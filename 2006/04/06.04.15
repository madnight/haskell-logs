00:00:38 <falconair> is there documentation on how to convert haskell type list comprehensions into fold/filter/map?
00:00:48 <lispy> newsham: is CChar a type?
00:01:14 <newsham> yah, the C* are native C types.
00:01:46 <lispy> okay, cool yeah i see Ptr CChar is char*
00:01:47 <lispy> sweet
00:02:18 <newsham> page 26 of ffi.pdf shows the C types
00:06:18 <lispy> newsham: so would sizeOf (0::Ptr CChar) do what i expect?
00:06:39 <newsham> should return 1.
00:06:40 <lispy> i want sizeof (char*)
00:06:46 <newsham> er.r.. i mean 4.
00:07:11 <sjanssen> lispy: I don't think you can change the number 0 to a Ptr
00:07:19 <newsham> i forget if you can just make a Ptr CChar.
00:07:41 <sjanssen> I believe sizeOf (undefined :: Ptr CChar) is the way to do it
00:07:42 <lispy> i just tested it in ghci but i get type errors
00:07:57 <lispy> sjanssen: heh, nice
00:07:59 <lispy> works
00:08:08 <newsham> ahh, if that works, please update the wiki "XXX" comment
00:08:10 <sjanssen> the undefined is okay because sizeOf is supposed to ignore it's argument
00:08:36 <lispy> newsham: hmm..shouldn't this be imported into the new wiki?
00:09:04 <newsham> if someone knows how and where please do.
00:09:07 <lispy> yeah, i'm not allowed to edit that page
00:09:32 <newsham> hmm.. how come?
00:10:37 <lispy> not sure, but taht was the message i got when i clicked on edit
00:10:59 <lispy> alignment x = (alignment $ nv_value x)
00:11:10 <lispy> nv_value is a function?
00:14:00 <newsham> ok, I updated the wiki
00:14:17 <newsham> nv_value is a function for the record NamedValue
00:14:28 <newsham> each field in the record makes an accessor function
00:15:15 <lispy> hmm...okay, so the formula is alignment x = (alignment $ <first field> x) ?
00:15:33 <lispy> i don't really know what alignment is...
00:16:13 <newsham> alignment says the storage alignment of the item.
00:16:34 <newsham> actually i think the program has a slight error.  the alignment of nv_name could be more restrictive on 64-bit systems
00:16:41 <newsham> since its a pointer...
00:17:09 <lispy> so how would i define alignment for my struct?
00:17:15 <newsham> alignment of a C structure is generally the same as the alignment of the most restrictive field.
00:17:26 <newsham> which is often 4-bytes on 32-bit systems.
00:17:44 <newsham> might be 8 on 64-bit systems
00:18:23 <newsham> in my example i'm basically saying "alignment of this structure is the same alignment of integers"
00:18:26 <lispy> i have alignment x = (alignment $ headers x) where headers :: Ptr CChar
00:18:33 <newsham> which is true for 32-bit systems I knwo of, but might not be true for 64-bit systems
00:18:37 <lispy> so i should be okay?
00:18:43 <newsham> lispy: thats probably pretty good.
00:18:50 <lispy> thanks
00:19:15 <newsham> alignment x = alignment (undefined :: Ptr CChar)
00:19:46 <newsham> (or you could use C2hs to generate the Storables for you)
00:20:53 <lispy> i only have one struct and one function
00:21:00 <lispy> i think C2hs might be overkill
00:21:55 <newsham> i think alignment of struct == alignment of a pointer is a pretty good 
00:22:54 <lispy> do i need to worry about const?
00:23:07 <lispy> ie, the C function is defined foo(const char*)
00:25:20 <newsham> const is just a promise that the function wont modify the buffer you pass in
00:25:33 <newsham> you can ignore that
00:25:56 <lispy> "Unacceptable result type in foreign declaration: IO CResponse"
00:25:59 <lispy> hm...
00:26:51 <lispy> no clue what it doesn't like :)
00:27:58 <newsham> C functions dont usually return fucntions
00:28:03 <newsham> not a Ptr CResponse?
00:28:12 <lispy> it should return a struct
00:28:41 <newsham> what system?
00:28:48 <lispy> what do you mean?
00:28:55 <newsham> what os, architecture, etc
00:28:55 <lispy> what OS?
00:28:59 <lispy> osx
00:29:01 <lispy> ppc
00:29:38 <lispy> typedef struct Response { ... } Response_t; Response_t fetch(const char*);
00:29:56 <lispy> then in haskell i built CResponse to match Response_t
00:29:58 <newsham> your calling convention probably returns a Response_t *
00:30:31 <newsham> (or perhaps the caller allocates the storage and passes in a Response_t * to the function)
00:30:37 <newsham> I'm not familiar with ppc calling convention
00:31:06 <xerox> 'morning
00:31:07 <lispy> does that mean this code won't be portable unless the C version explictly uses a pointer?
00:31:28 <lispy> BTW, it did compile when i change to IO (Ptr CResponse)
00:31:32 <lispy> i haven't tested it yet
00:31:43 <newsham> possibly.
00:31:59 <newsham> If FFI doesnt know about the structure returning calling convent
00:32:11 <newsham> then your code might have to encode the calling convention and be non-portable
00:32:27 <lispy> oh, i should proably have const char* -> CString huh?
00:32:29 <newsham> in general returning structs is considerd bad style 
00:32:45 <newsham> yah, CString will marshall your pointer and the data.
00:33:31 <lispy> okay, i'll rework the C code after i test this
00:35:49 <newsham> what are you up to, btw?
00:36:06 <lispy> i was trying to make a binding to libcurl
00:36:30 <lispy> someone mentioned we should do some wikipedia datamining in my research group
00:36:37 <lispy> so i was trying it out :)
00:36:51 <lispy> next i'll need an xml library but hopefully haskell has one
00:36:58 <newsham> no http fetching libraries for haskell?
00:37:20 <xerox> haskell.org/http
00:37:33 <newsham> http://www.cs.york.ac.uk/fp/HaXml/
00:38:44 <lispy> oh cool, i missed that
00:38:58 <Cale> sethk: sorry, yeah, if you want the thing which the monad is carrying around for you to be mutable, use state -- note that a ReaderT over IO which carries an IORef can still be quite useful -- the IORef itself doesn't have to change in order for the cell to be mutated
00:39:44 <lispy> hm..getting a linker error
00:40:00 <sethk> Cale, ok.  I think I can sequence things so that the map does not change
00:41:10 <lispy> i'm using --make but it's not finding _fetch..well that makes sense i never defined _fetch :)
00:53:01 <sethk> lispy, it should define it for you.  If it can figure out the types, why doesn't it just go ahead and implement the missing functions?  :)
00:56:05 <lispy> hehe
00:56:55 <lispy> i think i moved past that error, but now i'm getting some unusual undefined symbols, _printf$LDBLStub _ZCMain_main_closure and ___stginit_ZCMain
00:58:47 <lispy> oh...maybe i just have the wrong ghc line
01:02:37 <lispy> http://pastebin.com/661125
01:03:01 <lispy> i think that's the ghc line i want to run, but i wonder what it expects _fetch to be
01:03:41 <lispy> http://pastebin.com/661126
01:03:43 <lispy> that's the haskell source
01:13:04 <int-e> lispy: hmm. are you missing a -lcurl?
01:14:02 <lispy> int-e: if i leave that off i get different undefined symbols :)
01:14:21 <lispy> or...maybe i don't
01:15:03 <lispy> hmm...earlier i forgot it and got some different symbols, but now it doesn't seem to make a difference
01:15:05 <newsham> blah this plugin code isnt working
01:15:23 <lispy> newsham: i know the feeling :)
01:16:05 <lispy> if i change my import line then i get a different but corresponding undefined symbol
01:16:16 <lispy> so it's definitely my import that's killing it
01:18:57 <lispy> huh, i stopped using --make and it compiles
01:19:04 <lispy> $ a.out
01:19:05 <lispy> Bus error
01:19:13 <lispy> hehe, good thing haskell programs don't segfault
01:22:42 <newsham> hrm.. I am loading one symbol fine from the file, but the other symbol is failing.
01:26:02 <lispy> newsham: i think you were right about returning a struct
01:26:22 <lispy> newsham: i changed it to accept a pointer and return void and magically the bus errors have stopped
01:26:41 <newsham> cool.
01:28:09 <newsham> hmm.. cant get the type safe dyn loader to work
01:28:13 <newsham> but the non safe one seems fine
01:33:44 <lispy> @hoogle Ptr CChar -> String
01:33:45 <lambdabot> No matches, try a more general search
01:33:54 <lispy> @hoogle Ptr CChar -> CString
01:33:54 <lambdabot> No matches, try a more general search
01:34:07 <lispy> @hoogle Ptr CChar -> a
01:34:10 <lambdabot> No matches, try a more general search
01:37:05 <newsham> code works now.  yay.  HWS-WP.
01:37:42 <lispy> peakCAStringLen is what i need
01:38:23 <newsham> the ffi.pdf is a good place to look for those functions
01:38:53 <lispy> yeah
01:39:00 <lispy> that's wherei found it :)
01:39:15 <newsham> why not just use the http library?  seems easier at this point
01:39:15 <ski> @where ffi
01:39:16 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
01:39:47 <lispy> @break
01:39:47 <lambdabot> Unknown command, try @list
01:39:49 <lispy> er...
01:39:53 <lispy> @type break
01:39:55 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
01:40:12 <lispy> maybe i need a break and that was a slip :)
01:45:49 <araujo> Hello!
01:46:08 * araujo just read an article written in InterLingua
01:46:32 <lispy> how do a turn a CInt into an Int?
01:46:45 <lispy> i looked through the ffi.pdf but it's not obvious to me...
01:47:20 <int-e> fromIntegral would be my guess
01:47:27 <lispy> ah, worth a try
01:47:31 <lispy> i hadn't thought of that
01:50:20 <lispy> works, BTW
01:50:21 <lispy> thanks
01:52:44 <lispy> what was the function to get the commandline args?
01:52:58 <int-e> @index getArgs
01:52:59 <lambdabot> System.Environment
01:53:18 <lispy> oh, i just need to import then...
02:08:46 <dbrock> is there terminology to distinguish between functions that refer only their formal parameters and functions that refer to free variables?
02:09:26 <jyp> lambda-lifted
02:09:27 <ski> former is combinator, i think
02:09:39 <edwinb> A term with no free variables is 'closed' - is that what you mean?
02:12:22 <lispy> @index unsafePerformIO
02:12:22 <lambdabot> System.IO.Unsafe, Foreign
02:16:32 <xerox> Is a closure?
02:18:19 <araujo> geez, it'as almost 6am... where the time gone? :-)
02:29:29 <newsham> http://udp110165uds.hawaiiantel.net:8888/hws/
02:30:33 <boegel> araujo: maybe time to go to bed? :)
02:30:34 <ski> cool
02:31:34 <newsham> someone was saying that WASH has a web server?  looks just like web programming system to me
02:32:58 <newsham> what do most people usually use for building?  makefile? cabal? ghc --make <lots of args> ?
02:35:46 <Saulzar> I guess some of each, mostly 1 and 2, I'm a slacker still using 3...
02:36:04 <newsham> so cabal is sometimes a replacement for the make system?
02:36:09 <newsham> whats prefered?  
02:36:21 <Saulzar> I'd like to know too :)
02:36:59 <newsham> i shoul use cabal i imagine
02:37:01 <Saulzar> I think it's mainly just a packaging/installation system
02:39:13 <newsham> python has a system like that and its often used for "building" too
02:39:21 <newsham> (setup.py)
03:00:43 <musasabi> newsham: the new HAppS HTTP part can work nicely as stand alone.
03:09:12 <xerox> newsham: nice, what have you stetted up there on the web?
03:10:29 <xerox> sat up? whatver :-P
03:10:34 <newsham> set up.
03:10:39 <newsham> not sure what you mean.
03:10:57 <newsham> musasabi: thanks.  i'll grab that
03:11:18 <xerox> newsham: the page says "I'm running HWS... or I might be running HWS-WP..."
03:11:29 <newsham> its hws-wp at the moment.
03:18:26 <musasabi> newsham: I am using this code (uses HAppS) locally http://www.cs.helsinki.fi/u/ekarttun/haskell/HAppS-httpd/ (but e.g. the fileserving code is there only for the caching features, plain HAppS can do that)
03:19:15 <newsham> @hoogle fps
03:19:16 <lambdabot> No matches found
03:22:02 <newsham> musasabi: whats fps and where do I get it?
03:22:15 <xerox> ?google dons fps
03:22:15 <jyp> @where fps
03:22:17 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
03:22:17 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
03:22:30 <newsham> thank you
03:22:45 <jyp> cheers
03:33:07 <DeliQ> rasterfar: are you here ??
03:54:11 <newsham> musasabi: is there any documentation for getting set up and started?
04:00:08 <musasabi> newsham: HAppS or the httpd code ?
04:01:21 <musasabi> HAppS applications with MACID or just using the HTTP functionality or something entirely else.
04:08:52 <musasabi> grah. C++ is looking good from an angle as compared to Haskell. Need extendable types and fixed object layout in memory.
04:09:17 <musasabi> Of course I can just work with newtyped Ptrs but that feels dirty.
04:09:24 <eivuokko> Heh
05:06:54 <jip> good morning
05:08:45 <xerox> ?yow!
05:08:45 <lambdabot> I'm totally DESPONDENT over the LIBYAN situation and the price of
05:08:45 <lambdabot> CHICKEN ...
05:28:21 <mathrick> Cale: about?
05:29:53 <norpan> @yow
05:29:53 <lambdabot> Like I always say -- nothing can beat the BRATWURST here in DUSSELDORF!!
05:37:11 <bolrod> @arr
05:37:12 <lambdabot> I heard andersca is a pirate
05:47:24 <mahogny> hm. BRAT WURST, the american edition. for kids I guess
06:16:00 <mahogny> wx gurus: has anyone written new components in an external language using FFI? it seems I need the speed
06:49:59 <ndm> is there a good GHC profile viewer anywhere?
06:50:50 * ValarQ uses gv
06:52:04 <ndm> gv?
06:52:54 <ValarQ> GNU gv
06:53:06 <ndm> does that view the profile directly?
06:53:10 <ValarQ> no
06:53:56 <ndm> do you need to transform it in some way first?
06:54:45 <ValarQ> yeah, i think there is some converter in the ghc distribution
06:55:25 <ValarQ> ndm: http://www.haskell.org/ghc/docs/latest/html/users_guide/hp2ps.html
06:55:39 <ndm> thats only heap profiles, not time profiles
06:55:44 <ndm> i think...
06:55:52 <ndm> and it doesn't seem to come with the windows version either
06:55:58 <ndm> i might just write my own profiler
06:56:06 <ndm> * profile viewer
06:56:14 <ValarQ> ok
06:56:53 <Saulzar> It's not so bad with the time profiles though, since you can see them in order... 
07:09:31 <musasabi> Is there a good way to prettyprint rationals as decimal numbers with a given precision ?
07:10:47 <musasabi> Doubles lack precision so that way is out.
07:11:38 <Saulzar> Hmm, showFFloat and friends I think
07:15:49 <musasabi> Saulzar: Unfortunately they require a RealFloat and Rational is not a RealFloat. (tried that in the beginning)
07:16:53 <astrolabe> musasabi: I think writing your own wouldn't be too difficult.
07:18:13 <norpan> writing your own would be a nice exercise
07:18:13 <musasabi> astrolabe: that is possible, just seems like there should be a standard way of doing this.
07:18:31 <astrolabe> @hoogle fromRat
07:18:32 <lambdabot> Numeric.fromRat :: RealFloat a => Rational -> a
07:18:32 <lambdabot> Prelude.fromRational :: Fractional a => Rational -> a
07:18:53 <norpan> but you will lose precision if you convert to Double
07:19:20 <musasabi> denominator + numerator + loop with divMod of course works.
07:19:35 <norpan> divMod is a good function
07:19:42 <norpan> @hoogle divMod
07:19:43 <lambdabot> Prelude.divMod :: Integral a => a -> a -> (a, a)
07:19:48 <astrolabe> @hoogle showEFloat
07:19:49 <lambdabot> Numeric.showEFloat :: RealFloat a => Maybe Int -> a -> ShowS
07:19:54 <musasabi> astrolabe: my rational is 0.0 as double.
07:20:10 <norpan> multiply it by 10^yourprecision
07:20:15 <norpan> :)
07:20:18 <astrolabe> hmmm
07:21:53 <astrolabe> I can believe that that is a special enough case that there is no standard function for it.
07:24:25 <norpan> @doc Rational
07:24:26 <lambdabot> Rational not available
07:24:31 <norpan> @hoogle Rational
07:24:32 <lambdabot> Prelude.Rational :: type Rational
07:24:32 <lambdabot> Text.PrettyPrint.HughesPJ.rational :: Rational -> Doc
07:24:32 <lambdabot> Language.Haskell.TH.RationalL :: Rational -> Lit
07:24:59 <norpan> @doc  Text.PrettyPrint.HughesPJ.rational
07:24:59 <lambdabot> Text.PrettyPrint.HughesPJ.rational not available
07:25:10 <norpan> @doc  Text.PrettyPrint.HughesPJ
07:25:11 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Text-PrettyPrint-HughesPJ.html
07:26:02 <jip> it seems that ghc produces 386 executables. are there flags to enable things like mmx and simd instruction generation for better speed?
07:26:44 <astrolabe> ghc uses gcc
07:27:25 <norpan> you can use -fvia-c and pass flags directly to the c compiler
07:27:35 <jip> i thought that usage of gcc was only when using optional c code generation
07:27:59 <jip> yeah, but won't going through c throw away chances of advanced optimizations?
07:28:16 <astrolabe> I thought it always went through c
07:28:34 <norpan> no it produces machine code directly
07:29:06 <musasabi> -fvia-c => use C, -fasm => native code generation.
07:29:18 <vincenz> @seen dons
07:29:18 <lambdabot> dons is in #haskell. I don't know when dons last spoke.
07:29:30 <musasabi> without optimization -fasm is used, with -O -fvia-c is used.
07:30:25 <norpan> yes, if you have optimization on it goes via c
07:31:10 <jip> norpan: hm... interesting. how do i pass c compiler flags through?
07:31:28 <norpan> but you can try something like -fvia-c -optc yourgccoption
07:37:51 <Rob|dishes> jip: or you just generate the c code and then compile that with gcc
07:42:11 <Robokop> @hoogle FilePath -> String
07:42:12 <lambdabot> Distribution.Simple.Utils.mkLibName :: FilePath -> String -> String
07:43:07 <ndm> Robokop, FilePath is String
07:43:07 <jip> Robokop: hm...
07:43:11 <ndm> you can use them both the same
07:43:16 <ndm> type FilePath = String
07:43:17 <Robokop> ndm i know
07:43:37 <ndm> but hoogle doesn't know they are the same, it thinks they are different
07:43:38 <Robokop> ndm but i wanted justed the filename without the location
07:44:26 <Robokop> so i thought someone else wrote that function already but now i have to write it myself
07:44:43 <ndm> Robokop: everyone has written that function...
07:45:15 <Robokop> but it isn't in standard librarys
07:45:17 <Robokop> grr
07:45:36 <ndm> Robokop, http://www-users.cs.york.ac.uk/~malcolm/cgi-bin/darcsweb.cgi?r=yhc-devel;a=annotate_plain;f=/src/compiler98/Util/FilePath.hs;h=20060306000823-fbc8d-bf0f8bf2be5d35a3197902f676f5c855bdb9b5f7.gz
07:45:44 <ndm> there is a filepath module in Yhc
07:45:48 <ndm> just steal that
07:45:59 <Robokop> well it isn't that hard
07:46:13 <ndm> to be both windows and linux happy?
07:46:22 <ndm> there are a number of special cases
07:46:49 <ndm> getFileName in that module does what you want
08:11:31 <DeliQ> @seen dblhelix
08:11:32 <lambdabot> I saw dblhelix leaving #haskell-blah and #haskell 9 days, 59 minutes and 2 seconds ago, and .
08:16:18 <rasterfar> hey DeliQ: is your pm still open?  I was asleep when you msg'd me.
08:28:26 <DeliQ> rasterfar: msg'd you again :P
08:34:23 <jip> how do i use guards?
08:35:33 <xerox> <name> <args> | <guard> = <expr>
08:35:46 <xerox>               | <guard> = <expr>
08:35:57 <xerox>               | otherwise = <expr>
08:36:41 <mahogny> xample:
08:36:42 <mahogny> foo x | x>0 = x
08:36:42 <mahogny>       | otherwise = 0
08:36:51 <jip> ah, so it's "otherwise" i tried using _ thanks!
08:37:15 <toast> i don't quite get what we use maybe for
08:37:43 <mahogny> jip, that is more the case when you don't use | for pattern matching
08:37:57 <mahogny> toast, it flags if a variable is empty or not
08:38:32 <toast> thx
08:39:19 <xerox> toast: maybe is fromJust with defaulting.
08:39:26 <xerox> > fromJust Nothing :: ()
08:39:27 <lambdabot> Exception: Maybe.fromJust: Nothing
08:39:53 <xerox> > maybe 0 id Nothing :: Int
08:39:55 <lambdabot> 0
08:40:22 <mahogny> oooh. the function. that one looks lovely
08:40:30 <mahogny> much nicer than a case mess
08:45:19 <JohnnyL> how does l5 xs = foldinc 0 xs where inc x _ = x + 1 work?
08:46:13 <xerox> Do you mean foldl inc 0 xs ?
08:46:28 <JohnnyL> the whole thing.
08:46:55 <xerox> There's no such thing as foldinc.  Or is it defined somewhere in your code?
08:47:12 <JohnnyL> sorry foldl inc is correct.
08:47:19 <JohnnyL> i am looking at an example.
08:47:38 <xerox> I see it this way.
08:47:58 <xerox> The 'l' in "foldl" says that the accumulator is coming from the left, i.e. it's the first parameter in the "folded" function.
08:48:06 <xerox> That is, x, in your inc function.
08:48:22 <xerox> So it will start with 0, and add one for each element in the list.  I.e. length.
08:49:07 <JohnnyL> for each fold there is an inc x?
08:49:21 <xerox> Do you know how does foldl work?
08:49:28 <JohnnyL> not crealy no.
08:49:31 <JohnnyL> clearly
08:49:46 <xerox> Okay.
08:50:18 <xerox> foldl f k [1,2,3] = k `f` 1 `f` 2 `f` 3
08:50:29 <xerox> foldr f k [1,2,3] = 1 `f` 2 `f` 3 `f` k
08:51:21 <xerox> Is it understandable?
08:52:27 <JohnnyL> ok , so it applies f as iinfix against start k against each [list].
08:52:53 <JohnnyL> oh wait.
08:52:53 <xerox> Let's write it not infix to be sure.
08:53:06 <JohnnyL> what's k?
08:53:20 <ValarQ> JohnnyL: the initial value
08:53:21 <xerox> foldl f k [1,2,3] = (f (f (f k 1) 2) 3)
08:53:25 <JohnnyL> oh ok.
08:53:47 <xerox> Don't you see it in the formal parameters list?
08:54:25 <xerox> foldr f k [1,2,3] = (f 3 (f 2 (f 1 k)))
08:54:37 <Cale> foldl f k [1,2,3] = ((k `f` 1) `f` 2) `f` 3
08:54:38 <JohnnyL> okay, the scond def is much more cleary. ok so how does where combine with this fold function?
08:54:40 <xerox> Er... I'm not sure.
08:54:52 <qwr> > foldr (-) 0 [1,2,3]
08:54:54 <lambdabot> 2
08:55:27 <Cale> JohnnyL: hm?
08:55:42 <Cale> (I'm probably missing lots of context, just got here :)
08:55:53 <JohnnyL> k5 xs = fold inc 0 xs where inc x _ x + 1
08:56:20 <Cale> length
08:56:31 <JohnnyL> oh ok.
08:56:34 <Cale> > foldr (+1) 0 [1,2,3,4,5]
08:56:35 <lambdabot>  add an instance declaration for (Num (b -> b))
08:56:35 <lambdabot>   In the list element: 5
08:56:39 <JohnnyL> foreach inc x there is a fold?
08:57:12 <Cale> > foldr (const (+1)) 0 [1,2,3,4,5]
08:57:13 <lambdabot> 5
08:57:24 <Cale> > foldr (const (+1)) 0 "Hello"
08:57:25 <lambdabot> 5
08:57:35 <Igloo> where just allows you to define functions locally
08:57:41 <JohnnyL> > foldr (+) 0 [1,2,3,4,5]
08:57:44 <lambdabot> 15
08:57:52 <Igloo> It's equivalent to
08:57:58 <Igloo> inc x _ = x + 1
08:58:02 <Igloo> k5 xs = fold inc 0 xs
08:58:02 <JohnnyL> > foldr (const(+2)) 0 [1,2,3,4,5]
08:58:03 <Cale> The nicest way to look at foldr is that it replaces each (:) in the list with some function f, and the [] at the end with some value z
08:58:04 <lambdabot> 10
08:59:12 <Cale> > foldr (\x y -> concat ["(f ", show x, " ", y, ")"]) "z" [1,2,3,4,5]
08:59:14 <lambdabot> "(f 1 (f 2 (f 3 (f 4 (f 5 z)))))"
08:59:31 <Cale> > foldr (:) [] [1,2,3,4,5]
08:59:32 <lambdabot> [1,2,3,4,5]
08:59:57 <Cale> > foldr (\x y -> concat ["(", show x, ":", y, ")"]) "[]" [1,2,3,4,5]
08:59:58 <lambdabot> "(1:(2:(3:(4:(5:[])))))"
09:00:17 <Cale> I have some nice diagrams
09:00:44 <Cale> http://cale.yi.org/autoshare/folds.png
09:01:02 <Cale> (hopefully my dns is set correctly -- been having problems with the script that sets it)
09:01:10 <xerox> Cale: did you got around lending koxinelle the mathematica script? (-:
09:01:16 <Cale> yeah
09:01:26 <JohnnyL> Igloo :that fold only has one param of (inc 0 xs).
09:01:38 <Cale> did that last night just before going to sleep
09:02:17 <Cale> JohnnyL: basically, you're folding the function  const (+1), which is the same as \x y -> 1 + y
09:02:24 <Igloo> JohnnyL: No, it has 3 parameters: inc, o and xs
09:02:28 <Cale> which means that the elements of the list will be ignored
09:02:40 <Cale> but 1 will be added to the result in their place
09:03:31 <Cale> (look at the picture for foldr and imagine f being a function which ignores its left parameter and adds one to its right parameter, and z being 0
09:03:34 <Cale> )
09:04:07 <qwr> foldr f z []     =z
09:04:07 <qwr> foldr f z (x:xs) = f x (foldr f z xs)
09:04:22 <xerox> Cale: we have hawiki/CategoryTheory/Functor, but no CategoryTheory/Monad !!
09:04:23 <JohnnyL> Igloo, ok in the inline function of inc x like a iterator value?
09:04:32 <Cale> xerox: heh
09:04:33 <jip> hm... haskell code can grow into a real big mess if you aren't careful :\
09:04:55 <xerox> Cale: what can I suggest to read to a guy who asked for the category-theoretic-view of monads?
09:05:21 <Cale> xerox: Wikipedia and PlanetMath both have coverage of monads
09:05:43 <xerox> Great.
09:06:21 <Cale> JohnnyL: does the picture help any?
09:07:11 <JohnnyL> Cale, not not really, seems incomplete somehow.
09:07:20 <Cale> hmm
09:08:13 <jip> f limit n = if (n + 1) == limit then 0 else n + 1
09:08:20 <jip> is there something like that in the standard libraries?
09:08:25 <JohnnyL> foldr inc 0 xs goes through  each subelement of xs starting at 0 and appling inc, correct?
09:08:52 <Cale> jip: (`mod` limit) . (+1)
09:08:53 <JohnnyL> > foldr inc 0 [1,2,3,4]
09:08:55 <lambdabot>  Not in scope: `inc'
09:09:20 <jip> Cale: hm... cool thanks
09:09:25 <Cale> It replaces each (:) with inc
09:09:26 <xerox> JohnnyL: do you understand the let form?
09:09:32 <Cale> and [] with 0
09:09:38 <JohnnyL> > k5 xs = foldr inc 0 xs where inc x _ x + 1
09:09:39 <lambdabot>  parse error on input `='
09:09:51 <JohnnyL> > foldr inc 0 xs where inc x _ x + 1
09:09:52 <lambdabot>  parse error (possibly incorrect indentation)
09:09:54 <Cale> [1,2,3,4] is syntax sugar for 1 : (2 : (3 : (4 : [])))
09:10:11 <xerox> > let k5 xs = foldr inc 0 xs where inc x _ = x + 1
09:10:12 <lambdabot>  parse error on input `}'
09:10:20 <xerox> > let k5 xs = foldr inc 0 xs where inc x _ = x + 1 in k5 "hello"
09:10:21 <lambdabot>  add an instance declaration for (Num Char)
09:10:21 <lambdabot>   In the definition of `jqk':
09:10:21 <lambdabot>    jqk = let
09:10:27 <xerox> Whatever.
09:10:31 <Cale> > let k5 xs = foldr inc 0 xs where inc _ x = x + 1 in k5 "hello"
09:10:33 <lambdabot> 5
09:10:46 <Cale> (had the args to inc backwards)
09:11:23 <Cale> inc ignores its left parameter, because for implementing length, you don't care about the actual elements of the list
09:12:07 <Cale> (and from the diagram for foldr, you can see that the f's are taking the elements of the list as left parameter)
09:13:11 <Cale> > foldl (flip (:)) [] [1,2,3,4,5]
09:13:12 <lambdabot> [5,4,3,2,1]
09:13:52 * Cale wonders if Data.Tree is loaded
09:14:13 <Cale> > Node 5 []
09:14:15 <lambdabot> Node {rootLabel = 5, subForest = []}
09:14:31 <xerox> Yes it is!
09:15:26 <JohnnyL> what an interesting way to collaborate programming with multplie programmers.
09:15:35 <Cale> oh, well, I could use it, but the show instance is bad enough that I don't really care :)
09:17:22 <Cale> putStrLn (drawTree (foldr (\x y -> Node "f" [Node (show x) [], y]) (Node "z" []) [1,2,3,4,5]))
09:17:34 <Cale> you could try that in ghci though, after loading Data.Tree :)
09:18:01 <xerox> "How do I load Data.Tree?"
09:18:05 <xerox> ":m + Data.Tree"
09:18:07 <Cale> :m + Data.Tree
09:18:15 <xerox> (-;
09:24:31 <bolrod> :)
09:30:35 <JohnnyL> Cale, what's the order of operation for :  > let k5 xs = foldr inc 0 xs where inc _ x = x + 1 in k5 "hello"          ?
09:32:47 <xerox> let <foo> in <bar>
09:33:02 <xerox> <bar> is evaluated in the context of the bindings <foo>
09:33:25 <int-e> hmm. ghci is stupid: if invoked from the home directory, it sources the .ghci file twice ... is there a workaround for that?
09:33:36 <xerox> Which in turn is <name> <args> = <expr> where <quux>
09:33:50 <xerox> This time, <expr> is evaluated in the context of the bindings <quux>
09:35:02 <jip> oohh .ghci file? what's this?
09:35:20 <int-e> http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-dot-files.html
09:35:38 <jip> xerox: can you please post your .ghci? :)
09:35:39 <xerox> jip: a-la .bashrc
09:36:23 <xerox> No, it contains lines of code which are essential for my plan to take over the world, sorry.
09:36:57 <jip> :(
09:37:12 <jip> you can comment those out :P
09:37:24 <astrolabe> You have one of those plans too?
09:37:33 * int-e was going to add ':def m+ \r -> return $ ":m +" ++ r' ... but that results in a 'command 'm+' is already defined' for the reason explained above, which is ugly.
09:38:48 <xerox> ?pinky do we?
09:38:49 <lambdabot> Unknown command, try @list
09:38:54 <xerox> ?brain do we?
09:38:54 <lambdabot> I think so, Brain, but a codpiece made from a real fish would get smelly after a while, wouldn?t it?
09:39:10 <xerox> I always forget who's implemented.
09:40:50 <JohnnyL> xerox context is always referenced first?
09:41:15 <xerox> JohnnyL: lazily evaluated, but, mmmh.. yes?
09:41:41 <xerox> JohnnyL: in fact it's rather peculiar here, because it's all on one line.  Haskell has indentation rules.
09:42:26 <JohnnyL> @type inc
09:42:28 <lambdabot> Not in scope: `inc'
09:42:58 <xerox> ?type let inc x _ = x + 1 in inc
09:42:59 <lambdabot> forall a t. (Num a) => a -> t -> a
09:43:10 <xerox> ?pl inc x _ = x + 1
09:43:11 <lambdabot> inc = const . (1 +)
09:43:20 <jip> my program eats and eats and eats memory and never released it :(
09:44:12 <jip> oh wait forgot to compile with -O
09:46:22 <jip> argh, even with -O it sucks up ram
09:47:18 <jip> until it is finally Killed
09:47:24 <bolrod> creating large expressions?
09:48:00 <xerox> jip: profile it!
09:48:19 <mahogny> jip, space leak?
09:53:02 <jip> mahogny: i guess so, but i don't understand why
09:54:27 <JohnnyL> xerox why does 'inc _ x' have a '_' after inc?
09:54:41 <Cale> JohnnyL: because it ignores its first parameter
09:54:54 <Cale> _ is a pattern which matches anything and doesn't bind it to a variable
09:55:12 <JohnnyL> ok
09:55:26 <jip> xerox: this is really annoying... how do i profile it?
09:58:10 <xerox> Cale: when he asks you, I answer, when he asks me, you answer... we got to decide.
09:58:40 <JohnnyL> Cale/Xerox, so there 'where' is ultimately the driving local function in the following statement and gets top billing for the show expression? :  > let k5 xs = foldr inc 0 xs where inc _ x = x + 1 in k5 "hello"
09:58:48 * xerox grins
09:59:19 <JohnnyL> nw either you both answer, or non answer.
09:59:20 <xerox> JohnnyL: 'inc' exist between "let" and "in", but no further, do you see that?
09:59:20 <JohnnyL> haha
09:59:22 <Cale> k5 "hello"
09:59:41 <JohnnyL> yrd
09:59:45 <JohnnyL> yes
09:59:53 <Cale> yeah, that parses a little odd :)
10:00:00 <Cale> > let k5 xs = foldr inc 0 xs; inc _ x = x + 1 in k5 "hello"
10:00:01 <lambdabot> 5
10:00:15 <xerox> Nice one.
10:00:40 <Cale> maybe easier to read :)
10:03:15 <JohnnyL> Hey Khisanth, i'm in ny too.
10:03:22 <JohnnyL> so far thats 4 of us in here.
10:03:40 <Khisanth> 4 out of 8 million :)
10:03:48 <JohnnyL> hhehe.
10:14:17 <mnislaih> anyone remembers where do the pretty diagrams of foldr and foldl reside ?
10:15:28 <jip> hm.... the simple switch to unboxed arrays seems to have helped quite a bit
10:16:45 <xerox> mnislaih: sure.
10:17:05 <xerox> <http://cale.yi.org/autoshare/folds.png>
10:17:30 <mnislaih> thx
10:18:12 * xerox tips his hat
10:33:28 <Heffalump> there's no good idiom for abstracting record update functions, is there?
10:34:56 <Igloo> No
10:42:39 <musasabi> Heffalump: I use "type SF p r = (r -> p, p -> r -> r)", but having proper accessors would be much nicer.
10:43:53 <Heffalump> right, I just made something like that
11:04:06 <toast> data Maybe a = Nothing
11:04:06 <toast> | Just a
11:04:18 <toast> in this case
11:05:04 <toast> we could see Mayba a as a test, like : if (a == null) { nothing } else {}
11:05:14 <toast> meh
11:05:15 <musasabi> @seen shapr
11:05:16 <lambdabot> shapr is in #scannedinavian, #haskell and #ScannedInAvian. I last heard shapr speak 1 day, 3 hours, 56 minutes and 25 seconds ago.
11:05:31 <monochrom> I don't see that.
11:05:40 <musasabi> Anyone know of recent work in pure Haskell IP-stacks?
11:06:53 <JohnnyL> what happens when two function combine with '.'? ala: rootsOfPs2 = (map roots.filter real) ps 
11:07:32 <monochrom> f.g is the function that satisfies (f.g)x = f(g x)
11:08:01 <Robokop> @hoogle EventMouse
11:08:02 <lambdabot> No matches found
11:08:11 <Robokop> ke no wx for the bot
11:09:55 <JohnnyL> monochrom so x is applied as a parameter to g and g x is the parameter to f? i'm not sure i full understand.
11:10:57 <monochrom> http://www.vex.net/~trebla/weblog/pointfree.html   this may be an illuminating analogy.
11:11:58 <sethk> JohnnyL, well, technically, (g x) returns a function, and that function is the argument provided to f.  which is basically what you said but a hair different
11:12:54 <JohnnyL> monochrom, ok, so the output of one function is the input to another, correct?
11:12:58 <monochrom> yes
11:13:18 <JohnnyL> sethk, k thx.
11:13:33 <JohnnyL> sethK, there are now 4 people here from ny. Haskell Meet! :)
11:13:52 <sethk> I'm around
11:13:58 <norpan> g x returns a value, which may be a function
11:14:53 <monochrom> I wouldn't call "g x" a function either (without knowing g and x), but I suppose someone can call it an nth-order function where n may be 0.
11:15:20 <monochrom> I myself would call everything "value" when being unspecific.
11:15:57 <norpan> calling a scalar value a 0 order function is pushing it
11:16:10 <mahogny> expression?
11:18:30 <norpan> expression is ok
11:19:52 <monochrom> To digress, I don't like the math/physics convention of saying "the function x^2+sin(x)" and "the function f(x)".
11:21:18 <palomer> yeah, it's linguistically revolting
11:22:25 <mahogny> I don't like how mathematicians say f(x). it's obviously f x
11:23:53 <Robokop> mahogny: i don't like mathematicans at all
11:24:01 <mahogny> Robokop, ...thanks! ^_^
11:24:07 <monochrom> haha
11:24:23 <Robokop> mahogny: you are one of them?
11:24:29 <mahogny> Robokop, sorry :(
11:24:59 <Robokop> mahogny: yeah you ought to be sorry P:
11:25:01 <mahogny> I think this is the second time I've heard a CS dude attack mathematicians in my vicinity :)
11:25:43 <monochrom> And how many times have you heard a CS dude praise mathematicians?
11:25:56 <mahogny> hmmmm
11:26:03 * mahogny wonders if that has ever happen
11:26:13 <monochrom> Ok then I'll be the first one!
11:26:17 <mahogny> :o
11:26:27 <astrolabe> mathematicians are gods
11:26:32 <monochrom> I like mathematicians so much I joined them for four years!
11:26:34 <mahogny> o_O
11:26:35 <mahogny> lol
11:26:39 * Korollary shoots astrolabe with a tranquilizer gun
11:26:43 <mahogny> :D
11:26:48 * astrolabe is a mathematician
11:26:58 <mahogny> Korollary, big guns for big prey? :)
11:27:18 * astrolabe feels sleepy
11:27:28 <Korollary> mahogny: No, it's just my weapon of choice for astrolabe who is a sold out mathematician
11:27:40 <Maddas> mahogny: What's wrong with f(x)?
11:27:50 <mahogny> Maddas, it has lots of extra syntax!
11:27:52 <Maddas> > head ([1])
11:27:53 <lambdabot> 1
11:27:57 <Maddas> oh, just that, okay :-)
11:28:07 * Ulfalizer has a problem with mathematicians who present ideas in an unnecessarily complex way in order to show off
11:28:17 <Ulfalizer> and there seems to be many mathematicians of that kind =)
11:28:53 <mahogny> Ulfalizer, mathematicians usually hate overcomplicated proofs :)
11:28:57 <Korollary> Ulfalizer: No, but they just stand out when they do that.
11:29:20 <Korollary> aka recall bias
11:31:09 <Ulfalizer> mahogny: hrm, i should probably rephrase that. mathematicians who present material in a format that is unnecessarily hard to grasp is more like it.
11:31:40 <mahogny> Ulfalizer, that would be physicists if you ask me. they mess up our math :)
11:32:11 <BCoppens> mahogny: and engineers ;)
11:32:13 <Ulfalizer> it's not a general trait among mathematicians. it just seem to be quite common.
11:32:31 <mahogny> BCoppens, at times
11:32:56 <Robokop> well i hate how my profs try to explain some proof to me
11:33:09 <mahogny> BCoppens, the worst thing I know is when the proof comes before the theorem in books, and even worse when the proof is spread out in examples
11:33:13 <mahogny> Robokop, lol
11:33:17 <Robokop> first they come up with all kinda lemma's
11:33:24 <toast> head ([1,2])
11:33:25 <BCoppens> mahogny: ugh yeah :(
11:33:29 <toast> > head ([1,2])
11:33:30 <lambdabot> 1
11:33:31 <mahogny> Robokop, you prefer lemba?
11:33:37 <toast> > tail ([1,2])
11:33:39 <lambdabot> [2]
11:34:21 <Robokop> mahogny: what the # is lemba
11:34:29 <BCoppens> mahogny: or if they introduce new theorems and notations in examples or excercises
11:34:31 <mahogny> Robokop, never read LOTR? :)
11:34:36 <mahogny> BCoppens, omg
11:35:01 <Robokop> mahogny: well dit that but quite some time ago
11:35:14 <mahogny> BCoppens, one of my books (in lie algebra) has a chapter "devoted to the formalism that can be skipped if you prefer". I mean... uuhhh
11:35:19 <Robokop> mahogny: even before the three movies
11:35:31 <BCoppens> mahogny: lol :)
11:35:54 <mahogny> BCoppens, let's just say it is one of my top #3 most hated math texts
11:36:05 <Ulfalizer> i think proof is overemphasized in most books, especially in undergraduate mathematics. you don't need to understand how a tool is built in order to use it, though it might of course provide some valuable insight. anyway i think proofs should be relegated to an appendix for the most part.
11:36:17 * mahogny spanks Ulfalizer 
11:36:21 <mahogny> the proof IS the tool!!!
11:36:22 <mahogny> :)
11:36:38 <Ulfalizer> nah, hardly always
11:36:40 <Robokop> mahogny: i agree with that
11:36:45 <Korollary> You need to like proofs if you ever want to make new tools.
11:36:50 <mahogny> but undergrad math is usually thaught in a way not emphazining that aspect of math which sucks
11:36:52 <astrolabe> It depends whether you think of maths as a means or an end.
11:36:52 <BCoppens> mahogny: that's not a good thing then :-(
11:37:14 <mahogny> *emphasizing
11:37:25 <mahogny> astrolabe, indeed
11:37:37 <Robokop> > 201759 `mod` 850
11:37:38 <lambdabot> 309
11:37:40 <mahogny> astrolabe, but if you intend to go for an msc, it should be all means not be the end
11:37:47 <mahogny> *by
11:38:10 <Ulfalizer> Korollary: yes, but that is something you can learn later on. proofs just makes the material seem a lot more complex to beginners in math.
11:38:29 <Korollary> Ulfalizer: The material is inherently complex, tho.
11:38:43 <Robokop> > 201759 `div` 850
11:38:45 <lambdabot> 237
11:38:51 <mahogny> Ulfalizer, one should learn proofs and examples at the same time. proofs give understanding of how it works, examples show why the results are useful
11:39:01 <Ulfalizer> it is, but you shouldn't make it more complex than it is through n unnecessarily complex presentation.
11:39:27 <mahogny> Ulfalizer, if the presentation is complex, then either the teacher sucks or the presentation couldn't have been made simpler :)
11:39:29 <astrolabe> I find maths easier if I see the proofs.  I things are easier to understand and remember if you know the reason they are true.
11:39:44 <mahogny> indeed
11:39:46 <Ulfalizer> mahogny: many things can be very useful even if you take them as axioms and never prove them
11:40:09 <mahogny> Ulfalizer, yes. but some insight into why things are like they are can make you much better at using the tools
11:40:13 <BCoppens> but proofs can give you insight as to why stuff is true, so you remember it better
11:40:49 <Korollary> I skip proofs that are obvious and tedius to me. I have to follow the rest or else I dont consider the subject understood.
11:40:49 <mahogny> Ulfalizer, if you understand the concept you are dealing with, the proof should be simple and vice versa. you can't go on without the concept so one better just deal with it
11:41:01 <Ulfalizer> yes, that's true, but i still think proofs are overemphasized in introductory courses. it is something that comes more natural later on once you have some experience.
11:41:18 <mahogny> Ulfalizer, proofs should come already in grade 9
11:41:28 <mahogny> *grade=year
11:41:40 <Ulfalizer> i think that would be a very bad idea
11:42:22 <mahogny> it would be great. right now, proofs knock down students because they aren't used to them, and suddenly they drown in them at university
11:42:45 <mahogny> and basic proofs have uses outside mathematics; it is about understanding structured reasoning
11:43:11 * astrolabe agrees
11:43:28 <monochrom> Proofs represent a valuable and necessary way of thinking.  If students are not used to them, that is more reason to study them.
11:43:29 <Ulfalizer> i think thorems should be motived, but not necessarily proven
11:43:41 <astrolabe> maths without proofs would be like botany.
11:43:50 <mahogny> Ulfalizer, I can agree on that. you don't have to do picky details that are obvious
11:43:59 <Ulfalizer> and many proofs don't add much once you have the intuition for some theorem
11:44:05 <mahogny> but note the word "obvious"
11:44:54 <mahogny> Ulfalizer, you also have to remember that it might be very hard to do your own proofs unless you know a set by head already
11:45:34 * mahogny remembers the course where he was assumed to learn some 200 proofs by head :(
11:46:02 <Ulfalizer> present some theorem -> give some motivation -> let students get familiar with the applications by solving a few exercises -> prove the theorem if the proof provides additional valuable insight. that's the approach i used when i was a teaching assistans at the local high school, and it seemed to work very well.
11:46:20 <mahogny> Ulfalizer, that is a good one
11:46:24 <BCoppens> mahogny: :o that's a lot, but I assume that some looked similar then?
11:46:25 <Ulfalizer> i got an e-mail yesterday from some students who wanted me back because their current teacher sucks =)
11:46:44 <BCoppens> =)
11:46:58 <mahogny> BCoppens, you had to up your level to the degree that you could invent own proofs for the greater extent of them
11:47:09 <mahogny> as usualy
11:47:12 <mahogny> -y
11:47:21 <BCoppens> yeah I can imagine that that'd be required as well
11:47:56 <mahogny> functional analysis. I like the subject but it is soooo formal at times
11:48:18 <xerox> Wow.
11:48:46 <BCoppens> mahogny: that's not something that shows up a lot on cs, right?
11:48:49 <Ulfalizer> i think it's a bad to prove/derive the theorem at the same time you introduce it. they'll remember it much better if they first get some experience working with the theorem.
11:48:51 <mahogny> monochrom, btw which field did you study?
11:48:54 <Ulfalizer> +idea
11:48:58 <mahogny> BCoppens, read: never :)
11:48:59 <monochrom> formal methods
11:49:06 <mahogny> monochrom, which kind?
11:49:06 <BCoppens> mahogny: heh, I guessed as much =)
11:49:35 <monochrom> the program derivation kind
11:49:41 <BCoppens> mahogny: I usually at least vaguely can associate something with random maths directions, but I couldn't think of anything with that :)
11:49:45 <mahogny> BCoppens, well, if you are into _computational_ science, then it shows up all the time. it is the foundation for the past 100 years of engineering math
11:50:04 <mahogny> monochrom, found out anything useful? :)
11:50:20 <musasabi> it is annoying to work with the examples first approach. Much nicer to first see the proof/rules and then look at the examples and how they work and give motivation to various points of the proof.
11:50:27 <Ulfalizer_> bleh, damn isp
11:50:29 <BCoppens> mahogny: interesting :) *looks at wikipedia*
11:50:51 <mahogny> musasabi, I think that depends on the students
11:51:00 <mahogny> BCoppens, also known as real analysis
11:51:06 <mahogny> kind of the same
11:51:07 <monochrom> It is useful to have the option of looking at a functional program from the derivation perspective.
11:51:31 <mahogny> monochrom, yeah. I love semantics. I use it all the time when I design programs
11:51:36 <BCoppens> mahogny: ah the individual names on wiki do ring bells, but the common title didn't :)
11:51:57 <mahogny> monochrom, programs that haven't been formally proven to work should be banned in law :)
11:52:08 <mahogny> BCoppens, it's a huge field
11:52:23 <monochrom> That is why we need more proofs in classes.
11:52:39 <mahogny> BCoppens, banach spaces, hilbert spaces and the lebesgue integral are related
11:53:18 <BCoppens> mahogny: so I see, sounds not really trivial ;)
11:53:32 <monochrom> The theorems may be unworthy for proving, but the proofs are worth learning.
11:53:35 <JohnnyL> hey..is comma in a list comphrension like a function combiner?
11:53:44 <mahogny> BCoppens, actually, it is really pure, elegant and nice. hence why it became the foundation for all our math ;)
11:53:55 <mahogny> monochrom, yeah, at times
11:53:57 <monochrom> yes JohnnyL.
11:54:04 <BCoppens> mahogny: too bad there don't seem to be textbooks liked to by the wiki, usually I download them and then read the first chapter of it when I'm bored :)
11:54:10 <BCoppens> mahogny: hehe :)
11:54:21 <Ulfalizer_> another issue with undergraduate math books is that they often state definitions without giving any motivation as to why that definition is useful. motivating definitions is at least as important as proving theorems.
11:54:23 <mahogny> monochrom, depends on if you are a mathematician or yet-another-support-engineer :)
11:54:52 <mahogny> BCoppens, Introduction to hilbert spaces, Mikusinski, or a similar title with a similar name. that is an easy text
11:55:07 <mahogny> Ulfalizer, yes
11:55:09 <BCoppens> mahogny: and that's available online?
11:55:13 <mahogny> BCoppens, dunno
11:55:36 <mahogny> BCoppens, if you want a book that goes deep, but which hits you in the head, try Real Analysis by Folland
11:56:04 <mahogny> Ulfalizer, problem is, at times the definitions are there because of proof technicalities. at those times you are pretty much fucked as a teacher
11:56:23 <Ulfalizer_> matrix multiplication is a very good example. most books just say "this is how it's done" and leave it at that, giving the reader the feeling that definitions magically spring from thin air.
11:56:34 <mahogny> yeah
11:57:23 <BCoppens> mahogny: thanks :)
11:57:55 <BCoppens> hopefully I won't forget that by the next time I'm in the bookstore :)
11:57:57 <monochrom> The world needs more functional programming.
11:58:08 <mahogny> indeed
11:58:30 <mahogny> not everything fits well in FP, but way more than it is used for today
11:58:35 <monochrom> After knowing some functional programming, people know function composition, and then they will be ready to buy matrix multiplication.
11:58:48 <mahogny> hmm. dunno
11:59:12 <mahogny> a friend got serious problem with going from recursive definitions in haskell to induction proofs. he wanted to write haskell code all the time :)
11:59:48 <monochrom> That haskell code can be translated to Coq, and then you do have an induction proof.
12:00:08 <Lemmih> xerox: Hiya.
12:00:25 <mahogny> monochrom, I wanna see the face expression of the teacher when you hand in the code
12:00:45 <xerox> Hey Lemmih.
12:02:47 <jip> should i try to use list comprehension or should i use map everywhere?
12:02:57 <norpan> you decide
12:03:02 <monochrom> toss a coin
12:03:03 <Ulfalizer_> mahogny: more useful than writing a definition and proving some theorems would be to present a situation where you can clearly see the need for the tool in question, thus motivating its introduction. the problems with just proofs is that they often do not provide insight into why you would want to prove the things in question.
12:03:05 <mahogny> jip, what are the design criteria?
12:03:11 <jip> mahogny: i don't know
12:03:25 <mahogny> Ulfalizer, yes. the proofs by themselves does not motivate anything
12:03:26 <Ulfalizer_> -s
12:03:27 <norpan> that's why we have programmers; to make these choices
12:03:34 <mahogny> jip, in that case, go with the coin
12:03:45 <monochrom> use list comprehension.
12:04:34 <mahogny> my default design criteria unless someone else makes any, are code readability and maintainability, then provability and bug prevention. the design is usually clear then
12:04:43 <mahogny> *design choice
12:04:58 <Fir> instruction Google Adsense-->  http://planet.nana.co.il/hartk2003/en.htm                 Download free Firefox® -->  http://planet.nana.co.il/hartk2003/Firefox.htm
12:05:06 <jip> problem is i don't really get how to do list comprehension
12:05:21 <norpan> map f list is clearer than [ f a | a <- list ]
12:05:25 <mahogny> jip, then it is time to learn. they are too useful to not be known :)
12:06:16 <DeliQ> i'm making some functions on first order predicates, and now i'm gonna make a substitution function, but bounded variables may not be substituted, and i have no idea how to do it
12:06:20 <JohnnyL> monoschrom, so as soon as haskell leaves context from within a function combiner binding in a list comphrension it combines the results?
12:06:30 <DeliQ> does somebody have an idea ?
12:06:44 <JohnnyL> BCoppens, what your looking for dead tree haskell sources?
12:07:16 <Pegazus> <norpan> map f list is clearer than [ f a | a <- list ] --> that's your opinion
12:07:19 <monochrom> I don't understand.  This is very vague philosophy.
12:07:20 <mahogny> DeliQ, keep a list of bound variables when you recurse, and check that one each time you are about to substitute?
12:07:28 <BCoppens> JohnnyL: hmmm what?
12:07:37 <DeliQ> yes that's possible ..
12:08:14 <DeliQ> maybe i should a function that get's all the bounded vars out of a predicate
12:08:18 <JohnnyL> BCoppens, i was referring to : mahogny: too bad there don't seem to be textbooks liked to by the wiki, usually I download them and then read the first chapter of it when I'm bored :)
12:08:47 <Fir> instruction Google Adsense-->  http://planet.nana.co.il/hartk2003/en.htm                 Download free Firefox® -->  http://planet.nana.co.il/hartk2003/Firefox.htm
12:08:49 <BCoppens> JohnnyL: heh ;)
12:09:12 <BCoppens> JohnnyL: I'd prefer non-dead tree textbooks to the dead tree variants ;)
12:09:13 <mahogny> JohnnyL, dead tree haskell sources? o_O
12:09:22 <Ulfalizer_> the definition-theorem-proof approach sometimes feels akin to giving someone a tool that carves out little half-spheres from a surface, proving to the person that the tool indeed under all circumstances produces pretty spheres, and then leaving without telling the person why someone wanted such a tool in the first place; what it can be used for :P
12:09:58 <mahogny> Ulfalizer_, I can't help being reminded about the banach-tarski paradox when you say that :P
12:10:07 <Ulfalizer_> mahogny: what is it?
12:10:27 <mahogny> Ulfalizer_, you carve out a few peas from the earth, and then make another bigger earth out of them
12:10:54 <Ulfalizer_> ok, i'll look into it :)
12:11:05 <mahogny> Ulfalizer_, integration theory stuff :)
12:13:20 <monochrom> Ulfalizer_: the literature classes feel like reading some rant that has no obvious purpose, then trying to give it a purpose, and that's when I decide math is better.  While both have probably little purpose, at least the latter does not require making one up.
12:13:54 <mahogny> monochrom, lol
12:14:38 <Ulfalizer_> monochrom: i have nothing "against" mathematics in general, i just think it's often taught in a sub-optimal way
12:14:59 <mahogny> mathematics is best teached outside the mathematics class
12:15:48 <Ulfalizer_> it's not a disadvantage if it's taught well in the schools as well..
12:16:23 <vitriol_> mathematics is taught outside a class?
12:16:32 <mahogny> when I say that, I mean that it should be integrated in other classes
12:16:51 <mahogny> most notable the swedish physics education lack a real mathematics part
12:17:14 <JohnnyL> am i right in saying that in :  let k5 xs = foldr inc 0 xs where inc _ x = x + 1 in k5 "hello"  the binding order is 1) {after in} 2) {after let but before =} 3) takes a peek at before where 4) resolves after where 5) binds to fold.
12:17:38 <mahogny> heck, while we are at it, why not define sentences mathematically in the language class? :)
12:17:41 <vitriol_> i'm not sure where else one would teach number theory
12:18:17 <mahogny> vitriol_, that must be one of the most useless subjects I know. luckily I'm not saying that in #math which would cause me to be shot at sight :)
12:19:11 <vitriol_> mahogny, I suppose you have never had to use http over a secure connection then
12:20:16 <monochrom> If you think of a purpose/use of math as being aesthetics, you would treat it as music and wouldn't ask why someone would want the theorems.  (Why would someone want a symphony?)  Now yes the education process is dry, but do you know how many years of dry practice before a musician finally can perform/compose aesthetic music on the stage?
12:20:20 <mahogny> vitriol_, you have to go pretty deep into that subject before you need to consider that stuff as anything but black boxes
12:21:04 <xerox> So true.
12:21:07 <mahogny> vitriol_, there are probably few areas of math which aren't used for something, but number theory is probably one that is least use
12:21:11 <mahogny> *used
12:21:24 <BCoppens> mahogny: can't you use number theory in coding theory?
12:21:30 <mahogny> you can
12:21:46 <mahogny> simpler ones are for example related to latin squares
12:21:48 <BCoppens> well, that's a nice and practical use for it, isn't it ;)
12:21:58 <jip> if i have an infinite list, how can i cause the first "error" to be triggered?
12:21:59 <vitriol_> mahogny, if there was no number theory there would be no useful, modern cryptography. that's a huge application.
12:22:01 <Ulfalizer_> monochrom: it's not the dryness that's the problem. it's the effectiveness in getting concepts across. i'm strictly after efficient teaching.
12:22:12 <jip> right now i'm printing all of the elements but it's very slow
12:22:13 <mahogny> BCoppens, that's something I don't do on a daily basis though. or even yearly :)
12:22:30 <xerox> I must say that Internet makes the education process "less dry" somehow.  It democraticizes the knowledge, getting different people together, which means different knowledges, and thoughts.
12:22:40 * xerox hugs the channel
12:22:40 <BCoppens> mahogny: yeah but I guess people specialized in that area might do that on a daily basis :)
12:22:45 <Ulfalizer_> math is currently often taught in an ineffective way, because many (needlessly) don't understand the concepts because of the way they are presented
12:23:04 <mahogny> vitriol_, as I said, no part of mathematics are unused. but some are used way more often than others. while cryptography is big, the actual mathematics content is low
12:23:11 <mahogny> BCoppens, obviously
12:23:28 <mahogny> BCoppens, number theorists probably use it quite often too :)
12:23:45 <BCoppens> yeah ;)
12:23:53 <monochrom> I say the student expectation is the cause.  They expect use when there is really just music.  If their expectation is wrong, there is no efficient communication.
12:24:04 <vitriol_> mahogny, asymmetric cryptography is entirely based on number theory. that's a far stretch from it being 'useless'
12:24:14 <Ulfalizer_> mahogny: heh, i once heard a story about a mathematician who switched field from having done research on complex numbers once someone found practical use for them =)
12:24:27 <mahogny> vincenz, I said I agree :)
12:24:39 <mahogny> Ulfalizer_, lol
12:24:43 <BCoppens> Ulfalizer_: :D
12:25:04 <mahogny> I know a musician who refuses to call himself a musician because Rammstein does :)
12:25:27 <vitriol_> the interesting thing about number theory is that it was useless for thousands of years, and now is incredibly useful
12:25:35 <vitriol_> if noone had pursued number theory we wouldn't  have any mathematics
12:25:37 <Ulfalizer_> monochrom: i know the classes where i was a teaching assistant did much better on the tests than the other classes. i think i have a nack for presenting things in a way most people can understand.
12:25:59 <Ulfalizer_> and that's efficient teaching
12:26:23 <newsham> hi
12:26:33 <mahogny> vitriol_, number theory tend to pop up a little everywhere. I know a proof in markov theory that depends on a simple number theory statement. that said, I still would say that it is one of the least common theories in application :)
12:26:48 <mahogny> Ulfalizer_, that depends on the tests
12:27:00 <monochrom> Yes, you change the nature of the subject to suit their expectation.  They expect applications, you give them applications.  I'll give you more credit if you can change their expectation instead.
12:27:15 <mahogny> Ulfalizer_, I know lots of people that score better than me on tests, but they all come to me when they have questions :P
12:27:22 <BCoppens> hehe =)
12:27:39 <mahogny> why? because they can solve excersises but they know jack about the theory
12:27:43 <mahogny> *c
12:28:05 <Ulfalizer_> mahogny: i didn't know how the tests were laid out though, and i doubt even the better students got more out of the other classes
12:28:07 <vitriol_> mahogny, arg.
12:28:24 <mahogny> Ulfalizer_, well, I can't judge your students without seeing them in action either
12:28:35 <Ulfalizer_> i presented the same material that everyone else did, just in a more sensible way
12:28:51 <mahogny> Ulfalizer_, but it is common to see students that can use what they have but have no clue how it works under the hood
12:28:52 <Ulfalizer_> you need to be aware of your target group
12:28:56 <mahogny> Ulfalizer_, at least here
12:29:14 <mahogny> Ulfalizer_, that might be ok in some cases, but for engineers, I think not
12:29:38 <Ulfalizer_> often it's not that important to know how something works under the hood if it means you get less time to present and motivate other importat concepts
12:29:45 <vincenz> mahogny: with what?
12:29:51 <mahogny> vincenz, math
12:29:57 <vitriol_> mahogny, so it's not useless, just less useful than other areas of maths
12:29:57 <vincenz> o.O
12:30:00 <vincenz> mahogny: what?
12:30:06 <mahogny> vincenz, ehr. desynched
12:30:39 <Ulfalizer_> by "works under the hood" i mean proving. providing an intuitive grasp of how/why something works is often very important.
12:31:00 <mahogny> vincenz, when I say useless, I mean useless to the common engineer. specialists have use of it, but the rest can spend their days happily not knowing about it, just using what has already been applied
12:31:17 <Ulfalizer_> it all boils down to getting ideas across, and i think i was better at that than many of the other teachers
12:31:28 <mahogny> Ulfalizer_, when I say under the hood, I also include the intuition
12:31:48 <mahogny> Ulfalizer_, these students know jack about the concepts. but they can solve typical excercises
12:32:26 <Ulfalizer_> i opted for making my students understand the concepts instead of learning to solve common test problems
12:32:34 <mahogny> that is the way
12:32:53 <mahogny> priorities are #1, concept #2, examples and proof, order depending on target group
12:33:02 <Ulfalizer_> the same thing the other teachers did, but in a better (imho) way considering the target group
12:34:11 <mahogny> bbl
12:34:53 <Ulfalizer_> ideally all teachers should be judged by how well they manage to get concepts across. i don't think it necessarily follows that you provide less value to the more advanced students if you present the material in a way that more students can understand.
12:35:34 <JohnnyL> 75 megs for a mouse driver.
12:35:40 <Ulfalizer_> JohnnyL: nice..
12:35:45 <Ulfalizer_> logitech? :)
12:35:50 <JohnnyL> yeppers
12:37:43 <newsham> dons around?
12:37:50 <newsham> ?seen dons
12:37:51 <lambdabot> dons is in #haskell. I don't know when dons last spoke.
12:40:16 <JohnnyL> maybe DonsSpoke | Just DonsSpoke
12:40:57 <newsham> dont try to Justify
12:42:26 <Oejet> http://pastebin.com/661965   Where did the lazyness go?
12:42:39 <vincenz> mahogny: WHAT?
12:42:40 <JohnnyL> can sources appear on either side of 'where' but not mixed?
12:42:51 <vincenz> mahogny: I have _no_ idea what you're talking about
12:42:55 <vincenz> mahogny: wrong person?
12:43:40 <Korollary> Oejet: The files could still be open
12:43:56 <Oejet> Ah, it's run from ghci.
12:44:20 <monochrom> ah
12:44:39 <newsham> isnt readfile a bit excessive for file lengths?
12:44:45 <Oejet> But why should it even touch readFile, when it's not needed?
12:44:51 <vincenz> mahogny: please use the correct tabcomplete
12:44:59 <Oejet> newsham: Yes, but I'm just warming up. ;-)
12:45:01 <monochrom> The IO monad is mostly eager
12:45:17 <vincenz> monochrom: yes like a ...
12:45:34 <monochrom> If you use unsafeInterleaveIO you can introduce some laziness or delay.
12:46:09 <Oejet> Maybe I should just close the file before returning the length...
12:46:15 <xerox> > (map (drop 2) (repeat [1,2,3])) !! 1000000
12:46:17 <lambdabot> [3]
12:46:20 <newsham> why not just stat instead
12:46:52 <monochrom> I don't understand why readFile won't close.
12:47:30 <monochrom> Oh haha, because "return (length c)" is lazy.
12:47:32 <Oejet> newsham: Warming up to do some other statistics on the content.
12:48:56 <monochrom> Or more precisely "length c" is lazy, the files are never read and closed.
12:49:45 <xerox> return (length c `seq` length c)
12:49:54 <monochrom> http://pastebin.com/661982
12:50:10 <xerox> Right.
12:50:17 <monochrom> return (length c `seq` length c) will still be lazy
12:50:28 <xerox> Hoping for CSE :-)
12:51:19 <Oejet> monochrom: Good, good.
12:51:33 <Oejet> xerox: What's CSE?
12:51:43 <xerox> Common Subexpression Elimination
12:52:30 <mwc> sethk raised an interesting point over on libraries@haskell.org
12:52:31 <Oejet> xerox: GHC doesn't do that, I've read somewhere.
12:52:57 <mwc> Concerning the exportability of materials at haskell.org/crypto
12:53:06 <Ulfalizer> nope, it doesn't
12:53:33 <sethk> mwc, haven't seen any answers yet
12:53:35 <mwc> if haskell.org is a USA server, do they need to add a no-export-to-iran-etc disclaimer
12:53:37 <xerox> http://haskell.cs.yale.edu/haskellwiki/GHC:FAQ
12:53:50 <xerox> This says that in general GHC doesn't do it.
12:53:51 <mwc> or should we move the source to a Canadian server (no export restrictions)
12:54:19 <sethk> mwc, I'd be in favor of the simpler solution, and canada sounds simpler to me
12:54:59 <mwc> FWIW, I think the UK is as liberal as Canada on crypto export. You might be able to sidestep the whole issue by having Dominic send you a tarball by email.
12:55:20 <mwc> unless you're an american, in which case you can't export it yourself anyways
12:55:20 <sethk> mwc, yes
12:56:27 <sethk> mwc, if there is a server and I can say "download from X", be in Canadian or British or whatever, that is a reasonable way to handle it.
12:56:49 <newsham> you arms dealers
12:56:54 <newsham> wreaking global havoc
12:57:03 <mahogny> vincenz, sorry lol
12:58:39 <mwc> sethk, I'm certain about Canada's export restrictions, that's why OpenBSD is served from there. I'm not certain about the UK's. 
12:58:55 <sethk> mwc, k, thanks for the info
12:59:10 <mahogny> mwc, uk has export restrictions?
12:59:16 <Oejet> monochrom: xerox: Korollary: Thanks.
12:59:24 <xerox> You're welcome.
12:59:50 <sethk> mahogny, he said he doesn't know the uk situation for certain
12:59:59 <mwc> mahogny, not sure if they do
13:00:00 <Oejet> xerox: Btw. your code line looked almost like Scheme. :-P
13:00:10 <mwc> some governments restrict the export of strong cryptography
13:00:15 <mwc> http://en.wikipedia.org/wiki/Export_of_cryptography
13:00:25 * xerox boggles
13:02:11 <Oejet> (map square (upto 1 3))  <-- Is it Haskell, is it Scheme?  Nobody knows...
13:02:20 <mahogny> http://en.wikipedia.org/wiki/Wassenaar_Arrangement   seems these countries might have some sort of restriction. but canada is there to take it with a pinch of salt
13:02:40 <xerox> s/upto/enumFromTo/1
13:03:02 <mwc> mahogny, I'm not sure how our [Canadian] laws work, but I do know that the openbsd project can distribute anything to anyone
13:03:16 <mwc> and they've got a lot of strong crypto
13:03:36 <newsham> expected type [American] at line 2.
13:04:53 <monochrom> (map square (upto 1 3)) looks like scheme
13:05:13 <mwc> the outermost brackets have that effect for me as well
13:05:31 <monochrom> But enumFromTo changes my mind! XD
13:07:10 <jip> if it were haskell, upto 1 3 might instead be [1..3]
13:08:24 <mauke> @pl upto a b = [ a .. b ]
13:08:25 <lambdabot> upto = enumFromTo
13:11:11 <JohnnyL> in [x | x <- [0.100], odd x] how does haskell know to do [1.100] first?
13:11:53 <sethk> JohnnyL, it doesn't, exactly.  something says "give me a value" and it churns out a value
13:12:02 <mauke> because you wrote it first?
13:12:14 <sethk> JohnnyL, so it says get a value, is it odd?  no?  get another value .. is it odd?  yes?  then it stops
13:12:44 <sethk> or, as mauke says, because you told it to.  :)
13:16:49 <monochrom> The expression "odd x" will force "x" to be resolved first.
13:21:15 <JohnnyL> monoschrom, ok, that's clear. thanks guys.
13:21:49 <JohnnyL> haskell isn't very efficient is it?
13:21:55 <JohnnyL> or at least these functions aren't.
13:22:42 <mahogny> it can be
13:22:58 <sethk> there is some overhead associated with laziness, which is well known
13:23:02 <mahogny> it can beat C if you really want to. but code readability might be ... uh. nonexistent
13:23:48 <JohnnyL> mahongy, lot's of monads for that sort of competition?
13:25:09 <mahogny> JohnnyL, lots of seq, unboxing, IO and mutability down that road, yes. but there are cases when lazyness alone make things faster
13:25:29 <jip> and haskell is almost always a shitload faster then python and ruby :P
13:26:07 <resiak> (I thought you'd said "almost a shitload", and I was wondering how you defined a speed increase of exactly one shitload, but then I reread the screen.)
13:27:42 <JohnnyL> ah ha so it's a matter of speed versus readabilty.
13:27:48 <vincenz> jip: not if you put a lot of infinite loops
13:28:19 <jip> yeah, python seems to have got some really good optimizations for infinite loops :\
13:29:02 <vincenz> yeah
13:29:13 <vincenz> jip: you never claimed the code had to be equal
13:29:21 <vincenz> I assumed only the haskell version would have infinite loops
13:29:46 <JohnnyL> > let h = f [2.3.4] [5.,6] where f xs ys = [x*y | x <-xs , y<- ys]
13:29:47 <lambdabot>  parse error on input `,'
13:30:23 <JohnnyL> > let h = f [2,3,4] [5,6] where f xs ys = [x*y | x <-xs , y<- ys] 
13:30:23 <lambdabot>  parse error on input `}'
13:30:25 <vincenz> > let h = f [2.3.4] [5.,6] where f xs ys = [x*y | x <-xs , y<-ys] in h
13:30:26 <lambdabot>  parse error on input `,'
13:30:35 <vincenz> > let h = f [2,3,4] [5,6] where f xs ys = [x*y | x <-xs , y<-ys] in h
13:30:37 <lambdabot> [10,12,15,18,20,24]
13:30:52 <vincenz> gotta 'let .. in'
13:30:58 <JohnnyL> ok
13:31:01 <JohnnyL> thx.
13:31:32 <JohnnyL> in that case <- xs means grab next char from string list.
13:32:18 <newsham> > [(x,y) | x <- [2,3,4], y <- [5,6]]
13:32:19 <lambdabot> [(2,5),(2,6),(3,5),(3,6),(4,5),(4,6)]
13:33:24 <JohnnyL> [x*y | x<- [2,3,4], y <- [5,6] ]
13:33:27 <JohnnyL> > [x*y | x<- [2,3,4], y <- [5,6] ]
13:33:29 <lambdabot> [10,12,15,18,20,24]
13:35:25 <JohnnyL> x<-xs where "<- means fetch head of xs?
13:35:54 <JohnnyL> it's be nice to have a small reference guide for the contexts of all of these symbols.
13:35:55 <norpan> more like "for each element in xs"
13:36:06 <JohnnyL> norpan, oh ok, that's better.
13:36:28 <norpan> in list comprehension
13:36:57 <JohnnyL> > [x*y | x<- [2,3,4], [5,6] -> y] ]
13:36:58 <lambdabot>  parse error on input `->'
13:38:55 <Cale> > do x <- [2,3,4]; y <- [5,6]; return (x * y)
13:38:57 <lambdabot> [10,12,15,18,20,24]
13:39:03 <newsham> cartesian style, yoh.
13:39:21 <Cale> > do x <- [2,3,4]; y <- [5,6]; return (x, y)
13:39:22 <newsham> comprehending cale
13:39:23 <lambdabot> [(2,5),(2,6),(3,5),(3,6),(4,5),(4,6)]
13:40:04 <norpan> before haskell 98 list comprehension syntax worked for monads too
13:40:16 <Cale> yeah
13:40:27 <newsham> comprehending monads
13:40:48 <Cale> It's a shame that they nerfed a lot of language features for 98
13:40:48 <norpan> don't know why it was removed
13:40:59 <norpan> but do syntax works equally well
13:41:12 <Cale> guards are a little less convenient
13:41:13 <newsham> no -fhaskell-super-comprehensions-exts ?
13:41:27 <Cale> and they also weakened the types of a lot of prelude functions
13:41:38 <Cale> map/fmap/liftM is a mess
13:42:08 <norpan> map == fmap
13:42:12 <JohnnyL> > do [2,3,4] -> x;  [5,6]->y; return (x*y)
13:42:13 <lambdabot> [10,12,15,18,20,24]
13:42:20 <JohnnyL> mama like, mama like.
13:42:22 <Cale> fmap == liftM :)
13:42:22 <xerox> O_O
13:42:37 <xerox> When did they swap <- ?!
13:43:03 <Cale> heh, cute
13:43:12 <xerox> Crazy I didn't know it :-)
13:43:15 <JohnnyL> looks like there can be an enhancement to list generators for both directions in non do mode.
13:43:27 <norpan> why is not Monad automatically Functor
13:43:32 <norpan> beats me
13:43:35 <xerox> norpan: design incongruences
13:43:50 <Cale> norpan: because there's no way to have default superclass instances
13:44:05 <norpan> well
13:44:12 <Cale> It would mean that every time you wanted to make something a monad, you'd have to make it a functor first by hand.
13:44:27 <Cale> Once we have a way to automate that, it will be.
13:44:29 <xerox> ...`deriving' wouldn't be enough?
13:44:34 <Cale> nope
13:44:43 <xerox> Aww.
13:44:48 <norpan> could be solved
13:45:09 <Cale> Should hopefully be solved for H'
13:45:15 <xerox> Cale: think with me.  If we get Haskell.org as mentoring organization for the Summer of Code, which project could we propose, as an "organization" ?
13:45:19 <norpan> H' is what?
13:45:35 <vincenz> xerox: what have you been thinking of about the go game in haskell
13:45:42 <JohnnyL> xerox a language recplaement for php.
13:45:42 <newsham> @pleasetellmeabout H'
13:45:43 <lambdabot> Unknown command, try @list
13:45:43 <JohnnyL> :P
13:45:44 <Cale> Haskell-prime, the new standard which people are working on
13:45:52 <Cale> @where haskell-prime
13:45:53 <lambdabot> http://hackage.haskell.org/trac/haskell-prime
13:46:11 <xerox> JohnnyL: webdev is indeed an hot topic these days.
13:46:20 <vincenz> H' = haskell'
13:46:31 <vincenz> = haskell++
13:46:42 <Oejet> Primes?  http://en.wikipedia.org/wiki/Illegal_prime
13:47:03 <vincenz> but hopefully side-effect free
13:47:07 <mauke> :t (haskell++)
13:47:10 <vincenz> unlike c++ which lugs around a whole ton of c
13:47:10 <xerox> Oejet: that is a nice one.
13:47:18 <newsham> haskell98 -> haskell09 ?
13:47:19 <xerox> ?type \haskell -> (haskell++)
13:47:21 <lambdabot> forall a. [a] -> [a] -> [a]
13:47:31 <vincenz> illegal' o.O
13:47:54 <Cale> It's not really Haskell++, so much as standardising lots of the stuff that's become commonplace since Haskell98, together with smallish touches here and there
13:47:57 <tromp> haskell++ ? blasphemy!  should be (succ haskell)   :)
13:48:12 <Cale> Nothing unimplemented will be standardised.
13:48:26 <Cale> That's why it's Haskell'
13:48:46 <Cale> (and that's the temporary name)
13:49:19 <newsham> are you saying haskell succs?
13:49:33 <vincenz> newsham: old
13:49:42 <xerox> Cale: http://code.google.com/soc/mentorfaq.html see point 2 if you will
13:50:32 <norpan> if anything, haskell+1
13:50:35 <Cale> xerox: you should mail the Haskell mailing list
13:50:44 <vincenz> xerox: quanti anni hai?
13:50:54 <Cale> I like Haskell 1.6 myself.
13:50:56 <xerox> vincenz: 21
13:51:00 <xerox> Cale, good idea.
13:51:15 <vincenz> allora ogni estata fai un SoC di google
13:51:29 <xerox> (-:
13:51:41 <vincenz> fico
13:53:28 <ihope_> @index ix
13:53:29 <lambdabot> bzzt
13:53:33 <ihope_> @index Ix
13:53:34 <lambdabot> Data.Ix, Data.Array, Data.Array.IArray, Data.Array.Unboxed, Data.Array.MArray, Data.Array.IO, Data.Array.ST, Data.Array.Storable, Data.Array.Diff
13:54:11 <newsham> xerox: do you do web stuff?
13:54:21 <xerox> newsham: it depends :-)
13:54:28 <newsham> in haskell?
13:55:35 <xerox> I never did webdev in haskell so far :-(
13:56:43 <vincenz> dons gone for the weekend?
14:01:10 <ihope_> > '\1'
14:01:11 <lambdabot> '\SOH'
14:01:34 <newsham> anyone experienced with happs?
14:07:20 <vincenz> @seen dons
14:07:21 <lambdabot> dons is in #haskell. I don't know when dons last spoke.
14:07:44 <norpan> bad bot
14:08:00 <newsham> vinc: he hasnt been around since at least 12 hrs ago
14:13:17 <mathrick> Cale: pokety?
14:13:26 <vincenz> newsham: crap
14:23:51 <norpan> @yow
14:23:52 <lambdabot> Yow!  I'm imagining a surfer van filled with soy sauce!
14:25:28 <gzl> wtf?
14:26:03 <newsham> gnarly shoyu
14:32:11 <JohnnyL> in the function innXB = foldr1(+) . map (foldr1(*)) . transpose why aren't the rest of the parameters given for foldr1? how does that work?
14:33:23 <mauke> currying
14:33:41 <newsham> johnnyl: write it out without the compose and with the implicit argument explicitely
14:33:58 <mauke> @type (++) "hello, "
14:33:59 <lambdabot> [Char] -> [Char]
14:34:04 <newsham> ie             foldr1 (+) (map (foldr1 (*) (transpose x)))
14:34:38 <xerox> innXB = sum . map sum . transpose
14:34:43 <newsham> (with f . g . h   read it backwards.. you do h(x) ten g(..) of that, then f(..) of that)
14:34:55 <resiak> xerox: map product, no?
14:34:56 <newsham> xerox: map product
14:35:03 <xerox> heh!
14:35:10 <newsham> SOP
14:35:12 <xerox> You math weenies.
14:35:30 <newsham> <- just a computer weenie
14:36:20 <mahogny> hmmm
14:36:35 <mahogny> question; is there some standard for writing formal requirements in haskell?
14:36:46 <newsham> quickcheck?
14:36:56 <JohnnyL> @type foldr1
14:36:57 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
14:36:59 <xerox> I think so, that, or HUnit.
14:36:59 <mahogny> hard requirements. not tons of checking
14:37:27 <JohnnyL> oh folr1 only requires two parameters.
14:37:31 <JohnnyL> @type foldr
14:37:32 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
14:37:34 <newsham> http://www.math.chalmers.se/~rjmh/QuickCheck/  you declare the behavior and it verifies it with random tests
14:37:54 <resiak> foldr1 f (x:xs) = foldr f x xs   -- IIRC
14:37:56 <mahogny> newsham, yes, I know. that's even my uni :) but I am interested in hard proofs
14:38:08 <araujo> > foldr1 (+) $ map (foldr1(*)) $ transpose [[1,3], [2,5], [3,5]]
14:38:09 <lambdabot> 81
14:38:11 <mahogny> newsham, or as nice, properties that can be used in optimization
14:38:29 <xerox> > map product . transpose $ [[1,3], [2,5], [3,5]]
14:38:30 <lambdabot> [6,75]
14:38:39 <araujo> JohnnyL, it works here
14:38:47 <xerox> (sum .) :-)
14:38:54 <newsham> mahogny: ahh, sorry.  cant help.  above my level
14:39:17 <araujo> > foldr1 (+) $ map (foldr1(*)) $ transpose [[1], [2], [3]]
14:39:18 <lambdabot> 6
14:39:31 <mahogny> hmm. well, I'm tempted to mail the haskell', or at least the ghc mailing list about it
14:39:32 <JohnnyL> wha'ts the diff between  '.' , $ and ()?
14:39:41 <araujo> JohnnyL, now, if you got something like that, it will give you the impression than the latest foldr1 isn't applied :-)
14:39:51 <xerox> f . g = \x -> f (g x)   or if you want   (f . g) x = f (g x)
14:39:55 <newsham> $ is often like () :)
14:39:57 <newsham> . is not.
14:39:58 <xerox> f $ x = f x
14:40:10 <mahogny> JohnnyL, . is barely related, $ is an infix operator and encloses everything to the right in (), and () is... uh. obvious
14:40:17 <newsham> f $ a b c d e f g     =  f ( a b c d e f g )
14:40:23 <xerox> I.e. you can think of '$' as a '(', and put a ')' at the end of the line.
14:41:10 <araujo> JohnnyL, '$' is for composition in terms of values, '.' is for composition in terms of functions.
14:41:14 <JohnnyL> i thought $ was f $ a b c $ d e f is like f (a b c) (d e f)?
14:41:29 <JohnnyL> araujo, ok, that makes sense.
14:41:32 <xerox> f $ a b c $ d e f = f (a b c (d e f))
14:41:46 <araujo> > let f = (+ 2) . (* 3) in f 4
14:41:47 <lambdabot> 14
14:41:57 <araujo> > (+ 2) $ (* 3) $ 4
14:41:58 <lambdabot> 14
14:42:48 <JohnnyL> ah, so f goes allt the way to the right just before then 'in'.
14:42:58 <JohnnyL> rather the parameter to f.
14:44:25 <araujo> yes, somethign like that, in this case, im binding (+ 2) . (* 3) (which is a function) to the variable f
14:44:38 <araujo> @type (+ 2) . (* 3)
14:44:40 <lambdabot> forall a. (Num a) => a -> a
14:46:21 <JohnnyL> @type transpose
14:46:22 <lambdabot> forall a. [[a]] -> [[a]]
14:46:39 <musasabi> newsham: I have some experience with happs. Anything I can help you with?
14:46:54 <newsham> nothing in particular.. i have questions though.
14:47:14 <musasabi> feel free to ask.
14:47:14 <newsham> so it looks like happs has functions you can use to have it serve web pages, but its not really a full blown web server
14:47:29 <newsham> how good is the support?  robust?  features?
14:50:20 <musasabi> The base HAppS can be used quite adequately serve the static parts of a webapp, but for a standalone http server meant to replace something like apache one would use something like the HAppS-httpd code I linked earlier. (There is no formal release of that as I haven't had time to get it in a state for a release)
14:51:43 <musasabi> The HTTP support is quite good and supports parts of the RFC hws lacks support for. One thing is that it tries to be hard to DoS.
14:53:09 <JohnnyL> anyone here use use haskell in real world stuff?
14:53:23 <norpan> real world you way
14:53:25 <norpan> say
14:53:37 <musasabi> JohnnyL: yes.
14:53:44 <norpan> we do
14:53:47 <norpan> were i work
14:53:52 <newsham> i didnt see happs-httpd code.
14:53:56 <norpan> it's part of our product
14:54:04 <newsham> url?
14:54:17 <norpan> www.jasper-da.com
14:54:22 <JohnnyL> norpan, cool, glad to hear.
14:54:33 <musasabi> http://www.cs.helsinki.fi/u/ekarttun/haskell/HAppS-httpd/ (experimental, should add configuration file parser + documentation before doing a release)
14:54:41 <norpan> unfortunately i do most of my work in java and c++
14:55:22 <newsham> thanks.  i'll play with this.
14:55:32 <newsham> i've been reading through hws and hws-wp.
14:55:45 <newsham> both seem to work well but have some deficiencies
14:55:47 <norpan> haskell is damn good
14:56:13 <norpan> even if we only use it for some auxilliary tasks
14:58:31 <mauke> @pl collect k _ acc = k : acc
14:58:32 <lambdabot> collect = const . (:)
14:59:53 <musasabi> newsham: have fun with it :-)
15:00:42 <newsham> does it do url decoding?  redirect directory to index.html?  make directory listings?  cgis?
15:00:46 <newsham> plugins?
15:02:26 <musasabi> HAppS has some url decoding. directory listings are currently not done but would be ~20 lines of code (see FileServ), cgis are in the HAppS-httpd.
15:03:14 <musasabi> The architecture is entirely modular consisting of request handling parts in a user defined monad.
15:04:29 <musasabi> (and with monad transformers one can combine plugins from multiple apps)
15:06:22 <musasabi> Basically everything is a server part and the HTTP code does not depend on any of them, so they are all plugins.
15:07:34 <Oejet> Why are the Haskell knucleotid shootout entries so slow?
15:08:58 <musasabi> Oejet: because we lack efficient nice hashtables, strings and line io in the basic library
15:09:16 <musasabi> *base
15:13:52 <Oejet> Ah, for how long?
15:14:01 <jip> musasabi: i've had some thoughts about an arrow based "web framework"
15:14:46 <musasabi> jip: what kind of thing?
15:17:18 <jip> musasabi: for describing behaviour of a "web app" (forum, blog). with a builtin storage system(instead of a database), and automatic caching of html output, with automatic updating of the cache when relevant data in the store is modified
15:19:13 <musasabi> sounds nice.
15:19:47 <musasabi> actually with modern browsers one can use XML+XSL and push the processing to the browser and only emit small XML documents.
15:20:51 <jip> yeah, but you'd still need to do a database lookup
15:21:27 <musasabi> nah, just keep the stuff in memory and WAL updates with periodic checkpointing.
15:22:21 <newsham> why does everyone insist on using databases?
15:22:31 <jip> that's also fun :) but aside from performance, also from a code design point of view...
15:22:35 <musasabi> newsham: because they use PHP.
15:22:47 <newsham> before there was such a thing as php
15:22:49 <jip> i coded this forum in this python "framework" called cherrypy. it was pretty easy and fun
15:22:51 <JohnnyL> they only redeeming quality of databases is range searches and indexes.
15:23:00 <musasabi> newsham: or need multiple apps share the data.
15:23:20 <JohnnyL> and even those are trivial.
15:23:22 <jip> problem was when i wanted to add "components" to it, like a calender in a sidebar and other things
15:23:30 <mahogny> or the server need to reboot at some point? :)
15:23:36 <newsham> you dont need a db to share data
15:23:49 <mahogny> a db is considerably easier than most alternatives
15:24:15 <newsham> hah.
15:24:16 <musasabi> mahogny: that can be handled with having the state recoverable from disk.
15:24:23 <newsham> ever hear of a DBA?
15:24:43 <musasabi> mahogny: we do it in HAppS and it works quite nicely.
15:24:47 <mahogny> musasabi, indeed. and you need to get it to disk. so either you have to deal with all that shit, or you just use a persistent db
15:25:01 <mahogny> newsham, hmm. no?
15:25:15 <mahogny> newsham, got url?
15:26:09 <newsham> database administrator.  they keep dbs running
15:27:07 <Philippa> JohnnyL: do you ever manage more than opinionated bullshit? DBMSes provide a lot of safety guarantees that're damn hard work to get right from scratch
15:27:46 <newsham> they get paid decently :)
15:27:47 <JohnnyL> Philipippa, sorry did I offend you? I didn't want to offend anyone.
15:28:15 <newsham> http://seeker.dice.com/jobsearch/servlet/JobSearch?op=1013&FREE_TEXT=oracle%20dba&ppc=google
15:28:19 <JohnnyL> I'm just saying that in my experience custom databases are succinct, small custom and much less overhead.
15:28:37 <newsham> sr oracle dba, eden prairie, mn, fulltime $85k to $90k per year
15:28:56 <newsham> <mahogny> a db is considerably easier than most alternatives
15:28:57 <mahogny> JohnnyL, that's a good solution as long you don't worry about security or the time it takes to implement
15:29:00 <Philippa> okay. IME it's a lot easier to get hardcore data safety with a good pre-existing database
15:29:01 <newsham> unfortunately most people think that.
15:29:06 <Oejet> JohnnyL: You are not very enterprisey, then.
15:29:20 <JohnnyL> databses are fun, don't get me wrong. but alot of the time a custom job will be better overall. then again the programmer and not the dba has more stay potential.
15:29:34 <Philippa> newsham: FCVO 'alternative' it's true. A lot of systems operate under constraints where the alternative has massive engineering work to do
15:30:02 <JohnnyL> mahogny, imgo, security has never been a factor, and the source code usually contains a searchable string when compiled to binary.
15:30:23 <newsham> massive engineering work vs. upgrading, purchasing support, fixing bugs in sql injections, etc..
15:30:25 <JohnnyL> and whos says you can't apply security?
15:30:35 <mahogny> JohnnyL, that's only the C part of ACID :)
15:30:41 <newsham> err.. i should have put "massive" in quotes
15:30:43 <Philippa> JohnnyL: you can. It's just work
15:30:45 <newsham> because its not that bad.
15:30:48 <musasabi> Backups are the first key to data safety.
15:30:51 <newsham> you're engineering the rest of the product
15:30:54 <newsham> why not engineer the data store
15:31:00 <mahogny> JohnnyL, you can do ACID on your own, but someone has to code it, and that guy has to be paid and trusted
15:31:22 <JohnnyL> if you do not rust, you will not be trusted.
15:31:41 <JohnnyL> opps
15:31:42 <JohnnyL> hahah
15:31:45 <JohnnyL> rust=trust
15:31:46 <musasabi> Of course a relational DB is the way to go if there are many gigabytes of data, for most webapps the amount of data is quite a lot smaller and DB overhead can be significant.
15:31:47 <Philippa> if you drop your pants for everyone you won't be trusted by anyone but idiots though
15:32:08 <newsham> depends on your occupation.
15:32:13 <JohnnyL> Philippa, MVC should be enough security.
15:32:18 <mahogny> ...
15:32:19 <newsham> if you're an underwear model, it comes with the territory
15:32:21 <JohnnyL> just leave it all for the firewall.
15:32:37 <mahogny> JohnnyL, I hope you don't refer to that GUI MVC stuff
15:32:40 <Philippa> newsham: nope, underwear models with any sense're careful about who they're working with
15:32:59 <JohnnyL> yes, code+ rules & validations exist on the server and the gui is at the browser.
15:33:35 * mahogny now knows why no programs work; MVC is used as a security model -_-
15:34:06 <JohnnyL> php+hbtml+sql... lets refine that to just php + html. 
15:34:10 <JohnnyL> sorry, typos.
15:34:35 <mahogny> you gotta be kidding me. you mean you want to engineer secure databases... IN PHP???
15:34:56 <JohnnyL> thousands of websites can't be wrong.
15:35:06 <mauke> yes, they can
15:35:14 <mahogny> the amount of hacked sites do
15:35:25 <JohnnyL> i am not saying putting the controller at the web page. rather behind it.
15:35:28 <JohnnyL> capish?
15:35:36 <newsham> mahogny: uh..  secure?  like oracle?  like mysql?
15:35:43 <Philippa> thousands of web sites /are/ wrong. 90% of code out there is shit
15:35:44 <mahogny> newsham, secury as in ACID
15:35:46 <JohnnyL> sota like mysql functions, just remote queries.
15:35:46 <mahogny> *e
15:36:07 <Philippa> mahogny: ACID isn't a security concern, it's about you shooting yourself in the foot not someone else doing it
15:36:09 <mahogny> newsham, mysql is a joke though
15:36:16 <mahogny> Philippa, lol
15:36:29 <newsham> so is oracle.  i wouldnt trust oracle with my pets names.
15:36:44 <mahogny> Philippa, the database cannot be responsible for auth stuff. only the ACID stuff
15:36:46 <JohnnyL> too much overhead and pitiful documention in mysql.
15:36:58 <Philippa> mahogny: quite
15:37:16 <mahogny> JohnnyL, get postgresql. mysql is a commercial hype
15:37:19 <newsham> http://www.ngssoftware.com/advisory.htm  /oracle/
15:37:54 <JohnnyL> i have used ingres in the past. great database for government jobs.
15:38:13 <newsham> http://seclists.org/lists/bugtraq/2005/Oct/0056.html
15:38:14 <triplah> *rubs eyes*
15:38:22 <triplah> i wake up to see people talking php in #haskell
15:38:24 <mahogny> newsham, while I don't think oracle is 100% secure, I trust them more than your hacks
15:38:29 * triplah checks outside for flying pigs
15:38:41 <JohnnyL> still though when it comes to today's apps, I'd rather not have to either 1) bye into mysql hype or 2) spend $$$ on a databse when the hard drive and the algorithms for databases are well known.
15:38:51 <newsham> mahogny:  thats nice.
15:38:54 <mahogny> newsham, or my hacks, if you think that comment was offensive
15:39:01 <triplah> haha
15:39:08 <newsham> i'm not offended.  i just think you are misguided.
15:39:24 <newsham> btw, I'm a computer security consultant.
15:39:34 <JohnnyL> i built an app using just random data files with seqential datafiles ,my protogais tried to switch to Q+E and failed miserably.
15:39:53 <JohnnyL> i say SQL is good for bigger projects where you need to hire someone that knows sql.
15:40:02 <mahogny> years of software development management talk against you; coding things once and using it IS less buggy than continously reinventing the wheel (ie engineering special databases)
15:40:52 <mahogny> oh, and for your notice, I don't really bother much about authority. and we all know consultants are the ones that fuck up everything and sends an outrageous bill ;)
15:40:55 <JohnnyL> newsham, isn't MVC enough? google seems to not mind. But that may be a bad example.... NOT!
15:41:04 <newsham> mahogny: that is only true if the code is stable (unchurned), of high quality, and with properly chosen abstractions.
15:41:28 <newsham> imo software components lead to bloat, complexity, insecurity, inefficiency more often than not.
15:41:46 <Philippa> JohnnyL: Google only have other people's security to worry about for the most part, and I bet they're quite capable of putting an air gap between their test+dev systems and the rest
15:41:51 <mahogny> newsham, of course. but as I said, I doubt your hacks beat any of that (stability, quality, abstractions). at most abstractions
15:42:43 <newsham> mahogny:  a one thousand line well defined, well coded stable store beats a 10 million line general database engine any day
15:42:45 <JohnnyL> Philippa, what's an air gap? and do you think they use a custom database or Oracle?
15:43:04 <JohnnyL> Oracle would crash if it had to deal with google's data.
15:43:05 <JohnnyL> lol
15:43:06 <JohnnyL> jk
15:43:09 <JohnnyL> i don't know.
15:43:12 <newsham> air gap is physical disconnectedness
15:43:26 <Philippa> JohnnyL: An air gap is what it sounds like. Preferably at least a metre of air between systems (IIRC that's the DoD standard over here)
15:43:30 <triplah> newsham: like using sleepycat's offering + tight code?
15:43:31 <mahogny> newsham, depends on what those million lines of code are and who manages it
15:43:33 <newsham> mahogny: view the urls I pasted.
15:43:46 <mahogny> newsham, I have. I do know that bugs exist
15:43:50 <JohnnyL> i'm just saying that when there is a Monad of languages in one project. it's much more prettier in code (because the same functions can be used to attract RAM data as well).
15:43:52 <newsham> <mahogny> newsham, depends on what those million lines of code are and who
15:43:52 <newsham> +manages it
15:43:55 <newsham> i disagree.
15:44:02 <newsham> i will leave it at that.  
15:44:33 <JohnnyL> woah, just had a mind shift.
15:45:20 <Philippa> newsham: I agree when it's doable in a KLoC. Any bigger is when I worry
15:45:52 <mahogny> newsham, I think I can pick it up there :) it's somewhat floating; but who said a database has to a million lines just because it is general? if someone wanted to make a rock stable SQL server, they could
15:46:09 <Philippa> (actually, because my knowledge regarding some of the implementation issues is a bit too low I'd currently put the marker around a couple of hundred LoC for myself, but hey)
15:46:16 <mahogny> right now, I think only postgres only fulfill my requirements though
15:46:21 <mahogny> -onlyx1
15:46:38 <lispy> how many lines is sqlite?
15:46:39 <JohnnyL> one cool thing about going the route of db's is that you can seperate servers easily. but you can still do that through code if you wanted to as well, with like http as the remote call transducer.
15:47:01 <lispy> granted it's not a server, but it still pretty cool
15:47:28 <newsham> there are many remote access technologies.
15:48:15 <newsham> seperating servers to seperate machines has both positive and negative impacts.
15:48:29 <newsham> for example, in security you have additional attack surfaces
15:48:34 <newsham> for performance you have larger latency
15:48:39 <mahogny> I'm not extremely happy with the remote dbs that exist now. at least ordinary sql suffers a lot
15:48:51 <newsham> and of course better compartmentalization and ability to offload processing
15:49:32 <mahogny> OTOH, I have seen solutions that have several uncoupled SQLs, manually synchronized. I dunno if I like that approach much more
15:50:03 <lispy> if a process is manual it's just waiting for someone to screw it up
15:50:19 <mahogny> when I say manual, I mean own glue code
15:50:26 <lispy> ah
15:50:36 * vincenz would like to join or start a haskell icfp contest team... any room or people interested?
15:50:46 <newsham> lispy: sure, but an automated screw up can screw things up better than any human can :)
15:50:57 <JohnnyL> newsham, i still like the idea of a custom database, not only are hacks not evailable to it online , but it allows for greater smoothness over standard data manipulation libraries at the internal box layer. if you extend your data lib lirbary to focus on secondary storage. it's a win win situation.
15:51:11 <JohnnyL> all of the big projects like blitz use custom databases.
15:51:25 <lispy> blitz?
15:51:37 <JohnnyL> blitz=airline reservations.
15:51:44 <lispy> ah
15:52:03 <JohnnyL> they ironically use lisp and custom c both of them integral with a custom databse.
15:52:24 <Philippa> so, anyone wanna start a correct-by-construction SQL-DB-on-disk implementation in haskell?
15:52:32 <Oejet> vincenz: I am interested.
15:52:34 <lispy> JohnnyL: was it designed by paul grahmn?
15:52:41 <lispy> er..i spelled that
15:52:58 <newsham> lispy: if it was, dont you think he would have told you about it a dozen times already?
15:52:58 <JohnnyL> Philippa, why even use SQL when you can use first order functions?
15:53:18 <ski> JohnnyL : what do you mean ?
15:53:20 <lispy> newsham: yeah and it would be use stored procedures written in arc
15:53:23 <musasabi> Philippa: that is actually more painfull than it sounds like.
15:53:26 <mahogny> I think haskell would be the ultimate language for making a good database library that has all the ACIDity combined with fast access, with some template haskell and monadic hacking
15:53:34 <JohnnyL> lispy, yup.
15:53:36 <Philippa> musasabi: no, it's not. Because it sounds fucking painful to me
15:53:41 <JohnnyL> sky?
15:53:43 <JohnnyL> ski?
15:53:43 <mahogny> and that has the write-once, debug-once, work-always property
15:53:45 <musasabi> ok :-)
15:54:31 <musasabi> Philippa: I once tried prototyping something like that and I ended with most types as newtype Foo = Foo (Ptr ())
15:54:42 <lispy> Philippa: i'd say improving the reliability and performance of darcs would be more useful at this point
15:54:42 <Philippa> heh
15:54:52 <JohnnyL> mahogny what's template haskell like?
15:55:12 <lispy> and you can view darcs as a filesystem database...
15:55:12 <Philippa> lispy: depends. Darcs alone ain't enough for my web app work. For the community at large I agree, I was in fact being largely sarky
15:55:14 * ski thinks some kind of logic programming language would make a good interface for querying and managing a (relational) database
15:55:18 <mahogny> JohnnyL, I'd prefer to see something else really. I consider it a hack. a structured hack
15:55:22 <Philippa> an untyped filesystem db isn't enough
15:55:27 <triplah> ski: agreed
15:55:28 <triplah> :)
15:55:29 <Philippa> I've got that in Flippi already, though it needs a proper locking system
15:56:08 <triplah> i must say, i like xslt's querying style. and zquery is rather nice too
15:56:13 <triplah> xquery*
15:56:19 <lispy> triplah: realy?
15:56:29 <lispy> triplah: i hate it compared to sql
15:56:39 <triplah> sure i dislike the fact that they are written in xml pretty much
15:56:46 <ski> lispy : hate what ?
15:56:54 <triplah> lisp xquery has a few things over sql
15:57:06 <triplah> like comparing muiltiple lists
15:57:37 <alar> Is there a logic language with multidirectional sentences?
15:57:38 <alar> e.g. A=B+C can be resolved w.r.t A, B or C
15:57:38 <alar> depending on concrete task
15:57:48 <triplah> alar: prolog
15:57:57 * mahogny now has "writing a database library for haskell" on his already too long TODO. damn you!
15:57:58 <ski> alar : logic programming
15:58:09 <alar> triplah: nope
15:58:22 <ski> alar : have you tried mercury ?
15:58:25 <alar> in Prolog :- gives the direction of resolution
15:58:27 <JohnnyL> mahogny, first order library functions? :)
15:58:34 <alar> ski: I haven't
15:58:41 <ski> alar : huh, that's unrelated to this
15:58:43 <triplah> true, although the result is whatever you leave open
15:59:08 <triplah> X:-A,B can resolve to any of the items
15:59:08 <ski> (alar,triplah : unfortunately, arithmetic in plain prolog is single-direction)
15:59:16 <jip> no! glade froze up on me after spending hours designing a gui :'(
15:59:19 <triplah> yeah :\
15:59:22 <alar> ski: that's what I mean
15:59:28 <alar> and I think I know why
15:59:43 <ski> alar : arithmetic in various CLP packages, and also in mercury, is multi-direction
15:59:53 <ValarQ> jip: hope you learned not to trust a gui :P
15:59:56 <triplah> lets face it, arimetic is hardly prolog's strong point :P
16:00:01 <triplah> arithmetic*
16:00:05 <alar> ski: thanks, I'll look towards Mercury
16:00:20 <ski> triplah : yes .. that's because prolog has no functions
16:00:33 <alar> triplah: nontermination is Prolog's weak point
16:00:39 <triplah> yeah
16:00:50 <jip> @seen dcoutts_ 
16:00:51 <lambdabot> dcoutts_ is in #gentoo-haskell and #haskell. I don't know when dcoutts_ last spoke.
16:00:52 <mahogny> JohnnyL, dunno. I want to be able to define any kind of datastructure, have transactions, requirements on content (CHECKS) and full ACIDity in general, and still be almost transparent. that's quite a syntactic challenge
16:00:53 <jip> ValarQ: :\
16:00:55 <ski> alar : most languages have possible nontermination
16:01:04 <alar> ruleset must be carefully designed to disallow depth-first search falling in nontermination
16:01:48 <alar> ski: but in some languages it can be relatively easily avoided
16:01:59 <JohnnyL> mahogny, yeah. i like what i hear.
16:02:04 <JohnnyL> i'm still a newbie with haskell.
16:02:32 <lispy> mahogny: so you want the acid monad?
16:02:34 <JohnnyL> to be gentle in your project you should just make (which is sounds like) turning regular first order functions with slight differences.
16:02:40 <JohnnyL> as far as interface goes.
16:02:41 <JohnnyL> you know?
16:02:46 <mahogny> lispy, omg, code it for us!
16:03:17 <mahogny> JohnnyL, hm. got an example?
16:03:21 <lispy> mahogny: hehe, i use monads, i don't write them :)
16:04:03 <mahogny> lispy, I usually do neither if I can avoid :)
16:04:06 <ski> (alar : do you have any specific example in mind .. ?)
16:04:59 <JohnnyL> mahogny for example the function combiner '.' make it so that the function you call has a sisidter function name except that is accesses disk.
16:05:07 <Philippa> on a related subject, anyone know where to find reasonably hardcore info on database implementation, assuming I want to produce something reasonably well-engineered with more than a flat-file structure?
16:05:19 <alar> ski: what example?
16:05:34 <ski> alar : re nontermination
16:05:43 <lumi> Hi, I got a monads question.. In what way does the `ap` function compose?
16:05:46 <mahogny> Philippa, postgresql has some documentation. but it depends on what you know right now
16:06:10 <mahogny> JohnnyL, hm. I'll need to kick this for some time
16:06:55 <JohnnyL> does haskell have closures?
16:06:56 <ski> lumi : it returns an action, that when run : runs the first action argument, getting back a function, then runs the second action argument, and passes the result of that to the function, returning the answer
16:07:01 <Philippa> mahogny: assume I don't know the OS primitives well enough to derive safety properties from scratch yet, and that my knowledge of relational databases is mostly at a user level + knowledge of relational algebra and the like. I could build me a great in-memory DB...
16:07:15 <ski> > (Just succ) `ap` (Just 5)
16:07:16 <lambdabot> Just 6
16:07:20 <ski> > (Just succ) `ap` Nothing
16:07:21 <lambdabot> Add a type signature
16:07:27 <ski> > (Just succ) `ap` Nothing :: Maybe Int
16:07:28 <lambdabot> Nothing
16:07:34 <lumi> So it first gets the function? Thanks
16:07:39 <ski> > Nothing `ap` (Just 5) :: Maybe Int
16:07:40 <lambdabot> Nothing
16:07:49 <mahogny> Philippa, well. os primitives; fflush is about as much as I think you can demand. the rest you have to build
16:07:50 <Cale> I don't think it's enough to just ask for an 'ACID' monad, you need some more operations than that :)
16:07:52 <Philippa> JohnnyL: For the purpose you mean, "yes". I don't think there's a notion of 'closure' in the Haskell 98 Report though
16:07:56 <ski> > [succ,pred] `ap` [10,20]
16:07:57 <lambdabot> [11,21,9,19]
16:08:02 <ski> lumi : yes
16:08:06 <Cale> The trivial monad satisfies ACID quite nicely :)
16:08:07 <mahogny> Philippa, you know about log based databases?
16:08:30 <Philippa> mahogny: not really. I can have a guess at what 'log based' means if that helps?
16:08:32 <lumi> Wunderbar, thanks ski
16:08:52 <JohnnyL> i thought it had closure, i guess the "let..in" is just a scam of lisp at some level.
16:09:01 * Philippa bursts out laughing
16:09:04 <Philippa> you're clueless
16:09:07 <mahogny> Philippa, well. if you want performance, and ACIDity at the same time, that is where you need to pick up. you can have a look at journaling FS' as well, they do it in similar ways
16:09:11 <Philippa> trust me on this, you're asking the wrong questions
16:09:13 <ski> > return (+) `ap` [10,20] `ap` [-2,2]
16:09:14 <lambdabot> [8,12,18,22]
16:09:25 <ski> (lumi : that idiom is also nice)
16:09:32 <Philippa> JohnnyL: let ... in is old, old mathematical notation
16:10:14 <Philippa> and haskell has what you mean by closures. It's just that they're strictly an implementation-level concept in haskell because there's nothing you could mutate in them
16:10:15 <gzl> as is 'where'
16:10:21 <mahogny> Philippa, not sure, but SpriteFS but have been the first journaling FS and I think you can obtain the article. quite easy reading, the ideas today are similar. reiserfs docs are sparse
16:10:22 <Cale> > liftM2 (+) [10,20] [-2,2]
16:10:23 <lambdabot> [8,12,18,22]
16:10:37 <mahogny> *but=might
16:10:46 <JohnnyL> Philippa, who me? yeah, as far as haskell i'm a newbie. but i've written database before in other language. you'll laugh more when i tell you what language it is in.
16:10:58 <JohnnyL> personally i'm not too religious , every tool for every job.
16:11:06 <mahogny> JohnnyL, ...no words on B in here plz ;)
16:11:19 <JohnnyL> mahogny?
16:11:26 <lumi> ski: It is; sadly I can't use it for my case, I need them done the other way around
16:11:31 <JohnnyL> oh.
16:11:32 <JohnnyL> hahah.
16:11:34 <mahogny> JohnnyL, your language. if it starts with B then we don't want to know :)
16:12:04 <JohnnyL> mahogny, hey, man, without gotos B isn't that bad.
16:12:19 <Philippa> JohnnyL: as you're a self-confessed newbie, can you please take more care before criticising or being derogatory about a language you don't understand?
16:12:55 <mahogny> JohnnyL, yeah. and without any special syntax. and without the variable type variant. and without the unportable GUI. and if it had a much better system for OOP, and type inference and and ... uhm :)
16:13:07 <Cale> Closures are more of an implementation detail for curried functions than a language feature.
16:13:20 <JohnnyL> Philippa, i'm giving my input of knowledge based on Lisp and what little I know of Haskell and the various databases I've used. So I claim right to my proper words in such context. America has free speech you know. And our military created the Net, so there! :)
16:13:44 <JohnnyL> mahogny, vb and c# and java blur these days.
16:13:56 <Philippa> JohnnyL: America may have free speech in public but you're on private ground. Deal with it
16:13:57 <alar> ski: if you simply write A=B+C to be resolved as B=resolve(A-C) | C = resolve(A-B) | A=apply+(B,C) then I beleive an example that forces depth-first searcher into infinite branch is easily constructible
16:14:03 <mahogny> JohnnyL, well, there is no good imperative language. java needs a successor
16:14:12 <JohnnyL> Philippa, have i offended you?
16:14:24 <lispy> mahogny: have you seen nice and pizza?
16:14:27 <JohnnyL> mahogny, indeed, i agree wholeheartidly.
16:14:33 <Cale> I don't see what JohnnyL said that was so offensive?
16:14:51 <ski> lumi : you can define one that goes the other way, easily
16:14:54 <mahogny> lispy, well. I've seen Java 2k but I wasn't very impressed :)
16:15:13 <lispy> mahogny: nice looks well...
16:15:24 <lispy> mahogny: let's just say it has a good name :)
16:15:31 <Cale> mahogny: Haskell is a decent imperative language :) hehe
16:15:32 <alar> there is one really useful imperative language
16:15:36 <Philippa> JohnnyL: assume when talking about haskell that knowledge from lisp doesn't port unless you've grounds to believe otherwise. They're very different languages
16:15:39 <alar> for programming
16:15:42 <alar> it's asm
16:15:54 <mahogny> Cale, :)
16:16:13 <ski> alar : that isn't how CLP nor mercury works, though
16:16:21 <lispy> mahogny: http://nice.sourceforge.net/
16:16:44 <mahogny> lispy, well. the only thing that really bothers me is that the type system in 1.5 came too late, and getters/setters need to go. expressiveness is secondary, as long as it is stable, works and is well supported
16:17:00 <JohnnyL> Philippa, for example, if you take Show, internally in code then redirected that information that comes to Show into a database you have pretty much covered how to transparently make haskell to the second tier. mahogny, what do you think of this idea?
16:17:25 <mahogny> o_O
16:17:30 <Philippa> not everything's Showable and that causes problems on its own
16:17:34 <mahogny> >=====> (nuke)
16:17:35 <alar> ski: then CLP either has axioms that disallow infinite looping (not my naive example) or search width-first or have some secret I don't know yet
16:17:46 <Philippa> otherwise a bunch of us've been thinking about related stuff already, it's worth pursuing
16:17:53 <ski> alar : do you know what CLP is ?
16:18:07 <alar> Constraint Logic Programming?
16:18:07 <JohnnyL> Philippa, your welcome.
16:18:08 <JohnnyL> :)
16:18:23 <Cale> There are a lot of languages which people call asm.
16:18:29 <JohnnyL> oh CLP is great if you have severly large legacy code.
16:18:50 <newsham> jsr $c000
16:18:59 <ski> alar : yes .. an it works by posting constraints on the variables .. and later when enough of them have been instantiated, it can simplify/execute the constraint (very simplified)
16:19:02 <mahogny> drop java. use jasmin!
16:19:42 <Philippa> JohnnyL: the Show thing works better with lisps for the most part, though I'm aware lisps can have non-serialisable structures too
16:19:45 <ski> alar : so an 'A = B+C' constraint would just sit there, passively, until enough data is known about the vars
16:19:54 <Philippa> but you can't show code in haskell at all
16:20:11 <ski> alar : also, in mercury, it's statically determined which direction flow is used
16:20:16 <JohnnyL> Philippa, i was complaining about that yesterday.
16:20:36 <Philippa> yeah. It's not going to get fixed. Fundamental difference between the languages and their programming models, that
16:20:49 <JohnnyL> no inspections, make it so, instead of storing it in ram, make a second storage hit for inspections, not to hard.
16:20:54 <Philippa> (OK, OK, slight lie: YHC looks like it'll have serialisable code)
16:21:00 <alar> ski: in Curry constraint A=:=B+C can't instantiate variables at all, there's specialized solver CLP(FD), but it isn't in core language
16:21:22 <JohnnyL> what's that, at most 32 bit for each function? and you can compress that too as well.
16:22:08 <ski> alar : o-k
16:22:09 <Philippa> that doesn't play so nicely if you want to dynload code though
16:22:12 <alar> maybe it's because their solver uses depth-first search
16:22:17 <Philippa> and in an enterprise environment I definitely do
16:22:21 <alar> or some other reasons
16:22:45 <ski> (alar : doesn't that have type 'Bool' or something in curry ?)
16:23:07 <JohnnyL> newsham, 6502? which platform?
16:23:22 <JohnnyL> wow
16:23:25 <newsham> c64 for me.
16:23:31 <ski> inc $d020
16:23:47 <JohnnyL> i just looked at Philippa's sentence and instead of seeing Very different languages I saw, Slightly different languages.
16:24:00 <JohnnyL> newsham, me too.
16:24:13 * JohnnyL high fives newsham.
16:24:14 <mwc> First computer nostalgic reminesence time?
16:24:18 <Philippa> JohnnyL: lisp's fundamentally imperative and introspective in nature. Biiiig difference, that
16:24:24 <ski> (c64 is actually 6510 .. no diff in the language, though)
16:24:26 <alar> that has type "Success" - mainly the same as Bool, but expressions of the type Success instantiate unbound variables, expressions of type Bool are simply evaluated
16:24:27 <JohnnyL> newsham, ever hear of the demo group Style?
16:24:39 <newsham> 6510 is just 6502 with io registers
16:24:41 <JohnnyL> i am there interim artist, we are thinking about going to cell phone.
16:24:43 <newsham> john: no
16:24:48 <ski> (newsham : right)
16:24:59 <alar> Bool = False | True and Success = Succes , but no Failure :)
16:25:20 <astrolabe> lisp is imperitive?
16:25:30 <Philippa> astrolabe: damn! right
16:25:32 <Cale> astrolabe: yes
16:25:45 <JohnnyL> hell yeah, it's like one big series.
16:25:47 <ski> (alar : ok .. well, mercury doesn't mix in functions into the LP lang in that way, though)
16:25:58 <Philippa> you can actually muck around with the values inside a closure in lisp
16:26:08 <Cale> astrolabe: It's frustrating, because it has just enough features to make you want to program in a functional style, but not enough to make it convenient.
16:26:08 <JohnnyL> it's main redeeming quality is macros. :)
16:26:13 <mwc> Philippa, yikes
16:26:39 <Oejet> Lemmih: ping.
16:26:54 <ski> common lisp is often claimed to be multi-paradigm
16:27:04 <Lemmih> Oejet: pong.
16:27:06 <Cale> Scheme looks nicer, but it's still imperative.
16:27:12 <Philippa> depending on how you define "paradigm" that's reasonable
16:27:20 <mwc> Cale, isn't scheme about as functional as SML?
16:27:24 <Philippa> the core language is imperative, it so happens you can build other styles on top
16:27:34 <Philippa> mwc: almost. Still can't screw with the contents of a closure in SML as far as I know?
16:27:36 <ski> mwc : more or less, yes
16:27:47 <astrolabe> But the code doesn't look like a sequence of instructions?
16:27:54 <vincenz> astrolabe: with ml?
16:28:01 <Philippa> astrolabe: it's a lisp. Everything's a list (sort of)
16:28:10 <vincenz> 'cept it's typed
16:28:21 <ski> Philippa : by 'screw with the contents of a closure' do you mean assigning to a free variable of the closure ?
16:28:21 <Oejet> Lemmih: Interested in the ICFP contest?
16:28:25 <Philippa> ski: yup
16:28:27 <mwc> Philippa, well, screwing around like that isn't something you'd do in a functional statement
16:28:38 * lispy wonders if he should mention that lisp doesn't actually have 'lists' it just has binary trees consructed from cons cells ;)
16:28:46 <Philippa> lispy: am fully aware of that :-)
16:28:53 <Heffalump> how is that not a list?
16:28:58 * lispy realizes he shouldn't mention it ;)
16:29:04 <Heffalump> well, how is it any less of a list than a Haskell list?
16:29:06 <Cale> ski: mutating a variable which a closure has bound as a parameter, I think
16:29:19 <mwc> I was talking about it has about the same amount of support, and the same holes big enough to drive a truck through (References, anyone)
16:29:36 <Philippa> Heffalump: "lists can contain lists", approximately speaking. And strictly speaking a cons can just contain two values with no nil
16:29:58 <vincenz> except that in ml, a cons can only occur in a list
16:29:59 <Heffalump> that's just a consequence of the lack of static types
16:30:02 <vincenz> and not as a two-cell item
16:30:02 <Philippa> it's an unrestricted binary tree, haskell lists aren't
16:30:11 <Heffalump> it's not specific to lists
16:30:19 <vincenz> @localtime Cale 
16:30:44 <vincenz> > 1
16:30:45 <lambdabot> 1
16:30:49 <vincenz> lambdabot: there you are
16:30:52 <Lemmih> Oejet: Yeah.
16:30:56 <Philippa> I think "just" is a bit OTT. There're genuine uses for cons trees without nils in lisp
16:31:23 <vincenz> I've been considering the possibility of multi-tailed lists
16:31:28 <Heffalump> I'm sure there are, but add static typing and they'd stop working
16:31:31 <Philippa> to me, that ceases to be isomorphic to a sequence - you can flatten it into one, but that's not the same thing
16:31:33 <Cale> vincenz: trees?
16:31:44 <vincenz> Cale: hmm... well binary for sure
16:31:45 <Philippa> and they'd stop being lisp cons cells in the process
16:32:05 <vincenz> Cale: but no not trees
16:32:22 <Oejet> Lemmih: Jump to #oasis for a tiny bit of planning.
16:32:24 <Cale> vincenz: can you write what you mean as a data declaration? :)
16:32:27 <Philippa> furthermore, lisp'd consequentially stop being lisp in a far more fundamental manner than a mere addition of static typing would cause
16:32:34 <vincenz> Cale: like I said, been thinking about it ;)
16:32:37 <Heffalump> the #haskell get-together poll needs more options
16:32:54 <xerox> Yes indeed.
16:32:56 <vincenz> Cale: basically the issue with lists is that if you want to replace the tail bit, you're doing a lot of re-allocation
16:32:58 <Heffalump> like "maybe" and "yes if important darcs people go"
16:33:15 <Heffalump> and "hmm, maybe but I'm already kind of busy those months", that sort of thing :-)
16:33:48 <lispy> Heffalump: you can model lisp style cons in haskell even with static typing
16:34:01 <xerox> Heffalump: I subscribe for the last one!
16:34:14 <JohnnyL> ya have to like the footprint of lisps interpreter.
16:34:17 <xerox> I'd love to, but I have exams in that period :-(
16:34:48 <Cale> vincenz: well, using balanced trees will help there
16:35:25 <vincenz> Cale: balanced trees lose ordering to be "balanced"
16:36:05 <Cale> vincenz: I just mean balanced in node counts.
16:36:08 <vincenz> balanced trees are set like, not sequence like, basically, or map like
16:36:16 <newsham> umm.. balanced trees are usually ordered, arent they?
16:36:19 <Cale> Not search trees
16:36:22 <newsham> thats usually the point of using a tree
16:39:08 <lispy> newsham: i wouldn't really consider an AST to be ordered...structured yes, but not really ordered and i'd say that's a pretty common use
16:39:33 <Cale> Ordered by preorder traversal
16:40:29 <Cale> However, there's not really any data structure which could 'replace' lists. (Lazy) lists are the data-structure form of loops/linear recursion.
16:41:06 <Cale> but there's lots of other sequence data structures which are more appropriate in various circumstances
16:41:26 <xerox> Cyclic graphs? :-)
16:41:27 <Cale> iirc, there's a decent Sequence library going into the next GHC
16:43:27 <Cale> http://www.haskell.org/ghc/dist/current/docs/libraries/base/Data-Sequence.html
16:44:55 <xerox> `adjust' is exactly what someone wanted some days ago...
16:44:58 <mauke> I want automagically defined destructor functions
16:45:02 <xerox> He was trying to do it with arrays.
16:46:07 <mwc> What's a destructor function for haskell? Something to do with foreign language interfacing?
16:46:25 <xerox> data Foo = Foo Int
16:46:26 <mauke> no, the opposite of a constructor
16:46:34 <xerox> Something like unFoo :: Foo -> Int
16:46:36 <vincenz> data Foo = Foo {unFoo :: Int}
16:46:40 <vincenz> unFoo is a destructor
16:46:49 <mwc> Ah
16:46:54 <xerox> Well, he wants them automatically defined.
16:46:57 <mauke> destruct_list z f [] = z; destruct_list z f (x : xs) = f x xs
16:46:59 <vincenz> or just a function like xerox mentioned
16:47:00 <lispy> so fromJust and runST are other examples?
16:47:07 <mauke> like that
16:47:28 <mauke> it's like fold without the recursion
16:47:31 <Cale> mauke: why not  destruct_list z f (x : xs) = f x (destruct_list z f xs)
16:47:34 <xerox> desctruct_list = fold?
16:47:35 <Cale> (i.e. foldr)
16:47:42 <mauke> because that's not flexible enough
16:47:54 <lispy> @type unfoldr
16:47:55 <lambdabot> forall a b. (b -> Maybe (a, b)) -> b -> [a]
16:47:59 <Cale> foldr is universal
16:48:19 <Cale> You can basically write any list function as a foldr
16:48:22 <mauke> with destruct_list I can abort the computation early and I get context for free
16:48:45 <Cale> You can abort the computation early with foldr too :)
16:48:57 <mauke> not in OCaml :-)
16:49:02 <palomer> whew, just refactored a couple of hundred lines of code without compiling
16:49:33 <lispy> palomer: good luck!
16:50:09 <palomer> yeah, my program is broken
16:50:11 <palomer> :o)
16:51:26 <mauke> foldr z f = destruct_list z f' where f' x xs = f x (foldr z f xs) -- I think
16:51:48 <lispy> palomer: you use darcs right? time to revert :)
16:53:45 <vincenz> @see dons
16:53:46 <lambdabot> dons is in #haskell. I don't know when dons last spoke.
16:53:51 <vincenz> mauke: yes you can
16:53:53 <vincenz> mauke: use exceptions
16:54:04 <vincenz> iirc
16:54:11 <mauke> yeah, but ... eww
16:54:14 <Cale> huh?
16:54:19 <vincenz> Cale: aborting foldr
16:54:20 <Cale> you don't need exceptions
16:54:27 <Cale> you just return a value early
16:54:41 <vincenz> not in ocaml
16:54:44 <Cale> (just have f ignore its right arg)
16:54:48 <vincenz> it ain't lazy, member?
16:54:49 <Cale> sure, but that's ocaml
16:54:57 <vincenz> well mauke said you can't abort early in ocaml
16:54:59 <vincenz> so... exceptions
16:55:06 <Cale> ocaml doesn't even have automatic contructors
16:55:08 <mauke> wait, that doesn't work either
16:55:15 <vincenz> mauke: yes it does
16:55:22 <vincenz> throw the result in an exception
16:55:38 <xerox> And you have to 'catch' every foldr?
16:55:47 <mauke> I want to walk the list from left to right, though
16:56:07 <xerox> You can do it with foldr nevertheless
16:56:41 <ski> Cale : 'automatic contructors' ?
16:58:04 <lispy> maybe you could use the lazy module in ocaml? (/me has no clue if that would help)
16:58:07 <mauke> ok, let's say I have a tree that represents a C expression
16:58:26 <mauke> I want to walk this tree and do stuff to objects
16:58:32 <vincenz> lispy: there are lazy values
16:58:40 <vincenz> lazy int
16:59:09 <mauke> however, I need to distinguish between write accesses (=, ++, --, etc) and read accesses (everything else)
16:59:39 <ski> vincenz : but the fold would not be lazy anyway
17:00:02 <mauke> I don't see how I can use fold for that, because the base case of Var s needs to know about its context
17:00:07 <Cale> ski: iirc, constructors aren't functions
17:00:25 <ski> ah, that
17:01:52 <Cale> Is there any reason for that?
17:02:33 <ski> i guess they just wanted to see explicitely when closures that will call a constructor is called
17:03:16 <ski> vincenz : maybe something alike "lazy_fold_right : ('a -> 'r lazy -> 'r lazy) -> 'a list -> 'r lazy -> 'r lazy", specifically written to be lazy, would work ..
17:03:32 <alar> why constructions (formally) are not functions?
17:04:20 <Cale> alar: well, you can separate them, but I don't see a really great reason to
17:05:09 <vincenz> ski: not sure
17:05:15 <alar> Cale: I don't see formal dirrerence
17:05:24 <vincenz> ski: either way... ocaml is a funky language
17:05:25 <alar> difference
17:05:29 <vincenz> ski: you can pass around ref's
17:05:44 <ski> vincenz : you can in haskell, too
17:06:24 <Cale> alar: well, if constructors aren't functions, then writing something like ((:) 1) has no meaning
17:06:51 <Cale> alar: the rule would be that you have to fully apply them wherever they're used
17:07:02 <vincenz> Cale: constructors not being first class in ocaml really irked e
17:07:05 <vincenz> Cale: can't pass em around
17:07:25 <alar> Cale: there is a proposition of partial types or I got that wrong?
17:07:32 <ski> Cale : ocaml doesn't have curried constructors
17:07:36 <Cale> ski: right
17:07:43 <Cale> ski: (that's what I was trying to say :)
17:07:57 <alar> ah, you're talking about O'Caml
17:08:01 <Cale> yeah
17:08:15 <Cale> With Haskell, constructors are most certainly functions
17:08:27 <ski> Cale : but you still can't pass (function-typed) constructors as arguments
17:08:52 * alar does not know O'Caml and is not sure he should learn it
17:09:10 <Cale> ski: hm?
17:09:27 <Cale> ski: I thought constructors didn't have types, or something like that.
17:09:39 <mauke> yeah, constructors are more like keywords than values
17:10:01 <ski> Cale : yeah, i guess one can see/explain it like that
17:12:06 <Cale> I wonder why they didn't just make viewl and viewr return lists
17:13:12 <Cale> (in Data.Sequence)
17:15:12 <Cale> there aren't maps ViewL a -> Seq a  and ViewR a -> Seq a  anyway, so it actually looks less convenient
17:23:36 <Cale> (well, in the library I mean, obviously you can easily write them)
17:30:05 <JohnnyL> hoogle is great but where can i find information on '<-'?
17:30:40 <Korollary> that's syntactic sugar, so either in a tutorial or the report.
17:31:10 <JohnnyL> k
17:31:12 <JohnnyL> thx.
18:04:30 <ulfdoz> a.k.a. "harte wie'n Koffergriff"
18:04:36 <ulfdoz> ECHAN, sorry
18:04:48 * ulfdoz is a quite a bit drunken.
18:06:04 <vincenz> Cale: alive?
18:06:47 <ulfdoz> vincenz: Sorry, I'm not registered, but yes, I'am.
18:12:19 <JohnnyL> i cant' find it anywhere, what does <- mean?
18:12:58 <alar> you mean "do comprehension"?
18:13:47 <JohnnyL> transpose ((x:xs: xss) = (x: [h| (h:t) <- xss) : ...
18:14:27 <Cale> JohnnyL: there, it's something like "is drawn from"
18:14:49 <Cale> JohnnyL: Arrows mean different things in different places in the syntax
18:15:20 <JohnnyL> Cale, and only the tutorials know for sure (besides my hair stylist)?
18:15:34 <Cale> The Report
18:15:53 <Cale> http://www.haskell.org/onlinereport/
18:16:01 <JohnnyL> i did search on <- in the major areas of the report, couldn't find it.
18:16:14 <Cale> it's part of the list comprehension syntax here
18:16:35 <Cale> which should show up in "expressions"
18:16:45 <Cale> http://www.haskell.org/onlinereport/exps.html#list-comprehensions
18:17:02 <Cale> http://www.cs.uu.nl/~afie/haskell/tourofsyntax.html#List%20comprehensions
18:17:13 <Cale> there's another page which might interest you :)
18:17:52 <vincenz> Cale: can you get lambdabot into #oasis
18:17:56 <Cale> sure
18:18:01 <Cale> @join #oasis
18:18:27 <JohnnyL> Cale, ok that works, thanks.
18:18:46 <Cale> JohnnyL: List comprehensions are somewhat analogous to set comprehensions in mathematics
18:18:48 <vincenz> Cale: I made a preliminary page
18:18:58 <JohnnyL> cool.
18:19:19 <Cale> you might remember using notation like {(x,y) : x in R, y = x^2}
18:19:19 <JohnnyL> Cale, over the past 4 years, I have had a love for any type of math (although I stink at it).
18:20:32 <Cale> JohnnyL: my favourite introduction to mathematics is Michael Spivak's book "Calculus" -- I recommend it to everyone :)
18:20:58 <Cale> (if you're interested, note that it's not the same book as "Calculus on Manifolds" -- that book is decent too, but entirely different)
18:21:04 <Korollary> haskell needs more social sciences majors
18:23:25 <JohnnyL> ok
18:25:46 <Cale> I'm not sure how much you know already, but that book is basically an intro to modern mathematics, with the guise of being about calculus. (Some people would consider it more of an intro real analysis text)
18:28:14 <alar> what should I do to lure lambdabot in channel?
18:28:27 <alar> become an admin? :)
18:28:30 <Cale> yes
18:28:44 <Cale> or run your own, or ask me and I'll get it to join :)
18:29:07 <alar> does lambdabot stay in channel when all live people leave it?
18:29:15 <Cale> yes
18:29:31 <Cale> though it won't rejoin automatically when it reconnects unless the channel is in its config file
18:29:47 <Cale> (should really do something about that)
18:30:03 <alar> then, send it to #haskell_ru, please
18:30:11 <Cale> @join #haskell_ru
18:30:15 <Cale> should be there :)
18:30:17 <vincenz> @botsnack
18:30:18 <lambdabot> :)
18:30:19 <alar> @karma+ Cale
18:30:20 <lambdabot> Cale's karma raised to 9.
18:31:02 <Cale> :)
18:31:41 <palomer> <:o
18:32:00 <vincenz> Cale: checked the link?
18:34:45 <Cale> vincenz: your wiki? I was just looking now :)
18:34:50 <vincenz> kewl
18:35:48 <vincenz> btw
18:35:51 <vincenz> anyone have the geshi plugin for haskell
18:35:54 <vincenz> I know haskell.org uses it
18:35:58 <vincenz> but it's nowhere to be found
18:52:58 <palomer> vincenz: sorry bout that, was away for a while
18:54:38 <metaperl> @type map
18:54:40 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
18:54:42 <metaperl> @type bind
18:54:43 <lambdabot> Not in scope: `bind'
18:54:55 <metaperl> @type (>>=)
18:54:57 <lambdabot> forall (m :: * -> *) b a.
18:54:57 <lambdabot>    (Monad m) =>
18:54:57 <lambdabot>    m a -> (a -> m b) -> m b
18:55:27 <metaperl> map and return both transform what is in a container
18:55:32 <metaperl> map and bind, sorry
18:55:37 <jip> what is () called again?
18:56:01 <Korollary> unit iirc
18:56:03 <vincenz> palomer: hi
18:56:09 <metaperl> map uses (a -> b) and bind uses (a -> m b).
18:56:18 <palomer> yo
18:56:24 <metaperl> one can consider [a] as a special case of m a. no?
18:56:41 <metaperl> then map is just a special case of (>>=)... correct?
18:56:47 <palomer> any element of [a] is also an element of Monad m => m a
18:57:04 <palomer> metaperl: not quite
18:57:12 <palomer> you need to map and concat at the end
18:59:42 * metaperl returns to beginning of monads as containers
19:01:05 <ulfdoz> [AI understood monads by thinking about it as "reconstruction of a new value".
19:02:08 <lispy> hm...i just tried to compile darcs and gcc consumed so much ram that the linux out of memory killer killed it
19:02:25 <lispy> on a machine with 1GB of ram
19:03:20 <ulfdoz> use 2GB :)
19:03:48 <palomer> lispy: get more swap space
19:04:00 <ulfdoz> I even couldn't compile ghc with 64MB of physical ram and 256MB of swap
19:04:55 <lispy> palomer: i have no swap, but actually i think gcc was run away
19:05:51 <metaperl> @type fmap
19:05:52 <lambdabot> forall (f :: * -> *) b a.
19:05:52 <lambdabot>    (Functor f) =>
19:05:52 <lambdabot>    (a -> b) -> f a -> f b
19:05:56 <palomer> what's gcc doing compiling darcs?
19:05:57 <metaperl> @type map
19:05:58 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
19:06:23 <lispy> palomer: have you seen the darcs source code?  there's a fair bit of C
19:07:11 <Lemmih> And the Haskell code is compiled to C.
19:07:46 <lispy> oh yeah, i forget about that part
19:07:56 <lispy> so what was the way to set the gcc version that ghc uses?
19:08:05 <lispy> GCC=foo ghc .. ?
19:11:01 <lispy> -pgmc gcc
19:11:05 <lispy> that'sw hat i need
19:14:49 <lispy> that seems to have fixed it, upgraded from gcc-4.0.3 to gcc-4.1
19:16:32 <loufoque> what's so great with functional programming ?
19:16:41 <loufoque> could it make my life better ?
19:17:11 <Cale> sure :)
19:17:18 <alar> it could make your code shorter alot
19:17:32 <alar> Ericson says 10-20 times
19:18:04 <loufoque> Ericsson ? Are you talking about erlang ?
19:18:25 <Cale> not just Erlang, but a study which Erisson did on programming languages
19:18:36 <vincenz> palomer: ping
19:19:17 <Cale> I also find that I have a much nicer view of programming now that I know Haskell -- there are lots of new concepts in it, and you learn to look at your code differently in any language.
19:19:24 <loufoque> well the readability and maintainability is what's important, and it doesn't really depend on the code size
19:20:00 <palomer> vincenz: pong
19:20:20 * alar does not think so
19:20:36 <lispy> loufoque: well, haskell's type system helps with maintainability
19:20:40 <rasterfar> it's not so much being able to read it, as having confidence in its correctness, which makes code maintainable
19:20:49 <Cale> It's usually quite readable, I find -- of course, you can still write bad code. Maintainability is usually pretty excellent.
19:21:08 <lispy> loufoque: the compiler knows when you make a type errors..so if you change a datastructure it can find the places you're not using it correctly
19:21:22 <qwr> hmm... debian ghc 6.4 tells Failed to load interface for `ParsecExpr': Could not find module `ParsecExpr':
19:21:37 <vincenz> palomer: not getting my pm?
19:21:57 <Cale> The type system does help a lot -- you can often jump into well written code, just looking at the types of things, and figure out where to add your component, or which parts to use to get the effect you want.
19:22:04 <qwr> although ghc -v5 ... lists ParsecExpr as exposed module
19:22:04 <lispy> qwr: are you following the documentation at the  parsec website?  I seem to recall their examples using the old module layout and giving errors like that
19:22:10 <alar> yes, that's exciting with haskell: if my program is erroneous most of the time typecheckers detects it
19:22:17 <palomer> vincenz: oh, righto, forgot to register my nick
19:22:27 <palomer> so you weren't receiving my repiles
19:22:32 <vincenz> ah
19:22:32 <vincenz> that's why
19:22:33 <palomer> s/repiles/replies
19:22:33 <vincenz> hehe
19:22:37 <vincenz> reptiles
19:23:43 <qwr> lispy: yes, i'm trying one of their examples
19:25:49 <Korollary> qwr: ghc-pkg describe parsec shows "Text.ParserCombinators.Parsec.Expr"
19:27:25 <Cale> loufoque: another thing is that it's just fun to program in Haskell -- you don't feel so much like you're writing boilerplate code all the time, and if it compiles, it usually works, since the typesystem catches 80 or 90 percent of all the stupid mistakes which the compilers in other languages wouldn't.
19:27:56 <metaperl> both map and concatMap consume [a] to produce [b]. concatMap seems long-winded and inefficient: it containerizes each transformed element of [a]  as a singleton list [b] all of which then have concat applied to them to create [b]... why would someone go to that trouble?
19:27:57 <vincenz> Cale: put you as possible?
19:28:08 <vincenz> metaperl: not quite
19:28:15 <vincenz> map :: (a -> b) [a] -> [b]
19:28:16 <loufoque> what about Haskell's lack of OOP ?
19:28:25 <vincenz> concatMap :: (a -> [b]) -> [a] -> [b]
19:28:27 <vincenz> quite different
19:28:43 <vincenz> if you have multiple results
19:28:45 <vincenz> you can't do that with map
19:28:48 <Cale> loufoque: It has other features which generally make up for any lack of OOP.
19:29:12 <Cale> loufoque: Convenient parametric polymorphism, and the things you can do with typeclasses handle most of it
19:29:33 <alar> having functions as first class members and polymorphism are more powerful than OOP
19:30:18 <metaperl> vincenz: ah, so when you have a non-deterministic function on a, then concatMap is of use
19:30:32 <vincenz> metaperl: yep
19:30:41 * metaperl sees the light
19:30:43 <metaperl> :)
19:30:59 <vincenz> for instance
19:31:04 <mux>  does GHC lack the Parsec module?
19:31:20 <vincenz> concatMap findroots [quadratic equations]
19:31:57 <ayrnieu> loufoque - in Haskell you use very clever types and typeclasses where you would reach for objects in other languages.
19:32:01 <metaperl> sweet
19:32:11 <Cale> loufoque: There are also language extensions which give you existential types, which is basically what OOP is (though it might take a while to see exactly how that is).
19:32:21 <metaperl> mux: it's way down the in type hierarchy but GHC does ship with it
19:32:28 <metaperl> Text.Parser.Combinators
19:32:30 <Cale> (though it'll be the next release of GHC which really makes it convenient for OO programming)
19:32:30 <metaperl> something like that
19:32:43 <mux> ok, I'll look for it, thanks
19:33:13 <mux> I can just have import Parsec with hugs in the meantime
19:33:32 <Cale> But in FP, things are usually sort of 'dual' to OO in a strange way. Data is inextensible, but the operations on it are very extensible, which is sort of the reverse of the situation in OO-land.
19:33:40 <vincenz> metaperl: not regged?
19:34:10 <metaperl> regged?
19:34:14 <metaperl> what does that mean?
19:34:26 <vincenz> registered with nickserv
19:34:31 <Cale> Also, in a lazy language, a lot of the things which you'd use control structures for in an imperative language become data structures -- you use lists where you would have used loops.
19:34:32 <ayrnieu> cale - where can I read about existential types and what the next release of GHC does to make them convenient for OO?
19:35:04 <metaperl> vincenz: oh I am... I just dont bother to IDENTIFY
19:35:04 <Cale> ayrnieu: The old wiki has some stuff, let me dig
19:35:25 <ayrnieu> Cale - thanks :-)
19:35:31 <vincenz> metaperl: then I can't see whhat you pm me
19:35:40 <metaperl> oh ok hold on
19:35:44 <Cale> ayrnieu: http://www.haskell.org/hawiki/Existentially_20quantified_20record_20constructors -- this is the extension which will make OO pretty
19:37:56 <Cale> http://www.haskell.org/hawiki/ExistentialTypes
19:38:15 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html
19:46:41 <jip> where's that haskell html colorizer thing?
19:47:30 <CrewdenX> jip: dunno, but you should be able to do it with vim, if nothing else.
19:48:10 <jip> CrewdenX: nah, vim doesn't do a great job
19:48:35 <jip> @seen shapr 
19:48:36 <lambdabot> shapr is in #scannedinavian, #haskell and #ScannedInAvian. I last heard shapr speak 1 day, 12 hours, 39 minutes and 41 seconds ago.
19:49:00 <CrewdenX> jip: ok.
19:50:17 <jip> there was this website that worked great but i can't find it :\
19:50:25 <mwc> jip, vim, are you looking for a pretty printer or just a syntax colorizer
19:50:40 <jip> mwc: syntax colorizer
19:50:43 <mwc> jip, www.haskell.org/hawiki can do it (old haskell wiki)
19:51:27 <vincenz> yeah
19:51:28 <vincenz> actually
19:51:32 <vincenz> I had to look for a LONG time for that
19:51:34 <vincenz> eventually I found it
19:51:37 <vincenz> on the oddest place of all
19:51:40 <vincenz> and it was not the latest
19:51:53 <vincenz> let me find the link again
19:52:10 <vincenz> http://www.codersbase.com/index.php/Geshi_haskell
19:52:37 <vincenz> finally found it by tweaking my google search
19:52:38 <vincenz> and being lucky
19:52:45 <vincenz> original author doesn't provide a link
19:54:03 <jip> hm.... there was another one
19:55:16 <rasfar> jip: not thinking of hIDE are you?
19:55:45 <rasfar> (oh html, never mind)
20:02:36 <alar> is #epigram a forsaken channel?
20:15:45 <jip> argh, i can't believe i can't find that shit that i saw a long time ago :|
20:16:00 <vincenz> jip: down the toilet?
20:24:44 <jip> :O
20:28:08 <vincenz> anyone have a good haskell team suggestion?
20:28:13 <vincenz> ...name
20:28:18 <vincenz> teamname
20:28:33 <newsham> lazy coders
20:28:43 <newsham> lazy lambdas
20:29:41 <newsham> the supercombinators
20:30:14 <vincenz> newsham: you're on a roll
20:30:39 <alar> lazy oasis :)
20:30:43 <newsham> team ">>="
20:30:54 <alar> oazy lasis
20:31:21 <vincenz> functional crap
20:31:34 <newsham> barely functioning
20:32:47 <newsham> monadnucleosis
20:33:02 <vincenz> ooh
20:34:00 <newsham> monad a monad
20:34:56 <vincenz> newsham: I should have you put these on the wiki
20:35:27 <newsham> [5]+  Segmentation fault      ~/bin/hws-wp
20:35:41 <vincenz> newsham: I meant http://www.notvincenz.com/wiki/pmwiki.php/Icfp/Main
20:36:37 <alar> segmentation fault 
20:36:43 <alar> sounds nice name to me
20:36:50 <vincenz> pure segmentation fault
20:36:58 <vincenz> :)
20:36:58 <newsham> team segv?
20:37:27 <newsham> team unemployed phds?  ;-)
20:37:38 * vincenz is an employed phd
20:38:16 * alar is not phd
20:38:21 <newsham> monadic vow
20:39:06 <newsham> Monadic Art and Architecture
20:39:21 <jip> funky monads
20:39:31 <newsham> http://www.efn.org/~russelln/art.html
20:39:38 <alar> monky fonads
20:39:53 <newsham> felonius monad
20:42:22 <newsham> vincenz and the pointless functions?
20:42:57 <alar> Monad.Functor ?
20:43:13 <newsham> i was thinkign Control.Monad if you want a lib type name
20:44:15 <newsham> cant think of a good one usign "curried"...
20:46:06 <rasfar> curried lamb, das?
20:57:37 <petekaz> @seen Cale 
20:57:38 <lambdabot> Cale is in #oasis and #haskell. I last heard Cale speak 21 minutes and 23 seconds ago.
20:58:27 <Cale> hi
20:59:11 <petekaz> Cale: earlier you mentioned that "in a lazy language, a lot of the things which you'd use control structures for in a an imperative language become data structures -- you use lists where you would have used loops."  Could you explain that to me?
20:59:17 <petekaz> Maybe an example?
20:59:56 <Cale> sure
21:00:24 <Cale> With lazy evaluation, data structures are only built as they're needed, and not before
21:00:32 * petekaz is in the middle of YAHT and trying to compare haskell with other languages he knows.
21:00:52 <Cale> do you know the map function?
21:01:00 <petekaz> yes.
21:01:03 <Cale> okay
21:01:12 <Cale> let's say I have a couple of definitions like
21:01:13 * petekaz is familiar with CL/scheme
21:01:25 <Cale> evens = 0 : map (+1) odds
21:01:30 <Cale> odds = map (+1) evens
21:01:40 <Cale> (:) is cons
21:01:50 <petekaz> ok.
21:01:59 <Cale> well, already, we're seeing some pretty interesting control flow
21:02:24 <Cale> let's say I want to get the 3rd element of odds
21:02:48 <petekaz> odds !! 3?
21:02:55 <Cale> odds !! 2
21:03:02 <petekaz> right.
21:03:02 <Cale> either way :)
21:03:36 <Cale> what will happen is the evaluation will bounce back and forth between evens and odds
21:03:53 <petekaz> I see.
21:04:10 <Cale> they're both infinite lists, but they exhibit somewhat coroutine-like behaviour
21:04:25 <newsham> like generators.  wee.
21:04:57 <petekaz> Ok. I understand.
21:05:41 <Cale> also, even with things like IO, you tend to use lists together with a higher order function like mapM to get loops
21:06:15 <Cale> mapM takes a function from values to actions, and a list of values, and constructs an action producing a list of all the results
21:06:23 <Cale> @type mapM
21:06:24 <lambdabot> forall b (m :: * -> *) a.
21:06:24 <lambdabot>    (Monad m) =>
21:06:24 <lambdabot>    (a -> m b) -> [a] -> m [b]
21:06:32 <newsham> @type when
21:06:33 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
21:07:12 <petekaz> Cale: can you give me an example of that?
21:07:25 <Cale> mapM print [1..10]
21:07:28 <Cale> Is just like
21:07:35 <Cale> for i from 1 to 10
21:07:36 <Cale>    print i
21:07:40 <petekaz> right.
21:07:53 <petekaz> But I can do that in any language that has a map, no?
21:08:21 <Cale> yes, but here, you even do it with your infinite loops :)
21:08:24 <petekaz> or even a list comprehensions (which would be wasteful as there is no return value)
21:08:38 <newsham> mapM also wasteful with no return value
21:08:52 <Cale> mapM_ is for when you don't care about the results
21:09:07 <Cale> lists are quite good for iterative algorithms too
21:10:21 <petekaz> @type mapM_
21:10:23 <lambdabot> forall (m :: * -> *) a b.
21:10:23 <lambdabot>    (Monad m) =>
21:10:23 <lambdabot>    (a -> m b) -> [a] -> m ()
21:10:32 <Cale> you produce lists where the elements give (hopefully) better and better approximations to a solution, and then you can use things like dropWhile and other list functions to manipulate things
21:11:10 <lispy> @type dropWhile
21:11:11 <petekaz> Sounds great if you are into math ... I do more practical stuff for work.
21:11:11 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
21:11:51 <Cale> petekaz: well, once you're somewhat used to it, it's nice even for fairly mundane things
21:11:58 <newsham> petekaz: you probably still iterate over things
21:12:10 <newsham> @type scanl
21:12:11 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
21:12:16 <Cale> If you ever have to do search with backtracking, the list monad is great :)
21:12:26 <lispy> speaking of practical things, i wish java had tuples..
21:12:31 <petekaz> I need to read the rest of YAHT and look at example code to see if haskell can be useful for me.  It's strange, the one thing everyone here loves, the static typing, I hate.  I prefer languages like python, ruby, scheme, etc ...
21:13:02 <Cale> petekaz: well, static typing is frustrating when the type language is inflexible
21:13:04 <alar> Cale: list monad for search? I thought trees are used for that
21:13:27 <lispy> petekaz: well, which static languages have you used before?  C? C/C++?  I hate static typing in those languages
21:13:27 <Cale> alar: sure
21:13:35 <petekaz> C/Java
21:13:51 <palomer> static typing in C++ is quite powerful
21:13:51 <lispy> yeah the java type system is annoying...generics help a lot though
21:13:53 <Cale> alar: though you're right, trees can be better depending on how much control you want over how the computation proceeds
21:14:11 <petekaz> I'm so much more productive in dynamic languages.
21:14:17 <Cale> > do x <- [1..20]; y <- [x..20]; z <- [y..20]; guard $ x^2 + y^2 == z^2; return (x,y,z)
21:14:18 <lambdabot> [(3,4,5),(5,12,13),(6,8,10),(8,15,17),(9,12,15),(12,16,20)]
21:14:37 <Cale> I'd argue that C++'s typing is still annoying
21:14:41 <lispy> palomer: well, true...my gripe with C++ is probably more related to the type safety
21:14:47 <newsham> alar: list monads let you perform multi-value operations.
21:14:47 <Cale> No type inference is awful
21:14:53 <newsham> (even if you're using trees)
21:14:56 <Cale> alar: check that example :)
21:15:15 <lispy> petekaz: yeah me too unless the static typed language is haskell
21:15:18 <alar> @hooggle guard
21:15:19 <lambdabot> Monad.guard :: MonadPlus a => Bool -> a ()
21:15:19 <lambdabot> Control.Monad.guard :: MonadPlus m => Bool -> m ()
21:15:19 <lambdabot> Language.Haskell.TH.Guard :: data Guard
21:15:37 <Cale> guard p = if p then [()] else []
21:15:39 <Cale> basically
21:15:39 <lispy> petekaz: take python for example.  Development in python is just plain fast
21:15:46 <Cale> (that's specialised to lists)
21:15:51 <newsham> alar: familiar with Maybe?  list monad is similar (maybe monad is like [] [x]  in list monad)
21:16:11 <lispy> petekaz: but after learning some of haskell idioms i think i can write less code at a similar speed in haskell (meaning over all faster)
21:16:30 <Cale> petekaz: the thing is, you don't have to write the type of most things if you don't want to
21:16:48 <Cale> But the compiler will still statically infer that everything works
21:17:05 <petekaz> lispy: yeah, I love python and use it most extensively at work.  To better myself, I love learning languages, I'm reading SICP, playing with erlang, and now looking at haskell.
21:17:26 <wolverian> Cale, but static typing is not as expressive. so we need a hybrid language. 
21:17:28 <Cale> and if you add some type signatures, it will both improve compile-time error messages, and check that your type matches the inferred type
21:17:31 <lispy> petekaz: awesome
21:17:49 <Cale> wolverian: I've never found I really needed dynamic typing
21:17:59 <lispy> petekaz: work is where i use python.  they don't want me to use haskell for things we give to clients because i'm only an intern and someone will have to maintain it some day :)
21:18:15 <Cale> I can see it being useful if you were loading code at runtime
21:18:25 <wolverian> Cale, I very much like specifying that a parameter has to be 1 < x < 9, for an example, and making it a type error if it's not, even if it's a runtime type error.
21:18:25 <lispy> Cale: you probably also don't write a lot of glue and scripting code?
21:19:06 <newsham> cale: is that suprising?  people who dont have closures dont ever find a need for them either
21:19:16 <Cale> lispy: I don't know about that. I've written a reasonable amount of that sort of thing in Haskell with no problems.
21:19:20 <newsham> when you have a hammer everything looks like a nail
21:19:32 <wolverian> ..and when c++ is your hammer everything looks like a thumb
21:19:44 <lispy> Cale: well those are the situations when people usually find dynamic typing appealing
21:20:15 <Cale> wolverian: it would be nice to have further runtime constraints -- I'd hesitate to call something like that a type.
21:20:28 <Cale> (but I can see how it might be one)
21:20:59 <Cale> lispy: why is that? Why wouldn't you be able to determine your types statically?
21:21:01 <lispy> i think performance aside one of the coolest not-necessarily-functional ideas about haskell is that String = [Char]
21:21:11 <petekaz> Personally, I'm trying to see where haskell is on the language power scale (refering to graham's term).  Do I see haskell as strange simply because I do not understand it.  Am I not capable of looking up the power scale, and the rest of you are laughing at folks like us?
21:21:15 <wolverian> Cale, it's a type with constraints. it's not quite the same thing, as there are new problems with determining the distance of types now, but .. it's interesting, at least.
21:21:30 <Cale> wolverian: yeah
21:21:39 <petekaz> So once I learn it, I hope to have a better perspective.
21:21:49 <Cale> petekaz: I think most people find that
21:21:55 <lispy> Cale: well a lot of times when scripting or gluing things together knowing the types or processing them matters very little.  You just want your chunk of code to do it's little part regardless of how you change the rest
21:22:06 <lispy> Cale: it basically comes down to decopuling
21:22:21 <Cale> lispy: how is that not just parametric polymorphism?
21:22:46 <lispy> Cale: keep in mind, i like static typing in haskell.  I'm argueing for why people like it
21:22:51 <Cale> ah, okay :)
21:23:24 <Cale> My argument is that as your type system gets more expressive, you have less reasons to want dynamic typing.
21:23:30 <newsham> duck typing is more general than haskells type system
21:23:37 <newsham> luckily you rarely need more expressiveness
21:23:39 <wolverian> but static typing can never be as expressive as dynamic typing
21:23:44 <Cale> (and it's usually expressive enough in Haskell, at least in my experience)
21:24:03 <wolverian> so, why not have the capability?
21:24:04 <Cale> Besides, GHC has dynamics if you really need them :)
21:24:20 <Cale> and existential types, which are even better
21:24:23 <wolverian> heh
21:24:56 <wolverian> I'm trying to put together linguistics and mathematics here and it's just not working, so I'm leaving it to larry and the perl6 folk to sort out. 
21:25:02 <wolverian> (which they seem to be doing admirably enough)
21:25:10 <wolverian> anyway, time to go sleep, the sun is rising. :) 
21:25:19 <gzl> I feel like perl has the worst of all worlds.
21:25:33 <Cale> hehe
21:25:42 <wolverian> gzl, it's a love-or-hate language, sure enough.
21:25:51 <Cale> I really like static guarantees
21:26:25 <Cale> everything the compiler can prove for me is another thing of which I don't have to convince myself
21:26:48 <wolverian> Cale, okay, last comment. me too. that's why I want to see static typing, not just dynamic typing. I like both.
21:26:56 <Cale> (and consequently, another thing I don't have to think about)
21:27:02 <alar> Cale: have you looked at Epigram?
21:27:07 <Cale> alar: yeah :)
21:27:20 <newsham> cale: when programmign in dynamic-typed languages, you (the programmer) still give yourself interface guarantees
21:27:21 <petekaz> Cale: The last example you sent to lambdabot, from what I've learned so far, when in a do statement, and using the <- assignment, the thing on the RHS is supposed to be a monad action no?  Is a list a monad?  Why does this work:  do x <- [1 .. 10]; return x  ??  When I do :t [1 .. 10], I don't see any monad indications?
21:27:21 <Cale> alar: epigram has a serious syntax problem though :)
21:27:30 <newsham> they're just not verified by the compiler.
21:27:47 <Cale> petekaz: Lists form a monad, yes
21:28:06 <gzl> I have to say, I've had to use Python quite a bit recently, and I like it more than Haskell.
21:28:08 <Cale> newsham: right, so you have to think about them
21:28:09 <petekaz> but why can I use them outside of a do block?
21:28:14 <alar> Cale: IMHO it can be reworked into haskell-like syntax
21:28:22 <newsham> not really..  maybe when debuggign occasionally
21:28:25 <Cale> petekaz: do-blocks are just syntax sugar for ordinary functions
21:28:40 <Cale> newsham: well, you *should* :)
21:29:00 <newsham> *sigh*  i give up...
21:29:07 <petekaz> right ... and <- is really =>> right?
21:29:11 <Cale> do x; stmts = x >> do stmts
21:29:14 <newsham> i get the impression you dont have much experience with dynamic typed languages
21:29:20 <Cale> do v <- x; stmts = x >>= (\v -> do stmts)
21:29:44 <palomer> I far prefer dynamically typed languages for scripts
21:29:44 <newsham> (strong typing rocks, but it has disadvantages)
21:29:54 <newsham> palo: exactly.
21:30:03 <petekaz> I guess my confusion is that the RHS of the <- hand to be some action.
21:30:18 <Cale> newsham: I've written code in common lisp, python, ruby, perl 5, basic, scheme...
21:30:32 <newsham> pete: rhs has to be some monad wrapping a value.
21:30:38 <newsham> in IO its an action
21:30:40 <petekaz> And I thought actions could not be used outside of do blocks or >>=, yet I can use a list anywhere.
21:30:43 <newsham> but its not always an action
21:30:49 <Cale> I just find I'm a lot more comfortable when the compiler is verifying things so I don't have to.
21:30:59 <petekaz> @type [ 1 .. 10 ]
21:31:21 <Cale> @oldwiki MonadsAsContainers
21:31:28 <Cale> @botsnack
21:31:32 <alar> @vixen wake up!
21:31:32 <newsham> different monads have different behaviors.  do { } works w/ them all
21:31:34 <Cale> hmm
21:32:01 <Cale> petekaz: http://www.haskell.org/hawiki/MonadsAsContainers
21:32:21 <Cale> That should sort it all out and point you at further references :)
21:32:26 <petekaz> ok, but if a list is a monad, I didn't think I could use it outside of do or without >>=.  But I can use a list anywhere from what I've seen.
21:32:31 <petekaz> ok.
21:32:32 <petekaz> Thanks.
21:32:44 <Cale> monads are nothing special
21:32:53 <Cale> they're just types which support a certain interface
21:33:02 <Cale> xs >>= f = concat (map f xs)
21:33:06 <Cale> return x = [x]
21:33:18 <Cale> those are the list monad operations
21:33:58 <Cale> so there's no real magic going on there
21:34:23 <petekaz> I better read the docs.  I thought I finally understood do ond >> and >>=, but I guess not.
21:34:27 <Cale> It's just translating the do-notation into a bunch of (>>=) functions, which are just concatMaps
21:34:38 <Cale> (because it's the list monad)
21:34:57 <Cale> Read my little article, should give another perspective
21:35:50 <petekaz> thanks.
21:36:50 * alar falls asleep
21:36:55 <alar> see you later
21:37:11 <Cale> I think the action/computation view is a bit confusing to beginners. It's the way that you tend to view a lot of the more useful monads, but it's trickier than the container view to really understand at first.
21:43:12 <petekaz> Cale: thanks for the link, I'm falling asleep, need to get some rest so I can comprehend it :-)
21:43:40 <Cale> petekaz: see you around then -- let me know if you have any other questions, comments or criticisms :)
21:48:16 <sethk> Cale, I can use some help modifying my code to use StateT.  I'm not quite ready yet.  I decided to do it in two steps.  First, I'm collapsing all of my arguments in to a record type, replacing many arguments with a single argument.  Once that's working, I thought it would be better to approach the issue of how to use the monad without trying to modify the data format at the same time.
21:49:16 <Cale> sethk: yeah -- you'll probably want to define extractors/setters in the monad for convenience
21:49:29 <Cale> (if your state is a record type)
21:49:41 <sethk> Cale, ok.  I'm refactoring, should be done shortly.  And, yes, my state is a record type.
22:03:13 <sethk> Cale, when you say define extractors/setters "in the monad", I'm not sure what you mean.  For example, I have one field name dataSync, which I extract with (dataSync state).  Did you mean define a function as (dataSync state)?  Or did you mean something like state -> StateT MVar (Chan CScommand)?  (the type of dataSync is MVar (Chan CScommand)
22:09:39 <Cale> sethk: well, getters and setters for the components of your record
22:09:45 <Cale> whatever that record is
22:09:55 <sethk> Cale, ok.
22:19:22 <jip> hey guys! i've started a devlog for my gameboy emulator project!
22:19:29 <jip> http://www.mutantlemon.com/omegagb/devlog/
22:19:48 <sethk> jip, sounds like fun
22:24:07 <jip> spread this link around =]
22:37:38 <sethk> cale, still around?  I'm ready
22:38:10 <Cale> 5 minutes
22:38:21 <sethk> Cale, k, thanks as usual
22:42:00 <lispy> haha, dons would appreciate this...i just tried to zip a file and i get this:
22:42:10 <lispy> zip :: [a] -> [b] -> [(a,b)]
22:42:18 <lispy> that was part of the output about teh program usage :)
22:42:30 <Cale> heh
22:42:42 <Cale> sethk: okay
22:43:18 <sethk> Cale, Almost all of my functions are in the IO monad.  I've refactored so everything that I want to be available as state is a value of a record type
22:44:00 <Cale> which program is this?
22:44:38 <sethk> this program is a command server.  It accepts inputs from various devices, bar code reader, terminal entry, and performs commands in response to the input
22:45:41 <sethk> Cale, I can paste the file but it's rather long and involved and it might just be noise.
22:45:59 <Cale> okay
22:46:11 <Cale> so it actually is IO intensive
22:46:19 <sethk> yes
22:50:28 <sethk> Cale, does that mean to you that the monad isn't right for this code?
22:51:18 <Cale> no, just checking that you can't rip things out of IO and make them pure
22:51:37 <sethk> Cale, I have where possible, but it is a small fraction of the code
22:52:54 <Cale> okay, so you'll likely be working in StateT YourRecordType IO
22:53:11 <sethk> ok
22:54:20 <Cale> the only real things to know about it is that evalStateT a s will apply the action a to initial state s, and produce an IO computation
22:54:41 <Cale> and that you use get and put respectively
22:54:41 <Cale> to get and set the record
22:54:58 <Cale> modify might also be handy
22:55:01 <sethk> Cale, right.  Is that true even inside an IO monad function?
22:55:05 <Cale> @type Control.Monad.State.get
22:55:37 <Cale> these are only available in your state transformed IO
22:55:51 <Cale> also, to get IO to occur, you have to apply lift
22:56:14 <Cale> lift takes IO actions and turns them into StateT YourRecordType IO actions
22:56:18 <sethk> Cale, ok, so I use lift on every IO function, and use get
22:56:55 <sethk> Cale, where do I apply evalStateT?
22:57:07 <sethk> and what is a, and what is s?
22:57:12 <sethk> s is my state type?
22:57:22 <Cale> at the very top level
22:57:27 <Cale> a is the action
22:57:27 <Cale> s is the initial state
22:57:40 <Cale> or are you referring to another a and s?
22:57:44 <sethk> no, that one
22:58:13 <sethk> initial state I understand.  what is action in this context?  A function called from main that does everything?
22:58:38 <Cale> possibly
22:58:50 <sethk> I take my current function, move most of it to a new function, then apply evalStateT with an initial state and the function name?
22:58:59 <Cale> the whole computation done in the state transformed monad, from where you start needing the extra state to when you finish
22:59:26 <Cale> you only apply evalStateT to get an IO action
23:00:09 <sethk> Cale, then how does it know I'm in the State monad?  Does the type checker figure that out because we apply get?  Or from the application of evalStateT?
23:00:39 <newsham> each do statement is 1 type of monad, right?
23:00:53 <newsham> (ie all statements in it of the same monad type)
23:00:55 <Cale> both
23:01:00 <Cale> newsham: right
23:01:09 <Cale> yes
23:01:26 <sethk> Cale, ok, but now I'm confused.  You said we use lift for all the IO functions.  Now you said we use evalStateT for IO functions.  What am I missing?
23:01:50 <Cale> if you apply evalStateT, the state won't get carried to other invocations of evalStateT
23:02:03 <Cale> evalStateT goes from your big monad down to IO
23:02:13 <Cale> lift goes from IO to your monad
23:03:32 <Cale> @type Control.Monad.Trans.lift
23:03:37 <Cale> @type Control.Monad.State.evalStateT
23:03:45 <mbot> forall (t :: (* -> *) -> * -> *)
23:03:45 <mbot> [4 @more lines]
23:03:45 <mbot> forall a (m :: * -> *) s.
23:03:45 <mbot>             (Monad m) =>
23:03:45 <mbot>             Control.Monad.State.StateT s m a -> s -> m a
23:03:59 <Cale> ugh
23:04:03 <Cale> @type Control.Monad.Trans.lift
23:04:15 <mbot> forall (t :: (* -> *) -> * -> *)
23:04:15 <mbot> [4 @more lines]
23:04:29 <Cale> @more
23:04:34 <Cale> @more
23:04:34 <Cale> @more
23:04:39 <mbot>             a
23:04:39 <mbot> [3 @more lines]
23:04:39 <Cale> @more
23:04:44 <mbot>             (m :: * -> *).
23:04:44 <mbot>           (Control.Monad.Trans.MonadTrans t, Monad m) =>
23:04:44 <mbot>           m a -> t m a
23:04:58 <Cale> okay
23:05:22 <Cale> (I hate the type pretty printer sometimes :)
23:05:22 <sethk> Cale, so if a function has a return type of IO Foo, I use lift to apply StateT functions, and if the function has a return type of IO StateT, I use evalStateT to apply IO functions?
23:06:00 <Cale> lift turns IO things into StateT s IO things
23:06:20 <Cale> evalStateT is for actually running your computation going from StateT s IO back to IO
23:06:54 <sethk> Cale, that's where I'm confused.  How do I know whether I'm in StateT and have to apply evalStateT, or I'm in IO and have to apply lift?
23:06:58 <Cale> you don't want to apply evalStateT too early
23:07:14 <Cale> you'll probably have only one evalStateT (or runStateT if you care about the final state) in your whole program
23:07:22 <sethk> Cale, wait, though.  The state does not have a value until I apply evalStateT
23:07:31 <sethk> Cale, so how can I delay applying it?
23:08:23 <Cale> sethk: the state is abstracted away
23:08:36 <Cale> you access it via get and put
23:08:54 <Cale> try this:
23:09:13 <sethk> Cale, evalStateT has to be invoked before I can use get and put, correct?
23:09:32 <sethk> because the initial state is in the application of evalStateT
23:09:36 <sethk> ?
23:09:41 <Cale> evalState (do x <- get; put (x+1); get) 5
23:09:59 <Cale> yeah
23:09:59 <Cale> well, sort of
23:10:11 <Cale> you apply evalStateT to a StateT computation to get an IO computation
23:10:16 <sethk> 5 is your initial state in that example
23:10:40 <Cale> inside a StateT computation, you can assume that there's a state at any given point which has some value which isn't yet determined
23:10:46 <Cale> yeah
23:11:19 <sethk> I get inside a StateT computation by applying evalStateT to that computation and an initial state?
23:12:15 <Cale> eventually
23:12:23 <Cale> yeah
23:13:29 <sethk> I'm confused about why you say eventually.  The first thing I do in this program is set up the state.  Everything else needs the state.  So I have to do evalStateT as soon as I have a state value
23:14:15 <Cale> yeah
23:14:30 <Cale> (it's just confusion over the meaning of 'first')
23:14:52 <Cale> You might define a bunch of actions in the transformed monad, and then later use them with evalState :)
23:15:43 <sethk> Cale, if I use forkIO within the StateT monad, do the threads run in StateT?
23:16:45 <Cale> no, you'd have to handle that yourself to some extent
23:16:57 <Cale> you could construct a new forkIO for that
23:18:23 <sethk> Cale, ok, I'll need to do that.
23:20:11 <Cale> It's a little odd, since you can copy the current state, but after that point, the two states won't be shared
23:20:50 <sethk> hmm, that might be a problem.  There are MVars and Chans used between threads that are part of the state
23:21:56 <Cale> forkSIO :: StateT s IO () -> StateT s IO ThreadId;  forkSIO x = do s <- get; lift (forkIO (evalStateT x s))
23:22:01 <sethk> ok, so I have a function I've invoked with evalStateT, and it is barfing on the first print statemtn.
23:22:03 <Cale> well, those will be shared
23:22:17 <Cale> MVars will point to the same thing
23:22:45 <sethk> Cale, so if I do a takeMVar and putMVar and change the contents, the other threads will see the change, without using your special forkSIO?
23:23:08 <Cale> sure
23:23:23 <Cale> there's no way to prevent that even
23:23:52 <sethk> Cale, ok, that makes sense, since that's basically what MVars are for
23:25:15 <Cale> If you're just updating the value that an MVar points to, it doesn't really even have to be part of your state... it's more if you intend to replace which MVar you're using that you'd put one there
23:25:52 <sethk> Cale, it's part of my state because of the  way I designed the program.
23:26:14 <sethk> Cale, otherwise I have to use it as a function argument on 1000 functions
23:27:00 <Cale> okay, but you should be aware that you could get away with just using reader if you don't actually modify it
23:27:13 <Cale> (you just modify the thing it points to)
23:27:38 <sethk> Cale, ok.  that's the case thus far.  Why would using Reader be better?
23:28:39 <Cale> because you'd be assured that nothing swaps out the MVar for another one at some point
23:29:08 <Cale> or at least, if that happens, it only happens locally
23:29:09 <pierre-> !ruby
23:29:18 <Cale> (and the other one is put back after)
23:29:29 <pierre-> sorry, not that chanell
23:29:31 <sethk> Cale, I don't follow that.  
23:29:40 <sethk> Cale, oh
23:29:54 <sethk> Cale, it prevents me from carelessly changing it
23:30:13 <sethk> the code is the same?  except for the name of the eval function?
23:30:39 <Cale> basically
23:30:46 <Cale> you use ask instead of get
23:31:00 <sethk> ok, but the only change is function names.
23:31:15 <Cale> right
23:31:34 <Cale> and the fact that you can't change the MVars from the ones which you picked initially
23:32:07 <sethk> right, but we are saying that we will use Reader precisely because I can't change it, so that part is understood.
23:32:26 <Cale> right
23:32:37 <Cale> just trying to make sure that's clear :)
23:33:07 <sethk> I have it compiling, except for the evalStateT invocation.
23:33:14 <sethk> here is the line:
23:33:30 <sethk> evalStateT (doYourMonadicThing nstations handle) state
23:33:39 <sethk> state is a value of my record type
23:33:56 <sethk> but I get a couldn't match StateT s IO a against IO ()
23:34:10 <sethk> the call is in main, which has type IO ()
23:34:29 <sethk> do I need to use an explicit return () at the end?
23:34:51 <sethk> no, that's dumb.  :)
23:35:32 <Cale> hmm
23:35:57 <Cale> maybe you're using an IO action in the doYourMonadicThing part?
23:36:02 <Cale> (without lifting)
23:36:39 <sethk> possible.  let me look.  I wouldn't get compilation errors on those lines?  I guess not, because they could be correct.
23:37:13 <sethk> I use lift, not liftIO?
23:37:46 <Cale> liftIO would work too
23:38:08 <Cale> it's more useful when you have a large stack of monad transformers over IO and you want to go right to the bottom
23:38:30 <Cale> (lift IO all the way up to the full monad, rather than up one level at a time)
23:41:06 <sethk> hmm, the compiler seems to like liftIO more.  :)
23:41:15 <sethk> so that means I'm lifting more than one level?
23:42:13 <sethk> can you use $ more than once on the same line?  as in liftIO $ putStrLn $ "abc" ++ "def"  ?
23:43:27 <sethk> the compiler doesn't object to more than one $
23:43:40 <Cale> right
23:45:46 <Cale> though you could use (.) too
23:49:34 <sethk> I've still got the couldn't match error.  If I want to use an explicit signature   foo :: Int -> IO ()       what do I use now instead of IO ()?
23:50:56 <newsham> sethk: what do you write?
23:51:13 <sethk> newsham, I'm not sure I understand the question
23:51:27 <newsham> you are developing commercial software, no?
23:51:52 <sethk> oh, yes.  This is software used in a factory to test and configure machines as they come off the line
23:52:08 <newsham> neat
23:52:54 <lispy> sethk: cool
23:53:25 <Cale> newsham: you apply it to the int, then lift
23:53:49 <newsham> cale: no heavy lifting for me.  maybe seth?
23:54:11 <Cale> er, yeah
