00:00:20 <dons> haven't done any hacking on it. but have thought about it.
00:01:20 <dons> if someone really wants it, they need to step up and hack. or otherwise it waits till I switch to oggs and i'm forced to do it :}
00:01:23 <ValarQ> i have actually been thinking about it
00:02:16 <ValarQ> using the same curses interface for a mpd interface would be pretty neat
00:02:24 <dons> I think when I last looked ogg123 didn't support 'remote control' mode which makes it harder
00:02:30 <dons> yeah, mpd would be the best thing
00:02:59 <Korollary> mplayer should
00:03:13 <dons> it does, yes.
00:03:13 <dons> i've thought about that.
00:03:46 <dons> it's just hard for me to see myself getting time to work on it -- it was strictly a side project
00:04:06 <dons> but i'm always open to patches...
00:06:35 <Korollary> so hmp3 is the only mp3 player with a console ui in the world?
00:06:53 <dons> apparently :)
00:06:55 <dons> the ui is very nice though
00:07:08 <dons> and i wrote it because all the others I tried segfaulted
00:09:56 <Korollary> why did you pick mpg123 over mplayer?
00:10:53 <dons> i was using mpg321 at the time. it was simple to get something running . in hind sight it was short sighted :}
00:10:54 <Dazhbog> how about mp3blaster?
00:11:01 <dons> i should have gone for mpd or mplayer
00:12:57 <Korollary> mplayer already has a gui, which may make it a better choice.
00:13:04 <Korollary> I dont know what mpd is
00:14:38 <Korollary> mpd seems nice, too.
00:15:50 <dons> it's all about the functionality. I should have written hmp3 as a client to the most generic media player out there, rather than a mp3-only one.
00:15:51 <dons> oh well
00:15:53 <dons> it wouldn't be hard to change. a day or two
00:16:50 <Korollary> did you try http://hem.bredband.net/kaw/ncmpc/ ?
00:17:47 <dons> nope. I looked at the 4 or 5 that were available in the OpenBSDd ports system . no literature review ;)
00:17:48 <ValarQ> thats the one i'm using
00:18:42 <dons> yeah, binding to mpd would be fairly easy .it's set up to write bindings to
00:19:37 <neologism> pokud nechapes co je na tom funny tak jsi divny chlap
00:20:03 <neologism> sorry
00:20:48 <dons> ?elite pokud nechapes co je na tom funny tak jsi divny chlap
00:20:48 <lambdabot> p0KUD NEChapE$ (O jE nA 70M FUNnY tak JSI DI\/nY C|-|L4P
00:20:48 <dons> ah, now I get it
00:21:54 <Korollary> > reverse "pokud nechapes co je na tom funny tak jsi divny chlap"
00:21:54 <lambdabot> Terminated
00:21:54 <Korollary> >reverse "pokud nechapes co je na tom funny tak jsi divny chlap"
00:21:54 <dons> Terminated?
00:21:54 <dons> hmm
00:21:54 <Korollary> I broke the bot.
00:21:56 <dons> ah I know
00:21:58 <ValarQ> heh
00:22:00 <dons> nope. twas me.
00:22:02 <Korollary> That must be a magical phrase.
00:22:06 <neologism> ;)
00:22:17 <dons> it's a safe phrase. makes the bot fall asleep
00:23:00 <dons> ?version
00:23:07 <dons> i made some big changes today
00:23:17 <lambdabot> lambdabot 3p388, GHC 6.4.1 (Linux i686 3.20GHz)
00:23:41 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
00:23:41 <dons> and the darcs pull broke, lving things in a funny state
00:23:47 <dons> > reverse "pokud nechapes co je na tom funny tak jsi divny chlap"
00:23:48 <lambdabot> "palhc ynvid isj kat ynnuf mot an ej oc sepahcen dukop"
00:24:09 <dons> oh. hang on. helps if i fork lambdabot first..
00:25:24 <dons> ?vixen there you are!
00:25:24 <lambdabot> i like your screen name... what does it mean?
00:55:23 <Lemmih> arh, type-checking hurts my head )-:
01:11:09 <ADEpt> morning!
01:11:54 <olliej> evening!
01:11:54 <olliej> :)
01:12:19 <ADEpt> a question to ghc wizards: ghc optimizes (let x='a' in if x == x then "good" else "odd") to "good". Does eta conversion has something to do here? 
01:16:52 <Lemmih> There are rewrite rules for 'forall x. x == x = True'.
01:18:35 <Cale> Lemmih: hmm, really?
01:18:45 <Cale> > (1/0) == (1/0)
01:18:46 <lambdabot> True
01:18:51 <Cale> > (0/0) == (0/0)
01:18:52 <lambdabot> False
01:19:04 <Lemmih> Cale: Well, for unboxed values.
01:19:24 <Cale> ah
01:19:40 <Lemmih> Or so I though. Can't seem to find them.
01:20:43 <Lemmih> GHC.Base.lhs:886: "x# ==# x#" forall x#. x# ==# x# = True
01:22:27 <ADEpt> Lemmih: ah. i grepped for a wrong regexp that did not catch '==#'
01:25:23 <sethk> dons, 9 deployed applications and still counting
01:29:28 <ADEpt> Lemmih: thnx
01:29:56 <Lemmih> ADEpt: No problem.
01:36:52 <rasfar> @where haskell'
01:36:52 <lambdabot> http://hackage.haskell.org/trac/haskell-prime
01:37:13 <kuvkir> ADEpt: hi
01:37:42 <kuvkir> ADEpt: thans for the writing "Hitchiker's guide to Haskell". It's interesting reading :)
01:38:31 * shapr boings
01:40:08 <ADEpt> kuvkir: thanks for reading. I hope to find time to add a new section soon.
01:45:14 <jar_of_clay> hi all
01:45:23 <sieni> found a bug in "Hitchiker's guide to Haskell"
01:45:32 <jar_of_clay> ok, i have little question:
01:45:41 <jar_of_clay> f = putStr "Hello"     is this valid?
01:46:12 <sieni> ADEpt: theres a " missing in the Hello!/Bye! example
01:46:40 <sieni> ADEpt: in putStrLn "Bye!)
01:46:43 <sethk> jar_of_clay, no, probably not
01:46:53 <jar_of_clay> ok i figured out
01:47:09 <sethk> jar_of_clay, I didn't know I was such a talented explainer  :)
01:47:12 <jar_of_clay> in GHC you have to use say let f = putStr "Hello World"
01:47:34 <ADEpt> sieni: thnx, will fix
01:47:37 <jar_of_clay> :)
01:48:04 <sethk> jar_of_clay, in Haskell, not specifically in ghc
01:48:25 <sethk> jar_of_clay, also, isn't putStr an IO (), which means it doesn't return anything?
01:48:41 <jar_of_clay> i'm starting to understand a little already
01:49:00 <jar_of_clay> putStr has side effects and therefore cannot be a function
01:49:01 <sieni> jar_of_clay: well, it should work in a source file
01:49:07 <jar_of_clay> yes?
01:49:09 <sethk> jar_of_clay, if it returned something, you either use it within let or where, as you noted, or you can also use <-
01:49:11 <sieni> jar_of_clay: as in:
01:49:15 <sieni> module Main where
01:49:16 <sieni> f = putStr "Hello"
01:49:16 <sieni> main = do f
01:49:23 <sethk> jar_of_clay, more correctly you use it within a monad
01:49:25 <jar_of_clay> ic
01:49:58 <sieni> but if you use ghci, you need to use let to bind f
01:50:14 <sethk> jar_of_clay, it is an IO () function, and the monad keeps the side effects from escaping to other parts of a program
01:50:21 <jar_of_clay> what am I binding f to then?
01:50:37 <dons> sethk, wow. is it getting easier? you using Haskell for more things?
01:50:46 <uchchwhash> how is the class IO abstract?
01:50:49 <sethk> dons, yes
01:51:08 <uchchwhash> I mean, can I declare instance Something IO where .. ?
01:51:17 <sethk> dons, it's all haskell now, except for one small program.  Of course there is also c/c++ code using ffi
01:51:25 <dons> yep. sure. 
01:51:32 <sethk> dons, but the bulk is haskell code now
01:51:38 <dons> ?karma+ sethk
01:51:39 <lambdabot> sethk's karma raised to 3.
01:51:50 <dons> great stuff.
01:51:59 <sethk> dons, by the way I got permission to talk about it as long as I don't reveal the core algorithms.
01:52:55 <dons> oh, excellent. yeah, if you ever want to talk about using Haskell in a commerical environment. what it's strengths and weaknesses are, I'm sure many would be interested.
01:53:46 <sethk> dons, the first phase should be fully deployed within three or four weeks, then I'll have a bit more time to see if I can write something interesting
01:54:35 <jar_of_clay> Sorry if I'm interrupting, but I've got another question: Int is an instance of the type class Num, is this the same as saying Int inherits from Num (as in OO programming)?
01:54:39 <sethk> dons, on Thursday I wrote and deployed both sides of a somewhat complex client/server application in about four hours.
01:54:55 <sethk> jar_of_clay, how can you interrupt in a help channel?  No such thing.
01:55:31 <sethk> jar_of_clay, not the same, but there are similarities
01:55:31 <dons> sethk, 4 hours :) cool, haskell doing its thing 
01:55:31 <jar_of_clay> well I can't contribute, only ask and ask and ask...
01:55:38 <Cale> jar_of_clay: well, Num isn't a type
01:55:38 <sethk> jar_of_clay, you might say that the haskell class is similar to pure virtual functions in a c++ base class
01:55:55 <sethk> jar_of_clay, in that it specifies interface methods
01:55:58 <Cale> (which is one major difference here)
01:56:09 <sethk> jar_of_clay, ask away, that's the whole point of a channel like this
01:56:24 <jar_of_clay> ok, thanks
01:56:27 <sethk> jar_of_clay, we have #haskell-blah if we want to hear ourselves talk  :)
01:56:56 <Cale> another thing (which isn't too relevant here) is that typeclasses can have multiple type parameters, which can express relationships that class inheritance can't
01:57:03 <dons> it means that Int is a member of the class Num. which means that the methods of Num work in Int values. ad-hoc polymorphism
01:57:21 <Cale> (OO class inheritance)
01:57:39 <Cale> bounded parametric polymorphism
01:57:48 <Cale> I kind of hate calling it ad-hoc
01:57:52 <dons> yeah  ok :)
01:57:58 <dons> bounded parametric sounds much nicer
01:58:41 <jar_of_clay> i'm getting the impression that comparing type classes with OO inheritance does not work too well
01:58:41 <sethk> I want to use deriving with classes I create
01:59:17 <Cale> jar_of_clay: you'd be right
01:59:18 <sethk> jar_of_clay, there are similarities, but the are not the same
01:59:18 <Cale> jar_of_clay: there are some limited similarities
01:59:18 <Cale> yeah
01:59:21 <dons> classes in Haskell are about writing generic functions that work for a set of types
01:59:52 <dons> rather than fully polymorphic functions that work for all types
02:00:19 <jar_of_clay> ic
02:00:21 <sethk> the c++ class mechanism is  horribly overloaded
02:00:43 <dons> its just the word 'class' that throws people. it's horribly overloaded
02:00:56 <sethk> dons, yes, that's true
02:01:26 <dons> jar_of_clay, consider:
02:01:32 <dons> ?type id
02:01:33 <lambdabot> forall a. a -> a
02:01:36 <sethk> dons, also, though, c++ uses class for three distinct types of things
02:01:46 <dons> this functoin takes any type 'a' and returns something of that type.
02:01:57 <dons> it's polymorph, as it works for all types
02:02:33 <sethk> even Java is a bit better.  The Java interface has things in common with the haskell class, although as cale said the haskell class can express things that the Java interface (or similar OO things in other languages) can't express
02:02:54 <dons> > id True
02:02:55 <lambdabot> True
02:02:58 <dons> > id "foo"
02:02:59 <lambdabot> "foo"
02:03:18 <dons> id works on any data type. so if you write a polymorphic function, it works no matter what type you give it
02:03:24 <dons> now, some functions work for only a set of types
02:04:05 <dons> ?type sqrt
02:04:05 <lambdabot> forall a. (Floating a) => a -> a
02:04:05 <jar_of_clay> sethk: I was under the impression that c++ was more like Haskell because you can pass predicates to functions (like in std::sort )
02:06:21 <dons> sqrt is meaningful only over a subset of types. those that are members of the Floating class
02:06:39 <dons> ah, sort. that's a higher-order function. a function that takes another function as an argument
02:06:57 <dons> both C++ and Haskell can deal with higher-order functions
02:07:18 <dons> ?type sort
02:07:18 <lambdabot> Not in scope: `sort'
02:07:23 <dons> ?type List.sort
02:07:24 <lambdabot> forall a. (Ord a) => [a] -> [a]
02:07:40 <dons> works on lists of types, but only those that have some sort of ordering
02:08:03 <jar_of_clay> ok
02:09:53 <dons> ?type List.sortBy
02:09:53 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
02:09:54 <dons> is the higher-order function
02:09:54 <sethk> jar_of_clay, you pass function pointers, reallly.  I wasn't saying java is (or isn't) closer to haskell.  I said the java interface is closer to the haskell class than the c++ class is to the haskell class
02:09:54 <dons> it takse a function that compares to members of the list, and a list
02:09:57 <dons> yeh its much more like a Java interface
02:09:57 <jar_of_clay> sethk: is that because all Java objects inherit from Object and can therefore all be treated polymorphically?
02:09:57 <jar_of_clay> sorry
02:09:57 <jar_of_clay> you said java interface
02:10:48 <jar_of_clay> do any of you come from an OO background before learning about functional programming?
02:11:16 <Saulzar> Quite a few, I'd say
02:12:32 <sethk> jar_of_clay, I've coded in c and c++ for about 25 years.
02:12:53 <jar_of_clay> I wonder if there is something crucial, some basic point or exercise that opens your mind to the functional way of thinking
02:13:12 <sethk> jar_of_clay, no, just keep writing code until it clicks for you.
02:13:12 <sethk> jar_of_clay, and don't give up, because it takes a while
02:13:12 <jar_of_clay> wow, well i've been programming C++ professionaly for a year
02:13:21 <jar_of_clay> ok
02:14:06 <dons> your programming in a much more general language. it's more powerful, has more big concepts, and things can be glued together in more ways. so it takes time
02:16:26 <jar_of_clay> i'm working though "Yet another Haskell tutorial", for me things start to become complicated in chapter 4.5 about Data Types
02:17:14 <jar_of_clay> data Pair = Pair a b
02:17:39 <jar_of_clay> Pair is a type, but also a constructor
02:17:46 <dons> data Pair a b = P a b
02:17:55 <dons> they're in different namespaces.
02:18:00 <dons> this is confusing for beginners
02:18:11 <jar_of_clay> it is :)
02:18:21 <dons> the Pair onn the lhs is a type. so it can appear in type signatures
02:18:24 <sethk> jar_of_clay, I frequently say that the same name should not be used in that situation 
02:18:53 <sethk> jar_of_clay, should not be used in a tutorial, certainly
02:18:53 <dons> the Pair on the right is a constructor , a function on the value levell
02:18:53 <dons> yeah, not in a tutorial
02:18:53 <sethk> jar_of_clay, because it is natural to think that the same word means the same thing
02:18:58 <dons> it's good in practice though. data () = ()
02:19:09 <dons> you know that a Pair a b :: Pair a b 
02:19:13 <sethk> jar_of_clay, but you can call the right hand one (or the left hand one) by an name at all.
02:19:20 <dons> :: means 'has type' btw, 
02:19:37 <sethk> dons, yes, I do that myself, although I usually do data Pair' ... - Pair ...
02:19:47 <dons> and 'data' is just the way to define a 'struct'
02:19:51 <sethk> but that gives up the '
02:20:06 <sethk> dons, more like a union of structs
02:20:58 <dons> yeah, its more general (this is Haskell, after all)
02:20:58 <jar_of_clay> data Pair a b = P a b  here Pair is a type and P is a function, correct?
02:20:58 <dons> yep
02:20:58 <dons> so: P 8 'x'
02:20:58 <dons> is a value :: Pair Int Char
02:21:01 <jar_of_clay> does this mean type are the same as functions?
02:21:13 <dons> no no.
02:21:27 <dons> types are types. they are a way to classify values statically
02:22:16 <dons> so the type 'Bool' has values of True and False
02:22:17 <jar_of_clay> that's what i thought
02:22:38 <dons> the Bool type can be used statically to approximate what possible values an expression might have
02:23:09 <jar_of_clay> ok, i get that, same as in C++
02:23:24 <dons> yep. types are types, and types describe values. it's the same since time began
02:24:04 <jar_of_clay> but in the statement: data Pair a b = P a b   it looks like you assign a function to a type
02:24:23 <dons> no, = isn't an assignment
02:25:45 <ski> that notation is meant to look a bit like BNF syntax, i think
02:25:45 <jar_of_clay> associate a type with a function?
02:25:45 <dons> it's just syntax to say: I want a new data structure consisting of two values of type 'a' and 'b'. this new structure will have type 'Pair' and I can introducce such aa structure with the constructor P
02:25:45 <ski> think of the right-hand-side as a template, with an actual name for the constructor, and types in place of arguments that should have that type
02:25:46 <dons> so you get a lot of bang for your buck with that syntax
02:25:53 <jar_of_clay> so the function P returns a new instance of Pair?
02:26:06 <ski> data Foo a = F Int [a] String
02:26:16 <dons> a new value of type Pair
02:26:44 <dons> (shouldn't use words like 'instance -- too overloaded ;)
02:27:00 <ski> the 'F' constructor takes an integer, a list of 'a's and a string, wraps them up, returning a value of type 'Foo a'
02:27:04 <jar_of_clay> yeah ski, in my head in tend to replace 'a' with T to make it seem a little more familiar
02:27:20 <jar_of_clay> ok, value then :)
02:27:26 <ski> so, if
02:27:31 <ski> i :: Int
02:27:55 <ski> bs :: [Bool]
02:27:55 <ski> s :: String
02:27:55 <ski> then
02:27:55 <ski> F i bs s :: Foo Bool
02:28:00 <ski> ('::' means "has type")
02:28:51 <ski> jar_of_clay : do you understand
02:28:52 <ski> ?
02:29:09 <jar_of_clay> let me see
02:29:55 <sethk> jar_of_clay, for example, the client/server thing I was talking about.  I have a data type for request and response.  In c++ I would have a base class with a pure virtual function to handle requests and responses.  But in OO, the handle function must have the same arguments.  Haskell removes that requirement, which is incredibly liberating once you learn to use it.
02:29:56 <jar_of_clay> F i be s is of type bool, but how can you deduce that from i :: Int, bs :: [Bool] and s :: String ?
02:30:28 <ski> (jar_of_clay : it is of type 'Foo Bool', not 'Bool')
02:30:33 <ski> data Foo a = F Int [a] String
02:30:52 <jar_of_clay> ok
02:30:53 <ski> the 'F Int [a] String' part can be read as a template
02:31:06 <ski> first thing is always the name of the constructor
02:31:19 <jar_of_clay> ok
02:31:57 <ski> any additional things are the types that actual arguments at their places should have
02:31:58 <jar_of_clay> sorry, i have to leave now. but i find this VERY interesting; i'll be back soon
02:32:02 <ski> m
02:38:31 <iturk> hi there 
02:38:43 <iturk> i am just trying to create a simple file 
02:38:59 <iturk> i have just defined a function called square
02:39:12 <iturk> then i called using square 5 inside the file
02:39:31 <iturk> and i get > parse error (possibly incorrect indentation)
02:39:47 <iturk> have a miss something ?
02:40:10 <iturk> square :: Int -> Int
02:40:14 <iturk> square x = x * x
02:40:18 <iturk> square 5
02:40:24 <ski> you can't just call things on toplevel, in a file
02:40:36 <ski> you can only call inside definitions
02:40:47 <iturk> so i must make a definition
02:41:03 <ski> either just pass the file to ghci or hugs, and enter 'square 5' into that
02:41:06 <iturk> i was thinking that this was like python style
02:41:09 <ski> or, define e.g.
02:41:16 <ski> main = print (square 5)
02:41:24 <iturk> i have a hugs shell oepn
02:41:28 <ski> ok
02:41:39 <ski> then you can try out functions there
02:41:44 <iturk> but in my shell how can i run the program there
02:42:15 <iturk> i have tested functions like lenght "word"
02:42:31 <iturk> but if i want to pass a program to the shell how can i do it
02:42:33 <ski> you can use e.g. runhugs
02:42:51 <ski> 'pass a program to the shell' means ?
02:43:46 <iturk> can i do it like in swi-prolog
02:44:25 <iturk> like file->consult
02:44:25 <iturk> then i can call the functions that i want
02:44:25 <ski> Prelude> :l MyFile.hs
02:44:30 <iturk> that i have define in the file that i am consulting
02:44:31 <ski> Main> square 5
02:44:32 <ski> 25
02:45:47 <iturk> thanks
02:46:19 <ski> does that do what you want ?
02:46:19 <ski> ':l' is short for ':load'
02:46:19 <iturk> i see
02:46:19 <ski> ':r' for ':reload' is also useful
02:46:19 <ski> see ':?
02:46:28 <iturk> now i just adding runhugs to the class path
02:46:30 <ski> see ':?' for a list of these commands
02:46:42 <iturk> in order to run it from the place where the file is
02:47:02 <ski> are you on windows ?
02:47:06 <iturk> yes
02:47:18 <iturk> i am using eclipse
02:47:22 <ski> ok
02:47:41 <iturk> but i think that in linux its better for console typing stuff
02:47:54 <ski> (there is a graphical WInHugs, that you could try out too, if you haven't already)
02:48:52 <ski> in unices, you could add a line '#!/path/to/runhugs' at top of file, and make file executable, to be able to run it from shell
02:50:43 <iturk> i have run now ghci from the console in the directory of the file
02:50:52 <iturk> the hs file i mean
02:52:41 <iturk> shi: my ghci doesnt like :1
02:52:50 <iturk> instead i have used :load and works
02:53:23 <ski> not ':1', ':l'
02:53:23 <iturk> oo ok
02:53:24 <ski> "colon, lower-case ell"
02:53:29 <iturk> yes
02:53:53 <iturk> its very difficult to see the difference it this charset
02:54:14 <iturk> so now i can run square 5 
02:54:21 <iturk> and of course i get 25
02:55:00 <ski> and if you define 'main', you can use 'runhugs', or compile with 'ghc' to run from the shell
03:03:18 <iturk> ski: so i have added to my file > main = print(square 5)
03:03:32 <iturk> now i trying to get the result using the compiler
03:03:54 <iturk> but i just get Compiling Main             ( D:/Misc/Cadeiras/ITU/Advance Programming/Haskell/src/Hello.hs, interpreted )
03:05:00 <iturk> there are two options of running in eclipse one is "run ghci section" other is "run hugs 98 section"
03:05:16 <iturk> what is the main difference between them ?
03:13:13 <uchchwhash> hi Haskeller
03:13:19 <uchchwhash> I mean, hi Haskellers
03:13:35 <pesco> Hrm, can anyone give me a hint as to how to get Unicode output with hscurses?
03:13:45 <uchchwhash> I want to check out lambdadot... do I do it here?
03:14:12 <pesco> Hi uchchwhash. Sure, go ahead and talk to her.
03:14:34 <pesco> @vixen Hey, meet uchchwhash, I bet he's really nice!
03:14:35 <lambdabot> really!?
03:15:00 <uchchwhash> and yes, by the way, after pesco, don't you think Haskell' should be fully Unicode compliant? there was an issue with CompositionAsDot
03:15:05 <uchchwhash> @help
03:15:06 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
03:15:11 <uchchwhash> @list
03:15:11 <lambdabot> list [module|command]. Where modules is one of:
03:15:11 <lambdabot> babel base compose dice dict djinn drHylo dummy dynamic elite fact haddock help hoogle karma lambda localtime log more pl plugs poll pretty quote search seen slap spell state system todo topic type unlambda version vixen where
03:15:37 <pesco> uchchwhash: For lengthy sessions with lambdabot, a /query would be advisable.
03:15:56 <uchchwhash> ok thanks
03:16:19 <pesco> pesco: Yes, I think that compilers should finally support Unicode input. I think the next GHC will have it.
03:16:55 <pesco> Er, s/pesco/uchchwhash/. Am I _that_ self-centered?
03:17:23 <uchchwhash> support? don't you think it should take every advantage of it? I just checked out the spec for Fortress, you can do so much more with Unicode
03:17:49 <uchchwhash> anyway, I have a newbie question, please respond if you see my point
03:18:18 <uchchwhash> suppose I have a Tree data structure
03:18:46 <uchchwhash> data Tree a = Leaf a | Node a (Tree a) (Tree a)
03:18:47 <pesco> uchchwhash: Yes, I also think that once support is given, all kinds of nice Unicode characters should be supported for the familiar ascii art.
03:19:01 <uchchwhash> pesco: I second that
03:19:44 <uchchwhash> now what I really want is a function left to pick up the left subtree of a non-leaf tree
03:19:54 <uchchwhash> but I cannot make it total, right?
03:20:10 <pesco> No.
03:20:14 <uchchwhash> left (Leaf a) = error "something"
03:20:21 <pesco> Probably.
03:20:39 <uchchwhash> left (Node _ subtree _) = subtree
03:21:24 <uchchwhash> this thing pops up so often, that I honestly think we are far better off with making the alternatives data structures themselves
03:21:43 <uchchwhash> so that Node will itself be a type
03:22:50 <uchchwhash> is there a problem with this approach? (apart from clumsy pattern matching like depth (NodeInjection (Node _ l r)) = 1 + max (depth l) (depth r)
03:23:15 <uchchwhash> I mean, did I manage to make the function total?
03:24:59 <astrolabe> I think unicode haskell is a bad idea
03:25:32 <sieni> astrolabe: well, you are kinda stuck with it
03:25:44 <astrolabe> Yeah
03:26:47 <uchchwhash> honestly, I don't think it is. but it will be a disgrace to have the greek letter lambda instead of the convenient \ :)
03:27:04 <sieni> But it's nice that you can use funny names ;-)
03:27:10 <uchchwhash> hehe
03:28:24 <astrolabe> I don't think I'll be able to read code written in chinese characters for instance, let alone write it.
03:28:55 <sieni> like data ‹bergeek = ...
03:29:46 <sieni> except that wasn't unicode :-)
03:31:16 <uchchwhash> some things will be worth having, like forall, exists, proper arrows, ... Haskell code would look so much like mathematics itself that someday the lambda calculus will itself be called backslash calculus :-|
03:36:33 <Beelsebob> uchchwhash: what's hard to type about Œª?
03:37:28 <Beelsebob> and who said anything about instead - why not as well as?
03:37:47 <pesco> Œª!
03:37:48 <pesco> Join the fun, everybody!
03:38:01 <uchchwhash> Beelsebob: of course, the as well as is what comes to mind first... I was basically trying to show that things can get fanatic!
03:38:37 <Beelsebob> fair enough
03:38:43 <Beelsebob> I personally think Haskell would look *much* better and be *much* more readable if it got a little closer to the maths it represents
03:38:58 <uchchwhash> yeah that's my point basically
03:39:33 <Beelsebob> and if you really don't want to type lambdas etc, write a utility that'll read a haskell file, and write out a pretty haskell file
03:39:51 <Beelsebob> replace \s with lambdas etc
03:39:51 <uchchwhash> yeah
03:40:03 <uchchwhash> no no! please! the backslash looks much prettier to me than the lambda
03:40:13 <Beelsebob> urch!
03:40:16 <uchchwhash> you see, lambda should be a letter, not a symbol
03:40:17 <Beelsebob> not at all
03:40:17 <uchchwhash> hehe
03:40:30 <Beelsebob> why should it be a letter?
03:41:00 <uchchwhash> with Unicode and people from Greece coding in Haskell, you might need that lambda for an identifier :rolleyes:
03:42:09 <Beelsebob> for people who like a nice syntax you might have --| being a comment - doesn't stop Haskell not doing that... You can only please so many people
03:42:10 <Beelsebob> and in general, Haskell is written as maths
03:42:22 <Beelsebob> so you might as well be able to make it look like the maths
03:43:27 <uchchwhash> point taken, my love for the backslash symbol is indeed eccentric
03:44:16 <pesco> I think it looks much too "alarm! special! escape! watch out!".
03:45:01 <Beelsebob> anyway, that's not the only place it would be nice... you could have for example:
03:45:01 <Beelsebob> f :: [Œ± √ó Œ≤] ‚Üí Œ± ‚Üí Œ≤
03:45:01 <Beelsebob> f = (Œªx y ‚Üí lookup x y)
03:45:03 <Beelsebob> which quite frankly... is shiny
03:45:27 <uchchwhash> and the -> symbol that follows it as well, I get confused because that particular symbol is heavily overloaded
03:45:40 <uchchwhash> I don't think my irc client is Unicode compliant!
03:45:45 <Beelsebob> lol
03:45:50 <Beelsebob> that's UTF-8, not unicode
03:45:58 <Beelsebob> you're using irrsi, aren't you?
03:46:00 <ibid> UTF-8 is unicode
03:46:11 <jix> ibid: UTF-8 is a way to encode unicode
03:46:13 <ibid> well, ISO 10646, for some people
03:46:14 <uchchwhash> no I just downloaded Bersirc...
03:46:37 <ibid> jix: i know
03:46:37 <Beelsebob> unicode normally refers to other encodings though
03:46:37 <Beelsebob> but meh
03:46:37 <Beelsebob> yes
03:46:39 <liyang> (ooh, shiny.)
03:46:42 <ibid> jix: in this context, though, UTF-8 is close enough to Unicode as to be indistinguishable
03:46:52 <pesco> I'd really like greek letters for type variables. And the forall symbol. That keyword gets _way_ in the way.
03:46:59 <jix> ibid: ok ;)
03:47:27 <uchchwhash> Unicode has a nice four-dot square character I think
03:47:34 <ibid> Beelsebob: Unicode generally means UTF-8 where I come from, when we're not being picky enough to notice the difference between Unicode and a Unicode Transfer Format (or whatever)
03:47:36 <uchchwhash> for ::
03:47:53 <Beelsebob> ‚†≠
03:47:58 <Beelsebob> but that's a brail pattern :D
03:48:22 <uchchwhash> wow, good to know!
03:48:23 <Beelsebob> or ‚†∂
03:48:29 <Beelsebob> (also braile)
03:49:25 <ski> iturk : i haven't used Eclipse .. i assume those two just load into interactive toplevel
03:49:43 <Beelsebob> eek!
03:49:58 <sieni> Is it so hard to spell? (It's "braille")
03:50:00 <Beelsebob> eclipse suchs poo
03:50:00 <Beelsebob> sieni: and I'm lysdexic :)
03:50:08 <iturk> ski: i get the point from the ghci section in eclipse
03:50:13 <ski> iturk : to compile, use 'ghc Hello.hs -o Hello.exe' in shell (there could well be a way of doing this in your IDE, too, but i don't know)
03:50:16 <sieni> Beelsebob: sorry ^_^
03:50:22 <iturk> it open a consule for calling the functions
03:51:11 <iturk> since i dont have install hugs 98 it doesnt work
03:51:20 <iturk> only ghci
03:51:56 <uchchwhash> I am a Windows user, things would have been very convenient for me if the Eclipse plugin was easy on the user
03:52:27 <uchchwhash> and I suppose the development kindda stuck... of eclipsefp
03:52:33 <ski> iturk : if you can't find a command to compile in Eclipse, try the command i suggested in a shell/command-line
03:52:41 <uchchwhash> is someone working on it? or is the project deprecated?
03:53:52 <iturk> ski: it compiles very well now no problem
03:54:59 <iturk> uchchwhash: i am getting now good results from the compiler plugin inside eclipse i dont see way should be deprecated
03:55:59 <uchchwhash> no I don't want it deprecated! but I have been following it for quite a while, the progress is slow
03:56:21 <uchchwhash> I suspect because not many programmers are interested in it, Haskell and Java are too far apart
03:56:33 <musasabi> dons: sent a patch making the C bits optional.
03:56:48 <uchchwhash> [you need to code in Java to build an Eclipse plugin]
03:59:12 <vincenz> Hello
04:03:52 <jix> is there a good tutorial on good haskell code layout?
04:04:44 <musasabi> Is it possible to find out whether one is in GHC or ghci inside cpp?
04:05:12 <sieni> jix: http://www.haskell.org/onlinereport/lexemes.html#lexemes-layout
04:05:23 <jix> sieni: thx
04:05:26 <sieni> jix: and http://www.haskell.org/onlinereport/syntax-iso.html#layout
04:06:48 <astrolabe> They seem to be more about how the compiler translates layout than about what is good practise.
04:08:03 <Beelsebob> jix: do what looks nice and keeps things as far left as possible in general
04:09:01 <jix> Beelsebob: some tutorials do things like:
04:09:01 <jix> f     :: Int -> Int -> Int
04:09:01 <jix> f a b = a + b
04:09:12 <jix> some don't insert the spaces/tabs after the first f...
04:09:20 <Beelsebob> that's just odd if you ask me
04:09:26 <jix> ok
04:09:29 <Beelsebob> it's not like the :: has any meaning related to the =
04:10:36 <astrolabe> It makes sense to line up the a and b with the first two ints, the = with the second -> and a+b with Int
04:10:45 <astrolabe> If you can be bothered.
04:10:53 <Beelsebob> that *would* make sense, but it would be hard to read
04:11:13 <astrolabe> I think it would be ok if it all fitted on one line
04:13:04 * Beelsebob just thought... jibble :: ‚Ñï ‚Üí a ‚Üí ‚Ñï ‚Üí ‚Ñù would be shiny
04:13:18 <Beelsebob> or alpha even rather than a
04:13:32 <astrolabe> There are a few tips here.
04:14:06 <astrolabe> Beelsebob: But it might be awkward for someone who doesn't recognise the symbols.
04:14:25 <Beelsebob> astrolabe: then they should learn some damn maths
04:14:42 <Beelsebob> it's not like they're going to understand what a type is if they don't know any set theory anyway
04:14:44 <astrolabe> Where here is http://www.haskell.org/hawiki/HaskellStyle?action=highlight&value=coding+standard
04:14:48 <jix> yeah the use of unicode in haskell would be cool
04:15:15 <jix> but i'd have to get a new keyboard ;)
04:15:28 <Beelsebob> jix: I was specifically refering to using ‚Ñù and ‚Ñï etc.
04:15:36 <astrolabe> In maths they use russian symbols and hebrew.  I'm not familiar with either.
04:15:46 <jix> Beelsebob: yeah
04:16:04 <Beelsebob> astrolabe: in what context are they used?
04:16:19 <astrolabe> But once you admit general unicode people will be able to use chinese and all sorts of stuff.
04:16:50 * jix remembers c code with korean comments and meaningless function names
04:17:03 <astrolabe> Also, those symbols you typed don't appear as maths symbols to me, which I think exemplifies some of the problems that will occur.
04:17:26 <Beelsebob> astrolabe: then get an IRC client that actually understands UTF8
04:17:44 <Beelsebob> it was the N and R with double lines for the sets
04:18:08 <astrolabe> I can't really remember.  I guess Aleph 0  (a type on infinity) is hebrew, and I remember a 'shar' character from algebraic geometry.
04:18:48 <Beelsebob> ?0◊ê
04:18:49 <lambdabot> Unknown command, try @list
04:18:54 <Beelsebob> ohhh - shiny!
04:19:07 <Beelsebob> if you type and alef in OS X it automatically changes the writing direction
04:19:26 <astrolabe> Beelsebob: I could yeah.  Everyone could.  And editors that do. But it will reduce the options, and I'm not sure that the gain is worth it.
04:19:52 <Beelsebob> the point is that if no one uses it the editors will never sort out supporting it
04:20:09 * Beelsebob goes
04:20:40 <astrolabe> Ug.  Well that stops the discussion I spose.
04:20:58 <astrolabe> But I disagree that THAT is the point.
04:29:52 <musasabi> Is there a nice way to mark deprecated modules with haddock?
04:39:45 <jix> is it bad style to depend on the order of expressions?
04:40:02 <jix> like f [] =... f x =...
04:40:21 <Lemmih> No, it's necessary.
04:40:23 <Philippa> what do you mean by "depend on"?
04:40:38 <jix> ok i can trash that tutorial
04:40:39 <Philippa> Lemmih: that's patterns, no?
04:41:06 <boy> Lemmih: hi, how is hIDE going?
04:41:40 <Lemmih> Philippa: Yeah, I think that's what he meant.
04:42:04 <jix> yes
04:42:19 <ski> jix : i'd say that when it's not difficult to not depend on the order, then it can be nicer to don't depend on it
04:42:38 <jix> ski: yeah but it would be really ugly in my case
04:43:22 <ski> then don'tn't :)
04:44:13 <Lemmih> boy: Pretty good actually. I figured how to make kick-ass plugins with ghc-api. Unfortunately I don't really have time to hack on it right now.
04:46:43 <boy> Lemmih: how does one learn about ghc-api?
04:47:17 <jix> is there a function to split a list into parts of a specified length? like f 4 "TestTestTest" => ["Test", "Test", "Test"] ?
04:48:59 <Lemmih> boy: There's no documentation yet. You'd have to read the source )-: 
04:49:42 <ski> > let f n = unfoldr (\as -> if null as then Nothing else Just (splitAt n as))  in  f 4 "TestTestTest"
04:49:43 <lambdabot> ["Test","Test","Test"]
04:50:19 <boy> Lemmih: that's what everyone keeps telling me :\
04:50:32 <boy> Lemmih: just one question then: does ghc-api make hs-plugins obsolete?
04:50:32 <jix> ski: thx
04:51:24 <ski> > let f n = unfoldr (\as -> guard (not . null $ as) >> Just (splitAt n as))  in  f 4 "TestTestTest"
04:51:25 <lambdabot> ["Test","Test","Test"]
04:51:31 <Philippa> probably not currently - I suspect you could implement hs-plugins with ghc-api, but that's not obsolescence per se
04:52:12 <ski> > let f n = unfoldr (\as -> guard (not . null $ as) >> Just (splitAt n as))  in  f 3 "TestTestTest"
04:52:13 <lambdabot> ["Tes","tTe","stT","est"]
04:52:19 <ski> > let f n = unfoldr (\as -> guard (not . null $ as) >> Just (splitAt n as))  in  f 5 "TestTestTest"
04:52:20 <lambdabot> ["TestT","estTe","st"]
04:53:49 <genneth> has any one seen: http://mces.blogspot.com/2006/04/throwing-exceptions-with-posixiso-c.html
04:54:02 <Lemmih> boy: Um, not really. The GHC-api does everything hs-plugins does but you might wanna use it when you want something lightweight.
04:54:03 <genneth> any idea whether it's joking or not? it is april 1st
04:54:05 <jix> in my case the list is always a multiple of the specified size
04:54:10 <jix> +size
04:54:48 <Lemmih> boy: (linking with the ghc-api adds another 8mb to your binary :)
04:57:42 <boy> Lemmih: ok cool, thanks. which version of ghc do i have to use if i want ghc-api?
04:57:49 <Philippa> Lemmih: how readily does it strip?
04:58:06 <pesco> dons: Maybe you can help me with my hscurses+unicode problem? Which is the canonical way to do proper unicode output with hscurses? Just passing in the strings as they are shows nothing. So I manually encode to UTF-8, map the bytes back to Char with chr and pass that. This works (my terminal expects UTF-8, incidentally) but only for _some_ characters, appearently those with lower codes, like beta for instance. Higher ones produce garbage strinrgs like
04:58:40 <pesco> dons: Any idea what's causing this?
04:59:05 <pesco> dons: Just printing the utf-8 string with putStrLn shows the desired results for all characters.
04:59:12 <Lemmih> boy: ghc-6.5 (the development version).
04:59:20 <boy> Lemmih: ok cool
04:59:57 <davidhouse> grr. i can't get Debug.Trace to work
05:00:21 <vincenz> what are phantomtypes?
05:00:38 <boy> Lemmih: do you mind if i bug you with a few more questions about ghc-api?
05:00:49 <davidhouse> my code is now decorated with calls to trace, and i complied and ran, but nothing's showing up apart from the output of my algorithm
05:01:04 <Lemmih> boy: Not at all.
05:01:10 <ski> vincenz : type constructor arguments that are unused
05:01:23 <vincenz> ski: can you give me a simple example/
05:02:08 <astrolabe> davidhouse: odd.  Maybe stderror is not stdout for your set up?
05:02:12 <musasabi> vincenz: data Foo a = Foo
05:02:22 <vincenz> ah
05:02:25 <vincenz> what use do they have?
05:02:26 <ski> vincenz : e.g.iirc 'Ptr a' is/can be defined like 'newtype Ptr a = MkPtr UntypedPtr'
05:02:29 <Lemmih> Philippa: I got it down from ~11mb to ~8mb by stripping it, iirc.
05:02:40 <ski> vincenz : type checking
05:02:51 <vincenz> besides... if you then use the data constructor
05:02:51 <vincenz> Foo
05:03:01 <vincenz> doesn't the compiler not know which type it is? (Foo Int...Foo Double ...)
05:03:06 <davidhouse> astrolabe: doesn't something like 3>&1 direct stderr to stdout?
05:03:21 <vincenz> ski: still not quite seeing it :/
05:03:23 <astrolabe> I don't know
05:03:26 <sieni> davidhouse: well 2>&1
05:03:27 <Lemmih> Philippa: Compiling ghc with -split-objs might help.
05:03:29 <vincenz> I mean I see what they are, just not their use
05:03:31 <ski> vincenz : even if your internal representation uses a common format, you may want the external interface to constrain the user to use the operations in a restricted way
05:03:33 <davidhouse> sieni: thanks
05:03:47 <davidhouse> hmm... still doesn't work.
05:03:48 <sieni> davidhouse: since both stdin and stdout are in "1"
05:04:02 <sieni> davidhouse: what are you doing?
05:04:02 <vincenz> ski: oh...so you only export the type cons and not the datacons
05:04:07 <vincenz> ski: and provide constructor funcitons?
05:04:08 <ski> right
05:04:11 <ski> yes
05:04:15 <vincenz> cool, thank you :)
05:04:24 <sieni> davidhouse: for a file: foo > file 2>&1
05:04:24 <ski> that are explicitely typed with more restricted types
05:04:32 <davidhouse> i'm not calling trace directly, i've set up a function "log": log s = trace s $ return () (the return () is for convenience as it's being called from the state monad). would that matter?
05:04:41 <sieni> davidhouse: for a pipe foo 2>&1 | bar
05:05:17 <davidhouse> sieni: yeah, i'm familiar with redirection, i just couldn't remember which numbers to use and where to put the ampersand
05:06:03 <sieni> davidhouse: ok
05:06:20 <astrolabe> @hoogle trace
05:06:20 <lambdabot> Debug.Trace.trace :: String -> a -> a
05:06:20 <lambdabot> Debug.Trace :: module
05:06:20 <lambdabot> Debug.Trace.putTraceMsg :: String -> IO ()
05:07:09 <davidhouse> i don't think i need to call putTraceMsg anywhere... do i?
05:07:19 <ski> @hoogle Either
05:07:19 <lambdabot> Prelude.Either :: data Either a b
05:07:19 <lambdabot> Prelude.either :: (a -> c) -> (b -> c) -> Either a b -> c
05:07:36 <vincenz> ski: I see now why haskelldb would use them... underneath you most likely encode all as strings
05:07:39 <astrolabe> davidhouse: I don't think so, but it might be worth seeing if it works.
05:07:46 <ski> vincenz : exactly
05:07:58 <vincenz> :)
05:08:34 <davidhouse> putTraceMsg with an argument shows that argument, that works fine.
05:08:37 <jyp> davidhouse: it is very possible that your (log expr) never gets reduced to head normal form
05:08:48 <ski> vincenz : you can sortof build custom DSL type-systems with it
05:09:00 <jyp> davidhouse: in which case you get no output
05:09:05 <davidhouse> jyp, what does that mean, and what should i do?
05:09:06 <vincenz> ski: how so?
05:09:39 <ski> vincenz : in the case of haskelldb, they basically add a typesystem over the sql layer
05:09:47 <vincenz> right
05:09:54 <astrolabe> davidhouse: if you don't use the returned () I think.
05:10:11 <davidhouse> well trace needs two arguments. what should i give it as the second?
05:10:23 <jyp> davidhouse: It means that if the result of (log expr) is not used in computing the output of your program, then it's not "called"
05:10:34 <davidhouse> ah.
05:10:51 <davidhouse> well my calls to log look something like "(log $ "Any: " ++ show i) >> next"
05:10:54 <vincenz> ski: thanks for the help :)
05:11:12 <jyp> davidhouse: I think it gets optimized away.
05:11:25 <Lemmih> davidhouse: You could do: do ...; trace msg $ do ... -- this can look quite nice with newlines.
05:11:28 <ski> davidhouse,jyp,astrolabe : i think that 'log' would work, even if you don't inspect the returned '()'
05:12:24 <davidhouse> Lemmih, brilliant :)
05:12:40 <davidhouse> changing that to "log ("Any: " ++ show i) next" works.
05:12:45 <ski> since it must first force the 'log s' action to see how it will transform the state (in the state monad), so it prints the trace message, and then it discovers that the action is a plain 'return'-action, so it doesn't change the state
05:13:11 <davidhouse> err, "trace ("Any: " ++ show i) >> next"
05:13:52 <ski> did you mean
05:13:52 <ski> log ("Any: " ++ show i) >> next
05:13:53 <ski> ?
05:14:01 <vincenz> ski: is it possible, some how...to use phantom types to detect the layout of db at runtime
05:14:45 <ski> vincenz : do you mean which tables are present, and which schemas they have ?
05:14:54 <davidhouse> ski, no, i mean "trace ("Any: " ++ show i) next" :) what you put is what i had before
05:15:48 <ski> davidhouse : 'trace ("Any: " ++ show i) >> next' looks like a type error, anyhow (unless you're working in '((->) a'-monad :)
05:16:19 <davidhouse> that would be weird.
05:16:21 <vincenz> ski: yep
05:16:26 <ski> davidhouse : but yes, that last one you showed would work, i think
05:17:17 <jyp> bot
05:17:51 <ski> vincenz : *maybe* using existential types, somehow .. otherwise i don't see how it could work without already knowing in program what table schemas could apply
05:18:06 <ski> s/knowing/knowing statically/
05:18:36 <ski> s/existential types/existential types (or GADTs or similar)/
05:21:15 <vincenz> which means you can't do something like ... xxxrecords (Forgot the name) in ruby
05:22:15 <vincenz> maybe with hsplugins
05:30:37 <Saulzar> Have your program read the db, write Haskell and load it?
05:31:18 <dons> ?remember Lemmih A few days ago I wondered whether it would be possible to call GHCi from interpreted byte-code.
05:31:19 <lambdabot> Done.
05:32:48 <ski> hm
05:32:50 <ski> ?
05:32:55 <ski> ??
05:32:55 <lambdabot> Not enough arguments to @.
05:39:07 <davidhouse> ?help remember
05:39:07 <lambdabot> quote <nick>
05:39:07 <lambdabot> remember <nick> <quote>
05:39:07 <lambdabot> Quote somebody, a random person, or save a memorable quote
05:39:27 * davidhouse wonders
05:39:33 <pesco> ?quote
05:39:33 <lambdabot> Taral says: How do you add an @quote?
05:39:42 <davidhouse> ?rememer davidhouse hello there
05:39:43 <lambdabot> Done.
05:39:47 <davidhouse> hello, lambdabot
05:39:53 <pesco> ?quote
05:39:53 <lambdabot> astrolabe says: I put my thing in inverted commas because it isn't a really stalactite, but it looks like one, and contains nitrates from urea.
05:39:57 <davidhouse> aww, it's not what i thought it was :(
05:52:57 <Lemmih> @quote adept
05:52:57 <lambdabot>  I think I need cobrain to understand coeffects
05:53:03 <Lemmih> @quote adept
05:53:03 <lambdabot>  Tried to co-read and co-understand comonads, but got co-re dump
05:56:11 <astrolabe> Can anyone guess why, when I generate a .prof file, it is empty?
05:56:48 <ndm|bristol> not build for profiling
05:56:53 <Lemmih> astrolabe: You forgot +RTS -p?
05:57:30 <astrolabe> Lemmih: Thanks, I didn't, but maybe it got removed.
05:58:54 <astrolabe> or maybe I typed +RST  :/
06:02:44 <ski> ndm|bristol : hm wouldn't 'Prelude.Either :: * -> * -> *' be more proper than 'Prelude.Either :: data Either a b' as answer to '@hoogle Either' ?
06:03:04 <ndm|bristol> ski, no, beacuse i don't understand kinds :)
06:03:32 <int-e> @kind Either
06:03:32 <lambdabot> * -> * -> *
06:03:34 <ndm|bristol> anyway, I think the way it says now is clearer and would probably be more understood by most people
06:03:46 <ndm|bristol> but the first is probably more technically correct
06:05:35 <davidhouse> data Either?
06:05:41 <davidhouse> Either isn't a data constructor ;)
06:06:10 <ndm|bristol> it is a data type though
06:06:25 <ndm|bristol> written data Either a b = Left a | Right b
06:06:46 <ndm|bristol> hence the "bit near the either"
06:06:50 <ndm|bristol> is "data Either a b"
06:06:57 <davidhouse> yeah, meaning Left and Right are the data constructors and Either is a type constructor.
06:07:04 <davidhouse> i'd go for type Either a b
06:07:23 <ndm|bristol> i don't want that, since type implies a type alias
06:07:27 <ndm|bristol> @hoogle String
06:07:28 <lambdabot> Foreign.C.String :: module
06:07:28 <lambdabot> Prelude.String :: type String
06:07:28 <lambdabot> Text.Read.String :: String -> Lexeme
06:07:43 <ndm|bristol> It really should say type String = [Char]
06:08:02 <ndm|bristol> and the prelude should be first, i think it is on teh website
06:08:53 <ski> ndm|bristol : if it doesn't show kind, i'd prefer 'Prelude.Either a b' or 'data Prelude.Either a b' or 'data Prelude.Either a b = Left a | Right b'
06:09:20 <davidhouse> why Prelude. ?
06:09:33 <ski> to see which module it resides in
06:09:42 <ski> recall this is answer to '@hoogle'
06:09:45 <ndm|bristol> @hoogle Either
06:09:45 <lambdabot> Prelude.Either :: data Either a b
06:09:45 <lambdabot> Prelude.either :: (a -> c) -> (b -> c) -> Either a b -> c
06:10:00 <davidhouse> ah, yeah, i see
06:10:08 <ndm|bristol> the Prelude is already on the left hand side, hence i don't think it needs duplicating on the right as well
06:10:09 <mathrick> @type (`(-)` 3)
06:10:10 <lambdabot> parse error on input `('
06:10:23 <mathrick> @type (+ 3)
06:10:24 <lambdabot> forall a. (Num a) => a -> a
06:10:31 <ndm|bristol> ski, i can't do = Left a | Right b, since in general the type may take up too much space
06:10:32 <mathrick> @type (- 3)
06:10:33 <lambdabot> forall a. (Num a) => a
06:10:53 <ski> ndm|bristol : no, you misunderstood .. i wanted no 'Prelude.Either ::' part at all, just one of my proposed variants
06:11:36 <ski> ndm|bristol : yes, that's understandable .. so how about one of the two former variants, then ?
06:11:57 <ski> actually, 'type Prelude.Either a b' would be ok with me, too (maybe better, even)
06:12:08 <ndm|bristol> ski, the entire reason is for the website
06:12:17 <ndm|bristol> if you look at that, you'll see all the module names line up
06:13:08 <ndm|bristol> and clicking on the module, takes you do the documentation for that modle
06:13:12 <ski> wouldn't 'Prelude.Either a b' work with that ?
06:13:34 <ndm|bristol> then there is no mention that its a data
06:13:46 <ski> (or prefixing 'data'/'type'/'class', if you have a column before the module path)
06:13:56 <ndm|bristol> no column before
06:14:07 <ndm|bristol> and would be a bit wasteful, since most results will just be functions
06:14:11 <ski> do you mean you don't want a column before ?
06:14:28 <ndm|bristol> yep
06:14:53 <ndm|bristol> is your main complaint that :: means type, and i am abusing it to mean separator?
06:15:12 <ski> yes
06:15:38 <ski> '::' should mean 'value has type' or 'type has kind'
06:15:52 <ndm|bristol> i had never even noticed i was doing that, it never really occured to me
06:16:25 <ndm|bristol> but you're right, its definately wrong
06:17:17 <ndm|bristol> for teh website i'll entirely drop the ::
06:17:31 <ndm|bristol> for the command line i'll move to data Prelude.Either a b
06:17:48 <ski> ok
06:18:05 <ski> it would also be nice it it would show
06:18:08 <ndm|bristol> thanks for that, its something i would never havespotted
06:18:18 <ski> Prelude.Left :: forall a b. a -> Either a b
06:18:24 <ski> Prelude.Right :: forall a b. b -> Either a b
06:18:31 <ski> when searching for 'Either'
06:19:23 <ski> (i.e. finding constructors with type mentioning the searched-for type, and not just other non-constructor functions)
06:19:41 <ndm|bristol> ski, yep, version 2 did that
06:19:43 <ndm|bristol> and i liked it
06:19:56 <ndm|bristol> it should really be added back
06:20:12 <ski> it would be nice, yes
06:20:37 <ndm|bristol> although it won't say forall
06:20:44 <ndm|bristol> but yes, it should detect that
06:21:05 <ndm|bristol> i need to rewrite a chunk of hoogle, but don't have time for another month or so yet
06:21:30 <ski> ndm|bristol : sure, if it doesn't show top-level 'forall', it's even better, imho :)
06:22:09 <ndm|bristol> ski, it actually throws away all forall's, and balks on MPTC
06:22:16 <ndm|bristol> its 100% haskell 98 + heirarchical modules
06:22:24 <ski> ok
06:22:55 <ski> (i was just wondering how to display audreyt's existential fields :)
06:23:18 <ski> @hoogle runST
06:23:18 <lambdabot> Control.Monad.ST.runST :: ST s a -> a
06:23:18 <lambdabot> Data.Array.ST.runSTArray :: Ix i => ST s (STArray s i e) -> Array i e
06:23:18 <lambdabot> Data.Array.ST.runSTUArray :: Ix i => ST s (STUArray s i e) -> UArray i e
06:23:50 <ski> right .. so it is a bit incorrect, in those cases
06:24:10 <ndm|bristol> yes, at parse time, it just drops all forall's
06:24:52 <ndm|bristol> i don't really understand forall's, so if someone wants that, they'll have to implement it
06:25:25 <Philippa> which part is it you don't understand particularly?
06:25:36 <ndm|bristol> Philippa: i never tried to understand, hence i never did
06:25:39 <Philippa> I have to admit they made a lot more sense once I'd encountered System F
06:25:42 <Philippa> ah
06:25:50 <ndm|bristol> i am sure if i had teh desire, i could
06:26:03 <Philippa> I can give you a 5 minute "what the feature's about" that'll probably stick, but hey
06:26:55 <ndm|bristol> ok, if you want
06:27:05 <ndm|bristol> i read a basic overview in teh GHC manual the other day
06:27:19 <ndm|bristol> package up types and functions, that can be compined
06:51:06 <vincenz> Anyone know where to register a blog?
06:51:09 <vincenz> if I have an RSS feed
06:51:14 <chrisbrown> livejournal?
06:51:17 <chrisbrown> blog.co.uk?
06:51:37 <chrisbrown> oh - is it a haskell blog? try planethaskell.org
06:51:53 <vincenz> not haskell perse no
06:52:08 <chrisbrown> you want to set up one?
06:52:32 <vincenz> no
06:52:34 <vincenz> I have my own wiki
06:52:38 <vincenz> which comes with a blog-like thing
06:52:41 <vincenz> and I can publish it to rss
06:52:50 <chrisbrown> ah sorry - thought you meant to set one up
06:56:00 <vincenz> how do I check if this is a valid rss blogfeed?
06:56:02 <vincenz> http://www.notvincenz.com/wiki/pmwiki.php/BlogPages/RecentChanges?action=rss
06:56:42 <davidhouse> @google feed v#alidator
06:56:44 <lambdabot> http://chucker.mystfans.com/2005/04/29/171.entry
06:56:48 <davidhouse> @google feed validator
06:56:48 <chrisbrown> not sure - it came up as an rss feed on my browser
06:56:49 <lambdabot> http://feedvalidator.org/
06:57:25 <vincenz> cool :)
07:16:38 <mux> http://mu.org/~mux/shuffle.hs
07:16:43 <mux> any comments on this little piece of code?
07:16:50 <mux> shuffles lines from stdin
07:17:46 <jyp> http://okmij.org/ftp/Haskell/perfect-shuffle.txt
07:18:34 <monochrom> http://www.cs.utoronto.ca/~trebla/Shuffle.hs :)
07:18:37 <droundy> your printLines would be more elegant as printLines = putStr . unlines
07:19:00 <mux> jyp: this is a perfect shuffle, it uses Knuth's algorithm
07:19:13 <monochrom> me too
07:19:14 <int-e> mux: why do you swap elements 0 and i instead of just inserting x at position i?
07:19:20 <mux> all permutations have an equal probability of happening
07:19:37 <mux> int-e: uh? well I need to swap and not to insert something
07:19:39 <int-e> mux: the swap is really a trick for making it work on arrays, but you're not using arrays
07:20:28 <mux> droundy: I'll look about this, thanks
07:20:49 <droundy> mux: or printLines = mapM_ putStrLn
07:21:12 <jyp>  mapM_ putStrLn being the efficient version :)
07:21:31 <droundy> :)
07:21:40 <mux> my head hurts
07:22:03 <mux> I feel as if my brain had been smahed by a golden brick with a slice of lemon
07:22:13 * int-e would write that in Python (oh no, wait, I already did!)
07:22:22 * int-e ducks
07:22:43 <droundy> but putStr . unlines is the easy-to-understand version (does the work in non-monadic code)
07:22:49 <mux> I wrote that in C, and thought it would be a funny haskell exercise
07:22:56 <davidhouse> mapM_ putStrLn is much better.
07:22:56 <mux> there's not much point in it otherwise
07:23:29 <davidhouse> you might be able to shorten that readLines as well.
07:23:36 <davidhouse> @type until
07:23:37 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
07:23:59 <davidhouse> is there a monadic until?
07:25:01 <monochrom> No, until you write one.
07:25:15 <ndm> @type when
07:25:16 <lambdabot> Not in scope: `when'
07:25:25 <jyp> davidhouse: perhaps in Iavor's new monad lib ?
07:25:36 <jix> is there a read like function that returns Just x on success and Nothing on failure?
07:25:37 * mux thinks his brain is fundamentally imperative
07:25:39 <monochrom> @type Control.Monad.when
07:25:40 <lambdabot> forall (m :: * -> *).
07:25:40 <lambdabot>         (Monad m) =>
07:25:40 <lambdabot>         Bool -> m () -> m ()
07:25:41 <davidhouse> hmm, well something like sequence $ repeat $ unless isEOF getLine might work
07:25:56 <davidhouse> mux, it's a phase.
07:26:03 <davidhouse> just use lists instead of loops. :)
07:26:05 <monochrom> when p s = if p then s else return ()
07:26:20 <droundy> readLines = lines `fmap` getContents -- uses lazy IO
07:26:39 <davidhouse> ah, good ol' getContents. forgot about that.
07:26:54 <mux> I think I've done imperative coding for too long :)
07:27:47 <ski> @hoogle when
07:27:47 <lambdabot> Monad.when :: Monad a => Bool -> a () -> a ()
07:27:47 <lambdabot> Control.Monad.when :: Monad m => Bool -> m () -> m ()
07:27:48 <int-e> unfoldM would be neat. unfoldM :: Monad m => (a -> m (Maybe b)) -> a -> m [b]
07:27:57 <davidhouse> mux, what you wrote was nice functional code.
07:28:27 <Lemmih> jix: Control.Exception.try
07:28:47 <ihope_> Hmm...
07:28:53 <davidhouse> @index isEOF
07:28:53 <lambdabot> System.IO
07:29:06 <ihope_> Is it possible to have a list of unboxed values?
07:29:25 <boy> anyone have logs of this channel? the tunes.org site has been down for several hours already
07:29:40 <ihope_> What're you looking for?
07:30:02 <jyp> boy: try meme.org
07:30:06 <ski> ihope : not the normal list type, no
07:30:13 <ski> @kind []
07:30:14 <lambdabot> * -> *
07:30:23 <ski> i.e. not '# -> *'
07:30:26 <jyp> boy: hm, http://meme.b9.com/~1bb178f9412191e34362b984~/cview.html?channel=haskell&date=today
07:30:37 <ski> @index Int#
07:30:38 <lambdabot> bzzt
07:31:18 <mux> davidhouse: the problem is that it took me an insanely long time to get it
07:31:22 <ski> @kind @kind GHC.Base.Int#
07:31:23 <lambdabot> parse error on input `@'
07:31:27 <ski> @kind GHC.Base.Int#
07:31:28 <lambdabot> #
07:31:33 <ski> @type GHC.Base.I#
07:31:34 <lambdabot> GHC.Prim.Int# -> Int
07:31:36 <davidhouse> mux: how much functional code have you written before?
07:31:54 <mux> davidhouse: I've been doing C for more than 10 years, kernel code etc
07:32:01 <mux> I think I'm doomed.
07:32:10 <davidhouse> :)
07:32:40 <davidhouse> yeah, i started learning haskell about two months back
07:32:40 <ski> doomed to be addicted to haskell ?
07:32:47 <boy> hm... i thought someone attempted to contact me while i was away, but apparently it was just someone saying, "...and boy that would suck" :|
07:32:57 <davidhouse> took me about 2 weeks to get my head round it and start throwing out nice functional code.
07:33:28 <davidhouse> boy, don't pick a commonly-used nick :) there's someone in #math called integral, he must get really anoyed by that.
07:33:39 <boy> davidhouse: heh
07:33:49 <mux> ski: doomed to have issues with functional programming :-)
07:34:11 <davidhouse> mux, keep it going. it honestly is just a phase.
07:34:23 <ihope_> Ntegr <- an unpronounc(ea|i)ble word.
07:34:35 <mux> yeah, I guess so, not sure if I'll be bored enough to go through it though :-P
07:34:43 <davidhouse> ihope_, i read that as 'netgear;
07:35:00 <monochrom> heh
07:35:05 <droundy> mux: it takes time to learn the cool easy functional tricks, but it's well worth it
07:35:15 <ski> @spell pronouncible
07:35:16 <lambdabot> pronounceable pronouncedly pronounce pronouncing producible
07:35:23 <int-e> but it's probably meant to be read as 'en-teg-arr'
07:35:27 <mux> I'm a bit disappointed by the large number of different ways to do stuff, looks to me as if Haskell if the Perl of the functional languages
07:35:35 <ihope_> int-e: it's not meant to be read at all.
07:35:48 <mux> and that ain't a compliment
07:36:21 <ihope_> Then don't use Haskell.
07:36:26 <int-e> ihope_: well, that failed.
07:36:31 <ski> mux : example of such a situation ?
07:36:43 <droundy> mux: but the ways aren't equivalent, it's more power that you've got.  e.g. lines `fmap` getContents is lazy, and can operate on infinitely long stdin in finite memory.
07:36:59 <droundy> which might or might not wat you want.
07:37:20 <davidhouse> i prefer liftM to fmap. to me it's more readable.
07:37:38 <davidhouse> it 'lifts' lines into IO
07:37:59 <mux> ski: lambda calculus notation and "regular" notation for one
07:38:20 <davidhouse> as opposed to fmap, which 'maps' across getContents. but getContents doesn't return a list? how can you map across it? etc. (rhetorical question, i know the answers, it's an issue of readability)
07:38:24 <ski> mux : sometimes one is better/clearer, sometimes the other is
07:38:33 <mux> that's what Perl guys say :-)
07:38:45 <ski> davidhouse : String = [Char]
07:39:04 <davidhouse> ski, yes, but you're not mapping lines across each char, are you ;)
07:39:14 <ski> no
07:39:24 <droundy> @hoogle getContents
07:39:25 <lambdabot> Prelude.getContents :: IO String
07:39:25 <lambdabot> IO.hGetContents :: Handle -> IO String
07:39:32 <ski> 'fmap' is generalized from list, it needn't work on lists at all
07:39:47 <davidhouse> no, hence why it works here.
07:39:53 <ski> 'map' (and 'mapM','mapM_') is another thing
07:40:06 <ihope_> If lambda notation looks confusing, use the other notation. :-)
07:40:33 * ski ponders : `(lines <(getContents)>)'
07:40:44 <davidhouse> mux, lambda is useful for a quick function, normally that you're passing to another function. when it gets unwieldy, use a let binding
07:40:47 <mux> ihope_: not my point.. but well.
07:40:53 <int-e> ski: please, be reasonable.
07:40:54 <mux> I'm not wanting to rant on Haskell
07:41:03 <ski> int-e : hm ?
07:41:13 <int-e> ski: there's only so much Perl a language can take :)
07:41:14 <davidhouse> e.g. map (\a -> if a == 'b' then [] else [1..5]) or something like that.
07:41:41 <ski> int-e : that's not supposed to be perl :)
07:42:31 <davidhouse> does haskell have a tertiary operator?
07:42:33 <ski> int-e : it's a variant of monadic reflection/reification syntax, i've been thinking on  (i have mostly thought on the abstract syntax and semantics, as opposed to the concrete syntax)
07:42:37 <davidhouse> other then if/then/else ;)
07:43:07 <ndm> davidhouse: no
07:43:09 <davidhouse> i guess not, as operators have to be binary
07:43:16 <ihope_> foo . bar $ y -- this looks tertiary :-)
07:43:20 <ski> > - (2*3)
07:43:21 <lambdabot> -6
07:43:21 <davidhouse> shame. it's handy sometimes
07:43:24 <ndm> but often people define cond or if'
07:43:28 <ndm> as a function
07:43:36 <davidhouse> tertiary in the sense of ?:
07:43:40 <ihope_> \x y z -> if x then y else z
07:43:47 <ndm> if' (a == 'b') [] [1..5]
07:43:50 <davidhouse> e.g. in PHP, $value = $predicate ? $true_value : $false_value
07:43:59 <ihope_> Okay, let's see here...
07:44:00 <ski> > let b ? (t,e) = if b then t else e  in  (1 < 2) ? ("foo","bar")
07:44:01 <lambdabot> "foo"
07:44:20 <monochrom> if-then-else is just fine
07:44:28 <ndm> you could probably define one, using some fixity and perhaps a : data type
07:44:40 <ndm> predicate ? true :? false
07:44:48 <ndm> i suspect that could be defined in haskell
07:44:48 <ski> yes
07:44:54 <ihope_> Aye. Pretend they're tertiary.
07:44:57 <davidhouse> > let b ? (t,e) = if b then t else e; (:) = ((,)) in (1 < 2) ? ("foo" : "bar")
07:44:57 <lambdabot> Couldn't match `[Char]' against `Char'
07:45:20 <monochrom> You can also program your IDE to display if-then-else as ?:
07:45:34 <ski> davidhouse : '(:)' is not a variable operator, it's a constructor operator
07:45:41 <ski> (so you can't rebind like that)
07:45:51 <davidhouse> aww.
07:45:52 <int-e> > let b ? (t,e) = if b then t else e; (|) = ((,)) in (1 < 2) ? ("foo" | "bar") -- this should work though
07:45:52 <lambdabot>  parse error on input `|'
07:46:01 <int-e> ahhh. no.
07:46:15 <ihope_> > let a ? b = (a,b); (a,b) ?: c = if a then b else c in True ? 3 ?: 4
07:46:16 <lambdabot> 3
07:46:21 <ihope_> > let a ? b = (a,b); (a,b) ?: c = if a then b else c in False ? 3 ?: 4
07:46:22 <lambdabot> 4
07:46:28 <ski> davidhouse : *maybe* you could hide '(Prelude.:)' and define '(:)' in a module as a constructor of a new datatype ..
07:46:39 <monochrom> No, : is special.
07:46:44 <davidhouse> or do it ihope_'s way :)
07:46:55 <ski> monochrom : ok
07:47:11 <monochrom> It's a pity.
07:48:06 <davidhouse> monochrom: special in the sense that it's a constructor?
07:48:12 <davidhouse> or is there even more specialness
07:48:31 <monochrom> It is hardcoded into the grammar of Haskell.
07:49:47 <ihope_> Let's see...
07:50:10 <ihope_> infixr 1 ?, :?
07:50:24 <ihope_> data Cond a b = a :? b
07:50:45 <ihope_> a ? b :? c = if a then b else c
07:51:03 <monochrom> yeah something like that will work
07:51:41 <davidhouse> why do you need to specify a fixity if you're giving both ? and ?: the same?
07:52:16 <int-e> davidhouse: because the associativity is also specified and differs from the default
07:52:49 <ihope_> The default is infixl 9 ?, :? if I remember correctly
07:54:38 <chrisbrown> does anyone know anything about ghc 6.5 and overlapping instances?
08:01:26 <ihope_> > (!>>=)
08:01:27 <lambdabot>  Not in scope: `!>>='
08:03:08 <davidhouse> ihope_: qu'est-ce que c'est?
08:03:42 <mux> ohoh des francais
08:04:29 <ihope_> Lo siento. No hablo franc√©s.
08:04:31 <cpatrick> <funny accent>I strike in your general direction!</acccent>
08:04:41 <davidhouse> ihope_, "what's that"?
08:04:56 <ihope_> It's >>= with ! in front of it.
08:05:07 <davidhouse> well, quite.
08:05:12 <davidhouse> what's it meant to do?
08:05:30 <ihope_> m a -> (m a -> b) -> m b
08:05:58 <davidhouse> weird.
08:06:17 <davidhouse> unless you meant m a -> (a -> m b) -> m b
08:06:28 <ihope_> Nope.
08:07:00 <cpatrick> er. what's that used for?
08:07:14 <ihope_> What's what used for?
08:07:26 <cpatrick> !>>=
08:07:34 <ihope_> Nothing yet :-P
08:07:37 <cpatrick> @djinn Monad m => m a -> (m a -> b) -> m b
08:07:38 <lambdabot> Cannot parse command
08:07:39 <davidhouse> ihope_, then why require a to be monadic?
08:07:54 <ihope_> davidhouse: did I say anything about monads?
08:08:08 <cpatrick> @djinn m a -> (m a -> b) -> m b
08:08:09 <lambdabot> -- f cannot be realized.
08:08:09 <davidhouse> fine. why require m a instead of just a?
08:08:32 <cpatrick> ihope_: it can't work for arbitrary m ...
08:08:53 <cpatrick> You need to have some way of wrapping your 'b' into an 'm b'
08:09:16 <ihope_> Well... you have an m a lying around to help out.
08:09:43 <cpatrick> yeah, but after you've applied the function to it there's no 'm' left
08:09:49 <monochrom> @djinn m a -> (m a -> b) -> m b
08:09:49 <lambdabot> -- f cannot be realized.
08:10:16 <cpatrick> if it's a monad, you can let (!>>=) x f = return (f x)
08:10:31 <ihope_> cpatrick: wouldn't the same problem seem to exist with monads?
08:10:38 <Saulzar> It can work if m is a monad, as you have return - but still it is not apparent where you'd use it
08:10:41 <cpatrick> ihope_: nah, monads have return
08:10:45 <ihope_> @type \x f -> return (f x)
08:10:46 <lambdabot> forall (m :: * -> *) t a.
08:10:46 <lambdabot>         (Monad m) =>
08:10:46 <lambdabot>         t -> (t -> a) -> m a
08:10:59 <ihope_> cpatrick: maybe I have some m a -> a
08:11:50 <cpatrick> nah, it's an a -> m a that you need
08:12:07 <ihope_> cpatrick: just like you "need" m a -> a for a monad.
08:12:54 <Saulzar> There is no IO a -> a :)
08:13:08 <ihope_> System.Unsafe.unsafePerformIO, but that's unsafe. :-)
08:13:24 <resiak> crapbuster
08:13:24 <monochrom> I believe ihope_ is wildly misunderstood.
08:13:36 <ihope_> And it seems most of us like to pretend that doesn't exist...
08:13:41 <Saulzar> That breaks the monad abstraction, so it does not count :)
08:14:04 <resiak> erm
08:14:10 <ihope_> > System.Unsafe.unsafePerformIO -- I think lambdabot's one of the it-doesn't-exist-ists.
08:14:11 <lambdabot>  Not in scope: `System.Unsafe.unsafePerformIO'
08:14:27 <davidhouse> well lambdabot doesn't do IO anyway
08:14:31 <cpatrick> There's a name for something like that isn't there? Monoid or functor or whatnot. (that has return but not the other monad functions)
08:14:49 <Saulzar> Hmm, maybe that makes no sense. It breaks referential transparency perhaps but not much to do with monads...
08:15:12 <ihope_> Um... a class with only return?
08:15:28 <cpatrick> yeah
08:15:32 <Saulzar> @hoogle m a -> (m a -> b) -> m b
08:15:33 <lambdabot> Data.Generics.Schemes.everywhere :: (a -> a) -> a -> a
08:15:33 <lambdabot> Data.Generics.Schemes.everywhere' :: (a -> a) -> a -> a
08:15:33 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
08:15:43 <ihope_> !
08:16:17 <monochrom> Are you looking for a comonad?
08:16:28 <ihope_> monochrom: maybe
08:16:30 <ihope_> @djinn (m a -> (m a -> a) -> m a) -> m a -> m (m a)
08:16:31 <lambdabot> -- f cannot be realized.
08:16:59 <davidhouse> @djinn m a -> (a -> m b) -> m b
08:17:00 <lambdabot> -- f cannot be realized.
08:17:08 <davidhouse> djinn doesn't know about >>=.
08:17:59 <ihope_> There is nothing with type m a -> (a -> m b) -> m b. (>>=) :: Monad m => m a -> (a -> m b) -> m b -- :-)
08:18:18 <ihope_> @djinn Maybe a -> (a -> Maybe b) -> Maybe b
08:18:19 <lambdabot> f a b =
08:18:19 <lambdabot>   case a of
08:18:19 <lambdabot>   Nothing -> Nothing
08:18:19 <lambdabot>   Just c -> b c
08:18:52 <davidhouse> @djinn IO a -> (a -> IO b) -> IO b -- okay, so lambdabot doesn't know about monads then
08:18:52 <lambdabot> Cannot parse command
08:18:58 <davidhouse> @djinn IO a -> (a -> IO b) -> IO b
08:18:58 <lambdabot> -- f cannot be realized.
08:18:59 <cpatrick> I doesn't think it does type classes at all
08:19:20 <cpatrick> because type classes would make what it does undecidable in some cases (?)
08:20:25 <ihope_> Csary (sic);
08:33:49 <metaperl> CosmicRay: ping?
08:34:04 <metaperl> has anyone viewed http://sequence.complete.org/ using Konqueror? It's all blue and unreadable
08:34:14 <CosmicRay> hi metaperl 
08:34:20 * CosmicRay tries
08:34:39 <Saulzar> Looks ok here
08:34:42 <CosmicRay> it looks fine on my konqueror
08:34:56 <metaperl> oh I think it must be my KDE prefs controlling konqueror somehow
08:35:01 <CosmicRay> heh
08:35:03 <metaperl> its a dark purple color
08:35:08 <ihope_> Whoa!
08:35:11 <ihope_> Hmm...
08:35:12 <CosmicRay> or maybe slashdot has taken over your machine
08:35:18 <CosmicRay> do you also see unicorns? ;-)
08:35:57 <ihope_> Cool!
08:37:26 <CosmicRay> so how goes it metaperl?  ltns
08:37:57 <metaperl> CosmicRay: pretty good. I'm starting to study Haskell again. I am too old to learn C++. Though it is quite an impressive language
08:38:05 <metaperl> still a Perl programmer by trade
08:38:28 <CosmicRay> I learned C++ in 1995, and never really cared to use it ;-)
08:39:05 <metaperl> the STL and Boost take it to another level... all the various container classes depending on how the container will be used (vector, list, etc)
08:39:22 <metaperl> resetting all my KDE prefs fixed the display issue
08:46:43 <genneth> metaperl: have you seen the boost::multi_index stuff? i would say it's one of the crowing achievements of C++; it's almost elegant :p
08:47:03 <ski> ihope_ : your '(!>>=)' is the "cobind" operation for comonads
08:47:05 <ski> cpatrick : Conor McBride's 'Idiom'/'Applicative' ?
08:47:15 <metaperl> genneth: no, I have not. I got as far as skimming "Accelerated C++" and seeing the power of the STL
08:48:15 <genneth> metaperl: it's fun to see how to translate haskell thinking into C++; i've recently done a load of exercises in backtracking calculations, all of them guided by the list monad thinking, but then cludged up in C++
08:48:31 <metaperl> genneth: oh really?
08:48:44 <metaperl> what do you mean by backtracking
08:49:10 <genneth> the sort of thing like solving sodukus, etc. where you have a large number of things to try
08:49:29 <metaperl> oh, yes. the lazy infinite data structures of Hs can be helpful in this case
08:49:58 <genneth> the list monad makes it a snap, but sometimes you just need bit more speed or in my case, not being non-lazy enough to learn about some more data structures in haskell
08:50:10 <genneth> i've gotten too fond of the C++ STL data structures
08:51:11 <mwc> I thought I saw a purpose built backtracking monad a while ago
08:51:53 <mwc> http://www.csee.ogi.edu/~diatchki/monadLib/current/doc/html/Monad-SearchT.html
08:53:02 <genneth> ah yes
08:53:05 <genneth> that gives more control
08:53:19 <genneth> for my purposes, just a very naive list was more than enough
08:56:22 <metaperl> CosmicRay: wouldn't h1 h2 h3 or something like that be nice for inputting blog entries? I want to write a blog entry and separate the major parts via <h1> but that is not allowable Filtered or Manual HTML
08:59:14 <robokop> @hoogle (a,b,c) -> (a ->b) -> (a -> c) -> (b->c)
08:59:15 <lambdabot> No matches, try a more general search
09:00:25 <mwc> @hoogle (b -> a) -> (a -> c) -> (b -> c)
09:00:26 <lambdabot> No matches, try a more general search
09:00:32 <mwc> hmmm,
09:01:08 <robokop> well didn't really searched for one but just tested i the bot was alive
09:01:18 <robokop> because in PM he isn't
09:04:49 <astrolabe> @type (.)
09:04:49 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
09:06:56 <astrolabe> @djin (b->a)->(a->c)->(b->c)
09:06:56 <lambdabot> Maybe you meant: djinn djinn-add djinn-clr djinn-del djinn-env djinn-ver
09:07:05 <astrolabe> @djinn (b->a)->(a->c)->(b->c)
09:07:05 <lambdabot> f a b c = b (a c)
09:07:23 <astrolabe> I can't msg lambdabot either
09:07:31 <liyang> @pl f a b c = b (a c)
09:07:31 <lambdabot> f = flip (.)
09:08:09 <musasabi> Any idea how to get the fundeps right for a class like: (using -fallow-overlapping-instances)
09:08:12 <musasabi> class Result a b                where comp :: a -> IO b
09:08:15 <musasabi> instance Result (Wrap a) a      where comp = return    . unWrap
09:08:20 <musasabi> instance Result (Wrap (IO a)) a where comp = runLazyIO . unWrap
09:09:00 <musasabi> I would like to say "a -> b" but that is (with a reason) not allowed.
09:14:26 <jyp> musasabi: I guess you can't define data Wrap a = Wrap a | WrapIO (IO a) ?
09:15:14 <CosmicRay> metaperl: I could set it up to allow that
09:15:30 <metaperl> ok I'm writing a post now that could use it
09:15:49 <CosmicRay> give me about 10 minutes
09:20:03 <musasabi> jyp: that wouldn't really work for the purpose.
09:20:04 <CosmicRay> ok, manual html should now do what you want.
09:24:16 <musasabi> as the "a" parameter will be left polymorphic and "b" will be bound in the code.
09:24:40 <musasabi> Wrap is just a "newtype Wrap a = Wrap a" to avoid undecidable instances.
09:33:47 <ihope_> Can every GADT be expressed with foralls?
09:34:08 <metaperl> CosmicRay: please look at http://sequence.complete.org/node/153  ... I dont think the new tags are working quite right
09:38:26 <musasabi> ihope_: not really.
09:38:56 <musasabi> ihope_: data Foo a where Foo :: Foo a -> Foo b -> Foo (a,b)
09:39:11 <ihope_> Ah...
09:39:26 <ihope_> What about the other way around?
09:39:34 <chrisbrown> make
09:39:41 <chrisbrown> oops wrong window
09:40:52 <musasabi> ihope_: the other way works afaik.
09:43:58 <ihope_> Now, when using type annotations, should I use forall in types like 
09:44:08 <ihope_> "forall a. [a]"?
09:44:41 <Philippa> not in haskell 98
09:44:48 <ihope_> :-)
09:44:50 <ihope_> That'd be to emphasize the fact that any a can be there, as opposed to just what has been passed into the function.
09:44:56 <Philippa> IMO they're more readable to most people if you leave them out for rank 1 types, too
09:45:16 <ihope_> What's a rank 1 type?
09:45:29 <Philippa> one where all the foralls are on the outside
09:46:44 <Blicero> whats the default fixity of a function that is converted to infix with ``
09:46:53 <ihope_> infixl 9
09:47:04 <Blicero> thanks
09:47:08 <musasabi> It usually makes sense to write foralls only when they are needed.
09:48:17 <ihope_> True. I was thinking along the lines of people wondering "in the type Maybe a, where does the a come from and just what is it?"
09:48:31 <Philippa> it's a lot easier for someone who mostly reads H98 code to read off a rank-1 type that doesn't have explicit foralls, or a rank-n one that lets the outermost quantifications be implicit
09:49:01 <ihope_> Does Hugs stick to H98?
09:49:11 <Philippa> yeah, there it's a nice exposition to show some people the version with the forall - except really the foralls're in the constructor types so there isn't one there
09:49:20 <Philippa> no, Hugs supports some extensions as well
09:50:54 <Saulzar> Only time when the implicit forall thing is a pain is when you're wanting to specify that type again inside your function..
09:51:10 <ihope_> Now here's a weird idea: first-class instance declarations :-)
09:51:32 <ihope_> I guess that's already somewhat possible...
09:51:44 <Philippa> it's called a module system
09:52:23 <Philippa> Saulzar: true, I forget how implicit quantification and lexically scoped type variables interact? Is it "use an explicit forall or forget it"?
09:52:26 <ihope_> data RandomGenInst a = RandomGenInst (a -> (Int,Int)) (a -> (Int,a)) (a -> (a,a)) -- something like this
09:53:16 <ihope_> Then replace "RandomGen a =>" with "RandomGenInst a ->".
09:53:33 <Philippa> I'm not kidding about the module system bit, there's a reasonably sensible interpretation of type classes as a special case of ML modules + a defaulting mechanism
09:53:53 <Philippa> = manual dictionary transform. Yes, you can fake away
09:54:19 * ihope_ gets an idea
09:56:02 <chrisbrown> anyone know why this is a UTF-8 decoding error?  ppi (D n (N s)) = ppi (subnum n)<+>ppIfDebug ("¬¥"<>s<>"¬™")
09:56:23 <ihope_> What are you DOING?
09:56:39 <ihope_> @seen dons
09:56:40 <lambdabot> dons is in #haskell. Last spoke 4 hours, 25 minutes and 19 seconds ago.
09:56:50 <chrisbrown> trying to port HaRe to GHC
09:57:12 <chrisbrown> look at these bad boys: ppi (S p) = ppIfDebug ("¬¥"<>p<>"¬™")
09:57:18 <chrisbrown>  ppi (G m _ _) = ppIfDebug ("¬¥"<>m<>"¬™")
09:58:34 <ski> (hm .. "¬™" looks like an underlined superscript 'a')
09:58:49 <ihope_> It looks like a just plain superscript a to me.
09:58:51 <chrisbrown> wonder if something is going on with my machine here
09:59:12 <ihope_> > "¬™"
09:59:13 <lambdabot> "\194\170"
09:59:15 <ski> chrisbrown : is it supposed to be some other (e.g. unicode) sign ?
09:59:18 <ihope_> Hmm.
09:59:25 <chrisbrown> it looks like an arrow
09:59:30 <chrisbrown> in SubEthaEdit
09:59:42 <chrisbrown> a small arrow in superscript pointing to the right upper corner
10:00:14 <ski> (and "¬¥" is grave accent sign, of course)
10:00:30 <ski> (s/grave/acute/)
10:00:42 <chrisbrown> ppIfDebug ("¬´"<>s<>"¬ª")
10:00:49 <chrisbrown> thats what it is in vim
10:00:49 <ihope_> That looks about right.
10:00:56 <ihope_> Double chevrons?
10:01:34 <chrisbrown> ghc 6.5 doesn't like it
10:02:14 <Philippa> ooh, I've just decided why I like unicode source... how big's the symbol set for operators now?
10:03:31 <chrisbrown> hmm this file is auto generated from somewhere
10:03:43 <Saulzar> Yeah but most of them already have specific meaning (from math for example)
10:04:51 <Saulzar> Half the operators in use seem to be mixing symbols in order to look like arrows
10:09:12 <pierre-> hello
10:10:18 <astrolabe> hello
10:10:25 <ihope_> Does anybody besides dons have privileges for lambdabot?
10:19:19 <chrisbrown> i wonder why 6.4 didn't have a problem with those
10:29:00 <chrisbrown> hmmmm
10:29:17 * chrisbrown has an idea
10:30:08 <ihope_> @slap <nick>
10:30:08 * lambdabot smacks <nick> about with a large trout
10:46:36 <jyp> @slap itself
10:46:37 * lambdabot beats up itself
10:48:50 <ihope_> @slap dons
10:48:50 * lambdabot smacks dons about with a large trout
10:48:58 <ihope_> Hmm, that was unexpected.
10:49:09 <ihope_> @slap dons again
10:49:09 * lambdabot smacks dons again about with a large trout
10:49:25 <ihope_> @slap NickServ
10:49:26 * lambdabot slaps NickServ
10:49:29 <ihope_> Meh.
10:49:47 <chrisbrown> @slap @slap @slap blah
10:49:48 * lambdabot beats up @slap @slap blah
10:49:53 <chrisbrown> boring
10:50:17 <ihope_> @slap
10:50:18 * lambdabot smacks  about with a large trout
10:51:06 <ski> @seen
10:51:06 <lambdabot> Lately, I have seen chrisbrown, ihope_, jyp and ski.
10:51:15 * ihope_ laughs
11:05:18 <robokop> @slap lamdabot
11:05:19 * lambdabot smacks lamdabot about with a large trout
11:07:46 <robokop> > id "/me is quite annoying"
11:07:47 <lambdabot> "/me is quite annoying"
11:08:09 <robokop> > putStrLn "/me is quite annoying"
11:08:10 <lambdabot> No IO allowed
11:08:24 <ihope_> :-)
11:09:06 <robokop> that is to protect himself or something like that
11:09:14 <ihope_> Aye.
11:09:26 <robokop> because else someone does something like
11:09:27 <pesco> Yeah, whatever! Stupid restriction. Don't be such a sissy, lambdabot!
11:09:43 <robokop> > putStrLn "/part"
11:09:44 <lambdabot> No IO allowed
11:09:51 <ihope> @id
11:10:13 <ihope> @id ACTION foobsar
11:10:13 * lambdabot foobsar
11:10:30 <robokop> @id test
11:10:31 <lambdabot> test
11:10:33 <ihope_> Hmm.
11:10:55 <ihope_> Not as hackable as the error error bug, but still hackable-ish.
11:11:22 <robokop> --@id /part
11:11:44 <robokop> would fit to force a part i guess
11:11:46 <ihope_> @id /part
11:11:47 <lambdabot> /part
11:11:50 <ihope_> ;-)
11:14:08 <robokop> ok maybe i should look at the sources and find the quit command (i'm to lazy for that)
11:14:24 <ihope_> @quit
11:14:25 <lambdabot> Not enough privileges
11:14:50 <robokop> what would @id @quit do
11:14:52 <ihope_> Now, if you wanted it to quit, you'd need it to do a CRLF followed by "QUIT".
11:14:56 <ihope_> @id @quit
11:14:56 <lambdabot>  @quit
11:15:42 <robokop> but i don't want him to quit so why would i search for how to do it
11:16:08 <robokop> i just want him to accept pm's again
11:16:23 <robokop> @id help
11:16:23 <lambdabot> help
11:16:35 <robokop> @id HELP
11:16:35 <lambdabot> HELP
11:17:14 <ihope_> I doubt you can perform a CRLF via @id, as that would require sending CRLF inside your message, which is impossible...
11:17:55 <Philippa> @id \n\r
11:17:55 <lambdabot> \n\r
11:18:00 <Philippa> bah
11:18:02 <Philippa> and yes
11:18:17 * ihope_ looks up the CTCP spec
11:18:23 <int-e> don't you mean \r\n?
11:18:31 <Philippa> probably
11:18:42 <ihope_> Aye.
11:18:50 <Philippa> ihope: CTCP's sent via PRIVMSG still
11:18:56 <ihope_> I know.
11:19:34 <robokop> @id PRIVMSG robokop test
11:19:35 <lambdabot> PRIVMSG robokop test
11:19:59 <goron> Is Cabal  lso supposed to handle auto downloading of packages etc? Or is that leverages to e.g. apt/Yast/whatever?
11:20:01 <ihope_> You need the CRLF.
11:20:18 <goron> s/lso/also
11:21:51 <Philippa> even that won't be enough
11:22:06 <Philippa> it's not sending raw data, it's PRIVMSGing stuff to the chan
11:22:12 <Korollary> goron: I think there's something called cabal-get
11:22:31 <ihope_> PRIVMSG #haskell :\r\nPRIVMSG #haskell :Broken?
11:22:45 <Philippa> ihope_: the IRC protocol doesn't do nested messages :-)
11:22:51 <ihope_> :-)
11:22:57 <goron> Korollary: Hmm, well, not on my system.
11:23:07 <Philippa> *everything* between : and CRLF is sent verbatim, within the message limit
11:23:46 <robokop> well i quit messing with lamdabot i should focus on implementing my miniMax algorithm
11:24:51 <ihope_> It looks like lambdabot still isn't identified to services.
11:26:27 <goron> Korollary: It's not released yet. There is a darcs beta though.
11:27:02 <goron> But considering the fact that almost all Haskell software still is a *pain* to install... 
11:28:01 <ihope_> Download the source, load Main.hs into GHCi...
11:28:11 <ihope_> I know. That isn't installing.
11:28:20 <goron> ihope_: I know what I am talking about.
11:28:37 <goron> ihope_: The installation simply sucks.
11:28:58 <chrisbrown> goron: what are you trying to install?
11:29:21 <goron> chrisbrown: I thought I build hIde to see whether it is something.
11:29:48 <chrisbrown> is there an official release of it yet?
11:29:51 <goron> chrisbrown: I have to get dependencies all by hand.
11:29:58 <goron> chrisbrown: no
11:30:19 <goron> chrisbrown: What's the point of an "open-source" program, if you make it inaccessible?
11:30:53 <chrisbrown> goron: perhaps this is your opportunity to make Haskell more accessible then ;)
11:31:02 <Philippa> goron: that's one of the reasons I try to stick to the libs that come with GHC most of the time
11:31:20 <Philippa> though hopefully cabal-get'll happen sometime?
11:31:21 <goron> Philippa: Yes, a kind of "batteries included" idea.
11:31:31 <goron> Philippa: Like Python.
11:31:45 <goron> Some guy had in his README:
11:31:50 <chrisbrown> i just try and stick with things that are Haskell 98, non-compiler specific
11:31:58 <goron> exectute these things in all subdirs of src.
11:32:06 <goron> I mean... write a script for it....
11:32:17 <goron> Don't bother every single user with it. 
11:32:18 <Philippa> chrisbrown: can't do that for a lot of stuff in practice. At the very least, the hierarchical libs contain a lot of stuff I need on a regular basis (Parsec!)
11:32:33 <goron> (This is released code I am talking about)
11:32:45 <goron> Either release something userfriendly, or don't. 
11:32:47 <chrisbrown> Philippa: well, I've never had a problem
11:33:07 <Philippa> chrisbrown: I don't see a CGI lib in the Report, 'nuff said? :-)
11:33:35 <goron> chrisbrown: I helped the Samba installation procedure to ease installation from SVN on FreeBSD. 
11:33:36 <Philippa> goron: easy for you to say, you're probably *nix-centric enough to get away withit
11:33:52 <chrisbrown> in my opinion if you use things that only work with one particular implementation, then you get what you ask for.
11:33:55 <Philippa> though if cabal groks dependencies like that it'll be v.cool
11:34:06 <goron> Philippa: Oh, I forgot about Windows :P
11:34:07 <Philippa> chrisbrown: the hierarchical libs aren't that specific
11:34:24 <goron> Philippa: That is a good explanation.
11:34:50 <goron> Philippa: Have you seen Klik?
11:34:55 <Philippa> no?
11:35:12 <goron> Philippa: Basically a package manager which installs everything in a chroot. 
11:35:37 <goron> Philippa: You click on a link in Konqueror, and it Just Works :)
11:35:44 <Philippa> cool
11:35:55 <goron> Philippa: Of course not all packages are packaged... but a lot are. 
11:36:06 <Philippa> cabal seems to largely just work but for package dependencies now
11:36:44 <Philippa> even there it at least tells you stuff needs installing
11:37:50 <goron> Philippa: The dependencies were pretty well reported, I agree. I assume there is no dependency on autoconf?
11:37:58 <Philippa> give it a couple of years and we'll have the big centralised package database and the graphical front end and all that crap
11:38:06 <Philippa> it works under windows just running setup.lhs
11:38:23 <Philippa> from an end-user perspective, I like it for what it does so far
11:39:23 <goron> Philippa: What works?
11:40:00 <Philippa> building cabal packages
11:40:13 <Philippa> so no, no autoconf, no make
11:40:39 <goron> Philippa: I need to do ./Setup.lhs configure;/Setup.lhs build;/Setup.lhs install
11:40:46 <Philippa> yes, so do I
11:41:16 <Philippa> I understand the reason for those three separate steps despite my *nix background being somewhat minimalistic. It'd be nice to have compound options, but hey
11:41:30 <Philippa> if it pissed me off that much I'd've written a batch file by now
11:41:49 <monochrom> map ./Setup.lhs [configure, build, install]
11:41:54 * heatsink was gonna say that
11:41:59 <monochrom> (If there were a functional shell)
11:42:00 <goron> Philippa: I already did that.
11:42:33 <Philippa> monochrom: I'm under windows. No, there isn't :-)
11:42:43 <Philippa> yeah, I'm not surprised
11:43:26 <monochrom> Imperative programming is seriously hampering minds.
11:43:27 <ski> (scsh ?)
11:44:52 <goron> ski: Did you really need to put that in parentheses?
11:44:58 <pesco> Philippa: Doesn't ./Setup.lhs install run the other two if you didn't already?
11:45:23 <Philippa> pesco: I honestly don't know, I've never tried. See "if it pissed me off..." :-)
11:45:31 <pesco> :) I see.
11:45:51 <Philippa> it's not that often I need to build other people's stuff anyway, most of my own's just a ghc --make
11:45:59 <monochrom> A million imperative programmers (some very smart and open-minded) cannot invent "map ./Setup.lhs [x,y,z]".  This is statistically significant evidence that language conditions mind.
11:46:17 <mwc> Sapir Worf hypothesis 2.0?
11:46:35 <Philippa> monochrom: I've seen a near-equivalent construct in DOS batch files...
11:46:48 <Philippa> it was only available over directory structures though
11:46:51 <mwc> THere are tribes in africa that can't count above 7
11:46:55 <goron> monochrom: I would even drop the ./ from it. 
11:46:59 <neologism> monochrom: in fbsd there is "apply" command which is "map"
11:47:09 <monochrom> Damn, I'm supposed to know DOS batch files.
11:47:18 <Philippa> monochrom: FOR :-)
11:47:32 <goron> monochrom: Oh, I was not even meaning that :)
11:47:37 <Philippa> it's a long, long time since my batch fu was worth a damn though
11:55:52 <robokop> is there a function f :: Float which gives me the maximum float value
11:57:22 <BlurredWe> whats wrong with xargs... takes a list, and does something to each element of the list
11:57:42 <pesco> ?hoogle count
11:57:43 <lambdabot> Text.ParserCombinators.ReadP.count :: Int -> ReadP a -> ReadP [a]
11:57:43 <lambdabot> Text.ParserCombinators.Parsec.Combinator.count :: Int -> GenParser tok st a -> GenParser tok st [a]
11:57:43 <lambdabot> Test.HUnit.Base.counts :: State -> Counts
11:57:50 <pesco> Grmbl.
11:59:39 <pesco> *talktoself* Why did they forget this function?
12:00:16 <audreyt> echo configure build install | xargs -n1 ./Setup.lhs
12:00:36 <audreyt> (more portable than apply)
12:00:53 <pesco> Haha, Audrey to the rescue! ;)
12:00:56 <audreyt> but yeah, rpike's apply is perhaps the one I'd use :)
12:01:09 <monochrom> robokop: you can do something with floatRadix, floatDigits, floatRange.
12:01:36 <audreyt> apply ./Setup.lhs configure build install
12:01:44 <audreyt> much better than map ;)
12:02:09 <monochrom> BlurredWe: xargs is different.
12:02:36 <monochrom> Ah, -n1, no wonder.
12:03:31 * audreyt notes that Hs doesn't come with a map2 either
12:04:10 <audreyt> map2 :: (a -> a -> b) -> [a] -> [b]
12:04:13 <audreyt> (presumably)
12:06:00 <norpan> what would map2 do
12:06:23 <monochrom> It is underspecified, and there is no way to complete it and keep everyone happy.  What if [a] has an odd number of items?  It will cause an endian war.
12:06:36 <audreyt> what xargs -n2 does, presumably
12:07:30 <Cale> @type map . join
12:07:31 <lambdabot> Not in scope: `join'
12:07:35 <Cale> @type map . Control.Monad.join
12:07:36 <lambdabot> forall a a1.
12:07:36 <lambdabot>           (Monad ((->) a)) =>
12:07:36 <lambdabot>           (a -> a -> a1) -> [a] -> [a1]
12:07:59 <Cale> of course, that's probably not the one you're looking for :)
12:09:41 <robokop> @hoogle Float
12:09:41 <lambdabot> Prelude.Float :: data Float
12:09:41 <lambdabot> System.Win32.Types.FLOAT :: type FLOAT
12:09:41 <lambdabot> Text.PrettyPrint.HughesPJ.float :: Float -> Doc
12:09:54 <Cale> @type \f x -> zipWith f x (drop 1 x)
12:09:55 <lambdabot> forall a c.
12:09:55 <lambdabot>             (a -> a -> c) -> [a] -> [c]
12:10:13 <robokop> monochrom: i saw your three functions but they are not what i'm looking for
12:10:38 <Cale> > (\f x -> zipWith f x (drop 1 x)) (+) [1,2,3,4,5]
12:10:39 <lambdabot> [3,5,7,9]
12:10:40 <Korollary> robokop: Why do you need the maximum float val anyway?
12:11:05 <robokop> initializing my alphabeta pruning algorithm
12:11:25 <heatsink> @type foldl1
12:11:26 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
12:11:31 <heatsink> @type foldr1
12:11:31 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
12:11:54 <sjanssen> robokop: so you need the largest float that isn't infinity?
12:12:04 <robokop> yeah
12:12:21 <robokop> but infinity will do
12:12:30 <monochrom> You can compose floatRadix, floatDigits, floatRange to find the maximum representable floating point value.
12:12:38 <sjanssen> > 1/0 :: Infinity
12:12:39 <lambdabot>  Not in scope: type constructor or class `Infinity'
12:12:46 <sjanssen> > 1/0 :: Float
12:12:46 <lambdabot> Infinity
12:12:56 <monochrom> > 1/-0 :: Float
12:12:57 <lambdabot>  Not in scope: `/-'
12:13:02 <monochrom> > 1/(-0) :: Float
12:13:03 <lambdabot> -Infinity
12:13:10 <monochrom> > 0 == -0
12:13:11 <lambdabot> True
12:13:18 <robokop> hmmm
12:13:31 <robokop> thanks that will do
12:13:37 <monochrom> > 1/0 == (1/0 :: Float)
12:13:38 <lambdabot> True
12:13:41 <sjanssen> robokop: writing 1/0 is a little nasty, but any IEEE implementation will work that way
12:13:43 <monochrom> > 1/0 == (1/(-0) :: Float)
12:13:44 <lambdabot> False
12:13:54 <robokop> 3<Infinity
12:13:59 <robokop> > 3<Infinity
12:14:00 <lambdabot>  Not in scope: data constructor `Infinity'
12:14:13 <monochrom> This breaks referential transparency...
12:14:26 <robokop> > 3<(1/0)
12:14:27 <lambdabot> True
12:14:44 <robokop> thank you guys
12:14:48 <sjanssen> monochrom: floating point numbers break any and all nice properties
12:14:54 <monochrom> heh
12:14:56 <robokop> but i'm off to sleep
12:15:22 <ihope_> > maxBound :: Float
12:15:23 <lambdabot>  add an instance declaration for (Bounded Float)
12:15:23 <lambdabot>   In the expression: maxBound :: Float
12:15:23 <lambdabot>   In the definition of `ecl': ecl = maxBound :: Float
12:15:29 <ihope_> :-P
12:18:25 <ihope_> bash: make: command not found
12:21:10 <ihope_> make: gcc: Command not found
12:28:05 <monochrom> gcc: bash: Command not found
12:28:13 <monochrom> This completes the cycle XD
12:29:44 <ihope_> @remember monochrom gcc: bash: Command not found
12:29:45 <lambdabot> Done.
12:39:45 <ihope_> @type elem
12:39:46 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
12:43:08 <ihope_> > 2^2^2^2
12:43:09 <lambdabot> 65536
12:43:13 <ihope_> > 2^2^2^2^2
12:43:22 <ihope_> That was weird.
12:43:28 <ihope_> > 2^2^2^2^2
12:43:43 <lambdabot> 20035299304068464649790723515602557504478254755697514192650169737108940595563114530895061308809333481010382343429072631818229493821188126688695063647615470291650418719163515879663472194429309279820843091048559905701593189596395248633723672030029169695921561087649488892540908059114570376752085002066715637023661263597471448071117748158809141357427209
12:43:47 <lambdabot> 67190151836282560618091458852699826141425030123391108273603843767876449043205960379124490905707560314035076162562476031863793126484703743782954975613770981604614413308692118102485959152380195331030292162800160568670105651646750568038741529463842244845292537361442533614373729088303794601274724958414864915930647252015155693922628180691650796381064132
12:43:52 <lambdabot> 27530726714399815850881129262890113423778270556742108007006528396332215507783121428855167555407334510721311242739956298271976915005488390522380435704584819795639315785351001899200002414196370681355984046403947219401606951769015611972698233789001764151719005113346630689814021938348143542638730653955296969138802415816185956110064036211979610185953480
12:43:57 <lambdabot> 27871672001226046424923851113934004643516238675670787452594646709038865477434832178970127644555294090920219595857516229733335761595523948852975799540284719435299135437637059869289137571537400019863943324648900525431066296691652434191746913896324765602894151997754777031380647813423095961909606545913008901888875880847336259560654448885014473357060588
12:44:00 <ihope_> Yikes!
12:44:02 <lambdabot> 17090162108499714529568344061979690565469813631162053579369791403236328496233046421066136200220175787851857409162050489711781820400187282939943446186224328009837323764931814789848119452713007440220765680910376203999203492023906626264491909167985461515778839060397720759279378852241294301017458086862263369284725851403039615558564330385450688652213114
12:44:04 <ohub> :D
12:44:07 <lambdabot> 8136384083847782637904596071868767285097634712719888906804782432303947186505256609781507298611414303058169279249714091610594171853522758875044775922183011587807019755357222414000195481020056617735897814995323252085897534635470077866904064290167638081617405504051176700936732028045493390279924918673
12:44:09 <pesco> Gee, thanks! ;)
12:44:20 <pesco> I was wondering what to do with all that empty space in this xterm...
12:44:23 <ihope_> @slap lambdabot
12:44:23 * lambdabot slaps lambdabot
12:44:23 <ohub> that was huge number
12:44:24 <pesco> :-P
12:45:51 <zamez> heh
12:46:15 <ihope_> Don't make me evaluate 2^2^2^2^2^2!
12:50:15 <genneth> i'll see your tetration and raise you A(5,5)!
12:52:05 <ihope_> S^S(A(5,5))(A(5,5))
13:04:31 <neologism> ihope_: now I knnow what my password will be:)
13:04:46 <ihope_> :-)
13:05:10 <ihope_> You mean you haven't hacked NickServ to require you to sign some random number using RSA in order to sign in?
13:05:31 <vincenz> why doesn't lambdabot trim?
13:05:43 <ihope_> vincenz: why doesn't it do what?
13:05:53 <ihope_> Oh, right.
13:13:23 <vincenz> ihope_: sicko
13:17:01 <ihope_> f(hyper(a,b,n))=hyper(f(a),b,n-1). Find f.
13:57:54 <bolrod> > let argh = filter (\a -> a =='\108' || a=='\111') ['\NUL','\SOH'..'\127'] in delete '\111'.concat $[argh,reverse argh]
13:57:55 <lambdabot> "lol"
13:57:59 <bolrod> *Yawn*
14:02:03 <ihope_> @index delete
14:02:03 <lambdabot> Data.HashTable, Data.IntMap, Data.IntSet, Data.List, Data.Map, Data.Set
14:02:12 <ihope_> @type Data.List.delete
14:02:13 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
14:02:38 <ihope_> > succ '\NUL'
14:02:39 <lambdabot> '\SOH'
14:03:15 <bolrod> :)
14:03:19 <ihope_> > let argh = filter (\a -> a =='\108' || a=='\111') ['\NUL','\SOH'..'\127'] in [argh,reverse argh]
14:03:20 <lambdabot> ["lo","ol"]
14:03:39 <ihope_> Aha!
14:03:45 <bolrod> ['z','y'..]
14:03:47 <ihope_> > sort "rofl"
14:03:48 <lambdabot> "flor"
14:03:49 <bolrod> > ['z','y'..]
14:03:50 <lambdabot> "zyxwvutsrqponmlkjihgfedcba`_^]\\[ZYXWVUTSRQPONMLKJIHGFEDCBA@?>=<;:9876543210/.-,+*)('&%$#\"! \US\RS\GS\FS\ESC\SUB\EM\CAN\ETB\SYN\NAK\DC4\DC3\DC2\DC1\DLE\SI\SO\r\f\v\n\t\b\a\ACK\ENQ\EOT\ETX\STX\SOH\NUL"
14:04:27 <bolrod> > length ['\NUL'..]
14:04:28 <lambdabot> 1114112
14:04:51 <xahlee> should i install darcs by fink?
14:05:00 <xahlee> it has version 1.0.6-1
14:05:39 <ihope_> Hmm...
14:08:24 <MarcWeber> How does gtk2hs exactly use the gtk interface? gtk is C++, isn't it? haskell can only call C functions, right?
14:10:20 <bolrod> possibly just like wxHaskell?
14:11:29 <MarcWeber> I'm asking because I want to view some pdfs (poppler lib .. written in C++)..
14:12:00 <zamez> GTK is C, not C++
14:13:05 <xahlee> what's the diff between latex2html and latex2html-ja?
14:13:06 <MarcWeber> zamez: I mixed gdk/gtk and gtk+  gtk+ is C++ sry
14:13:26 <zamez> not gtk+, that's still C
14:13:40 <MarcWeber> Neither?
14:13:46 <zamez> maybe you mean gtkmm?
14:13:55 <MarcWeber> Never heard.
14:14:14 <MarcWeber> Is gtk+ from gimp?
14:14:21 <zamez> yeah
14:14:34 <MarcWeber> And gdk?
14:14:54 <zamez> too, it's the layer under I think
14:28:01 <TuringTest> glib / gdk / pango / cairo / gtk(+) / gnome are all c.  But the style of code heavily uses a struct idiom which mimics objects.  This makes wrapping in C++ with gtkmm / gnomemm much easier or with C# / mono.  
14:29:35 <musasabi> and the Haskell wrappers feel very nice too.
14:31:03 <ihope_> > phi
14:31:04 <lambdabot>  Not in scope: `phi'
14:31:58 <ihope_> > let fib = 1 : 1 : zipWith (+) fib (tail fib) in fromInteger (fib !! 1000000) / fromInteger (fib !! 999999)
14:32:02 <lambdabot> Terminated
14:32:09 <ihope_> > let fib = 1 : 1 : zipWith (+) fib (tail fib) in fromInteger (fib !! 100000) / fromInteger (fib !! 99999)
14:32:12 <lambdabot> NaN
14:32:19 <ihope_> > let fib = 1 : 1 : zipWith (+) fib (tail fib) in fromInteger (fib !! 10000) / fromInteger (fib !! 9999)
14:32:22 <lambdabot> NaN
14:32:34 <ihope_> > let fib = 1 : 1 : zipWith (+) fib (tail fib) in fromInteger (fib !! 1000) / fromInteger (fib !! 999)
14:32:35 <lambdabot> 1.618033988749895
14:35:53 <ski> > let fib = 1 : 1 : zipWith (+) fib (tail fib); [a,b] = take 2 . drop 1476 $ fib in fromInteger b / fromInteger a
14:35:54 <lambdabot> NaN
14:35:56 <ski> > let fib = 1 : 1 : zipWith (+) fib (tail fib); [a,b] = take 2 . drop 1475 $ fib in fromInteger b / fromInteger a
14:35:57 <lambdabot> Infinity
14:36:00 <ski> > let fib = 1 : 1 : zipWith (+) fib (tail fib); [a,b] = take 2 . drop 1474 $ fib in fromInteger b / fromInteger a
14:36:01 <lambdabot> 1.618033988749895
14:50:39 <Cale> > (1/2) (1 + sqrt 5)
14:50:40 <lambdabot>  add an instance declaration for (Fractional (a -> a1))
14:50:40 <lambdabot>   In the definition of `ztq': ztq = (1 / 2) (1 + (sqrt 5))
14:50:40 <lambdabot>   In the definition of `v':
14:50:47 <Cale> > (1/2) * (1 + sqrt 5)
14:50:48 <lambdabot> 1.618033988749895
14:50:50 <sjanssen>  > let fib = 1 : 1 : zipWith (+) fib (tail fib); [a,b] = take 2 . drop 1476 $ fib in fromRational (a % b)
14:53:39 <ski> > let fib = 1 : 1 : zipWith (+) fib (tail fib); [a,b] = take 2 . drop 1476 $ fib in fromRational (a % b)
14:53:40 <lambdabot> 0.6180339887498949
14:53:47 <ski> > let fib = 1 : 1 : zipWith (+) fib (tail fib); [a,b] = take 2 . drop 1476 $ fib in fromRational (b % a)
14:53:48 <lambdabot> 1.618033988749895
14:54:15 <sjanssen> oh, right
14:54:59 <sjanssen> anyway, things work much more nicely if you the fibs in Integers as much as possible
14:58:33 <astrolabe> dons: /msg ing lambdabot doesn't seem to work
15:09:51 <iturk> i have a problem that concerns understanding this function:
15:09:57 <iturk> sumFun :: (Int -> Int) -> Int -> Int
15:10:02 <iturk> sumFun f n
15:10:06 <iturk> 	| n == 0 = f 0
15:10:10 <iturk> 	| n > 0 = sumFun f (n-1) + f n
15:10:36 <iturk> so f corresponds to the (Int->Int) part
15:10:47 <mauke> yes
15:10:56 <iturk> and n corresponds to the 3rd Int 
15:11:38 <iturk> is what i say correct ?
15:11:56 <mauke> it's the first Int I see
15:13:05 <iturk> so the first Int that is not in the parentesis is taking the n value
15:13:14 <iturk> is that what you are saying
15:14:20 <mauke> huh?
15:14:31 <mauke> sumFun takes two arguments: a function, and an int
15:14:57 <iturk> and the function is in the parentesis part right ?
15:15:07 <iturk> in the function declaration
15:15:28 <mauke> yes
15:15:39 <mauke> (Int -> Int) is the type of that function
15:16:00 <iturk> so the first Int out of the parentesis is taking the n value 
15:16:31 <iturk> that is passed to the function f also
15:19:04 <ihope_> @bot
15:19:25 <ihope_> Yay!
15:19:29 <lambdabot> :)
15:20:09 * palomer wonders about using darcs to backup his home directory 
15:21:22 <boy> palomer: not recommended
15:22:14 <palomer> why?
15:26:48 <boy> it doesn't version file permissions
15:54:11 <araujo> yay!!
15:56:09 <ihope_> @type compare
15:56:10 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
15:56:27 <metaperl> could someone help with the Haskell implementation of a least divisor function: http://sequence.complete.org/node/154
15:57:15 <ihope_> @hoogle Eq a => [a] -> [a]
15:57:16 <lambdabot> List.nub :: Eq a => [a] -> [a]
15:57:16 <lambdabot> List.delete :: Eq a => a -> [a] -> [a]
15:57:16 <lambdabot> List.(\\) :: Eq a => [a] -> [a] -> [a]
15:57:34 <ihope_> > List.nub [1,1,2,3,3,3,4,5]
15:57:35 <lambdabot> [1,2,3,4,5]
15:57:48 <ihope_> > List.nub [1,2,3,4,5,1,5,3,2,4,1,5]
15:57:49 <lambdabot> [1,2,3,4,5]
15:58:17 <ihope_> Pretty obvious name :-P
15:58:28 <metaperl> what does \\ do? I think it's list difference
15:59:25 <metaperl> anyway...
15:59:27 <metaperl> could someone help with the Haskell implementation of a least divisor function: http://sequence.complete.org/node/154
16:01:41 <ihope_> > List.delete 3 [1,1,1,2,2,2,3,3,3]
16:01:42 <lambdabot> [1,1,1,2,2,2,3,3]
16:01:57 <ihope_> So I should delete . nub
16:04:09 <ihope_> @pl \fs v -> fmap ($ v) fs
16:04:09 <lambdabot> flip (fmap . flip id)
16:14:18 <ihope_> @type Control.Monad.mplus
16:14:19 <lambdabot> forall (m :: * -> *) a.
16:14:19 <lambdabot>         (Control.Monad.MonadPlus m) =>
16:14:19 <lambdabot>         m a -> m a -> m a
16:19:54 <ihope_> newtype OrderedSet a = OrderedSet [a] deriving everything but Show -- any good way to do this?
16:24:02 <xerox> Yow!!!
16:24:40 <Korollary> yo xerox
16:25:02 <xerox> What's up?
16:25:46 <Korollary> nothin
16:26:36 <xerox> Aww, too bad.
16:26:47 <xerox> I just came back from a trip, woopee.  But no life there, eh?
16:27:24 <Korollary> nope
16:27:31 <mwc> Apparently Data.Array doesn't like arrays of 800*300 elements
16:27:35 <xerox> ...pfft.
16:27:47 <mwc> In my old and broken C++ code, I used an array of rows, malloced separately
16:27:52 <mwc> could I do something like that in haskell?
16:28:12 <mwc> Array (Int,Int) (Array (Int,Int) Double)
16:28:14 <mwc> maybe?
16:28:21 <mwc> any reason to think that would work better?
16:28:30 <xerox> Array (Int,Int,Int,Int) Double ?
16:28:32 <mwc> er, Array Int (Array Int Double)) I meant
16:28:48 <mwc> Yeah, I was thinking of the range tuple when I shouldn't have been
16:28:53 <xerox> Array (Int,Int) Double ?
16:28:57 <mwc> yeah
16:28:57 <xerox> Oh-kay.
16:29:07 <mwc> I have a 2D array that's causing stack overflows
16:29:55 <Blicero> you sure its the array and not an algorithm you're using?
16:30:02 <mwc> I had some C++ code where I would handle large lattices like this as an array of pointers, each pointing to an array
16:30:30 <mwc> Yeah, I'm asking it to calculate a trivial value for each point, and then outputting the maximum value
16:30:43 <mwc> main = putStrLn $ show $ maximum $ map snd $ assocs $ progEffect [((400,400),pi/4,3600)]
16:31:35 <mwc> unless there's some voodoo in that line that I'm unware of
16:32:44 <mwc> progEffect is using an accum array, each node in the list it's passed has an effect on each point
16:33:54 <mwc> progEffect prog = accumArray (+) 0 ((0,0),(800,800)) $ concat $ map itemEffect prog
16:33:58 <mwc> I have concerns about concat
16:35:19 <mwc> Blicero, say anything problematic in there?
16:37:11 <Blicero> i think accumArray is not tail-recursive
16:37:24 <mwc> Hmmm
16:37:50 <mwc> Maybe I'll try constructing different arrays for each source and summing elements from them
16:38:15 <Blicero> oh no it is
16:39:25 <mwc> Maybe I should try building the values in STArray
16:43:38 <iturk> i am trying to understand the curried functions approach:
16:43:54 <iturk> powerc : : Int ?> Float ?> Float
16:44:26 <dons> ?uptime
16:44:27 <iturk> powerc n a = i f n==0 then 1 . 0 else a *  powerc ( n?1) a
16:44:27 <lambdabot> uptime: 16 hours, 19 minutes and 25 seconds
16:44:41 <iturk> sqr : : Float ?> Float
16:44:51 <iturk> sqr = powerc 2
16:44:59 <Philippa> iturk: you're not pasting valid haskell code...
16:45:10 <Philippa> you mean sqr :: Float -> Float, right?
16:45:27 <iturk> n its a Int
16:45:34 <iturk> not float
16:45:40 <xerox> Oi there :-)
16:45:42 <Philippa> aaanyway, powerc :: Int -> (Float -> Float) - that means it takes an integer and returns a function when you apply it
16:45:53 <Philippa> when you apply /that/ function, then you get all the stuff after the =
16:46:15 <iturk> 'n' and 'a' are both values
16:46:40 <Philippa> it can also be written powerc = \n -> (\a -> if n==0 then 1.0 else a * powerc (n-1) a)
16:47:08 <Philippa> depends where you're looking. On the LHS, they're formal parameters
16:47:18 <Philippa> the version I just showed you shows the returned function more explicitly...
16:47:26 <iturk> but the way that i am writing is correct i think
16:47:37 <Philippa> \x -> e is a function that takes a parameter x and returns the expression e...
16:48:15 <iturk> powerc n a = if n==0 then 1.0 else a *  powerc ( n?1) a
16:48:24 <iturk> this is the more correct one
16:48:43 <Philippa> yeah. Though I think we may have a character encoding problem? I see a question mark where you have a minus
16:49:31 <dons> me too.
16:49:53 <iturk> so in the minus you are seeing a question mark
16:50:02 <iturk> powerc n a = if n==0 then 1.0 else a *  powerc (n-1) a
16:50:06 <iturk> no its better
16:50:28 <iturk> now i mean
16:50:38 <Philippa> yes. You're using a character encoding not compatible with ASCII, which is generally not too hot on IRC as ASCII's about the only part of the charset you can expect someone else to have in common with you
16:51:08 <iturk> so i will format this better the point is that i has taking this directly from pdf
16:51:15 <Philippa> (yes, I know, it's horrible and imperialist and I'm lucky I speak english natively - the bastards still don't have my currency sign :-)
16:51:16 <iturk> that is certanly the problem
16:52:18 <Philippa> I believe most haskell implementations have the same encoding issue btw
16:52:37 <Philippa> though I could be wrong depending on how your chosen implementation was built. Anyway, back to currying?
16:52:42 <Philippa> Or did my quickie explanation suffice?
16:55:06 <iturk> ok i will pass everything now ok:
16:55:13 <iturk> powerc :: Int -> Float -> Float
16:55:20 <iturk> powerc n a = if n==0 then 1.0 else a * powerc (n-1) a
16:55:26 <iturk> sqr :: Float -> Float
16:55:30 <iturk> sqr = powerc 2
16:55:36 <mwc> Hahaha, I'm reading the Lazy Functional State Threads Paper from 1993
16:55:49 <mwc> it's kind of strange reading about ST before the time Monad
16:55:53 <iturk> ok the point is in sqr
16:56:09 <Philippa> iturk: yes?
16:56:11 <iturk> i just calling powerc with 1 parameter
16:56:19 <Philippa> all functions in haskell have exactly one parameter
16:56:25 <Philippa> to spell this out clearly for you:
16:56:26 <iturk> where powerc is defined for 2
16:56:32 <Philippa> powerc :: Int -> (Float -> Float)
16:56:47 <Philippa> (that's the same as the type you wrote by convention)
16:57:06 <Philippa> so when you apply powerc to 2, what do you get back?
16:57:12 <Philippa> or rather, what's the type of what you get back?
16:59:00 <iturk> i get a float
16:59:09 <Philippa> no, you don't
16:59:11 <Philippa> try again?
16:59:19 <Philippa> the parentheses mean the same as they usually do
16:59:24 <iturk> sqr 3
16:59:26 <iturk> 9.0
17:00:03 <Philippa> (you're getting floats because you wrote 1.0 which is a float literal btw)
17:00:21 <Philippa> but, what is the type of powerc 2, given that powerc :: Int -> (Float -> Float)?
17:00:27 <iturk> if n==0 then 1.0 you mean here
17:00:33 <Philippa> yes
17:00:51 <iturk> 2 is passed has a Int
17:00:57 <Philippa> yes
17:01:02 <Philippa> but you don't multiply by 2
17:01:21 <Philippa> it could be a different kind of number from the one you're taking a power of
17:01:46 <Philippa> (and in fact it is)
17:02:09 <iturk> i am not getting what value does 'a' takes
17:02:11 <Philippa> are you worried about currying, the mixing of Int and Float or both?
17:02:54 <monochrom> > let {powerc n a = if n==0 then 1.0 else a * powerc (n-1) a} in powerc 2 1.414
17:02:55 <lambdabot> 1.9993959999999997
17:02:56 <Philippa> your function is equivalent to powerc = \n -> (\a -> if n==0 then 1.0 else a * powerc (n-1) a) - a is an ordinary parameter, just not to the function you think it is
17:03:00 <monochrom> It works fine.
17:03:32 <Philippa> again, if powerc :: Int -> (Float -> Float), what is the type of powerc 2?
17:03:44 <Philippa> if you want to understand, you need to try to answer my question
17:03:48 <xerox> Have a joyous weekend.  Goodnight!
17:03:55 <Philippa> xerox: seeya
17:04:46 <iturk> hmmm
17:05:25 <Philippa> hint: all functions have one parameter, and a -> b is a function that takes an a and returns b
17:05:42 <monochrom> Is cheating encouraged?  By that I mean asking ghci ":type powerc 2" :)
17:05:53 <iturk> so (Float -> Float) is the return value
17:06:07 <Philippa> iturk: yes (OK, the type of the return value, but hey)
17:06:18 <Philippa> so, what's the type of powerc 2 1.0?
17:06:34 <Philippa> hint: powerc 2 1.0 = (powerc 2) 1.0
17:06:34 <iturk> so i am sending a Int and a Float
17:06:44 <iturk> and expecting to get a Float
17:06:59 <Philippa> yes. But you're sending them one after the other, not both at once
17:07:37 <iturk> so its like if the function only computes with half of the parameters
17:08:35 <iturk> monochrom: powerc 2 :: Float -> Float
17:09:46 <monochrom> Shameless plug: http://www.cs.utoronto.ca/~trebla/fp/
17:10:12 <Philippa> iturk: sort of. Really, the function always returns a function
17:10:20 <Philippa> (but the compiler may well implement it differently)
17:11:31 <dons> monochrom cool!
17:11:44 <dons> monochrom, your notes?
17:11:55 <monochrom> Yes, I wrote it.
17:12:22 <monochrom> I taught it to a few of my friends.  They didn't hate it.
17:13:03 <Philippa> monochrom: Cool. There's a girl likely moving in with me soon who wants to learn
17:13:25 <Philippa> still haven't decided how I'm going to teach her beyond starting off with a hands-on session with ghci
17:14:04 <monochrom> I also did http://www.cs.utoronto.ca/~trebla/javacourse/ .  My friends are more interested in this one because I taught it to them right at the time when Java began to emerge at work.
17:15:31 <mwc> Hmmm, monochrom is a South Western Ontario Haskeller too
17:15:32 <dons> cool. I'll add it to the Haskell wiki? is that ok?/
17:15:41 <mwc> Cale, monochrom, and I, who else?
17:15:45 <boy> dons: hello!
17:15:56 <dons> hey jips/boy
17:16:01 <dons> I see no patch yet?
17:16:06 <dons> did it make it off your box?
17:16:16 <boy> dons: i did darcs send more then 36 hours ago
17:16:20 <dons> if not, do a darcs send -o /tmp/f.patch ; then mail me /tmp/f.patch
17:16:30 <monochrom> I don't think I'm south western.  I'm in Toronto.
17:16:34 <dons> ok. so maybe youur sendmail isn't configured?
17:16:42 <boy> dons: quite likely
17:17:04 <dons> the -o flag to darcs send is your friend, then
17:17:10 <monochrom> dons: Mine?  Yes that's ok.
17:18:01 <boy> dons: what's the -o flag do?
17:18:19 <Philippa> "offline". Saves it as a file you can manually attach
17:18:22 <dons> dumps the patch to a file
17:18:33 <dons> you think `offline' Philippa?
17:18:54 <dons> i always  mentally thought: 'out'
17:19:03 <dons> dump out to /tmp/f.patch
17:19:25 <Philippa> I did this time. I probably thought out previously. It's late, I'm tired and I've not used the option in a while :-)
17:19:42 <dons> ok :}
17:20:07 <ndm> on windows, send rarely works
17:20:11 <Philippa> hey, wipe the drool off your chin! :-)
17:20:18 <ndm> so -o is about hte only way to get it working...
17:20:32 <Philippa> worse than that, if you're unlucky you discover you'd left OE configured to do something silly and it tries it
17:22:18 <ndm> yep, thats exactly what happens
17:22:24 <ndm> although most people have OE half configured
17:22:29 <ndm> which makes it just moreconfused...
17:23:13 <dons> well you know the solution to your windows problems , ndm ... :P
17:23:29 <ndm> dons, yep, patch darcs to do something sensible
17:23:57 <dons> yes!
17:24:58 <dons> Some stuff on the 'Learning Haskell' pages are very very old :(
17:25:57 <monochrom> My notes are also old. But they stand the test of time. :)
17:25:58 <dons> "We also give an example of the use of constructor classes which feature in Haskell 1.3 and Gofer"
17:26:18 <dons> ooh! constructor classes! Gofer!
17:26:23 <dons> let's revive Gofer!
17:26:27 <dons> it would be cool.
17:26:34 <monochrom> What is constructor class?
17:26:36 * dons imagines a Gofer plugin for lambdabot ...
17:26:39 <dons> a type class :)
17:26:41 <Philippa> yeah, I only even know what that means because I did a lot of background reading on type classes & checking
17:26:54 <Philippa> specifically, one for a type whose kind isn't *
17:27:06 <Philippa> (IOW, for a type constructor rather than a type)
17:27:09 <dons> www.cse.unsw.edu.au/~dons/cc.prelude
17:27:11 <Philippa> Monad's an example
17:27:39 <iturk> Philippa: thanks i get the point the value passing to sqr is getting inside powerc has the secund parameter
17:28:00 <Philippa> iturk: yep
17:28:53 <dons> hmm. we could add a Gofer pllugin to lambdabot. no evil unsafeCoerce#  to mess all the safety up
17:33:30 <dons> would be kinda fun for historical games
17:47:04 <dons> hmm. one of the links on the Learning Haskell page is from 1993
17:47:22 <dons> I'm not sure that is stil ok.
17:47:49 <dons> depends on how many Haskell B interpreters we have..
17:52:28 <dons> hehe. "Haskell for Miranda Programmers". WE noow would need Miranda for haskell programmers..
17:56:05 <monochrom> Is there also a "Haskell layout on punch cards How-To"?  XD
17:59:55 <dons> hehe
18:00:20 <dons> Haskell for Abacus users
18:00:32 <dons> sorely missing from the canon of Hhaskell documents
18:01:31 <araujo> dons, hiya!!!
18:01:47 <ihope_> dons: is lambdabot identified to NickServ?
18:01:56 <dons> hey araujo.
18:02:00 <dons> hmm
18:02:02 <dons> let me see
18:02:09 <araujo> :-)
18:02:14 <araujo> How that goes dons ?
18:02:30 <dons> should be now, ihope_
18:02:32 <dons> looks like it wasn't
18:02:37 <dons> good good araujo.
18:03:01 <dons> msging works now ihope_ ? 
18:03:26 <ihope_> Well, I set the option thingy to allow private messages from non-identified guys.
18:03:41 <ihope_> Just make sure it's always identified.
18:03:44 * ihope_ goes to bed
18:04:02 <dons> sure.
18:04:37 * araujo back online after a few weeks 
18:30:21 <dons> ?b52s
18:30:22 <lambdabot> You belong in Ripley's Believe It Or Not
18:31:23 <Lemmih> ?help b52s
18:31:24 <lambdabot> b52s. Anyone noticed the b52s sound a lot like zippy?
18:31:45 <dons> :}
18:32:36 <Korollary> @b52s $ $vixen
18:32:36 <lambdabot> Girl from Ipanema, she goes to Greenland
18:32:47 <dons> nah. have to use . I think 
18:32:53 <dons> ?. vixen b52s
18:32:54 <lambdabot> Have you ever killed a hobo?  Ive found eating their liver gives me strength.  I think i may just be short on b vitamines.
18:33:13 <dons> well that was not entirely unexpected
18:33:14 <Lemmih> oh my
18:34:01 <Korollary> Lemmih: It turns out it's possible to turn symbols to quoted symbols with cpp.
18:34:36 <Lemmih> Korollary: How?
18:36:57 <Korollary> I was reading this: http://okmij.org/ftp/c++-digest/computable-include.txt
18:37:33 <Korollary> apparently I was not familiar with all the operators of the cpp: http://gcc.gnu.org/onlinedocs/cpp/Tokenization.html#Tokenization
18:39:36 * Lemmih takes off to exercise.
18:40:10 <dons> exercise!
18:40:23 <Korollary> I'm back from the exercise bike.
18:40:45 <Korollary> I dont think anybody else reads TAPL on that thing
18:41:08 <dons> "Exercise for Haskell programmers" Lesson 1) pick up TaPL
18:41:36 <Korollary> You can get lost in Oleg's site, tho
18:41:55 <dons> Lesson 2. compile ghc. jog into the to city and back before it finishes compiling.
18:42:47 * araujo happy with Haskell on his compiler course
18:43:18 <dons> :)0
18:43:24 <ihope> Okay, the going to bed was a bit of a lie.
18:43:32 <Korollary> @localtime ihope
18:43:34 <lambdabot> Local time for ihope is Saturday, April 01, 2006 9:43:05 PM
18:43:40 <Korollary> geez grandpa
18:44:07 <ihope> I think you're on the wrong side of the norm :-)
18:44:16 <ihope> Anyway...
18:44:39 <dons> hmm. where does that mean ihope is? ah. east coast usa
18:44:46 <Korollary> or canada
18:44:48 <dons> I think I knew that already
18:44:56 <dons> or canada. or hmm. argentina?
18:45:03 <ihope> Argentina?
18:45:16 <Korollary> I dont think there are any south american cities in that timezone.
18:45:25 <dons> ah. ok.
18:45:44 <ihope> If an instance declaration references some class value (e.g. readsPrec referring to readsPrec), does that mean the value you're defining right now, or that value "in general"?
18:46:24 <ihope> And how do I get the other one?
18:46:52 <ihope> Hmm, wait a minute...
18:47:10 <dons> it's recursive. but depends on the type you're dispatching on, right?
18:47:15 * ihope assumes the type system will DWIM
18:47:31 <dons> yeah it will. as long as it isn't f :: String = f :: String ...
18:47:38 <dons> which would loop.
18:47:38 <ihope> :-)
18:47:46 <ihope> Okay, thanks.
18:47:46 <dons> but f :: a = ... f :: b ... is fine
18:47:46 <Korollary> it will infer the other one from the definition you're currently making
18:48:00 <dons> yikes!
18:48:04 <araujo> haha
18:48:58 <dons> I remembe rduring icfp 2005 contest i wrote some instance for the fgl graph lib where f 0 = f 0 ... and it was recursive
18:49:04 <dons> that took an hour or two to track down
18:49:06 <dons> bad dones.
18:49:07 <dons> dones
18:49:10 <Korollary> dons
18:49:12 <dons> hmm. dons
18:49:23 <dons> spinal memory
18:49:37 <araujo> Im finally understading the advantage of a language where specification is practically the same than implementation.
18:50:04 <Korollary> I'm not understanding what you just said.
18:50:48 * araujo wonders if it's what he said
18:50:54 <Korollary> yes
18:50:55 <dons> spec lang == implementationn lang. == no prototype.
18:51:06 <dons> and an implementation that just works
18:51:09 <dons> yeah?
18:51:15 <Korollary> as opposed to UML & Java?
18:51:37 <Korollary> I dont know many spec languages in heavy use.
18:52:11 <dons> ?quote mwc
18:52:11 <lambdabot>  I actually got away with running Haskell through a TeX pretty printer and handing it in as pseudocode
18:52:37 <blackdog> is there an idiomatic way of parsing comma separated values? it seems overkill to fire up parsec...
18:52:40 <Korollary> very appropriate quote
18:52:41 <dons> or more, that the pseudocode actually runs
18:52:43 <dons> blackdog!
18:52:47 <blackdog> hey don 
18:52:54 <dons> don't we have a CSV lib?
18:52:55 <dons> hmm
18:52:55 <blackdog> the prodigal son returneth
18:53:00 <Korollary> blackdog: There's a split function in MissingH
18:53:08 <araujo> mmm.. well, let me see how i put this....
18:53:36 <dons> yeah, also here: http://www.cse.unsw.edu.au/~dons/code/h4sh/H4SH/List.hs
18:53:45 <dons> so split on "," or use a regex?
18:53:51 <Cale> properly parsing CSV isn't as easy as splitting on ,
18:54:02 <dons> though I reckon someone must have written a csv module
18:54:09 <blackdog> where is split? (i don't need real csv...)
18:54:23 <Korollary> @google MissingH
18:54:24 <lambdabot> http://quux.org/devel/missingh
18:54:42 <dons> and above (a single module -- less deps)
18:54:47 <Cale> It's an easy enough list function to write :)
18:54:51 <dons> yup
18:55:08 <dons> ?csv module Haskell
18:55:14 <dons> ?google csv module Haskell
18:55:15 <lambdabot> http://www.xoltar.org/2002/oct/17/haskellCSV.html
18:55:41 <araujo> Korollary, it looks like most of the people need to think about two different ways to get things done in the course. One for the theory and other for the code they will be writting. 
18:55:44 <Korollary> ?poleposition in 30 mins
18:55:45 <lambdabot> Unknown command, try @list
18:56:01 <dons> Korollary, cheers.
18:56:14 <blackdog> yeah, i know. i'm trying to show off how l33t haskell is, though - am applying for a java job, and i want to put a concise solution in haskell in the header as a not-so-subtle "nya nyah"
18:56:24 <dons> hehe
18:56:38 <blackdog> so having to write basic stuff like that looks pretty lame
18:56:39 <araujo> Korollary, with Haskell for example, ive been able to take my professor exercises solved and implmented in code in just secs!!
18:56:41 <Korollary> blackdog: I wouldn't do that if it's not going to be understood.
18:56:44 <dons> yeah. split should be in the standard list lib
18:57:06 <dons> we even got to the point on the libraries list that it was going in. then nothing happenend
18:57:35 <blackdog> i'm not going to deliberately obfuscate it, but i'm buggered if i'm going to write ten pages of OO-Approved java fluff without at least a subtle dig.
18:57:53 <araujo> Korollary, I practically haven't needed to change/add any extra tweaking for writting the code.
18:58:02 <Korollary> blackdog: The best revenge is living well. Err. Yeah.
18:58:11 <araujo> That's what i wanted to say with spec==imple
18:58:36 <dons> good luck blackdog.
18:58:55 <Korollary> I'd get the job first, and then bitch about java. heh.
18:58:57 <blackdog> no, no - crushing the skulls of your enemies and hearing the lamentations of their women is the best revenge.
18:59:16 <dons> true.
18:59:17 <blackdog> if it's the sort of place that would take it badly, I don't want the job.
18:59:51 <dons> this whole commerical programming stuff scares me
19:00:03 * dons scurries back into open source academia
19:00:05 <Korollary> lol. nice term.
19:00:57 <blackdog> it's a bit lame. these guys are meant to be very very leet, and the first programming problem i was given wouldn't stump a first year student.
19:01:57 <Korollary> In that case there's almost no point in jabs with haskell. Will be totally wasted on them.
19:02:49 <dons> you're always so pragmatic Korollary ;)
19:03:28 <Korollary> I got grilled by very good people in several interviews. Not many of them knew or cared about FP.
19:03:35 <dons> remember, blackdog is the guy who tried to subvert the C,C++,Java ACM contest by compiling his Haskell into C and submitting that...
19:03:41 <Korollary> heh
19:03:43 <blackdog> maybe. but the people who set the test aren't the ones who talk about it in the interview afterwards - might get some cred from a neat solution, y'know? and the third problem isn't so bad - you need lazy streams to do it right.
19:03:52 <blackdog> good times.
19:03:57 <blackdog> good, good times.
19:04:01 <dons> which worked for a while. until they asked him to explain the code. and they even said you could use preprocessors!
19:04:08 <Korollary> lol
19:04:09 <dons> ?karma+ blackdog
19:04:09 <lambdabot> blackdog's karma raised to 3.
19:04:14 <Korollary> oh man
19:04:15 <blackdog> they only caught me because i finished so fast.
19:04:22 <Korollary> explain the C spewed by ghc heh
19:04:37 <araujo> blackdog, haha
19:04:56 <blackdog> the output of lex and yacc isn't so understandable, either.
19:05:24 <dons> the rules were clearly unfair.
19:05:28 <Korollary> no, but I think GHC's output is a bit more "alien".
19:05:43 <blackdog> we come in peace
19:05:56 <Korollary> take us to your reader.
19:05:58 <blackdog> give us your mutable references and no-one gets hurt
19:06:06 <blackdog> damn, yours is better
19:06:11 <dons> we have come to share with you the secrets of the universe. our advanced technology will improve your lives
19:06:15 <monochrom> I am going to the ACM contest finals.  Will I see blackdog there?
19:06:24 <blackdog> hell no.
19:06:32 <monochrom> Darn.
19:06:40 <blackdog> no longer eligible, i think. it's for students, right?
19:06:47 <monochrom> Yes.
19:06:53 <dons> they're missing out on a lot of great programmers by not allowing a lanugage free-for-all
19:06:56 <araujo> They should allow Haskell on that contest
19:06:57 <dons> icfp-style
19:07:20 <araujo> So that way it can discriminate hackers there too
19:07:37 <dons> it's great each year to watch the C, C++ and Java entries make up 60 70% of the icfp entries, but to be the first ones wiped out by corner cases
19:07:39 <Korollary> is it only c/c++/java?
19:07:44 <araujo> yes
19:07:51 <dons> induction isn't a strong point in those languaages
19:07:54 <araujo> And Visualcrappy i think
19:08:02 <Korollary> I bet that has driven Schemers nuts for decades.
19:08:24 <monochrom> No, no visualwhatever.
19:08:26 * boy is curious to see that dons enjoys witnessing the failures of others :)
19:08:37 <araujo> monochrom, yeah, got confused with other contest
19:08:53 <araujo> Oh, and pascal right?
19:09:08 <monochrom> Pascal is still in but phasing out.
19:09:29 <araujo> really?, ive heard that a lot of people still use pascal
19:09:32 * Korollary shoots Pascal
19:09:52 <monochrom> Every year they say "we probably won't support Pascal next year".
19:09:55 <dons> boy, it makes me feel I haven't wasted my last 8 years at university chasing a dead end
19:09:58 <araujo> hah
19:10:04 <monochrom> By induction it will probably take a few more years.
19:10:27 <araujo> monochrom, but there are still a good amount of folks using it?
19:10:45 <monochrom> I don't know.
19:10:47 <Korollary> What's the most prominent app/os/etc. written in pascal?
19:10:49 <araujo> if it is so, i doubt it'll dissapear soon
19:10:54 <boy> dons: i wouldn't say that c++ is a dead end. in fact, haskell is probably more of a dead end, in terms of money-making :P
19:10:59 <araujo> Korollary, an OS?
19:11:04 <Korollary> whatever
19:11:16 <dons> well, we can but hope. there are more and more commerical apps each year.
19:11:16 <Korollary> I dont know of anything written in pascall
19:11:19 <araujo> i think there is a pascal os
19:11:21 <dons> I mean, like 2 more each year
19:11:23 <monochrom> Much Apple Mac stuff was written in Pascal.  The OSes preferred API binding was for Pascal.
19:11:25 <dons> but that's still trending upwards!
19:11:30 <blackdog> if you know C++, you just know C++. you can take haskell skillz anywhere
19:11:31 <araujo> the question is if anybody actually uses it :-)
19:11:37 <monochrom> s/OSes/OS's/
19:11:51 <araujo> the question is if anybody actually use (a pascal application) :-)
19:11:52 <Korollary> monochrom: Nowadays it's objective c for macs right?
19:12:02 <blackdog> current flavour of month, yes
19:12:21 <monochrom> I don't know nowadays.
19:12:24 * araujo got one project this semester that he wants to code in Haskell
19:12:36 <araujo> let's see if we can take FP into the bussiness world :-)
19:12:49 <Korollary> FP has been in the business world.
19:13:02 <boy> i'd much rather see FP taken into the "FOSS" world :)
19:13:10 <dons> blackdog, you know Gabi is working at Credit Suisse this year? and lennart too.
19:13:12 <araujo> boy, it's already there!!!
19:13:16 <Korollary> It's been in the FOSS world too
19:13:34 <blackdog> yeah, i heard
19:13:36 <araujo> Korollary, i saddly don't see too much FP in bussiness
19:13:48 <araujo> im willing to explore that area too
19:13:50 <boy> araujo: not enough, we need some serious desktop or server software bundles that can really compete with the linux shit :)
19:14:00 <blackdog> ... uh?
19:14:08 <araujo> boy, well, help me with my Haskell OS :-]
19:14:30 <boy> araujo: tell me how
19:14:56 <araujo> boy, well, i am just slowly writting applications to do my daily work in Haskell
19:14:59 <araujo> mainly for fun
19:15:11 <Korollary> I didnt say FP was popular.
19:15:43 <dons> and sethk has written , what, 9 commerical apps this year in Haskell?
19:15:45 <dons> something like that.
19:15:53 <araujo> dons, cool
19:16:01 <araujo> what kind of appli?
19:16:05 <dons> automation and control stuff, I thikn.
19:16:23 <blackdog> honestly, i'm not sure why you guys are so evangelical. what's wrong with having a secret weapon? :)
19:16:25 <boy> araujo: my dream is, for fun, to have a complete suite of haskell-based applications for basic desktop usage: word processor, text editor, web browser, and more
19:16:32 <araujo> im looking for bussiness administration stuff
19:16:43 <araujo> shapr gave me some ideas a while back
19:16:52 <dons> blackdog. so we can get jobs as the language gurus? 
19:16:58 <Korollary> Well, there's yi for text editing heh
19:17:09 <dons> have a look at
19:17:11 <araujo> yeah, it'd be cool to get some $$ too 
19:17:14 <dons> ?wiki Libraries_and_tools
19:17:15 <lambdabot> http://www.haskell.org/haskellwiki/Libraries_and_tools
19:17:25 <dons> there's a couple of hundred apps there just from the last year or so
19:17:31 <araujo> boy, yes, that's what im talking about
19:17:44 <blackdog> who gets jobs as language gurus anyway? even for popular languages? Much better to build a cool program, start up a company, and move to your own island when you go public :)
19:17:52 <araujo> boy, that'd be something very ambitious too, but i think Haskell is pretty much ready for it.
19:18:01 <Korollary> Nowadays people think of Ajax based word-processors, which is much more unlikely than a word processor in haskell.
19:18:12 <Smokey`> blackdog: I hear that. :P
19:18:22 <dons> blackdog, let's do it!
19:18:24 <dons> now. what's a cool program
19:18:25 <dons> hmm
19:18:36 <dons> oh, the world domination monad
19:18:41 <dons> that should prove useful
19:18:43 <blackdog> dons: first, you can't open-source it _right_ away, ok?
19:19:01 <monochrom> It is now the world domination arrow.
19:19:05 <dons> ah, ok.
19:19:27 <monochrom> And for concurrent world domination, the world domination transaction.
19:19:46 <dons> lockfree world domination
19:19:47 <araujo> boy, ive been thinking to start coding stuff that i use in a daily basis on Haskell, like irc client (yay, i'd like to see one written in Haskell), email client, a few other appli....
19:19:49 <blackdog> i think ajax word processors have a niche, though. they don't have to be better than word because they're more available than word - they're not competing on the same terrain.
19:19:56 <boy> araujo: i agree that haskell can be used to make applications that replicate the functionality of current web browsers and spreadsheat programs. but my ultimate dream goal is to come up with a totally new design for a computer desktop, with new gui, security, and user concepts that differ radically then the traditional unix way
19:20:03 <araujo> and in a long term, i wouldn't mind to see a whole desktop too :-]
19:20:05 <dons> araujo, we already have 2 irc clients in haskell, or 3?
19:20:12 <dons> ginus, hircules
19:20:15 <dons> ginsu
19:20:18 <araujo> And in a very long long term, a whole OS (hey, we've got House)
19:20:19 <dons> and who else was writing one?
19:20:28 <araujo> dons, didn't know!
19:20:34 <araujo> dons, link?
19:20:52 <dons> ?wiki Libraries_and_tools/Network
19:20:52 <lambdabot> http://www.haskell.org/haskellwiki/Libraries_and_tools/Network
19:21:28 <boy> araujo: i've been thinking about doing a web browser, using a pure haskell html+css renderer
19:21:42 <araujo> boy, well, that could involve a fairly good and interesting amount of work in PFP GUI 
19:21:44 <dons> that page is a bit empty. there''s heaps more stuff, but I'm yet to go back through the haskell@ archives to find all the projects
19:22:58 <blackdog> what's the goal of these projects, though? Are you just trying to feel fuzzy and pure? Why is haskell going to be a better way of doing it, and even if it is, can you compete effectively with the amount of testing and tweaking and usability hacking that's gone into the standard apps?
19:23:21 <araujo> boy, that'd be cool, you know, im currently using the mozilla embedded library with Haskell to add a web option to an application im writting.
19:23:30 <blackdog> you should be focused on doing something new and cool, and not in getting dogmatic about tools.
19:23:34 <blackdog> my 2c, anyway.
19:23:38 <boy> araujo: well, i think the hard part is the actual rendering. in terms of the gui, i am thinking of using gtk2hs, since it seems to be the best option. but ideally a pure fp haskell gui toolkit project would be created
19:24:01 <araujo> blackdog, i'd say, because it'd be fun :-) 
19:24:11 <dons> I think most effort is going into doing stuff that's new and cool. smp, concurrency and more type safety
19:24:37 <dons> if more effort went into tools ,we'd have a cpan/hackage by now :}
19:24:49 <blackdog> app development isn't fun. coming up with is fun, the initial prototype is fun. polishing and sorting through feature requests and explaining it to newbies: not so much fun.
19:24:50 <araujo> haha
19:25:10 * blackdog is a grumpy old man
19:25:15 <dons> very ;)
19:25:18 <araujo> blackdog, we'll write a plugin for lambdabot to do the later :-]
19:25:23 * blackdog just needs a biscuit and a nap
19:25:46 <monochrom> But to change the world you need a high profile application, one that everyone uses and knows about.
19:26:15 <boy> well, i personally really would like a lightweight alternative browser to firefox
19:26:28 <boy> and i think that haskell is the best way to create it
19:26:36 <blackdog> Really? Do you know about the languages used in Google? Do people care, in general?
19:26:52 <araujo> monochrom, such as?
19:27:21 <Smokey`> if I ever end up developing purely in haskell, I'm going to be focusing my efforts on mathematical (primarily geometry & linear algebra) libs, and graphical libs (window management, GUI, and HW accelerated rendering)
19:27:28 <araujo> I think that the way to go is getting programms and tools that you use in a daily base
19:29:13 <blackdog> hey, can you put literal newlines in a haskell string? or do you have to encode everything? I want here documents, i guess...
19:29:17 <dons> Smokey`, wow. a couple of weeks ago you were very unsure. :)
19:29:28 <dons> blackdog? linegaps
19:29:34 <Smokey`> dons: I still am, note the first word in my statement.  'if'
19:30:22 <dons> blackdog, here: http://www.cse.unsw.edu.au/~dons/code/lambdabot/Plugin/DrHylo.hs
19:31:54 <dons> or you mean literals as in 'invisible'
19:32:11 <dons> no, in that case.
19:32:43 <Smokey`> dons: So far my believe if Haskell and C/C++, atleast for my development purposes, should go side-by-side.   However most performance-critical things would be implemented in C/C++, and imported into Haskell.
19:32:56 <Smokey`> I'm still not entirely sure though :)
19:33:22 <dons> yep. that's what i'd do too
19:33:47 <boy> i've been thinking about using haskell as sort of a "scripting language" for a c++ game engine
19:33:51 <Smokey`> dons: only problem with that, is the fact that most things would be impemented in C++ :P   and just imported into haskell.  essentially i'm just making bindings to my C++ libs for Haskell.
19:33:55 <Korollary> I'd probably want to replace c++ with ml/ocaml
19:34:05 <Smokey`> i get carried away with optimizing 'everything' eventually :P
19:34:39 <Smokey`> boy: a functional language, for game logic?  ehh... game logic is rather 'imperatively based' imo.
19:34:55 <dons> use the Hsakell for all the safe logic stuff. and performance critical stuff unload to C
19:35:36 <dons> game logic? very haskelly. check you Frag
19:35:38 <araujo> nah, imperative lanhguages are overrated
19:35:46 <dons> lots of lovely 'language' feature for the game logic
19:35:54 <boy> Smokey`: i've been thinking of a design for a yampa-based visual scripting language
19:36:29 <Smokey`> game logic, in my 2 and a half years of experience (Done a diploma in game development, + 6months professional),  alot of 'if this' 'else this'  'but in this case do this instead' 'or this case, do this'
19:36:33 <dons> and if it is really imperative/sequential in nature, you use a monad
19:37:00 <dons> Smokey', that's not imperative.
19:37:03 <dons> use guards...
19:37:23 <monochrom> unless "this" "that" reads and writes to state variables
19:37:45 <dons> the imperative stuff would be actions that require mutating state. everything else remains pure 
19:38:06 <dons> the mutating you do in a monad which gives you a sequencing guarantee
19:38:07 <boy> Smokey`: i've done lots of tests on paper, and i think it could work really well. there are still a few problems though, things like random values requiring explicit threading of a generator through complex graph structures :\
19:38:27 <dons> boy, have you seen Frag, the 3d game on top of Yampa?
19:38:31 <boy> dons: yep
19:38:37 <dons> it could do with a scripting edsl
19:39:02 <dons> to quickly code up and combine game elements
19:39:18 <Smokey`> i dunno, personally given my experience with game dev,  if i were ot use haskell i'd almost always be making functions purely with the 'do' statement.
19:39:40 <monochrom> Even then that's still fine.
19:39:42 <dons> that may be. yi is very monadic -- mutating editor buffers.
19:40:01 <dons> as spj says, Haskell is the world's finest [safest] imperative language
19:40:06 <monochrom> Our last resort is a quote from Simon Peyton Jones: Haskell is the finest imperative language. XD
19:40:26 <boy> Smokey`: i don't know how much experience with haskell you have, but you can do some really cool DSL shit with haskell, yampa is a really cool example of pure fp game dev
19:40:37 <Smokey`> boy: not alot, at all.
19:40:40 <dons> you get all the type checking, and ways to separate different sequenciig and state into separate monads. nothing approaches that in a non-monadic language
19:40:43 <Smokey`> that's why i'm very doubtful :)
19:47:00 <araujo> Smokey`, why?
19:47:12 <Smokey`> araujo: because I dont know enough about the language. :)
19:47:38 <araujo> ooh, that might a be a good reason then :-]
19:49:19 <araujo> Smokey`, but luckyly, that's also something easy to solve :-]
19:49:57 <araujo> haskell.org got pretty much what anybody new to haskell needs.
19:50:39 <Smokey`> aye.
19:51:01 <Smokey`> is there any way to convert from Int to Float ?
19:51:21 <monochrom> > fromIntegral 1 + 2.0
19:51:21 <lambdabot> 3.0
19:51:41 <Lemmih> > 1 + 2.0
19:51:42 <lambdabot> 3.0
19:51:59 <blackdog> wait, so lambdabot just treats the channel as a literate doc? Cool.
19:52:04 <monochrom> > fromIntegral x + 2.0 where {x :: Int; x = 1}
19:52:04 <lambdabot> 3.0
19:52:25 <blackdog> > accidental angle bracket
19:52:26 <lambdabot>  Not in scope: `bracket'
19:52:27 <monochrom> lambdabot does more than that, but yes.
19:52:39 <monochrom> @hoogle fromIntegral
19:52:40 <lambdabot> Prelude.fromIntegral :: (Integral a, Num b) => a -> b
19:52:47 <monochrom> That's another thing lambdabot does.
19:52:50 <dons> ?hoogle Int -> Float
19:52:51 <lambdabot> No matches, try a more general search
19:53:07 <dons> > fromIntegral (1::Int) :: Float
19:53:08 <lambdabot> 1.0
19:53:12 <blackdog> oh, i know lambdabot is the source of all good things. i think i still have some code in there, if don hasn't rewritten my code from disgust...
19:53:16 <blackdog> @vixen
19:53:16 <lambdabot> yeah?
19:53:17 <Korollary> hoogle actually could match that
19:53:20 <dons> yup, blackdog. you like that?
19:53:35 <dons> ?. vixen b52s
19:53:35 <lambdabot> Would you dress in women's clothes for me?  That really turns me on ;)
19:53:43 <blackdog> yes, you rewrote it?
19:53:43 <dons> (plugin composition ;)
19:53:46 <dons> nope
19:53:55 <dons> I mean, lambdabot treats teh  channel as a literate doc
19:54:08 <blackdog> oh, gotcha. yes, very cool.
19:54:32 <blackdog> @vixen i'm selling out and becoming a java programmer. should i do it?
19:54:32 <lambdabot> maybe you should :)
19:54:37 <dons> ?. id vixen hey babe
19:54:37 <lambdabot> hiya
19:54:42 <blackdog> incontrovertible proof.
19:54:55 <dons> ?vixen do you like java programmers, though?
19:54:56 <lambdabot> yah, i like you
19:55:00 <Korollary> lol
19:55:04 <Smokey`> :P
19:55:07 <dons> my secrete shame!
19:55:09 <araujo> haha
19:55:19 <Korollary> poor dons' fate has been sealed.
19:55:52 <monochrom> @vixen do you like ACM contest team coaches?
19:55:53 <dons> I used to teach java to postgrads. I'm so glad those days are over
19:55:53 <lambdabot> sure, i definitely don't hate
19:56:08 <araujo> haha
19:56:30 <monochrom> I taught Java to postgrads too.  http://www.cs.utoronto.ca/~trebla/javacourse/
19:56:38 <araujo> lambdabot, they should add Haskell to the ACM contest, right?
19:56:41 <monochrom> My friends graduated.
19:56:48 <blackdog> dons: i still want to write that markov chain generator so that lambdabot can imitate the regulars here
19:56:49 <dons> hehe
19:56:56 <dons> yeah. that would be good
19:57:04 <dons> we have one almost such thing it's great.
19:57:05 <dons> ?keal
19:57:05 <lambdabot> can haskell compile flash animations and java apps?
19:57:08 <dons> ?keal
19:57:08 <lambdabot> need 1 to do a while 0 does !a. need 1 to do a while 0 does !a
19:57:22 <dons> but I really want ?<nick> for all nicks
19:57:23 <blackdog> ?dons
19:57:23 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
19:57:27 <dons> lambdaobt keeps logs now, soit would be doable
19:57:41 <blackdog> so that's just a random line from the logs?
19:57:46 <Korollary> no
19:57:50 <dons> just random lines from that particular guy
19:57:51 <araujo> ?keal
19:57:51 <lambdabot> nsa prevent me from returning to math on efnet
19:57:55 <Korollary> those are precious quotes
19:57:56 <araujo> haha
19:57:56 <blackdog> yeah, what i meant...
19:57:57 <dons> actualy lines
19:57:59 <Smokey`> ?Smokey`
19:58:00 <lambdabot> Unknown command, try @list
19:58:12 <Smokey`> <3
19:58:17 <blackdog> heh, doesn't like the quote?
19:58:17 <dons> we could do random lines from the log. yeah. but markov is more fun.
19:58:26 * araujo thinks that ?<nick> would be a very dangerous feature ;-)
19:58:30 <Korollary> lambdabot could also compute statistics per user
19:58:30 <blackdog> totally.
19:58:38 <blackdog> autokarma!
19:58:44 <Smokeytest> testing...
19:58:58 <Smokey`> ?Smokeytest
19:58:58 <lambdabot> Unknown command, try @list
19:59:05 <Smokey`> I'm confused...
19:59:17 <Korollary> it doesnt recognize any user's name. Keal was special.
19:59:24 <Korollary> too special.
19:59:25 <Smokey`> ahh, alrighty...
19:59:29 <Smokey`> lol
19:59:33 <blackdog> troll?
19:59:40 <Korollary> not sure
19:59:41 <araujo> ?keal
19:59:42 <lambdabot> i want to invent white dye
19:59:48 <blackdog> troll. :)
19:59:49 <araujo> figure out :-P
20:00:21 <dons> it was weird 
20:00:23 <Korollary> He was a troll bordering on a mental disorder.
20:00:28 <dons> a strange 2 days
20:00:41 <dons> ?keal
20:00:47 <araujo> dons, only 2 days?
20:01:08 <Korollary> unforgettable two days
20:01:21 <dons> ?bot
20:01:32 <dons> hmm?
20:01:34 <Lemmih> ?bot
20:01:34 <lambdabot> :)
20:01:42 <dons> what did I do?
20:01:48 <monochrom> looks look lambdabot is infected by keal
20:01:54 <Lemmih> dons: You wrote some weird chars before '?'
20:02:03 <Smokey`> :S  I killed ghci...
20:02:04 <Korollary> I didnt see any, tho
20:02:06 <dons> ah. wifi plague
20:02:08 <Lemmih> ?slap Dons' wireless network
20:02:08 <lambdabot> why on earth would I slap Dons' wireless network
20:02:09 * araujo just read someone instructing to a bot to say "Haskell is weird" in other channel
20:02:31 <Korollary> which channel?
20:02:35 <araujo> ?keal
20:02:35 <lambdabot> will it return [] if map gives fpu infinite list?
20:02:47 <araujo> /msg Korollary #scheme
20:02:50 <araujo> oops ;-)
20:02:52 <Korollary> heh
20:03:16 <Korollary> I once run a cross-channel users stats across haskell, scheme, perl, python, ocaml
20:03:25 <Korollary> there's no love lost between some of those chans
20:03:32 <araujo> hah
20:03:47 <Smokey`> @hoogle Float -> Int
20:03:48 <lambdabot> No matches, try a more general search
20:04:19 <dons> how do you mean, Korollary?
20:04:24 <dons> no users shared?
20:04:30 <Lemmih> > truncate 10.42
20:04:31 <lambdabot> 10
20:04:39 <Korollary> dons: there were very few people, yes
20:04:47 <Lemmih> > round 10.62
20:04:47 <lambdabot> 11
20:04:58 * araujo used to be in #ocaml time ago
20:05:22 <blackdog> no shame there. if it weren't for the syntax, i'd probably still be using it...
20:05:24 <Smokey`> round would be more appropriate, ty :)
20:08:46 <Smokey`> haskell.org/onlinereport/ should be my home page... that and hoogle could teach me everything I need.
20:09:36 <Korollary> safety car
20:09:50 <Korollary> a very eventful start in Melbourne
20:17:55 <tennin> I'm looking for a real program to read that illustrates the use of arrows
20:18:00 <tennin> ideally in the 1000-2000 line range
20:18:50 <dons> Frag is around 7k loc. the arrows spacce invaders is almost certainly shorter
20:18:52 <monochrom> Ideally no one ever needs to write a 1000-line real program.
20:19:28 <tennin> monochrom, why?
20:20:05 <tennin> well, real or real-ish
20:22:36 <monochrom> To explain that requires the audience to not take the current industry practice for granted.
20:23:51 <monochrom> But industry practice doesn't care about ideals anyway.
20:24:37 <tennin> I'm still curious to know why you think that, whether it fits industry practice or not
20:26:31 <tennin> I don't have much experience industrial or otherwise, so I always want to hear what other, wiser people think
20:27:49 <tennin> potentially wiser anyway
20:32:02 <Smokey`> I'm soo confused, ghci is giving me an error, yet when I try manually putting in the code to ghci, it's fine...
20:32:19 <dons> what is the error?
20:32:25 <Smokey`> *** Exception: ./PPM.hs:48:10-74: Irrefutable pattern failed for pattern (p3 : comment : dimensions : range : pixelDataLines)
20:32:34 <Smokey`> exception sorry, but with the same data, and same code put into ghci, no exception
20:32:42 <dons> ok, so a pattern match is failing.
20:32:54 <Smokey`> put int = hand typed
20:32:56 <dons> it works in ghci, or ghc?
20:33:02 <Smokey`> s/int/into/
20:33:06 <dons> your statement above mentioned ghci twice
20:33:24 <Smokey`> aye, i'm loading it into ghci, it can load hte modules happily.  when i call the code though, i get that exception
20:33:39 <dons> but when you type the code in , it's fine?
20:33:47 <Smokey`> yes, with the same data and everything
20:33:50 <dons> there's no difference. so I suspect something else is at work
20:33:53 <dons> can you paste the code?
20:33:54 <Smokey`> mmm
20:34:12 <Korollary> did you mean to have an irrefutable match?
20:34:16 <dons> lisppaste: url
20:34:17 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
20:34:22 <Smokey`> even worse, it's not my code :(   It's a module supplied by my tutor that's not working
20:34:26 <Korollary> ah
20:34:32 <dons> what about when you compile it?
20:35:00 <Smokey`> dons: me and ghc dont get along w/ compiling stuff,  haven't done a successful multi-file ocmpilation as of yet :P
20:35:16 <Smokey`> hence doing everything in ghci
20:35:26 <dons> ghc --make Main.hs
20:35:39 <dons> --make will chase dependencies over multiple modules
20:35:48 <dons> you give it the top level module as an argument
20:36:10 <Smokey`> lol, fair enough... that'll make things easier :P
20:37:47 <dons> add -O if you want to optimise it
20:41:42 <Smokey`> WTF, now it's expecting type [a] in the return of my do statement, when the return type is infact [[a]] :(
20:41:57 <Smokey`> sigh, I had this issue before, dont know what I did wrong nor how to fix itthough
20:42:11 <dons> a type error. thank ghc. it would have been a runtime error otherwise :)
20:42:13 <Cale> Smokey`: can I see?
20:42:22 <dons> work backwards from the line that ghc says the error is at.
20:42:25 <dons> or paste the code
20:42:45 <Cale> are you working in the list monad?
20:42:56 <dons> it might be a comfort to know that type errors get really easy after a couple of months
20:43:04 <Cale> > do x <- [1,2,3]; [x, x+1]
20:43:05 <lambdabot> [1,2,2,3,3,4]
20:43:30 <metaperl> Cale: hi, ltns
20:43:37 <Cale> hi
20:43:45 <lisppaste2> Smokey` pasted "Smokey`" at http://paste.lisp.org/display/18534
20:44:30 <Cale> Smokey`: and the error?
20:44:43 <Smokey`> lol sorry :)
20:45:08 <Cale> also, what's the Image type?
20:45:13 <Cale> Is it monadic?
20:45:43 <lisppaste2> Smokey` annotated #18534 with "error + type defs" at http://paste.lisp.org/display/18534#1
20:46:07 <Smokey`> lol, type Image = PixelMap
20:46:24 <Cale> er
20:46:27 <Cale> ah
20:46:27 <Smokey`> type Row = PixelMap_Row,  sorry... (again not my code, i had to plug this module into my code... when i didnt expet to)
20:46:30 <Cale> okay
20:46:41 <Smokey`> expect to have to*
20:46:57 <Cale> why is decodePPM in a monad?
20:47:18 <Cale> you appear to be using the list monad, only in a trivial way
20:47:18 <Smokey`> you're talking to a noob here, no idea what a monad is :)
20:47:24 <Cale> so I suspect that you don't want to
20:47:34 <Cale> 'do' signifies that you're composing a monadic action
20:47:46 <Smokey`> okay, reaosn is the other way made the exception in my code...
20:47:55 <Smokey`> i'm testing this to see if it's any different, i doubt it though
20:47:57 <Cale> you're allowed to use  let ... in ...  without do
20:49:27 <lisppaste2> Cale annotated #18534 with "modification" at http://paste.lisp.org/display/18534#2
20:49:29 <dons> yep. you only use 'do' with monadic code. 
20:49:58 <Cale> now, lists form a monad, so 'return' is of type a -> [a]
20:50:02 <Cale> essentially, return x = [x]
20:50:03 <Smokey`> okay, that's my fault trying weird things then, because it used ot be something else.
20:50:18 <dons> keep it simple :)
20:50:46 <lisppaste2> Smokey` annotated #18534 with "used to be" at http://paste.lisp.org/display/18534#3
20:50:55 <metaperl> could someone help with    http://sequence.complete.org/node/154
20:51:00 <metaperl> "the Haskell implementation of the least divisor function"
20:51:13 <metaperl> I have re-formatted it for readability and would appreciate some help
20:51:28 <Cale> Smokey`: what exception?
20:51:38 <Smokey`> <Smokey`> *** Exception: ./PPM.hs:48:10-74: Irrefutable pattern failed for pattern (p3 : comment : dimensions : range : pixelDataLines)
20:52:02 <Cale> Smokey`: you'll still get that
20:52:16 <dons> oh. that means the list you get back isn't of the form you're trying to match against
20:52:21 <Cale> it means that lines contents doesn't give you enough lines
20:52:34 <Smokey`> mmm, that technically shouldn't be... :S
20:52:35 <dons> lines contents isn't returning a 5 line list
20:52:44 <Smokey`> *checks sstuff*
20:52:48 <Cale> at least 4 line...
20:52:59 <Cale> metaperl: okay, let me look
20:53:44 <monochrom> I don't understand "... implies (LD(n))^2"
20:53:45 <lisppaste2> dons annotated #18534 with "refactoring for style" at http://paste.lisp.org/display/18534#4
20:53:46 <dons> I just refactored it for style 
20:54:00 <dons> oh, as the bot says. good bot
20:54:00 <monochrom> Or in general I don't understand "... implies <number not boolean here>"
20:54:01 <metaperl> monochrom: that is in the book
20:54:13 <Cale> metaperl: if n doesn't have a factor less than sqrt(n), then it must be prime
20:54:33 <Smokey`> alrighty, i think i get the issue... hGetContents wont actually get the contents untill I use the variable...
20:54:53 <dons>  ?
20:54:56 <Smokey`> but i close it before I use it, because i dont want to have a handle to a file for too long
20:55:13 <monochrom> If it's in the book, I still don't understand it.
20:55:16 <Cale> metaperl: Suppose that n = a*b, but n doesn't have a proper factor less than or equal to sqrt(n)
20:55:16 <dons> s <- hGetContents; then pass 's' to something. don't close a lazy io list
20:55:16 <metaperl> monochrom: thanks... the HTML parser munged that IMPLIES statement. it is fixed now
20:55:28 <dons> Smokey`, it closes itself when you use it up
20:55:42 <monochrom> And I bet you don't understand it either.
20:55:48 <Cale> so a > sqrt(n) and b > sqrt(n)
20:55:55 <dons> if you need to strictly read it, Smokey`, that can be done. but it's rarely needed
20:55:56 <Cale> and so a*b > sqrt(n)^2
20:56:04 <Cale> and so a*b > n
20:56:09 <Cale> which is a contradiction
20:56:13 <monochrom> But it's a losing war.  People ask questions to get answers, not to get how to get answers.
20:56:51 <Smokey`> dons: no I dont need to, but i'm just used to doing it that way...
20:56:52 <dons> ?remember monochrom it's a losing war.  People ask questions to get answers, not to get how to get answers
20:56:53 <lambdabot> Done.
20:57:08 <dons> Smoeky`, yep I understand
20:57:12 <Cale> n > 1 and n not prime IMPLIES (LD(n))^2 < n
20:57:15 <Cale> er
20:57:17 <Cale> n > 1 and n not prime IMPLIES (LD(n))^2 <= n
20:57:23 <Cale> is what it should say
20:57:25 <dons> handles that close themselves when they're eof are fun and cool
20:58:07 <Smokey`> dons: again, lack of control scares me. :)
20:58:25 <Smokey`> unless i've written whatever automates 'x' for me :)
20:58:29 <Cale> you, or the book, left off the "<= n" bit
20:58:31 <monochrom> Well, at least I get two famous sayings registered to lambdabot, so all is not lost.
20:59:17 <metaperl> Cale: yes, I fixed it. The HTML parser was munging it
20:59:40 <Cale> aha
20:59:58 <Cale> okay
21:00:06 <Cale> so does it make sense?
21:00:16 <Smokey`> well that was fun, now for some Binary IO, (WITHOUT someone elses code!!!)
21:01:32 <Smokey`> and better yet, assignment 99% done :)  just doing extra things for personal benefit (and possibly extra marks) now :)   bmp file loading, then perhaps targa (similar)
21:01:50 <Smokey`> thanks guys, for the help, and more so putting up with me :)
21:02:20 <dons> Smokey`, no worries. if you want style suggestions. just post code.
21:02:26 <dons> it's helpful to have code reviews
21:03:11 <Smokey`> aye
21:03:48 <dons> how are you planning to do the bmp loading? writing a parser for the format that reads chunks of bytes?
21:04:00 <dons> hGetChar stuff?
21:04:02 <metaperl> Cale: ah. I think I see it. If n does not have a factor <= sqrt(n), then n is prime and in that case ldf k n would be n
21:04:08 <Smokey`> dons: yes, that was my plan...
21:04:20 <Smokey`> dons: unless you have a more functional way to do things :P
21:04:29 <dons> yep. that's how I'd do it (at least for an assignment)
21:04:32 <metaperl> Cale: I will add you comments to the thread on sequence
21:04:41 <Cale> metaperl: note that ldf k n is not necessarily the least divisor of n greater than k -- it gives up when k^2 is larger than n. But it suffices to ignore larger factors when looking for the least one.
21:04:41 <dons> there re standard binary io libs, but they're just layers over hGetChar anyway
21:05:03 <dons> if it's truly binary, you might need to use Data.Bits, not sure.
21:05:12 <Smokey`> dons: BMP/Targa aren't part of the assignment, they're for personal learning... as for standard IO... meh, i'm an elitist, i write my own everything in the end :P
21:05:23 <Smokey`> dons: no, hGetChar should be fine. :)
21:05:26 <dons> ok.
21:07:25 <monochrom> A loop invariant of ldf is that no number in [2..k-1] divides n.  With this loop invariant you are assured that ldf k n = LD(n).
21:07:39 <metaperl> Cale: why wouldn't that be the leaster divisor on n >= k?
21:08:12 <Cale> metaperl: because if k^2 > n, then it just gives you n
21:08:34 <metaperl> yes, because n is the least divisor
21:08:41 <Cale> There may be divisors k such that k^2 > n, but k < n, but it doesn't bother with them.
21:08:57 <metaperl> can there be such a thing?
21:09:03 <Cale> It's working on the assumption that you're searching for an overall least divisor
21:09:04 <Cale> sure
21:09:06 <Cale> look at 6
21:09:09 <monochrom> ldf 4 100 would be funny.
21:09:09 <Cale> 6 = 2 * 3
21:09:22 <Cale> 3^2 = 9 which is greater than 6
21:09:36 <metaperl> yes but it would find 2 as the least divisor
21:09:45 <metaperl> by the first guard
21:09:50 <metaperl> because 2 divides 6
21:09:57 <monochrom> ldf 3 6
21:10:15 <Cale> metaperl: right, but if called as ldf 3 6, as monochrom points out, it doesn't find 3
21:10:19 <Cale> it gives 6
21:10:20 <metaperl> monochrom: that would be 3
21:10:24 <Cale> nope
21:10:39 <monochrom> well, 3 is still not LD(6).
21:10:49 <metaperl> why not? the first guard would match it
21:10:53 <monochrom> ldf 4 6
21:10:58 <Cale> ah, sorry
21:11:01 <metaperl> monochrom: ld 6 = ld 2 6
21:11:06 <metaperl> ld n = ld 2 n
21:11:07 <Cale> bad example then
21:11:09 <metaperl> not any k
21:11:22 <Cale> ldf 11 100 then
21:11:41 <Smokey`> okay, stupid question, but i'm curious... say you have a data structure in C++  struct foo { float a, b, c; },  and you have two instances,  foo x, y;   to access the a/b/c vars, you have to reference the instance of hte data structure,  and then the varaible, such as  x.a/x.b/x.c, and y.a/y.b/y.c,   however in Haskell you just name each type of a variable manually when you declare the variable,  so you'd end up probably naming them foo(xa xb x
21:11:57 <metaperl> oh yes, ldf is an auxilliarly function only called with k == 2
21:12:09 <Cale> metaperl: right
21:12:12 <monochrom> Yes, you would never in your right mind evaluate ldf 4 6 directly.  That is why I said all the things I said.
21:12:14 <Cale> it won't find 20
21:12:27 <Cale> it'll go straight to 100
21:14:11 <monochrom> ldf k n is unspecified if you don't already know that no number in [2..k-1] divides n.
21:14:46 <metaperl> monochrom: I think it would return n
21:15:07 <dons> Smokey`, I don't fully understand your question. but you'd probably use record syntax
21:15:48 <dons> data Foo = Foo { a , b , c :: Float } ; then a x gives you the 'a' field of some 'x :: Foto'
21:16:14 <dons> i.e. the field names are also selectors for that field from some variable
21:16:30 <dons> is that what you mean?
21:16:45 <monochrom> The given theorem is probably best used in contraposition.  LD(n)^2 > n implies n is prime.  (Assuming n>1.  The case n=1 needs special treatment due to the way the code is written.)
21:19:57 <Smokey`> dons: h/o, i'll write up sample code, with a simpler question :)
21:20:04 <monochrom> Assuming no number in [2..k-1] divides n, and you evaluate ldf k n, and k does not divide n either, you have: no number in [2..k] divides n, so LD(n)>k.
21:20:44 <monochrom> If at this point you also find out k^2>n, that's LD(n)^2>k^2>n.  So n is prime.  So n = LD(n).
21:21:58 <monochrom> But now, reading the definition of LD, I'm worried.
21:22:42 <monochrom> The definition requires: forsome a. LD(n)*a = n and a>LD(n) and LD(n)>1.
21:23:27 <metaperl> hey has TheHunter been around?
21:23:29 <monochrom> But LD(2) does not exist by this requirement.
21:23:31 <Cale> it should be a >= p
21:23:39 <Cale> er
21:23:42 <Cale> no
21:23:45 <monochrom> That will still break.
21:23:50 <Cale> that condition should be deleted
21:23:58 <monochrom> In general LD(prime) does not exist.
21:23:58 <Cale> it's just p > 1
21:24:02 <Smokey`> http://rafb.net/paste/results/yVNxv392.html <-- if that makes sense...dons: 
21:24:04 <Smokey`> dons ^^
21:24:18 <Cale> The least such p
21:24:20 <monochrom> Then LD does not specify "least".
21:24:30 <monochrom> Ok, then it's good.
21:24:36 <Cale> well, "least divisor of n" is a fine definition
21:24:58 <monochrom> least proper divisor, we want to kick out 1.
21:25:01 <Cale> p * a = n and p > 1 are just facts about it
21:25:04 <Cale> right
21:25:18 <monochrom> err least nontrivial divisor?  proper probably means !=n
21:25:34 <Cale> nah, let's allow LD(p) = p
21:25:45 <Cale> exactly when p is prime
21:25:59 <monochrom> Yes I want to allow LD(n)=n, but "proper" disallows that.
21:26:10 <dons> Smokey`, I'll write you an example of how I'd do it
21:26:54 <Smokey`> dons: no problemo :)
21:27:08 <monochrom> At the end of the day it's really the smallest prime divisor.
21:28:15 <monochrom> If the book gave the broken definition, it should be thrown away.
21:29:52 <dons> Smokey`, the examplle is a bit false, since it sets all fields to 0.0. You'd just use a constant in Haskell. but say you only wanted to set some fields to 0, you'd do it like so: http://rafb.net/paste/results/EE8UP150.html
21:30:53 <dons> you can see how it's much simpler if you really want to set them all to zero: zero = Foo 0.0 0.0 0.0 -- is all you need to get an empty struct
21:31:13 <Smokey`> yeah that's setting them, i'm more curious as to how one would reference a/b/c from x/y, without predeclaring a/b/c as xa xb xc,  for other uses (such as passing them into other functions)   if that makes sense :S
21:31:48 <dons> you reference them by using the names a b c as selector functions on 'x' and 'u'
21:31:52 <dons> i.e. : x a
21:31:57 <dons> is the same as: x.a in C++=
21:32:06 <dons> sorry, a x
21:32:13 <Smokey`> oh, really?
21:32:18 <metaperl> monochrom: here is the book: http://www-lnc.usc.edu/~brannon/haskell/HR.pdf
21:32:20 <monochrom> fooey Foo{a=v1, b=v2} = v1+v2
21:32:24 <dons> the field name is a function that when applied to the Foo value returns that field
21:32:25 <Smokey`> awesome, that's what I wanted to know :)
21:32:31 <dons> so a :: Foo -> Float
21:32:36 <Smokey`> aye
21:32:37 <dons> and a x :: Float
21:32:44 <dons> cool huh.
21:32:45 <Smokey`> awesome :)  thanks dons :)
21:32:57 <Korollary> isnt that in the tutorial you're reading?
21:33:03 <dons> this is the record syntax :)
21:33:24 <Smokey`> mmm, they didn't teach us that in my class... heh, which is rather sad.
21:33:39 <Korollary> what textbook?
21:34:59 <Smokey`> lol, it's a programming class.  I purposely didn't buy the textbook knowing i could ace the entire course with haskell.org, and I have :)  mid-semester exam tomorrow, i know more than what they taught everyone, and after mid-semester break, we move to Java which I already know :)
21:36:13 <dons> I guess it's a bit advanced. but not very advanced.
21:36:35 <Smokey`> heh, advanced?  you explained ir rather well in 3-4 lines of code :)
21:36:37 <dons> they didn't teach it back when I did comp 1a in Haskell either
21:36:45 <Smokey`> it*
21:37:04 <dons> well. considering that you've got to master recursion first :S there's a lot of stuff to teach in a Haskell course
21:37:16 * dons makes a little joke
21:37:23 <palomer> mastering recursion is like winning the world
21:39:49 <monochrom> But do I win the girl too?
21:40:37 <dons> yeah, all the girls like guys how are experts at recursion and fp
21:40:44 <dons> ?vixen what do you think of functional programmers?
21:40:44 <lambdabot> fun is the opposite of work
21:40:52 <dons> hehe
21:41:42 * Smokey` wonders if it's possible to import C++ classes into haskell at all... now THAT would be cool :)
21:41:53 <dons> you can call them via the FFI
21:42:05 <Smokey`> how does one call a 'class'?
21:42:06 <dons> it's easier to call C, but C++ can also be done
21:42:25 <dons> don't know. i've never tried. it's a questoin for the haskell-cafe@ mailing list, I think
21:42:34 <Smokey`> aye
21:43:11 <dons> some people have written work combining oo langs and haskell
21:43:30 <dons> notably, ozone, a #haskell citizen, wrote Mocha, an interface to Obj. C.
21:43:40 <dons> uses lots of fun things like existentials types, iirc.
21:43:50 <Smokey`> that'd be rather cool... I could write my libs in 'both' Haskell and C++ :P  lol
21:43:59 <Smokey`> 'could', but wouldnt. :)
21:44:52 <Smokey`> anyway, enough of my nonsense :)
21:44:59 <dons> I should add the Obj C binding to the ffi page.
21:45:12 <dons> with the ones for python scheme C and so on
21:45:41 <dons> ?wiki Libraries_and_tools/Interfacing_other_languages
21:45:42 <lambdabot> http://www.haskell.org/haskellwiki/Libraries_and_tools/Interfacing_other_languages
21:46:22 <Bobstopper> audreyt: were you writing a yaml parser for Haskell? Any progress?
21:46:40 <dons> yaml? yet-another-??
21:46:52 <audreyt> Bobstopper: fully functional... it's in svn.openfoundry.org/pugs/src/Data/Yaml/Syck
21:47:01 <audreyt> parser and emitter (even for recursive infinite lists) work
21:47:02 <Bobstopper> great, thanks
21:47:10 <audreyt> dons: YAML Ain't Markup Language
21:47:15 <audreyt> yaml.org
21:47:26 <audreyt> Bobstopper: if you can help cabalize it, I'd be very happy
21:47:47 <dons> ah. got an url? (other than an svn dir?)
21:47:53 <dons> I'll add it to the wiki :)
21:48:06 <audreyt> url to the impl?
21:48:12 <dons> yep . or a descriptiong.
21:48:17 <Bobstopper> have you announced it anywhere? I found a mention that you were writing one but I couldn't find it anywhere when I tried searching for it.
21:48:29 <audreyt> Bobstopper: yeah, it's currently just internally used for pugs
21:48:35 <Bobstopper> ah ok
21:48:40 <audreyt> I'm not yet versed at hackage enough to cabalize/upload it
21:48:47 <audreyt> also it uses dons's FPS
21:48:53 <audreyt> and as such creates an interesting dependency
21:49:07 <audreyt> (You can also use [String] but internally it's FPS)
21:49:12 <dons> interesting, how so?
21:49:15 * audreyt is using FPS for all her new code these days
21:49:21 <dons> cool :)
21:49:22 <dons> so do I, actually
21:49:25 <dons> all my IO
21:49:33 <audreyt> I think [Char] is a mistake, seriously.
21:49:37 * dons feels a standard library coming on
21:49:41 <audreyt> [Word8] is fine. FPS is fine.
21:49:50 <audreyt> for the love of unicode, I don't know what [Char] means.
21:50:04 <dons> It's historical. A strong theme in Haskell was its use as a teaching language
21:50:27 <audreyt> yeah but, [Char] isn't a list of characters
21:50:29 <audreyt> it's a list of codepoints
21:50:33 <audreyt> and it really confuses people :)
21:50:40 <dons> and it's good to write proofs on programs that use lists for strings
21:50:42 <audreyt> (and a list of codepoints is just about useless in all applications)
21:50:47 <dons> a list of codepoints. hmm. 
21:50:58 <dons> a lazy list, you mean?
21:51:01 <audreyt> yeah
21:51:07 <dons> ok :)
21:51:15 <audreyt> the length of a lazy list of codepoints isn't "string length"
21:51:17 <dons> lazy lists are fine to reason about htough
21:51:24 <audreyt> because of combining charactres etc
21:51:35 <dons> you just throw induction at everything -- it all works
21:51:39 <Korollary> stating that a string is a list is also very aggressive.
21:51:40 <audreyt> it'd be much easier if [Char] just means [Char8]
21:51:45 <Cale> Well, I'm not sure if anyone who was writing Haskell 98 actually understood unicode. It seems really complicated.
21:51:50 <audreyt> or even better, [Char7]
21:51:53 <dons> yeah. that bit might not be very good
21:51:55 <monochrom> Smokey`, dons : imperative version: http://rafb.net/paste/results/MwW67y58.html
21:52:03 <dons> since its only 8 years later that ghc actually gets unicode
21:52:11 <audreyt> indeed
21:52:55 * audreyt is excited about "always"... I feel that STM is the new ST
21:53:04 <dons> hehe
21:53:15 <dons> ?remember audreyt I feel that STM is the new ST
21:53:15 <lambdabot> Done.
21:53:16 <Cale> audreyt: hm?
21:53:21 <adu> ghc uses unicode?
21:53:26 <audreyt> Cale: http://lambda-the-ultimate.org/node/1388
21:53:26 <Cale> STM and ST are very different
21:53:26 <dons> well, ST was pretty exciting in its day
21:53:39 <dons> adu, yeah
21:53:50 <Cale> they're not even remotely for the same thing, are they?
21:53:52 <dons> you can have use lambda and forall and arrow symbols for the keywords
21:54:04 <Cale> ST is for pure imperative computation
21:54:09 <audreyt> Cale: are they not? ST is noncomposable STM :)
21:54:15 <dons> Cale, I think audreyt means in the sense of 'changing the world'
21:54:20 <monochrom> runST gets you back to pure functional world.  runSTM gets you into IO.
21:54:29 <audreyt> yup.
21:54:32 <Cale> there's no runSTM :: STM a -> a
21:54:55 <dons> our programming won't be the same after STM, just as it was never the same after ST.
21:54:58 <audreyt> ...except in the Q monad :)
21:55:06 <Cale> STM is for concurrency, ST has nothing to do with concurrency
21:55:23 <dons> yikes!
21:55:29 <monochrom> Both have mutable variables.  Both have >>=.
21:56:02 <monochrom> Of course if you are just doing sequential programming, there needs no transaction log...
21:56:06 <Cale> sure, they're both monads with mutable cells, but that's where the similarities end
21:56:41 <monochrom> We like to get the computer to jump through a million hoops just to crunch out 1+1=2.
21:58:21 <monochrom> So, it's going to be: unsafePerformIO $ atomically $ unsafeIOToSTM $ newIORef ...
21:58:43 <audreyt> nah, just "runIO . runSTM"
21:59:05 <audreyt> and partially evaluate everything at compile time! *cackle*
21:59:14 <Cale> runIO/unsafePerformIO doesn't exist :)
21:59:18 <monochrom> Noooo!  I like runIO . runSTM . runIOinSTM . ...
21:59:32 <audreyt> @index runIO
21:59:33 <lambdabot> Language.Haskell.TH.Syntax, Language.Haskell.TH
21:59:53 <audreyt> Cale: what's wron with runIO :)
21:59:56 <monochrom> I also like to run JVM inside Linux inside VMWare inside Windows inside ...
22:00:04 <Cale> in any event, that wouldn't be very good, since TVars would be permitted to escape.
22:00:15 <audreyt> but not into runtime
22:00:18 <Cale> hm?
22:00:32 <audreyt> the idea of runIO is simply that the compilation time does the calculation:)
22:00:36 <Cale> you could create a TVar, and return it, and then run that computation
22:00:48 <audreyt> and TVars used in runIO . runSTM isn't visible at runtime
22:00:56 <Cale> and you'd have a TVar outside STM
22:01:00 <Cale> which would be bad.
22:01:29 <audreyt> yeah, which is why runIO can localize the effects in a differnt runlevel (i.e. compile time)
22:01:50 <Cale> hm?
22:01:56 <audreyt> Cale: have you used runIO?
22:02:02 <audreyt> Language.Haskell.TH.runIO
22:02:06 <Cale> oh, TH?
22:02:09 <audreyt> yeah
22:02:14 <audreyt> we've been talking past each other
22:02:15 <audreyt> :)
22:02:28 <Cale> so runIO isn't even a function
22:02:38 <audreyt> no, it's an action in the Q monad
22:02:38 <Cale> but a macro
22:02:41 <audreyt> yes.
22:02:42 <Cale> okay
22:03:13 <monochrom> This is scary!
22:03:32 <audreyt> I feel that there may come a time where runIO becomes more aggressively used, even recursively.
22:03:33 <Cale> still, you'd be able to do unsafe things from Q then
22:03:40 * dons notes that there are at least 13 theorem provers written in Haskell
22:03:44 <dons> we've found a niche!
22:03:53 <monochrom> So did the ML people.
22:04:05 <dons> compilers, theorem provers, and ray tracers
22:04:07 <audreyt> Cale: yeah, but the unsafeness doesn't propagate to runtime... it's of courses not the ST kind of separation
22:04:11 <Cale> audreyt: I actually hope not, at least, not manually.
22:04:33 <audreyt> Cale: but coupled with "always", I feel this new tool to be an intersting combination
22:04:38 <dons> monochrom, well, they had the 80s and 90s. now the theorem proving courses are being taught in Haskell :)
22:04:54 <dons> at least at my uni.
22:05:03 <audreyt> (of course my brain is somewhat formateed by perl6, which uses runIO . runSTM for just about everything.)
22:05:04 <monochrom> I particularly like Prufrock's use of typeclasses.
22:06:55 <monochrom> Then again, even I taught theorem provers in my Haskell notes.
22:07:39 <monochrom> I at least had the obvious vision to phrase tactics as monads rather than continuations.
22:13:45 <monochrom> Jim Grundy?!
22:25:17 <Smokey`> sweeet, now we're talking, Foreign.Marshal makes me feel good inside :)
22:26:44 <dons> hehe
22:27:06 <dons> you can malloc and alloc and coerce to your 'earts content
22:27:41 <dons> and mutate arrays are have lots of evil fun
22:27:47 <Smokey`> *drools*
22:27:53 <dons> Data.Array.IO might be fun for you too
22:28:03 <Smokey`> I could make sooo much goodness from these things <3
22:28:17 <dons> Foreign.C could be your friend too
22:28:57 <dons> ForeignPtrs are particularly fun, since you get the ghc GC to collect your foreign objects for you
22:29:08 <Smokey`> lol
22:29:52 <dons> you just register a de-alloc function, like free(). and when the object is out of scope, ghc will call that function on the foreign object
22:30:07 <dons> so no need to track the things you malloc very closely
22:30:15 <dons> (unless you like that sort of thing, and like writing extra code ;)
22:30:49 <Smokey`> you dont know me well enough, i 'do' like that sort of thing :)  and I have a tendency not to trust anythign I haven't written :P
22:31:09 <dons> yeah, I thought so
22:31:26 <dons> but soon you'll learn to trust Simon Marlow, the guy behind the GHC garbage collector :)
22:32:01 <dons> oh, and you haven't even started with concurrency yet!?
22:32:16 <dons> forkIO must be one of the most beautiful things about Haskell :)
22:33:15 <Lemmih> In Haskell-land, we have 'In The Simons We Trust' printed on our money.
22:33:48 <dons> and 'We are scared of bus errors in Cambridge'
22:34:04 <monochrom> I have started with concurrency.
23:12:16 <Smokey`> does Haskell support default arguments for function parameters?
23:15:39 <monochrom> No.
23:18:10 <dons> invisible, non-obvious scoped values are frowned upon, as they introduce bugs.
23:19:04 <dons> there is an experimental thing called 'implicit paramaters' but they also tend to introduce bugs. and also make code hard to maintain, imo.
23:19:32 <dons> for values that need to be threaded among many functions, you write a monad, which does the threading for you
23:19:57 <Smokey`> heh, the only thing that introduces bugs is a bad programmer.
23:21:22 <dons> I guess in the statically typed fp community, we tend to want the machine to catch and prevent more errors. rather than relying on the programmer to be good ;)
23:21:45 <Smokey`> imo that's just producing lazy programmers.
23:21:55 <Smokey`> and endorcing it in the language/runtime.
23:22:25 <sieni> Smokey`: and anyway it's a bit hard to do in Haskell, because of currying
23:22:47 <dons> the result is lots of language facilities that prevent bugs. leading to corrrect, high assurance code that you can write proofs about. rather than relying on programmers to have gotten it right.
23:23:32 <dons> if it wasn't for laziness we'd still be writing in machine code. abstraction is what pushes programming languages forward
23:24:23 <dons> but there's always ways to gain more control, if you need it. Foreign.* for example.
23:29:20 <dons> I think it's common for people to resent, say, the type checker at first. but with time it becomes an indespensible tool, like syntax highlighting or -Wall. More so, as it means i can proogram correctly while half asleep
23:29:41 <dons> or like GC.
23:29:56 <dons> all ways to remove bugs before they even appear
23:30:14 <dons> so, i say, 3 cheers for abstraction!
23:31:20 <audreyt> abstarction only works when you know what you are doing though...
23:31:30 <sieni> but if you want varargs or something similar, I guess you could use combinators for that
23:32:02 <Cale> I suppose it depends on what counts as "default arguments" 
23:35:25 <dons> yeah. I would think a monad pretty much works for this purpose
23:35:30 <dons> s <- gets
23:35:37 <dons> looks like there's a 'default argument'
23:36:35 <dons> It's funny how John Goerzon names any new library with a 'Missing' prefix :)
23:36:50 <dons> like, it was missing till it was written
23:36:58 <dons> but now it isn't
23:37:23 <Cale> hehe
23:39:59 <Cale> then again, MissingH would become H
23:40:56 <dons> oh, hehe, in Feb 05, Assoc Types were called "class associated types"
23:40:59 <dons> i'd forgotten that
23:41:17 <Cale> aren't they still?
23:41:34 <dons> not in recent conversations.
23:42:06 <dons> we never casually refer to them as 'class associated types' in our research group.
23:42:07 <Cale> I suppose the fact that you're talking on Haskell' basically implies the 'class' bit
23:44:18 <dons> yeah, nor on Haskell'
23:44:46 <dons> Smokey`, I note that Lemmih wrote 'Hacanon'. A tool to automate writing bindings to C++
23:44:58 <dons> you might want to talk to him if you wish to pursue this
23:45:18 <dons> http://www.haskell.org/pipermail/haskell/2005-February/015372.html
