00:02:33 <Pegazus> where did you got that info?
00:02:49 <int-e> again the last 2^k is 2^n
00:03:12 <Pegazus> i didnt understood point 2...
00:04:59 <Pegazus> can you explain it again please? :)
00:05:25 <int-e> You can solve for a and b there, using the recurrence. What form of t(n) to choose depends on the recurrence.
00:05:36 <Pegazus> but why should i do that?
00:06:42 <int-e> Because the homogenous solution has an error - it ignores the n+k part of the recurrence. t(n) corrects that error - you just need to find any solution of the inhomogenous recurrence.
00:09:26 <Pegazus> i odn't understand how do you correct it
00:09:32 <Pegazus> :(
00:09:37 <Pegazus> why does t(n) correct it?
00:10:27 <Pegazus> how do you get solution t(n) = - n - 2 - k?
00:10:29 <Pegazus> magic or what?
00:11:27 <int-e> look: let T(n) be any solution of T(n) = 2 * T(n - 1) + n + k. t(n) = - n - 2 - k also satisfies t(n) = 2*t(n-1) + n + k. Then, T(n)-t(n) = 2*(T(n-1)-t(n-1)), i.e. T'(n) = T(n) - t(n) satisfies the homogenous linear recurrence.
00:12:46 <int-e> Pegazus: I set t(n)=a*n+b, then use  t(n) = 2*t(n-1) + n + k  to get equations for a and b, by comparing the coefficients of the two resulting polynomials on the left and right side. Then I solve for a and b.)
00:14:28 <Pegazus> mmmm
00:14:33 <Pegazus> give me a minute to read please
00:19:44 <Pegazus> why did you set t(n) to a*n+b? because n + k was a grade 1 polynomial?
00:20:18 <int-e> yes.
00:20:21 <Pegazus> good
00:20:22 <Pegazus> and why does T(n)-t(n) = 2*(T(n-1)-t(n-1))?
00:21:13 <int-e> Pegazus: just subtract the two recurrences for T(n) and t(n)
00:21:51 <Pegazus> good
00:21:59 <Pegazus> thanks you very much int-e :)
00:22:02 <Pegazus> you are my hero!!!
00:22:20 <Pegazus> you really helped me :)
00:22:41 <int-e> nice
00:22:49 <Pegazus> where did you learn all that? do you know a book? webpage? or anything that has that sort of things?
00:24:05 <int-e> not really. these recurrences keep popping up in many places.
00:24:10 <Pegazus> ok
00:25:15 <Pegazus> now i have only one spare problem!
00:25:30 <Pegazus> do you know how to demostrate the complexity of a top bottom dynamic programming problem?
00:27:26 <int-e> counting the subproblems and finding out how much work is spent for each is a good start - but it really depends on the problem and the algorithm you use.
00:27:47 <Pegazus> i have a problem wich has for a n O(n^3) subproblems
00:27:58 <Pegazus> i know the complexity is O(n^3) because i do
00:28:36 <Pegazus> solve(...) { if (!IsOnCache(...)) { Solve; } return OnCache(...); } }
00:28:54 <Pegazus> Solve; uses up to 6 "smaller" instances to build the current instance
00:29:14 <Pegazus> but it will only execute at most O(n^3) times, because that are the number of instance
00:29:22 <Pegazus> but i don't know how to prove it formally
00:32:04 <int-e> Well, that is your proof. If you do the IsOnCache() check in the caller (which you could easily do without changing the complexity), then solve() is called at most once per subproblem. It also does a constant amount of work per subproblem.
00:32:33 <Pegazus> IsOnCache()  is O(1)
00:32:36 <int-e> i.e. the only idea that is missing is accounting the time spent on IsOnCache() to the caller of solve().
00:32:38 <Pegazus> and OnCache is O(1)
00:33:04 <Pegazus> i need a real "formal" proof, and i don't know how to do it :/
00:33:11 <int-e> (which is solve() again, but for another subproblem.)
00:33:28 <Pegazus> yes, but solve may take up to O(n^3)
00:33:33 <Pegazus> including the subproblems
00:35:54 <int-e> Nah, the idea is account the work done for each subproblem to the subproblem. I.e. you have for each problem p, a value c_p which is the number of steps spent on working on that subproblem. The total cost is the sum of all those small costs; if you can show that c_p = O(1) then your total cost will be O(|P|) where P is the set of all subproblems.
00:36:42 <int-e> So all you need to do is to associate the computing steps with the subproblems in such a way that c_p = O(1).
00:41:39 <Pegazus> thanks1
00:42:34 <dons> arg. ACM must have one of the slowest sites ever built
00:44:16 <sethk> dons, its O(n^3)  :)
00:44:51 <dons> I think it  must be.maybe 2^n
00:45:38 <int-e> Oh well. Software gets slower faster than hardware gets faster. (Who said that?)
00:45:53 <sethk> dons, I'm starting to test the new client/server code tonight.  I have four servers on this project now.  If things go well they'll all be using the new code (and all their clients of course) by the end of tomorrow.
00:46:03 <Pegazus> Wirths
00:46:17 <int-e> thx
00:46:34 <sethk> dons, deployed in Seattle on Monday, and Taiwan a day or two after that (assuming nothing important is discovered in Seattle, of course)
00:46:38 <dons> cool!
00:46:50 <dons> that's a mind boggling schedule for a  phd student
00:47:15 <dons> "respect" as Ali G would say :)
00:47:36 <sethk> dons, the new software let's them process about twice as many units per day, and they want to get it onto the production line quickly
00:48:00 <sethk> dons, too quickly, actually, but the new software is so much more stable than the old system that I really can't blame them
00:48:26 <sethk> dons, people are noticing how quickly bugs get fixed and that the bugs only have to be fixed once.  :)
00:49:37 <sethk> dons, the combination of C code and a coder who didn't understand threaded programming, but insisted on using it anyway ...
00:49:57 <sethk> dons, the old stuff has bugs popping up after running for several years.
00:50:18 <sethk> dons, and every time the hardware changes enough to effect timing relationships, the old system flakes out.
00:51:51 <sethk> dons, I also need to fold in your idea about the Configurable class.
00:52:02 <sethk> dons, and preprocess the config file to allow comments
00:52:23 <sethk> dons, but basically the config files are easy to read and people are not having any problems using them.
00:52:30 <dons> agreat stuff. I'm pleased  things are running smoothly.
00:52:39 <sethk> dons, so am I.
00:52:48 <sethk> dons, I'm sure there are other opportunities for abstraction
00:53:18 <sethk> dons, I have to build a front end and create a customer diagnostic program.  that's probably the next phase.
00:53:23 <dons> right. should  be   fairly easy to  bring in tthe Configurable class.
00:53:34 <sethk> dons, yes, it's simpler than the client/server stuff.
00:53:41 <sethk> dons, not really any tricky type issues that I can see.
00:53:47 <dons> you  currently use 'Show'-n  data structures for the config files?
00:54:18 <sethk> dons, right.  I use the record syntax   Constructor { parameter :: type, param2 :: type ...}
00:54:34 <sethk> dons, and the config file is just what is output by hPrint
00:54:44 <sethk> dons, and I add newlines to put each parameter on a separate line
00:54:58 <dons> yep. it practically reads itself :)
00:55:37 <dons> just  need to filter out ^-- lines so users can comment things.
00:55:55 <sethk> dons, right, although since we are filtering, I might use a more common comment delimeter
00:56:26 <sethk> dons, the record capability is really quite powerful.  Using it for the client/server messages, I can sniff the packets and read the data
00:56:57 <sethk> dons, any heterogenous representation problems are eliminated because the representation is all text
00:57:07 <dons> oh, good point
00:57:15 <sethk> dons, so the client and server can be different architectures and I don't have to care at all
00:57:26 <sethk> dons, byte ordering, float representation, I don't care.  :)
01:01:04 <sethk> dons, with the Integer type long values are easy.  MAC addresses, e.g., are 6 bytes.  But it's just a number, and we don't care that it is larger than the natural integer size
01:02:26 <dons> :) that's a  good use of Integer
01:03:29 <dons> so are you getting things done on schedule, I  guess? you're productivity is improved?
01:03:39 <dons> or is  it too early to tell?
01:03:54 <sethk> dons, a bit early.
01:04:04 <sethk> over the last month, though, my productivity has been excellent
01:04:23 <sethk> with a new language, there is that period where you have to think about everything
01:04:51 <dons> yep. we've seen  that over this weekend, and fair enough.
01:05:24 <sethk> dons, still, there is almost no debugging time, which makes a huge difference.
01:05:36 <sethk> dons, I'm going to replace the last big chunk of C code tomorrow.
01:05:49 <sethk> dons, then I'll be able to judge the productivity going forward.
01:06:23 <dons> Launchbury, at Galois, a Haskell company, has often talked about howw they were , in the  early days of the company, just able to hit  deadline after deadline. so much so, that the people at the end became the bottleneck..
01:06:52 <sethk> dons, I'm way ahead of the people producing the software that runs on the box
01:07:42 <sethk> dons, I also have needed to get enough experience to do accurate estimates.
01:08:03 <dons> that's a  good point that taking out debug time makes a hugh difference.  a bit more compilee time  (getting  type checking)  but that's  made up for by no segfault chasing.
01:08:16 <sethk> dons, more than made up for.
01:08:19 <sethk> much more.
01:08:36 <sethk> dons, plus, with the C code, how do you know it works?  That no major bugs remain?
01:09:19 <sethk> dons, the real payoff for this company though is on the next product.  It's a completely different platform, but only about 300 lines of my system are in any way platform dependent.
01:09:48 <sethk> dons, they key for me here was when I learned to use FFI effectively
01:10:05 <dons> nice.
01:10:11 <sethk> dons, which wasn't really terribly difficult, but I had anticipated that it would be harder and put it off for a while
01:10:16 <dons> you can start using hhaskell  as a glue between ffi pieces.
01:10:33 <sethk> dons, I'll have to look at it.
01:10:51 <sethk> dons, thus far the FFI is basically a bridge to modified device driver interfaces
01:11:16 <sethk> dons, and as such it also becomes a sort of natural boundary at the software hardware intersection
01:12:00 <sethk> dons, so by choosing the C side functions carefully (which I believe I have), that FFI boundary is where the machine dependencies are burried
01:12:53 <sethk> dons, I make a call to the FFI to write a MAC address for a NIC.  The C code know about the functions I've added to the device driver to accomodate tis
01:13:08 <sethk> dons, the haskell code knows only about the interface, which is quite high level and simple.
01:13:38 <sethk> dons, so, when I have to write a MAC to a completely different NIC on a different platform, everything that will change is within the C side of the FFI
01:14:03 <sethk> dons, and that let's me keep all the symantically significant processing separated from hardware specific stuff.
01:14:46 <dons> mm. makes sensee
01:14:51 <sethk> dons, another example, I retrieving error information collected by the NICs.  Every NIC accumulates different diagnostics and statistics.
01:15:26 <sethk> dons, but by passing strings of "name=value", I made the mechanics of accessing the data independent of the code that uses the data.
01:15:53 <sethk> dons, it would take a bit more detail to explain it, but I think you know where I'm going.
01:16:33 <sethk> dons, the only thing I'm still concerned about is that have used unsafePerformIO is a handful of places.
01:16:33 <dons> yep. getting high level on this  stuff just makes things more stable and easier
01:17:19 <sethk> dons, and I think I may have needed to use a monad to avoid this, but I decided that I couldn't take the time for the monads right now.
01:17:39 <dons> usually unsafePerformIO is  used in  a safe manner. the unsafe'
01:17:45 <dons>  bit just means you need to check yourself
01:17:49 <dons> rather than  relying on the type  system
01:17:56 <sethk> dons, I'll work out a stripped down example, and we can look at the possible options.
01:18:18 <sethk> dons, yes, true, but the one and only crash was caused by an unsafePerformIO, and I still have not tracked down what happened.
01:18:39 <sethk> dons, and I think I'm using it because I don't fully understand the better alternatives.
01:19:02 <dons> ah. most probably.
01:19:08 <dons> its very rarely needed
01:19:20 <sethk> dons, looking at one case, the State monad might have done perfectly, but I'm still confused about the semantics of using a monad from within another monad.
01:19:35 <dons> and certaainly not in normal haskell code (usually for making pure ffi code,  like strlen)
01:20:19 <dons> sure. stacking monads can  be a bit hard to get into.  but they're dead simple to use.
01:20:23 <sethk> dons, I'm "in" the IO monad.  I need functionality from the State monad (well, I need state; the state monad may nor may not be the solution, but some sort of monadic solutions is likely best)
01:20:45 <sethk> dons, I do understand using monads now.
01:21:05 <dons> so you'd use StateT (a state monad layered over IO), I think.
01:21:26 <dons> which gives you access to both monads, in essence
01:21:51 <sethk> dons, yes, that looked like what I should use.  I just have to study a bit more about what the environment actually is when you layer one monad over another.
01:22:11 <dons> yep.
01:22:18 <sethk> dons, tomorrow, if you are around, maybe we can spend some time with me on this.
01:22:26 <dons> sure. should be  ok.
01:22:42 <sethk> great.  I'll try to have a stipped done sample ready to go.
01:23:04 <sethk> and if I can get rid of the unsafePerformIO, and would very much like to do so.
01:23:25 <dons> ok.  yep, example code is the easiest way to proceed, I think.
01:23:39 <sethk> Part of the way I sold them on my using Haskell was the (it can't crash, can't be attacked in the typical hacking attacks, etc.)
01:23:39 <dons> it worked weell with the config stuff, and with yesterday's server code.
01:23:58 <sethk> yes, worked wonderfully for me, as long as I'm not consuming too much of your time.
01:24:15 <dons> :) I work on my various   things,  and just check irc. it's not too big a  drain :)
01:24:33 <dons> yeah, I've not heard of traditional attacks on haskell code.
01:24:39 <sethk> dons, in the back of my mind I'm trying to see if there is a viable Haskell company that we can grow out of this project.
01:25:01 <sethk> dons, I'm not sure I'm enough of a business type to do it
01:25:03 <dons> we did have some clever type haccking tricks on lambdabot's eval code.. but  it's evaluatting random code over the internet,  so we had to think about the  corners
01:25:32 <sethk> lambdabot is really amazing
01:25:49 <dons> hmm. I don't know. I think there really is  an army of people out there who'd work on Haskell code for practically nothing. .. I would
01:26:12 <dons> and we know we can do some much. it's just a  much more productive way to approach software dev.
01:26:17 <sethk> dons, that would be ok for a limited time to get a venture off the ground.
01:26:26 <dons> but I doon't know the  economics of this stuff.
01:26:48 <sethk> dons, I do know the economics, from working in the industry for so long.  The economics are not the difficult part.
01:27:22 <sethk> dons, the difficult part is convincing clients that "ok, I believe everything you say about it's advantages, if you get hit by a bus can I find someone to finish it?"
01:27:42 <sethk> dons, for some reason people I talk to seem to like to think about me getting hit by a bus  :)
01:27:58 <dons> yes. shapr suggested we create some kind of  resource for a  pool of haskell prograammers
01:28:08 <dons> to reasssure people that more haskellers can be found
01:28:12 <sethk> dons, I think that can be overcome.  Hows this for a company name:   Bullet Proof Software.
01:28:19 <dons> nice!
01:28:50 <sethk> dons, and our claim to fame it this:  Everyone else in the world give you software with a legal agreement that says "it may not work, and if it doesn't, that's your problem"
01:28:51 <dons> and good  to see  the 'high assurance'  hints  in  the name
01:29:19 <dons> ah! :)
01:29:22 <sethk> dons, to make it work, though, we would have to go a step farther.  We would have to say "if it doesn't work, we'll fix it."
01:29:42 <sethk> dons, there's issues with that (what does "doesn't work" really mean)?
01:30:03 <dons> have you had a look at galois.com? 
01:30:10 <sethk> dons, but from a marketting viewpoint, I think "WE ARE THE ONLY ONES SELLING SOFTWARE THAT DOES WHAT IT CLAIMS IT DOES"
01:30:35 <sethk> dons, not for a while.  I actually flew out there for a day to talk to some of those people.
01:30:39 <dons> yeah. I'd not  thought of that angle  before, but its  exactly what we say we can do.
01:30:48 <dons> oh, you met  them, cool.
01:30:57 <sethk> dons, but then the tech bust happened, and I had to scramble to pay the rent.
01:31:14 <sethk> dons, and we CAN do it.
01:31:53 <sethk> WE GUARANTEE THAT THERE ARE NO buffer overflows possible.
01:32:14 <basti_> .o° ( ? )
01:32:16 <sethk> dons, you get the general idea.
01:32:36 <sethk> dons, that's the thing, IMO, that is a big hole in the industry waiting to be filled.
01:32:41 <dons> yeah, there's a reason the haskell code keeps winning the icfp contests, while the C, C++ code segfaults its  way out.
01:32:50 <sethk> dons, absolutely.
01:33:06 <sethk> dons, at it has become possible because the hardware is not so cheap.
01:33:14 <dons> better, more  robust code, that satisfies  the spec, written faster.
01:33:27 <sethk> dons, absolutely.
01:33:37 <basti_> did i mention i took a lecture about proofcheckers?
01:34:00 <sethk> dons, and we say that my product, which will be running on four different production lines, has never had a failure.
01:34:05 <tizoc> hi, is Yi still being developed?
01:34:11 <sethk> basti_, no interesting
01:34:40 <sethk> dons, anyway, think about it.  If we can develop the idea, I can come up with some cash to help get it started.
01:35:09 <dons> tizoc, i  haven't had  much time to work on it. currently, its a useable vim or mg replacement, without the fancy  bits.
01:35:38 <tizoc> dons: ok
01:35:59 <dons> setthk, I will :) I've got  to work out what happens when my phd finishes this year.
01:39:34 <dons> hmm. I see galois  is  continuing to hire..
01:39:58 <dons> http://galois.com/join.php
01:40:30 <sethk> dons, interesting.  Oh no, we'll have a haskell coder shortage !!!
01:41:03 <dons> its a buyers market atm. you get your pick of phd-level hackers.
01:41:15 <sethk> dons, indeed.
01:42:00 * dons <- dinner
01:42:02 <sethk> dons, I instinct is towards starting off with a produce.  Something that is a security headache, where we can supply a bullet proof, hacker proof solution.
01:42:03 <dons> ciao!
01:42:23 <sethk> dons, ciao.  I can always do my speach about this.  :)
01:42:32 <dons> ok. we can talk later :)
01:43:11 <dons> oh, you might want  to look at pass.net.  that's  another haskell product/company
01:43:14 <sethk> yes, thanks as usual
01:43:42 <sethk> dons, if we get serious, we'll have to look at any the exist, especially if they survive.
01:44:37 <sethk> dons, but I believe the way to start the company is to build a bullet proof app that can be quickly deployed.  The characteristics are what we have to sell.
01:44:46 <sethk> I could be wrong
01:45:02 <sethk> I'll let you go and tell you more of my ideas when you have time.
01:45:06 <sethk> 'night
02:11:37 <tvoss> hi @ll ... could someone give me a hint how to calculate the list of integer divisors of an integer a?
02:12:02 <basti_> try all of them? ;)
02:12:58 <_Stinger_> be grateful factorization is hard :)
02:13:38 <tvoss> basti_: *smile* I had the same idea but I thought there would be a more efficient way ;)
02:14:02 <tvoss> thx anyway :)
02:14:09 <basti_> ;)
02:14:23 <basti_> you could reduce that to try to divide by primes
02:15:27 <_Stinger_> but then you have to find primes :)
02:15:48 <tvoss> for sure ;)
02:16:18 <tvoss> how about trying all integer divisors in {0...9} and assembling the rest? ;-9
02:16:34 <tvoss> *smile* in {1...9}
02:16:42 <_Stinger_> assembling?
02:17:01 * basti_ doesnt know either
02:17:19 <basti_> tvoss: is that homework?
02:17:30 <tvoss> basti_: Not at all ... interest:-)
02:17:33 <basti_> ah i see
02:17:42 <basti_> then you should try the easiest approach first, anyway
02:18:40 <Cale> _Stinger_: do you know how to factor a number into primes?
02:19:16 <Cale> er
02:19:22 <Cale> tvoss rather
02:19:31 <tvoss> Cale: ?
02:19:36 <Cale> You can just factor the number into primes
02:20:33 <Cale> and then every divisor is a product of some subset of those primes
02:21:32 <Cale> more precisely, if a = p_1^a_1 p_2^a_2 ... p_n^a_n, and b is a divisor of a, then b = p_1^b_1 ... p_n^b_n, where 0 <= b_i <= a_i
02:23:18 <Cale> Or you could just compute n mod k for each k from 1 up to n, and the divisors are those values for which this is 0.
02:23:27 <goltrpoat> alternatively, let n_1 = n.  say m_1 is the smallest divisor of n_1.  then a) m_1 is prime, b) (m_1)^2 < n_1 (restricting the search a bit).  let n_2 = n_1 / m_1.  say m_2 is the smallest divisor of n_2.  etc.
02:23:59 <Cale> well, that's how to actually do the factorisation
02:24:14 <tvoss> Cale: wow ;)
02:24:40 <basti_> everybody knows that, but other people don't boast with it ;)
02:24:49 <goltrpoat> well.. i got thrown but the 'compute n mod k for each k from 1 up to n' bit
02:24:56 <Cale> basti_: who's boasting?
02:25:00 <basti_> :P
02:25:14 <goltrpoat> ie you only need to go up while k^2 < n, and stop at the first k = 0 (mod n)
02:25:18 <goltrpoat> but=by
02:25:43 <Cale> goltrpoat: but you still have to construct the list of divisors from your primes afterward
02:25:57 <Cale> goltrpoat: since you'll only get a bunch of prime factors then (with multiplicities)
02:26:18 <goltrpoat> oh, composite divisors are required as well?
02:26:25 <Cale> I'd assumed so
02:26:57 <Cale> Factoring into primes and then using them to construct the other divisors is good though.
02:27:11 <Cale> Especially for something like 2^100 ;)
02:27:12 <tvoss> Cale: I think I'll try that approach
02:27:53 <goltrpoat> hehe yah.  hmm, i have 100 instances of 2.  how do i make 2^100 out of that.  let's see.  2*2?  nope.  2*2*2?  nope.
02:28:08 <goltrpoat> maybe 2*2*2*2?  crap, this may take a while.
02:28:17 <goltrpoat> :)
02:28:21 <tvoss> ;)
02:29:11 * tvoss gets back to emacs and keeps on learning haskell and number theory;)
02:29:39 <Cale> More like, "Is 126765060022822940149670320537 a divisor? No. is 126765060022822940149670320538 a divisor? No...
02:29:46 <goltrpoat> heheh
03:21:03 <Lemmih> D'oh. Note to self: Don't revert CAFs when GHC is dynamically loaded.
03:21:20 * xerox takes note
03:31:56 * ADEpt just posted chapter 4 of http://www.haskell.org/haskellwiki/Hitchhikers_Guide_to_the_Haskell
03:34:17 <LPhas> Hi, anyone knows how to get gtk2hs on macosx?
03:35:34 <xerox> Hey Phas.
03:35:39 <LPhas> hey :D
03:37:07 <LPhas> google is not helping
03:37:09 <LPhas> :/
03:37:17 <LPhas> macosx uses a strange format for libraries
03:39:35 <xerox> Yes indeed.  Duncan is on vacation here in Italy, though :-)
03:40:04 <LPhas> d'uh
03:48:24 <_cb> hello. i was wondering what 'tagging' meant when it came to types? i've googled but to no avail.
03:50:01 <davidhouse> what does haskell have in the way of printf() style functions?
03:50:03 <davidhouse> @hoogle printf
03:50:04 <lambdabot> Text.Printf.printf :: PrintfType r => String -> r
03:50:04 <lambdabot> Text.Printf :: module
03:50:04 <lambdabot> Text.Printf.hPrintf :: HPrintfType r => Handle -> String -> r
03:50:08 <davidhouse> oh :)
03:50:15 <davidhouse> @docs Text.Printf
03:50:16 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Text-Printf.html
04:01:13 <ADEpt> _cb: I thinks that "tagging" loosely means this: (a :: Int) is an Int, ( data T a = T a ; a:: T Int) is a "tagged" Int
04:01:55 <_cb> ahh, that makes sense. thanks!
04:50:47 <davidhouse> @docs Reader
04:50:48 <lambdabot> Reader not available
04:50:57 <davidhouse> @docs Control.Monad.Reader
04:50:58 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Reader.html
04:51:23 <davidhouse> it'd be more useful if @docs searched the whole tree
05:03:45 <kisu> sp
05:07:15 <davidhouse> @index (<>)
05:07:16 <lambdabot> Language.Haskell.TH.PprLib, Text.PrettyPrint.HughesPJ, Text.PrettyPrint
05:08:36 <davidhouse> @hoogle choice
05:08:37 <lambdabot> Text.ParserCombinators.ReadP.choice :: [ReadP a] -> ReadP a
05:08:37 <lambdabot> Text.ParserCombinators.ReadPrec.choice :: [ReadPrec a] -> ReadPrec a
05:08:37 <lambdabot> Text.ParserCombinators.Parsec.Combinator.choice :: [GenParser tok st a] -> GenParser tok st a
05:09:39 <JKnecht> Complete failure attempting recogition of 'goltrpoat' as a collapsed NP, nominal sentence, acronym, or other terminal linguistic construct. #haskell scanned from 1/6/1. Also underivable from 'Vlad Andreev'.
05:10:01 <JKnecht> recognition, even.
05:16:10 <dons> ?brain
05:16:11 <lambdabot> I think so, Brain, but culottes have a tendency to ride up so.
05:16:37 <xerox> Pink and the Brain?
05:16:42 <xerox> Pinky, err.
05:18:27 <dons> ?help brain
05:18:28 <lambdabot> brain. Pinky and the Brain
05:18:35 <dons> xerox gets  a  gold star!
05:20:26 <dons> :)
05:21:17 <JKnecht> ?help
05:21:18 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
05:23:19 * xerox jumps happily
05:23:43 * davidhouse hugs Reader
05:24:11 <xerox> ?brain what are we going to do tonight?
05:24:11 <lambdabot> I think so, Brain, but isn't that why they invented tube socks?
05:24:30 <xerox> ?pinky what are we going to do tonight?
05:24:30 <lambdabot> Unknown command, try @list
05:28:35 <davidhouse> @quote pinky
05:28:36 <lambdabot> pinky hasn't said anything memorable
05:28:54 <davidhouse> @quote-add pinky what are we going to do tonight?
05:28:55 <lambdabot> Unknown command, try @list
05:29:34 <davidhouse> @quote+ pinky what are we going to do tonight?
05:29:39 <davidhouse> @quote pinky
05:30:06 <lambdabot> pinky what are we going to do tonight? hasn't said anything memorable
05:30:08 <lambdabot> pinky hasn't said anything memorable
05:30:16 <davidhouse> @remember pinky what are we going to do tonight?
05:30:16 <lambdabot> Done.
05:30:21 <davidhouse> @quote pinky
05:30:21 <lambdabot>  what are we going to do tonight?
05:30:38 <davidhouse> @remember brain the same thing we do every night. try to take over the world!
05:30:38 <lambdabot> Done.
05:31:14 <davidhouse> xerox, better?
05:31:39 <xerox> @vixen better?
05:31:39 <lambdabot> let's don't talk about that
05:31:47 <davidhouse> @localtime dons
05:31:48 <lambdabot> Local time for dons is Sun Apr  9 22:32:29 2006
05:31:54 <davidhouse> dons, around?
05:33:01 <xerox> http://www.unc.edu/~mumukshu/gandhi/gandhi/hofstadter.htm
05:38:54 <jyp> @pinky
05:38:54 <lambdabot> Unknown command, try @list
05:39:00 <jyp> ?pinky
05:39:01 <lambdabot> Unknown command, try @list
05:39:05 <jyp> ?brain
05:39:06 <lambdabot> Narf!
05:47:56 <Bobstopper> is there any simple way to "find" using pattern matches? Or can pattern matches be passed as first class objects to make that possible? Or is the only real solution to implement is* functions like isJust etc?
05:53:04 <flux__> there is a whitepaper on implementing views, which would allow what you want, but as present, your best option is to use functions (with pattern matching guards, maybe)
05:53:15 <davidhouse> Bobstopper: map with a pattern-matching lambda
05:53:22 <Saulzar> Bobstopper, Yeah. Though there are some tools to autogen such isFoo functions
05:53:27 <davidhouse> or better, with a case.
05:53:55 <flux__> hm, maybe I misunderstood the problem ;)
05:53:56 <Bobstopper> davidhouse: that's basically defining an is* function...
05:55:14 <davidhouse> > filter isJust $ map (\s -> case s of 'a':'b':_:[] -> Just s; _ -> Nothing) ["123", "xyz", "abc"]
05:55:16 <lambdabot> [Just "abc"]
05:55:20 <Bobstopper> I'm just noticing I'm having to define a lot of is* functions which to me says I'm missing an abstraction. I guess I'm spoiled by lisp macros...
05:55:45 * davidhouse wonders
05:55:55 <davidhouse> > sequence [Just "abc", Nothing]
05:55:55 <lambdabot> Nothing
05:56:18 <davidhouse> > sequence $ filter isJust $ map (\s -> case s of 'a':'b':_:[] -> Just s; _ -> Nothing) ["123", "xyz", "abc"]
05:56:19 <lambdabot> Just ["abc"]
05:56:35 <davidhouse> could be made prettier with MonadPlus
05:58:00 <davidhouse> > foldl mplus mzero $ map (\s -> case s of 'a':'b':_:[] -> Just s; _ -> Nothing) ["123", "xyz", "abc"]
05:58:01 <lambdabot> Just "abc"
05:58:22 <davidhouse> sadly you can't generalise because there's no type of patterns.
05:59:44 <Bobstopper> Yeah... that's what I was feeling was missing. If I could pass patterns around first class, I could define abstractions such as a generic "is" function which takes a pattern and an object and returns true if it matches...
06:00:02 * davidhouse thinks there should be a shortcut function for foldl mplus mzero
06:14:50 <xerox> davidhouse, [x | x <- xs, "ab" `isPrefixOf` x]
06:15:14 <xerox> foldr mplus mzero = sequence
06:16:23 <Saulzar> A little different...
06:19:08 <Saulzar> Ah hah..
06:19:15 <Saulzar> foldr mplus mzero = msum
06:23:11 <Saulzar> Hmm, foldr and foldl seem to give the same result because thier arguments to mplus are switched
06:31:26 <davidhouse> Saulzar: yeah, for a list of Maybes, msum would find the last Just _, whereas we want the first.
06:32:00 <davidhouse> anyway, got to dash.
06:32:13 <Saulzar> > msum [Just 1, Just 2, Just 3]
06:32:14 <lambdabot> Just 1
06:33:19 <Saulzar> I guess it is a foldl then
06:43:37 <xerox> Right.
07:34:10 <_Stinger_> gees ghc takes a while to compile
07:53:16 <JohnnyL> does => mean 'convert to'?
07:53:27 <resiak> It means ,
07:53:40 <JohnnyL> which means?
07:53:52 <resiak> More accurately,  foo => 6  means  "foo", 6  --- => quotes the thing to the left of it
07:53:56 <resiak> s/thing/bareword/
07:54:01 <xerox> JohnnyL, in type signatures => is used to introduce the constraints before the actual type.
07:54:05 <resiak> argh, sorry
07:54:11 <resiak> I can't read what channel I'm on
07:54:14 <xerox> Hah.
07:54:49 <xerox> I.e. you extend the usual <name> :: <type> syntax with <name> :: <constraints> => <type>.
07:55:48 <xerox> The constraints tells about classes membership for type variables.  For example, since (+) sums only numbers, its type isn't (+) :: a -> a -> a, but, (+) :: (Num a) => a -> a -> a.
07:56:10 <xerox> To know what are the current instances loaded for some class type :info Class in your interpreter of choice.
07:59:49 <JohnnyL> that means the constraint on the left signfies a type which is applied to instanced on the right of the :type query?\
08:00:11 <xerox> Err.... what?
08:00:56 <JohnnyL> sorry.
08:01:25 <ski> > msum [Just 1, Just 2, Just 3]
08:01:26 <lambdabot> Just 1
08:01:30 <JohnnyL> I mean (Num a) contrains all instances on the right of the => which are 'a' to Num a?
08:01:32 <ski> > foldr mplus mzero [Just 1, Just 2, Just 3]
08:01:33 <lambdabot> Just 1
08:01:35 <ski> > foldl mplus mzero [Just 1, Just 2, Just 3]
08:01:35 <lambdabot> Just 1
08:02:19 <xerox> JohnnyL, Num a constraints the type a to be an instance of Num, and 'a' could appear multiple times in the type, yes.
08:03:34 <JohnnyL> => = contrains to the preformentioned type following to the right.
08:04:00 <mauke> > 1 :: (Monad m, Num a) => a
08:04:01 <lambdabot>   Ambiguous constraint `Monad m'
08:04:01 <lambdabot>    At least one of the forall'd type variables mentioned by the constraint
08:04:01 <lambdabot>    must be reachable from the type after the '=>'
08:06:15 <_Stinger_> lo mauke
08:07:17 <JohnnyL> > 1 :: (Num a ) => a
08:07:18 <lambdabot> 1
08:07:30 <JohnnyL> > 33 :: (Num a ) => a
08:07:31 <lambdabot> 33
08:07:41 <JohnnyL> > "33" :: (Num a ) => a
08:07:42 <lambdabot>  a
08:07:42 <lambdabot>   Inferred type: [Char]
08:07:42 <lambdabot>   In the expression: "33" :: (Num a) => a
08:12:28 <JohnnyL> hey paul.
08:30:05 <JohnnyL> where can i get  list of keyword defs? like whats ord mean?
08:30:32 <flux__> from the haskell report?
08:30:46 <Igloo_> ord isn't a keyword, it's a function
08:31:09 <Igloo> And yes, in the Haskell 98 report
08:31:32 <Igloo> Although you might prefer to look at http://www.haskell.org/ghc/docs/latest/html/libraries/index.html instead
08:31:52 <JohnnyL> thx
08:32:54 <JohnnyL> no ord there
08:33:13 <flux__> @index ord
08:33:14 <lambdabot> Data.Char
08:35:13 <vincenz> Anyone know if it's possible to filter all email for duplicates?
08:36:08 <ibid> depends on your definition of "duplicate", but if your definition is implementable, then yes
08:36:22 <flux__> vincenz, maybe you want to take a look at formail
08:36:40 <flux__> it has a dupe filtering capability; I think it matches only be duplicate message-ids
08:37:04 <vincenz> flux__: basically I forward all my work email to gmail
08:37:09 <vincenz> and I'm pop getting them both with thunderbird
08:37:19 <vincenz> (work email onyl at work, can't access from outside, hence the reason for forward)
08:37:25 <vincenz> obviously this'll lead to a lot of duplication
08:37:37 <JohnnyL> :load /dl/haskell/t.hs
08:37:38 <JohnnyL> ERROR "/dl/haskell/t.hs":21 - Undefined variable "ord"
08:38:04 <ibid> vincenz: you might want to consider using fetchmail as your pop client. then you can use procmail/formail to detect duplicates
08:38:44 <vincenz> sounds complicated
08:39:54 <flux__> > List.map Data.Char.ord "hello"
08:39:54 <lambdabot> [104,101,108,108,111]
08:39:55 <Saulzar> JohnnyL, It's in a module (Data.Char), the document Igloo posted has the details, also haskell.org/hoogle is good for searching
08:40:04 <vincenz> be cool if you could access email from haskell
08:40:07 <vincenz> and write your own code :)
08:40:13 <ski> 2hoogle ord
08:40:22 <ski> @hoogle ord
08:40:22 <lambdabot> Char.ord :: Char -> Int
08:40:22 <lambdabot> Prelude.Ord :: class Eq a => Ord a
08:40:22 <lambdabot> Text.Html.ordList :: HTML a => [a] -> Html
08:43:48 <JohnnyL> Saulzard, where is the Igloo post?
09:16:21 <xerox> What's the standard Arrow way to do (a,_) -> a ?
09:17:04 <mauke> @type arr
09:17:04 <lambdabot> Not in scope: `arr'
09:17:15 <xerox> ?type Control.Arrow.arr
09:17:17 <lambdabot> forall (a :: * -> * -> *) c b.
09:17:17 <lambdabot>        (Control.Arrow.Arrow a) =>
09:17:17 <lambdabot>        (b -> c) -> a b c
09:17:26 <xerox> You mean, arr fst. ?
09:17:49 <xerox> I wonder how one is supposed to get *a* result off an Arrow computation.
09:17:51 <mauke> no idea, I've never used arrows before
09:17:56 <xerox> Okay.
09:19:39 <xerox> ?type dropWhile
09:19:40 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
09:20:28 <metaperl> is anyone running ghci under Windows? when I run it under Cygwin, all the lines via ^M after them. anyway to get rid of this?
09:20:53 <integral> xerox: like monads the function to run an array is defined by the specific type of arrow you're using
09:20:56 <xerox> > let process = (takeWhile (/=' ') &&& dropWhile (/=' ')) >>> first ((++"> ") . ("<"++)) >>> uncurry (++) in process "nick blah blah blah"
09:20:57 <lambdabot> "<nick>  blah blah blah"
09:21:17 <xerox> integral, hmmm.
09:23:03 <JohnnyL> ord isn't in ghci either, how to load it guys?
09:23:11 <xerox> :module + Data.Char
09:23:15 <xerox> ...or :m + Char
09:23:20 <xerox> :help for insights.
09:23:21 <ski> @hello
09:23:22 <lambdabot> Maybe you meant: help hylo
09:23:25 <ski> @arr
09:23:26 <lambdabot> This is the END for you, you gutter-crawling cur!
09:23:27 <ski> xerox : 'arr fst' ?
09:23:37 <ski> what do you mean by 'get *a* result off an Arrow computation' ?
09:24:13 <xerox> ski, do you see what I mean with that example?  Perform computations circuit-like, and squeeze out a result.
09:24:48 <xerox> But since we have curried function, I don't exacly know what's the idiomatic way to avoid ">>> uncurry f".
09:27:39 <ski> hrm
09:28:12 <ski> > (takeWhile (/=' ') &&& dropWhile (/=' ')) "foo bar baz"
09:28:13 <lambdabot> ("foo"," bar baz")
09:28:24 <ski> > span (/=' ') "foo bar baz"
09:28:25 <lambdabot> ("foo"," bar baz")
09:28:52 <xerox> Ah-ha.
09:29:32 <xerox> I would have gone for (nick:text) = words line, but it fsckup whitespaces.
09:29:50 <ski> myes
09:30:23 <ski> i'm not sure exactly what you're asking about re your example ..
09:30:46 <xerox> Nevermind.
09:31:21 <ski> that's just the usual function arrow, yes ?
09:31:31 <xerox> Yes.
09:32:08 <ski> > arr fst (1,2)
09:32:09 <lambdabot> 1
09:47:23 <Lemmih> dons: ping.
09:58:03 <araujo> good morning
10:02:56 <ski> good evening
10:05:49 <palomer> afternooning
10:08:40 <Philippa> 'lo
10:09:24 <tibbe> how are list comprehensions just syntactis sugar for monadic binds? could someone give an example to clarify?
10:10:08 <xerox> tibbe, <- are translated to >>= and other expression with 'guard'.
10:10:11 <mauke> [ foo x | x <- list, cond x ] == do { x <- list; guard (cond x); return (foo x) }
10:10:13 <xerox> ?type Control.Monad.guard
10:10:14 <lambdabot> forall (m :: * -> *).
10:10:14 <lambdabot>         (Control.Monad.MonadPlus m) =>
10:10:14 <lambdabot>         Bool -> m ()
10:10:57 <tibbe> ah thanks
10:12:48 * ski wonders why ppl use '==' and not '=' for expressing such semantic equalities
10:13:23 <mauke> because = is assignment
10:14:15 <Philippa> no, just habit
10:14:18 <Philippa> == is equivalence
10:15:53 <Philippa> insofar as I can find a stronger argument, it's that = is /definitional equality/. Assignment is a somewhat different notion :-)
10:15:54 <ski> mauke : there's no assignment in haskell
10:16:07 <Philippa> ski: there's much assignment in haskell - just no one assignment primitive :-)
10:16:23 <ski> Philippa : that's mutation
10:16:36 <xerox> â‰ˆ is better?
10:16:37 <ski> assignment changes variable bindings
10:16:53 <mauke> ski: where?
10:17:08 <ski> mauke : where what ?
10:17:19 <Philippa> not always true. Many/most C coders would describe *foo = ... as an assignment, for example
10:17:22 <mauke> in perl assignment doesn't change bindings AFAICS
10:17:25 <Philippa> the value of foo is unchanged...
10:18:31 <Philippa> "assigning a value to a storage cell" makes sense given that common usage
10:19:38 <ski> hm, yes 'assignment' is used like that often ..
10:20:01 <ski> hm .. but i wonder .. i've seen some arguments for making this distinction
10:20:04 <Philippa> I don't think the FP community has the right to tell imperative coders they've got their terminology wrong
10:20:13 <ski> no
10:20:18 <Philippa> I tend to refer to your notion as just "binding"
10:20:28 <Philippa> "we bind the value a to the variable b"
10:20:42 <ski> how about closures, then ?
10:20:53 <mauke> what about closures?
10:21:18 <ski> Philippa : can you read scheme ?
10:21:34 <Philippa> ski: basic stuff. Assume anything involving continuations'll need explaining
10:21:54 <ski> (define tick
10:22:00 <ski>   (let ((x 0))
10:22:05 <ski>     (lambda ()
10:22:13 <Philippa> continuations're the only reason I'd have to even care about closures though
10:22:17 <ski>       (let ((y x))
10:22:35 <ski>         (set! x (+ 1 x))
10:22:41 <ski>         y))))
10:22:51 <mauke> sub tick { my $i = 0; sub { my $y = $x; $x += 1; $y } }  # perl
10:22:51 <Philippa> updates something inna closure, right?
10:23:07 <Philippa> (without having read it properly and guessing at the point being made)
10:23:16 <metaperl> if a function could do this: fn 2 [1 .. 100]      => [ [ 1,2], [3,4], [5,6] ... ]   -- what would you name the function?
10:23:27 <ski> yes, assigns to the variable 'x'
10:23:45 <_Stinger_> metaperl pairthebastards
10:23:52 <metaperl> no
10:23:58 <metaperl> the 2 is a variable
10:24:03 <metaperl> is could be 3 or 4 or whatever
10:24:04 <_Stinger_> takegroups
10:24:09 <Philippa> in that module I'd consider x itself to be bound to a storage cell, unless scheme's semantics act differently from how that would?
10:24:13 <Philippa> er, in that model
10:24:19 <Philippa> my brain sucks...
10:24:29 <Philippa> metaperl: groupInto?
10:24:30 <_Stinger_> takenof
10:24:42 <metaperl> yes I like the "group" idea the best. thanks guys
10:24:45 <metaperl> and girls
10:24:46 <metaperl> :)
10:24:48 <Philippa> _Stinger_: no, it's what happens if you iterate that 'til you're out
10:24:58 <_Stinger_> yeah that 2nd one isnt good
10:25:13 <Philippa> metaperl: if it's Haskell, check List for related functions to see if there's an existing naming scheme to fit into
10:25:13 <ski> Philippa : variables in scheme are bound to locations, which holds values
10:25:35 <Philippa> ski: thought, cell/location being pretty much ML/scheme
10:25:36 <ski> Philippa : 'set!' changes which location a variable refers to
10:25:38 <Philippa> er, thought so even
10:25:41 <Philippa> *ah*
10:25:53 <Philippa> "rebinding"
10:26:04 <Philippa> (or just plain "binding"
10:26:04 <Philippa> )
10:26:05 <ski> Philippa : otoh, e.g. 'set-car!' mutates the value (cell) of a cons
10:26:15 * Philippa nods
10:26:17 <Philippa> that part I expected
10:26:25 <mauke> scheme is weird
10:26:52 <JohnnyL> :load /dl/haskell/t.hs
10:26:52 <JohnnyL> Compiling Main             ( /dl/haskell/t.hs, interpreted )
10:26:52 <JohnnyL> Failed, modules loaded: none.
10:26:53 <Philippa> (I know what car and cdr are, though I always expect them to be the other way round - probably because I know what the D stood for)
10:27:03 <ski> so, 'set!' means that variables don't stand for same thing, always .. 'set-car!' just means that there are side-effects
10:27:28 <ski> (contents of address and decrement register ?)
10:27:49 <Philippa> d'oh, yes. Not because I know what it stood for, but because my brain wants to yell "data!"
10:28:07 <ski> Philippa : there are people wanting to get rid of 'set!' for this reason (but not 'set-car!' or similar)
10:28:10 <Philippa> although it might wanna be the other way round, 'cos "address" is obviously the next link, right?
10:28:41 <mauke> > sort ["cdr","car"]
10:28:41 <Philippa> I'd sooner change set! to change the value@location myself
10:28:42 <lambdabot> ["car","cdr"]
10:28:44 <Korollary> the most miserably named two functions in the universe.
10:29:04 <Philippa> mostly just an amusing lack of abstraction that stuck around, IMO
10:29:07 <ski> Philippa : how would that work with unboxed values ?
10:29:25 <ski> (Philippa : or maybe it shouldn't be supported for those ?)
10:29:25 <Philippa> ski: point. Dynamically-typed languages suck ;-)
10:29:46 <Philippa> that'd work if you don't mind having to state unboxedness everywhere, yeah
10:30:04 <Philippa> of course, then you have to check for it...
10:30:09 <JohnnyL> i tried to load ord through :module + Data.Char but it doesn't work, any suggestions?
10:30:44 <ski> Philippa : i think some compilers for scheme introduce explicit 'new-box','box-ref','box-set!', just to get rid of 'set!' internally, so optimisations can be applied easier
10:30:52 <Philippa> :m +Data.Char?
10:30:52 <Lemmih> JohnnyL: Try importing Data.Char in your file.
10:31:10 <Philippa> er, yeah, modules need to state other modules they depend on
10:31:19 <Philippa> they have their own evaluation contexts, in effect
10:31:41 <Philippa> ski: doesn't surprise me. There're days I'm very very glad to be on the static side of that debate
10:32:14 <ski> but i think this isn't mostly about static / dynamic ..
10:32:54 <mauke> yeah, perl does it differently
10:33:27 <Philippa> ski: yep, I'm just wincing at the implementation issues
10:33:35 <Philippa> (and really glad about not having to worry about them)
10:33:42 <Philippa> don't worry, carry on :-)
10:34:31 <ski> it seems, in some sense 'set!'-like things are worse for ability of reasoning than 'set-car1'-like things ..
10:34:39 <ski> .. do you agree with this ?
10:35:24 <ski> (s/car1/car!/)
10:35:29 <JohnnyL> Lemmih, yeah it works! thx guys.
10:35:37 <JohnnyL> I just did an import and walla!
10:40:38 <Saulzar> vincenz, Are you about? I'm wondering if you ever did anything with that traversal/transformation stuff on the Indirect Composite. I'm just trying to use it for a slightly larger example.
10:42:22 <Philippa> ski: instinctively I would agree. I'm not sure I'm awake enough to do the maths
10:43:03 <ski> k
10:43:05 <Philippa> I'd have to consider eg who could find the thing being altered to fuck with it - IOW, what the graph-of-control looks like
10:43:26 <Philippa> also, on their own isn't as bad as in each others' presence
10:43:52 <Philippa> set! is a lot worse when locations are mutable because it's harder to know you've hung on to the one you think you have
10:44:38 <vincenz> Saulzar: re
10:45:34 <vincenz> Saulzar: had to think for a bit to know whtat you were referring to :D
10:45:43 <vincenz> Saulzar: yeah I kept using it in that projet
10:45:54 <ski> in any case, allowing changing what location (or value) a variable refers to complicates semantics
10:49:39 <vincenz> Saulzar: ping
10:49:45 <Saulzar> vincenz, It seems extremely useful, but the number of types is huge and the instance headers seem to grow rather large! 
10:50:13 <vincenz> Saulzar: yeah I also experienced some codeblowup
10:50:33 <Saulzar> Had somewhat of a job figuring out what they should be, using type inference for traversal for example simplifies it quite a bit
10:50:59 <vincenz> how so?
10:51:58 <Saulzar> Well you had a traverse :: Exp ... -> m Exp ...,  but using instances a typeclass it becomes somewhat annoying
10:52:09 <vincenz> well yeah
10:52:10 <Saulzar> instance (Monad m, Transform m i i', Transform m p p' ...
10:52:14 <vincenz> in the end you just keep redefining transforms
10:52:20 <xerox> http://lambda-the-ultimate.org/node/1406
10:52:23 <vincenz> it was a bit yucky
10:52:36 <vincenz> xerox: lol
10:52:51 <vincenz> xerox: that's a joke, right?
10:52:54 <xerox> Nope.
10:53:06 <palomer> @pl \x y z -> if x then y else z
10:53:06 <lambdabot> if'
10:53:12 <palomer> pffft
10:53:25 <xerox> palomer, but you have to write it somewhere, it's not in the libs.
10:53:51 <xerox> palomer, it could be also called 'bool', a-la 'maybe' and 'either'...
10:55:51 <palomer> eh?
10:56:06 <xerox> ?type (maybe,either)
10:56:06 <lambdabot> forall b a a1 c b1.
10:56:06 <lambdabot>       (b -> (a -> b) -> Maybe a -> b,
10:56:06 <lambdabot>        (a1 -> c) -> (b1 -> c) -> Either a1 b1 -> c)
10:56:27 <palomer> @ = ?
11:00:54 <palomer> @type (maybe,either)
11:00:55 <lambdabot> forall b a a1 c b1.
11:00:55 <lambdabot>       (b -> (a -> b) -> Maybe a -> b,
11:00:55 <lambdabot>        (a1 -> c) -> (b1 -> c) -> Either a1 b1 -> c)
11:01:23 <palomer> what kind of silly combinator is maybe?
11:03:18 <xerox> Why?
11:03:27 <xerox> It's a fromJust with defaulting.
11:07:29 <palomer> ah, didn't know
11:08:14 <xerox> > fromJust Nothing :: Int
11:08:15 <lambdabot> Exception: Maybe.fromJust: Nothing
11:08:21 <xerox> > maybe 0 Nothing :: Int
11:08:22 <lambdabot> Couldn't match `Int' against `t -> t1'
11:08:36 <xerox> > maybe (const 0) Nothing :: Int
11:08:37 <lambdabot> Couldn't match `Int' against `t -> t1'
11:10:10 <wolverian> > maybe 0 id Nothing :: Int 
11:10:11 <lambdabot> 0
11:12:27 <JohnnyL> in map ord ['H'] where is the display function for the interpreter?
11:14:00 <Korollary> @type map Data.Char.ord ['H']
11:14:01 <lambdabot> [Int]
11:14:30 <Korollary> > show [ 1::Int ]
11:14:30 <lambdabot> "[1]"
11:19:01 <JohnnyL> are you saying show is tied to each function?
11:19:21 <wilx> show is defined for many types.
11:19:42 <Korollary> No, some types are instances of Show. The interpreter tries to 'show' the results.
11:23:19 <araujo> > let f x = x + 1 in show f
11:23:20 <lambdabot>  add an instance declaration for (Show (a -> a))
11:23:20 <lambdabot>   In the definition of `nme': nme = let f x = x + 1 in show f
11:23:20 <lambdabot>   In the definition of `v': v = let nme = let ... in ... in take 2048 (show nme)
11:23:36 <araujo> JohnnyL, that's what happens when it isn't an instance of show
11:24:59 <norpan> > v
11:25:00 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
11:25:00 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
11:25:00 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
11:25:00 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
11:25:02 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
11:25:05 <lambdabot> [6 @more lines]
11:25:05 <norpan> wee
11:25:27 <norpan> backslash baby
11:28:49 <vincenz> > v
11:28:50 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
11:28:50 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
11:28:50 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
11:28:50 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
11:28:53 <vincenz> what is v?
11:28:53 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
11:28:54 <vincenz> @type v
11:28:56 <lambdabot> [6 @more lines]
11:28:58 <lambdabot> Not in scope: `v'
11:29:04 <vincenz> what is v???
11:29:08 <bolrod> O_o
11:29:42 <vincenz> > m
11:29:43 <lambdabot>  Not in scope: `m'
11:29:47 * vincenz ponders
11:29:51 <vincenz> where does v come from
11:30:09 <bolrod> looks like seperate strings... 
11:30:11 <sieni> wtf?
11:30:12 <bolrod> > length v
11:30:13 <lambdabot> Exception: <<loop>>
11:30:13 <Saulzar>  lambdabot's state facility or something?
11:30:13 <Korollary> It's a secret backslash organization
11:30:18 <vincenz> bolrod: it's infinte
11:30:29 <bolrod> > head v
11:30:30 <lambdabot> Exception: <<loop>>
11:30:31 <vincenz> Korollary: vendetta!
11:30:33 <Korollary> v is for a lot of backslashhes
11:30:33 <bolrod> eh?
11:30:35 <vincenz> bolrod: woah
11:30:36 <Saulzar> Hmm, nope .. 
11:30:41 <vincenz> > length $ head v
11:30:42 <lambdabot> Couldn't match `[a]' against `Char'
11:30:46 <vincenz> > head v
11:30:46 <lambdabot> Exception: <<loop>>
11:30:49 <vincenz> wtf
11:30:55 <Korollary> v is not a type. v is a command.
11:30:56 <bolrod> > head $ head v
11:30:57 <lambdabot> Couldn't match `[a]' against `Char'
11:31:00 <bolrod> !!
11:31:06 <vincenz> v is a String!!!
11:31:11 <vincenz> yet you can't head it!
11:31:21 <bolrod> a string is a list right?!
11:31:22 <vincenz> > take 10 v
11:31:23 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
11:31:26 <vincenz> > take 1 v
11:31:27 <lambdabot> "\""
11:31:29 <vincenz> > head v
11:31:30 <lambdabot> Exception: <<loop>>
11:31:30 <bolrod> so
11:31:31 <Saulzar> > 2 + v
11:31:32 <bolrod> ;/
11:31:32 <lambdabot>  add an instance declaration for (Num [Char])
11:31:36 <vincenz> look
11:31:37 <vincenz> > take 1 v
11:31:38 <lambdabot> "\""
11:31:38 <vincenz> > head v
11:31:39 <lambdabot> Exception: <<loop>>
11:31:41 <vincenz> ???
11:31:42 <lambdabot> Maybe you meant: . id pl wn
11:31:42 <Saulzar> Yep, it is [Char] ..
11:31:48 <vincenz> why can I take 1 and not head it?
11:31:50 <Korollary> take 1 v works, but head doesn.t
11:31:51 <vincenz> > head $ take 1 v
11:31:52 <lambdabot> Exception: <<loop>>
11:31:54 <bolrod> > head "tst"
11:31:55 <lambdabot> 't'
11:31:57 <bolrod> ;/
11:31:59 <vincenz> can't even head the take 1!!!
11:32:06 <bolrod> thats stupid
11:32:08 <vincenz> it makes no sense
11:32:16 <vincenz> > head $ drop 1 v
11:32:17 <lambdabot> Exception: <<loop>>
11:32:18 <bolrod> take 10 $ inits v
11:32:20 <norpan> there you have a mystery
11:32:22 <bolrod> > take 10 $ inits v
11:32:23 <lambdabot> Exception: <<loop>>
11:32:27 <Saulzar> head $ show $ take 1 $ v
11:32:32 <Saulzar> > head $ show $ take 1 $ v
11:32:33 <lambdabot> '"'
11:32:36 <vincenz> > take 1 v
11:32:37 <lambdabot> "\""
11:32:41 <norpan> > nme
11:32:41 <lambdabot>  Not in scope: `nme'
11:32:57 <bolrod> so the first char is the char "  in a string
11:33:06 <bolrod> eh
11:33:07 <bolrod> no
11:33:17 <bolrod> > map ord  $ take 1 v
11:33:18 <lambdabot> Exception: <<loop>>
11:33:22 <bolrod> yo
11:33:23 <Saulzar> > let foo = take 1 $ v in foo `seq` head foo
11:33:24 <lambdabot> Exception: <<loop>>
11:33:31 <Korollary> let's check the type
11:33:33 <bolrod> stop messing with my head!
11:33:35 <bolrod> ;p\
11:33:37 <Korollary> > v + 1
11:33:37 <lambdabot>  add an instance declaration for (Num [Char])
11:33:37 <Saulzar> It's [Char]
11:33:41 <vincenz> Korollary: it's a [char]
11:33:46 <vincenz> why can't you head it
11:33:49 <kpreid_> > head $ show (let v' = show v')
11:33:49 <lambdabot>  parse error on input `)'
11:33:53 <kpreid_> > head $ show (let v' = show v' in v')
11:33:54 <lambdabot> '"'
11:34:02 <kpreid_> > take 30 $ show (let v' = show v' in v')
11:34:03 <vincenz> it makes no sense
11:34:03 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"
11:34:07 <vincenz> besides, where does this v come from?
11:34:09 <vincenz> > take 30 v
11:34:10 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"
11:34:17 <bolrod> so we got
11:34:19 <kpreid_> so that's v's structure
11:34:24 <kpreid_> > head $ show (let v' = show v' in v')
11:34:25 <lambdabot> '"'
11:34:37 <kpreid_> but that works and head v doesn't
11:34:38 <sieni> is that a prank by dons or what?
11:34:38 <Korollary> > null v
11:34:39 <lambdabot> Exception: <<loop>>
11:34:51 <bolrod> > take 10 $intersperse ' ' v
11:34:51 <lambdabot> Exception: <<loop>>
11:34:55 <kpreid_> > head $ tail v
11:34:56 <lambdabot> Exception: <<loop>>
11:34:56 <bolrod> aye
11:35:14 <Saulzar> head (v >>= id)
11:35:17 <Saulzar> > head (v >>= id)
11:35:18 <lambdabot> Couldn't match `[b]' against `Char'
11:35:20 <bolrod> > v !! 1
11:35:21 <lambdabot> Exception: <<loop>>
11:35:27 <bolrod> > v !! 1 !! 1
11:35:27 <lambdabot> Couldn't match `[a]' against `Char'
11:35:32 <bolrod> gah!
11:35:44 <Saulzar> > head (v >>= return . id)
11:35:44 <lambdabot> Exception: <<loop>>
11:36:09 <bolrod> > v
11:36:09 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
11:36:09 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
11:36:09 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
11:36:09 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
11:36:12 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
11:36:15 <lambdabot> [6 @more lines]
11:36:20 <kpreid_> > head ("abc" : v)
11:36:21 <lambdabot> Couldn't match `[Char]' against `Char'
11:36:21 <sieni> @more
11:36:25 <bolrod> whats with the spaces between the " 's
11:36:29 <kpreid_> > head ("abc" ++ v)
11:36:30 <lambdabot> 'a'
11:36:32 <Saulzar> head (zip3 v v v)
11:36:36 <Saulzar> > head (zip3 v v v)
11:36:36 <lambdabot> Exception: <<loop>>
11:36:41 <kpreid_> > ("abc" ++ v) !! 0
11:36:42 <lambdabot> 'a'
11:36:44 <kpreid_> > ("abc" ++ v) !! 3
11:36:45 <lambdabot> Exception: <<loop>>
11:36:48 <kpreid_> > ("abc" ++ v) !! 4
11:36:49 <lambdabot> Exception: <<loop>>
11:37:25 <kpreid_> > let a : b = v in a
11:37:26 <lambdabot> Exception: <<loop>>
11:37:33 <Saulzar> Quite bizare, darcs get lambdabot time? :)
11:37:36 <kpreid_> > let a : b = v in take 10 b
11:37:37 <lambdabot> Exception: <<loop>>
11:37:42 <kpreid_> > let a : b = v in take 10 v
11:37:42 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
11:37:59 <kpreid_> > let a : b = v in b
11:38:00 <lambdabot> Exception: <<loop>>
11:38:01 <bolrod> > head $ takeWhile (\c -> c=='\\' || c=='\"') v
11:38:01 <lambdabot> Exception: <<loop>>
11:38:07 <bolrod> >:(
11:38:27 <JohnnyL> haskell is such a beautiful language.
11:38:39 <Saulzar> map (\[x] -> x) $ take 1 v
11:38:39 <Korollary> v is for beautiful
11:38:43 <Saulzar> > map (\[x] -> x) $ take 1 v
11:38:43 <lambdabot> Couldn't match `[a]' against `Char'
11:39:04 <sethk> dons, is this reasonable?  I want to set my trace level either to a default or a value from an argument.  so I have args (from getArgs) and I did this:
11:39:13 <sethk> (or anyone else interested, of course)
11:39:17 <kpreid_> > take 10 $ map id v
11:39:18 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
11:39:22 <kpreid_> > head $ map id v
11:39:22 <sethk> TraceLevel is an enumeration defined with data
11:39:23 <lambdabot> Exception: <<loop>>
11:39:36 <kpreid_> > take 10 $ map ord v
11:39:37 <lambdabot> Exception: <<loop>>
11:39:46 <bolrod> > show $ take 10 v
11:39:46 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\""
11:39:51 <bolrod> > head $ take 10 v
11:39:52 <lambdabot> Exception: <<loop>>
11:39:52 <kpreid_> > take 10 $ map show v
11:39:53 <lambdabot> Exception: <<loop>>
11:40:08 <kpreid_> > take 10 $ map (,1) v
11:40:08 <lambdabot>  parse error on input `1'
11:40:12 <sethk>    catch ( (do { level :: TraceLevel) <- readIO arg; tsSetLevel level } (\e -> setLevelWithArgument defaultLevel xs)
11:40:16 <kpreid_> > take 10 $ map ((,) 1) v
11:40:16 <sethk> I left out the first line:
11:40:17 <Saulzar> > tail $ take 2 $ show $ take 10 v
11:40:17 <lambdabot> Exception: <<loop>>
11:40:18 <lambdabot> "\\"
11:40:33 <sethk> setLevelWithArgument defaultLevel [] = setLevel defaultLevel
11:40:50 <sethk> setLevelWithArgument defaultLevel (x:xs) =     what I wrote before, catch (...)
11:41:02 <sethk> that's too confusing, I'll paste something
11:41:28 <bolrod> > take 10  [show x | x<-v ]
11:41:28 <lambdabot> Exception: <<loop>>
11:41:37 <bolrod> > take 10  [0 | x<-v ]
11:41:39 <lambdabot> Exception: <<loop>>
11:41:46 <bolrod> ;/
11:41:50 <kpreid_> > length $ take 1 v
11:41:51 <lambdabot> Exception: <<loop>>
11:41:56 <kpreid_> > length $ take 10 v
11:41:57 <lambdabot> Exception: <<loop>>
11:42:02 <kpreid_> > take 10 v
11:42:02 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
11:42:08 <bolrod> the mysteries of the lambdabot 
11:42:17 <kpreid_> it would seem that the unusual case is that v can be shown
11:42:31 <kpreid_> hmmmmm
11:42:35 <kpreid_> > show $ take 10 v
11:42:36 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\""
11:42:44 <kpreid_> scratch that theory
11:43:00 <bolrod> > length $ show $! take 10 v
11:43:01 <lambdabot> Exception: <<loop>>
11:43:03 <bolrod> ;/
11:43:05 <kpreid_> > take 10 $ read v
11:43:05 <lambdabot> Add a type signature
11:43:12 <kpreid_> > take 10 $ read v :: String
11:43:13 <lambdabot> Exception: <<loop>>
11:43:54 <bolrod> > [vv | vv <- v
11:43:55 <lambdabot>  parse error on input `}'
11:43:57 <bolrod> > [vv | vv <- v]
11:43:58 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
11:43:58 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
11:43:58 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
11:43:58 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
11:44:00 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
11:44:03 <lambdabot> [6 @more lines]
11:44:22 <bolrod> > [ ord vv | vv <- v ]
11:44:22 <lambdabot> Exception: <<loop>>
11:44:27 <bolrod> >:/
11:44:30 <Lemmih> > let x = show x in x
11:44:34 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
11:44:37 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
11:44:39 <bolrod> O_o?
11:44:40 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
11:44:43 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
11:44:46 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
11:44:49 <lambdabot> [6 @more lines]
11:44:53 <sieni> @more
11:44:53 <bolrod> oooohhh
11:44:54 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
11:44:54 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
11:44:57 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
11:44:59 <basti_> wtf.
11:45:00 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
11:45:03 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
11:45:06 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\
11:45:06 <bolrod> hahah
11:45:15 <bolrod> da recursive call to show itself
11:45:29 <bolrod> > show "\""
11:45:30 <lambdabot> "\"\\\"\""
11:45:33 <vincenz> op spammiing
11:45:36 <vincenz> stop spammiing
11:45:48 <bolrod> > show.show "\""
11:45:48 <lambdabot> Couldn't match `[Char]' against `t -> t1'
11:45:54 <bolrod> > show.show $"\""
11:45:55 <lambdabot> "\"\\\"\\\\\\\"\\\"\""
11:46:03 <vincenz> bolrod: /msg lambdabot..
11:46:05 <bolrod> well... starts to look like it
11:46:14 <bolrod> -.-
11:46:35 <kpreid_> bolrod: but the recursive show, while apparently identical, doesn't exhibit the strange behavior v does
11:46:48 <vincenz> but
11:46:52 <bolrod> indeed
11:46:55 <vincenz> let x = show x in x will enver be correct!
11:47:28 <bolrod> > let x = show x in head x
11:47:31 <lambdabot> '"'
11:47:36 <bolrod> strange
11:47:46 <vincenz> > head $ let x = show x in x
11:47:47 <lambdabot> '"'
11:47:50 <vincenz> yeah
11:48:00 <bolrod> > let x = show $! x in head x
11:48:01 <lambdabot> Terminated
11:48:07 <bolrod> hmm..
11:48:08 <vincenz> bolrod: it's infinite
11:48:11 <vincenz> otherwise it would NEVER match
11:48:11 <bolrod> yes
11:48:21 <Saulzar> Hmm..
11:48:24 <vincenz> @type  $!
11:48:25 <lambdabot> parse error on input `$!'
11:48:28 <vincenz> @type ( $!)
11:48:28 <lambdabot> forall b a. (a -> b) -> a -> b
11:48:30 <bolrod> try to think of what it actually does
11:48:36 <bolrod> its very weird
11:48:50 <vincenz> well I find it odd that that matching actually works
11:48:52 <vincenz> I mean the
11:48:54 <vincenz> let x = show x
11:49:04 <bolrod> its showing nothing... and then...it shows that show.. and again.. and again
11:49:32 <vincenz> its a least fixed point solution
11:50:05 <bolrod> v is at least VERY weird
11:50:32 <vincenz> so show is obviously lazy
11:50:46 <vincenz> head first
11:51:40 <Lemmih> Perhaps someone should check the source?
11:51:58 <ralejs> @type v
11:51:59 <lambdabot> Not in scope: `v'
11:52:33 <bolrod> > show "\""
11:52:34 <lambdabot> "\"\\\"\""
11:52:52 <bolrod> > show "\"\\\"\"
11:52:52 <lambdabot>  lexical error in string/character literal
11:53:01 <bolrod> > show "\"\\\"\""
11:53:02 <lambdabot> "\"\\\"\\\\\\\"\\\"\""
11:53:14 <ralejs> > fix show
11:53:15 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
11:53:15 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
11:53:15 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
11:53:15 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
11:53:18 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
11:53:21 <lambdabot> [6 @more lines]
11:53:23 <bolrod> what does that do..
11:53:25 <bolrod> @type fix
11:53:27 <ralejs> Whoho!
11:53:29 <lambdabot> Not in scope: `fix'
11:53:32 <bolrod> ??
11:53:37 <lambdabot> Not enough arguments to @.
11:53:50 <ralejs> fix :: (a -> a) -> a
11:53:54 <ralejs> I think...
11:54:05 <ralejs> Can't remember where it is thoug
11:54:07 <bolrod> and what does it do?
11:54:13 <bolrod> @hoogle fix
11:54:13 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
11:54:13 <lambdabot> Control.Monad.Fix :: module
11:54:13 <lambdabot> System.IO.fixIO :: (a -> IO a) -> IO a
11:54:23 <bolrod> @hoogle v
11:54:24 <lambdabot> Data.Graph.vertices :: Graph -> [Vertex]
11:54:24 <lambdabot> Data.Map.valid :: Ord k => Map k a -> Bool
11:54:24 <lambdabot> Data.Set.valid :: Ord a => Set a -> Bool
11:54:28 <ralejs> Nerd answer: it computes the fixpoint of a function
11:54:51 <ralejs> It's a combinator for doing recursion.
11:55:00 <bolrod> hmmm
11:55:14 <ralejs> > let fix f = f (fix f)
11:55:14 <lambdabot>  parse error on input `}'
11:55:26 <ralejs> > let fix f = f (fix f) in fix
11:55:27 <lambdabot>  add an instance declaration for (Show ((t -> t) -> t))
11:55:33 <bolrod> ;o
11:55:43 <ralejs> @type let fix f = f (fix f) in f
11:55:43 <lambdabot> Not in scope: `f'
11:55:55 <ralejs> @type let fix f = f (fix f) in fix
11:55:56 <lambdabot> forall t. (t -> t) -> t
11:56:01 <ralejs> There you go!
11:56:15 <bolrod> > let fix f = f (fix f) in fix show
11:56:16 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
11:56:16 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
11:56:16 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
11:56:16 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
11:56:18 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
11:56:21 <lambdabot> [6 @more lines]
11:57:55 <bolrod> this still doesn't explain v though
12:01:02 <vincenz> > head $ let fix f = f (fix f) in fix show 
12:01:03 <lambdabot> '"'
12:01:05 <vincenz> nope
12:01:07 <vincenz> you an head it
12:01:10 <vincenz> s/an/can
12:07:12 <sjanssen> this 'v' is pretty strange
12:07:14 <vincenz> that fix point thing is cool
12:07:16 <sjanssen> wonder what it's for?
12:07:22 <vincenz> sjanssen: the strange thing is the fact you can't head it
12:07:37 <sjanssen> whoah
12:07:39 <vincenz> > head $ let fix f = f (fix f) in fix (reverse . show)
12:07:41 <lambdabot> Exception: stack overflow
12:07:44 <vincenz> > let fix f = f (fix f) in fix (reverse . show)
12:07:46 <lambdabot> Exception: stack overflow
12:07:52 <vincenz> sjanssen: look
12:07:54 <vincenz> > take 1 v
12:07:55 <lambdabot> "\""
12:07:56 <vincenz> > head v
12:07:57 <lambdabot> Exception: <<loop>>
12:08:00 <vincenz> odd ain't it
12:08:05 <vincenz> besides, I wonder where this v is defined
12:08:08 <vincenz> lambdabot?
12:09:43 <vincenz> @where v
12:09:44 <lambdabot> I know nothing about v.
12:09:49 <vincenz> @type v
12:09:50 <lambdabot> Not in scope: `v'
12:09:52 <vincenz> @hoogl v
12:09:53 <lambdabot> Maybe you meant: hoogle hoogle+
12:09:53 <vincenz> @hoogle v
12:09:54 <lambdabot> Data.Graph.vertices :: Graph -> [Vertex]
12:09:54 <lambdabot> Data.Map.valid :: Ord k => Map k a -> Bool
12:09:54 <lambdabot> Data.Set.valid :: Ord a => Set a -> Bool
12:09:58 * vincenz peers at lambdabot 
12:10:01 <vincenz> lambdabot: sneaky bastard
12:10:23 <vincenz> who came up with this v, anyways, araujo?
12:10:27 <vincenz> araujo: where did you find v?
12:10:38 <vincenz> or was it norpan 
12:11:18 <vincenz> @version
12:11:19 <lambdabot> lambdabot 3p400, GHC 6.4.1 (Linux i686 3.20GHz)
12:11:19 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
12:11:34 <sjanssen> > inits v !! 1
12:11:35 <lambdabot> Exception: <<loop>>
12:11:58 <vincenz> sjanssen: even worse
12:12:00 <vincenz> > take 2 v
12:12:01 <lambdabot> "\"\\"
12:12:03 <vincenz> > head $ take 2 v
12:12:04 <lambdabot> Exception: <<loop>>
12:12:08 <vincenz> funky, ain't t
12:12:19 <vincenz> that makes no SENSE!
12:12:22 <sjanssen> is dons around?
12:12:27 <sjanssen> @seen dons
12:12:27 <lambdabot> dons is in #haskell. Last spoke 6 hours, 51 minutes and 58 seconds ago.
12:12:29 * vincenz is doing a get lambdabot
12:12:32 <vincenz> gonna check the code
12:12:36 <vincenz> my bet is that v is inside lambdabot
12:12:43 <sjanssen> @localtime dons
12:12:44 <lambdabot> Local time for dons is Mon Apr 10 05:13:25 2006
12:12:50 <vincenz> :D
12:12:54 <vincenz> dons: wake up!
12:13:17 <flux__> vincenz, there's a glitch in the matrix?
12:13:21 <vincenz> could anyone tell me whta the diff is between 'get' and 'get --partial'
12:13:26 <vincenz> flux__: yeah...there's a flux of vs
12:13:58 <sjanssen> get --partial doesn't grab the whole history of the repo
12:14:07 <sjanssen> it's to save bandwidth
12:15:29 <vincenz> sjanssen: yeah but what does it not get?
12:16:15 <sjanssen> if you do --partial I think you can't revert to old versions
12:16:20 <vincenz> ah
12:16:25 <sjanssen> I'm not sure on the exact details
12:16:32 <vincenz> basically it only keeps that which will lead to a full image 
12:16:44 <vincenz> I bet you must optimize your repo for this... I mean that's some complex calculations
12:17:58 <vincenz> can't find the v
12:18:04 <vincenz> better just ask dons
12:20:25 <vincenz> > take 2 v
12:20:26 <lambdabot> "\"\\"
12:20:30 <vincenz> > (take 2 v) !! 1
12:20:31 <lambdabot> Exception: <<loop>>
12:20:32 <vincenz> > (take 2 v) !! 0
12:20:33 <lambdabot> Exception: <<loop>>
12:20:36 * vincenz scratches
12:21:03 <vincenz> you've got a finite list and it can't get an item!!!
12:23:32 <sjanssen> what could be the purpose of v?  it's just repeated quotings of "
12:25:26 <vincenz> yeah but more importantly, where does it come from
12:25:30 <vincenz> and why does head fail but take doesn't
12:25:46 <xerox> v?
12:25:52 <vincenz> > v
12:25:53 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
12:25:53 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
12:25:53 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
12:25:53 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
12:25:55 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
12:25:57 <vincenz> > take 1 v
12:25:58 <lambdabot> [6 @more lines]
12:25:59 <vincenz> > head v
12:26:12 <vincenz> > take 1 v
12:26:12 <xerox> Why does it come defined?
12:26:17 <vincenz> no idea
12:26:17 <lambdabot> "\""
12:26:19 <lambdabot> Exception: <<loop>>
12:26:20 <vincenz> > head v
12:26:21 <lambdabot> "\""
12:26:23 <lambdabot> Exception: <<loop>>
12:26:24 <vincenz> see... take works, head doesn't
12:26:28 <mauke> > take 23 v
12:26:29 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\"
12:26:40 <vincenz> I think v is like 42
12:26:49 <mauke> > take 1 $ take 23 v
12:26:50 <lambdabot> "\""
12:26:52 <xerox> Quote-quote-quote...
12:27:01 <vincenz> xerox: it's a fixed point of show
12:27:04 <vincenz> xerox: but you can head that
12:27:05 <vincenz> and not v
12:27:19 <xerox> ?type v
12:27:20 <lambdabot> Not in scope: `v'
12:27:23 <vincenz> > head $ let fix f = f (fix f) in fix show
12:27:24 <lambdabot> '"'
12:27:25 <vincenz> see
12:27:30 <vincenz> > head v
12:27:30 <xerox> > typeOf v
12:27:31 <lambdabot> Exception: <<loop>>
12:27:31 <lambdabot> [Char]
12:27:55 <vincenz> > typeOf typeOf
12:27:55 <lambdabot> Add a type signature
12:28:00 <vincenz> @type typeof
12:28:01 <lambdabot> Not in scope: `typeof'
12:28:04 <xerox> > let w = head v in seq w w
12:28:05 <vincenz> @hoogle typeOf
12:28:06 <lambdabot> Exception: <<loop>>
12:28:06 <lambdabot> Data.Typeable.typeOf :: Typeable a => a -> TypeRep
12:28:06 <lambdabot> Data.Typeable.typeOf1 :: Typeable1 t => t a -> TypeRep
12:28:06 <lambdabot> Data.Typeable.typeOf1Default :: (Typeable2 t, Typeable a) => t a b -> TypeRep
12:28:31 <Lemmih> > typeOf (undefined `asTypeOf` v)
12:28:32 <lambdabot> [Char]
12:30:12 <bolrod> still solving the v thing?
12:30:13 <bolrod> ;p
12:30:23 <vincenz> >typeOf1 (print "abc")
12:30:26 <vincenz> > typeOf1 (print "abc")
12:30:27 <lambdabot> IO
12:30:32 <vincenz> bolrod: I think v is unsolveable
12:30:56 <vincenz> bolrod: it's like the quantumflux in our universe, forever unfolding, and you can enver look too close (read 'head') cause it'll be quantum noise
12:31:12 <sjanssen> > dynApply (toDyn (head :: String -> Char)) (toDyn v)
12:31:13 <lambdabot> Just <<Char>>
12:31:27 <Lemmih> @vixen You're a quantum bot?
12:31:27 <lambdabot> i can't stand bots
12:31:29 <bolrod> so why can I take one of it
12:31:30 <bolrod> ;p
12:31:41 <bolrod> @vixen tell us about 'v'
12:31:42 <lambdabot> ever just get the urge to go out and kill a puppy?
12:31:44 <sjanssen> > fromDynamic $ dynApply (toDyn (head :: String -> Char)) (toDyn v) :: Char
12:31:45 <lambdabot> Couldn't match `Dynamic' against `Maybe Dynamic'
12:31:46 <vincenz> bolrod: cause taking...implies a list... like a historical process
12:32:10 <vincenz> > fromDynamic $ fromJust $ dynApply (toDyn (head :: String -> Char)) (toDyn v) :: Char
12:32:11 <lambdabot> Couldn't match `Char' against `Maybe a'
12:32:17 <Lemmih> @vixen Will 'v' make sense if we kill a puppy?
12:32:18 <lambdabot> let me answer that later, okay?
12:32:27 <bolrod> haha
12:32:28 <xerox> http://lambda-the-ultimate.org/node/1388
12:32:30 <sjanssen> > fromDynamic $ fromJust $ dynApply (toDyn (head :: String -> Char)) (toDyn v) :: Maybe Char
12:32:31 <lambdabot> Just 'J'
12:32:34 <xerox> ohub, I didn't know this one.
12:32:42 <xerox> STM with data invariants!
12:32:43 <sjanssen> what!
12:33:02 <sjanssen> oh, typo
12:33:33 <bolrod> but what on earth.. looks like a string. but when you look closer.. turns into a loop !
12:34:10 <sjanssen> > fromDynamic $ dynApp (toDyn (head :: String -> Char)) (toDyn v) :: Maybe Char
12:34:11 <lambdabot> Just 'J'
12:34:31 <xerox> Yay.
12:34:34 <sjanssen> okay, can anyone tell me where J comes into this?
12:34:40 <bolrod> haha
12:34:43 <bolrod> I just wondered
12:34:48 <bolrod> I hoped you knew
12:34:50 <xerox> @remember sjanssen > fromDynamic $ dynApp (toDyn (head :: String -> Char)) (toDyn v) :: Maybe Char
12:34:51 <lambdabot> Done.
12:34:59 <bolrod> :D
12:35:02 <vincenz> sjanssen: J???
12:35:04 <vincenz> sjanssen: J!!!
12:35:08 * wolverian boggles 
12:35:10 <vincenz> J is my answer to the universe
12:35:16 <bolrod> hahaha
12:35:16 <xerox> J.
12:35:19 <vincenz> I'm serious
12:35:24 <vincenz> nce I was stoned and me and my friend invented J
12:35:26 <vincenz> imagine a multiverse
12:35:30 <xerox> ...
12:35:30 <bolrod> someone has secretly built the answer to the universe into lambdabot 
12:35:34 <sjanssen> you guys, there's only one explanation
12:35:42 <sjanssen> it's the Knights Templar
12:35:43 <vincenz> with not only 3 dimensional universes, but all the universes, an infinite amount of them
12:35:46 <xerox> hahaha
12:36:09 <bolrod> :)
12:36:09 <xerox> You guys are going *nuts*.
12:36:16 <vincenz> sjanssen: where does "J" come from in
12:36:18 <vincenz> > take 10 v
12:36:19 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
12:36:26 <bolrod> @vixen do you know the answer to the universe(s)
12:36:26 <lambdabot> yeah, i know
12:36:30 <bolrod> SEE!!!
12:36:36 <xerox> Maybe it's what is there, after all those quotations?
12:36:46 <vincenz> xerox: but he did a 'head'!
12:36:49 <sjanssen> vincenz: have no clue
12:36:51 <bolrod> all bow to the mightly lambdabot 
12:36:52 <xerox> Heads up.
12:36:54 <sjanssen> > elem 'J' v
12:36:54 <lambdabot> Exception: <<loop>>
12:37:04 <vincenz> > elem '\' v
12:37:05 <lambdabot>  lexical error in string/character literal
12:37:05 <xerox> Dynamicize elem.
12:37:08 <vincenz> > elem '\\' v
12:37:09 <lambdabot> Exception: <<loop>>
12:37:11 <vincenz> lol
12:37:14 <vincenz> > take 2 v
12:37:15 <lambdabot> "\"\\"
12:37:22 <bolrod> you can't take a look at an element in v
12:37:23 <bolrod> ;p
12:37:23 <vincenz> > elem '"' $ take 2 v
12:37:24 <lambdabot> Exception: <<loop>>
12:37:28 <vincenz> damn
12:37:31 <vincenz> funky
12:37:38 * xerox boings waiting for sjanssen 
12:37:44 <bolrod> :D
12:37:45 <vincenz> v is odd
12:37:50 <vincenz> seriously odd
12:37:55 <bolrod> each element in v has the representation of a char
12:37:57 <bolrod> but when you touch it
12:38:00 <vincenz> boom
12:38:00 <bolrod> it explodes!
12:38:08 <bolrod> just like undefined
12:38:16 <bolrod> or.. maybe not
12:38:23 <bolrod> > show [1,2,3,4,undefined,5,6]
12:38:24 <lambdabot> Undefined
12:38:24 <vincenz> bolrod: Just 'J'
12:38:38 <bolrod> mhm
12:39:08 <bolrod> > fromDynamic $ dynApp (toDyn (head :: String -> Char)) (toDyn v)
12:39:08 <lambdabot> Add a type signature
12:39:10 <bolrod> what does that do then?
12:39:17 <xerox> > fromDynamic $ dynApp (toDyn (head :: String -> Char)) (toDyn "Test.") :: Maybe Char
12:39:18 <lambdabot> Just 'T'
12:39:25 <xerox> sowhat, the J must be there.
12:39:25 <bolrod> erh
12:39:36 <vincenz> xerox: but the whole point is that he takes HEAD
12:39:38 <vincenz> > take 1 v
12:39:39 <bolrod> @hoogle toDyn
12:39:39 <lambdabot> "\""
12:39:39 <lambdabot> Data.Dynamic.toDyn :: Typeable a => a -> Dynamic
12:39:41 <vincenz> THAT character!
12:39:57 <vincenz> I think v is the escape from monads
12:39:58 <bolrod> > fromDynamic $ dynApp (toDyn (head :: String -> Char)) (toDyn "\"") :: Maybe Char
12:39:59 <lambdabot> Just '"'
12:40:02 <xerox> > fromDynamic $ dynApp (toDyn (elem 'J ':: String -> Bool)) (toDyn v) :: Maybe Char
12:40:03 <lambdabot>  lexical error in string/character literal
12:40:03 <vincenz> into the world of undefined imperativeness
12:40:07 <xerox> > fromDynamic $ dynApp (toDyn (elem 'J' :: String -> Bool)) (toDyn v) :: Maybe Char
12:40:08 <lambdabot> Nothing
12:40:15 <xerox> > fromDynamic $ dynApp (toDyn (elem 'J' :: String -> Bool)) (toDyn v) :: Maybe Bool
12:40:16 <lambdabot> Just True
12:40:19 <xerox> Just True.
12:40:27 <vincenz> I don't trust todyn
12:40:42 <xerox> > fromDynamic $ dynApp (toDyn (elem '\' :: String -> Bool)) (toDyn v) :: Maybe Bool
12:40:43 <lambdabot>  lexical error in string/character literal
12:40:48 <xerox> > fromDynamic $ dynApp (toDyn (elem '\\' :: String -> Bool)) (toDyn v) :: Maybe Bool
12:40:49 <lambdabot> Terminated
12:40:52 <xerox> Heh.
12:41:00 <bolrod> > fromDynamic $ dynApp (toDyn (head.tail :: String -> Char)) (toDyn v) :: Maybe Char
12:41:01 <lambdabot> Just 'u'
12:41:05 <bolrod> Just
12:41:09 <bolrod> > fromDynamic $ dynApp (toDyn (head.tail.tail :: String -> Char)) (toDyn v) :: Maybe Char
12:41:10 <lambdabot> Just 's'
12:41:11 <xerox> UH
12:41:16 <bolrod> > fromDynamic $ dynApp (toDyn (head.tail.tail.tail :: String -> Char)) (toDyn v) :: Maybe Char
12:41:17 <lambdabot> Just 't'
12:41:19 <bolrod> :D
12:41:27 <bolrod> its 
12:41:31 <bolrod> Just Just Just Just ........
12:41:38 <xerox> AHAHAH
12:41:39 <bolrod> > fromDynamic $ dynApp (toDyn (head.tail.tail.tail.tail :: String -> Char)) (toDyn v) :: Maybe Char
12:41:40 <lambdabot> Just ' '
12:41:44 <bolrod> > fromDynamic $ dynApp (toDyn (head.tail.tail.tail.tail.tail :: String -> Char)) (toDyn v) :: Maybe Char
12:41:45 <lambdabot> Exception: <<loop>>
12:41:48 <bolrod> NO!
12:41:50 <xerox> NO!
12:41:53 <bolrod> Its   " Just Just v"
12:41:55 <bolrod> xD
12:41:59 <xerox> Hmm.
12:42:13 <xerox> > fromDynamic $ dynApp (toDyn (take 10 :: String -> String)) (toDyn v) :: Maybe Bool
12:42:14 <lambdabot> Nothing
12:42:16 <bolrod> > fromDynamic $ dynApp (toDyn (head(head.tail.tail.tail.tail.tail) :: String -> Char)) (toDyn v) :: Maybe Char
12:42:17 <lambdabot> Couldn't match `[String -> Char]' against `t -> t1'
12:42:17 <xerox> > fromDynamic $ dynApp (toDyn (take 10 :: String -> String)) (toDyn v) :: Maybe String
12:42:18 <lambdabot> Just "Just \"Just"
12:42:21 <vincenz> > head $ tail $ v
12:42:22 <lambdabot> Exception: <<loop>>
12:42:24 <xerox> > fromDynamic $ dynApp (toDyn (take 100 :: String -> String)) (toDyn v) :: Maybe String
12:42:25 <lambdabot> Just "Just \"Just \\\"Just \\\\\\\"Just \\\\\\\\\\\\\\\"Just \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Just \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Just \\\\"
12:42:31 <bolrod> oh
12:42:31 <xerox> ha-ha.
12:42:33 <vincenz> o.O
12:42:33 <sjanssen> I think I get it
12:42:35 <vincenz> holy crap
12:42:43 <basti_> we should make a #haskell-crapflood
12:42:45 <xerox> It appends Just "dynamicizing" it?
12:42:48 <sjanssen> v is the fixed point of showing your result, or something
12:42:52 <xerox> You can go on #haskell-overflow
12:43:02 <vincenz> sjanssen: so how does that work without arguments?
12:43:06 <bolrod> can you explain it though
12:43:07 <xerox> (It really exists.)
12:43:19 <kpreid_> > (v)
12:43:20 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
12:43:20 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
12:43:20 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
12:43:20 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
12:43:22 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
12:43:23 <kpreid_> oops
12:43:25 <xerox> Because toDyn "maybe"-izes the intermediate results?
12:43:25 <lambdabot> [6 @more lines]
12:43:28 <bolrod> kpreid_: we know that!
12:43:29 <bolrod> :p
12:43:45 <kpreid_> (1,take 3 v)
12:43:49 <kpreid_> > (1,take 3 v)
12:43:50 <bolrod> > let x = show "test"++x
12:43:50 <lambdabot> (1,"(1,")
12:43:50 <lambdabot>  parse error on input `}'
12:43:54 <xerox> (Again, #haskell-overflow would work.)
12:43:59 <bolrod> > let x = show ("test"++x) in x
12:44:00 <lambdabot> "\"test\\\"test\\\\\\\"test\\\\\\\\\\\\\\\"test\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"test\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"test\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
12:44:00 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"test\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
12:44:00 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"test\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
12:44:00 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
12:44:02 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
12:44:05 <lambdabot> [6 @more lines]
12:44:06 <bolrod> there is the same pattern
12:44:09 <sjanssen> this is way cool!
12:44:11 <xerox> No.
12:44:11 <kpreid_> OK, so v is the shown result of the input
12:44:15 <xerox> bolrod, it's different.
12:44:35 <bolrod> a tiny bit
12:44:37 <bolrod> only more \'s
12:44:40 <xerox> No.
12:44:54 <xerox> toDyn's one *starts* with Just.
12:44:59 <shapr> kick the bot!
12:45:06 <bolrod> > let x = "test"++show ("test"++x) in x
12:45:07 <lambdabot> "test\"testtest\\\"testtest\\\\\\\"testtest\\\\\\\\\\\\\\\"testtest\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"testtest\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"testtest\\\\\\\\\\\\\\\\\\\\
12:45:07 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"testtest\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
12:45:07 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"testtest\\\\\\\\\\\\\\\\\\
12:45:07 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
12:45:09 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
12:45:12 <lambdabot> [6 @more lines]
12:45:13 <bolrod> sorry
12:45:15 <bolrod> :x
12:45:30 <sjanssen> guys, lets avoid the 8 line responses, lambdabot will respond to PM's
12:45:41 <bolrod> it didn't last time I tried
12:45:51 <basti_> maybe you're not registered?
12:45:53 <bolrod> it does again
12:45:58 <bolrod> maybe I wasn't
12:45:59 <basti_> PM's are restricted on freenode
12:46:01 <bolrod> can't remmeber
12:46:15 <sjanssen> bolrod: there was a couple days where that was the case
12:46:15 <vincenz> bolrod: earn about take!!!
12:46:34 <bolrod> vincenz: O_o?
12:46:39 <bolrod> I said sorry!
12:46:41 <bolrod> :P
12:46:44 <flux__> wasn't there a flag to accept pm's from nonregistered users?
12:46:50 <flux__> s/flag/usermode/
12:46:51 <bolrod> I made the damn inits with the take function >_> psh!
12:46:51 <bolrod> ;)
12:46:57 <basti_> I don't know the exact rules anymore.
12:46:59 <xerox> flux__, yup.
12:47:12 <xerox> /MSG NickServ HELP  for insights, I think
12:47:17 <flux__> maybe lambdabot could make use of it, if it doesn't already ;)
12:48:56 <bolrod> anyway
12:49:03 <bolrod> is the v in the lambdabot code?
12:49:05 <bolrod> or in haskell?
12:49:15 <bolrod> who made this lambdabot
12:49:17 <vincenz> dons
12:49:26 <bolrod> did he put it in?
12:49:33 <bolrod> or is it in all the lambdabots
12:49:36 <xerox> 'J'.
12:49:51 <mauke> ok, I have implemented v here
12:49:57 <vincenz> mauke: what is the impl?
12:49:59 <bolrod> how?
12:50:09 <vincenz> > v 1
12:50:10 <lambdabot> Couldn't match `t1 -> t' against `[a]'
12:50:13 <vincenz> > v ""
12:50:13 <mauke> http://rafb.net/paste/results/xqN2OW37.html
12:50:13 <lambdabot> Couldn't match `[Char] -> t' against `[a]'
12:50:22 <mauke> at least the head/take part works
12:51:02 <vincenz> mauke: don't fully get it
12:51:48 <kpreid_> > let v' = show (take 10 v') in v'
12:51:49 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\""
12:51:53 <kpreid_> > let v' = show (head v') in v'
12:51:54 <lambdabot> Exception: <<loop>>
12:52:08 <kpreid_> this is like what lambdabot is actually doing, I expect
12:52:16 <kpreid_> the (...) is the expression you enter
12:53:09 <sjanssen> here's my guess: lambdabot changes all "> E" requests into "let v = show E in v"
12:53:23 <xerox> HEH
12:53:27 <bolrod> hmm
12:54:08 <sjanssen> because the result probably has to be monomorphic if you want to get the result out of hs-plugins
12:54:46 <sjanssen> and of course, when we get all self referential by using v in our expression, we get loops
12:54:59 <bolrod> true
12:55:16 <bolrod> but thats the same as  let x = show x in x
12:55:21 <vincenz> mauke: I don't get it...
12:55:26 <vincenz> mauke: shows calls show, no?
12:55:30 <bolrod> > let x = show x in head x
12:55:31 <lambdabot> '"'
12:55:33 <bolrod> see 
12:55:39 <mauke> vincenz: maybe
12:55:44 <bolrod> sjanssen: so not completely
12:55:48 <vincenz> mauke: so how come you don't always get an error
12:55:58 <vincenz> oh nm... the shows is after toChar
12:56:48 <bolrod> mauke: on your code I can't perform 
12:56:49 <bolrod> fromDynamic $ (dynApp (toDyn (take 100 :: String -> String)) (toDyn v)) :: Maybe String
12:57:04 <bolrod> <interactive>:1:61: No instance for (Typeable Evil)
12:57:08 <bolrod> and it can't derive it
12:57:16 <bolrod> oh
12:57:16 <bolrod> wait
12:57:38 <mauke> working on it
12:57:44 <bolrod> -fglasgow-exts
12:57:59 <sjanssen> > typeOf v
12:58:00 <lambdabot> [Char]
12:58:11 <xerox> sjanssen, makes sense to me.
12:58:17 <xerox> Nice one.
12:58:33 <bolrod> > toDyn v
12:58:34 <lambdabot> <<[Char]>>
12:58:51 <bolrod> mauke: its not a different data type..
12:58:52 <sjanssen> > let x = show (head x) in x
12:58:53 <lambdabot> Exception: <<loop>>
12:58:56 <bolrod> *Main Data.Dynamic> toDyn v
12:58:57 <bolrod> <<[Main.Evil]>>
12:59:10 <sjanssen> bolrod: your counterexample was incorrect
12:59:19 <bolrod> because?
12:59:24 <mauke> > Data.Dynamic.toDyn v
12:59:25 <mauke> <<[Main.Char]>>
12:59:26 <lambdabot> <<[Char]>>
12:59:42 <mauke> I guess I can't make the "Main" disappear
12:59:48 <bolrod> ok
12:59:53 <xerox> Hmmm.
12:59:57 <sjanssen> because "let x = show x in head x" is different from "let x = show (head x) in x"
12:59:58 <bolrod> can you apply the funcion on it?
13:00:12 <bolrod> > let x = show (head x) in x
13:00:13 <lambdabot> Exception: <<loop>>
13:00:15 <bolrod> ;o
13:00:40 <bolrod> so.... does this concludes it?
13:00:51 <sjanssen> I'm satisfied
13:00:58 <xerox> So using v inhibits performing any kind of operations?
13:01:02 <JohnnyL> zipWith is just map with 3 parameters.
13:01:38 <bolrod> let v = show (fromDynamic $ (dynApp (toDyn (take 100 :: String -> String)) (toDyn v)) :: Maybe String) in v
13:01:41 <bolrod> "Just \"Just \\\"Just \\\\\\\"Just \\\\\\\\\\\\\\\"Just \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Just \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Just \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Just \\\\\\\\\""
13:01:46 <bolrod> does quite the same
13:02:12 <xerox> OHO, it doesn't.  /me grins evilly.
13:02:31 <JohnnyL> hey Ryan, are you in nyc?
13:02:40 <bolrod> > take 1 v
13:02:40 <lambdabot> "\""
13:03:34 <bolrod> > let v = show (take 1 v) in v
13:03:35 <lambdabot> "\"\\\"\""
13:03:49 <bolrod> sjanssen: that still isn't the same
13:04:23 <JohnnyL> how does haskell know order of operation? (IF CELL=EMPTY, FETCH CELL CONTENTS) ???
13:04:27 <sjanssen> bolrod: good point
13:04:47 <RyanT5000> Johnny: i'm in Albany
13:04:55 <sjanssen> JohnnyL: are you takling about sequencing events like IO?
13:05:09 <sjanssen> JohnnyL: we use monads for that
13:05:15 <JohnnyL> RyanT5000, my ex gf was from there. i enjoyed the train ride upthere, everything is so green and small townish. i'm from long island.
13:05:28 <JohnnyL> sjanssen, no just functions.
13:05:38 <RyanT5000> yeah, my gf's from long island :P
13:05:53 <RyanT5000> i guess it's a popular pairing, lol
13:05:57 <RyanT5000> i hate albany, though
13:06:04 <RyanT5000> i've only lived here for like 3 years
13:06:06 <JohnnyL> albnay is quite dull.
13:06:11 <RyanT5000> yeah
13:06:19 <JohnnyL> but long island is too. just in a different way.
13:06:29 <RyanT5000> how are your restaurants?
13:06:34 <RyanT5000> we don't have any good restaurants
13:06:40 <xerox> Want to see something *gurgle* ?
13:06:56 <JohnnyL> the mom and pop ones are quite good. i tend to stay away from applebees (the big francises).
13:07:06 <JohnnyL> although i do like chili's... not sure if there are any here.
13:07:08 <xerox> > ("Hi there!", drop 2 $ take 11 v)
13:07:09 <RyanT5000> that really pisses me off, because i've lived in albuquerque (great mexican) seattle (great seafood and japanese), and houston (huge, so everything)
13:07:09 <lambdabot> ("Hi there!","Hi there!")
13:07:15 <JohnnyL> fridays wasen't that bad either.
13:07:47 <RyanT5000> hm yah, although you also have NYC close by
13:07:54 <JohnnyL> 55 miles away.
13:08:07 <RyanT5000> my gf wants to know where on longisland you live
13:08:13 <JohnnyL> center moriches
13:08:45 <RyanT5000> alright well i need to go; i'll be back in a few hours
13:09:25 <sjanssen> bolrod: I think the code must have a special case for strings
13:09:59 <bolrod> yes... where is it in the code ;)
13:10:07 <JohnnyL> bye
13:10:15 <sjanssen> > let v = show (take 1 v) in read v :: String
13:10:16 <lambdabot> "\""
13:10:42 <bolrod> ;o
13:10:46 <xerox> > ("Hi there!", drop 2 $ take 11 v)
13:10:47 <lambdabot> ("Hi there!","Hi there!")
13:10:50 <sjanssen> so it omits show if E :: String
13:10:59 <sjanssen> or unquotes it one level
13:11:17 <sjanssen> xerox: nice
13:11:25 <JohnnyL> sjanssen, i'm almost sure thats the algorithm.
13:11:37 * JohnnyL wonders how small he can make a haskell compiler for his c64.
13:15:20 <sjanssen> > let v = show e; e = take 1 v; in if typeOf e == typeOf "" then read v else v
13:15:21 <lambdabot> "\""
13:16:26 <bolrod> yep
13:16:40 <bolrod> now.. where is that actual code in the lambdabot source ;)
13:16:58 <xerox> grep v :P
13:17:04 <bolrod> yes.. 
13:17:15 <bolrod> it happens to be a quite often used letter
13:17:37 <sjanssen> it's possible that this code lives inside hs-plugins
13:18:07 <bolrod> next question.
13:18:22 <bolrod> should they solve it..or leave it in for nice effect
13:18:22 <bolrod> ;p
13:18:36 <sjanssen> seems a tough one to solve
13:18:36 <xerox> I think it's ok.
13:18:42 <bolrod> not really
13:18:45 <bolrod> just check the input for v
13:18:52 <xerox> You think it's that simple?
13:18:54 <bolrod> then use the let x = blababla
13:18:54 <sjanssen> I suppose they could scan the input string for an unused name
13:19:24 <bolrod> or use   let  abcdefghijklmnopqrstuvwyz = .....
13:19:29 <bolrod> nobody is going to use THAT
13:19:29 <bolrod> ;p
13:19:35 <xerox> v is the same.
13:19:50 <bolrod> v is alot shorter
13:21:02 <bolrod> but this is quite funny... maybe create an evil data type that acts even weirder ;p
13:25:54 <vincenz> just mess up show :D
13:26:03 <vincenz> but!
13:26:08 <vincenz> notice however that muake's implemetnation is wrong
13:26:09 <vincenz> cause
13:26:12 <vincenz> > typeOf v
13:26:13 <lambdabot> [Char]
13:26:15 <vincenz> v = [Char]
13:26:18 <vincenz> not [Evil]
13:26:41 <mauke> vincenz: the latest version has [Main.Char]
13:26:51 <vincenz> mauke: got a link?
13:27:09 <mauke> no, I'd have to revert a few changes first
13:27:13 <vincenz> okies
13:27:14 <mauke> apparently redefining the prelude doesn't work
13:27:26 <vincenz> we need dons
13:27:37 <vincenz> @version
13:27:37 <lambdabot> lambdabot 3p400, GHC 6.4.1 (Linux i686 3.20GHz)
13:27:37 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
13:28:03 <bolrod> :)
13:28:19 <mauke> here: http://rafb.net/paste/results/szUfoQ49.html
13:29:20 <vincenz> mauke: that's unusable anywhere Char is defined
13:29:39 <vincenz> and aren't class instances global
13:29:44 <vincenz> how can it work with two separate Char's?
13:30:00 <JohnnyL> whats a good function that returns a Bool value for filter?
13:30:06 <mauke> because they're separate
13:30:18 <mauke> that's like asking "how can both Int and Char be instances of Show"?
13:30:25 <vincenz> mauke: yeah but then the type wouldnt be [Char]
13:30:59 <mauke> yeah, I had to cheat
13:31:19 <mauke> it "works" for ghci's :type 
13:31:40 <bolrod> ahyeah..  how about something like instance.. but then for context of function use
13:31:44 <bolrod> so you can say
13:31:57 <bolrod> length (innits list)  =  length list + 1
13:32:02 <bolrod> inits*
13:32:11 <bolrod> instead that it calculates the real inits of the list
13:32:35 <bolrod> inits sees that it is being used in the function length   and then returns a different definition
13:33:52 <bolrod> or am I totally speaking nonsense :)
13:35:58 <bolrod> that way you can give a set of definitions ... and give clues to which definition is more convenient in certain context
13:36:05 <bolrod> and the ghc will find out which one to use when
13:38:00 <bolrod> ?
13:38:37 <Lemmih> You can create rewrite rules.
13:45:20 <JohnnyL> > filter isLower ['b','a','D']
13:45:21 <lambdabot> "ba"
13:45:29 <JohnnyL> filter isLower ['b','a','D']
13:51:12 <newsham> johnny: why do you ['b','a','D'] ?  why not "baD" ?
13:52:12 <JohnnyL> newsham, because i'm playing such as a newbie would.
13:52:13 <JohnnyL> :)
13:54:12 <JohnnyL> newsham, how can you combine: filter isAscii "BaD" ++ '\xff' ?
13:54:37 <xerox> > filter isAscii $ "BaD" ++ "\xff"
13:54:38 <lambdabot> "BaD"
13:54:53 <newsham> or ("BaD" ++ "\xff")   
13:55:14 <bolrod> > take 37 $ filter isAscii ['\NUL'..]
13:55:15 <lambdabot> "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\SYN\ETB\CAN\EM\SUB\ESC\FS\GS\RS\US !\"#$"
13:55:18 <newsham> or "BaD\xff"
13:55:28 <bolrod> hmm ofcourse
13:55:39 <vincenz> > drop 3 "bolrod"
13:55:40 <lambdabot> "rod"
13:55:44 <bolrod> > take 26 $ filter isLower ['\NUL'..]
13:55:45 <lambdabot> "abcdefghijklmnopqrstuvwxyz"
13:55:54 <bolrod> ;p
13:56:02 <vincenz> > filter isLower ['\NUL'..]
13:56:02 <lambdabot> "abcdefghijklmnopqrstuvwxyz\170\181\186\223\224\225\226\227\228\229\230\231\232\233\234\235\236\237\238\239\240\241\242\243\244\245\246\248\249\250\251\252\253\254\255\257\259\261\263\265\267\269\
13:56:02 <lambdabot> 271\273\275\277\279\281\283\285\287\289\291\293\295\297\299\301\303\305\307\309\311\312\314\316\318\320\322\324\326\328\329\331\333\335\337\339\341\343\345\347\349\351\353\355\357\359\361\363\365\
13:56:02 <lambdabot> 367\369\371\373\375\378\380\382\383\384\387\389\392\396\397\402\405\409\410\411\414\417\419\421\424\426\427\429\432\436\438\441\442\445\446\447\454\457\460\462\464\466\468\470\472\474\476\477\479\
13:56:02 <lambdabot> 481\483\485\487\489\491\493\495\496\499\501\505\507\509\511\513\515\517\519\521\523\525\527\529\531\533\535\537\539\541\543\545\547\549\551\553\555\557\559\561\563\564\565\566\592\593\594\595\596\
13:56:05 <lambdabot> 597\598\599\600\601\602\603\604\605\606\607\608\609\610\611\612\613\614\615\616\617\618\619\620\621\622\623\624\625\626\627\628\629\630\631\632\633\634\635\636\637\638\639\640\641\642\643\644\645\
13:56:05 <vincenz> woah
13:56:06 <bolrod> wow ;/
13:56:08 <lambdabot> [6 @more lines]
13:56:10 <vincenz> sorry
13:56:11 <bolrod> thats not right
13:56:14 <vincenz> I expected only 26
13:56:16 <bolrod> me too
13:56:21 <vincenz> hmm
13:56:25 <vincenz> we need a unicode viewer
13:56:36 <bolrod> > length $ isLower ['\NUL'..]
13:56:37 <lambdabot> Couldn't match `[a]' against `Bool'
13:56:39 <JohnnyL> what's '$'?
13:56:41 <vincenz> another funny thing is this
13:56:44 <vincenz> > maxBound :: Char
13:56:44 <lambdabot> '\1114111'
13:56:45 <bolrod> > length $ filter isLower ['\NUL'..]
13:56:46 <lambdabot> 1415
13:56:49 <vincenz> o.O
13:56:50 <bolrod> dayum!
13:57:03 <vincenz> > length ([minBound..maxBound] :: [Char])
13:57:04 <lambdabot> 1114112
13:57:04 <xerox> f $ x = f x -- i.e. loose function application
13:57:18 <xerox> That is, imagine a '(' where the '$' stands, and a ')' at the end of the line.
13:57:20 <vincenz> > ord 'a'
13:57:21 <lambdabot> 97
13:57:24 <vincenz> > '\97'
13:57:25 <lambdabot> 'a'
13:57:26 <bolrod> yes.. but why should every char after a be lower?
13:57:30 <vincenz> bolrod: not every
13:57:33 <vincenz> bolrod: there's a lot of chars
13:57:35 <vincenz> > length ([minBound..maxBound] :: [Char])
13:57:36 <lambdabot> 1114112
13:57:42 <vincenz> that's not exactly 1415
13:57:59 <bolrod> Oh! I See
13:58:00 <bolrod> ;)
13:58:07 <bolrod> > last $ filter isLower ['\NUL'..] 
13:58:08 <lambdabot> '\120777'
13:58:19 <bolrod> > last.init $ filter isLower ['\NUL'..] 
13:58:20 <lambdabot> '\120776'
13:58:27 <newsham> > length $ filter isUpper ['\NUL'..]
13:58:28 <lambdabot> 1221
13:59:05 <bolrod> > first $ filter isLower ['\NUL'..] 
13:59:05 <lambdabot> Couldn't match `a b' against `[]'
13:59:16 <bolrod> > head $ filter isLower ['\NUL'..] 
13:59:17 <bolrod> :x
13:59:18 <lambdabot> 'a'
13:59:20 <bolrod> haha
13:59:38 <bolrod> > head$ ['a'..] \\filter isLower ['\NUL'..] 
13:59:39 <lambdabot> '{'
13:59:45 <bolrod> > head$ $ ['a'..] \\filter isLower ['\NUL'..] 
13:59:46 <lambdabot>  parse error on input `$'
13:59:55 <bolrod> oh .. was already there
14:00:02 <bolrod> > take 10  ['a'..] \\filter isLower ['\NUL'..] 
14:00:03 <lambdabot> ""
14:00:09 <bolrod> > take 10  $['a'..] \\filter isLower ['\NUL'..] 
14:00:11 <lambdabot> "{|}~\DEL\128\129\130\131\132"
14:00:39 <bolrod> so.. what makes \120777 more lower then \132
14:00:49 <vincenz> bolrod: must be unicode characters
14:00:56 <vincenz> like a with umlaude and what not
14:01:01 <vincenz> > filter isPrint ['a' .. 'z']
14:01:02 <lambdabot> "abcdefghijklmnopqrstuvwxyz"
14:01:05 <JohnnyL> let p = filter isAscii $ "Bad" ++ "\xff"
14:01:07 <vincenz> > filter isPrint ['\NUL'..]
14:01:08 <lambdabot> " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\160\161\162\163\164\165\166\167\168\169\170\171\172\174\175\176\177\178\179\180\181\182\183\184\185\
14:01:08 <lambdabot> 186\187\188\189\190\191\192\193\194\195\196\197\198\199\200\201\202\203\204\205\206\207\208\209\210\211\212\213\214\215\216\217\218\219\220\221\222\223\224\225\226\227\228\229\230\231\232\233\234\
14:01:08 <lambdabot> 235\236\237\238\239\240\241\242\243\244\245\246\247\248\249\250\251\252\253\254\255\256\257\258\259\260\261\262\263\264\265\266\267\268\269\270\271\272\273\274\275\276\277\278\279\280\281\282\283\
14:01:08 <lambdabot> 284\285\286\287\288\289\290\291\292\293\294\295\296\297\298\299\300\301\302\303\304\305\306\307\308\309\310\311\312\313\314\315\316\317\318\319\320\321\322\323\324\325\326\327\328\329\330\331\332\
14:01:11 <lambdabot> 333\334\335\336\337\338\339\340\341\342\343\344\345\346\347\348\349\350\351\352\353\354\355\356\357\358\359\360\361\362\363\364\365\366\367\368\369\370\371\372\373\374\375\376\377\378\379\380\381\
14:01:11 <vincenz> whoops
14:01:14 <lambdabot> [6 @more lines]
14:01:21 <bolrod> becuase!! it certainly not is in the report like that
14:01:23 <JohnnyL> @more
14:01:24 <lambdabot> 382\383\384\385\386\387\388\389\390\391\392\393\394\395\396\397\398\399\400\401\402\403\404\405\406\407\408\409\410\411\412\413\414\415\416\417\418\419\420\421\422\423\424\425\426\427\428\429\430\
14:01:24 <lambdabot> 431\432\433\434\435\436\437\438\439\440\441\442\443\444\445\446\447\448\449\450\451\452\453\454\455\456\457\458\459\460\461\462\463\464\465\466\467\468\469\470\471\472\473\474\475\476\477\478\479\
14:01:24 <lambdabot> 480\481\482\483\484\485\486\487\488\489\490\491\492\493\494\495\496\497\498\499\500\501\502\503\504\505\506\507\508\509\510\511\512\513\514\515\516\517\518\519\520\521\522\523\524\525\526\527\528\
14:01:25 <lambdabot> 529\530\531\532\533\534\535\536\537\538\539\540\541\542\543\544\545\546\547\548\549\550\551\552\553\554\555\556\557\558\559\560\561\562\563\564\565\566\592\593\594\595\596\597\598\599\600\601\602\
14:01:26 <bolrod> isLower                  =  primUnicodeIsLower  -- 'a'..'z'
14:01:28 <lambdabot> 603\604\605\606\607\608\609\610\611\612\613\614\615\616\617\618\619\620\621\622\623\624\625\626\627\628\629\630\631\632\633\634\635\636\637\638\639\640\641\642\643\644\645\646\647\648\649\650\651\
14:01:31 <lambdabot> 652\653\654\655\656\657\658\659\660\661\662\663\664\665\666\667\668\669\670\671\672\6
14:01:31 <bolrod> that is in the report
14:01:35 <bolrod> lambdabot: shhh!
14:02:10 <newsham> > Just "stop"
14:02:11 <lambdabot> Just "stop"
14:02:48 <fons> hi!
14:03:02 <bolrod> hi
14:03:03 <fons> I have a problem related to numerical classes in Haskell
14:03:12 <bolrod> ok
14:03:23 <fons> I have some code, but it's quite long
14:03:28 <bolrod> pastebin ?
14:03:35 <bolrod> or like...... 500 pages?
14:03:35 <fons> I couldn't remember the name
14:03:40 <fons> thanks bolrod 
14:03:41 <bolrod> pastebin.com
14:03:44 <bolrod> ah
14:04:00 <JohnnyL> p=filter isAscii ("Bad" ++ "\xff")
14:04:00 <JohnnyL> ERROR - Syntax error in input (unexpected `=')
14:04:13 <newsham> ghci?
14:04:19 <bolrod> >:/
14:04:32 <newsham> p <- return $ filter isAscii ("Bad" ++ "\xff")
14:04:34 <JohnnyL> thats hugs.
14:04:43 <newsham> you cant do assignments in hugs i dont think
14:05:01 <fons> http://pastebin.com/650193
14:05:03 <newsham> (interactively)
14:05:30 <fons> my porblem is that the interpreter (hugs in this case) complains about the type of fac
14:05:49 <JohnnyL> newsham, nope, thats doesn't work.
14:05:52 <JohnnyL> why?
14:06:07 <fons> and I think is correct (well it obviously isn't otherwise the interpreter wouldn't complain)
14:06:18 <fons> I don't see why is there a problem
14:06:41 <vincenz> fons: be more specific about error?
14:06:43 <newsham> johnny: its not an imperative language 
14:07:00 <bolrod> fons: which line
14:07:02 <newsham> hugs foo.hs;   :e      add your assingment, then quit yoru editor
14:07:04 <bolrod> what type error
14:07:11 <bolrod> does it give any clues at all?
14:07:17 <newsham> or use ghci
14:07:18 <fons> vincenz, yes, Cannot justify constraints in explicitly typed binding
14:07:26 <fons> *** Expression    : fac
14:07:26 <vincenz> fons: for what line
14:07:39 <vincenz> @type (^)
14:07:40 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
14:07:49 <JohnnyL> ghci complains: p <- return $ filter isAscii ("Bad" ++ "\xff")
14:07:50 <JohnnyL> <interactive>:1:21: Not in scope: `isAscii'
14:08:10 <JohnnyL> newsham, oh ok.
14:08:18 <JohnnyL> too used to that commodore basic.
14:08:34 <vincenz> blegh
14:08:35 <vincenz> I hate paste bin
14:08:38 <vincenz> if you copy paste
14:08:40 <vincenz> it inserts white lines
14:08:45 <fons> actually my first try was fac :: (Num a, Integral b) => Expr a -> ([Expr a], a, b) -> ([Expr a], a, b)
14:09:02 <fons> My first guess was that the problem was the operator (^)
14:09:28 <vincenz> test.hs:38:61:
14:09:28 <vincenz>     Could not deduce (Num (Expr a)) from the context (Num a, Integral a)
14:09:28 <vincenz>       arising from use of `+' at test.hs:38:61
14:09:57 <vincenz> fons: found the bug!!!
14:10:01 <fons> vincenz, can you please try the type binding I wrote?
14:10:06 <vincenz>                     (\(lhs :^: (Const n)) -> lhs :^: (Const n+1))
14:10:08 <vincenz> should be
14:10:14 <vincenz> Const (n+1)
14:10:23 <vincenz> otherwise it's (Const n)+1
14:10:25 <fons> f*ck
14:10:29 <bolrod> haha
14:10:30 <fons> thanks dude
14:10:31 <vincenz> ghci is great
14:10:35 <vincenz> and from now on
14:10:38 <vincenz> please use
14:10:41 <vincenz> http://rafb.net/paste
14:10:44 <vincenz> much better than pastebin
14:10:45 <fons> ok, thanks
14:10:46 <vincenz> copy-paste wise
14:10:56 <fons> I think I'll begin using ghci instead of hugs
14:10:56 <newsham> or you could just put stuff up on a web site of your own :)
14:10:57 <vincenz> it's a hassle to copy from pastebin
14:11:03 <bolrod> vincenz: you can use the textarea below to copy
14:11:05 <fons> is it better?
14:11:18 <vincenz> bolrod: I still prefer rafb
14:11:25 <bolrod> ok
14:11:33 <vincenz> less spam
14:12:32 <bolrod> @vixen pastebin or rafb
14:12:33 <lambdabot> I like to pick everything up and smell it... Its a fetish of mine... And i mean everything! Is that cool with you?
14:12:48 <bolrod> ic....
14:13:22 <newsham> johnny: hoogle for isAscii, find out its in the Char module,  :m +Char   and then youc an use it in ghci
14:15:50 <fons> vincenz, you have an idea about why the following binding doesn't work?
14:15:53 <fons> fac :: (Num a, Integral b) => Expr a -> ([Expr a], a, b) -> ([Expr a], a, b)
14:16:37 <bolrod> it should
14:16:48 <bolrod> what is the error
14:16:49 <bolrod> ?
14:17:41 <fons> Inferred type : (Num a, Integral a) => Expr a -> ([Expr a],a,a) -> ([Expr a],a,a)
14:18:11 <JohnnyL> newshman, there is no  problem using isAscii,m assigning it to a function name is the problem.
14:18:21 <bolrod> expected type?
14:18:38 <fons> bolrod, the one I explicitly wrote
14:18:39 <bolrod> ic
14:18:48 <fons> fac :: (Num a, Integral b) => Expr a -> ([Expr a], a, b) -> ([Expr a], a, b)
14:18:49 <bolrod> there is no b in the inferred type
14:19:16 <JohnnyL> fons going all high level on us!
14:19:25 <bolrod> :)
14:20:06 <fons> ghci seems to be much more verbose
14:20:12 <bolrod> ofcourse
14:20:13 <fons> (I just installed it)
14:20:16 <fons> let's see
14:20:20 <bolrod> try -v5 and it'll drive you nuts
14:21:05 <fons> I'm having enough already
14:21:07 <fons> :)
14:21:14 <bolrod> JohnnyL: any problems? ;)
14:21:41 <fons> bolrod, the error doesn't help me that much
14:21:51 <bolrod> look at your code
14:21:53 <bolrod> not the error
14:21:54 <bolrod> ;)
14:22:06 <fons> bolrod, you have the answer already? hehe
14:22:07 <JohnnyL> bolrod, yeah well, just lack of knowledge really. i'd like to use the interpreter to store the function as a means by which I can write p and the function will return x.
14:22:09 <fons> OK
14:22:13 <JohnnyL> i tried let with no good results.
14:23:21 <fons> Quantified type variable `b' is unified with another quantified type variable `a'
14:23:42 <fons> I don't understand why
14:23:55 <bolrod> #
14:23:55 <bolrod> fac expr (factors, const, exp) =
14:23:55 <bolrod> #
14:23:55 <bolrod>   if isJust factors' then (fromJust factors', const, exp)
14:23:55 <bolrod> #
14:23:57 <bolrod>                      else (expr :^: (Const exp):factors, const, exp)
14:24:06 <bolrod> expr = Expr a
14:24:10 <bolrod> exp = Expr b
14:24:11 <bolrod> you say
14:24:37 <bolrod> now you   expr:^: (Const exp): factors
14:24:56 <bolrod> but :^: requires both Expr a
14:25:02 <bolrod> so exp must be Expr a
14:25:07 <bolrod> and can't be Expr b
14:25:15 <bolrod> aye ;)
14:25:27 <fons> wooo
14:25:33 <fons> I see your point there
14:25:40 <bolrod> cool 8)
14:25:58 <bolrod> either that
14:26:04 <bolrod> or it must be b
14:26:05 <bolrod> anyway
14:26:07 <bolrod> they must be the same
14:26:13 <bolrod> since factors is of type Expr a
14:26:51 <bolrod> and even if :^: could get Expr a :^: Expr b
14:26:57 <bolrod> you can't make it Expr b
14:27:05 <bolrod> since you can have  Expr b AND Expr a  in the same list
14:27:09 <fons> I see it now
14:27:13 <bolrod> good
14:27:43 <fons> thank you
14:28:00 <bolrod> np
14:28:55 <bolrod> > map (\c-> toEnum c ::Char).map fromIntegral.map floor.map (\x->0.029*x^5-0.3346*x^4+0.9392*x^3+0.9369*x^2+0.6192*x+89.0002)  $ [0,2,5.8,4]
14:28:57 <lambdabot> "Yawn"
14:29:00 <bolrod> =)
14:29:42 <xerox> bolrod, map a . map b . ... . map z = map (a . b . ... . z)
14:29:59 <bolrod> yep
14:30:03 <bolrod> this looks cooler
14:30:05 <vincenz> bolrod . xerox . bolrod = optimize
14:30:16 <JohnnyL> :p
14:30:22 <fons> bolrod, fromIntegral should fix it then?
14:30:46 <vincenz> or
14:30:47 <bolrod> I dont know what you want to do ;)
14:30:54 <vincenz> dons . dons . dons . dons = superoptimize
14:30:59 <vincenz> just do 
14:31:02 <xerox> fixM dons :-P
14:31:08 <vincenz> dons . dons . dons . dons $ mycode
14:31:12 <bolrod> :D
14:31:24 <fons> bolrod, expr :^: (Const (fromIntegral exp))
14:31:33 <bolrod> you could
14:31:35 <bolrod> I guess
14:31:43 <fons> but it still gives the same error
14:31:56 <fons> :S
14:31:57 <bolrod> then you made some error somewhere else?
14:32:14 <araujo> ok, definetly, now i wanna a t-shirt of http://haskell.org/hoogle/
14:33:38 <bolrod> :P
14:35:16 <bolrod> fac (Const c) (factors, mconst, exp)          = (factors, mconst*c^exp, exp)
14:35:24 <bolrod> ;)
14:35:28 <bolrod> look closer!
14:35:46 <bolrod> its really not that hard
14:36:16 <bolrod> at least
14:36:19 <bolrod> I guess this is it
14:37:31 <bolrod> maybe mconst*c^fromInteger exp   ?
14:38:39 <vincenz> this
14:38:39 <vincenz> http://www.cafepress.com/buy/code/-/pv_design_details/pg_1/id_5015354/opt_/fpt_Za____HPH_____D__B__baP_B/c_101/hlv_t
14:38:45 <vincenz> but I want a haskell version
14:39:12 <bolrod> and how would your haskell code look like?
14:39:30 <vincenz> something with sequence and a recursive function
14:40:04 <vincenz> and a monad
14:41:01 <vincenz> map write_code $ filter isAwake $ life
14:41:07 <vincenz> well not exactly that but oh well
14:41:32 <bolrod> sequence_ (map (const writeCode) (takeWhile awake life)) 
14:41:32 <vincenz> @type iterate
14:41:33 <lambdabot> forall a. (a -> a) -> a -> [a]
14:42:07 <vincenz> sequence_ $ iterate (\f -> do {if is_awake then write_code; f; else f}) ()
14:42:24 <bolrod> thats boring
14:42:27 <vincenz> it's monadic
14:42:37 <blackdog> i think awake has an implicit mutable reference :)
14:42:42 <vincenz> blackdog: it's a monad!
14:42:47 <vincenz> just use the right state monad
14:42:48 <bolrod> it looks more boring then the C code
14:42:55 <bolrod> because its too complicated ;p
14:42:59 <vincenz> lol
14:43:05 <blackdog> takeWhile isn't monadic, is it?
14:43:13 <vincenz> you mean it's pure
14:43:23 <blackdog> yeah. :)
14:43:34 <vincenz> let fix f = f (fix f) in fix write_code
14:43:45 <bolrod> :)
14:43:56 <vincenz> with the appropriate lambdas of course
14:44:08 <bolrod> exactly
14:44:50 <bolrod> let fix f = do {f; fix f} in fix write_code
14:44:54 <bolrod> something like that?
14:44:59 <bolrod> is that possible? ;)
14:46:03 <bolrod> ohyeah!
14:46:06 <bolrod> that works already!
14:46:11 <bolrod> :)
14:46:14 <vincenz> gotta take in the is_asleep
14:46:33 <vincenz> let fix f = do {if is_awake then f; fix f} in fix write_code
14:46:40 <vincenz> let fix f = do {if is_awake then f else (); fix f} in fix write_code
14:46:46 <bolrod> Yap!
14:46:50 <newsham> hmm.. let fix f = do {f; fix f}    isnt the fix operator is it?
14:46:51 <xerox> ?type Control.Monad.Fix.fix
14:46:51 <lambdabot> forall a. (a -> a) -> a
14:46:58 <newsham> isnt that sequence?
14:46:58 <xerox> ?type Control.Monad.Fix.fixM
14:46:58 <lambdabot> Not in scope: `Control.Monad.Fix.fixM'
14:47:00 <xerox> ?type Control.Monad.Fix.fixM_
14:47:01 <lambdabot> Not in scope: `Control.Monad.Fix.fixM_'
14:47:08 <vincenz> @hoogle fix
14:47:08 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
14:47:08 <lambdabot> Control.Monad.Fix :: module
14:47:08 <lambdabot> System.IO.fixIO :: (a -> IO a) -> IO a
14:47:11 <newsham> ?type sequence
14:47:12 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
14:47:22 <xerox> ?hoogle fixM
14:47:22 <lambdabot> No matches found
14:47:33 <vincenz> > map write_code_for $ problems
14:47:34 <lambdabot>  Not in scope: `problems'
14:47:35 <newsham> not sequence
14:48:04 <vincenz> sequence_ $ filter is_awake $ map write_code_for $ problems
14:48:11 <bolrod> xerox: you're not writing import Control.Monad.Fix on your mug!!
14:48:15 <bolrod> :/
14:48:25 <vincenz> we need a haskell mug
14:48:35 <vincenz> but one with code
14:48:43 <vincenz> not a logo or some "we don't do imperative" text
14:48:56 <vincenz> I found one for bolrod
14:48:59 <vincenz> http://www.cafepress.com/buy/haskell/-/pv_design_details/pg_2/id_3049084/opt_/fpt_/c_/hlv_t
14:49:10 <blackdog> shouldnt you filter for is_awake first? you don't wanna code in your sleep then just throw it away. ;)
14:49:14 <bolrod> >:/
14:49:30 <bolrod> you can dream!
14:49:32 <bolrod> duhhhhhhh
14:49:57 <blackdog> ... i think coding in your sleep should trigger an exception :)
14:50:10 <bolrod> nat rly
14:50:15 <JohnnyL> explain graph reductiopn
14:50:27 <newsham> repeatStuff f = f >> repeatStuff f ?
14:50:28 <bolrod> erh
14:50:34 <bolrod> indeed
14:50:44 <bolrod> or more 1337
14:50:56 <bolrod> repeatStuff f = f >>= \_ -> repeatStuff f
14:50:59 <bolrod> ;)
14:51:21 <newsham> i thougth there was a prelude func for that
14:51:44 <bolrod> but do is just the same as this
14:52:43 <basti_> \x _ -> x   is "const" btw.
14:52:46 <basti_> @type const
14:52:47 <lambdabot> forall a b. a -> b -> a
14:52:54 <xerox> >>= \_ -> is >> btw.
14:53:02 <bolrod> xerox: I just said that!
14:53:04 <basti_> that was bolrods point
14:54:05 * xerox should stop popping up randomly in others' conversations.
14:54:11 <bolrod> haha
14:54:14 <bolrod> nah.. it's ok
14:55:48 <bolrod> http://www.cafepress.com/buy/haskell/-/pv_design_details/pg_1/id_5443932/opt_/fpt_/c_/hlv_t  
14:55:52 <bolrod> ??
14:55:52 <lambdabot> Not enough arguments to @.
14:56:26 <blackdog> great error messages of the world, volume 27
14:56:34 <xerox> Anybody played yet with STM + invariants?
14:56:41 * basti_ shakes head
14:56:47 <basti_> but, i suppose it's rule.
14:56:54 <basti_> and rather obvious, again
14:57:09 <xerox> Err.. ?
14:57:27 <basti_> hmm?
14:57:51 <newsham> <vincenz> let fix f = f (fix f) in fix write_code
14:57:51 <newsham> <bolrod> let fix f = do {f; fix f} in fix write_code
14:58:04 <newsham> bolrod: the do variation isnt the fix operator.
14:58:18 <bolrod> its not even an operator
14:58:22 <bolrod> :t do
14:58:27 <bolrod> erh
14:58:31 <bolrod> @type do
14:58:31 <lambdabot> Empty 'do' construct
14:58:38 <basti_> do is syntactic sugar
14:58:40 <bolrod> its syntactic sugar
14:59:00 <bolrod> just like 
14:59:05 <newsham> not "do", "fix f = do {f; fix f}"
14:59:07 <bolrod> > [a| a<-[1,2,3]]
14:59:08 <lambdabot> [1,2,3]
14:59:08 <newsham> *sigh*
14:59:23 <newsham> thats nto "fix"
14:59:44 <bolrod> so what is your point ... ?
14:59:45 <bolrod> :x
14:59:59 * palomer hits bussproofs
15:00:06 <newsham> you were writing something differnt than vincenz' "let fix f = f (fix f) in fix write_code"
15:00:28 <newsham> but giving it the same name.  I assume you were tryign to write the same thing
15:00:28 <bolrod> indeed I was... so ?..
15:00:41 <bolrod> we were talking about putting it on a mug
15:00:41 <bolrod> ;/
15:01:11 <bolrod> and since write_code is probably IO ()...   logically speaking
15:01:30 <bolrod> it makes sense to put it in a do 
15:01:36 <bolrod> aye?
15:01:43 <newsham> still nto "fix" :)
15:02:18 <bolrod> let somestupidname f = do {f;somestupidname f} in somestupidname write_code
15:02:19 <bolrod> better?
15:02:22 <bolrod> ^.0
15:04:20 <bolrod> anywho.. I'm tired
15:38:40 <shamu> anyone have opinions on good resources for learning haskell, for people familiar with imperative programming?
15:39:09 <shamu> botsnack
15:48:26 <dbremner> shamu- Yet Another Haskell Tutorial
16:05:33 <i|> Hmm.
16:06:33 <i|> @pl \x y z -> scanr y z (reverse x)
16:06:33 <lambdabot> flip (flip . scanr) . reverse
16:06:39 <i|> @type flip (flip . scanr) . reverse
16:06:39 <lambdabot> forall a a1.
16:06:39 <lambdabot>            [a1] -> (a1 -> a -> a) -> a -> [a]
16:09:34 <shamu> does anyone have a recommendation on learning haskell, for someone familiar with some imperative languages?
16:09:46 <shamu> or should one start with a different functional language first?
16:11:30 <sjanssen_> Haskell is an acceptable first functional language
16:12:32 <shamu> are there good resources/examples to ease the mental transition from imperative to functional, in haskell?
16:13:08 <i|> @hoogle haskell for c programmers
16:13:09 <lambdabot> Did you mean: Haskell For c Programmers
16:13:09 <lambdabot> Prelude.undefined :: a
16:13:09 <lambdabot> Test.QuickCheck.Batch.bottom :: a
16:13:13 <i|> Oops.
16:13:17 <i|> @google haskell for c programmers
16:13:18 <lambdabot> http://www.haskell.org/~pairwise/intro/intro.html
16:13:34 <i|> That.
16:14:24 <araujo> Does anybody know if there exist something like, "readIfFileExist" ?
16:14:33 <sjanssen_> there's also a ton of stuff at:
16:14:37 <i|> @hoogle Handle -> IO Bool
16:14:37 <lambdabot> IO.hIsClosed :: Handle -> IO Bool
16:14:37 <lambdabot> IO.hIsEOF :: Handle -> IO Bool
16:14:37 <lambdabot> IO.hIsOpen :: Handle -> IO Bool
16:14:40 <sjanssen_> @wiki Books_and_tutorials
16:14:40 <lambdabot> http://www.haskell.org/haskellwiki/Books_and_tutorials
16:15:01 <astrolabe> @learn
16:15:01 <i|> @hoogle Handle -> IO (Maybe String)
16:15:01 <lambdabot> http://www.haskell.org/learning.html
16:15:02 <lambdabot> No matches, try a more general search
16:15:15 <i|> Looks like you'll want hIsEOF.
16:15:46 <sjanssen_> BTW, has anyone seen the Haskell code at PLEAC?
16:16:46 <sjanssen_> http://pleac.sourceforge.net/pleac_haskell/t1.html
16:17:04 <sjanssen_> it's absolutely terrible, maybe we should remove the link to it on the wiki?
16:17:12 <sjanssen_> or fix the code
16:17:54 <shamu> thanks a bunch, I remembered seeing that earlier but didn't come back to it.  I wanted to ask the author if he minded me reformatting it in latex for easier reading
16:18:03 <shamu> botsnack
16:19:42 <astrolabe> @botsnack
16:19:43 <lambdabot> :)
16:22:08 <palomer> grr, \o doesn't work in latex
16:22:12 * palomer kills latex
16:24:22 <vincenz> dons: ping
16:27:07 <shamu> well, latex or lyx
16:27:28 <shamu> it looks like the doc came from some sort of formatting program, but I could be misled
16:27:42 <vincenz> > take 1 v
16:27:43 <lambdabot> "\""
16:27:45 <vincenz> > head v
16:27:46 <lambdabot> Exception: <<loop>>
16:27:55 <bolrod> nat agian
16:28:03 <vincenz> :D
16:28:07 <palomer> what's v?
16:28:10 <vincenz> bolrod: I thought you were tired
16:28:10 <palomer> @type v
16:28:11 <lambdabot> Not in scope: `v'
16:28:14 <bolrod> omg -.-
16:28:14 <vincenz> palomer: the question on everyone's lips
16:28:18 <vincenz> > typeOf v
16:28:18 <bolrod> please..
16:28:19 <lambdabot> [Char]
16:28:23 <vincenz> anyways
16:28:25 <vincenz> bolrod: what do you do
16:28:29 <palomer> > tail v
16:28:30 <lambdabot> Exception: <<loop>>
16:28:35 <bolrod> we know what v is!!!!
16:28:37 <bolrod> >_<
16:28:40 <palomer> what's v?
16:28:46 <vincenz> why does tail v fail too???
16:28:49 <vincenz> that makes NO sense
16:28:55 <bolrod> omg -,-
16:28:55 <palomer> > take 10 v
16:28:56 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
16:29:00 <vincenz> head I can understand, one element does not display
16:29:02 <vincenz> but tail??
16:29:02 <bolrod> yadayadaytada!
16:29:04 <Cale> > v
16:29:05 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
16:29:05 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
16:29:05 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
16:29:05 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
16:29:07 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
16:29:08 <bolrod> NOOOOOOOO!!!!!!!!!
16:29:09 <vincenz> bolrod: what do you do?
16:29:10 <lambdabot> [6 @more lines]
16:29:13 <vincenz> Cale: v is a fixed point of
16:29:17 <bolrod> I dont know!
16:29:20 <vincenz> > let fix f = f (fix f) in fix show
16:29:21 <bolrod> v is very simple
16:29:21 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
16:29:21 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
16:29:21 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
16:29:21 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
16:29:24 <bolrod> no its not that
16:29:24 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
16:29:27 <lambdabot> [6 @more lines]
16:29:29 <vincenz> Cale: but it fails on head and tail, but not on take
16:29:43 <vincenz> which is the puzzling part
16:29:45 <vincenz> even this
16:29:47 <vincenz> > take 1 v
16:29:48 <lambdabot> "\""
16:29:50 <vincenz> > head $ take 1 v
16:29:51 <lambdabot> Exception: <<loop>>
16:29:52 <bolrod> no
16:29:53 <bolrod> its not
16:29:54 <vincenz> > tail $ take 1 v
16:29:55 <lambdabot> ""
16:29:55 <palomer> someone interpret the sequence of \'s as numbers
16:30:02 <bolrod> ok you wanna know
16:30:04 <vincenz> bolrod: what do you do?
16:30:14 <bolrod> sjanssen already gave the solution
16:30:18 <bolrod> vincenz: what do I do what?
16:30:20 <sjanssen_> I thought we solved this v debate a couple hours ago?
16:30:30 <sjanssen_> heh, what bolrod said
16:30:33 <palomer> ok, someone give me some background?
16:30:36 <vincenz> bolrod: student, work, research
16:30:36 <bolrod> > let v = (head v) in v
16:30:37 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
16:30:37 <lambdabot>   Expected type: [a]
16:30:37 <lambdabot>   Inferred type: a
16:30:41 <palomer> is this a puzzle from dons?
16:30:41 <bolrod> or something
16:30:45 <bolrod> > let v = show (head v) in v
16:30:45 <lambdabot> Exception: <<loop>>
16:30:50 <bolrod> > let v = show (take 1 v) in v
16:30:51 <lambdabot> "\"\\\"\""
16:30:56 <bolrod> > let v = show (take 1 v) in read v
16:30:57 <lambdabot> Add a type signature
16:31:00 <bolrod> > let v = show (take 1 v) in read v::String
16:31:01 <lambdabot> "\""
16:31:05 <vincenz> > let v = show (take 1 v) in head v
16:31:06 <lambdabot> '"'
16:31:09 <vincenz> head works
16:31:10 <bolrod> no
16:31:21 <bolrod> > let v = show (head $ take 1 v) in read v::String
16:31:22 <lambdabot> Terminated
16:31:24 <vincenz> so that's not the right definition
16:31:33 <vincenz> Anyways, onto something different
16:31:34 <sjanssen_> palomer: lambdabot changes "> E" into "let v = show E in v", so if you reference v, things get weird
16:31:37 <bolrod> it is..
16:31:43 <vincenz> been trying to make a simple program that simulates actors in an economic simulation
16:31:47 <vincenz> but I'm not sure how to model them
16:32:14 <bolrod> lambdabot changes the expr you type into   > E   ===>   let v = show (E)  in v
16:32:22 <bolrod> or something like that
16:33:03 <bolrod> ok..
16:33:06 <bolrod> now is the time to sleep
16:33:25 <bolrod> @vixen  is it time to sleep?
16:33:25 <lambdabot> yeah, it is
16:33:29 <bolrod> it sure is
16:33:33 <bolrod> good night everybody!
16:33:54 <vincenz> bolrod: night
16:34:02 <heatsink> vincenz: how do the actors make decisions?
16:34:23 <vincenz> heatsink: I'm uncertain as of yet
16:34:35 <vincenz> I want to make a simple system that evolves to a critical state
16:35:51 <vincenz> maybe I should make simple actions
16:35:55 <vincenz> and then have them have a state machine
16:36:00 <vincenz> with some parametrised actions
16:36:03 <vincenz> and then evolve the state machines
17:05:24 <i|> @index typeOf
17:05:24 <lambdabot> Data.Typeable, Data.Dynamic, Data.Generics.Basics, Data.Generics
17:05:31 <i|> > Data.Typeable.typeOf v
17:05:32 <lambdabot> [Char]
17:05:51 <i|> :-)
17:07:24 <dons> moin. oh, everyone's  having fun with 'v' :}
17:07:39 <i|> Heh.
17:07:40 <sjanssen_> yes, it was a great mystery for a while
17:07:58 <dons> hmm.  but I thought I'd randomised the var names
17:08:08 <dons> I'm not sure where this 'v' is defined. hmm
17:08:10 <i|> > let x = head (show x) in x
17:08:11 <lambdabot> Terminated
17:08:16 <i|> > let x = take 1 (show x) in x
17:08:17 <lambdabot> "\""
17:08:21 <i|> Hmm.
17:08:38 <i|> > let head ~(x:xs) = x in head v
17:08:39 <lambdabot> Exception: <<loop>>
17:08:47 <sjanssen_> I say we leave v, it can be fun!
17:09:03 <i|> So how do take work?
17:09:31 <dons> ah,  its  in hs-plugins 'eval' functionn. it doesn't randomise it.
17:09:42 <i|> Aha.
17:09:57 <dons> it's  like thhe 'it' variable in ghci, in some ways
17:10:14 <i|> > let take 0 _ = []; take n (x:xs) = x : take (n-1) xs in take 1 v
17:10:15 <lambdabot> "\""
17:10:41 <i|> > let head _ (x:xs) = x in head 1 v
17:10:42 <dons> in hs-plugins, you'll see eval generate:
17:10:42 <dons> resource = let { v = \n" ++
17:10:42 <lambdabot> Exception: <<loop>>
17:10:44 <dons>         "{-# LINE 1 \"<eval>\" #-}\n" ++ expr ++ ";} in toDyn v
17:10:57 <i|> > let head _ (x:xs) = [x] in head 1 v
17:10:58 <lambdabot> "\""
17:11:02 <dons> where 'expr' come from lambdabot, and itself uses  a 'let', but one that is randomised.
17:11:14 <i|> Hmm...
17:11:22 <dons> however, I don't like  that 'v'. it should be randomised too.
17:11:57 <i|> I keep forgetting that v is not always fix show.
17:12:04 <vincenz> dons: what si v
17:12:08 <vincenz> dons: how come you can't head v
17:12:10 <vincenz> > head v
17:12:11 <lambdabot> Exception: <<loop>>
17:12:17 <vincenz> < take 1 v
17:12:23 <vincenz> > take 1 v
17:12:24 <lambdabot> "\""
17:12:44 <i|> head returns a Char while take 1 returns a String.
17:13:04 <i|> > head (show (undefined :: Char))
17:13:04 <lambdabot> Undefined
17:13:06 <Igloo> It's because show on Char is strict
17:13:11 <i|> Ah.
17:13:20 <vincenz> @where hs-plugins
17:13:20 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
17:13:30 <i|> So how come show on Char is strict while show on String isn't?
17:14:10 <sjanssen_> > ("strange", take (length "strange") $ drop 2 v)
17:14:11 <lambdabot> ("strange","strange")
17:14:28 <i|> Strange.
17:14:43 <dons> its just an artifact, vincenz. it'll be gonne in a few mins..
17:14:59 <vincenz> II don't get it tho
17:15:01 <sjanssen_> aww, I like v!
17:15:21 <i|> vincenz: v is bound to show (theCurrentExpression)
17:15:32 <vincenz> oh
17:15:36 <vincenz> so you can't replicate this in pure haskell
17:15:42 <i|> Sure you can...
17:15:56 <vincenz> > v 1
17:15:56 <lambdabot> Couldn't match `t1 -> t' against `[a]'
17:16:01 <i|> > let x = show (head x) in x -- telling lambdabot "show v"
17:16:01 <vincenz> > Just v
17:16:02 <lambdabot> Exception: <<loop>>
17:16:02 <lambdabot> Just "Just \"Just \\\"Just \\\\\\\"Just \\\\\\\\\\\\\\\"Just \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Just \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Just \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
17:16:02 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Just \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
17:16:02 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Just \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
17:16:03 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
17:16:05 <vincenz> ah
17:16:07 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
17:16:09 <i|> s/show/head/
17:16:10 <lambdabot> [6 @more lines]
17:16:24 <i|> > let x = show (take 1 x) in x -- telling lambdabot "take 1 v"
17:16:25 <lambdabot> "\"\\\"\""
17:16:30 <i|> !
17:16:59 <i|> > read "\"\\\"\"" :: String
17:17:00 <lambdabot> "\""
17:18:12 <vincenz> > let fix f = f (fix f) in fix (++[1])
17:18:14 <lambdabot> Exception: stack overflow
17:18:22 <vincenz> > let fix f = f (fix f) in fix (1:)
17:18:23 <lambdabot> [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
17:18:23 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
17:18:23 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
17:18:23 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
17:18:25 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
17:18:28 <lambdabot> [6 @more lines]
17:19:10 <vincenz> anyways, I'm off *waves*
17:19:19 <i|> Bye bye.
17:20:28 <i|> data Data = Data Int# Int# Data Data | Null Int#
17:23:48 <i|> Is unsafeCoerce# the only polymorphic function that works on unboxed types as well as boxed ones?
17:27:13 <dons> yeah, its a bit magic.
17:27:52 <dons> I can't think of another kind polymorphic function .. since we don't have kind polymorphism..
17:27:57 <dons> yet
17:28:22 <i|> So ? isn't kind polymorphism?
17:28:27 <dons> ?type GHC.Base.unsafeCoerce#
17:28:28 <lambdabot> forall b a. a -> b
17:28:37 <dons> yep. but that's ghc internals.
17:28:43 <dons> not paart of the language.
17:29:05 <dons> ?kind (->)
17:29:06 <lambdabot> ?? -> ? -> *
17:29:26 <i|> So (->) is the only thing that has ? or ?? in its kind?
17:29:39 <dons> but its just a hacked on system for now. well, its a good hack. but not beautifull
17:30:01 <dons> yeah, I think so.
17:37:28 <i|> @index stdout
17:37:28 <lambdabot> System.IO
17:38:22 <dons> > take 30 v
17:38:22 <lambdabot>  Not in scope: `v'
17:38:27 <dons> :)
17:38:41 <i|> > let v = show (take 30 v) in v
17:38:42 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\""
17:39:08 <dons> i don't care if you define your own 'v' :)
17:41:04 <i|> Oops, I forgot that Djinn doesn't do GADT's.
17:43:46 <dons> ?remember i| Oops, I forgot that Djinn doesn't do GADT's.
17:43:46 <lambdabot> Done.
17:44:41 <heatsink> @keal
17:44:41 <lambdabot> Cale etc already pointed out Haskell is puny to nothing to emulate using my barrage of mathematic theories
17:44:55 <dons> I love that one partiicularly
17:45:21 <heatsink> Does it mean something?
17:45:27 <i|> :-)
17:46:02 <dons> that's a good question, heatsink. i'm  not sure.
17:46:10 <dons> and that's part of the magic
17:46:22 <heatsink> yea.
17:48:19 <i|> I was going to do this: data Variable a; data VarM a where {CreateVar :: VarM (Variable a); TakeVar :: Variable a -> VarM a; ReturnVarM :: a -> VarM a; BindM :: VarM a -> (a -> VarM b) -> VarM b}
17:49:02 <i|> s/BindM/BindVarM/
17:49:16 <i|> I suppose lots of stuff would be BindVarM CreateVar TakeVar, though.
17:50:27 <sjanssen_> > let v = show (let fibs = map read $ words $ drop 2 v :: [Int] in unwords $ map show (0 : 1 : 1 : 2 : zipWith (+) fibs (tail fibs))) in take 48 v
17:50:28 <lambdabot> "\"0 1 1 2 2 3 4 5 7 9 12 16 21 28 37 49 65 86 114"
17:51:05 <i|> Nice!
17:51:15 <sjanssen_> it isn't right though
17:51:45 <i|> Oh yeah. Those aren't the Fibonacci numbers :-P
17:58:57 <Revision17> can I create a GUI haskell program using one of the haskell gui toolkits that will run on MS windows in a single executable file (ie no depending gtk or anything)?
17:59:32 <i|> You mean creating standalone executables?
17:59:36 <Revision17> yes
18:00:12 <i|> I guess it'd be a matter of linking the GUI stuff into your program.
18:01:10 <Revision17> well, I know that I could create a static library version of gtk, but that doesn't seem to easy
18:01:14 <Revision17> in terms of time
18:01:37 <heatsink> > let {f x = let {x' = if x /= 0 then f (x-1) else x} in x} in f 8001
18:01:38 <lambdabot> 8001
18:01:49 <heatsink> how big is lambdabot's stack?
18:02:06 <i|> Hmm...
18:02:15 <heatsink> > foldr (+) 0 [0..8001]
18:02:16 <lambdabot> 32012001
18:02:23 <i|> @type fix (flip (const fix))
18:02:24 <lambdabot> Not in scope: `fix'
18:02:24 <lambdabot>  
18:02:24 <lambdabot> <interactive>:1:17: Not in scope: `fix'
18:02:34 <i|> @type let fix x = x (fix x) in fix (flip (const fix))
18:02:35 <lambdabot> forall c. c -> c
18:02:56 <i|> > fix (flip (const fix)) 3
18:03:00 <lambdabot> Terminated
18:03:35 <heatsink> > foldr (*) 0 [0..20000]
18:03:36 <lambdabot> 0
18:03:46 <heatsink> > foldr (*) 0 [0..100000]
18:03:47 <lambdabot> 0
18:04:13 <i|> Maybe there's some kind of optimization thingy going on there.
18:04:24 <i|> > foldr (*) 0 [0..1000000000000000000000]
18:04:26 <lambdabot> Exception: stack overflow
18:04:29 <i|> Nope.
18:04:44 <heatsink> > foldr (*) 0 [0..100000000]
18:04:45 <lambdabot> Exception: stack overflow
18:04:49 <heatsink> ok
18:04:55 <heatsink> > let {f x = let {x' = if x /= 0 then f (x-1) else x} in x} in f 100000000
18:04:56 <lambdabot> 100000000
18:05:00 <Cale> > foldl' (*) 0 [0..100000000]
18:05:04 <lambdabot> Terminated
18:05:37 <heatsink> Okay, so I guess recursive let like the above won't overflow the stack
18:06:06 <heatsink> oops
18:06:10 <heatsink> > let {f x = let {x' = if x /= 0 then f (x-1) else x} in x'} in f 100000000
18:06:14 <lambdabot> Terminated
18:06:22 <heatsink> > let {f x = let {x' = if x /= 0 then f (x-1) else x} in x'} in f 10000000
18:06:24 <lambdabot> 0
18:07:40 * heatsink writes a fixed-point state monad
18:07:55 <i|> A what?
18:08:32 <heatsink> A monad like State, but where some of the state comes from the future.
18:09:04 <Cale> reverse state?
18:09:17 <heatsink> I guess you could call it that.
18:09:18 <sjanssen_> a time travel monad?
18:09:29 <i|> A lottery-winning monad? ;-)
18:09:38 <heatsink> Once I write it, the universe will cease to exist.
18:10:13 <ayrnieu> heatsink - godspeed.
18:10:18 <i|> Let's hope it can also predict whether or not a Turing machine will stop running.
18:11:09 <heatsink> It's for a parser.  Build a symbol table.  Lazily look up symbols in the completed symbol table.
18:11:29 <i|> Oh, right, hmm.
18:11:42 <i|> class unSeq a where unSeq :: a -> a
18:12:30 <i|> unSeq takes a value of a type with only one constructor, and un-stricts it a bit.
18:12:46 <i|> E.g. unSeq x = (fst x, snd x)
18:12:47 <sjanssen_> huh?
18:13:35 <i|> Maybe better: unSeq ~(x,y) = (x,y)
18:13:45 <i|> unSeq ~(I# x) = I# x
18:14:14 <sjanssen_> how about: unSeq x = (const x) () ?
18:14:20 <dons> i|, nick change permanent?
18:14:28 <heatsink> doesn't that stricten it?  Now fst and snd can't be bottom.
18:14:38 <i|> dons: not really.
18:15:01 <heatsink> who am i|?
18:15:07 <araujo> Hello!
18:15:11 <i|> heatsink: what do you mean? (And I'm ihope.)
18:15:58 <heatsink> that's what I meant :)
18:16:36 <ihope> I meant what do you mean by fst and snd not being bottom.
18:16:39 <heatsink> unSeq makes the data less lazy, right?
18:16:51 <ihope> unSeq undefined = (undefined, undefined)
18:17:02 <heatsink> oh, I see.
18:17:24 <ihope> Essentially, seq . unSeq = id, strictness and all.
18:17:25 <sjanssen_> so you just want to lift the errors down one constructor
18:17:36 <ihope> sjanssen_: aye.
18:17:58 <heatsink> unSeq :: () = const ()
18:18:35 <ihope> Yep...
18:19:34 <ihope> Then you could have lazifiers for other constructors, for types where there's more than one.
18:19:48 <ihope> E.g. unSeqCons ~(x:xs) = x:xs.
18:21:29 <heatsink> It would generate an error for ([])?
18:21:50 <ihope> Yep.
18:21:54 <palomer> don't you guys hate it when there's a concept which is cristal clear in your head but it's impossible to explain it to anyone?
18:21:57 <palomer> or put it down on paper?
18:22:09 <ihope> Like monads?
18:22:15 <ihope> ;-)
18:22:24 <heatsink> Like when you drop acid?
18:22:30 <heatsink> ;)
18:22:35 <palomer> monads are cristal clear in your head?
18:22:46 <ihope> Something like that, yeah.
18:22:47 <sjanssen_> ihope: your unSeqCons doesn't generate an error for []
18:23:01 <ihope> sjanssen_: what value does it return?
18:23:06 <palomer> you're clinically insane
18:23:35 <ihope> Okay. Dirty water clear.
18:23:40 <sjanssen_> > let unSeqCons ~(x:xs) = x:xs in unSeqCons [] :: [Int] `seq` ()
18:23:41 <lambdabot> Couldn't match `seq [Int]' against `[]'
18:24:04 <ihope> Oh, I see.
18:24:06 <ihope> You
18:24:11 <palomer> grrr, and this concept is fundamental to my system
18:24:13 <ihope> 're seq'ing it.
18:24:24 <ihope> palomer: well, explain it to us. >:-)
18:24:35 <palomer> hah
18:24:37 <palomer> I would if I could
18:24:57 <ihope> Or at least tell us why it's necessary.
18:25:05 <palomer> wait, I think I have it!!
18:25:07 <heatsink> palomer: Explain by example?
18:25:07 * palomer leaves
18:25:18 <ihope> "Because otherwise things will go plooey" is acceptable...
18:25:31 <palomer> nono, I have it exactly
18:26:04 <ihope> Can you give us some code?
18:26:13 <palomer> no code, just ideas
18:26:25 <palomer> I'll try to write it down on paper, if it fails(it probably will) I'll be back
18:39:55 <ihope> Hmm.
18:39:59 <adu> hi
18:41:29 <ihope> If we skew-whatever a stream of bits then count the number of transitions from 1 to 0, bits "randomly" entered by humans will create much smaller values than actual random ones, I think.
18:43:50 <heatsink> what do you mean by skew-whatever?
18:44:35 <JohnMeacham> does GHC optimize within the body of unfired rules?
18:44:41 <ihope> Divide the stream into pairs, then apply the transform "00" -> "", "01" -> "0", "10" -> "1", "11" -> ""
18:45:06 <adu> ooooo interesting
18:45:30 <adu> won
18:45:33 <dons> hopefully humanity isn't just spewing random bits into the universe, right?
18:45:37 <adu> t that lose information?
18:45:53 <ihope> adu: yes.
18:45:53 <adu> you mean into cyberspace?
18:46:15 <ihope> Is there a good way to implement that thing in Haskell?
18:46:38 <adu> i would think just a function
18:46:50 * morans going on interview tomorrow...
18:46:59 <morans> oops wrong channel...
18:47:01 <ihope> Well, yeah...
18:47:12 <adu> func :: String -> String
18:47:12 <heatsink> People intuitively expect more transitions in a random bit string than naturally occur.
18:47:21 <ihope> skew ('0':'0':xs) = skew xs; skew ('0':'1':xs) = '0' : skew xs; skew ('1':'0':xs) = '1' : skew xs; skew ('1':'1':xs) = skew xs; skew [x] = []; skew [] = []
18:47:24 <adu> then maybe use a Monad or something
18:47:42 <ihope> Maybe we can shrink this a bit.
18:48:38 <sjanssen_> skew (x:y:xs) = if x == y then skew xs else x : skew xs
18:48:55 <ihope> I just typed that.
18:49:07 <ihope> Oh well.
18:49:23 <dons> this function will confuse 'skew', if  he's online
18:49:24 <ihope> > let skew (x:y:xs) = if x == y then skew xs else x : skew xs; skew _ = [] in skew "1001001011010110101010101110101000101101001011101010"
18:49:25 <lambdabot> "1010011111111101111"
18:49:36 <ihope> Notice the long string "111111111"
18:49:44 <heatsink> skew (x:y:xs) = (if x /= y then (x:) else id) skew xs
18:50:14 <ihope> > let skew (x:y:xs) = (if x /= y then (x:) else id) skew xs; skew _ = [] in skew "1010011111111101111"
18:50:15 <lambdabot> Couldn't match `[a]' against `t -> t1'
18:50:30 <ihope> > let skew (x:y:xs) = if x == y then skew xs else x : skew xs; skew _ = [] in skew "1010011111111101111"
18:50:30 <heatsink> > let skew (x:y:xs) = if x == y then skew xs else x : skew xs; skew _ = [] in skew "01001001011010110101010101110101000101101001011101010"
18:50:30 <lambdabot> "1100"
18:50:31 <lambdabot> "010011000000000110000"
18:50:47 <ihope> Nice.
18:51:02 <heatsink> If you shift it by one, it becomes a long string of zeros.
18:54:05 <ihope> > let blum x = (x^2) `mod` (3249751777*2159718031) in take 128 (map (`mod` 2) (iterate blum 2))
18:54:06 <lambdabot> [0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,1,1,0,0,1,0,1,1,1,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,1,0,1,1,1,1,0,0,0,1,0,0,1,0,0,1,1,1,1,1,0,0,0,1,0,0,1,0,1,1,0,1,0,0,1,1,0,0,0,0,1,0,1,0,0,0,0,
18:54:06 <lambdabot> 1,0,0,1,0,0,0,0,0,1,0,0,1,0,1,0,1,1,0,1,1,0,1,0,1,1,1,0,0]
18:54:22 <ihope> Hmm... good enough.
18:55:16 <ihope> > let skew (x:y:xs) = if x == y then skew xs else x : skew xs; skew _ = [] in skew "111111001100101111001000101110100011101000111011110001001001111100010010110100110000101000010010000010010101101101011100"
18:55:16 <lambdabot> "1111111101001011011000100"
18:55:49 <palomer> > let f x = x in f :: a -> b
18:55:50 <lambdabot> 1:15-25
18:55:50 <lambdabot>   Expected type: a -> b
18:55:50 <lambdabot>   Inferred type: a -> a
18:55:57 <palomer> ok, someone explain to me exactly why this doesn't work?
18:56:05 <palomer> like what mechanism in ghc says "this isn't good"
18:56:15 <ihope> The typechecker.
18:56:22 <palomer> what heuristic does it use?
18:56:40 <ihope> I think a modified Hindley-Milner thingamabob.
18:57:08 <palomer> well, the idea I need to clarify is exactly this
18:57:15 <palomer> the subsumption check
18:57:20 <palomer> I have no bloody way of checking how it works
18:57:25 <palomer> err, of explaining
18:57:32 <ihope> @google subsumption check
18:57:33 <lambdabot> http://gtps.math.cmu.edu/htmldoc/subsumption-check.html
18:58:01 <palomer> it isn't as simple as that:/
18:58:06 <palomer> Philippa: ping?
18:58:10 <heatsink> Oh yeah, there's a monomorphism restriction there
18:58:40 <palomer> where?
18:58:49 <ihope> It's a matter of matching variables against variables.
18:58:57 <ihope> Unless they're the same variable, it can't be done.
18:59:00 <palomer> but what exactly is being matched?
18:59:01 <heatsink> On the LHS of let-statement assignments, the typechecker assumes that all variables are monomorphic unless stated otherwise
18:59:13 <heatsink> >let (f :: a -> b) x = x in f :: a -> b
18:59:19 <heatsink> > let (f :: a -> b) x = x in f :: a -> b
18:59:19 <lambdabot>  Parse error in pattern
18:59:56 <heatsink> let {f :: a -> b; f x = x in f :: a -> b}
19:00:06 <heatsink> > let {f :: a -> b; f x = x} in f :: a -> b
19:00:06 <lambdabot>   Quantified type variable `b' is unified with another quantified type variable `a'
19:00:06 <lambdabot>   When trying to generalise the type inferred for `f'
19:00:06 <lambdabot>   Signature type:     forall a b. a -> b
19:00:27 <ihope> Boomies.
19:00:35 <palomer> this concept is incredibly important
19:00:39 <palomer> but noone knows how its done
19:00:40 <palomer> gah!
19:00:51 <heatsink> well, that's because it universally quantifies over a and b... it's different
19:01:13 <palomer> what's different?
19:01:23 <heatsink> There's a paper from the seventies about Algorithm W that's rather terse, but a good reference once you get through it.  I think Damas was the author.
19:01:35 <palomer> W deals with annotations?
19:01:51 <heatsink> No, W is the basic hindley-milner type inference algorithm.
19:02:04 <heatsink> It doesn't deal with recursive let.
19:02:26 <palomer> let isn't the issue here
19:02:36 <palomer> it's the annotations
19:02:46 <heatsink> The type annotations?
19:02:51 <palomer> f::a -> b
19:02:56 <palomer> @seen Philippa 
19:02:57 <lambdabot> Philippa is in #haskell, #haskell-blah, #haskell-overflow and #scannedinavian. Last spoke 8 hours, 2 minutes and 59 seconds ago.
19:03:12 <heatsink> As I understand it, that means that f is a function from _any_ a to _any_ b
19:03:21 <palomer> heatsink: it does
19:03:24 <palomer> it's obviously false
19:03:29 <heatsink> right.
19:03:52 <palomer> but I'm wondering how the type checker knows this
19:03:57 <heatsink> Oh, I see
19:04:00 <heatsink> Let me check
19:04:10 <palomer> I think it does one sided unification
19:04:22 <palomer> but I'd like to see a good presentation of this
19:05:58 <palomer> (you can assume that I know about type inference when explaining anything)
19:08:36 <heatsink> Okay, I can't help you there.
19:09:17 <palomer> yeah, it's tough stuff
19:09:21 <palomer> someone should publish a paper on this
19:09:28 <heatsink> By one-sided unification, do you mean that it looks for a substitution S such that S(Type1) = Type2?
19:09:53 <palomer> I didn't mean that
19:09:56 <palomer> but that could be it
19:09:57 <palomer> lemme think
19:10:20 <palomer> yeah, that's probably it
19:10:22 <palomer> I'm an idiot
19:11:53 <heatsink> Actually, the ghci message is more informative
19:12:51 <heatsink> It suggests to me that it does regular unification, but excludes "a" and "b" from any kind of substitution.  The closest match it can do is (a -> a).
19:13:20 <palomer> heatsink: yeah, that's what I had meant for one sided unification
19:13:30 <palomer> certain variables cannot be substituted
19:15:09 <heatsink> okay.  Hey, I learned something.
19:40:21 <Cufisz> hello all
19:41:01 <Cufisz> I'm just starting to learn Haskell with "the haskell school of expression" by Paul Hudak
19:41:36 <Cufisz> However when i compile one of the early graphics examples with GHC it runs terribly slowly
19:41:48 <Cufisz> it looks like it's not even running at all when looking at the task manager
19:41:50 <Cufisz> any ideas?
19:41:52 <dons> did you compile with -O ?/
19:41:58 <Cufisz> i tried -O2
19:42:04 <dons> are you using gtk2hs, or OpenGL ?
19:42:24 <Cufisz> i'm just using import Graphics.SOE
19:42:38 <dons> (its perfectly possibly to write very fast graphics code, you just need to use the right libraries)
19:42:51 <dons> probably the tutorial isn't trying to teach fast graphics coding
19:42:56 <Cufisz> well, i think something strange is going on
19:43:19 <Cufisz> because it's just a hello world program and it takes many minutes before even the window pops up
19:43:23 <dons> sounds like it. I dodn't know if anyone has much experience with SOE,  though.
19:43:27 <dons> oh. that's terrible.
19:43:31 <dons> somethings broken
19:43:53 <Cufisz> import Graphics.SOE
19:43:53 <Cufisz> main	=	runGraphics (
19:43:53 <Cufisz> 			do	w <- openWindow "Hello" (300,300)
19:43:53 <Cufisz> 				drawInWindow w (text(100,200) "Hello graphics world!")
19:43:53 <Cufisz> 				k <- getKey w
19:43:53 <Cufisz> 				closeWindow w
19:43:55 <Cufisz> 		 	)
19:44:08 <Cufisz> sorry, that's the program.. so as you can see very simple... any obvious mistakes?
19:44:22 <dons> haskell runs near C speed when compiled with -O on ghc, so ... hmm... move on and try a different graphics lib?
19:45:05 <dons> maybe you could try the OpenGL lib instead, if its graphics you want to play with?
19:45:20 <palomer> this proves that haskell is slow.
19:45:22 <Cufisz> hmm, it's a shame though because a lot of the examples in the book are based on this library
19:45:34 <dons> palomer, thanks  :)
19:45:39 <palomer> :)
19:46:07 <dons> I've not heard of the SOE lib in the last few years. maybe its jsut old and inefficient?
19:46:07 <palomer> haskell may be slow, but at least it's incredibly hard to get anything to typecheck
19:46:20 <palomer> Cufisz: paste in a pastebin
19:46:21 <dons> thanks palomer. in a good mood?
19:46:25 <dons> ?palomerr
19:46:25 <lambdabot> hrmph
19:46:38 <palomer> oh pshaw, I'm always like this
19:46:41 <Cufisz> it would have to be terribly inefficient though... i think i must be doing something wrong somewhere
19:46:45 <Cufisz> what's a pastebin?
19:46:51 <palomer> www.rafb.net/paste
19:47:02 <palomer> you should paste in a pastebin from now on (in case the channel is being used)
19:47:59 <Cufisz> ok, thanks
19:48:03 <palomer> so paste!
19:48:06 <palomer> so I can try your code
19:48:36 <dons> Cufisz: you  might want to use one of the graphics libs we actually use day to day, such as those found here: http://haskell.org/ghc/docs/latest/html/libraries/
19:48:53 <dons> also, check that the SOE lib is actually compiled? where'd you get it? 
19:48:54 <morans> rafb has no haskell highlighting?
19:49:17 <Cufisz> it comes with GHC
19:49:23 <dons> it does?
19:49:28 <dons> what package?
19:49:28 <Cufisz> appears not to have highlighting
19:49:30 <palomer> morans: it doesn't
19:49:34 <palomer> lisp.net would be better
19:49:55 <palomer> but I use rafb.net for _everything_
19:50:25 <Cufisz> dons, sorry i'm not sure even which package to tell you..?
19:50:29 * morans been meaning to play at extracting vim syntax highlighting for use in more general scenarios
19:50:32 <dons> ah, in HGL/Graphics/SOE ?
19:50:42 <Cufisz> I just installed GHC for win32 and from main.hs "import Graphics.SOE"
19:50:58 <Cufisz> or rather in main.hs
19:51:52 <dons> hmm. is mingw just slow? the bindings might be inefficient on windoes.
19:52:24 <Cufisz> mingw is usually pretty fast
19:52:39 <Cufisz> even g++ through cygwin (unix emulator) is pretty fast
19:54:05 <Cufisz> if anyone cares to take a peak the code is at: http://www.rafb.net/paste/results/LGXeQa73.html
19:54:07 <dons> well, I'm at a  loss. I've not heard of this problem before. I think your next move would be to mail haskell-cafe@haskell.org and ask there about slow Graphics.SOE.
19:54:35 <Cufisz> alright, thanks dons
19:54:36 <dons> there's nothing in  those 4  lines of code.
19:54:46 <dons> it's more likely something with  the HGL lib, I reckon.
19:54:50 <dons>  or something system related
19:54:56 <Cufisz> yes, that would make sense
19:55:19 <dons> it would be worth writing a little OpenGL or other haskell graphics lib program, to check they run at normal speed
19:55:57 <Cufisz> well, i have some c++ opengl stuff compiled with mingw that runs fine.
19:55:58 <Cale> when people say a given language is slow, it makes me grit my teeth :)
19:56:20 <palomer> works great here
19:56:29 <palomer> assembly is slow
19:56:31 <Cufisz> hehe, it's not even slowness.. the window hasn't yet popped up since i've started execution when the topic started =)
19:56:42 <Cufisz> but i have seen it pop up after leaving for a coffee
19:56:48 <Cale> Cufisz: hmm
19:56:55 <dons> something's broken then.
19:56:57 <Cale> Cufisz: which platform is this?
19:57:00 <Cufisz> win32
19:57:01 <dons> that's my diagnosis.
19:57:08 <Cufisz> hehe, thanks dons =)
19:57:09 <palomer> Cufisz: this is how it's done in haskell land. if you want usability try java or something
19:57:13 <Cale> I wonder if it's been heavily tested at all on win32
19:57:33 <dons> palomer is terribly grumpy today
19:57:41 <Cale> hehe
19:57:43 <palomer> more goofy than grumpy
19:58:18 <Cale> you're using GHC?
19:58:26 <Cufisz> yup
19:58:35 <Cufisz> 6.4.1
19:58:44 <Cale> maybe try Graphics.HGL instead
19:58:55 <Cale> It's just a newer version of the same library
19:59:08 <Cale> (Graphics.SOE is for compatibility with the book)
19:59:52 <dons> yeah,  the documentationn for Graphics.HGL seems quite useful, Cufisz 
20:00:08 <dons> the example you posted is in the documentation.
20:00:31 <Cufisz> hmm, same thing with Graphics.HGL
20:01:13 <dons> vincenz, ping?
20:03:54 <Cale> I wonder if something is causing it to block. Maybe insert print "a", print "b", etc. between the lines and see where it's getting stuck.
20:04:28 <dons> palomer, you going to put up some papers on http://haskell.org/haskellwiki/Research_papers/Type_systems ?
20:05:11 <dons> at least in the gadt section?
20:06:27 <palomer> sure sure
20:06:30 <palomer> might as well sign up
20:07:47 <Cufisz> hmm, well it's getting stuck at the open window call. But the strange thing is that it doesn't seem to be getting much cpu time.
20:07:50 <palomer> do you want me to add all the papers I know of?
20:08:31 <Cale> Cufisz: hmm, it works perfectly for me in X11 on Debian
20:08:42 <Cufisz> thanks cale!
20:08:49 <Cufisz> I'm just not sure where to go with this now...
20:09:02 <Cale> yeah, that's odd -- I wonder if ndm is about
20:09:06 <Cale> I know he's on win32
20:09:23 <gizban> how do I use a side effect like,  putStr "asdf",  in haskell, which is a functional language?
20:09:43 <Cale> @type putStr "asdf"
20:09:43 <lambdabot> IO ()
20:09:48 <Cale> It's an IO action
20:10:12 <Cale> there are operations for composing IO actions with one another in various ways
20:10:33 <Cale> in the end, you define an IO action called main
20:10:42 <Cale> and this is what runs
20:10:43 <palomer> there, added my favourite paper
20:10:49 <dons> palomer, well, Haskell stuff that you can categorise. and you have the url of  a pdf or .ps version
20:11:04 <palomer> oh, my GADT stuff is certainly not haskell-centric
20:11:06 <dons> so, inn the same format as  the existing material
20:11:10 <Cale> @type (>>)
20:11:11 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> m b -> m b
20:11:18 <dons> no, it doesn't have to be. background is good to.
20:11:22 <Cale> @type (>>) :: IO a -> IO b -> IO b
20:11:23 <lambdabot> IO a -> IO b -> IO b :: forall a b. IO a -> IO b -> IO b
20:11:26 <Cale> hehe
20:11:33 <Cale> dons: there's a bug :)
20:11:48 <dons> hehe
20:11:49 <dons> yes.
20:11:56 <dons> I  blame  TheHunter
20:14:33 <gizban> I'm trying to make a very simple program just to test this.  Lets say I wanted to make a function that adds one to an int that's the input, and I also want to putStr "asdf" in this function.  How do I do this?
20:14:55 <dons> gizban, have you read the tutorials on haskell.org?
20:15:28 <gizban> no, I'll do that now.  I was trying to work from slides that I have.
20:15:46 <dons> look under the 'Learning' heading.
20:28:56 <palomer> though, to be fair, my favourite paper isn't very good at all
20:28:58 <palomer> >:O
20:29:10 <palomer> it is the most comprehensible
20:29:17 <palomer> the wobbly types paper is very much incomprehensible
20:29:22 <palomer> (& friends)
20:30:07 <palomer> <:O
20:33:09 <dons> grr. paramaterising a function by record selectors needs a new class :}
20:34:23 <dons> oh well.
20:35:27 <dbremner> dons - there's also http://haskell.readscheme.org/ but it hasn't been updated in awhile.
20:39:46 <dons> dbremner, cheers. I'll incorporate that.
20:40:16 <dons> maybe it'll flourish a bit better on a  wiki on haskell.org.  i hope so, at least
20:46:05 <ncalexan> dons: are you a vi or an emacs user?  (Or a third editor user :)
20:46:50 <dons> vim :) sometimes  yi
20:47:53 <ncalexan> Yeah, I figure.d
20:48:31 <ncalexan> This whole yi-is-emacs-in-Haskell thing sounds nice until you confront the things that make emacs successful.
20:50:06 <ncalexan> Docstrings, the advice mode, incremental programming... not exactly Haskell's strong points.
20:50:22 <Cufisz> For those interested in the extremely slow execution of Graphics.SOE code in GHC, it appears to be a compiler issue. Works fine with HUGS.
20:53:47 <dons> I think the only issue that we really don't have yet is  a nice embeddable ghci.  the other things can be done. mostly its man power.
20:54:02 <dons> Cufisz:  very strange! worthy of an email
20:54:06 <dons> maybe a bug report.
20:54:26 <Cufisz> yup.. i'm checking out the newest release of GHC to see how it runs there and if not i'll submit one.
20:54:28 <ncalexan> Yes, the ghci situation is problematic.
20:54:45 <dons> well, we ghc-api now. so not so bad.
20:55:02 <ncalexan> But I don't see any nice way to support adding advice to a function.
20:55:27 <ncalexan> Maybe you see a nice way?
20:55:44 <dons> i don't buy that we have to emullate exactly the structure of  emacs. we'd use  typeclasses for many of these things.
20:55:53 <palomer> ok, anyone here have ghc-cvs installed?
20:55:59 <palomer> can't figure out how to get it to work
20:56:16 <ncalexan> dons: can you elaborate?
20:58:41 <ncalexan> The only way I see to make a func, say foo, have some kind of runtime changeable representation is scatter fooFunc <- loadCurrentFoo's everywhere... not very attractive.
20:59:19 <ncalexan> Or making every foo (even pure foo's) be essentially in IO, just to look up the current foo... that makes the baby Jesus cry.
21:00:10 <palomer> haskell GADTs suck.
21:00:12 <dbremner> ncalexan- it's not Haskell, but someone at INRIA wrote an extensible editor in O'Caml.
21:01:05 <ncalexan> I think I've seen that.
21:04:38 <ayrnieu> efuns.
21:04:41 <dons> its  not so bad.  you store your reloadable stuff ni a state monad as data, and lookup values that may be replaced, indirectly
21:05:10 <ncalexan> dons: AFAICT, it is so bad.  Ideally, every function can be rewritten.
21:05:14 <dons> so code looks  up other code indirectly, via a table. as lambdabot does.
21:05:44 <dons> right. so you reload code on the  level of the  module.
21:06:59 <dons> so really what you have  is a first class module concept. such that  you can rebind modules at runtime
21:07:19 <dons> as we did in yi and in lambdabot.
21:07:49 <dons> to make the  system more responsive you'd have a embeddable ghci interpret code that is changed often.
21:08:00 <dons> resorting to compiled code for more  stable things
21:08:44 <ncalexan> ATM, is it possible to have stable module A (f, g) and have the user just define a new A.f?
21:08:51 <dons> ncalexan: you've read the yi paper,  no?
21:08:56 <ncalexan> Yes.
21:09:08 <ncalexan> But I can't actually experiment with this stuff because it's borked on Mac OS X.
21:09:14 <dons> ah, right.
21:09:34 <ncalexan> And so I can't test something important:
21:10:01 <ncalexan> If I compile f = const g, and then redefine g, I need to recompile g.
21:10:06 <ncalexan> Sorry, recompile f.
21:10:27 <ncalexan> Which means you essentially can't touch the editor internals, because you'll have to rebuild the beast each time.
21:10:57 <ncalexan> Maybe this is on purpose?  Maybe that's not the behaviour?
21:10:58 <dons> sorry, where's f and where's  g?
21:11:44 <ncalexan> Does it matter?  My problem is really if f is deep in the stable editor tree and g is a little function that could be redefined by the user.
21:12:07 <ncalexan> For example, (setq yes-or-no-prompt 'y-or-n-prompt).
21:12:13 <dons> if you go messing inside the editor, you need to recompile stuff.
21:12:33 <dons> but i really want to emphasise the i find the emacs stuff rather illdisciplined
21:12:40 <ncalexan> As I thought.
21:12:43 <ncalexan> Oh, I completely agree.
21:12:47 <dons> we don't want to slavishly do what they do.
21:13:10 <dbremner> dons - my guess is you won't use dynamic scoping. ;-)
21:13:42 <ncalexan> I think what I want is dynamic scoping at the top-level.
21:13:51 <dons> yeah. whatt's the point of dng such a system in haskell if you're going to throw out the benefits of static typing 
21:13:56 <palomer> haskell GADTs suck, have I said this?
21:14:06 <ncalexan> More than once, palomer.
21:14:11 <dons> ?palomer
21:14:11 <lambdabot> hrmph
21:14:22 <palomer> ?palomer
21:14:23 <lambdabot> hrmph
21:14:29 <palomer> my favourite quote
21:14:35 <dons> oh, it's like looking into a  mirrow!
21:14:52 <palomer> how do I add a quote?
21:15:11 <gizban> unexpected ';', possibly due to bad layout.   There's no semi-colins anywhere in the expression
21:15:44 <palomer> maybe you should add one
21:15:57 <gizban> what does the semi colin due in haskell?
21:17:36 <dons> semi colin, is a bit like Colin when he's drunk.
21:17:56 <palomer> don't mind dons, all he does is complain and pick on the newbies
21:18:14 <dons> thankyou palomer.
21:18:41 <dons> gizban: it means that the layout of your code is confused somewhere.
21:18:48 <dons> so too much or too little indentation
21:19:01 <dons> around the line the that error message says you need a ;
21:19:15 <palomer> >:O)
21:19:17 <dons> (haskell inserts ; for you, instead of having to write them explicitly)
21:19:41 <rasfar> @quote lambdabot
21:19:42 <lambdabot> lambdabot hasn't said anything memorable
21:19:42 <dons> so when you get an error about ;, its referring to a site it was inserting ; 
21:20:24 <palomer> ghc gives crappy error messages
21:20:53 <palomer> I mean really, really crappy
21:21:06 <dons> don't mind palomer, he's a bitter old man who doesn't get enough sleep or enough type inference
21:21:30 <palomer> I'm 23
21:21:35 <palomer> I slept 13 hours
21:22:05 <dons> :P
21:22:18 <palomer> and all I do is type inference
21:22:21 <dons> too much sleep then!
21:22:22 <palomer> I have too much type inference
21:22:28 <palomer> make up your mind, woman!
21:22:57 <dons> its very clear to me all this type inference and lseep is making your stir-crazy
21:23:13 <dons> that's my diagnosis
21:23:15 <palomer> I spent all day today doing type inference
21:23:22 <palomer> man it's cooky
21:23:43 <dons> I proscribe a course of perl and oprah on the tv.
21:23:55 <dons> proscripe oprah. prescribe perl
21:24:16 * dons plays with new bouncy happy hacking keyboard.
21:24:53 <gizban> Last generator in do {...} must be an expression.  Anyone know what that means?
21:25:18 <dons> indentation again, most likely
21:25:28 <dons> or you forget to return () ?
21:25:41 <dons> or whatever you're returning
21:26:16 <palomer> gizban: I find that pasting the code and the error in a pastebin and asking the channel gets a much more concise answerr
21:26:33 <dons> its my birthday today. happy birthday dons :)
21:26:51 <dons> gizban: yep, show the code. much easier
21:27:15 <dons> lispaste: url
21:27:20 <dons> lisppaste: url
21:27:21 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
21:27:36 <gizban> here's the code, http://pastebin.com/650711
21:27:42 <palomer> happy birthday dons
21:27:52 <palomer> if you were in montreal, I'd bring you out for a cocktail
21:28:03 <dons> ooh. a cocktail :) 
21:28:05 * dons blushes
21:28:11 <araujo> hiya!
21:28:17 <araujo> happy birthday dons !
21:28:26 <dons> thanks araujo. how's the code?
21:28:58 <dons> that's some crazy indenting gizban
21:29:51 <gizban> does the indention really make a difference?
21:30:46 <dons> its a layout sensitive language unless you use explcit { ; }
21:31:03 <dons> ok, i've cleaned up the layout. lets see.
21:31:26 <dons> ttp://pastebin.com/650715
21:31:39 <dons> still, the Just case is way too complex
21:32:54 <dons> and there's some typos.  trying again..
21:34:09 <dons> you don't write function application like this: fst (t), you write: (fst t)
21:34:27 <araujo> dons, ooh, it's cool! , im adding  a new feature right now
21:34:27 <araujo> dons, btw, i already wrote something, should i send it to you?
21:34:49 <dons> yes. it'll get into today's HWN if you send it now
21:34:51 <dons> now!
21:35:03 <gizban> where are there typos?
21:35:18 <araujo> dons, ggod!!, sending right now!
21:36:12 <palomer> fst(t) is fine, just not haskellish
21:36:36 <dons> in his code, it actually broke the code.
21:36:43 <dons> maybe fst(t)
21:36:49 <dons> isn't maybe (fst t)
21:36:49 <palomer> maybe(fst(t))
21:36:56 <gizban> there's still errors, but those are probably my fault
21:37:14 <dons> here's an alternative http://pastebin.com/650719
21:38:24 <dons> gizban: use 'let' or 'where' to name subexpressions from complex structures. makes it easier to check that you're putting things together the right way
21:42:17 <gizban> can fst be used on a type that is Maybe?
21:42:20 <araujo> dons, you've got mail ;-)
21:43:02 <palomer> gizban: nope
21:43:12 <dons> yes, indeed I have , araujo :) thanks.
21:43:12 <palomer> @type fst
21:43:13 <lambdabot> forall a b. (a, b) -> a
21:43:19 <araujo> :-)
21:43:21 <palomer> notice that fst takes a pair, not a Maybe
21:43:52 <dons> @type fromMaybe --perhaps?
21:43:53 <lambdabot> Not in scope: `fromMaybe'
21:44:02 <dons> @type Maybe.fromMaybe
21:44:02 <lambdabot> forall a. a -> Maybe a -> a
21:44:21 <palomer> fromMaybe takes a default?
21:44:22 <palomer> strange.
21:44:32 <dons> in case of Nothing.
21:44:37 <dons> @type Maybe.fromJust
21:44:38 <ncalexan> What would fromMaybe Nothing be?
21:44:38 <lambdabot> forall a. Maybe a -> a
21:44:41 <gizban> I originally had "maybe pc fst (state)",   when you changed it to "maybe pc (fst state)"   it gave an error
21:44:54 <palomer> @type fromJust
21:44:54 <lambdabot> Not in scope: `fromJust'
21:45:05 <palomer> @type Maybe.fromJust
21:45:06 <lambdabot> forall a. Maybe a -> a
21:45:12 <palomer> righto
21:45:22 <dons> gizban, oh, maybe I read your code wrong? where you using 'fst' as a selector in some way?
21:45:29 <dons> in which case the (state) might have thrown me 
21:45:35 <dons> @type Maybe.maybe
21:45:37 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
21:46:19 <gizban> it's very confusing code, but you helped me solve my problem.  Now I have errors else where in the program to fix.
21:47:07 <dbremner> @google haskell layout rule
21:47:09 <lambdabot> http://www.haskell.org/onlinereport/lexemes.html
22:15:45 <gizban> haskell should be called hassle.  It's taking me hours to add IO to a working program.
22:17:23 <dons> usually you just put a top level wrapper in that does the io.
22:18:06 <dons> its actually a very clean, crisp io system, once you understand to use. sprinkling io trhough a pure program though is a bit evil, and will waste your time.
22:18:15 <dons> so you had a working pure haskell program?
22:18:21 <gizban> yeah
22:18:29 <dons> what were the io requirements?
22:18:45 <dons> that you had to had.
22:19:03 <gizban> output colored squares http://www.cosc.brocku.ca/Offerings/4V81/Assignment4.html
22:19:05 <dons> had to add.
22:19:47 <dons> so, could you take the result of the pure code and dump it out somehow?
22:20:09 <dons> i.e. mapM_ putStrLn or something similarly easy?
22:20:31 <gizban> not just the result.  Each step has to change the screen.
22:20:53 <dons> what is the type of the pure code? does it give you a list of things?
22:21:09 <gizban> it outputs either 1 or 0 at the end
22:21:16 <dons> in which case you could interperse io through the list, and let lazyness handle it.
22:21:26 <dons> depends on how you've written in it.
22:21:39 <dons> if you've written it in such a way that you can't get back all intermediate states
22:21:46 <dons> then you need to lift all the code into the IO monad
22:22:08 <dons> otherwise, you could sequence_ [ print x | x <- result ]
22:22:12 <dons> the later is much much easier.
22:22:44 <dons> otherwise its like sprinkling print statements on every evaluationg step, no?
22:23:12 <gizban> Core War is like an emulator.  When a single instruction is executed, I need to add a colored square to the output.
22:24:19 <gizban> I hate my prof for making us write a bloody emulator in a functional language.  This would have been so much easier in C++
22:24:29 <dons> can you write a function: eval (x:xs) = d result <- eval x ; print result ; eval xs ?
22:24:39 <dons> nah, interpreters/emulators are easy in haskell.
22:24:42 <dons> since its all structure hacking
22:24:55 <dons> but adding io into code that wasn't written to do io can be a bit tedious
22:25:20 <gizban> yeah, that's what I'm experiencing now
22:25:46 <dons> so there's no way to cleanly interleave io and pure parts?
22:26:20 <dons> you can't write a function that takes one step, pritns a result, and then takes the next?
22:26:32 <dons> then you'd avoid adding io to everything (since most of the code is pure anyway)
22:27:21 <Cale> If you just want to print messages for debugging, there's Debug.Trace
22:27:41 <sjanssen> you have something like: runStep State -> State now?
22:27:54 <Cale> but you shouldn't rely on any of those sort of messages being printed in any particular order or number of times
22:28:04 <gizban> I had to modify quite a bit of stuff so I could pass the window variable and the program colors to the internal code that does the actual IO
22:28:33 <dons> hmm. i don't like the sound of thei internal code that does io. usually the external skin of the program does the io
22:29:02 <sjanssen> I'd turn runStep into a function like this: State -> (State, Window -> IO ())
22:31:31 <sethk> dons, I have a moderately strange thing, or perhaps I'm misinterpreting
22:32:06 <sethk> dons, I discovered that I really don't need the handle on handleRequest (it's only needed for getRequest/putRequest which we moved to the Server class)
22:32:16 <sethk> dons, so I took it out, and rebuilt things, and didn't get any compilation errors
22:32:28 <sethk> dons, but I haven't changed the handle functions
22:33:32 <dons> hmm
22:33:58 <sethk> maybe my dependencies aren't correct, I'll do a make clean
22:34:14 <sethk> dons, I use --make, but in my makefile I use conventional notation to figure out what needs to be rebuilt
22:34:14 <dons> but did you change the calls to handleRequest?
22:34:19 <sethk> dons, no
22:34:26 <sethk> dons, and I did rebuild one server and one client
22:34:29 <dons> then something's funny
22:34:41 <sethk> dons, maybe it's a dependency thing.  I'll erase the .o and .hi files
22:34:48 <dons> so,  handleRequest :: Handle -> a -> IO b isn't the type anymore?
22:35:03 <sethk> dons, right, just a -> IO b
22:35:11 <dons> in which case, ClientSerer.hs shouldn't compile.
22:35:12 <sethk> let me make sure I edited the right files and such
22:35:24 <dons> since the runServer body calls handleServer with a handle
22:35:25 <sethk> dons, this sounds like I'm looking for something complicated and I really just did something dumb
22:35:29 <sethk> dons, right
22:35:29 <dons> yep. sounds like dependencies.
22:35:55 <dons> i can't think of anything other than dependencies that would cause something wierd like this.
22:36:08 <sethk> dons, yes, never mind, it's me  :)
22:36:22 <sethk> dons, I found a really nasty bug in the old C code
22:36:31 <sethk> dons, I've got binary values rolling over
22:36:31 <palomer> sethk: http://adrinael.net/wrong.jpg
22:36:34 <dons> ok .good :) Haskell's semantics _aren't_ borken :) phew!
22:36:46 <palomer> ghc semantics may very well be
22:36:48 <sethk> dons, something like that just _might_ get noticed  :)
22:36:52 <palomer> and their GADTs are crap
22:37:27 <dons> argh
22:37:56 <dons> grumpy old palomer.
22:38:26 <palomer> I'm not old!
22:38:28 <dons> palomer, show us the code... submit the patches... publish the new improved Generalise Abstract Palomer Types paper :)
22:38:28 <palomer> nor grumpy
22:38:34 <sjanssen> palomer: I enjoy that picture
22:38:41 <palomer> sjanssen: I adore it
22:38:53 <palomer> I will, I will
22:39:00 <palomer> as soon as I figure out how to do type inference
22:39:14 <dons> yeah, good image.
22:45:13 <dbremner> dons - I've found some uses for this image. http://img3.imageshack.us/my.php?image=nopony1st.jpg
22:45:39 <palomer> not bad
22:45:52 <sethk> dons, I want to add a function to the Server class that displays a request or a response.  Both Request and Response are instances of Show.  How do I write one function that will take either a Request or a Response argument?
22:46:15 <sethk> dons, all I do with the argument is something like hPutStrLn stderr (show requestOrResponse)
22:47:39 <dons> let me think.
22:47:59 <sethk> dons, it's easy to do with two functions; if it isn't obvious, I can just do that
22:48:54 <dons> you can always write a more general function:
22:48:55 <dons> showRequestOrResponse :: Show a => a
22:48:56 <dons> showRequestOrResponse = print
22:49:13 <dons> same as hPutStrLn stderr . show, almost
22:49:27 <dons> sorry, type wrong:
22:49:29 <dons> showRequestOrResponse :: Show a => IO a
22:49:32 <dons> showRequestOrResponse = hPutStrLn . show
22:49:45 <sethk> dons, that works
22:50:05 <dons> if you want to constrain it. we need a new class for things that are only Requests ore Responses. or maybe an existential.
22:50:16 <dons> but I think in this case, a more general function is fine.
22:50:21 <sethk> dons, for a debugging function, is it necessary?
22:50:30 <dons> right. I don't think it is :)
22:50:33 <sethk> dons, you answered while I was typing  :)
22:50:41 <dons> just have a single function that works on any Show a
22:50:55 <sethk> right
22:51:45 <dons> helps if I actually run the typechecker:
22:51:47 <dons> showRequestOrResponse :: Show a => a -> IO ()
22:51:47 <dons> showRequestOrResponse = hPutStrLn stderr . show
22:51:50 <dons> :}
22:52:08 <dons> which is just print, in the end
22:52:18 <sethk> dons, can I just hPrint, then?
22:52:27 <dons> ah yeah. good idea
22:52:42 <dons> showRequestOrResponse = hPrint stderr
22:53:09 * dons continues writing the weekly news
22:53:31 <araujo> yay!
22:54:15 <sethk> dons, I have a Bool that I added to runServer, which I'm calling verbose, to enable/disable the trace messages
22:54:22 <sethk> so I guess it is:
22:54:42 <sethk> showRequestOrResponse :: Show a => a -> Bool -> IO ()
22:54:50 <dons> that'd do.
22:55:21 <dons> in one program I wrote, I had: data LogLevel = Debug | Info | Warn | Fatal | Ignore
22:55:32 <dons> for multi level logging
22:55:35 <sethk> dons, I have something similar in my WTrace class
22:55:42 <sethk> dons, but I'm not sure I want that cross dependency
22:55:57 <sethk> dons, makes the ClientServer class less general
22:56:31 <sethk> dons, and I can always do  a case logLevel of ... with a couple of runServer calls with the Bool True or False for various levels
22:56:38 <sethk> dons, and that way we don't polute the Server class
22:56:45 <dons> or pass a Maybe LogLevel
22:56:53 <dons> so for no logging just provide a Nothing
22:56:57 <dons> otherwise some value.
22:56:58 <sethk> dons, that's an idea
22:57:03 <dons> but yes. it does pollute it a bit.
22:57:18 <sethk> dons, but won't the compiler insist on knowing what a LogLevel is even to accept a Maybe LogLevel?
22:57:26 <dons> i can think of a couple of solutions, but its all abotu the same amoubnt of code.
22:57:33 <dons> yes.
22:57:41 <dons> you could have a type LogLevel = Bool
22:57:56 <dons> or some other way. but you still need to have that imported into ClientServer.hs
22:58:32 <sethk> you use   showRorR = hPrint stderr     but how do I work my Bool into that?  it's a partial application?
22:58:57 <dons> ok, so expand it: showRorR v = hPritn stderr v
22:58:58 <sethk> I can just do   case verbose of   in the caller
22:59:09 <dons> then add your bool argument to that
22:59:19 <sethk> that's better, I think, than putting case or if/then/else in the caller
22:59:46 <dons> or use a guard.
23:00:06 <sethk> the guard is easier to follow (for me at least), but yours' looks nicer  :)
23:00:28 <dons> showRorR  verbose a
23:00:28 <dons>     | verbose   = hPrint stderr a
23:00:28 <dons>     | otherwise = return ()
23:00:31 <dons> perhaps ?
23:01:07 <sethk> hmm, I have something I've seen before that I don't quite understand.  I've put this function within the instance definition (in the same place we put the runServer call).  The compiler complains that the definition uses none of the class type variables
23:01:14 <sethk> should I put it outside the class definition?
23:01:30 <dons> yes. if it has nothing to do with the class
23:01:43 <dons> if its a helper you could stick it in a 'where' clause on the runServer
23:01:49 <dons> otherwise, just somewhere in the module
23:01:56 <sethk> ok
23:02:12 <dons> inside the instance defn you can only have method instances for that class
23:04:19 <sethk> dons, I tried your   foo v = hPrint stderr v and it complains that I'm applying hPrint to too many arguments.  Do I use parens to get rid of that?
23:04:45 <sethk> hmm, no, I think I did it wrong
23:04:54 <dons> @type System.IO.hPrint
23:04:54 <lambdabot> forall a.
23:04:54 <lambdabot>        (Show a) =>
23:04:54 <lambdabot>        GHC.IOBase.Handle -> a -> IO ()
23:04:59 <sethk> I put my Bool in the signature, but using that method I think it doesn't go in the signature
23:05:01 <dons> nope, takes a handle and an arg
23:05:34 <sethk> I'll just use the guard for now, and figure out the partial application after I get the guard working
23:06:24 <dons> this:             showRorR True request works with 
23:06:24 <dons> showRorR :: Show a => Bool -> a -> IO ()
23:06:25 <dons> showRorR  verbose a
23:06:25 <dons>     | verbose   = hPrint stderr a
23:06:25 <dons>     | otherwise = return ()
23:06:38 <dons> no need for the partial application if you're passing in 2 args.
23:07:07 <dons> though you'd write it like:
23:07:08 <dons> showRorR  verbose
23:07:08 <dons>     | verbose   = hPrint stderr
23:07:08 <dons>     | otherwise = const $ return ()
23:07:10 <dons> :)
23:07:23 <sethk> why const?
23:07:34 <dons> hPrint stderr has type a -> IO ()
23:07:39 <dons> so does const $ return ()
23:07:49 <dons> it takes an 'a', throws it away, and returns () in IO
23:07:55 <dons> @type return ()
23:07:56 <lambdabot> forall (m :: * -> *). (Monad m) => m ()
23:07:59 <dons> @tyuep const (return ())
23:08:00 <lambdabot> forall (m :: * -> *) b. (Monad m) => b -> m ()
23:08:39 <sethk> it's a trick to make the two clauses have the same signature
23:09:00 <dons> yep. they're both functions of 1 unamed argument now.
23:09:16 <dons> hPrint stderr takes an unamed arg, so does const (return ())
23:09:28 <dons> you could write: \_ -> return ()
23:09:55 <sethk> then you would yell at me for using >>=  :)
23:11:34 <dons> hehe
23:11:40 <dons> its ok. but no more than 1 line of it.
23:12:55 <dons> lambdabot's getting a spring clean....
23:19:00 <sethk> dons, I think it might be good to create a class that combines Server with methods to listen/accept on the server side and connect on the client side.  I don't want to put that into Server because it breaks my client/server are threads of the same process use case (unless I let the process connect to itself, which might be ok)
23:19:08 <newsham> flush out the imperative residue thats built up?
23:21:32 <sethk> dons, another thought.  There is a common situation where I have a request that really has no response other than "ok, I did it".  Can a specific response (a constructor on a Response instance) be coded in the class definition?
23:21:48 <sethk> dons, it isn't a function so it can't be a class function
23:23:26 <dons> you could have a null Response default, perhaps.
23:23:53 <dons> so, its the putResponse that jsut returns (), indicating its done?
23:24:09 <dons> no, getResponse?
23:24:30 <sethk> yes
23:24:50 <sethk> that's the general idea
23:24:59 <dons> possibly you could have : getResponse :: (HasStatus r) => Handle -> IO (Maybe r)
23:25:46 <dons> or write an instance of Response for ()
23:26:39 <gizban> how do I convert a type IO Bool to  just plain Bool ?
23:26:52 <dons> x <- foo
23:27:00 <dons> where foo returns IO Bool
23:27:06 <newsham> unsafePerformIO?  ;-)
23:27:14 <gizban> does it have to be inside a "do" block?
23:27:18 <dons> no, its almost always the do notation you want.
23:27:20 <newsham> wait, I wasnt suppsoed to say that was I?
23:27:21 <dons> yep
23:27:32 <dons> do x <- getBool
23:27:49 <gizban> can a do be inside another do?
23:28:30 <dons> in the same function? or do you mean can one IO function call another?
23:28:53 <gizban> inside the same function
23:28:59 <dons> do x <- ... ; y <- .... ; .... return ()  is how you stack up multiple statements
23:29:08 <dons> (you can replace those ; with newline)
23:29:27 <dons> inside the same block, yes. sure. but its not as common. and you probably don't want that.
23:29:45 <dons> unless you mean on an if then else or some tother kind of branch ?
23:30:05 <dons> do x <- f ; when (abc) $ do .... ; if True then do z else do y
23:30:09 <dons> its all good
23:30:21 <gizban> yeah, I have an if then else inside a do, then I need more do's inside the if and else
23:31:13 <dons> yeah, each time you open up a new monadic block, you start it with a 'do'
23:32:50 <gizban> omg I actually got ouput, ha
23:33:26 <rasfar> congrats on that
23:34:00 <dons> good work. io isn't so hard :) and you get karma every time you use a monad, its the cosmic will.
23:34:18 <newsham> so no karma for non-haskellites?
23:34:27 <sethk> dons, I actuallyl managed to add the Bool to runServer and get the instance and type declarations right by myself.  Of course, the fact that they are unchanged helped a bit ...
23:34:38 <dons> pretty soon every language will have karma. now that ruby has them.. and i'm sure ocaml must try to get  them.
23:34:51 <dons> will get karma, since they will have monads
23:35:12 <newsham> monads in ruby?  hmm.. 
23:35:36 <dons> yeah, it was on ltu recently
23:36:07 <dons> and the ocaml implementation of funky continuations needed monads
23:36:23 <dons> as the alternative was to write it all in C
23:39:46 <sethk> what's wrong with this:
23:39:51 <sethk> foo x
23:40:02 <sethk>     | value = return True
23:40:08 <sethk>     | otherwise = return False
23:40:10 <sethk> where
23:40:15 <sethk>     case x of
23:40:30 <sethk> it gives me a pattern error on the case x of line
23:40:33 <dons> where ... = case x of ....
23:40:37 <dons> 'where' needs to bind something
23:41:07 <sethk> ah, ok
23:41:07 <dons> where value = case x of ... ?
23:41:22 <sethk> is it possible in a case to have more than one pattern share the same code?
23:41:28 <sethk> in C you would say
23:41:30 <sethk> case x:
23:41:34 <sethk> case y:
23:41:37 <sethk>     some code ...
23:42:04 <sjanssen> sethk: not exactly
23:42:08 <dons> yes. using guards. but its a bit trikcy
23:42:15 <dons> its not identical
23:42:24 <sethk> ok, tell me anyway
23:43:32 <dons> here's two cases I can think of:
23:44:07 <dons> case c of
23:44:07 <dons>     3                    -> 4
23:44:07 <dons>     c | c == 1 || c == 2 -> 5
23:44:07 <dons> case () of {_
23:44:07 <dons>     | c == 1 || c == 2 ->
23:44:10 <dons>     | c == 3           ->
23:44:12 <dons> }
23:44:29 <newsham> in C you cant easily define a closure to call in both cases
23:46:06 <sethk> dons, I think I should probably avoid that in the interest of readability
23:46:29 <sethk> dons, plus the fact that I don't feel like figuring out why it works.  Looks like BNF  :)
23:47:45 <dons> it just resorts to guards, where you can combine multiple matches with || on a single branch
23:47:50 <dons> i guess the trick is that you can put a guard in there in the first place
23:48:16 <dons> any binding site, bar lambdas, takes a guard, iirc
