00:00:06 <shapr> Sure, and on ice as well.
00:00:10 <mahogny> x_x
00:00:27 <shapr> I have a 3" tire and a 65mm wide rim. And I have a 3.7" tire I'll install as soon as I get the right flavor of allen wrench.
00:00:28 <ValarQ> shapr: special tires?
00:00:32 <rashakil> it'd be great to have a physically accurate unicycle in a video game
00:00:45 <Korollary> heh
00:00:49 <mahogny> shapr, you have to show me that stuff when you get down here :)
00:01:05 <shapr> Sure, yeah.
00:01:18 <ValarQ> is shapr going down?
00:01:37 <shapr> But you can probably see it out the window if you watch Ulf or Daniel coming to the CS department.
00:02:09 <mahogny> hmmm. never seen them on unicycles. but I have my own times when I come and go o_O
00:03:26 <shapr> This is the sort of setup I have now, except my frame is designed for a larger tire - http://www.gb4mfg.com/temp/lm_test/Dscf2959.jpg
00:04:15 <mahogny> :o rigged
00:04:58 <mahogny> but wait, you don't have any gears have you?
00:05:02 <mahogny> how do you get up to speed?
00:05:56 <shapr> This shows the 3.7" tire on a prototype frame - http://www.unicyclist.com/forums/showthread.php?s=&threadid=39644
00:06:03 <shapr> You just pedal quickly :-)
00:06:16 <shapr> I'm using 170mm cranks for mountain unicycling.
00:06:53 <mahogny> hmmm
00:06:55 <shapr> Short cranks let you go faster, but give you less power going up hills. My setup is tuned for off road rough terrain unicycling.
00:07:24 <mahogny> ...and I usually consider 18 levels too few :/
00:07:48 <shapr> I'm fine with one :-)
00:08:00 <mahogny> looks nice
00:08:30 <shapr> On flat ground I can go faster than the average person can run, and uphill I can go faster than a bicycle in low gear.
00:09:03 <mahogny> well, you'd have to go faster, otherwise it would be a mess :)
00:26:52 <Lokadin> can anyone point me to a howto or tutorial that includes sockets?
00:27:18 <Lemmih> Lokadin: Seen the Haddock documentation for Network?
00:27:38 <Lokadin> yea, but i don't know how to work with sockets period
00:27:59 <Lokadin> hmmm i guess i can just look up a general socket tutorial
00:30:45 <Lokadin> so say, for a basic echo server i would need, listenOn accept and sendTo?
00:31:08 <Lokadin> or,,, i don't really wanna waste your time
00:31:14 <Lokadin> *shrugs*
00:32:14 <Lokadin> or without sendTo? here i think i might get it thanks
00:35:54 <musasabi> main = withSocketsDo $ let loop = accept >>= forkIO . work >> loop
00:36:55 <musasabi> work (h,_,_) = setBuffering h LineBuffering >> let loop = hGetLine h >> hPutLine >> loop in loop
00:51:10 <dons> @pl work (h,_,_) = setBuffering h LineBuffering >> let loop = hGetLine h >> hPutLine >> loop in loop
00:51:11 <lambdabot> (line 1, column 8):
00:51:11 <lambdabot> unexpected ","
00:51:11 <lambdabot> expecting letter or digit, variable, "(", operator or ")"
00:51:16 <dons> bah
00:51:26 <dons> musasabi: that's a nice little idiom :)
01:10:10 <yaarg> 4
01:11:55 <sethk> is there an IMAP library available?
01:35:29 <|Fo|Ns> hi
01:42:06 <Cale> |Fo|Ns: hi
01:42:26 <Cale> |Fo|Ns: new here?
01:42:49 <|Fo|Ns> yes
01:43:06 <Cale> any questions about haskell?
01:43:09 <|Fo|Ns> well, I was here asking some things a while ago
01:45:18 <|Fo|Ns> I was wondering if there is a was a way to do pattern matchings such us (Constructor a a)
01:45:48 <Cale> where the meaning is that the two a's are equal?
01:45:51 <|Fo|Ns> yep
01:46:44 <Cale> You can't quite do it like that, though I've thought about things along those lines. However, a guard will work just as well, though it's a bit more typing.
01:46:54 <Cale> Constructor a b | a == b
01:47:47 <resiak> Is there any particular reason why it's not legal to say Foo a a ?
01:48:11 <musasabi> resiak: think about typos.
01:49:05 <musasabi> myfun (Foo (Bar a) (Something _ (Complex x (Left a) _ z))) = ... "oops two times a"
01:49:16 <musasabi> would make for nice pattern matching bugs.
01:50:41 <|Fo|Ns> Cale, thanks
01:51:32 <resiak> Mmm, good point.
01:57:54 <Lokadin> say with darcs, how do you have a stable branch and an unstable branch? i mean with the stable branch does it just stop at a certain patch number?
01:59:03 <musasabi> Lokadin: you have two different repos one for stable and one for unstable.
02:04:48 <shapr> sethk: I think HAppS might have IMAP. wli wrote a simple imap downloader many years ago, dunno where it is now.
02:05:14 <sethk> shapr, thanks much
02:05:36 <Lokadin> musasabi: oh okay thanks :)
02:07:29 <Lokadin> say can anyone tell my why this echo server doesn't work properly  http://paste.lisp.org/display/19295
02:08:10 <musasabi> sethk: HAppS does not have IMAP at the moment.
02:08:20 <sethk> oh, well
02:08:40 <sethk> have to use python I guess
02:10:05 <Lokadin> i mean it seems to make sense logically
02:10:12 <Lokadin> but it doesn't echo
02:10:13 <Lokadin> or quit
02:10:29 <Lokadin> just listens
02:12:25 <shapr> xerox_: IMAP module
02:13:24 <lisppaste2> Lokadin annotated #19295 with "Echo Server modified but still not working" at http://paste.lisp.org/display/19295#1
02:13:40 <Lokadin> :(
02:13:56 <Lokadin> i even put in linebuffering
02:22:32 <xerox> Buon giorno.
02:30:46 <Lokadin> so could anyone perhaps try it and see if it works?
02:30:51 <Lokadin> maybe it does
02:31:00 <Lokadin> but i'm just an incompetent tester...
02:31:06 <shapr> xerox: IMAP and other protocol modules would be good SoC ideas as well.
02:31:12 <Lokadin> which is quite possible
02:31:26 <boegel> shapr: how about a cycle-accurate simulator in Haskell ? :)
02:32:40 <xerox> shapr: nice idea.  Is there some hierarchy where to pose them in right now?
02:35:57 <shapr> xerox: http://ocamlnet.sourceforge.net/doc/goals/goals.html
02:36:35 <xerox> shapr: *this* is what you mean.  Cool.
02:37:12 <shapr> We've already got cgi, ftp, http, and irc.
02:37:31 <shapr> I'm not sure about smtp and pop3, but I know imap4 would be useful.
02:37:39 * xerox goes scribbling on the wiki
02:37:57 <shapr> nntp would be nice too
02:38:37 <xerox> Haskellnet? :-)
02:45:12 * drrho is away: dancing
02:50:17 * shapr is here: trying to keep from working
02:50:57 <Lokadin> is that so
02:51:11 <Lokadin> that sounds like fun
02:51:45 <shapr> It's fun right now, but it's not fun when I get my bills.
02:53:04 <Lokadin> lol
02:53:09 <Lokadin> well what do you do?
02:53:31 <Lokadin> i mean wouldn't you still get paid regardless of whether you do your work?
02:54:03 <PeterK> depends
02:54:07 <mathrick> awww, damn
02:54:19 <mathrick> for a moment there I thought I was really smart
02:54:25 <shapr> Lokadin: Nah, I'm a contract programmer and I only get paid for the hours I actually work.
02:54:33 <shapr> Or at least, I only charge for the hours I really work.
02:54:44 <Lokadin> oh, that's nice of you :)
02:54:45 <bolrod> seems fair
02:58:47 <Lokadin> bolrod: say could you help me figure out how to work a simple haskell echo server i found online
02:58:50 <Lokadin> ?
02:59:33 <bolrod> ?.. I don't know if I'd understand it.. never used haskell with networking
02:59:33 <lambdabot> compose module failed: Parse error: "I"
02:59:39 <mathsew> what is an elegant way to do a breadth first search in haskell?
03:00:11 <mathsew> I'm searching a large, complex logical data structure, but I'm thinking that seeing a breadth-first tree search would give me insight into how to solve the problem
03:00:12 <shapr> Which way does the list monad do searching?
03:00:13 <Lokadin> bolrod: oh okay, have you ever tested a socket program that echos?
03:00:30 <mathsew> list monad is equivalent to backtracking; eg. depth-first
03:00:42 <bolrod> nop..  and I won't now...  I'm starving to death
03:00:44 <shapr> mathsew: make your type an instance of Functor?
03:00:44 <mathsew> s/eg./i.e./
03:00:49 <bolrod> I'll go eat something now :)
03:00:52 <Lokadin> bolrod: :( why?
03:00:53 <Lokadin> kk
03:00:54 <Lokadin> :)
03:00:56 <Lokadin> that's good
03:01:03 <mathsew> shapr, and...?
03:01:11 <bolrod> food is good
03:02:00 <shapr> mathsew: And your fmap definition will traverse the type breadth first?
03:02:22 <mathsew> oh... kay... but then where does the search come in
03:02:42 <mathsew> search :: (a -> Bool) -> Tree a -> a
03:02:44 <mathsew> for example
03:02:52 <mathsew> I don't see how a functor will help me there
03:03:43 <shapr> search predicate thattree = fmap predicate thattree
03:04:00 <mathsew> hmm.. then I get a Tree of Bools back
03:04:33 <shapr> What about search :: (a -> Maybe a) -> Tree a -> a
03:05:13 <vincenz> re
03:05:23 <mathsew> well the problem remains, once I have my tree of Bools (or Maybe a)s...
03:05:26 <Saulzar> Hmm, guess you still need a queue. A queue of functions to search 1 deeper (and return a list of more functions)
03:05:30 <mathsew> I still need to search the tree to find out which one matched
03:05:38 <shapr> and then search predicate thattree = head $ catMaybes . fmap predicate thattree
03:05:40 <vincenz> mathsew: what are you trying to do?
03:05:58 <mathsew> shapr, this is an infinite tree...
03:06:05 <shapr> ok?
03:06:11 <mathsew> vincenz, it's actually a logic programming problem
03:06:19 <vincenz> mathsew: I just entered and missed the context
03:06:27 <shapr> Infinite data structures are perfectly fine in that code.
03:06:36 <vincenz> mathsew: what does the tree look like, typewise?
03:06:38 <mathsew> shapr, are you misunderstanding what fmap does?
03:06:46 <shapr> I hope not...
03:06:47 * shapr checks
03:06:53 <mathsew> data Tree a = Leaf a | Branch (Tree a) (Tree a)
03:06:54 <mathsew> typical
03:06:54 <vincenz> mathsew: making a bfs for a tree isn't really difficult
03:07:02 <vincenz> oh wait
03:07:08 <vincenz> mathsew: that's impossible
03:07:12 <vincenz> mathsew: you only have data at the leafs?
03:07:14 <vincenz> and it's an infinite tree?
03:07:18 <mathsew> vincenz, oh
03:07:19 <mathsew> whoops
03:07:32 <mathsew> say I have data on the branches too
03:07:32 <vincenz> or did you mean
03:07:42 <vincenz> data Tree a = Leaf | Branch a (Tree a ) (Tree a)
03:07:49 <mathsew> I'm looking for an elegant solution that I can generalize to a much more complex problem
03:08:00 <mathsew> vincenz, sure
03:08:01 <shapr> Is fmap strict?
03:08:08 <mathsew> no, I don't believe so
03:08:13 <norpan> how can it be
03:08:15 <shapr> So, why wouldn't it work?
03:08:20 <vincenz> bfs (Leaf x ) = return x
03:08:24 <mathsew> but fmap :: (Functor f) => (a -> b) -> f a -> f b
03:08:31 <vincenz> bfs (Leaf x ) = [x]
03:08:42 <mathsew> whereas you seem to think it's like: fmap :: (a -> b) -> f a -> g b
03:08:44 <mathsew> or something
03:08:50 <vincenz> bfs (Branch x l r) = x:(bfs l ++ bfs r)
03:08:59 <vincenz> lazy list
03:09:03 <vincenz> erm
03:09:03 <vincenz> wait 
03:09:06 <vincenz> that's depth first
03:09:11 <Saulzar> Hehe.
03:09:17 <mathsew> yeah, depth first is really easy in many ways in fp
03:09:31 <xerox> shapr: added!
03:09:33 <vincenz> but I once saw how moving from dfs to bfs was as simple as placing your ++ elsewhere
03:10:02 <Saulzar> A queue with a state monad would be simplest I am guessing, same as imperitive style
03:10:18 <vincenz> ideally you would yield you results
03:10:30 <shapr> I've seen some simple solutions in Rabhi & Lapalme's "Algorithms : A Functional Programming Approach"
03:10:33 <mathsew> Saulzar, that's what I'm thinking too.  Unfortunately, a "purer" solution would be better, as the State method is very hard to generalize
03:10:35 <shapr> Sadly I don't remember them off the top of my head.
03:10:43 <Saulzar> Hmm
03:10:57 <vincenz> aha
03:11:06 <mathsew> (waits in anticipation)
03:11:19 <norpan> one good method is to use a priority queue
03:11:44 <norpan> works very good in a lazy setting
03:11:46 <mathsew> norpan, uh... trying to get away from imperative methods here
03:11:51 <shapr> What about using fmap to turn your a into a Maybe a, and then do the catMaybes trick on the tree instead of a list?
03:11:52 <norpan> yes
03:12:01 <mathsew> norpan, can you give an example
03:12:04 <norpan> you have a bfs that returns a priority queue of all elements
03:12:14 <mathsew> shapr, that's solving the wrong problem
03:12:16 <vincenz> mathsew: gime a second to code it up
03:12:17 <vincenz> mathsew: I got it
03:12:19 <shapr> It is?
03:12:29 <mathsew> shapr, the problem is to order the nodes in the tree in a breadth-first manner
03:12:38 <mathsew> once you can do that, you can solve the problem
03:12:38 <shapr> Your fmap instance does that.
03:12:44 <mathsew> fmap does no ordering
03:12:54 <Saulzar> He's worried about the traversal problem
03:12:58 <mathsew> fmap just changes things 'in place"
03:13:18 <vincenz> woo
03:13:22 <mathsew> :-)
03:15:03 * vincenz finds a paste site
03:15:30 <shapr> fmap does traversing though, doesn't it?
03:15:32 <vincenz> http://rafb.net/paste/results/3vzSpJ44.html
03:15:53 <mathsew> shapr, yes, but *how* it does the traversing is immaterial to the programmer
03:15:54 <Saulzar> shapr, But you still need to traverse the fmaped tree :)
03:16:06 <mathsew> I just need an ordering of the nodes..
03:16:13 * mathsew has concluded that's the best way to think of it
03:16:14 <vincenz> mathsew: look at athat site
03:16:18 <vincenz> mathsew: not test but should work
03:16:18 <mathsew> yep, going
03:16:27 <vincenz> not tested even
03:16:28 <shapr> Ah, I see.
03:16:42 <vincenz> obviously that datastructure is bad
03:16:47 <vincenz> you don't have any way of making an empty tree
03:16:56 <vincenz> you could probably clean it up a bi
03:17:01 <vincenz> make value return not a list
03:17:03 <vincenz> but just the value
03:17:07 <vincenz> and then instead of concatMap
03:17:08 <vincenz> just plain map
03:17:10 <vincenz> for value
03:17:14 <mathsew> vincenz, quite nice
03:17:18 <norpan> having values both in Branch and Leaf is obviously bad
03:17:20 <mathsew> I think that does it
03:17:25 <vincenz> norpan: yeah
03:17:52 <vincenz> http://rafb.net/paste/results/oi16NA37.html
03:17:55 <vincenz> paste 2
03:17:57 <norpan> hmm is there a good priority queue in haskell
03:18:03 <mathsew> I'm not using anything remotely close to that data structure in practice
03:18:36 <xerox> ?docs Data.Queue
03:18:37 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Queue.html
03:18:44 <mathsew> Actually, my favorite layout that is consistent with the original is:  data Tree a = Tree a [Tree a]
03:18:46 <Lokadin> say, if i was to make a program in parts, say for instance, with no core, what would be the best way to go around it communicating?
03:19:31 <Lokadin> say different parts of it?
03:19:44 <mathsew> thanks guys
03:19:58 <norpan> xerox: that's just a fifo
03:20:04 <xerox> :-|
03:21:36 <shapr> xerox: What was the module Cale recommends? Strategy or something?
03:22:19 <noj> does anyone know the status of GHC on intel/osx?
03:22:39 <xerox> Control.Parallel.Strategies
03:23:00 <xerox> evaluate . (`using` rwhdf) -- or something
03:23:19 <musasabi> Control.Parallel.Strategies ?
03:23:20 <vincenz> mathrick: that would work perfectly
03:23:29 <vincenz> he left?
03:23:48 <shapr> Are there docs for Strategies somewhere?
03:24:22 <xerox> shapr: *maybe* in the sources.
03:25:07 <shapr> Seems that the docs are here - http://www.cee.hw.ac.uk/~dsg/gph/papers/
03:25:41 <musasabi> The Clean people have many things about strategies that may be relevant.
03:26:47 <shapr> I'm still thinking about mathsew's question, seems like there should be some sort of 'traversal' typeclass.
03:27:02 <musasabi> There is something like that in 6.5
03:27:21 <shapr> ?
03:27:49 <musasabi> http://darcs.haskell.org/packages/base/Data/Traversable.hs
03:28:01 <musasabi> and http://www.soi.city.ac.uk/~ross/papers/Applicative.html
03:28:45 <shapr> ah, extra spiffy.
03:29:01 <xerox> Strawberry flavoured!
03:30:00 <vincenz> musasabi: what is this?
03:30:17 <shapr> Seems like fmap could be automatically derived for instances of Traversable.
03:30:33 <vincenz> shapr: most likely
03:31:12 <shapr> Or maybe it can just be defined directly?
03:31:23 <vincenz> actually
03:31:27 <vincenz> don't know
03:31:30 * shapr quickly hacks...
03:31:35 <vincenz> traverse doesn't tell you the type of the node you're traversing
03:31:40 <vincenz> and for each type that'll be different
03:34:49 <shapr> Huh?
03:37:27 <dcoutts> dons, yay
03:37:51 <dcoutts> > [| + |]
03:37:52 <lambdabot>  parse error on input `+'
03:37:58 <shapr> It's (Functor t, Foldable t) => Traversable t, neat.
03:38:02 <dcoutts> > [| (+) |]
03:38:04 <lambdabot> GHC.Num.+
03:38:07 <xerox> O_O
03:38:18 <shapr> wah?
03:38:20 <dcoutts> > let genex_power n = let genex_power' n x = if n == 0 then [| 1 |] else [| $x * $(genex_power' (n-1) x) |] in [| \x -> $(genex_power' n [| x |]) |] in genex_power 5
03:38:22 <lambdabot> \x_0 -> x_0 GHC.Num.* (x_0 GHC.Num.* (x_0 GHC.Num.* (x_0 GHC.Num.* (x_0 GHC.Num.* 1))))
03:38:26 <xerox> @karma+ dons -- woo!
03:38:27 <lambdabot> dons's karma raised to 32.
03:38:29 <shapr> dcoutts: What the heck?
03:38:39 <dcoutts> shapr, wmahahahaha!
03:38:41 <xerox> hahaha.
03:39:28 <dcoutts> shapr, it's either my research work or my next entry for the obfuscated Haskell contest
03:39:48 <xerox> > foldr ([| (:) |]) [] [1,2,3]
03:39:49 <lambdabot> Couldn't match `a -> b -> b' against `ExpQ'
03:39:52 <xerox> Wops.
03:40:01 <shapr> Is TH available in lambdabot now?
03:40:05 <dcoutts> it's a generating extension for the power function
03:40:09 <dcoutts> shapr, yep
03:40:15 <dcoutts> "safe TH"
03:40:18 <shapr> Wow, how'd that get safe?
03:40:20 <dcoutts> without the IO bits
03:40:22 <shapr> impressive.
03:40:24 <xerox> Indeed.
03:40:52 <dons> shapr, yeah, we worked out a safe subset. no reify or runIO.
03:41:21 <dons> where reify == the info function (i don't know why its calle 'reify')
03:41:35 <dcoutts> shapr,as you can see the result is a perfect unfolding of the power function: \x -> x * x * x * x * x * 1
03:42:14 <xerox> Very very very nice.
03:42:37 <shapr> Yeah, gorgeous.
03:42:38 * xerox <- [| lunch |]
03:42:51 <dcoutts> the output of my partial evaluator is supposed to be such generating extensions
03:43:06 <shapr> Speaking of which... any of your research online?
03:43:19 <dcoutts> appart from that above, no 
03:43:40 <shapr> Ah well
03:43:50 <xerox> dons: if you have any soc project ideas feel free to add them on the wiki! (applying today, hopefully)
03:44:23 <dons> ok. i've got a list. just need to put them up.
03:56:23 <int-e> > let genex_power n = let g 0 x = [| 1 |]; g 1 x = x; g n x = (if odd n then \y -> [| $x * $y |] else id) [| let y = $x * $x in $(g (n`div`2) [| y |]) |] in [| \x -> $(g n [| x |]) |] in genex_power 5
03:56:24 <lambdabot> \x_0 -> x_0 GHC.Num.* (let y_1 = x_0 GHC.Num.* x_0
03:56:24 <lambdabot>         in let y_2 = y_1 GHC.Num.* y_1
03:56:24 <lambdabot>           in y_2)
03:58:20 <int-e> @where lambdabot
03:58:21 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
04:00:00 <Lokadin> omg!!!!!!! it worked
04:00:02 <Lokadin> !!!
04:00:05 <Lokadin> i'm sooo happy :)
04:00:06 <Lokadin> lol
04:01:32 <Lokadin> aren't you happy for me?!! :) i was annoying everyone for soo long!! :)
04:01:33 <Lokadin> lol
04:01:40 <Lokadin> my localhost was down :(
04:01:47 <Lokadin> er lo interface
04:08:27 <araujo> morning!
04:08:58 <tromp> g'afternoon
04:09:49 <tromp> l
04:10:01 <dons> can anyone think of a way to write this:
04:10:01 <dons> instance                             Show (a -> b) where show _ = "<function>"
04:10:03 <dons> instance (Typeable a, Typeable b) => Show (a -> b) where show e = '<' : (show . typeOf) e ++ ">"
04:10:07 <kolmodin> morning araujo!
04:10:20 <araujo> kolmodin, hi!
04:10:23 <araujo> dons, hi!
04:10:24 <dons> such that it compiles.
04:10:42 <shapr> What error do you get? =)
04:10:47 * shapr never thought he'd say that to dons 
04:11:33 <musasabi> dons: one ends up needing undecidable-instances probably.
04:12:02 <dons> I'm not sure that works, because the context is different, not the type you are instantiating
04:12:23 <dons> if it was Show (Int -> b) and Show (a -> b), overlapping would work.
04:12:39 <dons> but I don't know if we have a mechanism for distinguishing contexts.. ?
04:12:47 <musasabi> newtype Wrap t = Wrap { unWrap :: t }
04:13:21 <musasabi> and then defined wrapped instances (no undecidable ones), and then the undecidable unwrapped->wrapped
04:14:08 <dons> hmm. but then I'd have to wrap the functions, no? which isn't going to work in lambdabot's @eval code :)
04:14:18 <dons> newtypes would do it, yeah.
04:16:34 <dons> it seems undecidable instances would let me distinguish C Int b => ... from C a b => ..., but that's not quite the problem here.
04:18:47 <dons> > putStrLn
04:18:49 <lambdabot> <[Char] -> IO ()>
04:19:03 * dons felt like liberalising @eval a bit
04:19:34 <dons> > \x -> x :: Int
04:19:35 <lambdabot> <Int -> Int>
04:19:42 <dons> cool and the gang
04:20:13 <dons> > putStrLn "x"
04:20:14 <lambdabot> No IO allowed
04:20:16 <dons> good.
04:20:26 <dons> > \x -> x
04:20:27 <lambdabot> Add a type signature
04:20:44 <Saulzar> Nice, much better than "Add instance show for ...."
04:20:49 <dons> that's the inability to overlap my instances, to distinguish monomorphic from polymorphic values
04:21:14 <dons> Saulzar: cheers. lambdabot has some crafty regexes for sweetening the type errors like that
04:25:30 <xerox> dons: wow.
04:26:05 <musasabi> dons: what kind of instances did you end up with?
04:26:19 <musasabi> > (\x -> x x)
04:26:20 <dons> just the Typeable one.
04:26:20 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
04:26:20 <lambdabot>   Expected type: t
04:26:20 <lambdabot>   Inferred type: t -> t1
04:26:27 <dons> polymorphic ones fail
04:26:32 <dons> > \x -> x
04:26:32 <xerox> ?version
04:26:33 <lambdabot> Add a type signature
04:26:33 <lambdabot> lambdabot 3p414, GHC 6.4.1 (Linux i686 3.20GHz)
04:26:33 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
04:26:36 <dons> > \x -> x :: ()
04:26:37 <lambdabot> <() -> ()>
04:26:48 <musasabi> > (\x -> fix x)
04:26:49 <lambdabot> Add a type signature
04:26:54 <dons> if I could have a backup instance, I could print something useful for \x -> x.
04:27:35 <musasabi> dons: instance Show (a -> a) does not work?
04:29:02 <dons> sure. but it can only print a constant, no? i.e. '<function>'
04:29:26 <musasabi> < a -> a >
04:29:27 <dons> i need the Typeable constraints to get a fun type printed, instead of a boring constant string
04:29:35 <musasabi> then again we lose type class constraints.
04:29:50 <musasabi> dons: how about using TH to reify the code and prettyprint the Type ?
04:30:17 <dons> yeah, tried that. couldn't manage to get the right Lift colass constraints on the a -> b type.
04:30:25 <dons> the current code is here: http://www.cse.unsw.edu.au/~dons/code/lambdabot/scripts/ShowQ.hs
04:30:32 <dons> for printing fancy values in @eval.
04:30:38 <musasabi> dons: but you need Lift.
04:30:45 <dons> if you can think of some more values that would be useful to print.
04:30:47 <musasabi> dons: just define it as a named value and pass the Name.
04:32:13 <musasabi> dons: "expr = <whatever the user typed + eta expansion?>; fshow = $(inferTypePrettyPrint ''expr)"
04:34:15 <dons> hmm. right!
04:34:26 <dons> that's a cool idea.
04:34:38 <dons> just grab the type from the type checker, right?
04:34:45 <dons> and splcie it back in as a custom String
04:36:05 <musasabi> yes
05:37:03 <xerox> Hey, you students!  <http://www.haskell.org//pipermail/haskell/2006-April/017891.html>
05:39:03 <olliej> xerox: already doing a haskell/ghc project :p
05:39:33 <xerox> olliej: cool, what exactly, if I may ask?
05:39:46 <olliej> xerox: compiling to .NET
05:39:51 <xerox> Ah-ha!
05:40:06 <xerox> Nice one, I think.
05:40:10 <olliej> xerox: almost got higher ranks going now
05:40:21 <xerox> Impressive.
05:40:22 <olliej> all completely statically checked,
05:40:30 <olliej> :)
05:44:54 * araujo happy to see some of his ideas in the SoC page
05:45:17 <xerox> araujo: cool.  Are you going to partecipate?
05:46:19 <araujo> xerox, yes!
05:46:20 <araujo> :-)
05:46:26 <xerox> araujo: as a student or a mentor?
05:46:37 <araujo> as a student 
05:46:54 <xerox> Great!  Do you have own proposals or you think you'll be applying for Haskell.org ones?
05:47:17 <araujo> xerox, the proposals i have are already listed on Haskell.org haha
05:47:25 <xerox> Nice.
05:47:36 <araujo> So i suppose i just could extend them a bit or so
05:55:34 <dons> yeah, araujo that'd be great if you apply
05:55:49 <dons> we could get some more code out of you :)
05:55:54 <araujo> dons dons !
05:55:56 <araujo> haha
05:56:02 <araujo> my pleasure ;-)
05:56:06 <xerox> dons: everyone tells me they didn't see the mail, argh.  Students don't seem to use the mailing list :-(
05:56:42 <dons> maybe make it clear, with a subjt "Google Summer of Code", sent to haskell@haskell.org, glasgow-haskell-users@ as well
05:56:50 <araujo> Good ideas.
05:57:12 <dons> it's ok to have 3 'call for papers' mails :)
05:57:24 <xerox> Okay, I want to hear if Isaac went throught the process today.
05:57:30 <dons> yep.
05:57:50 <dons> do we have a page sumwhere summarsing the mentors and admins? and the timeline?
05:57:58 <xerox> Nope, would you.... ?
05:58:18 <dons> just add those details to the top of the wiki page, so people who read the wiki know who to contact.
05:58:28 <dons> might catch some people who don't read the mailing list, perhaps
05:58:37 <xerox> Okay, I'll do it.
05:59:03 <xerox> I was also thinking about contacting projects' leaders in order to get them mentoring students working on their code
05:59:23 <mathrick> anyone knows how is ++ called in LaTeX?
05:59:43 <xerox> You know, like duncan, which being here is usually up-to-date with the events, but for many others I have to reach them via mails
05:59:57 <xerox> Still, I need a list of projects... ideaS?
06:00:17 <dons> yes. it's a good idea. contact the authors of the large haskell projects and ask them if they want to mentor people
06:00:40 <dons> i.e. _darcs_
06:00:49 <xerox> That's one.  Right.
06:00:51 <dons> we need to get someone to work on darcs for money.
06:01:07 <xerox> (I have asked pugs people, but they seem to be wanting applying on their own, falling back on us if they can't)
06:01:24 <dons> I'd like to see the ghc people put up workign on ghc ideas...
06:01:33 <dons> just taken straight from the ghc todo list
06:02:04 <musasabi> Getting a JHC/YHC projects there would be nice too.
06:02:09 <xerox> Right!!
06:02:30 <xerox> May you /MSG me the name/emails of the people involved in them?
06:02:35 * xerox brb
06:03:50 <dons> also, I think we need to make clear on the wiki page who students need to contact and what the process is.
06:04:05 <dons> most the details are in the original mail, but it should appear on the wiki too
06:05:26 <amiddelk> mathrick: try \plus, that's how lhs2tex translates ++     (%format ++         = "\plus ")
06:05:54 <mathrick> amiddelk: ok, lemme try
06:05:57 <dons> hmm. we should have a haskell edsl to latex as one of the projects...
06:06:48 <shapr> Is there an EDSL tutorial somewhere?
06:06:53 <mathrick> amiddelk: any idea what package that comes from?
06:06:55 <amiddelk> mathrick: if you are formatting haskell code to LaTeX, I would recommend using lhs2TeX so that you don't have to bother with it yourself
06:07:04 <mathrick> amiddelk: I'm using listing
06:07:12 <mathrick> can the two be integrated?
06:07:22 <dons> shapr, only the papers, I think
06:07:41 <dons> I created a 'EDSL' category. now where is it...
06:07:47 <mathrick> amiddelk: on a second thought, it's a report with snippets, not really literate haskell
06:07:51 <dons> ?wiki Research_papers/Domain_specific_languages
06:07:52 <lambdabot> http://www.haskell.org/haskellwiki/Research_papers/Domain_specific_languages
06:08:07 <amiddelk> mathrick: I don't know, but lhs2tex generates latex, and can deal with incorrect/partial haskell
06:10:23 <amiddelk> mathrick: \plus is defined my lhs2tex itself: \newcommand{\plus}{\mathbin{+\!\!\!+}}
06:10:52 <mathrick> aha
06:11:13 <amiddelk> basically as two ++ with negative space between
06:11:34 <amiddelk> basically as two plusses with some negative space in between *
06:12:33 * araujo off to eat , brb
06:17:58 <nomeata> dcoutts: hi. Might this signature be wrong: entryCompletionSetMatchFunc :: EntryCompletion -> (String -> TreeIter -> IO ()) -> IO ()
06:18:07 <nomeata> I'd expect entryCompletionSetMatchFunc :: EntryCompletion -> (String -> TreeIter -> IO (Bool)) -> IO ()
06:24:38 <bolrod> dons: reading through the fpstring.c   why does it copy the whole string when reversing?
06:27:33 <Saulzar> Sounds reasonable if it is an immutable string?
06:27:53 <bolrod> it is?.. in C everything can be changed right?
06:28:14 <bolrod> I just read it though.. I really have no idea how the rest works ;)
06:28:31 <shapr> w00, #haskell - Registered: 4 years 51 weeks 6 days (15h 4m 56s) ago
06:28:32 <bolrod> but if so...     you can reverse an array in the place it takes up
06:28:34 <shapr> Nearly five years!
06:28:35 <Saulzar> But if the underlying structure is a packed array and you modify it in C then you'll change it in Haskell
06:28:38 <dons> bolrod: purely functional strings! you can't mutate an old string
06:28:48 <dons> exactly as Saulzar says
06:28:48 <shapr> Google calendar roxx
06:29:03 <bolrod> hrm
06:29:17 <dons> let s = reverse t in t -- has to work, right?
06:29:28 <dons> t has to be around even after we reversed it into 's'
06:29:46 <bolrod> true
06:29:53 <dons> we could add unsafeReverse if someone really wanted it. or more likely, you can write it yourself using 'generate'
06:31:04 <dons> the first lesson of haskell variables is .. they don't vary :)
06:31:04 <bolrod> well.. I guess you could represent strings as pointers to pointers.. but that would probably kill some efficiency as well
06:31:19 <dons> isn't that a [Char] ?
06:31:37 <bolrod> damn! I just started reading ;p
06:32:25 <dons> btw, I wrote a little tutorial on using ByteString/fps
06:32:26 <dons> ?wiki Wc
06:32:28 <lambdabot> http://www.haskell.org/haskellwiki/Wc
06:32:38 <RyanT5000> is -cpp known not to work on windows?
06:32:44 <bolrod> lets see
06:32:56 <RyanT5000> i've been struggling with it for about 5 hours, with different ghc installs
06:33:13 <RyanT5000> every time, i get "This application has requested the Runtime to terminate it in an unusual way. 
06:33:13 <shapr> RyanT5000: Have you tried using -pgmF (Or -pgm + some letter) to specify the location of cc?
06:33:13 <RyanT5000> Please contact the application's support team for more information."
06:33:39 <shapr> I forget which letter is the c compiler.
06:33:40 <RyanT5000> well that's the thing: it seems to be running the right thing
06:33:50 <shapr> strace it?
06:33:52 <RyanT5000> well -pgmP is the C preprocessor
06:33:55 <RyanT5000> strace?
06:34:07 <shapr> er, whatever the windows equivalent is...
06:34:14 <RyanT5000> lol
06:34:27 <RyanT5000> i'm not saying i'd definitely know about it if windows had one
06:34:31 <RyanT5000> but i've never heard of it
06:34:46 <RyanT5000> hey whaddaya know
06:34:53 <RyanT5000> someone wrote something just like it
06:35:38 <RyanT5000> btw, isn't it kind of a bug that GHC totally blows up when the c compiler doesn't work?
06:36:14 <dons> you'd have the gnu cpp installed, surely. if you have gcc.
06:36:37 <RyanT5000> well right now i'm using the gcc that comes with ghc
06:36:53 <RyanT5000> (under the possibly-mistaken assumption that that would work the best)
06:40:08 <SamB> I thought you needed hscpp
06:41:10 <RyanT5000> i hope that's it :)
06:41:29 <alec> dons: thanks for the link, that was a good article
06:41:57 <dons> alex, cheers.
06:42:27 * SamB thinks GHC should just pretend it didn't find a .hi file if it finds one that doesn't make sense
06:42:38 <RyanT5000> @where hscpp
06:42:39 <lambdabot> I know nothing about hscpp.
06:42:41 <dons> doesn't it panic, SamB?
06:42:50 <dons> s/panic/error "evil .hi file"
06:43:09 <SamB> why?
06:43:24 <dons> depends on what you mean by 'doesn't make sense' I guess..
06:43:51 <dons> i'm sure it panics for some 'make sense' that 'doesn't'
06:44:51 <SamB> I mean, when building fptools/libraries, it isn't nice to have it complain about all the .hi files that the name in the file, GHCziBase, isn't the name we were looking for, GHC.Base
06:45:19 <SamB> just because there are old .hi files from an earlier GHC build
06:45:39 <dons> hmm. one strictness annotation, and then a rewrite of a library function, and my little benchmark goes from 0.7s to 0.013s
06:48:04 <bolrod> seems like reasonable improvement
06:50:19 <dons> > printf "%0.2f %%\n" (100 * 0.013 / 0.7 :: Double)
06:50:20 <lambdabot> Add a type signature
06:50:37 <dons> > printf "%0.2f %%\n" (100 * 0.013 / 0.7 :: Double) :: String
06:50:39 <lambdabot> "1.86 %\n"
06:50:43 <dons> that'll do
06:50:53 <xerox> Wow.
06:51:07 <mauke> @type printf
06:51:08 <lambdabot> forall r. (PrintfType r) => String -> r
06:51:11 <xerox> :-D
06:51:20 <mauke> impressive, star fox
06:51:26 <xerox> 100% agreed
06:51:39 <dons> the old code (which is in darcs ...) was massively inefficient
06:52:42 <dons> hmm. its even used in a number of places
07:01:08 <Igloo> dons: What code, OOI?
07:07:00 <mauke> > printf "%n" "where is your god now?"
07:07:01 <lambdabot> Add a type signature
07:07:05 <mauke> > printf "%n" "where is your god now?" :: String
07:07:06 <lambdabot> Exception: Printf.printf: bad formatting char n
07:08:10 * araujo back
07:10:38 <mauke> hmm, precision is broken
07:10:52 <mauke> > printf "%.3s" "foobar" :: String
07:10:53 <lambdabot> "foobar"
07:12:50 <olliej> @type printf
07:12:52 <lambdabot> forall r. (PrintfType r) => String -> r
07:13:53 <shapr> fwfewfwa: Learning Haskell?
07:14:19 <shapr> Random nicks trip my spammer filter...
07:17:55 <araujo> hah
07:17:58 <araujo> hola shapr 
07:18:08 <xerox> Okay.  Refactoring:
07:18:14 <xerox> http://haskell.org/haskellwiki/Summer_of_Code:_People
07:18:17 <xerox> http://haskell.org/haskellwiki/Summer_of_Code:_Project_suggestions
07:18:26 <xerox> Feedback is welcome, (proof read too :-).
07:19:28 * araujo re-checks
07:21:40 <__phas> Hi, i need some help using c2hs
07:22:17 <__phas> I made a test .c and .h file
07:22:37 <__phas> then i tryied to import a enum type with
07:22:58 <__phas> {#enum blah#}
07:23:20 <__phas> then if i do c2hs File.chs i get
07:23:30 <__phas> Sum.chs:5: (column 8) [ERROR]
07:23:30 <__phas>   >>> Unknown identifier!
07:23:30 <__phas>   Cannot find a definition for `NTHREE' in the header file.
07:23:44 <__phas> i thought i need to specify the proper .h file, so i tried
07:23:58 <__phas> c2hs file.h File.chs
07:24:02 <__phas> but i get
07:25:09 <__phas>  c2hs sum.c Sum.chs
07:25:09 <__phas> There must be exactly one binding file (suffix .chs), possibly
07:25:09 <__phas> preceded by one header file (suffix .h).
07:26:33 <__phas> oh, lol, wrong copying :P
07:26:40 <__phas> phas@zulu:~/c2hstest$ c2hs sum.h sum.chs
07:26:40 <__phas> In file included from sum.h:1,
07:26:50 <__phas> ...
07:26:57 <__phas>                  from sum.h:1:
07:26:57 <__phas> sum.h:1:17: error: #include nested too deeply
07:26:57 <__phas> c2hs: Error during preprocessing custom header file
07:27:09 <__phas> and it blaks sum.h
07:35:06 <pierre--> hello
07:36:31 <shapr> __phas: pastes over three lines are more politely put on a paste site.
07:36:51 <__phas> ok, sorry
07:37:18 <shapr> No worries if you don't know.
07:41:01 <shapr> @timein Portland
07:46:56 <lispy> shapr: 7:40
07:47:47 <lispy> my lcd won't stay on :(
07:48:12 <lispy> and this is a laptop
07:49:32 <lispy> hmm...that may have fixed it...
08:00:00 * mux hearts haskell
08:00:04 <mux> -- The infinite list of the terms of the Riemann zeta function.
08:00:04 <mux> zeta :: (RealFloat a, Enum a) => Complex a -> [Complex a]
08:00:04 <mux> zeta s = [ 1 / ((n :+ 0) ** s) | n <- [1..] ]
08:00:28 <neologism> hi mux
08:00:32 <mux> hello
08:01:13 <lispy> > let zeta s = [ 1 / ((n :+ 0) ** s) | n <- [1..] ] in take 5 (zeta 0)
08:01:14 <lambdabot> [1.0 :+ 0.0,1.0 :+ 0.0,1.0 :+ 0.0,1.0 :+ 0.0,1.0 :+ 0.0]
08:01:40 <mux> sum them 
08:01:44 <lispy> > let zeta s = [ 1 / ((n :+ 0) ** s) | n <- [1..] ] in take 5 (nub (zeta 0))
08:01:49 <lambdabot> Terminated
08:02:02 <xerox> nub ?!
08:02:10 <lispy> @type nub
08:02:11 <lambdabot> forall a. (Eq a) => [a] -> [a]
08:02:26 <lispy> > nub [1,3,1,4,1]
08:02:27 <lambdabot> [1,3,4]
08:02:34 <xerox> I mean, it doesn't work on infinite lists.
08:03:04 <lispy> i could have sworn i've nub'd infinite lists before...but maybe i'm on crack
08:03:40 <mauke> > let zeta s = [ 1 / ((n :+ 0) ** s) | n <- [1..] ] in take 1 (nub (zeta 0))
08:03:41 <lambdabot> [1.0 :+ 0.0]
08:03:59 <lispy> oh right
08:04:09 <lispy> my take was too big
08:04:18 <lispy> > let zeta s = [ 1 / ((n :+ 0) ** s) | n <- [1..] ] in (nub (zeta 0))
08:04:22 <lambdabot> Terminated
08:04:36 <lispy> heh, take 1 is necessary and sufficient :)
08:04:36 <mux> > let zeta s = [ 1 / ((n :+ 0) ** s) | n <- [1..] ] in sum (take 100 (zeta 2))
08:04:38 <lambdabot> 1.6349839001848923 :+ 0.0
08:04:45 <mux> > let zeta s = [ 1 / ((n :+ 0) ** s) | n <- [1..] ] in sum (take 1000 (zeta 2))
08:04:46 <lambdabot> 1.6439345666815612 :+ 0.0
08:04:51 <mux> > let zeta s = [ 1 / ((n :+ 0) ** s) | n <- [1..] ] in sum (take 10000 (zeta 2))
08:04:52 <lambdabot> 1.644834071848065 :+ 0.0
08:05:23 <mux> > pi^2 / 6
08:05:24 <lambdabot> 1.6449340668482264
08:05:29 <lispy> > let zeta s = [ 1 / ((n :+ 0) ** s) | n <- [1..] ] in zeta (1 :+ -1)
08:05:30 <lambdabot>   precedence parsing error
08:05:30 <lambdabot>    cannot mix `(:+)' [infix 6] and prefix `-' [infixl 6] in the same infix expression
08:05:41 <lispy> > let zeta s = [ 1 / ((n :+ 0) ** s) | n <- [1..] ] in zeta (1 :- 1)
08:05:42 <lambdabot>  Not in scope: data constructor `:-'
08:05:59 <lispy> i guess you do 1 :+ (-1) ?
08:06:04 <lispy> > 1 :+ (-1)
08:06:05 <mux> yes
08:06:06 <lambdabot> 1.0 :+ (-1.0)
08:06:30 <lispy> @type (-)
08:06:32 <lambdabot> forall a. (Num a) => a -> a -> a
08:08:57 * lispy watches the global IORef debate heat up
08:14:04 <shapr> tromp: Ever read Doerfler's Dead Reckoning? Any suggestions along the same lines?
08:15:33 <Lemmih> Anyone know what version of HOpenGL is shipped with ndm's WinHugs?
08:19:54 <dcoutts_> nomeata, that sounds plausable, email the gtk2hs-dev list so we don't forget. If you send us a patch too that'd be even better! :-)
08:21:11 <tromp> don't think i have, shapr
08:25:54 <hyrax42> how are lists implemented in Haskell (or a specific implementation thereof, if they differ)?
08:26:42 <hyrax42> I have read that you get O(log n) access to elements, though I may have been dreaming
08:27:26 <mauke> it's O(n)
08:27:33 <hyrax42> hm
08:27:35 <hyrax42> ok
08:29:08 <hyrax42> I was wondierng if vlists or something like were used
08:29:13 <hyrax42> but I suppose not
08:29:15 <dcoutts_> nope
08:29:29 <dcoutts_> use an array if you need fast indexing but not updates
08:30:05 <pesco> I want vlists.
08:39:08 <toste> hey
08:39:26 <toste> if i have a [Int] but there is just one innit
08:39:32 <toste> how can i get a Int
08:39:39 <xerox> head
08:39:43 <toste> true, thx
08:39:51 <xerox> You're welcome.
08:39:58 <mauke> or pattern matching
08:40:11 <dcoutts_> > case [3] of [x] -> x
08:40:13 <lambdabot> 3
08:40:21 <dcoutts_> > case [3,4] of [x] -> x
08:40:22 <lambdabot>  Non-exhaustive patterns in case
08:40:39 <bringert> or !!
08:40:43 <bringert> [3]!!0
08:40:47 <bringert> > [3]!!0
08:40:48 <lambdabot> 3
08:41:12 <mauke> > let [x] = [3] in x
08:41:14 <lambdabot> 3
08:41:26 <xerox> > case "yay duncan helpful" of [x:_:_]-> x
08:41:28 <lambdabot> Couldn't match `Char' against `[a]'
08:41:38 <bringert> or pattern matching in a lambda expression:
08:41:38 <dcoutts_> hah
08:41:40 <bringert> >  (\[x] -> x) [3]
08:41:42 <lambdabot> 3
08:41:43 <xerox> ops :-D
08:41:46 <hyrax42> haha
08:42:08 <dcoutts_> > case "syntax error" of (x:_:_) -> x
08:42:10 <lambdabot> 's'
08:42:27 <xerox> Ah-ha!
08:42:39 <bringert> case ["just a string"] of [x:_:_]-> x
08:42:42 <bringert> > case ["just a string"] of [x:_:_]-> x
08:42:44 <lambdabot> 'j'
08:42:59 <xerox> bringert!
08:43:01 <hyrax42> why the double :_?
08:43:09 <bringert> no reason really
08:43:20 <xerox> bringert: you do run some large haskell project right?
08:43:26 <bringert> just to fail if the string has less than two characters
08:43:27 <hyrax42> does it require a list of 2+ elts to do that?
08:43:31 <hyrax42> ok
08:43:55 <bringert> xerox: mid-size maybe, why?
08:44:11 <bringert> ah, let me guess, SoC?
08:44:17 <xerox> bringert: did you see the Google Summer of Code emails on the Haskell mailing list?
08:44:21 <bringert> yeah
08:44:21 <xerox> Yes, right!
08:44:33 <xerox> http://haskell.org/haskellwiki/Summer_of_Code:_People
08:44:34 <xerox> http://haskell.org/haskellwiki/Summer_of_Code:_Project_suggestions
08:44:45 <bringert> I haven't thought of any good projects yet
08:44:47 <xerox> We'd love if you would come in for mentoring
08:45:01 <bringert> though I guess I haven't thought very hard
08:45:08 <xerox> SyntaxNinja is going to apply today, I want to get people in
08:45:23 <dcoutts> xerox, there should be some Cabal ones, or hackage
08:45:24 <bringert> ok, I can put my name on the mentors list
08:45:41 <bringert> but I don't have any concrete projects atm
08:45:45 <xerox> dcoutts: uh, where?
08:46:01 <xerox> bringert: it's okay, other mentors proposed too many project to do them all :-)
08:46:39 <bringert> whoa, that list has a lot more stuff on it today
08:46:40 <dcoutts> xerox, no, I'm just saying I think there are probably some really useful projects we can think of involving improving Cabal/cabal-get/hackage
08:46:57 <xerox> dcoutts: oh yes, that's surely right.
08:47:19 <xerox> dcoutts: there was a guy proposing to add distributed compilation to Cabal
08:47:29 <dcoutts> fun
08:47:59 <xerox> If he's got a mentor I could add that project okay.
08:48:19 <bringert> should I add projects that I come up with, or is the list too long already?
08:48:36 <xerox> bringert: please add yours!
08:48:36 <dcoutts> xerox, I think we should record potential project ideas even if they don't have mentors yet
08:48:45 <dcoutts> then mentors could sign up to interesting projects
08:48:47 <xerox> dcoutts: okay, let me write it up.
08:48:55 <bringert> I guess people can use SoC projects as masters theses projects, right?
08:49:10 <xerox> Yes, as long as they do have an advisor, Chris said.
08:49:20 <toste> @where paste
08:49:21 <lambdabot> http://paste.lisp.org/new/haskell
08:49:39 <hyrax42> would it be inappropriate for an enthusiastic haskell newbie to apply for an soc project?
08:50:04 <lisppaste2> toste pasted "code" at http://paste.lisp.org/display/19321
08:50:16 <toste> Syntax error in expression (unexpected keyword "where")    
08:50:33 <xerox> hyrax42: as long as they meet the Google acceptance rules they're very much welcome :-D
08:50:49 <hyrax42> hom hoom
08:50:55 <hyrax42> I shall investigate in that case :)
08:50:59 * toste yawn
08:51:20 <toste> investigate what ;)
08:51:50 <toste> ahh
08:53:56 <wchogg> So I assume that all the required paperwork is being filed today for haskell.org to be a mentoring group?
08:55:31 <toste> nyone can look at my paste ? :p
08:56:19 <neologism> haskell is white space sensitive
08:56:35 <hyrax42> I'm looking but can't work out the problem
08:56:46 <hyrax42> other than guessing it's to do with layout as neologism just said
08:57:45 <pierre-> i'm only 15, is there a way for me to participate in SoC?
08:58:05 <toste> lol why don't you go to a summer camp instead :p
08:58:33 <pierre-> toste: there's nothing interesting at summer camp :-) 
08:58:35 <hyrax42> I believe you must be enrolled in, accepted into, or expected to graduate from a post-secondary program this summer
08:58:52 <fons_> SoC?
08:58:57 <hyrax42> or: you're out of luck :(
09:00:18 <toste> what is SoC ?
09:00:29 <hyrax42> Google Summer of Code
09:00:34 <toste> am currently snd year CS student
09:00:39 <toste> can i participate ;p
09:00:52 <hyrax42> encourage ($) students to participate in open source projects
09:01:03 * mux has a google SoC t-shirt
09:01:08 <hyrax42> which uni, toste?
09:01:13 <toste> montreal
09:01:15 <hyrax42> udem?
09:01:19 <toste> yer
09:01:24 <toste> udm
09:01:24 <hyrax42> cool
09:01:34 <xerox> wchogg: yes.
09:01:38 <hyrax42> <-- mcgill
09:01:52 <toste> cool, CS or Engeneering ?
09:01:59 <hyrax42> neither :o
09:02:04 <hyrax42> applied maths, physics
09:02:06 <toste> :p
09:03:18 <hyrax42> but my final year
09:03:39 <wchogg> xerox:  cool.  Nice job on getting alot of this stuff organized on such short notice.
09:03:52 <bringert> pierre-: but you are still welcome to pick up a haskell project to work on over summer. I'm sure that someone can help you if you work on their project
09:04:06 <xerox> wchogg: thank you very much.
09:04:07 <bringert> pierre-: just no $$$
09:04:11 <hyrax42> heh
09:04:50 <wchogg> I'm just amazed at how many projects have been added to the wiki in just the past 24 hours.
09:05:14 <xerox> hyrax42: you don't have to be that enrolled, accepted, expected.
09:05:36 <toste> [Achat "COMS" 2300 19.81] ++ read(Achat ++ " " ++ "ADBE" ++ " " ++ 500 ++ " " ++ 19.55) 
09:05:43 <toste> that doesnt work actually
09:05:49 <xerox> toste: http://code.google.com/summerofcode.html
09:06:11 <xerox> (You just have to be 18 by March 8, IIRC)
09:06:20 <toste> thx
09:06:23 <pierre-> bringert: thanks. I would be happy to participate in haskell project even without being paid.
09:06:28 <hyrax42> xerox: ?
09:06:40 <xerox> hyrax42: high school students are okay as well, for example
09:06:54 <hyrax42> oh ok
09:07:06 <hyrax42> yeah jsut saw the "not necessarily limited to..." clause
09:08:13 <toste> applyance aren't online yet, right ?
09:08:25 <hyrax42> may 1
09:08:31 <hyrax42> deadline may 8
09:08:44 <hyrax42> now is just scramble-time for the mentoring orgs
09:08:57 <toste> gotta right it somewhere, ill be drunk 24/7 atfer 27 april
09:09:07 <toste> write it*
09:09:29 <toste> :D
09:10:26 <xerox> haha.
09:10:49 <RyanT5000> could someone point me to some code that uses lemmih's SDL binding?
09:11:19 <lispy> well, if Lemmih is around i think he gave give you some example code
09:11:21 <bringert> toste: so, you are going to be writing your SoC application while drunk?
09:11:35 <lispy> i have some HOpenGL + GLUT code, but nothing with sdl in it
09:11:48 <RyanT5000> yeah, i've gotten glut "working"
09:11:53 <RyanT5000> in so much as glut ever works
09:11:57 <RyanT5000> :-/
09:12:01 * lispy nods
09:12:05 <toste> i did my acceptence uni test while behing extremely hangover
09:12:20 <toste> it shall be the same with google ;p
09:12:24 <RyanT5000> @where hssdl
09:12:26 <lambdabot> http://darcs.haskell.org/~lemmih/hsSDL
09:12:36 <lispy> i did see a snippet of Lemmih's code once...i tihnk the main trick was to convert an SDL image layer (or buffer or whatever) to something that opengl can write on
09:12:48 <RyanT5000> hm
09:12:55 <RyanT5000> right now when i flip the buffers, it crashes
09:13:00 <RyanT5000> null pointer reference
09:13:05 <RyanT5000> which makes me think my init code is wrong
09:13:06 <lispy> hmm...sounds lie a bug ;)
09:13:17 <RyanT5000> but i'm pretty sure it's not a bug in the binding
09:13:22 <RyanT5000> or even sdl
09:13:27 <lispy> oh no, i meant in your code :)
09:13:30 <RyanT5000> yeah
09:13:53 <RyanT5000> but cross-debugging is less-than-easy for someone with little haskell experience to begin with
09:13:58 <lispy> have you compared your code with a mimimal example of sdl in another language?
09:14:26 <RyanT5000> actually that's what i'm doing now: converting my haskell, line for line, into C
09:14:38 <RyanT5000> i expect i should get a more reasonable understanding from that
09:15:48 <bringert> I'm giving a lecture about HaskellDB to a database course tomorrow, maybe I should mention the possibility of a SoC hacking on haskellDB
09:15:54 <lispy> it may or may not help but i started converting the nehe tuts to haskell once: http://projects.codersbase.com/repos/nehe-tuts (it's a darcs repo or you can look at stuff directly)
09:16:09 <lispy> bringert: yes you should mention it
09:18:04 <RyanT5000> that's awesome lispy; i went through most of the nehe tutorials when i was learning opengl
09:18:10 <dcoutts_> bringert, cool
09:19:06 <lispy> RyanT5000: i stopped at lesson12 but i accept patches if you want to translate more :)
09:20:08 <RyanT5000> i may, if i start going through them again (although that'll  probably be at #30 or something; i did a lot before)
09:20:18 <xerox> bringert: I think it is a good idea.
09:20:26 <toste> @where paste
09:20:27 <lambdabot> http://paste.lisp.org/new/haskell
09:21:35 <lisppaste2> xerox pasted "nah it's toste" at http://paste.lisp.org/display/19323
09:21:51 <Saulzar> RyanT5000, Which OS are you using?
09:21:55 <RyanT5000> windows :(
09:22:22 <RyanT5000> developing a windows game + have little linux experience + afraid of cross-development = use windows
09:22:34 <xerox> ?!?!?!?!
09:22:35 <lambdabot> Unknown command, try @list
09:22:45 * dcoutts_ agrees with xerox 
09:22:49 <toste> just use gc++
09:22:53 <toste> lol ;p
09:23:02 <xerox> toste: what did you mean?
09:23:11 * dcoutts_ has no idea
09:23:47 <Saulzar> RyanT5000, There was something about the SDL bindings being broken on MacOS/Windows...
09:23:58 <toste> am tired, been studying 20/7
09:24:13 <toste> lol
09:24:16 <xerox> Sleep, guy.
09:24:31 <RyanT5000> saulzar: yeah, but i'm pretty certain that's not what's happening here
09:24:36 <Saulzar> Ah ok.
09:24:42 <hyrax42> toste: almost same
09:24:52 <hyrax42> I'm just getting tired of it now... this is a 3 week exam period for me
09:25:25 <hyrax42> stupid deferred exam next monday, my first was 2 weeks ago
09:26:11 <bringert> anyone have any project ideas for HaskellDB?
09:27:13 <bringert> hmm, wouldn't it be cool to have a web browser written in haskell?
09:27:27 <bringert> this could be split up into several projects
09:27:38 <dcoutts_> I know someone was working on html+CSS rendering with cairo
09:27:44 <toste> well haskell isnt made for i/o
09:27:48 <xerox> dcoutts_: wow
09:27:48 <bringert> ah, nice
09:28:03 <dcoutts_> can't remember who it was now
09:28:37 <dcoutts_> the basics aren't that hard, but the more advanced CSS things make the layout algorithm quite complex
09:28:38 <bringert> other subprojects could include: javascript interpreter, ssl support, http client with concurrency
09:28:47 <bringert> DOM stuff
09:29:12 <dcoutts_> how about a GHC debugger?
09:29:20 <dcoutts_> that'd be an interesting project
09:29:35 <xerox> But one has to find code to debug then <grin>
09:29:40 <dcoutts_> something that allows you to stop ghc and wander through the heap
09:29:52 <dcoutts_> I mean, to stop a ghc-compiled prog
09:29:55 <xerox> Hmm.
09:30:00 <xerox> Yeah, the rts.
09:30:03 <dcoutts_> indeed
09:30:12 <bringert> or maybe a heap profiler whose output I can understand
09:30:14 <xerox> Cool, might want to add it on the page?
09:30:22 <bringert> maybe I haven't been trying hard enough
09:30:30 <xerox> bringert: doesn't it do .ps graphs too?
09:30:31 <dcoutts_> there's a simple Gtk+ front pannel but there could be much better things
09:30:48 <dcoutts_> especially if it were written in Haskell (with minimal C)
09:30:49 <bringert> xerox: sure, but I never understood the labels :-)
09:30:55 <xerox> dcoutts_: I mean if you could write a short description for it
09:31:03 <xerox> bringert: ach!
09:31:05 <dcoutts_> xerox, remind me of the page?
09:31:20 <xerox> http://haskell.org/haskellwiki/Summer_of_Code:_Project_suggestions
09:31:27 <dcoutts_> ta
09:31:36 <xerox> (:
09:32:15 <bringert> most of the current suggestions are haskell libraries, haskell development tools and the like
09:32:25 <wolverian> hm, that page says ion is extensible in Ion - it's actually extensible in Lua.
09:32:42 <xerox> bringert: yes much so
09:33:04 <bringert> is that how we want it, or should there be projects to write user applications in haskell too?
09:33:11 <dcoutts_> shapr, I see you might be mentor for Language.*
09:33:32 <dcoutts_> shapr, one sub-part of that might be to fix the last few wrinkles in the c2hs C parser
09:34:06 <dcoutts_> shapr, and make it more paramaterisable perhaps, eg GNU-C, C99, C89, K&R
09:34:21 <xerox> bringert: both forms are happily welcome--even other forms if you can think of them :-)
09:34:40 <xerox> ....provided that it makes FOSS.
09:35:15 <dcoutts_> shapr, the main problem in the c2hs C parser is in accurately handling some GNU-C __attribute__ and the big one is the C grammar has this nasty bit to do with typedefed names that we don't get quite right
09:35:40 <dcoutts_> shapr, I can explain that in more detail if you need it
09:37:57 <xerox> I wonder if students will not pick up projects because they're not "signed" by a Mentor.
09:38:21 <xerox> (But yes we need to keep track of it somehow)
09:44:26 <toste> @where paste
09:44:27 <lambdabot> http://paste.lisp.org/new/haskell
09:45:02 <lisppaste2> toste pasted "code" at http://paste.lisp.org/display/19324
09:46:55 <Saulzar> toste, Not enough arguments... you have given 4, a -> b -> c -> d -> e -> f has 5
09:47:20 <toste> yer i know, i don't see it tho
09:47:42 <Saulzar> head(filter((==symb).symbole) b)
09:47:45 <Saulzar> This is 2 arguments
09:48:07 <toste> thx
09:55:00 <toste> > error ("foo")
09:55:01 <lambdabot> Add a type signature
09:55:17 <toste> if (1==0) then 1 else error ("foo")
09:55:22 <toste> > if (1==0) then 1 else error ("foo")
09:55:24 <lambdabot> Exception: foo
10:00:35 <xerox> Okay, sent mails everywhere.
10:09:04 <dcoutts_> xerox, looks good
10:11:35 <xerox> dcoutts_: hoped so :D
10:12:16 <xerox> dcoutts_: can you think of other projects to inform of the event?
10:12:49 <dcoutts_> xerox, I already forwarded it to the gtk2hs-users list
10:13:05 <xerox> Good!
10:13:24 <xerox> I hope other people would do the same, I don't know all the projects!
10:14:40 <mnislaih__> wow there are a lot of interesting and fun projects in the SoC page
10:15:07 <mnislaih__> I'm having a damn hard time to pick one!
10:15:30 * xerox fills in with joy
10:15:39 <mahogny> well, we have the advantage of being flexible. we have barely even fixed the language to be used :)
10:15:50 <mnislaih__> lol
10:16:13 <mnislaih__> xerox that was a great idea, not only for SoC. Now every newbie who wants/needs to start a pet project
10:16:26 <mnislaih__> can now look at that page and do something useful instead
10:16:43 <xerox> Ah, good!
10:16:48 <mnislaih__> and with a mentor, wohoo
10:17:01 <xerox> They're there to make guidance.
10:19:46 <mnislaih__> the frag hacking project looks just too cool to pass up
10:20:06 <mnislaih__> but hide and yi are pulling me too ..
10:20:31 <mnislaih__> and the continuation stuff for HAppS
10:20:39 <mnislaih__> I think I've seen something like that in the Lisp world
10:20:51 <mnislaih__> continuations for web frameworks
10:21:14 <mnislaih__> to model stateful sessions, right?
10:22:15 <mnislaih__> peeking into the Clean world would be a lot of fun too.
10:22:18 <mnislaih__> "Clean does very well for low level string benchmarks. Find out what they do, and port it to"
10:22:23 <mnislaih__> I like that sentence hehe
10:22:56 <wchogg> The ones I think are the most interesting are the GhcPlugins project idea, hIDE hacking, and improving ghc's numerics performance.
10:23:14 <mnislaih__> the ghcplugins is definitely the killer project
10:23:23 <mnislaih__> I'm trying to figure out if it is really doable
10:24:07 <wchogg> I just think working with the ghc-api would be pretty neat.
10:24:22 <mnislaih__> I mean, doable by an average brain in 3 months, in my case
10:25:15 <mnislaih__> although it's problably one of those things that if you cannot do in 3 months, you wouldn't manage in 3 years either
10:27:08 <wchogg> Honestly, I think I'd like to work on one of these projects as a hobby even if I can't get SoC funding for it.
10:27:46 <mnislaih__> same for me, but I sure would be more committed if I got the funding =D
10:28:55 <wchogg> mnislaih__:  I almost think it would be more fun without the pressure...my wife and I could do an *awful lot* with that kindof money.
10:28:57 <palomer> SoC?
10:29:18 <wchogg> palomer:  Oh we're just talking about what projects look good in the summer of code.
10:30:38 <mnislaih__> in the end, it's up to Google. I think we won't have many chances
10:31:24 <pejo> mnis, I just got here, what doesn't have much chance in SoC? 
10:31:41 <palomer> google pays for SoCs?
10:31:48 <mnislaih__> they do indeed
10:31:55 <mnislaih__> but there will be a lot of people applying
10:31:58 <palomer> and do SoC projects have to be open sourced?
10:32:07 <mnislaih__> there won't be many slots for haskell.org if there is any at all
10:32:09 <mahogny> palomer, yes
10:32:10 <wchogg> mnislaih__:  Yeah, to be realistic since there's probably only going to be 4-500 funded projects so it's not like all of us are going to get one.  I do think that if one of the haskell group gets it we should help them as much as possible.
10:32:33 <mahogny> ugh
10:32:50 <wchogg> mahogny:  Ugh?
10:32:53 <mahogny> I don't know if you have, but we have the saying "the more chefs the worse the soup"
10:32:53 <palomer> ugh!
10:33:04 <mnislaih__> and that's supposing Haskell.org will show up at all as a SoC Mentor
10:33:04 <mahogny> ie if too many of us get involved, I doubt it will end up right
10:33:13 <pejo> mnis, well. Google has lots of sharp brains. Wadler has a link on his blog to some paper from Google about functional programming in real life. I dont' think they discriminate based on language.
10:33:32 <wchogg> mahogny:  I meant in terms of answering questions and things like that, not *working* on it.
10:33:43 <mnislaih__> pejo: I'm not saying that. It's just that deadlines are tight and the one for mentor orgs. is today
10:33:52 <mahogny> wchogg, same there. if everyone decides their solution is the best one... omg :)
10:34:07 <mnislaih__> 'unoficially' it's today. un-unoficially it was Saturday or Friday
10:34:13 <wchogg> mahogny:  Le tme be naive, dammit. :-P
10:34:20 <mahogny> wchogg, sorry :(
10:34:30 <wchogg> I treasure my ignorance!
10:34:37 <mahogny> lol
10:34:52 * palomer thinks we should submit yi as a SoC project
10:35:17 <wchogg> In all seriousness, I do see your point.  I would just hope that people would be reserved enough to not let that happen.
10:35:39 <mahogny> I hope the mentor is strong enough to take that kind of thing
10:35:51 <wchogg> ...although there was an hour long argument yesterday about the usage of O notation.
10:37:51 <sethk> wchogg, that wasn't an argument, just a technical discussion
10:39:05 <davidhouse_> xerox, great job on the SoC organisation so far. i hope we see a load of productive haskell code from this.
10:39:11 * davidhouse_ just wishes he was old enough to enter
10:39:20 * xerox hugs davidhouse_ 
10:39:38 <xerox> davidhouse_: wow, how old are you?
10:39:52 <davidhouse_> xerox, 17 at the moment. next year... :)
10:39:57 <xerox> Yay, go you!
10:40:11 <wchogg> Who's the youngest regular here?
10:40:46 <xerox> davidhouse_: how comes you got into Haskell early?
10:40:49 <davidhouse_> although i've earmarked next year as my year-to-learn-C++, so i might try to get involved in a C++ SoC project. we'll see.
10:41:03 <neologism> anyone speaking italian here?
10:41:08 * xerox alza la mano
10:41:12 <mahogny> davidhouse_, what do you need C++ for? :o
10:41:20 <wchogg> wow...learning haskell before c++?  That'll be weird.
10:41:22 * araujo looks around
10:41:28 <xerox> neologism: io!
10:41:30 <araujo> The HDB hacking looks nice
10:41:39 <davidhouse_> mahogny: marketability. so people will hire me.
10:41:49 <mahogny> davidhouse_, bah. go academics ;)
10:41:52 <mnislaih__> well then learn Java
10:42:02 <mahogny> davidhouse_, or start up your own and beat the crap out of them with haskell =)
10:42:36 <davidhouse_> xerox, maths is one of my hobbies, so one day i was hanging out in #math and Cale introduced me. seeing as the only thing i had written previously was PHP (which i was beginning to detest), i fell in love.
10:42:49 <mahogny> php :(
10:42:53 <xerox> davidhouse_: he got me with scheme2haskell too :-D
10:43:06 <davidhouse_> i hadn't seen functional programming before. i was amazed that i could write funky programs like prime sieves in ONE LINE :)
10:43:22 <pejo> davidhouse, not to disappoint you but math doesn't exactly give you a lot of marketability, outside of academia. Unfortunately. :-)
10:44:04 <mahogny> actually, math is one of the better subjects. it's extremely flexible in terms of where you can work. you just have to learn where the spots are
10:44:10 <wchogg> Heh...I've always been kindof suspicious of that Paul Graham espoused notion that you should just start up your own business and beat the existing ones.  He seems like Miss America saying that anything is possible if you follow your dreams, but what about the 49 girls who followed their dreams and lost?
10:44:24 <xerox> davidhouse_: don't listen to pejo ;-)
10:44:26 <davidhouse_> pejo, actually, maths grads are amongst the most employable, statistically.
10:44:56 <davidhouse_> as Kit in efnet's #math. he recently got a job programming financial systems in Java after a maths degree.
10:45:03 <mahogny> wchogg, you should be. unless you have a winning factor, you might as well forget about it
10:45:06 <pejo> davidhouse, pure math?
10:45:12 <davidhouse_> the reasoning is that it's easier to take a smart guy and make him a smart programmer than it is to make a guy that can program smart.
10:45:24 <davidhouse_> pejo, i believe so. he's a dab hand at analysis, so i would guess so :)
10:45:31 <mahogny> good reasoning
10:45:39 <pejo> mahogny, I know that employers shoudl want math grads, but a lot of weird decisions are made when they hire people. 
10:45:53 <wchogg> Alot of people in physics get jobs on wall street doing financial analysis, making twice as much as if they'd stayed in academics.
10:46:01 <mahogny> pejo, it's all about contacts really. not grades
10:46:07 <davidhouse_> my reasoning is that a smart guy who can program is the best of the bunch :)
10:46:11 <pejo> davidhouse, sure, a smart guy can do pretty much anything. But unless one has a job it's hard to prove that one can do anything. :-)
10:46:18 <pejo> mahogny, heh, amen. 
10:46:43 <philv> Hey, a bit off topic, but does anyone know of any good lambda calculus textbooks, preferably for someone with an engineering background but no experience with lambda calculus?
10:47:02 <work_metaperl> philv: BJ Maclennan: Functional Programming: practice and theory
10:47:21 <work_metaperl> anyway, I have a monad question I would appreciate some help with: http://rafb.net/paste/results/R1jfTX41.html
10:47:28 <philv> work_metaperl: thanks, I'll check it out
10:47:34 <work_metaperl> sure
10:47:38 <araujo> I think the main difference is that some guys love what they do, others just do what they are supposed to do to fit into the society without any real interest on that.
10:47:45 <Saulzar> Heh, if you can do math you can do anything. Everyone else wishes they did more math.
10:48:08 * fons_ wowowowoowow it works! (I had to tell someone ;))
10:48:22 <araujo> The sucess is to find those who are in love.
10:48:29 <araujo> Like a poet :-)
10:48:35 <mahogny> Saulzar, I dunno if I agree, but it's certainly a good start
10:48:38 <Igloo> Edd: Was that a professional runner (if such a thing exists)?
10:48:40 <Igloo> Doh
10:48:42 <davidhouse_> fons_: congrats :) what did you make?
10:48:51 <xerox> fons_: what works?
10:49:01 <pejo> Saulzar, sure. I think I'd have a problem convincing an employer that they should give me more math education, if I was in the industry.
10:49:02 <thebug> howdy howdy, long time everybody :)
10:49:10 <dcoutts_> work_metaperl, there's no type error if you associate the right way
10:49:16 <work_metaperl> thebug: hi
10:49:23 <work_metaperl> dcoutts: I dont understand what you mean
10:49:30 <fons_> davidhouse_, I ported chapter 8 of Norgivs book (Paradigms of Artificial Intelligence Programming ...) to Haskell
10:49:34 <dcoutts_> (Just s) `comb` mother :: Maybe a
10:49:38 <xerox> pejo: you should teach your employer, a-la Hamming.
10:49:50 <dcoutts_> ((Just s) `comb` mother) `comb` father :: Maybe a
10:50:02 <mahogny> fons_, are you making that stuff available?
10:50:16 <fons_> davidhouse_, I now have an Integrator and differentiatior and simplifier of symbolic expressions in haskell
10:50:18 <work_metaperl> dcoutts_: but the type signature of comb says Maybe b for the return value
10:50:26 <dcoutts_> work_metaperl, perhaps you were doing: (Just s) `comb` (mother `comb` father)
10:50:32 <dcoutts_> work_metaperl, yes
10:50:37 <xerox> I got into Hamming's again yesterday so I'm fresh on it <http://www.cs.virginia.edu/~robins/YouAndYourResearch.html>
10:50:41 <fons_> mahogny, I don't know if it's going to be interesting for anyone asppart from me
10:50:47 * araujo kind of interested in one of the dcoutts_ mentoring task
10:50:56 <dcoutts_> araujo, cool :-)
10:50:56 <mahogny> fons_, ok
10:50:58 <work_metaperl> oh I should look at the type signature for mother
10:51:04 <mahogny> fons_, are you into AI?
10:51:05 <fons_> mahogny, but yes, I wouldn't have a problem in making it aviable
10:51:07 <work_metaperl> it is probably a -> Maybe a
10:51:13 <xerox> fons_: put the code in a darcs repo and push it on!
10:51:14 <work_metaperl> not a -> Maybe b
10:51:17 <fons_> mahogny, not reallyl
10:51:30 <dcoutts_> @type (>>=)
10:51:31 <lambdabot> forall (m :: * -> *) b a.
10:51:31 <lambdabot>    (Monad m) =>
10:51:31 <lambdabot>    m a -> (a -> m b) -> m b
10:51:32 <mahogny> btw, anyone know a good AI channel?
10:51:32 <fons_> (damm swedish keyboard)
10:51:45 <fons_> xerox, darcs?
10:51:46 <work_metaperl> yes, I see that
10:51:52 <davidhouse_> dcoutts_, shh :
10:51:54 <dcoutts_> work_metaperl, what you've got in comb is a special case of (>>=) 
10:52:17 <xerox> fons_: sure!  It is an Haskell program to keep track of sources history.
10:52:27 <xerox> fons_: http://abridgegame.org/darcs/
10:52:28 <davidhouse_> dcoutts_, he's following YAHT. he'll come on to that.
10:52:35 <dcoutts_> davidhouse_, ok sorry :-)
10:52:35 <work_metaperl> ok... oh so the transform of the containered value nto a different type is not necessary
10:52:47 <work_metaperl> davidhouse_: who is? not me
10:52:58 <xerox> fons_: it's cool because it's simple to use and you have to do very little to get the repository of sources done.
10:53:00 <davidhouse_> work_metaperl: err, all about monads.
10:53:00 <dcoutts_> work_metaperl, your existing type for comb is correct
10:53:06 <dcoutts_> comb :: Maybe a -> (a -> Maybe b) -> Maybe b
10:53:30 <dcoutts_> work_metaperl, including the 'a' & 'b' bits 
10:53:39 <work_metaperl> yes ... the bottom line is the more accurate type signature for what is happening here is Maybe a -> (a -> Maybe a) -> Maybe a
10:53:50 <dcoutts_> no
10:53:55 <dcoutts_> it was already correct
10:53:56 <fons_> xerox, I first need te create a parser
10:53:57 <dcoutts_> comb :: Maybe a -> (a -> Maybe b) -> Maybe b
10:54:13 <work_metaperl> but doesnt that mean something like a=Int b=Float
10:54:13 <fons_> xerox, I was testing it using my internal representation
10:54:18 <work_metaperl> different types.
10:54:23 <toste> > [1,2] : [1,2]
10:54:24 <lambdabot>  add an instance declaration for (Num [a])
10:54:24 <lambdabot>   In the list element: 2
10:54:26 <xerox> fons_: it's okay, everybody do :-=
10:54:31 <davidhouse_> work_metaperl: doesn't matter
10:54:32 <xerox> toste: (
10:54:32 <toste> > [1,2] : [3,4]
10:54:33 <lambdabot>  add an instance declaration for (Num [a])
10:54:33 <lambdabot>   In the list element: 4
10:54:36 <davidhouse_> the compiler sets a = b
10:54:37 <fons_> but I will upload it once I finnish
10:54:38 <xerox> toste: (++) not (:)
10:54:42 <toste> :p
10:54:48 <fons_> BTW, any good parser generator for Haskell?
10:54:50 <work_metaperl> I'm missing something
10:54:58 <Cale> > [1,2,3] >>= \x -> show x
10:54:59 <lambdabot> "123"
10:55:01 <davidhouse_> work_metaperl: if you have a and b as type variables, they don't have to be differen't types.
10:55:03 <davidhouse_> they _can_ be.
10:55:03 <xerox> fons_: I like parsec
10:55:23 <mauke> > [1,2,3] >>= show
10:55:25 <lambdabot> "123"
10:55:27 * xerox waves to Cale
10:55:33 <Cale> hello :)
10:55:36 * mahogny suddenly comes up with another idea for SoC *goes wiki*
10:55:41 <dcoutts_> work_metaperl, those 'a' & 'b' type parameters are bound each time you apply comb. So just because you use it once with a=Int b=Float doesn't mean you can't use comb somehwere else with different types
10:55:51 <dcoutts_> work_metaperl, for example:
10:55:59 <dcoutts_> > (id 'c', id 3)
10:56:00 <lambdabot> ('c',3)
10:56:06 <dcoutts_> @type id
10:56:07 <lambdabot> forall a. a -> a
10:56:30 <xerox> Cale: any ideas on the SoC projects?  I've got quite a list, but ideas are very welcome.  I think it might interest you to see which projects were proposed lately: http://haskell.org/haskellwiki/Summer_of_Code:_Project_suggestions
10:56:33 <dcoutts_> so I can use 'id' at type Char -> Char and Int -> Int all within one expression
10:56:41 <dcoutts_> work_metaperl, see?
10:57:21 <dcoutts_> work_metaperl, this is called polymorphism in Haskell (in Java/C++ they call it generic programming)
10:58:15 <work_metaperl> I guess what I am getting at is: if something produces a Maybe b but a function (e.g. comb) works off of things of type a then we have a problem, no?
10:58:17 <qwr> fons_: i've used parsec (which is not generator)
10:58:20 * araujo wonders if re-writting the GHC mangler into Haskell is a realistic or interesting projet to include.
10:58:25 <dcoutts_> work_metaperl, so your comb function will work with *any* 'a' & 'b', and they can be different each time you use comb
10:58:39 <dcoutts_> araujo, probably not
10:58:43 <toste> wow, am gettign ok in haskell ;p
10:58:43 <davidhouse_> work_metaperl: like i said, just because you're using two different type variables, you can still use the same type.
10:58:47 <fons_> qwr, it seems to be popular, I'll have a look at it
10:58:53 <araujo> dcoutts_, why exactly?
10:58:54 <toste> 5 days ago i didnt know shiet hehe
10:58:55 <Cale> xerox: how about a library using FunctionalForms ideas with Gtk2Hs?
10:59:05 <Cale> http://www.sandr.dds.nl/FunctionalForms/index.html
10:59:05 <work_metaperl> oh ok and a and b can be the same... right?
10:59:05 <dcoutts_> araujo, the program is nasty and uninteresting
10:59:11 <araujo> dcoutts_, haha
10:59:11 <dcoutts_> Cale, yes!
10:59:12 <davidhouse_> > let a x = Just (x + 1); b y = Just (y - 2) in Just 4 >>= a >>= b
10:59:14 <lambdabot> Just 3
10:59:22 <davidhouse_> > let a x = Just (x + 1); b y = Just (y - 2) in Nothing >>= a >>= b
10:59:23 * araujo thinking abut a darcs Gtk+ GUI too
10:59:23 <lambdabot> Nothing
10:59:29 <dcoutts_> araujo, yes!
10:59:35 <araujo> dcoutts_, go!!
10:59:37 <araujo> :-)
10:59:50 <pejo> dcoutts, I've sort of lost track of time (again), but you mentioned some article you were writing a couple of months ago. Anything new there?
10:59:53 <dcoutts_> araujo, Cale: add your ideas to the wiki (and tell xerox)
11:00:01 <dcoutts_> pejo, about what?
11:00:01 <araujo> dcoutts_, Perfect
11:00:07 <xerox> Yes, I was about to say that Cale, mind to write a short description on the wiki?
11:00:11 <araujo> xerox, read above :-]
11:00:14 <xerox> Looks promising!
11:00:25 <dcoutts_> araujo, you write it! don't be lazy ;-)
11:00:37 <pejo> dcoutts, Partial Evaluation, maybe? :-)
11:00:40 <araujo> dcoutts_, im on it, i just letting xerox known abut it haha
11:00:46 <araujo> :-]
11:00:47 <xerox> araujo: what exactly?
11:00:49 <dcoutts_> pejo, ah, no, still in progress
11:00:53 <xerox> Ah right.
11:00:59 <xerox> Tell me!
11:01:00 <araujo> xerox, A Gtk+ front-end for darcs
11:01:01 <dcoutts_> araujo, ok :-)
11:01:02 <davidhouse_> work_metaperl: exactly.
11:01:10 <araujo> xerox, what about taht one?
11:01:16 <xerox> Nice one!
11:01:21 <araujo> haha, im adding!
11:01:47 <davidhouse_> work_metaperl: e.g. if you had a function which took a (a, b), then you could still give it a (Int, Int).
11:02:29 <davidhouse_> the important thing is to realise that the function you pass into comb can change the type.
11:03:02 <davidhouse_> > let a x = Just (x + 1); b y = Just (show y) in (Just 5) >>= a >>= b
11:03:03 <lambdabot> Just "6"
11:03:09 <davidhouse_> > let a x = Just (x + 1); b y = Just (show y) in Nothing >>= a >>= b
11:03:10 <lambdabot> Nothing
11:04:51 <davidhouse_> (i'm just using >>= instead of comb because they're the same thing, and it saves me having to set up a comb myself)
11:05:54 <mahogny> I must say the thought of someone coding a Functional Matlab is extremely tempting but it certainly isn't 3 months work :/
11:06:56 <davidhouse_> mahogny: isn't there already a haskell CA?
11:06:58 <davidhouse_> *CAS
11:07:15 <mahogny> davidhouse_, matlab isn't a CAS
11:07:35 <davidhouse_> oh?
11:07:40 <mahogny> it's purely numerical
11:07:48 <xerox> Right.
11:08:00 <araujo> dcoutts_, xerox ...mmm , who should i put as mentor? 
11:08:15 <davidhouse_> mahogny: so, a lot more limited?
11:08:17 <mahogny> I was about to go at it earlier, but then I wasn't skilled enough in haskell. maybe give it a shot later
11:08:19 <davidhouse_> araujo: haskell.org
11:08:27 <dcoutts_> araujo, no-one yet
11:08:35 <araujo> dcoutts, ok
11:08:37 <mahogny> davidhouse_, it's an imperative language aimed at being very easy to use for numerics and it comes with easy to use plotting stuff
11:08:41 <dcoutts_> araujo, on the wiki, if it's your idea then it doesn't have a mentor yet
11:08:52 <davidhouse_> araujo, or listen to someone that knows what they're talking about :) (dcoutts)
11:08:55 <dcoutts_> araujo, but if it's on the wiki then a mentor may claim it
11:08:56 <mahogny> davidhouse_, it's your dream if you come from C or Fortran :)
11:09:10 <dcoutts_> araujo, if it's a good idea I may claim it :-)
11:09:51 * araujo since he hopes to apply as a student he won't be able to be mentor (me thinks)
11:09:56 <araujo> dcoutts_, got it
11:10:06 <mahogny> davidhouse_, I believe you could actually build something similar (not as good as custom-built) if you took GHCi and added plotting functions and an IDE to it
11:10:18 <davidhouse_> yeah.
11:11:29 <mahogny> hm. well, in theory you don't even have to extend GHCi if you are in that mood
11:11:51 <mahogny> just make another process communicate with it and let it handle the GUI
11:12:43 <mahogny> maybe that actually can be done in less than three months, if you forget about the IDE for the time
11:15:07 <davidhouse_> which archs/OSs can GHC compile for?
11:15:44 <lispy> araujo: yeah, they only allow one person each year to be both a student and metor
11:15:45 <davidhouse_> and what special extras do i need to compile for those targets?
11:15:47 <lispy> mentor*
11:16:11 <mahogny> davidhouse_, I believe the manual is a better source of information in this case
11:16:15 <xerox> davidhouse_: it can compile on quite a number of architectures!
11:16:29 <davidhouse_> e.g. will i need a mac to compile for ppc?
11:16:48 <mahogny> hm. didn't I see a similar question recenctly?
11:16:56 <mahogny> I kind of don't see why you would need it
11:17:32 <xerox> davidhouse_: maybe you could go under qemu at the very least
11:17:44 <davidhouse_> xerox, qemu?
11:18:04 <davidhouse_> mahogny: i'm writing a tool for other people that don't necessarily use linux x86.
11:18:09 <xerox> http://fabrice.bellard.free.fr/qemu/
11:19:58 <araujo> added....
11:23:28 <dcoutts_> xerox, if you can find a darcs expert that might want to mentor a darcs Gtk+ GUI that'd be cool (I could do it but a darcs expert might be better)
11:23:48 <xerox> dcoutts_: Right.
11:24:09 <nomeata> dcoutts: hi. just curious: are there any notable "real" gtk2hs based applications out there?
11:24:24 <dcoutts_> xerox, a darcs GUI could be a great project actually, it could be really useful
11:24:42 <xerox> Okay, I'll be relaying the request now.
11:24:59 <nomeata> FYI, I'm writing a frontend to the MySQL database where we keep the practice points of our students. I chose haskell because it's the course's main language :-)
11:25:25 <dcoutts_> nomeata, there are some research projects using it (Pivotal, Epigram) and it's in use for teaching and there are many little projects here and there
11:26:05 <nomeata> dcoutts, btw: Might this signature be wrong: entryCompletionSetMatchFunc :: EntryCompletion -> (String -> TreeIter -> IO ()) -> IO ()
11:26:14 <nomeata> I'd expect entryCompletionSetMatchFunc :: EntryCompletion -> (String -> TreeIter -> IO (Bool)) -> IO ()
11:26:20 <dcoutts_> nomeata, sounds great, if you want to do a screenshot feature thing on the gtk2hs web site that'd be great - we're always looking to show off real apps
11:26:59 <davidhouse_> @palomer
11:27:00 <lambdabot> hrmph
11:27:03 <nomeata> dcoutts: the screenshot will be boring, it's just a gtk app :-P. but yes, I can do that when it's more polished
11:27:08 <davidhouse_> that still makes me laugh. :)
11:27:10 <dcoutts_> nomeata, as I said eariler you're probably right about that, send an email to gtk2hs-dev so we don't forget (and it'll get fixed quicker if you include a patch)
11:27:43 <nomeata> dcoutts: sorry, missed your reply. e-mail will be sent shortly
11:27:55 <dcoutts_> ta
11:31:08 <davidhouse_> dcoutts_, does using GHC in a program necessarily mean that program won't work on windows?
11:31:14 <jlhamilton> i found some links for more info about Pivotal and Epigram:  http://sneezy.cs.nott.ac.uk/epigram/ http://www.cs.kent.ac.uk/projects/pivotal/index.html
11:31:23 <davidhouse_> unless you do something clever like an abstract GUI-lib layer
11:31:39 <xerox> dcoutts_: sent.
11:31:39 <RyanT5000> is the government still in the market for provably-secure OSes?
11:31:47 <RyanT5000> that sounds like a great application for haskell
11:31:48 <dcoutts_> davidhouse_, do you mean Gtk+ or GHC?
11:31:57 <davidhouse_> lol :)
11:32:01 <davidhouse_> i mean gtk2hs. sorry.
11:32:09 <dcoutts_> davidhouse_, gtk2hs works on win32
11:32:31 <dcoutts_> gtk2hs is more portable than wxhaskell
11:33:23 <dcoutts_> they both work on linux, win32 & OSX, gtk2hs also works on Solaris & *BSD
11:33:35 <davidhouse_> very nice:)
11:35:59 <RyanT5000> is there a way for a thing in a case statement to defer to another thing in that case statement?
11:36:03 <mahogny> gtk+ does not always look very native though. but I think one has better control over that gui for that reason
11:36:45 <RyanT5000> e.g.: case x of { A -> someInteger ; B -> (case A) + 1 }
11:37:05 <dcoutts_> mahogny, it looks pretty good on unix & win32. It's still not so good on OSX but they're working on a native layer.
11:37:05 <RyanT5000> (like structured fall-through)
11:37:26 <davidhouse_> RyanT5000: try a let clause
11:37:43 <RyanT5000> like before the case statement?
11:37:46 <mahogny> dcoutts, sounds nice
11:37:50 <davidhouse_> let n = someInteger in case x of A -> x; B -> x + 1;
11:37:51 <psi> *test*
11:37:59 <davidhouse_> psi, worked :)
11:37:59 <psi> sorry, couldn't type earlier
11:38:03 <RyanT5000> you mean A -> n, right?
11:38:10 <davidhouse_> err, yeah. same with B.
11:38:14 <RyanT5000> yeah thanks
11:39:43 <psi> what I wanted to say was, working with haskell during summer of code would be so cool. I just wish I was more experienced. I wonder if there's something you could work on without being a hard-core hacker.
11:40:11 <RyanT5000> psi: i'm also pretty inexperienced, but my plan is to just become a hardcore hacker as fast as possible :)
11:40:18 <xerox> psi: it doesn't mean much.  It's for students :-)
11:40:30 <SyntaxNinja> y0 xerox
11:40:41 * xerox waves to SyntaxNinja
11:40:42 <psi> RyanT5000: hehe, good plan
11:40:43 <SyntaxNinja> xerox: I gave google the go-ahead
11:40:51 * xerox gives SyntaxNinja a cookie in exchange :-D
11:40:53 <SyntaxNinja> hope there haven't been any objections, I certainly haven't heard any
11:40:58 <xerox> That's absolutely great.
11:41:02 <xerox> You rock!
11:41:43 <SyntaxNinja> :)
11:42:18 <xerox> SyntaxNinja: I'm mailing everywhere.
11:42:35 <xerox> SyntaxNinja: did you see the projects?  I had to categorize them since they were so many.
11:43:01 <SyntaxNinja> xerox: link? 
11:43:03 <davidhouse_> xerox, where is it?
11:43:10 <xerox> http://haskell.org/haskellwiki/Summer_of_Code:_Project_suggestions
11:43:32 <xerox> SyntaxNinja: add your ideas too if they aren't covered yet!
11:45:11 <SyntaxNinja> bah, can't remember my login offhand, but I would add two "systems" things.  integrate Halfs w/ House, and integrate Halfs w/ darcs :)
11:45:21 * xerox <- forkIO eat; waitForChildren xerox
11:45:54 <SyntaxNinja> hehe
11:45:56 <mnislaih> integrating Halfs w/ Darcs should be cool too, buy what's House ?
11:45:58 <lispy> xerox: uh...what are you eating?
11:46:12 <xerox> (dinner, brb)
11:46:16 <lispy> xerox: that's sort of scary if it makes you need to wait for children :)
11:46:19 <davidhouse_> lispy: hehe :)
11:46:26 <davidhouse_> mnislaih: an OS written in haskell
11:46:43 <RyanT5000> is there a game plan for House?
11:47:01 <mnislaih> oh, i'll go research google, it's the first time I hear about that davidhouse_
11:47:01 <RyanT5000> like, a strategy to make it a viable OS for real stuff
11:48:05 <mahogny> RyanT5000, nothing I have heard of. on the other hand, I don't see why would that be a good idea either
11:48:17 <araujo> @where himerge
11:48:18 <lambdabot> http://www.haskell.org/~luisfaraujo/himerge/
11:48:20 <RyanT5000> mahogny: why wouldn't it be a good idea?
11:48:21 <lispy> RyanT5000: making it "a viable OS for real stuff" probably isn't the ultimate goal...i would imagine it's meant more as a proof of concept for how FP langs can be used to write a highly reliable OS
11:48:23 <araujo> nomeata, ^^
11:48:34 <mahogny> RyanT5000, what would be the gain?
11:48:50 <RyanT5000> ok yeah well proof of concept is nice but i'm mostly interested in real stuff
11:49:12 <lispy> RyanT5000: well, the linux kernel can always use hackers ;)
11:49:18 <xerox> Uhmm.
11:49:37 <musasabi> House is also testbed for code.
11:49:38 <xerox> SyntaxNinja: should we now go for the homepage entry about the project? I wonder if Goolge is going to check the site
11:49:45 <xerox> brb
11:50:05 <musasabi> e.g. when House has a high performance networking stack many people might want use that for commercial purposes too.
11:50:36 <RyanT5000> i guess i risk sounding naive, but it seems like there should be an OS with a newer design than the monolithic kernel of windows/linux/etc.
11:50:38 <araujo> oh, yeah, house hacking would be nice
11:51:06 <mahogny> musasabi, I have a feeling they'd rather try to put it in another OS like linux when that time comes. it's no fun at all writing tons of drivers
11:51:09 <RyanT5000> i mean, i think linux is great in a large number of ways, but the basic design doesn't seem that impressive
11:51:26 <musasabi> there is some talk of a microkernel based thing, in some of the papers.
11:51:42 <lispy> RyanT5000: yeah, you can find debates about this all over the OS community. 
11:51:53 <RyanT5000> yeah, i know
11:52:01 <musasabi> mahogny: yes, I think it would be used through the tunnel/tap drivers for apps needing large amounts of tcp connections or various tricks.
11:52:06 <lispy> RyanT5000: exo kernel was a cool idea, but it sort of disappeared...
11:52:09 <RyanT5000> i've never really figured out why only monolithic architectures ever seem to be successful
11:52:20 <RyanT5000> lispy: i thought exokernel was a bit of overkill
11:52:21 <lispy> because you can build them easily
11:52:29 <mahogny> RyanT5000, well, there is no question about linux being quite a cave man but it runs and works. OS design is still in the stage "wow it works!"
11:52:40 <lispy> and having something that works at all is better than not having anything
11:53:02 <RyanT5000> also, what's the deal with this hardware-level virtualization stuff?
11:53:04 <nomeata> araujo: what, me? (or just a case of no autocompletion?)
11:53:07 <RyanT5000> i thought that was what Protected Mode was
11:53:19 <araujo> nomeata dcoutts: hi. just curious: are there any notable "real" gtk2hs based applications out there?
11:53:29 <RyanT5000> i mean it sounds to me like we've just failed at using protected-mode so badly that now the chip makers are giving us a second chance
11:53:33 <mahogny> RyanT5000, sounds like sand boxing
11:53:38 <araujo> nomeata, it was just a _delayed_ answer :-]
11:53:41 <nomeata> araujo: well, yes, google for gtk2hs and look for apps...
11:53:48 <mahogny> sand boxing is a lame excuse for not delivering code with proofs
11:54:02 <lispy> actually, i think it sounds very cool
11:54:07 <nomeata> araujo: but that will change soon, I guess, when the API is complete and in distros like debian.
11:54:29 <araujo> nomeata, what do you mean?
11:54:29 <RyanT5000> mahogny: you don't make money on a system by providing more barriers to people writing things on it
11:54:47 <lispy> i was reading about valgrind wondering why the hardware can't provide that level of "synthetic processor" for debugging purposes
11:55:02 <nomeata> araujo: when gtk2hs is a bit more finished and can be installed using apt-get install, applications will quickly follow
11:55:18 <RyanT5000> for example, it'd kick ass to have a natively-haskell OS to use on an every-day basis, but it won't catch on unless you have a C++-to-haskell compiler
11:55:19 <mahogny> RyanT5000, the only cure as I see it is to start suing companies each time their programs malfunctions. heck, you can get sued for hot coffee "over there", so this is nothing compared
11:55:35 <RyanT5000> except they've all indemnified themselves
11:55:42 <araujo> nomeata, oh.. mm.. well, that sounds like very distro dependent
11:55:46 <RyanT5000> you can't buy software without signing away your right to sue
11:55:50 <araujo> nomeata, we have good support for Gentoo
11:55:56 <araujo> as an example...
11:56:04 <nomeata> araujo: sure, debian was just an example
11:56:16 <RyanT5000> i vaguely remember some legislation being introduced that would make it impossible to revoke warrranties on software, but i'm pretty sure it didn't go anywhere
11:56:16 <Cale> why would you need a C++ to Haskell compiler?
11:56:29 <RyanT5000> because of all the developers who want to use C++
11:56:31 <mahogny> RyanT5000, when OSS has caught up, that will be one of their few means to compete; to give guarantees of working software
11:56:36 <araujo> nomeata, And of course, the more the better. But i was just pointed out that there already _real_ gtk2hs appli out there
11:56:48 <RyanT5000> mahogny: who will back up the guarantees for OSS?
11:57:05 <Cale> RyanT5000: want to use C++ to generate Haskell code which is just going to be compiled back into assembler anyway?
11:57:07 <mahogny> RyanT5000, if OSS still wish to compete they have to go the same way. evolution as always
11:57:07 <RyanT5000> who will let themselves be sued if OSS breaks?
11:57:09 <nomeata> araujo: hmm. but not very visible yet, are they? compared to, like, the mono craze applications
11:57:12 <SyntaxNinja> RyanT5000: it's not meant to be a general purpose OS, it's meant to be a separation kernel, afaik. maybe I'm wrong
11:57:22 <SyntaxNinja> xerox: what do you mean?
11:57:37 <SyntaxNinja> xerox: do you want to stick w/ wiki page for now, or should we create a trac instance and move things into tix
11:57:38 <araujo> nomeata, i wouldn't compare it with mono
11:57:41 <davidhouse_> Cale, what's the alternative?
11:57:53 <mahogny> RyanT5000, not to mention, once there is money in removing bugs, there will be more tools available for us as well
11:57:55 <davidhouse_> Cale, you can't suggest compiling to assembler and keep it at that. refactoring, anyone?
11:58:30 <araujo> nomeata, And imho, gtk2hs is actually kind of visible. It is one of the best API out there for gtk2. You can see the status of bindings in its site.
11:58:31 <RyanT5000> Cale: all i'm saying is that if you have an OS on which you can't compile C++ programs, it won't be successful
11:58:31 <nomeata> araujo: or ruby, or any of the recent "hip" languange. IMHO, haskell is on the best way to become hip, and then standard, too.
11:58:49 <Cale> Well, just because your OS is written in Haskell doesn't mean that you can't port a C++ compiler to it.
11:59:04 <Cale> But that wouldn't be a C++ to Haskell compiler
11:59:10 <Cale> it would be an ordinary C++ compiler
11:59:14 <araujo> nomeata, http://www.gtk.org/bindings.html
11:59:18 <araujo> Check what i mean
11:59:19 <RyanT5000> Cale: i was saying if your OS only ran Haskell
11:59:35 <nomeata> araujo: well, one of the best API sounds like an exagaration, there are parts I was missing after two days... but I like it so far.
11:59:36 <RyanT5000> like let's say you used Haskell's type system to enforce your system's security
11:59:44 <Cale> ah
11:59:47 <RyanT5000> (not saying this is a good idea; it was only a hypothetical example)
11:59:48 <davidhouse_> Cale, oh, i thought we were talking about hacking the OS itself.
12:00:02 <SyntaxNinja> RyanT5000: that's more or less the idea of House, AFAIK.
12:00:08 <araujo> nomeata, it has been very smooth for me.
12:00:11 <SyntaxNinja> but more than just Haskell's type system.
12:00:34 <araujo> nomeata, and check which is the only language (according to gtk.org) supporting the latest versions.
12:00:37 <RyanT5000> SyntaxNinja: in that case, what i am saying, is that for house to become popular, someone better come up with a way to shoehorn C++, Java, and C into it
12:00:38 <mnislaih> hooray! haskell.org is showing in the official SoC site !
12:00:47 <nomeata> araujo: but I'm already buggin dcoutts all the time about the stuff I miss, so I guess that will be fixed.
12:00:47 <SyntaxNinja> RyanT5000: popular for who?
12:00:59 <araujo> hoorray!!
12:01:01 <SyntaxNinja> RyanT5000: there are lots of uses for non-desktop operating systems.
12:01:03 <nomeata> araujo: well, you ignore C, C++, perl, python and java
12:01:24 <araujo> nomeata, im talking about the Other bindings.
12:01:32 <SyntaxNinja> RyanT5000: besides, you can write programs in C and run them on House, if I recall.
12:01:32 <nomeata> araujo: ok, agreed
12:01:39 <araujo> nomeata, Which mean that the Haskell bindings are in the level of those ones.
12:01:58 <araujo> Or closer to them, than say, C#
12:01:58 <davidhouse_> xerox, google's soc page doesn't have an '(ideas)' link for haskell.org like it has for some of the other projects. did you tell them about the wiki page?
12:01:59 <RyanT5000> gah, i'm not talking about what House really should do, or what it does or doesn't do, or whether it have a goal like that
12:02:26 <RyanT5000> i was making a much more confined statement relative to mahogny's statement that software should ship with proofs
12:02:36 <nomeata> araujo: well, close, some parts of the API feel like they have never been used, but we are getting there, and soon the first gtk2hs apps can appear in major distributions, don't you think?
12:02:39 <RyanT5000> specifically, that i think that's an undue burden on the developer
12:03:05 <araujo> nomeata, Well, the more we use gtk2hs, the better!!!
12:03:10 <RyanT5000> which will cause the demise of any system
12:03:19 <RyanT5000> (except for very special-purpose stuff)
12:03:33 <mahogny> RyanT5000, it would have to be introduced gradually
12:03:37 <araujo> nomeata, hey, are you saying that Gentoo isn't a major distro? ;-)
12:03:54 <nomeata> araujo: are there gtk2hs _apps_ in gentoo, too?
12:03:55 <araujo> nomeata, of course, the more distros including gtk2hs the better.
12:03:56 <RyanT5000> mahogny: can you generate the proof without any effort on the part of the developer?
12:04:07 <RyanT5000> like can i take my C++ hello world, and have the compiler output the proof as well?
12:04:07 <mahogny> RyanT5000, there's research going on
12:04:15 <RyanT5000> in which case, sure
12:04:23 <RyanT5000> it becomes part of your object file format
12:04:31 <RyanT5000> port gcc to it, and bam, you're fine
12:04:33 <araujo> nomeata, not yet , i am talking about gtk2hs support
12:04:39 <Cale> The proof of what, exactly?
12:05:05 <nomeata> araujo: ok, just making sure. 
12:05:22 <mahogny> RyanT5000, but heck, what if the OS lifts in the application into kernel space and removes tons of checks, making it 5% faster without crashing, then I think there is interest on a different level. proofs are as much about speed as about safety is as safety
12:05:25 <RyanT5000> Cale: not sure
12:05:31 <araujo> nomeata, As long as we have good support, anybody can pick it and start writting appli on it :-)
12:05:40 <RyanT5000> true mahogny
12:06:32 <nomeata> araujo: sure, my point was that if gtk2hs were available in debian (and thus ubuntu), even more people will consider writing their gtk apps in haskell
12:07:09 <araujo> nomeata, isn't gtk2hs available in Debian nor Ubuntu?
12:07:48 <araujo> nomeata, Of course, the more the better. As i told you, i just was pointed out that there already exist real life appli written on gtk2hs. 
12:07:55 <davidhouse_> araujo: gtk and ghc are available for those two. therefore, gtk2hs can be compiled.
12:08:13 <araujo> mm.. so?
12:08:21 <nomeata> araujo: there are packages ready, but not yet uploaded to the official package repository
12:08:33 <araujo> I suppose nomeata refers to the binary package.
12:09:23 <nomeata> right, as they are a prerequisite to uploding compiled versions of apps
12:09:31 <araujo> Ok. I wouldn't know how the Debian guys handle that.
12:10:48 <shapr> SyntaxNinja: hiya!
12:11:55 <jlhamilton> i compiled gtk2hs to work on Ubuntu
12:12:10 <jlhamilton> i think gtk2hs is available on Fedora now
12:12:43 <SyntaxNinja> y0 shapr
12:14:23 <araujo> hola SyntaxNinja 
12:22:11 <shapr> Whatever happened to @remember?
12:22:38 * Ulfalizer got a neat idea
12:22:56 <Ulfalizer> if i buy a wap i should be able to surf outside when my laptop arrives :)
12:23:17 <Ulfalizer> what cheap models are available that connect directly via an ethernet jack?
12:24:22 <xerox> davidhouse_: right, that's exactly what I was thinking about
12:24:51 <shapr> Ulfalizer: http://direct.nokia.com/Product.aspx?model=770 - get the wifi + dsl + 770 combo ;-)
12:25:19 <xerox> shapr: we're in!
12:25:26 <xerox> Let's party!
12:26:19 <shapr> w00!
12:26:39 <Ulfalizer> shapr: i think i'll settle for just a router :)
12:27:21 <SyntaxNinja> http://hackage.haskell.org/trac/summer-of-code login guest pass haskell'
12:29:48 <tibbe> who makes the best SOHO routers?
12:31:15 <Ulfalizer> SOHO?
12:31:44 <shapr> small office home office
12:32:16 <shapr> I want to get a linksys because they run Linux from flash and you can change the image.
12:33:04 <morans> haskell based wireless router?!
12:33:22 <Ulfalizer> aren't there any wap's that simply function as bridges and don't support multiple clients?
12:33:25 <tibbe> that you be something
12:33:34 <Ulfalizer> i guess not. the clientele wouldn't be that big for such a product :/
12:33:35 * SyntaxNinja lunch &
12:33:38 <tibbe> haskell routers that maps bits to church numerals
12:52:22 <cinema> shapr, ping
12:53:10 <shapr> pong
12:53:33 <cinema> shapr, Hi. Some ideas for SoC...
12:54:13 <cinema> 1) A haskell program processor, converting the type signatures in Unicode
12:54:35 <cinema> (and the subsequent references in the functions)
12:55:15 <shapr> Using the real forall and exists symbols?
12:55:23 <cinema> It makes much more readable programs in Xemacs, Eclipse...
12:55:32 <cinema> shaapr, exactly
12:56:19 <shapr> Neat idea, add it to the wiki page!
12:56:28 <cinema> Test it. You'll be surprised by the readability
12:57:01 <shapr> Also, xerox is the person to talk to about Haskell SoC projects :-)
12:57:06 <morans> and unicode operators
12:57:09 <morans> and then rename it to APL!
12:57:31 <shapr> If I could type unicode, I'd want unicode operators.
12:57:45 <cinema> 2) A semantics aware pretty-printer (where constructors have a different degree of boldness from types)
12:57:48 <mnislaih> a unicode keyboard would be funny ...
12:57:58 <jyp> The latex input method seems like a good compromise.
12:58:59 <jyp> btw, imho, more important things are to bring the hIde to a level of decent usability.
12:59:51 <cinema> jyp, Unicode is already supported by ghc. So the whole thing would not be very complicated
13:00:03 <jyp> cinema: agreed.
13:00:12 <jyp> (it seems almost too simple :)
13:01:08 <cinema> The problem is printing programs afterwards. I use a2ps, but it does noy support Uincode
13:03:09 <morans> mnislaih: have you seen an APL keyboard?
13:03:25 <mnislaih> hmm nop
13:03:40 <mnislaih> but I like weird keyb. layouts
13:03:45 <__phas> anyone knows how to get a string of C unsigned char using c2hs libraries?
13:04:21 <morans> http://www.users.cloud9.net/~bradmcc/cgi-bin/vuImag3.pl?i=149
13:04:33 <Saulzar> jyp, Yep - I'd agree. Not only would it be nice for developers but a nice example of practicality
13:05:06 <mnislaih> damn! does it have forall ? I don't see it lol
13:05:47 <ChilliX> __phas: get? Do you mean peek from memory?
13:05:57 <Saulzar> If enough characters are similar to latin characters you could have another type of shift key, "Invert" :)
13:06:04 <morans> heh
13:06:38 <xerox> Back!
13:06:46 <jyp> I think that when hIDE gets easy enough to compile, and allows for basic edition, contributions will start pouring in by the thousands :)
13:07:19 <__phas> -ChilliX- well, no, obtain a pointer to. obtain a C string. c2hs libraries have newCString that takes an Haskell String and returns a C string, but of signed char
13:07:36 <__phas> -ChilliX- i need a string of unsigned char
13:08:52 <norpan> so just cast it to unsigned afterwards
13:09:21 <Saulzar> You can always manually allocate a Ptr Word8 or a StorableArray of Word8 where you can extract the Ptr
13:09:45 <norpan> since you don't say how the String should be converted
13:09:58 <norpan> so just (unsigned *) yoursignedcharpointer
13:10:22 <shapr> jyp: yes!
13:10:46 <norpan> contributions will come from me to hide if i have the time
13:11:08 <wchogg> I just saw that mahogny had suggested matlab bindings for an SoC project, but would that be allowed since matlab is proprietary?
13:11:23 <mahogny> wchogg, they are if the bindings are OSS
13:11:41 <mahogny> wchogg, with some luck, they might also be usable with octave in the future
13:11:43 <__phas> norpan not, so easy, i have a function that takes an array of unsigned char, i don't think that i can pass an array of signed, 'couse they are (i think) longer or coded differently
13:11:59 <norpan> it's no problem
13:12:00 <wchogg> mahogny:  Okay.  I wasn't sure if everything had to be open source to be eligible as a project.
13:12:13 <norpan> signed/unsigned char are both 8 bits
13:12:16 <mahogny> wchogg, well. haskell is. that's 50% at least ;)
13:12:19 <ChilliX> __phas: there is no direct support
13:12:23 <mahogny> wchogg, otherwise, just call it octave bindings :P
13:12:41 <ChilliX> newCString is implemented in terms of the array allocation operations in Foreign.C.Array
13:13:01 <ChilliX> you will have to use them explicitly
13:13:10 <__phas> ChilliX ,yes, i saw
13:13:22 <jyp> shapr: as a side note I've been trying to compile it many times but always failed in a way or another.
13:13:23 <__phas> ChilliX ,but how to put an UNSIGNED char in the array
13:13:40 <norpan> just try my suggestion first
13:14:06 <ChilliX> yeah, the trouble is that there is only castChatToCChar, but *no* castCharToCUChar...
13:14:07 <__phas> ChilliX ,looking in the c2hs library, he simply put the ASCII value of the chars in the slots of the rray
13:14:58 <shapr> jyp: Hm, I've been able to build it.
13:15:08 <__phas> ChilliX ,yes, and i don't know how to code a unsigned C char from a Hs Char
13:15:32 <jyp> shapr: maybe it's due to my using AMD64 arch.
13:15:39 <norpan> the first question you should ask is why does your c function want unsigned characters
13:15:47 <ChilliX> Yes, I realise that and I am afraid to say that strictly speaking that is a unfortunately a gap in the Haskell FFI specification.
13:16:13 <ChilliX> We just didn't think that anybody would need that
13:16:16 <norpan> and what kind of characters does it want
13:16:26 <norpan> UTF-8? latin-1? just ascii?
13:16:29 <jyp> shapr: also the dependency on a GHC snapshot doesn't ease things ;)
13:16:30 <ChilliX> but thinking about it, it makes sense to have
13:16:59 <ChilliX> I'll put it as an item to fix for Haskell'
13:17:30 <ChilliX> For the moment, you can hack around it by relying as follows:
13:17:53 <ChilliX> castCharToCUChar :: Char -> CUChar
13:17:53 <ChilliX> castCharToCUChar ch = fromIntegral (ord ch)
13:18:01 <__phas> norpan , i'm trying to bind in haskell miniLZA libraries, i think that want unsigned char for space-related terms
13:18:58 <ChilliX> Not pretty, but works for GHC's current impelmentation of Char
13:19:28 <__phas> well it's almost the same implementation of castCharToCChar
13:19:34 <norpan> __phas: but do they want strings, or do they just use unsigned char for generic bytes
13:19:37 <ChilliX> yes, but with a different type
13:19:39 <__phas> so, if it isn't pretty this...
13:19:42 <ChilliX> overloading does teh rest
13:19:46 <__phas> yeah, i noticed
13:20:11 <__phas> -norpan- they want strings
13:20:18 <__phas> thank you ChilliX
13:20:28 <ChilliX> np
13:21:30 <norpan> since haskell strings are unicode it spells trouble
13:22:15 <ChilliX> norpan: this is how it is done for CChar, too, atm
13:22:27 <norpan> unless you want exactly the format it wants and then you should either make sure that withCString gives you that format or make your own marshaling
13:22:35 <ChilliX> As I said a hack that works given the current state of affairs
13:24:47 <norpan> depending on how you want your haskell interface, perhaps [Word8] is a better type than String
14:04:11 <work_metaperl> I like >>= notation better than do notation for what I have seen so far
14:06:21 <norpan> i like do notation
14:08:05 <mahogny> the one which looks best is different by case by case basis
14:08:33 <norpan> i like monad comprehension
14:11:31 <davidhouse> do notation is normally the best.
14:11:52 <davidhouse> if what you're writing is only a couple of commands, and you don't need to do any "var <- something"s, then i normally just >>.
14:12:00 <Saulzar> >>= is ok for quick one liners, do for anything else
14:12:08 <davidhouse> or if all the commands are really short, then i'll >> them together.
14:12:24 <davidhouse> and >>= for points-free, and that's about it.
14:34:38 <morans> lambdabot: ping
14:34:47 <morans> no bot!
14:43:54 <SamB> hmm. I'm getting syntax errors in X headers building GHC...
14:46:46 <psi> has anyone created a ghc 6.4.2 package for os x yet?
14:56:45 --- mode: shapr set +o juhp
15:04:40 * araujo looks around
15:05:34 * bolrod to
15:05:36 <bolrod> o
15:05:51 <bolrod> I just counted the total amount of nicks in all the channels I'm joined to
15:05:53 <bolrod> ;/
15:16:20 <palomer> hullo
15:16:26 <palomer> I'm looking for an injection from String to Integer
15:17:00 <palomer> anyone have one handy?
15:18:09 <Saulzar> injection?
15:18:25 <sethk> I'm afraid of needles
15:18:35 <sethk> even if I can't spell them
15:18:49 <SamB> that means that many strings map to a single integer
15:22:09 <xerox> palomer: (whateverInjectiveFunction :: Int -> Int) . read -- ? :-)
15:22:25 <palomer> it means that that no two strings map to the same integer
15:22:43 <xerox> Ah.
15:22:52 <astrolabe> An injection would mean that each integer has at most one string mapping to it.
15:23:06 <astrolabe> palomer: right
15:23:39 <xerox> read . (>>= (return . ord)) :: String -> Int -- a-la Goedel ?
15:24:01 <palomer> @type  read . (>>= (return . ord))
15:24:02 <lambdabot>   Couldn't match `Char' against `Int'
15:24:02 <lambdabot>   Expected type: [Char] -> String
15:24:30 <astrolabe> @hoogle Char->Int
15:24:31 <lambdabot> No matches found
15:24:46 <xerox> @type ord
15:24:47 <lambdabot> Char -> Int
15:25:09 <astrolabe> eh?
15:25:16 <xerox> @type read . (>>= (return . ord) :: Char -> [Int])
15:25:17 <lambdabot> parse error on input `::'
15:25:21 <astrolabe> Why didn't hoogle find that?
15:26:36 <xerox> @type read . (>>= (show . ord))
15:26:37 <lambdabot> forall a. (Read a) => [Char] -> a
15:26:39 <xerox> Okay.
15:26:47 <toste> [Fractional_fromDouble instFractional_v53 0.0] in  list = maybe [0.0] id (fmap read (valeurAttribut "Historique" a) :: Maybe [Float])
15:26:54 <xerox> astrolabe: heard the news?
15:26:57 <toste> > :t [0.0]
15:26:57 <lambdabot>  parse error on input `:'
15:27:03 <toste> > :type [0.0]
15:27:04 <lambdabot>  parse error on input `:'
15:27:12 <toste> @type [0.0]
15:27:14 <lambdabot> forall a. (Fractional a) => [a]
15:27:18 <xerox> astrolabe: http://code.google.com/summerofcode.html
15:27:39 <bolrod> :D
15:27:43 <toste> xerox, whats rong :/
15:27:56 <xerox> toste: with?
15:27:57 <bolrod> cool :)
15:28:05 <xerox> bolrod: yay :D
15:28:12 <toste> [Fractional_fromDouble instFractional_v53 0.0] in  list = maybe [0.0] id (fmap read (valeurAttribut "Historique" a) :: Maybe [Float])
15:28:20 <ChilliX> How about: \str -> foldl (\i c -> i * (fromIntegral $ Char.ord maxBound) + (fromIntegral $ Char.ord c)) 0 str :: Integer
15:28:31 <xerox> toste: I can't understand the first part.
15:28:33 <ChilliX> or some such..
15:28:38 <toste> it's the error i get
15:28:48 <toste> Program error: pattern match failure: calculerCroissance [Fractional_fromDouble instFractional_v53 1.0] 
15:29:06 <xerox> toste: is it a list with no commas?  And what about the first thing, should it be Fractional.fromDouble ?
15:29:34 <xerox> toste: doesn't make much sense anyway
15:29:56 <bolrod> xerox: maybe put it as first in the topic?
15:30:06 <toste> Data Action = ( Symbole x, [x1, x2, ..., xi]
15:30:13 <astrolabe> @eval inj "hello" where {inj [] = 0; inj [a:as] = ord a + 256 * inj as}
15:30:14 <lambdabot> Couldn't match `[Char]' against `Char'
15:30:16 <xerox> bolrod: good idea
15:31:17 <xerox> Good luck with the code, gotta sleep.
15:31:29 <ChilliX> Paltas: the above was for you
15:31:34 <ChilliX> palomer: the above was for you
15:32:03 <bolrod> ohyeah!
15:32:06 <bolrod> sleep! :D
15:32:09 <bolrod> almost forgot ;/
15:33:02 <astrolabe> ah
15:33:13 <astrolabe> @eval inj "hello" where {inj [] = 0; inj (a:as) = ord a + 256 * inj as}
15:33:14 <lambdabot> 1819043176
15:33:25 <palomer_> sorry, lagged out
15:33:31 * shapr lags in
15:33:48 <astrolabe> @eval inj "hello" where {inj [] = 0; inj (a:as) = ord a + 256 * inj as}
15:33:49 <lambdabot> 1819043176
15:33:59 <SyntaxNinja> y0 shapr
15:34:03 <shapr> y0 y0
15:34:04 <palomer_> what injection did we get?
15:34:05 <xerox> Ah, you are there!
15:34:06 <shapr> Did you read my email?
15:34:29 <palomer_> ok, did anyone figure out a bijection (and its inverse)?
15:34:34 <morans> oh, thats how to use lamba?
15:34:35 * morans forgets
15:34:38 <morans> @eval 1
15:34:40 <lambdabot> 1
15:34:44 <morans> @eval Just 5
15:34:45 <lambdabot> Just 5
15:34:48 <morans> @eval Nothing
15:34:49 <lambdabot> Add a type signature
15:34:52 <morans> oh!
15:34:59 <morans> thats why it isn't working in my Mud impl...
15:35:05 <heof> The following works as expected but gobbles memory like a madman:
15:35:12 <astrolabe> he wants a bijection now!
15:35:18 <heof> print =<< nmergeIO [[ x | x <- [0..], False], [1..]]
15:35:27 <shapr> Will an Adjunction do?
15:35:29 <xerox> shapr: what about putting the relevant urls in the topic?
15:35:38 <astrolabe> heh
15:35:51 <heof> any idea what's going on?
15:35:54 <shapr> The SoC urls?
15:35:57 <xerox> Yep
15:36:01 <shapr> The topic is open source.
15:36:35 <palomer_> nono, bijections need only apply
15:36:47 <palomer_> I'm generating new type variables
15:36:54 <palomer_> might as well figure out the biggest index and simply work from there
15:37:03 <shapr> heof == newsham ?
15:37:12 <astrolabe> xerox: is there a haskell mentoring org in that page?
15:37:13 <heof> no...
15:37:42 <fons__> where can I find info about the "forall" key name?
15:37:43 <bolrod> http://haskell.org/haskellwiki/Summer_of_Code:_Project_suggestions
15:37:53 --- topic: set to '["Haskell.org SoC projects","http://haskell.org/haskellwiki/Summer_of_Code:_Project_suggestions","Submit a paper to the Haskell Workshop:", "http://haskell.org/haskell-workshop/2006", "Haskell is still the language of choice for discriminating hackers", "logs:","http://tunes.org/~nef/logs/haskell/", "http://www.haskell.org/learning.html", "We put the Funk in Funktion","Vote on a European #haskell get-together: http://snappoll.com/poll/84228.php"]' by xerox
15:37:57 <heof> fons__, google "ghc extensions"
15:38:01 <xerox> astrolabe: exactly :-D
15:38:43 <heof> so nobody knows what's going on here?
15:38:47 <heof> i.e. up there
15:38:53 <heof> the nmergeIO thing
15:40:06 <heof> ... okay then
15:40:33 <Cale> heof: you're starting lots and lots of threads there
15:40:55 <heof> Cale, really?  Seems to me it would only start two
15:41:01 <fons__> thanks heof 
15:41:06 <heof> one for each element of that two-element list
15:41:48 <Cale> heof: oh, sorry, no
15:42:05 <heof> no what? :-)
15:42:18 <Cale> (I misread the input list)
15:42:20 <heof> ahh
15:42:28 <araujo> mmm...
15:42:35 <araujo> Who changed the Darcs GUI thing?
15:43:23 <xerox> araujo: a Darcs person who contacted me
15:43:45 <xerox> I have to go now tho, I'll be around in 6 hours.
15:44:07 <araujo> xerox, mentor?
15:45:09 <xerox> No, he doesn't have time, I hope someone else will answer for volunteer.
15:45:20 <xerox> See darcs-devel and darcs-users mls
15:45:25 * xerox waves
15:46:01 <ihope_> I guess it's time to start thinking of working on EagleBot.
15:46:40 * araujo writes down a note for xerox when gets back
15:47:09 <work_metaperl> I have a question on the sequence monadic function, which I have posted here: http://rafb.net/paste/results/HkcLwB31.html
15:47:26 <ihope_> araujo: does anybody ever use MemoServ?
15:47:27 <work_metaperl> oh, and I would appreciate some feedback :)
15:47:50 <ihope_> Whoa, there *is* an mcons...
15:47:57 <ihope_> @type Control.Monad.mcons
15:47:58 <lambdabot> Not in scope: `Control.Monad.mcons'
15:48:03 <ihope_> @index mcons
15:48:04 <lambdabot> bzzt
15:48:05 <araujo> ihope_, what's that? 
15:48:07 <araujo> ;-)
15:48:08 <ihope_> Never mind.
15:48:18 <mauke> liftM2 (:)?
15:48:36 <mauke> yeah
15:48:37 <Saulzar> @pl mcons p q = p >>= \x -> q >>= \y -> return (x:y)
15:48:38 <lambdabot> mcons = liftM2 (:)
15:48:45 <ihope_> work_metaperl: think \x -> q (>>= \y -> return (x:y))
15:48:53 <ihope_> Erm.
15:48:59 <ihope_> work_metaperl: think \x -> (q >>= \y -> return (x:y))
15:49:08 <work_metaperl> oh
15:49:13 <work_metaperl> I was associating inccorectly
15:49:17 <work_metaperl> not to mention spelling :)
15:49:41 <ihope_> infixr -1 ->
15:49:44 <ihope_> :-)
15:49:49 <ihope_> At least, I think so...
15:49:53 <ihope_> > \x -> x $ 3
15:49:54 <lambdabot> Add a type signature
15:50:12 <ihope_> @type \x -> x 
15:50:13 <work_metaperl> ah, so the first thing that happens in x:y gets containerized
15:50:13 <lambdabot> forall t. t -> t
15:50:15 <ihope_> @type \x -> x $ 3
15:50:17 <lambdabot> forall a b. (Num a) => (a -> b) -> b
15:50:36 <work_metaperl> is x:y gets containerzied
15:50:49 <ihope_> Contained?
15:51:13 <work_metaperl> oh wait. I skipped the part where they talked about what "->" meant... I dont understand what "->" means when using monads
15:51:18 <work_metaperl> back to the drawing board
15:51:36 <mauke> -> isn't monads, it's functions
15:51:41 <ihope_> foo bar = baz is the same as foo = \bar -> baz
15:52:22 <ihope_> Okay. Where would I start writing an "open a terminal window" function?
15:53:01 <bolrod> execute /bin/sh something?
15:53:32 <ihope_> That won't work on Windows.
15:53:39 <bolrod> then you use cmd there
15:53:48 * ihope_ tries it
15:53:58 <mauke> sh isn't a terminal
15:53:58 <bolrod> don't think /bin/sh will spoof a window
15:54:04 <ihope_> @hoogle String -> IO ()
15:54:05 <lambdabot> Prelude.putStr :: String -> IO ()
15:54:05 <lambdabot> Prelude.putStrLn :: String -> IO ()
15:54:05 <lambdabot> Debug.Trace.putTraceMsg :: String -> IO ()
15:54:16 <ihope_> Is there some "run this file" command?
15:54:20 <ihope_> @docs System.IO
15:54:21 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html
15:54:36 <mauke> @hoogle system
15:54:37 <lambdabot> System.system :: String -> IO ExitCode
15:54:37 <lambdabot> System :: module
15:54:37 <lambdabot> System.Win32.Info.SystemColor :: type SystemColor
15:54:54 <bolrod> blah
15:54:59 <ihope_> @docs Syste,
15:54:59 <lambdabot> Syste, not available
15:55:02 <ihope_> @docs System
15:55:02 <lambdabot> System not available
15:55:03 <bolrod> sleep.. or at least.. laying in bed :)
15:55:19 <ihope_> @index system
15:55:20 <lambdabot> System.Cmd
15:55:32 <ihope_> @docs System.Cmd
15:55:32 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Cmd.html
15:55:39 <palomer_> where's my bijection??!
15:56:44 <ihope_> Okay. system "cmd" didn't work.
16:17:30 <work_metaperl> 'm confused. What happens when a function is created like this: (return []) as is shown here: http://www.nomaware.com/monads/html/monadfns.html
16:18:08 <ihope_> Um...
16:18:38 <ihope_> return [] sticks the value [] into a monad.
16:18:45 <mauke> (return []) isn't a function
16:19:07 <mauke> .oO( awaiting counterexample )
16:19:13 <work_metaperl> but return containerizes things
16:19:26 <work_metaperl> for example for the List monad, return x = [x]
16:19:36 <work_metaperl> how does one containerize something that has nothing?
16:19:49 <mauke> why nothing?
16:19:51 <work_metaperl> oh it sticks [] into a container
16:19:51 <mauke> [] is a value
16:20:01 <work_metaperl> [] gets containerized
16:20:03 <work_metaperl> !
16:20:04 <work_metaperl> I get it
16:20:09 <work_metaperl> am I right?>
16:20:21 <mauke> > return [] :: [[String]]
16:20:22 <lambdabot> [[]]
16:20:45 <work_metaperl> what did qualifying that with a type signature do?
16:20:56 <mauke> > return []
16:20:56 <work_metaperl> > return []
16:20:57 <lambdabot>  add an instance declaration for (Show (m [a]))
16:20:57 <lambdabot>  add an instance declaration for (Show (m [a]))
16:21:04 <mauke> avoid this problem :-)
16:21:18 <work_metaperl> return [] :: [[Int]]
16:21:26 <work_metaperl> > return [] :: [[Int]]
16:21:27 <lambdabot> [[]]
16:29:05 <work_metaperl> help an ignorami out a little bit more. In the defintion of mcons (http://www.nomaware.com/monads/html/monadfns.html), p is the containerized empty list, correct?
16:32:47 <ihope_> It seems so.
16:34:24 <palomer> is there a type class for enumeration?
16:35:09 <mauke> @type enumFromTo
16:35:10 <lambdabot> forall a. (Enum a) => a -> a -> [a]
16:40:44 <tnks> Hi, I just saw a "let" statement without a corresponding "in"
16:40:54 <tnks> I think the code compiles.  Is that legal?
16:41:22 <liyang> In a do block, yes.
16:41:31 <tnks> ah... okay.
16:41:34 <tnks> I didn't realize.
16:42:03 <palomer> ski: ping?
16:44:14 <tnks> do you need a let statement in a do block?  Can you just use the " <- " syntatic sugar in a do block?
16:44:28 <tnks> are they semantically equivalent?  Or is there a difference?
16:44:33 <mauke> <- extracts a value from a monad
16:44:40 <mauke> let just binds a variable to a value
16:45:03 <tnks> mauke: I see.
16:45:34 <tnks> I haven't used monads in a while.  I'm forgetting some basics.
16:45:54 <tnks> (by haven't used monads... I really mean haven't used Haskell).
16:47:05 <palomer> how do I find out if a typeclass is derivable?
16:48:46 <Saulzar> palomer, There aren't many :)
16:49:09 <Saulzar> I guess the report says so
16:52:39 <palomer> Cale: ping
16:52:47 <palomer> (have you guys noticed that I'm back into haskell?) :P
16:53:13 <Saulzar> I assumed it was permanant :P
16:53:37 <palomer> oh no, I switch constantly between programming language
16:53:44 <palomer> I'm a programming slut
16:53:48 <palomer> programming manslut
16:53:54 <Saulzar> Hmm.. I pick one and stay for life
16:54:43 <palomer> is there a range typeclass?
16:54:50 <palomer> like, I want to get all elements between the first and the third
16:54:57 <wchogg> palomer:  You're an easy compile?  You like to code around?
16:54:58 <Saulzar> Hmm, Ix will do something like that
16:55:11 <Saulzar> @type Data.Array.range
16:55:13 <lambdabot> forall a. (Ix a) => (a, a) -> [a]
16:55:38 <Saulzar> Which was your last?
16:56:05 <palomer> ahh, but I want them to be indexed by integers
16:56:41 <Saulzar> Make an array?
16:56:49 <palomer> ["a".."b"]
16:56:52 <palomer> > ["a".."b"]
16:56:53 <lambdabot>  add an instance declaration for (Enum [Char])
16:56:53 <lambdabot>   In an arithmetic sequence: ["a" .. "b"]
16:56:53 <lambdabot>   In the definition of `swz': swz = ["a" .. "b"]
16:57:15 <palomer> is there a typeclass for integer mappings?
16:57:31 <Saulzar> I think that's called Data.Map
16:57:45 <Saulzar> (Rather, I don't think so)
16:57:57 <palomer> ah, no, Ord!
16:58:09 <palomer> ahh, nevermind
16:58:59 <palomer> you see, I want to get n unique elements of some type
16:59:32 <Saulzar> Randomly?
16:59:38 <palomer> not necessarily
17:00:02 <goltrpoat> well.. ["a".."b"] doesn't make sense, which ordering are you putting on the strings?  ['a'..'b'] makes sense, and map (some_coercion) [1..n] makes sense
17:01:54 <palomer> "a" < "b"
17:01:57 <palomer> > "a" < "b"
17:01:57 <Saulzar> I suppose one could make String an Enum :)
17:01:58 <lambdabot> True
17:02:02 <palomer> strings are ordered
17:02:05 <goltrpoat> but [Char] isn't Ord
17:02:14 <palomer> why the blazes isn't [Char] an Ord?
17:02:45 <ihope_> palomer: people can't agree on how they should be ordered, I guess.
17:02:59 <ihope_> Are longer strings always greater than shorter ones?
17:03:37 <ihope_> Are strings beginning with "higher" letters always higher than ones beginning with lower ones?
17:03:51 <goltrpoat> well.. lexicographical ordering is obviously well-defined on strings
17:03:56 <palomer> but there's an ordering on [Char]
17:04:01 <ihope_> Or is it s/$beginning/$ending/?
17:04:41 <Cale> There's an instance of Ord [Char]
17:04:48 <palomer> why are we even discussing the validity of an ordering on [Char] ? it's in ghci!
17:04:56 <palomer> Cale: any reason why [Char] isn't an Enum?
17:05:17 <ihope_> Same reason it isn't an Ord?
17:05:22 <palomer> IT IS
17:05:24 <palomer> YOU SILLY GOOSE
17:05:43 <Cale> > "Hello" < "Goodbye"
17:05:44 <goltrpoat> what's succ "blah"
17:05:44 <lambdabot> False
17:05:47 <goltrpoat> heh
17:05:50 <Saulzar> I don't suppose it's a "normal" use of strings..
17:06:03 <ihope_> goltrpoat: "blai"
17:06:05 <Cale> > succ "blah"
17:06:06 <lambdabot>  add an instance declaration for (Enum [Char])
17:06:06 <lambdabot>   In the definition of `rlz': rlz = succ "blah"
17:06:06 <lambdabot>   In the definition of `yhjulwwiefzojcbxybbruweejw':
17:06:16 <ihope_> yhjulwwiefzojcbxybbruweejw eh?
17:06:24 <Saulzar> Nice :)
17:06:32 <goltrpoat> oh i guess the lexicographical ordering is a total ordering, huh.  nevermind
17:06:33 <M3wkuskerekHarc> :))
17:06:34 <ihope_> @remember lambdabot In the definition of `yhjulwwiefzojcbxybbruweejw':
17:06:35 <lambdabot> Unknown command, try @list
17:06:49 <tnks> I think I need a little assistance reading a type definition.
17:07:03 <palomer> pfft
17:07:04 <ihope_> tnks: what is it?
17:07:15 <tnks> I've intuited what definitions like (Show a) => ... is all about.
17:07:38 <tnks> but now I'm dealing with some OOHaskell code and it's got: (HRLabelSet (HCons (a, b) r)) => ...
17:07:47 <tnks> How do I read that?
17:08:24 <ihope_> If (HCons (a, b) r) is in the class HRLabelSet, then...
17:08:25 <Cale> The type HCons (a,b) r must be an instance of the class HRLabelSet
17:08:38 <ihope_> I win. :-P
17:09:01 <tnks> ihope_: Cale: thanks.
17:11:22 <toste> whats a high order function ?
17:11:35 <Saulzar> A function taking other functions as arguments
17:11:36 <RyanT5000> a function whose arguments or return types are functions
17:11:51 <ihope_> But then a curried function is a higher order function, so...
17:11:54 <palomer> Cale: why do you think that [Char] isn't an instance of Enum?
17:11:59 <palomer> and why is Int an instance of Enum?
17:12:00 <toste> foo x = foo2 x
17:12:04 <toste> thats high order ?
17:12:17 <toste> int is a number
17:12:22 <RyanT5000> no (unless you count currying)
17:12:31 <ihope_> Well, it's polymorphic.
17:12:32 <RyanT5000> but foo x y = x y is
17:12:44 <toste> hum
17:12:52 <RyanT5000> where x is a function, e.g. Int -> Int, and y is an appropriate argument for x, e.g. Int
17:12:55 <toste> wheres the function in that ?
17:13:07 <toste> ok
17:13:18 <Cale> palomer: Well, I suppose that you could have an instance of Enum [a] when you have instances of Bounded a, Enum a.
17:13:28 <Cale> But it's often not too useful an instance
17:14:09 <toste> what do we use Bounded for ?
17:15:02 <toste> i know a Int is bounded and Integer isnt, but i don't really see the point
17:17:56 <ihope_> It's so you have minBound and maxBound :-P
17:18:20 <ihope_> You can also do stuff like [minBound..maxBound]
17:21:21 <sethk> toste, the point is that if you need values outside those boundaries, the type won't give you the results you are expecting
17:35:48 <ihope_> That ended pretty darn abruptly.
17:38:34 <tnks> How do I read "class HReverse l1 l2 | l1 -> l2, l2 -> l1"?
17:38:49 <tnks> The pipe and comma are new to me.
17:39:13 <tnks> I think the pipe is just to show a variant.
17:39:46 <cpatrick> tnks: it's a GHC extension
17:39:51 * cpatrick finds some docs
17:40:05 <tnks> cpatrick: oh... interesting.
17:40:11 <tnks> no wondering it was stumping me.
17:40:22 <tnks> cpatrick: I appreciate your help.
17:40:50 <tnks> does it have to do with allowing overlapping instances?
17:40:53 <cpatrick> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#functional-dependencies
17:41:02 <tnks> thanks.  Looking into it now.
17:41:25 <cpatrick> (that page links to a research paper written by a Simon and says "There should be more documentation, but there isn't (yet). Yell if you need it.")
17:44:23 <ihope_> A gush of water hits the lichen's left mycelium!
17:44:29 <ihope_> What's a mycelium?
17:44:41 <ihope_> And why am I asking this in #haskell instead of #nethack?
17:46:48 <dons> Igloo, code based on elemIndexLast
17:47:02 <dons> it was finding the last index by searching from the start of the string, not the end.
17:47:08 <dons> it also had a space leak
17:47:55 <dons> so any code using: breakLast, elemIndexLast, elemIndexLastWord8
17:48:57 <Igloo> Ah, right
17:52:59 <lispy> dons: what about breakOn?
17:53:38 <dons> Igloo, do you have any opinion on John Meacham's request to remove all 'Char' references from FPS? Since there's an implicit cast down to byte happening.
17:54:09 <dons> lispy: -- | 'breakOn' breaks its 'ByteString' argument at the first occurence
17:54:10 <dons> -- of the specified character. It is more efficient than 'break' as it
17:54:10 <dons> -- is implemented with @memchr(3)@. I.e.
17:54:10 <dons> -- 
17:54:12 <dons> -- > break (=='c') "abcd" == breakOn 'c' "abcd"
17:54:15 <dons> --
17:54:17 <dons> breakOn :: Char -> ByteString -> (ByteString, ByteString)
17:54:20 <dons> breakOn c p = case elemIndex c p of
17:54:24 <dons>                     Nothing -> (p,empty)
17:54:27 <dons>                     Just n -> (take n p, drop n p)
17:54:28 <dons> {-# INLINE breakOn #-}
17:54:29 * Igloo rereads what dons said and wonders what the space leak was
17:54:30 <dons> :)
17:54:33 <dons> so it doesn't go from the end.
17:54:56 <dons> oh, it was n't strict in the recursive loop
17:55:11 <dons> so when I strictified it, the index counters get turned into Int#
17:55:21 <Igloo> He was really saying the current Char functions should be moved to mumble.Latin1, right? Sounds reasonable to me
17:55:21 <dons> and it goes from 0.7s to 0.03s
17:55:47 <dons> Ah. I see what you mean.
17:56:22 <dons> I just want under no cicumstances for the casting to Word8 to be floated out to the users.
17:56:49 <ihope_> @kind () => a
17:56:51 <lambdabot> *
17:57:20 <dons> but it's already called 'ByteString'... just moving those functions into Something.Latin1 doesn't change anything, does it?
17:57:23 * Igloo can't see what the code in darcs isn't strict in, but I have a feeling I've seen GHC not behave as I'd expect with the h parameter in similar cases in the past
17:57:52 <dons> I rewrote the loop as: 
17:58:14 <dons>     STRICT2(go)
17:58:14 <dons>     go p i | i < 0     = return Nothing
17:58:14 <dons>            | otherwise = do ch' <- peekByteOff p i
17:58:14 <dons>                             if ch == ch'
17:58:14 <dons>                                 then return $ Just i
17:58:16 <dons>                                 else go p (i-1)
17:58:19 <Igloo> dons: I think the users you're thinking of should be using Something.Latin1
17:58:55 <dons> so this doesn't really change any typesafety. it's just a conventional thing.
17:59:02 <ihope_> Aha! If n is a countable infinity, then 2^n is uncountable!
17:59:23 <dons> currently I have "Data.ByteSTring - a library for latin1 strings"
17:59:51 <lispy> ihope_: yup, but is 2^n the same size as R (the real numbers)?
17:59:55 <dons> but you think it needs to be more clearly separated, the functions that implicitly coerce?
18:00:03 <dons> what about functions on String? like pack?
18:00:04 <ihope_> lispy: yes
18:00:05 <Igloo> The above shouldn't leak without the STRICT, though. It's strict in i anyway, and p is passed through unchanged. It'll probably get a little faster if it makes the difference between p being unboxed or not, though
18:00:18 <lispy> ihope_: really?  you have proof?
18:00:19 <Igloo> (which it would due to the first case)
18:00:38 <dons> the actual function in darcs takes 4 args, iirc, and performed much more slowly.
18:00:51 <lispy> dons: thanks for the answer about breakOn, I shoudl have read what you said more closely
18:00:53 <Igloo> dons: I think that's what he is saying, yes
18:00:53 <ihope_> lispy: a real number can be respresented uniquely as a function from some countably infinite type to a finite one, and vice versa.
18:01:23 <ihope_> The number of such functions is m^n, where n is the countable infinity, and m is the number of values in the finite type
18:01:42 * Igloo wonders if cache read-ahead understands reading things backwards
18:02:02 <lispy> ihope_: let's call the size of the countable infinity aleph_0
18:02:06 <Igloo> String is in the same boat as Char IMO
18:02:15 <ihope_> Okay.
18:02:16 * araujo back from dinner
18:02:37 <lispy> ihope_: so we know that if we take the power set, we always get a bigger set right?
18:02:51 <ihope_> Wait, just a second...
18:03:00 <ihope_> Then type(n) could be a type with n as the number of values, and values(n) would be the number of values of type n.
18:03:14 <dons> Igloo, ok. If both you and John are of this mind, I better do someting about it.
18:03:16 <ihope_> values(type(e) -> type(b)) -> b^e
18:03:21 <ihope_> s/->/=/
18:03:29 <ihope_> The second ->, that is.
18:04:16 <lispy> ihope_: http://en.wikipedia.org/wiki/Continuum_hypothesis
18:04:28 <lispy> ihope_: the question i asked  you cannot be proven
18:04:40 <Igloo> dons: I think it would be confusing once we have a utf-8 layer on top for the Latin-1 layer to be in the "core"
18:04:53 <dons> right.
18:05:30 <dons> Simon had Data.PackedString.{Latin1,UTF8,...} 
18:05:45 <dons> so presumably here we'd have Data.ByteString with Word8 and ByteString ops
18:06:00 <dons> and then Data.PackedString.Latin1 or something, giving Char ops
18:06:54 <lispy> ihope_: hopefully, i've sparked your curiousity about the continum hypothesis...if so, next go read about the axiom of choice...it's mind openning stuff
18:07:13 <dons> Igloo, or can you think of a nicer way to partition things? a better name?
18:07:47 <Igloo> Sounds fine to me
18:10:28 * Igloo vamooses
18:10:43 <dons> ciao
18:12:06 <lispy> ihope_: i feel like the analysis of infinities is one of the hardest parts of math
18:12:20 <lispy> ihope_: and yet...it's everywhere in math
18:12:32 <ihope_> > 1/0 == 1/0
18:12:33 <lambdabot> True
18:12:37 <ihope_> :-)
18:12:40 <lispy> hehe
18:16:58 <dons> lispy, do you want to have a look at my replacement for elemIndexLast in darcs?
18:27:20 <palomer> are there typeclasses for converting to and from integers?
18:27:53 <sjanssen_> palomer: toInteger and fromIntegral ?
18:30:11 <palomer> hrmph, not many types implement it
18:30:21 <palomer> what functions need I implement for Enum?
18:30:33 <lispy> dons: i've looked at porting FPS into darcs before and been intimidated by the difference in conventions between darcs FPS and current FPS
18:31:18 <dons> previously, I've only selectively ported functions I know to be widely used in darcs, and definitely faster
18:31:25 <dons> rather than doing the wholesale change
18:31:27 <sjanssen_> palomer: I believe toEnum and fromEnum is the minimal complete definition
18:31:28 <lispy> dons: it certainly needs to happen though.  Is your new code your FPS repo?
18:31:32 <dons> i.e. we did compare that way.
18:31:43 <dons> lispy, yes. but it will be in base/ soon enough.
18:31:50 <lispy> dons: ah, that's a good idea
18:31:54 <tnks> Why isn't upcasting allowed?  For instance... test::a; test = "a"
18:31:59 <tnks> Isn't upcasting safe?
18:32:26 <tnks> I get a error about matching a "rigid variable".
18:32:27 <dons> hmm.
18:32:47 <dons> "a" is more specific thatn 'a' , so you generate a type constraint, and it just won't work
18:32:55 <dons> you can write polymorphic functions though, that'll happily take an "a"
18:33:03 <lispy> dons: i need start packing, so i'm not sure if this week is good for me
18:33:14 <dons> > let f :: a -> a ; f a = a in f "a"
18:33:15 <lambdabot> "a"
18:34:30 <dons> > let f :: Int -> Bool ; f a = True in f -- just a little game
18:34:32 <lambdabot> <Int -> Bool>
18:34:34 <dons> good bot!
18:34:44 <lispy> cool
18:35:04 <tnks> huh.
18:35:05 <araujo> cool 
18:35:06 <lispy> > let f :: a -> a; f a = a in f
18:35:07 <lambdabot> Add a type signature
18:35:16 <lispy> hm...
18:35:21 <dons> doesn't work on polymorphic values
18:35:24 <araujo> hah
18:35:40 <dons> due to this: http://www.cse.unsw.edu.au/~dons/code/lambdabot/scripts/ShowQ.hs
18:35:45 <lispy> > let f :: a -> a; f a = a in f :: a -> a
18:35:46 <lambdabot> Add a type signature
18:36:01 <dons> but, we _could_ extend it, by using TH to find the type at compile time, and thus genreate a custom Show instance for that function
18:36:18 <dons> > [|t a -> a |]
18:36:18 <lambdabot>  parse error on input `->'
18:36:24 <dons> > [|t forall a -> a |]
18:36:25 <lambdabot>  parse error on input `->'
18:36:28 <dons> > [|t forall a . a -> a |]
18:36:29 <lambdabot>  parse error on input `->'
18:36:31 <dons> grr
18:36:32 <lispy> i'm surprised that it still dosen't work even with all my type signatures
18:36:34 <araujo> tnks, the nearest thing you can get (afaik) is something like this:
18:36:50 <araujo> > let f :: Num a => a ; f = id 2
18:36:51 <lambdabot>  parse error on input `}'
18:36:59 <dons> doesn't work on polymorphic values, lispy. Typeable only hoilds for monomorphic thingies
18:37:12 <araujo> mm...
18:37:14 <dons> no classes, no poly nothings.
18:37:21 <araujo> ouch
18:37:25 <lispy> dons: yeah, i just got mislead between you saying that and the error message
18:37:32 <araujo> SoC material :-]
18:37:54 <dons> araujo: possibly PhD material
18:38:00 <araujo> haha
18:38:10 <dons> writing a polymorphic Typeable is hard hard hard. you need to do unification at runtime..
18:38:28 <dons> hmm, which makes me thing there's actually a typeOf in hs-plugins...
18:38:30 * dons goes to check
18:38:35 <lispy> but it would be very nice for all the dynamic typers in the world wouldn't it?
18:39:04 <araujo> i think it would, but, at what cost?
18:39:17 <lispy> oh you realists
18:39:22 <araujo> hah :-]
18:39:26 <lispy> :)
18:40:05 <dons> the cost would be adding the type checker    to the runtime system, imo.
18:40:15 <dons> and then fromDynamic would involve a full type check 
18:40:41 <dons> hs-plugisn actually does this in its pdynload (polymorphic-dynamics load)
18:40:50 <dons> but by calling ghc itself at runtime to do the check.
18:41:15 <dons> and instead of using a TypeRep, it uses the type representation stored in the .hi file
18:41:47 <dons> its an interesting problem and we don't have a good solution yet. but we're getting there, I guess.
18:43:23 <dons> ah! I actually wrote some TH code to do this:
18:43:24 <dons> thTypeOf :: Q Exp -> Q Exp
18:43:24 <dons> thTypeOf qexp = qexp >>= typeOf'
18:43:24 <dons>     where
18:43:24 <dons>         typeOf' :: Exp -> Q Exp
18:43:27 <dons>         typeOf' (VarE nm) = do
18:43:29 <dons>             info <- reify nm
18:43:32 <dons>             case info of 
18:43:34 <dons>                 (VarI _ ty _ _) -> do v  <- dyn "_x" ; return $ SigE v ty
18:43:37 <dons>                 _               -> error "Not variable info"
18:43:41 <dons> ok, so maybe this can be done. 
18:43:42 * dons hacks
18:44:13 <araujo> hah
18:45:52 <lispy> dons: if the paste is more than 3...oh never mind ;)
18:45:54 <palomer> what's the function StateT r m s -> m s?
18:46:12 <dons> sorry. I thought the code was cool :$
18:46:23 <lispy> what's the state of RMS? eh...i dunno, he's probably working on emacs :)
18:46:27 <lispy> dons: i'm just teasing, i really don't mind
18:52:05 <metaperl> "The sequence function takes a list of monadic computations, executes each one in turn and returns a list of the results" -- one problem with this assertion is that sequence uses foldr, which means it executes the last function in the list first... it doesnt really execute them in sequence does it?
18:53:07 <dons> it must
18:53:13 <dons> otherwise the world woudl be crazy
18:53:18 <dons> sequence ms = foldr k (return []) ms
18:53:18 <dons>         where
18:53:18 <dons>           k m m' = do { x <- m; xs <- m'; return (x:xs) }
18:54:03 <dons> all the side effects (i..e putChar) would come out in the wrong order, no?
18:54:35 <metaperl> I skipped the section on do notation in the nomaware tutorial. it looks like I need to go back to it... I didn't like do-notation
18:54:58 <dons> it's just folding bind through the list of actions, creating a single action
18:54:58 <monochrom> Do you like >>= instead? XD
18:55:08 <metaperl> yes
18:55:11 <lispy> metaperl: start with the transformation between do notation of function notation then ;)
18:55:14 <monochrom> hee hee hee
18:55:16 <dons> that when eventually evaluated, will still produce a bunch of actions in the wrright order
18:55:22 <dons> sequence_ ms     =  foldr (>>) (return ()) ms
18:55:36 <dons> see, it's just gluing the actions together with >> in this csae
18:55:37 <monochrom> Do you like list comprehension (the notation, I mean)
18:55:51 <metaperl> yes I like list comprehension notation
18:55:54 <dons> and it doesn't matter in which order you do the gluing
18:55:59 <goltrpoat> i still wish monad comprehension hadn't been dropped
18:56:01 <metaperl> also, >> is new to me. I have only seen >>=
18:56:01 <goltrpoat> it looks so elegant.
18:56:04 <monochrom> The two notations are not too different.
18:56:36 <lispy> goltrpoat: yeah, i wasn't around back then, but it sounds like it was really nice for hackers confident with types and error messages
18:56:38 <monochrom> [ f x | y <- blah, x <- stuff ] = do { y <- blah; x <- stuff; return (f x) }
18:57:15 <monochrom> This equality works for list.  But if you imagine there were also "monad comprehension", this equality would hold for all monads too.
18:57:17 <metaperl> really? they areexactly equivalent?
18:57:21 <lispy> the thing that confused me was the difference in syntax with 'let' in do notation vs. out of do notation
18:57:57 <metaperl> the do notation looks like it containerizes a single result of f x not all of them
18:58:03 <metaperl> but I guess you just have to know how to read it
18:58:37 <lispy> in the list monad it's bind that weaves the values around
18:59:03 <lispy> so in some sense x is just one value...but it's one value several times because of bind
18:59:15 <monochrom> Phil Wadler wrote a paper explaining monads and advocating the "monad comprehension" notation, i.e., permitting [ f x | y <- blah, x <- stuff ] for all monads.  While the paper was among those beloved by students of monads, the notational suggestion didn't take off.
18:59:17 * lispy probably made no sense with taht
19:00:35 <metaperl> I wonder if Wadler's "The Essence of Functional Programming" would make monads clear to me
19:01:01 <metaperl> nah, I will re-read nomaware's tutorial from the start more closely
19:01:15 <monochrom> I learned monads from Wadler papers.
19:01:25 <Korollary> me too
19:01:28 <Philippa> metaperl: the obvious "runList" function's either head or id, depending on what you want the list to represent...
19:01:30 <goltrpoat> i still think hutton and meijer's paper is probably the best roundabout introduction to monads
19:01:41 <goltrpoat> (the parser combinators one i mean)
19:01:56 <metaperl> goltrpoat: URL?
19:02:00 <Philippa> I should finish off that part-done article I've got floating around the TMR wiki
19:02:05 <metaperl> monochrom: which Wadler paper?
19:02:13 <Philippa> metaperl: www.google.com. Or possibly www.cs.nott.ac.uk/~gmh/
19:02:14 <metaperl> Philippa: I dont know what your comment relates to?
19:02:34 <Philippa> list/monad comprehensions and lists having 'multiple return values'
19:03:39 <goltrpoat> hey philippa
19:03:59 <Philippa> 'lo
19:04:01 <lispy> goltrpoat: yeah, i had a professor that use parser monads to explain how monads work.  Besides the list monad it was the main example he gave us.  Even though I still struggle with parser monads at times, I tihnk it help a lot
19:04:10 <Philippa> I shouldn't be in here too long, I'm knackered, but how goes?
19:04:29 * lispy goes off to lookup knackered
19:04:39 <Philippa> parsing monads sure help you realise there's a wider range of stuff you can do with monads than you might expect
19:04:45 <Philippa> "tired", in this case
19:04:53 <lispy> ah
19:04:58 <lispy> i figured, but it's a new word :)
19:05:10 <monochrom> I think some tutorials on the web (such as nomaware) makes things too metaphysical, too for-dummy, too mysterious, all at the same time.  (When you try to assume dumb readers, when you try not to call a shovel a shovel, you achieve that.)  Wadler's papers are direct, bottomline.  I think I read most of his monad papers.
19:05:11 <mux> I like the Maybe monad to maybe chain comptuations
19:05:19 <mux> found it quite valuable to understand monads too
19:05:26 <dons> lispy, its a good pom/aussie-ism, ya drongo.
19:05:47 * mux has read the whole Wadler's page too
19:05:58 <mux> great
19:06:06 <goltrpoat> eh it goes
19:06:29 <lispy> dons: hehe, more new words.  Yeah dictionary.com says it's "Chiefly British"
19:07:06 <lispy> dons: i'm a bird?
19:07:34 <dons> pretty common down here. as in "Streuth, I'm knackered. Where's the beer?"
19:07:44 <dons> a bird? ah, a dodo. no.
19:08:10 <dons> drongo == silly person.
19:08:13 <lispy> mux: i struggle with the Maybe thing...i thought the list monad was for chaining computation...or maybe it's for non-deterministic (and thus in parallel not serial) computation
19:08:18 <Philippa> lispy: careful, you'll have somebody ASLing you if you announce that
19:08:33 <dons> hehe
19:08:33 <lispy> dons: http://dictionary.reference.com/search?q=drongo
19:08:46 <mux> lispy: the definition of (>>=) for the Maybe monad makes it very clear
19:08:58 <Philippa> all monads "chain computations"
19:09:02 <Philippa> that's what >>= /does/
19:09:07 <mux> binding lists is much more "weird" to me, and of less usefulness
19:09:08 <lispy> Philippa: why would they want to know my age and sex?  /me gets confused
19:09:15 <dons> lispy, that's not  the real definition!
19:09:24 <mux> yeah, the Maybe monad just maybe chains stuff
19:09:26 <dons> let me find it...
19:09:50 <Philippa> lispy: you missed out the location part. Usually with the intention of moving their location (or at least their cyber-location) to your underwear...
19:10:04 <lispy> heh
19:10:11 <dons> ?google aussie slang drongo
19:10:13 <lambdabot> http://www.aussieslang.com/features/australian-slang-basics.asp
19:10:15 <dons> something like that.
19:10:32 <lispy> Philippa: as a boy i find that people are rarely excited about relocating to my underwear...
19:10:48 <Philippa> and that'd be why people want to ask your sex ;-)
19:10:56 <lispy> heh
19:11:08 <lispy> dons: cool link
19:11:19 <Philippa> I'd almost say I'm agnostic about guys if I weren't going out with two of 'em...
19:11:26 <monochrom> You speak to the wrong group of people.
19:11:31 <lispy> you're going out with two guys?
19:11:42 <lispy> no wonder you're knackered
19:13:05 <sethk> Philippa, don't they get in each others' way?
19:13:14 <wchogg> ...wait, agnostic about guys?  You're unsure to their existence?
19:13:17 <Philippa> sethk: in what sense?
19:13:27 <lispy> Philippa: hehe, that's what i wanted to know
19:13:36 <Philippa> wchogg: I was unsure as to the existance of guys I'd actually want to go out with until I found myself doing so
19:13:36 <sethk> Philippa, well, you know, there are some things only available in limited quantities ...
19:13:40 <araujo> 0_o
19:14:01 <Philippa> I think we should drag this into #haskell-blah though, it seems to be derailing the on-topic convo
19:14:07 <lispy> heh
19:14:10 <lispy> true
19:14:33 * araujo joins #haskell-blah
19:14:59 <araujo> ;-)
19:15:47 <sethk> hey, 50 people just joined haskell-blah!  :)
19:15:54 <sethk> I think that belongs over there ...
19:15:58 <palomer> blah!
19:16:02 <palomer> grr
19:16:05 <palomer> woof
19:16:33 <sjanssen_> @palomer
19:16:34 <lambdabot> hrmph
19:16:44 * palomer thinks [Char] should be an instance of Integral
19:16:46 <palomer> who's with me?
19:17:08 <dons> everything should be an instance of everything!
19:17:16 <dons> if only I could get my ByteString functor writtenn..
19:17:40 <palomer> ok, there should at least be a typeclass for converting to and from integer
19:17:43 <palomer> since everything is countable
19:17:54 <palomer> well, most things
19:17:57 <dons> yeah, this has been suggested before.
19:17:59 <goltrpoat> palomer:  people who can imagine a reasonable answer to the query "numerator" `div` "denominator" ?
19:18:18 <palomer> dons: and...?
19:19:26 <Korollary> should [Bool] be an instance of integral too?
19:19:28 <sethk> [Char] an instance of Integral?  Char I can see, but [Char]?
19:19:47 <sethk> I guess I don't understand the concept
19:20:05 <sjanssen_> palomer: what is the definition of countable?
19:20:19 <araujo> > length "hello"
19:20:20 <lambdabot> 5
19:20:22 <araujo> :-P
19:20:31 <palomer> a set S is said to be countable if there exists an injection from S into the naturals
19:20:59 <sjanssen_> okay, that's what I assumed
19:21:00 <araujo> How would you inject a Set of Chars into it?
19:21:19 <palomer> it's not very hard
19:21:29 <palomer> how big is a char?
19:21:38 <palomer> (an injection was written earlier)
19:22:00 <sjanssen_> what is the practical use of such a function for Double ?
19:23:58 <palomer> well, you get a well ordering 
19:24:09 <palomer> so if you have a value of [Double], you can assign a least element
19:24:18 <sjanssen_> we already have Ord for that
19:24:30 <palomer> true
19:24:42 <palomer> ok, it isn't useful for floating point types
19:25:08 <sjanssen_> okay, what is the use for String?
19:25:33 <palomer> very useful
19:25:34 <goltrpoat> what on earth is the motivation for making [Char] an instance of Integral anyway
19:25:47 <metaperl> a container is descriptive meta-data which allows you to direct the flow of your monadic computation
19:25:54 <palomer> right now I'm working with types, my type variables are strings
19:26:05 <palomer> I went to translate my types into ST, work with them in ST, then translate back
19:26:24 <palomer> s/went/want
19:26:30 <goltrpoat> does "abcd" + "abcd" make sense as "bdfj" or "abcdabcd" ?  if the latter, then your bijection just got tricky
19:27:20 <palomer> no, it wouldn't be the latter
19:27:52 <sjanssen_> what's wrong with using strings inside ST?
19:28:55 <palomer> the whole point of ST is that my type variables become references
19:28:58 <palomer> much more useful
19:29:43 <palomer> ok, that's it, I'm writing a Countable typeclass
19:29:46 <sjanssen_> sure, that makes sense, but how is it easier to turn Integers into references than Strings into references?
19:29:51 <palomer> how big is a Char?
19:30:05 <palomer> sjanssen_: my references are indexed by integers
19:30:40 <sjanssen_> > maxBound :: Char
19:30:41 <lambdabot> '\1114111'
19:31:01 <sjanssen_> > ord (maxBound :: Char)
19:31:02 <lambdabot> 1114111
19:31:43 <sjanssen_> > succ maxBound :: Char
19:31:45 <lambdabot> Exception: Prelude.Enum.Char.succ: bad argument
19:32:31 <Cale> > log 1114111 / log 2
19:32:32 <lambdabot> 20.087461546321563
19:33:01 <sjanssen_> Cale: forget about logBase?
19:33:19 <palomer> @logs
19:33:20 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
19:33:28 <sjanssen_> > succ $ pred $ maxBound :: Char
19:33:29 <lambdabot> '\1114111'
19:33:55 <Cale> sjanssen_: just didn't think to use it
19:34:05 <sjanssen_> > chr $ succ $ ord maxBound
19:34:07 <lambdabot> Exception: Prelude.chr: bad argument
19:37:15 <goltrpoat> palomer:  i'm mildly confused..  lexicographical ordering gives you a bijection to N.  this makes sense for Enum and Ord.  it makes sense that you would not want to define this globally because different tasks require different orderings on strings, but let's forget about that for now.  why would you want to extend it to Integral and say that "d" `div` "b" is "b" ?
19:38:59 <monochrom> he probably doesn't care about what div does.
19:39:06 * palomer high fives monochrom
19:39:16 <goltrpoat> mul?
19:39:17 <goltrpoat> add?
19:39:18 <goltrpoat> sub?
19:39:24 <Cale> treating [Char] as numbers written base 1114112 seems like an unusual thing to do
19:39:38 <sethk> Cale, mildly unusual  :)
19:39:43 <sethk> I guess I still don't get the point
19:40:21 <sethk> although 1114112 is an attractive number ...
19:40:58 <palomer> I only care about a mapping to and from Int
19:41:16 <metaperl> how would you model a Camel which could have 2 or 3 humps? prolly a tuple would come into play....
19:41:35 <metaperl> data Camel = Either TwoHump a b | ThreeHump a b c
19:41:41 <metaperl> something like that
19:41:47 <goltrpoat> Integral is a division ring.  defining something to be an instance of Integral is tantamount to giving a division ring homomorphism.  there is no natural structure of that sort on [Char].  there is a natural group structure, but that's it.  i guess the question is why.
19:41:53 <Korollary> I would have a pure virtual camel class with no humps first. Then, I'd add enterprise humps using a decorator pattern.
19:41:57 <metaperl> but use tuples so you could do pattern matching and monadic chaining
19:42:12 <metaperl> Korollary: that doesnt sound like Haskell monads...
19:42:16 <Cale> goltrpoat: there's a natural group structure on [Char]?
19:42:24 <lispy> Korollary: and create your camels with a camel factory?
19:43:02 <goltrpoat> cale:  crap.  no, no inverse.
19:43:08 <Cale> Korollary: heh, the trivial camel
19:43:21 <goltrpoat> monoid, let's say.
19:43:29 <palomer> goltrpoat: Integral is certainly not a division ring
19:43:34 <palomer> look at Int
19:44:00 <palomer> actually, wait, Int is a division ring under (+,*,/)
19:44:07 <Cale> no it's not
19:44:13 <palomer> which axiom does it fail?
19:44:15 <metaperl> I was trying to make the leap from data Sheep = (name::String, mother::Maybe Sheep, father::Maybe Sheep) to camels....
19:44:17 <goltrpoat> yeah i'm losing points left and right.
19:44:20 <goltrpoat> no multiplicative inverse.
19:44:25 <palomer> oh, righto
19:44:31 <Cale> division rings are fields that are potentially noncommutative
19:44:42 <Cale> (that is, not quite fields)
19:45:05 <sjanssen_> metaperl: perhaps a good encoding is "data Camel a b c = Camel a b (Maybe c)"
19:45:08 <Cale> Integral requires toInteger
19:45:19 <metaperl> sjanssen_: very clever!
19:45:21 <metaperl> :)
19:45:34 <Cale> but other than that, the operations are suggestive of a Euclidean domain.
19:46:06 <metaperl> I like to name the type and data constructor distinctly though: data CamelType a b c = Camel a b (Maybe c)
19:47:17 <palomer> is it possible to have all types that instantiate one class instantiate another automatically?
19:47:37 <Cale> data Camel a b = Dromedary a | Bactrian a b
19:48:09 <metaperl> nice Cale
19:48:11 <Cale> palomer: you can write generic instances
19:49:11 <monochrom> type Camel = Either (Hump,Hump) (Hump,Hump,Hump)
19:49:48 <Cale> I'm not sure what kind of Camel would have 3 humps though.
19:49:54 <goltrpoat> an Objective one.
19:50:03 <Korollary> A souped-up camel
19:50:07 <Korollary> long range
19:50:15 <sjanssen_> a camel with a massive tumor?
19:50:43 <Cale> an intercontinental ballistic camel
19:50:52 <Lokadin> lol
19:51:29 <Cale> the extra 'hump' is a warhead
19:52:10 <goltrpoat> embedded by INRIA
19:52:51 <goltrpoat> ok i seem to be on a roll as far as making remarkably unamusing Caml jokes goes.
19:53:02 <palomer> is there a function Int -> Integral?
19:53:49 <Korollary> goltrpoat: I just failed to get it.
19:54:12 <goltrpoat> toInteger?
19:55:26 <Korollary> no
19:55:33 <Korollary> would be named fromInteger
19:55:52 <monochrom> @hoogle (Integral a) => Int-> a
19:55:53 <lambdabot> Data.Graph.Inductive.Example.starM :: GraphM m gr => Int -> m (gr () ())
19:55:53 <lambdabot> Data.Graph.Inductive.Example.ucycleM :: GraphM m gr => Int -> m (gr () ())
19:55:53 <lambdabot> Prelude.(!!) :: [a] -> Int -> a
19:56:51 <monochrom> @hoogle fromIntegral
19:56:52 <lambdabot> Prelude.fromIntegral :: (Integral a, Num b) => a -> b
19:57:06 <monochrom> This is general enough for  (Integral a) => Int-> a
19:59:30 <goltrpoat> Prelude> :t (toInteger 42)
19:59:30 <goltrpoat> (toInteger 42) :: Integer
20:00:38 <palomer> http://www.rafb.net/paste/results/p27tez29.html <--- gotta love the error message
20:00:42 <palomer> completely incomprehensible
20:01:14 <palomer> anyone have any hints?
20:01:52 <Korollary> you're the one writing an ms thesis on a typechecker
20:02:11 <monochrom> haha
20:02:35 <palomer> my type system doesn't have anything to do with typeclasses
20:05:44 * palomer wants more cunning newtype deriving
20:05:53 <sjanssen_> palomer: can GHC figure out how to derive Monad?
20:06:59 <palomer> nope
20:07:28 <palomer> btw, the code works without any changes
20:07:33 <palomer> err, I mean
20:07:42 <palomer> you can try and compile the code
20:07:50 <palomer> (just remove the module heading)
20:09:30 <Cale> sjanssen_: you can derive almost any class through a newtype
20:09:32 <monochrom> Unfortunately I don't know about deriving Functor.
20:09:38 <Cale> (with ghc)
20:09:50 <palomer> obviously not!
20:10:05 <Cale> Usually deriving Functor is okay
20:10:15 <palomer> well, I'm only interested in Monad really
20:10:24 <Cale> Monad too
20:10:38 <Cale> I'm not entirely sure what's happening there
20:11:35 <Cale> hmm
20:11:41 <Cale> it won't matter though
20:12:08 <Cale> since you'll never be able to runStateT
20:12:29 <palomer> why not?
20:12:36 <palomer> with the empty State
20:13:27 <Cale> hmm
20:14:34 <palomer> ie, []
20:15:13 <Cale> okay, so what does the Functor instance look like?
20:15:29 <Cale> fmap :: STI s a -> STI s b
20:15:30 <palomer> I don't really need Functor
20:15:36 <palomer> sure
20:15:46 <Cale> sure, but if you can't do functor, you have no hope of doing monad
20:16:01 <Cale> so essentially,
20:16:15 <Cale> fmap :: StateT [(Integer,STRef s a)] (ST s) a -> StateT [(Integer,STRef s b)] (ST s) b 
20:16:36 <palomer> yup
20:16:39 <Cale> er
20:16:46 <Cale> this is fmap f rather :)
20:16:56 <Cale> (I ignored the function parameter in the types)
20:17:18 <Cale> So, note that f is getting applied to the values of all the STRefs.
20:17:24 <monochrom> Perhaps it can do Functor but "deriving" doesn't know how.
20:17:56 <Cale> so you'd need to use modifySTRef on them
20:18:00 <Cale> but that gives you a computation in ST
20:18:08 <Cale> not an STRef.
20:18:10 <sjanssen_> palomer: do you really want to recreate all the STRef's every fmap or bind?
20:18:19 <goltrpoat> what happened to http://haskell.org/haskellwiki/GHC:Documentation ?
20:18:30 <palomer> sjanssen_: I would need to?
20:18:43 <goltrpoat> oh.  you need to be logged in now?
20:18:52 <Cale> It's a redirect
20:19:05 <palomer> so what you're saying is that it would be horribly inefficient to do so
20:19:07 <Cale> palomer: look carefully at the types there
20:19:27 <Cale> You have to replace all the (STRef s a)'s with (STRef s b)'s
20:19:29 <palomer> Cale: but we're working in ST anyways, no?
20:19:46 <Cale> not there we aren't
20:20:02 <sjanssen_> palomer: I'm saying that you probably want something else.  Perhaps "StateT [(Integer,STRef s MySpecificType)] (ST s) a"
20:20:29 <palomer> oh, yes, I do
20:20:32 <Cale> I'm not even sure what you'd do with bind
20:20:39 <sjanssen_> I bet that will solve all your problems
20:20:39 <palomer> actually, no, I don't
20:20:56 <palomer> nonono, I want a map from the integers to my references
20:21:09 <Cale> the references all have different types
20:21:12 <palomer> maybe there's a better way of doing it
20:21:23 <palomer> here, lemme show you what I'm doing
20:21:30 <Cale> you can't put them all in a single map
20:21:46 <Cale> unless you want to go ahead and use existential types or something
20:21:49 <palomer> ahh, good point
20:22:48 <sjanssen_> palomer: do you want to keep track of *every* reference you create, or just a special set of those references?
20:24:00 <palomer> every reference
20:24:06 <palomer> ok, here's what I'm doing
20:24:12 <palomer> I have types
20:24:22 <palomer> and my type variables are either integers or strefs
20:24:23 <Cale> palomer: if you don't care about having a global set of the available references, it's easier to store an index number together with each reference separately
20:24:59 <palomer> ie, I have (MonoType Int) and (MonoType (Tyref s))
20:25:18 <palomer> and I want to create a bijection between'em
20:25:37 <palomer> http://www.rafb.net/paste/results/OsxqVS37.html <--here's the code so far
20:28:14 <palomer> Cale: that's what STI does
20:28:21 <palomer> (stores the index with the reference)
20:28:26 <Cale> right,
20:28:27 <palomer> (it's the same STI that you wrote before)
20:28:33 <Cale> the STI that I wrote, yeah
20:28:46 <palomer> so, erm, how would I set up this bijection?
20:28:49 <Cale> that lets you go one way
20:28:55 <Cale> but you can't really go the other way
20:29:04 <palomer> up to STIness?
20:29:14 <palomer> Cale: why not?
20:29:20 <Cale> yeah, Integer -> STRef s a seems impossible
20:30:05 <palomer> it would be Integer -> STI s (STRef s a)
20:30:22 <Cale> still impossible
20:30:26 <palomer> how so?
20:30:37 <Cale> 'a' is undetermined
20:30:53 <palomer> well, yeah, here a is determined
20:31:00 <palomer> if you look at my code
20:31:01 <Cale> specifically, it would have to be dependent on the Integer you pass, but Haskell isn't dependently typed.
20:31:25 <palomer> you can assume that all my references are the same
20:31:37 <Cale> oh, okay, then it's sjanssen_'s idea asically
20:31:40 <Cale> basically*
20:31:41 <palomer> they're all references to MonoSType (Tyref s)
20:32:17 <palomer> oh my, now I have a circular module dependency issue
20:32:47 <palomer> can I just say " it's fixed " ?
20:33:00 <palomer> ie, existential quantification
20:33:01 <sjanssen_> palomer: add a type parameter to STI that represents the type of your references?
20:33:33 <Cale> you can alter STI to only construct references of that one particular type
20:33:40 <Cale> and then the problem goes away
20:34:03 <Cale> you could store a Data.Map or a list of pairs like you were doing
20:34:41 <Cale> (or at least, only keep track of references of that one type)
20:35:14 <metaperl> shapr: !
20:35:59 <palomer> > max [2,3,4]
20:36:01 <lambdabot> Add a type signature
20:36:07 <palomer> > max [2,3,4]::Int
20:36:08 <lambdabot> Couldn't match `Int' against `t -> t1'
20:36:10 <Cale> > maximum [2,3,4]
20:36:11 <lambdabot> 4
20:36:18 <Cale> > max 2 3
20:36:20 <lambdabot> 3
20:38:08 <palomer> @karma+ Cale
20:38:09 <lambdabot> Cale's karma raised to 8.
20:44:23 <palomer> whoa
20:44:29 <palomer> .
20:45:19 <dons> ?uptime
20:45:20 <lambdabot> uptime: 5 days, 2 hours, 20 minutes and 27 seconds
20:45:34 <Korollary> @seen pierre-
20:45:35 <lambdabot> pierre- is in #haskell. I don't know when pierre- last spoke.
20:45:53 <Korollary> because he has not yet heh
20:46:01 <pierre-> hello.
20:46:16 <Korollary> lambdabot should be more authoritative
20:47:05 <Korollary> hello pierre- 
20:58:48 <goltrpoat> one of the more odd quit messages in recent history.
21:00:43 <palomer> http://www.rafb.net/paste/results/L7B2kC80.html <---anyone have any ideas?
21:02:22 <palomer> nevermind
21:05:41 <Philippa> goltrpoat: a friend got a t-shirt that read "Admit it, you'd go to jail for this" on her 15th birthday (the age of consent here being 16)
21:06:17 <goltrpoat> hah
21:06:25 <Korollary> I love vanity
21:15:27 <sethk> hey, all, before my current project I'd done some work on a database engine for Haskell.  (Not an interface, an engine itself.)  Should I add this to the list of projects for the google thing you've been talking about?
21:16:31 <Philippa> Korollary: she'd had grown men hitting on her since she was 12
21:16:44 <palomer> http://www.rafb.net/paste/results/NTq2Un91.html <--I'm swimming in incomprehensible errors!
21:17:06 <sethk> Philippa, alledgedly grown
21:17:15 <sethk> Philippa, chronologically grown, perhaps
21:17:45 * Philippa nods
21:18:01 <Philippa> she certainly looked of age earlier than most, but hey
21:20:12 <Korollary> Philippa: I wasn't doubting the validity of her claim.
21:20:42 <Philippa> IIRC it was actually her mum bought the top, but hey :-)
21:24:55 <palomer> nevermind
21:29:42 <lispy> neverminding
21:31:30 <palomer> http://www.rafb.net/paste/results/1hprxj53.html  <--ok, I followed the suggestions proposed and this is what I get!
21:31:56 <palomer> Cale: ping
21:38:06 <Cale> palomer: pong
21:38:19 <palomer> any idea what could escape?
21:40:15 <Revision17> if I wanted to make a program that needed to put some simple 2d graphics on the screen, are there any libraries that are very win32 friendly (could be a gui toolkit, could be hopengl)?
21:41:32 <Cale> Revision17: you might try the HGL library (which has nothing to do with OpenGL), though I have no idea if it works under win32
21:41:53 <Cale> palomer: hmm...
21:42:17 <Revision17> Cale: well it claims to be win32 friendly; time to to some experimenting
21:42:45 <Cale> palomer: what's the type of (do toSType a; return 0) ?
21:42:57 <Cale> and the type of runSTI?
21:43:13 <Revision17> hmm, HGL doesn't seem to be activly maintained at all
21:43:29 <Cale> Revision17: it's in the GHC libraries
21:43:34 <palomer> runSTI :: (forall s. STI b s a) -> a <--the b is the thing I'm fixing
21:43:47 <Cale> Revision17: which means that it ought to be maintained along with them
21:43:51 <Revision17> Cale: ah; ok that must be why the page isn't maintained anymore
21:44:19 <goltrpoat> speaking of HGL.  runGraphics seems to open a console window, wait until it loses focus, and then open the window you're drawing in
21:44:24 <goltrpoat> which is amazingly annoying.
21:44:27 <palomer> urgh
21:44:30 <palomer> I can't even find that out
21:45:07 <palomer> I get this error http://www.rafb.net/paste/results/Era4jY50.html
21:45:37 <Cale> fromSType?
21:46:17 <palomer> http://www.rafb.net/paste/results/n0pv1H57.html
21:46:31 <palomer> ahh, righto
21:46:35 <Cale> all that error says is that the type 'a' isn't determined by context anywhere in the program
21:47:11 <palomer> so, erm, why should this matter?
21:47:26 <Cale> because it determines which instance of Countable to use
21:47:42 <Cale> and without knowing that, the compiler can't compile code for your function
21:47:47 <palomer> but this will just become a typeclass constraint
21:48:11 <Cale> not if the type 'a' doesn't appear in the type signature for the function
21:48:24 <palomer> I have to assign a type signature to this beast?
21:48:26 <palomer> my oh my
21:48:30 <goltrpoat> actually.  it opens a console window, waits until it loses focus, and then (apparently) puts any further processing into a badly written idle loop for the wndproc, because it only does processing when you're sending a message to the window (eg, moving a mouse over it)
21:48:33 <Cale> not necessarily
21:49:02 <Cale> but if the type variable isn't visible from the type of your function, then you have an ambiguity
21:49:11 <Cale> > (show . read) "1"
21:49:12 <lambdabot> Add a type signature
21:49:16 <Cale> like that
21:49:24 <palomer> http://www.rafb.net/paste/results/NqpnB822.html
21:49:26 <Cale> @type (show . read)
21:49:28 <lambdabot> String -> String
21:49:56 <Cale> It's String -> String, so the type that 'read' reads isn't apparent
21:50:19 <palomer> Cale: it should be infered
21:50:55 <Cale> It obviously can't be
21:51:13 <palomer> oh, righto
21:51:15 <palomer> in this case
21:51:25 <palomer> okok
21:51:50 <palomer> I was using the wrong function anyways, it's toSType we're interested in
21:53:13 <Cale> It looks like s is still forall'd in the type of blump'
21:54:01 <Cale> oh, hmm
21:54:15 <Cale> there are constraints appearing there which are questionable
21:55:12 <Cale> like that Monad instance constraint
21:55:52 <palomer> the whole type looks questionable
21:57:31 <Cale> If that thing really was an instance of Monad already, then it wouldn't appear in the context
21:57:58 <Cale> (do r <- newSTRef 0; writeSTRef r 1; readSTRef r) :: (Num a) => ST s a
21:58:02 <Revision17> sorry for the bother, but I'm trying to get the "hello world" hgl sample all linked and stuff; I'm already using -lHSHGL and -lHSWin32, but HSWin32 is having issues with some unresolved things.  What do I have to link that against?
21:58:44 <Cale> Revision17: you just use --make or -package hgl, I think
21:58:48 <palomer> but it is a monad
21:58:51 <palomer> newtype STI b s a = STI { unSTI :: StateT [(Integer,STIRef s b)] (ST s) a }
21:58:51 <palomer>     deriving (Functor, Monad)
21:58:52 <Cale> (let me check the package)
21:58:54 <palomer> proof by newtype
21:59:01 <Revision17> Cale: oh wow
21:59:03 <Revision17> that works
21:59:04 <Revision17> :)
21:59:58 <Cale> hang on
22:00:12 <Cale> hmm
22:01:44 <Cale> no, that's fine, okay
22:02:57 <Cale> @type do x <- (+1); return x
22:02:59 <lambdabot> forall a. (Num a) => a -> a
22:03:04 <Cale> hehe
22:03:08 <Cale> okay
22:03:24 <Cale> see, if Control.Monad.Reader isn't loaded, you get
22:03:28 <Cale> do x <- (+1); return x :: (Num a, Monad ((->) a)) => a -> a
22:03:41 <palomer> whoa that's weird
22:03:49 <Cale> The Monad constraint is generated because it doesn't have an instance
22:04:00 <palomer> but STI is loaded
22:04:04 <Cale> but with Control.Monad.Reader, the constraint is satisfied
22:04:17 <palomer> and an instance is derived in STI
22:04:18 <kolmodin> morning!
22:04:22 <Cale> hmm
22:05:33 <Cale> do an ":info STI" and see if the instance shows up
22:06:51 <palomer> http://www.rafb.net/paste/results/NkAYOt79.html
22:07:35 <Cale> oh, interesting
22:07:42 <Cale> :m + Control.Monad.State
22:07:51 <Cale> and then do the :info again and see if it's changed
22:08:31 <Cale> (in the end, it shouldn't matter, I'm just curious as to why it's not reducing those constraints)
22:08:44 <palomer> http://www.rafb.net/paste/results/1IaUQv73.html
22:09:23 <Cale> hmm, basically the same
22:10:08 <palomer> morning kolmodin 
22:10:26 <Cale> palomer: and if you also import Control.Monad.ST ?
22:10:50 <palomer> http://www.rafb.net/paste/results/HZ8Zvl25.html
22:10:52 <Cale> (I'm looking to see if the additional Monad constraint goes away on the Monad instance for STI)
22:11:02 <palomer> do you want STI.hs?
22:11:34 <Cale> anyway, that ought not to be the problem
22:12:06 <Cale> sure -- what's your current error message?
22:12:50 <palomer> http://www.rafb.net/paste/results/PSqHZb61.html
22:13:08 <palomer> http://www.rafb.net/paste/results/mILkUD95.html <---STI
22:15:26 <Cale> palomer: what's the type it gives just for the do-expression there?
22:16:33 <Cale> normally that kind of error would imply that an STRef is escaping or something, but that obviously isn't the case here
22:16:47 <palomer> http://www.rafb.net/paste/results/0NzcmK91.html
22:17:21 <Cale> oh, that's with the runSTI deleted?
22:17:43 <palomer> yeah
22:17:50 <Cale> oh hey
22:17:58 <Cale> s appears in b
22:18:18 <palomer> yeah
22:18:20 <palomer> you didn't know?
22:18:28 <Cale> runSTI :: (forall s. STI b s a) -> a
22:18:34 <Cale> or more specifically
22:18:41 <Cale> runSTI :: forall a b. (forall s. STI b s a) -> a
22:18:42 <palomer> oh, s can't appear in b
22:19:20 <Cale> not with that type for runSTI
22:19:22 <palomer> hrmph
22:19:24 <palomer> how do i fix it?
22:19:44 <palomer> I don't want to put the exact type of b, since I would have to use mutually recursive modules
22:20:33 <Cale> ugh, hmm
22:24:01 <palomer> there's no way, eh?
22:24:16 <Cale> Heh, maybe don't use ST?
22:24:48 <palomer> just use a simple list?
22:24:49 <Cale> though if you really need polymorphic references like that..
22:24:59 <palomer> oh, I don't
22:25:06 <palomer> my references are all the same
22:26:14 <Cale> You could just use something like a Map or a list to maintain the association them
22:26:16 <Cale> then*
22:26:26 <palomer> yeah, that's what I might end up doing
22:26:28 <palomer> hrmph
22:26:41 <palomer> or learn how to code mutually recursive modules
22:26:45 <palomer> or just dump the file into the other
22:27:02 <palomer> anyways, gotta run
22:27:03 <palomer> thx!
22:29:51 <palomer> wait, I have it
22:29:58 <palomer> newtype STI b s a = STI { unSTI :: StateT [(Integer,STIRef s (b s))] (ST s) a }
22:30:02 <palomer> what do you think?
22:31:50 * palomer runs
22:32:04 <Revision17> blarg HGL, while it compiles fine, just doesn't seem to want to do anything other than sit there silently and not do anything
22:42:31 <Cale> Revision17: are you compiling your own copy of HGL?
22:42:51 <Cale> Or are you referring to some sample program?
22:43:07 <Cale> HGL comes with GHC, so you shouldn't have to compile it yourself
22:43:11 <Revision17> Cale: no, I'm using the one included with ghc
22:43:22 <Cale> okay
22:43:26 <Revision17> the programs compile, start up, and just hang with an empty console window
22:43:39 <goltrpoat> yah.  switch focus out of the window.
22:43:41 <Cale> Revision17: someone said something about that
22:43:43 <Cale> yeah
22:43:52 <goltrpoat> [23:48] <goltrpoat> actually.  it opens a console window, waits until it loses focus, and then (apparently) puts any further processing into a badly written idle loop for the wndproc, because it only does processing when you're sending a message to the window (eg, moving a mouse over it)
22:43:56 <Revision17> goltrpoat: you mean the console window? that doesn't seem to do anythin
22:44:01 <Revision17> I tried that, based upon your comment
22:44:04 <goltrpoat> oh.
22:44:26 <goltrpoat> paste the code on rafb.net
22:44:43 <Cale> Hmm, that sounds quite broken.
22:45:03 <Cale> We really need to get some win32 maintainers for the libraries :)
22:46:10 <goltrpoat> yeah i got half a mind to just write a win32 library
22:46:32 <goltrpoat> plus bindings via FFI
22:46:33 <Revision17> http://www.rafb.net/paste/results/23dZU156.html
22:46:45 <Revision17> it's just the default hello world example
22:47:00 <goltrpoat> works fine here.
22:47:05 <goltrpoat> (compiled and ran it just now)
22:47:09 <Revision17> hmm
22:47:12 <Revision17> odd
22:48:04 <Revision17> doesn't here :-\
22:48:22 <Cale> Works fine here too, mind you, I'm on debian.
22:48:35 <Revision17> it works fine on my debian box; but not on my win32 one
22:49:38 <Cale> I wonder how well Gtk2Hs works on win32.
22:49:52 <goltrpoat> it should pop up a console window -- if you close that window, there will be no further entertainment.  if you click out of it and switch focus, it should pop up a new window.  finally, if you click on that one, it should actually draw something.
22:50:21 <goltrpoat> win32 support is remarkably ghetto.
22:50:24 <Revision17> Cale: for this program I can't go around distributing gtk with it
22:50:50 <Revision17> goltrpoat: yup, did that, nothing
22:50:53 <goltrpoat> weird.
22:50:58 <Cale> Revision17: there's also wxHaskell, though it might need extra runtime libs too
22:51:34 <Cale> there's also probably a straightforward binding to the win32 api somewhere
22:52:08 <Revision17> Cale: for win32 there is, but I'd really prefer to keep cross platform; I'll try out wxhaskell now
22:52:08 <goltrpoat> i think for UI stuff you're better off doing it in an environment that was designed for that, and just exposing drawing contexts to haskell
22:53:04 <goltrpoat> but some people might find that heretical, especially with all the "better ui through fp" stuff that's going around.
22:53:58 <Korollary> where's that going around?
22:54:35 <Revision17> goltrpoat: I don't generally care; I just want to paint stuff on a window with minimum of fuss; I'm writing a non-interactive simulation program that needs to run on windows machines (with me hopefully developing it on linux) without any big fancy libs or anything
22:54:45 <Revision17> maybe I will just do the gui in C++ and link
22:54:50 <goltrpoat> fudgets and the related papers are one thing that comes to mind, but there was more stuff.. i keep running into it
22:54:50 <goltrpoat> sec
22:56:27 <goltrpoat> google says haggis, but that's not what i was looking for.
22:58:18 <goltrpoat> crap.  i just came across a whole gaggle of papers the other day along the lines of why FP will save UI design.
22:59:25 <goltrpoat> considering i can't find it anymore, maybe it's not "going around".  -shrug-
22:59:26 <Korollary> check browser history
22:59:35 <Lokadin> why can't i do:
22:59:37 <Lokadin>    bracket
22:59:37 <Lokadin>       (sock <- listenOn (PortNumber 1111))
22:59:37 <Lokadin>       (sClose sock)
22:59:37 <Lokadin>       (manage sock)
22:59:48 <Lokadin> it complains about the <-
22:59:58 <goltrpoat> korollary:  yah that's what ive been doing for the past few minutes.  
23:00:20 <Korollary> Lokadin: what's 'bracket?
23:00:40 <Lokadin> er it's a standard haskell function
23:00:54 <Lokadin> to do actions safely
23:01:35 <Lokadin> bracket      :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
23:02:57 <Lokadin> hmmm i think i might know
23:07:09 <mwc> If I create a module (say HashTable) with a class inside (Hashable, types with a hash function), and then provide some sample instances (Say for Int, String), do I need to reference those instances in the exports list or what
23:07:17 <mwc> so that they become visible to importers of the module
23:08:23 <mwc> The report doesn't seem to give any direction on this point
23:09:19 <Lokadin> i think you do
23:09:22 <Lokadin> er one sec
23:09:41 <mwc> fwiw,Oh wait
23:09:53 <mwc> found it in section 5.4 of the report
23:10:01 <Lokadin> what report?
23:10:03 <mwc> I think I have, wasn't referenced under the export stuff
23:10:19 <mwc> http://haskell.org/onlinereport/modules.html
23:11:03 <mwc> I was looking in section 5.2
23:11:25 <Lokadin> say is there any function like sleep in haskell?
23:11:45 <mwc> hoogle for Int -> IO () perhaps?
23:11:56 <mwc> @hoogle Int -> IO ()
23:11:57 <lambdabot> Control.Concurrent.threadDelay :: Int -> IO ()
23:11:57 <lambdabot> System.Console.Readline.setCompletionQueryItems :: Int -> IO ()
23:11:57 <lambdabot> System.Console.Readline.setEnd :: Int -> IO ()
23:12:07 <Lokadin> oh wow thanks :)
23:12:19 <mwc> @hoogle (Num a) => a -> IO ()
23:12:20 <lambdabot> Prelude.print :: Show a => a -> IO ()
23:12:20 <lambdabot> Data.HashTable.delete :: HashTable key val -> key -> IO ()
23:12:20 <lambdabot> Data.IORef.writeIORef :: IORef a -> a -> IO ()
23:14:06 <mwc> Here you are
23:14:08 <mwc> http://www.haskell.org/ghc/docs/latest/html/libraries/unix/System-Posix-Unistd.html#v%3Asleep
23:15:10 <mwc> although it looks like threadDelay is what you want anyways
23:15:22 <mwc> since sleep and usleep interact poorly with concurrent stuff
23:17:10 <Lokadin> o
23:17:13 <Lokadin> what' concurrent?
23:17:39 <Lokadin> say, what i really need is to make a program that is in parts
23:17:56 <Lokadin> so like if a part of it goes down is reloaded it doesn't affect any other part
23:18:23 <Lokadin> i herd that can be done in haskell rather easily
23:18:24 <Lokadin> ...
23:18:48 <mwc> You should talk to dons 
23:19:00 <Lokadin> dons: you there?
23:19:05 <lispy> is it possible for ghc to generate a dll or shared object file full of haskell code?
23:19:06 <mwc> he's literally wrote the haskell plugable modules stuff
23:19:24 <mwc> lispy, I know it is
23:19:26 <Lokadin> but i don't need pluggable modules
23:19:34 <Lokadin> cause i don't want a core period
23:19:46 <mwc> How are you going to have stuff being reloaded?
23:20:17 <Lokadin> the different "cores" will communicate to each other, over sockets or what not
23:20:20 <mwc> do you mean seperate communicating processes?
23:20:26 <Lokadin> yea
23:20:42 <Lokadin> and i guess those would have hotpluggable software
23:20:46 <Lokadin> er modules
23:20:58 <mwc> Concurrency is haskell's "threads." It implements many of them over a single OS thread. the sleep call in that thread will therefore sleep the OS thread, and the entire program will halt
23:21:00 <Lokadin> but i need about 3 or four core parts
23:21:06 <mwc> if you're single threading, it makes no difference
23:21:18 <mwc> I'd use it just to be correct
23:21:30 <Lokadin> use what? threadDelay?
23:21:47 <mwc> lispy, I came across the details on the old haskell wiki late one night, long long ago
23:22:38 <mwc> lispy, http://www.haskell.org/hawiki/DynamicLinkingInGhc?action=highlight&value=DLL
23:22:43 <Lokadin> mwc: use what
23:23:39 <mwc> LoganH, threadDelay
23:23:54 <Lokadin> kk
23:24:00 <Lokadin> thanks, i was intending on it
23:25:29 <Lokadin> say, i was wondering what would be a way of making it so that if say one of the cores go down, and there is another core that notices and wants to bring it back up, can i bring it up, without it becoming a child process of the core that started it?
23:25:59 <Lokadin> because if it goes down then all child processes go down to right?
23:29:42 <Lokadin> can i just load it background in the shell and it wont become a child process?
23:30:46 <mwc> yeah
23:30:55 <mwc> fwiw, have a look at the System.Posix.* stuff
23:31:05 <goltrpoat> by core you mean server?  if a processor core "goes down", you have a lot more problems than getting your software to fail gracefully.
23:31:06 <mwc> 99% of the cstdlib should be availible there
23:31:46 <mwc> The question I have is why a server should ever go down
23:31:53 <mwc> You'd better have a really good reason
23:32:47 <Lokadin> to go to a new version
23:33:02 <Lokadin> or if it fails,
23:33:05 <mwc>  that's a good reason
23:33:07 <mwc> fails?
23:33:11 <mwc> As in crashes?
23:33:14 <Lokadin> yea
23:33:14 <goltrpoat> mwc:  it's typical.  imagine a build farm.
23:33:34 <mwc> Ah, fair enough
23:35:57 <goltrpoat> the behavior is very application-dependent there.
23:37:51 <goltrpoat> eg, if you have a bunch of machines serving the same thing to the same clients, that's one thing -- you don't care if a server goes down.  if you have a bunch of machines serving dedicated portions of the same thing to the same client, you care a little bit more -- if a server goes down, you need to load balance again.  if you have a bunch of servers serving different things to clients based on their state (these ten clients are d
23:39:18 <goltrpoat> presumably you have something sitting on top of the whole thing assigning connections, so it can catch a dead server and move the client over, if that's the desired functionality.
23:40:19 <Lokadin> what happens if the top goes down
23:41:07 <goltrpoat> the "top" is the proxy server, the only thing you can do is make that fully redundant
23:41:24 <goltrpoat> i don't know a ton about this, but one of our clients is an MMORPG team, so things are rubbing off here and there
23:42:26 <Lokadin> cool
23:45:24 <palomer> >:O
23:45:24 * lispy thinks MMORPG developers probably have a lot of fun challenges to solve
23:47:53 <palomer> hrmph, turns out my fix doesn't work
23:47:55 <palomer> screw this
23:48:31 <palomer> anyone know how to do mutually recursive modules?
23:48:39 <Lokadin> ?
23:48:42 <Lokadin> what you mean
23:48:58 <palomer> I have a module A which needs module B and vice versa
23:49:15 <Lokadin> so why aren't they the same module?
23:50:06 <palomer> because they're only linked precariously
23:50:16 <Lokadin> or, you could, make it so if module A sees module B down then module A will start module B
23:50:17 <palomer> in fact, there's probably a way to unlink them which would require much work
23:50:20 <Lokadin> and vice versa
23:50:28 <palomer> eh?
23:50:29 <goltrpoat> i was wondering about that myself.
23:51:02 <Lokadin> could have module C that would keep track of both of them, and make sure they are both loaded together as well
23:52:04 <goltrpoat> lokadin:  example:  module A defines a command processor, that processes commands b, c, and d, defined in modules B, C and D, where the commands need a command processor context.
23:53:05 <Lokadin> hmmm
23:53:12 <goltrpoat> lumping it all in A is dirty, and you can't come up with an overarcing module that oversees it all without fucking with the architecture.
23:53:12 <Lokadin> oh okay, that is rather odd
23:54:58 <Lokadin> but it doesn't seem to make sense, how can you need A to make A,
23:55:09 <Lokadin> that's a circular argument
23:55:13 <Lokadin> doesn't make logical sense
23:55:23 <palomer> Lokadin: you can't just create a third module to load both
23:55:30 <Lokadin> it's true
23:55:37 <Lokadin> but why would B need A
23:55:54 <goltrpoat> A provides definitions, which are based on b, c, and d.  modules B, C and D, which define their lower-case counterparts, require the definition of A.
23:56:26 <Lokadin> o okay
23:56:45 <Revision17> upon trying a variety of cross platform gui/drawing toolkits for haskell and ocaml, I think I'll use scala with AWT
23:56:49 <Revision17> :-\
23:56:52 <goltrpoat> heh
