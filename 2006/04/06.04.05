00:00:11 <rasfar> what's that word, not precisely "futile", but -- like, (+0)?....
00:01:25 <rasfar> abortive, barren, bootless, delusive, empty, exhausted, forlorn, fruitless, hollow, idle, impracticable, impractical, in vain, ineffective, ineffectual, insufficient, no dice, nugatory, otiose, profitless, resultless, sterile, trifling, trivial, unavailing, unimportant, unneeded, unproductive, unprofitable, unreal, unsatisfactory, unsubstantial, unsuccessful, useless, vain, valueless, worthless
00:02:00 <rasfar> unavailing is nice
00:12:12 <goltrpoat> rasfar:  perfunctory.
00:12:58 <rasfar> If that's really a synonym, you get the prize (for containing "functor")!!!
00:13:28 <goltrpoat> i was trying to come up with something FPish.
00:13:33 <goltrpoat> it's a synonym yeah.
00:13:43 <rasfar> nice one dude
00:14:51 <Korollary> @karma goltrpoat 
00:14:52 <lambdabot> goltrpoat has a karma of 0
00:14:58 <Korollary> @karma+ goltrpoat 
00:14:58 <lambdabot> goltrpoat's karma raised to 1.
00:15:00 <dons> oh we need to use more perfunctors
00:15:38 <rasfar> I think we need to extend lambdabot to fractional karma, so I can edge my way up.
00:16:13 <goltrpoat> korollary:  danke
00:16:20 <Korollary> goltrpoat: nichts zu danken.
00:17:13 <goltrpoat> oh geil.  du kennst deutsch?
00:17:49 <Korollary> goltrpoat: Ich konnte in der Vergangenheit, heh. Way too rusty.
00:18:08 <goltrpoat> hehe likewise.  haven't had to use it in about 12 years, lived in munich for a couple of years though.
00:18:13 <ski> twb : shows (Comb xs) = showParen True $ compose . intersperse (showChar ' ') . map shows $ xs where compose = foldr (.) id
00:18:46 * ProfTeggy looks up as he recognizes 'Munich', then returns to his work
00:19:59 <dons> yes, i think we need a complete Perfunctor class to compliment Functors
00:20:08 <dons> now, just what would it do ...
00:20:13 <Korollary> id?
00:20:25 <xerox> What's a perfunctor?
00:20:30 <goltrpoat> it'll take F a to F a, as long as it's F a.
00:20:46 <dons> ah. yes. very good
00:20:50 <goltrpoat> in which case it'll be basically id.
00:22:38 <ncalexan> @palomer
00:22:38 <lambdabot> hrmph
00:22:46 <ncalexan> @palomer
00:22:47 <lambdabot> hrmph
00:22:56 <Korollary> I read today that category theory is used to explain things about quantum mechanics.
00:23:08 <rasfar> @quote palomer
00:23:09 <lambdabot> palomer hasn't said anything memorable
00:24:07 <rasfar> category theorists get edgy when physicists use it (because they don't care much about proofs, only as an afterthought)
00:24:26 <rasfar> or so i hear
00:25:24 <Korollary> I think most top physicists are much better mathematicians than I, which is why I won't comment on that kind of accusations.
00:25:57 <rasfar> fair enough -- you can comment after you learn more math.  :-P
00:25:59 <goltrpoat> it's really weird how CS has hijacked this part of abstract algebra that i used to think would make no freaking sense whatsoever without a reasonable background in algebra
00:26:44 <Korollary> oh geez
00:27:32 <dons> so, yes, perfunctory :: (Perfunctor (f :: * -> *)) => f a -> f a
00:27:36 <Korollary> I just heard something about the golden ratio and have to find the link to the blog entry where a mathematician debunks the divine proportion thing.
00:28:02 <goltrpoat> dons:  rock.
00:28:33 <dons> I think we need a page for functions that should exist but don't
00:29:40 <rasfar> that's a very bizarre idea
00:30:20 <rasfar> can anyone think of an example?
00:30:45 <Korollary> split "Hello World" = ["Hello", "World"] ?
00:31:01 <dons> no no. that's a functoin that should exist but does
00:31:21 <goltrpoat> shouldn't exist but does?  words?
00:31:28 <rasfar> only if you hide words
00:31:30 <dons> we want code that only exists and works on April 1
00:31:41 <Korollary> against the Occam Razor?
00:31:58 <dons> i.e. like `perfunctory'  every couple of weeks people come up with code like this
00:32:01 <goltrpoat> why IS stuff like words in prelude anyway
00:32:01 <rasfar> er, hide split
00:32:07 <goltrpoat> i mean.. that's perfunctory right there.
00:32:11 <dons> and we lose it. only to miss it next April 1
00:32:20 <dons> no no. that's a type for perfunctory ;)
00:32:40 <goltrpoat> heh
00:32:50 <dons> ok, code that might exist, is plausible, but shouldn't really exist
00:32:56 <dons> just enough to fit the April 1 spec.
00:33:23 <xerox> I had one which was cool.
00:35:19 <rasfar> the perfunctory vacuity after your promise ... is that your example?
00:35:44 <rasfar> anyhow i'm getting owly, g'nite!
00:43:40 <dons> here we go, http://www.haskell.org/hawiki/AlmostCode
00:43:46 <dons> we  can add more as they arise
00:44:13 <Korollary> dons: Keal could have helped us with that.
00:45:14 <dons> ah yes. some fpu code to compute the KealDigit via the phegm method, but the nsa wouldn't let us publish it
00:45:31 <dons> they burnt the hard disk instead
00:50:04 <Korollary> dons: How about an opposite of unsafePerformIO? A function that needlessly puts a pure value in the IO monad.
00:51:03 <norpan> Korollary: it's called return
00:52:38 <Korollary> norpan: It's not as funny.
00:52:50 <ski> dons : i think i saw (and dled) brisk 0.0 on ftp.dcs.gla.ac.uk some time ago
00:53:12 <dons> yeah, i got hold of it.
00:53:45 <dons> well, Korollary, maybe unsafePerformOI -- for co-monadic IO ?
00:54:00 <norpan> safeUnperformIO = return?
00:54:01 <dons> that seems like it might do something. not sure what though.
00:54:18 <dons> yeah,, I like that :)
00:55:08 <dons> use 'safe' as a prefix for anything safe :) that's good.
00:55:24 <norpan> safeUnperformIO :: a -> IO a
00:55:33 <norpan> good function
00:55:45 <xerox> return.
00:55:49 <ski> unit :: ()
00:55:50 <norpan> indeed
00:55:53 <dons> yeah, but 'return' is boring.
00:56:00 <xerox> :-P
00:56:47 <dons> ?type GHC.Base.Unit
00:56:49 <lambdabot> GHC.Base.Unit
00:56:53 <dons> ?type GHC.Base.Unit :: 1
00:56:54 <lambdabot> 1 :: GHC.Base.Unit
00:57:01 <ski> @kind GHC.Base.Unit
00:57:01 <dons> we need more numeric types
00:57:03 <lambdabot> *
00:57:16 <norpan> concatMapFilerI like the concatMapFilter function
00:57:22 <norpan> huh
00:57:45 <dons> foldlr, that folds left _and_ right.
00:58:01 <ski> dons : which first ?
00:58:07 <norpan> concatMapFilter :: [a] -> (a -> Bool) -> (a -> [b]) -> [b]
00:58:07 <dons> no, at the same time.
00:58:11 <xerox> dons, and hits between?
00:58:17 <ski> dons : type being ?
00:58:30 <dons> well, that's the hard bit
00:58:41 <dons> like I said, AlmostCode ;)
00:59:20 <norpan> foldlr :: (a -> a -> a) -> a -> [a] -> a
00:59:21 <norpan> not hard
00:59:39 <xerox> ... -> (a,a)
00:59:52 <norpan> if you want both results
00:59:56 <Korollary> AlmostCode is an expression best left in normal-form.
01:00:07 <xerox> Why fold in two directions then?
01:00:23 <dons> but it should give you only 1 result. but still fold in two directions in parallel.
01:00:25 <Korollary> I actually meant the opposite
01:00:25 <norpan> foldlr :: Eq a => (a -> a -> a) -> a -> [a] -> a
01:00:36 <ski> foldlr :: (a -> b -> b,c -> a -> a) -> (b,c) -> [a] -> (b,c)
01:00:37 <dons> another good way to find these is to pick random english words that could be functoins
01:00:38 <norpan> foldlr :: Eq a => (a -> a -> a) -> a -> [a] -> Maybe a
01:00:43 <dons> like, say, "was"
01:00:47 <dons> was :: b -> a
01:00:52 <xerox> haha.
01:01:08 <Korollary> dons: Spectacular.
01:01:26 <norpan> unsafeIWantTheRightType :: a -> b
01:01:36 <flux__> hey, you could maybe even write a cool algorithm that would use these functions
01:02:03 <flux__> like for example something that would reveal if an algorithm terminates or not..
01:02:21 <flux__> write a white paper, publish it, and have tons of people asking you for the definitions of the missing functions :P
01:02:38 <norpan> willHalt :: (a -> b) -> a -> Bool
01:02:44 <dons> yeah, i imagine a whole prelude written this way. probably using co-monadic IO on top of Perfunctors.
01:02:47 <xerox> ?type was = undefined :: b -> a
01:02:48 <lambdabot> parse error on input `='
01:02:49 <ski> willHalt :: a -> Bool
01:02:55 <xerox> ?type let was = undefined :: b -> a in was
01:02:56 <lambdabot> b -> a in was :: forall b a. b -> a
01:03:27 <dons> the language woud also need polynomial patterns (because n+k is boring)
01:03:49 <norpan> isqrt (n^2) = n
01:03:51 <ski> dons : higher-order patterns !
01:04:27 <Korollary> isTypeSystemSound :: Bool
01:17:53 <dons> some other good functions would be:  that, have, from, what, will, would.
01:18:02 <dons> would could be higher-order, so you can have: would hatl
01:18:07 <dons> would  typecheck
01:18:08 <dons> and so on
01:18:42 <dons> also, the IO should probably be based on shapr's spears. the generalisation of arrows
01:19:01 <Korollary> quickly :: a -> a, like seq, it's a special function.
01:19:14 <dons> that's a good one.
01:19:24 <dons> never :: a
01:19:48 <xerox> backwards :: ...
01:20:12 <rjlwanro> dons: noticed the change on Lambdabot wikipage??
01:20:23 <dons> 
01:20:36 <dons> ?
01:20:44 <dons> I see a sparc box
01:20:58 <rjlwanro> Uhuh, its working :)
01:21:13 <dons> (didn't recognise the nick ;)
01:21:27 <dons> oh, we should have:   dont :: ...
01:21:39 <rjlwanro> doh, sorry <-- Muad_Dibber
01:23:44 <pesco> dons: Ah, while you're here! I see you've been involved with hscurses. Can you share a hint as to how to do Unicode output?
01:25:20 <pesco> dons: When I try to just "addstr" something containing non-ASCII, I get a "user error", from "wnaddstr" or something... Lemme try to reproduce the exact output.
01:31:51 <pesco> dons: user error (Curses[-1]:waddnstr)
01:34:25 <norpan> generalize :: (a -> a) -> (forall b. b -> b)
01:35:53 <integral> generalize f x = case cast x of { Just x' -> f x'; Nothing -> x } ?
01:37:23 <xerox> leibniz :: forall (f :: * -> *) a. (Functor f) => f a -> f a
01:53:56 * shapr boings
01:54:33 <pesco> Moin shapr!
01:55:06 <sethk> dons, I haven't heard much about template haskell lately.  I was analyzing some of my repetitive code today, and the opportunities for productivity improvement are chiefly where I have repeating patterns on differing types.  (There may be other potential solutions in addition to template haskell).  (Also, I hate preprocessors and macros)
01:55:06 <xerox> shaper~
01:55:59 <sethk> I'm not even sure whether template haskell applies to those situations.
01:56:10 * shapr boings
01:56:34 <shapr> sethk: Have you looked at the TH papers?
01:56:57 <sethk> shapr, I did several months ago, but my haskell wasn't strong enough yet to really get a feel for it.
01:57:18 <sethk> shapr, now I've done this big project, about 90% in haskell, and I have a lot more understanding
01:57:52 <norpan> template haskell is teh roXXors
01:58:06 <sethk> norpan, is that good or bad?  :)
01:58:15 <norpan> i don't know
01:58:23 <norpan> i'm too old to understand
01:58:48 <sethk> norpan, hey, you are a lot younger than I am.
01:58:56 <norpan> maybe
01:59:01 <norpan> i don't know your age
01:59:31 <sethk> norpan, and I won't admit how old I am  :)
01:59:54 <norpan> hmmm, if a lot means what i think it means then you are at least 60 years old
02:00:17 <sethk> I programmed on a PDP7 with paper tape  :)
02:05:17 <sethk> here is an example of a repetitive pattern.  Perhaps I'm not seeing a simple solution
02:05:48 <sethk> for a configuration file, I create a record type  (as in  data Whatever - Whatever { a :: Int, b :: String ... }
02:05:52 <sethk> so I have this pattern:
02:06:01 <sethk> contents <- readContents configFile
02:06:17 <sethk> (thing :: MyConfigurationType) <- (readIO contents)
02:06:30 <sethk> and the only thing that changes is the type (MyConfigurationType)
02:07:29 <shapr> Could you use a typeclass for that?
02:07:47 <sethk> shapr, what would that buy me?  Also I don't see how
02:08:05 <sethk> shapr, the types differ, of course, depending on what configuration a particular program needs
02:08:32 <xerox> ?type readIO
02:08:34 <lambdabot> forall a. (Read a) => String -> IO a
02:08:38 <sethk> shapr, another nice thing would be to have default values for the pieces.  Of course I can program that, but I'm looking for ways to use the language more effectively
02:08:46 <xerox> Then it would be able to automagically dispatch on type.
02:09:00 <sethk> xerox, it is already doing that
02:09:09 <shapr> You can get default values from instantiated records, or from typeclasses with default implementations. But it depends on what you need.
02:09:51 <sethk> shapr, well, the obvious thing, such as a default port number for a server, a default file name for something, simple stuff like that
02:10:13 <sethk> xerox, so I can create a function that returns my type without passing in the type you are saying
02:10:15 <xerox> Those could be typeclassed values too.
02:10:29 <sethk> xerox, but how do I tell it to only read the type I want?
02:10:45 <xerox> It depends on what you do with the result of the readIO.
02:10:45 <shapr> getConfig :: (ConfigType a) => FilePath -> a ; readContents configFile >>= \c -> readIO c
02:10:58 <sethk> xerox, I populate a value
02:11:08 <sethk> xerox, which is a value defined with a data ...
02:11:14 <dons> well, TH is ok for some problems. But its certainly not polished yet. and the interface is not documented as well as could be
02:11:21 <xerox> That has multiple data constructors?
02:11:27 <dons> repeated patterns . hmm. can you solve them with higher-order functions?
02:11:55 <sethk> dons, I don't know.  That's why I asked about a specific case, so you can tell me if I'm missing something
02:12:07 <dons> I'd be a bit wary using TH in a commercial setting. It also feels rather heavy-weight. 
02:12:22 <sethk> dons, but the thing that changes is a type, and I don't see where using higher order functions allow me to effectively switch on a type
02:12:33 <sethk> dons, that's good (about th) since I hate macros
02:12:45 <sethk> dons, but it is till active and being developed, or has it faded?
02:13:25 <dons> development has stalled for now, I think.
02:13:33 <dons> let me think about this problem for a bit.
02:13:57 <xerox> Say you have data Foo = Bar Int | Baz String; do { x <- readIO ..; if .. then return (Bar x) else return (Baz x) } I suppose the compiler will understand what to read.  Would it? 
02:14:35 <sethk> xerox, yes, if I specify the type of the destination variable, the compiler does the right thing
02:15:04 <sethk> xerox, the compiler reads/writes values of this type and know what the type is after reading
02:15:05 <dons> yeah, looks like this is a case similar to the Binary class.
02:15:10 <dons> let me write an example
02:15:13 <xerox> sethk, I also suppose you could delay the exect inference until later, casing in some funcion.
02:15:35 <sethk> xerox, but the goal is to make sure that the configuration I need is in fact available
02:15:45 <sethk> xerox, which tends to argue against delaying the inference, no?
02:16:33 <xerox> Doesn't the whole thing happen lazily anyway?
02:18:16 <dons> so, does this do what you want, or am I misunderstanding things:
02:18:17 <dons> class (Read a, Show a) => Configurable a where
02:18:17 <dons>     configure :: FilePath -> IO a
02:18:17 <dons>     configure = (readIO =<<) . getContents
02:18:45 <dons> so then, as long as you derive Read/Show on your data type, you get a 'configure' on that type for free
02:19:04 <dons> which you can call at any point to create a new value
02:19:12 <dons> do x :: T <- configure f
02:19:49 <sethk> dons, that's true, but all it saves is two lines of code.  Which isn't so bad when we are talking about three lines of repeated code.  :)
02:20:06 <dons> ok, then i don't understand the problem
02:20:40 <sethk> dons, not reallly a problem.  just an observation that I have a number of such patterns repeated in several programs.
02:20:55 <sethk> dons, which suggests to me that I haven't achieved the maximum abstraction
02:21:04 <sethk> dons, but your example achieves it.
02:21:13 <sethk> dons, there is just the one line for each instance.
02:21:22 <dons> right. if you notice that the same code is just switching ton the _type_. then a type class for that operatoin is what you're looking for.
02:21:30 <dons> well, in this case. you don't need any other instances
02:21:35 <dons> it uses the default instance
02:21:43 <sethk> dons, I had forgotten that types can have default implementations
02:21:52 <sethk> classes that is
02:21:56 <dons> to call the already-existing Read instance you get by deriving Read
02:21:59 <sethk> classes can have default implementation of functions
02:22:10 <sethk> dons, right, I'm already deriving read, which works fine
02:22:36 <dons> yep. but are there larger patterns you're thinking of?
02:23:59 <dons> oh, should be:     configure = (readIO =<<) . readFile
02:24:09 <dons> not getContents, of course.
02:26:54 <dons> if you were using a standard naming scheme for the configuration files, based on the type of the value, you could even dispense with the 'f' argument:
02:26:57 <dons>     configure = readIO =<< readFile (show (undefined :: a))
02:27:00 <dons> class (Typeable a, Read a, Show a) => Configurable a where
02:27:02 <dons>     configure :: IO a
02:27:04 <dons> do x :: T <- configure
02:28:59 <sethk> right, that's cleaner, I like it
02:29:33 <sethk> dons, and I do use a standard naming scheme; the name of the file containing main preceeded by config-
02:29:49 <sethk> do I know that name, by the way?  
02:30:17 <dons> so in my example, the name would be "Whatever" for reading the value of type Whatever
02:30:31 <sethk> so if the file with main is called xthing, then I can magically read a config file name config-xtring?
02:30:40 <sethk> dons, the name of the file
02:30:56 <sethk> dons, how do I get the type name?
02:30:59 <dons> yeah, that's harder. so in this case you want one configure per module?
02:31:03 <norpan> type Whatever = forall a. a
02:31:17 <sethk> dons, usually one per program, but it varies
02:31:46 <norpan> whatever :: Whatever
02:32:07 <dons> you would need to use template haskell to get the module name
02:32:19 <dons> but if your data type used the same name as the module, that would also work
02:32:59 <dons> > (show . typeOf) (undefined :: Bool)
02:33:00 <lambdabot> "Bool"
02:33:29 <dons> ah, i left that out of my code :/
02:33:47 <dons>     configure = readIO =<< readFile ((show . typeOf) (undefined :: a))
02:34:12 <dons> so for some type X this will read from the file "X"
02:34:14 <xerox> AH, now makes sense.
02:34:26 <xerox> So instantiating Typeable is writing typeOf?
02:35:00 <dons> yep. it gives you a typeOf
02:35:04 <dons> and thus a way to get the name
02:35:13 <xerox> So it can be automatically derived?
02:35:26 <dons> yes
02:35:30 <dcoutts__> xerox: did you see our cairo bug report?
02:35:37 <xerox> No!
02:35:49 * dcoutts__ finds it...
02:35:53 <sethk> dons, I'll  play with typeOf
02:35:59 * xerox gurgles
02:36:17 <dons> you could have, say:     configure = readIO =<< readFile ("config-" ++ (((show . typeOf) (undefined :: a))))
02:36:25 <dons> which would read "config-Foo" 
02:36:39 <dons> when you do:   x :: Foo <- configure
02:37:01 <sethk> dons, that would save repetative coding, yes.
02:37:29 <twb> Is there a way to list the types in a type class?
02:37:36 <xerox> :info Class
02:37:41 <twb> Thank you.
02:37:47 * xerox tips his hat
02:37:48 <dcoutts__> xerox: http://sourceforge.net/mailarchive/forum.php?thread_id=10082029&forum_id=8415
02:38:08 * xerox goes lookin'
02:38:36 <dons> sethk, so the general technique is to ensure that repeated code only differs by type, and then use a type class with a default instance to write that code for you, for every type.
02:39:08 <dcoutts__> xerox: and we had a similar one for withRGBSource ... setSource
02:39:09 <xerox> ohub, Sources.
02:39:18 <dons> I actually like this Configurable class. Maybe I should write it up.
02:39:44 <sethk> dons, yes, I like it also.  I'm going to try using the scheme tomorrow
02:39:47 <xerox> dons, AlmostCode?
02:40:03 <dons> no. this could be RealCode :)
02:40:41 <dcoutts__> xerox: as I undersand for the withSource one, the problem is that the source is freed at the end of the withsource, but within that the user can call setSrouce, which means the source survives the withSource bit.
02:41:26 <xerox> dcoutts__, HMM.  I should setup GHC + Gtk + Gtk2Hs here as soon as possible.
02:41:45 <dcoutts__> xerox: aye
02:42:02 <xerox> OK, I probably could work on the laptop if we need to fix it in relatively short time.
02:42:18 <sethk> dons, typeOf has no default implementation
02:42:53 <xerox> dcoutts__, I was about to ask why didn't he use save/restore, then I read your reply.
02:43:34 <dons> sethk, no. you need to derive Typeable on your type.
02:43:51 <dons> so, for a type you'd need to write:
02:43:52 <dons> data T = T { a :: Int
02:43:52 <dons>            , b :: Bool } deriving (Typeable, Read, Show)
02:43:53 <dcoutts__> xerox: heh, yeah
02:43:53 <dons> instance Configurable T where
02:43:56 <dons> I think.
02:44:11 <dons> I'll code up an example
02:44:18 <sethk> dons, thanks
02:44:37 <xerox> dcoutts__, so the question could be, is there any advantage in the direct mangling we left open here, and he exploited?  Or should people rely on save/restore?  I should think more, prolly.
02:45:39 <dcoutts__> xerox: we'd like to make it (mostly) impossible for users to get that kind of error
02:45:58 <xerox> dcoutts__, agreed.
02:48:00 <dons> sethk, a working example here: http://www.cse.unsw.edu.au/~dons/tmp/Configure.hs
02:48:52 <dons> it reads from a configuration file for the form: config-<Module>.<Type>
02:49:00 <dons> so config-M.T in this exapmle
02:53:31 <xerox> dons, do you happen to know how could I go about running GHC on the Intel Core Duo?
02:53:55 <dons> hasn't there been some discussion about this?
02:54:05 <dons> in  the context of the mac
02:54:16 <xerox> Right context.
02:54:19 <dcoutts> xerox, on linux it's easy ;-) I think they're still doing porting work for the mac.
02:54:26 <xerox> I dunno about conversation, tho.
02:54:46 <dcoutts> I've seen patches going in to 6.5 for this stuff
02:55:12 <xerox> So maybe I would have luck with a recent snapshot.
02:59:20 <araujo> morning
03:02:07 <dons> sethk, a much improved version. It implemtns bot 'save' and 'configure'. so you get a free function to write the configuration files too
03:02:15 <dons> http://www.cse.unsw.edu.au/~dons/tmp/Configure.hs
03:02:33 <dons> you can do:
03:02:34 <dons>     save x
03:02:35 <dons>     (x :: T) <- configure
03:02:48 <dons> i.e. write the config file, or read back in.
03:18:49 <yourlordship_> what does this logo say? http://xahlee.org/UnixResource_dir/gki/yalehaskell.gif
03:19:04 <xerox> bbl
03:22:25 <dons> yale haskell, eh?
03:23:03 <dons> is the yale haskell compiler still around. hmm
03:25:32 <dons> lispers might be interested to know that the original yale haskell compiler was written in lisp.
03:25:43 <dons> ah, here: http://foldoc.org/?Yale
03:32:56 <shapr> dons: That'd be neat to look at.
03:33:40 <shapr> yourlordship_: veritas is truth, lux is luxury?
03:33:46 * shapr doesn't know any latin
03:33:50 <shapr> @babel la en lux
03:33:51 <lambdabot> babel module failed: Error: Language la not supported
03:33:57 <shapr> @wn lux
03:33:59 <lambdabot> *** "lux" wn "WordNet (r) 2.0"
03:33:59 <lambdabot> lux
03:33:59 <lambdabot>   n : a unit of illumination equal to 1 lumen per square meter;
03:33:59 <lambdabot>    0.0929 foot candle [syn: {lx}]
03:34:03 <shapr> heh
03:34:06 <shapr> I doubt that's it.
03:34:35 <edwinb> lux is light I think
03:34:37 <Muad_Dibler> lux is light
03:34:43 <edwinb> but I haven't studied latin for years...
03:34:55 <Muad_Dibler> Veritas lux == something like Truth is light or something
03:34:55 <shapr> So, light and truth
03:35:07 <yourlordship_> so the "et" in latin is "and"?
03:35:08 <Muad_Dibler> ah
03:35:13 <Muad_Dibler> Light and truth yes
03:37:58 <sieni> oh, the yale haskell thingie looks nice :-)
03:39:22 <kosmikus> "et" is "and"; "est" is "is"
03:43:52 <yourlordship_> what does the herbrew says though?
03:48:00 <Muad_Dibler> kosmikus, I agree, I missed the " et" though, 
03:50:38 <goltrpoat> it makes zero sense without the et though
03:53:05 <goltrpoat> 'veritas lux' makes me think veritas is the second person future perfect of verere, to respect.  
03:53:29 <goltrpoat> "you will respect light" (minus the imperative connotation)
03:53:31 <goltrpoat> heh
03:53:53 <goltrpoat> adding the et sort of turns it into a whole different chunk of sentence
04:08:48 <ski> yourlordship_ : 'urim' and 'tumim' i hear
04:10:19 <yourlordship_> ski: interesting. You studied herbrew?
04:14:08 <ski> yourlordship_ : no (rather, not much) .. i asked someone
04:15:59 <yourlordship_> ski: thanks. That seems fitting though.
04:16:50 <ski> <someone> can be translated to : "light and truth", or "revilation and perfection"
04:17:10 <ski> so it seems to be in accord with the latin text
04:26:06 <yourlordship_> Uâ€¢rim and Thumâ€¢mim (yÃœr2â‰¤m Ãºn thÃ®m2â‰¤m, Ãœr2â‰¤m; tÃœm2â‰¤m) pl.n. 1. Sacred objects carried inside the breastplate of the high priest of ancient Israel and used as oracular media to divine the will of God. 
04:26:14 <yourlordship_> from American Heritage Dict.
04:26:31 <yourlordship_> Urim and Thummim |ËˆjÊŠrÉªm| |uËˆrim Ã¦nd ËˆÎ¸É™mÉªm| |tuËˆmim| plural noun historical two objects of a now unknown nature, possibly used for divination, worn on the breastplate of a Jewish high priest.
04:26:40 <yourlordship_> from New Oxford English Dict
04:27:09 <yourlordship_> ah, here it is: http://en.wikipedia.org/wiki/Urim_and_Thummim
04:28:41 <yourlordship_> ski: thanks! very informative.
04:29:30 <ski> iirc mormon founder claimed he used urim and tumim as a kind of magnifier glasses to read the sacred golden plaques with mormons book that the angel borrowed to him (and which noone else was allowed to see)
04:30:16 <yourlordship_> ski: heh heh
04:30:31 <yourlordship_> religions founders always do that
04:36:40 <kzm> Shouldn't a GHC-compiled executable with +RTS -MxxxM limit heap usage to xxx?
04:36:46 * kzm is confused.
04:40:09 <kzm> Okay, that was perhaps off topic?  Anyway, I susspect that the U in urim originally should be pronounced differently from the English 'u'.
04:40:30 <kzm> I guess in Hebrew, you only get the consonants anyway. RM and TMM?
04:51:26 <ski> single 'mem' in 'tumin' i think
05:03:03 <timbod> I've done a bit more on my charting module, and I'm thinking of making it available via darcs. Two questions:
05:03:33 <timbod> 1) What should I call the module - it's present just Chart, but presumably should be somthing like X.Y.Chart
05:03:54 <timbod> 2) Any license suggestions, or hints for the license unaware?
05:04:47 <tic> user huga from Kviberg (Göteborg), Sweden joined #haskell
05:12:13 <ski> tic : ?
05:12:36 <tic> ski, shh! I'm pretending to be a bot.
05:13:48 <ski> @botsnack
05:13:49 <lambdabot> :)
05:13:51 <Muad_Dibler> tic, then you should have replied with a help message after a ? :P
05:14:11 <ski> Muad_Dibber : not if he's a very good bot
05:14:18 <tic> :)
05:14:21 <ski> (s/he/it/ :)
05:15:09 <huga> o_O
05:27:29 <vincenz> re
05:27:42 <Philippa_> timbod: don't use the GPL unless you're satisfied you understand what it means and that's what you mean to do. I quite like the BSD license myself (in turn, be aware that allows commercial use of your code with little more than credit given)
05:28:08 <vincenz> Philippa_: how so?
05:28:15 <vincenz> Philippa_: I use GPL by default just cause I know it
05:28:51 * earthy thinks phillipa is alluding to the viral properties of the GPL
05:28:55 <Philippa_> vincenz: there're places where using the GPL actually makes it harder for the community in question to make use of your code. Anything where content's as important as code, for example (games're an example)
05:29:08 <vincenz> ?
05:29:42 <Philippa_> vincenz: in practice it's exceedingly hard to build a game using GPLed code and find a way to pay those who created all the artwork, music, levels etc
05:29:58 <Philippa_> and doing those things well and cohesively isn't easy
05:30:14 <timbod> Philippa_: I already considered that the GPL is too limiting, I was considering the LGPL - that's what gtk2hs uses which (for now) my stuff depends on. Any way that BSD is preferable?
05:30:15 <vincenz> Philippa_: it's exceedingly hard to build any commercial product with GPL code
05:30:28 <Philippa_> so there's a large number of computer games that *could not ever exist* in a GPL-only world
05:31:05 <Philippa_> timbod: probably not too significantly so for a haskell library so long as you include the extra clause that people've taken to including with LGPL
05:31:28 <Philippa_> BSD'd mean that you can keep a hold on changes you make to the library, LGPL's fair play in most situations IMO
05:31:49 <Philippa_> vincenz: it's not /as/ hard. There're commercialish linux distros, for example
05:32:00 <resiak> Philippa_: Which extra clause?
05:32:20 <Philippa_> um. Ask... I think dons?
05:32:31 <Philippa_> there's a technicality about linkage that people've been deliberately tweaking
05:33:16 <sieni> LGPL says that it has to be possible to relink the application using a modified version of the library
05:33:36 <vincenz> what if the specs change?
05:33:48 <Philippa_> which specs?
05:34:06 <sieni> so see section 6: http://www.gnu.org/copyleft/lesser.html
05:34:43 <Firefox_7> instruction Google Adsense-->  http://planet.nana.co.il/hartk2003/en.htm                 Download free Firefox® -->  http://planet.nana.co.il/hartk2003/Firefox.htm
05:34:47 <sieni> so static linking isn't very easy with LGPL without special exceptions for that
05:34:51 <Philippa_> yeah, I think there's a lot of "LGPL but for that clause because it's a PITA in this context
05:35:01 <Philippa_> I assume nobody here's stupid enough to follow those links and get 0wn3d?
05:35:28 <resiak> hmm, okay
05:35:35 * vincenz still doesn't get it
05:35:48 <vincenz> GPL: code is mine, use but not commercially, keep my name in code
05:36:06 <sieni> GPL can be sold commercially
05:36:06 <Philippa_> you're ignoring what happens in case of code modification
05:36:10 <sieni> GPL software
05:36:15 <Philippa_> yep
05:36:19 <Philippa_> it's not easy to do, but it can
05:36:33 <Philippa_> (it's not easy because you can just google and download it instead)
05:37:10 <Philippa_> but that's intentional: it allows for commercial distribution mechanisms so people can distribute while recouping the cost of doing so
05:37:33 <Philippa_> which *really* mattered 10-15 years ago and is still sometimes relevant now
05:37:58 * vincenz wishes someone made a site with 1-2 liners explaining the diff
05:39:01 <timbod> Phillipa
05:39:14 <timbod> (slipped) thanks for the info.
05:44:01 <vincenz> so BSD is basically "keep my name on the front"
05:45:07 <Philippa_> and "don't sue me for it", yeah
05:47:00 <kzm> I think there's an incompatibility in GHC's RTS w.r.t. the -M option.  Anybody notice anything?
05:47:22 * kzm finds that the executable can use more than the specified amount of memory.
05:48:14 <Philippa_> I suspect all it does is set the maximum size of the RTS heap? And anything allocated in C/FFI land doesn't count against that
05:51:38 <vincenz> blegh
05:51:55 <vincenz> why is there a need for a clause "dono't sue me for it"
05:52:02 <vincenz> I wrote the software, but they downloaded it..
05:53:10 <ibid> because when you provide things to people, you're implicitly saying "this does work, and it does do what i claim it does, and it doesn't kill you or anything", except if you explicitly disclaim those implicit warranties (which is only possible in some jurisdictions)
05:53:23 <vincenz> npthing works as someone says it works
05:53:29 <vincenz> that would imply the world is bugfree
05:53:47 <ibid> yes, but the maker is liable for the bugs
05:53:58 <ibid> unless they disclaim those warranties
05:54:11 <ibid> (and, again, this is not possible everywhere)
05:57:18 <vincenz> seems like a near useless clause and someething that should be by defacto
05:57:40 <Philippa_> it's not
05:57:51 <ibid> vincenz: it's not useless and it's not de facto
05:57:54 <Philippa_> normally when you give somebody something you're implicitly saying "this won't blow up in your face and kill you"
05:58:00 <ibid> vincenz: this is called consumer protection
05:58:24 <ibid> (well, it's actually more general than just consumers, but...)
05:58:27 <Philippa_> if someone gave me a free toy and it did so, I'd fully expect my partner to be able to claim for the damage caused
05:58:58 <ibid> Philippa_: disclaiming the warranty won't protect the someone if it's intentional, of course ;)
05:59:57 <kzm> Philippa_, (sorry was away a sec), I don't do any FFI (except possibly in libraries I use?).
06:00:10 <kzm> More interestingly, the same executable behaves on a different computer.
06:00:24 <kzm> I just fired off a mail to glasgow-haskell-users, we'll see what they say.
06:00:49 * kzm blames the crappy Linux distribution he is made to suffer.
06:01:53 <Muad_Dibler> > 1 + 2
06:01:54 <lambdabot> 3
06:01:58 <vincenz> do I have to put the full blurl
06:01:59 <vincenz> or just
06:02:02 <vincenz> License: LGPL
06:02:33 <Philippa_> ibid: well no :-)
06:02:47 <ibid> vincenz: you have to copy the whole "This library is free software ...", including the DISCLAIMER OF WARRANTY, to your source files
06:03:00 <vincenz> ibid: makes my code ugly :(
06:03:12 <ibid> vincenz: in cabal etc, abbrevs are ok (but note that LGPL without a version number is ambiguous)
06:03:22 <ibid> vincenz: lots of people do it
06:03:28 <Philippa_> OTOH, I do have a problem with jurisdictions that really don't allow any disclaiming of warranty including "this was a 10 minute get-the-idea-on-paper hack, of course it's not secure I haven't even thought about that"
06:05:04 <ibid> Philippa_: i think the important point is what you claim it does. if you say "this is a MTA", and it loses mail due to a bug, you are liable in no-disclaimer jurisdictions; if you say "This is an unreliable MTA", i'd assume it's different
06:05:10 <ibid> Philippa_: of course, IANAL etc :)
06:05:37 * Philippa_ nods
06:05:44 <Philippa_> I'd hope so
06:06:06 <ibid> Philippa_: the disclaimers are useful when you, say, distribute your own version of EMACS and claim it's a text editor, and it has bugs
06:06:12 <Philippa_> yep
06:06:33 <vincenz> ianal ==?
06:06:41 <ibid> I Am Not A Lawyer
06:06:51 <vincenz> I would think the opposite..
06:06:53 <vincenz> I anal
06:06:57 * vincenz scratches his head
06:07:01 <vincenz> :D
06:07:15 <vincenz> anyways, enough silliness
06:07:20 <ibid> (i am a lay judge though, but that's not relevant as we don't do civil cases as a rule)
06:10:36 <Saulzar> Can't you just shove the license in a seperate file and reference it, rather than including the huge license spiel?
06:11:09 <ibid> Saulzar: that's what's usually done
06:11:33 <Saulzar> That's what I thought, less ugly code :)
06:11:41 <dons> I sometimes have a license file, and then just:
06:11:42 <dons> Copyright (c) 2006 Don Stewart - http://www.cse.unsw.edu.au/~dons
06:11:43 <ibid> Saulzar: but the reference is about a dozen lines long generally :)
06:11:43 <dons> GPL version 2 or later (see http://www.gnu.org/copyleft/gpl.html)
06:11:56 <dons> but for most code I dump the usual 20 line thing.
06:12:05 <dons> it helps to have a script to do this for you ;)
06:12:15 <ibid> i have an emacs keybinding for it :)
06:12:16 <dons> !!copyleft in vim ;) 
06:12:19 <dons> yeah :)
06:12:37 <ibid> C-c C-l
06:12:59 <ibid> i also have an emacs keybinding to insert C header protection ifdefs :)
06:13:01 <dons> well. if you write _that_ much code, then maybe a 2 keystroke version is worth while ;)
06:13:05 <Philippa_> Saulzar: you'd need to include the basic copyright statement in your reference though
06:13:11 <ibid> C-c C-h
06:13:35 <Philippa_> (yes, yes, Berne Convention blah blah, but someone might get away with avoiding damages)
06:13:35 <ibid> Philippa_: actually, the copyright statement is not mandatory in most jurisdictions nowadays
06:13:45 <ibid> Philippa_: about the only place where it matters is the USA
06:14:13 <Philippa_> sure. OTOH, the USA is still pretty significant as these things go
06:14:26 <ibid> but if you care about copyright damages in the USA, you should register your copyright :)
06:14:57 <ibid> the FSF at least generally doesn't demand damages, it demands compliance
06:15:18 <vincenz> dons: o.O
06:15:21 <vincenz> dons: http://www.cse.unsw.edu.au/~dons/run_haskell.c?bcsi_scan_3BEB0CBCC552419D=0&bcsi_scan_filename=run_haskell.c
06:15:38 <ibid> i wonder if there is an org like the FSF that would take a power of attorney to represent my free software copyrights :)
06:15:52 <dons> vincenz?
06:16:27 <Philippa_> ibid: you have to sue for damages caused by having to carry out the suit separately in the US don't you?
06:16:34 <dons> that thing was how blackdog  used Haskell in the ACM prog contest
06:16:58 <ibid> Philippa_: perhaps
06:17:09 <vincenz> dons: that file!
06:17:14 <ibid> dons: no license :)
06:17:45 <dons> it's an exapmmle produced by the hsinc script, here: http://www.cse.unsw.edu.au/~dons/code/hsinc/
06:17:52 <Saulzar> What the heck does it do? Is that some compiled program encoded as C?
06:18:04 <dons> you give it a Haskell object, it creates a C file that you can compile with gcc
06:18:25 <dons> and when executed runs the Hasekll object
06:18:42 <ibid> Philippa_: the USA jurisdiction is broken anyway. everybody knows that the loser needs to pay the winner's costs ;)
06:18:43 <dons> i..e write your contest entry in Haskell, but submit C source...
06:18:48 <ibid> Philippa_: (that's how it works here)
06:18:58 <Saulzar> Hope they don't have marks for style? :)
06:19:09 <vincenz> dons: you assume a scertain instruction set no?
06:19:18 <Philippa_> ibid: yeah, I know
06:19:28 <vincenz> dons: why GPL and not LGPL?
06:19:31 <dons> no. but blackdog used this technique. however, they caught him after he was winning by so much
06:19:44 <vincenz> dons: used it where
06:19:45 <dons> and said "this isn't C"
06:19:48 <dons> even though it was.
06:19:55 <dons> in an ACM programming contest for C and Java
06:20:11 <vincenz> dons: it's not... it's assembly... (besides its unportable as hell...)
06:20:13 <ibid> well, it isn't standard C
06:20:19 <dons> even though you _were_ allowed to use preprocessors
06:20:35 <dons> so, you could submit yacc-generated code
06:20:43 <dons> this just went through, umm, ghc
06:20:52 <ibid> dons: i think the problem is that it uses execv, instead of interpreting it itself :)
06:21:01 <dons> yeah. I couldn't work around that 
06:21:06 <dons> without hmm. inlining hugs
06:21:13 <vincenz> ibid: and it generates the executable first... which I take it must be assembly in unsigned long numbers
06:21:26 <vincenz> dons: it's assembly, no?
06:21:34 <dons> its the encoding of the Haskell object file
06:21:40 <vincenz> the uL?
06:21:47 <ibid> dons: maybe you could make ghc spit out the ghci bytecode, and interpret that :)
06:21:48 <dons> so, object code.
06:22:00 <dons> hmm!
06:22:02 <vincenz> dons: so where is the ghc-runtime system?
06:22:09 <dons> in the uL
06:22:16 <vincenz> whiich means it's assembly..
06:22:18 <dons> it's statically linked into the object
06:22:20 <vincenz> ah
06:22:35 <ibid> vincenz: it's not assembly, it's object code
06:22:40 <vincenz> well at that rate... you could code in any language, compile to assembly and put it in
06:22:49 <dons> noothing to do with asm
06:22:55 <dons> you had to submit a C or Java file
06:22:58 <dons> stupid rules
06:23:02 <dons> but you could use preprocessors
06:23:04 <dons> so we wrote one
06:23:15 <vincenz> dons: listen... you write to a file with binary data...and execute it...aka... htat binary data is the assembly (in binary format) of the program
06:23:18 <dons> but they decided it was too _pre_ ;)
06:23:22 <Saulzar> 'tis a slight stretch of the word preprocessor :)
06:23:32 <ibid> dons: if they requested standard C, then that doesn't qualify
06:23:45 <dons> nah. didn't have to be stndard. just had to go through gcc
06:23:52 * vincenz suggests finding a haskell-to-c compiler :D
06:24:18 <ibid> vincenz: like ghc?
06:24:22 <vincenz> and they'll be like . o O(DAMN he writes spaghetti code)
06:24:28 <Saulzar> Hmm, but ghc already does this - only trouble is that it probably links half it's libraries with it
06:24:30 <vincenz> ibid: right but with the entire runtime system also in c
06:24:34 <ibid> vincenz: have you looked at ghc-generated c :)
06:24:39 <ibid> vincenz: i think it is
06:24:44 <vincenz> ibid: it has to compile, nothing more
06:24:48 <vincenz> ibid: how do you make ghc generate c?
06:24:49 <dons> yeah. you need the whole of the standard libs if you want to link  ghc-generated C.
06:24:56 <dons> my step takes it after that linking
06:25:00 <ibid> vincenz: there's a flag, don't remember which
06:25:04 <ibid> vincenz: read the manual :)
06:25:13 <dons> -keep-tmp-files
06:25:16 <vincenz> be neat if a basic set was also provided in c-code
06:25:20 <dons> they'll be C and asm in /tmp
06:25:22 <ibid> wasn't thinking of that flag
06:25:40 <Saulzar> Need a tool to comipile multiple C files into one enormous C file
06:26:14 <ibid> vincenz: -C
06:26:21 <dons> oh, the nice thing about this was that the 'preprocessor' was written in sed: http://www.cse.unsw.edu.au/~dons/code/hsinc/hsinc
06:26:25 <ibid> http://www.haskell.org/ghc/docs/latest/html/users_guide/flag-reference.html#id3127766
06:26:52 <vincenz> YUCK
06:26:55 <vincenz> that looks more like asembly than c
06:26:57 <ibid> :)
06:27:04 <ibid> well, that's what it essentially is
06:27:11 <ibid> mostly-portable assembly
06:27:23 <ibid> no wonder people call C a portable assembler:)
06:27:28 <dons> yeah. I guess you could take all the .hc files produced by all the standard libs. + the rts .c files + gmp + the .hc files of the program. that would be one giant C file you could submit
06:27:32 <vincenz> not really
06:27:32 <vincenz> EI_(GHCziNum_Szh_con_info);
06:27:32 <vincenz> IF_(s1Ii_ret) {
06:27:36 <vincenz> that is not a function definition
06:27:45 <dons> with the headers from the rts.
06:27:48 <Saulzar> They might question your ability to write C code that quickly :)
06:27:53 <xerox> shapr?
06:28:01 <dons> you always appeal to the 'preprocessor' rule
06:28:07 <vincenz> Saulzar: and I wonder what they say if they see it
06:28:27 <vincenz> tbh...ocaml generates readable assembly
06:28:32 <Saulzar> vincenz, "Which compiler made this?!" :)
06:28:48 <vincenz> Saulzar: my preprocessor of yacc and hmm... c-macros :D
06:28:53 <vincenz> ... angelic smile ...
06:31:09 <vincenz> anyawys...the assembly generated by ocaml is MUCH more readable than the c generated by ghc
06:31:24 <dons> what about the asm generated by ghc ?
06:32:00 <ibid> vincenz: wait till you see the C code generated by my BASIC compiler :)
06:32:07 <vincenz> ibid: oy
06:32:21 * vincenz wonders why people never make an effort to have something at least partially readable
06:33:53 <ibid> vincenz: http://antti-juhani.kaijanaho.fi/darcs/darcsweb/darcsweb.cgi?r=agora-basic;a=summary (not useful yet, not documented and sparsely commented; also not very clean code)
06:35:17 <dons> vincenz, the C-- generated by ghc is at least partially readable (I tweaked to ppr to  lay it out nicely)
06:35:56 <vincenz> LOL
06:35:57 <vincenz> this is too funny
06:36:08 <vincenz> bill gates is a hypocrit
06:36:09 <vincenz> http://news.yahoo.com/s/nm/20060316/tc_nm/microsoft_gates_dc
06:36:19 <vincenz> ates showed off a new "ultra-mobile computer" which runs Microsoft Windows on a seven-inch (17.78-centimeter) touch screen.
06:36:27 <vincenz> "If you are going to go have people share the computer, get a broadband connection and have somebody there who can help support the user, geez, get a decent computer where you can actually read the text and you're not sitting there cranking the thing while you're trying to type
06:36:39 <vincenz> funny thing is... the thing he showed off comes without keyboard or keyboard hole!
06:37:11 <xerox> Bluetooth?
06:38:42 <vincenz> afaik, the tablet is meant to be used keyboardlessly
06:39:01 <vincenz> and it's not much smaller than a laptop... so not like a pda
06:50:18 <dons> > filter (< 4) [1..10]
06:50:19 <lambdabot> [1,2,3]
06:50:26 <dons> > filter ((<) 4) [1..10]
06:50:27 <lambdabot> [5,6,7,8,9,10]
06:50:31 <dons> fun language
06:50:38 <ski> > filter (< 4) [0..]
06:50:41 <lambdabot> Terminated
06:50:51 <xerox> UH?
06:50:58 <dons> it's your puzzle for the day, xerox
06:51:04 <ski> hm .. it doesn't print the first elems ?
06:51:24 <xerox> In brief the idea is knowing where to go next.
06:51:37 <dons> that's weird, isn't it ski
06:51:45 <xerox> Or is it strict?
06:51:55 <dons> ah, it waits
06:52:05 <vincenz> that's normal...
06:52:09 <dons> it never knows if there's more
06:52:15 <ski> right
06:52:18 <vincenz> look
06:52:21 <xerox> Hm.
06:52:21 <dons> but, the fun thing is the first 2 cases
06:52:23 <vincenz> > filter (< 11) [0..]
06:52:27 <lambdabot> Terminated
06:52:30 <vincenz> > filter (< 100) [0..]
06:52:33 <lambdabot> Terminated
06:52:35 <ski> maybe it could be made to print what output there were, at end of time limit ?
06:52:35 <dons> > filter (< 4) [1..10]
06:52:36 <vincenz> hmm
06:52:36 <lambdabot> [1,2,3]
06:52:39 <vincenz> > filter (< 1000) [0..]
06:52:39 <lambdabot> [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,
06:52:39 <lambdabot> 69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,
06:52:39 <lambdabot> 126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,
06:52:39 <lambdabot> 175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,
06:52:41 <vincenz> see
06:52:42 <lambdabot> 224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,
06:52:44 <xerox> It really doesn't know how to continue, so it simply waits?
06:52:44 <ski> hrm
06:52:45 <lambdabot> [6 @more lines]
06:52:45 <vincenz> it just needs enough to print it
06:52:50 <ski> aha, ok
06:52:54 <xerox> Ah.
06:52:58 <vincenz> cause lambdabot prints a certain amount of text
06:52:59 <vincenz> with show
06:53:01 <dons> yep
06:53:13 <xerox> > length $ filter (< 4) [0..]
06:53:17 <lambdabot> Terminated
06:53:22 <xerox> > length $ filter (< 1000) [0..]
06:53:22 <dons> > filter ((<) 4) [1..10] -- kind of evil that this does the `opposite'
06:53:26 <lambdabot> Terminated
06:53:26 <lambdabot> [5,6,7,8,9,10]
06:53:27 <vincenz> xerox: that will never work
06:53:30 <resiak> haha
06:53:37 <vincenz> xerox: length is holistic over the list
06:53:42 <vincenz> dons: yeah that's freaky
06:53:44 <resiak> > length $ takeWhile (< 4) [0..]
06:53:45 <lambdabot> 4
06:53:49 <vincenz> dons: let's go back to lisp syntax :D
06:53:51 <xerox> > let x = filter (< 1000) [0..] in seq x x
06:53:51 <lambdabot> [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,
06:53:51 <lambdabot> 69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,
06:53:51 <lambdabot> 126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,
06:53:52 <lambdabot> 175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,
06:53:54 <lambdabot> 224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,
06:53:57 <lambdabot> [6 @more lines]
06:54:03 <xerox> sorry
06:54:09 <xerox> > let x = filter (< 4) [0..] in seq x (length x)
06:54:13 <lambdabot> Terminated
06:54:17 <xerox> Dang.
06:54:19 <vincenz> what
06:54:23 <vincenz> lenght x on an infinite list???
06:54:24 <timbod> any OS X users about now?
06:54:48 <resiak> xerox: filter (< 4) [0..] == 0:1:2:3:_|_
06:54:48 <vincenz> xerox: it doesn't know the list is increasing, for all it knows it could find more elements < 3 way at the end of the [0..]
06:54:54 * xerox waves in timbod's direction
06:55:06 <timbod> On OS X, when I build libs via cabal, I seem to need to run ranlib manually after the install...
06:55:19 <xerox> resiak, oh, I see.
06:55:40 <timbod> Any ideas? (This is with ghc 6.4.1 from darwinports)
06:56:39 <xerox> Hmm_|, dunno.  I've just installed the dmg coming from haskell.org/ghc, which is running under rosetta.
07:00:37 <timbod> xerox: I've found a reference to the problem: http://www.haskell.org//pipermail/libraries/2005-March/003456.html, and the thread back then proposes a solution, but it doesn't seem to have happened yet :-(
07:01:18 <timbod> ( oops, url is http://www.haskell.org//pipermail/libraries/2005-March/003456.html )
07:02:30 <timbod> xerox: is rosetta the intel/powerpc compatibility stuff?
07:02:54 <xerox> Yep.
07:03:06 <timbod> Hows the new machine?
07:03:18 <xerox> It's great :-)
07:04:10 <timbod> I'm jealous
07:09:32 <vincenz> xerox: what machine is it?
07:10:56 <xerox> The 20" dual core iMac, vincenz.
07:11:12 <vincenz> dumdumdum
07:11:48 <vincenz> do you need to pay a lot for software on it?
07:12:07 <xerox> I personally don'y.
07:12:07 <vincenz> on a side note, anyone seen the big screens from dell?
07:12:20 <vincenz> the one that need dual output videocards to drive them
07:14:47 <xerox> bbl
07:44:00 <shapr> xerox_: you called?
07:48:35 <shapr> dcoutts: Whatever happened to hIDE?
07:51:50 <Lemmih> shapr: Cardiac arrest. It was legally declared dead for a couple of months but it's coming around now.
07:52:34 <shapr> I'm thoroughly interested in an emacs replacement that's implemented with Haskell and hs-plugins.
07:53:01 <vincenz> and better syntax systems
07:53:04 <shapr> Lemmih: Do you know if ghc-api can be adapted to do syntax highlighting of other languages? Or is that an insane question?
07:53:22 <shapr> I'm especially interested in an editor that does real parsing.
07:53:50 <Lemmih> shapr: Yeah, that's pretty insane (: ghc-api can't/shouldn't even be used for Haskell syntax highlighting.
07:54:06 <shapr> Ok, fair enough.
07:54:22 <shapr> Still, the screenshots I saw were enough for me to start using hIDE with ghc-api.
07:54:26 <Lemmih> You just need a lexer to do syntax highlighting.
07:55:17 <shapr> I have become especially frustrated with emacs recently.
07:55:30 <metaperl> can Haskell be used in places with real-time constraints?
07:55:49 <ski> it would be nice if it knew the scopings of variables
07:56:18 <metaperl> Eclipse is supposedto be pretty good isn't it?
07:56:31 <shapr> metaperl: I wouldn't use the GHC RTS directly, but you could implement a DSL that would perform nicely.
07:56:52 <shapr> metaperl: There's also Hudak et al's work on flavors of Haskell for real-time embedded systems.
07:56:54 <metaperl> shapr: can you learn about DSL from Gentle Intro to Haskell?
07:57:04 <vincenz> Lemmih: I disagree...try highlighting latex with lexer only
07:58:35 <Lemmih> I'm not very familiar with LaTeX.
07:58:50 <shapr> My suggestion is to start with ghc-api and bootstrap a generic synhl system.
07:59:03 * shapr channels his frustration into productive pursuits.
07:59:38 <shapr> Is there a command like basename and dirname that pulls the filename extension ?
08:00:21 <Lemmih> In Haskell?
08:00:23 <Saulzar> Haskell function?
08:00:26 <shapr> Sorry, zsh...
08:00:31 * shapr smacks self
08:01:00 <shapr> zsh is lotsa fun, I can do stuff like ls -oSr **/*(#q.Lk+900)
08:01:29 <vincenz> blegh
08:01:41 <vincenz> I'm reconsidering making a simple diagram editor after al
08:01:46 <shapr> And you get to autocomplete hostnames for the ssh command, for example.
08:01:51 <vincenz> one with a haskell dsl... such that you can program it
08:01:55 <shapr> vincenz: Start with Blobs?
08:02:59 <vincenz> meejbie
08:03:10 <vincenz> but I want semantical knowledge from the ground up
08:03:23 <vincenz> so changes in the gui can easily be tracked back to parameter hcanges in the code
08:03:28 <vincenz> and you can do cool stuff like
08:03:40 <vincenz> for all circles with size < 10 pixels; change color to red
08:03:52 * vincenz is frustrate with dia and the amount of apework
08:04:32 <vincenz> it's amazing theres still no good diagram editor around
08:04:43 <vincenz> either you have fullblown presentational stuff like inkscape
08:04:52 <vincenz> or your stuck with age-old buggy crap like xfig or dia
08:05:41 <vincenz> shapr: blobs isn't the right thing tho
08:05:45 <vincenz> shapr: it aims at DAGs
08:07:55 <Saulzar> I've been using OODraw, not so fun either
08:08:01 <shapr> I like inkscape.
08:08:09 <vincenz> shapr: it's got too much blingbling
08:08:18 <vincenz> shapr: I want something simple, easy, quick to use
08:08:25 <vincenz> put some crpa on a sheet and voila, you got a concept
08:08:26 <Saulzar> I never thought of using it for diagrams
08:08:28 <vincenz> which you can then study
08:08:46 <shapr> Cool, a japanese Haskell book? http://www.amazon.co.jp/exec/obidos/ASIN/4839919623/nomusinolife-22/ref%3Dnosim/250-6684979-9233003
08:09:11 <shapr> What's up with the angry birds on the cover? http://images-jp.amazon.com/images/P/4839919623.01.LZZZZZZZ.jpg
08:09:33 <ptolomy> That image makes haskell seem so bad-ass.
08:09:35 <vincenz> shapr: c++ peckers
08:09:42 <ptolomy> "Use Haskell or birds will peck your fucking eyes out."
08:09:53 <vincenz> Haskell: do or die
08:10:06 <vincenz> that's probably what it says on the right under the title
08:10:57 <Saulzar> It's called "Haskell makes me angry"
08:11:23 <shapr> Maybe "Haskell gets you chicks." ?
08:12:37 <vincenz> those aren't chicks
08:12:39 <dons> evil haskell birds? hmm
08:12:40 <vincenz> "Haskell gets you peckers."
08:12:49 <dons> that is really cool
08:13:02 <dons> they look like they might be in a cabal
08:14:09 <vincenz> :D
08:15:20 <earthy> they look lean and mean to me
08:15:38 <dons> they look a bit like crazy seagulls. gone insane on lambdas
08:15:45 <dons> and now they want blood
08:16:05 <Saulzar> Picking Haskell apart
08:16:39 <dons> I would _so_ pick up that book if I saw it in a bookshop
08:25:11 <vincenz> Haskell: no birdshit
08:26:01 <ptolomy> hm.. I wonder if it'd be legally fine for me to make a haskell t-shirt with those birds on it..
08:27:12 <shapr> Anyone clueful about Oleg's HSXML and RSS.hs?
08:28:58 <vincenz> xahlee... I seriously wonder what's wrong with that guy
08:45:48 <sjanssen_> eerie
08:46:16 <sjanssen_> I just made the exact same point as SPJ in mailing list conversation, at nearly the same time
09:25:50 <MarcWeber> Where is the difference between (listToMaybe args) >>= read  and  liftM read (listToMaybe args) ?
09:28:49 <sjanssen_> MarcWeber: the first one doesn't type
09:28:57 <sjanssen_> @type liftM
09:28:57 <lambdabot> Not in scope: `liftM'
09:29:05 <sjanssen_> @type Control.Monad.liftM
09:29:06 <lambdabot> forall r (m :: * -> *) a1.
09:29:06 <lambdabot>         (Monad m) =>
09:29:06 <lambdabot>         (a1 -> r) -> m a1 -> m r
09:30:55 <MarcWeber> Both did compile but the >>= version resulted in "no read"
09:32:09 <Saulzar> >>= version is trying to read a "Maybe a"
09:33:47 <Saulzar> Since (>>=) 's  second argument is a function of type a -> Maybe b   which matches read for String -> Maybe b
09:36:29 <MarcWeber> Saulzar: I don't untderstand it.  shouldn't maybevalue >>= f   return case maybevalue of Nothing -> Nothing ; Just x -> f x ?
09:36:41 * vincenz rocks
09:37:15 <Lemmih> MarcWeber: Yeah, exactly.
09:37:42 <MarcWeber> So the read function should get the x from Just x, shouldn't it?
09:38:48 <Lemmih> MarcWeber: Yep, but 'f' will be of the type 'a -> Maybe b' and not 'a -> b' as you wanted.
09:40:00 <MarcWeber> So I had to use (read::String -> Int).
09:40:47 <Lemmih> MarcWeber: No. Look at the type of (>>=) again.
09:41:40 <MarcWeber> got it
09:41:43 <Lemmih> MarcWeber: (liftM f x === x >>= return.f)
09:49:31 <shapr> Has anyone written a time tracking program in Haskell?
09:49:41 <shapr> I've seen dons' program...
09:50:13 <pesco> shapr: Er, I just did.
09:50:35 <shapr> Oh?
09:50:38 <shapr> oh!
09:50:41 <pesco> Haven't seen dons' though! Where is it?
09:50:44 <shapr> darcs repo?
09:50:49 <pesco> shapr: Didn't I tell you that was what I was packaging?
09:51:05 <shapr> I heard about printable CEO, I just have no idea what it means :-)
09:51:24 <pesco> Oh, right. I was going to elaborate but you didn't ask. ;)
09:51:33 <pesco> So. http://khjk.org/sm/dist/
09:51:43 <pesco> There's karma-0.5.tar.gz and also the debs.
09:52:50 <pesco> shapr: "The Printable CEO, Part II" is time/task-tracking on paper. I did it in curses and added Karma scores.
09:53:27 <shapr> pesco: Is there a darcs repo available as well?
09:53:44 <MarcWeber> Lemmih: what do you mean by ===?
09:53:56 <vincenz> blegh
09:54:57 <vincenz> anyone read the rumor of the new osx dualbooter?
09:55:07 <vincenz> it will specifically allow windows-xp installation
09:55:18 <vincenz> do I smell ms pushing?
09:55:37 <Lemmih> MarcWeber: 'is the same as'
09:55:51 <vincenz> Lemmih: canonical isomorphism?
09:57:16 <MarcWeber> Lemmih: Let's hope I won't hask any questin about >>= again ;)
09:58:31 <Lemmih> vincenz: I think so.
09:58:59 <vincenz> any cters around?
10:10:24 <MarcWeber> When calling runInteractiveProcess  do I have to close all handles explicitely or can I do (in, _ ,_ , _) = runInteractiveProcess ..?
10:11:55 <vincenz> MarcWeber: handles always have to be closed explicitly
10:12:14 <Lemmih> They do?
10:12:19 <vincenz> hmm
10:12:22 <vincenz> welll flushed at least
10:12:30 <vincenz> anways
10:12:42 <vincenz> what's the use of only in?
10:14:18 <MarcWeber> vincenz: I'm using wmii and there is an application with which I can set the viewed screen (though you don't have a screen->many windows relation but a screen n:m window relation.. (implemented by tagging the windows)..
10:14:51 <MarcWeber> How do I (strict) read before closing the handle?
10:15:13 <vincenz> just read it all
10:15:17 <vincenz> it's an infinite list
10:15:20 <vincenz> end of list = closure
10:15:22 <vincenz> or it hangs
10:15:34 <vincenz> err... let me rephrase that
10:15:39 <vincenz> the list does not end until the process ends
10:15:46 <vincenz> if you read an element that's not there yet, your program waits
10:16:37 <MarcWeber> So I don't close stdout but in and err.
10:17:09 <vincenz> just in
10:19:57 * araujo back from univ
10:25:20 <bd_> @pointless \a -> f a a
10:25:21 <lambdabot> join f
10:25:28 <bd_> hmm
10:25:32 <lennart> howdy
10:25:44 <bd_> hi
10:25:48 <shapr> hej lennart, hur mÃ¥r du?
10:25:52 <bd_> 'join'... join isn't thje right type for that...
10:25:57 <bd_> oh
10:25:59 <bd_> Reader
10:26:30 <bd_> @pointless \a b -> select (a == []) b 
10:26:30 <lambdabot> select . ([] ==)
10:26:31 <bd_> err
10:27:28 <bd_> @pointless (\f -> f f) (\r a b -> select (a == []) b ((head a):(r (tail a) b)))
10:27:29 <lambdabot> join id (ap (ap . select . ([] ==)) . ap ((.) . (:) . head) . (. tail))
10:27:34 <bd_> hmm
10:27:43 <bd_> @pointless \a b -> (\f -> f f a b) (\r a b -> select (a == []) b ((head a):(r (tail a) b)))
10:27:44 <lambdabot> flip flip (const . ap (select =<< ([] ==)) . liftM2 (:) head . join . (. tail)) . flip . flip (join id)
10:29:20 <lennart> shapr: bara bra
10:38:09 <vincenz> @pointless \a b -> a == b
10:38:09 <lambdabot> (==)
10:39:59 <vincenz> @pointless \f g a b -> f (g a b)
10:39:59 <lambdabot> (.) . (.)
10:41:24 <vincenz> @pointless \f g a b c -> f (g a b c)
10:41:25 <lambdabot> (.) . (.) . (.)
10:41:25 <vincenz> @pointless \f g a b c d -> f (g a b c d)
10:41:26 <lambdabot> (.) . (.) . (.) . (.)
10:49:20 <shapr> lennart: Hey, I heard rumors long ago that BlueSpec was implemented by modifying ghc 5.04, is that NDA'd information?
10:49:21 <neologism> what is darcs equivalent of "cvs update" ?
10:49:41 <shapr> neologism: darcs pull -a
10:50:20 <neologism> thnx
10:50:42 <neologism> is there any "darcs for cvs users" doc somewhere?
10:51:35 <neologism> just found it :)
11:03:08 * araujo looks around
11:07:35 <Ulfalizer> is there some way to specify numbers that are guaranteed to compare less than (or greater than) every other number? that would be pretty handy for some recursive base cases.
11:07:54 <Ulfalizer> like the way the ieee float  inf  and  -inf  work
11:08:28 <lennart> Ulfalizer: for which type?
11:08:35 <Ulfalizer> lennart: ints
11:08:44 <ulfdoz> For bounded types, there are min- and maxBound, iirc.
11:09:19 <lennart> and you can always make your own type with extra infinity elements
11:09:29 <Ulfalizer> ulfdoz: how is it used? i'm still new to haskell.
11:09:42 <ulfdoz> Ulfalizer: Like a constant value.
11:09:50 <lennart> > minBount < 5
11:09:51 <lambdabot>  Not in scope: `minBount'
11:10:01 <lennart> > minBound < 5
11:10:02 <lambdabot> Add a type signature
11:10:15 <Ulfalizer> ah
11:10:16 <lennart> > minBound < (5::Int)
11:10:17 <lambdabot> True
11:10:18 <Ulfalizer> i see how it works now
11:10:25 <Ulfalizer> yeah, that was what i discovered :)
11:10:49 <Ulfalizer> thanks for the help
11:10:56 <ski> > minBound :: Float
11:10:57 <lambdabot>  add an instance declaration for (Bounded Float)
11:10:57 <lambdabot>   In the expression: minBound :: Float
11:10:57 <lambdabot>   In the definition of `joz': joz = minBound :: Float
11:11:09 <ski> @type minBound
11:11:10 <lambdabot> forall a. (Bounded a) => a
11:31:15 <xX[ReP]Xx> who maintains haskell.org?
11:35:47 <twb> xX[ReP]Xx: man whois
11:36:20 <xX[ReP]Xx> twb note that i didn't ksk who owns the domain.
11:36:24 <xX[ReP]Xx> ask
11:36:43 <eamelink> But it might give you an indication :P
11:37:21 <dozer> hi
11:38:05 <dozer> I've spent since xmas trying to write useful software in standard ML,
11:38:10 <dozer> and while the language is fine,
11:38:24 <dozer> the library support and documentation has stopped me getting any real work done
11:38:40 <dozer> a guy at work told me to try Haskell
11:39:04 <twb> Haskell is like SML, but with some improvements.
11:39:31 <dozer> I found the ml type-system meant that nearly always code wouldn't compile rather than contained bugs
11:39:34 <twb> There are a couple of things "missing", though, like the complete gooey module system.
11:39:35 <dozer> which was nice - comming from Java
11:39:45 <dozer> ok
11:39:56 <twb> dozer: Compared to Java, Haskell and SML are almost identical.
11:40:22 <dozer> twb: so it should be a not impossible task to port my sml to haskell?
11:40:37 <twb> lisppaste2: url?
11:40:37 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
11:40:55 <twb> dozer: if you have a small block, try pasting it there and I'll try to translate it :-)
11:41:13 <dozer> thanks for the offer, but it's about 2k lines
11:41:29 <twb> Hence "a small bit".
11:41:40 <twb> Most of it shouldn't need modification.
11:41:50 <twb> Except minor things like : and :: are the other way around in Haskell.
11:42:17 <twb> And let in end doesn't have and 'end' in Haskell :-)
11:42:36 <lisppaste2> dozer pasted "a bit of sml" at http://paste.lisp.org/display/18664
11:43:53 <twb> dozer: the first stanza becomes "data ontology = Ontology [directive]"
11:44:50 <twb> I forget how to do records in Haskell.
11:45:42 <lisppaste2> twb annotated #18664 with "approximate translation" at http://paste.lisp.org/display/18664#1
11:46:40 <dozer> thx - looks similar enough to do without extensive whailing and gnashing of teath
11:46:53 <twb> *wailing, teeth
11:47:06 <twb> @tutorial
11:47:07 <lambdabot> Unknown command, try @list
11:47:09 <twb> Grr.
11:47:15 <twb> http://haskell.org/tutorial/, IIRC.
11:47:28 <dozer> :(
11:47:37 <dozer> :)
11:47:51 <dozer> oh - and the tutorial apt-gets as well
11:47:57 <twb> Yes.
11:48:40 <twb> dozer: there's probably some SML<->Haskell migration documentation around, too.
11:48:52 <dozer> is there a particular interpreter/compiler I should start out with?
11:49:09 <twb> ghc is the usual compiler.
11:49:29 <twb> The hugs interpreter is a little faster than ghci (ghc's interpreter).
11:49:48 <Descolada|Work> what is SML?
11:49:55 <twb> Descolada|Work: Standard ML.
11:50:16 <twb> Descolada|Work: a language that features somewhere between gopher and APL in Haskell's ancestry, I think.
11:50:21 <twb> Er, gofer.
13:59:52 --- topic: '["Submit a paper to the Haskell Workshop:", "http://haskell.org/haskell-workshop/2006", "Haskell is still the language of choice for discriminating hackers", "logs:", "http://tunes.org/~nef/logs/haskell/", "http://www.haskell.org/learning.html", "We put the Funk in Funktion", "Vote on a European #haskell get-together: http://snappoll.com/poll/84228.php"]'
13:59:52 --- topic: set by franka on [Sun Mar 26 11:37:55 2006]
13:59:52 --- names: list (clog joloc_ _shawn ski ihope olliej Dreadshoot perspectival tennin Nomius SamB noj qwr_ Twigathy tic RyanT5000 joloc Poeir wchogg xerox MokuskerekHarc Trixsey turok rashakil Dark-Side jonkri Descolada|Work SyntaxNinja palomer wilx` Ulfalizer cmeme esap ed-209 benc_ Yango cmunier astrolabe bd_ cptchaos jak int-e kpreid_ neurogeek shrimpx_ kzm Saulzar huga triplah timbod arjanb mathrick viblo kisu juhp twb gadolin Pupeno eamelink Nioate)
13:59:52 --- names: list (Lemmih BlurredWe sieni Philippa_ luke-jr_ eno-away sjanssen mattam araujo pesco lisppaste2 eyck NameTab edwinb slipstream danly Lokadin drbean orbitz norpan liyang earthy ulfdoz @shapr binary42 bolrod Khisanth lambdabot shawn vincenz metaperl- Muad_Dibber moonlite Igloo Magical1 scw cbus Pseudonym sellout glasser Plareplane _samx_ ValarQ cods borism dcoutts rasfar cognominal isydor lucca gdsx jgrimes SimonRC eivuokko audreyt thedward ozone)
13:59:52 --- names: list (integral magagr kaol xX[ReP]Xx wolverian davidmccabe mokus emu dons Cale tessier mux ohub jks gzl Spark Lycurgus_ resiak neologism zamez flux__ Korollary Hmm_| xerox_ rkeene musasabi llappala kpk psnl mornfall lome petekaz metaperl greenrd akemp svens Wallbraker jlouis spo0nman kosmikus Maddas ibid pejo dcoutts_ wli djw kolmodin_ johs ksandstr WillKW dfhaii alch` CLxyz arguile Lunar^ dany2k Excedrin)
13:59:59 <RyanT5000> i find it expecting me to have a lot of unix stuff set up
14:00:07 <metaperl-> RyanT5000: you arent trying to install hIDE are you? I heard it is a bear
14:00:12 <RyanT5000> i have cygwin, but none of my libraries are in it or anything
14:00:22 <xerox> ?pl next resp = resp
14:00:23 <lambdabot> next = id
14:00:24 <RyanT5000> no i'm just trying to build hsSDL
14:00:32 <Lemmih> RyanT5000: My SDL bindings don't work on Windows.
14:00:37 <RyanT5000> ah
14:00:45 <Lemmih> At least not without cygwin.
14:01:10 <RyanT5000> does the final executable need to run in cygwin as well?
14:01:27 <RyanT5000> i don't mind using cygwin for parts of the build process, but i'd like a bona fide exe
14:01:32 <RyanT5000> for the final output
14:01:56 <metaperl-> a one-line definition is creating huge problems for me.. .can someone figure out the issue: http://rafb.net/paste/results/T3cYsS89.html
14:02:41 <xerox> metaperl-, the problem resides in the context.
14:02:49 <metaperl-> xerox: meaning?
14:03:06 <ihope> The problem isn't with process but with how you're using it.
14:03:19 <metaperl-> is process a builtin?
14:03:19 <xerox> You're trying to `process' a list.
14:03:21 <metaperl-> @type process
14:03:21 <lambdabot> Not in scope: `process'
14:03:23 <ihope> Apparently you were trying to pass a function into process.
14:03:43 <xerox> While the function process accepts a number and returns a number.
14:03:57 <metaperl-> hmmm: http://www.haskell.org/tutorial/patterns.html  
14:04:02 <metaperl-> that's where it came from
14:04:32 <RyanT5000> what's the line where you're using it?
14:04:36 <Lemmih> RyanT5000: I don't know. I would've tested it if I had a Windows box.
14:04:51 <metaperl-> this is the whole program: http://rafb.net/paste/results/Prs6IM87.html
14:05:07 <Dreadshoot> anyone tried FC++?
14:05:38 <metaperl-> Dreadshoot: or the functionals in Boost.org
14:05:54 <ihope> Well, I can see that there's no definition of init anywhere...
14:06:01 <RyanT5000> Lemmih: thanks; could you tell me if there's any part of it in particular that i should look at if i'm trying to get it to work on windows?
14:06:43 <metaperl-> changing process to "id" works
14:07:06 <ihope> Ah, yes. Try adding type annotations.
14:07:13 <Dreadshoot> metaperl: functionals in boost.. how similar to haskell is that implementation?
14:07:24 <ihope> Wait, wait... I see the problem!
14:07:25 <metaperl-> Dreadshoot: I dont know
14:07:31 * metaperl- looks up FC++
14:07:35 <xerox> metaperl-, oh-uhm.
14:08:03 <ihope> Indeed, it is that you haven't defined init. init has been defined elsewhere, but it doesn't do what you want.
14:08:11 <ihope> So define init :-)
14:08:35 <Dreadshoot> http://www-static.cc.gatech.edu/~yannis/fc++/tutorial.html i havent tried it either yet
14:08:42 <metaperl-> The formal review for FC++ has completed. I am sorry to say that FC++
14:08:42 <metaperl-> is not accepted into boost at this time
14:08:50 <metaperl-> http://lists.boost.org/boost-announce/2004/04/0041.php
14:09:51 <Dreadshoot> well who cares about if its in boost or not :)
14:10:08 <Lemmih> RyanT5000: You should look at the options in the SDL.cabal and SDL.buildinfo files. I'm not sure what they should contain on Windows.
14:10:12 <metaperl-> so, it sounds like Boost functionals are going to be more popular overall... I would read their criticism to know why to not use it
14:10:27 <RyanT5000> Lemmih: thanks; i'll let you know if i make any progress
14:11:15 <metaperl-> ihope: thanks. fixed
14:11:26 <Lemmih> RyanT5000: The Setup.lhs file is also borked.
14:12:01 <RyanT5000> ah
14:12:34 <Dreadshoot> !seen x
14:12:57 <ihope> Hmm...
14:13:45 <ihope> newtype ReaderArrow a b c = ReaderArrow {runReaderArrow :: (a -> b) -> a -> c} -- this right?
14:16:08 <RyanT5000> Lemmih: if i'm trying to compile *just* /Graphics/UI/SDL/Joystick.hsc, what do I use? do I need to run it through a separate C preprocessor, or is there some way i can get GHC to recognize it (it's complaining about the file format)
14:19:17 <RyanT5000> Lemmih: nvm, i just found hsc2hs which seems to be what needs to happen
14:20:14 <Lemmih> I'm off to bed. Good luck!
14:20:22 <RyanT5000> k; thanks for the help, and the library
14:23:17 <Dreadshoot> anyone got hs-plugins to work in win?
14:27:54 <RyanT5000> anyone know how to change the C include file path for hsc2hs?
14:33:37 <ski> ihope : newtype ReaderArrow r a b = ReaderArrow {runReaderArrow :: a -> r -> b}
14:34:17 <ihope> Ah, yes.
14:34:30 <ski> (ihope : what you said was the CoKleisli of the Context Comonad)
14:34:42 <ihope> Whoa...
14:35:15 <ski> data Context s a = C (s -> a) s
14:35:43 <ihope> Okay. If a monad is a piece of CPS, what's a comonad?
14:35:45 <ski> data CoKleisli w a b = CK (w a -> b)
14:35:56 <ski> data Kleisli m a b = K (a -> m b)
14:36:09 <ihope> @docs Control.Comonad
14:36:10 <lambdabot> Control.Comonad not available
14:36:17 <ski> ihope : what do you mean by 'monad is a piece of CPS' ?
14:36:45 <ihope> (>>=) :: m a -> (a -> m b) -> m b -- turns a monadic a into a CPS a
14:36:57 <ski> http://www.eyrie.org/~zednenem/2004/hsce/Control.Comonad.html
14:37:39 <ski> (=>>) :: Comonad w => w a -> (w a -> b) -> w b
14:41:41 <ihope> @hoogle Monad m => m a -> b -> m b
14:41:42 <lambdabot> Prelude.asTypeOf :: a -> a -> a
14:41:42 <lambdabot> Prelude.const :: a -> b -> a
14:41:42 <lambdabot> Prelude.seq :: a -> b -> b
14:42:18 <ski> are you attempting to find corresponding to '(>>)' ?
14:42:39 <ihope> No, I'm trying to find the complement of (.>>).
14:42:53 <ski> '(.>>)' is worthless (imo)
14:43:08 <ski> it's an attempt to be corresponding to '(>>)'
14:43:28 <ski> of course, it won't work that way, due to not fully dualizing
14:44:22 <Dreadshoot> dons: there?
14:44:34 <ski> iirc 'wa .>> b = fmap (const b) wa' (by comonadic laws)
14:45:02 <ski> so, it's not an operation specific to comonads, at all, it can be defined for any functor
14:45:20 <ihope> @type \a b -> Control.Monad.liftM (const b) a
14:45:21 <lambdabot> forall a1
14:45:21 <lambdabot>                  a
14:45:21 <lambdabot>                  (m :: * -> *).
14:45:21 <lambdabot>                (Monad m) =>
14:45:21 <lambdabot>                m a1 -> a -> m a
14:45:23 <Dreadshoot> or anyone knows if lambdabot would compile in win?
14:48:26 <ihope> Let's see...
14:48:52 <ihope> 1:02:03 AM 4/5/06 wasn't long ago :-)
14:49:20 <ihope> (And that's using the crazy American format, by the way, not the more sensible European one.)
14:49:38 <ski> mixed endian
14:55:29 <RyanT5000> i'm using hsc2hs, and it's giving me a linker error while trying to link the ModuleName_hsc_make.o into ModuleName_hsc_make.exe; it can't find __stginit_ZCMain or ZCMain_main_closure; does anyone know what objects these are in, and where i can find them?
14:56:28 <ihope> @index for
14:56:28 <lambdabot> bzzt
14:56:37 <ihope> Hmm.
14:56:38 <Yango> @index bzzt
14:56:38 <lambdabot> bzzt
14:56:46 <ihope> @index while
14:56:46 <lambdabot> bzzt
14:56:49 <ihope> @index until
14:56:50 <lambdabot> Prelude
14:56:54 <ihope> @type until
14:56:54 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
14:56:59 <ihope> Aha.
14:58:06 <ihope> Now we need muntil :: Monad m => (a -> m Bool) -> (a -> m a) -> m a -> m a
14:58:41 <Ulfalizer> is there some way to have a where clause or similar that is shared between a set of guarded equations?
14:59:41 <ski> @type Control.Monad.Cont.ContT
14:59:42 <lambdabot> forall a (m :: * -> *) r.
14:59:42 <lambdabot>           ((a -> m r) -> m r) -> Control.Monad.Cont.ContT r m a
14:59:53 <ski> @type Control.Monad.Cont.ContT (>>=)
14:59:54 <lambdabot>   Occurs check: cannot construct the infinite type: t = (t -> t1) -> r
14:59:54 <lambdabot>   Expected type: (a -> (t -> t1) -> r) -> (t -> t1) -> r
15:00:14 <ihope> @type \x -> Control.Monad.Cont.ContT (x >>=)
15:00:15 <lambdabot> forall a (m :: * -> *) r.
15:00:15 <lambdabot>               (Monad m) =>
15:00:15 <lambdabot>               m a -> Control.Monad.Cont.ContT r m a
15:00:27 <ski> er, right :)
15:00:37 <ski> so
15:01:01 <ski> \ma -> ContT (ma >>=)  ::  Monad m => m a -> ContT b m a
15:01:43 <ski> uncurry (=>>) :: Comonad w => (w a,w a -> b) -> w b
15:03:38 <Ulfalizer> ah, never mind, i had a stupid layout problem
15:04:01 <ski> \(ContextT wab wa) -> wab wa  ::  Comonad w => ContextT a w b -> w b  -- ihope, i think this is possibly answer to your 'If a monad is a piece of CPS, what's a comonad?'
15:04:23 <ihope> Um...
15:04:24 <ski> err
15:04:31 <ski> no
15:04:39 <ski> \(ContextT wab wa) -> wa =>> wab  ::  Comonad w => ContextT a w b -> w b  -- ihope, i think this is possibly answer to your 'If a monad is a piece of CPS, what's a comonad?'
15:04:41 <ski> i meant
15:05:24 <ski> 'Context' seems in some way to be dual to 'Cont'
15:07:32 <ihope> @index Context
15:07:33 <lambdabot> Data.Graph.Inductive.Graph, Data.Graph.Inductive
15:07:41 <ihope> ...So what is Context?
15:07:48 <ski> http://www.eyrie.org/~zednenem/2004/hsce/Control.Comonad.Context.html
15:08:50 <ski> (http://www.eyrie.org/~zednenem/2004/hsce/ is the index page for this lib)
15:10:39 <ihope> We wish you are Merry Christmas.
15:11:14 <Descolada|Work> and a merry thanksgiving
15:11:58 <Descolada|Work> i made a webpage for a used to be special person today :D
15:12:08 <Descolada|Work> the ... end
15:17:19 <RyanT5000> anyone know what ZCMain_main_closure is all about?
15:17:29 <RyanT5000> and __stginit_ZCMain
15:17:37 <RyanT5000> i'm trying to figure out what i need to link with to get those
15:18:34 <Yango> @type list
15:18:35 <lambdabot> Not in scope: `list'
15:19:31 <Descolada|Work> @hoogle list
15:19:31 <lambdabot> Control.Monad.List :: module
15:19:31 <lambdabot> Data.List :: module
15:19:31 <lambdabot> List :: module
15:19:42 <ski> RyanT5000 : do you have 'module Main' in your file ?
15:19:58 <RyanT5000> no, i'm trying to build the output from hsc2hs
15:20:16 <ski> hm ..
15:20:22 <RyanT5000> it compiles a c file into a .o, then it tries to link that using ghc
15:20:47 <RyanT5000> Executing: C:\ghc\ghc-6.4.1\bin\ghc.exe Joystick_hsc_make.o -o Joystick_hsc_make 
15:20:47 <RyanT5000> .exe 
15:20:47 <RyanT5000> C:/ghc/ghc-6.4.1/libHSrts.a(Main.o)(.text+0x1d):Main.c: undefined reference to ` 
15:20:47 <RyanT5000> __stginit_ZCMain' 
15:20:47 <RyanT5000> C:/ghc/ghc-6.4.1/libHSrts.a(Main.o)(.text+0x43):Main.c: undefined reference to ` 
15:20:48 <RyanT5000> ZCMain_main_closure' 
15:20:50 <RyanT5000> collect2: ld returned 1 exit status
15:20:57 * ski hasn't used hsc2hs :/
15:21:27 <ski> (though the error seems familiar .. though can't remember now .. possibly too tired)
15:22:12 <RyanT5000> actually if i just run that commandline listed after "Executing:" i get the exact same thing
15:22:20 <RyanT5000> so it's totally ghc giving me that error
15:23:21 <arjanb> i got that error once when the main function wasn't in the module thing
15:24:00 <RyanT5000> hm
15:26:30 <NameTab> how can I make it possible to run my main function which also uses wxHaskell from ghci?
15:27:08 <NameTab> never mind, now it works
15:27:38 <NameTab> can't run it twice though, segmentation fault lol
15:28:41 <Descolada|Work> codequake!
15:42:22 <RyanT5000> i am going to kill someone
15:42:27 <RyanT5000> specifically
15:42:38 <RyanT5000> whoever decided SDL.h should #define main to SDL_main
15:43:06 <RyanT5000> how do you justify #defining main???
15:43:23 <Descolada|Work> by feeling bad about it for 2 seconds
15:43:28 * dcoutts nominates SDL.h for the underhanded C contest
15:43:32 <RyanT5000> lol
15:44:01 <RyanT5000> if it were supposed to be underhanded, i'd be congratulating them
15:44:09 <RyanT5000> but it's supposed to be a friggen library
15:47:30 <araujo> hello
15:47:40 <Descolada|Work> sup
15:56:25 <dons> moin!
15:57:42 <metaperl-> @type map
15:57:42 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
15:57:45 <metaperl-> @type fmap
15:57:46 <lambdabot> forall (f :: * -> *) b a.
15:57:46 <lambdabot>    (Functor f) =>
15:57:46 <lambdabot>    (a -> b) -> f a -> f b
15:57:55 <mwc> RyanT5000, yeah, that drove me nuts!
16:00:04 * Descolada|Work loves haskel eating ice cream doughnuts
16:01:24 <RyanT5000> mwc: heh i just made /SDL/include/WithoutRedefiningMain/SDL.h
16:01:43 <RyanT5000> #include "../SDL.h"
16:01:43 <RyanT5000> #undef main
16:01:49 <Descolada|Work> lol
16:01:52 <RyanT5000> pointed all my stuff at that
16:02:07 <Descolada|Work> what is the point of #defining a new main anyway?>
16:02:33 <RyanT5000> it says in the source file that they want to make it so that main gets called from WinMain or something
16:02:45 <RyanT5000> basically they're trying to do something sneaky to "make your life easier"
16:03:01 <RyanT5000> of course, in the event that you actually have a clue what you're doing, it's just going to totally screw you over
16:03:09 <Descolada|Work> id rather they make my life "richer" but i know they cant do that :(
16:03:24 <sjanssen_> is this main thing well documented?
16:03:47 <mwc> WinMain? Is this some windows compatibility garbage?
16:03:48 <RyanT5000> no idea; i've just been trying to compile a libsdl <-> haskell binding on windows
16:04:00 <RyanT5000> well basically
16:04:11 <RyanT5000> if you want to make a program without a text console on windows
16:04:23 <RyanT5000> you need to define WinMain instead of main
16:04:31 <RyanT5000> and tell the compiler you're doing so
16:04:36 <mwc> of course
16:04:40 <RyanT5000> then it won't generate all the text support
16:04:50 <RyanT5000> (unless you explicitly ask it)
16:04:55 <mwc> so why do the SDL devs try to foist that on everybody
16:05:03 <mwc> instead of putting something on the windows docs?
16:05:03 <RyanT5000> well
16:05:08 <sjanssen_> ah, so the define is really aimed at cross platform compatibility?
16:05:09 <RyanT5000> i dunno?
16:05:13 <RyanT5000> yeah i think that's it
16:05:18 <RyanT5000> but they could've done something like
16:05:35 <RyanT5000> #define PORTABLE_MAIN whateverTheyHaveCurrentlyForMain
16:05:42 <RyanT5000> that way you'd at least have to do it on purpose
16:05:52 <RyanT5000> so you'd just say
16:05:54 <RyanT5000> int PORTABLE_MAIN
16:06:00 <RyanT5000> ()
16:56:40 <sjanssen_> mfix is way cool
17:07:52 <metaperl> convenient aliases for types are done how? for example String is [Char]
17:08:03 <sjanssen_> type String = [Char]
17:11:10 <metaperl> thanks
17:12:22 <ptolomy> Would "Program compiled using GHC, -fvia-c, and a few -foptc flags segfaults" be considered a known issue? My own damn fault for getting compiler-flag happy?
17:13:22 <ptolomy> (This is my first time having a Haskell program segfault. Does this make me a bad person?)
17:13:25 <sjanssen_> ptolomy: probably depends on the flags.  Can you paste it somewhere?
17:13:43 <ptolomy> where?
17:14:53 <sjanssen_> umm
17:14:56 <sjanssen_> can't remember the URL
17:14:59 <ptolomy>  --make -fvia-C -fglasgow-exts -O3 -funbox-strict-fields -fexcess-precision -optc-ffast-math -optc-O3 -no-recomp
17:15:03 <ptolomy> Those are the flags.
17:15:06 <dons> use -optc-O2
17:15:12 <dons> gcc is segfaulting
17:15:16 <ptolomy> 'k.
17:15:16 <dons> well, producing bad code
17:15:23 <dons> it is a known issue
17:15:27 <dons> well, at least to me
17:15:30 <ptolomy> excellent. Thanks.
17:15:44 <sjanssen_> sounds like something dons would know ;)
17:15:58 <dons> it's not ghc's fault, since it is the flag to gcc that produces bad code. gcc gets confused too easily.
17:16:17 <dons> yes, sjanssen, right ;)
17:18:22 <Dreadshoot> dons: will lambdabot compile under win?
17:19:10 <dons> I think so.
17:19:21 <dons> with maybe a couple of plugins needing to be disabled
17:19:26 <dons> it has been done before
17:19:32 <Dreadshoot> okay
17:20:03 <dons> youu disable plugins that don't work by editing config.mk and tweaking the static plugin list.
17:20:46 <dons> if you get it working, add the output of @version to http://haskell.org/haskellwiki/Lambdabot
17:21:00 <dons> hmm. if it even configures..
17:21:00 <dons> we'll see
17:21:34 <Dreadshoot> ok, will try next time on the comp that i got ghc on
17:28:11 <Rawr321> Hi my small company is looking at Haskell to target with our new development system (at some point will even include an OS)
17:28:39 <Rawr321> Can you guys answer a few of my questions?  Such as does haskell have variants so that we dont have to deal with types at all?
17:28:51 <RyanT5000> is there a function in Prelude with type (a -> b -> c) -> ((a, b) -> c), that does exactly what you'd think something like that would do?
17:29:07 <sjanssen_> Rawr321: Haskell is all about types
17:29:23 <RyanT5000> if you don't like strong typing don't use haskell
17:29:25 <sjanssen_> @type uncurry
17:29:26 <lambdabot> forall c b a. (a -> b -> c) -> (a, b) -> c
17:29:40 <RyanT5000> thanks sjanssen
17:30:05 <RyanT5000> btw Rawr, strong typing is awesome
17:30:09 <Rawr321> I was under the impression it was less about types, letting you actually solve the problem 
17:30:45 <Rawr321> Our current compiler takes a function like this: f(x,y) = x+y  Its a math based language and right now were targetting Python but we want something better
17:30:54 <RyanT5000> my understanding is that it can seem less-strongly-typed than something like C++,  because you don't always have to specify all the types (it'll figure some stuff out for you)
17:31:02 <RyanT5000> however it's actually a long stronger than C++'s type system
17:31:24 <RyanT5000> because there are no casts (to my knowledge - but i'm just a newb)
17:31:49 <Rawr321> so if it compiled a function of our language: f(x,y)=x+y into the equavilant haskell, would it have to specify types?
17:32:14 <RyanT5000> no, if you had something like that you wouldn't have to specify the type
17:32:28 <Rawr321> and the language Perl, for testing version 6, is targetting haskell and it uses dynamic types
17:32:39 <RyanT5000> haskell is statically typed
17:33:00 <RyanT5000> but really someone else should be answering your questions :P
17:33:07 <RyanT5000> i'll probably make a fool of myself in about 30 seconds, if i haven't already
17:33:44 <Rawr321> Perhaps I should look into it further myself but I was trying to get some help from a community like this since im sure you guys know more
17:34:03 <RyanT5000> i still don't completely understand your question though
17:34:04 <RyanT5000> basically
17:34:14 <RyanT5000> in a language like Perl, LISP, etc.
17:34:15 <Rawr321> We need variants (dynamic types)
17:34:17 <RyanT5000> each value has a type
17:34:41 <RyanT5000> whereas in haskell/c++/etc. each variable has a type
17:34:47 <metaperl> Rawr321: must you develop a language? there are plenty of languages with dynamic types
17:34:48 <Rawr321> so that we dont have to specifiy type and so that: x = 5; x = "string"; works
17:35:05 <benc_> is there a #darcs channel?
17:35:06 <metaperl> Rawr321: Perl does that. Tcl does that. Python does that. Ruby does that.
17:35:07 <Rawr321> If you had read above, its not I, but the company I work for.
17:35:20 <resiak> benc_: /j #darcs and see?
17:35:24 <benc_> hehe
17:35:26 <metaperl> Rawr321: oh and they are requiring a new language?
17:35:28 <Rawr321> Yes and once again, if you read above, I said our compiler is currently targetting Python but we want something better
17:35:55 <Rawr321> There paying me to write it and its for some unique research (im not in that dept though)
17:36:02 <metaperl> oh. good luck Rawr321
17:36:09 <sjanssen_> Rawr321: why do you need dynamic typing?
17:36:11 <RyanT5000> by "targeting python" you mean it outputs python, and you then use a python compiler to get the binary, right?
17:36:18 <metaperl> comp.lang.misc or comp.compilers on Usenet might be a good forum for your question
17:36:20 <araujo> Rawr321, and what is your question (if any)?
17:36:36 <Rawr321> Wow...you guys keep asking me the same questions that I said above
17:36:53 <RyanT5000> that's cause no one seems to really understand what you're asking
17:36:59 <metaperl> I dont think Haskell runs much faster than Python
17:37:15 <Rawr321> Can I use haskell as more of a dyntamic typed language?  Say, leave the Haskell compiler/runtime up to figuring out the type?
17:37:25 <Rawr321> Speed isnt an issue really
17:37:37 <palomer> haskell has dynamic typing
17:37:40 <araujo> Rawr321, Haskell implementations offer type inference.
17:37:49 <sjanssen_> Rawr321: Haskell can infer types.  However, if you get the types wrong, it will fail with a type error.
17:38:06 <palomer> you guys are forgetting about dynamic types
17:38:07 <araujo> So you don't need to keep specifying the types of every expression.
17:38:12 <Rawr321> Can you give me an example of getting the types wrong?  Do you mean it cant change from types?
17:38:32 <araujo> Rawr321, are you talking about weak types?
17:38:44 <ihope> What's wrong with the strongly typed stuff?
17:38:57 <sjanssen_> Rawr321: well, first of all your sequential assignment example isn't even possible in Haskell.  We don't have destructive assignment
17:38:59 <araujo> where, we can have things like: "1" + 1 == "11" 
17:39:09 <Rawr321> Im not sure if that is the term, ive noly been stufying english a few years.  I believe they are called variants, being able to change from type to type?
17:39:14 <ihope> > "1" ++ show 1
17:39:15 <lambdabot> "11"
17:39:24 <ihope> > read "1" + 1
17:39:25 <lambdabot> 2
17:39:42 <araujo> ihope, not exactly that
17:40:11 <araujo> Rawr321, right, to change types between values within a specific expression
17:40:15 <Rawr321> And ihope ive answered your question about atleast two times already
17:40:20 <araujo> that's weakly typed
17:40:33 <Rawr321> Ah yes then yes weakly/dynamically typed
17:40:44 <araujo> no, Haskell implementations are strong typed
17:41:00 <Rawr321> Hmmm perhaps it isnt a prime choice then...
17:41:05 <araujo> why not?
17:41:29 <Rawr321> The language is weak and dynamic so it would be easier to use a target language that supports that
17:41:40 <araujo> if your goal is to design a wealy typed, i don't see why Haskell wouldn't work.
17:41:49 <araujo> weakly typed language*
17:42:00 <sjanssen_> Rawr321: it's a good idea to write a compiler in Haskell.  It isn't such a great idea to compile an imperative weakly typed language into Haskell code
17:42:01 <araujo> mm.. why?
17:42:27 <araujo> Rawr321, you could actually ask to the perl6 people, they look doing very well with Haskell
17:42:32 <Rawr321> sjanssen_ -- Why does it matter what the compiler is coded in?  That has nothing to do with what im talking about
17:42:57 <araujo> i don't see what's wrong about using Haskell to implement a weakly/dynamically typed language.
17:42:58 <ihope> Okay, let's see here...
17:43:07 <Rawr321> I thought you said you couldnt araujo?
17:43:14 <araujo> Rawr321, uh?
17:43:14 <sjanssen_> Rawr321: yes, that was just me telling you what Haskell is good for.  read the second sentence.
17:43:19 <resiak> He said that Haskell isn't weakly typed.
17:43:25 <araujo> Rawr321, re-read what i said please
17:43:32 <resiak> He did not say that you couldn't write a compiler for a weakly-typed language in Haskell.
17:43:53 <Rawr321> I know, I was talking about where he said "Haskell implementations are strongly typed"
17:45:03 <araujo> Rawr321, yes, and i meant that
17:45:24 <Rawr321> Then how could I easily compile a dynamic typed language into haskell?
17:45:26 <araujo> I don't see how that implies you can't design a weakly/dynamically typed language on Haskell
17:45:37 <Rawr321> It doesnt
17:45:39 <Rawr321> But 
17:45:56 <araujo> perl6 is dynamically typed
17:46:00 <Rawr321> Wouldnt the compiler have to declare it a type?
17:46:01 <Rawr321> Yes I know
17:46:06 <araujo> there you got a terrific example
17:46:10 <Rawr321> Yes
17:46:12 <sjanssen_> araujo: he wants to take a dynamic language and spit out Haskell.  He doesn't want to write a compiler or interpreter *in* it.
17:46:25 <Rawr321> Correct
17:46:48 <araujo> mmm....
17:46:54 <ihope> data Dynamic = Integer Integer | String String | Function (Dynamic -> Dynamic) | Null -- defines a type that can hold an Integer, a String, a function, or nothing
17:47:15 <Rawr321> ahhh a variable can have multiple types?
17:47:19 <sjanssen_> NO!
17:47:25 <sjanssen_> heheh
17:47:30 <araujo> Rawr321, why dynamic?, and i don't see your kind of reasoning.
17:47:32 <Rawr321> your assigning it multiple values?
17:47:33 <ptolomy> There aren't really variables by most definitions..
17:47:45 <ihope> Well, this is only one type, but it can *hold* values of different types.
17:47:57 <Rawr321> araujo I dont believe I have a choice if its dynamic or not?
17:48:19 <ihope> I guess you'll want tuples too, and lists...
17:48:30 <Rawr321> Lists are a big aspect of the language yes
17:48:40 <ihope> data Dynamic = Integer Integer | String String | Pair Dynamic Dynamic | List [Dynamic] | Function (Dynamic -> Dynamic) | Null
17:48:47 <araujo> Rawr321, so, you can use a static language too?
17:49:03 <Rawr321> Hmmm?
17:49:33 <Rawr321> "static language"?  
17:49:39 <Rawr321> why do you ask this and what do you mean
17:49:40 <araujo> yes, static typed*
17:50:11 <araujo> i mean, if you don't have any preference over static or dynamically typed?
17:50:40 <Rawr321> Sorry dont know what static means, lemme look up one moment.
17:50:55 <Rawr321> Poor english skills hehehe sorry
17:51:04 <araujo> statically typed
17:51:11 <Rawr321> yes like C?
17:51:15 <ihope> Static typing = strong typing = static typing, pretty much.
17:51:21 <araujo> right
17:51:41 <Rawr321> In the documentation, to declare variables/functions they have no type, you simply use them such as:
17:51:44 <ptolomy> if your source language has a lot of imperative constructs, you may find haskell to be more difficult to translate into..
17:52:03 <Rawr321> f(x,y,z) = x+y-z
17:52:20 <ihope> ptolomy: aren't monads at least somewhat good at imperative stuff?
17:52:21 <Rawr321> No declarations you see?
17:52:29 <araujo> Rawr321, but pay attention to what you are looking for, no declaring explicit type variables doesn't say anything about a language being static or dynamically typed.
17:52:51 <araujo> You don't need to explictly declare types on Haskell for example.
17:53:00 <sjanssen_> ihope: I think monads are a good human interface . . . I wouldn't want to write an imperative language that targets them though
17:53:06 <Rawr321> Hmm?  So this means static:  x = 5; x = "string"   ?
17:53:21 <sjanssen_> Rawr321: that means absolutely not static
17:53:24 <araujo> no no
17:53:36 <RyanT5000> well araujo, if nowhere in the whole language there are any type variables, then isn't it essentially dynamically typed?
17:53:37 <ihope> That's unless 5 and "string" happen to have the same type...
17:53:37 <ptolomy> ihope, Oh, I'd call them quite good. However, automatically translating imperative code to imperative code is probably at least a bit easier than translating to monadic haskell.. 
17:53:40 <Rawr321> araujo you have gotten me confusid
17:53:40 <araujo> that actually means nothing about these concepts :-]
17:53:56 <araujo> Rawr321, it's because these concepts are very confusing.
17:54:26 <Rawr321> I see
17:54:31 <araujo> RyanT5000, no, because the language implementation can have a type inference system as Haskell implementations do
17:54:38 <RyanT5000> right but what is it inferring from?
17:54:45 <araujo> So you don't need to make types explicit.
17:54:51 <RyanT5000> when i say the "whole language" i'm including things like +
17:55:01 <RyanT5000> if all your builtins and everything are defined for all types
17:55:06 <RyanT5000> and you can't define new types
17:55:11 <RyanT5000> that's essentially the same as having a single type
17:55:12 <Rawr321> I dont know a lot of these english words about the types but here maybe if I tell you a little bit of the language it will help you tell me if I can do it or not
17:55:15 <ptolomy> Off topic, but what languages apart from Lisp have dynamic typing that can be specified for efficiency purposes?
17:56:06 <araujo> RyanT5000, that's what the inferecen system takes care of :-)
17:56:19 <ihope> Okay, let's see this dynamic language...
17:56:40 <Rawr321> In Daemon the code: x = 10 turns into x = 10; in python.  Very easy translation.  But to go from x = 10 to C's code like int x = 10l is harder
17:57:09 <ihope> Well, above, you can use x = Integer 10
17:57:14 <ihope> With the above, rather.
17:57:51 <Rawr321> See, i mean.  If you get input then it makes this difficult in a language like C because you have to define the types
17:57:52 <RyanT5000> araujo, i know what the inference system does - but if there's only one possible type it can infer, that seems kind of like it'd degenerate into dynamic typing
17:58:06 <ihope> With the appropriate definitions, you can still use x = 10.
17:58:45 <Rawr321> You guys y giving me headache.  Maybe I just tell them to stay with targetting Python? Yes?
17:58:47 <RyanT5000> Rawr: i think you're confused about your language design
17:59:26 <Rawr321> No, I know it.  They want a language that does not have to declare types and can change types are some of the requirments.  We have a working compiler that goes to Python
17:59:28 <RyanT5000> the values in your langauge still need to be typed
17:59:49 <Rawr321> Our compiler doesnt have to touch types 
17:59:49 <RyanT5000> so you should make a type in your target language that can represent any value from your source language
17:59:55 <RyanT5000> yes it does
18:00:00 <Rawr321> No it doesnt
18:00:02 <RyanT5000> how is your compiler going to know what to do when someone says
18:00:11 <RyanT5000> "Apple" + 5?
18:00:14 <ptolomy> Rawr321, Would it be entirely unreasonable to say that your compiler is more of a translator?
18:00:20 <ihope> I think that would return "Apple5".
18:00:21 <sjanssen_> sqrt("elephant")
18:00:29 <ptolomy> > mouse
18:00:30 <lambdabot>  Not in scope: `mouse'
18:00:31 <RyanT5000> that's a much better example sjanssen
18:00:37 <Rawr321> then it translate "Apple" + 5 into "Apple" + 5; and calls the Python interpreter
18:00:46 <RyanT5000> so you're not really writing a compiler
18:00:50 <ihope> Python sounds pretty good, then.
18:00:52 <resiak> sjanssen_: % perl -le 'print sqrt("elephant")'
18:00:53 <resiak> 0
18:00:54 <araujo> RyanT5000, uh?
18:00:57 * resiak hides.
18:00:58 <Rawr321> Yes, we are writing a compiler Ryan
18:01:13 <RyanT5000> but if all your language semantics are defined in terms of another language
18:01:15 <RyanT5000> what's the point?
18:01:19 <RyanT5000> semantics means "meaning"
18:01:26 <Rawr321> I know what that means 
18:01:41 <Rawr321> and I thought it meant more along like "plans"? not "meaning"?
18:01:55 * ptolomy asks all the interpeters on his system what the square root of "elephant" is..
18:01:58 <ihope> I thought it was what something does...
18:02:11 <Rawr321> Maybe I wrong?
18:02:12 <RyanT5000> syntax is the form of the language
18:02:16 <Rawr321> Yes
18:02:21 <RyanT5000> semantics are the meaning of the statements in that form
18:02:28 <Rawr321> Different syntax and easier to write code is one of Daemon's goals 
18:02:36 <Rawr321> Very ehhh math like?  
18:02:43 <Rawr321> Natural is the word
18:02:45 <Rawr321> Very natural.
18:02:56 <RyanT5000> yeah, but what i'm trying to say is
18:03:04 <RyanT5000> if you take something like
18:03:08 <RyanT5000> {stuff} + {stuff}
18:03:19 <RyanT5000> and translate that into {stuff} + {stuff} in python
18:03:25 <RyanT5000> or in any other language
18:03:29 <Rawr321> Its not always that simple
18:03:33 <RyanT5000> and let that language define the meaning of "+"
18:03:42 <Rawr321> Why does compiler need to know that?
18:03:50 <Rawr321> Compiler is like a translator
18:04:04 <sjanssen_> Rawr321: most compilers are more complicated than that
18:04:08 <Rawr321> Why does it need to know and bother with errors and such when Python interpreter does that?
18:04:17 <Rawr321> Yes I know, but most compilers target assembly and such
18:04:24 <RyanT5000> that's what makes the python interpreter a real compiler/interpreter
18:04:28 <sjanssen_> anyway, this conversation is wildly offtopic . . .
18:04:31 <Rawr321> Why put in such complicated meaures when Python interpreter does that
18:04:31 <ihope> Hmm... sounds like Python's the way to go.
18:04:38 <RyanT5000> true sjanssen
18:05:02 <Rawr321> OK I guess stick with Python.  Though this Haskell is interesting
18:05:23 <RyanT5000> alright, i wish you well rawr
18:05:43 <sjanssen_> Rawr321: yeah, Haskell is awesome.  Like I said earlier, you should try writing your compiler *in* Haskell, but outputting Python or something
18:05:44 <Rawr321> I was just told to look at ehhh I think functional is it, yes, thats it.  I was told to look for functional dynamic language
18:05:55 <Rawr321> know of one?
18:05:59 <sjanssen_> Haskell is awesome for things like parsing, performing transformations
18:05:59 * araujo didn't get what Rawr321 was saying though
18:06:10 <RyanT5000> have  you looked at lisp, rawr?
18:06:11 <sjanssen_> Rawr321: Scheme, Lisp
18:06:13 * ptolomy would target Lisp. Makes for easy translation of parse tree to code..
18:06:22 <Rawr321> Lisp is ugly :)
18:06:27 <ihope> Heh.
18:06:28 <ptolomy> who will see it?
18:07:00 <Rawr321> Were looking for something more along the lines of math like.  Like f(x) = x*2   See, like ehh algebre?
18:07:33 <Rawr321> Haskell looked like that to me at first but I see complex examples now and I know its not
18:07:49 <ihope> Well, f(x) = x*2 works in Haskell.
18:07:51 <RyanT5000> why does it matter what you're translating *into*?
18:08:06 <ihope> Most of the things you've given us will work in Haskell.
18:08:26 <Rawr321> I have to go.  ihope they will?   Perhaps I will tell them to look into Haskell then?
18:08:28 <araujo> > let f x = x * 2 in f 4
18:08:29 <lambdabot> 8
18:08:41 <Rawr321> oooh yes!
18:09:03 <Rawr321> Thank you very much lambdabot show me another exmaple before i go plz?
18:09:23 <ihope> Rawr321: well, if you implement dynamic types in Haskell, you'll have to specify the types--sort of ironic--but not if you stick with static types.
18:09:34 <sjanssen_> > let factorial n = product [1..n] in factorial 10
18:09:35 <lambdabot> 3628800
18:09:36 <metaperl> Rawr321: Perl6 is being prototyped using Haskell. it is a huge and heavy-duty project
18:09:53 <Rawr321> Yes I know.  How does it do dynamic types in it htough?
18:10:04 <metaperl> Rawr321: /join #perl and see :)
18:10:10 <metaperl> i mean /join #perl6
18:10:18 <Rawr321> hehe yes tomorow I will thank you must go byebye
18:10:20 <metaperl> it is not a bowl of cherries
18:10:24 <metaperl> goodnight
18:10:31 <Rawr321> bowl of cherries? is that a saying?
18:10:38 <metaperl> :) in the US , yes
18:10:43 <ihope> Rawr321: well, you can have a declaration that will allow you to convert types into a value of the Dynamic type.
18:10:44 <metaperl> it means, it is not easy by any means
18:10:46 <Rawr321> hehehe I like that
18:10:50 <metaperl> lol
18:10:52 <Rawr321> Ah I see
18:11:00 <Rawr321> Thank you i be back tomorow bye
18:11:22 <ihope> Haskell's classes are nice when working with dynamic typing as well.
18:12:33 <sjanssen_> gotta love a language where the semantics are defined as "oh, whatever Python would do"
18:12:39 <RyanT5000> lol
18:12:45 <resiak> In other words "my language is Python"
18:13:21 <ihope> Heh.
18:13:28 <ihope> @index Dynamic
18:13:28 <lambdabot> Data.Dynamic
18:13:33 <ihope> @docs Data.Dynamic
18:13:34 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Dynamic.html
18:14:00 <ihope> Oh, sheesh.
18:14:01 <dons> > toDyn (1 :: Int)
18:14:02 <lambdabot> <<Int>>
18:14:11 <ihope> That's interesting...
18:14:29 <ihope> > toDyn 1
18:14:29 <lambdabot> Add a type signature
18:14:36 <ihope> > toDyn (1 :: Integer)
18:14:37 <lambdabot> <<Integer>>
18:14:46 <RyanT5000> is that implemented in-language?
18:15:05 <dons> > let d = toDyn (7 :: Int) in case fromDynamic d of Nothing -> undefined ; Just x -> x :: Int
18:15:06 <lambdabot> 7
18:15:10 <dons> no, it's just a library
18:15:20 <dons> like most things in haskell, you don't need to extend the language
18:15:30 <RyanT5000> yah but i mean is the library implemented in pure haskell
18:15:39 <dons> yup, of course
18:15:55 <RyanT5000> how does that example ihope just used work?
18:15:56 <dons> let d = toDyn (7 :: Int) in case fromDynamic d of Nothing -> undefined ; Just x -> x :: Bool
18:15:57 <RyanT5000> > toDyn 1
18:15:58 <lambdabot> Add a type signature
18:16:01 <ihope> > dynApp (dynApp const (1 :: Int)) (2 :: Int)
18:16:02 <lambdabot> Couldn't match `Dynamic' against `t -> t1'
18:16:02 <sjanssen_> surely Dynamic must require something beyond H98?
18:16:13 <dons> no, its H98, i think
18:16:24 <dons> it's a pretty obvious system if you look at how Typeable is defined
18:16:31 <RyanT5000> hm
18:16:37 <dons> you just map each type to a value at runtime representing that type
18:16:43 <ihope> > toDyn (const :: Int -> Int)
18:16:43 <lambdabot> Couldn't match `Int' against `t -> t1'
18:16:44 <dons> and pair each value with tis type representation
18:16:52 <ihope> > toDyn (const :: Int -> Int -> Int)
18:16:53 <lambdabot> <<Int -> Int -> Int>>
18:16:54 <dons> i.e. runtime tags, just as you would in a 'real' dynamically typed language
18:17:04 <RyanT5000> hm
18:17:05 <dons> dynamic typing is just a special case of static typing
18:17:11 <RyanT5000> right
18:17:19 <dons> as Bob Harper always says
18:17:21 <RyanT5000> and i guess that "Add a type signature" is just like the last pattern
18:17:27 <RyanT5000> so if it can't match anything real, it chooses that
18:17:29 <ihope> Hmm...
18:18:00 <RyanT5000> (i've been writing in C++ for 8 years and haskell for 3 days... i haven't quite adjusted yet)
18:18:06 <dons> hehe
18:18:12 <dons> we have a few people like this.
18:18:36 <dons> hopefully it's like waking up from some kind of dream where programming was ugly and error prone
18:18:40 <RyanT5000> since i figured out that i hated C++ about 3 years ago, haskell is the first language i haven't hated
18:19:00 <Dreadshoot> c++ aint ugly, its useful
18:19:05 <ihope> data Dynamic where Dynamic :: Typeable a => a -> TypeRep -> Dynamic
18:19:12 <ihope> Hmm...
18:19:14 <dons> ihope?
18:19:21 <ihope> > typeOf (3 :: Int)
18:19:22 <lambdabot> Int
18:19:32 <ihope> Hmm...
18:19:32 <dons> data Dynamic = Dynamic TypeRep Obj
18:19:39 <ihope> Whatever.
18:19:54 <dons> type Obj = forall a . a
18:20:03 <dons> so, its a pair of a type tag and a value
18:20:12 <dons> doesn't it suck keeping types around at runtime!
18:20:18 <sjanssen_> aha!
18:20:27 <dons> ah ...
18:20:39 <sjanssen_> Dynamic requires rank 2 types
18:20:50 <sjanssen_> (I think thats what the forall business means)
18:21:18 <dons> that's just polymorphic
18:21:25 <dons> not rank-2.
18:22:02 <dons> the comment in the src says "using a function type would also work"
18:22:38 <dons> this representation of dynamics goes back to Cardelli . let me find the paper
18:23:31 <ihope> So Obj can be anything?
18:23:56 <ihope> Hmm...
18:23:58 <RyanT5000> is there any reason haskell wouldn't be practical for an OS implementation language?
18:24:07 <dons> it's actually been used to write an OS
18:24:12 <dons> and proved practical
18:24:18 <ihope> Dynamic (typeOf "foo") ()
18:24:24 <dons> ?where House
18:24:25 <lambdabot> http://www.cse.ogi.edu/~hallgren/House/
18:24:25 <RyanT5000> awesome; what's it called?
18:24:25 <Dreadshoot> dons: so has assembly :)
18:24:28 <ihope> Why wouldn't that work?
18:24:35 <RyanT5000> cool
18:24:42 <dons> it's an abstract type, ihope. so you can't build it directly
18:24:47 <dons> you have to go through the safe interface
18:24:55 <ihope> Ah, right :-)
18:25:03 <dons> otherwise, yeah, you've got yourself a runtime unsafeCoerce#
18:25:08 <ihope> @index unsafeCoerce#
18:25:08 <lambdabot> bzzt
18:25:27 <ihope> @type GHC.Prim.unsafeCoerce -- a parse error?
18:25:28 <lambdabot> Not in scope: `GHC.Prim.unsafeCoerce'
18:25:30 <ihope> Oops.
18:25:33 <ihope> @type GHC.Prim.unsafeCoerce# -- a parse error?
18:25:34 <lambdabot> forall b a. a -> b
18:25:38 <ihope> Oh.
18:25:43 <dons> ?wiki Libraries_and_tools/Operating_system
18:25:44 <lambdabot> http://www.haskell.org/haskellwiki/Libraries_and_tools/Operating_system
18:25:52 <dons> ^^ there Ryan
18:26:14 <dons> it's really cool seeing House boot up on a Thinkpad in a couple of seconds
18:26:24 <dons> into an X-like environement
18:27:00 <dons> at icfp 2005, Thomas Hallgren presented a talk describing house, using a slide program running on House on his laptop
18:27:10 <dons> it was very very cool
18:27:16 <RyanT5000> wow
18:27:40 <RyanT5000> is it preemptively concurrent?
18:27:58 <dons> it uses ghc's scheduler, which is preemptive
18:28:04 <RyanT5000> oh ok
18:28:32 <RyanT5000> isn't that actually cooperative via the memory allocator?
18:28:49 <RyanT5000> so if i wrote a tight loop with no allocation i could still crash the machine
18:29:27 <davidmccabe> Is the haskell workshop open to the general public?
18:29:33 <dons> yeah, i think they actually have a scheduler on top, for user programs
18:29:45 <dons> the ghc scheduler would be for kernel thhreads,
18:29:48 <RyanT5000> ah ok
18:30:07 <dons> my memory is a bit vague 
18:30:10 <RyanT5000> it seems like a language without mutable variables would lends itself to security pretty well
18:30:14 <dons> davidmccabe, if you pay the fee, I think so.
18:30:25 <davidmccabe> dons: I see. I can't find any of this information on the web site.
18:30:37 <dons> yeah, it's used for 'high assurance' software by a number of companies
18:30:51 <dons> writing things like web servers, OS and other stuff. 
18:30:55 <RyanT5000> hm
18:31:00 <Igloo> davidmccabe: Registration probably isn't open yet
18:31:22 <davidmccabe> Ah.
18:31:26 <RyanT5000> i'll have to check it out more; thanks for the pointer
18:31:32 <davidmccabe> Any rough estimates how much admission will cost?
18:31:47 <dons> about $50 US, iirc?
18:31:57 <Igloo> I was about to guess double that, but I'm not sure
18:32:11 <dons> I think maybe its $50 if you also go to ICFP?
18:32:24 <dons> not sure.
18:32:31 <ihope> Hmm...
18:32:38 <Igloo> There's also a student discount, and maybe an ACM member discount
18:32:41 <davidmccabe> Ok. Is it a meeting of haskell wizards only, or will there be anything that newbies can understand and appreciate?
18:33:00 <dons> davidmccabe, have a look at last year's papers.
18:33:06 <dons> there was a talk on darcs
18:33:08 <davidmccabe> Oh, excellent idea.
18:33:10 <dons> one about lambdabot and yi ;)
18:33:18 <metaperl> davidmccabe: you are not from South Carolina are you?
18:33:35 <Igloo> Aha: http://www.cs.ioc.ee/tfp-icfp-gpce05/page.php?page=reginfo
18:33:36 <dons> the haskell workshop is probably easier for non-academics than, say, ICFP, where you'll want some type theory
18:33:58 <darrint> What does Num [(Float, Float)] mean?
18:34:00 <Igloo> So 50EUR if you don't dither
18:34:08 <darrint> Instances of...
18:34:26 <Igloo> HW is mostly understandable to non-theoretical Haskellers, I'd say
18:34:27 <ihope> It means you tried to use [
18:34:30 <ihope> Whoops.
18:34:38 <ihope> It means you tried to use [(Float, Float)] as a number.
18:35:10 <RyanT5000> ?HOpenGL
18:35:10 <lambdabot> Unknown command, try @list
18:35:11 <darrint> Full message is... Instances of (Floating Integer, Num [(Float,Float)]) required for definition of regularPolygon
18:35:18 <RyanT5000> @index HOpenGL
18:35:19 <lambdabot> bzzt
18:35:24 <Igloo> Oh, no, there is a surcharge if you don't go to ICFP
18:35:31 <palomer> hrmph
18:35:34 <palomer> europe seems down!
18:35:39 <Igloo> so around 100EUR for HW
18:35:44 <darrint> hmm... really I tried not to. :-)
18:35:55 * RyanT5000 prepares to be newbified
18:36:04 <RyanT5000> how do i look up HOpenGL with lambdabot?
18:36:10 <davidmccabe> metaperl: I'm from portland.
18:36:14 <davidmccabe> Ok, thanks for the info, folks.
18:36:24 <metaperl> oh
18:36:49 <dons> look it up?
18:36:56 <ihope> darrint: you tried to use [(Float,Float)] as a number and Integer as a floating point thingy.
18:37:01 <dons> do you mean, what exactly, RyanT5000?
18:37:05 <RyanT5000> er
18:37:11 <davidmccabe> So I finally found a haskell tutorial that actually shows you how to write programs. Problem is, it skips too much of the theory, so I still don't really understand what's going on.
18:37:12 <ihope> Were you taking the square root or logarithm or something of an Integer?
18:37:15 <darrint> hmmm... narrowed it down to something simple.
18:37:17 <RyanT5000> i guess i'm not totally sure, lol
18:37:21 <RyanT5000> any information
18:37:27 <RyanT5000> i'm just trying to figure out lambda bot
18:37:30 <darrint> test 0 = []
18:37:31 <darrint> ; test n = n : (test n-1)
18:37:33 <RyanT5000> i know where the docs are for HOpenGL ;)
18:37:33 <dons> ?version
18:37:34 <lambdabot> lambdabot 3p396, GHC 6.4.1 (Linux i686 3.20GHz)
18:37:34 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
18:37:36 <dons> grab it and build iit!
18:37:40 <dons> then run it locally
18:37:44 <darrint> oops, without the ;
18:37:47 <RyanT5000> alright, thanks :)
18:38:07 <dons> it's good for your haskell-fu
18:38:12 <ihope> darrint: test (n-1)
18:38:24 <darrint> DOH
18:38:25 <ihope> Otherwise it'll parse as (test n) - 1
18:38:30 <dons> and even better if you contribute a new plugin ... hint hint ;)
18:38:43 <RyanT5000> lol yah
18:39:10 <dons> you can write a simple plugin in , hmm, 3 lines of code
18:39:14 <dons> so anyone could do it!
18:39:31 <RyanT5000> i get it :)
18:41:20 <RyanT5000> lol so i've inverted my shell
18:41:27 <RyanT5000> i'm now using :! primarily
18:41:49 <darrint> (1 :: Integer) ** (3 :: Float)
18:42:44 <int-e> @type (**)
18:42:45 <lambdabot> forall a. (Floating a) => a -> a -> a
18:42:51 <ihope> (1 :: Float) ** (3 :: Float)
18:43:04 <ihope> fromInteger (1 :: Integer) ** (3 :: Float)
18:43:14 <ihope> Both those will work, I think.
18:43:32 <int-e> no. the two arguments need to have the same type
18:43:37 <ihope> > (1 :: Float) ** (3 :: Float)
18:43:38 <lambdabot> 1.0
18:43:41 <ihope> > fromInteger (1 :: Integer) ** (3 :: Float)
18:43:42 <lambdabot> 1.0
18:43:58 <darrint> how do you instruct haskell to turn the integer into a float?
18:44:13 <ihope> fromInteger
18:44:14 <int-e> woops. sorry, I missed the fromInteger.
18:44:57 <RyanT5000> @docs Graphics.Rendering.OpenGL
18:44:57 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/OpenGL/Graphics-Rendering-OpenGL.html
18:46:02 <RyanT5000> so what do people think about IntelliSense et al?
18:46:28 <RyanT5000> i ask this because it seems relatively simple to pull off with template haskell
18:46:41 <dons> hmm?
18:46:59 <RyanT5000> that thing in visual studio where if you type something such as printf(
18:47:10 <RyanT5000> it then brings up a pop-up with the type of printf(
18:47:16 <RyanT5000> with help about the arguments and stuff
18:47:40 <dons> but you don't need TH. not even sure that would work. you hook in the compiler and the standard libs, a la visual haskell
18:48:02 <RyanT5000> does visual haskell do that?
18:48:13 <RyanT5000> i can't run that cause i'm on visual studio 2005 and i lost my 2003 install media :-/
18:48:58 <dons> yeah, I think there's some such thing in visual haskell. 
18:49:23 <RyanT5000> i've read pro and con articles about the idea of that kind of stuff
18:49:44 <RyanT5000> although i'm basically of the mindset "if my IDE can remember something for me, why should I have to remember it"
18:49:47 <RyanT5000> maybe i'm just lazy though :P
18:50:41 <dons> I just use ^P and ^N in vim to tab complete. that's about all you need if you know what you're doing,I think
18:51:07 <dons> and another script infers type signatures. and I use lambdabot to do a bit of pointfree work. that's about it.
18:51:25 <RyanT5000> good to know; i should get myself setup with that stuff
18:51:28 <dons> fancy tool support is overrated.
18:51:29 <RyanT5000> right now i'm using eclipse
18:51:49 <RyanT5000> eclipse's FP support is terrible
18:51:59 <RyanT5000> i think it's like one guy working on it
18:52:06 <RyanT5000> he's doing a great job, but there's just too much to do
18:52:33 <dons> install linux, and get hacking ;) much better to use a whole platform built for writing code on
18:52:56 <mux> may I suggest FreeBSD ? :-)
18:53:05 <RyanT5000> oh believe me, i wish i could
18:53:05 <mux> especially if you also intend to read system sources
18:53:08 <RyanT5000> but my situation is this:
18:53:17 <RyanT5000> i'm trying to finish a game i'm working on before September
18:53:19 <dons> well, I use OpenBSD. but linux is a good path in.
18:53:21 <RyanT5000> at which point i'm going to law school
18:53:48 <RyanT5000> my linux experience is insufficient;  it'd take me at least a month to get up to speed
18:53:53 <RyanT5000> and the game has to run on windows
18:53:58 <RyanT5000> and my code is currently in C# mostly
18:54:13 <dons> yeah, fair enough. if you're not going to be coding for a living. and need C# (!)
18:54:30 <dons> it's good for your karma though.
18:54:36 <mux> sounds fair enough indeed, though fyi, unix systems have mono for c#
18:54:42 <ihope> Dang, I forgot...
18:54:45 <RyanT5000> yeah but mono's too slow to run a game in
18:54:49 <RyanT5000> (at this time)
18:54:58 <RyanT5000> actually i might switch to linux while in law school
18:55:05 <RyanT5000> i'll only need like a text editor, lol
18:55:07 <ihope> I was clearing out my computer's RAM so I could play a game. Then I forgot, and BANG!...
19:00:18 <dons> mux, what do you work on? do you use haskell for work on study?
19:00:22 <dons> s/on/or/
19:20:57 * araujo looks around
19:29:38 <RyanT5000> if i'm using a function that returns IO (Maybe Int), is there something cleaner i can do than store the value, then use a case to extract the Just value or fail if it's Nothing?
19:32:44 <dons> > let x = Just 7 in fromMaybe undefined x
19:32:44 <lambdabot> 7
19:33:34 <dons> > let x = Nothing in fromMaybe undefined x
19:33:34 <RyanT5000> ah ok i think i see what that does; thanks
19:33:34 <lambdabot> Add a type signature
19:33:36 <dons> > let x = Just 8 in fromJust x
19:33:37 <lambdabot> 8
19:33:50 <dons> > let x = Nothing in fromJust x
19:33:50 <lambdabot> Add a type signature
19:34:19 <RyanT5000> wait; where are fromMaybe and fromJust?
19:34:31 <dons> > let x = Nothing :: Maybe () in fromJust x
19:34:31 <lambdabot> Exception: Maybe.fromJust: Nothing
19:34:43 <dons> one lets you proivde a default. the other just errors
19:35:00 <dons> so fromMaybe is more general. fromJust will exit on a pattern match failure
19:35:33 <dons> ?type Maybe.fromMaybe
19:35:33 <lambdabot> forall a. a -> Maybe a -> a
19:35:49 <dons> ?type Mayebe.fromJust
19:35:50 <lambdabot> lexical error
19:36:12 <RyanT5000> thanks :)
19:36:13 <dons> ?type Maybe.fromJust
19:36:14 <lambdabot> forall a. Maybe a -> a
19:37:13 <dons> note that using fromJust is like not looking for a null pointer. it's not the best programming practice, but ok for a quick hack
19:37:33 <RyanT5000> yeah
19:38:09 <RyanT5000> i'm getting back a value which is either a number of bits per pixel or Nothing, and if it's nothing then i have no good video modes
20:25:03 <mux> dons: sorry was away
20:25:35 <mux> dons: I was just embarrassed to not know anything about FP, so I started learning haskell to fix that gaping hole
20:26:03 <Korollary> good idea
20:34:37 <RyanT5000> what does ?Only unit numeric type pattern is valid" mean?
20:34:59 <RyanT5000> it's on each of the 0's in "rotate pitch::GLfloat (Vector3 1 0 0)"
20:35:55 <RyanT5000> ?type Graphics.Rendering.OpenGL.rotate
20:35:55 <lambdabot> forall c.
20:35:55 <lambdabot>             (Graphics.Rendering.OpenGL.GL.CoordTrans.MatrixComponent c) =>
20:35:55 <lambdabot>             c -> Graphics.Rendering.OpenGL.GL.CoordTrans.Vector3 c -> IO ()
20:36:29 <adu> OpenGL rocks!
20:36:43 <adu> and
20:36:44 <RyanT5000> lol i'm not quite sure how to take that
20:36:49 <adu> Haskell rocks too!
20:36:53 <RyanT5000> :)
20:36:59 <RyanT5000> but what does that error message mean?
20:37:02 <Lokadin> ls
20:37:04 <Lokadin> oops
20:37:08 <Smokey`> mmm, I know OpenGL very well (4 years experience), but no idea how the Haskell Bindigns are, so cant help you sorry...
20:37:09 <RyanT5000> it makes me think it's referring to () somehow
20:37:36 <RyanT5000> yah, i've certainly used the C version of glRotate plenty of times :)
20:38:17 <Smokey`> mmm, you seem to know HOpenGL, does it have GLX/WGL bindings, and how (if at all) does it handle extensions?
20:38:17 <adu> unit numeric type pattern might mean GLClamp type
20:38:44 <RyanT5000> ah ha!
20:38:55 <RyanT5000> :: binds less tightly than function application :-/
20:39:08 <adu> does that explain it?
20:39:11 <RyanT5000> sorry smokey, i'm just learning it
20:39:19 <Smokey`> RyanT5000: fair enough :)
20:39:21 <dons> it means you're using a number in a type declaration
20:39:45 <RyanT5000> nah GLfloat is right, it's just that i hadn't parenthesized the type tag
20:39:59 <dons> rotate pitch::GLfloat (Vector3 1 0 0 looks like a type annotation (because of ::) but actually has that Vector thingy at the end
20:40:09 <dons> yep
20:41:10 <Smokey`> oh, it uses GLUT... iew.
20:41:24 <RyanT5000> no, it has glut bindings
20:41:33 <RyanT5000> you have to use them :P
20:41:35 <RyanT5000> which i don't
20:41:44 <RyanT5000> i'm using SDL bindings temporarily
20:41:55 <Smokey`> RyanT5000: okay, so that means it DOES have WGL bindings then :)
20:42:03 <Smokey`> or GLX if oyu're on nix...
20:42:07 <RyanT5000> ah ok
20:42:25 <Smokey`> cant tell OpenGL to draw to a window iwthout OS-specific calls (WGL for Windows, GLX for X servers)
20:42:26 <RyanT5000> it's been a while since i've done any gl programming, and i only barely used wgl
20:42:42 <RyanT5000> right
20:43:30 <RyanT5000> wow... i'm totally overspecifying my types
20:43:42 <RyanT5000> this is so liberating, lol
20:44:06 <RyanT5000> i'm so trained from C++ to just randomly pick a type when i have several to choose from
20:45:10 <dons> just don't specify a type at all. it's almost always not required.
20:45:22 <dons> sometimes for various reasons you do want to pin things down though.
20:45:23 <RyanT5000> hm, good point
20:45:41 <Smokey`> dons: is there any way to get a list of all functions from a module (eg: from the standard prelude) within ghci or something else?
20:46:24 <RyanT5000> dons: do you normally not specify types for your top-level functions unless you run into problems?
20:46:45 <RyanT5000> although reallly you should take that as "if you were me, would you"
20:47:07 <dons> and its good documentation to specify them for top-level bindings
20:47:18 <Korollary> as a beginner it makes more sense to annotate because then the typecheck errors get clearer.
20:47:20 <mux> I've read it can be useful to limit the application of a function to a more limited set of types for optimization reasons
20:47:23 <dons> I always type top-level bindings
20:47:33 <dons> but I usually use a tool to infer the type for me
20:47:43 <dons> and insert the decl automagically
20:47:49 <RyanT5000> ah
20:48:04 <dons> yes. often you want to restrict functions to Int so the compiler can do tricks
20:48:12 <RyanT5000> ok
20:48:13 <dons> s/often/sometimes/
20:48:31 <RyanT5000> although
20:48:33 <dons> Smokey`, the documentation lists what's available from each module
20:48:38 <RyanT5000> can't it deduce that at compile-time anyway?
20:48:53 <dons> ?docs Data.List
20:48:53 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
20:49:13 <RyanT5000> i mean if i write a totally generic function, and it ends up being Int, isn't it going to instantiate a special Int-based version?
20:49:17 <dons> if there's some Int constraint somewhere, ghc will give you an Int functoin anyway
20:49:18 <RyanT5000> sort of like a C++ template
20:49:20 <mux> > flip (flip (-)) 1 2
20:49:21 <lambdabot> -1
20:49:24 <RyanT5000> ok
20:49:27 * mux gets ready for the IOHCC
20:52:06 <dons> here's an example of how I'd code with type annotationns: http://www.cse.unsw.edu.au/~dons/code/hmp3/Core.hs
20:52:36 <dons> miight be useful to look at . I always read other's code -- particular ghc libs -- when learning
20:53:05 <RyanT5000> yah, thanks!
20:53:18 <Smokey`> mmm, I think I'm going to try and reinvent the wheel, over my mid-semester break... start playing with C bindings in haskell,  try and implement my own OpenGL bindings (purely for fun)
20:53:34 <Smokey`> if i can get that far (IF!!!),  I
20:53:40 <mux> reinventing the wheel is nice for learning :-).
20:53:42 <Smokey`> I'll make an EGL implementation to follow suit.  which would be nice
20:54:00 <dons> or write a binding to some other lib we don't have yet?
20:54:07 <mauke> > flip flip 2 (-) 1
20:54:08 <lambdabot> -1
20:54:10 <dons> there must be a ton of gui libs out there..
20:54:11 <Korollary> libvorbis maybe
20:54:34 <mux> mauke: hmm, you look like a worthy oponnent for IOHCC :-)
20:54:42 <mux> opponent, rather
20:54:42 <Smokey`> dons: If I was going to write bindings for other libs, i'd write bindings for my own libs :)
20:55:02 <mauke> mux: lambdabot's @pl beats me
20:55:13 <mux> mauke: what's that?
20:55:21 <Smokey`> hmm, I wonder if my profiler would work :S   technically it should once it's compiled...
20:55:25 <Smokey`> hmmm
20:55:29 <dons> mauke, hehe.
20:55:32 <Smokey`> are there any good haskell profilers out there atm?
20:55:33 <mauke> it removes function arguments from your code
20:55:38 <mux> oh
20:55:42 <mux> automatic point-free conversion?
20:55:53 <mauke> yep. @pl == pointless
20:55:56 <dons> Smokey`, yes. a very good one: ghc
20:55:56 <dons> use -prof -auto-all
20:55:58 <mux> cool
20:56:16 <dons> then at runtime: ./a.out +RTS -p
20:56:21 <dons> will give you a a.out.prof file
20:56:22 <mux> @pl sqrt(2 + 3 * x)
20:56:22 <lambdabot> sqrt (2 + 3 * x)
20:56:28 <mux> hrm
20:56:36 <Smokey`> dons: pffft, mine's better ;)
20:56:37 <Smokey`> j/k
20:56:45 <mauke> @pl hypot a b = sqrt (a * a + b * b)
20:56:46 <lambdabot> hypot = (sqrt .) . (. join (*)) . (+) . join (*)
20:56:59 <mux> I would have expected sqrt . (2+) . (3*)
20:57:13 <mux> @pl foo x = sqrt(2 + 3 * x)
20:57:14 <lambdabot> foo = sqrt . (2 +) . (3 *)
20:57:16 <mauke> @pl \x -> sqrt (2 + 3 * x)
20:57:16 <lambdabot> sqrt . (2 +) . (3 *)
20:57:21 <mux> I'm not that bad at haskell !
20:57:27 <Smokey`> dons: what are some things haskell is lacking then?
20:57:41 <Korollary> Qt bindings?
20:57:45 <mux> @pl foo x = x * x
20:57:45 <dons> more libraries.
20:57:45 <lambdabot> foo = join (*)
20:57:58 <Smokey`> heh, I'm definately not doing that...  I'm an Xlib/Win32 purist :P
20:58:03 <mux> what the... I thought that was not possible
20:58:06 <dons> compare the libraries and tools page to , say, cpan
20:58:25 <Korollary> do we have an ssl library?
20:58:25 <dons> though we have a lot of theorem provers for some reason ...
20:58:32 <Korollary> dons: and raytracers!
20:58:34 <dons> I think so, maybe 2.
20:58:45 <dons> and ray tracers!
20:58:55 <dons> Haskell: the language of choice for discriminating ray tracers
20:59:04 <Smokey`> lol, ray tracers are easy... i've done too many, and I already have a C++ ray tracer as a current projec,t i'm not doing TWO at once.
20:59:17 <Smokey`> or rather, monte carlo path tracer...
20:59:19 <mux> write a meta-ray tracer
20:59:24 <Korollary> Smokey`: a directx binding then?
20:59:29 <mux> some code that will generate a ray tracer in any language
20:59:52 <Smokey`> Korollary: heh, I hate DirectX with a passion.
21:00:03 <dons> find some really popular lib in cpan and write a hakell version.
21:00:20 <Smokey`> cpan?
21:00:28 <Korollary> cpan.perl.org
21:00:30 <mux> the perl modules repository
21:01:04 <mux> are there expat bindings yet?
21:01:29 <Smokey`> mmm, I'll think about it while i'm in my Haskell lab today,  chances are i'm going to implement one of my own libs, or a graphics-related lib for windows though...
21:01:49 <Smokey`> I'm liking the idea of doing my own OpenGL bindings, and making an EGL implementation for them though
21:02:09 <Smokey`> if I could get a nice standard EGL implementation into Haskell, that'd eliminate the dirty, disgusting GLUT requirement.
21:02:37 <RyanT5000> ... can you seriously not use a type variable "a" in the constraint of a function, if a function it uses also uses a type variable called "a"?
21:03:31 <RyanT5000> no i think i misread something, nvm
21:03:47 <dons> no. that makes no sense.
21:03:54 <dons> ;)
21:04:00 <RyanT5000> yah i know :)
21:04:11 <Smokey`> dons: does Haskell have a standard low-level window management library,  such as Xlib/Win32 API/MFC ?
21:04:22 <Smokey`> and no i dont mean gtk/qt/wxwidgets
21:04:25 <RyanT5000> if you implement MFC, you should be shot
21:04:37 <RyanT5000> but i think i saw win32 bindings somewhere
21:04:39 <Smokey`> RyanT5000: I hate MFC too, dont worry :)
21:04:53 <Korollary> I thought there were some Win32 modules in ghc
21:05:32 <RyanT5000> here's a question i have: is it feasible to write a windowing system that's almost stateless?
21:05:40 <RyanT5000> lemme define what i mean
21:05:43 <Korollary> Graphics.Win32
21:06:02 <RyanT5000> there's a Document, and there's some other State thing (maybe a monad or something)
21:06:03 <Korollary> @index LPCTSTR
21:06:03 <lambdabot> bzzt
21:06:05 <RyanT5000> and each time you render
21:06:16 <RyanT5000> you reprocess the Document
21:06:29 <RyanT5000> and each time you get a keystroke/window drag/etc. you update State
21:06:36 <Korollary> RyanT5000: Is it possible to have stateless stdio?
21:06:51 <RyanT5000> yes - but i didn't say possible
21:06:56 <RyanT5000> and i don't mean
21:07:05 <Smokey`> RyanT5000: that's the exact reason I see myself doing most things in C++, and making bindings for haskell :P
21:07:16 <RyanT5000> well actually that's the reason i came to haskell :)
21:07:21 <RyanT5000> i want to write such a thing
21:07:28 <Smokey`> ...sounds inefficient.
21:07:32 <RyanT5000> becuase the whole Subject/Observer pattern is kicking my ass
21:07:37 <dons> hmm. there's bindings to Xlib.. -package X11  
21:07:49 <RyanT5000> when you have to implement Subject/Observer like a hundred times it becomes error-prone
21:08:03 <Korollary> I think a good windowing system could be written in haskell. It would be stateful, but should beat the heck out of anything else.
21:08:07 <RyanT5000> and in theory you don't need to re-examine parts of the document that haven't changed
21:08:29 <RyanT5000> smokey; do you write games?
21:08:33 <RyanT5000> or just other graphics stuff
21:08:38 <dons> isn't wxHaskell a good one?
21:08:46 <RyanT5000> is it 3d and very pretty?
21:09:02 <RyanT5000> like you'd see in a professional-looking videogame
21:09:06 <RyanT5000> that's what i need ;)
21:09:06 <dons> well, it's pretty. and there's also gtk2hs. that's very pretty
21:09:16 <dons> not sure.
21:09:20 <RyanT5000> nah i need shaders and everything
21:09:30 <RyanT5000> technically they don't need to be in the windowing system, but it'd be nice
21:10:01 <RyanT5000> ...crap
21:10:03 <RyanT5000> segfault
21:10:14 <RyanT5000> in SDL
21:10:35 <RyanT5000> oooh here's a good question: what's the easiest way for me to get a stack dump out of haskell?
21:10:54 <dons> by using -prof, I think
21:11:06 <dons> you'll see the call trace 
21:11:09 <RyanT5000> when launching my exe?
21:11:53 <RyanT5000> oh like if i run it from ghci?
21:12:20 <dons> so, compile with -prof -auto-all; run with +RTS -p ; then have it exit at the point you want th the trace. the file a.out.prof will hold the trace
21:12:22 * mux waves and heads to bed &
21:12:33 <RyanT5000> oh ok
21:13:19 <RyanT5000> "have it exit" ;)
21:13:22 <RyanT5000> by dumping core
21:13:47 <dons> hmm maybe. 'undefined' would be a bette rway.
21:13:56 <dons> if its crashing in C code. use gdb
21:14:05 <dons> and compile with -debug, for better symbols
21:14:07 <Smokey`> sorry was afk
21:14:14 <RyanT5000> yah i think it's crashing in the SDL binding
21:14:34 <Smokey`> RyanT5000: intially games, done a 2 year course in software development aimed at game dev... but I'm not soo much interestedi nthat anymore, I'm primarily computer graphics (both real time, and offline rendering)
21:14:44 <Smokey`> as well as physically-based simulation, so physics and hte likes.
21:14:48 <RyanT5000> ah ok
21:15:06 <Smokey`> dons: wxHaskell is decent, but I wouldn't call it a low-level window management library, it's a widgets/gui library...
21:15:59 <Smokey`> RyanT5000: if you want shaders, you'll need to use OpenGL/DirectX, and considering you're using Haskell, you've got ot use OpenGL. :)
21:16:20 <dons> ok. anyway. all the gui libs in the world are on 
21:16:21 <dons> ?wiki Libraries_and_tools/GUI_libraries
21:16:21 <lambdabot> http://www.haskell.org/haskellwiki/Libraries_and_tools/GUI_libraries
21:16:24 <Smokey`> which means you'll need extensions, which is what I asked you about before...  no idea how you'd go about handling extensions with HOpenGL
21:16:32 <dons> annd 
21:16:32 <dons> ?wiki Graphics
21:16:32 <lambdabot> http://www.haskell.org/haskellwiki/Graphics
21:16:37 <RyanT5000> they support a good deal of them
21:16:41 <Smokey`> dons: yeah i've looked at all of those
21:16:46 <dons> ?wiki Libraries_and_tools/Graphics
21:16:46 <lambdabot> http://www.haskell.org/haskellwiki/Libraries_and_tools/Graphics
21:16:46 <dons> I mean.
21:16:53 <dons> so if its not there -- you have a project!
21:17:27 <RyanT5000> oh man i love shader programming; i have no experience at it (i've written a really crappy cel-shading and outlining shader)
21:17:42 <RyanT5000> so i guess i was wrong earlier when i said i hate every language i know but haskell
21:17:46 <RyanT5000> i also love asm
21:17:49 <RyanT5000> all kinds of asm
21:17:56 <Korollary> It'll pass.
21:17:58 <RyanT5000> not that i want to write anything big in them...
21:18:06 <RyanT5000> lol no, it won't
21:18:16 <adu> i love ppcasm
21:18:19 <adu> but not x86
21:18:28 <RyanT5000> when i was 13 i read the whole 386 manual cover to cover for fun
21:18:30 <adu> i do not like x86 asm
21:18:30 <Smokey`> OOH, OOH!!! C bindings for Cg :D
21:18:57 <Smokey`> err, hakell bindings :S
21:18:58 <adu> RyanT5000: i read 2 of the three PowerPC manuals for fun
21:19:24 <RyanT5000> i just mean
21:19:28 <RyanT5000> i will always like asm
21:19:36 <RyanT5000> it's not a fading thing :)
21:19:49 <adu> i will like ppc asm until something better comes out
21:19:55 * tennin likes 6502 ASM
21:20:20 <RyanT5000> risc is fun too
21:20:40 <RyanT5000> branch delay slots are, in my experience, mostly useful for confusing the hell out of your TAs
21:21:12 <RyanT5000> with one innocent-looking assembler directive you can completely change the way your program works
21:21:17 <adu> RyanT5000: is that related to branch prediction?
21:21:23 <RyanT5000> sort of
21:21:46 <RyanT5000> basically the pipeline takes more than one cycle to figure out whether the branch is being taken or not
21:21:48 <Smokey`> RyanT5000: also, I generally find myself writing middle-ware libraries now (focused on math/physics/graphics), as opposed to applications... :P
21:22:06 <adu> RyanT5000: hm, sounds wierd, but interesting
21:22:06 <RyanT5000> so in the mean time, it executes the next listed instruction
21:22:18 <adu> only 1 instruction after?
21:22:23 <RyanT5000> right
21:22:28 <RyanT5000> by default the assembler will stick in a nop
21:22:31 <adu> ah ok, that sounds like it would be useful
21:22:39 <RyanT5000> yeah
21:22:44 <RyanT5000> compilers can make really good use of it
21:22:59 <adu> thats stupid, to have such a cool feature like that and use a nop
21:23:13 <RyanT5000> well the assembler can't transform your code
21:23:22 <RyanT5000> but you can turn that off
21:23:28 <RyanT5000> and make it so that it does in fact let you put something in there
21:23:49 <RyanT5000> but the great thing is that, on the assembler i was using, there's no syntax for that
21:24:04 <RyanT5000> there's just a directive at the top, that says "don't put in nops for me"
21:24:32 <RyanT5000> so now suddenly your instructions after branches are executed no matter what
21:24:42 <RyanT5000> instead of just if you fall through
21:24:53 <adu> who makes the 6502?
21:25:03 <Korollary> motorola
21:25:31 <adu> why is it i see nothing about Motorola at 6502.org?
21:26:18 <Korollary> I don't know. They had licensees in the past.
21:26:19 <RyanT5000> cannnot find -lHSrts_debug_p
21:26:28 <Korollary> ancient cpu. it was in the commodore 64.
21:26:32 <RyanT5000> where can i get that?
21:26:43 <RyanT5000> wow that is old
21:27:00 <tennin> also the 8-bit Nintendo
21:27:09 <adu> ppc is so beautiful
21:27:23 <adu> it saddens me that Apple is switching away from it
21:28:09 <Korollary> Find comfort in the fact that people arent writing in assembly so much.
21:28:15 <adu> heh
21:28:19 <benc_> hmm
21:28:30 <benc_> http://en.wikipedia.org/wiki/6502
21:28:33 <adu> Korollary: they should be
21:28:33 <RyanT5000> shader assembly's also pretty fun
21:28:34 <benc_> suggests MOS not morotla
21:28:38 <benc_> motorola
21:28:38 <RyanT5000> cause each op is friggen huge
21:28:47 <RyanT5000> it's like
21:28:50 <adu> RyanT5000: you mean OpenGL shading language?
21:28:51 <RyanT5000> "dot product"
21:28:59 <RyanT5000> yah
21:29:10 <adu> thats not quite what i would consider assembly
21:29:26 <RyanT5000> well i don't mean Cg
21:29:29 <RyanT5000> or HLSL
21:29:48 <Smokey`> RyanT5000: if you develop ASM shaders for vendor-specific apps, you can do some awesome things... because you're not limited to the standard instructions... AND you get access to the newly supported instructions (assuming your driver is up to date), which give you access to next-gen features that have been implemented on the card, however not in the shading language :)
21:29:48 <RyanT5000> i mean the actual assembly version, where each line maps onto a single opcode
21:29:53 <Smokey`> shading language = GLSL in this case.
21:30:00 <Smokey`> nmmm, I should have said high level shading language
21:30:20 <RyanT5000> yah
21:30:30 <RyanT5000> all i know is
21:30:30 <Smokey`> nVidia are great for that, they always expose the latest ASM instructions in their drivers :)
21:30:30 <adu> GLSL looks like assembly
21:30:34 <RyanT5000> edge detection is a pain in the ass :P
21:30:43 <Smokey`> adu: err, no it doesn't.  it looks like C w/ interfaces.
21:30:46 <adu> but i don't know if they correspond to actuall GPU instructions....
21:30:50 <Smokey`> (does it have interfaces yet?)
21:31:08 <RyanT5000> i dunno; i hate the C-based syntax
21:31:09 <RyanT5000> it's like
21:31:23 <RyanT5000> "it's C! oh wait but we're going to change everything that makes it anything like C"
21:31:33 <RyanT5000> like the parameter labels and stuff
21:31:38 <Korollary> It's just familiar syntax.
21:31:42 <RyanT5000> yeah
21:31:54 <Korollary> People would go nuts if Cg used s-exprs, so there you have it.
21:32:05 <RyanT5000> lol i'm not advocating s-expressions
21:32:12 <RyanT5000> it wouldn't fit at all
21:32:20 <Korollary> why not
21:32:31 <adu> whats an s-expr?
21:32:33 <RyanT5000> when i was working on this stuff, you only got like 63 opcodes
21:32:41 <RyanT5000> like, that was the max size of the shader
21:33:00 <RyanT5000> s-expressions do not lend themselves to easily knowing exactly what code's being generated
21:33:10 <RyanT5000> (imho)
21:34:23 <newsham> hi.  is the Haskell Web Server (HWS) available?
21:35:07 <dons> should be
21:35:12 <dons> multiple versions
21:35:23 <newsham> i found a few links but all 404'd
21:35:38 <newsham> http://www.mdstud.chalmers.se/~md9ms/hws-wp/ is the closest I came.  but the link to the original, and the tarball were both bad
21:35:44 <dons> hmm. 
21:35:59 <dons> and its not on haskell.org either.
21:36:00 <newsham> (btw, does haskell.org run on a haskell-based server?)
21:36:07 <dons> hws-wp is pretty close to the original code
21:36:16 <dons> doubt it
21:36:24 <newsham> hws-wp tarball == 404
21:36:33 <dons> grr
21:36:38 <dons> maybe ask google?
21:36:42 <dons> then haskell-cafe@
21:36:48 <newsham> thats how I found hws-wp (goog)
21:36:49 <adu> yur right
21:37:02 <Smokey`> newsham: if the URLs are bad, see if google has a cache of it...
21:37:05 <adu> what was that OpenGL shading asm that i saw somewhere?
21:37:22 <adu> what that just for a specific GPU then?
21:38:03 <Smokey`> adu: there is a standard isntruction set for vertex/fragment shaders...
21:38:18 <adu> what is that called?
21:38:28 <newsham> does goog cache .tgz?
21:38:31 <Smokey`> doesn't have a 'name' as such, it's an extension of OpenGL... h/o a sec
21:39:01 <Smokey`> GLSL is just the high-level shading language, that compiles into the ASM
21:41:23 <Smokey`> mmmm, where is it :S
21:41:36 <adu> i remember seeing it in system files somewhere
21:42:13 <adu> it was a light xml file with like <shader></shader> with some wierd mnemonics in it so i know it wasn't ppc
21:43:23 <Smokey`> hmmm, no idea what that was... might be related, but there's an actual specification 'somewhere' :)
21:44:18 <RyanT5000> i've seen files like that too
21:44:20 <adu> oo i found something like it!
21:44:20 <RyanT5000> on windows
21:44:38 <adu> /System/Library/PrivateFrameworks/GLResourceEditor.framework/Resources/OpenGLTrackballVertexProgram.txt
21:44:52 <Smokey`> http://oss.sgi.com/projects/ogl-sample/registry/ARB/vertex_program.txt <-- Section 2.14.4,  Vertex Program Execution Environment
21:44:56 <adu> its got lots of asm stuff
21:44:56 <Smokey`> that's for vertex shaders...
21:45:29 <Smokey`> http://oss.sgi.com/projects/ogl-sample/registry/ARB/fragment_program.txt <-- Section 3.11.4  Fragment Program Execution Environment
21:45:34 <Smokey`> ^ that's for fragment shaders
21:45:46 <adu> cool thanx
21:45:57 <Smokey`> np
21:47:06 <RyanT5000> dons: where do i get libraries with debugging symbols?
21:47:34 <Korollary> What the monad? http://groups.google.com/group/comp.lang.functional/browse_frm/thread/d5d8964f57adee40/158ec3cdbd05b93d#158ec3cdbd05b93d
21:48:33 <Smokey`> someone likes their symbols :)
21:48:40 <RyanT5000> lol
21:48:57 <dons> if you want more tha just the rts with debug symbols. you need to compile up your own ghc
21:49:34 <Smokey`> dons: so I take it there isn't an archive of debugging symbols, seperate from the binaries?
21:49:56 <RyanT5000> well what would actually be awesome is if i could just have the RTS catch the external exception, and then give me a stack trace of what line of haskell caused it
21:50:10 <Smokey`> (of course, all things considered, that would be a pain, you'd have to have OS/compiler-specific sets, just for the convenience of others)
21:50:15 <RyanT5000> because it's definitely going to be easier, for the time being, to work around this
21:50:29 <RyanT5000> seeing as i didn't write the binding i'm using or the library that's crashing
21:50:41 <Cale> Korollary: I like the reply: "What are you smoking? You're sure you could stop anytime you wanted, right?"
21:53:51 <newsham> so I take it the HWS doesnt see much real-world use?
21:54:07 <newsham> what about other implementations like the Postmaster mail server?
21:54:43 <dons> RyanT5000, just wrap your external ffi calls in a catch or handle. this is what everyone else dooes.
21:55:08 <RyanT5000> :-/ how do i do that?
21:55:14 <RyanT5000> just like
21:55:22 <RyanT5000> wait i'll look for a sec
21:55:47 <RyanT5000> alright so i say like
21:56:08 <RyanT5000> catch (dangerous operation) (putStrLn "Crap!")
21:56:32 <RyanT5000> but will this stuff catch a segfault?
21:56:35 <dons> I have a : throwIfErr :: Num a => P.FastString -> IO a -> IO a
21:56:43 <dons> not a segfault
21:56:48 <RyanT5000> ok
21:56:49 <dons> you can't catch that in any language
21:56:56 <RyanT5000> yah you can on windows :)
21:57:00 <dons> unless there's some magic trick
21:57:13 <RyanT5000> if i'm not mistaken, you can register a handler for that in win32
21:57:23 <RyanT5000> which is implemented in VC++ by __try and __catch
21:57:43 <dons> oh, SIGSEGV can be caught actually
21:57:51 <dons> just not SIGKILL and SIGSTOP
21:57:59 <RyanT5000> yah
21:58:03 <RyanT5000> actually
21:58:22 <RyanT5000> is there a way for me to just make it so that it outputs each function as it evaluates it?
21:58:27 <RyanT5000> like a trace functionality
21:58:38 <dons> so you'll need to use posix signals if you want to catch this
21:58:46 <RyanT5000> i mean, my program's small enough i could just put in "putStrLn" all over the place
22:00:04 <newsham> @hoogle fst
22:00:04 <lambdabot> Prelude.fst :: (a, b) -> a
22:00:04 <lambdabot> Control.Parallel.Strategies.fstPairFstList :: NFData a => Strategy [(a, b)]
22:00:04 <lambdabot> Data.Graph.Inductive.Query.Monad.mapFst :: (a -> b) -> (a, c) -> (b, c)
22:00:39 <Smokey`> dons: if Haskell has a profiler, and debugging symbols... why can't people make debuggers for Haskell?
22:01:11 <mwc> Wow, the wikibooks page on haskell arrows is really good
22:01:14 <newsham> does lazy evaluation making debugging more complex?
22:01:53 <sjanssen> newsham: that is one problem
22:01:56 <dons> Smokey`, they do. there's 3 or 4
22:02:04 <cpatrick> newsham: it makes it an absolute bastard
22:02:07 <newsham> dons: are they doc'd on wiki?
22:02:10 <Smokey`> hmmm, when I looked I couldn't find anything... clearly I didn't look hard enough
22:02:11 <dons> check haskell.org
22:02:25 <dons> no one uses them though, imo
22:02:28 <cpatrick> newsham: though luckily debugging in haskell is usually a matter of playing around with things in ghci
22:02:47 <dons> you just don't need them with ghci and QuickCheck
22:03:01 <newsham> sure, but debuggers often let you know what went wrong, so that you can muck w/ them interactively to find out how they went wrong
22:03:13 <mwc> that's what the toplevel is for
22:03:17 <mwc> it's better than any debugger
22:03:20 <newsham> mucking in ghci is a (non-trivial) search problem.
22:03:23 <dons> yep. freje even lets you trace your program backwards, iirc
22:03:23 <newsham> humans suck at search :)
22:03:35 <dons> and Lemmih just wrote a debugger binding into ghci
22:03:46 <newsham> url for debugging info?
22:04:06 <dons> under Programming development in the Libraries and tools page of haskell.org
22:04:26 <RyanT5000> heh the only issue is when your C code crashes apparently :-/
22:04:39 <RyanT5000> which is why the whole OS and everything should be written in haskell from the ground up!
22:04:46 <RyanT5000> lol
22:05:01 <Smokey`> an OS made from haskell, HA!
22:05:16 <RyanT5000> nope, i already asked: it exists
22:05:20 <dons> exactly.
22:05:26 <RyanT5000> and i think that's awesome
22:05:27 <Smokey`> aye, but I wouldn't want to see the source code.
22:05:27 <newsham> http://www.haskell.org/haskellwiki/Libraries_and_tools/Program_development#Tracing_.26_debugging   danke
22:05:42 <RyanT5000> has anyone in here implemented Undo/Redo in haskell?
22:05:43 <dons> Smokey`, go to the home page. they have browseable cvs
22:05:48 <RyanT5000> it seems retardedly easy to me
22:05:49 <dons> yeah.
22:05:56 <dons> well, what kind of Undo/Redo do you mean?
22:05:58 <newsham> i was runnign the haskell OS last week to look at it
22:06:07 <newsham> unfortunately it didnt support haskell :)
22:06:11 <Smokey`> dons: what's the name of the haskell OS?
22:06:12 <RyanT5000> like as in the user interface thing
22:06:14 <RyanT5000> House
22:06:41 <dons> yeah. I implemented it in Yi. There's also another library out there for polymorphic undo and redo
22:06:44 <dons> let me find you the links
22:06:59 <newsham> http://www.cse.ogi.edu/~hallgren/House/  the floppy on this page boots in vmware just fine (and qemu)
22:07:03 <dons> here's mine for Yi: http://www.cse.unsw.edu.au/~dons/code/yi/Yi/Undo.hs
22:07:17 <RyanT5000> heh i have 1/4 MB of C# that i very much want to rewrite in haskell now...
22:07:21 <dons> you'll have to google for 'polymorphic undo' I think to find the other library
22:08:52 <RyanT5000> do you really need to store actions?
22:08:58 <RyanT5000> what if you just had a list of documents
22:09:18 <RyanT5000> i'd think it'd have decent memory usage, just because it only needs to store the parts that changed
22:09:18 <dons> depends on how you want to do things.
22:09:26 <newsham> what is the name of lem's debug stuff?
22:09:33 <dons> I just store functionns that when executed will undo or redo actions
22:09:49 <dons> whiich only store the parts that changed..
22:09:51 <RyanT5000> but don't you have to write twice as much code?
22:09:56 <RyanT5000> i.e.:
22:09:58 <dons> ?
22:10:01 <RyanT5000> the forward and backward for each action?
22:10:11 <RyanT5000> or can you automatically generate those
22:10:12 <dons> did you look at the code. it's like 20 lines.
22:10:14 <dons> no no. you invert them
22:10:38 <dons> there's standard algorithms for this stuff
22:10:39 <Smokey`> very interesting, although imo rather messy compared to C operating systems i've looked at...  anyway I'll have a more in depth look when I get back from uni, later :)
22:10:44 <RyanT5000> sorry i don't totally understand the code
22:10:58 <RyanT5000> i don't even understand all the syntax
22:11:10 <newsham> smokey: at least the journey has been started
22:11:20 <Smokey`> newsham: aye, very true :)
22:11:39 <RyanT5000> what does u@(URList [] _) mean?
22:11:42 <RyanT5000> specifically
22:11:43 <RyanT5000> the @ sign
22:11:57 <newsham> it matches   (URLList [] _)
22:12:01 <dons> -- | Redo the last action that mutated the buffer contents. The action's
22:12:02 <dons> -- inverse is added to the undo list.
22:12:03 <newsham> but the hole thing can be refered to with the variable "u"
22:12:11 <newsham> whole, even.
22:12:16 <dons> so, you just turn an Insert into a Delete , to get the inverse
22:12:18 <dons> easy peasy
22:12:38 <RyanT5000> oh ok thanks newsham
22:12:40 <newsham> ie:    func x@(y,z) = (x,y,z)
22:12:48 <newsham> func (2,3)  ->   ((2,3),2,3)
22:12:55 <RyanT5000> oh ok so
22:13:42 <RyanT5000> there are only 3 possible actions
22:13:44 <RyanT5000> i see
22:14:06 <newsham> you're just giving a convenience name (an alias, if you will) for the whole construct
22:14:19 <RyanT5000> no i understand that part, thanks :)
22:15:01 <RyanT5000> what does !Point and !Size etc mean?
22:15:08 <RyanT5000> is that forcing it to evaluate?
22:15:32 <newsham> i'm not fluent in that stuff yet :)   I think its strict evaluation
22:15:39 <RyanT5000> k
22:16:46 <RyanT5000> so dons, what if i had something like a binary tree, and my actions mutated it
22:16:59 <RyanT5000> and i stored each mutated version in a list
22:17:07 <RyanT5000> how would the memory usage be for something like that?
22:17:23 <RyanT5000> and would that totally ruin my optimization?
22:17:29 <dons> depends on the size of the tree. if it's a lazy structure. maybe it would be fine.
22:17:50 <newsham> http://www.haskell.org/haskellwiki/Keywords#.21
22:17:54 <dons> let me find this polymorphic undo/redo lib. that would work on trees and such
22:17:57 <RyanT5000> is it generally better to use nonlazy structures?
22:18:01 <dons> no no.
22:18:06 <dons> you want lazy
22:18:14 <RyanT5000> i know in this case i do
22:18:20 <dons> but a text editor needs a strict, mutable buffer.
22:18:21 <RyanT5000> but i mean, i see a lot of !'s in your code
22:18:24 <dons> so Yi is a special case
22:18:32 <RyanT5000> i see
22:18:37 <dons> many things youu don't need to ensure lazyness
22:18:44 <Cale> Lazy datastructures can be used for what you'd normally have to use control structures for in strict languages.
22:18:48 <dons> so !-ifying them can be a good way to avoid space leaks
22:19:09 <dons> right. we use lazy lists instead of for loops
22:19:18 <RyanT5000> hm i see
22:20:29 <newsham> <dons> and Lemmih just wrote a debugger binding into ghci
22:20:35 <newsham> whats the name of lemmih's debugger stuff?
22:20:53 <dons> no name yet, I think. check ghc-cvs@ from the lsat few days. and last week's HWN
22:20:56 <dons> ?where HWN
22:20:56 <lambdabot> http://sequence.complete.org/
22:21:15 <newsham> HWN?
22:21:27 <newsham> (isnt that someone from hawaii?)
22:21:50 <dons> ?google HWN
22:21:51 <dons> lets see
22:21:52 <lambdabot> http://www.hwn.org/
22:21:53 <Cale> The difference is that you can (and do!) define lists in terms of other lists, so you can get some rather interesting effects from that.
22:21:55 <dons> doh
22:22:02 <Cale> (which would be tricky with plain loops)
22:22:44 <RyanT5000> right
22:23:00 <dons> ah, here's the polymorphic undo/redo from Dazzle: http://www.cs.uu.nl/~afie/pd09122004.zip
22:23:04 <RyanT5000> i knew i would like Haskell when i saw the list-comprehension form of an infinite list of all fibbonacci numbers
22:23:05 <Cale> Here's one of my favourite examples: isSubstringOf x y = any (isPrefixOf x) (tails y)
22:23:26 <RyanT5000> that's the first thing i did in GHCi: fib !! 1000000
22:23:35 <RyanT5000> twice, to see if it cached it ;)
22:23:47 <Cale> :)
22:24:42 <Cale> Note that this method of searching for a substring match is just as efficient as the nested loops with early breaking solution in an imperative language
22:24:55 <Cale> (asymptotically)
22:25:00 <RyanT5000> huh
22:25:06 <RyanT5000> that's awesome
22:25:24 <RyanT5000> it really seems like, with the exception of a few corner cases, it's easy to write efficient haskell code
22:25:47 <newsham> i'll let you know when I can find a working web server :(
22:25:49 <Cale> Well, searching is easy to make efficient
22:26:02 <Cale> Summarizing is harder to make efficient
22:26:12 <RyanT5000> what do you mean by summarizing?
22:26:31 <RyanT5000> you don't mean suffix tries do you?
22:26:34 <Cale> Something which consumes all of the input data to produce a small result
22:26:48 <RyanT5000> ah
22:27:29 <RyanT5000> heh the algorithm to build a suffix trie in O(n) time is the hardest thing i've ever implemented
22:27:29 <Cale> actually, that's basically the general hard thing to make efficient in a lazy language -- everything else is fine
22:27:36 <RyanT5000> hm
22:28:13 <dons> but in that case you just do it strictly.
22:28:16 <dons> no?
22:28:17 <Cale> right
22:28:22 <RyanT5000> :)
22:28:33 <dons> it's great having a lazy _and_ strict language
22:28:54 <RyanT5000> so... what's the second best language?
22:28:55 <Cale> you can usually add some strictness annotations to your datatypes, or a seq here and there
22:28:57 <RyanT5000> lol
22:29:15 <dons> Clean is the second best ;)
22:29:23 <RyanT5000> hm i'll check it out
22:29:28 <RyanT5000> i only heard of it earlier today
22:29:28 <dons> if only it had monads
22:29:29 <Cale> hehe
22:29:29 <RyanT5000> for the first time
22:29:38 <newsham> no love for erlang? :)
22:29:38 <Cale> Clean is almost exactly like Haskell
22:29:58 <dons> no static typing. how could i love such a beast?
22:30:11 <RyanT5000> yeah i don't know how anyone can live without static typing
22:30:18 <RyanT5000> even static typing with casts is better than dynamic typing
22:30:19 <mwc> Static typing is great for programmers with ADD
22:30:31 <newsham> *shrug* I write more python than C or haskell.   I seem to get buy just fine.
22:30:36 <mwc> I can't tell you how much code I wrote and threw away because it was too hard to find out where it went wrong
22:30:36 <Saulzar> Everyone else writes perfect code :)
22:30:37 <RyanT5000> and for programmers who occasionally make mistakes and like there to be a decent chance of them being caught
22:30:44 <newsham> I wouldnt want it to fly a plane or land on mars.  but its nice for lots of stuff
22:31:01 <dons> yeah. i wouldn't even try coding half asleep without a type checker
22:31:09 <RyanT5000> yeah
22:31:14 <dons> but with one, I just go ahead and let the compiler gently correct me
22:31:17 <mwc> We need a haskell avionics suite
22:31:24 <dons> rather than introducing bugs to be found the next day ... year
22:31:33 <RyanT5000> yep
22:31:34 <newsham> there are nice things you can do w/o static typing that you cant do w/ static typing.
22:31:44 <RyanT5000> i disagree!
22:31:45 <mwc> takeOff >> fly >> land :: IO (Maybe Crash)
22:31:45 <RyanT5000> :P
22:31:50 <dons> sure. that''s whta Dynamic is for, right ?
22:32:00 <RyanT5000> exactly
22:32:24 <newsham> speaking of static typing, why cant haskell handle rules for arbitrary tuples?  (and dont say TH ;-)
22:32:40 <dons> why? they're different types
22:32:42 <mwc> tuples != lists
22:32:45 <dons> you'd need to use a type class
22:32:55 <Pseudonym> HList
22:33:08 <newsham> of course they're different types, but sometimes I want a function that is generic over arbitrary lengths of tuples
22:33:12 <Pseudonym> Isn't HList the answer for every type hackery problem?
22:33:29 <newsham> in fact, I've seen several libraries that write functions for 1-ary, binary, trinary, ... tuples
22:33:32 <newsham> explicitely!
22:33:41 <newsham> i thought we all made computers for that sorta rote :)
22:33:44 <dons> or just use a typeclass..
22:33:47 <mwc> newsham, so you want a function that's generic over non-isomorphic types?
22:33:54 <dons> since they're born for writing functions over a set of types
22:34:07 <newsham> mwc: if thats what I said in normal english, then yah ;-)
22:34:08 <RyanT5000> i could see where you could make an argument for a tuple which has different-type members, but they all share a class
22:34:28 <newsham> i guess I offended the strict type gods.
22:34:30 <Cale> RyanT5000: you can get that as a list with an existential datatype
22:34:31 <dons> move all the (,,) into Functor, and away you go
22:34:36 <mwc> newsham, consider the tuple (Int, Int) and (Int,Int,Int)
22:34:36 <RyanT5000> oh right
22:34:54 <Cale> dons: (,,) can only be a Functor in one way
22:34:59 <Pseudonym> You didn't offend the strict type gods, but you did offend Hindley and Milner.
22:35:01 <RyanT5000> i'm actually happy with that being a TH thing
22:35:06 <Pseudonym> Which isn't a problem.  Offend away.,
22:35:09 <Cale> fmap f (x,y,z) = (x,y,f z)
22:35:09 <mwc> myself as well
22:35:41 <RyanT5000> although, it's kind of lame that they use printf as "justification" for some of their functionality
22:35:43 <dons> true. Cale. oops
22:35:58 <newsham> cross (a,b,c,d) = [(a',b',c',d') | a' <- a, b' <- b, c' <- c, d' <- d]
22:36:02 <RyanT5000> don't get me wrong, TH is the thing that made me think Haskell is strictly better than everything else i know
22:36:08 <RyanT5000> but printf is an abombination
22:36:11 <mwc> newsham, at any rate, how do you want to treat (Int,Int) as an element of (Int,Int,Int)
22:36:19 <RyanT5000> even the C community acknowledges that
22:36:25 <mwc> you could embed (x,y) as (x,y,0) or (x,y,1) right?
22:36:42 <newsham> mwc: lets say i want to define cross products over tuples of arbitrary lists
22:36:47 <mwc> and the appropriate embedding would be different if you wanted to SumAcrossTuple, or ProdAcrossTuple
22:36:47 <xerox> I thought it was (f x,y,z), or is the choice random really?
22:37:08 <mwc> newsham, cross products over arbitary lists?
22:37:24 <dons> > printf "%0.2f - %c\n" (pi::Double) 'x' :: String
22:37:24 <newsham> cross ([1,2], "abcd", [5.1, 2.3])
22:37:25 <lambdabot> "3.14 - x\n"
22:37:26 <dons> yay for dictionaries
22:37:57 <newsham> > cross ([1,2], "abcd", [5.1, 2.3], "XYZ") where cross (a,b,c,d) = [(a',b',c',d') | a' <- a, b' <- b, c' <- c, d' <- d]
22:37:58 <lambdabot> [(1,'a',5.1,'X'),(1,'a',5.1,'Y'),(1,'a',5.1,'Z'),(1,'a',2.3,'X'),(1,'a',2.3,'Y'),(1,'a',2.3,'Z'),(1,'b',5.1,'X'),(1,'b',5.1,'Y'),(1,'b',5.1,'Z'),(1,'b',2.3,'X'),(1,'b',2.3,'Y'),(1,'b',2.3,'Z'),(1,'c'
22:37:58 <lambdabot> ,5.1,'X'),(1,'c',5.1,'Y'),(1,'c',5.1,'Z'),(1,'c',2.3,'X'),(1,'c',2.3,'Y'),(1,'c',2.3,'Z'),(1,'d',5.1,'X'),(1,'d',5.1,'Y'),(1,'d',5.1,'Z'),(1,'d',2.3,'X'),(1,'d',2.3,'Y'),(1,'d',2.3,'Z'),(2,'a',5.1,'
22:37:58 <lambdabot> X'),(2,'a',5.1,'Y'),(2,'a',5.1,'Z'),(2,'a',2.3,'X'),(2,'a',2.3,'Y'),(2,'a',2.3,'Z'),(2,'b',5.1,'X'),(2,'b',5.1,'Y'),(2,'b',5.1,'Z'),(2,'b',2.3,'X'),(2,'b',2.3,'Y'),(2,'b',2.3,'Z'),(2,'c',5.1,'X'),(2,
22:37:58 <lambdabot> 'c',5.1,'Y'),(2,'c',5.1,'Z'),(2,'c',2.3,'X'),(2,'c',2.3,'Y'),(2,'c',2.3,'Z'),(2,'d',5.1,'X'),(2,'d',5.1,'Y'),(2,'d',5.1,'Z'),(2,'d',2.3,'X'),(2,'d',2.3,'Y'),(2,'d',2.3,'Z')]
22:37:59 <mwc> newsham, what exactly is cross supposed to mean?
22:38:03 <mwc> ah, ok
22:38:12 <newsham> cartesian cross product
22:38:13 <mwc> let me see
22:38:26 <Pseudonym> mwc, it's the category product over Set.
22:38:29 <mwc> right
22:38:30 <Pseudonym> Hope this helps!
22:38:31 <Pseudonym> :-)
22:38:39 <RyanT5000> the cross product for vectors in space also has meaning with more-than-3-element vectors
22:39:01 <mwc> RyanT5000, yeah, but generally you generalize that to an outer product or wedge product
22:39:21 <newsham> anyway, I have a generator in python which does that in a few lines (more than it should take), and I have n small haskell definitions, one for each length n-tuple that I care about, in haskell
22:39:30 <Pseudonym> There is also a meaningful cross product in 7 dimensions.
22:39:34 <newsham> seems somewhat broken to me
22:39:36 <Pseudonym> Actually, there's more than one.
22:39:49 <mwc> yeah, that's definitely something that needs to be locked away in TH
22:39:52 <RyanT5000> yeah i guess that would probably be done with arrays anyway
22:40:09 <newsham> mwc: or somehwo make the type system stronger to allow for it
22:40:10 <mwc> Pseudonym, that higher dimension product have something to do with cool theoretical physics?
22:40:11 <RyanT5000> and you can have existential arrays right?
22:40:18 <Pseudonym> mwc: I doubt it.
22:40:26 <Cale> Sure you can
22:40:28 <RyanT5000> nah newsham, that should be in TH
22:40:29 <newsham> TH is a hack.  useful, but a hack.
22:40:31 <Pseudonym> Actually, the higher dimensional stuff is distinctly UNcool physics.
22:40:36 <Cale> Not existential unboxed arrays
22:40:41 <mwc> newsham, I think a more appropriate type would be cross [[1,2,3],[2,3],"abcd"]
22:40:51 <mwc> work over lists of lists
22:41:22 <newsham> mwc: *shrug* fine.   cross :: [[?]]   ?
22:41:23 <RyanT5000> TH is how you get turing-complete typing
22:41:23 <Cale> sequence
22:41:40 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
22:41:41 <lambdabot> [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2,5,6],[2,5,7],[2,5,8],[3,4,6],[3,4,7],[3,4,8],[3,5,6],[3,5,7],[3,5,8]]
22:41:59 <newsham> > sequence ["abc", [4,5]]
22:42:00 <lambdabot>  add an instance declaration for (Num Char)
22:42:00 <lambdabot>   In the list element: 5
22:42:00 <lambdabot>   In the list element: [4, 5]
22:42:03 <RyanT5000> well really
22:42:15 <Pseudonym> String theory, for example, has been worked on for a few decades now, but a) has not yet yielded anything which resembles nature in any semi-complete way, b) has not yet yielded anything which is even remotely testable, and c) comes up with bizarre compactified higher dimensions and crap like that.
22:42:26 <RyanT5000> that seems like it should be from a tuple of lists to a list of tuples (sequence is what i'm referring to)
22:42:46 <mwc> Pseudonym, yeah, I can't wait for ET to come, smack the 10D physicists with a book that explains how the universe is actually 2D
22:43:00 <Pseudonym> I'd be careful who I said this to, but IMO a lot of the stuff which "respectable physicists" come up with makes less sense than astrology.
22:43:05 <newsham> @type ["abc", [4,5]]
22:43:06 <lambdabot>   No instance for (Num Char)
22:43:06 <lambdabot>   arising from the literal `4' at <interactive>:1:9
22:43:07 <Cale> Pseudonym: I agree -- other theories of quantum gravity look far more promising
22:43:18 <Cale> newsham: hm?
22:43:33 <Pseudonym> I suspect the reason why string theory is so popular is the politician's syllogism applies.
22:43:35 <Cale> newsham: what should the type of the resulting list be?
22:43:51 <Pseudonym> "We need to do something.  Here is something.  So let's do it!"
22:43:59 <newsham> > cross ("abc", [4,5]) where cross (a,b) = [(a',b') | a' <- a, b' <- b]
22:44:00 <lambdabot> [('a',4),('a',5),('b',4),('b',5),('c',4),('c',5)]
22:44:05 <Lokadin> so wait, Yi is modular like emacs, but it's vim style?
22:44:09 <mwc> he wants a tupfe of heterotyped lists, and get tuples of single elements of the same type
22:44:17 <Cale> Lokadin: it's not any particular style
22:44:22 <mwc> ([a],[b],..) = [(a,b,..)]
22:44:32 <Cale> Lokadin: there are vim-like and emacs-like modes
22:44:33 <newsham> mwc++
22:44:43 <Lokadin> Cale: true but by default, kk the modular part is what i was interested in
22:44:51 <Lokadin> Cale: :)
22:45:01 <newsham> same thing with all the zip implementations in prelude
22:45:18 <dons> Lokadin, check the paper that comes with yi.
22:45:26 <mwc> keynote 4 should come with an Steve Jobs RDF
22:45:45 <dons> it's not quite emacs yet
22:45:48 <RyanT5000> dons, how do i force immediate evaluation of an expression?
22:45:55 <Cale> tuples of length greater than 2 are of questionable use
22:45:59 <mwc> dons, but it has Vixen instead of Eliza
22:46:01 <newsham> zip, zip3, zip4, zip5, zip6, zip7!
22:46:02 <mwc> that's gotta count for something
22:46:09 <newsham> (why no zip0? :)
22:46:10 <dons> true!
22:46:12 <RyanT5000> i have a feeling that my program is crashing later cause its not evaluating this one function
22:46:21 <mwc> seq?
22:46:23 <Cale> newsham: I've never seen zip3 used in actual code
22:46:25 <dons> vixen is way more fun than eliza
22:46:35 <shapr> dons: Why do you think that?
22:46:35 * shapr grins
22:46:41 <newsham> cale: i often zip more than 2 items together in python (cant say I've done it in haskell yet)
22:46:54 <dons> for the first 2 years of Haskell, ghc only handled tuples < 5, and yale haskell only < 4
22:47:12 <Pseudonym> @vixen Say, do you have any psychological problems?
22:47:13 <lambdabot> maybe. do you?
22:47:17 <Lokadin> dons: kk thanks :)
22:47:18 <dons> shapr, ;)
22:47:24 <sjanssen> is there a limit now?
22:47:25 <newsham> anyway, not trying to put down haskell.. just seemed like a deficiency, and one that can be avoided when there is no strict static typing
22:47:35 <Pseudonym> @vixen We were discussing you-- not me.
22:47:35 <lambdabot> why not you?
22:47:37 <Korollary> sjanssen: ghc's max is 26 or something iirc.
22:48:07 <Cale> newsham: Right, but then you don't get any of the guarantees
22:48:09 <dons> no, it's up to 70, iirc.
22:48:20 <Saulzar> Cale, I've used zipWith family for 3, 4 :)
22:48:26 <newsham> cale: for sure.  strict static typing has many useful benefits.  thats why I'm so interested in haskell.
22:48:37 <RyanT5000> why is there a limit?
22:48:38 <mwc> The remedy for this is TH
22:48:43 <newsham> (and why I wouldnt want to fly a plane or drive a mars rover w/ python)
22:48:44 <dons> that limit got hit a while back with some generated code.
22:48:46 <Cale> newsham: You can get things in between, which preserve type guarantees, but allow for a wider variety of types in a single list.
22:48:48 <RyanT5000> i can understand why it'd have a limit early-on
22:49:01 <Cale> (well, really just one type, but many types project into that)
22:49:08 <RyanT5000> but once it's up way in double-digits, why not make it "huge"
22:49:12 <Cale> er, are included in that type)
22:49:13 <newsham> cale: yup.  true.  but they are heavy and awkward.
22:49:17 <mwc> RyanT5000, Simon got sick of writing zip27 x1:xs1 x2:xs2 ...
22:49:19 <Cale> not really
22:49:30 <RyanT5000> lol mwc
22:50:51 <Cale> data Showable a = forall a. (Show a) => S a
22:50:51 <Cale> instance Show (Showable a) where
22:50:51 <Cale>     show (S x) = show x
22:50:52 <sjanssen> if anybody is curious 62 is the limit on my version of GHC
22:50:56 <newsham> here's another one I like with dynamic typed system:     def run(f, *args, **kwargs) {  print f,args,kwargs; return f(*args, **kwargs) }
22:50:58 <Cale> *Main> [S 5, S "abc"]
22:50:58 <Cale> [5,"abc"]
22:51:11 <newsham> you can write generic function wrappers (print may not be the best example, but its simple to show)
22:51:13 <dons> 62!? hmm.
22:51:31 <sjanssen> yes, rather arbitrary
22:51:50 * dons dives into ghc to take a peek
22:52:16 <dons> (I know that take . peek doesn't type check.... )
22:52:16 <newsham> you cant do something like that in a strongly typed system (without template generation)
22:52:41 <Saulzar> What is *args and **kwargs?
22:52:43 <Korollary> Huge-tuples don't make sense anyway. You need labelled records unless you have a spectacular memory for what #17 stood for.
22:52:58 <Cale> newsham: yeah, I'm not sure I understand what that example is doing.
22:53:19 <RyanT5000> is there a haskell pastebin?
22:53:24 <Korollary> lisppaste2: url
22:53:25 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
22:53:36 <newsham> saulzer: in python *args captures all the remaining arguments into a tuple (immutable list), and **kwargs captures the keyword arguments into a dictionary
22:54:11 <newsham> and calling f(*args)   passes the tuple (or list) args as the arguments to f
22:54:39 <Saulzar> So it's varargs stuff?
22:54:44 <newsham> more or less.
22:54:47 <Cale> run f x y z = do
22:54:47 <Cale>     print (x,y,z)
22:54:47 <Cale>     return (f x y z)
22:55:05 <newsham> cale: yes, but generic over all number of arguments
22:55:06 <Saulzar> Sounds like it's template generation stuff in python too :)
22:55:25 <newsham> saulzar: nope, its runtime evaluation in python.
22:55:29 <Cale> oh, that could be done with typeclass hackery
22:55:38 <Cale> see the implementation of Printf in the libraries
22:55:46 <newsham> oh, also generic over all types of arguments
22:55:53 <Saulzar> Hmm
22:55:55 <newsham> run f x y z for all types of functions f, arguments x,y,z
22:56:11 <Cale> run :: (Show (a, b, c)) =>
22:56:11 <Cale>        (a -> b -> c -> a1) -> a -> b -> c -> IO a1
22:56:36 <Saulzar> Well, I think TH, or even templates in C++ are not so terrible if you really need that kind of thing.
22:56:36 <newsham> ahh.. cool.
22:56:58 <newsham> ok, well, lets go to a concrete example, because maybe you'll have a good idea for me.
22:57:14 <newsham> I want to run a bunch of tests.   as part of my tests I want to do something like:
22:57:38 <dons> ah, main/Constants.lhs: All pretty arbitrary:
22:57:39 <dons> \begin{code}
22:57:40 <dons> mAX_TUPLE_SIZE = (62 :: Int)    -- Should really match the number
22:57:51 <newsham> def runAllCombos(f, *args) { return map(f, *cross(args)) }
22:57:54 <dons>                 -- of decls in Data.Tuple
22:58:41 <newsham> and a test might be:   runAllCombos(myFunc, ["foo", "bar"], [1,2,3])
22:58:45 <sjanssen> 62 is so weird
22:58:52 <sjanssen> I wonder if it magic in some way
22:59:03 <newsham> and it should do the cross product of  ["foo","bar"] x [1,2,3]    can use those tuples as arguments to myFunc
22:59:03 <Cale> I'd use the list monad
22:59:17 <newsham> ie  myFunc("foo", 1) ...  myFunc("bar", 3)
22:59:27 <dons> maybe they can unbox tuples to that size, and copy them into stack slots?
22:59:27 <Cale> do x <- ["foo", "bar"]; y <- [1,2,3]; f x y
22:59:30 <newsham> right, so you can do that easily with the list comprehension
22:59:36 <Cale> or return (f x y)
22:59:38 <Cale> rather
22:59:40 <Cale> sure
22:59:50 <newsham> [myFunc x y | x <- ["foo","bar"], y <- [1,2,3]]
23:00:02 <Cale> and if you produce a bunch of IO actions, then you can sequence them and run them all
23:00:11 <newsham> but is there a way to code up the     map f (cross args)    ?
23:00:25 <newsham> only way i can think of to do that is to define cross1, cross2, cross3, etc..
23:00:33 <newsham> and then mapcross1, mapcross2, ...
23:00:46 <Cale> well, you could just use zipWithN
23:00:52 <Cale> or return/ap
23:01:12 <mwc> I better go to work, or I'm gonna be screwed.
23:01:12 <newsham> zipWith isnt right.  i would want crossWith
23:01:14 <mwc> ttyp
23:01:39 <Cale> > (return (:)) `ap` [1,2,3] `ap` [[4,5],[6,7]]
23:01:40 <newsham> zip is like a dot-product.  i want a cross-product
23:01:40 <lambdabot> [[1,4,5],[1,6,7],[2,4,5],[2,6,7],[3,4,5],[3,6,7]]
23:01:47 <Cale> oh, right
23:02:06 <newsham> but anyway, I understand what your saying (just replace zipWith with crossWith...)
23:02:16 <Cale> so it's  return f `ap` x `ap` y
23:02:26 <newsham> but still.. i would need TH to do it over several different lengths of arguments
23:02:32 <Cale> hm?
23:02:36 <Cale> this construction generalises
23:02:51 <Cale> you just insert more `ap`'s in between your args
23:03:04 <newsham> but I have to type the `ap`s each time.  i cant just make one function that hides that
23:03:13 <Cale> sequence
23:03:37 <newsham> sequence of ["abc", "def"], [1,2,3] ?
23:03:37 <Cale> if you want to take a list of lists
23:04:20 <Cale> Obviously, you know the type of f beforehand
23:04:29 <Cale> and so you know how many arguments you want to apply it to
23:04:42 <newsham> actually I have an arbitrary number of f's of differen ttypes :)
23:04:54 <newsham> yes, I know them ahead of time.
23:05:02 <newsham> the goal is one generic to rule them all
23:05:15 <newsham> (best I've come up with so far is n-generics for each argument length)
23:05:39 <newsham> back to  ([a],[b],[c],...) -> [(a,b,c,...)]
23:06:20 <RyanT5000> TH
23:06:21 <RyanT5000> ;)
23:06:21 <Cale> but perhaps more importantly, why is it that you want this?
23:06:36 <Cale> I have never run across such an exotic scenario
23:06:42 <newsham> cale: synthetic workloads, fault injection, "fuzzing"
23:06:46 <Cale> are you loading user code dynamically?
23:06:52 <newsham> no.
23:06:56 <RyanT5000> i don't quite understand why TH is considered (by some of you) to be a hack
23:06:56 <shapr> Fuzzing is better done via QuickCheck.
23:07:07 <Cale> RyanT5000: have you looked at it?
23:07:10 <RyanT5000> yeah
23:07:17 <Cale> newsham: I'm not sure I know what any of those are
23:07:21 <newsham> shapr: i'm not testing haskell code.
23:07:25 <RyanT5000> haskell doesn't have the simplest syntax ever
23:07:32 <shapr> newsham: Neither am I :-)
23:07:32 <RyanT5000> and that seems to be where most of the complexity comes from
23:07:42 <RyanT5000> i mean it doesn't seem so different from lisp macros
23:07:57 <ncalexan> Hehe... that's kind of the point :)
23:07:58 <shapr> QuickCheck is still the best fuzzing tool ever written.
23:08:04 <RyanT5000> well fine
23:08:11 <newsham> cale: i'm crafting workloads.  I'm providng these workloads to code that needs to be tested.  its sometimes called "fuzzing" or "fault injection"
23:09:07 <shapr> QuickCheck lets you define generators and properties.
23:09:18 <newsham> whats so great about that?
23:09:34 <newsham> (don't mean to be rude, just wondering whats innovative here)
23:09:40 <Cale> newsham: basically, it constructs random tests for you
23:09:48 <shapr> You want to craft workloads to look for flaws, right?
23:09:49 <newsham> lots of fuzzers do that.
23:09:58 <newsham> (including many that i've written)
23:10:03 <Cale> In order to test various properties which you specify algebraically
23:10:20 <newsham> i'll check out the paper
23:10:46 <shapr> newsham: I can talk more later, it's worktime right now.
23:10:53 <shapr> hey LoganH, long time no see.
23:11:01 <newsham> thanks for the ref.  talk to you later.
23:11:02 <LoganH> j0!
23:11:12 <LoganH> shapr: Cool, you're still around.
23:11:27 <shapr> LoganH: C'mon, it's only been... three years?
23:11:41 <LoganH> Four, I think.
23:11:45 <shapr> Oh
23:11:56 <shapr> I ended up dropping xmms-shell and switching to alsaplayer and then mpd.
23:12:20 <LoganH> Not surprising, xmms seems rather antiquated these days.
23:12:26 <LoganH> I haven't been using it much myself, either.
23:12:31 * shapr painfully drags his focus back to paying work.
23:12:35 <LoganH> Are you still in Scandinavia?
23:12:44 <LoganH> You mean you aren't paid for IRC?
23:12:52 <shapr> LoganH: Yeah, far north of Sweden, moving to Stockholm in the summer.
23:13:02 <LoganH> There's such a thing as far north of Sweden?
23:13:07 <LoganH> Oh, you mean far north within Sweden. :P
23:13:22 <shapr> LoganH: Are you going to be on #haskell the next day or two?
23:13:36 <newsham> at any rate, I dont think arbitrary length tuples of types are irrational or even special classes of types.  witness zip,zip3,zip4,...
23:13:44 <newsham> and I have at least once found that I wanted them.
23:14:02 <newsham> maybe some really bright prof or grad student will make me happy one day
23:14:19 <LoganH> shapr: Unless there's some anti-lurking rule, I don't see why not. :P
23:14:38 <RyanT5000> oh wow this is nice
23:14:42 <RyanT5000> SDL doesn't crash
23:14:43 <Korollary> newsham: wait for an Omega implementation.
23:14:45 <RyanT5000> as long as i never flip my buffers
23:14:49 <shapr> LoganH: Ok, I'll catch up with ya post-Damocles
23:14:54 <RyanT5000> wtf
23:15:06 <RyanT5000> that makes it pretty hard to draw things
23:21:16 <ncalexan> RyanT5000: paste code for debugging help?
23:22:00 <Cale> newsham: you could use ((a,b),c) instead of (a,b,c), which makes it much more trivial -- you can write typeclass functions which work to manipulate nested tuples
23:22:19 <lisppaste2> RyanT5000 pasted "SDL Issue" at http://paste.lisp.org/display/18678
23:22:30 <Cale> or (a,(b,c)), even
23:22:31 <RyanT5000> thanks ncalexan
23:22:50 <newsham> cale: not a bad idea (seems slightly hackish, but definitely more elegant than repetition)
23:22:55 <RyanT5000> when i run it it gets to all the putStrLns except the very last one
23:22:58 <RyanT5000> (cah)
23:23:06 <newsham> what about applying ((a,b),c) to a func as   func a b c?
23:23:07 <RyanT5000> oh and it doesn't get to d either
23:23:30 <RyanT5000> also, the flip is currently commented out ;)
23:24:08 <ncalexan> There's at least one problem with an unterminated list.
23:24:13 <RyanT5000> it's the second-to-last line
23:24:17 <RyanT5000> where?
23:24:19 <newsham> hmm.. i guess curry and partial evaluation can do it
23:24:27 <ncalexan> bpp <-
23:24:27 <newsham> cale: that might be a good workable solution.  thanks.
23:24:43 <RyanT5000> oh... that's an error, but that isn't causing it
23:24:46 <Cale> newsham: no problem -- you can write a typeclass to do the application in general
23:24:58 <RyanT5000> cause i used to just have OpenGL
23:25:17 <newsham> so why not make a generalize zip that uses nested tuples? :)
23:25:26 <RyanT5000> that should say bufferFlags  anyway
23:25:40 <Cale> newsham: that's also doable
23:26:17 <RyanT5000> oh man sorry i didn't remember i was right in the middle of an edit
23:26:19 <RyanT5000> lemme get that fixed
23:26:38 <newsham> how about syntactic sugar for   <a,b,c,d> ->  (a, (b, (c, d))) ?  :)
23:27:08 <newsham> genericZip <l1, l2, l3, l4>
23:28:08 <lisppaste2> RyanT5000 annotated #18678 with "SDL Issue (Updated)" at http://paste.lisp.org/display/18678#1
23:28:24 <ncalexan> RyanT5000: I will look at that ASAP, give me a few minutes.  Phone.
23:28:25 <RyanT5000> sorry about that ncalexan
23:28:27 <RyanT5000> thanks
23:28:36 <RyanT5000> the new one actually builds and exhibits the symptoms ;)
23:32:00 <RyanT5000> and btw it's crashing from C code in SDL, so it might not be that easy to fix without getting a debug version of that
23:35:59 <newsham> take care.  i'm off.
23:41:26 <RyanT5000> hey Smokey` - i have a library for you to make bindings for :)
23:41:28 <RyanT5000> OpenAL
23:41:42 <RyanT5000> i don't think there's any audio library for haskell right now
23:42:21 <dons> sure there is
23:42:23 <ncalexan> I believe there are bindings for that.  openal haskell
23:42:25 <ncalexan> google.
23:42:27 <RyanT5000> really?
23:42:31 <ncalexan> BTW, your code works for me.
23:42:40 <RyanT5000> really???
23:42:40 <ncalexan> MacOS X.
23:42:46 <RyanT5000> grrrr
23:42:52 <ncalexan> You should try the samples, like nehe et all first.
23:42:52 <dons> OpenAL, SDL. hmm maybe more  . 
23:43:07 <dons> ?wiki Libraries_and_tools/Music_and_sound
23:43:08 <lambdabot> http://www.haskell.org/haskellwiki/Libraries_and_tools/Music_and_sound
23:43:19 <RyanT5000> oh ok
23:43:28 <dons>  oh, and mistral has a binding to some sound lib too.
23:43:28 <RyanT5000> for some reason, i was stuck on searching for "audio"
23:43:46 <dons> oh. i'll change the title. good point
23:45:14 <RyanT5000> is there a link to HopenAL?
23:45:29 <dons> it's in the standard libs. 
23:45:36 <RyanT5000> oh huh
23:45:51 <dons> so check the docs for the standard libs from the front page
23:45:58 <RyanT5000> right; thanks
23:46:02 <RyanT5000> i think my brain's starting to turn off
23:46:43 <RyanT5000> does ALUT suck as much as GLUT?
23:47:09 <dons> ah. looks like OpenAL is only in cvs ghc
23:50:24 <ski> (Korollary : actually 6510, a slight variant of 6502, was in the c64)
23:58:16 <RyanT5000> how often is ghc released, and will they probably have merged in HOpenAL by the next release?/
