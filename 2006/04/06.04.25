00:02:19 <skew> palomer: you can do that, but you need some extra files
00:03:22 <goltrpoat> do tell?  ive run into this a lot.
00:03:31 <skew> see section 4.6.9 in the user's guide
00:05:29 <skew> basically, you can make a .hs-boot file with just the definitions the other module needs, and break the cycle
00:06:42 <goltrpoat> ghc user's guide?  4.6.9 talks about makefiles
00:06:50 <skew> what version?
00:06:59 <goltrpoat> 6.2
00:07:09 <skew> oh, that's the number in 6.4.1 and 6.4.2
00:07:31 <goltrpoat> oh ok, sec
00:07:48 <skew> "How to compile mutually recursive modules"
00:08:59 <skew> I don't see where to find older versions
00:09:55 <goltrpoat> excellent.
00:10:01 <lispy> oh i see, you can make dlls in windows with ghc as long as your application is one single dll
00:10:18 <lispy> that seems like a weird and crippling restriction
00:11:13 <goltrpoat> lispy:  hmm?
00:11:24 <lispy> http://www.haskell.org/ghc/docs/6.4.1/html/users_guide/win32-dlls.html
00:11:32 <goltrpoat> yeah, looking at it
00:11:47 * lispy was entertaining ideas of making language bridges
00:11:51 <goltrpoat> skew:  thanks a ton btw.
00:12:05 <lispy> apparantly you need dlls if you want to communicate with java
00:12:10 <skew> I hope it works - I've never really used it
00:12:27 <mwc> Could somebody look at http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Array-IArray.html or the MArray documentation, and tell me why functions such as the array maker functions or the subscripting functions aren't in the class?
00:12:27 <goltrpoat> lispy:  well, normally you'd have one output file per project, no?  whether it be an exe, a dll, or whatever
00:12:55 <shapr> metaperl: you called?
00:13:02 <mwc> shapr, you might know
00:13:03 <lispy> but what about applications that are a collection of dlls?
00:13:06 <goltrpoat> hey shapr.
00:13:24 <shapr> hiya goltrpoat 
00:13:50 <mwc> I'm writing a hashtable, and I'm tempted to put everything in the class itself (elemForKey :: ht k e -> k -> Maybe e)
00:13:57 <goltrpoat> lispy:  you usually have a collection of projects, no?  i mean, that's my experience in c++ anyway.  you set up a solution with a number of projects, and you compile all of them to dlls or whatever.
00:14:38 <goltrpoat> i don't understand how a single project can generate a set of dlls, i guess.
00:14:47 <lispy> goltrpoat: then what do they mean, "Making Haskell libraries into DLLs doesn't work on Windows at the moment;..."
00:15:04 <skew> that sounds like making a dll for a package
00:15:05 <mwc> I think that the windows PIC generation isn't working
00:15:20 <goltrpoat> lispy:  i think that's why visual haskell runs 6.5
00:15:31 <goltrpoat> (the dev snapshot from september or whatever)
00:16:06 <skew> does anyone know where old releases live?
00:16:15 <goltrpoat> cvs?
00:16:26 <skew> I'm looking for the release notes
00:16:29 <lispy> debian archives? :)
00:16:33 <lispy> oh
00:16:59 <goltrpoat> what's the word on the next stable version anyway
00:17:04 <Korollary> there seem to be release notes: http://haskell.org/ghc/download.html
00:17:09 <Korollary> under old releases
00:17:41 <skew> I saw something saying incremental garbage collection wasn't implemented yet, but that sounds wrong
00:18:01 <goltrpoat> it's not stop and go right now is it
00:18:01 <shapr> mwc: listArry is an array maker.
00:18:16 <skew> It's definitely generational
00:18:17 <mwc> 've always thought that if a class defines something "special" about a given type, the member operations are the defining charachteristics of that "specialness"
00:18:27 <mwc> right, what about indexing?
00:18:52 * lispy goes to sleep
00:19:04 <shapr> g'nite lispy!
00:19:08 <goltrpoat> mwc:  what about it?  (!) :: (IArray a e, Ix i) => a i e -> i -> e
00:19:14 <mwc> right
00:19:15 <lispy> shapr: good night
00:19:32 <mwc> but if you look at the class itself, (!) is not a member
00:19:58 <mwc> wouldn't (!) need to know about the internals of a given array index, and so need to be in the glass?
00:20:11 <mwc> *given array instance
00:20:43 <shapr> What class?
00:20:43 <shapr> Ix is the index typeclass.
00:20:46 <mwc> Right
00:20:57 <mwc> I mean, the array instance
00:21:18 <mwc> say I create a new type, and say Instance IArray Foo
00:21:23 <mwc> how does (!) work on that?
00:21:43 <shapr> (!) :: (IArray a e, Ix i) => a i e -> i -> e
00:21:59 <mwc> it seems all these array functions need to be specialized for the given instance type of the Array class
00:22:05 <mwc> so shouldn't they be in the array class?
00:22:29 <shapr> I created a simple array demo..
00:22:32 * shapr tries to find it
00:22:43 <mwc> According to http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Array-IArray.html, IArray has no members
00:23:46 <shapr> mwc: Have you tried to create a simple Array value and then use ! and others on it?
00:23:54 <mwc> What do you mean?
00:23:58 <mwc> I know how to USE array
00:24:00 <shapr> Oh
00:24:12 <mwc> I'm trying to understand the stucture (the WHY) of how it's put together
00:24:25 <mwc> data Foo = ...
00:24:41 <mwc> instance IArray Foo a
00:24:47 <mwc> how is (!) supposed to work on it?
00:24:49 <goltrpoat> haskell does not enforce interface conformance though.  you'll end up with a runtime error if you don't implement (!) on your instance and try to use it.  maybe i'm misunderstanding the question.
00:25:03 <mwc> Yeah
00:25:13 <mwc> but (!) isn't a member of the class!
00:25:18 <skew> which class?
00:25:19 <mwc> I don't understand how that's possible
00:25:32 <mwc> (!) needs to be specialized for a given implementation of the IArray interface
00:25:35 <shapr> I think that all the Array flavors end up working the same way, they just behave somewhat differently in terms of strictness, etc
00:25:46 <mwc> skew, IArray, MArray, they all seem to be build this way
00:25:58 <Korollary> I think I can rephrase his question
00:25:59 <mwc> shapr, yeah, but if you for instance were creating a newinstance
00:26:07 <goltrpoat> my take on it is, that the statement instance IArray Foo a is a guarantee that Foo implements the IArray interface to the extent that it's needed.
00:26:08 <mwc> how are you supposed to specialize all the functions for it
00:26:18 <Korollary> (!) is polymorphic, but it's not specialized for each kind of array.
00:26:27 <shapr> It seems you create an IArray instance.
00:26:47 <mwc> Korollary, I don't understand how that's possible
00:27:03 <mwc> wouldn't it need to know the internal structure in order to get an element?
00:27:20 <goltrpoat> did you implement (!) ?
00:27:29 <ProfTeggy> Moin
00:27:34 <shapr> It also seems that the different flavors work by export an Array type.
00:27:36 <Korollary> (!) is a method of Ix, not array.
00:27:38 <shapr> Gutentag ProfTeggy 
00:27:45 <ProfTeggy> Hello shapr!
00:28:19 <Korollary> oops, (!) is not  a method at all
00:28:27 <goltrpoat> ?  http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Array-IArray.html
00:28:31 <skew> http://darcs.haskell.org/packages/base/Data/Array/Base.hs
00:28:44 <skew> ! is implemented in terms of unsafeAt
00:28:53 <mwc> Ah
00:29:04 <goltrpoat> oy.
00:29:06 <mwc> so I actually understand how classes work
00:29:17 <mwc> methods that need to know about the internals of a given instances must be in the class
00:30:00 <goltrpoat> well, of course, no?  i thought you were asking if the compiler was going to magically infer the indexing operator just by virtue of you subclassing Array
00:30:40 <skew> yes, but functions that depend on the internals could also be built on primitives that are in the class, like it was with !
00:31:48 <mwc> goltrpoat, that's the only way I could figure on it doing it, with (!) out of the class
00:31:59 <mwc> skew, true
00:32:18 <mwc> but according to the docs, IArray is absolutely naked
00:32:40 <Korollary> I think the idea is that (!) is well typed, but producing a pure haskell implementation of it is not possible (there are no other operators or functions you can use to write anything)
00:32:43 <mwc> so I was quite confused
00:32:47 <Lokadin> say, how do you usually deal with config files and the like, do you read file? or is there some haskell optimal system?
00:33:10 <goltrpoat> i'm an xml whore.
00:33:23 <mwc> goltrpoat, I hope you get xhiv
00:33:27 <goltrpoat> haha
00:33:32 <Korollary> Lokadin: Check out MissingH.ConfigParser
00:33:40 <Lokadin> kk thanks :)
00:33:43 <mwc> I'd like to force the monsters behind that to write xml for an afternoon
00:34:38 <mwc> make an EDSL in haskell, then load it using hs-plugins
00:34:52 <mwc> or write the config file in haskell itself
00:35:04 <mwc> it would probably have the same feel as the Postfix config stuff
00:35:05 <goltrpoat> EDSL = Evil DSL?
00:35:09 <mwc> Embedded
00:35:14 <goltrpoat> oh.
00:35:32 <mwc> the DSL is mapped to haskell constructs, and in the end compiled as such, afaik
00:35:43 <skew> because monads ~= programming languages
00:35:49 <goltrpoat> i don't like DSLs for config files.  i think it's a terrible idea, honestly.
00:36:01 <mwc> I like Postfix's config files
00:36:08 <Korollary> template haskell :)
00:36:10 <mwc> lazily evaluated, foo = value
00:36:14 <mwc> nice and simple
00:37:16 <skew> has anyone here used Haskell in soft-realtime stuff?
00:38:00 <skew> I'm timing a UDP (echo) server in haskell.
00:38:52 <goltrpoat> i'd say yes if you were to replace "in" with "as well as"
00:38:52 <goltrpoat> hehe
00:39:49 <skew> Same here, but I'm hoping to turn the latter into the former :)
00:41:30 <goltrpoat> hehe
00:41:52 <shapr> hey bringert 
00:42:14 <bringert> hej shapr
00:43:10 <bringert> how's code?
00:43:19 * bringert just gave a lecture on HaskellDB
00:43:55 <bringert> and I mentioned the Haskell SoC opportunities to the students
00:44:41 <goltrpoat> SoC?
00:44:55 <goltrpoat> oh.. sys on chip?
00:45:11 <bringert> Summer of Code
00:45:18 <skew> Haskell system on a chip!
00:45:18 <bringert> http://haskell.org/haskellwiki/Summer_of_Code:_Project_suggestions
00:45:48 <skew> Maybe Galois sells them?
00:46:04 <bringert> Haskell is actually used in chip design I believe
00:46:10 <goltrpoat> yeah i spent a good minute trying to match SoC to programming acronyms in my head, finally came up with system on chip, typed it, and immediately thought, wait.  that's rather comical, more than anything.
00:46:15 <bringert> not on the actuall chips though AFAIK
00:47:04 <bringert> maybe Haskell can be compiled to run on a LSIP machine?
00:47:23 <skew> well, the Halfs story suggests they are using haskell for operating system stuff
00:47:26 <Korollary> who runs anything on a lisp machine?
00:47:48 <goltrpoat> bringert:  oh i believe it.  handel C has a lot of FP elements to it, VHDL and verilog are supposed to be impure FP, etc.
00:48:01 <goltrpoat> korollary:  no one, more or less.
00:48:35 <Korollary> How does one draw a parallel between FP & VHDL?
00:48:54 <bringert> I think bluespec (http://www.bluespec.com/) use a thinly veiled Haskell EDSL for chip design
00:49:03 <skew> well, no globals, that's for sure
00:49:57 <Korollary> There are globals in chip design
00:50:32 <skew> clock, power, ground
00:50:33 <goltrpoat> dunno.  architecture blah of blah is begin action; action; action; end.  it's sort of declarative in places, sort of functional in places.  i've spent very little time with it
00:50:55 <Korollary> I can see that Haskell makes a good declarative language for that stuff, but there is no higher order stuff in there.
00:52:47 <goltrpoat> one of my partners spent a good eight or something years at celoxica, working with handel c and vhdl and whatnot, doing fpga design
00:53:05 <goltrpoat> he keeps saying that handel c, in particular, had a lot of functional elements to it
00:53:29 <skew> I
00:53:35 <goltrpoat> haven't asked him what exactly was fp about it, so i can't really say one way or another.
00:53:57 <skew> from what I've seen, those languages are very explicit about what state affects other state
00:54:18 <skew> because in the end you pay for those side effects with wires
00:54:33 <goltrpoat> yah that's what i've seen as well, but i figure i haven't done anything serious with any of it, and maybe things come out in large-scale design
00:56:29 <goltrpoat> i suspect the idea is that CSP is impure functional, therefore occam is impure functional, therefore (insert popular concurrent systems language here) is impure functional.
00:58:10 <goltrpoat> trouble is, i don't remember anything about CSP, and my exposure to occam is limited to approximately a month of reading back in 1988 or so.
00:58:52 <goltrpoat> so for all i know i could be entirely on crack.
00:59:14 <Korollary> Allegedly I referred to a VHDL description of a CPU for my thesis, but I don't remember VHDL enough.
00:59:22 <Korollary> (I intended to forget.)
01:02:19 <goltrpoat> that's a lot of VHDL.
01:04:11 <dons> ?karma+ QuickCheck -- caught a bug for me
01:04:12 <lambdabot> QuickCheck's karma raised to 2.
01:05:25 <Korollary> dude it's 4am in D.C.
01:07:11 <Korollary> @karma HUnit
01:07:12 <lambdabot> HUnit has a karma of 0
01:07:21 <adu> Korollary: yes, it is
01:07:34 <adu> Korollary: actually, 4:06 am
01:07:56 <Korollary> GW makes a lot of noise eh
01:12:50 <adu> or "T 04:12 +04:00" to be precise now
01:13:09 <bringert> are LANGUAGE pragmas supposed to work in GHC 6.4.1?
01:13:44 <adu> oops, "T 04:12 -04:00"
01:16:15 <kzm> Hi, xerox.
01:16:31 <kzm> You're the SoC guy, aren't you?
01:16:34 <xerox> Good morning, #haskell!
01:16:43 <bringert> good morning xerox
01:16:44 <bringert> eh
01:16:57 <bringert> xerox: welcome back!
01:17:17 <bringert> xerox: I mentioned SoC at the end of my haskellDB lecture this morning
01:17:41 <xerox> Glitches in the client... what was said?  Hi there!
01:17:43 <bringert> but the lecture was at 08:00, so I guess many of the students were asleep
01:17:47 <xerox> Great!  haha.
01:17:49 <kzm> Hmm... what is the recommended way of accessing RDBs these days?
01:18:10 <bringert> kzm: RDB = relational databases, right?
01:18:13 <Lokadin> say missingh isn't compiling :(
01:18:17 <xerox> I just saw Evan on cafe now *happy*
01:18:25 <Lokadin> er or configuring
01:18:37 <Lokadin> complains about not parsing extensions field
01:18:44 <Lokadin> anyone have any ideas?
01:18:48 <bringert> that sounds like a cabal version mismatch
01:18:58 <Lokadin> oh okay
01:18:59 <bringert> the names of some extensions keep changing
01:19:03 * xerox yawnes and stretches
01:19:16 <Lokadin> thanks :) i'll try getting the right one
01:19:23 <kzm> bringert, yes.  
01:19:32 <bringert> why, HaskellDb of course!
01:19:51 <Lokadin> hmmm what you think is the cabal version that it was made with
01:19:51 <bringert> well, it actually depends on what you need/want
01:19:55 <Lokadin> 1.1.13?
01:19:56 <kzm> Perhaps I should rather ask why. :-) 
01:20:05 <Lokadin> .3
01:20:24 <kzm> I'm tempted to say that I want something simple, but of course, things start simple and end up complex...
01:20:50 <bringert> do you want to write the SQL yourself, or use higher-level combinators?
01:21:11 <bringert> if you want to write the SQL yourself, use HDBC or HSQL
01:21:25 <bringert> if not, use HaskellDB
01:21:42 <xerox> And of course.... :-)
01:21:52 <kzm> I don't feel any urges towards sSQL
01:22:03 <bringert> if you want Oracle, I think Takusen might be the only lib with native (non-ODBC) support for it
01:22:14 <kzm> s/s//  # argh, the enter button is too large, or my fingers are
01:23:05 <bringert> what I would do (though I'm biased) would be to start with HaskellDB, and if it for some reason doesn't meet your needs, extend HaskellDB. If that still isn't enough, use HDBC or HSQL
01:23:18 <kzm> At this point I guess I just want to store some tabular information, and a simple way to retrieve a subset of it.  Oracle is fairly far down on the list.
01:23:33 <bringert> of the latter two, HDBC is easier to build and work with (IMO), but somewhat less mature
01:23:35 <kzm> Any other backend limitations?
01:24:00 <kzm> SQLite seems to be the popular choice on the bottom rung of the ladder?
01:24:01 <bringert> you mean limitations as to what back-ends the different libs support?
01:24:07 <kzm> Yes, exactly.
01:24:29 <bringert> yeah, SQLite is really easy to get working, but it has a weird type system.
01:24:31 <xerox> Cool, I received an answer from a student on the HOpenGL mailing list!
01:24:47 <bringert> HDBC, HSQL and HaskellDB all support SQLite
01:24:47 <xerox> He would like to apply for some Game project!  *fills with joy*
01:24:50 <kzm> So now we have, what, 68 mentors and 1 student? :-)
01:25:04 <bringert> you probably want to use the SQLite3 libs
01:25:24 <bringert> HaskellDB can use HSQL or HDBC as a back-end
01:25:30 <bringert> or even wxHaskell
01:25:41 <bringert> so HaskellDB supports whatever they support
01:25:59 <kzm> Sounds good.
01:26:03 <Lokadin> say if i have 2 versions of cabal how do i set which version of cabal to use?
01:26:07 <bringert> and HSQL, HDBC and wxHaskell all support ODBC, which in turn support pretty much anything
01:26:34 <bringert> Lokadin: hacky solution is to hide the one you are not using and expose the other
01:26:53 <Lokadin> what you mean by hide? as in move around the executable? or what
01:28:21 <bringert> ghc-pkg hide Cabal-x.x
01:28:31 <bringert> ghc-pkg expose Cabal-y.y
01:28:31 <kzm> xerox, ahem, to clarify, how many SoC participants do we have now? (I didn't mean to be sarcastic)
01:29:19 <bringert> I asked a lexture hall full of 3-4:th year CS students if they had heard about SoC, noone reacted
01:29:24 <xerox> kzm: errr... didn't count.
01:29:58 <Lokadin> what's soc?
01:30:08 <xerox> Lokadin: urgh!
01:30:17 <xerox> Lokadin: http://code.google.com/summerofcode.html
01:30:22 <Lokadin> o
01:30:25 <Lokadin> that i know what that is
01:30:26 <Lokadin> lol
01:30:27 <bringert> otoh, no students ever react when when you ask questions to a whole room full of them
01:30:34 <xerox> Lokadin: Haskell.org is a mentoring organization!
01:30:43 <Lokadin> wow that's cool :)
01:30:44 <xerox> Lokadin: check the link in the topic to see our projects atm
01:31:17 <bringert> we're not on the organization list yet, but I guess that will change soon?
01:31:19 <Lokadin> er says there are none atm
01:31:32 <xerox> bringert: we are!!!
01:31:50 <bringert> heh, /me doesn't know the alphabet
01:31:55 <xerox> hah!
01:32:22 <Lokadin>  
01:32:22 <Lokadin> Haskell.org
01:32:22 <Lokadin> This Organization has not filled in its information
01:32:28 <xerox> We're secretive.
01:32:40 <Lokadin> http://code.google.com/soc/haskell/about.html
01:32:42 <Lokadin> lol
01:32:43 <shapr> It's the HSU
01:32:49 <shapr> the Haskell Secret Underground
01:32:57 * xerox plays some background music
01:33:09 <Lokadin> lol
01:33:19 * shapr cranks up chemical brothers
01:33:19 <xerox> Here's the agents: http://haskell.org/haskellwiki/Summer_of_Code:_People
01:33:27 <shapr> I'm Agent S
01:33:34 <xerox> Of course those are made up names.
01:33:40 <Lokadin> oo i know! how about our radio station can be digitalgunfire.com that's pretty underground
01:33:49 <bringert> yeah, my name is actually shapr
01:33:54 <shapr> what!?
01:33:57 * shapr laughs
01:33:58 <xerox> !
01:34:08 <shapr> They call me "The Bear Bringer"
01:34:12 <bringert> I shouldn't have said that?
01:34:32 <xerox> You'll be transferred to The Island now.
01:34:34 <bringert> oh, right, Haskell *Secret* Underground
01:34:37 <bringert> dammit
01:34:38 <bringert> not again
01:34:45 <shapr> Nooo, I am not a number, I am a free man!
01:34:47 * xerox starts with the smoke
01:35:06 * shapr grabs a fork to fend off Rover, the big white balloon.
01:35:09 <Lokadin> lol
01:35:25 <xerox> I'm laughing out loud, hah.
01:35:37 <shapr> bringert: Never give away your real name!
01:35:54 <Lokadin> lol
01:36:04 * shapr casts a spell onto the fabric of reality that uses bringert's real name "SHAPR" !
01:36:20 <bringert> shapr: but you gave me yours? so you must have given it away?
01:36:21 <shapr> Speaking of which, I should write chapter two...
01:36:25 * bringert is confused
01:36:31 <xerox> shapr: YES
01:36:37 <shapr> It's fun to play musical names!
01:36:40 <xerox> shapr: I recently sent you an email about that.
01:36:52 <shapr> Yeah, I'm glad you liked chapter one.
01:36:58 <shapr> Maybe I should publish it on my blog.
01:37:09 <Lokadin> what's the book about?
01:37:14 <Lokadin> or what is it?
01:37:18 <xerox> Top secret.
01:37:44 <shapr> It's about programming!
01:38:04 <bringert> dude, it was supposed to be secret
01:38:08 <shapr> whoops
01:38:25 <Lokadin> lol
01:38:38 <Lokadin> you guys are hillarious
01:38:39 <Lokadin> lmao
01:38:47 <bringert> shapr: did the split-up HTTP module work out for you?
01:39:01 <shapr> Yeah, it's exactly what I wanted, thanks!
01:39:05 * bringert always reads "lmao" as "lamo"
01:39:08 <Lokadin> is it like a programming action novel? those are pretty cool lol
01:39:28 <Lokadin> what's lamo?
01:39:29 <shapr> Oh hey, I'm moving to Stockholm in July, soon I will bring my new unicycle(s) to Chalmers.
01:40:03 <shapr> Lokadin: You want to read the first chapter?
01:40:10 <bringert> Lokadin: you mean like that dumb movie where a guy is forced to crack some insane crypto while given a blow-job?
01:40:16 <bringert> shapr: cool
01:40:30 <Lokadin> i would love to :)
01:40:48 <Lokadin> read the first chapter that is
01:40:49 <bringert> did I mention that a ganster holds a gun to his head
01:40:51 <musasabi> dons: any idea when you will be breaking up the API for fps?
01:40:52 <bringert> oh
01:41:06 <bringert> shapr: I'll be in Seattle May - July BTW
01:41:15 <kzm> Sorry to come in late to the island thing, but what's wrong with numbers.
01:41:17 <kzm> ?
01:41:18 <shapr> Wow, working for MSR?
01:41:28 * shapr changes kzm's nick to Number 7
01:41:31 <bringert> shapr: nope, just hanging out
01:41:38 <kzm> YOu don't hear people reacting with: I'm not a string of letters, I'm a free man.
01:41:39 <shapr> kzm: Ever seen 'The Prisoner' TV series?
01:41:48 <bringert> I'll meet some people at MSR though
01:41:52 <shapr> kzm: Actually, Prince did something like that.
01:41:54 <kzm> No, but I heard the song.
01:42:05 <kzm> I'm not a number, I'm a free variable!
01:42:09 <shapr> bringert: Oh, make sure to see the Bronze Pig in Pike Place Market, and look for the guerilla art everywhere.
01:42:18 <bringert> ok, cool
01:42:24 * bringert has never been to Seattle
01:42:29 <shapr> And be sure to spot the roll-on deodorant building too.
01:42:36 <bringert> wtf?
01:42:43 <shapr> You'll know it when you see it ;-)
01:42:47 <bringert> mkay
01:43:00 <shapr> Also, the Asian markets near First Hill are fun.
01:43:08 <shapr> Belltown had the best clubs and bars last time I was there.
01:43:31 <kzm> You know I hate to bring this back on topic, but how do I get at the modules I *know* are stuck under HaXml?  The docs refer to -package HaXml, but that doesn't seem to exist.
01:43:42 <bringert> shapr: hmm, I'll just get on irc when I'm there and ask you where to go
01:44:05 <bringert> kzm: have you tried "ghc-pkg list"
01:44:16 <bringert> that should show you what packages you have anyway
01:44:19 <kzm> Oh crap - it may not be installed after all.
01:44:47 * kzm just used 'locate', but failed to spot the hidden "downloads" component of the path.
01:44:59 * kzm apologizes for the inconvenience.
01:45:24 <bringert> shapr: do you have any crazy ideas for GF hacks? I was thinking that I could propose a SoC project hacking on GF
01:45:45 <xerox> mahogny: ping
01:46:01 * bringert also wants to ask a haskell question:
01:46:03 <bringert> are LANGUAGE pragmas supposed to work in GHC 6.4.1?
01:46:09 <bringert> cause they don't seem to
01:46:11 <shapr> Crazy Ideas I can do...
01:46:23 <musasabi> bringert: I don't think they should work.
01:46:26 <shapr> I had a bunch of odd GF ideas before, lemme see if I can remember any..
01:46:27 <bringert> ok
01:46:42 <xerox> pesco: oi!
01:46:54 <xerox> bringert: what is GF?
01:47:06 <dons> ?karma+ QuickCheck -- two pasto bugs caught
01:47:06 <lambdabot> QuickCheck's karma raised to 3.
01:47:16 <bringert> xerox: http://www.cs.chalmers.se/~aarne/GF/
01:47:18 * xerox high-fives dons
01:47:29 <shapr> Lokadin: Here's the first chapter of the book - http://www.scannedinavian.com/~shae/HackReality
01:47:33 <bringert> a system for working with natural language grammars
01:47:35 <shapr> I should probably fix the formatting.
01:47:50 <Lokadin> thanks :)
01:48:00 <shapr> Amusingly, I based the main character on someone who used to hang out on #haskell
01:48:12 <dons> so I rewrote about 1000 lines of code today. once I got it to compile, there have been 3 bugs, all of which spotted by QuickCheck.
01:48:16 <shapr> wow
01:48:20 <dons> except for the unknown unknowns that is
01:48:26 <bringert> xerox: you can write grammars for languages like English or Arabic, parse text to abstract syntax, and pretty print back to natural language
01:48:33 <bringert> and lots of other stuff
01:48:40 <xerox> bringert: impressive!
01:49:09 <xerox> Pfft, I'm leaving with my family in minutes.  I'll not be able to populate the trac now.
01:49:19 <shapr> dons: Lemme guess, FastPackedString -> Rope (http://www.sgi.com/tech/stl/Rope.html) -> Spaghetti -> Pasto?
01:49:48 <shapr> xerox: I want a trac login!
01:50:16 <xerox> shapr: you see the query?
01:50:17 <shapr> bringert: I made some connection between cool tricks already done dependent types and something that could be done with GF.
01:50:23 <dons> Data.Bytestring -> Data.ByteString + Data.PackedString.Latin1
01:50:23 <shapr> query?
01:50:29 <xerox> shapr: privmsgs
01:50:33 <dons> split into a Word8 layer and a Char layer
01:51:01 <shapr> xerox: thanks!
01:51:16 <shapr> Lokadin: Sent me an email if you like it.
01:51:19 <bringert> shapr: got anything written down?
01:51:22 <kzm> xerox: would it be an idea to organize the projects on required qualifications?
01:51:28 <shapr> I don't know, lemme grep my ideas collection.
01:52:53 <kzm> dons: Just wanted to say that I think it is a good structure (bytestring+latin1).  Would be even nicer with polymorphic constants (chars and strings) of course :-)
01:53:04 <xerox> kzm: what do you mean?
01:53:08 * kzm mainly uses ASCII only anyway.
01:53:11 <dons> a totally polymorphic thingy like Array would be really cool.
01:53:14 <dons> but so much more work
01:53:23 * xerox points mentors to -overflow
01:53:24 <kzm> xerox: http://haskell.org/haskellwiki/Summer_of_Code:_Project_suggestions#Bioinformatics_tools
01:53:34 <kombinator> xerox: Hi! If you look at http://code.google.com/soc/haskell/about.html , there is no link to the wiki page about projects
01:53:49 <xerox> kombinator: yep, I think SyntaxNinja is going to link them to the exact page
01:54:33 <xerox> kzm: "general haskell knowledge" is everything is needed I think.  Mentors can request more informations from the applicants too.
01:54:42 * kzm squints in the direction xerox is pointing for a second, then wanders off.
01:55:23 <xerox> Sigh, I'm going to leave now.  Be back this evening.
01:55:31 <shapr> have fun!
01:55:42 <xerox> Ah, you're Ketil kzm!
01:55:52 <shapr> Mistah Malde
01:56:09 * kzm bows.
01:56:13 <kzm> At your service!
01:56:31 <xerox> Thank you very much for the interesting project
01:56:32 * kzm hopes that's not why xerox is leaving.
01:57:02 <xerox> I think we'll be able to direct you the applications quite straightforwardly, but I see what you mean :-)
01:57:19 <xerox> Nope, my family wants to go out for today's vacation...
01:57:30 <xerox> ...they really only want to take me off the computer! (-;
01:57:56 <kzm> Heh.  Enjoy your day off!
01:58:02 <shapr> Buy a 770!
01:58:09 <xerox> kzm: will do!
01:58:13 <xerox> shapr: so right!!
01:58:18 <shapr> My girlfriend is unhappy that I've acquired a 770...
01:58:31 <xerox> Tickets can wait today, I hope.
01:58:39 <xerox> Okay, have fun gentlemen!
01:58:44 * xerox <- out
01:58:49 <musasabi> dons: please no Latin1 module. The current API is very nice for UTF8 ;)
01:59:56 <dons> musasabi: there's a lot of pressure on libraries@ to separate the W8 and the Char layer. and its actually pretty clean
02:00:13 <musasabi> dons: what does it do to performance?
02:00:26 <dons> should do next to nothing for Char. and speed up W8 
02:00:44 <musasabi> intermodule optimization works that well at the moment?
02:01:21 <Lokadin> shapr: wow that's really good :D, 
02:01:27 <shapr> bringert: Where's the GF repo?
02:01:30 <kzm> ..and it opens for a BS.Utf8 module with the same interface (right?)
02:01:39 <shapr> Lokadin: Glad you like it, any suggestions for improvement?
02:01:41 <Lokadin> only thing is i don't get how he managed to figure out even a half working system from a picture on ebay
02:01:46 <musasabi> dons: Something like Data.String.{Word8,Byte,UTF8,...} could also work.
02:03:15 <musasabi> dons: the thing is getting a byte <-> char in an encoding agnostic manner by a binary value is very useful.
02:03:33 <boegel> shapr: I have a cool project suggestion for SoC, but I don't have the time to work on it myself...
02:03:35 <shapr> Lokadin: First of all, you could statistically predict the rest to get a some idea of the rest of the writings.
02:03:40 <shapr> boegel: Put it on the wiki!
02:03:53 <boegel> shapr: starting a 3D modeller in Haskell, e.g. H3D, would be a cool thing I think
02:04:11 <shapr> Hm, didn't Wolfgang Thaller do something like that?
02:04:18 <boegel> shapr: that could start pretty basic, but could grow really big
02:04:20 <boegel> he did?
02:04:24 <kzm> Can you use byte strings safely with string/char constants, btw?  Must you assume something about the source representation?
02:04:25 <boegel> shapr: show me !
02:04:26 <Lokadin> shapr: well i got that, but if it's at the atomic level.. ebay resolution max of say 460x480
02:04:31 <Lokadin> ..
02:04:53 <Lokadin> or what not
02:05:03 <shapr> Lokadin: Yeah, but what if the visible lines were most of the 'kernel' and basic runtime, and only the userspace and useful utilities were missing?
02:05:06 <kzm> E.g. will "elemIndex 'Ã¦' bs" work?
02:05:19 <shapr> On the other hand, it didn't work so well...
02:05:32 <dons> musasabi: just ran the benchmarks. the numbers look identical
02:05:32 <bringert> shapr: sorry, phone. http://www.cs.chalmers.se/Cs/Research/Language-technology/darcs/GF/
02:05:42 <shapr> Lokadin: It's a good point though, maybe I should mention that.
02:05:43 <dons> the c2w and w2c conversions factor otu really well
02:06:01 <Lokadin> shapr: yea, i think it would make sense if you did :)
02:06:25 <dons> the api stays the same, of course, you just get to choose whether to operate on Chars on Word8s. In a sense this just means you get a lot more , and faster W8 ops
02:06:26 <Lokadin> shapr: but otherwise it's really good (Y) :D 5 stars
02:06:37 <shapr> w00, thanks!
02:07:31 <boegel> shapr: any links to WT work on a 3D modeller?
02:07:32 <Lokadin> :) np lol
02:07:40 <boegel> s/WT/WT's/
02:07:54 <musasabi> dons: how much faster?
02:07:57 <dons> musasabi: i'll run a full benchmark run and see how things go, but I like the trends so far.
02:08:09 <shapr> Lokadin: I could claim it's a holographic picture and half the view is just 50% resolution compared to the original image.. I think I'll say that. Thanks for pointing that out.
02:08:24 <dons> I haven't benched the W8 interface yet. but its missing all the coerciosn that slow the Char interface down, so I'd expect some speedup
02:08:48 <Lokadin> shapr: np :) glad i could help
02:08:59 <musasabi> dons: but how does one pattern match with the Word8 interface in manner that works remotely?
02:09:28 <shapr> Lokadin: I came up with a whole multi-book storyline for this. I know who created the pot, I know who bought it off ebay, and the current owners are after the main character...
02:09:57 <musasabi> case head str of 0x32 -> ...; 0x09 -> ...; 0x2F -> ...; does not seem very good.
02:10:07 <Lokadin> shapr: wow that's cool 
02:10:22 <musasabi> the current code is like: case head str of ' ' -> ...; '\t' -> ...; '/' -> ...;
02:10:32 <Lokadin> but why are they after the main character? 
02:10:37 <Lokadin> or you got that to
02:10:44 <Lokadin> cause don't tell me:P
02:10:48 <Lokadin> it would spoil it lol
02:11:08 <Lokadin> or you could
02:11:09 <Lokadin> lol
02:11:12 * shapr grins
02:11:33 <dons> musasabi, you get both interfaces. the current one on Char remains the same, but the underlying Word8 stuff is its own now. so you can use either syntax
02:12:08 <musasabi> dons: what is the new name of the Char layer? (please no explicit name of a single encoding)
02:12:40 <vincenz> que pasa
02:12:40 <dons> let me put up the api for you
02:15:56 <boegel> shapr: you're going to finish this book?
02:17:10 <shapr> bringert: Oh yeah, I remember one...Have you seen the paper "unsupervised learning of natural languages" by Solan, Horn, Ruppin & Edelman?
02:17:35 <shapr> boegel: Would be nice
02:18:41 <dcoutts> nomeata, Axel fixed that entryCompletionSetMatchFunc bug. :-)
02:18:43 <bringert> shapr: nope, but my officemate harald has
02:19:18 <bringert> shapr: http://www.cs.chalmers.se/~harald2/
02:19:36 <bringert> shapr: did you have idea about that and GF?
02:19:55 <dons> musasabi: http://www.cse.unsw.edu.au/~dons/tmp/index.html
02:20:09 <dons> I'm not 100% happy with the PackedString.Latin1 name, btw
02:20:14 <dons> Encode.Latin1 seems better
02:20:32 <dons> Encode.String.Latin1, I mean
02:20:40 <shapr> bringert: Yeah, I thought it might cool to implement the ADIOS algorithm and produce GF grammars.
02:20:46 <dons> or Data.String.Latin1
02:22:16 <dons> musasabi: opinions please :)
02:23:21 <shapr> bringert: I'd love to hear what you and Harald think about Sapir-Whorf, lojban, etc :-)
02:24:34 <bringert> shapr: ok, cool, I'll talk to harald about it
02:24:53 <bringert> shapr: you're welcome to drop by the department anytime
02:25:01 <shapr> Sure, next time I'm in Gothenburg.
02:25:04 <musasabi> dons: some other name than Latin1. I can work with that, but the name is not very good.
02:25:14 <Lokadin> say, i have a few files that import all the same thing, is there any way to make a different file that imports everything and they just import that one?
02:25:22 <dons> yep. ok.
02:25:36 <musasabi> Since people will use that for non-latin1 things.
02:25:44 <musasabi> (I use it for utf8)
02:26:06 <musasabi> and there is Latin2,3,4,5,6...
02:26:40 <dons> right. so you'll use the Char ops to get a cleaner interface to the byte layer for your UTF stuff?
02:27:01 <musasabi> I use the Char layer for UTF at the moment.
02:27:04 <Lokadin> nm i figured out a better way
02:27:28 <dons> hmm. Data.ByteString.Char ?
02:27:51 <musasabi> Sounds quite neutral and tells what it is.
02:28:32 <dons> yeah, that's seems quite nice really.
02:30:37 <musasabi> The word8 interface is nice too, but with literals quite painful to use.
02:30:54 <dons> yeah. it'll be useful I think for really efficient code.
02:31:03 <musasabi> -> lunch
02:31:14 <musasabi> (the really efficient code just grabs the Ptr etc ;)
02:31:18 <kzm> dons, musasabi: I'm apparently misunderstanding how this works. I thought ByteString now gives W8, and any Char-based interface relies on encoding/decoding that.
02:31:36 <kzm> Thus latin1 describes interpreting w8 according to that.
02:32:03 <musasabi> (will talk about that when I get back)
02:32:12 <kzm> And musasabi should decode UTF8 from the Word8 layer, rather than going via latin1?
02:32:29 <dons> I can imagine a more complex Data.ByteString.UTF8
02:32:43 <shapr> bringert: One cool trick would be to compare automatically generated grammar models with existing grammar theories. I wonder how many discrepancies would show up?
02:33:02 <bringert> lots and lots I think
02:33:26 <bringert> the generated grammar will not take semantics into accoount
02:33:32 <dons> kzm, yeah, I'd think so. but you get slightly nicer literals at little to no cost if he uses Data.ByteString.Char 
02:33:39 <bringert> which I think existing theories try to
02:34:13 <kzm> What guarantees are there for string constants in source code?
02:34:40 <Lokadin> dons: say with hs-plugins i can't hot-reload the core can i? as in the starting application
02:34:58 <dons> sure.
02:35:03 <dons> that's what 'reload' is for.
02:35:05 <bringert> heh, ghc error message:
02:35:06 <shapr> bringert: If you do end up implement ADIOS, it would be neat to apply it to the unreadable knot writings of the ... mayas? 
02:35:07 <bringert> demo.hs:56:46:
02:35:07 <bringert>     Couldn't match kind `(* -> *) -> * -> *' against `?? -> ? -> *'
02:35:07 <bringert>     When matching the kinds of `t :: (* -> *) -> * -> *' and `(->) :: ?? -> ? -> *'
02:35:09 <dons> check the 'Dynamic Apps' paper
02:35:21 <dons> very nice bringert 
02:35:27 <Lokadin> dons: really? *is blown back*
02:35:39 <dons> oh, hmm. sorry. the static core?
02:35:52 <Lokadin> er well i guess you'd call it that
02:35:59 <shapr> bringert: Oops, Incas - http://www.ee.ryerson.ca/~elf/abacus/inca-khipu.html
02:36:01 <Lokadin> i was wondering if you could change version numbers
02:36:02 <dons> no, the trick is to avoid the static core, by hoisting all the code into the dynamic land
02:36:07 <dons> that's the subject of the paper i meant
02:36:23 * bringert wrote a hack where the application checks it's time-stamp, and then exec's itself if it is out of date
02:36:32 <bringert> eh s/it's/its/
02:36:33 <Lokadin> i'm a little confused, so how do you make all dynamic code?
02:37:25 <Lokadin> dons: can you point me to a howto or docs or anything?
02:37:35 <bringert> shapr: or Linear A
02:38:19 <shapr> oh yeah!
02:38:22 <dons> Lokadin: just that paper
02:38:29 <dons> ?google Dynamic applications from the ground up
02:38:31 <lambdabot> http://www.cse.unsw.edu.au/~dons/papers/SC05.html
02:38:34 <araujo> Good morning!
02:38:53 <Lokadin> dons: thanks a bunch :) 
02:43:53 <goltrpoat> [04:16] <shapr> bringert: Oh yeah, I remember one...Have you seen the paper "unsupervised learning of natural languages" by Solan, Horn, Ruppin & Edelman?  <-- i've read that
02:54:43 <musasabi> back
02:54:53 <musasabi> kzm: why would I want to decode/encode it?
02:54:59 <shapr> goltrpoat: Have you seen http://www.cs.chalmers.se/~aarne/GF/ ?
02:58:14 <reppie> http://grouphug.us/confessions/162390143
02:58:19 <musasabi> kzm: the report guarantees things for character constants:
02:58:24 <musasabi> "This library provides a limited set of operations on the Unicode character set. The first 128 entries of this character set are identical to the ASCII set; with the next 128 entries comes the remainder of the Latin-1 character set. This module offers only a limited view of the full Unicode character set; the full set of Unicode character attributes is not accessible in this library."
03:09:58 <dons> good point 
03:13:36 <musasabi> Most of the time my data is mostly UTF8, but I have binary blobs which can be be illegal utf-8 in the middle, and even if I could ignore decoding errors the decoding would not help me in any way.
03:16:14 <shapr> dons: Hey, @remember is gone from the Quote module, is that just because it doesn't have a help message?
03:18:22 <kzm> musasabi, sorry, I thought you were decoding utf8.
03:18:40 <kzm> But is is correct to say that this is all about string literals?
03:19:30 <kzm> saving the trouble of inserting something like "map (fromIntegral.ord)" on strings.
03:20:18 <kzm> I still think latin1 is actually a good name for the char interface, because those are the chars you are getting.
03:20:26 <musasabi> kzm: I am handling mostly utf8 (+binary) data and do all my matching in the ascii subset. To match things Chars are much nicer than Word8, thus the need for a raw Char<->Word8.
03:21:33 <kzm> musasabi: would it be better to overload "foo" literals to Integral a => [a]?
03:21:43 <kzm> (although perhaps not practical)
03:21:56 <kzm> (just trying to grok the issues)
03:22:00 <musasabi> that would solve the issues (I would just switch to the Word8 interface)
03:22:40 <musasabi> kzm: there are at least 20-40 quite common single byte char encodings.
03:22:45 <kzm> My "problem" is that the char interface assumes an encoding, and naming it after the assumed coding seems like an appropriate thing to do.
03:24:11 <kzm> My situation is fairly similar to yours, I have data mostly in ASCII, and I certainly don't care much for the non-ascii parts.  Just want them preserved, is all.
03:24:21 * kzm hasn't ported to FPS yet, though.
03:24:42 <musasabi> but the point is that when the data is *not* Latin1 calling it Latin1 is very misleading.
03:25:12 <musasabi> Latin1 includes rules about character types etc I think.
03:25:15 <kzm> and my point is that when you chose to interpret them as latin1, that should be explicit.
03:25:17 <dons> yep.
03:25:38 <kzm> So does unicode, and by extension, Char.
03:26:07 <dons> so i've now moved things into: Data.ByteString, all Word8 ops plus IO. and Data.ByteString.Char, provides a ascii/8-bit Char layer over the top.
03:26:24 <dons> all it exists for, Data.ByteString.Char, is to handle the no-good-Word8-literals issue
03:27:36 <musasabi> dons: thanks, that works very well for me :-)
03:28:00 <dons> hopefully that is a good balance between need-for-speed issues, and the type issues.  
03:28:28 <dons> since its all about making a faster String, after all.
03:29:30 <kzm> So to get one of the 19-39 other single-byte encodings, I will now use the char interface to get "Chars" in the 8859-1 subset, and then convert them to Chars representing the actual characters?
03:29:44 <kzm> s/subset/range/
03:30:14 <musasabi> kzm: if you don't like the char interface you can just use the Word8 one.
03:30:38 <dons> right. then its fairly trivial to add your own conversion functions over the top.
03:30:38 <kzm> I like the char interface, I just don't like the canonization of one particular encoding.
03:30:49 <dons> all the Data.ByteString.Char functions are 1 liners
03:30:50 <dcoutts> xerox, here's another SoC idea: port the meld diff/merge widget from pygtk to gtk2hs. Such a widget would be really useful for IDEs and a darcs GUI.
03:31:01 <musasabi> kzm: of course many of them have ascii as a common subset thus if you just need to break/things on that subset you can use it directly.
03:32:01 <kzm> I guess this is just a question of names.  And perhaps we agree that the solution is really to make String polymorphic, at least in theory.
03:32:16 <kzm> Where do the other encodings fit in the module namespace?
03:33:35 <dons> I'd imagine a full Data.String.* perhaps
03:33:51 <musasabi> I think that a fancy UTF8 module + conversion functions between the various encodings could work.
03:34:09 <musasabi> There are some issues how one will treat e.g. ISO-2022-JP 
03:34:28 <dcoutts> there are a whole load of unicode functions (eg sorting, word breaking etc)
03:34:35 <dcoutts> see ICU
03:34:43 <dcoutts> @google ICU Unicode
03:34:45 <lambdabot> http://icu.sourceforge.net/
03:35:24 <musasabi> which normalization model is Ord for Char using?
03:35:49 <musasabi> hmm that won't work :-(
03:36:40 <musasabi> Is it possible to have "instance Ord a => Ord [a]" to work with unicode strings in a good manner?
03:36:52 <kzm> Isn't this going overboard if I just want latin-15 (or whatever I need for the euro symbol, for instance)?  As dons said, it's a collection of oneliners.
03:37:44 <dcoutts> well maybe, but on the other hand confusion between string encodings is a major source of bugs
03:37:50 <musasabi> kzm: I think that using it Data.String.Char as Latin15 will just work, of course euro-literals won't work. ;)
03:38:53 <kzm> dcoutts, exactly, so any conversion/interpretation should be explicit.
03:39:17 <dcoutts> kzm, yes. and possibly seperated by type changes
03:39:35 <kzm> The naive user will see a function from ByteString -> [Char] and assume he gets the right Chars.
03:39:48 <dcoutts> that, and there are some realy differences between encodings (variable width vs fixed width)
03:40:15 <dcoutts> so there are different operations available on different encodings
03:40:26 <musasabi> I think statefull vs stateless is a more profound difference.
03:40:43 <dcoutts> musasabi, yes I was just about to mention that one
03:41:00 <musasabi> it will create a situation where "ByteString -> [Char]" is not an injection.
03:41:11 <kzm> and title case, and combining characters, and, and...
03:41:14 <dcoutts> you can fold over all of them but indexing is near impossible
03:41:52 <musasabi> yes combining characters make things really fun and are one reason I think substrings are better than splitting things into physical unicode characters.
03:42:05 <kzm> substrings?
03:43:06 <kzm> Anyway, the complexities and intricacies of Unicode is not an argument against making explicit the assumptions for single-byte encodings.
03:43:08 <musasabi> yes. not operations on invidual characters but operations on substrings.
03:43:39 <dons> ok, hopefully final shuffle: http://www.cse.unsw.edu.au/~dons/fps/new/
03:44:04 <kzm> If I want to work on data in KOI8 or greek, it would be really nice to use those characters in (Unicode) string constants, import ByteString.KOI8 or whatever, and have the Char funcitons just work.
03:44:37 <musasabi> realistic aplications usually need to handle multiple encodings at once.
03:44:47 <musasabi> and many times they work in an encoding agnostic way.
03:44:56 <dcoutts> dons, some of the docs for the .Char version don't match up
03:45:07 <dcoutts> packChar :: Char -> ByteString
03:45:07 <dcoutts> O(n) Convert a Word8 into a ByteString
03:45:16 <dcoutts> O(n) ?
03:45:27 <musasabi> which is the way many RFCs are written - they work for any superset of ASCII with a few limitations.
03:45:28 <dcoutts> and it'd be convert Char into a ByteString
03:45:32 <dons> oh, looks like pasto
03:45:35 <kzm> a Word8?
03:45:48 <dons> most comments come from the Word8 equivalents...
03:45:52 <dcoutts> dons, do you want more nickpicking?
03:45:57 <dcoutts> nit
03:46:00 <dons> yes please.
03:46:02 <dcoutts> ok...
03:46:04 <kzm> musasabi, yes.  If you need to handle multiple encodings, making them explicit is even more important.
03:46:44 <dons> that comment was wrong for both packChar and packByte
03:46:49 <dcoutts> dons, ok the only stray Word8 I can see is in packChar & unpack
03:46:51 <ct16k> can anyone please help me make this shorter: map chr (map (+1) (map ord "K`\USltksh\US`mh "))
03:46:53 <ct16k> :)
03:47:17 <kzm> > pl  map chr (map (+1) (map ord "K`\USltksh\US`mh "))
03:47:18 <lambdabot>  Not in scope: `pl'
03:47:24 <dcoutts> >  map (chr.(+1).ord) "K`\USltksh\US`mh "
03:47:26 <lambdabot> "La multi ani!"
03:47:30 <kzm> Ah, urg.
03:47:47 <dons> thanks dcoutts
03:47:53 <ct16k> it's happy birthday in romanian
03:47:56 <ct16k> :)
03:48:06 <musasabi> > [ chr (ord x + 1) | x <- "K`\USltksh\US`mh "]
03:48:07 <lambdabot> "La multi ani!"
03:49:30 <dcoutts> dons, Data.ByteString.Char can't export all of Data.ByteString ?
03:49:36 <musasabi> kzm: depends on the definition of handling the encodings, usually the less apps "handle" text the easier they are to make work with different encodings.
03:49:42 <ct16k> dcoutts: thank you
03:49:52 <dons> well, it could I guess. it's tricky to get it right though, since many function names overlap
03:50:01 <musasabi> Having the IO operations there would be nice.
03:50:15 <dons> yeah
03:50:16 <dcoutts> dons, because many clash right? it should just export the non-encoding specific ones
03:50:32 <dons> dcoutts, yes. it can be done. i'll do it.
03:50:45 <dcoutts> dons, right but at the moment they will clash because you are exporting the module
03:51:23 <dons> only the things I import, though, right?
03:51:36 <dons> which is specifically just the list-ish ops
03:51:40 <dcoutts> oh, yes
03:51:45 <dons> no IO. but I could import the io and get it exported too
03:51:51 <musasabi> dons: thank you very much for listening and providing the .Char :-)
03:52:24 <dcoutts> dons, yes, I think it is an improvement, even if it means most people start using Data.ByteString.Char for convenience
03:52:26 <dons> musasabi: I'm on your side with these things. I want to use fps in the base libs for real world code. So making sure you're happy means I'm probably going to be happy too :)
03:52:59 <dons> one improvement is that there's a whole new api for Word8 programming :)
03:53:05 <dcoutts> dons, because then it's possible for people to add other layers if the bottom layer is agnostic (and fast :-) )
03:53:15 <dons> yep
03:53:53 <dcoutts> dons, did you understand SimonM's idea about a third form of ForeignPtr ?
03:54:18 <dons> yeah. I think its a good idea too
03:54:20 <dcoutts> dons, it'd allow most ordinary short strings to be movable by the GC and save 2 Ints?
03:54:20 <dons> more speed!
03:54:33 <dcoutts> I didn't quite follow exactly how that works
03:54:54 <dons> just simplifying the most common ForeignPtr usage, iirc
03:55:02 <dons> since we never need lists of finalisiers in practice
03:55:03 <dcoutts> So the two existing forms are for fixed strings that can be passed to foreign code
03:55:08 <dcoutts> and one form has finalisers
03:55:37 <dcoutts> or do they both have finalisers?
03:56:10 <dcoutts> and one form is allocated on the GC heap (but not movable) and the other is genuinely a foreign pointer
03:56:53 <dons> hmm. I'll have to check his comment again
03:57:07 <musasabi> there is the addForeignPtrFinalizer
03:57:11 <musasabi> but -> meeting
03:57:43 <dcoutts> since as someone keeps banging on, the ByteString does have the advantage that it is moveable by the GC which for short strings is an advantage
03:57:59 <dcoutts> err ByteArray#
03:58:50 <dons> ok, the IO functions are now exported too
03:59:49 <dons> I'll mail the libraries list.
04:03:12 <dcoutts> data ForeignPtrContents
04:03:12 <dcoutts>   = PlainForeignPtr !(IORef [IO ()])
04:03:12 <dcoutts>   | MallocPtr (MutableByteArray# RealWorld) !(IORef [IO ()])
04:03:22 <dcoutts> and then
04:03:27 <dcoutts>   | PlainMallocPtr (MutableByteArray# RealWorld)
04:03:58 <dcoutts> so actually it's already unpinned?
04:04:14 <dcoutts> MutableByteArray# & ByteArray# are not pinned I think
04:04:42 <dcoutts> so do they only get pinned when being passed to foreign code?
04:06:30 <dcoutts> mm, ByteArray# must be non-pinned since it's used by Integer
04:08:00 <dons> yeah, I think its just a normal heap object
04:08:12 * dons detects magic
04:08:54 <Itkovian> did you roll for it?
04:16:11 <lisppaste2> metaperl pasted "getting MonadPlus to work" at http://paste.lisp.org/display/19352
04:16:40 <metaperl> could I get some help importing MonadPlus into one of the nomaware examples: http://paste.lisp.org/display/19352
04:18:04 <Lokadin> dons: is your name actually don stewart?
04:18:09 <dons> yep
04:18:15 <dons> why?
04:18:36 <dcoutts> dons, dunno, ask you parents
04:18:39 <dcoutts> ;-)
04:18:49 <Lokadin> no it's just shapr and bringert were saying how they were using made up names on SoC
04:19:04 <Lokadin> and i thought that Don Stewart did seem rather suspicious
04:19:11 <dons> suspicious!!?
04:19:14 <dcoutts> heh
04:19:24 <dcoutts> poor dons :-)
04:19:24 <metaperl> could I get some help importing MonadPlus into one of the nomaware examples: http://paste.lisp.org/display/19352
04:19:26 <Lokadin> lol :P John Stewart funny guy
04:19:27 <Lokadin> lol
04:19:33 <olliej> wooo, i have unbroken my compiler
04:19:35 <dons> oh, John Stewart. yeah.
04:19:49 <Lokadin> yea, i watch lots of daily show
04:19:51 <bringert> Lokadin: just for the record, my name is actually bringert
04:19:53 <bringert> not shapr
04:19:56 <Lokadin> and that paper's really good btw
04:20:01 <dons> cheers
04:20:10 <Lokadin> bringert: alright :)
04:20:31 <metaperl> I dont believe it. Anytime I paste using paste.lisp.org, I get ignored
04:20:32 <metaperl> anytime
04:20:35 <metaperl> never fails
04:21:02 <mauke> @index mplus
04:21:03 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
04:21:12 <mauke> try import Control.Monad
04:21:22 <metaperl> mauke: thanks
04:21:54 <shapr> On the other hand, my name really is shapr.
04:22:30 <kzm> And I, on the third hand, is really number 7.
04:24:06 <metaperl> ok, now I am getting a kind error from my attempt to define Sheep as MonadPlus: http://rafb.net/paste/results/mW5y9y47.html  ... any help is appreciated
04:24:49 <mauke> ah, yes
04:25:03 <mauke> monads must be polymorphic
04:26:02 <kzm> dons, do you know if there is a ticket for polymorphic strings for H'?
04:26:08 <kzm> string constants, that is
04:26:31 <kzm> and if not, should there be?
04:26:40 <flux__> polymorphic strings?
04:27:45 <metaperl> mauke: does your comment refer to my problem: http://rafb.net/paste/results/mW5y9y47.html   ??
04:28:14 <mauke> yes, an instance m of Monad must take a type parameter
04:28:23 <mauke> so you can do m a -> m b, etc
04:29:56 <metaperl> mauke: if you look at the definition of Maybe and List in the report, they do not: http://www.haskell.org/onlinereport/monad.html
04:30:29 <mauke> sure they do
04:30:38 <mauke> there's Maybe a and [a] (== [] a)
04:30:39 <metaperl> oh?
04:30:46 <metaperl> not in that instance decl
04:30:52 <mauke> no, in the type definition
04:31:02 <metaperl> hmm
04:32:00 <kzm> ghci seems to interpret string constants as latin1, in my (presumably) unicode xterm, a character > 128 is turned into two Chars
04:38:50 <metaperl> mauke: FYI, they did not make the type definition polymorphic. And they imported Monad instead of Control.Monad to get `mplus` to work: http://www.nomaware.com/monads/examples/exercise2.hs
04:40:17 <dcoutts> dons, filterChar & filterNotChar should be in the "Searching by equality" section rather than the "Searching with a predicate"
04:41:02 <dcoutts> dons, and perhaps the note about "This implementation uses memchr(3)." is not necessary, just a note at the top of the "Searching by equality" section that these are optimised special cases of the more general predicate versions
04:41:44 <dcoutts> dons, though the "filterChar is around 3x faster, and uses much less space, than its filter equivalent" is very informative
04:42:19 <dcoutts> but "This implementation uses memchr(3)." is less so, a factor is much more useful to the user than a guess based on the impl
04:43:24 <vincenz> dum dum
04:45:12 <dcoutts> dons, I see references to join but no implementaion. Am I confused?
04:45:30 <dcoutts> or is it the ordinary join?
04:45:36 <dcoutts> @type join
04:45:38 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
04:46:21 <alar> join [[1,2,3],[4,5],[6]]
04:46:28 <alar> > join [[1,2,3],[4,5],[6]]
04:46:29 <lambdabot> [1,2,3,4,5,6]
04:47:58 <dcoutts> dons, oh the Word8 version has join, that's what I didn't spot
04:49:18 <dcoutts> dons, for the purposes of documentation, perhaps it'd be better to explicitly export everying from Data.ByteString.Char so we see the whole api there, rather than having to reffer to Data.ByteString for generic ops like join etc
04:52:38 * alar wonders how does join work in state monad
04:54:10 <metaperl> this might be a dumb question, but if I type a function as parent :: Sheep -> [Sheep] and then write parent s = return s   what container does s get wrapped in and why?
04:54:39 <dcoutts> > return 3 :: [Int]
04:54:42 <lambdabot> [3]
04:55:26 <dcoutts> metaperl, because [] is the monad you are using (you specified that in the type)
04:55:37 <metaperl> I see. thanks
04:55:39 <dons> dcoutts, yeah, good idea about the explicit exports.
04:56:13 <dcoutts> dons, also, what do you think about only putting char-oriented functions in .Char, eg words, unwords
04:56:28 <dcoutts> since they need to make assumptsions about the encoding of '\n'
04:56:49 <dcoutts> leave generic Word8 versions in the base module
04:57:01 <dcoutts> so you can split/join on any word8
04:57:12 <dcoutts> and only have special char handling versions in the .Char module
04:57:19 <dcoutts> just an idea
04:57:49 <dcoutts> I'm not sure how far you wan't to take the Word8/Char split
04:57:59 <dons> dcoutts, that's a reasonable idea. it was hard to pick how to split thsoe.
04:58:06 <dons> probably they should go in *.Char thoguh
04:58:07 <dcoutts> I bet
04:59:15 <dons> ok, i fixed the filterChar placing. and the other points i'll do in the morning.
04:59:27 <dons> keep looking for more things, if you like. it's very helpful.
04:59:32 <dcoutts> dons, ok
04:59:48 <metaperl> is there some sort of general function like this (Maybe a -> [a]) so that Nothing -> [] and Just a -> [a]
04:59:50 <dcoutts> dons, i'll follow up to your last email
05:00:00 <dons> kzm, I'm not sure what the alternatives would look like. Would you like to work out an alternative namespace?
05:01:28 <metaperl> ah: http://www.haskell.org/hoogle/?q=Maybe+a+-%3E+%5Ba%5D
05:02:42 <kzm> dons, uh, where was I?
05:03:19 <dons> oh, just responding your mail, via irc. :)
05:03:26 <kzm> dons, naturally.
05:03:32 * kzm smiles.
05:04:04 <kzm> Well, I liked it when ByteString.Char was named after the encoding, i.e. ByteString.Latin1.
05:04:25 <kzm> Then, you could add ByteString.Latin15, ByteString.whateverwithgreekcharacters, etc etc
05:04:42 <kzm> This would a) make it explicit that the chars you get are with respect to some encoding.
05:04:58 <kzm> b) make it really easy to handle just about any single-byte encoding
05:05:33 <kzm> (although, correct me if wrong, but some w8 functions (words?) might need replacement too for non-ASCII encodings)
05:06:17 * kzm shrugs.  Not a big deal, perhaps.  What's that saying about discussing syntax issues?
05:06:58 <dons> yeah, those words/lines etc will go into ByteString.Char, dcoutts noticed that too
05:07:22 <kzm> I can still make ByteString.Latin15 of course, but it doesn't appear as an alternative to ByteString.Char.
05:07:44 <dcoutts> dons, sent
05:07:47 <kzm> Right, it is nice if the leaf module is all you need to import.
05:08:07 <dons> I was thinking though about musasabi's point that Latin1 would still do the same work as Latin2 and others.
05:08:14 <dcoutts> I wonder if we could pin down the assumptions that the ByteString.Char module is making about encodings?
05:08:19 <dons> so Latin1 wouldn't necessarily be the most general name for that functionality.
05:08:31 <dons> dcoutts, that would be a good idea.
05:08:39 <dcoutts> I suspect that we can say that it's ok for any fixed width encoding with ASCII as a subset
05:08:43 <kzm> Well, but if the ByteString contains Latin2 characters, you must translate the latin1 code points into latin2
05:08:50 <dcoutts> ie Latin* but not UTF8
05:08:57 <dons> dcoutts, that's right, I think.
05:10:00 <dcoutts> dons, I wonder if there is a good name that describes that (possibly to address the .Char vs .Latin1 debate)
05:10:18 <vincenz> aloha
05:10:21 <dcoutts> .Char8 ?
05:10:22 <dons> ah, I see Simon likes Latin1 too.
05:10:32 <kzm> If you export everything from the "Char" type modules, then the ASCII subset restriction goes as well - but I will have to redefine words to look for a different space character(s)
05:10:36 <dons> yeah, I actually thought about Char8. it's not bad.
05:11:11 <kzm> But it is not.  A latin2 character is translated into a latin1 code point, which represents a different character!
05:11:19 <dcoutts> where as a full unicode fixed width 4-byte encoding would be what? .Char ? .Char32 ?
05:11:31 * kzm resorts to exclamation marks in the hope that it will help bring the point across.
05:11:35 <dons> dcoutts, would you like to mention this in reply to Simon? and kzm too, perhaps you could state some of these concerns.
05:11:51 <dons> on the mailing list. so others can participate.
05:12:17 <dons> I'm off to bed now!
05:12:46 <kzm> checked the mail, whee, I don't feel so lonely anymore!
05:12:53 <dons> :)
05:12:54 * kzm smiles at the end of a bad day.
05:13:14 <kzm> (unrelated to this issue, of course.  I'm not *that* sensitive)
05:16:55 <dcoutts> dons, done
05:17:29 <dcoutts> kzm, how compatible are the various Latin* encodigns then? I have to say I'm pretty ignorant.
05:17:39 <dcoutts> kzm, do they share the first 127 chars?
05:21:05 <kzm> dcoutts, yes, I think that is correct.
05:21:13 <kzm> I'm no expert, but AFAIK:
05:21:46 <kzm> iso-8859-* contain a bunch of charsets with 127 character ASCII in common, and individual defs for 128-255
05:22:01 <kzm> iso-8859-1 == latin1
05:22:14 <kzm> but others include greek characters and so forth.
05:22:16 <flux__> isn't ASCII 7-bit anyway?
05:22:21 <dons> ah, so as long as isSpace and \n are the same, then the existing ByteString.Char wouldn't care?
05:22:33 <dons> which latin* it is given.
05:22:40 <dons> the programmer might care, of course
05:22:44 <kzm> then there are non-ascii single byte charsets, like koi8 for russian (reputedly, I haven't used it)
05:22:53 <kzm> and EBCDIC for old IBM mainframes
05:23:40 <kzm> dons, how about isUpper?
05:24:15 <kzm> then there is utf8, which is ASCII compatible, but encodes extended characters in multiple bytes (starting with >127)
05:24:36 <kzm> and fixed-width multi byte unicode: utf-16, ucs-4 etc
05:24:49 <kzm> (this concludes the character set lecture :-)
05:25:14 <kzm> Oh, forgot, one common charset is windows-somethingorother, which looks like latin1, but uses funny quotes
05:25:29 <dcoutts> kzm, so the Char you get back from a latin-foo string would not be a 'real' Char and the unicode isUpper wouldn't work
05:25:33 <kzm> And of course, windows codepages, which are like the iso charsets (ascii in bottom)
05:25:55 <dons> isUpper isn't used inside ByteString.* , but I think since both Ross and Simon (library gurus) think Latin1 is a better name, then that might just be that.
05:26:09 <kzm> and ISO-646, which replaces some ascii characters (using brackets for Ã¦ Ã¸ Ã¥ in Norwegian, for instance)
05:26:19 <dons> and then I can get back to issues of making the code faster!
05:26:22 <dcoutts> kzm, to make isUpper :: Char -> Bool work for latin-foo you'd need to translate the char to a 32-bit unicode Char
05:26:32 <kzm> dons, but I'm likely to extract some Char from by bytestring, and use isUpper on it.
05:26:57 <kzm> dcoutts, yes.  The Char is a 32 bit unicode char (code point) already.
05:26:58 <dons> yeah, I think I understand the situation now.
05:27:02 <dcoutts> kzm, yeah, that'll go wrong for chars >127
05:27:07 <kzm> I just need to pick the right one.
05:27:29 <dcoutts> unless you translate, and that needs knowing the charset
05:27:32 <kzm> dcoutts, if you don't differentiate between the latin*, yes.
05:27:34 <dons> we need to force Latin1 so that people know not to assume _their_ code will work for any 8 byte encoding. or even any Latin* encoding.
05:28:03 <dcoutts> even Latin1 could be pushing it
05:28:15 <dcoutts> since isUpper probably won't work for >127
05:28:16 <kzm> or just a) make people aware of the limitations, and b) provide a "slot" for alternative decoding modules
05:28:26 <dcoutts> (if there are upper case chars in Latin1 >127)
05:28:45 <kzm> dcoutts, yes there are.
05:28:55 <dons> kzm, I think Data.ByteString.Latin1 will be  the first entry, which leaves open everything until we have full 32 bit ByteString.Char
05:29:02 <kzm> oslash Ã¸ and Oslash Ã
05:29:05 <kzm> for instance
05:29:25 <dcoutts> dons, so as it stands it's not even Data.ByteString.Latin1 but rather Data.ByteString.ASCII
05:29:30 <kzm> dons, but, but, how do you envision doing that (the full 32)?
05:29:39 <dcoutts> since we can't promise to return valid Chars
05:29:52 <kzm> don't you need Data.FourByteString for that?
05:30:24 <dons> kzm, it's jsut a group of 4 Word8s, right?
05:30:30 <kzm> dcoutts, is it a problem in practice?
05:30:38 <dons> and I can pack my Word8 buffers anyway I want
05:31:10 <dons> dcoutts, hmm, yeah, but that's more the problem of Data.Char
05:31:10 <dcoutts> kzm, well if you care about your isUpper example then yes, otherwise no
05:31:34 <dcoutts> dons, but the point is that Data.Char (rightly) assumes that Char is a Unicode code-point
05:31:35 <kzm> yes, but if I read a file into a ByteString, I must select an encoding.  There can be no magic Char module.  Unless it usees the locale or something.
05:31:56 <dcoutts> but ByteString.Char will not return valid Chars (for >127)
05:32:15 <kzm> dcoutts, hmm  isUpper will just return false on invalid characters, won't it?
05:32:19 <dons> hmm, 'not valid' ?
05:32:23 <dcoutts> dons, unless you actually do a Latin1 -> Unicode translation when getting Chars in/out
05:32:57 <dons> hmm
05:33:03 <dcoutts> kzm, dons, suppose I have a latin1 string with an upper case char with a mark (eg ^)
05:33:05 <kzm> dcoutts, it will if it is reading latin1.  iso-8859-1 maps to the same code points in Unicode.
05:33:17 <dcoutts> kzm, oh it does?
05:33:20 <dcoutts> oh well that's ok then
05:33:22 <kzm> so '\xyz' in latin1 is code point xyz
05:33:46 <dons> right, dcoutts was starting to worry me
05:33:47 <dcoutts> so it will return valid Unicode Chars then
05:34:01 <kzm> but for all other charsets, there must be some shuffling of values >127, and for some (EBCDIC, MS code pages, ISO-646) also below 127.
05:34:12 <dcoutts> dons, yeah, so that would only be true for all other Latin* encodings which do not map directly to Unicode
05:34:23 <dons> ah, yes.
05:34:39 <dcoutts> I wasn't aware of Latin1 mapping in directly, I thought it was only <127 that mapped in directly
05:35:02 <dcoutts> dons, so on that basis it should be called .Latin1
05:35:03 <kzm> but this shuffling is relatively straightforward, I think, so it is easy to implement siblings of Latin1.
05:35:48 <dons> they'd have slightly different w2c and c2w functions, I'd imagine.
05:35:57 <dcoutts> right
05:36:01 <dons> making Latin2 ... fairly easy to set up.
05:36:20 <dons> ok. /me really goes to be now. night!
05:36:24 <dcoutts> w2c & c2w are essentially no-ops currently right dons?
05:36:36 <dcoutts> g'night dons!
05:36:39 <kzm> you could even provide a generalized interface - parametrized by isSpace and other predicates, couldn't you?
05:36:42 <kzm> :-)
05:37:02 <dcoutts> paramaterisable modules please
05:37:03 <kzm> (which wouldn't give the right code points for any chars, but still)
05:37:17 <kzm> night
05:37:31 <kzm> yes, yes.  Gimme, gimme. :-)
05:38:07 <kzm> Seriously, perhaps the Word8-based interface could simply be provided the necessary predicates, and thus work on arbitrary charsets?
05:50:08 <shapr> @seen doaitse
05:50:11 <lambdabot> I saw doaitse leaving #haskell 4 days, 21 hours, 17 minutes and 29 seconds ago, and .
05:50:19 <shapr> @seen SyntaxNinja
05:50:24 <lambdabot> I saw SyntaxNinja leaving #haskell 12 hours, 17 minutes and 25 seconds ago, and .
05:54:34 <musasabi> home
05:55:16 <__phas>  @seen xerox
05:55:27 <__phas> @seen xerox
05:55:28 <lambdabot> I saw xerox leaving #haskell.it, #haskell-overflow, #haskell-blah and #haskell 1 hour, 53 minutes and 19 seconds ago, and .
05:56:19 <musasabi> dons: the space functions should go from the Word8 module.
05:57:12 <musasabi> dcoutts: UTF8 has ascii as subset.
05:57:25 <dcoutts> musasabi, but it's not fixed-width
05:57:41 <musasabi> dcoutts: and why is that a problem?
05:57:58 <dcoutts> musasabi, because the indexing etc will not work
05:57:58 <musasabi> dcoutts: if you just split on the ascii subset you don't have to care about it.
05:58:23 <dcoutts> you'll say head and get something that is not a Char
05:59:07 <musasabi> dcoutts: you test it against the ascii values you are interested with and then just use the "this is something I was not excepting" case.
05:59:12 <dcoutts> the current .Latin1 module really does assume a fixed width (and if we're being strict then it also assumes Latin1 and not any old 8-Byte encoding with ASCII as a sbuset)
05:59:47 <musasabi> dcoutts: and what good does a single physical unicode character do?
06:00:01 <musasabi> dcoutts: it can be a combining character and then you need a second one to know what it means.
06:00:13 <dcoutts> musasabi, sure you could use it with UTF8 and get various failure cases but it'd be better to have a .UTF8 module that at least gives you code points
06:00:50 <dcoutts> musasabi, yes, but that's a lesser degree of brokeness than treating UTF8 as fixed width
06:00:50 <musasabi> dcoutts: I think there should be separate modules for hanling higher level encoding concerns.
06:00:56 <dcoutts> yes there should
06:01:23 <dcoutts> hence ByteString.Latin1 and a hypothetical ByteString.UTF8
06:01:27 <musasabi> Data.ByteString.Char should be there for the ones needing "something as ascii in the subset"
06:01:52 <dcoutts> and then I'm sure you want something for figouring out the combining char mess
06:02:32 <dcoutts> musasabi, but what guarantees would that have? If I put in ASCII I get ASCII out and otherwise garbage?
06:02:33 <musasabi> Latin1 means things like the meanings of characters > 127, what I don't want to define.
06:02:57 <dcoutts> if you don't define it you cant use Char in the interface
06:03:04 <musasabi> dcoutts: basically "I know how this is encoded, but using the Word8 API is too much pain"
06:03:04 <dcoutts> since Char is defined
06:03:25 <musasabi> Char is defined to have a fixed encoding to numbers.
06:03:41 <dcoutts> musasabi, then abuse the .Latin1 module for non-latin1 encodings and deal with the corner cases
06:03:52 <musasabi> It is still not latin1
06:04:05 <musasabi> Why name it by something it is not?
06:04:13 <dcoutts> but it is only latin1
06:04:37 <musasabi> And then we will have Latin<X> modules with added encoding functionality and Latin1 will be different from them?
06:04:37 <dcoutts> it should work in all cases for latin1 (it may work in most cases for non-latin1)
06:05:07 <dcoutts> the point is that there is a trivial mapping of Latin1 -> Char
06:05:17 <dcoutts> that's not true for the other Latin encodings
06:05:34 <dcoutts> bascially you need to know the encoding to get Chars
06:05:44 <dcoutts> otherwise you've got Word8s
06:06:24 <musasabi> I can get Char <-> Number <-> Word8 (subset), that is enough. And it is fixed.
06:06:43 <dcoutts> musasabi, yeah, that's one possability (to have various Latin<X> modules)
06:07:09 <dcoutts> musasabi, or you can make a general one parameterised by the Word8 <-> Char mapping
06:07:22 <dcoutts> or something else for non-fixedwidth encodings
06:07:35 <musasabi> dcoutts: is there a reason against having the Char module? Wouldn't it be much more sensible for you to create a Data.String.<WhateverFancyEncoding> module for the fancier needs?
06:08:03 <dcoutts> what assumptions would that module make?
06:08:53 <musasabi> The Char module? Raw chr/ord and nothing else. It is just only prettier syntax for the Word8 module.
06:09:16 <dcoutts> the reason against calling the current implementation the Char module is that it wouldn't give you Chars
06:09:43 <dcoutts> (unless the encoding you happen to use is Latin1)
06:10:13 <dcoutts> you could make a Char module and have it be parameterised by the encoding
06:10:28 <musasabi> and worse performance.
06:10:32 <dcoutts> indeed
06:10:48 <dcoutts> but the current impl doesn't do that because it's a very thin wrapper over the Word8 impl
06:11:02 <musasabi> yes, which is exactly what I need.
06:11:06 <dcoutts> and that really only works for Latin1
06:11:23 <musasabi> which works with UTF8 on the ascii-subset.
06:11:35 <dcoutts> yes it would do
06:11:51 <dcoutts> but that's just the same thing as saying it works with ASCII
06:12:28 <musasabi> Many RFC implementations are like that, everything that is important is ASCII, the rest can be utf8, Latin<X> or something else.
06:13:12 <musasabi> Since one only splits on ascii and checks for equality of substrings one does not care where the character boundaries are.
06:13:56 <dcoutts> suppose you pass me a Data.ByteString.Char, what assumptions can I make about it? I don't know the encoding (though I know that '\n' maps to 0xfoo)
06:14:07 <kzm> I'm trying to run the tests in the FPS dir, but it can't find logpp.  Google isn't too helpful.  Any hints?
06:14:25 <musasabi> dcoutts: you can make the same assumptions as with a Data.ByteStrings which is none.
06:14:39 <musasabi> dcoutts: you should know your data.
06:14:57 <dcoutts> that's not very helpful if you're passing things across module boundaries
06:15:13 <musasabi> which modules need to really understand text?
06:15:22 <dcoutts> to do anything useful with your string I need (str, enc)
06:16:03 <dcoutts> musasabi, so yeah, if you control both ends then you can do more cunning things with the encoding
06:16:26 <dcoutts> but it can't be generally useful as an interchange format if it's so undefined
06:16:40 <dons> kzm, chmod +x tests/logpp
06:16:54 <dons> and edit the Makefile so that GM4 is the 'm4' on your system
06:16:57 <dcoutts> the way everyone uses (abuses) String
06:17:00 * dons couldn't sleep
06:17:16 <musasabi> depends on what one is doing. e.g. with network protocols we generally have just globs of binary data with text in between things.
06:17:32 <musasabi> and somewhere it says how the text is supposed to have been encoded.
06:17:40 <kzm> dons, weren't you going to bed? :-)
06:17:50 <kzm> thanks. Silly me, I should have checked.
06:17:54 <dons> yeah, but I needed to work out how much those w2c's were costing..
06:18:10 <dcoutts> dons, they're not no-ops?
06:18:11 <dons> luckily, they're identical to ussing unsafeCoerce# in the same postion.
06:18:21 <dons> they are no ops
06:18:29 <dcoutts> dons, right, because Word9 is actally 32bit as is Char
06:18:34 <dcoutts> 9/8
06:18:45 <kzm> Cases: 39  Tried: 39  Errors: 0  Failures: 0
06:18:47 <kzm> :-)
06:19:00 <dcoutts> so they have the same representation so ghc can convert them by doing nothing
06:19:36 <dcoutts> dons, in fact unsafeCoerce# is probably worse because it can make ghc more careful with optimisations (or so I am told)
06:19:41 <musasabi> dons: the same with command line arguments, if I am just taking them (on *nix) and opening them as files, I don't need to know about their encoding and not being able to use them even if they are garbage is bad.
06:19:51 <dons> dcoutts: it did. some things slowed down
06:19:57 <musasabi> s/dons/dcouts
06:20:15 <dcoutts> dons, you mean it was slower with unsafeCoerce# ?
06:20:17 <dons> kzm, and it shoudl also run the 100,000 quickchecks, and then the bench marks?
06:20:30 <dons> or do you just type 'make' for that. (not make run)
06:20:49 <dons> dcoutts, yes, some were. none were faster
06:20:52 <musasabi> Encodings are very good and they should be in the library, but at the same time the programmer should make concious choices where to use them and how to handle errors and mismatches.
06:20:58 <dcoutts> dons, that is interesting.
06:21:00 <dons> putting INLINE on everything in *.Char speeds up a few things a bit
06:21:17 <dons> dcoutts, I imagine map w2c will be slower than unsafeCoerce# though.
06:21:20 <dons> I've noticed that before..
06:21:28 <dcoutts> dons, true
06:21:56 <dcoutts> dons, ghc may not be able to eliminate the traversal if the knowledge about the no-op is too low level
06:22:04 <dcoutts> eg if it's at the C-- level say
06:22:05 <dons> yeah.
06:22:19 <dons> kzm, do the QuickChecks get run (in Quick.hs?)
06:22:41 <dons> (well, I know they do, since I run them all the time..)
06:23:51 <dcoutts> musasabi, yeah, it's kind of annoying that much of the time you can get away with not knowing the encoding and just passing bytes about unaltered, and then in some cases it's essential to know the encoding
06:24:05 <kzm> Yep.  Nicely, too.  25000 times.  You must be a patient man.
06:24:21 <dons> ./Qick.hs 100 will run them 10x less often :)
06:24:30 <kzm> And I used make only.
06:24:41 <dons> but I got very cautious when I found a bug only after running with n=1000, not the default 100
06:24:45 <kzm> Funny thing, my test program needs ghc --make to link correctly(?)
06:25:05 <musasabi> dcoutts: but think about e.g. /bin/rm not allowing you to delete a file because the name is not valid in your locale.
06:25:13 <dons> ? -package fps would also do, kzm
06:25:13 <kzm> 'ghc test.hs' fails with link errors, 'ghc --make test.hs' works. 
06:25:16 <dcoutts> musasabi, yeah, that'd be a pita
06:25:30 <kzm> okay. package magic in --make, then?  No matter.
06:25:30 <dcoutts> musasabi, so making any changes of encoding explicit is essential
06:25:38 <musasabi> yes
06:25:43 <dcoutts> musasabi, or indeed you'll end up with that problem
06:26:09 <dcoutts> musasabi, having a portable file interface that works in all those situations is tricky however
06:26:33 <dcoutts> musasabi, since for unix you want bytestrings and for OSX & Win32 you need valid Unicode
06:27:00 <musasabi> But on win32 at least command line arguments are unicode?
06:27:09 <dcoutts> musasabi, true
06:27:18 <musasabi> How about OSX ?
06:27:23 <dcoutts> if you built your app as unicode
06:27:35 <dcoutts> it's still possible to build it as ASCII so it'll work on Win9X
06:27:49 <dcoutts> musasabi, not so sure about OSX
06:29:26 <musasabi> dcoutts: I would argue for "getRawArgs :: IO [ByteString]" and "getLocaleArgs = do as <- getRawArgs; l <- getLocale; mapM (convertThrowErrors l) as"
06:29:32 * alar has just read words "simply-typed lambda calculus"
06:29:50 <alar> is there complicatedly typed lambda calculus?
06:30:01 <dcoutts> alar, yes
06:30:29 <alar> dcoutts: what do they differ in?
06:30:29 <dcoutts> musasabi, and you'd need similar interfaces for all your file ops
06:30:43 <dcoutts> alar, oh I see
06:31:02 <musasabi> openFile :: FilePath f => f -> OpenMode -> IO Handle
06:31:18 <dcoutts> alar, there are many more complex type systems for lamda calculus (and extensions thereof)
06:31:30 <dcoutts> there is not one canonical "complicatedly typed lambda calculus"
06:31:40 <dcoutts> "simply-typed lambda calculus" is indeed very simple
06:31:43 <musasabi> dcoutts: but how would we mark which ByteStrings are inside which encoding?
06:32:06 <dcoutts> alar, eg it guarantees that all functions are terminating (if you omit fix as a constant)
06:32:10 <musasabi> Doing it on typelevel would be nice, but it would need dependent types.
06:32:23 <dcoutts> musasabi, well it can be done dynamically
06:32:44 <alar> dcoutts: so there is "typed lambda calculus" as a computation system and many variations of type systems that are applicablein typed lambda calculus
06:33:12 <dcoutts> alar, there is "simple-typed lambda calculus" and many more complex variations
06:33:18 <alar> dcoutts: how can fix be a constant in typed lambda calculus? What type does it have?
06:33:33 <musasabi> dcoutts: so we would have "data FancyString = FancyString Encoding ByteString ?
06:33:56 <dcoutts> alar, it has a sane type but it is not definable in simply-typed lambda calculus (which is why it needs to be a constant)
06:34:16 <alar> dcoutts: so there is One caconical simply-typed lambda calculus, and all complicated ones are just extensions to it?
06:34:34 <dcoutts> musasabi, that's one possability, but that still won't work for your unix example because we really really don't know the file name encoding
06:34:55 <dcoutts> alar, some are extensions, others change it
06:35:14 <dcoutts> alar, I mean some have the simply-typed system as a subset and others don't
06:35:24 <alar> dcoutts: where can I read about those that change?
06:35:32 <alar> ah, I see
06:35:42 <dcoutts> alar, many many papers over the last 40 years
06:35:59 <dcoutts> alar, or find a overview book
06:36:12 <alar> dcoutts: are all constants in typed lambda calulus necessarily well-typed?
06:36:19 <musasabi> dcoutts: well the program can 1) use whatever user input it has gotten without recoding (works), or 2) use locale and pray.
06:36:37 <dcoutts> alar, they all have a type, they may not be definable within the basic language
06:37:06 <dcoutts> alar, eg any definition of fix within simply-typed lamba calculus would actully be ill-typed
06:37:25 <alar> dcoutts: do you mean "they have valid type, but it is not derivable from basic types"?
06:37:44 <kzm> musasabi, I agree - any character/string handling should be able to pass through the raw bytes untouched.
06:37:49 <dcoutts> musasabi, so long as you don't need to interpret the string you're ok to treat it as a file name
06:38:31 <dcoutts> musasabi, eg in Gtk+ they have two methods to get the file name from a file dialog, one as a byte string and one as a translation into unicode (based on the locale)
06:39:14 <kzm> of course, as readFile takes [Char], it will have to decide how to pass that off as bytes to the system call or c library.
06:39:23 <dcoutts> musasabi, they reccomend that apps remember both so that you can display it to the user in the GUI (which always uses UTF8) and so that you can still save the file again even if the translation into UTF8 was not bijective
06:39:34 <alar> dcoutts: so fix is added to simply-typed lambda calculus just as sqrt(-1) is added to real numbers, right?
06:39:51 <musasabi> yes, that one is also quite necassary since it may not be a bijective transformation.
06:39:58 <dcoutts> musasabi, exactly
06:40:27 <musasabi> kzm: and how would you handle "ISO-2022-JP -> Unicode -> ISO-2022-JP" so that it preserves the bytes?
06:40:38 <dcoutts> musasabi, or indeed it may not be translatable into unicode at all (so it'll end up with lots of replacement chars)
06:42:08 <dcoutts> dons, I wonder if we'll all have to shut up now that SimonM has used the term "bikeshedish" :-)
06:42:58 <dcoutts> musasabi, the problem is that doing these things correctly is difficult and the easy convenient way works 99% of the time so people are loathe to bother
06:43:22 <musasabi> Reading the standards it looks like ISO-8859 != 8 bit subset of unicode.
06:43:39 <dcoutts> musasabi, oh, so we're **** ?
06:43:55 <earthy> musasabi, you're right
06:44:04 <dcoutts> alar, not really
06:44:13 <dons> dcoutts: it's better than Theo de Raadt (OpenBSD) saying 'shutup and hack', I guess.
06:44:25 <dcoutts> dons, hah, yeah :-)
06:44:58 <alar> what's "bikeshedish"?
06:45:09 <dcoutts> alar, see the jargon file
06:45:27 <dcoutts> musasabi, does that mean we can only guarantee translation to Char for <127 ?
06:45:43 <musasabi> dcoutts: Latin1 does not have control characters I think (at least the standards I find omit them)
06:45:49 <vincenz> how hard is it to inverse-wrap code?
06:46:43 <vincenz> for instance if some c-lib requires registration of a callback..
06:46:49 <audreyt> musasabi: where does iso-8859-1  differ from the first 256 chars of unicode?
06:46:58 <dcoutts> musasabi, oh is that all? but the 127-255 do still translate 1-1 ?
06:46:59 <audreyt> musasabi: or do you mean 8859-(!1)?
06:47:15 <musasabi> audreyt: C1 control characters?
06:47:32 <dcoutts> musasabi, do you have a URL for the spec?
06:47:41 <musasabi> audreyt: they are defined in ISO 6429:1992 I think, not Latin1.
06:48:05 <audreyt> uh, ISO-8859 leaves them "undefined"
06:48:07 <musasabi> http://anubis.dkuug.dk/JTC1/SC2/WG3/docs/n411.pdf (for Latin1)
06:48:09 <audreyt> not "defined differently"
06:48:21 <musasabi> yes, which mean that they can have different semantics.
06:48:29 <audreyt> but in practice, they don't
06:48:40 <audreyt> I've yet to see an alternately mapped C1 on latin1
06:49:37 <musasabi> audreyt: some applications have special meanings for them which is pure evil/
06:49:42 <earthy> dcoutts: nope. iso 8859 codepoints 127-255 do not translate into utf8 neatly
06:50:03 <dcoutts> earthy, no, I mean to Unicode code points, not UTF8
06:50:15 <earthy> ah, they do translate to unicode code points
06:50:24 <earthy> for the defined part, that is
06:50:55 <audreyt> (fwiw, perl6 has fixed-size-byte-buffers, extendable-fixed-size-byte-buffers, and unicode-strings, as three fundamental types, each implemented in term on the previous one but exposs only the ADT)
06:51:22 <musasabi> Unicode is basically 0-0x7F = Ascii, 0x80-0x9F C1 control codes, 0xA0-0xFF Latin1, etc 
06:51:29 <audreyt> (and unicode-strings are just fragments of extensible-fixed-size-byte-buffers tagged with encoding)
06:52:58 <dcoutts> so is there any 8-bit encoding which cofers the Unicode code points 0-255 (in the same order)?
06:53:03 <musasabi> audreyt: do you have a nice way of saying "please split this into lines upon CRLF, but don't handle other encoding things yet" in the Perl6 land?
06:53:06 <dcoutts> cofers/covers
06:53:13 <musasabi> dcoutts: I don't think so.
06:53:27 <musasabi> maybe some ECMA one.
06:53:29 <audreyt> musasabi: $string.split(/\n/);
06:53:38 <dcoutts> musasabi, hmm, then we realy can't have .Latin1 as the current implementation
06:54:26 <dcoutts> musasabi, we'd have to go with your suggestsion to be less precise with the encoding and accept that we can't convert to/from Char except for <127
06:54:38 <musasabi> audreyt: so you allow to use character constants even without the full encoding things, very nice :-)
06:55:21 <dcoutts> musasabi, but presumably that's only by treating the string as ASCII
06:55:56 <musasabi> dcoutts: yes, basically that is what I am doing. ASCII + some extensions that I don't touch.
06:55:59 <audreyt> musasabi: sure, as each Str must (conceptually) expose Graphemes and Codepoints interfaces, and also has to be able to convert to bytes given an encoding
06:56:09 <audreyt> musasabi: there's a lot of autoupgrading that goes on underneath
06:56:25 <audreyt> musasabi: but the concept is that "pass-thru" data must never be subjected to autoupgrading
06:56:56 <audreyt> musasabi: and IO handles gives buffers by default, which cannot be promoted to strings without encoding annotations
06:56:57 <musasabi> audreyt: seems like Perl6 is something Haskell should look when thinking about Strings.
06:58:05 <audreyt> actually, I should submit a proposal on the hs' wiki.
06:58:09 * audreyt goes to do that
06:58:43 <musasabi> thanks
06:59:17 <dcoutts> musasabi, according to this http://www.unicode.org/charts/ we do have "Basic Latin" and "Latin-1" which cover code points 0-255
06:59:45 <dcoutts> "Basic Latin" covers 0-127 and "Latin-1" covers 128-255
06:59:49 <musasabi> http://www.unicode.org/charts/PDF/U0080.pdf at least does not claim so.
07:00:23 <dcoutts> that's Latin-1 which one covers 0x80-0xFF
07:00:36 <musasabi> dcoutts: read it.
07:00:46 <dcoutts> http://www.unicode.org/charts/PDF/U0000.pdf covers 0x00-0x7F
07:00:57 <dcoutts> so between the two the cover 0x00-0xFF
07:01:03 <dcoutts> the/they
07:01:06 <musasabi> dcoutts: inside it says that it is "C1 Controls and Latin-1 Supplement"
07:01:21 <dcoutts> is that not ok?
07:01:48 <musasabi> C1 is not a part of Latin1. (at least upon my understanding)
07:02:17 <dcoutts> then what do the Unicode people mean by "Latin-1"
07:02:29 <dcoutts> can't we just point to those docs as the spec?
07:02:44 <musasabi> Latin 1 + ISO 6429:1992 I think
07:03:01 <dcoutts> we can say they are the Unicode subset C0 + C1 (or whatever it's called)
07:03:23 <dcoutts> which those docs then define in terms of existing ISO standards
07:03:37 <musasabi> Things will just work, just the naming part.
07:05:12 <dcoutts> We say it's "Unicode Basic Latin, Latin-1 Supplement and C0 and C1 Controls"
07:05:42 <dcoutts> we can say that in the docs and point to the unicode tables
07:06:12 <dcoutts> musasabi, do you think that'd do (for a suitable definition of Data.PackedString.Latin1)?
07:06:37 <musasabi> dcoutts: I am still averse of the naming, for documentetation it works.
07:06:53 <musasabi> dcoutts: I would like to indicate in the name that it is the raw contents of the buffer.
07:07:09 <musasabi> dcoutts: not e.g. a UTF16 buffer transformed to Latin1
07:07:18 <dcoutts> but you want Char in the interface not Word8
07:07:49 <musasabi> dcoutts: try to write a ASCII based parser with Word8 ;)
07:08:19 <musasabi> dcoutts: I want a thin wrapper to the Word8 functionality that will keep my code readable.
07:08:24 <dcoutts> you want the convenience of the Char interface with the lack of spec that goes with the Word8 interface
07:08:34 <musasabi> yes.
07:08:48 <dcoutts> of course, for ASCII the Latin1 will do
07:09:37 <dcoutts> we only get a problem for Word8 values >127
07:09:38 <musasabi> But I am using UTF8 specifics in the code, thus averse of naming it Latin1.
07:09:52 <musasabi> '\number' works for them.
07:10:00 <dcoutts> Then what we want is a .UTF8 module I think
07:10:08 <musasabi> for most characters however one gets '/' ' ' '\t' and so on.
07:10:13 <dcoutts> it's very common and lots of people will want that too
07:10:28 <musasabi> dcoutts: I have both utf8 and binary blobs in the same stream.
07:10:40 <dcoutts> then you need to be very careful!
07:10:41 <dcoutts> :-)
07:10:59 <musasabi> the .Char works nicely.
07:11:10 <musasabi> or .Char8
07:11:30 <dcoutts> or use Word8 and then extract .Char(8) ones for the substrigns where you know the encoding
07:11:49 <musasabi> which makes pattern matching code ugly.
07:11:53 <dcoutts> you can still split your raw buffer using splitOn(Ord('\n'))
07:12:27 <dcoutts> use pattern gaurds
07:12:39 <dcoutts>  | '\n' <- chr n
07:12:40 <musasabi> fromIntegral makes them kind of long.
07:13:00 <musasabi> does not work because chr wants an Int and it will be Word8
07:13:06 <dcoutts> ah, true
07:13:13 <musasabi> of course one can have a shorter function.
07:13:14 <dcoutts> perhaps chr should be generalised
07:13:40 <vincenz> argh
07:13:51 <vincenz> don't you just hate websites that don't explain their purpose
07:14:00 <vincenz> and you have to click several levels deep to even find the concept of the project
07:14:19 <musasabi> Just a convenience Char layer for those who want that and fancy encodings for those that want that.
07:15:03 <musasabi> dcoutts: I think that the encoding specific modules should have things like character type predicates and such stuff.
07:15:27 <musasabi> dcoutts: which is why I would like to keep it .Char8 not .Latin1
07:16:43 <musasabi> dcoutts: because encodings specify also semantics and e.g. one character may be whitespace in one encoding and not in the other.
07:18:15 <dcoutts> musasabi, right, and for .Latin1 we don't need any predicates because it's a special case where we can re-use the Unicode char predicates
07:18:39 <dcoutts> for the others, yeah, you'd want encoding-specific predicates
07:18:58 <musasabi> dcoutts: actually no.
07:19:07 <musasabi> dcoutts: we want a isValid :: ByteString -> Bool
07:19:14 <musasabi> dcoutts: and there is C1 ;)
07:19:25 <dcoutts> musasabi, what about C1 ?
07:20:19 <musasabi> dcoutts: what semantics should they have there?
07:20:46 <musasabi> The normal ones which are usually used?
07:21:17 <dcoutts> musasabi, dunno about semantics, they are just Unicode code points
07:22:02 <musasabi> then there is the Latin1 combining graphics characters thing.
07:24:04 <vincenz> .th = template haskell?
07:26:13 * SamB wonders if a Z-machine interpreter counts as a non-toy application
07:27:52 <dcoutts> musasabi, yeah, that's a whole other tricky issue
07:28:53 <vincenz> SamB: referring to the Z spec lang?
07:29:05 <SamB> vincenz: no, not that one
07:29:19 <SamB> that one would almost certainly qualify
07:30:00 <SamB> the one that Zork runs on ;-). though not the same version.
07:30:49 <SamB> Well, I mean, I've already got part of an implementation and right now it only supports V5
07:32:07 <SamB> whereas, afaik, zork is only available in V3
07:36:04 <vincenz> is template haskell included defacto with ghc?
07:37:03 <Lokadin> sleeping is such a daunting task
07:37:14 <alar> vincenz: yes
07:37:28 <vincenz> anyone know how to compile a .th file?
07:39:05 <Lokadin> Cale: lol at SoC email link
07:39:32 <vincenz> Lokadin: newsgroup?
07:39:42 <Lokadin> http://www.haskell.org/hawiki/CaleGibbard
07:40:50 <Lokadin> it's a great way of making sure you only get emailed by competent people
07:41:12 <SamB> vincenz: what in the world is a .th file?
07:41:26 <vincenz> SamB: I have no idea
07:41:30 <vincenz> SamB: I think template haskel
07:41:36 <vincenz> don't know how to compile the beast
07:41:48 <SamB> template haskell is usually in .hs files
07:41:52 <SamB> or .lhs
07:42:28 <SamB> vincenz: post it someplace so we can see whats in it ;-)
07:43:41 <vincenz> http://darcs.haskell.org/~lemmih/hode/
07:44:38 <musasabi> dcoutts: seems like some characters are allways invalid under Latin1 if we go by the book :-(
07:44:57 <SamB> hmm, that is TH!
07:45:55 <vincenz> heh
07:46:01 <vincenz> lemmih should really add some README's
07:46:41 <sjanssen_> if it was hard to write, it should be hard to use?
07:46:59 * vincenz just wants to use ODE from haskell
07:47:01 <SamB> sjanssen: hmm?
07:47:02 <vincenz> HODE seems ideal
07:47:17 <SamB> well, I'd guess you could just run GHC on them in order...
07:47:37 <sjanssen_> SamB: just joking about why Lemmih might not have written documentation
07:48:23 <dcoutts> musasabi, which ones? where do you see that?
07:50:24 <musasabi> * 0x80, 0x81, 0x84 and 0x99 are invalid characters.
07:50:33 <musasabi> http://www.ecma-international.org/publications/standards/Ecma-048.htm
07:50:53 <musasabi> (which is the ecma standard corresponding to ISO 6429
07:51:34 <musasabi> dcoutts: then we have to implement also escape sequence processing, and we end up with variable size characters ;)
07:51:39 <dcoutts> http://www.unicode.org/charts/PDF/U0080.pdf just says they are control chars
07:51:48 <musasabi> yes, in C1
07:51:54 <dcoutts> that's ok
07:52:03 <musasabi> and escape sequences?
07:52:26 <dcoutts> I don't know what they are in this context
07:53:16 <musasabi> basically they define a way to say the control codes with 3 byte sequences.
07:53:33 <musasabi> that is if we use the Latin1 meaning of the control codes.
07:53:56 <musasabi> (where latin1 meaning = iso 6429)
07:54:44 <sjanssen_> musasabi: have you looked into ISO-8859-1
07:55:11 <sjanssen_> from Wikipedia: "Escape sequences (from ISO/IEC 6429 or ISO/IEC 2022) are not to be interpreted in documents labeled as ISO-8859-1 encoded."
07:55:12 <musasabi> sjanssen_: yes, the standard says "control characters undefined, but ISO-6429 may be used"
07:55:42 <dcoutts> musasabi, so it's a normalisation from Latin-1 strings to Latin-1 strings
07:56:41 <dcoutts> musasabi, if so then that's not something we should do automatically but if it's useful then perhaps we should provide a function to perform the normalisation
07:56:47 <musasabi> "The coded characters in this set may be used in conjunction with coded control functions selected from ISO/IEC 6429. However, control functions are not used to create composite graphic symbols from two or more graphic characters (see clause 6)."
07:56:59 <dcoutts> I expect there is a huge number of these Unicode algorithms that could be added
07:57:30 <musasabi> dcoutts: but one cannot have both. You cannot use 1) C1 definitions, 2) the ISO-6429 ones.
07:57:50 <musasabi> +both
07:57:51 <dcoutts> musasabi, I don't follow
07:58:13 <musasabi> dcoutts: I don't think the escape sequences are allowed if we use C0+C1.
07:58:27 <dcoutts> musasabi, that's ok with me
07:58:39 <musasabi> dcoutts: but they are allowed and should be interpreted if we use ISO-6429 which should be used with Latin1.
07:58:40 <dcoutts> we just specify it's the subset of Unicode
07:58:40 <SamB> why are you bothering about this stuff?
07:59:12 <dcoutts> musasabi, as I said, I'd define it as the subset of unicode not as ISO-6429
07:59:24 <musasabi> dcoutts: then calling it Latin1 is not good.
07:59:47 <dcoutts> musasabi, Latin1 short for "Unicode Basic Latin, Latin-1 Supplement and C0+C1 Controls"
08:00:09 <musasabi> dcoutts: what should I call the module implementing the Latin1 standard?
08:00:31 <dcoutts> musasabi, dunno, what would you rename the current thing to?
08:01:06 <SamB> does anyone use those things, besides Emacs and terminals?
08:01:07 <musasabi> dcoutts: anything generic. Data.ByteString.{Char8,RawChar,ByteChar,AsciiSuperSet,...}
08:02:00 <dcoutts> musasabi, of course in rality you could use the current impl and just interpret the escape sequences as a simple String -> String transform
08:02:08 <dcoutts> rality/reality
08:02:15 <musasabi> dcoutts: that would lose the indexing.
08:02:25 <dcoutts> true
08:02:38 <dcoutts> you don't get indexing with a variable width encoding
08:02:51 <dcoutts> but you would get indexing on the final normalised version
08:02:52 <musasabi> dcoutts: and having a Latin2 module that is Latin2 and a Latin1 module that is not Latin1 does not make sense.
08:03:20 <dcoutts> musasabi, then take it in as a byte string and interpret the escape sequences and give Latin1
08:03:39 <musasabi> dcoutts: it must be done automatically - otherwise Ord and Eq are wrong.
08:04:00 <dcoutts> no, Ord and Eq are right for Latin1 and you're transforming into that
08:04:05 <__phas> Anyone knows if Cabal parallelize compilation of indipendent modules?
08:04:07 <musasabi> yes.
08:04:12 <dcoutts> or do you want to transform back later?
08:04:17 <dcoutts> and still preserve all indexes?
08:04:17 <musasabi> Now I want a version without the transformations.
08:04:35 <dcoutts> if you want to keep the expanded form the call it something else
08:04:47 <dcoutts> call it Data.ByteString.ISO-FOOBAR
08:04:56 <musasabi> dcoutts: I have been arguing the whole day that it should be called something generic.
08:05:50 <musasabi> All the problems go away if you don't insist on calling it Latin1.
08:05:53 <dcoutts> you've been arguing for a more encoding agnositc interpetation
08:06:22 <dcoutts> where you don't have to care quite so uch what the encoding is but you then also don't get to rely on the encoding anywhere
08:06:26 <musasabi> Yes, I want a version that does not try to do stuff with encodings, just a plain superset of ascii.
08:06:35 <dcoutts> and many of the transforms to/from Char are undefined
08:06:41 <musasabi> yes.
08:07:00 <dcoutts> I think most people want the transform to from Char to be defined
08:07:07 <musasabi> and that is of little consequence if I just split on specific ascii chars, compare bytewise and do IO.
08:08:01 <dcoutts> then use the word8 version or a different wrapper on top
08:08:09 <mauke> @pl \a b -> length b `compare` length a
08:08:26 <dcoutts> musasabi, it's not supposed to cover every possible use, just come common and useful ones
08:08:37 <musasabi> dcoutts: think of parsing a mail message. What module would you use? Headers are not Latin1.
08:08:44 <dcoutts> there is plenty of space in the module heirarchy for others
08:09:55 <dcoutts> musasabi, yeah, I take your point that the current impl doesn't cover that use case very well, add another impl that makes it easy to change/ignore the encoding
08:11:00 <musasabi> so "cp Data/ByteString/Latin1.hs Data/ByteString/Char8.hs" and everyone is happy?
08:11:21 <musasabi> + add real Latin1 things to the Latin1 module.
08:12:01 <dcoutts> the great thing about character set specs is that there are so many to choose from
08:12:20 <eivuokko> heh
08:12:23 <dcoutts> Latin1 seems to reffer to a dozen incompatible specs
08:12:50 <dcoutts> if we want to be pedantic we should reffer to them by ISO/ECMA number
08:13:04 <musasabi> yes + revision ;)
08:13:35 <dcoutts> but there must be some common useful case that covers all the 0-256 codes in a fixed width manner
08:13:38 <audreyt> musasabi: oh, somewhat unrelated, but:
08:13:43 <dcoutts> that is what most people want, most of the time
08:13:46 <dcoutts> (I think)
08:13:47 <audreyt> http://hackage.haskell.org/trac/haskell-prime/wiki/SourceEncodingDetection
08:13:51 <alar> yes
08:13:54 <musasabi> I would like for there to be fancy modules for whatever encodings people want.
08:14:02 <dcoutts> musasabi, that'd be nice
08:14:08 <alar> 8-bit characters are musthave
08:14:17 <musasabi> But I also want a module for the ones who just want the superset of ascii scenario.
08:15:08 <dcoutts> musasabi, which will happen to have the same implementation as the subset of unicode senario (but with fewer guarantees on Char conversions)
08:15:11 <alar> e.g. often one works with latinified program that doesn't know about other charsets but admits 0-255 chars
08:15:42 <musasabi> dcoutts: I don't think subset of unicode should be called Latin1 in this scenario.
08:15:59 <dcoutts> musasabi, ok, convince the others
08:16:15 <dcoutts> it needs some name
08:16:18 <audreyt> musasabi: I wonder if people will be uncomfortable with the compiler rejecting iso8859* programs by default
08:16:23 <audreyt> s/program/source code/
08:16:45 <audreyt> such that an explicit encoding declaration is needed for iso8859* source code
08:17:13 <dcoutts> musasabi, Unicode.8Bit ? Char8 is also ok if it's clear that it's the 8bit subset of Unicode Char
08:17:14 <SamB> I don't think so
08:17:27 <audreyt> this requirement is similar to XML
08:17:39 <SamB> yeah, thats probably fine ;-)
08:18:00 <musasabi> audreyt: it will be a pain, at least here 75% of people still use iso-8859-1
08:18:01 <audreyt> (and the heuristics to implement it, in the URL above, is imported from perl)
08:18:16 <musasabi> audreyt: but that is not a large issue for me.
08:18:28 <audreyt> musasabi: but then, all utf8 text are also valid latin1 text, so I see little alternatives
08:18:31 <audreyt> okay. :)
08:18:39 <musasabi> dcoutts: Char8 is my current favorite.
08:19:04 <mauke> @hoogle Int -> [a] -> [a]
08:19:06 <musasabi> audreyt: most of the time I do code that non-finnish speaking people will read and thus will use ascii.
08:19:10 <audreyt> can we get Char0 and Char7  too?
08:19:10 <dcoutts> musasabi, it's ok with me too so long as we guarantee the ->Char conversions
08:19:21 <audreyt> musasabi: *nod* then it's safe anyway
08:19:51 <lambdabot> Prelude.drop :: Int -> [a] -> [a]
08:19:51 <lambdabot> Prelude.take :: Int -> [a] -> [a]
08:19:51 <lambdabot> Control.Parallel.Strategies.parBuffer :: Int -> Strategy a -> [a] -> [a]
08:20:20 <dcoutts> musasabi, we can say that users can rely on getting unicode chars out (and if you know what you're doing then you can abuse that but you'd better not pass that to code wirtten by anyone else)
08:20:59 <dcoutts> musasabi, the point is that it must be legitimate to get real Chars out of the string
08:21:33 <dcoutts> otherwise it doesn't really deserve to use that type because it's breaking the promise of the Char type
08:24:20 <musasabi> dcoutts: well giving out Word8 char literals would be one solution.
08:24:42 <musasabi> but as long as that is not possible there needs to be some solution.
08:26:36 <dcoutts> musasabi, Data.ByteString.BinaryBlobWithEmbededAsciiSubset ? :-)
08:27:27 <dcoutts> with the only guarantee that ASCII 0-127 appear as those numbers in the byte stream
08:27:30 <musasabi> dcoutts: anything that does not create the illusion that it is in some encoding in which it may not really be.
08:27:53 <dcoutts> musasabi, but you do see that these two things are different
08:28:06 <mauke> how can I simplify combinations (xs : xss) = [ a : b | a <- xs, b <- combinations xss ] ?
08:28:35 <dcoutts> one makes the assumption (and allows clients to rely on the assumption) while the other doesn't make the assumption (and clients must not make any assumption either)
08:29:19 <sjanssen_> mauke: I don't think you're going to get better than that
08:29:27 <dcoutts> one is not not really a subset of the other, neither group would be satisfied by the other type (with is corresponding assumptions)
08:30:08 <dcoutts> musasabi, so I don't really care what they're called either so long as it reflects the asumptions
08:30:15 <dcoutts> it/they
08:30:37 * dcoutts thinks this discussion has gone on quite long enough
08:31:00 <dcoutts> musasabi, do you think we should summarise this for the ml?
08:31:17 <musasabi> dcoutts: yes, I think that would make sense.
08:31:26 <musasabi> Do you want to write or should I?
08:31:33 <dcoutts> musasabi, you can
08:31:48 <dcoutts> or I will if you'd rather not
08:32:25 <mauke> sjanssen_: nevermind, I got it: combinations = foldr (liftM2 (:)) [[]]
08:33:16 <musasabi> I think you can make a less confrontational message, I am not sure I can get people agree.
08:33:16 <sjanssen_> mauke: that might be shorter . . . but I wouldn't call it simpler
08:33:49 <vincenz> > [1..3] >>= join replicate
08:33:50 <dcoutts> musasabi, should I write it then?
08:34:02 <lambdabot> [1,2,2,3,3,3]
08:34:11 <vincenz> wow lambdabot is lagged
08:34:50 <musasabi> That would be nice, but I can help/do it if it is much work.
08:36:12 <vincenz> what's this for?
08:36:54 * vincenz looks at dcoutts and musasabi as they seem to have tuned out everything else
08:37:18 <dcoutts> musasabi, I'll forward it to you before sending
08:38:10 * vincenz  waves a big red sign in front of dcoutts 
08:38:19 <dcoutts> vincenz, ? :-)
08:38:29 <vincenz> 17:35 < vincenz> what's this for?
08:38:39 <sjanssen_> @pl factorial n = length $ sequence_ $ take n $ iterate (():) [()]
08:38:41 <lambdabot> factorial = length . sequence_ . ($ iterate (:) ([] :)) . take
08:38:58 <dcoutts> vincenz, what's what for?
08:39:11 <vincenz> dcoutts: the thing you and musasabi have taken over the channel for to discuss
08:39:42 <dcoutts> vincenz, we're done :-)
08:39:46 <vincenz> right
08:39:47 <vincenz> but what is it
08:39:50 <dcoutts> vincenz, char encodings
08:39:53 <vincenz> oh
08:40:01 <vincenz> so you can anctually print unicode /
08:40:02 <vincenz> ?
08:40:20 <xerox> Gooooooood day.
08:40:33 <dcoutts> vincenz, well so we can process some 8-bit char encodings
08:40:43 <dcoutts> and how finely we specify them
08:41:34 <vincenz> print 'ÃÂ'
08:41:39 <vincenz> > show 'ÃÂ'
08:41:40 <lambdabot>  lexical error
08:42:11 * xerox welcomes the mentor Alberto Ruiz in the group
08:45:02 <musasabi> ok
08:45:55 <vincenz> > show 'ÃÂ'
08:45:58 <vincenz> > show ''
08:45:58 <lambdabot>  lexical error
08:45:59 <lambdabot>  parse error on input `}'
08:46:01 * xerox is filled with food -gurgle-
08:46:04 <vincenz> hmm this is odd
08:48:44 <vincenz> > show 'Ã¢ÂÂ¢'
08:48:45 <lambdabot>  lexical error
08:48:55 * vincenz scratches his head
08:49:01 <vincenz> why is lambdabot having all these issues with unicode
08:49:34 <vincenz> > show 'k'
08:49:37 <lambdabot> "'k'"
08:49:44 <vincenz> and when someone else does it
08:49:45 <vincenz> it works fine
08:49:55 <vincenz> but here it shows the <?> symbol
08:50:07 <__phas> >show '?'
08:50:10 <vincenz> no
08:50:15 <__phas> > show '?'
08:50:17 <vincenz> the unicode-unknown-symbol
08:50:21 <lambdabot> "'?'"
08:50:24 <vincenz> it looks lik a black diamond with a white ?
08:50:26 <__phas> oh
08:50:32 <__phas> i see
08:51:01 <vincenz> I think xerox had done it
08:51:05 <vincenz> the ring operator
08:51:08 <__phas> linux and unicode aren't very friendly
08:51:11 <vincenz> U+2218
08:51:23 <xerox> __phas: lies!
08:51:35 <vincenz> xerox: do a show of the ring operator as char/
08:51:37 <xerox> Gtk is one of the Unicode heavens so far.
08:51:38 <vincenz> I can't input it here
08:51:48 <vincenz> > show '.'
08:51:51 <xerox> This â¢, or this Â·
08:51:53 <lambdabot> "'.'"
08:52:14 <vincenz> right
08:52:15 <vincenz> that second one
08:52:17 <dcoutts> musasabi, sent
08:52:19 <vincenz> it hows up as unicode-unknwon
08:52:25 <vincenz> > show 'Ã¯Â¿Â½
08:52:25 <__phas> > show 'â¢'
08:52:26 <lambdabot>  lexical error
08:52:26 <lambdabot>  lexical error
08:52:27 <vincenz> > show 'Ã¯Â¿Â½'
08:52:37 <lambdabot>  lexical error
08:52:40 <vincenz> gr
08:52:47 <vincenz> I guess it's my client that's not sending unicode correctly
08:52:52 <Igloo> vincenz: You're putting multiple characters inside ''
08:53:01 <xerox> Indeed.
08:53:06 <vincenz> how's that?
08:53:09 <vincenz> that to me showed up as
08:53:13 <vincenz> '   <?>     ' 
08:53:14 <Lokadin> Dell technical support is great
08:53:24 <vincenz> with <?> being the unicode-unknown symbol
08:53:34 <Igloo> You're sending > show 'Ã¯Â¿Â½'
08:53:42 <vincenz> Igloo: yeah
08:53:51 <vincenz> s h o w ' funky '
08:54:02 <Igloo> Which is an accented i, upside down ?, 1/2
08:54:05 <dcoutts> that's three chars
08:54:09 <vincenz> erm
08:54:12 <xerox> vincenz: the `'' quotes delimit a char
08:54:13 <vincenz> here it shows up as one <?>
08:54:17 <vincenz> people
08:54:20 <vincenz> here it shows up as one char
08:54:29 <vincenz> a unicode-question-mark
08:54:40 <Igloo> Sounds like something is broken your end
08:54:44 <vincenz> the black diamond wiht white questionmark
08:54:49 <vincenz> irrsi gnometerm
08:54:57 <vincenz> and screen
08:55:07 <vincenz> and ssh
08:55:11 <musasabi> dcoutts: sending a reply.
08:55:12 <dcoutts> oh, fun, many layers to break :-)
08:55:28 <vincenz> gnome terminal -> ssh -> home -> screen -x
08:55:30 <Igloo> gnometerm is the only one I don't have
08:55:41 <vincenz> gnome terminal -> ssh -> home -> screen -x -> irssi
08:55:51 <Igloo> Unless it's doing an extra encoding/decoding I have no idea what's going on
08:55:52 <xerox> vincenz: it isn't a unicode char
08:55:55 <vincenz> odd
08:55:57 <vincenz> anyways
08:56:00 <xerox> vincenz: it is what it writes if he can't scan it.
08:56:00 <dcoutts> musasabi, ok ta, if you can elucidate your example better than I did, that'd be good, eg the email example
08:56:00 <vincenz> whenever you guys show unicode chars
08:56:02 <vincenz> like the ring dot
08:56:07 <vincenz> I get that funky questionmark
08:56:45 * vincenz does a test
08:57:13 <vincenz> hmm
08:57:14 <vincenz> can't test
08:57:17 <MarcWeber> Doe some glib bindings exist, yet? (in particular g_file_from/to_uri ?
08:57:31 <morans> how is one meant to input unicode into GHC?
08:57:31 <dcoutts> MarcWeber, they're not in our glib bindings
08:57:53 <vincenz> my current locale of gnome terminal is utf-8
08:57:55 <morans> or rather into source files?
08:58:04 <dcoutts> morans, can't yet
08:58:09 <morans> ah, ok.
08:58:10 <dcoutts> MarcWeber, feel free to send us a patch
08:58:16 <morans> i thought someone said it could support it...
08:58:39 <morans> maybe that was just a dream
08:58:45 <dcoutts> morans, GHC can do unicode, just not in string literals in source code
08:58:56 <dcoutts> String really is full 32-bit Unicode
08:59:06 <mauke> this is starting to worry me ...
08:59:11 <mauke> concatMap (map concat) $ ...
08:59:12 <humasect> i think not comments too, no?
08:59:26 <vincenz> dcoutts: not full 32bit
08:59:29 <vincenz> > maxBound :: Char
08:59:30 <MarcWeber> dcoutts: our is related to gtk2hs?
08:59:30 <lambdabot> '\1114111'
08:59:34 <dcoutts> humasect, that's ok I think
08:59:40 <xerox> mauke: (>>=)
08:59:42 <dcoutts> MarcWeber, yes
08:59:51 <dcoutts> vincenz, yeah ok
08:59:58 <vincenz> > log 1114111  / log 2
09:00:13 <vincenz> 20 bit
09:00:17 <vincenz> +-
09:00:23 <dcoutts> yeah, I think it's 21
09:00:35 <vincenz> 17:59 < vincenz> > log 1114111  / log 2
09:00:35 <vincenz> 17:59 < oasisbot> 20.087461546321563
09:00:44 <vincenz> lambdabot seems to be really lagged
09:00:45 <dcoutts> but it's more than 16 and less than 32
09:00:49 <humasect> i am used to comments being "anything" and ignored by the compiler.
09:00:59 <lambdabot> 20.087461546321563
09:01:08 <MarcWeber> dcoutts: I want to try adding poppler support..  would be nice to be able to view pdfs, wouldn't it?
09:01:11 <vincenz> lambdabot: You're SLOW!
09:01:13 <dcoutts> humasect, they are, so if you use utf8 then you can use unicode in comments
09:01:24 <dcoutts> MarcWeber, it certainly would
09:01:47 <humasect> dcoutts, ok sorry, i have some catching up to do with ghc current version.
09:01:51 <humasect> (I would like to haddock my current project in japanese for example)
09:01:59 <dcoutts> MarcWeber, feel free to darcs send us gtk2hs patches
09:02:20 <alar> @vixen you are slow
09:02:21 <lambdabot> have you ever scubadived?
09:02:25 <dcoutts> MarcWeber, have you got the latest gtk2hs darcs version?
09:02:39 <MarcWeber> dcoutts: I've installed the gtk2hs.hide version.
09:02:49 <mauke> xerox: thanks, down to gen (Upto n r) = [0 .. n] >>= map concat . combinations . (`replicate` gen r)
09:03:01 <xerox> mauke: slick!
09:03:14 <dcoutts> MarcWeber, ok, that's a bit of an old snapshot, for patches we'd rather they come from our current repo since then we can apply them trivially
09:03:58 <MarcWeber> The last time I did try I had problems using ghc 6.5. That's why lemmih told me to use this version
09:04:09 <MarcWeber> which did work.. 
09:06:39 <MarcWeber> I'll try it again. (darcs get http:darcs.haskell.org/gtk2hs)
09:06:59 <palomer> hrmph
09:07:03 <dcoutts> MarcWeber, ah, I was just working on the ghc-6.5 thing actually
09:07:32 <palomer> how do I tell ghc "every type which is in instance of class A is automatically an instance of that class B" ?
09:08:51 <alar> palomer instance A x => B x 
09:09:00 <dcoutts> MarcWeber, I'm just testing a patch with ghc-6.4.2, I'll tell you when I push it so you can try it with ghc-6.5, ok?
09:09:21 <dcoutts> MarcWeber, i'm trying to make it support ghc-6.4 and 6.5 at the same time
09:09:23 <palomer> @type 3
09:09:25 <lambdabot> forall t. (Num t) => t
09:09:36 <dcoutts> MarcWeber, with a bit of #ifdef stuff
09:09:36 <alar> where .... methods of B defined through methods of A....
09:09:44 <MarcWeber> ;)
09:10:05 <alar> where on the same line as instance
09:10:15 <palomer> why isn't 3 an Integral?
09:10:26 <mauke> > sqrt 3
09:10:27 <lambdabot> 1.7320508075688772
09:10:35 <palomer> > toInteger 3
09:10:38 <lambdabot> 3
09:10:42 <palomer> @type toInteger
09:10:44 <lambdabot> forall a. (Integral a) => a -> Integer
09:10:55 <palomer> so yeah, why isn't 3 parsed as an integral?
09:11:26 <alar> > toInteger 3.5
09:11:27 <lambdabot> Add a type signature
09:11:48 <alar> > toInteger 3.5::Float
09:11:50 <lambdabot> Couldn't match `Float' against `Integer'
09:12:06 <alar> > toInteger (3.5::Float)
09:12:08 <lambdabot>  add an instance declaration for (Integral Float)
09:12:08 <lambdabot>   In the definition of `ehe': ehe = toInteger (3.5 :: Float)
09:12:08 <lambdabot>   In the definition of `yhjulwwiefzojcbxybbruweejw':
09:12:45 <RyanT5000> is there a name for a function that doesn't recurse  on itself, but in each iteration rebuilds itself (with changes) and then calls that?
09:12:49 <alar> palomer: I guess you see now. UI supposes your 3 maybe floating-point 3 as well as integer
09:13:22 <xerox> RyanT5000: like a tail-call-fix?
09:13:29 <alar> Ryan: self-modifying code?
09:13:32 <palomer> alar: erm, that's not the issue
09:13:46 <RyanT5000> xerox: i don't quite understand that, but yes it is tail-call
09:14:03 <RyanT5000> basically i have a newtype GUI = Message -> IO GUI
09:14:06 <RyanT5000> which is called in a loop
09:14:18 <RyanT5000> each time the new GUI that was returned is called
09:16:13 <palomer> http://www.rafb.net/paste/results/4IbSdg63.html <--anyone have any idea?
09:16:24 * palomer thinks he doesn't understand typeclasses as he should
09:16:33 <xerox> RyanT5000: mfix, maybe.
09:16:48 <RyanT5000> alright, just wondering if there was a name for that :)
09:17:02 <RyanT5000> also i'm not totally sure it's related to the fact that i'm using monads
09:17:04 <RyanT5000> but it might be
09:18:16 <sjanssen_> palomer: when you write the literal "134", you're saying that literal is a number
09:18:41 <sjanssen_> palomer: just add Num c to the constraints like the error message says
09:19:34 <palomer> sjanssen: why am I not saying that the literal is a number AND an integral?
09:19:53 <xerox> If you say it is an Integral, then it is also a Num.
09:19:54 <sjanssen_> palomer: if you want, you can just say Integral c rather than Num
09:20:04 <palomer> (all the type classes which are instantiated by the type of 3       a) => a
09:20:05 <xerox> class (Num a) => Integral a where ...
09:20:27 <sjanssen_> @type 3
09:20:29 <lambdabot> forall t. (Num t) => t
09:20:35 <sjanssen_> @type 3.0
09:20:37 <palomer> how can Integral be made a subclass of Num ?
09:20:37 <lambdabot> forall t. (Fractional t) => t
09:20:47 <sjanssen_> palomer: it already is
09:20:49 <xerox> palomer: Integral *is* a subclass of Num.
09:20:54 <xerox> (I showed you.)
09:21:25 <palomer> oh, I didn't know
09:21:26 <xerox> In the report you can find the graph of the standard classes hierarchy.
09:21:35 * palomer wishes he could ask ghci for this stuff
09:21:43 <xerox> Yes, you can.
09:21:47 <palomer> how?
09:21:48 <xerox> :info Num
09:22:08 <xerox> ....or Integral, or whatever.
09:22:33 <palomer> neither tells me
09:22:58 <palomer> http://www.rafb.net/paste/results/9kgX0L37.html
09:23:15 <xerox> http://www.haskell.org/onlinereport/basic.html
09:23:17 <xerox> 6.3
09:23:44 <alar> hugs does tell
09:23:50 <xerox> class (Real a, Enum a) => Integral a where
09:23:51 * palomer kicks ghci
09:23:55 <xerox> Sure it does!
09:24:16 <xerox> class (Num a, Ord a) => Real a where
09:24:20 <xerox> There you go.
09:24:41 <palomer> ahh, gotcha
09:25:00 <RyanT5000> purely out of curiosity, is there an Imaginary lib for haskell?
09:25:18 <xerox> RyanT5000: I.e. complex numbers?
09:25:21 <RyanT5000> (not to be confused with all the libs i imagine i had, and then am disappointed when i don't)
09:25:22 <RyanT5000> yeah
09:25:26 <xerox> ?docs Data.Complex
09:25:28 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Complex.html
09:25:55 <RyanT5000> haskell really does have a great standard library
09:26:01 <xerox> Yes indeed.
09:26:31 <RyanT5000> i hate STL so much....
09:26:34 <alar> ghc-libs are almost inexhaustible
09:26:40 <RyanT5000> iostream
09:26:42 * RyanT5000 shivers
09:26:55 * palomer imagines a library
09:27:11 <wchogg> Any particular library, or just the platonic ideal of one?
09:27:30 <RyanT5000> what exactly is the platonic ideal of a library anyway?
09:27:50 <RyanT5000> all programs can be expressed with the minimum code necessary to represent their complexity?
09:29:42 <xerox> dwim :: IO a
09:29:42 <shapr> I want a language that doesn't need libraries.
09:30:27 <xerox> dwim :: forall n. ShaprBananas b => b n -- 'b'ananas for all the 'n'eeds
09:31:02 * shapr eats a banana
09:31:22 * xerox can't eat more
09:31:22 <tromp> u want all libraries builtin?
09:31:44 <tromp> then u want..... REBOL :)
09:32:01 <alar> shapr: unlambda?
09:32:13 <xerox> alar: that doesn't *need* libraries.
09:32:37 * xerox wants music
09:32:44 * dcoutts wants tea
09:33:04 * dcoutts has tea!
09:33:06 <dcoutts> joy!
09:33:07 <alar> xerox: language doesn't need libraries if it runs without them. Users want them :)
09:34:30 <palomer> yes! my library works!
09:34:52 <xerox> palomer: what is your library?
09:34:58 <musasabi> dcoutts: sent.
09:35:04 <dcoutts> musasabi, ta
09:35:49 <RyanT5000> gah
09:36:09 <RyanT5000> is there any way to get a stack trace when there's a segfault in FFI-interfaced code?
09:36:12 <RyanT5000> because there really should be
09:36:31 <xerox> dcoutts: did you see Evan's mail? :-D
09:36:41 <dcoutts> xerox, no, only your reply
09:37:03 <xerox> My reply contained all of his mail, hehe.
09:37:52 <palomer> xerox: oh, it's to deal with types and new variables
09:39:59 <musasabi> dcoutts: I tried to add the different semantics the modules should have, the different Ord instances are a pain but at least Data.ByteString.UTF8 is going to need a separate Ord instance, so it doesn't change things that much.
09:40:48 <dcoutts> musasabi, right
09:41:03 <dcoutts> ok I'm forwarding all that to the list...
09:41:53 <dcoutts> hia SyntaxNinja 
09:41:59 <palomer> woooot
09:42:02 * xerox waves to SyntaxNinja 
09:43:47 <SyntaxNinja> y0
09:43:53 <RyanT5000> is there a combinator that takes a pair of functions and turns them into a function of pairs?
09:44:07 <RyanT5000> (a -> b) -> (c -> d) -> (a, c) -> (b, d)
09:44:28 <RyanT5000> (i  hoogled it, but there are a lot of hits and none of them look right)
09:44:31 <dcoutts> @type (\f g (x, y) -> (f x, g y))
09:44:33 <lambdabot> forall a b a1 b1.
09:44:33 <lambdabot>            (a -> a1) -> (b -> b1) -> (a, b) -> (a1, b1)
09:44:41 <xerox> > (uncurry (***)) ((+1),(*2)) (0,10)
09:44:42 <lambdabot> (1,20)
09:44:51 <xerox> Ta-da.
09:45:01 <RyanT5000> :) thanks
09:45:15 <xerox> You're welcome!
09:45:53 <xerox> (Leave the uncurry if you meant "pair" in a less strict sense.)
09:46:05 <xerox> instance Arrow (->) where
09:46:20 <xerox>   (f &&& g) x = (f x,g x)
09:46:29 <xerox>   (f *** g) (x,y) = (f x,g y)
09:46:38 <xerox> first f (x,y) = (f x, y)
09:46:51 <xerox> second is obvious
09:47:00 <xerox>   (>>>) = flip (.)
09:47:13 <xerox> Those are handy at times.
09:48:45 <ratuca> Hello, I'd like to bother you with a small newbie question
09:48:55 <ratuca> How do I convert an Int to IOString for printing?
09:49:02 <humasect> shos
09:49:04 <humasect> show
09:49:11 <RyanT5000> you first conver it to a String with show
09:49:12 <xerox> ratuca: just print it.
09:49:19 <xerox> @type print
09:49:21 <RyanT5000> then you use the print command to turn it into an IO ()
09:49:21 <lambdabot> forall a. (Show a) => a -> IO ()
09:49:33 <ratuca> thank you very much :D
09:49:35 <RyanT5000> or that
09:49:36 <xerox> print = putStrLn . show
09:49:50 <RyanT5000> btw, what's the deal with trying to recreate printf?
09:49:54 <RyanT5000> i mean who really wants that
09:50:01 <RyanT5000> is it purely for multilingual stuff?
09:50:03 <mauke> me!
09:50:24 <mauke> yay, it works
09:50:25 <RyanT5000> i can see the point of format strings when you've got text in multiple languages with fields in it
09:50:28 <mauke> *Main> take 10 $ gen (Branch (Star (Literal "a")) (Star (Literal "b")))
09:50:30 * xerox starts the stunning effect backround music
09:50:30 <mauke> ["","","a","b","aa","bb","aaa","bbb","aaaa","bbbb"]
09:50:56 <RyanT5000> but it seems like there must be a better way
09:50:57 <xerox> > printf "%1.5f" (pi :: Double) :: String
09:50:59 <lambdabot> "3.14159"
09:51:02 * xerox hops
09:51:15 <SamB> printf is more fun than writing out all the ++s and various long-winded calls to non-existant library functions
09:51:16 <RyanT5000> for instance, instead of a format string, some kind of format specifier that's an actual object
09:51:21 * RyanT5000 hates parsing
09:51:29 <xerox> Seen that?
09:51:49 <SamB> RyanT5000: how do you know the format specifier isn't an actual object?
09:52:17 <xerox> Perl6 rules look way cool, but they probably only work the other way around.
09:52:23 <RyanT5000> what i mean by "actual object" is "not a string that needs to be parsed"
09:52:38 <palomer> is there a findAndRemove combinator with type [a] -> ([a],a) or somesuch?
09:52:42 <RyanT5000> so what i'd prefer is something like
09:52:46 <Cale> well, I don't think too many people actually use Text.Printf
09:52:47 <SamB> RyanT5000: well, that would be more long-winded
09:53:11 <Cale> The alternative is just to use various combinations of show and ++
09:53:11 <xerox> palomer: do you want to filter?
09:53:15 <SamB> @index printf
09:53:23 <RyanT5000> printf s = printFormat ((read s) :: Formatter)
09:53:38 <mauke> > printf "%.2s" "ok. NOT."
09:53:38 <RyanT5000> where Formatter is some kind of sensible datastructure
09:53:49 <palomer> xerox: that could work
09:53:53 <eivuokko> In Cabal, is there a convient way, besides using --scratchdir flag or make, to make multiple cabal-files share build directory?  Or can I somehow put many .cabal in one directory?
09:54:11 <lambdabot> Text.Printf
09:54:11 <lambdabot> Add a type signature
09:54:16 <SamB> RyanT5000: you mean it doesn't already do pretty much that?
09:54:21 <SamB> @docs Text.Printf
09:54:23 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Text-Printf.html
09:54:26 <Cale> palomer: are you looking to decompose the list into the first element satisfying a predicate, and the rest of the elements?
09:54:35 <mauke> > printf "%.2s" "ok. NOT." :: String
09:54:37 <lambdabot> "ok. NOT."
09:54:39 <palomer> Cale: yes!
09:54:54 <dcoutts> musasabi, sent to the list, hope it's ok
09:55:21 <SamB> well, it isn't exported anyways...
09:55:23 <Cale> palomer: and when there is no such element?
09:55:37 <palomer> it would be a Maybe
09:56:26 * araujo back from univ
09:56:26 <araujo> Hi!
09:56:26 <RyanT5000> is there any internationalization support in haskell?
09:56:32 <RyanT5000> hi :)
09:56:33 <Cale> I suppose that if you don't care about efficiency too much, you could use find and delete
09:56:42 <SamB> RyanT5000: not too much so far
09:56:51 <SamB> though Unicode is allowed in string objects
09:56:55 <palomer> actually, I know that it's in the list
09:56:56 <SamB> er, values
09:57:28 <RyanT5000> k, although i'm more concerned with the actual changing out of the strings
09:57:51 <RyanT5000> you know, i bet higher-order programming could be really useful for that
09:58:24 <RyanT5000> e.g.: let's say you want to say "You have 5 dollars" in english and some language without plurals (i think there are some)
09:59:16 <RyanT5000> meh, maybe not, i'm not sure
09:59:24 <musasabi> dcoutts: thanks
09:59:28 <RyanT5000> anyway, having format functions rather than format strings might be useful
09:59:36 <RyanT5000> not sure if that's specific to higher-order though
10:00:02 <Cale> > let f p xs = do x <- find p xs; return (x, delete x xs) in f (> 6) [1..10]
10:00:04 <dcoutts> musasabi, np
10:00:04 <lambdabot> Just (7,[1,2,3,4,5,6,8,9,10])
10:00:30 <Cale> > let f p xs = do x <- find p xs; return (x, delete x xs) in f (> 20) [1..10]
10:00:32 <lambdabot> Nothing
10:01:17 <mux> the Maybe monad is so usefulo
10:01:21 <mux> -o
10:01:29 <SamB> @type Text.Printf.printf "Hello, %s" :: String -> String 
10:01:31 <lambdabot> String -> String :: String
10:01:31 <lambdabot>                   -> String
10:01:45 <SamB> @type Text.Printf.printf "Hello, %s"
10:01:47 <lambdabot> forall r. (PrintfType r) => r
10:01:49 <Cale> mux: yeah, List and Maybe are my two favourite monads.
10:01:54 <mux> > let f p xs = find p xs >>= return (x, delete x xs) in f (>  6) [1..10]
10:01:56 <lambdabot>  Not in scope: `x'
10:02:03 <mux> dang
10:02:14 <mux> > let f p xs = find p xs >>= (\x -> return (x, delete x xs)) in f (>  6) [1..10]
10:02:15 <lambdabot> Just (7,[1,2,3,4,5,6,8,9,10])
10:02:55 <mux> Cale: I didn't find much usefulness in the List monad yet, but probably because I have yet to find good examples of when it's useful
10:03:17 <Cale> mux: it's useful when you're doing a backtracking search for solutions to a problem
10:04:47 <Cale> From the computation perspective, it lets you bind nondeterministic results, i.e. "try all of these in turn"
10:04:55 <mux> yeah
10:05:55 <RyanT5000> list comprehensions ftw!
10:06:04 <RyanT5000> they use the list monad
10:09:17 <dcoutts> MarcWeber, I've pushed a patch to fix gtk2hs with ghc-6.5, do you feel like testing it?
10:18:01 <alar> what are "existential datatypes"?
10:23:01 <xerox> alar: do you know the difference between universal and existential qualification?
10:23:55 <alar> xerox: I'm not sure
10:24:30 <xerox> alar: 'forall' vs. 'exist'
10:24:34 <alar> yes
10:24:45 <alar> but how does it rtelate to typesystem?
10:25:53 <xerox> alar: forall a. means that the type will unify for all the possible types a (possibly constrained). exist a. means that the type will unify for all the existent types a.
10:28:06 <alar> xerox: I don't understand how they unfiy for existent types
10:28:16 <alar> what domain are existent types taken from?
10:29:38 <xerox> http://haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#existential-quantification
10:29:51 <alar> thanks
10:31:57 <palomer> I've decided that ST is a bad idea
10:31:59 <palomer> let it be known.
10:32:34 <humasect> i have issues with namespace pollution from record names
10:33:02 <RyanT5000> humasect: more modules?
10:33:27 <RyanT5000> pretend you're writing in java and everything has to go in its own module
10:33:30 <RyanT5000> and import everything qualified
10:35:07 <RyanT5000> is there any reason haskell doesn't have a namespace x { } syntax like C++?
10:35:36 <RyanT5000> basically a submodule in a module
10:35:44 <humasect> now i'm not sure on your previous advice =)
10:36:11 <RyanT5000> lol, well, namespace pollution does seem to be a problem in haskell
10:36:20 <humasect> it is nice to have named tuples, but often accessor names are too convenient, has anyone found a comfortable naming convention for records ?
10:36:59 <humasect> yeah.
10:38:08 <norpan> i more and more tend to make a sub-module for each datatype
10:38:33 <norpan> easier with hierarchical module names nowadays
10:38:39 <humasect> do you end up with many small source files?
10:38:42 <RyanT5000> i was raised on OOP and C++, so i have no problem with having a billion small source files
10:38:54 <norpan> yes, you get a lot of small files, but that's no problem
10:39:02 <norpan> because i use vim + tags
10:39:04 <RyanT5000> my current project in C#, which i am porting to haskell, has, i think, 150 files right now
10:39:19 <humasect> =o
10:39:20 <RyanT5000> and it's like 1/4 done
10:39:36 <RyanT5000> about 80 of those are the classes that describe the game state
10:39:47 <humasect> i'm not sure i've seen haskell-mode with tags support
10:39:47 <RyanT5000> plus interfaces for most of the classes
10:40:20 <humasect> hm, yeah
10:40:24 <norpan> but it would be nice with something like Constructor.field syntax for accessors
10:40:32 <humasect> norpan: including subdirs ?
10:40:50 <norpan> humasect: i have a big tags file
10:40:51 <humasect> hm you may have hit something nice there, that would be logical syntax
10:40:58 <humasect> ok =)
10:41:31 <alar> xerox: I do not understand how do forall and exist differ in that context
10:41:33 <norpan> it collides with Module.identifier syntax though
10:42:04 <RyanT5000> norpan: make it Typename.fieldname
10:42:13 <RyanT5000> then make each type introduce a new module
10:42:19 <RyanT5000> which is implicitly imported into the current module
10:42:24 <alar> by definition of MkFoo it has implicit forall, because it is polymorphic over each applicable a
10:42:37 <alar> ah, but there are no constraint
10:42:55 <norpan> yes, and Typename.Constructor
10:42:56 <MarcWeber> dcoutts: Thx. I'll try.. i had to lay down for some minutes.
10:42:56 <humasect> module syntax should be merged with type syntax ?
10:43:06 <RyanT5000> norpan: yep
10:43:38 <xerox> alar: basically each 'a' could be different for each Foo.
10:44:01 <sjanssen_> does JHC support FFI?
10:44:10 <xerox> JHC!  I didn't contact them, argh.
10:44:29 <norpan> but what would the type name in the submodule be
10:44:37 <norpan> Module.Type.Type?
10:44:39 <RyanT5000> yep
10:44:50 <sjanssen_> xerox: hmm?
10:44:51 <norpan> a bit ugly, but workable
10:44:52 <RyanT5000> it would be exactly as if you had put it in a separate file
10:44:54 <RyanT5000> by definition
10:45:07 <RyanT5000> then you just add some syntax
10:45:22 <RyanT5000> right after deriving() you can say
10:45:26 <RyanT5000> qualified
10:45:29 <RyanT5000> hiding
10:45:31 <shapr> SyntaxNinja: y0 y0!
10:45:39 <RyanT5000> etc.
10:45:46 <sjanssen_> a related question: does YHC support FFI?
10:46:02 <humasect> nice one! hasktags is right there, and speedbar too. thanks norpan
10:46:17 <humasect> +ryan
10:46:18 <norpan> you're welcome
10:46:31 <RyanT5000> welcome :)
10:46:38 <xerox> alar: data Foo a = MkFoo a (a -> Bool) -- would clearly make a [Foo a] of elements of the *same* type.
10:47:12 <MarcWeber> dcoutts: I'll tell you later
10:47:32 <febuiles> Mmm, Ill bother you again if you dont mind, what could be wrong with the following code: http://cpp.enisoc.com/pastebin/6915  (its not c++)
10:47:43 <febuiles> I'm having a hard time with identation
10:47:52 <norpan> RyanT5000: and create a type alias type T = T.T?
10:48:03 <xerox> febuiles: put the if after the = sign.
10:48:17 <RyanT5000> how do you mean norpan?
10:48:29 <xerox> febuiles: also, you need learn some basics, I would suggest YAHT
10:48:37 <febuiles> YAHT?
10:48:42 <febuiles> yet another haskell tutorial
10:48:43 <alar> xerox: Foo in example is not parametric, just Foo, not Foo a
10:48:43 <febuiles> -_-
10:48:45 <norpan> if i declare newtype T = ... qualified then I then need to refer to it by T.T
10:48:56 <febuiles> I will and thx xerox
10:48:59 <RyanT5000> yeah, but that's why you declared it qualified
10:49:07 <xerox> febuiles: yep, it does an exercise pretty much matching your idea.
10:49:20 <RyanT5000> if you were just going to make a type alias you might as well have imported it without qualified
10:49:35 <norpan> but the pollution does not occur with type names
10:49:41 <RyanT5000> true
10:49:43 <norpan> only with accessors and to a lesser degree constructors
10:49:44 <xerox> alar: that's the point, it is not parametric because it hasn't to unify *for*all* the possible 'a'.
10:49:56 <alar> ah
10:50:05 <alar> then Foo a is a "forall"
10:50:13 <alar> Foo is an "exist"
10:50:16 <alar> right?
10:50:17 <RyanT5000> well what if qualified took a list?
10:50:22 <RyanT5000> sort of like hiding
10:50:26 <xerox> alar: sure, I didn't write it explicitly, sorry.  Try writing the definition in a file and ask for :info Foo
10:50:33 <RyanT5000> actually, hiding would have no purpose
10:50:39 <palomer> > 2 + 2
10:50:42 <lambdabot> 4
10:50:44 <norpan> RyanT5000: it's woth thinking about, it would be a conservative extension
10:50:48 <norpan> worth
10:50:50 <RyanT5000> yeah
10:50:58 <RyanT5000> it doesn't sound very hard to implement either
10:51:18 <RyanT5000> it might make finding the package when you import it a bit trickier
10:51:20 <norpan> module chasing
10:51:30 <RyanT5000> yeah
10:51:52 <norpan> if not in file T/T.hs then look in T for type
10:51:53 <pierre-> hello
10:51:59 <RyanT5000> yeah
10:52:10 <xerox> Anybody willing to do an Haskell.org + SoC logo for our trac? (-:
10:52:21 <norpan> also you can't just look at import statements for chasing anymore
10:52:37 <RyanT5000> why not?
10:52:42 <norpan> hmm, yes, why not
10:52:46 <norpan> :)
10:52:56 <RyanT5000> :) you can't have an import in the middle of a type
10:53:21 <norpan> well, i'll see if i can hack it into ghc
10:53:24 <xerox> Well, it depends wether you have a sufficiently cool typesystem :-D
10:53:25 <norpan> have to go now
10:53:28 <RyanT5000> awesome
10:53:30 <norpan> bye
10:53:30 <RyanT5000> nice talking to you
10:55:14 <palomer> @type \x -> do{(a,b) <- get; c <- head b; put (a,c:b)}
10:55:16 <lambdabot>   Occurs check: cannot construct the infinite type: a = m a
10:55:16 <lambdabot>   Expected type: [a]
10:55:18 <palomer> eh?
10:55:34 <xerox> The problem is c <- head b
10:55:43 <palomer> ah,righto
10:55:45 <palomer> being an idiot
10:55:49 * palomer hasn't eaten anything todo
10:55:50 <palomer> today
10:55:57 * xerox is *full*
10:56:01 <palomer> the error is pretty incomprehensible though
10:56:26 <xerox> He espected a list type, for the value b
10:57:01 <Igloo> That's not the full error, which doesn't help
10:57:32 <xerox> Right.
10:58:26 <xerox> But still, it was kinda comprehensible... get and head, State and List Monads.
11:00:13 <RyanT5000> @pl (\a b c -> Graphics.Rendering.OpenGL.vertex $ Graphics.Rendering.OpenGL.Vertex3 a b c)
11:00:14 <lambdabot> (((Graphics . Rendering . OpenGL . vertex . ((Graphics . Rendering . OpenGL) .)) .) .) . Vertex3
11:00:49 <RyanT5000> er
11:00:55 <RyanT5000> i guess pl doesn't actually use the libraries
11:00:57 <eivuokko> It doesn't understand qualiofied names
11:01:08 <RyanT5000> @pl (\a b c -> vertex $ Vertex3 a b c)
11:01:13 <xerox> (vertex .) . Vertex3
11:01:20 <xerox> No, more, whatever
11:01:47 <lambdabot> ((vertex .) .) . Vertex3
11:01:52 <xerox> Yes, more. :-)
11:02:07 <RyanT5000> hm
11:02:40 <RyanT5000> well i can't say i understand that very well
11:02:42 <RyanT5000> oh welll
11:03:15 <xerox> Yup.  ((f .) .) . g  = \x -> (f .) . (g x) = \y -> \x -> f . (g x y) = \z -> \y -> \x -> f (g x y z)
11:03:34 <xerox> (Applying the definition of (.))
11:03:35 <sjanssen_> RyanT5000: pointfree style can get hairy.  I'd suggest staying with the lambda expression you have now
11:03:36 <RyanT5000> right
11:03:37 <araujo> Hi!
11:03:46 <RyanT5000> yeah it just seemed easy
11:03:52 <RyanT5000> because textually the x y z come at the end
11:03:56 <RyanT5000> (er, a b c)
11:03:56 <eivuokko> Hehe
11:04:04 <xerox> It *is* easy (-;
11:04:11 <RyanT5000> true
11:04:31 <RyanT5000> this is my 3rd week with haskell though :P
11:04:35 * xerox waves to DeliQ 
11:04:40 <xerox> RyanT5000: nice!
11:04:44 <RyanT5000> i can deal with a few extra parameters to make it clearer for the time being
11:05:12 <xerox> RyanT5000: they usually write (f . g) x = f (g x), I like to state it as f . g = \x -> f (g x)
11:05:36 <RyanT5000> hm yeah
11:05:49 <RyanT5000> i really like the idea of pointfree
11:06:06 <sjanssen_> it would be nice to have more compose functions somewhere in the libraries
11:06:07 <RyanT5000> but you really have to have a firm understanding of the combinators you're using
11:06:36 <xerox> For example Arrow (->) ones.
11:06:44 <RyanT5000> yeah
11:07:04 <RyanT5000> arrows are cool, but FRP failed to seduce me
11:07:11 <RyanT5000> (for the purposes of writing a GUI)
11:07:33 <RyanT5000> it seemed like wiring would be a pain without a graphical programming interface, and then rewiring at runtime would be really hard
11:07:39 * DeliQ waves back to xerox!
11:07:45 <DeliQ> how are you today xerox ?
11:07:55 <RyanT5000> maybe at some point i'll refactor into a more arrow-based style, but not now
11:08:36 <xerox> DeliQ: quite good!  Went to eat out in some very wonderful place, nicely going.
11:09:10 <DeliQ> aaah, me had a introduction to the databases course
11:09:16 <sjanssen_> @. pl djinn (c -> d) -> (a -> b -> c) -> a -> b -> d
11:09:17 <DeliQ> quite boring :P
11:09:17 <lambdabot> f = (.) . (.)
11:10:20 <xerox> Yes!
11:10:25 <xerox> sjanssen_: there's a pattern!
11:10:57 <xerox> sjanssen_: the number of (.) composed is the number of the parameters of the function you're composing to the unary one.
11:11:15 <sjanssen_> @. pl djinn (d -> e) -> (a -> b -> c -> d) -> a -> b -> c -> e
11:11:17 <lambdabot> f = (.) . (.) . (.)
11:11:28 <sjanssen_> yep
11:11:50 <xerox> ^___^
11:11:54 <sjanssen_> I suppose if you knew that rule offhand, such code would be readable
11:12:05 * xerox grins
11:12:11 <sjanssen_> also, lambdabot rocks my world
11:12:21 <DeliQ> evil grin :P
11:12:25 <xerox> Yep, I want some student to build the hs-plugins application server.
11:12:35 <xerox> It could run our lives.
11:14:11 <xerox> DeliQ: how's it going with your SoC project?  Did you see the list growth?
11:14:43 <musasabi> xerox: any real reason that you want to use hs-plugins for such purpose?
11:15:01 <musasabi> other than that it is cool.
11:15:03 <xerox> musasabi: no *real* reason, it sounded cool the last time we talked about it.
11:15:07 <xerox> Right :-D
11:15:14 <DeliQ> xerox: yup, i'm reading all the replies and stuff
11:15:22 <xerox> musasabi: what do you think could serve the purpose too?
11:15:26 <musasabi> xerox: concurrency makes it quite painful.
11:16:27 * palomer goes back to using ST
11:16:31 <musasabi> xerox: typically I end up with ~30 threads so you need a way to make them all agree to quitting, serialize the data etc
11:16:39 <palomer> ST is like the girl who you always leave and always come back to
11:16:56 <xerox> musasabi: understandable.
11:17:59 <xerox> musasabi: STM?
11:18:12 <musasabi> xerox: in parts of the system, other parts are non-stm
11:18:31 <DeliQ> xerox: are you a teacher ?
11:18:34 <xerox> I see, I wonder the design.
11:18:48 <xerox> DeliQ: it depends on what you mean by teacher.  I like to teach and be taught.
11:19:01 <sjanssen_> is it really necessary to make all the threads quit?  I'm guessing the server has some sort of dispatch table, right?  can't you just change the dispatch table so new clients get the new functionality and current ones finish?
11:19:17 <sjanssen_> by new clients I mean new requests
11:19:20 <musasabi> xerox: also a full restart after a fresh checkpoint should be about 2 seconds and one can have a failover proxy to take pending requests and forward them to the app when it has been restarted.
11:19:21 <xerox> sjanssen_: i.e. recreate Em(ess)acs ?
11:19:41 <xerox> musasabi: that sounds like a good plan.
11:19:47 <DeliQ> xerox: because you were talking about, you want some student ....
11:19:47 <xerox> I wonder the design, again :-)
11:19:56 <DeliQ> xerox: i presumed you were a teacher
11:20:34 <xerox> DeliQ: sure I want students!  I want them to apply for SoC for Haskell.org.  I want to share the great experience I had last year, and I don't want to make people lose opportunities.
11:20:36 <musasabi> sjanssen_: it is necessary because data structures may have different implementations and one needs to serialize all state.
11:20:51 <xerox> DeliQ: I'm not a teacher in the schoolsystem sense.
11:20:52 <DeliQ> aah, i get it ;)
11:20:56 <musasabi> xerox: and one still needs the fast restart for the cases where GHC version has changed.
11:22:48 <xerox> musasabi: makes sense.  hs-plugins doesn't take any part in this design, right?
11:24:15 <DeliQ> xerox: are you mentoring the hs-plugins project ?
11:24:31 <xerox> That is, how does it handle dynamic loading, do we have other libraries-ideas?
11:24:35 <xerox> DeliQ: nope
11:24:53 <DeliQ> what kind of project is it ?
11:24:59 <musasabi> xerox: no, I don't think it is very good for an enterprise solution.
11:25:10 <musasabi> xerox: but it is quite cool.
11:25:33 <musasabi> For other things like Yi and lambdabot it is more suitable.
11:25:45 <xerox> DeliQ: err, which one?
11:26:05 <DeliQ> hs-plugins
11:28:06 <palomer> someone remind me the darcs command to unapply the last patch
11:28:22 <xerox> Man I had the page in cache!  I see more projects!!
11:29:13 <xerox> The Haskell Refactorer sounds very cool.
11:29:30 <xerox> Simon Thompson volunteered :-D
11:29:47 <wchogg> xerox:  Refactoring non-monadic code into monadic code sounds badass, but difficult.
11:30:21 <xerox> wchogg: doing global program transformations on code isn't a simple task, right, I think you can call it "programming" in a certain sense (-;
11:31:06 <xerox> They love to do it in lisp, tho.  Many (every?) Scheme compiler does CPS transformation on code to compile, in order to optimize it afterwards, IIRC.
11:32:10 <musasabi> Writing a library layer for easy TH deriving of classes could be one project also it probably needs something extra.
11:32:55 <xerox> "Refactoring to Classes" seem something very practical.
11:33:03 <vincenz> xerox: donde?
11:33:05 <wchogg> xerox:  Yeah, but it's easy in lisp because you don't write the code *is* the ast.  Well, I should say *easier*.  It's not trivial.
11:33:09 <xerox> musasabi: yes, write *documentation* !
11:33:20 <wchogg> *erase the don't
11:33:22 <vincenz> xerox: where is that "Refactoring ot Classes?"
11:33:36 <wchogg> vincenz:  It's down at the bottom of the SoC projects proposal.
11:33:40 <vincenz> wchogg: link/
11:33:41 <xerox> vincenz: I was having a cached page too!  Here: http://haskell.org/haskellwiki/Summer_of_Code/Project_suggestions
11:33:48 <vincenz> \o/
11:33:58 <xerox> He also moved the page and put the redirects.
11:34:42 <xerox> musasabi: willing to add it?  I think you can come up with a nice description.
11:34:42 * vincenz would love to do the game
11:34:45 <vincenz> but I ain't a student :(
11:35:03 <xerox> (You don't have to sign the proposal if you aren't willing to mentor it.)
11:35:20 <shapr> hsSDL would be cool.
11:35:30 <shapr> I want to steal pygame.
11:35:35 <xerox> shapr: Lemmih proposal?
11:35:39 <shapr> yeah
11:35:47 <xerox> Yes, very nice one.
11:35:56 <wchogg> shapr:  I wonder how many people would do work on Haskell && Windows so that they could work on those bindings.
11:35:59 <DeliQ> say, you have a data type Expr that models an expression with constructors for the well known binary operators :+:, :-: etc.. Could you make a class Foldable, and make Expr an instance of it ?
11:36:06 <vincenz> shapr: where do you see that?
11:36:07 <shapr> wchogg: Several
11:36:13 <shapr> vincenz: On the SoC page
11:36:16 <xerox> DeliQ: there *is* such a class!
11:36:21 <xerox> DeliQ: on current GHC, tho.
11:36:23 <DeliQ> oeh, tell me...
11:36:27 <vincenz> shapr: yeah wher
11:36:31 <wchogg> shapr:Oh?  Cool.  I'm surprised actually.
11:36:43 <vincenz> dcoutss is listed under sdl, not lemih
11:36:53 <xerox> ndm works on YHC right?
11:37:00 <shapr> yup
11:37:03 <shapr> and WinHugs
11:37:09 <xerox> No answers from YHC ml, sigh.
11:37:15 <DeliQ> @doc Foldable
11:37:16 <lambdabot> Foldable not available
11:37:20 <shapr> @seen ndm
11:37:21 <lambdabot> I saw ndm leaving #haskell-overflow, #haskell-blah and #haskell 13 days, 22 hours, 42 minutes and 23 seconds ago, and .
11:37:22 <musasabi> xerox: I can do it later..
11:37:27 <DeliQ> @hoogle Foldable
11:37:28 <lambdabot> No matches found
11:37:31 * xerox high-fives musasabi 
11:37:35 <shapr> Is York on holiday?
11:37:50 <xerox> DeliQ: you do have to search on the current doc: http://www.haskell.org/ghc/dist/current/docs/libraries/base/Data-Foldable.html
11:37:51 <vincenz> yeah
11:37:55 <vincenz> it went to New York
11:38:01 <DeliQ> ow, i'm sorry, ty!
11:38:03 <xerox> Ah-ha.
11:38:04 <wchogg> ...wow, I just realized that there's now a mentor for doing GSL bindings.  Awesome**5
11:38:11 * shapr throws rotten fruit at vincenz 
11:38:17 <xerox> wchogg: yeah, he volunteered today, IIRC.
11:38:23 <vincenz> shapr: I know I know
11:38:26 <vincenz> shapr: it was bad
11:38:56 <wchogg> xerox:  I'm starting to be glad that you can make multiple applications.  I think there's five or six I'll apply for.
11:39:07 * vincenz wishes he were a student
11:39:13 <xerox> wchogg: yes you can, but only one will be eventually accepted
11:39:40 <wchogg> xerox:  Oh yeah!  I didn't think it was possible to get paid three times. ;)
11:39:53 <xerox> wchogg: and you thought right.
11:40:19 <palomer> I have a type here that takes half my screen!
11:40:29 <wchogg> xerox:  I'm just glad there's so many ones that look fun.  Getting any of them would be fantastic.
11:40:38 <xerox> palomer: either you have a very small screen... or you're in danger!
11:40:58 <xerox> wchogg: ah, *spread*the*word*  I always fear I didn't contact all the possible ones!
11:41:05 <vincenz> wait a second
11:41:08 <vincenz> if you can apply to multiple
11:41:14 <vincenz> is there intraproject discussion?
11:41:23 <vincenz> cause what if A, B, C apply to X, Y, Z
11:41:30 <vincenz> and a is somewhat beetter than B and C
11:41:33 <vincenz> then X,Y,Z pick A
11:41:36 <vincenz> A picks X
11:41:44 <vincenz> and B and C, X and Y are left with nothing
11:41:46 <wchogg> xerox:  Well I think you did a nice job on pushing on everyone.  The number of projects has increased 10 fold since *sunday*.
11:42:06 <vincenz> a-C = students, X-Y=projects
11:42:23 <xerox> wchogg: yes but it's all up to the student from May 1 !!
11:42:56 <vincenz> xerox: ?
11:42:57 <wchogg> xerox:  Unfortunately I don't know anyone I can encourage to apply...
11:43:20 <xerox> wchogg: don't fear competition :-D  <grin>
11:43:43 * xerox is at his sixth tea cup
11:43:51 <wchogg> What kindof tea?
11:44:02 <xerox> Green tea of course!
11:44:16 <vincenz> xerox: so what happens if multiple projects accept one person.... thereby invalidating other candidacies for those projets
11:44:35 <xerox> vincenz: they can't.
11:44:47 <vincenz> xerox: well how does it work
11:45:38 <vincenz> xerox: see assume A and B applied to project X and A also applied to project Y
11:45:44 <xerox> vincenz: student apply through Google application web page, the request are relayed to the competent organizations, and discussed.  The mentors then have time to ask more informations to the applicants, if they need to do so, and then they're matched with students.
11:45:54 <vincenz> xerox: yeah ok
11:46:01 <vincenz> xerox: but let's say project A says "I like the student" and B too
11:46:13 <vincenz> xerox: the student then gets to choose I would think?
11:46:46 <vincenz> which means that during the timeframe that that student choose,s other candidacies to those two projects get less priority... 
11:47:20 <xerox> vincenz: we've smart people here :-)
11:47:33 <vincenz> xerox: no seriously
11:47:47 <vincenz> xerox: either there is a complete arbitration on the project side
11:47:56 <vincenz> with full multiplex communication betwene projects
11:47:58 <vincenz> or something goes awry
11:48:41 <xerox> vincenz: it partly depends on the projects proposals of the stuydent itself.  But the mentor have time to request informations, and they only have limited requirements, so they probably can work out and choose fairly
11:49:10 <xerox> We are setting up some means to keep everyone sensible up to date.
11:49:18 <vincenz> ok
11:49:26 <vincenz> cause it can lead to student deadlocks
11:49:31 <xerox> (I'm reading up in this very moment.  Tickets, RSS, email notifications, etc.)
11:50:25 * SamB thinks there should be a fromIntegral/a->a rule
11:50:30 <vincenz> shapr: ?
11:50:32 <wchogg> xerox:  Do you know how soon we'll find out how many projects haskell.org can host?
11:50:34 <vincenz> SamB: ?
11:50:44 <cinema> xerox, what do you think of a binding to LLVM (for a new back-end code generator) as a project for SoC
11:50:46 <vincenz> > fromIntegral $ fromIntegral 2 :: Int
11:50:50 <lambdabot> 2
11:51:00 <wchogg> cinema:  LLVM?
11:51:29 <cinema> wchogg, Low-Level Virtual Machine (os something like that)
11:51:30 <SamB> just so that you wouldn't get those messages about two rules matching the same case so often...
11:51:55 <cinema> http://llvm.org/
11:51:55 <SamB> it would go something like
11:52:15 <SamB> "fromIntegral/a->a" fromIntegral = id
11:52:26 <vincenz> SamB: I don't get it
11:52:42 <vincenz> SamB: fromIntegral can do a->a
11:52:49 <SamB> Rules.findBest: rule overlap (Rule 1 wins)
11:52:52 <SamB> ...
11:52:59 <SamB>     Rule 1: "fromIntegral/a->CInt" __forall {@ a{tv a5sI} :: *
11:53:07 <SamB> ...
11:53:10 <SamB>     Rule 2: "fromIntegral/Int32->a" __forall {@ b{tv a5t4} :: *
11:53:11 <SamB> ...
11:53:14 <xerox> cinema: bindings are always welcome I think
11:53:36 <xerox> cinema: could you come up with a short description of why it's cool?
11:53:45 <cinema> xerox, this one could be used by several haskell compilers
11:53:55 <cinema> it's a very active project
11:54:14 <SamB> what do we want a VM for?
11:54:18 <cinema> & supports tail call optimizations
11:54:26 <SamB> we have real machines!
11:54:28 <xerox> What sense does it make to put the RTS onto the VM?
11:54:32 <cinema> SamB, C-- is not very active
11:54:37 <xerox> (I'm not implying it doesn't)
11:54:42 <SamB> or is it not really a VM?
11:54:47 <cinema> LLVM can generate executable code
11:54:54 <SamB> ah
11:55:04 <eivuokko> SamB, yeah, it can be used as backend to generate native code
11:55:19 <SamB> so it is a virtual virtual machine?
11:55:23 <cinema> It is the most active project in this area
11:55:26 <xerox> C frontend...
11:55:42 <xerox> It includes front-ends for C, C++, and Stacker (a forth-like language). Front-ends for Java, Scheme, and other languages are in development.
11:56:05 <cinema> PyPy is using it as one of its backend
11:56:34 <xerox> Heh, PyPy, they use HM-in-reverse too.
11:56:49 <SamB> HM-in-reverse?
11:56:50 <xerox> (In order to do some kind of "static" checking.)
11:57:24 <palomer> is there a monadic equvialent to fmap with type (a -> m b) -> f a -> m (f b) ?
11:57:24 <xerox> Don't ask me to find the paper now...
11:58:39 <Cale> palomer: impossible -- that assumes that the functor f commutes with the monad m
11:58:53 <Cale> which in general isn't going to happen
11:59:03 * xerox waves to Cale
11:59:09 <wchogg> Yeah, what you're asking for is fmap twice but switching the order of the monads at the end, right?
11:59:21 <palomer> fmap twice?
11:59:26 <Cale> fmap once
11:59:41 <Cale> followed by swapping the monad and functor
11:59:42 <wchogg> Oh, sorry, misread the signature.
11:59:49 <Cale> you can do it with f = []
11:59:56 <Cale> @type sequence
11:59:58 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
12:00:13 <xerox> cinema: add it on the list of project with no mentor, maybe someone will pick it up!
12:00:14 <Cale> @type \f -> sequence . fmap f
12:00:17 <lambdabot> forall (m :: * -> *) a a1.
12:00:17 <lambdabot>          (Monad m) =>
12:00:17 <lambdabot>          (a1 -> m a) -> [a1] -> m [a]
12:00:34 <cinema> xerox, Ok I'll do it
12:01:10 <Cale> So you're basically assuming a sequence-like operation, which is more than you can guarantee from a general functor
12:01:21 <palomer> is takeWhile the same as filter?
12:01:31 <Cale> not quite
12:01:33 <davidhouse> no.
12:01:48 <Cale> It takes elements from the start of a list while the predicate holds
12:01:52 <davidhouse> takeWhile will start at the front a list, and stop once it finds anything where the predicate is false
12:02:02 <Cale> > takeWhile (<5) [1,2,3,6,2,3]
12:02:08 <wchogg> Cale:  So what are the extra assumptions needed to ensure that?
12:02:08 <lambdabot> [1,2,3]
12:02:15 <Cale> > filter (<5) [1,2,3,6,2,3]
12:02:17 <lambdabot> [1,2,3,2,3]
12:03:00 <palomer> ditto for dropWhile?
12:03:06 <Cale> wchogg: the existence of a natural transformation f m -> m f
12:03:15 <vincenz> Cale: transexuals?
12:03:20 <palomer> > dropWhile (<5) [1,3,8,9,1,2,8]
12:03:23 <lambdabot> [8,9,1,2,8]
12:03:45 <davidhouse> wchogg: what are you discussing?
12:03:53 <vincenz> Cale: Check out applicative
12:03:57 <palomer> is there a dual to filter?
12:04:10 <Cale> That is, a polymorphic function  f (m a) -> m (f a)
12:04:17 <wchogg> Cale:  Ah.  I thought perhaps there was something else like "if they're both monads that..."
12:04:26 <davidhouse> palomer: just not the predicate
12:04:31 <xerox> palomer: what do you mean?
12:04:56 <palomer> dual f x = x \\ (filter f x)
12:05:19 <Cale> wchogg: well, it would also be enough to have a map f a -> [a]
12:05:23 <xerox> palomer: (:) ?
12:05:24 <Cale> er, hmm
12:05:25 <Cale> no
12:05:27 <vincenz> Cale: applicative and traversable do just that
12:05:30 <Cale> not quite
12:05:37 <vincenz> Cale: f (m a) -> m (f a)
12:05:46 <davidhouse> palomer, \p xs -> filter (not . p) xs
12:05:54 <palomer> davidhouse: hah, good point
12:05:57 <Cale> vincenz: yeah, there are some classes which people tend to define for this
12:05:59 <davidhouse> @pl \p -> filter (not . p)
12:06:00 <lambdabot> filter . (not .)
12:06:06 <xerox> ^_^
12:07:06 <Cale> vincenz: I've also seen somewhat less general cases defined where you're swapping two monads.
12:07:16 <vincenz> Cale: oh
12:07:17 <vincenz> ?
12:07:30 <Cale> I'll see if I can find the paper
12:08:15 <vincenz> Cale: http://www.cs.nott.ac.uk/~ctm/IdiomLite.pdf
12:08:25 <palomer> is there a function a -> b -> m a -> m b
12:08:32 <Cale> yeah, I think I've read that one
12:08:49 <Cale> but it's not the one I'm thinking of
12:09:01 <xerox> palomer: liftM
12:09:19 <xerox> @type Control.Monad.liftM2
12:09:21 <lambdabot> forall r (m :: * -> *) a2 a1.
12:09:21 <lambdabot>         (Monad m) =>
12:09:21 <lambdabot>         (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
12:09:26 <xerox> Hmmm.
12:09:36 <palomer> @type Control.Monad.liftM
12:09:40 <lambdabot> forall r (m :: * -> *) a1.
12:09:40 <lambdabot>         (Monad m) =>
12:09:40 <lambdabot>         (a1 -> r) -> m a1 -> m r
12:09:50 <Cale> http://www.cse.ogi.edu/~mpj/pubs/RR-1004.pdf
12:09:57 <xerox> Yes that.
12:10:01 <wchogg> Now, is there any real difference between fmap and liftM except that liftM has the restriction that it must be a monad?
12:10:10 <palomer> what about a function a -> m b -> m a -> m b ?
12:10:13 <davidhouse> palomer: you can hoogle for it :)
12:10:18 <davidhouse> wchogg: nope :)
12:10:23 <palomer> davidhouse: I did
12:10:25 <davidhouse> fmap is more general, as you pointed out
12:10:30 <palomer> @hoogle a -> b -> m a -> m b
12:10:39 <davidhouse> i think you mean
12:10:43 <lambdabot> No matches, try a more general search
12:10:47 <davidhouse> @hoogle (a -> b) -> m a -> m 
12:10:50 <lambdabot> Control.Monad.Writer.listens :: MonadWriter w m => (w -> b) -> m a -> m (a, b)
12:10:50 <lambdabot> Prelude.(.) :: (b -> c) -> (a -> b) -> a -> c
12:10:50 <lambdabot> Control.Parallel.Strategies.(-|) :: (a -> b) -> Strategy b -> (b -> c) -> a -> c
12:10:51 <Cale> wchogg: no difference -- if the instance of Functor agrees with the instance of Monad, then they're the same
12:11:05 <palomer> oh, righto
12:11:06 <davidhouse> > Just 4 `fmap` (+2)
12:11:08 <lambdabot> Couldn't match `Maybe a' against `t -> t1'
12:11:09 <xerox> palomer: \action -> (>>= action) :: Monad m => (a -> m b) -> m a -> m b
12:11:21 <davidhouse> > (+2) `fmap` Just 4
12:11:23 <lambdabot> Just 6
12:11:24 <xerox> I.e. ((>>=) .)
12:11:43 <davidhouse> > (+2) `liftM` Just 4
12:11:45 <lambdabot> Just 6
12:11:46 <palomer> @type ((>=) .)
12:11:49 <lambdabot> forall b a. (Ord b) => (a -> b) -> a -> b -> Bool
12:11:57 <xerox> hehehe.
12:11:57 <Cale> @type join . liftM
12:12:02 <davidhouse> @type ((>>=) .)
12:12:07 <lambdabot>   Occurs check: cannot construct the infinite type: m = (->) (m a1)
12:12:07 <lambdabot>   Expected type: (a1 -> r) -> m a1 -> m a1 -> a
12:12:07 <lambdabot> forall (m :: * -> *) a b a1.
12:12:07 <lambdabot>      (Monad m) =>
12:12:07 <lambdabot>      (a1 -> m a) -> a1 -> (a -> m b) -> m b
12:12:08 <xerox> Control.Monad.blargh Cale :-\
12:12:12 <Cale> @type \f -> join . liftM f
12:12:14 <lambdabot> forall a (m :: * -> *) a1.
12:12:14 <lambdabot>         (Monad m) =>
12:12:14 <lambdabot>         (a1 -> m a) -> m a1 -> m a
12:12:14 <xerox> Err, no more?
12:12:26 * xerox mumbles.
12:13:03 <Cale> @type \f -> join . fmap f
12:13:06 <lambdabot> forall a (f :: * -> *) a1.
12:13:06 <lambdabot>         (Monad f, Functor f) =>
12:13:06 <lambdabot>         (a1 -> f a) -> f a1 -> f a
12:13:47 <davidhouse> what does join do?
12:13:50 <davidhouse> @type join
12:13:53 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
12:13:55 <xerox> join :: m (m a) -> m a
12:14:06 <Cale> It's part of the usual definition of a monad :)
12:14:11 <xerox> Cale: are you using some precise instance there?
12:14:24 <Cale> hm?
12:14:30 <Cale> nope
12:14:34 <davidhouse> Cale, it is? but it's not part of instance decls for Monad, right?
12:14:45 <xerox> davidhouse: Haskell doesn't require that because:
12:14:48 <Cale> davidhouse: right, that's a design flaw, imo
12:14:49 <xerox> @pl (>>= id)
12:14:50 <lambdabot> join
12:14:56 <davidhouse> yes, that's what i thought.
12:15:04 <vincenz> xerox: join rocks
12:15:18 <xerox> Yup it does, but as now I grok it only for particular cases.
12:15:21 <Cale> fmap, join, and return are the usual basis for a monad
12:15:28 <eivuokko> Is it possible (either already working, or technically possible) to use Djinn to generate funcs from template haskell?
12:15:42 <Cale> (the one normally used by algebraic topologists and category theorists)
12:15:55 <Cale> but return and >>= will do nicely as well
12:16:23 <Cale> eivuokko: Should be
12:16:38 <eivuokko> Cool.  I have to try that, then.
12:16:46 <palomer> @type  \f -> fmap $ join . liftM f 
12:16:53 <lambdabot> forall (f :: * -> *)
12:16:53 <lambdabot>              a
12:16:53 <lambdabot>              (m :: * -> *)
12:16:53 <lambdabot>              a1.
12:16:53 <lambdabot>            (Functor f, Monad m) =>
12:16:53 <lambdabot>            (a1 -> m a) -> f (m a1) -> f (m a)
12:16:59 <Cale> eivuokko: might require rewriting parts of Djinn to emit TH datastructures rather than strings
12:17:01 <palomer> that's the closest I can get to what I want
12:17:26 <eivuokko> Cale, Doesn't sound particulary hard.  But I dunno TH.
12:17:38 <SamB> Cale: or writing a parser that returns TH
12:18:06 <SamB> maybe using ParsecT (which still needs to be done)
12:18:20 * SamB wonders if ParsecT would be a good SoC project
12:19:39 <xerox> SamB: I think it would be!
12:19:41 * xerox <- dinner
12:19:49 <SamB> cool
12:19:54 <Cale> SamB: Maybe, it might be on the easy side, depending on who takes it.
12:19:58 <SamB> might be!
12:20:15 <SamB> but then I still can't for the life of me figure out what would be the best way to go about it in the first place
12:20:49 <Cale> I'd have to look at the Parsec source code. Surely a parsing monad transformer isn't so hard to do.
12:21:15 <Cale> (but Parsec specifically might be awkward to translate, depending on how it's written)
12:21:35 <davidhouse> what's the type signiture for Parsec?
12:22:08 <Cale> Parsec is a library
12:22:13 <sieni> do {xerox <- dinner; eatStrLn xerox}
12:22:25 <davidhouse> sorry, i meant CharParser. it's basically a state monad, right?
12:22:35 <SamB> would you replace the regular old parser type with the T version, would you make a typeclass and slow things down badly for the old version, would you make ParsecT completely seperate and incompatible with the old version...
12:22:41 <davidhouse> newtype GenParser tok st a
12:22:41 <davidhouse>   = Parser (State tok st
12:22:41 <davidhouse>             -> Text.ParserCombinators.Parsec.Prim.Consumed
12:22:41 <davidhouse>                    (Text.ParserCombinators.Parsec.Prim.Reply tok st a))
12:22:46 <davidhouse> ghci :i tells all.
12:22:59 <Cale> A parser for things is a function from strings to lists of pairs of strings and things.
12:23:07 * xerox runs off from the dinner a sec
12:23:13 <xerox> Maybe add it to the Language.* project?
12:23:14 <Cale> but it might not use that definition directly :)
12:23:29 <davidhouse> Cale, haskell Ã  la Dr. Seuss! i remember that.
12:23:36 <SamB> is that Parsec though?
12:23:47 <SamB> that sounds like Read
12:23:57 <xerox> SamB: ask shapr
12:24:09 <SamB> @google A parser for things is a function from strings to lists of pairs of strings and things.
12:24:12 <lambdabot> http://docs.python.org/tut/node5.html
12:24:13 <Cale> SamB: seems not, as that GenParser definition looks quite different
12:24:21 <SamB> @google "A parser for things is a function from strings to lists of pairs of strings and things".
12:24:24 <lambdabot> http://tunes.org/~nef/logs/haskell/05.12.11
12:24:44 <davidhouse> @google dr seuss site:haskell.org
12:24:46 <lambdabot> http://www.haskell.org/haskellwiki/Humor
12:25:40 <Cale> Preserving the performance of Parsec while generalising it is probably the tricky part
12:29:33 <__phas> Using the FFI marshalling libraryes, how can I get a Ptr CULong from a CUlong ?
12:30:52 <SamB> does GHC have that nice specialise pragma that will use a specialised version of a function even at runtime?
12:30:54 <SamB> I'm guessing no...
12:30:59 <SamB> because GHC probably can't do type-dispatch at runtime...
12:34:52 <Saulzar> As far as I know specialise was for compile time specialisation..
12:34:58 <Saulzar> To avoid run time dispatch
12:41:21 <ChilliX> __phas: use Foreign.with
12:41:40 <__phas> -Chillix- Thx
12:42:10 <ChilliX> eg, Foreign.with mylong (\ptrToLong -> <do some stuff>)
12:42:38 <SamB> Saulzar: well, I mean, so that it could do one run-time dispatch to a specialized version, to save you from all those indirect method calls
12:44:10 <eivuokko> @type flip Foreign.with (flip Foreign.peekBytOff 0)
12:44:12 <lambdabot> Not in scope: `Foreign.peekBytOff'
12:44:29 <eivuokko> @type flip Foreign.with (flip Foreign.peekByteOff 0)
12:44:33 <lambdabot> forall a a1.
12:44:33 <lambdabot>                  (Foreign.Storable.Storable a,
12:44:33 <lambdabot>                  Foreign.Storable.Storable a1) =>
12:44:33 <lambdabot>                  a -> IO a1
12:44:39 <eivuokko> But that's ugly :)
12:46:19 <eivuokko> Oh, heh.  I thought you wanted some integer -> pointer cast.  Sorry :)
12:49:50 <Saulzar> SamB, But it wouldn't do that by type dispatch it would make 2 versions and hardwire the specific version... no?
12:52:40 <SamB> Saulzar: well, ideally.
12:53:28 <SamB> but sometimes it might be nice if the generic version could dispatch to those versions when called with one of their types at runtime
12:54:05 <SamB> which works a lot better if you pass around types instead of those dictionaries, I think...
12:57:20 <nomeata> hi. is axel simon in here?
12:58:13 <nomeata> or can any one else tell me why the line:
12:58:14 <nomeata> foreign import ccall "wrapper" mkHandler_GtkEntryCompletionMatchFunc :: GtkEntryCompletionMatchFunc -> IO (FunPtr GtkEntryCompletionMatchFunc)
12:58:25 <nomeata> yeilds this error: parse error on input `import'
12:58:35 <nomeata> might I be missing some compiler flags or something?
12:58:44 <SamB> -fffi
12:58:46 <SamB> or -ffi
12:59:02 <SamB> -ffi looks nicer, I guess
12:59:31 <SamB> it thinks foreign is an identifier if you don't use that
12:59:56 <nomeata> thanks
13:00:01 <SamB> you are welcome!
13:00:31 * xerox <- back
13:00:39 <SamB> hellooo
13:00:45 <xerox> say say say!
13:00:57 <SamB> say say say what?
13:01:37 * xerox thinks if posting the stupid japanese program link on google video or not
13:01:55 <SamB> ?
13:02:13 <xerox> http://video.google.com/videoplay?docid=-2790332622002547165
13:03:16 <nomeata> what can I do against "Not in scope: data constructor `EntryCompletion'" ?
13:03:46 <SamB> @index EntryCompletion
13:03:47 <lambdabot> bzzt
13:03:59 <SamB> nomeata: did you say it somewhere?
13:04:27 <nomeata> SamB: it is exported by Graphics.UI.Gtk, AFAIK
13:04:57 <nomeata> SamB: the line in question is:
13:05:09 <nomeata>   dPtr <- mkFunPtrDestroyNotify hPtr
13:05:09 <nomeata>   (\(EntryCompletion arg1) arg2 arg3 arg4 -> withForeignPtr arg1 $
13:05:10 <nomeata>     \argPtr1 ->gtk_entry_completion_set_match_func argPtr1 arg2 arg3 arg4) ec
13:05:10 <nomeata>     (castFunPtr hPtr) nullPtr dPtr
13:05:57 <nomeata> which is part of the "do" of:
13:06:04 <nomeata> entryCompletionSetMatchFunc :: EntryCompletion -> (String -> TreeIter -> IO Bool) -> IO ()
13:06:04 <nomeata> entryCompletionSetMatchFunc ec handler = do
13:06:04 <nomeata>  
13:06:28 <nomeata> it complains about the EntryCompletion in the lambda pattern
13:06:31 <SamB> nomeata: what version of GTK did you have when you built gtk2hs?
13:07:04 <nomeata> SamB: I didn't build it, but the binary is 2.8.17
13:07:25 <SamB> well, what version was gtk2hs built against?
13:07:31 <nomeata> but do you think a scope problem can actually be related to the gtk version?
13:07:39 <nomeata> hmm, not sure, I'm using the pre-build debian binaries.
13:08:00 <SamB> pre-built binaries?
13:08:40 <nomeata> http://carwash.cs.nott.ac.uk:992/~lyh/gtk2hs/ which is linked from http://haskell.org/gtk2hs/download/
13:09:13 <SamB> well, my guess was they were built with a version of GTK below 2.4.0
13:09:17 <SamB> er, is
13:09:31 <nomeata> why's that?
13:10:01 <SamB> #if GTK_CHECK_VERSION(2,4,0)
13:10:02 <SamB> -- * Types
13:10:02 <SamB>   EntryCompletion,
13:10:02 <SamB>   EntryCompletionClass,
13:10:02 <SamB>   castToEntryCompletion,
13:10:04 <SamB>   toEntryCompletion,
13:10:36 <SamB> that is from Graphics.UI.Gtk.Entry.EntryCompletion
13:11:10 <nomeata> I can't imagine that, though. would these even link correctly then?
13:11:22 <SamB> of course
13:11:40 <SamB> there aren't missing symbols, just new ones
13:11:43 <nomeata> anyway, the scope error would be something else, woudn't it? After all, the "EntryCompletoin" in  the function definition is fine for ghc
13:12:04 <SamB> huh?
13:12:33 <SamB> that module doesn't export those things on your system!
13:13:11 <nomeata> nm -D /usr/lib/libgtk-x11-2.0.so.0.800.17 |grep gtk_entry_completion_set_match_func
13:13:11 <nomeata> 000bfea0 T gtk_entry_completion_set_match_func
13:13:28 <nomeata> nevermind, I guess I have to check the gtk2hs library
13:13:34 <SamB> yeah ;-)
13:14:45 <nomeata> well, there is /usr/lib/haskell-packages/ghc6/lib/gtk-0.9.10/imports/Graphics/UI/Gtk/Entry/EntryCompletion.hi
13:15:56 <nomeata> what confuses me: if I can write EntryCompletion in the function definition, why not inside a lambda expression
13:16:25 <nomeata> after all, it says scope error, not "symbol unknown" or "unknown constructor"
13:17:06 <davidhouse> nomeata: i think they're the same thing.
13:17:16 <davidhouse> anything GHC doesn't know about it calls a scope error.
13:17:26 <nomeata> ok
13:17:27 <SamB>  ghc --show-iface /usr/lib/haskell-packages/ghc6/lib/gtk-0.9.10/imports/Graphics/UI/Gtk/Entry/EntryCompletion.hi
13:18:09 <nomeata> export Graphics.UI.Gtk.Types EntryCompletion EntryCompletionClass castToEntryCompletion toEntryCompletion
13:18:16 <SamB> hmm
13:18:45 <SamB> well, you could try importing that module...
13:19:11 <SamB> oh, oh.
13:19:18 <nomeata> ok, that seems to work
13:19:19 <SamB> maybe EntryCompletion is only a type name
13:19:25 <nomeata> import Graphics.UI.Gtk.Types
13:20:53 <nomeata> hmm. next problem:    No instance for (Storable TreeIter) arising from use of `peek' at tutdb.hs:25:39-42
13:21:05 <nomeata> might that be another module that I need to import?
13:21:39 <xerox> SamB: did you see the clip?
13:22:12 <SamB> nomeata: I definately see such an instance in the Graphics.UI.Gtk.TreeList.TreeIter module
13:22:30 <SamB> xerox: no
13:22:35 <SamB> I'm on dialup :-(
13:22:41 <ChilliX> xerox: it's hilarious!
13:22:52 <nomeata> import Graphics.UI.Gtk.TreeList.TreeIter  does not help, though
13:22:54 <xerox> haha, there are other two if you are up to :P
13:25:07 <ChilliX> sure
13:27:09 <nomeata> hmm. I guess that instanse was put there after the last release.
13:27:32 <SamB> yrelease?
13:29:07 <nomeata> gtk2hs 0.9.10
13:30:26 <nomeata> what is this {# ... #} in the source? my ghc complains about that
13:30:36 <SamB> uh
13:30:46 <SamB> thats supposed to be handled by c2hs
13:30:51 <davidhouse> nomeata: pragmas. it shouldn't. what's the error exactly?
13:30:55 <SamB> er.
13:30:57 <SamB> or not.
13:31:00 <SamB> depends on what kind.
13:31:13 <davidhouse> you mean stuff like {-# OPTIONS_GHC -fglasgow-exts #-}?
13:31:18 <nomeata> tutdb.hs:24:13: parse error on input `{'
13:31:18 <SamB> wait, pragmas are {-# #-}
13:31:25 <SamB> I think {# #} are for c2hs
13:31:27 <nomeata> http://darcs.haskell.org/darcsweb/darcsweb.cgi?r=gtk2hs;a=plainblob;f=/gtk/Graphics/UI/Gtk/TreeList/TreeIter.chs.pp
13:31:40 <nomeata> so I can't use them in my regular .hs file?
13:31:46 <SamB> no
13:32:09 * nomeata is giving up on trying to hack a fixed entryCompletionSetMatchFunc into his app
13:32:29 <nomeata> I'll just get along without EntryCompletion, or wait for a new release, or build the current version myself.
13:32:44 <SamB> that does sound easier ;-)
13:33:51 <davidhouse> nomeata: are you trying to compile gtk2hs, or include some of its code in your app?
13:34:24 <SamB> davidhouse: he was trying to work around bugs in the release version ;-)
13:34:30 <davidhouse> ah.
13:36:28 <nomeata> correct
13:37:00 <dcoutts> nomeata, having problems building gtk2hs? or in using that code snippet that Axel gave you?
13:37:25 <nomeata> dcoutts: the latter
13:38:02 <nomeata> dcoutts: but it's no big deal, I can do without the EntryCompletion until a new version is released or compile my own version
13:38:25 <dcoutts> nomeata, so what went wrong with just copy & pasting that code in?
13:38:34 <dcoutts> it should work
13:38:52 <dcoutts> thoguh you will need to import a couple extra internal functions
13:38:58 <nomeata> a lots of missing imports, and no "Storable TreeIter" it the release version, as it seems.
13:39:25 <nomeata> No instance for (Storable TreeIter) arising from use of `peek' at tutdb.hs:25:39-42
13:39:26 <dcoutts> ah, that may be true (the Storable TreeIter)
13:39:39 <dcoutts> well you can build the darcs version, it's not that hard
13:40:04 <nomeata> I tried copying the Storable TreeIter instance in my code, but that did not work because of {#..#} constructs.
13:40:20 <nomeata> I might, though not today :-)
13:40:41 <neologism> is frags actively developed?
13:41:01 <dcoutts> nomeata, {# #} is a c2hs thing
13:58:04 <RyanT5000> is there a Double exponentiation?
13:58:27 <RyanT5000> like ^ except Double -> Double -> Double
13:58:38 <SamB> @type **
13:58:40 <lambdabot> parse error on input `**'
13:58:45 <SamB> @type (**)
13:58:47 <lambdabot> forall a. (Floating a) => a -> a -> a
13:58:51 <RyanT5000> thanks
14:00:21 <febuiles> any idea of why is this failing: http://pastebin.com/681754 ?
14:01:09 <conal> febuiles: yes.  application is just juxtaposition in haskell
14:01:27 <mauke> (foo) is the same as foo
14:01:33 <mauke> foo (bar) is the same as foo bar
14:01:40 <xerox> Your foo (bar) should be written as (foo bar)
14:01:51 <febuiles> mmm, perfect, thanks again :D
14:01:51 <xerox> As much as you did for (famas + 1)
14:02:06 <febuiles> switching languages = hard :(
14:02:20 <conal> but sometimes the parens are unneeded, eg: "head orig == head dest"
14:02:34 <conal> while in line 5 you'll need to add some
14:02:37 <xerox> Also you can do pattern matching instead of using head and tail.
14:03:06 <Cale> yeah, the way that's currently written, it will fail on the empty list
14:03:20 <xerox> If you swap (x:xs) and (y:ys) for orig and dest respectively, then (head orig) would be x, and (tail orig) would be ys.  y and ys for dest.
14:03:27 <Cale> The way it pattern matches is that it tries the bindings in order
14:03:31 <febuiles> Cale: I thought that link 8 helped that 
14:03:34 <xerox> Err, (tail dest) = xs. 
14:03:36 <Cale> so you have to put more specific patterns first
14:03:56 <febuiles> xerox I see, easier that way
14:03:58 <Cale> if you move like 8 to just before line 2, it'll work
14:04:05 <Cale> line*
14:04:19 <febuiles> oh, great
14:04:31 <mahogny> did anyone look for me earlier? scrolled out of buffer
14:04:32 <xerox> Because they're checked in order.
14:04:34 <febuiles> thank you all :D
14:04:38 <Cale> no problem :)
14:04:40 <xerox> You're very much welcome!
14:06:04 <Cale> mahogny: sorry, I was away earlier, what?
14:06:35 <Cale> oh
14:06:47 <mahogny> Cale, by irc client highlighted this channel when I came home :/
14:06:58 <mahogny> ah
14:06:59 <mahogny> xerox, 
14:07:07 <Cale> ah, yeah, I don't have that in my buffer either
14:07:07 <mahogny> xerox, pong *latency*
14:07:13 <xerox> Hmmm.
14:07:14 <mahogny> the art of huge greps :)
14:07:55 <Cale> -rw-r--r--    1 cale     cale     103691891 2006-04-25 17:06 FreeNode-#haskell.log
14:07:59 <mahogny> xerox, wanted anything? :)
14:08:07 <xerox> Let me try to remember.
14:08:24 <mahogny> I can try and read more in the buffer
14:08:25 <Cale> heh, my #haskell log is 100MB
14:09:40 <Cale> it also appears to include some control character that messes up my terminal when catted.
14:09:55 <mahogny> xerox, the logs doesn't hint much. might it be related to SoC?
14:12:27 <Cale> heh, 16.9 million words
14:12:36 <mahogny> lol
14:12:44 <mahogny> the art of useless commands :)
14:13:05 <Cale> and keeping overly large IRC logs
14:13:10 <mahogny> consider what one could write if each of those were one "word" of haskell
14:13:25 <nomeata> Hi. I'm following http://www.haskell.org/tutorial/monads.html. Before I can do "instance Num a => Num (R a) where ..." I had to write the lines "instance Eq a => Eq (R a)" and "instance Show a => Show (R a)". What is the reason for that?
14:13:58 <Cale> nomeata: Eq and Show are superclasses of Num
14:14:13 <nomeata> Cale: so every instance of Num has to be an instance of Eq and Show?
14:14:16 <Cale> yes
14:14:18 <davidhouse> exactly.
14:14:20 <Cale> unfortunately
14:14:36 <SamB> nomeata: you could have said "deriving (Eq, Show)"
14:14:42 <SamB> Cale: *un*-fortunately?
14:14:49 <RyanT5000> is there a function that gets every partition of a list?
14:14:56 <xerox> mahogny: yes it might
14:15:01 <nomeata> and an empty instance Show a => Show (R a) helps, even if I don't give a definition for show (R a)
14:15:03 <xerox> mahogny: aaaah! Did any student mail you?
14:15:11 <mahogny> xerox, lemme check
14:15:13 <Cale> SamB: yeah, there are lots of things which we'd like to have instances of Num for which can't be in either Eq or Show in any reasonable way
14:15:32 <xerox> mahogny: a student on the HOpenGL list told me he was going to, he's cool
14:15:36 <Cale> Like function types
14:15:43 <mahogny> xerox, ah. indeed one did
14:15:49 <mahogny> xerox, ooh
14:15:52 <xerox> mahogny: nice!!
14:15:53 <mahogny> that was fast
14:16:21 <xerox> Keep me updated :-)
14:16:56 <mahogny> he is indeed ready to take on something big. gotta calm him down a bit, as expected :)
14:17:35 <RyanT5000> how do you do integer division?
14:17:47 <greenrd> a `div` b
14:17:52 <RyanT5000> thanks
14:18:38 <vincenz> or
14:18:50 <vincenz> > let (/) = div in 3 / 5
14:18:52 <lambdabot> 0
14:19:13 <Cale> That's one thing which I'd change about the numeric stuff in the prelude -- separate `div` from toInteger.
14:19:23 <vincenz> > let (\) = div in 3 \ 5
14:19:25 <lambdabot>  parse error on input `)'
14:19:50 <liyang> lolol
14:19:51 <vincenz> Cale: how do you mean?
14:20:18 <Cale> quot, rem, div, mod, quotRem, and divMod should be in their own class, and toInteger in another
14:20:20 <Spark> let (\\) = div in 3 \\ 5
14:20:44 <vincenz> > let (\\) = div in 3 \\ 5
14:20:46 <Cale> There are more Num instances on which you could define div than on which you could define toInteger.
14:20:46 <lambdabot> 0
14:20:47 <vincenz> Cale: ah yeah
14:20:50 <vincenz> woah
14:20:53 <vincenz> why ... toInteger?
14:20:57 <Cale> (for example, polynomials)
14:21:12 <vincenz> right
14:21:17 <Spark> > hurt me beautiful
14:21:25 <lambdabot>  Not in scope: `beautiful'
14:21:30 * vincenz pats Spark 
14:21:45 <Cale> I think the expectation was that those functions be used only for things like Int and Integer.
14:22:03 <vincenz> Num poly woudl be neat
14:22:09 <Cale> Whoever designed that class decided to ignore all other Euclidean domains.
14:22:15 <Spark> > let hurt = \x.\y.666 in hurt me beautiful
14:22:17 <lambdabot>  parse error on input `.\'
14:22:21 <vincenz> however
14:22:31 <vincenz> Integral a => Integral (Polynomial a)
14:22:38 <SamB> Cale: you can't expect to get things like that right to start with
14:22:45 <Spark> i should learn haskell some day
14:22:48 <Spark> maybe tommorow
14:22:53 <SamB> haha
14:22:55 <vincenz> or is that unnecessary?
14:23:02 <vincenz> Spark: lazy evaulation!
14:23:07 <jlhamilton> Cale: will haskell' fix a lot of these number problems?
14:23:08 <vincenz> Spark: you have the foundation
14:23:16 <Cale> jlhamilton: I'm not sure.
14:23:19 <SamB> I doubt it
14:23:20 <Spark> yeah it shouldnt take too long
14:23:31 <SamB> somebody would have to actually, you know, do the work!
14:23:33 <Cale> jlhamilton: The general idea for haskell' is to only standardise implemented things.
14:23:33 <vincenz> ... famous last quote
14:23:34 <liyang> Import Prelude hiding everything and start over again.
14:23:44 <vincenz> Cale: I have to say that's shortsighted...
14:23:59 <vincenz> Cale: you want to refactor to clean it up and allow extensions
14:24:00 <Cale> vincenz: well, ghc doesn't have to follow the standard all the time :)
14:24:13 <vincenz> I like the class alias thingy
14:24:14 <SamB> vincenz: sure
14:24:21 <SamB> but its hard work doing that
14:24:22 <vincenz> that would ease a lot of the problems
14:24:23 <Cale> We have plenty of stuff in there that's not H98.
14:24:34 <vincenz> anyone seen that class alias thing/
14:24:35 <Cale> Yeah, I wish we had something along those lines too.
14:25:13 <Cale> I'd kind of like the ability to define default instances.
14:25:19 <vincenz> doesn't seem so complex
14:25:20 <Cale> (like default methods)
14:25:25 <vincenz> what is that... right after parsing?
14:25:27 <vincenz> the alias thingy
14:25:28 <SamB> and the numerics framework is a wonderful example of something that can be reworked in some repository somewhere
14:25:51 <vincenz> I mean the alias only requires source-manipulation
14:26:00 <vincenz> hmm
14:26:02 <vincenz> TH anyone?
14:26:11 <vincenz> or is TH not capable of such
14:26:53 <vincenz> (aka...it's not like camlp4/)
14:26:54 <vincenz> ?
14:26:56 <Cale> vincenz: It's a little more subtle than that.
14:27:10 <musasabi> TH is capable of many things, just not new syntax.
14:27:11 <vincenz> Cale: well yes.. your export list needs to also define these aliases
14:27:28 <vincenz> Cale: so that any instantiation elsewhere also expands
14:27:38 <vincenz> but it doesn't' seem ubercomplex
14:27:53 <vincenz> unless I'm missing something
14:28:25 <vincenz> Cale: btw...wanna gimme a pubkey
14:28:29 <vincenz> so you have repo access?
14:28:32 <Cale> pubkey?
14:28:46 <xerox> mahogny: I found another guy who knows you: nattfodd: excellent, one of the haskell mentor is a student at the uni I'll be an intern in this summer
14:28:50 <Cale> I thought I had repo access
14:28:52 <vincenz> Cale: ssh key
14:29:07 <vincenz> Cale: no you have wiki access
14:29:13 <Cale> ah
14:29:21 <vincenz> I need your pub ssh key
14:29:30 <mahogny> xerox, nattfodd. hmm. never heard of him. know his real name?
14:29:48 <Cale> vincenz: I just use my local account.
14:30:06 <nattfodd> mahogny: Alexandre Buisse
14:30:10 <xerox> :-D
14:30:16 <nattfodd> mahogny: but I'm in Uppsala atm
14:30:17 <mahogny> nattfodd, ah. hello :)
14:30:23 <nattfodd> I'll only come for the summer
14:30:31 <Cale> (so I'm not quite sure what you're talking about :)
14:30:42 <mahogny> nattfodd, studying there?
14:30:51 <nattfodd> hi
14:30:52 <nattfodd> nice to meet you
14:31:18 <mahogny> same here :)
14:31:25 <nattfodd> mahogny: I'll do an internship with Peter Dybjer
14:31:30 <mahogny> aaah
14:31:41 <nattfodd> and hopefully come back later if I like it, which I think I'll do
14:31:47 <nattfodd> I take it you know him?
14:32:13 <mahogny> met him a few times, but I'm actually centered around other departments
14:32:27 <nattfodd> are you a PhD student?
14:32:38 <mahogny> no, working on that ;)
14:32:52 <mahogny> but my field is a bit narrow and not very popular here :(
14:32:54 <Cale> vincenz: so I run ssh-keygen?
14:33:01 <nattfodd> nice, we're on the same boat, then :)
14:33:38 <mahogny> nattfodd, I'm more into biophysics though, not programming :)
14:34:51 <nattfodd> humpf
14:35:00 <nattfodd> biophysics has the word 'physics' in it 
14:35:03 <mahogny> lol
14:35:08 <mahogny> well, biomathematics if you prefer :)
14:35:29 <xerox> vincenz: ping
14:35:43 <mahogny> xerox, you like those pings huh? :)
14:36:41 <nattfodd> mahogny: which explains why you're willing to mentor people working on matlab
14:36:53 <vincenz> xerox: PONG
14:36:56 <xerox> vincenz: see mentoring FAQ nÂ°27.
14:36:57 <vincenz> Cale: YEP
14:37:02 <xerox> CAPS
14:37:40 <mahogny> nattfodd, yeah. I use it a lot
14:38:00 <Cale> vincenz: where should I send it?
14:38:06 <mahogny> nattfodd, it's strong until I want to implement a serious algorithm :/
14:38:40 <vincenz> Cale: my email will do
14:39:41 <nattfodd> mahogny: it corresponds to what I remember from maple
14:40:34 <mahogny> nattfodd, it's ok as long as lists are ok. but you won't find a linked list in these languages, which is good until you need one :)
14:41:02 <nattfodd> :)
14:41:46 <Cale> vincenz: the contact on "Not Vincenz's Wiki"?
14:42:25 <nattfodd> you have too many great projects on this SoC page...
14:42:36 <xerox> Yay!
14:43:26 <nattfodd> can I safely guess that dons is Don Stewart?
14:43:32 <xerox> Yup.
14:44:05 <nattfodd> and is lemmih on irc?
14:44:21 <xerox> Quite everybody is, apart from 2-3 iirc.
14:44:42 <nattfodd> but he's not atm, or not under this nickname
14:45:06 <musasabi> @seen Lemmih
14:45:07 <lambdabot> I saw Lemmih leaving #haskell-overflow, #haskell-blah and #haskell 13 hours, 44 minutes and 6 seconds ago, and .
14:45:17 * nattfodd would be very interested in the Yi thing, guessing from the description
14:45:21 <nattfodd> thanks musasabi 
14:45:27 <Cale> lemmih is David Himmelstrup
14:45:37 <vincenz> Cale: YEP
14:45:47 <Cale> vincenz: you should have it then
14:45:52 <vincenz> OK
14:46:02 <Cale> vincenz: what's with the all-caps?
14:46:20 <mahogny> xerox, ok. fat reply sent to that guy. if he knows the basics required for this, and we can concentrate on the minimalistic version of what he wants to do (and add features if time allows), then I think it can work out
14:46:35 <xerox> mahogny: nciely going!
14:46:50 * mahogny adds some projects to SoC, just in case
14:47:23 <xerox> mahogny: hmm, what exactly?
14:47:42 <vincenz> Cale: done
14:47:42 <mahogny> xerox, he wants to make a level editor in style of Hammerhead
14:47:47 <vincenz> Cale: playing a game, running is capslock
14:47:57 <bolrod> xerox: why doens't the google soc page have a link to the haskell ideas
14:48:00 <Cale> vincenz: ah
14:48:05 <xerox> bolrod: it will
14:48:11 <bolrod> ic :)
14:48:23 <mahogny> xerox, just the barebones should be no trouble, but I know that kind of programs has tons of features. I won't require him to implement any of those, they are just bonus
14:48:34 * Cale guesses Morrowind
14:48:46 <xerox> mahogny: ah, nice, you could think up a modular design to let it be done later
14:48:58 <mahogny> xerox, yeah
14:49:25 <mahogny> xerox, I had hoped to get something like this actually. if it turns out well, then he can work on this project also after SoC
14:49:40 <xerox> mahogny: that's what everyone whishes too, hehe!
14:50:04 <SamB> so what kind of person would ParsecT be a good project for?
14:50:15 * mahogny runs out of cathegories on haskell SoC :P
14:51:00 <xerox> SamB: quite experienced Haskell coder?
14:51:09 <mahogny> SamB, a compiler hacker on crack
14:51:29 <SamB> ah, okay, so I don't have to worry about being overqualified ;-)
14:51:42 <mahogny> :)
14:51:59 <xerox> SamB: hehe!  Did you add the project to the page yet?
14:52:14 <SamB> no
14:52:34 <RyanT5000> is there a function cross :: [a] -> [b] -> [(a, b)]?
14:52:39 <RyanT5000> (returns every pair)
14:52:49 <Cale> RyanT5000: liftM2 (,)
14:52:50 <mauke> @type zip
14:52:51 <lambdabot> forall b a. [a] -> [b] -> [(a, b)]
14:53:02 <RyanT5000> Cale: thanks
14:53:06 <Cale> zip is not what he's talking about :)
14:53:07 <RyanT5000> mauke, not zip
14:53:11 <mauke> oh
14:53:14 <Cale> > liftM2 (,) [1,2,3] [4,5,6]
14:53:16 <lambdabot> [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
14:53:47 <Cale> > liftM2 (,) (Just 1) (Just 2)
14:53:48 <lambdabot> Just (1,2)
14:53:49 <SamB> so will haskell.org provide SoC mentees with webspace for darcs repos?
14:54:26 <Cale> Whatever happened to the project to move fptools to darcs completely? Has that happened?
14:54:47 <xerox> SamB: last year it was required to put the projects on something like sourceforge.  Dunno.
14:54:57 <xerox> Cale: darcs.haskell.org/packages/ ?
14:55:01 <Cale> (I know that it's available as a darcs repo, so that it's obtainable that way, but I didn't think the other direction was up and running yet)
14:55:40 <SamB> I thought darcs was in charge by now...
14:55:54 <xerox> SamB: I did my development in darcs yes.
14:56:25 <SamB> I meant, I thought the main repo was darcs now, and CVS just a mirror, or something like that...
14:56:28 <xerox> SamB: I don't know how will it work for all this year's students, but I'm taking note, thanks for pointing that out
14:56:41 <hyrax42> > [(a,b)| a<-[1,2,3], b<-[4,5,6]]
14:56:42 <lambdabot> [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
14:56:46 <mahogny> ok. 2 new projects added to haskell SoC
14:56:50 <xerox> hyrax42: zip
14:56:53 <hyrax42> is that sugar for the liftM2 construct?
14:57:00 <mauke> huhu
14:57:02 * SamB shudders at the idea of using sf.net for this
14:57:04 <hyrax42> that cale gave?
14:57:26 <hyrax42> or closer I guess would be
14:57:38 <xerox> hyrax42: no
14:57:45 <hyrax42> > [(,) a b| a<-[1,2,3], b<-[4,5,6]]
14:57:46 <lambdabot> [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
14:57:51 <mauke> well, it's sugar for do { a <- [1,2,3]; b <- [4,5,6]; return (a,b) } which is sugar for [1,2,3] >>= \a -> [4,5,6] >>= \b -> return (a,b)
14:58:10 <xerox> hyrax42: liftM2 a b c = do { x <- a; y <- b; c x y }
14:58:11 <musasabi> I think it would make sense for use a darcs solution to host the haskell.org SoC projects if possible,
14:58:16 <musasabi> ,->.
14:58:27 <mauke> xerox: return?
14:58:42 <hyrax42> hmmm
14:58:43 <xerox> musasabi: I would love if darcs people proposed darcs projects!  I'm not really into their group though, pfft.
14:58:45 <araujo> Hello all.
14:58:49 <xerox> @type liftM2
14:58:50 <lambdabot> forall r (m :: * -> *) a2 a1.
14:58:50 <lambdabot>     (Monad m) =>
14:58:50 <lambdabot>     (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
14:58:55 * araujo thinks the diagram editor is nice
14:58:57 <xerox> mauke: right, return.
14:59:00 <Cale> ah, when you really look carefully at the parsec types, it seems like it is mostly just a classical parsing monad
14:59:04 <mauke> liftM2 f a b = do { x <- a; y <- b; return (f x y) }
14:59:07 <mauke> and argument order
14:59:15 <xerox> Yes, I was going by memory sorry.
14:59:33 <Cale> The user-state thing is silly.
14:59:43 <hyrax42> so they reduce to the same thing, but not for a particularly sugar-coated reason?
15:00:07 <Cale> though I suppose it saves you some trouble if you'd otherwise need to apply StateT
15:00:18 <Cale> hyrax42: yeah
15:00:41 <hyrax42> hmm
15:00:49 <hyrax42> I'll have to get the old noggin around this some time
15:00:53 <Saulzar> I am wondering how StateT influences performance for something like that, if at all...
15:01:24 <Cale> hyrax42: liftM2 is a monadic combinator, I'm abusing the fact that lists form a monad
15:01:33 <nattfodd> xerox: there is the darcs gui project
15:01:56 <xerox> nattfodd: right, the guy proposing it, or better, reviewing it on the darcs ml couldn't mentor it though
15:02:17 * araujo originally proposed the project using gtk2hs
15:02:35 <xerox> araujo: yes :-|
15:02:50 <nattfodd> wx* isn't so good
15:03:04 <nattfodd> go ask jakub in #gentooèbugs if you have doubts about it :)
15:03:09 <nattfodd> #gentoo-bugs
15:03:35 <hyrax42> what would be the best way to get this understood... go back to the 90's papers on monads?
15:03:49 <Cale> no, first of all, read my tutorial :)
15:03:55 <hyrax42> well it is not terribly relevant right now, I suppose... exams for a week yet
15:03:58 <Cale> then read All About Monads
15:04:08 <Cale> @oldwiki MonadsAsContainers
15:04:09 <lambdabot> http://www.haskell.org/hawiki/MonadsAsContainers
15:04:15 <hyrax42> I have all about monads
15:04:16 <hyrax42> ah
15:04:37 <hyrax42> thanks
15:04:39 <Saulzar> The early monad parser tutorials are quite good to get started too
15:04:52 <araujo> xerox, i see the community has moved very fast with this, thanks for organizing the whole thing
15:04:57 <hyrax42> I'll bookmark this, and look at it starting in a week or so I guess
15:05:09 <Cale> Though I find that older material on monads was more confused about good ways to teach the usefulness of monads to newcomers.
15:05:36 <Saulzar> The one I looked at used gofer, but still it was enlightening :)
15:06:04 * xerox hugs araujo 
15:06:12 <araujo> haha
15:09:01 <dons> moin!
15:09:06 * xerox waves to dons
15:09:15 * nattfodd notices there is no automatic prover project idea for SoC
15:09:35 <mahogny> nattfodd, tell me if you find a suitable student :)
15:09:37 <dons> ah yes. something in that domain would be good
15:09:43 <nattfodd> mahogny: me :)
15:09:48 <mahogny> nattfodd, lol
15:09:52 <nattfodd> but I need a mentor and an idea :)
15:10:00 <xerox> nattfodd: Coq guys were going to port it to Haskell for one
15:10:03 <musasabi> Something to prove things for class instances automatically would be very nice.
15:10:06 <ChilliX> Moin dons
15:10:14 <xerox> dons: do you know the Coq guys?  It would be cool to ask them
15:10:31 <nattfodd> xerox: yes, I know them
15:10:37 <nattfodd> but they are very ocaml people
15:10:39 <dons> hey ChilliX!
15:10:46 <hyrax42> @t join
15:10:47 <lambdabot> Maybe you meant: time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type .
15:10:51 <hyrax42> @type join
15:10:53 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
15:10:57 <monochrom> Coq to be ported to Haskell?!  Yay!
15:11:00 <xerox> nattfodd: they were the one telling me
15:11:05 <xerox> monochrom: Yay indeed.
15:11:11 <nattfodd> xerox: who was telling you?
15:11:19 <xerox> Memory refuges now....
15:11:21 <musasabi> e.g. that for Eq: a == b <=> b == a, and "a == a" and "a == b && b == c => a == c"
15:12:24 <musasabi> of course having that information propagated to the compiler would be extra nifty.
15:13:25 <palomer>  /me thinks Functor is the greatest typeclass of all
15:13:56 * Cale tries to decide what methods ought to be in the MonadParser class
15:14:12 <monochrom> many
15:14:23 <monochrom> (the combinator called "many", I mean)
15:14:55 <mauke> many can be written manually, it doesn't have to be a method
15:14:58 <hyrax42> what implementation does lambdabot use?
15:15:32 <dons> hyrax42: ? implementation of what, haskell?
15:15:40 <hyrax42> yes
15:15:42 <dons> ?version
15:15:42 <lambdabot> lambdabot 3p414, GHC 6.4.1 (Linux i686 3.20GHz)
15:15:42 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
15:15:43 <nattfodd> dons: mind if I query?
15:15:49 <nattfodd> about SoC
15:15:51 <hyrax42> I do not recognise those type annotations (forall etc.)
15:15:57 <dons> nattfodd: sure.
15:16:06 <monochrom> It has to be a method, having access to internal stuff, if it is to satisfy some subtle strictness and laziness requirements.
15:16:34 <dons> hyrax42: ghc prints types with explicit kind and quantification notes.
15:16:36 <hyrax42> if I do :t in my ghci shell I don't see the forall a (m :: * -> *) part
15:17:03 <hyrax42> I just get
15:17:05 <monochrom> In short, Text.ParserCombinators.Prim stuff should become methods of the class.
15:17:05 <hyrax42> Prelude> :t Monad.join
15:17:06 <hyrax42> Monad.join :: (Monad m) => m (m a) -> m a
15:17:08 <mauke> I don't know what MonadParser is, but my parser has the following primitives: runParser, tokenIf, <?>, <|>, <||>, <|||>, followedBy, notFollowedBy
15:17:32 <monochrom> Some internal stuff from Text.ParserCombinators.Prim should also be exposed methods IMO, e.g., manyAccum
15:17:34 <hyrax42> vs.
15:17:37 <hyrax42> @type Monad.join
15:17:38 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
15:17:45 <xerox> (I'm asking on #coq.)
15:18:58 <dons> we do have agda, already written in Haskell.
15:19:12 <dons> some theom prover literate person could work on that, perhaps?
15:19:52 <araujo> dons, hola!
15:19:54 <monochrom> "if many and skipMany are not defined as primitives, they will overflow the stack on large inputs"  http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/libraries/parsec/Text/ParserCombinators/Parsec/Prim.hs?rev=1.4
15:19:56 <nattfodd> dons: especially considering that I would be in internship in the team that created it
15:20:01 <xerox> (But there is some Smerdyakov guy who asked to be unbanned from #haskell and such... ?!)
15:20:24 <palomer> http://www.rafb.net/paste/results/F3dyv525.html <--anyone have any idea?
15:20:27 <mahogny> there are already some theorem provers around. I'd rather see if someone could take one and maybe make it a drop-in replacement for QuickCheck
15:20:53 <Igloo> xerox: What are you replying to?
15:20:56 <monochrom> But I think it is a greater service to expose manyAccum, which many and skipMany uses.  (Things like sepBy could use it too.)
15:21:08 <palomer> mahogny: monochrom is an expert on this subject
15:21:19 <monochrom> Not at all.  I just know HOL.
15:21:30 <palomer> aren't you into formal verification?
15:21:32 <xerox> Igloo: "ask shapr" my first thought, and nothing else.
15:21:33 <mahogny> I am certainly not. I only know theorem proving for imperative languages
15:21:56 <mahogny> and sequential (completely useless) languages >_<
15:22:03 <xerox> He's saying Ocaml works much better for Coq, than Haskell.
15:22:15 <xerox> But there is the other guy I was taking about before that finds the idea interesting.
15:22:27 <palomer> ahh, nevermind
15:23:01 <mahogny> someone feel free to add my idea, and mentor it, for SoC. I'd really love the tool :)
15:23:48 <musasabi> mahogny: just add it to the page.
15:23:59 <mahogny> hm. guess I could
15:24:07 <monochrom> I am not into formal verification if that phrase means specifically verification by machine.
15:24:24 <araujo> mahogny, and put as mentor: no-one.
15:24:36 <araujo> Somebody interested might take it.
15:25:40 <xerox> monochrom: what do you think could be a good Haskell project wrt Coq?
15:26:14 <ChilliX> xerox: Why Coq?  And not, eg, Isabelle?
15:26:32 * nattfodd thinks that s/coq/some theorem prover in haskell/ might be a better idea
15:26:40 <xerox> ChilliX: dunno, I just remembered something about the Coq guys and #haskell.
15:27:10 <xerox> The theorem prover idea sound very good.
15:27:11 <monochrom> I don't have specific suggestions.
15:27:14 <hyrax42> so in the list monad, fmap = map, return = \x -> [x], join = foldr (++) []?
15:27:14 <hyrax42> (except not defined as such?)
15:27:26 <xerox> monochrom: would you be up for mentoring a student working on such a project like a theorem prover?
15:27:28 <palomer> where do I find out what functions I have to implement in order to instantiate Enum?
15:27:31 <ChilliX> IMHO the Coq community seems to be more closed than the Isabelle community; ie, might be easier to find an Isabelle person to cooperate with...
15:27:40 <monochrom> yes hyrax42, actually it's exactly that.
15:27:49 <hyrax42> oh thanks
15:27:53 <hyrax42> my connection died a second
15:27:58 <hyrax42> and was about to re-ask
15:28:04 <xerox> hyrax42: and (>>=) becomes? :-)
15:28:11 <hyrax42> I'm getting there!
15:28:15 <hyrax42> it's the next one
15:28:16 <xerox> Sure!
15:28:36 <hyrax42> just going through Cale's tutorial
15:28:54 <mauke> @djinn [a] -> (a -> [b]) -> [b]
15:28:55 <lambdabot> -- f cannot be realized.
15:29:01 <mahogny> ok. added my idea, no mentor yet (come on! ;) ). we really oughta keep this wikipage for next year. many ideas are worth saving for later in case they don't get implemented
15:29:16 <Cale> > join [[1,2,3],[4,5],[6,7,8,9]]
15:29:17 <lambdabot> [1,2,3,4,5,6,7,8,9]
15:29:31 <Cale> > fmap (*10) [1,2,3]
15:29:32 <lambdabot> [10,20,30]
15:29:38 <Cale> > return 5
15:29:39 <lambdabot>  add an instance declaration for (Show (m a))
15:29:44 <Cale> > return 5 :: [Integer]
15:29:45 <lambdabot> [5]
15:29:49 <hyrax42> don't spoil the >>= one
15:29:55 <Cale> okay
15:29:56 <xerox> mahogny: what is your idea?
15:30:01 <RyanT5000> what's the function that returns all subsequences of a list?
15:30:03 <hyrax42> :)
15:30:13 <xerox> Formal Verification ?
15:30:17 <mahogny> xerox, yes
15:31:31 <xerox> dons: I see that SimonM talked to you about some projects, did he mention the distcc one perchance?
15:31:31 <shapr> xerox: In my experience, Smerdyakov is a troll.
15:31:52 <xerox> shapr: I had that impression from #scheme-rs too.
15:32:09 <sysfault> pretty knowledgeable guy however.
15:32:13 * araujo got the same impression from ##c
15:32:19 <sysfault> from my run ins with him.
15:32:22 <febuiles> RyanT5000: Maybe subsequences or tails? I'm not sure of what you mean by subsequences 
15:32:34 <shapr> For any channel that I admin, I will permanently ban Smerdyakov the instant he starts any trouble.
15:33:05 <shapr> That's the result of me spending way too many weeks dealing with him on #haskell
15:33:06 <franka> Hi, shapr.
15:33:21 <shapr> hiya franka, how's code?
15:33:28 <xerox> febuiles: ooops.  I didn't forget you!
15:33:29 <araujo> shapr, and what did he do here?, to talk about the ML superiority too?
15:33:40 <franka> Hm. Yeah, I don't code much nowadays.
15:33:41 <febuiles> haha dont worry xerox
15:34:11 <RyanT5000> febuiles: well, by subsequence i mean the original list with any number of elements removed, but i just figured out that's not the function i need anyway
15:34:17 <shapr> araujo: I don't mind too much if people are totally fanatic about only one thing. I do mind when someone starts driving newbies out of #haskell by being an irritating asshole.
15:34:36 <franka> Well, actually, I was thinking about how to code our mobile channels implementation MoCha in Haskell yesterday...
15:34:37 <araujo> shapr, ok, that's it
15:34:55 <xerox> febuiles: answered.
15:36:28 * araujo thinks thelist is growing up quite fast
15:36:37 <dons> xerox, oh, hmm, distcc. I've got a project idea of my own for that. that would be good .
15:37:26 <xerox> dons: I think the guy proposed me that was asking SimonM to mentor him, okay.
15:40:53 * SamB wonders why student registrations open on a monday
15:40:56 * SamB thinks that is a bit unfair
15:41:09 <musasabi> dons: any good ideas for different ways of sorting strings?
15:41:12 <wchogg> Unfair because they have work to do on monday?
15:41:13 <xerox> Because of... school?
15:41:18 <SamB> yes!
15:41:36 <xerox> Dang.
15:41:37 <musasabi> dons: the UTF8 module clearly needs to use UCA while the ASCII folks want just raw byte comparisons...
15:41:43 <SamB> unless nothing happens yet then
15:43:03 <dons> musasabi: right. the ascii people can just use qsort
15:43:09 <dons> qsort(3)
15:43:45 <musasabi> dons: and memcmp instead of a unicode_cmp 
15:44:09 <SamB> isn't qsort slow?
15:44:18 <musasabi> SamB: yes.
15:44:19 <SamB> being non-inlineable?
15:44:29 <musasabi> dons: which means two different Ord instances and that the modules may never be imported to the same place.
15:44:46 <SamB> musasabi: that sounds horrid
15:44:51 <SamB> isn't that what newtypes are for?
15:45:00 * araujo wonders if dons got free time for privmsg
15:45:04 <dons> SamB, its faster than List.sort for packed strings.
15:45:12 <dons> its possible though that we could code up a faster pure Haskell version
15:45:22 <musasabi> SamB: yes newtypes should work.
15:45:23 <dons> our compare is pure haskell, and it runs like a memcmp.
15:46:11 <SamB> dons: yes, I think it would be more efficient to write the sort in Haskell
15:46:13 <dons> araujo: always.
15:46:28 <musasabi> dons: have you looked at UCA? It is quite nontrivial.
15:46:36 <musasabi> much more slower than qsort.
15:46:39 <SamB> xerox: hey, it says this page is for *mentors* to add ideas
15:46:42 <dons> SamB, I accept patches.
15:46:52 <xerox> SamB: it is okay, keep on reading that header
15:47:15 <SamB> oh
15:47:25 <SyntaxNinja> ahh coofeeee
15:47:54 <SamB> maybe if you said "mentors, please add your ideas ...!" that would be less off-putting
15:48:01 <SamB> or maybe I am just silly
15:49:50 <SyntaxNinja> SamB: actually, you should start moving over to here anyway. anyone can add project ideas: http://hackage.haskell.org/trac/summer-of-code/wiki
15:50:29 <xerox> SamB: np
15:50:55 <SamB> SyntaxNinja: shouldn't the ideas go on a particular page?
15:51:25 <SyntaxNinja> samb: here are all the project ideas: http://hackage.haskell.org/trac/summer-of-code/query?status=new&status=assigned&status=reopened&type=proposed-project&order=priority
15:51:36 <SyntaxNinja> this way we can query them in a variety of ways, instead of just looking at one static page
15:53:39 <SyntaxNinja> SamB: what do you think?
15:53:56 <SamB> SyntaxNinja: I think I don't know how to use Trac yet
15:54:12 <xerox> Urgh, I got Smerdyakov on #haskell-overflow.
15:54:26 <SamB> interesting.
15:54:27 <hyrax42> I should read the prelude
15:54:30 <hyrax42> one day
15:54:32 <SamB> I better not say anything yet.
15:54:44 <SamB> hyrax42: lately it looks kind of empty, anyways
15:54:55 <hyrax42> well I should learn more haskell I guess
15:55:02 <SamB> or did you mean the one in the report? ;-)
15:55:19 <hyrax42> the report I think?
15:55:27 <hyrax42> just feeling kidna dumb for not knowing
15:55:39 <hyrax42> concat = foldr (++) []
15:55:40 <SamB> don't ;-)
15:55:48 <xerox> :-)
15:56:00 <hyrax42> don't?
15:56:06 <SamB> don't feel dumb
15:56:08 <hyrax42> the report is the only haskell book our library has
15:56:11 <hyrax42> ah
15:56:25 <hyrax42> which strikes me as a bit strange
15:56:31 <SamB> as long as it is obvious once you know what concat, foldr, and ++ are, thats good
15:56:38 <hyrax42> maybe I should go crazy and order a whole bunch
15:56:39 <SamB> huh, your library has the report?
15:56:44 <hyrax42> and nothing else
15:56:56 <hyrax42> oh university library
15:56:59 <hyrax42> mcgill
15:57:12 <SamB> well, I guess whoever asked for it must have been happy with just that ;-)
15:57:14 <hyrax42> yeah I guess ignorant rather than dumb was the word
15:57:18 <SyntaxNinja> SamB: what's to know? it's a wiki, and a ticket tracking system.
15:57:31 <SyntaxNinja> SamB: you create new project ideas by creating a new ticket. fill in the fields you know. tha'ts all.
15:57:48 <SamB> well, the ticket tracking system part is the part that is slightly intimidating
15:58:24 <SyntaxNinja> SamB: don't worry. just create one :)
15:58:47 <SamB> first things first, I must register
15:59:33 <SyntaxNinja> SamB: no need.
15:59:40 <SamB> oh.
15:59:50 <SamB> well, that would explain this error.
16:02:53 <SamB> hmm, so what do I say about ParsecT...
16:05:22 <dons> mmm... coffee
16:05:31 <SyntaxNinja> dons: mine is almost gone :(
16:06:18 <xerox> Sorry for bothering with silly things like this.  But since #haskell-overflow is house of #haskell people, would it make sense to operate preemptive actions wrt Smerdyakov?  I just don't know.
16:06:28 <dons> I have a whole steaming pot here :)
16:07:05 <SamB> xerox: no, wait until he starts acting up
16:07:20 <xerox> Yessir.
16:07:31 <xerox> (I'm running most of the SoC thing there, grumble.)
16:07:32 <dons> xerox, I think haskell-overflow should have the same perms for people as #haskell, btw. otherwise people who are kicked just come back in and annoy us over there. keal did  that, iirc.
16:07:45 <xerox> dons: I do agree.
16:07:58 <franka> What does Smerdyakov do that is annoying?
16:08:31 <xerox> Riastradh is giving me quite a list :-(
16:08:35 <SamB> act all more-academic-than-thou
16:08:52 <dons> for a long time, months, he would trigger large arguments, and harass newbies, 
16:09:08 <SamB> that is what ##c is for
16:09:18 <xerox> dons: let me see again how does the ChanServ thing work, and I'll be adding you and the others.
16:09:30 <araujo> SamB, no, that's not also good in ##c :-P
16:09:53 * araujo knows  Smerdyakov from it
16:10:03 <SamB> well, some of them *need* harassing
16:10:13 <SamB> so they'll find a friendlier language
16:11:08 <araujo> haha
16:11:21 <SamB> anyway, people are used to long arguments in ##c ;-)
16:11:28 <mahogny> I bet so lol
16:12:03 <musasabi> ##c is a much less friendly place than #haskell, but it is a fun place to argue from time to time.
16:12:49 <mahogny> you need to be quite stubborn to use C. there's one reason :)
16:13:00 <dons> its important that we keep #haskell a friendly place, as its such a central meeting place for a large part of the Haskell world. It fosters a lot of cooperation between projects in Haskell, and we need that, being such a small community.
16:13:45 <mahogny> small. hm. what are you comparing with?
16:13:52 <dons> perl.
16:13:55 <RyanT5000> C++
16:13:58 <araujo> Well, you can easily ask why a pointer isn't being properly referenced, and ending up discussing about the II world war
16:13:58 <dons> python
16:14:01 <xerox> dons: agreed.
16:14:18 <mahogny> araujo, for good reasons ;)
16:14:38 <araujo> mahogny, ahah, what are you suggesting? :-]
16:14:44 <xerox> I like #haskell the way it is.
16:14:46 <mahogny> the hidden reason for WW2
16:14:47 <dons> the irc channel magnifies the effort of the community by keeping us all interacting. so we need to keep it useful for developing code.
16:14:54 <dons> as it is these days
16:15:00 <mahogny> araujo, unsafe dereferencing. there you go
16:15:00 * araujo likes #haskel like it is too
16:15:11 <araujo> mahogny, haha wow, you got the topics connected!
16:15:51 <eivuokko> Has anyone else got unapplicable patch when trying to darcs get http://darcs.haskell.org/alex ?
16:15:54 * mahogny need some sleep. later :)
16:16:04 <eivuokko> *unapplicable patch-error
16:16:05 <xerox> 'night
16:16:07 <araujo> night mahogny 
16:16:32 <dons> eivuokko: which darcs version?
16:16:43 <eivuokko> 1.0.4,1.0.5 and 1.0.6
16:17:13 <SamB> personally, #haskell-overflow strikes me as a much-less problematic place for Smerdy to be...
16:17:38 * xerox shackes head
16:18:03 <dons> eivuokko: hmm. haven't seen this. the nighly builds also check alex out of dacs each night. very strange
16:18:05 <xerox> I'm relying on it
16:18:30 <tony2> anyone know of a libcurl binding banging around somewhere?
16:18:34 <musasabi> Ban him if it becomes a problem? A lazy aproach could work with Haskell.
16:18:43 <musasabi> tony2: darcs uses curl I think.
16:19:27 <ihope> So how can I access the Windows API and all that stuff from Haskell?
16:19:59 <musasabi> FFI, there are some wrappers already for winapi I think.
16:20:00 <tony2> musasabi, yeah I thought that too, but it doesn't have a general binding. 
16:20:37 <eivuokko> dons, Are you sure it does?
16:20:44 <tony2> (libcurl I mean, not winapi)
16:20:55 <ihope> Haskell's supposed to be high-level, though! ;-)
16:21:44 <xerox> dons, musasabi, I've added you, who more should I add to the ACCESS list?
16:23:20 <dons> dcoutts: moving lines* and friends in Data.ByteString.Latin1 is very nice. It means Data.Char is no longer an import in Data.ByteString. Exactly the bounday we're looking for.
16:24:09 <musasabi> dons: did you kill the whitespace routines also?
16:24:29 <dons> yep. they need Char.isSpace or the C equivalent.
16:24:34 <dons> so they're in the Latin1 file now.
16:26:09 <xerox> shapr: you're in the ACCESS list too now.
16:33:33 <SyntaxNinja> anyone want to make a logo for haskell.org's summer of code?
16:34:09 * xerox points at Cale's Inkscape-fu
16:34:13 <xerox> (-;
16:34:26 <Cale> :)
16:34:30 <SamB> can Cale do a lambda on a grassy hillside?
16:34:40 <xerox> haha, nice one.
16:34:46 <SamB> on lovely sunshiney day?
16:34:59 <resiak> Lambdatubbies come to play?
16:35:09 <SamB> hmm, there should be an "a" in that sentance...
16:35:10 <xerox> That would be scary.
16:35:16 <SamB> no! no tubbies!
16:35:18 <SyntaxNinja> we have a project ideas link now: http://code.google.com/soc/haskell/about.html
16:35:34 <resiak> The lambda behind the grassy knoll?
16:36:28 <SamB> maybe a lampbda on a lawn-chair with a laptop ;-). can lambdas do that?
16:38:03 <vincenz> Cale: darcs work for ya?
16:42:32 <MarcWeber> What is the library Hsc ?
16:44:05 <shapr> xerox: thanks
16:44:55 <ihope> > 2*3*5*7*11*13*17*23*29*31*37*41*43*47-1
16:44:56 <lambdabot> 32362620136236389
16:45:15 <ihope> I think that's bigger than 47*47.
16:46:27 <petekaz> newbie monad question: a "monad" is just a type that is in instance of Monad?  E.g. List is considered a monad because there are functions defined for >>, >>=, return, and fail?  
16:47:09 <petekaz> This term "monad" seems to scare the hell out of me, but this doesn't seem so scary.
16:47:23 <Cale> petekaz: basically
16:47:34 <Philippa> petekaz: all that plus it shouldn't be in Monad without adhering to the "monad laws", which're a few equations it should satisfy
16:47:36 <Cale> petekaz: there are some rules that those functions have to satisfy as well
16:47:41 <MarcWeber> petekaz: But you also have syntactic support for those methods (do notation) ...
16:47:43 <Philippa> (but you can say the same for things in Num too)
16:48:02 <SamB> or at least following the spirit of the monad laws
16:48:17 <Philippa> you have to be pretty careful about that one
16:48:20 <petekaz> so the term "action" that is used all the time with monads (in my limited reading thus far) does not really apply to List?
16:48:41 <MarcWeber> Philippa: if you want to learn more google for "all about monads" or the monad introduction on the wiki..
16:49:07 <MarcWeber> http://www.haskell.org/hawiki/MonadsAsContainers
16:49:44 <Philippa> MarcWeber: wrong person :-)
16:49:55 <Philippa> petekaz: yeah, more generally you'd see "computation"
16:49:59 <dons> think of 'monad" as "warm fuzzy thing" :)
16:50:14 <Philippa> action is fairly IO-specific, because it tends to mean a real action that sooner or later you can observe physical effects from
16:50:15 <MarcWeber> ohll %s/Philippa/petekaz ;)
16:50:18 <petekaz> I just read that in the "wearing the hair shirt"
16:50:43 <MarcWeber> So nobody knows what Hsc library is?
16:51:03 <petekaz> what would be a simple example using >>= for a List.
16:51:36 <mauke> > [1,2,3] >>= join replicate
16:51:37 <Cale> > [1..5] >>= \x -> [x, 10 * x]
16:51:37 <lambdabot> [1,2,2,3,3,3]
16:51:38 <lambdabot> [1,10,2,20,3,30,4,40,5,50]
16:51:54 <petekaz> thanks.
16:52:01 <Cale> mauke's example uses join from an entirely different monad
16:52:23 <Cale> > [1..5] >>= \x -> replicate x x
16:52:24 <lambdabot> [1,2,2,3,3,3,4,4,4,4,5,5,5,5,5]
16:52:24 <mauke> yeah, it's actually >>= \x -> replicate x x
16:52:50 * RyanT5000 cries
16:52:51 <petekaz> Cale: I was looking at yours anyways as I don't know about 'join' or 'replicate' yet :)
16:53:06 <RyanT5000> there are like 10 steps to render a font onto an OpenGL texture
16:53:13 <RyanT5000> and i don't understand any of them
16:53:24 <RyanT5000> and none of them do anything on their own
16:54:30 <mauke> in this case, join f = \x -> f x x
16:55:18 <Cale> petekaz: you should read my tutorial
16:55:26 <Cale> @oldwiki MonadsAsContainers
16:55:27 <lambdabot> http://www.haskell.org/hawiki/MonadsAsContainers
16:56:15 <Cale> (unless you're already there, I noticed that some others have mentioned it :)
16:56:33 <SamB> Parsec strikes me as something where "action" might seem appropriate, even though it is pure...
16:56:50 <petekaz> Cale: will do! Thanks.
17:01:19 <Cale> Well, here's a start on the request... http://cale.yi.org/autoshare/summerlambda.png
17:01:49 <xerox> Cale rocks.
17:01:53 <Spark> not enough murder in that pic
17:02:11 <Cale> heh
17:02:18 <xerox> Cale: it will be a track logo
17:02:19 <Spark> i think a gibbet with a skeleton in it hanging from the top of the lambda would be good
17:02:30 <xerox> Cale: more versions are okay anyway, good work
17:02:47 <Cale> track logo?
17:02:51 <shapr> dons: Oh, I had a crazy idea... You know the 'unsupervised learning of natural languages' paper?
17:03:30 <xerox> *trac
17:04:14 <shapr> dons: The ADIOS algorithm in that paper automatically builds a grammar for a language. Wouldn't that be the perfect way to build syntax hightlighters? You'd just feed it a corpus and lightly frob the results.
17:04:16 <dons> yeah.?
17:04:24 <dons> huh.
17:04:35 <SamB> how is something supposed to learn a natural language unsupervised -- who is going to teach the language?
17:05:02 <nattfodd> the compiler sources?
17:05:12 <dons> luckily we already have the grammars for languages. I'd like to see a syntax highlighter generater , kind of like a backend to happy.
17:05:19 <shapr> SamB: http://www3.isrl.uiuc.edu/~junwang4/langev/localcopy/pdf/solan05languageLearningPNAS.pdf
17:05:47 <nattfodd> dons: some friends of mine tried to have that 
17:05:49 <nattfodd> in ocaml
17:05:56 <dons> yeah, what kind of results?
17:05:59 <nattfodd> let me see if I can find it
17:06:17 <nattfodd> I don't know how it went
17:06:25 <dons> (I mean , Alex already generates most of a syn hl from the lexer spec)
17:06:37 <shapr> It would be very cool if an editor could generate a new programming mode from a corpus alone.
17:06:56 <nattfodd> http://home.gna.org/bed/
17:06:57 <dons> shapr, yes. true. for all those languages that don't have gramms
17:07:08 <nattfodd> but it looks like it didn't even have a proper release
17:07:16 <dons> nice idea!
17:07:38 <ChilliX> shapr: There are tools to generate a DTD from XML example docs.  That's about the same problem.
17:08:04 <metaperl> is there anything which does HTML syntax highlighting of Haskell code?
17:08:11 <shapr> metaperl: hscolour works nicely.
17:08:16 <metaperl> ah
17:08:33 <shapr> g'day Pseudonym 
17:08:34 <SamB> shapr: trang can generate rng specs for an XML format from a corpus ;-)
17:08:52 <dons> metaperl, yeah hscolour. also vim does it.
17:08:55 <Pseudonym> G'day.
17:08:56 <ihope> From a corpse? Sounds scary.
17:08:57 <ihope> :-P
17:09:08 <metaperl> o i see
17:09:20 <SamB> well, if one or more XML files given as commandline arguments are "a corpus", anyways
17:09:35 <SamB> ooh, like the logo, Cale ;-)
17:10:15 <shapr> ChilliX: Xml to dtd seems intuitively simpler to me. (where intuitively means "I really have no clue, and am wildly guessing.")
17:11:18 <ChilliX> I guess there are many DTDs where it is simpler, but I am not sure it is simpler in general
17:11:40 <ChilliX> But I don't know how well these tools do on complex DTDs
17:11:46 <ChilliX> maybe just work for the simpleer ones
17:11:57 <shapr> XML has to be a tree though, and programming and spoken languages have no limitations. That sounds to me like XML would be simpler.
17:12:07 <ChilliX> On the other hand, for syntax hl, you don't need to get the grammar, just the fairly regular parts
17:12:36 <shapr> metaperl: You can use htmlize-buffer in emacs.
17:12:48 <metaperl> oh interesting. ok
17:12:49 <ChilliX> Any computer language is a tree after parsing.
17:12:59 <shapr> Spoken languages too?
17:13:17 <ChilliX> shapr: spoken langauge is surely harder, but then I didn't want to syntax hl that ;)
17:13:18 <monochrom> I can't think of a spoken language not a tree.
17:13:34 <ChilliX> (yeah, still a tree, but more context sensitive stuff)
17:13:35 <SamB> ChilliX: hmm, would be interesting though
17:13:39 <metaperl> everything in computer science is a tree if you want to be minimalist right? isn't that the most flexible and general data structure?
17:13:40 <ChilliX> (million times more)
17:13:46 <monochrom> (How do you make a syntactically cyclic sentence?)
17:13:47 <SamB> I mean, to syntax highlight...
17:13:54 <SamB> monochrom: you can't.
17:13:57 <ChilliX> metaperl: except when it's a graph ;)
17:13:58 <metaperl> oh cycles kill that theory
17:14:00 <metaperl> yes
17:14:03 <SamB> without metaprogramming
17:14:24 * palomer is Functor crazy!
17:14:27 <Pseudonym> A DAG isn't a tree, surely.
17:14:34 <Pseudonym> Nor is a biconnected graph.
17:14:34 <ChilliX> Computer languages are designed to be trees
17:14:40 <SamB> you sure?
17:14:49 <SamB> well, I mean you sure a DAG isn't a tree?
17:14:49 <palomer> monkeys are designed to swing off trees
17:14:55 <Pseudonym> Oh, that's right.  We're talking about the SECOND rule of computer science.
17:14:55 <palomer> a DAG isn't a tree
17:15:00 <monochrom> code monkeys!
17:15:01 <Pseudonym> Rule 1: Everything is a tree.
17:15:12 <Pseudonym> Rule 2: If it's not a tree, add a level of indirection.  Now it is.
17:15:19 <metaperl> why is there no website for Haskell pastes that HTML colorizes them?
17:15:32 <shapr> metaperl: Haskell programmers are lazy.
17:15:34 <SamB> @paste
17:15:35 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
17:15:41 <SamB> that at least used to
17:15:43 <metaperl> Perl programmers are lazy
17:15:51 <metaperl> SamB: but does that colorize it?
17:16:01 <shapr> Actually, I kept meaning to integrate hscolour into a moinmoin plugin.
17:16:01 <SamB> I answered before you asked
17:16:06 <int80_h> Hey I have an idea for a summer of code project and I wanted to run it by the room. I wanted to develop a Mud Engine. Does that strike anyone's fancy?
17:16:10 <Pseudonym> metaperl: If that were true, they wouldn't "use strict".
17:16:14 <SamB> didn't it?
17:16:16 <ChilliX> shapr: That's be great!!
17:16:20 <int80_h> I have an educational justification for it
17:16:23 * SamB could be confused
17:16:37 <shapr> Happily, Ashley Yakely created a new mediawiki...
17:16:42 <MarcWeber> dcoutts: Are you still here? I get a compilation error.
17:16:45 <Pseudonym> Goodness, Haskell _and_ Perl humour in one sentence.  No wonder it wasn't funny.
17:16:48 <int80_h> The scripting language would be haskell itself, thereby being a promotional tool for haskell.
17:16:52 <SamB> Pseudonym: they are too lazy to be strict themselves, so they make perl do it
17:16:56 <shapr> Pseudonym: ouch!
17:16:59 <ChilliX> int80_h: 'd be cool
17:17:18 <SamB> a MUD engine?
17:17:22 <MarcWeber> dcoutts: glib/System/Glib/hsgclosure.c: 140 CAP isn't defined 
17:17:23 <SamB> like a MFP?
17:17:26 <int80_h> excellent. I need a mentor. Should I bring this to the mailing list to see if I get any offers?
17:17:33 <SamB> (Mud Functionally Programmed)
17:17:34 <Pseudonym> Perl 6 probably has a "use funny", for Damian Conway's personal purposes.
17:17:39 <int80_h> yeah an engine used to write MUDS
17:17:40 <ChilliX> int80_h: one of the MOOs got a lisp as the langauge, doesn't it?
17:17:56 <int80_h> sdf's MOO uses LISP yeah
17:17:59 <metaperl> http://rafb.net/paste/results/lY7HID51.html   --- I have a simple do-notation question here I would like some help with please
17:18:41 <Pseudonym> metaperl, what's the type of "parent"?
17:18:41 <int80_h> even if it doesn't get accepted, I'd still like to go forward with this.
17:18:46 <metaperl> i'm guess that a concatMap is complementary for that call to parent p
17:18:47 <Cale> xerox: should there be a title next to it?
17:19:08 <xerox> Cale: it should be part of the logo
17:19:23 <Cale> xerox: what should it say?
17:19:25 <monochrom> Imagine do { p <- parent s; q <- parent p; return q }
17:19:35 <metaperl> Pseudonym: same as grandparent, per this: http://www.nomaware.com/monads/examples/exercise3.hs
17:19:50 <xerox> Cale: Haskell.org Summer of Code ?
17:19:56 <metaperl> monochrom: parent p can't work
17:20:00 <metaperl> s is a single sheep
17:20:04 <metaperl> p is [Sheep]
17:20:10 <metaperl> parent requires a single sheep as input
17:20:16 <Pseudonym> OK.
17:20:21 <Pseudonym> So you're wondering how this works?
17:20:23 <Cale> metaperl: basically, p gets the value of each of the parents of s in turn, and then the parents of p are returned, and the results all merged into a single list
17:20:26 <monochrom> I'll let you think more.
17:20:32 <Cale> so what you'll have is the list of grandparents
17:20:33 <Pseudonym> If it helps, try this:
17:20:36 <metaperl> yes, that is what I thought, via concatMap
17:20:39 <Pseudonym> grandparent s = do p <- parent s
17:20:43 <Cale> p is not [Sheep]
17:20:43 <monochrom> [ q | p <- parent s; q <- parent p ]
17:20:50 <metaperl> but the tutorial did not explain that very well
17:20:51 <Pseudonym>                    q <- parent p
17:20:56 <Cale> It's just a single Sheep at any one time
17:20:58 <Pseudonym>                    return q
17:21:13 <metaperl> it seems weird that one call to parent takes s (a single sheep) and the next call takes [Sheep]
17:21:20 <Pseudonym> Yes, monochrom's version is also applicable.
17:21:22 <metaperl> is that because it is the last expression in the do-notation?
17:21:23 <Cale> metaperl: it doesn't
17:21:29 <Cale> metaperl: p :: Sheep
17:21:33 <Pseudonym> metaperl, you're confusing <- with let { = }
17:21:46 <Pseudonym> The <- symbol means "draws from", not "equals".
17:22:10 <Pseudonym> It's also how you get an "a" from "IO a".
17:22:18 <Cale> For each p, a parent of s, it computes the parents of p, and joins the results.
17:22:19 <metaperl> ah!
17:22:25 <metaperl> I see
17:22:41 <RyanT5000> [x] <- someFunc would fail if someFunc returned [] right?
17:22:43 <metaperl> Cale: does your monad tutorial explain <- better?
17:22:47 <RyanT5000> i.e.: cause an exception
17:22:49 <monochrom> Right RyanT5000 
17:22:54 <samc> yo shapr
17:23:03 <RyanT5000> thanks monochrom
17:23:15 <shapr> y0 samc
17:23:29 <monochrom> I think Cale's tutorial does.
17:23:32 <Pseudonym> This, BTW, is why do-notation is not imperative programming.
17:23:35 <Pseudonym> "<-"
17:23:37 <shapr> How're the kiwis doing?
17:23:38 <Pseudonym>  is not assignment
17:23:47 <samc> I just went to here http://harmonia.cs.berkeley.edu/harmonia/publications/harmonia-pubs.html and noticed the first pub, haven't read it or nuffin
17:24:02 <shapr> ooh!
17:24:23 <metaperl> do-notation is like streams programming
17:24:36 <Pseudonym> It's like a lot of things.
17:24:41 <Pseudonym> But it only is what it is.
17:25:03 <shapr> samc: Thanks, I'll check this out when I get time.
17:25:05 <Pseudonym> I'll leave you with that Taoist moment.
17:25:17 <monochrom> I refuse all analogies.  Except "do-notation is like list comprehension".  Then again that is not an analogy, that is a provable theorem.
17:25:17 <Cale> http://cale.yi.org/autoshare/summerlambda.png
17:25:32 <shapr> Has anyone read Yong Luo's 'A Type Theory with Partially Defined Functions and Pattern Matching' ?
17:27:17 <Pseudonym> Oh, I have a question for Haskell prime people.
17:27:38 <Pseudonym> Do I read it right that you guys are trying to choose BETWEEN functional dependencies and associated types?
17:27:41 <shapr> This paper looks sort of like full on 'incremental typing'.
17:27:44 <Pseudonym> If so, why not both?
17:27:55 <Pseudonym> Is there some theoretical reason that I'm not getting?
17:28:04 <shapr> Cale: Have you seen http://www.logic-alphabet.net/ ? Is it crackpot or nifty?
17:28:55 <ChilliX> Pseudonym: because they solve the same problem
17:29:10 <Pseudonym> Except that they don't.
17:29:30 <Pseudonym> They solve the same technical problem, but they don't solve the same "programmer's intention" problem.
17:30:01 <ChilliX> You will have to substantiate that.
17:30:29 <monochrom> http://www.cs.utoronto.ca/~trebla/ForwardSearch.lhs  I am proud of this list-as-monad code.
17:31:09 <Pseudonym> First off, associated types aren't the right way to express a functional dependency that goes the "wrong way".
17:31:15 <dons> musasabi: thanks for the patch.
17:31:29 <Pseudonym> Example: class MonadRef m r | r -> m where { ... }
17:31:31 <ChilliX> Wrong way?  Do you have an example?
17:31:36 <Pseudonym> Where m is the monad type and r is the reference type.
17:31:51 <Pseudonym> That's useful if a monad has more than one meaningful reference type.
17:32:01 <Pseudonym> e.g. IORef and MVar
17:32:06 <Cale> shapr: interesting -- not sure that it will catch on, but it's a neat idea
17:32:14 <samc> @seen boegel
17:32:15 <lambdabot> I saw boegel leaving #haskell-blah and #haskell 10 hours, 22 minutes and 39 seconds ago, and .
17:32:29 <sjanssen> and . . .
17:32:31 <samc> "and ."?
17:32:40 <Pseudonym> So ATs aren't the "right way" to express some FD problems.
17:32:41 <ChilliX> Pseudonym: Why not use an AT in this example?
17:32:47 <Pseudonym> You want to do this?
17:32:51 <Pseudonym> class MonadRef r where
17:32:59 <musasabi> dons: np
17:33:01 <Pseudonym>     type MonadType
17:33:02 <Pseudonym> ?
17:33:24 <ChilliX> Pseudonym: Well, that's the idea behind the FD program you gave.
17:33:27 <ChilliX> So, why not?
17:33:48 <ChilliX> The monad depends on the ref
17:33:52 <Cale> shapr: however, most of the time, "and" and "or" together with "not" are enough to get things across quickly enough, their main advantage being that we use similar terms in everyday life, so they're familiar.
17:34:14 <Pseudonym> It's not the right approach because the Monad typeclass system is all based on m being a member of the typeclass.
17:34:37 <Pseudonym> The class constraint is on m,
17:34:58 <Pseudonym> That's the intention of the programmer.
17:35:20 <Pseudonym> And all of the MonadRef operations are primarily on m, not r.
17:35:24 <ChilliX> Well it is being based on the monad being the determining parameter.  But you just chucked that out with your FD definition.
17:35:38 <Pseudonym> In addition, it's unclear how to express a functional dependency like | a -> b, b -> a
17:35:49 <ChilliX> Pseudonym: Ah that's easy
17:36:27 <ChilliX> (just a sec need to generate a static HTML page from our wiki)
17:36:52 <Pseudonym> See, the thing here is that I, as a programmer, should not need to put my typeclass system into some relational database-like normal form.
17:37:18 <Pseudonym> Sure, personnel ID might be the primary key, but most of the time I want to work with person names.
17:37:43 <monochrom> Ha! "Refactoring" gets a new meaning!  "I refactored my Linear Algebra library to the BCNF!"
17:37:47 <Pseudonym> Right.
17:38:05 <SamB> shapr: looks silly to me
17:38:12 <Pseudonym> And this kind of normal form thing is a global property, not modular.
17:38:14 <monochrom> It might not be bad.  We finally give some solid footing to refactoring.
17:39:01 <Pseudonym> Anyway, that's why I object to not having FDs.
17:39:20 <Pseudonym> And the reason that I object to not having ATs is that it would break encapsulation.
17:39:42 <Pseudonym> Adding an associated type to an FD system requires rewriting all type signatures.
17:40:14 <int80_h> okay I just sent mail to Haskell-Cafe
17:40:22 * int80_h is nervous
17:40:29 <int80_h> about my proposal
17:40:50 <ChilliX> I have got a *simple* scheme to translate *any* FD program (that obeys the weak coverage condition) into an AT program: http://www.cse.unsw.edu.au/~chak/haskell/BetterAssociatedTypes_2fClassEqualities.html
17:41:15 <ChilliX> So that's it for the AT cannot do XYZ arguments.
17:41:27 <ChilliX> Actually, for you example
17:41:39 <Pseudonym> For the record, I don't claim that "X can't do Y'.
17:41:40 <SamB> ChilliX: so? we aren't compilers!
17:41:42 <ChilliX> You can write it like this, if that matches your intuitin better
17:41:58 <Pseudonym> I claim that X can't do Y without preserving programmer intention.
17:42:04 <SamB> ChilliX: the compiler should be responsible for converting our nice programs into whatever nasty mess it needs...
17:42:06 * int80_h thought he was a compiler but got treatment.
17:42:20 * shapr reboots int80_h 
17:42:35 * int80_h giggles
17:42:40 <wchogg> shapr:  You fool, he'll kernel panic!
17:42:42 <ChilliX> class (m = M r) => MonadRef m r where
17:42:48 <ChilliX>   type M r
17:42:58 <RyanT5000> what is int80 anyway? it's not assigned is it?
17:43:02 <ChilliX> SamB: You are on the wrong track here.
17:43:05 <Pseudonym> Actually, that's a good point.  If it's syntactic sugar, why not let the compiler desugar?
17:43:06 <RyanT5000> or is it assigned to the APIC or something
17:43:11 <ChilliX> Nobody wants yoy to hand translate your programs
17:43:11 * int80_h panics only at the mention of linux.
17:43:27 <SamB> ChilliX: I don't want your nasty preprocessor either
17:43:32 <jcreigh> int80_h: Interrupt 0x80 is the jump to kernelspace in many UNIXes, right?
17:43:32 <SamB> it will be horribly slow
17:43:43 <Pseudonym> Oh, for the record, I do agree that equality constraints will make FDs better.
17:43:48 <int80_h> int 80h is the x86 interupt that says "make it so" to whatever instruction you just gave.
17:43:48 <ChilliX> However, it is a standard technique (*the* standard technique, actually) of comparing te expressiveness of language features to show how well one can be translated into the other
17:43:54 <monochrom> This seems to turn typeclass into modules in ML.
17:43:59 <Pseudonym> "Well" is subjective.
17:44:03 <ChilliX> SamB: As I said, wrong track.
17:44:08 <int80_h> I thought it was specific to the x86 hardware. I could be wrong
17:44:16 <SamB> ChilliX: well, you can write your programs in ASM if you like
17:44:19 <int80_h> I picked the name years ago when I was into assembler
17:44:28 <RyanT5000> assembler is still awesome
17:44:33 <RyanT5000> you get to pick your own registers
17:44:33 <Pseudonym> SamB: That's a reductio ad absurdum argument, sorry.
17:44:33 * shapr does int21 instead
17:44:50 <SamB> Pseudonym: wait, that is a fallacy since when?
17:44:51 <int80_h> heck yeah it is :) I'm finding my knowledge of C and assembler to be useful for my interest in Haskell.
17:45:14 <RyanT5000> yeah i don't see myself choosing to write in anything but haskell, c, or asm any time soon
17:45:26 <Pseudonym> In programming language circles saying that "you can do it because your language is Turing complete" is a fallacy.
17:45:27 <RyanT5000> maybe C++
17:45:31 <int80_h> we don't need nothing else nohow ;)
17:45:38 <monochrom> asm is fast and easy
17:45:50 <int80_h> easy!?!
17:45:51 <jcreigh> monochrom: asm is fast...
17:46:01 <ChilliX> monochrom: Type classes as modules in ML is solved, too: http://www.cse.unsw.edu.au/~chak/papers/DHCK06.html
17:46:11 <RyanT5000> easy to learn, maybe
17:46:12 <SamB> if you can come up with a *local* transformation that translates one feature into another, that is *one* thing.
17:46:16 <RyanT5000> hard to do anything of value in
17:46:17 <Pseudonym> Because the point of programming languages is to allow programming to be expressive, not for it to be possible.
17:46:18 <int80_h> I want whatever monochrom has been smoking.
17:46:23 <shapr> samc: Argh, it uses Spoken Java!
17:46:24 <SamB> if it is a *global* transformation, that is quite another.
17:46:49 <Pseudonym> Anyway.
17:46:55 <ChilliX> SamB: Read this? http://www.ccs.neu.edu/scheme/pubs/scp91-felleisen.ps.gz
17:46:58 <RyanT5000> Pseudonym is totally right
17:47:01 <Pseudonym> Yes, I agree about the "global transformation" thing.
17:47:13 <samc> shapr :(
17:47:14 <Pseudonym> If it breaks encapsulation, I don't want it.
17:47:19 * shapr is going to write Spoken Unlambda in protest...
17:47:22 <SamB> useful for compilers, not so much for programming languages
17:47:23 <Pseudonym> Or if it breaks separate compilation.
17:47:23 <monochrom> I was quoting someone else.
17:47:37 <shapr> oj, nearly 3am
17:47:40 * shapr &
17:47:48 <ChilliX> Pseudonym: DI you see this?
17:47:48 <Pseudonym> In general, any local change which causes global refactoring is a risk.
17:47:51 <ChilliX> class (m = M r) => MonadRef m r where
17:47:54 <ChilliX>   type M r
17:48:02 <Pseudonym> Yes, I saw that.
17:48:09 <ChilliX> We can have our cake and eat it, too ;)
17:48:09 <SamB> and it looks NASTY.
17:48:22 <SamB> well. it looks handy.
17:48:31 <Pseudonym> It does look handy for some purposes.
17:48:38 <SamB> the feature does, I mean
17:48:48 <SamB> but I don't think that is a good thing to use it for...
17:48:52 <Pseudonym> My main problem is that it's the same problem as you have with reducing relational schemas to normal form.
17:49:04 <Pseudonym> You're introducing symbols with no semantic content.
17:49:06 <ChilliX> Pseudonym: Well, it means that with Ats you can chose whether you make MonadRef one or two parameter, with FDs you have no choice
17:49:10 <Pseudonym> Their entire purpose is to be primary keys.
17:49:22 <Pseudonym> Or keys in general, I suppose.
17:49:24 <ChilliX> As a language designer, I'd rather use the feature that gives leaves the choice to the programmer
17:49:39 <musasabi> grah, on goes the fps discussion.
17:49:46 <musasabi> Am I being unreasonable there?
17:49:46 <SamB> ChilliX: okay, now you are speaking my language. but I would rather have *both*
17:49:48 <monochrom> fps = ?
17:49:53 <musasabi> fastpackedstring
17:49:54 <int80_h> I think the programmer should be kept in chains. Unless I am the programmer in question. In which case I want freedom.
17:49:56 <Pseudonym> Surely providing both FDs and ATs leaves the choice to the programmer?
17:50:10 <Pseudonym> And equality constraints, of course.
17:50:27 <SamB> yes, those could be very handy for a collections library...
17:50:29 <ChilliX> Pseudonym: Agreed, but it is bad language design IMHO as the overlap is too big
17:50:42 <Pseudonym> I disagree strongly with that.
17:50:53 <SamB> ChilliX: the overlap isn't too big. its just existant!
17:50:54 <ChilliX> Actually, to come somewhat you way,
17:51:03 <Cale> xerox: http://cale.yi.org/autoshare/summerlambda-black.png
17:51:10 <int80_h> the only solution is pistols at ten paces.
17:51:12 <ChilliX> since I got that translation, I am less worried about having both
17:51:12 <Pseudonym> I come from the school of thought that declarations are documentation.
17:51:24 <ChilliX> because we can desugar FDs into ATs
17:51:26 <Pseudonym> Right.
17:51:31 <Pseudonym> See, I'd be happy with that.
17:51:32 <Cale> (probably a little larger there than you'd actually want it)
17:51:35 <ChilliX> (I don't think it's possible the other way around btw)
17:51:37 <SamB> ChilliX: thats the spirit!
17:51:41 <Pseudonym> Much like the overlap between records and traditional ADTs.
17:52:00 <xerox> Cale: please refer to SyntaxNinja atm
17:52:06 <xerox> (nice!!!)
17:52:48 <ChilliX> One reason why I am reluctant to have both is that I suspect that you guys cling to FDs just because of familiarity.
17:52:52 <Pseudonym> The thing is, choosing to use a Haskell record instead of a positional data constructor shows programmer intention.
17:53:04 <Pseudonym> No, I disagree.
17:53:15 <ChilliX> Pseudonym: I expected, you would disagree.
17:53:22 <SyntaxNinja> Cale: I added one of the ones someone sent me to the wiki already. email me the final one if you want me to add it.
17:53:34 <ChilliX> Pseudonym: And it'll be hard to settle that question without having both for a year and see what people end up using.
17:53:50 <Pseudonym> I think people would use both, for different purposes.
17:53:55 <Philippa> I think ATs have one extra interesting thing going for them...
17:53:57 <Pseudonym> Well, I would, anyway.
17:54:00 <SamB> I think you will find they will use both ;-)
17:54:08 <Philippa> which is mostly about what happens when you do a lot of thinking about both type classes and modules
17:54:09 <Pseudonym> And I think that's their value.
17:54:14 <Philippa> unfortunately that's /so/ not a haskell' issue
17:54:42 <Philippa> indeed it's the sort of thing that may cause the need for another language that's not haskell so that it can break backwards compatability
17:54:58 <dons> fun deps don't get used  for much beyond C m s | m -> s, why is that I wonder?
17:55:15 <ChilliX> Philippa: seen this? http://www.cse.unsw.edu.au/~chak/papers/DHCK06.html
17:55:33 <Philippa> ChilliX: I have. About a month after I'd worked out (but not coded) my own approach to the subject
17:55:42 <Philippa> (but it'd likely been up for longer than that)
17:55:56 * Philippa whoises
17:56:47 <Cale> xerox: let me know if you want any changes, re-renderings, etc.
17:59:06 <Pseudonym> dons, I suspect that a lot of programs don't require nonstandard types of abstraction.
17:59:16 <xerox> Cale: last version?
17:59:22 <xerox> latest, even
17:59:24 <Pseudonym> That might be because not everyone has gotten used to it yet.
18:00:01 <dons> but they've been in ghc for, what, 7 years? :)
18:00:43 <RyanT5000> how much effort do classes really save?
18:01:20 <RyanT5000> i mean, what if you took each class C a where f :: a -> String
18:01:23 <RyanT5000> and replaced it with
18:01:36 <RyanT5000> data C a = C { f :: a -> String }
18:01:45 <RyanT5000> then anything that would normally read
18:01:51 <dons> @type sort
18:01:52 <lambdabot> forall a. (Ord a) => [a] -> [a]
18:01:53 <Pseudonym> First off, you can't express that without higher-ranked types.
18:01:54 <dons> @type sortBy
18:01:55 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
18:02:05 <Pseudonym> In general.
18:02:07 <RyanT5000> g :: C a => a -> whatever
18:02:12 <RyanT5000> becomes
18:02:15 <Pseudonym> So historically, typeclasses have been more powerful.
18:02:20 <RyanT5000> g :: C a -> a -> whatever
18:02:37 <Pseudonym> Secondly, expressing inherited typeclasses has problems.
18:02:45 <Cale> xerox: http://cale.yi.org/autoshare/summerlambda-black.png
18:02:56 <Pseudonym> You're turning interface inheritance into implementation inheritance.
18:03:03 <Pseudonym> Which has problems when you allow multiple inheritance.
18:03:09 <RyanT5000> hm
18:03:14 <monochrom> typeclasses avail operator/function overloading
18:03:24 <xerox> Cale: may you scale it to be a little smaller?
18:03:36 <RyanT5000> i kind of dislike how classes are essentially global variables
18:03:44 <RyanT5000> i have a rather strong disdain for global variables
18:03:51 <RyanT5000> e.g.:
18:03:55 <monochrom> You're quite right.
18:03:58 <RyanT5000> why not have Prelude be a type
18:04:06 <RyanT5000> main :: Prelude -> IO ()
18:04:11 <Pseudonym> Ryan, you can have your cake and eat it too.
18:04:26 <Pseudonym> You can express precisely what you want using traits typeclasses.
18:04:45 <RyanT5000> hm
18:04:48 <Pseudonym> data StdPrelude = StdPrelude
18:04:54 <Pseudonym> class Prelude p where
18:04:57 <Pseudonym>     {- .. -}
18:05:05 <RyanT5000> interesting
18:05:06 <Pseudonym> instance Prelude StdPrelude where
18:05:09 <Pseudonym>     {- .. -}
18:05:15 <Pseudonym> main :: (Prelude p) => p -> IO ()
18:05:34 <Pseudonym> What you want here is commonplace in C++.
18:05:46 <RyanT5000> structs full of function pointers?
18:05:53 <Pseudonym> template <typename CT, class Traits = char_traits<CT> >
18:05:57 <Pseudonym> class basic_string { ... };
18:05:59 <RyanT5000> ah
18:06:14 <RyanT5000> yeah i've done that way more than i'd like
18:06:42 <RyanT5000> that's why i'd rather data Prelude = Prelude { ... }
18:07:09 <RyanT5000> and in actual fact i'd rather if the record labels were nonglobal
18:07:16 <RyanT5000> but i'm not exactly sure what i mean by that
18:07:54 <monochrom> You mean you're speaking against the RIAA.  You will be sued for intellectual rights infringement shortly (for no reason).
18:08:06 <Pseudonym> I know precisely what you mean by that, and most Haskellers agree with you.
18:08:18 <Pseudonym> You should be able to use the same record label for different records.
18:08:35 <Pseudonym> Precisely how to accomplish that is still an open question.
18:09:09 <RyanT5000> what if it were context-sensitive
18:09:18 <RyanT5000> and they didn't automatically create accessor functions
18:09:25 <RyanT5000> i.e.: they were used only for patten-matching
18:09:25 <Pseudonym> The trouble is that Haskell avoids ad hoc overloading.
18:09:38 <Pseudonym> And reusing record labels looks too much like ad hoc overloading.
18:09:47 <Pseudonym> There should be a way to make it less ad hoc.
18:09:47 <RyanT5000> yeah, that's not what i mean
18:09:58 <RyanT5000> if you took out the automatically-generated functions
18:10:15 <RyanT5000> and made it so that MyRecord { introduced a scope that contained MyRecord's field labels
18:10:24 <RyanT5000> voila
18:10:26 <RyanT5000> i think that would work
18:10:44 <RyanT5000> of course not having accessors is a pain
18:10:50 <RyanT5000> but i think that could be solved independently
18:11:16 <Pseudonym> That's actually a general problem with Haskell.
18:11:19 <Pseudonym> Or is it a strength?
18:11:23 <Pseudonym> We're never sure.
18:11:29 <RyanT5000> what is?
18:11:35 <Pseudonym> But Haskell doesn't have a good concept of namespaces.
18:11:44 <RyanT5000> ah yeah
18:11:56 <Pseudonym> Variable scopes, yes.  Symbol namespaces, no.
18:12:06 <SamB> namespaces?
18:12:17 <SamB> explain!
18:12:19 <Pseudonym> SamB: In Haskell, namespace == module.
18:12:27 <SamB> well, exdplain a good concept
18:12:29 <Pseudonym> But even that isn't a hard and fast rule.
18:12:40 <SamB> s/exdplain/explain/
18:12:48 <Pseudonym> For a start, namespaces should be nestable.
18:13:16 <Pseudonym> In addition, it should be possible to control _precisely_ what is in a namespace and what isn't.
18:13:26 <Pseudonym> Haskell has neither.
18:13:41 <Pseudonym> Nested modules are a start, but as Ryan alludes to, a record should be a sub-namespace.
18:13:47 <Pseudonym> So that the record fields don't leak.
18:13:51 <RyanT5000> yeah
18:13:51 <SamB> yes!
18:13:54 <Pseudonym> And hence can be reused.
18:13:54 <SamB> this is true.
18:14:03 <SamB> I agree muchly.
18:14:09 <xerox> Puff, pant.
18:14:11 <SamB> but we need to figure out how that can work.
18:14:14 <xerox> I've got them all on the trac!
18:14:24 <Pseudonym> One of my common complaints is also that you can't control what typeclass instances get exported from a module.
18:14:27 <xerox> http://hackage.haskell.org/trac/summer-of-code/
18:14:30 <SamB> C has this thing called a dot that it uses
18:14:37 <Pseudonym> C++ has :: as well.
18:14:51 <SamB> additionally, how do you make it higher-order somehow?
18:15:01 <Pseudonym> Now to be fair, Haskell has a good reason for doing things the way it does.
18:15:21 <SamB> I guess I sorta like the Extensible Records idea...
18:15:26 <Pseudonym> Haskell discourages the use of "symbols", because almost everything is a variable.
18:15:44 <xerox> Pseudonym: did you poke at the Haskell.org Project Ideas page for this year Google Summer of Code programme yet?
18:15:47 <Pseudonym> Functions in Haskell aren't like function members in C++.
18:16:01 <xerox> Pseudonym: we've got Haskell.org as mentoring organization this year :-)
18:16:04 <Pseudonym> Because functions in Haskell are just variable names at the module level.
18:16:06 <Pseudonym> Oh, cool!
18:16:11 * xerox sweats
18:16:15 <Pseudonym> No, I haven't looked yet.
18:16:29 <int80_h> oh do ideas have to be limited to what is on the list?
18:16:35 <xerox> int80_h: no!
18:16:35 <Philippa> no, they don't
18:16:42 <xerox> I should add notes on the startpage.
18:16:45 <xerox> Doing it now.
18:16:46 <Philippa> 'sjust that ones on the list cause the mentors less work :-)
18:16:50 <SamB> hmm, somebody needs to update the TOPIC
18:17:09 <RyanT5000> has anyone uses SDL.surfaceGetPixels?
18:17:09 <Pseudonym> Oh, I know someone who is working on concurrent B-trees in Haskell.
18:17:16 <RyanT5000> i am getting nothing but 0's
18:17:20 * Pseudonym should let Einar know
18:17:31 --- topic: set to '["Haskell.org SoC projects","http://hackage.haskell.org/trac/summer-of-code/","Submit a paper to the Haskell Workshop:", "http://haskell.org/haskell-workshop/2006", "Haskell is still the language of choice for discriminating hackers", "logs:","http://tunes.org/~nef/logs/haskell/", "http://www.haskell.org/learning.html", "We put the Funk in Funktion","Vote on a European #haskell get-together: http://snappoll.com/poll/84228.php"]' by xerox
18:17:36 <Pseudonym> Oh, are you here, musasabi?
18:17:53 <xerox> Pseudonym: he added that project today :-D
18:17:59 <Pseudonym> Yeah.
18:18:28 <RyanT5000> but i can't tell if i'm not getting the pixels out or if my surface is really black
18:19:36 <xerox> Pseudonym: feel free to spit out your ideas.
18:42:58 * araujo looks in
18:43:19 * xerox yawnes
18:44:21 <araujo> xerox!!
18:44:28 <araujo> nice new site :-)
18:44:29 <xerox> Hey.
18:44:31 <xerox> Danke.
18:44:37 <xerox> Cale's logo looks very good
18:45:03 <araujo> hah, yeah, good inkscape-fu
18:45:57 * araujo hadn't noticed the MUD idea
18:46:53 <xerox> :-D
18:46:56 <xerox> Haskell-cafe guy
18:47:04 <araujo> :-)
18:47:07 <metaperl> Cale: check your gmail?
18:47:13 <metaperl> I just sent you some xfig figures
18:48:53 <Cale> metaperl: cool
18:49:55 <metaperl> :)
18:50:19 <metaperl> that's from reading the first part of the tutorial... I understand 100%. now to keep moving
18:55:07 <metaperl> Cale: one way to improve the bind diagram is for the function to take a single datum of type a and return a container of 3 or 4 datums of type b
18:56:06 <Cale> metaperl: yeah
18:59:24 <metaperl> there are containers that come with GHC that automatically keep their contents sorted correct?
18:59:30 <Pseudonym> BRB
18:59:56 <Cale> metaperl: Set does that, but unfortunately, although it's a monad, it can't be made an instance of Monad.
19:00:27 <metaperl> hmm
19:00:50 <Philippa> mmm, you'd need to MPTC the Monad class with the second parm being the "source category" (usually just a, but you might wanna constrain it)
19:04:15 <musasabi> Philippa: how would it look like? return is easy to constrain but isn't >>= harder?
19:04:33 <musasabi> or would you only constrain things in the >>=
19:06:07 <Philippa> I'm not sure you actually need to constrain in >>=
19:06:32 <Philippa> as return and the monadic primitives're the only way to construct an 'atomic' action
19:07:37 <musasabi> hmm, it would work.
19:07:44 <Philippa> and you might even find a sane reason to want to do it that way, though I'd want to check the maths to be happy it still counts as a monad if the primitives can yield return types that (ADTs preventing construction aside) return can't
19:07:54 <dons> musasabi: full tests indicate that Word8 and Latin1 run at exactly the same speed, on 20M buffers
19:07:55 <musasabi> except for undefined.
19:08:09 <Philippa> point
19:08:12 <Philippa> (hah!)
19:08:25 <Philippa> bottom's a pain in the arse
19:08:53 <musasabi> dons: nice :-)
19:09:13 <Philippa> in fact, you could shorten that to "bottom's a recursive pain"
19:09:31 <musasabi> dons: I think that micro string benchmarking might make sense too. With strings of lengths 1..50 bytes.
19:09:33 <dons> yeah, its comforting to know I wrote 500 lines of 'id' functions in Latin1.hs :S
19:09:51 <Philippa> yeah, that makes sense here
19:09:53 <dons> musasabi: yeah, I've got a plan to use QuickCheck to generate a large number, and then map functions over them.
19:10:06 <Philippa> some potentially-sensible parsing algorithms're going to use those, for example
19:10:09 <dons> if you've got some suggestsions for a microbenchmark structure though, that'd be useful
19:10:16 <Philippa> not to mention OS interaction could generate a crapload
19:12:49 <musasabi> dons: the generation part is quite easy, more about getting the operations realistic.
19:13:00 <musasabi> but I don't have good ideas.
19:13:38 <dons> yeah, I've already got the QuickCheck code to generate things. But not a good idea yet for how to do convincing tests that wouldn't end up much the same as the 20M tests
19:14:45 <musasabi> Have a set of operations with weighted probablities and treansform a list of random numbers into the operations and then use that?
19:14:58 <dons> ah, now that's interesting.
19:15:14 <dons> I could weight it on occurences from the ghc libs
19:15:45 <musasabi> dons: or take an application you are interested and look at the number of calls (loops vs non-loops)
19:16:33 <dons> good idea. ok, I think I can do something with this.
19:17:03 * xerox stretches more
19:17:13 <xerox> I've contacted Daan and others franka suggested
19:17:23 * xerox falls asleep on the keyboard
19:17:26 <dons> good work. :)
19:17:34 <SamB> oooh, daan ;-)
19:17:35 <xerox> @localtime xerox
19:17:38 <lambdabot> Local time for xerox is 2006-04-26 04:17:15 +0200
19:17:43 <xerox> hm.
19:18:01 <xerox> The site is pretty much shaped... I should add details on the homepage.  Tomorrow.
19:18:19 <xerox> I have also mailed the mailing lists to tell them that it's now official.
19:19:08 <newsham> hola
19:19:09 <newsham>         http://0x90.org/~txs/p118-olthoff.pdf
19:21:50 <xerox> Okay.
19:21:52 <xerox> Goodnight people.
19:22:17 <dons> night xerox!
19:22:50 * araujo back
19:22:52 <newsham> amusing alegory about formal methods
19:22:53 <araujo> night xerox 
19:33:18 <Frederick> hello anyone here familiar with tabular predictive parsing?
19:41:02 <Frederick> ??
19:41:03 <lambdabot> Not enough arguments to @.
20:00:40 <RyanT5000> am i wrong to think it's slow for a rebuild when nothing has changed to take 20 seconds?
20:01:00 <RyanT5000> like, just figuring out that the file dates match up
20:01:15 <RyanT5000> with like 20 files
20:01:22 <Korollary> yes it's slow
20:01:31 <RyanT5000> in a C++/C# environment i'd expect like 1/10th second per file at the most
20:02:02 <RyanT5000> Korollary: do you have a suggestion for figuring out what's wrong? i'm on windows, so that could be the issue i guess
20:02:16 <RyanT5000> lol i should try putting my compiler in vmware on linux
20:02:26 <RyanT5000> i've known things that were faster that way :-/
20:02:52 <RyanT5000> "on linux in vmware", rather
20:03:02 <dons> musasabi: since you, me and John want Char8 over Latin1. I've moved (for the last time, I promise) to Data.ByteString.Char8. So we don't make any claims about encodings. That can be for some future PackedString lib.
20:03:26 <dons> RyanT5000: is it relinkngi the bnairy?
20:03:35 <dons> grr. should watch while I type.
20:03:56 <RyanT5000> dons: no, most of the time spent is on checking dependencies
20:04:06 <dons> hmm. 
20:04:45 <RyanT5000> also i've noticed that sometimes i'll come back to a ghci process and it'll take like 10 seconds to execute the first command i issue
20:04:52 <RyanT5000> even if it's swapped out that seems excessive
20:05:13 <RyanT5000> anyway there's probably nothing anyone can do without knowing more about my setup
20:05:20 <dons> yep.
20:05:20 <RyanT5000> and who wants to learn about my setup
20:05:24 <RyanT5000> (hypothetical)
20:05:29 <dons> buy more ram?
20:05:34 <RyanT5000> i have plenty
20:05:43 <RyanT5000> 1 GB, using around 600 most of the time
20:05:47 <RyanT5000> but it's windows
20:05:56 <RyanT5000> for some reason windows swaps stuff out even when the ram isn't all used up
20:06:10 <RyanT5000> i don't know if it's using the extra space for disk cache or just "for fun"
20:06:23 <dons> for fun, I'd suspect
20:06:31 <RyanT5000> me too
20:06:32 <dons> need space for all that spyware.
20:06:40 <dons> ;)
20:06:43 <RyanT5000> :P
20:06:52 <RyanT5000> i'm relatively spyware-free, because i make heavy use of vmware
20:07:04 <RyanT5000> i have a clean windows 2000 vm i keep lying around
20:07:13 <RyanT5000> i sandbox anything remotely suspicious i get off the web
20:07:44 <Korollary> linux does the same. There's always some swapfile usage.
20:07:57 <RyanT5000> hm
20:08:10 <dons> yeah, mozilla always plays nasty buggers if i leave it for a few hours.
20:08:18 <RyanT5000> i understand putting stuff in the swapfile "for fun"
20:08:23 <Korollary> mozilla has had its own issues iirc
20:08:25 <RyanT5000> i don't understand removing it from ram
20:08:44 <dons> too right.
20:09:21 * RyanT5000 hates visual studio
20:09:27 <dons> programs we love to hate: emacs, mozilla, hmm. gcc?
20:09:31 <RyanT5000> visual studio 2003 and 2005 do not coexist peacefully
20:11:11 <RyanT5000> i really want to know what dev studio microsoft uses internally
20:11:27 <RyanT5000> they cannot seriously use Visual Studio and Visual SourceSafe
20:11:41 <RyanT5000> VSS is the worst versioning system ever made (commercially successful)
20:13:35 <fwfewfwa> they use CVS on a Debian
20:17:01 <Korollary> I think I heard something like MS uses something else developed internally.
20:17:46 <RyanT5000> hm
20:17:51 <RyanT5000> i wonder why they don't release it
20:18:00 <RyanT5000> maybe it supports cross-platform development :P
20:18:15 <RyanT5000> although that seems like it'd be relatively easy to neuter
20:18:38 <Korollary> it's a bit of a rumor so I could be wrong
20:18:57 <RyanT5000> yeah, i vaguely remember hearing the same thing, now that you mention it
20:19:28 <RyanT5000> what i've read is that, most likely, the only reason visual studio costs money is that if it didn't it'd be another monopolistic strategy
20:19:42 <sjanssen> seems odd that they'd develop something powerful enough to manage huge apps like WIndows and Office, but not sell it
20:19:52 <Korollary> I dont think so
20:19:52 <RyanT5000> if you think about it, they're not making anything significant off of visual studio
20:20:01 <RyanT5000> the odd $300 per developer
20:20:23 <Korollary> It's ok to make Windows media player free.
20:20:42 <RyanT5000> yeah but what other explanation is there?
20:20:50 <Korollary> They make money out of it
20:20:55 <Korollary> VS I mean
20:20:55 <RyanT5000> it's in their best interests to make it as easy to develop on windows as possible
20:21:03 <RyanT5000> they hardly make anything off VS
20:21:12 <sjanssen> RyanT5000: that might be a decent strategy for them
20:21:29 <RyanT5000> i mean how many developers are there working on windows? a million?
20:21:38 <RyanT5000> vs. the installed base of windows
20:27:16 <fwfewfwa> yes
20:27:28 <fwfewfwa> but now compare the cost of developing windows, and developing visual studio
20:27:39 <fwfewfwa> it may be that in percentage, they win a lot more money...
20:28:48 <RyanT5000> i've heard that the only two consistently profitable divisions at microsoft are office and windows
20:29:03 <RyanT5000> though i'm not exactly sure what that means
20:29:13 <RyanT5000> e.g.: whether vs is within one of those
20:37:50 <palomer> it won't be, once people start using Yi!
20:42:49 <mlh> RyanT5000: 'team foundation' is released
20:43:00 <mlh> if that's what ms use internally
20:43:07 <RyanT5000> that's just VS 2005 server
20:43:14 <RyanT5000> although it has been slow to deliver
20:46:29 <mlh> hmm maybe sourcedepot then .. an version of perforce apparently
20:50:45 <RyanT5000> ok i've defined the following: data GUI a = Message -> (a, GUI a)
20:50:50 <RyanT5000> somehow this seems like it should be a monad
20:50:57 <RyanT5000> am i right to feel that way?
20:51:28 <RyanT5000> the top-level gui, btw, will be a GUI IO ()
20:51:34 <RyanT5000> GUI (IO ())
20:52:01 <RyanT5000> whereas a text box would be GUI String
20:54:07 <sjanssen> what you've defined is a little like a reader monad
20:54:55 <sjanssen> actually, maybe not
20:56:33 <RyanT5000> oh well; i can always refactor later
20:56:42 <RyanT5000> besides, my understanding of monads at this time is shakey at best
20:56:46 <RyanT5000> thanks for the advice :)
20:56:51 <RyanT5000> i'll look up reader monad anyway
20:58:14 <sjanssen> is there a behavior that you want out of your monad?  it'd be easier to give advice that way
20:58:26 <RyanT5000> well, i'm not quite sure
20:59:03 <RyanT5000> it's very close to the Actor paradigm in Janus, from what i've read
20:59:12 <RyanT5000> essentially a GUI represents a Behavior
20:59:31 <RyanT5000> Message is obviously a Message
21:00:18 <RyanT5000> and i guess Actor would be the loop that keeps calling the function in the GUI
21:03:47 <palomer> enough jibber jabbering!
21:03:58 <palomer> blargh!
21:04:28 <sjanssen> @palomer
21:04:29 <lambdabot> hrmph
21:06:45 <sjanssen> RyanT5000: I managed to write Functor for your type, but I don't know what it means . . .
21:06:59 <RyanT5000> hm
21:07:11 <RyanT5000> maybe it'll become more apparent when i actually make some instances of it
21:07:19 <RyanT5000> Window, e.g.
21:10:05 * palomer thinks Actor sounds like java
21:12:46 <RyanT5000> no, not related to UML's Actor
21:13:05 <palomer> I've seen Actor used for GUIs in java
21:13:37 <palomer> gah, the types of my system just went bonkers
21:13:46 <palomer> ok, if ghc doesn't get better error reporting I'm pulling my leg off
21:13:51 <palomer> this is crazy!
21:16:13 <RyanT5000> wow
21:16:15 <Korollary> @ghc
21:16:15 <lambdabot>  Can't represent explicit kind signatures yet
21:16:29 <RyanT5000> i love it when people define their semantics really poorly
21:16:31 <RyanT5000> "An actor is an object with its own thread"
21:16:39 <RyanT5000> (referring to java)
21:17:02 <Korollary> @ghc
21:17:03 <lambdabot>  You need -fglasgow-exts to derive an instance for this class
21:17:05 <RyanT5000> "object" isn't well-defined to begin with, and "with its own thread" means next-to-nothing
21:17:19 <Korollary> I think java objects are pretty well defined.
21:17:42 <RyanT5000> well obviously their runtime behavior etc. are
21:17:47 <palomer> ok, if you use <- instead of let, the type system goes nuts
21:18:07 <RyanT5000> but the concept of an object can be rather nebulous
21:19:12 <RyanT5000> another difference between the stuff i'm reading about Actor in GUIs is that my entire program is a single actor
21:19:49 <RyanT5000> well i'll write it up if it ends up working well
21:22:08 <palomer> well, it looks like the community might see my ideas about GADTs written down
21:26:11 <monochrom> c'est la software engineering
21:32:16 <palomer> c'est beau
21:32:31 <RyanT5000> C'est Moi, C'est Moi
21:33:34 <RyanT5000> (it's the title of a song from the broadway show "Camelot")
21:35:01 <fwfewfwa> <Korollary> I think I heard something like MS uses something else developed internally. ---> they use VC++ compiler with some tools specially made for making their products...
21:35:26 <palomer> I think fwfewfwa is a microsoft SPY
21:35:32 <fwfewfwa> nope
21:35:34 <RyanT5000> fwfewfwa: the real question is, do they use Visual SourceSafe
21:35:38 <fwfewfwa> i've just asked a friend who used to work thre
21:35:50 <fwfewfwa> do they use Visual SourceSafe --> they don't (at least where this friend worked)
21:35:51 <RyanT5000> because vss is horrendous
21:36:11 <fwfewfwa> why is it horroendous?
21:36:27 <Pseudonym> You have to use it to feel the pain fully.
21:36:37 <fwfewfwa> he told me they use something like: http://subversion.tigris.org/ this
21:36:59 <RyanT5000> it has no security, you have to (?) use it over windows shares, and anything you do causes it to think it's corrupt (even if it isn't)
21:37:09 <RyanT5000> like, if you kill visual studio while checking something out
21:37:42 <RyanT5000> i've used cvs and subversion as well as vss, and the only advantage vss has is slightly superior integration into visual studio
21:37:53 <RyanT5000> however i think team foundation server might be decent
21:38:50 <palomer> well, anything is better than darcs
21:38:51 * palomer ducks
21:42:46 <RyanT5000> is anyone willing to help me get started with a "real" editor? aka emacs or vim
21:43:18 <RyanT5000> i have the basic survival skills necessary for either
21:43:31 <RyanT5000> but i have no idea what i need to set up to make them good for haskell
21:43:37 <RyanT5000> e.g.: this "tags" stuff i keep hearing about
21:43:55 <monochrom> Yes, Microsoft uses a better IDE than what they sell.  An intern a few years ago told me a programmer could change the AST (I forgot programmatically like TH or manually).
21:44:15 <RyanT5000> huh
21:45:11 <palomer> gah! why is fromEnum of type a -> Int? WHY?
21:45:21 <palomer> it should be a -> Integer
21:45:28 <fwfewfwa> programmer could change the AST (I forgot programmatically like TH or manually). ---> what does this means?
21:45:42 <mwc> RyanT5000, for starters, I find: set expandtab tabstop=4 backspace=indent,eol,start cindent works pretty well in Vim
21:45:44 <RyanT5000> or Integral b => a -> b
21:46:00 <monochrom> abstract syntax tree.  you can say it means parse tree.
21:46:16 <fwfewfwa> what does it means they can change the AST?
21:46:35 <palomer> RyanT5000: sure, I'll help you get started with emacs
21:46:40 <RyanT5000> lol he was just yanking your chain: he meant "by editing the source code"
21:46:51 <monochrom> It means the programmer effectively redefines the programming language.
21:46:58 <mwc> RyanT5000, don't listen to palomer. Stay away from the dark side!
21:47:05 <fwfewfwa> O_o
21:47:09 <RyanT5000> lol i will try both at some point
21:47:10 <fwfewfwa> i like c++ AST
21:47:12 <palomer> anyways, priv msg me if you want to learn
21:47:13 <fwfewfwa> why should i change it?
21:47:32 <mwc> monochrom, great, that explains a lot about the Microsoft internal development process
21:47:46 <RyanT5000> @roll 2
21:47:47 <lambdabot> Unknown command, try @list
21:47:50 <RyanT5000> @list
21:47:51 <lambdabot> list [module|command]. Where modules is one of:
21:47:51 <lambdabot> babel base compose dice dict djinn drHylo dummy dynamic elite fact haddock help hoogle karma lambda localtime log more pl plugs poll pretty quote search seen slap spell state system todo topic type
21:47:51 <lambdabot> unlambda version vixen where
21:47:55 <RyanT5000> @dice 2
21:47:55 <lambdabot> 2 => 2
21:48:04 <RyanT5000> @dice 2
21:48:05 <lambdabot> 2 => 2
21:48:07 <mwc> Redefine the language.. that sounds like it'll be great for  team coherency
21:48:09 <RyanT5000> @dice 2
21:48:09 <lambdabot> 2 => 2
21:48:13 <mwc> "What does #>> mean?"
21:48:15 <RyanT5000> what does dice do?
21:48:45 <mwc> nothing like some byzantine code transformations in the morning :D
21:48:50 <RyanT5000> well anyway i downloaded vim as soon as mwc responded.... so i'll try it first :P
21:49:24 <mwc> The thing that puts a lot of people off vim is that it has modes: insert mode, command mode, etc.
21:49:35 <RyanT5000> yrsh
21:49:36 <RyanT5000> *yeah
21:49:42 <mwc> I hate emacs for it's control-shift-alt-p-g finger contortions
21:49:59 <RyanT5000> i've figured  out the modes enough to use it to edit my /etc/ files on freebsd
21:50:00 <RyanT5000> that's about it
21:50:11 <mwc> yeah
21:50:48 <mwc> if you're on windows, I'm not sure which you'll find better integrated
21:50:53 <mwc> Vim is pretty minimal
21:51:22 <RyanT5000> well i'm not doing anything that tricky
21:51:28 <RyanT5000> even building on the commandline wouldn't really kill me
21:51:43 <RyanT5000> what would be really nice is context-sensitive hoogle
21:51:49 <RyanT5000> not sure if that's possible
21:51:55 <mwc> ah yes, that would be something
21:51:59 <mwc> maybe they'll get it into Hide
21:52:54 <monochrom> Template Haskell transforms the AST too, no?
21:53:39 <RyanT5000> i'm not sure if it can transform it, but it can generate new AST and read existing AST
21:53:50 <RyanT5000> and the AST it generates can be spliced in
21:54:19 <monochrom> Alright, so in Microsoft they have tools to do similar things to their C++ AST.
21:54:34 <RyanT5000> hm
21:54:42 <mwc> I think camlp4 is a little more powerful, as I understand it, it's TH haskell that's run entirely before the compiler sees it
21:54:43 <RyanT5000> sounds like something i could use
21:54:50 <mwc> so it can do pretty much anything
21:55:10 <RyanT5000> can't TH do pretty much anything?
21:55:22 <RyanT5000> module Main where $(generateMyProgram)
21:55:30 <mwc> Yeah, you have to call it
21:55:31 <RyanT5000> oh huh it can't generate imports
21:55:47 <mwc> my understanding of P4 is that it's more like a compiler pass
21:55:52 <RyanT5000> hm
21:57:10 <monochrom> So, I hope you were joking when you said such power must lead to byzantine code.
21:57:30 <mwc> In the hands of MS/
21:58:09 <monochrom> How do you know?
21:58:53 * RyanT5000 feels n00bified, running "vimtutor"
21:59:25 <palomer> http://www.rafb.net/paste/results/aPzOPr19.html <--I'm confounded by these errors, anyone have any insight
21:59:38 <palomer> learning vim is pointless
21:59:50 <dons> that's a quotable quote!
22:00:01 <palomer> unless you want to edit files over ssh or somesuch
22:00:10 <palomer> (an even then, emacs is a gizzilion times better)
22:00:26 <RyanT5000> well i know it's an issue of religion, so i figure i'll learn both and be a good agnostic
22:00:38 <palomer> who uses vim here?
22:00:45 * mwc does
22:00:46 * dons edits lambdabot/Plugin/Quotes/Text.hs:palomer
22:00:52 * dons does
22:00:58 <dons> also sethk
22:00:58 <mwc> palomer, I suppose any text editor using 80 megs has to be good
22:01:01 <RyanT5000> @karma mwc
22:01:02 <lambdabot> mwc has a karma of -1
22:01:04 <RyanT5000> @karma dons
22:01:05 <palomer> ok, can you compile at a touch of a button and jump to the next error at the touch of a button?
22:01:05 <lambdabot> dons has a karma of 32
22:01:18 <monochrom> I use emacs and the haskell mode suits me.  (I don't care about "tags".  It's a thing of the past.)
22:01:20 <mwc> RyanT5000, dons took my karma for trying to hack lambdabot :(
22:01:26 <RyanT5000> :(
22:01:41 <RyanT5000> i was trying to do that for a while too... except i really, really suck at it
22:01:43 <sethk> dons, someone looking for me?  My IRC thing is beeping
22:01:55 <dons> sethk, sorry. just noting that you're a vim user
22:02:11 <palomer> I didn't think so.
22:02:12 <sethk> dons, that's ok  :)
22:02:25 <dons> palomer, yeah, sure.
22:02:27 <sethk> dons, I've got vim cranking along on those haskell compiles now
22:02:30 <monochrom> what is "reconstruct"?
22:02:35 <dons> sethk gave a little tut on this the other day
22:02:37 <palomer> dons: and the cursor will go to the right line?
22:02:44 <sethk> dons, I made a short macro to open the error window and run make
22:02:50 <dons> palomer, that's the easy part
22:03:05 <sethk> palomer, it'll do what you expect
22:03:13 <monochrom> I suppose you are not a constructive team player.
22:03:37 <palomer> so you can edit code, then press a button and the cursor will move to the next error, then you edit more code, repeat
22:04:01 <sethk> palomer, right
22:04:08 <sethk> palomer, has next error, previous error
22:04:23 <sethk> palomer, and you get the error in one window and the code, highlighted in the other
22:04:24 <palomer> ok, can you interact with an inferior process (like an interpreter)?
22:04:39 <sethk> palomer, I haven't tried that.  I imagine it can
22:04:48 <palomer> last I asked #vim, it couldn't!
22:04:56 <RyanT5000> palomer: that's what my windowing system is for
22:05:00 <sethk> palomer, possible that it can't, I guess
22:05:06 <sethk> RyanT5000, well, emacs has no trouble doing it
22:05:16 <palomer> interacting with inferiour processes is very useful when using ruby/python
22:05:23 <palomer> s/inferiour/inferior
22:05:29 <RyanT5000> i know, but why would i want to use a split-pane emacs when i could instead use a separate window?
22:05:29 <sethk> but I don't like the haskell modes in emacs
22:05:38 <palomer> can you edit remote files locally, with every save done remotely?
22:05:56 <sethk> RyanT5000, so that you can do everything with the keyboard and not have to use the mouse and move your hands all over
22:06:02 <palomer> RyanT5000: because you can send the buffer to the remote process, sends parts of the buffer, etc...
22:06:28 <RyanT5000> hm, i can see the use in that
22:06:38 <RyanT5000> although i already don't use the mouse much (alt-tab)
22:06:40 <monochrom> emacs can put out separate windows too.
22:07:12 <palomer> and emacs is never 80 megs
22:07:15 <palomer> my emacs is running at 15
22:07:22 <palomer> and I have 20 or so files open, with various modes
22:07:45 <palomer> vi doesn't even come with a turing complete scripting language
22:07:50 <sethk> what's chewing up 80 meg?
22:07:51 <monochrom> I kind of don't want to ruin the surface texture of my C and X keys, so there are things I want to use the mouse for. :)
22:08:03 <sethk> palomer, the macros in vim are poor
22:08:22 <sethk> palomer, so I use vim, but I use emacs when I need those features
22:08:47 <palomer> why not just scrap vim and use emacs?
22:08:54 <palomer> I used to use vi, hardcore like
22:09:02 <sethk> palomer, the regular expression search and replace crawls
22:09:04 <palomer> until I saw the light
22:09:14 <palomer> sethk: you have that in emacs
22:09:17 <monochrom> I had old keyboards over which I used emacs key bindings intensively.  The erosion on C and X was significant.  :)
22:09:23 <sethk> palomer, yes, but it goes sloooooooow
22:09:26 <palomer> C-M-%
22:09:35 <palomer> eh? I never had a problem with speed
22:09:44 <palomer> give me a regexp, I'll try it right now
22:10:03 <RyanT5000> hm, i have to admit, palomer, you are rather persuasive; i'm enjoying listening in on this argument
22:10:10 <monochrom> (Give him the regexp that picks out prime numbers :) )
22:10:12 <palomer> (I would be surprised if it was slow, since I think it's done in C)
22:10:13 <sethk> palomer, next time I have one going slowly I'll note it down
22:10:27 <sethk> palomer, it may be that with my newest machines I won't notice the slowdown as much as I used to
22:11:42 <sethk> palomer, it's slow because it was running interpreted lisp
22:11:50 <palomer> oh, but many functions are implemented in C
22:11:54 <sethk> palomer, and for some reason it wasn't able to compile that piece of it
22:12:10 <sethk> palomer, I knew all about this five years ago, but I don't exactly have the details handy
22:12:32 <sethk> palomer, there is also the fact that vi uses maximal regular expressions and emacs uses minimal
22:12:40 <sethk> and usually maximal is what you need
22:12:42 <palomer> can't that be changed with a flag?
22:12:55 <sethk> palomer, didn't used to be able to, but I haven't checked in several years
22:13:29 <sethk> palomer, having a real macro language is an amazing feature, of course
22:13:46 <sethk> I'm surprised nobody has added anything other than primative keystroke macros to vim
22:13:56 <sethk> you can't even have a continue y/n type question
22:14:18 <palomer> type question?
22:14:35 <palomer> I once wrote a nice IDE in elisp, it very much resembled visual studio
22:14:46 <palomer> you could set breakpoints, and the cursor would move and all that jazz
22:14:55 <palomer> (when debugging)
22:16:38 <palomer>  Overlapping instances for Utilities.UnIntegerable String <--how is this blazing possible?
22:16:43 <palomer> there are no overlapping instances!
22:16:47 <palomer> http://www.rafb.net/paste/results/aPzOPr19.html
22:17:46 <palomer> oh, a "y/n type" question
22:21:36 <monochrom> palomer you give insufficient information.
22:22:07 <palomer> hmm?
22:22:20 <palomer> it's saying that the String instance is overlapping, no?
22:22:29 <palomer> or, rather, 2 instances are applicable for String
22:22:47 <palomer> and it gives the imported instances that match
22:22:51 <palomer> but one obviously doesn't match!
22:28:11 <monochrom> which -f flags are you using?
22:28:56 <monochrom> I am trying to reproduce the error in the first place.
22:29:38 <monochrom> If I can't reproduce the error within reasonable effort, then I must conclude you give insufficient information and you are insincere.
22:30:14 <palomer> insincere?
22:30:23 <palomer> here, I'll repreduce it
22:30:27 <palomer> reproduce it
22:30:34 <palomer> make something reproducible
22:31:07 <monochrom> overlapping instance is a fairly global issue.  you need to show more code.
22:32:40 <palomer> http://www.rafb.net/paste/results/3Lf1fq82.html
22:32:45 <palomer> try compiling that
22:33:52 <palomer> 	ghc --make -fallow-undecidable-instances -fglasgow-exts -fno-monomorphism-restriction Substitution.hs SType.hs MSG.hs Utilities.hs Main.hs Match.hs Term.hs Reconstruct.hs
22:34:04 <palomer> that's my global compile flag
22:34:23 <palomer> this is what you want: ghc -fallow-undecidable-instances -fglasgow-exts -fno-monomorphism-restriction foo.hs 
22:34:43 <monochrom> But at present I don't even get to that.  I am getting error "Illegal instance declaration" referring to "instance Integral a => ..." and "instance Num a => ..."  I am not sure whether I am doing something wrong.
22:36:01 <palomer> try with those compiler flags
22:36:02 <palomer> ?
22:36:22 <palomer> I get the overlapping errors when I try
22:36:23 <monochrom> thanks, processing...
22:39:00 <dons> ?uptime
22:39:01 <lambdabot> uptime: 6 days, 4 hours, 13 minutes and 57 seconds
22:43:24 <sjanssen> RyanT5000: ping
22:46:53 <RyanT5000> hm?
22:47:35 <sjanssen> I got really bored, and instanced Monad for your type
22:47:44 <RyanT5000> awesome; did it fit?
22:47:49 <sjanssen> it typechecks, but I don't really know what it means
22:48:37 <RyanT5000> paste?
22:48:53 <sjanssen> lisppaste2: url
22:48:53 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
22:49:44 <lisppaste2> sjanssen pasted "instance Monad GUI" at http://paste.lisp.org/display/19378
22:51:07 <sjanssen> return is easy, just a GUI that always returns x and itself
22:51:14 <RyanT5000> right
22:51:52 <sjanssen> fmap is easy too, just apply f to every value that the GUI will ever produce
22:51:53 <mahogny> xerox_, there?
22:52:00 <RyanT5000> right
22:52:01 <dons> ?quit lots of new code
22:52:25 <RyanT5000> heh i have no idea how to interpret >>= though
22:52:55 <dons> ?palomer
22:52:56 <sjanssen> I'm not quite satisfied with >>=
22:53:15 <lambdabot> Scalliwags!
22:53:54 <RyanT5000> well when i have some working code that does something useful, i'll talk to you about it
22:54:09 <RyanT5000> right now i'm not even writing instances of that yet
22:54:22 <RyanT5000> i'm working on getting stupid SDL_ttf to output OpenGL textures :-/
22:54:29 <sjanssen> the problem with (g >>= f) is that it gives a result of g to f only once
22:54:39 <RyanT5000> although my "work stack" now has "make it so visual studio can open things" on top
22:55:08 <adu> it can't open things?
22:55:15 <sjanssen> you get either that or the GUI that f produces isn't repeatedly replaced like it should
22:55:32 <palomer> dons: you should make it so that we can grab arbitrary quotes, like in #c++
22:55:38 <sjanssen> and I don't think you can write an instance of Monad that does both of those things
22:55:40 <dons> grab?
22:55:45 <RyanT5000> well adu, it can open my projects, but it can't build unless i recreate them from scratch
22:55:49 <palomer> yeah, grab
22:55:59 <dons> please elaborate
22:55:59 <RyanT5000> i'm using visual haskell, and i have vs 2003 and 2005 both installed
22:56:03 <palomer> @grab
22:56:04 <lambdabot> Unknown command, try @list
22:56:12 <adu> RyanT5000: ouch
22:56:17 <palomer> @grab palomer would add what I just said to my quote list
22:56:17 <lambdabot> Unknown command, try @list
22:56:18 <dons> what does it do? is it the same as @remember?
22:56:28 <dons> ah, what you just said. yeah, that's doable
22:57:10 <sjanssen> what if you @grab too slowly?
22:57:12 <RyanT5000> adu: yeah, i have no idea why it sucks so much
22:58:23 <dons> its just a little bit better than @remember. but i need to fix the bug in @remember first.
22:59:49 <monochrom> palomer: I admit someone else knows this more, but here is what I think based on what I heard some time ago.  The search algorithm for matching instances is quite dumb.  It ignores contexts first, i.e., it matches the RHS's of => first.  If you ask for "Integerable [Char]", then both "Integerable a" and "Integerable [Char]" match.  Without looking further, the algorithm already stops complaining ambiguity.  (Only after this s
22:59:49 <monochrom> tage passes with a unique match, does the algorithm proceed to check the context "Integral a =>")
23:01:04 <monochrom> This is probably a reason why Haskell 98 has restrictive rules on instance declarations re: "at least one of the types in the head of an instance declaration must not be a type variable"
23:01:43 <monochrom> (If the head is a type constructor, there is at most one match.)
23:02:02 <palomer> gotcha
23:02:18 <monochrom> (err nevermind the last statement. make that "it's easier to locate overlapping instances")
23:02:45 <palomer> this seems like a bug to me
23:02:47 <palomer> hrmph
23:02:53 * palomer ponders this while getting some cereal
23:03:10 <monochrom> I think they discussed this in this channel last night.
23:09:30 <palomer> that's nuts
23:09:40 <palomer> man, I need some shut-eye
23:09:52 <palomer> thx for the help
23:09:54 * palomer flies
23:40:17 <kzm> @seen
23:40:17 <lambdabot> Lately, I have seen kzm.
23:40:20 <kzm> @seen dons
23:40:21 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 41 minutes and 57 seconds ago.
