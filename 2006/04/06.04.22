01:00:54 <mauke> ?type intersperse
01:00:56 <lambdabot> forall a. a -> [a] -> [a]
01:44:23 <Lokadin> @YAHT
01:44:24 <lambdabot> Unknown command, try @list
01:44:39 <Lokadin> @url YAHT
01:44:40 <lambdabot> Maybe you meant: arr pl
01:44:48 <Lokadin> @list
01:44:48 <lambdabot> list [module|command]. Where modules is one of:
01:44:48 <lambdabot> babel base compose dice dict djinn drHylo dummy dynamic elite fact haddock help hoogle karma lambda localtime log more pl plugs poll pretty quote search seen slap spell state system todo topic type
01:44:48 <lambdabot> unlambda version vixen where
01:45:05 <Lokadin> hmmm
01:46:01 <dons> ?where yaht
01:46:02 <lambdabot> http://www.isi.edu/%7Ehdaume/htut/
01:46:15 <dons>  ?url should be a synonym good idea.
01:48:18 <Lokadin> thanks :)
01:48:18 <Lokadin> lol
02:15:42 <twice11> I used to think that DiffArray should be faster than Array in single-threaded, many-update code. Performance of http://www.physik.fu-berlin.de/~karcher/brt.hs shows otherwise. Can anybody tell me what I am doing wrong?
02:16:19 <twice11> That code has been extacted form a LZ77 decoder I am currently writing.
02:17:33 <twice11> The idea is to keep the latest output (for use as the dictionary) in an DiffArray. This model code makes a dictionary lookup on every second output byte and updates the dictionary on every output byte.
02:23:42 <twice11> Using my Pentium-III 700 processor and ghc 6.4 with optimization, both the DiffUArray and the UArray versions are space-efficient, but the DiffUArray takes 16 seconds, whereas the UArray codes finishes in 3 seconds.
02:31:30 <isaacd> Maybe DiffUArray is so slow dealing with its internal implementation that it's slower to use it than to copy 17 things each time? (wild guess)
02:32:39 <twice11> Might be. I will try with a larger array size, and report results.
02:33:13 <isaacd> > print 0
02:33:14 <lambdabot> No IO allowed
02:33:21 <Lemmih> twice11: DiffArray needs to read an MVar every time it's accessed.
02:34:23 <Lemmih> twice11: That's way more expensive than copying such a small array.
02:36:37 <twice11> OK, I see, the 17-entry-array was a bad model. Using a 16K Array DiffUArray really *is* lots faster than UArray. The DiffUArray timing did not change, whereas I am still waiting for the UArray timings.
02:37:08 <Lemmih> twice11: Btw, (x `seq` x) is kinda weird.
02:37:19 <isaacd> x `seq` (x : ...)
02:37:23 <isaacd> equivalently
02:37:40 <isaacd> infixr 0 seq
02:38:31 <twice11> Why is  x `seq` (x:...) weird? I supposed I can force evaluation of the head, if the tail of the list is accessed. That was the intention of the seq.
02:39:37 <Lemmih> twice11: I got the precedence wrong.
02:40:34 <twice11> OK, So the code does what I intended. The second (x `seq` backarray) is probably really weird. I put in some `seq`s into that code to fix a space leak.
02:42:28 <twice11> OK, I aborted the UArray run with 16K arrays after 300 seconds MUT time, the DiffUArray finished after 16s. So DiffArray works, but not as fast as I expected.
02:43:13 <Lemmih> Tried STUArray?
02:43:48 <twice11> Not yet. But this would mean a rewrite into monadic code, if I see that correctly.
02:44:02 <Lemmih> Yes.
02:44:33 <Lemmih> But you can escape the ST monad.
02:45:11 <twice11> Sorry, I don't understand what you mean by 'escaping' the ST moand.
02:47:08 <Lemmih> twice11: You can write a non-monadic version of withArray that calls the monad version.
02:49:10 <twice11> That what I intended to do, writing withSTArray n init = runST (withSTArray' n (newSTArray (0,16383) (replicate 16384 init))
03:04:07 <twice11> Lemmih: The hint with STUArray is OK: With enough heap, I get a higher performance than with DiffArray, but there seems to be a space leak now, as I did it like {x <- calcHead; xs <- calcTail; return $ x:xs}. Is there a way to return the head before calculating the tail, or should I use ST.Lazy instead?
03:05:57 <Lemmih> twice11: You can use an accumulator.
03:06:32 <twice11> That means to do it like ShowS?
03:07:38 <Lemmih> 'reverse' has the same cost, I think.
03:08:17 <twice11> I have to take a real life break, be back in about 30 mins.
03:42:48 <bolrod> yo.. I'm trying to compile that cairo clock.. though getting some errors like
03:42:49 <bolrod> Clock.hs:289:2: Not in scope: `windowSetGeometryHints'
03:43:04 <bolrod> what am I missing  (the other examples compile just fine)
03:43:16 <dcoutts> bolrod, you need the darcs version of gtk2hs
03:43:34 <bolrod> hmmm..  
03:43:37 <dcoutts> it won't compile with the released 0.9.10 version
03:43:38 <bolrod> compile from source ?
03:43:43 <bolrod> aha :)
03:44:05 <dcoutts> that's why that demo is in the darcs version and not in the last release :-)
03:44:35 <bolrod> urh.. it is in the source code you can download from sourceforge
03:44:45 <dcoutts> no it isn't
03:44:53 <dcoutts> not the clock demo
03:44:55 <bolrod> I just downloaded it
03:45:23 <bolrod> doesn't matter..  at least I know I don't have to search for some other package
03:46:27 <twice11> Lemmih: Using LazyST it seems to work quite nicely, and about a factor
03:46:33 <twice11> of 4 faster than DiffArray.
03:46:41 <twice11> Lemmih: Thanks for that hint.
03:46:42 <dcoutts> bolrod, the 0.9.10 tarball from sf.net only has 3 cairo demos. the clock one is not amongst them. You must have got that clock demo from the darcs version
03:46:46 <isaacd> twicell: btw this is equivalent to your 'do' and maybe prettier:  liftM2 (:) calcHead calcTail
03:47:11 <bolrod> possibly
03:47:16 <bolrod> I didn't install it from source
03:47:25 <bolrod> I just downloaded the .debs
03:47:45 <dcoutts> ah, well maybe someone added it to the .debs
03:47:56 <dcoutts> I didn't know they contained any demos
03:48:36 <twice11> isaacd: Nice idea, but calcHead and calcTail are expressions of hust the right complexity for one line, so I won't change that.
03:49:20 <twice11> btw: The version including an STArray variant can be found at http://www.physik.fu-berlin.de/~karcher/brt2.hs (brt is for "back reference test")
03:49:22 <bolrod> no they don't .. I downloaded the .debs to install
03:49:30 <bolrod> and got the tar.gz and found that demo
03:49:36 <twice11> s/hust/just/
03:50:16 <bolrod> or did I..
03:50:17 <bolrod> hrm
03:51:13 <bolrod> well..  I probably downloaded it from the darcs yes
03:51:28 <twice11> So thanks again for your input. I have more work to do at home now.
04:12:13 <musasabi> What was the way to implement a counter in STM?
04:13:41 <musasabi> data Counter = ...; incCounter :: Counter -> STM (); decCounter -> Counter -> STM (); getCounter :: STM Int and with writes not blocking each other.
04:19:34 <kolmodin> musasabi: data Counter = C (TVar Int) ; incCounter (C ti) = readTVar ti >>= writeTVar ti . (+1)
04:19:54 <mathrick> how do I make multi-file modules? Just add the same "module Foo where" at the top of each file?
04:20:10 <xerox> mathrick: IIRC you can't
04:20:35 <mathrick> xerox: hmm, gentle intro suggests otherwise
04:27:35 <mathrick> maybe I really can't have multifile modules
04:28:28 <norpan> i don't think you can
04:36:13 <mathrick> if I have a file named Foo.hs, then import Foo should work directly, without specifying the filename, right?
04:38:44 <Lemmih> mathrick: With ghc?
04:39:06 <mathrick> yes
04:40:46 <Lemmih> mathrick: With --make, yes.
04:41:04 <mathrick> aha, and without it?
04:41:21 <mathrick> I want to get files that are as usable with ghci as possible
04:42:40 <Lemmih> ghc won't compile dependencies if you don't tell it to.
04:43:26 <isaacd> ghci will
04:43:41 <isaacd> if you load something with it that has dependencies
04:43:45 <mathrick> isaacd: well, it doesn't seem to, I think
04:44:02 <mathrick> *DictTree> :load "/home/mathrick/dm22/svn/Faith/src/DictTree.hs"
04:44:02 <mathrick> Could not find module `DictTreeShow':
04:44:02 <mathrick>   use -v to see a list of the files searched for
04:44:02 <mathrick>   (imported from /home/mathrick/dm22/svn/Faith/src/DictTree.hs)
04:44:07 <Lemmih> Using --interactive /is/ telling ghc to compile dependencies.
04:44:17 <mathrick> and there is a file DictTreeShow.hs in there
04:44:43 <isaacd> Is your current directory the correct one for that file?
04:44:43 <Lemmih> mathrick: Add /home/mathrick/dm22/svn/Faith/src to the import path?
04:45:24 <mathrick> Lemmih: how?
04:45:45 <mathrick> isaacd: ah, right, $PWD is wrong
04:45:54 <Lemmih> mathrick: -ipath
04:46:07 <dcoutts> dons, if you're about, I've got a Q about running the ghc regressesion test-sutie
04:46:49 <mathrick> Prelude> :load "/home/mathrick/dm22/svn/Faith/src/DictTree.hs"
04:46:50 <mathrick> ./DictTreeShow.hs: file name does not match module name `Main'
04:46:52 <mathrick> HUH!?
04:47:07 <mathrick> module DictTreeShow where
04:47:08 <dcoutts> dons, so I have to unpack the testsuite into the ghc build dir, do a full build of ghc (though not an install) and then run make boot in the toplevel testsuite dir, then finally the make in testsuite/tests/ghc-regres/
04:47:21 <vincenz> buongiorno gente
04:47:38 <dcoutts> dons, however the bit where I must be missing something is that then it's using ghc-inplace that points to stage1 !?
04:47:44 <dcoutts> so of course all the ghci tests fails
04:47:53 <dcoutts> and TH too
04:48:09 <dcoutts> if I make the ghc-inplace symlink point to stage2 then it all works
04:48:38 <dcoutts> so is one just supposed to do that bit manually? or have I been missing a step or something?
04:49:00 * dcoutts is trying to integrate the ghc testsuite into the gentoo ghc ebuild
04:50:39 <mathrick> isaacd: do you know why that happens?
04:56:14 <mathrick> I don't get it
04:56:31 <mathrick> why does it insist on DictTreeShow.hs being mismatched with Main?
04:56:43 <mathrick> there's not a single mention of Main anywhere
04:57:34 <Lemmih> Try pasting you session somewhere.
04:58:21 <Lemmih> *your
05:00:35 <mathrick> http://pastebin.com/675014
05:02:59 <mathrick> Lemmih: there
05:05:02 <norpan> mathrick: are you sure that's the file that is read in
05:05:19 <mathrick> norpan: I just checked $PWD, and they match
05:06:01 <Lemmih> mathrick: Works for me, except that DictTreeShow can't see the DictTree datatype.
05:06:41 <mathrick> hmm, one round of reloading files seems to have fixed it somewhat, in that it errors out now instead of not loading the file
05:07:31 <mathrick> argh
05:07:42 <mathrick> I thought mutually recursive modules were allowed?
05:08:02 <mathrick> how am I supposed to add some functionality in another file, when it dies on cyclic imports?
05:08:13 <mathrick> and without that cyclic import, DictTree is not in scope
05:08:41 <Lemmih> Either don't or write a boot file.
05:08:50 <norpan> but DictTree doesn't really need DictTreeShow, right
05:08:51 <mathrick> oh, what's that?
05:09:03 <mathrick> norpan: it does, because I want to show trees
05:09:07 <dcoutts> or don't use import chasing but specify all the modules in the cycle at once
05:09:10 <norpan> but it's you who needs it
05:09:19 <norpan> so just import DictTreeShow
05:09:24 <norpan> err :load it
05:09:28 <mathrick> norpan: but I want to hide it all
05:09:41 <norpan> hide it all, what do you mean?
05:09:42 <mathrick> why should user care about how my files are organised at all?
05:10:00 <norpan> just put everything in one file and be happy
05:10:05 <Lemmih> dcoutts: Does that work?
05:10:12 <dcoutts> Lemmih, with ghc, yes.
05:10:18 <dcoutts> (I believe so)
05:10:19 <mathrick> norpan: I want to have single DictTree import, as if it were in one file all, but for management purposes, want to split code into multiple files
05:10:32 <dcoutts> and with hugs it doesn't afaik
05:10:39 <mathrick> norpan: one big pile of shit file is hardly a definition of "happy"
05:10:43 <norpan> mathrick: put the datatype in a separate file then
05:10:43 <Lemmih> dcoutts: Really?
05:10:56 <norpan> and import that both from DictTree and DictTreeShow
05:10:56 <mathrick> dcoutts: how do I do that?
05:10:58 <dcoutts> Lemmih, I thought so, try it
05:11:05 <Lemmih> dcoutts: I can't make it work and the GHC source code indicates that it's impossible.
05:11:05 <mathrick> norpan: right, that might work
05:11:10 <norpan> mutually recursive modules are not recommended
05:11:22 * dcoutts tries to make an example
05:12:15 <mathrick> norpan: but here are also necessary
05:13:30 <norpan> because you need one module to compile the other (for type inference) so it's not easy
05:14:01 <Lemmih> It would be a neat SoC project.
05:14:24 <dcoutts> Lemmih, yep you're quite right, I had mis-remembered
05:14:38 <mathrick> norpan: but there's gotta be _some_ way of splitting code into multiple files
05:14:47 <mathrick> otherwise, Haskell would be a toy and not a serious language
05:14:51 <norpan> huh?
05:15:01 <norpan> one module per file
05:15:03 <norpan> like java
05:15:13 <mathrick> that's silly
05:15:20 <mathrick> I want to split some unrelated ops
05:15:27 <mathrick> so that it's easily manageable
05:15:50 <mathrick> why would show code for example care about what ops I can do on my tree at all?
05:15:51 <norpan> how would splitting them to different files make it more manageable
05:16:07 <mathrick> norpan: I don't need to see unrelated code, and more code fits on one screen
05:16:08 <norpan> mathrick: so put the data type in a separate module
05:16:15 <mathrick> I did, and that worked
05:16:21 <norpan> good
05:16:26 <norpan> then what is the problem :)
05:16:59 <mathrick> it feels hacky, and I'm not sure some other cyclic dep won't creep in at another point
05:17:54 <Lemmih> You can write a boot file.
05:17:57 <dcoutts> I think having cyclic modules is generally a sign of a dodgy design, there are some cases where it makes sense but not many
05:18:38 <mahogny> actually, quite a few cases. of course, you can always lump up all modules in a single file but that sucks badly
05:18:43 <norpan> i have no problem putting a lot of code in the same file, but then i use a good editor
05:19:08 <sieni> unit testing might be annoying with large files
05:19:11 <mahogny> my rule is 1000 lines of code in a single file, at most. unless it's impossible to split it up
05:19:12 <mathrick> Lemmih: again, how do I do it / where do I read about it?
05:20:38 <mathrick> norpan: editor has little to do with that
05:20:45 <mathrick> you simply should split unrelated code
05:20:46 <Lemmih> mathrick: http://haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#mutual-recursion
05:20:57 <mathrick> if anything, to help your SCM work better
05:21:15 <dcoutts> but of course if it's unrelated code then you can split it easily, you've only got a problem if it's inter-dependent
05:21:28 <norpan> exactly
05:21:31 <norpan> not what i call unreleated
05:21:57 <dcoutts> in which case there's a resonable argument that they should be in the same module since you can't really say their very modular if they depend on each other
05:22:24 <norpan> and with a good editor it doesn't matter if code is in separate files or in the same file
05:22:39 <norpan> since you will be using tags or similar to navigate anyway
05:22:46 <mahogny> omg the ghc way for mutual recursion is a mess
05:22:54 <mathrick> dcoutts: that's hardly interdependent
05:23:10 <dcoutts> mathrick, I don't get what you mean
05:23:18 <mathrick> I wanted to split out some ops on a datatype, zOMG interdependent!
05:23:53 <dcoutts> if two modules depened on each other they are interdependent, no? are we talking about the same thing?
05:24:05 <mahogny> dcoutts, it makes sense that it is the same module, but there is no natural law stating that module==file must be true
05:24:19 <dcoutts> sure
05:24:34 <dcoutts> you can imagine two modules in one file
05:24:41 <mathrick> dcoutts: yes, but they only import each other because haskell requires me to do it that way, not because they truly are interdependent
05:25:06 <mahogny> dcoutts, that's a really perverse example, unless you code in java...
05:25:20 <norpan> but you found an even cleaner separation that makes no use of cyclic modules
05:25:27 <dcoutts> what's the difference here betwee "truly interdependent" and the need for the two modules to import each other?
05:25:57 <mathrick> dcoutts: because the _only_ common dependence they have is that they both define ops on the same datatype
05:25:58 <norpan> importing a module just for re-exporting it
05:26:11 <jip> olliej: around?
05:26:21 <mathrick> let's hope norpan solution doesn't break later
05:26:22 <olliej> jip: yup
05:26:27 <norpan> it won't
05:26:29 <mathrick> *norpan's
05:26:35 <dcoutts> mathrick, and the ops don't use each other?
05:26:43 <jip> olliej: yeah, of course i am using -O :) what hardware do you have, and which game rom, did you test?
05:26:43 <norpan> i use that layout all the time
05:26:48 <norpan> put data type in one file
05:26:52 <norpan> put show instance in one file
05:26:57 <norpan> put other function in another file
05:27:07 <mathrick> dcoutts: nope
05:27:09 <norpan> make top module that imports all other and re-exports them
05:27:11 <dcoutts> sounds like they should be independent and you shouldn't need to have them import each other
05:27:11 <olliej> jip 2.8g p4, with DropZone
05:27:29 <dcoutts> one imprts the other to get the type definitions
05:27:29 <dons> dcoutts: there's a testsuite argument that says which compielr to use.
05:27:44 <dons> i.e. you don't need to have the testsuite in the smae build tree even as the ghc you want to test
05:27:50 <norpan> then user can choose to get the whole lot or just the data type or data type + functions but define his own show
05:27:50 <olliej> jip: it animated very smoothly -- though at 100% cpu time :)
05:27:53 <norpan> etc
05:28:03 <dcoutts> dons, so is the standard thing to do to specify make HC=../../../stage2/ghc-inplace ?
05:28:11 <dons> set the TEST_HC="${WRKSRC}/ghc/compiler/stage2/ghc-inplace"
05:28:33 <dons> TEST_HC is magic to the testsuite build system
05:28:37 <norpan> but class instance + module system doesn't really work together
05:28:43 <dons> also, EXTRA_RUNTEST_OPTS="--output-summary=${REGRESS_RESULT}"
05:28:46 <norpan> you can't hide instances when importing a module
05:28:49 <dcoutts> dons, ok, fair enough, and that's what the nightly builds do?
05:28:53 <dons> to get the output in a file you diff against
05:28:59 <dcoutts> ok
05:28:59 <dons> yeah, i think so
05:29:06 <dcoutts> thanks dons 
05:29:09 <dons> check out the nightly build dir scripts, and check to be certain.
05:29:13 <mahogny> I guess a real example which makes more sense is any MVC style program. M -> V and V -> M, both truly interchangable. that's one case when circular dependence comes in handy, allthough it can be hacked out
05:29:15 <dons> its what i do for the openbsd test, anyway
05:29:21 <jip> olliej: hm... i have a 1.2g athlon. i suppose it's possible that your p4 is 10 times faster then my athlon :|
05:29:48 <olliej> jip: i spent some time trying to profile it -- but can i get it to work with gtk2hs? noooo
05:30:12 <jip> olliej: that's why there is the ascii version! edit Main.hs to import AsciiTest03 and change main = test03
05:30:21 <norpan> mahogny: what do the arrows in M -> V and V -> M mean
05:30:21 <dcoutts> olliej, building a profiling version of gtk2hs is a pain, I've not set up the build system to do it properly
05:30:27 <jip> olliej: run it in a fullscreen xterm with text size set to tiny
05:30:29 <mahogny> norpan, data flow
05:30:39 <mahogny> norpan, and calls, depending on how you code it
05:30:41 <olliej> dcoutts: yeah -- i spent some time trying to convince it to :)
05:30:56 <norpan> mahogny: yes, but the model should know nothing about the view
05:31:00 * dcoutts curses automake
05:31:01 <jip> dcoutts: how how's it going? how is hide?
05:31:15 <xerox> dcoutts: hey!  Sorry I fell asleep :-)
05:31:22 <dcoutts> xerox, ha!
05:31:27 <dcoutts> jip, we're working on the new gtk2hs tree view api
05:31:35 <xerox> I fell asleep after like an hour of this swf: http://haskell.galois.com/~paolo/tmp/loituma.swf
05:31:40 <dcoutts> jip, we need that new stuff for hIDE
05:31:41 * xerox laughs
05:31:41 <mahogny> norpan, I prefer my hacked version without the controller and then it happens that the model gets to know the view
05:31:42 <jip> dcoutts: i thought you finished the tree api a while ago?
05:32:00 <xerox> Cale: I learnt to sing it.... :-P
05:32:03 <dcoutts> jip, we were still discussing it, and finnishing off the implementations of the stores
05:32:14 <norpan> mahogny: in what way does it "know it"
05:32:17 <jip> dcoutts: cool. did you see my gtk2hs nintendo gameboy emulator?
05:32:21 <dcoutts> jip, it's testable now if you want to experiment with it?
05:32:28 <mahogny> norpan, can initiate sending of data to it
05:32:30 <dcoutts> jip, do I didn't, sounds nice
05:32:32 <jip> dcoutts: not sure i need treeview right now
05:32:34 <dcoutts> do/no
05:32:39 <xerox> dcoutts: indeed, jip's emulator is cool :D
05:32:44 <dcoutts> great!
05:32:54 * dcoutts hopes for some screenshots for the gtk2hs website
05:32:55 <norpan> mahogny: so the view registers callbacks with the model
05:32:57 <olliej> jip: how do i make cterm use a tiny font? (i don't use xterm, or play with my terminal settings frequently ;) )
05:33:08 <norpan> still no need for the model to know anything about the view
05:33:10 <olliej> s/cterm/xterm
05:33:10 <jip> dcoutts: http://www.mutantlemon.com/omegagb/devlog/
05:33:23 <mahogny> norpan, yes, that's essentially how one codes it to avoid the dependcy; but read "can be hacked out". this is the hack
05:33:27 <jip> olliej: i think it's control+right-click
05:33:33 <norpan> it's no hack; it's good design
05:33:53 <dcoutts> jip, looks cool
05:34:00 <mahogny> norpan, it's a lot of extra code and it's usually questionable if it needs to be there
05:34:15 <norpan> extra code? one callback registration?
05:34:36 <mahogny> one registration for each callback. that's bad enough for me
05:34:49 <norpan> so put all callbacks in the same registration
05:34:57 <olliej> jip: that's cool (the ascii mode one)
05:35:15 <norpan> that's essentially what you do when you make the model "aware" of the view
05:35:25 <jip> olliej: i know :D you should be able to profile it now
05:35:37 <mahogny> norpan, I still find it tedious, and as I said, I doubt the advantage when you can just give it everything it wants with one import
05:36:19 <dcoutts> jip, so presumably it's a bitmap thing for the game window
05:36:29 <norpan> instead of giving it everything you want with one callback?
05:36:31 <jip> dcoutts: i'm using the code from the fastdraw demo
05:36:46 <dcoutts> jip, so you're using the Pixbuf array interface
05:36:59 <jip> dcoutts: yep, doing exactly what fastdraw does
05:37:01 <norpan> anyway
05:37:03 <dcoutts> cool
05:37:04 <mahogny> norpan, not that I doubt the use of callbacks, but the usefulness has to be judged on case by case basis
05:37:29 <dcoutts> jip, does that feel like an ok interface for your purpose?
05:37:33 <norpan> and by the ability to do circular dependencies :)
05:37:46 <mahogny> norpan, yes, currently :)
05:39:16 <olliej> dons: almost have higher kinded types going-ish
05:39:23 <jip> dcoutts: i haven't really worked with it a lot. just copy and pasted the code from fastdraw without really reading through the code even. but i seem to be able to do what i need so i guess it's ok :)
05:39:33 <norpan> it should not be impossible to implement in the compiler though
05:39:54 <jip> dcoutts: if there is anyway to increase the speed of fastdraw though, make it happen please! :)
05:39:54 <norpan> it just has to compile all circular modules simultaneously
05:48:08 <jip> olliej: which version of ghc are you running btw?
05:48:45 <olliej> jip: 6.4.something
05:48:53 <olliej> jip: binaries from haskell.org
05:50:05 <dcoutts> jip, are you finding that it's a bottleneck?
05:50:25 <dcoutts> jip, you can make it a bit faster by doing unsafe indexing
05:50:54 <dcoutts> jip, and if you know that only small parts of the screen have changed then you can only blit those bits to the screen
05:54:54 <jip> dcoutts: i'm not sure if it's a bottleneck yet. i don't think it's the major one at least. i'll try doing unsafe indexing. i must update the entire screen each frame
05:55:03 <jip> olliej: windows?
05:55:55 <olliej> jip: linux
05:56:10 <jip> oh right\
05:56:23 <jip> olliej: have you tried profiling it yet? :)
05:56:27 <olliej> jip: yup
05:56:36 <jip> any interesting results?
05:56:50 <olliej> jip: Ascii test takes 76% of the time
05:57:13 <olliej> jip: machineCpuexecute' takes 10.8%
05:57:53 <olliej> jip: i'm guessing that ghc profiling counts actual time spent in a function, so i'll assume that ascii tests takes so long because it's IO bound
05:58:24 <olliej> jip: i wish i could work out which of  the instructions were taking all the time
06:00:09 <olliej> jip: oh, and executeInstruction uses 5.6% of the time
06:00:37 <jip> hm...
06:04:00 <jip> i think i'm gonna try getting joypad emulation working now :D
06:04:49 <jip> perfomance optimization can wait
06:06:32 <olliej> jip: i'll procrastinate, and see if i can do something for performance -- if i find anything i'll tell you :)
06:06:56 <jip> hm... cool thanks!
06:16:40 <dcoutts> jip, I wonder if that GB simulator could be made into an interesting undergrad practical...
06:17:04 <jip> dcoutts: hm... i would have no idea
06:17:39 <dcoutts> eg one could give the students the GUI and some other IO components and the students could write the CPU sim part perhaps
06:17:59 <dcoutts> as part of an architecture course
06:18:05 <olliej> dcoutts: hehe -- i favour raytracers :)
06:18:28 * xerox favouts L-Systems :-D
06:18:31 <xerox> *r
06:19:00 <dcoutts> we're already doing that one xerox!
06:19:07 <xerox> Hell yeah!
06:19:58 <olliej> :)
06:20:22 <neologism> @hoogle type a -> a
06:20:23 <lambdabot> Did you mean: Type a -> a
06:20:23 <lambdabot> Prelude.id :: a -> a
06:20:23 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
06:20:56 <norpan> @hoogle (a,b,c) -> b
06:20:57 <lambdabot> No matches, try a more general search
06:21:05 <jip> anyone see anything obvious modifications that can be done to speed up this function?
06:21:05 <jip> http://rafb.net/paste/results/v2iGqc54.html
06:21:06 <norpan> @hoogle Type (a,b,c) -> b
06:21:07 <lambdabot> No matches, try a more general search
06:21:12 <norpan> @hoogle Type (a,b) -> b
06:21:13 <lambdabot> No matches, try a more general search
06:21:15 <norpan> huh
06:41:06 <robokop> @ hoogle (a,b) -> b
06:41:09 <robokop> @hoogle (a,b) -> b
06:41:10 <lambdabot> Prelude.snd :: (a, b) -> b
06:41:10 <lambdabot> Prelude.uncurry :: (a -> b -> c) -> (a, b) -> c
06:41:10 <lambdabot> Prelude.fst :: (a, b) -> a
06:41:23 <robokop> @hoogle (a,b,c) -> b
06:41:24 <lambdabot> No matches, try a more general search
06:43:04 <Lemmih> jip: What's the type of 'scx'?
06:49:11 <jip> Lemmih: Word8
06:50:12 <xerox> dcoutts: ping
06:50:19 <dcoutts> xerox, pong
06:50:20 <Lemmih> jip: You could move some of the 'fromIntegral's out of 'getPixel'.
06:51:29 <xerox> dcoutts: query
06:51:55 <jip> Lemmih: thanks i'll try that
06:53:16 <jip> Lemmih: i'm using a 2 dimensional array for the irqStateDisplay. i only work with entire rows at a time though, updating or reading them. do you think i would gain performance if i switch to using an array of an array, instead of a 2 dimensional array?
06:54:12 <dcoutts> xerox, yes?
06:54:17 <xerox> dcoutts: do you see my query?
06:54:34 <dcoutts> xerox, no
06:54:38 <xerox> Hmmm.
06:54:41 <dcoutts> where?
06:54:47 <xerox> Here, on freenode.
06:55:26 <xerox> dcoutts: I see you
07:06:09 <olliej> woooo, compiled GHC.ST
07:24:12 <musasabi> Is it possible to write a "modifyMVarSTM_ :: MVar a -> (a -> STM a) -> STM ()" ?
07:31:14 <ski> dunno .. isn't STM supposed to be composable, so shouldn't it work with doing a read and a write ?
07:31:54 <musasabi> It is an MVar since it is important that it doesn't have transactional semantics.
07:32:04 <musasabi> putting a TVar there kills performance.
07:32:21 <dcoutts> @type [| 1 |]
07:32:22 <lambdabot> parse error on input `|'
07:32:28 <dcoutts> grumble
07:32:44 * dcoutts can't show off fancy generating extensions
07:33:05 <dcoutts> > $( [| 1 |] )
07:33:06 <lambdabot>  parse error on input `$'
07:33:13 <dcoutts> nope
07:33:20 <davidhouse> aww.
07:33:23 <davidhouse> TH is so cool :
07:33:25 <davidhouse> *:)
07:34:04 <musasabi> ski: basically I have "type D k v = MVar (Dimpl k v); data Dimpl k v = D_ (TArray Int [(k,v)]) Some Statistics"
07:34:17 <dcoutts> $((\n -> [| \x -> $(genex_power n [|x|] ) |]) 4) 3
07:34:18 <dcoutts> 81
07:34:25 <ski> erm, i just noticed it was an 'MVar', yes
07:34:36 <dcoutts> > 3^4
07:34:37 <lambdabot> 81
07:34:48 <musasabi> ski: if I use a TVar instead of MVar there it means that every transaction will read (or read/write) the same TVar which is slow.
07:35:24 <davidhouse> dcoutts, what's genex_power?
07:35:28 <ski> would it be faster if implemented primitively ?
07:35:34 <dcoutts> and genex_power gives me perfect code:
07:35:36 <dcoutts> printExpQ $ genex_power' 4
07:35:40 <dcoutts> \x_0 -> x_0 GHC.Num.* (x_0 GHC.Num.* (x_0 GHC.Num.* (x_0 GHC.Num.* 1)))
07:36:01 <dcoutts> davidhouse, it's the generating extension of the power function
07:36:14 <davidhouse> oh, i see.
07:36:19 <davidhouse> powers the old-fashioned way.
07:36:38 <musasabi> ski: to my limited understanding the problem is that every transaction needs to access the same TVar thus creating much contention.
07:36:42 <dcoutts> it's a trivial example of partial evaluation
07:37:20 <musasabi> (since all inserts update the statistics writes are common, but spurious writes don't matter)
07:37:32 <ski> musasabi : every transaction at all ?
07:38:11 <musasabi> ski: every transaction using that data structure - reducing it to the same as TVar (Data.Map.Map k v)
07:38:29 <musasabi> I would like to obtain a datastructure with real concurrent updates.
07:38:34 <ski> mhm
07:38:51 * ski hasn't really used STM yet
07:38:58 <xerox> Sent!!
07:43:57 <audreyt> what's the best replacement for a mutable IntMap?
07:44:06 <audreyt> IORef IntMap is, like, very slow.
07:44:21 <olliej> muwhahaha, i just got GHC.Arr to compile
07:44:58 <audreyt> the JudyL with John's HsJudy is the best one I can find currently, but it's LGPL
07:45:08 <audreyt> and I wonder if there are something like that somewhere for Haskell.
07:45:17 <audreyt> (mutable sparse extensible arrays)
07:46:12 <audreyt> (IORef Sequence is possible, but Sequence is not sparse)
07:47:25 <musasabi> audreyt: you might want to ask for a BSD version of HsJudy, that would be very nifty for other people too.
07:47:42 <audreyt> musasabi: Judy itself is LGPL
07:47:54 <audreyt> yeah, maybe I should to talk to HP
07:47:58 <audreyt> copyright holder of Judy
07:48:12 <audreyt> but it probably can't easily happen, certianly harder than if it's an individual
07:49:52 <musasabi> audreyt: point. Is it shared lib or statically linked?
07:49:53 <Philippa_> it may well be that there's at least only one individual in the organisation you need to talk to. I suspect if they picked LGPL they want it to stay that way though
07:50:24 <musasabi> If it is shared and the haskell binding is BSD then there should be no problem, I think.
07:51:04 <audreyt> musasabi: yeah, I'm betting on that.
07:51:52 <audreyt> but in any case... HsJudy itself is also shared
07:52:02 <audreyt> if it's properly cabalized
07:53:05 <musasabi> audreyt: seems like only the bitset api is wrapped, and it lacks the fancier interfaces.
07:54:05 <audreyt> musasabi: john says he's working on that
07:54:13 <audreyt> and the other apis are not really different
07:54:23 <audreyt> fancier interfaces is something I think i need to start working on
07:54:31 <audreyt> but if there is an alternative, I'd switch now
07:54:57 <audreyt> (HashTable is acceptable, though not as performant as JudyHS)
07:55:38 <audreyt> (but currently there is no equivalent for MutableIntMap)
07:57:48 <roconnor> IntMap ?= Map Int
07:58:38 <audreyt> a bit more optimized, I think
07:58:53 <roconnor> extensionally equivalent
07:59:22 <norpan> getting fast implementations of maps arrays and the likes is very good
07:59:50 <norpan> i need fast strings
07:59:58 <norpan> and i want the normal string functions to work
08:00:04 <norpan> is there any work on a String class
08:00:53 <sethk> norpan, has you looked at dons' new FPS?
08:01:02 <norpan> i haven't
08:01:12 <neologism> > minimum [Just 1, Nothing, Just 2]
08:01:13 <lambdabot> Nothing
08:01:15 <neologism> why?
08:01:22 <norpan> Nothing is less than Anything
08:01:23 <sethk> norpan, there's stuff about it on the mailing list over the past few days.
08:01:35 <norpan> ok
08:01:35 <neologism> what if I want minimum from Just values?
08:01:37 <sethk> norpan, check, it may do what you need
08:01:40 <norpan> filter isJust
08:02:01 <davidhouse> neologism: liftM minimum . sequence . filter isJust
08:02:25 <davidhouse> > liftM minimum . sequence . filter isJust $ [Just 1, Nothing, Just 2]
08:02:27 <lambdabot> Just 1
08:02:41 <metaperl> wouldnt a type constructor better be called a "type descriptor"? You can't construct anything with it. It just described what a data constructor builds
08:02:55 <sethk> metaperl, it constructs a value
08:02:58 <davidhouse> metaperl, no, they construct types.
08:03:11 <metaperl> but you call the data constructor to construct
08:03:14 <davidhouse> in the same way that data constructors construct values.
08:03:24 <davidhouse> sethk, they don't construct a value.
08:03:25 <metaperl> and it returns something of the type of the type "constructor"
08:03:31 <sethk> davidhouse, yes, wrong word
08:03:35 <roconnor> @hoggle catMaybe
08:03:36 <lambdabot> Maybe.catMaybes :: [Maybe a] -> [a]
08:03:56 <norpan> > minimum []
08:03:56 <roconnor> > minimum $ catMaybes [Just 1, Nothing, Just 2]
08:03:57 <lambdabot> Add a type signature
08:03:57 <lambdabot> 1
08:04:01 <davidhouse> think of type constructors like functions. you give them a type, they give you a new type. e.g. Maybe: you give it a type a, it gives you a Maybe a.
08:04:03 <norpan> > minimum [] : Int
08:04:04 <lambdabot>  Not in scope: data constructor `Int'
08:04:07 <norpan> > minimum [] :: Int
08:04:08 <lambdabot> Exception: Prelude.minimum: empty list
08:04:14 <vincenz> > 2
08:04:16 <lambdabot> 2
08:05:09 <davidhouse> metaperl: in fact, type constructors have a "type" in this way. because "type of type constructor" is cumbersome, we call it "kind"
08:05:16 <davidhouse> e.g. Maybe has kind * -> *
08:05:37 <davidhouse> because you give it one type (say Int), it will give you a new type (Maybe Int)
08:05:49 <davidhouse> (and in fact it's a necessary condition for all monads to have kind * -> *)
08:06:37 <davidhouse> you can play around with kinds with :kind in GHCi.
08:06:46 <davidhouse> most type constructors have kind *.
08:06:50 <davidhouse> but try with, say, State.
08:06:50 <neologism> how can I (+) (Just 1) (Just 2) using liftM/
08:07:01 <davidhouse> neologism: liftM2
08:07:01 <norpan> liftM2
08:07:15 <neologism> ah.. liftM2 ;)
08:07:48 <norpan> yes, liftM2
08:07:59 <neologism> I tried with liftM and wondered why it doesnt work
08:08:08 <i|> > fmap (fmap (uncurry (+))) [[(1,2),(3,4)],[(5,6)]]
08:08:09 <lambdabot> [[3,7],[11]]
08:08:27 <davidhouse> challenge for the day: write a generic liftMn using template haskell.
08:08:47 <norpan> very seldom would you need stuff above liftM2 though
08:09:05 <davidhouse> true.
08:09:12 <norpan> ok liftM3 for ternary operators
08:09:19 <norpan> like ?:
08:09:29 <davidhouse> well, all operators in haskell are binary.
08:09:46 <davidhouse> but you could do something like:
08:10:01 <norpan> @hoogle a -> a -> a -> a
08:10:02 <lambdabot> No matches, try a more general search
08:10:10 <norpan> isn't hoogle right?
08:10:20 <norpan> @hoogle a -> a -> a
08:10:21 <lambdabot> Prelude.asTypeOf :: a -> a -> a
08:10:21 <lambdabot> Prelude.const :: a -> b -> a
08:10:21 <lambdabot> Prelude.seq :: a -> b -> b
08:10:26 <norpan> huh
08:10:34 <davidhouse> > liftM3 foldr (Just 0) (Just (+)) (Just [1,2,3])
08:10:35 <lambdabot>  add an instance declaration for (Show (a -> a -> a))
08:10:49 <neologism> norpan: there's a web interface for hoogle
08:10:50 <norpan> foldr1 perhaps
08:11:00 <ski> > return (+) `ap` Just 1 `ap` Just 2
08:11:01 <lambdabot> Just 3
08:11:02 <davidhouse> that would make it binary.
08:11:14 <davidhouse> boo, ap.
08:11:22 <norpan> ap is nince
08:11:23 <norpan> nice
08:11:33 <davidhouse> ap is nice if you need liftMn n>3.
08:11:44 <davidhouse> but you yourself said that's not likely to happen ;)
08:12:12 <davidhouse> ap is annoying because there aren't many functions with type m (a -> a ->a)
08:12:20 <davidhouse> so you have to return anything you want first
08:12:32 <davidhouse> it'd be better if ap did the returning for you.
08:12:51 <norpan> but then it wouldn't be useful in chains
08:13:03 <ski> davidhouse : then it'd just be 'liftM', no ?
08:13:06 <davidhouse> @type ap
08:13:07 <lambdabot> forall b (m :: * -> *) a.
08:13:07 <lambdabot> (Monad m) =>
08:13:07 <lambdabot> m (a -> b) -> m a -> m b
08:13:12 <ski> @type liftM
08:13:14 <lambdabot> forall r (m :: * -> *) a1.
08:13:14 <lambdabot>    (Monad m) =>
08:13:14 <lambdabot>    (a1 -> r) -> m a1 -> m r
08:13:15 <jip> "There is no good reason for an application ever to call this function."
08:13:19 <davidhouse> oh, good point. it's still ugly.
08:13:46 <norpan> > (+) `liftM` Just 1 `ap` Just 2
08:13:48 <lambdabot> Just 3
08:13:53 <norpan> there you go
08:14:18 <davidhouse> > let (<+>) = liftM (+) in Just 1 <+> Just 2
08:14:19 <lambdabot> Couldn't match `(->) t' against `Maybe'
08:14:28 <norpan> liftM2
08:14:31 <davidhouse> > let (<+>) = liftM2 (+) in Just 1 <+> Just 2
08:14:32 <lambdabot> Just 3
08:14:33 <davidhouse> yeh.
08:14:47 <davidhouse> > let (<+>) = liftM2 (+) in Just 1 <+> Just 2 <+> Just 3 <+> Just 4
08:14:49 <lambdabot> Just 10
08:14:54 <i|_> ap is nice when all you have is that, const, and fix.
08:15:38 <norpan> id = ap const const
08:15:51 <davidhouse> i|_, i didn't think you needed fix
08:16:02 <norpan> you need fix
08:16:11 <norpan> buy from guy at corner
08:16:38 <vincenz> ap'u
08:16:42 <ihope> (\x -> (\y -> x (y y)) (\y -> (x (y y)))) is a type error.
08:17:05 <davidhouse> @pl (\x -> (\y -> x (y y)) (\y -> (x (y y))))
08:17:05 <lambdabot> ap (. join id) (. join id)
08:17:10 <davidhouse> pfft.
08:17:16 <vincenz> ihope: the error is (y y0
08:17:22 <davidhouse> > fix (0:)
08:17:23 <lambdabot> [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
08:17:23 <lambdabot> 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
08:17:23 <lambdabot> 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
08:17:23 <lambdabot> 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
08:17:23 <vincenz> ihope: there is no function that can be applied to itself
08:17:26 <lambdabot> 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
08:17:27 <davidhouse> oops
08:17:29 <lambdabot> [6 @more lines]
08:17:33 <davidhouse> > take 20 $ fix (0:)
08:17:34 <ihope> vincenz: id
08:17:35 <lambdabot> [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
08:17:37 <ihope> return
08:17:39 <ihope> const
08:17:42 <vincenz> ihope: except for id
08:17:48 <ihope> And return and const and...
08:17:53 * vincenz ponders
08:17:55 <davidhouse> > take 20 $ ap (. join id) (. join id) (0:)
08:17:56 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a1
08:17:56 <lambdabot>   Expected type: a -> a -> a1
08:17:56 <lambdabot>   Inferred type: a -> a
08:18:11 <vincenz> const const 1
08:18:16 <vincenz> > const const 1 2 3
08:18:17 <lambdabot> 2
08:18:22 <vincenz> > const const const 1 2 3 4
08:18:23 <lambdabot>  add an instance declaration for (Num (t -> t1 -> a))
08:18:29 <vincenz> > const const const 1 2 3
08:18:30 <lambdabot>  add an instance declaration for (Num (t -> a))
08:18:32 <vincenz> > const const const 1 2
08:18:33 <lambdabot> 1
08:18:49 <davidhouse> @type const const const
08:18:50 <lambdabot> forall a b. a -> b -> a
08:18:56 <ihope> const const const = const
08:19:01 <davidhouse> yes.
08:19:04 <vincenz> @type const const const const
08:19:05 <lambdabot> forall b a b1. b -> a -> b1 -> a
08:19:09 <vincenz> @type const const
08:19:10 <lambdabot> forall a b b1. b1 -> a -> b -> a
08:19:12 <ihope> const const const (const const const) (const const const) :-)
08:19:14 <vincenz> yeah
08:19:18 <vincenz> const const = const const const const
08:19:24 <vincenz> @type const const
08:19:25 <lambdabot> forall a b b1. b1 -> a -> b -> a
08:19:27 <davidhouse> const const = const id
08:19:31 <ski> > (\const -> const const 1 2 3) const
08:19:32 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1 -> t2 -> t3 -> t4
08:19:32 <lambdabot>   Expected type: t
08:19:32 <lambdabot>   Inferred type: t -> t1 -> t2 -> t3 -> t4
08:20:17 <ski> so, there is no *monomorphic*instance* of a function that can be applied to itself
08:20:28 <norpan> @type fix
08:20:30 <lambdabot> forall a. (a -> a) -> a
08:20:32 <ihope> Yeah, I think that's true.
08:21:07 <ski> (in Haskell, i.e. .. OCaml allows this with a flag)
08:21:09 <norpan> @type (\f -> f f)
08:21:10 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
08:21:10 <lambdabot>   Expected type: t
08:21:20 <ihope> OCaml allows infinite types?
08:21:20 <ski> (and there's always the recursive type trick)
08:21:22 <norpan> @type (\f x -> f x f)
08:21:24 <lambdabot>   Occurs check: cannot construct the infinite type: t = t1 -> t -> t2
08:21:24 <lambdabot>   Expected type: t
08:21:30 <ski> ihope : 'ocaml -rectypes' does
08:21:37 <ihope> Ah yes, the recursive type trick.
08:21:51 <norpan> @doc fix
08:21:52 <lambdabot> fix not available
08:22:31 <ski> (ihope : iirc, it was needed anyway for their OO system, and the flag switch just allows it in other places, as well)
08:22:33 <norpan> @type let x = f x in x
08:22:35 <lambdabot> Not in scope: `f'
08:22:48 <norpan> @type let f = let x = f x in x in f
08:22:50 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t
08:22:50 <lambdabot>   Expected type: t -> t
08:22:58 <davidhouse> @type \f -> let x = f x in x
08:22:58 <ihope> data Self a = Self (Self a -> a); selfAp = \(Self x) -> x (Self x) -- selfAp (Self selfAp) :: forall a. a
08:22:59 <lambdabot> forall t. (t -> t) -> t
08:23:02 <vincenz> OOOOOOOOOOOH
08:23:07 <bolrod> oh?
08:23:09 <vincenz> Don't you love it when you discover something new and tasty?
08:23:10 <ski> ihope : :)
08:23:15 <jip> how do i do like nested guards?
08:23:19 * vincenz bought a new kind of apple at the shop, it tastes great!
08:23:21 <ihope> jip: &&?
08:23:28 <bolrod> haha
08:23:37 <vincenz> fiji apple
08:23:39 <jip> ihope: no, i don't like that style
08:24:04 <bolrod> is there any cool tutorial on gtk2hs
08:24:05 <bolrod> ?
08:24:11 <Lemmih> musasabi: You can write it with unsafeCoerce#
08:24:22 <bolrod> or just  'read the source code' or something ;)
08:24:40 <jip> bolrod: there's the hello world on the website, and read the demos that come with it
08:24:50 <davidhouse> the gtk2hs examples are rocking.
08:25:02 <bolrod> a bit
08:25:03 <davidhouse> ooh, speaking of which, i must get that installed.
08:25:04 <jip> bolrod: if you are already with gtk from another programming language, then this should be everything you need to get started
08:25:53 <bolrod> never worked with gtk
08:25:57 <bolrod> code that is
08:26:40 <ihope> fix = \x -> selfAp (Self (\y -> x (y y))) -- I think this causes a stack overflow at compile time
08:27:12 <ihope> Stuff like that's why @djinn doesn't like recursive types.
08:27:45 <jip> bolrod: maybe read through the pygtk tutorial, just to get the jist of gtk, how it does signals and packing and stuff
08:28:40 <bolrod> ;o
08:30:25 <bolrod> maybe I should go read up on java again though ;/ since we're probably going to use that next
08:33:18 <ihope> @djinn-add data Foo a = Not (Not a) : a
08:33:19 <lambdabot> Cannot parse command
08:36:54 <olliej> ihope: that wouldn't work as Not is not a type
08:39:11 <dcoutts> davidhouse, good! :-)
08:39:19 <Cale> @djinn-add data Foo a = Foo (Not (Not a)) a
08:39:41 <dcoutts> bolrod, we're sort of working on one, but yeah, the demos are the best place to start
08:39:55 <dcoutts> bolrod, there's also a recent presentation on the gtk2hs web site
08:40:20 <dcoutts> http://haskell.org/gtk2hs/archives/2006/03/06/introductory-presentation/
08:40:56 <ihope> @djinn-del Foo
08:41:09 <ihope> @djinn-add data Foo a = (Not (Not a)) : a
08:41:10 <lambdabot> Cannot parse command
08:41:15 <dcoutts> bolrod, specifically: http://haskell.org/gtk2hs/docs/presentation/nottingham-06/
08:42:44 <olliej> @djinn-add data Foo a = ((Not (Not a)) : a)
08:42:45 <lambdabot> Cannot parse command
08:46:01 <ihope> @type \x -> x :: Int
08:46:03 <lambdabot> Int :: Int -> Int
08:46:27 <ihope> @. type pl \x -> x :: Int
08:46:28 <lambdabot> parse error on input `::'
08:48:52 <ihope> @pl \x -> x :: Int
08:48:53 <lambdabot> (:: Int)
08:49:06 <davidhouse> heh. that's not a function
08:49:31 <ihope> Shouldn't it be, though?
08:49:33 <davidhouse> > (::Int) 4
08:49:33 <lambdabot>  parse error on input `::'
08:49:47 <ihope> (:: a) = id :: a -> a
08:49:57 <davidhouse> sure.
08:50:07 <ihope> Not that that's valid Haskell.
08:50:20 <ihope> data [a] = [] | a : [a] isn't valid Haskell either.
08:50:32 <davidhouse> no, you'd need some kind of metacode lib,.
08:51:06 <davidhouse> it would be very cool if we could interact directly with the compiler's symbol table.
08:51:26 <ihope> But I'd like (:: a) to be implemented...
08:51:34 <DeliQ> @hoogle a -> IO a
08:51:35 <lambdabot> Control.Exception.evaluate :: a -> IO a
08:51:35 <lambdabot> Control.Concurrent.MVar.swapMVar :: MVar a -> a -> IO a
08:51:35 <lambdabot> Distribution.PackageDescription.withLib :: PackageDescription -> a -> (Library -> IO a) -> IO a
08:51:41 <Lemmih> ihope: Why?
08:51:54 <davidhouse> DeliQ: or return
08:51:56 <ihope> Why not?
08:52:12 <Lemmih> ihope: When would first-class type annotations be useful?
08:52:13 <DeliQ> strange it doesn't mention return ..
08:52:15 <ihope> DeliQ: yeah, return's probably what you want
08:52:23 <davidhouse> it doesn
08:52:27 <davidhouse> 't know IO's a monad
08:52:37 <ihope> @hoogle a -> [a]
08:52:38 <lambdabot> Prelude.repeat :: a -> [a]
08:52:38 <lambdabot> List.intersperse :: a -> [a] -> [a]
08:52:38 <lambdabot> Prelude.(:) :: a -> [a] -> [a]
08:52:48 <davidhouse> or how about infix type constructors. that'd be nice :)
08:52:54 <ihope> It doesn't seem to know [] is a monad either.
08:53:11 <Lemmih> davidhouse: We got that already.
08:53:12 <ihope> @hoogle a -> Maybe a -- lemme guess: no Just
08:53:12 <lambdabot> Hoogle Error: Parse Error: Unexpected character '-- lemme g'
08:53:13 <davidhouse> so we can do arrows with the proper syntax.
08:53:20 <davidhouse> Lemmih: type, not data
08:53:25 <Lemmih> davidhouse: Yes.
08:53:38 <davidhouse> Lemmih: ooh :) but that's not hs98, right?
08:53:51 <Lemmih> davidhouse: It's a GHC extension.
08:54:00 <davidhouse> cool.
08:54:12 <davidhouse> @type (&&&)
08:54:13 <lambdabot> forall (a :: * -> * -> *) c' c b.
08:54:13 <lambdabot>    (Arrow a) =>
08:54:13 <lambdabot>    a b c -> a b c' -> a b (c, c')
08:54:52 <davidhouse> (&&&) :: (a ~> b) -> (b ~> c) -> (a ~> c)
08:55:15 <davidhouse> i suppose (->) is really an infix type construcot.
08:55:19 <davidhouse> *type constructor
08:55:27 <ihope> (Arrow (~>)) => ...
08:55:34 <davidhouse> well, yeah.
08:56:03 <davidhouse> can you do that? use non-alphanumerics as a type variable?
08:57:12 <Lemmih> Yes.
08:57:18 <davidhouse> awesome.
08:57:19 <norpan> ~> is a neat symbol if you have the right font
08:59:17 <davidhouse> > let f g x y = (g x) * y in 4 `f (+4)` 2
08:59:17 <lambdabot>  parse error on input `('
08:59:20 <metaperl> does anyone have the code for the Haskell algorithms book typed up?
08:59:44 <davidhouse> Lemmih, next on the feature request list is a more flexible infix :)
09:00:22 <davidhouse> > let x ++ y = x `(+)` y in 2 ++ 4
09:00:22 <lambdabot>  parse error on input `('
09:00:32 <davidhouse> the former would be the more uesful.
09:00:55 <davidhouse> > Just 1 `liftM2 (+)` Just 2
09:00:56 <lambdabot>  parse error on input `('
09:00:57 <davidhouse> etc.
09:02:28 <davidhouse> if i have a string, and want the value of the variable with that name, will $(var s) do it>
09:02:45 <davidhouse> (talking template haskell here)
09:02:51 <xerox> No davidhouse.
09:03:32 <xerox> (&&&) :: (Arrow (~>)) => (a ~> b) -> (b ~> d) -> (a ~> (b,d))
09:03:37 <davidhouse> xerox, what will it do? and why not?
09:03:53 <Lemmih> > let (!-) = ($); (-!) = flip ($) in [1,2,3] -! zipWith (+) !- [4,5,6]
09:03:54 <lambdabot> [5,7,9]
09:04:03 <davidhouse> xerox, oops, i was thinking >>>
09:04:04 <Lemmih> davidhouse: tada
09:04:21 <xerox> Lemmih: that's circumfix! :-)
09:06:36 <ihope> And it's cute!
09:07:12 <xerox> In perl6 it is >>op<< IIRC.
09:07:21 <ihope> > let (!-) = ($); (-!) = flip ($) in [1,2,3] -! zip !- [4,5,6]
09:07:22 <lambdabot> [(1,4),(2,5),(3,6)]
09:08:23 <davidhouse> @index var
09:08:23 <lambdabot> bzzt
09:08:27 <davidhouse> @hoogle var
09:08:28 <lambdabot> Test.QuickCheck.variant :: Int -> Gen a -> Gen a
09:08:28 <lambdabot> Text.Html.variable :: Html -> Html
09:08:28 <lambdabot> Language.Haskell.TH.varE :: Name -> ExpQ
09:08:31 <aufrank> that's right xerox
09:08:49 <davidhouse> @hoogle Name
09:08:50 <lambdabot> Language.Haskell.TH.Name :: data Name
09:08:50 <lambdabot> Language.Haskell.TH.Syntax.Name :: OccName -> NameFlavour -> Name
09:08:50 <lambdabot> Text.Html.name :: String -> HtmlAttr
09:08:59 <davidhouse> @hoogle String -> Name
09:09:00 <lambdabot> Language.Haskell.TH.mkName :: String -> Name
09:09:00 <lambdabot> Language.Haskell.TH.Syntax.mkNameG_d :: String -> String -> Name
09:09:00 <lambdabot> Language.Haskell.TH.Syntax.mkNameG_tc :: String -> String -> Name
09:10:40 <xerox> aufrank: oooh, are you into pugs hacking?
09:11:41 <DeliQ> sorry, but what is an arrow ?
09:11:47 <xerox> DeliQ: nice question.
09:11:54 <DeliQ> hehe
09:11:58 <dcoutts> xerox, I've added a follow-up to your email (and added url [4] that you missed off :-) )
09:11:59 <davidhouse> DeliQ, haskell.org/arrows
09:12:03 <DeliQ> aah ty
09:12:42 <DeliQ> can is see it as a monad abstraction ?
09:12:46 <DeliQ> is = i
09:12:49 <xerox> DeliQ: pick one, generalization of monads, combinators for circuits design, ....
09:12:57 <aufrank> xerox: I follow it pretty actively but am only just now getting into haskell
09:13:11 <aufrank> I know more about p6 than I do about haskell, for sure
09:13:13 <jip> man this is the weirdest shit going down right now :\
09:13:20 <xerox> dcoutts: heh, [4] == [1].
09:13:28 <dcoutts> xerox, ah ok
09:13:38 <davidhouse> "bash: make: command not found" :|
09:14:16 <xerox> dcoutts: great follow up.
09:14:21 <dcoutts> xerox, ta
09:14:46 <jip> > (1, 2, 3, 4)
09:14:48 <lambdabot> (1,2,3,4)
09:15:33 <davidhouse> do people recommend haskell, haskell-cafe or both to subscribe to?
09:15:41 <liyang> Both.
09:15:42 <dcoutts> davidhouse, both
09:15:49 <dcoutts> and libraries too
09:15:59 * xerox needs a new email account
09:16:04 <dcoutts> and ghc-users :-)
09:16:04 <xerox> Spam is evil :-|
09:16:21 <jip> > (True, True, True, True, True)
09:16:22 <lambdabot> (True,True,True,True,True)
09:16:28 <jip> > (True, True, True, True, True, True, True, True)
09:16:29 <lambdabot>   add an instance declaration for (Show (Bool,
09:16:29 <lambdabot>                Bool,
09:16:29 <lambdabot>                Bool,
09:16:35 <jip> > (True, True, True, True, True, True, True)
09:16:36 <lambdabot>   add an instance declaration for (Show (Bool,
09:16:36 <lambdabot>                Bool,
09:16:36 <lambdabot>                Bool,
09:16:39 <jip> > (True, True, True, True, True, True)
09:16:40 <lambdabot>   add an instance declaration for (Show (Bool, Bool, Bool, Bool, Bool, Bool))
09:16:44 <xerox> @id jip sucks
09:16:44 <lambdabot> jip sucks
09:16:50 <jip> sorry :|
09:16:52 * xerox laughs
09:16:57 <xerox> Just kidding :-)
09:16:57 <davidhouse> xerox, get gmail! :)
09:17:10 <jip> this is weird though, when i try to show an 8 element tuple i get stack overflow!
09:17:10 <xerox> davidhouse: I really enjoy IMAP :-|
09:17:25 <davidhouse> jip, it's not weird
09:17:36 <jip> why not?
09:17:42 <davidhouse> it's just that the compiler creators didn't anticipate people trying to show 8-tuples
09:17:59 <davidhouse> you have to craft out the "instance Show (a, b, c...)" declarations manually
09:18:01 <dcoutts> that's not the same thing as stack overflow
09:18:10 <davidhouse> that's what i meant.
09:18:14 <davidhouse> it's not a stack overflow.
09:18:35 * mnislaih just saw the mails about SoC in the Haskell list
09:18:50 <xerox> mnislaih: what do you think about that?
09:18:59 <mnislaih> xerox = Paolo ?
09:19:04 <xerox> /WHOIS xerox
09:19:06 * aufrank goes to look
09:19:07 <dcoutts> mnislaih, yeah
09:19:24 <mnislaih> well it's surely great
09:19:31 <dcoutts> mnislaih, apply!
09:19:32 <mnislaih> I was looking forward to it, I sent the email to Haskell-cafe
09:19:41 <dcoutts> mnislaih, ah right, that was you
09:19:45 <xerox> Ah, nice!  Do you have any projects in mind yet?
09:19:51 <mnislaih> that means that you have sent a proposal to Google and haskell.org is the organization ?
09:20:03 <xerox> Yes, exactly.
09:20:09 <mnislaih> well I had some ideas
09:20:18 <dcoutts> xerox, have we applied yet?
09:20:27 <xerox> dcoutts: kinda.
09:20:31 <dcoutts> what was the appliation procedure exactly?
09:20:33 <mnislaih> but nothing serious. I figure out that there must be a lot of things to do in each and every haskell project out there
09:20:46 <davidhouse> i thought they weren't accepting any more mentoring organisations?
09:20:46 <mnislaih> I want to see progress in Visual Haskell for instance.
09:21:03 <wchogg> I think the deadline for mentoring organizations in May 1st.
09:21:07 <mnislaih> they are not davidhouse ?
09:21:41 * davidhouse might be misinformed
09:21:41 <mnislaih> probably they got their hands full, that's possible, but still 'you' should try
09:21:56 <mnislaih> by you I mean the people mentioned in the email, as representing haskell.org
09:22:22 <xerox> mnislaih: Visual Haskell isn't FOSS, is it?
09:22:38 <mnislaih> It is, they released it recently. Not sure about the license though
09:22:59 <xerox> I know they released it, I wonder about the licence.
09:23:09 <xerox> dcoutts: saw the query?
09:24:03 <xerox> The deadline for us to apply is the 24th.
09:24:29 <xerox> We should receive consensus on the ml in order to do that tho!  Hurry up :-)
09:27:07 <mnislaih> xerox: BSD license
09:27:14 <xerox> mnislaih: right.
09:27:28 <xerox> Sounds good, then.
09:27:41 <mnislaih> and I wonder in what state hide is now
09:28:02 <xerox> Hiding.
09:29:09 <mnislaih> if it is possible to contribute to hide that would be a great option too. But I wouldn't be able to help with low level stuff
09:29:40 <xerox> You'll see the details about hIDE on the wikipages, I think.
09:29:43 <ihope> @where visual haskell
09:29:44 <lambdabot> I know nothing about visual.
09:29:55 <ihope> @google visual haskell
09:29:57 <lambdabot> http://www.haskell.org/visualhaskell/
09:30:24 <mnislaih> I've seen the blog posts from Lemmih at planet haskell, and hardly understood anything
09:30:45 <mnislaih> he talks now about 3 varieties of hsplugins
09:30:55 <wchogg> Should I use haskell or haskell-cafe for talking about ideas for SoC projects?
09:31:05 <jip> whoah sweet! this shit works!
09:31:05 <Lemmih> mnislaih: I'm not talking about hs-plugins at all (:
09:31:15 <wchogg> jip:  Made a breakthrough?
09:31:24 <jip> yeah, i can actually play games!
09:31:32 <mnislaih> well that supports my theory that I didn't understand much
09:32:03 <wchogg> jip:  Awesome.  
09:32:17 <xerox> I don't know the details wrt hIDE, I hope Lemmih or someone will speak on hIDE behalf.
09:32:50 <aufrank> is the thread in question of h or h-c?
09:32:55 <Lemmih> We need a new plugin system for hIDE. That'd be a neat (but difficult!) project.
09:33:01 <aufrank> s/of/on/
09:33:03 <Igloo> wchogg: -cafe probably
09:33:45 <Lemmih> wchogg: We'll soon have a wiki page for project ideas.
09:33:55 <wchogg> Lemmih: Cool.
09:34:04 <aufrank> found it, nm
09:34:41 <mnislaih> Lemmih: you should post that as a project anyway. Maybe someone else will step
09:34:56 <xerox> aufrank: no, it is on haskell@haskell.org.
09:35:30 <wchogg> xerox:  Is a SoC project basically your full time job for that summer?
09:36:39 <xerox> wchogg: in my experience it was rather lax initially (I was on vacation, and bought a cellphone to get on the internet with a decent speed with the initial $500), the second month was *code*code*code*, which *is* a synonym for *fun*fun*fun* :-)  Also, we had only two months.
09:37:25 <wchogg> xerox:  Okay, because there are a few things I'd be interested in doing but I also have to do research for my advisor.
09:37:39 <aufrank> wchogg: I'm in the same boat
09:37:46 <mnislaih> same for me
09:37:48 <aufrank> my advisor cleared me to apply yesterday, though
09:37:50 <davidhouse> xerox, what did you code?
09:38:02 <aufrank> I said "I'm going to try to start contributing to a few projects anyway"
09:38:11 <xerox> wchogg: I heard that thesis project are also considered interesting if one has an advisor.
09:38:13 <aufrank> and he said I might as well apply if I'd be doing it anyway
09:38:38 <Maddas> :-)
09:38:40 <xerox> davidhouse: I wrote the Cairo haskell bindings (http://www.cairographics.org/) and integration in Gtk2Hs (it is a multi-backend library).
09:38:42 <wchogg> xerox:  Nah, that wouldn't really apply to me.  I'm a physicist not a cs grad student.
09:40:30 <aufrank> wchogg: again, same situation here.  cognitive science for me.
09:40:42 <ihope> @hoogle a -> IO b
09:40:43 <lambdabot> Control.Concurrent.MVar.swapMVar :: MVar a -> a -> IO a
09:40:43 <lambdabot> Distribution.PackageDescription.withLib :: PackageDescription -> a -> (Library -> IO a) -> IO a
09:40:43 <lambdabot> Control.Exception.evaluate :: a -> IO a
09:40:47 <wchogg> aufrank:  What kindof project did you want to work on?
09:42:09 <aufrank> so far I've thought of working on the test suite of darcs 
09:42:19 <aufrank> right now it's a bunch of perl and bash scripts
09:43:00 <xerox> Get on #darcs aufrank!
09:43:11 <xerox> A guy was asking wether there would have been darcs projects :-)
09:43:28 <wchogg> Dammit.  Connection went bad and I missed the last bit of conversation.
09:43:39 <davidhouse> aufrank, check out HUnit.
09:43:46 <aufrank> xerox: I've been in there the past few days and it's been dead
09:43:51 <aufrank> but I'll get over there now
09:45:17 <norpan> www.hunit.com was not what i expected :)
09:45:31 <aufrank> I should be up front and say that this would be something of a bootstrapping process for me
09:45:43 <aufrank> I'm really just finding my legs, haskell-wise
09:52:38 <ihope> Hmm. How come I can get to vi via bash but not via cmd?
09:53:19 <sjanssen> ihope: cmd doesn't have vi in it's PATH?
09:53:28 <ihope> Just where is vi?
09:53:58 <sjanssen> in bash, try a "which vi" which will print it's location
09:54:11 <ihope> Ah. Thanks.
09:55:31 <ihope> Now how can I make an alias in cmd?
09:55:39 <ihope> Or should I just not use cmd? :-P
09:56:16 <sjanssen> ihope: I would not use cmd.  Or even better, not use the OS that comes with cmd ;-)
09:56:37 <ihope> Tell the people who made my wireless adapter that ;-)
09:56:52 <ihope> Well, I gotta /away for a bit
09:57:26 <ihope> Or maybe not...
10:28:15 <i|> So how could one fix a "Duplicate instance declarations" error?
10:29:09 <Lemmih> Yes.
10:29:21 <i|> Okay. Thanks.
10:30:17 <sdschulze> Hi; I have a question on house... At what extent does it implement security and in which ways?  (hardware vs. software protection, etc.)
10:35:21 <sdschulze> I'm particularly interested whether there are plans to emulate multi-tasking by software, which would permit full optimization.
10:41:14 <DeliQ> does anybody know a good monad tutorial for a first year fp student ?? :P
10:42:05 <Korollary> @where MonadsAsContainers
10:42:06 <lambdabot> I know nothing about monadsascontainers.
10:42:13 <Korollary> @google MonadsAsContainers
10:42:15 <lambdabot> http://www.haskell.org/hawiki/MonadsAsContainers
10:42:21 <DeliQ> ahh thank you
10:42:33 <Korollary> np
10:42:40 <eivuokko> That's good, I also liked http://www.nomaware.com/monads/html/
10:43:02 <DeliQ> i won't be bored :P
10:43:11 <Korollary> You can't run out of monad tutorials.
10:44:01 <xerox> Great!  An answer!
10:44:09 * xerox points everybody at the mailing list
10:44:11 <DeliQ> monads where only mentioned for a split second in the lectures so..
10:44:13 <mwc> I didn't learn from this, but it seems to be written in the same style as the arrow tutorial on the same place, which I thought was excellently written
10:44:13 <mwc> http://en.wikibooks.org/wiki/Programming:Haskell_monads
10:44:51 <DeliQ> mwc: thanks..
10:45:14 <newsham> it would be neat if all the collected haskell knowledge was put onto a single web site
10:45:38 <Korollary> newsham: The Haskell wiki?
10:46:42 <mwc> Maybe this summer I'll sit down and write something on "Monads without a Ph.D."
10:47:00 <mwc> I imagine a lot of people come to haskell with a numerical experience in math, I figure I can write to them
10:47:19 <DeliQ> that sounds like a good thing!
10:47:26 <DeliQ> i would be interested in it!
10:47:28 <aufrank> mwc: I would appreciate that
10:47:35 <mahogny> mwc, if you are going at it, I'd say the main problem isn't the monads themselves, it is how to put them to good use
10:47:44 <aufrank> well said
10:47:56 <xerox> I think it's not that the problem.  They emerge.
10:47:58 <mahogny> mwc, in particular real life examples without academic masturbation
10:48:33 <mwc> My background is applied math and physics, I should be able to do that pretty well I'd hope
10:49:01 <xerox> But off course one has to think in terms of them.
10:49:02 <newsham> mahogny: like "scheme in 48 hrs"?
10:49:22 <newsham> http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/overview.html
10:49:23 <xerox> newsham: I have a better example of what Scheme.hs should look like if you want.
10:49:33 <mahogny> newsham, hmmm
10:49:33 <newsham> real life examples without academic masturbation
10:49:38 * mahogny looks
10:50:08 <xerox> newsham, <http://mumble.net/~campbell/tmp/Scheme.hs>.
10:50:10 <bolrod> xerox: well... I guess it's a start
10:50:12 <newsham> xerox: I'm not particularly hot on writing languages in haskell (and scheme i nparticular), but i'll take a look 
10:50:54 <xerox> This Scheme.hs is like a rewrite of the proper chapters of the Scheme standard, in Haskell.
10:51:28 <mahogny> newsham, that scheme stuff is way too fundamental. I'd be more interested in questions such as "when will it save my day if I make heavy use of a monad to do CPS"
10:51:31 <newsham> i would rather write small ascii plotters  http://www.haskell.org/hawiki/Mandelbrot  ;-)
10:51:48 <DeliQ> mwc: you could publish it on the haskell wiki ??
10:52:17 <xerox> 0_o
10:53:49 <alec> xerox: thanks for the link
10:53:57 <xerox> alec: my duty.
10:54:26 <mwc> probably. I have my last final morning, but I'll have a look at it soon
10:55:50 <xerox> mwc: did you think about applying for SoC under Haskell.org this year? (-:
10:56:13 <mahogny> SoC?
10:56:29 <jip> please don't use the abbreviation "SoC" anymore... it makes me go berzerk for some reason
10:56:44 <jip> summer of code isn't too hard to type
10:57:06 <wchogg> Why does SoC fill you with hate?
10:57:27 <newsham> soc it to jip
10:57:27 <mwc> xerox, nah, I was hoping to take this summer off, probably the last one I will until 60 or so
10:57:47 <newsham> summer of mwc :)
10:57:54 <xerox> Heh.
10:57:55 <mwc> plus I need to figure out what postgrad stuff I want to apply for
10:58:19 <aufrank> mwc: change to computational neuroscience ;)
10:58:30 <aufrank> a lot of the best people in the field came from physics or maths
10:58:31 <jip> newsham: cause for me it's gonna be the summer of hell :(
10:58:38 <mahogny> neural networks = major waste of CPU
10:58:52 <mwc> aufrank, no kidding. I was thinking evolutionary computing would be my choice
10:59:01 <newsham> my neural network is flakey
10:59:27 <mahogny> mwc, I'd say evo comp has much higher potential than neu comp
10:59:35 <sethk> mwc, I've been unimpressed with the evolutionary computing stuff I've read
10:59:50 <sethk> mwc, I think the concept is flawed and it will go nowhere
11:00:02 <newsham> why not get a job writing software?
11:00:06 <wchogg> sethk:  How do you think it's flawed?
11:00:13 <jip> have you guys seen NEAT?
11:00:27 <mahogny> sethk, seems we have the opposite opinion :) what makes you unimpressed?
11:00:40 <mwc> sethk, I was checking out some neat evo-driven engineering stuff
11:00:47 <sethk> mahogny, well, first I should make sure we are talking about the same thing
11:00:52 <newsham> nowhere is a fine destination ;-)
11:01:12 <mwc> a genetic algorithm designed a satellite component 20,000% better (in terms of surpressing vibrations) than the human-engineer's version
11:01:25 <sethk> yes, then, we are talking about the same thing
11:01:32 <sethk> think about it, it really makes no sense whatsoever
11:01:34 <mahogny> sethk, evolutionary computation = have a population and using crossovers and manipulations
11:02:00 <sethk> evolution itself does not produce a good result
11:02:00 <mwc> looked impossible though, it was all asymmetric and the trusses met at strange angles
11:02:09 <sethk> why emulate a process that doesn't even work?
11:02:12 <mahogny> sethk, ehr. wtf?
11:02:25 <mahogny> since when did evolution stop working?
11:02:27 * aufrank just programmed a genetic algorithm last week for the first time
11:02:34 <sethk> mahogny, it didn't stop, it never worked, per se
11:02:38 * palomer wonders what a genetic algorithm is
11:02:54 * mahogny wonders sethk has gone wacky and become a creationalist or something
11:03:03 <sethk> mahogny, through a stupendous amount of randomness and infinite amount of time, it turns up a few more or less working models
11:03:16 <newsham> http://portal.acm.org/citation.cfm?id=36206.36194  
11:03:24 <sethk> do you really want software with an appendix?
11:03:33 <sethk> tails?  male breasts?
11:04:01 <sethk> if evolution worked, we would have wheels
11:04:07 <mwc> sethk, the appeal of evolutionary computing is that (from an applied math perspective) we have more and more sophisticated problems and less turnaround time. The push is on to find easily adaptable algorithms that produce good results. Evo Comp seems to be pretty hot right now
11:04:24 <mwc> sethk, evolution has constraints.
11:04:32 <sethk> yes, indeed
11:04:33 <mwc> ie, human beings need to be constructed out of one piece of meat
11:04:38 <mahogny> I have nooo idea where you are taking this discussion. in all cases I have implemented both ANN and GA, the GA has beaten the hell out of the corresponding ANN. in some cases, I have used ANN and GA together, which improves ANN tons
11:04:44 <newsham> sethk: evolution absolutely "works".  the optimization function just doesnt align itself well with what some people think is optimal
11:04:45 <sethk> mwc, that isn't really the problem
11:04:55 <mwc> I suppose you cound have symbiotic wheels or something
11:05:02 <mwc> but anyways, that's fallacious
11:05:06 <mwc> wheels are good on ROADS
11:05:16 <sethk> newsham, no, that's not true.  it chooses only among a tiny subset of possible solutions
11:05:17 <mwc> legs and arms let you climb trees, swim
11:05:23 <mwc> use tools
11:05:30 <newsham> sethk: and?
11:05:37 <sethk> mwc, I wasn't saying that you give up arms and legs
11:05:39 <newsham> nobody said evolution picks THE optimal solution
11:05:50 <newsham> it finds local maximas, and it adapts as those change.
11:06:05 <sethk> newsham, no, it only chooses the least bad of a set of poor solutions
11:06:30 <mahogny> actually, good GAs are our currently our best algorithms at avoiding local optimas
11:06:37 <newsham> sethk: ok.  i'll buy that.  now convince me that that isnt "working"
11:06:47 <sethk> newsham, well, working is not a meaningful term
11:06:48 <mwc> I was under the impression particle swarms were pretty good too
11:06:52 <newsham> sounds like useful work to me
11:07:05 <mahogny> sethk, have you actually used these algorithms in practice?
11:07:06 <newsham> sethk: you said "evolution dosnt work" or something to that effect
11:07:18 <sethk> newsham, yes, in the sense that it would be something to emulate
11:07:35 <jip> hey guys, check it out, it's totally rad:
11:07:35 <jip> http://img529.imageshack.us/img529/3104/dropzonegameplay015iz.png
11:07:44 <sethk> mahogny, I've not really done much more than play around with it, but remember, I only write software that people pay me to write
11:08:11 <newsham> ever read massalin's "superoptimizer" paper.  very amusing
11:08:20 <mahogny> sethk, in that case I don't think you have much to add to the discussion
11:08:39 <sethk> mahogny, possibly not, but nobody else has qualified themself
11:08:42 <davidhouse> jip, is that yours?
11:08:43 <Korollary> jip: what is that?
11:08:47 <sethk> mahogny, as a tactic, that's completely unacceptable
11:08:56 <sethk> mahogny, insult the person, avoid the idea
11:09:05 <palomer> grr
11:09:05 <davidhouse> i remember some guy was making a game boy emulator, but i can't remember who it was
11:09:09 * palomer kicks DPMS
11:09:09 <jip> that's my haskell gameboy emulator!
11:09:22 <Korollary> jip: haha
11:09:23 <palomer> that guy was a real hoser
11:09:28 <newsham> jip: cool
11:09:30 <sethk> jip, no wonder it looks familiar
11:09:38 <jp> jip: congrats :)
11:09:39 <newsham> jip: do you plan to release it?
11:09:40 <jip> i can't believe it actually works
11:09:49 <Korollary> Man, I miss shoot'em-right games.
11:09:50 <jip> newsham: i'm releasing developer snapshots on my devlog
11:09:55 <aufrank> ok, really away now
11:09:56 <mahogny> sethk, ok. then let's put it like this; I qualify myself, and I find irritating that someone completely dissects an idea without any what-so-ever real life experience of it
11:09:57 <aufrank> &
11:10:02 <jip> http://www.mutantlemon.com/omegagb/devlog/
11:10:13 <xerox> @karma+ jip -- wooo!
11:10:14 <sethk> mahogny, then be irritated
11:10:14 <lambdabot> jip's karma raised to 4.
11:10:28 <newsham> sethk: the only reason it would be "unacceptable as a tactic" is if it didnt produce results (and was destined to never produce results)
11:10:29 <davidhouse> jip, awesome :)
11:10:43 <newsham> the fact that it has already produced results obliterates your argument.
11:10:54 <sethk> newsham, no, you misunderstood
11:11:04 <jip> only problem is that it's reallllllly slow :'(
11:11:06 <sethk> newsham, I said mahogny's insult of me is unacceptable as a tactic
11:11:13 <sethk> newsham, I wasn't talking about the algorithms
11:11:18 <xerox> jip: make a darcs repository to have patch from others :-D
11:11:19 <newsham> ahh.. my mistake.
11:11:47 <mahogny> sethk, that insult is based on facts. it's entirelly objective
11:11:51 <jip> xerox: i first have to do major cleanups of the code and implement a few missing features so that more games will run
11:11:58 <sethk> mahogny, makes no difference
11:12:04 <davidhouse> jip, that's really cool.
11:12:06 <sethk> mahogny, but your basic premise is entirely flawed
11:12:13 * davidhouse wishes he could come up with such a cool project idea
11:12:24 <Lemmih> metaperl: (re-blog) But it /does/ construct something.
11:12:26 <xerox> jip: keeping track of changes with darcs will let you have a very nice historybook of the developement too.  Seems you're concertend with it.
11:12:36 <metaperl> Lemmih: it does?
11:12:43 <sethk> Lemmih, wasn't that hours ago?
11:12:44 <metaperl> Lemmih: you cant call a type constructor can you?
11:12:52 <davidhouse> metaperl: sure you can.
11:12:56 <metaperl> data CoordType = Coord Float Float
11:12:57 <davidhouse> not to get a value, but to get a type.
11:12:58 <Lemmih> metaperl: It constructs a type.
11:13:00 <sethk> metaperl, in that sense you can't call a data constructor either
11:13:03 <metaperl> pt = Coord 2.0 2.0
11:13:08 <jip> xerox: maybe... thing is darcs is kind of weird for me. i think i'd rather use subversion or cvs
11:13:13 <metaperl> sethk: I just did didn't I?
11:13:14 <mahogny> sethk, since when was it impossible to use facts as arguments?
11:13:20 <xerox> jip: why?
11:13:25 <sethk> mahogny, never.  but you aren't listening
11:13:29 <davidhouse> metaperl, f :: Maybe Int. you just called Maybe, gave it an Int, and got a Maybe Int.
11:13:38 <davidhouse> metaperl, these things work at a different level.
11:13:44 <metaperl> darcs is no good when you repository is 2 gigs to start with ... it tries to load the whole thing in memory and do a patch-compare and runs out of memory
11:13:51 <sethk> mahogny, you don't really believe I was saying that you can't use facts in an argument (a fact can never _be_ an argument)
11:14:08 <jip> xerox: my big fear is the way darcs doesn't have revisions.
11:14:11 <metaperl> davidhouse: was that a type signature?
11:14:16 <davidhouse> metaperl: yeah.
11:14:20 <xerox> jip: what's the problem with that?
11:14:39 <sethk> jip, it has equivalent capabilities, though
11:14:40 <jp> jip: You can tag versions, which subsumes revisions.
11:14:41 <jip> xerox: hm... not sure. i guess i should probably just jump right into darcs and i will love it :)
11:14:47 <jip> jp: hm...
11:14:52 <xerox> jip: I really think you can mark stages too.
11:14:58 <xerox> Right, that.
11:15:02 <davidhouse> woah, jp and jip are VERY similar-looking nicks.
11:15:11 <mahogny> sethk, any factual statement can be considered an insult, if you just happen to belong to the wrong group. since you don't present any basis for what you say, my only option to counter is to show that the source is flawed - you
11:15:18 <davidhouse> thanks :()
11:15:19 <davidhouse> *:)
11:15:21 <sethk> mahogny, nonsense
11:15:49 <sethk> mahogny, I did indeed provide arguments.  You just have no answer for them
11:15:56 <xerox> jip: I promise you a patch if you switch to darcs :-D
11:16:09 * xerox and advertising
11:16:14 <mahogny> sethk, your arguments are entirelly subjective
11:16:23 <sethk> mahogny, nonsense
11:16:29 <davidhouse> jip, so what repo have you got? svn is fine by me
11:16:33 <davidhouse> as long as it's not CVS
11:16:33 <jip> xerox: hehe cool
11:16:36 <alec> jip: darcs is rediculously easy to use
11:16:46 <jip> davidhouse: i don't have any repos right now
11:16:51 <davidhouse> all RCSs are (or should be).
11:17:05 <xerox> davidhouse: argh! Heretic!  Burn burn burn!!
11:17:08 <jip> xerox: thing is my vacation is over in a few hours and then i'm gonna be off the grid for a while
11:17:13 <mwc> davidhouse, played with Arch any?
11:17:13 <sethk> davidhouse, are what?  I think I lost the thread of that discussion
11:17:15 <davidhouse> i quite like svn, but i'm happy to work with darcs if that's what my team is using :)
11:17:19 <mwc> It's like Darcs but terrifying
11:17:24 <davidhouse> sethk, easy to use. re alec's comment.
11:17:27 <xerox> jip: you don't want the others to play with you code :-(
11:17:29 <jip> xerox: so i'm not sure if i should switch to darcs now, or when i get back
11:17:30 <davidhouse> mwc, sounds fun :)
11:18:01 * xerox will start threatening @karma-'s  <j/k>
11:18:04 <davidhouse> jip, i'm sure one of these kind people wouldn't mind sharing a bit of their darcs if you email them the source.
11:18:10 <sethk> davidhouse, branching can be difficult
11:18:23 <xerox> I would do it!
11:18:30 <sethk> davidhouse, merging branches can be difficult also
11:18:35 <davidhouse> sethk, true. there are some rather involved concepts once you get in there.
11:18:35 <jip> davidhouse: i think i should be able to put the darcs repos on my server
11:18:35 <xerox> sethk: cp -R ?
11:19:19 <jyp> Anyone knows the preprocessor variables defined by Cabal ?
11:19:20 <sethk> xerox, I've worked on some big projects that had people who did nothing but version control all day, so they made things nobody could possibly use, for job security purposes  :)
11:19:31 <xerox> jip: sure you do.  You don't even need darcs on the server.
11:19:45 <jip> xerox: yeah, that's what i'm told
11:19:49 <sethk> xerox, but merging is not necessarily trivial, even if you don't purposely make it more difficult than necessary
11:19:50 <davidhouse> woah, really?
11:20:00 <davidhouse> xerox, it's all in the client?
11:20:19 <xerox> Darcs contains the seed of its own revolution.
11:20:33 <davidhouse> all you need is a _darcs dir and the client will pick up the rest?
11:20:39 <jyp> @seen syntaxninja
11:20:40 <lambdabot> I saw syntaxninja leaving #haskell and #haskell-blah 1 day, 17 hours, 2 minutes and 4 seconds ago, and .
11:20:49 <Korollary> and .
11:21:06 <Korollary> I guess the bot has not missed any time since then.
11:21:18 <xerox> davidhouse: there is no client/server.  There's just one darcs binary file.  It makes repositories, retrieve repositories, and synchronize repositories.  It has advanced features I didn't really got into too.
11:21:30 <davidhouse> ah, i see.
11:21:44 <davidhouse> so you could even have a darcs and svn repo sharing the same files.
11:21:54 <davidhouse> but you'd have to use both clients every time you did something.
11:22:08 <xerox> I think so.
11:22:50 <davidhouse> awesomeness.
11:24:01 <shapr> Wow, 211 clients!
11:24:25 <xerox> A shapr!
11:24:31 <shapr> hiya xerox
11:24:39 <xerox> shapr: did you see the mailing list perchance?
11:24:49 <shapr> Yup, just saw your Google SoC post.
11:24:55 <shapr> It's great!
11:25:10 <aufrank> xerox: thanks for getting the ball rolling on that, btw
11:25:14 <xerox> We have to hurry!  They're going to accept us until 24th.
11:25:24 <xerox> aufrank: I'm loving it.
11:25:46 <aufrank> is the wiki page up yet?
11:25:58 <xerox> We got something, waiting for some more consensus on the mailing list atm.
11:26:10 <aufrank> gotcha
11:26:22 <aufrank> @hoogle time
11:26:23 <lambdabot> System.Time :: module
11:26:23 <lambdabot> Time :: module
11:26:23 <lambdabot> System.Locale.time12Fmt :: TimeLocale -> String
11:27:25 <davidhouse> xerox, which mailing list was that on?
11:27:42 <xerox> davidhouse: haskell@haskell.org
11:27:43 <aufrank> haskell
11:27:57 * Lemmih heads to bed. Good night, all of #haskell.
11:28:09 <aufrank> gnight
11:29:00 <xerox> 'night.
11:29:00 <shapr> g'nite Lemmih 
11:29:46 <musasabi> Lemmih: how (re unsafeCoerce#) ?
11:30:12 * Korollary throws discount lambdas at shapr 
11:30:35 <jyp> Anyone familiar with Cabal wishes to help me?
11:30:56 <Lemmih> musasabi: \mvar fn -> unsafeIOToSTM (modifyMVar_ mvar (unsafeSTMToIO.fn))
11:31:25 <Lemmih> musasabi: where unsafeSTMToIO = unsafeCoerce# :: STM a -> IO a
11:31:57 <musasabi> Lemmih: let me try that one out.
11:32:06 * shapr catches a lambda and throws a redex back at Korollary 
11:33:19 <xerox> musasabi: you're doing exciting things, aren't you?
11:33:48 <davidhouse> do we have a real name -> #haskell nick map anywhere?
11:34:12 <xerox> We used to have something like that.  Along with a world map.
11:36:24 <SamB> What does this mean:
11:36:31 <SamB> Interesting!  A join var that isn't let-no-escaped [zdj{v s5Q5}]
11:36:38 <i|> :-D
11:36:56 <i|> What's the expression that caused that?
11:37:09 <SamB> no idea!
11:37:10 <xerox> @ghc
11:37:11 <lambdabot>  The instance types do not agree with the functional dependencies of the class
11:37:18 <aufrank> xerox: how much experience did you have with haskell when you started your summer of code project last year?
11:37:18 <xerox> That's simple.
11:37:26 <xerox> aufrank: mumble.
11:37:33 * i| wants to collect strange GHC error messages
11:37:37 <xerox> aufrank: I think had some months of haskell behind.
11:37:51 <musasabi> Lemmih: that seems to loop/freeze when there is an exception or retry.
11:37:56 <i|> So far I have... one.
11:38:04 <xerox> @ghc
11:38:05 <musasabi> davidhouse: /who
11:38:05 <lambdabot>  In a case expression, type of scrutinee does not match patterns
11:38:09 <SamB> something in jhc's PackedString.hs
11:38:11 <aufrank> xerox: so you were bootstrapping as well, to some extent?
11:38:43 <xerox> aufrank: I think you might say so, the community is so great that I never felt any pain.
11:38:48 <musasabi> xerox: nothing terribly exciting, concurrent datastructures.
11:38:51 <aufrank> =)
11:40:44 <davidhouse> musasabi: that would be nick -> name, right?
11:41:15 <SamB> @map
11:41:16 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
11:41:33 * SamB wonders if that has names
11:41:36 <aufrank> > map
11:41:37 <lambdabot>  add an instance declaration for (Show ((a -> b) -> [a] -> [b]))
11:41:41 <musasabi> yes, and the reverse too.
11:41:42 <aufrank> =P
11:42:05 <musasabi> dons: please provide a Data.FastPackedString that just re-exports Data.ByteString.
11:42:24 <davidhouse> musasabi: nice
11:42:56 <musasabi> dons: makes for evil versioning for everyone that depends on fps.
11:43:10 <Lemmih> musasabi: Hm, so it does.
11:45:16 <mnislaih> jvp you still got that problem?
11:45:27 <mnislaih> jyp ping
11:47:27 <jyp> mnislaih: Actually, I found my mistake
11:47:39 <jyp> mnislaih: Thanks :)
11:47:42 <mnislaih> np
11:47:51 <musasabi> -> away
11:54:20 <newsham> musasabi >>= (\away ->
11:54:55 <jimapple> is scanl a banana, lens, envelope, or barbed wire?
11:55:47 <newsham> have you tried applying a banana to a function and a list of values?
11:57:19 <jimapple> hmm
11:58:43 <jimapple> I don't get it
11:59:52 <newsham> there's no where to put the function.  therefore scanl is not a banana.
12:01:28 <shapr> scanl would be an anamorphism?
12:01:49 <shapr> Or maybe a hylomorphism?
12:05:15 <Oeje1> You guys are dope.
12:05:27 <jip> shapr: you see the latest screenshot?
12:05:36 <jip> http://img529.imageshack.us/img529/3104/dropzonegameplay015iz.png
12:06:04 <Oeje1> jip: Nice work.
12:06:27 <jip> thanks
12:06:48 <shapr> jip: nifty!
12:06:55 <davidhouse> jip, darcsify it already :)
12:07:31 <shapr> Yeah, darcs!
12:07:41 <davidhouse> would it be possible to create a darcs repo from a bunch of files on your computer, then just upload them to an http server?
12:12:44 <jimapple> I think scanl is a hylomorphism:
12:12:44 <jimapple> hylo c p g x a | p a = c
12:12:44 <jimapple> hylo c p g x a | not (p a) = let (b,a') = g a in b `x` (hylo c p g x a')
12:12:44 <jimapple> scanl f z ys = hylo [] (null . snd) (\(o,t) -> let r = g o (head t) in (r, (r,tail t))) (:) (z,ys)
12:13:30 <jip> newsham: http://www.mutantlemon.com/omegagb/devlog/
12:15:02 <newsham> danke
12:15:05 <sjanssen> davidhouse: that's essentially how darcs works
12:15:35 <sjanssen> davidhouse: oh wait, you know that -- you weren't asking a question
12:15:58 <davidhouse> i wasn't?
12:16:10 <sjanssen> I don't know anymore ;-)
12:16:20 <sjanssen> I'll go back to my corner
12:16:26 <davidhouse> sjanssen: i think i was
12:16:44 <shapr> davidhouse: darcs put
12:17:06 <davidhouse> shapr, how would that work?
12:17:15 <davidhouse> will it ask me for FTP details?
12:17:31 <sjanssen> shapr: that requires darcs on the receiving machine, right?  you can just use low tech methods like uploading the whole directory via FTP/rsync/scp
12:17:33 <shapr> er, no.. I think darcs put assumes a copy of darcs is on the destination server.
12:17:41 <davidhouse> ah.
12:17:44 <shapr> Yeah, rsync, unison, etc
12:18:44 <lispy> yes, darcs put does assume a remote darcs binary
12:18:55 <lispy> er wait...i'm thinking of push
12:19:11 <lispy> so...don't listen to me :)
12:19:31 <shapr> greetz mistah dagit
12:19:42 <lispy> hi
12:20:02 <xerox> davidhouse: darcs push it.
12:20:09 * lispy always wanted a PhD so he could be Dr. Dagit
12:20:26 <xerox> Dr. lispy Dagit.
12:20:40 <lispy> Dr. "lithpy" Dagit
12:21:27 <shapr> How do you say it? dah-git? day-git?
12:21:31 <lispy> so i was trying to find the places on my laptop where i'm wasting the most space..andi see that i have 0.5GB worth of epson printer drivers but i've never had an epson printer
12:21:57 <lispy> da (as in dad) git (hard g)
12:23:33 <lispy> darwinports seems to be another space waster
12:24:13 <newsham> doo doo doo doo doo inspector dagit
12:24:19 <newsham> doo doo doo doo doo Doo Doo
12:24:38 <lispy> heh, one of my good female friends in high school used to always sing that
12:25:31 <newsham> hmm.. you had female friends in high school and you still persued a phd?  ;-)
12:25:39 * lispy has no phd
12:26:11 <lispy> actually, i had an agreement with taht friend that if we were single at 40 we'd get married
12:26:48 <lispy> you can imagine my distress when i found out she's happily married with several children
12:27:18 <kep> lispy: ogo :)
12:27:27 <newsham> marital state is not monotonically increasing
12:27:36 <lispy> hehe
12:28:40 <lispy> it's like, "We were engaged!? Why did you get married?"
12:29:00 * lispy leaves for some earth day celebrations
12:29:02 * lispy waves
12:29:56 <robokop> lispy: why on earth would you have an eathday celebration
12:30:05 <shapr> 214 users must be a high water mark for #haskell
12:32:16 <newsham> hippy
12:33:18 <newsham> (doesnt seem like there's much to celebrate, what with global dimming, global warming, deforestation, glacial melt, el nin~o, la nin~a, forest fires due to over zealous fire prevention, etc.)
12:34:48 <shapr> We're still breathing.
12:35:14 <sethk> ghc -M writes to Makefile.  Is there a way to convince it to write to a different file name?
12:35:16 <newsham> no doubt, and making money w/ enough idle time to irc.
12:35:25 <newsham> but to celebrate "earth day"?
12:35:38 <newsham> isnt that like a disco at a funeral?
12:35:55 <sethk> I always thought a funeral would be the right place for disco
12:36:43 <newsham> isnt that like eating the brains of the deceased to capture their power?
12:37:03 <sethk> I'm not sure I follow the analogy  :)
12:37:08 <shapr> Zombies?
12:37:15 <mwc> I propose to fight global warming by nuking the polar ice caps
12:37:23 <newsham> http://www.as.ua.edu/ant/bindon/ant570/Papers/McGrath/McGrath.htm
12:37:27 <mwc> Preferably antartica
12:37:32 <mwc> get a little nuclear winter going
12:37:34 * shapr is trying to strip HaXml to something smaller and focussed on xmlrpc.
12:37:48 <sethk> mwc, nuclear winter is out of style, we have global warming now instead
12:38:04 <sethk> mwc, can't have both, since they pull in different directions
12:38:05 <shapr> Has anyone tried to strip/focus HaXml?
12:38:08 <newsham> shapr: why not make a lighterweight marshalling protocol than xml?
12:38:18 <newsham> (doesnt it have to be rpc usign xml?)
12:38:24 <newsham> s/doesnt/does/
12:38:30 <shapr> There already is such a thing, bittorrent's BEncode is a good example.
12:38:52 <shapr> But at the moment, I'm trying to optimize an existing program that uses xmlrpc.
12:40:24 <shapr> It would be nice to switch to BEncode, I'll consider that.
12:42:02 <mwc> yaml-rpc?
12:43:28 <shapr> yaml is whitespace significant, isn't it?
12:45:46 <davidhouse> anyone on emacs? could you test whether the M-x capitalize-region RET does anything?
12:46:06 <sethk> davidhouse, in general?  in haskell mode?
12:46:11 <davidhouse> in general.
12:46:57 <xerox> jip: bindWidget = (xmlGetWidget .) . windowXml
12:47:18 <sethk> davidhouse, changes the first letter of each word to upper case
12:47:20 <xerox> Hmm no.
12:47:30 <davidhouse> sethk, oh, i see :)
12:47:38 <xerox> jip: nevermind.
12:48:04 <sethk> davidhouse, I think there is another command that would force all the letters to be upper case
12:49:02 <davidhouse> upcase-region
12:49:07 <davidhouse> C-x C-u :) thanks, sethk.
12:49:23 <sethk> davidhouse, I thought that might be what you needed
12:54:47 <jip> xerox: hm... there's also a ghc option something about disabling the monomorphic restriction
12:55:30 <musasabi> yes, but it is better to fix the code if possible.
12:56:05 <jip> musasabi: well, the code is arguably not broken
12:56:42 <jip> newsham: ghc is supposed to have some sort of special profiling mode that finds the error
12:57:22 <davidhouse> jip, there's stuff in the user manual about profiling
12:58:01 <jip> davidhouse: yeah
12:59:40 <musasabi> jip: the code is broken from the view that it won't probably be legal haskell-prime either, and if one has to choose between few eta-expansions and yet another non-standard feature...
13:00:15 <musasabi> jip: of course there are cases where the change would be burdersome and -fno-monomorphism-restriction is the right way.
13:01:09 <jip> if you say so :) i'm definitely not an expert in this issue
13:02:12 <musasabi> shapr: btw I noticed on a similar thing that URI parsing with Network.URI was quite slow and have a faster routine for parsing URIs from fps.
13:02:47 <xerox> jip: anyway I was thinking that you would still be able to snapshot your sourcecode as you're doing now.  Just copy it somewhere.
13:03:12 <jip> xerox: yeah, i guess so
13:04:58 <shapr> musasabi: Ooh, I want it!
13:05:01 <newsham> jip doesnt like /msg's
13:05:43 <shapr> musasabi: I'm hacking around on cabal-get and deps, trying to get it all small enough to include in the next Cabal release.
13:06:26 <vincenz> shapr: pubkey!
13:08:06 <dbremner> shapr - hi
13:08:21 <shapr> vincenz: http://haskell.org/~shae/ssh2.pub
13:08:34 <shapr> hiya dbremner
13:09:26 <newsham> jip: what made you pick gameboy, btw?
13:13:35 <xerox> He's an evil gamer!
13:15:21 <jip> newsham: it's simple and has great games
13:15:24 <newsham> ewww glade.
13:15:43 <xerox> Glade does its evil job.
13:16:03 <newsham> poorly.  i've had much better success using gtk directly
13:16:26 <newsham> glade is an answer to the tedious C interface to gtk
13:16:36 <jip> glade is painful, but using gtk directly is even more painful
13:16:40 <davidhouse> glade is nice.
13:16:59 <newsham> if you code in any other language, using glade is as hard or harder (and less flexible) than just writing the code directly
13:17:18 <davidhouse> really?
13:17:26 <newsham> imnsho
13:17:36 <davidhouse> it's easier to code the position of all the buttons, how they should scale, inputs etc.?
13:17:55 <newsham> yup.   add yer buttons to the packer. tada.
13:17:56 <davidhouse> the glade UI builder seemed really quite simple
13:18:53 <xerox> The Haskell interface to the XML is quite convenient in fact.
13:19:26 <newsham> xerox: good to know.  the python xml libs have been giving me grief.
13:19:47 <humasect> how to get glade to generate that xml without the C project files it likes?
13:20:06 <jip> in gtk2hs it's just a single line to load the glade file, and then an additional line for grabbing each widget you want
13:20:10 <xerox> I'm am talking about the very specific interface stuck into Gtk2Hs to access Glade XML files only.
13:20:20 <xerox> What jip said.
13:20:29 <davidhouse> humasect: there's a glade UI builder that does it wysiwyg-style for you.
13:20:36 <helge_> Is there a book on Haskell available for free download on the internet?
13:20:39 <davidhouse> drag a button here, a text input here.
13:20:40 <humasect> that is glade right.
13:20:45 <davidhouse> @where yaht
13:20:46 <lambdabot> http://www.isi.edu/%7Ehdaume/htut/
13:20:50 <davidhouse> helge_: ^^
13:21:02 <newsham> helge: there are many haskell tutorials.
13:21:04 <humasect> davidhouse: /after/ doing this in glade.
13:21:18 <helge_> thanks!
13:21:20 <mwc> helge_, yaht being one of the more complete and readable ones, IMHO
13:21:47 <musasabi> shapr: http://test.happs.org/HAppS/src/HAppS/Protocols/SURI/ParseURI.hs
13:21:57 <davidhouse> it's got a couple of problems, but it's overall very good.
13:22:17 <vincenz> shapr: I mean the one for ssh
13:23:21 <shapr> vincenz: That's an ssh2 pubkey, isn't it?
13:23:32 <davidhouse> is FastString about as fast as a FastPackedString?
13:23:44 <shapr> musasabi: Any ideas or suggestions for cabal-get?
13:24:29 <musasabi> davidhouse: FastString is the name of the type defined in Data.FastPackedString. They are now being renamed to ByteString to add to the confusion.
13:25:14 <musasabi> shapr: the most important feature is the ease of installation, it should "just work" on linux/os x/windows.
13:25:23 <vincenz> shapr: not like the format in authorized_keys
13:25:50 <musasabi> shapr: maybe provide binaries like darcs does to help if there are issues.
13:25:59 <shapr> hm, yeah
13:27:23 <shapr> vincenz: http://haskell.org/~shae/id_dsa.pub
13:36:32 <mnislaih> anyone here experienced with IDL and Hdirect ?
13:38:59 <davidhouse> can GHC compile for 64 bit?
13:39:23 <SamB> davidhouse: apparantly yes
13:40:41 <davidhouse> good. :)
13:44:35 <lambda_boy> @hoogle while
13:44:36 <lambdabot> Prelude.dropWhile :: (a -> Bool) -> [a] -> [a]
13:44:36 <lambdabot> Prelude.takeWhile :: (a -> Bool) -> [a] -> [a]
13:44:36 <lambdabot> Data.PackedString.dropWhilePS :: (Char -> Bool) -> PackedString -> PackedString
13:59:10 <wimp> is there a way to do high performance matrix operations in haskell?
14:00:32 <mahogny> wimp, I'm afraid haskell and high performance scientific calculations don't mix like that. feel free to write FFI for BLAS if you're at it though
14:00:54 <jip> mahogny: why don't they mix?
14:01:33 <mahogny> jip, because it's hard to keep track of what the compiler optimizes in haskell, and the programs are usually so simple that you might as well use C where you have better control
14:01:53 <vincenz> shapr: done, test?
14:01:54 <mahogny> exceptions exist of course
14:04:12 <musasabi> There are some lib bindings for matrix computations.
14:04:18 <musasabi> See the mailing list archives.
14:15:42 <Korollary> my tv shows only the bottom of the picture. Great.
14:15:53 <newsham> power supply failure?
14:15:58 <Korollary> Perfect timing for the playoffs.
14:16:22 <ulfdoz> The rest is censored pr0n probably. :)
14:16:52 <Korollary> If you were to censor for reasons of obscenity, you'd go for the bottom half, imho.
14:21:24 <lambda_boy> hi! maybe i'm being dim but I can't find the file for the State monad in the hugs library
14:21:34 <lambda_boy> anybody know where it is?
14:22:24 <lambda_boy> i can find it on hoogle:
14:22:25 <lambda_boy> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-State.html
14:22:45 <aufrank> Korollary: you would be seeing the cavs absolutely dominating
14:22:59 <lambda_boy> but not in  /usr/lib/hugs/libraries/Control/Monad
14:23:03 <Korollary> aufrank: yeah I just checked the score. Dammit I missed it all.
14:23:16 <aufrank> it's a good day to be from cleveland =D
14:23:42 <Korollary> lambda_boy: I think I run into a similar problem with hugs recently
14:23:57 <lambda_boy> right
14:24:05 <Korollary> lambda_boy: Can you use ghc instead?
14:24:10 <lambda_boy> nice to know im not alone :)
14:24:18 <lambda_boy> yeah i have it installed
14:24:56 <lambda_boy> strangely, when i import Control.Monad.State in hugs, it works!
14:25:18 <lambda_boy> but yeah, ill rumage around in the ghc library for the definitions
14:25:39 <aufrank> Korollary: 'bron is three boards away from a triple double
14:26:01 <Korollary> aufrank: believe it or not, I thought you meant "Colorado Avalanche" with cavs. Heh.
14:31:35 <lambda_boy> hmm of course, all the library files in ghc are compiled
14:31:39 <Korollary> Yeah, hugs doesn't provide the entire hierarchical libs
14:32:10 <Korollary> lambda_boy: You can download/browse the ghc sourcetree
14:32:20 <lambda_boy> right!
14:32:35 <Korollary> damn tv
14:38:30 <lambda_boy> do i have to download a source distribution of ghc or can i browse them somewhere?
14:38:48 <lambda_boy> (to view the definitions of Control.Monad.State)
14:39:12 <xerox> @libsrc Control.Monad.State
14:39:13 <lambdabot> http://darcs.complete.org/fptools/libraries/mtl/Control/Monad/State.hs
14:40:05 <lambda_boy> wow thanks!
14:40:09 <lambda_boy> ill remember that
14:40:14 <xerox> No, unfortunately :-(
14:40:22 <lambda_boy> oh no
14:40:25 <lambda_boy> ic :(
14:41:34 <shapr> So, the excitement continues?
14:41:59 <Korollary> http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/
14:42:35 <xerox> Korollary: why I can't seem to find the sources on darcs.haskell.org/ghc/ ?
14:43:09 <lambda_boy> thanks korollary
14:44:32 <vincenz> shapr: did it work?
14:47:38 <lambda_boy> woo! im there now, i've got the State Monad definitions
14:51:05 <shapr> vincenz: Er, what user?
14:54:48 <shapr> vincenz: works
14:58:10 <vincenz> :)
15:09:12 <xerox> Ah-ha found!!
15:09:27 <xerox> lambda_boy: <http://darcs.haskell.org/packages/mtl/Control/Monad/State.hs>
15:13:44 <nomeata> (If gtk2hs questions are better asked in another channel, please tell me so...)
15:13:56 <xerox> Please go on here.
15:14:04 <nomeata> I want to disconnect a few button clicked handlers when I hide a modal window
15:14:20 <nomeata> I can do that in the onHide handler. But how do I then disconnect that signal hander?
15:15:05 <nomeata> (I have a modal window that is used for both entering and editing a data set, the code that shows the window connects the appropriate action to the buttons)
15:15:06 <xerox> System.Glib.Signals.disconnect, perchance?
15:15:13 <xerox> http://www.haskell.org/gtk2hs/docs/current/System-Glib-Signals.html
15:15:34 <nomeata> yes, but I can't disconnecta signal from within that signal's handler, can I?
15:15:56 <xerox> I don't exactly know, maybe just try it out.
15:15:57 <nomeata> id <- onHide window $ do disconnect id  -- wont work, I guess
15:16:12 <xerox> You have to get the ConnectId object.
15:16:27 <sethk> nomeata, you could spawn a thread, use a semaphore to delay the thread until the handler exits, or some such scheme
15:16:41 <xerox> You get the ConnectId object when you register the handle.
15:16:50 <xerox> Hence, you'll have it in the "parent".
15:17:49 <nomeata> xerox: right, but the "parent" is the handler for the button that opens that window, and I don't want to remove the other handlers until I close the modal window
15:18:32 <xerox> I'm confused on the terminology, I'm sorry.
15:18:34 <nomeata> I might need some kind of global variable containing a list of handlers to remove, but that does not sound very elegant.
15:18:56 <nomeata> I'm new to gtk2hs, and not very experienced with haskell, so please excuse that
15:19:05 <xerox> It doesn't sound elegant but it does sound plausible.  Currently Gtk2Hs enforces IORef-style coding.
15:19:33 <xerox> No, my problem is about GUI terminology, it isn't your fault.
15:20:07 <nomeata> ok, I'll have a look at IORef.
15:20:12 <vincenz> buonasera
15:21:31 <xerox> Suggesting IORefs lowers my karma.
15:22:01 <aufrank> @karma xerox+ -- you're still OK in my book
15:22:02 <lambdabot> xerox+ has a karma of 0
15:22:08 <xerox> Eeeeek!
15:22:19 <xerox> Phew, you put the + in the wrong spot.
15:22:25 <aufrank> oops, i just obsoleted you
15:22:32 <aufrank> now we've got xerox+
15:22:46 * xerox waves to astrolabe 
15:22:58 <xerox> aufrank: I hope not.
15:23:25 <nomeata> hmm. do I really have to harry the IORef around wherever I need it, or can I somehow "attach" it to a widget?
15:24:18 <nomeata> or might there even be a method that just clears all and any signal handers of a widget? (haven't found it though)
15:27:09 <xerox> nomeata: I don't know the exact semantincs of your program, but the IORef could for example contain a list of ConnectId to be disconnected at a certain time.
15:27:55 <sethk> nomeata, you can effectively make it global, but it's somewhat frowned upon
15:28:02 <nomeata> xerox: right. I just wonder if I really have to create that IORef in my outer most function and pass it as a parameter to every subfunction that might need it?
15:28:12 <nomeata> sethk: how can I do that?
15:28:19 <sethk> nomeata, using unsafePerformIO
15:28:31 <sethk> nomeata, for an example, look at Control.Concurrent
15:28:35 * xerox closes eyes and puts fingers in the ears
15:28:44 <sethk> nomeata, the example is for a list of thread ids, but the technique is general
15:29:16 <nomeata> sounds like I have to choose between the semantically ugly and the syntacitcally ugly
15:29:47 <nomeata> (and all because there is no "clearOnClickHandler" function :-( )
15:29:50 <sethk> nomeata, you could also use a monad to make it available, but that might be awkward in this context
15:30:13 <sethk> nomeata, in that case, you've got the source, add a clearOnClickHandler, and get it put into the source
15:30:28 <sethk> nomeata, then you'll have it and so will everyone else once you provide it
15:30:41 * nomeata does not feel able enough to do that
15:30:55 <nomeata> but I'll have a look
15:31:00 <sethk> nomeata, it wouldn't be terribly difficult, you can use a similar handler as a sample
15:40:05 <SamB> nomeata: why don't you think you can disconnect a handler from within itself?
15:52:15 <nomeata> SamB: hmm, maybe I can, but how do I pass the id into the handler -- I get the id when defining the handler (chicken-egg-problem)
15:53:06 <nomeata> what is the nicest haskell equivalent of a "foreach $id (@ids) {disconnect($id)}"?
15:53:24 <Igloo> mapM_ disconnect ids
15:53:27 <nomeata> thx
15:53:33 <xerox> forM_ = flip mapM_
15:53:37 <SamB> nomeata: oh
15:54:06 <ski> forM_ ids $ \id -> do
15:54:08 <ski>   disconnect id
15:54:28 <SamB> @type mfix return :: IO ()
15:54:29 <lambdabot> IO () :: IO ()
15:54:49 <xerox> SamB: uh-oh?
15:54:55 <SamB> nomeata: you could use mfix
15:54:57 <SamB> xerox: what?
15:55:10 <ski> @type (mfix return :: IO ())
15:55:12 <lambdabot> IO ()
15:55:13 <xerox> Where did return's parameter go?
15:55:24 <ski> xerox : from itself
15:55:30 <SamB> @type mfix
15:55:31 <lambdabot> forall (m :: * -> *) a. (MonadFix m) => (a -> m a) -> m a
15:55:43 * xerox is missing it
15:56:02 <SamB> xerox: it ties the argument function's in a loop
15:56:06 <SamB> s/'s//
15:56:10 <nomeata> @type mapM_
15:56:11 <lambdabot> forall (m :: * -> *) a b.
15:56:11 <lambdabot>    (Monad m) =>
15:56:11 <lambdabot>    (a -> m b) -> [a] -> m ()
15:56:33 <eivuokko> Is there a nice function to reverse byteorder (for Words) somewhere in ghc's libs?
15:56:55 <SamB> eivuokko: why?
15:57:11 <SamB> because the answer depends on your answer
15:57:17 <eivuokko> Ok, I take that as no, will do it myself then.
15:59:00 <DeliQ> after reading some monad tutorials, i guess you could make a Tree instance of monad??
15:59:14 <SamB> sure
15:59:38 <DeliQ> return would be insertTree i guess ?
16:02:33 <xerox> DeliQ: it depends upon your Tree type.
16:02:51 <xerox> data Tree a = Leaf a | Node (Tree a) (Tree a)
16:02:56 <DeliQ> yup
16:02:57 <xerox> instance Monad Tree where
16:02:58 <DeliQ> a basic tree
16:03:00 <xerox>   return = Leaf
16:03:04 <xerox>   ...
16:03:12 <xerox> There are multiple version of bind of course.
16:03:17 * SamB wonders why PortNum derives Ord
16:03:27 <DeliQ> why is return a leaf
16:03:29 <SamB> rather than having Ord properly implemented, so that
16:03:38 <DeliQ> can explain that xerox ?
16:03:46 <SamB> > return 1 ++ return 2
16:03:47 <xerox> SamB: to implement, reserved = (<1024) ?
16:03:47 <lambdabot> [1,2]
16:03:52 <ski> a leaf is a single-element tree
16:04:05 <SamB> er, sorry, I broke off mid-sentance
16:04:20 <xerox> I just eta-reducted |return x = Leaf x| (ski correct me if I'm wrong.)
16:04:21 <DeliQ> xerox: from MonadAsContainer i understood return as a function which puts something in a container
16:04:42 <xerox> DeliQ: right, and as ski sais, the containers are the leaves in that Tree.
16:04:43 <ski> (xerox : you are not)
16:04:50 <xerox> Good.
16:04:50 <SamB> anyway, so that 256 > 255 on all platforms
16:05:00 <DeliQ> hmm, ok
16:05:23 <xerox> Since fmap is easily defined on that Tree, the question is how to join trees.
16:05:40 <DeliQ> yup, some kind of mergeTree function ?
16:05:46 <ski> 'return x' should represent the "trivial action" that does nothing special except than to return the value 'x'
16:05:50 <xerox> fmap f (Leaf x) = Leaf $ f x
16:05:58 <ski> and the single-element tree is that action, in this case
16:06:09 <xerox> fmap f (Node l r) = Node (fmap f l) (fmap f r) 
16:06:15 <DeliQ> idd
16:06:30 <DeliQ> i can follow that
16:06:37 <xerox> Yup, ski says that because of the Monads Laws.
16:06:58 <nomeata> using handlerList = newIORef [] somewhere near that top, does that mean that everythime I use "do ids <- handlerList", I get a reference to this one list, or do I create new lists?
16:07:18 <DeliQ> which law specificaly ?
16:07:34 <xerox> nomeata: you get the exact same one.
16:07:44 <xerox> Errr, no sorry!
16:07:57 <xerox> You have to do |ids <- readIORef handlerList|.
16:08:06 <ski> return x >>= k = k x  -- possibly this one
16:08:18 <xerox> I think so too.
16:08:26 <SamB> Prelude Network.Socket> (256 :: PortNumber) > 255
16:08:26 <SamB> False
16:08:27 <DeliQ> hmm ok..
16:08:32 <xerox> SamB: Aww.
16:08:34 <ski> (but '(>>=)' has to be introduced first)
16:08:39 <xerox> So, let's join trees now.
16:08:41 <DeliQ> but you get join for free right ?
16:08:46 <ski> yes
16:08:52 <xerox> Do you?
16:09:01 <DeliQ> after defining bind and return
16:09:02 <xerox> Ah, I see what you mean :-)
16:09:02 <ski> but 'join' is sometimes easier to figure out than '(>>=)'
16:09:13 <ski> so, it can be easier to start in that end
16:09:14 <DeliQ> but let's join them
16:09:30 <xerox> You get it for free because:
16:09:33 <xerox> ?pl (>>= id)
16:09:34 <lambdabot> join
16:09:34 <ski> (since 'join' and 'fmap' gives you '(>>=)')
16:09:50 <nomeata> xerox: I can't use "readIORef" directly on handlerList: Expected type: IORef a Inferred type: IO (IORef [ConnectId Button])
16:10:03 <SamB> @type join fmap
16:10:04 <lambdabot> forall b. (b -> b) -> b -> b
16:10:10 <DeliQ> join would be the concat on lists ?
16:10:11 <SamB> @type fmap join
16:10:13 <lambdabot> forall (f :: * -> *) (m :: * -> *) a.
16:10:13 <lambdabot>      (Functor f, Monad m) =>
16:10:13 <lambdabot>      f (m (m a)) -> f (m a)
16:10:19 <SamB> hmm...
16:10:21 <xerox> ski: we are explaining the thing like folding on the same topic by the two different ends of the list :-)
16:10:25 <DeliQ> so, making multiple trees as one
16:10:29 <xerox> ?type join . fmap
16:10:31 <lambdabot>   Occurs check: cannot construct the infinite type: f = (->) (f a)
16:10:31 <lambdabot>   Expected type: (a -> b) -> f a -> f a -> a1
16:10:34 <xerox> Ops.
16:10:52 <ski> @type let ma >>= amb = join (fmap amb ma) in (>>=)
16:10:53 <lambdabot> forall (f :: *
16:10:53 <lambdabot>                      -> *)
16:10:54 <lambdabot>                    a
16:10:56 <lambdabot>                    a1.
16:10:58 <lambdabot>                 (Monad f, Functor f) =>
16:11:01 <lambdabot>                 f a -> (a -> f a1) -> f a1
16:11:09 <xerox> Okay.
16:11:14 <xerox> ?type (join .) . fmap
16:11:15 <lambdabot> forall a (f :: * -> *) a1.
16:11:15 <lambdabot>        (Monad f, Functor f) =>
16:11:15 <lambdabot>        (a1 -> f a) -> f a1 -> f a
16:11:22 <xerox> ?type (join .) . liftM
16:11:23 <lambdabot> forall a a1 (m :: * -> *).
16:11:23 <lambdabot>        (Monad m) =>
16:11:23 <lambdabot>        (a1 -> m a) -> m a1 -> m a
16:11:26 <SamB> xerox: why you use ?
16:11:36 <xerox> SamB: easier to type.
16:11:51 <ski> DeliQ : yes, like concat
16:11:53 <SamB> looks wierd!
16:12:04 <ski> join :: Tree (Tree a) -> Tree a
16:12:16 <xerox> \vixen lambda!
16:12:21 <DeliQ> i'm trying to foloow you ski...
16:12:23 <xerox> I thought it worked.
16:12:35 <SamB> :keal
16:12:42 <SamB> %keal
16:12:44 <ski> so, as elements in the tree, we have new trees, in which the final elements are in the leaves
16:12:50 <DeliQ> yup...
16:12:52 <ski> DeliQ : ok ?
16:12:55 <ski> m
16:13:08 <ski> so, we need some way of just getting a tree of final elements
16:13:14 <DeliQ> idd
16:13:20 <xerox> What's "idd" ?
16:13:23 <DeliQ> indeed
16:13:28 <nomeata> is there a haskell equivalent to "print-based debuggin", i.e., a semantical no-op that output the value of some variable?
16:13:29 <ski> the simplest way is to just "inline" the element trees where they are
16:13:39 <ski> @index trace
16:13:40 <lambdabot> Debug.Trace
16:13:49 <ski> nomeata : ^^
16:13:52 <nomeata> thx
16:13:53 <DeliQ> yep, idd...
16:13:54 <dcoutts> xerox!
16:14:01 <dcoutts> xerox, you rang.
16:14:06 <xerox> I.e. swap (Leaf (x :: Tree a)) with the appropriate Node.
16:14:29 <DeliQ> i get it
16:14:38 <ski> (DeliQ : and, it turns out that doing that satisfies the monad laws)
16:14:52 <ski> join (Leaf ta) = ta
16:15:06 <DeliQ> that's the easy case
16:15:10 <DeliQ> now the Node case
16:15:17 <ski> join (Node la ra) = Node (join la) (join ra)
16:15:24 <xerox> join (Node l r) = Node<Interrupted by ski>
16:15:29 <ski> just walk down, preserving the structure
16:15:42 <DeliQ> ok.. quite simple...
16:15:55 <ski> so, actually, the 'Node' case is simpler than the 'Leaf' case (imo, at least :)
16:15:58 <bolrod> ok.. I didn't quite follow.. can you explain everything again?
16:15:59 <xerox> Yay, it looks to me like blowing in a glove :-)
16:16:00 <DeliQ> hehe
16:16:02 <bolrod> j/k ;)
16:16:03 <xerox> Doesn't it?
16:16:14 <DeliQ> now bind them
16:16:22 <DeliQ> what would binding trees be ?
16:16:32 <xerox> (>>=) = (join .) . liftM
16:16:36 <ski> ma >>= amb = join (fmap amb ma)
16:16:41 <xerox> Or fmap or whatever.
16:17:12 <ski> first we map the continuation function 'amb' over each element in the tree .. this gives us a tree of trees
16:17:25 <DeliQ> aha, it applies some function f and joins them together afterwards
16:17:27 <ski> then we just remove the indirections at the internal leaves
16:17:32 <ski> so
16:17:51 <ski> Leaf a >>= k = k a
16:18:04 <ski> Node la ra >>= k = Node (la >>= k) (ra >>= k)
16:18:06 <xerox>   tree >>= action = join (fmap action tree)
16:18:06 <xerox>     where join (Leaf t) = t
16:18:07 <xerox>           join (Node l r) = Node (join l) (join r)
16:18:37 <DeliQ> i get it..
16:18:57 <DeliQ> what does k represent ?
16:19:02 <ski> DeliQ : if one wants, one can do step-by-step equational-reasoning from the def. of 'join' and the general def. of '(>>=)' to derive this direct implementation
16:19:06 <DeliQ> some action we want to apply ?
16:19:23 <ski> (>>=) :: Monad m => m a -> (a -> m b) -> m b
16:19:29 <ski> m >>= k
16:19:32 <ski> k :: a -> m b
16:19:41 <ski> if you have
16:19:46 <ski> do x <- bleh
16:19:53 <ski>    ..blah..
16:19:56 <ski> i.e.
16:20:01 <DeliQ> so k sais, give me an a and make a box of b's
16:20:07 <ski> bleh >>= \x ->
16:20:10 <ski> ..blah..
16:20:17 <bolrod> bleh blah bloh
16:20:23 <ski> then your 'k' is the '\x -> ..blah..'
16:20:30 <DeliQ> let's use al vowels ;)
16:20:30 <bolrod> I am on the edge of understanding the State monad :)
16:20:31 <ski> the continuation of the action
16:20:41 <DeliQ> i get it
16:20:45 <ski> fine
16:20:50 <DeliQ> thanks for explaining ski and xerox
16:20:59 <ski> yw
16:21:03 <DeliQ> i must say, mondas facinate me :P
16:21:08 <DeliQ> monads*
16:21:19 <ski> :)
16:21:55 <ski> (bolrod : do you have any query ? or you want to think and read more on your own ?)
16:22:06 <DeliQ> ski: you must have explained this like a million times before ?
16:22:29 <bolrod> welll.. could you show one simple use of the state monad ?\
16:22:53 <DeliQ> ski for president :P
16:22:56 <DeliQ> haha
16:23:23 <nomeata> do ids <- handlerList; modifyIORef ids ((:) okid) -- should append okid to the list of ids in the handlerList, right?
16:23:30 <ski> bolrod : have you seen numberTree ?
16:23:50 <bolrod> urh
16:24:02 <bolrod> no
16:24:13 <ski> (DeliQ : well, some times anyway)
16:24:46 <ski> a simple version is like this
16:25:08 <ski> numberTree :: Num b => Tree a -> Tree b
16:25:10 <ski> or
16:25:14 <ski> numberTree :: Num b => Tree a -> Tree (a,b)
16:25:25 <ski> if you want to preserve elements in the tree
16:25:42 <ski> anyway, this should just walk through tree, depth-first, and number the leaves
16:25:52 <ski> so it has to keep a state of the current number
16:25:57 <ski> understand ?
16:26:08 <bolrod> I hope :)
16:26:13 <DeliQ> yep i understand :P
16:26:39 <bolrod> maybe there is a site somehwere with that example?
16:26:50 <ski> possibly, yes
16:27:08 <ski> so, 'numberTree' will of course be a wrapper that initializes the state to 0, runs the worker, and throws away the final state
16:27:28 <DeliQ> yup...
16:27:42 <ski> numberTree t0 = t1
16:27:44 <ski>   where
16:27:52 <ski>   (t1,_) = loop t0 0
16:28:13 <ski>   loop :: Num b => Tree a -> b -> (Tree (a,b),b)
16:28:25 <ski> would be one way of writing this directly
16:28:50 <DeliQ> loop would be the "worker" ?
16:28:53 <ski> yes
16:28:57 <bolrod> hmm... I think I'll search the example :)
16:29:31 <DeliQ> ski go on please... i'm following you..
16:29:37 <ski> now, it is a little cumbersome to explicitely thread the number state around in 'loop'
16:29:40 <nomeata> ok, looks like I must run newIORef only once
16:30:08 <DeliQ> yup and ugly i guess
16:30:13 <ski> if you want to see how this 'loop' would look like, i can show .. otherwise i'll just head straight on the monadic version
16:30:28 <DeliQ> show us the monad :P
16:31:53 <ski> in the type for 'loop' above, we see a pattern 'b -> (Tree (a,b),b)', the 'b' represents the state type, and we both get an input of this type, and return an output of this type, additionally also returning something else (here 'Tree (a,b)')
16:32:21 <ski> we abstract this pattern into a monad, the state monad
16:32:32 <DeliQ> yup...
16:32:45 <ski> newtype State s a = MkS {unS :: s -> (a,s)}
16:33:06 <ski> do you understand the syntax there ?
16:33:18 <bolrod> I don't
16:33:22 <bolrod> well
16:33:27 <DeliQ> i understand
16:33:27 <ski> this is same as
16:33:36 <ski> newtype State s a = MkS (s -> (a,s))
16:33:36 <DeliQ> MkS is the contructor
16:33:45 <ski> unS :: State s a -> (s -> (a,s))
16:33:52 <ski> unS (MkS f) = f
16:34:01 <DeliQ> unS = unState ??
16:34:07 <ski> (and 'newtype' there is almost same as 'data')
16:34:08 <ski> yes
16:34:21 <ski> just two coercing functions
16:34:34 <ski> to go between the type 's -> (a,s)' and the type 'State s a'
16:34:44 <DeliQ> yup
16:34:57 <DeliQ> one question in between
16:35:01 <DeliQ> what is s and a
16:35:06 <DeliQ> s is the current state ?
16:35:08 <ski> 's' represents the type of the state, and 'a' represents the type of the monadic answer/result (above it was 'Tree (a,b)')
16:35:10 <DeliQ> but what is a
16:35:17 <DeliQ> ok...
16:35:24 <ski> so, instead of having
16:35:29 <ski>   loop :: Num b => Tree a -> b -> (Tree (a,b),b)
16:35:32 <ski> we will have
16:35:42 <ski>   loop :: Num b => Tree a -> State b (Tree (a,b))
16:36:03 <DeliQ> that's understandable
16:36:07 <ski> ok
16:36:30 <ski> now we need to make this into a monad
16:36:41 <DeliQ> i guess so :P
16:36:50 <ski> note, to be fully correct, 'State' is not a monad
16:37:01 <ski> 'State s' is a monad, for any type 's'
16:37:16 <DeliQ> hmm i get it
16:37:18 <ski> a monad type constructor takes one type argument
16:37:21 * dcoutts is pleased to announce that Gentoo's Haskell team is approaching 5 strong (3 existing members + 2 new recruits)
16:37:24 <ski> 'State' wants two
16:37:30 <ski> 'State s' wants one
16:37:41 <DeliQ> i get it
16:37:44 <ski> ok
16:37:59 * swoolley is pleased to announce that few care about Gentoo self-promotion.
16:38:11 <ski> so we start with the 'Monad' instance
16:38:27 <shapr> swoolley: eh?
16:38:28 <xerox> dcoutts: nice!
16:38:36 <ski> instance Monad (State s)   -- note, 'State s', not 'State'
16:38:36 <dcoutts> xerox, yeah :-)
16:38:37 <ski>   where
16:38:52 <ski> --return :: a -> State s a
16:38:52 <swoolley> Why would a distro have a "haskell team"?
16:38:54 <dcoutts> We're planning to take over the world :-)
16:38:56 <DeliQ> i'm following you ski...
16:39:00 <DeliQ> go on
16:39:03 <shapr> swoolley: Because they want to support Haskell packages?
16:39:07 <dcoutts> swoolley, to create and maintain packages for that distro
16:39:22 <sethk> no, no, I've already taken over the world, and I don't want to share any of it
16:39:23 <dcoutts> swoolley, Debian have a big Haskell team too
16:39:30 <ski> DeliQ : do you see why the type of 'return' in this instance is like i showed in the comment ?
16:39:36 <dcoutts> Fedora have a Haskell "team" of one
16:39:37 <shapr> Yeah, RedHat has juhp and more?
16:39:40 <DeliQ> yep i get it
16:39:41 <swoolley> yeah, but do they all announce it?
16:40:00 <shapr> Yeah, often.
16:40:01 <dcoutts> swoolley, well IRC isn't exactly a bit announcement :-)
16:40:04 <dcoutts> bit/big
16:40:10 <DeliQ> ski: it gives 'a' a state ?
16:40:13 <ski>   return a = MkS (\s -> (a,s))  -- trivial action, just wait for a state, and then return the value with unchanged state
16:40:20 <swoolley> I made the haskell packages for my distro, but never announced them but for changelogs.
16:40:21 <ski> DeliQ : which ?
16:40:25 <shapr> swoolley: Which distro?
16:40:29 <DeliQ> --return :: a -> State s a
16:40:30 * dcoutts is merely feeling chuffed that he's got 2 new recruite
16:40:31 <swoolley> sourcemage.org
16:40:37 <dcoutts> recruite/recruits
16:40:38 <shapr> cool
16:40:50 * dcoutts is havign trouble spelling due to gin & tonic
16:41:06 <swoolley> I'm the main QA person for sourcemage
16:41:20 <mahogny> dcoutts, I hope you haven't tried the dark art of Drunken Coding
16:41:21 <DeliQ> i get the return definition
16:41:30 <ski> DeliQ : the general type of 'return' inside the definition of the 'Monad' class (given the monad type constructor is named 'm') is
16:41:36 <ski>   return :: a -> m a
16:41:43 <dcoutts> mahogny, it works great 'til you look at the code the next morning ;-)
16:41:44 <DeliQ> and m = State s
16:41:49 <mahogny> dcoutts, :D
16:41:53 <ski> DeliQ : exactly :)
16:41:56 <DeliQ> ;)
16:42:08 <dcoutts> swoolley, "sourcemage" is a name of a distro?
16:42:14 <DeliQ> so what will bind to then ?
16:42:18 <DeliQ> to = do
16:42:20 <swoolley> dcoutts: yeah, it's been around as long as gentoo
16:42:28 <shapr> mahogny: Any new thoughts on laziness?
16:42:45 <swoolley> dcoutts: built from source, all written in bash, in the lfs tradition.
16:42:46 <mahogny> shapr, no. my standpoint is the same as for the past 5 years or so :)
16:42:49 <shapr> swoolley: #haskell is OS/distro agnostic (except for House, maybe).
16:42:56 <ski> --(>>=) :: State s a -> (a -> State s b) -> State s b
16:43:01 <swoolley> shapr: I would hope so :)
16:43:05 <shapr> We encourage people to use Haskell on any hardware or software.
16:43:31 <DeliQ> and the definition of bind ?
16:43:41 <xerox> Embed GHC in your systems!
16:44:03 <nomeata> is there a "isInt :: String -> Bool" function to check user input before calling "read"?
16:44:03 <swoolley> ghc's main problem is it takes forever to build
16:44:27 * xerox is wonder how he may go to get the ghc darcs without darcs
16:44:37 <shapr> I could go for an impredicative type system myself...
16:44:37 <xerox> wondering, even.
16:44:40 <ski> DeliQ : the returned action of type 'State s b' will wait for an initial state, pass it to the first action (of type 'State s a') to get a value of type 'a' and a new state of type 's', pass the value to the continuation function to get the second action (of type 'State s b'), pass the new state to this to get a final value and a final state, and those are returned
16:44:40 <mauke> @type reads
16:44:41 <lambdabot> forall a. (Read a) => ReadS a
16:44:50 <DeliQ> ski: let me read for a sec
16:45:12 <dcoutts> swoolley, I see, cool, so what's the state of Haskell/GHC support there? Perhaps we could learn something from each other
16:45:31 <mauke> > reads "123xyz" :: ReadS Int
16:45:32 <lambdabot> Couldn't match `[(a, String)]' against `t -> t1'
16:45:41 <mauke> oh, ok
16:45:47 <swoolley> Personally, I added ghc and darcs which I know work on x86 and x86_64.
16:45:59 <swoolley> there might be more, but I don't know of anything else as yet.
16:45:59 <DeliQ> ski: so if i may translate for myself, bind in a state monad take a state and a value, and gives the new state and value
16:46:12 <dcoutts> swoolley, one possability for getting ghc to build faster is "hc builds"
16:46:24 <dcoutts> ie building from a .hc bundle
16:46:28 <ski>   MkS s_as >>= amb = MkS $ \s0 ->
16:46:28 <ski>     let (a,s1) = s_as s0
16:46:28 <ski>         (b,s2) = unS (amb a) s1
16:46:28 <ski>     in  (b,s2)
16:46:55 <dcoutts> which means it just uses gcc, so it's quick (amd parallelises well too). It's reported to build in 20min rather than 1hour+
16:47:04 <swoolley> heh
16:47:10 <DeliQ> i see what your doing
16:47:20 <Korollary> dcoutts: hc builds should be the norm unless you're a ghc dev, yes?
16:47:24 <swoolley> took six hours last time I tried.
16:47:25 <dcoutts> swoolley, OpenBSD uses this method, we're planning to look into it for Gentoo
16:47:30 <DeliQ> now lets make the numbertree instance of state monad
16:47:45 <dcoutts> Korollary, typically people do ordinary builds rather than .hc builds
16:47:57 <ski> (DeliQ : of course, instead of matching out '(b,s2)' to return it, we could just return 'unS (amb a) s1' directly)
16:48:07 <dcoutts> Korollary, there arn't many registerised .hc tarballs available (only OpenBSD as far as I know)
16:48:31 <dcoutts> xerox, I've added my bit to the SoC page
16:48:31 <ski> DeliQ : yes, we need two more general operations, apart from defining 'loop' itself
16:48:32 <DeliQ> ski: true, but this was more clear for me
16:48:39 <swoolley> our philosophy is to build as close to the source as possible, which means a .hc build would not be the default.
16:48:53 <ski> (DeliQ : which was why i displayed this variant, of course :)
16:49:00 <xerox> dcoutts: LOL you called me "Peolo"
16:49:02 <DeliQ> ;)
16:49:10 <dcoutts> xerox, doh!
16:49:13 <ski> so
16:49:20 <DeliQ> let's start with the general operations then
16:49:36 <ski> we need a way to "run" State-actions
16:49:36 <dcoutts> xerox, fixed (I think...)
16:49:47 <ski> run :: State s a -> s -> (a,s)
16:49:48 <xerox> dcoutts: hehe, it's okay.
16:49:50 <DeliQ> yep i see what you mean
16:49:57 <ski> run = unS
16:50:09 <dcoutts> xerox, I did say I'd been on the gin (back from a big party)
16:50:14 <xerox> DeliQ: after finishing with Monad State, I'm suggesting you to poke at Arrow State, i.e. roll up your own definition :-)
16:50:27 <xerox> dcoutts: yup I read.  It's no problem really, funny :-)
16:50:40 <DeliQ> xerox: after ski explaining this i will do some experimenting myself
16:50:55 <ski> the other operation we need here, is for accessing the state and doing something with it
16:51:14 <ski> in this case, an operation to get current value, and increment the state is sufficient
16:51:41 <DeliQ> so the general operations are dependant on the current implementation ?
16:51:53 <ski> i'll define it directly as a primitive (one could also define other operations and define this in terms of them, instead)
16:52:00 <nomeata> isNumber string = and (map isDigit string) -- is there a better way?
16:52:01 <ski> the primitive operations are
16:52:14 <mauke> @type all
16:52:15 <ski> tick :: Num a => State a a
16:52:15 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
16:52:24 <lispy> > isNumber "-1"
16:52:25 <lambdabot>  Not in scope: `isNumber'
16:52:32 <lispy> @hoogle isNumber
16:52:33 <lambdabot> No matches found
16:52:38 <DeliQ> ski: tick = (+1) ?
16:52:41 <mauke> > all isDigit "-1"
16:52:43 <lambdabot> False
16:52:46 <lispy> nomeata: is that  in parsec?
16:52:57 <ski> DeliQ : more or less
16:53:01 <DeliQ> oke i get it
16:53:16 <ski> tick = MkS (\n -> (n,n+1))
16:53:20 <mauke> > (reads :: ReadS Int) "123xyz"
16:53:21 <lambdabot> [(123,"xyz")]
16:53:46 <xerox> tick = do n <- get
16:53:46 <xerox>           put (n + 1)
16:53:54 <nomeata> lispy: parsec? I just made that up myself
16:54:05 <lispy> nomeata: ah
16:54:10 <DeliQ> xerox: get and put are in prelude or something ?
16:54:12 <ski>           return n
16:54:29 <xerox> DeliQ: get and put are defined under the MonadState class.
16:54:41 <ski> DeliQ : that is one way to define it in terms of other primitives
16:54:42 <DeliQ> xerox: ok
16:54:50 <DeliQ> ski: i see...
16:54:57 <ski> DeliQ : so, on to 'numberTree' and 'loop', then
16:54:58 <lispy> oh, isn't there an example of how to use MonadState that uses random number generators?
16:55:03 <xerox> That means that you define them for each Monad does do State.
16:55:20 <ski> numberTree t0 = t1
16:55:21 <ski>   where
16:55:38 <ski>   (t1,_) = run (loop t0) 0
16:55:56 <ski>   loop :: Num b => Tree a -> State b (Tree (a,b))
16:56:13 <DeliQ> ski: can you show me the monadic loop version ?
16:56:32 <ski>   loop (Leaf a) = do n <- tick
16:56:50 <ski>                      return (Leaf (a,n))
16:57:14 <ski> if you expand the do-notation, that becomes
16:57:18 <DeliQ> and the Node case ?
16:57:25 <ski>   loop (Leaf a) = tick >>= \n ->
16:57:32 <ski>                   return (Leaf (a,n))
16:58:02 <ski>   loop (Node l0 r0) = do l1 <- loop l0
16:58:14 <ski>                          r1 <- loop r0
16:58:26 <ski>                          return (Node l1 r1)
16:58:38 <ski> that's it
16:58:39 <DeliQ> with monads it becomes all so elegant..
16:58:51 <DeliQ> :P
16:59:40 <DeliQ> ski: i must thank you for your perfect explanation
17:00:04 <DeliQ> make me eager to go and experiment :P
17:00:15 <ski> :)
17:00:47 <DeliQ> ski: i'm implementing some functions on predicate logic
17:01:04 <profmakx> hi
17:01:33 <DeliQ> ski: and i have a function which substitutes variables in a predicate
17:01:41 <DeliQ> i could use a state monad for that
17:02:13 <ski> possibly, yes
17:02:47 <DeliQ> it's 2am here, so i'm going to bed :P
17:02:52 <DeliQ> dreaming haskell code :P
17:02:54 <DeliQ> haha
17:03:33 <xerox> 'night!
17:03:36 <DeliQ> see you later all, have a good night
17:04:33 * xerox <- out
17:05:05 <Thlayli> hi! could anyone please take a look at this code: http://pastebin.com/675997
17:05:08 <Thlayli> is this haskell?
17:05:27 <dcoutts> it looks like Haskell code
17:06:10 <Thlayli> thanks
17:06:19 <Thlayli> i thought this is ada
17:06:28 <Thlayli> or Mary
17:06:35 <Thlayli> but now i'm sure it's haskell
17:07:41 <mahogny> ehr. that doesn't look like ada at all :o
17:10:40 <Thlayli> i've never programmed ada or haskell
17:11:25 <Thlayli> i though it was ada because a friend told me so
17:11:39 <Thlayli> he was wrong :(
17:17:06 <monochrom> @pl (\p c -> f p (fst c))
17:17:06 <lambdabot> (. fst) . f
17:17:17 <monochrom> Yuck :)
17:35:10 <Thlayli>  Last generator in do {...} must be an expression
17:35:13 <Thlayli> what does that mean?
17:35:30 <mauke> what's the last line in your do {}?
17:35:31 <Thlayli> error is the following line: char '-'
17:35:44 <mauke> hmm, that is an expression
17:35:44 <Thlayli> return (dd ++ de)
17:35:57 <Thlayli> i don't use curly braces, though
17:36:05 <Thlayli> i just want to fix that small program
17:36:15 <mauke> maybe your indentation is broken
17:36:20 <dons> moin
17:36:22 <Thlayli> that can well be
17:36:27 <mauke> what program?
17:36:48 <Thlayli> well, i currently play a game called mod-x
17:36:53 <Thlayli> this is level7#
17:37:19 <Thlayli> one had to break the password-protection in order to get a source file of an unknown language
17:37:26 <Thlayli> this language turned out to be haskell
17:37:35 <jip> hehe
17:37:44 <Korollary> paste it
17:37:45 <Thlayli> you now have to fix the program and let it gulp 3500 codes
17:37:48 <Thlayli> to find the correct one
17:37:51 <Thlayli> the whole program?
17:37:56 <Thlayli> only 66 lines
17:38:01 <Thlayli> already solved some issues
17:38:02 <Maddas> Wouldn't that defeat the point of the game? :-)
17:38:04 <Korollary> lisppaste2: url
17:38:04 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
17:38:08 <aufrank> Thlayli: is this something over at unfiction.com ?
17:38:08 <jip> post that shit
17:38:23 <Thlayli> i've never heard of unfiction.com
17:38:54 <aufrank> it's a forum for alternate reality games, which often involve the sort of puzzle solving you're describing
17:39:09 <Thlayli> well i'll check it out
17:39:14 <aufrank> great site
17:39:19 <Thlayli> if you're interested: here's the url of the game:
17:39:24 <Thlayli> www.mod-x.co.uk
17:39:31 <aufrank> last I looked, Perplex City was the best thing running
17:39:44 <Thlayli> i'll now paste the program, and a version with bugs i already fixed
17:39:47 <Korollary> sorta reminds me of The Python Challenge
17:39:57 <liyang> Mmmm... persplex.
17:40:16 <sethk> Korollary, sure that wasn't the monty python challenge?
17:40:38 <Korollary> sethk: No, it was a set of puzzles that were meant to be solved using snippets in python.
17:40:45 <sethk> I know ...
17:40:54 <Korollary> I am naive and gullable
17:41:25 <Korollary> and I am watching Montreal destroy Carolina.
17:41:29 <lisppaste2> Thlayli pasted "mod-x unfixed" at http://paste.lisp.org/display/19260
17:42:11 <lisppaste2> Thlayli pasted "fixed a few things" at http://paste.lisp.org/display/19261
17:44:04 <mauke> eww, too many do's
17:44:17 <Korollary> well, it's supposed to be a puzzle.
17:44:38 <Thlayli> hmm, line 55:
17:45:28 <Thlayli> ddd <- many (do digit)
17:45:33 <Thlayli> what's wrong with that?
17:46:04 <mauke> not sure, but I wouldn't use "do" there
17:46:09 <mauke> ddd <- many digit
17:46:19 <Thlayli> thanks very much
17:47:22 <Korollary> I think there's an indentation problem before that. the third line in code2.
17:47:40 <mauke> are you looking at the old version?
17:48:08 <Korollary> ah yes
17:49:34 <Korollary> @index many
17:49:35 <lambdabot> Text.ParserCombinators.Parsec.Prim, Text.ParserCombinators.Parsec, Text.ParserCombinators.ReadP, Distribution.Compat.ReadP
17:49:39 <Korollary> @type many
17:49:41 <lambdabot> Not in scope: `many'
17:49:44 <Korollary> er
17:50:01 <Korollary> @type Text.ParserCombinators.Parsec.many
17:50:02 <lambdabot> forall a st tok.
17:50:02 <lambdabot>              Text.ParserCombinators.Parsec.Prim.GenParser tok st a
17:50:02 <lambdabot>              -> Text.ParserCombinators.Parsec.Prim.GenParser tok st [a]
17:50:25 <mauke> many :: Parser a -> Parser [a]
17:51:18 <SamB> mauke implements @type better ;-)
17:52:07 <mauke> well, the actual type is many :: Combine (Parser tok st [a]) -> Parser tok st a -> Parser tok st [a]
17:58:26 <bolrod> DAMNIT!    :(
17:58:44 <bolrod> my computer casing resonates with the fans
17:58:47 <bolrod> ;/
18:02:29 <Thlayli> hmm, i still don't get what's wrong with code4 and code5. could someone please take a look? that would be very nice :)
18:03:04 <Thlayli> i'm working my way through the monads section of a tutorial at the moment, but i'm such a lazy guy ;)
18:04:17 <dons> musasabi: I've added a dummy FastPackedString back into the repo. good idea.
18:07:46 <bolrod> holy smokes!  thats no  a fan!! thats a hard disk!!!!!!
18:07:57 <bolrod> dayum!  note to self:  REALLY buy new hard disk
18:12:59 <Thlayli> code5 :: Parser
18:13:05 <Thlayli> Illegal Type in type expression
18:13:25 <Thlayli> so what's wrong with this?
18:13:51 <mauke> do you have ParseLib?
18:14:12 <Thlayli> i think so
18:14:15 <Thlayli> i'm using hugs
18:14:23 <Thlayli> started it with the +98 version
18:14:31 <Thlayli> i though hugs has got an implementation of it
18:14:55 <Thlayli> wouldn't i get an error at "impot ParseLib" if it wasn't present?
18:15:40 <mauke> ah, Parser is a type constructor
18:17:14 <mauke> you need to add the right return types to the parsers
18:17:33 <mauke> or just remove the type declarations, haskell should be able to figure it out on its own
18:40:14 <Thlayli_> q : "ss" does not work 'cause q is of type [char]...so how do i concatenate these strings?
18:44:35 <hoan> q++"ss"
18:44:45 <Thlayli_> yep, got that
18:44:48 <Thlayli_> thanks anyway
18:44:53 <hoan> np
18:50:44 <sethk> If on a data type, an enumeration (all data constructors have no arguments), if I use deriving eq, will the order be the order in which the constructors appear?
18:50:56 <sethk> sorry, not eq
18:50:58 <sethk> deriving ord
18:51:02 <Cale> sethk: you mean Ord, yeah
18:51:21 <sethk> Cale, right, Ord  :)  so the order is the order of appearance of the constructors?
18:51:22 <Cale> and yes, it's essentially the lexicographic order
18:51:34 <sethk> Cale, thanks
18:51:48 <Cale> earliest constructors first, and equal constructors compared by their next component, and so on
18:52:16 <sethk> Cale, this is a simple case, an enumeration really, because there are no components
18:52:26 <sethk> so I guess it is simply the order of the constructors
18:52:34 <Cale> yeah
18:52:49 <sethk> as in  data foo = True | False | Whatever     sort of thing
18:53:03 <Cale> yeah, there True < False
18:53:07 <Cale> and False < Whatever
18:53:16 <sethk> thanks, that's what I was looking for
18:53:17 <SamB> > True < False
18:53:19 <lambdabot> False
18:53:38 <sethk> SamB, my example doesn't match the library, obviously  :)
18:53:42 <palomer> > True < False < False
18:53:43 <lambdabot>   precedence parsing error
18:53:43 <lambdabot>    cannot mix `(<)' [infix 4] and `(<)' [infix 4] in the same infix expression
18:53:47 <SamB> > [minBound..maxBound] :: [Bool]
18:53:49 <lambdabot> [False,True]
18:54:05 <palomer> > (True < False) < (False < True)
18:54:07 <lambdabot> True
18:54:21 <SamB> > True < (False < False)
18:54:22 <lambdabot> False
18:54:34 <SamB> > (True < False) < False
18:54:35 <lambdabot> False
18:54:44 <sethk> what I'm actually doing is I have a trace thing with a logging level, and I want to say, e.g., level >= Verbose.  I know that one exists, but mine is much simpler
18:58:01 <dons> morning sethk.
18:58:08 <sethk> dons, morning
19:05:27 <sethk> Cale, I had to derive both eq and ord
19:05:51 <sethk> that makes sense, I'm doing <=
19:06:07 <Cale> Ord requires Eq
19:06:27 <Cale> (Ord is a subclass of Eq)
19:11:49 <juhp> shapr: well gemi is one more (though his packages cover FPL and more in general)
19:11:51 <sethk> Cale, we don't have the type of inheritence that says "you are deriving Ord so obviously you also need Eq"
19:12:08 <Cale> sethk: there's no inheritance at all
19:12:25 <sethk> Cale, how can you have a subclass without inheritence?
19:13:19 <juhp> dcoutts: hIDE won't build with the current releases of ghc and gtk2hs, right?
19:13:25 <Cale> Well, it means that Ord dictionaries can carry around Eq dictionaries with them in the implementation, which means one less pointer, I suppose.
19:14:05 <dcoutts> juhp, yeah, it needs special snapshots of ghc & gtk2hs
19:14:06 <sethk> Cale, but no visibility at the code level?
19:14:21 <sethk> Cale, thanks
19:14:45 <Cale> But on the language side of things, there are only two effects: One is that it becomes a requirement that there be an instance of Eq a whenever there is an instance of Ord a, and the second is that in a class context in a type signature, Ord a implies Eq a, and so you don't have to mention Eq if you've mentioned Ord.
19:15:45 <sethk> Cale, not that it's a big issue, but I wonder why, if it can work that way in a class context, it can't work that way in deriving?  Or would that be a bad thing for some reason?
19:16:18 <Cale> I suppose that it would be reasonable.
19:17:17 <Cale> But certainly, if you're defining the instances yourself, you have to have an explicit instance (either via deriving or an instance decl) for Eq somehow, before you may have one for Ord.
19:17:31 <sethk> Cale, yes
19:17:44 <sethk> Cale, with deriving, though, it's all magic anyway
19:22:45 <SamB> well, maybe you would want to derive the instance for one thing, but define your own for something it depends on?
19:22:48 <SamB> does that make sense?
19:22:56 <Cale> ah, yeah
19:23:08 <Cale> You might want to derive the instance for Ord, but not for Eq
19:23:16 <sethk> that's true
19:29:10 <palomer> it can happen to you
19:36:46 <monochrom> When you use Parsec with a tokenizer (i.e., you use GenParser tok () a, with tok != Char), how do you write the tokenizer?
19:37:24 <Cale> monochrom: typically you write it with parsec :)
19:38:14 <Cale> (though one could use alex or another tool)
19:38:47 <dons> alex is simple , easy and efficient.
19:39:27 <dons> but its an offline style lexer generator, rater than the funkier combinator style we all love
19:40:00 <monochrom> But parsec is too strict.
19:40:41 <dons> the only lazy lexer I know of is CTK.
19:40:55 <dons> so you could certainly use that, if needing a lazy lexer
19:41:52 <monochrom> I think it's unethical for a lexer to be strict.
19:42:45 <dons> lovely :)
19:42:47 <sethk> monochrom, there are a lot of unethical lexers
19:59:34 <SamB> hmm. Emacs doesn't seem to communicate well with uxterm
20:03:47 <sethk> SamB, what's uxterm, compared to regular old xterm?
20:03:58 <sethk> unicode?
20:04:05 <SamB> well, basically it is xterm with some options set
20:04:14 <SamB> also a wrapper script that sets those options
20:07:39 <sethk> SamB, my emacs is compiled for X, so I can't see what it is doing in xterm here.  I don't remember an argument to tell emacs to not run in X; I know you can compile it for console only
20:08:02 <Korollary> emacs -nw
20:08:03 <SamB> sethk: I meant in terms of pasting
20:08:13 <sethk> SamB, what happens?
20:08:23 <SamB> $(A!K!K!K!K(B
20:08:26 <sethk> Korollary, thanks
20:08:31 <SamB> well, okay, so emacs copies text wierd
20:09:07 <Cale> How about a jazz band made up of Haskell programmers called "Melodious Thunk"?
20:09:25 <sethk> seems ok
20:09:33 <sethk> SamB, paste seems ok here
20:09:47 <sethk> Cale, I might be the only one here old enough to know who you are talking about
20:10:04 <monochrom> emacs -nw
20:11:04 <thetallguy> Don't have to be old to have heard of Thelonius Monk.
20:11:07 <Cale> Well, I'm only 23.
20:14:32 <sethk> Cale, that's encouraging
20:15:55 <palomer> I'm 23
20:15:59 <palomer> I've heard that name before
20:16:17 <gzl> Thelonius Monk is pretty famous.
20:17:52 <sethk> gzl, I saw him play several times.  If you are 23, you can't say that.  :)
20:18:12 <gzl> having heard of somebody and seeing them live are two pretty different things. :P
20:19:15 <sethk> gzl, especially if they were dead before you were born.  makes it tough.
20:21:02 <gzl> yeah.
20:21:18 <gzl> I haven't seen Bach live in concert either.
20:22:01 <palomer> I heard he was something else
20:22:03 <Cale> I never got to see Zappa live, but I'll be seeing his son in concert (playing his father's music) soon.
20:22:34 <palomer> he's coming to the backwaters of canada, aka waterloo?
20:22:52 * Philippa is also 23 and also got the reference FWIW
20:23:05 <Cale> He's playing in Toronto on June 16th.
20:23:40 <Philippa> Melodious Thunk would also be a good name for eg a sequencer written in Haskell
20:24:38 <palomer> someone should write a sequencer in haskell
20:27:30 <palomer> actually, nevermind. way too useful
20:31:37 <olliej> dons: you there?
20:45:58 <dons> yep
20:47:26 <olliej> if i have a function fooo, such that foo = (length [1..]) + 4
20:47:32 <olliej> should foo terminate?
20:48:10 <dons> no, how could it?
20:48:17 <dons> > (length [1..]) + 4
20:48:21 <lambdabot> Terminated
20:48:24 <olliej> i was trying to work out where the thunk should be generated :)
20:48:46 <dons> 'foo' on its own can be passed around, but if you try to evaluate it, it will diverge
20:48:50 <olliej> dons: ie, whether foo should return a thunk or a value
20:48:54 <dons> > let f = (length [1..]) + 4 in length [f,f,f]
20:48:55 <olliej> dons: :)
20:48:56 <lambdabot> 3
20:49:08 <dons> its a lazy langauge. so its a thunk
20:49:15 <dons> until you force it.
20:49:25 <olliej> dons: was temporarily paranoid about being to agressive when inlining primops
20:49:25 <dons> > let f = (length [1..]) + 4 in head [f,f,f]
20:49:31 <lambdabot> Terminated
20:49:32 <dons> ah
20:52:25 <olliej> hmmmm... my code is doing something odd
20:55:33 <palomer> > 2.
20:55:34 <lambdabot>  parse error on input `}'
21:03:51 <dons> hmm. my code runs faster when I import Data.Char (even though no char things are used on the src level)
21:04:31 <olliej> hehe
21:10:47 <thetallguy> Anyone know of an image manipulation library written in Haskell?
21:12:00 <dons> its a common question. all the ones we know of are on haskell.org under 'Libraries and tools'
21:12:18 <dons> wxHaskell provides a number, from memory, including .png and .jpg stuff
21:12:28 <dons> a binding to some fast C lib would be useful and welcome, I think
21:12:33 <dons> ?wiki Libraries_and_tools
21:12:34 <lambdabot> http://www.haskell.org/haskellwiki/Libraries_and_tools
21:12:36 <dons> ^^ there
21:16:01 <thetallguy> Okay, thanks, that's what I had concluded.
21:16:03 <dons> hehe, and people complain about ugly haskell code on the shootout, the Clean guys are pretty evil too: print_permutations :: !*{#Int} !*{#Int} !*{#Int} !Int !Int !Int !*File -> *File
21:16:18 <thetallguy> I'm looking for something like netpbm
21:16:41 <dons> perhaps ask on haskell-cafe@haskell.org
21:16:49 <dons> someoen might know of something we don't.
21:17:36 <Saulzar> Perhaps SDL or Gtk bindings are the closest to that kind of thing
21:19:05 <thetallguy> Closest, but not close enough, I think.
21:19:20 <Saulzar> I was just looking for the SDL bindings, noticed it was under "Audio" only ... could I it also go under Graphics?
21:19:33 <dons> if it sprovides graphics stuff, then yes.
21:19:35 <dons> add an entry
21:19:39 <Saulzar> Righto
21:44:38 <Pegazus> hi, does anyone know where i can get a nice and easy introduction to PCF  and typed and untyped lambda calculus?
21:45:47 <Pegazus> and also fixed point operator or that thing...
21:55:40 <gzl> Pegazus: I don't know about PCF, but Types and Programming Languages (by Pierce) is a good book on untyped and typed lambda calculus.
22:05:25 <Korollary> Pegazus: You could start out with this one: http://www.cs.uiowa.edu/~slonnegr/plf/Book/ as a free introduction.
22:08:43 <Pegazus> thanks
22:09:07 <Pegazus> can anyone tell me a brief 2 line introduction about those topics? :p
22:09:42 <gzl> see wikipedia.
22:10:13 <dons> huh. my naive translation of the pure reverse-complement shootout entry into Data.ByteString runs 4x faster :)
22:10:29 <dons> 4x faster than our fastest entry, I mean
22:10:49 <Korollary> dons: that's not really a surprise is it?
22:11:47 <dons> its nice that writing again in the pure style out performs all the mutable array games we played
22:11:53 <dons> and it goes from 100 loc to 19 :)
22:12:18 <dons> I think this confirms that once Data.ByteString is in ghc 6.6, we'll again lead the shootout, or at least catch Clean.
22:13:09 * dons loves Data.ByteString
22:15:16 <Korollary> That won't help with things like n-body tho
22:16:49 <dons> nope. it helps the 4 DNA benchmarks
22:16:54 <dons> and sum-file
22:18:14 * Korollary wonders how java beats gcc at n-body
22:18:21 <dons> bizarre, i know.
22:18:44 <dons> gcc isn't god of everyone though, I guess :)
22:19:15 <Korollary> well, it loads 12M more and still beats it.
22:21:41 <thetallguy> I see references to multi-dimensional arrays on the wiki
22:22:21 <thetallguy> and an implementation that uses a preprocessor.
22:22:37 <thetallguy> But nothing in the standard libararies per se
22:22:42 <thetallguy> amd I missing something?
22:23:40 <Korollary> I don't think there are md arrays in the hierarchical libs
22:24:01 <thetallguy> Okay, thanks.
22:24:09 <PeterK> is it possible to write a "zip" function for FPS?
22:24:30 <Pegazus> what is FPS?
22:24:32 <dons> how would it work?
22:24:44 <Korollary> @where FPS
22:24:45 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
22:24:46 <dons> you can certainly write a :: ByteString -> ByteString -> [(Char,Char)]
22:24:55 <PeterK> take two FPS, and return a list of [(Char, Char)]
22:25:03 <dons> is it possible, of course.
22:25:11 <dons> its not provided though. do you think it should be?
22:25:17 <dons> ah, for bigrams?
22:25:20 <PeterK> it would help me :)
22:25:25 <dons> if you want it, i'll hack it up now.
22:25:30 * dons hacks
22:25:32 <PeterK> schweet
22:25:47 <dons> (since I want to get most things before this goes into ghc this week)
22:26:08 <Korollary> well, should FPS mimic Data.List?
22:26:36 <dons> it does. I had previously thoguht zip wasn't very useful
22:26:50 <dons> so i didn't implement it. (no other packed string lib does either)
22:27:29 <dons> ok, i'll add zip, zipWith, and unzip
22:30:31 <dons> ok. zip done. easy.
22:33:41 <dons> zipWith done
22:34:01 <PeterK> thanks for that!
22:34:39 <dons> just let me push it into the darcs repo
22:35:38 <dons> hmm. have to think abotu abotu unzip to make it efficient
22:37:28 <dons> note that zip is equivalent to an unpack. 
22:37:33 <dons> and unpacs are good things to avoid
22:45:55 <kep> re all
22:46:01 <Korollary> Hi
22:46:39 <kep> Korollary Hi
22:46:40 <thetallguy> Ach, they are supported.
22:46:53 <dons> PeterK: ok. all done. you can pull zip, zipWith and unzip from www.cse.unsw.edu.au/~dons/code/fps
22:47:09 <thetallguy> Nice turn around time.
22:47:14 <dons> QuickChecked and all. I also love QuickCheck.
22:47:20 <PeterK> dons: amazing! :)
22:47:32 <Korollary> @karma+ dons
22:47:33 <lambdabot> dons's karma raised to 30.
22:47:33 <dons> well, I've spent the last 4 days on this code, so its in my front brain now.
22:47:39 <dons> 30!
22:47:46 <Korollary> the big 3-0 baby.
22:47:54 * dons *blushes*
23:13:07 <Pegazus> any charitable soul willing to help me with a little tutorial of lambda calculus? :p
23:14:52 <sieni> Pegazus: what do you want to know?
23:15:21 <Pegazus> much...
23:15:26 <Pegazus> but i can start with a single question
23:15:34 <Pegazus> \f x. x
23:15:39 <Pegazus> \f x. f x
23:15:42 <Pegazus> \f x. f (f x)
23:15:51 <Pegazus> i failt to understand why the hell that represent the natural numbers
23:15:56 <Pegazus> failt = fail
23:16:06 <Pegazus> (Church numerals)
23:16:37 <sieni> Pegazus: the idea is that the number of f:s is "the number"
23:17:41 <sieni> you basically need a zero and a successor function. then you can define other operations
23:18:26 <Pegazus> yes
23:18:28 <Pegazus> but i mean
23:18:39 <Pegazus> :/ all functions take 1 argument functions
23:18:46 <Pegazus> it's confusing for me!
23:18:59 <Korollary> Pegazus: There are many ways of representing such things. If you find new representations for 0, 1, 2, etc. and a function (succ) that takes a number and produces the next, you too can claim to have encoded them in your own special way.
23:19:01 <Pegazus> like wich is f? is a parameter? a funciton what?
23:19:21 <Pegazus> i know that, in haskell data Nat = Z | Succ Nat
23:19:43 <Pegazus> but O_o here what is the type of f? what if i do f 4 what does it do?
23:20:04 <sieni> Pegazus: in pure lambda calculus there are no other values than lambda expressions
23:20:36 <sieni> Pegazus: it's not important what the church numerals are, but how the operations are defined (like successor and plus)
23:21:16 <adu> sieni, so is 5 a lambda without parameters that returns itself?
23:21:27 <Pegazus> that's what confuses me most
23:21:45 <sieni> adu: ?
23:21:47 <Pegazus> \n f x. f(n f x)
23:21:49 <Pegazus> what is that?
23:21:50 <Pegazus> O_o
23:21:57 <Pegazus> (it's supposed to be SUCC)
23:22:03 <sieni> Pegazus: successor yes
23:22:07 <sieni> well, look:
23:23:09 <adu> if the successor function is 'additive' what would be the 'multiplicative' succoessor-ish function?
23:23:39 <sieni> (\n f x. f (n f x)) (\f x. x) = (\f x. f((\f x. x)f x)) = \f x. f x
23:23:57 <Pegazus> <adu> it's "add c" for a constant...
23:24:06 <Pegazus> (for each multiplication a different constant)
23:24:08 <sieni> (\n f x. f (n f x)) (\f x. f x) = (\f x. f((\f x. f x)f x)) = \f x. f (f x)
23:24:28 <adu> Pegazus: "add c" is still additive
23:25:00 <Pegazus> mul 3 4 = add 4(add 4(add 4(0)))
23:25:27 <adu> ah the hyper-op definition, yes
23:25:27 <Pegazus> what does this function repressent in addition to the "Zero" (\f x. x) ?
23:25:35 <Pegazus> i mean if you "evaluate" it what function it represents?
23:25:53 <adu> identity?
23:25:56 <Korollary> no
23:26:22 <Pegazus> sieni: if i evaluate things in any order in lambda calculus it gives you the same result right?
23:26:23 <sieni> Pegazus: it drops the first argument and returns the second
23:26:26 <Korollary> it takes two arguments and returns the second.
23:26:34 <Pegazus> k
23:26:45 <Pegazus> Projection2,1
23:27:50 <sieni> Pegazus: the church numerals take two arguments, a function of one parameter and a thing and it applies the function to the thing n times.
23:27:58 <Pegazus> k
23:28:21 <Pegazus> is there any other "easier" or "clearer" representation of natural numbers in lambda calculus?
23:28:55 <Pegazus> (\n f x. f (n f x)) why does the function successor takes 3 arguments? i mean why \n f x ?
23:29:12 <skew> the only interesting argument is the first
23:29:13 <sieni> Pegazus: about evaluation order: I think that you get the same result provided that the evaluation terminates in each evaluation strategy
23:29:21 <Korollary> Not that I know of (in pure LC). LC is not meant to be convenient.
23:29:22 <Pegazus> k
23:29:42 <Pegazus> and what is the meaning of the . in lambda calculus?
23:29:45 <skew> types might help here - a number is something like (a -> a) -> a -> a
23:29:50 <sieni> Pegazus: well it is supposed to return a church numeral
23:30:01 <Pegazus> mm so?
23:30:04 <Korollary> It's just syntax to separate the abstraction from the bound variables.
23:30:22 <sieni> Pegazus: it takes a church numeral in (the first argument) and the two latter arguments are the arguments to the returned church numeral
23:30:22 <skew> you can say succ :: ((a -> a) -> a -> a) -> (a -> a) -> a -> a if you want to think of it as three arguments
23:30:38 <Pegazus> mmm ok
23:30:52 <Pegazus> does that kind of things works on haskell "lambda functions"?
23:31:00 <skew> or ((a -> a) -> a -> a) -> ((a -> a) -> a -> a) = Nat -> Nat if you want to think of adding stuff
23:31:29 <Pegazus> :/
23:42:09 <Korollary> eh, something's wrong on the n-body shootout
23:42:16 <Korollary> http://shootout.alioth.debian.org/gp4/benchmark.php?test=nbody&lang=gcc&id=0
23:42:17 <Korollary> and
23:42:21 <Korollary> http://shootout.alioth.debian.org/gp4/iofile.php?test=nbody&lang=all&file=output
23:42:59 <Korollary> The outputs don't match and it doesn't take 4s for N=1000.
23:45:03 <Korollary> err
23:45:04 <Korollary> my bad
23:45:35 <Korollary> n=1000 for test, n=5M for the real run.
23:45:50 * Korollary is obviously sharp enough for this.
23:45:50 <dons> its ok?
23:45:59 <Korollary> yeah
23:49:15 <dons> PeterK: how's the bigram code going, btw? you still hacking away at it?
23:49:34 <PeterK> not at this moment, but it works ok. i haven't used your new FPS.
23:49:46 <dons> ok. 
23:49:55 <dons> it handles your 1M files now?
23:50:29 <PeterK> with the improvement suggested by chrom, it improved a bit, and with the new zip, it will get a little bit faster (one unpack instead of two)
23:50:50 <dons> right. good. it's a n interesting problem
23:50:57 <dons> (to optimise)
23:51:12 <Korollary> what is it about?
23:51:32 <PeterK> the subproblem is finding the frequency of two-letter combinations in a given text file
23:51:32 <dons> bigrams. pairs (Char,Char).
23:51:49 <dons> which is an awkward representation when using large data quantitites
23:51:57 <dons> since you have to box all the data
23:52:16 <dons> so finding efficient ways to deal wthi this had us scratching our heads for a while.
23:53:29 <Korollary> I'm thinking very imperative.
23:53:54 <dons> I think its good now with a UArray (Char,Char) Int
23:54:06 <Pegazus> is haskell a lambda calculus language?
23:54:14 <dons> so the pairs of chars get used as keys, and can stay boxed, into a mutable array
23:54:17 <Pegazus> (i mean is there any way of viewing data types as functions in haskell?)
23:54:23 <dons> (actually, I'm not sure it uses a mutable array yet.)
23:54:24 <Korollary> Pegazus: It's based on LC.
23:54:38 <Pegazus> can you use data types as lamba functions?
23:54:42 <Pegazus> that's my question :p
23:54:48 <sieni> Pegazus: I don't think so
23:54:49 <dons> one other idea  I have is to use bit twiddles to pack the Char,Char into a single Int key. avoiding a true unpack
23:54:52 <Pegazus> hehe
23:54:53 <Pegazus> thanks
23:55:03 <Pegazus> if you were able, i'd think haskell is totally insane xd
23:55:07 <dons> but that makes other parts of the code harder.
23:58:09 <Cale> Pegazus: sort of. You can represent an algebraic data type using functions of a certain type -- essentially it will take replacements for the constructors of the type, and return the result of replacing them recursively throughout the structure.
23:58:20 <Cale> For example, with the list type, this is foldr
23:58:32 <Cale> With Either, it's either, and with Maybe, it's maybe
23:58:49 <Cale> with (,) (the pair type), it's uncurry
