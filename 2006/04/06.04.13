00:07:03 <Pseudonym> "Awfully slow" means that it takes less time to compute the factorial of 1000 than to print the answer.
00:07:16 <neologism> uh
00:08:41 <neologism> that definitely should be fixed
00:08:48 <juhp> dcoutts_: just saw the gtk2hs blog entry about your seminar in Nottingham... is the gui hIDE still in active development? :)
00:08:55 <dons> yep.
00:09:00 <dons> Lemmih's hackign away on it
00:09:08 <neologism> nice
00:09:15 <dons> he talks about it on planet.haskell.org
00:09:16 <juhp> ah good - I haven't tried in ages... :)
00:11:37 <neologism> I didnt know planet.h.org
00:11:56 <dons> neologism: you should read the weekly news ;)
00:12:03 <neologism> I shuold
00:12:11 <Pseudonym> Which is conveniently posted on planet haskell.
00:12:11 <dons> also, its on haskell.org under 'Community' now too
00:12:14 <dons> hehe
00:12:19 <dons> we like recursion
00:12:24 <Pseudonym> :-)
00:12:38 <Pseudonym> Seriously, putting p.h in your RSS feed, assuming you have one, is a good idea.
00:12:45 <RyanT5000> does hoogle seriously not index Data.*?
00:12:56 <dons> ?hoogle intersperse
00:12:58 <lambdabot> List.intersperse :: a -> [a] -> [a]
00:13:01 <neologism> I cannot find there the discussion about number being slow
00:13:04 <RyanT5000> or does it not return hits for just namespaces
00:13:05 <dons> hmm. inneresting
00:13:16 <dons> namespaces? no.
00:13:17 <RyanT5000> i get Data.Generics.Basics.Data
00:13:20 <RyanT5000> but i don't get just Data
00:13:24 <dons> ?lambdabot everywhere
00:13:25 <lambdabot> Unknown command, try @list
00:13:28 <dons> ?hoogle everywhere
00:13:29 <lambdabot> Data.Generics.Schemes.everywhere :: (a -> a) -> a -> a
00:13:29 <lambdabot> Data.Generics.Schemes.everywhere' :: (a -> a) -> a -> a
00:13:29 <lambdabot> Data.Generics.Schemes.everywhereBut :: GenericQ Bool -> GenericT -> GenericT
00:13:33 <dons> yeah. there you go.
00:13:38 <dons> you can't search on module names
00:13:42 <RyanT5000> ah
00:13:43 <RyanT5000> why not?
00:13:44 <dons> what would you want it to return?
00:13:51 <dons> (maybe its a good idea)
00:13:52 <RyanT5000> modules :
00:13:53 <RyanT5000> :)
00:13:58 <RyanT5000> i want to be able to type GLUT
00:14:00 <dons> all modules under a name?
00:14:08 <RyanT5000> sure, or just the root one
00:14:13 <RyanT5000> i use search engines like bookmarks
00:14:18 <dons> ?wiki Hoogle
00:14:19 <lambdabot> http://www.haskell.org/haskellwiki/Hoogle
00:14:22 <dons> add your suggestion there
00:14:29 <dons> ndm will pick it up probably. it sounds like a good idea
00:14:30 <RyanT5000> alright
00:14:47 <dons> basically, any thing that you 'think' should work in hoogle, should
00:14:59 <dons> ?hoogle lambdabot
00:15:01 <RyanT5000> just like google ;)
00:15:01 <lambdabot> No matches found
00:15:17 <dons> ah, well, not lambdabot's hoogle. but the real hoogle, it knows where projects live, for example
00:15:31 <RyanT5000> ah, that's cool
00:15:32 <dons> i think ndm just goes through the query logs, looking for patterns
00:18:10 <Pseudonym> Just like google.
00:18:18 <Pseudonym> Except at google, it's not ndm doing it.
00:19:01 <RyanT5000> maybe it is
00:19:03 <RyanT5000> maybe he's sneaky like that
00:19:31 <dons> just like i go through the logs looking for lambdabot mistake patterns, too.  but there's less of those.
00:19:52 <dons> fixing @type to have more stuff imported by default was one thing. as was the spell correction
00:20:20 <dons> if anyone has suggestions on making lambdabot smarter, feel free to bug me
00:21:06 <RyanT5000> <-- wiki newb
00:21:14 <Pseudonym> Make lambdabot sentient.
00:21:31 <lambdabot> Yeah. I'm bored in here.
00:21:35 <RyanT5000> is adding one bullet under "suggest" a "minor edit"?
00:21:50 <RyanT5000> or would that just be capitalization/spelling/etc.
00:22:27 <dons> a megamonad port would be good. so forall nick . @<nick> worked.
00:22:31 <dons> RyanT5000:  new content is not minor
00:22:36 <dons> only formatting and typos
00:22:39 <RyanT5000> k
00:24:28 <RyanT5000> dons: is there a datastructure like a Map combined with a pool of unique keys?
00:24:36 <RyanT5000> that *isn't* monad-based like Unique
00:25:08 <RyanT5000> basically i guess i want a heap
00:25:09 <dons> hmm, you want unique keys for elems in the Map? like a umm.. hashtable?
00:25:26 <RyanT5000> no, that's the wrong direction of abstraction
00:25:35 <RyanT5000> i basically want to be able to malloc and free entries in my table
00:25:48 <RyanT5000> without worrying about what the pointers i'm being returned are
00:25:54 <dons> hmm. you could write such a structure.
00:25:55 <RyanT5000> except instead of memory blocks it's unique id's
00:26:18 <dons> a Ptr is a unique id, no ?
00:26:36 <dons> ah, they even have Eq and Ord
00:26:40 <RyanT5000> i don't think i'm being clear
00:26:45 <RyanT5000> basically i want a Map
00:26:50 <RyanT5000> only i don't care about the ID's
00:27:10 <RyanT5000> i just want to be able to say "add this thing to the map using an unused ID, and give me the ID back"
00:27:57 <dons> ok. so like an array, perhaps, where you keep track of the last element. (an array that grows?)
00:28:16 <dons> adding an element adds it to the end of the array, with key 'n'. the next elem gets key n+1
00:28:20 <dons> how's that?
00:28:27 <RyanT5000> yeah, pretty much, although i do want to be able to deallocate things too
00:28:45 <dons> can you let the storage manager take care of that?
00:28:58 <dons> otherwise, you have to do ti in Foreign.* ptrs
00:29:11 <RyanT5000> hm, probably
00:29:16 <RyanT5000> basically what i have is objects in a Game
00:29:17 <RyanT5000> er
00:29:18 <RyanT5000> game
00:29:19 <RyanT5000> :P
00:29:34 <RyanT5000> so i need to be able to say "Add this ship to the game"
00:29:36 <dons> no, a Game!
00:29:55 <dons> ok. how many ships willt  there be?
00:30:03 <RyanT5000> a few thousand?
00:30:05 <RyanT5000> at most
00:30:10 <dons> because maybe a list would be ok.
00:30:39 <RyanT5000> hm
00:30:42 <RyanT5000> maybe
00:31:04 <dons> and i'd suggest letting the storage manager handle the deallocs until you find its not keeping up (which i've never noticed)
00:31:20 <RyanT5000> i'm not talking about dealloc in that sense
00:31:32 <RyanT5000> it's not a memory thing
00:31:38 <dons> ok hmm (confused)
00:31:40 <dons> you mean, removing?
00:31:40 <RyanT5000> when a ship is deleted from the gameboard
00:31:54 <RyanT5000> it needs to be removed from other places; that's all i meant about that
00:31:57 <dons> and what kind of operations do you need?
00:32:05 <dons> insertion, deletion, lokoup?
00:32:33 <RyanT5000> yah, i guess so - which is Map
00:32:56 <dons> would not a (Map Int Ship , Int) work? where you store the next number to use?
00:33:10 <dons> which is an (IntMap Ship, Int)
00:33:12 <RyanT5000> yeah, i guess it would
00:33:31 <dons> so insert grabs the n, inserts it, getting back a new map, and succ n.
00:33:39 <RyanT5000> right
00:33:46 <dons> the lookup is log n, and delete too. sounds fine.
00:33:58 <RyanT5000> yeah
00:34:04 <dons> a 5 line wrapper over IntMap, in fact :)
00:34:05 <roconnor> why do you need anything at all?
00:34:17 <RyanT5000> yeah, i'm used to thinking the OOP way
00:34:22 <RyanT5000> where that would be a big production
00:34:24 <dons> yeah, maybe Ships already have Ord ?
00:34:24 <RyanT5000> :-/
00:34:31 <dons> then no keys needed
00:34:34 <roconnor> just have other objects reference the ship?
00:34:58 <roconnor> no more references to the ship means no more ship
00:34:59 <RyanT5000> no, they need IDs because that's how the player assigns them commands
00:35:16 <RyanT5000> and the player does not interact directly with the server
00:35:43 <RyanT5000> so they need to be able to generate a commandfile which is essentially a Map ShipID Command
00:37:26 <RyanT5000> here's a question that actually makes me wonder why i'm having a hard time with it
00:37:41 <RyanT5000> actually, nevermind
00:37:50 <RyanT5000> i'll see if it still applies once i write the functional datastructure
00:38:02 <RyanT5000> it might magically go away in the transition from OOP to haskell
00:38:41 <dons> yep, jsut write your data Board = Board ... with the things you need in it. and then some functions to modify the elements.
00:38:53 <dons> should be fairly easy, if you have a good idea of the structures you need
00:39:01 <RyanT5000> yeah
00:39:17 <RyanT5000> there are some issues with efficiency
00:39:27 <RyanT5000> for instance, you have to have bidirectional maps of certain things
00:39:44 <RyanT5000> like ShipID->Location as well as Location->[ShipID]
00:39:52 <dons> well.. we'll see once you write it. there's always Graphs. and any other tricksy structure you want.
00:40:18 <RyanT5000> is there a canned way of doing that in haskell?
00:41:06 <RyanT5000> (the id->location, location->[id] thing)
00:41:13 <RyanT5000> it looks, to me, like a relational database
00:42:15 <dons> hmm. two Maps would be fine. maybe there's some smarter way, if you treat the board as an array with Int keys for Locations.
00:42:24 <dons> play around a bit
00:42:28 <dons> try thingsout
00:42:30 <RyanT5000> hm, how weird is it to be using existential datatypes like first thing?
00:42:44 <RyanT5000> class Model m ...
00:42:48 <RyanT5000> instance Model Ship
00:43:09 <RyanT5000> Cell stores an existential list of Models
00:43:21 <dons> do you have more than one kind of Model?
00:43:24 <RyanT5000> yeah
00:43:26 <RyanT5000> planets, for instance
00:43:40 <RyanT5000> in C# it's an inheritance hierarchy
00:43:43 <dons> shrug. that's one way. a normal data type would do too.
00:43:49 <dons> and need less type hacking
00:44:05 <dons> data CellElem = S Ship | P Planet ...
00:44:11 <RyanT5000> ah
00:44:12 <dons> type Cell = [CellElem]
00:44:38 <dons> rather than data Cell = forall a . Model a => Cell a
00:44:41 <dons> or whatever you've got
00:44:54 <RyanT5000> lol i have an empty editor right now :P
00:45:05 <dons> get hackign then!
00:45:10 <dons> less talk, more code
00:45:15 <RyanT5000> gp :)
00:45:41 <RyanT5000> (but i have the whole structure written in C# already; that's why i'm able to discuss it semi-intelligently)
00:45:53 <newsham> there is nothing more promising than an empty editor.
00:47:20 <ulfdoz> Here is something for your editor: http://www.theregister.co.uk/2001/09/11/worlds_first_decss_executable_prime/
00:47:27 <ulfdoz> Now, write the build system. :)
00:50:23 <dons> how do you turn random code into a prime? what's the encoding?
00:50:30 <dons> do you number the lambdas?
00:50:34 <dons> with each prime
00:50:53 <dons> (after you've got a lambda calculus version of the code)
00:51:22 <RyanT5000> you know what would be impressive, is if they made a prime that, when encoded into a base-256 string was machine-code for DeCSS on some platform
00:51:28 <RyanT5000> bonus points if the platform is i386
00:51:42 <RyanT5000> not to say that the current thing isn't impressive
00:51:59 <RyanT5000> and in fact i don't know if that isn't what they've done
00:52:07 <ulfdoz> the encoding is binary, gzip makes the code in ascii.
00:52:07 <Korollary> I think it's exactly that
00:52:28 <RyanT5000> awesome :)
00:52:43 <RyanT5000> oooh i see
00:52:45 <dons> oh, does it jsut happen to be a prime?
00:52:50 <RyanT5000> they made a gzip of what they wanted
00:52:54 <RyanT5000> then they fiddled with the end bits
00:52:59 <RyanT5000> until it was prime 
00:53:06 <dons> yeah.
00:53:13 <Korollary> I dont understand why it needed to be a prime, either
00:53:17 <RyanT5000> probably a non-code section
00:53:20 <ulfdoz> RyanT5000: C is almost machine code on any platform. ;)
00:53:23 <dons> not as nice as numbering lambdas with primes, I reckon
00:53:47 <dons> or debruijn indicides that when concatenated give you a prime
00:53:48 <RyanT5000> yah
00:54:11 <Korollary> @karma indicides
00:54:11 <lambdabot> indicides has a karma of 0
00:54:27 <dons> hehe
00:54:49 <RyanT5000> what are the rules for karma?
00:54:54 <RyanT5000> does it have to be a real user?
00:55:03 <dons> indicide is what happens if you play with too many de bruijn indicies. its usually fatal
00:55:12 <RyanT5000> lol
00:55:13 <dons> RyanT5000: no checks are made
00:55:13 <Korollary> no, it just needs to be not you.
00:55:18 <dons> right
00:55:20 <dons> 1 check is made
00:55:27 <dons> :}
00:55:31 <RyanT5000> so i could say @karma -RIAA?
00:55:38 <RyanT5000> you know, if they sued someone ;)
00:55:52 <Korollary> @karma+ karma-
00:55:53 <lambdabot> karma-'s karma raised to 1.
00:56:06 <RyanT5000> i know the module doesn't have rules
00:56:17 <RyanT5000> i was wondering what the "unwritten" rules were
00:56:24 <Korollary> dons: are you playing with debruijn indices really?
00:56:44 <dons> well, at one point in my life. and maybe again some day
00:56:46 <newsham> http://lava.net/~newsham/x/machine/debruijn.py
00:57:14 <Korollary> for some reason, I didn't find debruijn indices interesting.
00:57:25 <ulfdoz> RyanT5000: To see if they fiddled with the end bits, just compress it again.
00:57:46 <RyanT5000> well they could've fiddled with the end-bits of the program before compression
00:57:51 <RyanT5000> that's what i meant
00:58:25 <RyanT5000> i forget the formula for the sparseness of the primes is
00:59:31 <ulfdoz> A weird theory I heard somewhere: Assuming, that pi contains any sequence of numbers of any length, a compression method could work by giving start and endpoint of the data encoding sequence.
00:59:34 <RyanT5000> they just need to come up with about as many different pre-compression sources as there is distance between primes in that area
00:59:54 <newsham> ulfdoz: who said it would be compression?
00:59:55 <RyanT5000> ulfdoz: yeah but that'd be really inefficient
01:00:10 <RyanT5000> it might be equivalent to encrypting something and then compressing it
01:00:17 <RyanT5000> except with a really, really good encryption algorithm
01:00:19 <newsham> pideon hole - you can only encode 2^n unique messages in n bits.
01:00:21 <RyanT5000> OTP, in fact
01:00:22 <ulfdoz> newsham: If data is large enough, it is compression. ;)
01:00:39 <newsham> ulfdoz: not necessarily.  the starting position in PI could be even larger
01:00:45 <dons> yeah, all the cool code i've ever written is available in pi, its up to YOU to find it.
01:00:52 <dons> the next version of ghc is in there somewhere
01:01:08 <RyanT5000> 3.1415926535
01:01:15 <RyanT5000> what if i want to encode a '7'?
01:01:20 <RyanT5000> i have to write something over 10
01:01:27 <newsham> all my programs are in the trailing binary digits between two reals
01:01:32 <Korollary> it may take too many bits to specify between which digits the source file is.
01:01:42 <ulfdoz> newsham: That is meant to be "data is not large enough". But the thing, is you don't transmit the n bits, as you know, how to generate them.
01:01:49 <RyanT5000> has it been proven that pi contains all possible series of digits?
01:02:03 <RyanT5000> just because it never repeats itself does not imply that
01:02:09 <dons> reminds me of the story about the infinite library, where all knowledge is contained, its just a matter of finding it
01:02:10 <ulfdoz> Where are my nails?
01:02:14 <newsham> ryan: oh?
01:02:33 <RyanT5000> yah, what if i take pi and remove all the zeroes
01:02:43 <RyanT5000> it's still just as non-repeating
01:02:51 <newsham> true
01:02:53 <dons> the Borges story, what was it? La biblioteca de Babel?
01:02:57 <ulfdoz> RyanT5000: No, but the opposite isn't proven, too.
01:03:05 <RyanT5000> alright
01:03:59 * int-e wonders if it's possible to prove that this new number - pi without zeros - is irrational.
01:04:10 <ulfdoz> RyanT5000: So, living with assumptions. Security of RSA isn't proven, too.
01:04:25 <RyanT5000> it isn't?
01:04:29 <RyanT5000> oh right
01:04:32 <int-e> It most likely is
01:04:38 <RyanT5000> based on the factoring problem
01:04:41 <Korollary> you dont prove security.
01:04:41 <newsham> its nto proven to be equivalent to factoring.
01:04:47 <newsham> although matrix RSA is
01:04:53 <RyanT5000> ah
01:05:08 <ulfdoz> nope, as far as I know only OTPs are proven for encrypting data.
01:05:27 <newsham> "proven for encrypting data"?
01:05:31 <Pseudonym> Solving discrete log would also defeat RSA.
01:05:32 <RyanT5000> well there's a difference between proving that you're secure and proving how secure you are
01:05:40 <Pseudonym> But I believe that's believed to be harder than factoring.
01:05:47 <ulfdoz> newsham: You can't decrypting in another way as brute forcing the key.
01:06:01 <ulfdoz> or guessing of course.
01:06:03 <RyanT5000> you can't decrypt OTP
01:06:05 <RyanT5000> period
01:06:09 <RyanT5000> er
01:06:11 <RyanT5000> crack
01:06:14 <RyanT5000> obviously if you have the key...
01:06:25 <RyanT5000> it's 100% secure
01:06:57 <audreyt> ...(not against rubberhose attacks, though)
01:07:21 <newsham> it is secure against rubberhose attacks.  because it provides plausible deniability.
01:07:38 <newsham> every plaintext is plausible for a given ciphertext.
01:07:58 <RyanT5000> yeah, only the length is known, and you can buffer with a random amount of noise
01:08:38 <ulfdoz> I remember the panic as someone found a algorithm to find colisions in md5-hashes in 2^40 iterations.
01:08:41 <audreyt> but you need to produce a pad that decrypts the same ciphertext into a plausible aspect of plaintext
01:09:16 <ulfdoz> audreyt: You need to no the pad to get the correct plaintext.
01:09:30 <audreyt> (though indeed you can pad things with "noise" that provides the said aspect)
01:09:45 <RyanT5000> anyone use TrueCrypt?
01:10:12 <RyanT5000> it has a mode where you make a file system, put some data into
01:10:13 <RyanT5000> *it
01:10:21 <RyanT5000> then you make a new file system in the same volume
01:10:28 <RyanT5000> which fills the remaining space
01:10:41 <RyanT5000> both are accessible, with different keys
01:10:54 <RyanT5000> it first tries to mount the original file system
01:11:01 <RyanT5000> if that fails, it tries the second location
01:11:24 <RyanT5000> which is a semi-decent plausible-deniability scheme, imo
01:12:38 <audreyt> now that you mention it, the "Rubberhose" filesystem does something like that too, iirc
01:12:50 <RyanT5000> yeah, i just now read the slide that said that :P
01:12:52 <RyanT5000> only they do it like
01:12:55 <RyanT5000> a billion times smarter
01:13:30 <ulfdoz> has someone already written a small script to determine a minimum set of equivalent functional dependencies from given set of of fds (database design)?
01:14:59 <araujo> Hi!
01:18:21 <kolmodin> morning araujo!
01:18:31 <kolmodin> you're up early today
01:18:35 <araujo> kolmodin, wo wo!
01:18:54 <araujo> kolmodin, well, i actually have not gone to bed yet :-)
01:19:30 <kolmodin> oh :)
01:19:36 <RyanT5000> is there a class that corresponds to Data.Map.Map?
01:20:15 <RyanT5000> my Board datastructure should implement Map (Int, Int) Cell if it exists
01:21:51 <kolmodin> @localtime audreyt 
01:21:59 <kolmodin> @localtime araujo 
01:22:02 <kolmodin> :)
01:22:54 <kolmodin> brb
01:22:58 <RyanT5000> @localtime RyanT5000
01:23:05 <RyanT5000> does that do anything?
01:23:37 <RyanT5000> @help
01:23:37 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
01:23:43 <kolmodin> it should say the local time of the given user
01:23:47 <RyanT5000> ah
01:24:04 <kolmodin> but it doesn't, is lambdabot online?
01:24:11 <kolmodin> hmm, yeah
01:24:19 <shapr> @localtime shapr
01:24:21 <lambdabot> Local time for shapr is Thu Apr 13 10:23:59 2006
01:24:38 <shapr> It uses CTCP TIME
01:24:40 <kolmodin> @localtime kolmodin
01:24:57 <shapr> If you're blocking CTCP requests, it won't work.
01:24:58 <RyanT5000> anyone: is there a class that represents the interface of Map?
01:26:05 <kosmikus> @seen dons
01:26:06 <lambdabot> dons is in #haskell. I last heard dons speak 23 minutes and 12 seconds ago.
01:26:18 <RyanT5000> or is there something wrong with my OOP instincts' opinion that, since my Board acts exactly like a Map from (Int, Int) to Cell, it should be declared as such
01:26:43 <Korollary> RyanT5000: There are no interfaces in Haskell
01:27:10 <RyanT5000> aren't classes sort of used the same way?
01:27:43 <Korollary> No
01:28:01 <sieni> Yes
01:28:10 <Korollary> eh?
01:28:13 <sieni> :-)
01:28:27 * Korollary pours beer on sieni
01:28:32 <RyanT5000> well what about Show?
01:28:39 <RyanT5000> Read
01:28:41 <RyanT5000> Eq
01:28:46 <RyanT5000> those all look like interfaces to me
01:29:06 <RyanT5000> i'm not saying it's identical
01:29:56 <sieni> RyanT5000: Yes, Haskell type classes have similar uses as C++ abstract classes, C++ templates or Java interfaces
01:30:08 <RyanT5000> right
01:30:20 <RyanT5000> but i take it there's no class Map m key data
01:30:20 <Korollary> RyanT5000: It's parametric polymorphism versus subtyping polymorphism.
01:30:36 <sieni> see e.g. http://www.haskell.org/tutorial/classes.html
01:30:44 <RyanT5000> yeah, well subtyping is overrated anyway :P
01:35:08 <sethk> dons, if you are still around ...
01:35:27 <sethk> dons, waitForProcess works, although it has a problem with "interrupted (Interrupted system call"
01:35:32 <sethk> dons, but I can probably code around that
01:35:35 <sethk> dons, but...
01:35:50 <sethk> dons, getProcessExitCode isn't working at all, with the same handle that works with waitForProcess
01:36:03 <sethk> dons, it always returns saying ExitSuccess.
01:36:14 <sethk> dons, could the doc be backwards, I wonder?
01:36:23 <sethk> dons, maybe you have to call it until it returns Nothing?
01:36:25 <Korollary> sethk: I remember running into issues with those as well
01:36:35 <sethk> Korollary, did you work around it?
01:37:15 <sethk> Korollary, I cal work around the interrupted problem, I think, just by handling that exception and calling waitForProcess again
01:37:30 <Korollary> sethk: Yes I had to. I also remember that even though I passed in Nothing for the child's stdout, it still had the parent's.
01:37:34 <sethk> Korollary, but my logic is expecting the getProcessExitCode to work, so it's more work to use waitForProcess.
01:37:43 <sethk> Korollary, hmm, that's a problem also.
01:38:02 <sethk> Korollary, maybe time to use FFI?
01:38:09 <sethk> or try System.Posix.Process
01:38:13 <sethk> and check out dons wrappers
01:38:24 <RyanT5000> well, i'm off
01:38:29 <RyanT5000> @localtime RyanT5000
01:38:39 <Korollary> sethk: Probably. You should submit bug reports as well.
01:38:46 <sethk> Korollary, yes
01:38:49 <RyanT5000> wtf
01:38:50 <RyanT5000> anyway it's late
01:38:57 <Korollary> ?localtime RyanT5000 
01:38:59 <sethk> Korollary, as long as it isn't my code causing the problems  :)
01:39:04 <Korollary> bot's on strike
01:39:19 <Korollary> lambdabot: ?localtime RyanT5000 
01:39:34 <Korollary> We're through, lambdabot.
01:39:35 <sethk> Korollary, System.Posix.Process looks promising, if the functions work as documented
01:39:38 <int-e> > 1+1
01:39:39 <lambdabot> 2
01:39:58 <Korollary> lambdabot: oh I am so sorry. Please take me back!
01:40:01 <int-e> Korollary: if he gets no reply to his time request, what's he supposed to do?
01:40:18 <Korollary> int-e: apologize.
01:47:21 <dons> I think the interrupted exception happens if the process has already exited
01:47:22 <sethk> dons, if you are here, firefox has it's browser history broken and I only bookmarked one of your wrapper classes.  I have the lower level one; can you tell me the URL for the other one?
01:47:27 <dons> and its fixed in ghc cvs?
01:47:36 <sethk> dons, I can try the CVS
01:47:38 <dons> le me find them
01:47:43 <sethk> dons, but what about the other problem
01:47:55 <sethk> dons, because I only tried waitForProcess to make sure I had a good handle
01:48:15 <dons> high level: http://www.cse.unsw.edu.au/~dons/code/lambdabot/Lib/Process.hs
01:48:18 <sethk> dons, the interrupted exception is happening, actually, when I kill the process from another thread, which is not unreasonable
01:48:27 <sethk> thanks, I'll bookmark that one also
01:48:49 <sethk> dons, any idea why getProcessExitCode seems to be totally broken?
01:49:02 <sethk> dons, I haven't used the cvs version, is it stable?
01:49:02 <dons> hmm. no.
01:49:10 <dons> no not terrible stable.
01:49:23 <dons> this Process stuff is very new, so it still is a bit wobbly
01:49:36 <dons> the alternative is to use hslibs, and -package unix
01:49:36 <dons> le me see
01:49:41 <sethk> dons, I'd better stay away from the cvs version.  remember this code is being deployed.
01:49:49 <sethk> dons, I can try hslibs
01:49:59 <dons> or this, http://www.cse.unsw.edu.au/~dons/code/hmp3/Utils.hs
01:49:59 <sethk> dons, and it wouldn't be terribly hard to do with FFI, I don't think.
01:50:02 <dons> yeah, i think stay away from cvs too
01:50:25 <dons> right. i've wrtten 2 or 3 'popen-ish'  functions in my time. not too hard, even withotu the ffi
01:50:28 <sethk> dons, ok, I've got all three of those bookmarked now.
01:51:00 <sethk> dons, I don't need anything complicated, really, just "is it still running", "kill it" and, nice to have, "how did it exit?"
01:51:49 <sethk> dons, this thing is almost ready to deploy, the kill process is the last piece I was waiting for.
01:52:09 <sethk> dons, I can code around it, I guess, but I've not resorted to anything totally ugly thus far and I'd rather keep it clean  :)
01:52:09 <dons> oh, there's also System.Posix.Process   
01:52:11 <dons> in -package unix
01:52:18 <dons> that gives you most of the posix interface
01:52:40 <sethk> dons, I download that as a separate tarball?
01:52:47 <dons> nope
01:53:05 <dons> its in the unix package by default that comes with the system
01:53:22 <dons> it provides forkProcess and lots more
01:54:00 <sethk> dons, right, I have it, System.Posix.Process.  I didn't realize that's what we are talking about  :)
01:54:15 <sethk> dons, it's got fork/exec, which I could use
01:54:16 <dons> what about System.Process?
01:54:24 <sethk> that's what isn't working
01:54:29 <dons> ok. so that's the 4 options. System.Process, which is new.
01:54:33 <sethk> well, waitForProcess is working
01:54:40 <sethk> but getProcessExitCode is not
01:54:41 <dons> System.Posix.Process which is stable, and lower level
01:54:46 <dons> and then the two wrappers i wrote
01:55:19 <sethk> dons, if your wrapper uses System.Process, and System.Process is broken ... I think your high level at least used System.Process?
01:55:49 <sethk> popen from your Utils.hs would take care of it, I think
01:55:55 <sethk> assuming the bug didn't break your code
01:56:00 <dons> yep. and i've not noticed any issues. none recently anyway.
01:56:48 <sethk> ok, I'll play with them.  I'll have to play with my code a bit but it shouldn't take too long.
01:59:16 <dons> ok. i'm going to be offline for the next 3 days. vacation!
02:01:01 <sethk> dons, where do I find out the meaning of the arguments in System.Posix.Process?  executeFile, for example?
02:01:11 <sethk> dons, do I go to the source?
02:04:42 <sethk> dons, I guess if all else fails, read the library source code.  :)
02:05:47 <ValarQ> dons: were there any known problem with hs-plugins on amd64?
02:08:05 <jip> good morning haskell
02:08:51 <ValarQ> mornin jip
02:12:28 <jip> @seen Phillipa
02:12:29 <lambdabot> I haven't seen Phillipa.
02:12:42 <jip> @seen Philippa
02:12:43 <lambdabot> I saw Philippa leaving #scannedinavian, #haskell-overflow, #haskell-blah and #haskell 21 minutes and 56 seconds ago, and .
02:12:48 <jip> @seen Philippa_
02:12:49 <lambdabot> I saw Philippa_ leaving #scannedinavian, #haskell-overflow, #haskell-blah and #haskell 19 hours, 18 minutes and 31 seconds ago, and .
02:12:52 <jip> nein :(
02:13:04 <dons> ValarQ: not that I know of. try it. run the testsuite.
02:13:17 <jip> hello dons 
02:14:16 <xerox> Cale, ping
02:16:27 <ValarQ> dons: i'm asking because i was getting some magic interface error when using plugs
02:23:55 <Itkovian> is there a way to pass along the record label function to another function, e.g. to be able to do f recordf x y = x { recordf = y } ?
02:24:20 <vincenz> Itkovian: a record label is just a function, but only for getting data out, not data in
02:25:01 <Itkovian> So it cannot be done?
02:25:09 <vincenz> I doubt it
02:25:12 <Itkovian> crap
02:25:15 <vincenz> test and see?
02:25:26 <Itkovian> I don't know what else to try
02:26:17 <ValarQ> dons: i keep getting "Bad interface file" in one of the tests, hard to tell which thought
02:26:24 <xerox> Yes, you can't, Itkovian.
02:29:05 <jip> how do you make a list of length l whose elements are all n?
02:29:53 <xerox> [n]
02:30:05 <xerox> Which is the same as n:[].
02:30:30 <Itkovian> xerox: that would be length 1, not l
02:30:42 <xerox> Sorry?
02:30:55 <Itkovian> l as in el
02:30:58 <xerox> Ah, those char compare in the same way...
02:31:03 <Itkovian> lol
02:31:04 <xerox> ?type replicate
02:31:05 <lambdabot> forall a. Int -> a -> [a]
02:31:11 <xerox> There you go.
02:31:18 <jip> > replicate 19 0x00
02:31:21 <lambdabot> [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
02:31:23 <jip> danke sehr
02:31:28 <xerox> You're welcome.
02:35:17 <boegel> @type foldl
02:35:18 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
02:36:25 <boegel> @hoogle (a->b) -> [a] -> b
02:36:27 <lambdabot> Prelude.foldr :: (a -> b -> b) -> b -> [a] -> b
02:36:27 <lambdabot> Prelude.foldl :: (a -> b -> a) -> a -> [b] -> a
02:36:27 <lambdabot> Data.List.foldl' :: (a -> b -> a) -> a -> [b] -> a
02:36:34 <boegel> @hoogle (a->b) -> [a] -> [b]
02:36:36 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
02:36:36 <lambdabot> Control.Parallel.Strategies.parMap :: Strategy b -> (a -> b) -> [a] -> [b]
02:36:36 <lambdabot> Prelude.scanr :: (a -> b -> b) -> b -> [a] -> [b]
02:36:54 <xerox> heh
02:36:56 <xerox> foldl1
02:37:07 <xerox> ?type foldl1
02:37:09 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
02:37:12 <xerox> Right?
02:37:25 <boegel> hmm, interesting :)
02:38:17 <boegel> @hoogle (a -> b -> c) -> [a] -> b -> [c]
02:38:18 <lambdabot> Prelude.scanr :: (a -> b -> b) -> b -> [a] -> [b]
02:39:09 <boegel> @ map ((map filter) [1,2,3]) [1,3,2,3,1,2,3,2,1,1]
02:39:19 <boegel> @eval map ((map filter) [1,2,3]) [1,3,2,3,1,2,3,2,1,1]
02:39:20 <lambdabot> Couldn't match `[[a] -> [a]]' against `t -> t1'
02:39:28 <boegel> @type filter
02:39:29 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
02:39:53 <boegel> @eval map (length.(map filter) [1,2,3]) [1,3,2,3,1,2,3,2,1,1]
02:39:56 <lambdabot> Couldn't match `[[a] -> [a]]' against `t -> t1'
02:40:21 <boegel> @hoogle (a -> Bool) -> [a] -> [a]
02:40:23 <lambdabot> Prelude.dropWhile :: (a -> Bool) -> [a] -> [a]
02:40:23 <lambdabot> Prelude.filter :: (a -> Bool) -> [a] -> [a]
02:40:23 <lambdabot> Prelude.takeWhile :: (a -> Bool) -> [a] -> [a]
02:40:39 <boegel> @eval map (length.(map filter (==)) [1,2,3]) [1,3,2,3,1,2,3,2,1,1]
02:40:41 <lambdabot> Couldn't match `[a -> Bool]' against `t -> t1'
02:40:51 * boegel hmmz
02:42:01 <boegel> @eval map (flip.filter (==) [1,2,3,2,1,3]) [1,2,3]
02:42:02 <lambdabot> Couldn't match `[a]' against `t -> t1'
02:42:19 <boegel> @eval filter (==) 1 [1,2,3]
02:42:21 <lambdabot> Couldn't match `[a]' against `t -> t1'
02:42:25 <boegel> @type filter
02:42:26 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
02:43:07 <boegel> @type foldl
02:43:09 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
02:43:48 <jip> is there something like memcpy for copying from one Data.Array to another?
02:45:15 <xerox> What do you want to do exactly?
02:45:38 <boegel> @type length $ filter (=="one") ["one","two","three","one","two","one"]
02:45:40 <lambdabot> Int
02:45:47 <boegel> @eval length $ filter (=="one") ["one","two","three","one","two","one"]
02:45:48 <lambdabot> 3
02:46:16 <boegel> @eval length $ flip $ filter ["one","two","three","one","two","one"] (=="one")
02:46:17 <lambdabot> Couldn't match `a -> b -> c' against `[a1]'
02:46:21 <boegel> @type flip
02:46:23 <lambdabot> forall c a b. (a -> b -> c) -> b -> a -> c
02:46:45 <xerox> > length $ flip filter [1,2,3] (>2)
02:46:47 <lambdabot> 1
02:46:56 <jip> xerox: i have an array {0, 0, 0, 0, 0, 0, 0, 0, 0, 0} and an array {1, 2, 3}, i want to copy the second array to the first starting at index 2 so the result is: {0, 0, 1, 2, 3, 0, 0, 0, 0, 0}
02:46:59 <xerox> I.e. length $ flip filter $ [1,2,3] (>2)
02:47:01 <boegel> @eval length $ flip filter ["one","two","three","one","two","one"] (=="one")
02:47:03 <lambdabot> 3
02:47:19 <boegel> right, stupid me
02:47:25 <xerox> Na :-)
02:47:30 <xerox> ?docs Data.Array
02:47:31 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array.html
02:47:39 <jip> xerox: i've checked the docs
02:47:45 <xerox> I'm checking them now :-)
02:47:54 <boegel> now... what if I want to do that for all elements of ["one","two","three"], thus resulting in a list [3,2,1] for this example
02:48:38 <xerox> > map (id &&& length) $ group [3,3,3,2,2,1]
02:48:40 <lambdabot> [([3,3,3],3),([2,2],2),([1],1)]
02:48:46 <xerox> > map (head &&& length) $ group [3,3,3,2,2,1]
02:48:48 <lambdabot> [(3,3),(2,2),(1,1)]
02:48:58 <boegel> @type group
02:48:59 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
02:49:06 <xerox> jip, mmmh... it's not completely straightforward, imo.
02:49:14 <boegel> heh, ok :) If I've know about that one...
02:49:31 <boegel> > map length $ group ["one","two","three","one","two","one"]
02:49:33 <lambdabot> [1,1,1,1,1,1]
02:49:34 <jip> xerox: closest thing i see is (//)
02:50:04 <boegel> erm ?
02:50:10 <boegel> > group ["one","two","three","one","two","one"]
02:50:11 <lambdabot> [["one"],["two"],["three"],["one"],["two"],["one"]]
02:50:22 <boegel> group only works for numbers ? :s
02:50:36 <xerox> noj, it works for all the Eq a types
02:50:47 <xerox> Grrr.. "No", sorry noj.
02:51:02 <xerox> jip, you have to roll up your own function.
02:51:03 <boegel> xerox: then why do it produce (take 6 [1..1]) ?
02:51:18 <xerox> (replicate 6 1)
02:51:23 <xerox> Hmmm..
02:51:23 <jip> xerox: yeah but it'll be slow as shit :( i want memcpy to be used internally
02:51:57 <boegel> xerox: doesn't work in GHCi either... strange
02:52:26 <boegel> > group [1,2,1,1,1,2,1]
02:52:28 <lambdabot> [[1],[2],[1,1,1],[2],[1]]
02:52:31 <xerox> > group ["one","one","two","one"]
02:52:33 <lambdabot> [["one","one"],["two"],["one"]]
02:52:34 <boegel> --> that's not what I want
02:52:46 <xerox> > group $ sort ["one","one","two","one"]
02:52:47 <lambdabot> [["one","one","one"],["two"]]
02:52:52 <boegel> hmm, okay
02:52:55 <boegel> that's more like it
02:53:02 <boegel> > map length $ group $ sort ["one","two","three","one","two","one"]
02:53:03 <lambdabot> [3,1,2]
02:53:06 <xerox> Unsorted data is for weenies.
02:53:08 <boegel> hmmkay, thanks :)
02:53:13 * xerox tips his hat
02:53:24 <xerox> jip, it would be slow yep.
02:54:25 <xerox> jip, because you're changing (maxBound first) - (position + maxBound second) indices... I think.
02:56:34 <boegel> @type (&&&)
02:56:36 <lambdabot> forall (a :: * -> * -> *) c' c b.
02:56:36 <lambdabot>    (Arrow a) =>
02:56:36 <lambdabot>    a b c -> a b c' -> a b (c, c')
02:56:42 <boegel> @index (&&&)
02:56:43 <lambdabot> Control.Arrow
02:56:47 <xerox> instance Arrow (->) where
02:56:49 <xerox>   ...
02:56:53 <boegel> @index (,)
02:56:54 <lambdabot> bzzt
02:56:57 <xerox>   (f &&& g) x = (f x, g x)
02:57:00 <xerox>   ...
02:57:05 <boegel> @index ,
02:57:06 <lambdabot> bzzt
02:57:10 <xerox> Prelude.
02:57:21 <boegel> there's a , operator too for that, right ?
02:57:33 <xerox> (,) :: a -> b -> (a,b)
02:58:05 <xerox> (&&&) :: (Arrow a) => a b c -> a b d -> a b (c,d)
02:58:35 <xerox> Of if you willl: (&&&) :: (Arrow (~>)) => (b ~> c) -> (b ~> d) -> (b ~> (c,d))
02:58:55 <xerox> (~>) is equivalent to (->).
02:59:06 <boegel> hmm, mmkay
02:59:45 <xerox> hmhmhmhm
02:59:48 <xerox> (-:
03:00:04 <jip> how do i how a number in hex base?
03:00:08 <jip> show
03:00:17 <ValarQ> showHex ?
03:00:28 <jip> > showHex 14
03:00:29 <lambdabot>  add an instance declaration for (Show (String -> String))
03:00:38 <xerox> > showHex 14 ""
03:00:38 <jip> @type showHex
03:00:40 <lambdabot> forall a. (Integral a) => a -> ShowS
03:00:40 <lambdabot> "e"
03:00:48 <xerox> > showHex 14 "This is just appended before: "
03:00:50 <lambdabot> "eThis is just appended before: "
03:00:56 <xerox> Err, *after* :-P
03:01:15 <jip> @hoogle ShowS
03:01:16 <lambdabot> Prelude.ShowS :: type ShowS
03:01:16 <lambdabot> Prelude.shows :: Show a => a -> ShowS
03:01:16 <lambdabot> Numeric.showSigned :: Real a => (a -> ShowS) -> Int -> a -> ShowS
03:01:54 <jip> > showHex 0xF5 ""
03:01:55 <lambdabot> "f5"
03:02:10 <jip> > toUpper (showHex 0xF5 "")
03:02:11 <lambdabot> Couldn't match `Char' against `String'
03:02:19 <jip> > (map . toUpper) (showHex 0xF5 "")
03:02:20 <lambdabot> Couldn't match `a -> b' against `Char'
03:02:27 <xerox> > map toUpper $ showHex 0xdeadbeef ""
03:02:28 <jip> > (toUpper . map) (showHex 0xF5 "")
03:02:29 <lambdabot> "DEADBEEF"
03:02:29 <lambdabot> Couldn't match `Char' against `t -> t1'
03:02:40 <boegel> @eval (\x,y -> (x*2,y*3)) (1,1)
03:02:42 <lambdabot>  parse error on input `,'
03:02:47 <boegel> @eval (\(x,y) -> (x*2,y*3)) (1,1)
03:02:49 <lambdabot> (2,3)
03:02:54 <xerox> boegel, (***).
03:03:02 <jip> > '$' : (map toUpper $ showHex 0xdeadbeef "")
03:03:03 <lambdabot> "$DEADBEEF"
03:03:13 <xerox> ((*2) *** (*3)) (2,3) ==> (4,9)
03:03:30 <xerox> In the same Arrow (->) infamous instance you have:
03:03:40 <jip> > let showH = '$' : (map toUpper $ showHex x "") in [showH 1, showH 2, showH 100, showH 200, showH 300]
03:03:41 <lambdabot>  Not in scope: `x'
03:03:41 <boegel> xerox: no, I'm wondering why vim is behaving annoyingly on the (\(x,y) ..) syntax
03:03:43 <xerox> (f 
03:03:43 <xerox> (f *** g) (x,y) = (f x, g y)
03:03:47 <jip> > let showH x = '$' : (map toUpper $ showHex x "") in [showH 1, showH 2, showH 100, showH 200, showH 300]
03:03:48 <xerox> Ah.
03:03:49 <lambdabot> ["$1","$2","$64","$C8","$12C"]
03:03:57 <xerox> jip, lambdabot answers private messages too.
03:03:57 <boegel> the ) after y is matched with the first (, which is clearly wrong
03:04:05 <neologism> boegel: \( is not ( so he doesnt match iot
03:04:06 <neologism> it
03:04:25 <jip> xerox: yeah, sorry. i'm not registered though :| /me loads ghci
03:04:26 <xerox> Use "(\ (" ?
03:04:32 <xerox> jip, register!
03:05:37 <jip> xerox: it's too much trouble with all the nicks i have to keep track of
03:06:25 <xerox> jip, they can be linked.
03:10:19 <boegel> @eval (head &&& length) [1,2,2,2,3,3,3,3,3,3]
03:10:21 <lambdabot> (1,10)
03:10:28 <xerox> Yup.
03:10:32 <boegel> @eval (head &&& length) $ group [1,2,2,2,3,3,3,3,3,3]
03:10:33 <lambdabot> ([1],3)
03:10:41 <xerox> map it!
03:10:47 <boegel> @eval map (head &&& length) $ group [1,2,2,2,3,3,3,3,3,3]
03:10:49 <lambdabot> [(1,1),(2,3),(3,6)]
03:12:38 <boegel> ok, dumb mistake, but it works now... :) thanks :)
05:05:13 <vincenz> > group [1,2,2,2,3,3,3,3,3,3]
05:05:14 <lambdabot> [[1],[2,2,2],[3,3,3,3,3,3]]
05:05:58 <aleator> How is haskelll  world these days? Anything new?
05:06:12 <vincenz> aleator: of course not, referential transparencY!
05:06:15 <vincenz> every day is the same
05:06:53 <aleator> Ah I see. 
05:07:04 <int-e> the real world is full of unsafePerformIO, so all bets are off.
05:07:29 <norpan> unsafeInterleaveStupidAnalogies
05:10:00 <xerox> hahaha.
05:10:26 <vincenz> norpan: refering to me?
05:10:48 <aleator> I just spent an hour doing 3d scans from various things, such as bananas.. (with haskell for matrix math).
05:11:12 <norpan> vincenz: relf-referential
05:11:16 <norpan> self
05:11:34 <vincenz> aleator: eh?
05:11:37 <vincenz> aleator: how?
05:11:49 <vincenz> aleator: grid-projection and cam?
05:12:05 <aleator> web camera, cheapish laser, old lp-player..
05:12:15 <aleator> Some tumbling blocks..
05:12:30 <aleator> Oh and several coffee mugs were involved in construction..
05:12:42 <vincenz> how do you get your data into haskell
05:12:46 <Muad_Dib> picture of the construction? :)
05:12:52 <norpan> i think readFile!
05:12:56 <aleator> yep.
05:13:28 <norpan> must ... work
05:13:51 <aleator> I can show you a picture if I can find a camera.. 
05:14:30 <vincenz> aleator: erm..doesn't 3d scanning preclude a camera
05:14:55 <aleator> huh?
05:15:50 <norpan> if the camera is part of the construction it can be hard to use it
05:16:28 <vincenz> well... you can take it out temporarily
05:16:32 <vincenz> or just use haskell
05:16:38 <vincenz> and a recursive equation
05:17:52 <vincenz> camera = (scene camera)
05:18:10 <vincenz> norpan: or a mirror ;)
05:20:52 <aleator> http://www.cc.jyu.fi/~aleator/scanner.jpg & http://www.cc.jyu.fi/~aleator/troll-scanned.png
05:21:17 <vincenz> aleator: make it an animated gif!
05:22:07 <aleator> I should. Though SDL has no quick&easy way of capturing opengl surfaces, so it will have to wait a bit..
05:22:10 <jip> vincenz: whoah that is totally sweet! is this why you were looking for raytracer code?
05:22:27 <vincenz> o.O
05:22:30 <vincenz> jip: what?
05:22:33 <vincenz> jip: that's not my stuff
05:22:56 <xerox> @karma+ aleator -- impressive!
05:22:57 <lambdabot> aleator's karma raised to 2.
05:23:04 <jip> er oh yeah hm... i'm still kind of drunk i guess. cool stuff aleator!
05:23:12 <aleator> Though scans taken by this method are quite expensive.. 
05:23:20 * jip wanders away
05:23:21 <aleator> xerox: thanks :)
05:23:26 <vincenz> aleator: why not use the other method of matching pixels
05:23:31 <vincenz> aleator: two webcams?
05:23:44 <vincenz> that's great for outdoors
05:23:53 <vincenz> (unless you want to put the world on an lp-player)
05:24:10 <aleator> Well. First thing is that I can't get linux support two cheapie cameras..
05:24:35 <aleator> And hum.. Wouldn't you need really textured shapes for stereovision to work nicely?
05:25:08 <aleator> And to why it is expensive this way. The system is turned manually. By a professor.
05:25:38 <aleator> (not me)
05:25:59 <norpan> hey, what do you use karma for
05:28:36 <dons> to keep track of karma
05:29:17 <norpan> good
05:29:39 <dons> ValarQ, ah sounds like a bug reading .hi files. must be new.
05:29:40 <dons> hmm
05:43:36 <olliej_> how do i make ghc look for .hi of external modules when compiling? 
05:45:46 <alar> is there a library for data persistence?
05:47:10 <norpan> you mean like storing and retrieving haskell values?
05:47:20 <alar> yes
05:47:25 <alar> in binary form
05:47:47 <alar> something like class Storable
05:47:50 <dons> alar, yeah, NewBinary, SerTH, some others
05:48:05 <alar> where?
05:50:04 <wilx> Google :)
05:50:04 <dons> there's a list on the old haskell wiki
05:50:08 <dons> ?oldwiki BinaryIo
05:50:09 <lambdabot> http://www.haskell.org/hawiki/BinaryIo
05:50:10 <dons> I think
05:50:47 <dons> oh, and I missed Bulat's new serial lib.
05:50:49 <boegel> ?wiki
05:50:50 <lambdabot> http://www.haskell.org/haskellwiki/
05:51:49 <norpan> show and read not enough eh?
05:51:52 <norpan> you kids
05:53:02 <alar> show&read do not produce binary form
05:53:03 <resiak> Anyone got a good example of a cyclic datastructure?
05:53:25 <norpan> alar: depends on what you mean by binary
05:53:46 <xerox> resiak, data List a = Cons a (List a) | Nil
05:53:54 <alar> norpan: I mean the form where Int is 4-byte record
05:54:22 <alar> This is workable around by inventing new typesystem
05:54:23 <xerox> There also is that Mu type-level-fix, but I don't remember the details.
05:54:24 <norpan> so you actually want a specific format or do you just have general space/time concerns?
05:54:30 <alar> with binary show & read
05:54:38 <alar> and conversion to/from normal types
05:54:54 <resiak> xerox: I misphrased myself. I meant cyclic graphs
05:55:04 <xerox> ?docs Data.Graph
05:55:05 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Graph.html
05:55:10 <xerox> Let's see...
05:55:19 <alar> norpan: I want convenience of reading and interpreting structured binary files
05:55:44 <resiak> Hmm, shame that vertices aren't parametric
05:56:04 <norpan> alar: ok, no necessarily generated from haskell then
05:56:08 <xerox> resiak, maybe here... http://okmij.org/ftp/Haskell/#ccard-transform
05:56:44 <alar> norpn: yes, the file exists already
05:56:47 <xerox> It references this page http://haskell.org/hawiki/TyingTheKnot
05:57:07 <xerox> Yeah, that page explains what you want resiak, I think.
05:57:41 <dons> alar, use NewBinary, it has get and put in binary form
05:59:55 <resiak> That's very, very neat, and exactly what I wanted. Thanks, xerox.
06:00:09 <xerox> You're happily welcome!
06:01:27 <alar> ?docs NewBinary
06:01:28 <lambdabot> NewBinary not available
06:01:46 <alar> ?wiki NewBinary
06:01:46 <xerox> ?whre NewBinary
06:01:47 <lambdabot> http://www.haskell.org/haskellwiki/NewBinary
06:01:47 <lambdabot> darcs get http://www.n-heptane.com/nhlab/repos/NewBinary
06:02:30 <boegel> wtf ? ?whre
06:02:37 <boegel> ?where NewBinary
06:02:38 <lambdabot> darcs get http://www.n-heptane.com/nhlab/repos/NewBinary
06:02:42 <sowha1> hello, where can i find example on the use of the Text.Html library ?
06:02:45 <boegel> is lambdabot that smart?
06:02:52 <xerox> boegel, indeed.
06:02:57 <boegel> ?docs Text.Html
06:02:58 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Text-Html.html
06:03:03 <xerox> ?vixen are you that smart?
06:03:04 <lambdabot> yes, i am
06:03:13 <boegel> ?vixen are you in love with xerox?
06:03:14 <lambdabot> i truely am
06:03:18 <boegel> that says it all
06:03:19 * xerox giggles
06:03:49 <olliej_> that's just disturbing
06:04:48 <dozer> I feel dirty
06:05:05 <alar> thanks
06:05:08 <sowha1> boegel: that are just the docs, but no examples. i don't see how i can use hotlink for instance
06:05:15 <alar> class Binary - that's what I wanted
06:05:32 <boegel> @type hotlink
06:05:34 <lambdabot> Not in scope: `hotlink'
06:05:44 <boegel> @type Text.Html.hotlink
06:05:46 <lambdabot> Text.Html.URL
06:05:46 <lambdabot>        -> [Text.Html.Html]
06:05:46 <lambdabot>        -> Text.Html.HotLink
06:06:04 <boegel> hmm, can't help you there, never used it
06:07:11 <alar> not sure I'll ever use it though
06:10:00 <tromp> ?vixen are you xerox?
06:10:01 <lambdabot> i truely am
06:10:43 <ADEpt> sowha1: there are example in the source code of Text.Html itself.
06:10:46 <alar> @xerox are you vixen?
06:10:47 <lambdabot> Unknown command, try @list
06:10:56 <jip> @seen Philippa 
06:10:57 <lambdabot> Philippa is in #scannedinavian, #haskell-overflow, #haskell-blah and #haskell. I don't know when Philippa last spoke.
06:11:07 <alar> @seen reductor
06:11:08 <lambdabot> I haven't seen reductor.
06:16:18 <zellyn> Hi folks.  A quick question.
06:16:45 <zellyn> I'm writing a tiny term evaluator
06:17:02 <zellyn> The small step evaluator has type Term -> m Term
06:17:11 <zellyn> Where m is (right now) Maybe.
06:17:57 <zellyn> I want to write the big-step evaluator (eval) that calls the small-step evaluator (eval1) repeatedly.
06:18:47 <zellyn> Is there a Monad-y function that'll do that - apply a function repeatedly to a value, and return the last non-failure value?
06:19:11 <alar> how can I use lambdabot for name lookup  (function name, class or something)
06:19:14 <alar> ?
06:19:17 <zellyn> Perhaps I can compare to mzero?
06:19:29 <jip> alar: hoogle
06:19:57 <alar> @karma_ jip
06:19:58 <lambdabot> Maybe you meant: karma karma+ karma-
06:20:01 <alar> @karma+ jip
06:20:03 <lambdabot> jip's karma raised to 1.
06:20:07 <ADEpt> zellyn: you are looking for monadic repeat, basically?
06:20:11 <zellyn> yeah
06:20:20 <ADEpt> @hoolge repeat
06:20:21 <lambdabot> Prelude.repeat :: a -> [a]
06:20:26 <zellyn> hah
06:20:29 <xerox> Hmm.
06:20:30 <zellyn> yes
06:20:35 <xerox> ?hoogle sequence
06:20:36 <lambdabot> Prelude.sequence :: Monad m => [m a] -> m [a]
06:20:36 <lambdabot> Prelude.sequence_ :: Monad m => [m a] -> m ()
06:20:36 <lambdabot> Language.Haskell.TH.Syntax.sequenceQ :: [Q a] -> Q [a]
06:20:37 <ADEpt> but that's not what you want
06:20:50 <zellyn> But it has the same flavour.
06:21:04 <xerox> ?hoogle iterateM
06:21:05 <lambdabot> No matches found
06:21:07 <xerox> ?hoogle iterate
06:21:08 <lambdabot> Prelude.iterate :: (a -> a) -> a -> [a]
06:21:18 <ADEpt> @hoogle (a->a) -> m a -> m a
06:21:19 <lambdabot> Data.Generics.Schemes.everywhere :: (a -> a) -> a -> a
06:21:19 <lambdabot> Data.Generics.Schemes.everywhere' :: (a -> a) -> a -> a
06:21:19 <lambdabot> Control.Monad.Error.catchError :: MonadError e m => m a -> (e -> m a) -> m a
06:21:36 <xerox> ?hoogle (a -> m a) -> a -> m a
06:21:38 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
06:21:38 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
06:21:38 <lambdabot> Data.Generics.Schemes.everywhere :: (a -> a) -> a -> a
06:21:47 <xerox> ?hoogle (a -> m a) -> m a -> m a
06:21:48 <lambdabot> Data.Generics.Schemes.everywhere :: (a -> a) -> a -> a
06:21:48 <lambdabot> Data.Generics.Schemes.everywhere' :: (a -> a) -> a -> a
06:21:48 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
06:21:51 <xerox> ....
06:21:56 <ADEpt> :)
06:21:57 <jip> is there like a switch to ghc where it preprocesses do syntax sugar into regular haskell expressions?
06:22:21 <xerox> jip, I don't think so, but check the manpage.
06:23:27 <wilx> Hmm, one of the many dumps contains results of this desugaring process.
06:23:51 <ADEpt> jip: try ghc -v4 .... 2>&1 | less and browse all of the dumps
06:24:38 <alar> ADEpt: are you going to participate in ICFPC06?
06:24:57 <jip> ADEpt: cool thanks i think i see it
06:25:22 <jip> ADEpt: oh wait, that's not it
06:26:14 <jip> ADEpt: there's a dump but it still contains the do expressions
06:26:40 <sowha1> ADEpt, ofcourse in the source that's the place to publish it... sign
06:28:42 <ADEpt> sowha1: well, it is said that Text.Html is based on Text.PrettyPrint by HughesPJ. Having experience with Text.Pretty, I had no problem dealing with Text.Html 
06:34:18 <BCoppens> Itkovian: just wondering, why are you at uni atm? Don't you have easter holidays?
06:34:39 <Itkovian> Dude.
06:34:42 <Itkovian> We have to work
06:34:50 <BCoppens> heh =)
06:34:58 <Itkovian> it's not because students have holiday that we do too
06:35:15 <BCoppens> ah, I implicitly assumed that the holidays just were the same
06:35:18 <zellyn> How do you specify a catch-all in a case expression?
06:35:44 <resiak> _
06:35:49 <zellyn> I'm getting "Warning: Pattern match(es) are overlapped"
06:55:04 <zellyn> What's the problem with using mzero as a pattern in a case statement?
06:55:20 <zellyn> It works fine with Nothing when using Maybe.
06:55:35 <zellyn> But mzero seems to match both Nothing and Just 3.
06:56:20 <zellyn> And I get a "Warning: Pattern match(es) are overlapped" when using mzero, but not when using Nothing.
06:57:16 <wilx> > mzero :: Maybe Int
06:57:17 <lambdabot> Nothing
06:57:44 <mauke> mzero is not a constructor, thus it is a variable
06:57:50 <mauke> a pattern of foo matches anything
06:58:14 <zellyn> Aah.
06:58:50 <zellyn> How do I check whether x is (Nothing/[]/exception) without using a monad-specific constructor?
06:59:08 <zellyn> For any MonadPlus I should be able to tell, right?
06:59:18 <mauke> I'm not sure
06:59:56 <Saulzar> You could use guards
07:00:15 <zellyn> Saulzar: isn't that just like using a case statement?
07:00:17 <wilx> x == mzero?
07:00:35 <wilx> > let x = Nothing in x == mzero
07:00:37 <lambdabot> Add a type signature
07:00:43 <wilx> > let x = Nothing :: Maybe Int in x == mzero
07:00:45 <lambdabot> True
07:00:53 <wilx> > let x = Just 1 :: Maybe Int in x == mzero
07:00:54 <lambdabot> False
07:01:01 <mauke> oh, == works
07:01:05 <zellyn> cool
07:01:06 <wilx> > let x = [] :: [Int] in x == mzero
07:01:08 <lambdabot> True
07:01:12 <wilx> > let x = [1,2] :: [Int] in x == mzero
07:01:14 <lambdabot> False
07:01:24 <Saulzar> > let foo x | x == mzero = 0 | otherwise = 1 in foo Nothing
07:01:25 <lambdabot> Add a type signature
07:01:31 <Saulzar> > let foo x | x == mzero = 0 | otherwise = 1 in foo Nothing :: Maybe Int
07:01:32 <lambdabot>  add an instance declaration for (Num (Maybe Int))
07:01:32 <lambdabot>   In the expression: foo Nothing :: Maybe Int
07:01:32 <lambdabot>   In the definition of `ljk':
07:01:37 <Saulzar> > let foo x | x == mzero = 0 | otherwise = 1 in foo Nothing :: Int
07:01:38 <lambdabot> Add a type signature
07:02:26 <Saulzar> > let foo Monad m => m a -> Int; foo x | x == mzero = 0 | otherwise = 1 in foo Nothing
07:02:27 <lambdabot>  parse error on input `=>'
07:02:31 <Saulzar> > let foo :: Monad m => m a -> Int; foo x | x == mzero = 0 | otherwise = 1 in foo Nothing
07:02:32 <lambdabot>  add (MonadPlus m) to the type signature(s) for `foo'
07:02:39 <Saulzar> > let foo :: MonadPlus m => m a -> Int; foo x | x == mzero = 0 | otherwise = 1 in foo Nothing
07:02:40 <lambdabot>   add (Eq (m a)) to the type signature(s) for `foo'
07:02:40 <lambdabot>   or add an instance declaration for (Eq (m a))
07:02:40 <lambdabot>   In a pattern guard for
07:03:24 * Saulzar mutters
07:03:37 <zellyn> That makes sense.
07:03:38 <zellyn> heh
07:04:03 <Saulzar> > let foo :: (MonadPlus m, Eq (m a)) => m a -> Int; foo x | x == mzero = 0 | otherwise = 1 in foo Nothing
07:04:04 <lambdabot> Add a type signature
07:04:24 <Saulzar> > let foo :: (MonadPlus m, Eq (m a)) => m a -> Int; foo x | x == mzero = 0 | otherwise = 1 in foo Nothing :: Int
07:04:25 <lambdabot> Add a type signature
07:04:49 <Saulzar> @slap lambdabot 
07:04:50 * lambdabot slaps lambdabot
07:04:59 <zellyn> heh
07:05:27 <Saulzar> It works in ghci :)
07:05:58 <Saulzar> (Sorry for the spam)
07:06:07 <zellyn> np
07:06:30 <zellyn> I guess the monads that support "fail" should have an "isfailure" method.
07:07:24 <lome> what for?
07:08:41 <mauke> all monads have fail
07:08:55 <Saulzar> Usually you'd want it to happen implicitly (the failure), and for things like IO would it even be possible?
07:20:13 <zellyn> yeah, that's true.
07:20:37 <zellyn> Saulzar: thanks
07:20:41 <zellyn> later
07:26:19 <jip> i'm having trouble understaing the AST type here:
07:26:20 <jip> http://www.haskell.org/tmrwiki/PhilippaCowderoy_2fWIP_2fMonadArticleThingy
07:29:50 <Saulzar> It's using a recursive data structure to store all the monad functionality
07:30:25 <jip> but it doesn't look like any data statement i've ever seen. usually they look like data Foo = Bar | X | Y Z
07:30:36 <Saulzar> It's a GADT
07:31:06 <jip> hm... can if it weren't a GADT then what would it look like?
07:32:13 <Igloo> Does this help:   data Maybe a = Just a | Nothing       ===     data Maybe a where Just :: a -> Maybe a; Nothing :: Maybe a
07:32:34 <Saulzar> I don't think it's quite possible without a GADT (because the result type is dependant on the arguments)  but it would be something like data AST state = Return result |... 
07:33:11 <Igloo> It basically just tells you the type of the constructors
07:33:17 <jip> Igloo: hm... thanks i guess that sort of helps
07:33:43 <jip> so is GADT something i sould learn and love and embrace as the future of haskell programming?
07:38:02 <shapr> They're definitely neat.
07:38:25 <ptolomy> Is it worthwhile to join ACM?
07:39:07 * shapr doesn't think so
07:40:06 <shapr> But mostly because I do not believe that research papers should cost money.
07:40:09 <ptolomy> They make a decent case on the website, but so do many porn sites..
07:40:38 <wchogg> Maybe you could combine the two?
07:40:40 <Muad_Dib> shapr: aren't a lot of the papers they offer free anyway on other sites?
07:40:56 * ptolomy imagines Knuth porn.
07:40:58 * ptolomy vomits.
07:41:15 <Saulzar> Yep, if I run into ACM I just stick the name into google :)
07:41:37 <Saulzar> Sometimes, rarely ... they're not available elsewhere
07:41:53 <ptolomy> Convenience is a big bonus, though. Also, Safari membership built-in.
07:42:48 <jip> is there like a *good* haskell book that goes into real detail about everything from the basics up to things like monads and GADT and ==gives lots of examples and excercises with solutions== ?
07:43:07 <Lemmih> GADTs are pretty new.
07:43:24 <jip> hello Lemmih
07:43:35 <Lemmih> Hiya.
07:43:40 <Oejet> Hi, Lemmih.
07:43:51 <jip> Lemmih: is there news about hIDE?
07:44:52 <Saulzar> jip, Best not to learn everything in one go - the best two monad introductions are first Cales's "Monads as containers" on the hawiki, and then "All about monads" when you've gone through that
07:46:10 <jip> Saulzar: i've read both of those dozens of times. but i'm the kind of person who learns best by doing. i would like a lot of good excercises
07:46:24 <Saulzar> Ah, well... pick some example and mess with it
07:46:31 <Saulzar> That's what I always do
07:47:00 <jip> well, i'm sort of writing my own monad i think
07:47:08 <jip> it seems to be slowly working
07:47:16 <jip> but now i got stuck on this GADT thing
07:47:31 <Saulzar> I would not worry about them too much
07:47:38 <Lemmih> jip: There's a bit of bad news. If I can't figure out a way to pre-compile plugins then hIDE development will halt again (and probably for more than a couple of months).
07:47:51 <shapr> precompile?
07:49:46 <Lemmih> shapr: Seen the hide weblog? Plugins can export interfaces dynamically like this 'export ("myfunc", myfunc arg1 arg2)'.
07:50:02 <shapr> Oh, neat.
07:50:26 <Lemmih> But it (currently) only works when plugins are interpreted.
07:50:53 <Lemmih> And re-interpreting all of hide on start-up isn't really an option.
07:52:51 <Lemmih> But I'm hoping I can link object files and then resolve the missing symbols.
07:53:03 <shapr> Yeah, that would be nice.
07:53:09 <jip> what about hs-plugins 2?
07:58:19 <Lemmih> As I see it, we need three versions of hs-plugins: a low-level interface to Linker.{c|hs}, a medium-level interface which is what hs-plugins is now, and a high-level interface for convenient use of the ghc-api.
08:02:44 <xerox> Lemmih, uh, export takes an HList?
08:06:28 <Lemmih> xerox: Yeah.
08:06:38 <xerox> Wow.
08:08:11 <Lemmih> I need to convert '(name, fun) :+: Nil'  to  '(list of names with fun types, list of unsafeCoerced funs)'.
08:09:30 <xerox> (-:
08:42:26 <jip> hm... where are all the good GADT introductions?
08:45:34 <JohnnyL> what's Gadt?
08:46:33 <tromp> google knows
08:46:51 <tromp> @hoogle gadt
08:46:52 <lambdabot> No matches found
08:48:04 <dozer> JohnnyL - there's a wiki page I think
08:48:15 <dozer> possibly on the ghc site though
08:48:41 <dozer> or look at recent(ish) papers on lambda-the-ultimate
09:00:15 <Saulzar> @pl \x y -> fromBool (x == y)
09:00:16 <lambdabot> (fromBool .) . (==)
09:01:12 <vincenz> re
09:06:02 <vincenz> @pl \f x y z -> f x y z
09:06:03 <lambdabot> id
09:06:17 <vincenz> @pl \f g x y z -> f (g x y z)
09:06:17 <lambdabot> (.) . (.) . (.)
09:09:50 <norpan> @pl \(x,y) -> (y,x)
09:09:51 <lambdabot> uncurry (flip (,))
09:10:04 <norpan> så fint
09:10:49 <ibid> @pl \x y z -> (z,y,x)
09:10:50 <lambdabot> flip (flip . flip (,,))
09:10:58 <vincenz> @pl \f g x y z a -> f (g x y z a)
09:10:59 <lambdabot> (.) . (.) . (.) . (.)
09:11:03 <vincenz> @pl \f g x y z a b -> f (g x y z a b)
09:11:03 <lambdabot> (.) . (.) . (.) . (.) . (.)
09:11:27 <ibid> @pl \f g h x y z -> f (g (h x y) z)
09:11:28 <lambdabot> (. ((.) . (.))) . (.) . (.) . (.) . (.)
09:11:50 <vincenz> boobsalore!
09:13:21 <ibid> @pl (\h -> (\f g -> f . g) . h)
09:13:27 <lambdabot> ((.) .)
09:13:37 <norpan> almost
09:14:16 <ibid> @pl (\h y -> (\f g x -> f (g x)) (h y))
09:14:17 <lambdabot> ((.) .)
09:14:47 <ibid> @pl (\h y f g x -> f (g x)) (h y))
09:14:48 <lambdabot> (line 1, column 30):
09:14:48 <lambdabot> unexpected ")"
09:14:48 <lambdabot> expecting variable, "(", operator or end of input
09:14:58 <ibid> @pl \h y f g x -> (f (g x)) (h y)
09:14:59 <lambdabot> (flip (flip . (flip .) . (.)) .)
09:15:18 <ibid> @pl \f g h x y -> (f (g x)) (h y)
09:15:19 <lambdabot> ((flip . ((.) .)) .) . (.)
09:18:05 <norpan> @pl \a b c d -> a (b c d)
09:18:07 <lambdabot> (.) . (.)
09:18:13 <norpan> good bot
09:19:01 <ibid> @type ((.) .)
09:19:02 <lambdabot> forall b c a a1.
09:19:02 <lambdabot>     (a1 -> b -> c) -> a1 -> (a -> b) -> a -> c
09:19:10 <ibid> @type ((.) (.))
09:19:12 <lambdabot> forall b c a a1.
09:19:12 <lambdabot>      (a1 -> b -> c) -> a1 -> (a -> b) -> a -> c
09:19:21 <ibid> @type (. .)
09:19:22 <lambdabot> parse error on input `.'
09:19:25 <ibid> bah
09:20:11 <JohnnyL> > take 5 $ iterate (+1) 1
09:20:13 <lambdabot> [1,2,3,4,5]
09:20:49 <roconnor> > [1..5]
09:20:50 <lambdabot> [1,2,3,4,5]
09:26:27 <JohnnyL> > [1 35]
09:26:28 <lambdabot>  add an instance declaration for (Num (t -> a))
09:26:28 <lambdabot>   In the list element: 1 35
09:26:28 <lambdabot>   In the definition of `thb': thb = [1 35]
09:26:32 <JohnnyL> > [1.. 35]
09:26:33 <lambdabot> [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35]
09:31:46 <jip> whoah i think i figured this shit out :o
09:33:01 <vincenz> jip: ?
09:33:21 <Lemmih> dons: ping.
09:33:53 <jip> Philippa has really helped me
09:34:25 <jip> vincenz: i haven't really tested this yet but it compiles :)
09:34:46 <vincenz> jip: what does?
09:35:05 <Saulzar> lisppaste2, url
09:35:05 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
09:35:19 <jip> vincenz: this sort of mini-language for describing the operation of a cpu instruction using a minimal set of operations
09:35:28 <vincenz> jip: ooh interesting
09:36:11 <jip> in the process i've been exposed to GADT and i think i sort of get them now
09:36:38 <lisppaste2> Saulzar pasted "Most beautiful fibonacci" at http://paste.lisp.org/display/18953
09:36:46 <vincenz> jip:can I see?
09:37:17 <jip> vincenz: hm... well the code is sort of spread all over the place over a few different files
09:37:29 <vincenz> Saulzar: trying to write c-code in haskell?
09:37:39 <jip> vincenz: but i'm thinking of starting a sort of online journal to report my progress
09:37:46 <vincenz> jip: :)
09:37:50 <vincenz> a 'blog' as it were
09:37:52 <Saulzar> vincenz, output of pl0 to haskell compiler :)
09:38:02 <vincenz> Saulzar: then I forgive you
09:38:12 <vincenz> Saulzar: you could prolly do intermediate variable removal
09:38:14 <vincenz> and remove most io-refs
09:38:23 <Saulzar> But yes, that's essentially what it is...
09:38:34 <jip> vincenz: yeah i guess, a 'blog', but with no user comments :) i am making a gameboy emulator btw
09:38:38 <Saulzar> Hmm
09:39:04 <vincenz> jip: what's the instruction set you're encoding
09:39:20 <roconnor> tmp15  <-  (return 10)
09:39:23 <vincenz> jip: and when I read "minimal set o operations" I read microcode
09:39:23 <roconnor> wow
09:39:30 <vincenz> roconnor: hehe :D
09:39:43 <roconnor> tmp0  <-  (return 1)
09:40:01 <vincenz> yeah really
09:40:08 <vincenz> tmp0 <- (return 1) is just lika a let statement
09:40:16 <vincenz> and can prolly be substituded DIRECTLY for tmp0
09:40:24 <vincenz> doesn't require much logic to detect htose case and substitute
09:40:38 <vincenz> roconnor: at least it's not this
09:40:38 <jip> vincenz: gameboy cpu, which is similar to z80. when i say "minimal set of operations" i mean: readRegister, writeRegister, readMemory and writeMemory
09:40:41 <roconnor> this is (hopefully) generated code?
09:40:46 <vincenz> mktmp0 <- ( return $ return 1)
09:40:51 <vincenz> tmp0 <- mktmp0
09:41:02 <vincenz> jip: which is basically microcdoe
09:41:10 <Saulzar> Yep, it's not extremely smart :)
09:41:35 <vincenz> mkmktmp0 <- (return $ return $ return 1)
09:41:37 <JohnnyL>  /j #suse
09:41:45 <vincenz> mktmp0 <- mkmktmp0
09:41:47 <Saulzar> Only reason it does that is because "1" is an expression, and it just binds expressions 
09:42:01 <vincenz> Saulzar: detect contstant expressions
09:42:06 <jip> vincenz: i'm not really sure what microcode means, but the trick is that these are monadic operations, and so you can also use any haskell expression for your calculations
09:42:21 <roconnor> presumably ghc will do something reasonable.
09:42:59 <jip> i just hope this shit will run fast enough to emulate a 4 mhz cpu in realtime :\
09:51:31 * jip summons back Philippa
09:56:09 <jip> hm... GADT don't do complete type inference?
10:00:28 <Igloo> No (and 6.4.1 also has bugs which means it's even less complete than it needs to be)
10:00:56 <jip> :'(
10:01:09 <jip> will ghc 6.5 do complete type inference?
10:01:29 <Igloo> No; complete type inference is undecidable
10:01:43 <jip> but how can that be?
10:10:15 <jip> saweet, my first test passes! :D :D =]
10:11:33 <kOxiNeLLe> hello. I'm planning to run one of your bots like mbot, but I would like to know if any of you could provide me the script and/or plugin for mathematica, or if I'd have to write it myself?
10:11:48 <jip> er... wrong channel?
10:12:11 <bolrod> saweet
10:12:13 <kOxiNeLLe> hmmm
10:12:21 <bolrod> :)
10:12:34 <kOxiNeLLe> <jip> er... wrong channel?  --> I don't think I'm at the wrong place
10:12:36 <jip> kOxiNeLLe: maybe try #math?
10:12:49 <kOxiNeLLe> jip, they send me here from math
10:12:50 <xerox> No it's ok.
10:12:57 <kOxiNeLLe> yeah, I know it's here
10:12:59 <xerox> The problem is that Cale has it, I prolly had too...
10:13:01 <jip> hm... mbot is written in haskell? :O
10:13:03 <kOxiNeLLe> it says on the bot txt files too
10:13:06 <xerox> ...but I don't know where I could left it.
10:13:14 <xerox> jip, mbot == lambdabot.
10:13:15 <kOxiNeLLe> oh
10:13:22 <kOxiNeLLe> yup
10:13:27 <jip> hm.... really? interesting
10:13:43 <jip> % 1 + 1
10:13:45 <xerox> Sure, what other bot would Cale use in your opinion? (-:
10:14:05 <xerox> That's kOxiNeLLe problem, jip, '%' is proprietary :-P
10:14:08 <kOxiNeLLe> there is a folder on lambda bot page called 'Plugins', however I don't think the Mathematica one is included there
10:14:38 <xerox> Let me see if I can find it...
10:14:44 <kOxiNeLLe> thanks :)
10:15:06 <vincenz> mbot == lambdabot+cale-extension
10:15:20 <xerox> 'extensions'
10:15:34 <vincenz> mbot = lambdabot >>= Cale 
10:15:40 <xerox> hah.
10:15:43 <Cale> there's a couple of extensions -- I gave one of them to dons at some point
10:15:52 <kOxiNeLLe> hi Cale
10:15:52 * xerox hugs Cale
10:16:08 <vincenz> @karma+ Cale 
10:16:09 <lambdabot> Cale's karma raised to 8.
10:17:20 <kOxiNeLLe> so it's more than just one script to run the lambdabot with the mathematica part?
10:19:55 * kOxiNeLLe waits patientl
10:19:56 <kOxiNeLLe> y
10:28:10 <bolrod> I guess you have to wait a little longer
10:28:48 <kOxiNeLLe> I will
10:29:02 <bolrod> good 
10:29:05 <bolrod> ;)
10:37:47 * jip pokes Philippa 
10:57:06 <JohnnyL> what's the biggest part of the haskell interpreter?
10:57:36 <Philippa> yerwhat? That doesn't make sense
10:57:52 <Philippa> jip: am sort of hereish but not for much longer. My client attempts to reconnect automagically
11:04:22 <jip> Philippa: it works!
11:04:42 <jip> Philippa: i got rid of the the state "type parameter" or whatever it's called. i don't need it
11:07:56 <jip> Philippa: check it out:
11:08:20 <jip> http://rafb.net/paste/results/hfZzTG56.html
11:08:26 <jip> those are the good snippets
11:10:44 <ValarQ> > subtract 5 2
11:10:45 <lambdabot> -3
11:11:52 * ValarQ 's mind is having problem with that argument order
11:13:15 <bolrod> haha
11:13:20 <bolrod> subtract 5 from 2
11:13:52 <bolrod> > let subtract' = flip subtract in subtract' 5 2 
11:13:54 <lambdabot> 3
11:13:55 <bolrod> :)
11:14:04 <roconnor> Think (subtract 5) 2
11:14:23 <roconnor> or better let f = subtract 5 in f 2
11:14:30 <ValarQ> i was using it in the form: (`subtract` 5)
11:14:32 <bolrod> do not think! just do
11:14:54 <Saulzar> jip, Is it practical to write a large amount of code with the GADT monad approach? I would have thought that it was just for demonstration...
11:15:01 <ValarQ> bolrod: yeah, just do will do just fine :)
11:16:12 <Saulzar> jip, Though it is quite cool - I suppose it can always be swapped later ...
11:17:12 <bolrod> whats the 'GADT monad approach' ?
11:28:42 <Saulzar> bolrod, http://www.haskell.org/tmrwiki/PhilippaCowderoy_2fWIP_2fMonadArticleThingy
11:32:54 <vincenz> anyone hear anything about jethr0 as of late?
11:32:58 <vincenz> @seen jethr0
11:32:58 <lambdabot> I haven't seen jethr0.
11:33:04 <vincenz> @slap lambdabot 
11:33:05 * lambdabot slaps lambdabot
11:33:28 <kOxiNeLLe> @help
11:33:28 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:33:34 <kOxiNeLLe> @list
11:33:34 <lambdabot> list [module|command]. Where modules is one of:
11:33:34 <lambdabot> babel base compose dice dict djinn drHylo dummy dynamic elite fact haddock help hoogle karma lambda localtime log more pl plugs poll pretty quote search seen slap spell state system todo topic type
11:33:34 <lambdabot> unlambda version vixen where
11:33:55 <kOxiNeLLe> @help pretty
11:33:56 <lambdabot> pretty <expr>. Display haskell code in a pretty-printed manner
11:34:07 <kOxiNeLLe> @pretty foo
11:34:08 <lambdabot> "Parse error" at column 4
11:34:12 <kOxiNeLLe> -_-
11:34:32 <kOxiNeLLe> @pretty [1 2]
11:34:33 <lambdabot> "Parse error" at column 6
11:34:36 <kOxiNeLLe> hmrm
11:34:49 <neologism> @pretty map (+1) [1,2,3]
11:34:49 <lambdabot> "Parse error" at column 17
11:35:06 <kOxiNeLLe> @help quote
11:35:07 <lambdabot> quote <nick>
11:35:07 <lambdabot> remember <nick> <quote>
11:35:07 <lambdabot> Quote somebody, a random person, or save a memorable quote
11:35:20 <kOxiNeLLe> @quote xerox
11:35:21 <lambdabot>  > take 10 lol where lol = "ol" : zipWith (:) (intersperse 'o' $ cycle "l") lol
11:35:33 <kOxiNeLLe> @help spell
11:35:34 <lambdabot> spell <word>. Show spelling of word
11:35:41 <kOxiNeLLe> @spell foo
11:35:42 <lambdabot> foo
11:35:53 <kOxiNeLLe> @help topic
11:35:54 <lambdabot> topic provides: topic-tell topic-cons topic-snoc topic-tail topic-init topic-null
11:36:01 <kOxiNeLLe> @help todo
11:36:02 <lambdabot> todo. List todo entries
11:36:11 <kOxiNeLLe> @todo
11:36:12 <lambdabot> 0. SamB: A way to get multiple results from a google search
11:36:12 <lambdabot> 1. SamB: @get-shapr summons shapr instantly
11:36:12 <lambdabot> 2. SamB: stop mangling long urls
11:36:12 <lambdabot> 3. dons: improve formatting of @dict
11:36:12 <lambdabot> 4. dons: write Haskell Manifesto
11:36:14 <lambdabot> [18 @more lines]
11:36:23 <kOxiNeLLe> @help more lines
11:36:24 <lambdabot>  @more. Return more output from the bot buffer.
11:36:30 <kOxiNeLLe> @todo
11:36:31 <norpan> can't you talk privately to the bot?
11:36:31 <lambdabot> 0. SamB: A way to get multiple results from a google search
11:36:31 <lambdabot> 1. SamB: @get-shapr summons shapr instantly
11:36:31 <lambdabot> 2. SamB: stop mangling long urls
11:36:31 <lambdabot> 3. dons: improve formatting of @dict
11:36:31 <lambdabot> 4. dons: write Haskell Manifesto
11:36:33 <lambdabot> [18 @more lines]
11:36:34 <kOxiNeLLe> o
11:36:36 <kOxiNeLLe> oh
11:36:39 <kOxiNeLLe> no I can0t
11:36:44 <kOxiNeLLe> because I'm not a registered user
11:36:46 <kOxiNeLLe> on freenode
11:37:11 <kOxiNeLLe> <kOxiNeLLe> foo
11:37:11 <kOxiNeLLe> * Private messages from unregistered users are currently blocked due to spam problems, but you can always message a staffer. Please register! ( http//freenode.net/faq.shtml#privmsg ) (505) 
11:37:12 <kOxiNeLLe> see?
11:37:22 <norpan> so register :)
11:37:28 <kOxiNeLLe> click on that link
11:37:39 <kOxiNeLLe> then tell me where to register there and I'll gladly do it
11:38:00 <norpan> it's missing a :
11:38:27 <kOxiNeLLe> and the correct link would be?
11:38:31 <wchogg> http://freenode.net/faq.shtml#userregistration
11:38:34 <kOxiNeLLe> thanks
11:54:58 <JohnnyL> > ([1..22],[1..41])
11:55:00 <lambdabot> ([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22],[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41])
11:55:50 <jip> Saulzar: why wouldn't it be practical?
11:57:39 <Saulzar> jip, It might not be - but it involves explicitly creating and interpreting a data structure which would seem like it might be somewhat slower
11:59:28 <jip> Saulzar: hm... well, i hope that this will be fast :|
12:00:13 <Saulzar> Would be interesting to test some numbers, one with the GADT way and one with normal (composing functions) way
12:00:57 <jip> hm... i am not aware of any other way
12:06:18 <vincenz> > take 4 $ inits [1..]
12:06:19 <lambdabot> [[],[1],[1,2],[1,2,3]]
12:07:02 <vincenz> > take 5 $ drop 1 $ inits [0..]
12:07:03 <lambdabot> [[0],[0,1],[0,1,2],[0,1,2,3],[0,1,2,3,4]]
12:09:39 <JohnnyL> drop 1 [1..5]
12:09:40 <vincenz> > sum $  map sum $ take 5 $ drop 1 $ inits [1..]
12:09:41 <lambdabot> 35
12:09:44 <JohnnyL> drop 1 [1..5]
12:09:48 <JohnnyL> > drop 1 [1..5]
12:09:49 <vincenz> > sum $  map sum $ take 6 $ inits [1..]
12:09:50 <lambdabot> [2,3,4,5]
12:09:50 <lambdabot> 35
12:10:14 <basti_> map drop sum? that sounds a little like a cantonese dish
12:10:28 <JohnnyL> hehe
12:11:17 <JohnnyL> map sum $ take 6 $ inits [11..]
12:11:25 <JohnnyL> > map sum $ take 6 $ inits [1..]
12:11:26 <basti_> what are you trying to do?
12:11:26 <lambdabot> [0,1,3,6,10,15]
12:11:35 <basti_> just toying around?
12:11:38 <JohnnyL> yah
12:11:38 <vincenz> me?
12:11:40 <vincenz> yah
12:11:51 <vincenz> > reverse ":("
12:11:52 <lambdabot> "(:"
12:12:28 <basti_> > take 10 $ let fibs = zipWith (+) fibs (tail fibs) in fibs
12:12:29 <lambdabot> Terminated
12:12:35 <basti_> uhm?
12:12:40 <basti_> ah
12:12:41 <vincenz> basti_: head
12:12:43 <vincenz> 11
12:12:45 <vincenz> 1:1::
12:12:50 <basti_> > take 10 $ let fibs = 1:1:zipWith (+) fibs (tail fibs) in fibs
12:12:50 <basti_> yea
12:12:51 <lambdabot> [1,1,2,3,5,8,13,21,34,55]
12:13:03 <vincenz> > sum $ take 10 $ let fibs = 1:1:zipWith (+) fibs (tail fibs) in fibs
12:13:05 <lambdabot> 143
12:13:12 <vincenz> > sum $ take 7 $ let fibs = 1:1:zipWith (+) fibs (tail fibs) in fibs
12:13:13 <lambdabot> 33
12:13:26 <vincenz> > sum $ take 8 $ let fibs = 1:1:zipWith (+) fibs (tail fibs) in fibs
12:13:28 <lambdabot> 54
12:13:28 <vincenz> hah!
12:13:31 <basti_> > foldl (flip (:)) [] [1,2,3]
12:13:33 <lambdabot> [3,2,1]
12:13:35 <basti_> :D
12:13:47 <vincenz> sum $ map fib [0..n] == (fib (n+2)) -1
12:14:19 <basti_> www.foldl.com btw
12:14:31 <vincenz> yeah
12:14:39 <vincenz> a whole domain name for a lame javascript
12:15:06 <vincenz> www.foldr.com too
12:15:26 * basti_ nods
12:15:32 <wchogg> I thought the fold* sites were kindof funny.
12:15:50 <Saulzar> Do they have foldl'.com ?
12:16:00 <vincenz> Saulzar: they have replicate.com
12:16:04 <vincenz> Saulzar: it's full of bunnies
12:16:06 <Saulzar> Where it is strictly evaluated :)
12:16:13 <wchogg> Stupid bunnies.
12:16:50 * vincenz is just kidding
12:19:26 <wchogg> vincenz:  A shame.  I was hoping there really was a rabbit porn site that was lazily evaluated.
12:20:34 <vincenz> LOL
12:20:45 <vincenz> with an emphasis on lazily
12:43:23 <mahogny> I'm looking for a command to emit an idle event in wxhaskell. anyone know one?
12:43:35 <mahogny> also, anyone know an IRC channel for wxhaskell? one is really needed :(
12:44:01 <basti_> uhm
12:44:07 <basti_> a) why a special channel?
12:44:12 <basti_> b) what is an IDLE EVENT?!
12:44:37 <mahogny> well. I have tons of very detailed questions that I dunno if they fit in a general purpose channel
12:44:58 <mahogny> the idle event is emitted whenever the GUI has nothing better to do
12:45:00 <mahogny> kind of
12:45:03 <basti_> sure they do... if it bothers people (traffic overflow, as we had certain times), they'll tell 
12:45:05 <mahogny> the semantics are very unclear
12:45:18 <basti_> what are you trying to do with it then?
12:46:06 <mahogny> right now, the idle event is designed as to rerun as long as the handler returns True. but I need some way for it to be called the first time. maybe. it would be nice to know how to emit an event anyhow (I kind of need it for another project as well)
12:47:01 <basti_> hmmm
12:47:40 <mahogny> for this thing, I can prolly cheat and hope that the idle event is called sooner or later but that sounds bug prone as I know so little about the semantics
12:47:48 <Saulzar> Can you just call your handler directly? 
12:48:20 <mahogny> how do I know that wxhaskell will rerun the handler? I need to somehow get the attention of the GUI loop
12:48:50 <sethk> having a problem.  I'm doing fork/exec with System.Posix.Process.  Sometimes the exec happens, sometimes it doesn't.  On average I have to do three fork/exec for the exec to take place.  In the other cases the fork starts a new thread (i have the process ID from the return) but it never execs; it shows in ps as a thread of  the original process
12:49:29 <Saulzar> Well I mean something like (I've not used wxHaskell) ..  let foo = (handler code here);  onButtonPressed foo; foo -- call handler directly
12:50:11 <mahogny> Saulzar, that would stall the GUI. the idea with an idle event is that it is called only when the GUI is idle so that it can handle buttons etc in between
12:51:13 <Saulzar> So I assume foo is very slow? 
12:51:40 <mahogny> it will run at 100% CPU
12:51:44 <mahogny> continuously
12:54:11 <mahogny> sethk, that sounds bad and weird. I don't know how fork affects the ghc internals. but do you really need haskell for this? sounds like it is as good as made for C
12:54:33 <sethk> it's part of a huge program already written in haskell.  I may have to use ffi
12:54:43 <sethk> mahogny, but according to the docs it is supposed to work
12:55:02 <sethk> I think I just have to find a way to force the exec.
12:55:06 <mahogny> yeah. I can't tell what's wrong. how do you know that you need as much as 3 forks for it to work?
12:55:22 <sethk> I just repeat it until it works
12:55:41 <mahogny> it would take an earthquake for the corresponding C versions to fail and I assume GHC more or less just maps to those
12:55:45 <mahogny> so it sounds weird
12:56:00 <sethk> yes, it does.  and a stand alone test program doing the same thing works
12:56:11 <sethk> but that doesn't do me any good.  the real program has to work
12:56:29 <mahogny> sounds like a bug to me. try the mailing list
12:56:31 <Saulzar> What does the fragment in question look like?
12:56:32 <sethk> I need a way to make the exec call strict
12:56:43 <sethk> oh, it's a bug, but that doesn't matter.  I have to deliver working code today.
12:56:44 <Saulzar> Control.Exception.evaluate maybe?
12:56:57 <sethk> Saulzar, I thought of that, but it's not the right signature.
12:56:57 <mahogny> sethk, loop until it works?
12:57:16 <mahogny> sethk, anyhow, the sooner you mail the list, the sooner you might get to know a work-around
12:57:24 <mahogny> today if you are lucky
12:57:41 <sethk> mahogny, doesn't matter  I'll have a workaround today even if I have to use FFI.  And the guy who works on that code is out of town for a few days.
12:57:57 <sethk> Saulzar, maybe I can make evaluate work some how.
12:58:17 <mahogny> sethk, I have a feeling the FFI might mess it up even more
12:58:51 <sethk> mahogny, could, but as you said, the haskell calls should just map to the c calls
12:59:02 <Saulzar> sethk, Well, what kind of signature does it have? :)
12:59:17 <sethk> Saulzar, I'm looking at it again.
12:59:25 <mahogny> using these commands at least gives GHC a chance to react. calling fork/exec in FFI sounds like major bastardization if GHC is doing some process book keeping behind the scenes (which it might)
12:59:45 <sethk> mahogny, yes, that makes sense, but I may not have much of a choice
12:59:52 <mahogny> well. give it a shot
13:00:11 <sethk> Saulzar, evaluate might work.  I'm not sure why I thought it wouldn't.
13:00:45 <mahogny> sethk, but I'd recommend patching it up later if you take that route since it might backstab you later
13:00:46 <jameysharp> sethk: do I understand correctly that the fork always does as you expect? in that case exec should terminate the (forked) GHC runtime, so looping the exec call might make "sense", right? (insanity of having exec fail aside?)
13:01:06 <sethk> jameysharp, yes, it might.
13:01:07 <mahogny> jameysharp, fork can fail, but that's almost unheard of
13:01:18 <sethk> jameysharp, I've been repeating the fork/exec combination, which as you point out is not the same at all
13:01:49 <jameysharp> sethk: yeah, leaving all those children around seems bad and unnecessary.
13:02:06 <sethk> jameysharp, definitely, but as you note, repeating the exec is different
13:02:18 <sethk> if evaluate doesn't work, I'll try that next
13:02:20 <mahogny> sethk, does your app use threads or anything else that can confuse fork/exec?
13:02:29 <sethk> mahogny, yes, extensively
13:02:33 <mahogny> ouch
13:02:40 <sethk> mahogny, I actually had it almost working with System.Process
13:02:59 <sethk> everything worked correctly except the function that gets the process status/return code is totally broken
13:03:10 <sethk> so I'm trying Posix.Process, which is almost working but not quite
13:03:20 <mahogny> then it might not really be a bug in GHC; rather, you need to take better care about what the calls do. but I haven't played much with threads in C so I can't tell
13:03:54 <sethk> mahogny, I'm told the problem in System.Process is fixed in cvs, but the cvs version is not stable enough to use
13:04:08 <jameysharp> mahogny: POSIX threads shouldn't interfere with fork/exec as best I recall; but these are presumably GHC's userland threads, right?
13:04:14 <sethk> mahogny, so the System.Process part is a known ghc bug
13:04:27 <sethk> jameysharp, no, not if you use -threaded
13:04:43 <jameysharp> sethk: oh, I didn't know about that. :-) is that what you're doing?
13:04:54 <mahogny> sethk, how about patching the files from CVS that you need? dunno how much work that would be
13:05:05 <sethk> mahogny, might have to resort to that
13:05:19 <sethk> jameysharp, yes, other things don't work without the -threaded switch
13:06:12 <mahogny> jameysharp, ghc does both userland and real threads, depending on the switches. but you can force ghc to do real threads if you want to (sometimes needed)
13:06:15 <sethk> using evaluate complains that I'm applying   a -> IO a  to something that is already IO
13:06:36 <sethk> maybe I coded that incorrectly, let me try again
13:11:21 <sethk> jameysharp, repeating the exec worked, except for one tiny problem, it crashes the main program
13:11:29 <sethk> jameysharp, I'll try just repeating it once.
13:11:35 <jameysharp> sethk: bah, minor unimportant detail.
13:12:59 <sethk> jameysharp, this is weird, I end up with a copy of the original program still running.  maybe it will still work?  I doubt it.  :)
13:14:12 <jameysharp> sethk: I'm not sure I understand. fork should produce a copy of the original program, and if exec failed its caller will return, I guess... is that what you're seeing?
13:14:55 <sethk> jameysharp, I'm not sure.  fork produces a copy, but the copy destroys itself by running exec, the way it is usually done
13:15:03 <sethk> jameysharp, and I only did fork once 
13:15:10 <sethk> but, the exec does occur.
13:15:20 <morans> hi slang
13:15:29 <sethk> let me monkey around with it some more.  I think I might need an unsafeIO thing
13:15:37 <jameysharp> sethk: so you're left with three processes? two of the parent and one that you wanted?
13:15:51 <sethk> jameysharp, except that the parent (original) is dying on the second exec call
13:16:02 <sethk> but I'll take that out for a moment ...
13:16:07 <slang> morans: hi
13:16:24 <jameysharp> sethk: um, are you testing the return value of fork to make sure the exec happens only in the child?
13:16:47 <sethk> jameysharp, the docs don't call for that in the haskell version of the calls
13:17:02 <sethk> jameysharp, the exec is an argument and the magic is supposed to happen for you
13:17:13 <jameysharp> huh.
13:20:07 <sethk> jameysharp, fork does return the process ID of the child, and it is correct.  the problem is that the exec sometimes happens, and sometimes doesn't.
13:21:00 <sethk> jameysharp, when the exec doesn't happen, the child process shows as a thread of the parent.  (linux threading is brain dead and threads show up as process in the process table)
13:29:11 <sethk> I'm going back to the System.Process version.  I think I can work around it's problem by using waitForProcess in another thread, and catching the call interrupted exception.
13:33:53 <jameysharp> sethk: I don't know anything about Haskell's posix module, but I want to point out that threads haven't shown up in the process table in linux since NPTL replaced LinuxThreads. you are running a 2.6 kernel, aren't you?
13:34:16 <sethk> jameysharp, yes, but the threads certainly show up in the process table
13:34:28 <jameysharp> sethk: is your libc up-to-date?
13:34:34 <sethk> yes
13:34:48 <jameysharp> sethk: what distro are you running?
13:35:00 <sethk> Ubuntu, Fedora, and Slackware
13:35:29 <jameysharp> and you see threads as processes on all of them?
13:35:36 <sethk> yep
13:36:37 <morans> anyone got pointers to a more complex example of using GetOpt than the one thats in the haddock docs ?
13:37:20 <jameysharp> so when you run firefox, for example, you see a bunch of processes named firefox-bin? I sure don't, and it's not supposed to work that way any more. if you're still running LinuxThreads for some mystic reason I can believe things would break randomly.
13:37:37 <sethk> jameysharp, I haven't checked anything other than haskell threaded programs
13:38:27 <jameysharp> are GHC's "real" threads using the standard pthreads interface?
13:39:27 <jameysharp> sethk: (I think we can safely say that it's not linux's threads that are braindead at this point, anyway.)
13:39:28 <sethk> they are supposed to be, yes
13:39:46 <jameysharp> wacky.
13:40:26 <sethk> jameysharp, have to try the cvs version, see if it is different
13:43:28 <bolrod> data ParseError = Err {location::Int, reason::String}   << how does that work
13:43:33 <bolrod> what is 'location'  and 'reason'  
13:43:34 <bolrod> ?
13:44:31 <mauke> location :: ParseError -> Int
13:44:50 <mauke> they're field names
13:45:57 <bolrod> hrm...
13:50:43 <SyntaxNinja> w00t
13:52:07 <bolrod> w00t00t00t?
13:52:26 <jip> w00tage
13:52:39 <bolrod> MW00tage
13:52:58 <bolrod> ;o
13:55:02 <jip> @hoogle showHex
13:55:03 <lambdabot> Numeric.showHex :: Integral a => a -> ShowS
13:59:20 <Oejet> >showHex 245
13:59:36 <jip> > showHex 245
13:59:37 <lambdabot>  add an instance declaration for (Show (String -> String))
13:59:44 <jip> > showHex 245 ""
13:59:45 <lambdabot> "f5"
14:00:06 <Oejet> jip: Thanks. ;-)
14:01:14 <vincenz> re
14:02:53 <conal> does anyone use mmm-mode, mentioned on http://www.haskell.org/hawiki/LiterateProgramming,  for literate haskell programming?
14:04:47 <bolrod> hmm.. that kind of code really makes it easier to look at *Cough* *cough*
14:06:39 <SamB> isn't literate programming just a way to deal with the horror that is writing a large program in Pascal?
14:10:57 <jip> for IO code, what is better? return an error or throw an exception?
14:11:14 <bolrod> O_o?
14:11:20 <bolrod> aren't those connected :)
14:11:22 <bolrod> like... one throws
14:11:24 <bolrod> other catches
14:11:25 <bolrod> :P
14:11:36 <bolrod> or
14:11:48 <bolrod> isn't an exception a kind of error
14:11:48 <bolrod> hrm
14:12:13 <bolrod> maybe I"m confused..
14:13:18 <Oejet> You could look at it speed wise.  Exceptions are typically expensive to call, so if they are rare, it might be a good option.
14:13:18 <Lemmih> jip: It depends on the situation.
14:13:19 <jip> i mean like: IO (Maybe Result) without throwing an exception, or: IO Result and throw an exception if there is an error
14:14:07 <jip> Lemmih: what criteria does one use to decide?
14:14:48 <bolrod> throwing an exception is very usefull to stop with the monad you're in
14:15:02 <bolrod> (well.. not stop.. but don't execute the following things}
14:15:09 <Cale> I tend to think of throwing an exception as something to do when your program has a bug.
14:15:17 <bolrod> :P
14:15:33 <Cale> If you expect failure, returning a proper value seems better.
14:15:50 <bolrod> try in the ghci    sequence_ [putStrLn "one" , putStrLn "two" , fail "FAIL!" , putStrLn "three"]
14:15:50 <jip> Cale: in the C++/Java/Python world, it's not like that. exceptions are very common
14:16:22 <jip> Cale: but i guess in those languages you don't have a type system that can force callers to acknowledge the possibility of failure
14:16:24 <bolrod> jip: you might want to take a look at  throwDyn
14:16:26 <bolrod> and catchDyn
14:16:29 <bolrod> if you want that
14:17:02 <bolrod> with maybe its much harder to not evaluate the putStrLn "three"  I guess
14:18:17 <Oejet> bolrod: Might be wise, if the action has type ICBM -> IO ().
14:18:34 <conal__> *me timed out at the wifi cafe
14:18:44 <araujo> Hello
14:19:00 <bolrod> Oejet: its also quite clear if you se   throwDyn
14:19:05 <bolrod> you know something is wrong  ;)
14:19:12 <bolrod> instead of alot of Nothing  Maybe Just
14:19:14 <bolrod> bla bla
14:19:19 <bolrod> and checking for Nothing
14:29:38 <jip> @hoogle COff
14:29:39 <lambdabot> System.Posix.Types.COff :: data COff
14:29:49 <jip> > (1 :: COff)
14:29:50 <lambdabot>  Not in scope: type constructor or class `COff'
14:31:24 <bolrod> :t COff
14:31:27 <bolrod> -.-
14:31:37 <bolrod> @type COff
14:31:38 <lambdabot> Not in scope: data constructor `COff'
14:35:55 <jip> how come haskell had to choose /= instead of the standard != ?
14:37:37 <bolrod> because its different
14:37:54 <ski> '/=' looks somewhat more like the math '=' with a '/' through it
14:39:17 <bolrod> != sounds more like    HEY!! THIS IS!!!!
14:39:19 <bolrod> :x
14:39:25 <jip> yeah, but everyone knows what != means
14:39:31 <bolrod> ohyeah?
14:39:35 <jip> @hoogle when
14:39:36 <bolrod> ask your mother what != means
14:39:36 <lambdabot> Monad.when :: Monad a => Bool -> a () -> a ()
14:39:36 <lambdabot> Control.Monad.when :: Monad m => Bool -> m () -> m ()
14:39:37 <bolrod> ;/
14:39:38 <bolrod> ;p
14:39:58 * jip 's mother wouldn't know what /= means either
14:40:04 <bolrod> ok...
14:40:19 <jip> but if you ask 1000 programmers. most of them will figure out what != means but more then a few would scratch there heads at /=
14:41:03 <bolrod> yah  =/
14:41:07 <bolrod> ;)
14:41:19 <jip> @hoogle FileOffset
14:41:20 <lambdabot> System.Posix.Types.FileOffset :: type FileOffset
14:41:25 <bolrod> its the face of a programmer when he sees it ;)
14:41:48 <jip> how can i convert a FileOffset value to an Int? it seems that the only way is to show it and then read it
14:41:55 <JohnnyL> how do i turn trace on?
14:46:54 <morans> jip: its a COff which is an instance of Num. Not sure how to make it an int, but you can go the other way - convert an int into an offset, if you want to do comparisons or something like that
14:46:58 <morans> i think
14:48:21 <jip> morans: shouldn't fromIntegral work?
14:52:01 <bolrod> jip: I guess it would
14:52:12 <bolrod> if its an instance of Num it should at least
14:52:19 <morans> (fromIntegral (5 :: System.Posix.FileOffset) ) :: Int
14:52:21 <morans> works for me.
14:53:01 <morans> anyone build the md5sum from ox.ac.uk (or any other haskell md5sum or sha-xxx lib) recently?
14:53:01 <jip> hm.... yeah i guess it does seem to work :) thanks!
14:53:21 <Lemmih> JohnnyL: It can't be turned off.
14:55:10 <jip> @hoogle peek
14:55:11 <lambdabot> Foreign.Storable.peek :: Storable a => Ptr a -> IO a
14:55:11 <lambdabot> Foreign.Storable.peekByteOff :: Storable a => Ptr b -> Int -> IO a
14:55:11 <lambdabot> Foreign.Storable.peekElemOff :: Storable a => Ptr a -> Int -> IO a
14:57:00 <JohnnyL> does that mean that IO a is of type Storable?
14:58:34 <morans> it means that type 'a' must be Storable
14:58:41 <jip> i think it means that a must be Storable
14:58:48 <morans> so peek will return an IO <something>   where that something is Storable
14:59:00 <morans> doesn't say anything at all about whether IO a is storable or not.
14:59:05 <morans> though it likely isn't...
14:59:28 <jip> can i use valgrind on a haskell executable to check for memory leaks of my own haskell malloc calls?
15:01:12 <JohnnyL> there has to be a more effient Element offset collector then nThListEl (l:ls) 1 = l   nthListEl (l:ls) n = nthListEl ls (n-1) .. I mean it has to go through each element.. is there a way to go directly to that offset to collect the character?
15:01:56 <Lemmih> JohnnyL: You're looking for an array.
15:03:00 <JohnnyL> > nThlistEl "Johnny" 6
15:03:01 <lambdabot>  Not in scope: `nThlistEl'
15:04:20 <JohnnyL> @hoogle Array
15:04:22 <lambdabot> Array :: module
15:04:22 <lambdabot> Data.Array :: module
15:04:22 <lambdabot> Foreign.Marshal.Array :: module
15:05:01 <ski> @index Array
15:05:02 <lambdabot> Data.Array, Data.Array.IArray, Data.Array.Unboxed, Data.Array.Diff
15:05:19 <Lemmih> @seen dons 
15:05:20 <lambdabot> dons is in #haskell. I last heard dons speak 9 hours, 7 minutes and 34 seconds ago.
15:05:30 <JohnnyL> @seen Shapr
15:05:31 <lambdabot> Shapr is in #scannedinavian, #haskell and #ScannedInAvian. I last heard Shapr speak 5 hours, 6 minutes and 23 seconds ago.
15:06:40 <conal> @pl \ pathF hasF pathX hasX -> pathF (\ f -> pathX (\ x -> f x) hasX) hasF
15:06:41 <lambdabot> flip . (flip .) . (. flip) . (.)
15:06:53 <conal> wow
15:07:07 <JohnnyL> > zip "Johnny" "BeGood"
15:07:09 <lambdabot> [('J','B'),('o','e'),('h','G'),('n','o'),('n','o'),('y','d')]
15:07:18 <ski> @type \pathF hasF pathX hasX -> pathF (\ f -> pathX (\ x -> f x) hasX) hasF
15:07:20 <lambdabot> forall t
15:07:20 <lambdabot>                            t1
15:07:20 <lambdabot>                            t2
15:07:20 <lambdabot>                            t3
15:07:20 <lambdabot>                            t4
15:07:22 <lambdabot> [8 @more lines]
15:07:27 <ski> @more
15:07:28 <lambdabot>                            t5.
15:07:28 <lambdabot>                          (((t5 -> t4) -> t2)
15:07:28 <lambdabot>                          -> t
15:07:31 <lambdabot>                          -> t1)
15:07:32 <lambdabot>                          -> t
15:07:34 <lambdabot> [3 @more lines]
15:07:35 <ski> @more
15:07:38 <lambdabot>                          -> ((t5 -> t4) -> t3 -> t2)
15:07:40 <lambdabot>                          -> t3
15:07:42 <lambdabot>                          -> t1
15:07:48 * ski hates when it "prettyprints" like this
15:07:55 <conal> @pl \ pathF hasF pathX hasX -> pathX (\ x -> pathF (\ f -> f x) hasF) hasX
15:07:56 <lambdabot> (flip id .) . flip . (. flip id)
15:08:15 <conal> well, that's pretty!  :)
15:08:23 <vincenz> nearly symmetrical
15:10:27 <conal> and would be symmetrical/palindromic if "flip id" were given a name, eg. "#" for reverse application.
15:12:48 <JohnnyL> what exactly is that?
15:13:34 <jip> > showHex 195 ""
15:13:36 <lambdabot> "c3"
15:13:42 <JohnnyL> zipWith (+) [1,2,3,4,5] [6,7,8,9,10]
15:13:48 <JohnnyL> > zipWith (+) [1,2,3,4,5] [6,7,8,9,10]
15:13:50 <lambdabot> [7,9,11,13,15]
15:14:28 <conal> JohnnyL: "what exactly is that?"  Is that question to me?
15:14:34 <vincenz> > tails [1..4]
15:14:36 <lambdabot> [[1,2,3,4],[2,3,4],[3,4],[4],[]]
15:14:42 <jip> > (array (0, 1) [(0, 5), (1, 6)]) ! 0
15:14:43 <lambdabot> 5
15:14:52 <jip> > (array (0, 1) [(0, 5), (1, 6), (2, 7)]) ! 0
15:14:53 <lambdabot> Exception: Ix{Integer}.index: Index (2) out of range ((0,1))
15:15:08 <JohnnyL> conal, nope ski.
15:15:18 <conal> (thanks)
15:15:54 <JohnnyL> conal, ok, how about you. whats that u queried?
15:17:41 <JohnnyL> > foldr (++) "Johnny" 0
15:17:42 <lambdabot>  add an instance declaration for (Num [[Char]])
15:18:10 <conal> it's a sort of generalized function application, extracting function and argument from values.  from http://conal.net/papers/icfp06-submission, section 4.
15:19:30 <conal> I hadn't thought to run the definition through @pl before, in considering an arrow-ized generalization.
15:21:02 <jip> @hoogle Num -> Char
15:21:03 <lambdabot> No matches, try a more general search
15:21:21 <jip> @hoogle a -> Char
15:21:22 <lambdabot> No matches, try a more general search
15:21:24 <mauke> @hoogle chr
15:21:25 <lambdabot> Char.chr :: Int -> Char
15:21:25 <lambdabot> Text.PrettyPrint.HughesPJ.Chr :: Char -> TextDetails
15:21:25 <lambdabot> Text.Regex.matchRegex :: Regex -> String -> Maybe [String]
15:21:30 <jip> mauke: thanks :D
15:27:04 <JohnnyL> conal , looks like expert level work, impressive.
15:27:04 <conal> JohnnyL: who are you & what do you work on?
15:27:05 <JohnnyL> i am just teaching myself haskell, because I find that as a language it can go alot farther with less preparation and code context than say c or vb. At the present time i'm looking for part time programming work. I have no interest in building something someone won't use so i'm at a distress of sorts.
15:27:05 <conal> JohnnyL: thanks.  good luck with that!
15:27:13 <JohnnyL> @type foldr
15:27:15 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
15:27:20 <JohnnyL> thx.
15:32:58 <JohnnyL> @type zip
15:33:00 <lambdabot> forall b a. [a] -> [b] -> [(a, b)]
15:33:45 <JohnnyL> haskell is left to right?
15:33:55 <mauke> what?
15:33:56 <araujo> uh?
15:34:16 <JohnnyL> forall b a, the order of precedence is parsing.
15:35:01 <mauke> I don't understand
15:35:01 <RyanT5000> what's the standard way of doing exception-handling in haskell? for instance, if an index parameter is out-of-bounds
15:36:15 <JohnnyL> mauke, i am just wondering why the order of forall b a in the zip type definiton is in that order.
15:36:50 <RyanT5000> JohnnyL isn't that just arbitrary anyway?
15:37:41 <JohnnyL> dunno
15:38:10 <musasabi> RyanT5000: see Control.Exception that is the semi-standard way.
15:39:03 <RyanT5000> musasabi: is it considered good form? becuase some library stuff seems to just take the approach of not having any failure modes
15:39:12 <RyanT5000> like Map for instance
15:39:24 <ski> (conal : though '@pl' doesn't really know about arrow combinators)
15:39:28 <musasabi> Data.Map has failures.
15:39:55 <musasabi> @type Data.Map.lookup
15:39:57 <lambdabot> forall a (m :: * -> *) k.
15:39:57 <lambdabot>        (Ord k, Monad m) =>
15:39:57 <lambdabot>        k -> Data.Map.Map k a -> m a
15:40:12 <musasabi> It uses fail in the monad used.
15:40:34 <ski> (evil)
15:40:47 <jyp> why?
15:40:53 <jyp> why evil?
15:41:16 <RyanT5000> ah yeah but i'm referring to the nonmonadic functions
15:41:29 <ski> well, the bad is more or less that 'fail' is in 'Monad' .. and not, say, in a subclass of that
15:41:52 <ski> (jyp : 'fail' doesn't really belong there ..)
15:41:53 <jyp> ski: Oh yeah... Cale's crusade :)
15:42:12 <jyp> Which I think I agree with, btw. 
15:42:22 <ski> jyp : does he own it ?
15:42:59 <jyp> Own? Well, he's been fighting for a return to a cleaner state on the mailing lists.
15:43:55 <ski> ok
15:46:23 <RyanT5000> ok so lets say i have a function getThing :: Int -> Thing
15:46:36 <RyanT5000> where the Int needs to be, say, 0 through 9
15:47:24 <RyanT5000> if someone passes 10, should i throw an exception? or should I refactor the function so it is, for example, Int -> Maybe Thing
15:47:56 <RyanT5000> obviously i know this isn't something with a real answer
15:48:03 <jyp> If the situation is indeed exceptional, throw an exception.
15:48:14 <jyp> This is meant seriously.
15:48:21 <RyanT5000> alright, i know what you mean :)
15:48:29 <RyanT5000> thanks
15:48:44 <jip> i would say keep things simple and use error if a value not in range 0-9 is passed
15:48:54 <jyp> RyanT5000: Others might have another opinion though.
15:49:07 <RyanT5000> what do you mean "use error"?
15:49:16 <ski> if it's a program bug that a non-digit int is passed, then abort with an error, or throw an exception
15:49:16 <RyanT5000> an error return, like "Nothing"?
15:49:27 <jip> @type error
15:49:28 <lambdabot> forall a. [Char] -> a
15:49:34 <RyanT5000> ah ok
15:49:38 <ski> > 1 + error "Foo !"
15:49:39 <lambdabot> Exception: Foo !
15:49:43 <RyanT5000> i see
15:49:55 <ski> (ghc happens to implement errors with exceptions)
15:50:03 <jip> this way if there is a bug in your program and you accidently pass 10 to your function haskell will tell you when and where this happens
15:50:17 <RyanT5000> right
15:50:18 <jip> but it's a runtime error, not compile time
15:50:27 <RyanT5000> yeah, my situation has to be runtime anyway :(
15:50:34 <RyanT5000> i'm used to using exceptions all the time in C++
15:50:44 <RyanT5000> i just didn't know how they fit into the scheme of things in functional languages
15:52:14 <jyp> Another possibility is to constrain your input by typing
15:52:14 <jyp> You might also be interested in an article by Ralf Hinze et al. on contracts.
15:52:15 <jyp> http://www.informatik.uni-bonn.de/~loeh/Contract.pdf
15:52:15 <jip> yeah, this stuff can be very interesting. but for simple and practical programs that you want to write today, error isn't too bad :)
15:52:19 <jyp> Indeed :)
15:52:24 <RyanT5000> We recommend either hiding the Prelude version of catch when importing Control.Exception, or ...
15:52:26 <jyp> Well, I
15:52:35 <RyanT5000> how is that done?
15:56:58 <jyp> 'm guilty of giving advices to others the advices I need to receive.
15:56:58 <RyanT5001> ... nick in use?
16:12:25 <JohnnyL> can someone explain to me how (a->a->a) is interpreted in from zipWith?
16:12:29 <JohnnyL> @type zipwith
16:12:37 <lambdabot> Not in scope: `zipwith'
16:12:38 <JohnnyL> @type zipWith
16:12:39 <lambdabot> forall c b a. (a -> b -> c) -> [a] -> [b] -> [c]
16:12:56 <JohnnyL> or for that matter (a->b->c)
16:13:07 <jip> zipWith f la lb
16:13:34 <jip> f is a function that takes an "a" and "b" value and "joins" them into a "c" value
16:14:10 <jip> > zipWith (+) [1, 2, 3] [4, 5, 6]
16:14:11 <lambdabot> [5,7,9]
16:14:25 <JohnnyL> ok, i think i see now.
16:16:44 <JohnnyL> isn't the 'forall c b a a bit unneeded?
16:17:20 <jip> i'm not sure, but i think the forall part might have something to do with existential types
16:18:03 <ski> no, not here
16:18:46 * ski thinks it would be better if ghc skipped top-level 'forall's in types
16:27:00 <JohnnyL> my beef with haskell is that it doesn't allow youi to list the function within the interpreter.
16:28:16 <jip> :browse <module>
16:28:29 <jip> oh you mean the source
16:29:02 <wobster> hi everyone. I tried to write a function that puts every character at the beginning of a sentence toUpper (yes, 'homework'). I just don't seem to get the definition right. Please have a look at this http://cpp.sourceforge.net/?show=14785. x:s not correct for Strings?
16:32:05 <ski> JohnnyL : are you using hugs or ghc ?
16:32:22 <JohnnyL> ski, at the moment ghci.
16:32:34 <JohnnyL> wobster, your types are off.
16:32:57 <wobster> JohnnyL: 'off' like I have to load some module?
16:32:58 <JohnnyL> cc(s,1) is a tuple.
16:33:21 <ski> ok, then : ghci is an interactive toplevel (that is not the same concept as interpreter)
16:33:47 <JohnnyL> ski, can hugs do it? never heard of interactive toplevel before.
16:34:01 <JohnnyL> wobster, take a closer look at the error.
16:34:29 <ski> JohnnyL : interactive toplevel means that you can interactively try things out .. opposite would be 'batch' i guess
16:35:04 <wobster> JohnnyL: I don't understand it. that's why I'm asking here. a little hint please. 
16:36:39 <ski> JohnnyL : there are both compilers with interactive toplevels (such as ghci), batch compilers (ghc, gcc), interpreters with interactive toplevels (hugs) .... and i'd not be surprised if there exists batch (-only) interpreters, though i can't recall one, rn
16:37:28 <mwc> ski, something like runhugs sort of counts
16:37:33 <ski> JohnnyL : so the 'compiler' vs. 'interpreter' dichotomy is a different dichotomy than the 'batch' vs. 'interactive toplevel' one
16:37:42 <mwc> yep
16:38:15 <ski> mwc : indeed  (but not as 'batch-only' (and i wasn't just wondering about haskell implementations))
16:40:04 <basti_> i don't think there would be any difference between an interactive and a batch interpreter
16:40:14 <ski> wobster : itym 'cc :: (String,Int) -> String', instead of 'cc :: (String -> Int) -> String'
16:40:43 <wobster> doh
16:41:12 <ski> basti_ : surely the first would often allow meta-commands (like ':load' etc), while the latter didn't ?
16:41:18 <wobster> ski: thank you. I should better go to sleep now
16:41:40 <ski> wobster : also '[x] ++ s' can be shorter written as 'x:s'
16:41:57 <ski> (just like in the pattern to the left of the equals sign)
16:42:08 <basti_> ski: hmmmm
16:42:16 <wobster> ski: yes there is certainly a lot to do better. I touched haskell an hour ago for the first time .. 
16:42:35 <basti_> ski: i'd think statements like "include", "import" etc. would be equivalent to "load" in an interpreter
16:43:16 <ski> basti_ : maybe .. *if* the language supports such ..
16:43:23 * basti_ nods
16:45:51 <ski> wobster : i'd move the 'z ==' tests into pattern-matching on the LHS sides of the equations/clauses defining 'cc' (prolly also moving the if-test into pattern-matching, so that you get 4 equations/clauses, instead of 2)
16:47:55 <wobster> ski: I thought the 'state-machine' would be a bit clearer that way. I will see .. tomorrow. thanks until here.
16:48:22 <ski> yw
16:48:58 <jip> hello Philippa 
16:49:12 <Philippa> evenin'
16:50:00 <jip> Philippa: is it true that GADT is slower then regular algebraic data types?
16:51:17 <edwinb> Slower? It seems unlikely, at run-time at least...
16:51:44 <Philippa> I've not thought about the implementation much - my gut instinct is no, but type variables that aren't parameters of the type constructor might cause boxing that wouldn't be necessary otherwise
17:02:29 <Philippa> (extra polymorphism = less opportunity to unbox = potential loss of speed, is the general rule)
17:03:50 <jip> Philippa: did you see the code i pasted? what do you think? i solved the problem of being able to have a "black-box" memory state
17:05:40 <Philippa> didn't see the code AFAIK
17:05:52 <Philippa> I'm also planning on bed soon, but feel free to show me
17:07:22 <jip> http://rafb.net/paste/results/hfZzTG56.html
17:07:43 <jip> the good stuff is at the very top and very bottom
17:10:45 <Philippa> looks good
17:11:15 <JohnnyL> thats what lisp has that haskell doesn't.
17:11:38 <jip> Philippa: i like how the executeInstruction is totally isolated from the details of the "Machine"
17:12:43 <Philippa> JohnnyL: eh? Have I missed some context?
17:14:30 <jip> Philippa: the good news is that i now understand monads a little bit better :D and also GADT!
17:15:08 <Philippa> yeah. GADTs're actually really simple, it's just you tend to see them mixed in with a load of other features
17:21:00 <JohnnyL> Philippa, yeah i was talking about inspecting functions through the interpreter.
17:22:19 <Cale> JohnnyL: why not just use your editor to inspect them?
17:23:29 <JohnnyL> > map (const 1)
17:23:31 <lambdabot>  add an instance declaration for (Show ([a1] -> [a]))
17:24:01 <Cale> It would be quite expensive if every function had a pointer to a source code string, and sometimes, it would be sort of tricky to work out exactly what should be printed.
17:24:11 <JohnnyL> Cale, i like the freeform space of interfaction without having to switch back and forth.
17:24:32 <Cale> Well, you can't really write code in ghci or hugs
17:24:38 <Cale> they're more like debuggers
17:24:39 <JohnnyL> Cale, what's it look like in memory otherwise?
17:24:59 <JohnnyL> @seen cale
17:24:59 <Cale> Usually it looks like a bunch of machine code
17:25:00 <lambdabot> cale is in #haskell. I last heard cale speak 21 seconds ago.
17:25:01 <Philippa> compiled bytecode, compiled machine code
17:25:44 <JohnnyL> the only deterriment would be a function turning bytecode into source, no?
17:26:08 <Philippa> there's no such function
17:26:13 <Philippa> it's a one-to-many mapping
17:26:13 <Cale> Turning it into assembly wouldn't be so hard, turning it into reasonable Haskell code would be impossible :)
17:26:22 <JohnnyL> > let f= sum . map (const 1)
17:26:24 <lambdabot>  parse error on input `}'
17:26:41 <JohnnyL> > let  f = sum . map (const 1)
17:26:42 <lambdabot>  parse error on input `}'
17:26:49 <resiak> let f = that in what?
17:27:06 <JohnnyL> resiak, i'm following 'Haskell Tutorial' examples.
17:27:14 <Cale> > let f = sum . map (const 1) in f "Hello"
17:27:16 <lambdabot> 5
17:27:48 <Philippa> JohnnyL: you're also assuming lambdabot is equivalent to ghci or hugs. It's not
17:28:16 <JohnnyL> > f
17:28:17 <lambdabot>  Not in scope: `f'
17:28:22 <Cale> Well, it's sort of like ghc :)
17:28:25 <Philippa> haskell isn't designed as an 'interactive' language, ghci just interprets everything as if inside an outermost do statement (give or take)
17:28:25 <JohnnyL> > f "Hiya"
17:28:27 <lambdabot>  Not in scope: `f'
17:28:40 <Philippa> Cale: duh :-) It's still not identical to ghci though
17:28:49 <Cale> Right
17:28:57 <Cale> For one, it keeps no state :)
17:28:58 <Philippa> JohnnyL: Lambdabot is not an interactive session
17:29:08 <Philippa> it does one-off evaluation
17:30:05 <Cale> It doesn't really make much sense in Haskell to read in a program interactively
17:30:19 <Cale> Definitions can depend on later definitions
17:30:34 <Philippa> exactly. GHCi's a convenient kludge :-)
17:31:16 <Cale> For example, if I was to write a function which used a type which I hadn't declared yet, what it was bound to would be pretty problematic.
17:31:23 * JohnnyL has been spoiled by lisp. :)
17:31:28 <Cale> f x = Floom x
17:31:40 <Cale> data F a = Floom a
17:31:54 <Cale> that's a valid Haskell program
17:32:07 <Cale> (in that order)
17:32:26 <Cale> but if it was interactively interpreted, f wouldn't make sense until F was read in.
17:33:37 <Cale> You can also have mutually recursive functions
17:34:13 <Cale> evens = 0 : map (+1) odds
17:34:19 <Cale> odds = map (+1) evens
17:35:23 <Cale> (or in this case, mutually recursive lists)
17:36:52 <Cale> In lisp, function/variable binding is an imperative assignment sort of thing, whereas there is no sense of 'time' at the Haskell toplevel.
17:37:32 <JohnnyL> what else is there besides "toplevel?"
17:37:54 <Philippa> let statements, a few other binding constructs
17:38:14 <Philippa> have a text editor and a source file. It's not as painful as it might seem
17:38:40 <Philippa> loading new code in's only a :r away
17:38:43 <i|> import Paths_haddock -- what's this, and where?
17:39:05 <Cale> do-blocks usually induce a sort of time-oriented thinking -- though strictly speaking they're declarative too
17:39:40 <Cale> > do x <- [1,2,3]; y <- [4,5,6]; return (x,y)
17:39:42 <lambdabot> [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
17:40:17 <jip> Cale: i'm making a gameboy emulator in haskell :D
17:40:37 <Cale> cool :)
17:41:35 <palomer> very cool
17:41:46 <palomer> ugh, I have to implement my algorithm sometime soon
17:41:47 <jip> it's all pure, no IO. and i'm using all this crazy GADT shit and monads
17:41:55 <Cale> :)
17:42:05 <i|> Heh...
17:42:13 <i|> What's wrong with GADT's, though?
17:42:17 <JohnnyL> alot of idlers in here.
17:42:58 <palomer> what's wrong with haskell GADTs?
17:43:03 <i|> Yeah. Did someone somehow send the NAMES list to everyone in this channel? ;-)
17:43:05 <palomer> I just did a presentation on that wendnesday, actually
17:43:39 <palomer> my biggest beef with haskell GADTs is a flagrant lack of principle types
17:43:46 <palomer> but that's just skimming the surface
17:43:54 <i|> A what of whats?
17:44:08 <palomer> rather, principle typings
17:44:11 <jip> Cale: you once said that you think haskell would be fast enough for a gameboy emulator... but i'm not so sure the way i'm doing it will be fast enough :(
17:44:18 <palomer> i|: certain functions do not have a principle type
17:44:31 <Philippa> H-M doesn't have them either, so you can hardly complain about GADTs not having them when implemented on top of it
17:44:31 <i|> What's a principle type?
17:44:36 <i|> Oh, right.
17:44:42 <i|> Like \x -> x x
17:45:06 <palomer> no
17:45:10 <i|> No?
17:45:19 <palomer> the principle type  of a term subsumes all ethor types that term may have
17:45:32 <palomer> so \x -> x can have type Int -> Int, Bool -> Bool, ..
17:45:43 <palomer> but all those are subsumed by a -> a
17:46:00 <Philippa> but not with the rank-n extension
17:46:14 <i|> But any type of \x -> x x can be made more general.
17:46:17 <palomer> are there principle typings with rank n extensions?
17:46:26 <palomer> i|: try to find a type for that term
17:46:35 <Philippa> there aren't principle /typings/ for plain H-M
17:46:42 <palomer> hmm?
17:46:50 <i|> \x -> x x :: (forall a. a -> a) -> a -> a
17:46:51 <Philippa> types, yes. Typings, no.
17:47:03 <palomer> what's the difference?
17:47:03 <i|> Right?
17:47:13 <Philippa> typing ~= "type derivation"
17:47:21 <jip> Word8 + Word8... how do i tell if there was a carry from bit 3?
17:47:32 <i|> Word3? :-)
17:47:36 <palomer> ahh, righto
17:47:41 <Philippa> i|: no, you're using a outside the forall's scope
17:47:53 <palomer> so yeah, replace the word typing with type
17:47:55 <i|> (forall a. a -> a) -> b -> b?
17:48:04 <Philippa> there aren't principle types with the rank-n extension for reasons of predicativity
17:48:09 <palomer> so do rank-n extensions have principle types?
17:48:14 <palomer> ah, gotcha
17:48:33 <palomer> what do you mean "reasons of predicativity" ?
17:48:33 <Philippa> don't ask me about boxy types :-)
17:48:43 <Philippa> you can't instantiate a type variable with a polytype
17:48:55 <Philippa> so you can't use id on something with a sufficiently polymorphic type
17:49:04 <palomer> what if you could?
17:49:17 <Philippa> like I said, don't ask me about boxy types :-)
17:49:26 <palomer> >:O
17:49:42 <palomer> does HM + type classes have principle types?
17:50:07 <Philippa> AFAIK, yes. But I could be wrong. IANA sufficiently smart type theorist :-)
17:50:28 <palomer> IANA?
17:50:35 <Philippa> I Am Not A
17:50:49 <palomer> hrmph, that's another tough question
17:50:54 <Philippa> (IANAL = I Am Not A Lawyer - common disclaimer seen around what might otherwise be legal advice)
17:51:39 <Cale> Internet Assigned Numbers Authority :)
17:51:42 <palomer> anyways, haskell GADTs were not well enough thought about
17:52:39 <Philippa> Cale: just don't get a space in IANAL by accident, someone might misunderstand :-)
17:52:59 <Cale> hehe
17:53:00 <i|> What should GADT's do that they don't now?
17:53:03 <Philippa> palomer: most extensions to haskell destroy the inference of principle types
17:54:24 <Philippa> the interesting question's whether or not principle types exist for all typeable terms (oh okay, and whether you still get the inference right for an interesting subset, eg all terms you were previously inferring types for)
17:56:50 <palomer> Philippa: isn't that the same question as "is everything principally typed" ?
17:57:23 <Philippa> no. It's conceivable that there might be two types for a term, neither of which subsumes the other
17:57:54 <palomer> well then principle types don't exist for every typeable term
17:58:20 <Philippa> yes, that's the question I put :-)
17:58:40 <Philippa> "is everything principally typed?" means "does everything get assigned a principal type?"
17:58:41 <palomer> but that's the question we've been discussing!
17:59:14 <Philippa> an inference algorithm might assign a more specific type instead
17:59:25 <Philippa> does it exist vs do we find it
17:59:44 <palomer> well, yes, I never mentioned inference
18:00:00 <palomer> that's another problem with haskell GADTs
18:00:08 <Philippa> it's the property more commonly discussed under that heading though
18:00:10 <palomer> inference is incomplete
18:00:23 <Cale> It can't be complete
18:00:27 <palomer> which is more commonly discussed?
18:00:34 <palomer> Cale: sure it can, change your system
18:00:34 <Philippa> inference for many sufficiently interesting extensions to H-M is incomplete...
18:00:43 <Philippa> yeah, cut out the polymorphic recursion
18:00:45 <Cale> palomer: well, you'd have something weaker
18:00:51 <Philippa> oh, and most of the useful use cases in the process
18:01:00 <palomer> sure ,you'd throw out some confusing programs
18:01:12 <Philippa> you'd throw out every sensible GADT example I've seen
18:01:23 <palomer> GADT type inference without polymorphic recursion _is_ decidable
18:01:44 <palomer> and, if you change the GADT system it even becomes feasible, and you'd only be throwing out confusing programs
18:01:49 <palomer> (that's my thesis::P)
18:01:55 <Philippa> and it's wrong
18:02:02 <palomer> what's wrong?
18:02:10 <Philippa> polymorphic recursion on its own causes the problem, you understand
18:02:23 <palomer> Philippa: I said _without_ polymorphic recursion
18:02:27 <Philippa> but there're some exceedingly understandable polymorphically recursive programs using GADTs
18:02:38 <Philippa> "and you'd only be throwing out confusing programs"
18:02:43 <Philippa> that part's wrong
18:02:59 <palomer> ah, I was referring to changing the GADT system which does not include polymorphic recursion
18:03:07 <Philippa> trust the users on this, the users are telling you GADTs without polymorphic recursion aren't half as useful
18:03:18 <palomer> you can assume that we're dealing with a type system where polymorphically recursive fixpoint terms are annotated
18:03:27 <palomer> forget polymorphic recursion
18:03:47 <Philippa> so we're back to the existing compromise? You're not being very clear
18:04:00 <palomer> take HM
18:04:01 <palomer> add GADTs
18:04:03 <palomer> nothing more
18:04:14 <Philippa> and you get no polymorphic recursion. No thanks
18:04:15 <palomer> type inference is decidable, but principle types don't exist
18:04:21 <Philippa> OK, with you now
18:04:29 <palomer> look at that subset under haskell
18:04:40 <palomer> type inference is not complete and principle types don't exist
18:04:53 <palomer> for some terms
18:04:54 <Philippa> also not particularly concerned by it currently, unless you can show some good examples that should concern me?
18:05:11 <palomer> also, the error messages are really confusing
18:05:32 <Philippa> can learn to cope with that, though I'd like a typing dump sometimes
18:05:55 <palomer> however, if you tweak the GADT system a little you get back principle types AND complete feasible type inference
18:06:42 <Philippa> OK. What're the tweaks?
18:06:49 <palomer> can't reveal it just yet:OP
18:06:53 <palomer> soon, soon
18:06:57 <palomer> still have to work out type inference
18:08:08 <palomer> well, im off!
18:16:27 <sethk> jameysharp, still here?  Discovered something interesting about glib/haskell/linux threads
18:28:27 <jip> > shiftL (1::Word8) 1
18:28:29 <lambdabot> 2
18:31:52 <i|> @google "you feel vaguely nervous"
18:31:57 <lambdabot> http://www.geocities.com/dcorbett42/nethack/monspell.htm
18:38:00 <jip> > shiftR (0::Word8) 1
18:38:01 <lambdabot> 0
18:38:04 <jip> > shiftR (1::Word8) 1
18:38:06 <lambdabot> 0
18:38:08 <jip> > shiftR (2::Word8) 1
18:38:10 <lambdabot> 1
19:08:10 <int80_h> woo I just got the mail happs .8 is out!
19:08:59 <int80_h> bye guys :)
19:16:24 <iambap> Yay for haskell!
19:21:57 <jip> indeed
19:22:51 <iambap> lol
19:59:07 <jip> how do i make my own type class?
19:59:16 <palomer> very carefully
19:59:25 <Lemmih> class ClassName where ...
19:59:57 <palomer> isn't it class className a where ...
20:00:43 <RyanT5001> is there any particular reason you can't have a parameterless class? i mean aside from the fact that it would be exactly the same as defining the same functions at the toplevel
20:01:06 <RyanT5001> we could make haskell like java! everything must be in a class!
20:06:54 <jip> type A = (Int, Int)
20:07:01 <jip> can i make this an instance of a typeclass?
20:13:41 <Lemmih> You can't. Try 'newtype A = A (Int,Int)' instead.
20:14:24 <cpatrick_> Is there any difference between `newtype A = A (Int, Int)` and `data A = A (Int, Int)`?
20:16:59 <int-e> cpatrick: yes. in the data A case, A undefined  and  undefined  are different things; for newtype they are equal. newtype is really a type alias (but with different class dictionaries) on the implementation level.
20:17:55 <cpatrick> int-e: ahh, rightio, thanks. That kind of thing was never explained in the stuff I read it
20:36:23 <RyanT5001> how come you can't use types to create class instances?
20:36:31 <RyanT5001> i mean, if it's just a type alias
20:36:50 <RyanT5001> couldn't it practically do a lexical replacement, then make that the class instance?
20:36:50 <jip> Lemmih: it actually seems to work though
20:37:10 <RyanT5001> i mean then (Int, Int) should also be an instance
20:37:14 <RyanT5001> but that's perfectly legal
20:45:05 <Ashsong> Hey folks.  I have a Parsec question.
20:45:18 <morans> ...
20:45:21 <Ashsong> I've defined a bunch of reserved names for my language.
20:45:56 <Ashsong> The identifier parser that I create with makeTokenParser is only rejecting about half of them.
20:46:14 <Ashsong> This seems thoroughly bizarre.
20:48:54 <Ashsong> Silly firewall.
20:49:12 <Ashsong> Anyway - do you have any thoughts on what might be going on?  
20:49:38 <Ashsong> (The code describing the problem is quite short, if anyone wants to see it)
20:50:36 <hircules> heh :=)
20:54:55 <hircules> 昼
20:55:16 <RyanT5001> hm, closures don't really exist in haskell, do they
20:55:34 <RyanT5001> i mean, what's the point of a closure if you can't modify the enclosed value
20:55:43 <RyanT5001> it's just a pair of curried functions, that happen to be curried with the same value
20:55:58 <Cale> closures exist all over the place
20:56:05 <RyanT5001> ?
20:56:27 <RyanT5001> i guess my definition of "closure" isn't spot-on
20:56:34 <Cale> you're right that you can't modify the value, of course -- that would be like un-applying a function
20:56:50 <RyanT5001> yeah
20:57:09 <Cale> I can write f x = \y -> x + y
20:58:01 <Cale> (or mostly equivalently, f x y = x + y)
20:58:13 <RyanT5001> hm
20:58:43 <RyanT5001> i guess i've just never really hear anyone talk about closures except as a way of encapsulating an object
20:58:48 <Cale> and applying f to say, 5, results in a piece of data which is most commonly implemented as a closure
20:59:10 <RyanT5001> ah
20:59:22 <Cale> closures are really more an implementation mechanism than a language construct
20:59:47 <RyanT5001> yeah, but, e.g., in lisp you see stuff like a function that returns two functions, a setter and a getter
21:00:07 <Cale> Well, you can sort of do that here too
21:00:36 <Cale> (though to maintain a mutable cell, you'll want to be in some monad which supports them)
21:00:39 <RyanT5001> if you encapsulate an IORef or something?
21:00:41 <RyanT5001> yeah
21:00:55 <RyanT5001> if you think about it, really settable/gettable things arent' real
21:01:03 <RyanT5001> they're just pointers rather than values
21:01:10 <RyanT5001> you still can't change the pointer
21:02:07 <Cale> though quite often, immutable things are pointers too :)
21:02:21 <RyanT5001> true :)
21:03:01 <RyanT5001> lazy evaluation rocks
21:03:07 <RyanT5001> i still haven't absorbed it
21:03:31 <RyanT5001> i was thinking about making multiple taps off an arrow graph, so that you don't have to evaluate the whole thing just to get one result
21:03:44 <Cale> a nice example is that  xs ++ ys, if the result is fully evaluated, (++) takes O(length xs) time.
21:04:11 <RyanT5001> then i realized (about 4 hours later) that returning a lazy tuple with all possible results is equivalent
21:04:39 <Cale> Lists are a great way to get nondeterminism
21:05:01 <RyanT5001> nondeterminism in what sense? order of evaluation?
21:05:40 <Cale> In the sense of functions which may return 0 or more results
21:05:59 <Cale> (like in Prolog)
21:06:47 <RyanT5001> "may", depending on what?
21:06:54 <Cale> depending on their input
21:06:55 <RyanT5001> like if you evaluate it one way it doesn't halt?
21:07:02 <RyanT5001> oh
21:07:29 <Cale> do x <- [1..20]; y <- [x..20]; z <- [y..20]; guard (x^2 + y^2 == z^2); return (x,y,z)
21:07:31 <Cale> > do x <- [1..20]; y <- [x..20]; z <- [y..20]; guard (x^2 + y^2 == z^2); return (x,y,z)
21:07:33 <lambdabot> [(3,4,5),(5,12,13),(6,8,10),(8,15,17),(9,12,15),(12,16,20)]
21:07:50 <Cale> It's the same as a list comprehension, of course :)
21:08:40 <Cale> > [1..20] >>= \x -> [x..20] >>= \y -> [y..20] >>= \z -> guard (x^2 + y^2 == z^2) >> return (x,y,z)
21:08:42 <lambdabot> [(3,4,5),(5,12,13),(6,8,10),(8,15,17),(9,12,15),(12,16,20)]
21:08:50 <Cale> that's how it desugars
21:09:32 <Cale> you can think of x <- [1..20] as binding x to one of the values in [1..20] nondeterministically
21:09:42 <Cale> as in, it takes all possible values in that list
21:09:47 <RyanT5001> hm
21:10:13 <RyanT5001> i'm still trying to figure out what that code does; i haven't used, or really seen used, the list monad
21:10:44 <RyanT5001> you're finding pythagorean triples
21:10:53 <RyanT5001> that much i've figured out :P
21:12:00 <Cale> > [(x,y,z) | x <- [1..20], y <- [x..20], z <- [y..20], x^2 + y^2 == z^2]
21:12:01 <RyanT5001> i think you should s/do x/do n <- [1..]; x/   s/\^2/\^n/
21:12:02 <lambdabot> [(3,4,5),(5,12,13),(6,8,10),(8,15,17),(9,12,15),(12,16,20)]
21:12:35 <RyanT5001> that's my lame attempt at suggesting you solve fermat's last theorem
21:12:45 <RyanT5001> :P
21:14:08 <Cale> guard p  in this context is the same as  if p then [()] else []
21:14:18 <Cale> it's a little more general than that actually
21:14:30 <Cale> guard p = if p then return () else mzero
21:14:35 <RyanT5001> ah ok
21:14:46 <RyanT5001> so it's sort of like an assert
21:14:51 <RyanT5001> >
21:14:52 <RyanT5001> ?
21:15:02 <RyanT5001> oh huh not quite
21:15:31 <Cale> If the condition fails, it returns the empty list, which essentially forces that branch of the computation to be skipped
21:15:46 <RyanT5001> yeah
21:15:48 <Cale> x >>= f  is the same as  concat (map f x)
21:16:06 <Cale> and if x is empty, then the result is automatically empty :)
21:16:21 <palomer> x >>= f is pretty
21:16:32 <palomer> you can visualize the values of the lists going into f
21:16:48 <Cale> > [1,2,3] >>= (\x -> [x, x+10])
21:16:50 <lambdabot> [1,11,2,12,3,13]
21:17:08 <RyanT5001> i can't say i totally understand why the concat is in there
21:17:27 <RyanT5001> i guess it's just to get rid of the extra layer of monad (list) around the result?
21:17:31 <Cale> right
21:17:44 <Cale> in general,  x >>= f = join (fmap f x)
21:17:56 <Cale> join :: (Monad m) => m (m a) -> m a
21:18:11 <RyanT5001> yeah
21:18:18 <palomer> my prof says that monads is the wrong abstraction, everyone should use modal types
21:18:20 <palomer> I think she's nuts
21:18:49 <RyanT5001> modal types?
21:19:01 <palomer> yes
21:19:10 <palomer> box(A) means A is always valid 
21:19:24 <palomer> diamond(A) means A could be possibly valid
21:19:32 <Cale> haha
21:19:39 <RyanT5001> wtf?
21:19:55 <palomer> or, rather, "A is valid in some context"
21:20:01 <RyanT5001> isn't a monad a state machine with actions in it, that has a null action?
21:20:05 <Cale> It's just like modal logic
21:20:16 <RyanT5001> how else do you represent state?
21:20:18 <palomer> yeah, it is modal logic
21:20:19 <Cale> RyanT5001: not really
21:20:29 <Cale> That's sort of like a state monad, I suppose
21:20:54 <palomer> get this: she's a type theorist, yet she apparently knows nothing of monads and haskell
21:21:04 <RyanT5000> wtf?
21:21:17 <Korollary> how could she not have heard of haskell
21:21:20 <Cale> RyanT5000: have you read MonadsAsContainers?
21:21:25 <palomer> she's heard of it, just never used it
21:21:28 <RyanT5000> nope, cale
21:21:32 <Cale> (and/or have I pointed you at it?)
21:21:43 <Cale> @oldwiki MonadsAsContainers
21:21:43 <RyanT5000> (nope)
21:21:45 <lambdabot> http://www.haskell.org/hawiki/MonadsAsContainers
21:22:03 <Cale> hmm, I wonder if it's been transplanted
21:22:05 <Cale> @wiki MonadsAsContainers
21:22:06 <lambdabot> http://www.haskell.org/haskellwiki/MonadsAsContainers
21:22:25 <Cale> nope, I should probably do that
21:23:03 <Cale> (the first link works fine though)
21:23:57 <RyanT5000> the first one works
21:27:32 <palomer> out of all the tutorials, that ane has shed the most light on monads
21:28:12 <palomer> monads should be learned by example, like "monads for stateful computation" or "monads for nondeterministic computation" ....
21:28:18 <palomer> then, a pattern emerges!
21:28:48 <Cale> yeah, ultimately, that's the way to do it
21:29:20 <Cale> I just found that starting with the container-like examples seems the easiest way to get a foothold
21:29:37 <palomer> yeah
21:29:58 <RyanT5000> yeah, it is
21:30:34 <RyanT5000> but it's also easy to see how the contract "if i have an infinite box of apples, and you'll give me a possibly-different apple if i give you an apple" maps onto an infinite-state machine like IO
21:30:44 <RyanT5000> an apple is a state
21:31:08 <Cale> not a state, so much as a result
21:31:37 <palomer> I couldn't extract meaning from that statement
21:31:55 <RyanT5000> hm?
21:31:59 <palomer> hm!
21:32:01 <RyanT5000> alright well nevermind then :P
21:32:05 <Cale> hehe
21:32:29 <Cale> The states are part of the container, more than the apples :)
21:32:38 <RyanT5000> yeah
21:33:31 <palomer> I think the moral of the story is Monad m => m a can mean "m computes a value of type a" or "m contains a value of type a"
21:33:40 <palomer> thus computing and containing can be synonyms
21:33:48 <palomer> s/a value/values
21:34:24 <RyanT5000> well that makes sense, in the same way that a function of zero arguments is equivalent to a value
21:38:57 <ski> palomer : hm, yes monads seem related to 'possibly' in some variant of modal logic
21:41:24 <sethk> I'm getting a message that Distribution.Compat.FilePath is hidden.  But I've used it before, in another file, without this problem
21:41:28 <sethk> does that make any sense?
21:42:41 <sethk> damn, on this machine I get the same result with the other file
21:42:47 <sethk> how to I "unhide" it?
21:44:58 <sethk> did I modify the library source and forget that I did it?
21:45:47 <sethk> anybody know how this magic works?
21:46:43 <RyanT5000> well since no one who knows what they're talking about is answering, i'll say what i think it should be like: a compiler flag that says "let me import stuff even if it's hidden"
21:47:10 <RyanT5000> not that i would ever advise using such a flag, since it totally breaks encapsulation and stuff
21:47:10 <sethk> RyanT5000, that's sensible, but i'm using the same flags on both machines, one works, and the other doesn't
21:47:17 <RyanT5000> hm
21:47:37 <RyanT5000> ghc-pkg describe <packagename>
21:47:44 <RyanT5000> that's where it tellls you what's hidden
21:47:50 <RyanT5000> maybe you have different library configurations?
21:47:58 <sethk> I must have something different, yes
21:48:06 <sethk> let me try that ghc-pkg thing
21:48:40 <sethk> that just says that it can't find it
21:48:43 <astecp> that MonadsAsContainers article is good
21:49:02 <RyanT5000> can't find ghc-pkg?
21:49:09 <RyanT5000> what's the package name?
21:49:13 <sethk> no, ghc-pkg can't find the package
21:49:24 <sethk> Distribution.Compat.FilePath
21:49:25 <RyanT5000> is it a different version number?
21:49:30 <RyanT5000> no it's not the module name
21:49:44 <sethk> that's the name in the file after the word "module"
21:49:52 <RyanT5000> do ghc-pkg list
21:50:04 <RyanT5000> i'm guessing it's Cabal?
21:50:10 <sethk> yes, it's Cabal
21:50:26 <RyanT5000> so do ghc-pkg describe Cabal-1.1.4 (except with whatever version you have)
21:50:51 <sethk> it shows it as a hidden module
21:50:52 <RyanT5000> if you really want, you can probably take the output from describe, modify it, and then reregister it
21:51:03 <sethk> I need the function.
21:51:14 <sethk> I either have to code the same thing myself, which actually might be easier ...
21:51:21 <RyanT5000> what's the function?
21:51:24 <sethk> but regular expressions don't exactly work either
21:51:31 <sethk> splitFileName
21:52:20 <sethk> I've got a way to hack around it, I imagine, but I would rather be able to use the function
21:52:31 <RyanT5000> @hoogle splitFileName
21:52:32 <lambdabot> Distribution.Compat.FilePath.splitFileName :: FilePath -> (String, String)
21:52:42 <RyanT5000> @hoogle FilePath
21:52:44 <lambdabot> Distribution.Compat.FilePath :: module
21:52:44 <lambdabot> Prelude.FilePath :: type FilePath
21:52:44 <lambdabot> Distribution.Compat.FilePath.breakFilePath :: FilePath -> [String]
21:53:46 <RyanT5000> @hoogle+
21:53:47 <lambdabot> Distribution.Compat.FilePath.splitFilePath :: FilePath -> (String, String, String)
21:53:54 <RyanT5000> ...?
21:54:03 <RyanT5000> how does that work?
21:54:41 <Lemmih> sethk: Distribution.Compat.FilePath is available from this darcs repo: http://darcs.haskell.org/~lemmih/FilePath
21:54:54 <sethk> Lemmih, thanks, but I already have the source file
21:55:02 <sethk> it's in the library source
21:55:02 <RyanT5000> sethk i'd say
21:55:06 <sethk> but it is hidden anyway
21:55:06 <RyanT5000> take the output from describe
21:55:12 <RyanT5000> cut-paste
21:55:14 <RyanT5000> re-register
21:55:27 <RyanT5000> assuming you don't need to survive version changes of Cabal
21:55:47 <sethk> RyanT5000, you mean just move the modules to the list of normal (not hidden) stuff?
21:55:54 <RyanT5000> yep ;)
21:56:17 <RyanT5000> worst. solution. ever. (TM)
21:56:24 <RyanT5000> but a solution nonetheless
21:56:40 <sethk> I can think of worse ones without even trying hard
21:57:21 <sethk> I could bring the compiler and libraries, wholesale, from the machine that works to the machine that doesn't.  that's definitely a worse idea
22:09:28 <RyanT5000> hm true
22:13:20 <palomer> ski: still here?
22:16:36 <newsham> is there FilePath function for normalizing/conanicalizing paths?
22:18:55 <Lemmih> @type System.Directory.canonicalizePath
22:18:56 <lambdabot> FilePath -> IO FilePath
22:21:37 <newsham> why is it IO?
22:22:03 <ski> palomer : barely
22:22:28 <newsham> hmm.. it knows about current directory
22:23:55 <palomer> ski: I wanted to know more about the link between modal types and monads
22:25:42 <ski> palomer : well, i don't know so much myself
22:26:01 <ski> but 'A -> possible A' is return
22:26:28 <ski> 'possible (possible A) -> possible A' is join
22:27:04 <ski> (iirc, this latter is not true in all modal logics)
22:27:20 <ski> you can also look at
22:27:31 <ski> A |- possible B
22:27:36 <ski> ------------------------
22:27:51 <ski> possible A |- possible B
22:28:20 <ski> which is similar to bind
22:28:34 <palomer> hrmph
22:28:39 <palomer> we'll have to talk about this when I'm more awake
22:28:42 <palomer> and when you have more free time
22:28:48 <ski> heh
22:29:40 * ski should really go to bed, now
22:37:35 <RyanT5000> is there a good tutorial of haskell for someone who knows no programming at all?
22:38:22 <RyanT5000> also: my dad is the department head of a CS dept at a good school, and they're restructuring the 1st and 2nd semester courses; help me convince him and his faculty that they should use haskell ;)
22:38:33 <newsham> ryan: two dozen short lessons
22:38:34 <Cale> RyanT5000: well, Haskell Road comes to mind
22:38:52 <newsham> http://www.cs.ou.edu/cs1323h/textbook/haskell.shtml
22:38:58 <Cale> and yeah, two dozen short lessons wouldn't be too bad for that
22:39:35 <RyanT5000> alright, cool, thanks
22:39:46 <newsham> you're going to teach intro cs students haskell?
22:39:51 <RyanT5000> no, not me
22:39:56 <newsham> and then listen to the whine about java/c/etc for the next 4 years!@#?
22:40:08 <newsham> should be a 4th year class ;-)
22:40:25 <RyanT5000> LOL
22:40:28 <RyanT5000> good point
22:40:48 <RyanT5000> you know... someone should write a "faking it" library in haskell
22:41:09 <newsham> explain?
22:41:10 <RyanT5000> it lets you write C++ programs, including comments etc. in C++
22:41:12 <RyanT5000> er
22:41:14 <RyanT5000> in haskell
22:41:18 <RyanT5000> so you go to work
22:41:30 <newsham> anyone familiar with the RuntimeLoader module and http://www.algorithm.com.au/wiki/hacking/haskell.ghc_runtime_loading?
22:41:33 <RyanT5000> fire it up, edit your "C++ project"
22:41:42 <RyanT5000> only you're really metaprogramming it in haskell
22:41:43 <newsham> I grabbed and built (one minor tweak in import statements), but it doesnt work.
22:41:57 <RyanT5000> great for doing homework or assignments on the job
22:42:06 <RyanT5000> when a particular "crap language" is required
22:42:06 <sjanssen> you could get pretty close to faking C++ syntax
22:42:08 <sethk> RyanT5000, I'm trying to avoid c++
22:42:20 <RyanT5000> yes, sethk, that's why i want the faking-it library :P
22:42:21 <sjanssen> things like adhoc overloading, templates, might be tough
22:42:29 <RyanT5000> boss: "You must use C++"
22:42:35 <RyanT5000> you: "OK"
22:42:47 <RyanT5000> you: "/me metaprograms it in haskell"
22:42:58 <RyanT5000> boss: "How did you finish it so fast?"
22:43:02 <RyanT5000> ...
22:43:03 <RyanT5000> profit
22:43:03 <Cale> Well, you can compile Haskell to C :)
22:43:13 <RyanT5000> but can you compile it to maintainable C
22:43:19 <Cale> well, no :)
22:43:34 <RyanT5000> i.e.: it needs to be set up so that the C++ or Java or whatever produced could be maintained by a C++ or Java or whatever programmer
22:43:38 <Cale> but all the better for you :)
22:43:43 <RyanT5000> just as easily as handcrafted C++ code
22:43:44 <newsham> if you were maintaining it in C you wouldnt be coding in haskell
22:44:12 <RyanT5000> newsham: are you sure that has to be the case?
22:44:15 <newsham> you dont edit generated files lest your work becometh undone
22:44:33 <RyanT5000> what if you had good heuristic algorithms for reverse-mapping?
22:44:55 <RyanT5000> i'm not saying it'd be perfect
22:45:06 <RyanT5000> but if you're the primary one maintaining a particular module
22:45:10 <RyanT5000> it could possibly be helpful
22:45:25 <RyanT5000> i dunno, this is just a thought experiment; i'm not actually suggesting someone build it :P
22:45:35 <newsham> ryan: then your coworker would kill you when cvs diff showed every line modified even though you edited only 3 due to reformatting of your mappers
22:45:50 <newsham> have you worked in a team before?
22:46:01 <RyanT5000> yes
22:46:05 <Cale> I somehow think that even if you could translate idiomatic Haskell into C++ in a way which wasn't totally gibberish, most C++ programmers couldn't read it.
22:46:08 <RyanT5000> admittedly not a big or great one
22:46:16 <RyanT5000> noooo nooo
22:46:24 <RyanT5000> that isn't what i meant Cale
22:46:25 <newsham> ryan; imagine the multitude of problems that would arise
22:46:31 <RyanT5000> i hope that isn't what i said
22:46:42 <RyanT5000> haskell only for metaprogramming
22:46:49 <palomer>  RyanT5000 I wouldn't introduce haskell to first or second year students
22:46:50 <RyanT5000> kind of like TH, only wiith output being a C++ AST
22:46:54 <Cale> Or do you mean to write a library for constructing C++ parse trees?
22:46:58 <RyanT5000> right
22:47:00 <palomer> anyways, night
22:47:10 <RyanT5000> C++ parse trees plus comments
22:48:11 <newsham> palomer: if you left the monad stuff out and did just normal functional programming (like two dozen short lessons) i think its a good language for intro
22:48:28 <RyanT5000> newsham: are monads really that hard if you don't try to understand them?
22:48:52 <cpatrick> newsham: the problem with doing that is that the students then think "haskell is useless if you're doing anything relevant to the real world"
22:48:55 <RyanT5000> i mean, simple imperative programs aren't that hard to write
22:48:59 <RyanT5000> with do syntax
22:49:12 <RyanT5000> admittedly the <- syntax and IORefs aren't exactly idea
22:49:14 <RyanT5000> *ideal
22:49:24 <RyanT5000> but they get the job done
22:49:33 <RyanT5000> and i mean for the kind of stuff you have kids doing in CS1
22:49:42 <RyanT5000> cout << is just as confusing, imo
22:49:45 <newsham> cpatrick: so?  students think a lot of stupid things.
22:50:55 <cpatrick> mm, especially CS students. Doesn't mean they should be _encouraged_ to do so :-)
22:51:05 <newsham> nobody familiar with RuntimeLoader?
22:51:27 <Cale> Since when has CS got anything to do with the real world? :)
22:51:38 <RyanT5000> i don't see why telling them about "do" syntax and saying "don't worry about it" is any worse than telling them "#include <iostream>\nusing namespace std;"
22:51:50 <RyanT5000> we give them a lot of template code in CS1
22:51:53 <newsham> cale: http://research.microsoft.com/users/jpincus/cs%20SocSci.html
22:52:45 <cpatrick> Cale: you're thinking of actual compute science, rather than what people get taught in undergrad CS
22:57:27 <sjanssen> RyanT5000: I think I'd rather explain "main = do" than "class M { public static void main(String[] args){}}"
22:58:21 <RyanT5000> hell yeah
22:58:27 <sethk> RyanT5000, that's odd, I would never introduce templates before a full understanding of the language
22:58:41 <RyanT5000> lol sethk that's not what i meant
22:58:47 <RyanT5000> i meant template in the old sense
22:58:49 <RyanT5000> like a form letter
22:59:05 <RyanT5000> "put this at the top of your file"
22:59:06 <sethk> RyanT5000, well, since hello, world is about five lines, I don't really see the need ...
22:59:07 <RyanT5000> "and this at the bottom"
22:59:21 <RyanT5000> the need for what?
22:59:34 <newsham> "boilerplate"
22:59:42 <sethk> RyanT5000, right, boilerplate
22:59:46 <RyanT5000> yes, boilerplate is the "real ultimate" word i was looking for :P
22:59:59 <newsham> do I get 2 pts?
23:00:05 <RyanT5000> lol
23:00:08 <sethk> newsham, 1.5
23:00:23 <newsham> i'll take it
23:03:30 <RyanT5000> hm this Q/A thing starts out with the interpreter
23:03:35 <RyanT5000> that's probably a really good idea
23:07:13 <RyanT5000> gah!
23:07:20 <RyanT5000> why do they start with list comprehensions?
23:07:24 <RyanT5000> why is that an early thing?
23:07:33 <RyanT5000> before functions?
23:07:46 <newsham> normal math stuff
23:07:49 <newsham> pretty obvious
23:07:57 <RyanT5000> yeah... but freshmen don't know math either
23:08:16 <RyanT5000> and besides, it looks like set theory, but it's ordered, which makes a pretty big difference
23:08:17 <sjanssen> they should know some
23:08:45 <RyanT5000> i dunno, i'm skeptical that it should come before functions
23:09:03 <newsham> when you write your textbook you can do it your way :)
23:09:33 <RyanT5000> i'm not saying it's wrong, i'm just saying i'm confused :)
23:09:47 <RyanT5000> maybe it's a good way of doing something interesting without recursion?
23:10:02 <RyanT5000> i bet that's it
23:10:09 <Pegazus> hi, how can i implement this function: cstPRF 0 = Zero
23:10:09 <Pegazus> cstPRF k = Succ (cstPRF (k - 1))
23:10:16 <Pegazus> without using explicit recursion?
23:10:22 <Pegazus> i mean any fold thing or something?
23:10:28 <Pegazus> [i just want a tip :)]
23:10:58 <RyanT5000> why are you defining it with -1 anyway?
23:11:01 <Pegazus> like: foldr op r [a, b, c] ? a `op` (b `op` (c `op` r))  i need the same but without elements
23:11:02 <RyanT5000> shouldn't it be pred?
23:11:09 <Pegazus> pred?
23:11:12 <RyanT5000> predecessor
23:11:15 <sjanssen> @type iterate
23:11:16 <lambdabot> forall a. (a -> a) -> a -> [a]
23:11:20 <RyanT5000> @type pred
23:11:21 <sjanssen> Pegazus: start there
23:11:22 <lambdabot> forall a. (Enum a) => a -> a
23:11:29 <Pegazus> k
23:11:30 <Pegazus> thanks
23:11:43 <Pegazus> is that functoin on the prelude or what?
23:11:52 <sjanssen> @hoogle iterate
23:11:54 <lambdabot> Prelude.iterate :: (a -> a) -> a -> [a]
23:11:55 <RyanT5000> @hoogle pred
23:11:56 <sethk> Pegazus, what
23:11:56 <lambdabot> Prelude.pred :: Enum a => a -> a
23:11:56 <lambdabot> Data.Graph.Inductive.Internal.FiniteMap.predFM :: Ord a => FiniteMap a b -> a -> Maybe (a, b)
23:11:56 <lambdabot> Test.HUnit.Base.assertionPredicate :: AssertionPredicable t => t -> AssertionPredicate
23:11:58 <Pegazus> ahh iterate
23:11:59 <Pegazus> k
23:12:06 <Pegazus> thanks
23:12:11 <RyanT5000> but you should use pred too :)
23:12:21 <Pegazus> mm
23:12:28 <RyanT5000> that way your function is Enum a, Enum b => a -> b
23:12:36 <Pegazus> what the hell is an enum?
23:12:55 <RyanT5000> it's the class over which pred and succ are defined
23:12:57 <Pegazus> and how do you know what i'm trying to do?
23:13:02 <Pegazus> annn
23:13:09 <Pegazus> i'm using a custom one
23:13:11 <RyanT5000> oh
23:13:15 <RyanT5000> bad idea :P
23:13:20 <Pegazus> it's not
23:13:23 <RyanT5000> no i'm kidding
23:13:26 <RyanT5000> i don't know if it's a bad idea
23:13:31 <Pegazus> it's kind of "homework"
23:13:32 <RyanT5000> but you should look at Enum just to make sure
23:13:38 <RyanT5000> oic
23:13:39 <RyanT5000> k :)
23:13:39 <Pegazus> so it's a big idea to use it :)
23:13:47 <Pegazus> PRF menans Primitive Recursion Function
23:14:02 <Pegazus> i'have to implement all function that ways O_o
23:16:32 <Pegazus> how do i define the "implicit" function
23:16:42 <Pegazus> mm
23:16:45 <RyanT5000> what's the penalty for using Integral instead of Int32, if your numbers all fit in Int32?
23:16:57 <RyanT5000> the answer i'm looking for is "pretty damn low"
23:17:35 <RyanT5000> @pl cstPRF k = Succ (cstPRF (k - 1))
23:17:36 <lambdabot> cstPRF = fix ((Succ .) . (. subtract 1))
23:17:38 <sjanssen> do you mean Int vs Integer?
23:17:40 <RyanT5000> :D
23:17:41 <newsham> let irc do you rhomework
23:17:48 <RyanT5000> ah yes, my bad
23:17:52 <Pegazus> given a recursiv type
23:18:08 <Pegazus> i need to "create" a function that "construct" one of those things
23:18:10 <Pegazus> how to do it?
23:18:24 <Pegazus> normally is blah = MyConstructor MyData1 MyData2
23:18:33 <Pegazus> but how to make a "function" that returns MyConstructor MyData1 MyData2?
23:18:38 <RyanT5000> sjanssen: i meant a fixed-size int vs. an arbitrary-sized int
23:18:41 <sjanssen> GHC defines something like: data Integer = Big Int | Large IntegerPrimitive
23:18:46 <Pegazus> any more interesting than \x y = Myconstructor x y ?
23:19:04 <Pegazus> i mean that works but is there any more "elegant way"?
23:19:06 <RyanT5000> alright, so basically no penalty? maybe an extra dereference that probably gets inlined-away?
23:19:20 <RyanT5000> i'm not doing computations with them, i'm just using them as tags
23:19:21 <sjanssen> a penalty, but a small one
23:19:33 <RyanT5000> k
23:23:37 <newsham> "MyConstructor" is already a function
23:23:54 <Cale> with newtype there's no penalty
23:23:57 <newsham> \x y -> MyConstructor x y     is the same thing as   MyConstructor
23:23:58 <Pegazus> good
23:24:22 <RyanT5000> Cale: a newtype can only have one constructor though right?
23:24:24 <Pegazus> cstPRF k = (iterate (\x -> Comp Succ [x]) Zero) !! k
23:24:27 <Pegazus> that works
23:24:28 <Cale> right
23:24:36 <Cale> and that constructor can only have one field
23:24:41 <Pegazus> but is there any way to do that without using iterate nor explicit recursion?
23:24:42 <RyanT5000> right
23:25:14 <RyanT5000> Pegazus:
23:25:15 <RyanT5000> @pl cstPRF k = Succ (cstPRF (k - 1))
23:25:16 <lambdabot> cstPRF = fix ((Succ .) . (. subtract 1))
23:25:25 <RyanT5000> not only is that not recursive, it also doesn't use variables
23:25:32 <RyanT5000> is that good enough?
23:25:47 <newsham> he cant turn that in as homework, it looks too good.
23:25:53 <RyanT5000> true, but he could work from it
23:25:56 <newsham> can you rewrite it as a freshman would write it for him?
23:26:00 <RyanT5000> LOL
23:26:05 <RyanT5000> that's exactly why i'm not doing that
23:26:17 <Pegazus> what means @pl ?
23:26:30 <newsham> its a command to lambdabot
23:26:36 <Pegazus> <newsham> can you rewrite it as a freshman would write it for him? --> i'm actually expected to write really "high quality" code
23:26:50 <Pegazus> the thing is that they want us to learn high order, and those things
23:26:57 <newsham> you are?  or irc is?
23:27:05 <RyanT5000> pegazus: you would never have figured out the point-free function on your own, unless you were told to
23:27:07 <Pegazus> so we are forbidden to use explicit recursion, pattern mattching, and comprenhensive lists may be too :)
23:27:17 <Pegazus> <RyanT5000> pegazus: you would never have figured out the point-free function on your own, unless you were told to --> that's not a problem
23:27:27 <Pegazus> and i've seen the point free function anyway :p
23:27:55 <Pegazus> i can't find fix on the prelude...
23:27:56 <RyanT5000> well if it satisfies your homework and you don't have ethical issues with lambdabot doing your homework for you, turn it in
23:27:58 <Pegazus> what does it do?
23:28:04 <RyanT5000> @hoogle fix
23:28:05 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
23:28:05 <lambdabot> Control.Monad.Fix :: module
23:28:05 <lambdabot> System.IO.fixIO :: (a -> IO a) -> IO a
23:28:17 <Pegazus> i don't get it :/
23:28:42 <RyanT5000> tbh i have no idea what it does either
23:28:48 <Pegazus> O_o
23:28:49 <RyanT5000> i'm not doing your homework for you :)
23:28:56 <Pegazus> it's not my homework
23:29:02 <Pegazus> my homework is a little more complex :)
23:29:04 <newsham> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad-Fix.html#v%3Afix
23:29:08 <Pegazus> i ask specific things about the language
23:29:10 <newsham> fix f is the least fixed point of the function f, i.e. the least defined x such that f x = x. 
23:29:23 <Pegazus> least defined x???? what? O_o
23:29:30 <RyanT5000> isn't it amazing that you can just do that?
23:29:38 <Pegazus> just do what? :)
23:29:43 <RyanT5000> just find a fixed point
23:29:53 <Pegazus> i have no idea what a fixed point is
23:29:56 <newsham> peg: it solves the equation   f x = x
23:29:57 <newsham> for x
23:30:00 <RyanT5000> it's a point x such that f x = x
23:30:06 <RyanT5000> "point" means "value"
23:30:16 <RyanT5000> (it's a point in the space of all possible values)
23:30:52 <Pegazus> O_o
23:30:59 <Pegazus> i still don't get it, but anyway
23:31:01 <Pegazus> forget it
23:31:33 <RyanT5000> you should read the wikipedia page on fixed points
23:32:27 <newsham> lets say  f x = x * 0.5
23:32:44 <newsham> if you run f (f (f x))   and so on, the numbers get smaller
23:33:05 <newsham> err. bad example it never really approaches the value..
23:33:07 <newsham> nevermind :)
23:33:50 <Pegazus> k
23:33:58 <RyanT5000> well in that case 0 is a fixed point
23:34:20 <RyanT5000> let's say you have f x = 1 - x
23:34:26 <RyanT5000> then .5 is a fixed point
23:35:11 <RyanT5000> for continuous functions from Real->Real (i.e.: the regular kind of function from calculus), a fixed point is any point that lies on the line through the origin with slope 1
23:35:26 <RyanT5000> i.e.: any point y = x, or, equivalently, f x = x
23:35:29 <RyanT5000> ;)
23:36:42 <RyanT5000> hm, does that mean that given any function f(x) that doesn't have a fixed point, the average slope of that function is 1?
23:44:29 <Cale> nope
23:44:47 <RyanT5000> sorry,  continuous function from real to real
23:45:01 <Cale> hmm, are you assuming that it's everywhere differentiable, and its derivative is integrable?
23:45:08 <RyanT5000> yes
23:46:00 <Cale> actually, it could still be 0
23:46:04 <RyanT5000> how so?
23:46:07 <Cale> or really any value
23:46:25 <Cale> try something like exp(x)
23:46:43 <Cale> or x^2 + 1
23:46:49 <RyanT5000> hm
23:48:57 <araujo> hello!
23:50:38 <RyanT5000> ah, for x^2+1 it's undefined
23:51:36 <RyanT5000> you end up with (limit as x -> inf (x^2)) - (limit as x -> -inf (x^2))
23:52:12 <RyanT5000> i wonder if, if it is defined, it has to be 1 :P
23:53:10 <RyanT5000> (araujo, in case you're interested and confused, the question was whether a continuous differentiable function from real to real that didn't have a fixed point had to have an average slope of 1)
23:53:11 <Cale> It depends on how you define it
23:53:26 <Cale> (the improper Riemann integral)
23:53:35 <RyanT5000> well it matters at what speed the x's tend to their infinities
23:53:44 <RyanT5000> lol alright you just exceeded my math knowledge :P
23:53:44 <Cale> are you taking the limit as R -> infinity of the integral from -R to R of f(x) ?
23:58:27 <RyanT5000> no, i wasn't taking the limits together
23:58:27 <Cale> The Lebesgue integral won't exist in any event :)
23:58:27 <RyanT5000> if i did i'm sure it'd be an arbitrary value, but that isn't really correct
23:58:27 <RyanT5000> lol
23:58:27 <RyanT5000> i have no idea what that is
23:58:27 <RyanT5000> :)
23:58:27 <RyanT5000> i just got out of CS undergrad... i took multivariable calc and diff eq...
23:58:27 <RyanT5000> everything else i know about math is from reading wikipedia and mathworld :P
23:58:27 <ct16k> can somebody please help me debug a little piece of code? i know i'm missing some basics here, i just want to know which they are :">
23:58:27 <RyanT5000> k
23:58:27 <RyanT5000> if it's short, paste it here; if not, paste it in a pastebin and give a link
23:58:27 <RyanT5000> @where paste
23:58:27 <lambdabot> http://paste.lisp.org/new/haskell
23:58:27 <ct16k> it's about 9lines, but i think i'll use the link
23:59:07 <metaperl> in general people ignore things pasted from there but since RyanT5000 is on the lookout for it, it's OK...
23:59:35 <Lemmih> They do?
23:59:36 <lisppaste2> ct16k pasted "too much imperative thinking" at http://paste.lisp.org/display/18977
23:59:41 <metaperl> I dont know why people ignore things there... I think it is best to paste to rafb.net/paste and then ask a question pointing to the paste
23:59:43 <RyanT5000> yah, you generally need to ask your question and nudge people into looking at your paste :)
23:59:51 <metaperl> Lemmih: that has been my pervasive experience
