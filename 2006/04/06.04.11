00:11:40 <Pegazus> what are monades? and which is the syntaxis?
00:12:15 <ForgeAus> monad - lends itself to being a single unit so I guess its Haskells term for a module?
00:12:38 <ForgeAus> of some kind (generally speaking - I don't know if module has a special meaning in Haskell)
00:12:51 <Pegazus> it was something for handling colateral effects
00:12:53 <Pegazus> like maybe
00:16:01 <ayrnieu> forgeaus - no, sorry.
00:16:18 <ForgeAus> hehe don't b sorry, I was just guessing anyhow
00:16:33 <ayrnieu> http://www.haskell.org/hawiki/FrequentlyAskedQuestions
00:31:58 <vincenz> anyonea read haskell-cafe?
00:39:53 <skew> vincenz: yeah, did something interesting just come up?
00:46:41 <vincenz> well...hmm...damn now I can't remember
00:46:51 <vincenz> (too much context-switching)
00:47:01 <vincenz> oh right
00:47:12 <vincenz> sudoku solvers, these two guys were commenting, and they referred to what ide's they used
00:47:23 <vincenz> the first guy didn't mention, but said that basically he got type annotaitons for free in his ide
00:47:30 <vincenz> any idea on how he accomplishes this?
00:48:31 <int-e> I believe he didn't say that - he said that types *should* be inferred by the IDE and have no place in the source code.
00:49:00 <int-e> and that in the meantime ghci can be used out for finding out types. ... well that's how I read it.
00:49:26 <vincenz> yeah but I read the should as in 'your gui should be doing this, that's why -i- don't annotate my code'
00:49:34 <vincenz> meaning he used an other option that did do it
00:51:14 <vincenz> oh well
00:51:24 <vincenz> I hoped there was some solution, the concept sounded neat
00:51:43 <int-e> he mentioned using ghci, :browse Main
00:51:46 * int-e shrugs
00:52:41 <vincenz> I read that as alternate solutions
00:52:42 <vincenz> oh well
00:53:05 * int-e likes having types - at least for top level declarations - they localize compile errors, and serve as documentation. But I guess that's a matter of taste.
00:59:12 <vincenz> anyone know a good reference site for how to write a ray tracer, more specifically the math involved, not just for the simple things, but also allowing the option to expand to more complex things (For instance, how does one do cloudy materials, or diffuse lighting objects?)
00:59:54 <shapr> newsham: Hey, you were asking about web servers?
01:00:06 <vincenz> shapr: aloha
01:00:46 <shapr> hoi vincenz
01:03:17 <vincenz> shapr: how do I say "How is it going" in your language
01:04:02 <shapr> Well, since I'm from Alabama, I guess it'd be "howdy, 'sup?"
01:04:11 <vincenz> hmm I mean where you are...
01:04:15 <vincenz> (finland? norway?)
01:04:20 <shapr> I'm in Sweden.
01:04:25 <vincenz> right...the one I missed
01:04:28 <shapr> "Hej, hur mår du?"
01:06:06 <vincenz> hmm can't render that unicode car
01:06:07 <vincenz> char
01:06:15 <vincenz> Hej, hur m?r du?
01:06:56 <davidhouse> @index fix
01:06:57 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
01:08:10 <davidhouse> what exactly does fix do?
01:08:27 <davidhouse> i appreciate it finds a fixpoint, but that seems a bit limited, and doesn't appear to work some of the time
01:08:28 <davidhouse> > fix cos
01:08:29 <lambdabot> Terminated
01:08:38 <shapr> vincenz: mÃ¥r
01:08:50 <tvoss> hi @ll, anyone free for some debugging? ;)
01:09:06 <vincenz> shapr: can't see that unicode
01:09:11 <vincenz> it makes a little diamond with a ?
01:09:19 <shapr> davidhouse: It's more like the Y combinator in a manner than actually works in Haskel.
01:09:41 <shapr> vincenz: It's &a-ring;
01:09:43 <davidhouse> okay :) so what does the Y combinator do?
01:09:59 <shapr> It's called Y because it duplicates the computation.
01:10:24 * shapr looks for docs
01:10:31 <shapr> @get-definition Y
01:10:32 <lambdabot> Y = \f.U(\g.f(U g))
01:11:02 <shapr> http://www.haskell.org/hawiki/FixedPointCombinator
01:12:02 <tvoss> Could someone point me to a pastebin?
01:12:09 <vincenz> > take 10 $ let fix f = f (fix f) in fix show
01:12:10 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
01:12:14 <vincenz> tvoss: http://rafb.net/paste
01:12:30 <vincenz> @where+ pastebin http://rafb.net/paste
01:12:31 <lambdabot> Done.
01:12:35 <vincenz> @where pastebin
01:12:36 <lambdabot> http://rafb.net/paste
01:13:46 <neologism> forLoop n parents = do
01:13:46 <neologism>                      offspring <- crossAll parents
01:13:46 <neologism>                      let newparents = (takeHalf1 (sorted parents)) ++ offspring
01:13:46 <neologism>                      if verbose then mapM_ putStrLn (sorted offspring)
01:13:46 <neologism>                      forLoop (n - 1) newparents
01:13:52 <neologism> whats wrong with the "if verbose..." line?
01:13:59 <neologism> hugs complains about bad layout
01:14:05 <tvoss> thx ;-) I think I've got a _very_ simple problem but this is my first day with Haskell ... http://rafb.net/paste/results/ocdR0313.html
01:14:18 <davidhouse> > fix show !! 10
01:14:19 <lambdabot> '\\'
01:14:25 <davidhouse> > fix show !! 20
01:14:26 <lambdabot> '\\'
01:14:56 <vincenz> > fix (+1) !! 1
01:14:57 <lambdabot>  add an instance declaration for (Num [a])
01:15:01 <vincenz> > fix (+1) 
01:15:02 <lambdabot> Terminated
01:15:10 <vincenz> > fix (+0) 
01:15:11 <lambdabot> Terminated
01:15:26 <vincenz> it's interesting that fix fails on those things that have either no solution or an infinite amount
01:15:36 <shapr> davidhouse: Anyway, fix gets more interesting when you see the monadic and arrowdic(?) flavors, mfix and loop.
01:15:45 <vincenz> @type mfix
01:15:46 <lambdabot> forall (m :: * -> *) a. (MonadFix m) => (a -> m a) -> m a
01:16:13 <davidhouse> shapr, any quick examples?
01:16:15 <shapr> davidhouse: It gets even *more* interesting when you learn about strong normalization and fix.
01:16:20 <tvoss> could someone have a quick glance at http://rafb.net/paste/results/ocdR0313.html?
01:17:13 <shapr> davidhouse: Sorry, nothing comes to mind and I have other stuff I have to do..
01:17:17 * shapr goes to do $work
01:17:20 <davidhouse> sure. i'll keep reading.
01:17:30 <davidhouse> shapr: thanks
01:27:38 <neologism> is hugs known to be buggy?
01:28:09 <magagr> tvoss: the max function doesn't operate on lists
01:30:51 <magagr> you'll need to fold it into the list
01:34:28 <tvoss> magagr: thx;) I solved the problem by using foldl
01:34:40 <magagr> neat
01:36:48 <tvoss> magagr: http://rafb.net/paste/results/6OJyTR66.html
01:37:22 <boegel> hmm, I wrote a small Haskell program to aggregate my measurement results, but it's using 2G of virtual memory besides my 1.2G actual RAM... I guess something must be going wrong... :)
01:38:49 <Muad_Dibber> Maybe it's just very very big measurement results? :)
01:40:29 <boegel> nah
01:41:11 <boegel> I'm aggregating rougly 1,000,000 rows of 6 numbers into one single row...
01:41:33 <ibid> boegel: you're probably creating a lot of thunks...
01:41:51 <boegel> I do use 'length ls', in which ls is the list of 1,000,000 rows, so that forces evaluation. But that shouldn't use 3G of RAM, or would it?
01:41:54 <boegel> ibid: thunks ?
01:42:09 <boegel> ibid: if you tell me how to avoid that...
01:42:41 <ibid> boegel: do you pass (foo+1) kind of stuff as a recursive parameter?
01:42:57 <ibid> boegel: strategic `seq` helps usually :)
01:43:41 <boegel> ibid: no, but I do pass the list of 1,000,000 elements, of which I take 1,000 elements a time
01:43:41 <tvoss> thx for your help ... bye:-)
01:44:29 <ibid> boegel: i mean, you're not using any kind of an accumulator argument?
01:44:44 <boegel> ibid: no, I'm not
01:44:53 <ibid> ok, no idea then without seeing the code
01:45:01 <boegel> I can show you...
01:45:13 <boegel> let me trim it down a bit
01:45:17 <ibid> ok
01:46:44 <davidhouse> magagr: incidentally there's also a function maximum
01:46:48 <davidhouse> > maximum [1..10]
01:46:49 <lambdabot> 10
01:46:52 <davidhouse> @type maximum
01:46:53 <lambdabot> forall a. (Ord a) => [a] -> a
01:48:06 <boegel> ibid: I have to increase the stack size too when running it (using +RTS -K20M)
01:48:21 <ibid> boegel: the code...? :)
01:48:33 <boegel> ibid: coming up...
01:48:57 <boegel> let me throw a sample file online too, it's just gibberish numbers anyway :)
01:51:53 <boegel> ibid: http://elis.ugent.be/~kehoste/aggr_atom
01:52:14 <boegel> ibid: http://www.elis.ugent.be/~kehoste/aggr_atom (sorry)
01:52:52 <boegel> the log file is 49M, so I'd guess the max memory usage should be along those lines...
01:53:25 <ibid> you can assume that there's a constant factor involved
01:53:31 <ibid> (easily in the range of 2-6)
01:53:46 <boegel> well okay, I'm fine with that
01:53:54 <boegel> but 3G of RAM is just insane
01:54:14 <boegel> and I've run it on both Linux/i386 and OSX/PowerPC
01:54:45 <ibid> yeah
01:54:50 <ibid> let me play with this
01:54:53 <boegel> ok :)
01:55:02 <boegel> glad someone is willing to help me out
01:55:13 <ibid> no promises about results :)
01:55:34 <boegel> you're helping me anyway (with learning, for example)
01:55:54 <boegel> I can't imagine if I'd write the exact same thing in C, it would use 3G of RAM
01:57:18 <ibid> probably not
01:57:22 <int-e> (length fileLines) forces the entire file to be read, hmm.
01:57:26 <ibid> but you'd have to work harder to generate it
01:59:08 <ibid> hrm the webserver isn't responding now, and i can't see the command line
02:01:11 <int-e> boegel: try using  init $ drop 3 fileLines  instead of  take ((length fileLines) - 4) $ drop 3 fileLines  and  last $ fileLines  instead of  fileLines !! (length fileLines - 1)
02:02:50 <blackdog> @seen dons
02:02:51 <lambdabot> dons is in #haskell. I last heard dons speak 4 hours, 12 minutes and 8 seconds ago, but .
02:03:06 <bolrod> but.
02:03:25 <int-e> boegel: ah, that won't be enough. aggr_itypes should be written using splitAt, for the same reason.
02:03:51 <dons> yo
02:04:45 <boegel> yeah, but that's only 49M
02:04:46 <boegel> I agree that isn't the best of code, but it shouldn't use 3G
02:05:32 <dons> boegel, is it reading a lot of input in Strings?
02:05:32 <int-e> boegel: hmm, it's more like 400M, I think.
02:05:49 <int-e> dons: yes, an entire 49 MB file.
02:05:53 <boegel> dons: yes, it is
02:06:00 <dons> you using fast packed strings... ?
02:06:08 <dons> I would never do IO on Strings over 1M.
02:06:36 <boegel> dons: erm no, but that's a good suggestion
02:06:39 <dons> 1M is even pushing it.
02:06:43 <dons> ?where fps
02:06:43 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
02:07:03 <dons> I think using packed strings, as every other language on the planet does, is probably the first move to make :)
02:07:09 <int-e> boegel: anyway, I think it's the length that kills the memory usage, you should avoid it completely.
02:07:20 <dons> oh, you actually call 'length' ?
02:07:25 <blackdog> dons: you're my only hope.
02:07:37 <dons> thankyou blackdog.
02:07:46 <blackdog> what do you do when you get that linking error about running out of memory?
02:07:57 <dons> gimme a sec to find the flag
02:08:13 <dons> --no-keep-memory ?
02:08:26 <blackdog> you said something about EXTRA_CC_OPTS, but i tried exporting that, then passing it directly to -optl...
02:08:26 <dons> and using -Onot helped on haskell code.
02:08:30 <blackdog> yeah, tried that...
02:08:39 <blackdog> how do you pass it, though?
02:08:46 <dons> it uses gcc as a linker, remember
02:08:52 <blackdog> so -optc?
02:08:56 <dons> so  its:  -optl-Wl,--no-keep-memory
02:08:57 <dons> iirc
02:09:05 <dons> i.e. lookup the gcc flag for passing things to ld
02:09:09 <dons> and then pass --no-keep-memory
02:09:23 <dons> so thats ghc passing a flag to gcc, which then passes the rest to ld :)
02:09:34 <blackdog> .. mm, baroque. :)
02:09:37 <boegel> dons: would that help memory usage too ? next to being faster?
02:09:39 <blackdog> thanks, i'll try that.
02:09:40 <boegel> int-e: the total memory usage? or just evaluating 'length ls' ?
02:09:59 <dons> boegel, almost certainly. each node of a Char uses somethign like 8 words
02:10:08 <dons> each cahr in a packed string uses 8 bits
02:10:29 <dons> length , and any kind of fold, over huge M of input, will be expensive, i think
02:10:34 <int-e> boegel: you force the whole file when you use length.
02:10:38 <dons> but length on a fast packed string is a strlen.
02:10:59 <int-e> boegel: as a list, in the way dons described.
02:11:46 <dons> boegel, fps is mostly a drop in replacement for [Char]. so should be fairly easy to fix
02:12:08 <dons> and I encourage anyone thinking of doing more than 1M of IO, to pack those chars! :)
02:13:01 <int-e> argh. 8 words is about right, because the Char can not even be unboxed.
02:13:03 <dons> blackdog, remember that the ',' is required in the string: -optl-Wl,--no-keep-memory
02:13:28 <dons> (I always forget it :)
02:13:28 <boegel> dons, int-e: hmm, okay, let me fix those things... :)
02:13:47 <dons> boegel, also, check out the Performance resource on the wiki.
02:13:52 <dons> ?wiki Performance
02:13:52 <lambdabot> http://www.haskell.org/haskellwiki/Performance
02:13:57 <dons> if you go to the section marked 
02:14:06 <dons> "String" it will say: use fps :)
02:15:04 <boegel> :)
02:15:30 <boegel> dons: are they planning to fix that in Haskell' ? or are there disadvantages to fps too ?
02:15:45 <dons> nope. a new packed string library will be in the base libs.
02:15:58 <dons> well, [Char] is here to stay
02:16:10 <dons> but a std packed string lib with the base system will be good
02:17:28 <dons> ?dynamic-reload seen
02:17:29 <lambdabot> module reloaded
02:17:33 <dons> ?seen boegel
02:17:34 <lambdabot> Last time I saw boegel was when I left #flippi, #gentoo-haskell, #haskell, #haskell-blah, #haskell-overflow, #haskell.es, #haskell.it and #scannedinavian 5 seconds ago.
02:17:39 <dons> ?seen dosn
02:17:40 <lambdabot> I haven't seen dosn.
02:17:43 <dons> ?seen dons
02:17:43 <lambdabot> Last time I saw you was when I left #flippi, #gentoo-haskell, #haskell, #haskell-blah, #haskell-overflow, #haskell.es, #haskell.it and #scannedinavian 14 seconds ago.
02:19:52 <bolrod> O_o?
02:20:10 <bolrod> ?seen lambdabot 
02:20:11 <lambdabot> Yes, I'm here. I'm in #ScannedInAvian
02:20:17 <bolrod> :)
02:20:27 <boegel> hehe
02:21:03 <boegel> removing the 'length' stuff improved stuff a lot :)
02:21:11 <boegel> now the FPS part...
02:21:17 <bolrod> ..?
02:21:37 <dons> boegel: I'd import qualfied Data.FastPackedString as P
02:21:43 <dons> and then add a P prefix to your list ops
02:21:58 <blackdog> dons: when i pass the flag to cc, i get a warning about the linker input being unused because linking wasn't done, then the same error...
02:21:59 <boegel> dons: yeah, I was planning that :)
02:22:17 <dons> blackdog, is this code somewhere I could grab?
02:22:52 <dons> I don't rememebr the cure for the 'linkign wasn't done' issue.
02:23:12 <blackdog> it could be, but i only have a problem on FreeBSD
02:23:18 <blackdog> ghc 6.4
02:23:29 <dons> does -fasm help?
02:23:33 <blackdog> it compiles without a prob on my little mac...
02:23:54 <blackdog> no
02:24:08 <dons> what's the linking not done msg?
02:24:54 <dons> oh, hmm, you passed the linkign flag to the command that creates the executable?
02:25:07 <blackdog> yeah - just using ghc --make
02:25:16 <dons> right.
02:26:01 <dons> since you've got all the objects, can you use ghc to link them in a single pass without --make?
02:29:43 <boegel> hmm, appartently I screamed too fast... It's still using 1.05G of virtual memory (without FPS that is)
02:38:34 <mnislaih> which function or idiom is used to 'join' two arrays a1 and a2 in a new one
02:38:58 <neologism> anyone skilled here with evolution algorithm?
02:39:04 <dons> two lists, mnislaih ?
02:39:13 <mnislaih> like an equivalent to (++) for lists?
02:39:36 <dons> there's no idiom that I'm aware of.
02:39:37 <mnislaih> two arrays, of Data.Array.*
02:39:48 <dons> converting to lists and joining would be easy and inefficient
02:39:55 <dons> doing a memcpy would be harder, but efficient
02:40:10 <mnislaih> I'd rather avoid the conv. to lists. How would one do a memcpy ?
02:40:27 <mnislaih> Or, what data structure should I use instead of array ?
02:40:48 <dons> ?index copyArray
02:40:49 <lambdabot> Foreign.Marshal.Array, Foreign.Marshal, Foreign
02:41:00 <boegel> neologism: I played with it lately
02:41:02 <dons> ?type Foreign.Marshal.Array.copyArray
02:41:04 <lambdabot> forall a.
02:41:04 <lambdabot>             (Foreign.Storable.Storable a) =>
02:41:04 <lambdabot>             GHC.Ptr.Ptr a -> GHC.Ptr.Ptr a -> Int -> IO ()
02:41:12 <dons> is pretty efficient. its a wrapper over memcpy
02:41:25 <dons> but otherwise. lets se...
02:42:34 <dons> just create a larger array and do your own copy with a mapM_
02:43:05 <dons> mapM_ ( [1..(snd . bounds) arr1 ]
02:43:14 <dons>  grr. hit return too soon
02:43:22 <mnislaih> would this solution be efficient ?
02:43:29 <mnislaih> the thing is that I'm switching from my current data representation with lists, mainly because (++) is too inneficient
02:43:45 <mnislaih> and it's called a lot
02:43:51 <mnislaih> in my program
02:44:10 <dons> what are the array elements?
02:44:34 <mnislaih> terms
02:44:58 <dons> this would be something approachign a fairly efficient copy: mapM_ (\i -> unsafeWrite arr2 i (arr ! i)) [1.. ((snd.bounds) arr) -1 ]
02:45:05 <dons> terms of what? 
02:45:14 <mnislaih> from an algebraic datatype
02:45:17 <dons> some AST terms?
02:45:18 <dons> ok
02:45:24 <dons> so you can't use unboxed arrays then
02:45:30 <mnislaih> it's a representation of logic propositions
02:45:56 <mnislaih> I guess I might change the representation to use unboxed arrays
02:46:03 <mnislaih> with a bit of work
02:46:12 <mnislaih> but I'll leave that for later. I will try your suggestion
02:46:17 <dons> I think copying Arrays would be ok.
02:46:33 <mnislaih> I'll let you know later ok? thanks a lot
02:46:40 <dons> and when you know the bounds are correct, use unsafeRead and unsafeWrite. they're much more efficient
02:46:43 <dons> check :
02:46:45 <dons> ?wiki Performance
02:46:46 <lambdabot> http://www.haskell.org/haskellwiki/Performance
02:46:52 <dons> for a good chapter on efficient arrays
02:46:57 <sieni> Is there some reason why Clean is so highly ranked in the Shootout? Uniqueness types for side-effects? http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
02:47:09 <dons> they have a lot of packed string primitives
02:47:16 <dons> i.e. fread, a read() on packed strings
02:47:19 <dons> in their std libs
02:47:35 <dons> I think we'd score roughly the same with fps in the std libs. and Text.Regex.Lazy
02:48:09 <dons> they're both lazy langs. uniqueness types are jsut another way todo what we do with monads. its wrong to attribute that to their speed.
02:48:31 <sieni> ok
02:48:43 <dons> we score basically the same, but with a lot more work to get packed string io. and then only  on a few tests
02:49:05 <dons> so i think its not a typing thing :) they don't have magic super-fast types :)
02:49:22 <sieni> :-)
02:50:11 <sieni> can't [Char] be optimized to use FPS magic?
02:50:25 <sieni> by the compiler?
02:50:35 <dons> it often is. but not always
02:50:38 <dons> s/often/sometiems
02:50:54 <dons> but in general you don't want to strictify all your lists
02:51:06 <dons> which an fps is. its a hyperstrict list
02:52:48 <vincenz> dons: you looked for me?
02:54:31 * vincenz heads out for lunch, be back in 30-40
02:56:19 <dons> vincenz, I wrote an hmp3 patch for you :)
02:56:30 <dons> you can now search forwards and backwards through the song title list
02:56:35 <dons> as you requested :)
02:58:13 <boegel> dons: fetching FPS with darcs should suffice to use it in a Haskell program, right ?
02:59:01 <beelsebob_> @hoogle (a -> IO ()) -> [a] -> IO ()
02:59:02 <lambdabot> No matches, try a more general search
02:59:18 <beelsebob_> @hoogle (a -> m b) -> [a] -> m b
02:59:19 <lambdabot> Prelude.foldr :: (a -> b -> b) -> b -> [a] -> b
02:59:19 <lambdabot> Prelude.foldl :: (a -> b -> a) -> a -> [b] -> a
02:59:19 <lambdabot> Data.List.foldl' :: (a -> b -> a) -> a -> [b] -> a
03:00:47 <beelsebob_> @type foldr (\x _ -> putStrLn x) (return ()) [5, 3,4]
03:00:48 <lambdabot>   No instance for (Num String)
03:00:48 <lambdabot>   arising from the literal `5' at <interactive>:1:40
03:01:06 <beelsebob_> @type foldr (\x _ -> putStrLn x) (return ()) ["a","b","c"]
03:01:07 <lambdabot> IO ()
03:01:09 <beelsebob_> :)
03:05:26 <neologism> what is the main difference between ghc 6.0 and 6.2 and 6.4?
03:06:02 <neologism> ah.. found release noteses
03:07:00 <flux__> I wonder if the research in the eager haskell -front has advanced lately
03:07:03 <dons> boegel, fetch with darcs. build and install
03:07:06 <beelsebob_> @hoogle withCString
03:07:07 <lambdabot> Foreign.C.String.withCString :: String -> (CString -> IO a) -> IO a
03:07:07 <lambdabot> Foreign.C.String.withCStringLen :: String -> (CStringLen -> IO a) -> IO a
03:10:45 <boegel> dons: ok, nvm, stupid question
03:23:21 <boegel> dons: I've installed FPS (and Cabal), but when compiling my program I get this (on MacOSX):
03:23:35 <boegel> /usr/bin/ld: Undefined symbols:
03:23:35 <boegel> ___stginit_DataziFastPackedString_
03:23:35 <boegel> collect2: ld returned 1 exit status
03:23:41 <boegel> any idea's ?
03:25:40 <beelsebob_> :o
03:25:52 <beelsebob_> use -package FastPackedString
03:26:02 <beelsebob_> I just got the weirdest type error ever
03:26:23 <beelsebob_> Couldn't match `-> (IO())' against `IO'
03:26:30 <beelsebob_> o.O
03:26:50 <beelsebob_> mostly because it appears to be a kind error
03:26:54 <beelsebob_> not a type error
03:34:10 <araujo> Good morning!
03:34:29 <blackdog> What's so good about it?
03:34:45 <blackdog> i kid, i kid.
03:35:08 <sieni> no wai!
03:49:10 <Ulfalizer> heh, what is with americans and flags.. every time there's a demonstration against something, no matter what, you always see some confused guy waving an american flag somewhere in the crowd.. :)
03:52:31 <Cale`> beelsebob_: the kinds of (->) (IO ()) and IO match
04:00:54 <bolrod> sjanssen: dang!! this is going nuts :D
04:01:43 <bolrod> all that inits stuff :/
04:03:16 <bolrod> kopete BAH
04:03:17 <bolrod> :x
04:03:22 <pitecus> Which haskell implementations support unicode?
04:03:56 <sieni> shouldn't all if they conform to the Haskell report?
04:04:29 <pitecus> Which ones conform?
04:06:26 <vincenz> dons: ping
04:08:50 <bolrod> pong ?
04:13:53 <dons> boegel, -package fps
04:14:09 <boegel> dons: how do I handle operations involving Char's using FPS's ?
04:14:11 <dons> vincenz, i added regex searching on file names to hmp3. as you requested :)
04:14:24 <boegel> dons: oh, the error is fixed, I just had to run ranlib manually on some FPS lib
04:14:46 <dons> boegel? check the docs: http://www.cse.unsw.edu.au/~dons/fps/Data.FastPackedString.html
04:14:50 <dons> ah yes. ranlib on the mac.
04:14:58 <boegel> dons: heh, yeah
04:15:05 <boegel> what causes that ?
04:15:18 <dons> the mac linker? what else.. :)
04:15:31 <boegel> heh :)
04:15:40 <boegel> dons: I'm using break on a string now, as in:
04:15:43 <dons> if you check the haddocks, there's lots of list-like functions that take Chars, or Char predicates. but operate on fps.
04:16:14 <boegel> > break (==':') "1:2:3"
04:16:15 <lambdabot> ("1",":2:3")
04:16:27 <vincenz> dons: coolies :)
04:16:30 <boegel> how can I pull that if "1:2:3" is a fps ?
04:16:37 <bolrod> > span (==':') "1:2:3"
04:16:38 <lambdabot> ("","1:2:3")
04:16:40 <bolrod> ?
04:16:53 <boegel> bolrod: ?
04:16:59 * bolrod is bored
04:17:03 <boegel> heh
04:17:04 <dons> vincenz, check the help page for hmp3 from darcs, you use | and \ to search the file lsit. / and ? to search the dir list
04:17:10 <vincenz> \o/
04:17:10 <boegel> > break (==':') (pack "1:2:3")
04:17:11 <lambdabot>  Not in scope: `pack'
04:17:18 <boegel> @
04:17:20 <dons> boegel? use P.break?
04:17:33 <boegel> dons: oh, damn
04:17:33 <boegel> hmm
04:17:43 <shapr> Yay, QuickCheck is soon to be released!
04:17:48 <boegel> I thought I searched the HTML page for "break", and it failed
04:17:49 <boegel> strange
04:17:56 <boegel> y0 shapr
04:18:00 <shapr> y0 y0
04:18:10 <boegel> dons: just ignore my questions in the near future :s
04:18:17 <dons> Data.FastPackedString.break (==':') (pack "1:2:3")
04:18:17 <dons> ("1",":2:3")
04:18:18 <dons> :)
04:18:21 <blackdog> shapr: did you listen to ninetynine?
04:18:43 <shapr> blackdog: nah? lemme check shimweaser
04:18:50 <shapr> shimweaseL
04:19:11 <bolrod> what is a fast packed string anyway ? :)
04:19:13 <dons> what's this with Koen "distributing copies to friends" :(
04:19:20 <shapr> dons: Hey, I got one :-)
04:19:44 <dons> its a gc'd ptr to a chunk of space on the C or Haskell heaps, containing an array of bytes
04:19:46 <shapr> I've been poking John lately asking about QC licensing.
04:20:22 <dons> what license does it have?
04:20:27 <dons> (!)
04:20:47 <shapr> For various reasons, QC2 will probably have a GPL license.
04:20:53 * boegel swings on the sounds of the new Bloodhound Gang album
04:21:06 <shapr> But, the code I have isn't licensed at all, so I can't really do anything with it.
04:21:12 <dons> oh thats fine. i was worried that the older versions had some hidden clause I hadn't spotted.
04:21:13 <shapr> blackdog: Tracks on their site somewhere?
04:21:17 <bolrod> so I take it a FPS uses less memory and is in some way faster ?
04:21:27 <dons> much faster
04:21:37 <dons> like the difference between an array and a list for many ops
04:21:45 <dons> it also has O(1) substrings
04:21:58 <dons> i.e. drop and take are O(1)
04:22:04 <dons> check the docs for the various details.
04:22:13 <bolrod> aha
04:22:17 <dons> its pretty much the only way to do really large amoutns of string io.
04:22:35 <dons> i've done stuff with 1G files with fps. but my machine gets scared after that
04:22:50 <shapr> How much ram do you have?
04:22:51 <bolrod> 1G files?!O_o
04:22:54 <blackdog> shapr: yeah. badly designed site, but they're there. grep the html for mp3 or something, if you really can't find it. :)
04:22:57 <vincenz> dons: I need bigger
04:22:58 <dons> 256m + 1G swap
04:22:58 <neologism> is there some howto change code from String to FPS?
04:23:26 <bolrod> an all text file?
04:23:28 <dons> no. no howto. but its fairly easy as all the function names are the same.
04:23:32 <shapr> blackdog: It's using frames... sheisa
04:23:34 <dons> mostly.
04:23:50 <dons> bolrod: ?
04:24:10 <bolrod> well... just data?.. or 'text'  data
04:24:10 <blackdog> it looks like an abortion in Safari. cool bands always have crap sites, though - check out "The Mares" on myspace some time.
04:24:32 <dons> bolrod, its all bytes to me
04:24:36 <shapr> blackdog: aha, just add mp3/ to the frameset url.
04:24:40 <bolrod> ok :)
04:24:47 * vincenz needs to open up files that are pluri-gigabyte binary
04:24:49 <vincenz> suggestions?
04:25:00 <mahogny> wxhaskell expert wanted; I need to know why I should be using "variable" instead of an Mvar, if there is a reason at all
04:25:12 <dons> vincenz, how would you do it in ocaml?
04:25:22 <dons> on soln is to make your programs as lazy as possible
04:25:27 <dons> ensure they're very very lazy
04:25:32 <shapr> Oh hey, is gtk2hs or wxhaskell better for producing binaries that work on win32?
04:25:40 <shapr> Yeah, lazy pipelines are awesome.
04:25:59 <dons> and use no reductions or folds. then [Char] is fine.
04:26:04 <mahogny> shapr, never tried any on win32, but wx is native in win32 so I think that would be a better choice
04:26:11 <eivuokko> shapr, On my limited experience, I'd use wxhaskell if you can get it to compile.
04:26:13 <resiak> blackdog: All myspace pages are hideous
04:26:23 <shapr> eivuokko, mahogny: thanks for the advice.
04:26:46 <bolrod> the wsxhaskell site is very out of date
04:26:55 <bolrod> it has old binaries I think ;/
04:27:00 <bolrod> we have to use it for an assignment
04:27:13 <dons> hmm. did spj just post a seq in pure H98?
04:27:18 <vincenz> dons: well I read and use
04:29:56 <dons> boegel, btw, 'P.breakOn is more efficient than P.break
04:30:00 <dons> if you're doing lots of breaks
04:30:09 <dons> where the predicate is an ==
04:31:16 <bolrod> hmm... would cross compiling work if I'd run ghc in wine?
04:31:25 <dons> yes. but hard.
04:31:37 <dons> i ran linux ghc under emulation on openbsd at one point
04:31:48 <dons> it generated nice linux binaries, that in turn ran under emulation
04:32:06 <boegel> dons: oh okay
04:32:30 <dons> boegel, if your code's online , and your having troubles, ping me and i'll have a look.
04:32:49 <bolrod> dons: ;o ;(
04:32:53 <dons> after you've done all the hard work converting to packed strings
04:33:06 <bolrod> but is it possible to cross compile to windows .. with something like -fvia-C  or something?
04:33:26 <dons> why not just use windows ghc?
04:33:34 <bolrod> if I dont have a windows computer?
04:33:39 <dons> oh. hmm. no.
04:33:48 <bolrod> hmm.. that sounds clear ;/
04:34:03 <bolrod> because it would be possible to compile C for windows on linux right?
04:34:11 <dons> maybe. maybe if you ran ghc under emulation in wine, with ghc thinking it was in windows, you could get it to produce windows binaries. maybe
04:34:31 <bolrod> I will try then
04:34:35 <dons> bolrod: no. where would you get all the libraries to link against?
04:34:37 <boegel> dons: okay, but I'll try to pull it on my own, that's the only way I'll learn :)
04:34:45 <dons> how about in vmware, bolrod?
04:35:12 <bolrod> I dont know!.. but on the winrar site it said they were compiled in linux...    I think
04:35:21 <bolrod> vmware takes up so much space
04:35:36 <bolrod> and can't use it through console
04:36:19 <boegel> > read "3.2" :: Float
04:36:20 <lambdabot> 3.2
04:36:22 <bolrod> maybe the wine works.. I'll try
04:36:31 <boegel> dons: how can I pull that using fps ?
04:37:45 <bolrod> This installer relies on the Windows Installer runtime to operate   
04:37:48 <bolrod> how great! >:/
04:38:16 <boegel> :)
04:38:55 <boegel> dons: ping :)
04:39:05 <bolrod> PONG!
04:39:09 <bolrod> ;/
04:39:16 <bolrod> what's up with the 'ping'  :p
04:40:45 <eivuokko> winrar uses ghc?  Anyway, mingw toolset is pretty trivially available for crosscompiles.  Ghc isn't.
04:41:49 <beelsebob_> isn't it?
04:42:11 <eivuokko> I don't think so, not that I have tried very hard.
04:42:14 <beelsebob_> to get ghc to cross compile you gcc to cross compile
04:42:24 <beelsebob_> you tell gcc*
04:42:51 <beelsebob_> not as easy as yhc I'll admit ;)
04:42:56 <eivuokko> Also all libraries need to be cross compiled, rts needs to be cross compiled.
04:43:14 <beelsebob_> that's true
04:43:36 <eivuokko> And afaict the target and host macros aren't used (at least in driver) separately enough.
04:43:49 <eivuokko> So, things like --mk-dll might not work easily.
04:44:11 <beelsebob_> :/
04:44:47 <eivuokko> But as I said, maybe they actually are, and it's pretty trivial - I never tried really.
04:45:14 <eivuokko> One would think if that's easy, there would be cross ghc between mingw and cygwin, too.
04:45:27 <beelsebob_> true
04:45:38 <beelsebob_> ah well, what can I say... use yhc
04:56:50 <bolrod> dons: almost got it to work with wine
04:57:19 <bolrod> but can you link the .o file that the ghc creates with  ld ?
04:57:37 <bolrod> because it gives these errors of undefined reference..     
05:12:06 <beelsebob_> o.O
05:12:18 <beelsebob_> it appears my ghc install has exploded...
05:13:04 <beelsebob_> ___stginit_Directory_, ___stginit_Prelude_, ___stginit_System_, ___stginit_Char_, ___stginit_List_, ___stginit_Numeric_, ___stginit_CString_, ___stginit_Foreign_, ___stginit_SystemziIOziUnsafe_, ___stginit_IO_, ___stginit_GHCziTopHandler_, ___stginit_Monad_
05:13:21 <beelsebob_> (/usr/bin/ld: Undefined symbols{
05:19:02 * shapr hugs Haskell
05:19:17 * mauke ghci Haskell
05:19:27 <bolrod> -.-
05:21:49 * sieni mlton Haskell
05:21:54 <sieni> sorry, wrong weapon
05:24:21 <shapr> I'm spending time in #python asking questions...
05:30:20 <boegel> dons: it seems the FPS part did most of the optimizing... my program runs smoothly now using 150M of RAM :)
05:33:00 <bolrod> :O!
05:33:12 <bolrod> you can easilly crosscompile c to windows executables
05:33:13 <bolrod> ;/
05:33:26 <bolrod> i586-mingw32msvc-gcc count.c 
05:33:33 <bolrod> wine a.exe 
05:33:34 <bolrod> 1000000000
05:33:49 <bolrod> now... how do I get the ghc crazy enough to use that instead of the ghc
05:39:37 <bolrod> someone know how I can select the gcc to use with ghc?
05:40:56 <Angel> hello / bonjour
05:41:11 <shapr> bolrod: -pgm something -pgmF ? -pgmC ? I forget.
05:42:20 <shapr> salut Angel, apprenez vous Haskell?
05:42:44 <Angel> I am a beginner in Haskell, what can I use if I want to host my website in Haskell ?
05:42:49 <bolrod> -pgmc  cool
05:42:50 <bolrod> =)
05:42:51 <bolrod> lets see!!!
05:42:54 <Angel> Bonjour shapr 
05:43:19 <shapr> Angel: You can create standard cgi programs with Haskell.
05:45:07 <vincenz> Angel: darcs :)
05:45:26 <vincenz> Angel: vous etes belges ou francais?
05:45:40 <Angel> cgi is poor performance, doesn't it ?
05:45:49 * shapr has a hissy fit about badly designed software
05:45:53 <Angel> je suis francias
05:45:56 <Angel> francais
05:47:05 <Angel> darcs c 'est un systeme de gestion de versions pas un logiciel pour henergÃ© un site en Haskell
05:47:21 <shapr> That's true.
05:48:28 <vincenz> true, but if you want to host haskell software..
05:48:34 <vincenz> but I guess that's the wrong approach
05:48:42 <shapr> I think he wants a website done with Haskell.
05:48:44 <vincenz> have you looked at WASH?
05:48:50 <shapr> Yeah, WASH is the most complete solution at the moment.
05:49:08 <Philippa> has it been updated much?
05:49:15 <Philippa> there's a reason I didn't use it for Flippi at the time
05:50:43 <Angel> just two minutes , i read about wash :)
05:55:47 <bolrod> bah!  why doesn't it like the header files used in the ghc
06:00:28 <dons> boegel: ! great :)
06:01:59 <Angel> so I need Wash Server Pages, WashNGo and hs-plugins N
06:02:04 <Angel> ?
06:02:23 <dons> boegel, if you're still looking for a fast string 'read' function, look at readInt here: http://www.cse.unsw.edu.au/~dons/code/hmp3/FastIO.hs
06:02:42 <dons> you could convert that to read a float, I think
06:15:47 <xerox> Do you know of any good data recovering tool?
06:16:42 <shapr> xerox: For recovering from what?
06:20:24 <bolrod> can't I just make the ghc dump to a valid C program?
06:20:32 <bolrod> ^.0
06:20:38 <xerox> shapr, ~10Gb of data on a FAT32 partition.
06:20:48 <xerox> (It was deleted "accidentally".)
06:20:56 <dons> bolrod. no you still need the runtime system and any libraries
06:21:06 <dons> so it would be a big big program
06:21:14 <dons> better to run windows inside vmware, i reckon
06:21:25 <bolrod> I can compile a .c program to a .exe fine now
06:21:31 <blackdog> bolrod: sounds like don's trick for the C only prog comp :)
06:21:46 <dons> yeah. this comes up again and again
06:22:03 <dons> we ought to write such a script. one that gets .hc for everything and dumps it in a 100k loc file
06:22:07 <dons> just to make people happy
06:23:47 <blackdog> Totally. (C is faster, too!)
06:24:02 <bolrod> but seriously now...      I can compile a simple c program to an exe
06:24:14 <bolrod> but with the ghc it starts buggering me with unknown options
06:24:15 <bolrod> ;/
06:24:21 <blackdog> xerox: you've unmounted the disk already, i hope?
06:24:24 <bolrod> I just want the C output.. and then see what I can do with it
06:24:37 <xerox> blackdog, sure.
06:24:40 <bolrod> is that possible?..
06:24:57 <bolrod> I don't care if it compiles after that or not.. I just want to see ;)
06:25:16 <xerox> blackdog, in fact it spinned for one day since the disaster, and some work was done.
06:25:17 <Igloo> -keep-hc-file will leave the .hc file (I can't remember whether in /tmp or not)
06:25:27 <bolrod> hc file is not C 
06:25:32 <bolrod> its C for the ghc
06:25:55 <bolrod> right?
06:26:28 <bolrod> oh wait
06:26:30 <bolrod> it does compile ;/
06:26:55 <Igloo> It's just C, that needs headers and libraries from ghc to link against
06:27:49 <bolrod> no its not
06:27:59 <dons> yep. its jsut C
06:28:09 <bolrod> oh
06:28:22 <dons> full of macros from the rts headers
06:29:10 <Igloo> Oh, if you're compiling with a registerised compiler then you'll also need to run the mangler before assembling to get a working program
06:30:39 <dons> true. you need unregisterised C. (or is that the default, and then the mangler just improves it?)
06:30:48 <dons> or is the C itself not going to fly?
06:31:16 <bolrod> ^.o
06:31:32 <Igloo> I believe the C won't fly
06:31:35 <bolrod> what the hell is mangler :)
06:31:46 <bolrod> blah!
06:31:54 <dons> bolrod: cross-compilign ghc code is a non-trivial task, i hope you see that.
06:32:21 <Igloo> bolrod: If you really want to do this then just compile an unregisterised GHC and use that for now
06:32:30 <bolrod> I'm just trying to compile the .hc file with gcc to linux now >:/
06:32:31 <Igloo> and then you can ignore the mangler
06:32:37 <bolrod> and it dont work
06:33:08 <bolrod> ok.. it almost worked :)
06:33:11 <bolrod> /tmp/ccXutrkL.s:94: Error: junk at end of line, first unrecognized character is `-'
06:33:14 <dons> you're goign to need a windows-based rts and libraries to link against
06:33:26 <dons> you can't link against a linux rts
06:33:27 <bolrod> I believe that has something to do with the mangler?
06:34:01 <mux> do you guys prefer that style :
06:34:03 <mux> flip (foldl (flip (uncurry update')))
06:34:06 <mux> or this one :
06:34:11 <Igloo> bolrod: What is that? (you might need -keep-tmp-files)
06:34:13 <mux> flip . foldl . flip $ uncurry update'
06:34:27 <mux> or maybe something totally different
06:34:34 <bolrod> thats gcc <file>.c
06:34:41 <blackdog> you can replace all the . with $, can't you?
06:34:42 <bolrod> after I dod mv *hc <file>.c
06:34:46 <dons> mux: i like the latter
06:34:50 <Igloo> What's on that line, though?
06:35:05 <bolrod> erh.. it outputs that like 1000 times
06:35:10 <blackdog> we're not schemers, after all.
06:35:12 <mux> blackdog: I think it's possible yeah, would like it better?
06:35:15 <Igloo> mux: I prefer   flip $ foldl $ flip $ uncurry update'
06:35:20 <mux> okay
06:35:28 <mux> makes sense as it only use one operator
06:35:46 <mux> cheers!
06:37:17 <dons> Pseudonym will get grumpy with all those $.
06:37:50 <mux> dons: you'd prefer the version with both dots and a $ ?
06:38:07 <Igloo> That's OK, I don't mind Pseudonym being grumpy
06:38:12 <dons> :)
06:38:42 <dons> hmm. why would a QuickCheck test abort?
06:38:46 <dons> i.e. '*'
06:39:01 <Igloo> '*'?
06:39:07 <bolrod> Igloo: Its from the assambler
06:39:11 <bolrod>         --- BEGIN ---
06:39:17 <bolrod> it sees that as junk or something
06:39:37 <blackdog> igloo,dons: is there an operational difference between using $ and . there?
06:39:58 <dons> .....** (15800)
06:40:36 <dons> blackdog: i doubt it, in most cases
06:40:54 <mux> the only thing that annoys me is that I now have
06:40:56 <dons> hmm. apparently it means an exception
06:40:57 <mux> update'                 = update . const . Just
06:41:00 <mux> which is all dots
06:41:06 <mux> and
06:41:07 <mux> updateMany              = flip $ foldl $ flip $ uncurry update'
06:41:09 <mux> which is all $
06:41:13 <dons> so you have to choose!
06:41:23 <dons> ?pl updateMany              = flip $ foldl $ flip $ uncurry update'
06:41:23 * mux ponders
06:41:23 <lambdabot> updateMany = flip (foldl (flip (uncurry update')))
06:41:42 <dons> ?pl update'                 = update . const . Just
06:41:42 <lambdabot> update' = update . const . Just
06:41:47 <dons> ah well. no surprises
06:41:50 <Angel> what are your feelings about the Haskell "WebFunctions" http://www.cs.uu.nl/wiki/WebFunctions/WebHome ?
06:41:55 <mux> heh.
06:43:10 <morans> what makes lambdamot not be vulnerable to people running IO in it?
06:43:14 <mux> ?pl updateMany = flip . foldl . flip . (uncurry update')
06:43:15 <lambdabot> updateMany = flip . foldl . flip . uncurry update'
06:43:35 <mux> mm, not valid
06:44:04 <dons> morans: the type checker
06:44:26 <kpreid_> morans: unsafePerformIO is not in its scope and the results of expressions are shown, not performed
06:44:35 <dons> ?
06:44:39 <dons> they're 'performed'
06:44:44 <dons> you have to perform them to show them
06:44:53 <morans> so you can't give qualified names?
06:45:24 <kpreid_> never mind
06:45:34 <dons> you can't access modules that aren't in scope. as for normal haskell code
06:46:21 <dons> so, a) a trusted code base is all you get b) you're restricted to pure h98. no unsound extensions c) a type constraint requires that you write pure code.
06:46:30 <dons> > print "foo"
06:46:30 <lambdabot> No IO allowed
06:46:34 <morans> dons: I'm trying to compare it to ghc -e 'foo' where you *can* put in unsafePerformIOs
06:47:03 <morans> dons: by specifying System....unsafePerformIO
06:47:13 <dons> yeah, its not an interactive system like that where it adds extra imports for you
06:47:30 <morans> dons: so -e is adding imports authomagically?
06:47:36 <dons> like in ghci
06:47:45 <dons> since you can't write 'import Foo' statements
06:48:03 <morans> ok
06:48:30 * morans was adding lambdabot-like functionality to a mud he hangs out on
06:48:37 <dons> cool
06:48:45 <dons> what do you mean 'lambdabot-like' ?
06:48:49 <dons> you writing a bot in haskell?
06:48:55 * morans too lazy to port lambdabot to his RPC mechanism so he just put a 1-line hack round ghc -e  to see how people like it
06:49:02 <dons> (I'd start by ripping off lambdabot's plugins)
06:49:04 <morans> dans: i'll possibly just port lambdabot
06:49:24 <dons> there's lots of holes if you give unrestricted ghc -e access
06:49:35 <morans> yeah
06:49:42 <morans> i'm not too concerned - this is a private work MUD
06:50:07 <dons> why not take the 'runplugs' program from lambdabot -- its a tiny standalone program that implements ghc -e functionality in a restricted way
06:50:08 <morans> so for initial "play with this for an evening" its not that dangerous as long as I've made it clear to the other people that the holes are there
06:50:14 <morans> dons: yeah
06:50:16 <dons> so no infinite loops, no unsafe code.
06:50:39 <morans> dons: thats what I was looking at doing. there was some runtime error on my mac when I tried to get it to work and I was so tired I gave up for the evening.
06:50:46 <dons> ?gsite cse.unsw.edu.au RunPlugs.hs
06:50:47 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/lambdabot/Makefile
06:50:57 <dons> not quite google.
06:50:59 <morans> dons: it was all I could do to type ghc -e ${A} before I fell asleep :)
06:51:03 <dons> http://www.cse.unsw.edu.au/~dons/code/lambdabot/scripts/RunPlugs.hs
06:51:34 <morans> dons: but yes, that code is waht I was looking at to wonder why it wasn't vulnerable to imports
06:52:01 <dons> but you know now, right? import chasing is ghci magic
06:52:11 <morans> ja
06:54:17 <dons> this is weird. i've been asked about lambdabot's eval sandboxing 4 times today.
06:54:59 <Muad_Dibber> i'll ask about it later to make it 5.
06:55:19 <dons> thanks Muad_Dibber 
06:55:59 <flux__> however, you'll still need to be asked plenty of times to get that number up to 42 :(
06:56:49 <wchogg> What happens then?  Does lambdabot become the font of all knowledge?
06:56:57 <dons> its getting there
06:56:59 <dons> ?brain
06:57:00 <lambdabot> I think so, Brain, but culottes have a tendency to ride up so.
06:57:11 <mahogny> can anyone tell me how much of a speed advantage STM can give me over MVar?
06:57:12 <dons> lots of domain specific knowledge
06:57:27 <dons> mahogny: they're about the same, iirc.
06:57:35 <dons> but the semantics may be simpler
06:57:56 <Igloo> STM is slower than using MVars, no?
06:58:00 <Igloo> Just easier to get right
06:58:03 <mahogny> slower? o_O
06:58:30 <musasabi> yes.
06:58:37 <dons> Igloo: I thought it was about the same if you coded in a certain way that SimonM recommends?
06:58:56 <musasabi> dons: yes, but it is harder to optimize.
06:58:58 <dons> he wrote something on that to the ml recently?
06:59:09 <dons> ah ok.
06:59:19 <dons> musasabi: but simpler to write in stm?
06:59:29 <musasabi> readTVar + writeTVar  ~ modifyMVar
06:59:43 <mahogny> actually, I have some data here that almost never changes, but I need to read it quite often and still have it globally accessible. how do I get some speed into this?
07:00:12 <musasabi> IORef? (if there are no concurrent updates)
07:00:17 <dons> stick it in an ioref.
07:00:21 <mahogny> hmm
07:00:36 <mahogny> but IOref reads in all data whenever it does the IO right?
07:00:41 <dons> an MVar is jsut as good though
07:00:42 <dons> state :: MVar HState
07:00:42 <dons> state = unsafePerformIO $ newMVar emptySt
07:00:42 <dons> {-# NOINLINE state #-}
07:00:54 <dons> and then write some accessors
07:01:13 <dons> withST :: (HState -> IO a) -> IO a
07:01:20 <dons> modifyST :: (HState -> HState) -> IO ()
07:01:34 <dons> getsST :: (HState -> a) -> IO a
07:01:47 <mahogny> since I might not access all the data in the IORef, and IORef seems to read in all data, it seems to me like a major performance loss
07:01:52 <dons> mahogny: no, its jsut a ptr to the data
07:01:56 <mahogny> hmm
07:01:57 <mahogny> ok
07:02:01 <musasabi> How do I lift an arbitary value to TH level? e.g. foo :: MyType -> Q [Dec]; foo x = [d| someFun = foo 1 300 x |], but I seem to lack something for lifting the x.
07:02:07 <dons> i don't know what you mean by "reads in all the data" ?
07:02:29 <Igloo> musasabi: You need an instance Lift MyType
07:02:42 <mahogny> dons, well. I thought an (IOref a) will read the entire a into the local scope whenever I need anything in a?
07:02:48 <musasabi> Igloo: shouldn't TH provide that by default?
07:03:00 <dons> mahogny: ? it'll jsut unwrap the ptr. i.e. dereference.
07:03:04 <Igloo> It doesn't
07:03:08 <dons> what would it mean to 'read'?
07:03:09 <mahogny> ok
07:03:18 <musasabi> It seems quite evil to have to write a $(deriveLift ...)
07:03:18 <dons> do you mean, copy?
07:03:23 <mahogny> dons, copy yes
07:04:03 <dons> no copies. no mutable values. if you mutate it you get something new. but a read isn't a copy
07:04:07 <mahogny> I mean, wouldn't it have to execute the IO entirelly before moving on? a bit unsure on monadic semantics
07:04:12 <mahogny> hm
07:04:16 <mahogny> ok
07:04:21 <musasabi> Igloo: is there any way to lift a datastructure containing a function?
07:04:33 <Igloo> No
07:04:49 <dons> mahogny: its highly efficient. i've used iorefs in very performance driven apps with no noticeable penalty
07:05:05 <mahogny> dons, if you have tested it then I'm calm :)
07:05:24 <Igloo> musasabi: You might want to pass in a quasi-quoted MyType and then use $x instead
07:06:03 <vincenz> I'm getting more and more people at my firm interested in haskell, I might give a course soon, all pointers and tips are welcome!
07:06:27 <blackdog> ohh, you don't want to teach pointers in haskell. :P
07:06:29 <mahogny> vincenz, avoid the messiest examples? :)
07:06:58 <dons> vincenz, grab the tutorials from haskell.org?
07:07:05 <dons> mention lots of real world apps from the libraries page
07:07:10 <dons> and lots of clever research
07:07:13 <vincenz> yeah I pllan to refer to libraries
07:07:14 <dons> mention pugs
07:07:20 <musasabi> Igloo: I started from [Name] which was quite ugly and got to MyType. So back to [Name] ?
07:07:20 <vincenz> I think the advancement in research is less important
07:07:27 <vincenz> dons: it's mostly in the context of tool development
07:07:28 <dons> the shootout results too.
07:07:48 <vincenz> for such things as source-transformations, binding profile information to ast's, etc..
07:07:51 <blackdog> vincenz: are you trying to sell them on haskell, or teach them useful stuff?
07:07:52 <Igloo> musasabi: What are you actually trying to do?
07:07:52 <dons> lots of good advice on Why Haskell Matters
07:07:54 <vincenz> polyhedral model possible
07:07:58 <vincenz> blackdog: both ;)
07:08:05 <mahogny> vincenz, mention the time it took to implement the Perl compiler (I think it was)
07:08:14 <vincenz> I think that will be less viable
07:08:16 <dons> vincenz: oh, it is the only language on the planet designed to write AST transformations in.
07:08:17 <blackdog> perl6
07:08:31 <vincenz> I think I'll also refer to gtk2hs
07:08:33 <vincenz> and it's ease of use
07:08:46 <mahogny> vincenz, don't forget wxhaskell. native win32 interfaces :)
07:08:46 <dons> if they're writign a lot of ast tools, show them some pattern matching
07:08:54 <vincenz> and obviously the Data.* libraries
07:09:19 <mahogny> haskelldb?
07:09:38 <dons> yeah, the speed you can deploy new code. i.e. icfp contest. also, sethk is writing like 10 new commerical haskell aps a week these days. 
07:09:45 <dons> you might want to ask him about productivitiy 
07:09:59 <mahogny> sethk? he got a homepage or something?
07:10:41 <dons> he  hangs out here
07:10:42 <vincenz> My main worry is explaining monads
07:10:55 <tony2> are they familiar with functional programming in general? show them quickcheck in haskell.
07:10:57 <musasabi> Igloo: basically just createMain sp = do a <- deriviX sp; b <- deriveY sp; c <- [d| main = stdMainHandler sp |]; return (a++b++c)
07:11:31 <mahogny> vincenz, maybe not try monads the first thing you do. haskell has tons of nice stuff that doesn't involve monads, like partial function application and list comprehensions
07:11:47 <vincenz> mahogny: io is monadic
07:11:56 <mahogny> vincenz, yeah. hide it ;)
07:11:58 <Igloo> musasabi: How is createMain called, though? And what is sp?
07:11:59 <vincenz> tony2: no, they are not familiar with functional programming
07:12:27 <dons> wow. they write ast transformer code, but don't know fp?
07:12:35 <dons> how do they do pattern matching?
07:12:36 <tony2> then you'll probably spend quite some time, showing them recursive versions of imperitive code.
07:12:50 <blackdog> dons: people do it in C, you know
07:12:52 <dons> also, galois connection's initial business was writing ast transformer tools in haskell
07:12:54 <blackdog> poor benighted souls
07:13:02 <dons> so it can be highly successful 
07:13:34 <dons> i'd just die right now if i had to give up pattern matching on data structures. life isn't worth living 
07:13:52 <blackdog> drama queen :)
07:13:58 <dons> ;)
07:14:00 <vincenz> dons: I agree
07:14:15 <vincenz> dons: also... I had a technical discussion with a guy who's rather smart and open technologies
07:14:19 <vincenz> he brought up a good point
07:14:22 <vincenz> which I will have to tear down
07:14:25 <vincenz> basically
07:14:28 <vincenz> on a global level
07:14:32 <vincenz> you have FP <-> UML
07:14:34 <vincenz> (OO)
07:14:38 <mux> ?pl shuffle g map           = foldl (flip (uncurry swapMap)) map (permutations g (1, size map))
07:14:39 <lambdabot> shuffle = ap (foldl (flip (uncurry swapMap))) . (. ((,) 1 . size)) . permutations
07:14:46 <vincenz> one focusses on the transformations, the other on the relationships between complex data
07:14:50 <vincenz> I told him types do that
07:14:58 <vincenz> he agreed, but didn't seem fully convinced
07:15:11 <mahogny> UML=OMG
07:15:18 <blackdog> unless you're very careful, types can reveal too much about the implementation
07:15:41 <mahogny> well, that's no different from classes
07:15:48 <vincenz> not quite
07:15:52 <blackdog> for easy code which may have to slot into a much bigger framework, OO seems a better tradeoff.
07:15:52 <mahogny> public everything and you have the same problem
07:16:15 <vincenz> for instance...you have one data-structure, which links to many different data structures, UML is clear in showing these relationships, his fear is that this get lost in the jungle of fp code
07:16:29 <vincenz> UML/OO/whatever
07:16:40 <vincenz> you get the point
07:16:52 <blackdog> really hard code is where FP shines, but the dirty secret is that most code is bog-simple
07:16:54 <vincenz> (I didn't say OO cause then people think of c++ or java which contain too much lowlevel crud)
07:17:11 <mahogny> vincenz, fp doesn't stop you from using UML and the kind. in fact, one would be stupid to think that fp can replace it
07:17:24 <vincenz> mahogny: how do the two relate
07:17:32 <vincenz> his fear was that it's a choice, either or
07:17:59 <vincenz> he didn't try to discredit FP, just that UML is clear in conveying highlevel relationships, and with FP ...it's either UML(OO,whatnot) OR FP
07:18:11 <mahogny> vincenz, if you ask me, UML is crap. graphical tools are nice because they can be kept at a quite informal level but still give lots of information. UML is way too formal to harvest the advantages
07:18:24 <vincenz> mahogny: UmL is an instantiation of the concept I mean
07:19:04 <musasabi> Igloo: it is called like $(createMeain (foobar arg1 ... :*: baz sdf ... :*: End)) (where :*: is just a heterogenous collection of values inside a typeclass)
07:19:30 <vincenz> mahogny: basically with OO you have object-diagrams
07:19:33 <vincenz> mahogny: FP lacks this
07:19:42 <vincenz> and thus it's harder to have an oversight of big code
07:19:44 <mahogny> if you forget about the methods in UML, and just consider the data... if you use lots of records and use a standardized mapping of pointers to some datatype, you can easily map back and forth
07:20:30 <mahogny> I would say that imperative programming has the same problem as FP in this sense; unless you make a clear map to the UML, it will be impossible to make one in the end
07:20:35 <mahogny> spagetti code also called
07:20:43 <dons> vincenz: will you try my hmp3 patches? theyre in the darcs repo.... comments are welcome
07:20:44 <mahogny> you can code spagetti in haskell as well
07:20:46 <dons> :)
07:20:53 <dons> ?wiki Obfuscation
07:20:53 <lambdabot> http://www.haskell.org/haskellwiki/Obfuscation
07:20:57 <tony2> types, typeclasses, and modules. IMO these give better information and implmentation hiding than using objects/UML
07:21:01 <morans> hm
07:21:04 <dons> and throw some implicit paramaters in with TH
07:21:04 <vincenz> dons: not yet, will tonight
07:21:07 <morans> so /usr/bin/ld: table of contents for archive: /usr/local/lib/plugins-1.0/libHSplugins-1.0.a is out of date; rerun ranlib(1) (can't load from it)
07:21:15 <morans> thats the error I get when I try to ghc --make RunPlugs.hs
07:21:23 <morans> on mac os x
07:21:24 <dons> did you rerun ranlib?
07:21:30 <vincenz> mahogny: the point is highlevel documentation
07:21:32 <dons> like the good linker asks.
07:21:36 <morans> dons: I rebuilt, thats all
07:21:41 <tony2> dons: does hmp3 wrap some c decoder? or did you implment it all in Haskell?
07:21:43 <mahogny> dons, I think that depends on who designs the UML, the same way it depends on who codes the FP
07:21:48 <dons> you need to run ranlib 3 times an hour on the mac
07:21:51 <dons> its the law
07:22:04 <mahogny> vincenz, I don't think that will be a problem as long as you decide how to map the UML
07:22:07 <morans> dons: funny
07:22:12 <morans> dons: yeah that works, never come across that before
07:22:23 <dons> tony2, it wraps mpg321, a c decoder. I reckon I could write it in Haskell though... :)
07:22:35 <vincenz> mahogny: the connection is less clear, I tried to argue modules but he wasn't convinced
07:22:37 <mahogny> vincenz, it's no harder than coding OO in vanilla C; you just have to be a bit strict
07:22:40 <dons> after seeing the numerical performance in the shootout
07:22:53 <morans> well, it compiles, but doesn't run right now
07:23:00 <morans> unknown symbol `___stginit_TextziPrintf_'
07:23:08 <dons> oh, on the mac?
07:23:14 <morans> dons: ja
07:23:22 <mahogny> vincenz, I don't think modules mix very well with UML at all
07:23:28 <dons> yargh. hs-plugins is broke on the mac since the new backend was written
07:23:30 <xerox> Mac intel?  :-)
07:23:31 <dons> :(
07:23:42 <morans> ok
07:23:49 <dons> sorry. its a real pain
07:23:49 <morans> i'll try on a linux box
07:23:57 <dons> the ghc mac backend does something weird in the linker
07:24:00 <morans> dons: the server i want to run it on is linux
07:24:07 <dons> ok. linux is fine.
07:24:08 <dons> ?version
07:24:08 <morans> dons: so I'll just go play there
07:24:09 <lambdabot> lambdabot 3p410, GHC 6.4.1 (Linux i686 3.20GHz)
07:24:09 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
07:24:12 <dons> ^^ see :)
07:24:16 <morans> heh
07:24:35 <mahogny> vincenz, maybe you can give them example code on how to map UML to haskell?
07:24:45 <dons> tony2, it would be a fun project writing a verified decoder in haskell
07:24:49 <vincenz> are there examples available?
07:24:57 <xerox> dons, oh, \bot is on lunix now?
07:24:58 <morans> was pretty funny last night watching a bunch of intelligent programmers who hadn't really been exposed to haskell learning how to use it through communal interaction with the bot
07:25:00 <vincenz> mahogny: interesting concept, thanks for the suggestion
07:25:11 <shapr> Yah, lambdabot r0xx
07:25:19 <mahogny> vincenz, I don't do UML so I don't know. but I think it should be easy to make it yourself. make use of records
07:25:30 <vincenz> http://www.google.com/url?sa=t&ct=res&cd=4&url=http%3A//www.informatik.uni-bremen.de/uniform/wb/papers/ewk-thesis.ps.gz&ei=M7w7RM6PK5ukiAK6sdDpCw&sig2=_7_l3RlwH4W1EQEVX3jYSw
07:25:40 <dons> morans: oh yeah? what, in this channel?
07:25:41 <vincenz> mahogny: well I doubt tehy really use UML, but some sort of data-structure hierarchy
07:25:48 <dons> i should read the logs to see how they used it
07:25:58 <morans> dons: no, on mud
07:26:09 <morans> dons: the ghc -e bot
07:26:10 <dons> ah . the ghc wrapper.
07:26:14 <shapr> I'd rather see a bunch of domain specific requirements instead of UML or other specs.
07:26:29 <morans> dons: which looks pretty much exactly like the lambdabot UI - enough that no one will notice the changeover
07:26:45 <mahogny> vincenz, well, you would do the relations in a bit different way but I don't see a major problem there
07:26:50 <morans> dons: we have a bunch of bots there anyway for other stuff, so people are used to the basic interface already
07:26:56 * vincenz nods
07:27:31 <dons> morans: also, lambdabot has a command line interface... you could jsut wrap that.
07:27:45 <Quinthius> morans: is this a public mud or just private for friends and stuff?
07:28:10 <morans> Quinthius: it is a United States Department of Energy mud.
07:28:12 <dons> $ echo 'vixen hi cutey pie' | ./lambdabot 
07:28:13 <dons> lambdabot> How cute?
07:28:15 <shapr> morans: wow
07:28:21 <dons> morans: which woudl be scriptable, no?
07:28:24 <shapr> I had no idea the DoE had a mud.
07:28:26 <morans> shapr: google for LabSpace
07:28:43 <morans> shapr: there was a bunch of research in the 1990s(?) 
07:28:56 <morans> basically collaborative research using a lambdamoo engine as the core
07:29:05 <morans> this is kinda the leftovers of that long-gone project
07:29:06 <shapr> Fascinating.
07:30:26 <morans> dons: yeah, thats pretty much my mud/RPC interface anyway
07:30:42 <shapr> I'd like to see Croquet used for that sort of thing.
07:30:44 <morans> dons: feed in what someone just said to it either as args or stdin, and retrieve the response on stdout
07:31:01 <morans> shapr: Croquet?
07:31:56 <mahogny> vincenz, nice digging. that thesis is certainly n00b friendly
07:31:56 <dons> blackdog, did you get vixen-cgi working?
07:32:04 <vincenz> mahogny: haven't looked yet
07:32:07 <vincenz> was slow loading
07:32:46 <blackdog> dons: not on that machine. was playing with runhaskell, but forgot how to get something called as a CGI and just timed out for today.
07:32:50 <mux> http://mu.org/~mux/shuffle2.hs
07:32:53 <mux> any comments on this?
07:32:57 <mahogny> vincenz, I'm impressed that you can get a phd for that thesis, but it sure is useful :)
07:33:10 <mux> I rewrote my previous lame shuffle code using lists with maps this time
07:33:13 <vincenz> mahogny: phd?
07:33:28 <vincenz> mahogny: you sure it isn't a master's?
07:33:29 <mux> and removed nearly every explicit recursion
07:33:40 <mux> following advices in the Haskell Wiki
07:34:06 <dons> ?hoogle String ->  m a
07:34:07 <lambdabot> Prelude.error :: String -> a
07:34:07 <lambdabot> Debug.Trace.trace :: String -> a -> a
07:34:07 <lambdabot> Prelude.fail :: Monad m => String -> m a
07:34:10 <mahogny> vincenz, Doktor der Ingenieurwissenschaften? that's german for phd I think?
07:34:16 <dons> ?hoogle+
07:34:16 <lambdabot> Prelude.read :: Read a => String -> a
07:34:16 <lambdabot> Text.Printf.printf :: PrintfType r => String -> r
07:34:16 <lambdabot> Control.Monad.Error.strMsg :: Error a => String -> a
07:34:23 <vincenz> mahogny: seems so, yeah
07:34:29 <dons> do we have a read in a monad? or was that a dream?
07:35:22 <dons> ah. it was a lambdabot dream! its in lambdabot
07:35:50 * mux benchmarks shuffle.hs against shuffle2.hs
07:36:18 <vincenz> mahogny: heh... the relevant information I need is only a small paragraph
07:36:26 <vincenz> mahogny: last paragraph page 19 :D
07:37:04 <mahogny> vincenz, yeah. saw it :)
07:37:12 <mahogny> vincenz, a bit more meat is required though
07:37:30 <mahogny> vincenz, how much of UML do you use? use cases as well?
07:37:41 <vincenz> mahogny: I doubt they use real uml
07:37:48 <vincenz> mahogny: the concern was the oversightlyness of software 
07:38:20 <vincenz> but if I can draw class diagrams to fp in a one-to-one mapping, then documentation will be facilitated
07:38:46 <mahogny> vincenz, in case they use uml use cases, I would really recommend formal FOL semantics. I have switched over entirelly, mostly because it contains so much more information ready for proving in case you need
07:39:13 <vincenz> mahogny: I'm afraid, not being of CS formation, that I do not know what 'FOL' means
07:39:22 <mahogny> vincenz, first order logic
07:39:35 <vincenz> have any 'newbie' link?
07:39:48 <mahogny> it's usually not very newbie. hmm
07:39:50 <vincenz> I mean for the uml use cases things you discussed
07:39:50 <mahogny> I can dig some
07:39:56 * vincenz groks most things
07:40:14 <vincenz> I have a cs background by hobbyization :D
07:40:22 <mux> heh
07:40:28 <mux> pentane% time ( jot 10000 | ./shuffle > /dev/null )
07:40:32 <mux> 23.72s user 0.05s system 97% cpu 24.475 total
07:40:37 <mux> pentane% time ( jot 10000 | ./shuffle2 > /dev/null )
07:40:40 <mux>  0.65s user 0.00s system 93% cpu 0.698 total
07:40:52 <mahogny> vincenz, http://www.md.chalmers.se/Cs/Grundutb/Kurser/nasem/sempl-2002.pdf   this is how programming languages can be described (contains several ways, not only FOL)
07:41:00 <vincenz> mahogny: thx
07:41:09 <mux> I think shuffle2 wins :-)
07:41:16 <dons> blackdog, heard the new yeah yeah yeahs album  yet? if so, any good?
07:41:24 <mahogny> vincenz, I have found it to be useful for more than programming languages though. in particular network protocols are easily described by those methods
07:41:55 <vincenz> hmm
07:41:56 <blackdog> dons: not heard it. wasn't a massive fan of 'em anyway.
07:41:59 <vincenz> like most courses on semantics
07:42:05 <vincenz> mahogny: I do think that's rather too theoretical for the whole purpose
07:42:09 <blackdog> although apparently her boyfriend's new album is teh cool.
07:42:21 <dons> ah. post-liars?
07:42:40 <blackdog> no, no - drum's not dead, the liars album
07:42:50 <mahogny> vincenz, it's an extremely formal method but I have found good use of it informally used ;)
07:42:51 <shapr> mahogny: FOL for protocols?
07:42:55 <mahogny> shapr, yeah
07:43:19 <mahogny> shapr, it's easy to do proving of properties if you include dropping messages etc
07:43:31 <blackdog> am blasted. g'night don, shapr, the rest of you miscreants...
07:43:31 <vincenz> mahogny: well already preparing the course is going to be out of my work hours... so I'm trying to keep it lite and to the poitn
07:43:39 <dons> ciao blackdog
07:43:40 <shapr> g'nite blackdog 
07:43:41 <mahogny> shapr, and the specifications look very complete when you are done, unlike uml use cases
07:43:50 <shapr> mahogny: Do you have any demonstrations?
07:44:11 <vincenz> mahogny: the purpose is not to completely overthrow existing methods, but to introduce haskell as an alternative for toolwriting
07:44:11 <mahogny> shapr, not in electronic format. at least not very formal stuff
07:44:21 <mahogny> shapr, writing FOL on computer = eew
07:45:08 <mahogny> vincenz, formal semantics is a complement you can introduce later. start by just getting in FP :)
07:45:26 <vincenz> mahogny: the point to get accross is not theory, but a workable practical solution
07:45:38 <mahogny> vincenz, yeah
07:45:47 <vincenz> mahogny: (I work at imec... mostly electronics and embedded software.... theory cs is not the main feed of the day)
07:45:57 <vincenz> and will most likely just disgruntle the people
07:46:08 <shapr> I wish embedded electronics required FOL for specs.
07:46:25 <vincenz> http://www.imec.be 
07:46:25 <shapr> My gf has a DVD player that crashes about half the time when you insert a disc.
07:46:40 <vincenz> shapr: component failure 
07:46:51 <mahogny> vincenz, actually, you should look into FOL later because it mixes extremely well with FP. there is usually a trivial one-to-one mapping between the rules and the implementation so it's very easy to work with if you get over the FOL-part
07:47:13 <vincenz> mahogny: right but the idea of UML (or whatever) is just to have a highlevel documentation/overview
07:47:21 <vincenz> without getting lost in the details
07:47:33 <mahogny> vincenz, yeah. that's the point with documentation ;)
07:47:53 <vincenz> so, at least for now, I don't see any room for FOL, but will look into it myself
07:48:01 <vincenz> however...the book you gave me seems like most semantical books
07:48:04 <vincenz> where is the fol bit
07:48:10 <mahogny> shapr, well. FOL is a bit overkill for hardware. since you usually design it with a state machine, you can quite easily prove everything with induction automatically
07:48:12 * vincenz has read a few others
07:48:20 <mahogny> vincenz, FOL comes a bit late
07:48:25 <mahogny> *later
07:48:29 * vincenz nods
07:48:32 <shapr> I've noticed a similarity between both UML and MP3.. they're lossy compression formats based on 'getting across the general ideas.'
07:48:50 <mahogny> vincenz, you can get good stuff out of it even without going all the way to FOL, just staying with transitions
07:48:55 <vincenz> shapr: UML isn't even executable
07:49:04 <vincenz> afaik
07:49:12 <vincenz> I mean, it's ambiguous
07:49:19 <mahogny> UML with some very messy OCL might be :)
07:49:27 <vincenz> OCL?
07:49:49 <mahogny> object constraint language. you can use it to write requirements on methods
07:49:50 <shapr> I've been trying to come up with other psychology based compression formats, any suggestions?
07:50:01 <vincenz> shapr: jpeg
07:50:04 <vincenz> shapr: mpeg
07:50:32 <vincenz> most lossy graphics/video really
07:50:34 <mahogny> shapr, computer slaps user each time he believes it's actually Madonna who is singing (which is the case)?
07:51:01 <vincenz> mahogny:  I don't think he meant facial compression
07:51:07 <mahogny> :)
07:51:15 <vincenz> :D
07:51:18 <shapr> vincenz: Yeah, but UML and lossy graphics/video are two instances of a more general pattern.
07:51:21 <morans> hmm
07:51:35 <morans> can I install packages to be used by ghc (like hs-plugins) without being root?
07:51:40 <mahogny> I wouldn't consider jpeg a psychological compression format
07:51:41 <morans> and if so, how?
07:51:41 <vincenz> shapr: that humans are used to noise?
07:51:47 <dons> shapr, Chilli gave me an explanation for the evil birds on the .jp haskell textbook: stern faces mean strength and health -- genki
07:51:47 <vincenz> mahogny: it is
07:51:58 <vincenz> mahogny: high frequencies are less encoded
07:52:20 <vincenz> it's frequency based, which is inherently due to the nature of our... hmm right eye
07:52:21 <wchogg> dons:  What about the eyes that gleemed with the lust for human flesh?
07:52:23 <dons> shapr, i.e. this sushi place is very genki: http://www.genkisushi.co.jp/
07:52:32 <mahogny> vincenz, yeah. but that's highly visible and not recreatable; so I dunno if I would classify that as psychological
07:52:35 <shapr> dons: Wow, how'd he know that?
07:52:37 <dons> wchogg, that just shows their strength!
07:52:49 <vincenz> mahogny: can't find the FOL bit in that book :(
07:52:50 <dons> shapr, oh, he lived there for 5 years or so
07:52:55 <mahogny> vincenz, lemme have a look
07:52:57 <shapr> awesome
07:54:17 <mahogny> vincenz, page 22, the box. they don't clearly state it, but it is a kind of FOL
07:54:40 <dons> it all makes sense when you see that sushi site. or think of ito ogami, from the Lone wolf movies
07:54:42 <mahogny> vincenz, actually, one shouldn't be saying FOL but I forgot the name of it
07:56:04 * dons looks at perl.org and at haskell.org
07:56:23 <dons> and python.org
07:56:34 <dons> we need a bit of work. but not much
07:56:45 <dons> and we have more up to date news :)
07:56:57 <shapr> We need more libs and recipes.
07:57:07 <dons> yep
07:57:20 <dons> i'm in the process of porting oleg's code to the Category:Idioms page
07:57:27 <dons> so we're getting a few
07:57:35 <mahogny> someone write a python-to-haskell converter, then start working through the library list? :)
07:57:36 <dons> and I found mayeb 50 missing libs 
07:57:43 <mahogny> bbl
07:57:44 <shapr> fifty?
07:57:49 <dons> mahogny: we already have MissingPy
07:57:53 <dons> the python binding
07:58:02 <dons> shapr, there's lots on Libraries_and_tools, check it out!
07:58:08 <dons> several hundred entries
07:58:17 <dons> well, maybe 200
07:58:46 <vincenz> mahogny: what do you research on?
08:00:18 <dons> what does the (R) mean in: Python®
08:00:26 <dons> on python.org
08:00:26 <shapr> So now we just need cabal-get and to start putting libs onto darcs.haskell.org
08:00:29 <shapr> copyright, I assume.
08:00:42 <dons> is it like Mirand (tm Research Software) ? :/
08:00:49 <dons> Miranda
08:00:56 <vincenz> dons: rights reserved?
08:01:03 <dons> does this mean anything?
08:01:06 <shapr> I think it's just so people don't go around using the name to endorse their own stuff.
08:01:10 <vincenz> yeah
08:01:12 <dons> i'm surprised.
08:01:33 <vincenz> java, tiger, python, ...
08:01:36 <vincenz> all common words
08:01:41 <vincenz> stolen for language
08:02:55 <wchogg> So should new languages names be entirely uncommon words?
08:03:17 <wchogg> That'd be pretty awesome.
08:03:52 <vincenz> well yeah
08:03:54 <vincenz> like brainfuck
08:03:55 <Igloo> It means registered trademark (http://en.wikipedia.org/wiki/Registered_trademark)
08:03:57 <cpatrick> dons: registered trademark
08:04:04 <cpatrick> er, what Igloo said
08:04:10 <vincenz> or compluflatonia
08:04:12 <wchogg> Papers entitled things like "An Implementation of Object-Oriented Functional Programming in Frunlegczthorp (tm)"
08:04:18 <vincenz> :)
08:04:24 <Igloo> And the word is only trademarked within the appropriate field
08:04:33 <vincenz> "Optimizing a borinadina compiler"
08:05:02 <vincenz> "Decrypting the inner works of classes in ckrechghsaf"
08:05:34 <wchogg> "Continuations simulated in Frhagheimer with first class macros."
08:05:35 <vincenz> I especially hate single-lettered langaugenames
08:05:39 <vincenz> they're UNGOOGLABLE!
08:05:45 <vincenz> just try googling for "c++ parser"
08:05:47 <vincenz> and pray
08:06:18 <vincenz> "Flurterfrahnima put to the test"
08:06:45 <vincenz> well I'm reasonably happy with the title of my accepted paper
08:06:48 <vincenz> it sounded nifty enough
08:07:13 <vincenz> Template-Based Semi-Automatic Profiling of Multimedia Applications
08:16:26 <vincenz> ... silence ...
08:16:51 <mahogny> vincenz, got url?
08:18:15 <vincenz> don't know
08:18:26 <vincenz> are we allowed to publish papers on websites that are yet to apppear?
08:18:35 <mahogny> depends on the journal
08:18:36 <morans> "we" ?
08:18:36 <vincenz> (icme2006 is in july)
08:18:45 <vincenz> morans: we the academici
08:19:01 * vincenz wonders
08:19:05 <mahogny> vincenz, the ones who publish on arxiv usually get around the rule by calling the public version a "preprint"
08:19:09 <morans> vincenz: in the grid community it seems fairly common to see papers on websites listed "yet to appear"
08:19:09 * vincenz asks a colleague
08:20:03 <morans> mostly the restriction seems to be that the paper can't have appeared in another refereed journal, if my memory from a year or so ago still works
08:20:38 <mahogny> most larger journals forbid making articles public but if you use the preprint workaround they can't really say much. it's a really horrible rule that should be banned in law
08:20:47 * vincenz hmms
08:20:49 <resiak> Don't suppose anyone has looked at making lambdabot identify with NickServ, have they?
08:20:59 <vincenz> mahogny: I could send you a copy ywith the notice "do not distribute"
08:21:11 <vincenz> we also have the extra issue that wip can not be made public
08:21:16 <vincenz> (we have a patent office)
08:21:24 <mahogny> vincenz, well, if you don't have it preuploaded then let it be. no hassle :)
08:21:28 <vincenz> and paper submissions must go through patent office here first before submission
08:21:42 <mahogny> ouch, bureaucracy
08:21:44 <vincenz> mahogny: it's no hassle
08:21:48 <vincenz> mahogny: well it's not much
08:21:56 <vincenz> mahogny: just put it online in the database in advance
08:21:58 <vincenz> and they approve it
08:22:02 <vincenz> unless it's patentable
08:22:17 <mahogny> patentable=they rip you off? ;)
08:22:17 <morans> timf [to the Fung]: System.IO.Unsafe.unsafePerformIO (appendFile "../public_
08:22:17 <morans>     html/hello.html" ("echelon terrorist bomb"))
08:22:26 <morans> some joker on the mud
08:22:29 <vincenz> mahogny: nah I think they first ask for a patent before submitting
08:22:52 <mahogny> but that costs. who gets the patent?
08:24:28 <vincenz> mahogny: the research center I do my phd at
08:24:33 <mahogny> ah
08:24:36 <mahogny> where is that?
08:24:40 <vincenz> http://www.imec.be
08:24:53 <vincenz> largest electronical research center in europe ;)
08:29:37 <mahogny> bbl
08:45:49 <vincenz> the ugliness of templates: http://www.notvincenz.com/wiki/pmwiki.php/Personal/Templates
08:50:17 <palomer> you should watch out
08:50:29 <semanticphilosop> hi looking for a little help with some RTS issue - getting 
08:50:44 <semanticphilosop> internal error: update_fwd: unknown/strange object 57
08:50:48 <palomer> if ever var leaves its scope, and you have a reference to data, that reference will be garbage
08:51:00 <palomer> you're asking for trouble with that code
08:51:20 <vincenz> palomer: correct allocation was not the relevant issue
08:51:32 <vincenz> the page is updated with a working fix
08:51:35 <vincenz> and a reason why this sucks
08:51:54 <palomer> ddt is the fix of var?
08:52:01 <vincenz> ddt is a pointer wrapper
08:52:04 <vincenz> var is a data wrapper
08:52:11 <semanticphilosop> when I set a heap limit - anyone familiar with this problem?
08:52:12 <palomer> var is dangerous
08:52:15 <vincenz> palomer: not really
08:52:17 <vincenz> var<int>
08:52:18 <vincenz> acts like an int
08:52:31 * vincenz uses it for the paper published to icme
08:52:39 <vincenz> palomer: you mean ddt is dangerous
08:52:51 <vincenz> cause I store an allocated pointer
08:53:03 <vincenz> obviously, correct deallocation is necessary, but again, that was not the issue explored in that particular code a bit
08:53:12 <vincenz> my theory for showing problems is, minimize to the relevant core
08:54:09 <vincenz> anyways, time to head hoe
08:54:11 <vincenz> home 
08:54:11 <palomer> foo i = 0 ; {var<Int> j;  i = j();} //uh oh, if foo::operator= copies by reference, you're screwed
08:54:19 <vincenz> erm
08:54:21 <palomer> foo i = 0 ; {var<foo> j;  i = j();} //uh oh, if foo::operator= copies by reference, you're screwed
08:54:40 <vincenz> palomer: it's intended for POD data
08:54:49 <palomer> POD?
08:54:51 <vincenz> var is correct whenever the type it wraps is correct
08:55:32 <vincenz> fucking work proxy... keeps messing up ssh
08:55:38 <vincenz> palomer: plain old data
08:55:45 <vincenz> palomer: but whenever foo acts correctly, so will var
08:55:45 <palomer> ah, then it's fine
08:55:54 <palomer> if everything is pass by value
08:55:55 <vincenz> however it's less useful with non pod's
08:55:59 <vincenz> cause you can't overload operator.
08:56:13 <vincenz> palomer: what you mean is ... it's dangerous if
08:56:15 <palomer> consider using smart_ptr or scoped_ptr for ddt
08:56:16 <vincenz> var<foo&.
08:56:22 <vincenz> palomer: that's besides the point
08:56:32 <vincenz> the failure is in the template type system
08:56:50 <palomer> I don't see anything wrong with the template system in that case
08:56:59 <palomer> in sml you'd write something similar
08:57:13 <vincenz> palomer: the issue is the need for static_cast!
08:57:17 <vincenz> anyways
08:57:17 <palomer> (for var)
08:57:21 <vincenz> I gotta run or I'll miss my bus
08:57:40 <palomer> run!
08:57:57 <ndm> shapr, google hates you!
09:08:20 <shapr> ndm: eh?
09:08:42 <ndm> shapr, searching for your blog on google reader kept causing google reader to freeze
09:08:45 <shapr> ndm: Because my hits dropped from 25k to 16k?
09:08:48 <shapr> oh
09:08:49 <ndm> but searching for anything else didn't
09:08:54 <shapr> Weird
09:08:58 <ndm> yep, indeed
09:09:07 <ndm> its working again now with your name, but not finding your blog
09:09:16 <shapr> I dunno why.
09:09:35 <ndm> me neither, it found everyone else - i had to add yours by URL
09:20:17 <Philippa> if you've found it I may as well point out there's precious little code talk on my LJ :-)
09:20:55 <dozer> is there a way to thow an exception or error that can be caught later, or is this a feature that's only supported by IO?
09:21:41 <morans> dozer: thats kinda one of the uses of Either, I thought...
09:29:37 <Pegazus> is it possible to define a where for more than one pattern matching line in a function?
09:30:44 <Saulzar> You can use guards
09:31:32 <xerox> Pegazus, it would be equivalent  to define a top-level binding.
09:31:34 <Saulzar> > foo n | n ==0 = foo | n > 3 = "camel" where foo = "emu"
09:31:35 <lambdabot>  parse error on input `|'
09:32:24 <xerox> > let f n | n == 1 = 1 | otherwise = n * f (n-1) in f 10
09:32:25 <lambdabot> 3628800
09:34:18 <Pegazus> foldExp f_cst f_var f_add f_mul (Add a b) = f_add (fold_me a) (fold_me b)
09:34:18 <Pegazus> foldExp f_cst f_var f_add f_mul (Mul a b) = f_mul (fold_me a) (fold_me b)
09:34:18 <Pegazus>     where fold_me = foldExp f_cst f_var f_add f_mul
09:34:31 <Pegazus> i have those 2, and i would like to use the wher in both, is it possible in any way?
09:35:43 <Saulzar> Other way to do it would be to have 1 top level case and use a local let to switch between Add and Mul
09:37:35 <Pegazus> what?
09:37:42 <Pegazus> what's a top level case?
09:39:00 <Saulzar> foldExp f_cst f_var f_add f_mul exp = x   where f = case exp of (Add a b) -> ... (Mul a b) -> ...
09:39:15 <Saulzar> Er, sorry where x = 
09:40:23 <Saulzar> By top level case I mean different versions of your function matched by pattern
09:49:00 <vincenz> re
09:49:59 <bolrod> @arr
09:50:10 <bolrod> erhh
09:50:27 <bolrod> Test.
09:51:16 <Pegazus> mmmmm
09:51:28 <Pegazus> Saulzar: i didn't get it can you explain it again?
09:51:37 <Pegazus> what's a top level case?
09:53:03 <vincenz> xerox: ping
09:53:36 <bolrod> vincenz: solved the problem?
09:53:48 <vincenz> bolrod: what problem?
09:53:54 <bolrod> with that boaty
09:53:57 <bolrod> -y
09:54:58 <lambdabot> This is the END for you, you gutter-crawling cur!
09:55:05 <bolrod> HAHAHA
09:55:07 <bolrod> dang
09:55:11 <bolrod> @arr
09:56:35 <Saulzar> Pegazus, Each of your foldExp lines for example
09:59:09 <Pegazus> mmm
09:59:10 <Pegazus> ok
10:00:40 <lambdabot> Get out of me way, yeh landlubber
10:01:20 <jip> hello haskell!
10:03:26 <bolrod> funny :)
10:04:09 <vincenz> > v
10:04:10 <lambdabot>  Not in scope: `v'
10:04:54 <vincenz> > fix ((:) . 1)
10:04:55 <lambdabot>  add an instance declaration for (Show ([b] -> [b]))
10:06:46 <resiak> Where is the maximum length of lines for lambdabot set?
10:06:59 <SyntaxNinja> w00t
10:07:54 <vincenz> > fix (\(a:b) -> (a+1):a:b)
10:07:55 <lambdabot> Terminated
10:07:59 <vincenz> > fix (\(a:b) -> (a):a:b)
10:08:00 <lambdabot> Add a type signature
10:08:04 <vincenz> > fix (\(a:b) -> (a):a:b) :: Int
10:08:05 <lambdabot> Couldn't match `Int' against `[a]'
10:08:07 <vincenz> > fix (\(a:b) -> (a):a:b) :: [Int]
10:08:08 <lambdabot> Terminated
10:08:18 <vincenz> > fix (\(a:b) -> 0:b) :: [Int]
10:08:18 <lambdabot> Terminated
10:08:22 <vincenz> > fix (\(a:b) -> 0:a:b) :: [Int]
10:08:23 <lambdabot> Terminated
10:08:25 <vincenz> hmm
10:09:08 <vincenz> > fix (\x -> 0:x) :: [Int]
10:09:09 <lambdabot> [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
10:09:09 <lambdabot> 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
10:09:09 <lambdabot> 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
10:09:09 <lambdabot> 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
10:09:11 <lambdabot> 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
10:09:14 <lambdabot> [6 @more lines]
10:10:35 <jip> @type fix
10:10:36 <lambdabot> forall a. (a -> a) -> a
10:10:43 <Excedrin> at work, there's an email thread about a "surprising" facet of C++, one of my co-workers says, "The complexity comes from generic-ness of the problem, and describing abstractions really takes characters and brain cells" regarding a typically long g++ error message
10:11:13 <Saulzar> > take 10 $ fix (\ (~(a: b)) -> 0:0:b) :: [Int]
10:11:14 <lambdabot> [0,0,0,0,0,0,0,0,0,0]
10:11:40 <Saulzar> > take 10 $ fix (\ (~(a: b)) -> 0:b) :: [Int]
10:11:41 <lambdabot> Terminated
10:11:45 <Excedrin> it seems like a good opportunity to mention Haskell, but I'm not sure exactly what I should focus on (perhaps a nice ghc error message for contrast?)
10:12:09 <Philippa> GHC error messages do take a bit of familiarity to read effectively though (currying and all that)
10:12:30 <Philippa> and if you use the extensions that get you a comparable type system then the error messages when you mess up can be horrendous
10:12:44 <Saulzar> Yep, can't match foo against t -> t1 usaully doesn't help most newbies I think
10:12:52 <morans> yeah, ghc errors are hardly the best introduction to haskell
10:13:04 <bolrod> indeed
10:13:10 <Excedrin> ok, good point
10:13:17 <bolrod> I had to work with helium in the beginning of my FP course
10:13:24 <bolrod> it has nice error messages
10:13:34 <Saulzar> Well, at least it does not give you 9 pages of errors and the internals of the library as per templates...
10:13:37 <bolrod> but I went to ghci after like... 1 day.. because I couldn't get it to work on my desktop :D
10:13:42 <bolrod> (linux)
10:14:05 <RyanT5000> do functional programs typically use Model-View-Controller?
10:14:06 <bolrod> Saulzar: you can switch off overloading something blah.. I dont know
10:14:08 <bolrod> ;p
10:14:14 <bolrod> but it does give good error messages
10:14:33 <bolrod> instead of   syntax error at line 400   (in your 399 lines of code)
10:14:35 <bolrod> :x
10:14:41 <Saulzar> Template errors from the stl give you brain damage
10:14:58 <Pegazus> <Saulzar> Template errors from the stl give you brain damage --> you haven seen boost ones if you say that :)
10:15:02 <Pegazus> stl errors are quite nice...
10:15:07 <Saulzar> Hehe, I have :)
10:15:18 <bolrod> what kind of error is that?
10:15:22 <Pegazus> try forgetting an error on a boost::bind
10:15:23 <Pegazus> :)
10:15:23 <Saulzar> Actually boost usually does better, because it has some type assertions
10:15:24 <Excedrin> yea, this one is a "call of overloaded x is ambiguous, candidates are [x1,x2..]"
10:15:43 <Pegazus> try forgetting a parameter on a boost::bind
10:15:47 <Pegazus> you'll end with a single error of like 10 pages...
10:16:00 <bolrod> whats boost :)
10:16:00 <Saulzar> Yeah, I never even try to read such errors
10:16:02 <Pegazus> (and if it is in a nested template structure, i can't tell you how nice it becames)
10:16:14 <Pegazus> Yeah, I never even try to read such errors --> i sometimes need to...
10:16:28 <Pegazus> i like very much boost::bind
10:16:29 <Pegazus> :)
10:16:33 <bolrod> what is it >_<
10:16:34 <bolrod> ;)
10:16:45 <Pegazus> (it provides you with the same capabilitties of haskell for partial "execution" of a function
10:16:46 <Pegazus> )
10:17:23 <bolrod> ic
10:18:44 <Philippa> <RyanT5000> do functional programs typically use Model-View-Controller? <- at the mo there isn't really a well-developed "functional" GUI style (though there's fruit and the whole FRP thing), so MVC's as good a pattern to steal as any other
10:18:59 <Philippa> it's worth considering what you use as your 'objects' though (I'm fond of separate threads myself)
10:19:40 <RyanT5000> hm
10:20:05 <RyanT5000> right now my plan is to have essentially MVC and i'm using "any haskell type" as my "model"
10:20:20 <Philippa> what's your equivalent of a 'message', then?
10:20:32 <RyanT5000> here are my key classes
10:20:36 <RyanT5000> class ViewController controller view where 
10:20:37 <RyanT5000>      update :: controller -> Message -> view -> view 
10:20:37 <RyanT5000>      
10:20:37 <RyanT5000> class ModelView view model scene where
10:20:37 <RyanT5000>      composite :: view -> model -> scene
10:20:56 <RyanT5000> update controller Message view returns a mutated view
10:21:40 <jip> can you guys help me figure out a good type for my problem?
10:21:43 <Philippa> but no update to the controller?
10:21:54 <RyanT5000> hm...
10:21:58 <RyanT5000> right, i think
10:22:08 <RyanT5000> so this might not be isomorphic to actual MVC
10:22:22 <Philippa> indeed, it sounds potentially over-restrictive
10:22:27 <RyanT5000> i guess it should probably update itself
10:22:42 <RyanT5000> well is there really any need to separate model and view?
10:22:43 <RyanT5000> er
10:22:46 <RyanT5000> view and controller
10:22:57 <Philippa> this is one of the reasons I like using threads as a model
10:23:00 <Philippa> yes
10:23:34 <Philippa> suppose I'm writing an IRC client: the controller deals with my commands and with the messages coming off the 'net, the view does GUI or text. I could quite conceivably want to swap views while keeping the same controller
10:23:35 <RyanT5000> oh wait i don't think the controller would necessarily need to change itself
10:23:48 <Philippa> 'cos if that happened it'd want to change the model instead?
10:24:22 <RyanT5000> no, because in that case the controller is reallly the model in a totally new MVC paradigm
10:24:38 <RyanT5000> lol oh yeah i forgot another thing....... i have to be able to mutate the model ;)
10:25:44 <work_metaperl> I have to very basic algorithm analysis questions here: http://sequence.complete.org/node/162   ...i'd appreciate some help on them
10:25:57 <RyanT5000> you know i think this is not necessarily the right way of approaching this
10:26:07 <RyanT5000> i should be looking at what needs to happen without porting MVC
10:26:54 <RyanT5000> ...woah
10:26:57 <RyanT5000> woah woah woah
10:27:08 <RyanT5000> what if you describe the user control path as an arrow
10:27:50 <RyanT5000> if you think about it, MVC forms a diamond, with, counter-clockwise from the bottom, the user, the controller, the model, and the view
10:28:49 <RyanT5000> and messages flow through ccw loops that include the user
10:30:54 <Saulzar> work_metaperl, It's a singly linked list, so in order to attach the left to the front of the right, the left must be traversed to the end
10:31:19 <RyanT5000> what does this mean?
10:31:20 <RyanT5000> (b -> c) -> a b c
10:31:55 <Pegazus> nothing as far as i know O_o
10:32:01 <integral> RyanT5000: a :: * -> * -> *
10:32:08 <RyanT5000> yah thanks integral
10:32:15 <Pegazus> is a b c valid? 
10:32:17 <RyanT5000> yep
10:32:22 <RyanT5000> it's in class Arrow
10:32:23 <Pegazus> what the hell does it means?
10:32:25 <integral> Pegazus: yes, a is a type constructor.
10:32:30 <Pegazus> O_o
10:32:31 <Pegazus> wich one?
10:32:34 <RyanT5000> i always forget to look at the type environment
10:32:56 <integral> Pegazus: eg. newtype Arrow b c = MkArrow b -> c; arr :: (b -> c) -> Arrow b c # for example
10:33:08 <Pegazus> i don't get it
10:33:27 <integral> Pegazus: a stands for some type constructor that can be applied to two types
10:33:35 <Pegazus> aaaaaaaaaaaaaahhhhhhh
10:33:41 <Pegazus> there it has sense :)
10:33:45 <integral> so you have stuff like: data Foobar b c = Foo b | Bar c -- normally called Either :)
10:33:56 <Pegazus> but it's really "foolish" to call a constructor "a"
10:34:08 <RyanT5000> no
10:34:14 <RyanT5000> not when it's a parameter to a class
10:34:14 <Pegazus> it is
10:34:19 <integral> Pegazus: why?  it's a type variable, but with a higher kind
10:34:29 <Pegazus> because you always use it for "templates"
10:34:36 <integral> templates?
10:34:39 <Philippa> yerwhat?
10:34:43 <Pegazus> :)
10:34:45 <Pegazus> generics?
10:34:46 <RyanT5000> http://www.haskell.org/arrows/
10:35:12 <Philippa> yes, it's still a type variable, just one that takes a type constructor that's not been fully applied instead of one that has
10:35:21 <Philippa> and it's a for arrow here, though that could've been better
10:35:49 <RyanT5000> so does anyone with more Arrows experience than me have an idea about whether they could be a viable option to use as a generalization of MVC?
10:37:05 <Philippa> I'm not sure the concept makes sense to me. You *can* do FRP with them (see yampa, fruit), that might be a place to start?
10:37:45 <RyanT5000> alright i'm gonna learn what FRP is all about
10:37:47 <jip> RyanT5000: i'd say "yes"
10:38:02 <jip> RyanT5000: the fruit paper shows examples of how fruit obsoletes MVC
10:38:06 <shapr> d00d, frp r0xx
10:38:10 <RyanT5000> awesome, thanks
10:38:12 <Philippa> jip: got a link to that?
10:38:36 <Philippa> I'd not seen arguments for obsoleting it, only ones for providing a nice place to implement it
10:39:07 <jip> Philippa: http://haskell.cs.yale.edu/frp/genuinely-functional-guis.pdf
10:39:18 <RyanT5000> thanks :)
10:39:26 * shapr reads
10:39:32 <RyanT5000> well i think you don't need change notifications in FP implementations, which takes a lot of the potency out of MVC
10:39:35 <jip> Philippa: in the paper they explicitly refer to MVC and explain how with their method they get all of the benefits of MVC "for free"
10:39:45 <shapr> jip: Page number?
10:40:15 <RyanT5000> i love how excellently fast and stable Acrobat Reader is
10:40:18 <kombinator> fyi, there's a paper that obsoletes fruit
10:40:24 <jip> shapr: page 21
10:40:29 <jip> kombinator: really?
10:40:33 <Philippa> kombinator: in what way?
10:40:42 <Philippa> (better FRP-GUI lib?)
10:40:52 <kombinator> http://www.apocalypse.org/pub/u/antony/work/pubs/ac-thesis.pdf
10:41:09 <kombinator> well, maybe obsoletes is a wron word
10:41:14 <kombinator> supersedes
10:41:20 <jip> "The requirement for multiple views is so common in user interfaces that the Model-View-Controller (MVC) design pattern has emerged as a way to structure imperative ob ject-oriented programs to support multiple views when using imperative GUI toolkits [11]."
10:41:47 <kombinator> http://www.apocalypse.org/pub/u/antony/work/pubs/defense.pdf
10:41:57 <jip> "Fruit is the only toolkit we are aware of that provides multiple active views ?for free?, without requiring any extra forethought or planning by the programmer of the original GUI."
10:42:08 <jip> kombinator: i'll check this out
10:42:11 <kombinator> that's a newer version of this work
10:42:26 <Philippa> oh, that bit. All they mean is that they've got the message flow covered though
10:42:38 <Philippa> That doesn't mean there's nothing you can point at and say "that's a view"...
10:43:15 <shapr> I do wish it didn't require Java.
10:43:40 <RyanT5000> do you wish it required OpenGL?
10:43:44 <RyanT5000> cause that's what i'm about to port it to
10:43:48 <palomer> oh boy, I have an exceedingly simple description of a function but I have no way of computing it
10:43:50 <palomer> :/
10:44:00 <RyanT5000> what's the description?
10:44:12 <Philippa> "return true if the function passed to it terminates and false if it doesn't"? :-)
10:44:34 <RyanT5000> lol
10:44:44 <palomer> hrmph, turns out the description is wrong
10:44:44 <palomer> :/
10:44:53 <palomer> gah!
10:44:58 <palomer> this function is driving me nuts
10:45:22 <shapr> RyanT5000: I very much like the idea of FRP with an OpenGL backend
10:45:25 * jip twists his head sideways
10:45:37 * jip has done quite a bit of FRP with an OpenGL backend
10:45:52 <jip> shapr: i even showed you the screenshots! remember the 3d 4-sphere car :)
10:46:04 <RyanT5000> really now :)
10:46:23 <RyanT5000> cause i want to write a windowing system / game engine fitting that description
10:46:43 <Excedrin> have you looked at Frag?
10:46:53 <palomer> I once wrote a 3D engine, it drew quads on a tube
10:46:56 <jip> i wrote an interactive 3d physical car simulation with yampa and opengl. and i did a tetris with yampa and opengl :D
10:46:56 <shapr> That used FRP? The Haven stuff?
10:46:56 <palomer> nothing more
10:47:01 <shapr> jip: Dude, where's the source?
10:47:16 <jip> shapr: source is on my workstation... but you remember the screenshot, right?
10:47:33 <palomer> dude, where's my car?
10:47:43 <RyanT5000> well, uh, i already see that the bulk of my day will be devoted to reading this dissertation
10:47:57 <shapr> Yeah, I remember the screenshot.
10:48:10 <RyanT5000> does anyone want to make this a "real" project?
10:48:19 <RyanT5000> like with more than just me working on it?
10:49:08 <RyanT5000> basically i'm going to write a 3d engine with a windowing system and a widget library
10:49:39 <jip> RyanT5000: i have some thoughts on a game engine design using haskell+frp for the game scripting component, including gui scripting
10:49:45 <RyanT5000> and TH support for formatting arbitrary haskell datastructures in the windowing system
10:50:07 <RyanT5000> hm
10:51:31 <wchogg> RyanT5000:  Just out of curiousity, but are you developing this on windows or linux?
10:51:36 <RyanT5000> windows :(
10:51:45 <RyanT5000> (i want to actually sell my game)
10:51:47 <jip> for those who missed it
10:51:52 <jip> yampa opengl tetris: http://img220.imageshack.us/img220/5016/hstetris0014es.png
10:52:02 <jip> yampa opengl driving sim: http://img145.imageshack.us/img145/7513/drivedrive0020dn.png
10:52:17 <jip> RyanT5000: no reason it can't be cross-platform, right?
10:52:31 <RyanT5000> right
10:52:37 <RyanT5000> although i don't know what i'm doing on linux
10:52:46 <RyanT5000> and i don't have a reasonable linux dev box set up
10:53:07 <RyanT5000> (i have a couple of freebsd servers and an ubuntu setup)
10:53:25 <RyanT5000> now, one question about scope:
10:53:34 <RyanT5000> is there any reason we need scripting in the actual engine?
10:54:00 <Philippa> script with hs-plugins and who cares anyway?
10:54:00 <RyanT5000> it seems to me that it'd be better to make a plugin system
10:54:06 <RyanT5000> :D
10:54:10 <Philippa> 'cos it'll run just as fast either way
10:54:15 <RyanT5000> yah alright
10:54:19 <jip> the word "engine" is very vague
10:54:22 <RyanT5000> right
10:54:32 <RyanT5000> that's why i'm trying to define/contain it
10:54:45 <RyanT5000> tbh the part i'm interested in right now is the graphics stuff
10:55:01 <Philippa> assume anything that goes out to yampa /can/ be parameterised on
10:55:03 <RyanT5000> i already have a disgusting, but mostly-working, gameplay simulator in C#
10:55:13 <Philippa> once you're doing so, the rest's just a matter of which module you sling stuff in
10:55:24 <Philippa> haskell has major ease of refactoring compared to C++
10:55:29 <RyanT5000> right
10:55:43 <RyanT5000> what are people's thoughts on TH?
10:55:50 <RyanT5000> i like the idea of using it for anything like serialization
10:55:55 <shapr> SerTH
10:56:06 <RyanT5000> right
10:56:13 <RyanT5000> i've looked at SerTH and it looks awesome
10:56:16 <shapr> If you want reloading with hs-plugins, make sure all state can be serialized.
10:56:24 <RyanT5000> but also, for example, scripting bindings could probably be done in TH
10:56:39 <RyanT5000> in addition to doing something like
10:56:40 <shapr> Generate OpenGL bindings from headers?
10:56:46 <RyanT5000> no, not that
10:56:46 <RyanT5000> i mean
10:57:03 <wchogg> Hrmm...I've got a stupid question.  So I was looking at using State to write a little interpreter like in Monads for Functional Programming, but if there are print statements in the mini-language how do I handle interactions between the state monad and IO monad?  Just nest them?
10:57:07 <jip> my idea was a yampa powered visual scripting language
10:57:10 <RyanT5000> like if we wanted Python bindings for our engine
10:57:15 <RyanT5000> export them with TH
10:57:22 <RyanT5000> i dunno, i'm just thinking about stuff
10:57:29 <palomer> omg
10:57:34 <palomer> lyx keeps reverting back to old versions!
10:57:35 <palomer> !!
10:57:45 <palomer> I keep losing work!
10:57:46 <shapr> RyanT5000: How so?
10:57:47 <palomer> lyx sucks!
10:58:07 <RyanT5000> well we could automatically spider our engine's datastructures and generate python code correspondingly
10:58:14 <RyanT5000> (not that i want to script my game in python)
10:58:19 <Philippa> wchogg: monad transformers are your friend
10:58:30 <Philippa> or write a monad with a runMonad func that yields an IO action
10:59:00 <wchogg> Philippa:  Okay, I'll lookup monad transformers.  By name alone that sounds about right.
10:59:18 <Excedrin> are multiple modules allowed in a single file?
10:59:46 <jip> Excedrin: i think it's implementation dependant
10:59:49 <Philippa> Excedrin: not in any haskell implementation I've used
10:59:54 <Philippa> but what jip said
11:01:06 <jip> ok guys i have a big problem
11:01:19 <jip> i'm working on a cpu emulator
11:01:48 <jip> i have a data Instruction = LD Register Regsister | ADD Word8 | XOR Register | ...
11:02:01 <RyanT5000> another TH thing i really want to do is take a datastructure and automatically generate a GUI for it
11:02:04 <jip> now i need some kind of function executeInstruction :: Instruction -> XXX
11:02:14 <jip> problem is i'm not sure what the XXX type should be
11:02:31 <jip> it basicly needs to be some kind of data structure that describes what kinds of modifications need to be done to memory/registers
11:02:32 <wchogg> RyanT5000: It sounds like you're really going to be pushing TH hard.
11:02:41 <RyanT5000> yeah, well i don't see how else to do that kind of thing
11:03:05 <RyanT5000> on the other hand i recognize that i'm the least experienced person here
11:04:06 <Saulzar> jip, You could use a state monad or ST, depending on how you want to represent the memory
11:05:12 <Saulzar> I was thinking about a similar thing. Well, at least one could do compile time reflection for things like a property editor
11:05:16 <RyanT5000> (of course, with the autogenerated GUI, you could use it as the starting point for a gui-designer tool, and they could move/reskin/hide objects)
11:05:24 <RyanT5000> yeah
11:05:27 <jip> Saulzar: yeah, the memory is also a big problem, but i was hoping that i could put off the design of the memory later, and use a general interface to it for now
11:05:43 <jip> Saulzar: basicly the memory is a state with readByte/writeByte "actions"
11:06:54 <Saulzar> If you're worried at all about efficiency then a ST array would seem easiest, I guess you could get away with a list or map to begin with...
11:07:19 <jip> Saulzar: i'm not sure if i should be worried about efficiency, so for now i am not worrying at all about it
11:07:50 <jip> Saulzar: thing is, i want all the code to be real general. for example i want it to be possible later on to add the ability to "rewind" the state of the machine, without modifying the executeInstruction function
11:07:51 <Saulzar> Even with a slow memory impl I'd use a State monad to wrap it up, so maybe using something like ST is not such a huge jump anyway...
11:08:01 <Saulzar> Hmm..
11:08:14 <palomer> ST!
11:08:48 <jip> also, i'd like to not use monads, since i don't fully understand them. i think
11:09:05 <shapr> I can explain them.
11:09:40 <Saulzar> Rewind seems hard, storing masses of old structures would not be fun I think?
11:09:52 <RyanT5000> shapr: if you're going to give a lecture on monads, please do so in the main chatroom :)
11:10:16 <shapr> :-)
11:10:47 <jip> Saulzar: well, the "worker" who calls the executeInstruction, would store the history of all the XXX values, and then during rewind it would figure out how to reverse the effect of each
11:11:15 <Quinthius> RyanT5000: was just scrolling up some, and i assure you you're not the least experienced person here ;)
11:11:16 <RyanT5000> i've come up with a general datastructure for storing that kind of thing, although i don't know how to implement it
11:11:52 <RyanT5000> well thanks quinthius, but i'm still prety new
11:13:35 <Saulzar> jip, Yeah, that sounds a good idea.
11:15:19 <jip> Saulzar: problem is, i'm still totally stuck on what the XXX type should look like
11:16:01 <Saulzar> I'd use a record of the various peices of state you need, eg. the memory, history etc.
11:16:19 <Saulzar> But it's much easier with a State monad :)
11:17:15 <jip> Saulzar: thing is, a LD instruction might need to read a value from memory and put that value into a register. how can i encode this "action" into a value?
11:17:27 <jip> i need some sort of mini-language
11:17:50 <Saulzar> Hmm
11:17:58 <Saulzar> Ok, so you have memory history and a set of registers..
11:18:09 <Saulzar> All of these are going to be needed at the same time
11:20:05 <jip> i can think of something simple but maybe bloated
11:20:41 <RyanT5000> i came up with a datastructure for storing histories like you want to do
11:20:48 <RyanT5000> also, you could try using DiffArray
11:21:16 <jip> i am not interested in history right now. it's just something that i may want to add in the future and i don't want my current design to prevent it
11:21:24 <RyanT5000> good point
11:21:51 <palomer> gah! there must be an alternative to latex
11:21:54 <palomer> this is ridiculous
11:21:55 <jip> i can think of something simple: [(Location, machineState -> Word8)]
11:22:09 <jip> where Location = Memory Int | RegA | RegB | RegC | ...
11:22:09 <RyanT5000> palomer: write a haskell typesetter
11:22:11 <RyanT5000> please :)
11:22:35 <jip> the function in the 2nd part of the tupe is executed, and the result is put in the Location
11:22:41 <jip> this is done for each element in the list
11:22:43 <RyanT5000> hm, something involving literate haskell + TH seems like it could be interestin g:)
11:22:57 <jip> and history can be stored by tracking the previous value of the Location
11:23:48 <jip> so a LD A, B instruction would be converted into: [(RegA, \s -> getRegB s)]
11:24:08 <jip> and a INC A instruction would be converted into: [(RegA, \s -> (getRegA s) + 1)]
11:24:25 <palomer> RyanT5000: that would rock
11:24:28 <palomer> the typesetting monad!
11:24:30 <palomer> who's with me?
11:25:18 <RyanT5000> hm
11:25:33 <RyanT5000> certainly could be :)
11:25:49 <jip> what do you guys think about this?
11:25:55 <RyanT5000> but you'd have to add some syntactic sugar to allow reasonable editing of the text
11:25:58 <RyanT5000> you wouldn't want
11:26:06 <Oejet> palomer: First item: Separate compilation. ;-)
11:26:09 <RyanT5000> typeset "Blah blah blah"
11:26:11 <RyanT5000> over and over
11:27:47 <palomer> ok, now I have a relatively easy  denotational characterisation of a function
11:27:55 <palomer> but no way of computing it
11:27:56 <palomer> hrmph.
11:32:29 <RyanT5000> Yampa is beautiful
11:32:57 <RyanT5000> MVC is like the most degenerate, blasphemous case of it
11:34:11 <work_metaperl> RyanT5000: what is Yampa?
11:34:30 <RyanT5000> Yampa is a library for doing Functional Reactive Programming
11:34:47 <RyanT5000> which is a generalization of event-driven programming combined with realtime programming and signal analysis
11:35:56 <flux__> the tetris mentioned, is the source somewhere neatly available?
11:36:04 <flux__> I just wanna see some code that uses yampa :)
11:36:12 <work_metaperl> so if you wanted to program a game and needed things to happened at certain times, you would take advantage of something like Yampa I suppose.
11:36:20 <palomer> lyx is a piece of _crap_
11:36:34 <RyanT5000> yah, i'm trying to write a game engine
11:39:39 <jip> flux__: the tetris isn't complete as you can see, it just has falling single bricks instead of the actual tetris pieces :) and the code is quite messy
11:40:34 <Saulzar> Only it's not quite as simple as it seems to start, some things are more tricky...
11:42:22 <jip> flux__: i'm pasting the source for you...
11:43:16 <jip> http://rafb.net/paste/results/bvBJgm27.html
11:45:16 <jip> this code can probably be cut down to 1/3 of it's size
12:09:38 <jip> hm.... it won't work :\
12:12:01 <dozer> jip: welcome to the wonderful world of coding
12:13:06 <jip> dozer: i meant what i described earlier :)
12:14:19 * dozer discovers "earlier" has scrolled off the top of the IRC buffer
12:15:21 <jip> yeah, you weren't here. but are you very experienced in haskell?
12:16:48 <dozer> jip: I've been coding since ... Thursday last week
12:17:12 <jip> oh.... are you maybe some kind of super genious?
12:17:27 <dozer> na - more like super desperate
12:18:33 <dozer> what is it you're trying to do?
12:19:19 <jip> i'm looking for an appropriate type for the result of executing an instruction in my cpu emulator
12:19:59 <pierre-> hello.
12:20:01 <dozer> jip: and it's not some byte-string?
12:20:40 <jip> dozer: no, it needs to be an "instruction manual" that describes what operations to perform on the registers and memory
12:21:22 <dozer> jip: so capture in a data-structure a description of the operation, the before-state and the after-state?
12:22:08 <RyanT5000> jip
12:22:14 <RyanT5000> your virtual machine is a monad
12:22:16 <jip> dozer: no... i think i need some sort of combinator that will allow me to combine operations like readRegister, writeRegister, readMemory, writeMemory
12:22:23 <RyanT5000> the result of executing an instruction is an action in that monad
12:22:56 <dozer> RyanT5000: that sounds right for the operational semantics
12:23:19 <RyanT5000> what's the complete state of your machine?
12:23:37 <RyanT5000> an array of bytes, and a set of registers/
12:23:38 <RyanT5000> ?
12:23:55 <RyanT5000> or are you also simulating caching mechanisms and peripherals and such
12:24:57 <jip> RyanT5000: the array of bytes has some weird properties like some areas are echoed and some input ports are connected to some memory areas, but in terms of the cpu this shouldn't matter, it just reads/writes to memory
12:25:11 <dozer> RyanT5000: but if you want a specification as well, then something like GADT may be the way to go? Then you can prove properties of combining these instructions
12:25:33 <jip> hm... i think i know what i need, some sort of monad
12:30:00 <RyanT5000> er sry, i was away for a minute
12:30:36 <RyanT5000> and i must say i'm not really familiar with GADts
12:30:39 <RyanT5000> *GADTs
12:39:14 <RyanT5000> jip: what SDL binding did you use for your tetris?
12:39:25 <RyanT5000> ... wait
12:40:01 <RyanT5000> nvm, which did you use?
13:16:04 <jyp> @quote
13:16:05 <lambdabot> No quotes yet.
13:16:36 <jyp> @vixen How's that you don't know quotes?
13:16:36 <lambdabot> yeah, i know
13:17:13 <RyanT5000> wtf jyp and jip
13:17:19 <araujo> hello
13:17:56 <jyp> RyanT5000: We're two different persons :)
13:18:13 <RyanT5000> yah i didn't know :P
13:18:17 <RyanT5000> is there a monad that lets me do stuff simmilar to newIORef?
13:18:31 <RyanT5000> (didn't know whether you were or not)
13:18:34 <jyp> ST ?
13:18:41 <araujo> @hoogle newIORef
13:18:41 <lambdabot> Data.IORef.newIORef :: a -> IO (IORef a)
13:18:56 <jyp> @hoogle stref
13:18:57 <lambdabot> Data.STRef :: module
13:18:57 <lambdabot> Data.STRef.STRef :: data STRef s a
13:18:57 <lambdabot> Data.STRef.modifySTRef :: STRef s a -> (a -> a) -> ST s ()
13:19:04 <jyp> @hoogle newstref
13:19:04 <lambdabot> Data.STRef.newSTRef :: a -> ST s (STRef s a)
13:19:12 <RyanT5000> ah, thanks
13:19:17 <RyanT5000> what does "strict" mean in that sense?
13:19:44 * jyp won't talk about strictness for a while
13:23:05 <sethk> hey, all, I'm getting a stack space overflow with a message saying use +RTS -Ksize to increase it.  Those are compile time switches?
13:24:04 <ulfdoz> sethk: Yes.
13:24:05 <jyp> sethk: they are run-time switches
13:24:22 <ulfdoz> Oh, ehm. ashamed I'll shut up.
13:24:47 <jyp> If you pass those to GHC, it will increase the stack space at compile time.
13:24:49 <sethk> actually it looks like they are compile time switches that effect run time behavior, if I read this correctly
13:25:33 <resiak> ISTR that there is a function equivalent to \f -> f *** f, but I can't find it.
13:25:47 <jyp> :t ***
13:25:51 <jyp> @t ***
13:25:51 <lambdabot> Maybe you meant: time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type .
13:25:55 <jyp> @type ***
13:25:56 <lambdabot> parse error on input `***'
13:26:06 <jyp> @type (Control.Arrow.***)
13:26:07 <lambdabot> forall (a :: * -> * -> *) c' c b' b.
13:26:07 <lambdabot>         (Arrow a) =>
13:26:07 <lambdabot>         a b c -> a b' c' -> a (b, b') (c, c')
13:26:23 <jyp> @type (\f -> f Control.Arrow.*** f)
13:26:24 <lambdabot> forall (a :: * -> * -> *) b c.
13:26:24 <lambdabot>            (Arrow a) =>
13:26:24 <lambdabot>            a b c -> a (b, b) (c, c)
13:26:35 <jyp> @hoogle a b c -> a (b, b) (c, c)
13:26:36 <lambdabot> No matches, try a more general search
13:26:40 <resiak> I couldn't find it with my lambdabot either :)
13:27:09 <resiak> Basically, I have a list of pairs of FPSs, and I want to unpack them all. map (unpack *** unpack) works, but
13:28:28 * araujo just applied a patch to himerge
13:28:40 <jyp> @hoogle (b -> c) -> (b, b) -> (c, c)
13:28:41 <lambdabot> Data.Graph.Inductive.Query.Monad.(><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
13:30:13 <resiak> Ah, never mind. :)
13:31:40 <jlhamilton> @pl \x -> x * x
13:31:41 <lambdabot> join (*)
13:36:11 <resiak> How can I find which package this join is in? The only one my googling is finding is from Control.Monad
13:36:45 <jyp> @index join
13:36:45 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
13:36:46 <jip> RyanT5000: Lemmih's bindings
13:37:34 <RyanT5000> hm, i was having an issue with it crashing
13:38:15 <resiak> Okay.
13:38:41 <jyp> @pl \f -> \(x,y) -> (f x, f y)
13:38:41 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
13:40:26 <jyp> @pl \f -> \C x y -> C (f x) (f y)
13:40:26 <lambdabot> flip =<< ((flip . ((.) .)) .) . flip (.)
13:40:28 <RyanT5000> is there any way to save the internal state of an ST monad?
13:40:56 <jyp> save to disk?
13:41:13 <RyanT5000> not necessarily
13:41:34 <jyp> Well, I think you cannot observe the state
13:41:36 <RyanT5000> just like run a computation in it
13:41:40 <RyanT5000> then go back
13:41:48 <RyanT5000> and run a different computation from the same original state
13:42:04 <jyp> You can compose computations that need to run in sequence
13:42:11 <RyanT5000> no i don't want them to run in sequence
13:42:16 <RyanT5000> i want to have state A
13:42:21 <RyanT5000> then run computation x
13:42:26 <RyanT5000> which produces state B and some output
13:42:36 <RyanT5000> then i want to take state A, again, and run computation y
13:42:42 <RyanT5000> producing state C and some output
13:43:19 <jyp> You realize it's exactly equivalent to run x and y in sequence...
13:43:32 <RyanT5000> no...
13:43:45 <RyanT5000> A shouldn't ever change
13:43:53 <RyanT5000> so let's say A = {x = 5}
13:43:56 <RyanT5000> er
13:44:00 <RyanT5000> bad choice of variable name
13:44:01 <jyp> You want to be able to backtrack ?
13:44:04 <RyanT5000> yes
13:44:12 <Excedrin> saying "state" in that context is confusing, because it sounds like you're talking about something that's mutable
13:44:37 <jyp> well it's not possible with ST
13:44:42 <RyanT5000> alright, thanks
13:44:46 <RyanT5000> that's what i wanted to know :)
13:44:48 <Excedrin> but your A, B, C example can be done without the ST monad in a pure functional way
13:44:56 <RyanT5000> right
13:46:31 <jyp> I think there is a backtracking monad transformer, somewhere.
13:46:45 <jyp> Oleg is one of the authors, iirc.
13:47:01 <RyanT5000> hm; i'm still trying to figure out exactly what i want, too
13:47:10 <jyp> k :)
13:47:14 <RyanT5000> i'm thinking about implementing Undo/Redo in a data-neutral way
13:47:20 <RyanT5000> data- and operation-neutral
13:47:56 <RyanT5000> and basically i'm writing a user interface for game, although the way the game works it's essentially a document editor
13:48:05 <RyanT5000> (there's nothing even remotely real-time)
13:48:38 <RyanT5000> i may or may not use Yampa
13:48:52 <RyanT5000> but i'm definitely going to implement the GUI as an arrow graph
13:49:21 <jyp> kudos :)
13:49:43 <RyanT5000> so anyway i'm trying to figure out if maybe i can apply Undo/Redo stuff in a really global way
13:49:51 <RyanT5000> like what if there was functionality to undo moving a window
13:50:11 <RyanT5000> i mean, you wouldn't generally want to expose that to the user
13:50:15 <Excedrin> turn based game?
13:50:17 <RyanT5000> yeah
13:50:26 <RyanT5000> it's report-oriented
13:50:29 <RyanT5000> you download a report file
13:50:38 <RyanT5000> then you form your command file, which you upload
13:50:45 <RyanT5000> like the old-school games
13:50:59 <RyanT5000> i forget the really ancient one on like a PDP-11 that was like that
13:51:06 <RyanT5000> it was like the first strategy game ever or something :P
13:51:24 <RyanT5000> anyway mine is the same idea except with pixel shaders :P
13:51:53 <RyanT5000> i'm thinking about doing the engine as an open-source haskell project
13:52:00 <RyanT5000> at least the windowing/rendering system
13:52:11 <RyanT5000> i don't think there's any good OSS 3d windowing system at all, much less in haskell
13:52:35 <RyanT5000> (i use the word 'good' very strongly there, because my game needs windowing capabilities on par with office apps)
13:53:10 <Excedrin> Empire
13:54:45 <RyanT5000> anyway i started off with ModelViewController
13:55:02 <RyanT5000> now i'm thinking about yampa/arrows
13:55:54 <jip> kombinator: that slideshow seems to be based on a paper i read that goes into detail for each of the concepts that they talk about
13:56:26 <jip> kombinator: http://www.apocalypse.org/~antony/work/pubs/ac-thesis.pdf
13:57:51 <RyanT5000> oh and what's the deal with all this arrow syntax stuff
13:57:57 <RyanT5000> why don't we just use a graph notation?
13:58:15 <RyanT5000> or am i the only one who is going to draw out all my static arrow graphs anyway?
13:58:26 <jyp> Everyone does it.
13:59:03 <jyp> Would be nice if you implemented a GUI for arrow code edition :)
13:59:26 <RyanT5000> actually, that's the first thing that came to my mind when i read about arrows
13:59:29 <RyanT5000> i'd love to do that
13:59:31 <RyanT5000> once my game is done :)
13:59:36 <jyp> Maybe as a hIde plugin ?
13:59:46 <RyanT5000> maybe
13:59:49 <palomer> someone give me a term in the SKI calculus which has no type
14:00:00 <RyanT5000> but my game's windowing/composition engine will help with that anyway
14:00:07 <jyp> @google term in the SKI calculus which has no type
14:00:09 <lambdabot> http://burks.bton.ac.uk/burks/pcinfo/progdocs/plbook/function.htm
14:00:26 <dozer> I am confused by Data.Map.lookup
14:00:36 <vincenz> AHA!
14:00:45 <jyp> dozer: Aha!
14:00:48 <vincenz> @type lookup
14:00:49 <lambdabot> forall b a. (Eq a) => a -> [(a, b)] -> Maybe b
14:00:49 <palomer> grr, lambdabot is dead
14:00:53 <RyanT5000> oh huh could i use a Map in sort of the same way as the state of a ST?
14:01:01 <vincenz> @type Data.Map.lookup
14:01:02 <lambdabot> forall a (m :: * -> *) k.
14:01:02 <lambdabot>        (Ord k, Monad m) =>
14:01:02 <lambdabot>        k -> Data.Map.Map k a -> m a
14:01:07 <palomer> > let s = \x y z -> x z (y z) ; k = \x y -> x in s k k
14:01:08 <lambdabot>  add an instance declaration for (Show (t -> t))
14:01:11 <vincenz> dozer: easy
14:01:17 <jyp> RyanT5000: yup.
14:01:18 <vincenz> it looks up a key and returns a value, in any monad
14:01:24 <palomer> > let s = \x y z -> x z (y z) ; k = \x y -> x in s (k k) k k
14:01:24 <lambdabot>  add an instance declaration for (Show (t -> t1 -> t2 -> t3 -> t2))
14:01:41 <palomer> > let s = \x y z -> x z (y z) ; k = \x y -> x in s s s k
14:01:41 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
14:01:41 <lambdabot>   Expected type: ((t -> t1) -> t2 -> t3) -> (t -> t1) -> t2
14:01:41 <lambdabot>   Inferred type: ((t -> t1) -> t2 -> t3) -> ((t -> t1) -> t2) -> (t -> t1) -> t3
14:01:46 <dozer> vincenz: I guess the problem is I don't get what "in any monad" means
14:01:59 <palomer> which isn't lambdabot responding to private messages?
14:02:02 <jyp> dozer: what you want is coerce the monad to Maybe.
14:02:10 <vincenz> dozer: well
14:02:16 <vincenz> dozer: if it finds a key, it retunrs it
14:02:20 <vincenz> dozer: if it fails, it fails in that monad
14:02:27 <vincenz> dozer: for the Maybe monad, return = Just value, fail = Nothing
14:02:37 <vincenz> dozer: for the List monad, return = [value], fail = []
14:02:43 <RyanT5000> is there something like Map except without a specified key type?
14:02:45 <vincenz> so depending of which context
14:02:48 <vincenz> it will fail appropriately
14:03:31 <jyp> RyanT5000: Map is polymorphic already.
14:03:43 <jyp> RyanT5000: I guess you mean something broader?
14:03:50 <RyanT5000> i want it to generate keys for me
14:04:04 <RyanT5000> so i want a map, except instead of saying insert "location" "value"
14:04:10 <dozer> vincentz: ah ok - so how do I communicate that I want "instance aMap" to be executed in the Maybe monoid? "Maybe (instance aMap)"?
14:04:14 <RyanT5000> i say insert "value" and i get a location out
14:04:58 <RyanT5000> basically i want a structure that will allocate variables for me, just like ST, except it does so by returning a new state of itself
14:05:13 <vincenz> dozer: by making sure the return type is used as a Maybe
14:05:26 <jyp> RyanT5000: You need a "unique" supply.
14:05:37 <jyp> @hoogle unique
14:05:38 <lambdabot> Data.Unique :: module
14:05:38 <lambdabot> Data.Unique.Unique :: data Unique
14:05:38 <lambdabot> Data.Unique.hashUnique :: Unique -> Int
14:05:38 <vincenz> case lookup k map of Just value -> .. | Nothing -> ...
14:05:39 <RyanT5000> yah, i was about to ask about that
14:05:45 <RyanT5000> but Unique operates in a monad
14:05:53 <RyanT5000> i want it to be built-in to the map
14:06:00 <RyanT5000> i don't even want to be able to insert things by key
14:06:10 <vincenz> RyanT5000: easiest is to use a state monad
14:06:28 <vincenz> and then something like
14:06:34 <RyanT5000> yah, but i want the type to represent the state of the monad, not an action in the monad
14:06:45 <vincenz> create = v <- get; put (increment v); return v
14:07:32 <RyanT5000> hm
14:07:40 <RyanT5000> oh wait
14:07:41 <vincenz> increment being custom logic
14:07:59 <RyanT5000> what if i make my arrow graph recreate itself in each iteration?
14:08:07 <RyanT5000> that might be a more general form of what i'm trying to do
14:08:14 <RyanT5000> and it might not be inefficient, if done right
14:08:24 <RyanT5000> so what if each arrow returns the next-iteration copy of itself?
14:10:54 <RyanT5000> arrow :: a -> (b, arrow)
14:11:21 <shapr> That's how the collection arrows work.
14:12:14 <RyanT5000> so i don't actually need any state variables in my arrow graph!
14:12:24 <RyanT5000> i can just have the arrow graph encapsulate the state
14:13:15 <shapr> Automata arrows also return next-iteration copies, I think.
14:13:21 <shapr> g'day blackdog 
14:13:31 <RyanT5000> interesting
14:13:38 <shapr> blackdog: I checked out the two mp3s from ninetynine, but it's not for me.
14:13:40 <dozer> yay! got my first higher-order function compiling
14:13:43 <dozer> thanks for the help with Map
14:13:56 <RyanT5000> do you have any thoughts of that as a mechanism for running a GUI?
14:14:35 <shapr> Somebody built a purely arrow-style GUI on top of wxHaskell some months ago...
14:14:45 <shapr> They ran into the blackbox problem independently.
14:14:53 <RyanT5000> what's the blackbox problem?
14:15:15 <RyanT5000> is that the one i'm describing?
14:16:36 <shapr> Blackbox/blackhole is about the inability to lift a function into an arrow and retain the shortcut properties of the arrows.
14:17:11 <RyanT5000> shortcut properties? (sorry; i just spent a few hours reading about arrows but i'm still not totally up to speed)
14:17:44 <RyanT5000> is that like how you can use "first" to combine an arrow the null arrow to process a pair (a, c) -> (b, c)?
14:19:46 <dozer> how would I go about generating a function that hides a counter?
14:19:46 <shapr> RyanT5000: http://www.haskell.org/tmrwiki/ArrowsIntroduction
14:20:05 <dozer> I want next_num to return 0 on the initial invocation, 1 on the next one, and so on
14:20:20 <dozer> but be a unit function (not pass n-1 into it)
14:20:39 <jip> shapr: i did some expiriments with a yampa interface to gtk2hs
14:22:12 <shapr> > take 5 $ iterate (+1) 1
14:22:13 <lambdabot> [1,2,3,4,5]
14:22:40 <shapr> dozer: oops, I didn't make it start with zero... can you fix it? :-)
14:22:51 <jip> > take 5 $ iterate (+1) 0
14:22:52 <lambdabot> [0,1,2,3,4]
14:23:09 <shapr> jip: Yeah, but the idea is to let newbies figure out the next step ;-)
14:23:16 <jip> oh
14:23:32 <jip> i guess i should get some sleep
14:25:18 <esap> The blackbox problem can be solved by leaving out 'arr' from the Arrow interface, and replacing it with something else.
14:26:39 <esap> Like having returnA natively in the Arrow interface.
14:30:06 <dozer> should I be using the State Monad?
14:30:15 <dozer> and capturing my counter inside the State?
14:32:40 <jip> argh where is Cale when you need him :\
14:36:39 <JohnnyL> > take 12 $ iterate (+2) 1
14:36:40 <lambdabot> [1,3,5,7,9,11,13,15,17,19,21,23]
14:36:48 <JohnnyL> > take 12 $ iterate (+1) 1
14:36:49 <lambdabot> [1,2,3,4,5,6,7,8,9,10,11,12]
14:37:08 * JohnnyL likes newbie examples.
14:37:28 <JohnnyL> does haskell handle reg exprs?
14:38:42 <jip> JohnnyL: import Text.Regex
14:40:41 <jip> @hoogle Regex
14:40:41 <lambdabot> Text.Regex :: module
14:40:41 <lambdabot> Text.Regex.Regex :: data Regex
14:40:41 <lambdabot> Text.Regex.Posix.regExtended :: Int
14:43:31 <dozer> johnyL: yeah - we can make an infinite list of stuff, but I still don't see how to get from that to...
14:43:59 <dozer> johnyL: c = makeCounter() ; i = next c ; j = next c; k = next c
14:44:14 <dozer> johny: and get i to be 0, j to be 1, j to be 2 and so on
14:45:38 <JohnnyL> i can see using lisp closures on how to hide a counter. but haskell's Show goes for just about every primitive. so I don't know.
14:46:27 <JohnnyL> dozer, why are you asking questions intended for #c?
14:47:01 <dozer> ???
14:47:01 <lambdabot> Maybe you meant: . id pl wn
14:51:50 <vincenz> dozer: you use a state monad
14:52:19 <vincenz> nextValue = x <- get; put <- (dosomethingtomakesomethingnew x); return x
14:52:22 <vincenz> and then in your code
14:52:25 <vincenz> i <- nextValue
14:52:29 <vincenz> j <- nextValue
14:52:33 <vincenz> k <- nextValue
14:52:57 <dozer> vincenz: thanks - looks like I need to learn to play with monads then
14:58:16 <kombinator> jip: yes, the slides are from the defence of the paper
14:59:18 <jip> kombinator: it's cool stuff, especially the "more"/"fewer" part
15:01:49 <vincenz> dozer: get and put are the basic actions of the state monad
15:02:01 <vincenz> dozer: then you can easily create a monadic function that does the subsequent creation of new values
15:02:24 <vincenz> dozer: you could also start the state with an infinite list
15:02:28 <vincenz> and then pop off a value each time
15:02:29 <vincenz> like this
15:02:40 <vincenz> nextValue = x:xs <- get; put xs; return x
15:02:45 <vincenz> nextValue = do    x:xs <- get; put xs; return x
15:02:53 <vincenz> obviously do at all times
15:03:27 <dozer> thanks - will give that a go
15:05:31 <Pebblestone> Hi, all. I'm testing my ERC.
15:10:15 <kombinator> jip: you mean, passing the state as continuations?
15:11:12 <jip> kombinator: yeah, and the whole parallel switching shit. i don't understand it but i appreciate it's sweetness :)
15:11:43 <freegoldbar> Hi. I'm really impressed with the modern haskell language definition because it allows use of Unicode everywhere. Unfortunately I'm finding it difficult to find an implementation that actually implements Unicode. First I tried to download VisualHaskell (because Visual C++ and C# allows Unicode I thought VisualHaskell might as well, not so but it is also only alpha), then I downloaded a snapshot of GHC 6.5 because I was told it implements Unicode,
15:11:43 <freegoldbar> but when I tried in ghci to use Unicode to define some operators and identifiers it gave me some strange error messages. I've now downloaded darcs and is trying to get JHC, because I have read that it might support Unicode, but I only have a 64Kbit line and I'm wondering if I am wasting my time?
15:12:15 <kombinator> I don't remember if I fully understood parallel switching, but 'normal' switching is ok;)
15:13:59 <jip> kombinator: yeah, i actually don't think that parallel switching is supposed to be that complicated. it's just that the pSwitch function takes like 5 high order functions as arguments and these also work with high order functions... you just need to sit down and figure out exactly what's going on there :)
15:14:36 <jip> freegoldbar: you want to use unicode characters inside your haskell source code?
15:15:00 <freegoldbar> Sure, I do that in C++ already
15:15:16 <freegoldbar> and in C# and Mathematica
15:15:18 <kombinator> freegoldbar: If all you want is unicode in string literals then hugs should work as well
15:15:19 <shapr> freegoldbar: I think JHC does support Unicode sources, but I'm not 100% sure.
15:16:16 <freegoldbar> Ok good it takes quite some time to get JHC, that's why I'm asking. Thanks.
15:16:23 <vincenz> freegoldbar: oy
15:16:27 <shapr> And it takes a loong time to build JHC and its libs.
15:16:28 <vincenz> freegoldbar: does c++ even support unicode?
15:16:32 <jip> i can maybe accept using unicode in comments, but for function names and operator names i think that the potential for things to go crazy is too much
15:16:43 * vincenz agrees with ji
15:16:45 <vincenz> jip
15:16:46 <freegoldbar> Well some implementations do.
15:17:07 <vincenz> freegoldbar: why? a) it's non portable compiler wise b) it's not always portable editor wise c) it can be harder to read... d) it can be even harder to edit
15:17:32 <RyanT5000> maybe if you want chinese variable names?
15:17:44 * vincenz shudders
15:17:44 <RyanT5000> otoh, just force your dev team to learn english :P
15:17:55 <vincenz> RyanT5000: talk about unreadable code
15:18:01 <vincenz> RyanT5000: why not arabic, a bunch of squiggly lines
15:18:12 <RyanT5000> lol well it's readable to chinese/arabic people resp.
15:18:13 <psi> :)
15:18:28 <ihope> > (Î»Î± â Î± Ã· 2) Ï
15:18:29 <lambdabot>  lexical error
15:18:31 <freegoldbar> Yeah, I know. But I have been using Mathematica, so I don't care to be forced to use English in my programs anymore
15:18:41 <pejo> Ryan, I bumped into some german source code. It was a lot harder to fix than I could imagine actually, and I do have some knowledge about the german language.
15:19:02 <RyanT5000> yeah
15:19:04 <shapr> I've hacked on JIS encoded Haskell sources.
15:19:12 <RyanT5000> OSS should probably be in english regardless of what it does
15:19:18 <RyanT5000> unless it's actually language-specific
15:19:43 <dozer> RyanT5000: sure - but the ability to use the "right" symbols is a definite boone
15:19:51 <shapr> Yeah, I would like real lambdas.
15:19:52 <RyanT5000> yeah
15:20:02 <RyanT5000> that's true
15:20:10 <psi> I always use english in my code. the language themselves often contain a lot of english terms anyway, and I don't like to mix.
15:20:11 <freegoldbar> and greek symbols in formulas are nice too.
15:20:18 <psi> languages*
15:20:41 <JohnnyL> ihope, woah, how'd you do those funky symbols, is that ansi?
15:20:48 <RyanT5000> [A-Za-z_][A-Za-z_0-9]* ftw :P
15:20:56 <ihope> It's UTF-8 as far as I know.
15:21:10 <psi> has anyone heard of the timber language?
15:21:22 <ihope> @google timber language
15:21:24 <lambdabot> http://www.cse.ogi.edu/PacSoft/projects/Timber/Timber-2002-04.pdf
15:21:24 <shapr> Yeah, Timber is being developed at LtU these days, isn't it?
15:21:31 <shapr> Timber is the successor to O'Haskell, I think?
15:21:54 <psi> shapr: yeah, afaik my lecturer in the real-time systems course I'm taking is the main developer of the compiler
15:21:55 <RyanT5000> why does anyone want object orientation in haskell?
15:22:00 <psi> shapr: yeah
15:22:05 <RyanT5000> i'm becoming more and more negative about oop in general
15:22:17 <RyanT5000> and i spent my whole life up until now writing in C++
15:22:20 <shapr> psi: Is that pejo? or Nordlander(sp?)?
15:22:27 <psi> nordlander
15:22:41 <shapr> Yeah, Timber is neat stuff.
15:22:57 <shapr> I still haven't gotten around to reading all the related publications, but I probably will one day.
15:23:01 <psi> we're looking at the concepts timber is based upon right now, although we're using C :)
15:23:10 <RyanT5000> i don't see the point of C++'s operator .
15:23:19 <pejo> I'm just an innocent bystander. Nordlander and his mates deserve the credit.
15:23:31 <RyanT5000> x.go() would be just as readable go(&x)
15:23:45 <mahogny> RyanT5000, OO, not including methods, is easy to reason about without going into language technicalities
15:23:47 <jip> RyanT5000: virtual functions
15:23:50 <dozer> RyanT5000: well, I guess if you expose to the programmer stack vs heap allocation, you get exactly what you deserve syntactically and at run-time
15:23:59 <RyanT5000> the only reason virtual functions are useful
15:24:03 <RyanT5000> is because there's no higher-order functions
15:24:14 <psi> shapr: I just wish the compiler was available.
15:24:22 <pejo> Ryan, if oop = c++ to you then you have a whole bunch of concepts put into objects. Like a crappy module system, for example.
15:24:50 <shapr> It isn't?
15:25:01 <mahogny> RyanT5000, neah. I think haskell type classes rather than higher order functions is the proper replacement of virtual functions, unless you are refering to callbacks
15:25:01 <RyanT5000> i'm not quite sure what you mean pejo, but i've worked in other supposedly OOP languages too
15:25:16 <psi> apparently not. I asked him and he said they hadn't released it yet.
15:25:18 <RyanT5000> well dynamic polymorphism is useful, i will certainly admit
15:25:38 <RyanT5000> there are really not that many times i've had to use it, except that the static type system in C++ isn't strong enough
15:25:43 <pejo> shapr, "real soon now". 
15:25:58 <RyanT5000> but virtual functions are unnecessary; they're just function pointers anyway
15:26:16 <RyanT5000> so all you do is define a function theFunc at toplevel
15:26:22 <RyanT5000> which calls the appropriate function pointer
15:26:28 <dozer> the OO in Java supports funkey things like loading in classes that implement an interface dynamically at run-time, using them for a bit and throwing them away again
15:26:30 <mahogny> in theory, they don't have to be function pointers
15:26:31 <RyanT5000> and voila, you have the same effect, and even the same syntax
15:27:02 <RyanT5000> of course they don't have to be function pointers, but they certainly can be
15:27:15 <RyanT5000> also, with the scheme i just described, you can have turing-complete dynamic polymorphism
15:27:15 <mahogny> dozer, that, on the other hand, more or less requires the .class-files which isn't very nice if you ask me
15:27:33 <RyanT5000> i.e.: you could have the function called depend on the dynamic type of two different objects
15:27:41 <RyanT5000> so like theFunc a b depends on the type of both a and b
15:27:52 <dozer> well, it requires some dynamic loading together with dynamically discovering that a loaded type is of a type compattible with your interface
15:27:53 <RyanT5000> there's no way to do that in C++
15:28:22 <RyanT5000> i bet you can do dynamic classloading in haskell pretty easily
15:28:30 <RyanT5000> hell, you can even do it in C++
15:28:43 <mahogny> RyanT5000, CPS might be an even nicer alternative
15:28:51 <RyanT5000> CPS?
15:28:54 <jip> RyanT5000: remember that c++ is supposed to be close the the hardware, all features can have a straight-forward implementation
15:29:11 <RyanT5000> yeah i know jip, but that doesn't end up being so true anyway
15:29:13 <mahogny> RyanT5000, continuation passing style. something really functional and fucked up, but it works nice in practice
15:29:21 <RyanT5000> no i know about CPS
15:29:27 <RyanT5000> i don't see how it relates to dynamic classloading
15:30:03 <mahogny> you can hide away the object a method works on and hence obtain type similarity between a range of classes. if you do it the right way
15:30:26 <RyanT5000> yeah
15:30:28 <i|> > (218340923185012743^18239582043230) `mod` 2
15:30:32 <lambdabot> Terminated
15:30:50 <RyanT5000> heh, you'd have to write that one yourself :)
15:31:05 <RyanT5000> (responding to i|
15:31:07 <RyanT5000> )
15:32:20 <mahogny> RyanT5000, something that I have found completely unbeatable is the ability to store functions in lists. for example, I recently wrote a system for undo/redo that is extremely memory efficient (and speed efficient to some extent) in some 100 lines with comments; it would have been impossible to do the same in a language that doesn't support the functional notation of a function
15:32:37 <RyanT5000> yeah
15:32:44 <RyanT5000> uhm, what was the basic principle?
15:32:54 <RyanT5000> an undo/redo system is one of my current things
15:33:03 <mahogny> RyanT5000, you can have the code
15:33:07 <i|_> GHC should have some sort of modular arithmetic optimization thingy.
15:33:07 <RyanT5000> awesome! thanks :)
15:33:29 <RyanT5000> write one :)
15:33:35 <mahogny> i|, there's a ton of optimizations I wish ghc had
15:33:42 <RyanT5000> you could do it in TH
15:33:44 <i|_> And my wireless Internet connection should have some sort of half-decent range thingy.
15:33:52 <mahogny> RyanT5000, http://mahogny.areta.org/snippets/
15:34:05 <mahogny> RyanT5000, feel free to improve it and tune it. it's mostly conceptual as is
15:34:16 <Quinthius> hey guys, is there any major reason to use one OS over the other (linux vs windows) specifically for haskell development (i.e. due to better libraries available or compiler support), or are they pretty much even?
15:34:33 <RyanT5000> alright, although mine may be in a different style completely
15:35:02 <i|_> Say, that reminds me...
15:35:03 <shapr> Quinthius: Community wise, more people on #haskell use Linux. Also, most of the development of GHC happens on Linux.
15:35:12 <RyanT5000> do you have to write the inverse functions yourself?
15:35:15 <RyanT5000> in your undo system
15:35:15 <Quinthius> ahhh
15:35:19 <mahogny> RyanT5000, the idea is to store the functions that make changes to the world state in a list. that way you get a really cheap way of storing incremental changes
15:35:27 <mahogny> RyanT5000, no invert functions are used
15:35:40 <mahogny> RyanT5000, the rest of the program is completely unaware that the undo function exists
15:35:50 <shapr> mahogny: Seen the 'arrows for invertible programming' paper?
15:35:55 <RyanT5000> hm
15:35:56 <mahogny> shapr, nah
15:36:02 <mahogny> shapr, good?
15:36:07 <i|> Can anybody give me an idiot's guide to building hscurses?
15:36:15 <i|> ...on Windows?
15:36:16 <shapr> In short, "How to make arrows that generate their inverse."
15:36:31 <mahogny> sounds... interesting. googling!
15:36:45 <shapr> mahogny: It's cute and interesting. I only apply 'good' to a very small number of papers.
15:37:22 <RyanT5000> oh, mahogny, are you storing copies of the datastructure at each checkpoint?
15:37:45 <mahogny> RyanT5000, yes. it's done database style
15:37:57 <mahogny> RyanT5000, that way I can avoid the mess of inverses entirelly
15:38:33 <mahogny> I think it's a pretty good solution. it's memory efficient while it still saves a lot of programming effort
15:38:49 <RyanT5000> i think i know an even better way ;)
15:38:54 <mahogny> shoot
15:38:56 <RyanT5000> basically the same idea but slightly more generalized
15:39:04 <sieni> we had a small meeting, me, franka, lor and musasabi.
15:39:06 <sieni> got a few beers, photo evidence is forthcoming :-)
15:39:18 <RyanT5000> it is designed to use inverses, but as long as you keep a copy of the initial state you can emulate inverses (as you do)
15:39:49 <RyanT5000> basically you have a graph, where each edge is labeled with a transition
15:40:06 <RyanT5000> if you ignore the sense of the edges, the graph is a tree
15:40:17 <RyanT5000> you have one mutable (in an ST monad or something) state
15:40:22 <RyanT5000> which is the "current state"
15:40:33 <RyanT5000> it exists on a particular node of the graph
15:40:33 <jip> i have a question about monads
15:40:57 <mahogny> ...uh. where does the tree come from?
15:41:02 <RyanT5000> when you need to access a particular state of the data, it slides the cached state along the graph to get to the correct node
15:41:03 <jip> let's say i want to create my own List type, pretty much the same as the builtin List type
15:41:12 <RyanT5000> well if you change something, roll it back, and change it again
15:41:17 <RyanT5000> then you have multiple possible redos
15:41:25 <RyanT5000> that's why it's a tree
15:41:32 <jip> am i allowed to make my List2 type non-polymorphic, i mean only able to contain Integers. and have it still be a monad?
15:41:37 <mahogny> would you want multiple redos? sounds confusing. I wonder how an user would cope with it
15:41:43 <mahogny> -n
15:41:48 <RyanT5000> well you can always throw them away
15:42:02 <RyanT5000> i think my datastructure garbage collects well
15:42:11 <sethk> multiple redos are essential 
15:42:21 <sethk> you can't do anything serious without them
15:42:25 <mahogny> sethk, :)
15:42:52 <mahogny> RyanT5000, it sounds a bit overengineered. did you add inverses to that?
15:43:08 <RyanT5000> it currently uses only inversese
15:43:20 <RyanT5000> i was originally desigining a better version of DiffArray
15:43:28 <RyanT5000> since inverses are so easy with DiffArrays
15:43:32 <RyanT5000> er, Arrays
15:43:54 <mahogny> RyanT5000, I think one middle approach might be my system, but put the inverse in a Maybe such that the program can make one available if the coder decides it is worth the effort
15:44:04 <RyanT5000> yeah
15:44:27 <RyanT5000> that's definitely an appropriate way of doing it
15:44:38 <mahogny> inverses are pure evil. I prefer to live without them if possible, mostly because of the extra work
15:44:45 <lisppaste2> RyanT5000 pasted "Undo Data Structure" at http://paste.lisp.org/display/18880
15:44:52 <RyanT5000> yeah definitely
15:45:03 <RyanT5000> but implementing an undoable array would be better with inverses
15:45:19 <RyanT5000> the way i got to this datastructure was by assuming i had an array so large i couldn't possibly copy it
15:45:43 <RyanT5000> oh and btw that datastructure is the immutable version, which is worthless
15:45:48 <RyanT5000> i don't know how to write the mutable version
15:46:08 <RyanT5000> well, i might now, actually
15:46:14 <mahogny> it does indeed become a problem when you have something really huge
15:46:40 <RyanT5000> anyway the idea is that whenever you get the state from a particular node, it moves the array to that node
15:46:46 <mahogny> I assume that I can have a few checkpoints, given that I clean up and remove the most improbably used ones
15:46:49 <RyanT5000> that state is then cached
15:47:01 <mahogny> sounds clean at least
15:47:14 <RyanT5000> yeah, i think it is
15:47:21 <RyanT5000> it also trivially expands to have multiple cached states
15:47:23 <mahogny> I think your way works, although I have trouble seeing your undo in practice out of usability reasons
15:47:31 <mahogny> *redo
15:48:01 <RyanT5000> i can only think of one app that exposes multi-redo to the user
15:48:04 <RyanT5000> which is VMWare
15:48:10 <mahogny> oh?
15:48:18 <RyanT5000> in version 5.5 and above, you can boot up a machine, change it, and snapshot it
15:48:30 <mahogny> they list it as Redo x, Redo y etc?
15:48:35 <RyanT5000> they show you a tree
15:48:42 <mahogny> that's hardcore
15:48:43 <RyanT5000> it's not really undo/redo in the classic sense
15:48:53 <RyanT5000> but it's identical in functionality
15:48:59 <RyanT5000> you know what vmware does?
15:49:06 <mahogny> I was more thinking like in an editor etc
15:49:08 <mahogny> yes
15:49:14 <RyanT5000> k
15:49:20 <RyanT5000> yeah so they let you have a tree of machine states
15:49:22 <RyanT5000> it's pretty badass
15:49:39 <RyanT5000> and obviously when you have huge disks, you can't use checkpoints
15:49:55 <mahogny> what is the advantage? fast bootups?
15:50:01 <RyanT5000> no, you can do stuff like
15:50:10 <sieni> I misread "huge disks" to something else
15:50:12 <RyanT5000> have an initial snapshot with Windows installed
15:50:17 <RyanT5000> lol
15:50:25 <RyanT5000> then have a snapshot with Office installed
15:50:39 <RyanT5000> then have a snapshot without office installed, and with something else installed
15:50:56 <RyanT5000> obviously you can't have any merge points in your tree
15:51:05 <mahogny> hm
15:51:17 <RyanT5000> i use it as a sandbox
15:51:18 <mahogny> ok, I see. ghosting on adrenaline
15:51:33 <RyanT5000> for things i think might be viruses, etc.
15:52:24 <RyanT5000> hm....
15:52:33 <RyanT5000> i wonder if you could write something in TH to automatically generate inverses of some functions
15:53:01 <mahogny> in general no
15:53:12 <RyanT5000> right, i know you can't do it generally
15:53:39 <mahogny> but maybe if you introduce a special primitive that you can keep track of, you can check what has been changed and simply store away the original part
15:53:52 <mahogny> that assumes it is easy to design such a construct
15:53:58 <RyanT5000> lol yeah, not so easy
15:54:05 <RyanT5000> but it could be done for some functions
15:54:39 <RyanT5000> did you look at my diff class?
15:54:42 <mahogny> yup
15:54:57 <RyanT5000> if you could transform a function into a Diff automatically
15:55:17 <RyanT5000> btw the second thing returned in that tuple is the inverse of the original diff
15:55:53 <RyanT5000> also, i guess there's no reason a diff has to return the same thing as it takes
15:55:54 <mahogny> you can probably do such a beast, but the general solution would be slow
15:56:00 <RyanT5000> yeah
15:56:21 <RyanT5000> you could do d a b -> a -> (b, d b a)
15:56:52 <RyanT5000> really i just wanted to make an immutable array class that, rather than copying, kept a single state around and cached it at whatever state you had most recently used
15:57:11 <mahogny> I think a semiautomatic solution would require knowledge about what you are working on. so, some glue on top of your undolib
15:57:52 <RyanT5000> if my datastructure is all lazy, is there anything but arrays that i really need to worry about?
15:57:59 <RyanT5000> could i just store a list of all the states?
15:58:29 <mahogny> ouch
15:58:58 <RyanT5000> where does that hurt? :P
15:59:02 <mahogny> that sounds dangerous. if you have confidence in the GC, and design the interface properly then maybe
15:59:04 <mahogny> my head :)
15:59:19 <RyanT5000> i'm new to haskell, btw, i've been hacking on it for about 1 week solid
15:59:38 <RyanT5000> so performance isn't exactly something i understand yet
16:00:29 <mahogny> I know a case when the phd's here even started wondering what 5 lines of code really did, so I don't think you should worry if you get stuck on such a detail :)
16:00:43 <RyanT5000> :P
16:01:02 <RyanT5000> i plan to write my game with undo implemented via list-of-states
16:01:04 <RyanT5000> and then fix it
16:01:05 <RyanT5000> :)
16:01:57 <RyanT5000> btw anyone else interested in working on a purely-functional windowing system for opengl?
16:02:06 <RyanT5000> i want to start an OSS project, but i have no experience with such things
16:02:13 <RyanT5000> it seems like something haskell should have, though
16:02:26 <RyanT5000> no such thing, to my knowledge, really exists even outside haskell
16:02:34 <RyanT5000> at least not with good quality
16:02:51 <RyanT5000> most game engines treat their windowing system like the bastard stepchild
16:03:00 <mahogny> ok. news flash; purely functional GUIs in haskell is research stuff and the final word is yet to be said :)
16:03:09 <RyanT5000> oic
16:03:18 <RyanT5000> well i'm doing it for fun :)
16:03:20 <mahogny> I still prefer old style imperative GUIs for games, even in haskell
16:03:34 <RyanT5000> i wrote a purely-functional window manager in C++
16:03:53 <RyanT5000> it has some issues
16:03:55 <mahogny> ...uh. in what way was that beast functional?
16:04:08 <RyanT5000> in the way that a "Window" didn't store anything about its own contents
16:04:16 <Excedrin> void main() { } // c++ purely functional window manager
16:04:19 <RyanT5000> lol
16:04:29 <mahogny> Excedrin, :)
16:04:34 <RyanT5000> Window.Draw was side-effect free, except the part where it renders stuff
16:04:44 <mahogny> RyanT5000, I don't follow. why would that make it functional?
16:05:27 <RyanT5000> perhaps i misunderstand the meaning of "purely functional"?
16:05:40 <mahogny> well. Lambda calculus=functional, the way I see it :)
16:05:42 <RyanT5000> my understanding was that that means you don't use side-effects
16:06:30 <mahogny> I think you can prolly make a functional language with side effects if you wanted to :)
16:06:38 <i|> Unlambda.
16:06:40 <mahogny> but I hope I won't have to see one
16:06:46 <RyanT5000> LISP
16:07:04 <RyanT5000> so can you point me to some of this GUI research?
16:07:16 <RyanT5000> i just read half a dissertation on Yampa
16:07:33 <RyanT5000> my basic take is that they're using arrows and crap but it boils down to having no side effects
16:07:42 <RyanT5000> (i plan to use arrows too)
16:07:46 <mahogny> RyanT5000, haskell.org should have some links to libraries. start there. in particular, there is a lot about reactive GUIs
16:07:55 <RyanT5000> right, FRP?
16:08:01 <mahogny> haven't used them
16:08:06 <RyanT5000> yeah i've been reading about that all day
16:08:23 <mahogny> from what I have seen, they look nice theory but are too messy to use in practice for my taste
16:08:28 <mahogny> +in
16:08:46 <RyanT5000> well i hope mine won't be :)
16:09:28 <mahogny> it mostly falls on a too static design. straight forward use of arrows will get you there, although I have seen an example on how to avoid it in some paper
16:09:40 <mahogny> avoid=ugly hack to barely escape IMHO
16:10:09 <RyanT5000> "too static design" you mean like having to define your arrow-graph completely at compile-time?
16:10:15 <mahogny> yes
16:10:20 <RyanT5000> yeah that's bullshit :)
16:10:30 <RyanT5000> in each frame my arrow graph will rebuild itself
16:10:42 <RyanT5000> that's how it will change its state too
16:10:44 <mahogny> the hack I saw was to allow flows to be redirected at runtime but it still looks messy
16:11:13 <RyanT5000> that sounds sort of like what i'm doing, except i'm doing it on a more complete level
16:11:28 <RyanT5000> basically the next frame's arrow graph will be one of the outputs of the arrow graph
16:11:37 <RyanT5000> so the whole thing will be rebuilt "from scratch" each time
16:11:53 <mahogny> what about stateful arrows?
16:12:00 <RyanT5000> that's how they'll be implemented
16:12:08 <mahogny> hm. I guess
16:12:12 <RyanT5000> this won't operate in a monad
16:12:27 <RyanT5000> i'm gonna write a class real quick
16:12:31 <Cale> dozer: What you were asking for (a function which returns different values for the same input) is impossible.
16:12:33 <RyanT5000> i am of course worried about performance
16:12:41 <RyanT5000> but i figure i'll solve that when i come to it
16:12:53 <RyanT5000> i don't think this is fundamentally terrible performance-wise
16:12:54 <Cale> jip: you were looking for me?
16:13:02 <mahogny> Cale, even with IO? ;)
16:13:20 <Cale> mahogny: sure, since it would return the same IO action each time
16:13:32 <mahogny> Cale, call Random?
16:13:47 <RyanT5000> isn't Random an IO Int or something?
16:13:51 <RyanT5000> @hoogle Random
16:13:51 <lambdabot> Random :: module
16:13:51 <lambdabot> System.Random :: module
16:13:51 <lambdabot> System.Random.Random :: class Random a
16:14:00 <Cale> @type randomIO
16:14:00 <RyanT5000> @hoogle random
16:14:01 <lambdabot> forall a. (Random a) => IO a
16:14:01 <lambdabot> Random.random :: (Random a, RandomGen b) => b -> (a, b)
16:14:01 <lambdabot> System.Random.random :: (Random a, RandomGen g) => g -> (a, g)
16:14:01 <lambdabot> Random :: module
16:14:01 <dozer> Cale: sure - in sml you hack it by using a reference that's internal to the function
16:14:16 <Cale> dozer: right, but sml isn't referentially transparent like Haskell
16:14:53 <Cale> dozer: Note that evaluation order in Haskell isn't really specified. The compiler gets to decide the order in which to evaluate things, so long as the semantics are nonstrict
16:14:55 <dozer> Cale: no - so from what people have said and I have read tonight, you use monads to "transparently" lift that mutable state out
16:15:01 <Cale> right
16:15:19 <Cale> Well, it's not exactly transparent, but it's systematic anyway
16:15:49 <RyanT5000> class GUI graph message scene where
16:15:49 <RyanT5000>      run :: graph -> message -> (scene, graph)
16:16:37 <RyanT5000> parameterizing message and scene is a bit overzealous
16:16:51 <mahogny> RyanT5000, what I haven't really understood is this arrow shit. what's the advantage?
16:17:28 <RyanT5000> well, i don't want there to be any duplicated state
16:18:11 <RyanT5000> for instance, if you have a document, say type Document = Either String [String]
16:18:29 <RyanT5000> now if you make a control in a window to represent this document
16:18:42 <RyanT5000> it'll be a text box to represent a String
16:18:50 <RyanT5000> or a list box to represent a [String]
16:19:14 <RyanT5000> (my last three messages are the design document, so they're not subject to change)
16:19:19 <RyanT5000> now, in a traditional system
16:19:24 <RyanT5000> you say
16:19:33 <mahogny> I disagree about duplicated state
16:19:46 <RyanT5000> why?
16:19:50 <RyanT5000> why should state be duplicated?
16:19:53 <mahogny> even in a standard OO system, you can get away from it. it's more a matter of coding style
16:20:00 <RyanT5000> i don't see how
16:20:09 <RyanT5000> how do i do it in the example i just stated?
16:20:24 <mahogny> well, I assume the core you mean is this:
16:20:48 <mahogny> classically: you store the string in the widget AND somewhere else. this is one more than you want. right?
16:20:54 <RyanT5000> right
16:21:04 <RyanT5000> but also the kind of widget you pick could change based on the document
16:21:25 <RyanT5000> and what if you have two views of the same document at once?
16:21:26 <mahogny> well. you draw the string to the screen right? so if you really wanted, you could pull the string from there. hence if you store it in a string as well, you have duplicated the state
16:21:35 <RyanT5000> right
16:22:03 <mahogny> so my opinion is that a duplicated state can be so well hidden that you won't have to worry about it = it depends on coding style, no matter if it is C++ or haskell
16:22:44 <RyanT5000> true, but i think it is much less efficient in C++, either in amount of code required or amount of time required
16:22:49 <mahogny> so... that is also why I don't see a major advantage with arrows for this. but automatic construction of widgets is something else
16:22:50 <RyanT5000> (run time, that is)
16:23:08 <RyanT5000> basically, you have a function to render a window
16:23:17 <RyanT5000> oooh
16:23:18 <RyanT5000> why arrows?
16:23:20 <mahogny> I designed something earlier, but I never got around to implement it, that essentially decides all widgets by itself
16:23:24 <RyanT5000> i could have answered that much more directly :D
16:23:32 <RyanT5000> ok you know ModelViewController?
16:23:36 <mahogny> yeah. hate it
16:23:46 <RyanT5000> that's a special case of arrwos
16:23:48 <RyanT5000> *arrows
16:24:12 <mahogny> good. that explains why I'm no fan of arrows :)
16:24:20 <RyanT5000> well ok how do you define this then:
16:24:29 <RyanT5000> i have a control that displays a 3d object (the primary document)
16:24:43 <RyanT5000> the control lets me rotate the 3d object
16:24:48 <RyanT5000> the rotation state is also a document
16:24:55 <RyanT5000> which can be changed by some other control
16:25:06 <RyanT5000> (or by the same control)
16:25:21 <RyanT5000> so the 3d object is the Model
16:25:41 <RyanT5000> the type of the control, along with its state, is the View
16:25:48 <RyanT5000> and the thing that changes the rotation state is the Controller
16:26:26 <RyanT5000> essentially you have a cycle-free graph of documents, views, and controllers
16:26:44 <RyanT5000> a controller modifies a document, a view renders a document
16:27:05 <RyanT5000> anyway you can express this very cleanly with arrows, or so i believe so far
16:28:09 <mahogny> probably
16:28:17 <RyanT5000> so how is that not useful?
16:28:41 <RyanT5000> i'm not trying to say you're wrong - if you're right, then i want to hear about it :)
16:28:45 <RyanT5000> it'll make my life much easier
16:29:41 <RyanT5000> wow, this is identical to a neural net
16:29:46 <RyanT5000> class ReactionGraph graph stimulus response where
16:29:46 <RyanT5000>      run :: graph -> stimulus -> (response, graph)
16:29:46 <mahogny> I don't find it much more cleaner than the classic design. I have an allergy that's really problematic when I see something that looks like using X for the sake of using X :) in this case, I'd need to see example code to be convinced that it's so much better
16:30:13 <RyanT5000> i totally agree
16:30:18 <RyanT5000> i'll see if i can furnish an example :)
16:30:23 <mahogny> in particular, real world examples. this is no deal - they figured when they made all these reactive GUIs that it look nice until you step on a real world example :)
16:30:42 <RyanT5000> ok, give me a real-world gui, and i'll try to implement it
16:30:47 <RyanT5000> something pretty simple, though
16:31:39 <mahogny> well. that would be a specification several pages long lol. but maybe you should try implementing something in all these reactive GUI libs and see where the problems are. in particular I think there exist some analysis of different case stories
16:32:09 <RyanT5000> alright, well i'm first going to try my example about rotating a 3d model
16:32:24 <RyanT5000> using the arrow keys
16:32:34 <RyanT5000> to change pitch and yaw
16:32:53 <i|> @google haskell preprocessor
16:32:54 <lambdabot> http://www.dcs.gla.ac.uk/fp/software/
16:32:55 <mahogny> it would be nice if someone tried to implement my OIL library from before. like if you are ever bored *hinthint* :)
16:33:04 <RyanT5000> link?
16:33:12 <mahogny> none currently. I took it down
16:33:14 <RyanT5000> k
16:33:16 <mahogny> but the idea is simple
16:33:25 <mahogny> the gui engine should pick the widgets
16:33:38 <RyanT5000> ah, sounds just like what i'm trying to do ;)
16:33:42 <RyanT5000> in fact
16:33:44 <RyanT5000> using TH
16:33:54 <mahogny> take it to the extreme and combine it with an extremely flexible widget set that the user can move around and reassemble to fit whatever they do
16:34:09 <mahogny> for example, the gui lib even decides what becomes a window and what not
16:34:17 <i|> So where can I find one of these Haskell preprocessor thingamegadgets?
16:34:33 <mahogny> ...never heard of :o
16:34:37 <RyanT5000> i plan to be able to say "generate a window to edit this datastructure"
16:35:00 <RyanT5000> yeah dude do you have any time to work on something like this?
16:35:06 <RyanT5000> cause uh that's exactly what i'm doing :)
16:35:29 <mahogny> time... I will be 80 years old when I finally finish off my current todo and it keeps growing lol
16:35:39 <RyanT5000> yeah, thats my problem too
16:36:00 <RyanT5000> well anyway if you become interested, you can email me, ryant5000@yahoo.com
16:36:09 <RyanT5000> that goes for anyone else in this chatroom too :)
16:36:20 <mahogny> so, my solution has been to recruit "students"; I give them some interesting problems (ie my specifications) and I teach them programming in return
16:36:21 <RyanT5000> sorry, *channel
16:36:35 <RyanT5000> yah, i've done a bit of that :)
16:36:46 <RyanT5000> but i tend to have an aversion to tackling easy problems
16:36:55 <RyanT5000> and i have a hard time finding good students :P
16:36:56 <mahogny> it's the only solution that works out. allthough I'm on a different strategy now
16:37:03 <mahogny> yes. it's extremely hard
16:38:00 <mahogny> I decided that I should attract some non-students now for some projects by showing off and doing some apps that will be widely used. so there, my todo became huge over night :P
16:38:14 <RyanT5000> yah
16:38:23 <mahogny> a few things in the mill though
16:38:45 <mahogny> next up, hopefully an extension that is portable over MSN, Jabber and ICQ
16:39:01 <mahogny> a working sketchpad. the thing we always wanted but never found a good one :)
16:39:57 <RyanT5000> ah
16:40:00 <RyanT5000> that'd be cool
16:40:25 <mahogny> RyanT5000, btw, if you're ever interested in making an X-windows replacement, then give me a mail or something. that's an upcoming project but I need quite a team before I go for that one
16:40:27 <RyanT5000> sounds like you'd need a good widget system :)
16:40:33 <mahogny> lol
16:40:35 <mahogny> wxwindows
16:40:41 <RyanT5000> yeah, for teh lose
16:40:46 <mahogny> C++
16:40:57 <RyanT5000> i'm pretty much sticking to haskell forever i think
16:41:01 <RyanT5000> at least
16:41:07 <RyanT5000> i don't think i'm switching to anything that currently exists
16:41:18 <RyanT5000> i've spent 7 years writing C++ code
16:41:20 <mahogny> I have a weakness for C
16:41:31 <mahogny> so nowadays I mix haskell and C
16:41:42 <RyanT5000> ah, sounds like me, except asm rather than C
16:42:00 <RyanT5000> though i must admit i don't have much occasion to actually use asm
16:42:08 <RyanT5000> i wrote a really fast MD5 password cracker in it
16:43:12 <mahogny> I prefer portable assembly
16:43:26 <RyanT5000> yah, i would if i were actually doing it for anything useful, lol
16:43:35 <RyanT5000> i love getting into the intracacies of the processor
16:43:44 <mahogny> portable asm = C ;)
16:43:44 <RyanT5000> like RISC asm with its branch delay slots
16:43:48 <RyanT5000> (i know :)
16:43:49 <RyanT5000> )
16:44:14 <i|> MD5 crackers?
16:44:27 <resiak> Are they anything like cream crackers?
16:44:30 <RyanT5000> lol
16:44:35 <i|> How did you pull that one off?
16:44:42 <RyanT5000> i just wrote a really fast MD5 algorithm
16:44:45 <RyanT5000> it was brute force
16:44:56 <RyanT5000> it benchmarked way faster than any other bruteforce algorithm
16:45:06 <RyanT5000> it was only slightly slower than the weakness-based one i found
16:45:06 <mahogny> RyanT5000, I have an additional weakness for designing hardware but it's horribly expensive that I can't have it for hobby :(
16:45:12 <RyanT5000> yah
16:45:20 <RyanT5000> someone should make a haskell processor some day :)
16:45:25 <mahogny> RyanT5000, funny enough, all my designs have been realized anyway through the past years :)
16:45:38 <mahogny> RyanT5000, intel was at least 5 years after me with hyper threading :P
16:45:45 <RyanT5000> ah
16:45:51 <RyanT5000> yah i know how that goes
16:45:53 <i|> So what do I do with all this #if and such in this Haskell code?
16:45:56 <RyanT5000> you know MS's Singularity OS?
16:45:58 <mahogny> RyanT5000, except I have some 20 cores. so I beat AMD there as well
16:46:02 <mahogny> RyanT5000, nope
16:46:16 <RyanT5000> it's an OS based on binary translation for process containment
16:46:31 <RyanT5000> i.e.: drivers run in kernel mode, but they're compiled by the kernel from bytecode
16:46:38 <mahogny> hmm
16:46:42 <RyanT5000> its' way faster
16:46:46 <RyanT5000> cause you avoid context switches
16:47:06 <RyanT5000> i came up with that 3 years before it was published
16:47:08 <RyanT5000> :(
16:47:40 <mahogny> RyanT5000, drivers can run in kernel mode now, in binary. why would it be faster?
16:47:48 <RyanT5000> oh its not faster than that
16:47:50 <RyanT5000> it's safer than that
16:47:56 <RyanT5000> it's faster than a microkernel
16:48:04 <mahogny> microkernel=trash
16:48:08 <RyanT5000> well that's the point
16:48:14 <RyanT5000> take all the good stuff from microkernel
16:48:17 <mahogny> you'd love my planned X windows replacement
16:48:31 <RyanT5000> i'm sure i would :)
16:48:43 <RyanT5000> although imo, the OS should be the priority
16:48:46 <mahogny> you upload widgets as code to the server. it compiles it directly to driver code and then you have everything accelerated, even if it is remote over network
16:48:54 <RyanT5000> that's pretty sweet
16:48:58 <mahogny> no way. linux is adequate. X? no way
16:49:04 <RyanT5000> that's a good point
16:49:10 <RyanT5000> but i hate the OS architecture
16:49:16 <RyanT5000> works well, yes
16:49:19 <RyanT5000> designed well, no
16:49:23 <mahogny> patch that later
16:49:26 <RyanT5000> :P
16:49:45 <RyanT5000> what if you can't really make an efficient posix interface?
16:49:47 <RyanT5000> or, rather
16:49:56 <RyanT5000> a non-posix interface would be way more efficient
16:50:18 <mahogny> it's hard enough to find drivers for linux. until that is fixed, there's no point in designing a new OS. unless you are in really huge need of one
16:50:40 <int80_h> aw come on, writing an OS in haskell sounds like loads of fun
16:50:43 <mahogny> well, I have an OS design aka the macrokernel. all programs run in Ring0. but those are crazy ideas
16:50:49 <mahogny> int80_h, there is one :)
16:50:54 <int80_h> really?!
16:50:58 <mahogny> yes
16:51:02 * int80_h jumps up and down in joy
16:51:07 <int80_h> gimme gimme gimme
16:51:12 <mahogny> download
16:51:15 <mahogny> research stuff
16:51:29 <mahogny> there's an accompanying article
16:51:42 <int80_h> is it open for other people to play with?
16:51:49 <mahogny> maybe. never tried it
16:52:12 <int80_h> oooh I thought it was yours
16:52:14 <RyanT5000> i wouldn't be crazy enough to write an OS without linux driver support
16:52:34 <int80_h> well I thought that using the OSToolkit would be the way for me to go, if I wanted to make a toy.
16:52:41 <RyanT5000> also, imo, if you want it to be commercially viable, you better have windows driver support (yeah, i know that's f*cking hard)
16:53:09 <mahogny> RyanT5000, my OS has some extreme requirements so that's what is holding me back. like, the source code is needed for each application. all checks are done in software and it has to go through a theorem prover about security before it gets loaded etc. so... extreme, but fast :)
16:53:45 <RyanT5000> no disrespect, but i think those are foolish requirements
16:53:48 <RyanT5000> that's what rings are for
16:53:52 <int80_h> rings?
16:53:59 <mahogny> RyanT5000, no context switches at all
16:54:11 <RyanT5000> that's a good idea, mahogny
16:54:15 <RyanT5000> but why not use both?
16:54:31 <mahogny> with and without?
16:54:33 <RyanT5000> just charge the cost of the context switch against the application you're switching to-from
16:54:40 <RyanT5000> yep
16:54:57 <RyanT5000> voila, all the benefits, none of the downsides
16:54:57 <mahogny> that's one way. but why use a slow program on the other hand?
16:55:06 <mahogny> (unrealistic yes)
16:55:06 <RyanT5000> that should be the user's choice
16:55:17 <RyanT5000> what if it's a proprietary app?
16:55:32 <RyanT5000> its not a feature to be unable to run proprietary software
16:55:34 <int80_h> yeah I was thinking that..some people won't want to give out source
16:55:42 <RyanT5000> (lol @ fedora core 5)
16:55:48 <RyanT5000> (but even they patched it in like a day)
16:55:57 <mahogny> in my world even properietary apps would be public sourced. not in a readable format, but the parse trees would be available such that a theorem prover can be used
16:56:08 <RyanT5000> well that's a bit more reasonable
16:56:21 <RyanT5000> but without backwards-compatability you'll never get any adoption
16:56:25 <mahogny> it would also allow some optimizations I have planned which closed source completely makes impossible
16:56:29 <mahogny> right
16:56:49 <RyanT5000> i agree that integration into the kernel via theorem-prover is a good ideal
16:56:53 <RyanT5000> but you have to use rings in the interim
16:57:08 <mahogny> so, I would build it on linux, but hide away the core. fast to realize, but all functions can go in early. then recode it when the time is ready
16:57:20 <RyanT5000> yeah
16:57:34 <RyanT5000> if it can run everything as ring0, it should be easy to write it so that everything runs ring3
16:57:41 <RyanT5000> as a linux user app
16:57:43 <mahogny> lots of work. put on shelf until I have found a good team of coders. as with my X-windows replacement :(
16:57:48 <mahogny> yes
16:57:53 <RyanT5000> see, i think the x-windows replacement should be second
16:58:02 <int80_h> this will all be in haskell?
16:58:02 <RyanT5000> what if your OS makes it like a million times easier to write X-Windows :)
16:58:10 <mahogny> int80_h, no
16:58:14 <mahogny> int80_h, prolly not
16:58:14 <RyanT5000> if it's up to me, yes, int80_h
16:58:16 <int80_h> then we can make him a king in thanks
16:58:25 <mahogny> RyanT5000, it prolly won't
16:58:30 <int80_h> aw man
16:58:32 <RyanT5000> well there'll  be some asm and stuff
16:58:38 <RyanT5000> just enough to make it work :)
16:58:43 <int80_h> I was getting excited at the commercial OS written in haskell
16:58:58 <RyanT5000> obviously (?) i'm not writing my bootloader in Haskell
16:58:59 <mahogny> RyanT5000, I see X-windows and swear over it each day. if my programs run some 5% faster is a minor problem compared :)
16:59:05 <int80_h> yeah I imagine you would have to fiddle bits with asm, but that's expected
16:59:21 <mahogny> RyanT5000, if you do, ... uh. I would be impressed :)
16:59:22 <RyanT5000> do you know about plan9?
16:59:25 <mahogny> no
16:59:33 <RyanT5000> it's network-transparent
16:59:40 <int80_h> hey if someone can write an OS with scheme they can write one in haskell
16:59:44 <RyanT5000> so writing X windows on it, you wouldn't have to write any networking code at all
16:59:59 <RyanT5000> what if there were lots of features that "went away" on a redesigned OS?
17:00:05 <dibblego> if Haskell is a pure functional language, does it make sene that all functions have a return value?
17:00:13 <RyanT5000> yes dibblego
17:00:25 <RyanT5000> although you can technically have a function that returns ()
17:00:32 <RyanT5000> (the only value of type () is ())
17:00:46 <mahogny> RyanT5000, I don't think that would be a major biggie. the large part is coding it, getting applications to use it, and get it distributed. compared to that, a small/major driver recode is a triviality
17:00:47 <dibblego> RyanT5000: then what would be the point of invoking that function?
17:00:57 <RyanT5000> nothing
17:01:10 <RyanT5000> i suppose, mahogny
17:01:15 <dibblego> RyanT5000: do you think its inclusion in a pure functional language is perhaps dubious?
17:01:24 <RyanT5000> no
17:01:27 <RyanT5000> it's used with other types
17:01:29 <RyanT5000> IO () for instance
17:01:39 <RyanT5000> IO a is an IO action along with an a
17:01:49 <RyanT5000> when you don't care to include anything else along with it, you use ()
17:01:55 <dibblego> ok cheers
17:02:31 <mahogny> no proof, but if a function only returns () I have a hard time seeing them execute anything at all, unless it doesn't terminate
17:03:09 <RyanT5000> mahogny: i would only write an OS if it were going to be a major programming paradigm shift, so i wouldn't want to start any major rewrites of other systems until i could do so on top of my OS
17:03:19 <RyanT5000> simmilarly, i wouldn't write an OS unless i had the perfect language to write it in
17:03:25 <RyanT5000> well, not "perfect"
17:03:29 <RyanT5000> but "good"
17:03:41 <RyanT5000> haskell goes under the category of "almost good enough" to me
17:03:45 <mahogny> RyanT5000, as in my case; no point in me starting a new OS unless the applications on top of it adapts
17:03:50 <dibblego> RyanT5000: what do you call a perfect/good language?
17:03:57 <RyanT5000> haskell is my favorite so far
17:04:11 <RyanT5000> i can't imagine writing a next-gen OS in anything, for instance, with side-effects
17:04:15 <dibblego> then instead of writing an OS, why not write a language that meets your ideology?
17:04:21 <RyanT5000> i will :)
17:04:25 <dibblego> me too :)
17:04:41 <RyanT5000> however, haskell is so close i wouldn't find it terrible to write an OS in it
17:04:49 <mahogny> RyanT5000, I started on that one too. earlier it was the only acceptable language for any applications running on my OS but that is a quite harsh requirement
17:04:58 <RyanT5000> yeah
17:05:06 <mahogny> RyanT5000, the main feature: the language decides on all datastructures, the coder does not
17:05:07 <RyanT5000> that kind of thing should be pluggable
17:05:18 <RyanT5000> interesting
17:05:23 <RyanT5000> how is that different from type inference?
17:05:27 <RyanT5000> well
17:05:28 <mahogny> ehr
17:05:33 <RyanT5000> type inference with defaults
17:05:34 <mahogny> how is it alike? :)
17:05:54 <RyanT5000> so are you saying you don't say you want a map<x, y>
17:06:01 <RyanT5000> you just start using it like a map<x, y>
17:06:08 <RyanT5000> ?
17:06:16 <mahogny> how is the map implemented? that is what I question
17:06:28 <RyanT5000> someone implements it
17:06:34 <RyanT5000> are you saying no one ever implements any datastructures?
17:06:48 <mahogny> I'm saying the language picks the best implementation for your purpose
17:06:53 <RyanT5000> ah
17:07:02 <mahogny> actually, it goes a bit above maps. it can decide if a map is appropriate as well
17:07:02 <RyanT5000> in other words, computational complexity is part of the type
17:07:09 <mahogny> no
17:07:14 <mahogny> it guesses that too
17:07:14 <RyanT5000> then how can it decide?
17:07:24 <RyanT5000> oh i'm not saying you have to specify it
17:07:28 <dibblego> you two are having the same conversation I have had in my head before
17:07:46 <mahogny> mostly run time checks. like profiling, but more thorough on memory usage
17:07:52 <RyanT5000> yeah i have too, i'm just seeing what bits mahogny disagrees with ;)
17:07:57 <mahogny> lol
17:08:20 <RyanT5000> yeah i completely agree with that kind of thing
17:08:23 <mahogny> RyanT5000, a typical application that would benefit is a webserver
17:08:35 <RyanT5000> the mantra should be "don't make programmers care about things that they don't care about"
17:08:49 <RyanT5000> however, i definitely think you should be allowed to specify what implementation of the type it is that you want
17:08:52 <dibblego> RyanT5000: you are frightenly similar to my thoughts
17:09:06 <dibblego> how far into your language are you?
17:09:09 <RyanT5000> nowhere
17:09:12 <RyanT5000> i'm working on a game
17:09:13 <dibblego> same
17:09:20 <mahogny> RyanT5000, the apache team has no clue if your server is write intensive or read intensive so they select a data structure that works in general. but an on-site profilation can pick the one which is better at what you use, without recode. so it can probably save a lot of performance
17:09:26 <dibblego> well, I have a lot of the theory 
17:09:41 <dibblego> I wish I knew Haskell
17:09:44 <RyanT5000> learn it
17:09:50 <dibblego> I still have only spent 15 minutes reading about it
17:09:51 <RyanT5000> i learned it a week ago
17:09:53 <mahogny> dibblego, how did you end up in this channel? :)
17:09:55 <mahogny> lol
17:10:04 <RyanT5000> guys, we need to start up a working group
17:10:12 <dibblego> mahogny: because Haskell is (I'm betting) the closest language to the one I plan to write
17:10:17 <RyanT5000> it is
17:10:18 <RyanT5000> :)
17:10:27 <RyanT5000> you want to write the same langauge as me
17:10:31 <RyanT5000> and that's how i ended up here
17:10:34 <RyanT5000> ;)
17:10:45 <dibblego> I derived all my conclusions without knowing Haskell, which leaves me a bit on my own though
17:10:47 <mahogny> haskell is very close to the language I imagined when I started designing mine, except it lack a few features :)
17:10:54 <RyanT5000> right, i came up with monads about 2 weeks ago
17:10:59 <RyanT5000> then i  looked for a langauge based on them
17:11:00 <dibblego> RyanT5000: we have been discussing it for years in #jtiger
17:11:03 <RyanT5000> and found haskell
17:11:20 <dibblego> it all came about because Java is crap
17:11:27 <RyanT5000> yeah, for me C++ and C#
17:11:30 <RyanT5000> they're my crap :)
17:11:31 * mahogny likes java :(
17:11:50 <RyanT5000> i'm glad to see that we both converged on haskell, coming from different perspectives
17:11:54 <dibblego> you can disprove Java as being valid to meet a certain number of common objectives
17:12:12 <dibblego> RyanT5000: it's frightening, I have been on my own for years (except a select few)
17:12:12 <RyanT5000> right now my #1 principle is DRY - don't repeat yourself
17:12:14 <araujo> java's only objective is to make money.
17:12:27 <mahogny> dibblego, well. on the imperative side of the world, I would say there isn't much to choose from. I hate them all
17:12:29 <araujo> which is not bad at all, but you won't get anything beyond
17:12:44 <RyanT5000> dibblego do you have time for a project?
17:12:57 * araujo got to Haskell from a True object oriented language
17:13:13 <RyanT5000> i'm writing a functional graphics engine for a game
17:13:13 <dibblego> RyanT5000: I am planning to make myself time to get started on documenting everything at least
17:13:14 <mahogny> RyanT5000, anyway, if you feel up for an X replacement later when you have gotten some experience and I have gotten a team, just ask me :)
17:13:25 <RyanT5000> absolutely
17:13:26 <RyanT5000> :)
17:13:34 <dibblego> RyanT5000: I'm changing my processes at home before anything, then I will embark on documenting an objectives document
17:13:44 <dibblego> e.g. my set up at home is currently a mess
17:13:48 <araujo> mahogny, it'd be nice to see a Haskell desktop
17:13:51 <mahogny> RyanT5000, it will prolly be C though. too much assembly involved to do it in haskell
17:14:12 <RyanT5000> mahogny have you considered writing the C via a haskell program?
17:14:20 <dibblego> RyanT5000: one other person is also keen to assist on my objective, since we both reasoned our conclusion together
17:14:21 <araujo> Something like sawfish with Lisp would be nice.
17:14:24 <int80_h> aw you aren't afraid of a little assembly are ya (says the guy named int_80h
17:14:36 <RyanT5000> :P
17:14:56 <dibblego> I really need to learn Haskell before all of that
17:14:59 <RyanT5000> well dibblego if you want an IDE for your langauge you could help me with my 3d windowing system ;)
17:15:01 <mahogny> RyanT5000, yes. but in the end, I have to interface a lot of shit that is lowlevel or C, so it would be 20% C, 10% haskell, and 70% glue code :)
17:15:06 <RyanT5000> it'll be a good way to learn haskell too
17:15:18 <int80_h> I'm on chapter 5 of simon thomspon's book
17:15:23 <RyanT5000> possibly true mahogny
17:15:32 <dibblego> RyanT5000: when we have ourselves ready, I'll contact you - may I have your email or something?
17:15:40 <mahogny> int80_h, if that one is the one I think it is, it sucks badly in the monad section
17:15:40 <RyanT5000> ryant5000@yahoo.com
17:15:46 <int80_h> when I'm done with this book I want to make a mud engine.
17:15:53 <int80_h> Te craft of functional programming
17:15:54 <dibblego> tmorris _at_ tmorris.net is me
17:16:00 <mahogny> int80_h, ew
17:16:12 <int80_h> aw, what's wrong with it?
17:16:16 <RyanT5000> ah crap i didn't realize the logs are probably spidered by spammers :P:
17:16:24 <mahogny> int80_h, it's very far from real life :)
17:16:40 <int80_h> okay, better for real life would be?
17:17:11 <int80_h> what would be a better real world haskell book?
17:17:16 <RyanT5000> incidentally
17:17:19 <RyanT5000> dibblego
17:17:23 <RyanT5000> read about Template Haskell
17:17:25 <RyanT5000> you will love it
17:17:28 <mahogny> int80_h, haven't found one. they are either too simple like that one, or something evil that will make you spend the rest of the life in a room with white walls
17:17:37 <dibblego> ok
17:17:39 <int80_h> I like white walls
17:17:52 <int80_h> yeah I have burned through this book pretty quickly
17:17:54 <RyanT5000> in fact, you might be able to make your langauge essentially be syntactic sugar for haskell with th
17:17:56 <mahogny> int80_h, but I recommend you look up monads ASAP after going through that book
17:18:16 <int80_h> yeah I take it that they are both essential and tricky
17:18:16 <dibblego> I plan on making "pure functional" one aspect of the language
17:18:24 <Philippa> RyanT5000: read my article in IssueTwo of TMR :-)
17:18:28 <dibblego> I want to understand monads to find out if I should use them
17:18:38 <RyanT5000> link Philippa?
17:18:53 <RyanT5000> dibblego does that mean you plan on having side effects be possible in your language?
17:18:59 <mahogny> bbl
17:19:04 <dibblego> RyanT5000: kind of, not exactly
17:19:10 <RyanT5000> because i think you shouldn't
17:19:18 <RyanT5000> i consider that to be an anti-feature
17:19:20 <dibblego> RyanT5000: first, I think contract and implementation should be separated
17:19:23 <int80_h> yes, the purity police will come and hunt you down
17:19:28 <RyanT5000> possibly
17:19:43 <RyanT5000> but think about how much optimization you can do if you assume everything's immutable
17:19:57 <dibblego> then, the ability to define impure contracts, and the unidirectional relationship of an "effecting" cotnract on one more impure contracts
17:20:07 <dibblego> yes, anything declared pure can be optimised, sure
17:20:35 <dibblego> also, "grouping" of contracts (essentially what OO is)
17:20:45 <RyanT5000> yeah, i suppose if you have main be impure, with pure functions only being able to calll pure functions
17:20:53 <RyanT5000> that seems possibly reasonable
17:21:06 <RyanT5000> the only time i've found when side-effects are useful is for caching
17:21:07 <dibblego> it moots the benefits of OO once and for all
17:21:12 <dibblego> which is something I'm keen to do
17:21:16 <RyanT5000> yeah OO is retarded
17:21:20 <RyanT5000> that's my basic conclusion
17:21:40 <RyanT5000> each of its constructs is a special case of stuff you can do in higher-order languages like haskell
17:21:48 <RyanT5000> especially, e.g., dynamic polymorphism
17:21:50 <dibblego> I believe a formal proof that it contradicts its stated objectives is possible, but I'm not trained enoguh to produce it
17:22:17 <RyanT5000> well, any time you try to formally prove anything about an english statement you're probably screwed :P
17:22:20 <RyanT5000> but i know what you mean
17:22:26 <dibblego> yes
17:22:40 <RyanT5000> anyone here want to write a formal human language?
17:22:41 <dibblego> but for example, I believe that OO only meets its objectives when the software is in a black hole (profound?)
17:22:50 <RyanT5000> like haskell except for talking :P
17:23:01 <dibblego> or really, that OO misacknowledges computational progression (the arrow of time)
17:23:10 <RyanT5000> hm
17:23:18 <RyanT5000> i'm not exactly sure what either of those statements means
17:23:34 <dibblego> it requires the statement of a set of axioms
17:23:51 <dibblego> software does not exist without requirements; software is a function of a set of requirements
17:24:04 <RyanT5000> hm true
17:24:08 <dibblego> software requirements exist with validity at a point in time
17:24:15 <dibblego> tomorrow, they may be invalid
17:24:27 <dibblego> if you believe this, then you also believe that OO does not produce software
17:24:39 <RyanT5000> ah ok yeah i know this line of thought
17:24:50 <RyanT5000> OO does not adequately support changing software requirements
17:25:09 <RyanT5000> you are completely right and i have been grappling with this for a while
17:25:09 <dibblego> not only that, it deliberately sets out to prevent it
17:25:20 <RyanT5000> that may be, although i didn't think it through that far
17:25:33 <dibblego> I believe a formal proof is possible - perhaps one day, a full-fledged mathematician and I will do it
17:25:37 <RyanT5000> hm
17:25:54 <RyanT5000> well incidentally
17:26:03 <RyanT5000> i think we should work together on a programming language
17:26:13 <RyanT5000> i do think i have few things you don't
17:26:18 <dibblego> probably
17:26:25 <RyanT5000> and i know you have things i don't :)
17:26:34 <dibblego> I think you should discuss with a friend of mine, who has one thing better than I do - communication skills
17:26:41 <RyanT5000> ah
17:26:44 <dibblego> he is much better at it than me
17:26:52 <dibblego> I cannot communicate ideas very well
17:26:57 <dibblego> well, compared to him
17:27:09 <RyanT5000> hm, yeah i was going to say, i've found you pretty lucid so far
17:27:14 <dibblego> I think then we might have a very strong set of skills to meet our common objective
17:28:06 <RyanT5000> yeah, although i don't think this is necessary a good first haskell project
17:28:18 <RyanT5000> which is part of why i'm writing my game engine in haskell before working on a language
17:28:38 <dibblego> I want to understand monads more than anything, I just never have found the time
17:29:00 <RyanT5000> also, consider this: i know what i hate about OOP; now if i can also find what i hate about haskell, i'll really understand what needs to change :)
17:29:10 <RyanT5000> also, look at Arrows
17:29:10 <dibblego> all I know is they somehow allow working around the notion of state in a pure functional language
17:29:14 <RyanT5000> they're a generalization of Monads
17:29:40 <RyanT5000> a monad is a state machine
17:29:42 <dibblego> I can formally define, at least in my head, everything that is broken about OO - I am very clear on this
17:29:52 <RyanT5000> right, me too
17:29:53 <RyanT5000> ;)
17:30:20 <RyanT5000> so like the IO monad is the set of all possible states of the world outside the haskell program
17:30:41 <dibblego> then that is just an enumeration
17:30:42 <RyanT5000> an IO () is a function that is closed on that set
17:30:47 <RyanT5000> well you can't enumerate it
17:30:59 <dibblego> so there are infinite states
17:31:02 <RyanT5000> right
17:31:14 <dibblego> what is an IO () ?
17:31:18 <RyanT5000> it's what main returns
17:31:23 <RyanT5000> it's called an "IO action"
17:31:34 <dibblego> why main? the entry point of the program?
17:31:39 <RyanT5000> yeah
17:31:44 <RyanT5000> it doesn't have to be named main
17:31:57 <dibblego> why would it return the set of infinite possible states?
17:32:01 <RyanT5000> it doesn't
17:32:07 <RyanT5000> IO () is not a monad
17:32:10 <RyanT5000> it's an action on "the IO monad"
17:32:15 <RyanT5000> which is not actually really defined
17:32:23 <dibblego> I tihnk I need to read more
17:32:28 <dibblego> and I have to get some work done
17:32:33 <RyanT5000> alright, cya later
17:32:34 <dibblego> thanks for the chat
17:32:38 <dibblego> I will be in touch
17:32:39 <RyanT5000> you too
17:32:46 <dibblego> or tmorris _at_ tmorris.net - feel free
17:32:55 <RyanT5000> yep
17:33:02 <RyanT5000> and feel free to email me too
17:33:05 <dibblego> ok seeya
17:33:08 <RyanT5000> ryant5000 _at_ yahoo.com
18:26:47 <i|> YOU (i|) have been booted from ##everything by i| (i|)
18:39:11 <dons> cool. the a -> monad is now in Control..Monad.Instances
18:39:38 <RyanT5000> i just ran my first arrow-based interactive app
18:39:44 <dons> yay!
18:39:45 <RyanT5000> except i'm not using Arrows >.>
18:39:50 <RyanT5000> i just made my own kind of thing
18:39:58 <RyanT5000> and actually i don't see how to reduce it to arrows easily
18:40:03 <RyanT5000> but!
18:40:07 <RyanT5000> the idea is based on arrows :P
18:40:15 <dons> oh. your own kind of thing ? :)
18:40:23 <RyanT5000> yeah
18:40:56 <dons> so, with the Kleisli categories and all ;) 
18:41:09 <RyanT5000> well, i'm not exactly sure how to describe the mapping from arrow logic to my logic
18:41:13 <dons> (arrows have some nice theory undeneath them defining the abstraction)
18:41:18 <RyanT5000> C:\Documents and Settings\Administrator\Desktop\Graviton Studios\HMultiverse\Client\dist\build\Client
18:41:21 <RyanT5000> wtf
18:41:30 <RyanT5000> that's my output location :P
18:41:32 <RyanT5000> class ReactionGraph graph stimulus response where
18:41:32 <RyanT5000>      run :: graph -> stimulus -> response
18:41:33 <rasfar> dons: do you have a reference for that?
18:41:35 <RyanT5000> that's what i meant to paste
18:41:56 <dons> rasfar, check the Monads and Arrows page of the wiki, at:
18:42:06 <dons> ?wiki Research_papers
18:42:06 <lambdabot> http://www.haskell.org/haskellwiki/Research_papers
18:42:09 <RyanT5000> so, dons, there's a difference between my class and the Arrow class
18:42:15 <RyanT5000> which is that it has an additional parameter (graph)
18:42:25 <RyanT5000> i'm not exactly sure whether it matters
18:42:30 <rasfar> okay, I've been there ... not sure what nice theory underneath you're referring to... ;)
18:42:53 <skew> arrows are more different than that - the arrow is a type two parameters, that acts kind of like the function arrow
18:48:11 <tennin> Freyd categories?
18:48:22 <RyanT5000> actually... i may be wrong
18:48:31 <RyanT5000> my type might be more powerful than arrows
18:48:45 <RyanT5000> because arrows respond to exactly one kind of stimulus
18:48:58 <RyanT5000> am i right about that?
18:49:00 <Pseudonym> I don't think so.
18:49:28 <RyanT5000> i'm using "more powerful" with a very tightly defined meaning there
18:49:43 <RyanT5000> so ignore that part :P
18:49:57 <Pseudonym> :-)
18:50:09 <Pseudonym> Ryan, have you had a look at the Fudgets thesis?>
18:50:20 <RyanT5000> no
18:50:22 <RyanT5000> should i?
18:50:23 <RyanT5000> link?
18:50:34 <Pseudonym> @google fudgets thesis
18:50:53 <RyanT5000> but what i mean is, i'm not sure you can do what i'm doing with pure arrows
18:50:57 <Pseudonym> @google fudgets thesis
18:51:00 <RyanT5000> i didn't mean that i could duplicate arrows' functionality
18:51:16 <Pseudonym> Bleah.  It's http://www.cs.chalmers.se/~hallgren/Thesis/ anyway
18:51:16 <lambdabot> http://www.cs.chalmers.se/~hallgren/Thesis/
18:51:19 <dons> i think the fudgets theis should be on the research page of haskell.org somewhere.
18:51:19 <Pseudonym> Thanks!
18:51:24 <Pseudonym> I got it quicker than lambdabot.
18:51:30 <Pseudonym> Yeah, I think so too.
18:51:45 <Pseudonym> Fudgets are based on arrows, and they handle different kinds of stimuli.
18:51:52 <dons> ?gsite haskell.org fudgets thesis
18:51:54 <lambdabot> http://www.haskell.org/pipermail/haskell-cafe/2003-June/004510.html
18:52:02 <dons> huh
18:52:28 <rasfar> tennin: yes that paper looks helpful, i'm was just viewing that.  But really, it seems like Arrows never quite got off on so solid a categorical foundation as monads?
18:58:23 <dons> ? they do, no? see the arrow theory papers on the research papers page.
18:58:48 <dons> here: http://haskell.org/haskellwiki/Research_papers/Monads_and_arrows#Arrow_theory
18:58:49 <RyanT5000> Pseudonym are you sure they handle different types of stimuli?
18:59:07 <rasfar> I guess the confusing thing is that the two theoretical papers don't refer to arrows explicitly.
18:59:26 <dons> there's 4 on that list, so maybe theyre one's you haven't seen?
18:59:36 <RyanT5000> not just the same kind of stimulus with different data
18:59:42 <RyanT5000> it has to be a completely different type
19:00:08 <RyanT5000> (for software engineering reasons)
19:00:40 <rasfar> true, there's four.  i'll have to take a closer look...
19:05:37 <RyanT5000> anyone know, off the top of their head, how to set up perspective in OpenGL?
19:05:55 <RyanT5000> i've got all the calls except the one that makes the strength of the perspective be nonzero
19:06:05 <RyanT5000> (i.e.: the viewing distance be noninfinite)
19:07:38 <kpreid_> RyanT5000: gluPerspective or glFrustum
19:08:11 <RyanT5000> ah, gluPerspective might be what i'm looking for
19:08:17 <RyanT5000> i'm already calling glFrustum but it isn't enough on its own
19:08:19 <kpreid_> they do the same thing, with different inputs
19:08:22 <RyanT5000> do i need to be setting W values for everything?
19:08:34 <kpreid_> no
19:08:41 <int80_h> are the mailing lists archived?
19:08:43 <kpreid_> what parameters are you giving to glFrustum?
19:09:00 <RyanT5000> OpenGL.frustum (-1) 1 (-1) 1 (-1) 1
19:09:18 <RyanT5000> oh
19:09:32 <kpreid_> that is not going to work very well
19:09:41 <kpreid_> the viewpoint is at 0, 0, 0
19:09:49 <kpreid_> so you generally want both zNear and zFar to be positive
19:09:58 <kpreid_> in fact, it is so documented
19:09:59 <RyanT5000> ah ok
19:10:15 <RyanT5000> yeah, sorry
19:10:22 <RyanT5000> i don't have a great understanding of graphics math (yet)
19:10:47 <kpreid_> usually you set zFar to as far as you want to be able to see, and zNear according to how close you want to view things vs. how much depth buffer resolution you want in the distance
19:11:14 <kpreid_> gluPerspective is probably easier to understand how the parameters work
19:11:20 <RyanT5000> hm
19:11:41 <kpreid_> in glFrustum the left/right/bottom/top sets effectively the screen bounds as observed at the distance zNear
19:11:57 <RyanT5000> alright
19:12:02 <RyanT5000> yeah i think i get it now
19:12:16 <RyanT5000> so if i change it to OpenGL.frustum (-1) 1 (-1) 1 1 3
19:12:20 <RyanT5000> that'll give me some perspective
19:12:47 <kpreid_> also: if you want to view an object drawn at 0,0,0, after setting up the projection you need to translate in the modelview matrix so that the 'camera' isn't right on top of them
19:12:55 <RyanT5000> right
19:13:00 <RyanT5000> found that out already :)
19:13:09 <lispy> and zNear and zFar have to be > 0 rigt?
19:13:14 <kpreid_> lispy: yes
19:13:34 <RyanT5000> the math all works for zNear and zFar not >0 though, right?
19:13:40 <RyanT5000> it just doesn't represent an actual camera
19:13:57 <kpreid_> I don't know.
19:14:09 <kpreid_> (but glFrustum will report an error)
19:14:14 <RyanT5000> oh it will?
19:14:16 <RyanT5000> ok
19:14:30 <kpreid_> speaking of which, your code does call glGetError sometime, yes?
19:14:51 <lispy> hmm...i was thinking that in perspective projection you won't get any visuals with negative zNear
19:15:04 <lispy> seems like the other projection will draw tho
19:15:05 <RyanT5000> lol not yet :P
19:16:07 <kpreid_> not retrieving errors is a great way to get "...Why isn't it drawing anything at all?" or "Why are my objects whirling around like crazy?" (forgot a glPopMatrix; will show up as an overflow)
19:16:33 <RyanT5000> yeah
19:16:43 <RyanT5000> i never really thought of that as a debugging tool
19:17:10 <RyanT5000> that would've be a great thing for the professor of my junior year graphics class to have mentioned when we started
19:18:04 <kpreid_> write a routine which retrieves all the errors and just prints them (with perhaps a string for context), then do it regularly (like after every major object in your scene, if you have such)
19:18:27 <RyanT5000> yeah, that'd be pretty easy to do
19:21:49 <RyanT5000> what's a typical max matrix stack size for openGL?
19:21:54 <RyanT5000> should i basically use it a lot?
19:22:33 <RyanT5000> (i'll worry about performance later)
19:25:54 <kpreid_> I haven't seen enough to say 'typical'
19:26:07 <kpreid_> I've never hit the limit though
19:26:13 <RyanT5000> alright
19:26:44 <lispy> it would be interesting to write a test case to find that limit out on various configurations
19:27:03 <RyanT5000> oh, if all the points of a triangle lie outside the clip planes, the triangle is clipped right?
19:27:09 <kpreid_> no
19:27:12 <RyanT5000> crap
19:27:19 <RyanT5000> that would've been a good explanation :P
19:27:23 <kpreid_> er, wait, I don't know clip planes
19:27:49 <kpreid_> no, term confusion
19:27:55 <RyanT5000> hm
19:28:14 <kpreid_> a triangle 'bigger than the screen' won't disappear just because its points are all offscreen
19:28:21 <RyanT5000> alright
19:30:08 <Smokey`> RyanT5000: if any part of a polygon lies outside of a clipping plane, the parts of hte polygon outside of hte plane, are removed, essentially like taking a pair of scissors and cutting along the plane.
19:30:39 <Smokey`> make sense?
19:31:00 <RyanT5000> yeah
19:31:54 <kpreid_> RyanT5000: potential causes of entirely absent polygons: (a) your zNear and zFar frustum parameters are wrong, or (b) you're looking at them from the other side and have GL_CULL_FACE enabled
19:31:58 <Smokey`> in the case of clipping a triangle, it might result in two triangles (representing a quadrilateral)
19:32:24 <RyanT5000> well i now got something to show up
19:32:29 <RyanT5000> my frustum is
19:32:34 <RyanT5000> OpenGL.frustum (-1) 1 (-1) 1 1 3
19:33:06 <Smokey`> also make sure you're clearing your depth buffer AS WELL AS your colour/stencil/accumulation buffers.
19:33:17 <RyanT5000> and i'm drawing a rectangle of width 2 centered on the screen and with z = -2
19:33:23 <RyanT5000> but i want to know why z = -2
19:33:25 <RyanT5000> rather than 2
19:33:29 <RyanT5000> it doesn't show up with z=2
19:33:34 <RyanT5000> it shows up perfectly with z=-2
19:35:45 <kpreid_> RyanT5000: the camera looks towards negative z
19:35:49 <Smokey`> RyanT5000: that's not to do with your frustum then, that's to do with your modelview matrix... basically z=-2, the triangle is in front of the camera,  z=2, the triangle is behind the camera.  because you're most likely facing in the direction (0, 0, -1) and the camera is at origin, or some other arrangement (or something)
19:36:11 <RyanT5000> ah ok
19:36:20 <Smokey`> I say "or something" because i thought it defaulted to (0, 0, 1) too, but clearly it doesnt :)
19:36:23 <RyanT5000> right i forgot the right hand rule :)
19:36:34 <kpreid_> usually after you LoadIdentity the modelview you do a translation like (0, 0, -20) - that establishes the distance of the camera from 0 in the scene
19:36:50 <kpreid_> also, you should work with a much bigger z range, so you can see if you break something
19:36:50 <RyanT5000> yep, that's what i'm doing now and it works :)
19:37:02 <kpreid_> like 0.1 - 2000, say
19:37:33 <RyanT5000> alright
19:37:35 <kpreid_> don't worry about making it narrow unless you have depth buffer artifacts
19:37:58 <RyanT5000> thanks :)
19:38:07 <Smokey`> 0.1-2000 is more than fine for the depth complexity of most scenes with todays video cards.
19:38:25 <kpreid_> today's video cards?
19:38:39 <kpreid_> it's not a fuzzy thing, it's precisely the bit depth of your depth buffer
19:38:54 <RyanT5000> heh i'm working on a windowing system :)
19:38:56 <Smokey`> kpreid_: older video cards may only support 16/24bit depth buffers.
19:39:05 <RyanT5000> so in actual fact i'll be mostly using non-perspective views
19:39:20 <kpreid_> sure, I just mean it's not a fuzzy performance thing
19:39:34 <RyanT5000> isn't there such a thing as depth buffer compression?
19:39:48 <RyanT5000> that sounds like it could be a fuzzy performance thing, insomuchas you can't use it unless you have good performance
19:40:41 <Smokey`> no, has nothing to do with performance in most general cases unless you start using FBOs for image based techniques... in which case it's a bus/transfer rate issue, and the only way the depth buffer is involved is by taking up more space( a.k.a. completely irrelevant)
19:41:11 * kpreid_ leaves for the night
19:41:11 <RyanT5000> FBO?
19:41:23 <RyanT5000> is that something relating to displacement maps?
19:41:26 <Smokey`> mmm, OpenGL extension, lets you render to textures (amoung other things)
19:41:31 <RyanT5000> <-- out of his league
19:41:38 <RyanT5000> oh
19:41:42 <RyanT5000> yeah i like that one :P
19:42:27 <RyanT5000> soooo
19:42:36 <Smokey`> only issue w/ depth buffers how accurate the depth buffer is, the wider the span in the depth buffer, and less bit complexity (eg: 16bits, as opposed to 32bits), means artifacts will start arrising due to the fact it cant determine anyt difference between an object with a distance of 100.0 from the camera, and an object with a distance of w/ 100.1 from the camera)
19:42:52 <RyanT5000> right
19:43:07 <Smokey`> so you'll get triangles overlapping, or fighting ot be infront of each other (shimmering/popping/whatever you want ot call it)
19:43:20 <RyanT5000> yah
19:43:26 <RyanT5000> i've certainly seen enough of that in games
19:43:30 <Smokey`> hehe :)
19:43:39 <RyanT5000> UT2004 had a lot
19:43:54 <RyanT5000> i need to get a new graphics card :-/
19:44:08 <RyanT5000> i'm running a GeForce 4 440 Go
19:44:17 <RyanT5000> which doesn't even have pixel shaders
19:44:20 <RyanT5000> at all
19:44:30 <Smokey`> :)
19:44:39 <RyanT5000> it's practically the only GeForce 4 that doesn't
19:44:50 <RyanT5000> i think some of the GeForce 3's even have them
19:45:05 <RyanT5000> and it's (obviously) a laptop so i can't change it
19:45:10 * RyanT5000 cries
19:45:14 <Smokey`> re: UT2004 having depth buffer accuracy problems,  most games have a "draw distance"/"fog distance"/"view distance" option somewhere, which adjusts the farplane, and thus the far ranged of the depth buffer.
19:45:32 <Smokey`> unless they're dumb, and just change the farplane of the frustum, and NOT the depth buffer as well.  in which case they dont deserve to make games ;)
19:45:33 <RyanT5000> oh that does explain it...
19:45:45 <Smokey`> :)
19:45:47 <RyanT5000> cause all my friends maxed out their far planes
19:45:52 <RyanT5000> because that's how you snipe :P
19:45:56 <Smokey`> yup
19:46:01 <RyanT5000> avril across the map ftw :P
19:46:04 <Smokey`> hahaha
19:46:13 <Smokey`> anyway, I've gotta go man.  be back in a few hours. :)
19:46:16 <RyanT5000> alright, cya
19:46:27 <Smokey`> if you have any questions, just PM me, i'll get back to you when I can :)
19:46:32 <RyanT5000> k, thanks :)
19:47:06 <lispy> iirc, setting your near plane close to zero impacts the artefacts faster than having a large far plane value
19:47:34 <lispy> if you google it you can find a formula that basically tells you how fast your losing your bits of percsion as your move either plane
19:47:44 <RyanT5000> ah
19:48:00 <RyanT5000> yeah well i won't even be using a depth buffer for most of my stuff... i'm writing a windowing system
19:48:24 <lispy> in my experience a zNear = 1 is a good genearl purpose value
19:48:30 <RyanT5000> so unless i was going to count my windows, then increment the depth buffer value for each window
19:48:33 <RyanT5000> it wouldn't be too useful
19:48:39 <RyanT5000> plus, i can overdraw, so i probably should
20:18:22 <lisppaste2> RyanT5000 pasted "Type Issue" at http://paste.lisp.org/display/18888
20:18:37 <RyanT5000> coudl someone help me with this error?
20:19:10 <RyanT5000> it seems like i'm explicitly telling it something, and then it says it "can't deduce" it
20:19:24 <RyanT5000> (the error is at the end of the paste)
20:20:21 <RyanT5000> btw the code runs if i put in the exact type i'm going to pass to doDisplay (RotatedTriangle Double) in
20:20:53 <Cale> RyanT5000: hmm
20:21:52 <RyanT5000> sorry, it's a complicated example, but if i knew how to extract the thing that was causing the error i could probably fix it
20:22:32 <Cale> Just a shot, try changing one of the b's to a fresh variable. Also, you're not using the type b in the rest of the signature, so I don't think it could be helping
20:22:51 <Cale> maybe just delete  OpenGLScene b  altogether.
20:23:07 <RyanT5000> well i was trying to specify that that b was an OpenGLScene
20:23:20 <RyanT5000> does the order matter?
20:23:23 <Cale> nope
20:24:12 <RyanT5000> i mean if you see my instance declaration, there are some RotatedTriangles that can produce OpenGLScenes
20:24:57 <Cale> nstance Num t => ReactionGraph (RotatedTriangle t) DrawFrameStimulus (Scene t)
20:25:00 <Cale> er
20:25:06 <Cale> missed the i :)
20:25:10 <RyanT5000> yah
20:25:38 <RyanT5000> so there exist t's for which Scene t is an instance of OpenGLScene
20:25:48 <Cale> however, suppose that you apply the function doDisplay
20:25:57 <Cale> how does it tell which b to use?
20:26:33 <RyanT5000> hm what if i specify t
20:26:50 <RyanT5000> by making sure it's explicitly a RotatedTriangle Double
20:26:52 <RyanT5000> no that doesn't work
20:26:52 <Cale> You'll need to specify the scene type specifically
20:27:07 <Cale> before you pass anything to render
20:27:18 <Cale> since it'll need to know which type of scene, right?
20:27:23 <RyanT5000> ah ok
20:27:28 <Cale> (which implementation of render)
20:27:40 <RyanT5000> but what if i want that to depend on the input stuff?
20:27:55 <RyanT5000> for instance, what if i want someone to be able to pass me something that renders any kind of OpenGLScene
20:27:55 <Cale> well, you can have it depend on the input, but it currently doesn't
20:28:21 <RyanT5000> oh so do i need a dummy variable to the function?
20:28:41 <Cale> well, I think I know what you mean, but let me explain the problem :)
20:28:48 <RyanT5000> alright
20:29:21 <Cale> Suppose that for some type a, you have two instances of ReactionGraph a DrawFrameStimulus b, for different b's
20:29:36 <Cale> Currently, that's perfectly allowable
20:29:50 <RyanT5000> hm, true
20:30:05 <Cale> and there's no way to prevent it from eventually happening, since instances could be defined in some future module you don't know about
20:30:13 <RyanT5000> right
20:30:19 <Cale> So knowing 'a' doesn't give you information about 'b' right now.
20:30:32 <Cale> But you can add a restriction so that it does.
20:30:57 <Cale> something along the lines of:
20:31:05 <Cale> class ReactionGraph graph stimulus response | graph -> response where
20:31:05 <Cale>         run :: graph -> stimulus -> response
20:31:24 <Cale> the part after the | is called a functional dependency
20:31:34 <RyanT5000> hm
20:31:46 <Cale> It means that graph determines response uniquely, and as such limits you to exactly one instance
20:32:04 <Cale> but it also means that your problem of not knowing which b you're using should go away
20:32:05 <RyanT5000> hm now i need to figure out if that's what i mean to be saying
20:32:10 <Cale> yeah
20:32:40 <RyanT5000> can i make it (graph, stimulus) -> response?
20:32:49 <Cale> yeah
20:33:03 <Cale> graph stimulus -> response
20:33:13 <Cale> (the syntax is a bit odd)
20:33:56 <Cale> functional dependencies are an extension, but since you're already using multiparameter typeclasses, I don't suppose that you'll mind :)
20:34:02 <RyanT5000> right
20:34:02 <RyanT5000> :)
20:34:38 <heatsink> Hmm, haskell needs a way to distinguish tuples of types from tuple types... :)
20:35:07 <RyanT5000> although... i may want to restrict this from the render end instead
20:35:21 <RyanT5000> maybe OpenGLScene shouldn't be a class at all
20:35:50 <Cale> You can get quite a lot out of plain old parametric polymorphism :)
20:35:59 <RyanT5000> well i like it that haskell is forcing me to think about what i mean rather than how to say it
20:36:24 <Cale> yeah, type errors can catch some pretty deep problems :)
20:37:33 <RyanT5000> ah yeah i think this is better with parametric polymorphism
20:37:46 <RyanT5000> becuase let's say i figure out my Scene datatype sucks and is inefficient
20:38:07 <newsham> hi
20:38:10 <heatsink> hi
20:38:25 <RyanT5000> welll, i'm not sure where i'm going with this chain of logic
20:38:33 <RyanT5000> or how it leads to parametric polymorphism being the answer
20:38:38 <RyanT5000> but i think it does
20:39:36 <Cale> RyanT5000: well, classes are a sort of extension of ordinary parametric polymorphism -- You could, rather than insisting on OpenGLScene b, include as a parameter (render :: b -> IO ())
20:39:55 <Cale> and that would be about the same thing
20:40:06 <RyanT5000> ah true
20:40:14 <RyanT5000> and that's not really what i want
20:40:27 <RyanT5000> since the render function is pretty tightly coupled to the display routine anyway
20:40:50 <RyanT5000> it's certainly the tightest coupling i'm considering making isomorphic to solve my problem
20:56:03 <RyanT5000> hm Cale, i think having the rendering function get passed in is the best idea
20:56:46 <Cale> RyanT5000: It's simple and it works for now at least :)
20:57:04 <RyanT5000> i guess the real problem is that i haven't formalized where the line is drawn between the library and the library's user
20:57:09 <Cale> yeah
20:57:10 <RyanT5000> and i don't plan to yet
20:57:18 <Cale> exactly :)
20:57:20 <RyanT5000> in fact, i'm using glut now, and i don't plan to use that in the final version
20:57:32 <RyanT5000> so all this code is getting thrown away eventually
20:57:39 <RyanT5000> (or packaged up and never seeing the light of day again)
20:58:42 <RyanT5000> btw, do you see the relationship between ReactionGraph and Arrows?
20:59:00 <RyanT5000> i can't say i fully understand arrows, but after reading a bunch of Yampa stuff this is what i came up with
20:59:13 <Cale> It's probably an arrow somehow :)
20:59:17 <RyanT5000> i think it's a bit more general in some ways, although it's not as easy to use combinators on
20:59:37 <Cale> though it has more parameters than one, so possibly it's a specific type of Arrow
21:00:03 <Cale> I'm not really sure
21:00:14 <Cale> I haven't really used Arrows too much myself
21:00:22 <RyanT5000> for instance, i don't know how you can have an arrow graph where you feed it a "Message" and it returns an updated copy of itself, but you feed it a "DrawFrameStimulus" (poorly named, i know) and it returns a Scene
21:00:42 <RyanT5000> it's sort of like having multiple source/sink points on the arrow graph
21:00:55 <Cale> Well, that's the idea
21:01:13 <Cale> Arrows are always between two types
21:01:47 <RyanT5000> hm, but if you have an arrow that has input type (a, b) and output type (c, d)
21:01:54 <RyanT5000> and it's actually two arrows side-by-side
21:01:59 <RyanT5000> you might get the same effect
21:02:08 <Cale> yeah, that's a common trick
21:02:29 <Cale> @type (***)
21:02:31 <lambdabot> forall (a :: * -> * -> *) c' c b' b.
21:02:31 <lambdabot>    (Arrow a) =>
21:02:31 <lambdabot>    a b c -> a b' c' -> a (b, b') (c, c')
21:02:53 <RyanT5000> right but once you have that, can you update just a particular one of them?
21:02:55 <RyanT5000> er
21:02:57 <RyanT5000> evaluate
21:03:01 <Cale> @type first
21:03:03 <lambdabot> forall (a :: * -> * -> *) d c b.
21:03:03 <lambdabot>    (Arrow a) =>
21:03:03 <lambdabot>    a b c -> a (b, d) (c, d)
21:03:09 <Cale> hmm
21:03:55 <Cale> well...
21:04:14 <Cale> @type pure fst
21:04:15 <lambdabot> forall (a :: * -> * -> *) a1 b.
21:04:15 <lambdabot>     (Arrow a) =>
21:04:15 <lambdabot>     a (a1, b) a1
21:04:26 <Cale> @type (>>> pure fst)
21:04:28 <lambdabot> forall (a :: * -> * -> *) a1 b b1.
21:04:28 <lambdabot>       (Arrow a) =>
21:04:28 <lambdabot>       a b1 (a1, b) -> a b1 a1
21:05:06 <Cale> however, you really need that other input -- there's no guarantee from the type that the arrow doesn't do anything with it
21:05:16 <RyanT5000> right
21:05:35 <RyanT5000> do you think it's conceivable that my type isn't strictly weaker than arrows?
21:05:55 <RyanT5000> i.e.: couldn't be implemented in terms of
21:06:12 <Cale> Well, arrows are rather general, but it's quite possible.
21:06:13 <RyanT5000> because if that's the case i'm happy; if it could be arrows, i'd really like to make it into arrows
21:06:44 <Cale> If it's not naturally an arrow, it also might be best to leave it alone :)
21:07:00 <RyanT5000> true, although i was trying to make a system based on arrows when i came up with this ;P
21:07:03 <RyanT5000> *:P
21:09:43 <RyanT5000> hm i think one fundamental difference between my system and arrows is that you can't write a stateful ResponseGraph
21:10:04 <RyanT5000> or maybe you can :-/
21:10:18 <RyanT5000> but the way i capture state is by recreating the whole graph whenever anything changes
21:10:27 <RyanT5000> is that horribly inefficient?
21:16:11 <Cale> well, I have to sleep, but I'll tell you something about monads and arrows
21:16:40 <Cale> They're both used when you want to embed a domain specific language into Haskell, so that you can write parts of your program in it.
21:17:17 <RyanT5000> that's exactly what i'm trying to do, write a GUI language
21:17:41 <Cale> With monads, your 'run' function can't possibly perform optimisations on the 'source code' of the programs written in this EDSL, since >>= takes a function as its right parameter, and those are not observable (can't test them for equality even)
21:18:04 <Cale> With arrows, you can have special arrows in your type which are not in the image of the 'pure' function.
21:18:16 <Cale> and which the 'run' function can treat specially
21:18:41 <Cale> (as well as >>>, to some extent -- you may even have to include that operation as a structural part of your type)
21:19:04 <RyanT5000> hm
21:19:56 <Cale> The result is that you can have 'run' do clever optimisations, and make certain tricks possible, where various special arrows have more global information about the computation going on than what's fed to them
21:20:34 <RyanT5000> interesting
21:20:53 <RyanT5000> i have no idea whether i want that ability or not :P
21:21:00 <Cale> For example, with signal transformers, you might have some special arrows which have access to the future or the past values of the signal, or even the whole input signal, whereas the images of pure would act pointwise.
21:21:42 <RyanT5000> ok that makes some sense
21:21:51 <RyanT5000> i read half a dissertation on arrows this morning
21:21:59 <RyanT5000> the one about Yampa and stuff
21:22:48 <Cale> With parsers, you might have a very clever 'run' function which knows things about what inputs the parsers it's combining accept, and can efficiently implement union without any unnecessary backtracking.
21:23:18 <Cale> (i.e. it won't even bother to try parsers which would fail immediately)
21:23:28 <RyanT5000> ok so basically the point of these things is to make smarter combinators
21:23:31 <Cale> or even gain the ability to print the parsers
21:23:37 <Cale> yeah
21:23:49 <RyanT5000> alright well i certainly don't need that for now
21:23:56 <RyanT5000> but i'm going to read the Fudgets stuff
21:24:12 <RyanT5000> i don't really think it'll do what i'm looking for though
21:28:50 <dons> have you looked at yampa?
21:33:36 <RyanT5000> yeah, i didn't think it was a perfect fit
21:33:57 <RyanT5000> but i can't say i totally understood it
21:35:02 <RyanT5000> do you have much experience with yampa?
21:37:29 <dons> a stduetn i work with wrote Frag, the 3d game, in it. its pretty much the cutting edge of arrow-based reactive haskell code.
21:38:40 <RyanT5000> how difficult is it to have the arrow graph change itself at runtime?
21:38:48 <RyanT5000> or is it never necessary to do that?
21:39:10 <RyanT5000> i know there's that switch thign
21:39:26 <dons> hmm. i imagine with the right combinators, you can rewire things
21:39:46 <RyanT5000> what if i want to, for instance, have a button called "Make Window"
21:39:50 <RyanT5000> that makes a new window
21:39:58 <RyanT5000> which i can press an arbitrary number of times
21:40:06 <RyanT5000> then i can close windows however i like
21:40:16 <RyanT5000> that didn't seem easy in yampa
21:40:55 <dons> no idea. doesn't sound hard though.
21:41:08 <RyanT5000> hm,  have you looked at fudgets?
21:51:46 <dons> nope. 
21:51:52 <lispy> dons: i just saw your email on darcs-dev, i'll see if darwinports has a newer version of ghc
21:53:07 <RyanT5000> ah here's one thing i dislike about yampa: it requires me to use IO
21:53:35 <lispy> IO ain't so bad
21:53:48 <RyanT5000> but it's limiting; why would i use it if i don't need to?
21:54:14 <lispy> what do other thngs use?
21:54:15 <RyanT5000> i can write the entire rendering system without using it
21:54:39 <lispy> what are you writing?
21:54:39 <RyanT5000> well right now what i'm doing is passing a DrawFrameStimulus to my GUI state, and getting out a Scene
21:54:49 <skew> limiting? you can do anything in IO you can do without it - witness programs written in just about any langauge but Haskell
21:54:51 <RyanT5000> i'm writing a windowing system
21:55:07 <lispy> oh right
21:55:07 <RyanT5000> yes, skew, but i can't use a function that uses IO anywhere
21:55:11 <skew> yep
21:55:26 <lispy> sure you can, just wrap it in unsafePerformIO ;)
21:55:31 <RyanT5000> hahahaha
21:55:43 <lispy> hm...no newer ghc in darwin ports....
21:55:43 <RyanT5000> one thing i was thinking of is Undo
21:55:55 <skew> depends what yampa stuff you are doing, probably
21:56:25 <lispy> oh well, i'll just 'fix' any darcs source i need to compile for now by hand
21:56:46 <lispy> RyanT5000: you want a window manager with undo?
21:56:58 <RyanT5000> lol 1) for the hell of it
21:57:02 <RyanT5000> 2) orthogonality
21:57:14 <lispy> er wait, windowing system? so it's a replacement for X or for the window manager?
21:57:29 <RyanT5000> for X, essentially :P
21:57:33 <RyanT5000> but not entirely
21:57:41 <RyanT5000> i'm writing an OpenGL game
21:57:51 <RyanT5000> it needs a heavy-duty windowing system, due to the nature of the game
21:58:01 <RyanT5000> i want it to be pure-functional
21:58:06 <RyanT5000> this leaves me with few options
21:58:13 <RyanT5000> actually, even without that last requirement all the options suck
21:58:24 <lispy> sounds like it leaves you with the "write it yourself" option mostly :)
21:58:29 <RyanT5000> right
21:58:35 <RyanT5000> which is why i'm studying Yampa and Fudgets and stuff
21:58:53 <RyanT5000> anyway, here's why the windowing system needs to support Undo:
21:59:08 <RyanT5000> you know Model View Controller?
21:59:16 <lispy> sure
21:59:32 <RyanT5000> well you can take the View's state to be a Model
21:59:53 <RyanT5000> also any kind of Controller parameterization
22:00:01 <RyanT5000> basically anything with state is a Model
22:00:27 <RyanT5000> so if you have Undo for your "main" Model
22:00:33 <RyanT5000> (which i need)
22:00:47 <RyanT5000> and you generalize the windowing system's design from MVC as i just did
22:01:00 <RyanT5000> then you're left with a windowing system that supports Undo
22:01:38 <skew> that sounds interesting - a thing has a model, view and controller, all of which are MVC triples?
22:01:55 <skew> an infinite lazily evaluated tree?
22:01:58 <RyanT5000> i don't think a model is an MVC triple
22:02:04 <RyanT5000> it ends up being a grid, actually
22:02:13 <RyanT5000> with the "ultimate" model at the top
22:02:22 <RyanT5000> "pure" controllers along the righthand edge
22:02:27 <RyanT5000> "pure" views along the lefthand edge
22:02:44 <RyanT5000> user is the lowest node
22:02:58 <RyanT5000> and every counter-clockwise cycle is a data flow path
22:03:09 <RyanT5000> er, counter-clockwise rectangular cycle
22:03:18 <RyanT5000> one particular time this would come in handy is, for instance, keymapping configuration
22:03:27 <RyanT5000> you should be able to undo keymapping changes
22:03:47 <RyanT5000> even though they're a property of the Controller
22:04:00 <RyanT5000> of course you get into issues with having multiple undo lists
22:04:19 <skew> this still sounds like a tree to me - I don't see how things tie back together
22:04:21 <RyanT5000> but it's a question of "how do you expose it to the user?" not "how do you make it support it"
22:04:28 <RyanT5000> well let's say i type a key
22:04:48 <RyanT5000> er hm
22:04:58 <RyanT5000> well it's definitely cyclical
22:05:19 <RyanT5000> i hit a key, the controller receives a message, it modifies the model, the view re-renders it, i see something appear on the screen
22:05:38 <skew> oh, there's that funny state stuff going on
22:05:48 <skew> right, that kind of makes control flow cycles
22:06:05 <RyanT5000> if you remove the controller->view link which is usually put in, you are required to have a stateless controller and a stateless view
22:07:23 <RyanT5000> although if you consider the view to be polling the model, rather than receiving an update signal from it (as will actually be the case in my system) then maybe it's not so obviously cyclical
22:07:31 <RyanT5000> however i think it's logically cyclical anyway
22:08:06 <skew> you want to pretend it always mirrors the model, I think
22:08:19 <RyanT5000> yeah
22:08:40 <skew> I don't see how Yampa particularly involves IO
22:08:47 <skew> just from reading the tutorial paper
22:08:49 <RyanT5000> i thought reactimate required it
22:08:56 <skew> oh, that one maybe
22:09:04 <skew> but none of the stuff constructing the graph
22:09:11 <RyanT5000> right, it doesn't then
22:10:10 <RyanT5000> also i'm not terribly thrilled with the whole SF thing
22:10:20 <RyanT5000> it looks good for realtime systems, which is what it's intended for obviously
22:10:34 <RyanT5000> but it doesn't look right for an event-driven system
22:11:57 <skew> it's doesn't look that bad - an SF is a time series of stuff, they have the Maybe thing set up to handle channels carrying discrete events
22:12:04 <skew> Event == Maybe
22:12:09 <RyanT5000> yeah
22:12:28 <RyanT5000> the SP stuff looks a lot closer
22:13:05 <skew> I'm not sure what else you would do, but have connections between places, and events flowing along them
22:13:33 <skew> they probably are kind of pretending with the time input on the event channels
22:13:36 <RyanT5000> the SF stuff that feels wrong to me is time being nondiscreet
22:14:23 <skew> I think that lets you pretend that things behave deterministically, though
22:15:09 <skew> if you said a channel was modeled by a list of events, then a merger getting [a] and [b] would have a choice of outputting [a,b] or [b,a]
22:16:13 <RyanT5000> you mean interleaving?
22:16:18 <skew> yeah
22:16:28 <skew> like, a node that's supposed to combine two event streams
22:16:33 * Pseudonym hmms
22:16:33 <RyanT5000> well you can't do that at all in a nondiscreet system
22:16:42 <Pseudonym> Anyone here know a large amount about numeric analysis?
22:16:54 <RyanT5000> well here's another thing to think about: can you use Yampa in a nonpolled way?
22:17:19 <skew> sure you can, if neither channel has an event hapenning at this instant, your output doesn't have an event happenning either
22:17:28 <RyanT5000> and why is there a 1:1 corresponence between "rendering a frame" and "processing a message"
22:17:45 <skew> if one channel has an event hapenning, your output has that event hapenning
22:18:07 <RyanT5000> hm
22:18:08 <skew> and both channels have an event at the same time with probability zero, so we don't worry
22:18:15 <skew> that's what the math looks like, anyway
22:18:25 <RyanT5000> yes except that isn't actually true
22:18:26 <skew> are you sure Yampa actually runs on polling?
22:18:34 <RyanT5000> i'm pretty sure
22:19:18 <RyanT5000> i mean your "sense" function could block waiting for input
22:19:23 <skew> from skimming the paper, it sounds like the API is all in terms of continous time
22:19:23 <RyanT5000> but then you wouldn't get any frames of animation
22:19:49 <RyanT5000> yeah, and how does continuous time make sense from the perspective of an event-driven system?
22:19:58 <skew> and perhaps you are just reading that as implying a polling implementation
22:20:12 <RyanT5000> perhaps
22:20:20 <RyanT5000> did you look at the type of reactimate though?
22:20:52 <RyanT5000> i don't think there's any way to update your data without drawing a frame
22:21:04 <RyanT5000> unless i guess you had an event which asked for a frame
22:21:19 <RyanT5000> but that's crappy because that should be resolved by the type system at compile-time not by the logic at run-time
22:22:32 <skew> but that's something like looking at a mathematical description of a function, and then saying something about floating point numbers
22:22:49 <RyanT5000> true
22:23:16 <skew> you might do the frame stuff as a loop off in one part of your system that does frames as fast as possible, and grabs fresh data for each one
22:23:39 <RyanT5000> yeah and that's what i want to figure out if it's possible
22:23:43 <skew> arrows are really supposed to be drawn, not coded up
22:23:51 <skew> it's certainly possible to describe a graph like that
22:24:04 <skew> I don't know how the yampa system would actually run it
22:24:30 <RyanT5000> clearly the graph for "update my Model given my input" should be very tightly integrated with "render my Model"
22:24:41 <skew> more like tangent
22:24:42 <RyanT5000> due to the MVC stuff i was describing above
22:24:59 <RyanT5000> because if they aren't complicatedly interrelated you just have crappy old MVC
22:25:10 <skew> like, you have an input stream coming in, and some tangle with memory for the object and how to update it
22:25:31 <skew> and then hanging off the side with just a little latch for sampling the state, you have a loop drawing it
22:25:39 <skew> that's what I'm imagining, anyway
22:25:41 <RyanT5000> yeah
22:25:51 <skew> if you have a bunch of things to draw it probably gets trickier
22:25:51 <RyanT5000> i don't see  how arrows could support that
22:26:07 <skew> you just make the arrows corresponding to that picture
22:26:33 <skew> going way back, arrows probably have the most foundation of anything, and arrow is pretty much a category with objects = haskell types
22:26:34 <RyanT5000> i don't think there's any way to have multiple entry/exit points from an arrow graph
22:27:06 <RyanT5000> because all arrow combinators yield arrows as output
22:27:06 <skew> sure you can, but it gets ugly because of how it's turned into text
22:27:19 <skew> you end up with arrows that take tuples
22:27:35 <skew> like, there's loop :: Arrow (a,b) (a,c) -> Arrow b c
22:27:44 <RyanT5000> right
22:27:57 <skew> which is how you make a graph with a loop going back of type a
22:28:06 <RyanT5000> yah i know
22:28:24 <skew> well, that Arrow (a,b) (a,c) thing is a box with two inputs and two outputs
22:28:32 <skew> and you want to loop back from the a output to the a input
22:28:49 <RyanT5000> ok so an arrow graph is also an arrow
22:28:56 <skew> yeah
22:29:08 <skew> the arrow combinators are like minimal operations for building up graphs
22:29:13 <RyanT5000> right
22:29:32 <skew> and then some axioms about how they commute, to tell you that they are really just making that graph
22:29:33 <RyanT5000> so let's say i want to be able to put in either my Game State and a Message, and get out a new Game State
22:29:44 <RyanT5000> or put in a Game State and get out a Frame
22:30:10 <RyanT5000> what is the type of that Arrow / graph
22:30:19 <skew> something with inputs and outputs involving Either
22:30:22 <RyanT5000> or, what could be the type
22:30:26 <RyanT5000> yeah exactly
22:30:32 <RyanT5000> Either, which is dynamic typing
22:30:52 <skew> see the ArrowChoice class
22:31:04 <skew> dynamic typing? not exactly
22:31:24 <skew> it's a fixed set of types allowed
22:31:35 <RyanT5000> yeah sure, so is dynamic typing
22:31:41 <RyanT5000> "the set of all types defined in my program"
22:31:44 <skew> and the arrow combinators actually guarantee how things will flow between the cases of the either stuff
22:32:29 <RyanT5000> hm
22:32:33 <RyanT5000> it still rubs me the wrong way
22:33:19 <RyanT5000> what if i have 2 pieces of my code: one of them updates the gamestate, the other of which renders a frame
22:33:22 <RyanT5000> so i use Either and whatever
22:33:25 <skew> I think a big part of the problem is that it's so ugly to code with arrows
22:33:35 <RyanT5000> then, later, i add a new piece of the program
22:33:49 <skew> if you could just draw a picture and compile that, it would be better
22:33:54 <RyanT5000> indeed
22:33:59 <RyanT5000> (my next project after my game)
22:34:04 <RyanT5000> (i'm totally serious)
22:34:12 <skew> you wouldn't want to use Either for that, I think
22:34:34 <RyanT5000> let me show you what my code looks like right n ow
22:34:39 <skew> stuff like Yampa is about putting together some kind of data flow graph, sort of like LabView
22:34:54 <RyanT5000> right, actually labview was the first thing i thought of
22:35:06 <skew> I think you really want an autonomous loop, rather than something you drive externally to either make a frame or do an update
22:35:14 <lisppaste2> RyanT5000 pasted "Stuff" at http://paste.lisp.org/display/18895
22:35:35 <RyanT5000> hm that could be
22:36:39 <RyanT5000> although then you'd need to have your arrow return an IO
22:36:59 <skew> not really
22:37:09 <skew> the function for running the arrow would be in IO
22:37:19 <skew> the type of the arrow itself would possibly mention IO too
22:37:30 <RyanT5000> see, i don't like that all that much
22:37:31 <skew> the types flowing in the system don't all have to be in IO
22:37:46 <skew> you have to hit IO eventually
22:37:50 <RyanT5000> of course
22:37:53 <skew> like, when the program actually runs
22:38:08 <skew> same thing if your program is an arrow thing
22:38:15 <skew> still need to hit IO when you actually run it
22:38:29 <RyanT5000> yeah, but remember how i wanted all actions within my windowing system to be subject to Undo?
22:38:43 <RyanT5000> that rules out letting it touch anything near IO
22:39:05 <RyanT5000> anyway the interesting bit in that thing i pasted is 
22:39:05 <RyanT5000> class ReactionGraph graph stimulus response where
22:39:05 <RyanT5000>         run :: graph -> stimulus -> response
22:39:21 <RyanT5000> so then we have things like
22:39:27 <RyanT5000> data RotatedTriangle a = RotatedTriangle (Vector a) (Vector a) (Vector a) a a
22:39:36 <RyanT5000> instance Num t => ReactionGraph (RotatedTriangle t) Message (RotatedTriangle t) where ...
22:39:46 <RyanT5000> instance Num t => ReactionGraph (RotatedTriangle t) DrawFrameStimulus (Scene t) where ...
22:39:59 <RyanT5000> everything's strongly typed
22:40:17 <RyanT5000> so if i want it to draw a frame, i run it on a DrawFrameStimulus
22:40:29 <RyanT5000> if i want it to update itself based on a message, i run it on the message
22:41:20 <RyanT5000> i don't really know how one would map this kind of thing onto IO
22:41:22 <RyanT5000> er
22:41:26 <RyanT5000> onto arrows
22:41:38 <RyanT5000> i need to find an Arrows Person :P
22:42:27 <RyanT5000> of course the windowing system will be based on Combinators
22:42:39 <RyanT5000> even RotatedTriangle is too complicated to be a primitive
22:43:00 <mwc> RyanT5000, http://en.wikibooks.org/wiki/Programming:Haskell_arrows is a good read
22:43:07 <RyanT5000> thanks
22:45:08 <RyanT5000> mwc do you know arrows well?
22:45:33 <skew> that looks like the run function for some arrows, Arrow a () -> a -> IO ()
22:46:35 <mwc> RyanT5000, no, I think I understand how to use them, but no chance to have done so yet
22:46:44 <RyanT5000> hm
22:48:06 <RyanT5000> my basic complaint is that i can only use an arrow in one way
22:48:18 <RyanT5000> what i'd really like are parallel arrow systems
22:48:48 <RyanT5000> so for instance in the first system, i input a Message and a GameState, and get out a new GameState
22:49:02 <RyanT5000> in the second system i input () and get out a Frame
22:49:11 <skew> you could make something like that, maybe
22:49:46 <skew> you are now pretty far into research
22:49:54 <RyanT5000> that's how i like to be :)
22:50:01 <RyanT5000> why the hell am i not getting a phd
22:50:02 <RyanT5000> lol
22:50:08 <RyanT5000> i'm going to law school in 6 months
22:50:13 <RyanT5000> i guess more like 5 now
22:50:15 <RyanT5000> wtf
22:54:50 <tennin> good, we need a more purely functional legal system.
22:54:57 <RyanT5000> lol
22:55:49 <RyanT5000> well i'm mostly going for two reasons: 1) i'm pissed off about the RIAA et al as well as digital privacy stuff and 2) i got into harvard
22:55:59 <RyanT5000> i don't necessarily want to be a lawyer
22:56:05 <mwc> good
22:56:21 <mwc> I think they lobotomize your idealism away when you go in for your bar exam
22:56:23 <Korollary> That's a lot of work for not necessarily wanting to practice law.
22:56:33 <RyanT5000> yeah, korollary, i know
22:56:35 <mwc> (my uncle is a lawyer)
22:56:45 <RyanT5000> i still don't know if it's the right decision
22:56:54 <RyanT5000> i find law interesting, though
22:57:02 <Korollary> can it wait until you are more certain?
22:57:28 <RyanT5000> well, i'd have to withdraw my acceptance, and of course it wouldn't wait for me
22:57:46 <RyanT5000> so i'd have to apply again if i did want to go, and tbh i don't think i got in by a huge margin
22:58:02 <Korollary> do you have a fellowship or something?
22:58:15 <RyanT5000> also, i can't just sit around at home (i'm taking a year off now, between college and law school)
22:59:03 <RyanT5000> the thing is, i am pretty passionate about legal issues
22:59:18 <RyanT5000> esp. those that relate to computers
22:59:28 <mwc> cool
22:59:39 <RyanT5000> i definitely don't want to be a programmer as a career
22:59:51 <mwc> We need more people in law that can differentiate a toaster from a pentium
22:59:56 <RyanT5000> yeah
23:00:04 <Korollary> I think we need fewer people, but oh well heh
23:00:04 <mwc> RyanT5000, ideally, I'd like to see more folks like that in parliament/congress
23:00:23 <RyanT5000> i figure worst case i'm paying with 6 years of my life: 3 in law school and 3 to pay back the loans
23:01:18 <RyanT5000> i am strongly considering trying to go to MIT for Ph.D. work afterwards, though
23:01:22 <RyanT5000> in cs, that is
23:01:46 <Korollary> why do you diss programming as a job?
23:01:57 <RyanT5000> oh that's not it
23:02:16 <RyanT5000> i want to possibly design programs
23:02:30 <RyanT5000> implementation isn't fulfilling enough
23:02:32 <mwc> Korollary, he's probably under the impression it's more EA style work than say Paul Graham's type stuff
23:02:50 <skew> depends on the implementation language...
23:02:52 <mwc> RyanT5000, implementation is probably the most fulfilling thing I do
23:02:59 <mwc> but then I'm a computational physicist in training
23:03:30 <Korollary> It doesn't have to an extreme decision: either 100% theory or 100% implementation.
23:03:38 <RyanT5000> i know that
23:03:38 <Korollary> +be somewhere in that sentence
23:03:47 <RyanT5000> but i'll never be happy with someone telling me what code needs to be written
23:04:06 <RyanT5000> that's the issue
23:04:07 <Korollary> what if that person is a reasonable person and you agree with him?
23:04:22 <RyanT5000> i dunno, i want creative control
23:04:30 <Korollary> I have creative control
23:04:48 <Korollary> in fact, a lot of companies would like their employees to invent more stuff on their own
23:04:55 <RyanT5000> probably so
23:04:59 <RyanT5000> gah, i dunno
23:05:40 <skew> it seems funny somebody would spec something out so precisely there is no creativity left, and not type it in themselves
23:05:58 <Korollary> things are usually way underspecified actually
23:05:59 <RyanT5000> yah i know, i'm not really being very insightful or accurate
23:08:37 <Korollary> gah. The Daily Show is a rerun tonight.
23:08:42 <RyanT5000> that sucks
23:08:52 <skew> not that we wouldn't like more lawyers knowing what lambdas are.
23:08:58 <RyanT5000> i haven't been watching it lately (i can tell because it isn't haskell)
23:09:13 <RyanT5000> but it's an awesome show
23:09:29 <RyanT5000> yeah well i know i can make a ton of money as a lawyer knowing CS stuff
23:09:39 <Korollary> I am not sure if law would benefit from any formalization. I think their predicates are so subjective that a deduction system is worthless.
23:09:40 <RyanT5000> but that doesn't enter into my decision really
23:09:51 <RyanT5000> yeah i think that's probably true
23:10:17 <skew> I don't know about formalizing law, but it would help if people making and enforcing laws about software knew the first thing about it
23:10:17 <RyanT5000> although perhaps if you formalized all the formal parts, you could isolate the subjective decisions, and derive some value from that
23:10:29 <RyanT5000> yeah, that's what i'm interested in
23:10:37 <RyanT5000> what i really want to do
23:10:41 <RyanT5000> is write a filesharing program
23:10:52 <RyanT5000> and other programs
23:10:59 <Korollary> I dont know why software is so special. I don't understand copyrights for paper books, either.
23:10:59 <RyanT5000> specifically designed to challenge the laws on the books
23:11:22 <RyanT5000> copyright is an incentive to be creative
23:11:53 <RyanT5000> you get a monopoly on your creative work to help you pay for the cost of creating it
23:12:10 <skew> copyright on books is to encourage publishers to pay authors
23:12:11 <RyanT5000> however, it's critical to the functioning of society that that monopoly has certain limits
23:12:33 <RyanT5000> aka "fair use"
23:13:03 <skew> http://www.baen.com/library/palaver4.htm
23:13:11 <skew> I think that sums it all up pretty well
23:14:45 <skew> add a few points about how just about everybody now has the equipment to copy stuff for themselves
23:25:16 <RyanT5000> ah ha!
23:26:02 <RyanT5000> a class with one function is basically equivalent to a function type
23:26:32 <RyanT5000> so i have my class class ReactionGraph graph stimulus response where 
23:26:32 <RyanT5000>      run :: graph -> stimulus -> response
23:26:52 <RyanT5000> which is essentially the same as saying
23:27:18 <RyanT5000> newtype Graph stimulus response = stimulus -> response
23:27:25 <RyanT5000> which is essentially the same as an arrow
23:27:53 <RyanT5000> that would be completely true if the class parameters stimulus and response were dependent on graph
23:29:00 <RyanT5000> however, they aren't, so their types actually serve to choose an arrow at compile-time from a set, defined by the instances of  ReactionGraph
23:29:06 <RyanT5000> does that make sense to anyone other than me?
23:29:11 <skew> it's not quite the same, more like a function from a type to the member
23:29:47 <RyanT5000> which is?
23:29:58 <RyanT5000> you mean the class is?
23:33:38 <tennin> hmm, one reason I got interested in functional languages is that I want to get the portion of time spent on interesting "design" work as opposed to tedious, repetitive "implementation" labor as close to 100% as possible
23:34:33 <RyanT5000> this is true
23:34:51 <Korollary> Well there's more to design than just at the language level.
23:34:54 <astecp> tennin: well put
23:34:56 <tennin> though that might not be what you meant
23:35:00 <Korollary> such as algorithms, fault tolerance, etc.
23:36:26 <RyanT5000> tennin: is that related to/in response to what i've been saying?
23:36:49 <RyanT5000> i.e.: does it seem like i'm spending a lot of time on an implementation issue?
23:37:14 <RyanT5000> because i think that's partially true, although mostly i'm working on getting a better fundamental understanding of my datastructure
23:37:56 <tennin> just to (01:02:03) RyanT5000: i want to possibly design programs
23:38:04 <tennin> (01:02:23) RyanT5000: implementation isn't fulfilling enough
23:38:16 <RyanT5000> oic
23:38:24 <RyanT5000> absolutely
23:38:39 <RyanT5000> programming in C++ ruined my love for computer science
23:38:50 <RyanT5000> which i am only now regaining since finding haskell
23:39:06 <tennin> it's a possibly unfair interpretation of what you said, though
23:39:16 <RyanT5000> no, i think it's reasonable
23:40:05 <sethk> RyanT5000, I programmed in c++ for 15 years.  You can recover
23:40:08 <RyanT5000> what i really mean, i guess - and i suppose this is somewhat arrogant, but it's just an aspiration anyway - is that i want to be the guy deciding what software needs to be written
23:40:25 <RyanT5000> not as in "a marketing guy"
23:40:31 <RyanT5000> although partially that kind of thing
23:40:50 <Korollary> "visionary" heh
23:40:53 <sethk> RyanT5000, best way to decide what software needs to be written is to write it and convince other people to use it.
23:41:03 <astecp> that decision involves waaay too many non-technical consideration to interest me
23:41:10 <RyanT5000> sethk: not entirely
23:41:32 <Korollary> You can also start your own company
23:41:36 <Korollary> at some point, that is.
23:41:38 <RyanT5000> for instance, sethk, even if i can describe th e perfect OS pretty well, i still can't write it
23:41:39 <sethk> RyanT5000, I believe it's the best way, and I have a lot of experience.  But of course the theoretical possibility exists that I'm wrong.  :)
23:41:48 <RyanT5000> it's just too huge
23:42:07 <sethk> RyanT5000, you write the core, and build a company around that core.
23:42:21 <sethk> of course that reflects my lack of business ability, most likely
23:42:45 <RyanT5000> writing the next generation OS has been one of my major goals for about 5 years
23:42:48 <bolrod> ]
23:42:51 <astecp> I remember the last company that created the perfect OS
23:42:57 <bolrod> :)
23:42:57 <RyanT5000> lol
23:42:59 <astecp> didn't they have a name something like "Be"?
23:43:07 <sethk> RyanT5000, in 5 years you can write a lot of software
23:43:23 <tennin> getting somebody else to do the boring parts isn't really a satisfying solution, although it's easy for me to say that since I don't have the money/status to do that anyway
23:43:25 <RyanT5000> yeah well i kinda went to college and stuff in the interim
23:43:31 <Korollary> I dont think an os is worth pursuing perfection.
23:43:42 <RyanT5000> i didn't say perfection :)
23:43:57 <RyanT5000> the problem with Be is that they forgot that they needed to make money
23:43:58 <Korollary> you said perfect os
23:44:08 <RyanT5000> that was in my hypothetical
23:44:14 <RyanT5000> "even if i could design the perfect OS"
23:44:25 <RyanT5000> my real goal uses the words "next generation" ;)
23:44:29 <RyanT5000> small distinction
23:44:37 <RyanT5000> however the problem is, of course, how to make money
23:44:43 <Korollary> why not write something else
23:44:48 <RyanT5000> because the OS sucks
23:44:52 <RyanT5000> and everything is built on the OS
23:44:53 <Korollary> it doesn't even have to be perfect. Just useful would do.
23:44:55 <RyanT5000> the world needs a new OS
23:45:01 <RyanT5000> that's why i'm writing my game :)
23:45:07 <RyanT5000> it's a good game
23:45:08 <RyanT5000> not perfect
23:45:11 <RyanT5000> hell, i didn't even design it
23:45:26 <RyanT5000> imagine that - me wilfully implementing something someone else designed
23:45:35 <bolrod> you could question if there is such a thing as 'a perfect OS'
23:45:35 <RyanT5000> it actually has been a struggle, psychologically
23:45:42 <RyanT5000> i agree bolrod
23:45:52 <astecp> it would be "the", for a start
23:46:03 <sethk> haskell really is an amazing language.  I wrote a very large piece of software today that I just tried, and it basically worked the first time.
23:46:23 <bolrod> astecp: true
23:46:35 <Korollary> sethk: haskell programmers are better than the industry avg imho
23:46:43 <dons> sethk:  cool :)
23:46:47 <bolrod> but music for isntance.. is there a 'the best musical piece' ?
23:46:57 <sethk> Korollary, yes, but the language is surely a large factor
23:46:58 <bolrod> everybody wants something else from an OS
23:47:39 <mwc> I'm looking through a lot of the proposals on Haskell'. Stuff like MultiWayIfs and LambdaCase seem to be stuff that would be really easy to implement in template haskell, woudn't they?
23:47:40 <astecp> bolrod: a best musical piece? That's easy. Anything by Frank Zappa.
23:47:47 <bolrod> haha  
23:48:01 <Korollary> astecp: heh
23:48:10 <RyanT5000> bolrod: yes, everyone wants something different, but does anyone want windows, or linux?
23:48:25 <mwc> Hurd/L4 sounds really cool
23:48:26 <bolrod> I want linux more then windows
23:48:32 <Korollary> I want neither. I have both.
23:48:35 <mwc> I'm sure my grandchildren will find it interesting but antiquated
23:48:37 <bolrod> thats all I can say
23:48:42 <RyanT5000> here's the problem
23:48:45 <mwc> by the time RMS the 3rd finally blesses it
23:48:51 <RyanT5000> OS design has stagnated for 30 years
23:49:03 <bolrod> I have had windows XP
23:49:08 <bolrod> I have ubuntu and os x
23:49:29 <bolrod> for just normal browsing, irc and stuff os x is fine
23:49:41 <mwc> bolrod, find it easier to get work done on linux too?
23:49:41 <bolrod> but I wouldn't want ONLY os x
23:49:42 <Korollary> The best o/s is the one that I don't notice.
23:49:50 <RyanT5000> name one major OS kernel innovation since the introduction of unix
23:50:02 <RyanT5000> i mean, what's the biggest change?
23:50:02 <bolrod> mwc: find it that linux is 100 times more reliable then windows xp
23:50:13 <astecp> RyanT5000: bollocks. There are interesting projects such as plan9 and tunes and beos and hurd and wings going on everywhere. The problem (if any) is in the market which is driven by demands for an OS that are even more historically-constrained than the programmer who asks "right, where's the object system?"
23:50:14 <mwc> RyanT5000, real microkernels that actually deliver what the whole microkernel idea was supposed to?
23:50:16 <mwc> like L4?
23:50:51 <RyanT5000> ok my statement was overbroad; i know about plan9 etc.
23:51:04 <RyanT5000> name one in an OS you can actually use
23:51:13 <tennin> I haven't used any version of Windows since 98
23:51:15 <mwc> Hurd!
23:51:16 * mwc ducks
23:51:38 <RyanT5000> i want to see an OS that can compete with windows
23:51:45 <bolrod> EH!?
23:51:46 <RyanT5000> and linux
23:51:46 <mwc> you won't
23:51:50 <bolrod> oh
23:51:55 <bolrod> bsd?
23:52:16 <mwc> the defining characteristic of windows is that it runs every last piece of hardware to come out of some shanghai factory in the last 10 years
23:52:26 <tennin> Linux is definitely better than MS Windows 98, but aren't the new versions supposed to be more stable?
23:52:27 <Korollary> with poppus
23:52:29 <RyanT5000> right, so why can't anyone reverse-engineer the windows driver model?
23:52:36 <mwc> THe primary goal of windows si to be absolutely ubiquitous
23:52:38 <astecp> o_O
23:52:42 <mwc> and they suceed
23:52:46 <RyanT5000> right
23:52:50 <Korollary> the primary goal is to make money
23:52:51 <mwc> RyanT5000, they have. look up stuff like ndiswrapper
23:53:02 <RyanT5000> yeah, i've heard of it
23:53:03 <mwc> I don't care if linux could run windows drivers
23:53:09 <mwc> it's binary-tainted
23:53:16 <bolrod> ubuntu kernel has alot of wifi drivers built in
23:53:25 <RyanT5000> ... you don't like having the ability to run proprietary software?
23:53:26 <astecp> linux is held back by its insistence of competing with windows
23:53:30 <bolrod> ubuntu does quite a good job at finding hardware I heard
23:53:37 <RyanT5000> yes, bolrod, it does
23:53:41 <RyanT5000> here's the deal
23:53:44 <RyanT5000> make any excuse you want
23:53:52 <bolrod> you seen Xgl ?
23:53:53 <RyanT5000> but i don't see any kind of real threat to microsoft
23:53:56 <sethk> tennin, "better" is a meaningless term.  What are your requirements?
23:53:57 <RyanT5000> why is that
23:54:09 <bolrod> Xgl opens up to alot of new possible desktop apps
23:54:16 <bolrod> someone just needs to find a good use to it
23:54:27 <RyanT5000> is Xgl the OSS response to longhorn's desktop engine?
23:54:39 <astecp> RyanT5000: well it's not because of any technical superiority windows has, and I think that's the ground most people want to compete on.
23:54:44 <mwc> Xgl is the OSS response to the "oooh, transparency!"
23:54:46 <bolrod> I dont know if it was there before longhorn
23:55:07 <bolrod> and transparency was also available before Xgl I guess
23:55:09 <RyanT5000> i know astecp, but i don't think microsoft is unassailable
23:55:10 <sethk> dons, I have a type I created, a record type, with a bunch of constructors.  I'm building a map, which is a Map String MyType.  I've made another record type, which is basically an enumeration with one Constructor for each constructor in MyType.  That seems kludgy, but I also don't see a way around it.
23:55:15 <sethk> dons, is that followable?
23:55:40 <dons> if it was technical superiority that mattered in the mattered, everyone'd be using haskell..
23:55:48 <tennin> the main reasons I use Linux over MS Windows, however, are (1) it's Free Software, and I like the concept, and (2) it's free software, and I'm broke.
23:55:50 <RyanT5000> that's a great point dons :)
23:55:53 <dons> maybe if we came up with a haskell ipod, to sucker peopel in.
23:55:59 <astecp> dons: as an operating system? 0_o
23:55:59 <sethk> dons, maybe I'd better do a paste thing :)
23:56:08 <mwc> I htink this whole OS discussion should move to #haskell-blah 
23:56:10 <mwc> but that's just me
23:56:15 <mwc> as long as nobody else is complaining...
23:56:18 <astecp> or maybe #ideologies :)
23:56:27 <bolrod> #utopias
23:56:29 <dons> sethk, yep. need to see the code
23:56:32 <mwc> alt.talk.jihad.1992?
23:56:34 <RyanT5000> the main reason i use Windows over linux is that i am designing a game, i don't want to cross-develop, and i wnat to make money
23:56:57 <RyanT5000> good point mwc
23:57:03 <bolrod> thats why windows has 95% marketshare
23:57:16 <bolrod> everybody makes windows apps because they want to make money
23:57:19 <astecp> because of TRAITORS LIKE YOU
23:57:24 <mwc> windows has a 95% percent marketshare because it's good enough for most people
23:57:25 <bolrod> INDEED!
23:57:33 <RyanT5000> right
23:57:37 <astecp> BURN THE WINDOWS DEVELOPER
23:57:41 <mwc> they buy a printer, plug it in, fire up word, and write to aunt suzy
23:57:46 <RyanT5000> so
23:57:49 <RyanT5000> recognnizing that
23:57:55 <mwc> people here are people who use computers for more sophisticated stuff
23:57:57 <RyanT5000> why don't we make a plugin for Visual studio
23:58:01 <mwc> we own powertools.
23:58:09 <RyanT5000> that automatically compiles all your windows apps for linux
23:58:12 <tennin> talk.redundant
23:58:17 <bolrod> then fire up the e-mail  (outlook express)   
23:58:27 <mwc> so I don't think this channel is a representative sample of what the actual market forces are
23:58:31 <RyanT5000> if you make it retardedly simple for people to develop on linux
23:58:34 <bolrod> and write to your family you have one of them dual core processors
23:58:36 <RyanT5000> they will do so
23:58:42 <tennin> sorry for contributing
23:58:57 <RyanT5000> it's just not worth even 10% extra effort to make 5% extra money
23:59:06 <RyanT5000> so porting to linux is economically impossible
23:59:11 <bolrod> erh
23:59:21 <RyanT5000> or infeasible
23:59:24 <bolrod> just write portable code
23:59:28 <bolrod> ;/
23:59:38 <astecp> no, I like the idea of this visual studio plugin
23:59:47 <astecp> that automatically compiles windows code for linux
23:59:51 <astecp> someone go and write it
23:59:56 <RyanT5000> pretend i'm "mr. douchebag developer who writes visual basic in visual studio, and hardly even knows what linux is"
23:59:57 <sethk> dons, http://paste.ubuntu-nl.org/12078
