00:17:37 <sethk> hmm, I'm putting in thousands of lift statements, and the compiler is mostly happy, but it barfs on a catch
00:18:08 <sethk> says the first argument of the catch is StateT CSstate IO and it should be IO
00:18:24 <sethk> might have to code my own catch?  If that's even possible?
00:19:16 <sethk> or just lift?
00:20:12 <sethk> never mind, at least for the moment.
00:27:27 <sethk> I'll have to use the fork replacement you gave me and do something similar for catch.
00:27:49 <sethk> Should I have to put in 10000 lift statements?  Am I doing something backwards?
00:28:43 <Cale> you're only using one transformer
00:29:11 <Cale> so you should only need one for a given IO action
00:32:22 <sethk> Cale, yes, but I have many many IO actions
00:32:29 <sethk> but I think I see a better way.
00:32:37 <Cale> lift $ do ...
00:32:52 <sethk> ok, I can try that
00:33:13 <Cale> or if they're yours, lift them in their definition :)
00:33:16 <sethk> couldn't I also create a function, myGet, that gets the state using runStateT, and returns it as IO StateType ?
00:34:18 <Cale> You pass an initial state to runStateT though
00:34:44 <sethk> right, that's no good
00:41:53 <sethk> lift $ do doesn't work with a tail recursive function
00:42:21 <sethk> at least with one of mine
00:43:18 <sethk> Cale, thanks for your help.  I'm going to have to think about this for a while and see if I can figure out how to do it without a whole lot of hacking.
01:07:52 <valez> hello, im trying to write a function that given for example the list ["b","bba","b","ba","ba"] will return ["bbba","bbaba"]   will check if an element contains a symbol here 'a' if yes will add it to the previous one and do the same for the whole list
01:08:08 <valez> cant find a way to write it recursively
01:08:21 <valez> i know its a while loop
01:09:07 <valez> or not hmm
01:25:16 <bolrod> ?
01:25:29 <bolrod> what should it do?
01:27:39 <bolrod> valez: ?
01:28:38 <valez> yes
01:28:59 <valez> got any ideas?
01:29:00 <bolrod> what does that function need to do
01:29:21 <valez> not sure if i can do it only in one function
01:29:34 <bolrod> -.-
01:29:38 <bolrod> what does it have to do
01:30:55 <valez> checks the elements of the list one by one if a special character exists in that element add that element to the previous one in the list 
01:31:08 <valez> elements will be strings
01:31:41 <bolrod> 'special' 
01:32:01 <ValarQ> should other elements be put anywhere?
01:32:50 <ValarQ> and what about the special case when the first element contains something "special"?
01:33:03 <valez> if an element is added to the previous one should be deleted from its current position
01:33:09 <valez> it wont
01:34:34 <ValarQ> i think i understand the problem now...
01:38:26 <ValarQ> not sure how to solve it thought :/
01:38:57 <bolrod> how is this 'special' defined?
01:38:58 <ValarQ> my first thought is to use span or break
01:39:06 <valez> what im trying to do is 'transorm' a definition with guards that takes several lines into the same definition that will take one line, special character is '|' and elements of the list are the lines of the definition
01:39:30 <bolrod> so if | exists anywhere in the string
01:39:36 <bolrod> it should be added to the string before it ?
01:39:42 <valez> right
01:39:45 <bolrod> ok
01:39:50 <bolrod> sounds simple enough
01:41:02 <valez> for example definition:
01:41:17 <valez> myInt a
01:41:29 <valez>     | a>0  = 1
01:41:42 <valez>      |a==0     = 2
01:41:49 <valez> will be in a list:
01:42:47 <valez> ["myInt a", "| a>0   =1", "| a==0   =2"]  
01:43:34 <valez> and should become: [ "myInt a  | a>0  =1  | a==0   = 2"]
01:44:20 <bolrod> ohic
01:49:24 <astrolabe> I don't see, but would it might be helpful to transform your list [a,b,c,d] to [(a,b),(b,c),(c,d)] to start with.
01:49:41 <astrolabe> ?
01:49:41 <bolrod> nah
01:50:28 <araujo> ok, im here
01:52:20 <valez> hmm its not necessaty that i will end up with one element in the final list
01:52:41 <bolrod> almost there
01:52:47 <bolrod> only stupid types don't match yet
01:59:33 <bolrod> ok..  simple problem
01:59:59 <bolrod> 'a' (??)  [['b']] ->  [['a','b']]
02:05:03 <valez> an idea would be make [['b']] into ['b'] add the 'a' and then make the ['a','b'] into [['a','b']]
02:06:33 <bolrod> *Main> listgroup' ["test","test","tes|t"]
02:06:33 <bolrod> ["testtesttes|t"]
02:06:38 <bolrod> is that what you want?
02:07:21 <bolrod> *Main> listgroup' ["test","tes|t","test"]
02:07:21 <bolrod> ["testtes|t","test"]
02:08:45 <bolrod> valez: ?
02:08:54 <valez> the result in the first one should be ["test",testtes|t"]
02:09:00 <valez> but i can fix that
02:09:08 <bolrod> ok
02:09:10 <bolrod> lets see
02:14:35 <bolrod> *Main> listgroup' ["test","tes|t","test"] 
02:14:35 <bolrod> ["tes|ttest","test"]
02:14:35 <bolrod> *Main> listgroup' ["test","test","te|st"]
02:14:35 <bolrod> ["test","te|sttest"]
02:15:16 <bolrod> listgroup' xs =foldl (\l r-> if '|' `elem` r then reverse (r`onhead`(reverse l))  else l++[r]) [] xs
02:15:19 <bolrod>          where
02:15:20 <bolrod> yes
02:15:22 <bolrod>            onhead l (r:rs) = (l++r) :rs
02:15:22 <bolrod> it's ugly
02:15:25 <bolrod> :]
02:19:01 <valez> :)
02:19:07 <valez> thank you very much
02:20:49 <bolrod> you might want to optimize it if you're using it an awfull lot
02:21:01 <bolrod> but then again.. use the profiler ;)\
02:21:57 <valez> :) yeh ill see what i can do
02:22:13 <bolrod> don't optimize before you're done with the program ;p
02:26:41 <valez> yeh the whole thing is huge
02:47:21 <basti_> whats the axioms of a hash table?
02:49:18 <lispy> the first rule of hash table is that you do not talk about hash tables
02:49:32 <lispy> the second rule of hash tables is that you do not talk about hash tables
02:49:53 <lispy> the third rule of hash tables is that if it is your first time using a hash table you have to store a value
02:50:02 <basti_> lol
03:42:40 <araujo> Good morning.
03:45:41 <jyp> @quote
03:45:41 <mbot> xtmdster says: I knew that thing did more than 2+2.
03:57:28 <lesshaste> Hi.. I am trying to understand this code for a red-black tree and need a little help :)
03:57:30 <lesshaste> balance Black (RBNode Red (RBNode Red t11 x1 t12) y t21) x2 t22 =
03:57:31 <lesshaste>                RBNode Red (RBNode Black t11 x1 t12) y (RBNode Black t21 x2 t22)
03:58:19 <lesshaste> is this the case where the node x2 is black but its left child is red and so is its left grandchild?
03:59:03 <basti_> the function doesn't appear to eat a whole subtree.
03:59:21 <basti_> (respectively, it appears to eat -more- than a subtree)
03:59:48 <lesshaste> it is from http://pages.cpsc.ucalgary.ca/%7Erobin/class/417/RedBlack.hs
03:59:58 <lesshaste> I am just trying to understand the balance function
04:00:39 <basti_> balance ought to have a type somewhat like balance :: (RBTree a) -> (RBTree a).
04:00:53 <lesshaste> yes that's right
04:00:54 <basti_> I don't see how a single Colour value fits in there
04:03:21 <lesshaste> oh dear... how about http://pastebin.com/662869
04:03:58 <lesshaste> balance :: Ord t => 
04:03:59 <lesshaste>    Colour -> t -> RBTree t -> RBTree t -> RBTree t
04:04:02 <lesshaste> balance Black x a (Node Red y b (Node Red z c d))
04:04:03 <lesshaste>   = Node Red y (Node Black x a b) (Node Black z c d)
04:04:04 <basti_> hmm so the paremeters for balance are "color", "left subtree" and "right subtree"?
04:04:20 <lesshaste> appears so
04:04:29 <basti_> oh and a t
04:04:31 <lesshaste> although remember that I am the one that needs help :)
04:04:36 <basti_> so it's iso to RBTree t.
04:04:41 <basti_> I'm just wondering :D
04:04:56 <lesshaste> yes there is the node  and the left and right subtrees
04:04:59 <lesshaste> the node has a colour
04:05:04 <basti_> yes.
04:05:22 <lesshaste> can you interpret the balance line I pasted just above?
04:05:33 <basti_> so "balance Black (RBNode Red (RBNode Red t11 x1 t12) y t21) x2 t22 " is obviously Black node, Red subtree to the left, Red subtree even below
04:05:54 <lesshaste> basti_: sorry.. can you move to the new code :)
04:05:59 <lesshaste> balance Black x a (Node Red y b (Node Red z c d))
04:05:59 <lesshaste>   = Node Red y (Node Black x a b) (Node Black z c d)
04:06:03 <basti_> #
04:06:10 <basti_> its the same
04:06:17 <lesshaste> what is Black x a?
04:06:30 <basti_> Black is the color of the root of the subtree
04:06:34 <basti_> x is the value in the root
04:06:39 <lesshaste> and a?
04:06:39 <basti_> a is the left subtree.
04:06:40 <basti_> ah.
04:06:52 <basti_> so that the both red nodes are below in the right subtree.
04:07:08 <lesshaste> data Colour = Red | Black
04:07:09 <lesshaste> data RBTree t = Nil |
04:07:09 <lesshaste>          Node Colour t (RBTree t)  (RBTree t)
04:07:16 <lesshaste> that's the type
04:07:32 <basti_> yes.
04:07:48 <basti_> the type of balance, however is:    Colour -> t -> RBTree t -> RBTree t -> RBTree t
04:07:54 <lesshaste> yes
04:08:00 <basti_> color, value, left subtree, right subtree
04:08:03 <basti_> (of a tree node)
04:09:48 <lesshaste> so the "a" is the left subtree and not some polymorphic type thing?
04:10:14 <basti_> yes, "a" is the left subtree.
04:10:17 <basti_> 13:06 < basti_> a is the left subtree.
04:10:38 <lesshaste> that explains it :) I thought it was something to do with the fact the tree is polymorphically typed
04:10:49 <lesshaste> which also uses an "a" :) "a" is a strange name for a tree :)
04:11:22 <basti_> yes, maybe.
04:11:31 <basti_> polymorphic somethings only appear in type expressions
04:11:36 <basti_> (after ::'s)
04:11:39 <lesshaste> right
04:11:41 <lesshaste> thanks
04:11:45 <lesshaste> I am learning sloooooowly
04:11:58 <basti_> better than not learning at all.
04:11:59 <basti_> ;)
04:12:03 <lesshaste> so in this new light let me reread it :)
04:12:09 <lesshaste> (2 days to learn Haskell :) )
04:12:15 <basti_> to do what with it?
04:12:23 <lesshaste> you don't want to know :)
04:12:31 <lesshaste> I can tell you in pm
04:12:36 <basti_> heh
04:13:03 <lesshaste> I told you you didn't want to know :)
04:13:17 <basti_> I welcome your courage.
04:13:18 <araujo> basti_, now tell everyone
04:13:22 * araujo giggles
04:13:23 <lesshaste> thank you
04:13:46 <basti_> :P
04:15:08 <lesshaste> ok.. so that is clearly a left rotate :)
04:15:17 <lesshaste> anyone want to disagree :)
04:15:34 * astrolabe wants to know the secret
04:15:51 <araujo> i would want... but i still don't have breakfast
04:15:58 <lesshaste> ok 
04:16:18 <lesshaste> balance Black x a (Node Red z (Node Red y b c ) d)
04:16:19 <lesshaste>   = Node Red y (Node Black x a b) (Node Black z c d)
04:16:21 <lesshaste> is recolouring
04:16:27 <araujo> i don't like to disagree with anybody, about anything with my stomach empty :-)
04:16:59 <lesshaste> wise
04:17:57 <astrolabe> I wonder if it would be better to have RedNode and BlackNode as constructors.
04:18:14 <lesshaste> astrolabe: to make it clearer you mean?
04:18:38 <astrolabe> To decrease the number of terms in the code (ie to simplify).
04:19:10 <lesshaste> astrolabe: could be good
04:19:16 <lesshaste> astrolabe: it's a bit confusing at present
04:19:21 <astrolabe> But it might have the opposite effect, so I was wondering.
04:20:01 <astrolabe> functional data structures are possibly not the easiest place to start if this is your first functional language.
04:20:52 <astrolabe> Ah, I see you are examining someone else's code, please ignore most of what I said.
04:21:52 <lesshaste> astrolabe: that's ok. I can change it to make it simpler if you tell me how :)
04:22:59 <astrolabe> My guess is that it would be best to understand it first, then decide :)
04:24:03 <lesshaste> astrolabe: yes
04:28:31 <lesshaste> balance Black z (Node Red x a (Node Red y b c)) d
04:28:31 <lesshaste>   = Node Red y (Node Black x a b) (Node Black z c d)
04:28:31 <lesshaste>  
04:28:35 <lesshaste> looks suspicious
04:29:02 <astrolabe> I agree
04:29:59 <astrolabe> Ah no, I meant  Node Red z (Node....) d   looks suspicious.
04:30:10 <lesshaste> oh I see.. it's doing a left rotate and a right rotate on the parent in one step
04:30:12 <lesshaste> hmm...
04:32:12 <astrolabe> Because I guess the third argument of Node should be an 'a'
04:33:55 <lesshaste> astrolabe: sorry.. are you talking about the pastebin code?
04:34:14 <astrolabe> 10[12:17] lesshaste: 01balance Black x a (Node Red z (Node Red y b c ) d)
04:34:56 <lesshaste> astrolabe: right.. that x as root, z as right child and y as left child of z
04:35:30 <lesshaste> astrolabe: d is the right tree of Node Red z _ d
04:36:23 <astrolabe> Ah, you've changed the order round, I see.
04:37:28 <astrolabe> Does your code work?
04:37:47 <lesshaste> it's not my code :)
04:37:56 <lesshaste> does it work is an interesting question...
04:38:00 <lesshaste> I would have to prove it correct
04:38:05 <lesshaste> which is what I am trying to do more or less
04:38:38 <lesshaste> at least I know understand what it is doing
04:38:48 <lesshaste> now to establish if that is actually what it should be doing :)
04:38:55 <lesshaste> s/know/now
04:44:11 <lesshaste> well.. it certainly doesn't do the same thing as http://www.ececs.uc.edu/~franco/C321/html/RedBlack/redblack.html L((
04:44:14 <lesshaste> :((
04:46:18 <astrolabe> That does nothing for me, so maybe that's not a bad thing.
04:46:29 <lesshaste> it's java
04:46:33 <lesshaste> you might need to jre
04:46:39 <lesshaste> for your browser
04:47:10 <lesshaste> seems that haskell red-black trees use different rules from other red-black trees!
04:47:38 <astrolabe> Does it respect the invariant condition?
04:48:10 <lesshaste> the haskell rules do it seems... the difference is in how it deals with
04:48:51 <lesshaste> root x black, right child y red, left child z of y red 
04:49:02 <lesshaste> the "correct" way is just to recolor them
04:49:12 <lesshaste> the haskell rules actualy reorder the nodes
04:49:18 <lesshaste> I have no idea why
04:49:34 <lesshaste> so normally you just do at most one left rotate and one rotate and some recolourings
04:49:47 <lesshaste> in haskell there is an extra node reordering operation
04:50:12 <lesshaste> balance Black z (Node Red x a (Node Red y b c)) d
04:50:18 <lesshaste>   = Node Red y (Node Black x a b) (Node Black z c d)
04:50:19 <lesshaste>  
04:50:23 <lesshaste> that's the extra operation
04:50:47 <astrolabe> I could be because haskell is functional.
04:51:26 <lesshaste> I think it is a simplification so you don't have to call balance recursively maybe?
04:51:33 <lesshaste> (not sure about that)
05:07:48 <vincenz> re
05:10:26 <vincenz> Hello peeps!!!
05:10:34 <olliej> morning/evening/afternoon vincenz 
05:10:52 <vincenz> well... objectively noon, subjectively morning
05:10:58 <olliej> :)
05:12:45 <lesshaste> astrolabe: I give up :)
05:12:47 <olliej> does anyone have any pointers to a description of higher ranked types that might have "real" examples -- I know what they are, but i can't come up with a decent example (I'm not one of natures haskell programmers)
05:13:13 <lesshaste> olliej: you mean higher order functions?
05:13:30 <olliej> higher ranked... higher order is just function as value isn't it
05:13:36 <olliej> or have i got terminology screw again
05:13:41 <olliej> ?
05:13:44 <olliej> i'm meaning
05:13:48 <lesshaste> olliej: no no.. bound to be me ;)
05:13:55 <olliej> (forall a . a -> Foo)
05:14:01 <olliej> as an argument
05:14:15 <olliej> (it's a GHC extension rather than hazskell proper)
05:14:41 <olliej> s/hazskell/Haskell
05:14:50 <olliej> lesshaste: :)
05:24:20 <araujo> olliej, i know that as "higher order functions"
05:25:23 <araujo> It's kind of a consequence of being first class objects in the system.
05:27:20 <olliej> i  mean for example: foo :: (Show a, Show b) => (a,b) -> (forall c . (Show c) => c -> String -> (String, String)
05:27:28 <olliej> oops
05:27:41 <olliej> there should be a ')' after c -> String 
05:28:11 <jip> hey, did you guys see my haskell devlog yet?
05:28:15 <olliej> foo (x,y) g = (g x, g y)
05:28:34 <olliej> which is a trivial and completely useless example
05:28:51 <lesshaste> looking at  http://pastebin.com/662869 again... what stops the root being made red??
05:28:52 <ayrnieu> olliej - indeed!  Nobody would ever want to do that.
05:28:53 <olliej> araujo: but i was looking for a more useful example
05:29:05 <olliej> ayrnieu: :)
05:29:44 <olliej> ayrnieu: that is a useless example, i know there are case where they are useful, but damn if i can come up with a nice and simple useful example :)
05:30:17 <jip> http://www.mutantlemon.com/omegagb/devlog/
05:30:47 <ayrnieu> olliej - the 'evolution of a programmer' list of implementations of factorials has neat uses of combinators, e.g. in its Pascal programmer example.
05:30:48 <araujo> > let f g = g 3 in f (+ 2)
05:30:52 <mbot> 5
05:31:11 <araujo> olliej, that's a simple _not_ so useful example probably.
05:31:37 <olliej> araujo: yes, but it doesn't result in higher ranked types as arguments
05:32:08 <alar> jip: Philippa is no "he" AFAIK
05:32:14 <alar> no -> not
05:32:23 <araujo> i am not sure what you mean with higher ranked types.
05:32:43 <olliej> araujo: a function type with unbound type parameters
05:33:21 <jip> Philippa: eh? it can't be...
05:34:26 <olliej> eg. f :: a -> b -> (forall c . c->(c,c)) -> ((a,a), (b,b))
05:34:38 <jip> alar: it can't be
05:34:46 <olliej> araujo: f x y g = (g x, g y)
05:35:16 <lesshaste> olliej: although I feel this isn't your question look at the code for any haskell compiler
05:35:36 <olliej> lesshaste: am writing a haskell compiler :)
05:35:45 <lesshaste> olliej: I mean a compiler written in Haskell
05:35:50 <olliej> hehe
05:35:51 <olliej> bah
05:35:57 <lesshaste> olliej: there are normally examples in text books
05:35:57 <olliej> :)
05:36:08 <olliej> actually that's a point
05:36:15 * olliej digs in piles of books
05:36:31 <lesshaste> olliej: good luck
05:36:56 <araujo> @type f x y g = (g x, g y)
05:36:58 <mbot> parse error on input `='
05:36:59 <olliej> damn
05:37:07 <olliej> library made me return simon pj book
05:37:16 <araujo> @type let f x y g = (g x, g y) in f
05:37:18 <mbot> forall t a.
05:37:18 <mbot>            t -> t -> (t -> a) -> (a, a)
05:37:30 <olliej> araujo: higher ranked types can't be infered
05:37:33 <jip> alar: are you sure about this?
05:37:39 <olliej> araujo: hence the explicit singatures :)
05:37:51 <alar> yes
05:38:00 <olliej> hurrah, 5 years of CS and i still can't type properly :)
05:39:13 <olliej> @type let f x y (g::forall c . c->(c,c)) = (g x, g y) in f
05:39:14 <mbot> forall c
05:39:14 <mbot> [4 @more lines]
05:39:35 <olliej> mbot apparently doesn't like them
05:39:49 <araujo> olliej, i see the type infered there.
05:40:12 <araujo> polymorphically of course.
05:40:25 <olliej> araujo: have you got ghc ?
05:40:33 <araujo> yup
05:41:00 <jip> alar: but how can it be?
05:41:25 <alar> jip: what's so amazing in it?
05:42:55 <olliej> araujo: just coming up with an example that will actuall go :)
05:44:06 <jip> alar: nothing :)
05:44:09 <araujo> olliej, good, i can't find anything on google :-)
05:45:33 <alar> jip: well, I felt strange when found that she knows functional programming much better than I do, but I don't think it is impossible
05:46:18 <arjanb> olliej: in all papers i have seen they use silly examples, probably because useful examples are too complicated
05:46:46 <olliej> arjanb: :(
05:52:15 <vincenz> olliej: ook een hollander?
06:05:53 <olliej> vincenz: nopr
06:06:24 <olliej> araujo: dammit i can't make ghci use them, it keeps on ignoring the type specifiers, though i'm sure it has worked before
06:07:19 <olliej> araujo: make a hs file with h :: a -> b -> (forall c . c -> [c]) -> ( [a], [b])
06:07:31 <olliej> araujo: h x y z = (z x, z y)
06:07:44 <olliej> araujo: and
06:07:59 <olliej> araujo: g a b = h a b []
06:08:15 <olliej> then ghci -fglasgow-exts filename
06:13:22 <olliej> araujo: and do :t h
06:24:09 <araujo> olliej, ok, and... what's the main idea behind that?
06:25:23 <olliej> araujo: to have even more abstraction
06:26:00 <olliej> so you can have functions that can work over multiple different types
06:27:10 <araujo> ok, explain me further, how is that different from:
06:27:22 <araujo> @type let h x y z = (z x, z y) in h
06:27:24 <mbot> forall t a.
06:27:24 <mbot>            t -> t -> (t -> a) -> (a, a)
06:27:56 <olliej> araujo: did you put it in exactly as i said?
06:28:13 <araujo> Prelude> :t h
06:28:13 <araujo> h :: forall b a. a -> b -> (forall c. c -> [c]) -> ([a], [b])
06:28:18 <olliej> with the h :: a -> b -> (forall c . c -> [c]) -> ( [a], [b])
06:28:28 <olliej> there we go
06:28:44 <olliej> you can see the different types
06:29:09 <araujo> mm, you mean the 'a' and 'b' right?
06:29:15 <olliej> araujo:  yeah
06:29:20 <araujo> ok, i see now
06:29:25 <olliej> you can call h 1 "foo"
06:29:45 <olliej> but without the higher ranked type both the first args must be the same
06:30:26 <araujo> Right, but, what exactly are you calling higher-ranked types here?
06:30:32 <jip> Philippa: :O
06:31:00 <olliej> araujo: the function argument which takes type parameters
06:32:51 <araujo> let h x y z = (z x, z y) in h , and isn't this expression higher ranked too?
06:33:33 <olliej> no
06:33:45 <olliej> because it will infer x and y are the same type
06:34:02 <olliej> so z becomes t->t1
06:39:07 <araujo> olliej, ok, now tell me, how the hell you would call h :-)
06:42:22 <olliej> well the current h would go forever
06:42:24 <olliej> :)
06:42:40 <olliej> araujo, but in this particular case h 1 "foo" []
06:42:46 <olliej> @type []
06:42:47 <mbot> forall a. [a]
06:43:31 <olliej> oops
06:43:39 <araujo> you get it? 
06:43:40 <araujo> hah
06:43:43 <olliej> ithnk acutally (:[])
06:43:49 <olliej> sorry
06:44:01 <olliej> i've given you a slightly different examplple from what i had
06:44:03 <olliej> :)
06:44:03 <araujo> indeed, indeed :-)
06:44:15 <olliej> @type :[]
06:44:16 <mbot> parse error on input `:'
06:44:23 <olliej> @type (:[])
06:44:24 <mbot> forall a. a -> [a]
06:44:47 <olliej> araujo: i think (:[]) should work as a function
06:44:56 <basti_> > (:[]) 17
06:44:59 <mbot> [17]
06:46:26 <olliej> araujo: so h 12 "foo" (:[]) should work
06:48:03 <xerox> > flip id 12 (:[])
06:48:05 <mbot> [12]
06:48:19 <basti_> :-o
06:48:23 <basti_> @type flip id
06:48:24 <mbot> forall b c. b -> (b -> c) -> c
06:48:30 <basti_> ahh.
06:48:34 <xerox> (-:
06:48:53 <xerox> flip has the seed of its own revolution.
06:49:08 <basti_> @type flip flip
06:49:09 <mbot> forall a c b. b -> (a -> b -> c) -> a -> c
06:49:21 <basti_> o.0
06:49:23 <basti_> @type flip.flip
06:49:25 <mbot> forall a b c. (b -> a -> c) -> b -> a -> c
06:51:17 <xerox> @type (Control.Monad.Fix.fix flip :: forall a b. a -> a -> b)
06:51:19 <mbot> forall a
06:51:19 <mbot>                       b.
06:51:19 <mbot>                     a -> a -> b
06:51:23 <xerox> (-:
07:00:47 <vincenz> xerox: ciao
07:08:32 <xerox> yo.
07:08:57 <jip> xerox: sup... did you see my devlog?
07:09:04 <xerox> jip: nope!
07:09:19 <jip> xerox: http://www.mutantlemon.com/omegagb/devlog/
07:09:33 <xerox> This is an interesting idea.
07:15:18 <jip> hm.... it's not possible to get argv[0]?
07:15:36 <xerox> ?type System.Environment.getArgs
07:15:47 <xerox> ..zZzZ..
07:15:58 <Igloo> It's getProgName or something
07:16:08 <jip> Igloo: ah
07:16:24 <xerox> getProgName
07:16:33 <xerox> http://haskell.org/ghc/dist/current/docs/libraries/base/System-Environment.html
07:16:43 <jip> yeah thanks
07:32:23 <xerox> jip: I'm liking your comments on the devlog :-)
07:34:09 <xerox> jip: why don't you use a darcs repository?
07:39:32 <jip> xerox: too complicated
07:39:44 <xerox> jip: no way, it's *really* simple.
07:40:07 <jip> xerox: not sure if the server supports it
07:40:13 <xerox> It's just matter of doing 'darcs init' in your code directory, answer the question, and 'darcs add' the files.
07:40:18 <xerox> Heh, that's another cool thing.
07:40:57 <xerox> darcs just adds a _darcs directory, that's all.  Every copy of the directory is a working repo.  You don't need any kind of "support" at any other level than the webserver serving the directory as it is doing now.
07:41:45 <xerox> Check it out <http://abridgegame.org/darcs/manual/node4.html>
07:41:58 <jip> yeah, i heard about that
07:42:20 <jip> thing is, i also heard that darcs doesn't work in revisions, so will i be able to link to a specific revision of a file?
07:42:40 <xerox> Well, if it doesn't, I'd say no.
07:43:44 <xerox> OTOH it is a quite advanced tool, I wouldn't be discouraged by that.
07:44:08 <jip> yeah, but i don't need something so advanced :)
07:44:27 <xerox> I'm asking you because it would simplify things.
07:44:54 <xerox> I.e. I could do darcs get yoururl, play with it, darcs whatsnew, darcs record, darcs send
07:44:59 <xerox> And you'll get a patch in your mailbox.
07:45:24 <jip> yeah, i think i sent a patch for hs-plugins that way :)
07:45:45 <xerox> Cool (-:
07:46:34 <xerox> I don't think darcs ties you to some specific way of ordering things.
07:46:38 <jip> it was like a 2 line change but dons insisted that i send a patch through darcs =]
07:46:58 <xerox> Yes, because it's so convenient.
07:47:37 <jip> well, i'll look into darcs
07:48:18 * xerox jumps happily
07:48:19 <vincenz> @seen jethr0
07:48:20 <mbot> I haven't seen jethr0.
08:15:11 <JohnnyL> how can I make  f [2,3,4,5] [3,4,5,6] where f xs ys = [x*y | x<-xs, y<-ys]
08:15:11 <JohnnyL>    work?
08:15:38 <BCoppens> doesn't that work already?
08:15:53 <jyp> > let f xs ys = [x*y | x<-xs, y<-ys] in f [2,3,4,5] [3,4,5,6]
08:15:57 <mbot> [6,8,10,12,9,12,15,18,12,16,20,24,15,20,25,30]
08:17:14 <alar> whois mbot?
08:17:27 <basti_> lambdabot in disguise?
08:17:37 <alar> lambdabot-junior?
08:17:53 <alar> @join #haskell_ru
08:17:53 <mbot> Not enough privileges
08:17:55 <jyp> lambdabot's sidekick
08:18:08 <alar> @seen lambdabot
08:18:08 <mbot> lambdabot is in #haskell. I don't know when lambdabot last spoke.
08:20:11 <JohnnyL> BCoppens, no not in ghci.
08:20:14 <JohnnyL> thqnkw jyp.
08:20:32 <BCoppens> heh, it worked in hugs =)
08:20:41 <JohnnyL> mbot: 8*49
08:21:55 <alar> >8*49
08:22:31 <Maddas> > 8 * 49
08:22:33 <mbot> 392
08:23:51 <JohnnyL> @type uncurry
08:23:52 <mbot> forall c b a. (a -> b -> c) -> (a, b) -> c
08:25:37 <JohnnyL> > uncurry ("hello", "there")
08:25:39 <mbot> Couldn't match `a -> b -> c' against `(a1, b1)'
08:26:08 <basti_> ?
08:26:23 <basti_> > uncurry (*) (2,3)
08:26:23 <resiak> @type uncurry
08:26:24 <mbot> 6
08:26:25 <mbot> forall c b a. (a -> b -> c) -> (a, b) -> c
08:27:44 <JohnnyL> @type (*)
08:27:45 <mbot> forall a. (Num a) => a -> a -> a
08:28:34 <JohnnyL> is (*) the middle a in a->a->a?
08:28:42 <basti_> no.
08:28:55 <basti_> a -> a -> a means "give me two a and you'll get back an a"
08:29:03 <basti_> read -> as being right-associative:
08:29:14 <xerox> ?type Control.Monad.Fix.fix flip
08:29:15 <basti_> a -> a -> a   ===   a -> (a -> a)
08:29:23 <xerox> forall a b. a -> a -> b
08:29:44 <basti_> the first a is the first parameter, after the first parameter you have a function that takes another a, and then returns an a.
08:33:17 <JohnnyL> basti, i thought (a->b->c) mean't a function that takes an a, a b as an argument and returns a c.
08:33:28 <basti_> yes.
08:34:12 <basti_> so...?
08:36:51 <JohnnyL> basti: it's a witch?
08:36:53 <JohnnyL> burn her?
08:37:19 <basti_> right, JohnnyL.
08:37:25 <loonatic> hiho, small question: how can i get the largest Double in haskell?
08:37:29 * basti_ .o° ( ? )
08:37:43 <basti_> to answer your question: (*) itself has type a->a->a.
08:37:48 <basti_> * has, too, but * is infix.
08:38:00 <basti_> (oh, and the constraint of a being "Num")
08:38:35 * loonatic ??
08:38:49 <basti_> loonatic: not -your- question, i'm sorry.
08:38:52 <basti_> i don
08:39:11 <basti_> 't know how to get the highest/smallest numbers of types
08:39:23 <loonatic> k
08:41:38 <resiak> > maxBound :: Int
08:41:40 <mbot> 2147483647
08:41:47 <resiak> > maxBound :: Char
08:41:49 <mbot> '\1114111'
08:42:02 <basti_> \11411?
08:42:03 <musasabi> the problem is Double is not Bounded.
08:42:11 <basti_> > maxBound :: Double
08:42:12 <mbot>  add an instance declaration for (Bounded Double)
08:42:12 <mbot>   In the expression: maxBound :: Double
08:42:12 <mbot>   In the definition of `ugv': ugv = maxBound :: Double
08:42:23 <basti_> but why not?
08:43:02 <musasabi> basti_: doubles go all the way to infinity.
08:43:15 <basti_> ...?
08:43:15 <musasabi> of course there is the largest non-infinite Double.
08:43:28 <musasabi> > (1/0) :: Double
08:43:29 <mbot> Infinity
08:43:32 <basti_> ah
08:43:34 <basti_> i see
08:43:42 <loonatic> ah! cool!
08:43:43 <basti_> but that applies to float too doesnt it?
08:43:48 <basti_> > (1/0) :: Float
08:43:49 <musasabi> > (1/0) :: Float
08:43:50 <mbot> Infinity
08:43:51 <mbot> Infinity
08:43:58 <alar> ah, Double has Infinity!
08:44:10 <loonatic> yeah thats it, cool
08:44:11 <loonatic> thx
08:44:13 <basti_> so why isn't infinity given back?
08:44:28 <alar> is there a "Double without infinity" datatype?
08:44:42 <musasabi> Rational.
08:45:02 <musasabi> But that is exact rational numbers.
08:45:05 <Igloo> That's not the same as Double without Infinity
08:45:06 <alar> no
08:45:13 <alar> Rational is not Double
08:45:20 <JohnnyL> how do i uncurry zip two lists?  let f xs ys = uncurry ( zip xs ys )in f [1,2,3,4] [5,6,7,8]
08:45:20 <JohnnyL>  won't work.
08:45:43 <musasabi> @type zipWith
08:45:44 <mbot> forall c b a. (a -> b -> c) -> [a] -> [b] -> [c]
08:45:57 <alar> Rational is isomorphic to equality classes over (numerator,denominator) tuples
08:46:23 <davidhouse> what's the maths-related conversation topic?
08:47:08 <xerox> > (uncurry zip) ([1..10],[10..1])
08:47:09 <mbot> []
08:47:23 <davidhouse> > [10..1]
08:47:24 <mbot> []
08:47:28 <musasabi> The problem is that finite precision without infinity can make things quite evil.
08:47:29 <xerox> > (uncurry zip) ([1..10],[10,9..1])
08:47:31 <mbot> [(1,10),(2,9),(3,8),(4,7),(5,6),(6,5),(7,4),(8,3),(9,2),(10,1)]
08:47:39 <xerox> Thanks dave!
08:48:12 <ihope> Oh boy, this client is booched.
08:48:23 <xerox> What client?
08:48:27 <xerox> JohnnyL: saw?
08:48:35 <ihope> XiRCON
08:48:42 <xerox> Gawk, what a name.
08:49:08 <xerox> JohnnyL: you either want f = uncurry zip or f (xs,ys) = zip xs ys.
08:49:25 <davidhouse> @type uncurry
08:49:27 <mbot> forall c b a. (a -> b -> c) -> (a, b) -> c
08:49:32 <davidhouse> ah. nice.
08:49:42 <davidhouse> @type zip
08:49:44 <mbot> forall b a. [a] -> [b] -> [(a, b)]
08:49:52 <ihope> @type uncurry zip
08:49:53 <mbot> forall a b. ([a], [b]) -> [(a, b)]
08:50:12 <ihope> @type unzip
08:50:13 <mbot> forall b a. [(a, b)] -> ([a], [b])
08:50:20 <ihope> @type unzip curry
08:50:21 <mbot>   Couldn't match `[(a, b)]' against `t -> t1'
08:50:21 <mbot>   Expected type: [(a, b)]
08:50:25 <ihope> :-)
08:51:01 <JohnnyL> xerox, thx.
08:51:03 <JohnnyL> tired bbl.
08:51:08 <xerox> You're welcome.
08:52:38 <ihope> Okay, I don't see why it should be so hard to write this simultaneous I/O thing.
08:53:10 <xerox> Oh-uhm?
08:53:18 <davidhouse> why is it hard?
08:53:25 <ihope> Well...
08:53:26 <ihope> Hmm.
08:53:35 <xerox> forkIO?
08:53:52 <ihope> I need hscurses, don't I?
08:54:15 <xerox> Do you want to make a ncurses UI?
08:54:20 <ihope> Yeah.
08:54:23 <palomer> ihope: here's your problem: http://adrinael.net/wrong.jpg
09:02:15 <alar> how do I make links in wiki?
09:02:31 <alar> [[article]] links to article
09:02:54 <alar> but what if I want link to article in another language?
09:02:57 <xerox> CamelCase ?
09:03:04 <xerox> Oh?
09:03:22 <xerox> I didn't yet figure out the semantics of the new wiki.
09:18:30 <toast> rev (x:xs) = rev xs ++ [x]
09:18:40 <toast> anyone could tell me how this works ;p
09:18:44 <davidhouse> sure
09:18:51 <davidhouse> x:xs is a pattern patch.
09:19:04 <davidhouse> you know : is the operator for adding an item onto the front of a list, right?
09:19:12 <davidhouse> > 1 : [2, 3, 4]
09:19:15 <mbot> [1,2,3,4]
09:19:16 <toast> yes
09:19:33 <toast> but then, ++ do what ?
09:19:42 <davidhouse> right. as (:) is actually a constructor for the list datatype, you can you use it in a pattern match.
09:19:44 <alar> concatenates lists
09:20:03 <davidhouse> basically, x gets bound to the first item in the list, and xs is a list of the rest.
09:20:03 <alar> > [1] ++ [2,3,4]
09:20:05 <mbot> [1,2,3,4]
09:20:18 <toast> ok, but as i see it, this code would reverse the list to infinity
09:20:27 <davidhouse> well, almost
09:20:38 <davidhouse> i suspect there's another line something like rev [] = []
09:20:43 <davidhouse> that you haven't pasted.
09:21:05 <toast> exactly, but the list is never empty since we add x add the end of it at eat recursion
09:21:14 <toast> eatch*
09:21:31 <davidhouse> that line means (rev xs) ++ [x]
09:21:44 <davidhouse> i.e., recurse, passing in xs (which could be empty), THEN append x.
09:22:15 <toast> ok, so it doesnt really concatenate, it put [x] in the stack ?
09:22:19 <toast> :/
09:22:24 <davidhouse> it appends x.
09:22:29 <davidhouse> [x] is the list containing just x.
09:22:49 <toast> what do you mean, it appends x ?
09:22:55 <davidhouse> adds x to the end of the list
09:23:10 <toast> mama mia
09:23:13 <alar> > ['x','s'] ++ [x]
09:23:15 <mbot>  Not in scope: `x'
09:23:19 <alar> > ['x','s'] ++ ['x']
09:23:21 <mbot> "xsx"
09:23:32 <tromp> > "ns" ++ "x"
09:23:32 <davidhouse> here's an example of how it works: rev [1,2,3,4] = rev [2,3,4] ++ [1] = (rev [3,4] ++ [2]) ++ [1] = ((rev [4] ++ [3]) ++ [2]) ++ [1] = (((rev [] ++ [4]) ++ [3]) ++ [2]) ++ [1] = [] ++ [4] ++ [3] ++ [2] ++ [1] = [4,3,2,1]
09:23:34 <mbot> "nsx"
09:24:06 <toast> ahh nice david, thx :)
09:24:31 <toast> so i could see it as a stack
09:24:41 <davidhouse> yeah. lists can be used as stacks.
09:25:05 <xerox> Sure.  It's also nice to think of the exact substitution of definitions.
09:25:05 <davidhouse> it pops the first item, recurses on whats left, then appends that item
09:25:09 <musasabi> > let rev xs = loop xs []; loop [] a = a; loop (x:xs) a = loop xs (x:a) in rev [1..4]
09:25:12 <mbot> [4,3,2,1]
09:25:34 <davidhouse> *what's
09:26:23 <davidhouse> musasabi: nice.
09:29:08 <davidhouse> > let rev = reverse in rev [1..4]
09:29:11 <mbot> [4,3,2,1]
09:29:14 <davidhouse> that one works too :)
09:29:24 <bolrod> WOW!
09:30:44 <bolrod> >let rev = foldl (flip(:)) [] in rev [1..6]
09:30:48 <bolrod> > let rev = foldl (flip(:)) [] in rev [1..6]
09:30:50 <mbot> [6,5,4,3,2,1]
09:30:52 <bolrod> >_>
09:30:54 <bolrod> that works too
09:31:04 <davidhouse> pfft. points-free sucks.
09:31:13 <bolrod> ?
09:31:14 <musasabi> > let rev = foldr (:) [] in rev [1..6]
09:31:15 <mbot> [1,2,3,4,5,6]
09:31:17 <DeliQ> bolrod, what is the most efficient version of reverse ?
09:31:23 <DeliQ> the foldl flip ?
09:31:24 <bolrod> hell I don't know
09:31:25 <bolrod> :P
09:31:26 <bolrod> try
09:31:32 <DeliQ> hehe
09:31:33 <davidhouse> DeliQ: whatever's used in the prelude
09:31:36 <bolrod> that probably depends on the compiler , optimalisations
09:31:41 <bolrod> use of the function
09:31:43 <DeliQ> i get it...
09:31:43 <bolrod> etc. etc. etc.
09:31:48 <bolrod> davidhouse: you sure?
09:31:52 <davidhouse> probably.
09:32:09 <bolrod> you could probably create a better reverse for certain things
09:32:57 <davidhouse> probably.
09:33:13 <bolrod> -- reverse xs returns the elements of xs in reverse order.  xs must be finite.
09:33:13 <bolrod> reverse          :: [a] -> [a]
09:33:13 <bolrod> reverse          =  foldl (flip (:)) []
09:33:15 <bolrod> :]
09:33:34 <ihope> @type foldl (flip (:)) []
09:33:36 <mbot> forall a. [a] -> [a]
09:33:46 <musasabi> report defines the foldl flip while GHC uses the loop version.
09:34:30 <xerox> > let navigate xs = ([],xs); left (ys,[]) = (ys,[]); left (ys,(x:xs)) = (x:ys,xs); right ((y:ys),xs) = (ys,y:xs); ctx (xs,_) = xs in ctx . head . dropWhile (not . null . snd) . iterate left . navigate $ "!ekil reppiZ"
09:34:32 <mbot> "Zipper like!"
09:35:29 <bolrod> yesh
09:35:46 <davidhouse> iohc!
09:35:54 <bolrod> ohic!
09:36:04 <ihope> Choi! Ciho!
09:36:07 <xerox> davidhouse: argh! It's meant to be readable.
09:36:21 <bolrod> the flip fold is quite readable
09:36:22 <davidhouse> xerox, it's also meant to be needlessly complicated.
09:36:29 <bolrod> and probably fast as well
09:36:34 <xerox> davidhouse: for the specific case, yes.
09:36:53 <xerox> I wanted to show the zipper!
09:36:54 <davidhouse> what does ctx stand for?
09:36:58 <xerox> Context.
09:37:24 <davidhouse> i would have stuck with fst, but yeah.
09:37:50 <bolrod> this is what mbot thinks of difficult functions
09:37:51 <bolrod> > map (\c-> toEnum c ::Char).map fromIntegral.map floor.map (\x->0.029*x^5-0.3346*x^4+0.9392*x^3+0.9369*x^2+0.6192*x+89.0002)  $ [0,2,5.8,4]
09:37:54 <mbot> "Yawn"
09:37:58 <bolrod> :)
09:38:00 <davidhouse> heh.
09:38:16 <bolrod> blah.. its getting old
09:38:25 <bolrod> I wrote it some weeks ago when I was totally bored
09:38:39 <davidhouse> xerox, that is nice.
09:38:49 <davidhouse> it actually works quite elegantly.
09:38:56 <davidhouse> you don't need right, by the way.
09:39:03 <xerox> map a . map b . ... . map z = map (a . b . ... . z)
09:39:09 <xerox> davidhouse: yup, I wanted to show it too, tho.
09:39:20 <bolrod> I think that was already mentioned to me
09:39:30 <bolrod> but this looks way cooler
09:39:33 <bolrod> and way more confusing
09:39:42 <bolrod> maybe not.. though
09:39:56 <xerox> If one can distinguish a patterns it means that it's not confusing.
09:40:02 <xerox> pattern, even
09:40:14 <bolrod> well.. yes.. true
09:40:27 <bolrod> but you wouldn't be able to say what it'll output without a computer
09:40:31 <bolrod> or you're crazy
09:40:36 <bolrod> ;)
09:40:37 <davidhouse> @hoogle (a -> Bool) -> [a] -> a
09:40:39 <mbot> http://www.standardml.org/Basis/bool.html
09:40:45 <xerox> any, all
09:40:47 <davidhouse> pah. i want lambdabot.
09:40:54 <bolrod> pah!
09:41:02 <davidhouse> xerox, i was basically looking for fromJust . find
09:41:05 <toast> :r
09:41:06 <mauke> @type filter
09:41:07 <mbot> forall a. (a -> Bool) -> [a] -> [a]
09:41:09 <xerox> lookup ?
09:41:14 <bolrod> almost :P
09:41:15 <davidhouse> @type lookup
09:41:15 <toast> > :r
09:41:16 <mbot> forall b a. (Eq a) => a -> [(a, b)] -> Maybe b
09:41:16 <mbot>  parse error on input `:'
09:41:25 <toast> okay
09:41:31 <davidhouse> nah, not quite.
09:41:50 <bolrod> @pl ( a -> Bool) -> [a] -> a
09:41:51 <mbot> (line 1, column 5):
09:41:51 <mbot> unexpected ">"
09:41:51 <mbot> expecting variable, "(", operator or ")"
09:42:02 <bolrod> what was that other thing again
09:42:03 <xerox> @type \k -> (maybe k id .) . lookup
09:42:03 <bolrod> ;P
09:42:04 <mbot> forall a b.
09:42:04 <mbot>            (Eq a) =>
09:42:04 <mbot>            b -> a -> [(a, b)] -> b
09:42:09 <toast> compteurInt :: Int -> [Int] -> Int
09:42:09 <toast> compteurInt a [] = 0
09:42:09 <toast> compteurInt a (x:xs) =
09:42:09 <toast> 	if (a == x)
09:42:09 <toast> 		then n = n + 1
09:42:10 <toast> 	else compteurInt a xs
09:42:12 <toast> ops sorry
09:42:14 <bolrod> wowowow!
09:42:24 <xerox> Did you see that?
09:42:24 <bolrod> compteur!?
09:42:32 <bolrod> what the hell  is that.. some kind of french document?
09:42:32 <toast> counter
09:42:33 <bolrod> :p
09:42:39 <toast> yer
09:42:55 <toast> anyways, there's a mistake innit
09:43:01 <xerox> toast: that is \a -> length . filter (== a).
09:43:17 <xerox> I.e. length . filter . (==)
09:43:31 <toast> lol thx
09:43:44 <xerox> My duty.
09:43:48 <bolrod> haha
09:44:14 <davidhouse> > let setup xs = ([], xs); move p@(_, []) = p; move (ys, x:xs) = (x:ys, xs) in fst . fromJust . find (not . null . snd) . iterate move . setup $ "!ekil reppiZ"
09:44:16 <mbot> ""
09:44:25 <bolrod> HA!
09:44:28 <davidhouse> huh.
09:44:52 <xerox> davidhouse: it's way cooler if you use Type Synonyms, unfortunately we can't in lambdabot.
09:44:55 <davidhouse> oh, wait.
09:45:04 <davidhouse> > let setup xs = ([], xs); move p@(_, []) = p; move (ys, x:xs) = (x:ys, xs) in fst . fromJust . find (null . snd) . iterate move . setup $ "!ekil reppiZ"
09:45:07 <mbot> "Zipper like!"
09:45:18 <davidhouse> that's how i would have labelled it.
09:45:31 <xerox> I didn't like the idea of re-computing the list.
09:45:38 <xerox> Or counting, well, crawling.
09:45:47 <DeliQ> @seen rasterfar
09:45:47 <mbot> I haven't seen rasterfar.
09:46:04 <davidhouse> xerox, that only takes one pass
09:46:17 <xerox> But it raises an interesting question, how to plug the STOP in the zipper movements.
09:47:14 <xerox> davidhouse: hmm, I see what you mean.  Right.
09:48:12 <davidhouse> ours both treat infinite lists the same (i.e., _|_) as both find and dropWhile fail to terminate
09:48:21 <davidhouse> actually, i think find might be defined in terms of dropWhile
09:48:39 <xerox> dropWhile was straightforward, anyway.
09:48:43 <bolrod> who would want to reverse an infinite list ?
09:48:55 * xerox raises hand !!
09:48:58 <davidhouse> there is that (what would be the first element? :))
09:48:58 <bolrod> ;/
09:49:04 <bolrod> what would you want to compute with it?
09:49:10 <xerox> Infinite things.
09:49:17 <bolrod> like?
09:49:28 <bolrod> > head $ reverse [1..]
09:49:34 <xerox> I could tell you, but then I'd have to kill you.
09:49:34 <mbot> Terminated
09:49:42 <bolrod> > tail $ reverse [1..]
09:49:48 <mbot> Terminated
09:49:51 <bolrod> see... the one in the prelude doesn't do that either
09:49:57 <bolrod> hrm
09:49:58 <bolrod> wait
09:50:03 <bolrod> > last $ reverse [1..]
09:50:04 <davidhouse> > let myFind p l = case dropWhile p l of [] -> Nothing; (x:xs) -> Just x in (myFind (>5) [1..10], myFind (>5) [1..5])#
09:50:09 <mbot> Terminated
09:50:09 <mbot>  parse error on input `}'
09:50:11 <davidhouse> > let myFind p l = case dropWhile p l of [] -> Nothing; (x:xs) -> Just x in (myFind (>5) [1..10], myFind (>5) [1..5])
09:50:14 <mbot> (Just 1,Just 1)
09:50:34 <davidhouse> > let myFind p l = case dropWhile (not . p) l of [] -> Nothing; (x:xs) -> Just x in (myFind (>5) [1..10], myFind (>5) [1..5])
09:50:36 <mbot> (Just 6,Nothing)
09:50:39 <xerox> heh.
09:50:44 <davidhouse> :)
09:50:48 <bolrod> > let setup xs = ([], xs); move p@(_, []) = p; move (ys, x:xs) = (x:ys, xs) in fst . fromJust . find (null . snd) . iterate move . setup $ "test"
09:50:50 <mbot> "tset"
09:51:04 <xerox> davidhouse: do you know the one for Binary Trees ?
09:51:05 <bolrod> > let setup xs = ([], xs); move p@(_, []) = p; move (ys, x:xs) = (x:ys, xs) in last $ fst . fromJust . find (null . snd) . iterate move . setup $ "test"
09:51:07 <mbot> 't'
09:51:10 <bolrod> hmm
09:51:20 <bolrod> > let setup xs = ([], xs); move p@(_, []) = p; move (ys, x:xs) = (x:ys, xs) in last $ fst . fromJust . find (null . snd) . iterate move . setup $ [1..]
09:51:25 <mbot> Terminated
09:51:29 <bolrod> wellllllll
09:51:34 <davidhouse> > reverse $ filter (isAlpha) $ "rise to vote, sir"
09:51:36 <mbot> "risetovotesir"
09:51:46 <davidhouse> xerox, haven't heard it.
09:51:59 <bolrod> but why would you want to reverse an infinite list ?
09:52:06 <xerox> Do you want me to show you?
09:52:10 <davidhouse> let me have a crack.
09:52:25 <alar> what is the reverse of infinite list?
09:52:31 <alar> undefined?
09:52:38 <davidhouse> alar, yeah
09:52:41 <davidhouse> xerox, first thoughts are that it's easy with recursion
09:52:42 <bolrod> you could zip the reverse of an inifinite list togerther with the infinite list......
09:52:50 <bolrod> but then again
09:52:53 <bolrod> where to start ;p
09:53:22 <davidhouse> revTree (Node a) = Node a; revTree (Branch a b) = Branch (revTree b) (revTree a)
09:53:23 <bolrod> maybe you could stick them togeter.. so there won't even be a start to the infinite list ;)
09:53:30 <mauke> reverse (repeat 1 ++ [2,3,4]) == [4,3,2] ++ repeat 1, of course
09:53:33 <davidhouse> lets see if we can get faster.
09:53:41 <alar> > let x = [1..] in zip x (reverse x) 
09:53:47 <mbot> Terminated
09:54:13 <xerox> First, we need a Tree datatype.
09:54:28 <xerox> data Tree a = Branch (Tree a) (Tree a) | Leaf a
09:54:29 <davidhouse> yeah, i was going on Tree a = Node a | Branch (Tree a) (Tree a)
09:54:30 <alar> mauke: are you sure? :)
09:54:42 <mauke> well, at least that's how it should work :-)
09:54:46 <xerox> Now, we need a way to say whre a Tree is in a Tree.
09:55:15 <xerox> For example, if we have t = Branch (Branch (Leaf 1) (Leaf 2)) (Branch (Leaf 3) (Leaf 4)))
09:55:27 <davidhouse> i'd say that would become:
09:55:36 <alar> mauke: [2,3,4] "at the end" of infinite list matter only when you can define Equality on infinite lists :)
09:55:51 <xerox> Leaf 2 is marked by @: Branch (Branch (Leaf 1) @) (Branch (Leaf 3) (Leaf 4)))
09:55:53 <davidhouse> Branch (Branch (Leaf 4) (Leaf 3)) (Branch (Leaf 2) (Leaf 1))
09:56:12 <xerox> We can represent this datastructure "with the hole" like this:
09:56:13 <bolrod> alar: you write the function to compare infinite lists ;)
09:56:24 <alar> =)
09:56:33 <xerox> data Ctx a = Top | L (Ctx a) (Tree a) | R (Tree a) (Ctx a)
09:56:46 <davidhouse> xerox, i think this is easier than you're making out
09:56:58 <musasabi> > [1..] == [4..]
09:57:00 <xerox> Using this datatype we can rewrite our tree-with-mark notation to: R (Leaf 1) (L Top (Fork (Leaf 3) (Leaf 4)))
09:57:02 <mbot> False
09:57:09 <musasabi> bolrod: like that?
09:57:12 <bolrod> no
09:57:17 <bolrod> you can only say that the're not the same
09:57:22 <bolrod> but can you say they are the same?
09:57:23 <bolrod> ;p
09:57:24 <xerox> So a Tree Location is a Tree along with a Context.  type Loc a = (Tree a, Ctx a)
09:57:31 <bolrod> > [1..] == [1..]
09:57:36 <bolrod> Terminated!
09:57:36 <mbot> Terminated
09:57:40 <xerox> left, right :: Loc a -> Loc a
09:57:49 <davidhouse> xerox, surely all we need to do is visit each node, then swap its two branches.
09:57:55 <xerox> left (Branch l r, c) = (l, L c r)
09:58:10 <xerox> right (Branch l r, c) = (r, R l c)
09:58:11 <davidhouse> (where node /= leaf, i mean node as in any position on the tree)
09:58:16 <bolrod> what exactly is the reverse of a tree anyway
09:58:31 <xerox> up (t, L c r) = (Branch (t r, c)
09:58:42 <xerox> up (t, R l c) = (Branch (l t, c)
09:58:49 <xerox> top t = (t, Top)
09:59:01 <xerox> And you can also have this useful function to operate on Locations:
09:59:11 <xerox> modify :: Loc a -> (Tree a -> Tree a) -> Loc a
09:59:12 <bolrod> is there anyway in haskell to match several kinds of data constructors
09:59:19 <bolrod> lik you can match for    Nothing
09:59:20 <xerox> modify (t, c) f = (f t, c)
09:59:22 <bolrod> and     Just
09:59:26 <davidhouse> bolrod, case.
09:59:28 <bolrod> say you want to match for both
09:59:34 <xerox> Now you can navigate the tree as you want, I think it's cool.
09:59:37 <musasabi> bolrod: of course one can never know if two infinite structures are the same in Haskell (using structural equality)
09:59:39 <bolrod> davidhouse: in one patern
10:00:02 <davidhouse> bolrod: no, in general. easiest way is to use a guard.
10:00:06 <bolrod> musasabi: ;)
10:00:11 <xerox> What do you think?
10:00:17 <davidhouse> xerox, let me read it again
10:00:39 <bolrod> but seriously .. what do you define as the reverse of a tree?
10:00:46 <davidhouse> bolrod, what i said.
10:00:46 <xerox> I showed you!
10:00:48 <bolrod> just flippping every node ?
10:00:53 <davidhouse> yeah./
10:00:57 <bolrod> but with one node extra..
10:01:00 <bolrod> you flip around the whole tree
10:01:01 <bolrod> again
10:01:08 <xerox> Let me put the code together in a file.
10:01:11 <davidhouse> you don't need one node extra, no.
10:01:14 <xerox> So that you can play with it if you want.
10:01:19 <bolrod> nah..
10:01:24 <toast> counter :: (Eq a, Num b) => a -> [a] -> b
10:01:32 <bolrod> ?
10:01:44 <toast> i don't quite get the definition
10:01:52 <bolrod> me neither
10:01:58 <bolrod> I haven't seen the defenition though :)
10:02:10 <xerox> You're comparing the wrong thing I think.
10:03:29 <toast> i get a and a list [a]
10:03:33 <toast> and return a number
10:04:13 <DeliQ> does anybody know some predicate logic, and wants to help me for a sec ?
10:04:35 <davidhouse> DeliQ:
10:04:48 <davidhouse> > return "ask" :: Maybe String
10:04:50 <mbot> Just "ask"
10:04:54 <bolrod> ^^
10:05:27 <xerox> bolrod: ok, I'm uploading it.
10:05:36 <bolrod> Predicate logic... blah
10:05:37 <bolrod> :P
10:05:39 <bolrod> its stupid
10:06:00 <bolrod> ahyeah. you had a mac right?... do you know why osx doesn't come with wget ?
10:06:01 <DeliQ> davidhouse, i writing a function to substitute al free appearances of a var
10:06:14 <DeliQ> davidhouse, but i don't know how to do it exactly
10:06:32 <bolrod> first ask yourself if you know how to do it on paper
10:06:32 <davidhouse> i'm not really a predicate logic expert.
10:06:50 <bolrod> can you write out the exact steps you do when you substitute it yourself
10:06:55 <DeliQ> i know how to do it on paper
10:06:58 <bolrod> thats probably half the work
10:07:09 <bolrod> then put it into the machine in a clever way :)
10:07:16 <DeliQ> that's the tricky part :P
10:07:19 <DeliQ> hehe
10:07:21 <bolrod> =)
10:07:22 <xerox> http://haskell.galois.com/~paolo/tmp/ZipTree.hs
10:07:31 <bolrod> depends... 
10:07:55 <DeliQ> i thought writing a function first which gets all the bound vars out of a predicate
10:08:11 <DeliQ> and pass that one with the substition function
10:08:27 <bolrod> well.. first off.. how do you represent an expression?
10:08:28 <lisppaste2> davidhouse pasted "revTree" at http://paste.lisp.org/display/19060
10:08:35 <davidhouse> xerox, that's mine
10:08:36 <DeliQ> already coded that...
10:08:41 <DeliQ> wanna see it ?
10:08:55 <bolrod> well . sure
10:08:58 <bolrod> brb though
10:09:03 <davidhouse> but you're not talking about reversing a tree any more, i see
10:09:15 <DeliQ> bolrod, http://pastebin.com/663307
10:10:08 <xerox> Let's implement tree reversal via the zipper!
10:11:54 <bolrod> whats the if and iff
10:12:46 <DeliQ> if = -->
10:12:51 <DeliQ> iff = <-->
10:12:57 <DeliQ> if = implication
10:13:02 <DeliQ> iff = double implication
10:13:09 <DeliQ> both ways in fact
10:13:13 <xerox> I.e. "if and only if".
10:13:16 <bolrod> rather cryptic name ":)
10:13:26 <mauke> iff == equiv
10:13:26 <bolrod> I'd say..
10:13:36 <DeliQ> hehe
10:13:43 <DeliQ> i chose this one... :P
10:13:45 <bolrod> I know what -> means >_>
10:13:48 <bolrod> :P
10:14:00 <DeliQ> i'm sorry :P
10:14:01 <bolrod> you forgot the NAND  and XOR! >_>
10:14:01 <bolrod> ;)
10:14:08 <xerox> >_>
10:15:00 <davidhouse> xnor is far cooler.
10:15:11 <bolrod> :P
10:15:18 <bolrod> XNAND? 
10:15:20 <xerox> DBFZ for the masses.
10:15:23 <davidhouse> trivia of the day: all possible 16 logic gates can be made up of a combination of nand.
10:15:26 <DeliQ> and so on....
10:15:49 <bolrod> (XNAND  -> False )
10:15:50 <bolrod> :)
10:15:59 <bolrod> or.. always true
10:16:01 <bolrod> hrm..
10:16:04 * xerox got an evil idea.
10:16:06 <alar> what is >_> ?
10:16:16 <bolrod> its a smiley
10:16:18 <bolrod> :D
10:16:23 <bolrod> xerox: that is?
10:16:23 <davidhouse> bolrod, iff is common in mathematics.
10:16:34 <bolrod> I See
10:16:40 <bolrod> I don't recalling it seeing it as  iff
10:16:41 * xerox coughs and keeps writing
10:16:58 <bolrod> har har
10:17:02 <alar> I recall seeing iff as <=>
10:17:08 <bolrod> omg
10:17:12 <bolrod> thats something completely different
10:17:19 <DeliQ> it's just a name for a symbol
10:17:27 <DeliQ> doesn't matter that much :P
10:17:42 <alar> yes, just the matter of habit
10:18:55 <bolrod> well.. this is the perfect example where you can use matching with one pattern on more kinds of data constructors
10:18:58 <bolrod> ;/
10:19:00 <DeliQ> i'm not going to use :<=>: as a constructor or somthing
10:19:30 <bolrod> oh I did :)
10:19:42 <DeliQ> bit of a hassle.. typing :<=>: over and over again
10:19:53 <bolrod> bwah
10:19:55 <davidhouse> you could use Iff infix.
10:19:59 <bolrod> anyway.. its quite simple 
10:20:00 * alar doesn't recall "data constructors" in math
10:20:04 <vincenz> Lemmih: ping
10:20:13 <davidhouse> p1 `Iff` p2
10:20:18 <alar> @seen Lemmih
10:20:18 <mbot> Lemmih is in #haskell. I don't know when Lemmih last spoke.
10:20:35 <bolrod> you could write a function that keeps track of the bounded vars
10:20:46 <bolrod> bound?
10:20:47 <bolrod> watever
10:20:47 <davidhouse> xerox, seems that recursion is by far the easiest way to do revTree.
10:21:19 <DeliQ> bolrod, how??
10:21:31 <bolrod> matching against it?
10:21:39 <DeliQ> hmm...
10:21:50 <xerox> davidhouse: oh wops, I forgot we were doing that (-:
10:22:04 <bolrod> say..    All var rest   =   var ++ (rest of bound vars)   
10:22:13 <bolrod> ^.0
10:22:18 <davidhouse> xerox, it might be nice to make a Loc monad, then iterate a do statement.
10:22:59 <toast> compteur :: (Eq a, Num b) => a -> [a] -> b; counter a xs = length(filter (Eq a) xs)
10:22:59 <DeliQ> yes that should do it
10:23:07 <DeliQ> thanks bolrod
10:23:31 <bolrod> lets see if I could write this :)
10:23:36 <davidhouse> toast, i don't think you understand type classes
10:23:41 <bolrod> you want to replace one or more vars at a time?
10:23:54 <DeliQ> yep
10:24:04 <bolrod> is it a. or b.     
10:24:05 <toast> i guess ill read the type class chapter ;p
10:24:06 <bolrod> - 'yep'
10:24:09 <bolrod> ^.o
10:24:17 <DeliQ> and say you want to replace x by y and y by x
10:24:24 <DeliQ> it must happen at the same time
10:24:32 <DeliQ> otherwise you get conflicts...
10:24:43 <bolrod> erh
10:24:43 <xerox> davidhouse: the question is if either make Loc a monad, or travelling monadic.
10:24:48 <bolrod> ic
10:24:57 <bolrod> isn't it easier to replace one var at a time though ?
10:25:02 <xerox> I propend for the second choice.
10:25:04 * xerox tries
10:25:06 <DeliQ> Hmm_|, don't know.. :P
10:25:27 <davidhouse> xerox, interesting project.
10:25:32 <vincenz> davidhouse: you didn't know that all possible logic gates can be made with nand?
10:25:40 <davidhouse> i'd say a travelling one actually.
10:25:48 <davidhouse> >>= would be composition of your left, right etc. ones
10:26:00 <davidhouse> return would be bundle it with Top.
10:26:05 <vincenz> what are you two talking about
10:26:36 * vincenz is missing context
10:26:42 <davidhouse> vincenz: a monad to traverse trees
10:26:49 <vincenz> why would you need a monad
10:26:52 <davidhouse> http://haskell.galois.com/~paolo/tmp/ZipTree.hs
10:27:03 <DeliQ> bolrod, al the free occurences must be substituted ..
10:27:12 <vincenz> yeah, zipper structure
10:27:23 <vincenz> so you want to say
10:27:24 <vincenz> do
10:27:25 <vincenz>   left
10:27:26 <vincenz>   right
10:27:29 <vincenz> ?
10:27:31 <davidhouse> exactly.
10:27:34 <davidhouse> how cool is that? :)
10:27:35 <vincenz> easiest is a statemonad
10:27:40 <davidhouse> nah.
10:27:44 <vincenz> why not?
10:27:45 <xerox> That's what I'm doing too.
10:27:49 <davidhouse> well, i suppose it would be.
10:27:51 <vincenz> state monad is the most obvius
10:28:01 <vincenz> you're changing where you are... you'er changing state
10:28:10 <vincenz> sure you can custom build a state monad for that structure
10:28:12 <vincenz> but why would you
10:28:15 <vincenz> just make new monadic actions
10:28:17 <vincenz> based on get and put
10:28:20 <vincenz> or modify
10:28:35 <bolrod> DeliQ: yes. all free
10:28:42 <bolrod> but not more then one var at a time I guess :/
10:28:50 <bolrod> so not replacing  AND var t
10:28:50 <vincenz> xerox: paolo what is this for
10:28:52 <bolrod>  AND  var q
10:28:57 <DeliQ> that a choice of how you implement it
10:29:15 <DeliQ> you could pass a list of al substitutions
10:29:21 <DeliQ> [(a, b)]
10:29:26 <vincenz> davidhouse: btw... every logic gate can be made with nand
10:29:38 <davidhouse> vincenz: yeah, i just said trhat
10:29:47 <vincenz> yeah I misread that
10:29:57 <vincenz> in fact... 
10:29:58 <DeliQ> but for convenience jsut say one var at a time
10:30:08 <vincenz> I think that fpga's are nand-gate basd
10:30:09 <vincenz> or nor
10:30:25 <bolrod> DeliQ: yep
10:30:25 <vincenz> I think that's manufacturer dependent
10:31:36 <shapr> xerox: You called?
10:31:43 <vincenz> shapr: ah mind if I pm?
10:31:49 <xerox> shapr!!
10:31:57 <xerox> shapr: I'll be back in a minute.
10:32:22 <AL> Can't calculate (head vector) * vector, but can 5*[1,2,3], etc... ;(
10:32:22 <AL> Can anydody help?
10:32:22 <AL> I have
10:32:22 <AL> instance Num a => Num [a] where
10:32:22 <AL>     (+) = zipWith (+) 
10:32:23 <AL>     (*) = zipWith (*) 
10:32:25 <AL>     abs = map abs 
10:32:26 <shapr> xerox: ok
10:32:29 <AL>     negate = map negate  
10:32:31 <AL>     signum = map signum 
10:32:33 <AL>     fromInteger = repeat . fromInteger 
10:32:33 <shapr> AL: dude, use a paste tool.
10:32:39 <vincenz> AL: [1,2,3] is not a vector
10:32:40 <vincenz> AL: it's a list
10:32:46 <AL> ÐÑÑ
10:32:49 <AL> Yes
10:32:49 <vincenz> > map (*5) [1,2,3]
10:32:51 <shapr> AL: Don't paste anything over three lines in the channel directlry.
10:32:52 <mbot> [5,10,15]
10:32:56 <vincenz> not
10:33:16 <vincenz> oh...
10:33:21 <vincenz> I thought those were error messages
10:33:25 <vincenz> yeah, do like shapr said, use paste site
10:33:26 <AL> But after "instance Num a => Num [a]" i can do this - 5*[1,2,3]
10:33:27 <vincenz> much more sightly
10:33:46 <vincenz> AL: no you can'
10:33:52 <vincenz> (+) is monomorphic
10:33:56 <davidhouse> xerox, could you explain your Ctx type?
10:34:02 <vincenz> oh wait... fromInteger
10:34:09 <vincenz> AL: so what is the question?
10:34:27 <vincenz> davidhouse: that's actually an old paradigm
10:34:37 <vincenz> let me find the paper
10:34:46 <AL> When i write 5*[1,2,3] i get [5,10,15] but i can't define function test list = (head list) * list
10:34:55 <vincenz> AL: obviously not
10:35:03 <vincenz> 5*[1,2,3] is internally madae into
10:35:05 <vincenz> (fromInteger 5)
10:35:08 <vincenz> which gives a list
10:35:08 <xerox> davidhouse: it comes over trying to define the tree with the mark I showed you
10:35:18 <vincenz> AL: (*) expects two of the same types!
10:35:27 <vincenz> AL: except that whenever you put constants...it uses fromInteger
10:35:34 <vincenz> to make a Dobule, or Int, or whatnot, depending on context
10:35:50 <AL> After this -
10:35:55 <AL> instance Fractional a => Fractional [a] where
10:35:55 <AL>     (/) = zipWith (/)
10:35:55 <AL>     fromRational = repeat . fromRational
10:35:59 <vincenz> AL: PLEASE
10:36:03 <vincenz> put it all on one paste page
10:36:05 <AL> I can calculate 5.0*[1,2,3]
10:36:22 <vincenz> AL: yes
10:36:25 <vincenz> AL: again the same
10:36:31 <AL> about pasting - how can i do this in xchat?
10:36:35 <vincenz> fromRational turns 5.0 into [5.0, 5.0, ...]
10:36:38 <vincenz> AL: it's a webpage
10:36:44 <vincenz> http://rafb.net/paste
10:36:48 <davidhouse> xerox, what is Fork?
10:36:48 <vincenz> past ethere
10:36:51 <vincenz> and then give us the link
10:36:55 <xerox> davidhouse: we could go to #haskell-overflow to get into an in-depth explanation
10:37:03 <xerox> davidhouse: Fork = Branch, wooops.
10:37:04 <vincenz> davidhouse: where do you see Fork
10:37:22 <vincenz> you guys gobbying?
10:38:07 <AL> http://rafb.net/paste/results/PKfAyq22.html
10:38:18 <vincenz> AL: yes
10:38:23 <vincenz> AL: and look at fromInteger
10:38:25 <vincenz> and fromRational
10:38:30 <vincenz> whenever there's a constant
10:38:34 <vincenz> that is required to be a list
10:38:36 <vincenz> it repeats that constant
10:38:42 <bolrod> DeliQ: I don't know if it works
10:38:52 <vincenz> AL: if you're not using constants
10:38:52 <vincenz> then
10:38:54 <vincenz> for instance
10:39:05 <vincenz> domystuff l = (fromInteger $ head l) * l
10:39:16 <DeliQ> bolrod, can you show something ?
10:39:18 <bolrod> http://rafb.net/paste/results/oI6wTQ39.html
10:39:22 <DeliQ> let me see
10:39:29 <bolrod> parse error
10:39:55 <bolrod> forgot 'of'
10:40:28 <bolrod> ohh
10:40:31 <bolrod> big error
10:40:51 <AL> fromInteger takes Integer, but there can be Rational or Fractional
10:41:21 <vincenz> @type fromRational
10:41:23 <mbot> forall a. (Fractional a) => Rational -> a
10:42:05 <bolrod> ok
10:42:09 <bolrod> it worked
10:42:26 <DeliQ> bolrod, just give a some time to get your code :P
10:43:05 <bolrod> DeliQ: it doesn't work
10:43:17 <ihope> Server lag: 10 seconds
10:43:23 <ihope> That's pretty bad.
10:43:34 <ihope> Oh, it disappeared.
10:43:44 <DeliQ> why not ?
10:44:16 <bolrod> it replaces too much :D
10:44:21 <DeliQ> whoops
10:44:29 <AL> "map fromRational vector" don't work...
10:44:53 <DeliQ> it's not that easy you see :P
10:45:37 <DeliQ> i see you you check for boundness in the Rel contructor
10:45:47 <DeliQ> but that doesn't completely work ?
10:46:57 <vincenz> AL: honestly...
10:47:10 <bolrod> *Pred> replace predi ("z","q")
10:47:10 <bolrod> All "x" (Exi "y" (Rel ("M",["y","x","q"])))
10:47:10 <bolrod> *Pred> replace predi ("x","q")
10:47:11 <bolrod> All "x" (Exi "y" (Rel ("M",["y","x","z"])))
10:47:14 <vincenz> AL: you have this rather complex typeclass instances, and then you ask these questions...smells like homework
10:47:30 <bolrod> DeliQ: why doesn't that work ?
10:47:36 <bolrod> it works fantastico
10:47:57 <DeliQ> aha
10:47:59 <DeliQ> i see
10:48:06 <DeliQ> hahaha
10:48:34 <DeliQ> i thought you just said that it didn't work excuse me :P
10:49:37 <AL> vincenz: I'm novice in haskell...
10:49:41 <bolrod> *Pred> replace predi2 ("y","qq")
10:49:42 <bolrod> And [All "x" (Exi "y" (Rel ("M",["y","x","z"]))),Rel ("Q",["z","g","x"])]
10:49:42 <bolrod> *Pred> replace predi2 ("x","qq")
10:49:42 <bolrod> And [All "x" (Exi "y" (Rel ("M",["y","x","z"]))),Rel ("Q",["z","g","qq"])]
10:49:47 <bolrod> it didn't at first
10:49:58 <bolrod> I think this is the correct way to replace right?
10:50:59 <DeliQ> yep
10:51:07 <DeliQ> that's correct since the second x isn't bound
10:51:14 <DeliQ> so it work like a charm
10:57:45 <cmarcelo> DeliQ: http://pastebin.com/663419, another shot =) looks like it works too
11:01:49 <DeliQ> oke, let me see
11:02:27 <DeliQ> don't get bound vars get substituted ?
11:03:49 <cmarcelo> DeliQ: example?
11:04:06 <DeliQ> let me qoute bolrod
11:04:21 <DeliQ> *Pred> replace predi ("x","q")
11:04:24 <DeliQ> All "x" (Exi "y" (Rel ("M",["y","x","z"])))
11:04:37 <DeliQ> you see the x don't gets substituted
11:04:41 <DeliQ> get*
11:08:17 <cmarcelo> ops. i think i understood wrong =P   i thought you were trying to replace the free vars.. in predi, "x" is bounded by All "x", right?
11:08:34 <DeliQ> yep
11:08:35 <DeliQ> idd
11:12:20 <AL> vincenz: so can there be more beautiful solution that (fromInteger $ head vec :: Num a => [a]) * vec ? ;)
11:12:58 <vincenz> AL: yes
11:13:01 <vincenz> don't make Num [a]
11:15:37 <AL> vincenz, make class Vector?
11:17:02 <vincenz> that or just use map
11:17:18 <AL> Thanks
11:17:26 <cmarcelo> DeliQ: sorry bothering, but i'm confused now.. do you want to subst only the free vars, right?
11:18:40 <Oejet> Hi all.
11:22:26 <caribe> hey there :) is it allowed to ask newbie questions in here?
11:22:42 <ValarQ> should be...
11:23:54 <caribe> actually i'm worked quite allot with haskell now.. but i think i didn't understand all that's behind the curtain
11:24:30 <caribe> i wrote a function to find a fixpoint
11:24:33 <caribe> fix::(Int->Int)->Int->Int, fix funkt x = if (funkt x) == x then x else (fix funkt (funkt x))
11:24:58 <xerox> fix f x = f (f x)
11:25:16 <xerox> Hmm.
11:25:19 <caribe> okay seems similar ;)
11:25:21 <caribe> but..
11:25:32 <caribe> with fix (\a -> a*a-2) 30 it finds the fixpoint 2
11:25:40 <caribe> but the hell why? ;(
11:25:57 <ihope> Hmm...
11:26:07 <xerox> > let fix f x = f (f x) in fix (\a -> a*a - 2) 30
11:26:10 <mbot> 806402
11:26:14 <vincenz> xerox: that's different
11:26:15 <ihope> > take 20 (iterate (\a -> a*a-2) 30)
11:26:17 <mbot> [30,898,806402,650284185602,422869522044056384102402,178818632673768688174803230563866379679222169602,31976103391316214661670026282017579950973885487726242305120136752627561001349977994848052838402,10224711880921443243117216819512180103726068410921270801259655282983367939540341724336865846642088450827906208713983400252536173853751249333541446789521
11:26:17 <mbot> [5 @more lines]
11:26:19 <xerox> Yes indeed.
11:26:39 <ihope> Hmm...
11:26:42 <vincenz> caribe: to find the root of a function you need to divide by the slope
11:26:50 <mauke>  > take 20 (iterate (\a -> a*a-2) 30) :: [Int]
11:26:57 <mauke> > take 20 (iterate (\a -> a*a-2) 30) :: [Int]
11:26:59 <mbot> [30,898,806402,1744123906,-602611710,877887490,290324482,1161297922,350224386,1400897538,1308622850,939524098,-536870910,-2147483646,2,2,2,2,2,2]
11:27:04 <ihope> Aha!
11:27:06 <vincenz> overflow
11:27:07 <vincenz> although
11:27:09 <bolrod> :)
11:27:11 <vincenz> 2 IS the correct answer
11:27:24 <caribe> hmm?
11:27:29 <bolrod> > 2^31 - 1 :: Int
11:27:31 <mbot> 2147483647
11:27:31 <vincenz> 2*2 - 2 = 2
11:27:40 <bolrod> > 2^31  :: Int
11:27:42 <mbot> -2147483648
11:27:42 <xerox> > maxBound :: Int
11:27:44 <bolrod> BAM
11:27:44 <mbot> 2147483647
11:27:46 <bolrod> and flips over
11:27:49 <bolrod> :)
11:27:54 <caribe> aaah so that's the secret? ;)
11:28:09 <bolrod> 0 = all 0 bits
11:28:15 <bolrod> right?
11:28:20 <alar> fixpoint theorem states that LFP is found by such iteration when starting value is lower bound of a set
11:28:28 <bolrod> 2^31 = all one bits
11:28:31 <bolrod> I think :x
11:28:35 <caribe> aaaah then fix::(Integer->Integer)->Integer->Integer shouldn't find it right?
11:28:38 <alar> and GFP is found starting from upper bound
11:28:53 <mauke> caribe: right
11:29:00 <alar> vincenz: I think there are 2 fixpoints: 2 and +Inf
11:29:12 <vincenz> true
11:29:23 <bolrod> and -Inf ?
11:29:43 <alar> bolrod: (-Inf)*(-Inf) -2 = + Inf
11:29:52 <bolrod> ahyeah
11:29:54 <bolrod> :]
11:29:59 <caribe> ah muchas gracias :>
11:30:13 <bolrod> *Eats more chocolate to start brain*
11:30:17 <bolrod> j/k ;)
11:30:25 <alar> the function is quadratic, so 2 fixpoints are natural
11:43:01 <astrolabe> The fixed points are 2 and -1.
11:43:31 <alar> :(
11:43:59 <alar> then there are 2 finite fixpoints and I miss something
11:45:36 <cm> what is it that you miss
11:46:34 <alar> how come that quadratic equation has 3 possibly infinite roots
11:47:01 <astrolabe> They aren't all roots of a quadratic.
11:47:18 <astrolabe> But they are fixed points (of a different one).
11:47:47 <alar> x*x - x - 2 = 0 <=> x <- x*x - 2 , right?
11:48:18 <astrolabe> for finite x, yes
11:48:47 <alar> and for infinite?
11:50:25 <astrolabe> If you append + \inf and -\inf to the reals in the natural way, then only f(x)-x = 0 => x is a fixed point, but not the converse.
11:50:51 <alar> oh
11:50:55 <alar> tell me why
11:51:33 <davidhouse> infty - infty is undefined
11:51:40 <davidhouse> infact, infty +- infty is undefined.
11:51:43 <davidhouse> *in fact
11:51:49 <bolrod> welllllllllllll
11:51:57 <bolrod> it can be 0
11:52:02 <davidhouse> well, no it can't.
11:52:04 <bolrod> it can be infinity
11:52:28 <bolrod> it can't?
11:52:41 <davidhouse> it's not defined. no matter what your intuition tells you, there's no defintion for infty +- infty that would be consistent to everybody's intuition everywhere.
11:52:55 <alar> sometimes Inf - Inf is discoverable by calculaing the limit
11:53:08 <davidhouse> e.g., if infty - infty = 0, then:
11:53:10 <alar> (in those cases where if the limit exists)
11:53:17 <rasfar> m+m=m for every infinite cardinal, isn't it?
11:53:31 <astrolabe> The problem is that sensible appearing reasoning about \inf-\inf will lead to contradictions.
11:53:41 <alar> ah, yes
11:53:46 <davidhouse> infty = infty; infty + 3 = infty + 4; infty - infty + 3 = infty - infty + 4; 3 = 4.
11:53:58 <bolrod> :)
11:54:17 <davidhouse> hence we don't define infty +- infty.
11:54:24 <bolrod> ic
11:54:43 <rasfar> oh, when you say "+-infty" you are meaning "+(-infty)", not "+infty or -infty"?
11:54:47 <alar> davidhouse: at least when we don't know the nature of those infinities
11:55:04 <davidhouse> rasfar: i mean infty + infty and infty - infty are both undefined
11:55:09 <davidhouse> alar, who said anything about limits?
11:55:23 <davidhouse> we're just talking the extended reals here.
11:55:29 <davidhouse> R u {infty, -infty}
11:55:55 <rasfar> my understanding is, m+m=m for every infinite cardinal -- where did i get this idea?
11:56:05 <astrolabe> That's true
11:57:02 <alar> yes, while Infs are just extended reals we cannot tell more about them
11:57:07 <davidhouse> "The addition of infinite cardinal numbers (assuming the axiom of choice) is easy. If either ? or ? is infinite, then ? + ? = max{?,?}. Subtraction cannot be defined for infinite cardinals." from wikipedia.
11:57:46 <davidhouse> so you're right, it appears m + m = m for any infinite cardinal.
11:57:58 <rasfar> whew; just a sanity check...
11:58:01 <alar> who are those cardinals? Catholic lords?
11:58:02 <davidhouse> but then, we're not working in the cardinals here.
11:58:06 <davidhouse> just the extended reals.
11:58:15 <rasfar> okay
11:58:27 <davidhouse> alar, cardinal numbers are used to denote the size of a set.
11:58:35 <alar> ah
11:59:27 <davidhouse> naievely, they go 1, 2, 3, ..., aleph_0, aleph_1, ...
11:59:47 <davidhouse> where the aleph_k are different 'sizes' of infinity (the infinite cardinals).
12:00:38 <davidhouse> the rationals or any infinite subset thereof (including the integers) have cardinality (size) aleph_0 (they are called 'countable'), the reals have cardinality aleph_1.
12:00:57 <alar> aleph_0 for countable, aleph_1 for continuum, right?
12:01:14 <astrolabe> That is the continuum hypothesis.
12:01:41 * alar doesn't know what goes after continuum
12:01:41 <davidhouse> the continuum hypothesis states that there's no set with cardinality > aleph_0 but < aleph_1, yes.
12:02:06 <astrolabe> Not quite
12:02:15 <davidhouse> well, that's how i like to remember it :)
12:02:15 <bolrod> so what is the set of   complex numbers
12:02:17 <bolrod> aleph_2 ?
12:02:45 <astrolabe> the cardinality of the complexs is the same as that of the reals.
12:02:58 <bolrod> weird
12:03:09 <davidhouse> the complexes biject onto the reals, so they have the same cardinality.
12:03:16 <bolrod> so is there anything with aleph_2 except the powerset of the reals?
12:03:39 <bolrod> they do ?!
12:03:57 <bolrod> how does     1+4i  biject to lets say.. 1
12:04:23 <astrolabe> roughley speaking, map 0.123 +0.456i onto 0.142536
12:04:26 <alar> continuous functions biject to powerset of reals
12:04:36 <alar> if I recall that right
12:04:53 <bolrod> powerset of reals is aleph_2  right?
12:04:59 <astrolabe> no
12:05:00 <bolrod> and aleph_2 > aleph_1
12:05:00 <xerox> astrolabe: nice.
12:05:12 <bolrod> I'm quite sure it is
12:05:26 <astrolabe> I think aleph_2 is the third infinite cardinal
12:05:28 <alar> C:R->R
12:05:51 <bolrod> *grabs book*
12:06:05 <astrolabe> How that compares to the size of the reals, power sets of the reals etc seems to be quite independent of intuitive axioms.
12:06:09 <xerox> http://en.wikipedia.org/wiki/Powerset
12:07:57 <bolrod> hmmmmmmmmm
12:15:07 <davidhouse> @pl \(t, c) -> (f t, c)
12:15:08 <mbot> first f
12:15:13 <davidhouse> @type first
12:15:15 <mbot> Not in scope: `first'
12:15:19 <davidhouse> @hoogle first
12:15:21 <mbot> http://www.usfirst.org/
12:15:30 <davidhouse> :( i want lambabot
12:15:31 <davidhouse> @index first
12:15:32 <mbot> Control.Arrow
12:15:35 <davidhouse> ah.
12:26:19 <davidhouse> given -fglasgow-exts, shouldn't i be able to derive Monad from newtype Loc a = Loc (State (Tree a, Cxt a) (Tree a)) 
12:27:08 <davidhouse> ah, apparently i need some type variables as well
12:28:42 <alar> is Monad derivable?
12:29:12 <davidhouse> alar, with -fglasgow-exts and newtype it is
12:29:27 <davidhouse> i think actually the problem is that i'm using my type variable in the arguments to State
12:30:15 <davidhouse> @pl \(B l r, c) -> (l, L c r)
12:30:15 <mbot> (line 1, column 5):
12:30:15 <mbot> unexpected "l"
12:30:15 <mbot> expecting operator or ")"
12:30:24 <davidhouse> @pl \ (B l r, c) -> (l, L c r)
12:30:24 <mbot> (line 1, column 6):
12:30:24 <mbot> unexpected "l"
12:30:24 <mbot> expecting operator or ")"
12:30:28 <davidhouse> huh?
12:34:36 <davidhouse> xerox, you around?
13:05:34 * JohnnyL takes not that there has been examples in #haskell where the code looks like assembler.
13:06:56 <basti_> hmm
13:07:05 <basti_> not really like assembler no
13:07:16 <mauke> @seen Cale
13:07:17 <mbot> Cale is in #haskell and #math. Last spoke 12 hours, 32 minutes and 58 seconds ago.
13:07:19 <basti_> but like combinatory logic
13:07:53 <basti_> which is just like assembler for mathematicans
13:10:01 <JohnnyL> basti, what's good about haskell is the small function utilizies it comes with, what's bad about haskell is the small functions it comes with.
13:10:18 <JohnnyL> still though, i bet if one makes mid level utilities the programs are easier to read.
13:10:19 <alar> combinatory assembler :)
13:11:37 <shapr> Yeah, combinators give you the flexibility to do all the good and bad things you get from asm or high level code.
13:16:06 <JohnnyL> bye
13:20:01 <musasabi> Why is low level GHC source so ugly :-(
13:20:22 <musasabi> Lots of long names ending with #.
13:20:34 <musasabi> and the same for all constants.
13:21:10 <musasabi> "(ord# (indexCharArray# addr (nh +# 2#)) -# 0x80#) `uncheckedIShiftL#`  6#)"
13:21:12 <musasabi> etc
13:21:21 <Korollary> you know why
13:22:28 <alar> seems it is targeted for prehistoric asm
13:22:38 <musasabi> actually no. Compiletime polymorphism should kill the need for such things.
13:24:20 <Korollary> If strictness analysis can't do this, there must be a reason.
13:25:28 <pesco> Somebody here who's seen Oleg's Haskell XML?
13:25:40 <musasabi> "((int)addr[nh+2] - 0x80) << 6" looks so much prettier
13:26:10 <musasabi> pesco: yes, it is really nifty. Of course being hlist based the error messages are not pretty.
13:27:25 <pesco> Say I want to use it for literal Haskell programming. It would become unwieldy because of all the escaping work. I'd really like to work out a solution to this.
13:27:40 <pesco> Got any suggestions?
13:29:24 <musasabi> Personally I think the humans should be forced write XML.
13:29:49 <pesco> Evil Morbo laugh?
13:30:49 <musasabi> It is just not something that is usually easy for humans to write.
13:31:01 <musasabi> and humans and machines like different kinds of XML schemas
13:31:24 <pesco> Well yes. I'm looking for something that humans like.
13:32:16 <pesco> Actually, I'm looking for something both will like. I'm looking for an invention. ;)
13:33:57 <xerox> S-expressions?
13:34:35 <musasabi> S-expressions are not too bad.
13:34:55 <pesco> Right. But I still see two problems with them.
13:34:57 <musasabi> I think it makes sense to have a format for humans and convert it to something machines like.
13:35:03 * alar can't remember what are S-expresions
13:35:12 <musasabi> length prefixed fields should be the norm.
13:35:16 <alar> sex-pressions
13:35:19 <vincenz> alar: scheme
13:35:34 <pesco> alar: (this (is one) for example (yeah like in scheme))
13:35:44 <vincenz> ((.) (.))
13:35:45 <vincenz> or that one
13:35:54 <vincenz> sex-pressions
13:36:07 <pesco> Why are they called s-exp's by the way? What's the S for?
13:36:13 <vincenz> scheme?
13:36:22 <xerox> alar: that notation where you enclose forms in round parentheses, with prefix function application.
13:36:25 * pesco raises an eyebrow.
13:36:50 <xerox> S stands for symbolic.
13:36:55 <pesco> Aha.
13:37:39 <mwc> I seem to remember reading once S-expressions were intended as an intermediate representation, lisp was supposed to get an ALGOL-ish syntax
13:38:13 <xerox> Their "counterpart" in programming languages are M-expressions, where M stands for meta.
13:38:31 <vincenz> xerox: S stands for sucky
13:38:33 <vincenz> and M for monaidc
13:38:37 <vincenz> :D
13:39:24 <mwc> S&M-expressions?
13:40:44 <alar> M for maniacal?
13:40:44 <musasabi> :-)
13:40:57 <musasabi> or Sexy
13:41:07 <pesco> Anyway. 1: S-exp's (as we know them) make you escape stuff in strings. 2: Closing with single brackets is not readable in the presence of very large blocks and absence of indentation.
13:41:07 <vincenz> musasabi: only if you're an untyped git
13:41:38 <pesco> mwc: BTW, yes, the original intent was to give LISP a different front syntax.
13:41:59 <vincenz> yeah
13:42:05 <vincenz> eventually they kept the IR as actual language
13:42:07 * vincenz laughs
13:42:27 <musasabi> vincenz: there is no reason one couldn't use them in a statically typed setting.
13:42:34 <vincenz> musasabi: it was a lame attempt at a joke
13:43:18 <xerox> pesco: absence of indentation can be considered as a bug :-)
13:43:46 <pesco> xerox: Not sure...
13:44:15 <xerox> I think S-expressions are pretty simple to pretty-print.
13:52:20 <alar> does Epigram allow possibly-nonterminating programs?
13:53:02 <alar> or it seeks some proof to put on top of program defined via "general"?
14:06:31 <ihope> dons: pingity
14:07:45 <ihope> Oh well.
14:07:47 <ihope> > 2897/8
14:07:51 <mbot> 362.125
14:15:32 <Phyx-> hello, i have a question about wxhaskell. if it possible to insert a combobox in a list? 
14:16:08 <waern> phyx, no
14:16:15 <Phyx-> :(
14:16:31 <Phyx-> that sucks. lol. well thanx
14:17:02 <Phyx-> i can accomplish it with win32 apis, but i didn't know if it can be done in haskell
14:17:15 <waern> I'm not _totally_ sure you can't do that
14:17:23 <waern> but it doesn't sound right
14:18:03 <waern> wxhaskell is cross-platform, so that win32 argument doesnt'
14:18:06 <waern> hold
14:18:12 <Phyx-> yes, why i asked
14:18:13 <Phyx-> hehe
14:18:39 <waern> ofcourse you could use the win32 api from Haskell
14:18:49 <waern> I think there's some bindings for that
14:18:51 <xerox> Or Gtk2Hs (-:
14:19:22 <Phyx-> yeah, but my problem is, what if someone ran it on a mac
14:19:37 <Phyx-> or linux
14:19:38 <Phyx-> heheh
14:19:49 <Phyx-> xerox: nah, has t be wx
14:20:03 <waern> phyx, then you're screwed
14:20:07 <xerox> Gtk works on the mac.
14:20:12 * xerox just compiled it.
14:20:19 <Phyx-> heeheh
14:20:28 <musasabi> Phyx-: look whether you can do it someway with the wx C++ api.
14:20:34 <jip> Phyx-: why not implement the functionality you need directly in wx and send a patch? :)
14:20:40 <musasabi> Phyx-: if that is possible then a Haskell wx solution should exist.
14:21:58 <Phyx-> musasabi: i can accomplish it in c++ using win32 api calls, but if it's run on a mac it'll fail. so my next question is, can you override the paint event and draw it then?
14:22:20 <Phyx-> i'm not so confortable drawing in haskell as i am with gdi+ so that might be to much
14:22:39 <Phyx-> jip: i'd need a mac to try it on ^_^
14:22:54 <waern> phyx, yes, you can override the paint event
14:23:48 <Phyx-> ok, so that's good. then i have another idea :)
14:24:15 <Phyx-> well, bbl, gonna give it a try
14:24:30 <RyanT5000> so, is it basically standard practice for show to return a string which, if taken as Haskell code, would return the thing you just showed?
14:26:05 <basti_> that's what "deriving Show" does
14:26:29 <waern> ryan, in general, no
14:26:42 <liyang> It's handy sometimes for (read . show) == id to hold.
14:27:21 <waern> ryan, it's meant for displaying something in a more friendly way than it's haskell representation
14:27:27 <RyanT5000> k, i noticed that that's what deriving does, but also show Data.Set.empty returns "fromList []"
14:27:32 <RyanT5000> ah ok
14:28:16 <pesco> Wow, it returns Haskell code proper? That's interesting.
14:28:40 <RyanT5000> yep
14:28:44 <pesco> So now we just need read=evaluate.
14:29:31 <ihope> > 363+1+2+1+1+1+2+362+1+1+1
14:29:34 <mbot> 736
14:30:02 <RyanT5000> pesco: might present some security issues, but otherwise seems cool
14:30:14 <bolrod> morning
14:30:53 <pesco> RyanT5000: Security Schmurity. That's what the type system's for. ;)
14:30:55 <bolrod> xerox: yo.. they say the iMac intel duo core is faster then the previous iMac
14:31:06 <bolrod> did the previous have Dual core G5 proc?
14:31:13 <xerox> Nope, IIRC.
14:31:19 <bolrod> hrm...    
14:31:24 <RyanT5000> pesco: what if you read a handcrafted file that has "unsafe*" in it?
14:31:31 * bolrod wonders if dou core intel can beat dual core G5 PPC
14:31:43 <RyanT5000> you need a sandbox for evaluation (like has been discussed in here before)
14:31:45 <pesco> RyanT5000: You don't allow anything unsafe in the code. ;-)
14:32:00 <RyanT5000> is there a simple way to "not allow anything unsafe"?
14:32:06 <xerox> grep -v
14:32:15 <xerox> ...or  lambdabot's way.
14:32:17 <mauke> grep -v .
14:32:37 <RyanT5000> i don't buy the grep way
14:32:44 <xerox> sed?
14:32:55 <RyanT5000> does Haskell guarantee that all unsafe functions start with the word "unsafe"?
14:33:03 <mauke> haha
14:33:06 <RyanT5000> besides, what if they write
14:33:09 <jip> depends what you mean by unsafe
14:33:19 <RyanT5000> i mean violates types or purity
14:33:36 <xerox> safetyzer.sh: sed -e 's/unsafe.*/error "no way you'll be doing unsafe things here."/g'
14:33:51 <RyanT5000> lol
14:34:11 <RyanT5000> eval (reverse "efasnu")
14:34:19 <xerox> Sure, you ban IO.
14:34:40 <RyanT5000> i thought hte whole point of unsafe functions is that they werent' in IO?
14:34:44 <mauke> that reminds me of ftp://ftp.rfc-editor.org/in-notes/rfc3514.txt
14:35:22 <jip> RyanT5000: not necessarily. for example. the stuff in Foreign.Ptr can be used to write into unkown memory, possible corrupting data and causing all kinds of weird unsafe shit
14:35:26 <xerox> RyanT5000: how are you going to make an IO action which does something ev1l, to be fed to unsafePerformIO, without IO?
14:37:28 <RyanT5000> er, xerox
14:37:38 <RyanT5000> they can feed something to unsafePerformIO themselves
14:37:58 <RyanT5000> unsafePerformIO getLine
14:38:07 <RyanT5000> that could be your "serialized string"
14:38:17 <xerox> RyanT5000: Is there such a thing?
14:38:27 <RyanT5000> http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign.html#v%3AunsafePerformIO
14:39:09 <xerox> RyanT5000: you do not have getLine, since it uses IO.
14:39:15 <RyanT5000> ...?
14:39:26 <RyanT5000> how do you "not have" it?
14:39:33 <xerox> > getLine
14:39:35 <mbot> No IO allowed
14:39:38 <RyanT5000> are you saying we'd look at the symbol table and throw out anything that uses IO?
14:40:53 <xerox> If you have some time skim off lambdabot's sources.
14:41:07 <mauke> > const "hmm" getLine
14:41:09 <mbot> "hmm"
14:41:12 <RyanT5000> yah i'm just theorizing :P
14:41:14 <RyanT5000> i have no use for this
14:41:17 <RyanT5000> (yet)
14:41:23 <alar> @type const
14:41:24 <mbot> forall a b. a -> b -> a
14:41:36 <xerox> @type Control.Monad.Fix.fix flip
14:41:38 <mbot> forall a c. a -> a -> c
14:43:28 <waern> > getLine
14:43:29 <mbot> No IO allowed
14:44:03 <RyanT5000> > unsafePerformIO getLine
14:44:04 <mbot>  Not in scope: `unsafePerformIO'
14:44:22 <RyanT5000> > System.IO.Unsafe.unsafePerformIO getLine
14:44:24 <mbot>  Not in scope: `System.IO.Unsafe.unsafePerformIO'
14:44:36 <RyanT5000> :)
14:53:07 <mwc> This is OT here, but I think somebody will know what I'm taking about
14:53:19 <mwc> anybody know of a good package for setting pseudocode in Latex?
15:11:48 <Oejet> mwc: Listings.
15:12:37 <Paltas> Godaften oejet :)
15:18:43 <Oejet> Paltas: Hejsa, længe siden!
15:19:20 <vincenz> Oejet: Your friend?
15:19:33 * Phyx- babelfishes
15:20:13 <Paltas> Oejet, Ja det maa man sige, skifter lige til Engelsk saa ingen brokker sig. How is life? Did you got your bzip2 extention working?
15:20:37 <Paltas> Phyx-, Doesn't help it doesn't support danish (he just wrote "long time ago" :))
15:24:36 <jip> anyone know what the mainQuit gtk2hs function is called in c gtk+?
15:25:05 <Lemmih> gtk_main_quit?
15:25:13 <jip> Lemmih: thanks!
15:25:16 <Oejet> Paltas: Actually yes.  With laziness and all.  Will you participate in the ICFP contest July 21-24?
15:25:43 <jip> Lemmih: i designed a gui in glade, and when on do: window_main `onDestroy` mainQuit
15:26:01 <jip> it works great, but when i do: menu_quit `onActivateLeaf` mainQuit
15:26:14 <jip> then it sort of quits, but the window isn't closed!
15:28:34 <Paltas> Oejet, you'll be i assume?
15:30:17 <Oejet> Paltas: Indeed, because it's great fun.
15:30:37 <vincenz> Paltas: http://www.notvincenz.com/wiki/pmwiki.php/Icfp/Main
15:33:02 <Paltas> Yeah it seems like it could be very funny. :)
15:34:18 <toast> oi
15:34:19 <toast> http://pastebin.com/663919
15:34:26 <toast> doesn't work, why :p
15:35:22 <Lemmih> toast: (/=) doesn't work on all types. It only works for members of the Eq class.
15:36:05 <Lemmih> toast: Try removing the type signature and let your Haskell implementation infer it.
15:36:49 <toast> work
15:37:02 <toast> but how would i "include" Eq in my defenition ?
15:37:21 <Lemmih> Are you using Hugs or GHC?
15:37:28 <toast> hugs
15:37:49 <xerox> I think it's okay to write it as just drop x = filter (/= x) anyway.
15:38:07 <toast> yes, but hum, i would like to know still :p
15:38:11 <Lemmih> toast: ':t drop' will tell you what type it inferred.
15:38:17 <toast> k
15:38:26 <toast> drop :: Eq a => a -> [a] -> [a]   
15:38:29 <toast> thx
15:38:41 <xerox> The syntax there is <name> :: <constraints> => <type>
15:40:30 <xerox> The constraints tell about typeclass membership of type variables; also note that all the constrained type variable *must* appear at least one time in the type.
15:40:53 <jip> a `f` x >> b `f` x >> c `f` x
15:41:01 <jip> i should be able to convert this to:
15:41:06 <toast> > a `f` x >> b `f` x >> c `f` x
15:41:07 <mbot>  Not in scope: `x'
15:41:13 <jip> mapM_ (`f` x) [a, b, c]
15:41:15 <jip> right?
15:41:45 <jip> problem is, i can't
15:42:07 <ihope> Um...
15:42:13 <ihope> @index mapM_
15:42:13 <mbot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
15:42:20 <ihope> @type mapM_
15:42:22 <mbot> forall (m :: * -> *) a b.
15:42:22 <mbot>    (Monad m) =>
15:42:22 <mbot>    (a -> m b) -> [a] -> m ()
15:42:57 <ihope> Aha. It returns m (), not m b.
15:43:19 <jip> ihope: no, that shouldn't be a problem
15:43:28 <Lemmih> jip: Why can't you?
15:43:37 <ihope> Well, are you sure the sequence thing is happening in the right order?
15:43:47 <jip> Lemmih: because f isn't a regular function, i think it's a typeclass function, and a, b, and c aren't of the same type
15:44:15 <Lemmih> Ah, then of course you can't.
15:44:32 <jip> Lemmih: my_button `widgetSetSensitivity` s >> my_menu_item `widgetSetSensitivity` s
15:44:42 <jip> so what can i do?
15:44:50 <xerox> @pl \f x -> a `f` x >> b `f` x >> c `f` x
15:44:50 <mbot> ap (ap . ((>>) .) . ap (ap . ((>>) .) . ($ a)) ($ b)) ($ c)
15:44:59 <ihope> @pl \x y z -> x z y
15:45:00 <mbot> flip
15:45:08 <ihope> Okay, cool.
15:45:22 <Lemmih> jip: Cast the objects to widgets?
15:45:45 <jip> Lemmih: yeah, i guess that would work. thanks!
15:46:00 <jip> Lemmih: btw, do you have any ideas on what i asked earlier?
15:46:07 <xerox> mapM_ ((`widgetSetSensivity` s) . toWidget)
15:46:15 <ihope> b = (.); c = flip; i = id; k = const; s = ap; w = join; y = fix
15:46:16 <xerox> Whatever is toWidget really called.
15:46:36 <toast> what would be a good way of removing doubles in a list
15:46:42 <xerox> nub it.
15:46:44 <Lemmih> jip: I think you could destroy the main window on menu_quit.
15:47:02 <xerox> > nub ([1..10] >>= \x -> [x,x,x])
15:47:04 <mbot> [1,2,3,4,5,6,7,8,9,10]
15:47:19 <Lemmih> > [1..10] >>= \x -> [x,x,x]
15:47:20 <mbot> [1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7,8,8,8,9,9,9,10,10,10]
15:48:28 <toast> yer, but thats actually what i want to know
15:48:33 <toast> whats the nub function do
15:48:37 <toast> or how it do it
15:48:55 <jip> Lemmih: ah, seems to work great, thanks! wonder why mainQuit doesn't destroy all windows automatically though...
15:50:43 <araujo> @type nub
15:50:43 <ihope> > nub "The quick brown fox jumps over the lazy dog."
15:50:44 <mbot> Not in scope: `nub'
15:50:45 <mbot> "The quickbrownfxjmpsvtlazydg."
15:50:57 <araujo> @type List.nub
15:50:59 <mbot> forall a. (Eq a) => [a] -> [a]
15:51:25 <ihope> > length (nub "The quick brown fox jumps over the lazy dog.")
15:51:27 <mbot> 29
15:51:36 <xerox> > let nub = foldr (\n xs -> if not (n `elem` xs) then n:xs else xs) [] in nub ([1..10] >>= \x -> [x,x,x])
15:51:37 <mbot> [1,2,3,4,5,6,7,8,9,10]
15:51:45 <toast> > :t dub
15:51:45 <mbot>  parse error on input `:'
15:51:51 <xerox> A possible implementation.
15:52:20 <ihope> > let nub = foldr (\n xs -> if not (n `elem` xs) then n:xs else xs) [] in nub "The quick brown fox jumps over the lazy dog."
15:52:21 <mbot> "Tqickbwnfxjumpsvrthelazy dog."
15:52:37 <toast> over complicated for me :p
15:52:38 <vincenz> ??
15:52:46 <ihope> > let nub = foldl (flip (\n xs -> if not (n `elem` xs) then n:xs else xs)) [] in nub "The quick brown fox jumps over the lazy dog."
15:52:48 <mbot> ".gdyzaltvspmjxfnworbkciuq ehT"
15:52:51 <xerox> toast: it's very simple in fact.
15:52:52 <Lemmih> let nub = S.toList . S.fromList in nub ([1..10] >>= \x -> [x,x,x])
15:52:55 <Lemmih> > let nub = S.toList . S.fromList in nub ([1..10] >>= \x -> [x,x,x])
15:52:56 <mbot> [1,2,3,4,5,6,7,8,9,10]
15:53:03 <xerox> Lemmih's one is prolly faster.
15:53:40 <toast> > [1..10] >>= \x -> [x,x,x]
15:53:42 <mbot> [1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7,8,8,8,9,9,9,10,10,10]
15:53:44 <xerox> @type (Data.Set.toList,Data.Set.fromList)
15:53:45 <mbot> forall a a1.
15:53:45 <mbot>              (Ord a1) =>
15:53:45 <mbot>              (Data.Set.Set a -> [a], [a1] -> Data.Set.Set a1)
15:53:54 <xerox> Ah, it needs Ord, not Eq, too.
15:55:52 <toast> let nub = foldl (flip (\n xs -> if not (n `elem` xs) then n:xs else xs)) [] in [1..10] >>= \x -> [x,x,x]
15:55:55 <toast> > let nub = foldl (flip (\n xs -> if not (n `elem` xs) then n:xs else xs)) [] in [1..10] >>= \x -> [x,x,x]
15:55:57 <mbot> Add a type signature
15:56:06 <toast> > let nub = foldl (flip (\n xs -> if not (n `elem` xs) then n:xs else xs)) [] in nub [1..10] >>= \x -> [x,x,x]
15:56:08 <mbot> [10,10,10,9,9,9,8,8,8,7,7,7,6,6,6,5,5,5,4,4,4,3,3,3,2,2,2,1,1,1]
15:56:19 <toast> > let nub = foldl (flip (\n xs -> if not (n `elem` xs) then n:xs else xs)) [] in nub ([1..10] >>= \x -> [x,x,x])
15:56:21 <mbot> [10,9,8,7,6,5,4,3,2,1]
15:56:25 <ihope> Whee...
15:56:30 <xerox> toast: mbot also answers private messages.
15:56:37 <toast> k
15:58:12 <xX[ReP]Xx> hm, how do i get the HostAddrress from a SockAddr? (Network.Socket)
15:58:36 <ihope> @hoogle SockAddr -> HostAddress
15:58:39 <mbot> http://haskell.org/ghc/docs/6.4/html/libraries/network/Network.Socket.html
15:58:56 <xerox> No hoogle, boogey!
15:59:12 <ihope> Only Google?
15:59:17 <xX[ReP]Xx> ihope not very helpful
15:59:26 <alar> just as you do that in C: deconstruct sockaddr
15:59:43 * ihope gets a sudden deja vu
15:59:46 <xX[ReP]Xx> how do you deconstruct a datatype?
15:59:53 <xerox> xX[ReP]Xx: via pattern-matching.
16:00:09 <xX[ReP]Xx> yeah, but i don't know what a sockaddr looks like
16:00:24 <xerox> data SockAddr
16:00:24 <xerox> = SockAddrInet PortNumber HostAddress
16:00:24 <xerox> | SockAddrUnix String
16:00:37 <xerox> (It's on that page.)
16:02:07 <xerox> Maybe you could even just show it, if it has a proper Show instance.
16:02:18 <xX[ReP]Xx> show kinda works
16:02:27 <xX[ReP]Xx> but it also puts the port number, which i don't care about
16:02:32 <xerox> Gotcha.
16:03:43 <xerox> xX[ReP]Xx: did you refactor that prog?
16:03:50 <xX[ReP]Xx> woot, it works
16:03:53 <xX[ReP]Xx> no
16:03:54 <xerox> Hmpf.
16:04:04 <xX[ReP]Xx> i tried, once
16:04:12 <xX[ReP]Xx> and it was too hard
16:04:43 <xerox> It will not save you! Sinner!!
16:05:21 <sethk> has anyone noticed that tryPutMVar doesn't work correctly?
16:05:38 <mux> @pl \c -> not (isSpace c)
16:05:38 <mbot> not . isSpace
16:05:49 <mux> duh, time to go sleeping
16:05:54 <xerox> Goodnight.
16:06:10 <mux> thanks
16:06:13 <toast> foldr (\x y -> (x+y)/2) 54 [12,4,10,6]
16:06:18 <toast> what happend in here ?
16:06:55 <ihope> That's not an average, if that's what you're after...
16:07:08 <toast> nah i mean, what does it do
16:07:26 <toast> > foldr (\x y -> (x+y)/2) 54 [12,4,10,6]
16:07:29 <mbot> 12.0
16:07:42 <ihope> Well, if starts with 54, then averages each element of the list with it, starting with the leftmost element.
16:07:47 <xerox> (((54 / 6 + 2) / 10 + 2) / 4 + 2) / 12 + 2
16:07:50 <ihope> s/if/it/
16:08:12 <xerox> > (((54 / 6 + 2) / 10 + 2) / 4 + 2) / 12 + 2
16:08:14 <mbot> 2.23125
16:08:17 <xerox> Urgh.
16:08:20 <araujo> hah
16:08:29 <araujo> it does 6 + 54 / 2 .....
16:08:38 <xerox> Indeed.
16:09:23 <xerox> > 12 + (4 + (10 + (6 + 54 / 2) / 2) / 2) / 2
16:09:25 <mbot> 20.625
16:09:30 <xerox> No?
16:09:30 <toast> > foldr (\x y -> (x+y)/2) [12,4,10,6]
16:09:32 <mbot>  add an instance declaration for (Show ([[a]] -> [a]))
16:09:39 <Korollary> It's interesting that most of my haskell programs don't have fold in it. Mostly maps and filters.
16:09:40 <toast> > foldr (\x y -> (x+y)/2) 1 [12,4,10,6]
16:09:42 <mbot> 8.6875
16:09:57 <xerox> Ah, the parens.
16:09:59 <xerox> Grr.
16:10:41 <xerox> (((((((54 + 6) / 2) + 10) / 2) + 4) / 2) + 12) / 2
16:10:43 <xerox> > (((((((54 + 6) / 2) + 10) / 2) + 4) / 2) + 12) / 2
16:10:45 <mbot> 12.0
16:10:55 * xerox <- joy
16:11:06 <araujo> Korollary, we are two now
16:11:29 <xerox> Man, I always get down to fold arrows.
16:12:03 <araujo> Though i like to (ab)use flips/folds sometimes :-)
16:12:13 <jip> yikes if error happens inside IO action executed from within ghci, is it normal for ghci to quit or crash?
16:12:32 <ihope> I hope not.
16:13:20 <Korollary> jip: no
16:13:21 <jip> it's happening
16:13:38 <Korollary> Prelude> do x <- readFile "nosuch"; print $ head x;
16:13:45 <Korollary> *** Exception: nosuch: openFile: does not exist (No such file or directory)
16:14:42 <jip> that's an exception, i'm talking about error
16:14:42 <Korollary> Hmm, that phrase is backwards.
16:19:30 <xerox> Prelude> error "foo"
16:19:30 <xerox> *** Exception: foo
16:19:31 <xerox> I.e. error = exception.
16:19:44 <toast> foldr (\n
16:19:46 <xerox> (with some magic beneath)
16:19:50 <toast> what does \n does
16:20:19 <xerox> \ is the ascii symbol which was chosen for represent lambda.
16:20:44 <xerox> Lambda denotates anonymous function by means of this syntax: \<args> -> <body>.
16:22:07 <xerox> That is \a b -> (a + b) / 2 is equal to mean a b = (a + b) / 2, modulo having a name.
16:22:34 <xerox> In fact you can also write mean as: mean = \a b -> (a + b) / 2.
16:22:46 <jip> xerox: how would you explain ghci closing on me? have you experienced anything like this before? i also tried catching the error but it isn't caught :\
16:23:03 <xerox> jip: could you give any insights about the particular situation?
16:24:32 <jip> xerox: it's nothing special i don't think. i'm using gtk2hs
16:26:09 <xerox> I can't replicate anything involving gtk2hs atm, GHC isn't ported to Yonah yet.  I'm sorry. 
16:26:15 <xerox> Goodnight chaps.
16:26:21 <jip> yonah?
16:35:49 <jip> @hoogle Bool -> Int
16:35:50 <mbot> http://doc.trolltech.com/3.3/qheader-h.html
16:35:58 <jip> eh?
16:36:08 <Korollary> lol
16:36:17 <jip> f True = 1; f False = 0; what is this function called?
16:37:12 <Lemmih> @type Foreign.fromBool
16:37:14 <mbot> forall a. (Num a) => Bool -> a
16:37:36 <Igloo> f! But you probably wanted fromEnum.
16:37:38 <Korollary> mbot probably doesn't have hoogle and is correcting it to @google
16:38:13 <jip> > fromBool True
16:38:15 <mbot>  Not in scope: `fromBool'
16:38:38 <Korollary> > Foreign.fromBool True
16:38:40 <mbot>  Not in scope: `Foreign.fromBool'
16:47:34 <vincenz> hmm
16:47:45 <vincenz> @hoogle fromBool
16:47:47 <mbot> http://planatechsolutions.com/xllplus-online/CXlOper_FromBool.htm
16:47:51 <vincenz> o.O
16:48:06 <vincenz> I said hoogle, not google!
16:50:43 <Phyx-_> lol
16:51:17 <Phyx-_> hoogle == haskell google?
16:51:34 <Smokey`> aye
16:53:02 * jip hopes that lambdabot hasn't died and joined MegaMonad :\
17:10:08 <jip> anyone know how i'm supposed to construct a TextIter in gtk2hs?
17:13:40 <jlhamilton> is there a way for a bunch of functions to use a finite map without having to pass it around as an argument?
17:16:08 <mwc> jlhamilton, embed it in a State monad?
17:17:19 <mwc> foo :: Args -> FiniteMap Foo Bar -> Ret becomes foo :: Args -> State (FiniteMap Foo Bar) Ret for instance
17:17:43 <jlhamilton> i'm still learning Haskell and I have never used the State monad before, but I suspected that it might be the way to go
17:18:31 <mwc> Yah
17:18:41 <mwc> basically, what you'll do, is remove the FM parameter from your functions
17:18:52 <sethk> anybody know if a QSem is available or unavailable when created?
17:19:27 <mwc> and then replace the function body with do { fm <- get; return $ functionVal}
17:19:29 <jlhamilton> ok, i'll take a look at that
17:20:26 <Revision17> Anyone know when GHC will be officially supported on OSX Intel?
17:22:11 <ayrnieu> probably very soon.  Soon enough that you can just start programming with it under emulation and expect to have native ready before you get anything interesting done.
17:22:53 <Revision17> :)
17:25:28 <toast> http://pastebin.com/664091
17:25:32 <toast> whats rong sensei ;p
17:27:15 <Lemmih> toast: zip (z:[]) = ...
17:27:47 <Lemmih> toast: Otherwise it parses as '(zip z) : []'.
17:31:43 <sethk> figured out how to get dual windows in vim, one with the .hs file and the other with compiler error output
17:57:02 <vincenz> :split
17:57:05 <vincenz> :vsplit
17:58:23 <dons> sethk, with compiler error output? how?
17:58:52 <sethk> dons, with gvim, do :make.   then on the tools menu, select error window/open
17:59:17 <sethk> dons, highlights the current error, goes to the source code line when you double click on an error, etc.
17:59:27 <sethk> doesn't highlight, actually, but puts the cursor on it
18:00:15 <jip> hi dons! long time no talk
18:00:20 <jip> dons: do you know who i am?
18:00:32 <ayrnieu> DO YOU KNOW *WHO* *I* **AM**?
18:00:39 <dons> sethk, that works with ghc?
18:00:42 <ayrnieu> MY FATHER IS A VERY IMPORTANT PERSON
18:00:45 <sethk> dons, yep
18:00:52 <dons> cool, i'll have to try ti
18:06:25 <vincenz> dons: !!!!
18:06:28 <vincenz> dons: You're herer!!!
18:06:31 <vincenz>  \o/
18:06:42 <vincenz> dons: hmp3 is segfaulting
18:06:57 <dons> yikes!
18:07:07 <dons> where? any info?
18:07:11 <dons> how can I reproduce it.
18:07:28 <vincenz> dons: I did an update of hmp3
18:07:31 <vincenz> wouldn't compile
18:07:35 <vincenz> so I got the latest version of fps
18:07:36 <vincenz> and installed
18:07:38 <vincenz> (mmap version)
18:07:44 <vincenz> then -> segfault
18:07:51 <vincenz> rewinded one thingy of hmp3
18:07:52 <vincenz> still segfault
18:07:52 <dons> oh, mmap doesn't work on every system.
18:07:55 <vincenz> ah
18:08:00 <vincenz> linux/ubuntu
18:08:03 <dons> so use the no-mmap version, try that.
18:08:09 <jip> dons: did you ever end up applying that patch?
18:08:10 <vincenz> ok
18:08:11 <vincenz> will do
18:08:12 <dons> then well see what happens.
18:08:14 <dons> jip, yup
18:08:27 <jip> dons: awesome, weee thanks!
18:09:24 <vincenz> dons: normal I get a lot of No's
18:09:27 <vincenz> when configuring fps
18:09:37 <vincenz> No c2hs, cpphs, greencard
18:09:52 <Lemmih> dons: Have you tried linking object files against arbitrary closures?
18:10:00 <dons> vincenz: that's ok.
18:10:15 <dons> Lemmih, hmm. do tell..
18:10:31 <vincenz> dist/build/hmp3/hmp3-tmp/Keymap.o:: more undefined references to `DataziFastPackedString_zdwccall13_info' follow
18:10:59 <dons> vincenz, did you rebuidl fps with the no-mmap cabal file, and reinstall it?
18:11:01 <vincenz> yep
18:11:07 <dons> then clean hmp3, and restart it?
18:11:08 <vincenz> cleaned hmp3
18:11:10 <vincenz> maybe that's it
18:11:15 <vincenz> btw
18:11:19 <vincenz> nm
18:11:53 <vincenz> oh yeah
18:11:55 <vincenz> install of hmp3
18:11:57 <vincenz> as sudo
18:11:58 <vincenz> gives it wrong perms
18:12:14 <vincenz> works now \o/
18:12:37 <dons> hmp3 works?
18:12:40 <dons> so it was the mmap stuff?
18:13:02 <vincenz> apparently
18:13:45 <dons> ok. fine.
18:13:50 <vincenz> dons: '\\'        Search for file matching regex
18:13:50 <Lemmih> dons: I tried to do it but the garbage collector kept moving the closures around without updating the address in the newly linked code (which isn't really surprising).
18:13:56 <vincenz> should prolly say '\'
18:14:45 <Lemmih> dons: I was wondering if you knew how the garbage collector works in this regard. I want to inform it of the new references.
18:14:48 <vincenz> dons: feature request: \ or / or | without args but just enter should execut last regexp
18:15:01 <vincenz> dons: and check out http://www.notvincenz.com/wiki/pmwiki.php/Icfp/Main
18:15:02 <vincenz> :)
18:15:03 <dons> vincenz, like 'n' and 'N' do?
18:15:07 <vincenz> hmm
18:15:13 <vincenz> whoops
18:15:44 <dons> Lemmih: hmm. sounds tricky. isn't there a way to 'pin;' references though?
18:15:52 <vincenz> dons: other feature request... searching should cycle
18:16:01 <dons> hmm. maybe.
18:16:10 <vincenz> ala vim
18:16:12 <dons> it doesn't in many apps though
18:16:14 <vincenz> end = current line
18:16:15 <dons> i.e. less/ more
18:16:21 <dons> ah, ok.
18:16:29 <dons> that's reasonable
18:16:47 <vincenz> but
18:16:50 <vincenz> I'll look at the source sometime
18:16:54 <vincenz> maybe implement some features
18:16:56 <vincenz> and send you a path
18:16:57 <vincenz> patch
18:17:28 <Lemmih> dons: Yeah, I thought about pinned closures but I don't think they exist. The only way access a Haskell object from out side of Haskell is via a StablePtr, iirc.
18:17:31 <dons> ok. remember i want to keep it simple. so no huge mail-sending, opengl-playing capabilities ;)
18:18:42 <dons> hmm. Lemmih. tricky. what effect are you trying to achieve?
18:19:15 <dons> ?karma+ musasabi --hacking on happs
18:19:21 <dons> oh no bot?
18:19:30 <vincenz> dons: no worry, simple is good
18:19:42 <vincenz> dons: about lambdabot, what would be the complexity of a update-notifier for a darcs repo
18:19:52 <dons> we already have one :)
18:19:55 <vincenz> ooooooooooooh
18:20:00 <vincenz> for any repo?
18:20:02 <dons> look at the DarcsPatchWatch plugin
18:20:06 <dons> for local repos
18:20:08 <vincenz> link?
18:20:08 <dons> not remote oens
18:20:24 <dons> hmm, www.cse.unsw.edu.au/~dons/code/lambdabot/plugin/
18:20:33 <vincenz> and any idea why lambdabot often crashes on my system 
18:20:47 <dons> crashes? how so?
18:20:54 <vincenz> well
18:20:54 <Lemmih> dons: I want to export closures as top-level functions.
18:20:58 <vincenz> like the real lambdabot but more often
18:21:05 <vincenz> just...stops responding
18:21:16 <dons> ah. no idea. network pings maybe.
18:21:48 <dons> Lemmih? you want to link a module, and export the closures you bind to the symbols?
18:21:51 <dons> more info..
18:22:38 <Lemmih> dons: http://haskell.org/hide/?p=9
18:22:54 <dons> i'm actually working on some stability issues in lambdabot atm, vincenz
18:22:59 <vincenz> kewl
18:23:06 <vincenz> check out http://www.notvincenz.com/wiki/pmwiki.php/Icfp/Main
18:23:35 <Lemmih> dons: Exporting partially applied closures would solve the annoying problem of global variables in HIDE.
18:24:06 <dons> hmm
18:25:02 <Lemmih> dons: And it all works fine when the code is interpreted because the linker env is kept on the Haskell side (ie. closure ptrs are updated correctly by the GC).
18:25:13 <vincenz> dons: also decouple j,k and Up and Down... j and k should follow of order that songs are played in (random for instance)
18:25:47 <dons> vincenz, hmm. maybe i'll just write a more scriptable interface.
18:25:52 <dons> so you can write your own .conf files
18:25:53 <vincenz> :
18:25:55 <vincenz> :)
18:26:00 <vincenz> with a monadic language
18:26:28 <vincenz> @hoogle modify
18:26:29 <lambdabot> Control.Monad.State.modify :: MonadState s m => (s -> s) -> m ()
18:26:29 <lambdabot> Data.IORef.modifyIORef :: IORef a -> (a -> a) -> IO ()
18:26:29 <lambdabot> Data.STRef.modifySTRef :: STRef s a -> (a -> a) -> ST s ()
18:26:30 <mbot> http://www.livejournal.com/modify.bml
18:26:32 <vincenz> @hoogle modifyST
18:26:33 <lambdabot> Data.STRef.modifySTRef :: STRef s a -> (a -> a) -> ST s ()
18:26:34 <mbot> http://www.kolar.bsnl.co.in/adm/modifyst.php
18:26:40 <vincenz> mbot: shush, I hoogle not google
18:26:52 <dons> mbot: @part
18:27:02 <vincenz> lambdabot: @join oasis
18:27:02 <dons> mbot doesn't like me anymore?
18:27:03 <lambdabot> Not enough privileges
18:27:25 <dons> mbot: @version
18:27:26 <mbot> lambdabot 3p287, GHC 6.4.1 (Linux i686 )
18:27:26 <mbot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
18:27:35 <dons> mbot: @seen mbot
18:27:36 <mbot> Yes, I'm here. I'm in #haskell, ##engineering and #math
18:27:43 <dons> mbot: @part
18:27:48 <dons> nope
18:28:09 <vincenz> mbot: @mute
18:28:10 <mbot> Maybe you meant: math more quote
18:28:30 <dons> hmm, a real #haskell icfp team, eh?
18:28:32 <vincenz> @mute might be a good "everyone can use' command per channe
18:28:32 <mbot> Maybe you meant: math more quote
18:28:33 <lambdabot> Maybe you meant: more quote vote
18:28:35 <Lemmih> dons: We'd like lambdabot to join #oasis
18:28:38 <vincenz> dons: yeah
18:28:48 <vincenz> dons: Cale made lambdabot join #oasis 
18:28:52 <vincenz> but then she died
18:28:54 <dons> lambdabot: /join #oasis
18:29:08 <dons> and would you like lambdabot to always be in oasis?
18:29:13 <vincenz> hmm
18:29:13 <vincenz> sure
18:29:15 <dons> (i'll add it to the config files)
18:29:19 <vincenz> tho
18:29:25 <vincenz> I'll most likely run my own version
18:29:26 <Lemmih> Isn't oasis only a temporary name?
18:29:27 <vincenz> for darcs-watch
18:29:33 <vincenz> Lemmih: I regged channel name
18:29:38 <vincenz> Lemmih: team name can obviously still change
18:30:01 <dons> its interesting, stefanw actually wrote the darcspatchwatch plugin for our last year's icfp effort
18:30:05 <vincenz> :)
18:30:08 <dons> it works pretty well, i would say.
18:30:11 <vincenz> cool
18:30:15 * vincenz is going to experiment
18:30:19 <dons> but this year, not sure what i'm doing... 
18:30:30 <vincenz> nor is shapr
18:30:32 <dons> so i'll put myself down as a possible, i think.
18:30:35 <vincenz> :)
18:34:26 <vincenz> ack
18:34:27 <vincenz> /tmp/ghc18324.hspp:48:8: parse error on input `]'
18:34:33 <vincenz> ghc -Wall -Werror -fglasgow-exts -I. -pgmF ./dsl -F -funbox-strict-fields -O -fasm -fno-warn-incomplete-patterns -fno-warn-missing-methods  -package mtl Config.hs Lib/Util.hs scripts/GenModules.hs -o genmodules
18:34:54 <dons> vincenz, possibly a bug in your config.mk.in ?
18:34:58 <dons> or config.mk
18:35:59 <vincenz> dunno
18:37:59 <dons> you'll have to track down the syntax error. did you edit any files before the build?
18:38:13 <vincenz> only Config.hs
18:38:16 <vincenz> but I'm doing a clean get
18:38:35 <dons> ah, soudns like you maybe left off a , in your Config.hs ?
18:38:42 <vincenz> hmm
18:38:43 <vincenz> possibly
18:38:58 <vincenz> can I just leave empty paths for fptools
18:39:16 <vincenz> lambdabot really needs a config-file
18:39:25 <vincenz> cause for instance DarcsPatchWatch also has hard coded strings
18:39:48 <dons> its on the todo list. the darcspatchwatch hard coded string should be moved out in to the Config.hs too
18:39:56 <vincenz> yeo
18:39:57 <vincenz> yep
18:39:58 <vincenz> but even then
18:40:04 <vincenz> recompilation for setting changes..
18:40:06 <dons> plugins you don't use can have empty values, sure
18:40:27 <dons> but ideally we have a reloadable config. its a few hours work though, i'd think
18:40:43 <Lemmih> No @join #oasis?
18:40:57 <dons> did I have it join? I thought i did
18:41:00 <dons> ?seen lambdabot
18:41:00 <lambdabot> Yes, I'm here. I'm in #scannedinavian, #haskell.es, #haskell.it, #gentoo-haskell, #haskell-overflow, #flippi, #haskell-blah, #haskell and #ScannedInAvian
18:41:03 <dons> hmm
18:41:11 <palomer> @quote lambdabot
18:41:11 <mbot> lambdabot hasn't said anything memorable
18:41:12 <lambdabot> No quotes yet.
18:41:15 <dons> lambdabot, @join #oasis
18:41:19 <palomer> who's this mbot fellow?
18:41:20 <dons> ?seen lambdabot
18:41:21 <lambdabot> Yes, I'm here. I'm in #oasis, #scannedinavian, #haskell.es, #haskell.it, #gentoo-haskell, #haskell-overflow, #flippi, #haskell-blah, #haskell and #ScannedInAvian
18:41:27 <dons> mbot, @part
18:41:38 <dons> it ignores me time and time  again
18:41:45 <Korollary> Are the icfp entries of previous years online somewhere?
18:42:01 <vincenz> @eval
18:42:01 <dons> Korollary, some are. depends on the team
18:42:02 <mbot> <stdin>: hGetLine: end of file
18:42:02 <lambdabot> <stdin>: hGetLine: end of file
18:42:22 <dons> should be caught, good poitn vincenz 
18:42:32 <vincenz> no I was curious how to remove the fptools plugin
18:42:40 <dons> and i just get back from holiday, now so much work to do :(
18:42:43 <vincenz> he
18:42:54 <dons> vincenz, ah easy. edit config.mk remove it from the list of plugins
18:42:58 <vincenz> http://rafb.net/paste/results/nWxSPl82.html
18:43:03 <dons> in fact, Code isn't in there by default
18:43:14 <vincenz> which is it tho
18:43:17 <vincenz> ah ok
18:43:36 <dons> thats a ghc 6.4 ism. update to 6.4.1 or turn off -Werror
18:43:45 <vincenz> yep
18:44:15 <vincenz> compiling
18:49:29 <vincenz> hmm
18:49:32 <dons> long weekends are good, lots of new haskell projects get hacked on
18:49:36 <vincenz> ;0
18:49:58 <dons> (some really cool things got announced in the last couple of days)
18:50:09 <vincenz> like what?
18:50:36 <jip> like my devlog!
18:50:36 <dons> wait till the HWN comes out later today...
18:50:46 <dons> jip,  more info?
18:51:07 <jip> dons: http://www.mutantlemon.com/omegagb/devlog
18:51:14 <vincenz> dons: oasisbot is on
18:51:22 <jip> another update coming in a few hours btw
18:52:13 <vincenz> @help repo-add
18:52:13 <mbot>  @help <command> - ask for help for <command>
18:52:14 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
18:52:15 <vincenz> heh
18:52:20 <vincenz> why doesn't she know about it
18:52:35 <dons> vincenz, not on in lambdabot by default
18:52:44 <vincenz> but I added it to oasisbot
18:53:20 <dons> and then cleaned ; reconfigured and rebuilt?
18:53:26 <vincenz> ah...added to dynamics
18:53:27 <vincenz> might be that
18:53:45 <mux> @pl \¢ s -> not (elem c s)
18:53:45 <lambdabot> (line 1, column 2):
18:53:45 <lambdabot> unexpected "\162"
18:53:45 <lambdabot> expecting pattern
18:53:45 <mbot> (line 1, column 2):
18:53:45 <mbot> unexpected "\162"
18:53:45 <mbot> expecting pattern
18:53:46 <vincenz> and lambdabot doesn't actually stop running if you @quit
18:53:53 <vincenz> nm
18:54:09 <dons> vincenz. hmm. what about ^C ?
18:54:15 <vincenz> no got it...
18:54:19 <vincenz> but in non online mode
18:54:25 <vincenz> ^C makes it just idle
18:54:30 <dons> hit it twice
18:54:31 <vincenz> it just took a bit for @quit
18:54:45 * vincenz recompiles lambdabot with DarcsWatch added to STATICS
18:55:09 <dons> ah yes. it should be in both, since it builds a static version by dflt
18:55:20 <dons> can you add this to the commentary?
18:55:31 <dons> and anything else you have worked out, but wasn't documented?
18:55:42 <vincenz> commentary?
18:55:54 <vincenz> ah ok
18:55:58 <vincenz> haskellwiki
18:56:12 <vincenz> lambdabot is one serious bot
18:56:20 <vincenz> I doubt there's any bot around with this much powa
18:56:46 <dons> no no. not the wiki. the COMMENTARY file
18:56:48 <dons> in the src
18:56:49 <vincenz> oh!
18:56:59 <mux> ?pl \¢ s -> not (elem c s)
18:57:00 <lambdabot> (line 1, column 2):
18:57:00 <lambdabot> unexpected "\162"
18:57:00 <lambdabot> expecting pattern
18:57:03 <mux> hmpf
18:57:10 <dons> vincenz: yeah, I wonder. it does some really sophisticated things (research -paper worthy)
18:57:24 * mux wonders what's going on
18:57:26 <dons> mux, hmm. interesting.
18:57:36 <dons> i wonder does it work in new ghc's?
18:57:48 <dons> i.e. the ones that support unicode
18:58:02 <mux> ahaha
18:58:07 <mux> I didn't meant to type that
18:58:13 <mux> ?pl \c s -> not (elem c s)
18:58:14 <lambdabot> (not .) . elem
18:58:18 * mux rubs eyes
18:58:26 <mux> evil
18:58:44 <vincenz> \a b c -> not (elem a b c)
18:58:49 <vincenz> @pl \a b c -> not (elem a b c)
18:58:50 <lambdabot> ((not .) .) . elem
18:58:50 <mbot> ((not .) .) . elem
18:59:09 <vincenz> I see a pattern
18:59:36 <dons> the (f .) style is often used by @pl. it takes a while to get used to
18:59:49 <dons> i.e. (f .) . g
18:59:50 <vincenz> if' is even more evil
19:00:06 <vincenz> @pl \x -> if f x then g x else h x
19:00:07 <mbot> ap (liftM2 if' f g) h
19:00:07 <lambdabot> ap (liftM2 if' f g) h
19:00:07 <dons> nah, just short hand for if' p e1 e2 = if p then e1 else e2
19:01:29 <vincenz> odd
19:01:31 <vincenz> still no DarcsWatch
19:01:47 * vincenz grumbles
19:01:48 <vincenz> n
19:01:49 <vincenz> m
19:02:08 <dons> does it appear in @list ?
19:02:17 <vincenz> I changed config.mk
19:02:19 <vincenz> and then configure
19:02:26 * vincenz shoots himself
19:02:29 <vincenz> blegh tired
19:02:53 <dons> hehe, the best signature around:
19:02:54 <dons> "Seth Kurtzberg
19:02:56 <dons> (36 commercially deployed Haskell programs, and counting)"
19:03:01 <dons> sethk ^^ :)
19:03:14 <sethk> dons, be 37 tomorrow 
19:03:50 * dons is very happy about all this sethk hacking
19:04:35 <sethk> my definition of "program" is perhaps a bit generous  :)
19:04:44 <dons> so some short things?
19:04:46 <vincenz> sethk: you wrote those 37?
19:04:56 <sethk> naturally
19:04:59 <vincenz> got a link
19:05:18 * vincenz is trying to figure out a way for multiperson darcs-push
19:05:23 <vincenz> shell accounts?
19:05:35 <vincenz> dons: we want to have each have their own darcs repo
19:05:37 <vincenz> and then one central one
19:05:38 <dons> vincenz?
19:05:43 <dons> right. that works nicely
19:05:45 <vincenz> right
19:05:49 <vincenz> bt how to give access to central one
19:05:50 <dons> and you use either Daan's darcs-cgi thingy
19:05:56 <dons> or have ssh accounts on the central box
19:06:03 <dons> one for each user
19:06:09 <vincenz> ssh account is most likely easiest
19:06:16 <dons> yep
19:06:24 <vincenz> is it possible to limit use of ssh to darcs only?
19:06:37 <dons> hmm
19:06:47 <dons> restrict the login shell, yes?
19:06:52 <vincenz> yep
19:06:59 <dons> i.e. the login shell only provides 'darcs apply'
19:07:14 <dons> soi it would be possible, but probably not worth it.
19:07:32 <dons> i don't know. maybe it woudl be worth it.
19:07:42 <dons> but then you may as well use the darcs-cgi server by daan instead
19:07:45 <vincenz> true
19:07:46 <dons> since all that stuff is worked otu
19:07:52 <vincenz> except I'm horrible with cgi and apache
19:08:06 <vincenz> dons: reg on the page, and put desired tasks
19:08:31 <vincenz> a task list can be found below
19:08:32 <vincenz> of typical things
19:08:40 <vincenz> and is obviously extensible
19:08:43 <vincenz> if you think of anything else
19:09:16 <jip> check out the latest dev image:
19:09:16 <dons> yep.
19:09:17 <jip> http://www.mutantlemon.com/omegagb/devlog/images/omegagb-0002.png
19:09:26 <dons> ah, this is omega?
19:09:26 <vincenz> jip: nice
19:11:00 <dons> jip, is this the thing that someone was asking about ghci errors on on the mailing list? (try to parse that sentence)
19:11:09 <jip> dons: no
19:11:22 <dons> oh, some other 'omega' written in haskell?
19:11:30 <dons> that i've never heard of.
19:11:46 <jip> this is the in development "OmegaGB" a gameboy emulator written in haskell
19:11:57 <vincenz> woo
19:11:58 <vincenz> repo tracking
19:12:07 <dons> right. excellent. do you have a main page link?
19:12:17 <dons> so i can add it to the libraries_and_tools page of haskell code?
19:12:32 * vincenz goes to sleep
19:12:34 <jip> dons: hm.... it's not really a library or a tool. it's more like a cool_app :)
19:12:43 <dons> yep. we have cool aps too
19:12:52 <dons> i.e. in the OS section
19:13:07 <dons> (the idea is to document pretty much everything)
19:13:14 <dons> and this is the first emulator i know of
19:14:41 <dons> jip, you might want to use mmapFile from fps to load large roms into memory quickly
19:14:45 <dons> or possibly slurpFile
19:15:07 <dons> then files > 1G would be possible... :)
19:15:12 <jip> dons: yeah, i looked at fps. it looks good
19:15:36 <dons> secondly, your blog looks highly suitable for posting on planet.haskell.org ...
19:15:49 <dons> you can just pass the url to ibid (is there an rss feed)?
19:15:54 <dons> and he'll add it.
19:16:28 <dons> thirdly, does omegaGB use hs-plugins!?
19:16:31 <dons> and if so, how?
19:16:36 * dons is fascinated
19:17:31 <jip> dons: http://www.mutantlemon.com/omegagb
19:17:41 <jip> dons: I am keeping a very detailed develpment log
19:17:50 <dons> jip, 4thly, that machineCpuExecute function looks like it should be a monad?
19:18:01 <dons> to handle the threading of RegisterStates automagically
19:18:46 <dons> i.e. a Hardware monad :) machineCpuExecute :: ExecutionAST () -> Hardware ()
19:19:14 <dons> where the Hardware monad is a state monad carrying aroudn your MemoryModel m and RegisterStates
19:19:17 <jip> dons: possibly, but i think there might be a limitation in haskell's type system that would prevent the memory from being a typeclass
19:19:28 <dons> no. you'd use an existential type
19:20:40 <jip> what advantages are there to using a monad?
19:20:54 <dons> data Hardware = Hardware { memory :: Memory , registers :: RegisterStates }   ; data Memory = forall m . MemoryModel m => M m
19:20:59 <dons> something liek that
19:21:19 <dons> oh, you no longer have to remember to pass, and return each new version of the state
19:21:24 <dons> its done mechanically
19:21:26 <dons> so less bugs
19:21:51 <dons> so, lets see: WriteRegister reg n -> ((setRegState regS reg n, memS), ())
19:22:11 <dons> becomes: withRegisters $ \r -> setRegState regS r n
19:22:20 <dons> and you don't mention things you dont' use anymore
19:22:32 <dons> actually, itd be
19:22:38 <dons> setRegState regS n
19:23:05 <dons> all that threading of state values around is abstracted over.
19:24:00 <jip> yeah, this is powerful stuff, but machineCpuExecute doesn't need to do a lot of threading, it only has an old state and a new state. also, it's a short function that's done and works. it won't ever have to be extended anymore
19:24:08 <dons> sure.
19:24:17 <dons> if you had to do lots of instructions, i'd write a moand.
19:24:20 <dons> or had to write it again
19:24:41 <jip> but that's sort of what i did i thin
19:24:43 <dons> the 'Return' and 'Bind' hints that it is really a monad
19:24:54 <jip> i am using a monad
19:25:00 <dons> you've basically written an interprter for >>= and return
19:25:20 <jip> yeah and i make it a monad instance so i can use do notation in executeInstruction
19:25:48 <dons> ah yes, the ExecutionAST 
19:25:53 <araujo> dons, hiya!
19:26:01 <dons> hey araujo
19:26:19 <araujo> dons, how you doing? 
19:26:49 <dons> good. just got back from 3 days of bush walking and rock climbing, so feeling refreshed
19:26:59 <dons> and then people send me 10 bug reports :}
19:28:03 <dons> jip, so I think I probably wouldn't bother with the Return and Bind
19:28:15 <dons> seems kind of heavy. let me see if I can code up an alternative
19:28:31 <araujo> hah
19:29:25 <jip> dons: the bulk of the code is in executeInstruction, as you can see in http://www.mutantlemon.com/omegagb/devlog/snapshots/20060414/Cpu.hs
19:31:55 <dons> cool. looks good
19:33:05 <jip> dons: it can probably be shortened a lot by factoring out common operations, but i kind of like how it's verbose, each instruction's operation is easily understood
19:37:14 <dons> anyway, yep. it looks good . very cool
19:37:24 <dons> you might want to look at the hardware monad paper.
19:37:27 <dons> let me find it
19:39:24 <jip> cool thanks
19:40:11 <sethk> dons, do you happen to remember how you refer to a function key in a vim macro, (in an nmap command?)
19:40:27 <dons> ok, here's the docs, jip: http://www.cse.ogi.edu/~hallgren/House/kernel/Hdoc/
19:40:59 <dons> hmm. sethk, like this? :map <F5> :set hls!^M
19:41:14 <dons> where that is a literal < F 5 and >
19:41:46 <jip> dons: hm... that looks like sweet stuff
19:41:55 <toast> how do i use map{}
19:42:19 <dons> > map (+1) [1..5]
19:42:20 <lambdabot> [2,3,4,5,6]
19:42:23 <mbot> [2,3,4,5,6]
19:42:28 <dons> > map toUpper "haskell"
19:42:29 <lambdabot> "HASKELL"
19:42:31 <mbot> "HASKELL"
19:42:54 <toast> > map (:) [1,2,3,4]
19:42:55 <lambdabot>  add an instance declaration for (Show ([a] -> [a]))
19:42:55 <mbot>  add an instance declaration for (Show ([a] -> [a]))
19:43:04 <dons> jip, I think this is the paper: http://www.cse.ogi.edu/~hallgren/ICFP2005/
19:43:08 <toast> > map ('f') [1,2,3,4]
19:43:09 <lambdabot> Couldn't match `a -> b' against `Char'
19:43:09 <mbot> Couldn't match `a -> b' against `Char'
19:43:15 <dons> "
19:43:17 <toast> > map (+2) [1,2,3,4]
19:43:17 <dons> We describe a monadic interface to low-level hardware features that is a suitable basis for building
19:43:18 <lambdabot> [3,4,5,6]
19:43:19 <mbot> [3,4,5,6]
19:43:21 <dons> operating systems in Haskell. The interface includes primitives for controlling memory management
19:43:24 <dons> hardware, user-mode process execution, and low-level device I/O. The interface enforces memory safety
19:43:27 <dons> in nearly all circumstances."
19:43:41 <dons> jip, which sounds like what you're up to, in some ways, no?
19:43:58 <sethk> dons, that's house, right, you are quoting from?
19:44:10 <dons> yep
19:44:21 <dons> the house paper from last year's icfp conference
19:44:22 <toast> mapf ?
19:44:47 <dons> toast, what would map 'f' do?
19:44:52 <dons> ?type map
19:44:53 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
19:45:03 <dons> map takes a function from a -> b as its first argument
19:45:14 <dons> so 'f' isn't going to work there
19:45:25 <dons> ?type \_ -> 'f' -- would work
19:45:27 <lambdabot> forall t. t -> Char
19:48:19 <toast> \n (x:xs) = if (x == 1) then xs else xs:x
19:48:23 <toast> > \n (x:xs) = if (x == 1) then xs else xs:x
19:48:24 <lambdabot>  parse error on input `='
19:48:25 <mbot>  parse error on input `='
19:51:16 <toast> ;p
19:52:49 <jip> dons: that paper is really interesting. but what i'm doing is much simpler. i don't think that gameboy is powerful enough to run an operating system. it only has a handful of IO ports
19:58:07 <sethk> if I use the record syntax   data Xyz = Xyz { foo :: Int }    can I later refer to it as    Xyz 1 as if I had done  data Xyz = Xyz Int  ?
19:58:21 <Korollary> yes
19:58:37 <sethk> Korollary, thanks
19:59:51 <dons> jip, sure. just thoguht it might give you some ideas
20:04:00 <jip> yeah it looks interesting
20:05:05 <sethk> a Chan guarantees atomicity, correct?  I can have one thread write to the Chan and another reading without using a semaphore or some such sync object?
20:05:21 <dons> yep. its over the top of an MVAR
20:05:29 <dons> (its an MVar [a] , iirc)
20:05:39 <sethk> dons, thanks.  
20:14:04 <sethk> dons, I have a pair of things, one an MVar, and one a channel, that are logically connected.  (The MVar could probably be a plain IORef.)  I've created a semaphore to coordinate modifications.  Should I be using STM.Tchan instead?  I'm not quite sure how STM is intended, but it appears to allow an atomic series of operations.
20:14:15 <toast> is there a while () or something similar in haskell
20:15:00 <sethk> toast, you do that in a different way
20:15:24 <sethk> toast, typically with a tail recursive function
20:18:55 <sethk> dons, forget that question for the moment, I have a more important one.
20:19:19 <sethk> dons (or anyone), can you explain this?  I think I can but my explanation is contrary to what I thought would happen
20:19:54 <sethk> I have a record type, call it Foo.  One of it's values is an MVar, call it foomv.  If I do this:
20:20:04 <sethk> xyz thing =
20:20:21 <sethk>     let abc = (foomv xyz)
20:20:30 <sethk>     in ... do something with the MVar
20:20:39 <sethk> I get different results than if I do this:
20:20:59 <sethk> well, if I do the same thing but the (foomv xyz) is not in a preceding let clause
20:21:41 <sethk> with the MVar in the let ... in do    (the MVar in the ...), the first time the function is called it does what I expect, but in subsequent calls, the contents of the MVar are not current
20:21:48 <sethk> e.g.
20:22:06 <sethk> I test it for isEmptyMVar.  I call the function, empty it, and call the function again.
20:22:09 <dons> you're not returning the modified MVar into the structure?
20:22:15 <sethk> no
20:22:19 <sethk> but I'm not in either case
20:22:39 <dons> can you post the code?
20:22:46 <dons> sounds liek something simple. 
20:22:48 <sethk> yes, that would be better. 
20:23:06 <sethk> dons, I got around the problem just by changing the code around, but I'm not sure I understand what's going on.
20:23:27 <dons> also, I usually use withMVar, so I get a syntactic view of the atomicity
20:23:38 <dons> withMvar (foomv xyz) $ \v -> tweak v
20:27:01 <dons> sorry, that should be modifyMVar_
20:29:42 <sethk> dons, http://paste.ubuntu-nl.org/12418
20:33:44 <dons> looking..
20:35:04 <dons> looks ok to me: 
20:35:08 <dons> $ ./a.out 
20:35:08 <dons> empty=True
20:35:08 <dons> empty2=True
20:35:08 <dons> empty=False
20:35:08 <dons> empty2=False
20:35:10 <dons> ?
20:35:32 <sethk> that's not what happened in the context of the large program.
20:35:44 <dons> hmm. maybe something else was going on then.
20:35:48 <sethk> must be
20:35:51 <dons> something was takeMVar'ing ?
20:36:10 <dons> be careful with your mutable variables :)
20:36:12 <sethk> yes, and after that, the one using let did not change
20:36:23 <sethk> but (dsync state) was correct
20:36:26 <sethk> maybe I had a name clash
20:36:58 <dons> could be. its not too uncommon to have let state = CSstate { dsync = mymv } mess with some previous "state"
20:37:04 <dons> or to return "state" instead of "state'"
20:37:20 <dons> -Wall would spot shadowing issues
20:37:25 <sethk> it wasn't anything that simple
20:37:30 <dons> ok
20:37:50 <sethk> -Wall turns on something that I can't get rid of.  I forget what.  But I can use the warn option specifically for shadowing
20:38:43 <dons> I would usually wrap the whole structure in an MVar and pass that around. unless there are parts of the structure that are immutable
20:39:33 <dons> but you know what you're doing, I suspect.
20:40:11 <sethk> dons, I think so, at least mostly.  Plus, the (dsync state) form works, so the structure I'm passing in is intact
20:40:12 <dons> ;)
20:40:19 <dons> ok. 
21:10:31 <jip> *boing*
21:10:39 <dons> ?yow
21:10:40 <lambdabot> HUGH BEAUMONT died in 1982!!
21:20:57 <bobwhoops> Hi, I'm trying to write a max function to operate on a list using foldr. However, I'm unsure what function I should pass to foldr. Is there some maxoftwoints function I can use, or do I have to write my own?
21:21:34 <Cale> max
21:21:38 <Cale> @type max
21:21:39 <lambdabot> forall a. (Ord a) => a -> a -> a
21:21:41 <mbot> forall a. (Ord a) => a -> a -> a
21:21:51 <Cale> mbot: @part
21:21:56 <Cale> mbot: @part #haskell
21:22:16 <bobwhoops> Aha, thanks
21:22:23 <bobwhoops> Hey, you're from #math :)
21:22:26 <Cale> yes
21:24:24 <dons> ah. silly me
21:24:39 * dons edits the System plugin for error msgs
21:26:17 <dons> mornign Cale
21:26:29 <Cale> morning dons
21:41:53 <palomer> ok, guys, got this, I just changed 300 lines of code and it simply works
21:42:01 <palomer> I don't understand
21:42:27 <jip> OmegaGB Devlog updated! http://www.mutantlemon.com/omegagb/devlog/
21:42:53 <Cale> palomer: only 300?
21:43:01 <Cale> :)
21:43:19 <palomer> in C++!
21:43:33 <palomer> more than 300, 500
21:44:13 <Cale> ah
21:44:30 <dons> in C++, surely you jest?
21:44:38 <Cale> bobwhoops: you might also want foldr1
21:45:44 <palomer> I kid you not!
21:45:49 <palomer> and it was a total design change
21:45:50 <Cale> bobwhoops: (It's unlikely that you can provide a reasonable replacement for [], since in general there's no minimum value to use)
21:46:09 <palomer> from an object oriented hierarchy to union types
21:46:24 <Cale> palomer: what are you writing in C++?
21:46:30 <palomer> a game
21:46:45 <Cale> oh, cool
21:46:49 <Cale> what's it about?
21:47:08 <palomer> it's to learn to play the piano
21:47:09 <palomer> it's fun
21:47:24 <palomer> it's a ripoff of doremi
21:48:35 <palomer> though I ascertain that  I came up with the idea first!
21:48:43 <palomer> actually, that's not possible
21:48:49 <palomer> ok, I came up with the idea independently
21:54:06 <adu> palmer: can you help me with my GUI?
21:54:42 <sjanssen> jip: so GHC is really updating your arrays in place?
21:54:49 <sjanssen> it can do that!?
21:55:20 <palomer> adu: if you ask a specific question I may
21:55:29 <palomer> (I just arrived)
21:56:00 <adu> palomer: n/m i was just jealous
21:56:29 <palomer> jealous of what?
21:57:11 <adu> cuz i have lots of interdependant parts in my GUI, and i have to write lots of code between compilable states, and i usually get lots wrong or miss a namespace orsomething...
21:57:21 <adu> i wish i could get it right the first time :)
21:57:25 <dons> sjanssen: what kind of arrays? MArrays?
21:57:30 <dons> or normal Arrays
21:57:35 <jip> sjanssen: i'm pretty sure, it's hard to be certain though
21:57:43 <sjanssen> dons: UArray
21:57:50 <palomer> don't worry guys, I'll be coding in haskell in a few days
21:57:51 <palomer> don't fret
21:58:00 <araujo> adu, what tools are you using for GUIs?
21:58:25 <adu> araujo: right now, Python, PyOpenGL and Pygame
21:58:28 <sjanssen> palomer: good.  we don't like apostates
21:58:31 <adu> but i don't plan to keep it in python
21:58:34 <dons> IOUArrays, are. i.e. the MArray instance for Data.Array.Unboxed
21:58:41 <araujo> adu, mm.. wait... isn't this the Haskell channel?
21:58:43 <dons> so maybe that's what jip's up to
21:58:43 <araujo> :-)
21:58:49 <adu> araujo: yes, i like haskell
21:59:21 <adu> araujo: i take that back, i adore haskell
21:59:42 <palomer> I apostate on a weekly basis
21:59:47 <adu> just have lots of trouble using it because of my non-FP mindset
22:00:05 <palomer> and yes, I'm using that adjective as a verb
22:01:27 <Korollary> gah. Why does Text.Printf.printf pad 'always'?
22:02:07 <adu> araujo: i might try doing something in the haskell opengl bindings tho
22:02:45 <adu> palomer: i thougt apostate was a noun...
22:03:46 <araujo> adu, ive heard they are pretty cool
22:03:55 <araujo> i should give it a try someday
22:04:47 <araujo> @yay!
22:04:59 <lambdabot> Unknown command, try @list
22:05:51 <jip> i did an interactive 3d car physics demo using yampa and opengl:
22:05:54 <jip> http://img145.imageshack.us/img145/7513/drivedrive0020dn.png
22:08:36 <jip> anyway, i gotta get to bed
22:10:39 <adu> wanna see my gui so far?
22:10:48 <sethk> if I use unsafePerformIO in the way that is illustrated in the documentation for Control.Concurrent (near the end where it describes how to maintain a list of active threads), what risks are associated with this?
22:11:51 <adu> http://img88.imageshack.us/img88/8840/picture14zu.png
22:13:10 <palomer> oh my
22:13:50 <adu> o my?
22:14:11 <palomer> adu: apostasy is the noun
22:15:07 <dons> sethk, should be ok. the rules are: you can't use it safely when you can't imagine an alternative purely functional implemenetation. 
22:15:37 <dons> i.e. there's no way to do it in a purely functional manner, then its going to be unsafe to wrap a IO think and pretend its pure
22:16:09 <dons> i think that's the rule of thumb that's employed.
22:16:15 <adu> palomer: there is no verb form of 'apostate'
22:16:19 <dons> it would be nice to see a proof though.
22:16:21 <sethk> dons, Well, I can imagine one.  I'm coding a request handler function from our ClientServer thing, so I can't pass it in as an argument
22:17:01 <sethk> dons, unless there is something tricky that I'm overlooking, I don't see a way around that
22:17:41 <dons> why would you need to use unsafePerformIO to implement the request handler?
22:17:47 <dons> wasn't that in IO already?
22:17:57 <sethk> not to implement the handler, to get data to the handler
22:18:09 <sethk> the signature of the request handler is fixed
22:18:17 <palomer> adu: yes, which is why I pointed out my heresy
22:18:20 <dons> want to paste a code fragment?
22:18:33 <dons> where is the data coming from?
22:18:43 <sethk> dons, it's basically state data
22:19:10 <dons> i'm a bit surprised. i would have thought this'd just be done in IO as per usual
22:19:18 <sethk> how?
22:19:29 <sethk> the signature of the request handler is fixed by our class, right?
22:19:39 <sethk> so I can't pass the information in with an argument to the function
22:20:02 <sethk> Of course I can just not reuse that code and use a request handler function with another argument
22:20:19 <dons> hmm. the request handler needs this static data?
22:20:28 <sethk> right.  and it doesn't come from the client
22:20:35 <dons> ok. sounds fine.
22:21:13 <dons> the data is coming from the configuration files?
22:21:33 <sethk> in this particular case the data is from bar codes, but it comes up in other situations
22:21:44 <dons> and its immutable?
22:22:05 <sethk> no, not necessarily
22:22:52 <dons> hmm. can I see this handler code?
22:23:05 <sethk> sure, in about 10 minutes.  I'm still writing it.
22:23:07 <dons> (its probably ok, but maybe there's an easier way)
22:23:29 <sethk> I was thinking there might be something tricky with partial application that would get around it.
22:23:39 <sethk> I'll paste it when it's more or less readable.
22:23:49 <dons> right. that's what I was thinking. some partial application
22:24:15 <sethk> actually, I'll post another one.  I'll post the file, but the handler is only a few  lines.
22:27:44 <adu> is there much in the way of RTTI in haskell?
22:27:47 <sethk> dons, http://paste.ubuntu-nl.org/12425
22:28:00 <sethk> dons, look at localHandleRequest, it is almost at the end
22:28:11 <sethk> dons, that paste has the request/response file at the end
22:28:26 <dons> looking..
22:28:32 <sethk> dons, that's the only part of that c/s interface that's implemented yet
22:28:44 <sethk> dons, I'm going to run out with the dog, be right back.  Thanks for looking at it.
22:30:26 <adu> who coined "combinator"?
22:30:47 <lispy> adu: afaik, there is no rtti in haskell
22:31:00 <lispy> adu: from what i can tell it pretty much all just compiles away
22:31:13 <adu> lispy: ok
22:31:16 <adu> thanks
22:31:23 <lispy> adu: although, it seems that there are .hi files with ghc that tell the compiler how things can be linked together
22:31:46 <lispy> adu: so i guess it keep some information around for later linking and whatenot
22:32:06 <adu> lispy: i'm thinking I might be able to use some kind of polymorphism somehow, maybe
22:32:39 <lispy> yes polymorphism is used quite extensively in haskell
22:32:57 <lispy> map is polymorphic in several ways for examlpe
22:33:01 <lispy> @type map
22:33:02 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
22:33:18 <lispy> the function type can vary as well the element types
22:39:20 * gvdm points to topic and asks "Why not just "Fun in Function"?"
22:40:59 <dons> we like to be funky?
22:42:06 <adu> always funky
22:42:35 <dons> sethk, looks ok, I think.
22:44:56 <sethk> good, thanks
22:45:06 <sethk> it's contained
22:58:38 <newsham> who was the one asking about formal declaration syntaxes?
23:00:58 <newsham> @seen mahogny
23:00:59 <lambdabot> Last time I saw mahogny was when I left #flippi, #gentoo-haskell, #haskell, #haskell-blah, #haskell-overflow, #haskell.es, #haskell.it and #scannedinavian 4 days, 16 hours, 31 minutes and 28 seconds
23:00:59 <lambdabot> ago, and .
23:01:05 <lispy> newsham: was your spidey sense tingling? ;)
23:01:15 <newsham> no.  whats up?
23:01:26 <lispy> newsham: it's just the way you asked the question
23:01:45 <lispy> newsham: as if you'd been summoned
23:01:49 <newsham> 14:36:35 <mahogny> question; is there some standard for writing formal requirements in haskell?
23:02:13 <newsham> I just ran across something I read before that might be what he wants
23:02:23 <newsham> anyone know how to contact him?
23:05:36 <newsham> ftp://ftp.cse.ogi.edu/pub/pacsoft/papers/Plogic.pdf  http://www.cse.ogi.edu/~dick/dick.html
23:20:43 <Lemmih> dons: around?
23:37:44 <newsham> dons never around :(
23:57:58 <maus> hello anyone
23:58:06 <maus> let me ask a question
23:58:27 * Lemmih lets maus ask a question.
23:58:50 <maus> i need to convert strings from one character set to another. In particular from CP866 to KOI8-R
23:59:21 <maus> what's the best way to do this?
