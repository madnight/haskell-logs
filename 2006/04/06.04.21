00:00:08 <toki2_0> is there a X11-interface for Haskell ?
00:00:45 <dons> yep, several
00:00:57 <toki2_0> shipped with ghc ?
00:02:02 <toki2_0> dons, please tell me some
00:06:19 <toki2_0> ok, ghc has one
00:07:13 <goltrpoat> why is it that while the obvious way to get haskell to be more "popular" or "production-friendly" is to put together some win32 and .net bindings, no one seems to be remotely interested in doing that
00:07:48 <goltrpoat> i mean.. what we have right now in that sense is fairly abysmal
00:08:00 <dons> we're not interested in being popular wit the win32 and .net crowd?
00:08:06 <dons> I'm not sure really.
00:08:13 <zamez> because people don't code to make a language popular, they code for fun :)
00:08:19 <Lemmih> We're trying to avoid success at all costs.
00:08:31 <Jerub> darcs is a big enough success, imho
00:08:50 <dons> must of the development of haskell comes from research, which are people who mostly use unix and code to push the pointy end of the language forward, not to broaden its base.
00:08:51 <Lemmih> Unfortunately, Haskell is so great that it's getting difficult.
00:09:56 <neologism> Lemmih: do you thin that darcs success is due its being implemented in haskell?
00:10:04 <goltrpoat> but.. broadening the base has obvious benefits, no?
00:10:30 <dons> sure , it does. i'm just explaining why this hasn't been done. we're too busy looking at the pointy end
00:10:42 <goltrpoat> oh right
00:10:43 <dons> to do mostly grunty work. i.e. writing large numbers of bindigns
00:11:12 <dons> the large number of haskell devs don't get paid to do non-original things
00:11:30 <goltrpoat> yeah that's total grunt work.  just seems like most of the grunt work has been done on the unix side, not the windows side
00:11:35 <dons> so the research tends to be on new stuff, not writing yet another win32 binding or yet another .net thingy
00:12:29 * PeterK is programming haskell on a windows machine
00:13:00 <dons> yeah, its pretty common these days. after all, ghc headquarters is funded by MS.
00:13:21 <dons> which helps a little with the win32 support.
00:13:34 <goltrpoat> oh i didn't realize it was actually directly funded by MS.
00:13:48 <eivuokko> Imo, win32 stuff is partly fault of the community, the response to anything win32 or non-GPL tends to be pretty horrible, often.
00:13:48 <dons> the research institute is. 
00:14:04 <dons> that too. politics
00:14:05 <goltrpoat> sort of makes sense, since i keep running into papers where i have to do a doubletake on the authors' affiliations
00:14:32 <goltrpoat> eivuokko:  -nod-
00:14:42 <Lemmih> neologism: I think complex applications benefit from being written in Haskell.
00:14:56 <goltrpoat> hehe
00:15:07 <neologism> Lemmih: yes.. but C equivalent of darcs would have exactluy the same success I think
00:15:15 <goltrpoat> unless it involves a gui on windows! :)
00:15:21 <neologism> do you know cvsup?
00:15:24 <neologism> (the program)
00:15:43 <Lemmih> neologism: David tried to write it in C++ but it got too complex.
00:15:51 <mlh> @pl \x y -> x y
00:15:52 <lambdabot> id
00:16:10 <neologism> well.. cvsup was written in modula3 and noone wanted to touch the code cause thelanguage was too obscure.. so it got rewritten in C
00:16:14 <eivuokko> Lemmih, that's not fair comparison, as David has said too, as it was his first attempt.
00:16:44 <kowey> there is an attempt at reimplementing darcs in ruby floating around out there
00:16:48 <dons> though haskell is surely not as obscure as Modula3. at least haskell is taught to thousands of uni students.
00:17:07 <dons> kowey: i don't think this will be a success. its a bizarre thing to do anyway.
00:17:07 <goltrpoat> i didn't even know there was a 3.
00:17:21 <kowey> dons: i think the guy who started it sorta gave up
00:17:24 <goltrpoat> i spent all these years safe in the knowledge that they stopped at 2
00:17:46 <neologism> dons: most of the students hate haskell ;)
00:18:08 <neologism> at my univ we have voluntary course which teaches haskell 8 students attend (out of ~200)
00:19:20 <dons> hmm. that's sad. there's around 70/ 500 here for the voluntary course. and around 30 for the adv. course.
00:19:32 <dons> depends on the uni, the teacher , etc.  i guess
00:19:39 <neologism> sure...
00:19:59 <neologism> its combined haskell/prolog course... and I think prolog scared some people away.. but still
00:20:00 <eivuokko> I don't know, but I wouldn't suprise if haskell was often like SICP and scheme in uni teaching.  Most people don't get it properly and hate it, some people get it and love it.
00:20:00 <goltrpoat> one of my partners, who seems to be enjoying haskell so far, said he absolutely hated miranda back in college (about 8 years ago)
00:20:06 <dons> anyway, who cares if they hate it. undergrads would happily code in a mixture of asm and perl all day long
00:20:23 <Lemmih> eivuokko: I'm not using Darcs to compare Haskell against C. I'm just stating my believe that Haskell is well suited for certain complex applications.
00:20:25 <goltrpoat> ML, as well.  enjoyed LISP.  go figure.
00:20:27 <dons> engineering isn't a popularity contest :)
00:20:38 <neologism> dons: I am undergrad ;)
00:20:41 <PeterK> my uni doesn't offer it, i'll have to independent study if anything.
00:20:42 <astecp> dons: well said
00:20:54 <PeterK> dons is right about that too :)
00:21:19 <goltrpoat> yah, it just seems weird that the same person would have polar opinions about if not the same language then the same approach, eight years apart
00:21:35 <neologism> people tend to hate what they are taught at univ
00:22:03 <Lemmih> neologism: Of course, a darcs written in C would be exactly as successful. However, writing and maintaining it would be a fair bit harder.
00:22:41 <neologism> the problem with haskell is that it has quite complicated "hello world" :)
00:22:46 <goltrpoat> a mixture of asm and perl.. hahah
00:22:50 <goltrpoat> just saw that
00:22:56 <PeterK> really neologism?
00:23:07 <PeterK> never mind
00:23:08 <goltrpoat> inline asm in perl.  that'd be just..  so fundamentally broken on so many levels.
00:23:16 <neologism> PeterK: compared to other languages yes
00:23:46 <goltrpoat> neologism:  ever try to write a "hello world" in 6502 assembly?
00:23:47 <dons> neologism: main = print "hello, world"
00:23:50 <goltrpoat> :)
00:23:51 <PeterK> how complicated is it?
00:23:58 <dons> doesn't seem to hold back java..
00:24:11 <PeterK> seems to be as complicated as C
00:24:13 <Lemmih> dons: s/print/putStrLn/
00:24:20 <dons> keep it simple :)
00:24:27 <neologism> dons: main = do name <- getLine; putStrLn ("Hello, " ++ name)
00:24:39 <neologism> most peoiple dont figure this out
00:25:14 <dons> @pl main = do name <- getLine; putStrLn ("Hello, " ++ name)
00:25:14 <lambdabot> (line 1, column 26):
00:25:14 <lambdabot> unexpected ";"
00:25:14 <lambdabot> expecting letter or digit, variable, "(", "`", "!!", ".", operator or end of input
00:25:40 <neologism> uh. whats wrong with that?
00:26:02 <dons> well, main = getLine >>= putStrLn . ("hello, "++)
00:26:14 <dons> not so hard. and at least as hard as perl or C. on any other imperative lang.
00:26:16 <PeterK> #include <stdio.h> int main() { char mystring[80]. getline(mystring); printf( "Hello, %s", mystring ); return 0; }..... i forgot if getline is the function, but C seems as complicated.
00:26:39 <neologism> dons: I saw my classmates
00:26:46 <neologism> they are not able to do it
00:27:00 <dons> its weird. people have raised this a few times over the years, but i don't understand why its troublesome.
00:27:17 <dons> ah well, they're not taught very well.
00:27:27 <goltrpoat> peterk:  if getline() were an actual function, you'd have yourself a buffer overflow vulnerability in your hello world
00:27:30 <goltrpoat> hehe
00:27:44 <PeterK> lol
00:28:05 * araujo can't think of anything that isn't well suited for Haskell
00:28:08 <araujo> hi!
00:28:29 <goltrpoat> araujo:  device drivers.
00:28:36 <araujo> goltrpoat, House!
00:28:38 <goltrpoat> on windows xp.
00:28:46 <dons> well, there are a few projects out there to write device drivers in haskell, since they end up with less bugs
00:28:59 <dons> or at least in an EDSL inside haskell
00:29:23 <PeterK> learning to program is hard...well for most people...i can imagine that people who aren't great programmers won't make great haskell programmers. i'd be scared if the excellent students in the imperative langauges could not pick up haskell with effort.
00:29:37 <dons> so, actually, all that boilerplate code in a device driver is kind of well suited to a higher level lang that can abstract over the gunk
00:29:47 <goltrpoat> i think you have to be a little bit of a mathematician and a little bit of a programmer
00:29:50 <pesco> @where HSDL
00:29:52 <lambdabot> I know nothing about hsdl.
00:30:06 <pesco> @where sdl
00:30:07 <lambdabot> I know nothing about sdl.
00:30:08 <kowey> i dunno, i'm a pretty mediocre programmer and i like haskell
00:30:17 <goltrpoat> i mean in terms of how your head works.
00:30:23 <pesco> Lemmih: Where'd you move your SDL binding?
00:30:26 <dons> and its often taught as a first programmign language.
00:30:30 <goltrpoat> usually, mathematicians make terrible programmers, and vice versa.
00:30:31 <dons> so, it can't be too hard.
00:30:37 <dons> like scheme is taught to school kids
00:30:38 <Lemmih> @where+ hsSDL http://darcs.haskell.org/~lemmih/hsSDL
00:30:39 <lambdabot> Done.
00:30:45 * araujo got a theory about Haskell being easier to learn than most imperative languages.
00:30:53 <neologism> why is lambdabot not able to parse/run this
00:30:56 <neologism> let foo = do name <- getLine ; putStrLn ("Hello " ++ name) in foo
00:31:03 <pesco> Lemmih: Yo, thanks!
00:31:03 <goltrpoat> it is easier to learn, but most people have to unlearn a lot by the time they try it for the first time
00:31:10 <goltrpoat> or.. that's the situation right now anyway.
00:31:26 * dons catches himself using t and t' in the shell, and wondering why it doesn't work.
00:31:46 <dons> neologism: it implements only a partial haskell parser
00:31:46 <Lemmih> neologism: Because it's IO?
00:31:51 <dons> no do notation
00:31:53 <Lemmih> > let foo = do name <- getLine ; putStrLn ("Hello " ++ name) in foo
00:31:55 <lambdabot> No IO allowed
00:32:41 <araujo> For example, weeks ago i met somebody who has never ever heard of Haskell, and he was able to write valid expressions in about five minutes after i explained him a few basic things.
00:32:41 <neologism> ah.. ok
00:32:56 <dons> @pl getLine >>= \name -> putStrLn ("Hello " ++ name)
00:32:57 <lambdabot> putStrLn . ("Hello " ++) =<< getLine
00:33:08 <dons> like I said :)
00:33:28 <Maddas> araujo: What's the theory?
00:34:11 <araujo> Maddas, Than a child can learn how to use Haskell quickly and more efficiently than other imperative language.
00:34:37 <goltrpoat> araujo:  equivalently, i've spent a good month trying to teach the basics to one of my partners -- who's a fairly brilliant programmer -- and he still asks me questions along the lines of "i have no idea what you just said, can you start from the beginning"
00:34:42 <araujo> Most of the haskell-is-dam-difficult arguments is because people is just too used to imperative stuff.
00:35:14 <araujo> goltrpoat, the person who i talked to was a programmer too.
00:35:31 <araujo> i was quite impressed how quick he grasps at it.
00:35:31 <PeterK> Do a double blind study and teach a random group of high school students Haskell and the other Pascal...both groups will find it difficult, likely.
00:35:34 <goltrpoat> my other partner, who has a fairly decent FP background, seems to be picking it up reasonably quickly.
00:35:36 <goltrpoat> go figure.
00:35:36 <Maddas> araujo: Right, though I think properly learning programming in general is hard.
00:35:52 <araujo> Maddas, that's subject for other theory i suppose :-)
00:36:01 <Maddas> Ok :-)
00:36:10 <mlh> is it just me or are the words 'hello' and 'world' missing from the hsapps hello world example
00:36:39 <Maddas> PeterK: That has been done, though I don't know whether with Haskell in particular.
00:37:01 <araujo> goltrpoat, oh i forgot to say, the guy was good at mathematics, probably that has helped
00:37:09 <mlh> HAppS I should say.  http://happs.org/HAppS/examples/hello.hs
00:37:19 <araujo> goltrpoat, the thing is that most of the obstacle for learning Haskell is the imperative thought.
00:37:38 <mlh> araujo: maybe
00:38:03 <Maddas> araujo: I think it's also that abstraction is very common in Haskell, and getting the hang of that kind of abstraction isn't easy.
00:38:04 <mlh> maybe it's that a lot of haskell code is at a higher abstract level
00:38:15 <Maddas> (:
00:38:32 <araujo> Maddas, i don't think so. It's like mathematics for example.
00:38:37 <Maddas> Yes, exactly.
00:38:52 <ulfdoz> Eigentlich müsste es schon reichen, wenn man ihm sagt, sich nicht an ein Terminal zu binden.
00:38:53 <araujo> childs already are or should be learning math
00:38:55 <ulfdoz> ECHAN, sorry
00:39:14 <mahogny> IMO if you have a good line of thought in imperative programming, going to functional programming is easy. but you are one of those that sit there with trial and error and hope something will show up on screen in java, then haskell is probably your worst nightmare
00:39:15 <neologism> araujo: have you ever talked to your classmates during math classes at univ? ;)
00:39:18 <araujo> That, without imperative pollution, should be a big help.
00:39:21 <astecp> abstraction can be performed naturally in a functional language. People with a history in imperative languages are used to having to constrain their abstractions to certain limited patterns.
00:39:30 <araujo> neologism, about?
00:39:36 <neologism> araujo: about the math
00:39:43 <neologism> most people have 0 math thinking
00:40:06 <araujo> neologism, mm.. well, im refering to childs here
00:40:16 <mlh> "children"
00:40:21 <araujo> that's it :-)
00:40:31 <mahogny> children learning FP? what age?
00:40:31 <neologism> uh... yes
00:40:50 <pesco> Lemmih: Hm, maybe you want to list it on the SDL site? They mention all the bindings there. Or is it not ready for "official" status?
00:40:53 <araujo> mahogny, i'd say 8-14
00:41:06 <mahogny> araujo, that's incredibly interesting. how does it work out?
00:41:29 <mlh> simple fp would be easier than simple imperative I suspect
00:41:36 <Lemmih> pesco: It doesn't work on Windows and is problematic on MacOS.
00:41:43 <pesco> Lemmih: Eek!
00:41:55 <pesco> Lemmih: How is that?
00:42:04 <araujo> mahogny, well, i would like to do the following. To offer a Haskell and some other imperative course.
00:42:25 <Lemmih> pesco: SDL on MacOS is evil and so is Windows (:
00:42:25 <Maddas> FWIW, I can recommend reading "The Structure and Interpretation of the Computer Science Curriculum"
00:42:34 <araujo> And let the children pick up the languag for a small final project
00:42:49 <pesco> Lemmih: No, seriously? And why is it evil on MacOS?
00:42:57 <araujo> Anbd compare what they choose, why, and how they generally do.
00:43:01 <mahogny> araujo, I would assume that you have a hell of a problem when it comes to more serious functions
00:43:04 <araujo> The theory is that Haskell could do better.
00:43:10 <Maddas> araujo: This has been done with two languages (not Haskell), the paper reports a few results.
00:43:22 <Lemmih> pesco: SDL on Mac wants to change your 'main' C function to 'sdl_main' so it can initialize Cocoa or something like that.
00:43:25 <araujo> mahogny, well, it'd be a small projecyt, probably some basic arithmetic stuff.
00:43:32 <Maddas> (They talk about the role of functional languages in teaching)
00:43:50 <mahogny> why would FP be easier to learn?
00:43:53 <pesco> Lemmih: UACH! What the fucking hell?
00:44:07 <araujo> Maddas, aha, yeah, i know of some languages , but not functionals, do you have a link?
00:45:03 <araujo> mahogny, imho, and would be one of the thing i'd be showing with the project, is that functional programming is a more natural way of reasoning for example.
00:45:36 <Maddas> They thought Scheme and C++ -- the students could choose one -- first, as a preparation to a course using Java later on (IIRC). "The Northeastern HTDP students received five times as many A's (best grade) as the C++ students" is one result :-]
00:45:40 <araujo> But if you try to say that to a +15 years imperative programmer, he will tell you you are a liar.
00:46:41 <araujo> interesting
00:46:45 <mahogny> araujo, my experience tells that your experiment will run into confidence problems. AFAIK the problem is seldom the core reasoning but the book keeping. if you have haskell with GC, a good system for Data etc and compare that to say C, then it will be hard to say that it is the imperative part that makes it harder to reason
00:46:48 <Maddas> araujo: Google for "The structure and interpretation of the computer science curriculum", I'm afraid I don't have any mouse here (to copy/paste)
00:47:08 <PeterK> Some philosopher said that the French language most naturally captured the sequence of thought. Probably true for him...
00:47:12 <mahogny> bbl
00:47:34 <araujo> mahogny, it'd be a matter of establishing a well defined guideline.
00:47:41 <Maddas> PeterK: Every language camp has tons of people saying things like that (in particular with programming languages) :-)
00:47:49 <araujo> Maddas, ok.
00:47:55 <Maddas> araujo: ;-)
00:48:10 <neologism> PeterK: I heard that about greek's language
00:48:18 <Maddas> I heard that about pretty much any language.
00:48:27 <Maddas> (Of course only by speakers of those languages..)
00:48:29 <Lemmih> pesco: And I don't know why it fails on Windows.
00:48:36 <pesco> Lemmih: Okay...
00:48:57 <Maddas> PeterK: That's why I'd think that it's a lot more important to focus on the properties of languages rather than on which particular language is used.
00:49:30 <Maddas> (And on the way it is taught -- a good language won't help if the teacher is bad :-)
00:50:15 <kolmodin> Lemmih: hi
00:50:48 <poltrgoat> note to self:  while i can run off the battery during the thunderstorm, that doesn't protect the router, the other router, the cable, or the coffee machine.
00:51:01 <Maddas> (When I mentioned that paper, I was referring to the 'educational pearl' version  -- not the other one Google brings up.)
00:51:26 <pesco> I suppose HGL doesn't support MacOS (native, not X)?
00:52:47 <Lemmih> kolmodin: Hiya. You asked for a link to my ghci debugging thingy.
00:53:32 <Lemmih> kolmodin: http://haskell.org/ghc, it's in ghc-6.5.
00:54:16 <norpan> w00t
00:54:22 <norpan> how does it work
00:54:25 <kolmodin> Lemmih: oh, thanks
00:55:20 <norpan> i have 6.5 just built
00:57:17 <Lemmih> norpan: Try running 'import GHC.Base; f a b = breakpoint $ a + b :: Int' from GHCi.
00:57:52 <norpan> can you do "import" in GHCi?
00:58:19 <Lemmih> norpan: :m
00:59:21 <norpan> ok, now I have f, then what
00:59:29 <Lemmih> Run it.
00:59:40 <norpan> it gives me a result
01:00:27 <Lemmih> Oh right, I can't quite remember if I disabled breakpoints by default...
01:00:34 <norpan> hehe
01:01:00 <xerox> 'morning
01:01:13 <norpan> i'll try it later
01:01:40 <Lemmih> norpan: You have to unpull the "Don't build GHC with breakpoint support by default." patch.
01:04:14 <Lemmih> norpan: It should jump out to GHCi with 'a' and 'b' in scope when you run 'f'.
01:35:49 <robokop> sb here who understands the function showModal from wxHaskell (it has someting to do with dialogs)
01:37:06 <kowey> if i recall correctly, there is a tiny bug in the haddock for that function
01:37:49 <kowey> oh, yeah, there's a window missing in the  d   <- dialog [text := "Demo"] bit, but that's likely not your question, is it?
01:44:45 <norpan> Lemmih: oh
01:45:08 <norpan> or maybe there is some configure options, seems complicated to have to unpull a patch
01:49:36 <Lemmih> norpan: Edit compiler/Makefile and add -DBREAKPOINT on line 409
01:49:47 <norpan> is there a good reason why this breakpoint support cannot be set during run-time?
01:50:46 <Lemmih> It can and it is with -fignore-breakpoints.
01:51:01 <norpan> oh, unset
01:51:18 <norpan> making stage2 now
01:51:47 <Lemmih> But my code might be buggy so I wrapped it in #ifdef BREAKPOINT.
01:53:28 <davidhouse> good morning all :)
01:54:14 <norpan> hmmm, i may have to make clean first
01:55:36 <Lemmih> norpan: Touching DsExpr.lhs and RnExpr.lhs should do it, I think.
01:56:45 <Lemmih> Oh and InteractiveUI.hs
01:57:05 <norpan> i have plenty of cpu cycles so I will do make clean :)
01:57:22 <norpan> i'm at work now anyway, so i can't play with it
01:59:14 <dcoutts> dons, I agree, I think Data.ByteString(ByteString) is good
02:00:11 <norpan> time to make String into a typeclass?
02:18:10 <xerox> re.
02:27:15 <musasabi> morning
02:32:30 <dons> Lemmih, whats the flag to turn off ! patterns?
02:32:46 <dons> dcoutts, ah good :)
02:33:28 <dons> got it: -fno-bang-patterns
02:34:18 <dcoutts> dons, so is the plan to keep ByteString using Char or to have it use Word8 and have a seperate newtyped Latin1 Char version and possibly also a UTF8 one
02:34:58 <dcoutts> dons, btw, I think it's perfectly ok for there not to be a proper indexing operation for variable width string encodings like UTF8,16
02:35:23 <dons> no, I don't want to have special Char8s or anything
02:35:38 <dons> but eventually I want to add the UTF8 and so on layers over the top
02:36:05 <dons> it has to be a nice user thing. and if you can't throw Chars at it, it'll be a pain to use
02:36:05 <robokop> sb here who understands the function showModal from wxHaskell (it has someting to do with dialogs)
02:36:15 <goltrpoat> how is it ok to not have proper indexing for variable width string encodings
02:36:15 <dcoutts> and the base one will use Char and not Word8?
02:36:29 <dcoutts> goltrpoat, because you can't really do it
02:36:33 <dons> oh, Word8 for the byte encodings, and other sizes for others.
02:36:46 <dons> the lib gets paramaterised by a CHARSIZE cpp macro
02:36:47 <xero1> Bang patterns?
02:36:53 <dons> !
02:36:56 <dcoutts> dons, ah ok
02:37:02 <xero1> Strict annotations?
02:37:25 <dons> yeup
02:37:34 <musasabi> I don't see why people are so intent on indexing things by a Char.
02:37:41 <dcoutts> you can only traverse UTF8 strings, you can't really index them (unless you happen to know they are Latin1 or keep a seperate index->offset mapping)
02:38:13 <musasabi> As combining marks + composite characters cause a situation where Char != logical character.
02:39:32 <dcoutts> musasabi, so you mean that even with UCS4 you can't index logical chars
02:39:44 <musasabi> yes.
02:41:16 <goltrpoat> i guess i misunderstood what you meant by "indexing".
02:41:22 <musasabi> Thus substrings become the important thing - not characters and for that one FPS works nicely. (of course it could use a layer of unicode things on top of it)
02:41:49 <goltrpoat> by indexing a utf8 string i mean indexing the nth byte.  i don't care what the character is, that's not what the query is.  it doesn't make sense to try and guess the encoding or pass a locale.
02:42:19 <goltrpoat> i think that's fairly standard behavior.
02:42:31 <dcoutts> goltrpoat, so you're treating it as a byte string
02:42:42 <goltrpoat> a separate locale mechanism can figure out an offset if that's desired.
02:42:46 <goltrpoat> right.
02:43:07 <musasabi> Like I said on the list one can use 1) byte based, 2) physical character based, 3) substring based. And my argument is that 1) and 3) are most important, while many people seem to want 2) instead of them.
02:44:29 <goltrpoat> substring based?
02:45:09 <musasabi> goltrpoat: doing most operations basically on substrings instead of invidual characters.
02:46:09 <goltrpoat> you mean actual substrings, beyond interpreting physical characters?  substring queries?
02:47:14 <dons> hmm. lines seems to be about 10x faster in ghc 6.6 than 6.4.2
02:47:25 <flux__> why?-)
02:47:26 <dons> must be the new ForeignPTr, I guess.
02:47:27 <Lemmih> Really?
02:47:33 <dons> lines in FPS, I mean
02:47:34 <Lemmih> Oh, in FPS.
02:47:55 <dons> most FPS functions get faster, though unpack got about 2x slower.
02:48:04 <dons> (perhaps the weird fusion optimisations break)
02:48:13 <eivuokko> Gotta love new ForeignPtr allocated heap memory, eh? :)
02:48:21 <dons> hehe
02:48:35 <dons> its not, like, so Foreign anymore :)
02:49:53 <dons> oh, and inits and tails are also about 10x faster.
02:50:20 <dons> these all take lots of substrings. hmm. very interesting.
02:50:21 <musasabi> goltrpoat: yes.
02:50:48 <flux__> someone, not long ago, complained about inits (or was it tails?) being much slower than a simple (albeit non-lazy) version, so this would help?
02:51:26 <goltrpoat> musasabi:  when do you need to query for substrings that aren't at the head of the string?
02:51:44 <musasabi> goltrpoat: for things like splitting and searching for things.
02:51:59 <Lemmih> flux__: That was about Data.List.inits.
02:52:00 <goltrpoat> why are those things a performance concern?
02:53:30 <goltrpoat> also, you sort of just answered my "when do you need to query for substrings" with "when i need to query for substrings" :)
02:54:17 <dons> flux__, yeah, as lemmih says. though the algorithms sometimes conincide, it wasn't possible in this case
02:55:56 <goltrpoat> substring search with a variable char size is nontrivial, highly application-dependent, highly encoding-dependent.  should be app-side.
02:56:28 <dons> ah good, : main = print . length . lines =<<  hGetContents stdin (using FPS) is exactly 2x slower than wc-l with ghc 6.6
02:56:50 <musasabi> dons: do you know why the ForeignPtr optimizations didn't make it to 6.4.2 ?
02:56:53 <dons> it was 4x with 6.4
02:57:03 <dons> hmm. there was some talk of it, wasn't there.
02:57:12 <dons> I wonder what happened with that. maybe they did?
02:59:00 <musasabi> dons: point, seems like something at least *is* in.
02:59:27 <vincenz> dons: got my patch?
03:00:01 <dons> musasabi: ok. maybe it made it. I haven't tested with a new enough 6.4.2 compiler
03:00:10 <dons> vincenz: yep. i'm still pondering this 'j' 'k' issue.
03:00:16 <dons> I like playPrev,
03:00:18 <vincenz> dons: I'm gonna extend it further...
03:00:22 <dons> but I still want j k to go up and down.
03:00:23 <vincenz> dons: such that there is a prerandomized list
03:00:25 <dons> so maybe J and K ?
03:00:31 <dons> ah, that might be good, yes.
03:00:33 <vincenz> dons: such that playPrev actually goes back along that randomized list
03:00:38 <dons> please proceed :)
03:00:51 <dons> i'll apply your patch in the morning
03:00:55 <vincenz> :)
03:01:19 <vincenz> I'll also add search cycling
03:05:35 <dons> yes, that would be good too.
03:05:39 <musasabi> Trying fps with 6.4.2 next.
03:08:03 <vincenz> @type bounds
03:08:05 <lambdabot> forall i e. (Ix i) => Array i e -> (i, i)
03:12:11 <dons> musasabi, you can use the 'make bench' target in the testsuite to get an idea of how everything is performing
03:12:21 <dons> change the size of the 'bigdata' file to your liking
03:12:25 <vincenz> hmm
03:12:33 <vincenz> how do I make a cyclic buffer in haskell
03:12:43 <dons> using % ?
03:12:48 <vincenz> ?
03:13:13 <vincenz> a bidirectional cyclic buffer
03:13:54 <vincenz> {past :: [a], future :: [a]} requires a reverse if you loop on either side
03:14:01 <musasabi> dons: testing on HAppS HTTP which has the functions I mostly care about. Results soon for that one.
03:14:13 <vincenz> > reverse [1..3000]
03:14:15 <lambdabot> [3000,2999,2998,2997,2996,2995,2994,2993,2992,2991,2990,2989,2988,2987,2986,2985,2984,2983,2982,2981,2980,2979,2978,2977,2976,2975,2974,2973,2972,2971,2970,2969,2968,2967,2966,2965,2964,2963,2962,
03:14:15 <lambdabot> 2961,2960,2959,2958,2957,2956,2955,2954,2953,2952,2951,2950,2949,2948,2947,2946,2945,2944,2943,2942,2941,2940,2939,2938,2937,2936,2935,2934,2933,2932,2931,2930,2929,2928,2927,2926,2925,2924,2923,
03:14:15 <lambdabot> 2922,2921,2920,2919,2918,2917,2916,2915,2914,2913,2912,2911,2910,2909,2908,2907,2906,2905,2904,2903,2902,2901,2900,2899,2898,2897,2896,2895,2894,2893,2892,2891,2890,2889,2888,2887,2886,2885,2884,
03:14:15 <lambdabot> 2883,2882,2881,2880,2879,2878,2877,2876,2875,2874,2873,2872,2871,2870,2869,2868,2867,2866,2865,2864,2863,2862,2861,2860,2859,2858,2857,2856,2855,2854,2853,2852,2851,2850,2849,2848,2847,2846,2845,
03:14:18 <lambdabot> 2844,2843,2842,2841,2840,2839,2838,2837,2836,2835,2834,2833,2832,2831,2830,2829,2828,2827,2826,2825,2824,2823,2822,2821,2820,2819,2818,2817,2816,2815,2814,2813,2812,2811,2810,2809,2808,2807,2806,
03:14:21 <lambdabot> [6 @more lines]
03:14:38 <musasabi> which of course has lots of other factors.
03:15:00 <vincenz> > take 1 $ reverse [1..10000]
03:15:02 <lambdabot> [10000]
03:16:59 <dons> will be interested to see how things go.
03:17:03 <dons> you using the very latest fps?
03:17:11 <dons> i've improved some functions even today.
03:17:34 <dcoutts> dons, nice ghc 6.6 + fps benchmarks
03:17:51 <dons> yeah, i'm really happy about it :)
03:17:54 <dcoutts> 2x faster than C :-)
03:18:12 <vincenz> where?
03:18:16 <musasabi> dons: Seems like something is slower with the new code, GHC 6.4.1 and 6.4.2 have about the same performance :-(
03:18:18 <dons> 2x slower ... :(
03:18:25 <dons> but that's still ok, compared to wc -l
03:18:28 <musasabi> Will look into it closer.
03:18:33 <dcoutts> dons, oh sorry I read that wrong!
03:18:42 <dcoutts> well it's still a 2x improvement
03:18:55 <dons> it was more the point that the 'naive' .hs using FPS was 2x C
03:18:56 <dcoutts> from 4x 5x slower to 2x slower
03:18:59 <dons> it didn't need super hacks
03:19:18 <dcoutts> right, like cunning blocking & buffering
03:19:18 <dons> yeah, 2x speedup just by changing compilers is pretty cool
03:19:36 <dons> or any weird primop/unboxed/foreign games :)
03:20:47 <dcoutts> it would be nice if ghc could do more C like optimisations so that we could write fast C style code rather than using C + FFI
03:21:00 <dcoutts> eg memchr etc
03:21:05 <dons> musasabi: just had a thought that there might be other new optimisaionts, like the better list comprehension/mapM code in 6.6 that's helping
03:21:38 <dons> dcoutts: yeah, we need a Data.Cish
03:21:43 <dons> for mutable vars, and similar
03:21:54 <dcoutts> dons, not necessarily mutable vars
03:21:59 <dons> much along the lines of those we hacked on during the shootout
03:22:21 <dcoutts> dons, eg some simple tail recursions should turn into loops with re-used var locations
03:22:21 <dons> ah, ok. well mutable vars was something we needed often to emulate imperative algos
03:22:30 <dons> yeah, that sometimes works
03:22:49 <dons> it worked really well in the bits and partial-sums code
03:22:54 <dcoutts> so the C version uses mutable vars but the functional version is nice recursion with constant space
03:23:04 <dons> right.
03:23:13 <dcoutts> and if that can be allocated into regs then it could get up to C speed
03:23:34 <dons> have a look at the partial-sums results. we're faster than C
03:23:36 <dons> ?shootout
03:23:37 <lambdabot> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
03:23:47 <dons> only fortran is better.
03:24:02 <dons> and its a big loop with lots of vars going around, as you describe
03:24:04 <dcoutts> that's impressive
03:24:38 <dons> this one: http://shootout.alioth.debian.org/gp4/benchmark.php?test=partialsums&lang=all
03:25:17 <goltrpoat> what freaks me about CLS a little bit is that i remember seeing msvc 2005 vs gcc benchmarks, with somewhat scary-looking (as in bad) results for gcc
03:25:36 <musasabi> dons: I see a slowup from 1800 to 1400 req/sec with fps 0.2 -> current. Any ideas how to search for the culprit other than profiling (but that seems to be bad for something like fps) ?
03:26:20 <musasabi> dons: this is consistent with both 6.4.1 and 6.4.2
03:26:34 <dons> hmm. so with the same compiler, only the version of fps changes?
03:26:55 <dons> I'd unroll the fps patches back to 0.2 until the problem goes away.
03:27:04 <dons> there's about 20 patches since 0.2
03:27:17 <dons> you can probably skip many doc and comment changes
03:27:25 <musasabi> Changing from 6.4.1 to 6.4.2 does not change the performance in noticeable ways, but the fps version does.
03:27:34 <musasabi> I'll try to look at the differences now.
03:27:52 <dons> right. its possible something happened. maybe its this slower unpack I noticed in my 6.6 code?
03:27:55 <sbeyer> hi
03:28:29 <dons> 1800 seems pretty good, btw :)
03:29:47 <musasabi> Building with profiling, will take some time.
03:30:22 <dons> no no, I'd just rerun you tests with different fps versions
03:30:58 <dons> start at 0.2, then pull patches until it gets slower.
03:31:18 <musasabi> hmm that works too.
03:31:40 <dons> i hardly changed anything though. hmm. tricky.
03:31:55 <dons> you using the cbits code, or not?
03:32:09 <musasabi> no cbits.
03:33:08 <dons> ok, either way, i'll need more info to proceed on this :)
03:33:29 <musasabi> I am doing the pull & benchmark method now.
03:36:44 <Lemmih> Bulat is kinda funny sometimes.
03:40:29 <vincenz> dons: how come ghc is so far behind
03:41:32 <dons> vincenz: ?
03:41:43 <dons> Lemmih, right.
03:43:31 <int-e> vincenz: in the shootout? two things have happened: people have optimized their programs some more, and the scoring was changed to not include the number of lines of code by default - they even replaced that metric by the number of gzip bytes.
03:43:42 <musasabi> dons: "BSD license everything. Remove some more cbits" is the guilty one.
03:44:37 <musasabi> dons: I am using the whitespace functions, I would guess they are the guilty ones.
03:44:40 <eivuokko> What's the best to get Cabal..1) use ghc split objs 2) to have two builds, one for user build and another for devel, where user shouldn't use .hsc, but preprocessed .hs etc, so that user doesn't need external libs?
03:45:52 <musasabi> Then again I was not using the C versions previously...
03:46:12 <Lemmih> musasabi: Perhaps it's the BSD license...
03:46:21 <dons> musasabi: ah!  ok. 
03:46:41 <dons> I thought the versions I've written were faster. but it sounds like you must have been using the cbits??
03:46:52 <dons> since they had empty impls for non-cbits, no?
03:47:36 <musasabi> dons: I don't think I was using the cbits (just plain downloaded FastPackedString.hs without Cabal)
03:47:38 <Lemmih> eivuokko: New versions of Cabal can do #1 and is it safe to do #2?
03:47:56 <dons> this also makes me wonder, musasabi, whether you should be using the cbits
03:48:15 <eivuokko> Lemmih, it is (I know it is.)
03:48:24 <Lemmih> eivuokko: (new versions of Cabal === Cabal from darcs with GHC from darcs)
03:48:25 <dons> hmm. maybe a bit more detective work is required.
03:48:45 <eivuokko> Lemmih, yes, figured that.  Maybe darcs ghc works in Windows again, gotta try.
03:49:20 <dons> musasabi: if its making a difference in HAppS, i will definitely restore the dropspace and friends cbits
03:50:04 <musasabi> dons: I am looking for more data on this, what really makes the difference.
03:51:22 <vincenz> int-e: yep I noticed
03:53:01 <eivuokko> Lemmih, About the 2), I wrote partial directx9 bindings, and I don't fancy users of bindings need to install the sdk, because it's mainly needed for .hsc files.
03:53:53 <Lemmih> eivuokko: I don't think Cabal can do that yet. There has been talk about it, though.
03:54:23 <dcoutts> eivuokko, there's a whole under-specified area on the question of the scope of header files
03:54:31 <eivuokko> (and dx constants *do not change* between systems)
03:55:01 <xero1> Lemmih: where is GHC darcs?
03:55:02 <dcoutts> at the moment ghc will not inline C calls across moduled if you do this or that, but it's not specified to do so
03:55:13 <eivuokko> xero, darcs.haskell.org/ghc
03:55:21 <dcoutts> there's no spec on what modules need the C headers
03:55:53 <dcoutts> potentially it could be any module that imports (directly or indirectly) the module that defines the foriegn import
03:56:08 <Lemmih> xero1: darcs.haskell.org/ghc
03:56:13 <dcoutts> it'd be nice to be able to specify that it can't escape a module or package
03:56:28 <eivuokko> dcoutts, none of my imports need the header files in this case.
03:56:29 <Lemmih> Oh, I'm too late.
03:57:04 <dcoutts> eivuokko, oh they're just constants etc and not function imports
03:58:51 <eivuokko> dcoutts, the imports work without headers file (in my case)
03:59:32 <eivuokko> No idea why, tho.  And I skip some corners.
04:00:08 <dcoutts> Lemmih, dons, what do you think about a Haskell' proposal to allow control over the scope of C header files
04:00:35 <dcoutts> are we too late?
04:02:26 <Lemmih> Scope of header files?
04:03:09 <dcoutts> where you have some header file availiable for the compilation of one module but the thing gets inlined into another module where the header file is not available
04:03:24 <dcoutts> people often use "private" header files which do not get installed
04:03:33 <dcoutts> technically that's not possible, though in practice it works
04:04:04 <dcoutts> it's all to do with where the header file is available and which module is linking to the foreign function
04:04:37 <musasabi> Are there known issues with TH + -O2 -prof -auto-all that cause undefined symbols to creep up in the .o file of the TH module?
04:04:52 <sbeyer> hm, I have a problem with gtk2hs... I want to disconnect a signal in its callback function. How could this be solved?  "connectid <- onFooEvent widget (callbackfunction connectid)" won't work, of course.
04:05:16 <dcoutts> sbeyer, either don't do it, or use an IORef to tie the knot
04:05:25 <dcoutts> or possibly recursive do aka mdo might work
04:05:34 <Lemmih> sbeyer: You can use fixM.
04:06:13 <Lemmih> *mfix
04:06:15 <sbeyer> ok, neither did anything with IORef nor fixM, I'll take a look.
04:06:19 <sbeyer> mh ;)
04:07:11 <Lemmih> > mfix (\n -> return (0:n)) :: Maybe [Int]
04:07:16 <lambdabot> Just [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
04:07:19 <lambdabot> 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
04:07:22 <lambdabot> 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
04:07:25 <lambdabot> 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
04:07:28 <lambdabot> 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
04:07:31 <lambdabot> [6 @more lines]
04:08:20 <davidhouse> i _still_ don't understand fix :)
04:08:39 <davidhouse> i don't get how fix for some functions converges and for others it diverges.
04:08:49 <Lemmih> sbeyer: mfix for IO is just a fancy way of using an IORef.
04:08:49 <davidhouse> which properties are necessary for a convergant fix?
04:09:10 <vincenz> davidhouse: fix for lists is lazily constructed
04:09:21 <vincenz> davidhouse: so by the time it reads the first element... it knows it and can use it to generate the second
04:09:56 <davidhouse> fix doesn't output a list
04:09:57 <davidhouse> @type fix
04:09:59 <lambdabot> forall a. (a -> a) -> a
04:10:37 <vincenz> > fix (\l -> o:l)
04:10:38 <lambdabot>  Not in scope: `o'
04:10:44 <vincenz> > take 10 $ fix (\l -> 0:l)
04:10:45 <lambdabot> [0,0,0,0,0,0,0,0,0,0]
04:10:52 <vincenz> (not to spam everyone)
04:11:45 <davidhouse> right, because 0:[0,0..] == [0,0..], so [0,0..] is a fixpoint of (0:).
04:11:50 <vincenz> yeah
04:11:59 <vincenz> you're saying...gimme the end of the list, I'll give you the end of list +1
04:12:23 <vincenz> but it doesn't analyze fixpoints
04:12:32 <davidhouse> no.
04:12:32 <vincenz> it therefore only works with lazy structures
04:12:47 <davidhouse> it evaluates to (0:) $ (0:) $ (0:) $ (0:)...
04:13:04 <davidhouse> and starts evaluating that from the front, and get [0,0,0,...]
04:13:16 <davidhouse> producing an infinite list
04:13:57 <vincenz> sadly
04:14:03 <vincenz> you can't get the values from the list into the list
04:14:19 <vincenz> or you could try to generate a fix point of slowly more accurate guestimates
04:15:21 <davidhouse> but there are examples of functions with convergant fixes that don't produce lists
04:16:35 <musasabi> dons: seems like it is pack related, but pack should be the same in both of them. Any good ideas?
04:16:59 <davidhouse> > fix $ const 1
04:17:00 <lambdabot> 1
04:17:31 <davidhouse> i see why that works.
04:17:59 <musasabi> http://youzen.b2.fi/~musasabi/P_fast.prof http://youzen.b2.fi/~musasabi/P_slow.prof (for the different versions and a benchmark where they have an even larger difference)
04:18:22 <davidhouse> it evaluates to const 1 $ const 1 $ const 1 $ const 1..., so it starts from the front, comes across const 1 (a load of stuff), so ignores the load of stuff.
04:18:22 <sbeyer> hmmm I don't see, how IORef or mfix could help me :\ ...
04:18:46 <Lemmih> sbeyer: connectid <- mfix (\connectid -> onFooEvent widget (callbackfunction connectid))
04:19:12 <davidhouse> @type mfix
04:19:14 <lambdabot> forall (m :: * -> *) a. (MonadFix m) => (a -> m a) -> m a
04:19:34 <vincenz> mfix = fix in a monad
04:19:59 <davidhouse> any more examples of convergant fix series?
04:21:07 <vincenz> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
04:21:09 <int-e> davidhouse: fix (\(x,y) -> (2,x)) and variations thereof
04:21:19 <vincenz> ocaml `betterThan` ghc
04:21:34 <davidhouse> > fix (\(x, y) -> (2, x)
04:21:34 <lambdabot>  parse error on input `}'
04:21:41 <davidhouse> > fix (\(x, y) -> (2, x))
04:21:42 <lambdabot> Terminated
04:21:48 <davidhouse> int-e, ?
04:21:55 <int-e> > fix (\~(x, y) -> (2, x))
04:21:56 <dons> musasabi, ok. i'll look at the profiles.
04:21:57 <lambdabot>  parse error on input `->'
04:22:18 <dons> do you have a diff of the code that works? oh you mentioned the patch number.
04:22:24 <davidhouse> > fix (\ ~(x, y) -> (2, x))
04:22:26 <lambdabot> (2,2)
04:22:52 <davidhouse> ~ does something like forcing the pattern to match, right?
04:22:58 <davidhouse> more precisely?
04:23:01 <vincenz> dons: ocaml is beating us
04:23:12 <musasabi> dons: seems like there is something that makes the GHC inliner (or other optimizations) either kick in or not. And that has dramatic results.
04:23:50 <int-e> it asserts that the pattern match succeeds but postpones it until one of the matched values is used.
04:24:19 <vincenz> > fix (\(x,y) -> (2,x))
04:24:20 <lambdabot> Terminated
04:24:23 <dons> vincenz: yeah, can't do anything till fps is in base.
04:24:33 <dons> musasabi: hmm. yes. some slight change made a difference.
04:24:39 <vincenz> dons: right, tho in a way that means haskell is better
04:24:43 <vincenz> dons: it's impossible to write a unicode parser in ocaml
04:24:47 <davidhouse> @pl \(x, y) -> (2, x)
04:24:47 <lambdabot> (,) 2 . fst
04:24:49 <vincenz> well not impossible, unpossible
04:24:54 <int-e> > let f x = let (a, b) = x in (2, a) in fix f
04:24:55 <lambdabot> (2,2)
04:25:07 <dons> musasabi: do you want to try to narrow down the code further?
04:25:22 <davidhouse> > fix ((,) 2 . fst)
04:25:24 <lambdabot> (2,2)
04:26:40 <dons> musasabi: i'm finding it hard to compare the two profs, are they from differrent tests?
04:26:54 <musasabi> dons: the exact same one unfortunately.
04:27:09 <dons> hmm
04:27:12 <davidhouse> this expands to (2, (2, (2, (2, (2, ..., right?#
04:27:14 <musasabi> dons: looking at the hi files and even they don't seem to have things that should make a difference.
04:27:25 <musasabi> trying to merge parts of the patch and find the relevant bit.
04:27:37 <dons> ok. thanks.
04:28:09 <dons> we might have to kick up some inliner magic numbers
04:28:14 <dons> to make this more predictable
04:28:16 <int-e> davidhouse: no, (2, fst (2, ...))
04:28:34 <vincenz> > fix ((,) 2 )
04:28:35 <lambdabot>   Occurs check: cannot construct the infinite type: a = (a1, a)
04:28:35 <lambdabot>   Expected type: a -> a
04:28:35 <lambdabot>   Inferred type: a -> (a1, a)
04:28:54 <davidhouse> int-e, ah. makes sense.
04:29:06 <dons> musasabi: the -funfolding-creation-threshold and the -funfolding-use-threshold
04:29:22 <davidhouse> fix seems to work for a rather small minority of functions.
04:29:36 <davidhouse> specifically, those that ignore their arguments or parts thereof.
04:29:50 <davidhouse> hmm... maybe not.
04:29:54 <davidhouse> as (0:) works.
04:31:13 <vincenz> Lemmih: care to explain http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
04:31:16 <vincenz> oops
04:31:20 <vincenz> sbeyer: connectid <- mfix (\connectid -> onFooEvent widget (callbackfunction connectid))
04:33:19 <Lemmih> 'connectid' is the result of the 'onFooEvent widget (callbackfunction connectid)' action.
04:34:07 <musasabi> dons: ok, still merging things, will look at those next.
04:34:13 <vincenz> Lemmih: what's the first input then?
04:34:24 <Lemmih> vincenz: first input?
04:34:32 <vincenz> Lemmih: mfix calls a function over and over
04:34:37 <vincenz> Lemmih: it's gotta start with some value
04:34:43 <davidhouse> no it doesn't.
04:34:47 <davidhouse> that's the whole point.
04:34:49 <Lemmih> vincenz: No, it doesn't.
04:34:51 <vincenz> hmm
04:34:52 <davidhouse> @type mfix
04:34:54 <lambdabot> forall (m :: * -> *) a. (MonadFix m) => (a -> m a) -> m a
04:35:00 <davidhouse> notice the lack of an input
04:35:05 <vincenz> yeah
04:35:06 <vincenz> but inside
04:35:24 <davidhouse> vincenz, it generates an infinite application, which may or may or evaluate to something.
04:35:40 <davidhouse> working with fix (because it's easier):
04:35:47 <vincenz> right
04:35:57 <davidhouse> fix (const 1) = const 1 (const 1 (const 1 (const 1 ...
04:35:58 <vincenz> but with something like what Lemmih wrote you don't want to run that function an infinite time
04:36:22 <davidhouse> it starts evaluating from the left, sees const 1 (a load of stuff), and so it evaluates to 1.
04:37:01 <davidhouse> @index mfix
04:37:01 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
04:37:20 <davidhouse> is the source online?
04:37:25 <davidhouse> @help @fptools
04:37:26 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
04:37:30 <davidhouse> @help fptools
04:37:31 <lambdabot> fptools <lib>. Lookup url of ghc base library modules
04:37:38 <Lemmih>     ref <- newIORef (throw NonTermination)
04:37:38 <davidhouse> @help fptools Control.Monad.Fix
04:37:39 <Lemmih>     ans <- unsafeInterleaveIO (readIORef ref)
04:37:39 <Lemmih>     result <- k ans
04:37:39 <Lemmih>     writeIORef ref result
04:37:39 <Lemmih>     return result
04:37:39 <lambdabot> fptools <lib>. Lookup url of ghc base library modules
04:37:52 <davidhouse> @fptools Control.Monad.Fix
04:37:53 <lambdabot> http://darcs.haskell.org/packages/base/Control/Monad/Fix.hs
04:38:02 <Lemmih> ^^ Code for fixIO.
04:38:14 <davidhouse> ah. thanks.
04:38:43 <davidhouse> eww, it's not referentially transparent.
04:39:05 <musasabi> dons: I think I found the problem.
04:39:28 <Lemmih> davidhouse: It isn't?
04:39:50 <davidhouse> Lemmih, unsafeInterleaveIO works on unsafePerformIO, right?
04:40:09 <sbeyer> vincenz, Lemmih, well, thank you ;)
04:41:06 <Lemmih> davidhouse: Yes?
04:41:27 <musasabi> dons: My version of the no USE_CBITS had had an implementation for dropSpace/dropSpaceEnd in Haskell. Then upgrading to your 0.2 I didn't notice they had just error for them, now the current code has a Haskell definition for them that makes things slow down a little bit.
04:41:41 <dons> ah, ok.
04:41:55 <dons> so the naive versions (which i never benchmarked) were ok?
04:42:35 <Lemmih> davidhouse: unsafePerformIO /can/ break referential transparency, it doesn't have to (or so I think).
04:42:57 <musasabi> dons: nah, I think the fact was they were "error" and I didn't end up evaluating them helped.
04:43:01 <dons> musasabi: ah!
04:43:27 <davidhouse> Lemmih, ah. is the first line of that fixIO k = ..., by the way (guessing that's what the k is)
04:43:31 <dons> ok, then its allowed to go from doing nothing to diong something, with a slight slow down
04:43:49 <musasabi> dons: trying with an optimized "trim :: FastPackedString -> FastPackedString" now, since that is quite important for me.
04:43:51 <dons> but, if this code is somehow critical, maybe i should bring back the cbits version, and you should use it?
04:44:13 <dons> that's a front and back dropping of white space?
04:44:20 <musasabi> yes.
04:45:13 <musasabi> I am trying to do it as fast as possible in Haskell.
04:45:29 <dons> ok. check the dropSpace code, I think that's quite fast.
04:45:38 <dons> around 1.5x the old C code.
04:46:08 <dons> you'll probably need STRICTx()_ on any accumulator
04:54:08 <RHE123> is there an standard functie which is the opposite of (!!) ?
04:54:52 <dcoutts> @type find
04:54:54 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
04:55:11 <dcoutts> or findIndex or findIndices
04:55:18 <davidhouse> hmm...
04:55:25 <davidhouse> where is the State# data constructor defined?
04:55:52 <RHE123> @type findIndex
04:55:53 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
04:56:05 <RHE123> sounds good, let's try :)
04:56:06 <xero1> @type elemIndex
04:56:07 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
04:56:09 <dcoutts> davidhouse, what makes you believe that it has any constructors?
04:56:10 <davidhouse> GHC.ST seems to use it without defining it, and it doesn't appear to be in GHC.Base, GHC.Show or GHC.Num, which are the only modules GHC.ST imports.
04:56:25 <xero1> (That last one lets you avoid (==).)
04:56:35 <dcoutts> davidhouse, I'll bet it's a datatype with no constructors, like the RealWorld type
04:56:35 <davidhouse> s/data constructor/type constructor
04:56:49 <davidhouse> dcoutts, me too, but it still has to be defined somewhere
04:56:54 <xero1> grep?
04:57:09 <dcoutts> davidhouse, ok so you're talking about a type not a data constructor?
04:57:14 <davidhouse> yeah.
04:57:57 <ihope> I feel like I really need Word# literals right now.
04:57:59 <davidhouse> hmm...
04:58:00 <davidhouse> http://www.google.co.uk/search?q=%22type%20State%23%22%20%22newtype%20State%23%22%20site%3Adarcs.haskell.org
04:58:23 <davidhouse> @google "type State#" "newtype State#" "data State#" site:darcs.haskell.org
04:58:25 <lambdabot> No Result Found.
04:58:43 <dcoutts> davidhouse, perhaps it's a compiler builtin
04:58:54 <dcoutts> I can't find it with grep
04:59:05 <davidhouse> could be. it doesn't seem particularly special, though.
04:59:18 <davidhouse> e.g. type STRep s a = State# s -> (# State# s, a #)
04:59:27 <davidhouse> that would work just as well without the State#.
04:59:56 <dcoutts> I'll bet it's used to mark 'phantom' data
05:00:28 <dcoutts> you need it to be there to gurantee sequencine etc but it has no runtime representation
05:01:09 <dcoutts> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
05:01:39 <Igloo> It's "defined" in ghc/compiler/prelude/TysPrim.lhs
05:02:25 <dcoutts> quoth the docs:
05:02:27 <dcoutts> State# is the primitive, unlifted type of states.
05:02:39 <dcoutts> It has one type parameter. The only purpose of the type parameter is to
05:02:39 <dcoutts> keep different state threads separate.  It is represented by nothing at all.
05:02:51 <vincenz> what is that #
05:02:54 <davidhouse> i was just about to paste that :)
05:02:57 <davidhouse> vincenz, unboxed type
05:03:00 <vincenz> a
05:03:03 * vincenz nods
05:03:29 <dcoutts> vincenz, but only by convention, it has no special meaning defined by ghc
05:04:23 <dcoutts> it's purpose is to make your code look ugly if you use lots of unboxe things - to encourage you not to write such code :-0
05:05:50 <Heejae> what the;;
05:07:13 <vincenz> dcoutts: :D
05:07:35 <davidhouse> dcoutts, unboxed types must be treated specially, surely
05:07:46 <ihope> What--you expect me to define natural numbers as "data Natural = Zero | Succ Natural"?
05:08:13 <davidhouse> ihope, why not?
05:08:25 <ihope> davidhouse: if the unboxed types weren't different, they wouldn't be unboxed.
05:08:42 <ihope> And "data Natural = Zero | Succ Natural" is inefficient and all that.
05:08:52 <davidhouse> ihope, that's my point, but then "[the hash mark] has no special meaning defined by ghc"
05:09:15 <bolrod> someone with wxhaskell experience here?
05:09:16 <musasabi> dons: how much performance do you think there would be gained for using readWord8OffAddr# ?
05:09:31 <bolrod> I want to be able to create something like a scrolledWindow but with buttons in it etc.
05:09:36 <bolrod> instead of drawwing on it
05:10:55 <davidhouse> ihope, just out of interest, how would you define them? data Natural = Nat { toInt :: Int } or something along those lines?
05:11:21 <ihope> Well, I have data Nat = N# Word#
05:11:59 <ihope> I'm not sure how to define Natural.
05:15:28 <davidhouse> vincenz, "Most types in GHC are boxed, which means that values of that type are represented by a pointer to a heap object. The representation of a Haskell Int, for example, is a two-word heap object. An unboxed type, however, is represented by the value itself, no pointers or heap allocation are involved."
05:16:23 <davidhouse> http://haskell.org/ghc/docs/latest/html/users_guide/primitives.html pretty much explains everything
05:18:17 <vincenz> davidhouse: oh I know they are boxed ;)
05:18:26 <}ElectrowolF{> > 4 !! 5
05:18:27 <lambdabot>  add an instance declaration for (Num [a])
05:18:40 <}ElectrowolF{> > Int (4 !! 5)
05:18:41 <lambdabot>  Not in scope: data constructor `Int'
05:18:45 <davidhouse> > [1..10] !! 4
05:18:46 <lambdabot> 5
05:18:52 <davidhouse> @type (!!)
05:18:53 <lambdabot> forall a. [a] -> Int -> a
05:19:14 <}ElectrowolF{> hmm
05:20:07 <}ElectrowolF{> > [1990..2020] !! 2006
05:20:08 <lambdabot> Exception: Prelude.(!!): index too large
05:20:13 <}ElectrowolF{> lol
05:20:24 <davidhouse> because there aren't 2006 items in your list.
05:20:30 <dons> musasabi: hmm. some perhaps. we'd be able to do our own compilation to Core, in effect. if ghc's not doing the right thing.
05:20:41 <davidhouse> > [1990..2020] !! 16
05:20:42 <lambdabot> 2006
05:20:44 <dons> but if we already have the QuickChecked C code to do the same job...
05:21:21 <ihope> > unsafeCoerce "foo" :: String
05:21:22 <lambdabot>  Not in scope: `unsafeCoerce'
05:21:26 <ihope> > unsafeCoerce# "foo" :: String
05:21:27 <lambdabot>  Not in scope: `#'
05:21:45 <dons> it would be kind of insane to allow unsafeCoerce# in lambdabot ;)
05:21:58 <ihope> True...
05:22:05 <dons> musasabi: let me know what you think needs to be done
05:22:15 * dons -> off to dinner
05:22:41 <}ElectrowolF{> bon apetit
05:27:14 <davidhouse> anyone recommend a free postscript reader for windows?
05:29:15 <vincenz> davidhouse: ghostview?
05:29:33 <Jerub> davidhouse: ghostview.
05:29:57 <davidhouse> thanks.
05:29:59 <vincenz> anyone know a way to run a windows app in linux
05:30:08 <sdrac8> wine?
05:30:15 <Jerub> vincenz: vmware server
05:30:17 <xero1> ghostview? :-P
05:32:12 <vincenz> Jerub: too heavy
05:32:19 <vincenz> besides it ain't free
05:32:30 <davidhouse> wine :)
05:32:39 <Jerub> vincenz: xen.
05:32:45 <sdrac8> wine
05:33:33 <Jerub> I have never liked using wine.
05:33:54 <Igloo> dons: FPS is 1/2 the speed of wc -l not 2x the speed, right?
05:34:20 <vincenz> nor I
05:34:23 <sdrac8> I never liked using win either but it seems the best thing for only one app.
05:34:25 <vincenz> I just want something simple
05:34:28 <sdrac8> wine*
05:34:32 <vincenz> to run igowin
05:34:48 <norpan> 2x the speed measured in seconds per character
05:35:31 <vincenz> Jerub: can I run an existing iwndows install with xen?
05:35:42 <Jerub> vincenz: dunno. 
05:44:20 <ihope> Okay. How does GMP store an integer?
05:46:08 <tromp> in an int array
05:46:26 <robokop> @type print
05:46:28 <lambdabot> forall a. (Show a) => a -> IO ()
05:46:33 <vincenz> tromp: quick question... 3x3, black always wins?
05:47:43 <tromp> B +9
05:48:17 <tromp> even on 5x5, B +25
05:48:37 <ihope> tromp: do you know just what's in that array?
05:48:47 <tromp> 7x7 smallest odd-sized board where white can live
05:49:20 <tromp> no, ihope
05:50:32 <tromp> but gmp library has export/import functions
05:51:14 <tromp> to/from arrays of various radixes
05:51:38 <vincenz> tromp: cool, thx
05:51:41 <tromp> you're not supposed to access the native format
05:57:28 <ihope> Well, isn't Integer implemented using GMP?
05:57:46 <tromp> yes
05:59:03 <ihope> Well, how easy would it be to implement natural numbers the same way?
05:59:18 <eivuokko> I am (and have been for a while) writing a patch for ghc to get rid of GMP in ghc (and replace with another library).
05:59:39 <eivuokko> I will get to it someday again, hopefully soon.
05:59:44 <tromp> what's the advantage?
05:59:48 <eivuokko> License.
06:00:09 <norpan> then it's only readline left
06:00:22 <eivuokko> ihope, Depends what you mean...ghc actually does some optimisation by keeping only Int until it needs Integer..
06:00:35 <tromp> natural numbers would be easier than Integers
06:00:41 <tromp> no need to track signs
06:01:05 <eivuokko> ihope, Also, Integer does quite specific hacks to make GMP allocated memory reside on garbage collected heap
06:01:14 <eivuokko> (in case of ghc)
06:02:32 <ihope> So how should I implement fast arbitrary-precision natural numbers?
06:03:04 <vincenz> type Nat = Zero | Succ Nat
06:03:11 <vincenz> data Nat = Zero | Succ Nat
06:03:12 <ihope> Is that fast?
06:03:15 <vincenz> :D
06:03:22 <vincenz> with a really good compiler, yes
06:03:34 <ihope> Is GHC that good?
06:03:38 <vincenz> doubt it
06:03:40 <eivuokko> No.
06:03:55 <vincenz> ihope: [Integer]
06:04:03 <vincenz> lsb first
06:04:15 <ihope> How about [Word], then?
06:04:20 <eivuokko> Uhm
06:04:31 <eivuokko> Well, what are the advantages over just Integer?
06:04:40 <eivuokko> You can't control literals anyway.
06:04:46 <ihope> eivuokko: you know that it's not negative.
06:04:47 <eivuokko> (without compiler support)
06:04:51 <ihope> @index Word
06:04:52 <lambdabot> Data.Word, Foreign, GHC.Exts
06:05:04 <vincenz> ihope: it has been proven that natural numbers are never efficient
06:05:06 <vincenz> ihope: a - b
06:05:07 <kosaki> How should I understand TyingTheKnot, (Doubly linked list in particular)?
06:05:16 <eivuokko> My point exactly.  You will need to do sign checking on constructor funciton, because you cannot do it in constructor.
06:05:21 <vincenz> kosaki: I remember that vaguely, gimme link?
06:05:38 <eivuokko> Old wiki has page named like that, iirc.
06:05:51 <kosaki> http://www.haskell.org/hawiki/TyingTheKnot
06:09:31 <norpan> the trick to understanding it is to note that the function is called with some of it's output as input
06:09:38 <ihope> What's wrong with a-b? It can't be much harder than a+b, can it?
06:09:47 <dcoutts> xerox, ping
06:09:59 <norpan> if b > a, then a-b is not a natural anymore
06:10:43 <ihope> So pop an error when b > a...
06:10:59 <norpan> but then you have to do checking at run-time
06:11:07 <eivuokko> ihope, there's nothing hard in a-b.  But converting literal -1 or any other Num into Natural will require a construction function anyway, so internal representation of Integer should be just fine, no?
06:11:49 <eivuokko> i.e. newtyping something like newtype Natural = Natural Integer
06:12:02 <ihope> Well, a person can still pop a negative number into the Natural constructor.
06:12:13 <eivuokko> Don't give access to the constructor.
06:12:38 <eivuokko> You will need to construct those numbers via a function in all cases anyway.
06:12:55 <eivuokko> (because you don't have support for literals)
06:13:33 <ihope> Um...
06:13:43 <dcoutts> xerox, see the email to haskell cafe "Google SoC" and my quick reply...
06:13:43 <ihope> Num instance -> literals?
06:13:46 <norpan> you will have support for literals if you make it an instance of num
06:14:08 <dcoutts> xerox, when do you plan to announce?
06:14:12 <norpan> literals have type (Num a) => a
06:14:49 <norpan> uses fromInteger
06:14:54 <eivuokko> Yes, but you still have the constructor number.  I meant you don't have syntax saying 1N or somesuch, meaning 1 is natural number.
06:15:07 <eivuokko> *construct function
06:15:12 <norpan> so have your fromInteger check signedness
06:15:21 <eivuokko> Hardly requires access to Natural's constructor
06:15:26 <eivuokko> (for user)
06:15:51 <norpan> well, you haven't got access to Integer's constructor so why should you for Natural :)
06:15:57 <kosaki> I really can't understand this TyingTheKnot. 
06:16:20 <eivuokko> I gtg, sorry.
06:16:56 <eivuokko> kosaki, do you need it?  I didn't understand it before I had to write it...it's fairly safe to skip it. ... now really off.
06:17:08 <norpan> kosaki: the "go" function returns the first and last element of the list, which are input to the go function to put the final pointers in
06:17:37 <kosaki> norpan: I can see what is happening, but that doesn't mean I understand it.
06:18:10 <norpan> but you do understand lazy evaluation?
06:18:16 <kosaki> norpan: There is a difference between seeing it working and making it work yourself for arbitrarily complex datastructures.
06:18:20 <kosaki> norpan: yes
06:18:44 <norpan> yes, making it work yourself is harder, you need to identify which knots to tie
06:19:24 <kosaki> norpan: I am looking more for a kind of "method". 
06:21:27 <norpan> well, create your list, and when you need a "pointer" to something you've already created use an input
06:21:39 <norpan> s/list/datastructure/
06:21:57 <norpan> then have your function return those parts and use them as inputs
06:22:38 <Ulfalizer> ugh, it's kinda cumbersome that you have to give a name to the constructor of single-constructor data types
06:22:58 <tic> Make it a type?
06:23:19 <norpan> just name it the same as the type
06:23:24 <norpan> why is that so cumbersome
06:23:24 <Ulfalizer> it sometimes feels neater to use data though
06:23:45 <Ulfalizer> norpan: it just feels a bit ugly :)
06:24:05 <norpan> it's not ugly, it's elegant
06:24:28 <norpan> it's called type safety :)
06:24:36 <norpan> and we all love it
06:25:26 <dons> Igloo, right :) I mean takes 2x as long.
06:25:45 <dons> I thought I new what I wrote, but dcoutts also thought I meant 2x faster, not 2x slower :)
06:25:49 <Ulfalizer> you could probably get away without having the use the same name though, and still have type safety
06:26:03 <Ulfalizer> with a different system that is
06:26:10 <Ulfalizer> not that it's That much of a burden :)
06:26:15 <ihope> norpan: I can access Integer's constructors just fine.
06:26:28 <ihope> They're S# and J#, and they're in GHC.Num.
06:27:02 <Saulzar> That's not portable haskell though
06:27:07 <ihope> True.
06:27:19 <xerox> dcoutts: today
06:27:27 <dcoutts> xerox, cool
06:27:41 <xerox> dcoutts: going to see that cafe mail now, uh.
06:27:51 <Ulfalizer> otherwise you could allow the syntax  data Object = Type1 Type2 ..  for single-constructor data types. it should be unambiguous as far as i can tell.
06:28:29 <Ulfalizer> and have "Object" implicitly be the name of the constructor
06:28:30 <isaac_> data Object = Type1 Type2    -- constructer name is Type1
06:28:45 <Ulfalizer> yeah, but if Type1 is already the name of a type, the compiler could tell
06:29:00 <xerox> dcoutts: nicely done :)
06:29:01 <ihope> But what if you want it to be the name of a constructor?
06:29:04 <Ulfalizer> like  data Object = Int Int
06:29:11 <norpan> how would you separate it from the case when you have a constructor?
06:29:15 <Ulfalizer> then you name it something that's not already the name of a type
06:29:27 <isaac_> "already"?  That might be confising anyway since Haskell is not big on ordering such things
06:29:33 <Ulfalizer> name clashes are confusing anyhow
06:29:42 <kosaki> norpan: go prev []     next =  (next,prev)
06:29:43 <norpan> so you would not be able to have a constructor name that is already the name of a type
06:29:52 <Ulfalizer> nope
06:29:53 <isaac_> *confusing
06:29:54 <kosaki> norpan: Why are prev and next reversed?
06:30:34 <norpan> kosaki: because the pointer at the end points to the beginning, and vice versa
06:32:04 <dons> musasabi: when you work it out, can you summarise what the dropSpace or friends issues were exactly, and i'll look into them tomorrow
06:32:35 <norpan> you accumulate the list in the first parameter and then return it as the pointer that should be put at the last element
06:35:37 <Ulfalizer> isaac_: well, strip "already" then. the compiler would only have to do something like  if isType Bar then [data Foo = Bar is the same as old-style data Foo = Foo Bar] else [Bar is a constructor for the type Foo]. not being able to give constructors the same names as types is not that big a loss, imho.
06:36:35 <isaac_> Okay, then it only potentially breaks some code that was confusing anyway
06:36:38 <Ulfalizer> it is less "pure", sure, but i still find  data Foo = Foo Bar  pretty ugly :)
06:37:37 <isaac_> I think the bigger problem is how easy it is for humans to parse it correctly when reading it.
06:37:41 <norpan> not ugly, elegant i said
06:38:53 <norpan> one nice extension would be to allow newtype A = A T1 T2 T3
06:39:57 <isaac_> With what semantics?
06:40:00 <norpan> being isomorphic to newtype A = A #(T1, T2, T3)
06:40:12 <norpan> or something
06:40:40 <toste> hey
06:40:45 <toste> ?? paste
06:40:46 <lambdabot> Not enough arguments to @.
06:40:57 <davidhouse> @paste
06:40:57 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
06:41:14 <davidhouse> er
06:41:16 <davidhouse> @where paste
06:41:16 <lambdabot> http://paste.lisp.org/new/haskell
06:41:36 <jip> olliej: yo
06:41:41 <jip> @seen olliej 
06:41:42 <lambdabot> olliej is in #haskell. I last heard olliej speak 7 hours, 51 minutes and 32 seconds ago.
06:42:01 <kosaki> norpan: could you give an example of how mkDList [1,2,3] is calculated?
06:42:03 <Ulfalizer> data Foo = Type1 Type2  reads pretty naturally to me as "a Foo has a Type1 and a Type2", while  data Foo = Foo Type1 Type2  reads as "a Foo has a Type1 and a Type2 and oh shit, i have to make up a name for the constructor" =)
06:42:17 <olliej> yip: yo
06:42:21 <olliej> jip: yo
06:42:34 <jip> olliej: hey, yeah, i'm the guy
06:42:44 <Ulfalizer> jip: are you him?
06:42:44 <davidhouse> template haskell sounds really cool.
06:42:51 <norpan> Ulfalizer: if you want no constructor, use type Foo = (Type1, Type2)
06:43:28 <norpan> kosaki: you should try it yourself. write mkDList [1,2,3] and use the equivalences to write successive expressions
06:43:42 <lisppaste2> toste pasted "code" at http://paste.lisp.org/display/19219
06:43:52 <kosaki> norpan: I tried, but maybe I have to put somewhat more time into it.
06:43:57 <norpan> ok
06:44:01 <Ulfalizer> yeah, that works, but sometimes data is more consistent with the rest of the system/feels better for some other reason
06:44:03 <norpan> mkDList [1,2,3]
06:44:16 <norpan> let (first,last) = go last [1,2,3] first in first
06:45:02 <jip> olliej: sorry i'm not able to respond to pm, i'm not registered. another post to the devlog coming in a few hours
06:45:35 <olliej> jip: ah :) cool :)
06:45:54 <norpan> let (first,last) = let this = DLNode last 1 rest; (rest, last) = go this [2,3] first in (this,last) in first
06:46:19 <ihope> ??
06:46:19 <lambdabot> Not enough arguments to @.
06:46:30 <ihope> Um...
06:46:36 <norpan> let (first,last) = let this = DLNode last 1 rest; (rest, last') = go this [2,3] first in (this,last) in first
06:46:52 <norpan> let (first,last) = let this = DLNode last 1 rest; (rest, last') = go this [2,3] first in (this,last') in first
06:46:54 <toste> well basicly, i have a list of elements... i want to change on of them
06:47:34 <norpan> so, first will start with DLNode last 1 rest
06:47:35 <toste> but each element is a Data, and thoses Data's are into a Data wich itself is into a Data
06:47:59 <toste> hum; map ;/
06:48:09 <norpan> and last will be the result from go this [2,3]
06:48:59 <toste> > map (*2) [1,2]
06:49:00 <lambdabot> [2,4]
06:49:33 <CosmicRay> > map (*2) [1..]
06:49:34 <lambdabot> [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,118,120,122,124,
06:49:34 <lambdabot> 126,128,130,132,134,136,138,140,142,144,146,148,150,152,154,156,158,160,162,164,166,168,170,172,174,176,178,180,182,184,186,188,190,192,194,196,198,200,202,204,206,208,210,212,214,216,218,220,222,
06:49:34 <lambdabot> 224,226,228,230,232,234,236,238,240,242,244,246,248,250,252,254,256,258,260,262,264,266,268,270,272,274,276,278,280,282,284,286,288,290,292,294,296,298,300,302,304,306,308,310,312,314,316,318,320,
06:49:34 <lambdabot> 322,324,326,328,330,332,334,336,338,340,342,344,346,348,350,352,354,356,358,360,362,364,366,368,370,372,374,376,378,380,382,384,386,388,390,392,394,396,398,400,402,404,406,408,410,412,414,416,418,
06:49:37 <lambdabot> 420,422,424,426,428,430,432,434,436,438,440,442,444,446,448,450,452,454,456,458,460,462,464,466,468,470,472,474,476,478,480,482,484,486,488,490,492,494,496,498,500,502,504,506,508,510,512,514,516,
06:49:40 <lambdabot> [6 @more lines]
06:49:44 <CosmicRay> heh
06:49:47 <CosmicRay> only 6 more lines?
06:49:49 <CosmicRay> ;-)
06:49:58 <Ulfalizer> neat.. infinity fits on 11 lines
06:50:10 <toste> well, that replace each eleme
06:50:12 <CosmicRay> Ulfalizer: I think there's a dissertation in this ;-)
06:50:18 <toste> what if i only want to change 1 ?
06:50:21 <Saulzar> Last line may be quite long
06:50:23 <Ulfalizer> =)
06:50:35 <toste> map f x [..] ?
06:50:49 <toste> where f change that 1 value if its Eq to...
06:50:52 <kosaki> norpan: and with part of the value first known it enables the calculation of other values, right?
06:50:59 <CosmicRay> toste: which element do you want to change?  first?  last?  with some index?  identified by some test?
06:51:09 <CosmicRay> how do you know which element you want to change?
06:51:36 <norpan> kosaki: yes, something like that :)
06:51:38 <toste> if(isJust(find((==att).typeAttribut) l))
06:51:43 <toste> thats the element
06:52:04 <norpan> > length (repeat 1)
06:52:05 <davidhouse> > let mapIf p f l = map (\e -> if p e then f e else e) l in mapIf (==3) (*2) [1..10]
06:52:08 <lambdabot> Terminated
06:52:08 <lambdabot> [1,2,6,4,5,6,7,8,9,10]
06:52:20 <toste> thx david
06:52:33 <vincenz> > fix (const 2)
06:52:35 <lambdabot> 2
06:52:40 <davidhouse> that will work for more thank one element, too.
06:52:43 <kosaki> norpan: thanks, I will try to complete the example later today.
06:52:45 <davidhouse> > let mapIf p f l = map (\e -> if p e then f e else e) l in mapIf (>3) (*2) [1..10]
06:52:46 <lambdabot> [1,2,3,8,10,12,14,16,18,20]
06:53:30 <norpan> kosaki: the main point is that you can think of the input values as "already there" because you guarantee that your function will return them
06:54:03 <toste> :r
06:54:06 <kosaki> norpan: What is the property of the input values?
06:54:39 <vincenz> > foldr (\a xs-> if a `elem` xs then xs else a:xs) "" "kosaki"
06:54:40 <lambdabot> "osaki"
06:55:25 <mnislaih> hi, quick question, is there is any way or tool to integrate Drift with Cabal?
06:55:36 <vincenz> > foldr (\a xs-> if a `elem` xs then xs else a:xs) "" "vincenz"
06:55:37 <lambdabot> "vicenz"
06:56:08 <norpan> kosaki: the input values are the first node of the list and the last node of the list
06:56:40 <toste> 	if(isJust(find((==att).typeAttribut) l))
06:56:40 <toste> 		then mapIf ((==att).typeAttribut)) (val) l
06:57:01 <vincenz> @type mapIf
06:57:02 <lambdabot> Not in scope: `mapIf'
06:57:08 <kosaki> norpan: and they have the same nesting level? (because it's circular)
06:57:18 <norpan> nesting level?
06:57:40 <davidhouse> vincenz, i just wrote it
06:57:45 <davidhouse> > let mapIf p f l = map (\e -> if p e then f e else e) l in mapIf (==3) (*2) [1..10]
06:57:47 <lambdabot> [1,2,6,4,5,6,7,8,9,10]
06:57:58 <norpan> rather, the input values are "the node to put a backlink to from the node just being created" and "the node to put a forward link to when creating the last node"
06:58:02 <davidhouse> @type let mapIf p f l = map (\e -> if p e then f e else e) l in mapIf
06:58:04 <lambdabot> forall a.
06:58:04 <lambdabot>                        (a -> Bool)
06:58:04 <lambdabot>                        -> (a -> a)
06:58:04 <lambdabot>                        -> [a]
06:58:04 <lambdabot>                        -> [a]
06:58:04 <kosaki> norpan: DLNode (DLNode 1 next) 1 next etc.
06:58:54 <davidhouse> (note that your function must be a -> a and not a -> b by the homogoneity of lists and the fact that the predicate might be False for some values)
06:59:30 <kosaki> norpan: A normal list is nested like this: List 1 (List 1 (List 1 Empty))
07:00:15 <norpan> let node1 = DLNode node3 1 node2; node2 = DLNode node1 2 node3; node3 = DLNode node2 3 node1 in node1
07:00:37 <norpan> that will be the result
07:01:30 <norpan> so it will be nested both ways
07:01:38 <kosaki> norpan: ok
07:01:42 <vincenz> > let mapIf p f = map (\(a,b) -> if p b then a else b) $ zip =<< map f in mapIf (==3) (*2) [1..10]
07:01:43 <lambdabot> Couldn't match `[]' against `(->) [b]'
07:01:45 <norpan> that's why you need to tie the know
07:01:48 <norpan> tie the knot
07:02:10 <kosaki> I see
07:02:59 <norpan> as the page says: "It twists your brain a bit the first few times you do it, but it works fine."
07:03:17 <vincenz> > let mapIf p f = map (\(a,b) -> if p b then a else b) . (zip =<< map f) in mapIf (==3) (*2) [1..10]
07:03:18 <lambdabot> [1,2,6,4,5,6,7,8,9,10]
07:04:12 <Lemmih> darn
07:04:47 <vincenz> > let mapIf p f = (zipWith (\a b -> if p b then a else b) =<< map f) in mapIf (==3) (*2) [1..10]
07:04:48 <lambdabot> [1,2,6,4,5,6,7,8,9,10]
07:05:19 <vincenz> @type (=<<)
07:05:21 <lambdabot> forall b (m :: * -> *) a.
07:05:21 <lambdabot>    (Monad m) =>
07:05:21 <lambdabot>    (a -> m b) -> m a -> m b
07:07:06 <norpan> but if you have a lots of knots to tie, it may be easier to put them in a Map and pass the Map as input
07:07:12 <davidhouse> > find (> 3) =<< Just [1..10]
07:07:13 <lambdabot> Just 4
07:07:30 <vincenz> > let mapIf p = (zipWith (\a b -> if p b then a else b) =<<) . map in mapIf (==3) (*2) [1..10]
07:07:32 <lambdabot> [1,2,6,4,5,6,7,8,9,10]
07:07:37 <vincenz> just one actual param
07:08:40 <davidhouse> @pl \p -> (zipWith (\a b -> if p b then a else b) =<<) . map
07:08:41 <lambdabot> (. map) . (=<<) . zipWith . flip flip id . (ap .) . flip . (if' .)
07:08:52 <vincenz> the annoying parts are if' and ap
07:08:52 <davidhouse> see now, isn't that much more readable.
07:09:08 <vincenz> @type flip flip id
07:09:09 <davidhouse> what the hell is the flip flip id for?
07:09:10 <lambdabot> forall a c a1. (a -> (a1 -> a1) -> c) -> a -> c
07:09:17 <davidhouse> @type flip id
07:09:19 <lambdabot> forall b c. b -> (b -> c) -> c
07:09:29 <davidhouse> ah, right. because id only takes one parameter.
07:09:33 <davidhouse> @type flip const
07:09:35 <lambdabot> forall a b. b -> a -> a
07:09:44 <vincenz> lol
07:09:45 <davidhouse> flip flip const == const
07:09:52 <vincenz> @type flip flip const
07:09:53 <lambdabot> forall a c a1 b.
07:09:53 <lambdabot>        (a -> (a1 -> b -> a1) -> c) -> a -> c
07:10:08 <davidhouse> @type flip $ flip const
07:10:09 <lambdabot> forall a b. b -> a -> b
07:10:16 <vincenz> different than flip flip const
07:10:23 <davidhouse> flip flip const == (flip flip) const
07:10:24 <vincenz> flip flip const = flip flip $ const
07:10:30 <davidhouse> no.
07:10:37 <toste> well map use binary operation no ?
07:10:43 <vincenz> davidhouse: you and I said the same
07:10:55 <davidhouse> oh, sorry.
07:10:57 <davidhouse> misread yours
07:11:04 <toste> like if i wanna change a string to another in a Data, it's not map i need, right ?
07:11:14 <vincenz> davidhouse: flip const seems absolutely useless
07:11:15 <davidhouse> flip flip const = (flip flip) const = flip flip $ const /= flip (flip const)
07:11:19 <xerox> vincenz: no, IIRC
07:11:27 <davidhouse> vincenz, no, it's useful.
07:11:31 <vincenz> > flip const $ 2 3
07:11:33 <lambdabot>  add an instance declaration for (Show (a -> a))
07:11:36 <vincenz> > flip const $ 2 3 4
07:11:37 <lambdabot>  add an instance declaration for (Show (a -> a))
07:11:42 <xerox> @type (flip flip const, (flip flip) const, flip flip $ const)
07:11:43 <lambdabot> forall a
07:11:43 <lambdabot>                       c
07:11:43 <lambdabot>                       a1
07:11:43 <lambdabot>                       b
07:11:43 <lambdabot>                       a2
07:11:44 <vincenz> > flip const $ 2 $ 3
07:11:45 <lambdabot> [14 @more lines]
07:11:47 <lambdabot>  add an instance declaration for (Show (a -> a))
07:11:47 <xerox> ops :P
07:11:57 <vincenz> be nic eto have
07:11:59 <vincenz> @unify 
07:12:00 <lambdabot> Unknown command, try @list
07:12:22 <vincenz> @unify (flip flip const) (flip flip $ const)
07:12:23 <lambdabot> Unknown command, try @list
07:12:27 <xerox> :-)
07:12:32 <vincenz> > flip const $ 2 $ 3
07:12:33 <norpan> flip const takes two arguments and ignores the first, const takes two arguments and ignores the second
07:12:33 <lambdabot>  add an instance declaration for (Show (a -> a))
07:12:33 <xerox> Go for it!
07:12:42 <vincenz> @type flip const
07:12:43 <lambdabot> forall a b. b -> a -> a
07:12:53 <davidhouse> > map (flip const 'a') [1..10]
07:12:55 <lambdabot> [1,2,3,4,5,6,7,8,9,10]
07:13:03 <vincenz> davidhouse: right
07:13:09 <davidhouse> flip const _ = id
07:13:13 <vincenz> davidhouse: yeah
07:13:17 <vincenz> kinda useless
07:13:19 <davidhouse> in fact
07:13:24 <davidhouse> flip const = \_ -> id
07:13:28 <davidhouse> flip const = const id
07:13:33 <vincenz> @type const id
07:13:34 <lambdabot> forall a b. b -> a -> a
07:13:43 <vincenz> ;0
07:13:46 <norpan> groundbreaking work
07:13:52 <davidhouse> lets write a paper :)
07:13:58 <vincenz> norpan: we're planning to write a paper on the metaconcepts of id, flip and const
07:14:22 <vincenz> hmm
07:14:24 <vincenz> nw that I think of it
07:15:47 <norpan> vincenz: you mean a paper about I, K and (almost S) :)
07:15:53 <vincenz> yeah
07:15:54 <vincenz> was thinking about that
07:16:14 <vincenz> but I don't think flip, id and const are enough for S
07:16:18 <norpan> i think that has been pretty researched
07:16:41 <davidhouse> I, K, S?
07:16:50 <vincenz> davidhouse: functional combinators
07:16:55 <vincenz> davidhouse: you can define lambda with SKI
07:17:02 <vincenz> Ix = x
07:17:04 * davidhouse stays away from combinatorics
07:17:04 <vincenz> Kxy = x
07:17:10 <vincenz> Sxyz = xz(yz)
07:17:32 <davidhouse> xz(yz)? what does that mean?
07:17:39 <vincenz> in haskell
07:17:43 <vincenz> (x z) $ (y z)
07:17:48 <davidhouse> right.
07:18:00 <davidhouse> @pl \x y z -> x z $ y z
07:18:01 <lambdabot> ap
07:18:10 <vincenz> so x : a -> b -> c, y : a -> b, z: a
07:18:16 <davidhouse> @pl \x y z -> (x z) $ (y z)
07:18:17 <lambdabot> ap
07:18:32 <davidhouse> so, with id, const and ap we can define any combinator?
07:18:33 <vincenz> > ap (+) (+1) 1
07:18:35 <lambdabot> 3
07:18:46 <davidhouse> > ap (*4) (+1) 1
07:18:47 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> b
07:18:47 <lambdabot>   Expected type: (a -> b) -> a
07:18:47 <lambdabot>   Inferred type: (a -> b) -> a -> b
07:18:53 <vincenz> first one is dyadic
07:19:02 <davidhouse> oops
07:19:05 <norpan> davidhouse: yes
07:19:06 <vincenz> > ap (*) (+2) 3
07:19:08 <lambdabot> 15
07:19:19 <vincenz> = 3 * (3+2)
07:19:27 <davidhouse> @type \x y z -> x z $ y z
07:19:29 <lambdabot> forall a b t.
07:19:29 <lambdabot>         (t -> a -> b) -> (t -> a) -> t -> b
07:19:41 <vincenz> I wonder how lambdabot picks names of types
07:19:44 <vincenz> why not a b c
07:19:50 <norpan> S K K = I, so you don't need I
07:19:59 <vincenz> @type ap const const
07:20:00 <davidhouse> nice :)
07:20:01 <lambdabot> forall a. a -> a
07:20:08 <davidhouse> > ap const const 4
07:20:09 <lambdabot> 4
07:20:12 <davidhouse> > ap const const 10
07:20:13 <lambdabot> 10
07:20:16 <vincenz> hmm
07:20:17 <vincenz> another test
07:20:17 <davidhouse> > ap const const "hello world"
07:20:18 <vincenz> to ensure
07:20:19 <lambdabot> "hello world"
07:20:21 <vincenz> > ap const const 5
07:20:23 <lambdabot> 5
07:20:35 <vincenz> @type ap ap
07:20:37 <lambdabot> forall (m :: * -> *) a b.
07:20:37 <lambdabot>    (Monad m) =>
07:20:37 <lambdabot>    (m (a -> b) -> m a) -> m (a -> b) -> m b
07:20:37 <bolrod> @type ap
07:20:39 <lambdabot> forall b (m :: * -> *) a.
07:20:39 <lambdabot> (Monad m) =>
07:20:39 <lambdabot> m (a -> b) -> m a -> m b
07:20:43 <bolrod> :)
07:20:47 <vincenz> why is ap monadic
07:20:54 <davidhouse> because it is.
07:20:56 <davidhouse> that is what ap is.
07:21:03 <bolrod> ic
07:21:04 <vincenz> map should be monadic ap
07:21:05 * vincenz nods
07:21:09 <davidhouse> functions of type (->) a form a monad.
07:21:16 <davidhouse> which is how we can use ap in this context.
07:21:21 <vincenz> good point
07:21:28 <davidhouse> and it's how we can do things like:
07:21:41 <davidhouse> > liftM2 (+) (*2) (-1) 3
07:21:42 <lambdabot>  add an instance declaration for (Num (a -> a))
07:21:53 <davidhouse> > liftM2 (+) (*2) (1 `subtract`) 3
07:21:55 <lambdabot> 8
07:22:18 <vincenz> (1 `substract` ) == (1-)
07:22:24 <davidhouse> nope.
07:22:29 <davidhouse> > 3 `subtract` 2
07:22:30 <lambdabot> -1
07:22:34 <vincenz> hmm
07:22:43 <vincenz> oh yeah
07:22:45 <davidhouse> subtract x y = y - x -- subtract x from y
07:22:52 <vincenz> yeah in the very logical sense
07:23:02 <davidhouse> which is why you shouldn't use it infix. ever.
07:23:09 <davidhouse> > liftM2 (+) (*2) (subtract 1) 3
07:23:10 <lambdabot> 8
07:23:10 <vincenz> except to confuse people
07:23:23 <earthy> as in obfuscated haskell code
07:23:45 <davidhouse> hmm...
07:23:58 <davidhouse> > ((*2) >>= (+5)) 3
07:23:59 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> b
07:23:59 <lambdabot>   Expected type: a -> a -> b
07:23:59 <lambdabot>   Inferred type: a -> a
07:24:04 <vincenz> > foldr (\xs a -> if a `elem` xs then xs else a:xs) "" "haskell ask"
07:24:05 <lambdabot>   Occurs check: cannot construct the infinite type: b = [b]
07:24:05 <lambdabot>   Expected type: b
07:24:05 <lambdabot>   Inferred type: [b]
07:24:10 <davidhouse> > ((*2) >> (+5)) 3
07:24:11 <vincenz> > foldr (\a xs -> if a `elem` xs then xs else a:xs) "" "haskell ask"
07:24:11 <lambdabot> 8
07:24:12 <lambdabot> "hel ask"
07:24:28 <davidhouse> the (a->) monad is nice to play around with.
07:24:47 <davidhouse> @fptools Control.Reader
07:24:48 <lambdabot> Control.Reader not available
07:24:55 <davidhouse> @fptools Control.Monad.Reader
07:24:56 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/Reader.hs
07:25:09 <toste> http://pastebin.com/673341
07:25:26 <toste> how can i change this value :/
07:28:47 <davidhouse> > (*2) >>= (+) 4
07:28:48 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> b
07:28:48 <lambdabot>   Expected type: a -> a -> b
07:28:48 <lambdabot>   Inferred type: a -> a
07:28:55 <davidhouse> > ((*2) >>= (+)) 4
07:28:56 <lambdabot> 12
07:29:15 <davidhouse> > ((*2) >>= (-)) 4
07:29:16 <lambdabot> 4
07:29:56 <davidhouse> > (do { x <- (*2); (+x) }) 4
07:29:59 <lambdabot> 12
07:32:40 <davidhouse> > runReader (do { x <- ask; Reader (+) (x * 2) }) 4
07:32:41 <lambdabot> Couldn't match `Reader r a' against `t -> t1'
07:33:08 <davidhouse> > runReader (do { x <- ask; Reader $ (+) (x * 2) }) 4
07:33:09 <lambdabot> 12
07:33:57 <davidhouse> they're really the same monad.
07:34:42 <toste> if natural language that would be 
07:34:59 <toste> x = x*2; x+=x
07:35:40 <toste> ?
07:37:23 <davidhouse> yeah.
07:37:28 <Lemmih> I wouldn't call that "natural langauge".
07:39:26 <musasabi> How would I parse something without well defined tokens with happy? Most of the token types overlap each other and only the context tells what should be used.
07:40:37 <ihope> @index ask
07:40:37 <lambdabot> Control.Monad.Reader, Control.Monad.RWS
07:40:43 <vincenz> musasabi: trying to make a c parser?
07:40:46 <ihope> @type Control.Monad.Reader.ask
07:40:47 <lambdabot> forall r (m :: * -> *).
07:40:47 <lambdabot>           (MonadReader r m) =>
07:40:47 <lambdabot>           m r
07:40:54 <vincenz> musasabi: easiest way... integrate happy and alex, and make the parser change the table
07:42:16 <musasabi> vincenz: just some RFC based text formats.
07:42:54 <DeliQ> does anybody know, how you can get all the items in a listCtrl (wxhaskell)
07:43:07 <musasabi> So both %monad and %lexer
07:43:21 <musasabi> that might even work
07:44:39 <vincenz> musasabi: use alex and happy integration through the use of a monad, and then basically update your parser tokentable
07:44:52 <DeliQ> nobody ??
07:44:53 <Cale> DeliQ: get myListCtrl items
07:45:06 <DeliQ> that gives [["", ""] ...
07:45:12 <DeliQ> all empty strings
07:45:26 <DeliQ> is it a bug ?
07:45:31 <Cale> odd
07:45:44 <Cale> I don't really know wxHaskell too well
07:45:53 <DeliQ> hmm, thanks anyway!
07:46:02 <DeliQ> could be an older version of wxhaskell
07:46:16 <DeliQ> at home i have the newest
07:46:57 <davidhouse> anyone played with template haskell?
07:47:15 <Cale> I have, a bit
07:47:37 <davidhouse> made anything useful?
07:47:45 <davidhouse> it looks extremely cool.
07:48:12 <norpan> it's useful for deriving your own typeclasses for instance
07:48:16 <Cale> I haven't done anything serious with it.
07:48:44 <davidhouse> norpan, i think it would be useful anywhere you'd like to do some kind of code generation.
07:48:48 <Cale> It would be nice if it could be tied to 'deriving' syntax, so that it could be somewhat hidden from library users.
07:48:58 <musasabi> it is usefull, but needs some extra combinators to make it more easy to use.
07:49:06 <musasabi> -l
07:49:19 <Cale> The staging restrictions are also pretty annoying.
07:50:30 <davidhouse> e.g. i wrote a quick function (in normal haskell) to turn [(Test, a)] into a list of test cases (where you expected the snd from the fst).
07:50:44 <davidhouse> i might have a whack at making it a whole lot more flexible with TH.
07:51:04 <norpan> i've used it to derive accessor functions for tuples
07:51:10 <davidhouse> yeah.
07:52:01 <norpan> like $(nth 4 2) (1,2,3,4) = 2
07:52:32 <norpan> or whatever the syntax is, it was some time ago
07:53:51 <davidhouse> that's one of the examples in the paper, i think
07:54:00 <norpan> maybe
07:54:31 <norpan> hmmm
07:54:34 <araujo> Hi!
07:54:36 * araujo back
07:55:16 <davidhouse> sel i n = [| \ x -> $(caseE [| x |] [alt]) |] where alt = simpleM pat rhs; pat = ptup (map pvar as); rhs = var (as !! (i-1)); as = ["a"++show i | i <- [1..n] ]
07:55:44 <toste> @paste
07:55:45 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
07:56:08 <davidhouse> @where paste
07:56:09 <lambdabot> http://paste.lisp.org/new/haskell
07:56:43 <lisppaste2> toste pasted "code" at http://paste.lisp.org/display/19220
07:56:52 <isaac_> > unsafePerformIO
07:56:53 <lambdabot>  Not in scope: `unsafePerformIO'
07:56:58 <isaac_> ok
07:57:53 <isaac_> Aside from that "function", Haskell seems very safe for random code.
07:57:59 <sjanssen> toste: are you intentionally using parallel list comprehensions?
07:58:22 <sjanssen> isaac_: there is also unsafeCoerce#, and a couple others
07:58:30 <davidhouse> isaac_, that function isn't unsafe in the sense that it'll destroy your hard disk.
07:58:52 <toste> well hum what do you mean by list comprehension ?
07:59:03 <toste> pattern matching ?
07:59:03 <isaac_> I'm wondering when it's safe to use Haskell as a sort of scripting language for untrusted code.
07:59:25 <davidhouse> ah.
07:59:25 <sjanssen> toste: I bet this code doesn't compile
07:59:30 <toste> doesnt ;)
07:59:35 <vincenz> isaac_: most likely when you can ensure there is no IO
07:59:44 <davidhouse> > putStrLn "hello" -- lambdabot blocks IO
07:59:45 <lambdabot> No IO allowed
07:59:55 <davidhouse> IO is the only monad with "real" side effects.
07:59:56 <vincenz> davidhouse: you need more than that, you need to disallow
08:00:01 <vincenz> unsafePerformIO
08:00:02 <toste> i need to change 1 value ((typeAttribut attr)) in a list of typeAttribut
08:00:12 <xerox> hi!
08:00:15 <vincenz> > unsafePerformIO $ putStrLn "hello"
08:00:16 <lambdabot>  Not in scope: `unsafePerformIO'
08:00:18 <sjanssen> toste: what are you trying to accomplish with the list comprehension?
08:00:24 <toste> ^^
08:00:25 <vincenz> @hoogle unsafePerformIO
08:00:26 <lambdabot> Foreign.unsafePerformIO :: IO a -> a
08:01:07 <isaac_> > Foreign.unsafePerformIO
08:01:07 <lambdabot>  Not in scope: `Foreign.unsafePerformIO'
08:01:31 <toste> i need to change 1 value ((typeAttribut attr)) in a list of typeAttribut
08:01:34 <isaac_> > Data.Map.map
08:01:34 <sjanssen> toste: typeAttribut is not a type (you can tell, because it doesn't start with a capital letter)
08:01:35 <lambdabot>  Not in scope: `Data.Map.map'
08:01:46 <davidhouse> > Data.List.map
08:01:47 <lambdabot>  add an instance declaration for (Show ((a -> b) -> [a] -> [b]))
08:01:52 <vincenz> isaac_: lamdbabot only imports certain modules
08:01:54 <sjanssen> toste: disregard that, I misread your statement
08:02:27 <isaac_> ok
08:02:30 <araujo> Does anyone know if there exist a function in the GHC libs for ordering a list of strings by length?
08:02:48 <isaac_> sortBy length ?
08:02:54 <isaac_> sortBy length ? oops
08:02:55 <davidhouse> :)
08:02:59 <davidhouse> almost.
08:02:59 <toste> it's not a type, its like a getter; ATTRIBUT is the type of the list
08:03:04 <davidhouse> sortBy (compare length)
08:03:08 <davidhouse> err
08:03:12 <vincenz> @type sortBy
08:03:13 <davidhouse> sortBy (compare . length)
08:03:14 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
08:03:17 <araujo> Thanks davidhouse 
08:03:21 <vincenz> @hoogle sortBy
08:03:22 <lambdabot> List.sortBy :: (a -> a -> Ordering) -> [a] -> [a]
08:03:22 <xerox> @type compare
08:03:23 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
08:03:46 <vincenz> @hoogle sort
08:03:47 <lambdabot> List.sort :: Ord a => [a] -> [a]
08:03:47 <lambdabot> List.sortBy :: (a -> a -> Ordering) -> [a] -> [a]
08:03:47 <lambdabot> System.Win32.NLS.sORTIDFROMLCID :: LCID -> SortID
08:03:55 <vincenz> @hoogle sortWith
08:03:56 <lambdabot> No matches found
08:04:05 <davidhouse> > sortBy (compare . length) ["321", "4", "58900"]
08:04:05 * vincenz thought there was a sortWith
08:04:06 <lambdabot> Couldn't match `Int' against `[a]'
08:04:27 <vincenz> @pl \x y -> compare (length x) (length y)
08:04:28 <lambdabot> (. length) . compare . length
08:04:28 <xerox> @type sortBy (Control.Monad.liftM2 compare length length)
08:04:30 <lambdabot>   Couldn't match `a -> Ordering' against `Ordering'
08:04:30 <lambdabot>   Expected type: a2 -> a2 -> a -> Ordering
08:04:32 <isaac_> This is where we want that "comparing" function
08:04:38 <Lemmih> > let comparing f a b = f a `compare` f b in sortBy (comparing length) ["Hello","World","!"]
08:04:39 <davidhouse> crap, yeah.
08:04:39 <lambdabot> ["!","Hello","World"]
08:04:49 <vincenz> > sortBy ((. length) . compare . length) ["321", "4", "10000"]
08:04:50 <lambdabot> ["4","321","10000"]
08:04:52 <davidhouse> > sortBy (liftM2 compare length length) ["321", "4", "58900"]
08:04:53 <lambdabot> Couldn't match `a -> Ordering' against `Ordering'
08:05:16 <vincenz> @type join
08:05:18 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
08:05:31 <davidhouse> > join $ Just $ Just "a"
08:05:32 <lambdabot> Just "a"
08:05:42 <vincenz> @join compare lenght
08:05:43 <lambdabot> Not enough privileges
08:05:43 <vincenz> @join compare length
08:05:44 <lambdabot> Not enough privileges
08:05:51 <vincenz> @type join compare length
08:05:52 <lambdabot>   No instance for (Ord ([a] -> Int))
08:05:52 <lambdabot>   arising from use of `compare' at <interactive>:1:5-11
08:06:03 <vincenz> @type join length
08:06:05 <lambdabot>   Couldn't match `[a1] -> a' against `Int'
08:06:05 <lambdabot>   Expected type: [a1] -> [a1] -> a
08:06:10 <vincenz> @type join compare
08:06:11 <lambdabot> forall a. (Ord a) => a -> Ordering
08:06:16 <vincenz> nm
08:06:28 <araujo> thanks Lemmih 
08:06:31 <davidhouse> > join compare "78
08:06:31 <lambdabot>  lexical error in string/character literal
08:06:34 <davidhouse> > join compare 78
08:06:35 <lambdabot> EQ
08:06:38 <davidhouse> heh.
08:06:40 <vincenz> > sortBy ((. length) . compare . length) ["321", "4", "10000"]
08:06:41 <lambdabot> ["4","321","10000"]
08:07:11 <sjanssen> however, this sort is highly inefficient
08:07:16 <davidhouse> @pl \f g x y -> f (g x) (g y)
08:07:17 <lambdabot> join . ((flip . ((.) .)) .) . (.)
08:07:21 <roconnor> @seen Philippa_
08:07:22 <lambdabot> Philippa_ is in #scannedinavian, #haskell-overflow, #haskell-blah and #haskell. I last heard Philippa_ speak 19 hours and 44 minutes ago.
08:07:32 <vincenz> davidhouse: lots of dots
08:07:56 <davidhouse> > sortBy ((join . ((flip . ((.) .)) .) . (.)) compare length) ["321", "4", "10000"]
08:07:57 <lambdabot> ["4","321","10000"]
08:08:01 <vincenz> @pl \g f x y -. f (g x) (g y)
08:08:01 <davidhouse> ta-da :)
08:08:02 <lambdabot> (line 1, column 10):
08:08:02 <lambdabot> unexpected "."
08:08:02 <lambdabot> expecting "->"
08:08:05 <vincenz> @pl \g f x y -> f (g x) (g y)
08:08:06 <lambdabot> flip =<< ((flip . ((.) .)) .) . flip (.)
08:08:16 <vincenz> @pl \f g x y -> f (g y) (g x)
08:08:17 <lambdabot> join . (((.) . flip) .) . (.)
08:08:17 <sjanssen> > map snd $ sortBy (\x y -> compare (fst x) (fst y)) $ map (\l -> (length l, l)  ["321", "4", "10000"]
08:08:18 <lambdabot>  parse error on input `}'
08:08:33 <sjanssen> > map snd $ sortBy (\x y -> compare (fst x) (fst y)) $ map (\l -> (length l, l))  ["321", "4", "10000"]
08:08:35 <lambdabot> ["4","321","10000"]
08:08:44 <davidhouse> there should be a combinator for \f g x y -> f (g x) (g y)
08:08:45 <vincenz> sjanssen: I thought there was a sortwith
08:08:58 <sjanssen> @pl map snd $ sortBy (\x y -> compare (fst x) (fst y)) $ map (\l -> (length l, l))
08:08:59 <roconnor> sjanssen: you are a genius!!!
08:08:59 <lambdabot> map snd (sortBy ((. fst) . compare . fst) (map ((,) =<< length)))
08:09:04 <vincenz> @type compare
08:09:05 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
08:09:11 <vincenz> sorthWith (Ord b) :: (a -> b) -> [a] -> [b]
08:09:19 <vincenz> sorthWith (Ord b) :: (a -> b) -> [a] -> [a]
08:09:36 <vincenz> so you could just do sortWith fst
08:09:36 * roconnor must rewrite his SortUsing and GroupUsing functions.
08:09:40 <vincenz> in sjanssen's example
08:09:53 <pharm> @type GroupUsing
08:09:55 <lambdabot> Not in scope: data constructor `GroupUsing'
08:09:57 <pharm> ?
08:10:01 <vincenz> @hoogle groupUsing
08:10:02 <lambdabot> No matches found
08:10:05 <davidhouse> > let attach f g x y = g x `f` g y in sortBy (attach compare length) ["321", "4", "10000"]
08:10:06 <vincenz> @hoogle Using
08:10:06 <lambdabot> ["4","321","10000"]
08:10:07 <lambdabot> Control.Parallel.Strategies.using :: a -> Strategy a -> a
08:10:13 <roconnor> groupUsing is a function I wrote.
08:10:22 <pharm> Ah, I see...
08:10:26 <vincenz> What is a Strategy?
08:10:31 <roconnor> @hoogle groupWith
08:10:32 <lambdabot> No matches found
08:10:38 <vincenz> @hoogle groupBy
08:10:39 <lambdabot> List.groupBy :: (a -> a -> Bool) -> [a] -> [[a]]
08:10:42 <xerox> davidhouse: what about "stick" :-)
08:10:50 <davidhouse> vincenz, something to do with concurrency :) @docs Control.Parallel
08:10:56 <vincenz> xerox: stick f in g?
08:11:03 <davidhouse> xerox, i just an arbitrary names. all the cool combinators have arbitrary names.
08:11:13 <davidhouse> *chose an arbitrary name
08:11:15 <sjanssen> @oldwiki LicensedPreludeExts
08:11:16 <lambdabot> http://www.haskell.org/hawiki/LicensedPreludeExts
08:11:37 <vincenz> davidhouse: but hnestly
08:11:39 <vincenz> this would be better
08:11:51 <sjanssen> I believe there is a "comparing" function in there
08:12:08 <vincenz> > map fst $ sortUsing snd $ map (\x -> (x, length x))
08:12:09 <lambdabot>  Not in scope: `sortUsing'
08:12:30 <vincenz> sortUsing:: (Ord b) => (a -> b) -> [a] -> [a]
08:12:57 <vincenz> or even
08:13:04 <vincenz> sortUsing length 
08:13:08 <vincenz> :D
08:13:18 <vincenz> except it'd be less efficient
08:13:52 <isaac_> depends on the implementation
08:13:53 <sjanssen> what we need is a general Schwartzian transform function (that is also discussed on the oldwiki)
08:13:57 <vincenz> > let sortUsing f l = sortBy (\a b -> compare (f a) (f b) in sortUsing length ["a", "cde", "bd"]
08:13:58 <lambdabot>  parse error on input `in'
08:14:07 <vincenz> > let sortUsing f l = sortBy (\a b -> compare (f a) (f b)) in sortUsing length ["a", "cde", "bd"]
08:14:08 <lambdabot>  add an instance declaration for (Show ([[a]] -> [[a]]))
08:14:17 <vincenz> > let sortUsing f = sortBy (\a b -> compare (f a) (f b)) in sortUsing length ["a", "cde", "bd"]
08:14:18 <lambdabot> ["a","bd","cde"]
08:15:00 <roconnor> sortUsing f = map fst $ sortUsing snd $ map (\x -> (x, f x))
08:15:03 <roconnor> ;)
08:15:06 <norpan> and that will call f on the elements how many times?
08:15:15 * davidhouse thinks Bool should be a monad.
08:15:22 <vincenz> roconnor: right, more eficient :)
08:15:23 <davidhouse> newtype BoolM a = BM Bool
08:15:49 * vincenz peers at davidhouse 
08:15:55 <sjanssen> norpan: ostensibly O(n log n) times
08:16:11 <davidhouse> instance Monad BoolM where { return = const True; x >>= f = if x then f x else x }
08:16:14 <norpan> exactly, but roconnor gave a better version
08:16:29 <davidhouse> a bit like Maybe, but for when you're not interested in the computation's output.
08:16:36 <davidhouse> only whether it succeeds or fails
08:16:37 <vincenz> davidhouse: Maybe ()
08:16:45 <davidhouse> awkward.
08:17:46 <roconnor> my version is _NOT_ better. :)
08:17:51 <toste> ok, simple exemple, if i want to change a value of a list i input : foo x Action(s l) (i want to change s so it equal x and then return changed Action (s l))
08:18:12 <norpan> roconnor: it is because it will call f only once for each element
08:18:41 <norpan> time to go
08:18:42 <norpan> bye
08:18:43 <sjanssen> toste: you can't change x, values are immutable.  You can make a new s, and then return a new Action containing it
08:18:53 <roconnor> > let sortUsing f = map fst $ sortUsing snd $ map (\x -> (x, f x)) in sortUsing length ["a", "cde", "bd"]
08:18:54 <lambdabot> Couldn't match `([(a1, b1)] -> [((a1, b1), b1)]) -> [(a, b)]' against `[a]'
08:19:01 <vincenz> @type ((+!)&&&id)
08:19:03 <lambdabot> Not in scope: `+!'
08:19:03 <vincenz> @type ((+1)&&&id)
08:19:05 <lambdabot> forall b. (Num b) => b -> (b, b)
08:19:08 <toste> damn
08:19:35 <vincenz> http://rafb.net/paste/results/56G1dy23.html
08:19:37 <toste> so i would basibly have to remove Action(s l) from the list of ACTION and then replace it with a new
08:19:37 <roconnor> hmmm
08:19:39 <davidhouse> mkPair = id &&& id -- nice little function :)
08:19:41 <roconnor> monomorphism restriction.
08:19:50 <davidhouse> @pl \x -> (x, x)
08:19:51 <lambdabot> join (,)
08:20:02 <davidhouse> i prefer mine :)
08:20:56 <vincenz> @type (+1) *** (-1)
08:20:57 <lambdabot> forall b b' c'.
08:20:57 <lambdabot>       (Num b, Num (b' -> c')) =>
08:20:57 <lambdabot>       (b, b') -> (b, c')
08:21:11 <roconnor> > let sortUsing :: forall a b, (Ord b) => (a -> b) -> [a] -> [a]; sortUsing f = map fst $ sortUsing snd $ map (\x -> (x, f x)) in sortUsing length ["a", "cde", "bd"]
08:21:12 <lambdabot>  parse error on input `,'
08:21:12 <vincenz> > (+1) *** (-1) $ id &&& id $ 1
08:21:12 <davidhouse> > let sortUsing f = map fst $ sortBy snd $ map (f &&& id) in sortUsing length ["a", "cde", "bd"]
08:21:13 <lambdabot>  add an instance declaration for (Num (a -> c'))
08:21:13 <lambdabot>   Occurs check: cannot construct the infinite type: t = (a, t -> t1)
08:21:13 <lambdabot>   Expected type: (a, t -> t1) -> (a, t -> t1) -> Ordering
08:21:13 <lambdabot>   Inferred type: (a, t -> t1) -> t -> t1
08:21:14 <vincenz> spaceships!
08:21:21 <xerox> > ((+1) *** (subtract 1)) (-1,1)
08:21:22 <lambdabot> (0,0)
08:21:34 <davidhouse> > let sortUsing f = map fst . sortBy snd . map (f &&& id) in sortUsing length ["a", "cde", "bd"]
08:21:34 <roconnor> > let sortUsing :: forall a b. (Ord b) => (a -> b) -> [a] -> [a]; sortUsing f = map fst $ sortUsing snd $ map (\x -> (x, f x)) in sortUsing length ["a", "cde", "bd"]
08:21:35 <lambdabot>   Occurs check: cannot construct the infinite type: t = (a, t -> t1)
08:21:35 <lambdabot>   Expected type: (a, t -> t1) -> (a, t -> t1) -> Ordering
08:21:35 <lambdabot>   Inferred type: (a, t -> t1) -> t -> t1
08:21:35 <lambdabot>  parse error on input `=>'
08:21:50 <vincenz> roconnor: recursive!!1
08:21:50 * xerox hears lambdabot clashing with asteroids
08:22:16 <vincenz> let sortUsing f l = map fst $ sortBy (\a b -> compare (snd a) (snd b)) $ map (id&&&f) l in sortUsing length ["abc", "de", "f"]
08:22:18 <davidhouse> > let sortUsing f = map snd . sortBy fst . map (f &&& id) in sortUsing length ["a", "cde", "bd"]
08:22:19 <lambdabot>   Occurs check: cannot construct the infinite type: t = (t -> t1, b)
08:22:19 <lambdabot>   Expected type: (t -> t1, b) -> (t -> t1, b) -> Ordering
08:22:19 <lambdabot>   Inferred type: (t -> t1, b) -> t -> t1
08:22:20 <vincenz> > let sortUsing f l = map fst $ sortBy (\a b -> compare (snd a) (snd b)) $ map (id&&&f) l in sortUsing length ["abc", "de", "f"]
08:22:21 <lambdabot> ["f","de","abc"]
08:22:23 <vincenz> > let sortUsing f l = map fst $ sortBy (\a b -> compare (snd a) (snd b)) $ map (id&&&f) l in sortUsing length ["abc", "de", "f"]
08:22:24 <lambdabot> ["f","de","abc"]
08:22:27 <vincenz> \o
08:22:33 <davidhouse> > let sortUsing f = map snd . sortBy (compare . fst) . map (f &&& id) in sortUsing length ["a", "cde", "bd"]
08:22:34 <lambdabot>   Occurs check: cannot construct the infinite type: a = (a, b)
08:22:34 <lambdabot>   Expected type: (a, b) -> (a, b) -> Ordering
08:22:34 <lambdabot>   Inferred type: (a, b) -> a -> Ordering
08:22:58 <vincenz> davidhouse: compare . fst only applies fst to first param
08:23:00 <xerox> Someone should open #haskell-lambdabot-playgarden :-)
08:23:00 <davidhouse> yaeh.
08:23:11 <davidhouse> you'd have to use attach again
08:23:16 <davidhouse> xerox: `ghci` :)
08:23:44 <vincenz> davidhouse: lambdabot without --online
08:24:23 <davidhouse> does offline lambdabot permit IO?
08:24:46 <vincenz> dunno
08:25:23 <davidhouse> @where dons
08:25:24 <lambdabot> I know nothing about dons.
08:25:36 <vincenz> @who dons
08:25:37 <lambdabot> Maybe you meant: echo ghc what wn
08:25:48 <vincenz> hmm
08:25:50 <vincenz> @ghc
08:25:51 <lambdabot>  panic! (the `impossible' happened, GHC version 6.4)
08:26:10 <Lemmih> @ghc
08:26:10 <lambdabot>  parse error in data/newtype declaration
08:26:22 <davidhouse> @ghc
08:26:23 <lambdabot>  Use -fglasgow-exts to allow multi-parameter classes
08:26:26 <davidhouse> ?
08:26:30 <Lemmih> @quote
08:26:30 <lambdabot> SyntaxNinja says: I think that the compiler authors will fly here from England just to kill me if I did that
08:26:58 <xerox> davidhouse: @ghc will spit out surreal but existent GHC error messages.
08:27:01 <Lemmih> Anyone remember what SyntaxNinja was referring to?
08:27:28 <davidhouse> well, GHC wasn't written in england
08:27:41 <davidhouse> the clue is that it's named the GLASGOW haskell compiler :)
08:28:10 <sjanssen> davidhouse: perhaps the Simons live in England?
08:28:13 <integral> except SPJ is at Cambridge now
08:28:21 <vincenz> @quote+ xerox says: @ghc will spit out surreal but existent GHC error  messages.
08:28:22 <lambdabot> xerox says: @ghc will spit out surreal but existent GHC error  messages. hasn't said anything memorable
08:28:45 <vincenz> haha
08:28:48 <vincenz> @quote+ bush
08:28:48 <lambdabot> bush hasn't said anything memorable
08:29:45 <sjanssen> @. elite keal
08:29:46 <lambdabot> need TO P|an a fI3|D7riP to phr3d3RICx b. MaNCofph 0f freEzcALE $e/\/\i(ONDU(+Or
08:32:51 <roconnor> @elite djinn ((((A->B)->A)->A)->B)->B
08:32:52 <lambdabot> djInn ((((a->b)->a)->a)->8)->b
08:33:00 <roconnor> @. elite djinn ((((A->B)->A)->A)->B)->B
08:33:01 <lambdabot> f A = A (\ b -> b (\ ( -> a (\ _ -> C)))
08:33:24 <roconnor> @. pf djinn ((((A->B)->A)->A)->B)->B
08:33:25 <lambdabot> compose module failed: Parse error: "pf"
08:33:32 <roconnor> @. pl djinn ((((A->B)->A)->A)->B)->B
08:33:33 <lambdabot> f = ap id (flip id . (. const))
08:33:53 <vincenz> @. type djinn  ((((A->B)->A)->A)->B)->B
08:33:54 <lambdabot> parse error on input `='
08:37:47 <NameTab> can anyone explain to me why ChoiseLists have a big whitespace on my Linux box and not on my Windows box?
08:38:46 <RHE123> (in wxHaskell, right NameTab? :P)
08:39:05 <NameTab> hehe, yes of course ;)
08:39:31 <sjanssen> roconnor: ooh, that's neat!
08:41:19 <roconnor> what is neat?
08:41:31 <xerox> It is an adjective.
08:41:31 <sjanssen> composing pl and djinn
08:41:38 <roconnor> :-)
08:42:22 <Oejet> Hi, I've installed haskell-mode-2.1, which includes an inferior GHCi mode, which seems to superseede the old one, but where did all the key-commands go?  Should I really type "M-x inferior-haskell-load-file" every time I want the buffer evaluated?
08:42:59 <xerox> Oejet: C-c C-l
08:45:35 <vincenz> Oejet: ALT+TAB; kill -9 emacs; cd /; sudo rm -rf `find . | grep emacs`; gvim
08:46:40 <xerox> Oejet: I also like M-x run-haskell.
08:48:43 <Oejet> xerox: Ah, thanks.  vincenz: What is the command to get an inferior Haskell mode in Vim?
08:49:13 <vincenz> inferior?
08:49:19 <sjanssen> Oejet: the mode is so inferior, it doesn't even exist
08:49:26 <vincenz> why choose inferior when you can use superior ghci!
08:50:54 <xerox> Oejet: vim does provide some kind interaction too, but I never investigated those arts known as dons-fu.
08:52:31 <neologism> vincenz: seems like you've chosen your editor :)
08:53:47 * vincenz tried emacs before
08:53:54 <vincenz> I just didn't sync with it
08:54:29 <vincenz> besides when you're very effective with one editor, even if you force yourself, it's hard to learn the other cause you get frustrated at first with how slow stuff goes
08:55:54 <musasabi> Are the semantics of: case error "foo" of _ | (1+1==2) -> 1; 2 -> 5 well defined ?
08:56:13 <musasabi> i.e. is a case pattern always evaluated in a lazy fashion.
08:58:32 <dcoutts> musasabi, I don't understand your concern
08:58:52 <dcoutts> that expression always evaluates to 1 right?
08:59:01 <xerox> Doesn't error, being a bottom, disrupt the normal flow of the computation anyway?
08:59:07 <dcoutts> the _ | True pattern overlaps the 2 pattern
08:59:17 <xerox> Uh, laziness.
08:59:53 <dcoutts> oh I see, hmmm
09:00:09 <dcoutts> > case error "foo" of _ | (1+1==2) -> 1; 2 -> 5
09:00:11 <lambdabot> 1
09:00:18 <dcoutts> hugs says the same
09:00:28 <dcoutts> so yeah, it's lazy
09:00:42 <xerox> Yep.
09:01:39 <Lemmih> Prelude GHC.Exts> let f 10# = 20# in case f 20# of _ -> ()
09:01:39 <Lemmih> *** Exception: <interactive>:1:4-14: Non-exhaustive patterns in function f
09:03:42 <toste> can i use where in a simple funtion ?
09:04:17 <Oejet> Sure.
09:06:17 <xerox> '#' == unboxed, right?
09:06:44 <Lemmih> Kinda.
09:07:49 <xerox> Lemmih: is it the difference that makes that idiom fail?
09:07:57 <Lemmih> xerox: Yes.
09:12:57 <xerox> This evaluates to IO (): let f 10 = 20 in evaluate (case f 20 of _ -> () `using` rwhnf)
09:20:02 <isaac_> Vim is confused by (\(a,b) -> whatever)  -- it doesn't match the parentheses correctly because it thinks \( doesn't match )
09:20:25 <isaac_> Putting a space between \ and ( makes it understand.
09:20:57 <xerox> That's right.
09:21:17 <isaac_> Is it possible to change that behaviour?
09:21:27 <earthy> um. yes
09:21:32 <earthy> don't ask me how though
09:21:52 <xerox> That question reduces to wether is it possible to fix a bug somewhere in the vi framework for syntax colouring.
09:22:40 <vincenz> or the syntax file for haskel
09:22:47 <vincenz> xerox: don't overgeneralize
09:22:52 <isaac_> I don't think it has to do with syntax coloring because % works even in an unknown-type file.
09:23:12 <earthy> it is to do with the syntax highlighting files
09:23:17 <isaac_> And I tried looking in the haskell vim hilighting file.
09:23:17 <earthy> which I meant to look into anyway
09:23:35 <isaac_> `locate haskell.vim`
09:23:41 <earthy> since there's some things wrong with lhaskell.vim people mentioned
09:25:40 <musasabi> dcoutts: just wanted to check that it is guaranteeded that the case pattern will be evaluated lazily.
09:25:56 <dcoutts> musasabi, right
09:25:59 <musasabi> makes for nice code.
09:26:10 <dcoutts> indeed
09:26:30 <musasabi> case head xs of _ | null xs -> ...; 'a' -> ...; 
09:27:07 <isaac_> case xs of [] -> ...; ('a':_) -> ...;
09:27:16 <musasabi> not as pretty.
09:27:25 <musasabi> and I am using a datype for which that won't work.
09:28:26 <xerox> musasabi: yay, that's pretty!
09:28:28 <neologism> maintainter of the vim haskell syntax is haskell-cafe@haskell.org
09:28:59 * xerox overgeneralization was overly right ;-)
09:29:12 <Lemmih> neologism: I think I know that guy... (:
09:31:24 <Ulfalizer> there seems to be something wrong with the ordinary haskell.vim as well. code sometimes gets highlighted inside comments, so that you have to ctrl-l to fix it.
09:32:11 <isaac_> That's because vim isn't very good at keeping track of distant matching delimiters.
09:32:23 <isaac_> (syn region)
09:32:34 <isaac_> I think
09:32:38 <Ulfalizer> i haven't seen it with /* */ in c though
09:32:50 <Ulfalizer> at least not as far as i can remember
09:33:47 <Ulfalizer> it's nice to see vim 7 seems to be on its way :)
09:36:52 <jip> hi Lemmih 
09:37:11 <Lemmih> Hiya jip. How's code?
09:37:17 <neologism> Ulfalizer: I dont see how vim7 helps haskell :)
09:37:51 <jip> Lemmih: i think i'm gonna switch my ghc to ghc 6.5 and then i'll try hide :)
09:38:00 <Lemmih> jip: You haven't made another devlog entry for a couple of days.
09:38:14 <xerox> jip: how's omegagbc?
09:39:20 <jip> xerox: haven't worked on it since creating that animated gif. gonna do a new post to the devlog soon and then do some more work
09:39:39 <xerox> Which anymated gif?
09:40:19 <jip> http://img88.imageshack.us/img88/6433/anim6at.gif
09:40:30 <Ulfalizer> neologism: nah, i just meant it's great that vim 7 is on its way, since it's such a nice editor
09:40:35 <neologism> ah.. :)
09:42:38 <xerox> jip: haha, that's very nice :-)
09:45:28 <lispy> huh, so my patch format is actually slower to process than the current one
09:45:35 <lispy> i find that very odd
09:59:10 <NameTab> are there by any chance any wxHaskell users online?
09:59:26 <NameTab> does somebody have a clue why with this example: http://cvs.sourceforge.net/viewcvs.py/wxhaskell/wxhaskell/samples/wx/Controls.hs?view=markup
09:59:43 <NameTab> the type of logSelect is commented, I know the compile crashes when you uncomment it, but what's wrong?
10:03:47 <isaac_> This isn't wrong, but the labels parameter seems to be unused...
10:04:12 <isaac_> By 'compile crashes', do you just mean a compile error, or the compiler actually crashing?
10:04:24 <NameTab> ehh, compile error
10:04:32 <NameTab> using the flag -fglasgow-exts prevents it
10:04:36 <NameTab> then it works
10:04:45 <isaac_> Oh, multi-param type classes 
10:04:55 <isaac_> ?
10:05:10 <isaac_> Items w String
10:05:18 <NameTab> I suppose, but what does it mean sort of?
10:05:19 <toste> hum
10:05:34 <toste> @where paste
10:05:34 <lambdabot> http://paste.lisp.org/new/haskell
10:05:48 <lisppaste2> toste pasted "code" at http://paste.lisp.org/display/19224
10:07:11 <lisppaste2> toste annotated #19224 with "code" at http://paste.lisp.org/display/19224#1
10:10:31 <toste> 	| (typeAttribut att1) == att = (Action s x) 
10:10:31 <toste> 		where x :: ATTRIBUT = [(typeAttribut att1) val,att2,att3,att4,att5,att6,att7]
10:10:33 <xerox> NameTab: are you asking what "multi-parameter type class" mean?
10:10:35 <toste> can i say that ?
10:11:24 <Lemmih> toste: Well, 'x' is a list, not an ATTRIBUT.
10:11:40 <Lemmih> toste: And the syntax is 'x :: type; x = ...'.
10:11:50 <xerox> toste: do you want to make heterogeneous lists?
10:11:57 <toste> yes
10:12:07 <xerox> Haskell lists are homogeneous.
10:12:28 <xerox> You might want to look at HList.
10:13:12 <toste> hum no sorry :p
10:13:13 <xerox> Or roll up your own datatype if the number of different types of the values of the list are limited.
10:13:24 <NameTab> xerox: yes
10:13:30 <toste> i have my own datatype already
10:13:43 <toste> u can see it in the paste : http://paste.lisp.org/display/19224#1
10:14:00 <Lemmih> toste: You're trying to replace a value in a list?
10:14:10 <toste> iyes
10:14:12 <xerox> NameTab: a multi-parameter typeclass is a cartesian product of typelcasses.
10:14:45 <Lemmih> toste: Don't use find. Just talk through the list, replacing the value in question.
10:14:46 <NameTab> err
10:14:54 <xerox> NameTab: i.e. it relates a number of type to a set of types.
10:15:05 <xerox> s/type/types/1
10:15:18 <Lemmih> toste: If it isn't in the list then it simply won't be replaced.
10:15:50 <toste> yes, ill use otherwise to return unchanged value
10:16:08 <Lemmih> toste: Yeah, don't do that.
10:16:10 <xerox> NameTab: it's simpler than it sounds, Num a means that the type a is in the set of types called Num, Foo a b means that a and b are jointly in the set of types Foo, if you want.
10:16:21 <int-e> ok, what's wrong with  map (\x -> if x == old then new else x) ? can the list have duplicate entries?
10:16:45 <toste> hum, what shall i do then ;p
10:16:54 <isaac_> http://wxhaskell.sourceforge.net/doc/Graphics.UI.WX.Classes.html -> see class Items
10:17:10 <Lemmih> toste: Walk through the list, replacing the value in question when you hit it.
10:17:30 <toste> i tought parameter where "immunable" 
10:18:00 <isaac_> class Items w a | w -> a   means that if you know the type 'w', you also know the type 'a'
10:18:07 <NameTab> xerox: right, I kind of get what you are saying I think, still don't really know what the use really is, but for now: it works, so first I'll finish my assignment ;)
10:18:19 <Lemmih> toste: replace val attr [] = []; replace val attr (x:xs) | typeAttribut x == attr = val:xs | otherwise = x:replace val attr xs
10:21:20 <toste> yea, but the problem is, val is a part of this type. so it won't work
10:21:43 <toste> | typeAttribut x == attr = (attr val):xs 
10:22:08 <Lemmih> 'attr' is a function?
10:24:20 <toste> nop, its a infixe of type ATTRIBUT
10:24:31 <toste> like Name "NASDAC"
10:24:36 <toste> attr is Name
10:24:46 <roconnor> @seen Philippa_
10:24:47 <lambdabot> Philippa_ is in #scannedinavian, #haskell-overflow, #haskell-blah and #haskell. I last heard Philippa_ speak 22 hours, 1 minute and 24 seconds ago.
10:25:20 <Lemmih> toste: So it /is/ a function? 'Nom', 'Place', 'Prix', etc are all functions.
10:25:49 <toste> data ATTRIBUT = Nom String | Place String | Prix Float |
10:25:50 <Lemmih> toste: And you want to check whether something is a specific type of ATTRIBUT?
10:26:14 <Lemmih> toste: 'Nom' is a function of type :: String -> ATTRIBUT.
10:26:55 <toste> ya ur right
10:27:59 <Lemmih> Perhaps you want to define 'isNom (Nom _) = True; isNom _ = False'?
10:28:32 <xerox> NameTab: a nice extension to multi parameter typeclasses is functional dependencies.  They do make lots of sense.
10:28:41 <toste> nah, i basicly need to parse (attr val) into a ATTRIBUT type
10:29:49 <Lemmih> toste: Try writing the type of 'foo'.
10:30:19 <roconnor> can I use lambdabot to leave messages for people?
10:31:30 <Lemmih> toste: Can you imagine the type of the function you want?
10:31:47 <toste> sure
10:32:06 <Lemmih> toste: What would it look like?
10:32:08 <xerox> NameTab: for example |class Foo a b | a -> b where ...| means that there will be one possible b type for each a type instantiated.  I.e. 'a chooses b'.
10:32:15 <toste> foo :: Show a => String -> ACTION -> a -> ACTION	
10:32:37 <roconnor> associated types!
10:33:33 <Lemmih> toste: Ah, and if the first argument is "Prix' then you want the third argument to be a Float?
10:36:17 <toste> yes
10:36:30 <Lemmih> toste: Re-think what you're trying to do.
10:36:36 <toste> i guess ;p
10:37:17 <Lemmih> How about 'foo :: ATTRIBUT -> ACTION -> ACTION'?
10:37:54 <Lemmih> toste: foo attr (Action s l) = Action s (replace attr l)
10:39:18 <roconnor> @slap lambdabot
10:39:22 * lambdabot smacks lambdabot about with a large trout
10:41:18 <jip> @slap president bush
10:41:19 * lambdabot slaps president bush
10:41:28 <}ElectrowolF{>  " parse error on input `=' "  on " newCal = (..... "  ??
10:42:14 <}ElectrowolF{> while trying to do an if-then-else in a where..
10:42:18 <}ElectrowolF{> should be possible, right?
10:43:12 <Lemmih> > x where x = if True then 10 else 20
10:43:15 <lambdabot> 10
10:43:23 <roconnor> @wiki DoAndIfThenElse
10:43:24 <lambdabot> http://www.haskell.org/haskellwiki/DoAndIfThenElse
10:43:27 <roconnor> oops
10:43:36 <roconnor> }ElectrowolF{: http://hackage.haskell.org/trac/haskell-prime/wiki/DoAndIfThenElse
10:43:45 <}ElectrowolF{> let's see
10:44:02 <}ElectrowolF{> not realy what i mean
10:44:12 <}ElectrowolF{> *paste*
10:44:12 <}ElectrowolF{> >              where
10:44:12 <}ElectrowolF{> >               if d == 0
10:44:12 <}ElectrowolF{> >                then do
10:44:12 <}ElectrowolF{> >                 newCal = (
10:44:13 <lambdabot>  parse error on input `where'
10:44:13 <lambdabot>  parse error on input `}'
10:44:13 <lambdabot>  parse error on input `then'
10:44:13 <lambdabot>  parse error on input `='
10:44:16 <}ElectrowolF{> lol
10:44:17 <}ElectrowolF{> ;p
10:44:35 <Lemmih> ...
10:44:44 <roconnor> you need to say "let newCal =..." 
10:44:52 <roconnor> you need to use the word let in a do block
10:45:02 <}ElectrowolF{> what if i remove the do ?
10:45:03 <Lemmih> No, he doesn't. It's completely wrong.
10:45:12 <}ElectrowolF{> hmm
10:45:21 <roconnor> oh
10:45:28 <}ElectrowolF{> should i make the newCal part in a new function and let the where be part "after" the ifthenelse?
10:45:37 <roconnor> ah
10:45:40 <}ElectrowolF{> and let that newcal be in the where ?
10:45:50 * roconnor reads the code more carefully
10:46:10 <}ElectrowolF{> because i want to use 2 diffrent newcal functions, depending on the value of d
10:46:26 <}ElectrowolF{> if d == 0 then newcal1 else newcal2   
10:46:28 <}ElectrowolF{> where 
10:46:32 <Lemmih> }ElectrowolF{: newCal = if d == 0 then ... else ...
10:46:33 <}ElectrowolF{> newcal1 :: etc etc
10:46:34 <}ElectrowolF{> ?
10:46:43 <}ElectrowolF{> hmm
10:48:02 <roconnor> Philippa_: If you get this, I'll be in Wanker's bar for the next while.
10:48:04 <}ElectrowolF{> Ok, modules loaded: Main.
10:48:06 <}ElectrowolF{> whee
10:48:36 <}ElectrowolF{> "Ok, modules loaded: Main." is almost my most beloved sentence atm.. "want a beer?" still comes in first thou..
10:48:55 <}ElectrowolF{> thank you, Lemmih
10:54:34 <toste> i think i should copy all element from my list of ATTRIBUT and then paste the att ++ val
10:55:24 <}ElectrowolF{> @seen doaitse
10:55:25 <lambdabot> I saw doaitse leaving #haskell 1 day, 2 hours, 23 minutes and 22 seconds ago, and .
10:57:48 <fraxtal> the haskell doesn't sleep
10:59:57 <toste> hum
11:00:14 <toste> well yea, its working like a charm exept i can't make the ATTRIBUT list
11:00:23 <toste> (Action s [(att val),x2,x3,x4,x5,x6,x7])
11:01:25 <toste> (att val) is [CHAR] ;(
11:04:41 <toste> how could i make (att val) of type ATTRIBUT 
11:04:55 <toste> data ATTRIBUT = Nom String | Place String | Prix Float ...
11:05:03 <Lemmih> Did you read what I wrote to you?
11:05:15 <toste> hum
11:05:25 <Cale> well, the only way to change the type would be to change the type of att
11:05:26 <toste> yes, but i have to keep this signature
11:05:37 <Lemmih> toste: Why?
11:05:50 <toste> well, because the teacher gave it to us
11:07:47 <toste> *** Type           : [Char]
11:07:47 <toste> *** Does not match : a -> b   
11:08:17 <Lemmih> Either your teacher is deranged or you copied it wrong.
11:08:49 <Lemmih> toste: You could do (read (attr ++ " " ++ show val)).
11:09:14 <toste> she is retarded :o
11:09:47 <toste> working mate
11:09:52 <toste> thx alot !
11:10:30 <toste> wow u r the skills hehe
11:12:09 <aufrank> dons: ping
11:12:41 <aufrank> lispy: ping
11:17:15 <lispy> ping
11:17:19 <lispy> sup?
11:17:58 <aufrank> hey, I asked about possibly working on some perl/haskell/darcs stuff as a SoC project
11:18:05 <aufrank> and you guys said you should add it to the list
11:18:10 <aufrank> is the list available somewhere?
11:18:49 <xerox> aufrank: I'm going to post to the Haskell mailing list in minutes
11:19:23 <aufrank> oh, neat
11:19:29 * aufrank goes to find the archive
11:19:37 <lispy> aufrank: http://thread.gmane.org/gmane.comp.lang.haskell.cafe/12452/focus=12452
11:20:02 <aufrank> grazzi
11:20:06 <lispy> np
11:20:18 <xerox> aufrank: Italiano?=
11:20:54 <aufrank> no, but I pretend
11:21:04 <xerox> (-:
11:21:05 <lispy> aufrank: i had assumed you sent that mail to the haskell-cafe list :)
11:21:10 <aufrank> I drop whatever words I know in whichever languages whenever I get the chance
11:21:28 <aufrank> lispy-- I'm not on any of the haskell lists yet
11:21:40 <aufrank> just joined the darcs ones this morning
11:21:43 <xerox> Okay, let me ginish it.
11:21:46 <xerox> finish, rather.
11:21:50 <mathrick> how can I make a where clause that's local to just one guard (instead of one function definition block) ?
11:23:59 <SamB> mathrick: um, you need to use let
11:24:09 <xerox> > lef f n | n < m where { m = n + 2 } = "okay?" in f 1
11:24:09 <aufrank> I'm about to meet with my advisor to talk over summer plans
11:24:10 <lambdabot>  parse error on input `|'
11:24:15 <xerox> Nah :-)
11:24:18 <SamB> what?
11:24:29 <mathrick> SamB: blÃ¦h
11:24:43 <toste> so read is a parser to all
11:24:54 <SamB> toste: say what?
11:24:56 <toste> it checks what haskell need to compile and parse it ?
11:25:19 <lispy> aufrank: which one? darcs-users, darc-devel and darcs-conflicts?
11:25:37 <SamB> toste: oh, that
11:25:40 <aufrank> lispy: I didn't join conflicts, and haven't sent messages to any of them
11:25:55 <mathrick> so maybe an another question, how can I lay out let clause so that `let' and and `in' are on different lines?
11:26:24 <SamB> toste: it does parse whatever type is needed, yes
11:26:26 <lispy> iirc, line up the 'in' with the 'let'
11:26:37 <toste> francais, english, espaniol
11:27:13 <SamB> > let f n | n < m where { m = n + 2 } = "okay?" in f 1
11:27:14 <lambdabot>  parse error on input `where'
11:27:34 <aufrank> xerox == duncan couts?
11:27:42 <toste> > read "124"
11:27:43 <astrolabe> no
11:27:43 <lambdabot> Add a type signature
11:27:47 <toste> > read "124"::Int
11:27:48 <xerox> /WHOIS xerox
11:27:48 <lambdabot> 124
11:28:04 <astrolabe> dcouts = duncan couts?
11:28:10 <xerox> Yes.
11:28:13 <toste> i have don't have to specify the type tho ?
11:28:17 <aufrank> that would make more sense, I guess :)
11:28:17 <xerox> (Two 't's.)
11:28:23 <toste> i mean, if i put it in a funtion
11:28:27 <SamB> who is this dcouts? I've seen dcoutts though...
11:28:52 <astrolabe> toste: I depends whether the compiler can deduce it's an int.
11:28:56 <astrolabe> *It
11:29:23 <lispy> @type read . show
11:29:25 <lambdabot> forall a a1. (Read a, Show a1) => a1 -> a
11:29:33 <SamB> you only have to specify the type if the compiler complains that it can't figure out which type to use
11:29:54 <lispy> (read . show) 1
11:29:58 <lispy> > (read . show) 1
11:29:59 <lambdabot> Add a type signature
11:30:05 <lispy> like that
11:30:10 <lispy> > (read . show) 1 :: Int
11:30:11 <lambdabot> 1
11:30:23 <lispy> > (read . show) 1 :: Float
11:30:24 <lambdabot> 1.0
11:30:39 <lispy> > (read . show) 1.0 :: Int
11:30:40 <lambdabot> Exception: Prelude.read: no parse
11:30:53 <dcoutts> SamB ?
11:31:06 * lispy directs dcoutts to aufrank
11:31:18 <dcoutts> aufrank, xerox and I are not the same :-)
11:31:24 <aufrank> got it
11:31:30 <Cale> > show . read $ "1"
11:31:31 <lambdabot> Add a type signature
11:31:32 <lispy> dcoutts: liar! ;)
11:31:32 <dcoutts> aufrank, but we both work on cairo/gtk2hs
11:31:40 <dcoutts> lispy, hah hah!
11:31:42 <Cale> That case is more problematic :)
11:32:20 <astrolabe> Has anyone seen dcouts and lispy at the same time?
11:32:26 <astrolabe> er xerox
11:32:30 * aufrank 's amateur-ness feels magnified with all of these real experts around =P
11:32:44 <SamB> probably
11:32:57 <lispy> astrolabe: i've seen dcoutts and lispy at the same time
11:33:03 * lispy looks in a mirror
11:33:04 <xerox> aufrank: amateurs are happily welcome everytime!
11:33:04 <dcoutts> me too!
11:33:28 <dcoutts> xerox, sent that SoC thing yet?
11:33:30 <lispy> astrolabe: i've also seen lispy and xerox at the same time
11:33:38 <xerox> dcoutts: finishing it up now.
11:33:45 <dcoutts> xerox, excelent
11:33:47 <xerox> (In this very moment)
11:34:02 <aufrank> dcoutts: that's why you were pinged by me-- I thought you and xerox might be the same person since you posted that something would be forthcoming and he said he was working on it
11:34:24 <dcoutts> aufrank, I guessed as much
11:34:34 <dcoutts> we were colaberating on it
11:34:50 <dcoutts> or rather xerox is doing all the work and I'm just cheerleading :-)
11:35:01 <dcoutts> go xerox go!
11:35:01 <aufrank> well rah rah from me too
11:35:01 <lispy> one more person and  you qualify as a conspiracy :)
11:35:07 * xerox hugs everybody in the channel :-D
11:35:14 <xerox> They call me for dinner, I'll be right back.
11:35:23 <lispy> go!
11:35:30 <lispy> eat till you explode then write s'more....
11:36:00 * lispy explodes for good measure
11:36:54 * dcoutts nearly exploded after a couple meals on his recent trip to Italy
11:37:05 <dcoutts> sooo much good food in Italy
11:40:16 <pirroH> mediterranean diet
11:40:49 <pirroH> a little too fat, but so tasty
11:46:30 * lispy doesn't understand how reading lines as a big chunk can have worse performance that parsing that same data character by character
12:01:00 <Philippa_> roconnor: 'lo
12:01:16 <roconnor> hey
12:01:41 <Philippa_> 'fraid I'll have to pass on pubbage, having one of those days. How's yours been?
12:01:54 <roconnor> np
12:02:15 <roconnor> Conference is over, so now I'm worrying about my conference next week
12:09:23 <roconnor> So associated types don't seem to be able to capture "class Wedge a b c | a b -> c,  c a -> b, b c -> a where ..."
12:09:33 <roconnor> or at least I don't see how to use them to do this.
12:10:17 <roconnor> Philippa_: BTW, I'm here tomorrow too.
12:21:32 <mathrick> http://pastebin.com/673891
12:21:44 <mathrick> could anyone check why it doesn't want to parse the marked line?
12:22:04 <mathrick> I've been careful to make where line up with |'s from guards
12:22:19 * Cale looks
12:23:35 <ChilliX> mattam: you seem to have two wheres for one equation
12:23:45 <mathrick> ChilliX: you mean me?
12:23:49 <ChilliX> namely the last of delete
12:23:59 <ChilliX> oops, yes, stupid nick completion
12:24:24 <mathrick> ChilliX: /set completion_amount 0
12:24:34 <ADEpt> hello. Anybody uses nntp to read haskell mailing lists off gmane?
12:24:36 <Cale> er, yeah
12:24:38 <ChilliX> The where with extractMax and the last one belong to the same equation
12:24:50 <ChilliX> ie, you need to join them into one where clause
12:25:02 <mathrick> ChilliX: I'm not sure I get what you're saying
12:25:04 <Cale> hm?
12:25:13 <ChilliX> You cannot do 
12:25:24 <ChilliX> foo x = bar y
12:25:28 <ChilliX>     where
12:25:31 <Cale> er, yeah, the where which contains extractMax and extractMin is the where clause for delete
12:25:33 <ChilliX>       bar = ...
12:25:35 <ChilliX>   where
12:25:39 <mathrick> oh
12:25:39 <ChilliX>     y = ...
12:25:44 <Cale> so you can't have another one
12:25:51 <ChilliX> you must write
12:25:53 <mathrick> so I need to use let?
12:25:57 <ChilliX> foo x = bar y
12:26:01 <ChilliX>     where
12:26:05 <ChilliX>       bar = ...
12:26:09 <ChilliX>       y = ...
12:26:30 <Cale> no, you just have to move toBeRebuilt into the same block as extractMax and extractMin
12:26:50 <mathrick> okay, so where containing  extract* belongs to the first level block?
12:26:51 <mathrick> funky
12:27:03 <Cale> where is part of declaration syntax
12:27:16 <Cale> (not expression syntax)
12:27:56 <ADEpt> anyone experiences trouples reading gmane.comp.lang.haskell.libraries via nntp?
12:28:01 <Cale> and it scopes over guards, but not over multiple equations
12:28:11 <mathrick> oh, so I can never have where for lower-levels blocks?
12:28:41 <Cale> mathrick: well, what scope did you expect it to have?
12:29:00 <Cale> you can use let when you want to make local definitions in an expression
12:29:01 <mathrick> Cale: dunno, I guess I was confused
12:29:14 <mathrick> also, how can I hint a type of a particular expression without introducing full typesig for a function?
12:29:19 <mathrick> that was something with :: right?
12:29:34 <ChilliX> mathrick: you can; the where new = extractMin l is perfectly fine
12:29:38 <Cale> yeah, you can give parts of an expression types with ::
12:30:03 <ChilliX> What you cannot have is something like ((expr where ...) where ...)
12:30:37 <Cale> you can't even have (expr where ..), it has to be  decl where ...
12:30:45 <ChilliX> However, it is fine to have (foo x = y where (y = z where z = x + 1))
12:31:09 <ChilliX> Note how the second where belongs to the equation in the first where and *not* to the outermost eqaution
12:31:12 <Cale> not with parens like that it isn't
12:31:18 <ChilliX> no, not parens
12:31:22 <ChilliX> { } in fact
12:31:28 <ChilliX> I just wanted to write it into one line
12:31:43 <Cale> foo x = y where {y = z where z = x + 1}
12:32:28 <Cale> where scopes over guards
12:32:28 <ChilliX> mathrick: re :: depends a bit on what exactly you want to do
12:32:34 <Cale> so you can do something like
12:32:45 <ChilliX> mathrick: You can write (1 :: Int) + 2, for example
12:33:15 <Cale> foo x | x > 0 = y | otherwise = 2 * y where y = x + 10
12:33:51 <mathrick> can I say "new = extractMax r :: Data.Tuple"?
12:34:14 <Cale> if Data.Tuple is a type
12:34:22 <mathrick> Cale: is it?
12:35:11 <Cale> not usually
12:35:26 <Cale> It's a module though
12:35:39 <mathrick> the exact problem I have is that I defined fst and snd for my own Assoc type
12:35:40 <Cale> It just has fst, snd, curry and uncurry
12:35:45 <mathrick> and now it complains:
12:35:46 <mathrick> http://pastebin.com/673923
12:35:57 <mathrick> in the non-highlighted line in the middle
12:36:20 <mathrick> but shouldn't it infer from the first highlighted line that extractMax must return a tuple?
12:36:51 <Cale> what's the error?
12:38:05 <Cale> If you defined your own fst, it will shadow the prelude definition
12:38:27 <mathrick> but shouldn't they be able to co-exist?
12:38:41 <Cale> no, unless one of them is qualified.
12:38:42 <mathrick> fst for tuple is not the same as fst for Assoc
12:38:46 <mathrick> bah
12:39:04 <mathrick> so what do we have rigorous type-checking if it isn't used?
12:39:07 <mathrick> *for
12:39:15 <Cale> You could define a typeclass
12:39:35 <Cale> class HasFst t a | t -> a where
12:39:38 <mathrick> hrmpf, it's silly
12:39:39 <Cale>    fst :: t -> a
12:40:04 <mathrick> if you are polymorhic, be so all the way through
12:40:12 <Cale> hm?
12:40:14 <}ElectrowolF{> > [1..5] !! 2
12:40:15 <lambdabot> 3
12:40:23 <Cale> What would the type of fst be?
12:40:27 <}ElectrowolF{> > [1..5] !! 4
12:40:28 <lambdabot> 5
12:40:33 <Cale> If you allowed them to coexist?
12:40:34 <}ElectrowolF{> > [1..5] !! 5
12:40:35 <lambdabot> Exception: Prelude.(!!): index too large
12:40:41 <}ElectrowolF{> > [1..5] !! 0
12:40:42 <lambdabot> 1
12:40:47 <mathrick> Cale: there would be two of them
12:40:53 <Cale> It would have to be some odd union of types, and those just aren't allowed.
12:41:05 <}ElectrowolF{> > ([1..5] !! 3) ([1..5] !! 2)
12:41:06 <lambdabot>  add an instance declaration for (Num (a -> a1))
12:41:06 <lambdabot>   In an arithmetic sequence: [1 .. 5]
12:41:19 <mathrick> Cale: but if it's perfectly clear that exctractMax must return a tuple, then where's the ambiguity?
12:41:24 <}ElectrowolF{> > ([1..5] !! 3) $ ([1..5] !! 2)
12:41:25 <lambdabot>  add an instance declaration for (Num (a -> b))
12:41:25 <lambdabot>   In an arithmetic sequence: [1 .. 5]
12:41:27 <}ElectrowolF{> hmm
12:41:39 <mathrick> }ElectrowolF{: you have a disturbing nick
12:41:45 <}ElectrowolF{> mathrick: why?
12:42:03 <}ElectrowolF{> already have it for over 8 years..
12:42:05 <Cale> mathrick: Well, it's a can of worms to start allowing that sort of thing.
12:42:08 <mathrick> because it looks like a garbage, with all the <} and {>
12:42:16 <mathrick> Cale: umm, why?
12:42:28 <}ElectrowolF{> true that, but i'm stuck to it after all this time..
12:42:47 <mathrick> Cale: languages with pathetic type systems (*cough* C++ *cough*) allow that with no difficulty
12:44:41 <}ElectrowolF{> but how DO i get something like ([1..5] !! 3) ([1..5] !! 2) to work?
12:44:45 <Cale> mathrick: C++ also doesn't have things like universal quantification :)
12:44:46 <}ElectrowolF{> to give me 2 ints ?
12:44:52 <mathrick> well, I guess I could just ignore it and rename my fst and snd to afst and asnd, but I still think it's just silly to not allow multiply defined functions if they're perfectly discernable through argument types
12:44:58 <mathrick> Cale: what's that?
12:45:05 <Cale> type variables
12:45:09 <isaac_> }ElectrowolF{: ( ([1..5] !! 3), ([1..5] !! 2) )
12:45:13 <isaac_> > ( ([1..5] !! 3), ([1..5] !! 2) )
12:45:14 <lambdabot> (4,3)
12:45:16 <Cale> @type map
12:45:17 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
12:45:30 <mathrick> Cale: hmm
12:45:30 <}ElectrowolF{> isaac_: want it without a ,
12:45:30 <isaac_> or
12:45:33 <isaac_> > [ ([1..5] !! 3), ([1..5] !! 2) ]
12:45:36 <lambdabot> [4,3]
12:45:38 <}ElectrowolF{> need it as parameters
12:45:40 <}ElectrowolF{> *spelling*
12:45:56 <isaac_> parameters? then you just need a function!
12:45:58 <mathrick> Cale: then why doesn't it complain at the definition spot, but only when I try to use it?
12:46:04 <mathrick> either it does conflict or not
12:46:06 <isaac_> > (+) ([1..5] !! 3) ([1..5] !! 2)
12:46:07 <lambdabot> 7
12:46:10 <mathrick> make up your mind, haskell
12:46:21 <}ElectrowolF{> like "f 3 5", but then instead of 3 and 5 i want notations like ([1..5] !! 3) ([1..5] !! 2)
12:46:41 <isaac_> ok
12:46:51 <isaac_> you can do that...
12:46:55 <}ElectrowolF{> how?
12:47:08 <isaac_> f ([1..5] !! 3) ([1..5] !! 2)      --right??
12:47:16 <}ElectrowolF{> like that, yes
12:47:32 <Cale> mathrick: you can qualify which one you want
12:47:41 <isaac_> > let f = (*) in f ([1..5] !! 3) ([1..5] !! 2)
12:47:43 <lambdabot> 12
12:47:50 <Cale> mathrick: Put  MyModule.fst or Prelude.fst
12:48:04 <mathrick> Cale: is Put a keyword?
12:48:10 <Cale> no
12:48:21 <Cale> I mean, you can type those instead of fst
12:48:30 <Cale> in order to say which one you mean
12:48:36 <mathrick> Cale: okay, but if I use snd 4 times on a line, it's not an acceptable solution -_-
12:48:40 <mathrick> it's already way too long
12:48:52 <Cale> sure, which is why you normally don't name things the same :)
12:48:58 <mathrick> which is silly
12:49:05 <mathrick> because they're not ambigous
12:49:31 <Cale> but solving ambiguities like that in general is probably exponential time
12:49:46 <}ElectrowolF{> got a "> days     :: Year -> Month -> Int" function, and i want to display the year and month (from a choice) as ints, so i need to get them from some sort of construction i just tried to use
12:50:00 <Cale> especially when you might have to infer a polymorphic type
12:50:17 <isaac_> }ElectrowolF{: a "choice" meaning...?
12:50:33 <mathrick> Cale: but haskell would have to infer extractMax's type anyway, no?
12:50:43 <Cale> oh, it does
12:50:45 <mathrick> then it's work you will do either way
12:51:01 <}ElectrowolF{> from wxhaskell, you can select something and then it returns a value if you ask for it
12:51:03 <}ElectrowolF{> sec
12:51:05 <Cale> I mean that the general problem of inferring types becomes much harder in the presence of ad-hoc polymorphism like that
12:51:16 <mathrick> Cale: aha
12:51:33 <}ElectrowolF{> (int (lDays !! (d+ (days (lYears !! y) (mToM m)))))
12:51:35 <Cale> so much so, that I'm fairly sure that it becomes exponential time
12:51:36 <mathrick> Cale: well, I guess I don't have appropriate overview of haskell's type system
12:51:36 <}ElectrowolF{> is what i tried
12:52:01 <}ElectrowolF{> days is the function i need the 2 parameters for
12:52:08 <Cale> (It might still be practical in most cases)
12:52:17 <}ElectrowolF{> gives you how many days a particular month has
12:52:48 <isaac_> @hoogle days
12:52:49 <Cale> But then again, we have bounded parametric polymorphism, which is just as good, and we're able to assign types to names uniquely.
12:52:50 <lambdabot> System.Locale.wDays :: TimeLocale -> [(String, String)]
12:53:05 <isaac_> what's the type of 'days'?
12:53:14 <Cale> You can write a couple of classes for fst and snd and get the effect you want
12:53:22 <mathrick> can I say let a = 5; b = a + 3 in ... ?
12:53:30 <Cale> sure
12:53:30 <}ElectrowolF{> int
12:53:31 <}ElectrowolF{> days     :: Year -> Month -> Int
12:53:43 <isaac_> oh
12:53:48 <mathrick> Cale: but I'll have to manually throw tuples in that new class, right?
12:53:51 <NameTab> }ElectrowolF{: it's hopeless, I'm never gonna finish it on time
12:53:53 <Cale> right
12:53:53 <mathrick> and they'll all have to agree
12:54:05 <}ElectrowolF{> NameTab: mine works.. basically...
12:54:09 <}ElectrowolF{> not perfect thou
12:54:12 <NameTab> }ElectrowolF{: then help me! :P
12:54:13 <Cale> I'd have one class per component
12:54:14 <mathrick> well, okay, here I see a problem
12:54:21 <}ElectrowolF{> RHE123 has a nice one
12:54:29 <}ElectrowolF{> isaac_: any bright ideas?
12:54:40 <mathrick> where you could have multiple interpretations of a call if multiple definitions didn't agree on args number
12:54:51 <isaac_> }ElectrowolF{: what error message do you get?
12:55:02 <Cale> mathrick: yeah
12:55:25 <Cale> you might have to do global program searches to determine that a particular type wouldn't work
12:55:27 <}ElectrowolF{> *paste*
12:55:28 <}ElectrowolF{>  Couldn't match `String' against `Int'
12:55:28 <}ElectrowolF{>    Expected type: String
12:55:28 <}ElectrowolF{>    Inferred type: Int
12:55:28 <}ElectrowolF{>  In the application `days (lYears !! y) (mToM m)'
12:55:28 <}ElectrowolF{>  In the second argument of `(+)', namely `(days (lYears !! y) (mToM m))'
12:55:39 <}ElectrowolF{> hmm
12:55:40 <Cale> and it would ruin most hope of separate compilation
12:55:59 <}ElectrowolF{> string.. err
12:56:03 <}ElectrowolF{> heck
12:56:24 <}ElectrowolF{> someone hit me
12:56:57 <isaac_> is lYears :: [String] or mToM m :: String ?
12:57:20 <}ElectrowolF{> isaac_: just saw something i did.. i'm stupid ;)
12:57:27 <}ElectrowolF{> > mToM :: Int -> Month
12:57:28 <lambdabot>  Not in scope: type constructor or class `Month'
12:57:42 <mathrick> Cale: I guess, but then, having to define your own typeclass for that sort of stuff has already ruined it
12:58:10 <}ElectrowolF{> o no
12:58:11 <}ElectrowolF{> weait
12:58:13 <}ElectrowolF{> gah
12:58:25 <}ElectrowolF{> i am realy missing things after almost a full day of doing haskell..
12:58:32 <ihope> @kind Num
12:58:34 <lambdabot> Class `Num' used as a type
12:58:40 <isaac_> }ElectrowolF{: ok, it's the best helper who can trigger someone to realize what they did wrong ;)
12:58:54 <}ElectrowolF{> i thought i just got it.. but i didn't :(
12:59:50 <Cale> lisppaste2: url
12:59:51 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
13:00:19 <lisppaste2> Cale pasted "Fst and Snd class" at http://paste.lisp.org/display/19232
13:02:13 <mathrick> garh, type system strikes again
13:02:17 <lisppaste2> Cale annotated #19232 with "more interesting type of Assoc" at http://paste.lisp.org/display/19232#1
13:02:55 <aufrank> cale, this reminds me of a question that came up when I was working last night
13:03:27 <aufrank> is pattern matching the only way to extract the nth element out of a tuple of size N, where N > 2?
13:03:36 <Cale> yes
13:03:43 <aufrank> (_, a, _) = ( 1, 2, 3 )
13:03:49 <Cale> or writing a function to do it for you
13:04:03 <Cale> or using TH to generate that code at compile time
13:04:09 <aufrank> ok
13:04:24 <jip> what exactly is TH?
13:04:31 <aufrank> I just thought that something like  nth 2 ( 1 2 3 ) might be built in
13:04:37 <jip> and is it something that i should know?
13:04:38 <aufrank> and that maybe I was looking under the wrong name
13:04:49 <isaac_> }ElectrowolF{: can you paste the whole module or whatever you have where you define some of the referenced things? http://paste.lisp.org/new/haskell
13:04:53 <Cale> Template Haskell -- it's a system for generating Haskell parse trees in Haskell at compile time.
13:05:01 <Cale> basically a macro system
13:05:12 <mathrick> http://pastebin.com/673995
13:05:14 <mathrick> help please
13:05:17 <jip> Cale: is it something i should know?
13:05:26 <mathrick> I'm not sure how I should read those error messages
13:05:52 <Cale> jip: Something to look at anyway -- it can be cool, but I still think it's a little rough around the edges
13:06:40 <aufrank>  this is probably an ill-formed question, but is there a relationship between DrIFT and TH?
13:06:52 <jip> Cale: does is come as part as ghc?
13:06:59 <Cale> aufrank: they can accomplish similar tasks
13:07:05 <Cale> jip: yes
13:07:05 <isaac_> mathrick: you can try putting in the type signatures for your functions, then it might be easier to figure out
13:07:16 <aufrank> that's what I thought from doing a quick read of their respective home pages
13:07:27 <Cale> mathrick: yeah, what is the type of delete?
13:07:46 <mathrick> isaac_: well, yeah, but I have learnt to avoid them, as usually I do poorer job than haskell would otherwise
13:08:05 <mathrick> Cale: (Maybe a, DictTree)
13:08:21 <Cale> mathrick: it must be a function type
13:08:26 <mathrick> ah
13:08:27 <monochrom> At first glance, I don't think newTree has the right type for the first argument of maybeRebuild.
13:08:31 <mathrick> Cale: sec
13:08:50 <isaac_> mathrick: snd (delete...) (MkAssoc...) r  ???  snd only takes one argument
13:09:09 <isaac_> wait, I see...
13:09:49 <isaac_> Haskell would conclude (correctly?) that the tuple had a function type as its second element type
13:10:01 <mathrick> delete :: Ord a => a -> DictTree a -> Bool -> (Maybe a, DictTree a) would be it
13:10:14 <Cale> okay
13:10:15 <mathrick> isaac_: sec, lemme parse what you just said
13:11:06 <Cale> mathrick: you're applying snd to (delete x l $ tBR || toBeRebuiltL)
13:11:22 <monochrom> isaac_ means: if you go "snd (x,y) a b", that becomes "y a b", therefore y must be a function.
13:11:23 <Cale> and then applying the result of that to (MkAssoc v w) and r
13:11:41 <mathrick> Cale: uh?
13:11:43 <Cale> so it's inferring that the snd component is a function of at least 2 parameters
13:11:53 <mathrick> oh
13:11:57 <ihope> > foldr1 gcd [12,42,500]
13:11:58 <lambdabot> 2
13:11:59 <Cale> but it's not
13:12:12 <mathrick> okay, I think I get it
13:12:20 <Cale> > snd ("Hello", \x -> x + 1) 5
13:12:21 <lambdabot> 6
13:12:25 <mathrick> Cale: can I solve it without introducing additional parens?
13:12:36 <monochrom> You can put more $'s.
13:12:44 <mathrick> monochrom: where exactly?
13:12:58 <mathrick> $ is left or right associative?
13:13:05 <Cale> How many parameters are you applying Node to?
13:13:08 <isaac_> mathrick: right
13:13:10 <mathrick> Cale: 3
13:13:12 <Cale> currently, it's just 1
13:13:23 <mathrick> isaac_: then $ is no good for me
13:13:32 <Cale> you don't want $ at all here
13:13:33 * mathrick gives in to parens, *sigh*
13:13:39 <mathrick> Cale: really?
13:13:45 <monochrom> why do you deplore parens?
13:13:52 <ihope> > snd (undefined, \x -> x + 1) 5
13:13:53 <lambdabot> 6
13:13:58 <mathrick> Cale: but then Node will swallow my snd, no?
13:14:02 <Cale> yes
13:14:08 <monochrom> The alternative is to write like XML. XD
13:14:09 <mathrick> and that's no good
13:14:16 <Cale> which is why you'd better wrap that in parens
13:14:38 <monochrom> Node (snd (delete ...)) (MkAssoc v w) r
13:14:47 <Cale> probably, yeah
13:14:56 <monochrom> Node (snd $ delete ...) (MkAssoc v w) r   if you like $
13:15:39 <Cale> personally, I dislike using $ more than once, usually you can replace the first n-1 of them with . 
13:16:05 <monochrom> Pick one: parens, XML, syntax tree.
13:16:42 <Cale> Using just indentation for grouping would be "fun"
13:16:58 <mathrick> well, it doesn't work anyway :)
13:17:07 <mathrick>     | x < v = let newTree = Node (snd (delete x l (tBR || toBeRebuiltL))) (MkAssoc v w) r
13:17:07 <mathrick>               in maybeRebuild newTree tBR toBeRebuiltL
13:17:14 <monochrom> that is broadly speaking a subcategory of syntax tree.
13:17:15 <mathrick> hmm, I better pastebin it
13:17:33 <Cale> there was a second error which we hadn't dealt with
13:18:00 <monochrom> Like I said there are other problems.  newTree has the wrong type as the first parameter to maybeRebuild.  It's so obvious it's staring at you.
13:18:07 <mathrick> http://pastebin.com/674025
13:18:18 <mathrick> Cale: now it's down to only one, the first one
13:18:28 <mathrick> the other one went away
13:18:34 <Cale> right
13:19:03 <Cale> as monochrom said, you're passing the wrong type of thing as the first parameter to newTree
13:19:10 <Cale> er
13:19:16 <Cale> maybeRebuild rather
13:19:19 <mathrick> I am?
13:19:21 * mathrick checks
13:19:30 <Cale> you're passing newTree, which is a tree
13:19:38 <mathrick> oh
13:19:39 <mathrick> I am
13:19:46 <Cale> as the first parameter to maybeRebuild, which takes a pair
13:20:15 <mathrick> that's why I asked about let a = 4; b = 4 + a in ..., btw :)
13:20:21 <mathrick> but I totally forgot about that
13:20:41 <Cale> > let a = 4; b = 4 + a in b
13:20:42 <lambdabot> 8
13:21:07 <Cale> > take 20 $ let evens = 0 : map (+1) odds; odds = map (+1) evens in evens
13:21:09 <lambdabot> [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38]
13:21:15 <mathrick> Cale: yeah, so y'see, I spotted that error, asked about a solution I had in mind, and then promptly forgot about it and started compiling things
13:21:22 <mathrick> wondering why it doesn't work
13:21:42 <Cale> and if you think these type errors are hard to figure out, imagine if there was ad-hoc polymorphism :)
13:21:49 <mathrick> heh
13:22:13 * xerox 's evens and odds, wooo!
13:22:38 <mathrick> Cale: your evens definition is wicked, btw
13:22:43 <Cale> :)
13:22:55 <mathrick> one could probably call it evil
13:23:04 * xerox grins
13:23:07 <Cale> It's a nice example of mutual recursion and lazy evaluation
13:23:27 <Cale> Has a nice coroutine-like feel to it
13:23:49 <mathrick> it has a nice brain-melting evilness to it
13:24:44 <Lokadin_> i love spicy food
13:24:53 <Lokadin_> on the topic of brain melting that is
13:24:54 <xerox> Cale: do you remember wether you thought it up or remembered it?
13:24:56 <mathrick> spicy is good, agreed
13:25:20 <xerox> This is brain meltin' http://dojo.fi/~rancid/loituma__.swf
13:25:39 <Cale> xerox: I didn't think it up just now, that's for sure. I'd be surprised if someone hadn't thought it up before me
13:26:11 * xerox tries to determine born date with google (-:
13:26:24 <monochrom> It is very difficult to fix errors in a broken program.  It is far easier to extort the specification from the author and derive a correct program.
13:27:31 <Lokadin_> xerox: lol that's hillarious
13:27:38 * xerox can't close that
13:28:10 <Lokadin_> what you mean?
13:28:24 * xerox dances
13:28:42 <Lokadin> lol
13:28:43 <Lokadin> :)
13:31:18 <ihope> > map pred "Ifsf(t!b!mmbnb-!uifsf(t!b!mmbnb-!boe!bopuifs!mjuumf!mmbnb"
13:31:19 <lambdabot> "Here's a llama, there's a llama, and another little llama"
13:31:30 <Lokadin> oh man i got some extra spicy pad sew noodles from the thai place and am sitting here blowing my nose *sighs* how wonderful
13:31:44 <Cale> xerox: that flash is clearly pure evil
13:31:53 <xerox> Indeed.
13:32:02 * xerox is trying to write out the text
13:35:23 <Lokadin> say so do you always have to recompile lambdabot to change config settings
13:35:24 <Lokadin> ?
13:38:01 <isaac_> @pl fix (\l -> 1:1:map (\n -> l!!(n-1) + l!!(n-2)) [2..])
13:38:02 <lambdabot> fix ((1 :) . (1 :) . flip map [2..] . ap (ap . ((+) .) . (. subtract 1) . (!!)) ((. subtract 2) . (!!)))
13:38:16 <isaac_> take 10 $ fix ((1 :) . (1 :) . flip map [2..] . ap (ap . ((+) .) . (. subtract 1) . (!!)) ((. subtract 2) . (!!)))
13:38:25 <isaac_> > take 10 $ fix ((1 :) . (1 :) . flip map [2..] . ap (ap . ((+) .) . (. subtract 1) . (!!)) ((. subtract 2) . (!!)))
13:38:26 <lambdabot> [1,1,2,3,5,8,13,21,34,55]
13:39:32 <isaac_> take 20 $ fix (\l -> 1:1:map (\n -> l!!(n-1) + l!!(n-2)) [2..])
13:39:34 <isaac_> > take 20 $ fix (\l -> 1:1:map (\n -> l!!(n-1) + l!!(n-2)) [2..])
13:39:35 <lambdabot> [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765]
13:39:38 <Cale> Lokadin: some of them -- it's certainly possible to fix things so that you don't, but I'm not sure exactly what it would entail.
13:40:35 <Cale> Lokadin: it's mostly the startup configuration stuff (which server to connect to, what nickname, etc) that you need to modify Config.hs to change
13:41:53 <Cale> > take 20 $ fix (\xs -> 0 : 1 : zipWith (+) xs (tail xs))
13:41:54 <lambdabot> [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181]
13:42:59 <isaac_> so many strange ways to do one thing in Haskell...
13:43:43 <isaac_> @pl  fix (\xs -> 0 : 1 : zipWith (+) xs (tail xs))
13:43:44 <lambdabot> fix ((0 :) . (1 :) . ap (zipWith (+)) tail)
13:43:53 <isaac_> much better!
13:44:01 <isaac_> @type ap
13:44:02 <lambdabot> forall b (m :: * -> *) a.
13:44:02 <lambdabot> (Monad m) =>
13:44:02 <lambdabot> m (a -> b) -> m a -> m b
13:44:28 <Cale> it's using the monad ((->) a)
13:44:48 <Cale> (Yes, that's partially applied :)
13:45:30 <Cale> ap :: (e -> a -> b) -> (e -> a) -> e -> b
13:46:24 <Cale> > ap (+) (+1) 5
13:46:25 <lambdabot> 11
13:47:32 <xerox> http://haskell.galois.com/~paolo/tmp/oituma-lyrics.text
13:47:35 <Lokadin> Cale: kk thanks  :) had to go because of the spiciness
13:47:36 <xerox> Do you think the lyrics is okay? :D
13:47:55 <xerox> "loituma", ops.
13:48:09 <Cale> > ap (\x y -> concat ["(f ",x," ",y,")"]) (\x -> concat ["(g ",x,")"]) "x"
13:48:10 <lambdabot> "(f x (g x))"
13:48:53 <Lokadin> xerox: lol are you for real?
13:49:00 <xerox> haha yeah.
13:49:26 <Lokadin> i prefer futurepop *shrugs*
13:49:45 <xerox> One correction.
13:49:54 <isaac_> f=zipWith (+); g=tail
13:50:04 <isaac_> x=xs
13:50:48 <mnislaih> so how do I integrate Drift into my project which uses Cabal
13:51:18 <mnislaih> should I write a custom setup.hs with Cabal user hooks?
13:56:31 <Cale> xerox: sure it's not 'abari patta'?
13:56:39 <xerox> Where exactly?
13:56:51 <xerox> yes it is
13:57:16 <xerox> haha Cale, I never thought you would go with me in this crazy lyrics thing :-)
13:57:46 <xerox> (updated)
13:58:13 <xX[ReP]Xx> rankui kakuk e akiri kanku
13:59:33 <Cale> I hear an 'n'
14:00:11 <xerox> where?
14:00:30 <Cale> in 'kankuk', xX[ReP]Xx wrote it without the n
14:00:39 <xerox> yep me too
14:00:46 <xerox> I wonder what language is it.
14:02:10 <Cale> Loituma is a Finnish music group
14:02:20 <xerox> O_o
14:02:27 <xerox> musasabi: come here!
14:04:59 <Lokadin> Cale: crazy
14:05:56 <Lokadin> i thought it was just jibberish
14:09:57 <Cale> http://www.noside.com/nsd6010note.html http://www.noside.com/nsd6027note.html -- liner notes to a couple of their albums, I haven't found anything quite like the words there though.
14:10:09 <musasabi> xerox: yes?
14:10:22 <Cale> musasabi: http://dojo.fi/~rancid/loituma__.swf
14:10:45 <Cale> (I'm sure that's what he called to point you at :)
14:11:00 * xerox nods with a smile
14:14:01 <xerox> musasabi: any ideas?  <grin>
14:14:03 <musasabi> not understandable finnish, some kind of kantele-music (kantele = a kind of finnish harp)
14:14:50 <musasabi> after goodling I can find other pieces by loituma and they are more understandable.
14:15:12 <xerox> FSVO understandable :-)
14:15:36 <sieni> it was slightly funny to hear that since I was already listening to Värttinä here :-)
14:17:48 <mathrick> another problem
14:17:50 <mathrick> http://pastebin.com/674128
14:18:32 <mathrick> the highlighted lines are the cause of (MkAssoc (Maybe a) b) creeping in
14:18:58 <mathrick> I tried to solve that by using (fromJust $ fst new), but then it gives rise to an infinite type
14:19:20 <xerox> musasabi: heh, thanks.
14:19:51 <mathrick> then I tried to solve it by type annotation, like let new = extractMin r :: Maybe a
14:19:58 <mathrick> but it still doesn't work
14:20:15 <mathrick> I can't see any clean way out of this tangled mess
14:20:28 <Cale> hmm
14:20:40 <Cale> You're not getting an actual type error anymore
14:20:48 <Cale> just not the type you wanter
14:20:50 <Cale> wanted*
14:21:23 <mathrick> Cale: yes
14:21:38 <mathrick> Cale: but Maybe there is very much undesired
14:21:56 <Cale> what's the definition of DictTree ?
14:22:14 <mathrick> data DictTree a = Leaf | Node (DictTree a) a (DictTree a)
14:22:14 <mathrick> data Assoc a b = MkAssoc a b
14:22:54 <Cale> and what's the type you want delete2 to have?
14:23:25 <Cale> (is it the same as that comment?)
14:23:53 <mathrick> Cale: yes
14:24:01 <Cale> You're returning trees with MkAssocs in them so it's no surprise that Assoc shows up in the final type
14:24:39 <mathrick> Cale: yeah, I know, but it infers (Num (Maybe a)) at one point
14:25:00 <Cale> Num?
14:25:00 <mathrick> oh, and Ord (Maybe a) too
14:25:04 <mathrick> Cale: yeah
14:25:15 <Cale> can't be because of this code -- perhaps the Ord
14:25:49 <mathrick> *DictTree> delete 10 (Leaf)
14:25:49 <mathrick> <interactive>:1:7:
14:25:49 <mathrick>     No instance for (Num (Maybe a))
14:26:42 <Cale> that's coming from the fact that you're passing 10 to something which expects a (Maybe a)
14:27:15 <Cale> I recommend first adding the type signature you expect and seeing what error is given
14:27:54 <Cale> Adding more type signatures can improve the quality of type errors you get too.
14:28:36 <Cale> you're comparing x with v which means that they have the same type
14:29:05 <Cale> and you're returning (v, ...) from the function
14:30:12 <mathrick> I see
14:30:50 <Cale> you're also returning the result of maybeRebuild in another case -- what's its return type?
14:31:08 <Cale> I'm guessing a pair where the first component is a Maybe something.
14:32:00 <mathrick> Cale: yeah
14:32:17 <mathrick> (Maybe a, DictTree a)
14:32:20 <Cale> oh, you're also returning (Nothing, Leaf) in the first equation
14:32:30 <mathrick> is that bad?
14:32:33 <Cale> so if you want x to not have a Maybe type
14:32:39 <Cale> you can't compare it with v
14:32:52 <Cale> since it would have to have the same type then
14:33:18 <mathrick> yeah
14:33:28 <mathrick> I'll need to rethink it a bit
14:34:22 <Cale> (perhaps just apply Just to x before comparing?)
14:42:11 <mathrick> Cale: apply to x? how do you mean?
14:42:32 <Cale> Just x < v
14:42:36 <Cale> Just x > v
14:42:39 <Cale> etc.
14:43:21 <mathrick> ah
14:43:28 <mathrick> Cale: is Maybe in Ord class?
14:45:57 <isaac_> Ord a => Ord (Maybe a)
14:48:33 <Cale> yeah
14:48:42 <Cale> Nothing < Just x for all x
14:48:50 <Cale> and Just x < Just y if x < y
14:49:41 <mathrick> well, I'm closer now
14:49:44 <mathrick> but not quite there
14:51:02 <mathrick> http://pastebin.com/674209
14:52:05 <mathrick> also, I'm not quite sure Just x is correct
14:52:16 <mathrick> since I don't want to rebuild the tree with Maybe's in it
14:52:54 <mathrick> so really, I need to get rid of Maybe inside the tree type
14:56:46 <mathrick> bah, I'm stupid
14:56:49 <mathrick> I'm returning v
14:56:55 <mathrick> instead of Just v
14:57:04 <mathrick> while expecting my function to return Maybe's
14:57:20 <mathrick> no wonder haskell expects me to have trees of Maybe's
14:59:03 <mathrick> now it looks much saner
15:24:04 <mathrick> is there a way to call a print or similar function from trace ?
15:24:30 <mathrick> as in, I have a function to print my tree already, and I don't want to rework it into someting returning [Char]
15:24:44 <mathrick> and it has -> IO () signature right now
15:26:01 <norpan> but it doesn't do any IO?
15:26:10 <mathrick> does
15:26:26 <mathrick> if it didn't, it wouldn't have IO () signature :)
15:28:03 <monochrom> I would not write a print-my-tree function with a ->IO() signature in the first place.  I would write the ->String one instead.
15:28:23 <mathrick> yeah, I'm rewriting it now
15:28:24 <mux> yeah, and have the ->IO() function call the other one
15:28:44 <mux> also, I'd use the Show type class
15:29:01 <aufrank> mathrick:  are you deriving Show?
15:29:05 <monochrom> Even in imperative programming (C++ for example), I would write one that outputs to any given ostream, rather than hardcode it to cout.
15:29:07 <aufrank> yeah, what mux said
15:29:56 <SamB> monochrom: eww
15:30:34 <mathrick> yeah, yeah, I know
15:30:38 <monochrom> Actually I would write one that outputs to an "output iterator" in general.  Now that corresponds well with ->String in Haskell.
15:30:39 <mathrick> historical reasons, basically
15:31:56 <monochrom> So, it seems that most programmers transitioning from IP to FP have difficulties because they had bad habits when doing IP in the first place.
15:33:16 <mathrick> blah
15:33:34 <monochrom> heh
15:33:43 <mathrick> monochrom: you haven't really told me anything earth-shattering, it was written this way because
15:33:51 <mathrick> of many things
15:33:58 <mathrick> like show being already taken
15:34:03 <SamB> because the imperative languages tend to have an astounding lack of features
15:34:12 <SamB> and libraries
15:34:47 <xX[ReP]Xx> rankui kankuk e akiri kanku
15:35:13 <monochrom> data MyStuff = X | Y deriving Show
15:35:29 <monochrom> Now "show" will work for MyStuff rather than "being taken".
15:35:37 <mathrick> err, how do I make a newline?
15:35:39 <monochrom> try "show X" and "show Y"
15:35:52 <mathrick> "\n" gets printed as, well, "\n"
15:36:21 <monochrom> You could also omit "deriving Show" and instead overload "shows".
15:36:53 <norpan> mathrick: "\n" is newline
15:36:55 <mathrick> monochrom: bah, by being taken I mean there was already another show written
15:37:06 <mathrick> *DictTree> print $ showTree $ mkDTree [1 .. 3]
15:37:07 <SamB> well
15:37:07 <mathrick> "(v: 2,w: 4)\n+--(v: 1,w: 2)   +--*\n   +--*\n+--(v: 3,w: 2)   +--*\n   +--*"
15:37:19 <norpan> replace print with putStr
15:37:33 <mathrick> okay
15:37:39 <monochrom> omit print
15:37:41 <xerox> mathrick: try: mapM_ putStrLn . lines . showTree . mkDTree [1..3]
15:37:50 <SamB> mathrick: just take out the "deriving Show" and rename yours?
15:38:42 <monochrom> > "\n\n\n"
15:38:43 <lambdabot> "\n\n\n"
15:38:46 <mathrick> SamB: ARGH, I"M NOT INCAPABLE OF THINKING THIS UP, IT JUST ENDED UP WRITTEN THIS WAY
15:39:48 <musasabi> Implementing putStrLn on the Handle level might be good, the current definition causes problems :-(
15:39:49 <SamB> mathrick: oh, you are using the other one?
15:40:36 <SamB> why, what is current definition?
15:40:55 <mathrick> SamB: something that prints the tree, just in a very unhelpful manner
15:41:13 <xerox> mathrick: did you try the mapM_ ?
15:41:15 <mathrick> but I didn't need it to be helpful previously, so I simply didn't care
15:41:23 <mathrick> xerox: no
15:41:25 <monochrom> There is always unsafePerformIO.  Now that trace is already on the table...
15:41:32 <SamB> last q was meant for musasabi 
15:43:14 <monochrom> If you go "trace (showTree ...) ..."  the newlines will work fine.
15:44:03 <norpan> @hoogle trace
15:44:04 <lambdabot> Debug.Trace.trace :: String -> a -> a
15:44:04 <lambdabot> Debug.Trace :: module
15:44:04 <lambdabot> Debug.Trace.putTraceMsg :: String -> IO ()
15:44:40 <monochrom> > trace "\n\n\n" True
15:44:41 <lambdabot>  Not in scope: `trace'
15:45:13 <monochrom> But do try that.  You will be happy.
15:45:14 <musasabi> SamB: putStrLn x = putStr x >> putChar '\n'
15:45:37 <musasabi> SamB: think of two threads each calling putStrLn
15:46:03 <monochrom> Nice!
15:46:33 <norpan> @hoogle traceShow
15:46:33 <lambdabot> No matches found
15:46:47 <SamB> musasabi: you think it ought to have synchronization?
15:47:11 <norpan> i remember having traceShow a = trace (show a) a
15:47:14 <monochrom> one expects putStrLn to be atomic.
15:47:20 <norpan> maybe that was not standard
15:47:23 <SamB> or you think it should be putStr . (++'\n')
15:47:27 <SamB> er.
15:47:32 <SamB> only with double quotes
15:47:46 <monochrom> that will work
15:47:51 <musasabi> SamB: I am seing the effects of it like "line1line2\n\n" with competing threads writing to stdout.
15:48:15 <SamB> ah
15:48:41 <musasabi> (the excepted output is "line1\nline2\n"
15:49:09 <SamB> s/cep/pec/?
15:49:23 <musasabi> yes
15:50:14 <ihope> Hmm...
15:51:08 <xerox> monochrom: hSetBuf LineBuffering or something ?
15:52:32 <monochrom> ">>" clearly breaks atomicity no matter how you do buffering.
15:52:35 <SamB> @hoogle hSetBuf
15:52:36 <lambdabot> IO.hSetBuffering :: Handle -> BufferMode -> IO ()
15:52:46 <xerox> StdOut
15:53:10 <monochrom> But I will let musasabi assure you.
15:53:25 <xerox> I believe you :-)
15:53:36 <musasabi> xerox: it is not a buffering issue.
15:54:43 <musasabi> xerox: it goes like this 1) Thread A does putStr "line1", 2) Thread B preempts and does putStr "line2", 3) the both threads execute putChar '\n' in some order.
15:55:51 <xerox> Why did you want musasabi to explain that monochrom?
15:56:22 <monochrom> Because my explanations are too rigorous.
15:56:46 <xerox> Rigor is okay.
15:56:57 <norpan> rigor mortis
15:57:01 <norpan> time to sleep
15:57:22 <ihope> Why no blocking thingy or whatever?
15:58:29 <ihope> 1. Thread A does putStr "line1". 2. Thread B attempts to putStr "line2", but fails because thread A is outputting something. 3. Thread A does putChar '\n'...
15:59:02 <monochrom> We are discussing "putStr "xxx" >> putChar '\n'"
15:59:31 <monochrom> How do you protect >> from being interrupted?
15:59:49 <xerox> Anyway I just jumped randomly in the discussion getting back onto the keyboard without reading all of it, sorry.
15:59:52 <monochrom> You may like to code your own locks.
16:00:06 <ihope> monochrom: wait for yield?
16:00:10 * ihope shrugs
16:00:14 <musasabi> monochrom: it can be done with holding the Handle MVar, but that is not portable and putStr (x ++ "\n") is slow.
16:00:26 <monochrom> You may like to request the GHC team to implement putStrLn atomically.
16:01:24 <musasabi> or just do an atomicPutStrLn and submit it to GHC and use it in the code in the mean time.
16:01:34 <norpan> you would have to traverse x to print it anyway so x ++ "\n" should be ok
16:01:47 <ihope> Um...
16:02:20 <ihope> @type foldr (>>) (return ()) . map putChar
16:02:20 <norpan> and it's not like printing is a fast operation anyway...
16:02:22 <lambdabot> [Char] -> IO ()
16:02:39 <musasabi> ihope: that is even worse.
16:02:46 <ihope> It is?
16:03:03 <monochrom> more >> means more ways of interleaving.
16:03:12 <norpan> but how is putStr implemented
16:03:23 <musasabi> norpan: inside the Handle.
16:03:35 <monochrom> putStr seems to be atomic.
16:03:46 <ihope> Ah...
16:03:57 <musasabi> Handles are really "MVar Handle__" and they keep that MVar while doing things to the internal representation.
16:04:07 <ihope> We need safeUninterleaveIO
16:04:11 <monochrom> Let me code up two threads doing putStr over infinite strings.
16:05:27 <ihope> I got abababababababababababaaaaaaaaaaaaaaaaaaaa
16:05:37 <ihope> Whoa, fireworks!
16:05:55 <norpan> @hoogle forkIO
16:05:56 <lambdabot> Control.Concurrent.forkIO :: IO () -> IO ThreadId
16:05:59 <ihope> I think it turned from abababab to aaaaaaaa after I ^C'd it.
16:06:41 <ihope> I ^C'd it some more, and it fuzzed out. I had to hold down the ^C for it to finish.
16:07:03 * ihope attempts to capture the fireworks
16:08:46 <musasabi> hmm, hPutStr does indeed do switched.
16:08:57 * musasabi goes to code atomicPutStrLn
16:09:05 <monochrom> Interesting interleaving.
16:09:07 <ihope> Grumble, grumble.
16:09:19 <ihope> It won't stop printing a's!
16:09:41 <ihope> Aha!
16:10:07 <ihope> It looks like the b thread terminated and I'm back at the prompt while it's still printing a's.
16:10:21 <ihope> Is there a "kill all threads except this one"?
16:10:31 <ihope> @index close
16:10:32 <lambdabot> bzzt
16:10:42 <monochrom> No.
16:11:17 <norpan> when i compile i get a lot of b and then a lot of a and then a lot of b
16:11:20 <norpan> and so on
16:11:28 <norpan> probably when the buffer is full or something
16:12:01 <ihope> hClaose and stouad. Very funny, GHCi.
16:12:32 <ihope> Oh! Aha! Eureka!
16:13:13 <norpan> taking a bath and discovering the law of lifting power in fluids?
16:13:34 <ihope> Okay, :m + System.IO doesn't do the trick.
16:13:47 <ihope> "Leaviang GHCi."
16:14:18 <ihope> How... appropriate?
16:14:18 <ihope> How FUN!
16:14:35 <monochrom> your computer is weird
16:14:42 <musasabi> ihope: nothing like that exists. (the close all other threads)
16:14:53 <norpan> Bork! Bork! Bork!
16:15:16 <ihope> This time I'll play it safe: thread <- forkIO foobar
16:15:52 <work_metaperl> I have a question about the monadic computation here: http://www.nomaware.com/monads/examples/example1.hs   .... fathersMaternalGrandmother does not short-circuit and quit when a Nothing is encountered does it? it keeps sequencing combinator actions... that seems inefficient
16:16:36 <norpan> comb will stop when it's argument is Nothing
16:16:47 <work_metaperl> norpan: how come?
16:16:55 <ihope> comb Nothing  _ = Nothing
16:16:56 <norpan> because it's defined that way
16:17:08 <ihope> What goes into the second parameter is ignored.
16:17:27 <work_metaperl> aha! thanks
16:17:27 <norpan> ignored == not computed
16:17:30 <work_metaperl> _
16:17:35 <work_metaperl> that was the key ... the _
16:17:38 <work_metaperl> THANKS
16:17:38 <ihope> Yep.
16:17:51 <norpan> it could be f instead of _, would work the same way
16:18:03 <norpan> nothing magic about _
16:18:03 <ihope> Leav8i2n108436888g612983858 127102685G4601HCi.
16:18:04 <work_metaperl> oh because the result = Nothing
16:18:18 <work_metaperl> right?
16:18:27 <ihope> Yep.
16:18:29 <norpan> because the result makes no use of the second parameter
16:18:50 <work_metaperl> cool
16:19:00 <norpan> that's what's lazy evaluation is about
16:19:13 <norpan> or at least part of what's it's about
16:19:17 <ihope>   Leavin g GHCi.
16:22:52 <ihope> Leng GHCi.
16:23:41 <GeniXPro> > map (x -> sum [1..x]) [1..9]
16:23:41 <lambdabot>  parse error on input `->'
16:23:49 <GeniXPro> blah
16:23:55 <GeniXPro> forgot my syntax
16:24:37 <GeniXPro> > map (\x -> sum [1..x]) [1..9]
16:24:38 <lambdabot> [1,3,6,10,15,21,28,36,45]
16:24:44 <musasabi> The Oleg's HSXML updates look very nice, have to find time to play with it :-)
16:24:56 <GeniXPro> > map (\x -> sum [1..x]) [1..20]
16:24:57 <lambdabot> [1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210]
16:25:07 <GeniXPro> > map (\x -> sum [1..x]) [1..100]
16:25:08 <lambdabot> [1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,276,300,325,351,378,406,435,465,496,528,561,595,630,666,703,741,780,820,861,903,946,990,1035,1081,1128,1176,1225,1275,1326,
16:25:08 <lambdabot> 1378,1431,1485,1540,1596,1653,1711,1770,1830,1891,1953,2016,2080,2145,2211,2278,2346,2415,2485,2556,2628,2701,2775,2850,2926,3003,3081,3160,3240,3321,3403,3486,3570,3655,3741,3828,3916,4005,4095,
16:25:08 <lambdabot> 4186,4278,4371,4465,4560,4656,4753,4851,4950,5050]
16:27:16 <ihope> > sum [1..100]
16:27:17 <lambdabot> 5050
16:27:18 <SamB> map sum (inits [1..100])
16:27:26 <ihope> And they say Euler was fast...
16:27:29 <SamB> > map sum (inits [1..100])
16:27:31 <lambdabot> [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,276,300,325,351,378,406,435,465,496,528,561,595,630,666,703,741,780,820,861,903,946,990,1035,1081,1128,1176,1225,1275,1326,
16:27:31 <lambdabot> 1378,1431,1485,1540,1596,1653,1711,1770,1830,1891,1953,2016,2080,2145,2211,2278,2346,2415,2485,2556,2628,2701,2775,2850,2926,3003,3081,3160,3240,3321,3403,3486,3570,3655,3741,3828,3916,4005,4095,
16:27:31 <lambdabot> 4186,4278,4371,4465,4560,4656,4753,4851,4950,5050]
16:29:11 <ihope> Hmm...
16:29:15 <ihope> > sum [1..33]
16:29:17 <lambdabot> 561
16:29:20 <ihope> > sum [1..37]
16:29:21 <lambdabot> 703
16:29:25 <ihope> > sum [1..35]
16:29:26 <lambdabot> 630
16:29:30 <ihope> > sum [1..36]
16:29:32 <lambdabot> 666
16:29:44 <SamB> > sum [1..1000]
16:29:45 <lambdabot> 500500
16:29:55 <SamB> > sum [1..1000000]
16:29:57 <lambdabot> Exception: stack overflow
16:29:59 <SamB> > sum [1..100000]
16:30:01 <lambdabot> 5000050000
16:30:01 <ihope> forkIO (putStr (cycle "LOL!\b\b\b\b"))
16:30:15 <SamB> um
16:30:17 <SamB> what?
16:30:23 <ihope> "PreLOde CoLOLntLO.ConurreLOLLOL!"
16:30:36 <ihope> "Leavig GHCi."
16:30:44 <GeniXPro> interesting what things sum to
16:30:54 <GeniXPro> > sum [1..7]
16:30:55 <lambdabot> 28
16:31:04 <GeniXPro> > sum [..7]
16:31:04 <lambdabot>  parse error on input `..'
16:31:09 <GeniXPro> > sum [7..]
16:31:10 <ihope> > sum [1..8]
16:31:14 <lambdabot> Terminated
16:31:15 <lambdabot> 36
16:31:19 <GeniXPro> ahh
16:31:27 <ihope> > sum [1..sum [1..8]]
16:31:28 <lambdabot> 666
16:31:38 <GeniXPro> nice
16:31:52 <GeniXPro> You created the best number!
16:31:55 <GeniXPro> beast*
16:32:09 <ihope> What a typo.
16:34:49 <ihope> "This calls for wisdom. If anyone has insight, let him calculate the number of the beast, for it is man's number. His number is 666."
16:35:50 <PeterK> > sum [1..8]
16:35:51 <lambdabot> 36
16:36:22 <norpan> > let (+) = (*) in 7+7
16:36:24 <lambdabot> 49
16:36:26 <ihope> > case divMod 666 256 of (x,y) -> [chr x, chr y]
16:36:27 <lambdabot> "\STX\154"
16:36:41 <ihope> Do you think his name is STX154, then?
16:39:44 <work_metaperl> sum [1..6^2]
16:39:56 <work_metaperl> > sum [1..6^2]
16:39:58 <lambdabot> 666
16:40:07 <work_metaperl> aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaahhhhhhhhhhhhh!!!!!!!!!!!!!!!!!!!!!!!!!!!!
16:40:49 <ihope> Well, 666 is 999 upside down.
16:41:29 <ihope> Annoyingly enough, the shortest Haskell code that results in the number 666 is 666.
16:41:38 <ihope> Or rather, "666".
16:42:09 <PeterK> > 500 + 100 + 50 + 10 + 5 + 1
16:42:10 <lambdabot> 666
16:42:35 <work_metaperl> ['6','6'] ++ ['6']
16:42:35 <SamB> ihope: I don't see anything about divmodding the number of the beast
16:42:41 <work_metaperl> > ['6','6'] ++ ['6']
16:42:43 <lambdabot> "666"
16:43:01 <ihope> SamB: that was to translate it into ASCII.
16:43:05 <work_metaperl> I used the Christian cross against itself :)
16:43:08 <ihope> > divMod 666 128
16:43:09 <lambdabot> (5,26)
16:43:18 <work_metaperl> > ['6'] ++ ['6'] ++ ['6']
16:43:20 <lambdabot> "666"
16:43:20 <ihope> > "\5\26"
16:43:22 <lambdabot> "\ENQ\SUB"
16:43:32 <ihope> Ah, his name is Enqsub.
16:43:57 <ihope> > chr (ord '\SUB' + 128)
16:43:58 <lambdabot> '\154'
16:44:19 <PeterK> > sum[1..12] - sum[1..3]
16:44:21 <lambdabot> 72
16:44:57 <PeterK> > (sum [12..36], sum [4..11], sum[1..3])
16:44:59 <lambdabot> (600,60,6)
16:46:26 <PeterK> > "\1\3 \4\11 \12\36"
16:46:27 <lambdabot> "\SOH\ETX \EOT\v \f$"
16:46:47 <ihope> Hmm.
16:49:31 <PeterK> > 36*12 + 13*18
16:49:33 <lambdabot> 666
16:49:49 <ihope> > length [ x | x <- [1..666], x `gcd` 666 == 1 ]
16:49:50 <lambdabot> 216
16:50:23 <ihope> > map (\x -> sum [1..x]) [1..36]
16:50:24 <lambdabot> [1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,276,300,325,351,378,406,435,465,496,528,561,595,630,666]
16:50:35 <ihope> Aww, 216 isn't in there.
17:06:22 <metaperl> are you people still at it? what's so great about 216?
17:06:57 <metaperl> oh I see. never mind
17:26:34 <palomer> hullo!
17:28:38 <ihope> Hi.
17:38:20 <dons> moin.
17:38:42 <dons> ?uptime
17:38:43 <lambdabot> uptime: 1 day, 23 hours, 14 minutes and 21 seconds
17:38:48 <vincenz> hiya
17:38:56 <vincenz> dons: I had something really weird happen with hmp3
17:39:08 <dons> right, ok. using mpg321 ?
17:39:42 <bolrod> 3
17:39:44 <bolrod> oops
17:40:07 <dons> musasabi: do you have any clues about the HAppS speed issues with FPS? do I need to tweak anything?
17:40:31 <vincenz> dons: yes
17:40:38 <vincenz> dons: suddenly I got noise out of my speaker
17:40:58 <SamB> vincenz: you are supposed to get noise out of your speaker
17:41:00 <SamB> that is the point
17:41:11 <dons> vincenz: a bogus mp3 file?
17:41:21 <dons> mpg321 will happily play non mp3 files, iirc.
17:41:24 <dons> and they sound bad
17:41:46 <SamB> dons: like mpeg movies
17:41:54 <dons> sounds like a non-hmp3 problem though -- hmp3 does talk to the speaker directly
17:42:01 <SamB> dons: though you'd think it ought to be able to handle them
17:42:04 <dons> SamB: like mpeg movies, for example.
17:42:27 <dons> if we write a binding to mplayer or mpd , then probably its a bit better.
17:42:59 <SamB> dons: not that it ought to show the video, just that you'd think it could throw that out and play the audio
17:43:06 <dons> yep. I agree.
17:43:06 <vincenz> dons: no I don't know... suddenly noise, hmp3 got killed, and my speaker kept busy
17:43:21 <dons> possibly mpg321 didn't die, but hmp3 gave up on it.
17:43:28 <dons> so it kept playing.
17:43:34 <dons> kill -HUP mpg321
17:43:38 <dons> maybe -9
17:43:49 <vincenz> no mpg321 was running
17:43:51 <SamB> yeah, thats happened to me before
17:43:55 <vincenz> I had to reboot
17:43:59 <dons> hmm. weird. i've not seen this.
17:44:06 <dons> a linux driver issue?
17:44:11 <SamB> fuser /dev/dsp
17:44:42 <SamB> dons: maybe mpg123 was a symlink
17:44:53 <dons> hmm, to what?
17:45:09 <SamB> something with another filename
17:45:25 <dons> yeah, but it still needs to be something that talks to the speaker.
17:45:28 <dons> it's possible though.
17:45:59 <SamB> well yeah
17:46:00 <vincenz> time to add a randomized playlist
17:46:07 <vincenz> anyone have a suggestion for a cyclic list?
17:46:26 <SamB> # update-alternatives --list mpg123
17:46:26 <SamB> /usr/bin/mpg123-oss
17:46:26 <SamB> /usr/bin/mpg123-esd
17:46:26 <SamB> /usr/bin/mpg123-nas
17:46:27 <SamB> /usr/bin/mpg321
17:46:31 <vincenz> ?
17:46:34 <dons> use `mod` to wrap, vincenz.
17:46:37 <Jerub> vincenz: def cycle_list(foo): while True: for elem in foo: yield elem
17:46:43 <Jerub> blah!
17:46:46 <vincenz> cyclic list, bidirectional,
17:46:49 <Jerub> I hate it when I get the wrong channel.
17:46:53 <vincenz> Jerub: not ruby
17:46:55 <vincenz> :D
17:46:57 <dons> hmm. building such a list might be expensive. be sure to keep it lazy.
17:46:58 <vincenz> and that's monodirectional
17:47:03 <vincenz> dons: not really
17:47:05 <vincenz> dons: lookk
17:47:10 <vincenz> > reverse [1..10000]
17:47:12 <lambdabot> [10000,9999,9998,9997,9996,9995,9994,9993,9992,9991,9990,9989,9988,9987,9986,9985,9984,9983,9982,9981,9980,9979,9978,9977,9976,9975,9974,9973,9972,9971,9970,9969,9968,9967,9966,9965,9964,9963,9962,
17:47:12 <lambdabot> 9961,9960,9959,9958,9957,9956,9955,9954,9953,9952,9951,9950,9949,9948,9947,9946,9945,9944,9943,9942,9941,9940,9939,9938,9937,9936,9935,9934,9933,9932,9931,9930,9929,9928,9927,9926,9925,9924,9923,
17:47:12 <lambdabot> 9922,9921,9920,9919,9918,9917,9916,9915,9914,9913,9912,9911,9910,9909,9908,9907,9906,9905,9904,9903,9902,9901,9900,9899,9898,9897,9896,9895,9894,9893,9892,9891,9890,9889,9888,9887,9886,9885,9884,
17:47:12 <lambdabot> 9883,9882,9881,9880,9879,9878,9877,9876,9875,9874,9873,9872,9871,9870,9869,9868,9867,9866,9865,9864,9863,9862,9861,9860,9859,9858,9857,9856,9855,9854,9853,9852,9851,9850,9849,9848,9847,9846,9845,
17:47:13 <vincenz> (10000 songs)
17:47:15 <lambdabot> 9844,9843,9842,9841,9840,9839,9838,9837,9836,9835,9834,9833,9832,9831,9830,9829,9828,9827,9826,9825,9824,9823,9822,9821,9820,9819,9818,9817,9816,9815,9814,9813,9812,9811,9810,9809,9808,9807,9806,
17:47:18 <lambdabot> [6 @more lines]
17:47:21 <dons> right. keep it lazy, like i said
17:47:25 <dons> not an array.
17:47:29 <vincenz> well no a list
17:47:32 <vincenz> but hmm
17:47:35 <vincenz> it can't be lazy
17:47:38 <vincenz> imagine doing "playPrev"
17:47:39 <vincenz> on first song
17:47:59 <SamB> vincenz: I'm pretty sure that was Python rather than Ruby
17:48:06 <vincenz> I'm considering {past :: [Int], Future :: [Int]}
17:48:21 <vincenz> reverse on end
17:48:26 <vincenz> at either side
17:48:39 <dons> yeah, sounds ok.. 
17:49:01 <vincenz> how do I get a random permutation of [0..x]?
17:49:10 <dons> playlists can't get very big. so possibly an UArray would be fine.
17:49:19 <dons> use System.Random
17:49:21 <dons> and think hard.
17:49:26 <vincenz> dons: heh thx
17:49:38 <vincenz> dons: Prolly reseed the list whenever user reselects random mode
17:49:52 <vincenz> after typing 'm' 3 times
17:50:30 <vincenz> dons:  easiest way.... make [0..n] and then n times randomly select (0..remaining)
17:50:36 <vincenz> not very efficient tho
17:50:42 <vincenz> O(n^2)
17:51:21 <dons> hmm. its a undo/redo list no? so going forward pushes an element on the prev list.
17:51:28 <dons> and going backward pushes and elem on the forward list
17:51:38 <dons> then you check for the end.
17:51:53 <dons> so only 1 list is needed, and a ptr in that list.
17:52:08 <vincenz> yea
17:52:20 <vincenz> dons: but a ptr in that list requires O(N) access
17:52:28 <vincenz> dons: while using prev and future only O(1) except at loops
17:52:38 <dons> right. so use an Unboxed Array, I reckonn.
17:52:46 <vincenz> there are still a few issues
17:52:51 <vincenz> what if user manually selects a song
17:52:53 <vincenz> a) reseed
17:52:57 <dons> ah, succ and pred, is good.
17:53:11 <vincenz> b) find position of song in random list
17:53:45 <dons> its a moderately complicated system. so make sure to draw up a sane design first :)
17:53:48 <musasabi> dons: The current code seems fast enough, floating constant strings outwards would a nice addition, but cannot say whether that is fixed without -prof.
17:53:52 <dons> it might even need its own module?
17:54:12 <musasabi> dons: but in general I am quite happy with the current state.
17:54:22 <dons> musasabi: floating constants outwards? so they're shared if you use them multiple times?
17:54:32 <dons> i.e. a true FastString as ghc uses them
17:54:55 <dons> ok. so we resolved the speed issue from yesterday then?
17:54:59 <dons> it was due to 'error' ?
17:55:11 <dons> or was there something else.
17:55:12 <musasabi> The error made things fast.
17:55:30 <dons> and dropSpace and friends are acceptable now?
17:55:39 <musasabi> yes, they are acceptable.
17:56:02 <dons> ok. good. i'm tidying it up as Data.ByteString to go into ghc today :)
17:56:05 <musasabi> I changed URI parsing to use FPS instead of going via Strings and got the lost performance back from there.
17:56:08 <dons> did using 6.5 help?
17:56:14 <dons> ah, good idea.
17:57:19 <musasabi> 6.5 didn't make a large difference in the tests.
17:59:47 <musasabi> I think comparePS could be made faster as there is no need to pass around two length parameters, but didn't get a version I was happy with.
18:00:47 <dons> hmm. I could do some more testing with the old memcmp version
18:01:00 <dons> they seemed around the same, but i didn't get precise numbers
18:01:38 <dons> ah, yes, those len args are redundant
18:04:18 * palomer fixes another bug
18:04:21 <palomer> hip hip
18:07:14 <ihope> Hooray?
18:07:53 <palomer> more enthusiasm next time
18:08:07 <fraxtal> bugs in GHC?
18:09:42 <ihope> Will do...
18:10:25 <PeterK> I'm still working on my problem with counting bigrams.  Suppose one had the text "ABCDCBDABBDDBACDABCCAAACABBBADABDBADBACCADBACAD". And you want to know how many times each bigram comes up (A, A), (A, B)..(C, D), (D, D). What's an efficient way to do this?
18:11:19 <dons> musasabi: well, comparePS is pretty good. on two 16M strings that only differ in their last bit, the pure haskell version takes  1.063 while the memcmp version takes 1.055s
18:11:27 <dons> for small strings < 1M its ~0.00s
18:12:13 <ihope> Well, first you make a list of digrams, then you count the number of instances of each one.
18:12:28 <ihope> @hoogle a -> [a] -> Int
18:12:29 <lambdabot> No matches, try a more general search
18:12:32 <ihope> @hoogle a -> [a] -> Integer
18:12:33 <lambdabot> No matches, try a more general search
18:12:33 <musasabi> dons: yes, quite fast :-)
18:12:38 <ihope> Bleh.
18:13:08 <PeterK> I can do that, but doing a separate count through the text for each bigram takes a long time as you increase the number of bigrams.
18:13:11 <monochrom> "zip text (tail text)" will produce a list of bigrams
18:13:29 <monochrom> > let text = "ABCDEFG" in zip text (tail text)
18:13:30 <lambdabot> [('A','B'),('B','C'),('C','D'),('D','E'),('E','F'),('F','G')]
18:14:00 <dons> then use (Char,Char) as indicies into an array to count them?
18:14:17 <monochrom> Hey, that will work!
18:14:28 <SamB> PeterK: what dons said
18:14:55 <ihope> > let count x l = length (filter (==x) l) in count 't' "Only the fool would take trouble to verify that his sentence was composed of ten a's, three b's, four c's, four d's, forty-six e's, sixteen f's, four g's, thirteen h's, fifteen i's, two k's, nine l's, four m's, twenty-five n's, twenty-four o's, five p's, sixteen r's, forty-one s's, thirty-seven t's, ten u's, eight v's, eight w's, four...
18:14:56 <lambdabot>  lexical error in string/character literal
18:14:56 <ihope> ...x's, eleven y's, twenty-seven commas, twenty-three apostrophes, seven hyphens and, last but not least, a single !"
18:15:10 <ihope> Ow ow ow
18:16:24 <monochrom> > group "AABBCCAAA"
18:16:25 <lambdabot> ["AA","BB","CC","AAA"]
18:16:29 <ihope> So how's this binding stuff work?
18:16:51 <encoded_> omg!
18:17:13 <encoded_> we need coders fora windows NT compatible OS!
18:17:20 <encoded_> come join us! #reactos
18:17:25 <encoded_> www.reactos.org
18:17:27 * vincenz smacks encoded_ 
18:17:34 <vincenz> what a shame
18:17:37 <monochrom> You can use "sort" to sort the list of digrams so that same occurences are together.  Then you can use "group" to split them.
18:17:38 <vincenz> reactos is something decent
18:17:44 <vincenz> for someone to ruin it's rep with crappy spamming
18:18:01 <dons> :(
18:18:09 <monochrom> > let text = "ABCDCBDABBDDBACDABCCAAACABBBADABDBADBACCADBACAD" in group $ sort $ zip text (tail text)
18:18:10 <lambdabot> [[('A','A'),('A','A')],[('A','B'),('A','B'),('A','B'),('A','B'),('A','B')],[('A','C'),('A','C'),('A','C'),('A','C')],[('A','D'),('A','D'),('A','D'),('A','D')],[('B','A'),('B','A'),('B','A'),('B','A')
18:18:10 <lambdabot> ,('B','A')],[('B','B'),('B','B'),('B','B')],[('B','C'),('B','C')],[('B','D'),('B','D'),('B','D')],[('C','A'),('C','A'),('C','A'),('C','A')],[('C','B')],[('C','C'),('C','C')],[('C','D'),('C','D')],[('
18:18:10 <lambdabot> D','A'),('D','A'),('D','A')],[('D','B'),('D','B'),('D','B'),('D','B')],[('D','C')],[('D','D')]]
18:19:03 <vincenz> > let text =  "ABCDCBDABBDDBACDABCCAAACABBBADABDBADBACCADBACAD" in map (fst &&& length) $ group $ sort $ zip text (tail text)
18:19:04 <lambdabot> Couldn't match `[a]' against `(a1, b)'
18:19:09 <monochrom> So now I have a list of lists of digrams.  I can "map length" to count ech.
18:19:16 <vincenz> > let text =  "ABCDCBDABBDDBACDABCCAAACABBBADABDBADBACCADBACAD" in map (head &&& length) $ group $ sort $ zip text (tail text)
18:19:17 <lambdabot> [(('A','A'),2),(('A','B'),5),(('A','C'),4),(('A','D'),4),(('B','A'),5),(('B','B'),3),(('B','C'),2),(('B','D'),3),(('C','A'),4),(('C','B'),1),(('C','C'),2),(('C','D'),2),(('D','A'),3),(('D','B'),4),((
18:19:17 <lambdabot> 'D','C'),1),(('D','D'),1)]
18:19:28 <monochrom> Yes, like that.
18:19:37 <PeterK> thank you
18:20:21 <vincenz> ;)
18:20:28 <monochrom> In an imperative language you write more code and design your own data structures and introduce more bugs.
18:20:35 <vincenz> HAh
18:20:40 <vincenz> I laugh in the face of data structure bugs
18:20:43 <monochrom> But somehow people like that.
18:20:51 <vincenz> monochrom: people like bondag too
18:20:53 <dons> they do?
18:21:25 <monochrom> Somehow people like imperative languages, that's for sure.  You have to somehow explain why.
18:21:39 <vincenz> or have to explain 'somehow'
18:21:54 <vincenz> monochrom: somehow is your stop word?
18:22:04 <vincenz> monochrom: checked this out? http://www.notvincenz.com/wiki/pmwiki.php/Icfp/Main
18:22:17 <monochrom> somehow I keep saying "somehow" :)
18:22:34 <musasabi> Does anyone have got a functional hashtable based on DiffArray ?
18:22:37 <vincenz> like you know, like I really like liking
18:23:59 <monochrom> I am not sure I want to work with palomer XD
18:24:11 <vincenz> s/palomer/monochrom?
18:24:22 <monochrom> That too.
18:24:25 <vincenz> ?
18:25:02 <PeterK> what do I import to get &&& in scope
18:25:34 <musasabi> PeterK: import Control.Array
18:25:36 <vincenz> PeterK: Control.Arrow
18:25:41 <musasabi> *Arrow
18:25:43 <PeterK> thank you
18:27:06 <ihope> Control.Array?
18:28:18 <palomer> monochrom is simply jealous that I can prove tautologies faster
18:28:22 <musasabi> ihope: no such thing, was thinking one thing and writing an another.
18:28:40 <vincenz> palomer: I do hope you will be serious during the thing
18:29:16 * vincenz can't read what monochrom is pming him cause monochrom isn't regged
18:29:17 <monochrom> There is no Control.Array
18:29:39 <monochrom> I am not pming.
18:29:46 <vincenz> so you're just ignoring me
18:29:50 <palomer> ouch
18:29:52 <vincenz> > mkStdGen 10
18:29:53 <lambdabot> 11 1
18:29:59 <palomer> I'm serious when it counts
18:30:06 <vincenz> palomer: ok :)
18:30:12 <vincenz> >take 10 $ randoms $ mkStdGen 10
18:30:13 <monochrom> Yes I block pm's.  You want to tell me something?
18:30:15 <vincenz> > take 10 $ randoms $ mkStdGen 10
18:30:16 <lambdabot> Add a type signature
18:30:18 <vincenz> monochrom: if you're interested
18:30:22 <vincenz> > take 10 $ randoms $ mkStdGen 10 :: [Int]
18:30:24 <lambdabot> [-1258130923,-870666468,433432625,-1228884604,793723731,1488653119,609706456,-326773183,-379446370,1048451235]
18:30:36 <monochrom> I am not interested in joining any team.
18:30:43 <vincenz> why no
18:30:44 <vincenz> t
18:31:11 <monochrom> No time, no gut, no wit, ...
18:31:24 <vincenz> in that order?
18:31:34 <monochrom> yes :)
18:31:53 <PeterK> If I wanted to make an array out of [(('A','A'),2),(('A',B'),3),(('B','B'),1)] and fill in the missing ('B','A') with 0...how would I do it? I apologize for the newbish questions.
18:32:22 <vincenz> PeterK: well you'd first have to define the range of things
18:32:28 <vincenz> but why do that?
18:32:47 <vincenz> just do a lookup and return 0 on Nothing
18:32:54 <PeterK> I want the matrix of these bigrams so I can do a distance calculation between two matrices.
18:34:14 <ihope> > mkStdGen 0
18:34:15 <lambdabot> 1 1
18:34:21 <ihope> > next (mkStdGen 0)
18:34:22 <lambdabot> (2147482884,40014 40692)
18:34:23 <monochrom> use accumArray with initial value 0 and accumulating function (\_ x -> x)
18:34:32 <vincenz> > splitAt [1..3]
18:34:33 <lambdabot> Couldn't match `Int' against `[a]'
18:34:34 <vincenz> > splitAt 1 [1..3]
18:34:35 <lambdabot> ([1],[2,3])
18:34:39 <vincenz> > splitAt 0 [1..3]
18:34:40 <lambdabot> ([],[1,2,3])
18:34:56 <monochrom> @pl (\_ x -> x)
18:34:57 <lambdabot> const id
18:35:23 <monochrom> (\_ x -> x) seems more readable than const id :)
18:35:53 <ihope> I like const id.
18:37:11 <monochrom> If you want the matrix anyway, you can skip the (head&&&lenght).group.sort step.  It saves you nlogn time.
18:37:37 <palomer> I prefer const const id id 
18:37:52 <dons> > accumArray (const id) 0 (('A','A'), ('Z','Z')) $ let text =  "ABCDCBDABBDDBACDABCCAAACABBBADABDBADBACCADBACAD" in map (head &&& length) $ group $ sort $ zip text (tail text)
18:37:53 <lambdabot> array (('A','A'),('Z','Z')) [(('A','A'),2),(('A','B'),5),(('A','C'),4),(('A','D'),4),(('A','E'),0),(('A','F'),0),(('A','G'),0),(('A','H'),0),(('A','I'),0),(('A','J'),0),(('A','K'),0),(('A','L'),0),((
18:37:53 <lambdabot> 'A','M'),0),(('A','N'),0),(('A','O'),0),(('A','P'),0),(('A','Q'),0),(('A','R'),0),(('A','S'),0),(('A','T'),0),(('A','U'),0),(('A','V'),0),(('A','W'),0),(('A','X'),0),(('A','Y'),0),(('A','Z'),0),(('B'
18:37:53 <lambdabot> ,'A'),5),(('B','B'),3),(('B','C'),2),(('B','D'),3),(('B','E'),0),(('B','F'),0),(('B','G'),0),(('B','H'),0),(('B','I'),0),(('B','J'),0),(('B','K'),0),(('B','L'),0),(('B','M'),0),(('B','N'),0),(('B','
18:37:53 <lambdabot> O'),0),(('B','P'),0),(('B','Q'),0),(('B','R'),0),(('B','S'),0),(('B','T'),0),(('B','U'),0),(('B','V'),0),(('B','W'),0),(('B','X'),0),(('B','Y'),0),(('B','Z'),0),(('C','A'),4),(('C','B'),1),(('C','C')
18:37:56 <lambdabot> ,2),(('C','D'),2),(('C','E'),0),(('C','F'),0),(('C','G'),0),(('C','H'),0),(('C','I'),0),(('C','J'),0),(('C','K'),0),(('C','L'),0),(('C','M'),0),(('C','N'),0),(('C','O'),0),(('C','P'),0),(('C','Q'),0)
18:37:56 <dons> :)
18:37:59 <lambdabot> [6 @more lines]
18:38:13 <vincenz> nil l
18:38:15 <vincenz> > nil []
18:38:16 <lambdabot>  Not in scope: `nil'
18:38:19 <vincenz> > null []
18:38:20 <lambdabot> True
18:38:24 <ihope> > null [1]
18:38:24 <palomer> does the S combinator have anything to do with the fixed point combinator?
18:38:25 <monochrom> accumArray (+) 0 (lowerbound, upperbound) (zip (zip text (tail text)) 1)
18:38:26 <lambdabot> False
18:38:30 <pesco> Hm, anyone of the alioth/haskell-unsafe people here, by any chance?
18:38:34 <ihope> palomer: nope
18:38:39 <monochrom> You figure out lowerbound and upperbound.
18:38:44 <palomer> ok, the person who's funding me is an idiot
18:38:56 <ihope> What... why?
18:39:08 <dons> palomer, does this person read log files?
18:39:18 <monochrom> heh
18:39:19 <dons> ?google palomer haskell
18:39:21 <lambdabot> http://sequence.complete.org/hwn/20060116
18:39:27 <dons> lucky
18:39:30 <dons> ?google palomer #haskell
18:39:32 <lambdabot> http://sequence.complete.org/hwn/20060116
18:39:36 <dons> hmm
18:39:44 <dons> ?google palomer #haskell tunes.org
18:39:46 <lambdabot> http://tunes.org/~nef/logs/haskell/06.03.07
18:39:50 <dons> ah ha!
18:39:56 <dons> YOU'RE FIRED ! :)
18:40:07 <pesco> ?google palomer idiot
18:40:09 <lambdabot> http://www.irclogs.ws/efnet/c++/25Oct2005/1.html
18:40:16 <jip> > let a = a in a + 1
18:40:17 <lambdabot> Terminated
18:40:21 * pesco raises eyebrow.
18:40:28 <jip> > let a = a in 1
18:40:29 <lambdabot> 1
18:40:46 <vincenz> > tail []
18:40:47 <lambdabot> Add a type signature
18:40:48 <pesco> Hm, so no alioth people here. :(
18:40:51 <vincenz> > tail [] :: [Char]
18:40:52 <lambdabot> Exception: Prelude.tail: empty list
18:41:04 <dons> pesco, who in particular are you looking for?
18:41:08 <dons> dcoutts?
18:41:12 <dons> or Igloo?
18:41:32 <pesco> Anyone, I'm having trouble with the deb repo there.
18:41:42 <Igloo> What trouble?
18:41:43 <pesco> Ah yeah, I see the members list.
18:41:49 <ihope> ?google 3
18:41:50 <lambdabot> http://www.3com.com/
18:41:59 <ihope> ?google http://www.3com.com/
18:42:01 <lambdabot> http://www.3com.com/
18:42:03 <pesco> Igloo: I'm trying to build wxhaskell from source and cannot seem to find the orig.tgz
18:42:06 <ihope> Aww.
18:42:38 <pesco> Igloo: (I'm on powerpc)
18:42:49 <Igloo> Well, if it wasn't uploaded you'd have to ask the creator. It's probably the release tarball from the wxhaskell page, though
18:43:30 <pesco> Igloo: It should be. Hm, I thought anyone of the devels could put the file there.
18:44:31 <Igloo> If the person who created it didn't put it there then the rest of us don't have it  :-)
18:44:38 <pesco> Igloo: Also, I have the feeling the repo organization isn't correct. The sources are under i386, so I have to list that in my deb-src line.
18:45:18 <pesco> Igloo: Like you said, it's with some certainty the upstream tarbal, because that's what the orig.tgz's are, right?
18:45:30 <Igloo> Normally, yes
18:45:46 <vincenz> \o/
18:46:01 <vincenz> http://rafb.net/paste/results/Txav6P48.html
18:46:07 <vincenz> feel free to refactor, comment
18:46:13 <Igloo> There's a reason for the repo being organised like that. It might be to stop uploads trashing source from other arches, but it might be something else
18:46:20 <vincenz> what bugs me is the (length l)
18:46:38 <pesco> Igloo: Okay.
18:47:43 <vincenz> refactor: http://rafb.net/paste/results/uZnm9C56.html
18:48:27 <vincenz> comments?/
18:49:34 <vincenz> @hoogle getArgs
18:49:35 <lambdabot> System.getArgs :: IO [String]
18:50:45 <ihope> @hoogle IO a
18:50:46 <lambdabot> System.exitFailure :: IO a
18:50:46 <lambdabot> Control.Exception.evaluate :: a -> IO a
18:50:46 <lambdabot> Network.withSocketsDo :: IO a -> IO a
18:51:16 <ihope> What does evaluate do?
18:52:54 <monochrom> give "evaluate undefined >> return ()" a try
18:53:03 <dons> evaluate :: a -> IO a
18:53:04 <dons> evaluate a = IO $ \s -> case a `seq` () of () -> (# s, a #)
18:53:10 <vincenz> http://rafb.net/paste/results/XK60o852.html
18:53:14 <vincenz> dons: ya like?
18:53:16 <dons> -- | Forces its argument to be evaluated, and returns the result in
18:53:17 <dons> -- the 'IO' monad.  It can be used to order evaluation with respect to
18:53:17 <dons> -- other 'IO' operations
18:54:11 <dons> "(mkStdGen $ read $ head $ tail $ args)" should be "(mkStdGe n . read . head . tail) args" :)
18:54:25 <vincenz> I mean the core
18:54:26 <dons> but yes, looks good.
18:54:35 <vincenz> find it odd removeAt ain't in Data.List
18:54:50 <dons> is it possible to write a QuickCheck test for this function?
18:54:55 <dons> do you know quickcheck?
18:54:59 <vincenz> yep
18:55:02 <vincenz> dons: for which function
18:55:04 <vincenz> removeAt ?
18:55:15 <dons> just a couple of properties for removeAt, and anything else.
18:55:27 <vincenz> hmmka
18:55:28 <vincenz> why?
18:55:29 <monochrom> Something like "do { f <- getContents; evaluate (length f); putStrLn "ok!" }" probably forces reading before the ok.
18:55:37 <dons> shrgu. i guess its not needed.
18:55:44 <dons> but i'd like to add a QC suite to hmp3 at somep oint
18:56:36 <vincenz> ah
18:56:44 * vincenz puts the stdgen first in randomPerm
18:57:19 <vincenz> not lazy tho
18:57:23 <vincenz> :(
18:57:28 <jip> I've added a new post to my gameboy emulator devlog!
18:57:29 <jip> http://www.mutantlemon.com/omegagb/devlog/
18:57:34 <vincenz> woo
18:58:08 <dons> jip, did you consider asking ibid to add a feed to planet.haskell.org ?
18:58:21 <dons> it'd be cool to add your blog to that haskell aggregator
18:58:29 <jip> dons: i don't have a feed
18:58:43 <dons> oh you should! this is really interesting stuff you're doing.
18:59:03 <dons> hehe "let v'' = v + v''"
18:59:05 <dons>  :)
18:59:08 <dons> ?karma+ jip
18:59:09 <lambdabot> jip's karma raised to 3.
18:59:36 * vincenz wants karma
19:00:03 <dons> I'd recommend STUArray for the roms by the way
19:00:20 <dons> ah, you using UArray now? good.
19:00:51 <dons> jip, is the code in darcs, btw?
19:01:02 <jip> dons: no
19:01:02 <dons> or you just post snapshots?
19:01:08 <jip> just those snapshots
19:01:09 <dons> any kind of version control?
19:01:19 <jip> nope
19:01:20 <vincenz> hehe
19:01:25 <dons> if you put it in darcs, i'm likely to contribute patches... 
19:01:27 <vincenz> let v''..
19:01:54 <jip> dons: hm... tempting :)
19:01:55 <dons> hmm. and an rss feed would be good if you want to be come famous.. :)
19:02:37 <dons> i'll add a link on the libraries and tools page of the wiki, anyway, since this is the only free hardware emulator i know of
19:02:43 <dons> written in .hs
19:02:56 <vincenz> jip: very cool
19:03:18 <dons> ?where+ OmegaGB http://www.mutantlemon.com/omegagb/
19:03:18 <lambdabot> Done.
19:03:22 <jip> dons: problem is that i hate the complexity of all this "blog" stuff. and i don't like to think of my devlog as a "blog". once i finish the emulator. the devlog will stop being updated, and i will format all posts into a webpage that will read like a diary
19:03:24 <vincenz> jip: on a sidenot
19:03:34 <vincenz> jip: what is it you're using for blogging?
19:03:38 <jip> dons: maybe i'll install something like blosxom though
19:03:46 <jip> vincenz: single html page
19:03:53 <vincenz> jip: manually editted?
19:03:59 <jip> vincenz: yes
19:04:00 <vincenz> why not go to blogspot?
19:04:05 <vincenz> gets you an atom feed
19:04:36 <vincenz> on another note, how do you do the snapshot thingy?
19:04:43 <jip> vincenz: manually done
19:04:55 <vincenz> darcs repo checkout?/
19:05:03 <dons> oh, you could save time with darcs:  darcs dist generates snapshots 
19:05:03 <jip> no, it's all totally manual
19:05:07 <vincenz> ok
19:05:28 <dons> do you want a darcs tutorial while we're here? :)
19:05:37 <dons> cd src ; darcs init ; darcs add * ; darcs record ;
19:05:38 <vincenz> easy pie
19:06:07 <dons> then darcs whatsnew  -s after some changes. darcs dist, to make snapshots.
19:06:12 <dons> darcs revert to undo stuff
19:06:27 <Igloo> jip: FWIW if you were using -Wall and were writing warning-free code then the compiler would probably give you a warning about the v'' thing
19:06:28 <dons> and then others can darcs send patches to you
19:06:42 <jip> Igloo: i'm pretty sure that it didn't give me a warning there
19:06:48 <dons> Igloo, it would?
19:07:04 <Igloo> I'd expect you to get a "v' is unused" warning, but it would depend on what the code looked like exactly
19:07:04 <jip> dons: yeah... maybe i'll start using darcs soon
19:07:30 <jip> dons: the bad news is that tomorrow is my last day of vacation and then i'm gonna be gone for a while and won't be able to work on this :'(
19:07:47 <Igloo> Or if the other value really was called v'' too then a variable shadowing warning
19:08:01 <dons> fair enough. 
19:09:24 <PeterK> same problem, another newbie question...how do I say in haskell, "sum the values in the array where the first index of the two indices of the array is 'A'". the documentation on the array functions doesn't seem to help me much.
19:09:28 <jip> if people really want an atom feed then i guess i can manually create one :|
19:10:28 <monochrom> assocs will give you a list of everything
19:10:57 <monochrom> you can use list comprehension or otherwise to pick out just the things you want.
19:11:01 <monochrom> then you can call sum.
19:13:05 <monochrom> sum [ x | ( ('A', _), x ) <- assocs ]
19:13:07 <monochrom> err
19:13:18 <monochrom> sum [ x | ( ('A', _), x ) <- assocs your_array_here ]
19:13:34 <PeterK> thank you , i'll do taht
19:15:55 <lispy> @pl \myarray -> sum [ x | (('A', _), x) <- assocs myarray]
19:15:56 <lambdabot> (line 1, column 17):
19:15:56 <lambdabot> unexpected "["
19:15:56 <lambdabot> expecting variable, "(", operator or end of input
19:16:07 <lispy> oh right...no list comps allowed
19:16:42 <SamB> jhc takes far too much RAM to compile the Time module...
19:17:36 <dons> ?wiki Libraries_and_tools/Operating_system#Hardware_emulators
19:17:37 <lambdabot> http://www.haskell.org/haskellwiki/Libraries_and_tools/Operating_system#Hardware_emulators
19:17:38 <dons> jip ^^
19:19:26 <jip> dons: cool thanks :D
19:19:53 <SamB> 781m and counting...
19:21:52 <dons> SamB, do you have an url for the jhc darcs src?
19:22:16 <SamB> dons: you don't?
19:22:50 <dons> lazy functional programmer
19:22:55 <SamB> http://repetae.net/john/repos/jhc
19:22:58 <dons> ?where jhc
19:22:59 <lambdabot> http://repetae.net/john/computer/jhc/
19:23:07 <dons> danke
19:23:20 <dons> going to have a snoop around the packed string code
19:25:28 <elsee> why should i program in haskell? just curious.
19:26:45 * lispy just realized what darcs really needs.  Cale working on conflictor theory and dons doing the performance tuning...
19:26:56 <lispy> dons: my new format is actually slower to parse!
19:27:50 <dons> ?google Why Haskell Matters
19:27:52 <lambdabot> http://www.haskell.org/haskellwiki/Why_Haskell_Matters
19:27:53 <monochrom> sum [ x | ( ('A', _), x ) <- assocs your_array_here ]  is one reason why I program in Haskell.
19:28:04 <i|> Hmm...
19:28:06 <dons> elsee: see here http://www.haskell.org/haskellwiki/Why_Haskell_Matters. its a good overview
19:28:15 <dons> also, check out the intros on haskell.org
19:28:39 <elsee> im an assembler programmer, just curious - ill check it out
19:30:33 <dons> elsee, the basic argument is that you'd pick up haskell if you wanted high assurance, bug free  code, with little to know debugging necessary
19:30:43 <lispy> dons: that page seems a bit preachy...
19:30:48 <palomer> scalliwags!
19:31:00 <SamB> dons: your english is buggy
19:31:08 <SamB> you meant to say "little to no"
19:31:12 <dons> using the powerful typesystem, the purity, and other mechanisms, to write correct code from the start.
19:32:17 <perry> "other mechanisms"?
19:32:19 <lispy> elsee: it's true, using haskell cuts developer time down quite a bit
19:32:28 * palomer thinks dons is sounding like a used haskell salesman
19:32:29 <lispy> dons no lie
19:32:38 <palomer> and it cures impotence
19:33:03 <lispy> palomer: that depends on how "excited" you are by lazy evaluation
19:33:33 <lispy> Haskell: Viagra for your mind.
19:33:47 <palomer> and it gets rid of that pesky women infestation problem. You'll be women free with ghc.
19:33:55 <dons> ?palomer
19:33:56 <lambdabot> blargh!
19:33:58 <dons> grumpy palomer
19:34:22 <palomer> you should add "scalliwags!" to that
19:35:00 <palomer> Haskell: you'll never have problems in bed, or much else really
19:35:23 <lispy> my gf just left me...i wonder if it's because of the haskell...
19:35:31 <dons> SamB, hehe. yeah. sometimes i let my spinal grey matter do spelling while my top brain is thinking abotu some code i want to write.
19:35:32 <elsee> why not ... J instead?
19:35:38 <dons> that was actually the case just then. 
19:35:39 <PeterK> "No instance for (Fractional Int)" <-- I get this when trying to make an array with decimal values out of an array with integer values.
19:36:01 <dons> decimals eh? you'll need to round or fromIntegral
19:36:14 <elsee> anyhow thanks for the info
19:36:21 <dons> elsee: J?
19:36:24 <lispy> java?
19:36:27 <elsee> no
19:36:31 <dons> i guess that's the big evil J
19:36:37 <lispy> BEJ
19:36:41 <SamB> APL relative?
19:36:45 <elsee> ya
19:36:50 <dons> Jaskell? the Java backend for Haskell.. ?
19:36:50 <SamB> before K, I think
19:36:55 <elsee> ya
19:37:34 <lispy> Jaskell...
19:37:42 <SamB> array programming and stuff, probably
19:37:45 <lispy> i can't imagine that being good for haskell...
19:38:43 <lispy> have you guys read this paper yet? http://members.verizon.net/%7Evze3fs8i/air/airpaper.html
19:39:45 <i|> @where jaskell
19:39:46 <lambdabot> I know nothing about jaskell.
19:39:52 <i|> @google jaskell
19:39:55 <lambdabot> http://www.scdi.org/~avernet/projects/jaskell/
19:40:13 <lispy> heh, when you saw your nick i thought you were a blubbering icky thing for a second...then i realized i'm in irc not angband....
19:40:24 <PeterK> adding fromIntegral worked
19:40:46 <lispy> PeterK: of course, dons' is never wrong ;)
19:40:55 <dons> jaskell was a java backend for haskell from about 6 years ago
19:41:14 <dons> not part of ghc.
19:41:30 <lispy> ah, too bad
19:41:40 <perry> hahaha: "The journal editor will pick the referee most likely to be offended by your paper, because then at least the referee will read it and get a report back within the lifetime of the editor."
19:41:47 <dons> the jvm isn't well suited to fp code
19:41:49 <lispy> adding .NET and JVM targets to ghc would have its uses
19:41:57 <dons> tail calls are the biggest problem. and memory traffic is painful
19:42:18 <lispy> dons: yeah and there was another one that's bad...um...oh, lambdas
19:42:36 <lispy> the way i've seen lambda's implemented normally is anonymous runnables
19:42:47 <dons> also, destructive updatse of thunks encoded as objects aren't possible. so you have to use indirection. nasty
19:43:13 <lispy> you end up with a lot of classes that need to be garbage collected when you use highorder functions, but not all JVMs clean up classes well
19:43:20 <dons> the jvm's over rated.
19:43:41 <dons> yeah, that's another point.
19:43:59 <dons> hmm: Apr 22 12:27:18 habanero /bsd: pppoe (data): unknown version/type packet: 0x81
19:44:06 <dons> funny packets eh?
19:44:20 * lispy whistles
19:44:55 <lispy> tomorrow is earth day in the US, how about other places?
19:45:05 <dons> earth day?
19:45:06 <lispy> (april 22, specifically )
19:45:10 <dons> sounds a bit new age..
19:45:30 <lispy> i got invited to a tour of a japanes garden for earth day...
19:45:33 <dons> is it a real holiday?
19:45:42 <lispy> well...not a work holiday
19:45:46 <dons> ah. oh well.
19:45:47 <lispy> but it's on the calendar
19:46:16 <lispy> i think i might hit the store and buy them a small house plant as a thank you
19:46:25 <lispy> not sure what else to do
19:46:52 <dons> :)
19:51:56 <sethk> dons, we've had our first successful end to end runs with the new software on site today
19:52:11 <elsee> im not sold yet, but thanks for the info - asm == easier and faster
19:52:27 <elsee> have a good evening
19:53:30 <dons> easier and faster. sigh.
19:53:40 <sethk> faster in what sense?
19:53:42 <dons> sethk, cool!
19:53:46 <sethk> certainly not faster to code
19:54:24 <dons> as we observed yesterday, so people are content, no , thrilled to code in a mixture of perl and asm for the rest of their days
19:54:41 <perry> asm?
19:55:10 <perry> who codes in assembly?
19:55:33 <perry> assembly in perl?
19:55:45 <monochrom> I don't actually understand the "easier" part.
19:57:06 <dons> people don't like learning new things. i don't know why.
19:57:30 <dons> it's the paul graham argument about the language you're currently using enclosing your world, so you can't imagine what a more powerful language would do 
19:58:00 <dons> and apparently even functions are too much sugar for elsee :}
19:58:01 <monochrom> I can understand the "faster" part, as a myth, i.e., "if I write asm code manually, it runs faster than compiler-generated asm code" and "if I make a wheel manually, it is rounder than machine-made wheels", i.e., some inferiority complex in the face of the inevitable machination.
19:58:13 <perry> isnt that sapir/whorrf?
19:58:17 <dons> i like that :)
19:58:27 <petekaz> so dons, are you saying haskell is higher on the language scale than lisp?
19:58:43 <dons> for sure. it's abotu 30 years more langauge technology in it
19:58:57 <sethk> dons, very positive initial reviews.  The software works identically every time you run it
19:59:04 <dons> excellent!
19:59:08 <sethk> dons, which would sound silly if it weren't for the way other software typically works
19:59:34 <monochrom> Perhaps I can understand "easier" from the (irrelevant) perspective that each asm instruction on its own has a simple semantics.
19:59:41 <sethk> I'm still getting a little bit of "now, why did you write it in, what was that language?"  but not as much as I was
20:00:52 <sethk> people have noticed that there are no core dumps and no abnormal terminations, which I consider a very positive thing (that it's been noticed, that is)
20:01:08 <dons> i'm really happy its been going so well.
20:01:19 <dons> these are exactly the benefits we should expect to see, really.
20:01:23 <dons> so its good to have this confirmed in a commerical setting
20:01:36 <sethk> dons, it's important for me to continue developing in Haskell on this project
20:01:43 <sethk> that is, the reaction is important
20:02:07 <sethk> because I sold the concept just about entirely on the basis of reliability
20:02:20 <dons> right. so the reliability must be maintained.
20:02:23 <SamB> well, you have to admit that its a long jump from ASM to Haskell...
20:02:44 <sethk> dons, well, that's more or less automatic if I don't do anything really stupid  :)
20:02:53 <sethk> SamB, I assume that pun was intentional  :)
20:03:09 <sethk> wish I thought of it  :)
20:03:09 <SamB> sethk: no!
20:03:23 <sethk> SamB, well, you should claim it was, even if it wasn't
20:03:26 <SamB> heh
20:03:33 <PeterK> I can't imagine doing "easier" programming in ASM :)
20:03:51 <sethk> PeterK, I had the same reaction
20:03:54 <SamB> well, easier than wrapping your head around structured and functional and pure all at the same time
20:03:56 <sethk> I've done asm programming
20:04:15 <SamB> easier to continue doing it, I mean
20:04:19 <sethk> SamB, is it?  Have you ever written a substantial program in an assembly language?
20:04:25 <sethk> it isn't easy
20:04:29 <dons> i hope you get a chance to use QuickCheck soon. once you get used to it, you end up with mechanically checked comments, essentially
20:04:30 <SamB> sethk: no, but I'm not fluent
20:04:44 <PeterK> Even for simple functions where it could make sense to use ASM, it is harder for me to do.
20:05:01 <sethk> dons, I should have time to try things now that we have a working delivery
20:05:06 <SamB> I have enough trouble reading the stuff produced by IDA
20:05:41 <sethk> I had the same reaction as several other people, in what sense could it possibly be easier?
20:05:47 <perry> how long have you worked on programming haskell vs. programming assembly?
20:05:49 <heatsink> what is IDA?
20:05:58 <SamB> the demo of which can incidentally be kept open indefinately if you leave it in the debugger until the time runs out, as long as it has trouble killing the target process...
20:06:00 <dons> so much grunt work though to get anything done. the productivity must be massively impaired no matter how good you are.
20:06:03 <sethk> perry, well, I did assembly work for about five years, although it was a long time ago
20:06:09 <PeterK> Maybe elsee can put together an ASM team for the programming challenge...which Haskell's won, how many times now?
20:06:14 <SamB> heatsink: interactive disassembler
20:06:16 <sethk> dons, yes, and the troubleshooting time
20:06:18 <heatsink> ah
20:06:23 <SamB> very nice program, I wish I could afford to buy it
20:08:34 <perry> i still have a printout of the nos kernel (all assembly)..  you can do it if you have a certain bent of mind
20:08:35 * vincenz remembers cracking programs with a cracked ida
20:09:53 <SamB> I'm in over my head right now trying to rewrite an entire program
20:10:13 <SamB> though at least its written in portable C, from the looks of it
20:11:22 <perry> SamB, i did that last time by first refactoring the C into a modularity suited for the target language
20:11:52 <perry> .. more suited ...
20:13:03 <perry> refactoring replaces equals with equals, so this made the final leap from C as small as possible
20:13:17 <SamB> perry: well, I mean, I'm trying to reconstitute something like the C source from the binary
20:13:25 <perry> ohh..  sorry
20:13:54 <heatsink> SamB: wow, that's awful.
20:14:04 <SamB> but, as far as I can tell, the program is written so that it would compile fine just about anywhere
20:14:48 <perry> how many functions?
20:15:08 <SamB> I'm not sure exactly
20:15:13 <SamB> probably less then 100
20:15:32 <perry> which platform?
20:16:11 <SamB> it runs on windows, but as I said it seems like it would compile fine anywhere
20:16:42 <perry> lots of function calls?
20:16:45 <olliej> jip: ooh, pretty pictures :)
20:16:59 <SamB> it deals with the image data compression in "The Legend of Zelda: A Link To The Past"
20:17:15 <sethk> assembly language is nothing but loads, jumps, and calls
20:17:21 <sethk> and stores of course
20:17:29 <monochrom> there are also add and subtract.
20:17:34 <SamB> maybe 50% of the calls in this program are to fseek and fread
20:18:09 <perry> the windows c++.net assembly i saw was not optimized, so was just a bunch of calls to primitives
20:18:22 <jip> SamB: excellent game :)
20:18:28 <jip> olliej: like them? :)
20:18:35 <olliej> jip: :)
20:18:53 <SamB> jip: it isn't a game, it is a ROM hacking tool
20:19:14 <SamB> or did you mean LttP itself?
20:19:21 <jip> SamB: i meant LttP :)
20:19:27 <SamB> hehe
20:19:29 <SamB> oh. yes ;-)
20:20:03 <SamB> I might have an easier time if I would give more of these functions names...
20:20:41 <SamB> it is unfortunate that OllyDbg is so much better at detecting switch constructs than IDA, too
20:21:15 <SamB> IDA seems only to handle the ones with jump tables
20:21:22 <PeterK> how do you do (6, 5, 2) - (3, 4, 4) = (3, 1, -2) in Haskell?
20:21:40 <dons> write an instance of Num for (a,b,c) ?
20:22:01 <heatsink> @type (>)
20:22:02 <lambdabot> forall a. (Ord a) => a -> a -> Bool
20:22:09 <heatsink> @info Num
20:22:10 <lambdabot> Unknown command, try @list
20:22:19 <SamB> you mean Num n => Num (n, n, n) ?
20:22:51 <SamB>  @info was too verbose
20:22:57 <dons> yep
20:22:57 <heatsink> hm.
20:23:02 <olliej> SamB: surely (Num a, Num b, Num c) => Num (a, b, c)
20:23:04 <olliej> ?
20:23:09 <heatsink> So Num <> Ord ? Must be some group theory thing.
20:23:15 <SamB> I think I missed it entirely, too!
20:23:24 <SamB> olliej: oh, maybe
20:23:26 <perry> instance (Num a, Num b, Num c) => Num (a, b, c) where (a1,b2,c1) - (a2,b2,c2) = (a1-a2, b1-b2, c1-c2) ....
20:24:17 <SamB> > sqrt (-1)
20:24:18 <lambdabot> NaN
20:24:25 <SamB> > sqrt (-1) :: Complex
20:24:26 <lambdabot>  Not in scope: type constructor or class `Complex'
20:24:34 <SamB> > sqrt (-1) :: Complex.Complex
20:24:35 <lambdabot>  Not in scope: type constructor or class `Complex.Complex'
20:24:37 <perry> > (1, 2, 3) - (3, 3, 3)
20:24:38 <lambdabot>  add an instance declaration for (Num (a, b, c))
20:24:38 <lambdabot>   In the definition of `xbk': xbk = (1, 2, 3) - (3, 3, 3)
20:24:38 <lambdabot>   In the definition of `yhjulwwiefzojcbxybbruweejw':
20:24:39 <dons> instance (Num a, Num b, Num c) => Num (a,b,c) where
20:24:39 <dons>     (a,b,c) + (d,e,f) = (a+d, b+e, c+f)
20:24:39 <dons>     (a,b,c) - (d,e,f) = (a-d, b-e, c-f)
20:24:39 <dons> main = print $ (6, 5, 2) - (3, 4, 4)
20:24:40 <dons> $ runhaskell A.hs
20:24:44 <dons> (3,1,-2)
20:24:47 <SamB> dons: why no complex numbers?
20:25:16 <dons> typeclasses forever!
20:25:20 <dons> ah, good point. adding..
20:25:22 <perry> why no octonions?
20:25:22 <olliej> dons: hehe
20:25:54 <SamB> 887m now...
20:26:01 <dons> they're not there by the principle of  least imports
20:27:03 <PeterK> > zipWith (-) [6, 5, 2] [3, 4, 4]
20:27:05 <lambdabot> [3,1,-2]
20:27:18 <dons> lists are good :)
20:27:34 <PeterK> Sorry I meant to use lists, not tuples.
20:27:35 <SamB> perry: those aren't even in the library, afaik
20:27:51 <perry> SamB, was a joke
20:28:08 <dons> yes, we should add a whole range of OnionN types.
20:28:13 <dons> Onion8, Onion1 and more
20:28:22 <perry> Onion?
20:28:36 <SamB> dons: haha
20:28:59 <dons> we could use a Nat kind to have convenient indexing of Ontion types. by their N
20:29:03 <SamB> does anyone know anything about GC RTS option tuning?
20:29:16 <perry> whats an onion type?
20:29:32 <SamB> perry: oct onions
20:29:36 <SamB> and more
20:29:52 <dons> and then f :: Onion 8 :+: Onion 4 :: Onion 11
20:30:00 <dons> or 122.
20:30:18 <dons> we could extend this to Schallots and Garlic types
20:30:29 <heatsink> dons: of course, each onion_n type has to contain an onion_{n-1} type
20:30:32 <perry> haha..  i believe there are several versions of onion4 and onion8
20:31:06 <perry> i still need to read my clifford algebra books
20:31:08 <dons> and collections of Onions can be contained in a SaladSandwich class
20:31:34 <SamB> dons: HLists?
20:31:39 <SamB> don't those have bad explosions, or was that fixed?
20:31:54 <dons> all SaladSandwiD[Dches should be Onion Functors, too.
20:31:55 <perry> meats and joints?
20:32:13 <perry> all the lettuce operations
20:32:13 <SamB> dons: do you know anything about the GC options for GHC's RTS?
20:32:19 <dons> a bit, yes.
20:32:27 <dons> what did you need?
20:32:57 <SamB> well, I'm trying to get JHC to use less memory ;-)
20:33:17 <dons> hmm.
20:33:47 <SamB> for some reason, the docs don't even mention -T
20:43:11 * SamB lays in more swap
20:46:23 <PeterK> I am using "accumArray (const id) 0 (('@','@'), ('Z','Z')) $ map (head &&& length) $ group $ sort $ zip text (tail text)" as suggested to get the matrix with the frequency of bigrams, as suggested.  However, it seems slow when working with 1MB files. Any suggestions for speeding this up?
20:46:49 <dons> 1MB files!
20:47:05 <dons> use FPS, with unboxed arrays.
20:47:15 <dons> so, Data.Array.Unboxed. and FPS to suck the files in.
20:47:19 <monochrom> I suggested not sorting if you store everything into a matrix.
20:47:50 <dons> 1M is going to be pretty hard on a String. you need a better data type. a packed string or UArray
20:47:58 <PeterK> I am currently using FPS just to suck in the files, and then unpacking them to [Char]. What are unboxed arrays?
20:48:07 <dons> don't unpack the string.
20:48:20 <SamB> dons: how should he get the bygrams?
20:48:26 <SamB> er, bigrams...
20:48:43 <dons> use FPS ops for tail and so on.
20:48:55 <SamB> how do you zip FPS together?
20:48:55 <dons> then dump the bytes into a Int Unboxed array, using the two Chars as a single Int key
20:49:39 <dons> hmm. write a zip.
20:49:51 <SamB> what would the result type be?
20:50:25 <dons> yeah, I see. it has to be pairs of Char, or maybe an Int key. you coudl get that efficiently writing a zip that uses unsafeHead.
20:51:19 <dons> firstly though, the easy bit, try a UArray Int Int
20:51:22 <SamB> and how do you make the Int key?
20:51:40 <dons> smoosh      the chars together
20:51:44 <dons> easy
20:52:03 <SamB> well, how do you do it so that the ranges line up nicely?
20:52:32 <dons> shiftL 8 ?
20:53:20 <SamB> isn't ther range something like '@'-'Z'?
20:56:42 <dons> I'm not going to write this code. But I've used this char smooshign trick successfully in a shootout entry, so it works fine as long as the range doesn't get to big.
20:57:59 <dons> and here the size of the UArray is going to be what? < 5000 Ints?
20:58:04 <dons> so that's fine.
20:58:21 <dons> PeterK: you following?
20:58:35 <PeterK> I am trying to understand.
21:01:32 <dons>  let c2w = fromIntegral . Char.ord
21:01:38 <dons>  let pack a b = ((c2w a - c2w 'A') `shift` 8) .|.  (c2w b - c2w 'A')
21:01:43 <dons>  pack 'A' 'A'
21:01:43 <dons> 0
21:01:47 <dons>  pack 'I' 'J'
21:01:48 <dons> 2057
21:01:53 <dons>  pack 'Z' 'Z'
21:01:53 <dons> 6425
21:02:01 <dons> so that's your keys into a UArray Int Int
21:02:12 <dons> SamB, yeah?
21:03:00 <dons> PeterK: what's the motivation behind this problem again?
21:03:03 <SamB> > 27*27
21:03:05 <lambdabot> 729
21:03:07 <dons> is it as assignment?
21:03:12 <PeterK> It's not homework.
21:03:15 <monochrom> answer text = sum [ x | (('A',_),x) <- assocs (accumArray (+) 0 (('@','@'),('Z','Z')) (zip (zip text (tail text)) (repeat 1))) ]
21:03:20 <PeterK> I can write a description of the problem though.
21:03:27 <monochrom> 7 seconds on runghc (ghci)
21:03:27 <dons> just for fun?
21:03:30 <PeterK> Yes.
21:03:44 <PeterK> To learn about Haskell, in large part. I've done the problem in C++.
21:04:12 <dons> ok, then welcome to "optimising haskell for large input". step 1, use similar structures to the ones you'd use in C++
21:04:13 <monochrom> 2.5 seconds on ghc -O.
21:04:24 <monochrom> These are on a 1GHz Pentium.
21:04:41 <dons> yeah, maybe its the unpack of 1M that's the issue
21:04:54 <dons> also, PeterK, you using -O ?
21:05:17 <SamB> -O definately would be a good idea ;-)
21:05:20 <PeterK> Hehe, no I haven't used that yet, I'll do that from now on.
21:05:31 <dons> ah ok. makes a *big* difference.
21:05:54 <PeterK> I uploaded my current code to http://www.haskell.org/hawiki/HaskellIrcPastePage
21:06:06 <PeterK> I think I kind of messed up the paste page though :(
21:06:27 <SamB> it works best if you use library functions that fuse nicely...
21:06:51 <Korollary> lisppaste2: url
21:06:51 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
21:07:28 <SamB>  8282 naesten   22   5  942m 169m  10m D  0.9 67.6  17:15.83 jhc               
21:09:17 <Korollary> wow
21:10:35 <monochrom> 1 second on ghc -O and with UArray (Char,Char) Int
21:11:32 <dons> ah, cool. you can use (Char,Char) as a key?
21:11:50 * dons forgets its just the elem that has to be unboxed.
21:11:50 <monochrom> UArray has contraint on the content only.
21:12:02 <dons> and what about if you pack the key? any difference
21:14:39 <monochrom> I am too sleepy to think how to translate "(('A',_),x) <- assocs blah" into the packed-key equivalent.
21:14:54 <dons> oh, I like it when elemIndices goes from 0.7s to 0.008s on 20M :)
21:15:07 <dons> monochrom: fair enough. probably not much benefit.
21:15:16 <SamB> dons: probably not much...
21:16:24 <dons> I was thinking that we had to unbox the key :$
21:16:55 <monochrom> It depends on how "instance (Ix a, Ix b) => Ix (a,b)" works.
21:17:40 <musasabi> hmm, DiffArray hashtables were quite easy, but the performance is slightly worse than Data.Map :-(
21:17:47 <monochrom> If it uses multiplication, then probably bit-shifting is significantly faster 
21:18:45 <musasabi> with lookups being the problem.
21:19:59 <SamB> monochrom: well, those multiplies could be fairly well optimized!
21:20:21 <SamB> and considering the overhead of all the other stuff that goes on, it might not make much difference
21:21:52 <PeterK> The problem is to take texts, to calculate the matrix of the frequency of the bigrams, and then to calculate the distance of two texts to each other by using a distance formula (subtract one frequency from the other, for each element in the matrix, square that, and sum up).
21:22:32 <PeterK> With more than two texts, say with 16 texts, you then create a distance matrix of the texts and see which ones group together.
21:28:15 <dons> monochrom: maybe you want to paste your code somwhere PeterK can view it?
21:29:52 <lisppaste2> monochrom pasted "uarray" at http://paste.lisp.org/display/19242
21:43:25 <Korollary> How significant is that "Haskell" above the giant "Haskell" logo at haskell.org?
21:44:46 <monochrom> Not significant.
21:45:36 <monochrom> On a text browser, the image is given the text "Haskell - A purely functional language" anyway.
21:45:41 <dons> not significatn. we don't know how to get rid of it.
21:45:47 <Korollary> hah
21:47:09 <Korollary> I also think that "purely functional" is not the same as "pure, functional".
21:47:43 <monochrom> Right.
21:48:25 <monochrom> "pure" is supposed to qualify "functional" rather than "language".  So it should be "purely functional".
21:56:56 <olliej> jip: ping?
22:00:46 <palomer> it's friday night, guys
22:00:49 <palomer> time to boogie
22:01:01 <olliej> palomer: it's saturday afternoon :)
22:01:09 <olliej> nope, evening rather
22:57:22 <adu> what was that python/haskell code that was both at the same time?
22:57:43 * palomer kills sdl
23:00:51 <olliej> palomer: :)
23:01:30 <palomer> >:O
23:03:22 <adu> i think it was something like this:
23:03:25 <adu> s -- def putStr(s): print s # main =  	putStr("Hello World!")
23:04:16 <palomer> is that ruby?
23:04:33 <adu> no it wassomething like python and haskell
23:04:48 <palomer> oh, righto
23:04:53 <adu> i don't remember who posted it
23:05:00 <adu> it was really cool
23:15:47 <davidmccabe> *sigh*.
23:29:00 <ski> > [(-),(-),(-)] `zipAp` [6,5,2] `zipAp` [3,4,4]  where  zipAp = zipWith ($)
23:29:01 <lambdabot> [3,1,-2]
23:29:12 <ski> > repeat (-) `zipAp` [6,5,2] `zipAp` [3,4,4]  where  zipAp = zipWith ($)
23:29:13 <lambdabot> [3,1,-2]
