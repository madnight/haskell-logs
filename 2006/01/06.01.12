00:00:26 <Keal> just a sidestory for ya since everyone is seemingly asleep
00:00:53 <zamez> and what've you been smoking?
00:01:18 <Keal> what have you been smoking? you narrow minded Haskell user? ;)
00:01:30 <lispy> Keal: does Cale work at NSA?
00:01:41 <Keal> hell if i would care
00:02:19 <Keal> all i know is i have experienced my own death unhappening...
00:02:35 <Keal> and a friend of mine unhappened period
00:03:03 <Keal> why do hundreds of people in the us every year go missing?
00:03:23 <Keal> its because the timeline diverges and past events themselves unhappen
00:03:24 <lispy> obviously they are unhappening
00:03:50 <lispy> i'm not sure why others don't see such a parsimonious explanation
00:04:17 <Keal> its goddamn okkams razor simplistic
00:05:03 <Keal> parsimonious????
00:05:37 <Keal> seriously its blazing obvious that the timeline itself is volitile
00:05:56 <Keal> if space can bend. why the fuck cant time?
00:06:12 <musasabi> Keal: how many percent of us do you think are NSA's bots and how many of us real people?
00:06:16 <zamez> <Keal> do i have permission to let you all in on a little secret?
00:06:18 <zamez> no
00:06:30 <lispy> Keal: http://www.dinosauria.com/jdp/misc/parsimony.htm
00:06:48 <mjl69> some are programmed to think they are human...
00:06:50 <luqui> does the implementation of STM support fairly "large" transactions well?
00:06:58 <sieni> I think I speak for many of us, when I say 
00:07:00 <sieni> wtf?
00:07:33 <lispy> mjl69: i'm one of those bots
00:07:39 <Keal> space bends, true. space has deformations, true. space has singularities, true. space is multidimensional, true. now what prevents time from being that way as well?
00:07:45 <musasabi> luqui: try it? I think it still needs some polishing, but it is one area that devs are interested in.
00:07:52 <Korollary> Ask your mommy. I am busy right now.
00:07:55 <lispy> i'm a bot programmed to think it is human that suspects it is a bot...
00:08:32 <luqui> hmmm, try.. it?  what a novel idea :-)
00:08:51 <lispy> Keal: did you read the page about the scientific definition of parsimony?
00:08:54 <mjl69> a human pretending to be a bot pretending to be human yet suspecting he may be a human pretending to be a bot
00:09:14 <lispy> mjl69: my head hurts when you say that
00:09:36 <musasabi> mjl69: :-)
00:09:51 <mjl69> I have to get to work on the script for the pilot right away :)
00:10:05 <zamez> I just read a story by Philip K Dick where a bot thinks he's a human and tries to prove it
00:10:27 <mjl69> oh, where he splices the tape?
00:10:30 <zamez> then he failed and exploded
00:10:36 <lispy> ah :(
00:11:18 <mjl69> I remember the one where he finds out he's a bot and finds the punch tape drum in his chest and starts experimenting with it.
00:11:32 <zamez> haven't read that
00:12:16 <lispy> Keal: from a scientific point of view, we have to reject your claims because those events can already be explained by well established scientific truths.  The burden of proof lies with you.
00:13:23 <lispy> anyway, i'm outta here.  If I don't sleep soon my schedule will diverge from the plan tomorrow
00:13:34 * lispy waves
00:13:56 <mjl69> goodnight!
00:14:19 <musasabi> night
00:14:29 <Keal> parsimony is where science goes wrong
00:14:48 <Keal> erm.
00:14:54 <Keal> antiparsimony is where science goes wrong
00:19:14 <dons> musasabi, oh definitely in loc.
00:21:43 <Keal> antiparsimony were 100% correct...
00:21:50 <Keal> b*(Floor[v/b^p]/b-Floor[Floor[v/b^p]/b])
00:21:54 <Keal> wouldnt be valid
00:22:39 <Keal> as it functions 100% correct and explains away how do to base n counting systemns
00:22:50 <Keal> even as irrational bases
00:23:16 <Keal> so lispy
00:23:48 <Keal> i have proven it correct by disproving already existing mathematical assumptions with already existing mathematical proofs
00:24:17 <Keal> which blows away a shitload of math you learned in school
00:24:22 <Keal> they dumbified you
00:24:26 <Keal> in other words
00:24:51 <Keal> i have basically written a proof that shows an assumption is wrong
00:25:21 <Keal> cuz when you assume you make an ass out of you and me
00:25:32 <Keal> so basically mathematics as we know it is fucked
00:25:40 <Keal> just ask mathematica
00:26:22 <Keal> plug plug Pi for v and Sqrt[2] for b and any value for p into that
00:26:34 <Keal> mathematica will give incorrect simplification
00:26:44 <Keal> i broke math
00:26:53 <Keal> try it lispy
00:27:32 <Keal> bow before the antichrist of mathematics :P j/k
00:27:40 <Keal> lispy :(
00:27:42 <Keal> where are you?
00:27:51 <Keal> brb food
00:27:54 <twb> dons: ping?
00:28:03 <sieni> http://math.ucr.edu/home/baez/crackpot.html
00:29:12 <twb> dons: y'know how you were talking about parsec parsers being drop-in yi modes?
00:43:16 <aleator> Hi! What is method of choice of easily writing/restoring haskell datastructures to/from file? show/read combination seems rather abysmally slow.
00:44:44 <musasabi> aleator: pick your favorite serializing library.
00:44:59 <musasabi> aleator: it seems everyone has at least a few sitting around.
00:45:24 <aleator> I was kinda asking if anyone got recommendations of those?
00:45:56 <aleator> since I haven't yet got a favourite :)
00:46:45 <musasabi> do you need cyclic structures?
00:47:10 <musasabi> if not Binary is easy, if you do SerTH works quite well.
01:13:37 <aleator> musasabi: Ok. I'll try binary. thanks
01:23:49 <joelk> let a = Data.Array.Unboxed.listArray (0,4) [0..4] :: Data.Array.Unboxed.UArray Int Int in Data.Array.Base.unsafeAt a 3
01:24:06 <joelk> ah, nevermind me...
01:59:34 <gour> dcoutts: ping
02:08:54 <joelk> oooh! ghci doesn't like interpreting unsafeArray...
02:11:19 <dcoutts> gour, pong
02:13:39 <gour> dcoutts: hi, akismet has started to work..and there is one comment in moderation queue. i'm leaving it up to you if you want to modify comment policy
02:14:06 <gour> (btw, today i received my gnome 2 book, but will have to wait a bit with it)
02:14:12 * dcoutts didn't realise there were any comment policy options that could be changed
02:14:36 <gour> i.e. whether one has to leave his/her name etc.
02:15:28 <gour> dcoutts: Options -> Discussion...
02:16:47 <dcoutts> gour, oh right, but they're not specific to askimet
02:17:23 <gour> dcoutts: true, so we're staying with our defaults?
02:17:41 <dcoutts> gour, unless you've got a suggestion?
02:18:16 <gour> nope, i think it's reasonable to expect email from the comment
02:18:44 <dcoutts> gour, oh, that comment is genuine!
02:18:51 * dcoutts was expecting spam :-)
02:19:02 <gour> dcoutts: that's why i'm asking
02:19:11 <dcoutts> right :-)
02:19:16 * dcoutts approves the comment
02:21:43 <gour> dcoutts: i was investigating about upgrade to gallery-2 yesterday, but,imho, it is not ripe time yet
02:22:17 <gour> dcoutts: wpg2 plugin does not support wp-2, so it's, better to wait
02:24:43 <gour> dcoutts: have you tried pida-recently? now it has plugin for devhelp reference books, pastebin plugin, some darcs functionality...nice if you use gvim daily
02:25:20 <dcoutts> gour, re: gallery2. That's fine. We can wait 'til you think it's ready.
02:25:29 <araujo> Good morning.
02:25:31 <gour> dcoutts: ok
02:25:44 <dcoutts> gour, I've not tried pida yet. Is there an ebuild?
02:26:32 <dcoutts> gour, it seems to be in portage but hard masked
02:26:47 <gour> dcoutts: no, just pick latest snapshot from the http://pida.vm.bytemark.co.uk/snapshots/ 
02:27:02 <gour> dcoutts: unpack in $HOME and run .develop.sh script
02:27:09 <dcoutts> ok
02:27:30 <gour> dcoutts: and you can give feedback to #pida too :-)
02:28:00 <dcoutts> right :-)
03:52:30 <joelk> @index runST
03:52:31 <lambdabot> Control.Monad.ST.Lazy, Control.Monad.ST, Control.Monad.ST.Strict
03:52:46 <joelk> @type Control.Monad.ST.Strict.runST
03:52:47 <lambdabot> forall a. (forall s. GHC.ST.ST s a) -> a
04:16:23 <MarcWeber> Can you think of any possibility of using the touch pad of a notebook in another way and still using an additional usb mouse as "mouse" ? e.g. the touch pad might be used as joystick or as numpad or ..? Would you have to develop your own mouse pad driver? Is there any documentation_
04:16:29 <MarcWeber> ?
04:16:44 <MarcWeber> Sorry.. wrong channel.
04:17:32 <MarcWeber> I really don't know why I did accidentally switch back to haskell..
04:22:28 <dons> musasabi, the harmonic loop code should be compiled with -optc-O3, makes a difference on the x86s i've tested on. http://shootout.alioth.debian.org/gp4/benchmark.php?test=harmonic&lang=all 
04:22:53 <dons> perhaps all code should get -optc-O3.
04:23:30 <jip> dons: hi, did you release hs-plugins 1.0 yet?
04:24:54 <dons> it's tagged. but not announced.
04:25:11 <jip> hm... i still have to send you that bug report :=
04:26:24 <dons> please hurry up then :)
04:28:33 <jip> hm... ok
05:18:41 <araujo> Hello.
05:19:09 <JKnecht> hi.
05:19:34 <Itkovian> am i correct when saying that foldr and foldl yield the same for a commuting function f ?
05:20:29 <Igloo> For an associative function f, if you ignore strictness
05:21:05 <Igloo> Oh, and you need e to be a unit of the function, roughly speaking
05:40:16 <int-e> @type fromInteger
05:40:17 <lambdabot> forall a. (Num a) => Integer -> a
06:04:30 <jip> did someone make a haskell type that represents the AST of a haskell program?
06:04:50 <xerox> GHC folks?
06:04:52 <dcoutts> @docs Language.Haskell.Syntax
06:04:52 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/haskell-src/Language-
06:04:52 <lambdabot> Haskell-Syntax.html
06:05:06 <dcoutts> it's Haskell98 I think
06:05:19 <dcoutts> or there's the Template Haskell AST
06:05:20 <kosmikus> there's haskell-src-exts that has Haskell with extensions
06:05:24 <kosmikus> and many others
06:05:39 <kosmikus> but there's no "standard" AST for Haskell, I think
06:15:34 <jip> hm... cool
06:15:56 <CosmicRay> JaffaCake: ping
06:16:06 <JaffaCake> CosmicRay: hi
06:16:46 <CosmicRay> JaffaCake: good morning.  I'm about halfway done with the libraries conversion.  I noticed that HaXml also has an upstream darcs repo.
06:17:27 <JaffaCake> nice going... I'll look at the HaXml repo
06:17:30 <CosmicRay> JaffaCake: so I just did a darcs get from the remote server and put the result there.
06:17:50 <JaffaCake> ok
06:17:53 <CosmicRay> JaffaCake: would you be able to take a quick glance at the files in /srv/darcs/packages and let me know if you see any obvious problems?
06:18:02 <JaffaCake> will do
06:18:59 <CosmicRay> whenever the cron job kicks off -- should be soon IIRC -- it will already be updating the repos I've made it to so far.
06:20:02 <JaffaCake> CosmicRay: are you still working on network?
06:20:27 <CosmicRay> JaffaCake: no, that one was just finished this morning IIRC
06:20:37 <JaffaCake> hmm, hang on
06:21:05 <CosmicRay> huh, wtf is this:
06:21:07 <CosmicRay> Wed Jan 11 13:56:54 PST 2006  Unknown tagger
06:21:08 <CosmicRay>   tagged cmm-merge2
06:21:25 <JaffaCake> I don't know
06:21:32 <JaffaCake> just saw it
06:21:32 <dcoutts> CosmicRay, I got "Unknown tagger" too when converting the Gtk2Hs CVS repo to darcs
06:21:44 <dcoutts> ask in #tailor
06:21:49 <CosmicRay> dcoutts: but tailor doesn't apply tags, does it?
06:22:07 <dcoutts> I'm not really sure
06:22:21 <JaffaCake> the tag is correct, I think
06:22:59 <JaffaCake> CosmicRay: looks fine so far
06:23:03 <SamB> and this "Unknown tagger" person has no email address?
06:23:13 <CosmicRay> JaffaCake: excellent
06:23:16 <CosmicRay> SamB: apparently not
06:24:04 <dcoutts> CosmicRay, I think it might convert cvs tags to darcs tags. After converting the gtk2hs repo, I did a darcs optimize --checkpoint and it seems that there was at least some darcs tag in the repo.
06:24:16 <CosmicRay> hmm, interesting.
06:27:36 <dcoutts> CosmicRay, though not all of them I think. There seemed to be a tag for the 0.9.9 release but not the 0.9.10
06:27:51 <CosmicRay> <lelit> uhm, it could, yes. iirc a contributed patch to allow cvs tag handling
06:37:09 <ihope> > error "Ping" 
06:37:10 <lambdabot> Add a type signature
06:37:19 <ihope> Good enough.
06:42:00 <SamB> darcs optimize --checkpoint rules
06:44:09 <Lemmih> SamB: I'm not really sure I wanna pick a less rare piece to promote diversity.
06:44:22 <SamB> Lemmih: I didn't say that!
06:44:43 <SamB> I said, "within a rarity level"
06:45:58 <Lemmih> so 'concatMap shuffle (group (sortBy (comparing fst) (zip usecounts pieces)))'?
06:46:32 <xerox> what a clear line
06:46:39 <SamB> Lemmih: split up some
06:47:11 <xerox> group (sortBy (comparing fst) (zip usercount pieces)) >>= shuffle
06:47:58 <resiak> Does that just yield a list? Is a list a monad?
06:48:05 <Lemmih> ie. only shuffle pieces with the same usecount.
06:48:08 <SamB> resiak: yes!
06:48:11 <SamB> Lemmih: yes
06:48:35 <xerox> @type \g xs ys -> group (sortBy (comparing fst) (zip xs ys)) >>= g
06:48:36 <lambdabot> Not in scope: `group'
06:48:36 <lambdabot>  
06:48:36 <lambdabot> <interactive>:1:19: Not in scope: `sortBy'
06:48:39 <SamB> Lemmih: also, what happens if none of our peers have a particular piece?
06:48:45 <xerox> @type \g xs ys -> List.group (List.sortBy (comparing fst) (zip xs ys)) >>= g
06:48:46 <lambdabot> Not in scope: `comparing'
06:49:07 <resiak> Okay, that's just totally confused me about the nature of monads. I thought that the point of them was to write essentially imperative code
06:49:34 <xerox> @type \g xs ys -> let comparing p x y = compare (p x) (p y) in List.group (List.sortBy (comparing fst) (zip xs ys)) >>= g
06:49:35 <lambdabot> forall a b b1.
06:49:35 <lambdabot> (Eq (a, b), Ord a) =>
06:49:35 <lambdabot> ([(a, b)] -> [b1]) -> [a] -> [b] -> [b1]
06:49:36 <Lemmih> SamB: pieces == pieces the remote have but we don't.
06:49:43 <int-e> How do I change the C stack size (for FFI) in ghc? I think there was an RTS option for that, but what is it?
06:49:47 <xerox> There you go, resiak.
06:49:48 <SamB> Lemmih: ah
06:50:44 <xerox> resiak: it yelts a list because of the use of 'zip'
06:51:14 <xerox> resiak: well, group probably influences it before, given that Haskell it's lazy, but that's the idea.
06:51:38 <resiak> xerox: Handy. I'm more confused by the monadic nature of lists... but I guess it makes sense
06:51:52 <xerox> resiak: monadic nature of lists is very straightforward
06:52:11 <resiak> xerox: That depends if you "get" monads, and I don't
06:52:14 <xerox> resiak: do you understand the underlying idea behind the 'concatMap suffle computation' line of lemmih up there?
06:52:18 <resiak> xerox: Sure.
06:52:33 <xerox> resiak: computation >>= shuffle would have been the same
06:52:51 <resiak> xerox: I seeeee
06:52:57 <resiak> Syntactic sugar, basically
06:53:03 <xerox> resiak: err.
06:53:12 <resiak> xerox: I know that it's _not_, but that's how you'd _use_ it.
06:53:42 <xerox> resiak: it's more like the other way around, the >>= (bind) in the monad instance of lists is 'concatMap'.
06:54:19 <resiak> xerox: I see... Oh, that makes sense, thinking about it. Thanks.
06:54:24 <xerox> resiak: it's simple, you have a list, and you want to perform an action that returns a list of results on each element, and collect all the results.
06:56:03 <xerox> > (map f [1..3],(=<<) g [1..3]) where f x = (x+1); g x = [x+1,x*2]
06:56:05 <lambdabot> ([2,3,4],[2,2,3,4,4,6])
06:56:49 <int-e> ah. simple. I set the right ulimit (so it's not an RTS option - I remembered that wrong)
06:57:11 <xerox> (=<< = flip >>=, just to get the same shape for the two values of the tuple)
06:57:44 <resiak> Sure, I get that. Okay, that looks (a) sensible; (b) clear; (c) useful. Thanks!
06:57:54 <xerox> resiak: great.  You're welcome.
06:58:17 <xerox> resiak: want to see other monads?
06:58:31 <resiak> xerox: I should get back to revising for exams tomorrow :-)
06:58:39 <xerox> Good luck :-)
06:59:51 <resiak> xerox: but this is a cool thing to have seen (a practical example of a monad other than IO actions). I'll rummage around in documentation this weekend.
07:00:38 <xerox> resiak: I suggest you to read 'All About Monads', it has plenty of cool examples.
07:02:34 * SamB wonders why his emacs opens TODO in a mode called Todoo
07:02:48 * resiak saves the tarball for later consumption.
07:08:47 <SamB> @hoogle unsafeCast
07:08:48 <lambdabot> No matches found
07:08:51 <SamB> @hoogle unsafe
07:08:52 <lambdabot> Language.Haskell.TH.Lib.unsafe :: Safety
07:08:52 <lambdabot> Language.Haskell.TH.Syntax.Unsafe :: Safety
07:08:52 <lambdabot> Language.Haskell.TH.Unsafe :: Safety
07:10:28 <Lemmih> @index unsafeCoerce#
07:10:29 <lambdabot> bzzt
07:10:50 <SamB> @hoogle unsafeCoerce
07:10:51 <lambdabot> No matches found
07:15:21 <dcoutts> @where yhc
07:15:22 <lambdabot> http://www.cs.york.ac.uk/~ndm/yhc
07:15:35 <dcoutts> @type GHC.Exts.unsafeCoerce#
07:15:36 <lambdabot> forall b a. a -> b
07:22:13 * SamB wishes this thing about Haskerl "if"s was true!
07:32:29 <SamB> so, somebody already tried spamming the Conjure list
07:33:19 <SamB> somebody else now too
07:39:11 <CosmicRay> JaffaCake: darcs conversion is done.
07:39:19 <JaffaCake> woohoo!
07:39:20 <CosmicRay> @seen autrijus
07:39:21 <lambdabot> autrijus has changed nick to audreyt.
07:39:21 <lambdabot> audreyt is in #haskell. I don't know when audreyt last spoke.
07:39:28 <CosmicRay> audreyt: that's confusing
07:40:02 <CosmicRay> JaffaCake: I moved libraries out of /srv/darcs to a Secret Location in my home directory
07:40:14 <CosmicRay> JaffaCake: should I do the same with libraries.ghc-6.4?
07:40:15 <JaffaCake> ok
07:40:20 <SamB> lambdabot is awfully in-the-know to know that...
07:40:26 <JaffaCake> yes, might as well
07:40:27 <earthy> drat. I hate my types blowing up so that I need huge screens to read them
07:40:32 <CosmicRay> JaffaCake: ok, will do
07:40:46 <JaffaCake> I'll have to update a few things now... instructions on the wiki, and the nightly builds
07:41:02 <JaffaCake> did you darcs optimise the new repos?
07:41:15 <CosmicRay> not yet, let me go do that now...
07:41:33 <SamB> but does lambdabot know that Autrijus is now Audrey and female?
07:42:03 <CosmicRay> JaffaCake: done.
07:42:11 <Saulzar> Probably it spots common nick changes
07:42:28 <SamB> Saulzar: it must have *been here* at the time
07:42:43 <JaffaCake> CosmicRay: great, thanks
07:43:07 <Saulzar> It could also use the nickserv id
07:44:02 <SamB> Saulzar, Saulzar... you don't really think lambdabot is going to query nickserv when you say "seen", do you?
07:45:06 <Saulzar> Nope, but I guess it doesn't use magic to figure out nick changes :)
07:45:42 * SamB wonders how hard it would be to rip Maple off of his XP box and get it going in Linux...
07:46:16 <SamB> Saulzar: no, it just pays attention ;-)
07:48:53 * Saulzar ponders creating a "World" data structure rather than dragging around some lists
07:49:12 <SamB> whatcha makin'?
07:50:22 <Saulzar> Same thing as before, re-working collision for about the 4th time :)
07:51:45 <SamB> a world datatype would probably be good
07:51:46 <Saulzar> I think I made it difficult for myself by chosing non-symetrical objects - robocode uses circles for everything I'm sure
07:52:08 <SamB> asymetrical objects can't be THAT hard...
07:52:24 <Saulzar> It seems quite tough to make collisions stable enough
07:52:43 <SamB> how are you detecting them?
07:52:59 <SamB> or are you having trouble with things bouncing through eachother or something like that?
07:53:02 <Saulzar> Convex polygons 
07:53:19 <Saulzar> Yeah, or getting suck overlapping a little bit
07:54:05 <Saulzar> This way seems to work, calculate collision points, apply impulses then just project objects out of each other until nothing collides anymore
08:39:27 * jip pokes dons 
08:42:48 <Philippa> I just wrote a haskell module to describe the household budget here. There is no saving us...
08:44:10 <chucky> philippa: You are not the first person I've met who uses Haskell as a spreadsheet. :)
08:44:50 <Philippa> yeah, I'm not surprised
08:45:01 <Philippa> I figured having the formulae as easily-viewable as the figures was a good thing
08:49:40 * Heffalump does that quite a lot
08:50:15 <Heffalump> once I used Haskell to keep track of money while on holiday then when I got home wrote a module to import it into my personal accounts system
08:50:53 <Philippa> heh
09:06:52 <carp> where's http://darcs.haskell.org/libraries gone?
09:07:02 <carp> (or am i losing my mind?)
09:08:10 <musasabi> carp: they are redoing the darcs version.
09:08:24 <carp> oh
09:08:39 <carp> thanks
09:09:02 * jip summons dons
09:09:13 <dcoutts> carp, see http://darcs.haskell.org/packages
09:14:27 <carp> oh so each package is a repo now
09:23:18 <CosmicRay> carp: yup
09:23:35 <CosmicRay> see my post to the ghc users list
09:36:19 <SamB> alright, who is spamming the conjure list?
09:40:26 <carp> CosmicRay: thanks, overlooked that mail
09:42:59 <Heffalump> SamB: already? :-(
09:44:16 <SamB> and I think I accidentally let the onto the list!
09:44:36 <SamB> well, two of them
09:44:36 <SamB> no wait.
09:45:03 <SamB> Heffalump: yes!
09:45:11 <SamB> four so far!
09:48:49 <Lemmih> Hi SyntaxNinja.
09:49:57 <SyntaxNinja> hi Lemmih
09:50:16 <lispy> wow, QuickCheck is really cool
09:50:34 <SamB> lispy: yup!
09:50:49 <SamB> especially the way it uses type classes
09:53:14 * SamB wonders why unrar doesn't work
09:54:14 <liyang> probably because it's old. Try rar x instead...
09:55:00 <SamB> yeah...
09:55:03 <lispy> SamB: the disappointing thing for me is that QuickCheck is a superset of an idea i had.  So that means, I cannot do anything new with my idea :)
09:55:22 <SamB> lispy: a superset?
09:55:28 <SamB> are you sure?
09:55:45 <SamB> lispy: anyway, at least it saves you tuits
09:55:51 <lispy> SamB: well, it does more than my idea and i don't think my idea can do anything QC cannot
09:56:01 <lispy> tuits?  the round kind?
09:56:15 <SamB> yeah
09:56:20 <lispy> heh
09:56:22 <SamB> nobody knows what to do with the square kind
09:56:41 <musasabi> I wish they would release the new QC code rather than just sitting on top of it.
09:56:42 <lispy> square tuits could be cool
09:56:58 <lispy> musasabi: maybe it needs more testing ;)
09:57:23 <musasabi> lispy: it works fine, I think it is more about license issues or some other nonsense.
09:57:44 <SamB> musasabi: someone should steal it
09:57:49 <SamB> in outer space
09:58:26 <musasabi> heh
09:59:47 <jip> who hear has the ear of dons?
10:00:16 * musasabi tries to parse
10:01:29 <JKnecht> want him to finish hs-plugin?
10:01:40 <jip> no i have a bug report
10:01:46 <Lemmih> finish hs-plugins?
10:02:23 <JKnecht> s/finish/annonuncd-bump to 1.0/
10:02:46 <jip> i have a bug report and it is criticial that he read it before 1.0
10:03:08 <Lemmih> How about mailing him?
10:03:31 <jip> i am banned from mail... but if someone sees him please refer him to here:
10:03:33 <jip> http://www.pocketpage.org/fileclosemergebug
10:03:52 <JKnecht> doesn't the bot do memos?
10:03:58 <musasabi> dons: see what jip is saying.
10:04:10 <musasabi> (now that should highlight properly)
10:04:58 <Switchplaces> must go today 2 alienware area51-m 7700 notebooks. price 600 for 2.  message me if interested on msn at mcsltd1@hotmail.com, aim at ogd443 or yahoo at thishastogotoday.  do have an auction set up on yahoo auctions for these.  
10:05:27 <Lemmih> Dude, that's so lame.
10:05:53 <JKnecht> they just kicked im on lisp.
10:06:21 <JKnecht> said it was stolen stuff.
10:06:48 <musasabi> well k-line probably coming up.
10:14:28 <pgavin> who can recommend a decent book for learning haskell?  I've learned a bit from various online tutorials already, but I'd like to get an actual book
10:15:00 <Philippa> TaPL's supposed to be good, but not in the way you're asking for
10:15:17 <Philippa> audreyt started implementing the stuff in it in haskell and ended up writing pugs
10:15:27 * liyang learnt from Hudak book.
10:15:31 <pgavin> TaPL?
10:15:48 <Philippa> Types and Programming Languages
10:15:51 <pgavin> ah
10:15:52 <Philippa> it's a book on type theory
10:15:53 <sieni> I got my copy today
10:16:03 <sieni> (and also ATTaPL)
10:16:20 <Philippa> comes with (give or take downloading them) example code in ocaml and an explanation of how it's taken from the formalisms
10:16:35 <Philippa> between that and an understanding of monads you can start building interpreters real fast
10:16:40 <gour> pgavin: i like http://www.cs.kent.ac.uk/people/staff/sjt/craft2e/
10:16:51 * Philippa just didn't use a book
10:16:56 <liyang> There's also: http://www.cs.nott.ac.uk/~gmh/book.html 
10:17:01 <Philippa> I kept attacking problems and looking for solutions
10:17:07 <liyang> (*cough*)
10:17:12 <Philippa> gmh's writing is generally good
10:17:24 <Philippa> liyang: I take it you're here now? :-)
10:17:26 <gour> Philippa: you're a smart head
10:17:51 <Philippa> gour: yeah, and I did spend a lot of time banging it against the wall once in a while
10:17:54 <liyang> I never finished reading Hudak actuallly. Learnt the rest from just using the thing (and the ghc reference docs.)
10:18:00 * Philippa nods
10:18:09 <liyang> Philippa: in my office. :)
10:18:09 <Philippa> the GHC references could use more usage info sometimes though
10:18:29 <Philippa> liyang: which is in which city now? :-)
10:18:31 <gour> Philippa: my wife is doctor, if the head still hurts...
10:18:35 <Philippa> (I'm in cam over the weekend anyway)
10:18:48 <Philippa> gour: heh. I know how to do it so I don't cause too much damage...
10:19:03 <pgavin> thnx everyone
10:19:06 <gour> Philippa: strange habit :-=)
10:19:17 <Philippa> doesn't happen too often, thankfully :-)
10:19:24 <liyang> (I should probably disclose my personal interests while plugging GMH's book shouldn't I... ^_^;;)
10:19:36 <gour> liyang: have you read that book?
10:19:43 <Philippa> yes, yes you should :-)
10:19:46 <liyang> gour: er... nope. 
10:19:55 <liyang> But I will. :)
10:19:56 <Philippa> I read the course notes it was derived from, and took the course
10:20:33 <gour> liyang: share here..
10:20:47 <Philippa> gmh is going to be your supervisor, right?
10:21:47 <liyang> he is already. :)
10:23:25 <gour> dcouuts: 5min ago i noticed our header pic on the site disappeared ?
10:23:44 <gour> dcoutts: the lonk was missing..
10:23:55 <dcoutts> gour?
10:24:00 <gour> s/lonk/symlink
10:24:36 <dcoutts> oh, is it fixed now? It's working for me, even after bypassing the caches.
10:24:55 * gour fixed it, but wonder what happened
10:25:04 <dcoutts> actually I notice that our banner has an odd coloured border
10:25:16 <dcoutts> it's probably because I messed up when changing it before
10:25:31 <dcoutts> perhaps it's supposed to be transparent at the border
10:25:54 <dcoutts> or perhaps the colour just changed slightly with the various format conversions I had to do.
10:25:55 <gour> no idea..
10:26:21 <gour> maybe wp-2 changed colors
10:26:40 <dcoutts> actually it was like that before you converted to wp 2
10:26:56 <gour> hmm, never noticed :-(
10:27:15 * gour is interested only for the content
10:31:31 <sproingie> i think it dawns on me that i have to be delirious with fever to tackle the hard topics like monads
10:31:55 <sproingie> read All About Monads for the 8th time, and it all makes sense
10:32:45 <gour> dcoutts: check a site!
10:33:03 <dcoutts> ooh!
10:33:23 <gour> how do you like it (new theme) ?
10:34:11 <dcoutts> mmm, not really.
10:34:59 <dcoutts> it has some good things
10:35:12 <dcoutts> and some things that would need to be fixed
10:35:16 <gour> it is vanilla - no tweaking
10:35:23 <dcoutts> but in general I think the other one was better
10:35:31 <dcoutts> even after the obvious things were fixed
10:35:31 <gour> ok
10:35:37 <dcoutts> it's too light I think
10:35:50 <dcoutts> the contrast between the background and foreground
10:36:06 <gour> check others' screenshots
10:36:21 <dcoutts> and the text colour is too light on a white background
10:36:24 <dcoutts> where?
10:36:38 <gour> Presentation has a link
10:36:45 <dcoutts> one good thing is that it makes the rss feeds easier to see
10:37:05 <gour> http://wordpress.org/extend/themes/
10:37:12 <dcoutts> I don't know if we need / want the search bar
10:37:37 <dcoutts> or did we have that before and I just never noticed?
10:38:04 <gour> we did have :-)
10:38:18 <dcoutts> oh yeah :-)
10:38:29 <dcoutts> I only noticed it because it moved :-)
10:38:36 <gour> lol
10:39:01 <dcoutts> heh, the search even works!
10:39:07 <dcoutts> http://haskell.org/gtk2hs/?s=svg
10:39:49 <gour> i was close thinkin' you searched for 'cairo'
10:39:59 <gour> :-)
10:40:41 <dcoutts> I did that too :-)
10:40:56 <gour> my intuition did not fail :-)
10:41:37 <gour> it's enocuraging for my jyotish study :-)
10:42:35 <gour> dcoutts: if you downloaded pida snapshot, do it once again, the new one is up fixing some important stuff
10:43:04 <dcoutts> when I checked last, gentoo had the latest version
10:43:49 <gour> yep, but lot of development has happened recently, it's almost a new app
10:44:41 <gour> although for all features one needs e.g. latest meld from cvs
10:45:03 <dcoutts> yeah I'm waitign for the next meld release with the darcs plugin
10:45:59 <dcoutts> gour, just at the moment I'm working on the new gtk2hs treeview api, I'm sending it to the devel list. Perhaps you'll think about it in relation to your db ideas.
10:46:32 <dcoutts> @seen jyp
10:46:33 <lambdabot> I saw jyp leaving #haskell 1 month, 3 days, 20 hours, 42 minutes and 25
10:46:33 <lambdabot> seconds ago, and I have missed 18 days, 14 hours, 4 minutes and 7 seconds
10:46:33 <lambdabot> since then.
10:48:45 <gour> dcoutts: i saw your email(s), but i'm still lacking haskell skills to give a valuable feedback regarding the proper solution(s)
10:49:02 * gour save those email in his archive
10:49:47 <dcoutts> gour, actually it's not those ones, they were about low-level FFI stuff.
10:50:01 <dcoutts> I've not posted yet about the new high-level api
10:50:15 <gour> huh, it's encouraging a bit :-)
10:50:52 <gour> but you already posted about treeview api?
10:53:25 * SamB wonders what is a good way to reverse a compression format
10:55:04 <jip> dcoutts: you use an interesting "design pattern" in the with*Pattern functions in the cairo bindings. did you invent the idea?
10:55:29 <dcoutts> jip, no, it's been around a while
10:55:40 <dcoutts> the previous cairo bindigns used the idea
10:55:43 <SamB> doesn't PS use that pattern?
10:55:46 <dcoutts> and I've seen it elsewhere
10:56:02 <SamB> only in a much less clearly-visible way?
10:56:11 <jip> do you know of anywhere where it's written about?
10:56:12 <SamB> or is that only for transformations...
10:56:24 <dcoutts> it's possible to subvert it by returning the resource from the inner function
10:56:38 <jip> dcoutts: how is that possible?
10:56:43 <dcoutts> the only way to stop that would be to use rank-2 types
10:56:53 <SamB> which are a pain in the neck!
10:57:06 <dcoutts> jip, withResource $ \resource -> return resource
10:57:09 <dcoutts> SamB, yeah
10:57:14 <SamB> they stop so many things that seem perfectly reasonable!
10:57:28 <dcoutts> SamB, so we didn't bother, we just tell people not to do that!
10:57:39 <SamB> which would work if only the compiler would just shut up and unfold the functions
10:57:55 <jip> dcoutts: but if people don't listen and do do that then they will get a segmentation fault?
10:58:05 <dcoutts> jip, probably yes.
10:58:08 <SamB> STUArray is a good example of how this is annoying
10:58:31 <dcoutts> jip, because the object will be accessed after it has been freed. So a segfault or an assertion.
10:58:47 <jip> dcoutts: i understand. maybe in a debug version you can give an error message instead of segmentation fault
10:58:55 <SamB> write a function polymorphic in STUArray element type... no problem!
10:59:07 <dcoutts> jip, yeah, that wouldn't be too hard.
10:59:09 <SamB> try to runSTUArray it and boom! type error.
10:59:25 <dcoutts> jip, the nice thing is that one can mix the two styles.
10:59:42 <jip> dcoutts: hm.... which is the other style?
11:00:00 <SamB> oh, this is the same sort of thing as withForeignPtr...
11:00:02 <SamB> I see!
11:00:12 <dcoutts> jip, one can provide new* style ones that give GC-managed resources, or the with* style that gives guaranteed resource management.
11:00:39 <jip> dcoutts: i see. does haskell have builtin support for with* style for opening files maybe?
11:00:46 <SamB> or the malloc style...
11:00:51 <SamB> with neither!
11:01:02 <dcoutts> jip, see Control.Exception.bracket
11:01:33 <dcoutts> jip, the new svg extension to cairo uses both styles:
11:01:34 <dcoutts> http://darcs.haskell.org/gtk2hs/svgcairo/Graphics/Rendering/Cairo/SVG.chs
11:01:35 <jip> dcoutts: i shall see this, but if this is indeed what i am thinking of then wouldn't this be the preferred way of working with files, instead of having to manually close them?
11:01:47 <SamB> jip: nah!
11:02:06 <SamB> the preferred way of working with files is to readFile them...
11:02:08 <dcoutts> jip, in some circumstances the with* style is not very easy to use
11:02:11 <Lemmih> The Conjure spamming is getting annoying.
11:02:30 <SamB> Lemmih: oh, did the mailing list send you the admin passward?
11:03:10 <Lemmih> Nope.
11:03:37 <SamB> sorry I added you as an admin and didn't send the passward!
11:03:44 <jip> dcoutts: like if i want to switch a lot between 2 different patterns?
11:03:48 <SamB> should I remove you or send you the passward?
11:04:25 <Lemmih> I would like to be removed, thanks.
11:04:36 <SamB> sorry again!
11:04:57 <Lemmih> No problem (:
11:05:17 <dcoutts> jip, yeah, having both styles is fine I think. If resource usage is temporary, frequent and expensive then the with* style is good. In most other cases the normal style is more convenient.
11:05:17 <SamB> but yes, they are getting annoying!
11:05:30 <SamB> thats like the fifth one I've seen!
11:05:41 <dcoutts> jip, so providing both in a library allows both usage patterns.
11:06:17 <SamB> Heffalump: is there any possibility of running a spamfilter over messages from unsubscribed people?
11:07:21 <Heffalump> not trivially
11:07:46 <Heffalump> but you could spamfilter the moderation messages you get
11:07:59 <jip> dcoutts: i see. but the best would be an improved "design pattern" that will be useful in all cases and will prevent people from "leaking" out the resouce :)
11:08:06 <SamB> hmm, apparantly I can say I only want to see the accumulated admin requests..
11:08:33 <dcoutts> jip, well if you find such a pattern do tell us! :-)
11:09:35 <SamB> jip: that reeks of NP
11:10:04 <dcoutts> jip, guarantees on resource usage and convenience usually have to be traded off against each other.
11:10:17 <SamB> sounds suspiciously like "will this ever be used again", which sounds suspiciously like "will this program ever terminate"
11:10:27 <SamB> in fact, they could be seen as the same in a way...
11:10:33 <dcoutts> SamB, yes.
11:10:42 <dcoutts> that's why region analysis is conservative.
11:10:44 <SamB> because you could also say "is this continuation dead"
11:13:14 <Philippa> it sounds a bit like a linear typing issue, only not?
11:13:31 <SamB> so I have proved that the halting problem is a special case of exact resource management
11:14:49 <dcoutts> SamB, of exact static resource management
11:14:56 <dcoutts> dynamially you can do it
11:15:10 <SamB> dcoutts: not really
11:15:11 <dcoutts> if you run the GC after every interesting operation
11:15:13 <Philippa> dynamically you can observe that you've not given it enough time yet ;-)
11:15:43 <SamB> dcoutts: dynamically you can say "oh, I'm not sure if this is still needed or not"
11:16:15 <dcoutts> SamB, hmm, ok so that's the same as current GC's
11:16:34 <int-e> right. do { p <- allocate; will_this_ever_halt; use p }
11:16:36 <dcoutts> where it finds a reference to some object but we don't know if it'll ever be used again
11:17:08 <dcoutts> I was just thinking about the restricted problem of reachability
11:17:16 <SamB> see! you need to solve the halting program to know if p is dead while executing "will_this_ever_halt"
11:19:34 <Heffalump> SamB: one might define deadness in terms of the "weak until" of temporal logic instead of the "strong until" (or maybe I mean vice versa)
11:20:45 <SamB> Heffalump: ah! but then it wouldn't be called "exact resource management"
11:21:54 <dcoutts> SamB, I was thinking "exact resource management" meant Heffalump's "weak until" version.
11:22:02 <dcoutts> ie what current GC's do.
11:22:21 <SamB> maybe I am not using the correct term ;-)
11:22:43 <Heffalump> dcoutts: except you need to consider the behaviour of compilers too
11:22:57 <dcoutts> SamB, I don't know if there's a commonly accepted terminology
11:23:05 <Heffalump> a compiler might turn do { p <- allocate; loop; use p } into do { p <- allocate ; loop }
11:23:09 <Heffalump> because use p is known dead code
11:23:14 <SamB> lets just say "absolutely leak-free"
11:23:40 <Heffalump> so if we want a GC spec that is deterministic, it should treat p as dead regardless (except of course it can't cos of the halting problem)
11:23:54 <Heffalump> s/deterministic/deterministic with respect to source code/
11:24:06 <SamB> hmm?
11:24:34 <dcoutts> Heffalump, right, and the compilers can sometimes statically determine that something component of a value will never be used again so it can replace it with NULL so the GC might be able to free the object.
11:25:06 <dcoutts> there's a term for that too, but I can't remember what
11:25:34 <SamB> zeroing, I think
11:25:49 <dcoutts> sounds familiar
11:26:18 <SamB> well, thats not really the whole term and might not be part of the term itself...
11:26:25 <int-e> the usage of 'live' does not seem to be clear. http://www.memorymanagement.org/glossary/l.html#live
11:28:09 * Speck thinks about how unfortunate it is that the Dynamic Optimizations using GADTs paper is only available through the ACM Portal, though he has access to it :-)
11:29:45 <SamB> paperwarez?
11:29:48 <Heffalump> Speck: linked from http://www.cs.nott.ac.uk/~nhn/papers.html
11:30:11 <Speck> oh snap, that wasn't there last I checked
11:30:25 <astrolabe> Is it fair to describe the haskell type inference system to a C++ programmer as like automatic maximal templatisation?
11:30:38 <SamB> astrolabe: huh?
11:32:05 <astrolabe> templates let you write functions that can work on many different classes.
11:32:16 <SamB> yes...
11:32:17 <Speck> I'm interested in using (or writing) a plugin-based gadt-optimized bi-arrow combinator library for parsing/pretty printing. Aside from relevant papers, can anyone think of useful links for me?
11:32:35 <astrolabe> haskell programs automatically tend to work on many different types.
11:32:50 <astrolabe> *haskell functions.
11:33:34 <SamB> astrolabe: something like that...
11:33:35 <astrolabe> in fact, as many types as is possible (hence maximal)
11:33:38 <SamB> only without code bloat
11:33:47 <SamB> you are thinking of principle types
11:34:04 <SamB> which are the kind that get inferred
11:34:06 <Heffalump> Speck: you've read the HW paper on bi-arrows?
11:34:08 <astrolabe> That's it. thanks.
11:34:23 <Speck> Heffalump: yup.
11:34:47 <astrolabe> Speck: How did your course go?
11:34:48 <Heffalump> I don't have any other suggestions, except to say that I think that would be a very cool thing to do.
11:34:56 <Speck> astrolabe: I got an A!
11:34:59 <Heffalump> it's always annoyed me that one has to write the two separately
11:35:06 <Speck> Heffalump: I couldn't find many non-trivial examples of the uses of bi-arrows (other than the ones given in the paper)
11:35:28 <astrolabe> Excellent!  Considering how much you knew at the start, that's really good.
11:35:42 <Heffalump> I think the authors suggested this application themselves, TICBW
11:35:43 <SamB> Speck: you can write your thesis on this!
11:36:11 <Speck> SamB: it would be a funny thesis for an English major to write... unless I made it exceedingly postmodern somehow...
11:36:24 <Heffalump> switch major ;-)
11:36:27 <SamB> Speck: you could say it was post-postmodern
11:36:35 <Speck> SamB: that would probably be enough :-)
11:36:44 <Speck> @quote FrederickJameson
11:36:45 <lambdabot> FrederickJameson hasn't said anything memorable
11:36:46 <Igloo> Heff: Is it going to save any actual coding?
11:36:55 <jip> hm... rank 2
11:37:01 <Heffalump> Igloo: should do, because the structure will be the same
11:37:15 <SamB> nobody actually knows what post-postmodern is, so you would just get to write it the normal way then
11:37:20 * Igloo will have to see it before I believe it
11:37:40 <Speck> SamB: Frederick Jameson wrote a very good book tying it to a Marxist late capitalism
11:40:25 * SamB wonders why rar is globbing through ~/
11:43:29 <palomer> how can one create a derivable type class?
11:44:05 <Speck> DriFT?
11:44:33 <SamB> hack GHC
11:45:14 <SamB> or, export a TH function create the instance
11:45:36 <palomer> hrm, seems haskell needs something like metaML
11:45:47 <Heffalump> that's what TH is
11:45:51 <Heffalump> except not as clean
11:45:55 <SamB> is that anything like TH?
11:46:11 <SamB> Heffalump: which isn't as clean?
11:46:13 <Heffalump> TH
11:46:21 <Heffalump> (IMO, and from only limited experience of each)
11:46:29 <palomer> metaML always produces type checkable code
11:46:32 <SamB> Heffalump: what does metaML do better at?
11:46:37 <SamB> oh. type checkable, eh?
11:46:38 <SamB> how?
11:46:40 <Speck_> oh this is why Speck_ is in the channel all the time. I forgot about a detached screen!
11:47:16 <palomer> it sucks that you can't have derivable type classes, really
11:47:39 <palomer> can't write, rather
11:47:41 <Heffalump> SamB: by not allowing direct manipulation of ASTs, IIRC
11:47:58 <SamB> palomer: agreed!
11:48:05 <Speck> I've never used DriFT, but isn't that what it's supposed to do?
11:48:19 <SamB> palomer: why don't you go start by porting Linker.c to all platforms supported by GHC
11:48:22 <palomer> let's incorporate it into the standard
11:48:40 <SamB> Speck: drift makes you add things to drift
11:48:46 <SamB> ugly things!
11:49:17 <SamB> drift has no concept of ASTs for output code!
11:49:17 <Speck> gtg bbl
11:49:29 <Speck> thanks for clearing it up tho 
11:55:37 <palomer> and we shouldn't have to use [| |] to write code processed by TH
11:55:53 <SamB> palomer: why is that?
11:56:08 <musasabi> palomer: but TH breaks referential transparity.
11:56:19 <palomer> so do implicit arguments
11:56:33 <musasabi> normal implicit arguments?
11:56:37 <SamB> musasabi: never mind referential transparency! think of the poor type checker!
11:56:48 <palomer> yeah
11:56:56 <SamB> palomer: no they don't! they just break my head!
11:57:01 <musasabi> SamB: I am conserned of "let x = 5 in foo x" and "foo 5" being different.
11:57:12 <palomer> ok, then linear implicit arguments:o
11:57:37 <musasabi> I think most people consider lin. implicit arguments as evil.
11:57:54 <SamB> palomer: you mean linear variables? those are apparantly just broken!
12:00:17 <palomer> anyways, who cares about referential transparency?
12:00:32 * SamB does
12:00:47 <palomer> sometimes it's simply better not to have it
12:00:50 <SamB> but only when it isn't too inconvenient
12:01:02 <palomer> for example, say we were encoding lambda calculus
12:01:06 <SamB> but I don't think [| |] is too inconvenient
12:01:35 <palomer> I think we can all agree that the string representation is slow and ugly
12:01:59 <SamB> yeah
12:02:15 <SamB> wait, what string representation?
12:02:17 <palomer> data Term = Lambda (ref Term) Term | App Term Term | Var (ref Term) is much more elegant
12:02:31 <dcoutts> ref?
12:02:36 <palomer> data stupidTerm = Lambda String Term | App Term Term | Var String
12:02:43 <palomer> dcoutts: a reference
12:02:54 <palomer> now substitution becomes a breeze!
12:03:06 <palomer> and is so much faster
12:03:51 <SamB> but... that isn't re-entrant!
12:03:53 <palomer> substitute (Var t) u x = if x == t then t:=u else ()
12:04:00 <palomer> SamB: reentrant?
12:04:13 <SamB> yes!
12:04:17 <palomer> what does that mean?
12:05:05 <SamB> it means that if a function is recursive, its new arg will call replace its old arg!
12:05:29 <sieni> palomer: http://en.wikipedia.org/wiki/Reentrant
12:05:48 <palomer> SamB: example?
12:06:22 <SamB> references aren't referentially transparent, so examples are hard to present...
12:07:06 <palomer> I don't see a problem with this definition
12:08:00 <musasabi> palomer: and you will run into problems with cycles.
12:08:12 <palomer> okok, what about this:
12:08:19 <palomer> substitute (Var t) u x = if x == t then t:=copy u else ()
12:08:24 <palomer> that way, no problems!
12:08:42 <palomer> and application is even easier
12:09:13 <palomer> apply (Lambda x _) y = x := copy y
12:09:26 <palomer> what more could a man want?
12:10:08 <palomer> a lambda calculus evaluator in...2 lines?
12:10:15 <palomer> let's see haskell do that!
12:10:41 <palomer> (and with better performance, too!
12:12:05 <palomer> this is the only thing that really bothers me about haskell
12:35:48 <lispy> palomer: if all you want is mutable state, that is possible outside of Haskell 98 for sure, and maybe even with haskell 98 if you use the ffi?
12:36:15 <dcoutts> you can use STRefs in the ST monad of course
12:36:23 <dcoutts> anyone know of an implementation of a sequence type that supports: random access, random insertion and random deletion?
12:36:23 <Lemmih> The FFI isn't part of Haskell98.
12:36:54 <lispy> Lemmih: ah
12:36:57 <palomer> but can I do Term = Var (STRef Term) | App Term Term | Lambda (STRef Term) Term ?
12:37:04 <dcoutts> palomer, yes
12:37:08 <musasabi> + s
12:37:16 <dcoutts> and then your ops will be in the ST monad
12:37:20 <musasabi> (the foralls make it a litle more complex.
12:37:25 <palomer> and what would be the type of eval?
12:37:50 <palomer> Term -> Term?
12:37:50 <gour> dcoutts: latest pida can embed gazpacho (0.6.3)
12:38:01 <dcoutts> gour, nice
12:39:07 <lokijuh> hi all!
12:39:22 <gour> dcoutts: and it keeps everything in buffer-list, so you can switch between source-code files, ui files etc.
12:41:15 * palomer has the feeling that programming with mutability is like staying in the ST monad _all the time_
12:41:38 <lokijuh> one stupid question... is there some function to denote pattern matching (something as (\x -> case x of { X _ -> True; _ -> False}) )??
12:41:40 <dcoutts> palomer, yeah, probably
12:41:53 <lispy> palomer: only the operations which update the state *need* to be in ST
12:42:33 <lispy> palomer: inside ST you can pull out a non-monadic value, apply a function and then stuff it away again.  But if you do it that you occasionally need to force a computation.
12:42:50 <xerox> lispy: but then, you can't easily recognize (humanly and programmatically) the *others*, generally speaking.
12:42:59 <palomer> lispy: so eval cannot be Term -> Term, right?
12:43:23 <lispy> palomer: well, there is runST
12:43:45 <lispy> xerox: i don't understand
12:44:09 <SamB> lispy: may I remind you of the bouncer?
12:44:33 <xerox> lispy: in some sense palomer is right, because you can't easily recognize if a function is pure or not.
12:44:36 <Heffalump> lokijuh: there's no generic function of that form, no.
12:46:33 <lispy> SamB: sure, what is the bouncer?
12:46:57 <SamB> lispy: rank-2 polymorphism?
12:47:17 <palomer> oh, runST should do it
12:47:18 <palomer> I get it:o
12:47:31 <lispy> SamB: rank-n polymorphism topics are on my list, but i haven't studied them
12:47:46 <palomer> lispy: but runST will get rid of the references
12:47:49 <palomer> right?
12:48:00 <SamB> well, note that STRef takes two type variables...
12:48:05 <lispy> palomer: yeah because it gives you back the value of the computation
12:48:09 <SamB> er, two types...
12:48:31 <SamB> @kind Data.STRef.STRef
12:48:33 <lambdabot> * -> * -> *
12:48:46 <SamB> also note
12:48:56 <SamB> @type Control.Monad.ST.runST
12:48:58 <lambdabot> forall a. (forall s. GHC.ST.ST s a) -> a
12:49:17 <SamB> see that little forall?
12:49:23 <lispy> which one?
12:49:36 <SamB> the one inside
12:49:41 <lispy> okay
12:49:44 <SamB> the outside one is irrelevant
12:50:32 <SamB> well, that keeps you from returning anything that contains STRefs from the computation...
12:51:01 <SamB> @type Data.STRef.newSTRef
12:51:03 <lambdabot> forall a s. a -> GHC.ST.ST s (GHC.STRef.STRef s a)
12:51:14 <lispy> right, i realized you can't keep the refs after runST
12:51:55 <SamB> also, you'd need to thread s through Term
12:52:01 <lokijuh> Heffalump: that`s bad.. thanks
12:52:05 <lispy> it does pose a problem, this is true
12:52:30 <lispy> i guess in that case you cant really escape ST
12:52:47 <SamB> not without unsafePerformST ;-)
12:52:55 <lispy> er :)
12:53:09 <Heffalump> unsafePerformIO . stToIO, in fact.
12:53:31 <Heffalump> but don't do that, of course.
12:53:38 <Cale> hello
12:53:45 <lispy> Cale: hi
12:54:19 <lispy> Cale: i don't know if you bumped into it, but someone was here looking for you last night and sounding like an absolute quack (probably to get attention).
12:54:30 <Cale> oh, yeah, I'm aware of that
12:54:45 <Cale> I was tired of him :)
12:55:03 <Cale> You can only humour that kind of person so much
12:55:10 <lispy> Cale: i find it somewhat amusing (i'd want to get him banned if he was a regular...) in that his "theories" were just odd
12:55:13 <lispy> yeah
12:56:47 <Cale> anyway, regarding the above, I'm of the view that you really ought not to want to escape ST. ST is for computations which really are pure, but which are more easily handled via imperative references. If you need to use IO, just swap STRefs for IORefs.
12:58:18 <palomer> lispy: but references are part of my underlying data structure!
12:58:20 <sproingie> Cale: wow, you have your very own fanboy kook 
12:58:23 <lispy> Cale: (i'm searching for a reason to want to escape ST) does it limit laziness?
12:58:27 <Heffalump> cale: useful for debugging purposes
12:58:48 <Heffalump> I've written code that runs in ST but does the odd unsafeIOToST for debugging purposes
12:59:07 <lispy> palomer: oh right, i usually keep the references out of the datastructure, but i can see why you would want to do it your way as well
12:59:40 <palomer> references naturally describe lambda terms
12:59:50 <lispy> hmm...my harddrive may have just failed
13:00:02 <lispy> (not on the computer i'm chatting from)
13:02:03 <lispy> palomer: why do references describe them so naturally
13:02:29 <palomer> lispy: because variables are references
13:03:26 <palomer> they're naturally references
13:03:41 <palomer> the text representation is simply a silly way of writing it down on paper
13:07:07 <Heffalump> references are updatable, though
13:09:52 <Cale> well, yeah, for debugging
13:09:58 <Cale> there's also Debug.Trace though
13:10:03 <Cale> which usually suffices
13:10:54 <Cale> (which of course is implemented in terms of unsafePerformIO, but which is reasonably safe for debugging
13:10:55 <Cale> )
13:12:03 <Cale> You actually can introduce odd problems with regard to strictness with Debug.Trace though.
13:12:43 <SamB> palomer: variables aren't references
13:12:59 <SamB> they are things that can be filled in with values somehow
13:13:27 <SamB> but not in the way you seem to think
13:13:55 <Heffalump> cale: if I'm already in a monad, I'd sometimes prefer the evaluation order guarantees I get from unsafeIOToST
13:14:14 <Heffalump> well, 'guarantees'
13:15:14 <lispy> i wish there was a haskell debugger that let me step through my program in terms of lazy evaluation
13:15:54 <lispy> sometimes stepping through the code as it runs can really help your understanding.  I do this in other languages with unfamiliar code
13:16:46 <SamB> there is that thing that does box-and-arrow animations in postscript...
13:17:12 <Cale> I want something like HOPS for Haskell.
13:19:37 <palomer> SamB: variables are a poor man's references
13:19:46 <Cale> SamB: what is that thing called?
13:20:00 <Cale> palomer: references are a poor man's variables
13:20:11 <SamB> wasn't it called HOPS or something?
13:20:16 <Cale> :)
13:20:29 <Cale> SamB: perhaps we're talking about the same thing :)
13:20:37 <palomer> anyways, lambda calculus is most naturally done with references. evaluation becomes a 4 line problem
13:20:47 <palomer> (or even less)
13:21:01 <Cale> HOPS wasn't Haskell though, it was a programming language in and of itself.
13:22:04 <SamB> palomer: but does it pass the tests!
13:23:08 <palomer> what tests?
13:24:41 <SamB> you mean to tell me you are abusing imperative methods without QuickCheck tests to verify that it seems to work?
13:25:00 <palomer> I can't quickcheck this because it's not haskell
13:25:23 <palomer> and there's no quickcheck for sml
13:25:54 <palomer> really, it should work.
13:25:55 <SamB> palomer: so why are you doing this in a crappy language like SML?
13:26:05 <palomer> because I need references?
13:26:20 <SamB> you might as well write all your programs in the IO monad...
13:26:29 <Cale> have you tried ST?
13:26:37 <SamB> @index IORef
13:26:38 <lambdabot> Data.IORef
13:26:39 <palomer> there are references in the datatype
13:26:47 <Cale> @index STRef
13:26:48 <lambdabot> Data.STRef, Data.STRef.Lazy, Data.STRef.Strict
13:26:53 <Cale> that's no trouble
13:27:05 <Cale> you can build datatypes out of STRefs
13:27:19 <palomer> data Term = Var (STRef Term) | App Term Term | Lambda (STRef Term) Term ?
13:27:21 <SamB> Cale: what about the damn s
13:27:38 <Cale> SamB: you just have to parametrise over it, no?
13:28:00 <SamB> I suppose...
13:28:34 <Cale> perhaps  data Term s =  Var (STRef s Term) | App Term Term | Lambda (STRef s Term) Term ?
13:29:04 <ihope> @index QuickCheck
13:29:05 <lambdabot> bzzt
13:29:09 <ihope> >:-D
13:29:18 <ihope> Oh right, right right right.
13:29:24 <ihope> @pl \x -> [x, x]
13:29:25 <lambdabot> ap (:) return
13:29:27 * palomer is getting a head ache
13:29:31 <palomer> I'll come back later to implement it
13:29:48 <ihope> @index ap
13:29:49 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.
13:29:49 <lambdabot> State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont,
13:29:49 <lambdabot> Control.Monad.Error, Control.Monad.List, Data.Graph.Inductive.Query.
13:29:49 <lambdabot> ArtPoint, Data.Graph.Inductive.Query, Data.Graph.Inductive
13:30:07 <ihope> Eek!
13:33:28 <ihope> So which is the ap of type (a -> b -> c) -> (a -> b) -> a -> c?
13:33:45 <Cale> @type Control.Monad.ap
13:33:47 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
13:34:06 <Cale> that, with the Reader monad: (->) a
13:34:49 <Cale> ap :: m (b -> c) -> m b -> m c
13:34:56 <Cale> with m = (->) a, we get
13:35:17 <Cale> ap :: (a -> (b -> c)) -> (a -> b) -> (a -> c)
13:35:23 <ihope> Ah.
13:37:47 <ihope> > let (:-D) a = a+1 in 2 :-D
13:37:48 <lambdabot>  Parse error in pattern
13:38:33 <ihope> > let (|-D) a = a+1 in 2 |-D
13:38:34 <lambdabot>  Parse error in pattern
13:39:16 <ihope> > let (%#$!!) a = a+1 in a %#$!!
13:39:18 <lambdabot>  parse error on input `}'
13:40:05 <ihope> :-/
13:41:04 <Cale> infix operators need two parameters
13:41:08 <Cale> (at least)
13:41:43 <ihope> Aww.
13:42:29 <Cale> I wonder how hard it would be to transform Parsec into a monad transformer.
13:43:10 <SamB> Cale: probably not too hard
13:43:20 <Cale> yeah, it can't be that bad
13:43:32 <SamB> probably mostly a matter of changing type sigs
13:44:05 <Cale> with a nice MonadParser class :)
13:44:23 <Cale> then we could get rid of the stupid user state that it has
13:44:49 <Cale> or is that already frivolous?
13:45:11 <Cale> yeah, you ought to be able to state transform it anyway, I'd think
13:45:21 <astrolabe> If I do a sequence of operations to an array, then as long the resulting array is a pure function of the sequence.  So can I cast back from a mutable array to something outside of the monad?
13:45:53 <Cale> astrolabe: sure, which monad?
13:46:10 <SamB> astrolabe: unsafeFreeze
13:46:12 <Heffalump> astrolabe: yes, ST is good for doing this
13:46:14 <astrolabe> Cale: I'm not sure, the one for mutable arrays?
13:46:27 <Cale> astrolabe: there's ST arrays and IO arrays
13:46:33 <Cale> you probably want ST arrays
13:46:35 <int-e> @index runSTArray
13:46:36 <lambdabot> Data.Array.ST
13:46:44 <SamB> astrolabe: or even runSTArray
13:46:46 <int-e> @type Data.Array.ST.runSTArray
13:46:47 <lambdabot> forall e i.
13:46:47 <lambdabot> (GHC.Arr.Ix i) =>
13:46:47 <lambdabot> (forall s. GHC.ST.ST s (GHC.Arr.STArray s i e))
13:46:47 <lambdabot> -> GHC.Arr.Array i e
13:46:49 <SamB> or runSTUArray
13:46:53 <Cale> runSTArray/runSTUArray do what you want
13:46:55 <SamB> as appropriate
13:47:12 <astrolabe> So many types!  Any tutorials?
13:47:20 <Cale> yes, actually :)
13:47:39 <SamB> Cale: there are?
13:47:42 <Cale> on the new Haskell wiki\
13:47:48 <SamB> and to think I learned all this reading the library!
13:47:57 <Cale> http://haskell.org/haskellwiki/Arrays
13:48:11 <Cale> SamB: this is within the last week
13:48:32 <astrolabe> Wonderful.  Thanks all.
13:50:13 <ihope> I don't think Haskell is a good lanugage. Unlambda is much better.
13:50:21 <ihope> *lanugage
13:50:24 <ihope> ...
13:50:27 <ihope> *language
13:50:52 <int-e> ihope: maybe you should look up 'good' in a dictionary :)
13:50:59 <ihope> Good idea...
13:51:16 <Cale> heh
13:51:25 <ihope> But, you know, Haskell doesn't have such constructs as "fix const".
13:51:59 <astrolabe> what does 'fix const' do?
13:52:13 <int-e> you mean, a fixpoint combinator?
13:52:15 <ihope> It takes an infinite number of arguments.
13:52:21 <int-e> ah.
13:52:24 <int-e> v
13:52:27 <ihope> Yep.
13:53:46 <Heffalump> @type fix const
13:53:48 <lambdabot> Not in scope: `fix'
13:54:13 <Cale> It's of type t where t = b -> t
13:54:23 <Cale> (forall b)
13:54:40 <Heffalump> @type (let fix f = f (fix f) in fix) const
13:54:42 <lambdabot>   Occurs check: cannot construct the infinite type: t = b -> t
13:54:42 <lambdabot>   Expected type: (b -> t) -> b -> t
13:54:48 <Heffalump> boring :-)
13:55:16 <ihope> Control.Monad.Fix.fix
13:55:34 <Heffalump> what's it doing in Control.Monad ?
13:55:45 <ihope> @type Control.Monad.Fix.fix
13:55:46 <lambdabot> forall a. (a -> a) -> a
13:55:50 <ihope> Good question.
13:56:04 <Cale> @type Control.Monad.Fix.mfix
13:56:06 <lambdabot> forall (m :: * -> *) a.
13:56:06 <lambdabot> (Control.Monad.Fix.MonadFix m) =>
13:56:06 <lambdabot> (a -> m a) -> m a
13:56:46 <lispy> @type Control.Monad.liftM2 (&&)
13:56:47 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m Bool -> m Bool
13:56:51 <Keal> how do i search for someone saying 'Keal' in mirc
13:57:22 <ihope> Keal: step one: ditch mIRC...
13:57:34 <ihope> :-P
13:57:35 <Cale> Keal: ask somewhere like #freenode
13:57:38 <Keal> nm if you are going to be flagrant
13:57:53 <Cale> I don't remember much about mirc.
13:57:59 * Keal goes to pick up his brother from work
13:58:08 <ihope> There's an #mirc channel, with... one person on it.
13:58:34 <musasabi> I think many people avoid mirc for security reasons.
13:58:55 <Cale> mIRCscript is scary
13:59:33 <Cale> The parser appears completely ad-hoc.
13:59:43 <Keal> its scary if you dont know how to code secure mIRCscript
13:59:55 <Cale> No, the language itself is scary
14:00:01 <Keal> why?
14:00:20 <wolverian> it's insane.
14:00:21 <Cale> Because it was obviously designed by someone who'd never written an interpreter before
14:00:34 <Cale> and had no instruction on the matter
14:00:45 <Keal> mIRCscript was not invented by Khaled Mardem-Bey
14:01:02 <Keal> he based it around an already existing scripting language
14:01:08 <Cale> Well, whoever did it didn't seem to know what they were doing :)
14:01:31 <musasabi> people just make languages without thinking.
14:01:32 <Cale> at least, back several years ago when I was using it.
14:01:41 <musasabi> and when they don't work they just add more glue.
14:02:12 <musasabi> when people complain about that, they add syntactic sugar to hide the patchworks
14:02:26 <Keal> its prolly scary to you because it seems like it shouldnt work in the first place
14:02:26 <SamB> they mever get rid of the old, no-longer-needed glue?
14:03:53 <Cale> Keal: well, it's just scary because it's so large and poorly designed
14:04:09 <Keal> why is .mrc scary?
14:04:27 <Cale> Normally, when one designs a language, one doesn't make everything syntactically primitive
14:04:50 <Keal> its made syntactically primitive so even old grandmas and code it
14:04:53 <edwinb> when one *designs* a language, yes ;)
14:05:02 <Keal> you have a prollem with that cale?
14:05:17 <Cale> whereas I recall there being functions whose behaviour differed on the presence or absence of commas in the parameter list
14:05:42 <Cale> (or was it parens, or both -- something like that)
14:06:04 <musasabi> Cale: no-one would do something like that, would they? (you are just kidding, I hope)
14:06:10 <Cale> musasabi: no
14:06:13 <Cale> I'm not kidding
14:06:17 <musasabi> :-(
14:06:18 * int-e feels reminded of TeX.
14:06:19 <Keal> parens means its a function
14:06:26 <Keal> that returns a result
14:06:27 <Cale> I could just see the giant switch block
14:06:39 <Keal> no parens doesnt use commas and is a macro
14:06:49 <SamB> int-e: at least TeX has reconfigurable syntax
14:06:55 <Keal> that is what you are talking about
14:07:14 <Cale> They might have fixed some of the irregularities in the language since I used it, but it really was terrible back then
14:07:29 <Keal> works fine for me
14:07:39 <Cale> Oh, it worked, it was just a mess
14:07:40 <Keal> anywasy i must go my baby bro is stuck at work
14:08:00 <Keal> you prolly didnt know how to code
14:08:04 <Cale> I did
14:08:09 <Keal> you just thought you did
14:08:16 <Cale> I was coding in 4 or 5 languages at that point.
14:08:26 <Keal> if you cant make god ith a primative script you aint god
14:08:48 <Cale> um, whatever, you don't make sense anymore :)
14:08:53 <Keal> :P
14:09:07 <astrolabe> trolling
14:10:04 <Cale> I'm willing to discuss things so long as they're at least tangentially relevant and make sense :)
14:10:38 <Cale> (even with someone considered to be a troll)
14:11:21 <astrolabe> Well, I'm not an authority.  It just seemed like it to me.
14:12:59 <SamB> astrolabe: I think what he said is that he'll even feed the trolls whilst they make sense
14:15:08 <Cale> Yeah, so long as someone is willing to be rational, I'm willing to discuss things. So what if they're trolling? I get to benefit from my own thought on the matter regardless.
14:26:22 <gzl> usually people who are trolling aren't being rational
14:26:29 <gzl> if they were being rational it wouldn't really be a troll
14:26:54 <Cale> well, relatively so. I don't care if they can't be convinced, I suppose.
14:54:25 <palomer> guess who's back
14:54:58 <monochrom> me
14:57:18 <lispy> who?
14:57:21 * palomer is still trying to figure out a gmail account name
14:57:39 * [1]garym recommends waffleiron_56
14:57:40 <lispy> i see a lot of people use first.last
14:57:59 <Cale> palomer: is palomer taken?
14:58:08 <palomer> of course
14:58:19 <Cale> pfantasio ?
14:58:36 <palomer> I want something really easy to remember
14:58:43 <Cale> I had no trouble getting cgibbard, though that was quite a while ago :)
14:59:08 <Cale> heh, my friend's email is really.easy at gmail
14:59:23 <palomer> bastard!
14:59:28 <Cale> (It's really easy to remember)
14:59:42 <palomer> real.easy is taken!
14:59:44 <palomer> oh the humanity
14:59:52 <Trevion> super.easy?
14:59:57 <Trevion> incredibly.easy?
15:00:11 <Trevion> A friend of mine had myaddressis
15:00:54 <Cale> I may have registered moc.liamg@gmail.com
15:01:18 <Trevion> that's not bad.
15:01:24 <monochrom> haha
15:01:49 <lispy> or gmail.com@gmail.com
15:02:32 <Trevion> hotmail@gmail.com?
15:03:37 <lispy> i remember i was disappointed that my last name was one character too short
15:03:46 <lispy> and so was lispy
15:04:02 <Trevion> lispy'?
15:04:08 <palomer> hotmail is taken
15:04:16 <Trevion> lispy_?
15:04:35 <palomer> someone give me synonyms to very
15:04:36 <SamB> lithpy
15:04:43 <Trevion> (coworker of mine used to name his helper functions that way.  It was no end of annoying once he had three or four)
15:04:58 <palomer> I still don't know how to name helper functions
15:05:00 <lispy> lispy_______
15:05:02 <lispy> like that?
15:05:04 <SamB> f, g, h!
15:05:09 <palomer> functionWhoDoesTheSameThingButKeepsAnArgument
15:05:22 <Trevion> usually it would go lispy, lispy', lispy_, lispy'', lispy2, lispy__, etc.
15:05:40 <lispy> i tend to use a sequence of '
15:05:51 <lispy> lispy, lispy', lispy'',lispy''
15:05:54 <lispy> er '''
15:05:57 <lispy> you get my point
15:06:13 <Trevion> usually lispy' and lispy_ would do the same thing, but with some subtle undocumented difference that wasn't apparently from their type signatures.
15:06:26 <palomer> incrediblyeasy@gmail.com is taken!
15:06:30 <palomer> I took incredibly.easy
15:06:52 <monochrom> some synonyms to very: quite, rather, a bit.
15:06:54 <lispy> is naught@gmail.com taken?
15:06:56 <palomer> I always call the functions helper, helper2, ...
15:07:08 <Trevion> aux is fewer characters than helper.
15:07:19 <monochrom> f is yet shorter
15:07:26 <Trevion> yes, but where do you go after h?
15:07:42 <monochrom> No I go f, f', f'', f''', ...
15:07:56 <lispy> lemma basically translates to "helper theorem" we need a dedicated work for "helper function"
15:08:10 <palomer> ok
15:08:15 <palomer> I'm now rathereasy@gmail.com
15:08:17 <Trevion> f?
15:08:21 <palomer> do you guys prefer with or without the . ?
15:08:34 <palomer> rather.easy vs rathereasy
15:09:05 <lispy> ra.theeasy would be ironic
15:09:12 <lispy> ra.thereasy*
15:09:46 <lispy> you could use penismighter
15:09:56 <palomer> isn't it penismightier?
15:09:59 <lispy> er mightier
15:10:04 <lispy> yeah, i can't spell
15:10:12 <monochrom> hmm lemma would be a good word for helper functions too.
15:10:29 <Cale> http://www.penisland.net/
15:10:36 <lispy> monochrom: i don't know german so i didn't want to comment
15:10:51 <monochrom> don't worry, I'm just making a wild suggestion.
15:10:56 <Cale> unfortunate choice of domain :)
15:11:04 <lispy> Cale: hahahaha
15:11:06 <monochrom> besides, functions are proofs of theorems too.
15:11:09 <lispy> Cale: omg, that's great
15:11:22 <palomer> lol
15:11:42 <lispy> i wonder how many corporate firewalls block that site
15:12:22 <monochrom> sum xs = lemma 0 xs where {lemma i [] = i; lemma i (x:xs) = lemma (i+x) xs}
15:12:48 <lispy> i'd think sumLemma
15:13:27 <palomer> foldl (+) 0 lst?
15:13:47 <palomer> ok, so everyone knows
15:13:51 <lispy> @pl \lst -> foldl (+) 0
15:13:52 <lambdabot> const (foldl (+) 0)
15:13:54 <palomer> rathereasy ATTTTT gmail.com
15:13:56 <lispy> @pl \lst -> foldl (+) 0 pl
15:13:57 <lambdabot> const (foldl (+) 0 pl)
15:14:01 <lispy> @pl \lst -> foldl (+) 0 lst
15:14:02 <lambdabot> foldl (+) 0
15:14:11 <lispy> bleh, that just muddled my point
15:14:12 <palomer> what does pl stand for?
15:14:20 <lispy> my point was that you don't need the lst at the end :)
15:14:21 <asymptote> I didn't know there was a lambdabot....
15:14:24 <lispy> palomer: point free
15:14:26 <palomer> functions are proofs of silly theorems
15:14:29 <lispy> er point less
15:14:31 <palomer> integers are also proofs of silly theorems
15:14:58 <lispy> palomer: trivial is the word i've often heard used
15:14:59 * palomer has about 8 email accounts now
15:15:11 <palomer> I prefer meaningless
15:16:29 * palomer wishes he could change his background colour in gmail
15:16:52 <lispy> palomer: you could tell the browser to override the website style :)
15:38:28 <ihope> @pl \x -> do a <- x; [a, a]
15:38:29 <lambdabot> (line 1, column 16):
15:38:29 <lambdabot> unexpected ";"
15:38:29 <lambdabot> expecting letter or digit, variable, "(", "`", "!!", ".", operator or end
15:38:29 <lambdabot> of input
15:38:48 <Heffalump> hmm. Who was it that suggested I can make a strict Data.Map just by making element insertion strict?
15:38:50 <ihope> @pl \x -> do {a <- x; [a, a]}
15:38:51 <lambdabot> (line 1, column 10):
15:38:51 <lambdabot> unexpected "{"
15:38:51 <lambdabot> expecting variable, "(", operator or end of input
15:38:54 <lispy> ihope: i don't think @pl does monads
15:39:01 <ihope> Oh.
15:39:08 <ihope> @pl let {} in 3
15:39:09 <lambdabot> (line 1, column 5):
15:39:09 <lambdabot> unexpected "{"
15:39:09 <lambdabot> expecting natural, identifier or "in"
15:39:24 <ihope> I don't think @pl does inline...
15:40:46 <musasabi> :-(
15:40:54 <lispy> \x -> do a <- x; [a,a]; should be equivalent to \x -> x >>= return (\a -> (a,a))
15:41:01 <lispy> er
15:41:08 <lispy> i meant to use a list at the end not a tuple
15:41:19 <lispy> \x -> do a <- x; [a,a]; should be equivalent to \x -> x >>= return (\a -> [a,a])
15:41:30 <lispy> ah, still not right
15:41:40 <ihope> @pl \x -> x >>= (return . (\x -> [x, x]))
15:41:41 <lambdabot> (ap (:) return `fmap`)
15:42:50 <ihope> ...Now why isn't that fmap (ap (:) return)?
15:43:31 <lispy> good question
15:43:51 <lispy> but, either way, i'd say youwant to stick with the first version for clarity sake
15:44:38 <ihope> ...If I want clarity, I'll stick with do notation :-)
15:45:08 <lispy> yeah :)
15:54:47 <jip> palomer: is gmail good for mailing lists?
15:55:19 <ihope> If your lists are in read, you can mail their string representations :-P
15:56:52 <jip> is Happy included with ghc?
16:13:02 <lispy> jip: i don't think so, but i think Parsec is
16:13:09 <jip> ok
16:20:48 <dons> jip, I see your bug report. thanks :)
16:21:02 <jip> dons: alright, is everything clear?
16:21:47 <dons> yep. good report. 
16:21:58 <dons> should be able to fix that today or tomorrow
16:22:04 <jip> were you able to reproduce the bug?
16:22:21 <dons> i haven't tried yet, but the report is detailed enough that I'm confident I will be able to.
16:22:28 <dons> i'll let you know 
16:22:51 <jip> ok sweet, awesome. i guess my work is done(short of providing a fix i suppose :=)
16:22:59 <jip> fix today or tomorrow would be super sweet
16:23:13 <dons> (pretty sure I'm just forgetting to close handles after a merge)
16:23:42 <jip> i tried going through the hs-plugins source to see if i could figure things out but it is over my head :(
16:25:31 <lispy> \@pl \a b -> a `liftM2 (&&)` b
16:25:41 <lispy> @pl \a b -> a `liftM2 (&&)` b
16:25:42 <lambdabot> (line 1, column 11):
16:25:42 <lambdabot> unexpected "`"
16:25:42 <lambdabot> expecting variable, "(", operator or end of input
16:25:56 <lispy> @pl liftM2 (&&)
16:25:57 <lambdabot> liftM2 (&&)
16:26:10 <lispy> heh, my typing is faster than my brain today
16:26:36 <lispy> so am i correct in assuming there is not already a function that does liftM2 (&&) ?
16:27:24 <dons> @type liftM2 (&&)
16:27:25 <lambdabot> Not in scope: `liftM2'
16:28:01 <lispy> @type Control.Monad.liftM2 (&&)
16:28:02 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m Bool -> m Bool
16:28:20 <dons> @hoogle (Monad m) => m Bool -> m Bool -> m Bool
16:28:22 <lambdabot> No matches, try a more general search
16:28:38 <lispy> alright, that answers my question
16:28:39 <lispy> thanks
16:28:57 <dons> @hoogle m Bool -> m Bool -> m Bool
16:28:59 <lambdabot> No matches, try a more general search
16:57:38 <ihope> Is the Ackermann function the one that grows "fastest", or are there ones that grow faster, maybe in some infinite hierarchy?
16:58:06 <ihope> And does the "Graham iteration" function grow in Ackermann time?
17:00:47 <jip> is there a function that converts the Double value -0.0 into 0.0 and otherwise returns the value as is?
17:01:38 <Cale> \x -> if isNegativeZero x then -x else x
17:01:51 <Cale> or just
17:01:57 <Cale> \x -> if isNegativeZero x then 0 else x
17:02:36 <jip> whoah cool
17:02:44 <ihope> @pl \x -> if isNegativeZero x then 0 else x
17:02:45 <lambdabot> flip if' 0 =<< isNegativeZero
17:07:34 <dons> @pl \n -> "Acc(3,"++n++"):"++n
17:07:36 <lambdabot> ("Acc(3," ++) . ap (++) ("):" ++)
17:09:34 <cpatrick> @hoogle if'
17:09:36 <lambdabot> Prelude.undefined :: a
17:09:36 <lambdabot> Data.Graph.Inductive.Monad.emptyM :: GraphM m gr => m (gr a b)
17:09:36 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
17:09:52 <ihope> > putStr "HEllO WORld"
17:09:53 <lambdabot> No IO allowed
17:09:55 <ihope> Rats.
17:09:56 * cpatrick blinks
17:10:33 <Cale> cpatrick: if' i t e = if i then t else e
17:10:56 <cpatrick> Cale: danke :-)
17:11:06 <Cale> It's not in the libraries
17:11:18 <Cale> just a folk-function :)
17:11:50 <cpatrick> aha. what's the significance of the name of @pl ?
17:12:45 <Cale> pointless, a.k.a. point-free
17:13:13 <lispy> Cale: we should tell people it makes it closer to perl ;)
17:13:14 <Cale> The point-free form of a function is one which doesn't mention the 'point' or value which it acts on.
17:13:34 <Cale> er, 'on which it acts'
17:13:56 <ihope> That is the kind of English up with which I will not put...
17:14:15 <Cale> The term was first used by topologists, I believe
17:14:26 <lispy> Cale: that would make sense
17:14:29 <Cale> which explains the mention of points
17:14:56 <Cale> It seems half of everything in Haskell was first used by topologists :)
17:15:11 <cpatrick> learning haskell seems to be a good way of expanding my general maths/CS knowledge
17:15:54 <ihope> Were comments ever used by topologists?
17:16:41 <Cale> heh
17:17:12 <Cale> Most of mathematics is written as prose. I suppose one could say that they use the literate style.
17:17:34 <ihope> What about poetic mathamatics?
17:17:39 <ihope> *mathematics
17:20:30 <Cale> Don't ask. That borders on math jokes, almost all of which are terrible.
17:21:37 <jip> haskell needs python style """ doc strings
17:23:04 <lispy> jip: lisp style doc strings?
17:23:06 <ihope> How can I have 6 * 9 equal 42, but everything else equal what it currently is?
17:23:28 <jip> lispy: does lisp even have comments? :P
17:23:36 <lispy> ihope: change your number base?
17:24:08 <Cale> ihope: redefine * 
17:24:22 <Cale> you'll lose all the nice properties though
17:24:28 <Cale> and the result will fail to be a ring
17:24:32 <sproingie> > let 6 * 9 = 42 in 6 * 9
17:24:34 <lambdabot> 42
17:24:44 <lispy> haha
17:25:03 <Cale> if you want to keep it a ring, you can mod out by the ideal generated by 6 * 9 - 42
17:25:07 <ihope_> jip: (quote (Just dont use this value anywhere))
17:26:01 <lispy> well, hopefulling jip was teasing, because ; is the comment char in lisp
17:26:41 <lispy> jip: haddock can generate documentation if you use a certain structure in your comments, is that what you want?
17:26:47 <ihope_> I did it!
17:27:02 <jip> no, i mean python style """ string literals that can span multiple lines
17:27:04 <ihope_> let mult 6 9 = 42; mult x y = x * y
17:27:13 <ihope_> let x * y = mult x y
17:27:20 <ihope_> I don't know why it works, but it does.
17:27:44 <ski> lexical scoping
17:27:55 <lispy> jip: oh, common lisp has those as well :)  someone on the ML asked about those today.  You can but a \ at the end of the line and at the beginning of the next line
17:27:56 <ski> (i.e not mutually recursive)
17:27:58 <ihope_> Oh, right.
17:28:50 <jip> lispy: yeah but that's annoying and you still have to escape quote characters
17:29:18 <lispy> jip: time to write a preprocessor then :)
17:29:42 <jip> problem with preprocessors is that they munge compilation error messages :'(
17:31:30 <ihope_> Is there any way to explicitly unscope a variable?
17:33:47 <ihope_> > (map head . words) "aesthetically refined technique"
17:33:48 <ski> no
17:33:48 <lambdabot> "art"
17:34:12 <Cale> function abstraction with let?
17:34:30 <Cale> just don't pass the variable in
17:34:43 <ihope> Wait, what now?
17:34:57 <Cale> otoh, you have to explicitly pass all the other variables you want
17:35:14 <ihope> Put them all into a tuple!
17:35:45 <Cale> oh, that's another thing you could do
17:35:48 <Cale> use the Reader monad
17:35:54 <Cale> along with a lookup table
17:36:08 <Cale> and simply locally delete that entry
17:36:36 <Cale> but there's no primitive for excluding a variale
17:36:39 <Cale> variable*
17:36:56 <Cale> hmm, I suppose you can always do
17:37:18 <Cale> (\x -> ... don't bother using x ...) ()
17:37:42 * ski wonders if 'Functor' not being superclass of 'Monad' has anything to do with that 'fmap' can be constructed (and laws proved) with methods in 'Monad' class (and laws)
17:37:53 <Cale> if x was in scope in the enclosing expression, it will be shadowed by the lambda binding
17:38:14 <Cale> ski: that's exactly why we want Functor to be a superclass
17:38:22 <ski> (also 'let x = () in ...')
17:38:23 <ihope> Yeah. Why isn't it a superclass?
17:38:39 <ihope> 'let x = undefined :: Void'?
17:38:48 <Cale> ihope: because there's no convenient way to automatically derive superclasses
17:38:58 <ihope> Oh.
17:38:58 <ski> Cale : yes, but it's not same situation as with e.g. 'MonadPlus'
17:39:16 <Cale> ski: sure
17:39:37 <ihope> @djinn (a -> b) -> m a -> m b
17:39:38 <lambdabot> -- f cannot be realized.
17:39:58 <ihope> ...
17:40:04 <Cale> I think we need a good way to define default instances... I was talking to Lennart about this. I wonder if he's come up with anything new.
17:40:07 <ski> it would be good to have some way of giving instance for 'Functor' generically in 'Monad' class definition, so that every 'Monad' uses that (possibly with support for overriding for more efficient version)
17:40:19 <Cale> right
17:40:19 <ski> Cale : exactly
17:40:38 <ihope> let fmap x y = do {a <- x; return (x y)}
17:40:43 <Cale> if there is no instance in scope, the default instance given in the class is used
17:41:07 <ihope> ...make that a <- y
17:41:07 <ski> how about open-world ?
17:41:11 <ski> hm
17:41:26 <Cale> (as if it was written beside the instance of the subclass)
17:41:48 <Cale> and you can't override it in a future module
17:41:53 <ski> also, what about a sibling class to 'Monad' that also wants to default 'fmap' ?
17:42:08 <ski> (e.g. Applicative/Idiom)
17:42:29 <Cale> well, in that case, we'd want to make the hierarchy linear, but I see your point
17:42:39 <Cale> It would generate an error
17:42:44 <ski> (well, actually, that example class should prolly be between 'Functor' and 'Monad')
17:42:55 <Cale> and the user would simply have to define an instance of Functor themselves
17:43:06 <ski> m
17:43:29 <ski> something for declaring superclasses, after-the-fact, would also be nice
17:43:31 <Cale> Only if there were instances of Monad and Applicative at the same time though
17:43:37 <Cale> (explicit instances)
17:43:43 <ski> (like JohnMeacham's proposal)
17:43:49 <ski> m
17:44:00 <lispy> @pl \_ -> foo
17:44:01 <lambdabot> const foo
17:44:55 <ski> hm, 'STM' would possibly be a 'MonadElse', yes ?
17:44:59 <ihope> If Functor was a superclass of Monad, could we have return, join, fail and map be the only class functions for Monad?
17:45:00 <Cale> yes
17:45:05 <Cale> definitely
17:45:23 <Cale> ihope: I hope to remove fail as well
17:45:32 <ski> concur
17:45:36 <Cale> Having fail in Monad is a crime :)
17:45:37 <ihope> Hmm. fail = error
17:45:52 <Cale> Make people use MonadError or MonadZero
17:46:01 <ihope> If having fail in Monad is a crime, is having error in Haskell a crime as well?
17:46:04 <lispy> wouldn't map be a member of Functor?
17:46:13 <Cale> ihope: not quite as bad
17:46:14 <ihope> ...Yes.
17:46:24 <ski> ihope : 'fail' can be recovered easily in many monads
17:46:29 <Cale> map should be a member of functor
17:46:54 <Cale> The only reason 'fail' is in Monad is because of the do-notation translation
17:47:02 <ihope> Oh?
17:47:12 <Cale> when you have a refutable pattern match which fails, fail is called
17:47:13 <ihope> Well then, take it out and replace it with error!
17:47:28 <Cale> yeah, but
17:47:33 * ski remembers a paper which wanted to define 'ap' in a better (in that case) way than the standard sequential definition .. i wonder if that would be a good use for Idiom/Applicative
17:47:40 <Cale> that's actually not what you want a lot of the time
17:48:04 <Cale> do { Just x <- [Nothing, Just 5, Nothing, Just 6, Just 7, Nothing]; return x }
17:48:06 <Cale> > do { Just x <- [Nothing, Just 5, Nothing, Just 6, Just 7, Nothing]; return x }
17:48:08 <lambdabot> [5,6,7]
17:48:22 <Cale> The pattern match acts like a filter
17:48:23 <lispy> so we're down to return and join?
17:48:29 <Cale> yeah
17:48:34 <ihope> Yay!
17:48:37 <ski> eta and mu :)
17:48:42 <Cale> right
17:48:51 <ihope> > join join return join return
17:48:52 <lambdabot>   Occurs check: cannot construct the infinite type: m = (->) (m (m a))
17:48:52 <lambdabot>   Expected type: m (m a) -> m (m a) -> t -> t1 -> t2
17:48:52 <lambdabot>   Inferred type: m (m a) -> m a
17:48:57 <ihope> What?
17:49:13 <Cale> um...
17:49:19 <ski> @pl join . join . return . join . return
17:49:20 <lambdabot> join
17:49:24 <ihope> !
17:49:28 <ihope> Oh.
17:50:20 <Cale> But really, for a lot of monads, you want to be able to just define return and bind, and get join, map, and all the rest for free.
17:50:32 <ihope> Let's see. In the Reader monad, join has type (a -> a -> a) -> (a -> a), and return has type a -> (a -> a)?
17:50:33 <Cale> So we need an extension to the default methods bit
17:50:42 <Cale> yeah
17:50:56 <ski> ihope : depends on what the env type is ..
17:51:20 <Cale> ihope: (e -> e -> a) -> (e -> a) and a -> (e -> a)
17:51:28 <ihope> Oh, yeah!
17:51:46 <Cale> @djinn (e -> e -> a) -> (e -> a)
17:51:47 <ihope> > join join
17:51:47 <lambdabot> f a b = a b b
17:51:49 <lambdabot>   Occurs check: cannot construct the infinite type: m = (->) (m (m a))
17:51:49 <lambdabot>   Expected type: m (m a) -> m (m a) -> a1
17:51:49 <lambdabot>   Inferred type: m (m a) -> m a
17:51:56 <Cale> @djinn a -> (e -> a)
17:51:57 <lambdabot> f a _ = a
17:52:03 <ihope> It happened that early, eh?
17:52:07 <ski> (that incidentally uses the standard 'of course' comonoid structure over 'e')
17:53:17 <Cale> I'm not that familiar with comonoid objects, seeing as there's nothing like them in plain algebra
17:53:37 <ski> (copy & discard)
17:53:54 <ihope> @pl join return return join return
17:53:55 <lambdabot> join return return join return
17:53:59 <ihope> Oh.
17:55:28 <ihope> So join return return join return has a type, but I get a type error whenever I try to use it?
17:55:46 <ski> @pl join . return . return . join . return
17:55:46 <lambdabot> return
17:55:49 <ski> @type join . return . return . join . return
17:55:50 <lambdabot> Not in scope: `join'
17:55:50 <lambdabot>  
17:55:50 <lambdabot> <interactive>:1:25: Not in scope: `join'
17:56:13 <ski> @type let join = Control.Monad.join in join . return . return . join . return
17:56:14 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m (m a)
17:56:28 <ski> @type let join = Control.Monad.join in join return return join return
17:56:29 <ihope> return join return
17:56:29 <lambdabot>   Occurs check: cannot construct the infinite type:
17:56:29 <lambdabot>   t = ((t -> t2) -> t1 -> t -> t2) -> ((t -> t2) -> t1 -> t -> t2) ->
17:56:29 <lambdabot> a
17:56:39 * ski used '.'
17:57:35 <ihope> e -> (f -> f -> a) -> (f -> a)
17:57:55 <ihope> The whole thing seems to be of type (a -> a). Weird.
17:58:34 <Cale> How is join return return join return well-typed at all?
17:58:56 <ihope> The Reader monad!
17:59:11 <Cale> oh, in that specific monad
17:59:33 <ski> Cale : 'tis not
18:00:15 <ihope> Doink.
18:00:20 <ihope> > return return 3 4
18:00:22 <lambdabot>  add an instance declaration for (Show (m a))
18:00:42 <ski> > return return 3 4 5
18:00:43 <lambdabot> 4
18:00:45 <Cale> ski: with an instance for Monad ((->) e) it gets a type, but there's an ambiguous constraint in it
18:00:51 <ihope> Over here, that seems to have the same effect as (return () :: IO ()).
18:01:26 <ski> @type let join = Control.Monad.join in join return return join return
18:01:28 <lambdabot>   Occurs check: cannot construct the infinite type:
18:01:28 <lambdabot>   t = ((t -> t2) -> t1 -> t -> t2) -> ((t -> t2) -> t1 -> t -> t2) ->
18:01:28 <lambdabot> a
18:01:39 <ski> Cale : see, illtyped
18:02:00 <Cale> however, join return return join (return :: a -> Maybe a) is fine
18:02:27 <Cale> and equivalent to join in the Maybe monad
18:02:43 <Cale> er
18:02:44 <Cale> no
18:02:52 <ski> @type let join = Control.Monad.join in join return return join (return :: a -> Maybe a)
18:02:52 <Cale> it's just equivalent to join, period.
18:02:53 <lambdabot>   Occurs check: cannot construct the infinite type:
18:02:53 <lambdabot>   t = ((t -> t2) -> t1 -> t -> t2) -> ((t -> t2) -> t1 -> t -> t2) ->
18:02:53 <lambdabot> a
18:03:15 <ski> Cale : maybe you're thinking of the version with '.' in between ?
18:03:19 <Cale> ski: need the Control.Monad.Reader instance
18:03:27 <ski> hm
18:03:35 <Cale> > (join return return join (return :: a -> Maybe a)) (Just (Just 5))
18:03:37 <lambdabot> Just 5
18:03:47 <Cale> > (join return return join (return :: a -> Maybe a)) [[1,2,3],[4,5,6]]
18:03:49 <lambdabot> [1,2,3,4,5,6]
18:04:41 <ski> you're right
18:04:52 <ihope> It'd be nice if I could join [1,2,3,4,5,6] to get 1,2,3,4,5,6...
18:05:01 <Cale> > (join return return join 5) [[1,2,4],[6,7,8]]
18:05:02 <lambdabot> [1,2,4,6,7,8]
18:05:05 <ski> ihope : hm ?
18:05:20 <ihope> Lists outside of their monad.
18:05:27 <Cale> ihope: I don't even understand what you mean there.
18:05:32 <ski> ihope : monadic reflection ?
18:05:46 <ihope> I'm not sure, really.
18:06:07 <ihope> Like join is m (m a) -> m a, I'd like m a -> a.
18:06:10 <ihope> ;-)
18:06:35 * ski 's been thinking on a syntax extension that would, sortof, give a kind of monadic reflection to haskell
18:06:37 <Cale> That ruins the monad structure though
18:06:42 <ski> ihope : yes, monadic reflection :)
18:06:47 <ihope> Cale: bingo!
18:07:09 <ihope> Heh. Extract the String from getLine, how about that?
18:07:33 <sproingie> kiss referential transparency goodbye
18:07:46 <Cale> Note that while it seems restrictive that join :: m (m a) -> m a, the fact that it's actually returning a value in your type, and not just some polymorphic thing you have no control over actually means that you have more control over what's going on
18:08:01 <ski> [{ [< putChar [< getChar >] >]  }] :: IO ()
18:08:10 <Cale> monadic reflection is dumb :)
18:08:23 <ski> sproingie : not necessarily globally
18:09:07 <ski> Cale : hm, you mean ?
18:09:46 <sproingie> how would you handle reflection on, say, Nothing?
18:09:47 <Cale> ski: Oh, I'm just against anything which breaks referential transparency, even locally.
18:10:37 * ski was thinking about some ppl been grumbling over over-sequentialization in commutative monads
18:11:23 <Cale> Yeah, otoh, we don't actually have many commutative monads.
18:11:56 <Cale> Mostly just monads which we don't care about the sequence ;)
18:12:46 <Cale> I wonder if there's a nice way to express the proof that a monad is commutative as a function to be implemented as a witness of that commutativity.
18:13:22 <ski> i suspect we need extra laws
18:13:36 <Cale> well, extra laws settle it with no extra primitives
18:14:38 <Cale> It's just the commutativity of (>>), for the most part.
18:14:51 * ski would like to see some examples of Idiom/Applicative that doesn't support Monad
18:15:07 <Cale> there were some in the Idiom paper, iirc
18:15:22 <ski> IdiomLite.pdf ?
18:15:26 <Cale> yeah
18:15:54 <ski> i think (haven't checked fully) that the zipper-thing can actually be made a monad
18:16:12 * ski tries to remember what more there were
18:16:18 <Cale> I'd also like to see some more useful examples of adjunctions.
18:16:33 <ski> possibly some nested idioms ..
18:16:46 <ski> m, would be nice
18:17:26 <Mayco> hihi
18:17:31 <Cale> We'll know that the CS interpretation of category theory is getting mature when we start finding adjunctions all over the place.
18:17:38 <Cale> Mayco: hello
18:17:39 <Mayco> I am newbie...
18:17:57 <Cale> cool -- do you need help with anything?
18:18:01 <ski> do you have any questions yet ?
18:18:03 <Mayco> Ya.....
18:18:22 <Mayco> I am writing my first Haskell programming... :P
18:18:30 <ski> ok, cool
18:18:47 <ski> (have you programmed in any other programming language, before ?)
18:19:20 <Mayco> I took Java and C++ courses before...
18:19:38 <gzl> Cale: what do you mean by adjunction?
18:19:42 <ski> (Cale : the system i'm toying around with was inspired partly by that idiom paper ..)
18:19:45 <Cale> You can expect Haskell to be completely different :)
18:19:59 <Mayco> YA... I know..
18:20:29 <Mayco> I need to write a Haskell function called cipher with two arguments. The first is a character and the second is an offset (an integer). The character should be a lower case character and the offset should be in the range [0..25]. If either argument is not in the legal range, the function should return the character '?'. Otherwise, the function should return the result of applying the cipher to the character with the specific offset. For
18:20:47 <Cale> gzl: in the category theoretic sense
18:20:51 * sproingie .oO( homework )
18:21:03 <gzl> Cale: ah, so adjoint functors. thought you might have been talking about the topological thing.
18:21:15 <Cale> gzl: yeah
18:21:47 <gzl> I think Hyland has written about stuff like this
18:21:54 <sproingie> Mayco: we didn't get all your paste.  do you have any code to start with?
18:21:58 <Cale> I want to see something as deep as Stone-Čech compactification :)
18:22:01 <Mayco> ya.. I wrote something down.. but I have some questions about it...
18:22:02 <sproingie> Mayco: we can help with homework, but only help
18:22:05 <gzl> syntax and semantics being an adjoint pair of functors
18:22:09 <ski> Mayco : you can use "guards" to check whether the character and offset is in range or not .. do you know guards yet ?
18:22:17 <gzl> which I find kind of funky
18:22:27 <Mayco> ya
18:22:40 <sproingie> where is haskell's pastebin anyway?
18:22:53 <Cale> gzl: yeah, that's pretty neat
18:22:58 <Cale> lisppaste2: url
18:23:02 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
18:23:21 <Mayco> First I wanna check the character is lowercase ... and the integer is between 0~25
18:23:54 <gzl> I wonder if stuff like sheaf theory will ever show up in any of this
18:24:12 <gzl> (there's some book called Sheaves in Geometry and Logic)
18:24:37 <Cale> > isLower 'c'
18:24:38 <lambdabot> True
18:24:40 <Cale> > isLower 'C'
18:24:42 <lambdabot> False
18:24:50 <sproingie> Mayco: yah you need to use guards.  a guard looks something like this
18:24:50 <Cale> isLower is in Data.Char
18:24:52 <ski> > isLower '3'
18:24:53 <lambdabot> False
18:25:10 <sproingie> Mayco: fac n | n > 0 = n * fac (n - 1)
18:25:15 <rep> > isLower '/'
18:25:17 <lambdabot> False
18:25:26 <sproingie> Mayco: the stuff between the | and the = is the guard
18:25:27 <Mayco> legalChar :: Char -> Char
18:25:27 <Mayco> legalChar ch
18:25:27 <Mayco>      | 96 < (ord ch)  && (ord ch) < 123                       = ch
18:25:27 <Mayco>      | otherwise = '?'
18:25:27 <Mayco> legalNum :: Int -> Char
18:25:28 <Mayco> legalNum num
18:25:30 <Mayco>      | -1 < num  && num < 26             = num
18:25:32 <Mayco>      | otherwise = '?'    
18:25:32 <sproingie> Mayco: use the pastebin
18:25:38 <rep> > isLower ']'
18:25:39 <lambdabot> False
18:25:41 <rep> hm
18:25:42 <Mayco> I post it on that web you gave me...
18:25:46 <rep> > isLower '}'
18:25:47 <lambdabot> False
18:25:52 <rep> interesting
18:26:22 <ski> Mayco : you can't return 'num' from 'legalNum' .. it's not a character
18:26:43 <ski> > map isUpper "]}"
18:26:44 <lambdabot> [False,False]
18:27:20 <ski> Mayco : are you required to define functions 'legalChar' and 'legalNum', with these types ?
18:27:25 <lisppaste2> Mayco pasted "Haskell beginner" at http://paste.lisp.org/display/15695
18:27:53 <Mayco> My paste is available at http://paste.lisp.org/display/156
18:28:32 <Mayco> ya.. so let 'num' become a character??
18:28:47 <ski> Mayco : otherwise, it seems easier to either return 'Bool' from these two, checking that in the function that calls these (and return '?' there, if outside range) .. or to write this checking in the other function, not bothering to write thses two at all
18:29:38 <Mayco> IC....^^
18:29:49 <ski> (hm, that other function being 'cipher')
18:30:01 <Mayco> I will try to 'bool" 
18:30:32 <ski> you can't return a useful character from 'validNum' if you don't pass it in ..  so easiest to return truth-value results instead (i.e. 'Bool')
18:30:48 <Mayco> IC.....^^
18:31:40 <Mayco> I am going to try it .. thank you sooo much!!!
18:35:25 <lispy> hmm....i can't compile darcs on amd64
18:35:43 <lispy> gcc-3.3: Internal error: Killed (program cc1)
18:35:43 <lispy> Please submit a full bug report.
18:36:01 <lispy> is there a way to make ghc use gcc4 instead?
18:36:47 <Lemmih> -pgmc gcc-4.0, iirc.
18:37:40 <lispy> i'll try installing gcc-3.4 first to see if it will take over for 3.3
19:26:38 <dons> musasabi, ping?
19:28:50 <dons> musasabi, entries for ackermann, takfp, harmonic, and pidigits to submit. they're posted on the wiki. regards the harmonic entries, you could submit both proposals o see which one runs better on their setup. 
19:45:11 <lispy> man, the darcs source has some issues
19:45:51 <lispy> the function (///) is defined in about 3-4 different modules with slight differences.  I don't know if the differences matter or if the different modules even know it's in the others.  I wonder if there could be just one implementation of it.
19:47:22 <lispy> and virtually no one is responding to darcs-devel recently
19:47:27 <lispy> hmm...where to get answers
19:47:52 <lispy> i have half a mind to just change things, run the test suite and if it passes submit the changes
19:54:49 <ForgeAus> hey all :)
19:55:02 <Pseudonym> G'day.
19:55:03 <lispy> hey
19:55:17 <ForgeAus> G'day pseudo, a fellow aussie?
19:55:23 <Pseudonym> Yup.
19:55:32 <Pseudonym> So how's this for a weird coincidence...
19:55:43 <Pseudonym> My wife has just started selling jewellery via eBay.
19:55:52 <Pseudonym> Been going for a month or so.
19:56:05 <Pseudonym> And today she gets an order from one "Sarah Tridgell", of Canberra.
19:56:18 <Pseudonym> Me: "You know who that is, don't you..."
19:56:28 <Pseudonym> She did not.  She'll have to hand in her geek card.
19:56:52 * lispy has no clue either
19:57:04 <Pseudonym> Andrew Tridgell's wife.
19:57:09 <Pseudonym> Tridge.  Samba.  You know.
19:57:17 <ForgeAus> Sarah Tridgell the name doesn't ring any bells... nor does Andrew.... 
19:57:30 <lispy> Pseudonym: huh?
19:57:41 <lispy> Samba like the networking stuff?
19:57:44 <Pseudonym> Right.
19:58:06 <ForgeAus> lol at least it ain't ballroom dancing :)
19:58:08 <Pseudonym> Well, it's the last time I tell you guys a story.  Hmph.
19:58:19 <Pseudonym> Don't even know who Tridge is.
19:58:33 <ForgeAus> Pseudo, nothing wrong with the story, just that I didn't have enough background info for it to mean anything to me
19:58:35 <sproingie> i woulda  recognized andrew, not his wife
19:59:05 <lispy> i would have been cluless
19:59:09 <lispy> clueless even
20:01:31 <Cale> I don't follow samba development closely enough to recognise that name :)
20:06:06 <ForgeAus> dittoo
20:06:38 <ForgeAus> still the coincidence was noteworthy
20:07:12 <Cale> @google "Sarah Tridgell" Canberra
20:07:14 <lambdabot> No result found.
20:07:30 <dons> Tridge is pretty famous. 
20:07:39 <dons> think of the bitkeeper issues last year.
20:07:39 <ForgeAus> I gather that
20:07:43 <Pseudonym> Right.
20:07:47 <Cale> bitkeeper?
20:08:00 <Pseudonym> Doesn't ANYONE here read slashdot?
20:08:07 <Pseudonym> <RandomIrcUser> slashdot?
20:08:07 <ForgeAus> Cale, its like theres a whole other life we're missing out on uh?
20:08:09 <dons> he reverse engineered the protoocol and wrote a free client. roughly(?).
20:08:21 <ForgeAus> I been to slashdot a few times, but I don't read it religiously
20:08:50 <ForgeAus> I thought reverse engineering was illegal these days
20:08:58 <Pseudonym> It depends.
20:08:59 <Korollary> no
20:09:19 <ForgeAus> Koroll, kewl, sounds like I should get into emulation! lol
20:09:19 <Pseudonym> It depends on why you're doing it, what you do with the results, and which jurisdiction you do it in.,
20:09:43 <Korollary> emulation and rev engineering are related but different things btw
20:10:13 <ForgeAus> I agree, its just that rev engineering is one techinique often used in emulation
20:10:15 <Pseudonym> Reverse engineering for the purpose of compatibility, especially if the product isn't being supported, is pretty much sacrosanct in most jurisdictions.
20:10:28 <Cale> I scan slashdot semi-regularly, but I only skim the stories for links, and hardly ever bother to look at the comments.
20:10:37 <ForgeAus> emulation is more about finding equivalent processes to run opcodes from other processors, right?... 
20:10:50 <sproingie> i stopped reading slashdot many months ago
20:10:56 <sproingie> my life feels richer for it
20:10:56 <Korollary> I read slashdot daily. Check out a few comments. It's trash mostly.
20:11:00 * Pseudonym still has it on RSS
20:11:06 <Pseudonym> It makes it much easier to skim.
20:11:07 <ForgeAus> lol sproingie
20:11:20 <ForgeAus> trashdot?
20:11:27 <ForgeAus> or is that slashtrash?
20:11:52 <ForgeAus> I find it wierd that its slashdot, instead of dotslash.. (ie how you run commands in a *nix environment)
20:12:03 <Korollary> apple this, google that, new ruby book is out, 1. 2. 3. profit.
20:12:03 <ForgeAus> erm proggies  in the current directory... 
20:12:45 <Cale> ForgeAus: yeah, it's inherently redundant, like most of the comments
20:12:50 <newsham> mmmm aapl+goog
20:13:00 <Cale> (and stories, for that matter)
20:13:13 <Korollary> and an infinite number of duplicate stories
20:13:13 <ForgeAus> Cale, sometimes a little redundancy is good... 
20:13:38 <Korollary> ask slashdot: I'm a dumbass sysadmin. What should I do?
20:13:38 <Pseudonym> Maybe the reason why it's called slashdot is so it doesn't show up when you type "ls".
20:13:45 <ForgeAus> Koroll, aren't they mostly replies tho?
20:13:57 <Korollary> ForgeAus: no, actual dupe stories
20:14:21 <ForgeAus> koro, sounds a bit stupid
20:14:24 <Cale> I've completely stopped reading kuro5hin.
20:14:48 <Korollary> ForgeAus: It absolutely is and they are notorious for that. "Oops, we announced/cover this two days ago."
20:15:29 <ForgeAus> Cale, personally I'm all for anything that puts some C in IRC
20:15:37 <ForgeAus> if its on topic.. thats a Bonus!
20:15:37 <Cale> Korollary: I don't think the editors read slashdot, and I don't blame them
20:16:07 <Korollary> Cale: lol what does an editor do anyways.
20:16:26 <ForgeAus> Korollary, I would have thought the answer was obvious.... edit!
20:16:34 <Cale> Korollary: take user submissions and put them on the front page, basically
20:17:10 <ForgeAus> isn't the editor the only person who actually goes through and reads all the crap thats submitted? lol
20:17:56 <Korollary> Cale: that's one lazy definition of an editor
20:18:00 <ForgeAus> either that or theres a some anal subscribers.... 
20:18:26 <Cale> Korollary: I think it's pretty accurate for slashdot.
20:19:05 <sproingie> it incenses me that they call it editing or anything like journalism
20:19:41 <ForgeAus> I'm not a journalist so I prolly wouldnt know
20:19:41 <Korollary> sproingie: well, there's all kinds of editing. this one requires the least skill.
20:20:06 <lispy> sproingie: there are other forms of journalism that incense me, like cnn
20:21:00 <ForgeAus> lispy try: <insert any national media news broadcast here> in place of cnn :)
20:21:12 <sproingie> no kidding.  check out the headlines lately
20:21:36 <sproingie> 11 miners alive!  (real story: 11 miners dead).  Bomb thrown into Starbucks!  (real story: Flashlight left at Starbucks)
20:21:42 <ForgeAus> well mostly in Aus its about the bus crash in egypt
20:21:50 <lispy> ForgeAus: ah, i can't speak for other countries.  At our house we tend to believe the BBC before CNN tho
20:21:58 <ForgeAus> I thought it was 10 miners dead?
20:22:41 <ForgeAus> yeah well we got ABC (prolly nothing like ur ABC) here to relay BBC to us basically
20:22:56 <sproingie> ForgeAus: 12 miners.  one survivor.
20:23:25 <ForgeAus> yeah something like that
20:23:31 <Korollary> the product of today's news channels is not news; it's your attention span for the commercials.
20:23:54 <ForgeAus> thats what I thought that there was a survivor so 11 alive where real story is 11 dead, didn't account for the one that survivived...
20:24:23 <sproingie> well yunno, alive, dead, whatever.  gotta get that story out, we got a deadline!
20:25:04 <ForgeAus> I found it particularly alarming how the London unexploded multi-bombs story took over our TV... 
20:25:20 <Korollary> bombs don't explode? That's news to me.
20:25:27 <ForgeAus> which basically boilled down to some innocent guy was killed... nothing else really cept a big scare... 
20:26:15 <ForgeAus> sure a commercial-sized broadcast could have covered that... 
20:26:30 <ForgeAus> instead two stations were commandeered for an entire night... 
20:27:20 <ForgeAus> to keep us all uptodate by repeating over and over the non-event that was going on!... 
20:28:46 <Korollary> every time they connect to a correspondant live, an imperative programmer forgets to increment i in a while loop.
20:29:43 <ForgeAus> :)   assuming you call ur counter variable i :) ... also assuming that loop condition is valid... 
20:30:16 <ForgeAus> to "practically" exit the loop when i reaches a certain value
20:32:09 <ForgeAus> if the loop condition is not based (or dependant) on the variable i, incrementing it during the loop probably wouldn't make much difference
20:33:12 <ForgeAus> but thats not saying anything most programmers don't already know... 
20:35:56 * Keal sets to work
20:37:58 <Keal> where do i download haskell from haskell.org?
20:38:10 <Keal> Cale
20:38:19 <Keal> binary42
20:38:47 <Cale> http://www.haskell.org/ghc/download_ghc_641.html
20:39:16 <Cale> http://cvs.haskell.org/Hugs/pages/downloading.htm
20:40:40 <Keal> haskell.org is slow to download from :(
20:45:08 <Keal> oddly i once met eminem online by coincidence
20:45:14 <Keal> in a chatroom
20:45:57 <Keal> the gerbil/fack song whatever the name of it is, might have been inspired by a story i told him
20:46:06 * Keal shrugs
20:47:02 <Keal> eminem's pretty cool to talk with. kinda down to earth yet odd
20:48:37 <Keal> btw a great deal of egg and sperm storages are no good due to freezing the cells too rapidly
20:50:10 <newsham> still not haskell.
20:50:14 <Keal> how do i add...
20:50:15 <Keal> hey
20:50:26 <Keal> how do i add ghc to PATH
20:50:38 <newsham> whats your shell?
20:50:51 <Keal> what do you mean
20:50:53 <Keal> its xp
20:51:24 <Keal> i am not sure how to modify include paths for executable files
20:51:25 <newsham> right click my computer, select properties, go to advanced, click environment variables, edit the path
20:51:38 <Keal> thanks
20:51:41 <newsham> next time you invoke the cmd shell it will be set according to those settings
20:51:58 <Keal> usually i just mod types if i need to do it
20:52:10 <Keal> never had to mod paths since like the 90's
20:55:42 <Keal> ok done and done
20:59:05 <Keal> what the hell does Prelude > mean?
20:59:19 <newsham> thats the module you're currently "in"
20:59:39 <Keal> wheres the mofo gui?
20:59:39 <newsham> if you ran ghci Foo.hs, you would be in whatever module Foo.hs contains
20:59:50 <newsham> ascii is graphics too
20:59:54 <Cale> the prelude is the default starting module, it contains basic definitions which almost every Haskell program will use
21:00:12 <Keal> better be atleast 16x16 color with extended ascii set
21:00:33 <newsham> nothing says functional programming languagelike monochrome ascii
21:01:23 <Keal> how bout i say ick no unicorn and daisy loving girl mathematician will ever enjoy this
21:01:52 <newsham> *shrug* doesnt affect me.
21:01:57 <newsham> you could try winhugs
21:02:09 <Keal> you think i am one of them persnipity uppity men are pig lesbian mathematicians?
21:02:30 <Keal> no i like things that are cute
21:02:33 <Cale> Keal: If you're on windows, there's WinHugs, but usually I tend not to care whether there's a gui for something whose main task is evaluating expressions
21:02:33 <Pseudonym> Goodness.  Do they exist?
21:02:40 <Keal> not this ungodly interface before me
21:02:44 <newsham> keal: you assume I think about your at all, or that I care.
21:03:11 <Cale> You can still manipulate gui apps that you've written from the GHCi/hugs prompt
21:03:16 <Pseudonym> I thought it's a story that parents tell their kids if they want them to grow up and be sociologists.
21:03:33 <Keal> evaluating expressions is ALL haskell does?????
21:03:43 <newsham> sociologist?  arent you skipping ahead?
21:03:59 <newsham> math -> physics -> engineering -> computer science -> mba -> ... -> sociology
21:04:20 <Pseudonym> Sociology is the anti-maths.
21:04:21 <newsham> keal: no.  it also doesnt evaluate them..  also pretty important.
21:04:52 <Pseudonym> What you asked, Keal, is actually an interesting philosophical question.
21:05:08 <Keal> so the only thing haskell was designed to do..... was evaluate expressions and give error when the expression is incorrectly typed?
21:05:12 <Pseudonym> There's a sense in which all Haskell does is evaluate expressions (though, as newsham says, not all of them).
21:05:18 <newsham> if you went around evaluating everything, nobody would ever accuse you of being lazy
21:05:29 <Keal> and people love that???
21:06:00 <Pseudonym> But it's also a full modern programming language, with everything you'd expect of one (apart from a decent module system).
21:06:14 <Keal> love a black and white lower 128 from 32 up of ascii glyphs?
21:06:15 <Pseudonym> (Haskell's module system is decidedly indecent, but that's another topic.)
21:06:28 <Cale> Pseudonym: you really think it's all that bad?
21:06:38 <Pseudonym> And if you can work out how those two things are both true, you have mastered Haskell.
21:06:41 * Keal wishes he had rather just not stopped working on T
21:06:55 <Pseudonym> Cale: Yes I do.
21:06:59 <Keal> T seems to be haskell, except with a decent  interface at this point
21:06:59 <newsham> http://www.informatik.uni-bremen.de/~cxl/haskell-in-space/ <- un-ascii
21:07:06 <Cale> Pseudonym: what's wrong with it?
21:07:16 * Keal is pissed
21:07:23 <Pseudonym> First off, it doesn't support true separate compilation.
21:07:35 <Pseudonym> In the sense that multiple modules may need to be analysed concurrently.
21:07:56 <Pseudonym> This is true of Haskell, though not true of the closely related language, Haskell + hi-boot files.
21:08:13 <Pseudonym> Secondly, you don't have fine-grained control over what is exported from a module.
21:08:27 <Pseudonym> You must exporting a typeclass instance, for example.
21:08:29 <Pseudonym> export
21:08:35 <newsham> is the problem that ghc uses .o files which dont carry around enough metadata for the seperate compilation you want?
21:08:35 <Pseudonym> You have no choice over that.
21:08:36 <Keal> what is the max amount of operands haskell can handle in a single expression?
21:08:48 <Pseudonym> Keal: How much RAM do you have?
21:09:02 <Keal> why is it a matter of ram?
21:09:14 <newsham> keal: you're not asking a haskell question so much as a ghc or hugs question.
21:09:25 <newsham> haskell is the ideal, ghc and hugs are the concrete instantiations
21:09:33 <Pseudonym> There's probably a theoretical limit based on computing resources.
21:09:39 <Keal> T could perform expressions 600mb and bigger
21:09:56 <Pseudonym> Haskell can work with infinite expression, so that beats T.
21:10:23 <Pseudonym> @eval [1..]
21:10:24 <lambdabot> [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,
21:10:24 <lambdabot> 28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
21:10:24 <lambdabot> 52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,
21:10:24 <lambdabot> 76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,
21:10:24 <lambdabot> 100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,
21:10:26 <lambdabot> [24 @more lines]
21:10:29 <Pseudonym> Note, infinite size.
21:10:34 <Pseudonym> @eval takeWhile (<10) [1..]
21:10:40 <lambdabot> [1,2,3,4,5,6,7,8,9]
21:10:56 <Keal> Pseudonym that is a 1 operand expression
21:11:06 <Keal> the operand is ..
21:11:18 <Pseudonym> I imagine it would take a while to type 600Mb.
21:11:24 <newsham> > take 5 $ drop 1000 $ [1..]
21:11:25 <lambdabot> [1001,1002,1003,1004,1005]
21:11:32 <Keal> not with T
21:11:40 <newsham> > take 5 $ drop 100000 $ [1..]
21:11:41 <lambdabot> [100001,100002,100003,100004,100005]
21:11:45 <Keal> with T you can construct expressions easily
21:11:47 <Pseudonym> Can you give an example?
21:11:48 <Keal> graphically too
21:12:05 <Keal> you could view it as a damn oak tree for all it cared
21:12:56 <Pseudonym> I don't understand the qualitative difference.
21:13:03 <newsham> keal: should you be programming?
21:13:10 <Keal> n-tree in otherwords it ripped from an rpn version
21:13:16 <Pseudonym> Haskell supports combinator-based programming.  You can build up expressions dynamically easily.
21:13:27 <Keal> drag and drop?
21:13:40 <Pseudonym> Well, nobody has written the GUI for it.
21:13:55 <Pseudonym> What's the benefit of drag and drop in this case?
21:14:06 <Keal> can you make a macro that builds the expression accoridng to a genetic algorithm where you decide what is good and what is bad?
21:14:11 <Pseudonym> Sure.
21:14:20 <Pseudonym> It's not called a macro, but yes.
21:14:48 <Pseudonym> It's not called a macro because I don't see the benefit of doing that at compile-time.
21:15:02 <Pseudonym> But with Haskell, it's dead easy to build up expressions in that way.
21:15:09 <Keal> graphically with glyphs of simplified graphics at each node in the n-tree of operands as ripped from the rpn imprint?
21:15:28 <Keal> graphics of th graphing?
21:15:32 <Pseudonym> This sounds like a special-purpose programming system to me.
21:15:53 <Pseudonym> If so, that's not Haskell's goal.
21:16:05 <Keal> no it sounds like something somone would expect that trees 500gb hdds of expressions as if they were floppy dicks
21:16:07 <cpatrick> Keal: if you want something identical to your T system, why don't you use that?
21:16:10 <Keal> disks
21:16:27 <Keal> because i am sick of T
21:16:36 <Pseudonym> Oooh, Freudian slip.
21:16:40 <Keal> i had hoped out of x billion people on the net...
21:16:48 <Pseudonym> So... you're sick of T, but you want something exactly like it.
21:17:00 <Pseudonym> Why don't you write your own, then?
21:17:14 <Keal> someone would have been able to create a product more superior than something i invented when i was 12 back when i had no clue what i was doing
21:17:15 <newsham> that would involve coding and not ircing
21:17:30 <Keal> >:(
21:17:52 <Keal> it only took me 90 days to create T
21:18:04 <dons> Pseudonym, this guy was busy trolling yesterday. he's maliciously disruptive.
21:18:18 <Keal> and yes that was with zero formal training in all  realms
21:18:24 <Keal> :(
21:18:38 <Keal> perhaps i just genius and never tested
21:18:45 <Keal> :(
21:18:58 * Keal feels sad
21:19:04 <Pseudonym> Poor Keal.
21:19:18 <newsham> the genius always stands alone
21:19:18 <Pseudonym> Tell you what, you put T up on sourceforge and we'll all have a go and help you improve it.
21:19:23 <newsham> crying in the rain
21:19:27 <Keal> ok.
21:19:59 <Keal> only one prollem. T broke confines of the visual basic langage and would not compile as a self standing class file
21:20:20 <newsham> when I was 12 I poked and peeked
21:20:21 <Pseudonym> Oh, if it's in visual basic...
21:20:22 <Keal> reason is vb6 classes do not allow reverse inheritance
21:20:30 <Pseudonym> When I was 12 I poked, peeked and sys'd.
21:20:32 <Keal> it all i afford at time i poor!
21:20:41 <newsham> sys 64738
21:20:45 <Pseudonym> Indeed!
21:20:53 <Keal> originally t written in basica
21:20:59 <Keal> and t work back then
21:21:04 <Cale> You could afford visual basic, but not a free compiler for one of many other languages?
21:21:17 <Keal> tried making t for 4016 but ram crashed
21:21:36 <Keal> could only hold 6 variables do to only 16k available
21:21:58 <Keal> t took all damn full out of 16k
21:22:08 <Keal> left only room for 6 vars in db :(
21:22:10 <Pseudonym> I can imagine it would be hard to manipulate 600Mb of expression on a machine with 16k of memory.
21:22:24 <Keal> that was 70's pos commodore
21:22:36 <Keal> 8088 it work fine
21:23:29 <Keal> although 8088 only had 64k and 20mb vram
21:23:50 <Keal> rest of 640k i could not access due to basica sucking
21:24:19 <newsham> > map toEnum [99,97,110,32,119,101,32,115,116,111,112,32,116,104,105,115,63] :: [Char]
21:24:21 <lambdabot> "can we stop this?"
21:24:45 <Keal> i ask.
21:25:33 <Keal> can haskell run on 8088?
21:25:41 <Pseudonym> No, but Gofer could.
21:25:46 <Pseudonym> You can still get Gofer.
21:26:34 <Pseudonym> Well, 8086, anyway.
21:26:42 <Keal> reason i make t is for free opensource calculator with much power that run on anything
21:27:10 <binary42> VB does not run on anything.. ;-)
21:27:13 <Keal> perhaps haskell not what i expected
21:27:25 <Keal> vb was for experimentation in order to dev
21:27:31 <binary42> In fact I don't have a single machine that would run VB right now.
21:27:31 <Keal> not intended as final
21:28:29 <Keal> T is turing machine
21:28:42 <binary42> Keal: Let me give you some advice. Learn as many languages as you can, but for each one try to take in more than facts. Learn the culture and their point of view. Then decide what you like.
21:28:53 * Pseudonym nods
21:29:19 <Keal> i return soon must take something and drink glass of milk
21:29:24 <Pseudonym> Every programming language comes with a syntax, a semantics, a set of libraries, a culture, and an implicit theory on utility.
21:29:39 <Pseudonym> You need to have a passing familiarity with all of them.
21:29:56 <monochrom> haha newsham you're clever
21:30:07 <newsham> http://lava.net/~newsham/x/machine/rpn.tgz   portable calculator.
21:30:13 <newsham> is that what you're looking for?
21:30:55 <newsham> (I didnt write it, but I use it regularly)
21:35:08 <araujo> Hello Haskell'ers!
21:35:13 <newsham> hi
21:37:32 <araujo> @yaw!
21:37:33 <lambdabot> HELLO, everybody, I'm a HUMAN!!
21:39:12 <sieni> has anybody ever planned to make "strict haskell" as a replacement for sml and ocaml?P
21:39:15 <sieni> -P
21:40:30 <dons> why would you want to?
21:41:17 <monochrom> I think the module system of sml and the subtyping system of ocaml are irreplaceable.
21:43:07 * Keal feels sick :(
21:43:08 <sieni> there are some annoyances in ML that are not going to get fixed soon, like value restriction
21:43:09 <Pseudonym> We should bring them into Haskell, and then we'd be set.
21:43:59 <ForgeAus> pseudo, u still there?
21:44:06 * Keal dissapointed
21:44:19 <Pseudonym> Yes.
21:44:22 <ForgeAus> what did you mean programing languages come with cultures? (among the list of other things)
21:44:57 <Pseudonym> Like natural languages, any language has a culture of people who use it.
21:45:07 <Pseudonym> Klingon culture is very different from Esperanto culture.,
21:45:09 * Keal was so happy with T, coded in basic so run on anything, and does lot,
21:45:10 <Pseudonym> For example.
21:45:16 <monochrom> The culture of the community around the language in question.
21:45:23 <Pseudonym> Well, Perl has a culture.  And C++ has a culture.
21:45:26 <ForgeAus> is that like cobol (used to) lends itself to business usage
21:45:28 <Pseudonym> And Haskell does too.
21:45:33 <Pseudonym> Not quite.
21:45:43 <Pseudonym> That's the implicit theory of utility, you're thinking of there.
21:45:55 <Pseudonym> Every language has an implicit theory of what it's "for".
21:46:05 <Pseudonym> Perl is glue, for example.
21:46:07 <Keal> what was basic for
21:46:12 <ForgeAus> :)
21:46:14 <Pseudonym> For teaching, originally.
21:46:29 <Pseudonym> C is for system programming.
21:46:31 <ForgeAus> Pascal is kinda a teaching language (I like Pascal alot)
21:46:35 <Pseudonym> Right.
21:46:38 <Pseudonym> You get the idea.
21:46:39 <monochrom> cobol had as much culture as screwdrivers.
21:46:43 <Pseudonym> Haskell is for structure hacking.
21:46:49 <lispy> Pseudonym: perl sysadmining ang munging text, i do'nt really think of glue
21:46:49 <Keal> what was basic supposed to teach
21:46:52 <Pseudonym> Fortran is for numerics.
21:47:06 <Pseudonym> I think of glue.  Perl is for stringing CPAN modules together.
21:47:09 <ForgeAus> whats python for then?
21:47:16 <lispy> ForgeAus: constricting
21:47:17 <Pseudonym> Python is for scripting.
21:47:21 <ForgeAus> lol lispy
21:47:26 <Pseudonym> :-)
21:47:41 <lispy> man, quickcheck is useful, it's finding bugs in darcs
21:47:41 <Pseudonym> Anyway, you get the idea.
21:47:44 <ForgeAus> I already knew python was a scripting language, but then 
21:47:45 <Keal> what was basic supposed to teach
21:47:50 <newsham> hmm.. python is for scripting?  I'll have to rm my programs :(
21:47:51 <ForgeAus> so is c or any other language really...
21:47:52 <Pseudonym> Culture is what the people are like.
21:48:14 <Pseudonym> newsham: That's the thing about the implicit theory of utility: It's often wrong.
21:48:16 <ForgeAus> in fact scripting is analogous to programming itself!
21:48:31 <Keal> what was basic supposed to teach
21:48:33 <ForgeAus> so saying python is for scripting doesn't really tell me much
21:48:40 <ForgeAus> Keal simple programming
21:48:42 <newsham> speaking of scripting, anyone play with Monad (the shell from MS) yet?
21:48:43 <Pseudonym> Haskell programmers tend to be very literate in pure maths.
21:48:52 <Pseudonym> As an example.
21:48:54 <ForgeAus> used keywords that were easily understandable
21:49:08 * Keal sad
21:49:14 <ForgeAus> MS shell monad? 
21:49:19 <ForgeAus> first I heard of it
21:49:23 <lispy> newsham: i think they canned monad when they canned longhorn in favor of vista
21:49:25 <Pseudonym> Basic was adopted by microcomputer manufacturers because it was very easy to write an interpreter in a small amount of ROM.
21:49:31 <ForgeAus> (is that like darwin? is to macs? )
21:49:40 * Keal would kill self but knows not supposed to
21:49:54 <ForgeAus> Keal, cheer up then
21:49:57 <newsham> lispy: no.  monad sh ships with the latest public beta.
21:49:59 <newsham> of vista
21:50:07 <newsham> and you can download it independantly i believe
21:50:12 <Pseudonym> Keal, if you're serious, you should go see your doctor and tell them this.
21:50:27 <Keal> doctor just give meds not fix prollem
21:50:31 <Pseudonym> Don't muck around with brain chemistry.
21:51:15 <Pseudonym> Anyway.  Programming language culture.
21:51:37 <Pseudonym> Haskell programmers tend to be mathematicians in disguise.
21:51:39 <dons> isn't haskell's implicit utility writing typecheckers ;)
21:51:46 <Pseudonym> Something like that. :-)
21:51:52 <ForgeAus> lol
21:51:55 <dons> typecheckers for haskell-like languages.
21:51:59 <Pseudonym> There are a lot of languages out there that are optimised for writing their own compilers.
21:52:18 <dons> and ML is about writing Isabelle and other theorem provers.
21:52:21 <ForgeAus> most compilers can be translated from one language to another anyhow
21:52:36 <newsham> lispy: msh was yanked before an earlier beta, but i guess they put it back.
21:52:38 <ForgeAus> thats the beauty of pseudocode :) .. well can be 
21:52:42 <newsham> btw, "longhorn" isnt canned.
21:52:51 <Keal> reason i do math is math change world. reason i get gf is becaus  she need someone to love and i love her for that. reason i have cat is kitten need dad and i need child to care for to feel loved.
21:53:01 <ForgeAus> I thought vista is what longhorn was?
21:53:20 <newsham> longhorn is a code word and hence morphs and confusion.
21:53:29 <ForgeAus> Keal sounds simple enough in theory
21:53:36 <ForgeAus> but those things are quite emotional in practice
21:53:40 <Keal> but there is prollem in changing world
21:53:41 <newsham> vista is basically the client version of longhorn 
21:53:43 <Keal> word is...
21:53:46 <Pseudonym> Actually, someone made a list of programming languages once, and their motivations for being.
21:53:51 * Keal looks in dictionary
21:54:08 <Keal> parsimony
21:54:09 <Pseudonym> Haskell's motivation: Miranda is proprietary.
21:54:10 <monochrom> I bet 99% of them read "for the PhD thesis of ____ "
21:54:19 <ForgeAus> Keal I dunno what the word means
21:54:24 <Keal> parsimony prevents fixing old prollems in math
21:54:30 <Pseudonym> Perl's motivation: AWK isn't good enough.
21:54:39 <Pseudonym> C's motivation: We need SOMETHING to write Unix in.
21:54:41 <Keal> world not accept what provides ideal
21:54:53 <ForgeAus> lol
21:55:00 <newsham> s/write/rewrite/
21:55:17 <lispy> newsham: heh, yeah i often thin about that
21:55:25 <ForgeAus> Keal is that another way of saying the world model is dynamic, but people want to stick with their static methods?
21:55:27 <Pseudonym> Scheme's motivation: Lisp is too damn big.
21:55:30 <newsham> more realistically "hey, I dont like pascal much, but i had fun writing a compiler for it, I wanna try write another one, lets use it to rewrite the kernel"
21:55:32 <dons> I often think Haskell is around so that PL academics have a common language to hack on, and jobs.
21:55:46 <lispy> if we took the constraints of C but the knowledge we have know abotu building languages, could be make a better language for designing unix?
21:55:47 <cpatrick> newsham: doesn't C predate pascal?
21:55:51 <Pseudonym> Pascal's motivation: The Algol committee stopped listening to Wirth.
21:55:56 <Keal> b*(Floor[v/b^p]/b-Floor[Floor[v/b^p]/b]) for example
21:56:00 <lispy> dons: i had a professor tell me that was the reason for haskell
21:56:01 <ForgeAus> cpatrick probably
21:56:03 <Keal> it change whole view
21:56:08 <lispy> dons: a languages professor :)
21:56:11 <ForgeAus> seeing as pascal is essentially an "easy C" in a sense
21:56:14 <newsham> cpat: .err.. sorry. you're right.. i think i mean bcpl
21:56:27 <Keal> it my proof of glyph based counting systems
21:56:35 <Pseudonym> Pascal is an easy Algol.
21:56:36 <monochrom> dons: yes that's true, but if Miranda were freer, Miranda would be the choice.
21:56:55 <ForgeAus> I dunno much about Algol
21:56:58 <Keal> it shows proof that base can be non integer
21:57:00 <ForgeAus> I heard of it thats about all
21:57:01 <dons> yep. would have been the choice. that's all 15 years ago now.
21:57:05 <Keal> it prove base can be irrational
21:57:23 <Keal> it also make mathematica break
21:57:31 <Keal> because mathematica is not correct
21:57:43 <newsham> http://channel9.msdn.com/wiki/default.aspx/Channel9.MSHWiki btw
21:57:48 <Keal> showing that math as it is today is fallable
21:58:22 <Keal> but my proof show math has ideal that can be accustome into system
21:58:40 <lispy> newsham: okay, so the thing i heard about them canning it is not true
21:58:50 <Keal> my proof show math is broken right now
21:58:54 <newsham> lispy: it was partly true.
21:58:58 * araujo wonders what Keal talks about
21:59:01 <newsham> it was removed from earlier beta.
21:59:15 <Keal> my proof show some original primary assumptions are incorrect
21:59:24 <araujo> Oh, btw, Haskell is the best because it is the funnier!!!! 
21:59:27 <Keal> that they are not self-evident
21:59:34 <dons> :)
21:59:35 <Keal> that they are not obvious
21:59:41 * araujo throws lambdas at everyone
21:59:53 <Keal> that only way to come to assumption is to prove it
22:00:01 <araujo> Hello dons :-)
22:00:04 <Keal> and i have proved original assumption about roots wrong
22:00:05 * lispy grabs a bottle opener and sits down with a nice cold lambda
22:00:10 <dons> @y0w
22:00:11 <lambdabot> Remember, in 2039, MOUSSE & PASTA will be available ONLY by
22:00:11 <lambdabot> prescription!!
22:00:17 <araujo> hah
22:00:27 <Keal> thus all of mathematics needs to be tested that it is indeed corrrect again
22:00:40 <Keal> proofs are no longer sound
22:00:45 <lispy> dons: hehe, you know who yow reminds me of....
22:00:47 <ForgeAus> eek monad is Cscript for windows?
22:01:02 <Keal> and that is what i do as mathematician
22:01:05 <dons> lispy?
22:01:06 <Keal> i break math
22:01:21 <Keal> in order to prove elemental primary assumptions
22:01:42 <lispy> hey look, it's the new perl!
22:01:43 <lispy> filter Trim-SparseText{$_ = $_.Trim();if($_){$_;} }
22:01:45 <Pseudonym> Which assumptions are wrong?
22:01:50 <Keal> or disprove with a correct answer
22:02:03 <Keal> for example...
22:02:05 <newsham> lispy :)
22:02:11 <Keal> b*(Floor[v/b^p]/b-Floor[Floor[v/b^p]/b])
22:02:15 <araujo> lispy, i almost got blinded 
22:02:18 <Keal> give that to mathematica
22:02:27 <Keal> but replace b with Sqrt[2]
22:02:29 <newsham> lispy: still beats cmd.exe's gotos.
22:02:36 <Keal> and replace v with Pi
22:02:45 <Keal> replace b with an integer
22:02:50 <Keal> mathematica will foul
22:02:54 <lispy> replay vi with yi
22:02:59 <Keal> and simplify incorrect
22:03:06 <Pseudonym> Sounds like a bug in Mathematica.
22:03:19 <Pseudonym> Did you submit a support request?
22:03:20 <Keal> actually it bug in math
22:03:23 <Keal> not mathematica
22:03:33 <newsham> pseudo: stop encouraging it.
22:03:42 <lispy> math needs a service pack
22:04:06 <Keal> primary elemental assumption of integer coefficients to roots in counting sytem is wrong
22:04:19 <Keal> truth is..
22:04:31 <Keal> coeffient is to precision of base
22:04:46 <Keal> and when base is less than 1...
22:04:47 <dons> I want a @megamonad^h^h^h^h@keal plugin for lambdabot please.
22:04:49 <lispy> we're getting ready for web2.0, why not math2.0 at the same release party?
22:04:52 <binary42> math is a legacy app these days. I suggest you migrate that to something more modern like astrology.
22:05:01 <lispy> dons: hehe
22:05:02 <Keal> endian mirrors the decimal
22:05:26 <Pseudonym> We work with more cutting-edge pseudoscience here.
22:05:27 <newsham> the releases put out by euler were of high qality
22:05:34 <newsham> but it all went to hell after that
22:05:41 <newsham> sorta like unix
22:05:46 <lispy> yeah, they should have given him a raise
22:05:48 <newsham> post labs
22:05:58 <Pseudonym> I kinda liked the early Pythagorean patches.
22:06:03 <Pseudonym> They were pretty quirky.
22:06:21 <Pseudonym> Hang on, the Gauss releases weren't too bad.
22:06:49 <Keal> Pseudonym who is pseudoscience?
22:07:03 <lispy> Pseudonym: the feature updates from ramanujaun were pretty crazy tho
22:07:03 <Pseudonym> My cousin.
22:07:14 <Keal> Pseudonym who use pseudoscience?
22:07:19 <newsham> its too bad they accidentaly erased archimedes calculus
22:07:36 <lispy> newsham: wasn't that because they didn't use darcs?
22:07:36 <Pseudonym> Keal: Someone mentioned astrology, that's all.
22:07:41 * Pseudonym hates explaining jokes
22:08:08 <Pseudonym> lispy: Yeah, I'm kinda glad they did the Goedel rewrite.
22:08:09 <newsham> bitrot
22:08:23 <ForgeAus> btw lispy theres an nvi
22:08:33 <ForgeAus> but I still can't get used to vi, I prefer pico!
22:08:40 <lispy> nvi?
22:08:44 <newsham> I say we feed keal to himself and look down the diagonal
22:08:50 <lispy> ForgeAus: yi!
22:08:50 <ForgeAus> new vi I assume it stands for
22:08:55 <monochrom> haha
22:09:02 <ForgeAus> yi I haven't heard of
22:09:03 <Pseudonym> If you're using vi, do yourself a favour and use vim.
22:09:04 <monochrom> newsham is clever today
22:09:04 <lispy> newsham: hehe
22:09:04 <Keal> coeffient precision is same as base precision, when base<1 endian of powers mirrors
22:09:09 <Pseudonym> But yi is very cool.
22:09:12 <lispy> ForgeAus: it's written in haskell, by dons
22:09:16 <lispy> @whereis yi
22:09:17 <lambdabot> Maybe you meant: where where+
22:09:20 <ForgeAus> I see.. sounds kewl
22:09:20 <lispy> @where yi
22:09:21 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
22:09:33 <ForgeAus> I'm not much a *nix head anyhow
22:09:50 <lispy> i'm more of a unix ass my self ;)
22:10:10 <Keal> Coeffient precision is *equal to Base precision. when Base<1,endian spanning Power is mirrored
22:10:24 <Keal> i not good at speaking
22:10:25 <Pseudonym> I'm a Unix duodenum.  Don't ask.
22:10:33 <Keal> b*(Floor[v/b^p]/b-Floor[Floor[v/b^p]/b])
22:10:35 <Keal> see?
22:11:00 <lispy> b xor p?
22:11:01 <Keal> that isolates digit of original Value
22:11:19 <Keal> b raised p
22:11:33 <lispy> does this equation work in a different timeline?
22:11:35 <ForgeAus> carets are useually raising powers...
22:11:41 <lispy> have we just diverged too far?
22:12:00 <ForgeAus> divergence often leads to interesting places
22:12:17 <ForgeAus> at least this was a mathematical one (ie, semi-on topic)
22:12:25 <Keal> b*(Floor[v/b^p]/b-Floor[Floor[v/b^p]/b]) this expression isolates the value of a single digit
22:12:35 <lispy> does reality use cvs to merge the branched timelines?  that could lead to the unhappenings you mentoined
22:12:50 <ForgeAus> lipsy do timelines really branch?
22:12:57 <lispy> ForgeAus: ask Keal 
22:13:10 <ForgeAus> I don't think "sideways in time" parallel universes have yet been proven, just theorized
22:13:11 <Keal> :|
22:13:30 <Keal> i know it true i have witnessed it
22:13:38 <ForgeAus> and if they do hwo to get there isn't a matter of where they are, but WHEN (ie can't travel by *distance* to get there gotta travel by time)
22:13:42 <Pseudonym> So seriously for a moment, if b < 1, what does that equation mean?
22:13:52 <Pseudonym> Do bases of less than 1 make sense
22:13:53 <Pseudonym> ?
22:13:59 <Pseudonym> Base 1 doesn't make sense, as I understand it.
22:14:09 <ForgeAus> since we can't yet travel in time beyond our average one second per second, then its kinda a non-issue
22:14:14 <Keal> i already told you Pseudonym
22:14:23 <Pseudonym> You said it breaks down.
22:14:32 <Pseudonym> But that might just mean that it doesn't make sense.
22:14:40 <Keal> is 0<b<1 then digits go instead of 123.456 they change to 654.321
22:14:48 <Pseudonym> Ah, cool.
22:14:52 <Pseudonym> That's trippy.  I like it.
22:15:22 <Keal> i foul....
22:15:30 <Keal> is 0<b<1 then digits go instead of 123.456 they change to 6543.21
22:15:38 <Pseudonym> Right.
22:15:54 <Pseudonym> I wonder if that equation works with negative bases, or if you have to flip the Floors to Ceils or something.
22:16:12 <Keal> i have not tested negative bases yet. as it cause prollems
22:16:16 <ForgeAus> or just reverse the sign somewhere along the equation
22:16:23 <Pseudonym> Maybe.
22:16:30 <Pseudonym> Negabinary notation is kinda cool.
22:16:48 <ForgeAus> maybe it becomes floor [v/-b^p] or something somewhere
22:16:56 <ForgeAus> negabinary?
22:17:02 <Pseudonym> Base -2
22:17:03 <ForgeAus> 1 and 0 instead of 0 and 1
22:17:10 <ForgeAus> or 0 and -1?
22:17:11 <Keal> all i know i knew that expression before i was infant
22:17:17 <Pseudonym> 0 = 0
22:17:20 <Pseudonym> 1 = 1
22:17:20 <Keal> maybe in womb
22:17:22 <Pseudonym> 10 = -2
22:17:24 <Keal> maybe earlier
22:17:25 <Pseudonym> 11 = -1
22:17:33 <Pseudonym> 100 = 4
22:17:35 <Pseudonym> 101 = 5
22:17:37 <Pseudonym> 110 = 2
22:17:43 <Pseudonym> etc
22:17:47 <lispy> with a negative base you'll get weird numbers because the base will telescope
22:17:55 <ForgeAus> etc?
22:17:57 <Pseudonym> The place values are, from right to left: 1, -2, 4, -8 etc
22:17:58 <ForgeAus> I don't understand
22:18:05 <lispy> right
22:18:07 <Pseudonym> Multiplying by -2 every time.
22:18:24 <lispy> Pseudonym: do integers have unique representations in this base?
22:18:28 <Pseudonym> Yes.
22:18:34 <Pseudonym> Both positive and negative.
22:19:24 <lispy> Pseudonym: oh, i bet if it weren't binary you'd be able to have multiple representations
22:19:25 <Keal> try use complex base
22:19:39 <ForgeAus> is there an infinite number of values between the real numbers 1.0 and 2.0?
22:19:50 <araujo> yes
22:19:59 <Keal> b*(Floor[v/b^p]/b-Floor[Floor[v/b^p]/b]) i call this Keal Digit
22:20:00 <ForgeAus> ahh 1 + 1j?
22:20:02 <monochrom> No.
22:20:37 <Keal> also other trick i not tell you yet
22:20:42 <Keal> you will be surprise
22:20:50 <ForgeAus> where j represents a number squared that = -1?
22:21:41 <Keal> series p as ints
22:21:45 <joelk> ForgeAus, just one example: 1+1/n for all natural numbers n: 2, 1.5, 1.25, 1.125,....
22:21:50 <ForgeAus> imho relations are interesting... sqrt's have multiple outputs... 
22:22:10 <Pseudonym> No, sqrt has one output.
22:22:16 <lispy> yeah, the positive one
22:22:20 <Keal> and same series p+q where q is 0=>q>1 from inf..-inf you get same
22:22:21 <Pseudonym> Right.
22:22:22 <Keal> wait
22:22:24 <Keal> listen
22:22:27 <Keal> watch
22:22:30 <ForgeAus> Pseudonym, if you use a computer prehaps.. but in math, no
22:22:54 <ForgeAus> ever done a polynomial, the -(neg) result of a sqrt is important
22:22:56 <cpatrick> ForgeAus: conventionally the sqrt symbol refers to the positive square root
22:23:01 <Pseudonym> Nope.  sqrt has one output, and is only defined on non-negative reals.
22:23:05 <lispy> ForgeAus: sqrt is defined to be the positive root only. Look at the binomial theorem for example
22:23:09 <Pseudonym> There'a good reason for that.
22:23:12 <Keal> b*(Floor[v/b^(p+q)]/b-Floor[Floor[v/b^(p+q)]/b])
22:23:17 <Keal> watch
22:23:19 <Keal> i teach you
22:23:21 <Pseudonym> sqrt (a*b) == sqrt a * sqrt b is too useful an identity to give up.
22:23:27 <Keal> i added q
22:23:29 <lispy> er not binomial
22:23:30 <Keal> i tell you now
22:23:34 <lispy> ForgeAus: i meant quadradic :)
22:23:39 <Keal> q is 0=>q>1
22:23:42 <Pseudonym> The alternative:
22:23:51 <Keal> p is whole
22:23:51 <ForgeAus> lispy try drawing a circle graph without relations?
22:24:04 <Pseudonym> 1 = sqrt (1) = sqrt (-1 * -1) = sqrt (-1) * sqrt(-1) = -1
22:24:10 <Pseudonym> And we don't want that.,
22:24:13 <Keal> now take p=-inf..
22:24:19 <joelk> ForgeAus is right, in the sense of multi-valued complex functions. But that isn't the same thing of "functions as a subset of all relations"
22:24:22 <ForgeAus> pseudo, 1 = -1? wow
22:24:44 * cpatrick grins at Pseudonym 
22:24:48 <Keal> have q=0..<1
22:24:54 <Pseudonym> ForgeAus: Only if you allow sqrt to be defined on numbers other than nonnegative reals.
22:25:19 <ForgeAus> Pseudo, agreed, for the most part
22:25:26 <Keal> have it so all p=inf..-inf use same q
22:25:31 <ForgeAus> but most people tend to forget that -2 * -2 also = 4
22:25:37 <newsham> i = sqrt(-1); j = -i
22:25:49 <Pseudonym> Sure, so you say: Let x be a number such that x^2 = 4
22:25:56 <Pseudonym> Rather than: Let x = sqrt 4
22:26:12 <cpatrick> newsham: !?
22:26:15 <Keal> sum the result (d) of the expression for all p and outside that nest all q=0..<1 sums will be equal to v
22:26:28 <Keal> you not listening! :(
22:26:32 <newsham> e^jw
22:26:35 * Pseudonym can multitask
22:26:36 <Pseudonym> Go on
22:26:42 <Keal> i already told you it
22:26:50 <Keal> :(
22:26:56 <Keal> you lie :(
22:27:07 <ForgeAus> in solving x^2 = 4 most ppl forget to evaluate -2 because its slightly non-conventional.. 
22:27:08 <Pseudonym> You haven't finished.  You haven't explained what the problem is.,
22:27:15 <cpatrick> newsham: my understanding was that j was what engineers called i
22:27:28 <Keal> there was no prollem
22:27:28 <Pseudonym> Yes, engineers use j because i means electrical current.
22:27:31 <ForgeAus> x (in simple terms) is 2... (but I can't say -2 is INCORRECT)
22:27:36 <newsham> cpatrick: almost.   look at a mathemticians fourier transform vs. an engineers fourier transform.
22:27:42 <newsham> you'll notice that j == -i
22:27:42 <Keal> i just proved that continuity is indeed a continuity
22:27:52 <newsham> they're both square roots of -1
22:27:55 <ForgeAus> i is useful for 3d models apparently
22:27:55 <Keal> i just proved that continuum is indeed a continuum
22:27:58 <ForgeAus> not sure how it works tho
22:28:10 <Pseudonym> j is not -i
22:28:11 <newsham> forge: quaternions?
22:28:12 <cpatrick> newsham: AIUI the fourier transform difference is a separate issue again
22:28:13 <ForgeAus> xyz cartesian planes make more sense to me than using i's
22:28:24 <ForgeAus> newsham, possibly, that term is new to me
22:28:29 <Keal> at same token i prove infinity never ends in both directions
22:28:41 <Keal> -..-
22:28:45 <Pseudonym> Keal: But surely all this is dependent on the axiomatisation of real numbers.
22:28:48 <ForgeAus> Keal then how do yo arive at transfinite numbers? hehe
22:28:59 <Pseudonym> If so, your argument is circular.
22:29:07 <Keal> Pseudonym. it is not circular
22:29:24 <ForgeAus> I agree with Pseudonym. j = i
22:29:43 <Pseudonym> Sure it is.  By saying "q is a real number", you're invoking the axiomatisation of real numbers.
22:29:49 <Pseudonym> Which includes continuity, topology etc.
22:29:52 <ForgeAus> j^2 = -1 somehow... 
22:29:53 <newsham> pseudo: F(w) = \Integral f(t) e^{-iwt) dt
22:30:09 <newsham> F(w) = \Integral f(t) e^{jwt} dt
22:30:13 <newsham> q.e.d.
22:30:25 <newsham> j*j = -1, i*i = -1
22:30:28 <Keal> Pseudonym imaginary is nother axis
22:30:29 <Pseudonym> Right.
22:30:33 <Pseudonym> So?
22:30:36 <joelk> those aren't the same Fs
22:30:38 <Keal> so this is real axis
22:30:49 <newsham> joel: sure they are, if j = -i
22:31:02 <Pseudonym> In Quaternion algebra, i and j are different numbers such that i^2 = j^2 = -1.
22:31:06 <ForgeAus> how does an imaginary axis work?
22:31:24 <Keal> complex numbers for example
22:31:30 <ForgeAus> xy and a complex z?
22:31:33 <Pseudonym> In Geometric algebra, of course, i is the normal of the 2D plane.
22:31:34 <joelk> newsham, mathworld has a good explanation of the issue. There are lots of ways to define the fourier transform and its inverse.
22:31:52 <Pseudonym> In 3-space, ANY normal n has the property that n^2 = -1.
22:32:03 <Pseudonym> (Assuming it's normalised, of course.)
22:32:08 <ForgeAus> isnt using a complex z just complicating the equation why use it?... why not just normal z like x and y are?
22:32:24 <Keal> Pseudonym 0=>q>1 proves that 1 is indeed 1
22:32:48 <Pseudonym> Keal: OK, but 1 == 1 is trivially provable by other means.
22:33:03 <newsham> forge: yah, quaternions are for people who dont have matrices
22:33:04 <Keal> limit for base being 0 and 1 proves 0 is zero and 1 is one
22:33:24 <ForgeAus> ahh matricies! ....
22:33:25 <Pseudonym> On the contrary, matrices are for people who can't handle geometry.
22:33:25 <Keal> prollem tho is -1
22:33:29 <Keal> -1 is another limit
22:33:45 <ForgeAus> 3D arrays are simple enough to understand tho
22:33:49 <Keal> since -1 limit exists negative bases may work
22:33:53 <Pseudonym> You mean tensors?
22:34:01 <ForgeAus> each value includes an x,y,z value
22:34:18 <ForgeAus> so to find any point you just reference where along the x, y and z axes they are.. 
22:34:37 <Keal> however i not test negative bases since it cause prollems
22:34:40 <ForgeAus> why would one apply complex numbers to z? I don't understand
22:34:48 <Pseudonym> ForgeAus: You know any computer graphics?
22:34:56 <ForgeAus> Pseudo, not much
22:34:58 <newsham> i'm feeling tensor already
22:35:06 <ForgeAus> lol newsham
22:35:11 <ForgeAus> tnesor sounds familiar
22:35:18 <ForgeAus> grr tensor
22:35:18 <Pseudonym> ForgeAus: You know what a rotation matrix looks like?
22:35:25 <ForgeAus> no
22:35:31 <Pseudonym> Ah, then don't worry.
22:35:31 <ForgeAus> (sounds like one axes is polar?)
22:35:37 <lispy> ForgeAus: the end result is that translation can be represented as an affine transformation and becomes linear
22:35:47 <newsham> its all relative
22:35:50 <lispy> (linear in the sense that translation is a linear transformation)
22:36:14 <lispy> and linear transformations are easy to compose on hardware because you can use matrices
22:36:18 * Keal farts and goes to pee and go have a smoke outside
22:36:54 <ForgeAus> ur entire screen can be looked at as an x,y matrix of pixels!!
22:37:18 <ForgeAus> but thats just one representation
22:37:26 <Pseudonym> Geometric algebra, in which hypercomplex algebra is embedded, makes a lot of this stuff much simpler.
22:37:46 <Pseudonym> To rotate a point in 2D, you multiply it by a matrix.
22:37:47 <ForgeAus> Pseudo I figured it would somewhere along the line
22:38:13 <Pseudonym> [ [ cos t  -sin t ] [ sin t  cos t ] ]
22:38:22 <Pseudonym> (2D layout is not IRC's speciality.
22:38:39 <Pseudonym> That's the matrix representation.
22:38:40 <ForgeAus> awwww
22:38:41 <Pseudonym> Now consider this.
22:38:54 <ForgeAus> but I'd love to learn 2D sprite processing (collision detection, etc ) and all that jazz
22:38:55 <Pseudonym> Suppose that I is a quantity such that I^2 = -1
22:39:10 <Pseudonym> And further, suppose that I commutes with all real numbers.
22:39:17 <Pseudonym> So I*t = t*I for all real t.
22:39:26 <ForgeAus> true
22:39:45 <ForgeAus> least it did when I learnt complex numbers
22:40:03 <Pseudonym> Now if you expand the Taylor series, you will find that:
22:40:10 <Pseudonym> exp (I*t) = cos t + I * sin t
22:40:14 <Pseudonym> Just under those two assumptions.
22:40:36 <ForgeAus> that step is a little beyond me, I'll just take ur word for it
22:40:45 <lispy> or sometimes it's written exp(I*t) = cis(t)
22:40:57 <Pseudonym> Interestingly: I = [ [ 0  -1 ] [ 1  0 ] ] is a matrix such that I^2 = -1.
22:41:00 <newsham> e^jw
22:41:17 <Pseudonym> So exp (I*t) is a 2D rotation matrix.
22:41:49 <ForgeAus> wow I like that I = [ [ 0  -1 ] [ 1  0 ] ]
22:42:08 <Pseudonym> It works in 3D too, where I is any 3x3 matrix such that I^2 = -1.
22:42:16 <Pseudonym> I represents the normal of the plane of rotatin.
22:42:29 <ForgeAus> man why didn't they teach me this at school!
22:42:31 <Pseudonym> So there's a deep sense in which I, the complex number, is actually the "normal" to the 2D plane.
22:43:07 * Keal cries
22:43:12 <ForgeAus> hell I had to teach myself logartithms!
22:43:19 <lispy> in some sense, eigenvalues and eigenvectors are the generalization of this
22:43:45 <lispy> which is why they come up so much
22:43:56 <Pseudonym> Quantities like that also show up in quantum mechanics.  They're called spinors.
22:44:21 * ForgeAus plonks a quark and a spinor in the bottle and stirs...
22:44:34 <dons> @keal
22:44:35 <lambdabot> can haskell compile flash animations and java apps?
22:44:36 <Pseudonym> They were called that for an unrelated reason, but it's kinda cool that they turn out to be useful for rotating things in geometric spaces.
22:44:38 <dons> @keal
22:44:39 <lambdabot> i try make program called Glyph to do it but my script lang called T too
22:44:39 <lambdabot> slow. i invent T
22:44:46 <ForgeAus> hmmm but was it an up quark a strange quark a down quark or a bottom quark?
22:44:47 <dons> @keal
22:44:48 <lambdabot> you need a Zh function in Haskell
22:44:55 <dons> :)
22:44:58 * joelk suspected all along...
22:45:00 <lispy> @karma+ dons
22:45:01 <lambdabot> dons's karma raised to 23.
22:45:09 <Pseudonym> @showoff+ dons
22:45:09 <lambdabot> Unknown command, try @listcommands.
22:45:18 <dons> hehe
22:45:27 <newsham> salt is for suckas!
22:45:46 <ForgeAus> true
22:45:51 <ForgeAus> because salt dehydrates
22:46:01 <ForgeAus> thus requiring more sucking... in a vicious cycle
22:46:17 <newsham> your membranesmust be porous
22:46:18 <ForgeAus> which is why pretzels are so addictive
22:47:41 <lispy> ForgeAus: yeah, i always suspected it was a chemical dependence
22:48:42 <ForgeAus> its simple lipsy, same as (usually to lesser extent) fries, and lotsa other dryfoods
22:48:50 <ForgeAus> (cheetos, etc... if you guys have them over there)
22:49:02 <ForgeAus> (twisties?)
22:50:49 <lispy> we call them cheetos where i'm from
22:51:03 <lispy> but i don't eat them
22:51:11 <ForgeAus> good
22:51:33 <ForgeAus> they arent all that healthy that I can see
22:51:44 <Korollary> healthy foods are overrated
22:52:08 <ForgeAus> yeah and lots of them taste bad lol
22:52:20 <dons> bowel cancer is overrated
22:52:25 <ForgeAus> but you can't go wrong with a good salad
22:53:22 <Korollary> a good salad is as boring as the plate it comes in
22:53:46 <ForgeAus> Koroll, maybe you have to redefine what salad means to you?
22:54:04 <Korollary> like in a Gedankenexperiment?
22:54:21 <ForgeAus> sure stuff like lettuce tomato and onion but do you add something like banana?...
22:54:23 <Korollary> "What happens if a salad accelerates at a fat person nearing the speed of light?"
22:55:05 <ForgeAus> pasta and apple are also good to chuck in salad
22:55:33 <Korollary> well, if you follow  that path, the salad graduates to the carbohydrate souce category
22:55:41 <Korollary> +r+
22:55:46 <ForgeAus> I'm not a fan of egg (mostly the yolk) or cheese but lotsa salads have them
22:56:08 <joelk> OK, while trying to make the simplest ST function I could think of, I did this:
22:56:12 <ForgeAus> Korollary, sure nothing wrong with some carbs in ur salad
22:56:12 <joelk> @pl \a -> runST (newSTRef a >>= readSTRef)
22:56:12 <lambdabot> runST . (readSTRef =<<) . newSTRef
22:56:31 <joelk> the first version compiles, but the pl version gives a type error
22:56:40 <Pseudonym> The thing is, everyone is heavy if they near the speed of light.
22:56:45 <joelk> Can anyone tell me why?
22:56:50 <Pseudonym> And they get thinner.
22:56:59 <Pseudonym> So everyone is overweight, but nobody is fat
23:03:29 <Pseudonym> Must away.  Nytol!
23:06:58 <lispy> @keal
23:06:59 <lambdabot> antiparsimony were 100% correct...
23:07:12 <Korollary> oh man
23:11:34 <ski> joelk : maybe monomorphism restriction ?
23:13:05 <joelk> I've heard the phrase before...
23:14:03 <cpatrick> joelk: try giving it a type signature
23:15:01 <ski> hmm
23:15:14 <ski> i think the '.' application loses polymorphism
23:15:57 <cpatrick> dons: does the @keal database update as he keeps talking?
23:16:11 <joelk> cpatrick, well, it's type is a -> a. it's just id
23:16:27 <ski> right
23:16:31 <newsham> keal seems to give different results with each invocation
23:16:44 <ski> the 'runST' must be directly applied to it's polymorphic argument
23:17:10 <ski> s/'//
23:17:11 <dons> cpatrick, no.
23:17:28 <joelk> Ah... Well ain't that something.
23:17:29 <dons> could be done though. that would be truly evil.
23:17:48 <dons> newsham, of course. what else would it do?
23:17:53 <newsham> the links on http://www.haskell.org/libraries/ arent working for me :(   is web.archive.org down or is it on my side?
23:19:09 <newsham> how does one normally marshal structured data in haskell?
23:19:19 <newsham> Storable?
23:19:33 <dons> marshal for what purpose?
23:19:44 <dons> to talk to the ffi, Storable. to write to disk, Binary
23:19:46 <newsham> structured network data
23:20:00 <dons> or write a custom parser/pretty printer.
23:20:57 <newsham> is Binary standard?
23:20:58 <flux__> ocaml has a fun feature of marshalling functions between processes that are running the same binary
23:21:30 <flux__> that limitation can reduce its usefulnes quite a lot, though :)
23:21:35 <flux__> (but is understandable)
23:22:17 <dons> sounds cool though.
23:23:40 <flux__> also cyclic datastructures are supported, which may actually be more commonplace
23:23:57 <newsham> where can I find docs for Binary?
23:25:46 * Keal cries
23:26:11 <Keal> what is wrong with my damn eyes
23:26:21 <Keal> i am crying but i have no tears
23:26:30 <dons> @where NewBinary
23:26:31 <lambdabot> darcs get http://www.n-heptane.com/nhlab/repos/NewBinary
23:26:34 <Keal> they burn like hell
23:26:59 <dons> @keal
23:27:00 <lambdabot> doctor just give meds not fix prollem
23:27:44 <newsham> @dons
23:27:45 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
23:28:08 <Keal> @die
23:28:09 <lambdabot> "dice" (line 1, column 1):
23:28:09 <lambdabot> unexpected end of input
23:28:09 <lambdabot> expecting digit
23:28:39 <flux__> it would be fun if lambdabot (megahal?) could explain from what contexts does it get its response
23:29:09 <dons> the @keal lines are just from the logs. but it's practically megamonad anywaay
23:29:11 <flux__> but funny, my livingroom tv (which I'm ircing on) just turned off, and it can hardly be a stray IR signal because I have curtains
23:29:23 <flux__> oh
23:30:00 <Keal> @pi
23:30:01 <lambdabot> (line 1, column 1):
23:30:01 <lambdabot> unexpected end of input
23:30:01 <lambdabot> expecting white space, natural, identifier, lambda abstraction or
23:30:01 <lambdabot> expression
23:30:41 <Keal> @lambdabot
23:30:42 <lambdabot> Unknown command, try @listcommands.
23:31:46 * Keal needs sleep i guess
23:32:15 <dons> @keal
23:32:16 <lambdabot> how bout i say ick no unicorn and daisy loving girl mathematician will
23:32:16 <lambdabot> ever enjoy this
23:32:46 <dons> see, how is that _not_ MegaMonad?
23:33:43 <Keal> that is verbose recall
23:33:53 <Keal> of things i actually said
23:34:36 <Keal> are you saying i am MegaMonad?
23:35:40 <newsham> > return "test" >>= keal
23:35:41 <lambdabot>  Not in scope: `keal'
23:35:54 <dons> oh, this is too funny
23:35:57 <joelk> bah, dons, several days ago (2? 1?) I did a darcs send, only to realize that I don't have my mta setup... How else can I submit?
23:36:08 <dons> ah.
23:36:14 <dons> do a darcs send -o /tmp/f
23:36:18 <dons> and then mail me /tmp/f
23:36:49 <joelk> thanks.
23:38:42 <lispy> joelk: what OS do you use?
23:39:00 <lispy> darcs can send using things like evolution and mail.app
23:39:27 <joelk> lispy, linux.  
23:39:45 <joelk> dons, would you prefer inline or as attachment?
23:40:07 <Keal> i used to wash already diced carrots thinking they still contained pesticide. i assume they still had pesticide inside them anyway that theyabsorbed whilst growing and that washing them doesnt change that?
23:40:24 <lispy> joelk: okay, that should make things easy.  What do you normally use for email?  webbased or otherwise?
23:40:32 <newsham> who wrote keal?
23:40:42 <joelk> web
23:40:44 <Keal> i did
23:41:14 <lispy> joelk: okay, that makes it mildly harder.  Is it gmail or squirrelmail or what? (if you don't mind me asking)
23:41:22 <dons> joelk, an attachment is easiest.
23:41:27 <dons> newsham, I did.
23:42:10 <Keal> i am not code
23:42:35 <newsham> pretty imnpressive, but i think there's some crosstalk inm the knowledge representation implementation
23:42:37 <Keal> i exist in other, alternate reality connected to same internet
23:47:13 <Keal> a bomb just went off
23:47:17 <Keal> ccant say where
23:48:08 * Keal sleeps
23:50:08 <Keal> newsham
23:50:47 <Keal> dons?
23:50:53 <newsham> @newsham
23:50:54 <lambdabot> Unknown command, try @listcommands.
23:51:35 <Keal> mr. s?
23:52:00 <Keal> miss s?
23:52:01 <newsham> lion? scare crow?  aunty emm?
23:52:28 <Keal> is don male or female?
23:52:47 <Keal> o.o
23:53:30 <Keal> i am machine
23:58:38 <Keal> @dons
23:58:39 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
