00:00:26 <Korollary> palomer: http://www.amazon.com/exec/obidos/tg/browse/-/596192/ref=br_bx_c_2_0/104-6087657-6931151
00:00:29 <Korollary> about Canada
00:01:02 * shapr has a copy of Canada, found it on kazaa
00:18:31 <ADEpt> @index Variant
00:18:32 <lambdabot> bzzt
00:18:43 <ADEpt> ok, Variant it will be :)
00:38:51 <ADEpt> Lemmih: here?
00:43:17 <joelk> What is -fparr mean? It isn't in ghc's man page or the user manual.
01:00:53 <dons> it's for the nested data parallelism extensions
01:02:25 <dons> -fparr gives you syntactic support for parallel arrays 
01:02:39 <dons> -fflatten uses flattening transformations
01:02:51 <dons> check $fptools/ghc/compiler/ndpFlatten
01:04:14 <joelk> dons, was just wondering why the fannkuch shootout entries use it... I get an insignificant but repeatable speedup by leaving it out.
01:04:41 <dons> not sure why it'd be used in fannkuch
01:05:04 <Korollary> maybe because it sounds sexy
01:05:11 <dons> yeah. could be.
01:05:32 <dons> @docs GHC.PArr
01:05:32 <lambdabot> GHC.PArr not available
01:05:39 <dons> @fptools GHC.PArr
01:05:40 <lambdabot> GHC.PArr not available
01:05:42 <joelk> I don't think it's there for any good reason.
01:06:00 <dons> I think it's very ok to ditch it.
01:06:09 <dons> read GHC.PArr if you're interested
01:06:30 <joelk> another (slightly less) insignificant speedup comes from raplacing "foldl' max 0" with "maximum". Hehe
01:07:19 <dons> hmm, in Data.List: maximum xs              =  foldl1 max xs
01:07:28 * Speck sc(H)OFfs
01:08:11 <dons> and it gets specialised in Int and Integer to foldl1' max xs
01:08:30 <joelk> I get a repeatable approx 5% speedup
01:08:46 <dons> huh.
01:09:19 <dons> maximum is better anyway.
01:09:36 <dons> ah you going to put a page up for nbody on the hawiki?
01:09:54 <dons> @hawiki ShootoutEntry
01:09:55 <lambdabot> http://www.haskell.org/hawiki/ShootoutEntry
01:10:11 <joelk> I hardly see the point when I'm 2.5x slower than the current fastest Haskell
01:10:19 <joelk> ... entry
01:10:38 <dons> well, seeing differrent implementatoins can give people good ideas...
01:10:56 <joelk> OK, I'll fiddle around with it a bit first.
01:11:03 <dons> and whdo all this work when no one will see it? you should put something up.
01:11:46 <dons> (I put up 5 or 6 entries today, only 3 or 4 were actually better :)
01:13:01 <dons> I particularly like this for the sum-file test: main = getContents >>= print . foldl ((.read).(+)) 0 . lines
01:14:14 <joelk> neat!
01:14:21 <Speck> dons: I liked that too :-) especially considering the C version is actually shorter than the haskell entry atm
01:14:43 <dons> bah. I think haskell should be the shortest in all of them.
01:14:50 <Speck> I agree
01:15:00 <dons> it wasn't too hard to halve some of the entries for haskell
01:15:09 <joelk> I think you'd have to compare by characters in stead of lines to puck the shortest at this point...
01:15:19 <joelk> s/puck/pick/
01:15:28 <Speck> I really like the shootout effort going on. I'm learning a lot about optimizing haskell, even if some think it's a pointless endevour
01:15:53 <joelk> Speck, that's why I'm working on them too.
01:15:59 <dons> it's fun. it pushes on a funny end of haskell too, the intersection of brevity and speed.
01:18:18 <dons> the large string/regex tests are annoying though, we need better FastString/Regex libs.. I've got a prototype, but we can't use it in the shootout yet.
01:19:03 <joelk> Yep, I've just confirmed that *I* get a 5% speedup with maximum. Wonder what's going on...
01:19:45 <dons> are you compiling with -O, like the Data.List maximum/foldl would be?
01:19:59 <joelk> yes
01:20:20 <takuan> how do you represent a class hierarchy with uml?
01:20:31 <takuan> with the regular style for OO?
01:20:42 <Speck> maybe some kind of optimization can occur before maximum is translated into its equivalent form
01:20:43 <takuan> or does something more appropriate exist?
01:23:31 <araujo> Hello.
01:26:43 <joelk> What's the story with the different optimization levels -On? What's the highest meaningful n?
01:28:04 <Cale> I remember just hearing it was -O, at least with the native code generator
01:28:10 <Saulzar> By the looks of the docs O2
01:28:31 <Saulzar> What gets passed to the C compiler in the case of fvia-C?
01:29:39 <kzm> I generally use -O2, but I haven't really measured it much.  I suspect you get most of the benefit with just -O.
01:30:22 <Cale> The easiest way to see what -O (etc.) ‚Äúreally mean‚Äù is to run with -v, then stand back in amazement.
01:30:26 <Cale> heh
01:30:31 <Cale> (from the user guide)
01:30:49 <Saulzar> I can't see any gcc arguments with -v
01:31:05 <kzm> Well - if it even amazes the user guide author, it is probably worth watching :-)
01:31:27 <Saulzar> Ahh
01:31:33 <Saulzar> Kdevelop was filtering it, heh.
01:32:02 <Saulzar> Hmm
01:32:03 <joelk> I actually get a slight slowdown going from -O to -O3 (what the shootout entries all seem to use)
01:32:13 <Saulzar> It seems to use -O with gcc, even if I'm giving ghc -O3
01:32:15 <dons> ah, even better, use foldr: print . foldr ((+).read) 0 . lines =<< getContents
01:32:56 <Cale> why foldr there?
01:33:20 <Speck> would that still be in constant space? it's a requirement for the entry
01:33:21 <Cale> Isn't summing numbers a job for foldl'?
01:39:31 <dons> oh, I was just trying to make the code a bit simpler
01:39:41 <dons> fold' is probably a better idea.
01:40:58 <joelk> What's the easiet way to check that ghc is observing my INLINE pragmas?
01:42:31 <Cale> It always does, afaik
01:42:56 <Cale> The inline pragma is there to override its automatic decision with regard to inlining.
01:43:01 <joelk> Well, they're not helping (seem to be hurting actually)
01:43:48 <Speck> couldn't explicit inlining break the monomorphism restriction? would ghc tell you or just skip it?
01:44:31 <dons> ah, the foldr gets madly compiled into a tight loop. that's really cool
01:44:50 <Cale> dons: probably strictness analysis :)
01:46:38 <dons> ah, and even better if I say (0::Int).
01:46:46 <dons> then its about 10 lines of Core
01:48:20 <dons> ghc does a stunning job compiling "foldr ((+).read)" :)
01:49:15 <Cale> Are you compiling via C? I wonder what the C code for that looks like :)
01:54:24 <xerox> shapr: <http://khashmir.sourceforge.net/>
01:54:33 <xerox> Morning, people!
01:54:59 <xerox> @index fold'
01:54:59 <lambdabot> bzzt
01:55:01 <m3ga> evening xerox!
01:55:27 <dons> it's a bit hart to read Cale. the Core is turned into `idiomatic' .hc files, more idiomatic than usuual..
01:55:36 <dons> typo all day long
01:56:27 <xerox> dons: what are .hc files?
01:58:57 <shapr> xerox: thanks
02:00:55 <araujo> Good morning.
02:02:25 <xerox> Could anybody sum up what are the 'r' and 'l' and "l'" version of fold good at?  Picking them is usually matter of what sounds better for me, i.e. where the accumulator comes from, in reducing the list.  But have other properties, for example wrt to laziness; hence I ask :)
02:08:23 <Heffalump> I generally consider r the laziest, and l' the strictest.
02:08:39 <Heffalump> r will consume the list one element at a time and potentially produce useful output as it does so
02:08:50 <Heffalump> neither l and l' will produce any output until they've seen the entire list
02:09:19 <xerox> Gotcha.
02:09:22 <Heffalump> l will build up a large chain of unevaluated stuff while doing so, whereas l' will apply the operation strictly as it does so
02:09:29 <xerox> ..and I know the difference between l and l'
02:09:33 <xerox> Good.  Thanks much.
02:09:44 <Heffalump> my default choice is r
02:09:52 <Heffalump> then if I find a good reason (rarely) I change it
02:10:08 <xerox> I'm used to use l, duh.
02:10:15 <ibid> wouldn't the l variants be generally the right choice when the operator is strict?
02:10:29 <Heffalump> ibid: probably, but I don't think about strictness until I need to :-)
02:10:35 <ibid> xerox: l is the better variant in strict languages. maybe that's where it comes from?
02:10:59 <xerox> Possibly?  :\
02:11:09 <Heffalump> note that l can be expressed in terms of r (with an extra parameter, i.e. you build up a function with r and then apply it)
02:11:19 <Heffalump> I think l' probably can be too
02:11:54 <Heffalump> or at least nearly
02:19:37 <kzm> sorry to drop in late, but are there cases where you need foldl?  (I generally always use foldr or foldl')
02:20:04 * kzm is franctically scanning previous comments to see if the question was already asked and/or answered.
02:21:53 <ibid> hmm, i find myself using (flip map) a lot
02:24:58 <xerox> @type \xs -> (xs >>=) . (return .)
02:24:59 <lambdabot> forall a (m :: * -> *) b. (Monad m) => m a -> (a -> b) -> m b
02:26:22 <joelk> Whoa! Ok, weird. I replaced a function advance :: Double -> SolarSys -> SolarSys with advance :: SolarSys->SolarSys by explicitly putting the constant time step instead of a variable and the code became slower.
02:28:41 <joelk> Run time increased by one third! What the...
02:32:39 <kzm> That is...interesting.  Did you look at core output or anything?
02:34:17 <joelk> OK. I took out a bunch of extraneous INLINEs (ghc is smartre than me after all) and the difference went away. Still don't understand it though...
02:36:13 <joelk> kzm, what is core output and how does one look at it?
02:37:05 <bortzmeyer> I have a tail-recursive function but it still crashes with 'Stack space overflow'. I noticed the warning in http://haskell.org/hawiki/TailRecursive that I should use seq or $! but I have no idea how.*
02:38:42 <joelk> bortzmeyer, I'm just starting to get the hang of seq too. What is the function's type?
02:40:13 <bortzmeyer> joelk: Integer -> Integer -> Integer
02:42:26 <joelk> Ok. Can you give me the function?
02:43:08 <bortzmeyer> joelk: bump x n = 
02:43:08 <bortzmeyer>     if n <= 0 then 
02:43:08 <bortzmeyer>        x 
02:43:08 <bortzmeyer>     else 
02:43:09 <bortzmeyer>        bump (x+10) (n-1)
02:47:08 <joelk> ok. in this example: x+10 `seq` n-1 `seq` bump (x+10) (n-1)
02:47:23 <joelk> for the else case 
02:48:29 <joelk> actually seems the "n-1 `seq`" is unnecessary
02:48:43 <joelk> :t bump
02:48:44 <araujo> Excellent!
02:48:48 <araujo> It worked...
02:48:51 * araujo is scared
02:50:25 <bortzmeyer> joelk: Many thanks, it works. But it is extremely unelegant (specially typing twice x+10)
02:50:43 <bortzmeyer> To me, it completely defeats the purpose of tail-recursion.
02:52:32 <joelk> how about fbump n x = if n <= 0 then x else bump (n-1) $! (x+10)
02:52:43 <joelk> err... bump n x = if n <= 0 then x else bump (n-1) $! (x+10)
02:53:06 <joelk> still not pretty
02:54:01 <eivuokko> Maybe this: uncurry bumb $! (x+10,n-1)
02:54:19 <bortzmeyer> joelk: it does not work for me, Stack space overflow again (compiled with ghc)
02:54:58 <joelk> did you notice that I switched the order of the argument to avoid a flip?
02:55:37 <bortzmeyer> eivuokko: no, it does not work Occurs check: cannot construct the infinite type: a = (a, b)
02:55:37 <bortzmeyer>       Expected type: a
02:55:37 <bortzmeyer>       Inferred type: (a, b)
02:55:37 <bortzmeyer>     In the expression: x + 10
02:55:37 <bortzmeyer>     In the second argument of `($!)', namely `(x + 10, n - 1)'
02:56:09 <eivuokko> Uhm, I guess I should have tried it first, then ;)  Sorry.
02:57:16 <bortzmeyer> joelk: no, sorry, I missed the switching. It works now but why did it fail without you switch?
02:59:08 <joelk> The switch just put x in a convenient place to use $!
02:59:44 <bortzmeyer> Now, my Haskell program begins to look like my old Perl $! programs
03:01:01 <joelk> heh
03:01:06 <eivuokko> You mean it isn't artificial test-case?  Isn't that function bump x n = x+n*10?
03:02:21 <bortzmeyer> eivuokko: yes, it is artificial since I tried to understand tail-recursion. But one day, I'll have to do it for real
03:02:30 <eivuokko> Sure.
03:06:22 <maitscha> hallo. I have defined the following function:
03:06:31 <maitscha> compare1 :: Ord a => (a -> a -> Bool) -> a -> a -> Ordering
03:06:32 <maitscha> compare1 f x y
03:06:32 <maitscha>     | f x y     = LT
03:06:32 <maitscha>     | f y x     = GT
03:06:32 <maitscha>     | otherwise = EQ
03:06:50 <maitscha> but now, i am a little bit confused about the output:
03:06:58 <maitscha> -- compare1 (<) 2 4 == LT
03:06:58 <maitscha> -- compare1 (>) 2 4 == GT
03:06:58 <maitscha> -- compare1 (>) 4 2 == GT
03:06:58 <maitscha> -- compare1 (<) 4 2 == LT
03:07:39 <maitscha> the function compare1 is used for a sortBy. It seems it works correct, but I doesnt know how a sortBy could work with these output...
03:13:01 <Heffalump> are you sure that output is correct?
03:21:36 <ADEpt> @seen Lemmih
03:21:37 <lambdabot> Lemmih is in #haskell-blah and #haskell. Last spoke 10 hours, 34 minutes
03:21:37 <lambdabot> and 16 seconds ago.
03:22:48 <ADEpt> i wonder if it's ok for darcs to apply two dozen of patches for 4 hours (even more, since it is still running)?
03:25:47 <Heffalump> ADEpt: well, it does it.
03:26:11 <Heffalump> it shouldn't in theory, but it's a well known problem that is hard to fix (but droundy and others are working on it)
03:26:26 <ADEpt> Heffalump: so I could hope that if I leave it running, it will eventually terminate?
03:26:39 <Heffalump> it's an exponential blowup
03:26:48 <ADEpt> Heffalump: or I'd better apply them one-by-one?
03:26:54 <Heffalump> so you might have to wait for heat death of the universe
03:27:02 <ADEpt> Heffalump: :))))
03:27:07 <ADEpt> Heffalump: thanks
03:27:09 <Heffalump> if you do that you'll at least be able to observe where the problem is
03:27:12 <Heffalump> (one-by-one)
03:27:29 <Heffalump> I can probably help you work around it, but not till this evening (11:30am here now)
03:27:33 <Heffalump> and ask me on #darcs
03:28:08 <Lemmih> ADEpt: Hi.
03:29:16 <ADEpt> Lemmih: hi
03:29:25 <ADEpt> Lemmih: some mighty patches your did :)
03:29:49 <ADEpt> Lemmih: my darcs is running for 4+ hours on iP 2.2 applying them :)
03:29:50 <Heffalump> btw, it should definitely not happen if you don't have changes that aren't in the repo you are pulling from
03:29:58 <Heffalump> it's just when you try to merge changes that it gets unhappy
03:30:08 <Heffalump> s/it gets/it can get/
03:30:13 <ADEpt> Heffalump: this is a merge, and probably a big one
03:30:49 <Lemmih> ADEpt: Weird.
03:31:29 <ADEpt> Lemmih: i'll try to apply them one-by-one now.
03:32:38 <ADEpt> @localtime Heffalump
03:32:41 <lambdabot> Local time for Heffalump is Thu Jan  5 11:32:17 2006
03:33:04 <ADEpt> Lemmih: seems like even the first parch does it
03:33:26 <Heffalump> oh wow, how'd it do that?
03:34:07 <ADEpt> Heffalump: should I move to #darcs with that?
03:34:49 <ADEpt> Heffalump: or maybe there are some command-line switches that will give me lots of debug info?
03:35:21 <Heffalump> you can see if anyone else on #darcs can help now
03:35:34 <Heffalump> or as I said I can help this evening. I don't know of any useful command-line switches.
03:35:56 <ADEpt> Heffalump: ok, thanks
03:48:47 <Lemmih> ADEpt: Is your repo down?
03:49:57 <ADEpt> Lemmih: yep :( It's on home computer, which is behind strict firewall during the day
03:50:19 <ADEpt> Lemmih: i could provide you with copy via mail
03:51:28 <Lemmih> That would be nice.
03:53:48 <ADEpt> Lemmih: sent to you gmail address
03:54:01 <ADEpt> Lemmih: do you remember the version you started from ?
03:54:59 <Lemmih> Yeah. It was SamB's repo minus two patches.
03:58:11 <ADEpt> Lemmih: i'm getting you whole repo and try to merge mine into it on the assumptions that mine patches are smaller and might be easir to apply :)
04:01:57 <Lemmih> Merging might be hard since I pretty much rewrote everything except MiniHTTP.
04:04:34 <ADEpt> hmmm....
04:04:50 <ADEpt> and commited in one patch? :)
04:08:35 <Lemmih> Hm, darcs indeed doesn't like pulling my patches from your repo.
04:09:40 <ADEpt> or other way around
04:15:06 <ADEpt> Lemmih: is it just the way "main" is written, or your version does not actually do anything as of now?
04:24:57 <Lemmih> ADEpt: Main.run does something.
04:26:05 <Lemmih> ADEpt: I test it with GHCi.
04:26:51 <maitscha> hallo, i have to make a function like insertX :: [a] -> Int -> [a]
04:27:05 <ADEpt> Lemmih: I understand that it does at leas single-peer upload/download of the whole file, right?
04:27:14 <ADEpt> Lemmih: or even multi-peer?
04:27:20 <maitscha> no, insertX :: [a] -> a -> Int -> [a]
04:27:34 <maitscha> insertX [] c 3 == [ccc]
04:27:50 <maitscha> insertX [abc] d [2] == [abcdd]
04:28:10 <maitscha> does somebody know how to insert a value several times in a list?
04:28:42 <Lemmih> ADEpt: It should be able to do multi-peer downloading. I've only tested it a single peer, though.
04:28:57 <maitscha> insertX [abc] d 2 == [abcdd]
04:29:20 <Lemmih> maitscha: [ccc] == [c,c,c]?
04:29:31 <maitscha> Lemmih, oh, yes.
04:30:11 <maitscha> and insertX [a,b,c] d 2 == [a,b,c,d,d]
04:30:15 <ADEpt> Lemmih: so, whats your opinion - is it better to think and abandon the idea of merge or think and abandone some of the code, and, so to speak, merge manually?
04:30:29 <Lemmih> > let insertX lst c n = lst ++ replicate n c in insertX [1,2,3] 4 2
04:30:30 <lambdabot> [1,2,3,4,4]
04:31:34 <maitscha> oh. replicate is good.
04:31:44 <maitscha> @replicate
04:31:45 <lambdabot> Unknown command, try @listcommands.
04:31:51 <Lemmih> @type replicate
04:31:52 <lambdabot> forall a. Int -> a -> [a]
04:31:59 <Lemmih> ADEpt: Depends on whether you guys like my code or not.
04:32:02 <maitscha> ok. thx!!!
04:32:55 <ADEpt> Lemmih: what i've seen i liked (Bencode, Protocol/*). Though I've yet to grok the "whole picture"
04:35:02 <ADEpt> Lemmih: why did you got rid of loggin code? :)
04:36:45 <Lemmih> MissingH takes like half an hour to build on my laptop. Writing a BSD logger should take less than that (:
04:37:07 <kimos> i want to know which type this expression have:  Knoop (Boom `a`)      and boom is :  data Boom t = Leeg | Knoop (Boom t) (Boom t)
04:37:44 <ADEpt> kimos: Boom Char
04:37:55 <kimos> a -> Boom char ?
04:39:28 <joelk> Boom 'a' doesn't mean anything because there is no constructor Boom.
04:39:48 <ADEpt> joelk: ah.right
04:40:11 <kimos> so what is the type of the expression Knoop (Boom `a`)?
04:41:11 <Lemmih> kimos: (Knoop (Boom `a`)) isn't an expression.
04:41:22 <joelk> it won't even parse. And i assume you mean single-quotes not back-quotes
04:41:51 <kimos> yea its maybe 'a'   
04:42:45 <kimos> i got it in the exam asking  what is the expression of  Knoop (Boom  'a' )
04:43:10 <kimos> data Boom t = Leeg | Knoop (Boom t) (Boom t)
04:43:33 <joelk> "Constructor Boom not in scope" maybe?
04:43:46 <kimos> no
04:43:49 <joelk> that's what I would write on an exam
04:44:15 <kimos> its multible choice
04:45:17 <kimos> 1) (Boom a) -> Boom 1      2) (Boom Char) -> (Boom Char)   3) a -> Boom 1     4)   a -> Boom Char
04:45:45 <Lemmih> Wow.
04:45:57 <kimos> lol
04:46:21 <kimos> oops
04:46:29 <kimos> 1) (Boom a) -> Boom a     2) (Boom Char) -> (Boom Char)   3) a -> Boom a     4)   a -> Boom Char
04:46:39 <kimos> choose one plz :)
04:47:17 <Lemmih> kimos: Are you absolutely sure that Boom is defined as "data Boom t = Leeg | Knoop (Boom t)"?
04:47:25 <kimos> isnt   data Boom t = Leeg | Knoop (Boom t) (Boom t)   a construsion for boom?
04:47:31 <kimos> yes
04:48:14 <Lemmih> kimos: 'Boom' is a type constructor. 'Leeg' and 'Knoop' are the data constructors.
04:48:45 <kimos> wierd quastion 
04:49:07 <kimos> i did all the quastion my self  only this i needed  help
04:49:14 <joelk> maybe they meant: data Boom t = Leeg t | Knoop (Boom t) (Boom t). Then Knoop (Leeg 'a') :: (Boom Char) -> (Boom Char)
04:49:48 <kimos> yessss
04:50:02 <kzm> (or alternatively 'data Boom t = Leeg | Knoop t (Boom t) (Boom t)' )
04:50:35 <kzm> kimos: complain about meaningless question, get it annulled, and collect full score :-)
04:50:49 <kimos> lol goodplan
04:50:58 <joelk> Did the TA look hungover by any chance?
04:51:12 <kimos> TA?
04:51:26 <kimos> well sometimes they scrap some of the quastions because their wrong
04:51:35 <kimos> this might be also a wrong quastion
04:51:35 <kzm> kimos: actually, that worked for me - turned out one of the questions I couldn't answer wasn't correctly formulated.  One of my good grades :-)
04:52:05 <kimos> lets hope they will ask me this quastion again then lol :)
04:52:09 <joelk> friend of mine got offered a job after pointing out an error on the exam they give to applicants.
04:52:20 <kimos> come on ?
04:53:08 <kimos> lets hope i get a good job then 
04:53:33 <kimos> anyways so the best close answer is (Boom Char) -> (Boom Char)  ?
04:54:38 <kosmikus> kimos: I wouldn't answer the question without a remark that it's wrong.
04:54:44 <kosmikus> kimos: what course is this?
04:55:01 <kimos> programming lanquages
04:56:25 <kimos> joelk how did you come up with (Boom Char) -> (Boom Char)  ?
04:56:38 <kosmikus> if it's a take-home exam, can't you just write a mail to your teacher asking to correct the question?
04:57:28 <kimos> no its a sample exam and he might ask the same quastions on the exam 
04:57:47 <kimos> thats what he do everyyear actualy 
04:57:50 <joelk> Knoop :: (Boom Char) -> (Boom Char) -> (Boom Char), right?
04:58:49 <kimos> yes
04:59:38 <joelk> then Knoop (Leeg 'a') :: (Boom Char) -> (Boom Char) . With my redefinition of data Boom t
05:00:14 <kimos> ok i think its the good answer and i will put remark on it
05:00:17 <kosmikus> even if it's a sample exam, you should still get the exercise corrected
05:00:17 <kimos> thanks alot
05:00:24 <kosmikus> you'll help the other students that way
05:00:39 <kimos> yea true
05:00:48 <kimos> i will ass remark
05:00:52 <kimos> add* sorry
05:01:18 <kimos> thanks everyone 
05:03:56 <Speck> sorry this is completely ot, but #haskell is the nearest source of people at this hour and I don't care enough to actually look hard. Can anyone tell me what cratylism means?
05:07:30 <kimos> same as mimologism  i think
05:10:09 <Speck> that helped. thanks :-)
05:30:35 <chucky> what is the "buildable" flag in Cabal supposed to do?
05:31:09 <chucky> I thought setting "Buildable: False" would make it not build certain executables, but it builds them anyway
05:40:14 <chucky> Why does it have to be unusually quiet when I for once have a simple question? :(
05:40:53 <earthy> ;)
05:41:02 <earthy> I don't have the answer, sorry.
05:41:23 <chucky> Quite all right. :)
05:41:36 <ADEpt> chucky: shhhh! everybody is thinking ;)
05:43:18 <Lemmih> chucky: You want to disable the building of some libraries if eg. they depend on a foreign library which isn't there.
05:43:57 <chucky> lemmih: So why doesn't it work?
05:44:28 <chucky> it still builds my executables, even though I put buildable: False in my buildinfo-file
05:44:48 <Lemmih> Did you set it for the executable and not the library?
05:44:59 <chucky> yes
05:45:39 <Lemmih> Oh well.
05:45:42 <chucky> I have a configure file that generates a separate buildinfo file setting the buildable status on different executables
05:48:11 <chucky> hmm so apparently it works if I don't put it in a separate file. Interesting...
05:49:45 <datenmaulwurf> hey
05:49:47 <datenmaulwurf> i have a question
05:49:57 <datenmaulwurf> whats wrong with this part of a program named reduce1
05:49:58 <datenmaulwurf> reduce1 x:y:xs
05:49:59 <datenmaulwurf>         | x == y        =       x:reduce1 xs
05:49:59 <datenmaulwurf>         | otherwise     x:y:reduce1 xs
05:50:20 <audreyt> missing = after otherwise.
05:50:39 <datenmaulwurf> oh ^^
05:50:40 <datenmaulwurf> thanks
05:50:42 <chucky> and missing parenthesis around the first line, should be: reduce1 (x:y:xs)
05:50:42 <datenmaulwurf> there is another
05:50:50 <datenmaulwurf> ERROR test:4 - Syntax error in declaration (unexpected symbol ":")
05:50:57 <datenmaulwurf> line 4 is in this case the first line
05:51:04 <datenmaulwurf> okay
05:51:22 <datenmaulwurf> thanks alot!
05:51:24 <datenmaulwurf> now it works
05:51:35 <datenmaulwurf> thanks ;)
05:51:38 <audreyt> np :)
05:51:44 <chucky> np
05:53:36 <datenmaulwurf> hu... it doesn't work correctly :|
05:53:44 <tromp_> do you want reduce1 [0,1,1] = [0,1,1] ??
05:53:51 <datenmaulwurf> no
05:54:00 <tromp_> then your otherwise clause is wrong
05:54:09 <datenmaulwurf> [1,2,3,3,4,5] -> [1,2,3,4,5]
05:54:14 <datenmaulwurf> that's what i want
05:54:17 <chucky> you will need a base case as well I think?
05:54:29 <tromp_> try x:reduce1 (y:xs)
05:54:41 <datenmaulwurf> omg, yeah
05:54:43 <datenmaulwurf> you#re right
05:55:28 <datenmaulwurf> hmm
05:55:39 <datenmaulwurf> reduce1 (x:y:xs)
05:55:39 <datenmaulwurf>         | x == y        = x:reduce1 xs
05:55:39 <datenmaulwurf>         | otherwise     = x:y:reduce1 (y:xs)
05:55:51 <datenmaulwurf> makes
05:55:52 <datenmaulwurf> reduce1 [1,3,3,2,2,3,1,1,1,3]
05:55:52 <datenmaulwurf> [1,3,3,2,3,1,1,1,3,3]
05:55:57 <tromp_> or define reduce1 = map head . group
05:56:27 <audreyt> wouldn't that involve multiple traversals?
05:56:39 <tromp_> nope
05:56:52 <audreyt> ah right. indeed.
05:59:16 <resiak> tromp_: Where's group defined?
06:00:06 <arjanb> @index group
06:00:07 <lambdabot> Data.List
06:00:19 <resiak> Handy
06:00:32 <datenmaulwurf> now it works well
06:00:36 <datenmaulwurf> but i need a little
06:00:39 <datenmaulwurf> feature
06:01:01 <datenmaulwurf> [1,1,1,3,3,4] should be [1,3,4]
06:01:16 <datenmaulwurf> and [1,1,1,1,1,1,1] should be [1]
06:01:21 <datenmaulwurf> reduce1 (x:y:xs)
06:01:21 <datenmaulwurf>         | x == y        = x:reduce1 xs
06:01:21 <datenmaulwurf>         | otherwise     = x:reduce1 (y:xs)
06:01:21 <datenmaulwurf> ~                                         
06:01:32 <datenmaulwurf> how can i improve it?
06:02:36 <arjanb> | x == y  = reduce1 (y:xs)
06:02:51 <tromp_> great; an infinite loop
06:02:59 <tromp_> oops no:(
06:03:02 <datenmaulwurf> ^^
06:03:03 <datenmaulwurf> lol
06:03:10 <datenmaulwurf> it makes always an empty list
06:03:21 <datenmaulwurf> no
06:03:33 <datenmaulwurf> hmm
06:03:40 <datenmaulwurf> there is a problem
06:03:52 <datenmaulwurf> [1,1,2,2] should be [1,2]
06:03:55 <datenmaulwurf> not an empty list
06:04:15 <tromp_> try reduce1 (x:xs) = x : reduce1' xs where ...
06:04:42 <tromp_> and reduce1 [] = []
06:05:15 <datenmaulwurf> ok, thanks
06:05:17 <datenmaulwurf> i'll try it
06:12:28 <chucky> this is getting weird now. Cabal *never* seems to read my package.buildinfo file, no matter what I put in it
06:14:18 <datenmaulwurf> sorry
06:14:22 <datenmaulwurf> i have another question
06:15:13 <datenmaulwurf> exists a function which returns true if an element exists in a list xs?
06:15:39 <chucky> @type elem
06:15:40 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
06:16:49 <shapr> chucky: run the unit tests?
06:17:09 <chucky> shapr: I found it, I'm stupid. :)
06:17:26 <chucky> I didn't use defaultMainWithHooks
06:17:32 <shapr> ah ok
06:17:40 <chucky> although I might have other problems now
06:20:03 <datenmaulwurf> chucky, Prelude> forall
06:20:03 <datenmaulwurf> ERROR - Undefined variable "forall"
06:20:13 <datenmaulwurf> :|
06:20:29 <Lemmih> > elem 4 [1..10]
06:20:31 <lambdabot> True
06:20:39 <datenmaulwurf> sry
06:20:45 <datenmaulwurf> thanks :)
06:33:51 <farre> @djinn a -> b -> a
06:33:52 <lambdabot> f a _ = a
06:34:39 <chucky> wow, that was almost scary! :)
06:35:07 <chucky> (the way lennart entered the channel a few seconds after farre invoked Djinn, that is)
06:36:06 <farre> @djinn (a -> b -> c) -> (b -> a) -> b -> c
06:36:07 <lambdabot> f a b c = a (b c) c
06:37:48 <shapr> In reality, lennart is the djinn... that's why he shows up like that.
06:38:19 <neologism> in a few weeks my haskell course at school will begin
06:38:29 <neologism> I am curious what it will be
06:39:42 <Saulzar> Hmm, the delay mechanism in Yampa seems to make it hard to deal with instantaneous events... Trying to do collision response but a delay means that my object is 2 frames embedded in the other by the time it responds
06:39:55 <pierre-> hi all
06:40:07 <xerox> djinnModule type = askLennart ("write a function of this type: " ++ type) >>= \code -> replyBack code
06:40:11 <pierre-> which gui library for haskell is better?
06:40:24 <xerox> pierre-: I'm partial to Gtk2Hs.
06:40:24 <SamB> pierre-: silly question
06:40:40 <pierre-> why?
06:41:09 <shapr> neologism: which school?
06:41:17 <neologism> vutbr.cz
06:41:19 <xerox> Because it has all the goodies, and it's very simple to use, modulo some things under work.
06:41:28 <neologism> shapr: I doubt you ever heard about that
06:42:15 <xerox> pierre-: for example, it has cairo!  And OpenGL (also in 'in a widget' fashion), aaand, more.
06:43:04 <lennart> I'm the all-seeing eye of the djinn....
06:47:57 <lennart> tic: all klart och inlamnat till expeditionen
06:48:27 <tic> lennart, topp. dÂ dyker det upp i Ladok snart dÂ, antar jag.
06:48:29 <Lemmih> lennart: What does 'inlamnat' mean?
06:48:32 <tic> Lemmih, handed in.
06:48:37 <tic> Lemmih, although, "inl‰mnat".
06:48:52 * tic hands lennart a pair of dots
07:01:32 <Lemmih> Hiya sjanssen.
07:01:50 <sjanssen> hello Lemmih
07:09:24 <Igloo> Anyone with Debian/powerpc around?
07:10:12 <Igloo> Oh, n/m
07:34:12 <TNKS> Hi.  Have there been any efforts to make Haskell it's own embedded scripting language, say through dynamic compilation?
07:34:31 <ADEpt> TNKS: already done ;)
07:34:47 <TNKS> ADEpt, I'm down with it.  Can you point me in the right direction?
07:34:48 <shapr> @where hs-plugins
07:34:48 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
07:34:50 <integral> @eval "Yep"
07:34:52 <lambdabot> "Yep"
07:35:02 <ADEpt> @eval "+1"
07:35:04 <lambdabot> "+1"
07:35:19 <flux__> you know guys, that isn't very impressive ;)
07:35:59 <ADEpt> @eval "print $ length \"oh really?\""
07:36:01 <lambdabot> "print $ length \"oh really?\""
07:36:05 <Cale> > let sieve (x:xs) = x : sieve [y | y <- xs, y `mod` x /= 0] in sieve [2..]
07:36:07 <lambdabot> [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,
07:36:07 <lambdabot> 101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,
07:36:07 <lambdabot> 193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,
07:36:07 <lambdabot> 293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,
07:36:07 <lambdabot> 409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,
07:36:09 <lambdabot> [24 @more lines]
07:36:23 <flux__> adept, really ;)
07:36:23 <integral> _that_ is impressive 8)
07:36:24 * ADEpt . o O (damn!)
07:36:40 <TNKS> hs-plugins looks pretty cool.  Was it designed for an application in particular?  I'm curious to see what kind of apps have used it.
07:36:51 <ADEpt> TNKS: lambdabot here
07:37:02 <ADEpt> TNKS: h4sh
07:37:03 <Cale> and yi
07:37:30 <flux__> btw, what is the status of yi nowadays?
07:37:39 <Cale> It's usable
07:38:02 <Cale> http://www.cse.unsw.edu.au/~dons/hs-plugins/paper/
07:38:05 <Cale> http://www.cse.unsw.edu.au/~dons/hs-plugins/
07:38:35 <TNKS> oh yeah. . . duh. . . for some reason, I thought lambdadot might be some kind of interface to a hugs or ghci session.
07:38:49 <TNKS> it makes more sense to use hs-plugins.
07:39:11 <TNKS> I'll check out h4sh (a Haskell shell?) and yi.
07:39:41 <Cale> h4sh is a bunch of small commandline apps
07:39:53 <Lemmih> Well, hs-plugins is just a sugar coated interface to GHC and GHCi's linker.
07:40:59 <TNKS> how stable is hs-plugins?  
07:43:20 <SamB> should I stop waiting for gmane and just admit Lemmih's message to the list?
07:43:57 <Cale> SamB: what?
07:44:11 <SamB> Cale: conjure list
07:44:17 <Cale> oh
07:44:34 <SamB> ADEpt: what do you think?
07:45:21 <ADEpt> SamB: which message?
07:45:31 <ADEpt> SamB: actually, I think about Lemmih's code right now :)
07:45:49 <SamB> ADEpt: the one about what he changed
07:46:06 <ADEpt> SamB: you should, I think
07:47:03 <ADEpt> SamB: how is it happen that gmane is in this process? :)
07:47:13 <SamB> hmm?
07:47:19 <SamB> process?
07:47:38 <SamB> I was hoping gmane wouldn't take so long to subscribe to the list...
07:47:46 <ADEpt> SamB: process of admitting a message to mailing list
07:47:51 <ADEpt> SamB: ah. I see
07:48:12 <SamB> so now I'll end the emergency moderation too...
07:48:13 <ADEpt> SamB: I think that gmane could actually wait for some message to create the list :)
07:48:32 <ADEpt> SamB: so you could try posting some "ping" message and see what happens
07:48:40 <SamB> ADEpt: it isn't on my subscriber list though
07:49:39 * ADEpt looks at Lemmih's code and thinks about russian proverb about something that is too heavy to carry further, but it will be a pity to throw it out :)
07:50:06 <SamB> I thought Lemmih was the one throwing things out?
07:50:13 <SamB> so will there be no merge, then?
07:50:34 <flux__> hm, my oldish yi tree doesn't pull cleanly, even though I don't have local changes
07:50:53 <SamB> flux__: huh
07:51:04 <SamB> do you have local patches?
07:51:36 <flux__> well I apparently had one, I apparently had had some .nfs-files in at some point, but I removed them, shouldn't be of consequence
07:52:09 <SamB> did you darcs revert/darcs unpull?
07:52:19 <flux__> um, no
07:52:24 <flux__> is that what I should do?-)
07:52:40 <SamB> well, was it a patch or a change that you had?
07:53:53 <ADEpt> SamB: i tried to pull from Lemmih today. even the first patch spent ~5 hours in darcs, after which I just killed darcs process.
07:54:04 <SamB> ah.
07:54:10 <ADEpt> SamB: seems like automatic merge is not possible at the moment
07:54:21 <SamB> Lemmih: why did you make such a huge patch?
07:54:28 <flux__> I have one 'local patch', "Removed .nfs-files", but I don't see why that should cause a problem
07:54:41 <SamB> flux__: dunno
07:54:49 <SamB> but you could try unpulling it...
07:54:55 <ADEpt> SamB: i tried it in different forms and shapes - like pulling my patches to Lemmihs repo, merging patch-by-patch from both to the third one - to no avail
07:55:12 <SamB> yeah. I tried that too...
07:55:56 <ADEpt> SamB: yep, probably the good thing will be to just re-record everything in Lemmih's repo in small patches, but I am not sure if it is a task that is possible to tackle
07:55:58 <flux__> nope, still has a problem
07:56:23 <flux__> and darcs whatsnew says No changes!
07:56:49 <Lemmih> I've successfully pulled my patches from SamB's repo.
07:57:07 <flux__> oh, I'm pulling from http://www.cse.unsw.edu.au/~dons/yi
07:57:07 <ADEpt> Lemmih: "from SamB" or "to SamB"?
07:57:07 <Lemmih> SamB: I got carried away. (:
07:57:09 <SamB> Lemmih: whose patches from my repo?
07:57:33 <Lemmih> ADEpt: To SamB.
07:57:53 <SamB> flux__: what does "darcs push" say?
07:58:04 <ADEpt> SamB, Lemmih: I would definitely want to see a merger, but i think we need a Plan (whew, I said it :)
07:58:04 <SamB> possibly with --dry
07:58:27 <flux__> darcs: Pushing to http URLs is not supported. (my darcs is 1.0.3-2)
07:58:40 <flux__> but it is only one patch that doesn't commit
07:58:55 <flux__> hm, maybe
07:59:27 <flux__> apparently all the rest depend or it or something
08:01:06 <ADEpt> SamB, Lemmih: I already whined that once again I cant see the Big Picture - which module does what and which interact with what
08:02:07 <Lemmih> ADEpt: The mail I sent to conjure@ should clarity things a bit.
08:02:58 <ADEpt> Lemmih: yep. just read it. But I would like to see something like [(Module, it's function/purpose, it's users)] :)
08:03:13 <ADEpt> Lemmih: i would even write it, with help :)
08:06:00 <Lemmih> It should be relatively simple. Network.Server is the server, Protocol.PWP is the Peer Wire Protocol, and so on.
08:07:29 <Lemmih> FileSystem.Interface is explained in the mail and the BlockManager (previously known as the PieceManager) got a fair bit of documentation in its header.
08:09:34 <TNKS> The YAML documentation makes reference to a libyaml-haskell, but I couldn't find it.  Can someone help me out?
08:10:58 <SamB> mailman seems to munge mail in its archive...
08:11:18 <Heffalump> yes, for anti-harvesting reasons
08:12:37 <SamB> Heffalump: do un-munged archives exist?
08:13:39 <Heffalump> err, pass
08:14:14 <SamB> you don't know?
08:14:16 <Heffalump> not that I can find.
08:14:26 <Heffalump> I don't know for sure, but the files I can find are all munged.
08:14:53 <Heffalump> oh, hangon
08:14:59 <SamB> thats just lovely...
08:15:13 <Igloo> A bit of sed fixes non-extreme cases IIRC
08:15:37 <Heffalump> yes, they do exist.
08:16:27 <SamB> Heffalump: where?
08:16:39 <Heffalump> http://urchin.earth.li/mailman/private/conjure/
08:16:51 <Heffalump> oh, bugger.
08:17:08 <SamB> bugger?
08:17:12 <Heffalump> they exist on the file system, and for lists without public archives the equivalent URL gets to the unmunged ones
08:17:29 <Heffalump> but for ones with public archives it seems not to
08:18:05 <Heffalump> what do you need it for?
08:18:12 <Heffalump> (i.e. do you need it very occasionally, or regular access?)
08:18:37 <SamB> oh, I just seem to remember the gname people being picky about that sort of thing...
08:18:43 <SamB> er, gmane rather
08:19:00 <Heffalump> but gmane should only need the archives once for an import, right?
08:19:05 <Heffalump> cos it can subscribe to get ongoing access
08:19:08 <SamB> yeah
08:19:19 <SamB> of course ;-)
08:19:40 <Heffalump> ok, if you need the mbox just ask me.
08:20:28 * Heffalump discovers than anyone with an urchin account can read it once they know the name. Hmm, not very secure that.
08:20:29 <SamB> okay
08:20:57 <SamB> read what?
08:21:09 <SamB> the archives?
08:21:20 <Heffalump> yes
08:21:33 <Heffalump> not much of an issue for a list that's public anyway. I doubt our users want to spam harvest :-)
08:21:39 <SamB> I think the main thing is that spammers not get to it by accident
08:22:25 <SamB> if spammers cared, they wouldn't have any trouble finding large corpi of munged emails to unmunge...
08:23:41 <Heffalump> yeah
08:29:00 <sproingie> trivial unmunging does get done by many spammers
08:29:38 <sproingie> but not all.  and they don't sell each other's address lists much these days, so it cuts spam at least in half
08:29:49 <sproingie> too much of a price imho tho, destroying email usability
08:30:05 <Cale> Gmail is pretty good at filtering spam, though it's been letting through a few of the fake diploma ones lately. I've had 30 spam messages in the last couple days, most of them obviously from the same spammer.
08:30:37 <sproingie> gmail's spam filter is adequate, but i think it retroactively marks up spam 
08:30:53 <sproingie> which is something webmail providers can do that isp's generally don't have resources to do
08:31:04 <tuomov> bogofilter+old spamassassin is working quite well for me
08:31:18 <tuomov> even plain bogofilter would do decently
08:31:28 <sproingie> dspam is pretty godlike if you can get it configured right
08:31:30 <tuomov> I get perhaps one false negative a week
08:31:57 * sproingie does antispam for a living :)
08:32:06 <Cale> I've had only 3 or so false negatives in the time I've had my gmail account.
08:32:06 <Saulzar> Apparently we have spam filtering , but I've been getting absolutely bombarded with the fake watches and drugs advertising
08:32:23 <Cale> (at least, that I've seen)
08:32:36 <sproingie> Saulzar: yep, those have been the big problem spam runs for us
08:32:56 <Saulzar> Only thing that it filters is emails from my relatives :)
08:33:01 <sproingie> the watch spammer has a really good phrase generator for the prose, or else he just embeds everything into an image
08:33:17 <sproingie> and the drug spammer is mangling the text *so* badly that it's unreadable 
08:33:47 <Cale> sproingie: Yeah, the best trick I've seen is encoding the whole spam in an image, and including some innocuous real-email text around it.
08:33:54 <Saulzar> Yeah, I've gotten a number of random garbage  + image attachment ones
08:34:01 * sproingie is sort of limited in what he can do in commercial antispam, since it's a lot more sensitive wrt false positives
08:34:16 <Cale> In the past I used to get quite a lot of completely-blank spam, which was baffling.
08:34:25 <sproingie> i.e. i personally can accept fp's, but i can't impose them on millions of users
08:34:28 <Cale> Not even a title.
08:34:35 <sproingie> Cale: probably a probe for a live mailbox
08:34:42 <Cale> sproingie: yeah
08:35:24 <sproingie> we've got some image OCR for the image spam, but boy is it not fast
08:35:24 <Saulzar> You'd have to be so stupid to ever respond to any of it... it's amazing that it works
08:36:01 <sproingie> Saulzar: for the most part, the response rates actually aren't really profitable.  the spammer is sually running a scam against the advertiser who only wants hits
08:36:31 <sproingie> Saulzar: you'd think that pyramid would have collapsed by now, but i guess greed distorts perception enough to keep it going
08:37:02 <Saulzar> Hmm
08:37:08 <Saulzar> Fantastic
08:37:22 <sproingie> i suspect the drug spam is profitable though.  pure business reasons -- they're cheaper
08:37:50 <sproingie> especially when the product they sell is often bogus
08:39:02 <sproingie> and now back to your regularly scheduled haskell talk
13:53:16 --- topic: '["Haskell is still the language of choice for discriminating hackers", "logs: http://tunes.org/~nef/logs/haskell/","http://www.haskell.org/learning.html","Haskell IDE: http://haskell.org/hawiki/hIDE","http://www.haskell.org/tmrwiki/IssueFive","We put the Funk in Funktion","http://sequence.complete.org/hwn/20051129","HCAR 11/2005: http://haskell.org/communities/","dons for Emperor !"]'
13:53:16 --- topic: set by boegel on [Wed Dec 21 07:13:18 2005]
13:53:16 --- names: list (clog_ carp Lokadin monochrom palomer poetix sylvan bigbabyjesusfoo baskeboler mjl69 alar tennin JKnecht boro_ tic icb cinema qnix_ der_eq_ ADEpt lisppaste2 ncalexan Itkovian jips neurogeek andrew_p Nomius defcon8 kagy SyntaxNinja cparrott mkhl fabs _Codex pediddle CosmicRay kaol chucky sproingie kpreid_ masm psi PerlJam lennart Si\ svens jberg frederik_ Revision17 Jaen Pupeno arjanb iblechbot reductor Beelsebob Oejet praseodym donghee)
13:53:16 --- names: list (araujo astrolabe Speck sethk Nioate SamB cognominal tismith da_Bobstopper Squall` takuan Trixsey|Laptop Twigathy neologism Philippa borism metaperl mauke cooz_ mornfall triplah Saulzar juhp Cale Nanar PupenoL JaffaCake ramkrsna kpk gaal ozone tessier zamez glasser kzm aleator Chilli ksandstr ValarQ audreyt wolverian wilx eno-away Khisanth scw clog psnl cmeme resiak wli tewk cbus ibid sieni lambdabot cjs__ integral spamsch djw Lor cmm)
13:53:16 --- names: list (musasabi johs Lunar^ dany2k Iome earthy C-Keen boegel kala__ stesch noj drbean eyck skylan AtnNn mattam arguile jp-autark nik_ Korollary kosmikus Wallbrak1r dons thedward samx Igloo magagr moonlite eivuokko tromp_ tic|school gzl Lemmih ulfdoz flux__ ricebowl lispy cods xerox Spark norpan WillKW rep tumm Heffalump alch` seafood jlouis dcoutts_ Matt-W pejo emu kolmodin cpatrick tuomov)
13:53:37 <Squall`> Why would ghci give me an error when when doing square x = x * x ? Are you not allowed to define functions in the interpreter or something?
13:53:52 <SyntaxNinja> Squall`: right
13:53:55 <xerox> You can, but you must use the 'let' syntax.
13:53:56 <Squall`> oh
13:54:01 <Squall`> okay
13:54:04 <SyntaxNinja> only in ghc
13:54:30 <Squall`> I also am having a little trouble grasping "layout", especially for control structures.
13:54:32 <monochrom> let square = x*x
13:54:46 <monochrom> there is no control structure.
13:54:53 <xerox> there is no spoon.
13:54:56 <Squall`> pardon?
13:55:03 <monochrom> there is no control structure.
13:55:07 <SamB> Squall`: you can look at the report.
13:55:08 <xerox> there is no spoon!
13:55:14 <lennart> palomer: how would we evaluate let a = b in c?  is it a trick question? :)
13:55:15 <Squall`> okay
13:55:22 <SamB> we ought to add the layout rule sections to the channal FAQ
13:55:26 <alar> where is no spoon?
13:55:33 <SamB> alar: there ->
13:55:42 <Squall`> SamB, that would certainly be helpful.
13:55:43 <xerox> <- here
13:55:47 <palomer> lennart: nope
13:55:55 <Philippa> Squall`: the report gives an entirely accurate definition of the layout rule that I've never found anywhere else. Well worth it IMO
13:56:19 <SamB> hmm
13:56:22 <SamB> interesting!
13:56:25 <Squall`> What is ' the report'?
13:56:26 <monochrom> There is no alar
13:56:26 <spoon> oh, there is a spoon
13:56:36 <xerox> I don't see any spoon.
13:56:38 <spoon> =NickServ= This nickname is owned by someone else
13:56:40 <SamB> @google Haskell report
13:56:42 <lambdabot> http://www.haskell.org/onlinereport/
13:56:47 <Squall`> thanks
13:57:00 <Philippa> Squall`: "The Haskell 98 Report", sorry
13:57:00 <SyntaxNinja> alar: darn I almost kicked you, but I couldn't op myself fast enough ;)
13:57:00 <palomer> lennart: would you create fixed point terms to evaluate it?
13:57:06 <Squall`> okay
13:57:22 <alar> SyntaxNinja: why?
13:57:23 <lennart> palomer: in Haskell, yes
13:57:40 <SamB> @google "The Haskell 98 Report"
13:57:41 <lambdabot> http://www.haskell.org/onlinereport/
13:58:11 <SamB> alar: 'cause its fun to kick spoons?
13:58:22 <Khisanth> alar: there WAS a Spoon :(
13:58:40 <lennart> let a = b in c === (\a.c) (fix (\a.b))
13:58:52 <palomer> lennart: what's the semantics of fix
13:59:26 <lennart> use the Y combinator.  Or think of it as a the least fixpoint operator in the cpo, if you prefer.
13:59:35 <palomer> so fix == Y
13:59:40 <lennart> yes
13:59:53 <palomer> but this will be part of my Term datatype
13:59:55 <monochrom> "use the Y combinator, Luke!"
14:00:30 <lennart> you can't type check Y, so you'd have to build it in
14:00:53 <lennart> fix :: (a->a)->a
14:01:16 <palomer> lennart: by building it in, do you mean have it part of my Term datatype?
14:01:47 <lennart> well, in the same way as you have, say, + as a primitive
14:01:57 <lennart> it's just another function
14:02:29 <palomer> oh, so fix :: exp -> exp
14:02:39 <SyntaxNinja> alar: to prove there was no spoon?
14:02:48 <lennart> palomer: yes
14:02:49 <alar> :)
14:03:13 <lennart> if that how you do your other primitives
14:03:40 <palomer> and how would I define fix?
14:04:11 <lennart> well, the Haskell function you want is 'fix f = x where x = f x'
14:04:28 <lennart> that's a good definition because it will give you a cyclic graph
14:04:49 <lennart> how you turn that into Exp->Exp depends on how your code looks
14:05:27 <palomer> lennart: pretty standard, App, Lam and Var constructors
14:07:01 --- topic: '["Haskell is still the language of choice for discriminating hackers", "logs: http://tunes.org/~nef/logs/haskell/","http://www.haskell.org/learning.html","Haskell IDE: http://haskell.org/hawiki/hIDE","http://www.haskell.org/tmrwiki/IssueFive","We put the Funk in Funktion","http://sequence.complete.org/hwn/20051129","HCAR 11/2005: http://haskell.org/communities/","dons for Emperor !"]'
14:07:01 --- topic: set by boegel on [Wed Dec 21 07:13:18 2005]
14:07:01 --- names: list (clog_ ihope bigbabyjesusfoo carp Lokadin monochrom palomer poetix sylvan baskeboler mjl69 alar tennin JKnecht boro_ tic icb cinema qnix_ der_eq_ ADEpt lisppaste2 ncalexan Itkovian jips neurogeek andrew_p Nomius defcon8 kagy SyntaxNinja cparrott mkhl fabs _Codex pediddle CosmicRay kaol chucky sproingie kpreid_ masm psi PerlJam lennart Si\ svens jberg frederik_ Revision17 Jaen Pupeno arjanb iblechbot reductor Beelsebob Oejet praseodym donghee)
14:07:01 --- names: list (araujo astrolabe Speck sethk Nioate SamB cognominal tismith da_Bobstopper Squall` takuan Trixsey|Laptop Twigathy neologism Philippa borism metaperl mauke cooz_ mornfall triplah Saulzar juhp Cale Nanar PupenoL JaffaCake ramkrsna kpk gaal ozone tessier zamez glasser kzm aleator Chilli ksandstr ValarQ audreyt wolverian wilx eno-away Khisanth scw clog psnl cmeme resiak wli tewk cbus ibid sieni lambdabot cjs__ integral tuomov cpatrick kolmodin)
14:07:01 --- names: list (emu pejo Matt-W dcoutts_ jlouis seafood alch` Heffalump tumm rep WillKW norpan Spark xerox cods lispy ricebowl flux__ ulfdoz Lemmih gzl tic|school tromp_ eivuokko moonlite magagr Igloo samx thedward dons Wallbrak1r kosmikus Korollary nik_ jp-autark arguile mattam AtnNn skylan eyck drbean noj stesch kala__ boegel C-Keen earthy Iome dany2k Lunar^ johs musasabi cmm Lor djw spamsch)
14:07:04 <lennart> eval (App (Var "fix") f) = eval (App f (App (Var "fix") f))
14:07:49 <palomer> lennart: keep in mind that my evaluation is strict
14:07:57 <palomer> lennart: so that will probably always go into an infinite loop
14:07:58 <lennart> ugh
14:08:09 <lennart> yes, then you need to be careful
14:41:36 --- topic: '["Haskell is still the language of choice for discriminating hackers", "logs: http://tunes.org/~nef/logs/haskell/","http://www.haskell.org/learning.html","Haskell IDE: http://haskell.org/hawiki/hIDE","http://www.haskell.org/tmrwiki/IssueFive","We put the Funk in Funktion","http://sequence.complete.org/hwn/20051129","HCAR 11/2005: http://haskell.org/communities/","dons for Emperor !"]'
14:41:36 --- topic: set by boegel on [Wed Dec 21 07:13:18 2005]
14:41:36 --- names: list (clog Nomius_ ski cptchaos hugues23 ihope bigbabyjesusfoo carp Lokadin monochrom palomer poetix sylvan baskeboler mjl69 tennin JKnecht boro_ tic icb qnix_ der_eq_ ADEpt lisppaste2 ncalexan jips neurogeek defcon8 SyntaxNinja cparrott mkhl fabs _Codex pediddle CosmicRay kaol chucky sproingie kpreid_ masm PerlJam lennart svens jberg frederik_ Revision17 Jaen Pupeno arjanb reductor Beelsebob Oejet praseodym donghee araujo astrolabe Speck sethk)
14:41:36 --- names: list (Nioate SamB cognominal tismith da_Bobstopper Squall` takuan Trixsey|Laptop Twigathy neologism Philippa borism metaperl mauke cooz_ mornfall triplah Saulzar juhp Cale Nanar PupenoL JaffaCake ramkrsna kpk gaal ozone tessier zamez glasser kzm aleator Chilli ksandstr ValarQ audreyt wolverian wilx eno-away Khisanth scw psnl cmeme resiak wli tewk cbus ibid sieni lambdabot cjs__ integral tuomov cpatrick kolmodin emu pejo Matt-W dcoutts_ jlouis)
14:41:36 --- names: list (seafood alch` Heffalump tumm rep WillKW norpan Spark xerox cods lispy ricebowl flux__ ulfdoz Lemmih gzl tic|school tromp_ eivuokko moonlite magagr Igloo samx thedward dons Wallbrak1r kosmikus Korollary nik_ jp-autark arguile mattam AtnNn skylan eyck drbean noj stesch kala__ boegel C-Keen earthy Iome dany2k Lunar^ johs musasabi cmm Lor djw spamsch)
14:42:42 <boro_> Heffalump, can't you just tell me, so i can move on?:P
14:43:06 <lennart> @pl \ f g h x -> f (g x) (h x)
14:43:07 <lambdabot> liftM2
14:43:30 <palomer> lennart: where can I read about unification wrt type inference?
14:43:33 <lennart> wow, Monad (e ->) never ceases to amaze me :)
14:43:35 <palomer> (I've never done it)
14:44:01 <palomer> lennart: that kind of looks like K
14:44:10 <lennart> palomer: luca cardelli has some old papers about type checking that I seem to remember being pretty good
14:44:17 <Heffalump> (k (+1)) 4 ((k 2) 4) = k (+1) 4 ((k 2) 4) -> (+1) ((k 2) 4)
14:44:24 <palomer> lennart: does it describe the unification algorithm?
14:44:36 <Philippa> it includes source code in modula 2
14:44:53 <Philippa> (which isn't that hard to read once you figure out the syntax for pass-by-reference)
14:45:01 <lennart> yes.  but from a rather imperative perspective, i seem to remember
14:45:40 <lennart> @pl \ f g h x -> f (g x) h
14:45:41 <lambdabot> (flip .) . (.)
14:45:42 <palomer> oh wait, it looks like S
14:45:48 <Philippa> the source isn't as heavily imperative as you might think though - it uses mutable variables for unification, but you're only going to implement those another way anyway
14:46:11 <Philippa> any other assignment's just a language artifact
14:46:13 <boro_> Heffalump, thanks :)
14:46:25 <palomer> Philippa: hrm, is it possible to get a monadic implementation of unification wrt type inference?
14:46:37 <lennart> hmmm, so Haskell has S', but not B'
14:46:48 <Philippa> palomer: yep. Wrap the ST monad
14:47:02 * palomer has never seen the ST monad before
14:47:13 <Philippa> it supplies references ala ML
14:47:52 <Philippa> that is, you initialise the cell they refer to with a value, and can then get and set said cell's value
14:48:03 <palomer> oh ,very cool
14:48:12 <palomer> is there any cool tutorial on this?
14:48:22 <Philippa> (you could equivalently tow a map from variable id to value around)
14:48:34 <Philippa> nope, it's pretty easy to use just from the docs though
14:53:07 <monochrom> http://www.cs.toronto.edu/~trebla/Shuffle.hs is an example of using ST and STArray.
14:53:14 <palomer> Philippa: tutorial in unification
14:53:47 <palomer> s/in/on
14:53:53 <ski> @type \f g h x -> f (g x) (h x)
14:53:55 <lambdabot> forall t t1 t2 t3.
14:53:55 <lambdabot> (t -> t1 -> t3) -> (t2 -> t) -> (t2 -> t1) -> t2 -> t3
14:54:02 <ski> @type let ap = Control.Monad.ap in \f g h x -> (return f `ap` g `ap` h) x
14:54:03 <lambdabot> forall a a1 b t.
14:54:03 <lambdabot> (Monad ((->) t)) =>
14:54:03 <lambdabot> (a -> a1 -> b) -> (t -> a) -> (t -> a1) -> t -> b
14:54:39 <palomer> someone wrote a turing complete language with just 2 symbols!
14:54:57 <monochrom> I wrote one.
14:55:07 <lennart> palomer: why 2, when you can do it with one?
14:55:07 <monochrom> Err, I wrote one with just 1 symbol.
14:55:13 <ncalexan> monochrom: given your name...
14:55:27 <palomer> lennart: what language is this?
14:55:34 <monochrom> I didn't write one.  Someone did, and I use it all the time.
14:56:03 <lennart> palomer: one symbol is all you need to express any number.  and you can code anything as a number
14:56:11 <alar> are there functions in Prelude similar to round?
14:56:31 <palomer> good point
14:56:34 <lennart> @djinn (t -> t1 -> t3) -> (t2 -> t) -> (t2 -> t1) -> t2 -> t3
14:56:34 <lambdabot> f a b c d = a (b d) (c d)
14:57:15 <palomer> pfft, I can do better than djinn
14:57:17 <Cale> @type round
14:57:18 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
14:57:21 <Cale> @type floor
14:57:23 <palomer> someone give me a type and I'll find an inhabitant
14:57:23 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
14:57:24 <palomer> go!
14:57:27 <Cale> @type ceiling
14:57:28 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
14:57:31 <alar> thanks!
14:57:45 <ski> palomer : ((a -> b) -> a) -> a
14:57:47 <lennart> palomer: I suspect you'll cheat
14:58:09 <monochrom> haha
14:58:24 <alar> @karma+ Cale
14:58:26 <lambdabot> Cale's karma raised to 6.
14:59:13 <palomer> ski: undefined
14:59:13 <monochrom> has palomer fell into an infinite loop?
14:59:43 <palomer> > undefined ((a -> b) -> a) -> a
14:59:44 <lambdabot>  parse error on input `->'
14:59:51 <palomer> > undefined::((a -> b) -> a) -> a
14:59:52 <lambdabot>  add an instance declaration for (Show (((a -> b) -> a) -> a))
14:59:59 <palomer> @type undefined::((a -> b) -> a) -> a
15:00:00 <monochrom> haha
15:00:01 <lambdabot> forall a b. ((a -> b) -> a) -> a
15:00:21 <palomer> showing that Pierce's law isn't inhabited is very easy with a little semantics
15:00:30 * ski thinks that qualifies as cheating :)
15:00:43 <lennart> palomer: so does all your programs look like 'main=undefined' ?
15:00:50 <palomer> lennart: yup
15:00:51 <ski> @djinn ((a -> b) -> a) -> a
15:00:52 <lambdabot> -- f cannot be realized.
15:01:06 <palomer> is finding a non bottom term for a type decidable?
15:01:27 <lennart> palomer: in what type system?
15:01:59 <palomer> lennart: say, HM(X)
15:02:14 <palomer> or simply typed lambda calculus + recursion
15:03:52 <lennart> palomer: no, i can't imagine it would be
15:04:02 <lennart> it sounds like the halting problem
15:04:18 <palomer> how so?
15:05:06 <_Codex> isnt it just 1-->A arrow?
15:05:11 <lennart> once you add recursion, how will you know if your term is bottom or not?
15:05:55 <palomer> lennart: I don't see your argument
15:06:52 <_Codex> sounds like something that needs strong normalisation..
15:06:56 <ihope> Is there a way to access a particular class instance's definition of something?
15:07:49 <lennart> palomer: just a gut feel.  once you ad recursion very few things are deciable :)
15:08:20 <palomer> hrmph, term synthesis should be decidable!
15:08:35 <ihope> If the only recursion you have is things evaluating to themselves, then it's all decidable...
15:08:54 <palomer> what's this about structural recursion?
15:09:49 <lennart> palomer: first, you'll have to be more specific in your problem statement.  you say non-bottom.  does that mean not equal to bottom?  or that bottom must not occur anywhere in value?
15:11:30 <lennart> e.g., \ x -> undefined has type ((a->b)->a)->a and is non-bottom
15:11:47 <palomer> bottom must not appear anywhere
15:13:51 <lennart> palomer: well, I don't know the answer, but I have a strong feeling that it's undecidable
15:14:00 <alar> @type trace
15:14:01 <lambdabot> Not in scope: `trace'
15:14:08 <alar> @type debug
15:14:09 <lambdabot> Not in scope: `debug'
15:14:15 <alar> @index trace
15:14:16 <lambdabot> Debug.Trace
15:14:21 <lennart> @type Debug.Trace.trace
15:14:22 <lambdabot> forall a. String -> a -> a
15:14:47 <alar> it emits string message and continues?
15:14:52 <lennart> yes
15:18:05 <lennart> palomer: here's my informal argument: when you build a term and you can use fix you can get terms with bottom in them.  how will you know?  checking if a term is bottom or not is the halting problem.
15:19:47 <palomer> lennart: yeah, checking that the term my synthesizer evaluates to is bottom is the halting problem
15:20:10 <palomer> lennart: I don't see how this would imply that generating non bottom terms is impossible
15:20:42 <lennart> no, it might not be.  but i doubt it
15:23:32 <lennart> terminating programs are not recursively enumerable in general, but they might be in some very restricted setting, and then it could work
15:24:15 <palomer> terminating programs are recursively enumerable!
15:26:10 <lennart> they are?
15:27:11 <lennart> hmmm, yes, i was thinking of something stronger, but what's it called...
15:29:32 <lennart> palomer: anyway, take it as an excerise to prove or disprove :)
15:29:46 <palomer> that program synthesis is decidable?
15:30:45 <lennart> in simply typed lambda calculus + fix
15:32:42 * palomer wonders how long it took them to prove that ((a->b)->a)->a was inhabited
15:33:47 <lennart> And who are "they"?
15:34:17 <Speck> lennart: I could tell you, but I'd have to kill you.
15:34:19 <lennart> besides, I don't think it's inhabited :)
15:34:31 <Heffalump> @djinn ((a->b)->a)->a
15:34:33 <lambdabot> -- f cannot be realized.
15:35:07 <lennart> @djinn Not(Not(((a->b)->a)->a))
15:35:08 <lambdabot> f a =
15:35:08 <lambdabot>   void (a (\ b -> void (a (\ _ -> b (\ c -> void (a (\ _ -> c)))))))
15:36:17 <palomer> what's Not?
15:36:20 <Philippa> all you can return for it's undefined because you never get given an a as a parameter
15:37:00 <palomer> eh?
15:37:29 <Philippa> look at the type
15:37:48 <Philippa> it's not a -> (b -> (a -> a))...
15:37:52 <lennart> @djinn-env
15:37:53 <lambdabot> data () = ()
15:37:53 <lambdabot> data Either a b = Left a | Right b
15:37:53 <lambdabot> data Maybe a = Nothing | Just a
15:37:53 <lambdabot> data Bool = False | True
15:37:53 <lambdabot> data Void
15:37:55 <lambdabot> type Not x = x -> Void
15:37:57 <lambdabot> type Cont r a = (a -> r) -> r
15:38:38 <Heffalump> I'm confusing myself about which of (((a -> a) -> a) -> a) and (((a -> b) -> a) -> a) is more general.
15:38:38 <lennart> Not is logical negation
15:38:51 <Philippa> palomer: it's a function that takes a function as a parm and returns an a. Furthermore, it can't use the function in question to generate an a. So the only a it could possibly return is undefined
15:39:20 <lennart> Philippa: but with time travel you can implement it
15:39:29 <lennart> which is what Scheme does
15:39:34 <Heffalump> @type \f -> f id
15:39:35 <lambdabot> forall a t. ((a -> a) -> t) -> t
15:40:18 <Philippa> lennart: you've seen my standard example of why we can't just use functions of type World -> World for IO? :-)
15:40:49 <Heffalump> because of fix?
15:40:54 <lennart> Philippa: ummm, no, I don't think I have
15:40:54 <palomer> doesn't Not return Void?
15:41:14 <Philippa> lennart: a hypothetical function I refer to as winLottery. It does time travel :-)
15:41:19 <lennart> Not x is a function from x to Void
15:41:43 <lennart> Philippa: sounds good to me!
15:42:45 <palomer> Philippa: show us how winLottery works
15:43:26 <Heffalump> type IO a = RealWorld -> (a, RealWorld)
15:44:12 <Philippa> palomer: it doesn't, that's the point :-) It creates a future, grabs next week's lottery numbers from it and then uses them in a second future in which we actually buy a ticket - that being the future it returns
15:44:28 <Philippa> if you can find a computer that can actually implement that, we're in trouble
15:44:41 <Heffalump> winLottery beforelottery = let (lotteryresult, afterlottery) = lotterydraw beforelottery in playlottery (lotteryresult, beforelottery)
15:45:04 <Heffalump> the point is that RealWorld has to be single-threaded. You can't fork it.
15:45:23 <Heffalump> the IO monad guarantees that by not exposing RealWorld itself, just a correctly written >>= operation
15:45:50 <Heffalump> so you can implement IO as functions from RealWorld -> RealWorld, as long as you encapsulate it correctly
15:49:02 <lennart> I wonder if I could refine that argument to make classical logic look impossible
15:50:15 <SamB> Heffalump: you mean RealWorld -> (RealWorld, a)
15:50:37 <Philippa> BFD :-)
15:50:40 <Heffalump> no, I meant what I said.
15:50:48 <Heffalump> it's certainly consistent with the definition I gave
15:51:11 * palomer would like to see sane interpretations of lambda-mu
15:51:20 <SamB> also, you definately need a newtype
15:51:38 <palomer> once you have the fixed point operator, can you get a non bottom value of type ((a->b)->a)->a?
15:52:15 <Heffalump> palomer: I don't think you need a fixed point operator.
15:52:42 <palomer> Heffalump: I'm starting with simply typed lambda calculus
15:53:07 <Heffalump> actually, I'm just confused, ignore me.
15:53:19 <ski> (pierce's law duplicates the continuation)
15:53:25 <lennart> palomer: it would be surprising if fix gave you Peirce law
15:54:41 <palomer> ski: could you elaborate on that?
15:54:46 <lennart> but who knows, fix is powerful
15:55:33 <ski> \f. mu k. [k] (f (\x. mu k'. [k] x))
15:55:49 <ski> (iir your syntax correctly)
15:57:06 <palomer> that looks like call/cc
15:57:25 <lennart> well, it is the type of call/cc after all
15:57:37 <palomer> (I'm not saying that because I understand call/cc, I'm saying it because I have a vague memory of the syntactic representation of call/cc)
15:57:54 <palomer> ski: how does that split the continuation?
15:58:17 <ihope> Just what IS call/cc in a referentially transparent language
15:58:27 <lennart> time travel
15:59:19 <lennart> I think Either a (Not a) better to illustrate the time travel
15:59:25 <ski> palomer : no split .. duplicate
15:59:38 <ihope> @index Void
15:59:38 <ski> ihope : answer is 'no'
15:59:39 <lambdabot> bzzt
16:00:09 <lennart> Haskell doesn't have Void anymore
16:00:13 <ski> lennart : i've implemented that in SML/NJ :)
16:00:15 <ihope> ski: not "monad" or "arrow"?
16:00:16 <lennart> it's the empty type
16:00:24 <ihope> Like ()?
16:00:30 <ski> no
16:00:31 <lennart> No, empty
16:00:36 <lennart> no constructors
16:00:42 <lennart> (well, there's always bottom)
16:00:44 <ihope> Ah
16:01:05 <ski> palomer : 'k' there above is the continuation, and it's used twice
16:01:17 <palomer> oh, righto
16:01:23 <palomer> can you explain me how that's call/cc though?
16:01:29 <lennart> ski: yeah, you can implement call/cc, but it's a form of time travel
16:01:52 <ski> (lennart : was referring to 'excluded middle')
16:02:03 <palomer> how is call/cc a form of time travel?
16:02:21 <ski> you can jump back
16:02:21 <lennart> sure, excluded middle isn't hard to make when you have call/cc :)
16:02:42 <ski> lennart : right .. but still fun
16:02:43 <Nanar> can someone enlight me in 2 words, what is Monad ?
16:02:47 <lennart> palomer: you can return from the same function more than once
16:02:54 <ihope> Monads are.
16:02:59 <ski> Nanar : effectful computation
16:03:12 <palomer> true
16:03:21 <Nanar> ihope: :)
16:03:33 <ski> you can implement argfc
16:03:43 <lennart> argfc?
16:03:52 <palomer> so wait...classical logic is intimately related to quantum mechanics?
16:03:56 <ihope> In more words: Monads are things that describe how to have a value exist, how to have it not exist, how to access it, and what happens when it's accessed.
16:04:18 <palomer> Nanar: Monad is a typeclass
16:04:19 <ski> argfc is the 'function' that, when called, always returns the argument from it's *first* call
16:04:24 <lennart> palomer: ummm, I don't think it's very related
16:04:42 <palomer> but it has time travel
16:04:48 <lscd> I'm new to haskell, and going through YAHT; section 4.5, especially the use of Either, is really confusing me.  Could anyone point to another explanation of Either [what, exactly, it is, how/when/why to use it, etc?]
16:04:49 <ihope> argfc, call/cc...
16:05:07 <SamB> ski: um.
16:05:13 <SamB> that sounds horrid
16:05:15 <ski> argfc = callCC (\k. \x. throw k (\y. x))
16:05:27 <SamB> I would never want to do that. Ever.
16:05:38 <SamB> Except maybe in C!.
16:05:54 <ihope> An Either value is pretty much something with one of two types.
16:05:55 <Nanar> monad is standard in all haskell compiler ?
16:05:56 <ski> (map id [10..15] = [10,10,10,10,10]  (assuming left-to-right))
16:06:01 <ski> Nanar : yes
16:06:12 <Nanar> ok ok many thanks
16:06:19 <ihope> Every "Left" value has the same type as any "Right" value...
16:06:37 <ihope> So you can have a function return one of two types.
16:06:45 <ski> SamB : nobody's said that argfc is particulary useful :)
16:06:55 <lennart> ski: weird!
16:06:57 <ski> palomer : QM ?
16:07:22 <ski> the point of argcf, is that one can get some state-like behaviour, without state
16:07:32 <ski> (using continuations)
16:07:49 <ihope> Oh right. What's a good monad for implementing call/cc?
16:08:02 <lennart> the continuation monad
16:08:03 <ihope> I'll need it for this Unlambda interpreter.
16:08:13 <ski> @index callCC
16:08:14 <lambdabot> Control.Monad.Cont
16:08:28 <palomer> someone write an undeciferable program that returns "where's my tea" 
16:08:34 <lennart> @type Control.Monad.Cont.callCC
16:08:36 <lambdabot> forall (m :: * -> *) a b.
16:08:36 <lambdabot> (Control.Monad.Cont.MonadCont m) =>
16:08:36 <lambdabot> ((a -> m b) -> m a) -> m a
16:08:50 <lscd> ihope: hm.. the example in the tutorial defines [1-4]tuples, with Tuple a b c d = One a | Two a b, etc, and then poses the exercise of converting a Tuple to a haskell tuple, and says as a hint to use Either; would I redefine Tuple using either to do that? [I looked at the solution, and it uses Right and Left quite a lot, but doesn't redefine Tuple, so I'm not sure if I'm on the right track with it]
16:09:28 <ski> palomer : there are people doing work with relations with linear logic and quantum mechanics, though :)
16:09:30 <lennart> @djinn ((a -> Cont r b)->Cont r a)->Cont r a
16:09:31 <lambdabot> f a b = a (\ c _ -> b c) b
16:10:05 <ski> (classical linear logic, or variants, of course)
16:10:10 <ihope> lscd: tricky one. Just use something like Either a (Either b (Either c d)) for one of a, b, c or d.
16:10:38 <ncalexan> lscd: you can read ihope's solution as:
16:10:41 <lscd> ihope: hm, wouldn't it be possible to do it using two Eithers?
16:10:55 <ncalexan> A tuple with at most four components... oh, you've definitely gotten it :)
16:10:59 <ihope> I don't think so. Each Either adds one type to the jumble.
16:11:12 <ski> a + a * b + a * b * c + a * b * c * d
16:11:14 <lscd> ihope: hm, nested ones?
16:11:18 <ski> now factor that :)
16:12:10 <palomer> someone give me functions on lists that have easy left/right inverses
16:12:20 <ski> reverse
16:12:21 <ihope> lscd: I don't think you can use only two Eithers.
16:12:24 <ncalexan> revers.e
16:12:32 <palomer> well, reverse is the easy one
16:12:34 <palomer> any others?
16:12:38 <ncalexan> map id
16:12:43 <palomer> >:O
16:12:50 <ihope> I wrote one called "munge"...
16:12:55 <ncalexan> rotations will do too.
16:12:59 <lennart> any permutation
16:13:00 <palomer> ihope: do you have it?
16:13:15 <palomer> I want to invite a girl out for tea in haskell
16:13:19 <palomer> but I don't want to make it obvious
16:13:32 <ihope> palomer: just a sec
16:13:48 <ncalexan> rot13 if your list is [Char] :)
16:14:03 <ski> swap first two elem, then next two, etc
16:14:22 <SamB> ncalexan: what if she can read ROT13?
16:14:26 <lennart> > map succ "Hello world"
16:14:27 <lambdabot> "Ifmmp!xpsme"
16:14:42 <lennart> > map pred "Ifmmp!xpsme"
16:14:43 <lambdabot> "Hello world"
16:14:52 <palomer> what's the definition of successor?
16:14:58 <ski> @type succ
16:15:00 <lambdabot> forall a. (Enum a) => a -> a
16:15:05 <palomer> Char is an Enum?
16:15:08 <palomer> > 'a' + 1
16:15:09 <lambdabot>  add an instance declaration for (Num Char)
16:15:14 <ski> > succ 'a'
16:15:16 <lambdabot> 'b'
16:15:22 <Heffalump> > pred '\0'
16:15:24 <lambdabot> Exception: Prelude.Enum.Char.pred: bad argument
16:15:27 <ski> > ['a'..'g']
16:15:29 <lambdabot> "abcdefg"
16:15:34 <palomer> pred 'a'
16:15:40 <palomer> > pred 'a'
16:15:41 <lambdabot> '`'
16:16:40 <ihope> munge = \x -> case x of {[x] -> [x]; xs -> (snap . munge_ . splat) xs} where {snap (xs,ys) = xs ++ ys; munge_ (xs,ys) = (munge xs, munge ys); splat = \x -> case x of {[x,y] -> ([x],[y]); (x1:x2:xs) -> x1 : (fst . splat) xs, x2 : (snd . splat) xs}}
16:16:47 <ihope> (I think)
16:17:20 <lennart> gah!
16:17:35 <palomer> hah!
16:17:37 <palomer> what's the inverse?
16:17:51 <ihope> The inverse of munge is munge...
16:18:33 <lscd> ihope: sorry, my connection half-died; could you show me the exact definition you'd use? The ones I'm trying are making progressively less sense
16:18:48 <palomer> let munge = \x -> case x of {[x] -> [x]; xs -> (snap . munge_ . splat) xs} where {snap (xs,ys) = xs ++ ys; munge_ (xs,ys) = (munge xs, munge ys); splat = \x -> case x of {[x,y] -> ([x],[y]); (x1:x2:xs) -> x1 : (fst . splat) xs, x2 : (snd . splat) xs}} in munge $ munge "hah"
16:18:56 <palomer> > let munge = \x -> case x of {[x] -> [x]; xs -> (snap . munge_ . splat) xs} where {snap (xs,ys) = xs ++ ys; munge_ (xs,ys) = (munge xs, munge ys); splat = \x -> case x of {[x,y] -> ([x],[y]); (x1:x2:xs) -> x1 : (fst . splat) xs, x2 : (snd . splat) xs}} in munge $ munge "hah"
16:18:57 <lambdabot>  parse error on input `,'
16:19:05 <palomer> doesn't parse:/
16:19:05 <ski> missing parens in the tuple, i think
16:19:28 <ihope> lscd: Tuple a b c d = Either a (Either (a,b) (Either (a,b,c) (a,b,c,d)))
16:20:41 <ihope> Put parentheses around x1 : (fst . splat) xs, x2 : (snd . splat) xs
16:21:20 <palomer> > let munge = \x -> case x of {[x] -> [x]; xs -> (snap . munge_ . splat) xs} where {snap (xs,ys) = xs ++ ys; munge_ (xs,ys) = (munge xs, munge ys); splat = \x -> case x of {[x,y] -> ([x],[y]); (x1:x2:xs) -> (x1 : (fst . splat) xs, x2 : (snd . splat) xs)}} in munge $ munge "hah"
16:21:21 <lambdabot>  Non-exhaustive patterns in case
16:21:37 <ihope> It only works on lists with lengths that are powers of two.
16:21:41 <palomer> @hoogle pred
16:21:42 <lambdabot> Prelude.pred :: Enum a => a -> a
16:21:42 <lambdabot> Data.Graph.Inductive.Internal.FiniteMap.predFM :: Ord a => FiniteMap a b -
16:21:42 <lambdabot> > a -> Maybe (a, b)
16:21:42 <lambdabot> Test.HUnit.Base.AssertionPredicate :: IO Bool
16:21:46 <ihope> > let munge = \x -> case x of {[x] -> [x]; xs -> (snap . munge_ . splat) xs} where {snap (xs,ys) = xs ++ ys; munge_ (xs,ys) = (munge xs, munge ys); splat = \x -> case x of {[x,y] -> ([x],[y]); (x1:x2:xs) -> (x1 : (fst . splat) xs, x2 : (snd . splat) xs)}} in munge $ munge "hah\NUL"
16:21:48 <lambdabot> "hah\NUL"
16:22:37 <palomer> > "a\nb"
16:22:39 <lambdabot> "a\nb"
16:24:13 <ski> > let munge [x] = [x]; munge xs = (snap . munge_ . splat) xs where {snap = uncurry (++); munge_ (xs,ys) = (munge xs, munge ys); splat [] = ([],[]); splat (x:xs) = (x:zs,ys) where (ys,zs) = splat xs} in munge . munge $ "abc"> let munge [x] = [x]; munge xs = (snap . munge_ . splat) xs where {snap = uncurry (++); munge_ (xs,ys) = (munge xs, munge ys); splat [] = ([],[]); splat (x:xs) = (x:zs,ys) where (ys,zs) = splat xs} in munge . munge $ "abc"
16:24:15 <lambdabot> Couldn't match `[a]' against `Bool'
16:24:21 <ihope> > let munge = \x -> case x of {[x] -> [x]; xs -> (snap . munge_ . splat) xs} where {snap (xs,ys) = xs ++ ys; munge_ (xs,ys) = (munge xs, munge ys); splat = \x -> case x of {[x,y] -> ([x],[y]); (x1:x2:xs) -> (x1 : (fst . splat) xs, x2 : (snd . splat) xs)}} in munge $ munge "This thing's a test of length 32"
16:24:23 <lambdabot> "This thing's a test of length 32"
16:24:38 <ski> > let munge [x] = [x]; munge xs = (snap . munge_ . splat) xs where {snap = uncurry (++); munge_ (xs,ys) = (munge xs, munge ys); splat [] = ([],[]); splat (x:xs) = (x:zs,ys) where (ys,zs) = splat xs} in munge . munge $ "abc"
16:24:40 <lambdabot> "abc"
16:25:00 <ski> (shouldn't paste two things at same time :)
16:25:13 <ihope> :-)
16:25:20 <dons> Moin
16:25:53 <palomer> ski: updated munge?
16:25:57 <ihope> > let munge [x] = [x]; munge xs = (snap . munge_ . splat) xs where {snap = uncurry (++); munge_ (xs,ys) = (munge xs, munge ys); splat [] = ([],[]); splat (x:xs) = (x:zs,ys) where (ys,zs) = splat xs} in munge . munge $ "This test contains exactly 40 characters"
16:25:58 <lambdabot> "Ternylsh tn4aietis saoc0t trc tscaaxh ec"
16:26:21 <ski> palomer : shortened, somewhat
16:26:28 <lscd> ihope: hm; on the good side, that's valid haskell, on the bad side, it doesn't define any of the constructors the other definition defined, so (unsurprisingly) the sample solution code absolutely can't work with it; fwiw, the first definition is fromTuple (One a) = Left (Left a).  Would you mind explaining to me how I work with the nested eithers you showed me (I'm having trouble even constructing a Tuple with that definition), or a d
16:27:22 <ihope> Let's see here...
16:27:43 <ski> Tuple a b c d = (a,Either () (b,Either () (c,Either () d)))
16:28:05 <ihope> The constructors would be Left, (Right . Left), (Right . Right . Left), (Right . Right . Right . Left), I think
16:28:48 <ski> (or even 'Tuple a b c d = (a,Maybe (b,Maybe (c,Maybe d)))')
16:29:10 <ihope> @pretty . arr
16:29:11 <lambdabot> "Parse error" at column 1
16:29:16 <ihope> @. pretty arr
16:29:17 <lambdabot> "Parse error" at column -17
16:29:30 <ihope> Heh
16:29:34 <ihope> @pretty Tuple a b c d = (a,Maybe (b,Maybe (c,Maybe d)))
16:29:35 <lambdabot>  Tuple a b c d = (a, Maybe (b, Maybe (c, Maybe d)))
16:29:58 <ski> unpretty
16:30:06 <lscd> ski: hm.. and if I wanted to define Tuple to be One a, Two a b, Three a b c, or Four a b c d, how would I? [this seems ugly, otoh, it's what the tutorial is showing, so hopefully it would end up making sense :/]
16:30:27 <lscd> [using Either]
16:30:33 <palomer> main = let munge [x] = [x]; munge xs = (snap . munge_ . splat) xs where {snap = uncurry (++); munge_ (xs,ys) = (munge xs, munge ys); splat [] = ([],[]); splat (x:xs) = (x:zs,ys) where (ys,zs) = splat xs} in munge . munge $ "This test contains exactly 40 characters" in print (munge "There once was a man nammed brie\nWho managed to live in a tree\nThough hot water he hadn't\nAnd boiling he wouldn't\nHe always managed to drink tea")
16:30:38 <ski> lscd : either of my or ihope's versions would do
16:30:47 <palomer> for some reason, ghc doesn't like that 
16:31:15 <palomer> parse error at in
16:31:16 <ski> palomer : you have two 'in'
16:31:17 <lscd> ski: those accept the right types, but have different names for the constructors, as far as i can tell?
16:31:22 <ihope> Either a (Either (a,b) (Either (a,b,c) (a,b,c,d)))
16:31:46 <ski> lscd : yes
16:32:11 <ihope> one = Left; two = Right . Left; three = Right . Right . Left; four = Right . Right . Right . Left
16:32:22 <ihope> (You know how function composition works?)
16:32:23 <ski> lscd : ihope's is basically 'a + a * b + a * b * c + a * b * c * d' .. while mine is 'a * (1 + b * (1 + c * (1 + d)))'
16:32:30 <lscd> ski: my question is, if I wanted to preserve the constructor naming, how would I define it?  Short of adding a definition that One = Left, etc
16:32:39 <palomer> oh, nevermind
16:32:59 <palomer> > let munge [x] = [x]; munge xs = (snap . munge_ . splat) xs where {snap = uncurry (++); munge_ (xs,ys) = (munge xs, munge ys); splat [] = ([],[]); splat (x:xs) = (x:zs,ys) where (ys,zs) = splat xs} in print $ munge . munge $ "There once was a man nammed brie\nWho managed to live in a tree\nThough hot water he hadn't\nAnd boiling he wouldn't\nHe always managed to drink tea"
16:33:00 <lambdabot> No IO allowed
16:33:16 <palomer> > let munge [x] = [x]; munge xs = (snap . munge_ . splat) xs where {snap = uncurry (++); munge_ (xs,ys) = (munge xs, munge ys); splat [] = ([],[]); splat (x:xs) = (x:zs,ys) where (ys,zs) = splat xs} in munge . munge $ "There once was a man nammed brie\nWho managed to live in a tree\nThough hot water he hadn't\nAnd boiling he wouldn't\nHe always managed to drink tea"
16:33:18 <lambdabot> "Toebda\nentahira hdi'iethgteaelHr  nrheoeaeidhr o e  h hw\nutgeokmTeng
16:33:18 <lambdabot> lngnrdiaeonc ea  yau  bde wsw om  tmn \nmnmst Aet'Wvaaoanlanhd \n
16:33:18 <lambdabot> ataiwoln d"
16:33:25 <palomer> eh?
16:33:43 <Nanar> any ptr to doc about Either ?
16:33:47 <ihope> Preserve the constructor naming...
16:33:49 <ski> lscd : you can't reduplicate same behaviour with constructors (since haskell doesn't have 'views') .. you can define functions like ihope showed, which you can use to construct such values .. but those can't be used for matching
16:34:03 <ihope> Just where is this tutorial?
16:34:26 <Nanar> I googled but doc I found didn't explain :\
16:34:52 <ski> Nanar : 'Either' is used when you want to return one of two possible things .. like an error message/code or a result .. or a double or an int, etc
16:35:04 * palomer wonders about the period of munge
16:35:38 <lscd> http://www.isi.edu/~hdaume/htut/
16:35:59 <palomer> lscd: eh?
16:36:01 <ski> palomer : s/tree/trie/ :) (to make it rhyme)
16:36:05 <palomer> oh, I thought that was directed to me
16:36:20 <palomer> brie is pronounced like tree
16:36:28 <ski> yes, but not textually
16:36:39 <Nanar> ski: somthing like if not a then b ?
16:37:01 <palomer> limericks don't have to be textual
16:37:16 <ihope> Nanar: pretty much.
16:37:21 <Nanar> ski: ah ok can be a or b
16:37:23 <ski> (of course not .. just it could be considered to be nicer, here)
16:37:26 <lscd> ihope: i'm using the pdf version; the thing I'm asking about is exercise 4.7, page 61
16:37:36 <ihope> Okay.
16:38:16 <ski> @type  let foo x = if even x then Left (show x) else fromIntegral x :: Double in foo
16:38:17 <lambdabot>   Couldn't match `Either String b' against `Double'
16:38:17 <lambdabot>   Expected type: Either String b
16:38:23 <lscd> ski: yet another dumb question: what are views?
16:38:26 <ski> @type  let foo x = if even x then Left (show x) else Right (fromIntegral x :: Double) in foo
16:38:28 <ski> :9
16:38:28 <lambdabot> forall a. (Integral a) => a -> Either String Double
16:38:49 <ski> > let foo x = if even x then Left (show x) else Right (fromIntegral x :: Double) in map foo [8..12]
16:38:51 <lambdabot> [Left "8",Right 9.0,Left "10",Right 11.0,Left "12"]
16:39:04 <lennart> palomer: I have a new theory about simply typed lambda calculus + fix:  nothing happens when you add fix, the same types are inhabited.  This conjecture is equally unsubstantiated.  Good night!
16:39:30 <palomer> lennart: hah
16:39:35 <palomer> it's false
16:39:42 <ski> lscd : 'views' was a proposal to be able to define "constructors", that actually aren't constructors in the implementations, but you could use them like that (i.e. pattern-match on them) outside the implementation
16:39:45 <lennart> example?
16:39:57 <palomer> (a->a)->a
16:40:22 <lennart> ok, i'll give you that one
16:40:28 <ihope> Aha, I see.
16:40:29 <palomer> and you can build tons from there
16:40:32 <lscd> ski: ahh; what's good/bad about that?
16:40:44 <lennart> hmmm
16:40:56 <lennart> now you have to prove to me that it's non-bottom
16:41:06 <palomer> (a->a)->a is the type of fix
16:41:22 <ihope> func (One a) = Left a
16:41:25 <lennart> sure, but you're not allowed to produce terms that contain bottom
16:41:33 <ski> lscd : good is that this would allow combining abstract datatypes with pattern-matching .. bad is that there was some problems with referential transparency (iirc)
16:41:34 <ihope> func (Two a b) = (Right . Left) (a,b)
16:41:51 <ihope> func (Three a b c) = (Right . Right . Left) (a,b,c)
16:41:58 <lscd> ski: ahh, the latter would make it a non-starter in haskell, ya?
16:42:11 <ihope> func (Four a b c d) = (Right . Right . Right . Left) (a,b,c,d)
16:42:17 <ski> lscd : there are some workarounds iirc
16:42:23 <lennart> palomer: and fix id is bottom
16:42:28 <ski> lscd : but, it was never implemented, i think
16:42:31 <lennart> so fix is not a total function
16:43:09 <ski> http://haskell.org/hawiki/Views
16:43:10 <SamB> > fix id
16:43:11 <lambdabot> Add a type signature
16:43:13 <ihope> A function I rather like is (fix const)
16:43:16 <SamB> > fix id :: ()
16:43:16 <ihope> > fix const
16:43:17 <lambdabot> Exception: <<loop>>
16:43:18 <lambdabot>   Occurs check: cannot construct the infinite type: t = b -> t
16:43:18 <lambdabot>   Expected type: (b -> t) -> b -> t
16:43:18 <lambdabot>   Inferred type: (b -> t) -> b -> b -> t
16:43:29 <ihope> :-P
16:43:49 <lennart> fix const is the always hungry function
16:43:59 <palomer> @type fix const
16:43:59 <ihope> Yep.
16:44:00 <lambdabot> Not in scope: `fix'
16:44:11 <palomer> @hoogle fix
16:44:12 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
16:44:12 <lambdabot> Graphics.UI.ObjectIO.StdIOCommon.Fix :: ItemLoc
16:44:12 <lambdabot> Control.Monad.ST.Lazy.fixST :: (a -> ST s a) -> ST s a
16:44:21 <palomer> @type Control,Monad.Fix.fix const
16:44:22 <lambdabot> parse error on input `,'
16:44:26 <palomer> @type Control.Monad.Fix.fix const
16:44:28 <lambdabot>   Occurs check: cannot construct the infinite type: t = b -> t
16:44:28 <lambdabot>   Expected type: (b -> t) -> b -> t
16:44:39 <ski> # fix const;;
16:44:39 <ski> - : '_b -> 'a as 'a = <fun>
16:45:03 <lennart> palomer: anyway, I stand by my conjecture
16:45:07 <palomer> hrm
16:45:09 <palomer> I'll think about it
16:45:14 <palomer> lennart: your modified conjecture:o
16:45:21 <lscd> ihope: when I put those 4 func lines in a source file, then try to load it, I get ERROR "./Tuple2.hs":6 - Undefined data constructor "One"
16:45:29 <lennart> my new one.  which is totally opposite of the old one
16:45:30 <ski> # fix const 12 13 14;;
16:45:31 <ski> - : int -> 'a as 'a = <fun>
16:45:51 <palomer> lennart: what's your new one? the set of inhabited types remains unchaned?
16:45:53 <palomer> unchanged
16:45:58 <ihope> lscd: make sure Tuple is in scope.
16:46:01 <lennart> oh no!  the ocaml lambdabot is here!
16:46:08 <lscd> ihope: ahh... oops, ok
16:46:10 <lennart> palomer: yes
16:46:13 <ski> ocaml *-rectypes* :)
16:46:29 <palomer> I don't see how callCC type could be done without fix
16:46:40 <lscd> ihope: it is, that didn't help 
16:46:49 <ski> I don't see how fix has anything to do with callCC, here
16:46:51 <palomer> @hoogle ((a->b) -> (a->b)) -> (a->b)
16:46:52 <lennart> i don't see how it can be done with fix
16:46:53 <lambdabot> No matches, try a more general search
16:47:07 <lscd> ihope: (I used your definition of Tuple though; I should probably use the one that uses One...Four instead?)
16:47:08 <palomer> what's the definition of callCC?
16:47:30 <lennart> @djinn ((a -> Cont r b)->Cont r a)->Cont r a
16:47:31 <lambdabot> f a b = a (\ c _ -> b c) b
16:47:38 <ihope> lscd: yes.
16:47:42 <palomer> oh, good point
16:47:53 <palomer> hrm, I'll have to think about it
16:47:56 <ski> callCC f = mu k. [k] (f (\x. mu k'. [k] x))
16:48:25 <palomer> ski: yeah, if haskell had lambda-mu!
16:48:30 <palomer> (that would rock)
16:48:59 <ihope> Wha's mu?
16:49:11 <palomer> the infinite lambda
16:49:15 <palomer> the lambda that never goes away
16:49:16 <ski> captures continuation
16:49:21 <ski> palomer : ?
16:49:36 <palomer> (I've heard it called the infinite lambda)
16:49:53 <ski> m-hm
16:50:34 <ski> (palomer : to have ref. transp. continuations, i think we must have linear type system)
16:50:34 <ihope> Okay. I'll go up to my room and go insane now.
16:51:45 <lscd> ihope: thanks for all the help
16:51:46 <palomer> ski: the type system for lambda-mu is classical logic
16:51:57 <ihope> 'Welcome
16:52:09 <ski> (palomer : yes .. so we need classical linear logic)
16:52:45 <palomer> classical linear logic is used to type Pi-Calculus, no?
16:53:10 <palomer> I have serious issues with classical sequents as type derivations
16:53:22 <lscd> next question: what is 'func'? it's not in the tutorial at all, and googling didn't yield any aanswers to that question [caveat: i haven't googled extensively, this connection keeps freezing for a minute or two at a time :/]
16:53:57 <ski> (palomer : re pi-calc, may possibly be)
16:54:08 <palomer> bbl!
16:54:25 <ski> lscd : i'd guess 'func' was just short for 'function'
16:54:56 <lscd> ski: ahh, ok, thanks
17:43:03 <Cale> dons: ?
17:45:07 <Cale> dons: A friend of mine and I were both wondering about the state of yi -- the curses version doesn't seem to build a dynamic binary or the library which it claims to install, and there were various other questions.
17:47:32 <dons> yep, there was a big refactor of the bulid system recently, and it just builds the static version atm.
17:47:50 <dons> it's trivial to add support for the dynamic version though. i'll do it soon.
17:48:17 <ncalexan> dons: can you talk a little about the two repos?
17:49:10 <ncalexan> Like, why are there two... which is freshest... where patches should go... etc.
17:49:14 <dons> one is a rewrite to support gtk, the other is a curses implementation.
17:49:25 <ncalexan> Is the curses impl out of date.
17:49:26 <ncalexan> ?
17:49:34 <dons> no.
17:49:41 <dons> why?
17:49:46 <ncalexan> So if I wanted to work on the curses, I should ... okay.
17:49:59 <Cale> Can't they be unified?
17:50:01 <dons> yes, and just send patches to me.
17:50:10 <dons> they could be Cale. but that's even more work
17:50:23 <Cale> hmm
17:50:54 <ncalexan> dons: how is this not going to lead into two editors?  If I want to add, say, read-only buffer support, I have to do it twice.
17:51:32 <dons> they're basically the same still, but the gtk version is super-alpha, and it's been easier to work on it separately.
17:52:54 <wchogg> This is a dumb question, but is Template Haskell still being actively developed?  The web page is dated 2003.
17:53:04 <ncalexan> So what is the road map?  Do you intend to merge the Gtk gui into the curses version, and I should continue looking at the curses code?
17:53:35 <ncalexan> Or maybe you'd prefer to chat later; you mentioned busy-ness :)
17:53:55 <dons> yeah, mail me the questions, I'll get back to you. 
17:54:01 <sproingie> blean.  is there any perl regex package for haskell that works?
17:54:16 <sproingie> Prelude Text.JRegex> print ("hellofooobarbobfoobarbad" =~ "fo*bar" :: Int)
17:54:16 <sproingie> Loading package JRegex-1.0 ... linking ... <interactive>: /usr/local/lib/JRegex-1.0/ghc-6.4/HSJRegex-1.0.o: unknown symbol `__stginit_Array_'
17:57:47 <sproingie> i fought the linker and the linker won
17:58:13 <sproingie> thought i'd get away from this nonsense when i ditched C++
17:58:22 <Lemmih> wchogg: I think its only being maintained now.
17:59:24 <SamB> sproingie: I think it forgot to depend on the antiquated package for Haskell 98 programs...
18:00:00 <sproingie> oy ... how do i add it?
18:00:44 <SamB> hmm
18:01:17 <SamB> :set -package haskell98?
18:03:11 <sproingie> same error
18:03:55 <sproingie> oh wait, now the error's different
18:04:25 <SamB> whats the error now?
18:04:27 <sproingie> Loading package JRegex-1.0 ... linking ... <interactive>: /usr/local/lib/JRegex-1.0/ghc-6.4/HSJRegex-1.0.o: unknown symbol `pcre_version'
18:04:43 <sproingie> i'm wondering if the build step in this package was a no-op
18:04:47 <sproingie> clearly it didn't link
18:05:46 <SamB> ok...
18:05:53 <Lemmih> Was it cabalized?
18:05:58 <sproingie> yep
18:06:12 <SamB> you need to restart ghci, and make it load the pcre library
18:06:23 <SamB> which is to say
18:06:32 <SamB> you need to start GHCi with that library on the command line
18:07:10 <Cale> huh, that's kind of dumb, it should know that library needs to get loaded
18:07:32 <Cale> isn't there an option in the conf file for the package which contains things like that?
18:08:08 <sproingie> who knows.  maybe RRegex will work better
18:08:29 <sproingie> i thought JRegex would actually be easier to build because it's cabalized
18:08:55 <Cale> hmm, I'll have a look and see if there's anything obviously wrong with it
18:11:56 <sproingie> same author, actually.  i guess JRegex is a cabalized RRegex
18:12:47 <Cale> okay, there's a suspicious lack of options in the .cabal file
18:13:58 * araujo wonders if a +60 line function is too obscene
18:14:01 <Cale> you managed to get it to compile using Setup.hs? I'm already having to edit the .cabal to get it to build.
18:14:19 <sproingie> built out of the box, yep
18:14:27 <sproingie> for some loose definition of "built" i'm finding
18:14:46 <Cale> oh, ghc6.4
18:15:00 <Cale> what was the command that you used?
18:15:17 <Cale> nm
18:15:20 <sproingie> runhaskell Setup.hs configure; runhaskell Setup.hs build; runhaskell Setup.hs install;  
18:15:34 <sproingie> i do have a new version of cabal
18:15:56 <Cale> sorry, I'd meant to get it to fail
18:16:49 <Cale> okay
18:17:26 <Cale> I had to add   'haskell98' (sans quotes) to the list of build-depends, and  Extra-Libraries: pcre  to the .cabal
18:17:54 <Cale> Perhaps you can do without the first change because you actually got it to build fine.
18:19:10 <sproingie> WOO
18:19:13 <sproingie> you are my savior
18:19:30 <sproingie> Cale++
18:23:40 <SamB> Cale: no, both of those are needed
18:23:49 <sproingie> just sent a patch (and credited you)
18:23:53 <Cale> SamB: I needed both
18:24:24 <Cale> SamB: sproingie managed to get it to build without the explicit haskell98 because he's on a bit older ghc
18:24:37 <SamB> Cale: but not to *use* it
18:24:55 <SamB> see above errors
18:25:10 <sproingie> actually i've no idea whether my patch sent ... i never send mail direct from this machine
18:25:47 <Cale> SamB: ah
18:42:59 <Korollary> way to go ghc (chameneos)
18:43:41 * SamB suspects his dog is eating candy cane
18:44:08 <SamB> yup
18:44:21 <SamB> putting those anywhere she could reach them was a bad idea...
18:52:32 <Speck> I don't understand how the chameneos benchmark wouldn't have Java or C implementations, since those are examples giving in the paper from which the benchmark is based.
18:58:05 <Korollary> Speck: Java folks will get to submitting one eventually.
18:59:22 <Speck> I think it would read nicer if meetings itself were given an explicit type, instead of the then-branch in it -- assuming I'm right that it would do the exact same thing
18:59:42 <Speck> of course, lines of code might be a consideration -- in which case I still think (meetings::Int) = ... would read better
19:00:06 <Korollary> Speck: There are already 2 entries. You can have a 3rd.
19:00:19 <Speck> oh, not just for such a tiny nitpick
19:00:29 <Speck> and I brought it up mostly because I wanted to make sure I was correct
19:00:34 <Korollary> ah
19:00:43 <Korollary> I didn't really study it
19:00:59 <Speck> let meetings = if null args then (1000000::Int) else (read . head) args
19:01:03 <Speck> that's the only line I'm referring to
19:01:56 <Korollary> it's an argument to replicateM_ in the next line
19:02:09 <ski> let meetings :: Int
19:02:11 <ski>     meetings = ...
19:02:25 <Speck> @type replicateM_
19:02:27 <lambdabot> Not in scope: `replicateM_'
19:02:34 <Speck> @type Control.Monad.replicateM_
19:02:35 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m ()
19:02:40 <Speck> it might be Int anyway
19:03:13 <sproingie> what's with the trailing underscore to replicateM_ anyway?
19:03:30 <Speck> @type Control.Monad.replicateM
19:03:32 <ski> means results are discarded
19:03:32 <lambdabot> forall a (m :: * -> *). (Monad m) => Int -> m a -> m [a]
19:03:34 <Korollary> it's the m () tradition
19:03:47 <ski> @type mapM
19:03:48 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
19:03:51 <ski> @type mapM_
19:03:52 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> [a] -> m ()
19:03:58 <ski> @type sequence
19:03:59 <ski> @type sequence_
19:03:59 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
19:04:00 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
19:04:27 <Korollary> @type getLine
19:04:28 <lambdabot> IO String
19:04:39 <Speck> how would I check if removing the explicit Int typing on that line affects the compilation in any way?
19:04:40 <Korollary> there should be a getLine_, heh
19:04:57 <Korollary> wasteLine maybe
19:05:16 <ski> do ...
19:05:19 <ski>    getLine
19:05:21 <ski>    ...
19:05:32 <Korollary> Speck: it doesnt look like it would
19:06:22 <Speck> Korollary: that's the only explicit typing in the whole program... it's actually starting to bug me, but until there's another optimization, it's definitely not worth confusing an already confusing results table for the shootouts
19:08:58 <sproingie> wasteTime_
19:09:19 <Korollary> Speck: yeah, any effort is better spent on another benchmark
19:11:11 <sproingie> shootout claims a language has to support floating point to qualify ... i guess lua qualifies because there's no requirement to actually support ints
19:11:56 <Korollary> I'd say that's a hidden requirement
19:15:41 <Korollary> I should use hGetBuf and Ptr's to have an imperative style reverse-complement entry
19:16:29 <sproingie> peek and poke
19:17:36 <dons> Speck, regarding :: Int, check the generated Core.
19:17:45 <dons> Int usually kills off lots of fromIntegral style code.
19:18:05 <Korollary> ah
19:20:48 <lispy> Korollary: you are aware that entries which are not coded in the "dogmatic" (I think that's the word they use) way are not meant to be accepted, right?
19:21:35 <lispy> or more bluntly, don't be suprised if your peek/poke implementation is rejected :)
19:22:09 <dons> peek/poke are pretty common in Haskell ;)
19:22:42 <lispy> heh, i've used them once
19:22:49 <lispy> and it was painful
19:23:13 <dons> what we need is fastStrings in the base lib :)
19:23:26 <lispy> i would totally agree with that
19:23:50 <lispy> dons: how hard would it be to make FPS only allow itself to hold n bytes in memory at a time?
19:24:24 <lispy> that is, you have access to the whole file, say, but you only use n bytes of space even if the file is 3 megs
19:24:30 <lispy> or 3000 megs
19:25:14 * lispy is not sure if that made any sense
19:25:25 <lispy> i ask for the sake of darcs
19:26:10 <lispy> if it needs to process a large file then at some point it may load the entire file into memory
19:26:10 <dons> you could write a lazy slurpy buffer, I guess
19:26:33 <dons> you basically talking about a lazy IO function, with invisible bounded buffers, no?
19:26:49 <lispy> yeah, i think so
19:27:03 <dons> could be done.
19:27:07 <lispy> being able to seek might be important, but even if it was monodirectional it would help
19:27:33 <lispy> i guess that's why languages like c++ have streams
20:01:15 <orbitz> hi
20:03:47 <Korollary> yo
20:04:25 <SamB> orbitz: hello
20:07:12 <orbitz> SamB: what's shakin/
20:07:31 <orbitz> i removed a uselss channel from my list and decided why not replace it with #haskell
20:07:54 <orbitz> how is emacs support for haskell?
20:08:27 <SamB> orbitz: well. it is okay, but the indentation isn't terribly intelligent
20:08:48 <orbitz> too bad
20:09:32 <SamB> works better than nothing, but sometimes you have to indent yourself ;-)
20:09:37 <Korollary> it's not that big of a deal
20:10:01 <orbitz> woudl it be hard to get the indenation up
20:10:58 <SamB> I imagine that it would have been fixed already if it were easy...
20:11:11 <SamB> dunno!
20:11:24 <SamB> the matter is also complicated by the fact that there are, what is it, 3 versions of the emacs mode?
20:11:29 <Korollary> iirc, it's more of an emacs limitation
20:11:51 <SamB> we are hoping hIDE will do better ;-)
20:12:19 <orbitz> ugh, i hate having to learn a new set of tools just for one bloody language
20:12:25 <orbitz> maybe i'll just deal with teh emacs mode
20:12:33 <orbitz> can emacs figure out the indetnation after the fact? or no
20:12:51 <SamB> well, hIDE isn't even ready yet.
20:12:53 <orbitz> would asking emacs to indent after I finish typing the line work out?
20:13:00 <orbitz> will it ever be?
20:13:06 <SamB> dunno!
20:13:09 <Philippa> Haskell sorta doesn't work that way
20:13:14 <orbitz> liek SML?
20:13:16 <orbitz> SML has similar issues
20:13:24 <Philippa> I dunno, does SML have a layout rule?
20:13:29 <tismith> orbitz: just use vim :)
20:13:40 <Philippa> but yes, you've got a problem with patterns typically going on separate lines
20:13:47 <orbitz> tismith: no thanks
20:13:49 <SamB> hopefully at some point it will all build on the latest release version of GHC...
20:13:55 <SamB> without ghc-api...
20:14:07 <orbitz> i'm used to erlang
20:14:18 <orbitz> where the emacs mode can even figure otu when to put new lines in for you
20:14:25 <orbitz> erlang is quit the verbose language syntaxually
20:14:50 <SamB> well, Haskell is not a prolog-derivative syntax-wise ;-)
20:15:07 <Philippa> nor is it overly verbose
20:15:28 <SamB> not that erlang is necessarily overly verbose...
20:15:45 <Korollary> haskell doesn't have levels and levels of nested blocks, either. Doing it manually is not too uncomfortable. haskell-mode helps a bit, but I usually don't even care.
20:16:07 <SamB> Haskell mode does most of it.
20:16:12 <Philippa> I do sometimes get what would be three or four nested levels if you de-layouted in my code
20:16:18 <SamB> mostly what bothers me is the odd monadic let
20:16:23 <orbitz> well are tehr eeamcs keys to easily jump layers of indetnation?
20:16:48 <Philippa> tbh, it's often better to manually specify how deep to indent anyway
20:16:53 <Philippa> tabs're anathema
20:17:27 <SamB> really, its mostly a matter of backspacing a little sometimes...
20:17:32 <Korollary> yeah
20:17:47 <Philippa> I tend to use space instead, but then I tend to indent by a couple of spaces at a time
20:18:06 <Philippa> (or else to line up with the end of a pattern, which isn't exactly tab-based either)
20:18:20 <Korollary> I sometimes indent by one space, heh
20:18:38 <SamB> anyway, its not terrible!
20:18:51 <SamB> and if you hate it you are welcome to your braces and semis
20:18:57 <Korollary> nah. I wish I wrote enough haskell code to be able to complain about it.
20:19:52 <SamB> what would be really cool would be a pretty printer able to take advantage of the layout rule...
20:20:08 <orbitz> SamB: i bought an in-and-out burger shirt today, jealous much?
20:20:16 <SamB> no!
20:20:29 <SamB> I am not one of those that nearly idolizes those!
20:20:30 <orbitz> why not?
20:20:37 <orbitz> i had it for my first tiem today
20:20:38 <orbitz> it was fantastic
20:20:47 <SamB> I have met at least one, though, I think.
20:21:00 <orbitz> i think i'll write soem more erlang code bfore i write some haskell
20:21:06 <SamB> I think he wanted to conquer the world (possibly the country), and hated onions...
20:21:06 <orbitz> i do need to learn haskell badly thouhg
20:21:08 <orbitz> oh so badly
20:21:11 <Korollary> badly?
20:21:15 <orbitz> BADLy
20:21:26 <SamB> you should learn it well instead ;-)
20:21:27 <Korollary> it aches?
20:21:31 <Philippa> you got needs, huh?
20:21:32 <SamB> its much more fun that way ;-)
20:22:00 <orbitz> follow joel reymonts haskell experiences at all?
20:22:10 <Korollary> yes.l he hangs out here a lot as well
20:22:20 <Philippa> a bit. He did kinda jump off into the deep end
20:23:08 <Philippa> then again, you shoulda seen the conversation about AI earlier
20:23:14 <SamB> yeah. and he shoulda switched to erlang sooner...
20:23:27 <Philippa> gotta admire the tenacity there though
20:23:37 <Philippa> (and hey, at least sylvan eventually got the damn point)
20:23:40 <Korollary> it's educational
20:25:16 <SamB> yeah
20:25:26 <SamB> and he stress tested like the entire GHC RTS, plus the type checker!
20:27:30 <SamB> he's also making me wonder if maybe Erlang wouldn't be a good language to do a BitTorrent client in...
20:27:43 <lispy> hm...this is the third time i've asked iTunes to add songs to my library and it has gone into some sort of inifinite loop
20:27:55 <SamB> by which I mean "would"
20:27:56 <Korollary> lispy: I hate itunes.
20:28:16 <lispy> Korollary: yes, i can see why
20:28:35 <lispy> i've disabled the thingy where it copies them to your "library" when you add them
20:28:46 <lispy> but it's still taking hours to do this seemingly simple operation
20:32:26 <lispy> this is what apple gets for not using haskell!
20:32:37 <Korollary> heh I wouldn't go that far.
20:34:47 <SamB> lispy: I think you mean Erlang
20:35:20 <SamB> or perhaps 16-bit DOS
20:38:42 <Nanar> hum there is something I really don't understand with haskell
20:39:25 <Nanar> why sometime with some function I have to do a <- func, and sometime a = func
20:39:58 <Nanar> for example with function getClockTime
20:40:29 <ski> '<-' runs a monadic action, possibly doing some side-effects, then binding the result value to the LHS
20:40:43 <ski> '=' just binds value of expression directly
20:40:51 <Nanar> ok
20:40:52 <ski> @index getClockTime
20:40:53 <lambdabot> System.Time
20:41:01 <ski> @type System.Time.getClockTime
20:41:03 <lambdabot> IO System.Time.ClockTime
20:41:16 <ski> so, when you write
20:41:17 <ski> do ...
20:41:25 <ski>    t <- getClockTime
20:41:43 <ski> then the IO-action here is 'getClockTime'
20:41:49 <ski> getClockTime :: IO ClockTime
20:41:57 <ski> while, the variable 't'
20:42:03 <ski> t :: ClockTime
20:42:39 <ski> so, you can think of the '<-' as running the action, and extracting the result, binding it to the variable ("unwrapping" the 'IO' in the type)
20:42:53 <ski> (Nanar : does this help ?)
20:42:58 <Nanar> now imagine this code http://pastebin.com/492879
20:43:04 <Nanar> ski: yes a bit
20:43:16 <Nanar> I made a time function
20:43:30 <Nanar> I have to do d <- date in main
20:43:34 <orbitz> what gui frameworks does haskell support?
20:44:06 <Philippa> ITYM "which GUI frameworks/libraries are there existing bindings for"? gtk, wx, I think there're some tk bindings around somewhere too
20:44:07 <Nanar> ski: of I would prefer to write directly putStrLn (date ++ " " ++ m)
20:44:10 <Korollary> orbitz: gtk and wx bindings exist afaik
20:44:14 <Nanar> of course
20:44:16 <orbitz> Korollary: how are they?
20:44:20 <orbitz> Korollary: what about on win32?
20:44:30 <Philippa> they work on win32
20:44:46 <orbitz> yes, but what abotu win32api
20:44:56 <Philippa> I *think* there're some raw win32 api bindings floating around somewhere, but I'd rather just stab myself in the eyeball with a rusty corkscrew
20:45:03 <orbitz> :)
20:45:19 <Philippa> they're very, very basic. As in, not much different from using C
20:45:27 <Korollary> orbitz: ghc comes with some win32 bindings
20:45:39 <ski> Nanar : the 'd <- date' tells when you take the date
20:45:46 <Nanar> ski: if you have few sec, how would I write date function to return a String and not an action
20:46:13 <Philippa> you wouldn't
20:46:28 <Philippa> you'd call it from yet another action which would pass it into something else
20:46:39 <ski> Nanar : though, you could try things like 'putStrLn =<< liftM (++ " " ++ m) date'
20:46:39 <Korollary> Nanar: which tutorial are you reading?
20:47:07 <Nanar> Philippa: ok ok, now it's clear :)
20:47:12 <Nanar> Korollary: give me a sec
20:47:13 <Philippa> ski: way to cut the floor out from under someone :-)
20:47:55 <orbitz> would haskell make a good scripting language to emebdd in an application?
20:48:06 <Nanar> Philippa: Haskell Tuto, by Damir Medak and Gerhard Navratil
20:48:11 <Philippa> I'm in two minds about that one
20:48:35 <Philippa> the short answer is "yes, but you'd probably want to define a new monad for interacting with the app itself"
20:49:08 <Philippa> (the good news is that also makes it pretty much impossible for scripts to call IO code you don't want them to)
20:49:20 <orbitz> :)
20:49:29 <orbitz> i still need to learn monads
20:49:31 <dons> yeah, that sounds reasonable
20:49:33 <dons> a monad would be good.
20:49:51 <Philippa> dons: no RTS hacking has happened as yet, 'mafraid
20:50:07 <Nanar> Philippa: to be honest, in all haskell tutorial I found, some basic are missing
20:50:28 <orbitz> are monads basicly like iterating over a list where the result may be what you are after or nothing?
20:50:33 <Philippa> Nanar: er, I wasn't talking about any of the tutorials? Although yes, I'm inclined to agree
20:50:41 <Korollary> Haskell tutorials are never universally liked.
20:50:43 <Philippa> orbitz: er, no
20:50:53 <Philippa> orbitz: monads are sort of like language extensions...
20:51:02 <Nanar> Philippa: all have very good mathematic example, but nothing about IO, getting time, hostname...
20:51:07 <Philippa> *ah*
20:51:16 <Philippa> yeah
20:51:37 <Philippa> want to stake out a page on hawiki to keep your notes on such things on?
20:51:43 <Philippa> that'd make a good starting point for such a thing
20:52:02 <Nanar> and the worst, I am trying to patch darcs, so I have some example of code, some keywords are simply not explained in index google found
20:52:23 <Philippa> um, yeah. Darcs uses a lot of GHC-specific extensions, doesn't it?
20:52:40 <Nanar> example http://www.zvon.org/other/haskell/Outputprelude/Either_d.html
20:53:21 <Philippa> the deriving stuff?
20:53:25 <Nanar> Philippa: probably, I am not enought expert to judge, and on another side, I want to avoid compiler specific thing in my code
20:53:29 <Korollary> Nanar: you'd need to be quite a bit more comfortable with haskell to mess with darcs in general.
20:53:49 <Philippa> orbitz: er, I was explaining what monads are?
20:54:12 <orbitz> Philippa: yes, started atleast
20:54:39 <Nanar> Korollary: I take my time, at time I mainly copy past code, and try to understand :)
20:55:10 <Philippa> okay. A monad consists of a (parameterised) datatype for programs in the extended language and some standard functions to use to build such programs - the two important ones being return and >>=
20:55:20 <Nanar> Korollary: I don't think my change will be publish before a while :)
20:55:33 <Philippa> return is just 'make this value a program'...
20:55:50 <Nanar> ok
20:55:53 <Philippa> so within the IO monad, return "Hello IO!" :: IO String, because in general IO programs have the type IO a
20:56:00 <Philippa> that make sense?
20:56:11 <Nanar> ok I understand
20:56:11 <lispy> a monad gives you a way to compose program statements while allowing you to overload the way they are composed...(that's one application)
20:56:31 <ski> s/overload/parameterize/
20:56:40 <ski> (overloading not necessary)
20:56:51 <ski> (but helpful)
20:57:13 <Nanar> If I follow, haskell know only value and expression, Monad give immediate action
20:57:16 <Philippa> lispy: can I please finish giving my explanation without being drowned in a pile of conceptual overloading?
20:57:22 <Philippa> Nanar: no, they don't
20:57:28 <orbitz> Philippa: i think so
20:57:28 <Nanar> erf :)
20:57:43 <sproingie> i don't get the "make this value a program" bit.  i know what return does, but i don't really get its relation to the computation other than forcing the sequencing to occur
20:57:56 <Philippa> sproingie: return does no sequencing whatsoever
20:58:07 <Philippa> all return does is let the monad deal with the value at all
20:58:22 <ski> Philippa : possibly 'program' is a somewhat inappropriate term, here ?
20:58:31 <Philippa> orbitz: the second function is >>= (pronounced 'bind'). It takes a program on its LHS, and a function yielding a program on the RHS
20:58:49 <Philippa> ski: sort of. I'll say computation from now on - in a meaningful sense it's a case of same difference though
20:58:55 <orbitz> what is teh defintion of program
20:59:02 <orbitz> function?
20:59:04 <sproingie> orbitz: a sequence of instructions
20:59:21 <sproingie> orbitz: a sequence of functions that follow each other.  like a program in most other languages
20:59:26 <Philippa> "value of monadic type (which is thus intended to yield some kind of result)"
20:59:33 <SamB> return injects a value into the monadic computation
20:59:36 <Philippa> sproingie: please *please* see what I said to lispy earlier...
20:59:52 * Philippa sighs - there goes any attempt to maintain a coherant presentation :-)
21:00:02 <Korollary> I'd recommend reading any one of the numerous monad intros.
21:00:08 <Philippa> so would I
21:00:32 <Philippa> OTOH, I'd like to actually finish the explanation, because I also have a rather nice trio of implementations of the state monad that work rather well pedagogically speaking
21:00:34 <ski> monadic computation .. something that can return/compute to a value .. an possibly some "extra" stuff .. that is what the specific monad is about (side-effects etc)
21:00:53 <Nanar> Philippa: I read you carrefully
21:00:59 <ski> s/an/and/
21:01:05 <Korollary> Philippa: go ahead of course. If you like it, let's put it in the wiki.
21:01:14 <Philippa> OK. Guys. Can I actually explain what bind /does/ now?
21:01:25 <Philippa> Korollary: There's a TMR article in the works :-)
21:01:28 <sproingie> getting as many explanations in the wiki is good
21:01:36 <Philippa> Korollary: it also make sense of how to implement monads easily...
21:02:04 <Philippa> orbitz: suppose I have this computation: getChar >>= putChar...
21:02:24 <ski> @type getChar
21:02:25 <lambdabot> IO Char
21:02:27 <ski> @type putChar
21:02:29 <lambdabot> Char -> IO ()
21:02:34 <Philippa> thanks
21:02:43 <sproingie> kinda like a pipe
21:02:45 <orbitz> Philippa: seems everyone wants to put in theri 2 cents
21:03:00 <Philippa> orbitz: yup. You spotted what bind does?
21:03:22 <Philippa> (ski's showing you the types was sensible btw)
21:03:33 <Philippa> @type >>=
21:03:34 <lambdabot> parse error on input `>>='
21:03:36 <orbitz> no i don't see what bidn does form yoru simpel example
21:03:39 <Philippa> @type (>>=)
21:03:41 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
21:03:55 <orbitz> i udnerstand getChar would have tyep IO Char
21:04:07 <orbitz> and putChar takes a Char and retursn IO monad
21:04:11 <Philippa> orbitz: it takes the result from the computation in the LHS, applies it to the RHS to get a second computation and then yields the result of that computation
21:04:36 <Philippa> it's sort of 'function application for monads'
21:04:57 <orbitz> Philippa: so would getChar >>= putChar print any character that was input?
21:05:12 <Philippa> yep
21:05:17 <orbitz> ok
21:05:18 <sproingie> Philippa: would a pipe be an accurate metaphor?
21:05:28 <orbitz> pipe makes sense to me in that case
21:05:32 <Philippa> sproingie: yep, unix pipes actually form a monad (with cat as return)
21:05:56 <sproingie> Philippa: ah, so return is basically >>= with the "outside world" at the right hand side?
21:06:20 <ski> 'return' is not a special case of '(>>=)'
21:06:33 <Nanar> Philippa: thanks for the explanation
21:06:41 <Nanar> Philippa: things become clear
21:07:10 <ski> '(>>=)' is used to "sequence" monadic actions
21:07:14 <Cale> except that unix pipes aren't a functor over anything -- except maybe the category with a single object consisting of the set of possible bytes and functions from bytes to bytes
21:07:29 * Korollary chuckles
21:07:41 * ski smiles at CT being brought into the pic
21:07:43 <Cale> hehe
21:07:49 <Cale> sorry :)
21:07:50 <Philippa> orbitz: from >>= you can build pretty much any sensible control flow anyway. Two important functions you can build from it are liftM (aka fmap) which turns a function into its monadic equivalent and join, which turns a computation-that-returns-a-computation into just a plain computation
21:08:10 <ski> @type (>>)
21:08:11 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> m b -> m b
21:08:15 <Philippa> oh okay, and >>
21:08:21 <Philippa> which is >>= only it ignores its input
21:08:38 <ski> '(>>)' can be used for simple sequencing, when resutl of first action is not needed (it's discarded)
21:08:39 <Philippa> anyway, all that stuff you see people talking about with do? That's syntactic sugar, it turns into a lot of >>= and lambda
21:08:53 <ski> '(>>=)' allows second part to depend on result of first part
21:09:13 <sproingie> putStr "hello " >> putStrLn "world"
21:09:33 <orbitz> Philippa: got soem example code?
21:09:45 <Philippa> orbitz: implementations of monads, or code using them?
21:09:55 <orbitz> Philippa: using
21:09:55 <Korollary> orbitz: http://haskell.org/hawiki/MonadsAsContainers
21:09:57 <Philippa> I mostly use the do notation for the latter
21:10:08 <ski> (maybe examples of do-syntax, and expanded versions)
21:10:17 <Philippa> http://www.flippac.org/projects/SigGen.hs <- does a lot of IO using the do notation)
21:10:53 <Philippa> do notation consists of a series of statements...
21:10:57 <Philippa>  pattern <- expression
21:11:02 <Philippa> where expression :: m a
21:11:28 <Philippa> and some without the pattern <- bit, including the last statement
21:12:03 <Philippa> the pattern <- expression desugars to expression >>= (\pattern -> ...), where ... is the rest of the code desugared...
21:12:25 <orbitz> Philippa: do you have an exampel of do adn teh equivaletn >>=
21:12:29 <Philippa> a statement that's just an expression desugars to expression >> ..., or just expression if it's the last one
21:12:40 <Philippa> a couple of contrived ones
21:13:04 <orbitz> is anything other htan teh pathological cases easy to show
21:13:10 <Philippa> do a <- getChar; putChar a <=> getChar >>= (\a -> putChar a)
21:13:28 <Philippa> sort of. You can do the syntactic manglings, but do notation's a lot easier to read
21:13:40 <Philippa> and it's 5am here :-)
21:13:44 <sproingie> orbitz: that being two different expressions, <=> isn't an operator :)
21:14:29 <orbitz> sproingie: thanks
21:14:35 <Korollary> orbitz: http://www.nomaware.com/monads/html/class.html#donotation has a few as well
21:14:45 <orbitz> do expressions in a 'do' happen in order?
21:14:51 <orbitz> Korollary: thanks
21:14:52 <sproingie> yep
21:14:54 <Philippa> that's sort of dependant on the monad
21:15:13 <Philippa> strictly speaking, all the monadic signiature requires is that they're dependant on each other in the obvious way
21:15:18 <orbitz> my haskell bookmarks are growing larger than life
21:15:19 <Philippa> so some monads are lazy, others aren't
21:15:28 <Philippa> in most monads, they happen in order
21:15:55 <orbitz> any suggested readign for haskell ebginign? Haskell For c Programmer ok? I don't relaly care about learning it form a C standpoint
21:15:58 <sproingie> orbitz: in the IO monad, which you'll see *everywhere* they always happen in order
21:16:50 <orbitz> sproingie: i would imagine so
21:16:58 * ski thinks http://www.cs.pdx.edu/~antoy/Courses/TPFLP/lectures/MONADS/Noel/research/monads.html is nice, though short
21:17:09 <Philippa> yep. The IO monad's a bit special in some regards: with most monads, either the resulting datatype's something you can take apart or there's a runMonad func that gets the result out for you
21:17:17 <orbitz> any suggesting readign for learning haskell? not just monads
21:17:25 <Philippa> the IO monad doesn't have that - and that's intentional
21:17:37 <Philippa> orbitz: want to see some code for a monad that gives Haskell state?
21:17:51 <orbitz> i've always heard of monads in term sof IO, are they useful in any sutation where you want to execute thing sin soem order in haskell?
21:18:02 <orbitz> Philippa: yes, i'm always looking forward to seeing code
21:18:10 <Philippa> they're useful for any situation where you want a new language feature
21:18:28 <Philippa> okay, I'll pm you it and discuss there for now? It's the skeleton of an article I'm writing
21:18:38 * ski thinks that's a slight overstatement :)
21:18:47 <sproingie> Philippa: know anything about arrows?
21:19:03 * sproingie wishes there was as much a wealth of tutorial material on those as with monads
21:19:11 <Philippa> ski: OK, slight. But monads represent what you get without throwing away 'haskellness'
21:19:20 <Philippa> sproingie: a bit, but it's late and I'm shattered
21:19:50 <sproingie> Philippa >>= bed
21:19:51 * Korollary calls for a round of applause for Philippa
21:19:56 <ski> Philippa : yes .. effects
21:20:14 * ncalexan claps.
21:20:17 <sproingie> Philippa++
21:20:32 <Korollary> (maybe the noise will keep her awake ;) )
21:21:15 <Nanar> orbitz: http://www.haskell.org/~pairwise/intro/section3.html#part7
21:21:23 <orbitz> thanks
21:21:45 <Nanar> I was reading another
21:21:46 <orbitz> Nanar: ah, i already ahve this
21:21:55 <JoshTriplett> It occurs to me that while getChar >>= (\a -> putChar a) is not particularly readable compared to the same thing expressed with do, getChar >>= putChar makes perfect sense.
21:22:00 <Nanar> sorry :)
21:22:10 <orbitz> is haskell for c programmers a good introduciton to haskell, or are ther ebetter? I don't particlarly need it from a c point of view
21:22:14 <orbitz> Nanar: no need, the tought that counts
21:22:27 <Korollary> orbitz: I don't like that tutorial myself
21:22:33 <ncalexan> orbitz: a lot of people recommend Yet Another Haskell Tutorial, by Hal Daume.
21:22:41 <ncalexan> But I haven't looked at it.
21:22:46 <orbitz> i have YAHT
21:23:03 <ncalexan> Oh, good.
21:23:09 <orbitz> i just need to spend a day writing soem haskell
21:23:38 <sproingie> yep.  check out the shootout examples in haskell too
21:24:00 <sproingie> that's pretty good sample code that does something useful
21:24:16 * sproingie learned about channels from reading the chameneos benchmarks (which ghc now gets the #1 spot on)
21:25:20 <orbitz> heh
21:25:21 <orbitz> sproingie: URL?
21:25:43 <sproingie> http://haskell.org/hawiki/ShootoutEntry
21:26:34 <sproingie> chameneos is a great example of how haskell can suck up LOTS of RAM one way, and be stingy with it with just a little tweak
21:27:13 <sproingie> since there are two entries for ghc.  note the RAM consumption difference
21:27:26 <Korollary> I'd actually prefer real applications like Yi over shootout examples.
21:27:40 <orbitz> what is Yi
21:27:45 <Korollary> it's a text editor
21:27:48 <Korollary> @where yi
21:27:49 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
21:28:12 <orbitz> i think my haskell bookmarks have tripled tonight
21:28:54 <Korollary> read the wiki. There's so much there. It's overlooked a lot by learners for some reason.
21:29:38 <orbitz> ok, will do
21:29:44 <orbitz> i gotta write soem erlang tonight
21:31:28 <sproingie> real applications are nice but a bit overwhelming
21:31:41 <sproingie> it's often nice to see concepts in isolation
21:31:48 <Korollary> they have more comments tho :)
21:32:16 <sproingie> BTW, who maintains the wiki?
21:32:24 <Korollary> we all mess it up.
21:32:32 <sproingie> damn Moin doesn't have any way to retrieve a password
21:33:02 <Korollary> ah
21:33:29 <sproingie> if anyone can just delete the ChuckAdams user, i could just reregister.  not sure how it tracks users
21:33:31 <ski> @seen shapr
21:33:32 <lambdabot> shapr is in #ScannedInAvian. Last spoke 6 hours, 33 minutes and 10
21:33:32 <lambdabot> seconds ago.
21:42:09 <dons> sproingie, I just gained another 10% on chameneos. it's all a matter of massaging ghc the right way :)
21:42:47 <dons> lesson of the day: Eq is not as nice as `case'
21:43:11 <Korollary> heh
21:43:26 <Korollary> how?
21:43:37 <Korollary> you mean == is slower than pattern match?
21:44:26 <sproingie> hm.  what is fps-any?  yi wants it, i apparently don't have it
21:44:40 <Korollary> @where fastpackedstring
21:44:41 <lambdabot> I know nothing about fastpackedstring.
21:44:58 <Korollary> @where FPS
21:44:59 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
21:45:10 <Korollary> that's it
21:45:13 <sproingie> i can't wait til hackage has every cabal package downloadable from one app
21:45:16 <sproingie> thanks
21:46:15 <dons> the complement functoin was inefficient.
21:47:10 <joelk> dons, I'm on my third version of nbody :-(. I'm learning more about GHC than Haskell proper, but then again, that is forcing me to explore new areas of Haskell too.
21:47:45 <dons> I rewrote it using case, Korollary, rather than using lots of ==
21:48:05 <dons> joelk, is nbody getting faster?
21:48:08 <dons> or shorter?
21:48:11 <dons> or both!!?
21:48:30 <Korollary> dons: That's similar to the ocamllers technique of de-polymorphising functions to gain speed.
21:48:36 <dons> i've learnt that fusing multiple maps and reductions into a foldr helps ghc.
21:48:36 <dons> it's worked on two cases
21:48:38 <dons>  now.
21:49:09 <dons> ghc should do our specialisation for us. hinting at ::Int helps sometimes though.
21:49:20 <joelk> I got nbody2 to be almost as fast as my nbody1.  Both about 2.5x slower than the current version. BooHoo. 
21:50:00 <joelk> I think the moral of the story is "never ask a list to do an array's job"
21:50:12 <defcon8> http://pastebin.com/492928
21:50:17 <defcon8> can someone correct that please
21:50:21 <dons> definitely. 
21:50:32 <dons> (joelk)
21:50:36 <Korollary> joelk: wasn't that obvious before ? :)
21:50:59 <sproingie> cabal seems to be installing all executables with mode 744
21:51:00 <defcon8> anyone?
21:51:08 <sproingie> -rwxr--r--  1 root root 1225288 2006-01-05 21:46 /usr/local/bin/yi
21:51:25 <joelk> but I'm not even talking about O(1) lookup. map and zipWith over lists of vectors (V3 !Double !Double !Double) is SLOWWWWW
21:52:11 <dons> khmm. that's weird. try to not travers ethe lists too many times
21:52:45 <Korollary> that should be slower than an array by a constant
21:53:08 <joelk> Yes, dons, it would be faster to not process at all :-)
21:53:38 <dons> :) well sometimes people do filter . map . group . sort and so on..
21:53:39 <Korollary> so two implementations, one with lists and one with arrays should remain proportional for growing input. Otherwise something's weird.
21:53:51 <dons> we actually had entries that did that kind of thing.
21:53:52 <joelk> I realize that. That's what I mean. Now I'm trying with UArrays.
21:54:00 <Korollary> defcon8: it looks like there's a massive typo in that program.
21:54:30 <Philippa> dons: if you're composing things that leave the order intact (aside from filtering) that can be pretty fast still
21:54:33 <Philippa> and... argh, bed
21:54:35 <defcon8> what is that Korollary ?
21:54:40 <ski> defcon8 : either put defintion of 'root' outside of definition of 'main' or use a 'where' (or 'let')
21:54:57 <defcon8> ok then
21:56:05 <defcon8> Test.hs:4:
21:56:05 <defcon8>     Couldn't match `IO a' against `(a1, a1)'
21:56:05 <defcon8>         Expected type: IO a
21:56:05 <defcon8>         Inferred type: (a1, a1)
21:56:13 <defcon8> im still getting the same error
21:57:05 <ski> try 'print (root 4 9 16)'
21:57:41 <Nanar> sound like I am not the only one perturb by the IO things
21:57:45 <defcon8> compiled
21:57:46 <defcon8> thanks
21:58:07 <defcon8> defcon8@defcon8 ~/python $ ./test 
21:58:07 <defcon8> (NaN,NaN)
21:58:12 <defcon8> wtf?
21:58:17 <Korollary> python ?
21:58:24 <defcon8> haskell
21:59:24 <ski> > let (a,b,c) = (4,9,16) in b*b - 4*a*c
21:59:26 <lambdabot> -175
21:59:42 <ski> you're taking square root of negative number
22:00:13 <defcon8> oh right
22:00:19 <defcon8> cant it do complex numbers? :p
22:00:30 <ski> (i.e. your quadratic equation has two complex number solutions)
22:00:31 <sproingie> wow, yi really is nicely commented
22:00:43 <defcon8> then i must do error exceptions
22:00:47 <Korollary> @karma+ dons
22:00:48 <lambdabot> dons's karma raised to 22.
22:02:01 <ski> Data.Complex> sqrt (-1) :: Complex Double
22:02:01 <ski> 0.0 :+ 1.0 :: Complex Double
22:02:37 <defcon8> weve only just learned complex numbers yesterday
22:02:59 <defcon8> ok off to school. thanks for the help
22:03:00 <ski> i think your code defaulted to Double ..
22:03:13 <ski> print (root :: Complex Double)
22:03:17 <ski> you could try that
22:03:24 <ski> err
22:03:29 <ski> print (root 4 9 16 :: Complex Double)
22:04:21 <defcon8> what module do i have to import?
22:04:44 <ski> Data.Complex
22:05:02 <ski> hm
22:05:04 <ski> actually
22:05:09 <defcon8> Test.hs:2: parse error on input `module'
22:05:15 <defcon8> i put that befoer module Main
22:05:20 <ski> import Data.Complex
22:05:27 <defcon8> oh
22:05:29 <ski> after 'module Main where'
22:05:47 <ski> since root returns a pair, that above will not work
22:05:53 <defcon8>     Can't find module `Data.complex'
22:06:00 <ski> print (root 4 9 16 :: (Complex Double,Complex Double))
22:06:07 <defcon8> ok i could do it on fst and snd
22:06:14 <ski> upper case 'C' in 'Complex'
22:06:21 <defcon8> yep i dit
22:06:23 <defcon8> im using ghc
22:06:34 <defcon8> oh no i didnt
22:07:29 <defcon8> defcon8@defcon8 ~/python $ ./test 
22:07:29 <defcon8> ((-1.125) :+ 1.653594569415369,(-1.125) :+ (-1.653594569415369)
22:07:35 <defcon8> i dont even get thjat but thanks foor the help :D
22:07:52 <ski> of course, if you want 'root' to always work with complex numbers, you could add a type signature to that, instead
22:08:10 <ski> 'a :+ b' is 'a + i * b'
22:08:19 <defcon8> ooooh
22:08:24 <defcon8> the real and imaguinary parts
22:09:11 <ski> :b
22:09:17 <ski> arg
22:10:36 <dons> I really like how making haskell code shorter usually leads to more readable code, not less readable
22:11:18 * Korollary laughs at the mandelbrot c++ entry
22:22:32 <dons> hmm, the current mandlebrot entry is not good. we already have much better entries on the wiki.
22:23:12 <dons> oh, sorry, it's the old entry that isn't good. not the #2 entry.
22:26:05 <Korollary> dons: I picked it up from the wiki
22:26:16 <Korollary> 10x slower than C and it scales with input
22:26:34 <boro> Can someone show me exapmle of using flip?
22:28:15 <Korollary> boro: I can't think of a good one right now. How about a bad one?
22:28:22 <Korollary> > flip map [1,2,3] id
22:28:23 <lambdabot> [1,2,3]
22:28:35 <Korollary> is the same as "map id [1,2,3]"
22:29:17 <boro> Korollary, teach me understand meaning of "."
22:29:27 <boro> like ((.).) 
22:29:53 <Korollary> boro: it's function composition. (f . g) x is the same as f (g x)
22:29:53 <boro> ((.).) (*) 4 (+3) 2 = 20
22:31:00 <boro> Korollary, hot to use iterate ?
22:32:12 <boro> A, okei, i know now :D
22:32:16 <ski> ((.).) (*) 4 (+ 3) 2  =  ((.) . (*)) 4 (+ 3) 2  =  (.) ((*) 4) (+ 3) 2  =  ((*) 4) ((+ 3) 2) = 4 * (3 + 2) = 20
22:33:19 <ski> (and 'iterate' is a quite hot function, yes)
22:38:39 <boro> Whats wrong here:  (takeWhile (not null) . iterate tail) [2,0,3]
22:40:53 <dons> not.null
22:41:22 <dons> as the compiler says: Probable cause: `not' is applied to too many arguments in the call (not null)
22:53:39 <boro> sky, how this is like you showd last one ((+4).(.(*3))) (+2) 1
22:58:38 <boro> ski
22:58:40 <boro> :)
22:59:54 <ski> boro : ?
23:03:27 <boro> ski, can you explain ((+4).(.(*3))) (+2) 1 like ((.).) (*) 4 (+ 3) 2  =  ((.) . (*)) 4 (+ 3) 2  =  (.) ((*) 4) (+ 3) 2  =  ((*) 4) ((+ 3) 2) = 4 * (3 + 2) = 20
23:05:29 <Saulzar> @type ((+4).(.(*3))) (+2)
23:05:31 <lambdabot> forall a. (Num (a -> a), Num a) => a -> a
23:06:25 <ski> hrm
23:06:36 <Saulzar> Heh, (Num a -> a)
23:06:42 <ski> ((.) .) (*)
23:06:52 <ski> this is a section, applies to argument
23:06:54 <ski> so
23:07:04 <ski> ((.) .) (*) = (.) . (*)
23:07:08 <ski> just like
23:07:17 <ski> (4 +) 3 = 4 + 3
23:07:18 <ski> and
23:07:31 <ski> (+ 3) 4 = 4 + 3
23:07:40 <ski> boro ..
23:07:41 <ski> so
23:07:57 <ski> ((.).) (*) 4 (+ 3) 2  =  ((.) . (*)) 4 (+ 3) 2
23:08:01 <ski> ok ?
23:08:09 <boro> jup
23:17:30 <Korollary> @hoogle (a -> a -> a) -> a -> a
23:17:32 <lambdabot> Prelude.flip :: (a -> b -> c) -> b -> a -> c
23:19:32 <Korollary> @hoogle a -> (a -> a -> a) -> a
23:19:34 <lambdabot> Prelude.flip :: (a -> b -> c) -> b -> a -> c
23:20:26 <sproingie> reading the "Monads as Containers" tutorial ... i started to lose track when he stopped talking about apples and blueberries 
23:21:05 <Korollary> lol
23:21:31 <sproingie> i fairly well understand how to use simple monads, but i still don't really know how they work
23:21:42 <sproingie> except for trivial ones like List and Maybe
23:22:46 <sproingie> knowing that >>= had an implicit join was useful.  i don't think many other tutorials mention that
23:23:44 <sproingie> one of 'em throws the lambda at you and babbles about CPS
23:24:10 <Korollary> well, lambda terms should be known
23:24:26 <Saulzar> Don't think it helps to try to understand them too much as a whole.. they're an abstraction, they can represent lots of different things
23:24:35 <sproingie> i'm starting to realize that
23:24:57 <Korollary> Saulzar: I actually refuse to look at them from a CT point of view. Just treat them like methods of yet another typeclass.
23:25:10 <Saulzar> Seems to be two general kinds of them though to me, one which the Monad _are_ the values of the computation (eg. List or Maybe)
23:25:19 <sproingie> and learning that like any good abstraction, people can play golf with 'em and bend your brain doing things you wouldn't expect
23:26:10 <Saulzar> Others are represented as functions to run in future, eg. State, Reader Cont  (or any of the Transformer monads)
23:26:53 <ski> the monad *is* the typeconstructor, plus the 'return' and '(>>=)' methods (satisfying the laws)
23:27:38 <boro> What was that paste page ?
23:27:52 <Korollary> lisppaste2: url
23:27:52 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
23:27:54 <ski> in List and Maybe, the monadic action (which is a value) (possibly) contains the result value(s) of the action
23:28:19 <ski> while in State, etc, you have a function that will return something that contains the monadic result
23:28:35 <ski> but, functions are also data, so the difference is not so big
23:29:05 <ski> e.g.  the type 'Bool -> a' is more or less the same as '(a,a)'
23:29:57 <lisppaste2> boro pasted "Problem" at http://paste.lisp.org/display/15414
23:30:04 <boro> Help anyone ?
23:30:16 <Saulzar> Yep, and when you use them it feels much the same - but it's good to know they're working a little differently internally
23:30:41 <sproingie> i still don't quite grok 'return'.  it seems the opposite of <- in a way, putting a value back into the monad
23:31:04 <Korollary> <- is just sugar, not an actual operator
23:31:08 <sproingie> do { x <- ["foo", "bar", "baz" ]; x }  -->  "foobarbaz" 
23:31:32 <sproingie> do { x <- ["foo", "bar", "baz" ]; return x }
23:31:32 <sproingie>  --> ["foo", "bar", "baz"]
23:31:48 <Saulzar> boro, Erk - too much in one go... can you split it up to several small functions to make it more clear?
23:31:53 <ski> (verbose) a 'monadic action' is something that will 'monadically return' a 'result'
23:31:59 <Korollary> Maybe is a simpler monad to study
23:32:03 <dons> x <- g ; ...  ==   g >>= \x -> ...
23:32:32 <sproingie> ok, i'm fried enough for one night
23:32:37 <sproingie> gnite all
23:32:40 <Korollary> nite
23:32:50 <ski> a 'monadic action' can also perforn some 'effect', the details thereof depends on the particular monad
23:33:07 <ski> 'return' takes a result value, and constructs a 'monadic action' that, when run, does no effects, and gives the result back
23:33:13 <ski> so, it makes a trivial action
23:33:33 <Korollary> I have this weird feeling that I have an errand to run, but I don't know what.
23:34:54 <ski> '(>>=)' takes an action, and a function from an intermediate result to another action, and constructs an action, that when run/performed, will run the first action, pass the result to the second arg, which gets us the second action (thus it can depend on first action's result), and then performs that action, finally returning the result of that action
23:35:17 <boro> Guestion.. If its' defined  function :: [Int] -> [Int] and function works fine with [1,2,3,4,5,6] when that definition part is commented. Why the hell function doesnt work, if it's not commented ???? :|
23:35:58 <boro> example.... blaa [1,2,3,4] = [2] ... Those both are [Int] ??
23:36:04 * ski guesses 'Guestion' is a mix of 'Guess' and 'Question' :)
23:36:23 <boro> Sorry, i'm not english :(
23:36:31 <ski> boro : more context needed
23:36:40 <boro> What you mean ? :P
23:37:06 <dons> > let f [1,2,3,4,5,6] = [2] in f [7] -- your code is weird
23:37:08 <lambdabot>  Non-exhaustive patterns in function f
23:37:10 <ulfdoz> boro: could you paste your code somewhere? (e.g. www.rafb.net)
23:37:15 <boro> Nope :P
23:37:17 <boro> Don't have time 
23:37:27 <boro> But usually, whats the problem ? :o
23:37:38 <dons> no one understands your problem, I think.
23:37:45 <ski> do you have a definition like
23:37:47 <dons> hence the requests for "more context"
23:37:48 <ski> function = ...
23:37:49 <ski> or like
23:37:53 <ski> function ... = ...
23:38:04 <boro> function list = other list
23:38:05 <ski> (i.e. with or without arguments to the left of '=')
23:38:12 <boro> with
23:38:20 <ski> ok .. weird
23:38:25 <boro> yes :S
23:38:37 <ski> how do you use the function ?
23:38:49 <ski> just in repl ? or call it from some other code in file ?
23:39:08 <boro> same file
23:39:40 <dons> it would be easier to paste the rrerror, and the code, somewhere. we'd have solved it by now..
23:39:58 <dons> less talk, more code! :)
23:40:02 <boro> Umm, i'm away soon..
23:40:03 <boro> http://paste.lisp.org/display/15414
23:40:09 <boro> here is a code
23:40:38 <boro> it's not working right now, don't know where is the problem. but idea is same
23:41:06 <dons> length list == 0 is not very efficient, you should use `null list'
23:41:52 <boro> Okei, but that not the problem right now
23:41:53 <boro> :S
23:41:54 <dons> reverse (tail (reverse .. ) == init
23:42:22 <boro> Umm
23:42:34 <ski> 'takeWhileSnd0 ([a++[list!!i]]) x (i+1)' looks weird
23:42:48 <ski> are you sure you didn't mean 'takeWhileSnd0 (a++[list!!i]) x (i+1)' ?
23:43:24 <ski> (since you are getting 'a' in as first arg to 'takeWhileSnd0')
23:43:45 <ski> boro : btw, did you get type error ?
23:43:51 <lisppaste2> boro pasted "Blah" at http://paste.lisp.org/display/15415
23:44:00 <boro> waird, now, it's working
23:44:03 <boro> OK, off now :P
23:44:27 <ski> (if so, did you get 'infinite type' ?)
23:44:29 <ski> hm
23:45:20 <ski> (ok, so 'twas that, then)
