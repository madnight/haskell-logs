00:13:16 <audreyt> rehi lambdafolks
00:29:03 <dons> heya audreyt
00:41:56 * araujo hates this
00:43:09 * araujo can't sleep
01:18:58 <Nanar> Hi
01:19:35 <Nanar> I just write an haskell program and I was very surprised by the haskell behaviour
01:19:47 <Nanar> http://mandrivafr.pastebin.com/507899
01:20:23 <Nanar> in fact it works very fine but I think explaining behaviour would help any newbies like me
01:20:40 <Nanar> is there a good place ?
01:20:55 <Nanar> and where ?
01:24:01 <gour> CosmicRay: ping
01:24:20 <Lemmih> Nanar: Any particular part you find confusing?
01:24:58 <araujo> @type getContents
01:25:00 <lambdabot> IO String
01:26:36 <araujo> Is thata directory function right?
01:27:11 <Nanar> Lemmih: the IO behaviour, it don't wait carraige return to works
01:28:00 <Nanar> Lemmih: in my exemple, if it found "@info@" all other letter I type are print immediatelly
01:29:21 <Lemmih> Nanar: That's because the result of 'getContents' is a lazy list.
01:30:03 <Nanar> Lemmih: yes yes I understand that, but I think this probably need explication for newbies
01:32:35 <Nanar> Lemmih: my goal is only to write a basic exemple of code to help, because it was hard to write those few lines
01:43:09 * drrho is away: pool swimming
01:45:28 <gour> anyone familiar with interfacing python & haskell?
01:50:49 <tuomov> yeah, but they didn't survive to tell about it
01:52:30 <gour> such a pain?
02:47:04 <Nanar> I have a line of words sparated by '@' char
02:47:18 <Nanar> how can I split the line ?
02:47:29 <Speck> Is there any way to find out what C-- code GHC would emit on any platform? (even PPC which C-- doesn't support)
02:47:50 * Nanar very newby but really trying to learn :)
02:47:56 <ibid> Nanar: look at span (it's not a perfect fit, but you can use it to build one)
02:48:36 <Nanar> ibid: else I can write  my own functions
02:49:26 <kosmikus> Nanar: there's a function "lines" that splits a string at occurrences of '\n'. Unfortunately, it isn't parameterized over the character to split at. However, you can perform that modification yourself by looking at the code of "lines".
02:49:47 <Nanar> kosmikus: good idea
02:50:25 <Speck> lines should be defined as split '\n' for the correct implementation of split
02:52:15 <kosmikus> yes, should be
02:52:37 <Lemmih> let words' fn [] = []; words' fn str = let (s,r) = break fn str in s:words' fn (dropWhile fn r) in words' (=='@') "hello@world"
02:53:02 <Lemmih> I believe it should be 'split (=='\n')'.
02:54:15 <Speck> Lemmih: more general, yeah... but maybe represent it as a fold over a function which returns a maybe, split at Just x
02:54:38 <Speck> *fold of a function that retuns a maybe for each character over the string
03:15:17 <Speck> @hoogle (a -> Bool) -> Maybe a
03:15:18 <lambdabot> Data.List.find :: (a -> Bool) -> [a] -> Maybe a
03:18:01 <dcoutts> @seen SyntaxNinja
03:18:02 <lambdabot> I saw SyntaxNinja leaving #haskell and #haskell-blah 2 days, 9 hours, 49
03:18:02 <lambdabot> minutes and 55 seconds ago.
03:28:41 <pesco> Anybody know what the time complexity of Data.Array.Unboxed.! is?
03:28:48 <Heffalump> linear, I hope..
03:28:50 <Heffalump> IM constant.
03:28:55 <Heffalump> (duh :-)
03:29:07 <Heffalump> any array access should be constant-time
03:29:18 <Heffalump> except perhaps to a historical DiffArray
03:29:33 <pesco> Are you sure? I thought the original arrays were actually search trees...
03:30:08 <pesco> Maybe I should measure it...
03:30:38 <tromp_> yes, it's O(1)
03:31:30 <pesco> tromp_: Cool, thanks!
03:32:18 * pesco starts using UArray.
03:34:41 <timbod> Hi All - is there a tidy syntax for expressing nested folds?
03:35:17 <audreyt> gfoldl?
03:36:34 <tromp_> hard to say without seeing code samples. timbod
03:37:33 <tromp_> maybe the inner folds are worthy of a new function definition?
03:37:48 <timbod> In imperative (ie non haskell) code, I would have nested loops, but  always seem to need to have a separate function for each nested fold in order to get the types right.
03:38:54 <tromp_> there's no need for that, it might just help clarity
03:39:02 <tromp_> hi Cale
03:48:11 <pesco> cptchaos: Moin Moin!
03:48:26 <pesco> cptchaos: Oh, you're only resetting... :/
03:49:02 <Nanar> how can I get the n element of a list ?
03:49:35 <tromp_> list!!n
03:49:40 <aleator> Nanar: list !! n. But you probably don't want to.
03:49:58 <Nanar> aleator: why ?
03:50:34 <aleator> Nanar: People asking that usually don't :) (ie. it is often bad thing to do with lists.)
03:51:18 <aleator> if you need to index use array.
03:51:37 <Nanar> aleator: I have 3 or 4 words list, sperated by @ on each line
03:52:39 <aleator> What do you want to do to it?
03:52:46 <aleator> or them?
03:52:54 <pesco> aleator: UArray has constant-time access! (Applying new knowledge yay! ;)
03:53:19 <aleator> pesco: :)
03:53:56 <Nanar> aleator: read the line, get each element
03:54:44 <Lemmih> Nanar: Sounds like a map.
03:55:19 <aleator> Nanar: You have one string? Or a list of words?
03:55:40 <Nanar> aleator: string like mamory-0.2.19-1plf.ppc@0@88463@Emulators
03:56:33 <aleator> ok. And you want a list of @ separated elements?
03:57:09 <Nanar> this is done, hum
03:57:32 <aleator> You already have a list of them? What next? 
03:57:38 <Nanar> my code look like this http://mandrivafr.pastebin.com/508016
03:57:48 * aleator begins to wonder if this actually is the case where one wants !!..
03:59:34 <Lemmih> I would say '[name,epoch,size,group] = splitat reste'
04:00:09 <Nanar> Lemmih: above the where ?
04:00:11 <Lemmih> Nanar: size(reste) == size reste, btw.
04:02:01 <Lemmih> Nanar: You can bind the info with a 'let'.
04:02:29 <pesco> What's everyone's suggestion for representing a sparse (symmetric) matrix? I need fast expansion (add new row+col), insertion (increase elem above 0), and multiplication with vectors.
04:07:37 <Nanar> I don't understand how it works but it works :)
04:07:42 <Nanar> many thanks
04:09:07 <Nanar> my code look this now: http://mandrivafr.pastebin.com/508027
04:28:36 <pesco> Okay, I want to represent dense vectors as (UArray Int Double). A straight-forward implementation of vector addition is (\x y -> accum (+) x (assocs y)). Is it worth the effort, wrt. time efficiency, to instead create the result array as a mutable STArray, write its elements in an iteration and freeze it to yield the result?
04:29:17 <pesco> Hm, am I asking too specialized questions?
04:30:45 <pesco> cptchaos: Have you dealt with something like this in your numerics code?
04:32:18 <gour> any lib available for computing min/max/lagrange interpolation etc. ?
04:37:47 <Saulzar> pesco, Would be interesting to see, give it a go? :)
04:38:30 <pesco> Saulzar: Yes, I'll make some measurements. Hah, so much to do...
04:39:25 <Saulzar> pesco, Also maybe parrallel arrays could be used... as there is a zipWithP ..
04:39:39 <Saulzar> Though I'm not sure what state they're in, or if they should be used :)
04:42:33 <Saulzar> But they seem like something which should be good for that kind of thing
04:46:42 <pesco> Saulzar: That's definately the case. I used them a few years ago with great success.
04:46:58 <pesco> Saulzar: Also made measurements at the time and they definately made anything else look like crap.
04:47:27 <Saulzar> Cool.
04:47:31 <pesco> Saulzar: However, I don't know about their current state either and want to avoid the dependency for the time being.
04:48:03 <Saulzar> They seem to be more like "real" arrays
04:48:09 * pesco nods.
04:48:57 <pesco> But it's a pity, the classical IArray interface is just lacking a few functions like zipWith and some fold.
04:49:10 * pesco frowns.
04:49:14 <Saulzar> It doesn't have any at all..
04:49:34 <Saulzar> Where as PArr seems to have them all
04:49:45 <pesco> Yep.
04:51:00 * Speck is curious about Oleg's "best collection traversal interfaces" research, but can't understand it
04:56:11 <Philippa> does anyone here know where to look for (possibly digested-for-newbies) research on incremental parsing of programming languages (as opposed to of natural languages)?
04:57:31 <Speck> not sure Philippa, but I'd like to know what incremental parsing of programming languages would be
04:57:32 <pesco> Speck: He claims that folds and unfolds should be provided as the native interface, right?
04:57:53 <Philippa> Speck: what you need for good IDE-type features
04:58:00 <Speck> pesco: a non-recursive left fold for languages without delimited continuations
04:58:10 <Speck> Philippa: ah, I think I know what you mean
04:58:26 <gour> dcoutts: ping
04:59:23 <Speck> pesco: I think I need a braindead example of an enumerator of simple fold over a list turned into a cursor
04:59:30 <pesco> Speck: Ah yeah, I see. One has to make oneself familiar with all this continuation stuff before Oleg can be properly understood. That's where I last left off... ;)
04:59:58 <Speck> is this Oleg-specific continuation stuff, or stuff I should know anyway (I don't know very much about continuations at all)
05:00:24 <pesco> I don't know; I have the impression that it will be generally helpful.
05:00:43 <Speck> could you recommend any particular reading that would help me understand?
05:05:16 <pesco> WRT. continuations, I have three pdf's on my desktop. The files are called danvy88some.pdf, danvy90abstracting.pdf, and danvy92representing.pdf.
05:05:38 <pesco> Did I rename them? Hm...
05:05:45 <Speck> sounds like citeseer papers, which I should be able to get
05:06:07 <pesco> Yes, but I'm not sure I got them that way. I have the habit of renaming everything citeseer-style.
05:07:02 <dcoutts> gour, pong
05:07:29 <pesco> Speck: I'll tell you the full names in a second.
05:08:05 <gour> dcoutts: hi, regarding the yesterday's point of documentaion tool..
05:08:06 <Speck> pesco: I found the three you just mentioned
05:08:17 <pesco> Speck: Ah, cool. :)
05:08:18 <dcoutts> gour, yeah?
05:08:30 <Speck> pesco: thanks for the refs
05:08:44 <pesco> Speck: No problem, always happy to share something.
05:08:58 <gour> dcoutts: i see that e.g. trac supports so called wikiprocessors, so one can use e.g. rst (http://docutils.sourceforge.net/rst.html)
05:09:13 <gour> dcoutts: offline and then submit into wiki, or directly
05:10:01 <gour> dcoutts: another possibility is to use txt2tags and convert text into moinmoin format which can be directly copy&pasted into trac wiki while creating new ticket
05:10:41 <dcoutts> gour, so one can process the wiki text through an prog running on the server which extend the markup?
05:10:52 <gour> dcoutts: i tried the 2nd method and it works nicely. try something with txt2tags, convert to moinmoinwiki and import into some trac wiki (eg. ghc), but don's submit :-)
05:11:04 <dcoutts> eg a Haskell prog which parses code blocks and highlights them as Haskell syntax with hyperlinks?
05:11:45 <gour> see http://projects.edgewall.com/trac/wiki/WikiProcessors
05:14:51 <gour> and http://projects.edgewall.com/trac/wiki/WikiMacros
05:15:17 <dcoutts> but can we use an external prog written in Haskell to do it, and do it automatically?
05:15:26 <gour> however, i'm not sure how one can interface python & haskell (pinged CosmicRay, but not pong), i.e. how to call Haskell from python?
05:15:45 <dcoutts> via invoking the program seperately
05:16:08 <dcoutts> by talking over a pipe
05:17:12 * gour is browsing http://projects.edgewall.com/trac/wiki/MacroBazaar
05:19:22 <gour> i was mostly thinking about the feature (you mentioned yesterday) that one can contribute both online & offline
05:20:42 <gour> dcoutts: here is one macro: include 
05:20:42 <gour> Inserts the output of an external URL. 
05:20:56 <gour> dcoutts: [[include(http://www.example.com/)]]
05:40:46 <dfhaii> afternoon
05:44:47 <dfhaii> can someone help
05:45:46 <dfhaii> i have a list of IO [(Int, String)] being returned from a function, and am trying to write a function i can feed to map with the list which replaces the int with one and keeps the string the same
05:46:05 <dfhaii> i can't get anything other than type errors out of hugs though
05:47:16 <psnl> dfhaii: first part of the haskell assignment?
05:47:19 <Speck> you have to be in the IO monad to use anything in the IO monad, like your list
05:47:20 <dfhaii> i have tried map (\(a,b) -> (1,b)) theList
05:47:29 <dfhaii> yeas it is psnl 
05:48:26 <dfhaii> my plan is to change them all to a one, then loop through looking for unique strings, adding them to a list, then looping through again and every time the same string comes up increment that number in the second list
05:48:31 <dfhaii> if that makes any sense
05:48:34 <psnl> agents<-fieldsFrom host requested-group "user-agent"
05:48:45 <Nanar> I create data: data Package = Pack { pname :: String, pgroup :: Maybe }
05:48:49 <psnl> map (\a,b)->(1,b) agents
05:49:12 <Nanar> How can I say to haskell that pgroup can be uninitialized ?
05:49:45 <psnl> Nanar: you need something after pgroup
05:50:06 <Nanar> psnl: wrong past: pgroup :: String
05:50:39 <dfhaii> :( more syntax errors
05:50:44 <Nanar> psnl: but pgroup can be simply empty
05:51:00 <pesco> Ooh! DiffArray is IArray but has constant-time update!
05:51:23 * pesco gets to work.
05:51:31 <psnl> Nanar: then have pgroup :: Maybe String and when you want it to be empty, you use Nothing
05:52:08 <psnl> dfhaii: my map is broken, \(a,b)->(1,b)
05:52:15 <Nanar> psnl: ah ok, I can't avoid: Fields of `Pack' not initialised: pgroup
05:52:23 <psnl> oh, I see
05:53:20 <psnl> Nanar: is that when you have something like Pack name ?
05:53:42 <dfhaii> the map i tried is map (\(a,b) -> (1,b)) but that gives me type errors
05:54:05 <psnl> which are?
05:54:24 <Nanar> psnl: faster: http://mandrivafr.pastebin.com/508094
05:54:39 <dfhaii> type [(a, [char])] does not match IO b
05:55:54 <psnl> Nanar: http://mandrivafr.pastebin.com/508096
05:56:44 <vincenz> Hello
05:57:07 <vincenz> Out of curiousity, is deforestation (orat least cheap deforestation) used in the haskell compilers?
05:57:51 <Nanar> psnl: ok understood
05:57:58 <Nanar> psnl: thanks
05:58:13 <psnl> dfhaii: thinking about it, a better way to solve your problem is to get a list of strings, sort the list, and then count the frequencies
05:59:18 <dfhaii> ok, i'll look into that
05:59:22 <dfhaii> thanks for the help
06:00:31 <psnl> thats how I did it
06:00:49 <dfhaii> you are a student here too?
06:00:53 <psnl> yep
06:01:11 <dfhaii> how far have you got?
06:01:19 <psnl> finshed ages ago
06:01:28 <dfhaii> :O congrats
06:03:42 <psnl> have you just started?
06:04:24 <dfhaii> i've been trying throughout the holidays, but have so far got nowhere
06:04:24 <CosmicRay> gour: pohng
06:04:27 <CosmicRay> err pong ;-)
06:04:50 <dfhaii> and am getting slightly concerned about how soon it is in
06:05:26 <psnl> unless you have someone to copy off, you might well be fucked
06:05:51 <dfhaii> better to be fucked than copy though
06:08:54 <Speck> hrm, if a left fold can be turned into a non-recursive left fold, what is the non-recursive left fold for: foldl (+) 0 [1..]
06:11:33 * beelsebob_ wonders where the fuck the QuickCheck symbols have gone
06:11:51 <beelsebob_> @paste
06:11:52 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
06:13:03 <beelsebob_> anyone see what's up there?
06:13:11 <beelsebob_> ... other than ld is being stupid
06:13:18 <gour> CosmicRay: hi
06:14:14 <gour> CosmicRay: seeing you're author of Missingpy, i wanted to ask about calling haskell from python
06:14:45 <CosmicRay> ok.
06:14:56 <CosmicRay> I have never attempted this, but go ahead, we'll see if I can shed any light ;-)
06:16:11 <gour> CosmicRay: how one can write haskell 'plugin' for python appliation?
06:21:10 <CosmicRay> gour: hmm......
06:21:16 <dcoutts> gour, you mean calling in-process
06:21:22 <CosmicRay> gour: you mean basically writing a Python module in Haskell?
06:21:28 <CosmicRay> gour: I have never used FFI to export things...
06:21:43 <dcoutts> I'd go via Haskell's FFI + Python's C API
06:21:47 <CosmicRay> gour: but I would assume that you would need to write a Python module in C in the normal way, and call into the exported Haskell routime
06:21:51 <gour> CosmicRay: writing a Python module in Haskell..
06:22:02 <CosmicRay> right, what dcoutts said.
06:22:18 <CosmicRay> gour: fortunately garbage collection in Python meshes decently with GC in Haskell, at least for going the other direction.
06:22:23 <beelsebob_> argh... what's it up to now...
06:22:31 <CosmicRay> gour: you could think of it as writing a C interface to the HAskell stuff, and then a Python interface to that.
06:22:59 <CosmicRay> gour: I don't know if MissingPy would be helpful to you in this, but if you think it might be, I'd encourage you to darcs get it, and do your hacking in darcs.  I'd integrate whatever patches you come up with.
06:30:53 <vincenz> no comments on deforestation?
06:31:44 <gour> CosmicRay: i am helping pida (http://http://pida.vm.bytemark.co.uk/projects/pida/wiki) devs with submitting bug reports, so, after saying, i'm interested for haskell, they are pushing for haskell-support and i wonder how it could be possible
06:32:23 <gour> dcoutts: i was thinking about 'your method' - common denominator via C api
06:33:53 <dcoutts> gour, you export make your Haskell functions using the FFI
06:34:02 <gour> CosmicRay: i'll take a look at your bindings
06:34:24 <dcoutts> then you write a python extension module in C which #includes the .h file for your exported Haskell functions
06:35:04 <gour> dcoutts: yep, i believe it is similar as extending e.g. Ruby (which i was looking at before haskell era)
06:35:45 <gour> dcoutts: btw, i posted urls for hs-plugins & yi to pida devs as well :-)
06:36:09 <dcoutts> gour, oh? you want to extend pida with Haskell? :-)
06:37:11 <gour> dcoutts: well, gvim is there, darcs.., gazpacho, what is missing?
06:37:27 <dcoutts> hIDE! :-)
06:37:53 <gour> dcoutts: the truth is pida devs wanted haskell support, cause it is meant to be language-independent ide
06:38:17 <gour> dcoutts: it looks hiDE is waiting for the future
06:38:17 <dcoutts> that'd be nice too
06:38:42 <dcoutts> well and for improvements I'm currently making to Gtk2Hs in the TreeView department
06:39:11 <gour> hIDE also reqs. newer ghc(api) ?
06:39:28 <dcoutts> gour, well some of the features do
06:39:34 <dcoutts> the GUI progress is independant
06:39:37 <dcoutts> hIDE will make havy use of list & tree widegts
06:40:03 <dcoutts> so improving the Gtk2Hs list/tree view widget APIs is important
06:40:12 <gour> i was able to crash pida badly and postponed beta release for a while, although man dev is very responsive
06:40:26 <dcoutts> we'll be able to implement the model in Haskell rather than having to proxy a C store
06:40:46 <gour> having things in haskell, is great
06:40:55 <dcoutts> so the trees will be able to be generated on demand and update dynamically (without great pain)
06:41:41 <gour> so there is still living force in hiDE or only in yourself?
06:43:35 <gour> dcoutts: btw, simon says: "import Insect as Ant -- which gives the local name Insect to the imported module Ant". is it true? (i thought it is vice versa)
06:44:10 <dcoutts> gour, well I'm working on the GUI and Lemmih & dons are waiting for ghc 6.6
06:44:54 <dcoutts> gour, "import Insect as Ant" imports the module called Insect and makes it available in the current module by the name Ant.
06:46:47 <gour> dcoutts: huh, so it is the error in the book...
06:46:57 <dcoutts> I guess so
06:47:23 <gour> 6.6 is scheduled for the spring?
06:47:56 <dcoutts> dunno
06:48:22 <dcoutts> gour, you can report the errata: http://www.cs.kent.ac.uk/people/staff/sjt/craft2e/
06:48:38 <dcoutts> the current errata page doesn't mention it
06:48:41 <dcoutts> http://www.cs.kent.ac.uk/people/staff/sjt/craft2e/errata.html
06:51:03 <gour> will do
06:55:00 <beelsebob_> anyone who plays with quickcheck hanging about now?
06:55:42 <vincenz> Do the latest haskell compilers use cheap deforestation?
06:58:19 <Cale> vincenz: I believe there's foldr/build deforestation
06:58:42 <gour> dcoutts: i sent remark to simon
06:58:44 <vincenz> Cale: does it implement all the prelude in function of them?
06:59:08 <vincenz> like in Gill's work
07:00:29 <dcoutts> gour, hey look: http://darcs.haskell.org/darcsweb/darcsweb.cgi?r=gtk2hs
07:00:41 <dcoutts> darcs browser for the Gtk2Hs repo :-)
07:00:53 <dcoutts> I've linked it from the Gtk2Hs deelopment page.
07:00:55 <rep> looks like gitweb
07:01:02 <Cale> You can look at how the Prelude is implemented yourself... http://darcs.haskell.org/packages/base/
07:01:33 <vincenz> thx
07:01:42 <Cale> There are a bunch of RULES pragmas for automatically translating various constructionds
07:01:48 <Cale> constructions*
07:01:56 <vincenz> where do I look?
07:02:00 * vincenz has never used haskell
07:02:05 <vincenz> ah nm
07:02:09 <dcoutts> vincenz, or: http://darcs.haskell.org/darcsweb/darcsweb.cgi?r=base;a=tree
07:02:52 <vincenz> where is basic stuff like map defined
07:03:04 <vincenz> got it
07:03:32 <vincenz> no build used :/
07:04:05 <vincenz> darn :D
07:04:17 <gour> dcoutts: who made it?
07:04:29 <Cale> vincenz: look for RULES pragmas
07:04:38 <dcoutts> gour, JaffaCake did. :-)
07:04:47 <JaffaCake> did what?
07:04:49 <dcoutts> JaffaCake, ta muchly for the new darcsweb!
07:04:55 <Cale> "filter"     [~1] forall p xs.  filter p xs = build (\c n -> foldr (filterFB c p) n xs)
07:05:00 <JaffaCake> you're welcome :)
07:05:27 <gour> Jay JaffaCake!
07:05:34 <Cale> "map"	    [~1] forall f xs.	map f xs		= build (\c n -> foldr (mapFB c f) n xs)
07:05:40 <Cale> vincenz: see? :)
07:05:59 <Cale> vincenz: that's in http://darcs.haskell.org/packages/base/GHC/Base.lhs
07:06:24 <vincenz> Oh
07:06:28 <vincenz> List.hs said something different
07:07:22 <Cale> List.lhs doesn't have a declaration for map, as far as I can see -- it just reexports it from Base
07:07:38 <vincenz> What does {-# RULES mean
07:08:03 <vincenz> is that pure comment
07:08:08 <vincenz> or does the compiler actually do something with tht
07:08:09 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/pragmas.html#rules
07:08:17 <Cale> it's a compiler pragma
07:08:22 <Cale> for rewriting
07:08:31 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/rewrite-rules.html
07:08:32 <vincenz> neat
07:08:37 <vincenz> yip
07:08:46 <vincenz> so you can tell the compiler to do optimizations by defining rules :)
07:08:50 <Cale> right
07:08:56 <vincenz> reminds me a bit of codeboost (albeit that it was yucky)
07:09:09 <saintiss> hi, I'm having some strange behaviour here:
07:09:14 <saintiss> isEmpty :: [a] -> Bool
07:09:14 <saintiss> isEmpty [] = True
07:09:14 <saintiss> isEmpty [x:xs] = False
07:09:20 <vincenz> Cale: is this ghc specifiic?
07:09:21 <saintiss> why is this not accepted?
07:09:26 <Cale> isEmpty (x:xs) = False
07:09:40 <Cale> [x:xs] is a list consisting of a single list element
07:09:45 <Cale> vincenz: yeah
07:10:00 <saintiss> Cale, ah, thanks
07:10:16 * vincenz should really learn haskell
07:10:26 <vincenz> I love the typeclass system to define algebras
07:11:06 <vincenz> Cale: however how does it handle lists that are written ini the code
07:11:08 <vincenz> like [1,2]
07:11:09 <saintiss> Cale, also, why can I not type this in the haskell shell? it is only accepted if I feed it from a file
07:11:10 <vincenz> or []
07:12:45 <Cale> saintiss: that's right, you can only make declarations in files
07:12:49 <Cale> vincenz: hm?
07:13:06 <Cale> If you type [1,2], that's desugared to 1:2:[]
07:13:16 <Cale> where : is cons
07:13:27 <flux__> saintiss, the second definition would work if the type declaration was isEmpty :: [[a]] -> Bool
07:13:51 <vincenz> Cale: right but if you want to use build...
07:13:57 <vincenz> I.e. foldr/build deforestation
07:13:59 <flux__> saintiss, and as you cannot write type declarations in interactive sessions, it induces the type
07:14:10 <vincenz> you need to have \c n -> 1 c 2 c n
07:14:27 <saintiss> another issue: is it possible to override e.g. the built-in + operator?
07:14:38 <flux__> :t (+)
07:14:51 <saintiss> flux__, right, thanks
07:14:57 <flux__> @type (+)
07:14:59 <lambdabot> forall a. (Num a) => a -> a -> a
07:15:40 <flux__> I'm not sure if you can (you propably can for a module context), but atleast you can make an instance of the class Num
07:15:48 <eivuokko> saintiss, built-in (+) is implemented in Prelude, if you want, you can provide your own implementation, but then you must (in practice) hide the one in Prelude on modules you use your +
07:16:03 <flux__> which will make it work with sum etc
07:16:44 <saintiss> wait, so + is syntactic sugar for "sum"?
07:17:00 <Saulzar> + is a function
07:17:10 <eivuokko> @type sum
07:17:11 <lambdabot> forall a. (Num a) => [a] -> a
07:17:13 <flux__> no, sum is just a function that takes a list of Nums and produces a Num
07:17:31 <saintiss> right
07:17:37 <dfhaii> wewt part1 done
07:17:39 <Saulzar> You can also implement Num for your own data types too, and just use the default + on them
07:17:42 <flux__> lambdabot doesn't have a way to lookup classes, does it?
07:17:57 <eivuokko> @index Num
07:17:58 <lambdabot> Prelude
07:18:00 <Saulzar> @info Num
07:18:01 <lambdabot> Unknown command, try @listcommands.
07:18:11 <flux__> @listcomm
07:18:12 <lambdabot> use listcommands [module|command]. Modules are:
07:18:12 <lambdabot> babel base code compose dice dict djinn dummy dynamic elite fact haddock
07:18:12 <lambdabot> help hoogle karma lShell localtime more pl plugs poll pretty quote search
07:18:12 <lambdabot> seen spell state system todo topic type version vixen where
07:18:27 <flux__> doesn't seem like it would
07:18:44 <Saulzar> Try :info Num in ghci 
07:19:11 <flux__> that's useful, thanks
07:19:14 <Cale> vincenz: oh, I'm not sure if any deforestation rules apply directly, but I can't be sure
07:20:39 <Cale> > let 1 + 1 = 3 in 1 + 1
07:20:41 <lambdabot> 3
07:21:03 * xerox points at cale
07:21:13 <beelsebob_> :o
07:21:52 <Cale> let x + y = x * y + y in 3 + 5
07:22:04 <Cale> infinite loop :)
07:22:07 <Cale> > let x + y = x * y + y in 3 + 5
07:22:09 <lambdabot> Exception: stack overflow
07:23:29 <Cale> > let 0 + x = x; x + 0 = x; x + y = succ x + pred y in 3 + 5
07:23:31 <lambdabot> 8
07:23:48 <xerox> heh.
07:24:09 <xerox> Somebody stops Cale in doing prolog in Haskell :)
07:24:28 <Cale> Oh, it's just recursion :)
07:24:53 <beelsebob_> > let cale = "stupid" in cale
07:24:55 <lambdabot> "stupid"
07:24:58 <beelsebob_> :P
07:25:30 <xerox> Nah :-)
07:26:48 <Cale> The important point here is that Haskell infix operators are actually just ordinary functions, and so can be rebound however you like. Also, as was mentioned, (+) and (*) are members of the typeclass Num, so you can define them for your own types by making an instance of Num, and take advantage of all the usual functions for working with numbers.
07:27:38 <vincenz> Cale: afaik deforestation rules are only valid if you also replace the constant lists ini your code (or at least the code undergoing deforestation)
07:29:04 <xerox> > let x + 0 = x; x + y = succ x + pred y in 3 + 5
07:29:06 <lambdabot> 8
07:29:09 <xerox> > let x + 0 = x; x + y = succ x + pred y in 0 + 5
07:29:11 <lambdabot> 5
07:29:13 <xerox> > let x + 0 = x; x + y = succ x + pred y in 0 + 0
07:29:15 <lambdabot> 0
07:29:18 <xerox> > let x + 0 = x; x + y = succ x + pred y in 4 + 0
07:29:20 <lambdabot> 4
07:29:25 <Cale> vincenz: well, if it doesn't do that, that would just be one place where you wouldn't get the optimisation.
07:29:30 <xerox> ....so you don't need the '0 + x = x' part, right?
07:29:37 <Cale> xerox: yeah
07:29:48 <flux__> > let x + 0 = x; x + y = succ x + pred y in (-4) + (-4)
07:29:54 <lambdabot> Terminated
07:29:57 <flux__> ;(
07:29:57 <xerox> Cough.
07:30:05 <Cale> for negative values you need extra rules
07:30:45 <xerox> > let 0 + x = x; x + 0 = x; succ x + pred y in (-4) + (-4)
07:30:47 <lambdabot>  parse error on input `in'
07:30:53 <xerox> > let 0 + x = x; x + 0 = x; x + y = succ x + pred y in (-4) + (-4)
07:30:54 <lambdabot> -8
07:31:22 <flux__> > let 0 + x = x; x + 0 = x; x + y = succ x + pred y in 4 + (-4)
07:31:27 <lambdabot> Terminated
07:32:37 <vincenz> blegh
07:32:41 <vincenz> what does this mean:
07:32:52 <vincenz> class (Eq k, Functor(m k)) => AssocX m k
07:32:54 <vincenz> and why is it not allowed
07:33:00 <flux__> > let 0 + x = x; x + y | y < 0 = y + x; x + y = succ x + pred y in 4 + (-3)
07:33:01 <lambdabot> 1
07:33:14 <Cale> vincenz: you need -fglasgow-exts to compile that
07:33:22 <vincenz> what does it mean tho
07:33:53 <Cale> that's a (multiparameter) typeclass declaration defining a class AssocX with parameters m and k whenever Eq k and Functor (m k)
07:34:00 <vincenz> ah
07:34:01 <vincenz> and this
07:34:06 <Cale> Eq k means that values of k are comparable for equality
07:34:10 <vincenz> newtype HashColl c a = H (c Int)
07:34:24 <vincenz> instance (UniqueHash a, CollX c Int) => CollX (HashColl c) a 
07:34:38 <vincenz>  H (c Int) is just the variant definition?
07:34:56 <vincenz> (and where did the a go to?)
07:34:56 <Cale> newtype defines a new type which is isomorphic to an existing one
07:35:19 <vincenz> right but is that a data constructor or a kind constructor?
07:35:23 <Cale> data
07:35:25 <vincenz> (err...type constructor)
07:35:27 <Cale> er
07:35:27 <vincenz> ah coolies :)
07:35:29 <Cale> which one?
07:35:37 <Cale> HashColl is a type constructor
07:35:38 <vincenz> newtype HashColl c a = H (c Int)
07:35:45 <Cale> H is a data constructor
07:35:46 <vincenz> where does the 'a' go to?
07:36:02 <Cale> It's just not used
07:36:06 <vincenz> and how can H be a data constructor if it has an Int
07:36:11 <vincenz> H (c Int)
07:36:21 <vincenz> oh
07:36:21 <vincenz> hmm
07:36:22 <vincenz> nm
07:36:32 * vincenz is new at haskell but reading some papers that requirie him to decipher it
07:36:46 <Cale> So, for instance,  HashColl [] Double  and  HashColl [] String  are different types, but implemented the same way.
07:36:51 <vincenz> ah
07:37:14 <vincenz> so how about
07:37:18 <vincenz> instance (UniqueHash a, CollX c Int) => CollX (HashColl c) a
07:37:22 <vincenz> the precedence seems wrong
07:37:29 <vincenz> on the part on the right
07:37:34 <Cale> My guess is that there's probably some extra class of types which get defined to control the operation of various class instances depending on the otherwise unused type parameter
07:37:49 <vincenz> it's for a collection library (Edison)
07:37:49 <Cale> CollX has 2 parameters
07:37:57 <vincenz> but so did HashColl
07:37:58 <Cale> Yeah, I kinda recognise it
07:37:59 <vincenz> yet only one is given
07:38:21 <Cale> It probably wants a type constructor as its first parameter
07:38:32 <Cale> of kind * -> *
07:38:35 * vincenz nods
07:38:42 <Cale> so that's just partial application
07:39:04 <vincenz> that's why I always flip on haskell code, it's hard to read
07:39:07 * vincenz comes from ocaml
07:39:21 <Cale> well, this is some pretty heavy stuff as far as typeclasses go
07:39:43 <vincenz> that and the fact that you often use so many different symbols that you have to know what they all do
07:39:56 <vincenz> instead of using nicie functionnames that are legible :D
07:40:07 <vincenz> anyways, it said that the previous was not possible either
07:40:13 <Cale> that just depends on who's writing the code :)
07:40:25 <vincenz> the Int in Collx c Int on the right side is not allowed
07:40:38 <Cale> what's the error?
07:40:44 <vincenz> no that's what it saiid in this paper
07:40:48 <Cale> oh
07:40:55 <vincenz> An Overview of Edison - Okasaki 200
07:40:56 <vincenz> 2000
07:41:13 <Cale> oh, that might be from a time when it wasn't allowed :)
07:41:18 * vincenz grins
07:41:29 <vincenz> basically I should read that as a partially specialized template
07:41:34 <vincenz> (in c++ lingo)
07:41:38 <vincenz> only allowing Collx c Int
07:41:53 <vincenz> and not CollX c somethingelse
07:42:19 <Cale> instance (UniqueHash a, CollX c Int) => CollX (HashColl c) a -- this means that the given instance of the class only applies when the preconditions of UniqueHash a and CollX c Int apply.
07:42:30 <vincenz> oh
07:42:31 * vincenz nods
07:42:38 <vincenz> and then you can define more optimal methods
07:42:56 <Cale> That is, if we have an instance CollX c Int, and also UniqueHash a, then we can derive from it an instance CollX (HashColl c) a
07:43:11 <vincenz> with as extra specialization...
07:43:16 <vincenz> single = single . hash
07:43:21 <Cale> probably,  I'd have to read the paper :)
07:43:26 <vincenz> that's what it said
07:43:32 <vincenz> I should prolly learn ocaml
07:43:35 <vincenz> it would ease my life
07:43:38 <vincenz> I mean haskell
07:44:10 <vincenz> I take it that ghc is the most popular compiler
07:44:16 <Cale> Yeah, it's really quite nice once you get used to it :) Typeclasses are getting very expressive these days.
07:44:23 <vincenz> yeah
07:44:33 <vincenz> I always wish tehy would invent a type-classed, strict, oo-syntax lang
07:45:03 <Cale> Yeah, I was thinking about that.
07:45:30 <Cale> However, I always realise that I could just write a suitable monad and not have to actually leave Haskell :)
07:45:37 <vincenz> heh
07:45:41 <Cale> well, except for the proper OO part
07:45:45 <vincenz> Except Haskell is inherently lazy
07:45:49 <Cale> but that'll be fixed in GHC 6.6
07:45:50 <vincenz> so you lose some on efficiency
07:45:54 <Cale> possibly
07:45:59 <Cale> you can make things strinct
07:46:02 <Cale> strict*
07:46:06 <flux__> maybe eager haskell will some day fix that :)
07:46:13 <vincenz> "Pattern guards and transformational patterns" - Simon Peyton Jones
07:46:15 <vincenz> interesting?
07:46:16 <Speck> cale, are you familiar with oleg's "best collection traversal interface" code?
07:46:27 <Cale> Speck: maybe...
07:46:29 <vincenz> Speck: got a link?
07:46:56 <Cale> http://okmij.org/ftp/Computation/Continuations.html#enumerator-stream
07:47:04 <Speck> http://okmij.org/ftp/Scheme/enumerators-callcc.html I think is the general concept, but the Haskell implementation is really messing with me: http://okmij.org/ftp/Haskell/misc.html#fold-stream
07:47:07 <SamB> Cale: what will be fixed in 6.6?
07:47:14 <Cale> SamB: OO in Haskell
07:47:21 <SamB> Cale: how?
07:47:33 <vincenz> haskell has call/cc?
07:47:40 <Cale> GADTs/Existential types with record syntax
07:47:58 <vincenz> GADTS = ?
07:47:58 <Cale> vincenz: no, but it does have a continuations monad which has call/cc
07:48:00 <liyang> oooh, shiny.
07:48:04 <SamB> vincenz: in an appropriate monad with an appropriate name (but an unfortunately inappropriate type)
07:48:08 <Cale> Generalised Algebraic Data Types
07:48:21 <vincenz> Oh is this the thing with the existence quantifier?
07:48:23 <Cale> http://www.haskell.org/hawiki/Existentially_20quantified_20record_20constructors
07:48:37 <vincenz> not that I knkow much about formal type theory but I read some here and there
07:48:40 <SamB> Cale: hmm? how does that fix OO in Haskell?
07:48:47 <Cale> look at the wiki page :)
07:48:58 <vincenz> will do
07:49:00 <SamB> I am
07:49:29 <Cale> Well, you can already do this sort of thing with existential types, but this makes it quite pretty
07:49:55 <Speck> Cale: it seems to require a good understanding of the relationship between Y and call/cc, but I don't really understand this. Your explanations have helped me out before, so I was wondering if you had any insights.
07:50:29 <vincenz> ooh
07:50:33 <Cale> Speck: it's been a while since I've looked at that, so I'm not familiar with it
07:50:36 <vincenz> Cale: I assume it uses a vtbl?
07:50:44 <Cale> vincenz: vtbl?
07:50:51 <vincenz> virtual table
07:50:57 <Cale> what's that?
07:51:00 <Speck> Cale: ok, no problem. I just got curious about generics/standard collection interfaces
07:51:02 <vincenz> aka a lookup table so it can't decide at compile time which function to call
07:51:20 <vincenz> cause counterA and counterB can be thrown through each other
07:51:24 <Cale> vincenz: I think it's handled by passing dictionaries.
07:51:32 <vincenz> right
07:51:34 <vincenz> a vtbl ;)
07:51:44 <vincenz> (c++ lingo)
07:51:56 <vincenz> what's so special about leaving out the forall in that example?
07:52:06 <SamB> vincenz: sort of
07:52:18 <vincenz> and what's that tag for?
07:52:48 <Cale> vincenz: just prettier syntax for the same thing. The tag is just to show use of a publicly accesible field
07:52:55 <vincenz> oh
07:52:56 * vincenz nods
07:53:13 <SamB> JHC handles type classes differently, though...
07:53:24 <Cale> With the GADT syntax, you can do more than with just existentials though
07:53:34 <vincenz> such as what
07:53:38 <gour> SamB: how useful is JHC atm?
07:53:38 <Cale> yeah, it's really implementation dependent
07:53:42 <SamB> gour: dunno
07:53:43 <vincenz> and how is this existential?
07:53:48 <vincenz> the fact you put self on the left AND right side of the .?
07:53:54 <vincenz> (ini the forall construct)
07:53:56 <SamB> its probably too slow for me to do anything with it anyway
07:54:09 <vincenz> forall x.dosomethingwith x
07:54:14 <gour> SamB: ok. we'll wait then
07:54:41 <vincenz> data B a = forall foo.NewCounter foo * foo
07:54:45 <Cale> vincenz: It's because for each value of type Counter a, there exists a type self which applies
07:54:45 <SamB> gour: well, keep in mind that I have a PII 450
07:54:48 <Speck> gour: I think it chokes on large programs still, due to whole-program optimizations
07:54:54 <vincenz> data B a = forall foo.NewCounter foo * foo*aa
07:54:59 <SamB> and 256 MB of RAM
07:55:05 <Cale> vincenz: the current syntax is a bit confusing, which is why the GADT syntax is preferred
07:55:11 * vincenz nods
07:55:24 <vincenz> just trying to figure out what it really means, conceptually
07:55:40 <Cale> well, I shouldn't say current, since the GADT syntax is implemented :)
07:55:48 <Cale> 'older' perhaps :)
07:56:31 <SamB> Cale: current refers to GHC 6.4 still, doesn't it?
07:56:59 <SamB> or else you would say "has been fixed in GHC 6.6"
07:57:06 <Cale> SamB: well, neither of these record syntaxes are permitted in 6.4, though both are permitted without the record syntax
07:57:15 <SamB> oh.
07:57:23 <SamB> in that case, older is a better way to say it.
07:58:16 <gour> SamB: ohh, important detail :-)
07:58:26 <vincenz> what's a good source to learn ocaml
07:58:31 <gour> Speck: but it is a promising one?
07:58:31 <vincenz> blegh
07:58:32 <vincenz> haskell
07:58:35 <vincenz> just haskell.org
07:58:40 <vincenz> or is ther esome great tutorial out there
07:59:02 <Cale> The data declaration means that values of type Counter a are constructed by making for all types 'self', a record of the form NewCounter { _this :: self, _inc :: self -> self, _display :: self -> IO (), tag :: a }
07:59:14 <SamB> hmm. there is a lot of spam coming into the Conjure list...
07:59:18 <Cale> vincenz: Yet Another Haskell Tutorial is quite good
07:59:22 <vincenz> thx
07:59:23 <gour> SamB: well, year and half ago i had celeron 566/256
07:59:27 <Cale> @google Yet Another Haskell Tutorial pdf
07:59:28 <lambdabot> http://www.isi.edu/~hdaume/htut/tutorial.pdf
07:59:40 <vincenz> aha, lambdabot
07:59:44 <vincenz> a prime example of unreadable code
08:00:10 <Cale> vincenz: if you're already really familiar with functional programming, you might even start with the (not-so-) Gentle Introduction to Haskell
08:00:11 <gour> SamB: and building ghc lasted forever (now i'm on amd64/1gb)
08:00:24 <vincenz> I consider myself an ocaml guru
08:00:51 <vincenz> @google Gentle Introduction to Haskell
08:00:52 <lambdabot> http://www.haskell.org/tutorial/
08:01:06 <Cale> vincenz: Well, I'm not sure really how it would be, but perhaps try the Gentle Intro, it's pretty terse anyway
08:01:07 <gour> vincenz: what brings you to haskell, guruji :-)
08:01:26 <vincenz> gour: recent papers I've been reading
08:01:33 <vincenz> like the deforestation stuff
08:01:42 <vincenz> and I've always envied type classes over functor
08:01:53 * SamB wonders if he would understand lambdabot's search module anymore
08:02:04 <gour> vincenz: welcome..
08:02:13 <vincenz> thx
08:02:16 <vincenz> not new here tho
08:02:20 <vincenz> I used to chat a lot with shapr
08:02:42 <vincenz> and jjust hang out for the channel's friendliness (besides it's the only place wher eyou can ask algorithmically complex questions)
08:02:49 <Cale> lambdabot isn't that unreadable... dons did a reasonably good job of cleaning things up. I'm sure it could still be cleaner though.
08:02:50 <vincenz> ocaml's nearly dead
08:02:57 <vincenz> and the other channels are ..-brain- dead
08:03:03 <gour> lol
08:03:13 <vincenz> :P
08:03:23 * gour gald to choose learning haskell over other fp languages
08:03:36 <vincenz> I like ocaml's speed
08:03:43 <vincenz> I wrote a toolkit in it that would've been prohibitive in other languages
08:04:23 <Cale> vincenz: When I was working on a common lisp application, I asked how to get the compiler to stop complaining when I didn't use one of my function's parameters, say, to write a constant function, and I was met with confusion as to why you'd ever want a constant function.
08:04:26 <gour> vincenz: you have seen latest shoutout results?
08:04:32 <Cale> (in #lisp)
08:04:45 <Cale> eventually someone more clueful came along, but it was just sort of funny
08:05:20 <Cale> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
08:05:51 <vincenz> gour: no
08:06:03 * gour believes Cale is sort of a cheater
08:06:03 <Cale> (that's the link to the shootout results)
08:06:13 <Cale> gour: hm?
08:06:21 <vincenz> o.O
08:06:22 <vincenz> o.O
08:06:23 <gour> :-)
08:06:23 <vincenz> o.O
08:06:27 <vincenz> ghc scores over ocaml?
08:06:33 <gour> lol
08:06:38 <Cale> yeah.
08:06:47 <vincenz> holy crapparoli
08:06:57 <Cale> We only have a little way to go to beat gcc too
08:07:03 <vincenz> I remember when it was likek 10 times slower
08:07:12 <Cale> (though they haven't implemented 3 of the programs)
08:07:21 <vincenz> see I have this tool that analyzes profiling data (like a couple of gigabytes worth)
08:07:39 <vincenz> it's rather side-effect full
08:07:44 <vincenz> cause I build up tables as Ii parse this data
08:07:47 <vincenz> and keep an active environment
08:08:09 <Cale> Truth in advertising, basically the entire Haskell community has been working on solutions to the shootout problems for the last couple of weeks.
08:08:26 <vincenz> oh
08:08:30 <vincenz> so specific optimization
08:08:42 <vincenz> and most likely not code one would typically write ?
08:08:51 <Cale> Surprisingly though, it's the most elegant programs that often win.
08:09:11 <Cale> Though I think there's still a few places where the technique has been unbox everything
08:09:30 <vincenz> I take it that
08:09:33 <vincenz> !Integer is a reference
08:09:36 <vincenz> ?
08:09:37 <Cale> no
08:09:40 <vincenz> oh
08:09:40 <Cale> strict field
08:09:43 <vincenz> meaning?
08:09:55 <Cale> I presume you're looking at a data declaration?
08:10:01 <vincenz> yeah
08:10:09 <vincenz> data F = F !Integer (repeated 4 times)
08:10:37 <Cale> It means that when the value of type F is constructed, the Integer will be computed too
08:10:44 <vincenz> ah
08:10:45 <vincenz> no lazyness
08:10:46 <vincenz> :)
08:10:49 <Cale> right
08:10:55 <SamB> well, the spec says it is like an $! before that field gets applied to the constructor...
08:11:17 <vincenz> I wonder why D keeps winning and who the hell uses D
08:11:27 <Cale> oh, yeah, I suppose there's funny things when you mix and match strict and non-strict fields
08:11:44 <SamB> in addition to providing strictness, it also allows the compiler to unbox that field if desired...
08:11:50 <Cale> right
08:12:11 <freshness> how can i abbort a rekursion?
08:12:18 <Cale> so if you run GHC with -funbox-strict-fields, you'll get a more compact data representation.
08:12:25 <Cale> freshness: Ctrl-C? 
08:12:29 <SamB> freshness: by not recursing again
08:12:30 <Cale> or do you mean something else?
08:12:37 <Cale> define a base case?
08:12:40 <freshness> no i mean in the program text
08:12:40 <vincenz> freshness: tailcall whipping your ass?
08:12:52 * vincenz shudders
08:13:03 <SamB> freshness: typically through something called a "base case"
08:13:15 <vincenz> how is the library support in haskell
08:13:21 <Cale> vincenz: getting pretty decent
08:13:21 <vincenz> for stuff liike gui or networking or concurrency
08:13:27 <SamB> vincenz: good and getting better
08:13:29 <vincenz> that
08:13:36 <vincenz> 's a sad thing ini the ocaml community, it's so STALE
08:13:36 <SamB> well, the networking stuff needs some work
08:13:39 <vincenz> :/
08:13:40 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/index.html -- this is the stuff included with GHC
08:13:52 <vincenz> nice GLUT :)
08:13:54 <SamB> just yesterday I had to fix an Fd leak in Network.HTTP...
08:14:23 <Cale> vincenz: yeah, and parser combinators, and graph theory libraries and all sorts of cool stuff :)
08:14:34 <Cale> vincenz: there's also a gtk2 binding called gtk2hs
08:14:37 <SamB> XML too
08:14:45 <Cale> and yeah, some really cool XML bindings
08:14:56 <Cale> or libraries
08:15:00 <SamB> Cale: not bindings, libraries ;-)
08:15:04 <Cale> yeah
08:15:22 <cptchaos> *Big Lag Warinig*: pesco: I have only dealt with sparse matrices, so I used Map.Map (wich hase no unboxed counterpart like array for some reason). But with a map addition is simply done with unionWIth  
08:15:27 <Cale> I actually did stop and wonder how they were implemented after I typed that :)
08:15:39 <SamB> HXT uses Parsec
08:15:49 <Cale> http://haskell.org/gtk2hs/docs/current/
08:16:11 <vincenz> XML...
08:16:14 <SamB> HXT is apparantly the coolest
08:16:55 <SamB> taking the abstractions the farthest and having such cool features as Relax NG...
08:17:23 <Cale> http://www.fh-wedel.de/~si/HXmlToolbox/hdoc/index.html
08:18:46 <SamB> though I *had* hoped to implement relax ng myself, so that was a bit disappointing...
08:18:55 <SamB> on the other hand, I probably would have failed
08:19:06 <xerox> What is 'relax ng'?
08:19:07 <Cale> anyway, when I started writing Haskell code a couple of years back, there were lots of library support issues to complain about, and now I pretty much can't complain.
08:19:40 <Cale> http://www.relaxng.org/
08:20:08 <Spum> Ello
08:20:14 <Cale> heh, "The RELAX NG specifications have been developed within OASIS by the RELAX NG Technical Committeee."
08:20:27 <xerox> Hah.
08:20:28 <Cale> Committeeeeeeeee!!
08:20:37 <xerox> A RELAX OSASIS.
08:20:46 <SamB> Cale: where did Haskell come from?
08:21:01 <Cale> SamB: Miranda
08:21:02 <mahogny> SamB, offspring of Miranda
08:21:27 <SamB> well, there was a RELAX before RELAX NG...
08:21:37 <Cale> Spum: hello
08:21:49 <SamB> but I was talking about the commitee
08:22:22 <Cale> SamB: I was talking about the humourous typo.
08:22:49 <SamB> ah
08:23:20 <SamB> yeah, I guess there probably aren't supposed to be three Es in commitee
08:23:33 <SamB> though beyond that I make no claims as to its spelling
08:26:29 <ihope> > let acro = (map head . words) ("This acronym (" ++ acro ++ ") is not arbitrary.") in acro
08:26:30 <lambdabot> Exception: <<loop>>
08:26:36 <ihope> Eh?
08:26:37 <Spum> Sorry, i'm new to Haskell
08:26:42 <Spum> what kind of language is it?
08:26:47 <ihope> Functional.
08:27:09 <Cale> Spum: It's a purely functional language with lazy evaluation.
08:27:50 <Philippa> ihope: you wanted the in earlier and to apply the function to something, no?
08:27:52 <Cale> and generally lots of really cool features :)
08:28:27 <ihope> No; I wanted that to evaluate to "TaTina".
08:28:33 <Philippa> > let acro = (map head . words) in ("This acronym (" ++ acro "three letter acronym" ++ ") is not arbitrary"
08:28:36 <lambdabot>  parse error on input `}'
08:28:55 <ihope> Parenthesis!
08:28:57 <Philippa> > let acro = map head . words in ("This acronym (" ++ acro "three letter acronym" ++ ") is not arbitrary")
08:28:59 <lambdabot> "This acronym (tla) is not arbitrary"
08:29:08 <Philippa> you prolly want a toUpper in there
08:29:30 <Philippa> Spum: want an explanation of that code?
08:29:30 <int-e> ihope: but how is words supposed to know that acro does not return any spaces?
08:29:43 <ihope> Good question, indeed!
08:30:10 <Philippa> ihope: you needed two values in the let, then
08:30:18 <SamB> what is with the display of the output for mandelbrot?
08:30:18 <Philippa> that lets you be recursively silly
08:30:37 <ihope> Hm..
08:30:46 <ihope> Eek, double typo.
08:30:48 <ihope> Hmm...
08:31:08 <int-e> > let acro = map head words; words = ["This", "acronym", acro, "is", "not", "arbitrary."] in unwords words
08:31:10 <lambdabot> "This acronym TaTina is not arbitrary."
08:31:40 <ihope> Cool.
08:37:05 <ihope> Still, in my original thing, a very, very lazy compilerthing would be able to produce the correct output...
08:39:35 <int-e> > let acro = (map head . words) ("This acronym (" ++ acro ++ ") is not arbitrary.") in take 3 acro
08:39:36 <lambdabot> "Ta("
08:40:11 <int-e> > let acro = (map head . words) ("This acronym " ++ acro ++ " is not arbitrary.") in take 3 acro
08:40:12 <lambdabot> "TaT"
08:40:24 <Cale> ihope: no, it really shouldn't be able to, since it's actually defined in terms of itself in a way which doesn't resolve to it being defined to anything in particular
08:40:49 <int-e> it works to that point - how is a compiler/RTS supposed to figure out the next letter? it'd have to be very, very clever.
08:41:07 <ihope> And that's the cleverness I'm looking for...
08:41:42 <Cale> ihope: It has to be impossibly clever
08:41:52 <ihope> Really?
08:41:58 <Cale> yeah
08:42:35 <ihope> Isn't it provable that (map head . words) never returns anything containing spaces?
08:43:03 <xerox> ...words will never too.
08:43:07 <int-e> consider, for example, let acro = cycle "Ta" in map head $ words ("The acronym " ++ acro)
08:43:32 <ihope> @type cycle
08:43:34 <lambdabot> forall a. [a] -> [a]
08:43:47 <ihope> Is that the infinite concatenation?
08:43:50 <int-e> yes
08:43:55 <ihope> Cool.
08:44:08 <ihope> So (sequence_ . cycle) is what I've really been looking for?
08:45:02 <xerox> @type Control.Monad.sequence_ . cycle
08:45:04 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
08:45:13 <ihope> >:-)
08:45:21 <xerox> @type Control.Monad.sequence_
08:45:23 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
08:45:30 <xerox> heh.
08:45:33 <int-e> anyway, the point I was trying to make was that you also run into problems of termination - "TaTaTa..." contains no spaces. How is "TaT"<program produces no further output> distinguishable from that?
08:45:39 <Cale> ihope: what are you trying to do?
08:45:54 <ihope> Just a second...
08:46:09 <ihope> @pl \x -> putStr x >> getLine
08:46:10 <lambdabot> (>> getLine) . putStr
08:46:22 <Cale> heh
08:46:59 <ihope> (sequence_ . cycle) [putStr "Press ENTER to see how an idiot spends his/her time...", getLine]
08:47:14 <xerox> Cool :-)
08:47:21 <xerox> @type Control.Monad.repeatM
08:47:22 <Cale> only it's a type error
08:47:22 <lambdabot> Not in scope: `Control.Monad.repeatM'
08:47:24 <xerox> @type Control.Monad.repeat_
08:47:26 <lambdabot> Not in scope: `Control.Monad.repeat_'
08:47:39 <xerox> @type Control.Monad.repeatM_
08:47:40 <lambdabot> Not in scope: `Control.Monad.repeatM_'
08:47:43 <Cale> (sequence_ . cycle) [putStr "Press ENTER to see how an idiot spends his/her time...", getLine >> return ()]
08:47:45 <xerox> @index repeat
08:47:46 <lambdabot> Data.List, Prelude
08:47:49 <xerox> @index repeatM
08:47:50 <lambdabot> bzzt
08:48:25 <dcoutts> hey xerox, tried the svg cairo stuff yet? :-)
08:48:48 <int-e> sequence_ . repeat $ putStr "Press ENTER to see how an idiot spends his/her time..." >> getLine
08:49:34 <xerox> dcoutts: not yet :(
08:49:37 <ihope> Why not infixl `id` 0?
08:49:43 <ihope> ...Or whatever?
08:49:59 <Cale> ihope: hm?
08:50:13 <ihope> Use `id` instead of $?
08:50:21 <xerox> @type ($)
08:50:23 <lambdabot> forall b a. (a -> b) -> a -> b
08:50:24 <xerox> @type id
08:50:26 <lambdabot> forall a. a -> a
08:50:31 <xerox> Wah, right?
08:50:40 <int-e> @type id :: (a->b) -> a -> b
08:50:42 <lambdabot> (a->b) -> a -> b :: forall a b. (a -> b) -> a -> b
08:50:49 <Cale> You could, but there's something to say for self-documenting-ness
08:50:58 <Cale> $ means function application
08:51:07 <Cale> whereas id really just means the identity function
08:51:10 <ihope> let apply = id :: (a -> b) -> a -> b
08:51:18 <int-e> lambdabot: are you sure you want to cut at the *first' ::?
08:51:20 <Cale> (even if they are the same thing really)
08:52:00 <Cale> > zipWith ($) [(*5), (+3)] [1,2]
08:52:00 <ihope> @type ap const
08:52:01 <lambdabot> [5,5]
08:52:02 <lambdabot> Not in scope: `ap'
08:52:07 <ihope> @index ap
08:52:07 <int-e> except $ has a more restricted type.
08:52:08 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.
08:52:08 <lambdabot> State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont,
08:52:08 <lambdabot> Control.Monad.Error, Control.Monad.List, Data.Graph.Inductive.Query.
08:52:08 <lambdabot> ArtPoint, Data.Graph.Inductive.Query, Data.Graph.Inductive
08:52:09 <Cale> > zipWith id [(*5), (+3)] [1,2]
08:52:11 <lambdabot> [5,5]
08:52:20 <ihope> @type Control.Monad.ap const
08:52:22 <lambdabot> forall a a1. (Monad ((->) a1)) => (a1 -> a) -> a1 -> a1
08:52:32 <xerox> ihope: heh.
08:52:35 <Cale> sure, they're the same, but I think zipWith ($) gets the idea across better than zipWith id
08:52:44 <xerox> @type Control.Monad.Fix.fix . return
08:52:46 <lambdabot> forall a. (Monad ((->) a)) => a -> a
08:52:49 <xerox> :-)
08:52:58 <ihope> @type Control.Monad.ap const undefined
08:52:59 <lambdabot> forall a. (Monad ((->) a)) => a -> a
08:54:10 <int-e> @type let ap x=Control.Monad.ap x in ap (ap const const) (ap const const)
08:54:11 <lambdabot>   Occurs check: cannot construct the infinite type: b = b -> b1
08:54:11 <lambdabot>   Expected type: (b -> b1) -> a -> b
08:54:35 <Cale> It's too bad that $ can't work with higher rank types
08:54:41 <ihope> > Control.Monad.ap id id
08:54:42 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> b
08:54:42 <lambdabot>   Expected type: (a -> b) -> a
08:54:42 <lambdabot>   Inferred type: (a -> b) -> a -> b
08:55:22 <int-e> @pl ap (ap const const) (ap const const)
08:55:23 <lambdabot> join id
08:55:33 <Cale> > return (,) `ap` [1,2,3] `ap` [4,5,6]
08:55:34 <lambdabot> [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
08:56:05 <ihope> @pl ap id id
08:56:06 <lambdabot> join id
08:56:13 <ihope> ...Right, right
08:56:25 <xerox> @pl ap
08:56:26 <lambdabot> ap
08:56:29 <xerox> @pl ap id
08:56:30 <lambdabot> ap id
08:56:35 <xerox> @pl ap return return
08:56:36 <lambdabot> ap return return
08:56:42 <Cale> @pl ap . return
08:56:43 <lambdabot> fmap
08:56:54 <ihope> @type Control.Monad.ap return return
08:56:56 <lambdabot> forall a (m :: * -> *).
08:56:56 <lambdabot> (Monad ((->) a), Monad ((->) (m a)), Monad m) =>
08:56:56 <lambdabot> a -> a
08:57:24 <Cale> @pl \f x y -> return f `ap` x `ap` y
08:57:26 <lambdabot> liftM2
08:57:57 <Cale> @pl \f a b c d e f g -> return f `ap` a `ap` b `ap` c `ap` d `ap` e `ap` f `ap` g
08:58:13 <lambdabot> const (((((const .) .) .) .) . flip flip id . ((flip . ((flip . ((flip . (
08:58:13 <lambdabot> (ap . (ap .)) .)) .)) .)) .) . flip flip id . ((flip . ((flip . ((flip . (
08:58:13 <lambdabot> (ap . (ap .)) .)) .) . (flip .)) .)) .) . ((((ap .) .) .) .) . ((flip .) .
08:58:13 <lambdabot> ) . (((ap .) .) .) . (flip .) . ((ap .) .) . flip . (ap .) . flip fmap)
08:58:13 <lambdabot> optimization suspended, use @pl-resume to continue.
08:58:21 <Cale> heh
08:58:21 <ihope> :-)
08:59:05 <ihope> I wish I could define types with lambdabot.
08:59:18 <ihope> let data Badger = Badger Badger Badger | Mushroom in ...
09:00:05 <Cale> that would be an interesting language feature. Make let really the same syntactically as the top level of a module.
09:00:29 <Cale> otoh, you'd have some odd things to decide
09:00:40 <Cale> let data Badger = Badger Badger Badger | Mushroom in Mushroom
09:00:58 <xerox> ... in main = ... ?
09:01:00 <Cale> would hopefully give an error
09:01:11 <SamB> Cale: yes
09:01:17 <int-e> let data Badger = Badger Badger Badger | Mushroom deriving Show in Mushroom
09:01:20 <int-e> main = print ...
09:01:35 <SamB> just as existentially quantified type variables aren't allowed to escape
09:01:45 <int-e> . o O ( "Error: Don't know which mushroom to pluck." )
09:02:03 <Cale> @ghc
09:02:04 <lambdabot>  GHCi's bytecode generation machinery can't handle 64-bit code properly
09:02:04 <lambdabot> yet.
09:02:11 <Cale> @ghc
09:02:12 <lambdabot>  For basic information, try the `--help' option.
09:02:15 <Cale> @ghc
09:02:16 <lambdabot>  Oops!  Entered absent arg
09:02:21 <Cale> @ghc
09:02:23 <lambdabot>  absApply: Duff function
09:02:30 <int-e> @help ghc
09:02:31 <lambdabot> GHC!
09:02:52 <SamB> "Entered absent arg"?
09:03:19 <Cale> there are lots of debugging messages in there which are never meant to see the light of day
09:04:16 <Saulzar> Duff function? :)
09:06:44 <ihope> @ghc
09:06:45 <lambdabot>  Data constructor does not return its parent type
09:06:56 <ihope> Hmm.
09:07:22 <ihope> @type (map . map . map . map . map . map . map . map) id
09:07:24 <lambdabot> forall a. [[[[[[[[a]]]]]]]] -> [[[[[[[[a]]]]]]]]
09:08:05 <ihope> Is it possible to compute the Ackermann function in Haskell
09:08:12 <ihope> 's type system?
09:08:13 <Cale> ihope: of course
09:08:15 <Cale> oh
09:08:20 <ihope> :-D
09:08:30 <Cale> In the type system? Probably with extensions
09:08:37 <ihope> Aww.
09:08:56 <ihope> type Ack Zero x = (Inc x)
09:09:05 <ihope> Hmm, deja vu.
09:09:34 <ihope> I'd probably get some recursion error.
09:09:45 <Cale> invAck n = 4
09:09:51 <ihope> Hah.
09:10:29 <ihope> Hmm, I keep accidentally typing /tell instead of /msg.
09:14:36 <pesco> Does anybody know of a handy benchmarking tool? I.e. tell it a bunch of programs and it calls them all, measuring cpu usage...?
09:15:28 <Igloo> pesco: What was the result of your Linux/powerpc ghci debugging?
09:16:03 <Igloo> pesco: And if you find a tool that tells you useful things about memory useage of programs you give it, please let me know
09:16:16 <pesco> Igloo: None yet, my HD was too full to compile GHC. ;)
09:16:48 <Igloo> Ah, OK
09:18:45 <pesco> Huh, I really would have expected some shiny tool for this benchmarking purpose to exist, but at least Ubuntu knows nothing.
09:20:04 <mahogny> pesco, the time command is the first resort. only gives you execution time but it is useful for optimization
09:22:19 <pesco> mahogny: Yes, but time measures only one run of one program. A proper benchmark runs each program multiple times with different arguments and produces nice graphs as a result.
09:22:47 <goron> pesco: Isn't writing such a program trivial?
09:23:15 <pesco> goron: Sure. Will you do it for me?
09:23:48 <goron> pesco: I have more important things to do. 
09:25:48 <pesco> goron: You see, doing it will consume some time and effort. Certainly more than "apt-get install benchmark; benchmark [1,10..1000] imp1 imp2 imp3; xpdf benchmark.pdf" would have...
09:26:05 <mahogny> not much more. get at it :)
09:26:16 <pesco> mahogny: I am. :)
09:27:09 <goron> pesco: The most work is determining *what* "nice" results you want. 
09:27:19 <Igloo> I think looking at memory use is harder, sadly. AFAICT you either have to poll with ps or /proc, which isn't too satisfactory, or watch syscalls
09:27:45 <pesco> Igloo: My time manpage says it can report something about memory usage...
09:28:00 <Igloo> pesco: Does it ever say anything other than 0?
09:28:10 <pesco> Igloo: No idea, haven't tried.
09:28:12 <goron>  There's a cool memory usage tool for C(?) on the webpage of the main author of Enlightenment.
09:28:29 <goron> It also addresses cache misses etc.
09:28:30 <Igloo> goron: Is that rasterman?
09:28:34 <goron> Igloo: yes
09:28:49 <goron> Igloo: I meant there's a link on that webpage.
09:29:03 <goron> But there's a lot still to be desired in that area.
09:29:25 <Igloo> Aha, http://www.rasterman.com/index.php?page=Memprof - thanks, I'll take a look
09:29:49 <goron> Igloo: I didn't take a very serious look at it, but report back if it's really something :)
09:30:33 <mahogny> memproof sucks IIRC. forgot why
09:32:47 <heisenbug> anybody ever bootstrapped yhc on a new platform or can help me with this?
09:33:57 <Igloo> No-one can help you if you don't say what your problem is
09:34:29 <araujo> Hello.
09:34:30 <heisenbug> okay, here is my problem:
09:35:07 <Igloo> memprof looks like it's doing the right sort of things at first glane, although it looks like it'd miss mmap anonymous
09:35:09 <heisenbug> I can send the yhc compiler to the target, and build yhi
09:36:00 <heisenbug> but how do I invoke yhi with the bytecode program to compile yhc on the target?
09:36:27 <heisenbug> it is not described on the wiki as far as I can see
09:40:09 <Cale> hmm, ndm isn't here - I bet he could tell you though
09:40:56 <Cale> I'm pretty sure I've seen Tom Shackell on IRC too...
09:42:06 <Heffalump> not very often, that I can remember
09:42:57 <Cale> You might just try emailing one of them.
09:43:03 <heisenbug> okay, maybe I will email them anyway
09:43:25 <heisenbug> in any case, this is the wiki page h
09:43:39 <heisenbug> where I would expect an explanation: http://haskell.org/haskellwiki/Yhc/Porting
09:43:46 <pesco> heisenbug: What kind of file is the yhc executable?
09:44:11 <heisenbug> should be a hbc .file
09:44:12 <Cale> heisenbug: me too - that's where I looked
09:44:37 <pesco> heisenbug: But I thought those must be executed by calling yhi on them?
09:45:15 <heisenbug> there was a hint somewhere that the makefile will be updated to support bootstrapping, but that never materialized
09:45:46 * palomer wishes he could have haskell write out all the default cases for a function acting on a datatype
09:45:48 <heisenbug> pesco: yeah, bit how to invoke?
09:45:48 <Cale> heisenbug: If you have yhi running, and the .hbc for the compiler, shouldn't you be able to run the compiler?
09:46:21 <Cale> yhi ModuleName
09:46:52 <pesco> heisenbug: According to the docs, yhc is run as a regular command, so I suspect it's a shell script that calls yhi on the compiler proper...
09:46:52 <heisenbug> and the .hs file should be specified how?
09:47:14 <Cale> The .hs has the same name as the module
09:47:32 <Cale> (as should the .hbc, iiuc)
09:48:08 <Cale> you just run  yhi ModuleName, where you have a file  ModuleName.hbc
09:48:29 <heisenbug> ok, I will try all of this... thanks!
09:50:11 <goron> Cale: Do you know whether x - (sqrt 2)**(log x) = Theta(x)?
09:50:39 <Cale> what's Theta(x)?
09:50:56 <goron> Cale: that's a CS thing.
09:51:10 <Cale> oh, is an element of Theta(x) :)
09:51:23 <goron> Cale: yes, Theta(x) is a set of functions.
09:51:34 <Cale> right, that one
09:51:37 <Cale> um...
09:52:45 <Cale> yeah, if that's the log base 2, then that simplifies to x - sqrt(x)
09:53:18 <goron> Why?
09:55:02 <pesco> (sqrt x)**y = sqrt (x**y) ?
09:57:09 <int-e> pesco: remember that sqrt(x) = x^(1/2)
09:57:13 <Cale> sqrt(2)^(log_2(x)) = sqrt(2)^(log(x)/log(2)) = exp(log(sqrt(2)) log(x) / log(2)) = exp(1/2 log(sqrt(2))
09:57:46 <Cale> er
09:57:49 <Cale> oops :)
09:57:53 <pesco> int-e: Ah yes, I'm dumb.
09:58:16 <Cale> sqrt(2)^(log_2(x)) = sqrt(2)^(log(x)/log(2)) = exp(log(sqrt(2)) log(x) / log(2)) = exp(1/2 log(x))
09:58:20 <Cale> right
09:58:36 <Cale> = exp(log(x^1/2)) = sqrt(x)
09:59:34 <Cale> since log(sqrt(2)) = 1/2 log(2)
10:01:05 <tromp_> x - (sqrt 2)**(log x) = Theta(x) iff the base of the log is is greater than sqrt 2
10:03:07 <tromp_> assuming x -> infty :)
10:31:25 <mahogny> did haskell.org have some pages for putting/getting code snippets and new modules? think I have seen some urls floating around in here
10:32:03 <Cale> the old wiki has lots of code on it
10:32:13 <mahogny> ok
10:32:33 <yaarg> http://pleac.sourceforge.net/ <-- needs more haskell
10:32:58 <Cale> Actually, that needs rewriting in idiomatic haskell
10:33:47 <yaarg> fair enough
10:34:07 <Saulzar> What is this syntax? "s'    = s.substr 5 2"
10:34:11 <Saulzar> s.substr ??
10:34:18 <Cale> they redefined .
10:34:30 <Cale> x.f = f x
10:34:40 <Saulzar> Ugh
10:34:40 <Cale> terrible, I know
10:34:48 <Saulzar> I see, to make it look like OO
10:34:56 <Cale> The upshot of this is that the code looks nothing like Haskell code.
10:35:04 <Saulzar> I didn't realise it was haskell at all, I thought it was perl placeholder code still
10:35:12 <mahogny> wtf. if they want .'s like that, they better go java
10:35:15 <yaarg> i've only used it for perl yes
10:35:29 <yaarg> but i just noticed today they've been working on other langs too
10:35:47 <davidw> well.. writing things from left to right can make sense sometimes
10:35:57 <Saulzar> Where is their replacement (.) defined?
10:36:11 <Saulzar> I notice they hide half of the rest of the prelude too..
10:36:27 <Saulzar> Oh, import Common
10:36:35 <liyang> hey yaarg 
10:36:47 <yaarg> hello liyang :)
10:37:35 <Saulzar> davidw, I would agree - but it makes little sense in an example showing off haskell code when they don't even mention it
10:38:00 <mahogny> actually, here is a question I have been wondering about for a while. say you have a named tuple and at some point replace some variable in it and you never use the original variable again. what happens in ghc internally? will it be clever enough to just move over the rest of the data that wasn't set or will it make the huge data copy?
10:38:52 <Cale> mahogny: the copy usually isn't too huge
10:39:11 <Cale> mahogny: what kind of tuple?
10:39:36 <Cale> Most things are actually pointers anyway
10:39:36 <mahogny> data Foo = Foo {a::int, b:: ....}, that kind
10:40:16 <Cale> like, let's say you have  data Foo = Foo { a :: Integer, b :: Array (Int, Int) Integer }
10:40:51 <Cale> at runtime, that looks like a tagged box with two pointers
10:40:58 <mahogny> ok
10:41:08 <mahogny> so if you have a data constructor, you get a pointer internally?
10:41:12 <Cale> yeah
10:41:16 <mahogny> right
10:41:17 <Cale> or a bunch of them
10:41:34 <Cale> so if you have foo :: Foo
10:41:42 <Cale> and you do  foo { a = 5 }
10:41:50 <Cale> then the array pointer is just copied
10:41:58 <mahogny> ok. thx. helpful knowledge when it is time to optimize :)
10:42:18 <Cale> If you want to know in more detail how it works...
10:42:25 <mahogny> well, that's enough I think
10:42:34 <mahogny> I can use the force otherwise :)
10:42:36 <Cale> http://citeseer.ist.psu.edu/peytonjones92implementing.html
10:42:56 <mahogny> oh. that one is still up to date?
10:43:01 <Cale> basically
10:43:19 <Cale> from what I understand anyway
10:49:40 <Saulzar> 87 pages, maybe not time to start reading at 7 am :)
10:50:36 <mahogny> baah. have you no spine you either? :)
10:51:03 <Saulzar> I am no G-machine :)
10:51:11 <mahogny> that figures :)
10:54:34 <Saulzar> Hmm, I see.. the Pleac stuff has half a regex library at the bottom!
10:59:28 <gour> on shootout lsit, ghc is on the 4th place on Debian AMD Sempron, with the missing entries
11:08:00 <araujo> mail.google.com works for anybody here?
11:08:44 <mahogny> yes
11:09:44 <araujo> mmm....
11:10:54 <yaarg> what's the word for haskellish code? :) like pythonic and Python..
11:11:09 <SamB> idiomatic Haskell
11:11:18 <SamB> we aren't necessarily sure what it *is* though
11:12:00 <mahogny> I used to define it as "something unreadable with monads". still a quite ok definition in some cases :P
11:12:10 * SamB takes his httpd out of his server box
11:12:44 <yaarg> heh
11:13:18 * SamB examines it to find its number
11:14:57 * SamB puts it back in the server
11:17:10 * SamB wonders why the MOOSE browser doesn't show him any methods on his httpd, and that its parent is apparantly "generic daemon listener"
11:35:13 <davidw> has anyone written an error correcting haskell parser?
11:37:43 <SamB> supposedly!
11:37:52 <SamB> but I have yet to find out what they are good for.
11:38:24 <davidw> I don't mean a combinator library, but a parser for Haskell grammar *using* such a library :)
11:39:14 <SamB> it seems unlikely that they are very good at producing error messages...
11:39:37 <SamB> anyway, I'm sure no one has produced a useful error-correcting parser with such a library
11:39:47 <SamB> er, for Haskell
11:41:57 <davidw> hmm.. maybe the error correcting could be combined with type checking somehow 
11:47:28 <SamB> I'm pretty sure that that is NP
11:48:23 * SamB wants to see LambdaMOO in Haskell...
11:48:30 <davidw> i'm not talking about finding the 'best' solutions
12:03:00 <vincenz> SamB: why
12:03:32 <SamB> vincenz: dunno!
12:03:51 <vincenz> SamB: what dfeatures do you want of lambdamoo
12:03:59 <vincenz> btw...
12:04:09 <vincenz> is there a reason why ubuntu offers ghc 6.4 and 5.04?
12:04:49 <mahogny> I think not only ubuntu does it like that
12:05:05 <vincenz> why
12:05:12 <mahogny> not sure
12:05:26 <SamB> vincenz: not features of lambdamoo. I'd like to see a reimplementation of lambdamoo!
12:06:00 <mahogny> whoever maintains Haddock: make install doesn't invoke make all. semi-bug :/
12:06:15 <vincenz> SamB: check out cold
12:06:58 <SamB> @where cold
12:06:59 <lambdabot> I know nothing about cold.
12:07:14 <vincenz> cold.org
12:07:21 <vincenz> http://ice.cold.org
12:08:37 <vincenz> I'm off
12:08:39 <vincenz> timie to get a drink
12:09:35 <vincenz> tomorrow or later I'll be studying haskell ;)
12:09:44 <vincenz> and I' mso tired I already mentally typoed haskell as ocaml 10 times
12:10:43 <SamB> it looks like the part where the bytecode is depended on by the database format (because databases contain intstruction pointers for suspended tasks) may be the nastiest part...
12:10:56 <vincenz> it works really well tho
12:11:20 <SamB> LambdaMOO, you mean?
12:11:28 <vincenz> no
12:11:29 <mahogny> haddock just choke on something trivial. is that common?
12:11:29 <vincenz> cold
12:11:59 <musasabi> mahogny: #ifndef __HADDOCK__ tricky code... #endif
12:12:00 <SamB> ice.cold.org doesn't seem to work too well as an address...
12:12:07 <vincenz> lemme look
12:12:28 <vincenz> http://cold.org/coldc/
12:12:33 <vincenz> there ya go
12:12:40 <vincenz> sadly it lacks support and wide spread use
12:12:41 <vincenz> but mudwise
12:12:45 <vincenz> it's the best system out there
12:13:25 <mahogny> musasabi, it dies on a certain text in a comment with parse error?
12:13:26 <SamB> what makes it better than lambdamoo?
12:14:09 <vincenz> SamB: the system
12:14:12 <vincenz> can't talk right now
12:14:16 <vincenz> going out for a driink
12:14:19 <SamB> magagr: haddock has strict requirements on comments
12:14:22 <vincenz> (9pm... I was up at 5:30am)
12:23:15 <mahogny> memory-efficient module for Undo/Redo in case anyone interested: http://mahogny.areta.org/snippets/Undo.hs
12:25:30 <ncalexan> mahogny: maybe that should go on the Wiki, perhaps close to Cale's MonadUndo?
12:26:27 <mahogny> yeah. maybe. I'd like to betatest it a bit though before I put it there
12:38:20 <xerox> @pl \xs ys -> zip xs ys >>= \(x,y) -> [x,y]
12:38:21 <lambdabot> flip flip (uncurry ((. return) . (:))) . ((>>=) .) . zip
12:39:08 <xerox> bah.
12:43:09 <Igloo> The hard bit is concat . transpose
12:43:21 <Igloo> Unfortunately you can't say [,]
12:43:51 <ncalexan> @type return . (,)
12:43:52 <lambdabot> forall (m :: * -> *) a b. (Monad m) => a -> m (b -> (a, b))
12:44:01 <ncalexan> Not quite...
12:44:37 <ncalexan> @djinn a -> [a]
12:44:37 <lambdabot> -- f cannot be realized.
12:45:31 <ncalexan> @type (:[]) . (,)
12:45:32 <lambdabot> forall a b. a -> [b -> (a, b)]
12:45:38 <xerox> Igloo: aaaaah!
12:45:48 <ncalexan> Again, not quite :)
12:45:51 <xerox> Igloo: well, no?
12:46:05 <xerox> @type List.transpose
12:46:07 <lambdabot> forall a. [[a]] -> [[a]]
12:46:20 <xerox> @type List.transpose . return
12:46:22 <lambdabot> forall a. [a] -> [[a]]
12:46:49 <Igloo> "well, no"?
12:50:58 <xerox> > let evens = map (+1) odds; odds = 1 : map (+1) evens; in take 10 $ (((concat . transpose) .) . (. return) . (:)) odds evens
12:51:00 <lambdabot> [1,2,3,4,5,6,7,8,9,10]
12:51:26 <xerox> (That is, 'concat . transpose' takes a list as a param, not two lists)
12:51:57 <xerox> I think there should be a way to intersperse 'streams' that way, shouldn't it?
12:52:26 <Igloo> Yes, that's why you want [,]
12:52:40 <xerox> [,] :: .. ?
12:52:40 <Cale> what's the goal here?
12:52:50 <Cale> [,] :: a -> a -> [a]
12:52:57 <Cale> 'obviously' :)
12:53:06 <Igloo> [,] is analogous to (,), i.e. [,] == \x y -> [x, y]
12:53:23 <Cale> do we also get [,,,,,,] ?
12:53:24 <Cale> :)
12:53:49 <Igloo> Cale: \x y -> concat $ transpose [x, y] but without the points and still nice
12:53:52 <Igloo> You do in my world
12:54:10 <Igloo> (I might mean [_, _]; I had another meaning for the oth one which I don't recall OTTOMH)
12:54:14 <xerox> Oh right.
12:54:40 <SamB> @pl [,] == \x y -> [x, y]
12:54:41 <lambdabot> (line 1, column 1):
12:54:41 <lambdabot> unexpected "["
12:54:41 <lambdabot> expecting white space, natural, identifier, lambda abstraction or
12:54:41 <lambdabot> expression
12:54:41 <Igloo> Oh, I do mean [_, _], as [3,,4,5,,,] should be allowed
12:55:04 <Igloo> Or at the very least [3,4,5,]
12:55:06 <SamB> @pl [,] = \x y -> [x, y]
12:55:07 <lambdabot> (line 1, column 1):
12:55:07 <lambdabot> unexpected "["
12:55:07 <lambdabot> expecting white space, natural, identifier, lambda abstraction or
12:55:07 <lambdabot> expression
12:55:47 <Igloo> Unfortunately for consistency (,) needs to be renamed
12:56:47 <xerox> ....to?
12:57:00 <Igloo> (_,_)
12:57:10 <SamB> Igloo: no, for consistancy, (1,) needs to work
12:57:24 <xerox> @type (1,)
12:57:26 <lambdabot> parse error on input `)'
12:57:33 <SamB> also (,1)
12:57:37 <Igloo> SamB: As does (,)
12:58:36 <SamB> Igloo: (,) works fine
12:58:41 <Igloo> Also, (Just _) is an expression (equivalent to Just, but it's more interesting with multi-parameter constructors) etc
12:58:46 <tibbe> @help
12:58:47 <lambdabot>  @help <command> - ask for help for <command>
12:58:52 <SamB> Igloo: you are crazy
12:58:54 <tibbe> @help m
12:58:55 <lambdabot>  @help <command> - ask for help for <command>
12:59:02 <tibbe> how to locate a function?
12:59:05 <Igloo> SamB: But it would have to mean () to be consistent with extra commas in lists being deleted
12:59:12 <tibbe> with lambdabot
12:59:40 <xerox> @index intersperse
12:59:41 <lambdabot> Data.List
13:00:23 <SamB> hmm, why does Cold want a DB package?
13:00:44 <Igloo> Hmm, I wonder if (Just (foo _)) should be allowed, and what it should mean
13:01:08 <SamB> Igloo: maybe extra commas in lists shouldn't be deleted?
13:01:11 <xerox> What about that '_' ?
13:01:30 <Igloo> SamB: But that's the biggest problem, and where I started  :-)
13:01:39 <Igloo> Anyway, I need to go eat or I won't be alive to be mad tomorrow
13:01:53 <ulfdoz> I have problem with instance declaration of a Monad "data Statistics a :
13:02:18 <ulfdoz> arg, "data Statistics a = Stat {counter::(a -> a)}"
13:03:26 <ulfdoz> If I want to define (>>=) as "(>>=) st f = let cnt = counter st in return (cnt . f)" I get a kind error. but what's the problem?
13:03:56 <ulfdoz> The error is "Kind error: Expecting kind `* -> *', but `Statistics a' has kind `*'"
13:04:30 <tibbe> @index fromJust
13:04:31 <lambdabot> Data.Maybe
13:04:47 <SamB> ulfdoz: "instance Statistics where"
13:05:49 <ulfdoz> SamB: Isn't it "instance Monad (Statistics a) where"?
13:06:32 <SamB> ulfdoz: nope!
13:06:59 <glasser> ulfdoz: see, you have a Monad a, and a Statistics a, so Monad is like Statistics
13:07:47 <SamB> er, I forgot the Monad.
13:07:53 <SamB> ulfdoz: "instance Monad Statistics where"
13:08:01 <SamB> that should actually work...
13:10:00 <ulfdoz> SamB: Indeed it does, thx.
13:10:31 <SamB> ulfdoz: sorry about the confusion
13:21:24 <newsham> If I make a record  (data Foo = Foo { foo, bar :: Int })   it makes accessor functions (foo, bar) and some sorta updater
13:21:40 <newsham> why can I get the type of th eaccessor, but not the type of something like "{ foo = 3 }" updator
13:22:24 <Cale> newsham: the updater is syntax
13:22:34 <Cale> it has to include the thing being updated too
13:22:46 <Cale> { foo = 3 } on its own isn't valid syntax
13:22:59 <newsham> so this piece of haskell doesnt seem to fit very well :(
13:23:23 <newsham> I can simulate a record with field accessors, but I cant simulate record updator without inventing new syntax
13:24:53 <newsham> here's the thing.. i would like to marshal records to and from binary data.  but I want to do it in a random-access fashion.
13:25:00 <SamB> newsham: the update syntax is indeed ill-fitting
13:25:12 <newsham> when reading from binary data, I want to be able to access one part of the record without having to fully unmarshal the record
13:25:46 <SamB> newsham: that sounds kinda crazy
13:26:01 <newsham> is it?
13:26:11 <newsham> I do it in C all the time.
13:26:15 <tibbe> anyone have a good source for writing an interpreter for a language with closures and lambdas in haskell?
13:27:27 <Philippa> SamB: there're times when a file format effectively requires it
13:27:58 <Philippa> tibbe: there're a fair number of lambda calculus evaluators about if that'll do - what evaluation scheme do you want?
13:28:03 <newsham> x = ntohl(hdr->ip_src.s_addr);
13:28:49 <tibbe> Philippa, I'm trying to write a small language of my own and I just want a general idea how it's done, probably eager (strict) evaluation
13:29:22 <tibbe> Philippa, would be really great if the were some papers on it or so
13:29:42 <newsham> a book on languages and denotational semantics will more or less have a completely implementation of a language with closures and lambdas
13:30:07 <glasser> If you don't care about parsing, you can write such a thing in half a screen of Haskell
13:31:19 <Philippa> half a screenfull? That's too much IMO
13:31:34 <glasser> half a PDA screen
13:32:08 <Philippa> heh, fair enough
13:32:15 <alar> They say haskel is actually a typed lambda calculus
13:32:23 <alar> is this true for epigram?
13:32:23 <araujo> Hello.
13:32:36 * araujo wants to experiment with GUI in haskell
13:32:55 <tibbe> glasser, I can write a parser myself so that half a screen of code is something I'd very much like, just the abstract syntax and evaluator
13:33:20 <tibbe> newsham, can't really afford many more books atm :/ got to pay for all school books
13:33:39 <newsham> any classes on denotational semantics?
13:34:14 <glasser> off the top of my head, there's certainly one in Wadler's original monads paper.  But it's practically the standard example in a lot of Haskell papers
13:34:21 <tibbe> newsham, unfortuneatly not, I'm doing a programming language course (hasn't started yet) and I wanted to do something a bit more advanced that implement basic
13:34:43 <tibbe> glasser, where might I find that paper?
13:35:24 <glasser> "essence of functional programming"
13:36:23 <tibbe> glasser, found it, i think
13:36:49 <chucky> simon peyton-jones has a (now free) book called "implementing functional languages: a tutorial" available
13:36:51 <chucky> http://research.microsoft.com/Users/simonpj/Papers/pj-lester-book/
13:37:03 <chucky> might be a bit too much info though
13:37:23 <araujo> Cool cool!
13:37:59 <newsham> http://www.csc.liv.ac.uk/~grant/Teaching/COMP317/densem.pdf
13:38:59 <newsham> basically model an "environment" where you can bind values to names, and retrieve values using names, and overlay new environments over old ones
13:39:19 <newsham> then define an evluator for evaluating expressions containing variables, using an environment.
13:39:31 <tibbe> newsham, i made a stack of (var,val) mappings
13:39:34 <newsham> then define your constructs like "let" in terms of them
13:39:44 <chucky> aarne ranta has some great slides on compiler construction in general here: http://www.cs.chalmers.se/Cs/Grundutb/Kurser/komp/current/lectures/lectures.html
13:40:03 <chucky> I took his course in 2004
13:40:07 <tibbe> chucky, I attend Chalmers
13:40:25 <chucky> oh. :)
13:40:37 <araujo> Thsi is cool chucky 
13:40:45 <araujo> Did you already read it?
13:41:09 <tibbe> somehow I whish I'd taken some more interesting courses, now I've only got half a year left before my MS
13:41:11 <chucky> araujo: The book? Sadlo no, I haven't had time. I've browsed through it
13:42:14 <tibbe> newsham, I'm probably really thick but I'm not sure how to represent functions, it would be nice if I could have partial application
13:42:32 <newsham> empty-environ : Environ;  bind : Id x Bindable -> Environ;  overlay : Environ x Environ -> Environ;  find : Environ x Id -> Bindable
13:43:13 <newsham> evaluate : Expression -> (Environ -> Integer)  (for integer expressions)
13:43:16 <tibbe> newsham, is the overlay for creating new scopes?
13:43:21 <Philippa> tibbe: the lambda calculus gets you that by default
13:43:28 <araujo> chucky, nice, this will give me some interesting reading :-]
13:43:31 <carp__> alar: epigram's core is.
13:43:32 <newsham> tibbe: yah, create a new scope based on old scope and new bindings
13:43:39 <Philippa> data Term = Var Identifier | App Term Term | Lam Identifier Term
13:43:44 <tibbe> Philippa, then I probably should learn how to implement that then ;)
13:44:14 <xerox> newsham: Reader Monad?
13:44:16 <newsham> elaborate : Declaration -> (Environ -> Environ)
13:44:27 <newsham> xerox: not familiar with that one yet.  
13:44:50 <Philippa> Someone else can explain an eager evaluator for that, I'm heading off
13:44:58 <tibbe> newsham, then I "pop" scopes as I leave scopes?
13:45:08 <newsham> example:   evaluate "let D in E" env = let env' = elaborate D in env in evaluate E (overlay (env',env))
13:45:10 <tibbe> newsham, did that make any sense? xD
13:45:38 <newsham> tibbe: in a sense.  if you were passing in environments, you would pass in the elaborated environment only to expression evaluators in the inner scopes
13:45:48 <newsham> and the outer scope would have the simpler environments
13:46:08 <newsham> similar to pushing and popping, but pushing and popping are actions, not the meanings
13:46:17 <Philippa> newsham: it's the exact subset of State you need to do environments, essentially
13:46:30 <tibbe> I really my lambda calculus is lacking (rather noexisting really)
13:47:02 <Philippa> tibbe: App (Lam "x" (Var "x")) foo => foo
13:47:12 <newsham> lambda calculus is simple stuff like:   (Lx.x+1) 5
13:47:25 <tibbe> Is there a log of this channel somewhere?
13:47:34 <newsham> which means you have a function which takes in an "x" and returns an "x+1" and you apply that to "5" to get    5+1 = 6
13:47:36 <chucky> tibbe: see topic
13:47:42 <tibbe> newsham, yes, but how the thinking translates to implementation
13:47:51 <tibbe> chucky, thanks
13:47:56 <Philippa> newsham: write him the (eager) interpreter for the type I just gave?
13:48:03 <Philippa> (with type Identifier = String or similar)
13:49:20 <tibbe> Philippa, just curious, why name the data type Term and not Expr or similar?
13:50:00 <newsham> phillip: trying to get it straight in my head first :)
13:50:36 <ihope> @pl \q w e r t y u i o p a s d f g h j k l z x c v b n m -> a b c d e f g h i j k l m n o p q r s t u v w x y z
13:50:52 <lambdabot> ((((((((((((((((((flip .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .)
13:50:52 <lambdabot> .) . (((((((((((((((((((flip .) .) .) .) .) .) .) .) .) .) .) .) .) .) .)
13:50:52 <lambdabot> .) .) .) .) . ((((((((((((((((((((flip .) .) .) .) .) .) .) .) .) .) .) .)
13:50:52 <lambdabot> .) .) .) .) .) .) .) .) . (((((((((((((((((((((flip .) .) .) .) .) .) .) .
13:50:52 <lambdabot> ) .) .) .) .) .) .) .) .) .) .) .) .) .) . ((((((((((((((((((((((flip .) .
13:50:54 <lambdabot> [102 @more lines]
13:50:56 <lambdabot> optimization suspended, use @pl-resume to continue.
13:51:50 <newsham> philip: i'm not very comfortable with lambda calc without the extra syntactic glue :)
13:51:55 <newsham> sugar
13:52:21 <ihope> Do you put glue on your cereal?
13:56:04 <newsham> so to evaluate "Var Id" you basically just look it up:  eval (Var i) e = find i e
13:56:25 <newsham> to evaluate an application:   eval (App (Lam i t1) t2) e
13:56:44 <newsham> you want to bind t2 to i and then evaluate t1
13:57:20 <newsham> evaluate t1 (overlay (bind id t2) e)
13:57:24 <newsham> something like that
13:57:57 <ihope> Omgwtfbbq, I just got a huge idea that'll, um... never mind.
13:59:53 <SamB> why does cabal only want to run haddock for exposed modules?
14:01:00 <tibbe> newsham, thanks
14:01:13 <tibbe> newsham, I'll try to understand that in the morning ;)
14:04:17 <pesco> ihope: What the fucking Barbeque?!
14:04:59 <ihope> Oh my gosh!
14:05:28 <newsham> xerox: ok, back to reader monad.  what were you suggesting?  this is for my records questions?
14:06:58 <newsham> oh, for overlaying environs?
14:44:10 <ihope> Hmm, hmm, hmm.
14:44:14 <ihope> Mmm!
14:47:30 <ihope> Woot, long definition.
14:49:08 <ihope> > let compose 0 f x = x; compose n f x = f (compose (n-1) f x); conway [x] = x; conway (1:xs) = conway xs; conway (x1:x2:xs) = compose x2 (\y -> conway ((x1-1):conway y:xs)) xs in compose 64 (\x -> conway [3,3,x]) 4
14:49:09 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
14:49:09 <lambdabot>   Expected type: [a]
14:49:09 <lambdabot>   Inferred type: a
14:49:21 <ihope> Talk about a vague error message...
14:54:38 <psnl> makes sense
14:58:53 <Heffalump> ihope: does it not tell you what the error is in?
14:59:39 <ihope> ...Where is it?
15:00:22 <ncalexan> @type repeat
15:00:23 <lambdabot> forall a. a -> [a]
15:00:27 <ncalexan> @type iterate
15:00:28 <lambdabot> forall a. (a -> a) -> a -> [a]
15:00:33 <Heffalump> oh, duh, lambdabot.
15:00:43 <Heffalump> I thought you were pasting something else :-)
15:00:45 <ulfdoz> Pah, type system b0rked. It doesn't work as I want it. ;)
15:02:13 <glasser> If I do it not in lambdabot, I get
15:02:19 <glasser>     In the first argument of `conway', namely `y'
15:02:20 <glasser>     In the first argument of `(:)', namely `conway y'
15:03:04 <glasser> so in: (\y -> conway ((x1-1):conway y:xs))
15:03:17 <glasser> that's getting interpreted as (conway y):xs
15:03:22 <glasser> not conway (y:xs)
15:03:44 <ihope> I know.
15:03:52 <glasser> which means you're trying to put something of conway's output type as an element of that list
15:04:45 <ihope> Yep.
15:15:36 <ihope> So...?
15:16:31 <ulfdoz> http://www.rafb.net/paste/results/Sds2TJ88.html <- I do not find the reason, why type system disagrees.
15:18:37 <ihope> I think it's in the definition of return.
15:19:08 <ihope> ...Never mind.
15:20:26 <Lemmih> ulfdoz: What do you think the type of 'f' (in the definition of (>>=)) is?
15:20:59 <ulfdoz> Lemmih: a -> Statistics c b
15:21:02 <Lemmih> Oh, wait. Sorry.
15:22:16 <ihope> It's impossible to return a monad...
15:22:46 <ihope> @pl \x -> [x,x]
15:22:47 <lambdabot> ap (:) return
15:25:17 <Lemmih> ulfdoz: s/in newCnt/in newCnt s/
15:26:24 <ulfdoz> Wow! I looked over an hour at it. thanks.
15:40:58 <tbfg> hi i've a monad beginners question
15:41:16 <tbfg> how would a function look like printing an IO Integer ?
15:41:51 <ncalexan> tbfg: do you want to print an integer?
15:42:04 <tbfg> ncalexan an IO Intger
15:42:09 <SamB> @type print
15:42:11 <lambdabot> forall a. (Show a) => a -> IO ()
15:42:11 <Lemmih> tbfg: print =<< ioInteger.
15:43:00 <SamB> @type (>>= print)
15:43:02 <lambdabot> forall a. (Show a) => IO a -> IO ()
15:43:15 <ihope> @seen int-e
15:43:16 <lambdabot> I saw int-e leaving #haskell-overflow and #haskell 3 hours, 2 minutes and
15:43:16 <lambdabot> 17 seconds ago.
15:43:36 <tbfg> Lemmih thanks!
15:47:02 <mfgl> Quite subtle. I'm also a begginer, and was wondering about the difference between "print" and ">>= print".
15:47:23 <mfgl> Now I see: in fact ">>= print" prints an IO a
15:47:35 <mfgl> while "print" prints a.
15:48:22 <ncalexan> mfgl: I prefer to think of (>>= print) as taking an IO action that returns an 'a' -- (>>= print) runs that action, collects the 'a' it spat back, and then prints it.
15:48:37 <tbfg> mfgl print actually print everything which is member of the class Show
15:48:54 <ncalexan> An (IO a) by itself doesn't really have a printed form.
15:49:04 <ncalexan> It's an action that will do some IO, then return an a.
15:50:25 <mfgl> Thinking...
15:52:16 <mfgl> I think I understand. One thing are IO states or data, and other thing are printable types.
15:53:57 <ihope> @djinn m (a -> b) -> a -> m b
15:53:58 <lambdabot> -- f cannot be realized.
15:54:06 <ihope> Mmh.
15:55:06 <ncalexan> @type \f x -> return x >>= f
15:55:07 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> a -> m b
15:55:28 <ncalexan> @pl  \f x -> return x >>= f
15:55:28 <lambdabot> id
15:55:28 <ihope> @type \x y -> do {a <- x; return (a y)}
15:55:30 <lambdabot> forall (m :: * -> *) a t. (Monad m) => m (t -> a) -> t -> m a
15:55:45 <ihope> :-)
15:55:55 <ihope> @djinn forall (m :: * -> *) a t. (Monad m) => m (t -> a) -> t -> m a
15:55:56 <lambdabot> Cannot parse command
15:56:00 <ihope> Tee hee.
15:57:08 <ncalexan> @type (return .)
15:57:09 <lambdabot> forall (m :: * -> *) b a. (Monad m) => (a -> b) -> a -> m b
15:58:17 <ihope> @pl \x y -> do {a <- x; return (a y)}
15:58:18 <lambdabot> (line 1, column 12):
15:58:18 <lambdabot> unexpected "{"
15:58:18 <lambdabot> expecting variable, "(", operator or end of input
15:58:23 <ihope> Oh right.
15:58:46 <ihope> @pl \x y -> x >>= \a -> return (a y)
15:58:47 <lambdabot> flip (fmap . flip id)
15:58:53 <ihope> Hmm.
16:00:00 <ihope> Bbbut...
16:00:09 <ihope> @type fmap
16:00:11 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
16:00:14 <Lemmih> @type flip (flip ap . return)
16:00:15 <lambdabot> Not in scope: `ap'
16:00:25 <Lemmih> @type flip (flip Monad.ap . return)
16:00:26 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> a -> m b
16:00:37 <ncalexan> @type Monad.ap
16:00:38 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
16:01:24 <ihope> @type flip (fmap . flip id)
16:01:25 <lambdabot> forall (f :: * -> *) c a. (Functor f) => f (a -> c) -> a -> f c
16:01:35 <ihope> @type \x y -> x >>= \a -> return (a y)
16:01:36 <lambdabot> forall (m :: * -> *) a t. (Monad m) => m (t -> a) -> t -> m a
16:02:04 <ihope> At least it proves functors are more useful than I thought they could be.
16:02:11 <ihope> ...Or something.
16:05:52 <SamB> when people ask for those functions, we should give them do blocks instead ;-)...
16:06:25 <ihope> ...What?
16:06:51 <mfgl> I don't think so.
16:07:41 <SamB> the ones that do things with "IO values"
16:07:44 <ncalexan> Howdy, Cale.
16:08:06 <mfgl> >>= is an interesting manner of sequencing commands without breaking the functional meaning of the language. If I understood it well.
16:08:16 <SamB> mfgl: you do
16:09:07 <mfgl> Thanks. But I think I'm just starting to understand it. :)
16:09:10 <SamB> hmm, conjure is still apparantly leaking sockets somewhere...
16:09:59 <ihope> @type \a -> do {b <- a; c <- b; d <- c; e <- d; f <- e; g <- f; g}
16:10:01 <lambdabot> forall (m :: * -> *) b.
16:10:01 <lambdabot> (Monad m) =>
16:10:01 <lambdabot> m (m (m (m (m (m (m b)))))) -> m b
16:13:11 <ihope> So is there any "official" spoon sound, like there is an "official" rheet sound?
16:17:54 <dons> @seen musasabi
16:17:55 <lambdabot> musasabi is in #haskell-overflow, #haskell-blah and #haskell. Last spoke
16:17:55 <lambdabot> 4 hours, 6 minutes and 3 seconds ago.
16:19:07 <dons> musasabi, any chance you can submit the fixed ackermann (http://www.haskell.org/hawiki/AckEntry) to replace the bug in http://shootout.alioth.debian.org/debian/benchmark.php?test=ackermann&lang=ghc&id=0
16:19:21 <dons> I notice Isaac even mentioned this ackermann on the list.
16:24:49 <ihope> Does anybody know of any web pages that contain the entire decimal expansion of Pi?
16:25:10 <Pseudonym> Yes, but unfortunately it's an infinite download.
16:25:28 <ihope> Can you give me the URL?
16:25:44 * Pseudonym is joking
16:25:47 <ihope> Oh.
16:25:53 <Pseudonym> Pi is transcendental.
16:25:59 <ncalexan> The decimal expansion of Pi does not terminate.
16:26:38 <ihope> I know...
16:26:55 <ihope> So it'd just have to be a nonterminating web page, aye?
16:26:57 <ncalexan> ihope: you can get the first several thousand digits from the Haskell wiki, pidigits shootout entry...
16:27:07 <dons> the first `n ' thousand..
16:27:28 <dons> http://shootout.alioth.debian.org/gp4/benchmark.php?test=pidigits&lang=ghc&id=3
16:31:11 <Pseudonym> http://web.comlab.ox.ac.uk/oucl/work/jeremy.gibbons/publications/spigot.pdf 
16:31:20 <Pseudonym> Lots of Haskell code in that paper.
16:32:06 <ulfdoz> We could save more lines of code, if we'd implement benchmarks in standard libs. :)
16:32:29 <ihope> We could save lines of code by not using line breaks.
16:35:12 <ulfdoz> nice ranking
16:36:17 <Pseudonym> @eval let { g q r t k n l = if 4 * q + r - t < n * t then shows n . g (10*q) (10*(r-n*t)) t k (10 * (3 * q + r) `div` t - 10 * n) l else g (q*k) ((2*q + r) * l) (t*l) (k+1) ((q * (7*k + 2) + r*l) `div` (t*l)) (l+2) } in putStr (g 1 0 1 1 3 3 "")
16:36:18 <lambdabot> No IO allowed
16:36:22 <Pseudonym> Damn.
16:36:26 <Pseudonym> @eval let { g q r t k n l = if 4 * q + r - t < n * t then shows n . g (10*q) (10*(r-n*t)) t k (10 * (3 * q + r) `div` t - 10 * n) l else g (q*k) ((2*q + r) * l) (t*l) (k+1) ((q * (7*k + 2) + r*l) `div` (t*l)) (l+2) } in g 1 0 1 1 3 3 ""
16:36:29 <ihope> Use braces wherever possible...
16:36:29 <lambdabot> "31415926535897932384626433832795028841971693993751058209749445923078164062
16:36:29 <lambdabot> 862089986280348253421170679821480865132823066470938446095505822317253594081
16:36:29 <lambdabot> 284811174502841027019385211055596446229489549303819644288109756659334461284
16:36:29 <lambdabot> 756482337867831652712019091456485669234603486104543266482133936072602491412
16:36:29 <lambdabot> 737245870066063155881748815209209628292540917153643678925903600113305305488
16:36:31 <lambdabot> [23 @more lines]
16:36:34 <ihope> Omgwtfbbq.
16:36:44 <dons> ihope, it's about elegance. we don't want to submit vomit.
16:36:48 <dons> ;)
16:36:51 <ihope> :-)
16:37:01 <dons> @keal
16:37:02 <lambdabot> i try make program called Glyph to do it but my script lang called T too
16:37:02 <lambdabot> slow. i invent T
16:37:11 * Pseudonym laughs
16:37:14 <dons> oh, I was hoping for a quote about the fpu being destroyed
16:37:37 <ncalexan> @keal
16:37:38 <lambdabot> i cant think anymore
16:37:40 <shrimpx> any word on the 2006 ICFP prog. contest?
16:37:58 <Pseudonym> Yes.  This year's contest is to implement a time warp program.  We won.
16:38:01 <ihope> @keal
16:38:02 <lambdabot> ghc need to have plugin that allow copy paste in xp
16:38:19 <shrimpx> well i won too then
16:38:20 <ihope> @help keal
16:38:21 <lambdabot> Talk like Keal
16:38:33 <shrimpx> good deal
16:38:50 <ihope> ...Who's Keal?
16:38:55 <dons> don't ask.
16:39:04 <dons> he's a funny bot
16:39:09 <ihope> A bot?
16:39:18 <dons> @keal is a bot, yes :)
16:39:19 <lambdabot> the fractal is 5 irrationals
16:39:23 <ihope> @ihope
16:39:24 <lambdabot> Unknown command, try @listcommands.
16:39:27 <ihope> Aww.
16:39:35 <bigbabyjesusfoo> @listcommands
16:39:36 <lambdabot> use listcommands [module|command]. Modules are:
16:39:36 <lambdabot> babel base code compose dice dict djinn dummy dynamic elite fact haddock
16:39:36 <lambdabot> help hoogle karma lShell localtime more pl plugs poll pretty quote search
16:39:36 <lambdabot> seen spell state system todo topic type version vixen where
16:39:46 <bigbabyjesusfoo> @help babel
16:39:47 <lambdabot> usage: babel lang lang phrase
16:40:08 <Pseudonym> @babel English German "the spirit is willing but the flesh is weak"
16:40:13 <dons> en de
16:40:16 <dons> no quote.
16:40:24 <Pseudonym> @babel en de the spirit is willing but the flesh is weak
16:40:46 <dons> well, as long as the connection to the babel site doesn't timeout...
16:40:51 <ihope> :-)
16:41:00 <bigbabyjesusfoo> @help dynamic
16:41:07 <bigbabyjesusfoo> :(
16:41:12 <bigbabyjesusfoo> I think we killed it
16:41:14 <dons> nah, we've got a bug. just wait for the timeout...
16:41:14 <Pseudonym> Lambdabot is busy with the babel thing.
16:41:20 <lambdabot>  "der Geist ist bereit, aber das Fleisch ist schwach"
16:41:22 <lambdabot>  der Geist ist bereit, aber das Fleisch ist schwach
16:41:24 <lambdabot> dynamic is a module.
16:41:36 <ihope> @babel de en der Geist ist bereit, aber das Fleisch ist schwach
16:41:38 <lambdabot>  the spirit is ready, but the flesh is weak
16:41:49 <ihope> Aww...
16:42:00 <Pseudonym> @babel en de the spirit is ready, but the flesh is weak
16:42:01 <lambdabot>  der Geist ist bereit, aber das Fleisch ist schwach
16:42:05 <Pseudonym> Let's translate to fixpoint!
16:42:11 <bigbabyjesusfoo> @babel jp en zanshin
16:42:12 <lambdabot> babel module failed: Error: Language jp not supported
16:42:16 <bigbabyjesusfoo> :(
16:42:20 <Pseudonym> @babel en de I am you and you are me and we are all together.
16:42:21 <lambdabot>  Ich bin Sie und Sie sind ich und alle wir sind zusammen.
16:42:28 <Pseudonym> @babel de en Ich bin Sie und Sie sind ich und alle wir sind zusammen.
16:42:30 <lambdabot>  I am you and you am I and everything we am together.
16:42:32 <ski> hmm @fix ?
16:42:38 <Pseudonym> @bable en de  I am you and you am I and everything we am together.
16:42:39 <lambdabot>  Ich bin Sie und Sie sind ich und alles wir morgens zusammen.
16:42:41 <bigbabyjesusfoo> @babel fr en les incompetant
16:42:43 <lambdabot>  incompetant
16:42:45 <Pseudonym> @babel de en Ich bin Sie und Sie sind ich und alles wir morgens zusammen.
16:42:46 <lambdabot>  I am you and you am I and everything we in the morning together.
16:42:50 <alar> @babel en ru I am you and you are me and we are all together.
16:42:52 <lambdabot>  can't parse this language
16:42:56 <Pseudonym> @babel en de I am you and you am I and everything we in the morning together.
16:42:58 <lambdabot>  Ich bin Sie und Sie sind ich und alles wir morgens zusammen.
16:43:11 <Pseudonym> Yay, it added "morning".
16:43:16 <Pseudonym> That's not bad.
16:43:19 <dons> that was good, wasn't it :)
16:43:26 <bigbabyjesusfoo> @babel en it fuckface
16:43:28 <lambdabot>  fuckface
16:43:31 <bigbabyjesusfoo> :(
16:43:32 <Pseudonym> @babel en de I hate spam and I want parliament to make it illegal.
16:43:34 <lambdabot>  Ich hasse Spam und ich wnsche Parlament es ungltig bilden.
16:43:38 <Pseudonym> @babel de en Ich hasse Spam und ich wunsche Parlament es ungultig bilden.
16:43:40 <lambdabot>  I hate Spam and I desire parliament it ungultig form.
16:43:40 <alar> @babel en ru face
16:43:42 <lambdabot>  can't parse this language
16:43:45 <Pseudonym> @babel en de I hate Spam and I desire parliament it ungultig form.
16:43:46 <lambdabot>  Ich hasse Spam und ich wnsche Parlament es ungultig Form.
16:43:48 <ihope> @fix
16:43:56 <Pseudonym> @babel de en Ich hasse Spam und ich wunsche Parlament es ungultig Form.
16:43:57 <lambdabot>  I hate Spam and I desire parliament it ungultig form.
16:44:04 <ihope> @help fix
16:44:05 <lambdabot>  @help <command> - ask for help for <command>
16:44:11 <ihope> ...?
16:44:38 <bigbabyjesusfoo> @babel en sp Rule Britannia Britannia rule the waves
16:44:39 <lambdabot> babel module failed: Error: Language sp not supported
16:44:47 <Pseudonym> @babel en de We should not have called it "monad", we should have called it "warm fuzzy thing".
16:44:47 <bigbabyjesusfoo> @babel en es Rule Britannia Britannia rule the waves
16:44:48 <lambdabot>  Wir sollten nicht es genannt haben "Monad", wir sollten es benannt haben
16:44:48 <lambdabot> "wrmen flockige Sache".
16:44:49 <lambdabot>  Regla de Britannia Britannia de la regla las ondas
16:44:57 <Pseudonym> @babel de en Wir sollten nicht es genannt haben "Monad", wir sollten es benannt haben "warmen flockige Sache".
16:44:59 <lambdabot>  We should not have called it "Monad", we should it have designated "warm
16:44:59 <lambdabot> flockige thing".
16:45:27 <dons> yes, we should have the IO Flockige instead.
16:45:28 <Pseudonym> @babel en de We should not have called it "Monad", we should it have designated "warm flockige thing".
16:45:30 <lambdabot>  Wir sollten nicht es genannt haben "Monad", wir, wenn es "warme flockige
16:45:30 <lambdabot> Sache" gekennzeichnet.
16:45:39 <dons> @type fmap
16:45:40 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
16:45:41 <bigbabyjesusfoo> @babel en am Britain and America are two countries seperated by a common language
16:45:42 <lambdabot> babel module failed: Error: Language am not supported
16:45:52 <Pseudonym> @babel de en Wir sollten nicht es genannt haben "Monad", wir, wenn es "warme flockige Sache" gekennzeichnet.
16:45:53 <lambdabot>  We should not have called it "Monad", we, if it "warm flockige thing"
16:45:53 <lambdabot> characterized.
16:46:13 <bigbabyjesusfoo> :( lambdabot hates America
16:46:16 <bigbabyjesusfoo> ;)
16:46:25 <mfgl> @babel es en monada
16:46:27 <lambdabot>  monada
16:46:30 <Pseudonym> @babel en de We should not have called it "Monad", we, if it "warm flockige thing" characterized.
16:46:32 <lambdabot>  Wir sollten nicht es genannt haben "Monad", wir, wenn es "warme flockige
16:46:32 <lambdabot> Sache" kennzeichnete.
16:46:42 <Pseudonym> OK, fix point.
16:46:47 <Pseudonym> Phew.
16:47:08 * SamB improves conjure's behaviour dramatically with a small (~5 line) change ... or so he thinks
16:47:10 <Pseudonym> Your mission, should you choose to accept it, is to come up with the phrase which takes the longest to reach fixpoint.
16:47:43 <dons> Samb, cool. how so?
16:47:56 <ski> (hmm .. translation as operational semantics)
16:48:10 <bigbabyjesusfoo> @babel en swedishchef BORK BORK BORK BORK
16:48:11 <lambdabot> babel module failed: Error: Language swedishchef not supported
16:48:23 <ihope> > last
16:48:24 <Pseudonym> @babel en se bork
16:48:24 <lambdabot>  add an instance declaration for (Show ([a] -> a))
16:48:24 <lambdabot> babel module failed: Error: Language se not supported
16:48:32 <Pseudonym> @babel en eo bork
16:48:33 <lambdabot> babel module failed: Error: Language eo not supported
16:48:37 <ncalexan> SamB: is Conjure in an open darcs repo somewhere?
16:48:55 <Pseudonym> @babel en fr I want some whine with my cheese.
16:48:57 <lambdabot>  Je veux un certain gmissement avec du mon fromage.
16:49:04 <Pseudonym> @babel fr en Je veux un certain gemissement avec du mon fromage.
16:49:06 <lambdabot>  I gemissement want some with my cheese.
16:49:15 <Pseudonym> @bable en fr I gemissement want some with my cheese.
16:49:17 <lambdabot>  Le gemissement I en veulent avec du mon fromage.
16:49:25 <Pseudonym> @bable fr en Le gemissement I en veulent avec du mon fromage.
16:49:26 <bigbabyjesusfoo> @babel en jive Excuse me miss, I speak Jive
16:49:37 <arjanb> @where Conjure
16:49:41 <lambdabot> babel module failed: thread killed
16:49:41 <lambdabot> babel module failed: Error: Language jive not supported
16:49:41 <lambdabot> http://j.mongers.org/pub/haskell/darcs/conjure/
16:49:48 <Pseudonym> @bable fr en Le gemissement I en veulent avec du mon fromage.
16:49:49 <lambdabot>  Gemissement I want some with my cheese.
16:50:01 <Pseudonym> @babel en fr Gemissement I want some with my cheese.
16:50:03 <lambdabot>  Gemissement I en veulent avec du mon fromage.
16:50:12 <Pseudonym> @babel fr en Gemissement I en veulent avec du mon fromage.
16:50:14 <lambdabot>  Gemissement I want some with my cheese.
16:50:17 <Pseudonym> Done.
16:51:40 <Pseudonym> @babel en es The rest of this sentence is in Indonesia, written on
16:51:42 <lambdabot>  El resto de esta oracin est en Indonesia, escrita encendido
16:51:52 <Pseudonym> @babel es en El resto de esta oracion esta en Indonesia, escrita encendido
16:51:53 <lambdabot>  The rest of this oration this in Indonesia, written ignited
16:52:02 <bigbabyjesusfoo> @babel en nl I'm Dutch, isn't that weird?
16:52:03 <Pseudonym> @bable en es The rest of this oration this in Indonesia, written ignited
16:52:04 <lambdabot>  Ik ben Nederlands, ben niet bizar dat?
16:52:05 <lambdabot>  El resto de esta oracin esto en Indonesia, escrito encendido
16:52:21 <Pseudonym> #bable es en El resto de esta oracion esto en Indonesia, escrito encendido
16:52:30 <Pseudonym> @bable es en El resto de esta oracion esto en Indonesia, escrito encendido
16:52:31 <lambdabot>  The rest of this oration this in Indonesia, written ignited
16:52:41 <SamB> dons: by making it prefer to finish downloading already-started pieces rather than start new ones, regardless of rarity
16:52:41 <newsham> do record fields get evaluated lazily?  ie. if   x = Foo { bar=expr1, baz=expr2 }    and expr2 is big and expensive, does expr2 get evaluated if I never use baz?
16:52:42 <Pseudonym> I like "ignited".
16:52:54 <Pseudonym> newsham: No.
16:53:06 <Pseudonym> However, you can make a field strict in the constructor.
16:53:08 <newsham> no to "not lazily" or no to "doesnt get evaluated"
16:53:12 <Pseudonym> If that's what you want.
16:53:18 <Pseudonym> It's lasy.  Does not get evaluate.
16:53:22 <newsham> thanks.
16:53:22 <Pseudonym> evaluated
16:53:56 <newsham> so I think I have a reasonable way to do unmarshalling so that it can be evaluated lazily
16:54:02 <newsham> but i still dont have a good way to do lazy marshalling
16:54:25 <SamB> dons: mind you, I have no real understanding of how I managed to do this, because the module in question is practically bereft of comments
16:55:29 <SamB> ncalexan: yes
16:55:37 <SamB> http://scannedinavian.org/~lemmih/conjure
16:55:51 <SamB> also see patches on http://blog.gmane.org/gmane.network.bit-torrent.conjure.devel
16:56:53 <Lemmih> SamB: I don't like haddock.sh.
16:58:11 <SamB> Lemmih: I agree with you!
16:58:18 <SamB> Lemmih: however, I'm not sure what to use instead
16:58:41 <SamB> Lemmih: You will hopefully like this last patch
16:59:51 <newsham> thoughts on this?  http://www.lava.net/~newsham/x/Pkts3.lhs.txt
16:59:53 <Lemmih> We can get Cabal to do it correctly with a few tweaks.
17:00:12 <SamB> Lemmih: I'm seeing some apparantly leaked sockets even after the two patches intended to remedy this...
17:01:01 <SamB> though at least it won't leak them when my connection is down
17:02:36 <Drakioned> hey
17:06:12 <SamB> Lemmih: that single patch radically reduces the number of unfinished pieces at any given time, and thereby reduce the number of blocks wasted by termination of conjure (intentional or otherwise)
17:06:35 <Lemmih> It looks good.
17:07:02 <SamB> as well as making blocks available to send to peers sooner
17:07:11 <SamB> Lemmih: however! I have no idea how it works. that file needs many comments!
17:09:04 <SamB> Lemmih: do you like the HTTP UI patches?
17:09:58 <Cale> Keal is almost certainly not a bot -- I'm not sure what to make of him really. I have some doubt that he really wants to piss people off... he might actually be insane.
17:10:18 <Lemmih> SamB: Sure.
17:11:03 <ncalexan> If Keal is a bot, he's far and away the best bot I've ever seen.
17:11:57 <ncalexan> @keal
17:11:58 <lambdabot> what are epsilons?
17:12:15 <Cale> @keal
17:12:16 <lambdabot> antiparsimony were 100% correct...
17:12:34 <palomer> #haskellians are notoriously hard to piss off
17:12:34 <pesco> Gaaah! Has anybody here used runInteractiveProcess?
17:12:59 <pesco> I can't figure out how to use it right.
17:13:17 <ncalexan> @keal
17:13:18 <lambdabot> and yes that was with zero formal training in all realms
17:13:26 <ncalexan> hehe...
17:13:36 <SamB> I really thought it was going to take more than that before I would be happy with the block picking and such, but now that I've done that the only thing that bothers me is how long pieces sometimes take to download, and I'm sure thats just from my 56k modem ;-)
17:13:44 <pesco> Maybe somebody can give me a stupid example, say, run cat, send "hello", and read it back?
17:13:44 <Cale> pesco: more specific question?
17:14:05 <SamB> 56k modems are a great way to stress test p2p apps ;-)
17:15:42 <SamB> ncalexan: yeah, its hard to get a bot to come up with such original ways to act stupid...
17:16:13 <SamB> ncalexan: I mean, if you could do that, it would probably be relatively easy to get it to actually act smart
17:16:38 <ihope> Is there a good way to do Java-style exceptions in Haskell?
17:16:40 <musasabi> dons: looking at it.
17:17:33 <pesco> Cale: The docs give an example. "(inp,out,err,pid) <- runInteractiveProcess ...; forkIO (hPutStr inp str)". Why forkIO?
17:18:19 <ncalexan> SamB: it wasn't so much the varied stupidity.  It was the way he integrated into the channel.  He developed something of a relationship with Cale, and others; he learnt to use lambdabot; he debugged several series expansions... clearly a mind, if a deeply troubled mind :)
17:18:38 <SamB> ncalexan: ah
17:19:04 <SamB> yes, that is a big factor as well...
17:19:14 <ncalexan> The thing that makes me think bot is that he did it not for hours, but for days.  Who has that kind of dedication?
17:19:39 <palomer> what's the big deal with keal?
17:19:41 <ihope> @keal
17:19:42 <lambdabot> i only trust opensource tools. where can i download haskell for windows?
17:19:51 <SamB> ncalexan: insane people!
17:19:58 <ncalexan> Point :)
17:20:01 <SamB> ncalexan: alternatively, keal could be a cabal
17:20:09 <ihope> Cabal?
17:20:21 <ncalexan> What a strange way to spend ones time.
17:20:23 <SamB> ihope: no, cabal
17:20:39 <SamB> ihope: a secret organization!
17:20:42 <gzl> what kind of strange things did he say?
17:20:57 <ncalexan> @keal
17:20:58 <lambdabot> know you know this 24 periods Keal SecretTM
17:20:59 <ncalexan> @keal
17:20:59 <lambdabot> can haskell pipe the raw irrational megaequation into an analog device
17:21:02 <SamB> ever heard of the PSU?
17:21:06 <ncalexan> Oh, that one's good.
17:21:23 <gzl> woah!
17:21:31 <gzl> pipe the raw irrational megaequation
17:21:33 <musasabi> dons: committed a fixed version.
17:21:48 <ihope> @type either Left Right
17:21:49 <lambdabot> forall b a. Either a b -> Either a b
17:21:53 * Heffalump only saw a few hours of Keal, when was he around?
17:23:03 <SamB> ncalexan: did you see that repo url for Conjure?
17:24:09 <ihope> > let left = Left; test left = 3 in test Left
17:24:11 <lambdabot> 3
17:24:19 <ihope> Omgwtfbbq.
17:24:49 <Heffalump> > let left = Left; test right = 3 in test Left
17:24:50 <lambdabot> 3
17:25:01 <Heffalump> (nice try ;-)
17:25:13 <ihope> Hahaha... hah... heh...
17:25:30 <ncalexan> SamB: yep, but it should have been scannedinavian.com.
17:25:55 <ncalexan> SamB: I don't really grok BT, I'm more interested in seeing good haskell style (in the large)
17:26:20 <SamB> ncalexan: oh?
17:26:47 <SamB> my "darcs send" invocation told me it was "Creating patch to http://scannedinavian.org/~lemmih/conjure..."
17:27:26 <SamB> ncalexan: I'm not sure this is good style exactly, though we probably try
17:27:43 <ncalexan> It told me the .org address was not a darcs repo; the .com address was fine.
17:27:54 <Cale> hmm
17:28:01 <ncalexan> SamB: well, of course I reserve my own judgement :)
17:28:03 <Cale> what was the last thing I said? :)
17:28:16 <ncalexan> Something about Keal.
17:28:20 <ncalexan> @keal
17:28:21 <lambdabot> better be atleast 16x16 color with extended ascii set
17:28:29 <Cale> <Cale> it's not necessary
17:28:29 <Cale> <Cale> (inp,out,err,pid) <- runInteractiveProcess "/bin/cat" [] Nothing Nothing
17:28:29 <Cale> <Cale> hPutStrLn inp "hello"
17:28:29 <Cale> <Cale> hClose inp
17:28:29 <Cale> <Cale> hGetLine out >>= print
17:28:31 <Cale> <Cale> ihope: you mean Java style in that every possible exception is mentioned in the type?
17:28:35 <ncalexan> Wait... that's reasonable.
17:28:40 <SamB> <Cale> pesco: more specific question?
17:28:44 <Cale> okay
17:29:06 <Cale> that was a reply to pesco
17:30:28 <ihope> <Cale> hey, I never said that
17:30:59 <ncalexan> <Cale> now I'm just making stuff up.
17:31:12 <Cale> heh
17:31:26 <ihope> <Cale> STOP THAT!
17:31:31 <Cale> hm?
17:31:59 <pesco> Cale: Ah, thanks.
17:33:15 <pesco> Cale: I think the problem I'm having, though, is that I want to wait for the program to terminate before using its output. But it doesn't seem to terminate until I've pulled everything out of its stdout or something.
17:34:25 <pesco> Because I want to know whether the command failed before I open the output file...
17:35:23 <Cale> pesco: which command? Is it something standard?
17:36:13 <pesco> Cale: It's ploticus. Takes data on stdin, produces a postscript file on stdout.
17:36:45 <Cale> If a program writes to stdout and nothing reads, I think it'll just block
17:37:18 <pesco> Cale: I guess, so I have to force the read somehow other than writing.
17:37:37 <Cale> You could have the program write to a file on disk, or a fifo.
17:37:44 <Cale> er
17:38:07 <Cale> yeah, a fifo ought to work
17:38:20 <pesco> That seems very complicated...
17:38:33 <pesco> s/complicated/contrived/
17:38:53 <Cale> or just read the output in your program
17:39:02 <Cale> and keep it until you need it
17:47:15 <tbfg> i've another monad question
17:47:31 <tbfg> i have a function returning an IO Integer and have to print some output
17:47:37 <tbfg> concat a string to the integer
17:47:42 <tbfg> how could I do that ?
17:47:57 <Pseudonym> show 10
17:48:02 <Pseudonym> @eval show 10
17:48:03 <lambdabot> "10"
17:48:08 <Pseudonym> That turns an integer into a string.
17:48:09 <Cale> do n <- myIOInteger; putStrLn ("n = " ++ (show n))
17:48:15 <tbfg> Pseudonym but it's an IO Integer
17:48:15 <Pseudonym> (Or any showable type, in fact.)
17:48:32 <Cale> tbfg: you have to run the computation to get an integer from it
17:48:56 <Cale> you can only do that inside another IO computation, which is okay, since you'll need to be in IO to do printing
17:49:35 <Pseudonym> Right.
17:49:44 <Pseudonym> Lunch.  BBL
17:50:03 <tbfg> Cale thx
17:50:09 <Cale> tbfg: you might read http://www.haskell.org/hawiki/IntroductionToIO and http://www.haskell.org/hawiki/UsingIo
17:50:15 <tbfg> i just cant figure out monadic operations on my own :(
17:51:45 <Cale> If you'd like to know about monads in general http://www.haskell.org/hawiki/MonadsAsContainers is my intro to monads
17:52:21 <tbfg> Cale thanks, I#ll check that
17:52:33 <tbfg> hmm just one more question for today :)
17:52:40 <Cale> sure
17:52:44 <tbfg> i had to write a function called filter
17:52:51 <tbfg> it is clashing with Prelude filter now
17:53:00 <tbfg> is there a way to call it full qulified ?
17:53:10 <tbfg> +a
17:53:13 <Cale> Main.filter if 'Main' is the name of your module
17:53:14 <ski> import qualified Prelude
17:53:24 <Cale> import Prelude hiding (filter)
17:53:35 <tbfg> I actually need filter...
17:53:42 <Cale> oh, okay
17:53:50 <ski> then use both
17:54:02 <Cale> You can still call the Prelude filter with Prelude.filter
17:54:10 <tbfg> how does haskell differ between qualified name and function composition...
17:54:16 <Cale> spaces
17:54:26 <Cale> Prelude . filter is composition
17:54:35 <Cale> Prelude.filter is a qualified name
17:54:41 <tbfg> hmm
17:54:45 <ski> @type \g f -> f.g
17:54:46 <lambdabot> forall b c a. (a -> b) -> (b -> c) -> a -> c
17:54:49 <tbfg> a.b is composition too..
17:55:10 <ski> qualified if it starts with module identifier (uppercase start)
17:55:13 <Cale> when a is lowercase :)
17:55:22 <tbfg> got it :)
17:55:26 <ski> @type \g f -> F.g
17:55:27 <lambdabot> Couldn't find qualified module.
17:55:27 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
17:55:27 <lambdabot> \\)?
17:56:00 <Cale> of course, you can have data constructors which are uppercase too, and you might want to compose them with another function, in that case, you really need the spaces
17:56:01 <tbfg> thanks guys! you helped me a lot
17:56:16 <ski> @type \g -> Just.g
17:56:17 <lambdabot> Couldn't find qualified module.
17:56:17 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
17:56:17 <lambdabot> \\)?
17:56:19 <ski> @type \g -> Just . g
17:56:20 <lambdabot> forall b a. (a -> b) -> a -> Maybe b
17:56:24 * beelsebob_ licks people
17:56:32 <SamB> tbfg: but watch out! a.b might someday mean something else
17:56:53 <ski> hm ?
17:57:06 <Cale> I kind of think it might be a good idea to make all binary operators require spaces
17:57:08 <beelsebob_> it's caught at the type checker... it depends on whether F in F.g is a module name or not
17:57:33 <ihope> @type either Right Left
17:57:34 <lambdabot> forall b b1. Either b1 b -> Either b b1
17:57:48 <Cale> ihope: hehe
17:58:12 <mstermind> must go today 1 alienware laptop area51-m 5700 price $500 price includes shipping, wireless router and carry case, 1 alienware desktop area51 7500 price $550 including shipping, monitor, speakers.  message me if interested on aim at mikcomputing, aim at mcsltd3@hotmail.com or yahoo at mcsltd2 only if interested and wanting to buy.  willing to put on a yahoo buy it now auction
17:58:30 <Cale> mstermind: K-Lined! Soon!
17:59:06 <Cale> mstermind: you said that here the other day. Nobody cares, and it's rude.
17:59:58 <SamB> mstermind: I might pay $100
18:00:11 <Cale> heh
18:00:25 <SamB> but I'd be more inclined to do so if you would use real english!
18:00:31 <ihope> I'll pay a quarter for it!
18:03:39 <CosmicRay> @seen syntaxninja
18:03:40 <lambdabot> I saw syntaxninja leaving #haskell and #haskell-blah 3 days, 35 minutes
18:03:40 <lambdabot> and 57 seconds ago.
18:03:44 <CosmicRay> bah
18:04:11 * beelsebob_ farts at CosmicRay 
18:04:17 <mfgl> Cale: http://www.haskell.org/hawiki/MonadsAsContainers  is really informative. Thankyou.
18:04:30 <Cale> mfgl: glad you like it :)
18:05:57 <SamB> beelsebob_: how wude
18:06:04 <yome> @seen yome
18:06:05 <lambdabot> You are in #haskell. Last spoke just now.
18:06:15 <beelsebob_> @yow
18:06:16 <lambdabot> ... bleakness ... desolation ... plastic forks ...
18:06:24 <beelsebob_> nooo... plastic sporks!
18:06:27 <yome> Oh!  At last another useful bot!
18:07:26 <ihope> @. elite yow
18:07:27 <lambdabot> \/\/H4t i W4n7 tO FIND Ou+ is -- Do pARR0Tz0rz kN0W /\/\U(h 4bou+ AS+r0-+
18:07:27 <lambdabot> URf?
18:07:51 <ihope> Are there any other such things?
18:07:56 <SamB> @. vixen keal
18:07:57 <lambdabot> are you horny?
18:08:26 * SamB wishes he could see what keal said too
18:08:26 <ihope> @vixen Eh? What? Hmm.
18:08:27 <lambdabot> who's to say?
18:08:32 <ihope> @vixen
18:08:33 <lambdabot> i'm a huge baseball fan
18:08:37 <ihope> @help vixen
18:08:38 <lambdabot> sergeant curry's lonely hearts club
18:08:41 <ihope> @. elite elite
18:08:42 <lambdabot> Say 4gAIN?
18:08:53 <SamB> @vixen huge baseball?
18:08:54 <lambdabot> yes
18:09:06 <SamB> @elite
18:09:08 <lambdabot> Say again?
18:09:09 <ihope> @vixen Can you repeat that?
18:09:10 <lambdabot> I'm sorry, I forgot we already talked about that...
18:09:19 <ihope> @vixen That's too bad.
18:09:20 <lambdabot> yeah, it's a shame
18:09:39 <ihope> @. vixen vixen Woot
18:09:40 <lambdabot> yeah, i am... but bad is better than nice :)
18:09:45 <ihope> @vixen woot
18:09:46 <lambdabot> I will NOT be ignored...
18:09:50 <ihope> @vixen
18:09:51 <lambdabot> :)
18:09:59 <SamB> @elite . keal
18:10:00 <lambdabot> . xEAl
18:10:07 <ihope> @. elite keal
18:10:08 <lambdabot> I Ne3D M47|-| phrienDLy C0mpI1eR t0 C0/\/\PIle fOR JVm OR Fl45h
18:10:23 <ihope> "malh"?
18:10:28 <ihope> Math!
18:10:30 <Cale> math
18:10:51 <Cale> @. elite keal
18:10:52 <lambdabot> i |-|ave 8AzIca||Y wRI77eN A pr00ph +hat sHo\/\/5 an a5zuMptI0N iS
18:10:52 <lambdabot> WRong
18:11:24 <palomer> ok, someone explain me the keal situation
18:11:43 <SamB> palomer: keal is freaky
18:12:10 <SamB> palomer: but quoted, he's almost as good as YOW
18:12:10 <Cale> Keal is just this guy who is either a troll or just plain crazy
18:12:12 <pesco> When did he first appear?
18:12:13 <ihope> @keal is freaky
18:12:14 <lambdabot> with KealDigit quantum crackproof encryption possible
18:12:18 <Cale> couple years ago
18:12:28 <Cale> Used to use the nick 'jargon'
18:12:36 <Cale> @keal
18:12:37 <lambdabot> Cale etc already pointed out Haskell is puny to nothing to emulate using
18:12:37 <lambdabot> my barrage of mathematic theories
18:12:43 <SamB> Cale: did he escape from a mental institution
18:13:10 <Cale> SamB: I don't know -- he's mentioned that he has a few psychiatric problems
18:13:11 <palomer> ok, and why is everyone obsessing about keal?
18:13:19 <Cale> palomer: he's just funny
18:13:25 <palomer> is he banned?
18:13:41 <Cale> I don't think so
18:13:48 <pesco> No, /whois says he's in #math.
18:14:08 <pesco> Or did you mean from #haskell? Dunno.
18:14:19 <Cale> @seen shapr
18:14:20 <lambdabot> shapr is in #ScannedInAvian. Last spoke 3 hours, 14 minutes and 32
18:14:20 <lambdabot> seconds ago.
18:14:25 <palomer> from #haskell
18:14:25 <Cale> oh, so he was here
18:14:26 <Lemmih> He's banned from #haskell.
18:14:48 <beelsebob_> shapr's banned?
18:14:53 <Cale> no
18:15:00 <palomer> why is he banned?
18:15:03 <Cale> shapr is an op here
18:15:14 <palomer> banning shapr would be blasphemous
18:15:14 <beelsebob_> I thought it was a bit odd
18:15:16 <Cale> I haven't seen him around much
18:15:28 <SamB> beelsebob_: keal is the one who would be banned
18:15:33 <beelsebob_> no... he's not been in #unicycling much either
18:15:49 <ihope> @. vixen keal
18:15:49 <Cale> (and shapr would likely be the person who would be in charge of handing out that ban)
18:15:50 <lambdabot> girls masturbate too you know... probably more than guys. we can do it
18:15:50 <lambdabot> anywhere discretely
18:15:57 <ihope> !
18:16:05 <Cale> haha
18:16:07 * Lemmih giggles.
18:16:39 <beelsebob_> @vixen shapr
18:16:40 <lambdabot> i'm the type of girl that finds Don Knotts very sexy
18:17:13 <Cale> @. vixen vixen
18:17:14 <lambdabot> hey, who did we fight in WWII besides Germany and Russia?
18:17:26 <pesco> Hah, a good game! Try to reverse engineer what Keal said from vixen's response.
18:17:35 <pesco> @. vixen keal
18:17:36 <lambdabot> I Think you're fake
18:17:41 <pesco> Haha.
18:17:41 <Cale> hahaha!
18:17:45 <beelsebob_> @. keal
18:17:46 <lambdabot> Not enough arguments to @.
18:17:52 <beelsebob_> @. vixen keal
18:17:53 <lambdabot> you sure can
18:18:05 * beelsebob_ tries to figure out what vixen does
18:18:11 <beelsebob_> @. vixen beelsebob_
18:18:12 <lambdabot> compose module failed: Parse error: "beelsebob_"
18:18:13 <pesco> Vixen seems to deal real well with him!
18:18:23 <pesco> @. vixen keal
18:18:24 <lambdabot> Ooh, functional programmers are so hot!
18:18:33 <pesco> Heheh.
18:18:35 <beelsebob_> @vixen beelsebob
18:18:36 <lambdabot> i could really use a backrub
18:18:55 <beelsebob_> @vixen spj
18:18:56 <lambdabot> ouch! I just spilt hot coffee on myself!
18:19:00 <beelsebob_> :o
18:19:50 <Cale> @vixen hello
18:19:51 <lambdabot> hi
18:20:02 <palomer> @quote palomer
18:20:07 <palomer> @palomer
18:20:08 <lambdabot> Unknown command, try @listcommands.
18:20:49 <Cale> @vixen so what have you been up to?
18:20:50 <lambdabot> not much, what's up with you?
18:23:03 <TheHunter> @. vixen . vixen . vixen keal
18:23:36 <TheHunter> @bot
18:24:00 <bigbabyjesusfoo> @vixen how naughty is lazy evaluation
18:24:04 <Lemmih> Oh, my God! You killed lambdabot.
18:24:13 <bigbabyjesusfoo> you bastard!
18:24:26 <TheHunter> me?
18:24:39 <palomer> @vixen I'd like to lift your monads
18:26:42 * TheHunter just saw lambdabot's picture on her homepage.
18:27:00 <palomer> > 2+2
18:27:04 <dons>  musasabi, I've written a fast non-leaking regex-dna :)
18:27:07 <palomer> I think lambdabot has me on ignore
18:27:52 <Cale> @bot
18:28:17 <Cale> @get-dons-to-restart-you
18:43:05 <TheHunter> @bot
18:43:09 <TheHunter> sorry :(
18:51:39 <cjs> So where the heck is this mysterious, "R.Bird . Introduction to Functional Programming using Haskell" book? Amazon's never heard of it. Google finds only references to it.
18:52:31 <Cale`> http://www.cambridge.org/uk/catalogue/catalogue.asp?isbn=0521277248
18:52:40 <Cale`> er
18:52:40 <Cale`> no
18:52:46 <Cale`> http://web.comlab.ox.ac.uk/oucl/publications/books/functional/
18:53:37 <Cale`> http://www.amazon.co.uk/exec/obidos/ASIN/0134843460/202-4426201-6351026
18:55:19 <Cale> cjs: google finds it just fine :)
18:57:48 <palomer> google makes your daddy want to rock
19:18:50 <cjs> Hm. Must be my inability to use google.
19:19:07 <cjs> Oh, wait; I bet you're using google.co.uk, right?
19:23:45 <Cale`> no, I'm not actually in the UK
19:24:05 <Cale> @google Introduction to Functional Programming using Haskell
19:24:07 <lambdabot> http://web.comlab.ox.ac.uk/oucl/publications/books/functional/
19:24:24 <Cale> @google amazon Introduction to Functional Programming using Haskell
19:24:26 <lambdabot> http://www.amazon.com/exec/obidos/tg/detail/-/0201342758?v=glance
19:25:38 <Cale> well, that's not the right link
19:26:09 <Cale> http://www.amazon.com/gp/product/0134843460/104-7475590-4343110?n=283155 -- here's the book on amazon.com
19:31:27 <cjs> That link definitely did not come up on my Amazon search--and I included both author and title.
19:31:29 <cjs> Odd.
19:31:58 <cjs> And I wonder why Wadler is still listed as an author of the 2nd edition.
19:33:38 <Cale`> why wouldn't he be?
19:34:23 <cjs> I don't think he was co-author of the 2nd edition. I'd heard he was, er, "ejected." And his name's not on the cover.
19:34:46 <Cale> odd
20:18:36 <palomer> > (\x -> case x of ILit y -> y ; _ -> 4) ILit 8 
20:18:38 <lambdabot>  Not in scope: data constructor `ILit'
20:18:56 <palomer> > (\x -> case x of y -> y ; _ -> 4)  8 
20:18:57 <lambdabot>   Warning: Pattern match(es) are overlapped
20:18:57 <lambdabot>      In a case alternative: _ -> ...
20:19:11 <palomer> > (\x -> case x of 8 -> 9 ; _ -> 4)  8 
20:19:13 <lambdabot> 9
20:22:40 <palomer> GADTs are super broken in haskell
20:22:55 <Lemmih> How so?
20:23:04 <palomer> the wobbly types paper is wrong in so many ways
20:23:47 <palomer> http://www.rafb.net/paste/results/tQT5KH76.html <--this should compile, but doesn't
20:24:33 <Lemmih> palomer: s/ILit 8/(ILit 8)/
20:25:20 <palomer> yeah, still doesn't compile
20:26:07 <palomer> http://www.rafb.net/paste/results/KOQlj257.html <--still doesn't compile
20:26:21 <Lemmih> Oh, right.
20:26:29 <arjanb> palomer: maybe leave the last argument out?
20:26:53 <Lemmih> s/ILit 8//
20:27:03 <palomer> check out my latest paste
20:27:14 <palomer> that really should compile
20:27:28 <Lemmih> palomer: No, it shouldn't.
20:27:32 <palomer> why not?
20:27:49 <palomer> oh, right, one sec
20:27:49 <Lemmih> palomer: "foo = (\x -> case x of ILit y -> y ; BLit y -> y)" works.
20:28:05 <Lemmih> palomer: Same reason 'foo Just 10 = ()' fails.
20:28:54 <Lemmih> palomer: 'foo (ILit y) = y; foo (BLit y) = y' also works.
20:31:31 <palomer> http://www.rafb.net/paste/results/54cYm951.html <--nonetheless, this should work
20:33:01 <Lemmih> palomer: No, it shouldn't.
20:33:05 <palomer> why not?
20:34:02 <Lemmih> "(\x -> case x of ILit y -> y ; BLit y -> y)" is a function of type "Term a -> a". You can't just cast it to "Term Int -> Int".
20:34:22 <palomer> ok, do you agree with this statement:
20:34:34 <palomer> if a::forall s.T, then a::T[u/s] for any u ?
20:35:20 <TheHunter> has -package posix been renamed?
20:35:42 <Lemmih> TheHunter: I think it's called 'unix' now.
20:36:10 <TheHunter> thanks, that appears to work.
20:36:52 <palomer> I can concoct other examples where the haskell type system fails where it shouldn't when dealing with GADTs
20:38:31 <palomer> the wobbly types paper is pure crap
20:38:40 <palomer> no offence to anyone who contributed to it here
20:42:36 <palomer> http://www.rafb.net/paste/results/0fyOGN12.html <---this, to me, makes _no_ sense
20:44:37 <ncalexan> What's wrong?  What doesn't make sense?
20:48:41 <TheHunter> I don't suppose anyone has encountered this before? runplugs: user error (loadShared: couldn't load `librt.so' because /usr/lib/librt.so: symbol __librt_multiple_threads, version GLIBC_PRIVATE not defined in file libc.so.6 with link time reference)
20:52:35 <palomer> ncalexan: clearly, y has to be of type int
20:53:07 <palomer> http://www.rafb.net/paste/results/faoFuh46.html <--yet here it isn't
20:54:18 <Lemmih> palomer: It only has to be an Int if the first argument is a "Term Int".
20:54:52 <palomer> or else it's free?
20:55:29 <palomer> any same type inference scheme would declare "y is an int you dopes!"
20:56:55 <palomer> http://www.rafb.net/paste/results/TVi2N919.html <--ok, here's a really strange one
20:56:58 <Lemmih> 'case x of ILit i -> [x must be of type 'Term Int' which means y is an Int]; BLit _ -> [x is Term Bool so y is a Bool]'
20:57:32 <palomer> it chokes on h, remove h and it compiles
20:57:57 <Lemmih> Of course.
20:58:13 <palomer> notice that h has the same definition as f
20:58:21 <palomer> and, through g, the same annotations
20:58:25 <palomer> so why should f compile and not h?
20:58:26 <ncalexan> palomer: no, y can't be fixed.
20:58:41 <Lemmih> palomer: A 'Term Int' will /never/ contain 'BLit'.
20:59:00 <palomer> ncalexan: Term a -> Int -> Int  is another valid type of the function
20:59:37 <palomer> Lemmih: why does haskell accept f:: Term Int -> Int and not h:: Term Int -> Int ?
20:59:47 <palomer> when they have _the same definition_
20:59:49 <ncalexan> palomer: what if you wanted to do something with 'y' in the BLit option?  You should be able to do that; 'y' just has to agree with the type of the term.
21:00:08 <Lemmih> palomer: Because 'Term Int' will /never/ contain a BLit.
21:00:17 <palomer> ncalexan: oh no, you can't, try it out
21:00:40 <Lemmih> palomer: '(((\x -> case x of ILit y -> y; BLit y -> y) :: Term a -> a) :: Term Int -> Int)' works, btw.
21:01:13 <palomer> I don't care that Term Int will never contain a BLit
21:01:38 <palomer> functions with the same definitions should be able to be annotated identically, and more specific annotations should always work
21:01:53 <ncalexan>  
21:01:53 <ncalexan> i :: Term a -> a -> a
21:01:53 <ncalexan> i (ILit _) y = y
21:01:54 <ncalexan> i (BLit _) y = y
21:02:30 <TheHunter> palomer, this already doesn't apply to pre-gadt ghc.
21:02:35 <ncalexan> palomer: I believe wobbly types are only in 6.5, and even then quite experimental... I'm only using 6.4.1, so we might have clashes if you're CVS.
21:02:58 <Lemmih> palomer: I guess it's possible to lift that restriction and make it a warning instead.
21:02:58 <palomer> ncalexan: clearly i should also have type Term a -> b -> a
21:03:17 <ncalexan> Well, I specified its type to demonstrate a point.
21:03:37 <ncalexan> My GHCi infers forall t a. Term a -> t -> t
21:03:41 <ncalexan> As you want.
21:03:41 <palomer> ncalexan: but you didn't use y as an int anywhere
21:03:56 <ncalexan> Of course not -- there's not much that you can do with an Int and a Bool.
21:03:58 <palomer> err, yeah, Term a -> t -> t, I meant
21:04:01 <ncalexan> Structure them into a list, or whatever.
21:04:06 <ncalexan> Or id them.
21:04:13 <palomer> ncalexan: in my example I had used y clearly as an int
21:04:20 <palomer> ncalexan: I had even used addition on it
21:04:23 <ncalexan> In only one case.
21:04:38 <ncalexan> You could do something -- && with y, for instance -- in the Bool option.
21:04:50 <palomer> try it out
21:04:54 <palomer> try using y as an int and as a bool
21:04:58 <palomer> it will fail miserably
21:05:05 <palomer> wait, lemme try first:P
21:05:25 <palomer> no wait, it would work
21:06:09 <palomer> good point
21:06:22 <palomer> still, I stand by my last point on annnotations
21:06:48 <ncalexan> The whole point of wobbly types paper is that at the moment, you need to annotate.
21:06:54 <palomer> yes
21:06:56 <ncalexan> It works fine if you annotate Term a -> a -> a.
21:07:11 <palomer> but the fact is you can't annotate with a specific annotations
21:07:26 <ncalexan> You sometimes get better error messages if you use explicit forall rather than GADT, BTW.
21:07:57 <ncalexan> f :: Term a -> Int -> a
21:07:57 <ncalexan> f (ILit x) y = x + y
21:07:57 <ncalexan> f (BLit x) y = x
21:07:58 <ncalexan>  Works for me.
21:08:02 <palomer> http://www.rafb.net/paste/results/Ayi1QH35.html <--this chokes on h
21:08:13 <palomer> it really should not choke on h
21:08:18 <ncalexan> Of course it should.
21:08:33 <ncalexan> You're telling it to return an Int.
21:08:39 <ncalexan> But (BLit x) -> x returns a Bool.
21:08:45 <TheHunter> palomer, you're right, there's something unpleasing about that (and similar problems that turn up with fundeps), but that certainly does not imply that "the wobbly types paper is pure crap".
21:09:15 <palomer> ok, I back down from the pure crap part
21:09:22 <ncalexan> palomer: check your 'h'.  What should it return?
21:09:37 <palomer> ncalexan: when passed a Term Int, it should return an Int
21:09:41 <palomer> that's all my annotation says
21:10:05 <ncalexan> But you specified a Term Bool clause... that does not return an Int.  What possible correct action is there to take?  Silently ignore?
21:10:31 <ncalexan> I get a very nice "Inaccessible case alternative..." message.
21:10:32 <palomer> ncalexan: I don't care about the other clauses, really
21:10:43 <palomer> ncalexan: anyways, in my program, f has type Term Int -> Int
21:10:45 <ncalexan> But they don't type check... you see that, right?
21:10:52 <ncalexan> Sorry, I'm talking about 'h'.
21:11:01 <musasabi> palomer: "h" does seem incorrect.
21:11:05 <ncalexan> h :: Term Int -> Int
21:11:05 <ncalexan> h (ILit x) = x
21:11:05 <ncalexan> h (BLit x) = x
21:11:14 <palomer> ok, h fails with the annotation Term Int -> Int but f passes?
21:11:15 <ncalexan> That can never be right -- it returns a Bool as an Int in the last line.
21:11:25 <musasabi> palomer: yes.
21:11:32 <palomer> and you guys are ok with this?
21:11:37 <musasabi> palomer: yes.
21:11:39 <ncalexan> Yes.
21:12:00 <palomer> that you can't annotate with a more specific type?
21:12:19 <ncalexan> Can you paste the latest version?
21:12:28 <ncalexan> For me, I think I can annotate with a more specific type.
21:12:30 <musasabi> palomer: "h (BLit x) = x" => "Term _ -> _" where _ must be unifiable with Bool.
21:12:31 <palomer> http://www.rafb.net/paste/results/Ayi1QH35.html
21:12:43 <TheHunter> I agree, "Inaccessible case alternative" should be a warning, not an error.
21:13:07 <palomer> I think there's something fundementally wrong with the type system
21:13:31 <ncalexan> palomer: f and g are two different functions, in the sense that they do not have the same domain.
21:13:36 <palomer> TheHunter: notice that the case alternative is as inaccessible in g as it is in h
21:14:04 <TheHunter> there is no case analysis done in the definition of g.
21:14:14 <palomer> TheHunter: g is the same function as f
21:15:14 <ncalexan> palomer: patently not.  g is not defined on (Term Bool) values, for instance.
21:15:19 <TheHunter> with a different definition...
21:15:24 <ncalexan> They are the same function when restricted to (Term Int).
21:15:26 <palomer> ok, then g is the same as h
21:15:44 <TheHunter> h is more special than g.
21:15:52 <ncalexan> Again, not when you look at the domain.
21:16:06 <palomer> hmm? show me how they would behave differently
21:16:16 <ncalexan> The type system won't let me.
21:16:31 <palomer> assume it let you define h that way
21:16:39 <ncalexan> I can evaluate f (BLit False), for instance.  But I can't evaluate g (BLit False).
21:16:57 <palomer> ncalexan: I'm talking about the difference between g and h 
21:17:07 <ncalexan> palomer: arguing that the type system is broken, and then imagining that you can do certain things in it... that's a difficult argument to maintain.
21:17:25 <palomer> you guys argued that g and h are different
21:17:38 <palomer> and I'm saying that they are different inasmuch as the type system is cooky
21:17:40 <ncalexan> They are!  h is undefined on (BLit False), for instance.
21:17:53 <palomer> no it isn't, it has type Term Int -> Int
21:18:08 <ncalexan> And yet, BLit False is not of type Term Int.
21:18:23 <TheHunter> they of course denote the same function, but with a different definition.
21:18:26 <ncalexan> While f (BLit False) is defined.
21:18:45 <ncalexan> TheHunter: not in the standard set theoretic function sense.
21:19:00 <ncalexan> f === g <=> f(x) = g(x) for all x _in the domain of definition_.
21:19:06 <ncalexan> The domain really does count!
21:19:07 <palomer> ncalexan: you can ignore f and focus and g and h
21:19:14 <palomer> s/second and/on
21:19:27 <palomer> anyways, we're getting nowhere
21:19:36 <TheHunter> ncalexan, afaics, both of them are of Type  Term Int -> Int.
21:19:58 <palomer> I find haskell's GADT type system relies too heavily on annotations, and is too restrictive in its annotations
21:19:59 <ncalexan> Sorry, I thought the issue was f and h.  Damn one letter names :)
21:20:35 <TheHunter> i don't see what more you want us to say than that h should be accepted.
21:20:43 <palomer> well then say it
21:20:50 <ncalexan> Then I agree that maybe h should warning, rather than error...
21:20:57 <TheHunter> <TheHunter> I agree, "Inaccessible case alternative" should be a warning, not an error.
21:20:59 <ncalexan> But that's a pretty minor complaint.
21:21:33 <palomer> TheHunter: yeah, but I also wanted to hear it from the others
21:21:50 <ncalexan> palomer: then you win :)
21:21:52 <palomer> ok, now let's say I want to type the expression "a b"
21:22:12 <palomer> a must have type B -> C, and b must have type B, do we agree?
21:23:31 <ncalexan> I think so.
21:23:46 <palomer> now, let t stand for the term (\x -> case x of ILit y -> y ; BLit y -> y) (ILit 8)
21:23:59 <TheHunter> and there are much nastier "features" of current ghc's type system - all that stuff is experimental.
21:24:44 <palomer> if you annotate the left expression of t with (Term Int -> Int) then you get an error
21:24:44 <TheHunter> for example, as soon as you mix gadts and fundeps, all hell breaks loose
21:24:54 <palomer> but this, however, is the annotations needed for HM !
21:25:13 <ncalexan> TheHunter: pointer to an example?
21:25:58 <palomer> TheHunter: is this true with the wobbly system too?
21:26:33 <TheHunter> i never read the paper, so i wouldn't know.
21:26:54 <TheHunter> anyway, that sort of thing is kind of expected if you mix two unrelated experimental extensions
21:27:28 <TheHunter> ncalexan, there's a lot about that on the mailing lists, just google  for 'gadts' and 'fundeps'
21:27:49 <palomer> furthermore, I don't see why these annotations are needed, really
21:28:53 <ncalexan> palomer: that just means you don't understand the material leading up to wobbly types.
21:29:15 <ncalexan> Higher rank type inference is undecidable.
21:29:48 <palomer> are you saying that type inference with GADTs is undecidable?
21:30:18 <ncalexan> I believe so.  GADTs wrap higher rank functions into data types.
21:30:38 <ncalexan> At least, that's what I'm using them for.
21:30:48 <palomer> I've never seen any paper claiming that type inference with GADTs is undecidable
21:30:56 <palomer> higher rank functions are functions from terms to types, right?
21:31:29 <ncalexan> That might be an equivalent characterisation, but I'm thinking of function arguments that are used polymorphically in a function.
21:31:47 <palomer> oh, System F
21:31:48 <ncalexan> Classic example: \f -> (f [1,2,3], f [True, False]).
21:32:21 <TheHunter> i'd be surprised if there were even principal types for gadts, but maybe i'm already thinking about the interaction with other extensions.
21:32:32 <palomer> TheHunter: there aren't
21:32:35 <ncalexan> System F is just one type system.
21:32:51 <palomer> ncalexan: you mean to put forall quantifiers anywhere within the type, right?
21:33:03 <ncalexan> That's another characterisation.
21:33:10 <palomer> @type (\f -> (f [1,2,3],f [True,False])
21:33:12 <lambdabot> parse error (possibly incorrect indentation)
21:33:12 <palomer> @type (\f -> (f [1,2,3],f [True,False]))
21:33:13 <lambdabot>   No instance for (Num Bool)
21:33:13 <lambdabot>   arising from the literal `1' at <interactive>:1:11
21:33:34 <palomer> anyways, I don't see what GADTs have to do with higher rank functions
21:33:46 <palomer> and if you have a paper supporting your argument, I'd very much like to see it
21:34:04 <ncalexan> I don't, but it's really easy to see how they wrap higher rank functions.
21:34:17 <ncalexan> Let me prepare a paste.
21:35:33 <TheHunter> what do you want type inference to do when there is more than one most general type?
21:35:53 <palomer> return all possible types
21:36:10 <palomer> what else do you want it to do?
21:36:38 <TheHunter> assign an arbitrary one? complain?
21:37:00 <palomer> oh no, that wouldn't work
21:37:19 <palomer> since the infer usually calls upon itself 
21:37:23 <palomer> infer function
21:38:02 <ncalexan> http://www.rafb.net/paste/results/9OTC0n99.html
21:38:05 <palomer> anyways, there's nothing wrong with having union types
21:38:20 <ncalexan> That should at least suggest that GADTs and higher rank types are related :)
21:38:45 <palomer> ncalexan: can you do this without typeclasses?
21:38:58 <ncalexan> palomer: sure, but you can't do anything useful :)
21:39:35 <ncalexan> typeclasses are the way to actually make a GADT that loses type information (notice that Showable does not expose information about the 'a' it's carrying) do something useful.
21:39:38 <ncalexan> Anyway, I must go.  g'night all, thanks for the discussion palomer, TheHunter
21:39:58 <palomer> erm, it's higher rank on a finite number of types
21:45:05 <musasabi> type classes are on a finite number of types in any given program too.
21:45:30 <vincenz> Out of curiousity
21:45:44 <vincenz> that little codesample that ncalexan pasted
21:46:11 <vincenz> how does haskell do that for multiple types
21:46:22 <vincenz> runtime dispatching or multiple code instantiations?
21:47:26 <dons> ah, so happy. musasabi, my new regex-dna runs in constant space, and about 1000x faster :)
21:47:30 <musasabi> vincenz: GHC adds a dictionary to the values with Showable (the constructor)
21:47:49 <vincenz> so if it does that
21:47:56 <vincenz> why can't you have heterogeneous containers
21:48:03 <vincenz> it's doing runtime dispatching anyways
21:48:21 <dons> you can have heterogeneous containers. but it needs to do runtime dispatching.
21:48:31 <vincenz> it apparently already does runtime dispatching
21:48:47 <vincenz> 06:26 < musasabi> vincenz: GHC adds a dictionary to the values with Showable
21:49:15 <dons> > [toDyn 'x', toDyn (7::Int), toDyn ()]
21:49:15 <TheHunter> that example doesn't need gadts btw.
21:49:16 <lambdabot> [<<Char>>,<<Int>>,<<()>>]
21:49:19 <musasabi> vincenz: that equals to an indirect function call.
21:49:55 <vincenz> dons: but haskell uses indrection by default!
21:49:58 <dons> ooooh. new regex-dna uses 20% of the memory of the perl version :)
21:50:07 <vincenz> nice
21:50:13 <vincenz> you people are hacking the alioth shootout, hmm?
21:50:18 <dons> ah, but slower still. /me keeps hacking.
21:50:28 <vincenz> > 1+1
21:50:29 <lambdabot> 2
21:50:36 <musasabi> dons: sounds very nice :-)
21:50:40 <musasabi> dons: What did you do?
21:51:04 <dons> I wrote a Word8 getContents, and a regexec on Word8 buffers
21:51:23 <dons> i.e. poor mans FPS in 20 lines :)
21:52:10 <vincenz> anyways
21:52:15 <dons> (it bugged me that Isaac used regex-dna as an example on the list today, and that people responded saying "well, a language can't do everything" -- not true!)
21:52:17 <vincenz> if haskell uses dispatching by default
21:52:20 <vincenz> why the need for toDyn
21:53:41 <dons> it's a list of dynamically typed values
21:53:53 <vincenz> but dispatching is done ANYWHO
21:53:56 <vincenz> ANYHOW
21:53:59 <vincenz> so why
21:55:18 <musasabi> dons: sounds good.
21:55:26 <musasabi> Still I want to have 6.6 and real fps.
21:55:32 <dons> so do I
21:55:40 <vincenz> ...
21:55:48 <dons> (but I can't sleep while haskell looks bad on the regex test ;)
21:56:19 <dons> hmm. /me counts 2800 loc in his shootout hack dir
21:56:59 <musasabi> dons: tell me when you have something committed. If you want I think you could ask Isaac for commit bit as you seem to do most of the hacking these days if it is easier for you.
21:57:10 <vincenz> musasabi: so if you always do runtime dispatchiing, why do you need toDyn
21:57:33 <dons> vincenz, I'm just showing one way to do heterogeneous lists. there's other ways that uses typeclasses
21:57:37 <dons> look at HList
21:57:57 <vincenz> dons: I think you misunderstand my question
21:58:04 <vincenz> I'm not looking at a way to do hetero
21:58:23 <vincenz> I'm wondering why it can not be done by default given that runtim dispatching is the default tactic for any function taking a calss with multiple instances
21:58:30 <musasabi> vincenz: in many cases the indirect call can be compiled into a direct one.
21:58:30 <vincenz> class even
21:59:02 <dons> what's the type of the list of heterogeneous values going to be, vincenz?
21:59:19 <vincenz> Showable 
21:59:21 <vincenz> for instance
21:59:35 <dons> you could build a list of existentials under Show, yes.
21:59:43 <dons> (I think I've done that before)
22:00:36 <dons> a list of [forall a. Show a => E a]
22:00:55 <dons> yeah, we have heterogenous Data.Maps in lambdabot, so that's one way.
22:01:11 <vincenz> hmm
22:01:20 <dons> so those value guarantee to provide methods of class Show, but that's all we know about them.
22:01:45 <dons> data E = forall a . Show a => E a
22:02:17 <dons> is that what you mean? since you know some information from the dictionary, why not use that to build safe hlists?
22:02:47 <vincenz> yes
22:03:02 <vincenz> due to the fact you use runtime dispatching
22:03:09 <vincenz> you could have heterogeneous lists
22:03:15 <vincenz> that's the only requirement for runtime dispatching
22:03:19 <dons> yeah. the dictionary is the existential's interface when you 'unpack' it.
22:03:22 <vincenz> I mean (for heterogeneous lists)
22:03:52 <qnix_> hi, could someone pls explain how I can make haxml to print (render) the xml in the "traditional" way ?
22:06:53 <qnix_> i've try define my own render in term of fullRender using different Mode, but unless I go for one-line mode, it render the xml in HaXml's peculiar way. :(
22:09:33 <Lemmih> dons: Will you put the code on the wiki?
22:10:17 <dons> I will soon, just profiling and finishing it off.
22:10:21 <dons> give me a few hours
22:10:33 <dons> (trying to beat perl's run time)
22:11:25 <Korollary> a noble cause
22:11:36 <dons> beating it with a stick
22:26:03 * vincenz is reading the gentle introduction to haskell
22:26:07 <vincenz> but
22:26:07 <vincenz> hmm
22:26:13 <vincenz> data (a,b) = (a,b)
22:26:17 <vincenz> isn't that redundant?
22:26:33 <vincenz> and what does that say
22:26:44 <vincenz> (a,b) = (a,b)...
22:26:50 <vincenz> seems like a recursive definition 
22:26:54 <palomer> is that even legal?
22:26:58 <vincenz> meaning fixed point is _|_
22:27:01 <ibid> that's not legal haskell
22:27:15 <ibid> (a,b) = (a,b) is legal, though
22:27:34 <vincenz> and it means what?
22:27:39 <palomer> > let (a,b) = (a,b) in a
22:27:40 <lambdabot> Add a type signature
22:27:46 <ibid> it makes a and b both be bottom
22:27:46 <vincenz> ah
22:28:02 <palomer> > let a = a in a
22:28:03 <lambdabot> Add a type signature
22:28:09 <palomer> > let a = a in a::Int
22:28:09 <vincenz> > let (a,b):: (Int,Int) = (a,b) in a
22:28:10 <lambdabot> Add a type signature
22:28:10 <lambdabot> Exception: <<loop>>
22:28:19 <vincenz> > let (a,b)::(Int,Int) = (a,b) in a
22:28:20 <lambdabot> Add a type signature
22:28:22 <vincenz> why does that not work
22:28:27 <palomer> the haskell type inference algorithm is screwy
22:28:36 <xerox> a :: forall a. a
22:28:37 <ibid> let a,b::Int ; (a,b) = (a,b) in a
22:28:46 <ibid> > let a,b::Int ; (a,b) = (a,b) in a
22:28:48 <lambdabot> Exception: <<loop>>
22:28:50 <ibid> yes
22:28:54 <vincenz> hy loop
22:28:56 <vincenz> why loop even
22:29:02 <ibid> because it is?
22:29:09 <palomer> a  = a means a reduces to a
22:29:10 <vincenz> not really
22:29:16 <vincenz> it means
22:29:20 <xerox> @type let bot = bot in bot
22:29:22 <lambdabot> forall t. t
22:29:23 <vincenz> assign to the new context a,b the a,b that come in
22:29:27 <xerox> @type undefined
22:29:28 <lambdabot> forall a. a
22:29:31 <vincenz> stop
22:29:34 <xerox> You see?
22:29:37 <vincenz> let (a,b) = (a,b) in a
22:29:40 <ibid> but data (a,b) = (a,b) is ... shall we say ... an illustration of how the pair data type would be defined if it was syntactically possible
22:29:44 <vincenz> wait
22:29:50 <vincenz> a and be are defined in the outer context
22:29:52 <palomer> ugh, I just ordered the indian version of "types and programming languages"
22:29:59 <vincenz> you assign these to new contextual a,b in the inner context
22:30:00 <vincenz> and take out a
22:30:03 <vincenz> seems perfectly legal
22:30:06 <vincenz> in ocaml that wouldn't loop
22:30:16 <ibid> vincenz: no, in let (a,b) = (a,b), the rhs a and b are the a and b defined in the lhs
22:30:27 <palomer> in ocaml it might not compile
22:30:29 <ibid> in haskell, let is what some other languages call letrec
22:30:35 <vincenz> ibid: why not have the rhs be what comes in from the outer context
22:30:43 <vincenz> oh
22:30:53 <ibid> vincenz: because it's letrec :)
22:30:58 <vincenz> right :)
22:31:10 <vincenz> out of curiousity
22:31:20 <vincenz> how does haskell define the list comprehension syntax
22:31:23 <vincenz> is that part of the compiler
22:31:29 <vincenz> or in the haskell prelude?
22:31:35 <ibid> it's part of the language syntax
22:31:41 <vincenz> if it's in the haskell prelude then the haskell core syntax must be freaky
22:31:41 <ibid> it's not library stuff
22:31:56 <ibid> it's syntactic sugar
22:31:57 <palomer> man, from now on I buy my stuff at amazon.ca
22:32:02 <ibid> desugared by the compiler
22:32:13 <vincenz> ibid: how about [1,3...]
22:32:16 <vincenz> that sugar too?
22:32:20 <vincenz> (compiler or library?)
22:32:21 <ibid> yes
22:32:35 <ibid> syntactic sugar (ie. desugared by compiler)
22:32:37 <vincenz> so you can't just define your own syntactic constructs in a lib
22:32:46 <ibid> not in any language
22:32:50 <vincenz> good
22:32:53 <vincenz> cause it was scaring me
22:33:10 <ibid> no language allows that :)
22:33:15 <vincenz> ibid: well you might get schemers to argue with you, but then again scheme syntax is just ()
22:33:24 <ibid> but in some languages, there are ways to make it seem like you could :)
22:33:35 <vincenz> actually not true
22:33:39 <vincenz> camlp4 allows you
22:33:42 <sieni> hmm... I have heard about this new fancy thing called lisp
22:33:50 <vincenz> sieni: that's not new yntax
22:33:59 <vincenz> sieni: the lisp or scheme syntax is purely defined by ( ) and '
22:34:04 <xerox> ibid: perl6? :)
22:34:14 <ibid> sure, there are exceptions
22:34:20 <ibid> they just tend to be not useful :)
22:34:26 <xerox> <grin>
22:34:28 <jimapple> dylan
22:34:28 <vincenz> ibid: another arguable point
22:34:57 <ibid> vincenz: sure, but it has been a part of the established core of POPL knowledge for decades :)
22:35:05 <vincenz> ibid: what has?
22:35:14 <vincenz> that changeable syntax is useless?
22:35:22 <ibid> "languages that allow the user to change the syntax are too complex to be useful"
22:35:28 <vincenz> oh
22:35:36 <vincenz> should publish that to our GJB
22:35:39 <ibid> it's a reaction to languages like PL/1
22:35:47 <sieni> vincenz: what about reader macros?
22:35:52 <vincenz> ibid: depends how modifiable
22:35:58 <vincenz> sieni: hmm not familiar with them :/
22:36:05 <ibid> vincenz: sure. i don't completely agree with it either
22:36:07 <vincenz> ibid: as long as it's understandable on a metasyntax level it's fine
22:36:08 <mahogny> ibid, what about template haskell? isn't that the same style? :)
22:36:14 <vincenz> besides
22:36:17 <vincenz> what IS syntax
22:36:18 <vincenz> I mean
22:36:20 <ibid> even Haskell is a counterexample as that principle is usually understood
22:36:21 <vincenz> if you have
22:36:22 <vincenz> if x then y
22:36:23 <palomer> what is love?
22:36:24 <vincenz> and then define
22:36:31 <vincenz> unless x then y
22:36:35 <vincenz> is it syntax or semantics
22:36:38 <vincenz> you could argue
22:37:00 <vincenz> from a metasyntax point of view, it's still the same template
22:37:02 <ibid> don't ask me to defend the notion, i don't agree with it :)
22:37:05 <palomer> the syntax is the set of strings accepted by the compiler
22:37:50 <vincenz> palomer: well then you could define typing to be part of syntax too
22:37:54 <ibid> the usual definition is based on the division "syntax, static semantics, dynamic semantics"
22:38:00 <vincenz> cause if it's not properly typed you get a compiler error
22:38:04 <vincenz> and hence it's not accepted
22:38:44 <mahogny> languages that can take syntax has the evil property that they can have syntax clashes, which makes name clashes seem trivial
22:38:46 <ibid> syntax, therefore, is the context-free language defined by the formal grammar of the language, not all of which belong to the language proper
22:39:03 <vincenz> palomer: my pint is that if you have a construct "if x then y" and then define a new construct "unless x then y" the template looks the same, so depending on what you call syntax, it could be a syntax extension or not
22:39:31 * vincenz targets the previous line to ibid too
22:39:40 <ibid> (static semantics defines, among other things, "well-formed" strings in the language, usually by things like "definition before use" rules, type systems etc)
22:39:59 <xerox> Seeyou.
22:40:12 <vincenz> ibid: agree that the new definition is not perse a syntax change and the the whole concept is rather fuzzy
22:40:15 <ibid> vincenz: i think this is a stupid debate. of course you're right :)
22:40:27 <vincenz> I'm not debating ya
22:40:30 <vincenz> anyways
22:40:36 <vincenz> you should publish a paper about it to GJB
22:40:47 <vincenz> it's a new upcoming conference
22:40:50 <vincenz> well rather journal
22:41:02 <ibid> (please, write it "per se". "perse" is finnish for an unfavourable name for human's ass:)
22:41:12 <ibid> GJB?
22:41:24 <vincenz> General Journal of Bullshit
22:41:25 <ibid> vincenz: why should i write a paper on something that's at least two decades old?
22:41:30 <ibid> ah
22:41:33 <vincenz> I'm planning to start it soon :D
22:41:41 <vincenz> I bet you could get some pretty funny submissions
22:41:45 <palomer> GJB?
22:41:46 <vincenz> we agreed that the acceptance rate is 120%
22:41:47 <palomer> what's that?
22:41:53 <ibid> palomer: read above
22:41:57 <vincenz> so publish a paper and you might get an extra one for free
22:41:59 <ibid> palomer: don't make him repeat it :)
22:42:06 <palomer> repeat it!
22:42:11 <vincenz> General Journal of Bullshit
22:42:21 <vincenz> however we only accept real bullshit
22:42:23 <palomer> sounds exciting
22:42:30 <vincenz> I think it could be funny
22:42:40 <vincenz> and of course
22:42:53 <vincenz> you could always submit a past paper of a colleague you 'like'
22:43:03 <palomer> haha
22:43:15 <vincenz> anyways
22:43:20 <palomer> I could submit my supervisor's paper
22:43:21 <vincenz> submission length is between 0 and 8 pages
22:43:28 <palomer> 0 pages?
22:43:35 <ibid> only bullshit? horse manure is not allowed?
22:43:39 <vincenz> it must be good bullshit, meaning that to the laymen it must seem serious but to any expert it should be funny
22:43:43 <vincenz> palomer: we accept titles only
22:43:50 <vincenz> abstracts of course are optional
22:43:57 <vincenz> and there's an acceptance rate of 120%
22:44:10 <vincenz> meaning submit one and get a possibility of a second free
22:44:17 <ibid> vincenz: if you allow abstracts, do you accept concrete, too?
22:44:23 <vincenz> LOL
22:44:24 <vincenz> good one
22:44:49 <vincenz> but I do think that if I started a website
22:44:54 <vincenz> people would submit some pretty funny things
22:45:03 <vincenz> after all, the defining quality of bullshit is that it's funny after though
22:45:04 <vincenz> t
22:46:00 <vincenz> Anyways I should prolly get to owrk
22:46:06 <vincenz> been idling and coffee drinking for long enough
22:46:45 <vincenz> ibid, palomer: you a grad student?
22:46:57 <palomer> yup
22:47:04 <vincenz> palomer: where at
22:47:28 <palomer> mcgill
22:47:34 <palomer> we need a place to find bullshit papers
22:47:49 <palomer> I'd very much like to present a bullshit paper to some professors
22:47:51 <vincenz> palomer: what's your topic?
22:48:13 <ibid> vincenz: sure
22:48:19 <vincenz> ibid: sure?
22:48:27 <ibid> sure i am a grad student
22:48:36 <vincenz> you can't answer with "sure"
22:48:41 <vincenz> yes, but not sure
22:48:42 <ibid> i just did
22:48:46 <vincenz> that's wrong
22:48:49 <palomer> I'm doing type checking/inference of HM + GADTs
22:48:50 <vincenz> sure means "well if you want me to"
22:49:09 <vincenz> palomer: oh, so you aim at popl and pldi
22:49:15 <palomer> yeah
22:49:18 * vincenz shudders
22:49:53 <vincenz> good luck
22:49:55 <vincenz> :)
22:49:55 <ibid> (hmm. my first instinct was to mirror the abbreviation of graduate to grad in abbreviating student. thought better of it, though)
22:50:09 <vincenz> ibid: lol
22:50:28 <vincenz> ibid: well you could be but it would pose me no extra information
22:50:48 <ibid> hm?
22:50:53 <vincenz> palomer: any recent publications?
22:51:00 <palomer> have I ever published?
22:51:01 <palomer> no
22:51:07 <vincenz> oh
22:51:09 <vincenz> first year?
22:51:10 <palomer> but I could have published that work I did on cracking DES
22:51:14 <palomer> second year
22:51:18 <palomer> but quite lazy
22:51:19 <vincenz> begin or end?
22:51:25 * vincenz is nearing his third year
22:51:29 <palomer> I'll be gone in 6 months, masters or not
22:51:29 <vincenz> help
22:51:37 <vincenz> palomer: how so
22:51:49 <vincenz> palomer: I thought you were doing a phd
22:51:59 <vincenz> ibid: what's your topic?
22:52:24 <palomer> no, masters
22:52:37 <palomer> I'd kill myself before I'd do a PhD on type systems
22:52:43 <ibid> vincenz: that's a good question
22:52:52 <vincenz> ibid: what year are you in?
22:52:59 <vincenz> ibid: I take it you're doing a phd
22:53:09 <palomer> man, I just want to work in a small japanese village
22:53:13 <vincenz> palomer: true, the acceptance rate of popl is good enough to kill people
22:53:16 <ibid> vincenz: i'm not in a grad school where "year" makes much sense
22:53:17 <vincenz> palomer: you're japanese?
22:53:23 <vincenz> ibid: well m neither
22:53:26 <palomer> no
22:53:29 <ibid> vincenz: but i've been at it since 2003
22:53:31 <vincenz> ibid: but you must have been at it for several years
22:53:32 <vincenz> ah
22:53:34 <vincenz> ibid: hmm
22:53:38 <vincenz> ibid: so what's your topic?
22:53:46 <ibid> 08:49  <ibid> vincenz: that's a good question
22:53:47 <ibid> :)
22:53:51 <vincenz> I hope by now you know it (although it took me nearly 2 yaers)
22:53:58 <vincenz> ibid: so what have you been working on
22:54:35 <ibid> i switched away from my original topic a year or two ago
22:54:50 <vincenz> ibid: unpublishable?
22:55:18 <ibid> got tired of it. to do anything good in it i'd have had to learn french
22:55:26 <vincenz> what was it?
22:55:28 <palomer> what topic?
22:55:30 <ibid> because most of the prior pubs are in french
22:55:39 * vincenz wrinkles his nose
22:55:42 <ibid> i was studying the B formal method
22:55:50 <palomer> you know that most good frogs publish their work in english
22:55:54 <palomer> oh, B
22:55:55 <vincenz> so what are you currently working on?
22:55:59 <vincenz> palomer: frogs?
22:56:09 <palomer> frogs = french
22:56:11 <vincenz> B...Wait I heard about that, it's rather like Z, no?
22:56:19 <ibid> further developed, yes
22:56:20 <vincenz> palomer: LOL, and you're cana-duh-ian
22:56:27 <ibid> Z is a notation, B is a method
22:56:29 <palomer> I'm part frog
22:56:30 <vincenz> palomer: I thought you'd be kin to french
22:56:42 <vincenz> ibid: ah I see
22:56:48 <ibid> my current broad topic area is principles/theory of programming languages
22:56:50 <palomer> isn't B a bastardization of hoar's system?
22:56:52 <vincenz> I thought Z and brothers were ancient
22:57:06 <ibid> Z is 70-ish, B is about 15 years old
22:57:11 <palomer> Jesus called, he wants his method back
22:57:16 <vincenz> then ther's also a java one
22:57:20 <vincenz> my colleague told me
22:57:23 <vincenz> Vsomethingsomething
22:57:35 <palomer> B doesn't seem very exciting
22:57:48 <ibid> palomer: B is based on the refinement calculus, which is in turn based on hoare logic
22:57:51 <vincenz> they should shoot people who invent ungoogable names
22:58:11 <palomer> ooh, the refinement calculus
22:58:19 <vincenz> ibid: reminds me of this paper I was reading
22:58:20 <palomer> where specifications are harder to understand than programs!
22:58:20 <vincenz> hmm
22:58:22 <vincenz> let me fish it up
22:58:56 <ibid> right now, i'm giving a course in functional programming
22:59:00 <vincenz> Functional Declarative Language Design and Predicate Calculus: A Practical Approach - Boute , TOPL2005
22:59:10 <vincenz> or wait
22:59:14 <vincenz> no not topl
22:59:16 <ibid> i intend to write up a licentiate thesis after it's done
22:59:23 <vincenz> Trannsacitons of Prog  Lang and Sys
22:59:27 <ibid> toplas
22:59:31 <vincenz> ah thanx :)
22:59:45 <vincenz> what's a licentiate thesis
22:59:46 <palomer> the greatest system of them all is AF_2
22:59:52 <palomer> nothing is decidable and everything is simple
23:00:03 <ibid> licentiate thesis is intermediate between master and phd
23:00:14 <palomer> and I wouldn't be surprised if all type systems can be encoded into it with some meaning preserving encoding
23:00:29 <vincenz> what is AF_2?
23:00:34 <palomer> ibid: which country are you in
23:00:43 <ibid> finland
23:00:50 <palomer> vincenz: it's like System F, except your predicates aren't all nullary
23:01:04 * vincenz nods as if he knows what that means
23:01:12 <ibid> i'm calling my current research program "applied theory of programming languages"
23:01:19 <palomer> it's really a dependently typed system in disguise
23:01:21 <vincenz> ibid: they still sponsor you?
23:01:29 <ibid> vincenz: hm?
23:01:32 <vincenz> palomer: my knowledge of type systems is nearly nihil
23:01:51 * vincenz 's background is EE, all his knowlege of programming is selftaught and pragmatic
23:01:56 <palomer> hrmph
23:02:02 <palomer> teaching english in japan pays too low
23:02:07 <vincenz> hehe
23:02:13 <vincenz> and costs in japan are too high
23:02:15 <vincenz> shit
23:02:19 <vincenz> gotta run and catch the bus
23:02:20 <vincenz> cya later
23:02:21 * ibid is one of the finnish grad students who's in the "assistant tar pit"
23:02:29 <palomer> but I _really_ want to live in a japanese village
23:02:32 * vincenz detaches screen
23:02:37 <ibid> too muuch teaching to be able to concentrate fully on the research
23:02:46 <palomer> ibid: I hear that teaching pays quite well over there
23:02:49 <ibid> palomer: why you asked?
23:02:59 <palomer> asked about what?
23:03:00 <ibid> palomer: depends on what you compare to :)
23:03:04 <ibid> palomer: finland :)
23:03:16 <palomer> I asked about finland?
23:03:20 <palomer> oh, I asked where you live
23:03:26 <palomer> because we don't have licentiates here
23:03:45 <palomer> but I hear that they're getting rid of them to better conform with europe
23:03:58 <ibid> that's possible
23:04:15 <ibid> but i'm already in so it doesn't matter to me
23:04:36 <ibid> actually, it's my supervisor who insists on me doing licentiate first
23:04:42 <palomer> I did half a license in paris
23:07:27 <ibid> the nice thing is, the licentiate thesis can usually be expanded to become a phd thesis, so it's not really a detour
23:07:34 <palomer> nice
23:07:37 <palomer> getting late!
23:07:38 <palomer> night
23:07:47 <ibid> i should go to work
23:19:55 <jonkri> yay, talk about people :-)
23:20:28 <jonkri> i have my first haskell lession today, and i'm quite looking forward to it
23:23:00 <gzl> was that supposed to be lesson or lesion? if you're getting lesions I think you're doing it wrong.
23:24:53 <jonkri> hahahahaha
23:25:00 * jonkri just used a dictionary
23:25:30 <jonkri> sorry, i'm not a native speaker (as you might have guessed)
23:25:38 <gzl> :)
23:26:14 <Korollary> Good luck, enjoy and don't forget haskell once the finals are over.
23:27:16 <jonkri> Korollary: i wont, if it's good :-)
23:27:32 <jonkri> but i'm honestly quite sceptic, alltough i don't know anything yet
23:27:48 <jonkri> i'm very found of the idea of object orientation
23:28:14 <jonkri> just the idea of not building everything up with objects (like in c#) feels wrong
23:29:34 <Korollary> jonkri: Haskell is not object oriented. You are in for a surprise. I hope you like it.
23:30:54 <jonkri> Korollary: yeah, me too
23:34:11 <gzl> have you built up anything any other way?
23:35:17 <jonkri> gzl: does QBASIC count? :-)
23:35:31 <jonkri> geez. i sound like a microsoft nerd
23:35:57 * jonkri feels a need to defend himself
23:36:04 <jonkri> i'm using gnu, and i'm not coding in c# nor java, but in c++!
23:38:35 <gzl> I don't like what I've seen of C++.
23:39:15 <gzl> C# seems interesting. especially the new version coming out.
23:39:39 <jonkri> gzl: well, a lot of things in it are far from perfect, and i think c# solves many of the problems, but i still like the idea of making classes
23:39:41 <gzl> anyway, Haskell is diffferent.
23:39:42 <vincenz> re
23:39:46 <gzl> with three f's.
23:39:58 <vincenz> no with an "r" and an "e"
23:41:44 <vincenz> ...
23:42:06 <vincenz> btw
23:42:11 <vincenz> how come the regex-dna is so slow for haskell
23:42:48 <astrolabe> classes fulfill lots of roles in an OO language.  Haskell seems to separate them.
23:42:59 <vincenz> yeah
23:43:15 <vincenz> classes do not server polymorphism in the traditional sense in haskell
23:43:38 <sieni> http://it.slashdot.org/comments.pl?sid=174164&cid=14488622
23:44:09 * vincenz *laughs*
23:44:11 <Korollary> sieni: nice one
23:52:33 <Lemmih> Greetings ADEpt.
23:52:52 <ADEpt> Lemmih: hi!
23:55:38 <vincenz> I hate windows
23:55:49 <vincenz> open up explorer
23:55:53 <vincenz> type CTRL+F
23:55:56 <vincenz> get the little dog
23:55:59 <vincenz> click on "all files"
23:56:01 <vincenz> and crash
23:56:09 <sieni> vincenz: well, it's a good punishment for people, who think they want to use it
23:56:20 <vincenz> sieni: got no choice
23:56:35 <vincenz> can't live without outlook
23:59:36 <vincenz> anyone seen the article by bjarne about c++0x?
23:59:46 <tibbe> no
23:59:59 <vincenz> let me fire up synergy to copy over the link to 
