00:13:40 <space-age> why does microsoft not use haskell
00:13:44 <space-age> ?
00:14:46 <dons> microsoft actually pays the wages of the main ghc developers..
00:15:42 <dons> @google simon peyton jones
00:15:44 <lambdabot> http://research.microsoft.com/Users/simonpj/
00:15:49 <dons> @google simon marlow
00:15:50 <Cale> MS does use Haskell, afaik just not for anything which they sell (yet)
00:15:50 <lambdabot> http://research.microsoft.com/~simonmar/
00:16:16 <dons> there's some haskellish stuff in one of their spreadsheets -- spj added first class functions
00:16:21 <dons> and some other lambda stuff
00:16:37 <shapr> Visual Basic is subversively picking up pieces of Haskell.
00:17:01 <shapr> But they're calling the pieces 'warm fuzzy things' effectively getting around the common misperception of Haskell.
00:17:21 <dons> hehe
00:17:26 <dons> really?
00:17:50 <dons> that would be a coup, if they adopted the haskell warm fuzzy things
00:18:18 <dons> i had fun reading this weeks openbsd news, about the kernel developers being interested in STM.
00:18:29 <dons> all good good.
00:18:47 <Cale> :)
00:18:50 <Cale> That's cool
00:19:01 <ibid> i don't know what they'll be calling the dominant paradigm of programming in fifteen years (my bet: object-oriented programming), but it's going to look an awul lot like functional programming
00:19:31 <ibid> well, haskell people did *not* invent STM, you know :)
00:19:34 <ibid> they just improved on it
00:19:43 <dons> yeah, I know.
00:20:01 <m3ga> dons: do you have a link to the openbsd STM stuff?
00:20:02 <Cale> Are they interested in Haskell's interpretation of STM?
00:20:08 <dons> but the context as the composable haskell model
00:20:14 <dons> s/as/was/
00:20:29 <dons> m3ga, it's just blog talk :) 
00:20:49 <dons> http://www.undeadly.org/cgi?action=article&sid=20051228051733&mode=flat
00:21:08 <dons> thomas nordin, mentioned in the article, worked on ghc and is at portland, iirc.
00:25:11 <boegel> @seen Itkovian
00:25:12 <lambdabot> I saw Itkovian leaving #haskell-overflow, #haskell-blah and #haskell 1
00:25:12 <lambdabot> day, 11 hours, 5 minutes and 37 seconds ago.
00:27:24 <m3ga> thanks dons
00:28:01 <dons> bit hot yesterday, eh m3ga?
00:30:23 <dons> @seen CosmicRay
00:30:24 <lambdabot> I saw CosmicRay leaving #haskell 1 day, 2 hours, 27 minutes and 25
00:30:24 <lambdabot> seconds ago.
00:31:11 <boegel> dons: are you doing HWN now ?
00:31:19 <dons> yes.
00:31:29 <boegel> any issues out yet ? :)
00:31:41 <dons> there should be an issue this week. i'm back at work tomorrow
00:31:56 <dons> a bumber post-holiday round up
00:31:59 <dons> bumper
00:32:31 <dons> i just have to work out how CosmicRay's publishing scripts work.
00:34:16 <dons> suggestions for hwn entries are welcome.
00:35:22 <boegel> hmm, you should include a merry christmas/happy newyear part, although it has passed already, and be sure to include a piece on the change of maintainer of HWN
00:49:53 <dons> yep.
01:02:37 <boegel> astrolabe: ping
01:03:03 <boegel> hmm, 66hours idle, something is telling me he isn't there :P
01:17:41 * Cale writes a CGI program in Haskell.
01:17:48 <Cale> This is surprisingly easy.
01:18:08 <Cale> (well, not that surprising, given Haskell's track record with making things easy)
01:29:51 <gour> Cale: how do you do (cgi) ?
01:31:08 <Cale> Network.CGI
01:31:18 <gour> Cale: i was challenged (once) how to implement a sort of (well-known) cgiemail script in haskell, but it is still above my head :-(
01:31:34 <Cale> It passes you an environment and you just return some html
01:32:17 <gour> i.e. after user fills out & submit the form, the (Haskell) script should use those input values and email them to a certain email address...
03:13:54 <Saulzar> Hmm, the `impossible` happened... then clean rebuild, and the `impossible` no longer happened
04:14:45 <Lemmih> Hi Oejet.
04:19:40 <r3tex> when i load hugs i get Hugs.Base> instead of Prelude> is this a problem?
04:24:50 <Cale> r3tex: nope
04:24:57 <Cale> (not a problem)
04:24:59 <r3tex> ok =)
04:26:18 <Oejet> Lemmih: Hejsa!
05:00:12 <r3tex> anyone here use QuickCheck?
05:01:00 <Cale> r3tex: not for anything big, I've played around with it a bit
05:05:27 <r3tex> Cale:  hmm, i'm supposed to use it for my course ;) there's supposed to be a QuickCheck and check but I only find one binary called check
05:07:29 <r3tex> oh, it seems to come with hugs!
05:07:31 <r3tex> =0
05:13:17 <Cale> yeah
05:19:11 <chucky> the "quickCheck" script is available via the QuickCheck homepage:
05:19:11 <chucky> http://www.cs.chalmers.se/~rjmh/QuickCheck/quickcheck
05:22:04 <xerox> chucky, what a groovy nick.
05:22:11 <xerox> Howdy, folks :-)
05:22:23 <chucky> xerox: Thanks (I think?) :)
05:22:25 <chucky> and hi
05:23:48 <shapr> @yow !
05:23:48 <lambdabot> I joined scientology at a garage sale!!
05:25:33 <Saulzar> Dum de dum
05:25:34 <chucky> I'm not sure which is more disturbing: lambdabot implying that it has joined scientology or lambdabot implying that it visits garage sales
05:25:48 <chucky> someone shouldn't have written that "go to garage sale"-plugin
05:25:52 <chucky> :)
05:26:12 <xerox> What is it? :)
05:26:29 <Saulzar> lambdabot, a master of pointless style - no wonder it visits garage sales
05:28:51 <chucky> btw, does anyone know if there is a (simple, standard) way to pass options to Alex and Happy when they are invoked by Cabal?
05:29:45 <Lemmih> There isn't.
05:30:27 <chucky> :/
05:32:29 <eivuokko> 			void Incoming(messaging::Queue& in) {}
05:32:29 <eivuokko> 			void Io(OVERLAPPED*, DWORD*) {}
05:32:29 <eivuokko> 			~Connected() {}
05:32:38 <eivuokko> Uhm, sorry.
05:32:56 <chucky> oh no, it's C++! :)
05:33:25 <eivuokko> Yup.
05:34:17 <xerox> Do you know if Oz is static or not, and why?
05:39:05 <Saulzar> Hehe, this is neat - 100 bots following a path - O(n^2) collision detection hurts!
05:39:49 <xerox> Saulzar: haha, where is it?
05:41:29 <Saulzar> Also has a giant space leak - nearly couldn't kill it ;)
05:43:48 <Saulzar> I'll upload it, not friendly to compile as I have no makefile and it needs yampa
05:44:25 * xerox arfs
05:45:04 <Saulzar> ghc --make makes for lazy me 
05:45:10 <Lemmih> shapr: Wanna try out Conjure?
05:45:46 <Saulzar> saulzar.orcon.net.nz/robots.tar.gz
05:46:39 * xerox mumbles as the kdevelop files
05:48:04 <xerox> Saulzar: any tips about how to spin it on?
05:48:48 <Saulzar> I've been using this to compile it ghc -fasm -O2  -package gtkglext --make -farrows -fglasgow-exts -i/home/oliver/afrp-0.4/src/ -lpangox-1.0
05:49:24 <xerox> What about afrp?
05:49:27 <Saulzar> So afrp needs to point to where you have the Yampa files.. 
05:49:43 <xerox> Could I ask you for an url pointing to them too?
05:49:46 <shapr> Lemmih: It works??
05:50:18 <shapr> Quite a few people are talking to me about AFRP and arrows recently.
05:50:20 <shapr> yay!
05:50:29 <Lemmih> shapr: Yep. It can download single file torrents now.
05:50:40 <shapr> Lemmih: awesome!
05:50:42 <Saulzar> Wow, nice
05:50:45 * shapr dances cheerfully
05:50:58 <Saulzar> http://www.haskell.org/yampa/afrp-0.4-src.tgz
05:51:17 <shapr> Though that tgz needs moving from *.as to *.hs last I checked.
05:51:27 <cm> yo
05:51:31 <Saulzar> Ahh, could be
05:51:37 <Saulzar> I'll upload a fixed ver
05:51:51 <Saulzar> Also some parts are included in Control.Arrow
05:52:17 <shapr> Lemmih: I've wondered about renaming conjure to HaskellMule.
05:52:28 <xerox> Grazie Saulzar :-)
05:53:23 <cm> fast like a haskelle :/
05:54:30 <boegel> shapr: HaMule
05:54:46 <Saulzar> saulzar.orcon.net.nz/afrp-ghc.tar.gz
05:55:17 <xerox> Thank you!  From the wikimedia foundation.
05:55:44 <xerox> They deserve it, don't they?
05:58:02 <xerox> Well, let's -blah it if you want.
06:06:33 <xerox> Saulzar: where does one get gtkglext from?
06:08:12 <Saulzar> xerox, Ahh - I forgot about that, it's in the devel version of gtk2hs from darcs
06:08:24 <xerox> Ah-ha!
06:12:18 <r3tex> if quickCheck comes with hugs and ghs how do i invoke it?
06:12:25 <shapr> Test.QuickCheck
06:12:32 <shapr> import that then run quickCheck
06:13:12 <r3tex> hmm *testing*
06:14:16 <xerox> @index quickCheck
06:14:17 <lambdabot> Test.QuickCheck, Debug.QuickCheck
06:14:34 <r3tex> =P i'm not sure i'm with you guys
06:14:47 <r3tex> if i load it, my project gets unloaded
06:15:13 <xerox> The lambdabot's @index command returns the list of modules in which the given functions is defined in.
06:15:46 <shapr> r3tex: http://www.scannedinavian.org/~shae/ProtoQuickCheck.hs
06:16:02 <xerox> s/functions/function/  I'm sorry
06:16:29 <shapr> Load that file into hugs, then run quickCheck prop_RevRev
06:17:29 <xerox> shapr: why does your webserver make the user download the hs files, instead of showing them as foo/plain ?
06:17:46 <r3tex> shapr:  but once i've loaded it my old .hs file gets unloaded right?
06:17:56 <ezraburgh> @pl \f (x,y) -> (x, f y)
06:17:58 <lambdabot> (`ap` snd) . (. fst) . flip ((.) . (,))
06:18:03 <xerox> It depends on how you load it, r3tex 
06:18:24 <xerox> ezraburgh: I would suggest to 'import Control.Arrow' and use 'second f'
06:18:47 <shapr> xerox: I haven't gotten around to fixing the mime types.
06:19:06 <shapr> r3tex: Right, so I usually import the module into my test module.
06:19:13 <shapr> For Foo.hs I have Test_Foo.hs
06:19:25 <ezraburgh> xerox: thanks!
06:19:29 <r3tex> shapr:  ahaaa at the beginning of the file
06:19:42 <r3tex> shapr:  ok, i just started today, i need to learn haskell in a week ;)
06:19:43 <r3tex> hehe
06:19:51 <xerox> ezraburgh: that is, 'second f (x,y) = (x, f y)'.  You're welcome!  Want me to show some other combinators from that library?  They can be handy.
06:20:31 <ezraburgh> xerox: would love it!
06:20:37 <ezraburgh> I always find myself reaching for such things
06:21:08 <xerox> ezraburgh: here we go.  Those are called the '(->) a' instance of the 'Arrow' class:
06:21:21 <Cale> just (->)
06:21:23 <xerox> (f &&& g) x = (f x, g x)
06:21:33 <xerox> Ah, woops.
06:21:46 <xerox> This in fact lets you apply two functions to a same value, returning a pair of results.
06:21:57 <xerox> > let dup = (id &&& id) in dup 2
06:22:00 <lambdabot> (2,2)
06:22:00 <ezraburgh> ah, ok. that's useful.
06:22:19 <xerox> This one is nice: (f *** g) (x,y) = (f x, g y)
06:22:30 <xerox> It applies the functions to the arguments position-wise.
06:22:48 <ezraburgh> yeah, that's handy.
06:22:49 <xerox> > (+1) *** (*2) $ (1,0)
06:22:49 <ezraburgh> anything for triples?
06:22:51 <lambdabot> (2,0)
06:23:02 <int-e> first = (*** id); second = (id ***)
06:23:08 <xerox> Then there are 'first' and 'second' that you saw.
06:23:19 <ezraburgh> yep
06:23:36 <xerox> I don't know if there are other ones.  I think there are no other ones regarding triples or n-tuples with n >= 3.
06:23:58 <Cale> n-tuples with n >= 3 are hardly used in Haskell.
06:24:23 <xerox> Agreed.
06:24:36 <Cale> (normally you'll create a named data type at that point)
06:24:37 <xerox> Though it would be nice to have fmap instances, at times.
06:24:46 <shapr> roconnor: Personally, I'm in favor of web of pet names :-)
06:24:52 <Saulzar> Hmm, the reason for only using 2 is that it is sufficient for saving intermediate results
06:25:03 <roconnor> shapr, yep
06:25:06 <Cale> yeah, I wish there was an instance of Functor for ((,) a)
06:25:08 <xerox> Saulzar: or computing two things in a row, like in a fold.
06:25:22 <roconnor> Although I'm a bit suprised to hear a European say that.
06:25:30 <xerox> Cale: could you write it down here?
06:25:54 <Cale> fmap f (x,y) = (x, f y)
06:26:03 <int-e> fmap = second ;)
06:26:07 <Cale> sure
06:26:26 <ezraburgh> what is the Functor class good for?
06:26:41 <Saulzar> Why would fmap for tuples act only on the 2nd item?
06:26:41 <roconnor> Is there a utility to draw arrow diagrams, and then export it as arrow code?
06:26:50 <Cale> ezraburgh: it generalises the idea of applying a function to all the elements of a container
06:27:04 <Cale> Saulzar: because it can't do any more than that
06:27:05 <ezraburgh> what's a situation where it would be useful?
06:27:05 <xerox> Why second ?!
06:27:23 <xerox> That is, on what base you pick one up, instead of both, and why the second?
06:27:36 <Saulzar> Cale, Ah, because the elements are possibly of different type?
06:27:49 <Cale> Saulzar: yeah
06:28:29 <Cale> (,) is a Bifunctor really
06:29:18 <glasser> Yeah, how would Haskell know whether to treat the functor relation on a tuple as applying f to the first or the second?
06:29:32 <glasser> I guess you can't describe the other version as a type as easily
06:29:32 <glasser> .
06:30:41 <Cale> right
06:31:11 <Saulzar> ezraburgh, There are lots of containerish types and it allows you to manipulate the contents without too much fuss
06:31:39 <Cale> fmap works (or should work) with any monad type for instance
06:32:06 <ezraburgh> makes sense, i just haven't seen it in practice
06:33:08 <Cale> If you see liftM, that's the same thing as fmap. It just has a more restrictive type (only works for monads).
06:33:36 <Cale> Don't ask me why they decided we need two fmaps :)
06:33:38 <ezraburgh> right... is Monad a Functor?
06:33:48 <Cale> Every monad is a functor
06:33:56 <int-e> not to mention the specialised map for Lists :)
06:34:10 <Cale> but not every Monad instance in Haskell is forced to have a Functor instance
06:34:30 <Cale> (don't ask me why)
06:34:47 <ezraburgh> so when declaring a Monad instance, you should (might) also declare it as a Functor instance...?
06:34:58 <int-e> you can still make an instance Monad m => Functor m where fmap = liftM
06:35:25 <Cale> yeah, you should
06:35:26 <xerox> Cale: what does a BiFunctor implement?
06:35:27 <int-e> of course that's turning it upside down.
06:35:42 <Cale> bimap :: (a -> b) -> (c -> d) -> f a c -> f b d
06:35:59 <Cale> bimap :: (Bifunctor f) => (a -> b) -> (c -> d) -> f a c -> f b d
06:36:19 <xerox> Makes sense.
06:37:40 <int-e> are there contravariant functors in Haskell? Would they be useful? (having comap :: (a -> b) -> f b -> f a)
06:37:53 <Cale> You can define a class for them
06:38:14 <Cale> I haven't thought of too many uses, though I'm sure there are some lurking around
06:38:59 <glasser> How could you actually apply them, though?
06:39:09 <ezraburgh> is that type even inhabitable?
06:39:54 <glasser> @djinn (a -> b) -> f b -> f a
06:39:56 <lambdabot> -- f cannot be realized.
06:40:02 <glasser> @hoogle (a -> b) -> f b -> f a
06:40:04 <lambdabot> Data.Generics.Schemes.everywhere :: (a -> a) -> a -> a
06:40:04 <lambdabot> Data.Generics.Schemes.everywhere' :: (a -> a) -> a -> a
06:40:04 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
06:40:26 <int-e> yes. F x = x -> T is such a functor, for every type T.
06:40:54 <ezraburgh> with what fmap? fmap f = identity?
06:40:57 <int-e> with comap = flip (.)
06:41:33 <int-e> @djinn (a -> b) -> (b -> c) -> (a -> c)
06:41:33 <xerox> int-e: what is it in Haskell-syntax?
06:41:33 <lambdabot> f a b c = b (a c)
06:42:19 <glasser> Ah true that
06:42:48 <ezraburgh> ok
06:43:18 <int-e> xerox: newtype F a x = x -> a; instance CoFunctor F a where comap = (.) ... given class CoFunctor f where comap :: (a -> b) -> f b -> a
06:43:47 <xerox> Thanks int-e.
06:44:12 <int-e> err, the last a should be f a
06:46:08 <psnl> can anyone spot what is wrong with this: chomp (a : []) = if (a == (chr 13)) then [] else a ;where chmop's argument is a string?
06:46:36 <Cale> psnl: you've only defined it on lists of length 1
06:47:08 <int-e> and it's not correctly typed - a is not a list
06:47:11 <psnl> there is a base case underneath of the form chmop a:as = a + chmop as
06:47:30 <psnl> s/+/++/
06:47:34 <lennart> the else branch is not a list
06:47:48 <psnl> ok, cool
06:47:50 <int-e> you should return a:[] or [a] (the first is the desugarized version of the second)
06:48:09 <Cale> chomp (a:b:as) = a : chomp (b:as)
06:48:23 <Cale> that should be your general recursive case
06:48:29 <int-e> psnl: why don't you make the empty list your base case?
06:48:34 <xerox> Cool one.
06:48:54 <int-e> ah, because it's only supposed to affect the last character
06:49:27 <lennart> but what if there is no last character?
06:49:37 <psnl> thanks
06:49:55 <psnl> lennart: thats a thought, I will include a case for the empty string
06:50:00 <xerox> ...then spit some horrible error to the user.
06:50:18 <int-e> @type drop
06:50:20 <lambdabot> forall a. Int -> [a] -> [a]
06:50:40 <xerox> Hmm.
06:53:03 <int-e> Cale: you don't like overlapping cases, do you?
06:53:15 <Cale> int-e: safer to avoid them :)
07:01:15 <shapr> roconnor: Did you see my blog post about p2p dns that effectively uses pet names?
07:01:34 * shapr hops joyfully
07:01:40 <CosmicRay> happy new year, shapr!
07:01:49 <shapr> gott nytt år CosmicRay!
07:01:49 <CosmicRay> dons: ping
07:01:53 <CosmicRay> @seen dons
07:01:53 <lambdabot> dons is in #haskell. Last spoke 6 hours, 12 minutes and 9 seconds ago.
07:11:53 <shapr> hej lennart 
07:11:58 <lennart> hej
07:12:13 <shapr> Do you know of any Haskellers in Stockholm other than Faxén?
07:12:44 <shapr> I'm moving there in the summer, and want to know who I can contact for a type theory support group.
07:12:45 <lennart> hmmmmm, can't say I do
07:13:03 <shapr> Also, any idea where Urban Boquist went to, or how to contact him?
07:13:09 <lennart> Bjorn Lisper has done some Haskellish stuff
07:13:27 <shapr> I still want to know why SSA-style machine code is superior (as it says in his thesis).
07:13:31 <lennart> Urban work for Ericsson doing Erlang.  urban@boquist.net
07:13:31 <shapr> Ah, good point
07:14:01 <shapr> Gee, maybe I should learn Erlang and see if I can get contract work in Stockholm.
07:14:20 <shapr> Thanks, I'll email him.
07:14:27 <lennart> Not a bad idea.
07:14:43 <shapr> I'd much rather find Haskell or other nifty type theory oriented work.
07:14:48 <lennart> Erlang is a pretty cool language in many ways.
07:15:06 <shapr> Yeah, it is. I still wish I could get the same features in Haskell though.
07:15:46 <lennart> Many Haskell features rely on types in one way or another.  And Erlang is just never gonna get static type checking.
07:15:50 <shapr> I've been thinking about a language like that, an alternate future where the Haskell committee decided to build in network transparency...
07:16:22 <Heffalump> is Erlang actually network transparent?
07:16:42 <lennart> I think network transparency is bad.  The network isn't transparent.
07:16:45 <shapr> No, let me rephrase that as 'concurrently aware'.
07:16:58 <Heffalump> lennart: yeah
07:17:14 <Heffalump> in what ways is it more concurrently aware than Haskell?
07:17:50 <lennart> Well, Haskell doesn't have concurrency.  Some implementations do. :)
07:17:58 <shapr> I'd like a language where sending a task to a different CPU or host has the same interface and behaviour. I'd also want E style capabilities built in.
07:18:19 <shapr> I was thinking, what about making thunks the basic unit of concurrency?
07:18:32 <Heffalump> shapr: why isn't that a library, like Haskell concurrency?
07:18:38 <Heffalump> (sending a task to a different place)
07:19:09 <Heffalump> (s/that a library/that best expressed as a library/)
07:19:30 <Cale> Heffalump: you'd need runtime support to fire unevaluated thunks over the network and have them interpreted as anything but junk on the other side :)
07:19:30 <shapr> I think it shouldn't be a library, for reasons similar to those expressed by Joel Wager in his blog.
07:19:44 <Heffalump> cale: I wasn't talking about the thunk bit
07:19:54 <shapr> lennart: Learned anything neat recently?
07:19:56 <Heffalump> shapr: URL?
07:20:31 <shapr> wagerlabs.com
07:20:52 <Heffalump> thunks are effectively the basic unit of SMP, but it's not obvious to me that you want to allow any thunk to be moved to a different host
07:21:04 <shapr> I definitely want it :-)
07:21:50 <shapr> The only transparent approach I see is NDP.
07:24:43 <Heffalump> I don't quite understand what he's saying Haskell should have. Implicit per-thread event queues with pattern matching on receive?
07:25:01 <Heffalump> (on the concurrency side of things, that is)
07:26:23 <musasabi> Much of the problem came that he tried to write Erlang in Haskell and then things didn't work out.
07:26:28 <Heffalump> is Joel Wager the same person as Joel Reymont?
07:26:31 <shapr> yup
07:26:42 <Heffalump> I definitely agree with his criticisms of record syntax.
07:27:24 <musasabi> yep, something is needed for that, then again ~20 lines of TH bring him erlang like record definitions.
07:27:41 <Heffalump> pattern matching on incoming events shouldn't be particularly hard in Haskell, albeit more syntactically verbose
07:27:54 <shapr> I do wish Haskell had an OTP layer so I could write apps like mnesia.
07:27:55 <Heffalump> TH is poorly supported and rather hacky, IMO
07:28:15 <Heffalump> it doesn't include all the extensions in the AST, does it?
07:28:24 <musasabi> Of course people pointed him out to alternative libraries to do things, but most of the time he just implemented things from the ground up without looking at existing solutions.
07:28:44 <Heffalump> when I investigated porting my transformation system to TH, I kept running into technical limitations of TH that would make it really unpleasant.
07:28:46 <shapr> Yeah, he definitely took his own approach to many things.
07:29:08 <shapr> Heffalump: Part of that is because it's not been used much, SPJ says on the TH mailing list.
07:29:34 <Heffalump> yeah, vicious circle
07:29:53 <Heffalump> people should write little libraries to do things like musasabi just described, see if that increases takeup
07:30:11 <shapr> Cabal and Hackage will help.
07:30:31 <musasabi> Heffalump: does not help much, because there is a strong NIH syndrome sometimes.
07:30:33 <shapr> The number of isolated (and nifty) Haskell libraries is surprising.
07:31:43 <aleator> shapr: someone should be paid to collect and streamline them :/
07:31:50 <shapr> Pay me =)
07:31:59 <aleator> how much?
07:32:09 <Saulzar> NIH? Not in Haskell?
07:32:09 <shapr> Seriously though, when was the last time anyone here looked through the UniForM tools for example?
07:32:17 <rep> not invented here
07:32:37 <shapr> Or Fudgets and its InternetLib, or tried to update Jan Skibinski's Squeak integration, or...
07:33:13 <musasabi> For example the efficient binary serialization in Haskell.
07:33:36 <musasabi> It has been dozens of times by different people and everyone seems to have at least a few libraries for it.
07:33:45 <shapr> Yeah, that needs to be fixed.
07:34:27 <CosmicRay> shapr: I agree that this is a problem.  I have been trying to integrate one best-of-breed tool for each problem into missingh.
07:34:34 <musasabi> and each new people gets pointed to 5-6 of them but in the end just implements his/her own library rather than taking time to contribute to the existing ones.
07:34:46 <Saulzar> Hmm, libraries will always get implemented like that unless there is some centralisation
07:34:49 <musasabi> the same thing with e.g. FastPackedString
07:34:49 <shapr> But that was the goal of the libraries list.
07:34:59 <shapr> Saulzar: Or at least some way to find modules
07:35:03 <Saulzar> Just look at C++, how many thousand little network libraries are there?
07:35:05 <CosmicRay> shapr: oh, I thought the goal of the libraries list was to flame about cabal.
07:35:07 <musasabi> There are at least 6 implementations that I am aware of.
07:35:10 <shapr> CosmicRay: ha!
07:36:03 <musasabi> I think a major part of the problem is that one is too productive in Haskell
07:36:09 <shapr> aleator: You can pay me to do it :-) Though probably the best thing I could do for the Haskell libraries collection is to fill in Hackage.
07:36:20 <musasabi> People just write their own code rather than reading through someone else's code.
07:36:54 <shapr> My darcsforge idea would solve part of the problem. It just keeps local mirrors of the remote repositories. Then browsing, searching, and general lookup would be easy.
07:36:59 <Saulzar> Hmm, or rather read through somone elses code and think 'I could do that' ...
07:37:14 <shapr> musasabi: Thus my earlier thesis that every community needs a Master Refactorer :-)
07:37:32 <roconnor> shapr, no.  have a link?
07:37:35 <shapr> Björn Bringert does that well for the code he maintains. Maybe we could bribe him?
07:38:06 <shapr> roconnor: http://www.scannedinavian.com/2005-11-24.html
07:38:21 <roconnor> what's the relationship betweek hackage and cabal?
07:38:36 <musasabi> But e.g. I think that many people have used Network.Browser (from the HTTP library) and fixed every POST being broken, but people just fork their own versions rather than sensinf patches upstream.
07:38:37 <earthy_> hackage builds on cabal
07:38:53 <musasabi> *sending
07:38:53 <shapr> Cabal is the config, build, and install system. Hackage is a chunk of server software that lets you find cabal packages.
07:39:31 <roconnor> shapr, There was an awsome talk at 22C3 about freenet
07:39:37 <shapr> darcs http send would make darcs patches incredibly easy.
07:39:52 <roconnor> The freenet people have developed a way to route through social networks.
07:40:00 <roconnor> automagically
07:40:01 <shapr> roconnor: Sorry I missed it. Lately I've been especially in favor of C3.
07:40:07 <shapr> oh wow!
07:40:33 <lennart> darcs is wonderfully cool.  Now if it only had a few more features.... ;)
07:40:34 <roconnor> They want to make a darknet freenet.
07:40:50 <roconnor> you hook-up with your friends.
07:41:00 <roconnor> then you are placed on a random point on a circle.
07:41:27 <shapr> I think it won't work to run it through the existing network. I've been thinking about a consumer owned internet using wimax and other long distance mesh network tech.
07:41:43 <roconnor> then network users randomly swap positions if it reduces the sum of the products of the lenghts to their friends, or something like that.
07:41:57 <shapr> Oh, that's nice and simple.
07:42:23 <roconnor> To route a packet to X, I find the closest person Y of my friends on the circle and send it to him/her.
07:42:37 <shapr> huh?
07:42:53 <roconnor> Suppose I want to send a packet to alice.
07:42:58 <musasabi> Doesn't that make it possible for an attacker to chart out the social network?
07:43:29 <musasabi> I think that "who are my friends" is usually more valuable information than the contents of random messages.
07:43:55 <roconnor> then I find the closest friend to alice on my friends list, bob.  Bob sends it on the same way.
07:44:48 <roconnor> If I drop the packet into the network, how will I be able to track it?
07:45:05 <roconnor> (to be fair, I don't understand all of the details of the protocol).
07:45:06 <earthy_> the sameway traceroute works
07:45:13 <earthy_> ICMP timeouts.
07:45:19 <shapr> roconnor: Oh check this out - http://www.scannedinavian.com/2005-12-05.html
07:45:22 <earthy_> and TTL fields
07:45:53 <earthy_> ofcourse, if the system does not do ICMP timeouts that won't work
07:45:55 <roconnor> yes, but the darknet protocol won't leave an unencrypted return route.
07:46:15 <shapr> I just need to find some way to operate on encrypted data without the operator knowing what that data is...
07:46:23 <earthy_> roconnor: the way ICMP timeouts work is that you get the IP address of the packet that timed out
07:46:38 <earthy_> ofcourse, you are not guaranteed that the next packet takes the same route... *hmmm*
07:46:40 <Heffalump> packets have IP addresses :-)
07:46:42 <Heffalump> ?
07:47:03 <earthy_> s/packet that/host at wich the packet/
07:47:33 <roconnor> I would suggest the user at the location of the time out not write his IP address in the packet that he sends back to his friend.
07:47:59 <roconnor> In fact, I would expect timed out packets to be dropped.
07:48:14 <flux__> shapr, but that doesn't solve all of the problem, because in a game you might not want to reveal the whole state of the world to everybody
07:48:14 <earthy_> but that can break stuff...
07:48:19 <roconnor> oh, I should point out that these packets are not on the IP level.
07:48:41 <roconnor> they are on the Darknet level.
07:48:57 * earthy_ nods
07:49:00 <roconnor> I suppose that places it somewhere on the application level.
07:49:07 <flux__> shapr, also the computation chunks should be sent to atleast different subnets, because it might be too easy to gain trust by running your special software in a few subnets with potentially thousands of ip's..
07:49:09 <shapr> flux__: The idea as I see it is that you have the game running on a virtual machine where not all of the machine is on a single host, so it can verify that the other pieces are reacting correctly.
07:49:59 <flux__> yes, I can see that that approach will give you reliable computing, but it will also very easily reveal all computation to everybody, unless you split the computing into sufficiently small chunks
07:50:17 <shapr> flux__: Sure yeah. Once the majority is cheating, the uncheatability breaks down. It really only guarantees consistency. But at least I won't have to deal with cheaters on counterstrike with this sort of system. 
07:50:24 <flux__> in games it might be undesirable to give away your location; compare to first person shooters where you can see through the walls
07:51:09 <flux__> hmm, how would that address fps-like cheats, auto-aiming and that see-through-walls?
07:51:27 <Cale> the solution to cheating is perfect knowledge :)
07:51:29 <Cale> hehe
07:51:34 <shapr> The client runs on the substrate, not on your machine.
07:52:19 <Heffalump> hmph, why does HashTable only have an IO interface
07:52:20 <Saulzar> Sounds extremely complicated :)
07:52:32 <flux__> hmm.. but the substrate runs also on your machine?
07:52:47 <shapr> Saulzar: The anonymous distributed substrate?
07:53:08 <flux__> or is this idea based on that zero-knowledge computation stuff
07:53:15 <shapr> flux__: Sure, but the problem is equivalent to one CPU in a sixteen CPU box trying to spy on the others.
07:53:17 <Saulzar> Running part of the client remotely, for games (I haven't been following the stuff earlier)
07:54:41 <flux__> well, if the jobs where distirbuted randomly among the cpus, all the cpus would atleast get fragments of the information?
07:54:49 <lennart> Heffalump: Because HashTable is broken
07:55:02 <flux__> that might still be a difficult attack, though
07:55:13 <Heffalump> lennart: broken how?
07:55:30 <Heffalump> just fundamentally broken, or in some specific ways?
07:55:36 <lennart> It only has an IO interface, hence it's broken :)
07:55:37 <flux__> but so it is to split the work behind running a fps world
07:55:45 <Heffalump> ah :-)
07:56:11 <Heffalump> it has a comment saying it should use MVar instead of IORef, presumably to make it thread safe
07:56:14 <lennart> It has nothing to do with IO, I don't see why anyone would put it in IO
07:56:14 <roconnor> earthy_, So I'm not clear on the details of how everything is kept secret, however what is amazing is that you can actually automatically route along social networks.
07:56:31 <Heffalump> it could just be in ST, couldn't it?
07:56:36 <Heffalump> oh, but then threading.
07:56:38 <lennart> I would think so
07:56:41 <earthy_> roconnor: yes, that is in fact amazing
07:56:54 <shapr> flux__: One simple improvement I've thought of is to operate only on encrypted data. Can you run a distributed VM in such a way that no single node can ever decrypt data by itself? Is there some way to execute encrypted data without decrypting it?
07:57:37 <Heffalump> shapr: no.
07:57:51 <Heffalump> because if you can execute it once, you can execute it again
07:57:55 <flux__> shapr, there are algorithms to work on data where you don't know what the original data is or what the result is, but I believe implementing a vm in terms of those would be atleast horribly inefficient
07:57:59 <Heffalump> and if you can execute something repeatedly, you can find out what it does
07:58:04 <roconnor> I should write a Haskell implementation of Freenet to gain a better understanding of how Freenet works.
07:59:07 <shapr> flux__: Data parallel arrays would make it easy to transparently split the work. But data parallelism will likely make any C++ programmer scream in pain.
07:59:29 <Heffalump> data parallelism is just what SIMD machines use
07:59:55 <roconnor> Does cabal ``replace'' make?
07:59:57 <Heffalump> so anyone who writes intrinsic code for SIMD machines would understand the concept
08:00:10 <roconnor> as in I would run Setup instead of make.
08:00:15 <Heffalump> but fundamentally, a lot of computation is not data parallel
08:00:18 <Heffalump> roconnor: I believe so
08:00:35 <shapr> and fundamentally, a lot of computation is data parallel
08:00:37 * shapr shrugs
08:01:01 <Heffalump> you'll probably find that most isn't
08:01:22 <shapr> or I may find that most is :-)
08:01:26 <Heffalump> or at least is control-driven enough that multiple execution units don't help much
08:01:59 <roconnor> Hmmm, I never written Haskell code so complex that ghc --make doesn't work.
08:01:59 <Heffalump> data processing algorithms like video/audio codecs etc are quite vectorisable
08:02:23 <Heffalump> and crypto stuff
08:02:49 <earthy_> often the trade-off is one of sequential control versus throwing away unneeded results
08:02:54 <Heffalump> but if there was a lot of benefit to be had, compilers would routinely get large speedups by targetting the MMX/SSE extensions
08:02:54 <shapr> LtU has a recent article about data parallel arrays for general purpose use of GPUs - http://lambda-the-ultimate.org/node/view/1203
08:03:01 <Heffalump> yeah, that was quite cool
08:03:02 <roconnor> So Hackage is the CPAN of Haskell?
08:03:13 <Heffalump> but the speedups weren't really that large
08:03:29 <earthy_> hef: actually, it is very hard to do good extraction for mmx/sse code from C
08:03:51 <Heffalump> earthy_: it's not _that_ hard
08:04:01 <earthy_> and the payoff just isn't there... if you know you have data parallelism, you can use libraries that make use of it
08:04:12 <Heffalump> right
08:04:13 <roconnor> map working on Word8 should translate to sse code ;)
08:04:17 <Heffalump> roconnor: yeah :-)
08:04:31 <earthy_> hef: there's a number of complexities to do with aliasing
08:04:36 <Heffalump> earthy_: agreed.
08:05:15 <earthy_> roconnor: but map working on Integer *might* be faster using sse
08:05:16 <roconnor> At my former job we wrote SSE assembly code by hand.
08:05:21 <earthy_> it's just that you can't know that
08:05:36 <earthy_> unless you do some complex reasoning
08:05:40 <roconnor> earthy_, good god, could that ever happen?
08:05:52 <Heffalump> roconnor: why not use intrinsics?
08:06:06 <roconnor> intrinsics?
08:06:11 <earthy_> yes, it could. will we see that? probably not: the payoff in speed isn't there
08:06:39 <earthy_> however, the machinery that allows you to do that *also* allows you greater language level security
08:06:54 <Heffalump> roconnor: C functions that correspond to assembler instructions
08:07:09 <Heffalump> mean you get C type safety and can use the compiler's register allocator and scheduler
08:07:17 <earthy_> C type safety... hm. :)
08:07:35 <Heffalump> well, it's better than nothing
08:07:50 <roconnor> *shrug* I don't know.  I didn't write the asm code. ... Well I did write one.
08:07:53 <Heffalump> though annoyingly, Intel's intrinsic types don't distinguish between what's in a vector
08:08:30 <roconnor> C has type safety?! ;)
08:09:01 * roconnor notices earthy_ got to it before me.
08:09:54 * Heffalump disappears
08:10:20 <ibid> roconnor: you know, there's safety and then there's safety ;)
08:13:38 <roconnor> I don't suppose darcs deals with module dependencies in any way.
08:13:57 <roconnor> I mean, dependencies on other darcs distirbutions.
08:17:29 <roconnor> Wait, when I make a cabal package, where do I put it?
08:18:04 <shapr> heya PerlJam, ltns
08:18:14 <shapr> Actually, I think that operations on encrypted data will work fine.
08:18:44 <PerlJam> greets shapr 
08:19:14 * PerlJam recently decided to really try to learn haskell
08:19:28 <PerlJam> Learn it such that I have an intuition about it as I do about perl.
08:19:45 <shapr> In fact, I think it's even possible to bootstrap an encrypted program in such a way that the program only lets out the data it wishes. That is, the it encrypts all incoming data with the public key and decrypts outgoing data with the private key, while running encrypted.
08:19:48 <shapr> Wouldn't be very efficient though.
08:19:50 <PerlJam> I'm finding out that there's a bunch of stuff that I thought I knew that I really don't know.
08:20:03 <shapr> PerlJam: Welcome to the deep pool of nifty goodies!
08:20:11 <shapr> You may want to check out such resources as 
08:20:12 <shapr> @learn
08:20:13 <lambdabot> http://www.haskell.org/learning.html
08:20:17 <shapr> @wiki HaskellNewbie
08:20:17 <lambdabot> http://www.haskell.org/hawiki/HaskellNewbie
08:20:30 <shapr> And Hal Daume's Yet Another Haskell Tutorial
08:20:38 <PerlJam> yeah, yeah, I've got all those
08:20:43 <shapr> Ok, any questions?
08:22:14 <PerlJam> um ... sure. 
08:23:34 <shapr> Like
08:23:35 <shapr> ?
08:23:37 <PerlJam> I'm having a problem right now that has shown me that I'm missing something fundamental or I'm just have a severe case of mental block.   How do you write a function that returns a random number in a given range?  I've used num <- randomRIO(0,100) but I wanted to put that in another function that does some math on that value and returns it.
08:24:04 <PerlJam> (you can see that I'm still thinking procedurally somewhat)
08:24:11 <Cale> http://www.haskell.org/hawiki/HaskellNewbie_2fWorkingWithRandomNumbers
08:24:17 <Cale> that might help :)
08:24:26 <sylvan> do {num <- randomRIO(0,100) ; let x = fac n ; print x}
08:24:49 <PerlJam> Hmm.
08:25:11 <Cale> @type Random.randomRIO
08:25:13 <lambdabot> forall a. (System.Random.Random a) => (a, a) -> IO a
08:25:35 <sylvan> basically, you can't call IO functions from regular functions, but you can call recular functions from IO functions...
08:26:13 <shapr> Cale: Do you know of any papers about working on encrypted data without decrypting it?
08:26:20 <Cale> so  randomRIO (0, 100)  is an IO action, which when you run it, gives you a number from 0 to 100
08:26:47 <Cale> shapr: hmm
08:26:50 <roconnor> shapr, you can probably do linear transformations of encrypted data.
08:27:06 <shapr> Given the public key of some encrypted data, it would seem that there's a simple way to do any operation you want on the data without revealing the data.
08:27:15 <Saulzar> Hmm, do libraries have profiling versions or something? I add -prof to my ghc line and suddenly it can't find `Graphics.UI.Gtk.OpenGL' anymore.
08:27:28 <shapr> Yup, must have prof libs as well.
08:27:38 <Cale> shapr: somehow I doubt that
08:27:57 <Cale> how do you do it? Which encryption system?
08:28:30 <shapr> Cale: Think of it from a CT perspective... there's a symmetric (?) map, you just don't have the other half of the map handy.
08:28:34 <Saulzar> Can I leave out a library for profiling somehow?
08:28:41 <PerlJam> sylvan: I guess you summed up that what I'm trying to do it cicumvent the IO monad  :)
08:29:43 <Cale> shapr: well, okay, so you have some invertible map which is very hard to find an inverse to
08:29:46 <shapr> Cale: public/private key crypto is a morphism, right?
08:30:00 <Cale> in which category?
08:30:06 <shapr> :-P
08:30:11 <Cale> It's a function, sure :)
08:30:37 <shapr> You can always get the original data back with the other key.
08:30:39 <Cale> (or a pair of functions, based on a key)
08:31:02 <Cale> right
08:31:04 <shapr> So the question is, if you have one key, how do you 'encrypt' an operation?
08:31:25 <Cale> well, if you have the private key, you might be able to
08:31:58 <shapr> ?
08:32:04 * PerlJam decides to spend more time with hawiki
08:32:28 <Cale> hmm
08:35:04 <shapr> Cale: I want a group homomorphism?
08:35:24 <Cale> Let's look at this. You have n which is the product of a pair of primes p and q, and you have a private key d and public key e such that d e = 1 (mod phi(n)), and gcd(e, phi(n)) = 1. To encrypt, the sender computes E = M^e (mod n)
08:35:26 <tromp_> between what groups?
08:35:43 <Cale> where M is the message
08:36:12 <tromp_> the sender assumes that gcd(M,n)=1
08:36:40 <tromp_> if not, then the owner of M has already broken the system:(
08:36:48 <shapr> tromp_: Intuitively I am convinced that a public key will allow operations on encrypted data without revealing that data.
08:37:09 <shapr> Question is...
08:37:10 <tromp_> what operations do you have in mind?
08:37:19 <shapr> Something like public/private key crypto.
08:37:47 <Cale> well, if you wanted to multiply the message by a given value, you could do that
08:37:48 <tromp_> you can multiply an encrpyted M by any constant
08:37:52 <int-e> Cale: it's well known that the operation commutes with exponentiation - which is usually considered to be a weakness of RSA.
08:37:54 <tromp_> but little more than that...
08:37:57 <shapr> Since the public key is a trasform from unencrypted to encrypted for data, why can't it do that for functions as well?
08:38:09 <Cale> since M^e N^e = (MN)^e
08:38:47 <shapr> tromp_: Is there a pub/priv cryptosystem that allows for turing complete transparent ops?
08:39:31 <Cale> shapr: addition alone seems hard
08:39:33 <tromp_> there is something called secure multiparty computations
08:39:35 <shapr> I just want to find some way to run a program while keeping it encrypted.
08:40:49 <tromp_> u'd have to rey to formalize that first
08:40:51 <tromp_> try
08:40:56 <shapr> Yeah, I thought so...
08:41:34 <shapr> But the general idea is that a public key is like a wormhole to the 'encrypted world' and thus allows communication with an encrypted program.
08:42:00 <shapr> I think it'll work, but I have nowhere close to enough clue to formalize it.
08:42:56 <Cale> Well, with RSA, you'll have trouble. Computing even (M+1)^e (adding one to the message without being able to decrypt it) seems difficult.
08:43:09 <shapr> hej bringert 
08:43:11 <shapr> wassup?
08:43:20 <bringert> hej shapr
08:43:24 <bringert> I'm writing a paper
08:43:38 <shapr> Cale: I'll put it on my list of things to look out for, someone has done this already I'm sure.
08:43:44 <shapr> Neat, what's the paper about?
08:43:52 <bringert> anyone know what the problems with adding type class instance derivation for GADT's are?
08:43:53 <tromp_> it's not possible in a naive sense
08:44:00 <shapr> tromp_: How so?
08:44:06 <bringert> shapr: almost compositional functions
08:44:08 <Cale> shapr: I've heard of things being done
08:44:09 <shapr> bringert: Simon time, iirc
08:44:15 <shapr> Cale: oh tell me more!
08:44:20 <tromp_> for instance, you cannot map M to M/2
08:44:23 <shapr> bringert: What's that?
08:44:32 <bringert> shapr: "Simon time"?
08:44:39 <tromp_> since that would allow you to extract all bits of M
08:44:43 <shapr> bringert: Yeah, I think that was the only limitation to deriving GADTs.
08:44:48 <bringert> ah
08:45:07 <tromp_> see, the attacker can compute the encodings of 0 and 1
08:45:23 <tromp_> and keep applying the /2 operation until he gets one of those 2 encodings
08:45:30 <shapr> bringert: You can find out for sure by looking at the ghc-users list ... just before ICFP I think, when autrijus discovered that GADTs are perfect for teaching newbies about ADTs.
08:45:30 <tromp_> and then work his way back
08:45:43 <shapr> That's when the demand for deriving typeclasses with GADTs suddenly appeared.
08:45:52 <shapr> tromp_: Makes sense.
08:45:59 <bringert> shapr: it's about making it easy to write functions which are pretty much just recursing through some data structure, with just a few interesting cases
08:46:11 <bringert> like many parts of a compiler
08:46:16 <shapr> bringert: Derive a zipper?
08:46:25 <tromp_> you can look up the literature on secure multiparty computation to see how they handle things there
08:46:30 <shapr> That does sound like a neat paper.
08:46:49 <shapr> tromp_: Thanks.. any other keywords I should look for?
08:46:52 <tromp_> it's a setting where multiple parties each have an input to a function f
08:47:12 <tromp_> which they want to jointly compute without learning any info about other's input
08:47:21 <bringert> shapr: I haven't looked at zippers, maybe it's the same thing. got any pointers?
08:47:21 <Cale> shapr: http://en.wikipedia.org/wiki/Encrypted_function
08:47:22 <shapr> It would suck if there's no way to do turing complete ops on encrypted data.
08:47:24 <tromp_> except for what is implied by function result
08:47:34 <tromp_> those keywords should suffice
08:48:12 <tromp_> things often suck that way, shapr:)
08:48:20 <shapr> Yeah, true.
08:48:24 <bringert> ok, looked it up, it's not really a zipper
08:48:33 <shapr> Cale: aha! I am by no means the first to think of this then.
08:48:55 <shapr> bringert: You may want to look at Oleg's ZFS, it has nifty traversal deriving powers.
08:49:48 <shapr> That's the whole niftiness about Oleg's series of Zipper articles, you give it the datastructure and you get the traversal for free.
08:49:48 * rep watches erlang-the-movie.mpg
08:50:04 <tromp_> i rememer a paper that claimed to be able to do DES decryption without revealing the key
08:50:19 <shapr> tromp_: That's the sort of thing I want.
08:50:27 <shapr> Happen to remember the title?
08:50:32 <Cale> shapr: I'm not sure if anyone's worked out a Turing complete version. Polynomial and rational functions are quite a small subset of those you might want to compute.
08:50:36 <tromp_> i'll have to do some serious digging
08:51:19 <shapr> Cale: And there's tromp's point that turing complete encrypted ops will only work where you cannot calculate the value of encrypted 0 and 1
08:51:26 <shapr> Might mean it's just not possible.
08:52:58 <tromp_> look for "obfuscation", e.g. the section on http://www.scs.carleton.ca/~hshen2/framemenu_files/categorized.html?reload_coolmenus
08:53:31 <shapr> Obfuscation is definitely one powerful application of this idea.
08:53:38 <tromp_> that also lists the DES  paper
08:54:26 <tromp_> and the goldreich et al. paper showing that in some sense it's not possible:)
08:54:29 <Cale> shapr: This idea is one powerful application of obfuscation :)
08:55:36 <shapr> tromp_: So how is encryption different from obfuscation?
08:56:18 <shapr> Obviously encryption works, though only by being computationally intractable, can obfuscation work the same way?
08:57:41 <tromp_> encryption is well-defined:)
08:58:47 <shapr> I only want consistency.
08:59:01 <tromp_> obfuscation is ...
08:59:03 <tromp_> %!PS                       %  -John Tromp (http://www.cwi.nl/~tromp/)
08:59:04 <tromp_> 42 42 scale 7 9 translate .07 setlinewidth .5 setgray/c{arc clip fill
08:59:04 <tromp_> setgray}def 1 0 0 42 1 0 c 0 1 1{0 3 3 90 270 arc 0 0 6 0 -3 3 90 270
08:59:04 <tromp_> arcn 270 90 c -2 2 4{-6 moveto 0 12 rlineto}for -5 2 5{-3 exch moveto
08:59:04 <tromp_> 9 0 rlineto}for stroke 0 0 3 1 1 0 c 180 rotate initclip}for showpage
08:59:33 <tromp_> or
08:59:35 <tromp_> char*M,A,Z,E=40,J[40],T[40];main(C){for(*J=A=scanf(M="%d",&C);
08:59:35 <tromp_> --            E;             J[              E]             =T
08:59:35 <tromp_> [E   ]=  E)   printf("._");  for(;(A-=Z=!Z)  ||  (printf("\n|"
08:59:35 <tromp_> )    ,   A    =              39              ,C             --
08:59:35 <tromp_> )    ;   Z    ||    printf   (M   ))M[Z]=Z[A-(E   =A[J-Z])&&!C
08:59:38 <tromp_> &    A   ==             T[                                  A]
08:59:42 <tromp_> |6<<27<rand()||!C&!Z?J[T[E]=T[A]]=E,J[T[A]=A-Z]=A,"_.":" |"];}
08:59:42 <shapr> That's a nice one.
08:59:53 * Saulzar picks #2
08:59:53 <xerox> What is it?
08:59:56 <shapr> Have you seen the two IOHCC contest entries?
09:00:01 <xerox> ...a mazE? :D
09:00:08 <tromp_> the MAZE one is also listed on wikipedia in the obfuscation section:)
09:00:33 <shapr> Oh I have a postscript question... do you know if the random fonts also display the same way on gv?
09:00:51 <tromp_> i saw the lambda calculus interpreter with programs encoded in identifier names:)
09:01:04 <shapr> Yeah, that was crazy.
09:01:13 <shapr> Ulf Norell's winning entry...
09:01:17 <tromp_> hard to beat that:)
09:01:32 <tromp_> like, ever:)
09:01:36 <shapr> MetaSteganographic Obfuscation
09:01:37 <xerox> Any url? :)
09:01:42 <shapr> http://www.scannedinavian.org/iohcc/
09:01:51 <shapr> I keep meaning to run another contest...
09:02:21 <xerox> Why are them ever packed.. hmpf.
09:02:29 <shapr> huh?
09:03:30 <Saulzar> Wow, that's quite some abuse of tuples
09:03:40 <xerox> I mean, why are those entries ever in compressed tarballs.
09:04:06 <shapr> We were following the IOCCC standards.
09:04:12 <shapr> Because we couldn't think of a reason not to.
09:05:04 <Saulzar> To judge them, requires figuring out what they do? :)
09:05:11 <tromp_> they thought obfuscating the contest results was in the right spirit:)
09:05:31 <xerox> Let's do another in 2006 :-)
09:05:36 <shapr> Sounds good to me.
09:07:11 <shapr> Malcolm's ReMorse entry was also awesome.
09:07:13 <xerox> instance Monad P where
09:07:13 <xerox>     return = P' . (,)
09:07:13 <xerox>     P' m >>= f  = P' $ uncurry (runP . f) . m
09:07:14 <xerox> woo.
09:26:12 <SamB> obfustication generally works by being done mostly manually...
09:26:41 <xerox> It depends on what are you obfuscating, for variables' names it kinda works algoritmically too, doesn't it?
09:27:00 <SamB> okay. so there are obfusticators out there too...
09:28:15 <anatolyv> I have another newbie question. I realized I don't really understand what $! does, exactly. I mean, it enforces immediate as opposed to lazy evaluation, but what does 'immediate' mean if the enclosing expression is evaluated lazily anyway? I seem to be missing something embarrassingly simple here I guess.
09:28:41 <xerox> Heh, *maybe* i got some obfuscated code I did in school, YEARS ago, on some paper
09:28:46 <C-Keen> ~.
09:29:29 <Cale> anatolyv: the enclosing expression might never even get around to needing its parameter
09:29:52 <Cale> > (\x -> 5) undefined
09:29:54 <lambdabot> 5
09:29:59 <Cale> > (\x -> 5) $! undefined
09:30:01 <lambdabot> Undefined
09:30:24 <anatolyv> Hmmmm.
09:30:54 <SamB> > (\x -> 5) $ (\y -> 3) $! undefined
09:30:55 <Cale> $! enforces a small bit of strictness, and in the right places can save lots of memory
09:30:56 <lambdabot> 5
09:31:46 <anatolyv> SamB, in this last example $! never got evaluated, right?
09:31:53 <Cale> anatolyv: right
09:32:10 <SamB> anatolyv: right!
09:32:20 <Cale> > (\x -> 5) $! (\y -> 3) $! undefined
09:32:22 <lambdabot> Undefined
09:32:25 <Cale> > (\x -> 5) $! (\y -> 3) $ undefined
09:32:27 <lambdabot> 5
09:32:40 <xerox> Heh.
09:32:56 <anatolyv> So, it's all about the sequence of evaluation, is that it? "f $ x" is - evaluate first f, then x, and "f $! x" is the other way around?
09:33:06 <Cale> right
09:33:27 <Cale> really, it'll just evaluate x enough to determine the top level constructor, and then work on f
09:34:09 <Cale> if x is a list, for example, it'll build the first (:) cell, or work out that it's []
09:34:27 <anatolyv> Cale: could you explain a bit more how it can save lots of memory and why?
09:34:28 <Saulzar> Something I need to investigate, this code seems to leak at about 10Mb/second :/
09:35:08 <SamB> Saulzar: that doesn't sound too hard to investigate
09:35:24 <Cale> anatolyv: well, in some recursive situations, you're building up expressions bit by bit by decomposing some structure. With $!, you can do some of that evaluation a bit early
09:35:27 <SamB> which program?
09:36:09 <dcoutts__> xerox: ping
09:36:13 <Cale> consider foldl (+) 0 [1..100000]
09:36:41 <xerox> dcoutts__: poing!
09:36:47 <Cale> foldl f z []     =  z
09:36:48 <Cale> foldl f z (x:xs) =  foldl f (f z x) xs
09:36:56 <Saulzar> AI bots thing, I just need to compile some libs with profiling first, but it seems odd - since it's jumping out to IO at 40 times/second
09:37:03 <Cale> so, first thing to evaluate is foldl
09:37:12 <anatolyv> Cale: right
09:37:27 <dcoutts__> xerox: seen the Cairo matrx bug reports?
09:37:27 <Cale> foldl (+) 0 [1..100000] = foldl (+) (0 + 1) [2..100000] = foldl (+) ((0 + 1) + 2) [3..100000]
09:37:42 <Cale> = foldl (+) (((0 + 1) + 2) + 3) [4..100000]
09:37:44 <dcoutts__> xerox: btw, have you had a good holiday!?
09:38:06 <Cale> you can see the unevaluated arithmetic expression getting built up there
09:38:12 <xerox> dcoutts__: nope!  yes!
09:38:33 <Cale> it'll be 100001 items long before any of it gets evaluated
09:38:43 <anatolyv> Cale: and it I have $! there, it'll flatten the expression on every recursion to evaluate the top level constructor?
09:38:44 <dcoutts__> xerox: good!
09:38:50 <xerox> dcoutts__: what about you? :)
09:38:51 <Cale> anatolyv: right
09:38:56 <Cale> foldl' f a []     = a
09:38:56 <Cale> foldl' f a (x:xs) = (foldl' f $! f a x) xs
09:39:00 <dcoutts__> xerox: http://sourceforge.net/tracker/?func=detail&atid=455426&aid=1394475&group_id=49207
09:39:05 <dcoutts__> xerox: yeah, good fun thanks
09:39:41 <Cale> now the $! will force the addition to happen right away on each step
09:40:11 <anatolyv> Cale: right, I think I see it now.
09:40:12 <dcoutts__> xerox: I've applied the fixes (mostly) but I just wanted to mention it to you and wonder about checking correctness more carefully perhaps, like some testing.
09:40:31 <Cale> > foldl (+) 0 [1..1000000]
09:40:33 <lambdabot> Exception: stack overflow
09:40:35 <roconnor> Cale, how does foldr work in this example?
09:40:36 <Cale> > foldl' (+) 0 [1..1000000]
09:40:38 <lambdabot> 500000500000
09:40:38 <xerox> dcoutts__: what is 'pointwise' ?
09:40:43 <Cale> > foldr (+) 0 [1..1000000]
09:40:46 <lambdabot> Exception: stack overflow
09:40:59 <roconnor> ouch.
09:41:03 <Cale> much the same, and it's not even tail recursive
09:41:09 <xerox> dcoutts__: I will do, thanks very much for noticing me.
09:41:17 <Cale> foldr is good when you want laziness though
09:41:20 <SamB> > foldr' (+) 0 [1..1000000]
09:41:22 <lambdabot>  Not in scope: `foldr''
09:41:25 <Cale> you hardly ever wany plain foldl
09:41:30 <Cale> want*
09:41:37 <SamB> yes ;-)
09:41:52 <anatolyv> and having foldr', I guess, wouldn't make any difference, that's why it's not there.
09:42:09 <SamB> I suppose not
09:42:13 <SamB> or it would be idiotic
09:42:30 <Cale> anatolyv: right, it probably wouldn't get used :)
09:42:47 <dcoutts__> xerox: pointwise is defined in the Matrix.chs module. eg scalarMultiply scalar = pointwise (*scalar)
09:42:57 <Cale> foldl' is good for collapsing lists into single values
09:43:12 <Cale> foldr is good for lazily processing lists
09:43:36 <Cale> (producing bigger structures from them)
09:44:10 <resiak> Cale: $ : $! :: id : strict ?
09:44:13 <tromp_> let's say, for transforming lists
09:44:20 <anatolyv> Cale: a big huge thank you. It all makes so much more sense now :)
09:44:26 <Cale> anatolyv: no problem
09:45:14 <Cale> resiak: hmm... what's 'strict'?
09:45:50 <resiak> Cale: I thought it forced evaluation ... but maybe it doesn't exist. It was mentioned in the course I took last year
09:45:51 <Cale> all the evaluation that $! does is to the top level constructor (weak head normal form) anyway, which is the least amount of processing you can do.
09:46:08 <resiak> Cale: I'm clearly wrong. Sorry.
09:46:16 <xerox> dcoutts__: you mean it's a C function?
09:46:17 <Cale> no problem :)
09:47:07 <Cale> > foldl (flip const) 0 [1,2,undefined,4,5]
09:47:08 <lambdabot> 5
09:47:14 <Cale> > foldl seq 0 [1,2,undefined,4,5]
09:47:16 <lambdabot> Undefined
09:47:25 <Cale> @type seq
09:47:27 <lambdabot> forall b a. a -> b -> b
09:47:29 <dcoutts__> xerox: no it's a simple Haskell function
09:47:32 <Cale> @type flip const
09:47:34 <lambdabot> forall a b. b -> a -> a
09:47:40 <dcoutts__> pointwise f (Matrix xx yx xy yy x0 y0) =
09:47:40 <dcoutts__>   Matrix (f xx) (f yx) (f xy) (f yy) (f x0) (f y0)
09:48:36 <Cale> > foldl' (flip const) 0 [1,2,undefined,4,5]
09:48:38 <lambdabot> Undefined
10:29:12 <bringert> does anyone konw whether DrIFT supports GADTs?
10:29:22 <dcoutts__> probably not
10:29:37 <dcoutts__> GADTs are newer than recent DrIFT releases
10:29:51 <dcoutts__> (I think)
10:31:10 <bringert> ok, thanks
10:31:27 <bringert> I'll go with TH then
10:32:52 <bringert> TH supports GADTs, right?
10:33:04 * dcoutts__ is not sure
10:36:39 <bringert> grr: "Can't reify a non-Haskell-98 data constructor"
10:36:53 <musasabi> bringert: yes, TH only supports Haskell98
10:38:14 <Heffalump> anyone around vaguely familiar with the GHC libs (or maybe fplibs)?
10:43:35 <CosmicRay> Heffalump: how familiar do you need? ;-)
10:43:51 <Heffalump> I'm trying to figure out the right way to improve Data.HashTable.
10:44:01 <Heffalump> It's currently IO-only. Making an ST version is a trivial code change.
10:44:22 <CosmicRay> ah.  that's more familiar than I am. ;-)
10:44:24 <Heffalump> however, it's not clear how to actually change the library appropriately.
10:44:29 <Heffalump> ok :-)
10:44:43 <CosmicRay> so let me ask you a question.
10:44:49 <Heffalump> (where appropriately = in a way that won't mess up existing users)
10:44:51 <CosmicRay> why do we have Data.HashTable when we already have Data.Map?
10:44:55 <xerox> Heffalump: I'm a newbie about the question I want to pose, but, how is ST faster than IO?
10:45:06 <CosmicRay> It seems trivial to wrap a Data.Map in an IORef or an MVar and get the same functionality as a HashTable
10:45:07 <Heffalump> because it has different complexity properties?
10:45:13 <CosmicRay> ah.
10:45:31 <CosmicRay> does that happen purely because it updates an in-memory instance as opposed to returning a new instance?
10:45:43 <Heffalump> no, balanced binary trees behave differently to hash tables
10:45:51 <Heffalump> even with in-place updates
10:45:59 <Heffalump> xerox: it's not, but it's more useful, cos of runST
10:46:02 <CosmicRay> so why is there no hash table outside of the IO monad?
10:46:11 <xerox> @index runST
10:46:12 <lambdabot> Control.Monad.ST.Lazy, Control.Monad.ST, Control.Monad.ST.Strict
10:46:14 <Heffalump> CosmicRay: because it's not sane to use a hash table without in-place updates
10:46:17 <xerox> @type Control.Monad.ST.runST
10:46:18 <lambdabot> forall a. (forall s. GHC.ST.ST s a) -> a
10:46:20 <CosmicRay> ah.
10:46:25 <Heffalump> xerox: runST allows ST computations to be run from a pure function
10:46:28 <musasabi> xerox: IO is implemented in terms of ST in GHC, but the performance difference is usually very small to nonexistent.
10:46:29 <Heffalump> which you can't do (safely) with IO
10:47:13 <xerox> It's surely an advantage; and it does not break referential transparency in any way?
10:47:34 <Heffalump> xerox: which, IO or ST?
10:47:49 <xerox> The latter.  I suppose it works like a State, in some sense, so no problem.
10:48:07 <Heffalump> it's an advantage _if_ you don't need to do IO operations :-)
10:48:14 <xerox> Well, yes :-)
10:48:48 <xerox> I wonder what's the ST 'API'
10:48:53 <xerox> @docs Control.Monad.ST
10:48:54 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad-ST.
10:48:54 <lambdabot> html
10:49:50 <xerox> Mumble.
10:49:52 <sproingie> 404
10:50:01 <xerox> sproingie: (++ "html")
10:50:11 <sproingie> oh foo.  thanks
10:50:19 <xerox> np.
10:51:26 <xerox> Heffalump: does it define anything along the lines of: 'get' for State, 'tell' for Writer, etc; in order to make it clear its purpose?
10:51:46 <Heffalump> it's a bit different, you make STRefs
10:51:53 <Heffalump> there's no one piece of state, like in State
10:52:14 <xerox> Just mutable spots.
10:52:15 <Heffalump> so you do foo <- newSTRef 5 ; writeSTRef foo 6 ; val <- readSTRef foo
10:52:17 <Heffalump> right
10:52:28 <xerox> Well, that makes it clear too :-)
10:53:28 <xerox> What is the idiomatical function for Reader, I can't remember...
10:53:41 <sproingie> how's that differ from IORefs?
10:53:54 <Heffalump> it doesn't, apart from being for ST
10:53:59 <xerox> sproingie: the good thing is that it is not.  Except you can't do any *other* IO operations.
10:55:14 <maitscha> hallo. i have a function (a -> a -> Bool), e.a. (>=). How can I use this function to sort the  list [a] ?
10:55:25 <xerox> Ah, it is 'ask' !
10:55:29 <Heffalump> sortBy
10:55:34 <Heffalump> @type sortBy
10:55:36 <lambdabot> Not in scope: `sortBy'
10:55:40 <Heffalump> @type Data.List.sortBy
10:55:41 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
10:55:43 <Heffalump> oh, not quite
10:55:45 <maitscha> ths.
10:55:56 <xerox> What does 'e.a.' mean^?
10:56:16 <Heffalump> I think it was supposed to be 'e.g.'
10:56:23 <dcoutts__> maitscha: you need (a -> a -> Ordering) rather than (a -> a -> Bool)
10:56:38 <xerox> Hmm.  OK, then write something like instance Ord FooType where .. ?
10:56:40 <Heffalump> maitscha: you need to make a function of type a -> a -> Ordering somehow. Shouldn't be too hard, but you may need to use == too
10:56:43 <dcoutts__> which is what the 'compare' functions gives
10:56:44 <Heffalump> xerox: no
10:56:48 <dcoutts__> :type compare
10:56:51 <dcoutts__> @type compare
10:56:52 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
10:56:57 <Heffalump> if you really want to use >= to sort by, just do sortBy (flip compare)
10:57:12 <Heffalump> xerox: if using (>=), Ord must already be defined, in the wrong order
10:57:19 <dcoutts__> sort = sortBy compare
10:57:21 <xerox> Which will actually do compare x y = if f x y then GT else LT or something ?
10:57:30 <Heffalump> xerox: yeah, something like that
10:57:41 <xerox> :)  Dinner!  Seeya.
10:57:42 <Heffalump> I think you need to get the EQ answer right too, or the sort will misbehave
10:58:05 <dcoutts__> compare is a member of the Ord class so it may have a more effecient implementation, but the default is implemented in terms of (>=)
10:58:30 <Heffalump> and (==) surely
10:58:36 <dcoutts__> probably
10:58:44 <sproingie> xerox: i'm a bit confused ... i guess an example of when to use an IOref and when to use a STref would help
10:58:47 <zamez> you need either compare or (<=) to implement Ord
10:58:50 <maitscha> hmmm.... when I use sortBy I get a type error.
10:58:57 <Heffalump> sproingie: depends what monad you are in
10:59:02 <dcoutts__> from Hugs' Prelude.hs:
10:59:03 <dcoutts__>     -- Minimal complete definition: (<=) or compare
10:59:03 <dcoutts__>     -- using compare can be more efficient for complex types
10:59:03 <dcoutts__>     compare x y | x==y      = EQ
10:59:03 <dcoutts__>                 | x<=y      = LT
10:59:05 <dcoutts__>                 | otherwise = GT
10:59:11 <Heffalump> maitscha: yeah, my answer was a bit inaccurate, see the discussion that followed
11:05:33 <maitscha> hmmm... I think i need some more help
11:05:43 <maitscha> do I need a function compare?
11:05:54 <maitscha> compare is already defined in prelude.
11:06:16 <maitscha> and compares 2 types.
11:06:24 <Heffalump> you need to make one called something else, but with the same type
11:06:28 <Heffalump> a -> a -> Ordering
11:06:34 <Heffalump> it can use your a -> a -> Bool
11:06:38 <Heffalump> and should probably use (==) too
11:06:48 <Heffalump> try copying the one in the prelude and changing it a bit
11:10:07 <maitscha> but i have a function aaa :: Ord a => (a -> a -> Bool) ...  Then I have something like that: ... where list = sortBy f $ createList t. How should I now use my own function compare1 :: Ord => a -> a -> Ordering?
11:10:27 <maitscha> where f a function like (>=)
11:10:44 <maitscha> where f is a function like (>=)
11:11:46 <Heffalump> change sortBy f to sortBy compare1
11:20:05 <maitscha> I am trying to write a function to convert (a -> a -> Bool) -> (a -> a -> Ordering). Is that possible
11:20:15 <maitscha> sorting :: Ord a => (a -> a -> Bool) -> (a -> a -> Ordering)
11:20:54 <Heffalump> yes, it is possible
11:21:20 <Heffalump> though I suggest you make the constraint Eq a, not Ord a
11:23:55 <maitscha> because when I use l = sortBy compare1 (createList t) it doesnt use the sort operator
11:24:02 <maitscha> compare1 :: Ord a => a -> a -> Ordering
11:24:02 <maitscha> compare1 x y
11:24:02 <maitscha>     | x == y    = EQ
11:24:02 <maitscha>     | x < y     = LT
11:24:02 <maitscha>     | otherwise = GT
11:24:37 <Heffalump> I suggest you change one of those lines to use your function instead.
11:24:49 <Heffalump> your a -> a -> Bool one that is
11:37:27 <maitscha> I think i havent understood it yet.
11:38:06 <maitscha> a function Ord a => a -> a -> Ordering is used for sortBy
11:38:29 <maitscha> I have a function (a -> a -> Bool)
11:39:17 <xerox> You could use something like: magic f x y | x `f` y = LT | otherwise = GT
11:39:24 <xerox> But it misses an 'EQ' case, somehow.
11:40:28 <maitscha> perhaps i should make a little brake after such a hard day.
11:41:23 <xerox> maitscha: how would you sort things with a decision procedure 'a -> a -> Bool', in general?
11:41:50 <xerox> It gives you either a True, or a False value.  What does it say about the ordering, in your specific case?
11:42:09 <maitscha> nothing. it makes only sense with some operator
11:42:23 <maitscha> like >
11:42:50 <xerox> I meant to ask you a description on how would you base the ordering on that function; then I could try to Haskellify the wordy English description.
11:45:44 <xerox> Howdy ADEpt.
11:46:11 <ADEpt> xerox: hi!
11:46:17 <ADEpt> xerox: happy new year!
11:46:50 <xerox> Happy new year, ADE!
11:48:07 <ADEpt> @localtime xerox
11:48:07 <lambdabot> Local time for xerox is Mon Jan  2 19:46:01 2006
11:49:01 <ADEpt> xerox: hm. it either england or something scandinavian. You must have had proper New Year, with snow, furtree and whatnot, right?
11:51:09 <xerox> Try again, you'll be more lucky :-)
11:52:16 <xerox> But hey, we had a white newyear's eve in fact!  Italy, though  :)
11:53:30 <ADEpt> xerox: Italy? And you have snow? Lucky you! We had like 20 cm of snow, but on 30th dec here comes fog and +5 and all snow was gone overnight. So it was green grass for us :(
11:53:44 <cm> :p
11:54:12 <xerox> We got like less than a centimeter, and for a very very short period during the night, riding the midnight.
11:54:18 <xerox> @localtime ADEpt
11:54:32 <ADEpt> 21:52 here :)
11:54:40 <ADEpt> Ukraine
11:54:47 <MarcWeber> Hi. Why can't I find any class Monad statement in fptools/libraries/base/Control/Monad.hs but the export line ? 
11:55:19 <xerox> ...'cause it's defined elsewhere; hence imported and then exported again?  Just guessing.
11:55:28 <Trevion> I believe it's in the standard prelude
11:55:49 <xerox> It would make sense, probably.
12:09:55 <MenTaLguY> hello
12:10:12 <MenTaLguY> I've got a kind of mundane problem to-day
12:10:28 <xerox> Hi MenTaLguY!
12:10:33 <MenTaLguY> howdy xerox
12:10:40 <xerox> Are you the person who posted the cairo matrix problem?
12:10:46 <MenTaLguY> yes, that'd be me
12:11:01 <xerox> Cool.  I'm the author :-)  /me hides under a rock
12:11:25 <MenTaLguY> well, just as long as it gets fixed somehow
12:11:46 <MenTaLguY> I was starting to question my own sanity before I realized the library was wrong :P
12:11:54 <xerox> It will.  I'll test it throughfully in the next days.
12:11:59 <xerox> I'm terribly sorry :(
12:12:02 <MenTaLguY> cool, thanks
12:12:02 <MenTaLguY> s'ok
12:12:31 <xerox> Got another Haskell-related problem in the meanwhile?
12:12:37 <MenTaLguY> yep
12:12:57 <MenTaLguY> trying to find a concise way of ... hm, I guess there are really two separate problems
12:13:41 <maitscha> xerox I have no idea how to solve my problem.
12:13:49 <xerox> Haskell is good at finding concise ways to do things.
12:14:00 <MenTaLguY> the first is just finding the most concise way of generating the sequence [1/1, 1/2, 2/3, 3/4,...]
12:14:08 <xerox> maitscha: did you see my 'magic' definition?
12:14:40 <maitscha> yes.
12:14:44 <MenTaLguY> writing that, I guess that's not so different from the standard "fibs" though
12:14:47 <MenTaLguY> something like ...
12:15:47 <xerox> Hmm, 'import Rational' and '1%1 : [x%(x+1) | x <- [1..]]' is good enough?
12:16:37 <MenTaLguY> actually, yes, that would be fine
12:16:51 <MenTaLguY> I must be a bit fried from coding all morning
12:17:01 <MenTaLguY> I'd probably use map rather than a list comprehension, though
12:17:32 <MenTaLguY> anyhow
12:17:45 <MenTaLguY> the second part is a (little) more interesting
12:18:47 <MarcWeber> xerox: What about let list=[1..] in 1%1: [a%b| a<-list b<-(drop 1 list) ]? ;-) Which one would be faster?
12:18:55 <MenTaLguY> I want to take the front portion of a list until the point where the difference between subsequent values fall below some threshold
12:19:16 <xerox> MarcWeber: does yours really get the aimed result?
12:19:40 <xerox> MenTaLguY: takeWhile decisionProcedure
12:20:01 <MenTaLguY> nope, I need to make the decision based on two adjacent values, not just one
12:20:18 <xerox> Then, fold, I'd say.
12:21:05 <MenTaLguY> my predicate would be something like (\a b -> (a - b) >= 2)
12:21:10 <MenTaLguY> how would that work with fold?
12:21:40 <MarcWeber> xerox: It should .. because x_n%(x_n+1) (x_n=n) is substituted by (x_n)%(x_(n+1)) ;-) I hope you understand what I want to say..
12:22:19 <maitscha> xerox
12:22:20 <maitscha> compare1 :: Ord a => (a -> a -> Bool) -> a -> a -> Ordering
12:22:20 <maitscha> compare1
12:22:20 <maitscha>     | f x y     = LT
12:22:20 <maitscha>     | f y x     = GT
12:22:20 <maitscha>     | otherwise = EQ
12:22:22 <maitscha> should do it.
12:23:51 <maitscha> the only question is now how i can use this function in my sortBy
12:25:01 <SamB> er.
12:25:18 <CosmicRay> FFI question.  I've got some functions that take things of type SQLHANDLE.  Exactly what SQLHANDLE means is implementation-specific.  On my implementation, it is typedefed to void *.  But it may not be that on others.  hsc2hs can't convert #{type SQLHANDLE} for me due to that typedef.  But I can't just use a Ptr () because it could be different on different platforms.  So what should a type signature be for a foreign import of t
12:25:18 <CosmicRay> his sort of function?
12:25:26 <SamB> s/compare1$/compare1 x y/?
12:25:43 <maitscha> ok. now it works.
12:26:20 <xerox> MenTaLguY: I'm trying to write it out
12:26:34 <xerox> I was thinking of something along those lines:
12:26:35 <SamB> CosmicRay: use a type synonym to hardcode it, or alternatively wrap everything first.
12:26:36 <xerox> > scanl (\(Just x) y -> if y - x >= 2 then (Just y) else Nothing) (Just 1) [3,5,7,8,9,10]
12:26:38 <lambdabot>  Non-exhaustive patterns in lambda
12:27:09 <SamB> CosmicRay: you really have to know what sort of type you are dealing with
12:27:27 <CosmicRay> hmm.
12:27:31 <MenTaLguY> takeWhile2 p (x:xs@(x':xs')) = if p x x' then x:(takeWhile2 p xs) else [x]
12:27:31 <MenTaLguY> takeWhile2 p xs = xs
12:27:37 <CosmicRay> it appears that HSQL goes on the assumption that it's always a pointer to something.
12:27:42 <CosmicRay> I guess I'll go on that assumption too, for now.
12:27:45 <maitscha> xerox thank you for your cause for thought.
12:27:54 <MenTaLguY> (er, takeWhile2 :: (a -> a -> Bool) -> [a] -> [a])
12:28:36 <xerox> maitscha: just a second :-)
12:28:41 <SamB> CosmicRay: with a name like that, it most likely will be.
12:28:46 <MenTaLguY> xerox: hmm.  will that work for an infinite list?
12:28:59 <CosmicRay> heh
12:29:10 <xerox> MenTaLguY: I was thinking of wrapping it in a 'takeWhile (/= (-1))' or something.
12:29:11 <CosmicRay> SamB: everything in ODBC is uppercase and starts with "SQL", pretty much.
12:29:15 <CosmicRay> SQLSMALLINT, SQLRETURN, etc.
12:29:23 <xerox> There could be better approaches, maybe.
12:29:23 <CosmicRay> I can tell it was Microsoft that invented it.
12:29:35 <SamB> CosmicRay: I meant the "HANDLE" part
12:29:42 <CosmicRay> ah
12:29:43 <araujo> Hello everyone.
12:29:45 * araujo is back
12:29:48 <CosmicRay> hey araujo
12:29:51 <CosmicRay> dons: ping
12:29:56 <araujo> Hello CosmicRay :-)
12:30:43 <araujo> How things have been doing here? :-)
12:30:53 <SamB> CosmicRay: I'm not sure if MS's HANDLES are all actually pointers, but I'm pretty sure they all have pointer types...
12:31:04 <CosmicRay> evil.
12:31:28 <MenTaLguY> not all HANDLEs are pointers, no
12:31:58 <xerox> > takeWhile (/= (-1)) $ scanl1 (\x y -> if (x - y) >= 2 then x else (-1)) $ take 10 $ 1%1 : [x%(x+1) | x <- [1..]]
12:31:59 <SamB> MenTaLguY: what are the non-pointers?
12:32:00 <lambdabot> [1%1]
12:32:04 <xerox> Well.. ?
12:32:40 <MenTaLguY> hmm, it's been a while
12:32:49 * MenTaLguY tries to remember
12:33:03 <MenTaLguY> it's some weird corner case with one of the older libraries
12:34:28 <xerox> > takeWhile (/= (-1)) $ scanl1 (\x y -> if (x - y) >= 2 then x else (-1)) $ 1%1 : [x%(x+1) | x <- [1..]]
12:34:30 <lambdabot> [1%1]
12:34:31 <MenTaLguY> I haven't done serious Windows programming (with the exception of console stuff) since about 98/99 though
12:36:18 <xerox> > take 8 $ map fromRational $ scanl1 (-) $ 1%1 : [x%(x+1) | x <- [1..]] :: [Float]
12:36:20 <lambdabot> [1.0,0.5,-0.16666667,-0.9166667,-1.7166667,-2.55,-3.4071429,-4.2821426]
12:38:52 <MenTaLguY> hmm
12:39:05 <MenTaLguY> I wonder whether there's a better way to write that takeWhile2 which I posted earlier
12:39:11 <MenTaLguY> because I think that's basically the solution I want
12:39:43 <MenTaLguY> my version's hideously ugly though
12:42:02 <MenTaLguY> hmm
12:42:18 <MarcWeber> MenTaLguY: I would have done it in your way, too..
12:44:13 <xerox> I think scanl1 is nice.
12:45:15 <MenTaLguY> blah xs = map fst $ zip xs $ takeWhile (>= 2) $ scanl1 (-) xs
12:45:32 <xerox> ?!
12:45:56 <xerox> I showed you what it gives you back with that 'xs' we wrote before :(
12:45:57 <MenTaLguY> but actually the scanl1 there isn't taking the difference between successive elements, but rather an element and the accumulator
12:46:08 <xerox> Hmm, whoops.
12:46:13 <xerox> You're right.
12:46:21 <xerox> No, uhm.
12:46:27 <machack666> is there a way to tell ghc's optimizer not to inline certain functions?  I've got a situation where two very simple functions, both of which are basically the same (return $ True) aren't getting called, but if I add something else, such as a putStrLn statement, then they get called successfully.  This suggests that the optimizer is twiddling something around on me.  I already have -fno-cse specified, but to no avail.
12:46:29 <Heffalump> is newtype Foo = Foo (x,y) any more or less efficient than data Foo = Foo x y ?
12:46:45 <Heffalump> machack666: there's a pragma, check the docs
12:46:45 <CosmicRay> machack666: there's a pragma for that, check the ghc user guide
12:46:51 <Heffalump> lol
12:47:07 <MenTaLguY> machack666: {-# NOINLINE function #-}
12:47:30 * CosmicRay takes the more helpful award ;-)
12:47:31 <MenTaLguY> check the docs for specifics, caveats, and portability notes
12:47:41 <machack666> MenTaLguY: Will the function's name suffice?  Thanks for the tip, BTW
12:47:44 <CosmicRay> aw man, mentalguy edged me out ;-)
12:48:03 <MenTaLguY> mac: I think so.  I rarely need to use it.
12:48:05 <Heffalump> CosmicRay: btw, on the subject of HashTable vs Map
12:48:25 <musasabi> {-# NOINLINE #-} should not change the behaviour of your program unless you are using unsafe* 
12:48:29 <Heffalump> it's unlikely that the functional implementation of Map will get compiled to do proper in-place update just because you stick it in a STRef or whatever
12:48:38 <Heffalump> cos that's require quite clever compiler optimisations
12:48:43 <MenTaLguY> mac: is this a CAF you don't want inlined because it's an unsafe IO action?
12:49:27 <SamB> machack666: why do you care if it never gets called?
12:49:54 <machack666> Cocoa's RTS uses the selectors to query behavior, and I would like the behavior I'm indicating.  :)
12:50:07 <machack666> a kind of delegation
12:50:20 <SamB> huh?
12:50:32 <MenTaLguY> xerox: hrm.  still poking at the scanl version, because it's intriguing
12:51:00 <SamB> what does it do anything different if they get "called" then if they "don't get called"?
12:51:08 <xerox> MenTaLguY: are you sure the decision procedure is \a b -> (a - b) >= 2 ?
12:51:18 <MenTaLguY> precisely that, yes
12:51:31 <machack666> in a custom NSView, if you want to accept Key events (say) you need to have a selector (Cocoa's method dispatch system) -acceptsFirstResponder:(BOOL), which returns true if you want to receive key events
12:51:55 <SamB> well does it work without the "NOINLINE"?
12:51:56 <machack666> if cocoa does not see that selector, then you don't get the events by default.
12:52:06 <machack666> I'm trying that now.
12:52:10 <CosmicRay> Heffalump: ahh, ok
12:52:22 <MenTaLguY> mac: er, so you want this to show up in the symbol table, specifically?
12:52:38 <SamB> because I can hardly see how method visibility could be affected by Haskell compiler optimizations...
12:53:04 <SamB> MenTaLguY: Cocoa is ObjC
12:53:10 <MenTaLguY> well, if it's not exported, then it may get inlined away entirely
12:53:16 <xerox> > takeWhile (/= (-1)) $ scanl1 (\x y -> if (x - y) >= 2 then y else (-1)) $ [1000,100,10,5,4,3,2,1]
12:53:17 <lambdabot> [1000,100,10,5]
12:53:24 <SamB> MenTaLguY: inlined into what?
12:53:26 <xerox> That seem to work.
12:53:30 <machack666> since the functions are not called from within my code, I'm wondering if it is getting optimized away
12:53:37 <SamB> oh, that.
12:53:45 <xerox> > takeWhile (/= (-1)) $ scanl1 (\x y -> if (x - y) >= 2 then y else (-1)) $ 1%1 : [x%(x+1) | x <- [1..]]
12:53:46 <lambdabot> [1%1]
12:53:50 <xerox> Dang.
12:53:56 <SamB> machack666: well, the functions won't be of any use if you don't pass them to something
12:54:06 <machack666> but if I have the additional putStr, maybe the compiler decides that it is important enough to keep around--I don't know, just guessing at the difference in behavior.
12:54:14 <Heffalump> bah, can't do computations in ST in the ghci repl.
12:54:32 <xerox> Heffalump: what does it block it?
12:54:32 <SamB> if you want to export to C land, use foreign export...
12:54:34 <machack666> SamB: hoc, the Haskell-Cocoa bridge exposes those functions to the Cocoa Runtime, but only at runtime.  :D
12:54:42 <MenTaLguY> yes, what SamB said
12:54:45 <Heffalump> <interactive>:1:0:
12:54:46 <Heffalump>     Couldn't match `ST s (GHC.STRef.STRef s a)' against `IO a1'
12:55:19 <SamB> machack666: well if you pass it to the Haskell-Cocoa bridge, it will have to exist in some form to be able to be passed ;-)
12:55:21 <Heffalump> I can't really blame it, it'd probably have to unify the s across multiple computations
12:55:22 <MenTaLguY> xerox: hrm, I think that is the cleanest one so far
12:55:29 <machack666> I don't think it has anything to do with the C symbol table. All method dispatches go through the objc's runtime
12:55:36 <machack666> true
12:55:43 <MenTaLguY> xerox: I have kind of an aesthetic thing against "magic values", though, but ... can't think of anything better myself right now
12:55:53 <xerox> MenTaLguY: but hey, look at the intermediate result.
12:55:58 <MenTaLguY> the one that used maybe was kind of unweildy
12:55:58 <xerox> > take 10 $ scanl1 (\x y -> if (x - y) >= 2 then y else (-1)) $ 1%1 : [x%(x+1) | x <- [1..]]
12:56:01 <lambdabot> [1%1,(-1)%1,(-1)%1,(-1)%1,(-1)%1,(-1)%1,(-1)%1,(-1)%1,(-1)%1,(-1)%1]
12:56:15 <xerox> MenTaLguY: well, yes, I didn't think of scanl*1* at that time, heh.
12:56:24 <Heffalump> oh, but I can use stToIO everywhere
12:56:25 <Heffalump> so that's ok
12:56:31 <xerox> I asked you because:
12:57:06 <xerox> > [1%1 - 1%2, 1%2 - 2%3, 2%3 - 3%4]
12:57:08 <lambdabot> [1%2,(-1)%6,(-1)%12]
12:57:10 <machack666> hoc does a bunch of fancy TH stuff behind the scenes, so I don't really know what's going on.
12:57:21 <MenTaLguY> xerox: ah, there's a piece I didn't give you
12:57:23 <xerox> I mean, they are negative.
12:57:52 <MenTaLguY> I'm ... oh, you're right.
12:57:55 <MenTaLguY> The series increases.
12:57:58 <MenTaLguY> duh
12:58:08 <xerox> > take 10 $ scanl (compare) 1%1 $ [x%(x+1) | x <- [1..]]
12:58:09 <lambdabot>   Expecting a function type, but found `Ratio a'
12:58:09 <lambdabot>   Expected type: a -> b
12:58:09 <lambdabot>   Inferred type: Ratio ([Ordering] -> [Ordering])
12:58:10 <MenTaLguY> the piece I was going to mention doesn't help that
12:58:12 <xerox> Well ok.
12:58:13 <SamB> machack666: if you gave me a shell account I'd be happy to play with it ;-)
12:58:37 <MenTaLguY> here, let me back up and I'll give you the full problem
12:58:46 <xerox> Thanks.
12:59:00 <machack666> no go on the NOINLINE
12:59:05 <SamB> or does it insist on using Cocoa and not just objc?
12:59:32 * SamB should like to see the code
13:00:02 <machack666> SamB: It's a custom NSView (i.e., Cocoa) subclass written in Haskell
13:00:12 <MenTaLguY> I'm drawing tickmarks on a ruler of a width which is passed as a parameter
13:00:45 <machack666> this part has been a pita, compared to the rest of the application
13:00:55 <SamB> hmm
13:01:00 <MenTaLguY> Given some mathematical series to determine the length of ticks at various levels of division, I want to stop subdividing when the difference between tickmarks is less than two pixels
13:01:18 * SamB wants to look at hoc
13:01:26 <machack666> hoc.sf.net
13:01:37 <machack666> CVS has the fresher version
13:01:57 <xerox> MenTaLguY: why not go the other way around?
13:02:01 <machack666> but you have to build from source which takes a looooong time
13:02:46 <xerox> MenTaLguY: i.e. 1: sum two, 2: draw a tick, GOTO 1...
13:02:53 <SamB> machack666: a looooong time?
13:03:16 <SamB> does it actually need OS X?
13:03:32 <MenTaLguY> right now what I'm thinking of for generating the tick lengths would be something like... width:[width*(1-x/(x+1)) | x <- [1..]]
13:03:48 <machack666> yes, or at least the system frameworks.  :D
13:03:59 <SamB> system frameworks?
13:04:15 <MenTaLguY> xerox: hrm, the different subdivision levels can have arbitrary intervals, though
13:04:24 <machack666> Mac OS X's answer to libraries.  They contain header files and code refs in one big happy bundle
13:05:26 <machack666> hoc uses an interface generator to parse all of the headers to create haskell stubs for all of the available functions, as well as wrapping objc's runtime system expectations. (basically)
13:05:35 <machack666> ifgen is what takes forever.
13:05:40 <MenTaLguY> it seems easier to just zip the truncated list of tick lengths with the reverse sorted list of tick intervals, and work from that
13:06:23 * SamB tries building anyway
13:06:52 <machack666> I'm really just not sure why if I include the IO actions, it works fine, but if I remove them, then the selectors are not getting called.
13:07:32 <SamB> hmm. so far it has only complained that I'm missing libffi-src in my checkout, and told me how to get it.
13:07:52 <SamB> it made no complaint about the fact that I have the GNU version of the compiler...
13:08:14 <machack666> it could quite possibly work with GNUStep, if you have that installed
13:08:53 <MenTaLguY> the implementation of the GNUStep runtime's a bit different though
13:09:08 <SamB> well, it may complain after that point that I don't have the environment set for GNUStep building...
13:09:11 <machack666> right, so I doubt it'll be able to reproduce my problem :/
13:09:16 <SamB> MenTaLguY: indeed!
13:09:51 <SamB> machack666: well.
13:09:51 <SamB> do you suspect a bug?
13:11:02 <MenTaLguY> hmm
13:11:06 <machack666> I suspect that it's because I'm being optimized away.  I don't really know how to tell, though, as the behavior changes when I add a print-like statement to the function.
13:11:10 <MenTaLguY> there's a better way to do 1 - x / ( x + 1 ), isn't there?
13:12:13 <SamB> how does the behaviour change?
13:12:21 <machack666> I stop getting key events
13:12:26 <SamB> oh. tried -fasm?
13:12:28 <MenTaLguY> ah, namely 1 / ( x + 1 ) :P
13:14:01 <MenTaLguY> at which point I can just do... map recip [1..]
13:14:38 <MenTaLguY> rather than 1:(map (\x -> 1 / ( x + 1 )) [1..])
13:14:58 <MenTaLguY> I'm full of stupid today :/
13:16:46 <MenTaLguY> xerox: still here?
13:16:53 <xerox> Yep.
13:16:59 <MenTaLguY> xerox: I think what we wanted was probably mapAccumL
13:17:23 <MenTaLguY> rather than scanl
13:17:41 <machack666> -fasm worked once, but I want to double-check the code to ensure it's what I thought it was. :)
13:17:57 <MenTaLguY> that way we can put the previous item in the accumulator, but still generate the list of differences
13:18:20 <xerox> @type mapAccumL
13:18:21 <lambdabot> Not in scope: `mapAccumL'
13:18:28 <xerox> @type Data.List.mapAccumL
13:18:29 <MenTaLguY> it's from Data.List
13:18:30 <lambdabot> forall y acc x. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
13:18:35 <MenTaLguY> yeah
13:19:04 <xerox> Well, yes.
13:19:08 <MenTaLguY> mapAccumL (\prev x -> (x, prev - x))
13:19:09 <machack666> hmm..I'll go beat my head on it for a while more
13:19:37 <MenTaLguY> well, and throw a snd on that too
13:20:01 <MenTaLguY> oh, coats
13:20:04 <MenTaLguY> you're a genius
13:20:14 <MenTaLguY> I'm sorry, I don't think I understood what you were getting at earlier
13:20:30 <xerox> You rock too :-)
13:20:32 <MenTaLguY> if we've got a list of differences between elements, and we know the first one (we do), we don't need to carry around the original
13:20:45 <MenTaLguY> so all my zippery was for naught
13:21:50 <MenTaLguY> so, okay, we can do this thing easily now
13:22:10 <xerox> Yeah.
13:23:21 <xerox> I don't like the 'mapAccumL' name, though.
13:23:28 <MenTaLguY> you and me both
13:23:35 <MenTaLguY> still, it does the job
13:24:09 <xerox> Heh, yes.  Thinking of some name 'fold'-based :)
13:25:19 <MenTaLguY> foldMapL maybe.
13:25:23 <Itkovian> evening
13:25:44 <Itkovian> anybody coming to fosdem this year?
13:26:45 <xerox> I see the point of the 'mapAccum' part, well...
13:27:54 <TuringTest> @type Data.List.mapAccumR
13:27:55 <lambdabot> forall y acc x. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
13:28:07 <maitscha> how can i make multiple constraints?
13:28:22 <jyp> Itkovian: I might, since I live in Brussels
13:28:45 <TuringTest> maitscha: What constraints?
13:29:06 <TuringTest> @type (&&)
13:29:07 <maitscha> like xxx :: Ord a => a -> ...
13:29:07 <lambdabot> Bool -> Bool -> Bool
13:29:25 <TuringTest> xxx :: (Num a, Ord a) => a -> ...
13:29:34 <maitscha> ok. thx.
13:29:48 <MenTaLguY> xerox: okay, I think this is what I've ended up with:
13:31:20 <MenTaLguY> scanl (-) thickness' $ map fromIntegral $
13:31:20 <MenTaLguY>   takeWhile (>= 2) $ snd $
13:31:20 <MenTaLguY>     mapAccumL (\prev x -> (x, prev - x)) thickness' $
13:31:20 <MenTaLguY>       map (round . (thickness' /)) [1..]
13:31:26 <MenTaLguY> I think that's right...
13:32:21 <MenTaLguY> I'll probably factor out scanl (-) and snd $ mapAccumL (\prev x -> (x, prev - x)) into "fromDeltas" and "toDeltas" or something like that
13:32:29 <xerox> Yeah.
13:34:02 <xerox> Why do you map fromIntegral?
13:35:05 <MenTaLguY> because of the round
13:35:14 <MenTaLguY> my final result does need to be a Double, eventually
13:35:21 <MenTaLguY> but I don't care immediately
13:36:27 <MenTaLguY> I'm rounding the tick lengths to pixels
13:37:14 <MenTaLguY> s/a Double/a [Double]/
13:38:36 <MenTaLguY> okay, so:
13:39:06 <MenTaLguY> map fromIntegral $ fromDeltas thickness' $ takeWhile (>= 2) $ toDeltas thickness' $ map (round . (thickness' /)) [1..]
13:39:15 <MenTaLguY> that seems basically readable, I hope?
13:41:06 <MenTaLguY> huh
13:41:10 <MenTaLguY> that didn't typecheck
13:41:21 <MenTaLguY> ohh
13:41:26 <MenTaLguY> thickness is a Double
13:41:35 <palomer> > putStrLn "merry christmas"
13:41:37 <lambdabot> No IO allowed
13:41:45 <palomer> > "merry christmas"
13:41:47 <lambdabot> "merry christmas"
13:41:48 <MenTaLguY> merry christmas to you too, lambdabot
13:45:01 <MenTaLguY> cool, typechecks now
13:45:07 <MenTaLguY> ah, crumbs, the first delta is going to be 0
13:45:24 <MenTaLguY> hah!
13:45:28 <MenTaLguY> works beautifully now
13:45:32 <MenTaLguY> thanks xerox!
13:47:46 <Itkovian> @seen shapr
13:47:47 <lambdabot> shapr is in #haskell-blah, #ScannedInAvian and #haskell. Last spoke 4
13:47:47 <lambdabot> hours, 40 minutes and 43 seconds ago.
13:48:18 <xerox> Thank you, MenTaLguY :-)
13:54:51 <Itkovian> night
13:55:26 <MenTaLguY> xerox: in case you're curious, here's the (rather boring, so far) custom ruler in action: http://www.rydia.net/~mental/ploog/ieYieth1Ca.png
13:55:49 <xerox> 404 :(
13:56:01 <MenTaLguY> er, try now
13:56:03 <maitscha> @localtime nexus
13:56:26 <xerox> @karma+ MenTaLguY -- Good one!
13:56:26 <lambdabot> MenTaLguY's karma raised to 1.
13:56:32 <maitscha> @localtime maitscha
13:56:34 <lambdabot> Local time for maitscha is Mon Jan 02 22:54:40 2006
13:56:40 <Muad_Dibber> what you doing MenTaLguY?
13:56:48 <ihope> @type (>>= id)
13:56:49 <lambdabot> forall (m :: * -> *) b. (Monad m) => m (m b) -> m b
13:56:57 <ihope> :-)
13:57:13 <MenTaLguY> Muad: exploring the gtk2hs Gtk/Cairo bindings
13:57:14 <xerox> So, join = (>>= id) ?
13:57:20 <MenTaLguY> also writing a little Haskell canvas widget thing
13:57:21 <ihope> xerox: yep.
13:57:27 <MenTaLguY> and some ruler widgets to go with
13:57:27 <xerox> ihope: woo.
13:57:52 <sjanssen> @pl (>>= id)
13:57:53 <lambdabot> join
13:57:59 <ihope> Also, defining it to equal const undefined doesn't return the wrong result for anything >:-)
13:58:02 <xerox> Right on, sjanssen.
13:59:16 <MenTaLguY> one experiment I'm trying to do is to figure out how rulers in document coordinates should work if you can arbitrarily rotate the document
14:00:10 <MenTaLguY> my current thinking is that x and y exchange once you get past e.g. 45 degrees
14:00:44 <MenTaLguY> possibly the ruler itself should provide hints
14:00:51 <MenTaLguY> about the rotation
14:00:56 <MenTaLguY> but, I've not gotten to that part yet
14:01:17 <xerox> I'd love if you could produce some other meaningful pngs :-)
14:01:40 <ihope> Have the rulers be attached to the document?
14:02:26 <astrolabe> Maybe the label should be 0.8 x + 0.6 y where 0.8 is cos theta and 0.6 is sin theta
14:02:31 <MenTaLguY> no, the rulers stay with the window
14:02:49 <MenTaLguY> they'd get cut off otherwise
14:03:12 <MenTaLguY> (either that, or you'd basically have to allow room for a "ruler disc" in the window)
14:03:15 <xerox> astrolabe: ...what is...theta?
14:03:25 <MenTaLguY> the angle of rotation, in this case
14:04:02 <astrolabe> right
14:04:42 <MenTaLguY> that won't really give you x and y in the document's coordinate system, though, which I think is what people are mostly interested in
14:05:57 <astrolabe> If that is what they are interested in, why are you giving them a rotated view?
14:07:56 <MenTaLguY> it can be convenient to draw on that way
14:08:23 <ihope> Don't let them rotate more than some amount?
14:08:40 <MenTaLguY> I see no reason not to let them rotate all the way
14:08:48 <MenTaLguY> I'm sure there's a reasonable solution with the rulers
14:08:49 <ihope> Other than the ruler problem? :-)
14:11:58 <ihope> lambdabot needs a @lol commands.
14:12:01 <ihope> *command
14:21:47 <ihope> @type \x y -> do {a <- x; b <- y; return (x y)}
14:21:49 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
14:21:49 <lambdabot>   Expected type: t
14:22:05 <ihope> ...?
14:22:09 <mauke> a b unused
14:22:14 <ihope> Oh!
14:22:18 <ihope> @type \x y -> do {a <- x; b <- y; return (a b)}
14:22:19 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => m (a1 -> a) -> m a1 -> m a
14:22:37 <mauke> @pl \x y -> do {a <- x; b <- y; return (a b)}
14:22:37 <lambdabot> (line 1, column 12):
14:22:37 <lambdabot> unexpected "{"
14:22:37 <lambdabot> expecting variable, "(", operator or end of input
14:22:58 <mauke> @pl \x y -> x >>= \a -> y >>= \b -> return (a b)
14:22:58 <lambdabot> (. ((. (return .)) . (>>=))) . (>>=)
14:23:55 <ihope> Pointless needs braces!
14:24:14 <MenTaLguY> braces for faces!
14:24:39 <mauke> hmm, isn't that the same as Monad.ap?
14:24:43 <ihope> Yes.
14:26:50 <xerox> mauke++
14:27:41 <ihope> Hmm, it's Doitch!
14:28:22 <MenTaLguY> hmm, not sure if my ingenious ruler scheme is working
14:40:21 <MenTaLguY> hmm
14:40:28 <MenTaLguY> okay, I'm just not calculating this right
14:42:35 <resiak> I'm using threadDelay (n * ( 10 ** 6)) as a replacement for sleep n in (say) Perl ... is that the Right Way?
14:44:02 <PerlJam> someone coming from perl should know that there is no universal Right Way
14:44:15 <xerox> Heh, that's a good one.
14:44:26 <resiak> Heh. Meh, I only ask because threadDelay is (allegedly) GHC-specific...
14:44:29 <PerlJam> TMTOWTDI isn't the motto just to be cute, it's a description of nature.
14:52:46 <resiak> Okay... is there a way which isn't threadDelay, proving TMTOWTDI?
14:54:20 <ihope> More than one way to do it, eh? Sounds like lists to me.
14:57:51 <MenTaLguY> Hmm
14:58:04 <MenTaLguY> so, let's say I've got a vertical line at x = whatever
14:58:13 <MenTaLguY> and I apply an affine transformation to it
14:58:40 <MenTaLguY> what's the cleanest way to find its post-transformation x intercept?
14:58:51 <SamB> hmm...
14:59:03 <MenTaLguY> actually, I'll make it easier
14:59:04 <MenTaLguY> x = 0
14:59:32 <SamB> my GHCi can't find hs_free_stable_ptr in itself...
14:59:34 <MenTaLguY> I'm thinking I should be able to figure this out from the transformation matrix
15:00:12 <astrolabe> you should be able to.
15:00:56 <astrolabe> The transformation is something like   v ->  Av+w  for an orthogonal A
15:02:54 <astrolabe> If v = (0,y) then  the image of v is ya+w where a is the second column of A.
15:03:41 <MenTaLguY> er, are we using pre- or post- multiply here?
15:04:00 <astrolabe> so a typical point in the image is  (y a1+ w1,y a2 +w2)
15:04:19 <astrolabe> Pre-multiply
15:05:05 <astrolabe> sorry, should have said v = (0,y)^T
15:05:20 <astrolabe> so a typical point in the image is  (y a1+ w1,y a2 +w2)^T
15:06:12 <astrolabe> Solving for y-coord = 0,  y = -w2/a2
15:07:02 <astrolabe> so x-intercept is w1-(a1/a2)w2
15:07:12 <astrolabe> unless a2 = 0
15:08:45 <astrolabe> If a2 =0, then if w2 = 0, every point is an x-intercept else (w2 /=0) there are no x-intercepts.
15:09:17 <MenTaLguY> in my case I don't care about the a2 = 0 case
15:09:41 <astrolabe> That's handy
15:10:11 <palomer> ugh
15:10:15 <palomer> reading about type inference at the moment
15:11:09 <dons> CosmicRay ping
15:11:13 <MenTaLguY> what does the ^T denote?
15:12:26 <gzl> MenTaLguY: transpose
15:13:14 <MenTaLguY> hrm, I still think I'm a bit lost
15:13:26 <astrolabe> ask a question
15:15:43 <MenTaLguY> so, say we've got a matrix:
15:16:07 <xerox> > tranpose [[1,2,3],[4,5,6],[7,8,9]]
15:16:08 <lambdabot>  Not in scope: `tranpose'
15:16:12 <xerox> > List.tranpose [[1,2,3],[4,5,6],[7,8,9]]
15:16:13 <lambdabot>  Not in scope: `List.tranpose'
15:16:17 <xerox> > Data.List.tranpose [[1,2,3],[4,5,6],[7,8,9]]
15:16:18 <lambdabot>  Not in scope: `Data.List.tranpose'
15:16:23 <xerox> wtf.
15:16:25 <gzl> haha
15:16:28 <xerox> @index transpose
15:16:28 <lambdabot> Data.List
15:16:37 * xerox hides.
15:16:38 <MenTaLguY> xx xy 0
15:16:39 <MenTaLguY> yx yy 0
15:16:39 <MenTaLguY> 0  0   1
15:16:42 <astrolabe> you missed the 's' :)
15:16:44 <xerox> > Data.List.transpose [[1,2,3],[4,5,6],[7,8,9]]
15:16:45 <lambdabot> [[1,4,7],[2,5,8],[3,6,9]]
15:16:47 <rep> lol
15:16:57 <MenTaLguY> what would the formula for the x-intercept of that line look like?
15:17:02 <xerox> @karma- rep
15:17:03 <lambdabot> rep's karma lowered to 0.
15:17:16 <rep> :(
15:17:24 <xerox> @karma+ rep
15:17:24 <lambdabot> rep's karma raised to 1.
15:17:33 <xerox> Sorry for playing with your Karma.
15:17:35 <astrolabe> hey.  can you lower someones karma?  I predict karma wars!
15:17:40 <rep> :)
15:17:52 <xerox> astrolabe: it's question of respect, with the 's', ok? :)
15:18:27 <astrolabe> xerox.  sure :)
15:18:33 <xerox> ^_^
15:19:07 <astrolabe> MenTaLguY: ok lets do in in homogeneous coordinates
15:20:05 <MenTaLguY> ok..
15:20:58 <astrolabe> The equation of the y-axis is [1,0,0][x,y,z] = 0
15:21:15 <xerox> Goodnight, folks.
15:21:21 <astrolabe> night night
15:22:22 <palomer> night xerox 
15:22:35 <astrolabe> We need the inverse of your transformation.  Lets call the inverse B.
15:22:50 <palomer> how do I look at older postings on LtU?
15:23:43 <astrolabe> MenTaLguY:  the equation for the image of the y-axis is [1,0,0] B [x,y,z] ^T = 0
15:23:54 <astrolabe> I missed off a ^T before
15:24:02 <astrolabe> The equation of the y-axis is [1,0,0][x,y,z]^T = 0
15:24:33 <astrolabe> [1,0,0] B is the top row of B.
15:25:01 <astrolabe> say [1,0,0] B = [b1,b2,b3]
15:26:17 <astrolabe> so the image of the y axis is the set of [x,y,z] such that x b1 + y b2 + z b3 = 0.
15:26:59 <astrolabe> for the x intercept, y =0
15:28:03 <astrolabe> so x = -z (b3/b1)
15:28:41 <astrolabe> to convert to non-homogeneous coordinates, set z =1, giving x = -b3/b1
15:30:11 <palomer> the exceptional syntax paper is mildly interesting.
15:44:56 <MenTaLguY> ok ... so
15:46:12 <MenTaLguY> I dunno
15:46:42 <MenTaLguY> I think I basically follow you, but I don't completely how b1, b2, and b3 relate to the fields in the matrix
15:46:57 <MenTaLguY> I don't have the mathematical foundation to follow you at that level of abstraction
15:47:43 <astrolabe> B is [[b1,b2,b3],[*,*,*],[*,*,*]]
15:47:55 <astrolabe> where I don't care what the * are
15:48:34 <MenTaLguY> okay, so that'd correspond to xx, xy and 0 in my matrix?
15:48:57 <astrolabe> B is the inverse of your matrix
15:49:11 <MenTaLguY> ahh, ok
15:49:18 <astrolabe> I guess anyway
15:49:27 <MenTaLguY> hmm
15:49:34 <astrolabe> I'm not positive that your matrix is what I think it is.
15:49:57 <astrolabe> Could you show how it used in a transformation?
15:50:55 <MenTaLguY> transformPoint :: Matrix -> (Double,Double) -> (Double,Double)
15:50:55 <MenTaLguY> transformPoint (Matrix xx yx xy yy x0 y0) (dx,dy) = newX `seq` newY `seq` (newX,newY)
15:50:55 <MenTaLguY>   where newX = xx * dx + xy * dy + x0
15:50:55 <MenTaLguY>         newY = yx * dx + yy * dy + y0
15:51:16 <MenTaLguY> postmultiply here
15:51:38 <MenTaLguY> (despite the argument order)
15:52:33 <MenTaLguY> the last row (0, 0, 1) is implied
15:53:17 <MenTaLguY> er, and the fields are not in order ... so, interpret (Matrix xx yx xy yy x0 y0) as:
15:53:32 <MenTaLguY> xx yx x0
15:53:32 <MenTaLguY> xy yy y0
15:53:32 <MenTaLguY> 0   0   1
15:53:51 <MenTaLguY> (again, post-multiply)
15:55:18 <astrolabe> Ok.  I used pre-multiply
15:55:45 <astrolabe> but otherwise, I think we agree.
15:56:28 <astrolabe> So my matrices are the transpose of yours.
15:57:11 <MenTaLguY> so I'd want to look at the first column of the inverse transformation
15:57:16 <MenTaLguY> ?
15:57:24 <astrolabe> Yeah.
15:57:56 <astrolabe> You might or might not find it easier to use the adjoint matrix rather than the inverse.
15:58:04 <MenTaLguY> then b3 is always 0?
15:58:52 <astrolabe> hmmm. let me think
15:59:25 <astrolabe> Doesn't seem likely huh?
16:00:03 <MenTaLguY> no...
16:00:57 <astrolabe> Your matrix has the form for a pre-multiply matrix
16:01:34 <astrolabe> newX = xx*dx + yx*dy + x0
16:02:35 <MenTaLguY> so, xx is b1, yx is b2 and x0 is b3?
16:06:02 <astrolabe> B is the inverse of your matrix
16:06:10 <astrolabe> It's my bed-time.
16:06:38 <MenTaLguY> ok
16:06:45 <MenTaLguY> thanks
16:06:54 <astrolabe> good luck
16:17:34 <MarcWeber> Do you really need the line starting with "translate (x:xs) [y]" in this example: http://www.nomaware.com/monads/examples/example14.hs ?
16:18:32 <palomer> hrm
16:18:39 <palomer> I think I understand type inference
16:18:40 <palomer> it's not hard
16:18:55 <SamB> huh. HOC doesn't like my system...
16:19:08 <palomer> HOC?
16:19:20 <SamB> palomer: thats more than I can say
16:19:46 <palomer> higher order chocolate?
16:20:34 <SamB> Haskell ObjC
16:20:43 <SamB> "HOC: A Haskell to Objective-C BindingHOC: A Haskell to Objective-C Binding"
16:20:59 <SamB> oops, pasted twice...
16:21:10 <SamB> didn't seem to work either time...
16:23:21 <araujo> SamB, sounds cool
16:24:05 <Heffalump> MarcWeber: well, it would behave differently without it
16:24:23 <Heffalump> since the line below makes the recursive call with ys, not y:ys
16:27:08 <SamB> araujo: would be cooler if it didn't segfault GHC on me...
16:30:08 <palomer> who here thinks that "let a = b in c" is the same as "(\a->c) b" ?
16:31:48 <CosmicRay> palomer: that makes sense.
16:31:57 <Igloo> The two aren't equivalent in Haskell
16:32:04 <CosmicRay> though it seems silly.
16:32:19 <CosmicRay> Igloo: why not?
16:32:25 <Igloo> e.g. let a = undefined in (a :: Int, a :: Bool)   is typable whereas   (\a -> (a :: Int, a :: Bool)) undefined   isn't
16:32:51 <palomer> Igloo: ignoring undefined
16:33:56 <SamB> palomer: I'm pretty sure you don't need undefined for that problem
16:35:02 <palomer> (well, erm, the fact is they aren't equal:O)
16:35:13 <MarcWeber> Heffalump: Thanks! I think I'm lacking tr knowlege ;-)
16:35:54 <palomer> @type let foo x = foo (x+1) in foo
16:35:56 <lambdabot> forall a t. (Num a) => a -> t
16:36:07 <Heffalump> MarcWeber: well, I didn't think about how tr worked, I just read the code :-)
16:36:08 * palomer scratches his head
16:36:16 <palomer> how did lambdabot type that!
16:36:23 <SamB> araujo: probably some problem with GNUSTEP/GNU ObjC
16:36:32 <Heffalump> palomer: why wouldn't it be able to?
16:37:16 <Cale> palomer: there's no constraint put on the return type of foo
16:37:38 <palomer> oh, nevermind
16:38:38 <palomer> so is let a = b in c the same as (\a->c) (Y (\a->b))
16:38:48 <SamB> palomer: Its about the same deal as "forever", I guess
16:39:45 <palomer> crap, gotta run
16:39:49 <palomer> we'll continue this discussion later
16:49:53 <SamB> its also possible that the GHC I tried it on is just messed up...
16:56:38 <SamB> hmm, seems to build fine with my normal GHC (after numerous changes to the cbits) if I comment out the call to hs_free_stable_ptr
16:56:57 <SamB> (which the GHCi linker apparantly did not know about)
17:01:25 <dons> SamB, hmm. ghc 6.5  seems to know about it though
17:01:34 <dons> (it's in Linker.c)
17:01:42 <araujo> SamB, More likely, i think Obj-C suffers a lot from its implementations.
17:02:08 <araujo> SamB, seesm like a decente language really, but not good enough supported.
17:02:31 <sproingie> does all right in osx, supported pretty well too
17:02:54 <dons> you can even call haskell from obj C ;)
17:06:06 <SamB> dons: yes. but mine crashes when I try to build that here...
17:06:18 <SamB> probably I have a bad GHCi or something...
17:06:34 <SamB> 6.4 does not crash when I comment it out, though...
17:26:43 <stesch> Yeah, Haskell on page one (hot) of reddit. :-)
17:27:06 <stesch> (Or "the R word" as we Lisper call it.)
17:27:14 <araujo> link?
17:27:39 <dons> @google reddit
17:27:40 <lambdabot> http://reddit.com/
17:27:42 <dons> ?
17:27:44 <araujo> SamB, yes, but.. i don't think it is a good thing to have a language only well supported to one platform.
17:43:41 <palomer> guess who's back
17:44:09 <palomer> does everyone agree that let a = b in c is the same as (\a->c) (Y (\a->b)) ?
17:44:53 * psnl flips a coin
17:45:00 <psnl> yes
17:45:07 <palomer> really?
17:45:12 <palomer> they'll have the same type?
17:45:19 <psnl> I can flip it again if you like
17:46:17 <palomer> @type let f y = f y in f
17:46:19 <lambdabot> forall t t1. t -> t1
17:46:54 <Cale> palomer: you know that let binding usually observes different rules wrt typing from lambda binding, right?
17:47:53 <palomer> yeah
17:47:56 <Cale> > let i x = x in (i 5, i "Hello")
17:47:57 <lambdabot> (5,"Hello")
17:48:25 <palomer> > let i = \x -> x in (i 5, i "hello")
17:48:27 <lambdabot> (5,"hello")
17:49:06 <Cale> > (\i -> (i 5, i "Hello")) (\x -> x)
17:49:07 <lambdabot>  add an instance declaration for (Num [Char])
17:49:34 <palomer> let y f = f (y f) in (\i-> (i 5, i "hello")) (y (\i -> \x -> x))
17:49:39 <palomer> > let y f = f (y f) in (\i-> (i 5, i "hello")) (y (\i -> \x -> x)) 
17:49:41 <lambdabot>  add an instance declaration for (Num [Char])
17:52:21 <palomer> hmm?
17:52:25 <palomer> how the hell does that work?
17:52:29 <palomer> that should be a pair!
17:54:27 <palomer> what's the let rule for type deduction?
18:01:35 <Saulzar> What is the type for i when you pass it (\x -> x) ?
18:02:57 <Cale> Basically, the types of let bound functions aren't affected by the types of things in the 'in' part of the let.
18:03:29 <palomer> Saulzar: I pass i?
18:05:26 <palomer> > let y f = f (y f) in Y id
18:05:26 <Saulzar> > let f i = (i 5, i "Hello") in f (\x -> x)
18:05:27 <lambdabot>  Not in scope: data constructor `Y'
18:05:27 <lambdabot>  add an instance declaration for (Num [Char])
18:05:37 <palomer> > let y f = f (y f) in y id
18:05:39 <lambdabot> Add a type signature
18:05:49 <palomer> @type id
18:05:51 <lambdabot> forall a. a -> a
18:06:18 <palomer>  > let y f = f (y f) in (\i-> (i 5, i "hello")) (y (\i -> \x -> x)) <--why doesn't this return a pair?
18:06:45 <Cale> (\i-> (i 5, i "hello")) -- what's the type of this?
18:07:12 <palomer> a -> (b,c) 
18:07:16 <palomer> no?
18:07:18 <Cale> no
18:07:37 <Cale> you have to pass it a function
18:08:05 <palomer> a could be a function type
18:08:26 <Saulzar> @type (\i -> i 5)
18:08:27 <lambdabot> forall t t1. (Num t) => (t -> t1) -> t1
18:08:39 <Cale> @type (\i -> i "hello")
18:08:41 <lambdabot> forall t. ([Char] -> t) -> t
18:09:14 <Cale> (Num t) => (t -> t1) has to unify with ([Char] -> t2)
18:10:17 <palomer> @type let y f = f (y f) in (\i-> (i 5, i "hello")) (y (\i -> \x -> x)) <--why doesn't this return a pair?
18:10:19 <lambdabot> parse error (possibly incorrect indentation)
18:10:21 <palomer> @type let y f = f (y f) in (\i-> (i 5, i "hello")) (y (\i -> \x -> x))
18:10:23 <lambdabot>   No instance for (Num [Char])
18:10:23 <lambdabot>   arising from the literal `5' at <interactive>:1:30
18:10:37 <palomer> oh, it's an error
18:11:21 <Saulzar> A pair of what though?
18:11:24 <palomer> so, err, I guess let a = b in c is not the same as (\a -> c) (Y (\a -> b))
18:11:31 <Saulzar> That's the issue.
18:11:31 <palomer> (but it should be!)
18:11:49 <palomer> Saulzar: good point
18:12:30 <palomer> (a->b) -> (b,b)
18:18:29 <Saulzar> But there's still no function which satisfies a -> b  for a = [Char] and a = Num
18:20:32 <musasabi> a = [Char] and a = "is an instance of Num" => instance Num [Char] where "this does not make sense"
18:26:18 <Saulzar> > let f :: (forall a. a -> Int) -> (Int, Int); f i = (i 5, i "Hello") in f (\x -> 5)
18:26:20 <lambdabot> Couldn't match `. (forall a)' against `[]'
18:29:55 <Saulzar> Hmm, seems to work in ghci - is lamdabot -fglasgow-exts? I guess it would have a parse error otherwise.
18:31:31 <dons> lambdabot does not allow -fglasgow-exts.
18:31:48 <dons> too many security issues result.
18:32:24 <Saulzar> Ahh.
18:32:41 <Korollary> one day, every irc channel will be running a lambdabot. We have to plan with security in mind.
18:32:52 <dons> very true
18:34:07 <musasabi> mostly it is missing auto-op, logging and less-fp related topic module.
18:34:15 <musasabi> for a general purpose bot
18:34:37 <Pseudonym> It also has no CTCP support.
18:34:55 <musasabi> what is the need for CTCP?
18:35:11 <dons> musasabi, it has both ctcp and logging..
18:35:13 <dons> :)
18:35:21 <Pseudonym> Oh?  When did CTCP go on?
18:35:23 <dons> @localtime
18:35:28 <dons> @localtime dons
18:35:31 <lambdabot> Local time for dons is Tue Jan  3 13:29:13 2006
18:35:34 <dons> uses ctcp
18:35:37 <SamB> araujo: the trouble is more that the NeXT/Apple and GNU runtimes have different APIs for this sort of thing
18:35:40 <musasabi> mmh
18:35:45 <Pseudonym> But I can't CTCP VERSION it.
18:35:50 <Pseudonym> For example.
18:35:59 <dons> it's not a general purpose ctcp plugin, but wouldn't be hard to add, I think.
18:36:06 <araujo> SamB, yes, that's what i meant
18:36:13 <Pseudonym> Oh, also it can't handle DCC.
18:36:19 <araujo> SamB, There is not standard or unimor AFPI
18:36:21 <araujo> API*
18:36:29 <araujo> Which it is not a good thing for a language.
18:36:52 <SamB> araujo: agreed!
18:37:20 <SamB> we should start a commitee!
18:37:28 <dons> yep, no dcc
18:37:41 <Korollary> no streaming audio, either
18:37:48 <dons> or video
18:37:56 <araujo> SamB, well.. they should :-)
18:38:12 <dons> not sentient yet... or is it?
18:38:27 <musasabi> hmm LogModule is quite large
18:39:08 <dons> but it can leap over tall lambdas in a single bound
18:39:09 <rep> is there something like map, but for tuples?
18:39:20 <dons> faq, rep. :)
18:40:14 <SamB> araujo: Apple and GNU?
18:40:26 <SamB> araujo: get real!
18:40:35 <rep> dons ah
18:40:38 <rep> thanks
18:40:49 <musasabi> dons: wouldn't LogModule benefit from a lower level hook to stuff itself into?
18:40:53 <araujo> SamB, I do. I actually think that it would be very beneficial to Apple.
18:41:03 <SamB> GNU, start a standardization commitee?
18:41:26 <dons> musasabi, I'm not sure. I'm not familiari with the code.
18:41:32 <araujo> SamB, With Apple.
18:41:43 <araujo> SamB, Or even Apple alone.
18:41:48 <dons> musasabi, patches welcome.
18:41:53 <SamB> araujo: oh, I don't doubt *that*
18:41:55 <araujo> GNU will surely stick with the standard.
18:42:02 <SamB> but GNU isn't that sane, methinks
18:42:18 <araujo> No, i don't think GNU needs to be part of a committe 
18:42:28 <SamB> araujo: how is apple alone a commitee?
18:42:48 <SamB> okay. so someone should petition Apple to come up with a standard.
18:43:17 <araujo> The important thing is that Apple (or whoever wants it) start a committe (probably with other organizations?) to work on an Objc standard.
18:43:34 <araujo> I mean, that isn't _such_ crazy idea.
18:44:03 <SamB> no.
18:44:17 <SamB> the only sanity I was questioning was GNUs
18:44:37 <araujo> No, i wouldn't care about GNU at all.
18:44:43 <araujo> Not about this.
18:44:51 <rep> is it possible to do pattern matching in lambdas? ie, \(x:xs)->blah ?
18:44:51 <musasabi> the GNU one lacks many things (at least a few years ago)
18:44:55 <araujo> I mean.. Apple doesn't need GNU to make a standard.
18:44:58 <musasabi> rep: yes.
18:45:23 <SamB> it's quite true that GNU tends to go along with what ever standards exist...
18:45:27 <musasabi> > (\(x:_) -> x) "foo"
18:45:28 <lambdabot> 'f'
18:46:54 <rep> cool
18:47:19 <SamB> rep: but you can only give one pattern that way
18:47:36 <rep> yes, that's fine
18:48:03 <musasabi> I learned a new trick today:
18:48:32 <musasabi> > let _ = () {- really a large expression to force types -} in 1
18:48:33 <lambdabot> 1
18:48:36 <rep> hm
18:49:00 <musasabi> I didn't know that one could do the let binding without a variable before :-)
18:50:09 <rep> http://rafb.net/paste/results/Tecxqs56.html
18:50:15 <rep> anyone have an idea on what's wrong?
18:50:30 <rep> oh
18:50:31 <rep> oops
18:51:06 <rep> (sRH, sWH) should be [sRH, sWH]
18:51:07 <musasabi> (sRH,sWH) <- mapM fdToHandle =<< (createPipe >>= \(x, y)-> return [x, y])
18:51:11 <rep> (although it still complains)
18:51:36 <rep> ha, works, now thanks
18:51:38 <rep> but why?
18:51:44 <SamB> musasabi: of course you can
18:52:36 <musasabi> rep: because mapM wants "[a]" not "IO [a]"
18:52:37 <SamB> musasabi: what I didn't realize was that you could do
18:52:37 <SamB> > let in 1
18:52:38 <lambdabot> 1
18:52:56 <rep> musasabi oh ok, that explains it
18:53:20 <SamB> oh, does anyone know which debian package contains AppKit?
18:53:23 <rep> musasabi but then why doesn't it like createPipe >>= \(x, y) -> [x,y] ?
18:53:41 <musasabi> SamB: when one thinks about it, it is clear that _ works there, I just had been using a dummy variable in such places before.
18:53:58 <musasabi> rep: that has type IO [Fd]
18:54:21 <musasabi> wait.
18:54:26 <rep> it has type [Fd]
18:54:30 <musasabi> that is incorrect.
18:54:32 <rep> as far as i can tell
18:54:34 <musasabi> @type (>>=)
18:54:36 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
18:54:37 <dons> musasabi, I use this trick to force runtime type checks when dynamically type checking plugins in hs-plugins
18:54:44 <rep> hm
18:54:56 <musasabi> dons: yes, I used it for forcing types too :-)
18:55:04 <dons> _ = Plugin.foo :: API.type
18:55:33 <musasabi> on top-level?
18:55:47 <musasabi> rep: note how the second argument has to produce a result inside the monad.
18:56:26 <SamB> musasabi: I probably would do that anyway
18:56:37 <SamB> cause _ doesn't look too nice on a line by itself...
18:56:37 <rep> ah, ok
18:56:42 <musasabi> dons: that is even more pretty :-)
18:56:47 <SamB> or rather, at the beginning
18:57:12 <musasabi> SamB: do \n let _ = theExpressionHere \n the block continues
18:57:31 <dons> yep, on the top level musasabi.
18:57:44 <dons> I thin kthis is even described in the hs-plugins paper.
18:58:00 <dons> :}
18:58:35 * musasabi goes to punish himself for being lazy when reading papers
18:59:09 <SamB> musasabi: you would rather be strict
18:59:18 <SamB> ?
18:59:19 <dons> ok, hwn is done all except for the quote of the week.
18:59:20 <dons> hmm
18:59:35 <dons> how to find a quote of the week, anyone got any @quote ideas?
18:59:44 <musasabi> SamB: ?
19:00:06 <dons> (wasn't the `strict' a joke about bondage and punishment?)
19:00:21 <musasabi> or the do block
19:00:23 * musasabi is not sure
19:00:47 <musasabi> (but if it is about punishment, then would sounds weird to by tired senses)
19:02:27 <musasabi> -by
19:02:37 <musasabi> grah. I am not making sense in english anymore.
19:02:53 <dons> hehe
19:03:19 <JKnecht> is there a Haskell Apache module?
19:03:44 <SamB> I didn't figure out what "strict" meant in the context of reading papers
19:03:54 <SamB> but it seemed unlikely to be an improvement
19:04:42 <SamB> JKnecht: no, because you haven't written it yet
19:04:48 <musasabi> heh
19:04:55 <musasabi> I think there is some code out there.
19:05:04 <dons> yeah, there's some stuff. ask Lemmih.
19:05:13 <musasabi> www.scannedinavian.org/repos/modhaskell/ and losser.st-lab.cs.uu.nl/mod_haskell/ at least.
19:05:45 <JKnecht> great, thanks, will checkout.
19:05:51 <rep> -rw-r--r--  1 suleiman  suleiman    4138 Jan  2 19:02 httpd.hs
19:06:03 <rep> my goal is to reach 4096 bytes
19:06:20 <rep> it was originally almost 9k
19:06:32 <rep> (of course it's almost unreadable now)
19:07:00 <musasabi> rep: make names shorter?
19:07:06 <rep> already done
19:07:21 <musasabi> kill some indentation?
19:07:41 <musasabi> 42 space characters is enough
19:07:43 <rep> i'm using tabs instead of spaces now
19:07:48 <Cale> rep: why are you sacrificing readability for source text size?
19:07:49 <dons> remove whitespace: http://www.cse.unsw.edu.au/~dons/pretty.html
19:07:59 <rep> Cale for fun
19:08:06 <Cale> okay :)
19:10:51 <musasabi> dons: pretty :-)
19:11:26 <musasabi> the next stage might be to make a haskell program trasnsformer which takes a program and generates an equivalent program that is pretty ascii-art
19:11:50 <dons> yeah, some of the rewrite rules are quite fun.
19:11:54 <dons> oh, it could be a plugin!
19:12:22 <JKnecht> rep: yours is a standalone daemon?
19:12:29 <rep> JKnecht yes
19:12:34 <rep> it does CGI too!
19:15:02 <Pseudonym> BBS
19:15:34 <rep> http://people.freebsd.org/~ssouhlal/stuff/httpd.hs in case you're interested
19:16:02 <rep> it still needs some work, though
19:17:04 <JKnecht> Interesting though.
19:17:19 <rep> -rw-r--r--  1 suleiman  suleiman    4096 Jan  2 19:14 httpd.hs
19:17:20 <rep> yay
19:18:23 <musasabi> congrats
19:18:58 <JKnecht> will it actually serve /Users/refugee/public_html ?
19:21:08 <rep> JKnecht yes
19:22:39 <JKnecht> then double congrats :)
19:23:11 <rep> http://people.freebsd.org/~ssouhlal/stuff/minihttpd.hs
19:23:28 <rep> could be made shorted by about a few hundred bytes i think
19:23:30 <rep> shorter
19:23:54 <dons> oh this is nice: http://www.joelonsoftware.com/articles/ThePerilsofJavaSchools.html
19:24:09 <dons> (talks about FP and Haskell)
19:33:34 <gzl> a bunch of it is silly though
19:33:47 <gzl> that article, I mean
19:34:25 <gzl> most of it, even
19:34:39 <gzl> didn't care for that article
19:38:24 <glasser> ok, dumb darcs.cgi question: how do I actually *look at* a file?
19:38:46 <glasser> i mean I see "annotate" and "patches" links but no actual file link
19:39:26 <SamB> gzl: whats so silly about Java being too dumbed-down?
19:42:05 <gzl> well, for one, he went off on a long thing about the schools themselves, and it's not true that schools starting with Java never teach C or Haskell. everybody does C (and usually some sizable projects in it)
19:42:50 <gzl> second, asking a C programmer to implement a linked list is not really a meaningful interview question in the first place
19:43:28 <SamB> maybe he doesn't actually do that
19:43:33 <gzl> making the interview question be dependent on the inherent difficulty of the language is pretty silly
19:43:41 <glasser> Everyone doesn't do C
19:43:56 <gzl> the people at the schools he explicitly named do
19:44:06 <glasser> Not MIT, which he named
19:44:15 <gzl> MIT he named in a positive way
19:44:18 <gzl> for doing Scheme
19:44:55 <sproingie> asking a C programmer to show you a linked list code makes it sound like you disbelieve that he knows C
19:45:01 <musasabi> gzl: I would not think that someone without passing knowledge of C is unlikely to have been interested in many common low level projects.
19:45:02 <glasser> true that.  But I think you can easy get through MIT CS without touching pointers (unless you count cons cell pointers)
19:45:18 <SamB> sproingie: probably he wanted them to do actual things
19:45:39 <gzl> MIT doesn't have an operating systems course? I find that hard to believe
19:45:58 <glasser> It has an OS course (pretty new actually) but it is not anywhere near required
19:46:05 <sproingie> SamB: well if you want to see if someone who claims to know C actually knows it, asking him to write the struct to create a linked list and find an element would demonstrate it
19:46:06 <SamB> glasser: don't they make you do a VM at some point?
19:46:22 <sproingie> SamB: but it's so elementary that it's like asking "no really, do you know C or were you lying to me?"
19:46:26 <musasabi> and it is a very quick question.
19:46:28 <gzl> in any case, he wasn't criticizing MIT for not teaching Scheme
19:46:32 <gzl> er, for not teaching C
19:46:39 <glasser> SamB: oh er yeah that :)
19:46:55 * sproingie isn't sure C is useful for teaching computer science.  software engineering, definitely
19:46:59 * musasabi hasn't been on a C course at the univ.
19:47:00 <glasser> sproingie: well, reversing a linked list is slightly nontrivial
19:47:10 <SamB> glasser: in scheme, but still, I'm pretty sure it had something that counts as pointers, if only in an abstract way
19:47:25 <musasabi> then again some courses required that you do assignments in C, but the C cource is quite optional.
19:47:39 <glasser> SamB: there's the course where you implement a CPU from virtual gates.  I guess that counts :)
19:48:10 <SamB> glasser: Isn't there some kind of VM in SICP somewhere?
19:48:10 <gzl> in any case, he wasn't criticizing MIT for not teaching C. he was lauding it for teaching Scheme. he was criticizing schools that start with Java for giving graduates that don't do C or FP, and that's not true (at least in the case of the two schools he mentioned)
19:48:40 <sproingie> glasser: in place?  yeah, but i'm not sure what relevant knowledge that would test
19:48:41 <glasser> SamB: There's a really weird register machine thing. Which they've actually dropped in recent years.
19:49:03 <glasser> gzl: right, not actually disagreeing with you
19:49:06 <gzl> moreover, I think it's pretty silly the way he reduces all of computer science to pointers and lambda calculus
19:49:16 <SamB> gzl: oh?
19:49:26 <glasser> gzl: yeah, on #haskell we reduce it *all* to lambda calculus!
19:49:27 <SamB> those really are the basics, aren't they?
19:49:28 <sproingie> gzl: technically you don't need the pointers to reduce all of cs to something basic
19:49:39 <sproingie> hell, you don't even need the lambda.  just a couple combinators
19:50:03 <SamB> well, the pointers are for implementation
19:50:38 <gzl> at any decent school, you'd get a sequence in theoretical CS, and people who are good at that will be able to pick up the abstractions of FP just as people who are good at FP will be able to pick up Java and OO
19:50:57 <sproingie> ````s``s`ks``s`k`si``s`kk``s`k`s``s`ksk``s`k``s``s``si`k.*`krii`ki
19:51:02 <SamB> gzl: what sort of theory?
19:51:05 <sproingie> so there
19:51:19 <gzl> formal languages, formal grammars, automata theory, computability theory, algorithms, and complexity
19:51:25 <gzl> the usual core material
19:51:37 <SamB> sproingie: unlambda isn't purely functional
19:52:17 <sproingie> SamB: it has impure additions.  you can use just ` s and k if you want
19:52:29 <SamB> sproingie: pretty hard to get output that way
19:52:30 <sproingie> can't do much that's useful with 'em of course
19:52:43 <SamB> so its really not purely functional at all...
19:53:07 <glasser> I suspect most undergrad CS programs do't do any of those except for algorithms, at least not on the "required" track
19:53:58 <glasser> but that probably just says that most undergrad CS programs in america are not "decent" schools
19:54:00 <gzl> glasser: all of those are required at my school. and the intro sequence is in Java, and he explicitly mentioned it in his article as one of these Java schools.
19:55:02 <glasser> good for your school, i certainly think they belong in a standard sequence
19:55:03 <gzl> he's painting with excessively broad strokes
19:55:12 <glasser> gzl: welcome to joel on software :)
19:55:33 <sproingie> spolsky trolls for hits with curmudgeonly ranting
19:55:48 <gzl> I wrote to him about it too, and he pretty much condeded all the points
19:56:06 <gzl> I wanted to respond and ask "So what was the point of the article?" but decided not to
19:56:47 <glasser> well, there certainly are many schools which have more or less vocationalized their CS departments
19:56:53 <sproingie> one of the nice things about trackbacks is how visible they make public rebuttals
19:57:06 <glasser> but just using Java for their intro sequence doesn't do that.  (you're at penn?)
19:57:12 <lambdabot> Haskell Weekly News: January 3, 2005 is out!
19:57:13 <gzl> glasser: yeah. but that's not the same set as schools that start with java.
19:57:17 <gzl> glasser: yes
19:57:23 * glasser nods.
19:57:59 <gzl> I think FP is a good thing to start with, but for other reasons
19:59:08 <SamB> gzl: what other reasons?
19:59:22 <SamB> anyway, aren't excessively broad strokes exactly what FP is good for?
19:59:23 <gzl> for one, it levels the playing field for kids coming in
19:59:28 <gzl> huh?
19:59:33 <gzl> no, his article paints in broad strokes...
20:00:32 <gizban> does haskell have shift left and shift right already defined?  Kind of like << and >> in C++
20:00:36 <SamB> gzl: you would prefer a witty alegorical scifi novel?
20:00:40 <gzl> some kids will enter and be very familiar with Java and others won't. it makes the course extremely uneven and hard for beginners. if you start with ML everybody starts confused
20:00:52 <gzl> SamB: I can't understand almost anything you're saying :)
20:01:07 <SamB> gizban: Data.Bits?
20:01:08 <sproingie> i don't believe in levelling a playing field for its own sake
20:01:17 <Pupeno> does gtk2hs support glade or glade2 ?
20:01:30 <sproingie> though making people throw away bad preconceptions to teach new principles is certainly a good thing
20:01:31 <gzl> nor do I. but in addition to the other benefits, I think this is a good thing that comes out of it
20:01:48 <dons> Pupeno, yep
20:01:53 <SamB> gzl: do you know what alegory is?
20:02:01 <sproingie> my ability to learn haskell is being severely hobbled by years of imperative OOP thinking
20:02:03 <Pupeno> gizban: take a look at the functions on Data.Bits, there are shifting functions.
20:02:10 <gizban> thanks
20:02:11 <gzl> SamB: I know what allegory is. I don't know what alegory is.
20:02:14 <SamB> Pupeno: glade2 naturally
20:02:17 <Pupeno> dons: it wasn't a yes(yep)/no question.
20:02:23 <Pupeno> SamB: thanks.
20:02:54 <SamB> Pupeno: as glade 1 doesn't work too well with gtk 2
20:03:10 * Pupeno is new to glade and gtk.
20:03:22 <SamB> sproingie: oh come on
20:03:41 <SamB> sproingie: its not that much easier for someone with no programming background, unless they have a strong maths background
20:04:20 <SamB> and even so it would probably depend on the particular maths
20:04:46 <dons> you reckon? the haskell core is easy enough it is taught as an introductory language in many unis
20:06:08 <SamB> maybe I am just forgetful
20:06:08 <SamB> I don't remember when I started ;-)
20:06:38 <dons> what have you found hard sproingie?
20:07:06 <dons> also, an aside, knowing FP probably doesn't harm your imperative code..
20:07:26 <gzl> also, more sophisticated languages are supposed to make things easier. you can't fault the language for making things that are "hard" in C easier
20:07:55 <dons> unless you're teaching CS, then maybe not knowing the fundamentals is a problem.
20:07:59 <SamB> dons: I'm just saying maybe it isn't any harder to learn Haskell after learning other things than before
20:08:05 <gzl> which is more or less what he's complaining about
20:08:12 <dons> yeah, i agree. it isn't any harder SamB
20:09:44 <sproingie> dons: i keep wanting to keep everything in stateful objects
20:09:51 <SamB> so, perhaps imperative ways do not get in the way really
20:10:06 <dons> anyway, it's a common complain that Java-ising CS means people don't learn the fundamentals, both low-level hardware and the theoretical side. it's an icky medium, where all you can do is write web applets
20:10:51 <sproingie> dons: i'm not saying imperative code is some lesser discipline that damages the brain, but i did get into a rut, and don't have the formal cs background to get FP as easily 
20:11:26 <SamB> dons: web applets are like obsolete
20:11:35 <SamB> they don't even really work anymore!
20:11:35 <dons> well, it's a subset of FP, so you're learning new things. but I don't think you need any formal background.
20:11:44 <dons> which is why we teach haskell to beginners
20:11:51 <dons> > map (+1) [1..10] -- ain't hrad
20:11:53 <lambdabot> [2,3,4,5,6,7,8,9,10,11]
20:12:15 <gzl> what about monads?
20:12:25 <Cale> Monads are easy
20:12:27 <dons> that's just imperative programming with a scary name.
20:12:31 <SamB> about all you can do are servlets and the like...
20:12:32 <sproingie> hell what about arrows.  at least monads have scads of tutorial material
20:12:45 <dons> sure, there's hard stuff. but nobody uses that stuff 
20:12:46 <SamB> gzl: they aren't hard as long as you don't call them that
20:13:10 <Cale> I taught 11 year old kids to use monads :)
20:13:26 <sproingie> monads in general or the i/o monad?
20:13:30 <Cale> in general
20:13:37 <Cale> via the containers analogy
20:13:38 <gzl> yeah, I know. I still don't think they're totally trivial to teach
20:13:47 <gzl> the containers thing does make things much simpler
20:13:48 <Cale> It should certainly be possible to teach to beginner undergrad students
20:14:30 <dons> we teach imperative sequenced computation to all sorts of people, but just don't tell them about the semantics. so monads, with semantics, shouldn't be too hard.
20:14:31 <gzl> does anyone start with Haskell? I've only seen ML
20:14:55 <Cale> I've seen it
20:15:03 <dons> i started with Haskell
20:15:05 <SamB> I does!
20:16:04 <gzl> no, I mean, any university
20:16:06 <lambdabot> I started with Haskell, and I love it!
20:16:23 <dons> gzl, UNSW does. so does Chalmers, I think. there are many others.
20:16:25 <gzl> ok
20:16:26 <Cale> Some in Australia do
20:16:28 <Cale> yeah
20:16:39 <gzl> that was a legitimate question, btw, not a rhetorical one :)
20:17:10 <SamB> unfortunately the US is behind the times
20:17:20 <SamB> gzl: whats a rhetorical question?
20:17:25 <dons> heh
20:18:08 <gizban> I'm very new.  How do I use Data.Bits(shiftL)?  shiftL 5 2  gives an error
20:18:15 <Cale> SamB: one which is used to provide a context for further statements
20:18:19 <gzl> a question asked solely to assert something rather than produce a reply
20:18:43 <dons> > 5 `shiftL` 2
20:18:44 <lambdabot> Add a type signature
20:18:48 <dons> > 5 `shiftL` 2 :: Int
20:18:49 <lambdabot> 20
20:19:03 <dons> > shiftL 5 2 :: Int
20:19:04 <lambdabot> 20
20:19:23 <Cale> gizban: it has to know what type the numbers are in order to be able to tell what bits it's shifting :)
20:19:49 <dons> > shiftL 5 2 :: Word8
20:19:51 <lambdabot> 20
20:20:01 <gizban> so every time I call the method I need to specify the type?
20:20:03 <Cale> > shiftL 5 40 :: Int
20:20:05 <lambdabot> 0
20:20:08 <Cale> > shiftL 5 40 :: Integer
20:20:10 <lambdabot> 5497558138880
20:20:17 <Cale> gizban: in actual code, probably not
20:20:26 <SamB> Cale: I think that kind is called an introductory question
20:20:30 <Cale> gizban: you just have to make sure that the type is clear from context
20:21:05 <SamB> gizban: in actual code, you'll probably just have constraints
20:21:21 <SamB> if you actually write something ambiguous, the compiler will yell loudly at the site of the ambiguity
20:21:58 <Cale> Questions that do not require an answer, but are only put in the form of a question in order to produce a greater effect
20:22:13 <gizban> 5 and 2 are ambiguous because they can be Int, Integer or floats?
20:22:24 <Cale> So introductory questions I suppose are a subset of those :)
20:22:43 <dons> any type which is a member of class Num, gizban. so not Float
20:22:55 <Cale> dons: er
20:23:05 <Cale> > 5 :: Float
20:23:07 <lambdabot> 5.0
20:23:15 <dons> oh my bad.
20:23:40 <Cale> > shiftL 5 3 :: Float
20:23:41 <lambdabot>  add an instance declaration for (Bits Float)
20:23:41 <lambdabot>   In the expression: shiftL 5 3 :: Float
20:23:41 <lambdabot>   In the definition of `moo': moo = shiftL 5 3 :: Float
20:24:11 <dons> ah, the Bits class, right.
20:24:14 <Cale> hehe, 'moo'
20:24:21 <mjl69> @type 5.0
20:24:23 <lambdabot> forall t. (Fractional t) => t
20:24:29 <mjl69> @type 5
20:24:30 <lambdabot> forall t. (Num t) => t
20:24:42 <dons> nonetheless, class Num a => Bits a
20:25:49 <glasser> What, I can't bit-shift an IEEE double??
20:26:00 <glasser> Haskell is clearly less powerful than C!!
20:26:11 <dons> unsafeCoerce#
20:26:30 <glasser> (actually, hmm, does C let you bitshift doubles without passing through some pointer casts and dereferences?)
20:26:45 <dons> C is just Haskell with unsafeCoerce# on every expresion ;)
20:26:50 <rep> heh
20:27:05 <glasser> what is the # there?
20:27:12 <mjl69> English is more powerful than Chinese
20:27:19 <mjl69> or is it the other way around?
20:28:39 <gizban> haha, my school assignment is to implement Core War in Haskell
20:29:26 <glasser> ooh
20:29:47 <rep> sweet!
20:29:47 <glasser> what class is this?
20:29:57 <gzl> Cale: how did you motivate monads to the 11 year olds?
20:30:11 <gizban> Functional Programming
20:30:18 <gizban> http://www.cosc.brocku.ca/Offerings/4V81/
20:31:40 <dons> SamB, 458:07 hmp3 0.3 :)
20:32:02 <Cale> gzl: I didn't really provide too much in the way of motivation. Young kids learn quickly, and there are lots of examples to play with.
20:32:48 <rep> sometimes i wish i had learned to program when i was younger
20:32:49 <gzl> none of them asked 'what do containers have to do with computations?' :)
20:33:24 <gzl> or why you need monads to do any of these things
20:34:12 <SamB> dons: hmm.
20:34:12 <SamB> I might be just about ready to listen to that playlist again!
20:34:22 <gzl> in other words, why monads? why not some other thing?
20:34:30 <Cale> It's easy to see why containers are a useful concept, and I just introduced monads as a kind of container with these particular operations we can apply to it.
20:34:56 <glasser> did you call them monads?
20:35:12 <Cale> glasser: yeah, that didn't have any noticeable effect
20:35:19 <gzl> I don't see why people think the name is so intimidating
20:35:35 <glasser> were they old enough to immediately react with "heh heh gonads?"
20:35:47 <mjl69> hey, don't monads require the use of algebraic types, and kids aren't capable of understanding algebra until 12 years old?
20:36:17 <Cale> mjl69: they'd already been programming in Haskell for a couple of weeks, following along with HR
20:36:31 <gzl> Cale: ok. do you have a good explanation of why monads are the right abstraction?
20:37:14 <Cale> gzl: well, I didn't provide one explicitly
20:37:20 <gzl> no, I'm asking you for one myself now :)
20:37:21 <SamB> mjl69: algebraic types don't actually require algebra
20:37:27 <Cale> I probably could, if I thought about it :)
20:37:31 <gzl> ok
20:37:35 <SamB> anyway, that thing about needing to be 12 to get algebra is probably a myth
20:38:42 <Cale> Little kids learn ridiculously fast.
20:38:45 <Saulzar> Kids just need to see they can make it do something cool 
20:38:51 <Saulzar> Then they can learn anything
20:39:13 <Cale> Yeah, I think I'd already showed them how to use the IO monad at some point, without bringing up the generalisation.
20:39:14 <gzl> Cale: because to me, the connection between containers and computations isn't totally intuitive
20:40:56 <Cale> gzl: it's two concrete analogies used to explain the same abstract concept. They're not really all that obviously related, but you can sometimes draw computations as chains of boxes which feed values into one another.
20:41:10 <Cale> Which is somewhat of an in-between analogy
20:41:40 <Cale> I think that one gets mentioned in the Appendix of All About Monads
20:42:05 <gzl> yeah, and that's fine. what I'm still not totally clear on is why people settled on monads in the first place.
20:42:09 <glasser> yeah, there's a pretty conveyor belt picture
20:42:36 <Saulzar> Hmm, some monads are containers - it's certainly easier to generalise if you start with something concrete.
20:42:41 <gzl> because the container thing wasn't the original motivation
20:43:02 <glasser> the thing that blew my mind until very recently was the ubiquity of the "a -> m b" type. like, the fact that input to monads was working just through normal lambda abstraction
20:43:29 <glasser> in a way i feel like arrows make a little more sense to me than monads because of that.  although I haven't actually played much with them :)
20:44:05 <Cale> Well, from a computations perspective, the axioms are sort of self-motivating. You want computations to be able to return any value in your original language, so you have 'return', which converts values into computations. Then you want some kind of sequencing, and it's not enough just to be able to say 'run this and then that', but the result of the first computation has to be able to affect the second somehow.
20:44:35 <SamB> glasser: well.
20:44:57 <gizban> is there a way to write numbers in another base?  like 0xFF?
20:44:59 <gzl> Cale: yeah, but that's still thinking of those axioms as operations on containers
20:45:02 <SamB> arrows seem kind of annoying to use, sometimes...
20:45:05 <gzl> Cale: isn't it?
20:45:06 <glasser> > 0xFF 
20:45:08 <lambdabot> 255
20:45:21 <Cale> gzl: I'd say that's a somewhat computational way to look at it
20:45:22 <SamB> gizban: sure!
20:45:29 <gizban> sorry, I should have tested it before asking
20:45:36 <SamB> gizban: printing them that way is trickier though
20:45:44 <glasser> SamB: Well, I haven't written more than a few lines of arrow code.  But intuitively having "the system" handling input as well as output seems reasonable
20:45:56 <glasser> gizban: to tell the truth I wasn't sure what would happen :)
20:46:02 <glasser> gizban: so we both learned
20:46:15 <gzl> Cale: yeah, I suppose. maybe I should read Wadler's articles on this.
20:46:30 <gzl> I think he goes through how they came up with it
20:46:32 <Cale> So that second operation you come up with is bind, which takes a computation, and a rule for constructing the second computation based on the result of the first
20:46:37 <gzl> yeah
20:46:55 <Cale> The container analogy is better supported by fmap, return and join
20:48:06 <gzl> yeah
20:48:12 <Cale> Actually, I think the container analogy is older, but wasn't carried across by the CS folks. I've seen various articles describing examples of monads in mathematics literature, and combinatorial structures are all over them.
20:48:35 <glasser> the big Wadler insight was "this container concept models computations too", right?
20:48:47 <fnord123> anyone know a good page with loads of list comprehensions i can read to get my head around them? I can't seem to do it :-S
20:49:52 <glasser> from google, here are a few http://www.zvon.org/other/haskell/Outputsyntax/listQcomprehension_reference.html
20:50:04 <gzl> glasser: no idea
20:50:36 <Cale> glasser: yeah, from what I've heard, there were people using monads to describe the effects of programs in denotational semantics
20:51:03 <Cale> and they ended up realising that they might as well apply those ideas to the way that they wrote the programs in the first place
20:51:10 <glasser> neat
20:51:18 <SamB> and so somebody figured, why not actually write the programs that way too?
20:51:22 <mjl69> Cale: the container analogy as you explain it makes me question why does the functional argument to bind have to put it's result into it's own individual container.
20:51:23 <Cale> SamB: yeah
20:51:30 <gzl> I see. I suppose what I was getting at is that somebody thought of using monads to do things before this containers analogy came about, so I'm wondering what that guy was thinking. (I think it was Moggi.)
20:52:06 <glasser> mjl69: does it?
20:52:21 <Cale> mjl69: I'll check the wording there :)
20:52:41 <Cale> If I have a box of apples (m a) and for each apple, you will give me a box of blueberries (a -> m b) then I can get a box with all the blueberries together (m b).
20:54:32 <Cale> > [1,2,3] >>= \x -> [x, 10*x]
20:54:33 <lambdabot> [1,10,2,20,3,30]
20:55:05 <mjl69> oh, I guess your analogy doesn't create a problem.  I think of a function as doing something to or with it's argument.  More like turning each apple into a blueberry, putting each blueberry into a box and then taking them out and putting them all in one big box.
20:55:47 <glasser> ah, but you can turn an apple into a box of multiple blueberries
20:55:56 <glasser> (in the genetic engineering monad at least)
20:56:05 <Cale> yeah, well, it reduces to that in the case of x >>= return (f x)
20:56:15 <Cale> which is the same as map f
20:56:24 <mjl69> why not a version of bind such that [1,2,3]  `mybind` \x->x,10*x yields the same result?
20:56:52 <Cale> hm?
20:57:01 <mjl69> oh, I don't know if that made sense, but basically a->b instead of a->m b
20:57:02 <Cale> yields [1,2,3]?
20:57:11 <Cale> that's map
20:57:13 <Cale> fmap
20:57:27 <Cale> > fmap (\x -> 10 * x) [1,2,3]
20:57:29 <lambdabot> [10,20,30]
20:57:59 <Cale> > [1,2,3] >>= \x -> return (10 * x)
20:58:01 <lambdabot> [10,20,30]
20:58:16 <Cale> or,
20:58:40 <Cale> > let f x = 10 * x in [1,2,3] >>= \x -> return (f x)
20:58:42 <lambdabot> [10,20,30]
20:58:44 <gizban> http://www.rafb.net/paste/results/4f91c863.html, how do I return an Integer when the parameters are Int?
20:59:00 <Cale> > let f x = 10 * x in [1,2,3] >>= return . f
20:59:02 <lambdabot> [10,20,30]
20:59:19 <Cale> gizban: fromIntegral
20:59:21 <glasser> @hoogle Int -> Integer
20:59:23 <lambdabot> System.CPUTime.cpuTimePrecision :: Integer
20:59:23 <lambdabot> Data.Bits.bit :: Bits a => Int -> a
20:59:23 <lambdabot> Prelude.toEnum :: Enum a => Int -> a
21:00:02 <glasser> bah
21:00:29 <glasser> that does seem to be a slightly lossy encoding though :)
21:00:55 <Cale> encode (a,b,c,d,e) = fromIntegral (a+b+c+d+e) :: Integer -- this will typecheck, but it's not what you want, because it doesn't protect from overflow
21:01:38 <Cale> encode (a,b,c,d,e) = sum (map fromIntegral [a,b,c,d,e])
21:02:08 <Cale> this will both typecheck and provide protection from overflow in summing the numbers
21:03:13 <gizban> thanks, that's exactly what I needed
21:14:18 <gizban> what's wrong with this line?   (size :: Integer)*2^28    where size is an Int = 12
21:14:48 <Cale> well, if size isn't of type Integer, you shouldn't say that it is :)
21:15:11 <Cale> @type fromIntegral (size :: Int)
21:15:13 <lambdabot> Not in scope: `size'
21:15:18 <gizban> how do I convert it to Integer?  do i have to call a function to convert it?
21:15:22 <Cale> @type \x -> fromIntegral (x :: Int)
21:15:24 <lambdabot> forall b. (Num b) => Int -> b
21:15:31 <Cale> @type \x -> fromIntegral (x :: Int) :: Integer
21:15:33 <lambdabot> Integer :: Int -> Integer
21:15:43 <Cale> heh
21:16:03 <Cale> anyway, fromIntegral handles conversions from integral types (Int, Integer)
21:17:04 <rep> something i'd really like is being able to make .so libraries in haskell.
21:17:05 <gizban> so   fromIntegral(size) * 2^28  ?
21:17:17 <Cale> (fromIntegral size) * 2^28
21:17:45 <Cale> rep: I'm sure you can
21:18:06 <rep> how?
21:18:11 <Cale> The FFI
21:18:30 <Cale> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
21:19:18 <Cale> http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffise3.html#x6-140003.4
21:19:53 <Cale> foreign export ccall "addInt"   (+) :: Int   -> Int   -> Int 
21:20:17 <Cale> you're limited in terms of what types are available
21:21:06 <Pupeno> does anybody have a version of memory that works with today gtk2hs, or do you recommend another path to learn gtk2hs (I don't know much about gtk itself)
21:22:44 <Saulzar> There are quite a few demos in the distribution
21:24:06 <Pupeno> Saulzar: yes, I am inspecting them, but I don't expect them to work as a tutorial really.
21:24:38 <Pupeno> maybe I should learn plain gtk+ first.
21:25:08 <Saulzar> Well, you can follow the memory tutorial and try out various things
21:25:34 <Pupeno> but I can't get the memory samples to work: memory: Cannot cast object to VBox.
21:25:37 <Saulzar> I don't think it's important, I've never used gtk and gtk2hs has been not too much of a mystery
21:26:23 <Pupeno> ok.
21:27:08 <Saulzar> Probably doesn't matter if it won't run... there's another glade demo, maybe you can see what's wrong by comparing them
21:28:53 <Pupeno> ok.
21:33:02 <araujo> Hello.
21:34:32 <Saulzar> Hi.
21:46:54 <Pupeno> hi araujo.
21:51:11 <araujo> Hello Pupeno 
22:11:53 <palomer> hrm
22:12:09 <palomer> does anyone have the deduction rules for the haskell typesystem?
22:15:24 <palomer> recursion is really bothering me
22:16:57 <palomer> pfft, #sml has managed to get smaller since last I went
22:17:56 <dons> the static semantics are published in a few places
22:18:14 <dons> but probably start with the report.
22:18:19 <dons> @where haskell98
22:18:20 <lambdabot> http://haskell.org/onlinereport/
22:22:38 <palomer> it says here that let p = e1 in e2 is (somewhat) equivalent to let p = fix (\p -> e1) in e2
22:23:57 <palomer> which is the same as (\p -> e2) (fix (\p -> e1))
22:24:16 <palomer> (they use \~p->e1 in the onlinereport, I don't know what that means)
22:24:34 <palomer> (it says it's irrefutable)
22:25:38 <palomer> > let fac = \n -> fac n+1 in fac
22:25:39 <lambdabot>  add an instance declaration for (Show (t -> a))
22:25:43 <palomer> @type let fac = \n -> fac n+1 in fac
22:25:45 <lambdabot> forall a t. (Num a) => t -> a
22:26:20 <palomer> @type let y f = f y f in y (\fac n -> fac n+1)
22:26:22 <lambdabot>   Occurs check: cannot construct the infinite type: t = (t -> t2 -> t1) ->
22:26:22 <lambdabot> t1
22:26:22 <lambdabot>   Expected type: t
22:26:39 <palomer> eh, where's the error?
22:28:26 <palomer> @type let y f = f (y f) in y (\fac n -> fac n+1)
22:28:27 <lambdabot> forall t a. (Num a) => t -> a
22:28:32 <palomer> ahh, better
22:53:03 <palomer> hrm
22:53:15 <palomer> @type let fix f = f (fix f) in fix
22:53:16 <lambdabot> forall t. (t -> t) -> t
22:53:25 <palomer> @type let fix f = f (fix f) in fix id
22:53:26 <lambdabot> forall a. a
22:53:36 <palomer> the fixed point of the identity is forall a.a?
22:53:59 <palomer> what the???
22:55:21 <Cale> palomer: it's bottom
22:55:42 <Cale> you have to admit it's a fixed point :)
22:55:43 <palomer> but, like, every term is a fixed point of id
22:55:57 <palomer> this doesn't sit well with my intuition
22:56:04 <Cale> but no other term has such a general type
22:56:34 <Cale> Wouldn't it be surprising if it came back with 5 ?
22:56:55 <palomer> Cale: I'm talking about types
22:57:06 <palomer> I would have thought that exists x.x would be the type of the fixed point
22:57:29 <Cale> there are no existential types in HM inference
22:57:58 <Cale> (and no existential types written that plainly in Haskell either)
22:57:58 <palomer> well, any type is more general than forall a.a
22:58:07 <palomer> I thought if HM inference derives a type, then it's the most general type
22:59:50 <Cale> forall a. a is pretty general
22:59:58 <Cale> it unifies with anything
23:00:18 <palomer> but forall a.a types every image of fix
23:00:25 <palomer> no?
23:00:31 <Cale> hm?
23:01:00 <palomer> ok, take, for example, fac
23:01:18 <Cale> @type let fix f = f (fix f) in fix (\f n -> if n == 0 then 1 else n * f (n-1))
23:01:20 <lambdabot> forall a. (Num a) => a -> a
23:01:33 <palomer> yeah
23:01:37 <Cale> @type let fix f = f (fix f) in fix (\f n -> if n == 0 :: Integer then 1 :: Integer else n * f (n-1))
23:01:39 <lambdabot>   Couldn't match `Integer' against `Bool'
23:01:39 <lambdabot>   Expected type: Integer
23:01:46 <Cale> @type let fix f = f (fix f) in fix (\f n -> if n == (0 :: Integer) then 1 :: Integer else n * f (n-1))
23:01:48 <palomer> > (\f n -> if n == 0 then 1 else n * f (n-1)) undefined
23:01:48 <lambdabot> Integer -> Integer
23:01:49 <lambdabot>  add an instance declaration for (Show (a -> a))
23:02:01 <Cale> @type (\f n -> if n == 0 then 1 else n * f (n-1)) undefined
23:02:02 <lambdabot> forall a. (Num a) => a -> a
23:02:19 <Cale> @type let fix f = f (fix f) in fix (\f n -> if n == 0 then 1 else n * f (n-1)) undefined
23:02:20 <lambdabot> forall a. (Num a) => a
23:03:00 <palomer> (\f n -> if n == 0 then 1 else n * f (n-1)) undefined <---shouldn't this be bottom too?
23:03:54 <palomer> so most general == denotationally smallest?
23:04:13 <palomer> (the first question is most pressing)
23:04:32 <Cale> (\f n -> if n == 0 then 1 else n * f (n-1)) undefined 5
23:04:36 <Cale> > (\f n -> if n == 0 then 1 else n * f (n-1)) undefined 5
23:04:38 <lambdabot> Undefined
23:04:40 <Cale> > (\f n -> if n == 0 then 1 else n * f (n-1)) undefined 0
23:04:42 <lambdabot> 1
23:04:45 <Cale> not bottom
23:05:04 <palomer> I thought the operational semantics were:
23:05:15 <palomer> (\a -> b) undefined = undefined
23:06:22 <Cale> no, that's what makes Haskell lazy is that they're no
23:06:23 <Cale> not8
23:07:07 <palomer> so (\a -> b) undefined = b[undefined/a] ?
23:07:45 <Cale> well, provided the usual stuff about free/bound variables, yeah
23:08:18 <palomer> and undefined x = x ?
23:08:32 <palomer> Cale: substitution takes care of free/bound variables
23:08:39 <palomer> err, undefined x = undefined
23:09:08 <Cale> yep
23:09:15 <palomer> gotcha
23:09:24 <palomer> but in sml, (\a -> b) undefined = undefined, right?
23:09:28 <Cale> right
23:09:47 <palomer> and the most general type means the denotationally smallest by inclusion, right?
23:10:12 <Cale> hmm... possibly :)
23:11:14 * palomer pokes ski
23:11:42 <Cale> yeah, I suppose it is
23:12:03 <Cale> because it unifies with as many other types as possible (by inclusion)
23:12:30 <palomer> and let a= b in c is the same as writing (\a->c) (Y (\a->b)), right?
23:13:04 <Cale> I don't think it's quite the same because of polymorphism.
23:13:14 <palomer> Cale: what do you mean?
23:13:53 <Cale> suppose that b, and thus a gets a polymorphic type in the let-expression
23:14:33 <palomer> sure
23:15:00 <Cale> c might apply a in multiple type contexts where the type of a is restricted in various incompatible ways
23:15:20 <palomer> what's a type context?
23:15:22 <palomer> a sequent?
23:15:36 <palomer> (do you have an example of what you're saying?)
23:15:39 <Cale> okay
23:15:46 <Cale> here's my example from earlier
23:16:12 <Cale> let a = \x -> x in (a (5 :: Int), a "Hello")
23:16:50 <Cale> a gets a polymorphic type, being let-bound, namely, forall t. t -> t
23:17:10 <Cale> then in its first application, that gets specialised to  Int -> Int
23:17:21 <Cale> and in the second application, to  [Char] -> [Char]
23:17:29 <palomer> sure
23:18:26 <palomer> so...?
23:18:33 <Cale> now, consider:  (\a -> (a (5 :: Int), a "Hello")) (\x -> x)
23:19:06 <Cale> we have to assign a type to the first lambda term, and we won't be able to
23:19:29 <Cale> since that means assigning a type to a
23:20:05 <palomer> forall t. (t->t) -> (Int,String)
23:20:26 <palomer> that's a proper type, no?
23:21:24 <int-e> but you want (forall t. (t -> t)) -> (Int, String)
23:21:36 <palomer> but my first type works
23:21:55 <Cale> no, it doesn't.
23:22:14 <Cale> That would mean that I could pass the function a Bool -> Bool and it would work
23:22:21 <palomer> oh ,you're right, it doesn't
23:22:30 <int-e> > (\(a :: forall x . x -> x) -> (a (5 :: Int), a "Hello")) (\x -> x)
23:22:31 <lambdabot>   Illegal signature in pattern: forall x . (x -> x)
23:22:31 <lambdabot>    Use -fglasgow-exts to permit it
23:22:31 <palomer> ok
23:22:50 * palomer kicks lambdabot
23:23:01 <palomer> so, how does type inference work with let bindings?
23:23:10 <Cale> lambda bound variables are assumed monomorphic inside the lambda term
23:23:36 <lambdabot> don't kick me, that's abuse.
23:23:44 <Cale> The entire reason that let is there at all is to allow for polymorphic bindings.
23:24:04 <palomer> let a = b in c  == let a = Y (\a -> b) in c ? 
23:24:07 <Cale> otherwise, we could get by with lambda syntax sugar
23:24:28 <palomer> I always thought haskell let == lisp letrec
23:24:33 <Cale> yeah
23:24:35 <palomer> which is syntactic sugar
23:24:39 <Cale> that's closer to the truth
23:24:45 <palomer> but still a little far?
23:24:46 <Cale> but we have a typesystem
23:25:08 <Cale> let actually has a meaningful function in the type system
23:25:20 <Cale> and can't be desugared away
23:25:32 <Cale> (except by replacement of definition bodies)
23:25:56 <palomer> HM(X) has a deduction rule for let
23:25:56 <int-e> aka inlining?
23:26:04 <Cale> int-e: yeah
23:26:31 <palomer> so, why is it still a little far away from the truth?
23:27:10 <Cale> oh, well, it is letrec functionally, but it can't be implemented with lambda, which is perhaps different
23:27:33 <palomer> <Cale> that's closer to the truth <--what's missing?
23:27:55 <Cale> lisp doesn't have static typing?
23:28:14 <palomer> Cale: common lisp doesn't, neither does cheme
23:28:27 <Cale> yeah
23:28:41 <palomer> s/cheme/scheme
23:28:45 <Cale> when people say "lisp", I usually take that to mean common lisp
23:29:48 <Cale> but yeah
23:30:07 <palomer> ...?
23:30:32 <Cale> If lisp was to aquire a static typesystem, it's likely that letrec would take on a new functionality in the language
23:30:42 <Cale> (just plain let as well)
23:31:34 <Cale> you'd want them to be able to bind values polymorphically
23:31:57 <Cale> currently, that's not a concern
23:32:13 <palomer> how does let a = b in c differ from let a = Y (\a -> b) in c?
23:32:55 <Cale> it doesn't
23:33:00 <palomer> oh, gotcha
23:33:01 <Cale> afaict
23:33:11 <palomer> well, that answers that
23:33:25 <Cale> it's just that there was another difference between lisp and haskell there when you mentioned lisp
23:33:36 <palomer> yeah
23:34:29 <palomer> let p = e1  in  e0  	=	 let p = fix ( \ ~p -> e1) in e0
23:34:29 <palomer> where fix is the least fixpoint operator. Note the use of the irrefutable patterns ~p. This translation does not preserve the static semantics because the use of case precludes a fully polymorphic typing of the bound variables. The static semantics of the bindings in a let expression are described in Section 4.4.3.
23:34:44 <palomer> why doesn't it preserve the static semantics?
23:34:58 <Cale> oh
23:35:44 <Cale> ah, okay, so it is a bit different :)
23:35:54 <palomer> how so?
23:35:54 <Cale> it's the same problem
23:36:54 <palomer> hmm?
23:37:47 <Cale> you have a lambda there which is defeating polymorphism
23:38:46 <palomer> oh, right, my function won't be able to be polymorphic
23:38:50 <palomer> so how do we get around this?
23:39:29 <Cale> by making let primitive
23:39:39 <palomer> what's the typing rule?
23:39:54 <Cale> do you have a copy of TaPL?
23:39:54 <palomer> (that's all I care about, really)
23:40:10 <palomer> Cale: I'm getting one tomorrow, and I printed out chapter 22
23:40:17 <palomer> I have access to the other chapters too
23:40:20 <Cale> Ah, it's in chapter 22
23:40:24 <Cale> 332
23:40:34 <Cale> T-LetPoly
23:41:45 <Cale> basically, the types are inferred based on the inlined version
23:42:11 <palomer> man, all this would be so much simpler in system F
23:42:14 <Cale> I seem to recall there's a more efficient way to do that
23:42:16 <palomer> which section?
23:42:36 <Cale> don't know if it's in TaPL
23:42:39 <int-e> aaaah. this is about describing bindings with holes on a functional level.
23:42:45 <Cale> (I just got TaPL too :)
23:43:08 <palomer> I don't have page numbers
23:43:23 <Cale> oh
23:43:31 <Cale> 22.7
23:43:37 <Cale> Let Polymorphism
23:44:03 <palomer> Cale: but that doesn't deal with recursion
23:44:53 <palomer> Cale: T-Let is derivable with the naive rewriting of let
23:45:29 <Cale> T-Let is the wrong one
23:46:31 <palomer> yeah
23:46:43 <palomer> T-LetPoly is even worse
23:46:47 <palomer> that's blatant application
23:47:10 <palomer> no recursion there!
23:47:16 <Cale> right, I'm not sure if there's a recursive version in the book
23:47:17 <Cale> hmm
23:47:29 <Cale> well, the Haskell Report says it in prose.
23:47:31 <Cale> The Hindley-Milner type system assigns types to a let-expression in two stages. First, the right-hand side of the declaration is typed, giving a type with no universal quantification. Second, all type variables that occur in this type are universally quantified unless they are associated with bound variables in the type environment; this is called generalization. Finally, the body of the let-expression is typed.
23:48:18 <palomer> Cale: the right hand side is typed?
23:48:26 <gaal> I'm trying to use hat for something that does FFI. But I'm running into problems with c headers; if I don't specify -I/usr/include, hat doesn't find basic stuff like stdlib.h. If I do, it gets confused by the headers.
23:48:29 <palomer> Cale: doesn't that also disregard recursion?
23:49:22 <Cale> palomer: I'm pretty sure this way works with recursion
23:49:42 <palomer> so to type let a = b in c
23:49:44 <palomer> I would type b
23:49:55 <Cale> gaal: hmm, using Hat with anything nontrivial is hard
23:50:19 <gaal> is there *any* debugger-type tool that works for nontrivial things? :-(
23:50:31 <palomer> actually, I'm not too clear what the prose means exactly
23:50:32 <Cale> gaal: not that I'm aware of
23:50:37 <Cale> ghci works fine
23:50:58 <Cale> usually what I do is to break up definitions into smaller parts and check each of the parts
23:51:11 <gaal> Cale: is there a way to declaratively inject trace prints into functions?
23:51:15 <Cale> yes
23:51:19 <Cale> Debug.Trace
23:51:26 <gaal> I mean w/o recompilation :)
23:51:34 <Cale> oh, probably not
23:52:05 <palomer> I think I know how to type let a = b in c
23:52:13 <gaal> okay.
23:52:21 <palomer> but man, I'm surprised the literature doesn't mention it
23:52:26 <palomer> you assume a has type alpha
23:52:34 <palomer> then you unify alpha with the type of b
23:52:50 <palomer> and you get another type C
23:52:55 <palomer> which you universally quantify
23:52:59 <palomer> is this correct?
23:53:12 <Cale> yeah, I think so
23:53:33 <Cale> there's an explicit generalisation there
23:53:41 <int-e> > let True = False in True == False
23:53:42 <lambdabot> False
23:53:53 <Cale> heh
23:54:06 <pejo> palomer, I'm not sure what you're asking but http://research.microsoft.com/Users/luca/Papers/BasicTypechecking.A4.pdf might be of interest for you. 
23:54:44 <Cale> what a degenerate case of pattern binding
23:55:00 <palomer> pejo: what bothers me is recursion
23:55:34 <ibid> palomer: how so?
23:55:56 <palomer> ibid: try to type let y f = f (y f) in y
23:56:04 <Cale> palomer: recursion shouldn't bother you too much here, because you have a type variable for the whole expression, and application will just generate a constraint saying that things line up as usual
23:56:10 <int-e> > let a = [a] in undefined
23:56:11 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
23:56:11 <lambdabot>   Expected type: a
23:56:11 <lambdabot>   Inferred type: [a]
23:56:40 <eivuokko> Typing Haskell in Haskell has text and code show how to do typechecking in haskell.
23:56:55 <palomer> eivuokko: eh?
23:57:09 <Cale> > let [] = [1,2,3] in 1:[]
23:57:11 <lambdabot> [1]
23:57:25 <palomer> why does haskell let you rebind constructors?
23:57:26 <palomer> that's evil
23:57:33 <Cale> It's not rebinding them
23:57:40 <palomer> wait, shouldn't that throw an exception?
23:57:41 <int-e> Cale: it's silly but can be very confusing the first time you see it.
23:57:43 <Cale> It's a pattern binding
23:57:47 <ibid> palomer: ok. assume y has the type alpha -> beta (which means f will have type alpha). now, f gets the return value of y as argument, so alpha = beta -> gamma; this gives y :: (beta -> gamma) -> beta
23:57:53 <int-e> palomer: only if you ever evaluate that '[]'
23:58:00 <Cale> Which just happens not to match any variables
23:58:06 <int-e> palomer: that's lazy evaluation
23:58:09 <Cale> > let [x,y,z] = [1,2,3] in x + y + z
23:58:11 <lambdabot> 6
23:58:21 <int-e> hmm
23:58:21 <palomer> ibid: is that your final answer?
23:58:28 <int-e> > let [x,y] = [1,2,3] in x
23:58:29 <lambdabot>  Irrefutable pattern failed for pattern [x, y]
23:58:44 <Cale> > let ~[x,y] = [1,2,3] in x
23:58:45 <palomer> > let [x] = [1,2,3] in x
23:58:46 <lambdabot>  Irrefutable pattern failed for pattern [x, y]
23:58:47 <lambdabot>  Irrefutable pattern failed for pattern [x]
23:58:49 <palomer> > let [] = [1,2,3] in x
23:58:50 <lambdabot>  Not in scope: `x'
23:58:56 <palomer> > let [] = [1,2,3] in ()
23:58:58 <lambdabot> ()
23:58:59 <Cale> oh, right, it's already irrefutable :)
23:59:08 <ibid> palomer: generalize that to get y's real type, and then ungeneralize it again at "in", yielding a type (beta -> gamma) -> beta for the let expression
23:59:17 <palomer> why didn't the irrefutable pattern fail for [] = [1,2,3] ?
23:59:17 <ibid> palomer: well, assuming i didn't make mistakes :)
23:59:29 <int-e> > let [x] = [1,2,3] in ()
23:59:30 <lambdabot> ()
23:59:32 <palomer> ibid: well, erm, it's wrong
23:59:45 <int-e> palomer: because the bound variables (none) are never used.
23:59:55 <ibid> @type let y f = f (y f) in y
23:59:56 <lambdabot> forall t. (t -> t) -> t
