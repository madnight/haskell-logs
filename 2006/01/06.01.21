00:07:36 <Lemmih> dons: Does hs-plugins really work with GHC <6.4?
00:27:05 <skew> Hi. Check my post on the Haskell list - it looks like Oleg's "Simple IO Regions
00:27:34 <skew> has a hole. I'm not sure how (if?) it can be fixed without complicating the system
00:31:12 <lispy> @pl \x -> (foo x) == c)
00:31:13 <lambdabot> (line 1, column 19):
00:31:13 <lambdabot> unexpected ")"
00:31:13 <lambdabot> expecting letter or digit, variable, "(", operator, "==", "/=", "<", "<=",
00:31:13 <lambdabot> ">=", ">", "`elem`", "`notElem`" or end of input
00:31:17 <lispy> @pl \x -> (foo x) == c
00:31:18 <lambdabot> (c ==) . foo
00:44:11 <lispy> dons: should it be possible to lazily read a file using FPS?
00:44:26 <lispy> darcs tries to, but i'm starting to wonder if that is actually possible
00:45:08 <lispy> well, i'm off to bed
00:45:12 <lispy> more of this tomorrow
00:52:40 <Lemmih> dcoutts, dons: Any idea how we handle project management / build support / cabal integration in hIDE? What does visual studio do?
01:00:13 <neologism> anyone skilled with turing machines and O(...) ?
01:00:39 <ncalexan> A little.
01:00:57 <neologism> when I have complexity of P and NP (polynomal and nondeterministci polynomal)
01:00:59 <neologism> whats the difference?
01:01:22 <neologism> I mean PSPACE and NPSPACE
01:01:36 <ncalexan> P and NP I could tell you off the top.
01:01:42 <neologism> turing machines dont differ in space complexity between deterministci and nondeterministic
01:02:01 <ncalexan> PSPACE and NPSPACE I can't recall.
01:02:22 <neologism> polynomal space and non-deterministci polynomal
01:02:26 <neologism> it should be the same
01:02:42 <neologism> as TM solve problems within the same space no matter if they are D or ND
01:02:58 <cpatrick> ncalexan: do you mean EXPSPACE?
01:03:08 <ncalexan> In P and NP, it's verifying a solution in polynomial time.
01:03:14 <neologism> ah
01:03:18 <neologism> its really as I say it
01:03:25 <neologism> PSPACE=NPSPACE
01:03:27 <ncalexan> But I don't know what NPSPACE space means.
01:03:37 <neologism> non-deterministic TM space complexity
01:03:44 <ncalexan> I think you're write.  not PSPACE is, I think, as cpatrick says: EXPSPACE.
01:03:49 <ncalexan> s/write/right.
01:04:00 <neologism> I just wonder why there are two if they are the same
01:04:37 <ncalexan> Well, it's interesting that space hierarchy and time hierarchy are different.
01:04:52 <neologism> the proof is quite trivial
01:05:39 <neologism> ay I have one more question?
01:06:33 <ncalexan> Mmm.
01:07:04 <neologism> what it means when language is C-complete (C being a class of languages)
01:08:19 <ncalexan> That one I don't know.
01:08:34 <ncalexan> Oh, you mean like Turing-complete?
01:09:21 <neologism> I dont know
01:09:25 <neologism> I dont understand the definition
01:09:27 <ncalexan> I've never heard of anyone saying Regular-complete, for example; Regular languages.
01:09:40 <neologism> but it might be what you say
01:09:45 <neologism> ok, thnx
01:09:54 * neologism failed at exam and now studies really hard
01:09:55 <ncalexan> Well, the best I can tell you is for Turing-complete.
01:10:18 <neologism> imho its a language which can be reduced to any of the languages in the class C
01:10:20 <musasabi> dons: Committed recursive. Does fib get inlined or specialized? (if things work without type annotations in the functions like the entry does it would be very nice)
01:10:40 <ncalexan> neologism: that's probably backwards.
01:10:48 <neologism> backwards?
01:11:13 <ncalexan> Oh, maybe you're right.  It's the difference between NP-complete and NP-hard, right?
01:11:29 <neologism> ncalexan: the terms are there
01:11:32 <neologism> what NP-hard?
01:11:38 <neologism> what is...
01:11:42 <ncalexan> And I think hard is the intuitive one -- any NP hard language L can be reduced to your language X.
01:11:57 <ncalexan> I'll refresh the defns, one sec.
01:13:28 <ncalexan> http://en.wikipedia.org/wiki/NP-hard
01:13:37 <ncalexan> That'll be better than me butchering it... and it's late, I must sleep.
01:15:13 <neologism> I have definitions - the problkem is that I dont understand them ;)
01:15:29 <ncalexan> Sorry :(
01:18:57 <cpatrick> neologism: NP-hard = any NP problem can be reformulated in terms of this problem (and the algorithm to rewrite the problem must be in P)
01:19:04 <cpatrick> NP-complete = NP-hard and in NP
01:19:14 <neologism> ok, thnx
01:19:19 <cpatrick> so presumably something similar works for Turing-complete, etc
02:16:15 <jip> @seen Lemmih
02:16:16 <lambdabot> Lemmih is in #haskell-blah and #haskell. Last spoke 1 hour, 22 minutes
02:16:16 <lambdabot> and 56 seconds ago.
02:16:31 <Lemmih> Hi jip.
02:18:01 <jip> Lemmih: hi, there was something i wanted to ask you about your SDL bindings
02:18:52 <jip> pixelFormatGetBytesPerPixel returns an IO action, while some other similar functions return a direct value? why is this?
02:20:15 <Lemmih> I'm not sure it's a constant.
02:20:29 <jip> should i try to find out?
02:20:55 <Lemmih> Yeah, that would be neat.
02:24:35 <jip> btw, are you planning on eventually making a webpage for the bindings with documentation and screenshots and a faq and everything?
02:27:29 <Lemmih> Not really.
02:27:35 * boegel|home would like some screenshots
03:04:55 <jip> @type (^)
03:04:56 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
03:05:52 <jip> is (^) efficient for squaring double values? or will some complex exponent algorithm be invoked?
03:07:10 <tromp> nothing  complex about it
03:32:01 <Saulzar> I think (**) is the more expensive one
03:36:17 <bass> Does anybody here have experience with Text.PrettyPrint?
03:39:16 <bass> I'm writing some Show instances for my data and I decided to use Text.PrettyPrint for it. What I would like to print my data structures in table layout. What is the best method to do that with Text.PrettyPrint? I made my own table function: http://haskell.org/hawiki/HaskellIrcPastePage but can it be done smarter?
03:39:52 <A-Tui> hi
03:40:46 <shapr> @yow !
03:40:47 <lambdabot> Where's th' DAFFY DUCK EXHIBIT??
03:41:26 <A-Tui> any know some tutorial about complexity in haskell?
03:41:48 <shapr> pesco: This deb tutorial is great, thanks
04:11:40 <pesco> shapr: Yeah, my pleasure, I just read it myself.
04:14:31 <pesco> dstatyvka: Oh, another one in .cz!
04:16:00 <xerox> Which one?
04:16:21 <shapr> hiya xerox 
04:16:30 <xerox> Howdy shapr
04:16:42 <shapr> How's code?
04:17:25 <xerox> Thinking about an Haskell-Go with Cale, lately :-)
04:18:13 <shapr> ah cool
04:18:15 <xerox> ....expecially crafted to use SVG for the rendered pieces, using the new cairo+SVG api!
04:20:35 <shapr> wow!
04:20:37 <shapr> I'd like to see that.
04:20:52 <jip> xerox: but the main goal is a go ai?
04:22:15 <xerox> jip: not really :-)
04:22:55 <dcoutts> xerox, glad to see someone's going to use the new svg stuff :-)
04:23:07 <jip> xerox: then just a program with a gui that lets you play go against another human?
04:23:21 <dcoutts> dons, pong
04:23:45 <xerox> Yeah, Cale inkscaped out the stones; we're looking for a wooden board svg, or some idea, now :-)
04:23:46 <Saulzar> Hmm, what sort of algorithms are used in go-search ? The game tree is absurd right?
04:24:21 <jip> xerox: cool, play over a network would also be sweet
04:24:22 <xerox> jip: the goal is to write a lightweight, goodlooking, network-enabled, haskell go.
04:24:31 <jip> ah, excellent :)
04:24:47 <pesco> xerox: Cool, so it will work with the usual Internet servers, I take it? I'm not sure, do they use different protocols or is there some standard?
04:25:17 <astrolabe> They tend to have local search and global search
04:26:08 <xerox> pesco: I know KGS does not allow any client other than his proprietary Java one on its servers.  IGS?  I'm not planning anything, but it's doable I think.
04:26:24 <shapr> greetings Lemmih 
04:26:25 <Saulzar> Is there a FIGS? :)
04:26:36 <shapr> Functional IGS?
04:26:47 <pesco> xerox: is IGS the one aka Pandanet?
04:26:51 <xerox> IGS is free for non-asian people.
04:26:57 <xerox> pesco: yeah right.
04:27:01 <shapr> hoi jorik 
04:27:08 <Saulzar> Free, well there is FICS for chess
04:27:15 <Lemmih> Hiya shapr.
04:27:16 <astrolabe> Bill Shubert provides an extension to the Go Text Protocol to allow connection of engines to KGS
04:27:17 <pesco> xerox: Ah yes. That's what I've been using then.
04:27:20 <jorik> wzup shapr
04:27:37 <xerox> pesco: KGS has a way better client and user interaction than IGS in my experience.
04:27:47 <astrolabe> yeah
04:27:58 <astrolabe> But IGS gets the best players :)
04:28:19 <pesco> xerox: Aha! I think I haven't tried them. So the goal is to make a great IGS client!
04:28:28 <astrolabe> I learned haskell to help me write a go program.  I haven't made much progress though.
04:28:50 <shapr> Well, you're still go'ing right along, yeah?
04:28:51 <xerox> pesco: I admit I love the editing facilities of the KGS client.
04:29:00 <pesco> Anyway, I gotta go. Talk to you all later.
04:29:04 <xerox> Bye bye.
04:29:21 <xerox> It would be nice to have a game, if someone will :-)
04:30:27 <astrolabe> I seem to have stopped playing.
04:30:36 <xerox> So we're having the Olympics right here, in some weeks.
04:31:14 <astrolabe> I can't get over my dislike of the competitiveness that I have.
04:31:19 <astrolabe> Olympics?
04:31:26 <xerox> Yeah, Winder Olympics?
04:31:35 <xerox> Olympiads?
04:31:36 <astrolabe> Where is here?
04:31:44 <xerox> @babel it en Olimpiadi.
04:31:46 <lambdabot>  The Olympic Games.
04:32:13 <xerox> Turin, Piedmount, Italy.
04:32:23 <astrolabe> Cool
04:32:31 <astrolabe> f you don't mind the tourists
04:32:36 <xerox> I know what you mean when you talk about competitiveness.
04:33:12 <xerox> Go is _very_ much up to you :-)
04:34:38 <astrolabe> Yeah.
04:35:15 <xerox> Do you feel like having a game now?
04:35:36 <astrolabe> I have various bits of half-finished poorly written haskell code for go, which you are welcome to have if you would like.
04:35:50 <astrolabe> No thanks to a game.
04:36:06 <xerox> Thank you, I'd love to read them.
04:36:16 <astrolabe> There is no real engine, but it interfaces to kgs.
04:36:28 <xerox> Right.  It accepts bot.
04:40:28 <araujo> Good morning.
04:42:59 <kosmikus> morning araujo 
04:44:00 <araujo> Hello kosmikus !
04:49:15 <dcoutts> Lemmih, yeah, I did have some ideas about project management.
04:49:50 <dcoutts> Lemmih, I think we figured out that it should be possible to match each source file to at most one .cabal file.
04:50:43 <dcoutts> Lemmih, so it should not require any user interaction to build each file (at least in the interactive typechecking style)
04:50:51 <tromp> are your go programs online, astrolabe?
04:51:33 <astrolabe> No, they aren't.  Calling them programs would be an exageration.
04:51:52 <tromp> i'd like to see your code too
04:51:56 <astrolabe> There is one that can connect to kgs and pass at every move.
04:52:37 <astrolabe> It keeps track of captures, but it was written before I had any idea about functional data structures
04:52:58 <astrolabe> They are scraps of programs really :(  I hope to improve them.
04:53:03 <tromp> you mean it's ugly:-?
04:53:13 <shapr> You could put your source online in a darcs repo and hope for patches or critiques.
04:53:20 <astrolabe> It certainly is ugly and inefficient.
04:53:29 <astrolabe> shapr: how would I do that?
04:53:45 <dcoutts> Lemmih, then we should identify each .cabal file in the source tree and find the deps between them.
04:53:49 <Lemmih> dcoutts: We need to work out a gui wrapper.
04:54:03 <dcoutts> Lemmih, I think for a normal build we should just call out to the cabal program.
04:54:04 <shapr> astrolabe: Put your sources into a darcs repo, then put the darcs online accessible via http somehow.
04:54:11 <shapr> astrolabe: That way anyone can grab a copy and look at your sources.
04:54:18 <astrolabe> Also, it is possible (but unlikely) that I might want to use these scraps for something commercial.  I wouldn't want to lose the right to do that.
04:54:26 <dcoutts> Lemmih, I think VS just reads the .cabal file(s) but does not use the cabal exe system.
04:54:30 <shapr> astrolabe: Include a license.
04:54:41 <dcoutts> Lemmih, so it can support incremental rebuilds & interactive typechekcing etc.
04:54:54 <shapr> astrolabe: Also, since you have the copy to your sources, even if you release them under license X now, you can completely relicense them later.
04:55:08 <tromp> it's hard to lose the right to something you wrote yourself:)
04:55:34 <dcoutts> Lemmih, for hIDE, many components are going to want to get at project management info.
04:56:20 <dcoutts> Lemmih, it's not just building, so we'll have to think carefully about what sort of project info api we provide.
04:57:29 <astrolabe> tromp: Are you registered?
04:57:44 <dcoutts> Lemmih, ideally as much of it should be as automatic as possible, I don't like those IDEs where you have to import everything into it's way of doing things.
04:58:24 <eivuokko> VS uses cabal.
04:58:31 <shapr> hei eivuokko 
04:58:35 <eivuokko> For project description and building (and configuring)
04:58:44 <dcoutts> Lemmih, one ought to be able to fire up hIDE in a dir that uses cabal (or just ghc --make) and have the interactive typechecking work and have building work.
04:58:45 <eivuokko> Hiya shapr
04:59:12 <tromp> i am now
04:59:13 <dcoutts> Lemmih, you mean a GUI wrapper for editing the .cabal files?
04:59:43 <Lemmih> dcoutts: A gui wrapper for all gui tasks.
05:00:25 <Lemmih> I don't like that plugins like CommonSense depends on Gtk.
05:00:35 <dcoutts> Lemmih, me too.
05:00:45 <dcoutts> I think we should be able to factor that out.
05:01:30 <dcoutts> Lemmih, though we should rprovide a gui for most/all tasks we need to have things work if people edit stuff manually. Eg we should make use of file change monitoring if it's available.
05:05:13 * Lemmih will update the wiki once he's found some food.
05:06:39 <tromp> how do i change to a different nick?
05:07:14 <tromp> ah, /nick seems to work
05:07:14 <dcoutts> Lemmih, oh I guess we should move our stuff to the new wiki.
05:07:39 <shapr> Yeah, I think I'll lock the old wiki.
05:08:06 <shapr> I'm glad Ashley started the new wiki, I'm tired of doing organizational stuff for now.
05:09:07 <shapr> I probably won't be here much in the future, but dons, musasabi, SyntaxNinja, Igloo, pseudonym, kosmikus, and heffalump have power to ban, change channel modes, etc
05:10:22 <jip> who is Ashley?
05:10:35 <dcoutts> shapr, you wont be here much?
05:10:38 <shapr> Ashley Yakeley, I don't think he's on #haskell
05:10:42 <shapr> dcoutts: Don't think so.
05:10:51 <dcoutts> :-( why?
05:11:23 <shapr> Well, I want to switch my focus to two other subjects, producing working code, and learning proof programming.
05:11:46 <shapr> On the other hand, this may be the best irc channel for proof programming :-)
05:12:01 <tromp> you can stay and just idle more:)
05:12:29 <shapr> Maybe :-)
05:12:52 <tromp> we were worried you were  going on a unicycle trip around the world:)
05:12:57 <shapr> haha!
05:13:06 <shapr> I'd need a unicycle like dcoutts' to do that.
05:13:17 <shapr> My 29" tire probably isn't enough.
05:13:29 <tromp> what does he have? a unitank?
05:13:35 * dcoutts grins
05:13:37 <shapr> He has a 36 inch Coker.
05:13:41 <dcoutts> mmmm
05:13:43 <shapr> dcoutts: Any pix of you on the Coker?
05:13:54 <dcoutts> actually no :-(
05:14:05 <dcoutts> I should take some and upload them
05:14:15 <shapr> Yes!
05:14:50 <tromp> how much does it cost, dcoutts?
05:15:01 <dcoutts> Â£250 ish
05:16:15 <shapr> tromp: http://www.coker.com/store/customer/product.php?productid=18208&cat=302&page=1
05:16:45 <tromp> wow, that wheel looks big
05:17:40 <tromp> $339 though
05:19:16 <shapr> tromp: I think that tire size started with their bikes - http://www.coker.com/store/customer/product.php?productid=18204&cat=300&page=1
05:21:18 <tromp> strange that the unicycle is over 2/3 the price of the cruiser
05:21:44 <shapr> tromp: random question, any idea how to make a reclining uni? I have monster leg muscles, but I can't apply my full strength because I can only work against my weight or my arm muscles when holding the seat. I'd like to be able to press my back into a seat and use my full leg strength. Still, I can't figure out how to balance a unicycle with that setup.
05:22:29 <tromp> i don't think reclining is the solution
05:22:39 <tromp> how about strapping yourself to the saddle?
05:22:50 <shapr> I can press 350kg or so with my legs.
05:24:04 <shapr> Hm, both toe clips and saddle straps are worrisome. It's important to get off the uni quickly when a crash happens.
05:24:32 <dcoutts> yeah, I can attest to that
05:24:40 * xerox walks back in crunching a yellow apple
05:24:52 <neologism> shapr: 350kg?
05:24:58 <dcoutts> shapr, reclinign is possible, let me find the link...
05:25:11 <tromp> then u shld reserve your power for a 2 wheel bike:)
05:25:28 <shapr> I may have to buy a reclining trike or bike then.
05:25:41 <shapr> neologism: ?
05:25:41 <dcoutts> http://www.bath.ac.uk/~ensgwo/monowheel.htm
05:26:20 <neologism> seems quite a lot
05:26:20 <shapr> neologism: How much can you leg press?
05:26:30 <neologism> I dont know but Id expect it to be under 100
05:26:38 <neologism> have never measured it (dont exercise that much)
05:26:59 <pesco> neologism: how much do you weigh?
05:27:03 <neologism> 65
05:27:07 <xerox> Hah, dcoutts, the monowheel is great :-)
05:27:24 <pesco> neologism: Then you can at least press 65. :-)
05:27:25 <tromp> i think u shld manage twice your weight
05:27:38 <xerox> pesco: heh.
05:27:57 <shapr> neologism: I weigh 98 kilos, and I have lots of leg muscles after years of unicycling - http://www.scannedinavian.com/images/shae-sj.png
05:27:59 <neologism> shapr weights 350kgs? :)
05:28:40 <xerox> http://www.netbsd.org/gallery/in-Action/joff-ts7200+hd44780-1.jpg
05:29:08 <neologism> shapr: I see :)
05:30:35 <shapr> xerox: What is that?
05:30:53 <pesco> A happy hacking keyboard at least! :)
05:31:39 <xerox> shapr: netbsd running on... unknown home-made device? :-)
05:31:52 <shapr> Speaking of which, has anyone here heard of a keyboard adaptor from ps2 to bluetooth or wifi? I'd like to strap my 770 onto my spare kinesis keyboard.
05:32:04 <xerox> You got a 770?
05:32:43 <shapr> Yeah, seen the screenshot? http://www.scannedinavian.org/~shae/screenshot00.png
05:33:08 <pesco> shapr: Yay, finally a mobile with a real integrated keyboard. ;)
05:33:15 <xerox> Waaah!
05:33:16 <shapr> Or the other way around ;-)
05:33:34 <pesco> shapr: Exactly. ;)
05:33:43 <shapr> I'd like to hacksaw some of the plastic on the front so I could really slot it into my keyboard.
05:33:48 <pesco> shapr: What kind of system is the 770? I.e. hardware/OS?
05:33:56 <xerox> Linux I think.
05:34:03 <shapr> Of course, in that case I could do mini usb-b to usb.
05:34:14 <shapr> The 770 runs a modified debian/arm linux distro.
05:34:37 <shapr> 65mb of ram, 128 mb flash, and comes with a 64mb rs-mcc card. I bought a 1gb card so I could have lots of space.
05:34:56 <pesco> shapr: By factory!? Wow.
05:35:30 <xerox> How much does it cost?
05:35:46 <shapr> I was going to buy a new palm TX to replace my palm IIIc with dying battery, but the nokia 770 is all around better.
05:35:53 <shapr> xerox: 300 euro without VAT
05:36:15 <shapr> I got mine for business purposes, I hope to get paid to write/port apps for the 770 :-)
05:37:29 <shapr> Several of the 770 developers hang out on #maemo, the channel dedicated to their modified debian/arm distro.
05:37:32 <xerox> Plan: 1. unicycle to Nokia central factory; 2. walk in; 3. ...
05:37:35 <shapr> heh
05:43:00 <pesco> shapr: Maah, I'm jealous!
05:43:16 <shapr> Well, buy one and help me get gtk2hs working on it :-)
05:43:39 <pesco> shapr: I'll get back to you with a decision tomorrow. ;)
05:43:41 <shapr> heh, ok
05:48:39 <ski> > length "constantinopolitanischerdudelsackpfeifenmachersgesellschaft"
05:48:41 <lambdabot> 59
05:51:07 <ski> > length "nihilistendynamittheaterkaestchenssprengungattentaetsversuchungen"
05:51:09 <lambdabot> 65
05:51:59 <_|_kid> ahoy hoy
05:52:12 <_|_kid> ^_^
05:52:57 <lightstep> hello
05:53:05 <_|_kid> that was funny conversation yestaday, nobody agreed on the whole ad-hoc polymorphism in haskell
05:53:06 <ski> > length "transvaaltruppentropentransporttrampelthiertreibertrauungsthraenentragodie"
05:53:08 <lambdabot> 74
05:53:20 <jip> argh, don't bring that shit up again :=
05:53:43 <_|_kid> okay, new topic :D
05:54:15 <jip> like why ghc doesn't have some implementation for better records :(
05:54:29 <ski> > length "mekkamuselmannenmassenmenchenmoerdermohrenmuttermarmormonumentenmacher"
05:54:31 <lambdabot> 70
05:54:34 <lightstep> or why the mtl is more popular than the atl
05:54:37 <jip> the longer this is put off, the worse it will be in the end
05:54:41 <xerox> > 75
05:54:42 <lambdabot> 75
05:54:44 * xerox won
05:54:58 <ulfdoz> ski: Äh, lol
05:55:06 <_|_kid> i've been reading the efforts to make a backend of GHC to .NET plus some other musings that related
05:55:28 * ski wonders if anyone recognizes the source of these 4 words
05:55:34 <ski> :)
05:55:54 <jip> @google transvaaltruppentropentransporttrampelthiertreibertrauungsthraenentragodie\
05:55:56 <lambdabot> No Result Found.
05:55:58 <jip> @google transvaaltruppentropentransporttrampelthiertreibertrauungsthraenentragodie
05:56:00 <xerox> Haskellers' ill brains.
05:56:00 <lambdabot> No Result Found.
05:56:08 <lightstep> markov chains?
05:56:26 * ski might have mistyped/misread some characters .. it's in gothic letter
05:56:47 <lightstep> both 'thie' and 'rei' in the same word?
05:57:36 <tromp> > length "rabarberbarbarabarbarbarenbaardenbarbier"
05:57:37 <lambdabot> 40
05:58:10 * ski wonders though why Twain went down in number of letters in last word
05:58:15 <tromp> off for some rowing...
05:58:20 <xerox> > length "supercalifragilistichespiralidoso"
05:58:22 <lambdabot> 33
05:59:06 <_|_kid> from what i gather so far microsoft.research is on the intuitive for the .NET backend task, i cannot find any news on the progress thus far however i was looking at one of there presentations on it, from what i see is there proposing some extensions to be added to GHC to better support OO & .NET in haskell. Now the only problem is i've just being looking at the paper "Haskell’s overlooked object system" now theoritically i
05:59:24 <ski> (lightstep : 'thier' and 'trieber' i assume are correct splitting)
05:59:29 <_|_kid> does DSEL in pure haskell98 and even nice with some already supported haskell extensions
05:59:41 <_|_kid> *can be done as a DSEL library
06:00:31 <_|_kid> now from this i would conclude that it would make more sense to work on OOHaskell library to help the interop between haskell and .NET
06:00:54 <dcoutts> shapr, only 300 euros +VAT for the 770. That's not bad at all.
06:00:58 <_|_kid> instead of adding a thew new extensions to GHC that microsoft.research propose
06:01:06 <lightstep> ski, my point was that the e came before the i in 'treiber'
06:01:10 <dcoutts> shapr, maybe I will get one and help you port gtk2hs :-)
06:01:30 <jip> how do i convert a Double to an Int?
06:01:40 <Heffalump> @type fromRational
06:01:42 <lambdabot> forall a. (Fractional a) => Rational -> a
06:01:51 <Heffalump> hmm, no
06:01:57 <Heffalump> @type toInteger
06:01:58 <lambdabot> forall a. (Integral a) => a -> Integer
06:02:11 <_|_kid> jip: i'm sure you asked that yestaday ~_^
06:02:24 <jip> _|_kid: no, yesterday i asked the opposite :P
06:02:30 <Heffalump> @type toIntegral
06:02:31 <lambdabot> Not in scope: `toIntegral'
06:02:38 <lightstep> @hoogle Double -> Int
06:02:40 <lambdabot> Text.Regex.Posix.regExtended :: Int
06:02:40 <lambdabot> Text.Regex.Posix.regIgnoreCase :: Int
06:02:40 <lambdabot> Text.Regex.Posix.regNewline :: Int
06:02:46 <lightstep> @type round
06:02:46 <Heffalump> interesting..
06:02:48 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
06:02:51 <ski> @type floor
06:02:52 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
06:02:54 <ski> @type ceil
06:02:56 <lambdabot> Not in scope: `ceil'
06:03:00 <ski> @type ciel
06:03:02 <lambdabot> Not in scope: `ciel'
06:03:06 <xerox> @type round
06:03:08 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
06:03:14 <_|_kid> no comments on my musalings?
06:03:26 <jip> floor seems to work thanks
06:03:32 <ski> @type ceiling
06:03:34 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
06:03:47 <xerox> > [floor,round] `ap` [0.5]
06:03:49 <lambdabot> [0,0]
06:04:00 <xerox> > [floor,round] `ap` [0.4,0.5,0.6]
06:04:01 <ski> OO can mean many things
06:04:02 <lambdabot> [0,0,0,0,0,1]
06:04:16 <ski> xerox : you're starting to like 'ap' :)
06:04:18 <Heffalump> I didn't think MSR were working actively on a .NET backend for GHC.
06:04:27 <xerox> ski: I'm loving it.
06:04:38 <jip> whoah ap is cool
06:04:41 <lightstep> > map floor [0.5, 0.5000001, 0.50000000000000001]
06:04:42 <lambdabot> [0,0,0]
06:04:49 <lightstep> > map round [0.5, 0.5000001, 0.50000000000000001]
06:04:51 <lambdabot> [0,1,0]
06:04:56 * ski has some ideas for syntax extension related to 'ap'
06:04:58 <_|_kid> Heffalump: i don't think it's as active as we believe since there is no info on progress..
06:05:07 <_|_kid> well i can't find any
06:05:07 <xerox> > return floor `ap` [0.5,0.5000001,0.50000000000000001]
06:05:09 <lambdabot> [0,0,0]
06:05:16 <Heffalump> as who believes?
06:05:27 <_|_kid> me and u :P
06:05:31 <Heffalump> the last time I remember someone asking on the list I think Simon PJ said it was dead
06:05:34 <xerox> @pl \f xs -> return f `ap` xs
06:05:35 <lambdabot> fmap
06:05:37 <xerox> heh.
06:05:37 <Heffalump> I didn't think it was active at all.
06:05:47 <xerox> @pl \f xs -> xs >>= return . f
06:05:49 <lambdabot> fmap
06:05:50 <Heffalump> So it could hardly be less active than I believe.
06:05:53 <xerox> Now I know two :-)
06:06:00 <_|_kid> Heffalump: that was a seperate project i believe
06:06:13 <Heffalump> what was?
06:06:30 <_|_kid> Heffalump: the dead project
06:06:53 <Heffalump> separate to what?
06:07:00 <Buggaboo> hi guys, anyone here use vnc on kde?
06:07:06 <_|_kid> Heffalump: the one that MSR are doing
06:07:29 <Buggaboo> I want to allow uninvited remote logins, but can' t find the docs on how to do that.
06:07:32 <_|_kid> Heffalump: a thew different people have taken a stab at it from different angles
06:07:33 <ski> (xerox : would you like to hear (and have time) some of my ideas regarding this syntax ?)
06:07:49 <Buggaboo> argh. wrong channel.
06:07:50 <Heffalump> There was Hugs.NET from somewhere, but that's not GHC.
06:07:52 <Buggaboo> sorry
06:07:53 <xerox> ski: Yes, sure!!
06:07:59 <Buggaboo> btw, hi ski
06:08:02 <xerox> ski: #haskell-overflow?
06:08:02 <ski> #haskell-overflow ?
06:08:06 <ski> Buggaboo : hiya
06:08:11 * ski smiles
06:08:24 <Heffalump> @type `ap`
06:08:24 <_|_kid> Heffalump: read this: http://www.haskell.org//pipermail/haskell-cafe/2005-January/008244.html
06:08:25 <lambdabot> parse error on input ``'
06:08:47 <ski> @type (`ap`)
06:08:48 <lambdabot> parse error on input `)'
06:08:52 <Heffalump> ah, ok.
06:08:56 <Heffalump> anyway, they're all dead, AFAIK.
06:09:24 <xerox> @type Control.Monad.ap
06:09:25 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
06:10:03 <_|_kid> well anyways apart from that, my logical conclusion would be to start it up again, a .NET backend and use OOHaskell for integration between the two
06:10:23 <Heffalump> sure, if you have time :-)
06:11:04 <_|_kid> i don't as of current no :P but i just wanted to express my thoughts and see if this has already been done or thought of
06:11:24 <Heffalump> no idea, ask on the list
06:11:25 <_|_kid> does it sound absurd for instance
06:11:34 <Heffalump> I haven't looked at OOHaskell for ages.
06:11:39 <Heffalump> and I don't really care about .NET
06:11:51 <Heffalump> so I have no particular idea :-)
06:12:16 <Heffalump> I think the cost of threads in .NET is a lot higher than GHC's threads.
06:13:46 <_|_kid> i'm thinking there must be way to map out .NET types to OOHaskell
06:14:08 <_|_kid> although haven't looked at OOHaskell in-depth
06:14:36 <Heffalump> I dunno if it can interoperate well with "real" Haskell, either
06:14:42 <Heffalump> you might just be shifting the problem
06:15:40 <_|_kid> what do you? i thought OOHaskell was just DSEL library
06:15:45 <_|_kid> *do you mean?
06:16:19 <Heffalump> oh, I was confusing it with John Hughes' stuff.
06:16:49 <Heffalump> if it's based on HList, it's probably a not very pleasant hack.
06:18:29 <_|_kid> well i know it has a depedance on HList but i don't enough about either to comment on it's pleasantance ;)
06:19:43 <_|_kid> *pleasant-ness
06:29:25 <jip> anyone familiar with yampa?
06:30:36 <jethr0> jip: no, but how's your tetris going :)
06:30:45 <jip> jethr0: did you see the screenshot?
06:33:35 <Saulzar> jip, Only the usuals I guess, "a bit" :)
06:34:15 <jip> Saulzar: it has all these functions for doing vector math, but it doesn't have cross product.... or does it?
06:36:18 <Saulzar> Hmm, doesn't look like it
06:37:15 <jip> wonder if i should add it to my copy... i've already made some other minor changes
06:38:06 <Saulzar> I guess it's probably easier to maintain a file of stuff you've added, in case you need to update Yampa or distribute it...
06:39:09 <jip> problem is that i've also changed the entire module structure of the yampa code
06:39:35 <jip> and i don't think that yampa is going to be updated anymore :'(
06:42:54 <shapr> dcoutts: That would be awesome :-)
06:43:13 <Saulzar> You never know, seems there's at least one who responds on the mailing list recently
06:43:18 <dcoutts> shapr, I had a sharp zaurus but they never went anywhere
06:43:29 <dcoutts> though hugs ran on it
06:43:33 <Saulzar> and there is a lot of interest in it, after all ... playing around with games is quite popular :)
06:43:55 <shapr> I've wanted a Linux handtop for years, but never been able to afford one until now.
06:43:56 <dcoutts> shapr, the 770 looks like it's got better backing/support
06:44:07 <dcoutts> and it using gtk is great
06:44:20 <dcoutts> it makes it much easeir to code for it
06:44:26 <shapr> Yeah, the #maemo channel is quite active. Several of the original developers are there. I've also met some of the developers on #haskell before :-)
06:44:37 <dcoutts> cool
06:45:41 <ihope> > Data.List.transpose [[1,2,3],[4,5,6],[7,8,9]]
06:45:43 <lambdabot> [[1,4,7],[2,5,8],[3,6,9]]
06:45:54 <ihope> Never thought THAT would be a builtin.
06:45:55 <jip> shapr: now you could afford it because they have gotten cheaper or because you have gotten richer?
06:46:09 <shapr> From what I've heard, the 770 uses a different system than the Palm. The flash loader can't be overwritten, so you can always reflash no matter how much you try to brick the device. This has inspired me to take many more chances with this device. I was never brave enough to try Linux on Palm.
06:46:13 <shapr> jip: Some of both.
06:51:44 <jethr0> jip: sry, was shortly away. yes i say your one-block screenshot and was quite impressed
06:52:13 <jethr0> i'm considering doing sth with yampa myself. can you encourage that from your tetris experience or are you now scarred for life ?-)
06:53:43 <jip> jethr0: it was hard at first but i am slowly starting to get the feel for it. i have now put this tetris on hold and i'm making a 3d car physics demo now
06:54:06 <Saulzar> Skipped the intermediate step? :)
06:54:29 <jethr0> i heard. but isn't there maybe sth yampa-like that is still actively developped?
06:54:45 <jip> jethr0: yampa appears to be pretty much complete
06:55:50 <Philippa_> I wouldn't go that far, last time I talked to Henrik about it there was a lot of work could be done on improving the accuracy for physical sims - better numerical integrators, numerical stability, that kind of stuff
06:56:40 <jip> Philippa_: perhaps. i have decided not to use the continuios parts of yampa anyway though
06:57:10 <SamB> maybe jethr0 means "maintained"?
06:58:56 <jethr0> SamB: well, what's the point of maintaining if you're not changing anything. but it's what i meant :)
06:59:24 <SamB> hmm, after downloading all night, conjure had only five pieces started but unfinished ;-). this is a definate improvement over the behavior before I made it prefer already-started pieces to unstarted ones regardless of rarity
06:59:36 <Heffalump> in practice you need to maintain stuff to avoid bit-rot
06:59:47 <Heffalump> make sure it works with latest compilers, libraries etc
06:59:53 <SamB> jethr0: well, to keep it from bitrottting, of course ;-)
06:59:55 <Heffalump> although in theory things shouldn't change, in practice they do
06:59:56 <Saulzar> Hmm, it's fairly complete for what it does. For simulations it seems a little hairy - inter-object reactions don't seem simple to deal with
07:00:30 <jethr0> hmm, i would have found inter-object reactions a very central problem...
07:00:46 <SamB> for instance, doing something about ^{<<,>>} {<<,>>}^, keeping the build system up-to-date, cabalizing it...
07:01:16 <jethr0> true
07:01:20 <SamB> Heffalump: the theories are bad ;-)
07:01:31 <jip> ...putting it into a darcs repos
07:02:03 <SamB> keeping SpaceInvaders working with the latest HGL...
07:02:10 <SamB> incidentally, SpaceInvaders is *very* slow
07:02:20 <SamB> and quite hard
07:02:30 * jip couldn't even get that shit to compile
07:02:57 <jethr0> if the code of frag weren't so unreadable that would be an interesting yampa "example"
07:03:57 <jethr0> i hope frag's code quality isn't representative of how a complex yampa game looks like :)
07:04:32 <Saulzar> jethr0, Are you looking at the .hs files or the .as files?
07:04:35 <SamB> well, I renamed the .as files to .hs, and then just tried to build with ghc -i../../../src, and fixed things in the source (mostly references to Graphics.HGL.Utils which needed to be changed to just Graphics.HGL) until it built.
07:04:42 <SamB> then it ran ;-)
07:05:10 <SamB> oh, and added -farrows at some point of course
07:05:22 <jethr0> ".hs", but i must have sampled a bad file last time. most of it has indentation of less than 10. so not as bad as i had feared
07:05:23 <psi> i've never been able to run frag
07:05:37 <Saulzar> jethr0, It looked fairly horrific to me until somone mentioned the .hs files are the de-arrowised files output from arrowp
07:05:43 <SamB> someone should also heirarchicalize it...
07:06:06 <jethr0> aha, that might explain some things
07:06:21 <Saulzar> Yeah. The .as files are much better
07:06:43 <SamB> they really shouldn't include the .hs files
07:06:50 <dcoutts> I'm looking for some advice about how haddock's --soruce and --wiki options should work. (I'm hacking on the haddock code atm.)
07:06:54 <SamB> (GHC does know how read all the arrow notation directly, doesn't it?
07:07:04 <SamB> )
07:07:05 <Saulzar> Yeah. But I guess that is new
07:07:17 <dcoutts> at the moment it works like: haddock --source=http://foo.bar/blah/%F
07:07:28 <dcoutts> where %F means the file name, %M means the module name
07:07:31 <dcoutts> except..
07:07:48 <SamB> what is with the extension ".as", anyway?
07:07:52 <dcoutts> that %F means the .hs file name, not the original file name (which might be something else if you used a preprocessor)
07:07:57 <jethr0> i was already wondering how someone could possible write/maintain sth like "ObjectBehavior.hs"
07:08:09 <dcoutts> the %M is the module name with '.' replaced by '/'
07:08:12 <jethr0> i take back my comments about "frag"s unreadability
07:08:28 <Saulzar> jethr0, Yeah, it looks like crazy copy/paste
07:08:35 <dcoutts> so I've been hacing haddock so it knows the *original* file name, not just the .hs name.
07:08:52 <SamB> as mentioned in one of the Makefiles in the afrp tarball (the small yampa tarball), .as doesn't really sound like a kind of Haskell...
07:09:05 <dcoutts> so should I just change the meaning of %F or add a new %? place holder?
07:09:36 <dcoutts> what do people suggest?
07:09:44 <Saulzar> SamB, Hmm, arrow source?
07:09:53 <SamB> should probably be .ahs or just .hs with a {-# LANGUAGE #-} pragma. though of course the latter is a very recent introduction, being a Cabal thing...
07:10:06 <Saulzar> What is .hs anyway? Haskell source?
07:10:27 <dcoutts> Saulzar, "Haskell script" I beleve
07:10:33 <SamB> Saulzar: I assumed it stood for HaSkell ;-)
07:10:55 <jethr0> SamB: where did you get the space invaders source?
07:11:20 <SamB> jethr0: under examples/SpaceInvaders
07:11:29 <jethr0> ah, cool
07:11:39 <SamB> dcoutts: what is %F used for?
07:12:10 <dcoutts> SamB, the name of te .hs file.
07:12:24 <dcoutts> SamB, and I've now tauch haddock to figure out the original filename
07:12:37 <dcoutts> eg if it was a .hs.pp file or .chs file
07:12:45 <SamB> dcoutts: no, I mean for what purpose has it been used thus far?
07:12:54 <SamB> like, in what kind of context is it used?
07:12:56 <dcoutts> for the name of the .hs file
07:13:10 <dcoutts> oh, haddock --source=blah/%F
07:13:22 <dcoutts> it puts links to the source code into each page
07:13:31 <SamB> like, how is used in a sentance?
07:13:46 <dcoutts> SamB, no, it's a command line option
07:14:16 <SamB> oh
07:14:19 <dcoutts> SamB, look here: http://haskell.org/gtk2hs/docs/devel/Graphics-Rendering-Cairo.html
07:14:28 <dcoutts> it's got a link to the source
07:14:34 <SamB> okay
07:14:52 <SamB> so, probably it should point at the real source ;-)
07:17:39 * SamB installs darcs-load-dirs
07:19:48 * SamB wishes his package database was shorter
07:19:54 * SamB wonders how you clean them
07:20:27 * SamB wonders for the nth time why they are in flat text files
07:21:24 <jip> man my yampa 3d car physics demo is running at only 10 fps :(
07:21:55 <Saulzar> What is it doing?
07:22:08 <xerox> 'accidents'
07:22:17 <SamB> I betcha I can get it to run at 1 or less fps
07:22:28 <jip> right now it's just a ball resting on a landscape
07:22:36 <SamB> with no work on my part whatsoever
07:23:04 <jip> hm... ok when i compile with optimizations i get 250 fps
07:23:20 <Saulzar> Heh, slight difference.
07:24:15 <jip> thing is there is this huge data structure that is passed around everywhere... i guess when optimizations are off then ghc actually copies this sucker instead of just a pointer
07:24:35 <Saulzar> Hmm, I don't think so
07:24:51 <Saulzar> It will always be boxed
07:25:07 <jip> that's the only thing i can think of
07:25:17 <jip> even in interactive it will be boxed?
07:25:36 <Saulzar> Yeah
07:26:22 <SamB> huh?
07:26:40 <SamB> wouldn't it especially be boxed in ghci?
07:27:20 <jip> interactive: 10fps, compiled: 35fps, optimized: 250fps
07:27:28 <xerox> :-)
07:28:22 <jethr0> SamB: where did you get the arrow library for compiling spaceInvaders?
07:29:07 <jethr0> compiled it from the Yampa/arrow-0.2-src ?
07:29:15 <Saulzar> You want afrp-0.4
07:29:38 <SamB> arrow library?
07:29:46 <SamB> you mean the one that comes with GHC?
07:29:47 <Saulzar> Don't use arrowp, GHC does that itself - with -farrows
07:30:01 <Saulzar> Just rename all the .as files to .hs and add -farrows to the command line
07:30:42 <jethr0> Saulzar: yes, but make complains about missing "arrowp" command
07:30:46 <jethr0> ah sorry
07:30:47 <Saulzar> I have a fixed version at http://saulzar.orcon.net.nz/afrp-ghc.tar.gz
07:30:55 <jethr0> cool
07:31:03 <Saulzar> Just use ghc --make, the yampa build files are out of date too
07:31:18 <SamB> someone needs to get it into darcs
07:35:15 <dcoutts> yay! my haddock is now generating accurate per-name source code links!
07:35:53 <dcoutts> since of course the module in which a name is documented is not necessarily the same as where it's source code lives
07:36:11 <dcoutts> and I've got it going to the one where the original source it, not where it's exported from
07:36:21 <dcoutts> which is the right thing I think.
07:36:30 * dcoutts is feeling quite pleased with himself.
07:36:38 <SamB> dcoutts: of course
07:40:47 <dcoutts> SamB, actually, counter intuitively it's rather harder to find the original file name of the exporting module
07:41:14 <dcoutts> I guess it's the name of the file that one gets at the end of processing it
07:41:40 <dcoutts> after reading the final {-# LINE 4 "Blah.chs" -#} pragmas
07:41:54 <SamB> dcoutts: if I click on a link to "source code", I *definately* want to see some code for that function ;-)
07:42:11 <dcoutts> indeed, so link to defining rather than exporting is right!
07:42:32 <dcoutts> but at the top level of the module you want the source code for that module
07:42:39 <dcoutts> which is the exportign module
07:42:48 <SamB> ah, yes.
07:42:49 <dcoutts> and that's not so easy to find actually :-)
07:43:08 * dcoutts goes off to poke in the haddock sources some more
07:43:14 <SamB> well, people could find that easily enough themselves anyway ;-)
07:43:41 <SamB> not that it shouldn't be added, just that you don't need to feel that it is absolutely vital
07:45:01 <shapr> Anyone who wants to get an article into the Feb 1st TMR, please talk to me. Feb 1st is the last issue I'll be driving. After that, I'm passing it someone else.
07:45:28 <SamB> I dunno.
07:45:32 <SamB> I probably won't finish mine by then...
07:48:46 <tibbe> I don't want to sound stupid but what's TMR?
07:49:06 <jip> the monad reader?
07:49:28 <xerox> @where TMR
07:49:30 <lambdabot> http://www.haskell.org/tmrwiki/FrontPage
08:05:45 <ihope> What's a good way to implement lists with constant numbers of elements?
08:06:24 <Lemmih> [a]?
08:06:32 <ihope> Specifically, a hexagonal game board with 37 spaces?
08:07:05 <Lemmih> An array, perhaps?
08:08:32 <ihope> Just how do those work?
08:09:45 <SamB> it depends on the array
08:09:54 <SamB> @docs Data.Array.IArray
08:09:55 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array-IArray.
08:09:55 <lambdabot> html
08:10:59 <SamB> personally, I'd probably want to use some kind of coordinates, not an array of 37 elements...
08:11:23 <SamB> @google icfp ants
08:11:25 <lambdabot> http://www.cis.upenn.edu/~plclub/contest/index.php
08:11:28 <ihope> Array of arrays?
08:11:53 <SamB> array with tuples for indices, probably...
08:11:57 <SamB> or something of that nature
08:12:04 <ihope> I guess that'd work.
08:12:23 <SamB> and with extra elements that aren't actually used, probably
08:13:10 <SamB> that page might be of interest WRT hexagonal game grids
08:16:58 <Heffalump> you can use an array with tuples as indices
08:29:36 <astrolabe> ihope: you can map a hexagonal grid onto part of a square one, as in the two forms of the game 'hex'.
08:32:56 <tromp_> what shape is the hexboard?
08:33:47 <tromp_> you shld prolly just complete the shape to a rectangular one, like in the game of hex
08:33:57 <tromp_> which has a straightforward array representation
08:34:44 <tromp_> with neighbours of cell i at i-h,i-h+1,i-1,i+1,i+h-1 and i+h
08:36:16 <tromp_> like astrolabe said:)
08:49:15 <SamK> hi, can someone explain why "const" takes two parameters and only returns the first?
08:49:36 <ndm> SamK - it does nothing useful
08:49:44 <ndm> in the same way that id does nothing useful
08:49:48 <ndm> but its handy to have
08:50:02 <SamK> why not just take one param?
08:50:08 <ndm> that really would be id
08:50:14 <ndm> its useful for transforming functions
08:50:44 <SamB> SamK: taking the second param is the whole point
08:50:58 <ndm> imagine you have a list of booleans
08:51:13 <ndm> and a function to combine two booleans, which reduces an entire list to a single element
08:51:18 <ndm> (this is called a fold)
08:51:31 <ndm> you might want to take the and of all these elements, then you could pass (&&)
08:51:46 <ndm> but if you just want the very last one, you could pass const, and get it that way
08:51:58 <SamK> ah, I see
08:52:25 <ndm> its like id - it doesn't do anything useful itself, but its handy to have around
08:52:30 <SamK> because fold is expecting two arguments
08:52:38 <ndm> indeed, and you only want one
08:53:20 <ndm> you could also pass (not . const), which is a way of transforming the function to get one single argument for not
08:54:05 <SamK> but presumably, you would use another method in that example, but I get the point, another usefull tool
08:54:24 <dcoutts> SamB, wee, fixed up the module level source code links too. It was just a matter of attaching a source code location to the module header and then extracting that info again later.
08:54:31 <ndm> SamK - sometimes these "ridiculous solutions" in haskell are quite nice
08:54:40 <dcoutts> so now we've got accurate haddock source code links! :-)
08:54:46 <ndm> for example, minimum = head . sort
08:55:11 <ndm> dcoutts, so you're hacking haddock now are you ?
08:55:11 <Philippa_> is that what it actually uses? Only that's got crap complexity
08:55:19 <dcoutts> ndm, yep
08:55:34 <ndm> dcoutts, how hard would it be to add a new backend for haddock?
08:55:37 <dcoutts> ndm, I wanted wiki & source code links in out api docs.
08:55:42 <ndm> either XML or Hoogle output would be nice :)
08:55:49 <dcoutts> ndm, hmm, I don't think it's that easy.
08:55:57 <ndm> i looked at haddock a bit, but it looked quite painful
08:56:04 <dcoutts> haddock is not the greatest structured things
08:56:06 <ndm> which is why hoogle just reparses haddocks HTML
08:56:18 <dcoutts> the html output module is pretty big
08:56:29 <ndm> yes, and it seemed to do all the clever work...
08:56:48 <dcoutts> hmm, actually maybe it's not that bad...
08:56:58 <dcoutts> the html pretty printer just exports a few functions
08:57:06 <dcoutts> they could be made into a record
08:57:15 <ndm> ah, ok
08:57:21 <dcoutts> and then the Main.hs could use the record rather than the ppHtml funcs directly
08:57:25 <ndm> i was looking at it from an other point of view
08:57:33 <ndm> that might work quite well
08:57:42 <ndm> the idea design would be (in my thoughts)
08:57:52 <ndm> return a data structure, that is all the information
08:57:57 <ndm> then pass that to each of the back ends
08:58:06 <dcoutts> that's sort of what happens
08:58:20 <ndm> but the data structure is a whole haskell syntax tree
08:58:32 <ndm> i was hoping for something a bit more concise :)
08:58:37 <dcoutts> it's slightly better than that
08:58:47 <dcoutts> it gets a list of interfaces
08:59:01 <dcoutts> which are lists of exported entities
08:59:30 <ndm> ok, but still a lot of work inside the back end
08:59:42 <ndm> but changing the output functions, that is neat
09:00:19 <dcoutts> yeah, there is still quite a bit done in the backend
09:00:40 <dcoutts> the html backend (whcih does support several html index formats) is 1200 lines long
09:01:29 <dcoutts> ndm, what kind of backend do you want?
09:01:39 <ndm> i only tried to start work on it, bvut there is no hugs support so i gave up
09:02:06 <dcoutts> you want to run haddock with hugs?
09:02:20 <dcoutts> it uses cabal now so it should be easier
09:02:38 <dcoutts> you might have to remove some patter gaurds if hugs does not support that
09:02:52 <dcoutts> it doesn't look very ghc-specific from what I could see
09:03:08 <ndm> dcoutts, http://www.haskell.org/hoogle/res/hoogle.txt
09:03:11 <ndm> thats my back end
09:03:26 <ndm> from what i remember, fast mutable integers were making it a bit hard in hugs
09:03:37 <dcoutts> ndm, oh the binary serialisation
09:03:40 <dcoutts> hmm
09:04:00 <dcoutts> does hugs have a working binary module?
09:04:33 <dcoutts> ndm, I'd think you could write a much smaller backend than the html one to produce that hoogle output.
09:04:56 <ndm> dcoutts, no idea on the binary module
09:05:09 <ndm> and i guess a hoogle back end would be a lot shorter, but still quite a bit of work
09:05:19 <dcoutts> ndm, wel if you just want to hack haddock up, you can remove the binary serialisation features
09:05:41 <dcoutts> then it wouldn't read/write the .haddock interface files but that mgiht be ok
09:05:53 <ndm> ok, i might one day in the future
09:06:07 <ndm> but hoogle limps along for now, so have to move on to new things
09:06:39 <dcoutts> Yhc!
09:06:54 <ndm> Indeed, am rewriting the Prelude right now :)
09:07:38 <Lemmih> Hiya lscd.
09:07:41 <ndm> and also am writing Catch, case and termination checker for haskell
09:07:44 <lscd> hi Lemmih 
09:08:56 <dcoutts> ndm, termination? you should talk to a chap in my group who's working on that.
09:09:08 <ndm> dcoutts, who?
09:09:09 <dcoutts> for strict and lazy higher order functinal languages
09:09:20 <ndm> i'm just doing lazy termination
09:09:46 <dcoutts> ndm, http://progtools.comlab.ox.ac.uk/members/damien
09:09:54 <dcoutts> http://progtools.comlab.ox.ac.uk/members/damien/research
09:10:03 <ndm> dcoutts, yes, Bruno mentioned him to me in the past
09:10:18 <dcoutts> "size change termination"
09:10:53 <dcoutts> it seems to work somewhat but it's very computationally expensive
09:11:00 <ndm> dcoutts, yes - i have read the original work on that - my method is totally different
09:11:11 <ndm> no notion of sizes at all
09:12:49 <dcoutts> interesting
09:17:16 <fatbrain> win32 haskell implmementation, which should one use?
09:17:29 <ndm> WinHugs!
09:17:31 <ndm> @where winhugs
09:17:33 <lambdabot> http://www.cs.york.ac.uk/~ndm/projects/winhugs.php
09:18:17 <tromp_> funny to have SamK (close to S and K) asking about why const is useful:)
09:18:20 <ndm> fatbrain, WinHugs is really nice and easy to use, GHCi is faster at running, much slower at compiling, less friendly, more bizare haskell extensions
09:18:21 <fatbrain> does that come with, like an IDE n all?
09:18:35 <ndm> fatbrian, follow the link, see the screenshot
09:18:49 <ndm> its not an IDE, but its got some ide like features
09:18:50 <fatbrain> yeah, I noticed some GUI crap on the screenie so I guess there's an IDE
09:19:00 <ndm> fatbrain: not a GUI fan?
09:19:05 <fatbrain> yeah, I already have a text-editor
09:19:05 <fatbrain> no
09:19:13 <fatbrain> will it work with whatever editor?
09:19:15 <ndm> yes
09:19:21 <fatbrain> great
09:19:22 <ndm> fatbrain: which is your editor of choice?
09:19:31 <fatbrain> GHCi felt so 1999... :P
09:19:34 <fatbrain> emacs
09:19:52 <fatbrain> I have that and ofcourse SciTE
09:19:53 <ndm> it has 100% integration with some editors, but configuring a new one is a few seconds work
09:20:17 <fatbrain> ok
09:20:19 <ndm> but if you give me the details, i'll add Emacs to the compiled code, and then it will auto-detect and configure itself for emacs
09:20:43 <ndm> the only thing editor integration gets you is click on an error, jump to file and source code position
09:21:35 <fatbrain> yeah, and that I can live without
09:21:51 <fatbrain> so, were we talking about GHCi or WinHugs?
09:21:55 <ndm> wait til you try it - i certainly couldn't live without it again
09:22:07 <ndm> WinHugs comes with Hugs as well, a command line version, which might suit you more
09:22:23 <ndm> but yes, GHC, GHCi, Hugs, WinHugs are pretty much the main choices
09:22:31 <ndm> Yhc is still too unstable and immature, sadly
09:22:55 <Muad_Dibler> Yhc being?
09:23:02 <ndm> your choices are fast compliation (Hugs), or fast execution (Ghc)
09:23:05 <ndm> @where Yhc
09:23:06 <lambdabot> http://www.cs.york.ac.uk/~ndm/yhc
09:23:17 <Muad_Dibler> the york haskell compiler i'd guess now ;)
09:23:18 <ndm> Muad_Dibler: think nhc98 v2
09:23:43 <ndm> but with a pile of other goodies thrown in
09:24:02 <Muad_Dibler> you one of those ex-students?
09:24:10 <ndm> no, i'm a current student
09:24:18 <ndm> its 2 current students, 1 ex-student
09:24:58 <Muad_Dibler> ah
09:25:02 <Muad_Dibler> :)
09:25:30 <fatbrain> @where ghc
09:25:32 <lambdabot> http://haskell.org/ghc
09:27:20 <ndm> fatbrain: if you are getting hugs/winhugs, get them from the link i gave you - not the official one - since the official ones are over 2 years old
09:27:56 <fatbrain> hm, that may explain the 18th sentury look my last winhugs installation had.
09:28:19 <ndm> indeed, i rewrote it from scratch to give the new winhugs
09:28:30 <ndm> the old one was written for Win 3.1
09:30:33 <fatbrain> great :) thanks
09:41:09 <SamB> 18th century? just think how bad it must have looked on the real 3.1!
09:41:39 <ndm> SamB, probablly identical, they wrote all their own controls from scratch
09:41:50 <SamB> oh?
09:41:59 <ndm> i.e. the toolbar, status bar, rich text window are all custom written - not the standard windows one
09:42:17 <ndm> indeed, not a very good idea, but looked prettier at the time, i guess
09:42:39 <SamB> well, with the way the standard ones looked, I can understand... though wasn't there some generally available library for 3d controls?
09:43:27 <eivuokko> Common controlds 3d wasn't something everybody got, iirc.
09:43:36 <SamB> oh.
09:43:52 <eivuokko> I think it was (somehow) tied to those win32 on 3.1 thingies
09:44:03 <eivuokko> But it's a bit hazy on my memory...
09:45:54 <SamB> 3.1 is freaky
09:46:00 <Saulzar> Wow, that's a while ago.
09:48:26 <Saulzar> When netscape took 10 minutes to start :)
09:56:21 <fatbrain> and where should I go if I want the quickstart of Haskell?
09:57:14 <Saulzar> @where YAHT
09:57:15 <lambdabot> http://www.isi.edu/%7Ehdaume/htut/
09:57:28 <philip> go to haskell.orh and read the 'gentle intro'
09:57:31 <Saulzar> This tutorial is pretty good
10:03:04 <fatbrain> thanks
10:10:57 * SamB thinks maxima ought to have a worksheet interface
10:34:00 <cajole> <dcoutts> indeed, so link to defining rather than exporting is right!
10:34:00 <cajole> <dcoutts> but at the top level of the module you want the source code for that
10:34:00 <cajole>           module
10:34:00 <cajole> <dcoutts> which is the exportign module
10:34:00 <cajole> <SamB> ah, yes.
10:34:01 <cajole> <dcoutts> and that's not so easy to find actually :-)
10:34:02 <cajole> ð dcoutts/#haskell goes off to poke in the haddock sources some more
10:34:04 <cajole> <SamB> well, people could find that easily enough themselves anyway ;-)
10:41:40 <Lemmih> Hurrah for Haskell'.
10:43:30 <Muad_Dibler> Yay!
10:51:10 <araujo> Hello!
10:51:15 <araujo> Hurray!
11:10:58 <fatbrain> > map toUpper "bleh"
11:11:00 <lambdabot> "BLEH"
11:11:06 <fatbrain> Undefined variable "toUpper"
11:11:21 <fatbrain> >map toUpper "moo"
11:11:30 <fatbrain> > map toUpper "moo"
11:11:32 <lambdabot> "MOO"
11:11:35 <xerox> > map Char.toUpper "cook-a-doodle-doo"
11:11:36 <fatbrain> ohh... interesting
11:11:37 <lambdabot> "COOK-A-DOODLE-DOO"
11:11:49 <fatbrain> I tried that in Hugs got the undefined error message :(
11:11:56 <xerox> fatbrain: import the Char module.
11:12:17 <xerox> fatbrain: you can find where the functions you're looking for are with lambdabot's @index command.
11:12:20 <xerox> @index toUpper
11:12:21 <lambdabot> Data.Char
11:12:40 <xerox> I think it's GHC-biased, but works for Hugs too in the most cases.
11:14:10 <fatbrain> tanks
11:39:01 <tibbe> I want to write a lambda calculus compiler, will I need a GC for the runtime system?
11:39:08 <tibbe> for closures etc?
11:39:24 <SamB> only if you want to collect the memory ;-)
11:40:19 <lispy> i wonder, could you write the lambda calculator as an eDSL in haskell and then compile that? at least initially?
11:40:50 <lispy> but, that might take all the fun, challenge and learning out of such a project
11:40:52 <tibbe> SamB, lets assume I do ;)
11:41:36 <tibbe> C-- looks promising as an intermediate language
11:42:11 <tibbe> with tail call support and a small run time that can in implementing a GC (stack inspection, etc)
11:46:34 <SamB> why do you want to go to all this trouble for *lambda calculus*?
11:46:51 <SamB> and how do you run lambda calculus programs, anyway?
11:47:41 <SamB> I suppose you could do it like Lazy K
11:55:07 <tibbe> SamB, so it's a language that is implemented by using only lambdas plus a few arithmetic ops
11:55:18 <SamB> ah
11:55:26 <tibbe> SamB, think haskell with only regular, simple functions (and closures
11:55:53 <tibbe> but if I can do it (GC) with lambda calculus...
11:56:11 <tibbe> http://www.itstud.chalmers.se/~larssont/Main.hs
11:56:31 <tibbe> that's the bare minimum
12:40:42 <roconnor> what's the best way of spliting a string into a list of strings where tokens are separated by commas?
12:41:24 <roconnor> sort of like strtok(), but not sucky
12:44:15 <Heffalump> I would probably just write a simple recursive function
12:44:26 <roconnor> :-/ okay
12:44:54 <Heffalump> @type break
12:44:56 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
12:45:06 <Heffalump> I think you could probably also use iterate and break.
12:45:16 <xerox> Yeah.
12:45:19 <xerox> and takeWhile.
12:45:20 <Heffalump> but I don't think it's worth the hassle of figuring out how, TBH
12:45:22 <xerox> @type break
12:45:24 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
12:45:29 <xerox> @type splitAt
12:45:31 <lambdabot> forall a. Int -> [a] -> ([a], [a])
12:45:59 <Heffalump> splitAt uses a position, roconnor needs to use a character
12:46:16 <Heffalump> > break (==',') "foo,bar,baz"
12:46:18 <lambdabot> ("foo",",bar,baz")
12:46:30 <roconnor> I'll cut and paste the code for lines and words
12:47:01 <roconnor> lines  is closer to what I want
12:47:15 <tibbe> @type lines
12:47:16 <lambdabot> String -> [String]
12:47:41 <tibbe> > lines "foo\nbar"
12:47:43 <lambdabot> ["foo","bar"]
12:48:42 <gzl> it's a little odd that this isn't in the List module
12:52:38 <xerox> break leaves the glue-char appeneded to the rest, hmpf.
12:52:47 <dcoutts> oh yeah, I've got haddock producing accurate source code links, for everything!
12:52:48 <dcoutts> http://haskell.org/gtk2hs/docs/devel/
12:53:11 <xerox> Idea.
12:53:22 <dcoutts> (actualyl some are not accurate in that example, but that's the fault of c2hs, not haddock. I'm about to go fix c2hs)
12:53:29 <SamB> @hoogle (a -> Bool) -> [a] -> [[a]]
12:53:31 <lambdabot> No matches, try a more general search
12:53:41 <dcoutts> c2hs doesn't preserve the name if the original file was .chs.pp
12:53:48 <SamB> @hoogle (a -> a -> Bool) -> [a] -> [[a]]
12:53:49 <dcoutts> but appart from that...
12:53:49 <lambdabot> Data.List.groupBy :: (a -> a -> Bool) -> [a] -> [[a]]
12:53:59 <dcoutts> xerox, take a look! :-)
12:54:06 <dcoutts> http://haskell.org/gtk2hs/docs/devel/Graphics-Rendering-Cairo-SVG.html
12:54:24 <dcoutts> source links! :-)
12:54:28 <xerox> Source code links?!?!
12:54:30 <xerox> Wooo!!!
12:54:32 <Cale> dcoutts: very nice :)
12:54:40 <dcoutts> with useful anchors too, in case one has html versions of your code
12:54:54 <xerox> @karma+ dcoutts -- yay!
12:54:55 <lambdabot> dcoutts's karma raised to 7.
12:54:56 <TFK> Is there any simple implementation of Conway's Game of Life in Haskell avaliable on the net?
12:55:09 <dcoutts> eg: the svgRender link is:
12:55:10 <dcoutts> http://darcs.haskell.org/gtk2hs/svgcairo/Graphics/Rendering/Cairo/SVG.chs#svgRender
12:55:22 <roconnor> dcoutts yay!
12:55:43 <dcoutts> so if one had a syntax colouriser thingy that produced html with anchors for each export then we could link directly to them
12:55:56 <dcoutts> the actual URL format is customisable with variable expansions
12:56:14 <dcoutts> %F, %M etc
12:56:14 <SamB> @google "Life.hs"
12:56:17 <lambdabot> http://www.jfks.de/index.php?id=450
12:56:27 <xerox> > groupBy (const (/=',')) "ab,cdef,g"
12:56:29 <lambdabot> ["ab",",cdef",",g"]
12:56:32 <xerox> Somehow...
12:57:12 <roconnor> :-/
12:57:25 <xerox> > let split = map (drop 1) . groupBy (const (/=',')) . (',':) in split "ab,cdef,g"
12:57:27 <lambdabot> ["ab","cdef","g"]
12:57:31 <xerox> :-)
12:57:34 <roconnor> (const (/=',')) isn't really an equivalence relation is it?
12:58:08 <xerox> > let split = map (drop 1) . groupBy (const (/=',')) . (',':) in split ",a,bc,"
12:58:09 <lambdabot> ["","a","bc",""]
12:58:39 <xerox> Check for unespected ',' and that functions could be good enough.
12:59:16 <Cale> http://www.eldamar.org.uk/haskell/life.hs
13:00:14 <Cale> I'm sure there are others
13:00:24 <SamB> tried MissingH?
13:00:41 <SamB> TFK: there's your Game of Life, I guess
13:01:05 <TFK> SamB, erm, it doesn't work.
13:01:10 <TFK> But thanks for trying :-)
13:01:23 <tibbe> Haskell uses C for compilation right?
13:01:39 <Cale> tibbe: optionally
13:01:46 <Cale> GHC can compile via C
13:01:55 <Cale> or directly to native code
13:02:05 <tibbe> Cale, but it always does right, just hides it if you don't want to see the actual C code?
13:02:09 <tibbe> ah
13:02:10 <Cale> no
13:02:16 <SamB> boy, these original Lemmings tunes sound neat ;-)
13:02:34 <tibbe> I'm trying to find a language to compile my language to
13:02:52 <Cale> compile to Haskell :)
13:02:52 <tibbe> and I don't want to generate #"%!#%!%!# x86 assembler
13:03:23 <SamB> tibbe: GHC can
13:03:26 <Cale> there's C--, I'm not sure how complete it is
13:03:28 <tibbe> I feel haskell supports many things my language doesn't need and so create inefficiencies
13:04:06 <tromp> @type ap
13:04:07 <tibbe> Cale, I've just read the C-- spec but I can't find anyone (by Googling) who actually uses it which makes me a bit unsure
13:04:07 <lambdabot> Not in scope: `ap'
13:04:22 <xerox> @type (Control.Monad.ap)
13:04:23 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
13:04:37 <tromp> thx:)
13:04:43 <xerox> :))
13:04:46 <Cale> tibbe: well, I think the plan is eventually to get GHC using it -- I'm not sure, but seeing as Simon PJ is involved with both, it would be plausible :)
13:05:29 <tibbe> Cale, I just don't want to have to rewrite everything from scratch if the word "discontinued" appears on their site one day
13:05:57 <tibbe> and I guess the number of users matters to me since I'm not too good with this low level stuff
13:06:11 <Cale> oh, you should definitely have some useful intermediate language.
13:06:15 <tibbe> (i.e. writing a garbage collector and interfacing it with C--)
13:06:23 <Cale> What sort of language is this?
13:06:38 <tibbe> strict side-effect free functional
13:06:42 <tibbe> with closures
13:07:13 <tibbe> the minimal version (without any ops, lists, etc) is half a page of haskell, including the interpreter
13:07:27 <tibbe> but I want to solve the problem with compilation before moving on
13:08:16 <SamB> tibbe: maybe you should just write a C-- compiler ;-)
13:08:52 <SamB> if you write one in Haskell, it will make C-- more accessible
13:09:10 <tibbe> I think I could generate C-- without much trouble
13:09:14 <tibbe> but the GC...
13:09:57 <tibbe> I probably need to do some analysis on my AST as well to decide which variables need to be on the heap
13:10:23 <ibid> "functional with closures" is a little redundant, is it not? :)
13:10:24 <SamB> how hard is it to write a simple copying GC?
13:10:34 <ibid> good GC is har
13:10:35 <ibid> +d
13:10:42 <ibid> bad GC is easy
13:10:49 <SamB> and variables don't need to be on the heap, closures do ;-)
13:11:03 <jip> @where c--
13:11:04 <lambdabot> I know nothing about c--.
13:11:15 <Heffalump> www.cminusminus.org
13:11:26 <xerox> @google c--
13:11:28 <lambdabot> http://www.c-span.org/
13:11:41 <ibid> especially considering that GC has a huge impact on the responsiveness of the compiled code
13:11:51 <tibbe> ibid, perhaps, but one day I might add mutable state and that'll complicate things
13:11:59 <SamB> @where+ c-- www.cminusminus.org
13:12:00 <lambdabot> Done.
13:12:15 <tibbe> SamB, enclosed variables need to be on the heap right? :)
13:12:22 <ibid> tibbe: not always
13:12:45 <ibid> tibbe: only if the inner function outlives the creating outer AR
13:12:46 <Cale> tibbe: you should use monadic IO and State -- it would be neat to have a strict language with monadic features.
13:12:51 <tibbe> ibid, I guess that func langs use some generational GC?
13:13:08 <ibid> tibbe: functional language *implementations* frequently do
13:13:13 <ibid> tibbe: languages rarely specify the type
13:13:26 <ibid> (though generational fits well with the paradigm)
13:13:31 <tibbe> Cale, I'll use State/IO in the implementation
13:13:45 <tibbe> ibid, that's what I meant
13:14:01 <jip> are there c-- bindings for haskell?
13:14:22 <Cale> tibbe: I mean, if you're adding IO and such to your language, it would be cool to see a strict functional language which uses monads for IO.
13:14:28 <ibid> tibbe: sorry, that's one of my pet peeves (mixing up languages and implementations)
13:14:44 <tibbe> ibid, I guess I need to do some sort of static analysis to see what functions escape with "closed" variables and allocate those on the heap and the rest on the stack?
13:14:57 <ibid> tibbe: that's a useful optimization
13:15:07 <ibid> tibbe: heap allocation is simpler and safe
13:15:09 <tibbe> Cale, it would
13:15:49 <ibid> some form of region inference would probably help here
13:15:53 <tromp> it seems the official library docs are incomplete
13:15:55 <tibbe> ibid, yeah, if I could just start with a super simple GC and then make it work and make it better later
13:16:06 <Cale> tromp: no kidding? :)
13:16:25 <ibid> tibbe: that's a good plan
13:16:28 <Cale> tromp: which library are you interested in?
13:16:39 <ibid> tibbe: in general, also. make it work, then make it fast. not the other way around :)
13:16:40 <tibbe> ibid, I go look for a simple copy collector
13:16:43 <tromp> was looking for asks in Control.Monad.Reader
13:16:56 <ibid> tibbe: you might even want to consider using the boehm collector at first
13:17:04 <tibbe> ibid, simplet?
13:17:13 <tibbe> ibid, s/simplet/simpler
13:17:23 <Cale> tromp: it's listed, but what it does isn't mentioned
13:17:40 <tibbe> tibbe, oh, that's an already existing GC right?
13:18:05 <ibid> tibbe: virtually "plug-and-play", if you use C-compatible conventions or compile through C
13:18:10 <tibbe> ibid, now I'm talking with myself, great
13:18:39 <tibbe> ibid, then nice thing with compiling through C-- is that I get tail calls for free
13:19:00 <ibid> tibbe: sure
13:19:43 <tibbe> ibid, I've read that there has been some successful attempts at hacking tail calls into C but that they were fragile and used lots of gcc specifics
13:19:45 <ibid> tibbe: the boehm collector is fairly good. not as good as a specially crafted GC would be (because the latter can work with the compiler) but it's certainly a lot better than anything simple you can make yourself
13:19:55 <SamB> you could just jump off the empire state building every so often ;-)
13:20:11 <tromp> ah, right. missed that:(
13:20:24 <ibid> tibbe: i heard that recent GCCs are a lot better at recognising tail calls
13:20:37 <SamB> anything simple, really
13:21:02 <tibbe> ibid, so GCC actually does tail call optimizations for C?
13:21:26 <ibid> tibbe: it's done it to some extent for ages. i hear it's better at it nowadays
13:21:37 <ibid> tibbe: you will want to examine the code it generates yourself, though
13:21:46 <tibbe> ibid, xD
13:22:47 <ibid> btw, if you ignore floating-point, x86 isn't that bad a target until you start thinking about a powerfully optimizing compiler
13:23:00 <ibid> x86 fp sucks
13:24:12 <tibbe> I'm just looking for the simples possible solution atm, sounds like I should 1) generate C 2) with only heap vars 3) and use the boehm gc
13:24:16 <jip> does c-- do floating point?
13:24:23 <tibbe> jip, yes
13:24:26 <SamB> eh, powerful optimizations are still doable...
13:24:54 <ibid> tibbe: simplest is to make up an intermediate language which you interpret
13:25:05 <SamB> its just that you want to leave the instruction generation to something good at that sort of thing, often...
13:25:07 <jip> cool, does c-- do simd optimizations?
13:25:48 <ibid> SamB: sure, but x86 the hedgehog starts showing its thorns then
13:25:53 <tibbe> ibid, I've already written an interpreter for my language in haskell
13:26:12 <tibbe> jip, dunno
13:26:14 <tromp> you cld compile to combinators
13:26:16 <SamB> ibid: intermediate language? that language sounds almost like an IR already
13:26:16 <tibbe> jip, read the spec ;)
13:26:41 <ibid> instruction generation isn't the problem (modern x86 on-chip optimization makes doing that pointless beyond a point), it's the small register file that's the big problem
13:27:14 <SamB> jip: C-- doesn't *do* anything, except tell you what you can and can't do in it, and how an implementation can and can't behave...
13:27:15 <tibbe> SamB, I can express most advanced constructs in it or implement the "on the side", I want to study how to generate native code first before I add more complexity
13:28:40 <jip> SamB: ok but is it designed in such a way so that it's not fiendishly difficult for implementations to do simd optimizations?
13:30:49 <tibbe> SamB, the reason I'm doing this is that I'm taking a programming languages code and implementing a small interpreted imperative language in haskell (which we are supposed to do) is both boring and easy
13:31:21 <SamB> ibid: what about cache stuff?
13:31:29 <SamB> besides, I have a PII ;-)
13:31:43 <SamB> jip: no clue!
13:32:20 <SamB> tibbe: s/code/class/?
13:32:39 <tibbe> SamB, *laughs* yes
13:33:18 <tibbe> SamB, perhaps you can guess what type of material I've been reading the last couple of says ;)
13:33:43 <tibbe> SamB, head full of code
13:34:05 <palomer> peyton-jones wrote a paper on generating native code from lambda terms
13:34:31 <tibbe> palomer, they did? remember the name? did they just generate assembler?
13:36:23 <SamB> peyton-jones is a "he", not a "they"
13:36:34 <SamB> Simon by name
13:37:09 <SamB> @google simonpj
13:37:11 <lambdabot> http://research.microsoft.com/Users/simonpj/
13:37:19 <palomer> his book may also address the subject
13:38:18 <tibbe> palomer, I'm reading it now, it's kinda longish
13:38:40 <palomer> I forget the name of the paper
13:38:54 <palomer> my god the man is prolific
13:39:04 <tibbe> "Implementing Functial Languages" is the book, although so I've only read about an interpreter in Miranda
13:39:25 <palomer> I've written a lambda calculus interpreter with let bindings
13:39:30 <palomer> and type inference
13:39:31 <palomer> it's fun
13:39:35 <xerox> Yay.
13:39:45 <palomer> all you need is beta reduction
13:39:52 <palomer> and the Y combinator
13:40:52 <tibbe> palomer, let x = y in z   ==>   (\x. z) y   right?
13:41:02 <palomer> tibbe: not in haskell
13:41:08 <tibbe> palomer, but I would love to see the code?
13:41:33 <tibbe> palomer, s/?/!
13:42:01 <palomer> let a = b in c ==> (\a -> c) (Y (\a->b))
13:42:42 <tromp> that's if a occurs free in c
13:42:42 <palomer> well, almost
13:42:52 <tromp> i mean in b
13:42:53 <Cale> dons: are you about?
13:42:54 <palomer> tromp: that's always.
13:43:16 <tromp> if a doesn't occur in b, then tibbe's translation works
13:44:21 <palomer> yes, but without recursion your language is pretty useless
13:44:35 <tromp> Y(\a->b) = (\a->b)(Y(\a->b)) = b in that case
13:44:37 <tibbe> I must admit I've never taken any courses on lambda calculus so I've just repeating bits and pieces I've read
13:44:42 <palomer> heck, all terms are strongly normalizable
13:45:02 <tibbe> what does the Y combinator do?
13:45:10 <palomer> Y a = a (Y a)
13:45:33 <xerox> fix f = f (fix f) ?
13:45:36 <palomer> it unwinds the recursive definition
13:45:48 <palomer> Y is very similar to fix
13:46:01 <tromp> it's the same
13:46:09 <tibbe> you see, you can't define it in yet another concept I don't understand ;)
13:46:27 <palomer> well, no, since fix and Y have different definitions
13:47:12 <tromp> fix is defined as fix f = f(fix f)
13:47:13 <palomer> say you have fac n = if n == 0 then 1 else n*(fac n-1)
13:47:33 <tromp> you can define Y the same way:)
13:47:49 <palomer> ok, now beta reduce (Y (\fac -> \n -> if n == 0 then 1 else n*(fac (n-1))))
13:48:18 <roconnor> anyone know an easy way to convert an iso-latin-1 file to a utf-8 file?
13:48:45 <xerox> Ask Emacs?
13:49:23 <palomer> tromp: Y is \xf-> ((\x -> (f x x)) (\x -> (f x x)))
13:49:44 <palomer> s/\xf\\f
13:49:46 <chucky> roconnor: open it in a utf-8 aware editor, and re-save it as utf-8?
13:49:51 <tromp> that's a possible nonrecursive definition
13:49:58 <palomer> no. That's Y
13:50:10 <chucky> (gedit can do it by using the "save as" menu item, if you're on linux)
13:52:53 <tromp> palomer, that gives   n -> if n == 0 then 1 else n*(fac' (n-1))
13:53:13 <tromp> where fac' is what i started with
13:53:22 <palomer> right
13:53:35 <palomer> and then you unwind it again
13:53:37 <palomer> and again...
13:53:53 <tromp> not in head normal reduction
13:54:44 <palomer> I'm trying to show to what it's equivalent
13:54:47 <palomer> I'm not evaluating it
13:55:06 <tromp> ok, it's equivalent to an infinite expansion
13:55:15 <tromp> same for fix
13:55:35 <palomer> the question was educational, and was for tibbe
13:55:48 <palomer> I'll agree that Y and fix are equivalent under certain reduction rules
13:55:51 <palomer> but they're not the same
13:56:48 <tromp> well, give me a function that distinguishes them
13:57:03 <tromp> where f Y = False and f fix = True
13:57:13 <tromp> then i'll agree they're different
13:57:58 <tromp> or where one is undefined and the other isn't
13:59:59 <roconnor> does file IO read files as utf-8 files?
14:00:37 <palomer> @type \f-> (\x -> f (x x)) (\x -> f (x x))
14:00:38 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
14:00:38 <lambdabot>   Expected type: t
14:00:48 <palomer> now do you agree that they're different?
14:01:47 <tromp> that definition is for the untyped lambda calculus
14:02:12 <palomer> Y has one definition
14:02:16 <palomer> anything else isn't Y
14:02:26 <ihope> Is there a definition of fix for the simply typed lambda calculus?
14:02:36 <tromp> different ppl use different definitions
14:02:38 <palomer> ihope: nope
14:03:01 <tromp> you'll find many places that define Y f = f (Y f)
14:03:03 <palomer> tromp: you're free to invent your own definitions
14:03:32 <palomer> there are many terms that satisfy that equation
14:03:45 <tromp> still, it\s a definition
14:04:35 <palomer> ok, show me a sane source that defines Y that way
14:05:43 <ihope> Which way?
14:05:51 <palomer> Y f = f (Y f)
14:06:13 <ihope> Well, that is a perfectly fine fixed-point function...
14:06:35 <palomer> ihope: Y usually refers to a specific lambda term
14:06:46 <palomer> a specific fixed point operator
14:06:51 <ihope> How about fix \y x -> x (y x)? :-P
14:07:06 <ihope> Not lambda enough...
14:07:14 <palomer> @type fix 
14:07:16 <lambdabot> Not in scope: `fix'
14:07:19 <palomer> @hoogle fix
14:07:21 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
14:07:21 <lambdabot> Graphics.UI.ObjectIO.StdIOCommon.Fix :: ItemLoc
14:07:21 <lambdabot> Control.Monad.ST.Lazy.fixST :: (a -> ST s a) -> ST s a
14:07:29 <tromp> i found http://ycombinator.com/ but that didn't help:(
14:07:46 <palomer> @type (Control.Monad.Fix.fix) (\y x -> x (y x))
14:07:48 <lambdabot> forall t. (t -> t) -> t
14:08:06 <palomer> let fpc =  (Control.Monad.Fix.fix) (\y x -> x (y x)) in fpc (\x -> x)
14:08:21 <palomer> > let fpc =  (Control.Monad.Fix.fix) (\y x -> x (y x)) in fpc (\x -> x)
14:08:21 <ihope> tromp: heh.
14:08:22 <lambdabot> Add a type signature
14:08:52 <palomer> > let fpc =  (Control.Monad.Fix.fix) (\y x -> x (y x)) in fpc ((\x -> x)::forall a. a-> a)
14:08:53 <ihope> @type Control.Monad.Fix.fix \fix x -> x (fix x)
14:08:53 <lambdabot>  a
14:08:53 <lambdabot>   Inferred type: . (forall a) a
14:08:53 <lambdabot>   In a lambda abstraction: \ x -> x
14:08:55 <lambdabot> parse error on input `\'
14:09:21 <palomer> > let fpc =  (Control.Monad.Fix.fix) (\y x -> x (y x)) in fpc ((\x -> x)::(forall a. a-> a))
14:09:22 <lambdabot>  a
14:09:22 <lambdabot>   Inferred type: . (forall a) a
14:09:22 <lambdabot>   In a lambda abstraction: \ x -> x
14:09:50 <palomer> anyways, I'm off
14:13:41 <palomer> what's lambdabot going on about?
14:13:43 <palomer> is that an error?
14:14:01 * SamB had no idea WizARC used info-zip internally
14:16:57 <araujo> Haskell'!!!
14:17:25 <jyp> yeah
14:18:09 <jyp> It's very exiting to be part of the haskell community these days :)
14:18:17 <fatbrain> how do I import Char in Hugs?
14:18:17 <rep> why?
14:18:33 <jyp> Haskell' !!!
14:18:36 <jyp> :)
14:18:52 <jyp> so many things going on
14:19:30 <tromp> import Data.Char
14:19:50 <tromp> or :m +Data.Char
14:19:59 <tromp> if it works like ghci:)
14:20:19 <jyp> http://hackage.haskell.org/trac/haskell-prime
14:20:29 <jyp> @where haskell-prime
14:20:31 <lambdabot> I know nothing about haskell-prime.
14:20:49 <jyp> @where+ haskell-prime http://hackage.haskell.org/trac/haskell-prime
14:20:51 <lambdabot> Done.
14:21:00 <jyp> @where+ haskell' http://hackage.haskell.org/trac/haskell-prime
14:21:01 <lambdabot> Done.
14:21:57 <araujo> jyp, i feel i got something to tell to my grandsons now :-]
14:23:03 <jyp> :))
14:23:31 * sproingie sees this comment in lambdabot: 
14:23:31 <sproingie> -- | Thread-safe modification of an MVar.
14:23:37 <sproingie> mvars aren't threadsafe?
14:24:28 <jyp> araujo: By then Haskell will be the first language a programmer learns :)
14:24:49 <araujo> jyp, yeah! :-]
14:25:16 <jyp> sproingie: depends on what you mean by threadsafe
14:25:20 <Cale> sproingie: they can be used in ways which are not safe for the application
14:25:37 <araujo> I will say... "Oh.. i remenber 40 years ago boys.... when we were discussing the Haskell' standard at the beginning of the century...."
14:26:18 <jyp> and they'll say: why did you make such conservative old-fashioned choices ???
14:26:21 <jyp>  :)
14:26:22 <araujo> hahah
14:26:34 <tibbe> jyp, it's actually the first language taught at Chalmers, that's a univeristy though...
14:27:10 * jyp wishes he'd studied at Chalmers
14:27:44 <jyp> most universities don't, unfortunately
14:28:00 <Cale> there are quite a few who do
14:28:12 <Cale> Some in Australia
14:28:12 <sproingie> Cale: any mutable state can be abused, sure.  just wondering if putMvar will actually allow two threads to write to the mvar before it's emptied inbetween
14:28:24 <sproingie> Cale: since the docs indicate that that won't happen
14:28:32 <Cale> sproingie: no, one thread will block
14:28:43 <sproingie> Cale: ok, safe enough for me then :)
14:33:27 <tromp> hi Cale
14:33:31 <Cale> hi
14:33:42 <tromp> remember the what-is-a-combinator discussion:-?
14:33:48 <Cale> yeah?
14:34:00 <tromp> what about the Y combinator:-?
14:34:23 <tromp> that's not a combinator
14:34:38 <araujo> oh, there exist a ticket to remove the '-' unary operator.
14:34:57 <tibbe> I can't believe that we're having the same problem generating native code as we had in 1992
14:35:24 <araujo> oh cool, i like this one, to have multiparameter type classes.
14:35:41 <Cale> Y = S S K (S (K (S S (S (S S K)))) K)
14:36:04 <tromp> yeah, that\s my definition:)
14:36:21 <tromp> but not everything expressible in S,K is a combinator
14:37:14 <Cale> tromp: hmm
14:37:41 <jyp> imho, interesting languages are always on the verge of not being compilable
14:37:42 <Cale> araujo: isn't that an obvious one?
14:37:59 <jyp> "compilable" in a "state of the art sense"
14:38:17 <araujo> Cale, well, it says "aopt maybe" , yet :-P
14:38:21 <araujo> adopt*
14:38:29 <Cale> I don't think that Haskell' would be realistic without multiparameter typeclasses. Everyone uses them.
14:39:28 <Cale> odd that functional dependencies has a "probably no"
14:39:33 <Cale> since everyone uses those too
14:39:58 <Cale> MonadState uses fundeps for example.
14:41:55 <jyp> I think they wish to include associated type synonyms
14:42:37 <Cale> Really? Those aren't even implemented though, afaik.
14:43:36 <jyp> i thought it was implemented but not committed yet
14:43:39 <Cale> I was under the impression that this was to create a revision primarily to clean up cruft and bring the standard up to a realistic point.
14:44:25 <araujo> Cale, itÂ¿s for that according to the wiki
14:44:28 <jyp> Reading the AT paper, it sort of looks like a cleanup of the functional deps :)
14:44:41 <Cale> jyp: it's not quite that
14:45:15 <Cale> I don't think it's quite as expressive.
14:45:31 <jyp> Right, but still... I suspect the motivation is to replace FD
14:45:49 <Cale> mm
14:45:57 <jyp> with a less expressive but cleaner system
14:47:02 <dcoutts> xerox, the .chs.pp source links should be fixed now too :-)
14:47:09 <dcoutts> eg: http://haskell.org/gtk2hs/docs/devel/Graphics-UI-Gtk-TreeList-TreeView.html
14:47:15 <jyp> "In particular, even HList ... can be mirrored with ATs"
14:47:16 <dcoutts> links to http://darcs.haskell.org/gtk2hs/gtk/Graphics/UI/Gtk/TreeList/TreeView.chs.pp
14:47:23 <jyp> so I suspect they have done it.
14:47:32 <tibbe> is lambda lifting something that all FPL:s "should" do?
14:48:18 <Cale> ATs are also 'probably no'
14:49:27 <jyp> Well, I guess probably no + probably no = probably yes then :p
14:50:53 <lispy> lambda lifting?
14:51:02 <jyp> On a serious side, they probably don't want to standardize FD only to discover that they have been, in practice, completely replaced by AT two years later.
14:52:20 <lispy> is lambda heavy?
14:53:41 <Cale> I think restandardising every couple of years is a good plan ;)
14:54:01 <jyp> ;)
14:55:17 <Cale> I actually half-seriously don't want people to expect the language to be too stable.
14:55:49 <edwinb> half the fun is playing with all the latest extensions...
14:56:22 <Cale> another thing we could do is standardise various extensions
14:56:40 <SamB> especially since too stable == stagnant
14:56:47 <Cale> SamB: right
14:57:21 <Cale> Like, standardise both fundeps and ATs but don't require either in Haskell'
14:57:59 <jyp> Well, why standardise then ?
14:58:16 <alar> what are ATs?
14:58:19 <Cale> To make the semantics well known and recorded in one place?
14:58:29 <Cale> http://hackage.haskell.org/trac/haskell-prime/wiki/AssociatedTypes
14:58:42 <SamB> jyp: so that they will be done the same in different implementations?
14:59:32 <Cale> I'd really really like to see the Prelude go back to looking somewhat like it did in Haskell 1.4
14:59:39 <jyp> makes sense... still, I guess the papers are already descriptive enough.
14:59:50 <Cale> Haskell 98's changes to the prelude seem brain damaged
15:00:22 <tromp> what is a prime example, Cale?
15:00:58 <Cale> tromp: Removing MonadZero, adding fail to Monad, specialising all kinds of functions to lists
15:01:01 <alar> seems they are more powerful than FD
15:01:23 <Cale> alar: how so?
15:01:27 * lispy is downloading VS.NET 2005 so he can look at the haskell extensions he's heard about
15:01:38 <alar> Cale: just my HO
15:01:50 <tibbe> woa! there's a hidden C-- generator in Haskell!
15:01:52 <alar> am I wrong?
15:02:02 <lispy> tibbe: hidden?
15:02:15 <tibbe> lispy, as in not in the docs
15:02:18 <tromp> specialization is bad:(
15:02:29 <tibbe> lispy, found it in the CVS
15:02:30 <lispy> tibbe: as in, ghc can generate C--?
15:02:39 <jyp> ghc can compile C--
15:02:49 <tibbe> lispy, haven't read through the code yet but I think so
15:02:51 <lispy> ghc++
15:03:16 <tibbe> jyp, I want to generate it
15:03:27 <tibbe> now I jus thave to figure out how to add a GC
15:03:43 <Cale> alar: there seem to be things which associated types can't do which fundeps can
15:03:56 <Cale> or at least, where the translation is unclear
15:04:08 <jyp> tibbe: so, you have a C-- compiler that you want to feed with ghc's output ?
15:04:10 <lispy> tibbe: GC's are hard to write afaict
15:04:38 <Cale> alar: but I'm not really sure if there are any important cases
15:04:54 <tibbe> jyp & lispy, I have an AST of a language I wrote that I want to generate C-- from, the language need a GC though
15:05:05 <Cale> class Zip a b c | a c -> b, b c -> a -- seems not possible to simulate with associated types
15:05:13 <ihope> @pretty let sieve (x:xs) = x : [ y | y <- sieve xs, y `mod` x /= 0 ] in sieve [2..]
15:05:15 <lambdabot>  i = let sieve (x : xs) = x : [y | y <- sieve xs, y `mod` x /= 0]
15:05:15 <lambdabot> in
15:05:15 <lambdabot>    sieve [2 ..]
15:05:23 <Cale> otoh,  class Zip a b c | c -> a b
15:05:25 <Cale> is fine
15:05:56 <alar> thanks
15:06:23 <alar> those matter are not quite clear for me yet
15:06:41 <Cale> I'm not sure I want to give up functional dependencies
15:06:43 <tibbe> http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/ghc/compiler/cmm/
15:06:50 <lispy> tibbe: so what makes this language interesting.  Is it a learning tool for yourself, or is it cool in some additional way?
15:07:09 <jyp> The very idea is that  things that can be expressed by FD but not AT are more confusing than useful
15:07:13 <SimonRC> hello
15:07:13 <tibbe> lispy, learning tool for myself
15:07:24 <lispy> tibbe: nice, good lukc with it.  Sounds fun
15:07:29 <Cale> jyp: but is that true in all cases?
15:07:41 <tibbe> lispy, thanks
15:08:03 <jyp> Cale: I'm not competent on the matter... but IMHO yes
15:08:19 <Cale> Maybe in all cases that we know about right now
15:08:43 <jyp> nicely put,
15:09:13 <SamB> GHC can't compile proper C--, actually...
15:09:15 <Cale> I'm not really sure. Also, there seemed to be some awkward cases with ATs that I wasn't terribly convinced about, though I could probably get used to them.
15:09:15 <jyp> but still, designing for the unknown futures is a difficult stance, 
15:09:35 <jyp> especially when FD have been around for quite some time
15:10:06 <tibbe> lispy, looks like the C-- GHC stuff isn't a generator :/
15:10:59 <lispy> tibbe: i tihnk you'll find that onec you have an AST, generating code is a matter of pretty printing, at least generating naive code
15:11:39 <tibbe> lispy, you're probably right, still it would be nice if what I've found turned out to be something I could use
15:12:47 <lispy> man, compiler design is fun.  Talking about this makes we want to work on my haskell syntax to ocaml syntax translator
15:13:57 <tibbe> :)
15:14:03 <lispy> the idea would be to compare programs that don't require certain features of laziness (like infinite datastructures) with themselves compliedin a strict manner
15:14:12 <tibbe> i wish I had a better theoretical background on functional languages though
15:14:41 <lispy> tibbe: well, i've learned a ton from hanging out here and trying to read papers about haskell
15:15:04 <palomer> yeah, lispy used to be a real idiot:o
15:15:06 <palomer> :P
15:15:12 <lispy> used to be?
15:15:19 <lispy> so i've gotten better!
15:15:26 * lispy bounces around
15:16:03 <lispy> i'm still very much struggling with how to optimize haskell programs
15:16:28 <palomer> rewriting terms
15:16:39 <lispy> i think i need to be able to trace a program through it's lazy evaluation
15:17:12 <tibbe> I'm trying to figure out if lambda lifting is something i must do or if I could have only one arg functions and compose multi arg functions of those
15:17:44 <jyp> lispy: how about trying out eager haskell ?
15:18:02 <lispy> i don't know what lambda lifiting is, but i know you can use single param lambda to get multi arg lambdas
15:18:12 <lispy> jyp: oh, i hadn't heard of that
15:18:21 <lispy> jyp: how much of haskell does it support?
15:18:29 <jyp> no :)
15:18:47 <jyp> I'd wish you did the testing for me :)
15:18:54 <lispy> heh
15:18:58 <palomer> I don't see how eager haskell would differ from normal haskell, except that it would fail more often
15:19:06 <palomer> and sometimes be slower
15:19:10 <palomer> and sometimes faster
15:19:13 <lispy> palomer: laziness does not come for free
15:19:14 <tromp> eager to fail:)
15:19:43 <palomer> I disagree, laziness is free!
15:19:57 <jyp> this is the whole point: being faster more often than being slower :)
15:20:01 <ihope> Laziness is free, but it doesn't always pay of.
15:20:03 <ihope> *off
15:20:12 <lispy> another thing i wonder about is...what if we view cells at the level of dna, and view the rules of dna as a model of computation.  Now we try to write programs in "dna" and simulate those programs :)
15:20:27 <palomer> compilers should be able to detect when a problem can be easily solved without laziness and optimize accordingly
15:20:47 <jethr0_> palomer: is that always computable?
15:20:57 <eivuokko> @quote+ ihope Laziness if free, but it doesn't always pay off.
15:20:58 <lambdabot> ihope Laziness if free, but it doesn't always pay off. hasn't said
15:20:58 <lambdabot> anything memorable
15:21:12 <eivuokko> Ergh.
15:21:20 <jyp> You guyes can also read about cheap eagerness (Faxen) and optimistic evaluation
15:21:22 <palomer> jethr0_: surely not, but I rather have my compiler do the  work than I!
15:21:40 <jethr0_> sure, but the heuristics shouldn't produce any false positives!
15:22:47 <roconnor> @hoggle (a -> m b) -> [a] -> m [b]
15:22:48 <lambdabot> No matches, try a more general search
15:23:12 <jyp> @type mapM
15:23:14 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
15:23:23 <ihope> What was that guy's name?
15:23:36 <ihope> Started with a k, I think.
15:23:45 <jyp> who? 
15:23:46 <roconnor> @type mapM_
15:23:47 <jethr0_> the problem is to find out when and if cells are evaluated; and to ensure that the eager version is still "correct" and has the same strictness as the original
15:23:47 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> [a] -> m ()
15:24:29 <ihope> @type sequence
15:24:30 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
15:25:28 <lispy> will haskell' consider unifiying functors and monads (all monads are functors right?) and having monad comprehensions?
15:25:55 <jyp> it looks like the prelude will be much more thin
15:26:13 <jyp> don't know if monads will be taken out though
15:26:29 <jyp> ... but if so, the question magically vanishes :)
15:26:41 <lispy> i know one that that seems weird about haskell98 prelude, is that there are unexported functions, what's up with that?
15:26:57 <lispy> no monads in prelude? er i'm confused
15:27:10 <ihope> Three monads in the Prelude...
15:27:15 <ihope> [], IO, Maybe
15:27:50 <lispy> well, how would you take [] out of the prelude?  put it in someother standard module?
15:29:12 <ihope> Put the instance declaration somewhere else?
15:29:28 <SimonRC> lispy: since list comprehensions are almost the same as do-notation on lists, it used to be that you could write comprehensions for any monad.
15:30:05 <lispy> SimonRC: right, Cale or someone explained that to me once, they seemed very nice.
15:30:29 <lispy> i guess the disadvantage was worse type messages
15:30:33 <SamK> To practice, I am trying to convert "one two three" to "three two one", I got as far as reverse(words "one two three")), do I need to foldr ++ somehow?
15:30:35 <SimonRC> yeah
15:30:46 <SimonRC> SamK: unwords
15:30:58 <SimonRC> also note linhes and unlines
15:31:07 <SimonRC> *lines and unlines
15:31:19 <SamK> thats awesome ;)
15:31:30 <lispy> > unwords (words "one    two        three")
15:31:32 <lambdabot> "one two three"
15:31:38 <lispy> but notice you lose something :)
15:32:11 <glasser> SamK: but it might be fun to come up with your own definition of unwords using a fold function
15:32:14 <SamK> unwords just inserts a single space right?
15:32:23 <lispy> SamK: correct
15:33:30 <ihope> > (\"one two three" -> "three two one") "one two three"
15:33:32 <lambdabot> "three two one"
15:33:38 <SimonRC> :-)
15:34:46 <lispy> haha
15:35:28 <glasser> > (\"one two three" -> "three two one") "uno dos tres"
15:35:30 <lambdabot>  Non-exhaustive patterns in lambda
15:36:07 <ihope> > (\14 -> 16) "catorce"
15:36:09 <lambdabot>  add an instance declaration for (Num [Char])
15:36:09 <lambdabot>   When checking the pattern: 14
15:36:09 <lambdabot>   In a lambda abstraction: \ 14 -> 16
15:36:32 <ihope> > case 3 of 5 -> 7
15:36:34 <lambdabot>  Non-exhaustive patterns in case
15:37:18 <SamK> unwords (reverse (words "uno dos tres")))
15:38:14 <lispy> > unwords (inits (words "uno dos tres"))
15:38:15 <lambdabot> Couldn't match `Char' against `String'
15:38:24 <lispy> :(
15:38:32 <ihope> > (unwords . reverse . words) "uno dos tres"
15:38:34 <lambdabot> "tres dos uno"
15:38:47 <ihope> (map unwords . inits . words) "uno dos tres"
15:38:51 <ihope> > (map unwords . inits . words) "uno dos tres"
15:38:53 <lambdabot> ["","uno","uno dos","uno dos tres"]
15:38:55 <olliej> > let x = 4 +
15:38:57 <lambdabot>  parse error (possibly incorrect indentation)
15:39:08 <olliej> :(
15:39:19 <olliej> can't do the ghci one of storing a let
15:39:20 <SimonRC> > let x = (4 +)
15:39:21 <lambdabot>  parse error on input `}'
15:39:33 <olliej> > let x = 4 (+)
15:39:34 <lambdabot>  parse error on input `}'
15:39:35 <SimonRC> > let x = (4 +) in x 5
15:39:37 <lambdabot> 9
15:39:38 <ihope> Of course, let...in still works.
15:39:49 <SamK> how does (unwords . reverse . words) "uno dos tres" work? infix?
15:40:07 <SimonRC> SamK: the functions are composed
15:40:18 <olliej> nuts.. i managed to screw up cvs on my masters... *sigh**
15:40:21 <SimonRC> that is the point of . after all
15:40:24 <ihope> (a . b) c = a (b c)
15:40:58 <SimonRC> so (f . g . h) = \x -> f (g (h x)))
15:41:23 <lispy> > unwords (concat (inits (words "one two three")))
15:41:25 <lambdabot> "one one two one two three"
15:41:25 <ihope> Yep.
15:41:52 <SamK> right, yeah I see
15:41:54 <ihope> > (unwords . concat . inits . words) "The quick brown fox jumps over the lazy dog"
15:41:55 <lispy> olliej: darcs welcomes you
15:41:55 <lambdabot> "The The quick The quick brown The quick brown fox The quick brown fox
15:41:55 <lambdabot> jumps The quick brown fox jumps over The quick brown fox jumps over the
15:41:55 <lambdabot> The quick brown fox jumps over the lazy The quick brown fox jumps over
15:41:55 <lambdabot> the lazy dog"
15:42:34 <olliej> lispy: :p
15:43:34 <lispy> > let (a o b) c  = a (b c) in (unwords o concat o inits o words) "The quick brown fox jumps over the lazy dog"
15:43:35 <lambdabot>  Not in scope: `o'
15:43:52 <olliej> lispy: it turns out a while back i checked out an earlier revision of some files.. which i then forgot i had done... and then modified... *sigh*
15:44:06 <lispy> > let (a `o` b) c  = a (b c) in (unwords `o` concat `o` inits `o` words) "The quick brown fox jumps over the lazy dog"
15:44:08 <lambdabot> "The The quick The quick brown The quick brown fox The quick brown fox
15:44:08 <lambdabot> jumps The quick brown fox jumps over The quick brown fox jumps over the
15:44:08 <lambdabot> The quick brown fox jumps over the lazy The quick brown fox jumps over
15:44:08 <lambdabot> the lazy dog"
15:44:22 <lispy> olliej: i am sorry to hera about that
15:44:43 <tromp> clean uses o instead of .
15:44:52 <lispy> SamK: as you can see, ihope's definition of . is actually how it is defined in haskell!
15:44:56 <tromp> of course, without the ``
15:45:29 <olliej> lispy: net summary: i am a retard
15:46:07 <SamK> (.) :: (b -> c) -> (a -> b) -> a -> c
15:46:18 <lispy> olliej: *shurg* cvs has encouraged many bright people to do foolish things, i know it's seduced me once or twice
15:46:43 <ihope> @type ((.) . (.))
15:46:45 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
15:47:20 <olliej> lispy: :)
15:47:20 <lispy> olliej: i especially hate that checking out old versions makes those files sticky...and then you overwrite "good stuff" just because you wanted to see a version from 3 weeks ago
15:48:52 <SamK> ihope: heh, straight over my head
15:49:43 <SamK> '.' rules.. just like making a pipeline..
15:49:52 <olliej> lispy: i am *really* beginning to hate cvs
15:50:06 <olliej> lispy: but it's got 12 months of history in it
15:50:18 <ihope> Composition is like a lesser version of continuations.
15:50:37 <SimonRC> SamK: yes
15:52:41 <ihope> Yay, Internet Explorer boochery.
15:52:54 <ihope> I can always read this page via the source code...
15:53:23 <ihope> ...Of course, HTML is mostly incomprehensible these days...
15:53:24 <SimonRC> ihope: use w3m
15:54:15 <SimonRC> sed -e 's/<[^>]>//g
15:54:21 <SimonRC> oops
15:54:28 <SimonRC> ihope: sed -e 's/<[^>]>//g'
15:56:02 <lispy> olliej: tailor.py,don't lose the history convert to just about any other VCS
15:56:18 <lispy> olliej: not ready for the paradigm shift of darcs, go for svn
15:56:49 * olliej goes looking for tailor.py
15:57:52 <tromp> . is the mappend of the (->) Monoid
15:58:00 <lispy> olliej: http://darcs.net/DarcsWiki/RelatedSoftware
15:58:10 <olliej> lispy: yeah just found it :)
15:58:24 <olliej> @type >>=
15:58:25 <lambdabot> parse error on input `>>='
15:58:36 <tromp> @type (>>=)
15:58:38 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
15:58:53 <olliej> tromp: cheers
16:01:26 <ihope> According to my brother, he (unwords . repeat) "definitely".
16:02:08 <lispy> > take 5 $ (unwords . repeat) "definitely"
16:02:09 <lambdabot> "defin"
16:02:14 <lispy> er...
16:02:31 <lispy> heh, not what i had meant :)
16:02:45 <ihope> > (unwords . replicate 5) "definitely"
16:02:47 <lambdabot> "definitely definitely definitely definitely definitely"
16:03:24 <lispy> so, replicate n = take n . repeat
16:03:29 <lispy> would that work?
16:03:34 <ihope> If foot stomps were BEL's, it'd be (unwords . repeat) "def\ainitely"
16:03:36 <SamK> does lambdabot detect when you are registered to freenode?
16:03:49 <ihope> lispy: yeah, I think so.
16:03:55 <int-e> > let a = 21 in iterate succ a !! a
16:03:57 <lambdabot> 42
16:04:18 <ihope> Fancy doubling?
16:04:52 * int-e wonders if there's a standard function for \f n v -> iterate f v !! n.
16:04:59 <int-e> ihope: yeah
16:05:08 <ihope> @pl \f n v -> iterate f v !! n
16:05:09 <lambdabot> flip . ((!!) .) . iterate
16:05:18 <ihope> pl knows all.
16:05:25 <ihope> Except inline notation.
16:05:29 <int-e> ihope: and it doesn't even work for negative numbers.
16:05:45 <ihope> @pl \x -> do a <- x; return (a+1)
16:05:46 <lambdabot> (line 1, column 16):
16:05:46 <lambdabot> unexpected ";"
16:05:46 <lambdabot> expecting letter or digit, variable, "(", "`", "!!", ".", operator or end
16:05:46 <lambdabot> of input
16:05:54 <ihope> Whoo.
16:06:14 <lispy> @pl \x -> x >>= return (a+1)
16:06:15 <lambdabot> (return (a + 1) =<<)
16:06:21 <ihope> Whoa!
16:06:33 <ihope> Not (>>= return (a + 1))?
16:06:34 <chucky> @pl \x -> do {a <- x; return (a+1);}
16:06:35 <lambdabot> (line 1, column 10):
16:06:35 <lambdabot> unexpected "{"
16:06:35 <lambdabot> expecting variable, "(", operator or end of input
16:07:04 <ihope> @pl \x -> x >>= \a -> return (a+1)
16:07:05 <lambdabot> ((1 +) `fmap`)
16:07:11 <lispy> well, it'sstill wrong
16:07:12 <ihope> Whoa.
16:07:19 <lispy> yeah
16:07:23 <lispy> that's what i should have typed
16:07:37 <lispy> fmap is pretty handy, and actually it should be the case that map = fmap
16:07:45 <ihope> > [a | a <- Maybe 3]
16:07:47 <lambdabot>  Not in scope: data constructor `Maybe'
16:07:49 <araujo> There exist a function in the prelude to take the first letter of a word to uppercase?
16:07:53 <ihope> > [a | a <- Just 3]
16:07:54 <SamK> [1,2,3]
16:07:55 <lambdabot> Couldn't match `Maybe a' against `[a1]'
16:08:12 <ihope> @pl \(x:xs) -> toUpper x : xs
16:08:13 <lambdabot> ap ((:) . toUpper . head) tail
16:08:13 <SamK> gah, talk to me lambdabot :)
16:08:33 <lispy> > [1,2,3]
16:08:35 <lambdabot> [1,2,3]
16:08:47 <araujo> ihope, ap?
16:08:53 <ihope> I suppose.
16:09:05 <araujo> @index ap
16:09:06 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.
16:09:06 <lambdabot> State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont,
16:09:06 <lambdabot> Control.Monad.Error, Control.Monad.List, Data.Graph.Inductive.Query.
16:09:06 <lambdabot> ArtPoint, Data.Graph.Inductive.Query, Data.Graph.Inductive
16:09:12 <ihope> Apparently my brother really is evaluating a repeat, not a replicate.
16:09:13 <araujo> Interesting :-)
16:09:20 <int-e> araujo: in that case, ap f x y = f x (f y)
16:09:30 <int-e> argh
16:09:32 <ihope> Zee ess combinator!
16:09:39 <int-e> araujo: in that case, ap f g x = f x (g x)
16:09:45 <int-e> what was I thinking?
16:09:55 <ihope> (Or "cumbeenator".)
16:09:57 <araujo> Thanks int-e 
16:10:43 <int-e> @type Control.Arrow.ap
16:10:44 <lambdabot> Not in scope: `Control.Arrow.ap'
16:11:38 <ihope> Arrow, eh?
16:11:41 <int-e> ap :: (Monad m) => m (a -> b) -> m a -> m b
16:12:07 <int-e> No, not Arrow. It's 'just' the Reader Monad.
16:12:41 <SimonRC> ap is lifted function aplication
16:12:51 <SimonRC> reduces need for liftM
16:13:49 <ihope> I like >>=.
16:14:10 <tromp> ap               =  liftM2 ($)
16:14:23 <lispy> isn't it the case that concatMap = >>=
16:14:26 <ihope> @index unsafePerformIO
16:14:27 <lambdabot> System.IO.Unsafe, Foreign
16:14:46 <ihope> @type concatMap
16:14:48 <lambdabot> forall b a. (a -> [b]) -> [a] -> [b]
16:14:58 <ihope> Looks like flip (>>=) to me.
16:15:13 <lispy> concatMap = =<<
16:15:16 <lispy> in that case :)
16:18:51 <SamK> I've registered with freenode, is there anything else you need to do to /msg lambdabot?
16:21:17 <ihope> Well, there's the identify stuff.
16:21:30 <ihope> You should be all right.
16:21:41 <SamK> yeah, done that
16:22:04 <SamK> [1,2,3]
16:22:12 <SamK> ah well ;)
16:23:48 <ihope> > [1,2,3]
16:23:50 <lambdabot> [1,2,3]
16:24:05 <int-e> SamK: note the '>'
16:24:05 <dons> moin
16:24:06 <SamK> > [1,2,3]
16:24:08 <lambdabot> [1,2,3]
16:24:15 <SamK> <ahem>
16:24:59 <ihope> > If lambdabot didn't require that, we'd be in bad shape.
16:25:00 <lambdabot>  parse error on input `,'
16:25:30 <SamK> > (unwords (reverse (words "smart not too")))
16:25:32 <lambdabot> "too not smart"
16:26:24 <dons> Lemmih, hs-plugins used to work with < 6.4, but I broke backward compat.
16:26:53 <dons> lispy, isn't lazy reading what readFileLazily :: FilePath -> IO LazyFile
16:26:56 <dons> is for?
16:28:47 <dons> musasabi, regarding fib, it seems to get specialised.
16:28:53 * SimonRC thoung that was getContents
16:35:56 <SimonRC> hi * 2
16:36:40 <dcoutts> hia dons, you were trying to get ahold of me yesterday?
16:36:54 <dcoutts> @seen SyntaxNinja
16:36:55 <lambdabot> I saw SyntaxNinja leaving #haskell and #haskell-blah 22 hours, 34 minutes
16:36:55 <lambdabot> and 21 seconds ago.
16:37:02 <Cale> dons: hi!
16:38:48 <dons> dcoutts, yeah, I head a regex program for you to test on a gentoo 32bit x86?
16:39:12 <dcoutts> dons, oh ok. what? where?
16:39:14 <dons> wget http://www.cse.unsw.edu.au/~dons/regex-dna.tgz
16:39:17 <Cale> Nick Alexander and I are working on monadising some aspects of yi
16:39:36 <dons> untar, ghc -o a A.hs ; time ./a < input.txt ; check the output matches expected
16:40:01 <dons> dcoutts, it may diverge. this is what I'm looking for  -- it seems to diverge on the gentoo shootout box
16:40:05 <dons> Cale, ah!1
16:40:09 <dons> yes, this would be good
16:40:10 <dcoutts> dons, ok
16:40:20 <dons> (it may even be in the todo list, Cale)
16:41:41 <dcoutts> dons, any particular command line args when building with ghc?
16:43:05 <dcoutts> dons, how long do I expect it to run for?
16:44:31 <dcoutts> dons, it terminates and gives the right answer.
16:45:56 <dons> hmm :/
16:46:36 <dons> it doesn't terminate in 3000 seconds on the shootout box
16:46:47 <dcoutts> $ time ./a.out < input.txt > expected2
16:46:47 <dcoutts> real    1m15.636s
16:46:47 <dcoutts> user    1m15.389s
16:46:47 <dcoutts> sys     0m0.108s
16:47:15 <dcoutts> what gcc are they using?
16:47:31 <dcoutts> have you tried with -fasm rather than -O -opt-C ...
16:48:20 <dons> I think it is due to the hard coded byte offsets in the regexec binding (no hsc2hs)
16:48:41 <dons> this caused the openbsd version to not terminate on linux, till i realised regex.h isn't the same
16:49:04 <dons> it ends up reading an infinite list of (0,0) offsets, or some such.
16:49:37 <dons> i need to either use hsc2hs on the test machine, or put my Ptr Word8 code into the base lib, and use it once 6.6 comes out
16:50:02 <dons> that's nice and fast, btw.
16:50:21 <dcoutts> so 6.6 will include fps ?
16:50:37 <eivuokko> Is there non-gpl fps?
16:51:20 <dons> it is BSD3 licensed
16:51:34 <dons> fps.cabal: License:             BSD3
16:51:57 <dons> dcoutts, yes, a merger of simonM's packedstring lib, and all the full List interface from FPS
16:52:03 <dcoutts> cool
16:52:04 <dons> which I am currently working on
16:52:08 <dcoutts> excelent
16:52:14 <dons> and thinkgs like mmap and regexec support
16:52:44 <dcoutts> will ghc use fps itself then? mmap support for slurping .hi files would be good
16:53:06 <eivuokko> Ah, hmm.  I somehow thought it gpl.
16:55:56 <eivuokko> Anyway, cool.  I'm tired of Ptr Word8 hacks :)
16:56:35 <SamB> eivuokko: it for some reason said it *was* GPL...
16:58:02 <dons> yeah, simon wan'ts to use packedstrings in ghhc. not sure about mmap.
16:59:56 <ihope> > (error . error) "Test\ning"
16:59:58 <lambdabot> Add a type signature
17:00:04 <ihope> > (error . error) "Test\ning" :: Int
17:00:06 <lambdabot> Test
17:00:06 <lambdabot> ing
17:00:18 <ulfdoz> Hollywood-Schießerein sind immer wieder geil. Und keine Scheibe geht im Kugelhagel kaputt.
17:00:25 <ulfdoz> ECHAN, sorry
17:01:16 <SamB> > (error . ("Foo\n"++) . error) "Test\ning" :: Int
17:01:17 <lambdabot> Test
17:01:17 <lambdabot> ing
17:02:19 <dons> maybe I can submit a .hsc file, and get musasabi to run hsc2hs on the shootout box.
17:03:27 <dcoutts> sounds like a good idea
17:04:00 * dcoutts delves into hsc2hs to try and fix the {-# LINE ... #-} pragmas it emits
17:04:10 * dcoutts is on a {-# LINE ... #-} rampage today
17:04:30 <dcoutts> "a {-# LINE ... #-} *fixing* rampage today"
17:04:57 <SamB> well duh
17:05:15 <ihope> > (error . error) "oooO  Oooo\n(  )  (  )\n \ (  ) /\n  \_)(_/"
17:05:17 <lambdabot>  lexical error in string/character literal
17:05:34 <ihope> > (error . error) "oooO  Oooo\n(  )  (  )\n \\ (  ) /\n  \\_)(_/"
17:05:36 <SamB> > (error . error) "oooO  Oooo\n(  )  (  )\n \\ (  ) /\n  \\_)(_/"
17:05:36 <lambdabot> Add a type signature
17:05:37 <lambdabot> Add a type signature
17:05:47 <ihope> > (error . error) "oooO  Oooo\n(  )  (  )\n \\ (  ) /\n  \\_)(_/" :: Int
17:05:49 <lambdabot> oooO  Oooo
17:05:49 <lambdabot> (  )  (  )
17:05:49 <lambdabot>  \ (  ) /
17:06:06 <ihope> That's better. But the feet have no heels.
17:06:11 <SamB> okay, kindly *remove* your feet from this IRC channel
17:06:19 <eivuokko> heh
17:07:16 <dons> do I need to fix this error.error issue?
17:07:22 <dons> it's a simple thing to fix.
17:07:28 <dons> but do I *need* to do it?
17:07:43 <SamB> error.error issue?
17:07:45 <eivuokko> Fwiw, http://www.cse.unsw.edu.au/~dons/code/fps/cbits/fpstring.c is LGPL'd.
17:07:51 <SamB> whats the issue?
17:07:59 <SamB> > error "oooO  Oooo\n(  )  (  )\n \\ (  ) /\n  \\_)(_/" :: Int
17:08:00 <lambdabot> Exception: oooO  Oooo
17:08:00 <lambdabot> (  )  (  )
17:08:00 <lambdabot>  \ (  ) /
17:08:45 <dons> eivuokko, ah, if you need it, it's BSD. that is just left over from my default license.
17:09:04 <dons> I have a script `copyleft` that inserts licenses into new files :}
17:09:19 <SamB> eivuokko: perhaps an oversight?
17:10:13 <SamB> dons: it claims to be part of darcs, too...
17:11:01 <eivuokko> Well, licenses are dangerous for commercial stuff :)  Gotta know where to tread.
17:11:30 <dons> it's BSD. David and I both say so. and we wrote the code :)
17:11:34 <SamB> dons: what is with that GPL thing anyway
17:11:50 <dons> I'm a communist ;) hehehe
17:11:51 <SamB> dons: okay, so FIX THE FILE!
17:12:06 <eivuokko> Darcs is GPL and a lot of code came from there
17:12:15 <ihope> Whoo. These unsafe functions are tricky to work with.
17:12:21 <ihope> And no, I'm NOT using them seriously!
17:12:24 <eivuokko> unsafeInterlaveIO is cool :)
17:12:30 <ihope> Yeah...
17:12:40 <SamB> ihope: well, that is why they are called unsafe*
17:13:18 <ihope> Unlambda's unsafe functions are... um...
17:13:18 <eivuokko> unsafeInterleaveIO is one of the coolest practical safety breakers I know.
17:13:23 <ihope> :-)
17:13:28 <SamB> dons: what about all the people who have sent in patches, anyway?
17:13:38 <ihope> What if the type system vanished?
17:13:59 <ihope> And the :: stuff would simply reuse the same data as a different type?
17:15:15 <ihope> Heh. You could cast a list as a Maybe...
17:15:40 <ihope> And the empty list would become a Just (broken stuff), and anything else would be Nothing.
17:17:58 <edwinb> just stick a few unsafeCoerces in and get a similar effect ;)
17:18:38 <ihope> :-)
17:19:26 * araujo got headache
17:19:37 <eivuokko> Bad?
17:19:42 <ihope> 'Tis the point...
17:19:50 <araujo> Sort of....
17:20:24 <araujo> I had to stand in a line during too much time today in the mall 
17:20:35 <araujo> And it's been way too hot here today too.
17:25:27 <musasabi> Is there a nice way to create "Data.Map.filterMap :: Ord k => (a -> Maybe b) -> Map k a -> Map k b" from the existing API?
17:26:04 <SimonRC> use toList?
17:26:10 <dons> musasabi, regarding the regex-dna test, do you think it's possible to compile an entry this way: hsc2hs D.hsc && ghc -o d D.hs -O2 -optc-O3 -fglasgow-exts
17:26:51 <dons> (I think the entry is failing due to the hard coded struct shape)
17:28:15 <musasabi> SimonRC: possible, but not very efficient.
17:29:26 <tromp> why not use filter, musasabi?
17:29:59 <musasabi> tromp: because I need to modify the entries too.
17:30:10 <musasabi> of course a two-pass approach is possible.
17:30:11 <tromp> yes, so compose it
17:30:36 <SimonRC> Map k a --> Map k (Maybe b) --> Map k b
17:32:00 <tromp> or filter first, and then map
17:32:29 <tromp> filter (isJust . f)
17:32:48 <tromp> map (fromJust . f)
17:33:01 <ihope_> @type fromJust
17:33:03 <lambdabot> Not in scope: `fromJust'
17:33:10 <ihope_> @index fromJust
17:33:11 <lambdabot> Data.Maybe
17:33:18 <ihope_> @type Data.Maybe.fromJust
17:33:20 <lambdabot> forall a. Maybe a -> a
17:33:24 <tromp> you don't like the clumsy redundant feel of it:-?
17:33:39 <ihope_> @hoogle fromNothing
17:33:40 <lambdabot> No matches found
17:34:11 <araujo> Haskell is the only language ive used where you end up with less lines of code than you initially thought for a programm :-)
17:35:00 <SimonRC> ihope_: And just *what* would be the type signature of that?
17:35:04 <tromp> you can also change your map function to use a special b value instead of Nothing
17:35:19 <tromp> but that feels ugly
17:35:26 <SimonRC> tromp: no! naughty programmer! no magic values!
17:35:51 <tromp> see? that wld get you ostracized
17:36:03 <tromp> or however you spell that
17:37:19 <tromp> off to bed
17:37:28 <ihope_> Oh, uh.
17:37:36 <ihope_> SimonRC: Just a -> ()
17:39:55 <ihope_> Trivital type!
17:40:18 <edwinb> Maybe a -> Maybe b
17:49:50 <Shapr-nokia770> y0, wassup?
17:50:52 <SimonRC> well, lambdabot is up, at the moment
17:51:05 <Shapr-nokia770> @Yow !
17:51:06 <lambdabot> Reality distorts my sense of television.
17:52:20 * edwinb gets gadget envy
17:52:32 <Shapr770> Gah, pirate wifi is so unreliable
17:52:55 <Shapr770> edwinb, seen the screenshot?
17:53:01 <edwinb> no...?
17:53:47 <Shapr770> Http://www.scannedinavian.com/~shae/screenshot00.png
17:54:13 <edwinb> ooh, nice
17:54:16 <edwinb> want :)
17:54:37 <Shapr770> Only 300e without  vat
17:55:08 <pesco> I wonder if their SDK can be run on PowerPC.
17:57:03 <Shapr770> I've seen discussion about that on the maemo users list, don't remember the verdict.
17:57:51 * Shapr770 browses around looking for new debs to install.
17:58:27 <Shapr770> Mmm, debian in the palm of my hand ;-)
17:58:45 <pesco> Hey Shapr770, have you seen Ekiga?
17:58:58 <Shapr770> No, what's that?
17:59:10 <pesco> The new GnomeMeeting.
17:59:28 <pesco> Supporting SIP, broadband Speex and a bunch of other goodies.
18:00:01 <pesco> I just compiled the beta and it looks really nice.
18:00:54 <palomer> grr
18:01:04 <palomer> I have haskell's indentation of the => in case statements
18:01:27 <pesco> "haskell's indentation"?!
18:01:33 <musasabi> Are the C float.h constants available in Haskell? I would like to get at DBL_MIN at least.
18:01:34 <SimonRC> => in case?
18:01:46 <Shapr770> Cool, we should try that. The next version of the 770 firmware will have voip, maybe it'll use exiga
18:01:48 <SimonRC> surely ->?
18:02:01 <pesco> Shapr770: I definately hope so!
18:02:32 <pesco> Shapr770: My only problem now is to find a decent but simple registrar.
18:03:09 <pesco> Shapr770: SER is a beast and wants me to define complicated scripts or install MySQL. siproxd wants to relay all my traffic, and partysip is completely undocumented.
18:04:37 <palomer> err, yeah, ->
18:04:55 <palomer> no wait, haskell does an ok job
18:05:11 <dons> musasabi, I see:  floatRange _        =  (DBL_MIN_EXP, DBL_MAX_EXP)
18:05:31 <dons> in GHC.Float.lhs
18:06:39 <musasabi> > floatRange (0 :: Double)
18:06:40 <lambdabot> (-1021,1024)
18:06:58 <dons> #define DBL_MIN_EXP     (-1021)
18:06:58 <dons> #define DBL_MIN         2.2250738585072014E-308
18:07:10 <musasabi> hmm, it is just including float.h
18:07:29 <dons> hmm, No instance for (Bounded Float)
18:08:43 <dons> musasabi, do you think hsc2hs is a reasonable preprocessor to use for a shootout entry? any opinions?
18:08:45 * araujo off to watch some animes and then get back hacking
18:15:15 * SimonRC goes to bed
18:15:55 * Shapr770 must reboot to get new applets into the toolbar...
18:16:00 <Shapr770> Bye!
18:19:33 <dons> musasabi, what i've done on the regex-dna problem is to move the platform specific stuff (4 lines) into hsc2hs macros. it's now portable, so hopefully won't spin out on the shootout box. Is there any issue with the following build line: hsc2hs D.hsc && ghc -o d D.hs -O2 -optc-O3 -fglasgow-exts ?
18:19:55 <dons> http://www.haskell.org/hawiki/RegexDna, fyi
18:37:27 <TFK> Are there any SDL bindings besides http://fxp.hp.infoseek.co.jp/haskell/HSDL/ (how good is this one, and are there any English references?)?
18:39:31 <stepcut> yes
18:39:44 <stepcut> one moment
18:40:38 <stepcut> darcs get http://scannedinavian.org/~lemmih/SDLstable/
18:40:56 <stepcut> Last I heard, those are the best
18:52:31 <TFK> Mmm, thanks
18:59:31 <TFK> Only that doesn't seem to work :-(
18:59:44 <TFK> darcs just gets stuck, no output whatsoever.
18:59:53 <stepcut> hrm
19:00:56 <stepcut> works for me
19:14:25 <TFK> Invalid repository:  http://scannedinavian.org/~lemmih/SDLstable
19:14:25 <TFK> darcs failed:  Failed to download URL http://scannedinavian.org/~lemmih/SDLstabl
19:14:25 <TFK> e/_darcs/inventory
19:14:25 <TFK> libcurl error code: 52 <--- :-(
19:14:39 <TFK> C:\haskell>darcs --version
19:14:39 <TFK> 1.0.6pre1 (unknown)
19:16:42 * musasabi looks at the RegexDna
19:18:14 <dons> I notice that Chris has posted a nice fast knucleotide on the wiki too.
19:18:47 <musasabi> sizeof looks like a thing that has to be done with hsc2hs :-(
19:18:53 <dons> yeah :/
19:19:03 * araujo surfin' through the Haskell' tickets
19:20:06 <araujo> Please, don't remove '.' :-)
19:20:41 <dons> it was a hack to hard code the byte offsets. 
19:20:55 <musasabi> and the amd64 kills that probably
19:21:22 <musasabi> "sizeOf somethingSuitable" is an alternative is Isaac says no.
19:21:53 <dons> ? cannot parse that sentence
19:21:56 <musasabi> I think we should focus on why the libraries are too slow rather than handfixing things in the shootout
19:22:10 <musasabi> s/alternative is/alternative if/
19:22:56 <musasabi> very late, and I haven't yet had lunch so my english tends to be quite bad.
19:22:59 <lispy> Cale: i just watched the Backus movie you recommended.  he's one dry speaker.  But it was interesting.  Is haskell based on FL?
19:23:36 <dons> sure. i'm inclined to refactor the Text.Regex.Posix.hsc file anyway., and export the Ptr Word8 interface.
19:24:28 <musasabi> A second thing is a good fast HashTable, if {Perl,Python,Ruby} can have it, it cannot be that impossible to get with GHC.
19:25:44 <musasabi> The benchmarks tend to change with time, but improvements in libraries are with us in the next year too.
19:26:32 <Heffalump> lispy: indirectly, yes
19:26:34 <musasabi> of course it is nice to win the shootout even before GHC6.6 makes things easier :-)
19:27:25 <dons> yes. binding to an efficientperl-compat regex library would be good, for example.
19:27:43 <Heffalump> lispy: or rather, some of the ideas are
19:28:30 <dons> regex(3) seems much more inefficient than some of the other languages libs.
19:28:54 <dons> so, packedstrings, hashtables, and regexes are what we need
19:29:14 <dons> the future looks good :)
19:30:09 * musasabi does not know about regex stuff (and how unicode affects it), but hashtables should be quite easy
19:30:30 <dons> yeah, already jyp has a better HashTable he's working on.
19:32:50 <dons> we should probably write a list of things that have been hard to do in the shootout. seems like a good idea.
19:33:41 <dons> ah, we're now second on the debian box too: and only just second: http://shootout.alioth.debian.org/debian/benchmark.php?test=all&lang=all
19:33:58 <dons> and that's with the n-body test still failing..
19:34:34 <dons> hmm. so if we fix regex and submit Chris' fast knucleotide... hmm... :)
19:35:43 <dons> and then there are 5 programs that will be much shorter with packed strings. good good
19:51:19 <dons> musasabi, did you see that my fix to the nested comments in chameneos was rejected? http://shootout.alioth.debian.org/debian/benchmark.php?test=chameneos&lang=ghc&id=3
19:52:11 <dons> it's the same program as the accepted one, but with -- comments, and a shorter complement function. i think they're wrong to reject it, since the semantics are the same as the correct entry.
19:52:45 <dons> it certainly didn't become asymmetrical during a refactor :/
19:56:55 <Cale> lispy: Not directly, but probably some of the ideas have come along from there.
20:00:58 <musasabi> dons: I don't consider that fair either.
20:04:31 <musasabi> dons: I think I have found the problem, it is CVS related rather than unfairness.
20:04:50 <dons> ah!
20:04:58 <dons> @karma+ musasabi
20:04:59 <lambdabot> musasabi's karma raised to 8.
20:05:30 <stepcut> @karma- CVS
20:05:31 <lambdabot> CVS's karma lowered to -1.
20:08:30 <dons> hehe
20:09:13 <musasabi> it is fixed in the CVS now.
20:11:03 <musasabi> -> sleep (2 hours, till the morning)
20:11:40 <stepcut> I really think 2006 is going to be the year The Hurd takes off
20:11:57 <stepcut> look out linux!
20:28:56 <lispy> stepcut: yes, i replaced all my debian linux installs with debian hurd on jan 1.
20:29:51 <stepcut> I am holding out for Hurd/coyotos
20:30:21 <Heffalump> lispy: surely that should be apr 1?
20:31:10 <lispy> Heffalump: are you suggesting that the Hurd is not ready for ' time?
20:31:28 <lispy> but, joking aside, debian hurd is the best way to install it
20:31:44 <stepcut> there are also some live cds I think
20:31:52 <lispy> i did run hurd for a while, but it was akin to using HP-UX and i realized i was being silly
20:33:27 <lispy> they should just take the ghc run-time and make it run on the bare metal as their microkernel...oh wait...
20:35:26 <stepcut> doesn't hOp/House still run the drivers, etc in kernel space ?
20:36:09 <Heffalump> lispy: me? never ;-)
20:36:16 <lispy> isn't that true of the device drivers in a microkernel?  (I mean drivers that talk to hardware)
20:37:34 <stepcut> lispy: maybe it varies, but I think in hurd/l4 no...
20:38:02 <stepcut> well, that is if they every decide on a device driver framework :p
20:38:10 <ncalexan> @index gets
20:38:11 <lambdabot> Control.Monad.State, Control.Monad.RWS
20:38:16 <ncalexan> @type gets
20:38:17 <lambdabot> Not in scope: `gets'
20:38:25 <ncalexan> @type Control.Monad.State.gets
20:38:27 <lambdabot> forall a (m :: * -> *) s.
20:38:27 <lambdabot> (Control.Monad.State.MonadState s m) =>
20:38:27 <lambdabot> (s -> a) -> m a
20:39:07 <stepcut> page 2 - >http://lists.gnu.org/archive/html/l4-hurd/2006-01/pdfNo8Q93TjwG.pdf
20:39:55 <lispy> stepcut: i think they did, wasn't it called the "in action" framework or something? ;)
20:41:54 <stepcut> lispy: hurd on the l4 has had many different proposals -- I don't think there has been any code written. Of course, hurd/l4 is now decided to abandon l4 and move to something else -- possibly coyotos
20:55:56 <SamB> lispy: how do you run C on top of the GHC rts as a microkernel?
20:56:26 <stepcut> forkProcess
20:56:38 <stepcut> or use the haskell FFI export stuff
20:56:53 <SamB> lispy: if you figure that one out, that would be great, because then you ought to be able to get GHCi going...
20:56:54 <stepcut> err, not forkProcess, execProcess, or whatever it is called
20:57:19 * stepcut confuses himself
20:57:45 <stepcut> runProcess
20:57:46 <SamB> I think jethr0 or Saulzar was working on implementing libc in Haskell...
21:00:12 <palomer> whoa.
21:00:28 <palomer> what will be the equivalent of malloc?
21:04:13 <ncalexan> @djinn (a -> b) -> (a -> m b)
21:04:15 <lambdabot> -- f cannot be realized.
21:04:22 <ncalexan> @type liftM
21:04:23 <lambdabot> Not in scope: `liftM'
21:04:30 <ncalexan> @type Control.Monad.liftM
21:04:32 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
21:04:54 <ncalexan> @index (a -> b) -> (a -> m b)
21:04:56 <lambdabot> bzzt
21:05:27 <Heffalump> @type (return.)
21:05:28 <lambdabot> forall (m :: * -> *) b a. (Monad m) => (a -> b) -> a -> m b
21:05:37 <ncalexan> Cheers.
21:16:24 <Lemmih> dons: OK. I asked because the fix I made depends on Cabal.
21:58:23 <lispy> anyone here use eclipse + haskell plugin to edit code?
22:01:53 <lispy> every line of haskell code that i write in emacs makes me think emacs isn't the right editor
22:07:18 <lispy> shapr: c'mon, back me up here :)
22:07:46 <lispy> shapr: BTW, i started reading pragmatic programmer as you recommended.  I just want to say, Thank you.
22:08:00 <Cale> lispy: I've used mostly emacs and vim. The right editor is future yi :)
22:08:19 <lispy> heh, future yi is fyi
22:08:26 <ncalexan> LOL!
22:08:40 <lispy> Cale: yeah, i want yi to be an ide
22:08:47 * palomer proves that haskell is, contrary to popular belief, not turing complete
22:08:51 <ncalexan> No no, you want hide.
22:09:04 <lispy> ncalexan: hide?
22:09:06 <lispy> palomer: heh
22:09:19 <ncalexan> The grand plan is that yi will be the editor plugin of the Haskell IDE.
22:09:23 <palomer> I'll start using yi when they speed up character input
22:09:30 <ncalexan> I know nothing about the development of hide.
22:09:54 <lispy> palomer: hmm...it's not as fast as vi in that regard, but i didn't find it to be too slow
22:10:10 <Cale> I don't completely understand why the two should be separate. One plugin framework really ought to be enough :)
22:10:19 <palomer> I'm quite a stickler when it comes to character input
22:10:28 <ncalexan> Cale: powers that be.
22:10:40 <lispy> ncalexan: then in the mean time, i'll give eclipse (yet another try with open mind) and try out this haskell plugin that parses the code and lets you do refactoring
22:10:50 <ncalexan> lispy, palomer: what yi were you using?  curses or gtk?
22:10:51 <palomer> eclipse has slow character input too
22:10:56 <palomer> ncalexan: ncurses
22:11:12 <lispy> ncalexan: ncurses, circa last summer
22:11:24 <palomer> dons says he's going to fix this someday
22:11:26 <lispy> palomer: boo! @ eclispe
22:11:29 * palomer hopes for sooner not later
22:11:34 <lispy> palomer: patch it yourself! ;)
22:11:50 <Cale> palomer: btw, I hope you're kidding. It would be quite easy to implement a Turing machine in Haskell.
22:11:50 <palomer> internet explorer has really fast character input
22:12:36 <palomer> how can you NOT think I was kidding?
22:12:38 <lispy> palomer: do you use IE widgets to edit your code? ;)
22:12:50 <palomer> windows in general has fast character input
22:13:02 <lispy> what impresses me more than haskell's lack of TMC, is that ghc solves the halting problems
22:13:03 <palomer> it's a real pleasure typing in windows
22:13:14 <Cale> palomer: occasionally you say some pretty bizarre things ;)
22:13:20 <palomer> Cale: for example?
22:13:38 <lispy> palomer: is editing slow in other OSs you use?
22:13:45 <Cale> I can't remember what the previous one was -- it was a lot saner than that, for sure
22:13:49 <palomer> it's rather slow in linux under X
22:13:58 <lispy> um...
22:14:11 <palomer> Cale: renaming monad and pluralizing type names
22:14:22 <palomer> though it's blazing fast in linux console
22:14:23 <lispy> i've never experienced slow character entry in X
22:14:44 <palomer> lispy: oh, it's nothing huge, but it's something I notice
22:14:45 <Cale> and what's this about the speed of text input? I can't type 200 chars/second, so I usually don't notice.
22:14:46 <lispy> i've noticed my ibook has slow character entry sometimes, but nothing to worry about it
22:14:59 <palomer> most people wouldn't notice
22:17:07 <lispy> one of the things that gets me about eclipse is the way it wants to jam everything into some directory somewhere...oh wait...keeping an open mind this time....
22:18:01 <palomer> eclipse takes too much of my screen space for non code
22:18:21 <lispy> palomer: you'd really hate visual studio
22:18:23 <palomer> emacs is the best for me, really, 98% or so of my screen is code reachable
22:18:29 <Heffalump> it's not the speed per se, it's the lag.
22:18:41 <palomer> Heffalump: is there really a difference?
22:18:53 <lispy> palomer: if you find yi slow at character input, don't you find the same of emacs?
22:19:00 <Heffalump> I noticed it with eclipse the last time I tried it
22:19:01 <ncalexan> throughput vs. latency.
22:19:59 <palomer> emacs is the best of the bunch, along with kate
22:20:15 <palomer> emacs console is way fast
22:23:53 * palomer wonders which parsing technology yi will prefer
22:24:04 <ncalexan> palomer: what would you prefer?
22:24:29 <palomer> sablecc:P
22:24:49 <ncalexan> That's not a very haskell-ish solution.
22:25:22 <ncalexan> Plus, I think that's just LR(k) or LALR or some small class.
22:25:24 <ncalexan> Why limit?
22:26:24 <palomer> because I'm sick of rewriting my grammars for every language I use
22:26:36 <palomer> (literally rewriting)
22:27:01 <palomer> one parser generator for all languages
22:27:04 <ncalexan> Point.
22:27:53 <palomer> I'm waiting for sablecc 4 to come out
22:29:03 <palomer> then I'll write a haskell plugin
22:29:18 <lispy> yi will uses ghc's parser, iirc it's in theworks
22:29:30 <palomer> ghc has a parser generator?
22:29:35 <dons> sigh, palomer brings this input thing up every time, and doesn't submit any patches. it's practically FUD :/
22:29:45 <lispy> palomer: oh, for haskell it will use ghc's
22:30:33 <lispy> dons: how is yi these days?  I was all excited this summer and going to submit patches and then school came about and i got lost in the trenchs
22:30:58 <palomer> FUD?
22:31:14 * palomer helps lispy out of the trenches
22:31:44 <lispy> palomer: fear-something-something, it's like when MS puts out marketing stuff that borders on lies just to make a competitor look bad.  It's corporate propagando
22:31:55 <lispy> propaganda
22:31:56 <palomer> oh, I'm not trying to make people fear yi
22:32:07 <palomer> FEAR YI!
22:32:16 <Korollary> fear, uncertainty & doubt
22:32:31 <lispy> Korollary: thanks
22:32:56 <palomer> eh, emacs mode for yi doesn't have C-x C-w !
22:33:16 <ncalexan> Nor does it have M-C-q.
22:33:25 <ncalexan> Or a host of other things.
22:33:26 <ncalexan> And yet...
22:33:54 <lispy> palomer: once upon a time i was going to write an elisp interpreter as a plugin for yi, i never finished the parser...
22:34:30 <palomer> my god, do you have any idea what kind of a monster is elisp?
22:35:28 <lispy> but it would make the transition easier for me, at least back then when i was glued to gnus
22:35:32 <palomer> are the semantics even clearly exposed anywhere?
22:35:47 <dons> by the way, the `emacs' mode does write files :/ remember there are *3* emacs modes
22:35:51 <lispy> sure, in emacs, when in doubt, check the reference implementation
22:35:59 <dons>   ("write-file",
22:36:00 <dons>         [[c_ 'x', c_ 'w']],
22:36:01 <dons>         msgE "Write file: " >> cmdlineFocusE >> metaM writeFileMap)
22:36:16 <palomer> I see emacs and emacs2
22:36:27 <lispy> emacs-ng or something was the other one
22:36:43 <dons> maybe you should read the src first palomer, before speaking from authority
22:36:44 <dons> sigh
22:37:03 <palomer> what did I say which is the least bit controversial?
22:37:08 <palomer> everything I've said is factual!
22:37:18 <palomer> (they aren't criticisms)
22:37:23 <ncalexan> palomer: come off it... innocence doesn't become you.
22:37:49 <palomer> I'm innocent I tell you!
22:38:05 <palomer> so how do these haskell plugins work, exactly?
22:38:15 <palomer> is there some magic mumbo jumbo going on?
22:38:44 <lispy> palomer: look at the documentation for hs-plugins
22:39:01 <lispy> i don't know exactly how it works, but dons has a paper or two about it at his site
22:39:24 <lispy> it sort of like, you read the .hi files and load things that way
22:39:40 <dons> yeah, I think i'll title my PhD: "magic mumbo jumbo"
22:40:00 <lispy> heh
22:40:11 <lispy> dons: it wouldn't be the first thesis on that topic ;)
22:40:14 <dons> hehe
22:40:16 <ncalexan> Y'know, enough theses go unread by the committee that it might not matter.
22:41:36 <dons> :)
22:42:29 <Korollary> I'd like some comics for a change instead of references.
22:42:42 <dons> oh that is such a good idea!
22:42:56 <dons> I really like that :)
22:43:08 <palomer> someone write a limerick about theses
22:43:19 <ncalexan> Better yet, your annotated bibliography should be in comic form.
22:43:27 <ncalexan> Recounting your experiences with each reference.
22:44:21 <Cale> dons: the trick is to pick two areas where it's really unlikely that someone who has to review the thing will be an expert on both of them, and combine those.
22:45:06 <palomer> south african botany and higher order unification
22:45:14 <dons> ah, very cunning. hmm.. like type theory and ummm... dynamic linking!
22:45:22 <ncalexan> LOL!
22:45:56 <dons> fingers crossed ;)
22:46:19 <palomer> "dynamic linking" is a field of study?
22:46:27 <palomer> what about "array updating" ?
22:46:47 <lispy> palomer: do your feet taste good? ;)
22:46:48 <ncalexan> sigh.
22:46:54 <palomer> >:O!
22:47:00 * hellish read that as dynamic licking.
22:47:17 <palomer> I kid I kid
22:47:26 <lispy> good
22:47:30 <lispy> so do i
22:48:38 <lispy> okay, i'm getting happier with eclispe.  I went to "File -> New Project" and the first choice is "Haskell Project"
22:49:15 <lispy> i installed the darcs plugin too,
22:50:27 <lispy> of course, next thing that happens is a run time error haskell plugin
23:16:57 * Cale wonders if it's too late to join the Haskell' committee
23:36:10 <Lemmih> It's never to late to join a Docracy, I think.
23:42:56 <Cale> Lemmih: well, one can't participate on the wiki/trac without an account
23:43:34 <Cale> I'm on the mailing list though, and have a few messages to send in my head once I have time.
23:47:05 <Lemmih> I can give you an account if you want.
23:47:53 <Cale> that would be cool
