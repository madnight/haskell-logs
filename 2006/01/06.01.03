00:00:27 <palomer> int-e: gotcha
00:00:30 <gizban> how do I convert an Integer to an Int?
00:00:38 <Cale> gizban: fromIntegral
00:00:45 <Cale> gizban: didn't you ask that before?
00:00:56 <gizban> doesn't that convert Int to Integer?
00:01:01 <Cale> does both
00:01:04 <int-e> @type fromIntegral
00:01:05 <Cale> @type fromIntegral
00:01:05 <lambdabot> forall b a. (Num b, Integral a) => a -> b
00:01:07 <lambdabot> forall b a. (Num b, Integral a) => a -> b
00:01:10 <Cale> hehe
00:01:11 <int-e> :P
00:01:35 * palomer ponders skipping the first day of school
00:01:43 * palomer agrees that it's the smartest thing to do
00:01:45 <gizban> this book I have isn't very helpful
00:01:58 <Cale> I wish it'd try to line up the order of occurence of the class constraints with the order of the type variables in the type
00:02:08 <int-e> palomer: I'm sure you'd regret it
00:02:11 <Cale> gizban: which one?
00:02:23 <palomer> int-e: I could skip the first half of the semester and not miss a thing
00:02:34 <gizban> Addison Wesley, Haskell The Craft Of Functional Programming (1999)
00:02:39 <palomer> I'm taking one course, and it covers the first half of the TaPL
00:02:44 <ibid> palomer: ok, found my mistake. again, what's the problem?
00:02:59 <palomer> ibid: trying to find a generic way of doing it
00:03:03 <Cale> @google Yet Another Haskell Tutorial pdf
00:03:07 <lambdabot> http://www.isi.edu/~hdaume/htut/tutorial.pdf
00:03:13 <palomer> YAHT > craft?
00:03:24 <Cale> palomer: I don't know, but it's another option :)
00:03:33 <ibid> palomer: generic in what sense?
00:03:38 <palomer> what's that algorithms in haskell book?
00:03:55 <Cale> hmm, did Okasaki do one?
00:03:58 <ibid> which one?
00:04:02 <ibid> there are two
00:04:06 <palomer> the one from UdeM
00:04:12 <Cale> I seem to recall his was in Lazy-ML or something
00:04:19 <ibid> the textbook and the scientific monograph
00:04:22 <palomer> ibid: generic in the sense that I can express it in terms of typechecking other terms
00:04:24 <Cale> or some variant of ML with laziness annotations
00:04:28 <palomer> ibid: as a type rule
00:04:56 <ibid> palomer: i don't see where's the problem in that?
00:05:16 <ibid> ah yes, the okasaki one was only partially haskell
00:05:18 <palomer> Algorithms: A Functional Programming Approach
00:05:29 <ibid> yeah
00:06:16 <palomer> hrm, I'll have to derive a typing rule for let
00:06:33 <palomer> ibid: you've given me a method, not a type rule
00:06:39 <palomer> a deduction
00:06:46 <palomer> something with a horizontal line seperating two things
00:06:50 <ibid> palomer: i described a derivation :)
00:06:58 <ibid> palomer: you hadn't asked for the type rules :)
00:09:44 <palomer> hrm, the type rule will have to explicitly mention constraints
00:10:20 <palomer> so wait, the ghc extensions allow binders to be universally quantified?
00:10:33 <int-e> hmm - yes, that's what I've learned actually - introduce type variables for each subterm and find the type constraints (equations) - then solve that system with unification
00:10:47 <int-e> (for typed lambda calculus)
00:11:09 <palomer> but for typed lambda calculus you don't have recursion
00:11:23 <palomer> or universal types
00:11:29 <gaal> What am I doing wrong? I'm handing off a stable pointer to a Haskell structure to a c lib with FFI, and in the Haskell callback where I try to deref it, I get a segfault. The pointer itself is correct (the address I store is the address I get in the callback). Ideas? Directions?
00:11:59 <int-e> palomer: universal types are a problem. recursion just means that the same subterm occurs in several places - I don't see a problem there
00:12:27 <palomer> int-e: recursion is much more than that. all terms in typed lambda calculus normalize
00:12:27 <gaal> freezeNode node = do { ptr <- newStablePtr node ; new (castPtr $ castStablePtrToPtr ptr) }
00:12:53 <gaal> thawNode nodePtr = do { let ptr = castPtr nodePtr ; deRefStablePtr (castPtrToStablePtr ptr) }
00:13:27 <palomer> what's the shortest expression of type forall x.x (which is not "undefined") ?
00:14:18 <int-e> fix id ?
00:14:28 <ibid> palomer: i think i have a first stab at at a let typing rule (but which requires a "GEN" type transfomer)
00:14:50 <ibid> palomer: i don't think that type has any values except undefined
00:15:37 <int-e> @type Control.Monad.Fix.fix id
00:15:38 <lambdabot> forall a. a
00:15:49 <C-Keen> re.
00:16:11 <ibid> int-e: and that's distinguishable from undefined by ...?
00:16:30 <palomer> ibid: I meant syntactically different, not semantically different
00:16:39 <int-e> ibid: nothing without using the IO monad.
00:16:42 <ibid> well, ok
00:17:02 <ibid> let f = f in f, but fix id is a shorter way of saying that :)
00:17:25 <palomer> let f = f in f 
00:17:27 <ibid> (if you allow the functions fix and id without requiring their definitions to count)
00:17:29 <palomer> > let f = f in f 
00:17:30 <lambdabot> Add a type signature
00:17:33 <palomer> @type let f = f in f 
00:17:34 <int-e> semantically, it has to be bottom, because its value has to inhabit empty types.
00:17:35 <lambdabot> forall t. t
00:17:57 <palomer> ibid: what's GEN?
00:18:15 <ibid> palomer: "add a forall for every free type variable"
00:18:20 <ibid> palomer: ie. generalize
00:18:25 <palomer> oh, that's fine
00:18:45 <ibid> but now that i think of it, my rule is too powerful
00:18:55 <ibid> it requires a cut, too, to work as in HM
00:19:03 <palomer> yeah, be careful not to tread in the system F waters
00:19:07 <palomer> hrmph
00:19:09 <palomer> I have to get some sleep
00:19:10 <palomer> night!
00:25:09 <ibid> palomer: you might find http://haskell.org/definition/long-semantics.ps.gz interesting
00:25:19 <ibid> palomer: (old, obsolete draft for haskell static semantics)
01:42:02 <MarcWeber> Is "return a = Cont ($a)" equal to "return a = Cont (lp a)rp" with lp=( and rp=) ? 
01:42:38 <Cale> huh?
01:42:55 <Cale> ($a) = \x -> x $ a
01:51:26 <MarcWeber> Cale: I thought "blah $ blah2 \n" is translated into "blah (blah2) \n" ..  But obviously not if beeing in parenthesis
01:53:41 <ibid> uh, that's a string, it's not translated to anything
01:53:51 <ibid> (or what does the \n part mean?)
01:55:00 <MarcWeber> ibid: End of line.. "" should have been some help to recognize the important phrases of my message .. It wasen't ment to be a string ;-)
01:55:21 <Cale> $ is an operator defined in the prelude
01:55:27 <Cale> f $ x = f x
01:55:29 <ibid> MarcWeber: i mean, if i interpret "" as not a string delimiter, then the \n part makes no sense
01:55:59 <ibid> MarcWeber: if yyou meant blah $ blah2 "\n", then it's translated to blah (blah2 "\n")
01:56:05 <Cale> with infixr 0 $
01:57:04 <Cale> which means that it binds very weakly, whereas ordinary application binds strongly (stronger than any operator)
01:57:37 <ibid> ah, i think i now get it, you meant to say, blah $ blah being the last thing on the line. but then the question is unanswerable, because we need to know what the next line says :)
01:57:48 <Cale> so  f x y = (f x) y, whereas f $ x y = f (x y)
01:58:09 <ibid> but the rule of thumb is that "whenever you see $, add a (, and then put the corresponding ) as far away as possible"
01:58:28 <Cale> similarly,  f . g h = f . (g h) whereas f . g $ h = (f . g) h
01:58:49 <Cale> I use that latter one a lot
01:59:16 <Cale> does that make sense?
02:03:06 <MarcWeber> ibid: I didn't know how to indicate the end of a line.. So I used \n beause I thought most people might understand it.. Cale: Which rule is used to translate ($a) to x -> x $ a ?
02:03:11 <stesch> Cool. Haskell still on page 1 on reddit. Place 5, 31 points.
02:03:44 <stesch> There are only 10 Haskell links on reddit. (Search)
02:06:05 <ibid> MarcWeber: the standard rule that when op is an operator, then (op a) ==> \x -> x op a
02:06:19 <ibid> MarcWeber: i found the \n confusing, as it's usually only used inside strings :)
02:06:32 <int-e> MarcWeber: IIRC the rule is ($ x) = flip ($) x
02:08:31 <Cale> <Dogan> but I knew this one mathematician guy in college
02:08:31 <Cale> <Dogan> he tried to apply for a grant to get funding for his project
02:08:31 <Cale> <Dogan> and on the form he said his project involved "studying the effects of tropical vacations on mathematicians"
02:08:54 <MarcWeber> int-e: Where can I find this definition?
02:09:09 <Cale> MarcWeber: in the Report
02:09:21 <Cale> http://www.haskell.org/onlinereport/standard-prelude.html -- for the prelude
02:09:42 <Cale> one sec while I find the part on operator sections
02:09:57 <Cale> http://www.haskell.org/onlinereport/exps.html#sect3.5
02:10:27 <MarcWeber> I know I can use (2 -) beeing expanded: \x -> 2 - x.
02:10:49 <MarcWeber> Can I also use ( - 2) which should be expanded to \x -> x - 2 ?
02:10:50 <Cale> Because - is treated specially in the grammar, (- exp) is not a section, but an application of prefix negation, as described in the preceding section. However, there is a subtract function defined in the Prelude such that (subtract exp) is equivalent to the disallowed section. The expression (+ (- exp)) can serve the same purpose.
02:12:00 <int-e> copy and paste is great :)
02:12:05 <Cale> :)
02:13:14 <Cale> Especially with the "as described in the preceding section"
02:13:38 <MarcWeber> //www.haskell.org/onlinereport/exps.html#sect3.5
02:13:49 <Cale> yeah, that's what I pasted :)
02:13:53 <MarcWeber> Sorry.. pasted by mistake..
02:13:58 <Cale> ah :)
02:14:39 <MarcWeber> It's kind of complicated I'm using irssi on gentoo linux running with colinux on windows.. I connect via putty.exe And sometimes I paste accidently by clickking with the right mouseb.
02:14:52 <Cale> hehe
02:15:06 <Cale> prefix negation should require no space between the - and what's being negated, then we could use (- 1)
02:15:29 <int-e> @type (-1+)
02:15:30 <lambdabot> forall a. (Num a) => a -> a
02:15:41 <xerox> > (-1+) 1
02:15:42 <lambdabot> 0
02:15:55 <xerox> Good morning :-)
02:16:01 <Cale> goodnight :)
02:16:19 <dons> (-1+) is a nice little trick
02:16:20 <int-e> I think (-1+) is not very pretty but beats (subtract 1) by a mile.
02:16:24 <Cale> er, it does happen to be early morning I guess :)
02:18:45 <MarcWeber> This is the solution: ( (-) 2) ;-)
02:19:40 <int-e> uhm
02:19:49 <int-e> > ((-) 2) 42
02:19:51 <lambdabot> -40
02:19:52 <int-e> are you sure?
02:20:27 <int-e> oh, why does (`(-)` 2) not work?
02:20:50 <int-e> (probably the syntax requires an id between `` ....)
02:21:54 <MarcWeber> int-e: No, I'm not.. you are right.. ! I was so convinced by my idea.. that I haven't read the result thoroughfully enough ;-(
02:25:38 <shapr> @yow !
02:25:39 <lambdabot> What PROGRAM are they watching?
02:27:24 <MarcWeber> int-e: I think I have to read the Prelude before beeing able to answer you question. :t (/) is equal to :t (-) and (/2) 3 = 1.5 and (2/)3 =0.6666 is working as expected ..
02:28:22 * shapr boings cheerfully
02:28:26 <shapr> It's sunny! w00!
02:29:12 <m3ga> shapr: you should have some of the sun around here. We had 44 degrees C the day before y'day!
02:30:37 <xerox> Yow, shhhaper.
02:30:42 <mjl69> > concat( map (\x->[x,x*x,x*x*x]) [1,2,3])
02:30:44 <lambdabot> [1,1,1,2,4,8,3,9,27]
02:31:18 <mjl69> so that's why you need a->m b
02:31:23 <int-e> MarcWeber: my guess was right
02:32:21 <int-e> MarcWeber: and the prelude won't help you much there; the special handling of - is a language syntax issue
02:32:25 <MarcWeber> int-e: I can't understand your guess by now.. I'm not sure what you mean by id..
02:32:35 <xerox> > [1,2,3] >>= \x -> [x,x*x,x*x*x]
02:32:37 <lambdabot> [1,1,1,2,4,8,3,9,27]
02:32:41 <int-e> MarcWeber: and identifier
02:32:54 <MarcWeber> How does haskell now wether I want (-1) beeing substraction op or negotiation op?
02:33:15 <int-e> MarcWeber: it doesn't. it just parses it as the negation
02:34:09 <MarcWeber> How can I tell haskell to use substraction? I know it must be there as ghci :t (-) tells me a-> a-> a
02:34:53 <MarcWeber> How does an id look like in your example `(-)` ? I can't imagine one
02:35:14 <int-e> you use a desugarized version, either \x -> (x-1) or (flip (-) 1); or something that's equivalent, like (-1+) (that's ((-1)+) )
02:35:36 <int-e> MarcWeber: (-) is not an id - it's the function version of a binary operator.
02:36:31 <int-e> MarcWeber: or, you use a utility function, like (subtract 1)
02:36:54 <int-e> that's the sole reason why subtract exists at all
02:38:18 <MarcWeber> Having a - b: Is - `substract` here ?
02:38:54 <xerox> @type subtract
02:38:55 <lambdabot> forall a. (Num a) => a -> a -> a
02:39:03 <xerox> @type (-)
02:39:04 <lambdabot> forall a. (Num a) => a -> a -> a
02:39:36 <m3ga> people, is there some more up-to-date docs for parsec than http://www.cs.uu.nl/~daan/download/parsec/parsec.html? The module names have changed and many of the examples don't work.
02:39:54 <int-e> MarcWeber: no, subtract has the arguments reversed
02:39:55 <xerox> m3ga: what's the problem?
02:40:03 <int-e> MarcWeber: subtract = flip (-)
02:40:17 * JKnecht thanks dons for HWN.
02:40:17 <xerox> > (1 - 2, 1 `subtract` 2)
02:40:18 <lambdabot> (-1,1)
02:40:32 <int-e> b - a  equals  a `subtract` b
02:40:59 <m3ga> xerox: i'm working through the examples and many of them don't work. i'm  pretty new to haskell and the compiler error messages don't help me much :-)
02:41:01 <xerox> > (1 - 2) == (subtract 2 1)
02:41:02 <lambdabot> True
02:41:34 <xerox> m3ga: I don't know of online examples resources, you could try ask here about your doubts, if you wish.
02:42:16 <m3ga> lisppaste2: where?
02:42:28 <xerox> lisppaste2: url
02:42:28 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
02:43:55 <shapr> m3ga: I'm jealous
02:44:13 <xerox> Why so? :-)
02:46:17 <lisppaste2> m3ga pasted "problems with parsec examples" at http://paste.lisp.org/display/15316
02:46:47 <m3ga> shapr: you do **not** want 44 degrees C
02:47:57 <MarcWeber> int-e: Can you explain me once again why ( ´(-)´ 2) doesn't work?
02:48:40 <xerox> Backticks want an id between them, and (-) isn't one, I think.
02:50:15 <MarcWeber> Thanks id=[a-zA-Z0-9] or something like that! yeah!
02:50:27 <ndm> MarcWeber: its do do with infix and prefix operators
02:50:38 <ndm> prefix operators are like names, such as subtract
02:50:45 <ndm> infix operators are symbols, like -
02:50:51 <int-e> MarcWeber: because (-) is not an identifier. see http://www.haskell.org/onlinereport/exps.html#sect3.2 (note that haskell distinguishes symbols and identifiers)
02:50:58 <ndm> to make an infix operator a prefix one, add brackets (-)
02:51:09 <ndm> to make a prefix one an infix, and backticks `subtract`
02:51:25 <ndm> hence `(-)` is just the same as -, hence not needed
02:52:11 <tromp_> except that (-)1 differs from -1
02:52:59 <MarcWeber> ndm: no it's not because (`(+)` 2) 3 doesn't compile but (+ 2) 3 ;-)
02:53:30 <ndm> MarcWeber - you can't actually do it, but if you think of that way, you'll realise there would never be any reason to
02:54:29 <int-e> ndm: well, we had one use: (`(-)` 1)
02:55:11 <tromp_> that reminds me of a saying...
02:55:14 <ndm> its a shame, i'm quite surprised to find that "-                    1 " is treated as -1
02:55:23 <tromp_> two wrongs don't make a right, but three lefts do
02:55:57 <tromp_> are you more suprised about -              1 than about - 1 ?
02:56:01 <MarcWeber> ndm: Of cause there wouldn't except of thinking  (`(-)` a)  of beeing equal to (subtract a), (flip (-) a) because reading - as negotiation op wouldn't make sense.. *lol* 
02:56:33 <ndm> tromp_: i realise the first is logical from the second, but both seem a little nutty
02:56:42 <ndm> in the same way that 1                       2 isn't 12
02:57:05 <flux__> so - 1 + 1 should be an error?
02:57:10 <MarcWeber> a b = 10*a+b ? ;-)
02:57:39 <tromp_> so you'd want the lexer to lex -12 as a single token?
02:57:52 <ndm> tromp_, yes, i would
02:58:07 * int-e would, too
02:58:12 <tromp_> then it would become more context sensitive
02:58:20 <tromp_> since 1-12 should be lexed differently
02:58:21 <xerox> m3ga: problem seems to be, to me, that reservedOp takes TWO arguments.
02:58:42 <ndm> tromp_: maybe its wrong to have - mean both negation and subtraction
02:58:49 <xerox> m3ga: that is, reservedOp :: TokenParser st -> String -> CharParser st (), and it misses a 'String' there.  Doesn't it?
02:58:52 <ndm> perhaps ~1 should be (-1) literal
02:58:59 <m3ga> xerox: yes, but which two :-)
02:59:24 <tromp_> i agree you don't really need unary -
02:59:32 <tromp_> you can just write 0-1 :)
02:59:47 <int-e> or use negate
03:00:10 <ndm> unfortunately i'd consider this a bug in maths, rather than haskell
03:00:17 <ndm> overloading of one symbol for two meanings
03:00:23 <MarcWeber> ndm: !!! great!
03:01:16 <MarcWeber> Even excel has some kind of mistake interpreting - .. gnumeric is adding extra () to show the user the ambiguity .. ;-)
03:01:33 <m3ga> xerox: got it!  -->  Infix (do { reservedOp lexer s ; return f } <?> "operator") assoc
03:01:36 <xerox> m3ga: fix it by passing the 'lexer' as its first param.
03:01:41 <xerox> m3ga: that's right.
03:01:48 <m3ga> :-)
03:01:55 <m3ga> thanks xerox 
03:02:00 <xerox> You're welcome!
03:03:05 <m3ga> i've been using ocaml for over a year, but haskell still has some real surprises and inscruitabilities
03:27:23 <kzm> anybody know where to find daVinci bindings for Haskell?
03:28:52 <kzm> I find some references (on haskell.org, among other places) but the links mostly turn up dead.
03:29:13 <kzm> (didn't somebody mention UniForM the other day?)
03:30:00 <basti_> what is "davinci"?
03:30:49 <kzm> graph library.  Actually called uDraw(Graph) now, due to a name conflict.
03:31:31 <kzm> http://www.informatik.uni-bremen.de/uDrawGraph/en/index.html
03:31:44 <basti_> ah
03:32:06 <kzm>  Leonardo da Vinci is a registered trademark of Hans-Georg MÃ¼ller, Gelsenkirchen, Germany
03:32:19 <basti_> :-o
03:32:28 <xerox> @karma- Hans-Georg_MÃ¼ller
03:32:29 <lambdabot> Hans-Georg_MÃ¼ller's karma lowered to -1.
03:33:01 <sieni> M-A-tilde-one quarter-ller?
03:33:30 <xerox> Muller, with ':' above the 'u'.
03:33:55 <xerox> Get UTF-8!
03:35:23 <kzm> I'm unable to find what he is using the trademark for (except bullying nice and generous software authors)
03:35:51 <kzm> Anyway, I guess that's a "no", then?   :-)
03:39:44 <basti_> apparently... ^^
03:49:01 <kzm> Hmm - found Martin Erwig's FGL, and some stuff by Paul Callaghan.  Anybody know them (either the people or their software)?
03:50:15 <kzm> In particular, the FGL User Guide is very dated.
03:56:08 <shapr> Erwig's papers describe the ideas (like inductive graphs) behind the library, but I never got any further than that.
03:56:31 <shapr> kzm: And yez, UniForM has the source for the daVinci bindings
03:57:40 <shapr> But a few years back, when  I tried to get that whole package to work, daVinci's wrapper protocol had changed dramatically and I couldn't even get the two versions old antique free-as-in-binary version to run.
03:58:49 <shapr> kzm: I also heard some rumors that some or all of the daVinci PTC (Patent, Trademark, Copyright) had been sold to IBM for their data visualizer tools. I dunno if that's true though.
03:59:57 <kzm> Hm.  At least the uDraw(Graph) site seems to contain recent, live information.
04:00:33 <kzm> Any UniForM info I found appeared bit-rotted...
04:01:18 <kzm> Well, I got the uD(G) stuff downloaded, and will take a quick look.  As for bindings, well, I have to learn to use the FFI sooner or later :-)
04:01:43 <kzm> I guess a mail to Erwig and Callaghan may be worth the trouble as well.
04:01:51 <shapr> There's an anonymous UniForM repo online somewhere, and it's has a whole lotta Haskell source in there.
04:02:10 <shapr> One of the minor libs is a Tk binding.
04:02:39 <shapr> I think it also includes an emacs binding
04:05:53 <psnl> I know Callaghan
04:06:22 <shapr> kzm: Want to write a TMR tutorial article for FGL? =)
04:06:24 <kzm> psnl: hmm...any chance of getting him online? :-)
04:06:41 <kzm> shapr: love to.  Perhaps in a year or so? :-)
04:07:04 <kzm> Let me at least get the user guide off the printer :-)
04:07:11 <psnl> kzm: on irc? no. email he replies to
04:07:38 <psnl> p.c.callaghan@dur.ac.uk
04:07:53 <kzm> Happen to know the extent of his involvement with daVinci and/or FGL?  And/or any working code repo I can lay my sweaty palms on?
04:08:27 <kzm> Anyway, I'll mail him.  Thanks!
04:09:26 <psnl> I assme you have seen http://www.informatik.uni-bremen.de/uDrawGraph/en/index.html
04:10:25 <psnl> how do you define the Ord functions on a type?
04:12:07 <shapr> You only need to define the compare function for the Ord typeclass.
04:12:34 <shapr> @type compare
04:12:35 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
04:13:29 <Lemmih> Either compare or <=.
04:15:51 <tromp_> hi shapr
04:16:19 <psnl> so you define a function (<=) :: t->t->Bool where t is your type?
04:18:02 <Lemmih> psnl: 'instance Ord YourType where t1 <=/`compare` t2 = ...'
04:18:14 <kzm> psnl, thanks (for the URL), but yes, I've got it.
04:19:23 <kzm> Lemmih, don't use slashes like that, it melts my BRANE. :-)
04:20:08 <psnl> thanks, that seems to work
04:29:42 <earthy> yaay. higher-kinded polymorphism.
04:30:09 * earthy hugs GHC ;)
04:31:57 <shapr> hoi tromp_ 
04:39:51 <tromp_> i found an excellent discussion of obfuscators, if you're still interested:)
04:40:35 * int-e would be
04:43:20 <tromp_> http://www.cs.princeton.edu/~boaz/Papers/obf_informal.html
04:58:03 <shapr> tromp_: My goal is really operations on encrypted data, but if obfuscators fits that subject, I like it.
04:59:10 <shapr> tromp_: this is what I want: http://www.scannedinavian.com/2005-12-05.html - some way to anonymize operations sufficiently to encourage cooperation.
05:01:35 <shapr> Hm, anonymization would be obfuscation.
05:02:42 <MarcWebe1> Do you now some easy understandable continuation monad example?
05:04:00 <JKnecht> what did Heinlein say about cheating at Solitaire?
05:04:01 <shapr> tromp_: This is an excellent link, thanks!
05:05:51 * int-e likes the notion of a hopeful addition.
05:06:49 <shapr> JKnecht: Roughly that a person who violates their own rules is below contempt, but that doesn't begin to cover the whole range of whathe meant.
05:08:06 <MarcWeber> @index exit2
05:08:07 <lambdabot> bzzt
05:08:46 <tromp_> i think the word  Provable has no place on that page, shapr:)
05:09:36 <tromp_> your description is very far from being formalized enough to consider provable properties
05:10:02 <MarcWeber> What does lambdabot mean by saying bzzt? Not found?
05:11:15 <JKnecht> shapr: hmmm, yeah that sounds like something a person who romanticizes Fascism would say. 
05:12:17 <Itkovian> shapr: I followed your book advice, having received the Dead Reckoning book. So far it is excellent. Thx.
05:14:54 <MarcWeber> Can you think of two different instances of monad m () ?
05:21:16 <MarcWeber> I don't understand how the when monad is used...
05:23:58 <JKnecht> MarcWeber: http://www.isi.edu/~hdaume/htut/ has a nice tutorial on Monads.
05:25:12 <Saulzar> Hmm, my program is leaking memory like a seive and  by far the massive item on the list when profiling is "integral" from Yampa, what does that tell me?
05:29:00 <JKnecht> I think it tells us your program isn't just Haskell.
05:30:57 <Saulzar> Hmm, how'd you mean? I profiled a cut down version without any gui, libs etc.
05:31:31 <JKnecht> You mean it is pure Haskell? Hugs or GHC?
05:31:36 <Saulzar> More importantly, (I assume it is a problem with how I use it...), how can I tell if it is likely a problem with laziness accumulating or?
05:31:38 <shapr> tromp_: Yeah, fair enough. I'll write a followup post that says "In the case of truly anonymous distributed processing where the results can still be accessed, altered results are detectable."
05:31:51 <Saulzar> Yeah, pure haskell. GHC
05:32:59 <JKnecht> How do you distinguish GC failure from just being space complex/inefficient?
05:33:27 <musasabi> JKnecht: the most probable reason is a space leak in the code.
05:34:33 <Saulzar> Well, it runs iteratively... and memory use progressively rises a few Mb every second
05:35:07 <musasabi> that sounds very much like a space leak.
05:35:34 <musasabi> and if it is that large then tracing it should not be that hard
05:36:33 <JKnecht> If it were Lisp consing out of control would be equally suspect. I should think a similar thing would apply to Haskell so that inferring GC failure would be less than certain.
05:36:41 <Saulzar> Well, I've profiled it and it plonks 75% of the cpu/memory in 2 functions from Yampa
05:36:51 <musasabi> the basic problem is probably that you are keeping around references to stuff that you don't need anymore (either due to data structures or lazyness)
05:37:46 <shapr> Itkovian: Glad you enjoy it. That book is furnishing me with hours of fun.
05:38:20 <shapr> I've been reading the section on logarithms the last few days, and I'm starting to wonder how the pattern behind logarithms can be generalized.
05:39:45 <lennart> shapr: have you read Conor McBride's stuff on taking the differential of a data structure?
05:40:03 <shapr> Logarithms are a cute way to pull operations one step down the scale of operators {addition, multiplication, exponentiation, and tetration} , but.. what's the generalized version?
05:40:43 <shapr> lennart: No? But I shall ask google.
05:41:13 <shapr> Oh, this is in relation to psychological compression?
05:41:16 * shapr hops excitedly
05:41:39 <lennart> No, it was more related to logarithms
05:41:57 <lennart> So the derivative of a data type is its zipper.  Which is cool.
05:42:16 <basti_> should i rewrite Data.Set to handle intervals?
05:42:24 <shapr> huh, wow
05:42:32 <musasabi> what is the integral?
05:42:38 <Saulzar> Heh, I run the robot soccor demo from Yampa and it seems to have a space leak too, has crept up from 0.8% to 11% 
05:43:00 <shapr> Surprising
05:43:04 <musasabi> basti_: wasn't something like that announced to the lists ?
05:43:12 <basti_> there was?
05:43:17 <musasabi> I think so.
05:43:19 <basti_> like where?
05:43:28 * basti_ isnt reading the lists all that much
05:43:30 <musasabi> on sf.net, was announced to the haskell-lists.
05:44:00 <musasabi> (I don't remember the exact url, and don't get to mails from here)
05:44:00 * basti_ looks
05:44:30 <musasabi> If someone has used that I would be interested whether it handles inverse operations well
05:44:48 <shapr> I wonder if Oleg's zipper articles reference this.
05:45:02 <Saulzar> The integral is a signal function which keeps some state (sums up the previous inputs)
05:45:11 <Itkovian> shapr: I'm still in the primitives section on division :-)
05:45:26 <basti_> is there a decent search interface to the lists?
05:45:32 <shapr> Itkovian: me too, but I get bored and skip onto the later sections as they're mostly independent.
05:45:56 <Itkovian> haha
05:46:33 <basti_> musasabi: when was this announcement, roughly?
05:46:41 <musasabi> basti_: in december.
05:46:50 <basti_> ah
05:46:52 <basti_> http://www.haskell.org//pipermail/haskell/2005-December/017094.html < this?
05:47:22 <musasabi> (still on a text terminal, no cut-and paste or anything fancy)
05:47:26 <shapr> Itkovian: One of my goals for this is to try to find some way to get simple spoken crypto that's still tough for computer endowed eavesdroppers. Maybe elliptic curve crypto?
05:48:11 <shapr> But it also lets me investigate a possible connection between number theory and compiler optimization.
05:48:15 <Itkovian> erm. dude. 
05:48:15 * shapr boings happily
05:48:20 <shapr> There's so much cool stuff to learn :-)
05:48:28 <Itkovian> I'll talk to you in a few years, eh
05:48:44 <shapr> Itkovian: encrypted? ;-)
05:48:46 * shapr snickers
05:49:05 <Itkovian> nah, that'll be for in about 20 years
05:49:29 <MarcWeber> I'll have a break, go shopping.. bye ;-)
05:51:10 <basti_> musasabi: in that thing, the intervals may not overlap
05:51:23 <basti_> and the numbers must be discrete
05:51:57 <shapr> hiya JaffaCake, have a good vacation?
05:52:12 <JaffaCake> hi there, yes, thanks :)
05:55:44 <Saulzar> Cool, frag does not seem to leak memory... I can see what they do.
05:57:53 <kzm> Hmm..Data.Graph is not FGL?
05:58:02 <tromp_> what book are you talking about, shapr&Itkovian?
05:58:30 <Itkovian> tromp_: Dead Reckoning: Calculating without instruments
05:58:46 <Itkovian> isbn 0-88415-087-9
06:00:12 <kzm> @index embed
06:00:13 <lambdabot> bzzt
06:00:22 <kzm> @botkick
06:00:23 <lambdabot> Unknown command, try @listcommands.
06:00:38 * kzm hopes that hurt.
06:01:20 <Nanar> well ok
06:01:40 <Nanar> sound like I will not be able to understand alone /o\
06:01:55 <Nanar> I trying write my first code in haskell
06:02:06 <Nanar> of course it doesn't works :)
06:02:12 <Nanar> main = do putStrLn (inc 0)
06:02:18 <Nanar> inc n = n + 1
06:02:34 <kzm> FGL isn't included in GHC?!
06:02:49 <Nanar> Couldn't match `String' against `Integer'
06:02:59 <tromp_> leave out the do
06:03:03 <Nanar> how can I print the number ?
06:03:12 <tromp_> and insert a show
06:03:15 <Saulzar> putStrLn takes a string, so you can convert it with show, or use print (which does that)
06:03:19 <tromp_> or use print
06:04:33 <kzm> Argh - I guess it's just the user guide that's more dated than I thought.  
06:04:40 <kosmikus> kzm: Data.Graph.Inductive
06:05:22 <Nanar> thanks tromp_, Saulzar 
06:05:41 <xerox> print = putStrLn . show
06:05:42 <tromp_> you can also use succ instead of inc
06:06:08 <tromp_> since integers are an instance of Enum
06:06:44 <kzm> kosmikus: Right.  I was trying to play with some examples from the user guide, but the only thing they seem to have in common, is the name FGL...
06:10:31 <Nanar> \o/ 1st apps: 5 lines :)
06:13:41 <shapr> tromp_: Have you seen that book?
06:14:59 <tromp_> not before
06:15:13 <tromp_> is there a review online?
06:16:16 <tromp_> well, i found a synopsis
06:19:03 <kosmikus> kzm: hmm. I've been using FGL recently, and while the documentation is certainly outdated, I still found it helpful.
06:19:43 <kzm> Apparently, "embed" is gone, but I found & (not so easy to grep after :-)
06:20:04 <kzm> But I am unable to construct graphs, I get Ambigous type variable 'gr' (from class DynGraph)
06:20:25 <kzm> Not sure how to add type signatures for this.  Any ideas?
06:21:36 <kzm> E.g.: let g = ([],1,'a',[]::[((),Node)]) & empty -- directly from the first example
06:22:20 <kzm> (the type declaration was apparently sufficient to fix this to a Graph () Char -- or vice versa?, but not anymore.
06:22:23 <kzm> )
06:24:36 <kzm> Hah!  :: Gr Char () did the trick!
06:26:04 <kzm> Hmm...is there any support for undirected graphs?  (Yes, I know I can double the number of edges, but is there a less pedestrian way?)
06:28:01 <kzm> Does "Tree" (as in Data.Graph.Inductive.Tree) refer to the *implementation*?  I.e. it has nothing to do with Tree as a type of Graph.  And is this naming really wise?
06:29:10 <shapr> I think the papers say you can get undirected graphs by ignoring the direction of the connections.
06:29:25 <kosmikus> kzm: yes, I think it refers to the implementation
06:36:37 <Trevion> "C++ is a tremendously type safe language, to the point where every time I work with it I feel like about 90% of the work I do is in accounting for type." -- seen on Slashdot
06:36:59 <basti_> :-O
06:37:01 <UncleD> ;P
06:37:05 <UncleD> that's a humouring quote.
06:37:16 <basti_> hmm
06:37:21 <basti_> i didnt get the joke then
06:37:30 <UncleD> maybe it wasn't meant to be funny.
06:38:22 <Trevion> I don't think the original author was trying to be funny.  I found it humorous, though.
06:50:34 <twb> @pl (not . \x -> isSpace x || x == '(' || x == ')')
06:50:36 <lambdabot> not . liftM2 (||) isSpace (liftM2 (||) ('(' ==) (')' ==))
06:51:18 <twb> @pl \x -> isSpace x || elem x "()"
06:51:20 <lambdabot> liftM2 (||) isSpace (flip elem "()")
06:53:23 <lisppaste2> twb pasted "practicing parser design" at http://paste.lisp.org/display/15318
06:53:45 <twb> Anyone care to suggest improvements?
06:54:42 <ADEpt> twb: re oparen, cparen - there are 'parens'
06:54:43 <ADEpt> @index parens
06:54:44 <lambdabot> Language.Haskell.TH.PprLib, Text.ParserCombinators.Parsec.Token, Text.
06:54:44 <lambdabot> PrettyPrint.HughesPJ, Text.PrettyPrint
06:55:00 <twb> @type Text.ParserCombinators.Parsec.Token.Parens
06:55:02 <lambdabot>   Not in scope: data constructor `Text.ParserCombinators.Parsec.Token.
06:55:02 <lambdabot> Parens'
06:55:03 <twb> @type Text.ParserCombinators.Parsec.Token.parens
06:55:04 <lambdabot> forall a st.
06:55:04 <lambdabot> Text.ParserCombinators.Parsec.Token.TokenParser st
06:55:04 <lambdabot> -> Text.ParserCombinators.Parsec.Char.CharParser st a
06:55:04 <lambdabot> -> Text.ParserCombinators.Parsec.Char.CharParser st a
06:55:22 <twb> ADEpt: that uses tokens instead of Chars.
06:56:22 <ADEpt> twb: and?
06:56:27 * ADEpt feels dense today
06:56:43 <ADEpt> twb: how this will prevent you from using it?
06:56:57 <twb> ADEpt: I don't understand how to use them.
06:58:52 <ADEpt> twb: i would rather:
06:58:52 <ADEpt> atom = .... return $ Atom x
06:58:52 <ADEpt> lispExpr atom <|> (parens (many lispExpr) >>= return Comb)
06:59:04 <ADEpt> lispExpr = atom <|> (parens (many lispExpr) >>= return Comb)
07:00:20 <ADEpt> twb: re Token parsers - take a look at the bottom of http://svn.openfoundry.org/pugs/src/PIL/Native/Parser.hs, for example
07:00:29 <twb> Looking.
07:01:12 <ADEpt> twb: with Token parsers, your "atom" will be just "identifier"
07:01:54 <ADEpt> twb: and "indetifier" will automagically take care not to gobble up unwanted spaces and/or parens
07:02:21 <twb> OK, suppose I use Token.hs.
07:02:45 <twb> Can I define the identifier quotation mechanism |bleh|, where anything but a | can occur between the |'s?
07:03:19 <twb> e.g. (|not) (a sum|) ==> Comb [Atom "not) (a sum"]
07:06:27 <ADEpt> twb: if I understand you right, you just specify that ' ' is a valid identifier char, and '|' is not, and then write something:
07:06:27 <ADEpt> strange_parser = between (char '|') (char '|') identifier
07:07:14 <twb> But *every* character is valid within ||.
07:07:26 <aleator> Hi! What is the library of choice for linear algebra? I would need the basics up to SVD..
07:07:29 <twb> Including comments and parens, for example.
07:08:16 <twb> Whereas an un|quoted| identifier can't contain spaces or parens.
07:09:01 <Saulzar> aleator, Have a look at hmatrix
07:11:38 <ADEpt> twb: now you lost me :)
07:11:53 <mwc> Sorry all, had a bug in a script I use to launch xchat
07:12:03 <mwc> hence the double-login
07:12:34 <twb> ADEpt: OK, in common lisp, normal symbols (identifiers) can only match [^a-zA-Z0-9-].
07:12:55 <ADEpt> twb: yep
07:12:58 <twb> ADEpt: But if you put |'s around the symbol, you can use *any* character.
07:12:59 <aleator> Saulzar: Thanks. Any opinions on it?
07:13:10 <xerox> ...except '|' ?
07:13:14 <twb> e.g. |foo\|bar| is a valid identifier, with the symbol-name "foo|bar".
07:13:22 <xerox> Foo.
07:13:31 <twb> xerox: hmm?
07:13:34 <Saulzar> aleator, I've never used it myself - but it looked promising after browsing through the docs...
07:13:54 <xerox> Well no, you just answered with the example.
07:14:49 <twb> All I'm saying is I'm a little wary of using Token.hs, because I'm not sure it's sufficiently extensible.
07:15:00 <aleator> Saulzar: ok.
07:15:04 <ADEpt> so, you will have smthing like:
07:15:04 <ADEpt> atom = between (char '|') (char '|') (many1 anyChar) <|> identifier
07:15:35 <ADEpt> twb: well, you could take what's fits your needs, and ignore/reimplement the rest.
07:16:05 <twb> OK.
07:16:18 <aleator> This is what complained about yesterday.. Quick google finds three matrixy thingies for haskell, and I've already done small one myself.. Perhaps there could be a wikipage with reviews of third party libraries..
07:16:48 <twb> ADEpt: I'll try it, and come back to whine if I can't get it to work :-)
07:18:06 <ADEpt> twb: ok :)
07:21:34 <twb> Another thing is that normal identifiers are (by default) converted to uppercase, but case is preserved in quoted identifiers.
07:21:47 <twb> So Foo = foo = |FOO| /= |foo|
07:26:08 <ADEpt> twb: it a matter of sticking 'map toUpper' in the proper place, i think
07:26:17 <twb> Okey dokey.
07:26:46 <twb> Do things like toUpper and isSpace honor locales (like the C versions do)?
07:28:32 <aleator> hmm.. hmatrix tutorial seems outdated..
07:28:58 <ADEpt> twb: well, i would be surprized if they are not just wrappers around libc
07:29:17 <twb> ADEpt: that was my assumption.  I thought someone could confirm it.
07:30:33 <Saulzar> Hmm, all the `seq`'ing and `deepSeq`'ing in the world and I can't seem to make a difference, there must be a technique to this.
07:30:45 * Saulzar `seq` bed
07:31:38 <xerox> Forecefully evaluating ourself in bed is actually too  weird.
07:37:18 * SamB thinks GHC ought to have a better way to handle dynamic "exports" from the GHC binary...
07:37:37 <SamB> in Linker.c...
07:37:41 <aleator> Saulzar: 5min evaluation says: hmatrix is good. Thank you.
07:38:32 <SamB> what's the point of forcing a data constructor?
07:38:48 <SamB> data contstructors would be very silly not to be in WHNF already
07:39:48 <SamB> oh well, at least I can get HOC to build...
07:40:09 <kosmikus> HOC?
07:40:15 <kosmikus> higher-order chaos?
07:40:39 <SamB> Haskell on Cocoa or Haskell Objective-C...
07:41:18 <kosmikus> ah
07:41:22 <SamB> last time I said HOC out of context, someone asked if I meant Higher-Order Chocolate
07:41:35 <SamB> ;-)
07:42:10 <SamB> I'm sure it will be leaky around exceptions, though...
07:44:08 <SamB> because I had to comment out the call to hs_free_stable_ptr...
07:45:58 <SamB> I do have some patch hunks to send to the hoc devel list, though...
07:46:33 <SamB> it wouldn't build out of the box on GNUSTEP, though it was clearly supposed to... 
07:46:46 <SamB> I guess they don't test it there enough
08:06:21 <shapr> kosmikus: I like it!
08:06:26 * shapr wants HOC
08:06:52 <SamB> shapr: do you need patches to get it to build with GNUSTEP?
08:10:21 <SamB> oh, you meant higher-order chaos
08:11:21 <shapr> I'm up to my eyeballs in HOC!
08:11:32 <shapr> Yes, this bings a new meaning to being in hoc.
08:11:33 <Philippa_> is that like functional sphagetti?
08:13:24 <SamB> interesting...
08:13:27 <SamB> <no location info>:
08:13:27 <SamB>     Warning: Pattern match(es) are overlapped
08:13:27 <SamB> 	     In a case alternative:
08:13:27 <SamB> 		 0 -> ...
08:13:27 <SamB> 		 1 -> ...
08:14:04 <shapr> How'd you get that?
08:14:30 <shapr> tromp_: Any nifty books I should check out?
08:15:13 <tromp_> on what topic?
08:15:39 <SamB> building HOC...
08:15:49 <tromp_> have you tried The Hobbit yet, shapr:-?
08:17:44 <shapr> Yes, quite a few years back :-) I think I was 9.
08:18:42 <tromp_> check out Surreal Numbers
08:18:46 <PerlJam> shapr: how about "War and Peace"?
08:18:50 <shapr> My mother has a very old gold leaf hardback version of the LoTR. I read that in middle school and taught myself some elvish.
08:18:50 <PerlJam> :)
08:19:01 <shapr> I was fond of running around saying "Elvish is alive!"
08:19:22 <shapr> PerlJam: Maybe some other year :-)
08:19:30 * PerlJam adjusts his internal numbers that summarize shapr's sanity.
08:20:06 <shapr> Oh, I want to hear about these numbers.
08:21:53 <PerlJam> shapr: 37 4 17 91 1729
08:21:56 <PerlJam> ;-)
08:21:59 <shapr> heh
08:22:08 <tromp_> well, there's {|}
08:22:17 <tromp_> which happens to be 0
08:22:33 <tromp_> and {0|}, which happens to be 1
08:22:35 <xerox> Ascii-porn?
08:23:00 <shapr> I'm not insane, but I am aware that my approach to life is utterly alien to most humans.
08:23:09 <tromp_> and generally {L|R} where L and R are sets of surreal numbers
08:23:44 <tromp_> that generate integers, fractions, real numbers, and all kinds of infinitely big and small numbers
08:24:46 <tromp_> so it's like zero and succ, but giving a much richer structure
08:24:57 <shapr> Oh I thought up a refinement to Dead Reckoning. He doesn't manipulate number bases at all. 
08:25:17 <shapr> Whatever happened to that discussion of a base prime number system?
08:26:07 <xerox> What is Dead Reckoning?
08:26:16 <shapr> isbn 0-88415-087-9
08:26:22 <xerox> A book :-)
08:27:50 <Lemmih> @seen jlouis 
08:27:51 <lambdabot> jlouis is in #haskell-blah and #haskell. Last spoke 4 days, 4 hours, 37
08:27:51 <lambdabot> minutes and 7 seconds ago.
08:28:12 * shapr tries to conjure up jlouis 
08:29:20 * SamB groans appreciatively
08:33:00 <shapr> hoi kagy 
08:33:27 <kagy> hoi shapr
09:20:03 <xerox> Oi! boegelz
09:21:07 <boegel|home> yo xerox 
09:21:34 * boegel|home leaves again giggling like a schoolgirl
09:21:36 <audreyt> dons: this is your regularly scheduled prodding about releasing hs-plugins.
09:26:12 <SyntaxNinja> w00t
09:26:30 <Lemmih> Hi SyntaxNinja and happy new year.
09:26:53 <xerox> Whoopeee!  Happy happy, joy joy - Shadow-lexer!
09:27:48 <SyntaxNinja> happy new year
09:28:22 <SyntaxNinja> sorry if I've been hard to get ahold of (not sure if anyone tried) syntaxpolice.org is down :(
09:28:46 <xerox> It's ever a bit sad when a host leaves us :(
09:29:00 <SyntaxNinja> ijones@debian.org should work any minute now
09:29:49 <SyntaxNinja> plus I didn't have internet at home, and I was away from work... and for a while, my cell phone wasn't receiving incoming calls, and I didn't have a home phone.
09:29:54 <SyntaxNinja> so I had a real vacation ;)
09:30:04 <SyntaxNinja> (I moved recently)
09:30:09 <SyntaxNinja> @moo
09:30:11 <lambdabot> Maybe you meant: map more msg todo yow
09:30:36 <xerox> Moo was taken off quite a while ago.  Moo.
09:34:19 <SyntaxNinja> I miss moo
09:35:15 <xerox> It made quite a big noise at times.
09:35:26 <MarcWeber> Is somone here who also wants to learn more about monads and is interested in (helping me)  understanding example18 of All about Monads tutorial?
09:36:09 <xerox> Firstly, we want more details about the incriminated, infamous, and shattering example eighteen.
09:37:29 <MarcWeber> 06135@pop.gmx.net:61 of 96 (2891 octets) .. flushed
09:37:30 <MarcWeber> reading message 9006135@pop.gmx.net:62 of 96 (2927 octets) .. flushed
09:37:30 <MarcWeber> reading message 9006135@pop.gmx.net:63 of 96 (4513 octets) .... flushed
09:37:46 <xerox> Wee, it smelled of Cont Monad from the beginning.
09:38:05 <MarcWeber> http://www.nomaware.com/monads/html/contmonad.html
09:38:27 <xerox> What about that?
09:38:36 <Philippa_> xerox: there's something fishy about that
09:39:11 <xerox> Philippa_: care to elaborate a bit?
09:39:53 <Philippa_> just a bad pun
09:40:25 <xerox> Dang.  Whoops.
09:40:47 <MarcWeber> xerox: not sure where to start. when monad:
09:41:07 <MarcWeber> when              :: (Monad m) => Bool -> m () -> m ()
09:41:16 <MarcWeber> when p s          =  if p then s else return ()
09:41:18 <xerox> It's just an action.
09:41:39 <xerox> Right.  It evaluates its second argument only if its first one is True.
09:42:27 <xerox> That code is just a big made-up to show how to GOTO in Haskell, that's my impression.  I admit I could be completely wrong on this subject.
09:43:14 <MarcWeber> It either returns return () or s but s also is of type m (). Where is the difference between return ()  and m ()? Both can't contain any information except from "void", right?
09:43:39 <Cale> @type return ()
09:43:41 <lambdabot> forall (m :: * -> *). (Monad m) => m ()
09:43:41 <Lemmih> Well, those are two completely different things.
09:43:55 <Lemmih> MarcWeber: 'return ()' is an expression. 'Monad m => m ()' is a type.
09:44:03 <xerox> What's the type of 'return' ?
09:44:04 <Cale> return () :: Monad m => m ()
09:44:25 <xerox> I was asking Marc, my Cale friend :-)
09:44:55 <xerox> Well, ok :-)
09:44:56 <Cale> I'd already typd that when you asked
09:44:58 <MarcWeber> Cale, xerox *lol* That's why I was asking... 
09:45:12 <xerox> But he laughs, so hey :-D
09:45:13 <MarcWeber> Can you imagine two different m () ?
09:45:30 <Lemmih> > when True (Nothing)
09:45:31 <lambdabot> Nothing
09:45:32 <Lemmih> > when False (Nothing)
09:45:34 <lambdabot> Just ()
09:45:52 <xerox> MarcWeber: 'return ()' is _all_ the different 'Monad m => m ()'.
09:46:18 <xerox> If you will, it is the value of the type 'forall m. (Monad m) => m ()'.
09:50:25 <MarcWeber> I think I'm not sure what () means. I thought it's some kind of dummy type.. but why is (Nothing) of type (Monad m) =>  m () ?
09:51:21 <MarcWeber> and why does return () end up in Maybe?
09:51:22 <Heffalump> m () isn't the same as ()
09:51:34 <Lemmih> Because Maybe is a monad.
09:51:35 <Heffalump> MarcWeber: return () :: Monad m => m ()
09:51:44 <Heffalump> Maybe is one of many instances of Monad
09:54:58 <MarcWeber> Am I right that the Monad class definition looks like this: class Monad a where .. with a beeing the type with which you call return and therefore specify the kind of Monad to use?
09:55:24 <MarcWeber> s/kind/type
09:55:40 <Cale> class  Monad m  where
09:55:40 <Cale>     (>>=)  :: m a -> (a -> m b) -> m b
09:55:44 <Cale>     return :: a -> m a
09:55:44 <Heffalump> MarcWeber: not quite, no
09:56:05 <Heffalump> when you call return, the argument to return gives you the a in 'm a'
09:56:14 <Cale> > return 5 :: Maybe Int
09:56:16 <lambdabot> Just 5
09:56:22 <Cale> > return 5 :: [Int]
09:56:24 <lambdabot> [5]
09:57:05 <Cale> In the first example, the monad is Maybe, in the second, it's [] (Lists)
09:58:01 <xerox> [Int] =~= [] Int =~= (Monad []) => [] Int
09:58:53 <MarcWeber> So what does type (Monad m) =>  m () tell me, then? In particular () ?
09:59:14 <MarcWeber> xerox: I've never seen =~= before..
09:59:17 <Cale> () is the type of thing being held in the container
09:59:20 <Heffalump> if v :: Monad m => m ()
09:59:31 <Heffalump> then "x <- v" inside do notation will give you a x of type ()
09:59:32 <Cale> MarcWeber: xerox basically means "is the same as"
09:59:41 <datenmaulwurf> !help
09:59:42 <Cale> > return ()
09:59:44 <lambdabot>  add an instance declaration for (Show (m ()))
09:59:44 <xerox> Right.
09:59:48 <MarcWeber> Thanks a lot..
09:59:49 <Cale> > return () :: [()]
09:59:51 <lambdabot> [()]
09:59:51 <xerox> datenmaulwurf: Howdy.  Learning Haskell?
09:59:56 <Cale> > return () :: Maybe ()
09:59:59 <lambdabot> Just ()
10:00:04 <Cale> MarcWeber: see?
10:00:05 <xerox> > return () :: ()
10:00:06 <lambdabot> Couldn't match `()' against `m a'
10:00:24 <datenmaulwurf> xerox, sry ^^
10:00:33 <Heffalump> MarcWeber: typically, type inference will determine what m is. Either the type signature of the overall function you are writing, or your use of some operation that is particular to a given monad, will constrain m.
10:00:39 <datenmaulwurf> xerox, there wasn'r a bot, which answer my question, hm?
10:00:40 <Heffalump> @type return ()
10:00:41 <xerox> datenmaulwurf: don't be sorry.  What brings you there, if I may ask?
10:00:42 <lambdabot> forall (m :: * -> *). (Monad m) => m ()
10:00:53 <Heffalump> @type do { putStr "foo" ; return () }
10:00:55 <lambdabot> IO ()
10:01:08 <Heffalump> and IO () is the type of return () too
10:01:15 <xerox> datenmaulwurf: yup.  Try @listmodules, (in private would be probably saner), and play with @listcommands.
10:01:27 <datenmaulwurf> @listcommands
10:01:28 <lambdabot> use listcommands [module|command]. Modules are:
10:01:28 <lambdabot> babel base code compose dice dict djinn dummy dynamic elite fact haddock
10:01:28 <lambdabot> help hoogle karma lShell localtime more pl plugs poll pretty quote search
10:01:28 <lambdabot> seen spell state system todo topic type version vixen where
10:01:31 <datenmaulwurf> ah
10:01:32 <datenmaulwurf> ok
10:01:33 <datenmaulwurf> thx
10:02:00 <xerox> datenmaulwurf: You're welcome.
10:02:57 <datenmaulwurf> thanks :) - what's syntax to find out what's a function is for?
10:03:29 <SyntaxNinja> OK I can be reached at ijones@debian.org if anyone cards ;)
10:03:36 <xerox> np: The Moody Blues - Ride My See-Saw
10:04:05 <Cale> @index foldl'
10:04:06 <lambdabot> Data.List
10:04:09 <xerox> datenmaulwurf: you could do this procedure, if you're searching for an explanation (and there is one in the docs)
10:04:11 <Cale> @docs Data.List
10:04:13 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
10:04:17 <xerox> What Cale said :-)
10:04:55 <Cale> The @index command will find which module things are in and then @docs <module> will point you at the manual.
10:05:54 <datenmaulwurf> hmm ^^
10:05:57 <datenmaulwurf> @index abs
10:05:59 <lambdabot> Prelude
10:06:02 <datenmaulwurf> -> prelude
10:06:07 <datenmaulwurf> @docs prelude
10:06:08 <lambdabot> prelude not available
10:06:12 <datenmaulwurf> -> not available ^^
10:06:17 <Cale> @docs Prelude
10:06:17 <xerox> @docs Prelude
10:06:18 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
10:06:18 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
10:06:25 <xerox> @poke Cale
10:06:25 <lambdabot> Maybe you meant: code more vote
10:06:28 <xerox> :-)
10:06:30 <Heffalump> that ought to be fixed, I guess.
10:06:31 <Cale> heh
10:06:55 <datenmaulwurf> ahh, now the link comes :)
10:06:57 <MarcWeber> Cale: I see because List Monad: return x = [x] and Maybe : return = Just, right.
10:07:02 <Cale> Perhaps not though, people should be made aware that module names are case sensitive :)
10:07:12 <Cale> MarcWeber: yeah
10:07:14 <datenmaulwurf> Cale, lol ^^
10:07:21 <xerox> I'm with Cale, heh.
10:07:25 <datenmaulwurf> --	datenmaulwurf	@docs prelude
10:07:25 <datenmaulwurf> 	lambdabot	prelude not available
10:07:25 <datenmaulwurf> 	datenmaulwurf	-> not available ^^
10:07:25 <datenmaulwurf> 	Cale	@docs Prelude
10:07:25 <datenmaulwurf> 	xerox	@docs Prelude
10:07:25 <datenmaulwurf> 	lambdabot	http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
10:07:25 <Lemmih> @. docs index abs
10:07:26 <lambdabot> Prelude
10:07:26 <lambdabot>  not available
10:07:31 <Lemmih> /-:
10:07:38 <SamB> I think @poke should be implemented
10:07:43 <xerox> UH.
10:07:57 <xerox> @compose docs index abs
10:07:58 <lambdabot> Prelude
10:07:58 <lambdabot>  not available
10:08:02 <xerox> Why doesn't it work?
10:08:02 <datenmaulwurf> but now i know what's abs ;)
10:08:09 <xerox> Heh.
10:08:22 * datenmaulwurf is the bugfinder
10:08:22 <Heffalump> @. (docs,index) abs
10:08:24 <lambdabot> compose module failed: Parse error: "(docs,index)"
10:08:34 <Cale> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v%3Aabs
10:08:51 <datenmaulwurf> Cale, thanks
10:09:12 <Cale> > map abs [-10..10]
10:09:14 <lambdabot> [10,9,8,7,6,5,4,3,2,1,0,1,2,3,4,5,6,7,8,9,10]
10:09:27 <datenmaulwurf> cool
10:09:34 <xerox> Heffalump: that's an idea.  How could we extend the syntax to curried commands with more arguments than one?
10:09:36 <datenmaulwurf> nice bot, some bugs, but very nice :)
10:09:54 <xerox> abs x | x >= 0 = x
10:10:01 <xerox>       | otherwise = -x
10:11:12 <SamB> datenmaulwurf: I think people like you keep going and messing things up ;-)
10:11:51 <SamB> I hate it when that happens
10:11:52 <xerox> ....racist? :-)
10:12:14 <SamB> xerox: I meant "newbies"
10:12:16 <SamB> and I was kidding
10:12:46 * xerox fades in the background
10:25:27 <palomer> man, I wish there was datatype subtyping
10:26:52 <SamB> palomer: what do you want it for? (not to question its utility, but whether I can grant your wish depends on the answer)
10:27:19 <palomer> I have lambda terms, and I have extended lambda terms
10:27:31 <palomer> and I want to define show only for lambda terms
10:27:54 <palomer> right now, this means I need to manuallyconvert extended lambda terms to lambda terms
10:28:11 <palomer> furthermore, I need to define 2 very different datatypes
10:28:18 <palomer> err, 2 very similar datatypes
10:28:22 <SamB> well...
10:28:40 <xerox> GADTs?
10:28:48 <palomer> GADTs can help?
10:28:53 <SamB> you could do something like data Term a = Foo | Bar | Ext a deriving Show
10:29:01 <gour> @sort
10:29:02 <lambdabot> Maybe you meant: more part
10:29:25 <palomer> SamB: yeah, I guess that's the best option
10:29:26 <lennart> howdy!
10:29:29 <xerox> Well, what do your Lambda and Extended Lambda terms look like?
10:29:47 <palomer> SamB: you mean extTerm = Foo | Bar | Term
10:29:59 <palomer> extended lambda terms have let
10:30:36 <lennart> palomer: how is your quest for truth and beauty doing?
10:30:45 <SamB> its vaguely like how wxHaskell and HOC handle class heirarchies
10:30:58 <SamB> palomer: Foo and Bar are just examples
10:31:21 <xerox> Well.  Have you ever seen this example there?  <http://www.haskell.org/ghc/docs/latest/html/users_guide/gadt.html>
10:31:32 <SamB> palomer: and I really did mean for it to be inside-out
10:39:58 <gour> in which module (ghc) is 'sort' defined?
10:41:29 <arjanb> @index sort
10:41:30 <lambdabot> Data.List
10:41:46 <gour> arjanb: thanks
11:17:51 <araujo> Good morning.
11:18:46 <Lemmih> Good evening, araujo.
11:19:35 * Lemmih regrets not starting his Conjure fork from a fresh repo.
11:21:15 * ADEpt regrets not doing any conjure work since last year ;)
11:24:22 <Mitar> is there any difference between f (g (h x))) and (f . g . h) x?
11:24:30 <Mitar> (for any f, g, h)
11:24:49 <xerox> No.
11:25:25 <xerox> It is also equivalent to 'f . g . h $ x'
11:25:42 <Mitar> is there any perfomance difference?
11:25:54 <Mitar> and to f $ g $ h $ x too
11:25:59 <PerlJam> "performance difference"?
11:26:26 <PerlJam> Mitar: no, the perform identically.
11:26:30 <PerlJam> s/the/they/
11:27:06 <Mitar> so there is no difference except syntactic?
11:27:28 <PerlJam> that you ask the question mildly disturbs me.
11:27:47 <araujo> Hello Lemmih 
11:27:48 <Mitar> i am learning haskell and functional programming ...
11:27:57 <araujo> Mitar, Cool.
11:28:02 <PerlJam> Mitar: congratulations !  me too.
11:28:13 <Mitar> and why it would disturb you?
11:28:43 <PerlJam> Mitar: premature optimization is the root of all evil
11:28:49 <Mitar> he he
11:28:54 <Mitar> i know that
11:29:08 <PerlJam> Mitar: Besides it's like asking if "2 + 3" is faster than "6 - 1"
11:29:10 <Mitar> i am just asking that to know what haskell do behind the scenes
11:29:13 <mjl69> me too.
11:29:16 <araujo> Mitar, You are working on terms of values with the '$' notation
11:29:32 <Mitar> araujo?
11:29:35 <araujo> Mitar, the '.' notation allows you to think in terms of functions
11:29:56 <PerlJam> araujo: procedural programmers are used to thinking in terms of values :)
11:30:12 <araujo> PerlJam, what a shame :-)
11:30:42 <Mitar> ok, thanks
11:31:24 <Mitar> just to be sure: so there is no difference in the way haskell evaluate f (g (h x))) and (f . g . h) x?
11:31:25 <PerlJam> araujo: yeah, I even argued on a perl 6 mailing list once that side-effect free programming was not the norm and would surprise most perl programmers.
11:33:27 <araujo> Mitar, You can think of f(g(h x) as three functions applied to a value, and (f.g .h) x as one function applied to a value
11:33:45 <araujo> PerlJam, You mean.. perl6 won't have side-effects?
11:35:22 <xerox> It's nice to sequence the computation with the function composition operator (.) for two reasons, afaics; first, it emphazises the flow of the computation, second, it hides the very last argument: in case of one-argument functions is usually quite stilish.  Well, somehow :-)
11:35:25 <PerlJam> araujo: Let's just say that the goal is to minimize side effects as much as possible or at least to contain them to very specific instances.
11:35:40 <Cale> Mitar: right
11:35:44 <araujo> > let f = (sqrt . (+ 1) . (* 2)) in f 5
11:35:47 <lambdabot> 3.3166247903554
11:35:53 <araujo> > let f = (sqrt $ (+ 1) $ (* 2)) in f 5
11:35:54 <lambdabot>  add an instance declaration for (Floating (a -> a))
11:35:59 <PerlJam> araujo: though perl6 doesn't have anything nifty like monads in which to sequester all side effects.
11:36:22 <araujo> PerlJam, Well, that looks interesting....
11:36:29 <Cale> Mitar: you use (.) when thinking about functions, and ($) when thinking about the values that they act on
11:36:34 <araujo> If you ask me, no side-effects is the way to go.
11:37:00 <PerlJam> araujo: why do you think I'm putting a concerted effort into learning haskell?  :-)
11:37:08 <Cale> Perl 6 is busy stealing as many ideas from Haskell as possible :) We really are going to have a Haskerl.
11:37:10 <araujo> Good :-)
11:37:18 <araujo> haha
11:37:23 <Cale> http://www.dcs.gla.ac.uk/~partain/haskerl.html
11:37:31 <Cale> That was in 1993
11:37:35 <ulfdoz> "Jungs, wir haben ein Sabotageziel!"
11:37:39 <ulfdoz> ECHAN, sorry
11:37:45 <PerlJam> I've dabbled in haskell for years now without really gaining a deep understanding of it.  Now I've decided that I want to have an intuitive understanding of it even if just for my own edification.
11:38:02 <basti_> congratulations PerlJam 
11:38:35 <PerlJam> Cale: indeed. One of the things I've realized over the last few weeks is just how much is stolen from haskell (or haskell-like languages)
11:39:06 <neologism> maybe its creeping to become haskell without anyone noticing
11:39:53 <PerlJam> It helps that the only extant implementation of perl 6 is implemented in haskell too
11:42:51 <JKnecht> is that a joke?
11:42:59 <gzl> is what a joke?
11:43:14 <JKnecht> perl 6 implemented in Haskell.
11:43:18 <PerlJam> not at all.  
11:43:19 <gzl> no 
11:43:22 <PerlJam> dead serious
11:43:23 <gzl> google pugs
11:43:36 <Cale> http://www.pugscode.org/
11:43:48 <Cale> Pugs is an implementation of Perl 6, written in Haskell. It aims to implement the full Perl6 specification, as detailed in the Synopses.
11:43:48 <araujo> PerlJam, ive found functional programming (haskell specifically) as the way to solve many problems i used to have with imperative languages.
11:43:49 <PerlJam> And why not?  GHC evolved from a hybrid perl implementation :)
11:43:59 <araujo> PerlJam, Among them, easy-to-maintain code
11:44:03 <Heffalump> I thought perl6 was a joke designed to give the perl designers something to do.
11:44:34 <JKnecht> Oh I see there isn't a production implementation of Perl 6. Still impressive though.
11:44:52 <gzl> but this will become the production one...
11:45:00 <Cale> What do you mean by "production"?
11:45:10 <gzl> Perl 6 itself isn't "production"
11:45:15 <terceiro> Cabal newbie question: after `runhaskell Setup.hs configure && runhaskell Setup.hs build && runhaskell Setup.hs install`, my library's files go into /usr/local/lib/PACKAGE-VERSION/. ghci is able to tell the types (:t) of functions in that library, but when I try to eval something with that functions, I get [ghc-6.4.1: unable to load package `PACKAGE-VERSION']. Any ideas?
11:45:30 <JKnecht> In the sense that say Perl 5.6.0 is.
11:45:56 <sieni> http://bleaklow.com/alanbur/p6_cover.gif
11:45:57 <araujo> terceiro, i think you need to register your libraries
11:46:07 <gzl> well, clearly nobody is using perl 6 to do anything yet, if that's what you mean
11:46:11 <gzl> they're still writing it
11:46:15 <wolverian> JKnecht, 5.6.0 is too old to be production :)
11:46:26 <PerlJam> araujo: I read a piece by Paul Graham once where he was talking about implementing things in LISP faster and better than the procedural programmers of the day because code just fell out naturally once you were in the proper mindset.  I experienced that just the other day in haskell.  I wrote some code and it just looked right and golly if it didn't just work too.
11:46:39 <Lemmih> araujo: Installing should do that.
11:46:48 <terceiro> araujo: but they are being registered. At least, `install` is supposed to do that
11:46:59 <araujo> Lemmih, terceiro Ok.
11:47:10 <Cale> There appear to be a hell of a lot of perl 6 test cases used to test pugs.
11:47:32 <Cale> http://m19s28.vlinux.de/iblech/stuff/pugs-smokes/pugs-smoke-6.2.10-r0-linux-normal--1135528829-2835--10340-10340-0-1240-1538-0--1fffe39a11963c98ac8c36a3287f6322.html
11:47:48 <PerlJam> JKnecht: the perl6 compiler guy told me that he's targetting June 2006 to have the first version of the production compiler released to the public.
11:48:18 <PerlJam> If perl5 is any indication, once we have the alpha compiler, we'll have the actual release within 2 years
11:48:30 <JKnecht> they're using GHC?
11:48:34 <Cale> yeah
11:48:35 <PerlJam> JKnecht: aye
11:48:50 <Lemmih> terceiro: GHCi doesn't say why it failed? Perhaps with -v?
11:49:44 <terceiro> Lemmih: good point. Loading package SPF-0.1 ... linking ... <interactive>: /usr/local/lib/SPF-0.1/HSSPF-0.1.o: unknown symbol `__stginit_Monad_'
11:49:58 <araujo> PerlJam, yes, it is amazing how fast you can write good quality code in Haskell. 
11:50:03 <musasabi> terceiro: add a depend to the haskell98 package.
11:51:02 <terceiro> musasabi: hm ...
11:52:32 <terceiro> ah ...
11:52:37 <Lemmih> SyntaxNinja: Why didn't the Cabal code move to src/?
11:52:47 <PerlJam> araujo: yep.  After participating and lately watching pugs development, I've learned that even inexperienced haskell hackers can easily generate quality apps  much in the same way that newbie perlers can get useful work done.
11:52:54 <terceiro> so I need to add the dependencies even if Cabal can guess them at build time
11:53:17 <terceiro> now it worked
11:53:32 <terceiro> araujo, Lemmih , musasabi: thank you
11:54:00 <araujo> terceiro, np
11:54:33 <Lemmih> terceiro: Yep, newer versions of GHC have a -fhide-all-packages flag which allows you to catch this kind of errors earlier.
11:58:07 <Lemmih> Hi ADEpt. Feeling like hacking some Conjure?
11:59:14 <araujo> PerlJam, yeah, i wouldn't know how exactly explaining it, but Haskell makes you think from other abstraction level than most of the imperative (even functional) languages. You can get closer and faster to the domain of what you wanna do, instead of getting distracted by how to do it. That frees you of many many _unnecessary_ problems. And that's why i consider haskell as a fun and clean language :-)
11:59:43 <PerlJam> araujo: yep.
11:59:58 <PerlJam> araujo: Definitely easier on the eyes compared to lisp or scheme too  ;-)
12:00:01 <icb1> does the ! in "oosVe :: !Velocity2," mean strict?
12:00:05 <araujo> So your thinking is kind of "higher" level , and when you start seeing things like that, you can easily adopt the model in other languages
12:00:10 <Lemmih> icb1: Yes.
12:00:19 <icb1> where is that defined? 
12:00:24 <icb1> i am looking at ht index
12:00:37 <icb1> there is a bunch in Data.* definitions
12:00:54 <Lemmih> ht index?
12:01:04 <icb1> ghc lib index
12:01:29 <araujo> PerlJam, For example, i had to develop a C programm a few months ago, people was kind of impressed how fast and free-bug i did it
12:01:45 <Lemmih> icb1: It's not a library. It's a strictness annotation.
12:01:47 <twb> How would I go about making a parser that handles a C-like #include?
12:02:10 <icb1> ahh, it should be in the the 98 report then?
12:02:11 <araujo> PerlJam, i barely had to use variables, and most of the wor was done with recursion and pointers to functions
12:02:39 <PerlJam> araujo: I hadn't really hoped to get such a thing from my haskell tinkering but if I do, that'll be awesome.
12:02:41 <Nanar> newbie question
12:02:51 <Nanar> imagine code: http://mandrivafr.pastebin.com/489084
12:03:02 <SamB> twb: it is nearly always ugly
12:03:08 <araujo> PerlJam, Well, let me tell you, you will... Haskell slowly turns into a "thinking-way" 
12:03:10 <Nanar> in this case, what is the best way to avoid printdot(-1)
12:03:16 <araujo> At least that's what happened to me :-)
12:03:37 <Oejet> araujo: I had that experience too.  Haskell really messes with your C programming. :-P
12:03:39 <PerlJam> araujo: well then, I am only encouraged to continue with my chosen path
12:03:50 <twb> SamB: any ideas?
12:04:03 <araujo> Oejet, haha, isn't that fun and beautiful? :-)
12:04:06 <Lemmih> icb1: Yeah.
12:04:14 <araujo> Oejet, You are definetly writing good C code!!!
12:04:25 <araujo> PerlJam, :-)
12:04:28 <icb1> i see "infixl 9  !, //" in the Array definition
12:04:30 <SamB> twb: probably unsafePerformIO and {get,set}{Position,Input}
12:05:01 <PerlJam> the only "problem" I see is that I'll only be using haskell "as a hobby" so I won't exercise my haskell muscles as much as, say, perl or C or php or whatever
12:05:15 <icb1> hmmm, the strict evaluation section talks about $!
12:05:21 <SamB> PerlJam: "only"?
12:05:24 <Lemmih> Nanar: printdot n | n <= 0 = return (); printdot n = do putChar '.'; printdot (n-1)
12:05:35 <twb> @index getPosition
12:05:36 <lambdabot> Text.ParserCombinators.Parsec.Prim, Text.ParserCombinators.Parsec
12:05:48 <icb1> ahhh, i see it, thanks lemmih
12:05:51 <twb> Oops, I used grep instead of zgrep.
12:06:05 <icb1> it is under the "strictness flags" section
12:06:20 <SamB> twb: grep works okay if you have the genuine source tree rather than the sources-as-docs package from Debian
12:06:30 <Oejet> araujo: I think that passing and returning big structs (records) by value is a bit of stretching it, but it _looks_ good. :)
12:06:40 <twb> SamB: yeah :-/
12:06:51 <araujo> Oejet, it does :-)
12:06:55 <SamB> which is not to say this package is not highly useful
12:07:28 <Lemmih> Nanar: Or better yet: printdot n = putStrLn (replicate n '.')
12:07:53 <Cale> printdot n = putStr (replicate n '.')
12:07:56 <Cale> yeah
12:08:31 <Nanar> Lemmih, Cale: yes, sure, but I am trying to understand function and co :)
12:08:40 <Lemmih> @pl printdot n = putStrLn (replicate n '.')
12:08:41 <lambdabot> printdot = putStrLn . flip replicate '.'
12:08:58 <PerlJam> replicate n '.' is like take n (repeat '.')  right?
12:09:34 <Nanar> PerlJam: replicate n time '.'
12:09:40 * PerlJam fires up ghci at work (and all work is stopped :)
12:09:40 <Oejet> Lemmih: Argh, I was in the midst of typing that by hand. :)
12:10:03 * Nanar note replicate
12:10:35 * PerlJam adds replicate to the List of Useful Stuff in his head
12:11:06 <araujo> PerlJam, if you are hacking on perl6, i think you will have pretty much fun :-)
12:11:15 <Nanar> PerlJam: you were using perl and now switching to haskell ? right ?
12:11:43 <Nanar> araujo: I want to patch darcs :)
12:11:54 <Nanar> sound like I have still many works
12:11:59 <Nanar> before pathing
12:13:37 <PerlJam> Nanar: What is this talk of "switching"?  I see people say things like that all the time and I just don't understand it.   I *continue* to use perl and am now trying to add haskell as one of the languages that I can code in my sleep (like C or perl) rather than only a language I can code in but don't have the zen of (like python or PHP)
12:14:38 <Nanar> PerlJam: yes, switching is not appropriate
12:15:21 <Nanar> PerlJam: rephrasing, you use perl adn trying to use haskell
12:15:45 <PerlJam> Nanar: well, I use haskell, just not at the level I'd like.
12:16:05 <PerlJam> I can code haskell (or python or php) apps all dad but it's like speaking a foreign language.
12:16:06 <icb1> It's only when you have lost everything that
12:16:08 <icb1> you are able to do anything.
12:16:52 <PerlJam> I code C and perl like a native (because I am a native as far as I'm concerned) and I'd like to code haskell the same way
12:18:02 <PerlJam> I really wish I'd have run into haskell 15 years or so ago when I was dabbling with scheme and lisp.  I would have dropped them like a rock and never looked back.
12:18:04 <Nanar> after one days of reading doc, haskell become easy now, but oh well, I mean become easy to do something with it
12:18:10 <araujo> I see more purely fuctional programming as a way of thinking. Even if you won't ever touch Haskell for developing applications, it will help you to code in whatever language you have
12:18:11 <Nanar> not to understand everything
12:18:44 <araujo> It is a more profound way of thinking that OOP.
12:18:58 <PerlJam> araujo: I'd have to agree completely.
12:19:02 <_Codex> Then comes categories :)
12:19:04 <araujo> I think you can more easily get OOP out of a functional approach than the opposite.
12:20:06 <PerlJam> The other cool thing is that my daughter is showing an interest in mathematics (she's 7) and I'm thinking that I might just show her some haskell for her first programming language :)
12:20:19 <Nanar> araujo: to me and currently, it is more syntaxic problem, in fact I often wrote code in an "haskell way"
12:20:36 <Nanar> aka just want result of function 
12:21:04 <Nanar> and taking care to all return code
12:21:09 <araujo> PerlJam, that'd be terrific :-)
13:40:34 <PupenoL> Hello.
13:40:58 <PupenoL> Can widgets be created using Gtk2hs ?
13:41:21 <Lemmih> @seen dcoutts 
13:41:22 <lambdabot> dcoutts is in #gentoo-haskell and #haskell. I don't know when dcoutts
13:41:22 <lambdabot> last spoke.
13:50:24 <basti_> PupenoL: what kind of widgets?
13:51:21 <PupenoL> basti_: any. I'd be looking into making a widget that can draw arbitrary figures (I want to port my SRT (http://scret.sf.net) to Haskell+Gtk2hs)
13:51:45 <basti_> like gtk2hs DrawingArea?
13:52:52 <PupenoL> basti_: I'd like to inherit something like the DrawingArea I imagine.
13:54:07 <basti_> hmm nobody stops you from defining an own thing that accesses DrawingArea internally
13:54:50 <PupenoL> basti_: if there aren't bindings for the parts of GObject and Gtk to create new widgets, then that will efectively stop me from creating a widget.
13:55:06 <basti_> hmm
13:55:21 <basti_> i've never looked at this in detail but i thought it was possible
13:55:39 <PupenoL> is there some example of this being done ?
13:55:56 <PupenoL> (like a port of tictactoe to Haskell: http://www.gtk.org/tutorial/a2922.html#SEC-TICTACTOE)
13:59:41 <PupenoL> see you latter.
14:12:17 <Heffalump> what's the most recent version of hws-wp?
14:14:13 <cinema> dcoutts, ping
14:31:06 <imix> where can i find function for conversions between machine byte ordering/network byte ordering?
14:32:58 <SamB> @hoogle htnl
14:32:59 <lambdabot> No matches found
14:33:04 <SamB> @hoogle htonl
14:33:06 <lambdabot> No matches found
14:35:06 <SamB> hmm, not sure!
14:35:58 <imix> I stumbled over the fact that SockAddr from Network.Socket needs port and address in network byte order but offers no conversion functions
14:36:11 <SamB> oh
14:36:13 <SamB> well
14:36:45 <SamB> aren't port numbers in another format anyway?
14:36:45 <SamB> and type too?
14:36:47 <Nanar> re newbie question
14:36:49 <SamB> @type Network.Socket.SockAddr
14:36:51 <lambdabot> Not in scope: data constructor `Network.Socket.SockAddr'
14:36:57 <Nanar> remove = DarcsCommand {command_name = "remove"}
14:37:05 <Nanar> what means {} ?
14:37:19 <imix> the only place i found the usual functions were in a library called network-alt by Einar Karttunen
14:37:25 <SamB> Nanar: in this case, it is record syntax
14:38:08 <SamB> oh, I see.
14:38:16 <SamB> @type Network.Socket.SockAddrInet
14:38:18 <lambdabot> Network.Socket.PortNumber
14:38:18 <lambdabot> -> Network.Socket.HostAddress
14:38:18 <lambdabot> -> Network.Socket.SockAddr
14:38:46 <SamB> anyway, you'll notice a PortNumber isn't an Int
14:38:49 <imix> Nanar: have a look at http://www.haskell.org/hawiki/UsingRecords if you want to know how they work
14:39:07 <Nanar> imix: ah better than asking :)
14:39:09 <Nanar> thanks
14:39:43 <SamB> imix: anyway, try fromIntegral ;-)
14:39:59 <imix> SamB: already tried it, without success
14:40:09 <SamB> imix: what happened?
14:40:51 <imix> SamB: nothing, it still gave me machine byte order
14:41:13 <SamB> how could you tell?
14:42:13 <imix> i traced the result of the whole address composition, instead of port 21 I always got 5376
14:42:38 <SamB> show me!
14:42:38 <psnl> imix: I has service calls in my network code
14:42:46 <psnl> hold on a second
14:43:09 <psnl> (Service "nntp") for example
14:45:59 <imix> SamB: have a look at http://ste.aeschbacher.ch/temp/ftp.hs
14:46:55 <imix> psnl: where can i find your code?
14:47:47 <psnl> imix: sorry, just a random bit of code
14:47:57 <psnl> but all you need is Service ftp
14:48:00 <psnl> but all you need is Service "ftp"
14:48:09 <SamB> imix: it will not work that way
14:48:31 <psnl> main has the wrong type
14:48:36 <SamB> imix: you need to change "PortNum port" to "fromIntegral port"
14:50:29 <imix> SamB: ah, I only tried PortNum fromIntegral port
14:51:34 <SamB> imix: I thought you were making things too complicated for yourself
14:54:58 <imix> SamB: I assume i still make things too complicated with haskell quite often. It's like learning to walk again when one's used to imperative languages (even though I get the impression that it's more like learning to ride a motorcylce when one is used to walk...)
14:56:33 <icb1> where is "forall" defined?
14:57:26 <SamB> icb1: forall?
14:57:31 <icb1> yes
14:57:32 <SamB> @index forall
14:57:33 <lambdabot> bzzt
14:57:49 <SamB> do you mean that thing that sometimes shows up in types?
14:58:05 <icb1> yes
15:03:19 <icb1> hug's parser thinks it is a keyword, but i can't seen to find it in the 98 report's syntax seciton
15:08:09 <dibblego> http://www.nomaware.com/monads/html/ - is this available in PDF or some other source forma convertible to PDF?
15:09:59 <icb1> dibbleg, just do a single large page printout
15:11:46 <dibblego> where is it available as a single page?
15:12:20 <icb1> it is avail as a tar
15:12:59 <dibblego> but that is just several HTML documents - do you mean print each one out?
15:14:06 <icb1> hmmm, i was quite sure i did that once
15:14:23 <dibblego> maybe I am wrong - I will look closer
15:15:43 <icb1> maybe the message is that one should remember it in heart 
15:18:34 <dibblego> it is split across HTML pages
15:19:39 <icb1> dibblego, 24.193.75.185/jake/monad_tutorial.pdf
15:21:53 <dibblego> cheers - where did you get that document from? is it publicly available?
15:22:24 <icb1> i thought i did a print page to pdf a long time ago 
15:22:44 <Dibrom> anyone know of a good source for information on how to handle type reconstruction for rank-2 polymorphism?
15:24:39 <JKnecht> @hoogle Rank2Polymorphism
15:24:40 <lambdabot> No matches found
15:24:49 <JKnecht> @hoogle RankTwoPolymorphism
15:24:50 <lambdabot> No matches found
15:25:08 <JKnecht> http://haskell.org/hawiki/RankTwoPolymorphism
15:25:46 <Dibrom> yeah, I already saw that.. are you referring to the book listed there?
15:26:20 <Dibrom> what I need basically is a description of the type reconstruction algorithm for rank-2
15:26:37 <Dibrom> I've implemented a basic System-F based lambda calculus and would like to add type inference to it
15:27:33 <Dibrom> I suppose I could dig through the haskell source, but it'd be nice to get something more direct
15:28:27 <dcoutts> Lemmih: pong
15:28:55 <dcoutts> PupenoL: oh, you're wondering about gtk2hs
15:29:33 <Pupeno> dcoutts: I'm at home now. Yes, I was wondering about wether I can create new widgets with gtk2hs and if there's an example out there.
15:30:01 <dcoutts> Pupeno: do you mean just do some custom drawing on a blank widget?
15:30:38 <dcoutts> or do you mean create a new type of widget (inherited from another GObject) that appears as a distinct GType to foreign C code
15:30:50 <Pupeno> dcoutts: not really. I want to have my own widget (wich would do custom drawing) with it's own sets of function and signals.
15:30:55 <JKnecht> "From System F to Typed Assembly Language" is in the ACM digital library if you have access.
15:30:59 <Pupeno> dcoutts: the second.
15:31:16 <Dibrom> no access AFAIK
15:31:32 <Dibrom> but it looks like there is a paper on SPJ's site that might help
15:31:36 <dcoutts> Pupeno: the second is not possible but I don't think it's necessary
15:31:39 <Dibrom> "practical type inference for arbitrary-rank types"
15:31:51 <dcoutts> Pupeno: unless it must appear as a different GType to foreign code
15:32:14 <Pupeno> dcoutts: I intend to port my Score Reading Trainer (http://scret.sf.net) to Haskell+Gtk2hs. The center is a separate widget (that might be used on other applications as well)
15:32:27 <dcoutts> Pupeno: it's easy to customise a DrawingArea to do stuff on redrawing & catch signals/events
15:33:18 <Pupeno> but I won't be able to set my own custom signals, right ?
15:33:23 <dcoutts> so if it's ok to return a GtkWidget or a GtkDrawingArea to the foreign code then it's ok, if it absolutely must appear to foreign code as a MyCustomWidget type then you need to do some bits in C
15:33:53 <dcoutts> Pupeno: you can catch any signals that GtkWidget defines
15:34:15 <dcoutts> Pupeno: are you trying to present an interface to foreign code?
15:34:33 <Pupeno> dcoutts: no, I only want to use it from Haskell.
15:34:39 <dcoutts> Pupeno: then it's no problem
15:35:13 <Pupeno> you mention catching signals, but I mean emiting signals.
15:35:16 <dcoutts> Pupeno: you can make Haskell objects that use arbitrary callbacks
15:35:52 <dcoutts> it's quite common to make customised 'widgets' that take various IO () callbacks as parameters
15:36:29 <Pupeno> is there any example ?
15:36:41 * dcoutts thinks
15:37:03 <dcoutts> there's some code like that in hIDE
15:37:27 <Pupeno> a port of tictaktoe would be exactly what I need (it'd be what I do to leart to do it): http://www.gtk.org/tutorial/a2922.html#SEC-TICTACTOE
15:38:33 <dcoutts> Pupeno: in hIDE there's a list widget abstraction that takes two callbacks which get invoked for when a list item gets selected and another for when one get's right clicked. And their in terms of the list's abstract model rather than the underlying GtkTreeView api.
15:39:00 <dcoutts> Pupeno: there's a memory game tutorial written by boegel 
15:39:40 <Pupeno> dcoutts: I don't think that the game makes its own widget and I couldn't get it to compile anyway, it seems very old.
15:40:05 <dcoutts> it's a little old, it shouldn't need much changed
15:40:29 <dcoutts> Pupeno: the graphic & cairo demos show how to draw on a GtkDrawingArea
15:40:49 <dcoutts> then it's jsut a matter of making a function like:
15:41:08 <Pupeno> dcoutts: I changed as far as I could (compilte time errors), but there are runtime errors of which I have no idea how to solve them.
15:41:51 <dcoutts> Pupeno: oh, hmm. I've not looked at it in a while. Perhaps with boegel's permission i could incorperate it into the Gtk2Hs demo collection so we could keep it up to date
15:42:11 <dcoutts> mkTickTackToeBoard :: SomeCallback -> IO Widget
15:42:46 <dcoutts> and the mkTickTackToeBoard would make the DrawingArea and setup all the events etc (possibly using any of the supplied callbacks)
15:43:03 <dcoutts> and return the widget so it can be packed into another window or container
15:43:15 <Pupeno> dcoutts: is this (not being able to make a widget) a limitation of Gtk2hs or is a limitation of every high-level binding to gtk+ ?
15:43:28 <dcoutts> mostly both :-)
15:43:46 <dcoutts> python allows one to make new widgets and present them as such to foreign code
15:44:15 <dcoutts> so you can write a widget in python and have it appear as a distinct GType to C code
15:44:28 <Pupeno> but?
15:44:41 <dcoutts> with Gtk2Hs at the moment it'd appear as a GtkDrawingArea
15:45:05 <dcoutts> with python you could make it appear as MyNewWidget which inherits from GtkDrawingArea
15:45:30 <dcoutts> however it's not obvious that it's very useful to be able to do this
15:46:07 <Pupeno> dcoutts: ok, I'll try to do it now, will you be here for a while ?
15:46:10 <dcoutts> since we don't often want to create new widgets in Haskell that will need to be used from C
15:46:53 <dcoutts> Pupeno: probably for a bit, I'm here quite often
15:50:15 <Pupeno> where can I find that code (the list of hide) ?
15:53:23 <dcoutts> @where hIDE
15:53:24 <lambdabot> http://www.haskell.org/hawiki/hIDE
15:54:33 <dcoutts> http://scannedinavian.com/repos/hIDE/plugins/ideShell/src/Hide/IdeShell/
15:56:06 <dcoutts> http://scannedinavian.com/repos/hIDE/plugins/ideShell/src/Hide/IdeShell/MainWindow.hs
15:58:42 <dcoutts> Pupeno: or the FileBrowser.hs has something similar
15:58:49 <xerox> hIDE!  The development is going somewhere?
15:59:13 <dcoutts> xerox: hia. Well I'm still working on stuff underneath.
15:59:53 <dcoutts> Like the treeview api so we can have a decent directory/file tree
16:00:16 <xerox> I was thinking about the TreeView API some days ago.
16:00:21 <dcoutts> good!
16:00:24 * dcoutts too
16:00:25 <Lemmih> I'll probably wait till GHc-6.6 before hacking more on hIDE.
16:00:35 <dcoutts> Lemmih: yeah
16:00:55 <xerox> But I'm kinda sleepy now, 1am, yaaaaaawn.
16:00:57 <dcoutts> I'm worried that some of our stuff got too unreliable too quickly
16:01:27 <dcoutts> we've had rather a lot of crasher bugs
16:01:50 * Lemmih blames the ghc library (:
16:01:53 <dcoutts> heh
16:02:13 <dcoutts> dons: I've not tried gtk yi for a while. How reliable is it?
16:02:46 <dcoutts> I'm still interested in working on the extensable / pluggable gui framework parts
16:02:53 <xerox> Goodnight folks.
16:02:57 <dcoutts> g'night xerox 
16:03:03 <Lemmih> night, xerox.
16:03:14 <JKnecht> nitey nite.
16:05:08 <dcoutts> Pupeno: so you work on this?: http://scret.sourceforge.net/
16:05:27 <Pupeno> dcoutts: yes, I made it.
16:05:29 <dcoutts> Pupeno: it'd be cool to do that with Gtk2Hs and using cairo
16:05:38 <Pupeno> dcoutts: yes :)
16:05:51 <dcoutts> using cairo would make the grapics more smooth
16:06:15 <dcoutts> how do you generate the notation?
16:06:22 <dcoutts> fonts or manually?
16:07:27 <Pupeno> you mean the drawing of the notes, clefs, alterations ? they are PNGs, created from SVGs I draw (based on other images of course).
16:07:39 <dcoutts> I see
16:07:57 <Pupeno> dcoutts: any recomendations of a better way to do it ?
16:08:05 <dcoutts> svg via cairo
16:08:28 <dcoutts> that'd give you smooth scalable vector graphics
16:09:02 <Pupeno> I created svgs thingking in the time when I was going to use them directly.
16:09:02 <dcoutts> we've not bound the svg cairo api yet but it's not very big. I think it'd be quite easy.
16:09:49 <dcoutts> xerox: (message for when you wake up!) have you thought about binding the svg cairo api?
16:10:42 <dcoutts> Pupeno: there is a svg api extension for cairo that allows one to integrate drawing svg with other cairo operations
16:11:04 <dcoutts> so one can do a mixture of svg with custom cairo drawing
16:11:16 <JKnecht> Unicode for an on the cheap option eg: &#x266F; .
16:11:23 <dcoutts> so one can scale & transform the svg and then draw on top of it etc
16:11:51 <dcoutts> or yeah, just use cairo to draw some unicode font
16:13:26 <Pupeno> oh! that'd be an interesting aproach. Won't I encounter problems like the user not having any font providing a given glyph ?
16:13:38 <dcoutts> Yes that would be a problem
16:13:52 <dcoutts> you'd be at the mercy of whatever fonts are installed
16:14:21 <dcoutts> I'm not sure how easy it is to add an extra font along with a program
16:14:49 <dcoutts> Pupeno: in fact the older version of the Haskell cairo bindings included bindings for libsvg-cairo
16:15:01 <dcoutts> so it should be really easy to update and get working
16:15:16 <dcoutts> here's the old version: http://ofb.net/~abe/darcs/svg-cairo/
16:24:26 <tewk> I have an IO String and a function that takes a String, Can I get from an IO String to a String?
16:24:38 <dcoutts> no
16:24:47 <dcoutts> once 'inside' IO you can't get out
16:25:15 <dcoutts> you can do whatever you like with the string so long as the overall result stays inside IO
16:25:32 <dcoutts> eg you've got a function f :: IO String
16:25:39 <JKnecht> Pupeno: both IE and Mozilla will have the required Unicode font support, eg. for sharp symbol.
16:26:06 <dcoutts> do { str <- f; return (g str) }
16:26:17 <JKnecht> i.e., as currently distributed.
16:26:58 <dcoutts> tewk: so in that little example above we can use the str :: String (in the call to g) but the overall result is still in the IO monad.
16:27:09 <dcoutts> tewk: does that make any sense?
16:28:54 <tewk> dcoutts: yep, so what would the type of str be and where is <- defined, I like understand what is going on
16:29:21 <dcoutts> tewk: so str is of type String
16:30:10 <dcoutts> the <- operation is 'performing' the IO String to get a String (but the result is only accessable from inside the 'do' block)
16:30:24 <dcoutts> so the 'String' does not escape the IO monad
16:30:53 <tewk> Ok, I get that.
16:30:58 <Pupeno> dcoutts: newFileBrowserView would be the function creating the new widget, right ?
16:31:08 <dcoutts> tewk: the 'str' above is only in scope for the rest of the do block.
16:31:17 <tewk> Right, go it
16:31:23 <tewk> s/got/it
16:31:39 <mauke> do { str <- f; return (g str) } is syntactic sugar for f >>= \str -> return (g str)
16:31:52 <dcoutts> tewk: and the do block as a whole must return something of type 'IO a' (for some type 'a')
16:32:06 <dcoutts> Pupeno: right
16:32:33 <dcoutts> Pupeno: it's returning a Haskell record which contains a widget as private data
16:33:00 <dcoutts> the record members are not exposed in the module interface
16:33:27 <dcoutts> but you could equally return just the widget after attaching all the signal handlers etc
16:38:26 <tewk> dcoutts: Ok how do I store off the result of g in a monad, cause I'm not ready to leave the do block yet?
16:39:09 <dcoutts> do str <- f
16:39:12 <dcoutts>    let blah = g str
16:39:14 <dcoutts>    ...
16:39:53 <dcoutts>    return (... something ...)
16:40:56 <tewk> Ok, what is the type of blah now?
16:41:30 <dcoutts> the result type of the function g
16:42:02 <dcoutts> eg g :: String -> Int
16:42:10 <dcoutts> then blah would be :: Int
16:42:10 <SamK> hi, i was wondering, is there any trick to getting fast random access into a list in haskell, without traversing the entire list each time?
16:42:25 <dcoutts> SamK: turn the list into an array
16:42:39 <SamK> ah right
16:42:40 <dcoutts> @docs Data.Array
16:42:40 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array.
16:42:40 <lambdabot> html
16:42:58 <SamK> are arrays non-destructive in haskell?
16:43:02 <dcoutts> @type Data.Array.array
16:43:03 <lambdabot> forall e i.
16:43:03 <lambdabot> (GHC.Arr.Ix i) =>
16:43:03 <lambdabot> (i, i) -> [(i, e)] -> GHC.Arr.Array i e
16:43:04 <mauke> lambdabot: stop breaking your replies across multiple lines!
16:43:10 <dcoutts> @type Data.Array.listArray
16:43:11 <lambdabot> forall e i. (GHC.Arr.Ix i) => (i, i) -> [e] -> GHC.Arr.Array i e
16:43:21 <Lemmih> SamK: You can get mutable arrays if you want.
16:43:29 <dons> SamK, there are both immutable and mutable arrays
16:43:43 <Lemmih> Hi dons.
16:43:56 <dcoutts> dons: congratulations on becomming emperor
16:44:04 <dcoutts> er, I mean HWN editor
16:44:04 <dons> I'm emperor?
16:44:09 <SamK> I guess turning a long list into an array, performing the lookups, and the turning it back into a list isnt the best thing performance wise?
16:44:11 <dons> oh, in the topic. hmm.
16:44:20 <dcoutts> :-)
16:44:23 <dons> :)
16:44:30 <dcoutts> SamK: indeed
16:44:40 <dcoutts> it'll only save you time if you do lots of lookups
16:45:11 <SamK> ok
16:45:50 <dcoutts> if you're doing lots of updates as well as lookups you might want a different collection type than a list or array
16:46:00 <dcoutts> eg a Map or Set
16:46:15 <dcoutts> or a mutable array or a hash table
16:46:45 <dcoutts> Map & Set are nicer than mutable arrays or hashes
16:47:28 <dons> SamK, yes, Map is much more idiomatic Haskell
16:47:45 <SamK> right, will have to look into that
16:48:54 <dons> > M.insert "foo" 7 M.empty :: M.Map String Int
16:48:55 <lambdabot> {"foo":=7}
16:49:25 <SamK> cool, how fast are the lookups?
16:49:34 <SamK> hash table?
16:50:14 <dons> log n
16:50:34 <dons> it uses size balanced binary trees
16:50:56 <SamK> so they are immutable?
16:51:40 <dons> they're normal haskell values.. so destructive updates aren't kosher
16:52:04 <dcoutts> they're persistent, like all Haskell values
16:52:46 <dcoutts> you make new maps from old ones, but the old ones persist (until they're GC'ed)
16:53:13 <SamK> didnt realise haskell had mutable arrays.. i've only just started to learn it ;)
16:53:38 <dons> they're really for specialised problems. you rarely need them
16:54:34 <dcoutts> only for when performance tuning critical parts of a program
16:55:03 <SamK> sounds like map is what I need actually, resonable fast random access, insert etc
16:55:49 <dcoutts> what are you storing looking up? is it a sequence or like a key-value association?
16:56:02 <SamK> well, its a list of 3D vertices, and a list of triangles
16:56:12 <SamK> each triangle has 3 indicies into the vertex array
16:56:36 * dcoutts notes that there isn't a random access seqence module in the standard libs
16:56:50 <dcoutts> and that there should be!
16:57:04 <SamK> and I want to build a new list which has 3 times the vertices, by getting the triangle indicies and appending the indexed vertices
16:57:44 <SamK> so, basically, iterate through all triangles, and read the indexed vertices, i.e. a lot of indexing
16:58:55 <SamK> if that makes any sense :)
16:59:16 <SamK> so how does haskell reconcile mutable arrays with purity?
16:59:28 <dons> with monads!
16:59:35 <dcoutts> an IO or ST monad
16:59:37 <SamK> might have guessed..
16:59:39 <dons> mutability is all about sequencing
17:00:20 <dons> so it's quite easy to write programs that do lots of destructive mutation of datta
17:01:05 <dons> i've written a couple of programs that spend most of their time overwriting chunks of raw memory. haskell just turns out to be the world''s best imperative language
17:02:10 <dcoutts> dons: oh yes, I was wondering how stable gtk yi is atm?
17:03:02 <dons> gtk yi, hmm. i got it working, and the testsuite running. but i'm not sure how stable it is.
17:03:15 <dons> depending on gtk versions, people reported some issues.
17:04:05 <dons> hmm. it's probably reasonably stable though.
17:04:14 <dcoutts> ok
17:04:54 <dcoutts> a good milestone should be getting a decent multi-file editor working
17:05:20 <dcoutts> you know - one of those programmer's editors with a dir tree down the side
17:05:45 <dcoutts> I know I'd find it useful even at that point
17:06:00 <dcoutts> and then we'd find the crasher bugs if we were dogfooding :-)
17:06:29 <dcoutts> dons: do you do your coding with Yi ? :-)
17:07:17 <SamK> does anyone know of any video lectures/tutorials for learning haskell? I found the "structure and interpretation of computer programs" lectures very usefull for lisp/scheme
17:07:37 <dons> not yet. but the curses yi has had some work recently, particularly syntax highlighting. so it's very usable. some people in fact use it!
17:07:48 <dcoutts> cool
17:08:02 <dons> i'm always surprised at how well it does vim when I fire it up :S
17:08:14 <araujo> dons, dcoutts hey!
17:08:44 <araujo> dons, a question, what's wrong with this:
17:08:46 <araujo> pdynload "World.o" [] [] "world" >>= (\ x -> case x of{ LoadSuccess _ m -> putStrLn m ; _ -> print "error"
17:08:59 <araujo> world is a String.
17:11:22 <dons> do you need to use pdynload? it's a bit slower, and rarely needed?
17:12:12 <dons> pdynload "../Plugin.o" ["../api"] [] "API.Interface" "resource"
17:12:41 <dons> an exampel. so 'world' should be the type to check against, no? and what symbol are you looking up?
17:14:37 <araujo> dons, well, use type String
17:16:42 <araujo> mmm....
17:16:53 <araujo> dons, Ok, i think i better use load
17:18:31 <dons> pdynload is only needed if you nothing about the code you're loading.. if you wroote the code yourseeelf, use load, or dynload (at most)
17:18:47 <dons> .. if you know nothing about ...
17:19:42 <araujo> dons, Ok, i see that for dynload the types must be Typeable
17:20:15 <dons> yep, it uses Dynamic checks
17:20:42 <dons> instead of calling ghc at runtime to do a typecheck
17:20:47 <araujo> dons, well, actually, that's what i want... (pdynload)
17:21:31 <araujo> dons, mevertheless, i don't seem to get the result i want with it
17:21:40 <araujo> Prelude System.Plugins> pdynload "World.o" [] [] "String" "world" >>= (\ x -> case x of{ LoadSuccess _ m -> putStrLn m ; _ -> print "error" })
17:21:40 <araujo> "error"
17:22:22 <dons> have a look at the examples/pdynload code in hs-plugins
17:23:17 <araujo> Ok
17:23:18 <dons> I'm pretty sure pdynload plays games with qualified type  names. so you still need an API mdoule that will export String, so it can be referred to as API.Type.
17:24:01 <dons> that wasn't clear.  I think pdynload needs a qualified type name, so 'String' won't work, I think.
17:24:47 <araujo> ok, get it
17:27:37 <araujo> dons, But i see that the return type of load is polymorphic
17:27:52 <araujo> So i can load pretty much whatever i want with it too?
17:28:59 <dons> sure. you need to provide some kind of type context so ghc knows what type is being used. with `load' you assert the type, with dynload and pdynload, that type also gets checked 
17:33:54 <LordBrain> Hi
17:34:03 <LordBrain> I see GHC/Unicode.hi
17:34:12 <LordBrain> in my ghc6 package
17:34:36 <LordBrain> but... my viewer says thats a binary file.. how do i view the interfaces to modules that come with ghc?
17:34:54 <dons> @docs Data.List
17:34:55 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
17:34:57 <dons> :)
17:34:59 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
17:35:02 <dons> don't read .hi files
17:35:29 <dons> they're binary data for the compiler only.
17:35:33 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/GHC-Unicode.html
17:35:58 <dons> @docs GHC.Unicode
17:35:59 <lambdabot> GHC.Unicode not available
17:36:03 <dons> interesting.
17:36:12 <SamB> LordBrain: if you MUST read .hi files, use ghc --show-iface
17:36:24 <LordBrain> ah
17:36:27 <LordBrain> thanks
17:36:45 <SamB> but they won't be very informative
17:37:39 <LordBrain> hmm
17:37:44 <SamB> more usefully, you could fire up GHCi and do :m Data.List
17:37:50 <LordBrain> well what i'm trying to do is work with utf8
17:38:13 <SamB> well...
17:38:23 <LordBrain> like
17:38:51 <LordBrain> to do something like: find (=='C') "bahCbah" 
17:38:59 <LordBrain> where C is say an umlat
17:39:02 <LordBrain> or something
17:39:12 <LordBrain> a funky character in utf-8
17:39:18 <SamB> @hoogle utf8
17:39:19 <lambdabot> No matches found
17:39:46 <SamB> I guess I'll have to tell you our little secret:
17:40:00 <SamB> Haskell doesn't actually support utf8 yet
17:40:06 <dons> > find (== '\789') "abcde\789def"
17:40:07 <lambdabot> Just '\789'
17:40:19 <LordBrain> hmm
17:40:39 <SamB> however, it does support Unicode
17:41:05 <dcoutts> SamB: GHC doesn't support Unicode character or string literals. The Haskell spec mandates Unicode but no compilers implement it. :-(
17:41:09 <SamB> so, you'd need to decode utf8 in some implementation-dependant manner
17:41:41 <SamB> dcoutts: yeah, but the spec doesn't specify how to read utf-8 files does it?
17:42:09 <dcoutts> SamB: the spec doesn't specify the unicode encoding to use I think
17:42:40 <SamB> so, as I said, Haskell doesn't support utf-8 ;-)
17:42:40 <dcoutts> you can use unicode characters by their index in string & char literals
17:42:48 <dcoutts> there is code lying about for doing utf8 <-> ordinary String conversion
17:43:00 <SamB> true
17:43:01 <dcoutts> Gtk2Hs has some, other projects have it too
17:43:35 * dcoutts &
17:44:05 <SamB> of course, at some point in the future if GHC switched to reading utf8 by default, then of course that wouldn't work right anymore...
17:45:39 <Pupeno> there aren't gnome bindings yet, right ?
17:46:10 <SamB> what is gnome?
17:47:02 <dons> @google gnome
17:47:03 <lambdabot> http://www.gnome.org/
17:47:08 <SamB> I don't see any bindings here.
17:47:27 <SamB> but I'm uncertain what such bindings would do for one.
17:47:40 <SamB> I was under the impression that GNOME was a desktop environment...
17:47:59 <dons> you could program using the gnome api.. ?
17:48:06 <SamB> but it doesn't seem to reimplement the entire GUI toolkit the way KDE does
17:48:09 <Saulzar> No doubt it has various hooks for things like interacting with docking etc.
17:48:21 <SamB> so I'm not sure what you're looking for
17:48:33 <tewk> What is normall haskell convention for multiword variablenames such as function parameters,  functions names seem to be camel case.  is it myArgYipee or my_arg_yipee or myargyipee ?
17:48:38 <SamB> they do have libs for all sorts of non-gui things, and maybe a few extra widgets
17:48:42 <Pupeno> bindings for the gnome api, it extends gtk.
17:48:52 <Cale> tewk: camelCase
17:49:11 <SamB> Pupeno: well. you could specify what parts of it you are interested in.
17:49:15 <Pupeno> for example, the class GnomeApp.
17:49:35 <SamB> what does that do?
17:49:39 <Pupeno> and the functions needed to initialize a Gname application.
17:49:57 <SamB> it sounds like the kind of thing skeller's like to avoid...
17:50:02 <Pupeno> SamB: its a the main window of an application.
17:50:10 <SamB> oj
17:50:12 <SamB> er, oh
17:50:12 <LordBrain> i've never been clear on the motivation for using the gnome api.. wouldnt that make it so your program requires gnome?
17:50:18 <dons> tewk, __only_C_programmers_waste_space_like_this
17:50:25 <SamB> that should be called GnomeAppWindow
17:50:37 <SamB> or something like that
17:53:49 <SamB> which link on http://developer.gnome.org/doc/API/ would be of interest?
17:54:10 <tewk> Can this be simplified or shortened             readFile g >>= \x -> return ( parseGrammar x)
17:54:46 <SamB> tewk: liftM parseGrammar $ readFile g
17:55:11 <SamB> aka liftM parseGrammar (readFile g)
17:57:11 <SamB> Pupeno: well?
17:57:42 <dons> @pl readFile g >>= \x -> return (parseGrammar x)
17:57:43 <lambdabot> parseGrammar `fmap` readFile g
17:58:04 <Pupeno> SamB: I needed gnome_program_init (http://developer.gnome.org/doc/API/2.0/libgnomeui/ch01.html#initialization)
17:58:12 <dons> our lambda robot can rewrite code for  you, tewk
17:58:40 <SamB> Pupeno: well. you could import it yourself for now, probably...
17:58:58 <Pupeno> SamB: what do you mean by 'import' ?
17:59:20 <SamB> Pupeno: foreign import, to be precise
18:00:22 <tewk> dons: cool, where is the code for lambdabot, I'd love to see it.
18:00:36 <dons> @version
18:00:37 <lambdabot> lambdabot 3p266, GHC 6.5.20050806 (Linux i686)
18:00:37 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
18:00:44 <dons> there ^^
18:01:12 <SamK> is there a way to chat privately with lambdabot?
18:01:29 <dons> yes,, /msg
18:01:54 <SamK> mmm. tried that before, dont think it likes me
18:02:10 <dons> you need to register on freenode
18:02:15 <dons> and identify yourself
18:02:41 <SamB> Pupeno: yuck! its vararg!
18:02:42 <SamK> ah
18:04:44 <tewk> Thanks for all the help, as I said to AudreyT the other day working with haskell becoming fun and enjoyable instead of painfull :)
18:04:58 <dons> cool :)
18:05:09 <dons> it should never be painful.
18:05:17 <dons> what did you find hard?
18:05:57 <SamB> dcoutts: how would you interface with a vararg function?
18:06:22 <dons> use TH to generate a number of imports?
18:06:30 <dons> (I did this with printf once)
18:06:31 <SamB> or even a va_list function
18:06:47 <dons> what does the report say?
18:06:58 <dons> the ffi addendum, I mean.
18:07:06 <SamB> dons: report?
18:07:21 <SamB> the ffi addendum isn't going to be a lot of help
18:07:27 <SamB> it is not a HOWTO document
18:07:52 <dons> it describes interfacing with the type system of C though..
18:08:35 <dons> SamB, why wouldn't the ffi addendum mention varargs? it seems some statement would be required at least.
18:08:52 <dons> such as "we don't attemmpt to handle varargs". or "C is dumb".
18:09:48 <dons> or "we provide a proof of the equivalence of C with varargs and a subset of the lambda calculus". ok. i'll stop with the silly jokes.
18:09:59 <tewk> dons: It hasn't been that bad.  I guess I need more experience.  Syntax mostly.  I've been working on pugs mostly.  I'm starting to be able to refactor comfortably.
18:10:56 <SamB> dons: what about va_lists?
18:11:02 <tewk> I knew I needed a lift function but I was trying to use liftIO instead of liftM, higher order functions, currying that I miss etc.
18:11:52 <tewk> matching against record field ..
18:12:34 <SamB> how would one go about adding bindings to gtk2hs?
18:14:55 <Cale> dons: Could hs-plugins together with the Text.Printf trick handle varargs?
18:15:14 <Saulzar> Wow, retainer profiling is god. 
18:15:30 <dons> you can do runtime metaprogramming with hs-plugins, so yes. just as TH would also work, I think.
18:15:39 <SamB> Saulzar: I thought you said that crashed on you
18:15:42 <Cale> TH is compile time though
18:15:50 <dons> any of the usual ways to solve the printf issue would work, I think.
18:15:58 <Saulzar> SamB, Nope? I never knew about it until 5 minutes ago :)
18:16:09 <SamB> huh
18:16:16 <Cale> I suppose that's basically sufficient, but you'd have to expose your library's users to TH
18:16:22 <Saulzar> Let me solve 90% of my memory leak in 10 seconds
18:16:37 <SamB> what are you writing?
18:17:41 <Saulzar> A little AI game
18:23:20 <SamB> hmm, there doesn't appear to be any reasonable way to create a va_list dynamically...
18:24:39 <dons> generate the code at runtime with `eval` ?
18:25:49 <SamB> I was thinking something more along the lines of "provide a TH function to generate a call"
18:26:05 <SamB> or something like that...
18:26:41 <SamB> the thing is, I can't imagine they don't have a backdoor for Python and suchlike languages
18:26:56 <sproingie> hm.  does forkIO preempt threads even when they don't use native OS threads?
18:27:13 <SamB> sproingie: assuming they allocate, yes
18:27:37 <sproingie> the example in the Control.Concurrent docs actually alternates 'a' and 'b' for me
18:27:43 <sproingie>    main = forkIO (write 'a') >> write 'b'
18:27:44 <sproingie>      where write c = putChar c >> write c
18:28:55 <sproingie> prints a lot of 'a' then a lot of 'b' and so on
18:29:33 <SamB> sproingie: you didn't expect it to switch too often, did you?
18:30:33 <sproingie> sometimes it switches every iteration of write, after i let it run for a bit. basically random.  the docs suggest it'll only write one of them
18:31:16 <sproingie> top shows only one instance of the process running, so it appears it only has one os thread
18:31:29 <SamB> that is perfectly normal
18:32:01 <SamB> OS threads are rather heavyweight and tend to be OS-dependant
18:32:39 <sproingie> wasn't planning on depending on fully cooperative behavior anyway.  the docs do seem to indicate it tho
18:33:04 <sproingie> tho they also say it's implementation dependent, so i guess no one should ever have depended on it
18:35:20 <sproingie> meh.  looks like rtsSupportsBoundThreads is false for me anyway
19:25:31 * araujo bit bored
19:25:45 <dons> @yow
19:25:46 <lambdabot> Hey, waiter!  I want a NEW SHIRT and a PONY TAIL with lemon sauce!
19:26:01 <araujo> hah
19:31:06 <dons> how's code araujo?
19:31:49 * sproingie .oO( couldn't match `LemonSauce a' against `Hairstyle a' )
19:32:19 <dons> lambdabot is good at generating mental type errors :)
19:32:28 <araujo> dons, it is good so far, i added alias support and redirection of stderr to hashell a couple of days back :-)
19:32:44 <dons> cool
19:33:00 <dons> can I chsh to hashell yet?
19:34:27 <Cale> reductor seems to quit for Excess Flood an awful lot.
19:34:47 <dons> yes, saw that yesterday too
19:34:58 <resiak> Perhaps reductor is *gasp* a spambot?
19:35:21 <SamB> resiak: spambots don't generally idle in channels do they?
19:35:38 <resiak> SamB: Sure they do. They gather handles to spam.
19:36:21 <dons> but where's the excess flood happening?
19:36:27 <Saulzar> Hmm, not just today either - I'm always seeing that message
19:36:27 <araujo> dons, Of course!!
19:36:31 <SamB> then why would ti be flooding?
19:36:32 <resiak> Some other channel? /msges?
19:36:35 <araujo> dons, The thing is kind of stable now
19:36:49 <dons> @where hashell
19:36:50 <lambdabot> haskell.org/hashell
19:36:58 <araujo> I use it pretty well, of course, it is kind of limited yet in comparison with , say, bash... but it works
19:37:15 <dons> good good. keep up the work :)
19:37:19 <dons> @karma+ araujo
19:37:20 <lambdabot> araujo's karma raised to 4.
19:38:17 <dons> looks like some of the h4sh examples would also map to hashell
19:38:45 <dons> here are some h4sh one liners: http://www.cse.unsw.edu.au/~dons/h4sh.txt
19:40:09 <araujo> :-)
19:40:15 * araujo checks
19:41:40 <araujo> dons, oh, interesting, i hadn't looked at that paper
19:44:30 <dons> and you've seen: http://www.cse.unsw.edu.au/~pls/thesis-topics/functionalshell.html?
19:44:42 <dons> there's some interesting references at the end.
19:44:53 <dons> time to add hashell to the list
19:46:40 <araujo> dons, i don't remenber looking at that site, but ive been reading about Es
19:49:42 <araujo> dons, ive just wanted something that allowed me to express scripting tasks using as much Haskell as possible
19:50:49 <araujo> So like, for example, if i need to parse a config file, i just can treat it like a list of String for example.
19:51:15 <rep> is unsafePerformIO ever necessary?
19:51:30 <araujo> I'd dare to say 'no'
19:51:44 <rep> i don't really understand the point of it
19:51:58 <gzl> all of these hashell examples seem way more complicated than the usual things in a normal shell
19:52:26 <dons> rep, sometimes it's useful, for ffi work.
19:52:32 <dons> which is why it was introduced.
19:52:44 <dons> gzl, what about the h4sh examples
19:53:39 <gzl> most of those are roughly the same, some are more complicated
19:53:55 <araujo> gzl, They are very simple really. As long as you grasp at the basic ideas, you practically can use Haskell for whatever you want.
19:54:02 <sproingie> rep: unsafePerformIO is for convenience.  there's "safe" places to use it actually
19:55:01 <rep> sproingie like?
19:55:18 <sproingie> setting up global variables
19:55:41 <sproingie> docs for control.concurrent have an example of that
19:56:36 <gzl> araujo: but why write some really long expression in Haskell when you can write a short shell command?
19:56:48 <gzl> like this: n::(Text.Regex, Maybe|) unwords [ x | x <- (lines <|ps aux|>) , isJust (matchRegex (mkRegex "hashell") x) ] 
19:57:12 <araujo> gzl, For example, if you know that <|command|> maps to the output of the command in form of [Char] , and that '!~' is like '$' but for hashell complete expressions, you pretty much understand what it does. 
19:57:16 <gzl> you really want to write that on the command line instead of ps aux | grep hashell
19:57:24 <gzl> it's not a question of not understanding, it's a question of what the point is
19:57:48 <araujo> gzl, Those are just 'examples' of how to do certains things with hashell
19:57:52 <dons> shell is not great once you need more than 10 lines of it.
19:58:12 <gzl> I know, I'm just saying they're not very convincing examples
19:58:29 <araujo> gzl, There is really no real examples where you can see the advantage of hashell over other shell in those examples.
19:58:30 <gzl> the h4sh one liners are definitely better
19:58:47 <araujo> I didn't intend that.
19:58:52 <gzl> so what's the advantage of hashell?
19:58:59 <araujo> I intended to show how certains things are possible through Haskell
19:59:04 <gzl> ok
19:59:22 <araujo> To have a purely functional language for scripting tasks.
19:59:34 <araujo> I don't intend to convince anyone Hashell is the best shell out there.
19:59:42 <gzl> ok, but it appears to be a lot more verbose
20:00:02 <araujo> yes it is. 
20:00:39 <gzl> and a major benefit of a functional language is that it's often more clear and concise
20:00:52 <gzl> so it sseems like a big benefit is missing
20:01:32 <gzl> sorry, I don't mean to rag on you or anything. I definitely think it's very cool to see that it works. and I know it's alpha. I'm just wondering how you're eventually envisioning actual use
20:02:11 <araujo> yes, it is alpha, and many things are changing yet.
20:04:41 <araujo> The idea is that you can think on terms of functions while working with your shell.
20:04:55 <araujo> So it is pretty much a way of thinking.
20:05:56 <gzl> right. I suppose I'm just not yet convinced that that way of thinking is especially effective in this context.
20:07:44 <araujo> gzl, How would you get a list of words out of a file in bash?
20:08:50 <araujo> gzl, That is a quick reasoning for any haskell programmer
20:09:19 * araujo waits for gzl 
20:10:18 <gzl> sorry, my internet connection sucks, I keep getting disconnected. I don't know offhand, I've never had to do that before
20:10:47 <araujo> That's what i want to avoid , "not knowing off-hand"
20:10:55 <gzl> either there's some command that helps you do this or you have to resort to sed or something
20:11:05 <araujo> words <|cat file.txt|>
20:11:11 <araujo> That is it in hashell
20:11:27 <gzl> ok, that's a good example.
20:11:29 <araujo> I don't need to go through any command
20:11:43 <araujo> I can reason in terms of haskell to get things done
20:12:39 <gzl> yeah, that's fair. I think it also has to do with how much stuff the Prelude has in it already, though
20:12:50 <araujo> Of course, some examples will look more bloated than others.
20:13:09 <araujo> But i hope many things to change yet
20:13:28 <araujo> The Prelude is an amazing piece of software
20:14:44 <araujo> One of the goal of hashell, it is precisely to take it into the command line world.
20:15:22 <gzl> sure
20:16:44 <gzl> maybe you should put that words example on that page instead
20:16:52 <gzl> rather than stuff that's harder to write in hashell than bash
20:17:21 <araujo> Do they look too scary? :-)
20:17:30 <araujo> Well, considering that ive not written any docs....
20:17:34 <gzl> the huge one that's just ps aux | grep hashell especially :)
20:17:59 <gzl> or the users one right after
20:18:39 <araujo> Oh, or i should probably add further explanation about the command. I actually wanted that command to show how to import two modules at once.
20:19:07 <araujo> It both imports Text.Regex and Maybe
20:19:45 <gzl> ok.
20:20:40 <araujo> But i see what you mean, i could add some simpler examples too.
20:29:41 <gzl> araujo: if you just want 'ls', do you have to type <|ls|> ?
20:29:58 <araujo> gzl, No, you just type ls
20:30:03 <gzl> ah, good
20:30:07 <araujo> <| |> is to interact with Haskell
20:30:11 <gzl> ok
20:30:23 <araujo> So you can still use your sed, awk and rest of things you know ;-)
20:30:45 <araujo> So if you want, you got the choice of using whatever style fits better your need.
20:30:47 <gzl> and you can use normal pipes and redirection?
20:30:51 <araujo> yes
20:30:57 <gzl> that's nice
20:32:23 <gzl> can you do something like ls | map f ?
20:32:34 <gzl> in other words, mixing the two
20:33:15 <araujo> That'd be somethign like: ls # map f
20:33:16 <gzl> or with the previous example, cat file | words
20:33:38 <gzl> ok
20:33:40 <araujo> # is the pipe between Haskell and commands.
20:33:47 <araujo> you can think of it like that
20:34:36 <gzl> so you can go in both directions? cat file # words # wc -l ?
20:35:23 <gzl> or it's only from commands to Haskell and not vice versa
20:35:55 <araujo> wc -l !~ words # cat file
20:35:57 <araujo> Like that
20:36:08 <gzl> why do you have to do it backwards?
20:36:10 <LordBrain> hmmm how about
20:36:22 <gzl> well, "backwards"
20:36:27 <LordBrain> cat file | tr '[:space:]' '\n'
20:36:30 <LordBrain> for bash
20:36:35 <araujo> gzl, Because you are treating commands as functions too in this case.
20:36:42 <LordBrain> tats splitting into words
20:36:44 <LordBrain> thats
20:36:59 <araujo> So, wc -l is like a function
20:37:06 <gzl> araujo: ok, but you wrote ls # map f; why isn't that map f # ls then?
20:37:46 <araujo> ls !~ map f 
20:37:58 <araujo> Sorry, it is actually like that.
20:38:22 <araujo> and yes, 
20:38:28 <araujo> you can do, map f # ls
20:38:53 <gzl> hmm
20:39:23 <LordBrain> hmm i gtg
20:39:29 <araujo> (#) is to command -> haskell , and (!~) haskell to command
20:39:30 <gzl> LordBrain: yeah, that does work.
20:40:32 <gzl> araujo: ok
20:40:42 <araujo> And you can mix both stylke in a single expression
20:40:44 <LordBrain> sounds funj
20:40:47 <gzl> yeah, that's nice
20:40:47 <LordBrain> fun
20:40:53 <gzl> you should definitely highlight that in the examples/docs too
20:41:02 <araujo> I will *nods*
20:41:06 <gzl> other shells like that I've seen don't let you totally ignore the haskell
20:41:13 <gzl> or mix and match at will
20:41:15 <gzl> which is just annoying
20:41:16 * araujo should really write something
20:41:21 <gzl> like Esther, for example
20:41:46 <araujo> yes, that shuoldn't happen
20:41:57 <gzl> what if a Haskell thing and a program have the same name?
20:43:29 <araujo> gzl, explain
20:43:37 <araujo> Or give me an example
20:43:51 <gzl> suppose I had a program called 'words' in my $PATH
20:43:55 <gzl> and I just type 'words'
20:43:57 <gzl> what does it do?
20:44:11 <araujo> It runs your programm words
20:44:21 <gzl> what if I wanted the Haskell function?
20:44:43 <araujo> w:: words 
20:44:55 <araujo> That is one of the reason the code looks so verbose
20:45:11 <gzl> what's w::?
20:45:26 <araujo> Because we need to avoid that kind of collision, probably there exist better ways to handle this, i don't know, i still need to figure out
20:45:41 <araujo> It says that you wanna run that expression as Haskell
20:45:54 <gzl> sorry, didn't ask the question properly
20:46:02 <gzl> does the w have any significance or is it just anythign?
20:46:07 <araujo> And, you are returning a value that it not a String
20:46:23 <gzl> so?
20:47:04 <araujo> yes, it means, "evaluate this expression as Haskell code, and returns a value different to a String with newline at the end"
20:47:25 <gzl> value different to a string?
20:47:37 <araujo> yes, you are returning [String]
20:47:55 <gzl> ok
20:48:02 <araujo> -> w:: words "hello world!"
20:48:02 <araujo> ["hello","world!"]
20:48:02 <araujo> -> 
20:48:05 <gzl> oh, I see what you mean
20:48:06 <gzl> ok
20:48:32 <gzl> does the 'w' matter or can that be anything?
20:48:46 <araujo> It does matter
20:48:52 <gzl> ok
20:48:58 <araujo> We've got so far, n,s,w,m
20:49:24 <araujo> n and s are for String values with newline and non-newline respectively
20:49:42 <araujo> w and m for non-String with newline and non-newline
20:50:05 <araujo> You can see it like type constraints
20:50:10 <gzl> why do you need to specify whether the return value is a string?
20:50:38 <araujo> For example, for pretty printing
20:51:09 <gzl> no, I mean, is there no way for it to figure that out by itself?
20:51:31 <araujo> It depends upon what you want
20:51:34 <gzl> ok
20:51:39 <araujo> As an example:
20:51:42 <araujo> -> n:: "hello world!"
20:51:42 <araujo> hello world!
20:51:42 <araujo> -> w:: "hello world!"
20:51:42 <araujo> "hello world!"
20:52:41 <araujo> So, if you are watching the output on the monitor, you will more likely want n
20:52:53 <araujo> If you are saving the result in a file, you might want w
20:52:56 <araujo> itis up to you.
20:53:15 <gzl> yeah
20:54:36 <gzl> there should be some way of avoiding saying that explicitly in most situations
20:55:08 <araujo> gzl, well, so far, it is avoided when you mix expressions
20:55:13 <gzl> ok
20:55:24 <gzl> yeah, that's not bad
20:58:04 <joelk> is there an optimized function equivalent to "\f a n -> (iterate f a) !! n" ?
20:58:10 <gzl> this sounds cooler now. maybe you just need some more docs :)
20:58:24 <gzl> does this compile on OS X?
20:58:31 <araujo> gzl, yeah, i do :-)
20:58:42 <gzl> hmm
20:58:52 * araujo finishing some things before start wirtting something
20:58:53 <Cale> joelk: that's not too bad actually
20:59:02 <Cale> joelk: are you having trouble with it?
20:59:11 <araujo> gzl, you also can do things like, saving the result of Haskell expressions and so far.
20:59:32 <gzl> saving the result or saving the expression itself?
20:59:35 <joelk> yes, running out of stack space. I had hoped it would be optimized to run in constant space...
20:59:39 <araujo> w::(|cf.txt) words <|cat config|> 
20:59:42 <araujo> For example
20:59:56 <Cale> oh, okay, yeah, that may be a problem for large n
20:59:59 <araujo> gzl, The result
21:00:09 <joelk> n = 1000000!
21:00:14 <gzl> araujo: that's cool. is there no way of getting > to work with that as well as normal shell commands?
21:00:39 <joelk> that's an exclamation point, not a factorial... :-)
21:01:17 <Cale> joelk: iterate' f a = let b = f a in b `seq` a : iterate' f b
21:01:22 <Cale> use that version of iterate
21:01:38 <araujo> gzl, you mean, words > file.txt ?
21:01:54 <Cale> the problem is that it's getting to the end of the iteration without ever actually applying f
21:01:55 <joelk> Ok, will try now. I still haven't gotten the hang of `seq` and friends
21:02:17 <Cale> and then it has this huge expression to deal with which causes a stack overflow
21:02:25 <gzl> araujo: yeah
21:03:30 <araujo> gzl, No , though it is actually a matter of syntax. w::(|cf.txt) does just the same than > 
21:03:46 <araujo> But, i found it easier to write like that, considering that you can mix expressions.
21:04:06 <araujo> So you can have partial results saved like this: 
21:04:41 <Cale> joelk: this will also have the benefit of having it run in constant space
21:04:58 <joelk> still overflowing...
21:05:04 <Cale> hmm...
21:05:10 <araujo> (|filetwo.txt) # grep 1 . wc -l !~(Data.List|fileone.txt) unwords [ f | f <- lines <|ls|> , ".txt" `isSuffixOf` f ]
21:05:27 <Cale> > iterate (+1) 0 !! 1000000
21:05:30 <lambdabot> Exception: stack overflow
21:05:32 <araujo> Check also: # grep 1 . wc -l !~ 
21:05:44 <Cale> > let iterate' f a = let b = f a in b `seq` a : iterate' f b in iterate' (+1) 0 !! 1000000
21:05:44 <araujo> Which is a kind of command composition.
21:05:46 <lambdabot> 1000000
21:05:59 <Cale> can I see the rest of your code?
21:06:56 <gzl> araujo: hm, I suppose. I find it visually a lot clunkier, though
21:07:01 <joelk> just a second
21:07:45 <gzl> araujo: anyway, bedtime for me, I'll catch you later
21:07:50 <araujo> Later gzl 
21:08:04 <araujo> I'll ping you whenever i get some docs up :-)
21:08:05 <gzl> I hope it turns out well :)
21:13:19 <joelk> Cale: Well, it's pretty long. I have your iterate ' and then the last line in my main do-block is "print . energy $ iterate' (advance 0.01) bodies !! n"
21:14:31 <Cale> how large is n?
21:14:39 <Cale> could it be some other problem?
21:14:42 <joelk> 1000000
21:15:09 <Cale> hmm
21:15:54 <Cale> ah, what is the type of bodies?
21:18:21 <joelk> bodies :: [Body], data Body = Body {pos :: !Vector3, vel :: !Vector3, mass :: !Double}, data Vector3 = V3 !Double !Double !Double
21:18:53 <Cale> ah, okay
21:19:28 <joelk> does that make a difference?
21:19:32 <Cale> yeah
21:19:42 <Cale> seq will only force the first cons cell of a list
21:22:27 <Cale> strictList xs = foldl' seq () xs `seq` xs
21:22:57 <Cale> iterate' f a = let b = strictList (f a) in b `seq` a : iterate' f b
21:23:12 <Cale> foldl' is in the Data.List library
21:23:29 <Cale> that should force all the list elements to be evaluated on each step
21:23:53 <Cale> oh
21:23:55 <Cale> oops
21:24:29 <Cale> strictList xs = foldr seq () xs `seq` xs
21:24:34 <joelk> Oh good. I could switch to a tuple of known length, but then the rest of the functions are much less elegant. Let's try strictList
21:24:53 <Cale> a tuple wouldn't help either
21:25:29 <joelk> it wouldn't have to evaluate all the elements to make sure it's not bottom?
21:26:00 <Cale> > fst (5, undefined)
21:26:01 <lambdabot> 5
21:26:08 <joelk> doh!
21:27:02 <joelk> wow, it's slow... Have to work on that. But it must be confined to constant space now! thanks.
21:27:09 <Cale> no problem
21:27:27 <Korollary> are you doing the n-body benchmark?
21:28:09 <joelk> yes. I thought the shootout would be a good way to learn seq and optimizing.
21:29:02 <joelk> I changed fannkuch so it used "maximum . map foo" instead of explicit recursion. That sped it up quite a bit.
21:29:23 <Korollary> Yeah, the benchmarks are nifty little projects.
21:29:34 <Korollary> I used to have an array based solution to fannkuch
21:30:05 <Cale> joelk: been reading the mailing lists?
21:30:24 <dons> Korollary, your soln was pretty quick, wasn't it?
21:30:40 <joelk> So far the best optimization lesson I've learned is "use builtins like maximum, map, fold* wherever possible."
21:31:03 <dons> they've been carefully tuned, so it's a good idea
21:31:06 <Cale> joelk: yeah
21:31:15 <joelk> on my machine the old fannkuch took 2m14s, the updated one took 5s
21:32:00 <Korollary> dons: I did the same algorithm in C++, OCaml and Haskell. GHC came close to 5x of the speed of C++ with unsafeWrite's.
21:32:05 <Cale> joelk: did you try Sebastian's version?
21:32:44 <dons> Korollary, is it worth putting up on the language shootout?
21:33:41 <Cale> Korollary: how does it compare with Sebastian's version?
21:33:43 <Korollary> dons: It would require some massaging. I concentrated on the permutation generation, so it'd need some extra code. And it's verbose, heh.
21:34:37 <Korollary> Cale: I didn't look at Sebastian's version. There was this deal about a particular way of generating the permmutations, so I don't even know if mine is generating them in the right order anymore. IIRC, the then-submitted haskell code didn't.
21:35:29 <Cale> There are some pretty fast obvious solutions popping up on the mailing list
21:35:43 <joelk> I read the lists, but seemed to have missed that thread until now... Don't see a link to Sebastian's version yet, just references to it
21:36:12 <dons> I think suggesting particular entries that need improviing on the list is a great way to improve the code 
21:36:22 <Korollary> Yes, there are some, except one for fasta, which is hopeless without FastStrings
21:36:29 <Cale> 03-Jan-2006 18:43
21:36:55 <dons> so many people seem willing to hack up examples.
21:36:56 <Cale> there were some suggestions afterward that I haven't tried yet
21:37:05 <dons> Korollary, are we allowed to use FastString?
21:37:11 <dons> fps, I mean?
21:37:30 <Korollary> dons: FPS doesn't come with GHC, does it?
21:37:54 <dons> well, it's only 1 module, it could be submitted with the entry.
21:38:08 <dons> has anyone tried PackedString in the std lib?
21:38:10 <Korollary> but it has C code, right?
21:38:52 <dons> the standard libs use C code too. ok. i've decided micro-benchmarks are stupid now.
21:39:24 <Korollary> tbh, fasta is just begging for an in-place updatable string. The test case has lines that are 9M characters long. You have to reverse it and apply a table based transform to it.
21:40:17 <dons> right, well, a ForeignPtr would be ok.
21:40:18 <Korollary> That's why the memory usage is so high and it makes people think that there's a space leak. There isn't.
21:40:24 <dons> i.e. roll your own mini-FastString
21:42:47 <Cale> Sebastian's fannkuch runs in ~2.2 seconds on my machine, and Kimberley's in 0.67 s
21:42:48 <joelk> Ah...that's why I missed that thread on haskell-cafe. I submitted my example 12 hours ago nad the thread started 8 hours ago.
21:42:54 <Korollary> dons: Micro-benchmarks are not so stupid for a reasonable feature that would exist either is a built-in or a library. A lot of people think that fast string operations are such a reasonable thing. GHC will get there.
21:43:17 <dons> I think that fast strings are a reasonable thing.
21:43:18 <Korollary> Cale: Yeah, Kimberley's entry looked suspiciously good heh
21:45:09 <Korollary> I'd be happy if ghc beat java consistently
21:45:39 <Cale> neither of them generates the perms in the strange correct order though
21:46:39 <Cale> which is why I suggested that we use the slower perm generator to print the "first 30" and switch to the fast one thereafter
21:47:12 <Korollary> Cale: lol
21:48:22 <joelk> Cale: about strictList: Weird used to overflow for n=100,000 . Now works for 100,000, but overflows for 1,000,000. Weird
21:48:29 <Cale> reductor: what's with the excess flood?
21:48:58 <Cale> joelk: oh, hmm
21:49:33 <Cale> strictList [] = []; strictList (x:xs) = x `seq` strictList xs
21:49:41 <Cale> try that and see if it does any better
21:50:13 <Cale> er
21:50:25 <Cale> sorry, that will kill your list :)
21:50:39 <lisppaste2> Korollary pasted "Imperative Perm" at http://paste.lisp.org/display/15343
21:50:47 <joelk> hehe. Ok, I feel better if Cale still has trouble with this stuff...
21:50:56 <Cale> well, it'll work
21:50:56 <Korollary> Cale: That's my imperative version. Just the permutations.
21:51:12 <Cale> but you'll need to write iterate' differently again :)
21:51:37 <Cale> iterate' f a = let b = f a in strictList b `seq` a : iterate' f b
21:52:03 <Cale> since the return value of strictList is now always the empty list
21:52:24 <Cale> (but it does force the elements of your list to get evaluated just the same)
21:54:08 <Cale> user    0m0.470s
21:55:13 <dons> what's the law against calculating all results at compiler time with TH... ?
21:55:25 <Cale> ooh
21:55:27 <Cale> hehe
21:55:34 <joelk> still overflows.
21:55:39 <Cale> *that* would be slick
21:55:58 <Cale> joelk: okay, I have no idea what's going on from what you've shown me then
21:56:18 <dons> Cale, I've done that trick on occasion to confuse and scare C programmers
21:56:21 <Cale> could it be happening in some other part of the program?
21:56:44 <dons> you take the slow haskell program, add `show $( )' and then it's suddenly a fast haskell program!
21:56:55 <Cale> hehehe
21:56:56 <Korollary> heh
21:57:11 <Korollary> and yell "show me the money!"
21:59:14 <dons> I mean, if our language is powerful enough to compute these things in the compiler... then why not? it's unfair not to allow it, right?
21:59:41 <joelk> Well, that's the only place that depends on n. Perhaps we're forcing each [Body] to evaluate, but the long [[Body]] is still around.
22:00:03 <dons> hmm. this dna problem is also begging for FastStrings
22:00:18 <Korollary> dons: I think it's unfair to disallow array based solutions because they are un-idiomatic haskell.
22:00:20 <dons> all very imperative bias on the benchmarks, hmm.
22:00:52 <dons> does it say anywhere that it has to be idiomatic?
22:00:57 <Korollary> I mean, they don't forbid it. But submitters usually go for pure haskell.
22:01:06 <Korollary> and then apologize in the comments
22:01:07 <dons> yeah, silly billies
22:01:07 <Cale> joelk: stack overflows basically never occur from running out of space -- it's always the exaluation of some expression which became too large before it had a chance to get evaluated
22:01:56 <joelk> Isn't "became too large" very similar to "ran out of space"?
22:02:19 <Cale> no because it doesn't usually really take up all that much space
22:02:19 <Korollary> joelk: it ran out of space for storing pointers to things not yet eval'd.
22:02:43 <Cale> The stack is pretty small
22:02:56 <Cale> You can increase the size explicitly with an RTS option
22:04:09 <sproingie> what's the M in MVar stand for?
22:04:36 <joelk> Well, yeah, I thought that is what I've been talking about.
22:04:36 <dons> Mutable
22:04:38 <Cale> Mutable
22:04:51 <dons> MontyPython
22:05:02 <Cale> joelk: well, it's quite different from running out of heap space :)
22:05:20 <sproingie> thanks
22:05:41 <sproingie> hm.  the ghc example for chameneos in the shootout does nice for speed
22:05:52 <sproingie> but wow on the RAM
22:06:40 <Korollary> heh
22:08:29 <joelk> True, but I thought we were talkng about a recursive function being optimized to run in constant (stack) space.
22:09:24 <SamB> I thought it might be for Maybe
22:09:29 <SamB> or Multithreaded
22:10:22 <Korollary> Mutex maybe.
22:10:35 <Korollary> "An MVar (pronounced "em-var") is a synchronising variable..."
22:11:05 <sproingie> they do have mutexes on them
22:11:18 <sproingie> i like mutable tho ... it's a box i can pass around and change
22:12:00 <sproingie> in fact, with channels and mvars, i think my hand-wringing about stateful apps in haskell is probably over.  it's two idioms i can actually understand
22:12:09 <Korollary> "MVars, a kind of synchronised mutable variable".
22:12:27 <Korollary> synchronisation is importante
22:12:33 <SamB> that sounds kinda mutexy to me...
22:13:08 <Korollary> I wish I knew (i.e. had time to learn) ST arrays
22:13:30 <sproingie> now i just need to figure out what the heck a zipper is
22:13:35 <sproingie> since they seem so darn powerful
22:14:15 <SamB> I wouldn't worry about it...
22:14:28 <SamB> unless you need to embed a filesystem in your program, anyway
22:14:37 <Korollary> Is it all about filesystems?
22:14:43 <SamB> probably not
22:14:57 <Korollary> I can't keep up with Oleg anyways
22:15:06 <SamB> Oleg was in on that?
22:15:28 <SamB> okay, if Oleg was in on it, definately don't worry if you don't get it
22:16:05 <Korollary> Oleg had an implementation
22:16:14 <Korollary> http://lambda-the-ultimate.org/node/view/1036
22:16:21 <Cale> Why do people care so much about what Smarandache does?
22:16:42 <Korollary> Cale: Who's Smarandache?
22:16:50 <Cale> http://en.wikipedia.org/wiki/Neutrosophy
22:17:30 <Cale> He seems to have some odd followers who go around parading everything he's willing to claim as his ideas
22:21:01 <Korollary> Cale: like what?
22:21:30 <Saulzar> You could set your clock to reductor's Excess Flood
22:21:47 <Korollary> Saulzar: lol
22:22:29 <Cale> Lots of funny integer sequences which nobody has much use for. The most interesting one of which was actually studied over 100 years ago by someone else, but that didn't stop him from naming it after himself.
22:23:30 <Korollary> Cale: Well, his ignorance. The community won't use that name, so it doesn't really matter.
22:23:47 <Cale> Well, he has his own journal
22:24:11 <SamB> that doesn't sound exactly peer-reviewed
22:24:21 <Korollary> I'll claim that I discovered them first in my blog
22:24:42 <SamB> Korollary: be sure to use plenty of exclamation points!!!!!
22:25:12 <Korollary> SamB: I'll cite your made-up papers as well
22:25:25 <SamB> what?
22:25:29 <SamB> the proofs in the puddings?
22:25:38 <Korollary> Your P=NP stuff
22:25:48 <SamB> heh
22:26:06 <Korollary> I should go to #math and troll
22:26:06 <SamB> you can claim that the proofs were eaten after I put them in puddings
22:26:06 <Cale> also, he's some up with some bizarre generalisation of fuzzy logic, which is possibly interesting, but I'm not yet convinced that it deserves as much attention as it's getting
22:27:00 <sproingie> never heard of the guy before now
22:27:05 <sproingie> kooks are a dime a dozen
22:27:21 <SamB> sproingie: but slavery is illegal
22:27:35 <Cale> Well, he actually appears to have some force behind him, which is strange
22:27:39 <sproingie> SamB: only if you make 'em work for you
22:27:45 <Korollary> The guy spent two years at a refugee camp
22:27:52 * SamB goes to bed
22:28:01 <sproingie> SamB: tho i suppose using them as fertilizer also breaks some laws
22:28:24 <SamB> sproingie: depends if you kill them first, probably
22:28:56 <Korollary> Cale: I didn't know Bayesian probability was such a controversial topic among math nerds. Is it worth learning?
22:29:20 <Cale> Korollary: I didn't see any difference from ordinary probability.
22:29:38 <Cale> Then again, I'm a pure math person, so I might be missing the point
22:30:00 <Korollary> Well, Bayesian supporters are also pure math people.
22:30:02 <Cale> I think it's just subtle philosophical perspective thing.
22:30:05 <Korollary> Yes
22:30:15 <joelk> I don't think it's controversial anymore.
22:30:19 <Cale> Well, statisticians are different :)
22:31:53 <Cale> http://planetmath.org/encyclopedia/NeutrosophicLogic.html
22:34:08 <Cale> It seems to me like awfully heavy machinery for such a task.
22:34:40 <Cale> also, don't believe the link to monad :)
22:34:44 <Korollary> It seems a bit odd to have two independent degrees of T & F
22:34:49 <Cale> (it's bad auto-linking)
22:35:27 <Cale> Even stranger to have a third independent indeterminacy part
22:36:26 <Korollary> right, that doesn't sound orthogonal to the other two
22:38:00 <sproingie> was bayesian modelling ever controversial
22:38:12 <sproingie> it's just a statistical model
22:38:49 <Korollary> sproingie: probably not. I think it's Bayesian probability theory that's controversial.
22:39:18 <Korollary> http://en.wikipedia.org/wiki/Bayesian_probability
22:40:12 <Korollary> lol
22:40:21 <Korollary> "...not talking to each other for the most part, not attending each others' conferences, etc."
22:40:40 <Cale> I'm a formalist, so I really don't care how people decide to interpret mathematics, as long as they do the mathematics part correctly :)
22:41:14 <sproingie> Korollary: i don't put much stock in conflating mathematics and epistemology, no matter what school of thought it follows
22:41:15 <Cale> At least, I'm a formalist from a philosophical standpoint :)
22:43:48 <Korollary> sproingie: This lack of fighting among mathematicians bothers me :)
22:44:17 <Korollary> They should go at each other like Pythonists and Rubyists
22:44:48 <Cale> It's hard to fight about mathematics because it's all pretty arbitrary. You choose some axioms, and a logic, and you see where that gets you.
22:45:12 <Cale> normally there's at least one interpretation of the axioms which you have in mind to keep you interested
22:46:22 <sproingie> well, in godel's time there was certainly a lot of fighting about deep philosophical issues regarding the axioms and their consequences
22:46:31 <sproingie> probably still is, just too abstract for me to comprehend
22:46:31 <Cale> The only thing to really argue about is what part to work on
22:46:51 <Cale> sproingie: Yeah, GÃ¶del kind of killed that :)
22:47:10 <araujo> Can anybody here get proper output from getEnvironment ?
22:47:34 * JKnecht would constrast Mathematics As a Cultural System (q.v.) with the (universal) residue of the mathesis.
22:47:56 <sproingie> wish i had a proper compose key so i could spell his name properly
22:48:04 <sproingie> Goedel just doesn't look right 
22:48:19 <Korollary> but it sounds right
22:48:45 <Korollary> it's also a legal german spelling
22:49:05 <Korollary> but uncool, yes. viva unicode
22:50:39 <Cale> GÃ¶del's first incompleteness theorem is basically "Your formal system is either incomplete or broken." and his second incompleness theorem is "You can't tell if it's broken."
22:51:49 <Cale> Of course, it only discusses systems powerful enough to express universally quantified statements of arithmetic, but basically any interesting foundation for mathematics had better have that. :)
22:51:51 <Korollary> Unless a certain 'entity' blesses us with a more powerful formal system ;)
22:52:10 <Cale> Yeah, but you still can't show that one isn't broken
22:52:43 <Cale> By "broken", of course I mean inconsistent, which means that it proves every statement.
22:52:48 <Korollary> You can if your system obeys the more powerful system
22:53:34 <joelk> Cale: found my mistake. I removed a strictness annotation and forgot to put it back. Now to get that inner loop producing the correct results...
22:53:51 <Cale> You might be able to prove the consistency of a system from within another external system, but if the external system is inconsistent, you could do that already anyway. :)
22:53:51 <JKnecht> that's not what the incompleteness result says though. 
22:54:31 <Cale> (and you could also prove the negation of your statement :)
22:54:38 <dons> @pl map (\v -> v ++ ' ': show (numHits v s')) variants
22:54:39 <lambdabot> map (ap (++) ((' ' :) . show . flip numHits s')) variants
22:55:09 <Korollary> Cale: That's why I said "blessed".
22:55:46 <Cale> Well, okay :)
22:56:22 <Cale> systems like that are not too common around these parts :)
22:56:41 <Korollary> the space aliens should drop one for us
22:57:14 <JKnecht> i.e., not finitely axiomatizable doesn't imply inconsistent.
22:59:01 <Cale> JKnecht: who said that it did?
23:00:55 <JKnecht> isn't that the anaphoric referent of "your system" in <<GÃ¶del's first incompleteness theorem is basically "Your formal system is either incomplete or broken." and his second 
23:00:58 <JKnecht>               incompleness theorem is "You can't tell if it's broken."
23:01:00 <JKnecht> >>
23:01:55 <Cale> by "your system", I mean "any system you'd like to choose which is capable of expressing universally quantified statements of arithmetic"
23:11:24 <gizban> is there an easy way to get random access for a list?  Or am I going to have to write my own function to do it?
23:11:43 <Saulzar> @type (!!)
23:11:44 <lambdabot> forall a. [a] -> Int -> a
23:12:08 <gizban> what does @type (!!) mean?
23:12:18 <sproingie> random access is something you probably don't want if you're using a list
23:12:19 <Saulzar>  @type gets the bot to look up the type
23:12:44 <sproingie> if you're using !! a lot, you're probably using the wrong data structure
23:12:58 <Cale> > [5, 2, 3, 7, 1, 3, 12] !! 3
23:13:00 <lambdabot> 7
23:14:23 <sproingie> good old reductor
23:14:40 <sproingie> can we just ban it?
23:20:19 <Korollary> @summon channelop
23:20:20 <lambdabot> Unknown command, try @listcommands.
23:20:31 <gizban> how do I create a list of length 50 with all elements starting at 0 where the list of type [Integer]?   I tried [i*0 | i <- [1..5]] but that doesn't seem to be what I nee
23:20:34 <gizban> need
23:20:48 <Korollary> > [0..50] :: [Integer]
23:20:49 <lambdabot> [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,
23:20:49 <lambdabot> 27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50]
23:21:17 <sproingie> that'd be length 51 ;)
23:21:31 <Korollary> I am not thinking
23:21:37 <Korollary> leave me to my instincts
23:21:40 <Cale> > replicate 50 0
23:21:42 <lambdabot> [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
23:21:42 <lambdabot> 0,0,0,0,0,0,0,0,0,0,0,0,0,0]
23:22:40 <Cale> [0 | i <- [1..50]]
23:22:42 <Cale> > [0 | i <- [1..50]]
23:22:44 <lambdabot> [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
23:22:44 <lambdabot> 0,0,0,0,0,0,0,0,0,0,0,0,0,0]
23:22:51 <Cale> like those?
23:23:01 <gizban> thanks, that's exactly what I need
23:23:33 <gizban> I need to represent a memory core with 4096 memory locations
23:24:11 <Cale> use an array
23:24:18 <Cale> a mutable array, probably
23:25:20 <gizban> the assignment says it has to be of type [Integer].  Can an array be of type [Integer]?
23:26:32 <Korollary> No, that's a list of Integers. If it's an assignment, use that.
23:26:53 <Korollary> "One of these 270 phrases was "Math is hard!" Although only about 1.5% of all the dolls sold said the phrase, it caused public outcry over Barbie's representation of women, and the infamous phrase quickly became a common pop culture reference."
23:27:10 <gizban> !! allows random access read.  Is there a random access write?
23:27:47 <Korollary> gizban: No, lists are not mutable. You can construct a new list where it differs from the original at that index, though.
23:27:49 <Cale> just make a new list with that element changed
23:28:39 <gizban> split at a pivot point and insert a new value?
23:32:12 <Korollary> gizban: you can split into two and pattern match on the right half to create a new right half and append it to the left half.
23:57:55 * palomer found the real let rule
23:58:07 <palomer> my god it wasn't easy to find
23:58:20 <Korollary> the real let?
23:58:27 <palomer> for typing
23:58:52 <palomer> ie, how to type let a = b in c
23:59:15 <palomer> quite easy
23:59:59 <palomer> Gamma, a: alpha |- b: alpha
