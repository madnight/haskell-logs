00:00:44 <gour> joelk: how do you like okasaki's book so far? i'm considering Functional Programming Approach book too
00:02:59 <joelk> I don't know if any other books cover the things in Okasaki's book. I'm studying it when I can find the time. I think I need to understand it for some of the projects I have in mind.
00:03:36 <gour> joelk: is it lighter  than thesis for reading?
00:03:40 <khaladan> i got The Functional Programming Approach to Programming with Caml, is that the same one? by Cousineau and Mauny
00:03:52 <khaladan> haven't read it yet--got it for christmas
00:04:18 <gour> khaladan: nope, i think about http://www.iro.umontreal.ca/~lapalme/Algorithms-functional.html
00:04:51 <joelk> Not lighter, but perhaps clearer. I haven't sat down to do a direct comparison yet.
00:05:51 <gour> joelk: ok. i think that FPA could be better as the 2nd haskell book (before okasaki)
00:06:36 <gour> joelk: i.e. it deals with algorithms, not only data structures
00:08:28 <joelk> The two are pretty entwined. I learned the most about algorithms in a class entitled "Data Structures". Of course that was in C and not very challenging.
00:14:41 <vincenz> gour: okasaki's book is quitegood
00:15:20 <khaladan> some think data structures = algorithms
00:16:00 <vincenz> khaladan: I think they can be defined as being isomorphic
00:16:04 <dons> vincenz, the '>' handling is in Plugins/Base.hs iirc
00:16:11 <dons> you interested in hacking the bot?
00:16:12 <vincenz> dons: yeah, found it :)
00:16:41 <vincenz> dons: no just wanted a nice place to learn haskell, although... I was hoping to make a plugin that would automatically log all urls... How would I go about doing such a thing, given how the bot requires @something
00:18:22 <dons> ah, that would be interesting. hmm..
00:18:28 <dons> it's not a normal plugin though
00:18:32 <dons> it would have to filter everything
00:18:52 <dons> the bot does see all the channel text though, so it's very doable
00:19:16 <dons> but if you can think of a normal: @foo plugin that would be easier
00:19:28 <khaladan> vincenz, know where i might find more info on that idea?
00:20:23 <gour> vincenz: and you know the other one?
00:20:45 <vincenz> gour: afraid not
00:20:49 <vincenz> khaladan: idem
00:20:58 <dons> musasabi, cheers
00:21:07 <dons> @karma+ musasabi for all the shootout commits :)
00:21:08 <lambdabot> musasabi's karma raised to 7.
00:21:41 <khaladan> the latin idem? :)
00:21:45 <khaladan> oh well then!
00:22:31 <gour> vincenz: ok
00:23:56 <vincenz> dons: it's just that I've wanted this for a while, I often idle on chans and I figure I might as well log all urls, possibly with context for later review
00:52:25 <musasabi> What would be the best way to define a Data.Map.filterM ?
00:55:58 <Itkovian> musasabi: ask Chuck Norris
00:56:49 <Itkovian> why does this work: (zipWith (\x y -> (read x :: Int) + (read y :: Int))) ["1","2"] ["3","4"]
00:56:58 <Itkovian> and thgis doesn;t: foldr (zipWith (\x y -> (read x :: Int) + (read y :: Int))) [0,0] [["1","2"], ["3","4"]]
01:02:55 <Itkovian> >  (zipWith (\x y -> (read x :: Int) + (read y :: Int))) ["1","2"] ["3","4"]
01:02:57 <lambdabot> [4,6]
01:03:08 <Itkovian> >  foldr (zipWith (\x y -> (read x :: Int) + (read y :: Int))) [0,0] [["1","2"], ["3","4"]]
01:03:10 <lambdabot> Couldn't match `String' against `Int'
01:04:43 <vincenz> >  foldr (zipWith (\x y -> (read x :: Int) + (read y :: Int))) [0,0] [["1","2"], ["3","4"]]
01:04:44 <lambdabot> Couldn't match `String' against `Int'
01:04:51 <vincenz> damn
01:04:58 <Lemmih> What should it do?
01:05:07 <vincenz> >  foldr (zipWith (\x y -> (read x :: Int) + (read y :: Int))) ["0","0"] [["1","2"], ["3","4"]]
01:05:08 <lambdabot> Couldn't match `String' against `Int'
01:05:29 <vincenz> gotta admit
01:05:34 <vincenz> not sure what foldr (zipWith) does
01:05:52 <joelk> > foldr (zipWith (\x y -> (read x :: Int) + y)) [0,0] [["1","2"], ["3","4"]]
01:05:53 <lambdabot> [4,6]
01:06:00 <joelk> how's that?
01:06:38 <Itkovian> wtf?
01:06:45 <joelk> @type foldr
01:06:46 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
01:06:50 <vincenz> what does zipwith do?
01:06:54 <vincenz> in this example
01:07:01 <Itkovian> it adds the numbers
01:07:06 <vincenz> n
01:07:06 <vincenz> no
01:07:09 <vincenz> the foldr does that
01:07:13 <vincenz> @type zipWith
01:07:14 <lambdabot> forall c b a. (a -> b -> c) -> [a] -> [b] -> [c]
01:07:26 * vincenz scratches his head
01:07:31 <Itkovian> no, the zipWith does.
01:07:36 <vincenz> @type foldr . zipWith
01:07:37 <lambdabot> forall a c. (a -> c -> c) -> [c] -> [[a]] -> [c]
01:07:40 <Itkovian> the foldr keeps the zipWith going
01:07:41 <vincenz> oh
01:07:43 <vincenz> there ya ho
01:07:47 <vincenz> there ya go even
01:07:47 <Lemmih> > map (sum.map read) (transpose [["1","2"],["3","4"]])
01:07:49 <lambdabot> [4,6]
01:08:12 <vincenz> @pl foldr (zipWith (\x y -> (read x :: Int) + y)) 
01:08:13 <lambdabot> foldr (zipWith ((+) . (:: Int) . read))
01:08:34 <Itkovian> Lemmih: cool, but why can't the read be applied twice? 
01:09:11 <Itkovian> Lemmih: will that still work lazily?
01:09:21 <joelk> from the type of foldr, the function must be of type a->b->b, so y is an Int
01:09:55 <Itkovian> joelk: yes, but in reality it's a String? Or will that coerce the String to an Int automagically?
01:09:59 * Itkovian is Lost
01:10:05 <Lemmih> Itkovian: Yes.
01:10:38 <Lemmih> @type zipWith (\x y -> (read x :: Int) + y)
01:10:39 <lambdabot> [String] -> [Int] -> [Int]
01:10:44 <Lemmih> @type foldr (zipWith (\x y -> (read x :: Int) + y))
01:10:45 <lambdabot> [Int] -> [[String]] -> [Int]
01:11:00 <Lemmih> @type zipWith (\x y -> (read x :: Int) + (read y))
01:11:01 <lambdabot> [String] -> [String] -> [Int]
01:11:08 <Itkovian> hmm
01:11:10 <Lemmih> @type foldr
01:11:11 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
01:11:39 <Itkovian> @type zipWith (\x y -> (read x :: Int) + (read y :: Int))
01:11:41 <lambdabot> [String] -> [String] -> [Int]
01:11:44 <Itkovian> buggers
01:12:36 <Itkovian> but the y comes from a [String], no?
01:13:13 <Itkovian> I had no idea it could coerce that to an Int if the outer function imposes its type
01:13:30 <Itkovian> Thx. I'll try to make sense of it.
01:13:46 <Itkovian> brb
01:14:05 <Lemmih> Itkovian: It won't coerce anything.
01:19:05 <Itkovian> hmm
01:23:05 <Itkovian> Lemmih: how will it make an Int then?
01:23:16 * Itkovian feels like a complete newbie
01:23:43 <joelk> x is a string, y is an int already. look at the base case: [0,0] :: [Int]
01:23:56 <joelk> compare with 
01:23:57 <joelk> > foldr (zipWith (+) . map read)  [0,0] [["1","2"], ["3","4"]]
01:23:58 <lambdabot> [4,6]
01:25:29 <Lemmih> Itkovian: 'y' is the accumulated result of (read x + y).
01:25:57 <vincenz> what are ghc's restrictions on windows
01:26:21 <Lemmih> GHC is restricted on Windows?
01:26:39 <vincenz> I dunno
01:26:41 <vincenz> I'm asking
01:26:49 <vincenz> I read somewhere ghc has restrictions on certain os's
01:27:44 <Itkovian> joelk: right but I might just as well use foldr1 ... which drops the [0,0] ...
01:27:59 <joelk> @type foldr1
01:28:01 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
01:28:15 <Itkovian> ah well, I'm starting to grok it.
01:28:24 <Itkovian> thx.
01:28:26 <vincenz> > foldr1 (zipWith (+) . map read) [["1","2"], ["3","4"]]
01:28:27 <lambdabot>  add an instance declaration for (Num String)
01:28:35 <Lemmih> Itkovian: I would go with the 'transpose' solution.
01:28:40 <Itkovian> Lemmih: yes.
01:28:57 <vincenz> @type foldr1 (zipWith (+) . map read)
01:28:58 <lambdabot>   No instance for (Num String)
01:28:58 <lambdabot>   arising from use of `+' at <interactive>:1:16-18
01:29:00 <Itkovian> i'm timing them now
01:29:13 <vincenz> @type foldr1 (zipWith ((+) . map read))
01:29:14 <lambdabot>   No instance for (Num [String])
01:29:14 <lambdabot>   arising from use of `+' at <interactive>:1:17-19
01:29:25 <vincenz> @type foldr1 (zipWith (map ((+) . read)))
01:29:26 <lambdabot>   Expecting a function type, but found `[b]'
01:29:26 <lambdabot>   Expected type: [a] -> [a] -> [a]
01:33:01 <Itkovian> 17 seconds vs 2 seconds for python
01:33:04 <Itkovian> grmbl.
01:34:46 <joelk> Huh, I thought the foldr (zipWith (+) . map read) version was pretty good, in so far as it clearly states what it does.
01:35:46 <vincenz> Itkovian: can you paste both versions on http://rafb.net/paste
01:36:01 * vincenz would like to take a look at them
01:36:09 <vincenz> possibly run an ocaml experiment with similar code
01:36:38 <Itkovian> joelk: yes, but i think foldr1 is more elegant as it requires no 'base' list of 0's
01:40:04 <Itkovian> pasted
01:40:11 <vincenz> what's the link
01:40:16 <Itkovian> My ocaml experience is very limited
01:40:25 <vincenz> my haskell experience is very limited ;)
01:40:28 <Itkovian> http://rafb.net/paste/results/kajjbP94.html
01:40:30 <vincenz> thx
01:40:37 <Itkovian> http://rafb.net/paste/results/du0Ncv44.html
01:40:43 <joelk> > foldr1 (zipWith (+)) . map (map read) $ [["1","2"], ["3","4"]]
01:40:45 <lambdabot> [4,6]
01:40:58 <joelk> but now I'm being silly
01:41:14 <Itkovian> joelk: that seems a bit ugly indeed
01:41:33 <joelk> Oh, now you've got me started...
01:41:45 <joelk> > foldr1 ((map show .) . (. map read) . zipWith (+) . map read) [["1","2"], ["3","4"]]
01:41:46 <lambdabot> ["4","6"]
01:42:15 <joelk> heh
01:44:04 <vincenz> hmm
01:44:16 <vincenz> Itkovian: first of all your haskell version is doing more work
01:44:25 <vincenz> you're filtering the lines
01:44:30 <vincenz> which the python version isn't doing
01:45:11 <Itkovian> well, the filtering and all really takes no time
01:45:20 <Itkovian> it's the read and the accumulation that takes time
01:45:27 <Itkovian> without that it's just over 1 sec.
01:45:33 <Itkovian> with it, it's 17 secs
01:46:56 <Itkovian> and the filter is really fast, as it only examines the first char
01:59:38 * Itkovian boings
02:03:12 <JKnecht> Hi Cristo. Are you originally from So. Africa?
02:03:41 <christo> hi JKnecht no
02:03:45 <christo> Australia
02:03:57 <JKnecht> sorry, knew someone with that name.
02:10:13 <Itkovian> vincenz: let me know when the ocaml implementation is done
02:11:11 <vincenz> Itkovian: actualyl been busy with other things :/
02:11:35 <Itkovian> np.
02:11:42 <Itkovian> so have I
02:41:37 <vincenz> does HOpenGL come with the std ghc distro?
02:41:37 <dcoutts> yes
02:41:37 <vincenz> where do I get the exmaples
02:41:37 <dcoutts> @where hopengl
02:41:37 <lambdabot> http://haskell.org/HOpenGL/
02:42:11 <vincenz> how do I compile?
02:42:22 <vincenz> Planet.hs:15:0:
02:42:31 <vincenz> Failed to load interface for 'GL'
02:42:46 <dcoutts> sounds like the demo is rather old
02:43:10 <dcoutts> it's not using the hierarchal module names
02:43:13 <vincenz> ah
02:43:24 <dcoutts> hopefully you can just change:
02:43:36 <dcoutts> GL -> Graphics.Rendering.OpenGL
02:43:50 <dcoutts> GLU -> Graphics.Rendering.GLU
02:44:00 <dcoutts> GLUT -> Graphics.UI.GLUT
02:44:03 <dcoutts> (I think)
02:44:16 <vincenz> I did that
02:44:18 <vincenz> now I get errors
02:44:34 <vincenz>  Not in scope: data constructor `GL.Flat'
02:44:42 <vincenz> Not in scope: `pushMatrix'
02:44:44 <vincenz> and others
02:44:48 <dcoutts> do
02:44:54 <dcoutts> import Graphics.Rendering.OpenGL as GL
02:45:19 <vincenz> import Graphics.Rendering.OpenGL as GL
02:45:19 <vincenz> import Graphics.Rendering.OpenGL.GL
02:45:19 <vincenz> import Graphics.Rendering.OpenGL.GLU
02:45:19 <vincenz> import Graphics.UI.GLUT
02:45:39 <vincenz> @google ColorBufferBit
02:45:41 <lambdabot> http://www.cin.ufpe.br/~haskell/hopengl/ioref.html
02:45:49 <Saulzar> Hmm, I think the interface has changed with respect to push/pop matrices
02:47:32 <vincenz> doh
02:47:38 <vincenz> not even the tutorial simple example works
02:48:15 <vincenz> @hoogle Single
02:48:16 <lambdabot> Text.Html.BlockTable.single :: a -> BlockTable a
02:48:16 <lambdabot> Data.IntMap.singleton :: Key -> a -> IntMap a
02:48:16 <lambdabot> Data.IntSet.singleton :: Int -> IntSet
02:48:34 <Saulzar> Though I don't really know, it seems all the "stack" operations in HOpenGL now use preservingBlah, so preservingMatrix will do a push/pop
02:49:34 <vincenz> it's WindowPosition, WindowSize, ColorbufferBit, Single, GLUT.Rgb, GlUT.init and DisplayAction
02:49:49 <vincenz> and displayFunc
02:50:28 <joelk> and the buffer bits were replaced with enumerated types, ie do clear [ColorBuffer, DepthBuffer]; drawSomething;
02:53:55 <vincenz> even the documentation is off
02:54:31 <Lemmih> http://haskell.org/HOpenGL/ hasn't been updated for a couple of years.
02:55:16 <Lemmih> vincenz: Try the examples at http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/libraries/GLUT/examples/
02:56:30 <vincenz> slowly fixing 
02:58:55 <vincenz> all I'm left with is displayFunc and DisplayAction
03:02:46 <vincenz> that is odd
03:02:51 <vincenz> column style coding is not working
03:02:53 <vincenz> I have to add ;
03:04:54 <vincenz> nm
03:04:57 <vincenz> mixing spaces and tabs
03:20:20 <JohnMeacham> do not mix spaces and tabs.
04:32:54 <Itkovian> is there a way to improve the performance of read?
04:33:20 <Itkovian> in the timing issue mentioned this morning, I find after profilaton that the map read takes up 88% of the total execution time.
04:33:36 <Itkovian> I cannot imagine that it has been implemented badly
04:33:50 <Itkovian> It knows to what the String should be read, i.e. to an Int
04:33:50 <tromp_> what type is it reading?
04:33:55 <Itkovian> String to Int
04:34:06 <tromp_> try roll your own
04:34:33 <tromp_> or find source of the provided one
04:34:35 <Itkovian> I'd assume that it gets replaces by a native call to C
04:34:41 <Itkovian> *replaced
04:34:45 <tromp_> then it can't be slow;(
04:35:01 <dcoutts> Itkovian no, the C version deals with char*, not String
04:35:22 <Itkovian> hmm
04:35:23 <dcoutts> Itkovian, it uses the list of possible parses style
04:35:29 <dcoutts> @type reads
04:35:30 <lambdabot> forall a. (Read a) => ReadS a
04:35:51 <Itkovian> dcoutts: easy way to speed it up?
04:36:20 <Itkovian> it can't be _that_ hard?
04:36:20 <tromp_> do the strings have whitespace?
04:36:23 <Itkovian> nope
04:36:55 <dcoutts> Itkovian, write it straight, not going via list of sucesses. Ignore other stlyes of interer, like hex etc.
04:37:15 <dcoutts> or call C
04:38:43 <tromp_> > foldl' (\x c -> 10*x+(fromEnum c - fromEnum '0')) 0 "654"
04:38:45 <lambdabot> 654
04:40:12 <tromp_> or better yet,
04:40:22 <Itkovian> tromp_: excellent.
04:40:26 <tromp_> use digitToInt
04:40:33 <Itkovian> reduced to 13.3%
04:41:05 <tromp_> > foldl1' (\x c -> 10*x+c) $ map digitToInt "654"
04:41:07 <lambdabot> 654
04:41:21 <tromp_> 'that shld be pretty fast
04:41:25 <Itkovian> still, I find it majorly annoying that the system can't deduce this based on the inferred type of the result
04:42:24 <tromp_> cause it's part of a more general parsing framework
04:42:47 <tromp_> that can produce many parses, and handle whitespace and different number formats
04:43:12 <Itkovian> I agree with that, but if the final type is not some Num a, then it should be able to infer a much faster algorithm for conversion at compile time
04:43:25 <tromp_> > read "-0xfb" :: Int
04:43:27 <lambdabot> -251
04:45:37 <Itkovian> ok.
04:45:59 <Itkovian> and how does one access specific instances of that framework?
04:46:13 <Itkovian> like say, only decimal "strings"
04:46:48 <tromp_> you can't. it's all part of reads defined for Int
04:46:58 <Itkovian> ok.
04:47:18 <Itkovian> anyway, now it has like 50% slowness compared to python. thx.
04:47:45 <tromp_> interpreted python?
05:11:38 <goki-> you know if you search on google for "haskell graph" you get some kind of virus warning?
05:12:20 <dcoutts> goki-, where?
05:12:30 <goki-> in the google response
05:12:43 <goki-> maybe it's just me
05:12:55 <goki-> We're sorry...
05:12:55 <goki-> ... but your query looks similar to automated requests from a computer virus or spyware application. To protect our users, we can't process your request right now. 
05:13:05 <dcoutts> heh
05:13:08 <dcoutts> not for me
05:13:21 <dcoutts> @google haskell graph
05:13:23 <lambdabot> http://www.haskell.org/debugging/techniques.htm
05:13:45 <tennin> well, so much for my haskell botnet =(
05:13:50 <goki-> heh
05:13:58 <goki-> It's the only time I've ever seen anything like that
05:14:23 <goki-> it asked me to do two captcha things (spelling?) then it let me see the results
05:32:37 <Monteiro> my haskell program has an error : ERROR "t1.hs":13 - Instance of Num [Int] required for definition of fub
05:32:37 <Monteiro>  | anyone knows ?
05:33:03 <ADEpt> Monteiro: you are trying to add/multiply/... lists of numbers, probably
05:33:03 <wilx> @type fub
05:33:05 <lambdabot> Not in scope: `fub'
05:33:33 <ADEpt> Monteiro: which is impossible to do unless to explain to haskell how to treat lists of numbers as a single number
05:33:45 <ADEpt> Monteiro: but most probably, its an error on your part
05:34:30 <Monteiro> yes, it's that exacly
05:34:55 <Monteiro> i've : where  calculus  = z + 2 * y + 3 * x
05:35:06 <Monteiro> and calculus : list ...
05:35:36 <tromp_> calculus : list ???
05:35:43 <tromp_> that makes no sense
05:36:18 <tromp_> what's the whole definition?
05:36:32 <Monteiro> tromp_ : wait a sec, i'll show it to u
05:37:24 <Monteiro> http://rafb.net/paste/results/2LRE5x55.html
05:37:32 <Monteiro> its there
05:38:06 <araujo> Good morning.
05:38:14 <tromp_> (1:1:1) is wrong
05:38:40 <Monteiro> [1:1:1] ? 
05:38:41 <tromp_> should be [1,1,1]
05:38:44 <Monteiro> yes
05:38:45 <Monteiro> :)
05:41:25 <Monteiro> now i 've i*** Type           : [[a]]
05:41:25 <Monteiro> *** Does not match : [Int]
05:41:25 <Monteiro>  n *** Expression     : next [1 : 1 : 1]
05:42:04 <tromp_> 1:1 is wrong
05:42:17 <ADEpt> should be [1,1,1]
05:42:42 <Monteiro> ahhhh
05:42:44 <Monteiro> my mistake
05:44:07 <Monteiro> tks to all
05:48:25 <tromp_> strange program anyway:)
05:52:43 <Monteiro> tromp_ : yes, that first function it is suposed to make a infinite list
05:52:45 <Monteiro> supposed
05:53:18 <tromp_> except it runs out:(
05:53:37 * araujo wonders why someone who doesn't advocate functional programming writes to comp.lang.functional
05:53:37 <tromp_> trying to do a recurrence?
05:53:54 <Monteiro> yes
05:54:13 <Monteiro> tromp_ : it's like fibonnaci
05:54:30 <Monteiro> but it has a formule
05:54:36 <tromp_> try to compute with the whole seq at once
05:54:37 <Monteiro> that "conta" for each element
05:55:02 <Monteiro> tromp_ : how ?
05:55:08 <tromp_> find a recurrence for the whole seq
05:55:30 <tromp_> for instance, if a have twos :: [Int]
05:55:52 <tromp_> satisfying twos = 1 : map (2*) twos
05:56:00 <tromp_> then what can the seq be?
05:56:11 <Monteiro> my problem is that i need the 3 before numbers in the list
05:56:33 <tromp_> well, twos also has some leading terms
05:56:38 <tromp_> the 1 in there
05:56:39 <Monteiro> [1:1:1] to build the 4ยบ element it's 1 + 1 * 3 + 1 * 2 = 6
05:57:08 <Monteiro> next [1:1:1:4] recursive infinite list
05:57:30 <tromp_> you cannot use :1
05:57:34 <tromp_> 1 is not a list
05:57:44 <tromp_> : puts another element in front of a list
05:58:21 <Monteiro> yes
05:58:24 <Monteiro> my mistake again
05:58:33 <Monteiro> [1,1,1,4]
05:59:01 <tromp_> try my example twos
05:59:02 <Monteiro> next list ++ [calc]
05:59:05 <Monteiro> ok
06:08:42 <gour> dcoutts: ping
06:08:53 <Monteiro> tromp_ : which is the Int limit in haskell ?
06:09:11 <tromp_> > bounds :: (Int,Int)
06:09:13 <lambdabot>  Not in scope: `bounds'
06:09:34 <ADEpt> Cale: thnx for proofreading :)
06:09:54 <tromp_> > maxBound :: Int
06:09:56 <lambdabot> 2147483647
06:10:24 <vincenz> Shite, Generic Programming is a hard topic on c.l.f.
06:10:49 <araujo> hah yeah
06:11:26 <gour> vincenz: is there anything else interested going on on c.l.f (didn't look for quite some time) ?
06:11:35 <vincenz> not really
06:11:43 <vincenz> lots of call for papers
06:11:50 <vincenz> for WORLDCOMP '06
06:11:55 <gour> great, i'm not missing much then
06:12:12 <vincenz> heh
06:12:20 <vincenz> it's turned into a bashing about the definition of log
06:12:30 <vincenz> all good arguments have been lost already
06:12:33 <vincenz> tho it's weird
06:12:38 <vincenz> generic programming seems to be a hot topic
06:12:48 <vincenz> there's even a 3 day lecture at a univ in uk about generic programming
06:13:18 <vincenz> http://www.cs.nott.ac.uk/ssdgp2006/
06:13:22 <vincenz> I'm considering attending
06:14:59 <araujo> What is this fuss about GP?
06:15:21 <araujo> I also wonder if whoever is advocating C++ in c.l.f is Stepanov :-]
06:15:29 <vincenz> actually
06:15:32 <vincenz> it's quite funny
06:15:36 <vincenz> I read a similar thread a whiile ago
06:15:38 <vincenz> someone referred me to it
06:15:40 <vincenz> it was 97
06:15:43 <vincenz> and started by stepanov
06:15:48 <vincenz> someone must have brushed off the dust
06:15:54 <araujo> hah yeah, i read part of that thread too
06:18:11 <vincenz> it's actually quite funny cause most GP code is basically a patching of ocaml/haskell style code into c++
06:18:37 <vincenz> except that ocaml/haskell always assume a list, while c++ gp decouples that from the algorithm
06:21:10 <goki-> I read something about making Haskell into essentially a full imperative language, is that really possible/useful?
06:21:25 <goki-> Assuming you can retain functional programming style as well?
06:21:40 <vincenz> goki-: imperative or strict?
06:22:01 <goki-> I think I mean imperative, but I could be wrong
06:22:34 <integral> hmm, doesn't it already support writing imperative code?
06:25:05 <Monteiro> tromp_ : http://rafb.net/paste/results/r6yLcT51.html -> I made it work :)
06:26:41 <ADEpt> Monteiro: should eat stack space like crazy, from the first sight ...
06:27:07 <Monteiro> ADEpt : i only calculate what i feel necessary
06:27:16 <Monteiro> ADEpt : see fub, has a take n
06:27:19 <tromp_> it would be simpler to define it as next x y z
06:27:26 <vincenz> what is this supposed to do?
06:27:41 <Monteiro> it's like fibonnaci , but with is only formule
06:27:46 <Monteiro> *formula
06:27:47 <tromp_> he's doinf recurrences
06:27:47 <vincenz> oh!
06:27:52 <vincenz> doinf?
06:28:07 <Monteiro> take n (infinite list)
06:28:38 <vincenz> makes no sense tho
06:28:40 <vincenz> he alters the list
06:28:53 <tromp_> for instance fib m n = m ; fib n (m+n)
06:28:59 <vincenz> yeah but he alters the list
06:29:23 <tromp_> don't make input a list
06:29:25 <Monteiro> [1:1:1] to build the 4ยบ element it's 1 + 1 * 3 + 1 * 2 = 6
06:29:34 <int-e> > let next x y z = x:next y z (x+2*y+3*z) in take 10 $ next 1 1 1
06:29:35 <lambdabot> [1,1,1,6,21,76,276,1001,3631,13171]
06:29:36 <vincenz> Monteiro: not really
06:30:24 <int-e> > let next x y z = x:next y z (x+2*y+3*z) in next 1 1 1 !! 20
06:30:25 <lambdabot> 18841804176
06:30:30 <ADEpt> > let next x y z = :next y z (z+2*y+3*x) in take 10 $ next 1 1 1
06:30:31 <lambdabot>  parse error on input `:'
06:30:35 <vincenz> @which zip
06:30:36 <lambdabot> Unknown command, try @listcommands.
06:30:39 <vincenz> @type zip
06:30:41 <lambdabot> forall b a. [a] -> [b] -> [(a, b)]
06:30:42 <vincenz> @type zipi3
06:30:44 <lambdabot> Not in scope: `zipi3'
06:30:44 <vincenz> @type zip3
06:30:45 <lambdabot> forall c b a. [a] -> [b] -> [c] -> [(a, b, c)]
06:30:50 <ADEpt> > let next x y z = x:next y z (z+2*y+3*x) in take 10 $ next 1 1 1
06:30:52 <lambdabot> [1,1,1,6,11,26,66,151,361,861]
06:30:55 <vincenz> @type zipWitih3
06:30:57 <lambdabot> Not in scope: `zipWitih3'
06:30:58 <vincenz> @type zipWith3
06:30:59 <lambdabot> forall d c b a. (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
06:31:14 <int-e> ADEpt: ah. I read it wrong.
06:31:28 <tromp_> one only has to read http://www.artima.com/cppsource/cpp0xP.html to feel better about haskell:)
06:32:05 <vincenz> myrecurrence = 1:1:1:[zipWith 3 (\x y z -> z+2*y+3*x) myrecurrence (tail myrecurrence) (tail (tail myrecurrence))]
06:32:11 <tromp_> btw take n l !! n is the same as l !! n
06:32:26 <vincenz> > let myrecurrence = 1:1:1:[zipWith 3 (\x y z -> z+2*y+3*x) myrecurrence (tail myrecurrence) (tail (tail myrecurrence))] in take 5 myrecurrence 
06:32:27 <lambdabot>   The function `zipWith' is applied to five arguments,
06:32:27 <lambdabot>   but its type `(a -> b -> c) -> [a] -> [b] -> [c]' has only three
06:32:27 <lambdabot>   In the list element:
06:32:37 <int-e> @index zipWith3
06:32:37 <lambdabot> Data.List, Prelude
06:32:42 <tromp_> uhm, actually you can't take n l !! n
06:32:48 <vincenz> > let myrecurrence = 1:1:1:[zipWith3 (\x y z -> z+2*y+3*x) myrecurrence (tail myrecurrence) (tail (tail myrecurrence))] ini take 5 myrecurrence
06:32:49 <lambdabot>  parse error on input `}'
06:32:55 <tromp_> you'd need to take (n+1)
06:33:00 <gour> tromp_: true, or one can also read about perl6
06:33:01 <vincenz> > let myrecurrence = 1:1:1:[zipWith3 (\x y z -> z+2*y+3*x) myrecurrence (tail myrecurrence) (tail (tail myrecurrence))] in take 5 myrecurrence
06:33:02 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
06:33:02 <lambdabot>   Expected type: [a]
06:33:02 <lambdabot>   Inferred type: [[a]]
06:33:15 <int-e> vincenz: too many []
06:33:21 <vincenz> where
06:33:28 <Itkovian> tromp_: cpp0xP: true
06:33:43 <vincenz> > let myrecurrence = 1:1:1:(zipWith3 (\x y z -> z+2*y+3*x) myrecurrence (tail myrecurrence) (tail (tail myrecurrence))) in take 5 myrecurrence
06:33:44 <lambdabot> [1,1,1,6,11]
06:33:48 <vincenz> yay
06:33:48 <Itkovian> by coincidence, you have the same nick as the prof's name who taught us C++ :-)
06:33:51 <vincenz> > let myrecurrence = 1:1:1:[zipWith 3 (\x y z -> z+2*y+3*x) myrecurrence (tail myrecurrence) (tail (tail myrecurrence))] in take 10 myrecurrence 
06:33:52 <lambdabot>   The function `zipWith' is applied to five arguments,
06:33:52 <lambdabot>   but its type `(a -> b -> c) -> [a] -> [b] -> [c]' has only three
06:33:52 <lambdabot>   In the list element:
06:34:07 <tromp_> what nick?
06:34:10 <vincenz> > let fub = 1:1:1:(zipWith3 (\x y z -> z+2*y+3*x) fub (tail fub) (tail (tail fub))) in take 5 fub
06:34:12 <lambdabot> [1,1,1,6,11]
06:34:19 <vincenz> > let fub = 1:1:1:(zipWith3 (\x y z -> z+2*y+3*x) fub (tail fub) (tail (tail fub))) in take 10 fub
06:34:21 <lambdabot> [1,1,1,6,11,26,66,151,361,861]
06:34:22 <vincenz> \o
06:34:26 <vincenz> \o/
06:34:29 <Itkovian> 'tromp'
06:34:37 <tromp_> now find a way to get rid of those repeated tails...
06:34:44 <tromp_> that's not a nick...
06:34:51 <vincenz> tromp_: they're bad?
06:34:56 <vincenz> oh I know
06:34:57 <Itkovian> well, it doesn't matter, it's used as one :-)
06:35:40 <tromp_> the best way to do recurrences seems to be
06:35:43 <tromp_> recurrence coeff basis = rec where
06:35:43 <tromp_>  rec = basis ++ rest
06:35:43 <tromp_>  rest = foldl (zipWith (+)) (repeat 0) $ zipWith (map.(*)) coeff $ tails rec
06:35:53 <vincenz> seems inefficient
06:36:34 <tromp_> for instance his next = recurrence [1,2,3] [1,1,1]
06:36:44 <vincenz> yeah but seems extremely inefficient
06:37:11 <int-e> let fub=1:a; b=1:b; c=1:zipWith3 (\x y z -> z + 2*y + 3*x) fub a b in take 10 fub
06:37:13 <int-e> > let fub=1:a; b=1:b; c=1:zipWith3 (\x y z -> z + 2*y + 3*x) fub a b in take 10 fub
06:37:14 <lambdabot>  Not in scope: `a'
06:37:31 <tromp_> don't know why you'd think that
06:37:33 <int-e> > let fub=1:a; a=1:b; b=1:c; c=1:zipWith3 (\x y z -> z + 2*y + 3*x) fub a b in take 10 fub
06:37:35 <lambdabot> [1,1,1,1,6,6,11,21,41,61]
06:37:41 <vincenz> :)
06:38:00 <int-e> > let fub=1:a; a=1:b; b=1:zipWith3 (\x y z -> z + 2*y + 3*x) fub a b in take 10 fub
06:38:02 <lambdabot> [1,1,1,6,11,26,66,151,361,861]
06:38:28 <vincenz> recursive definitions
06:38:29 <vincenz> groovy
06:38:42 <tromp_> actually it's recurrence [3,2,1] [1,1,1]
06:38:55 <vincenz> tromp_: recurrence is aboutthe most innefficent thing I've ever seen
06:39:03 <tromp_> while fib = recurrence [1,1] [0,1]
06:39:06 * vincenz votes int-e 
06:39:14 <int-e> let a .*. b = sum $ zipWith (*) a b; step rec pre = tail $ pre ++ [rec .*. pre] in step [3,2,1] [1,1,1]
06:39:17 <Itkovian> vincenz: to iterate is human, to recurse divine :-)
06:39:30 <Itkovian> @karma help
06:39:31 <lambdabot> help has a karma of 0
06:39:35 <vincenz> Itkovian: I wasn't talkking abut recursion
06:39:36 <Itkovian> yeah
06:39:39 <vincenz> I was talking about his recurrence function
06:39:44 <Itkovian> ah yes, I see that now
06:39:50 <Itkovian> sorry
06:39:53 <vincenz> no worries
06:39:56 <tromp_> it is for arbitrary order, vincenz
06:40:17 <vincenz> tromp_: so is int-e's
06:40:24 <int-e> no.
06:40:30 <tromp_> no way
06:40:35 <vincenz> sure it is, if you meta-instantiate it
06:42:45 <int-e> vincenz: that's hard to do at run-time.
06:42:59 <vincenz> true
06:43:05 <vincenz> but you could prolly define
06:43:06 <vincenz> recurrence2
06:43:08 <vincenz> recurrence3
06:43:10 <vincenz> recurrence4
06:43:16 <int-e> sure
06:43:17 <vincenz> and then you could do it in your efficient way
06:43:50 <vincenz> hmm
06:44:19 <tromp_> and you could use template haskell to do it for any order:(
06:44:22 <vincenz> perfect for templatehaskell :)
06:44:35 <vincenz> meta instantiations \o/
06:44:36 <tromp_> and it would be no more efficient than my simple definition:(
06:44:44 <vincenz> o.O
06:44:45 <vincenz> sure it would
06:44:47 <vincenz> it doesn't use ++
06:45:21 <tromp_> neither does mine
06:45:26 <ADEpt> > let next (x,y,z) = (y,z,z+2*y+3*x) in take 10 (iterate next (1,1,1))
06:45:28 <lambdabot> [(1,1,1),(1,1,6),(1,6,11),(6,11,26),(11,26,66),(26,66,151),(66,151,361),(
06:45:28 <lambdabot> 151,361,861),(361,861,2036),(861,2036,4841)]
06:45:31 <tromp_> expect once at the start
06:45:31 <vincenz> tromp_: recurrence?
06:45:40 <vincenz> ADEpt: I had been thinking that but it's a lot of dupplication
06:45:54 <tromp_> the problem is you didn't bother to understand my definition...
06:46:11 <vincenz> tromp_: yes I did
06:47:51 <vincenz> tromp_: wait... you're from nl
06:47:53 <vincenz> you work on clean?
06:48:31 <tromp_> no
06:49:00 <vincenz> what do you work on?
06:49:41 <tromp_> go
06:49:52 <vincenz> ooh
06:49:56 * vincenz wants to get better at go
06:50:39 <Cale> vincenz: :)
06:50:51 <vincenz> Cale: ?
06:51:05 <Cale> There are lots of go players around, including me
06:51:09 <vincenz> ah
06:51:10 <vincenz> cool
06:51:12 * vincenz sucks at go
06:51:18 <vincenz> I'm only slightly decent on small boards
06:51:20 <vincenz> I get lost on big boards
06:51:36 <vincenz> I'd love to get restarted
06:51:44 <vincenz> but it's not fun to play against faceless strangers on kgo
06:51:45 <tromp_> i'm pretty good at 2x2
06:51:45 <vincenz> or igo
06:51:48 <vincenz> LOL
06:51:53 <Cale> It's a different game on the 19x19 board, isn't it? :)
06:51:57 <vincenz> yeah
06:52:00 <vincenz> 9x9 is ok
06:52:02 <tromp_> don't laugh; 2x2 is hard!
06:52:04 <vincenz> 19x19....I'm lost
06:52:06 <vincenz> tromp_: no it's not
06:52:17 <vincenz> I played 2x2 on igo
06:52:26 <tromp_> do you know how many possible 2x2 games there are?
06:52:38 <vincenz> tromp_: hardly many
06:52:55 <edwinb> depends on the rules. it makes my brain hurt.
06:53:00 <vincenz> anywho
06:53:12 <vincenz> where do you play go?
06:53:27 <vincenz> I wouldn't ming getting a sparring partner
06:53:28 <tromp_> under AGA/NZ rules
06:53:29 <int-e> I know tromp calculated that number, I forgot for which ruleset(s?) though.
06:53:44 <vincenz> tromp_: how many board positiosn are there?
06:53:50 <tromp_> 57
06:54:08 * vincenz scratches his head
06:54:11 <vincenz> how can that be
06:54:12 <edwinb> 57? coo.
06:54:16 <vincenz> that seems like too many
06:54:20 <edwinb> sounds plausible
06:54:21 <tromp_> and 386356909593 possible games
06:54:38 <vincenz> but aren't they isomorphic to boardflips or board trns?
06:54:43 <Lor> An odd number?
06:54:53 <Lor> This includes all the symmetric variations?
06:54:56 <int-e> Lor: there's the empty board
06:54:58 <tromp_> yes
06:55:12 <vincenz> tromp_: so wiithout symmetric variations?
06:55:15 <tromp_> the game pass pass is the same no matter how you flip it
06:55:22 <Cale> tromp_: which ko rule?
06:55:24 <Lor> Right.
06:55:27 <tromp_> positional superko
06:55:30 <Cale> okay
06:55:42 <tromp_> with situational superko it would be more
06:55:44 <vincenz> what is that?
06:55:47 <Cale> you'd need something like that :)
06:56:04 <Lor> positional superko is situational modulo whose turn it is?
06:56:07 <vincenz> hmm
06:56:09 <Philippa_> in 2x2 there's one possible first move and two possible second moves...
06:56:09 <tromp_> yes
06:56:10 <Cale> The superko rule says that you may not repeat a previous board position.
06:56:20 <vincenz> Philippa_: three
06:56:24 <tromp_> PSK is much nicer from mathematical point of view
06:56:29 <tromp_> SSK is messy
06:56:31 <Philippa_> vincenz: nope, you play the opposing diagonal or to the side
06:56:33 <vincenz> oh wait, you're right, it symmetric
06:56:38 <Lor> Philippa_, or pass.
06:56:54 <Philippa_> Lor: point. Though I don't see any possible gain in a pass at that point
06:57:09 <Cale> vincenz: the next time the board is empty, it's not symmetric though
06:57:10 <vincenz> what is superko?
06:57:15 <tromp_> an optimal 2x2 game is A1 B2 A2 pass pass
06:57:20 <Cale> vincenz: The superko rule says that you may not repeat a previous board position.
06:57:21 <Philippa_> remind me what happens if there's no available play for someone due to the ko rule?
06:57:25 <int-e> vincenz: forbidding repetition of a whole board position
06:57:30 <Cale> Philippa_: they lose
06:57:35 <int-e> vincenz: except by a pass, obviously
06:57:35 <tromp_> but some games last for over 80 turns:)
06:57:39 <vincenz> nd what is the diifference between positional or the other one
06:58:00 <Lor> tromp, so there's just one seki?
06:58:08 <int-e> vincenz: if you only forbid the same position with the same player to move, that's the situational super ko rule.
06:58:23 <vincenz> ah
06:58:28 <Cale> vincenz: positional -> you can't repeat that pattern of stones, situational -> you can't repeat that pattern of stones on the same player's turn
06:58:34 <vincenz> thx :)
06:58:45 <Cale> http://senseis.xmp.net/?Superko
06:58:50 <tromp_> well, except you can always pass
06:58:54 * vincenz has been wanting to make a freecell solver 
06:58:59 <vincenz> I plaly that game out of mental boredom WAY too much
06:59:00 * SimonRC is having a bizzare problem with his depth-first-search program: http://compsoc.dur.ac.uk/~sc/BFS.lhs ...
06:59:21 <vincenz> Cale: where do you play
06:59:22 <Cale> tromp_: yeah, unless you want to play mathematical go :)
06:59:34 <SimonRC> trace seems to indicate that the first case is being ignored on recursive calls.  Any clues?
06:59:43 <Cale> vincenz: KGS, as well as occasionally in real life.
06:59:50 <psnl> SimonRC: nice to see you have implented a datatype for a graph
06:59:52 <tromp_> SSK: you cannot move to position p if p already occured with the same player to move
07:00:05 <vincenz> who else plays on KGS
07:00:22 * edwinb waves
07:00:23 <SimonRC> psnl: how else would anyone do it?
07:00:26 <tromp_> i just played a 4x4 game there
07:00:27 <edwinb> (well, occasionally I do anyway)
07:00:36 <SimonRC> edwinb: hi, person I know already
07:00:40 * vincenz would love some insights on big board games
07:00:53 <edwinb> hello Simon
07:01:01 <psnl> vincenz: very hard to do, go play some
07:01:12 <psnl> SimonRC: you didn't have a type in the lecture
07:01:30 <vincenz> psnl: I have but either you're lost against someone stronger, or you hae someone who's just as clueless
07:01:33 <SimonRC> psnl: I upgraded a bit
07:01:44 <SimonRC> psnl: hello other person I know
07:02:17 <Cale> vincenz: Well, I could show you a few things that you should know
07:02:23 <edwinb> One of the great things about go is that playing someone a bit stronger teaches you stuff, without you having to try.
07:02:28 <vincenz> Cale: sure :)
07:02:31 <psnl> vincenz: you are supposed to lose your first fifty games, and you need to play at least a thousand to get any good
07:02:31 <SimonRC> edwinb: yes
07:02:35 <vincenz> they should make a haskell kgs client
07:02:50 <Cale> vincenz: they should make an open source kgs client
07:02:52 <tromp_> replace they->i
07:02:52 <edwinb> who are "they" ;)
07:02:56 <vincenz> edwinb: people
07:03:02 <edwinb> you are in the set of people...
07:03:09 <vincenz> not in the set of opensource creators
07:03:09 <psnl> edwinb: the people who control my life
07:03:09 <Cale> you'll have to reverse engineer the protocol.
07:03:27 <vincenz> why don't you play the other one?
07:03:31 <edwinb> if you want to write a client, it would have to be for another server. Or write a server while you're at it.
07:03:43 <vincenz> the other one is open source no?
07:03:50 <tromp_> only nngs is
07:04:01 <edwinb> and nobody uses that any more...
07:04:08 <vincenz> why
07:04:10 <Cale> KGS has the nicest editing tools
07:04:14 <Philippa_> mostly, "they" = someone
07:04:22 <vincenz> Cale: editing tools are for post game no?
07:04:32 <Cale> vincenz: and during, in teaching games
07:04:33 <edwinb> "they" = someone other than me ;)
07:04:34 <vincenz> Cale: and editing tools for post game are based on the common format
07:04:46 <vincenz> forgot the format but there's a standardized format
07:04:55 <Cale> vincenz: yeah, it's just SGF
07:05:04 <vincenz> right that one...it's been a while
07:05:40 <psnl> edwinb: do all functional programmers play go?
07:05:42 <Cale> CGoban 2 is the nicest SGF editor right now.
07:05:56 <vincenz> anyways
07:05:58 <vincenz> coffeebreak
07:06:00 <vincenz> bbl
07:06:04 <edwinb> psnl: they all should ;)
07:06:07 <vincenz> gotta socialize with my coworkers
07:06:36 <dcoutts> JaffaCake, I've got wiki links from each function working:
07:06:36 <dcoutts> http://haskell.org/gtk2hs/docs/devel/Graphics-Rendering-Cairo-SVG.html
07:06:40 <dcoutts> comments?
07:06:40 <Cale> You might think that SGF stands for 'Standard Go Format', but it's actually 'Smart Game Format' :)
07:06:53 <vincenz> anyways... if there were a haskell client or possibly editor (and in the end... isn't an editor with a basic protoco lbasically a game that's internet playable...) people could experiment with siimple ai's
07:07:39 <int-e> People do, using GTP and kgs' GTP client.
07:08:30 <vincenz> the protocol shouldn't be THAt complex should it
07:08:38 <vincenz> basically just support SGF and some chatty stuff
07:08:51 <vincenz> (a simple IRC combined with encapsulated SGF
07:10:23 <gour> dcoutts: it looks very nice
07:11:12 <gour> dcoutts:although 'user' & 'comments' are separated, and it gives (to me) impression that there are two links actually
07:11:26 <Cale> vincenz: right, the protocol in general shouldn't be that bad
07:12:05 <xerox> Oh, I thought about writing an internet-enabled Go Haskell program.
07:12:20 <Cale> xerox: with cairo!
07:12:21 <gour> dcoutts: maybe to coin some other 1-word term?
07:12:26 <int-e> well, there is game information, sound ... by choosing a closed protocol, wms can extend it as he likes and deprecate old versions ...
07:12:28 * int-e shrugs
07:12:30 <xerox> Cale: indeed.  Now with SVG is even simpler!
07:13:37 <dcoutts> gour, that's a good point, perhaps a background/border to make it look more button like?
07:13:46 <gour> someone can write some fisher chess program in haskell with gui interface
07:14:09 <gour> dcoutts: well, you can try, i'll give you feedback
07:14:47 * dcoutts pushes Cale & xerox to use the new SVG cairo lib
07:15:03 <dcoutts> http://haskell.org/gtk2hs/docs/devel/Graphics-Rendering-Cairo-SVG.html
07:15:26 <xerox> blackStone :: SVG; whiteStone :: SVG
07:15:38 * gour pushes someone to write chess engine & gui in haskell :-)
07:15:52 <dcoutts> blackStone <- svgNewFromFile "BlackStone.svg"
07:16:02 * gour is happy seeing xerox already started
07:16:03 <dcoutts> svgRender blackStone
07:16:13 <xerox> Heh gour.
07:16:22 <gour> :-)
07:16:35 <xerox> dcoutts: I wonder about the GUI/Network concurrency, is there any problem?
07:16:36 <int-e> dcoutts: which svg lib are you binding to?
07:16:41 <flux__> hmm.. collaborative programming over irc..
07:16:44 <xerox> int-e: libsvg-cairo
07:16:54 <xerox> flux__: e*x*a*c*t*l*y
07:16:56 <flux__> maybe with some ed-like interface :)
07:17:05 <xerox> Err..  I like gobby :-)
07:17:05 <Cale> actually, probably want 5 or 6 nice white stones :)
07:17:05 <gour> flux__: yep. haskell version of gobby :-)
07:17:07 <flux__> "now shut up people, I'm writing a routine!"
07:17:21 <xerox> Cale: just transform a base one, either
07:17:22 <dcoutts> xerox, people have written irc clients with gtk2hs usign threads. One thread for the network & one for the GUI.
07:17:29 <xerox> dcoutts: ah-ha!
07:17:32 <Cale> xerox: yeah, that's possible :)
07:17:58 * gour does not understand (yet) the evil of gtk+ threading
07:18:13 <psnl> I ought to learn a threading library
07:18:15 <dcoutts> int-e, and if libsvg-cairo dies out, we can switch to librsvg without changing the Haskell API.
07:19:02 <dcoutts> int-e, we're sort-of waiting to see with cairo svg lib becomes the de-facto standard
07:19:07 <dcoutts> with/which
07:19:28 <xerox> Cale: do you have some free time to try to gobby out an Haskell-Go sketch?
07:19:45 <dcoutts> gour, you mean threading with gtk2hs or threading in C with Gtk+ ?
07:19:46 <Cale> sure, we could :)
07:19:49 <xerox> I have a fresh gtk2hs build to fire up :-)
07:19:57 <dcoutts> xerox, yay!
07:19:58 <int-e> dcoutts: cworth has more or less stated that libsvg-cairo was a quick hack based on librsvg and that he prefers librsvg.
07:20:25 <dcoutts> int-e, indeed. But librsvg with cairo is not out yet. I'll switch if necessary.
07:20:45 <dcoutts> gour, they're quite different. One is sane, the other is insane. :-)
07:20:50 <int-e> dcoutts: I don't know which of the two works better at the current time. librsvg's cvs has cairo code.
07:20:52 <gour> dcoutts: well, i heard about gtk (C) threading, but i'm interested primarily for gtk2hs (although it is not rush to explain now, i'm not there yet - step by step)
07:21:18 <gour> dcoutts: heh, that's elucidating comment
07:21:31 <int-e> dcoutts: I don't follow the releases though.
07:21:56 <dcoutts> int-e, yeah, I looked at the librsvg cairo api, it looks ok. But libsvg-cairo is out now and works. When cairo versions of librsvg are released and become standard I'll switch.
07:22:00 <gour> dons: pls .put this dcoutt's statement as 'quote of the week'
07:24:04 <dcoutts> gour, the main difference is that threading with Gtk+ in C requires aquiring a lock for many ops.
07:24:43 <dcoutts> so it's not possible to write code that doesn't know wether it's running in the context of the main loop or not
07:24:45 <gour> dcoutts: why?
07:24:48 <dcoutts> in C that is
07:24:53 <gour> ok
07:25:12 <gour> gtk2hs?
07:25:13 <dcoutts> because in one case you have to aquire a lock and in the other you don't
07:25:49 <dcoutts> in gtk2hs you just do a little magic at the beginning of the program to enable threads and then it "Just Works"tm.
07:26:00 <gour> timer?
07:26:01 <dcoutts> you can use forkIO as much as you like
07:26:43 <dcoutts> it shares time between the gtk+ main loop and any runnable Haskell threads.
07:27:04 <SamB> dcoutts: what is this you say?
07:27:21 <gour> dcoutts: this is explained on the site in faq?
07:27:34 <SamB> dcoutts: are you talking about that ugly kludge or did it get fixed?
07:27:38 <dcoutts> gour, Yes. In detail.
07:27:53 <dcoutts> SamB, "ugly kludge" is a matter of opinion :-)
07:28:13 <dcoutts> SamB, it does use polling, but it's actually quite a low overhead. I can't measure it.
07:28:42 <gour> dcoutts: and what multi-threading brings in reality (gtk2hs) ?
07:28:55 <SamB> dcoutts: it still doesn't look very pretty, does it?
07:28:57 <dcoutts> SamB, By "I can't measure it" I mean that it's sufficiently close to 0 that I cannot measure the difference.
07:29:13 <SamB> dcoutts: yes, I figured that out ;-)
07:29:27 <dcoutts> SamB, I would like to use a non-polling mechanism but I need more help from the RTS.
07:29:52 <SamB> huh, some bozo in ##c wants to use a relational database to hold one integer...
07:30:12 <dcoutts> gour, threads can be quite a handy way of doing GUIs. It means you don't have to split long running operations into little restardable slices.
07:30:17 <SamB> dcoutts: I have decided that I am not an RTS hacker. at least not yet.
07:30:28 <dcoutts> restardable/restartable
07:30:52 <SamB> hmm. reminds me of STM.
07:31:06 <dcoutts> SamB, I tried a hack. It mostly worked. But I'm waiting for the new SMP rts for some changes JaffaCake said might improve the situation.
07:31:26 <dcoutts> SamB, per-OS-thread runques of Haskell threads.
07:31:27 * JaffaCake wakes up
07:31:35 <dcoutts> so that we can set thread affinity
07:31:44 <gour> dcoutts: i just read that it helps in not carrying too much state around ?
07:31:52 <dcoutts> ie bind Haskell GUI threads to the GUI OS thread.
07:31:56 <SamB> dcoutts: wouldn't you need something stronger than affinity?
07:31:59 <Philippa_> 'lo JaffaCake. I've been wondering something lately: how come GHC never implemented transformational patterns? Was there a technical reason, or was it just work with little demand?
07:31:59 <dcoutts> gour, right
07:32:13 <dcoutts> SamB, what do you mean?
07:32:25 <JaffaCake> Philippa_: I'm not sure what transformational patterns are, got a link?
07:32:38 <gour> dcoutts:thanks, that looks more close to my needs, but who knows, maybe i'll take advantage of the 1st one too
07:32:50 <SamB> doesn't affinity usually just mean that you want a thread to run in a particular place for performance reasons?
07:33:05 <JaffaCake> dcoutts: are you talking about the problem of having several Haskell threads bound to the same OS thread?
07:33:10 <Philippa_> JaffaCake: they're described in the same paper as pattern guards. pat!expr, runs the value being matched against through expr before continuing matching
07:33:14 <dcoutts> JaffaCake, yes.
07:33:15 <SamB> JaffaCake: yup
07:33:19 <gour> dcoutts: and how is the whole stuff supported on multi-platform?
07:33:32 <Philippa_> the sugarless variant being what I currently suggest every time someone complains about views
07:33:32 <SamB> gour: the threads are green
07:33:34 <JaffaCake> Philippa_: thanks, I'll have to go back and read that
07:33:35 <dcoutts> JaffaCake, people brought up the question of Haskell threads & GUIs again.
07:34:05 <dcoutts> gour, the thread stuff works on win32 too. It's pretty portable. No C hacks involved.
07:34:07 <SamB> gour: and there is code for OS threads on win32 and *nix
07:34:08 <Philippa_> I could certainly see how it'd be something of a PITA to implement in that it's that much more complicated to translate into non-nested case
07:34:14 <SimonRC> Do the results of Debug.Trace.trace always come out in the right order?
07:34:20 <flux__> samb, I've used a table that holds one integer, but the table was also used with postgresql's notification mechanism ;)
07:34:24 <SamB> SimonRC: what is the right order?
07:34:30 <JaffaCake> dcoutts: I thought it might be easier to implement that with the new runtime, but now I'm not so sure
07:34:39 <dcoutts> JaffaCake, oh?
07:34:46 <SamB> flux__: he just wanted to do a hit counter for a website
07:34:53 <tromp_> funnt quote from FC++ docs:
07:34:56 <tromp_> Unlike Haskell, in FC++, we can do comprehensions in any monad (not just lists). Here's an example with some surrounding C++ code:
07:35:09 <JaffaCake> dcoutts: that's all I remember just now, I'll have to page it back in again :)
07:35:17 <SimonRC> SamB: the first argument is printed out before the output of any tracing in the second argument.
07:35:19 <dcoutts> JaffaCake, s'ok
07:35:27 <dcoutts> JaffaCake, actually what I wanted to ask you about was if you had any insight into where in the haddock code I should insert the "user comments" link
07:35:44 <dcoutts> JaffaCake, I've got it going for ordinary functions:
07:35:53 <JaffaCake> cool!
07:35:53 <dcoutts> pick any page here:
07:35:54 <dcoutts> http://haskell.org/gtk2hs/docs/devel/
07:35:55 <SimonRC> SamB: I mean, will it come out in that order?
07:36:02 <SamB> SimonRC: it should
07:36:06 <SimonRC> hmm
07:36:28 <dcoutts> JaffaCake, but I was trying to see if there was one location that'd do it for each kind of documented entity, functions, types, etc.
07:36:28 <JaffaCake> that looks really good
07:36:34 <dcoutts> JaffaCake, thanks :-)
07:36:44 <SamB> because the second arg isn't supposed to be entered until the first arg is printed
07:37:18 <gour> dcoutts: does it mean that ghc will also get populated with 'example usage' code?
07:37:34 * gour is joking again
07:37:34 <dcoutts> JaffaCake, the more I look at the haddock html output the more I want to change it all to use css. Except that I don't want to be the person to do it! :-)
07:37:40 <JaffaCake> dcoutts: I'll have to go look at the code, I don't remember off the top of my head
07:38:00 <JaffaCake> dcoutts: that'd be great
07:38:02 <dcoutts> JaffaCake, I can darcs send you my current patches
07:38:05 * gour aggrees with dcoutts
07:38:30 <dcoutts> at the moment it uses a mixture of table & css layout
07:38:50 * gour hates fiddling with tables in html
07:39:24 <SamB> dcoutts: you mean like I want to get Self going again but don't want to write the parser, or my z-machine interpreter but don't want to write the GUI?
07:39:42 <dcoutts> heh :-)
07:39:50 <JaffaCake> dcoutts: I seem to recal that you couldn't do table-style layout with CSS, is that still true?
07:40:09 <dcoutts> JaffaCake, I think it can be done now with CSS 2(.1)
07:40:21 <gour> JaffaCake: iirc, IE has poor support for (many) CSS-2
07:40:29 <JaffaCake> yes
07:40:44 * gour hit the wall trying to do css-only layout on the sites
07:40:57 <JaffaCake> I spent quite a few long days playing with the haddock layout, it's really frustrating
07:41:07 <vincenz> re
07:41:19 <JaffaCake> I don't particularly want to go there again :)
07:41:23 <dcoutts> JaffaCake, I can believe it.
07:41:41 <vincenz> what's cairo
07:41:44 <JaffaCake> but somtimes I look at it and think it really sucks
07:42:36 <jethr0> moin moin
07:42:37 <SamB> hmm, I wonder why there is this MVar here...
07:42:37 * vincenz wants to learn haskell but to learn it I should write some programs, but I'm not sure what
07:42:49 <SamB> it seems kind of out of place amidst all the STM...
07:42:52 <dcoutts> vincenz, see cairographics.org
07:43:30 <dcoutts> vincenz, and then see the Hasell version of the cairo API:
07:43:31 <dcoutts> http://haskell.org/gtk2hs/docs/current/Graphics-Rendering-Cairo.html
07:44:01 <dcoutts> vincenz, gtk2hs comes with some cairo demos
07:44:10 * vincenz hmmms
07:44:15 <vincenz> what's so special about cairo
07:44:17 <dcoutts> http://darcs.haskell.org/gtk2hs/demo/cairo/
07:44:29 <xerox> it looks cool, and has an 'easy' api
07:44:31 <dcoutts> vincenz, it produces nice output. And it's not a pain to use.
07:44:40 <xerox> dang.
07:44:43 <vincenz> hmm
07:44:43 <dcoutts> what xerox said :-)
07:44:59 <vincenz> doesn't it risk to become inefficient by not using the more complex primitives of the underlying system
07:45:05 <xerox> not many languages come with a simple graphic interface
07:45:11 <vincenz> and basically requiring a reinvention of the wheel
07:45:40 <dcoutts> vincenz, it's actually quite effecient. It does lots of peformance tricks under the nice API.
07:45:46 <vincenz> ah
07:45:57 <dcoutts> though you do pay somewhat for the nice quality output
07:46:17 <dcoutts> but for equal quality output the cairo api is nicer/shorter
07:46:32 <dcoutts> it's really well designed
07:46:35 <vincenz> :)
07:46:38 <dcoutts> imho
07:46:39 <vincenz> hmm
07:46:41 <vincenz> alright
07:46:42 <SamB> @pl \(s,r) -> (s,choke)
07:46:43 <lambdabot> flip (,) choke . fst
07:46:50 <vincenz> @type (,)
07:46:52 <lambdabot> forall b a. a -> b -> (a, b)
07:46:53 <xerox> @index choke
07:46:54 <lambdabot> bzzt
07:47:00 <vincenz> @hoogle choke
07:47:01 <lambdabot> No matches found
07:47:10 <xerox> SamB: (id *** choke)
07:47:16 <vincenz> SamB: what's the use of r
07:47:17 <SamB> choke is just some variable that is in scope
07:47:19 <xerox> SamB: second choke
07:47:21 <vincenz> @type (***)
07:47:22 <lambdabot> Not in scope: `***'
07:47:24 <xerox> ah, duh
07:47:29 <vincenz> @hoogle ***
07:47:29 <lambdabot> Control.Arrow.(***) :: Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
07:47:31 <xerox> SamB: second $ const choke
07:47:37 <vincenz> @type const
07:47:37 <jethr0> xerox: shoudn't it be "const choke"?
07:47:38 <lambdabot> forall a b. a -> b -> a
07:47:40 <xerox> @pl second $ const choke
07:47:41 <lambdabot> second (const choke)
07:47:48 <xerox> jethr0: yes, sure.
07:47:53 <SamB> why is it that @pl does not tell me "second (const choke)"?
07:47:55 <xerox> jethr0: I thought it was some function.
07:48:00 <dcoutts> vincenz, oh and it can output to various targets, in memory bitmaps, pngs, on screen windows, ps files, pdf files and in the next version svg files.
07:48:03 <jethr0> :)
07:48:03 <xerox> SamB: 'cos TheHunter is a slacker!
07:48:21 <SimonRC> Does trace actually intefere with lazyness?
07:48:26 <vincenz> dcoutts: I think as first problem I would like to write a freecell solver
07:48:35 <SamB> SimonRC: in what way?
07:48:40 <dcoutts> vincenz, the other reason to use it is that everyone else is using it :-) gtk, mozilla, mono, ...
07:48:42 <vincenz> to learn haskell
07:48:45 <xerox> vincenz: did you see Cale's monadic sudoku solve?
07:48:49 <xerox> solver, even
07:48:58 <vincenz> xerox: I have it, not looked at it yet tho, but I can imagine it uses a similar technique
07:49:14 <dcoutts> vincenz, for learning haskell, start with the non-gui bit.
07:49:16 <vincenz> but I want to learn haskell
07:49:23 <jethr0> SimonRC: it says in the docu that trace interferes with evaluation and should only be used for rough debugging
07:49:33 <vincenz> right
07:49:34 <vincenz> so first things first
07:49:39 <SimonRC> SamB: if you trace the generation of an infinite data structure, will that cause the program to loop
07:49:45 <SamB> SimonRC: it will evaluate only as far as it needs to to print the message, and of course it will put the value in WHNF (but the caller wanted it to be in WHNF anyway)
07:49:45 <SimonRC> jethr0: thanks
07:49:50 <vincenz> and I apologize for sounding like a newb, it seems haskell erquires a different default idiom than ocaml
07:50:02 <dcoutts> vincenz, starting with the IO parts of your program will give you bad habbits.
07:50:15 <vincenz> dcoutts: I know, but it'd be nicer to experiment
07:50:21 <xerox> Cale: I'm reading with Gobby if you will.
07:50:27 * gour listens wise words of dcoutts
07:50:33 <vincenz> what's it called again the xxx of a card "Hearts, Clovers,.."
07:50:37 <xerox> If anybody wants to gobby out Haskell-Go just tell me.
07:50:41 <SamB> dcoutts: that probably depends on what your program does with IO
07:50:43 <vincenz> xerox: gobby?
07:50:43 <jethr0> "The trace function is not referentially transparent"
07:50:50 <SamB> maybe not though
07:50:52 <xerox> vincenz: yeah, a collaborative real-time text editor.
07:50:56 <xerox> @google gobby
07:50:58 <lambdabot> http://gobby.0x539.de/
07:51:01 <vincenz> what does gobby out mean
07:51:02 <dcoutts> SamB, sure, but for beginners you can see my point.
07:51:05 <SamB> jethr0: yeah, but it only breaks referential transparency by printing messages
07:51:17 <tromp_> @google tromp
07:51:19 <lambdabot> http://homepages.cwi.nl/~tromp/
07:51:21 <vincenz> xerox: gobby out
07:51:23 <xerox> vincenz: 'use gobby to edit collaboratively'
07:51:23 <tromp_> cool:)
07:51:30 <vincenz> xerox: oh sure :)
07:51:36 <jethr0> SamB: that wouldn't be worth noting, methinks. i thought there were issues with evaluation beyond that
07:51:39 <vincenz> I'd love to gobby with someone to learn a bit of haskell :)
07:51:43 <vincenz> perfect pairprogramming
07:52:08 <SamB> jethr0: maybe, but I don't think those are referential transparency issues
07:52:16 <xerox> vincenz: come here :-)
07:52:20 <vincenz> xerox: whrere
07:52:29 <xerox> vincenz: I told you the data privately
07:52:44 <goki-> I kind of wandered off in the middle of a conversation there, sorry
07:53:09 <SamB> jethr0: I expect seq has the same "issues"
07:53:25 <SamB> er, well, not quite.
07:53:34 <SamB> you'd need to force the entire string...
07:53:49 <jethr0> SamB: yes, but from what i understood "trace" can sometimes change execution results or sth like that, and then the author doesn't want to get blamed for it :)
07:54:05 * vincenz reboots his laptop to ubuntu
07:54:26 <SamB> jethr0: most likely because of things that can happen in the process of evaluating the string
07:54:33 <SimonRC> hmm
07:55:10 <jethr0> SamB: yes, and _that_ is a "ref. transparency" issue if trace is supposed to do its job without disturbing anything else
07:55:54 <eivuokko> trace also likely causes a system call or two.
07:56:03 <SamB> but I could probably rig up a function with the same issues using seq and common Prelude functions
07:56:04 * SimonRC really needs a thing that will allow him to evaluate expressions a bit at a time.
07:56:06 <eivuokko> And those tend to slow down things.
07:56:15 <jethr0> well, maybe not. at least, if strange things happened while using trace i'd disable it and try again...
07:56:35 <SamB> eivuokko: not as much as actually blitting the text to the screen
07:56:49 <jethr0> SamB: hmm, haven't thought about it. i guess one would need "performUnsafeIO", right?
07:56:58 <SamB> jethr0: that isn't in Prelude
07:57:05 <Philippa_> or indeed in Haskell 98
07:57:14 <jethr0> how would you hide the IO then?
07:57:17 <Philippa_> it's an implementation-specific hack which happens to've become a pseudo-standard for more hacks
07:57:34 <SamB> I meant things like foldr
07:58:05 <SamB> I said "something that has the same issues", not "something that does the same thing"
07:58:23 <SamB> I mean, it would have those other issues but not actually print anything ;-)
07:58:52 <jethr0> SamB: ah, ok. well, but with "seq" it's kinda intended. i guess the author of trace just wanted to prevent people from thinking that it would automagically and transparently solve ALL problems
07:58:57 <jethr0> :)
07:59:20 <Philippa_> AIUI trace doesn't actually alter that much unless the IO consequences're serious (eg you've got heap space worries)?
07:59:47 <jethr0> Philippa_: i really don't know. i'd just be cautious while using it.
08:00:48 <Philippa_> trace text = unsafePerformIO <do the print bit> `seq`?
08:00:58 <Philippa_> (apologies for pointlessness)
08:01:05 <SimonRC> Aha!  It is evaluating the same things repeatedly.  I need a data structure for Haskell to keep all the appropriates thunks in, rather than having it re-invent the same thunks repeatedly.
08:01:19 <Philippa_> if so, I'd expect it to leave the evaluation order on values pretty much unaltered
08:01:20 <jethr0> Philippa_: that would be my guess
08:01:30 <dcoutts> SimonRC, how are the thunks indexed?
08:01:41 <SimonRC> they aren't at the moment.
08:01:46 <dcoutts> SimonRC, keep an array or some other collecton of them?
08:01:52 <SimonRC> I am about to
08:02:07 <jethr0> Philippa_: i guess you're right. i just had it in the back of my mind that there might be issues with trace. might not be the case...
08:06:08 <Lemmih> JaffaCake: Would it be hard to change the GHC build system so the GHC library doesn't link with every .o file it can find?
08:06:44 <JaffaCake> what do you mean?
08:08:32 <Lemmih> It currectly links with the object files from the GHC binary (Config.o, Main.o ...) which means it can't be used from ghci/hIDE.
08:09:42 <JaffaCake> but Config.o is required as part of GHC?  maybe not Main.o though
08:10:23 <Lemmih> But the GHC library doesn't mention Config in either 'exposed-modules' or 'hidden-modules'.
08:11:54 <SimonRC> My idea is rather than recursing directly, the function looks values up in a Data.Map.Map, which is a simple lookup table of the function.
08:12:01 <JaffaCake> Lemmih: it should
08:12:44 <vincenz> re
08:12:46 <vincenz> sorry for the long delay
08:12:56 <vincenz> Anyone know a generic way to turn proxy on and off
08:13:33 <vincenz> basically at work I ihave to pipe everything through a proxy, and at home I don't have a proxy... so I want a way that'll set up all the different programs (as well as for instance the Proxycommand in .ssh/config) 
08:14:33 <jethr0> vincenz: hmm, easies would likely be to artifically go through your own proxy always, but that's an evil hack
08:14:44 <Lemmih> JaffaCake: I would love to fix it but the Makefile looks like voodoo to me.
08:14:51 <vincenz> jethr0: and then have this proxy retarget
08:15:04 <JaffaCake> Lemmih: allow me to stick pins in it, then :)
08:15:15 <jethr0> just as an idea...
08:15:22 <vincenz> basically at work we uses this ugly shellscrip
08:15:30 <vincenz> that connects to a certain port and then passes all data to it
08:15:34 <vincenz> well not shellscript, a perl script
08:15:42 <jethr0> hmm
08:15:51 <jethr0> what data?
08:15:52 <vincenz> but that I only use for ssh
08:16:02 <vincenz> for firefox I just set the proxy
08:16:12 <SimonRC> ... but the trick is to cram all the data into one copy of the datastructure.
08:16:59 <vincenz> jethr0: it's a pl scriipt to be used for ProxyCommand for .ssh/config
08:18:21 <jethr0> vincenz: for http the system-wide proxy in /etc/profile should do: http_proxy=http://proxy.mydomain.com:8080/
08:18:32 <vincenz> jethr0: yeah
08:18:43 <vincenz> but that doesn't hold for synaptic
08:18:45 <vincenz> or firefox
08:18:46 <JaffaCake> Lemmih: I think I've fixed the Main thing
08:19:18 <jethr0> yes, that's why i suggested setting up your own proxy, putting everything through there and switching its config centrally
08:19:27 <vincenz> jethr0: right
08:19:38 <vincenz> jethr0: what about software that has no proxy setting
08:19:42 <vincenz> like for instance gobby
08:20:59 <Lemmih> JaffaCake: Can you fix hschooks.o too? And why is it located under the parser/ folder?
08:21:36 <JaffaCake> Lemmih: hmm, i'll look at that
08:21:43 <JaffaCake> it's under parser/ for very historical reasons
08:22:01 <dcoutts> JaffaCake, well with darcs it's easy to move stuff about :-)
08:22:04 <JaffaCake> we used to have various C files under parser/, hschooks.c is the last one
08:22:09 <jethr0> hmm, that goes far beyond your initial question :). that will get arbitrarily complicated. maybe use a virtual host as standard gateway and let it solve the problems
08:22:27 <JaffaCake> dcoutts: yes, I can't wait to start shifting stuff around when we finally make the switch to darcs
08:22:37 <jethr0> or setting up a virtual network interface (tunnel) to a host which doesn't need proxying
08:22:40 <dcoutts> JaffaCake, is the GHC lib going to use heiricharcal names? If not, is it going to be exposed by default?
08:23:14 <JaffaCake> dcoutts: it's not exposed by default, maybe someday we'll switch to using hierarchical names
08:23:19 <dcoutts> JaffaCake, when's the big switch marked "Darcs!" getting flipped?
08:23:30 <JaffaCake> ASAP, I hope
08:23:31 <dcoutts> JaffaCake, ok, I guess that's ok then.
08:23:33 <dcoutts> cool
08:23:45 <vincenz> jethr0: they really should have some software for this, laptops are a current thing
08:24:34 <dcoutts> JaffaCake, if you find you don't like the default style of emails that darcs sends to the commit mailing list then we've got an alternative which can be made to look much like the old cvs emails.
08:24:34 <jethr0> yes, maybe there exists sth like that. i guess the "easiest" would be to create a virtual network interface that forwards everything to a socks proxy
08:25:00 <vincenz> jethr0: it's not a socks proxy
08:25:16 <dcoutts> JaffaCake, I implemented it in a post-apply hook for the gtk2hs repo.
08:25:22 <jethr0> well, to a proxy that can handle arbitrary/most connections/protocols
08:25:35 <jethr0> ls
08:25:44 <dcoutts> Lemmih, so you've been hacking on hIDE recently?
08:25:52 <JaffaCake> dcoutts: sounds good, is it easy to set up?
08:25:53 <vincenz> yeah
08:25:53 <Lemmih> dcoutts: Still can't.
08:26:20 <dcoutts> JaffaCake, yes, pretty easy since I've already done it for the gtk2hs repo on darcs.haskell.org.
08:26:40 <dcoutts> Lemmih, because of GHC API issues?
08:26:40 * JaffaCake goes to take a look
08:26:50 <Lemmih> dcoutts: Yep.
08:26:54 <dcoutts> ndm, long time no see!
08:27:00 <JaffaCake> Lemmih: what would help to get you unstuck?
08:27:10 <ndm> dcoutts, indeed, unfortunately my phd needed some attention
08:27:16 <ndm> but i'm back hacking yhc this afternoon
08:27:21 <dcoutts> ndm, mm, know the feeling.
08:27:22 <Lemmih> JaffaCake: I think you just did most of it (:
08:27:30 <JaffaCake> heh, cool
08:27:39 <dcoutts> ndm, shapr and I were wondering about Yhc + FFI things the other day
08:27:42 <jethr0> vincenz: have you looked at "http://www.faqs.org/docs/Linux-HOWTO/Laptop-HOWTO.html#ss10.2"
08:28:04 <jethr0> i thing divine is configurable, so you might do arbitrary changes to config files or copy them back and forth
08:28:13 <vincenz> cool
08:28:17 <vincenz> I'll look at it, thanks
08:28:27 <jethr0> np
08:28:54 <vincenz> I doubt it does generic proxy however
08:28:58 <ndm> dcoutts, it was half implemented by Tom, then he had to stop and work on a hat virtual machine (phd things once more), i'll ask him for a status tomorrow
08:29:16 <dcoutts> JaffaCake, darcs.haskell.org:/home/darcs/gtk2hs/_darcs/prefs/defaults and darcs.haskell.org:/home/duncan/bin/commit-messages-split.sh
08:29:28 <JaffaCake> dcoutts: so looks like I can just use ~duncan/bin/commit-message-split.sh?
08:29:38 <JaffaCake> yes
08:29:42 <jethr0> vincenz: not by itself, but it finds out which network you are currently in and then let's you run your own scripts
08:29:44 <dcoutts> JaffaCake, right. Or make a copy in case I mess it up :-)
08:29:50 <JaffaCake> good idea
08:29:55 <jethr0> not sure generic proxy exists. would be nice though...
08:29:58 <dcoutts> JaffaCake, you want to change the -v option for -s probably.
08:30:07 <vincenz> jethr0: ah 
08:30:19 <jethr0> sry
08:30:25 <dcoutts> JaffaCake, in the script. -v means show the full patch. -s is summary. More like what you have now.
08:30:35 <JaffaCake> right
08:30:59 <dcoutts> JaffaCake, commit-messages-split.sh line 50 /--verbose/--summary/
08:31:10 <JaffaCake> is there any reason that script can't be in the repository itself? :)
08:31:21 <dcoutts> JaffaCake, it probably can be.
08:31:41 <dcoutts> JaffaCake, the only thing that can't is the .current-hash file.
08:31:59 <dcoutts> ndm, ok. Thanks.
08:32:21 <ndm> dcoutts, have you started on teh work to make Gtk2Hs compile without -fglasgow-exts ?
08:32:33 <dcoutts> ndm, the thing we really wanted to know is if we can do truely portable FII or if we need to compile FFI stubs on each arch.
08:32:39 <Lemmih> JaffaCake: Is filtering out unwanted object files really the right way to go?
08:32:40 <dcoutts> ndm, I've been looking at it yes.
08:33:00 <ndm> dcoutts, libffi may work for all gcc targets - so we might be able to get that working
08:33:01 <JaffaCake> dcoutts: it'd be nice to have a link in the commit mail that takes you to the patch itself on darcsweb
08:33:06 <dcoutts> ndm, I've got an alternative class representation that is Haskell98 rather than using unsafeCoerce# :-)
08:33:08 <vincenz> data Card = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | J | Q | K
08:33:13 <vincenz> I take iti that won't work
08:33:14 <vincenz> :P
08:33:19 <dcoutts> JaffaCake, yeah, that'd be nice.
08:33:25 <ndm> but we'd then need to assembly code for Windows
08:33:45 <Cale> vincenz: yeah, you have to give them names starting with an uppercase letter
08:33:45 <dcoutts> ndm, because?
08:33:49 * vincenz nods
08:34:02 <ndm> dcoutts, because visual studio doesn't have libffi, its very internally tied to gcc
08:34:02 <sproingie> vincenz: cards also have suits
08:34:12 <vincenz> sproingie: I have a separate type Suit
08:34:19 <dcoutts> JaffaCake, you put up the darcsweb after I made that script, so I didn't think of it then.
08:34:32 <JaffaCake> sure
08:34:39 * vincenz feels like a stupid newb
08:34:42 <dcoutts> ndm, hmm. So it'd only work for yhc rts built on win32 with gcc.
08:34:47 <sproingie> vincenz: ah, but any one card has both a rank and suit
08:34:56 <jethr0> vincenz: i still think the easiest would be to allow clients to open a tunnel to their gateway and let the gateway push everything through it's proxy
08:35:03 <dcoutts> ndm, mingw's gcc
08:35:21 <ndm> dcoutts, no - it would work on all - we can use libffi on gcc, but we'll have to write asm for the visual studio which is compatible with libffi
08:35:45 <ndm> dcoutts, mingw is horrible - yhc on windows will be a first class port - no mingw at all
08:36:02 <vincenz> jethr0: "their gateway"?
08:36:04 <dcoutts> ndm, mingw is native. You're thnking on cygwin.
08:36:06 <sproingie> mingw isn't so bad. cygwin is a horror.
08:36:15 <dcoutts> ndm, ghc uses mingw's gcc.
08:36:24 <ndm> visual studio is very nice, and i like it
08:36:27 <ndm> so we're sticking to it :)
08:36:40 <xerox> contingent phrase :P
08:36:43 <ndm> its also got a beautiful debugger and some good sanity checking which has caught many bugs
08:36:53 <dcoutts> ndm, right ho :-)
08:37:01 <ndm> mingw is an option, but we really don't want to restrict visual studio out of the picture
08:37:22 <ndm> anyway, i'll probably end up doing the assembly, so we might be able to get a Linux FFI out before that
08:37:26 <vincenz> how do you say that the cards should enable Show and Eq?
08:37:26 <dcoutts> ndm, so we have to build ffi stubs on all arches? or jsut for win32 :-)
08:37:31 <sproingie> long as it isn't C++, any of the compilers can probably play if they want to
08:37:38 <ndm> dcoutts, no ffi stubs ever is the plan
08:37:39 <Cale> vincenz: deriving (Show, Eq)
08:37:44 <dcoutts> ndm, yay!
08:37:50 <jethr0> vincenz: well the machine that allows you access to the net
08:37:51 <vincenz> Cale: cool, I got it right :)
08:38:01 <ndm> dcoutts, whether thats possible is still under debate...
08:38:03 <vincenz> jethr0: gobby for instance has no proxy setting
08:38:14 <dcoutts> ndm, I think it's "mostly" possible
08:38:25 <ndm> we'll do out best...
08:38:41 <ndm> unfortunately everyone has a phd, so time is getting rather squeezed
08:38:44 <dcoutts> ndm, so long as the symbol name is the same on each platform
08:39:00 <ndm> yes - that might be an issue
08:39:02 <dcoutts> ndm, so some C libs which do tricky things with macros might be out
08:39:03 <jethr0> yes, that's why i'd set up a tunnel, push everything through the tunnel and let its other end worry about proxying it... but that's not a very client-sided solution
08:39:13 <ndm> perhaps we can have the symbol name as a variable, rather than a string
08:39:22 <vincenz> woot
08:39:26 <vincenz> so far so good
08:39:33 <ndm> then it can be computed, since we have runtime linking anyway
08:39:49 <ndm> and that might help with your multliple Gtk versions with weird names and locations
08:39:53 <vincenz> is there a haskell paste site?
08:39:58 <vincenz> @hawiki 
08:39:58 <lambdabot> http://www.haskell.org/hawiki/
08:40:04 <jethr0> http://paste.lisp.org/new/haskell
08:40:07 <dcoutts> ndm, the one I know would be a problem for gtk2hs is that on win32 the names of some file access functions have _utf appended to them. We currently use #ifdef Win32 for that.
08:40:15 <vincenz> jethr0: I'll just use a wiki page
08:40:19 <jethr0> hehe
08:40:40 <dcoutts> ndm, but yeah, if there's a runtime solution then it's ok.
08:40:55 <ndm> dcoutts, yeah, that sounds like it wouldn't be too much extra work
08:41:02 <ndm> although it is a modification to the FFI spec
08:41:07 <dcoutts> ndm, we can do #ifdef YHC; if win32 then ... else ...
08:41:16 <ndm> and probably one that GHC would never be able to match :)
08:41:20 <dcoutts> ndm, true.
08:41:32 <vincenz> what
08:41:34 <dcoutts> ndm, is it just calling through a pointer
08:41:37 <vincenz> all pages are immutable!
08:41:45 <ihope> Hmm, immutable
08:41:51 <jethr0> gotta register
08:41:56 <dcoutts> ndm, and the pointer is obtained dynamically by a symbol lookup?
08:42:01 <ndm> dcoutts, i guess so - i know very few details, Tom/Malcolm is the expert on FFI
08:42:07 <dcoutts> ndm, doesn't sounds like an FFI spec change.
08:42:08 <ndm> dcoutts, yep
08:42:24 <ndm> i know little about the spec
08:42:54 <dcoutts> ndm, shapr wants to run gtk2hs progs on his Nokia 770 which uses gtk
08:43:15 <dcoutts> ndm, ideally he could build them on linux and run the bytecode on the 770
08:43:31 <vincenz> http://www.haskell.org/hawiki/WikiSandBox
08:43:47 <dcoutts> ndm, that'd be the goal anyway. :-)
08:43:59 <ndm> dcoutts, yes - he posted to teh yhc mailing list
08:44:06 <dcoutts> ndm, oh right.
08:44:13 <Cale> vincenz: just log in
08:44:19 <vincenz> Cale:  I did, that's my first edit
08:44:28 <ndm> dcoutts, the gtk port depends on ffi, so i'll try and urge tom along
08:44:33 <Cale> ah, cool
08:44:55 <dcoutts> ndm, I'll hack on makign ghc'isms in gtk2hs optional
08:45:02 <vincenz> isRed Card {suit == Hearts} = True
08:45:04 <vincenz> correct syntax?
08:45:48 <vincenz> ah, single =
08:46:00 <ndm> dcoutts, cool - i'll see if i can hack any of the ffi in, but i doubt it
08:46:03 <Cale> yeah
08:46:19 <vincenz> Cale: that's patternmatching and not creation, right?
08:46:27 <Cale> right
08:46:30 <vincenz> cool
08:46:31 <vincenz> thanks
08:46:39 <vincenz> isBlack = not . isRed :)
08:47:14 <Cale> seeing as they're elements of eq, you can write  isRed card = suit card `elem` [Hearts, Diamonds]
08:47:17 <Cale> hmm
08:47:22 <vincenz> ah
08:47:22 <Cale> @pl isRed card = suit card `elem` [Hearts, Diamonds]
08:47:22 <vincenz> thx
08:47:24 <lambdabot> isRed = (`elem` [Hearts, Diamonds]) . suit
08:47:26 <vincenz> :)
08:47:37 <dcoutts> ndm, you can pinch the assembly needed to support dynamic export from the GHC rts.
08:47:38 <Cale> of course :)
08:47:40 <xerox> indeed!
08:47:44 <vincenz> nifty
08:47:49 <vincenz> alright...what next
08:47:56 <vincenz> adjancency
08:48:11 <ndm> dcoutts, libffi alegedly does it all, without assembly, and hence 100% portable
08:48:16 <vincenz> @pl \x y -> suit x == suit y
08:48:17 <lambdabot> (. suit) . (==) . suit
08:48:19 <dcoutts> ndm, cool!
08:48:28 <xerox> nah
08:48:32 <ndm> dcoutts, one of yhc's major goals is 100% portability
08:48:33 <xerox> @type compare
08:48:35 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
08:48:43 <dcoutts> ndm, I know. :-)
08:48:53 <Cale> vincenz: derive Enum
08:48:57 <ndm> i'm considering adding a file layer on windows, to give unix directories - to get every program running
08:48:59 <vincenz> Cale: rightio
08:48:59 <Cale> then you get succ and pred
08:49:09 <xerox> (compare .) . curry (suit *** suit)
08:49:16 <Cale> xerox: hehe
08:49:21 <xerox> ^_^
08:49:31 <vincenz> @pl \x y -> (suit x == suit y) && ( (succ $ rank $ x) == (rank y))
08:49:32 <lambdabot> ap (ap . ((&&) .) . (. suit) . (==) . suit) ((. rank) . (==) . succ .
08:49:32 <lambdabot> rank)
08:49:34 <vincenz> oy
08:49:35 <dcoutts> ndm, what kind of file layer?
08:49:54 <dcoutts> ndm, windows is actually not too bad, it accepts / as a dir seperator.
08:50:12 <vincenz> @pl \x y ->  ( (succ $ rank $ x) == (rank y))
08:50:13 <lambdabot> (. rank) . (==) . succ . rank
08:50:18 * vincenz wrinkles
08:50:26 <vincenz> @type ***
08:50:27 <lambdabot> parse error on input `***'
08:50:32 <ndm> dcoutts, to handle the c:\ thing, report it as /C/ if a flag is specified
08:50:33 <vincenz> @hoogle ***
08:50:33 <lambdabot> Control.Arrow.(***) :: Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
08:50:54 <vincenz> > isRed Card {suit == Hearts} = True
08:50:55 <lambdabot>  parse error on input `=='
08:50:59 <SamB> @type (Control.Arrow.***)
08:51:00 <vincenz> > (suit *** suit)
08:51:01 <lambdabot> forall (a :: * -> * -> *) c' c b' b.
08:51:01 <lambdabot> (Control.Arrow.Arrow a) =>
08:51:01 <lambdabot> a b c -> a b' c' -> a (b, b') (c, c')
08:51:01 <lambdabot>  Not in scope: `suit'
08:51:02 <xerox> vincenz: the Arrow (->) instance defines *** as: (f *** g) (x,y) = (f x,g y)
08:51:07 <vincenz> aha
08:51:08 <vincenz> thx
08:51:15 <dcoutts> ndm, a right.
08:51:20 <xerox> vincenz: and &&& as (f &&& g) x = (f x,g x)
08:51:30 <vincenz> hmm
08:51:37 <xerox> vincenz: you also get first f (x,y) = (f x,y) and second f (x,y) = (x,f y).
08:51:45 * vincenz nods
08:52:22 <vincenz> adjacent x y = first succ $ (suit *** suit) $ (,)
08:52:28 <vincenz> now just a compare
08:52:43 <vincenz> @type curry
08:52:44 <lambdabot> forall c b a. ((a, b) -> c) -> a -> b -> c
08:52:49 <gour> ndm: where can i see more about libffi?
08:52:59 <ndm> @google libffi
08:53:00 <lambdabot> http://sources.redhat.com/libffi/
08:53:04 <vincenz> @type compare
08:53:05 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
08:53:12 <gour> ndm: ta
08:53:14 <ndm> gour, i don't have any definative reference on it
08:53:19 <vincenz> adjacent x y =  decurry compare . curry (first succ $ (suit *** suit) $ (,))
08:53:23 <vincenz> that seem good?
08:53:35 <vincenz> > adjacent x y =  decurry compare . curry (first succ $ (suit *** suit) $ (,))
08:53:36 <lambdabot>  parse error on input `='
08:53:44 <vincenz> > decurry compare . curry (first succ $ (suit *** suit) $ (,))
08:53:45 <lambdabot>  Not in scope: `suit'
08:53:57 <vincenz> > let suit = id in decurry compare . curry (first succ $ (suit *** suit) $ (,))
08:53:58 <lambdabot>  Not in scope: `decurry'
08:54:04 <vincenz> > deCurry
08:54:05 <lambdabot>  Not in scope: `deCurry'
08:54:24 <vincenz> @pl decurry compare . curry (first succ $ (suit *** suit) $ (,))
08:54:24 <lambdabot> decurry compare . curry (first succ ((suit *** suit) (,)))
08:54:49 <vincenz> where is decurry
08:54:53 <vincenz> @hoogle decurry
08:54:54 <lambdabot> No matches found
08:54:58 <vincenz> @hoogle curry
08:54:58 <lambdabot> Data.Tuple.curry :: ((a, b) -> c) -> a -> b -> c
08:54:58 <lambdabot> Prelude.curry :: ((a, b) -> c) -> a -> b -> c
08:54:58 <lambdabot> Data.Tuple.uncurry :: (a -> b -> c) -> (a, b) -> c
08:55:18 <vincenz> > let suit = id in uncurry compare . curry (first succ $ (suit *** suit))
08:55:19 <lambdabot>   Expecting a function type, but found `b'
08:55:19 <lambdabot>   Expected type: a -> (b, b)
08:55:19 <lambdabot>   Inferred type: a -> b1 -> c
08:55:22 <gour> vincenz: is decurry some ocaml-ism?
08:55:41 <vincenz> > let suit = id in (uncurry compare) . curry (first succ $ (suit *** suit))
08:55:42 <lambdabot>   Expecting a function type, but found `b'
08:55:42 <lambdabot>   Expected type: a -> (b, b)
08:55:42 <lambdabot>   Inferred type: a -> b1 -> c
08:55:57 <vincenz> @type curry (first succ $ (id *** id))
08:55:59 <lambdabot> Not in scope: `first'
08:55:59 <lambdabot>  
08:55:59 <lambdabot> <interactive>:1:24: Not in scope: `***'
08:56:06 <vincenz> grr
08:56:22 <vincenz> > curry (first succ $ (id *** id))
08:56:23 <lambdabot> Couldn't match `(,)' against `(->)'
08:56:32 <vincenz> why does > accept it and @type doesn't
08:56:57 <xerox> 'cos > doesn't evaluate it?
08:57:07 <vincenz> @hoogle first
08:57:08 <lambdabot> Control.Arrow.first :: Arrow a => a b c -> a (b, d) (c, d)
08:57:08 <lambdabot> Graphics.Rendering.OpenGL.GL.PixelRectangles.PixelStorage.lsbFirst ::
08:57:08 <lambdabot> PixelStoreDirection -> StateVar Bool
08:57:08 <lambdabot> Data.List.deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
08:57:25 <JaffaCake> dcoutts: the commit script works nicely, thanks!
08:57:30 <xerox> > let f = curry fix id return concat ++ - 2 in ()
08:57:32 <lambdabot>   Expecting a function type, but found `(a, b)'
08:57:32 <lambdabot>   Expected type: (a1, b) -> t -> [a]
08:57:32 <lambdabot>   Inferred type: (a2 -> a2) -> a2
08:57:38 <xerox> ...hehe, it does.
08:57:55 <vincenz> @hoogle ****
08:57:56 <lambdabot> No matches found
08:57:56 <vincenz> @hoogle ***
08:57:57 <lambdabot> Control.Arrow.(***) :: Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
08:58:20 <vincenz> > Control.Arrow.(***) id id
08:58:20 <lambdabot>  Not in scope: data constructor `Control.Arrow'
08:58:26 <vincenz> > Control.Arrow.*** id id
08:58:26 <lambdabot>  parse error on input `Control.Arrow.***'
08:58:29 <vincenz> hmm
08:58:34 <vincenz> > (Control.Arrow.***) id id
08:58:35 <lambdabot>  add an instance declaration for (Show ((b, b') -> (b, b')))
08:58:41 <vincenz> oh!
08:58:49 <vincenz> > Control.Arrow.curry (Control.Arrow.***) id id
08:58:50 <lambdabot>  Not in scope: `Control.Arrow.curry'
08:58:57 <vincenz> @hoogle curry
08:58:57 <xerox> > (id *** id) (1,2)
08:58:58 <lambdabot> Data.Tuple.curry :: ((a, b) -> c) -> a -> b -> c
08:58:58 <lambdabot> Prelude.curry :: ((a, b) -> c) -> a -> b -> c
08:58:58 <lambdabot> Data.Tuple.uncurry :: (a -> b -> c) -> (a, b) -> c
08:58:59 <lambdabot> (1,2)
08:59:07 <vincenz> > curry ((Control.Arrow.***) id id)
08:59:08 <lambdabot>  add an instance declaration for (Show (a -> b -> (a, b)))
08:59:10 <xerox> > curry (id *** id) $ 1 2
08:59:12 <lambdabot>  add an instance declaration for (Show (b -> (a, b)))
08:59:13 <vincenz> so far so good
08:59:44 <vincenz> > (curry (id *** id)) $ 1 2
08:59:45 <lambdabot>  add an instance declaration for (Show (b -> (a, b)))
08:59:50 <vincenz> > (curry (id *** id)) $ 1 2 3
08:59:51 <lambdabot>  add an instance declaration for (Show (b -> (a, b)))
08:59:54 <vincenz> odd
09:00:13 <vincenz> > uncurry compare
09:00:15 <lambdabot>  add an instance declaration for (Show ((b, b) -> Ordering))
09:00:47 <Lemmih> JaffaCake: Is it imporant to define 'ghc_strlen', 'ghc_memcmp' and 'ghc_memcmp_off' in parser/hschooks.c? Can't 'strlen' and 'memcmp' be used directly?
09:01:26 <JaffaCake> Lemmih: we had problems with those functions being inlined by gcc, and causing gcc to require too many registers on x86
09:02:34 <vincenz> @pl \x y -> (x == y) && (x <> y)
09:02:35 <Lemmih> Oh, OK. I'll move them to another file for now.
09:02:35 <lambdabot> ap (ap . ((&&) .) . (==)) (<>)
09:03:03 <vincenz> @hoogle ap
09:03:04 <lambdabot> Control.Monad.ap :: Monad m => m (a -> b) -> m a -> m b
09:03:04 <lambdabot> Data.Graph.Inductive.Query.ArtPoint.ap :: Graph gr => gr a b -> [Node]
09:03:04 <lambdabot> Control.Arrow.app :: ArrowApply a => a (a b c, b) c
09:03:37 <dcoutts> Lemmih, these symbols cause problems because it causes clashes when the GHC package is loaded in ghci?
09:04:04 <vincenz> anyone have any suggestions for
09:04:06 <vincenz> adjacent x y =  ((suit x) == (suit y)) &&  curry (uncurry compare . (first succ . (rank *** rank))) x y
09:04:34 <xerox> urgh.
09:04:41 <vincenz> yah
09:04:56 <vincenz> basically suit x == suit y.... and succ (rank x) == rank y
09:05:12 <jethr0>  vincenz: can't you use the fact that the cards are an Enum?
09:05:16 <vincenz> jethr0: and
09:05:24 <vincenz> cards aren't enum
09:05:26 <vincenz> only ranks are
09:05:58 <jethr0> well, substract them from each other, "abs" and compare with "1". or am i not making sense?
09:06:12 <vincenz> that's what I'm doing for the rank
09:06:27 <jethr0> uhu
09:07:47 <tromp_> writing the next poker world champion, guys?
09:08:51 <jethr0> "(==1) . abs . ((fromEnum x) - (fromEnum y))" or sth...
09:09:08 <jethr0> "(==1) . abs . ((fromEnum $ rank x) - (fromEnum $ rank y))" or sth...
09:13:30 <jethr0> vincenz: didn't mean to annoy you; never mind
09:15:48 <vincenz> sorry
09:15:50 <vincenz> was afk
09:15:58 <jethr0> np
09:16:07 <vincenz> anyone know any matlab code parsing tools
09:16:15 <vincenz> adj x y = (succ x) == y
09:16:22 <jethr0> are you sure you don't want "==" instead of "compare" above?
09:16:32 <vincenz> I do
09:16:36 <vincenz> someone pushed me to compare :)
09:16:40 <jethr0> ah
09:16:52 <vincenz> adjCard x y = adj (rank x) (rank y)
09:17:06 <vincenz> @pl adjCard x y = adj (rank x) (rank y)
09:17:07 <jethr0> yup, looks good
09:17:07 <lambdabot> adjCard = (. rank) . adj . rank
09:17:22 <vincenz> yick
09:17:36 <vincenz> oh!
09:17:43 <vincenz> nm
09:18:05 <vincenz> @pl adjCard x y = (rank x) `adj` (rank y)
09:18:06 <lambdabot> adjCard = (. rank) . adj . rank
09:18:07 <Cale> partially applied composition is usually sort of odd
09:18:36 <jethr0> huh?
09:18:38 <vincenz> adjCard x y = adj (rank x) (rank y) && (suit x) == (suit y)
09:18:57 <Cale> jethr0: as in (. rank) there
09:18:57 <vincenz> blegh
09:19:02 <vincenz> I should define an adjancy class
09:19:07 <Cale> :)
09:19:25 <vincenz> but... not yet sure how
09:19:27 <jethr0> Cale: how can it apply rank AFTER having called "adj"?
09:19:44 <vincenz> jethr0: adj is partially applied
09:19:51 <jethr0> true
09:19:53 <vincenz> then you ( . rank) the second argument
09:19:57 <jethr0> still a bit weird
09:20:03 <vincenz> notice that ( .  rank ) === (.) x rank
09:20:05 <Cale> jethr0: right :)
09:20:12 <vincenz> it's damn ugly
09:20:40 <Cale> vincenz: you shouldn't quite need a new class, you can generally use Enum
09:21:02 <Cale> oh, for Cards
09:21:19 <vincenz> canPlace x y = adj (rank x) (rank y) && (((isRed x) && (isBlack y)) || ((isRed y) && (isBlack x))
09:21:33 <vincenz> any nice cleanup idioms?
09:21:48 <jethr0> differentColors x y = ...
09:22:06 <vincenz> yeah but still
09:22:23 <vincenz> btw, does && bind tigher?
09:22:40 <vincenz> @hoogle xor
09:22:41 <lambdabot> Data.Bits.xor :: Bits a => a -> a -> a
09:22:41 <lambdabot> Graphics.Rendering.OpenGL.GL.PerFragment.Xor :: LogicOp
09:22:41 <lambdabot> Graphics.HGL.Draw.Region.xorRegion :: Region -> Region -> Region
09:22:47 <jethr0> priority 3
09:22:55 <vincenz> I mean than ||
09:22:59 <vincenz> differentColors x y = (isRed x) && (isBlack y) || (isBlack x) && (isRed y)
09:23:18 <vincenz> it's not very succint
09:23:22 <jethr0> && is prio 3, || is prio 2
09:24:28 <vincenz> @pl differentColors x y = (isRed x) && (isBlack y) || (isBlack x) && (isRed y)
09:24:29 <lambdabot> differentColors = ap (ap . ((||) .) . (. isBlack) . (&&) . isRed) ((.
09:24:29 <lambdabot> isRed) . (&&) . isBlack)
09:24:37 <vincenz> hmm...
09:25:02 <jethr0> and today in "guess what this function does"...
09:25:15 <vincenz> @pl differentColors x y = (isRed x) && (not . isRed $ y) || (not .isRed $ x) && (isRed y)
09:25:15 <lambdabot> differentColors = ap (ap . ((||) .) . (. (not . isRed)) . (&&) . isRed) ((
09:25:15 <lambdabot> . isRed) . (&&) . not . isRed)
09:25:19 <vincenz> grr
09:26:01 <vincenz> differentColors x y = (isRed x) && (not . isRed $ y) || (not .isRed $ x) && (isRed y)
09:26:02 <Lemmih> How about 'data Color = Red | Black'? diffColors x y = color x /= color y?
09:26:05 <vincenz> differentColors x y = xor (isRed x) (isRed y)
09:26:16 <vincenz> how do I apply something to multiple inputs
09:26:21 <vincenz> I seem to be seeing that pattern often
09:26:36 <jethr0> dc x y = isRed x != isRed y
09:26:51 <vincenz> good thinking
09:27:09 <vincenz> there ya go
09:28:02 <vincenz> it's always hard to tell the priorities
09:28:05 <vincenz> canPlace x y = adj (rank x) (rank y) && (not . sameColor $ x y)
09:28:26 <jethr0> nice
09:28:30 <vincenz> do I need the ()?
09:28:33 <vincenz> around the not bit
09:28:56 <jethr0> yes, at least because of the "$", i think
09:29:07 <vincenz> and if I removed the $
09:29:42 <jethr0> > True && not True
09:29:42 <vincenz> now for a board
09:29:44 <lambdabot> False
09:29:50 <Saulzar> You'd need to bracket the not . sameColour then
09:30:00 <vincenz> Saulzar: ah thanks, then I prefer the $ solution
09:30:07 <vincenz> but I often have stuff like
09:30:12 <vincenz> f x y && g x y
09:30:18 <vincenz> isn't there a solution to that?
09:30:28 <jethr0> i think func. application binds more
09:30:33 <vincenz> yeah but I mean
09:30:36 <vincenz> (&&) f g 
09:30:37 <vincenz> or something
09:30:55 <vincenz> some way to say "they take the same input"
09:31:00 <vincenz> and then apply something to combine their output
09:31:02 <jethr0> well, with some arrow magic
09:31:07 <vincenz> without using a list and fold
09:31:37 <vincenz> anyways
09:31:38 <vincenz> I gotat run
09:31:46 <vincenz> gotta run home to pick up a bottle for a drink at my promotor's place
09:31:48 <vincenz> thanks for all the help!
09:31:52 <vincenz> I'll be bugging you later tonight
09:31:56 <jethr0> bye
09:32:18 <vincenz> basically the idea however is
09:32:51 <vincenz> (&&) (something f g)  and then you can apply it to as many parameters as you want as long as f and g take the same
09:33:32 <jethr0> well sth like (uncurry (&&)) . curry (f *** g)
09:33:33 <jethr0> or so
09:33:37 <vincenz> yah
09:33:43 <jethr0> but that's ugly
09:33:46 <vincenz> oy
09:33:48 <vincenz> @type ($)
09:33:49 <lambdabot> forall b a. (a -> b) -> a -> b
09:33:55 <vincenz> seems it doesn't work with two params
09:34:05 <vincenz> (not . sameColor $ x y)
09:34:08 <vincenz> doesn't work :/
09:34:10 <vincenz> but I really gotta run
09:34:13 <vincenz> or I'll be late :D
09:34:25 <jethr0> no, because he's trying to apply x to y
09:35:28 <boegel> astrolabe: ping !
09:36:39 <boegel> anyone familiar with PCA/regression in here ?
09:44:11 <SimonRC> aha!
09:44:42 <SimonRC> My problem is that my "shortest" function isn't smart enough
09:45:13 <jethr0> aha
09:45:52 <orbitz> vincenz: yes, . creates a funcitno which takes 1 argument
09:46:26 <orbitz> ((foo 1) . (bar 2)) 5 would work i'd assume
09:47:29 <SimonRC> I was expecting it to return the first element of the list when it wasn't smart enough to know to do that when it could have done.
09:48:44 <jethr0> ??
10:00:07 <Cale> http://vx.hn.org/autoshare/Goishi.svg :)
10:00:40 <Cale> xerox: some freshly inkscaped go stones :)
10:02:50 <Cale> I should probably separate out the parts into separate files.
10:03:42 <Cale> We'll also need a nice wood grain board. That ought to take me some time with the pen tool :)
10:04:15 <gour> Cale: hey, you're serious...
10:04:20 <dcoutts> Cale, xerox, I was working on a mancala board game using cairo. I took some nice hi-res pics of a real board.
10:04:35 <dcoutts> I was having trouble with the AI
10:04:48 * gour wonders why nobody likes fisher chess...
10:05:12 <Cale> gour: as in random starting position?
10:05:40 <gour> Cale: yep, only 960 starting positions :-)
10:06:10 <tromp_> in go you can also re-arrange all your stones at the start of the game:)
10:06:15 <vincenz> > ((+ 1) . (+ 2)) 3
10:06:17 <lambdabot> 6
10:07:03 <vincenz> @hoogle (a -> b) -> (a -> b) -> (a -> (b,b))
10:07:04 <lambdabot> No matches, try a more general search
10:07:08 <gour> Cale: this one works on linux (world-champion) but no native gui - something for dcoutts & cairo
10:07:17 <gour> Cale: http://fruitchess.com/news.htm
10:07:25 <vincenz> @hoogle (b -> b -> b) -> (a -> b) -> (a -> b) -> (a -> b)
10:07:27 <lambdabot> No matches, try a more general search
10:07:44 <vincenz> @hoogle (b -> b -> b) -> [(a -> b)] -> (a -> b)
10:07:45 <lambdabot> No matches, try a more general search
10:08:06 <vincenz> @type foldr1 (+) 
10:08:08 <lambdabot> forall a. (Num a) => [a] -> a
10:08:23 <vincenz> @type foldr1 (&&) . map (ap)
10:08:24 <lambdabot> Not in scope: `ap'
10:08:28 <vincenz> @hoogle ap
10:08:29 <lambdabot> Control.Monad.ap :: Monad m => m (a -> b) -> m a -> m b
10:08:29 <lambdabot> Data.Graph.Inductive.Query.ArtPoint.ap :: Graph gr => gr a b -> [Node]
10:08:29 <lambdabot> Control.Arrow.app :: ArrowApply a => a (a b c, b) c
10:08:34 <vincenz> @type foldr1 (&&) . map (Control.Monad.ap)
10:08:35 <lambdabot>   Expecting a function type, but found `b'
10:08:35 <lambdabot>   Expected type: m (a -> b) -> Bool
10:08:52 <vincenz> @hoogle combine
10:08:53 <lambdabot> Graphics.Rendering.OpenGL.GL.Texturing.Environments.Combine :: TextureFunct
10:08:53 <lambdabot> ion
10:08:53 <lambdabot> Language.Haskell.TH.Lib.combine :: [([(Name, Name)], Pat)] -> ([(Name,
10:08:53 <lambdabot> Name)], [Pat])
10:08:53 <lambdabot> Graphics.Rendering.OpenGL.GL.Texturing.Environments.Combine4 :: TextureFunc
10:08:55 <lambdabot> tion
10:10:15 <vincenz> @pl \fl d -> (ap) fl d
10:10:15 <lambdabot> ap
10:10:34 <vincenz> > Control.Monad.ap [(+) (-)]
10:10:35 <lambdabot>   add an instance declaration for (Show ([a -> a -> a] -> [a -> a -> a]))
10:10:41 <vincenz> > Control.Monad.ap [(+) (-)] 2 3
10:10:42 <lambdabot> Couldn't match `(->) t' against `[]'
10:10:45 <vincenz> > Control.Monad.ap [(+) (-)] [2 3]
10:10:46 <lambdabot>  add an instance declaration for (Num (t -> a -> a -> a))
10:10:46 <lambdabot>   In the list element: 2 3
10:11:00 <vincenz> > Control.Monad.ap [(+) (-)] (&&)
10:11:01 <lambdabot>   Expecting a function type, but found `m a'
10:11:01 <lambdabot>   Expected type: [a -> a -> a]
10:11:01 <lambdabot>   Inferred type: Bool -> Bool -> Bool
10:11:06 <vincenz> > Control.Monad.ap [(+) (-)] (+)
10:11:07 <lambdabot>   Expecting a function type, but found `m a'
10:11:07 <lambdabot>   Expected type: [a -> a -> a]
10:11:07 <lambdabot>   Inferred type: a1 -> a1 -> a1
10:12:00 <vincenz> Is there no way do do something like:  \op fl d = (apply op to the list obtained by applying each f in fl to d)
10:12:34 <vincenz> or more plainly
10:12:48 <Cale> what's the type of the function you want?
10:13:05 <vincenz> Cale: [(a->b)] -> a -> [b]
10:13:20 <vincenz> or possibly
10:13:33 <vincenz> [(a->b->c)] -> a -> b -> [c]
10:13:42 <vincenz> (and all other metainstantiations)
10:13:56 <Cale> map ($ x) fs
10:13:59 <vincenz> tho that could be done by a repeated
10:14:20 <Cale> @pl \fs x -> map ($ x) fs
10:14:21 <lambdabot> flip (map . flip id)
10:14:22 <tromp_> op list arg = map ($ arg) list
10:14:38 <SamB> what is "swing" again?
10:14:54 <vincenz> > flip (map . flip id) [(+) (*)] 1
10:14:55 <lambdabot>  add an instance declaration for (Num (a -> a -> a))
10:15:01 <vincenz> > flip (map . flip id) [(+) (*)] $1
10:15:02 <lambdabot>  add an instance declaration for (Num (a -> a -> a))
10:15:07 <dcoutts> hia SyntaxNinja 
10:15:22 <dcoutts> much Cabal goings on again :-)
10:15:29 <vincenz> > map ($ x) [(+)]
10:15:30 <lambdabot>  Not in scope: `x'
10:15:39 <vincenz> > (\x -> map ($ x) [(+)] ) 1
10:15:40 <lambdabot>  add an instance declaration for (Show (a -> a))
10:15:50 <Cale> swing :: (((a -> b) -> b) -> c -> d) -> c -> a -> d
10:15:50 <Cale> swing f c a = (f ($ a)) c
10:16:24 <dcoutts> SyntaxNinja, I feel we dump our general complaints on your plate too much. Sorry about that.
10:16:27 <vincenz> let comb fs x = map ($ x) fs in comb (comb [(+) (*)] 1) 2
10:16:29 <Cale> > let swing f c a = (f ($ a)) c in swing map [(*2), (+5)] 16
10:16:31 <lambdabot> [32,21]
10:16:32 <vincenz>  >let comb fs x = map ($ x) fs in comb (comb [(+) (*)] 1) 2
10:16:50 <Cale> why are you applying (+) to (*) ?
10:16:54 <vincenz> 1 and 2
10:16:55 <jethr0> ls
10:16:56 <Cale> are you missing a comma?
10:16:57 <SamB> > let swing f c a = (f ($ a)) c in swing map ($) [(+1), (*2)] 5
10:16:58 <lambdabot> Couldn't match `t -> t1' against `[b]'
10:17:02 <vincenz>  >let comb fs x = map ($ x) fs in comb (comb [(+), (*)] 1) 2
10:17:24 <vincenz> > let comb fs x = map ($ x) fs in comb (comb [(+), (*)] 1) 2
10:17:25 <lambdabot> [3,2]
10:17:28 <vincenz> woo!
10:17:33 <SamB> > let swing f c a = (f ($ a)) c in swing map ($) 5 [(+1), (*2)]
10:17:34 <lambdabot> Couldn't match `t -> t1' against `[b]'
10:17:47 <vincenz> @pl \x y = comb (comb fs x) y
10:17:48 <lambdabot> (line 1, column 6):
10:17:48 <lambdabot> unexpected "="
10:17:48 <lambdabot> expecting pattern or "->"
10:17:52 <vincenz> @pl \x y -> comb (comb fs x) y
10:17:53 <lambdabot> comb . comb fs
10:18:06 <SamB> @type let swing f c a = (f ($ a)) c in swing map ($)
10:18:07 <lambdabot>   Expecting a function type, but found `t_aHt'
10:18:07 <lambdabot>   Expected type: [a -> b]
10:18:10 <SamB> @type let swing f c a = (f ($ a)) c in swing map
10:18:12 <lambdabot> forall a b. [a -> b] -> a -> [b]
10:18:15 <vincenz> let comb fs x = map ($ x) fs in comb . comb [(+), ($)] $ 1 2
10:18:24 <vincenz> let comb fs x = map ($ x) fs in comb . comb [(+), ($)] 1 2
10:18:38 <SamB> @type let swing f c a = (f ($ a)) c in swing map 5 [(+1), (*2)]
10:18:39 <lambdabot> forall b. (Num [[Integer -> Integer] -> b]) => [b]
10:18:41 <vincenz> let comb fs x = map ($ x) fs in comb . comb [(+), ($)] $ 1 2
10:18:55 <vincenz> > let comb fs x = map ($ x) fs in comb . comb [(+), ($)] $ 1 2
10:18:56 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> b
10:18:56 <lambdabot>   Expected type: (a -> b) -> (a -> b) -> a -> b
10:18:56 <lambdabot>   Inferred type: (a -> b) -> a -> b
10:19:10 <vincenz> > let comb fs x = map ($ x) fs in comb . comb [(+), ($)] 1 2
10:19:11 <lambdabot>   The function `comb' is applied to three arguments,
10:19:11 <lambdabot>   but its type `[a -> b] -> a -> [b]' has only two
10:19:11 <Cale> > let swing f c a = (f ($ a)) c in swing map (swing map [(+), (*)] 1) 2
10:19:13 <lambdabot> [3,2]
10:19:15 <SamB> @type let swing f c a = (f ($ a)) c in swing map [(+1), (*2)]
10:19:17 <lambdabot> forall a. (Num a) => a -> [a]
10:19:18 <vincenz> > let comb fs x = map ($ x) fs in (comb . comb [(+), ($)]) 1 2
10:19:19 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> b
10:19:19 <lambdabot>   Expected type: (a -> b) -> (a -> b) -> a -> b
10:19:19 <lambdabot>   Inferred type: (a -> b) -> a -> b
10:19:20 <SamB> @type let swing f c a = (f ($ a)) c in swing map [(+1), (*2)] 5
10:19:22 <lambdabot> forall a. (Num a) => [a]
10:19:35 <vincenz> @type let comb fs x = map ($ x) fs in comb . comb
10:19:35 <SamB> Cale: oh, you've got it?
10:19:36 <lambdabot>   Expecting a function type, but found `b'
10:19:36 <lambdabot>   Expected type: [a1 -> b1] -> [a -> b]
10:19:58 <SamB> vincenz: Cale has it
10:20:09 <Cale> > let swing f c a = (f ($ a)) c in swing map (swing map [(+), (*)] 1) 2
10:20:11 <lambdabot> [3,2]
10:20:49 <vincenz> @pl \fs a b -> swing map (swing map fs a) b
10:20:50 <lambdabot> (swing map .) . swing map
10:20:55 <vincenz> :)
10:21:15 <vincenz> > let swing f c a = (f ($ a)) c in (swing map  .) . swing map [(+)] 1 2
10:21:16 <lambdabot> Couldn't match `t -> a2 -> a1 -> [a -> b]' against `[b1]'
10:21:24 <vincenz> let swing f c a = (f ($ a)) c in (swing map  .) . swing map [(+)] $ 1 2
10:21:27 <vincenz> > let swing f c a = (f ($ a)) c in (swing map  .) . swing map [(+)] $ 1 2
10:21:28 <lambdabot> Couldn't match `a1 -> [a -> b]' against `[b1]'
10:21:33 <vincenz> same error as I got
10:21:44 <vincenz> let swing f c a = (f ($ a)) c in (swing map  .) . swing map $ [(+)] 1 2
10:21:51 <Cale> @type let swing f c a = (f ($ a)) c in swing zipWith
10:21:52 <lambdabot> forall a b c. [a -> b -> c] -> a -> [b] -> [c]
10:21:55 <vincenz> > let swing f c a = (f ($ a)) c in (swing map  .) . swing map $ [(+)] 1 2
10:21:55 <SamB> Cale: ooh!
10:21:56 <lambdabot>   The function `[(+)]' is applied to two arguments,
10:21:56 <lambdabot>   but its type `[a]' has none
10:22:10 <SamB> I that is a nice "comparing" function you have
10:22:10 <Cale> @type let swing f c a = (f ($ a)) c in swing any
10:22:12 <lambdabot> forall a. [a -> Bool] -> a -> Bool
10:22:35 <SamB> I had been thinking that that function would be nice
10:22:40 <vincenz> still not working
10:22:51 <Cale> vincenz: what are you trying to do?
10:22:54 <sieni> hmm... parser combinators are cool
10:23:01 <vincenz> let swing f c a = (f ($ a)) c in (swing map  .) . swing map $ [(+)] 1 2
10:23:05 <Cale> sieni: they sure are :)
10:23:13 <vincenz> Cale: put all the stuff with swing on the left
10:23:17 <vincenz> so I can jsut repeat it
10:23:29 <SamB> sieni: yupper!
10:23:38 <vincenz> @type let swing f c a = (f ($ a)) c in (swing map .) . swing map
10:23:39 <lambdabot> forall a b a1. [a1 -> a -> b] -> a1 -> a -> [b]
10:23:45 <vincenz> see should work fine
10:23:51 <vincenz> let swing f c a = (f ($ a)) c in (swing map  .) . swing map $ [(+)] 1 2
10:23:55 <vincenz> > let swing f c a = (f ($ a)) c in (swing map  .) . swing map $ [(+)] 1 2
10:23:56 <lambdabot>   The function `[(+)]' is applied to two arguments,
10:23:56 <lambdabot>   but its type `[a]' has none
10:24:00 <Cale> @pl \fs x y -> map (($ y) . ($ x)) fs
10:24:01 <lambdabot> flip (flip . (map .) . flip . flip id)
10:24:15 <SamB> vincenz: take out the $
10:24:26 <vincenz> let swing f c a = (f ($ a)) c in (swing map  .) . swing map  [(+)] 1 2
10:24:30 <Cale> > let comb fs x y = map (($ y) . ($ x)) fs in comb [(+), (*)] 1 2
10:24:30 <vincenz> > let swing f c a = (f ($ a)) c in (swing map  .) . swing map  [(+)] 1 2
10:24:31 <lambdabot> [3,2]
10:24:31 <lambdabot> Couldn't match `t -> a2 -> a1 -> [a -> b]' against `[b1]'
10:24:38 <vincenz> o.O
10:24:43 <vincenz> > let swing f c a = (f ($ a)) c in (swing map  .) . swing map  [(+)] 1 2
10:24:44 <lambdabot> Couldn't match `t -> a2 -> a1 -> [a -> b]' against `[b1]'
10:25:11 <vincenz> Cale: I want to make it arity undependent by just erpeating the swing maps enough times
10:25:29 <vincenz> > let swing f c a = (f ($ a)) c in let mything = (swing map  .) . swing map  in my thing [(+)] 1 2
10:25:30 <lambdabot>  Not in scope: `thing'
10:25:42 <vincenz> > let swing f c a = (f ($ a)) c in let mything = (swing map  .) . swing map  in my mything [(+)] 1 2
10:25:43 <lambdabot>  Not in scope: `my'
10:25:47 <vincenz> grr
10:26:05 <vincenz> aha
10:26:15 <vincenz> so why does it not work with the let my thing
10:26:36 <Cale> you didn't define 'my'
10:26:43 <vincenz> yeah I meant without the my thing
10:26:48 <vincenz> > let swing f c a = (f ($ a)) c in (swing map  .) . swing map  [(+)] 1 2
10:26:49 <lambdabot> Couldn't match `t -> a2 -> a1 -> [a -> b]' against `[b1]'
10:27:00 <vincenz> > let swing f c a = (f ($ a)) c in ((swing map  .) . swing map) [(+)] 1 2
10:27:02 <lambdabot> [3]
10:27:04 <vincenz> ah
10:27:14 <vincenz> that's why Iused the $ but then it trried to do [(+)] 1 2
10:27:28 <Cale> ah, right
10:27:31 <vincenz> @pl ((swing map .) . swing map)
10:27:32 <lambdabot> (swing map .) . swing map
10:27:36 <SamB> why the @pl?
10:27:43 <vincenz> @pl \a b c -> ((swing map .) . swing map) a b c
10:27:44 <lambdabot> (swing map .) . swing map
10:28:05 <vincenz> @type let swing f c a = (f ($ a)) c in let mything = (swing map  .) . swing map
10:28:07 <lambdabot> parse error (possibly incorrect indentation)
10:28:15 <vincenz> @type let swing f c a = (f ($ a)) c in (swing map  .) . swing map
10:28:17 <lambdabot> forall a b a1. [a1 -> a -> b] -> a1 -> a -> [b]
10:28:26 <SamB> @pl ((swing map .) . swing map) a b c
10:28:26 <lambdabot> swing map (swing map a b) c
10:28:30 <vincenz> @type let swing f c a = (f ($ a)) c in (swing map .) . (swing map  .) . swing map
10:28:31 <lambdabot>   Couldn't match `[a -> b]' against `a1 -> [b1]'
10:28:31 <lambdabot>   Expected type: [a2 -> a1 -> b1] -> a2 -> [a -> b]
10:28:35 <vincenz> darn
10:28:53 <vincenz> @type let swing f c a = (f ($ a)) c in ((swing map .) . (swing map) .) . swing map
10:28:54 <lambdabot>   The operator `.' [infixr 9] of a section
10:28:54 <lambdabot>    must have lower precedence than the operand `(.)' [infixr 9]
10:29:12 <vincenz> @type let swing f c a = (f ($ a)) c in (((swing map .) . swing map)) .) . swing map
10:29:13 <lambdabot> parse error on input `)'
10:29:15 <vincenz> doh
10:29:22 <vincenz> I want to expand the pattern to higher stuff
10:29:37 <SamB> @type let swing f c a = (f ($ a)) c in (swing map . swing map)
10:29:38 <lambdabot>   Expecting a function type, but found `b'
10:29:38 <lambdabot>   Expected type: a1 -> [a -> b]
10:30:12 <Cale> @type let swing f c a = (f ($ a)) c in swing . swing swing
10:30:13 <lambdabot> forall a t a1. a1 -> (a -> a1 -> t) -> a -> t
10:30:23 <vincenz> hey how do I get a comb
10:30:24 <vincenz> from swing map
10:30:41 <vincenz> @type let swing f c a = (f ($ a)) c in swing map
10:30:42 <lambdabot> forall a b. [a -> b] -> a -> [b]
10:30:42 <Cale> hm?
10:30:47 <vincenz> I'd like the comb to be swing map
10:30:56 <Cale> um
10:30:58 <Cale> hm?
10:31:10 <Cale> you could let comb = swing map in...
10:31:12 <vincenz> right
10:31:14 <vincenz> but in one thingy
10:31:32 <vincenz> let swing f c a = (f ($ a)) c in let comb = swing map in comb . comb
10:31:38 <vincenz> @type let swing f c a = (f ($ a)) c in let comb = swing map in comb . comb
10:31:39 <lambdabot>   Expecting a function type, but found `b'
10:31:39 <lambdabot>   Expected type: [a1 -> b1] -> [a -> b]
10:31:52 <vincenz> let swing f c a = (f ($ a)) c in let comb = swing map in comb . comb
10:31:56 <tibbe> :t tripple x = 3 * x
10:31:59 <tibbe> @t tripple x = 3 * x
10:32:00 <lambdabot> Maybe you meant: todo todo-add todo-delete topic-cons topic-init topic-
10:32:00 <lambdabot> null topic-snoc topic-tail topic-tell type .
10:32:01 <vincenz> @type let swing f c a = (f ($ a)) c in let comb = swing map in (swing comb) . comb
10:32:02 <lambdabot>   Expecting a function type, but found `[a -> b]'
10:32:02 <lambdabot>   Expected type: ((a -> b1) -> b1) -> b -> t
10:32:06 <vincenz> dum dum dum
10:32:09 <vincenz> still not there
10:32:11 <tibbe> @type tripple x = 3 * x
10:32:12 <lambdabot> parse error on input `='
10:32:25 <tibbe> @type \ x -> 3 * x
10:32:27 <lambdabot> forall a. (Num a) => a -> a
10:32:32 <SamB> @type let swing f c a = (f ($ a)) c; comb = swing map in comb . comb
10:32:33 <lambdabot>   Expecting a function type, but found `b'
10:32:33 <lambdabot>   Expected type: [a1 -> b1] -> [a -> b]
10:32:37 <Cale> @type let triple x = 3 * x in triple
10:32:38 <lambdabot> forall a. (Num a) => a -> a
10:32:57 <vincenz> Cale: see where I'm going...
10:33:03 <vincenz> comb = [a->b] -> a -> [b]
10:33:07 <vincenz> then I'd like to be able to combine em
10:33:08 <SamB> @type let swing f c a = (f ($ a)) c; comb = flip $ swing map in comb . comb
10:33:10 <lambdabot> forall b a b1. a -> [([a -> b1] -> [b1]) -> b] -> [b]
10:33:10 <vincenz> ooh!
10:33:56 <vincenz> @p \fs a b = comb (comb fs a) b
10:33:57 <lambdabot> Maybe you meant: part paste pl pl-resume pointless poll-add poll-close
10:33:57 <lambdabot> poll-list poll-remove poll-result poll-show pretty .
10:34:00 <vincenz> @pl \fs a b = comb (comb fs a) b
10:34:00 <lambdabot> (line 1, column 9):
10:34:00 <lambdabot> unexpected "="
10:34:00 <lambdabot> expecting pattern or "->"
10:34:04 <vincenz> @pl \fs a b -> comb (comb fs a) b
10:34:05 <lambdabot> (comb .) . comb
10:34:17 <vincenz> @pl \fs a b c -> comb (comb (comb fs a) b) c
10:34:18 <lambdabot> (((comb .) . comb) .) . comb
10:34:20 * SimonRC is irritated.
10:34:26 <SamB> SimonRC: yes?
10:34:31 <vincenz> there's gotta be a better way to do that
10:34:36 <vincenz> than those silly .)
10:34:38 <SamB> try some of this lotion
10:35:03 <SimonRC> SamB: my breadth-first-search program just loops if it finds a cycle befor it finds a path
10:35:15 <vincenz> @pl \fs a b c -> ((fs `comb` a) `comb` b) `comb` c
10:35:15 <lambdabot> (((comb .) . comb) .) . comb
10:35:20 <SamB> SimonRC: and you were expecting?
10:35:44 <vincenz> Cale: see what I want?  I just want to get rid of those stupd .)
10:35:49 <SimonRC> SamB: I thought that ghci would be smart enough to evaluate in an order that avoids loops
10:35:56 <vincenz> @hoogle ap
10:35:57 <lambdabot> Control.Monad.ap :: Monad m => m (a -> b) -> m a -> m b
10:35:57 <lambdabot> Data.Graph.Inductive.Query.ArtPoint.ap :: Graph gr => gr a b -> [Node]
10:35:57 <lambdabot> Control.Arrow.app :: ArrowApply a => a (a b c, b) c
10:36:10 <SamB> SimonRC: isn't that impossible?
10:36:12 <SimonRC> vincenz: try writing in J instead
10:36:18 <vincenz> SimonRC: J?
10:36:30 <SimonRC> vincenz: the language
10:36:33 <vincenz> ???
10:36:35 <vincenz> why
10:37:05 <SimonRC> it allows you to various HoF things without anything like Haskell's dots
10:37:18 <jip> is there a fst,snd,thrd for 3 tuplets?
10:37:24 <vincenz> I'm sure there's a way to do it, just that @pl doesn't know of these extra functions to use nisteand of .)
10:37:26 <SimonRC> It's a descendent of APL, so it needs very few maps and folds ether
10:37:27 <Cale> jip: not anymore
10:37:56 <Cale> there used to be fst3, snd3, thd3, iirc.
10:38:02 <jip> Cale: where did they go?
10:38:08 <Cale> removed in Haskell 98
10:38:18 <jip> :'(
10:38:28 <vincenz>  let swing f c a = (f ($ a)) c in let comb = swing map in foldrl (comb) [(+)] [1,2,3]
10:38:36 <jip> Cale: because it makes unreadable code?
10:38:38 <vincenz> > let swing f c a = (f ($ a)) c in let comb = swing map in foldrl (comb) [(+)] [1,2,3]
10:38:40 <lambdabot>  Not in scope: `foldrl'
10:38:46 <vincenz> > let swing f c a = (f ($ a)) c in let comb = swing map in foldr (comb) [(+)] [1,2,3]
10:38:47 <lambdabot>  add an instance declaration for (Show (a -> a -> a))
10:39:04 <Cale> jip: the occasions where one really wants more than pairs are rare anyway
10:39:10 <vincenz> > let swing f c a = (f ($ a)) c in let comb = swing map in foldr (flip comb) [(+)] [1,2,3]
10:39:11 <lambdabot>   Occurs check: cannot construct the infinite type: b = a -> b
10:39:11 <lambdabot>   Expected type: [a -> b] -> a -> [a -> b]
10:39:11 <lambdabot>   Inferred type: [a -> b] -> a -> [b]
10:39:20 <Cale> jip: and usually warrant creating a custom data type
10:39:25 <vincenz> @type fodlr
10:39:26 <lambdabot> Not in scope: `fodlr'
10:39:29 <vincenz> @type folrd
10:39:30 <lambdabot> Not in scope: `folrd'
10:39:31 <vincenz> @type foldr
10:39:32 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
10:39:38 <SamB> @pl (swing map (swing map xs f) g) h
10:39:38 <lambdabot> swing map (swing map xs f) g h
10:39:49 <SamB> @pl f a b c = (swing map (swing map xs a) b) c
10:39:49 <lambdabot> f = swing map . swing map xs
10:40:07 <vincenz> hmm
10:40:09 <vincenz> foldr doesn't work
10:40:15 <SamB> @pl f a b c = swing map (swing map (swing map xs a) b) c
10:40:16 <lambdabot> f = (swing map .) . swing map . swing map xs
10:40:17 <vincenz> tho that's what I want
10:40:35 <SamB> @type \a b c -> swing map (swing map (swing map xs a) b) c
10:40:36 <lambdabot> Not in scope: `swing'
10:40:36 <lambdabot>  
10:40:36 <lambdabot> <interactive>:1:21: Not in scope: `swing'
10:40:48 <SamB> @type let swing f c a = (f ($ a)) c in \a b c -> swing map (swing map (swing map xs a) b) c
10:40:49 <lambdabot> Not in scope: `xs'
10:40:55 <SamB> @type let swing f c a = (f ($ a)) c in \a b c -> swing map (swing map (swing map [] a) b) c
10:40:56 <lambdabot> forall a b a1 a2. a2 -> a1 -> a -> [b]
10:41:00 <vincenz> ((f `comb` a) `comb` b) `comb` c works ... just that fodlr won't allow that
10:41:08 <vincenz> typing system is not strong enough
10:41:26 <Cale> you could use typeclasses to get this varargs like behaviour
10:41:27 <Philippa_> is there no foldr1?
10:41:36 <Cale> @type foldr1
10:41:37 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
10:41:39 <vincenz> Philippa_: the problem is that each intermediate result has a diferent type
10:41:56 <Philippa_> ah, you want the polymorphically-recursive version?
10:42:14 <Philippa_> hrmm. Yeah, that might be worth requesting
10:42:22 <vincenz> f = [(a->b->c)]    f `comb` 1 = [(b->c)] ... (f `comb` 1) `comb` 2 = [Int]
10:42:39 <vincenz> so I'm foldring over my arguments to my list of functions
10:42:57 <Philippa_> except, of course, that getting the relevant list's a bit of a bugger
10:43:15 <Philippa_> there's a bit of a problem with subsumption there - it's okay until there're typeclasses involved
10:43:29 <vincenz> also there's a problem in that if my list of arguments is too long it will no longer work
10:43:34 <vincenz> cause then I'm applying Num to Num
10:44:07 <vincenz> so it's obvious a type system can't hadnel this
10:44:15 <SimonRC> @type comb
10:44:16 <lambdabot> Not in scope: `comb'
10:44:30 <vincenz> @type let swing f c a = (f ($ a)) c in let comb = swing map in comb
10:44:31 <lambdabot> forall a b. [a -> b] -> a -> [b]
10:44:47 <vincenz> @type let swing f c a = (f ($ a)) c in let comb = swing map in (comb .) . comb
10:44:48 <lambdabot> forall a b a1. [a1 -> a -> b] -> a1 -> a -> [b]
10:44:50 <vincenz> :)
10:45:08 <vincenz> but that's just ugly, hence me thinking of foldr, which of course is senseless
10:45:15 <vincenz> I should prolly just curry em
10:45:26 <vincenz> @type curry
10:45:28 <lambdabot> forall c b a. ((a, b) -> c) -> a -> b -> c
10:45:33 <vincenz> @type uncurry
10:45:34 <lambdabot> forall c b a. (a -> b -> c) -> (a, b) -> c
10:45:38 <vincenz> @type uncurry . uncurry
10:45:39 <lambdabot> forall b c a b1. (a -> b1 -> b -> c) -> ((a, b1), b) -> c
10:45:55 <SimonRC> eh?
10:45:59 <SimonRC> oh, yeah
10:47:24 <vincenz> > let swing f c a = (f ($ a)) c in let (<<=) = swing map in [(+)] <<= 1 <<= 2
10:47:25 <lambdabot> [3]
10:47:28 <vincenz> :)
10:47:29 <vincenz> much cleaner
10:47:31 * gour noticed that vincenz explores some of the exercises from thompson's book
10:47:37 <vincenz> gour: huh?
10:47:39 <vincenz> what book
10:47:42 <SimonRC> hi
10:47:54 <gour> @google craft of fp
10:47:56 <lambdabot> http://sequence.complete.org/node/47
10:48:22 * vincenz ponders
10:48:29 <vincenz> now the last part
10:48:29 <vincenz> combining the list of results
10:48:43 <vincenz> let swing f c a = (f ($ a)) c in let (<<=) = swing map in foldr1 (+) . [(+), (*)] <<= 1 <<= 2
10:48:51 <vincenz> > let swing f c a = (f ($ a)) c in let (<<=) = swing map in foldr1 (+) . [(+), (*)] <<= 1 <<= 2
10:48:52 <lambdabot>   precedence parsing error
10:48:52 <lambdabot>    cannot mix `(.)' [infixr 9] and `(<<=)' [infixl 9] in the same infix
10:48:52 <lambdabot> expression
10:48:56 <gour> vincenz: http://www.cs.kent.ac.uk/people/staff/sjt/craft2e/
10:49:04 <vincenz> > let swing f c a = (f ($ a)) c in let (<<=) = swing map in foldr1 (+) . ([(+), (*)] <<= 1 <<= 2)
10:49:05 <lambdabot>   Expecting a function type, but found `[b]'
10:49:05 <lambdabot>   Expected type: a1 -> [a]
10:49:05 <lambdabot>   Inferred type: [a2]
10:49:35 <vincenz> @pl \op l a b -> foldr op ( l <<= a <<= b)
10:49:36 <lambdabot> (. (((<<=) .) . (<<=))) . (.) . (.) . foldr
10:49:49 <vincenz> @pl \l a b -> foldr op ( l <<= a <<= b)
10:49:50 <lambdabot> (((foldr op .) . (<<=)) .) . (<<=)
10:49:57 <vincenz> yikes
10:50:05 <vincenz> > let swing f c a = (f ($ a)) c in let (<<=) = swing map in foldr1 (+) ([(+), (*)] <<= 1 <<= 2)
10:50:06 <lambdabot> 5
10:50:11 <Cale> > do f <- [(+), (*)]; return (f 1 2)
10:50:13 <lambdabot> [3,2]
10:50:33 * vincenz grumbles
10:50:40 <vincenz> I like the <<=
10:50:54 <Cale> oh, what are you trying to do now?
10:51:04 <dcoutts> JaffaCake, yay, I've a better haddock patch that's less invasive and works for every kind of top level export.
10:51:10 <vincenz> shit I gotta run
10:51:13 <vincenz> cya later
10:51:17 <Cale> (what's this with the foldr?)
10:51:18 <Cale> oh
10:51:21 <Cale> later
10:51:28 <vincenz> Cale: to combine the results from the different funtions
10:51:31 <dcoutts> JaffaCake, I'll upload the Gtk2Hs example again and darcs send you the patch.
10:51:35 <vincenz> so now I can do something like
10:51:58 <vincenz> hmm
10:52:05 <vincenz> nm
10:52:06 <vincenz> anyawys
10:52:08 <vincenz> bbl
10:52:51 <vincenz> > let swing f c a = (f ($ a)) c in let (<<=) = swing map in foldr1 (&&) ([even, (>5)] <<= 7)
10:52:52 <lambdabot> False
10:52:56 <vincenz> > let swing f c a = (f ($ a)) c in let (<<=) = swing map in foldr1 (&&) ([even, (>5)] <<= 8)
10:52:57 <lambdabot> True
10:53:00 <vincenz> ;)
10:53:23 <vincenz> I like hte <<=
10:53:28 <vincenz> inject a value into a list of fucntiosn
10:55:06 <Cale> @pl \xs v -> xs >>= return . ($ v)
10:55:07 <lambdabot> flip (fmap . flip id)
10:55:17 <Cale> of course.
10:56:09 <Cale> xs <<= v = xs >>= return . ($ v)
10:57:15 <Cale> @type let xs <<= v = xs >>= return . ($ v) in (<<=)
10:57:17 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> a -> m b
10:57:29 <Cale> @type ap
10:57:30 <lambdabot> Not in scope: `ap'
10:57:35 <Cale> @type Control.Monad.ap
10:57:37 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
10:58:22 <Cale> @type (. return) . ap
10:58:23 <lambdabot> Not in scope: `ap'
10:58:30 <Cale> @type (. return) . Control.Monad.ap
10:58:31 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> a -> m b
11:00:55 <Cale> > [(*), (+)] `ap` return 2 `ap` return 3
11:00:56 <lambdabot> [6,5]
11:05:59 <dcoutts> gour, I've improved the haddock wiki stuff, see what you think:
11:06:00 <dcoutts> http://haskell.org/gtk2hs/docs/devel/
11:07:17 <gour> dcoutts: much better
11:07:44 <gour> dcoutts: one remark..
11:08:37 <gour> dcoutts: make a color of 'visited' more distinguishable from the 'active' or normal link
11:09:11 <gour> dcoutts: this is applicable to other (normal) haddock links too
11:09:22 <gour> dcoutts: of course, imho
11:16:26 <araujo> dcoutts, ping!
11:30:26 <dcoutts> araujo, pong!
11:30:57 <dcoutts> gour, hmm, ask someone else about the general link colour. It's not my department.
11:31:13 <dcoutts> gour, I'm only dealing with the wiki links at the moment.
11:31:42 <eivuokko> If anyone is interested, I have written beginnings of a Windows async io library around i/o completion ports. http://darcs.tamelambda.net/repo/win32asio/ It only has (in practice) support for lazily reading files now.  Any comments are appreciated.
11:32:22 <gour> dcoutts: but what do you think about my remark?
11:33:08 <dcoutts> gour, hmm, dunno. Perhaps having the difference be subtle is good. I don't feel stronly about it.
11:33:13 <Lemmih> dcoutts: I'm unstuck. hIDE will continue! whee.
11:33:20 <dcoutts> Lemmih, woot!
11:34:14 <SamB> unstuck?
11:34:38 <dcoutts> Lemmih, well my list/tree/view hacking has been going well too. That was a prerequisite of doing the file/module/thing browser properly. ie generating it on demand and other nify things.
11:35:03 <dcoutts> Lemmih, the new tree/list api is much nicer, see:
11:35:03 <dcoutts> http://haskell.org/gtk2hs/docs/devel/Graphics-UI-Gtk-TreeList-ListStore.html
11:35:31 <dcoutts> no more silly conversions via a generic value
11:37:04 <Lemmih> Looks neat.
11:37:29 <dcoutts> Lemmih, I'm working on the TreeStore now, it's more complex obviously
11:38:39 <dcoutts> Lemmih, but the real point is that we can implement custom models, so the hIDE pages tree would get a TreeModel adapter and could be plugged into a TreeView widget. So there's no need to be restricted by the provided store types.
11:38:57 <dcoutts> http://haskell.org/gtk2hs/docs/devel/Graphics-UI-Gtk-TreeList-CustomStore.html
11:39:27 <dcoutts> that's the low level interface one can implement to get a custom TreeModel
11:47:57 <jip> anyone seen dons or Lemmih?
11:48:28 <Cale> dons is probably asleep
11:48:29 <psnl> ask the bot
11:48:29 * Lemmih looks around.
11:48:34 <Lemmih> Can't see either.
11:49:05 <SamB> Lemmih: look in the mirror!
11:49:57 <jip> Lemmih: hello! have you considered in the SDL bindings removing the "SDL" prefix from the SDLK_LEFT, SDLK_a, SDLK_ESCAPE, etc...?
11:49:58 <Lemmih> Ah, there he is.
11:52:51 <Lemmih> jip: I would gladly accept a patch.
11:53:04 <jip> Lemmih: but do you think it's a good idea?
11:53:28 <jip> the you change the name of all these then you will break all existing programs :(
11:54:12 <Lemmih> We can change it in the unstable branch.
11:54:36 <SamB> existing programs?
11:54:39 <jip> so you think it's a good idea? i think it is because it would make these names consistent with the names of all the other functions
11:54:49 <Lemmih> I don't really use SDLKey much. Char seems easier to handle.
11:55:09 <Lemmih> jip: Yeah, I think it's a good idea.
11:55:20 <jip> well, i like to import your sdl bindings qualified as SDL, and so SDL.SDL_q is kind of redundant
11:55:54 <araujo> arghrrga?!?!
11:56:00 <jip> ok so cool i guess i'll see if i'm capable of making a patch yikes!bbi20min
11:56:05 <SamB> jip: true!
11:56:10 <araujo> Why file recognizes .hs files as Java programms?!?!?!
11:56:22 * araujo almost suffer a heart-attack
11:56:23 <jip> araujo: i've also noticed this
11:56:46 <SamB> araujo: must be the imports or something
11:56:47 <Lemmih> araujo: Because Haskell looks just like Java? (:
11:56:58 <araujo> NO!!!
11:57:03 * araujo not feeling well
11:57:55 <SamB> hmm, I ran it on five here and it decided that two of them were English and three were Java
11:57:56 <araujo> Im writting bindings for libmagic, and this has come out for my surprise.......
11:58:14 <Lemmih> SamB: heh.
11:58:14 <araujo> But.. confusing Haskell with Java!?, that's too much.
11:58:35 <Cale> well, how does it recognise Java?
11:58:42 <araujo> hah
11:58:47 <araujo> as Haskell? :-]
11:58:52 <SamB> araujo: don't expect it to work right on text files
11:58:54 <Cale> my guess is that it's doing less than a full parse
11:59:08 <araujo> much much less.....
11:59:12 <SamB> you should consider yourself lucky if it gets the right encoding
11:59:41 <SamB> Cale: yeah!
11:59:53 <SamB> especially for English
12:00:01 <Cale> hehe
12:00:14 <araujo> well.. files look up the info from a database.....
12:00:16 <SamB> it doesn't exactly do full parses of binary files
12:00:32 <dcoutts> araujo, you could use the freedesktop.org system for mime type recognition, it uses a combination of file extensions and content
12:01:11 <dcoutts> http://freedesktop.org/wiki/Standards_2fshared_2dmime_2dinfo_2dspec
12:01:22 <araujo> dcoutts, oh, btw, wanna asked you, Ptr a works for any kind of pointer right?
12:01:40 <dcoutts> araujo, right Ptr a is polymorphic
12:01:48 <araujo> Ok, correct.
12:02:53 * araujo could 'sed :Java:Haskell:g' the file database too :-]
12:03:33 <dcoutts> araujo, yeah, file is not very good at recognising different kinds of text files
12:03:45 <dcoutts> araujo, for that it's often better to use the file name
12:03:46 <monochrom> The GNOME file manager uses the freedesktop system and correctly shows a lambda icon for Haskell files.
12:04:00 <dcoutts> which is what the freedesktop.org system does
12:04:24 <dcoutts> which is why as monochrom says, Gtk+ file manager recognises Haskell files correctly.
12:04:49 <dcoutts> araujo, here are some implementations of the spec:
12:04:49 <dcoutts> http://freedesktop.org/wiki/Standards_2fshared_2dmime_2dinfo_2dspec#head-978bef7f41fbdc4b40c2deacb294a386c82aae4d
12:05:15 <SamB> it doesn't use the database for text files, araujo 
12:07:38 <araujo> dcoutts, Ok, let me take a look
12:07:48 <araujo> SamB, it doesn't? .. you sure?
12:08:17 <araujo> How did it get the info from text files?
12:09:42 <SamB> araujo: it uses dumb heuristics
12:10:08 <araujo> i see.
12:14:06 <ulfdoz> What means non-overloaded in Terms of Haskell?
12:14:54 <SamB> ulfdoz: where do you see it?
12:17:16 <jlenor1_> hello
12:17:33 <jlenor1_> someone give me a simple example of a polymorphically recursive function
12:18:45 * palomer_ slaps palomer
12:18:53 <SamB> jlenor1_: simple?
12:19:14 <palomer_> yes!
12:20:05 <eivuokko> f you know Parsec: class Foo a where foo :: a -> Parser ()   instance Foo [a] where foo f = many foo >> return ()  or something.
12:20:25 <eivuokko> Err, except that'd need signatures to make sense.  But anyway.
12:21:10 <SamB> I forgot what polymorphic recursion is good for, sorry!
12:21:48 <eivuokko> I'd guess that, flattening container type (list here) or meta-prgramming style ala hlists and stuff are most common examples.
12:22:06 <SamB> well, I mean, apart from in type class members, and that doesn't seem terribly polymorphic to me...
12:22:20 <SamB> hmm, and yeah, HList
12:22:26 <musasabi> Okasaki has many examples of polymorphic recursion.
12:22:58 <SamB> musasabi: oh, true!
12:23:08 <eivuokko> Hmm.  I haven't read that yet.
12:23:12 <SamB> I remember now.
12:23:32 <palomer_> ugh, I hate acroread 
12:23:34 <SamB> like those catenable sequences
12:24:02 <SamB> or weren't they catenable?
12:24:09 <musasabi> data Seq a = Nil | Zero (Seq (a, a)) | One a (Seq (a,a))
12:24:11 <SamB> I don't remember...
12:24:28 <eivuokko> Hmm.
12:24:42 <musasabi> page 144 and onwards
12:24:50 <palomer_> that's a GADT
12:24:51 <SamB> musasabi: stuff sorta like that, yeah
12:25:24 <SamB> eivuokko: based on a digital representation of the length of the sequence, you know
12:25:47 <eivuokko> No, I don't.  Sorry.
12:25:49 <SamB> palomer: actually no
12:26:05 <SamB> its just exceptionally similar to a GADT
12:26:31 <SamB> eivuokko: in little endian
12:27:39 <ulfdoz> SamB: For example sortBy in Data.List, actually every function of .*By
12:29:11 <SamB> ulfdoz: it means that it doesn't use type classes
12:29:50 <SamB> so you pass in the function instead of a dictionary being implicitly passed in
12:34:28 <jip> yay my yampa tetris is progressing :D
12:34:49 <glasser> jip: ooh
12:35:03 <glasser> i'd be psyched to see that
12:35:35 <jip> i'm using sdl for input and opengl for rendering
12:36:12 <Lemmih> Wow, it sounds cool.
12:37:13 <dcoutts> jip, yampa uses opengl?
12:37:16 <mahogny> jip, what are you using for sound/music? are you coding that ground up?
12:37:24 * dcoutts thought it used the HGL
12:37:43 <jip> dcoutts: yampa allows you to use whatever IO you want, only it's "spaceinvaders" example uses HGL
12:38:09 <jip> mahogny: haven't thought about that yet but if i decide to add sound and music then probably sdl
12:38:15 <dcoutts> jip, oh, interesting. How hard is it to add an output layer?
12:38:23 <jip> dcoutts: it's very easy
12:38:32 * dcoutts considers getting yampa to work with cairo/gtk2hs
12:38:39 <dcoutts> jip, nice
12:38:42 <mahogny> jip, I started porting allegro to haskell earlier. much nicer than sdl but currently incomplete. it comes with pretty much all that precoded
12:39:03 <ulfdoz> I see it's usefull. :)
12:39:21 <mahogny> if there is interest from the community, I might finish the allegro port
12:39:37 <sieni> allegro cl? do you have access to the source code?
12:39:44 <jip> mahogny: hm.... allegro was fun for me when i was a beginner but i will probably never use allegro again
12:39:50 <cinema> dcoutts, we are back to the arrow front-end for gtk2hs !
12:39:54 <mahogny> sieni, http://alleg.sf.net
12:40:05 <dcoutts> cinema, indeed!
12:40:11 <mahogny> hrm. wrong url
12:40:25 <cinema> dcoutts, Yampa is the way to go
12:40:25 <jip> dcoutts: only problem with yampa is that it needs control over the main loop
12:40:37 <mahogny> or not. firefox is just being foxy with me
12:40:45 <jip> dcoutts: although it could very easily be modified probably
12:40:51 <dcoutts> jip, that can probably be done with Gtk+
12:41:17 <mahogny> jip, never really understood that. what's sdl so much better at?
12:41:50 <jip> dcoutts: oops, discard that, yampa also has an option where it lets you control the main loop
12:42:02 <dcoutts> ok
12:42:54 <jip> mahogny: sdl has a more consistent and professional api. (and much smaller)
12:43:25 <jip> and i think the sdl implementation is a bit cleaner. it doesn't have all that legacy stuff from dos with tons of video driver code and shit
12:43:36 <palomer_> no examples?
12:44:32 <mahogny> jip, true that I guess. but it means a lot of reinventing the wheel instead. can't wait until allegro 5 comes out :/
12:45:46 <jip> mahogny: allegro definetely has a lot more features and it makes it much easer to get some nice graphics on the screen with only a few lines
12:46:21 <Lemmih> dcoutts: I'm having problems compiling gtk2hs from the darcs repo.
12:46:29 <dcoutts> Lemmih, yes?
12:46:48 <Lemmih> glib/System/Glib/hsgclosure.c:99:0:
12:46:49 <Lemmih>      error: too few arguments to function 'rts_apply'
12:47:02 <dcoutts> Lemmih, ah yes, you're using ghc-6.5
12:47:09 <dcoutts> Lemmih, I've got a patch.
12:47:18 <dcoutts> wait a sec...
12:48:44 <dcoutts> http://haskell.org/~duncan/gtk2hs/hsgclosure.ghc-6.5.c
12:48:55 <dcoutts> replace your glib/System/Glib/hsgclosure.c with the above
12:49:28 <Lemmih> Thanks.
12:49:30 <dcoutts> Lemmih, ghc's C api changed in 6.5, most funcs now take a capaility.
12:49:41 <dcoutts> capaility/capability
12:49:44 <palomer_> grr
12:50:28 <dcoutts> Lemmih, thanks for reminding me about that. I should integrate the 6.5 stuff so that it's automatically used if one builds with 6.5 or later.
12:51:46 <xerox> cajole: wow
12:51:56 <xerox> Woops, I mean, Cale :-)
12:55:35 <xerox> Cale: you did a great work with the white stone.
12:59:25 <jip> is it bad style to have like a function that is more then a page long?
13:00:03 <xerox> Depending on the story it tells, they say it would be good perl style <grin>
13:00:14 <mahogny> jip, long where? not IMO. but it can be hell to debug/find parse errors
13:00:47 <monochrom> Not bad style if the length does not reflect complexity.
13:01:39 <jip> you mean like if it's long because it has a large list of constants or something?
13:01:44 <monochrom> Like if your function takes a tuple of 100000 numbers and computes their sum, it's alright :)
13:02:21 <jip> ok well my function is pretty complex even i can't seem to understand it
13:03:05 <monochrom> Then that's bad, and it's bad beyond just bad style.
13:03:32 <monochrom> Thus, style is seldom the primary concern.
13:03:34 <jip> i know it's bad, but i wanted to know if it's also bad style :)
13:04:47 <Lemmih> dcoutts: gtk/Graphics/UI/Gtk/TreeList/TreeStore.chs:269:10:
13:04:47 <Lemmih>     Not in scope: `mallocTreeIter'
13:05:10 <xerox> dcoutts: is there the svg viewer sourcecode somewhere online?
13:05:23 <dcoutts> Lemmih, oh, sorry, some stuff is not quite in sync. There are major changes in the TreeList stuff going on.
13:05:31 <dcoutts> Lemmih, I'll look into it.
13:05:47 <dcoutts> xerox, http://darcs.haskell.org/gtk2hs/demo/svg/
13:05:58 <xerox> oh-uhm
13:06:29 <xerox> Maybe I just need to darcs pull.
13:06:51 <xerox> Yes.
13:06:57 <dcoutts> :-)
13:08:09 <dcoutts> Lemmih, ah! The reason it's out of sync is because in my tree I've removed TreeStore.chs.pp entriely :-)
13:08:42 <dcoutts> Lemmih, let me roll you a fix...
13:12:02 <jip> man this tetris is killing me :'(
13:12:30 <xerox> jip: what?
13:12:49 <dcoutts> Hmm, if I push a patch that modifies a file which a subsequent and already recorded patch deletes, is that going to cause a conflict?
13:13:36 <jip> xerox: i'm trying to make tetris with yampa
13:13:47 <dcoutts> Lemmih, it might be safer if I send you the patch rather than me pushing it to the main repo. Other wise I fear it'll cause problems for the patches that are waiting in my dev tree.
13:14:21 * jip mumbles something about "this is why you should use subversion" :P
13:14:30 <dcoutts> Lemmih, then you'd need to undo that patch before pulling the big treeview revision
13:14:57 <dcoutts> jip, I'm using darcs which should do at least as well as subversion on something like this.
13:15:08 <Lemmih> dcoutts: Bed time for me. I'll try again tomorrow.
13:15:12 <SamB> dcoutts: hmm?
13:15:22 <jip> when darcs matures a bit more it will be awesome
13:15:22 <dcoutts> I'm just not familiar with how far darcs can commute patches
13:15:33 <dcoutts> jip, mature == ?
13:15:58 <Heffalump> it needs better UI, better performance, and a better conflict-handling mechanism. And to be less buggy.
13:16:02 <SamB> ohhh.
13:16:16 <jip> is faster, uses less memory, and deals with conflicts right
13:16:23 <SamB> dcoutts: you can send it against the main repo
13:16:39 <dcoutts> Heffalump, what do you think about my query? will it cause a conflict?
13:16:45 <SamB> Heffalump: yes!
13:16:45 <SamB> most things need all of those, except for the third one
13:16:53 <Heffalump> how much scrollback do I need to read?
13:17:00 <dcoutts> Heffalump, I'll repeat...
13:17:11 <Heffalump> SamB: most things have a conflict-handling mechanism that is worse than darcs in some ways
13:17:54 <dcoutts> Heffalump, I've got the published tree on darcs.haskell.org. In my private tree I've deleted some files. It turns out that to make the published tree compile we need to change one of those files that is about to be deleted.
13:18:18 <dcoutts> Heffalump, so I'd previously recorded a patch in my private tree that deletes a file
13:18:30 <SamB> Heffalump: I mean, programs in general
13:18:38 <dcoutts> Heffalump, now to fix a build bug for Lemmih I need to modify that file.
13:18:39 <SamB> most programs aren't RCSes
13:18:47 <Heffalump> SamB: ah :-)
13:19:01 <dcoutts> Heffalump, the question is, when I later push my patch that deletes said file, will it cause a conflict?
13:19:04 <Heffalump> dcoutts: ok, those patches will definitely conflict.
13:19:21 <Heffalump> because a file deletion is two patches really: "remove all content", then "delete file"
13:19:27 <dcoutts> Heffalump, right
13:19:32 <Heffalump> and "remove all content" means "remove all content assuming it's what we expect"
13:19:33 <dcoutts> and the contents has changed
13:19:40 <dcoutts> ok, I see.
13:19:45 <Heffalump> but I don't think the merge will be a particular problem.
13:19:49 <Heffalump> You can just redelete the file and rerecord.
13:20:03 <Heffalump> and you won't get exponential mergers down the line, because you won't be layering more stuff on top of this.
13:20:06 <dcoutts> hmm, there are many other changes in my local tree.
13:20:07 <Heffalump> (cos the file is deleted :-)
13:20:35 <dcoutts> in particular I've re-created the file :-) (with a totally new and unrelated implementation)
13:20:41 <Heffalump> ah. Then I'm less sure.
13:20:59 <Heffalump> I was about to say that I'm familiar wiht conflict-handling for file changes, but not for deletes and adds particularly.
13:21:07 <Nanar> how can I cast a Maybe String to String ?
13:21:15 <dcoutts> I'll not push the change to the main repo, I'll send it privately to Lemmih, he'll have to roll it back before pulling next time.
13:21:24 <Heffalump> Nanar: are sure it's not Nothing?
13:21:26 <Heffalump> If so, fromJust
13:21:26 <dcoutts> that'l be ok.
13:21:33 <Heffalump> but that'll throw an exception if it is Nothing
13:21:35 <SamB> @type Data.Maybe.maybe
13:21:36 <dcoutts> Heffalump, thanks.
13:21:36 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
13:21:49 <Nanar> Heffalump: no, but it is only for a test :)
13:23:02 <Heffalump> Nanar: well, fromJust if you don't care, and maybe if you want to provide a default value. Both in Data.Maybe.
13:23:46 <Igloo> fromMaybe is usually nicer than maybe IME
13:23:58 <Nanar> Heffalump: okok, currently I am just learning haskell, geting an exception is not a problem
13:24:41 <ulfdoz>     Probable cause: `length' is applied to too many arguments in the call
13:24:41 <ulfdoz>         (length xs)
13:24:44 <ulfdoz> Ja nee?
13:25:25 <SamB> Igloo: depends what you want to do with it, probably
13:25:39 <Heffalump> @type Data.Maybe.fromMaybe
13:25:41 <lambdabot> forall a. a -> Maybe a -> a
13:25:47 <Heffalump> oh, yes.
13:25:56 <Heffalump> ulfdoz: impressive.
13:26:03 <Heffalump> did you accidentally redefine length?
13:26:17 <ulfdoz> nope, at least I mean the native one.
13:26:33 <Heffalump> and you are definitely getting the native one?
13:28:30 <ulfdoz> It suddenly works, when I comment out the type of the function.
13:29:21 <Nanar> Heffalump: thanks
13:30:33 <Cale> ulfdoz: check the inferred type
13:31:50 <Nanar> Just a question, finally Maybe is way to do in C something like ptr != NULL ?
13:32:07 <SamB> Nanar: sort of
13:32:13 <Cale> Nanar: something like that, only much safer :)
13:32:37 <SamB> its more than that, though, because Nothing /= Just Nothing
13:32:56 <Cale> SamB: in Maybe (Maybe a), you mean?
13:33:11 <Cale> that would be like having an extra level of indirection again :)
13:33:16 <SamB> Cale: yeah
13:33:48 <Nanar> I can't do a :: String; a = Nothing; right ?
13:35:08 <Heffalump> SamB: it's about the same, cos ptr == NULL and *ptr == NULL are not the same thing, if ptr is of type foo**
13:35:09 <Cale> Nanar: right
13:35:31 <SamB> Heffalump: true
13:35:57 <Cale> @type Just "Hello"
13:35:59 <lambdabot> Maybe [Char]
13:36:10 <SamB> only then you have to malloc(sizeof(foo*)) everywhere
13:36:10 <SamB> and free too
13:36:10 <Cale> @type Nothing
13:36:11 <lambdabot> forall a. Maybe a
13:36:44 <Cale> Maybe is a lot safer than plain pointers :)
13:37:18 <Nanar> ptr are nice for poeple who love to play with the memory
13:37:20 <SamB> much nicer looking too
13:37:29 * SimonRC grins at the last 3 paragraphs:  http://people.csail.mit.edu/gregs/ll1-discuss-archive-html/msg03277.html
13:37:37 <SimonRC> ihope: didn't expect to see you here.
13:38:06 <Nanar> but in fact language without ptr have way to do same things easilly whithout getting lot of core dump :)
13:38:18 <SamB> Nanar: which is what Ptrs are for, along with FFI
13:40:36 <Cale> @type Foreign.malloc
13:40:38 <lambdabot> forall a. (Foreign.Storable.Storable a) => IO (GHC.Ptr.Ptr a)
13:45:46 <ulfdoz> arg, BEER! cya tomorrow
13:49:26 * boegel|home pings astrolabe (again)
13:49:39 <astrolabe> hia boegel
13:49:47 <astrolabe> how's things?
13:49:55 <boegel|home> astrolabe: are you identified, I need to ask you some non-Haskell stuff
13:50:05 <boegel|home> astrolabe: busy, but interesting :)
13:50:08 <astrolabe> just a mo
13:50:41 <astrolabe> ok, I'm in.
14:17:39 * araujo finishing his bindings
14:17:51 <dcoutts> good good
14:18:16 <araujo> dcoutts, :-]
14:18:23 <araujo> dcoutts, thanks for your help
14:18:26 <dcoutts> np
14:55:31 <o_Rocky> anyone familiar with backtraking&monads?
14:55:33 <o_Rocky> :P
14:56:14 <ihope> No, but I do know that the IO monad can essentially be ignored if you're using CPS.
14:56:19 <Lor> Someone no doubt is.
14:56:24 <ihope> (getLine >>=)
14:56:31 <Lor> ihope, huh?
14:56:35 <Heffalump> o_Rocky: I'm familiar with the list monad, if that helps.
14:56:55 <Lor> I have implemented a tiny embedded prologish backtracking thingy ages ago.
14:57:07 <o_Rocky> i'm working on MonadState w/IO
14:57:09 <Lor> All right, I have done various backtracking thingies, so I have some idea about them.
14:57:35 <o_Rocky> i need some backtraking technique
14:57:40 <ihope> Lor:
14:57:43 <Lor> Read Hinze's paper.
14:57:46 <ihope> @type (getLine >>=)
14:57:47 <o_Rocky> for a board game
14:57:47 <lambdabot> forall b. (String -> IO b) -> IO b
14:57:58 <ihope> A CPS String, that is...
14:58:09 <Lor> http://citeseer.ist.psu.edu/hinze00deriving.html
14:58:29 <Lor> Is any of this stuff in a common library yet?
14:59:26 <glasser> Cale has a Monad NonDetT, not sure if that's the same thing
14:59:58 <Lor> ihope, right, you can instantiate a monomorphic CPS monad using IO as a return type.
15:00:24 <Lor> Wasn't there some point at which IO in Haskell was done purely with CPS?
15:00:44 <o_Rocky> wtf is CPS?
15:00:52 <tic> continuation passing style.
15:01:13 <Lor> (q.v.)
15:01:13 <tic> and don't do "wtf is XXX", when you can Google it up yourself, and moreover, drop the attitude.
15:02:35 <Lor> Right. CPS is something you should learn if you want to do backtracking.
15:02:51 <Lor> Because backtracking is essentially dropping your current continuation and switching to an older one.
15:03:01 <ihope> omgwtf is bbq?
15:03:05 * SimonRC goes home.
15:03:57 <Nanar> how do I cast a string to a number (like "34") ?
15:03:58 <Cale> glasser: it's not mine -- it's been on the wiki for ages :)
15:04:12 <Cale> > read "34" :: Integer
15:04:13 <lambdabot> 34
15:04:32 <Nanar> Cale: thanks
15:04:34 <glasser> eh, lambdabot should respond to "wtf is XXX" :)
15:04:35 <Cale> Nanar: note that the type signature is usually not necessary if it can be inferred which type is desired
15:04:41 <Lor> It has nothing to do with casting, though.
15:04:59 <Nanar> Cale: read magically understand what I want ?
15:05:07 <Cale> Nanar: yep
15:05:11 <o_Rocky> Nanar: no
15:05:21 <Cale> typeclass magically
15:05:26 <o_Rocky> i have to give it the type you want
15:05:27 <Lor> It does, if the return type can be inferred.
15:05:50 <o_Rocky> never tryed that
15:06:24 <Nanar> in a nutshell, it does if it can ?
15:06:31 <Lor> Yep.
15:06:40 <Nanar> thanks
15:07:10 <Nanar> btw: you know this chan is very newbies friendly ?
15:07:15 <Nanar> :)
15:08:18 <SamB> Nanar: it is all a part of our evil plan
15:08:39 <Nanar> but I think haskell lack of documentation
15:08:58 <ihope> It has the Report!
15:09:00 <Nanar> I mean basic documentation, "how do I do ..."
15:09:09 <ihope> There's #haskell...
15:09:11 <eivuokko> "Cookbook" documentation you mean?
15:09:21 <Nanar> more basic
15:09:48 <Nanar> like "how do I read a number", "how to parse a simple file"
15:10:06 <o_Rocky> thats what makes it the language of choice for discriminating hackers
15:10:15 <Nanar> for example I didn't find any simple do about Maybe/Just
15:10:33 <glasser> Have you found the hierarchical library docs yet?
15:10:39 <Nanar> simple doc
15:10:40 <glasser> They are nice (along with hoogle)
15:10:48 <glasser> I also like the hawiki a lot
15:11:32 <Nanar> yes but for example error message are not easy to parse when you begin
15:11:53 * glasser nods.
15:12:18 <Nanar> I am really thinking to start to write some basic example (not the best) on the wiki
15:12:32 <Cale> aren't there examples in YAHT?
15:12:33 <eivuokko> Please do :)
15:12:55 <Nanar> Cale: url ? the one on haskell.org ?
15:13:12 <Cale> @google yet another haskell tutorial pdf
15:13:14 <lambdabot> http://www.isi.edu/~hdaume/htut/tutorial.pdf
15:13:17 <o_Rocky> Nanar: when did you began learning haskell?
15:13:23 <eivuokko> @where yaht
15:13:23 <lambdabot> http://www.isi.edu/%7Ehdaume/htut/
15:13:34 <Nanar> o_Rocky: begining of the weeks
15:13:45 <o_Rocky> weeks?
15:13:51 <Nanar> -s
15:14:19 <o_Rocky> and you are already progamming with Monads?
15:14:23 <Nanar> I am french, you probably how are french poeple with foreign language ;)) excuse my poor english
15:14:49 <o_Rocky> mine is not very good as well
15:14:50 <Nanar> o_Rocky: when I am have obligation
15:15:00 <Nanar> s/am//
15:16:20 <o_Rocky> why don't you begin with something simpler?
15:16:24 <Nanar> I am thinking for exemple to comment this one http://mandrivafr.pastebin.com/513826
15:16:27 <o_Rocky> some basic functions
15:16:37 <Nanar> and explaining step by step
15:17:16 <Nanar> in this very small programs there are 5 or 6 concept to understand
15:17:30 <Nanar> why text <-
15:17:43 <Nanar> the array (x:xs)
15:17:57 <Cale> hey, you know that you only need parens for grouping, right?
15:18:19 <Nanar> Cale: x:xs is enought ?
15:18:31 <Cale> no, that's got to be grouped
15:18:46 <Cale> http://mandrivafr.pastebin.com/513828
15:19:17 <Nanar> I had doubt :)
15:23:35 <Nanar> o_Rocky: here the thing I am trying to end http://mandrivafr.pastebin.com/513835
15:24:16 <Nanar> o_Rocky: because I need something to do, and interaction with system if often need
15:25:10 <o_Rocky> troubles with parsing?
15:25:28 <Nanar> I finally find a way to do
15:25:54 <Nanar> it is not easy to it in functionnal way when use familiar with perl
15:26:38 <vincenz> re
15:27:19 <o_Rocky> Nanar: i've done one automaton to recon options from command line just like getOpts
15:27:49 <o_Rocky> the tecnique is to do the automaton in the paper...
15:28:05 <o_Rocky> then there are thecniques 
15:28:21 <o_Rocky> that help you put the automaton in haskell
15:28:28 <Nanar> yup
15:29:01 <Nanar> at least, I'd like to create rpm binding for haskell
15:29:10 <Nanar> but later :)
15:29:48 <Nanar> I think haskell can make easier programming of checking software
15:30:09 <Nanar> or dependancies solver
15:30:13 <vincenz> @type \xs v -> xs >>= return . ($ v)
15:30:14 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> a -> m b
15:30:21 <vincenz> aha
15:31:20 <vincenz> @type \xs v2 -> (\v -> xs >>= return . ($ v)) >>= return . ($ v2)
15:31:21 <lambdabot> forall a b a1.
15:31:21 <lambdabot> (Monad ((->) a1), Monad ((->) a)) =>
15:31:21 <lambdabot> (a1 -> a -> b) -> a1 -> a -> b
15:31:27 <vincenz> @pl \xs v2 -> (\v -> xs >>= return . ($ v)) >>= return . ($ v2)
15:31:28 <lambdabot> flip (fmap . flip id) . flip (fmap . flip id)
15:32:07 <vincenz> @type flip (fmap . flip id) . flip (fmap . flip id) . flip (fmap . flip id)
15:32:08 <lambdabot> forall a a1 c.
15:32:08 <lambdabot> (Functor ((->) a1), Functor ((->) a)) =>
15:32:08 <lambdabot> (a -> a1 -> c) -> a1 -> a -> c
15:32:17 <vincenz> @type flip (fmap . flip id) . flip (fmap . flip id)
15:32:18 <lambdabot> forall a a1 c.
15:32:18 <lambdabot> (Functor ((->) a1), Functor ((->) a)) =>
15:32:18 <lambdabot> (a -> a1 -> c) -> a -> a1 -> c
15:32:29 <vincenz> @type (flip (fmap . flip id) . flip (fmap . flip id)) . flip (fmap . flip id)
15:32:30 <lambdabot> forall a a1 c.
15:32:30 <lambdabot> (Functor ((->) a), Functor ((->) a1)) =>
15:32:30 <lambdabot> (a1 -> a -> c) -> a -> a1 -> c
15:32:43 <vincenz> do
15:33:34 <vincenz> @pl \xs v3 -> (\v2 (\v -> xs >>= return . ($ v)) >>= return . ($ v2)) >>= return . ($ v3)
15:33:35 <lambdabot> (line 1, column 17):
15:33:35 <lambdabot> unexpected "\\"
15:33:35 <lambdabot> expecting pattern
15:33:41 <vincenz> @pl \xs v3 -> (\v2 -> (\v -> xs >>= return . ($ v)) >>= return . ($ v2)) >>= return . ($ v3)
15:33:42 <lambdabot> flip (fmap . flip id) . (. ((return .) . flip id)) . (>>=) . flip (fmap .
15:33:42 <lambdabot> flip id)
15:34:23 <vincenz> @type let xs <<= v = xs >>= return . ($ v) 
15:34:24 <lambdabot> not an expression: `let xs <<= v = xs >>= return . ($ v)'
15:34:30 <vincenz> @type let xs <<= v = xs >>= return . ($ v) in (<<=)
15:34:31 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> a -> m b
15:34:37 <vincenz> @type let xs <<= v = xs >>= return . ($ v) in (<<=) . (<<=)
15:34:39 <lambdabot> forall a a1 b.
15:34:39 <lambdabot> (Monad ((->) a), Monad ((->) a1)) =>
15:34:39 <lambdabot> (a -> a1 -> b) -> a -> a1 -> b
15:34:43 <vincenz> @type let xs <<= v = xs >>= return . ($ v) in (<<=) . (<<=) . (<<=)
15:34:44 <lambdabot> forall a a1 b.
15:34:44 <lambdabot> (Monad ((->) a), Monad ((->) a1)) =>
15:34:44 <lambdabot> (a -> a1 -> b) -> a1 -> a -> b
15:35:23 <vincenz> @type let xs <<= v = xs >>= return . ($ v) in \xs v v2 v3-> xs (<<=) v (<<=) v2 (<<=) v3
15:35:25 <lambdabot> forall (m :: * -> *)
15:35:25 <lambdabot>  a
15:35:25 <lambdabot>  b
15:35:25 <lambdabot>  t
15:35:25 <lambdabot> (m1 :: * -> *)
15:35:27 <lambdabot> [20 @more lines]
15:35:39 <vincenz> @type let xs <<= v = xs >>= return . ($ v) in \xs v v2 v3-> xs <<= v <<= v2 <<= v3
15:35:40 <lambdabot> forall (m :: * -> *) a a1 a2 b.
15:35:40 <lambdabot> (Monad m) =>
15:35:40 <lambdabot> m (a -> a1 -> a2 -> b) -> a -> a1 -> a2 -> m b
15:36:03 <vincenz> @pl \xs v v2 v3 -> xs <<= v <<= v2 <<= v3
15:36:04 <lambdabot> ((((<<=) .) . (<<=)) .) . (<<=)
15:36:32 <vincenz> is there a standard idiom for (xs >>= return . ($v))
15:37:21 <vincenz> @type join
15:37:22 <lambdabot> Not in scope: `join'
15:37:27 <vincenz> @hoogle join
15:37:28 <lambdabot> Control.Monad.join :: Monad m => m (m a) -> m a
15:37:28 <lambdabot> Data.PackedString.joinPS :: PackedString -> [PackedString] -> PackedString
15:37:28 <lambdabot> Distribution.Compat.FilePath.joinFileName :: String -> String -> FilePath
15:37:54 <vincenz> @hoogle m (a -> b) -> a -> m b
15:37:56 <lambdabot> Control.Parallel.par :: a -> b -> b
15:37:56 <lambdabot> Control.Parallel.seq :: a -> b -> b
15:37:56 <lambdabot> GHC.Conc.par :: a -> b -> b
15:39:28 <vincenz> that's not right
15:39:28 <Lor> That's almost ap, but not quite.
15:39:28 <Lor> @type Monad.ap
15:39:28 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
15:39:28 <vincenz> > Monad.ap [not] [True]
15:39:28 <lambdabot>  Not in scope: `Monad.ap'
15:39:33 <vincenz> > ap [not] [True]
15:39:35 <lambdabot> [False]
15:39:39 <vincenz> > ap [not, not] [True]
15:39:40 <lambdabot> [False,False]
15:39:43 <vincenz> > ap [not, not] [True, False]
15:39:45 <lambdabot> [False,True,False,True]
15:39:52 <vincenz> yeah
15:39:58 <vincenz> just take m a to be (return a)
15:40:06 <Lor> Right.
15:40:20 * vincenz is learning more haskell :)
15:40:32 <vincenz> so ap is the same as
15:40:56 <vincenz> > f <- [not, not]; d <- [True, False; return (f d)
15:40:57 <lambdabot>  parse error on input `<-'
15:41:02 <vincenz> > do f <- [not, not]; d <- [True, False; return (f d)
15:41:03 <lambdabot>  parse error on input `;'
15:41:11 <vincenz> > do f <- [not, not]; d <- [True, False]; return (f d)
15:41:14 <lambdabot> [False,True,False,True]
15:41:28 <vincenz> @type \fs ds do f <- fs; d <- ds; return (f d)
15:41:30 <lambdabot> parse error on input `do'
15:41:35 <vincenz> @type \fs ds -> do f <- fs; d <- ds; return (f d)
15:41:36 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => m (a1 -> a) -> m a1 -> m a
15:41:43 <vincenz> \o/
15:42:45 <vincenz> @hoogle m (a -> b) -> m a -> m (m b)
15:42:46 <lambdabot> Prelude.asTypeOf :: a -> a -> a
15:42:46 <lambdabot> Control.Parallel.par :: a -> b -> b
15:42:46 <lambdabot> Control.Parallel.seq :: a -> b -> b
15:43:28 <vincenz> asTypeOf 1 2
15:43:32 <vincenz> > asTypeOf 1 2
15:43:34 <lambdabot> 1
15:43:37 <vincenz> what's the use?
15:44:01 <Roboguy> IIRC, it's a restricted version of const
15:44:30 <Lor> @type liftM2 ($)
15:44:31 <lambdabot> Not in scope: `liftM2'
15:44:35 <Lor> @type Monad.liftM2 ($)
15:44:36 <lambdabot> forall b a2 (m :: * -> *). (Monad m) => m (a2 -> b) -> m a2 -> m b
15:44:41 <ihope> !type asTypeOf
15:44:42 <Lor> That's an easier way to define it.
15:44:48 <ihope> @type asTypeOf
15:44:49 <ihope> Heh
15:44:50 <lambdabot> forall a. a -> a -> a
15:45:05 <ihope> > (>>) asTypeOf (>>>)
15:45:07 <lambdabot>  add an instance declaration for (Show (a b c -> a c d -> a b d))
15:45:20 <Lor> Huh?
15:45:22 <ihope> ...Is it just me, or did that work?
15:45:26 <Lor> > (>>>)
15:45:27 <lambdabot>  add an instance declaration for (Show (a b c -> a c d -> a b d))
15:45:29 <ihope> > (>>) `asTypeOf` (>>>)
15:45:31 <lambdabot>  add an instance declaration for (Show (a b b -> a b b1 -> a b b1))
15:45:35 <ihope> There we go.
15:45:43 <Lor> Ah, it defaults to the function arrow.
15:46:01 <Lor> Most confusing.
15:46:10 <Lor> @type (>>>)
15:46:12 <lambdabot> Not in scope: `>>>'
15:46:18 <Lor> @type (Arrow.>>>)
15:46:19 <lambdabot> Couldn't find qualified module.
15:46:19 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
15:46:19 <lambdabot> \\)?
15:46:30 <Lor> @hoogle >>>
15:46:30 <lambdabot> Control.Arrow.(>>>) :: Arrow a => a b c -> a c d -> a b d
15:48:05 <vincenz> @hoogle a -> m a
15:48:07 <lambdabot> Prelude.id :: a -> a
15:48:07 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
15:48:07 <lambdabot> Data.Graph.Inductive.Monad.emptyM :: GraphM m gr => m (gr a b)
15:48:14 <vincenz> is it me or is @hoogle somewhat flawed
15:49:46 <ihope> @type return
15:49:47 <lambdabot> forall (m :: * -> *) a. (Monad m) => a -> m a
15:49:54 <ihope> @djinn a -> m a
15:49:55 <lambdabot> -- f cannot be realized.
15:50:06 <ihope> ...Ah well.
15:53:25 <vincenz> @hoogle forall (m :: * -> *) a. (Monad m) => a -> m a
15:53:26 <lambdabot> hoogle: Unexpected character when parsing: * -> *) a. (Monad m) => a -> m
15:53:26 <lambdabot> a
15:53:26 <lambdabot>  
15:57:48 <Roboguy> Are you looking for something in particular, heh?
16:01:34 <Nanar> thanks all and good night
16:01:39 <Roboguy> G'night
16:06:58 <dons> hmm. what? my chameneos isn't symmetrical? even though it's the same code as the accepted entry... :/
16:11:34 <ihope> Is there a Haskell-related word that rhymes with "strife"?
16:12:08 <ihope> Oh, never mind.
16:15:32 <o_Rocky> can i use mplus with Monad State Transformer?
16:16:17 <ihope> StateTrans?
16:16:42 <Cale> You can if the monad being transformed is a MonadPlus
16:17:34 <ihope> Infix type constructors?
16:31:39 <lispy> what was the .hi file viewer's name again?
16:32:03 <palomer> :o
16:32:28 <lispy> palomer: don't say "cat" ;)
16:32:43 <palomer> "cat"
16:33:17 <lispy> i want to look at the stirctness of a compiled function
16:33:23 <lispy> there is a command for that, but i can't remember it
16:34:14 <cpatrick> ghc --something
16:34:31 <cpatrick> where the value of "something" can be divined from the man page :-)
16:36:22 <lispy> ah, --show-iface
16:36:23 <lispy> thanks
16:37:38 <lispy> oh hm...the function i'm after seems to be inlined, as it's not in the .hi file
16:46:49 <SyntaxNinja> lispy:  is sin http://lambda-the-ultimate.org/
16:46:58 <lispy> is sin?
16:47:11 <lispy> ah
16:47:26 <lispy> if lisp is sin, i am el_diablo
16:52:43 <el_diablo> hmm...
16:53:41 <SyntaxNinja> hmm
16:54:03 <dons> lispy, regarding the strictness, is the function exported?
16:54:10 <dons> otherwise it won't end up in the .hi file
16:54:35 <dons> anyway, check the bit about 'don't guess, look it up' on strictness in the ghc manual
16:56:49 <el_diablo> dons: yes
16:57:29 <el_diablo> dons: i double checked the exportedness when it wasn't in the output of the interface dump
16:59:15 <glauber_sp> hi guys. I'm starting reading about haskell and I didn't found any option in ghci to trace or debug the programs. Do I need a debbuger to do it? Can anyone suggest me one?
16:59:36 <dons> you won't need one, most likely.
16:59:40 <dons> i've ever needed one.
17:00:12 <Pseudonym> In Haskell, you're encouraged to do this:
17:00:22 <Pseudonym> 1. Write small functions.
17:00:26 <Pseudonym> 2. Unit test them.
17:00:27 <glauber_sp> I'm reading "A little intro.. to haskell 98" and I've already read The craft of function programming
17:00:34 <Pseudonym> 3. Use the type system creatively to avoid errors.
17:00:39 <Pseudonym> And if you need to:
17:00:45 <Pseudonym> 4. printf-style debugging is avaiable
17:00:51 <Pseudonym> In the form of Debug.Trace
17:01:15 <el_diablo> IMHO, those are helpful but not a replacement for an interactive debugger
17:01:28 <Pseudonym> Yes, however there's a problem with that in Haskell.
17:01:31 <el_diablo> as dons said, you'll rarely need a debugger, but you might want one sometimes
17:02:01 <Pseudonym> In Haskell, evaluation order is a global property of the program.
17:02:14 <Pseudonym> It has almost nothing to do with the code that you wrote.
17:02:24 <el_diablo> on large imperative projects i've often set break points and run the debugger just to learn program flow and accellerate my understanding.  I wish I had that in haskell.
17:02:26 <Pseudonym> So interactive debuggers don't work so well.
17:02:40 <Cale> I agree with Pseudonym.
17:02:53 <Pseudonym> Here's an example:
17:02:57 <Pseudonym> [ f 1, f 2, f 3 ]
17:03:04 <Pseudonym> Or even better:
17:03:08 <Pseudonym> g f = [ f 1, f 2, f 3 ]
17:03:15 <Pseudonym> In this code, g doesn't call f.
17:03:36 <el_diablo> but couldn't you step through cost-centers or steps in the graph reduction?
17:03:37 <Pseudonym> It sets up thunks, which may or may not be evaluated later.
17:03:41 <glauber_sp> Pseudonym, f will not be evaluated?
17:03:52 <Pseudonym> glauber_sp: Maybe, maybe not.
17:03:55 <Pseudonym> But certainly not inside g.
17:03:55 <Lor> You mean "g is not strict in f".
17:04:09 <Lor> The other way round, sorry.
17:04:12 <Pseudonym> I mean that g does not call f.
17:04:21 <Lor> That doesn't mean anything.
17:04:31 <Cale> exactly :)
17:04:33 <Cale> hehe
17:04:40 <glauber_sp> hum, I've read about the thunks and strict versus lazy eval
17:04:40 <Pseudonym> In the sense that in a traditional imperative debugger, there would be a call stack, with a frame for g, with frames for f underneath them.
17:04:55 <Pseudonym> In Haskell, everything you thought you knew about call stacks doesn't apply.
17:05:31 <glauber_sp> > (^) :: Int -> Int -> Int
17:05:31 <glauber_sp> > x ^ 0 = 1
17:05:31 <glauber_sp> > x ^ (n+1) = x*(x^n)
17:05:33 <lambdabot>  add an instance declaration for (Show (Int -> Int -> Int))
17:05:33 <lambdabot>  parse error on input `='
17:05:33 <lambdabot>  parse error on input `='
17:06:15 <glauber_sp> there is the "problem" I got: this line: > e6 :: Int
17:06:15 <glauber_sp> > e6 = 4^(-2)  -- Notice the behavior of the + pattern on this one
17:06:16 <lambdabot>  parse error on input `='
17:07:02 <ihope> > 4^(-2)
17:07:04 <lambdabot> Exception: Prelude.^: negative exponent
17:07:11 <glauber_sp> produces an error (*** Exception: part10.lhs:(47,1)-(48,19): Non-exhaustive patterns in function ^) but I wanted to see why. I wanted to see how haskell reduced the function
17:07:15 <ihope> @type (^^)
17:07:16 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
17:07:20 <lispy> Pseudonym: hang on tho, would it be possible to write an interactive hook to the graph reducer?
17:07:30 <ihope> > 4^^(-2)
17:07:31 <lambdabot> 6.25e-2
17:07:35 <Pseudonym> I don't know enough about the GHC RTS to answer that question.
17:07:46 <lispy> Pseudonym: fair enough.  I should try to do that.
17:07:57 <Pseudonym> I guess you could step through cost centres.
17:08:01 <Pseudonym> Like you say.
17:08:11 <Pseudonym> But I'm not sure how useful that would be.
17:08:27 <lispy> i think a tool like that could really blow the mind of people that are asking for a debugger, enough so to satisfy their "need" :)
17:08:51 <Pseudonym> I used to think that declarative debugging was the answer, but now I'm not so sure.
17:08:57 <Roboguy> glauber_sp: It is giving you problems because it never reaches the non-recursive case
17:09:14 <Pseudonym> I do find it frustrating that compiler technology always changes, but debugger technology is essentially the same as it has been for 40 year.
17:09:24 <Pseudonym> The user interfaces have gotten better, that's all.
17:09:39 <Cale> Declarative debugging would be good if it was better supported
17:09:51 <Pseudonym> I'm not so sure about that.
17:09:52 <glauber_sp> Roboguy, I got the error, I just wanted to know if there were any tracer or something like it
17:09:57 <Roboguy> Ah
17:10:00 <lispy> Pseudonym: that's not 100% true, have you seen automatic debugging?  hat-delta?
17:10:04 <Pseudonym> Declarative debugging won't help if your data structures are huge or complex.
17:10:09 <glauber_sp> Roboguy, but thanks anyway =-)
17:10:17 <Pseudonym> No, I haven't seen hat-delta.
17:10:54 <lispy> Pseudonym: ah, well it's not "released" yet, but maybe you've heard of delta debugging?
17:11:09 <ihope> Mmh, unsafePerformIO
17:11:17 <Pseudonym> Errr...I think so.
17:11:41 <lispy> it's a form of automatic debugging that requires to program runs.  One which "fails" and one that "passes", it then tries to work through the program states to find places that could have caused the failure (the flaw)
17:12:49 <lispy> it's certainly a neat idea.  Delta debugging was validated using a bug in gcc, it ran over night and reduced 300K lines of code to just 10 places that could have caused the failure.  The actual place of the fault was something like the 2nd or 3rd listed place.
17:12:56 <glauber_sp> I found this in gentoo, I'll try it: http://www.cs.mu.oz.au/~bjpop/buddha/
17:13:21 <Pseudonym> Nice.
17:13:31 <Pseudonym> I do think we could do with a decent coverage analyser.
17:13:36 <Roboguy> lispy: Interesting idea
17:13:49 <glauber_sp> well, I'l go back to the reading stuff. thanks guys =)
17:13:51 <lispy> Pseudonym: yes, i tihnk so as well.
17:14:14 <lispy> Pseudonym: seems like a nice addition to quickcheck.
17:14:32 <Roboguy> Don't think I've heard of delta debugging before.  Hmm
17:15:03 <lispy> http://www.st.cs.uni-sb.de/askigor/
17:15:35 <lispy> i only know about it because i was previously in an HCI research group and it had implications to our research
17:15:54 <lispy> we studied a lot of end-user programming in spreadsheets.
17:16:09 <lispy> cool domain of study in some ways, but i don't like studying HCI
17:16:25 <Roboguy> Ah
17:17:15 <lispy> dons: i finally found that function, it is in the output, it was just hard to spot
17:18:10 <Pseudonym> Oooh!  Oooh!
17:18:25 <Pseudonym> Seminar by Phil Wadler, just over the road!
17:18:33 <Pseudonym> 1st Feb.  Must go.
17:20:16 <dons> anyone have a gentoo box?
17:21:19 <lispy> nope, i run an all debian shop w.r.t linux
17:23:33 <Cale> Someone should write a book about bittorrent and call it "A Million Little Pieces"
17:24:46 <SyntaxNinja> and it should be full of lies.
17:32:11 <tewk> is there a prelude function for (\x -> x:[]) aka (list x ) in scheme ?
17:32:50 <lispy> tewk: are you sure that function you just named does what you think?
17:33:03 <lispy> @pl \x -> x:[]
17:33:04 <lambdabot> return
17:33:06 <Cale> return
17:33:20 <Cale> lambdabot: jinx!
17:33:24 <lispy> heh
17:34:15 <lispy> tewk: i can't speak for scheme, but in lisp you can do (list 1 2 3) ==> (1 2 3)
17:34:29 <palomer> '(1 2 3)
17:34:35 <lispy> and so in that case, i don't think haskell has a direct equivalent
17:34:39 <palomer> or is it ,(1 2 3)
17:34:51 <kpreid_> but his function *is* 1-ary LIST.
17:35:04 <palomer> nono, it's '(1 , 2 3)
17:35:07 <palomer> err
17:35:11 <palomer> '(1 2 3)
17:35:20 <palomer> also (list 1 2 3)
17:35:28 <lispy> '(1 2 3) == (quote (1 2 3))
17:35:44 <kpreid_> 2-ary lisp LIST would be (\x y -> x:y:[]) == (\x y -> [x,y]), etc.
17:35:48 <lispy> the quote is just there to get around the eager evaluation :)
17:36:03 <palomer> oh
17:37:02 <lispy> the output of --show-iface is confusing me
17:38:03 <lispy> http://pastebin.com/513983
17:38:14 <lispy> what is the strictnes sof apply?
17:38:33 <lispy> it seems that empty_markedup_file is misplaced
17:40:28 <lispy> er sorry, i meant to ask about the strictness of applyHunks
17:40:35 <lispy> er, applyHunkLines
17:40:40 * lispy can't say what he means
17:41:02 <lispy> and for that matter, here is the body of that function
17:41:25 <lispy> i guess none of the bodies are present because it's an interface file :)
17:41:36 <tewk> lispy: thanks, and yep mine lambda func above is just 1-ary.  I want a function that will take a singleton and return a list of one element eg x:[]
17:41:37 <rep> she bang she bang
17:43:11 <lispy> (:[]) is probably the most straightforward
17:43:25 <lispy> @type (:[])
17:43:26 <lambdabot> forall a. a -> [a]
17:44:57 <sh10151> infix notation rears its ugly head
17:45:25 <Cale> if you don't like that,  return  also does the trick
17:45:33 <Heffalump> no!
17:45:45 <Heffalump> you'll get horrible error messages and it's completely obfuscated
17:45:54 <Heffalump> unless you really want to be writing monadic code
17:46:35 <Cale> hm? You might get unresolved overloading, but chances are good that something's going to let it know that you want a list.
17:46:38 <lispy> i'd say normally when i need 1-ary list in haskell i just do foo x = [x] sor tof thing
17:47:35 <Cale> > return 1 :: [Integer]
17:47:37 <lambdabot> [1]
17:47:39 <Heffalump> cale: a error message that before would have been "wanted [x] got [[x]]" will turn into unresolved overloading or "wanted [x] got m [x]"
17:47:43 <Cale> > return 1 :: Maybe Integer
17:47:45 <lambdabot> Just 1
17:48:10 <Cale> Heffalump: sure
17:48:11 <lispy> > return 1 :: IO Int
17:48:12 <lambdabot> No IO allowed
17:48:16 <lispy> :(
17:49:01 <Cale> > return 1 2
17:49:03 <lambdabot> 1
17:49:39 <Cale> (that's the reader instance)
17:49:45 <tewk> I like (:[]) I though of that but the infix confused me a little bit. I forgot that (:[]) x  evalutates to x:[] not []:x
17:49:51 <dons> lispy, you compiling with -O ?
17:50:00 <dons> you'll need that to see unfolded bodies in the .hi files
17:50:35 <lispy> dons: i tihnk i'm using something higher than -O, so i should reduce?  I will get the same strictness?
17:51:07 <dons> no, that'll be fine.
17:51:08 <dons> just not -Onot.
17:51:22 <dons> so no one is using gentoo?
17:51:49 <dons> I need a shootout program checked
17:52:28 <triplah> dons: i am
17:52:51 <dons> it runs fine for me on debian, but is timing out on the (faster) gentoo shootout box.
17:52:52 <triplah> lemme know what you want. i'm leaving in a few mins... i'll be back a bit later though
17:52:54 <lispy> dons: did you look at my pastebin?  can you tell from that whan the strictness of applyHunkLines is?  Where do i learn to read the core output?  (other than just the L = Lazy, S = Strict, U = unboxed, ...)
17:53:21 <dons> triplah, download  http://www.cse.unsw.edu.au/~dons/regex-dna.tgz
17:53:32 <dons> compile: ghc -o a A.hs
17:53:41 <dons> then run: time ./a < input.txt
17:53:56 <dons> it should complete in about 30 seconds or so  (depending on cpu power....)
17:54:40 <dons> then if you like, check that the output matches the `expected' file
17:55:34 <triplah> ok compiing
17:55:35 <lispy> oh hm...it is compiled with excatly -O
17:55:41 <triplah> i'm using 64bit ghc btw
17:55:54 <dons> ah. hmm.. 
17:56:00 <dons> that might break things....
17:56:06 <dons> we'll see.
17:56:14 <triplah> seg faulted
17:56:20 <triplah> trip@trip ~/temp/regex-dna $ time ./a < input.txt 
17:56:21 <triplah> Segmentation fault
17:56:23 <dons> ok. that's to be expected.
17:56:33 <lispy> haskell doesn't segfault! ;)
17:56:47 <dons> (I have a binding to regexec in there, which depends on specifc byte offsets to the regex_t struct)
17:56:53 <triplah> a[3918]: segfault at 00002abfab300010 rip 00002aaaaafeebc0 rsp 00007fffffc75908 error 4
17:56:55 <dons> but since I can't use hsc2hs, I have to hand-code them
17:57:07 <triplah> ahh well, 64bit could screw with it, haha
17:57:24 <lispy> "idomatic"
17:57:26 <triplah> ok i have to go
17:57:28 <lispy> er idiomatic...
17:57:29 <triplah> cyas
17:57:41 <dons> yeah, don't worry. i need to either get 32bit box, or find a way to use hsc2hs in the shootout
17:57:41 <ihope> Idiotomatic? *runs*
17:57:57 <dons> hsc2hs is iditomatic, but they don't let us use it.
17:58:10 * lispy nods
17:58:45 <Heffalump> w00t!
17:58:49 <lispy> dons: so i am compiling with -O, but more importantly, where is my strictness annotation for applyHunkLines, is it just missing?  is that possible?
17:59:03 * lispy feels so ignorant
17:59:06 <Heffalump> *Foo> list :: [Int]
17:59:06 <Heffalump> []
17:59:06 <Heffalump> *Foo> list 1 :: [Int]
17:59:06 <Heffalump> [1]
17:59:06 <Heffalump> *Foo> list 1 2 :: [Int]
17:59:08 <Heffalump> [1,2]
17:59:11 <Heffalump> *Foo> list 1 2 3 :: [Int]
17:59:13 <Heffalump> [1,2,3]
17:59:18 <lispy> i'm happy to RTFM, but i don't see it in the ghc manual
17:59:18 <dons> lispy, check the ghc users guide.
17:59:23 <dons> Heffalump, hmm?
17:59:25 <lispy> er...okay....
17:59:42 <lispy> Heffalump: how did you do that?
17:59:51 <Heffalump> -fglasgow-exts, sadly
17:59:52 <dons> check 'faster.html'
18:00:03 <dons> and then grep for 'How do I find out a function's strictness'
18:00:17 <Heffalump> what's the pastebin of choice?
18:00:23 <dons> oh what the hey:
18:00:24 <dons>     Look for your function in the interface file, then for the third field in the pragma; it should
18:00:27 <dons>     say __S <string>. The <string> gives the strictness of the function's arguments. L is lazy (bad),
18:00:31 <dons>     S and E are strict (good), P is ?primitive? (good), U(...) is strict and ?unpackable? (very
18:00:34 <dons>     good), and A is absent (very good).
18:01:18 <dons> dcoutts, you run gentoo 32bit?
18:01:24 <araujo> lisppaste2, help?
18:01:24 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
18:01:36 <lisppaste2> Heffalump pasted "list function" at http://paste.lisp.org/display/15836
18:02:12 <lisppaste2> araujo pasted "polimorph" at http://paste.lisp.org/display/15837
18:02:21 <araujo> Why that doesn't work?
18:02:28 <Igloo> Those docs don't match that output, but the strictness is given after "Strictness:"
18:02:38 <Igloo> (rather than after "__S")
18:03:38 <Igloo> Oh, it looks like that strictness probably applies to something else, actually
18:03:53 <lispy> okay, when i use -ddump-simpl it does put in the strictness for applyHunkLines but not when i look at the output of --show-iface
18:03:56 <Igloo> That's just part of the output, right?
18:04:09 <lispy> Igloo: are you looking at the pastebin?
18:04:13 <Igloo> Yes
18:04:36 <lispy> yeah, that's all i could find pertaining to that function
18:04:52 <Igloo> Paste the whole thing
18:05:31 <araujo> anyone?
18:05:39 <lispy> just a second, here is part of the output from -ddump-simpl http://pastebin.com/514009
18:06:04 <Heffalump> araujo: it doesn't work because your definition of func has type Test, not type F a => a
18:06:22 <Heffalump> if someone came along and made a new instance of F, func wouldn't work for that instance
18:06:42 <Cale> araujo:  func :: Test
18:06:56 <lispy> Igloo: http://pastebin.com/514014
18:07:00 <Cale> araujo: your implementation only works for one instance of the class
18:07:20 <Cale> araujo: (it needs to work for all of them)
18:07:35 <Heffalump> is there an echo in here? :-)
18:08:14 <araujo> mmm....
18:08:25 <Cale> Heffalump: oh, hehe
18:08:25 <lispy> Igloo: so i can't tell if it's the packedstrings or the filecontents that is strict, the two outputs might be contradicting each other or talking about completely different hings
18:08:48 <Cale> (I was reading araujo's paste and not watching the channel when you replied)
18:08:56 <Igloo> lispy: {- Arity: 2 Strictness: SL -} tells your hte stricness
18:09:18 <araujo> mm.. i see
18:09:22 <araujo> Thanks Cale , Heffalump 
18:09:23 <Igloo> lispy: And in the -ddump-core it's the Str: DmdType SL
18:09:31 <Igloo> lispy: Both say the Int is strict, the list is not
18:09:39 <lispy> Igloo: oh, i've been misreading the output then
18:10:12 <Heffalump> so, doesn't anyone like my list function? :-)
18:10:23 <Igloo> Oh, sorry, I misread the type or read the wrong one
18:10:28 <lispy> Igloo: but, it's not just an Int that is strict right?
18:10:36 <Igloo> The list is trict, the fFileContents is not
18:11:09 <lispy> right, so does that mean applyHunkLines forces the computation of the packedstring?
18:11:17 <lispy> or does it work like seq?
18:11:20 <Igloo> No
18:11:34 <Igloo> It's like seq in that it's only talking about WHNF, yes
18:12:11 <lispy> so, i should put a cost-center at applyHunkLines and profile probably?
18:12:28 <Igloo> What are you trying to find out?
18:13:05 <lispy> in my lastest profile it seems that some computation after writing the patch file forces the patch to be held in memory
18:13:15 <lispy> so i'm trying to find out where that is happening
18:14:05 <lispy> i've narrowed it down to applyToPristine or whatever it is called in Record.lhs
18:14:35 <lispy> if i comment that function call out, then it doesn't consume excess memory, so i figure it was a good place to start looking.  It has lead me to this function
18:15:01 <lispy> does that make sense or am i wasting my time and should be looking elsewhere?
18:15:04 <Igloo> Have you ruled out strict parsing when the patch is reread as the cause?
18:15:24 <lispy> no, how can i rule it out?
18:15:34 <lispy> (i thought that's part of what i was doing)
18:16:22 <Igloo> Try looking at just the first line of the reread oatch and see if the memory usage still spikes
18:16:34 <Igloo> (the first line it adds, that is)
18:17:04 <lispy> Igloo: for example, i should modify record so that it writes the patch then looks at the first line and exits?
18:17:05 <Igloo> Either that or just look at the code
18:17:25 <Igloo> Yeah
18:17:29 <lispy> i've tried looking at the code, but i'm too inexperienced
18:18:10 <Igloo> Oh, it might be parameterised by monad now, which could make it a bit trickier to see exactly what's going on
18:20:20 <lispy> do you know off the top of your head how i look at the first line of a patch?
18:21:18 <Igloo> Something along the lines of   case patch of Hunk _ _ _ (x:xs) _ _ _ -> printPS x
18:21:29 <Igloo> But with different function names, numbers of _s etc
18:21:49 <lispy> cool, that will get me in the right direction tho
18:25:08 <cakoose> I have a quick XML task and was hoping to be able to practice my Haskell.  Is there a Haskell XML parsing library that keeps track of source line numbers?
18:25:50 <cakoose> Looking at the data types for HaXML, HXML, and the Haskell XML Toolbox, it doesn't look like any of them track source locations.
18:26:58 <dons> hey, anyone have opinions on putting abstracs of haskell papers (as they appear) in the HWN?
18:33:50 <lispy> Igloo: thanks for your help, running the profile now
18:38:42 <lispy> i have to say, it's pretty impressive to see darcs write a 360mb patch and only consume 350kb
18:42:49 <dons> excellent.
18:47:17 <lispy> according to top it uses a lot more, but that's due to the mmap'ing.  Which as I understand it doesn't really matter since the os can be clever and drop mmap'd pages back to the file on disk
18:53:54 <sproingie> is anyone here able to change passwords on the wiki?
18:55:18 <Korollary> dons: Have you seen the ghc vs gcc arrays post in haskell-ghc-user?
19:04:31 <dons> yep.
19:07:07 <mwc> How can I get rid of these useless parameters here: lcgPeriod mod a i s = take mod $ lcg mod a i s
19:07:51 <palomer> State ?
19:07:53 <mwc> actually, lcgPeriod mod a i s = findPeriod $ take mod $ lcg mod a i s if it makes any difference
19:07:58 <palomer> or Reader?
19:08:14 <mwc> no, lcg is a function of 4 arguments
19:08:21 <mwc> I'd like those last three to be "points free
19:08:25 <sproingie> @pl lcgPeriod mod a i s = take mod $ lcg mod a i s
19:08:27 <lambdabot> lcgPeriod = ap ((.) . (.) . (.) . take) lcg
19:08:55 <mwc> ah, ok... @pl lcgPeriod mod a i s = findPeriod $ take mod $ lcg mod a i s
19:08:58 <sproingie> for being points free, i see a lot of dots
19:09:12 <mwc> maybe I'm using the wrong term
19:09:32 <mwc> I'd like those last three parameters to be implicit in the character of lcg being a function of 4 args. something like
19:09:42 <mwc> lcgPeriod mod a i s = findPeriod $ take mod $ lcg mod
19:10:08 <mwc> but that doesn't choke the compiler
19:10:30 <sproingie> well that's what @pl does, though as you can see its output is somewhat mysterious
19:10:42 <palomer> why does @pl display terms with points?
19:10:43 <sproingie> in fact mod seemed to have disappeared
19:10:46 <mwc> yeah, I'd like to have something that's readable that does the same thing
19:11:19 <Cale> palomer: it doesn't
19:11:44 <samx> trying to understand the class definition of MonadError totally blows my mind each time I try.. Anyone know of any down to earth intro to fundeps, and what ever other stuff it might be using?
19:12:16 <Cale> 'points' in 'points-free' refers to the values on which a function acts
19:12:20 <palomer> @pl lcgPeriod mod a i s = take mod $ lcg mod a i s
19:12:22 <lambdabot> lcgPeriod = ap ((.) . (.) . (.) . take) lcg
19:12:25 <palomer> I see points!
19:12:38 <sproingie> i was making a joke ... i guess palomer was repeating it
19:12:43 <palomer> nono
19:12:45 <palomer> I'm serious
19:12:51 <Cale> The fact that Haskell uses a period to represent composition is irrelevant.
19:13:09 <Cale> The term comes initially from algebraic topologists
19:13:16 <Cale> (as far as I know)
19:13:35 <palomer> oh
19:13:38 <palomer> and what does it mean?
19:13:52 <Cale> the idea is to write functions in a way which doesn't mention the points on which they act
19:14:01 <Cale> that is, in terms of compositions of other functions
19:14:26 <palomer> the points on which they act? eh?
19:14:31 <sproingie> their args
19:14:48 <Cale> You have some function, acting on a space of values
19:14:55 <Cale> the values are called points
19:16:03 <palomer> the inhabitants of the return type?
19:16:04 <sproingie> hm...  what about:   lcgPeriod mod = findPeriod . (take mod) . lcg  
19:16:22 <Cale> the inhabitants of any type
19:16:23 <sproingie> not sure if that works.  my head hurts too much from coughing
19:16:38 <Cale> but here, primarily the input types
19:16:52 <palomer> oh, righto, the input types
19:17:07 <palomer> err, the inhabitants of the input types
19:17:24 <palomer> I thought functions only acted on the inhabitants of the input type
19:17:26 <Cale> \x -> x^2  -- x is the point being acted on, and it's being transformed into its square
19:18:17 <Cale> say, for each point on the real line
19:18:22 <palomer> @pl \x -> x^2
19:18:23 <lambdabot> (^ 2)
19:18:40 <Cale> it removed the mention of x
19:18:45 <palomer> gotcha
19:18:52 <palomer> so in pl form, you can't mention the arguments
19:18:57 <palomer> it'll be of the form blah = blurgh
19:19:01 <Cale> right
19:19:05 <palomer> where blah is a variable you want to bind
19:19:08 <Cale> no lambda terms
19:19:26 <palomer> and no lambda terms
19:19:32 <palomer> how is this always possible?
19:20:01 <Cale> there's enough predefined functions around
19:20:23 <palomer> @pl (\(Just x) -> x)
19:20:24 <lambdabot> (line 1, column 9):
19:20:24 <lambdabot> unexpected "x"
19:20:24 <lambdabot> expecting operator or ")"
19:20:30 <Cale> and after all, there are lots of combinator bases to use
19:20:43 <Cale> but @pl is sneaky and does lots of simplification
19:20:47 <palomer> > (\(Just x) -> x) (Just 5)
19:20:49 <lambdabot> 5
19:21:02 <palomer> why didn't it accept my last query?
19:21:04 <Cale> It also doesn't have a real Haskell parser
19:21:17 <palomer> @pl (\x -> case x of Just y -> y)
19:21:18 <lambdabot> (line 1, column 25):
19:21:18 <lambdabot> unexpected ">"
19:21:18 <lambdabot> expecting variable, "(", operator or ")"
19:21:37 <palomer> ok, how do you transform foo x = bar x ?
19:21:39 <Cale> it doesn't know about case, or lots of other syntax
19:21:41 <palomer> oh, foo = bar
19:21:42 <palomer> righto
19:21:59 <palomer> does it always terminate?
19:22:15 <Cale> in my experience :)
19:22:22 <Cale> I'm not sure
19:22:31 <Cale> I haven't really looked at the algorithm
19:22:37 <Cale> but I suspect that it does
19:23:09 <Cale> one could abstract just about anything into an appropriate combinator applied to a bunch of arguments, and then rewrite the combinator
19:23:23 <Cale> (say an SK-combinator)
19:23:27 <bojohan> @pl \x y z -> (z,y,x)
19:23:27 <lambdabot> flip (flip . flip (,,))
19:23:54 <Cale> @pl \x y z -> x z (y z)
19:23:55 <lambdabot> ap
19:24:16 <Cale> @pl \x y -> x
19:24:17 <lambdabot> const
19:24:30 <palomer> what's (,,) ?
19:24:39 <Cale> > (,,) 1 2 3
19:24:41 <lambdabot> (1,2,3)
19:24:57 <palomer> (,,) 1 2 3 4
19:25:05 <palomer> > (,,) 1 2 3 4
19:25:06 <lambdabot>   The function `(,,)' is applied to four arguments,
19:25:06 <lambdabot>   but its type `a -> b -> c -> (a, b, c)' has only three
19:25:06 <lambdabot>   In the definition of `kdm': kdm = (,,) 1 2 3 4
19:25:08 <palomer> > (,,,) 1 2 3 4
19:25:09 <sproingie> > (,,,) 1 2 3 4
19:25:10 <lambdabot> (1,2,3,4)
19:25:11 <lambdabot> (1,2,3,4)
19:25:22 <sproingie> i lose
19:25:25 <palomer> has anyone ever found a use for (..) ?
19:25:34 <lispy> @type (..)
19:25:36 <lambdabot> parse error on input `..'
19:25:46 <lispy> what is (..)?
19:25:50 <palomer> err, I meant (,,)
19:26:08 <Cale> I hardly ever use triples
19:26:09 <lispy> i've mapped (,) before
19:26:16 <Cale> (,) is useful
19:26:25 <palomer> for example?
19:26:31 <Cale> zip = zipWith (,)
19:27:11 <lispy> i think tuples are more common in ML than in haskell
19:27:20 <Korollary> I don't use triples, either. They get too anonymous. I declare data types instead.
19:27:25 <Cale> If you're declaring instances of classes, you might need to know that the constructor for pairs is called (,) too
19:27:42 <palomer> oh, true
19:28:09 <Cale> that's both the type constructor and the value constructor
19:28:12 <lispy> in ocaml for example, pattern matching can only be used with functions of arity 1 (as near as I can tell) so people use tuples to be able to use more patttern matching
19:29:34 <lispy> if ocaml had the declaritive syntax of haskell, i bet it would be more popular
19:29:51 <lispy> well, declarative syntax and encrouaged curried functions
19:30:09 <Cale> yeah, ocaml has really awkward syntax, which is quite unfortunate
19:33:33 <lispy> Igloo: assuming my printHead :: Patch -> IO () is only requesting the first line of the patch, then the patch parsing needs to be fixed.  Which if that's the case, i'm tempted to just throw it away and start writing the new patch parsing.
19:34:06 <lispy> i've requested the first line, but it seems to be parsing the whole thing, no output after several minutes
19:36:11 <Igloo> You need to start by adding the constructor for the new hunk format and converting old hunks into that just before they are actually applied
19:36:55 <lispy> applied or written?
19:37:07 <Igloo> applied
19:37:15 <lispy> are you saying i should avoid implementing the code to read them?
19:37:24 <lispy> and just try applying them?
19:37:40 <Igloo> I'm saying you should write the apply code first
19:38:14 <lispy> that assumes i can find the spec for the new format :)
19:38:38 <lispy> i know it's supposed to be on the maillist, but i have yet to find the right email
19:54:38 <newsham> hi
19:55:30 <lispy> interestingly, everything in PatchRead is marked as lazy in every argument
19:58:39 <lispy> although, the printHead function i wrote is considered strict
19:59:19 <lispy> oh, this is really weird
19:59:51 <lispy> Igloo: printHead use about 100kb of memory on average
20:00:06 <lispy> Igloo: so, maybe it is applyToPristine that we need to look at
20:07:29 <Lokadin> say can someone point me to a ncurses howto or information how to use with haskell ?
20:07:51 <lispy> Lokadin: look at the darcs sources, i think it uses ncurses
20:08:07 <Korollary> yi & hmp3 as well iirc
20:08:25 <lispy> oh true
20:08:37 <Lokadin> what part of darcs?
20:08:52 <Lokadin> o
20:08:56 <Lokadin> hmp3
20:09:29 <Lokadin> whats yi?
20:09:39 <lispy> Lokadin: maybe the External.hs, look for curses
20:09:40 <Korollary> @where yi
20:09:41 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
20:10:10 <lispy> i would imagine yi makes the most extensive use
20:11:42 <Lokadin> hmmm, well all i really need is to make a typing game
20:11:52 <lispy> ah, cool
20:12:27 <lispy> Lokadin: your best bet maybe to learn the ncurses api and then study your compilers FFI (ghc is reported to have a nice FFI)
20:12:29 <Lokadin> so like the text just needs to emerge from the right and you type it so it disapears
20:12:36 <Lokadin> o
20:12:49 <Lokadin> where can i find the ncurses api
20:12:49 <Lokadin> ?
20:13:18 <lispy> Lokadin: maybe here? http://frank.harvard.edu/~coldwell/ncurses/hackguide.html
20:13:39 <Lokadin> kk thanks :) i'll take a look
20:13:46 <lispy> although that seems to be for people that want to extend ncurses
20:14:10 <lispy> Lokadin: http://dickey.his.com/ncurses/ncurses-intro.html
20:14:19 <lispy> that one will be more of a user's guide
20:14:26 <Lokadin> kk
20:14:31 <Lokadin> :) thanks
20:18:29 <lispy> you're welcome
20:18:42 <lispy> if you make a typing program i want to play with it :)
20:20:50 <Lokadin> lol kk
20:21:13 <Lokadin> well as soon as i get a working prototype i'll tell you guys lol
20:21:14 <Lokadin> :)
20:36:41 <lispy> Igloo: is it possible your library doesn't track memory allocated by things such as zlib?
20:37:05 <SamB> most likely
20:37:38 <lispy> SamB: you know the library i'm talking about?
20:38:16 <SamB> lispy: no!
20:38:39 * lispy gives up
20:38:41 <lispy> ;)
20:39:00 <glasser> hmm. types with "forall" are existential types?
20:39:40 <lispy> i'm not sure, because in math "there exists" is the existential quantifier
20:39:50 <lispy> but i can't recall seeing "there exists" in haskell
20:39:53 <glasser> yeah, that's why it seems odd to me
20:40:03 <glasser> but I'm reading that that is the case, and am making sure I'm right :)
20:40:33 <lispy> hm...isn't "for all" the universal quantifier or some such?
20:40:41 <glasser> mmhmm
20:40:48 <SamB> lispy: existentials ought to use "exists", but for some reason do not yet
20:41:02 <SamB> for some reason they use "forall" instead
20:41:10 <SamB> which is *really* confusing
20:41:36 <lispy> yeah, that's been bugging me for a while, i just figured existential types were something i hadn't used yet
20:43:01 <lispy> okay, i don't think Igloo's memory tracking library is accurate for darcs gz functions
20:44:04 <lispy> if the library is accurate, that means darcs spent the last 30 min parsing this patch file, return the first line and only needed 100kb peak to do it
20:44:15 <lispy> (and the patch file is 360mb uncompressed)
21:01:59 <mwc> Is there a way to get $ to play nicely with partial application?
21:02:26 <mwc> I'm back trying to rewrite this function; I think if I can figure this out it'll be a major leap in understanding haskell
21:04:37 <newsham> mwc: I dont think so.    (foo $ bar) x   is not the same as foo $ (bar x)
21:05:01 <newsham> mwc: I dont think so.    (foo $ bar a b c) x   is not the same as foo $ (bar a b c x)
21:05:22 <newsham> I assume you want the latter behavior.
21:05:50 <monochrom> "take $ 30" is partial application.
21:06:14 <mwc> I'm trying to write lcgPeriod mod a i s = findPeriod $ take mod $ lcg mod a i s without those 3 redundant parameters
21:06:41 <newsham> mono: i think he means he wants to use an expr like  foo $ bar blah   and get out a function that takes an argument to be appended after "blah" syntactically
21:07:02 <mwc> newsham, indeed
21:07:04 <newsham> mwc: whats wrong with redundant arguments?
21:07:14 <mwc> newsham, I just think it could be more nicely expressed
21:07:24 <mwc> this is something I'm trying to do for the heck of it
21:07:31 <mwc> @pl lcgPeriod mod a i s = findPeriod $ take mod $ lcg mod a i s
21:07:32 <lambdabot> lcgPeriod = (((findPeriod .) .) .) . ap ((.) . (.) . (.) . take) lcg
21:07:50 <newsham> keep in mind that partial application is different than macro expansion or string splicing.
21:08:00 <mwc> yeah
21:08:11 <mwc> I'm trying to figure out an alternative
21:08:15 <mwc> @type ap
21:08:16 <lambdabot> Not in scope: `ap'
21:08:23 <newsham> findPeriod $ take mod $ lcg    means   findPeriod (take mod (lcg))
21:08:46 <mwc> yeah, so I'm trying to come up with something else besides $
21:08:46 <newsham> which is obviously not right if lcg needs more args and mod expects what lcg returns
21:08:49 <mwc> maybe . 
21:08:53 <mwc> but that doesn't work either
21:09:21 <newsham> perhaps it cant be done and the only confusion is that the dollar sign made it look like perhaps it coudl be doen :)
21:10:46 <mwc> @type .
21:10:48 <lambdabot> parse error on input `.'
21:10:50 <mwc> @type (.)
21:10:51 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
21:11:02 <mwc> So why can't c be a function type?
21:11:14 <newsham> it can be?
21:11:26 <newsham> still probably doesnt solve your problem.
21:11:29 <mwc> well, I think that's the source of the problem when I try to write this using composition
21:12:07 <newsham> are your sure your lhs and rhs of (.) are  (b->c) and (a->b)    (ie. argreement on "b")
21:12:11 <monochrom> lcgPeriod mod a i = findPeriod . take mod. lcg mod a i
21:12:12 <newsham> I bet they're not.
21:12:33 <monochrom> I can eliminate s but to eliminate the others require more work.
21:13:54 <mwc> lcg takes 4 integral args to give an infinite integral list. take mod is integral list to integral list
21:14:27 <mwc> then find period is (Eq a) => a -> Maybe Int
21:14:35 <mwc> er, [a] -> Maybe Int
21:14:39 <mwc> so it should be good
21:14:40 <monochrom> I don't think it is worth pointfreeing.
21:14:44 <newsham> try parens where you expect them to be.
21:15:03 <newsham> ie.  (mod . lcg) a i
21:15:11 <mwc> yeah
21:16:27 <palomer> > let map f l = case l of nil => nil | (h::t) => (f h)::map f t in map
21:16:29 <lambdabot>  parse error on input `=>'
21:16:33 <palomer> > let map f l = case l of nil -> nil | (h::t) => (f h)::map f t in map
21:16:34 <lambdabot>  parse error on input `|'
21:16:41 <palomer> > let map f l = case l of nil -> nil  (h::t) -> (f h)::map f t in map
21:16:42 <lambdabot>  parse error on input `->'
21:16:50 <palomer> eh?
21:16:58 <lispy> palomer: you can also talk to lambdabot in private if you're playnig with syntax
21:17:17 <lispy> palomer: i think you need a ;
21:17:19 <ncalexan> > let map f l = case l of { nil -> nil ; (h::t) -> (f h)::map f t } in map
21:17:20 <lambdabot>   Illegal signature in pattern: t
21:17:20 <lambdabot>    Use -fglasgow-exts to permit it
21:17:30 <ncalexan> That nil looks odd, too.
21:17:43 <ncalexan> And your :: should be :.
21:18:18 <ncalexan> > let map f l = case l of { [] -> [] ; (x:xs) -> (f x):(map f xs) } in map
21:18:19 <lambdabot>  add an instance declaration for (Show ((a -> a1) -> [a] -> [a1]))
21:18:26 <SamB> > let map f l = case l of { [] -> [] ; (h:t) -> (f h):map f t } in map
21:18:27 <lambdabot>  add an instance declaration for (Show ((a -> a1) -> [a] -> [a1]))
21:18:28 <ncalexan> ;)
21:18:44 <monochrom> eh eh?
21:20:33 <ncalexan> No, I'm Canadian -- it's just one eh.
21:20:36 <ncalexan> Eh?
21:21:51 <palomer> anyways, I have a simple example of polymorphic recursion
21:22:11 <palomer> depth [] = 0 ; depth (h:t) = 1+ (depth h)
21:22:43 <lispy> should that be 1+(depth t) ?
21:22:53 <SamB> @type let depth [] = 0 ; depth (h:t) = 1+ (depth h) in depth
21:22:54 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
21:22:54 <lambdabot>   Expected type: [a]
21:23:08 <ncalexan> No, he wants it be polymorphic :)
21:23:19 <lispy> uhm...hmm...why?
21:23:37 <ncalexan> That I can't answer.
21:23:51 <palomer> well, that's how "deep" the list is
21:24:34 <lispy> depth [1,2] = 1 + depth 1, that doesn't make sense
21:25:09 <palomer> oh, good point
21:25:44 <palomer> so how could I write a depth function?
21:25:49 <lispy> type checker 1, palomer 0 ;)
21:26:08 <lispy> what would the type be?
21:26:27 <palomer> [a] -> int
21:26:38 <palomer> note that it would be polymorphically recursive
21:27:36 <lispy> what is the depth of [1,2]?
21:27:40 <palomer> 0
21:27:51 <ncalexan> palomer: I think the way to do that (at this time) is to make the depth function in a class Depthable.
21:27:52 <SamB> palomer: first of all, it can't be polymorphic exactly
21:27:58 <ncalexan> You can define it for list types.
21:27:59 <lispy> what is something with depth of 1 or 2?
21:28:11 <palomer> maybe [[a]] -> int could work
21:28:16 <SamB> or at least, not parametrically
21:28:25 <ncalexan> The problem is you get undec. instances if you want to make any random (non-list type) Depthable.
21:28:38 <palomer> depth [[]]  = 1
21:28:43 <ncalexan> But it's not so hard if you have a finite universe of things you want to put in your list.
21:28:49 <palomer> depth [a] = 1+(depth a)
21:29:45 <palomer> no wait, that wouldn't work
21:29:46 <palomer> hrmph
21:30:00 <palomer> I'm trying to find a simple example where polymorphic recursion would be useful
21:30:07 <palomer> heck, I don't care about usefulness
21:30:35 <SamB> palomer: try with Okasaki
21:30:41 <palomer> I don't like his examples
21:30:44 <palomer> they suck
21:31:03 <palomer> someone convince me that my last depth function isn't typeable with recursive polymorphism
21:31:07 <SamB> well, his are the only ones I can think of!
21:31:30 <SamB> palomer: what recursive polymorphis
21:32:16 <ncalexan> BTW, palomer, what type does [[1], [[2]]] have?  You might type a function that you can't type an input value for :)
21:32:21 <SamB> anyway, you can't say "instance Depthable (not [a]) where"
21:32:27 <palomer> here's an example
21:32:36 <ncalexan> SamB -- that would really complicate the fundeps :)
21:33:51 <SamB> ncalexan: Num [a] => [[[a]]]
21:33:56 <SamB> @type [[1], [[2]]]
21:33:57 <lambdabot> forall a. (Num [a], Num a) => [[[a]]]
21:34:19 <SamB> oh, huh
21:34:26 <SamB> oh right.
21:34:31 <SamB> I left the a out ;-)
21:34:33 <ncalexan> That seems a little skew.
21:35:06 <ncalexan> @type [['a'], [['b']]]
21:35:07 <lambdabot>   Couldn't match `Char' against `[a]'
21:35:07 <lambdabot>   Expected type: Char
21:35:08 <SamB> if you think about it it makes perfect sense
21:35:10 <monochrom> You could use a tree data structure to begin with.
21:35:20 <SamB> now, actually instantiating might not 
21:35:25 <ncalexan> SamB: the Num is misleading, but you can make a class that will work.
21:35:56 <ncalexan> Anyway, I think this problem is really well understood.
21:36:04 <SamB> ncalexan: you can even make a Num instance that works
21:36:15 <ncalexan> Mmm.
21:36:36 <SamB> probably "instance (Bits n) => Num [n]"
21:38:01 * SamB has to go to bed
21:39:20 <jethr0> moin moin
21:39:33 <newsham> hi jethr0
21:40:57 <jethr0> hey nwesham
21:41:13 <jethr0> s/nwe/new/
21:41:43 <jethr0> i saw you posted on the TH mailings list
21:42:09 <newsham> yah.  I made a bit of progress, but I don't know how to take in a string (or a Name) and use that to construct a call at compile time
21:42:31 <jethr0> "construct a call"?
21:43:16 <newsham> lets say I have a string "foo",  I want to do something like call    "func foo"
21:43:40 <newsham> (in particular I have a string of a type, and I want to call a method that returns the length of that type given an instance of that type)
21:45:28 <jethr0> $([|const "hello"|] >>= lift . show)
21:45:32 <jethr0> "AppE (VarE GHC.Base.const) (LitE (StringL \"hello\"))"
21:45:49 <jethr0> "length of that type"?
21:46:03 <newsham> I dont want to construct a call inthe output, I want ot evaluate the call at compile time
21:46:38 <newsham> instance ByteContainer FOO where { containerLength x = 12 }
21:47:07 <newsham> so if I have a string "FOO" I want to do  "containerLength newFOO"  (I already have a newFOO function)
21:47:20 <jethr0> well, you can nest TH.
21:47:54 <newsham> so I have something like   $( ... ; len = $(nested stuff) ; .. )   ?
21:48:33 <SamB> newsham: you need more brackets
21:49:46 <jethr0> newsham: i'm trying that right now, hang on a sec
21:50:23 <newsham> this sure seems a lot more complicated than lisp macros.  maybe mr. graham was right
21:50:29 <jethr0> let x = 12 in $([| $(varE $ mkName "x") |])
21:51:23 <jethr0> newsham: that's partially true. but you have the "comfort" of type safety. AND lisp macros tend to get pretty ugly/non-understandable when sufficiently complex
21:52:15 <jethr0> hmm, well that wasn't it yet, but it shows nesting :)
21:52:53 <newsham> btw, I couldnt get your printAST example to work.
21:53:16 <newsham> I get an error on   "printAST [| 5 |]"
21:53:37 <newsham> pr.lhs:9:0: parse error (possibly incorrect indentation)
21:53:51 <Lemmih> dcoutts: ping.
21:54:08 <SamB> newsham: did you catch that quotations are in a Monad?
21:54:10 <jethr0> "let printAST ast = runQ ast >>= print in printAST [| 5 |]" works fine for me with "TH" and "TH.Syntax" imported
21:54:31 <newsham> hmm?
21:54:50 <jethr0> ah, if you do that inside of a file you have to assign the result to sth
21:55:11 <jethr0> i guess that's a real "bug" in my tut
21:55:21 <newsham> sth?
21:55:34 <jethr0> x = printAST [| 5 |]
21:55:45 <SamB> such as main
22:00:53 <jethr0> newsham: let x = "hello" in $([| length $(varE $ mkName "x") |])
22:00:56 <jethr0> results in "5"
22:03:04 <jethr0> alternatively: let x="hello" in $(appE (dyn "length") (dyn "x"))
22:03:39 <jethr0> or   $([| length $(dyn "x") |])
22:03:51 <jethr0> which isn't even all that ugly/convoluted anymore
22:04:30 <jethr0> newsham: still there?
22:06:15 <jethr0> or   $([| length $(dyn "x") |])
22:06:27 <jethr0> which isn't even all that ugly/convoluted anymore
22:10:04 <jethr0> @seen
22:10:05 <lambdabot> Lately, I have seen jethr0, newsham, palomer and samb.
22:11:55 <palomer> :o
22:12:28 <jethr0> i never know whether i just lost connection to the server or everybody just disappeared
22:12:34 <jethr0> stupid irc protocol
22:13:11 <palomer> does anyone even use TH?
22:13:45 <jethr0> don't know. few people, bad docu, ... but there are some projects out there using TH for code transformation, etc
22:17:27 <jethr0> gotta go. i'll be back in half an hour
22:19:59 <newsham> jethr0: thank you
22:20:05 <jethr0> np
22:20:08 <jethr0> did that help?
22:20:35 <newsham> busy coding something else,but it looks like its what I need.
22:20:41 <newsham> I'm pretty sure I can get there from here.
22:20:42 <jethr0> :)
22:21:05 <jethr0> k
22:39:51 <jethr0> ls
22:40:43 <rep> .
22:40:44 <rep> ..
22:40:58 <jethr0> hehe
23:18:13 <sethk> 'evening all.  quick question about explicit code (vs layout).
23:18:34 <sethk> in the form   let ... in do ...  the compiler is happy with:
23:18:43 <sethk> foo x y = let
23:18:44 <sethk> {
23:18:50 <sethk> z = x;
23:18:54 <sethk> } in do
23:18:54 <sethk> {
23:18:58 <sethk> whatever;
23:18:59 <sethk> };
23:19:08 <sethk> but if I change:  } in do
23:19:15 <sethk> to two lines,  one  }
23:19:20 <sethk> and the next    in do
23:19:42 <sethk> the compiler barfs.  Is there a way to avoid this?  I tried a semicolon after } and before   in do,  but that didn't help
23:20:05 <jethr0> sethk: why do you use all those braces anyways?
23:20:43 <jethr0> you generally only need braces if you want to cram everything into one line; or have an aversion to proper indentation
23:20:46 <sethk> jethr0, when I don't feel like figuring out where one of my bozos put tabs instead of spaces  :)
23:20:52 <sethk> jethr0, I know I don't need them
23:20:59 <sethk> jethr0, I coded it with layout rules first
23:21:08 <sethk> I just want to know how
23:21:14 <sethk> this is an artificial example, obviously
23:21:26 <jethr0> hmm, what error message does the compiler produce?
23:21:37 <jethr0> have you indented the "in" to be level with the "let"?
23:21:39 <sethk> just "parse error"
23:21:51 <sethk> jethr0, the whole point is to avoid _any_ indentation sensitivity
23:22:00 <sethk> jethr0, if I indent it correctly I don't need the braces at all  :)
23:22:17 <jethr0> hmm, multiline haskell will _always_ rely on indentation to _some_ extent
23:22:27 <sethk> jethr0, not according the the report
23:22:36 <jethr0> hmm
23:22:53 <sethk> having } in do    on one line i no big deal, possibly that's all the granularity I can get
23:23:13 <jethr0> haven't read that part very attentively, but putting an "in" at an arbitrary indentation doesn't seem right
23:23:29 <sethk> jethr0, if indentation is irrelevant, then nothing seems right or wrong
23:23:38 <sethk> in fact, the language isn't defined by indentation
23:23:51 <sethk> braces are added to the code by the compiler using indentation as a guide
23:23:57 <jethr0> yes, but it would be contrary to the problems i've had with haskell indentation. braces or not
23:23:59 <sethk> see page 14 of the report
23:24:30 <sethk> as I wrote it, you can put in anywhere on the line you like as long as it is after {, and the following lines can be in the first column
23:24:40 <sethk> that's ugly, I just did it to prove that I was indentation insensitive
23:24:49 <jethr0> hmm, interesting
23:25:00 <sethk> it's easier for a code generator to generate code with explicit terminators.
23:25:21 <sethk> but, as I said, if I need to keep the in on the same line with the do, or the where on the same line as the closing }, that's no big deal
23:25:30 <jethr0> sethk: wouldn't putting it all on one line be even easier for a generator?
23:26:00 <sethk> jethr0, sure, but (1) i'd hate to try and read it and (2) I wouldn't be able to edit the file once the line got to be some maximum length
23:26:07 <sethk> of course I could run it through a formatter
23:26:19 <sethk> that's a good question, I'm not sure what the compiler would do with everything on a single line.
23:26:27 <sethk> I think I'll try that, just to see what happens.  :)
23:26:33 <jethr0> :)
23:26:59 <palomer> this is something that I often want to do with an [a] list a_1:...:a_n
23:27:30 <palomer> take the first element, a_1, then try f a_1 a_i (i!=1)
23:27:56 <palomer> if it succeeds, remove a_i from the list and change the cumulative return value
23:28:25 <palomer> keep on goingwhen you're done, return the final list and the cumulative return value
23:28:27 <jethr0> palomer: so try every element against every other?
23:28:38 <palomer> is this a one liner?
23:29:35 <jethr0> could you give me a very short example (i.e with 3 elements, or so?)
23:30:08 <palomer> try (h:t) = foldl (\a c -> if f a h then c:g(a) else c) nil t
23:30:25 <palomer> ok, say [(1,2),(4,8),(2,6)]
23:30:35 <palomer> and my predicate is <
23:30:35 <jethr0> uhu
23:30:43 <ncalexan> palomer: try Cale's swing combinator at http://haskell.org/hawiki/LicensedPreludeExts
23:30:52 <ncalexan> I think the swing find is very close to what you want.
23:31:01 <palomer> so it would start with 1 and test it against 4
23:31:06 <palomer> sucess
23:31:07 <ncalexan> s/combinator/hof/
23:31:17 <palomer> so I have [2,8]  (I started with 2)
23:31:22 <palomer> then I test 1 against 2
23:31:24 <palomer> success
23:31:29 <palomer> so I have [2,8,6]
23:31:42 <palomer> so I return ([2,8,6],nil)
23:32:39 <palomer> ok, look at it this way
23:32:53 <palomer> I have lst :: [(a,b)]
23:33:06 <palomer> I have a partial ordering on a
23:33:18 <jethr0> yes, but what then? i thought you wanted to repeat the process with a_2 now?
23:33:25 <palomer> I want to apply this partial order, then get a list of b's for every chain
23:33:55 <palomer> jethr0: actually, I would repeat with the head of the output list
23:34:09 <palomer> someone give me a typical partial order
23:34:20 <jethr0> <=
23:34:23 <ncalexan> Sets, inclusino.
23:34:31 <ncalexan> Naturals, division.
23:34:35 <palomer> ok, divides
23:34:52 <jethr0> i don't get the "head of the output list" part
23:35:28 <palomer> [(2,1),(8,2),(3,3),(9,4),(6,5)]
23:35:36 <jethr0> couldn't you do sth with "takeWhile" and then "map snd" on the result?
23:35:51 <palomer> looking at the first coordinates, I get the chain:
23:36:10 <palomer> 2,6,8
23:36:23 <palomer> and the chain 3,9,6
23:36:49 <palomer> now, I take the second coordinates, so I get output 1,5,2
23:36:50 <palomer> and
23:37:07 <palomer> 3,5,4
23:37:18 <palomer> (I was describing how to implement this before)
23:37:30 <palomer> so my result is [[1,5,2],[3,5,4]]
23:37:52 <palomer> how would I do this?
23:38:30 <jethr0> sry, maybe i'm not the right person to ask :). i have no idea how you got from <long list> to "2,6,8"
23:38:44 <palomer> ok
23:38:50 <palomer> take any set of numbers
23:38:53 <palomer> then order them like so
23:39:02 <palomer> (a < b) means a divides b
23:39:07 <jethr0> ah, you left out the ordering part :)
23:39:11 <jethr0> yes
23:39:11 <palomer> do you agree that you get a lattice?
23:39:18 <jethr0> hmm
23:40:14 <jethr0> but you could get "2,8,6" just as well?
23:40:20 <palomer> sure
23:40:23 <palomer> ordering doesn't matter
23:40:38 <palomer> when I say 2,8,6 I mean
23:40:43 <jethr0> ok
23:40:43 <palomer> "both 8 and 6 are under 2"
23:40:56 <jethr0> yes
23:41:03 <palomer> so, for any maximum, I get a tree, do we agree?
23:41:10 <jethr0> yes
23:41:14 <palomer> a tree of keys, in this case
23:41:20 <palomer> since I'm dealing with pairs
23:41:37 <palomer> now, I want to collect the values (the second coordinate) of these nodes
23:41:52 <jethr0> yes, i get that part
23:42:10 <palomer> how in the blazes can I do this elegantly
23:42:12 <palomer> hullo ski 
23:42:32 <jethr0> palomer: your foldl doesn't look that bad
23:44:17 <jethr0> hard part is to find non-overlapping maxima that cover all elements (if i understood you correctly)
23:44:33 <palomer> well, if I was to use my foldl
23:44:39 <palomer> I would simply insert my a_1 back into my list
23:44:49 <palomer> at the back
23:45:03 <palomer> and try my algorithm again
23:45:09 <palomer> until I get a fixed point
23:45:32 <palomer> wait, I would have to iterate through every element before getting a fixed point
23:45:38 <palomer> ugh, this seems like something people would want to do
23:45:46 * palomer pokes cale
23:46:05 <ncalexan> Why would you get non-overlapping maximum chains?  What about 1, 6, 12, 18?
23:46:18 <ncalexan> I think the chains would be 1 | 6 | 12 and 1 | 6 | 18...
23:46:28 <ncalexan> Which certainly intersect non-trivially.
23:46:31 <jethr0> i thought you wanted to test all combinations and take the non-overlapping maxima so that their sum equals the input list
23:46:43 <palomer> ncalexan: I mis expressed myself
23:46:46 <palomer> I mean trees, not chains
23:46:56 <jethr0> hmm
23:46:57 <palomer> so 1,6,12,18 would be one tree
23:47:09 <ncalexan> But 12 \not{|} 18.
23:47:17 <jethr0> exactly
23:47:24 <palomer> but they have a common maximum
23:47:43 <ncalexan> Every pair has a common max -- their LCM :)
23:47:44 <palomer> take your set, find the maximums, each one of those maximums defines a tree
23:47:54 <jethr0> how about 2,4,8 and 3,6,9; they ain't no tree.
23:48:07 <palomer> sure, 2 trees
23:48:18 <palomer> with a common element
23:48:48 <ncalexan> And the common element is?
23:49:07 <palomer> 6
23:49:19 <ncalexan> 6 is not in 2,4,8 -- or I'm completely lost.
23:49:25 <palomer> yes, but 2 | 6
23:49:28 <palomer> and 2 is a maximum
23:49:33 <jethr0> so you need sth like a sieve. to not check elements again that already appeared inside another tree
23:49:34 <palomer> and each maximum defines a tree
23:49:38 <palomer> and I'm interested in those trees
23:50:10 <jethr0> what do you need this for?
23:50:15 <ncalexan> Oh, you're calling 2 the max.  Sorry.  That's counter-intuitive; the poset of integers calls 1 the minimum.
23:50:41 <palomer> oh, righto
23:50:43 <palomer> fine, minimums
23:50:57 <palomer> take a minimum, it defines a tree
23:51:29 <ncalexan> I think all your doing is sorting by least, and then finding all multiples of head, and removing them; then finding all multiples of head; removing, etc.
23:51:53 <palomer> divides was an examples
23:51:56 <ncalexan> s/your/you're/
23:51:57 <palomer> s/examples/example
23:52:04 <palomer> I'm dealing with a partial ordering p
23:52:36 <ncalexan> I don't think it makes much difference.
23:52:58 <jethr0> yes, but ncalexan is right. by deleting matching elements you only have remaining elements that don't occur in already found trees. so, with some backtracking this would be solvable
23:53:07 <jethr0> but i'm sure there's a much nicer solution...
23:53:19 <ncalexan> Where is the backtracking?
23:53:50 <ncalexan> Choose an element.  Compare everything to the element, looking for the least.  Then compare everything to the least, taking out things that compare to it.
23:54:02 <ncalexan> Then you do have to sort.
23:54:08 <ncalexan> s/do/don't/
23:54:10 <ncalexan> Bah!
23:54:10 <palomer> finding the least is O(n)
23:54:21 <ncalexan> I wasn't claiming efficiency.
23:54:23 <palomer> removing multiples is O(n)
23:54:37 <palomer> repeat n times
23:54:42 <palomer> this is O(n^2) in the worst case
23:54:43 <ncalexan> So O(n^2).
23:54:50 <ncalexan> And sorting O(n log n)
23:54:59 <ncalexan> So you really don't have a lot of room for optimization.
23:55:17 <ncalexan> In general, you're trying to sort a poset.
23:55:22 <palomer> but wait
23:55:25 <palomer> your method gives me chains
23:55:26 <ncalexan> Whatever that means.
23:55:42 <ncalexan> Did you not want chains?  I thought that was the point.
23:55:47 <palomer> nope
23:55:49 <palomer> I want trees
23:56:07 <ncalexan> What is a tree in a poset?
23:56:11 <ncalexan> Does that even mean something?
23:56:14 <palomer> take a maximum
23:56:17 <palomer> everything that's under that maximum
23:56:18 <palomer> repeat
23:56:29 <palomer> (for other maximums)
23:57:09 <ncalexan> Recall 1, 6, 12, 18.  If I choose 18 as the max, I get 18, 6, 1 and 12.
23:57:18 <ncalexan> If I choose 12 as the max, I get 12, 6, 1 and 18.
23:57:28 <ncalexan> You are okay with ambiguity?
23:57:36 <ncalexan> Or do you have some way to deal with it?
23:58:23 <palomer> it's not a question of ambiguity
23:58:44 <palomer> I just want all these trees
23:58:50 <jethr0> but if you go over all combinations, O(n log n) isn't your biggest problem
23:58:50 <palomer> actually, building the lattice would be nice too
23:58:52 <Itkovian> @seen boegel
23:58:53 <lambdabot> boegel is in #haskell-blah, #haskell-overflow and #haskell. Last spoke 14
23:58:53 <lambdabot> hours, 23 minutes and 2 seconds ago.
23:59:18 <ncalexan> palomer: what you're trying to do is probably equivalent to topological sorting.
23:59:49 <palomer> imagine I have a datastructure NTree, I want to put these elements in my NTree
23:59:54 <palomer> sorted by predicate p
