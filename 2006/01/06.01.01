00:01:25 <pierre-> happy new year!
00:01:34 <Cale> happy new year!
00:02:16 <pierre-> i'm haskell newbie, how can i participate in hIde developement
00:02:18 <pierre-> ,
00:02:20 <pierre-> *?
00:03:49 <Cale> Hmm, I'm not sure as I'm not all that familiar with hIDE myself. I haven't seen many changes to it lately. I wonder if dons has any easy to-do's for yi.
01:12:41 <Lemmih> pierre-: hIDE has pretty much stalled and will probably first be continued when GHC-6.6 is out.
01:29:53 <gour> 'morning #haskell & all the best (in a year 2006)
01:29:58 <shapr> yow!
01:30:25 <gour> how's the code?
01:31:19 <shapr> Code is fun, how's yours?
01:32:22 <gour> it was stalled for (quite) some time, but moved a bit in the 14th chapter, so now i'm recursive algebraic types (exercises 14.15 onwards..)
01:32:48 <shapr> ah, nifty
01:32:49 <gour> s/i'm / i'm at/
01:33:01 <gour> well, it could be (much better) 
02:06:11 <palomer> morning haskell
02:06:33 <neologism> happy new year haskellers!
02:20:48 <lennart_> moinin
02:24:55 <stesch> moin moin
02:27:21 <ibid> moi kaikki, hyvää uutta vuotta :)
03:02:53 <rep> hm
03:03:02 <rep> replaceMin t = let (t', m) = rpMin t m in t'
03:03:05 <rep> how does this work?
03:03:24 <rep> passing an argument that isn't bound to anything
03:05:42 <rep> (from http://haskell.org/hawiki/FixedPointCombinator)
03:07:01 <rep> does it have to do with laziness?
03:08:50 <int-e> yep.
03:10:51 <JohnMeacham> happy new year haskellies!
03:11:11 <shapr> whee!
03:11:19 <basti_> rep: the real question is, what would happen if you return that unbound value? ;)
03:17:32 * int-e Suspects that answering 'how does this even work' requires a complete understanding of lazy evaluation.
04:00:31 <audreyt> instance Num (Seq a -> a) where fromInteger = (Seq.!)
04:00:39 * audreyt grins evilly
04:00:52 <audreyt> Seq.index, even.
04:11:09 <int-e> let me guess - with this definition, (1+2) sequence  compiles but yields a runtime error?
04:47:16 <Debolaz> How do I make ghc include /usr/pkg/lib/ghc-6.4.1/include when it compiles something so that it may suck in ghcconfig.h? (And why isn't this default behaviour?)
04:48:13 <Lemmih> -Ipath
04:48:25 <Lemmih> And it's not always wanted.
04:49:58 <Debolaz> Trying to compile cabal 1.1.3:
04:49:59 <Debolaz> /usr/pkg/bin/ghc -I/usr/pkg/lib/ghc-6.4.1/include --make -Wall -fno-warn-unused-matches -cpp  -i. -odir dist/tmp -hidir dist/tmp Setup.lhs -o setup
04:49:59 <Debolaz> Chasing modules from: Setup.lhs
04:49:59 <Debolaz> ./Distribution/Compat/FilePath.hs:40: ghcconfig.h: No such file or directory
04:50:20 <Debolaz> It's probably something I'm missing, I don't really use haskell, just trying to make it behave properly in pkgsrc. 
04:50:57 <Lemmih> What version of GHC?
04:51:09 <Debolaz> 6.4.1
04:51:38 <Lemmih> Then drop all the flags.
04:52:05 <Lemmih> Or simply: 'runhaskell Setup.lhs {configure|build|install}'
04:53:51 <Debolaz> /usr/pkg/bin/ghc  Setup.lhs -o setup
04:53:51 <Debolaz> /usr/bin/ld: cannot find -lHShaskell98
04:54:40 <Lemmih> Are you sure you've got a working GHC?
04:54:44 <Debolaz> This problem I've encountered before, while trying to compile pugs. It seems to stem from the fact that ghc for some reason decides it doesn't want to include -L/usr/pkg/lib/ghc-6.4.1 when trying to link after having been called from pkgsrc, but I can't find any obvious environment variable of parameter causing this behaviour.
04:55:22 <Debolaz> It links just fine when not run through pkgsrc.
04:55:33 <Lemmih> Can you use GHCi? What does 'ghc --print-libdir' say?
04:55:50 <Debolaz> # ghc --print-libdir
04:55:50 <Debolaz> /usr/pkg/lib/ghc-6.4.1
04:56:18 <Debolaz> ghci seems to work fine too.
04:57:37 <Lemmih> Then use 'runhaskell' or 'runghc'.
05:00:34 * Debolaz goes for it.
05:04:37 <Debolaz> Ok, how do I tell it during the configure phase to install to /usr/pkg rather than /usr/local? Does it still take the setup from GNUmakefile?
05:05:49 <Lemmih> 'runhaskell Setup.lhs --help'
05:07:17 <Debolaz> Thank you.
05:11:26 <Debolaz> Though while runghc|haskell worked outside pkgsrc, it still doesn't work inside pkgsrc.
05:11:41 <Debolaz> cd /usr/pkgsrc/noncvs/ghc-cabal/work/cabal && /usr/pkg/bin/runghc -cpp Setup.lhs configure
05:11:41 <Debolaz> ./Distribution/Compat/FilePath.hs:40: ghcconfig.h: No such file or directory
05:11:47 <Debolaz> Running the first line outside pkgsrc works just fine.
05:12:35 <Lemmih> Try 'runhaskell -i Setup.lhs configure'
05:17:42 <Debolaz> "./Distribution/Simple/Configure.hs:63: ghcconfig.h: No such file or directory" when doing runghc -i Setup.lhs build. Configure worked though.
05:19:37 <Lemmih> Hm.
05:20:36 <Debolaz> When run outside pkgsrc, both works.
05:21:34 <Lemmih> I think you need to ask someone who knows more about this 'pkgsrc' you're referring to.
05:22:36 <Debolaz> http://www.pkgsrc.org/ - It's an automated build system for various operating systems. I've not had any similar problems with any non-haskell application.
05:23:41 <Debolaz> There has to be some environment variable that causes haskell to start borking, but I can't find any documentation on what that might be, and I can't find any obvious one when running /usr/bin/env from pkgsrc. 
05:24:47 <flux__> debolaz, remove the environment and replace with it some known one?
05:25:09 <musasabi> morning
05:40:38 <neologism> any AI expert here?
05:40:49 <neologism> or.. artificial neural networks expert
05:43:53 <Saulzar> Ask anyway :)
05:44:27 <neologism> what is perceptron?
05:44:42 <tic> it's a node!
05:44:50 <neologism> I mean.. whats the difference bethween normal neuron and perceptron
05:44:53 <basti_> "a pointless algorithm that doesn't do anything real but is hyped up for no reason"
05:45:01 <earthy_> wasn't that a weird term for a neuron that actually had external inputs?
05:45:04 <neologism> I am studying for an exam
05:45:10 <tic> basti_, it's really all an optimization problem, isn't it?
05:45:19 <tic> basti_, finding a plane that cuts all points
05:45:20 <Saulzar> A neuron is something in your brain, a perceptron is a simple model of what a neuron might be like :)
05:45:23 <neologism> and I dont understand the difference between neurons in general and perceptron
05:45:35 <neologism> Saulzar: no.. its not.. its special in something
05:45:39 <neologism> at least it seems so
05:45:45 <basti_> tic: neural networks never solved a real problem.
05:45:57 <basti_> -> #ai
05:46:33 <neologism> ok
05:46:36 <neologism> thn anyway
05:46:39 <xs> basti_: like handwriting recognition?
05:46:43 <basti_> -> #ai
05:48:13 <Debolaz> basti_: Aritifical neural networks didn't anyway. :)
05:49:16 <neologism> seems like I wont pass the exam tomorrow :)
06:36:37 <MarcWeber> Having do {put g'; return x} beeing equal to put g' >> return x: Doesn't that mean that the result of put g' isn't used ? How can g' be forwarded then? I'm talking about the state monad
06:37:04 <Heffalump> g' is written into the state
06:37:15 <Heffalump> the result of put g' is ()
06:37:25 <Heffalump> the explicit result, that is
06:37:54 <Heffalump> implicit results that go into the monad's internal structures are always "forwarded"
06:39:54 <tic> it really depends on how you define bind..
06:40:43 <MarcWeber> Yes, put is a function returning a function \s-> ((),s). By the way: Why does get return (s,s)? and not ((),s) ?
06:42:40 <Heffalump> because the first element of the tuple is what the explicit result is
06:43:15 <Heffalump> so it's what you get in s if you have do { ... ; s <- get ; ... }
06:43:15 <int-e> 'return s (first component) and keep the state the same (second component)'
06:48:02 <MarcWeber> Heffalump: What do you mean talking about implicit/explicit? fst,snd value of the tuple (value,state)?
06:51:14 <Heffalump> MarcWeber: yes (but vice-versa)
06:51:39 <Heffalump> type State x a = \x -> (a,x)
06:51:47 <Heffalump> x is the (implicit) state that the monad passes around
06:51:57 <Heffalump> a is the (explicit) result that is produced by a computation
06:52:23 <Heffalump> you see the a values when you use do notation, because you can give them  names by doing a <- ...
06:52:42 <Heffalump> you don't explicitly see the x values
06:55:32 <MarcWeber> Heffalump: I've understood how to use it but not how it works, yet.. ;-) Have to think about it again
07:14:11 <luqui> does the fellow who writes hoogle ever hang out in here?
07:14:53 <Lemmih> Yeah, he's even here now.
07:14:59 <Lemmih> @seen ndm 
07:15:00 <lambdabot> ndm is in #haskell-overflow, #haskell-blah and #haskell. I don't know
07:15:00 <lambdabot> when ndm last spoke.
07:15:20 <musasabi> whois tells ndm spoke an hour ago.
07:15:47 <musasabi> lambdabot could be teached to do whois too for @seen answers
07:31:53 <ndm> luqui, i wrote hoogle
07:34:04 <luqui> ndm, hi
07:34:12 <luqui> I checked out the source, and it doesn't seem to be working
07:34:49 <luqui> in Database.hs, the result of loadTextfile x is: Database {aliases = AliasTable {}, names = NameTable [], types = TypeTable [], classes = ClassTable {}}
07:35:01 <luqui> which it seems to be would be a problem
07:35:46 <luqui> s/be/me/
07:36:27 <Lemmih> @hoogle func :: With Type
07:36:28 <lambdabot> hoogle: Hoogle/Parser.hs:(82,8)-(85,38): Non-exhaustive patterns in
07:36:28 <lambdabot> function g
07:36:28 <lambdabot>  
07:36:50 <ndm> luqui, hi
07:37:12 <ndm> hmm, will check
07:38:13 <ndm> Lemmih, thats a bug - have added it to the wiki and will fix later
07:38:25 <ndm> luqui, where did you get the source?
07:38:27 <ndm> cvs or darcs?
07:38:52 <luqui> darcs
07:39:14 <luqui> 42 patches
07:39:19 <ndm> just checking it out myself, this isn't my development machine
07:39:44 <luqui> ./hoogle -l src/hoogle.txt map   # returns nothing
07:40:13 <ndm> hmm, my database definately has stuff in
07:40:59 <ndm> how big is the file src/hoogle.txt
07:41:14 <luqui> 6929 lines
07:41:40 <ndm> hmm, works fine for me...
07:41:46 <luqui> strange
07:41:58 <ndm> can you try converting src/hoogle.txt from DOS -> UNIX newline characters
07:42:06 <luqui> ahh, that's a good idea
07:42:07 <ndm> since i guess you're running on Linux
07:42:58 <ndm> and which compiler are you using?
07:43:17 <luqui> ghc 6.4.1
07:44:04 <luqui> ndm, the line conversion worked
07:44:07 <luqui> thanks
07:44:19 <ndm> luqui, that sounds like a GHC bug then...
07:44:32 <luqui> why, is it supposed to normalize the line format?
07:44:40 <ndm> yes
07:44:59 <ndm> in haskell, readFile opens a text file, which should be changed to the right format
07:45:24 <luqui> "right format" meaning UNIX style?
07:45:24 <ndm> haskell is remarkably broken in that the haskell 98 libraries have no support for binary files :)
07:45:36 <ndm> it should consider all lines equal
07:45:52 <ndm> i'll dos2unix it and patch it when i get back to my development machine
07:45:57 <luqui> You're not being entirely clear about that...
07:46:09 <luqui> "all lines equal"
07:46:17 <ndm> it should open all files in text mode
07:46:37 <ndm> which i think means it should paper over any differences between platforms
07:46:53 <luqui> hmm..
07:47:20 <ndm> anyway, i'll fix teh darcs repo
07:47:29 <luqui> it's probably working correctly, because I'm on UNIX, and that was a dos file
07:47:40 <ndm> and see if i can patch it in some way to stop this happening again (like filtering '\r' or something)
07:47:41 <luqui> maybe it would be a good idea to patch source not to care
07:47:44 <luqui> i.e. to ignore \rs
07:47:54 <luqui> heh, yeah :-)
07:47:55 <ndm> it should ignore the \r
07:47:58 <xs> but don't some macs use only \r for line end?
07:48:09 <luqui> yeah, but those macs suck
07:48:12 <ndm> xs, only pre OS X
07:48:26 <luqui> and nobody uses anything pre OS X anymore...
07:48:36 <ndm> anyway, readFile and lines should really just do any appropriate magic for any types of text file
07:48:40 <luqui> (was there a ghc for Mac < 10?)
07:48:54 <luqui> well, as long as you can define that magic well
07:49:02 <luqui> as in, convert all line endings to "\n"
07:49:03 <xs> luqui: the problem is if you want to access data from a pre-osx machine.
07:49:12 <luqui> xs, true
07:49:18 <luqui> I was being somewhat sarcastic
07:49:38 <ndm> its all very annoying that line endings are so very broken
07:49:53 <luqui> basically, s/\r?\n|\r\n?/\n/g
07:50:54 <xs> does the order of \n and \r matter under windows? it doesn't on a typewriter.
07:51:01 <ndm> xs, yes]
07:51:11 <luqui> yeah, it's always \r\n
07:51:16 <ndm> netscape once defined their own line endings, that were \n\r :)
07:51:23 <luqui> ack
07:51:26 <xs> heh :p
07:51:44 <ndm> anyway, using \n will certainly work on windows
07:51:58 <ndm> via haskell, and via any decent editor - just not using notepad
07:53:18 <ndm> thanks for tracking that down luqui, i'll patch it all up soon
07:53:52 <luqui> cool
08:48:23 <maitscha> hallo. i want to iterator through a tree and insert values from a sorted list. any ideas?
08:49:08 <maitscha> i have tried it with...
08:49:09 <maitscha> reArangeTree :: Ord a => Tree a -> [a] -> Tree a
08:49:10 <maitscha> reArangeTree (Leaf a) l = (Leaf (head l))
08:49:10 <maitscha> reArangeTree (Branch (tree1) (tree2)) l = (Branch (reArangeTree tree1 l) (reArangeTree tree2 l))
08:49:24 <maitscha> but that only inserts always the first element from the list in the leafs.
08:50:46 <basti_> maitscha: are you a classmate of reddi and the other guy that showed up here yesterday?
08:51:24 <basti_> ah no you -are- that guy
08:51:38 * basti_ has problems remembering abstract nicknames
08:52:30 <basti_> we talked about that, didnt we, and I mentioned a type, didnt I?
08:53:40 <maitscha41> sorry, back.
08:53:45 <basti_> wb
08:53:51 <maitscha41> hallo basti_
08:53:51 <sylvan> maitscha, I'd do it recursively. That is split the (sorted) list in two each time, and insert them recursively in one branch each, then when the list is a single element you generate a leaf instead
08:54:10 <basti_> sylvan: the tree isn't guaranteed to have balanced depths
08:54:34 <basti_> the (empty) tree is given, and it is to be filled.
08:54:42 <sylvan> oh so the tree isn't empty from the start?
08:54:49 <maitscha41> yes, the three should have the same structure as the original one.
08:54:56 <maitscha41> s/three/tree
08:55:10 <basti_> no it has a certain structure, and this structure is not to be changed
08:55:49 <maitscha41> only the values from the leafs should be changed
08:56:14 <tromp_> anyone here use Mac OS X?
08:58:14 <nnunley> tromp_: I'm using it right now.  What do you need?
08:58:42 <sylvan> ah, then you'll a function to traverse the list "pop" off elements as you reach the leaves, and return a tuple of the new tree, and the elements of the sorted list which hasn't been used yet
08:58:57 <sylvan> traverse the TREE
08:59:31 <sylvan> reArrangeTree' :: Tree a -> [a] -> (Tree a, [a])
08:59:42 <maitscha41> sylvan: exactly what i first tried. but I got e little bit confused because of the recursion.
08:59:44 <tromp_> wondering what are good IRC clients, nnunley
09:01:06 <maitscha41> reArangeTree :: Ord a => Tree a -> [a] -> (Tree a,[a])
09:01:06 <maitscha41> reArangeTree (Leaf a) l = ((Leaf (head l)),tail l)
09:01:13 <sylvan> yes correct
09:01:14 <sylvan> so far
09:01:24 <sylvan> then in the Branch case you need to first apply this recursively to the left tree
09:01:30 <maitscha41> but i got a confused with the function reArangeTree (Branch (tree1) (tree2)) l = 
09:01:48 <sylvan> and *then* recursively to the right tree using the list you got back from the first recursion
09:01:52 <basti_> yea that part is a little harder
09:01:58 <basti_> but not all that hard again
09:02:05 <basti_> what do you want to do in that case maitscha?
09:02:10 <sylvan> then return the Branch of these two sub-trees, and the list you got back from the second recrusion
09:02:51 <maitscha41> but how can i use the returned list from the left tree for the right tree?
09:03:19 <sylvan> where (t1' , xs') = reArrangeTree t1 xs
09:03:32 <sylvan> and then use xs' when you recurse down t2 
09:03:47 <maitscha41> hmmm.... ok. that sounds good.
09:05:58 <maitscha41> i will try it. thx so far.
09:11:42 <basti_> bet he'll show up again?
09:29:31 <Lemmih> SamB: ping.
09:46:35 <Oejet> Lemmih: Happy New Year!
09:48:35 <Lemmih> Thanks, likewise.
09:56:18 <Oejet> Lemmih: Are you in one piece?
10:01:42 <Lemmih> Yep, you?
10:29:39 <twb> What are the options for reading and writing utf-8 text files in Haskell?
10:30:04 <musasabi> use a library that supports it.
10:30:12 <musasabi> fps perhaps.
10:30:24 <Lemmih> fps supports utf-8?
10:31:10 <mahogny> while we are in on that, if I want to support multiple locales in my program (several charsets), can I do it with vanilla haskell or do I need to use some libs?
10:31:42 <musasabi> Lemmih: I think it does, or at least some variants of it.
10:31:56 <arcatan> newbie question, but... if I have tuple (x,y), how do I get the values x and y out of the tuple?
10:32:03 <twb> Can I make parsec use fps?  I suppose I'd need to write a new Parsec/Char.hs that used the fps backend?
10:32:17 <mahogny> arcatan, the functions fst and snd. but depending on the situation, there are better ways
10:32:17 <musasabi> Lemmih: I think there are at least 1) ghc, 2) darcs, 3) jhc, 4) pugs, 5) dons and probably others I am forgetting about.
10:32:26 <twb> >(\(x,y)->x+y) (2,3)
10:32:28 <Lemmih> let (x,y) = (1,2) in a + b
10:32:41 * Lemmih slaps head.
10:32:49 <musasabi> audreyt made cool changes to PArrows to make it work with fps.
10:33:01 <twb> arcatan: alternately, see fst and snd
10:33:05 <musasabi> (available from pugs)
10:33:10 <Lemmih> twb: How about using a lexer?
10:33:13 <twb> fst = \(x,_) -> x
10:33:27 <twb> Lemmih: Scary.
10:33:31 <arcatan> okay, thanks everbody
10:33:48 <musasabi> separating the lexer out can make sense.
10:34:01 <twb> Still scary, tho.
10:34:49 <twb> The lexer stuff seems geared towards parsing programming languages, which is not what I'm doing.
10:36:05 <musasabi> twb: what are you doing?
10:36:25 <twb> Basically trying to implement a parser for reST markup.
10:36:33 <musasabi> reST ?
10:36:34 <twb> http://docutils.sf.net/
10:36:44 <twb> (I'm in a bit over my head, to be honest :-)
10:36:59 <mahogny> parsec should be able to cover simple markup as well. it's really general
10:37:14 <twb> reST is not simple ^_^;
10:37:38 <mahogny> well. I'm able to parse mirc script with parsec. hence I think it should be able to parse anything :)
10:37:43 <twb> But I'd rather use parsec than anything lex+bisonesque, e.g. happy.
10:37:59 <mahogny> yes. those tools are very inflexible
10:38:58 <musasabi> twb: seems that they say that they lack a spec and that the code is the spec and that the code can be a mess of regular expressions.
10:39:09 <twb> Yes.
10:39:17 <Debolaz> mahogny: Do you know LrdMtrod?
10:39:36 <twb> They have a English-language "spec" at...
10:39:50 <twb> http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.txt
10:39:53 <mahogny> Debolaz, hrm. yes
10:40:35 <Debolaz> mahogny: Just curious. :)
10:41:09 <mahogny> Debolaz, :)
10:41:15 <arcatan> another question: how do I access command line arguments?
10:41:21 <Oejet> Lemmih: Yes, I'm safe, thank you. :)
10:42:01 <Debolaz> mahogny: I know him from efnet, he mentioned you in relation to a discussion about programming. Just wondered if it was the same person.
10:42:02 <mahogny> twb, with exception of indentation as part of language (which I find messy to implement but not impossible), the language seems easy
10:42:18 <Debolaz> Now to make haskell work.. *Sighs*
10:42:24 <Lemmih> Oejet: How's code?
10:42:26 <mahogny> Debolaz, aaah. yeah. I'm the normal target for all his therrories :)
10:42:26 <twb> mahogny: OK, maybe I'm just stupid and inexperienced.
10:42:47 <mahogny> parsec shouldn't have any trouble with it
10:43:04 <twb> I even have trouble writing a parser for sexprs.
10:44:03 <xs> arcatan: getArgs?
10:44:16 <arcatan> thanks
10:44:24 <Debolaz> I've debugged the problem with haskell linking down to the fact that something in the environment variables (Though it's not obvious what) causes it to pass -L/someotherdirectory instead of the proper -L/realpathtohaskelllibs which again causes the linking, not really mysteriously, to fail.
10:44:43 <Debolaz> However, it seems just impossible to determine what causes haskell to go ballistic with the paths.
10:46:27 <Debolaz> I can't seem to find any mentioned of this weird behaviour in the ghc documentation either.
10:48:39 <musasabi> ghc -v might help you
10:50:01 <Spark> then again it might explode in your face
10:50:37 <Debolaz> musasabi: No. The directory just appears mysteriously in the parameter list to ld, ghc doesn't mention it before.
10:50:51 <musasabi> Debolaz: not even with enough verbosity options?
10:50:53 <Oejet> Lemmih: I don't type so much Haskell at the moment.  Last month was the exam period, and this month I will work, but I might be able to sneak a Haskell line or two into at least the prototypes, so that's good.
10:51:44 <Debolaz> musasabi: No. I ran it at v5.
10:51:55 <Lemmih> Oejet: Did you do well at the exams?
10:53:06 <Debolaz> musasabi: I can put up -v5 results of good and failed runs, wait a bit..
10:55:38 <Debolaz> http://www.debolaz.com/temp/haskell.success.txt http://www.debolaz.com/temp/haskell.failure.txt
11:22:39 <musasabi> Debolaz: seems quite weird.
11:26:16 <Oejet> Lemmih: Not good, I'm afraid, I took on too much work in the fall semester.
11:31:22 <Lemmih> Oejet: You're an undergrad at DIKU, right?
11:33:18 <Debolaz> musasabi: Is it possible that I'm overlooking something very simple here, or could this be a programming error in haskell?
11:33:47 <Lemmih> s/haskell/ghc/
11:34:26 <Debolaz> Lemmih: I blame caffeine. :/
11:39:00 <Debolaz> Aight, there's definitly a programming error in ghc, -v5 is returning false information.
11:48:11 <palomer> gah
11:48:59 <palomer> http://www.rafb.net/paste/results/QmAU0F96.html <---could someone tell me how this grammar is ambiguous?
11:49:31 * SamB goes to look
11:50:48 <monochrom> What is { ... } ?
11:50:58 <SamB> what is the problem?
11:51:50 <SamB> monochrom: those are actions
11:52:01 <SamB> this appears to be for Happy
11:52:24 <SamB> well, I mean they are usually called actions..
11:54:08 <SamB> hmm...
11:54:34 <stesch> Someone wants to convince a Python user: "But if you're smart enough to have dropped C++ in favour of Python, you're smart enough to handle Haskell."
11:54:48 <SamB> I suspect this line:
11:54:50 <SamB> Application : Application Term {Application $1 $2}
11:54:50 <SamB> | Term Term {Application $1 $2}
11:54:51 <monochrom> haha
11:54:55 <SamB> well, two lines really
11:55:30 <SamB> stesch: eh. I think this person over-estimates the amount of intelligence required to drop C++ for Python...
11:55:48 * JKnecht seconds that.
11:56:11 <SamB> palomer: how is happy supposed to tell whether to recurse or not?
11:57:53 * JKnecht tries real hard, on the basis of 30 years of programming, to think of a language harder to learn than Haskell.
11:58:49 <basti_> JKnecht: ever tried prolog?
11:59:11 <JKnecht> Yep for about 20 years. No comparison.
11:59:38 <JKnecht> well some comparison, but I think Prolog is easier.
11:59:42 <basti_> heh
11:59:44 <basti_> but why?
11:59:56 <SamB> palomer: why are you trying to use Happy?
11:59:57 <Cale> Really? I found prolog a lot more indirect to program in than Haskell
11:59:58 <JKnecht> simpler model of computation.
12:00:09 <SamB> Happy makes me Sad
12:00:20 <basti_> Cale: yea that was my impression too
12:00:26 <Cale> SamB: You should try Frown then.
12:00:36 <monochrom> Suppose I have a language consisting of x, x]x, x]x]x, x]x]x]x, ... generally one or more x's interspersed by an operator called ].  How would you write a grammar for it?
12:00:37 <basti_> Cale: but you can program almost imperatively in prolog, too.
12:01:05 <Lemmih> SamB: What tracker software are you using?
12:01:05 <basti_> monochrom: (x])*x ?
12:01:09 <Debolaz> Are anybody here familiar with the internals of haskell? I need to know where it constructs the argument list for gcc when linking an executable.
12:01:09 <basti_> (regex)
12:01:14 <Heffalump> the Haskell type system is actually quite hard to learn properly, IMO
12:01:15 <SamB> Lemmih: me?
12:01:27 <Debolaz> err
12:01:30 <Debolaz> ghc, sorry.
12:01:33 <SamB> Lemmih: just the one that came with BitTornado personally
12:01:38 <basti_> Heffalump: not if you know prolog :D
12:01:50 <Heffalump> basti_: not just HM inference
12:01:50 * SamB has to eat
12:01:57 <Heffalump> random bits and pieces like type classes
12:02:02 <SamB> see you later
12:02:06 * Heffalump is off too
12:02:07 <basti_> i didn't find them -that- hard tbh
12:02:31 <Heffalump> I'm a good mathematician, and an experienced Haskell programmer, and I still occasionally run across type errors that take me a while to understand.
12:02:48 <Heffalump> and not just because the error message is bad, but because the system is complex
12:03:05 <basti_> oh
12:03:20 <Heffalump> anyway, I'm really off. Ask me some other time if you want to finish this debate :-)
12:03:20 <monochrom> Yes basti.  Similarly for CFG.  You have two cases: one for x along, and another for L ] x.  L ::= x | L ] x.  (Or you use the other recursion.)
12:03:39 <monochrom> But one thing you don't do is: L ::= x | x]x | L]x.
12:04:04 <basti_> you mean like shift/reduce conflicts?
12:04:20 <monochrom> It's redundant, not to mention that it's odd and ambiguous and shift-reduce conflicts and all that.
12:04:27 <Cale> Heffalump: yeah, but it also depends on how far you push on the type system in the first place. Usually I find myself attracted to solutions which use multiparameter typeclasses and fundeps, and then end up having to satisfy all the constraints that gives me :)
12:04:33 <basti_> i thought regex < lr(1)
12:04:47 <monochrom> But palomer's grammar is precisely like that.  Three cases.  Term; Term Term; Application Term.
12:05:38 <JKnecht> also I don't consider Prolog a general purpose programming vehicle, but Haskell is so it's sort of apples and eggplants.
12:08:05 <Cale> JKnecht: ah, I suppose in that case :)
12:10:02 <Cale> Haskell's got more to it, but I think the basics are easy enough to pick up and get started with. I sort of like the fact that it's hard to know everything there is to know about it, simply due to the kinds of libraries which people write. :)
12:10:16 <palomer> I can't help but thinking that parsing could be better handled by a classically typed language
12:10:44 <Cale> palomer: what does the type system have to do with it?
12:10:50 <monochrom> What is classically typed?
12:11:00 <palomer> Cale: what can be expressed
12:11:09 <JKnecht> parametric polymorphism.
12:11:57 <Cale> JKnecht: well, it seems to me that you want parametric polymorphism when writing something like a parser library.
12:12:21 <JKnecht> why so?
12:13:04 <JKnecht> also classically typed could mean pre-OOP, i.e. intrinsically typed.
12:13:07 <Cale> Well, you want your parsers to be able to return/act on different types of data, and to be able to combine parsers which return different types of data.
12:13:43 <musasabi> palomer: one can build a classical parser generator in Haskell if one wants.
12:13:53 <musasabi> palomer: we just don't fancy such things ;)
12:14:05 <palomer> musasabi: I mean classically typed
12:14:16 <monochrom> So I ask again. What is classically typed?
12:14:27 <musasabi> what is classically typed - C?
12:15:54 <palomer> well, erm, a classically typed language will have ((A->B)->A)->A inhabited
12:16:16 <Cale> You mean a strict language?
12:16:42 <palomer> no, I mean a type system which follows the deductive rules of classical logic
12:16:47 <Cale> ah
12:16:54 <monochrom> djinn time!
12:17:13 <palomer> @djinn ((a->b)->a)->a
12:17:15 <lambdabot> -- f cannot be realized.
12:17:25 <palomer> @djinn (a->a)->a
12:17:26 <lambdabot> -- f cannot be realized.
12:17:46 <palomer> @djinn (a->b)->(a->b)
12:17:47 <lambdabot> f a = a
12:17:49 <Cale> @type let y f = f (y f) in y
12:17:51 <lambdabot> forall t. (t -> t) -> t
12:18:13 <Cale> djinn doesn't handle recursion
12:18:17 <palomer> yeah
12:18:26 <palomer> djinn is intuitionistic
12:18:46 <glasser> what exactly does djinn do? come up with terms of various types?
12:18:51 <glasser> @djinn Bool
12:18:52 <lambdabot> f = False
12:18:52 <Cale> glasser: yeah
12:18:57 <palomer> glasser: give it a type, and you might just get a term
12:19:13 <Cale> @djinn (b -> c) -> (a -> b) -> a -> c
12:19:14 <lambdabot> f a b c = a (b c)
12:19:17 <palomer> @djinn Int
12:19:18 <lambdabot> -- f cannot be realized.
12:19:19 <glasser> does "f cannot be realized" actually mean it's impossible, o just that djinn isn't smart enough?
12:19:20 <musasabi> @djinn (a -> c) -> (b -> c) -> Either a b -> c
12:19:21 <lambdabot> f a b c =
12:19:21 <lambdabot>   case c of
12:19:21 <lambdabot>   Left d -> a d
12:19:21 <lambdabot>   Right e -> b e
12:19:24 <glasser> Ok, that answers that
12:19:34 <palomer> glasser: it means that it requires something more than what djinn can give you
12:19:44 <palomer> (not a question of smartness)
12:19:59 <glasser> it's not part of Djinn's calculus basically?
12:20:05 <Cale> glasser: Djinn will always find non-recursive solutions if they exist.
12:20:28 <Cale> (though of course, there are time/memory limitations :)
12:20:36 <glasser> gotcha
12:21:40 <monochrom> How would you use ((A->B)->A)->A for a parser?
12:22:25 <Cale> what would a term of type ((a -> b) -> a) -> a even look like?
12:23:26 <palomer> Cale: in lambda-mu?
12:23:32 <palomer> people say it looks like call/cc
12:23:35 <palomer> I don't buy it
12:23:47 <palomer> (and they never give me sufficient evidence when I ask)
12:23:59 <palomer> anyways, do you really want the term?
12:24:01 <Cale> oh, I see that
12:24:11 <Cale> it does look like call/cc sort of
12:24:14 <palomer> Cale: how?
12:25:00 <Cale> well, you're passing it a function which takes an (a -> b) (think continuation), and returns an a, and it gives you an a
12:25:34 <palomer> how is that call/cc?
12:25:43 <Cale> So it's like it grabbed the current continuation and passed it to that function in order to get a value of type a.
12:26:48 <palomer> hrm, I think you're on to something
12:26:51 <Cale> Deliciously irritating :)
12:27:09 <Cale> I can't help but hate call/cc
12:27:13 <palomer> why?
12:27:43 <Cale> It's just so clearly not a function.
12:27:58 <Cale> It's an abuse of the evaluation mechanism :)
12:28:00 <palomer> it is if continuations become first class citizens!
12:28:14 <Cale> Well, no, it's still not a function :)
12:28:21 <palomer> why not?
12:28:27 <Cale> Because it's not well-defined
12:28:34 <palomer> how so?
12:28:46 <Cale> (callcc f) doesn't always return the same value for the same input.
12:29:00 <palomer> Cale: it does if you consider the environment as part of the input
12:29:02 <monochrom> It is intuitionistically not well-defined, but classically well-defined.  You just have to embrace classical logic. :)
12:29:04 <Cale> which means it's not a function :)
12:29:32 <Cale> monochrom: no, it's still not a function either way, in the sense of mathematics.
12:29:48 <monochrom> Hmmm classical logic is not referential-transparent!!!
12:29:57 <palomer> you know that if you CPSify your program, call/cc cgets mapped to a simple lambda term
12:30:03 <palomer> and CPSification is stable
12:30:16 <palomer> monochrom: sure it is, in a different calculus
12:30:24 <palomer> check out lambda-mu
12:30:32 <Cale> It's only weirdos like logicians and functional programmers who relate the implication of a logical system to functions in any way :)
12:30:35 <monochrom> I was joking.
12:30:56 <monochrom> But I think we're all functional programmers.
12:31:05 <Cale> :)
12:31:12 * nnunley is a disfunctional programmer.
12:31:13 * palomer will have to reread my notes on lambda-mu
12:31:43 <palomer> I spent half a year in france
12:31:57 <palomer> and I wasn't able to see how ((a->b)->a)->a related to call/cc
12:32:05 <palomer> all hail #haskell !
12:32:41 <Cale> :)
12:32:56 <Cale> functional programmers are just applied logicians
12:33:38 <glasser> Does Haskell have any functions (a -> a) -> a at all? I see Djinn doesn't like it
12:33:51 <Cale> @type let y f = f (y f) in y
12:33:53 <lambdabot> forall t. (t -> t) -> t
12:34:13 * Debolaz puts on the macarena.
12:34:22 <xerox> @type Control.Monad.Fix.fix
12:34:23 <lambdabot> forall a. (a -> a) -> a
12:34:51 <xerox> (hi.)
12:34:55 <Cale> hello
12:35:03 <glasser> oh right
12:35:09 <SamB> Cale: do you mind callCC?
12:35:26 <Cale> SamB: I just said I did :)
12:35:43 <SamB> I thought you said call/cc
12:35:48 <SamB> they aren't the same thing at all!
12:35:56 <Cale> I don't mind it restricted to a monad or something, but it shouldn't be treated as a first class function.
12:36:11 <palomer> how does callCC work?
12:36:16 <SamB> @type Control.Molnad.Cont.callCC
12:36:17 <lambdabot> Couldn't find qualified module.
12:36:17 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
12:36:17 <lambdabot> \\)?
12:36:24 <SamB> @type Control.Monad.Cont.callCC
12:36:25 <lambdabot> forall (m :: * -> *) a b.
12:36:25 <lambdabot> (Control.Monad.Cont.MonadCont m) =>
12:36:25 <lambdabot> ((a -> m b) -> m a) -> m a
12:36:29 <palomer> damnit, someone give me some intuition about lambda-mu
12:36:32 <Cale> yeah, that one's okay
12:37:18 <SamB> of course, I'm still not sure what the point is exactly...
12:37:43 <Cale> It's rarely really useful, afaict
12:38:07 * palomer still doesn't see how callCC could possibly be defined
12:38:38 <SamB> palomer: go read source code?
12:39:02 <Cale> Well, it's no problem since you have a restricted type.
12:39:17 <palomer> hoogle should have links to source
12:39:32 <Cale> Could be that your MonadCont is also a MonadZero, and callCC f = mzero :)
12:39:44 <Cale> that's a cheap answer though :)
12:40:50 <Cale> Cont r a = ((a -> r) -> r)
12:41:15 <Cale> callCC :: ((a -> Cont r b) -> Cont r a) -> Cont r a
12:42:27 <Cale> @djinn-add type Cont r a = ((a -> r) -> r)
12:42:35 <Cale> @djinn-env
12:42:36 <lambdabot> data () = ()
12:42:36 <lambdabot> data Either a b = Left a | Right b
12:42:36 <lambdabot> data Maybe a = Nothing | Just a
12:42:36 <lambdabot> data Bool = False | True
12:42:36 <lambdabot> data Void
12:42:38 <lambdabot> type Not x = x -> Void
12:42:40 <lambdabot> type Cont r a = (a -> r) -> r
12:42:49 <Cale> @djinn ((a -> Cont r b) -> Cont r a) -> Cont r a
12:42:50 <lambdabot> f a b = a (\ c _ -> b c) b
12:43:15 <palomer> whoa, that's cool
12:43:37 <Oejet> Lemmih: Not quite, I'm almost half way through informatics at DTU.
12:43:44 <palomer> how is Either a b encoded in intuitionistic logic?
12:44:22 <Cale> disjunction?
12:44:41 <musasabi> either a b = a or b
12:44:47 <musasabi> (a,b) = a and b
12:44:48 <palomer> and Maybe?
12:44:49 <musasabi> etc
12:45:20 <Cale> Maybe is a bit silly.
12:45:30 <basti_> a or () ?
12:45:30 <musasabi> Maybe = Either () a
12:45:31 <Cale> Maybe a = a or true
12:45:47 <Cale> since () is obviously true :)
12:46:00 <palomer> and Bool is true or true?
12:46:15 <palomer> damnit, I had found a classically typed programming language before
12:46:21 <palomer> but I can't find it anymore
12:46:49 <Cale> well, things start breaking down there, because you have all these "proofs" of true.
12:47:08 <palomer> ok, what are the deduction rules associated with datatypes?
12:47:41 <Cale> You should ask Lennart
12:47:54 <Cale> lennart_: are you there? :)
12:48:31 <palomer> oh my, they have a programming language based on linear logic now
12:48:33 <Cale> Djinn tries to pick less trivial proofs of things now.
12:48:52 <Cale> Oh? Ski would probably like to see that, if he isn't responsible for it :)
12:49:40 <palomer> seems pretty dead though
12:49:43 <palomer> it's called lolli
12:50:10 <Cale> A google search just turned up Lygon and LLP
12:50:23 <musasabi> http://www.lix.polytechnique.fr/~dale/lolli/
12:50:44 <palomer> lygon seems pretty dead too
12:50:57 <ski> Cale : hm ?
12:51:19 <palomer> llp also seems pretty dead
12:51:39 <palomer> ski: have you heard on a programming language which is classically typed?
12:51:48 <ski> no
12:52:20 <ski> otoh lygon is based on classical linear logic .. but that's not type-system, but logic programming
12:55:02 <palomer> whoa, classical linear logic
12:55:11 <palomer> that's a really rich type system
12:55:35 <ski> m
12:56:22 <Debolaz> Hmm.. does anybody here have some familiarity with the ghc internals?
12:57:14 * ski has some code for a type-system .. with some ideas borrowed from lolli implementation .. but it's nowhere near finished state
12:57:14 <Lemmih> Debolaz: You might have better luck writing the the ghc-cvs mailing list.
12:58:14 <ski> Cale : isn't callCC supposed to satify some laws ?
12:59:04 <ski> (like e.g. 'callCC (\k -> k x) = return x')
12:59:30 <MenTaLguY> hello
12:59:34 <ski> hi MenTaLguY
12:59:43 <MenTaLguY> got sort of an interesting problem
12:59:57 <Debolaz> Lemmih: Or learn haskell well enough in 10 minutes to fix this compiler bug all by myself. :)
13:00:12 <Debolaz> (Aka, the slightly unrealistic option)
13:00:17 <MenTaLguY> let's see.. I should probably pasteboard this
13:00:30 <palomer> ski: have you seen lambda-mu calculus?
13:01:36 <ski> palomer : hm, possibly ..
13:01:58 <palomer> I still don't have any intuition whatsoever on it
13:02:16 <ski> palomer : is it where you can use 'mu k. cmd' to capture current cont in 'k' (and then 'cmd' is prolly a jump) ?
13:03:17 <palomer> mu alpha.[beta] cmd
13:04:03 <palomer> t:: = x | \x->t | (t)t | mu alpha.[beta] t
13:04:08 <palomer> that's the syntax
13:05:46 <palomer> and (mu alpha.[beta] cmd) c passes to c to every alpha continuation
13:06:21 <ski> cmd ::= alpha ^ t
13:06:22 <ski> ?
13:06:29 <ski> er, hm
13:06:42 <ski> what was '[beta]' ?
13:06:47 <ski> optional ?
13:07:09 * ski thinks he's read some paper with this, but a while ago
13:07:19 <palomer> nono, [beta] isn't optional
13:07:34 <ski> so what do the square parens mean ?
13:07:52 <palomer> it's a tag
13:07:59 <palomer> for example:
13:08:15 <ski> btw, isn't application there syntactic sugar (or at least could be) ?
13:08:23 <ski> (well, if you had pairs, i.e.)
13:08:29 <Lemmih> Debolaz: Did you find out why it only fails in 'pkgsrc'?
13:08:46 <palomer> (mu a.[b] (\x -> mu c.[a] t)) e = mu a.[b] (\x -> mu c.[a] t e)
13:09:09 <Debolaz> Lemmih: No, but I'm pretty sure it's due to a bug in ghc. I'm still working on it, trying to decipher the routines that are called for linking applications.
13:09:57 <ski> palomer : ok
13:10:29 <palomer> ski: lambda-mu is classically typed
13:10:34 <ski> yes
13:10:40 <lisppaste2> MenTaLguY pasted "cleaner way to write makeA and makeB?" at http://paste.lisp.org/display/15264
13:10:41 <palomer> ski: but I can't get any intuition about it!
13:10:45 <ski> (or .. it can be)
13:10:54 <MenTaLguY> ther we go
13:11:07 <MenTaLguY> took me a little while to reduce the code to a simpler case for paste
13:11:39 <palomer> ski: for example, I can think of lambda terms as mathematical functions (very poor model, I know) sending inputs to outputs
13:15:36 <MenTaLguY> so, any thoughts on the makeA/makeB thing?
13:16:25 <ski> you could define just one self-recursive 'a', instead of both 'a' and 'b', i guess
13:16:35 <ski> (or you could even use 'fix')
13:16:40 <ski> style question
13:17:06 <ski> 'makeB' could be rewritten with 'liftM' (or 'fmap', if you like)
13:17:36 <MenTaLguY> it's mainly makeA that I'm worried about
13:17:53 <MenTaLguY> I am forced to have a and be be separate in this case
13:17:58 <ski> palomer : tf tx  =  mu k. case tf of Fun kf -> [kf] (tx,Cont k)
13:18:19 <ski> a = A (B a bref) aref
13:18:33 <ski> a = fix (\a -> A (B a bref) aref)
13:19:06 <MenTaLguY> aha
13:19:37 <MenTaLguY> hmm
13:19:49 <ski> you could prolly use 'liftM' (or 'liftM2' or '`ap`') here, too, if you want to avoid using '<-'
13:20:44 <ski> (palomer : that's assuming we have basically 'data a -> b = Fun (Not (a,Not b))')
13:21:18 <MenTaLguY> I guess what I'm wondering is whether there's a monadic version of fix which could be brought to bear here
13:21:20 <ski> (palomer : btw, did the paper you read mention something about "critical pair" ?)
13:21:30 <ski> MenTaLguY : not needed
13:21:50 <ski> you aren't making circular IORefs, e.g.
13:21:51 <MenTaLguY> because in my real code, it's not just an IORef; there are a bunch of values which must be gotten via IO actions
13:22:17 <MenTaLguY> it looks like I've got to copy-and-paste that part of it into both makeA and makeB, and I'm not happy about that prospect
13:22:33 <ski> hm
13:22:44 <ski> copy and paste what into both makeA and makeB ?
13:23:02 <MenTaLguY> the bref <- newIORef 0 bit
13:23:13 <ski> ah
13:23:17 <MenTaLguY> which is more than just one value in the real code
13:23:38 <MenTaLguY> I think my real question is "how do I avoid that redundancy?"
13:23:41 <ski> well, you want two different IORefs here, right ?
13:23:58 <ski> (and not two references to same cell)
13:24:24 <MenTaLguY> right, the IORefs should all be distinct
13:24:48 <ski> one could do
13:24:59 <ski> do let foo = newIORef 0
13:25:04 <ski>    aref <- foo
13:25:07 <ski>    bref <- foo
13:25:09 <ski>    ...
13:25:13 <MenTaLguY> oh, no
13:25:18 <ski> dunno if that helps, here
13:25:20 <MenTaLguY> they're totally different types
13:25:26 <MenTaLguY> also they aren't all IORefs
13:25:27 <ski> hm
13:25:31 <MenTaLguY> I just picked that as an example
13:26:12 <ski> i think it'd possibly be simpler to help, if you provided a bigger example, more close to what you want
13:27:58 <ski> (palomer : hm, what about that example you gave did you not get intuition about ?)
13:29:02 <lisppaste2> MenTaLguY annotated #15264 with "something closer to the real code" at http://paste.lisp.org/display/15264#1
13:29:58 <MenTaLguY> instead of just that Unique and IORef Double, there are a whole bunch of fields in B whose values must be obtained via IO actions
13:30:42 <ski> (that 'where' is not needed you know, right ?)
13:30:49 <MenTaLguY> so imagine about five lines where you see:
13:30:49 <MenTaLguY> un <- newUnique
13:30:49 <MenTaLguY> dref <- newIORef 0
13:31:03 <MenTaLguY> hrm, actually I didn't know
13:31:07 <MenTaLguY> what would I do instead of where?
13:31:16 <MenTaLguY> other than just defining that function at the top level?
13:31:26 <ski> well
13:31:42 <ski> either, you can put a 'let' before the 'return', like
13:32:10 <ski>    let a = fix $ \a -> A (B a un dref) iref
13:32:30 <ski> (or even possibly just
13:32:30 <ski>    let a = A (B a un dref) iref
13:32:32 <ski> )
13:32:37 <ski> and then
13:32:39 <ski>    return a
13:32:49 <ski> or, you could abbreviate this to just
13:33:02 <ski>   return . fix $ \a -> A (B a un dref) iref
13:33:16 <ski> but, hm
13:33:16 <MenTaLguY> sounds good
13:33:29 <MenTaLguY> now I just need to figure out how to avoid duplicating all that work for initializing B
13:33:34 <ski> i'm not fully sure what code duplicate you're talking about here ..
13:33:45 <ski> is the the two 'newIORef 0's in 'makeA' ?
13:34:00 <ski> or, the code in 'makeB' also being in 'makeA' ?
13:34:06 <MenTaLguY> the latter
13:34:08 <ski> ok
13:34:15 <ski> hm, that should be fixable, i think
13:34:16 <MenTaLguY> I'm trying to figure how to factor that out into a common helper
13:34:20 <ski> right
13:35:34 <MenTaLguY> hmm, could I like curry B's constructor?
13:36:05 <MenTaLguY> so, the helper might have a result of IO (a -> b)?
13:36:13 <MenTaLguY> er, IO (A -> B) rather
13:38:52 <MenTaLguY> hah, that might work
13:39:49 <lisppaste2> ski annotated #15264 with "mfix" at http://paste.lisp.org/display/15264#2
13:40:28 <lisppaste2> ski annotated #15264 with "or even" at http://paste.lisp.org/display/15264#3
13:40:55 <ski> maybe one could do something with currying, too ..
13:40:59 <ski> .. hm
13:41:41 <lisppaste2> MenTaLguY annotated #15264 with "does this look sane?" at http://paste.lisp.org/display/15264#4
13:42:22 <ski> sure, that's a nice idea too
13:42:45 <ski> it's "better" in that it doesn't rely on 'mfix' showing that that's not really needed, here)
13:43:37 * MenTaLguY nods thoughtfully
13:43:47 <ski> (what you did is similar in some ways to 'attribute grammars' and 'circular programmin' i think)
13:44:31 <ski> with my 'mfix' idea, you (at least in this specific example) could just reuse the same 'makeB' .. instead of creating a new helper
13:44:37 <MenTaLguY> yeah
13:44:47 <MenTaLguY> I think I will probably end up using mfix in this case
13:44:51 <ski> so you choose the one that you like most, in your case :)
13:44:53 <ski> ok :)
13:45:05 <MenTaLguY> mfix is basically exactly what I was looking for, I realize
13:45:25 <ski> iirc there's some syntactic sugar that one can use with 'mfix'
13:45:37 <MenTaLguY> ah?
13:45:38 <ski> mdo a <- ..b..
13:45:44 <ski>     b <- ..a..
13:45:49 <ski>     return a
13:45:53 <ski> something like that
13:45:53 <MenTaLguY> ahh
13:46:02 <MenTaLguY> yes, I remember reading about the mdo extension
13:46:41 <ski> http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#mdo-notation
13:46:53 <ski> (imo somthing like
13:47:01 <ski> do rec a <- ..b..
13:47:08 <ski>        b <- ..a..
13:47:12 <ski>    return a
13:47:23 <ski>  would be nicer, though)
13:47:31 * MenTaLguY shrugs
13:47:41 <MenTaLguY> in this particular case, mfix is sufficiently clear
13:47:46 <ski> not a big matter
13:47:48 * ski nods
13:48:43 <MenTaLguY> thanks a bunch; you not only solved my problem, but helped me understand the role of fix/mfix
13:48:48 <musasabi> mdo is nice that it makes everything just work.
13:49:07 <musasabi> the bad part is that no understanding is required
13:51:25 <MenTaLguY> huh
13:51:52 <MenTaLguY> not that this is an issue for me yet, but the STM monad doesn't appear to be an instance of MonadFix
13:52:17 <MenTaLguY> is it possible to define an instance of MonadFix for it, do you think, or was that just an oversight?
14:09:20 <Lemmih> Yay. I just downloaded my very first file with Conjure.
14:09:46 <monochrom> Yay.
14:10:21 <Oejet> Lemmih: Was it pr0n?
14:10:32 <Oejet> Just kidding. :)
14:10:40 <musasabi> bittorrrent for something else than pr0n?
14:10:57 * Lemmih laughs.
14:12:43 <Lemmih> It was "Implementing functional languages" by SPJ and David Lester, actually.
14:13:54 <monochrom> That's pr0n
14:14:16 <Oejet> Explicit content. :-P
14:28:20 <machack666> happy new years to everyone!
14:28:39 <Lemmih> Happy new year!
14:28:43 <machack666> I'm looking for someone with experience bridging runtime systems, specifically cocoa.
14:29:04 <machack666> (although anyone with experience in other languages would be able to contribute, I'm sure)
14:29:40 <SamB> Lemmih: unfortunately not seeded by conjure
14:29:45 * Oejet drinks hot cocoa now.
14:30:01 <SamB> at least, I don't think it is
14:30:07 <palomer> happy new year!
14:30:23 <palomer> http://www.rafb.net/paste/results/QmAU0F96.html <--whoever tells me why this grammar is ambiguous gets a new year hug
14:30:42 <palomer> oh wait, nevermind
14:30:43 <machack666> I'm running into problems using haskell datatypes as an ivar, although the hoc distribution (Haskell-on-Cocoa) seems to suggest that this is possible
14:30:55 <palomer> actually, mind
14:30:56 <Lemmih> SamB: It will be soon, hopefully.
14:31:13 <machack666> I'm wondering if it has to do with refcounts or something different between the GC systems
14:31:26 <SamB> Lemmih: hopefully
14:31:32 <SamB> has anyone done any work on it lately?
14:31:52 <machack666> hoc-users mailing list has like 3 people on it, so I thought I might get a slightly larger slice of the pie be asking here.  :D
14:31:55 <SamB> I know I haven't in about two weeks...
14:32:40 <SamB> machack666: well, maybe you've just landed yourself in a larger pie
14:33:14 <Lemmih> SamB: I've been working on it a lot lately.
14:33:33 <SamB> Lemmih: cool. Where can I pull from?
14:33:43 <machack666> my immediate problem is that I get a haskell exception which registers itself as a breakpoint, but I'm not in a debugger.
14:33:52 <Lemmih> SamB: http://scannedinavian.org/~lemmih/conjure
14:34:17 <machack666> unfortunately, the backtrace is not very useful, as the haskell state is hidden within the haskell rts.
14:34:58 <SamB> machack666: that is indeed annoying
14:35:07 <SamB> I have the same problem whenever I get a segfault...
14:35:44 <machack666> are there debugging tools which work better for haskell?
14:36:40 <machack666> just using gdb right now
14:37:07 <SamB> machack666: not really anything of that type
14:37:13 <palomer> ok, a BIG new years hug if someone finds the ambiguity in my grammar
14:37:41 <SamB> I mean that model doesn't work well for Haskell...
14:37:50 <monochrom> which grammar?
14:38:04 <SamB> palomer: your grammar is too confusing for me!
14:38:04 <palomer> monochrom: http://www.rafb.net/paste/results/QmAU0F96.html
14:38:08 <machack666> right, what with non-deterministic evaluation
14:38:11 <palomer> it has 4 productions
14:38:16 <monochrom> I mean I think I pointed out a fundamental design flaw earlier today?
14:38:27 <palomer> oh, I missed that
14:38:30 <palomer> lemme check my highlight window
14:38:33 <machack666> unfortunately, the staring at the code until you go cross-eyed method isn't helping as much as I'd like
14:38:35 <SamB> monochrom: oh, you did?
14:39:09 <SamB> machack666: heard of the printing method?
14:39:10 <palomer> oh, and SamB asked me why I was using happy
14:39:12 <palomer> SamB: why not?
14:39:23 <SamB> machack666: of Python fame?
14:39:37 <palomer> monochrom: I don't understand the point you made earlier
14:39:42 * SamB kids
14:39:43 <monochrom> Something like "L ::= One | Two | More,  One ::= Term,  Two ::= Term Term,  More ::= L Term"  this is asking for trouble.
14:39:46 <SamB> palomer: because it doesn't have combinators, duh!
14:40:36 <monochrom> I also think someone pointed out something first before I made my observation.
14:40:37 <machack666> unfortunately, printing does not work as well, as it only shows up the first time you evaluate the expression (a la Debug.Trace.trace)
14:40:52 <palomer> SamB asked me how happy was supposed to know to recurse
14:41:12 <palomer> monochrom: but it has a 1 token look ahead
14:41:37 <SamB> machack666: there is also the Test.QuickCheck method for pure code
14:41:57 <SamB> and the plain-old imperative-style print method in the IO monad
14:42:09 <machack666> the problem now is that it's all within the IO monad, as it needs to interact with the cocoa rts
14:42:27 <machack666> does print print to stderr, or is it possible to have it do so?
14:42:44 <machack666> something along the lines of hSelect hStderr
14:42:45 <machack666> ?
14:42:56 <Lemmih> hPrint stderr ...
14:43:00 <SamB> Lemmih: wow, you've been busy!
14:43:35 <palomer> hrm, Cale` posted a parsec lexer before
14:43:38 <monochrom> So, consider input "x x" and starting symbol Exp.  What do the productions say?
14:43:56 <palomer> well, that becomes var
14:44:04 <palomer> which becomes term
14:44:21 <palomer> and then you push x, which also becomes var
14:44:24 <palomer> which becomes term
14:44:29 <palomer> which reduces to application
14:44:35 <monochrom> Why does it not become Application -> Term Term -> x x ?
14:44:35 <SamB> palomer: what do you think this is? Prolog?
14:44:53 <palomer> SamB: eh?
14:45:06 <palomer> monochrom: it is application
14:45:09 <machack666> SamB's new years resolution is to bash ever language but haskell ;D
14:45:18 * machack666 eats kids
14:45:18 <machack666> *BURP*
14:45:24 <palomer> @logs
14:45:25 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
14:45:32 <palomer> @irc
14:45:33 <lambdabot> Maybe you meant: arr ghc id
14:45:34 <SamB> machack666: huh?
14:45:38 <machack666> that was supposed to be "/me kids"
14:45:40 <palomer> is lambdabot logging this channel?
14:45:47 <machack666> keyboard shortcuts
14:46:01 <SamB> I didn't make any new years resolutions
14:46:02 <machack666> gotta hate them
14:46:04 <palomer> monochrom: but it could be parsed as expression, but then you'd look one token ahead and you'd see that it was impossible
14:46:33 <SamB> palomer: doubt it
14:46:42 <monochrom> I have my doubt too.
14:46:53 <SamB> clog seems to be running
14:46:58 <palomer> grr, could someone seach their log for when cale pasted on the list pastebin?
14:47:03 <palomer> clog?
14:47:32 <SamB> cmeme is also in the channel, actually
14:47:46 <palomer> how do I get the channel logs?
14:49:48 * SamB looks for the meme logs...
14:50:34 <dbw-LAPTOP> i have some possibly stupid questions
14:50:44 <monochrom> Ok, input is "a b c d e", starting symbol is Application.  What will happen?
14:50:55 <palomer> found it
14:51:04 <dbw-LAPTOP> does anybody have the patience for a total beginner? :-\
14:51:14 <dbw-LAPTOP> i have a file containing one line:
14:51:18 <dbw-LAPTOP> print "Hello, world!"
14:51:40 <dbw-LAPTOP> "hugs helloworld.hs" does not work, but "hugs < helloworld.hs" does.
14:52:01 <monochrom> main = putStrLn "Hello, world!"
14:52:21 <monochrom> You can still use print if you want, but methinks it's odd.
14:52:28 <dbw-LAPTOP> okay
14:52:36 <dbw-LAPTOP> how was i to know i had to use "main"?
14:52:49 * dbw-LAPTOP squints hard at the tutorial
14:53:30 <monochrom> When you're at a Haskell prompt you just use putStrLn "Hello, world!"
14:53:39 <SamB> dbw-LAPTOP: which tutorial?
14:53:47 <dbw-LAPTOP> haskell.org/tutorial
14:53:51 <palomer> does ghci automatically evaluate IO () values?
14:53:54 <monochrom> If you want a standalone program file you use main = putStrLn "Hello, world!"
14:54:00 <dbw-LAPTOP> i see
14:54:07 <monochrom> The tutorial assumes you're at a Haskell prompt.
14:54:23 <dbw-LAPTOP> huzzah, it works, thank you
14:54:27 <dbw-LAPTOP> now i have another problem
14:54:31 <palomer> @hoogle parsec
14:54:32 <lambdabot> Distribution.Setup.parseConfigureArgs :: ConfigFlags -> [String] -> [
14:54:32 <lambdabot> OptDescr a] -> IO (ConfigFlags, [a], [String])
14:54:32 <lambdabot> Distribution.Setup.parseCleanArgs :: [String] -> [OptDescr a] -> IO (Int,
14:54:32 <lambdabot> [a], [String])
14:54:32 <lambdabot> Distribution.Setup.parseCopyArgs :: CopyFlags -> [String] -> [OptDescr a]
14:54:34 <lambdabot> -> IO (CopyFlags, [a], [String])
14:54:51 <dbw-LAPTOP> relude> function :: Integer -> Integer
14:54:51 <dbw-LAPTOP> ERROR - Undefined variable "function"
14:55:26 <dbw-LAPTOP> all the code snippets in the tutorial give me complaints like this
14:55:30 <monochrom> That line function :: Integer -> Integer has to be put in a file.  Can't do it on the prompt.  Hugs shortcoming.  Sorry.
14:56:01 <machack666> palomer: Text.ParserCombinators.Parsec
14:56:06 <monochrom> So, listen. Put these two lines in a file.
14:56:14 <monochrom> function :: Integer -> Integer
14:56:20 <monochrom> function x = x + 10
14:56:31 <monochrom> Call the file silly.hs or something.
14:56:38 <dbw-LAPTOP> huh.
14:56:55 <dbw-LAPTOP> so the tutorial assumes i'm at a prompt, but NOT a hugs prompt, which is the recommended interpreter...
14:56:59 <monochrom> Run hugs.  type in ":load silly.hs".  type in "function 4".  You'll be happy.
14:57:07 <tic> dbw-LAPTOP, you cannot define functions in hugs/ghci.
14:57:33 <dbw-LAPTOP> whyever not :(
14:57:52 <tic> no idea
14:57:57 <monochrom> The tutorial doesn't actually say when to put things in a file, when to type things at the prompt.  But I'm telling you now.
14:57:58 <dbw-LAPTOP> good answer
14:58:07 <dbw-LAPTOP> monochrom: okay, thanks :)
14:58:15 <SamB> well, in ghci you can if you say "let"
14:58:59 <mcnster> it helps to think of a ghci prompt as being inside an IO () monad
14:59:15 <monochrom> There is someone who was like you and found it puzzling.  After he had figured it out he wrote up a web page for this.
15:00:00 <dbw-LAPTOP> oh
15:00:09 <dbw-LAPTOP> that would be a nice website to have
15:00:13 <JKnecht> Gawd bless the intarweb.
15:00:21 <dbw-LAPTOP> mcnster: yes, that helps.  *eye roll*
15:00:50 <mcnster> hehe
15:00:56 <mcnster> :)
15:01:39 <Cale`> It's synntactically like the inside a do-block of the IO monad, except that if you type something with non-IO type, it will enclose it in print
15:02:01 <Cale> syntactically*
15:02:05 <palomer> Cale: how do I use your lexer with parsec?
15:02:06 * dbw-LAPTOP hits pedants with a stick
15:02:10 <mcnster> cale said it more precicely *eye roll*
15:02:13 <mcnster> hehe
15:02:27 <dbw-LAPTOP> Me: this not work.
15:02:30 <dbw-LAPTOP> Cale: Monads pwn you.
15:02:39 <Cale> dbw-LAPTOP: monads pwn all
15:02:44 <dbw-LAPTOP> Me: owned, now my rectum hurts
15:03:19 <machack666> is there a c-symbol which represents the current exception in the haskell rts?
15:03:36 <Cale> palomer: well, just the same as ever, though you can't use CharParsers, for an obvious reason :) You have to parse lists of those tokens
15:03:51 <dbw-LAPTOP> so is it redundant to say "add :: Integer->Integer->Integer"
15:04:00 <dbw-LAPTOP> then "add = \x y -> x+y"
15:04:06 <SamB> machack666: current exception?
15:04:41 <Cale> dbw-LAPTOP: Well, with the monomorphism restriction, if you write add like that, you'll run into difficulties. The monomorphism restriction can be turned off though.
15:04:51 <Cale> er
15:05:05 <Cale> that is, if you write add like that, but don't include the type sig
15:05:05 <machack666> I'm trying now to access the exception when I run into the runtime error--poking around with gdb
15:05:08 <palomer> Cale: like, how do I write the parser which parses a variable?
15:05:49 <dbw-LAPTOP> and is "\x y -> x+y" more or less equivalent to the LISP "(lambda (x y) (+ x y))"
15:05:51 <machack666> when you do ghci and generate an exception, it will print on the screen; so there is some description or handler somewhere
15:05:53 <monochrom> dbw-LAPTOP:  http://www.haskell.org/hawiki/FirstSteps?action=show
15:06:03 <dbw-LAPTOP> monochrom: thanks
15:06:21 <dbw-LAPTOP> Cale: so, the answer is, no it's not redundant?
15:06:30 <monochrom> yuck it's geared towards not hugs
15:06:33 <SamB> machack666: wouldn't it be easier to stick an exception handler around the code that generates the exception?
15:06:53 <Cale> dbw-LAPTOP: yeah
15:07:01 <monochrom> But hey, the YAHT does not ask for your name anymore.
15:07:06 <Cale> dbw-LAPTOP: though you could just write add = (+), and that's the same
15:08:09 <machack666> I'm trying to use Control.Exception.setUncaughtExceptionHandler with a custom handler to inspect/print the value of the called exception, but it is never called.
15:08:12 <Cale> palomer: have a look at 'token' in Text.ParserCombinators.Parsec.Prim
15:09:42 <machack666> I'm calling setUncaightExceptionHandler as the first statement in the main function
15:09:55 <monochrom> YAHT is long, but comprehensive (covers several Haskell interpreters).  http://www.isi.edu/~hdaume/htut/
15:09:57 <Lemmih> machack666: If you running it from GHCi then the exception won't be uncaught.
15:09:59 <Cale> palomer: You'd write a bunch of simple token parsers with token, and then write your parser in terms of those.
15:10:03 <SamB> machack666: thats presumably only called if something makes its way to the very top level of a thread...
15:10:57 <palomer> Cale: what functions would I need to write?
15:11:32 <dbw-LAPTOP> okay... but once "add" is defined, with the type sig, it would be redundant to say "addthree :: Integer -> Integer" before saying "addthree = add 3"
15:11:36 <palomer> (this is _exactly_ where functors would be useful)
15:11:51 <machack666> this is being run standalone, as the application structure is not set up correctly for the Cocoa RTS unless it is wrapped in the application bundle
15:12:45 <machack666> other control.exception ideas appreciated
15:12:57 <machack666> or any way to "catch" the exception being generated
15:13:10 <Cale> palomer: hm?
15:13:26 <Lemmih> machack666: How about 'catch'?
15:13:37 <machack666> sounds logical... :D
15:13:42 <monochrom> Yeah a parser is a functor.  (A parser is a monad, so it's a functor.)
15:13:52 <Lemmih> @type Control.Exception.catch
15:13:53 <lambdabot> forall a. IO a -> (GHC.IOBase.Exception -> IO a) -> IO a
15:14:12 <Cale> monochrom: I get the sense that he's referring to ML functors
15:14:26 <monochrom> Haha but we have typeclasses.
15:14:26 <palomer> monochrom: I meant an sml functor
15:14:52 <machack666> can you be very broad in your definition of the IO action to run, i.e., main = catch (oldMain) handler?
15:15:03 <SamB> palomer: you could try TH...
15:15:08 <machack666> let me try
15:15:08 <palomer> TH?
15:15:13 <Cale> What's the problem?
15:15:19 <SamB> machack666: that probably won't help
15:15:27 <palomer> Cale: I mean, how do I create a GenParser?
15:15:37 <Cale> with 'token'
15:15:41 <Cale> token :: (tok -> String) -> (tok -> SourcePos) -> (tok -> Maybe a) -> GenParser tok st a    
15:15:53 <SamB> machack666: you probably want to do the catch around IO actions that get run from ObjC-land
15:15:54 <palomer> and what's SourcePos?
15:16:21 <Cale> Well, you probably want to extend my lexer to store SourcePos values in the tokens
15:16:23 <palomer> (and Maybe a)
15:16:28 <Cale> It's just for pretty error reporting
15:16:33 <monochrom> So, ordinary parsers assume the input is a stream of Char.  But Parsec assumes the input is a stream of t, where t is a type variable.  This is general enough.  I don't think you need sml functor yet.
15:16:42 <palomer> and the String
15:16:53 <Cale> Well, look carefully at the type. The parser is going to either accept the token or reject it
15:16:58 <Cale> and return a value of type 'a'
15:17:14 <Cale> So if it rejects, you have that function return Nothing
15:17:30 <Cale> if it's to accept the token, you return Just x for some appropriate x
15:17:31 <palomer> monochrom: an sml functor would be more appropriate, really. you could write struct Parser = Parsec(MyTokenType) where MyTokenType satisfies the Token signature
15:17:37 * SamB needs to implement this in Slate
15:17:41 <palomer> monochrom: this way, I know exactly what I need to implement
15:17:41 <machack666> SamB: part of the problem is that I'm not sure where exactly the exception is being generated, other than it appears if I try to use the haskell datatype
15:17:50 * joelr1 waves
15:17:56 <Cale> palomer: We're just using parametric polymorphism here, it's fine
15:18:01 <Cale> GenParser tok st a
15:18:03 <SamB> machack666: hmm.
15:18:07 <Cale> the second type is the token type
15:18:12 <Cale> er
15:18:13 <Cale> first
15:18:38 <Cale> tok is the token type, st is the (user) state type, and a is the return type
15:19:27 <Cale> hi joelr1 
15:19:49 <palomer> oomph
15:20:00 <SamB> palomer: this way works fantastically in the vast majority of cases (parsing lists of chars), and works with tokens also... whats the problem?
15:20:02 <palomer> I have to write 10 token functions
15:20:23 <palomer> SamB: I'm just saying that functors would be more intuitive
15:20:28 <monochrom> I don't think it's any different with or without sml functors in this case.
15:20:36 <Cale> palomer: well, you'd have to write them anyway
15:20:43 <SamB> palomer: I don't see how
15:20:48 <monochrom> You can say with sml functors things are more well-organized, but that's it.
15:20:51 * joelr1 just posted an extensive comparison of Haskell vs. Erlang
15:20:54 <joelr1> http://wagerlabs.com/articles/2006/01/01/haskell-vs-erlang-reloaded
15:21:02 <joelr1> your feeback is welcome!
15:21:10 <palomer> monochrom: exactly.
15:21:24 <monochrom> So suppose you are given a Token signature.  You still don't "know" what to implement.  You still have to read the doc.
15:21:27 <SamB> and that approach seems a bit rigid
15:21:33 <SamB> joelr1: cool
15:21:47 * SamB goes to see
15:22:06 <SamB> doc?
15:22:06 * SamB reads the source
15:22:08 <monochrom> The same with this "token" function here.  It expects three parameters.  You read the doc to find out what you should pass in.
15:22:42 <palomer> monochrom: with functors/signatures, the signature would tell you exactly what you need to implement
15:22:54 <SamB> if you read the source, you can see how the character parsing stuff uses it...
15:23:02 <monochrom> I can give you a signature that tells you nothing.
15:23:05 <SamB> well, it doesn't use token exactly...
15:24:00 <monochrom> I think you know what I mean but you just have a prejudice.
15:24:01 <lennart> palomer: I was just looking at logs.  Have you convinced yourself that call/cc has type ((a->b)->a)->a yet?
15:24:09 <palomer> lennart: somewhat
15:24:32 <palomer> monochrom: eh?
15:25:01 <palomer> lennart: actually, not that much
15:25:11 <palomer> lennart: care to enlighten?
15:25:16 <Cale> joelr1: I think one of your major problems is that almost nobody working with Haskell has actually had the chance to care about binary IO very much.
15:25:34 <joelr1> Cale :-)
15:25:34 <lennart> palomer: perhaps you should try to find Chet Murthy's PhD theses
15:25:38 <lennart> thesis
15:25:46 <palomer> lennart: it gives a good explanation?
15:26:15 <joelr1> Cale: true but it's not just that. it's also concurrency issues.
15:27:06 <lennart> palomer: I've not actually read his thesis, but I think it has some explanation.
15:27:10 <Cale> joelr1: that too, though I'd say more has been done with concurrency. Just nobody doing such incredibly parallel things. I don't think I've ever considered writing an app that had more than a couple of threads.
15:27:13 <musasabi> mmh, work code does efficient binary IO in Haskell.
15:27:31 <palomer> lennart: btw, what are the deductive rules associated with datatypes?
15:27:37 <esap> Some methods of designing systems produce lots of threads.
15:27:57 <lennart> palomer: for what language?
15:28:17 <SamB> esap: true
15:28:28 <joelr1> Cale: well, yes, highly-multithreaded. i got spoiled by erlang :-(
15:28:37 <joelr1> musasabi: you are fairly unique it seems 
15:29:05 <Cale> For binary IO, either we use libraries through FFI that handle it for us, or we give up and use text IO. ;) Something really ought to be done. None of the binary IO libraries I've seen have been all that pretty, and apparently don't get the performance that we'd like.
15:29:26 * esap myself have thought that having lots of threads is a sign of over-design. Context switches can be expensive.
15:29:40 <lennart> palomer: there's a fairly simple scheme for stating the rules associated with data type definitions (assuming strictly positive types) in type theory
15:29:43 <palomer> lennart: haskell (but isn't it pretty standard)
15:29:46 <SamB> esap: what context switches?
15:29:50 <Oejet> iyyupåp
15:29:52 <musasabi> joelr1: I think your problem is that you have many issues and it gets complex to find the really relevant one. It does not help that you have massive concurrency and most people don't use the picklers like you are.
15:30:16 <SamB> you don't really think Concurrent Haskell needs to context-switch on every reschedule?
15:30:17 <lennart> Oh, in Haskell.
15:30:26 <joelr1> musasabi: true. i'm devoid of all these problems now. after a 1-week erlang rewrite.
15:30:27 <palomer> lennart: oh or type theory
15:30:33 <palomer> actually, no, in haskell:o
15:30:38 <palomer> I know how to do it in type theory
15:30:44 <esap> samb: well ok, I don't know how concurrent Haskell handles context switches.
15:30:57 <palomer> lennart: for example, how would djinn handle datatypes?
15:31:00 <musasabi> esap: they are very cheap.
15:31:08 <palomer> s/would/does
15:31:09 <joelr1> musasabi: i can now think of where i could apply haskell next. it will probably take me a while.
15:31:10 <Cale> I've almost been thinking about some monadic language for binary processing which compiled to fast C code to handle splitting/merging of data, which would then be buffered and lazily converted to Haskell types.
15:31:28 <lennart> palomer: in Haskell the constructors behave just like ordinary functions, and then you get the elimination rule via case.
15:31:34 <palomer> Cale: what does the a in (tok -> Maybe a) represent?
15:31:42 <joelr1> Cale: interesting. please look at the erlang bit syntax (link in my blog post) for inspiration
15:31:44 <lennart> Oh, djinn is different.
15:31:44 <Cale> palomer: the return type you want
15:31:45 <palomer> lennart: oh, I see
15:31:51 <palomer> lennart: is it?
15:32:03 <lennart> djinn doesn't handle recursive types
15:32:31 <lennart> In djinn every data type definition is translated into a sum of products.
15:33:03 <lennart> djinn uses n-ary disjunctions and conjunctions internally, so the translation is easy
15:33:09 <musasabi> Cale: usually IO is a larger problem
15:33:18 <palomer> lennart: and then it maps it back for the output?
15:33:25 <palomer> @djinn Bool
15:33:26 <lambdabot> f = False
15:33:37 <lennart> palomer: basically, yes
15:33:58 <lennart> it keeps the constructor names around during deduction
15:34:10 <palomer> lennart: but how would you prove, say, True \/ False ? (they're constructors!) 
15:34:18 <palomer> or are all constructors assumed to be provable?
15:34:28 <Cale> all constructors are obviously provable
15:34:45 <Cale> er
15:34:48 <Cale> they're proofs
15:34:55 <palomer> so or elimination doesn't require any annotation?
15:34:56 <Cale> True is a proof of Bool
15:35:00 <Cale> as is False
15:35:07 <palomer> Cale: gotcha
15:35:12 <Cale> So it can just pick one :)
15:35:23 <lennart> When you say 'data Bool = False | True'  it's internally just 'T \/ T'
15:35:35 <palomer> Cale: what if i don't want my token to return anything? 
15:35:50 <Cale> palomer: you could have it return ()
15:36:12 <palomer> but T \/ T -> T is not the identity
15:36:24 <palomer> or, rather, T -> T \/ T
15:36:34 <palomer> you need to inject on the right or on the left
15:36:41 * esap would like to find the least restriction you need to make to have a left adjoint on  A \/ _
15:36:42 <Cale> @djinn () -> Bool
15:36:43 <lambdabot> f _ = False
15:36:51 <Cale> It just picks one
15:37:12 <lennart> Yes, you need to inject.  That's aprt of the proof
15:37:15 <musasabi> The times I have used FFI for performance have been mostly related to avoiding using Handles because of performance issues.
15:37:31 <lennart> When you ask it to prove Bool it proves 'T \/ T'
15:37:38 <palomer> so haskell ignores the inject annotation
15:38:04 <lennart> No, it's the constructor that is the injection
15:38:54 <lennart> The proof of 'T \/ T' is 'inj0 ()'  (if () is the proof of T)
15:39:07 <lennart> Well, one proff is
15:39:25 <lennart> And 'inj0 ()' is translated into False
15:41:17 <palomer> Cale: how do I use lex to parse a string?
15:41:27 <palomer> err, to lexically analyze a string
15:42:01 <palomer> lennart: gotcha
15:42:10 <lennart> palomer: btw, for call/cc google Tim Griffin "A Formulae-as-Types Notion of Control"
15:42:17 <Cale> palomer: how you'd normally apply a parsec parser
15:42:18 <palomer> lennart: I read part of it
15:42:25 <lennart> ok
15:42:28 <palomer> lennart: couldn't understand it
15:42:30 <Cale> palomer: btw, I included a more complete example on the wiki
15:42:43 <palomer> Cale: but lex is a [GenParser ..]
15:42:49 * esap suggests also Crolard: Subtractive logic + its companion paper that describes coroutines
15:42:51 <Cale> palomer: it shouldn't be
15:43:04 <palomer> lexer = fmap concat (many parseToken)
15:43:06 <Cale> palomer: are you sure?
15:43:12 <Cale> right
15:43:12 <lennart> so then my advice is just to sit down and try to figure out what type call/cc must have to be well typed :)
15:43:20 <palomer> Cale: lemme check
15:43:51 <Cale> So it's a  forall st. GenParser Char st [Token]
15:43:57 <SamB> Lemmih: I notice you didn't get three of the patches that I have before you made those major changes
15:44:50 <SamB> Lemmih: probably just as well...
15:45:26 <Lemmih> I'll check 'em out.
15:45:28 <Cale> palomer: btw, I put a slightly more complete example here: http://www.haskell.org/hawiki/ScanningInHaskell
15:46:03 <Cale> I should extend it to store SourcePos values in the tokens
15:46:20 <lennart> palomer: are you still doing lambda calculus implementation?
15:46:27 <palomer> lennart: yeah
15:46:32 <palomer> still in the parsing stage:P
15:46:53 <palomer> I've finished the evaluator though
15:46:56 <lennart> hmmmm, because parsing is fun?
15:46:59 <SamB> Lemmih: want me to send them? it'd probably be faster than trying to pull them...
15:47:06 <palomer> lennart: because parsing is a pain in haskell
15:47:25 <Lemmih> SamB: Yeah, that would be nice.
15:47:25 <Cale> I think you're the only person I've ever seen complain about parsing being hard in Haskell.
15:47:35 <lennart> palomer: parsing lambda calculus is only a few lines using parsing combinators
15:47:54 <esap> parsing is fun and easy
15:47:56 <palomer> lennart: yeah, I did that
15:48:00 <SamB> though I'm not sure if they'll get through gmail unscathed with my old version of darcs...
15:48:01 <palomer> lennart: trying to expand my grammar now
15:48:10 <lennart> ah
15:48:13 <palomer> Cale: I got spoiled by sablecc
15:49:01 <SamB> Lemmih: apparantly these patches conflict badly with yours (at least, the first two)
15:49:03 <lennart> palomer: did you stick with generating fresh variables in a monad for your evaluator?
15:49:31 <palomer> lennart: yeah
15:49:45 <palomer> lennart: I remember you suggested I check which variables haven't been used yet
15:49:51 <palomer> lennart: but doesn't that amount to the same thing?
15:50:50 <Cale> palomer: and I recall you didn't end up using that nice custom monad for some reason :)
15:51:11 <lennart> palomer: yes, they end up very similar
15:51:36 <Cale> I wonder how it would be to use de Bruijn indices.
15:51:37 <lennart> palomer: you like cool stuff, you should try higher order abstract syntax
15:52:36 <lennart> I did a little experiment with different ways to implement lambda calculus.  de Bruijn was the slowest for some reason
15:52:45 <Cale> odd
15:53:08 <lennart> HOAS beat the other with two orders of magnitude in speed
15:53:14 <palomer> lennart: did you try using ints as your lambda calculus indices (not de Bruinj indices, but a simple map)
15:53:32 <lennart> Yeah, I used ints
15:53:41 <palomer> lennart: the same HOAS as what XI Hongwei describes?
15:54:16 <lennart> HOAS usually means the same thing.  I'm not sure what Hongwei description you are referring to.
15:54:29 <lennart> You can check out my code: http://www.augustsson.net/Darcs/Lambda/
15:55:03 <lennart> I need to try a few more variations like explicit substitutions
15:56:58 <palomer> lennart: do you use HOAS in cayenne?
15:57:48 <lennart> No.  I've never used HOAS in anything real.  Next time I will.
15:58:28 <lennart> Compile time reduction in Cayenne could need a speed boost.
15:58:45 <Cale> lennart: Oh, you're responsible for Cayenne? :)
15:59:07 <lennart> yep
15:59:07 <Cale> ah, you are
15:59:17 <esap> the HOAS approach creates a strange connection between the implementation language of the interpreter and the language itself.
15:59:57 <lennart> esap: yes.  And never having used it I don't know about the practical pros and cons yet.
16:00:34 <lennart> Cale: but I don't consider myself responsible for Cayenne much anymore
16:00:59 <lennart> It was an experiment.
16:02:42 <esap> lennart: I considered using something like that for my compiler's parse tree, but then decided on representing the functions with an ordinary parse tree, to be able to manipulate it better.
16:03:43 <monochrom> What is higher-order abstract syntax?  Thus, the parser returns a function, a collection of functions, etc?
16:03:44 <esap> lennart: but I suppose there might be advantages in either approach
16:03:44 <lennart> esap: yes, if hoas is a win or a loss probably depends on much you are going to manipulate the tree.
16:04:15 <machack666> Status update: catch() around the offending code worked, and revealed... a simple array bounds exception!  I was using a 1-based offset in the creation, and trying to access via a 0-based offset.  Fixed, and works!
16:04:30 <machack666> thanks for the help and suggestions
16:04:39 <palomer> Cale: your lex variable is of type lexer::GenParser Char b [Int->Token]
16:04:46 <machack666> nothing to do with the rts's involved
16:04:55 <lennart> monochrom: higher-order abstract syntax is the name usually used when you use abstraction in the implementation language to represent abstraction in the implemented language
16:04:57 <machack666> other than difficulty exposing the exception involved
16:05:10 <palomer> Cale: shouldn't it be GenParser Char b [Token] ?
16:05:49 <lennart> monochrom: so for lambda calculus in Haskell you could use the type data HOAS = HVar IdInt | HLam (HOAS -> HOAS) | HApp HOAS HOAS
16:06:25 <palomer> lennart: oh, nice
16:07:59 <Cale> palomer: that doesn't seem right, but it did have the wrong type (namely GenParser Char st ()) as I'd written it on http://www.haskell.org/hawiki/ScanningInHaskell -- try again, I just changed it
16:08:19 <Cale> (I'd added on ">> eof" without thinking enough :)
16:08:32 <Cale> I don't see where you're getting Int->Token from
16:24:32 <ndm_> anyone know how i can see a diff of the last edit to a hawiki page?
16:25:18 <SamB> ndm_: click toolbar buttons until you reach the correct one!
16:26:02 <ndm_> SamB, thanks! turns out my proifile had the toolbar turned off...
16:26:27 <SamB> ndm_: yes, thats annoying!
16:27:09 <SamB> I wonder why when you get an account the toolbar is turned off, even though you have one if you browse without an account...
16:27:42 <SamB> what is FilePath?
16:28:24 <Lemmih> @where FilePath
16:28:25 <lambdabot> http://scannedinavian.org/~lemmih/FilePath
16:29:18 <palomer> Cale: http://www.rafb.net/paste/results/KVqnrS25.html
16:29:19 <Lemmih> A cabalization of Distribution.Compat.FilePath from Cabal.
16:29:40 <palomer> lennart: so what lambdabot does when evaluating what we give it is similar to HOAS
16:31:12 <palomer> oh, I see my error
16:32:22 <lennart> palomer: i'm glad, because I didn't see any connection between lambdabot and hoas :)
16:33:32 <palomer> > (\x -> x+2) 3
16:33:34 <lambdabot> 5
16:34:01 <palomer> lennart: lambdabot takes what we give it, translates it into haskell code, and runs it, no?
16:34:15 <SamB> palomer: it *is* haskell code
16:34:23 <Cale> palomer: lambdabot uses ghc
16:34:29 <lennart> I don't really know what lambdabot does
16:34:38 <SamB> lambdabot just slaps some boilerplate on and runs it, pretty much
16:34:48 <lennart> HOAS is different from a compiler.  There's no translation involved
16:35:03 <SamB> probably with hs-plugins, but that isn't too important here...
16:35:07 <lennart> only a trivial one
16:35:19 <Cale> yeah, with hs-plugins
16:37:51 <palomer> lennart: you translate the string to an internal representation which are actual atoms of the language, no?
16:38:54 <lennart> yes, but the translation is trivial
16:39:14 <palomer> for it to be considered HOAS?
16:39:43 <lennart> well, I don't think there's a strict definitions of what it is.  But I'd say yes
16:39:44 <esap> I wonder why it's "higher order abstract syntax" and not "lower-order abstract syntax". I'd view the implementation language of the interpreter as lower than the implemented language :-)
16:40:08 <lennart> esap: the name doesn't make total sense
16:41:12 <lennart> palomer: I think the key here is that there's an easy translation both to and from HOAS
16:43:42 <palomer> you can translate from HOAS?
16:43:57 <lennart> sure
16:44:11 <lennart> otherwise it wouldn't be very interesting
16:44:23 <palomer> Cale: btw, how do I retrieve the sourcePos ?
16:44:38 <palomer> (in your code)
16:45:01 <palomer> lennart: so you're given a an element of HOAS -> HOAS and you're going to translate it back to concrete syntax?
16:45:11 <lennart> palomer: if you look at http://www.augustsson.net/Darcs/Lambda/HOAS.lhs you can see the 3 line functions translating both ways
16:45:18 <Cale> palomer: getSourcePos
16:45:38 <esap> lennart: Could this work without the 'HVar' alternative in the AST? 
16:45:49 <palomer> Cale: but your scanning code doesn't keep the position
16:46:20 <esap> lennart: if you had some error handling mechanism?
16:48:39 <lennart> esap: with some weird error handling it probably could
16:48:51 <lennart> i prefer it clean
16:49:33 <esap> lennart: HLam (HOAS -> IO HOAS) perhaps, then if variable was not found during conversion, give an error.
16:50:03 <lennart> yuk
16:50:09 <lennart> :)
16:50:13 <esap> :-)
16:50:46 <esap> When I read the code, it seemed that HVar was just used to signal an error :-)
16:52:05 <esap> but I guess toLC does need it
16:52:06 <lennart> it's also used to represent free variables
16:53:25 <esap> Why not have a constraint at top level that no free variables should exist?
16:53:49 <esap> and handle primitive operations as functions in Haskell?
16:53:54 <lennart> sure, you could artificially bind all variables at the top level.
16:54:42 <lennart> but this is supposed to be a very straightforward implementation of lambda calculus.  and it normally allows free variables
16:54:59 <lennart> furthermore, toLC needs HVar
16:55:19 <lennart> I'm not going to use exceptions when there's a nice way :)
16:56:06 <esap> heh. I've been trying to understand how to implement exceptions cleanly...
16:57:09 <lennart> continuations, perhaps
16:57:29 <esap> I don't like continuations
16:57:43 <esap> They are too messy to use, and easy to misuse
16:58:53 <lennart> have you looked at Olin Shiver's multiple return lambda calculus?
16:58:59 <SamB> Lemmih: there are an awful lot of warnings from your version of conjure...
16:59:08 <esap> lennart: no
16:59:27 <lennart> it might suit your needs
17:00:19 <esap> My current idea would be to have a left adjoint to A \/ - functor.  - \\ A -| A \/ -
17:00:52 <lennart> hmmmm, I thought you were talking about implementation? ;)
17:01:25 <esap> well, first have to decide what to implement. see http://www.kotiposti.net/epulkkin/ControlOperation.txt
17:01:25 <lennart> http://portal.acm.org/citation.cfm?id=1016864 has a link
17:02:02 <Philippa> is it available anywhere free?
17:03:08 <lennart> http://www.cc.gatech.edu/grads/d/dfisher/mrlc.ps
17:04:53 <Philippa> thanks
17:05:27 <palomer> returning multiple values? like pairs?
17:05:42 * palomer ducks
17:05:43 <lennart> no, multiple return points
17:05:55 <lennart> like goto :)
17:06:10 <lennart> it's a really nifty idea
17:06:15 <esap> is it like goto to the end of the function, or can the caller know which exit was used?
17:06:34 <palomer> lennart: anything like lambda-mu?
17:06:42 <lennart> the caller doesn't normally know
17:07:04 <lennart> palomer: hmmmm, I think Olin's stuff is more restricted
17:07:20 <lennart> but my lambda-mu is a little rusty
17:07:44 <lennart> Olin's stuff can be implemented with just a stack
17:08:15 <palomer> but it's the same idea, right?
17:09:46 <lennart> in some very broad sense, I'd say yes
17:09:59 <esap> the paper seems nice. I'll have to invest some time to reading it.
17:12:44 <psnl> is there any difference between IO [String] and [IO String] ?
17:13:09 <palomer> they aren't the same type:o?
17:13:30 <psnl> thats what I am wondering
17:13:34 <esap> psnl: list of IO actions is not the same as an IO action returning a list
17:13:49 <psnl> ok, cool
17:13:59 <esap> [IO String] is a list of IO actions.
17:14:05 <lennart> but you can convert between them
17:15:03 <psnl> I have a block of code in which the return type is [IO String] and it recurses with hGetLine calls
17:15:12 <psnl> which return IO String
17:15:23 <Lemmih> SamB: Yeah...
17:15:25 <psnl> so I'm just wondering
17:15:58 <lennart> psnl: sequence is a function worth looking at
17:16:27 <Lemmih> SamB: I'm gonna fix that, but for now I'm just developing with ghci.
17:18:37 <palomer> how do you translate foo x y = expr into lambda calculus ?
17:19:53 <palomer> like, finding a term for foo
17:20:07 <lennart> foo = \x.\y.expr ?
17:20:56 <palomer> lennart: but expr may contain foo
17:21:20 <lennart> oh, ok.  foo = Y (\foo.\x.\y.expr)
17:22:07 <lennart> it works regardless if foo is recursive or not
17:22:10 <palomer> why must a fixed point of (\foo.\x.\y.expr) be alpha/beta/eta equivalent to foo?
17:22:39 <palomer> oh, nevermind
17:22:41 <palomer> I'm an idiot
17:22:50 <lennart> well, that's normally how a recursive definition is given meaning
17:22:50 <palomer> ok, now what if we have 2 mutually recursive functions?
17:23:18 <lennart> you can make a pair of them
17:23:42 <palomer> hmm?
17:24:41 <lennart> foobar = Y (\foobar. let foo = fst foobar; bar = snd foobar in (body of foo, body of bar))
17:27:38 <palomer> is this how compilers do it?
17:27:57 <lennart> Not really.
17:28:08 <palomer> how do they do it?
17:28:17 <lennart> if you talk about real compilers
17:29:04 <lennart> well, there's usually a top level where all definitions are mutually recursive.
17:29:49 <lennart> this is easy to implement since names on the top level correspond to machine addresses in some sense
17:30:51 <lennart> If you're talking about the internal representation in real compilers, then you usually introduce a new construct for mutually recursive bindings
17:31:40 <lennart> But this is really just specialized representation for recursive tuples like i described before
17:32:07 <esap> sharing is often important issue in real compilers
17:32:14 <lennart> yes
17:33:30 <palomer> hrm, I don't see how a fixed point of that foobar function corresponds to the mutually recursive function pair
17:35:14 <palomer> is "body of" a lambda term?
17:35:49 <lennart> yeah, it's the rhs of 'foo = ...' and 'bar = ...'
17:37:02 <palomer> lennart: which may contain foo and bar
17:37:08 <lennart> yes
17:37:25 <palomer> is HOAS the easiest way to implement lambda calculus?
17:37:35 <lennart> define easy
17:37:58 <lennart> it's certainly not easy in C
17:38:33 <palomer> lennart: is it easier than what I did with substitution
17:38:42 <palomer> (in haskell)
17:38:56 <lennart> yes, in Haskell it's short
17:39:20 <palomer> is it described anywhere in detail (other than your webpage)?
17:39:38 <lennart> it must be.  it's been around for ages
17:39:41 * esap found useful description from wikipedia.
17:39:50 <esap> http://en.wikipedia.org/wiki/Higher-order_abstract_syntax
17:40:42 <lennart> It's fewlines lines of code than the other variants I tried, if that's your measure of easy.
17:40:56 <lennart> s/fewlines/fewer/
17:41:32 <lennart> Since in some way you're "cheating" and putting the substitution burden on Haskell.
17:41:43 <esap> On the other hand, it might be somewhat unfair comparison, since the HOAS approach "reuses" code from Haskell for the target language.
17:41:44 <palomer> and doesn't require the pesky State monad
17:41:58 <esap> But of course, reuse should be encouraged :-)
17:42:23 <SamB> palomer: you *don't* need State...
17:42:49 <palomer> SamB: explain again why I don't need state?
17:43:04 <Cale> You never actually need the state monad
17:43:14 <Cale> but there are times you might want it
17:43:33 <palomer> well, yeah
17:43:40 <Cale> (basically, any time that you'd otherwise have a state parameter :)
17:47:05 <lennart> palomer: btw, did I see you say that your supervisor says he invented coinduction?
17:47:33 <lennart> I thought David Park was dead.
17:47:33 <Spark> heh
17:48:01 <palomer> lennart: that's what he claims
17:48:17 <lennart> and who is he?
17:48:17 <palomer> but he called it something else
17:48:20 <Spark> my supervisor invented "false"
17:48:26 <palomer> prakash
17:48:26 <Spark> revolutionised the world of logic...
17:48:38 <palomer> lennart: he published it in the first LICS
17:48:55 <palomer> so if you have anything which predates it, I'd like to see it
17:49:12 <lennart> well, David Park did bisimulation
17:49:54 <psnl> "false" ?
17:50:03 <psnl> how old is he?
17:50:21 <Spark> i was joking
17:51:59 <lennart> Park published on bisimulation in 81
17:52:12 <psnl> good good, though I knew a haskell programmer who had redefined identity, so anything is possible
17:53:08 <Spark> didnt milner do stuff with bisimulation with CCS in the 70s
17:53:56 <lennart> yes, but David Park is usually attributed the invention of the proof technique
18:00:32 <palomer> module Lambda (eval,Term(..)) where <--hrm, is there anything wrong with this syntax?
18:01:42 <palomer> lennart: what if I have a list of mutually recursive functions?
18:02:56 <palomer> Y (\foos -> map (\x subst x (fibre x)) foos) ?
18:03:11 <palomer> yeah, that'll probably work
18:08:25 <dbw-LAPTOP> stupid question: how can i take an integer quotient of two integers (ie, floor[a/b]), without doing a shitload of conversions
18:09:49 <glasser>  is that not div?
18:09:56 <glasser> @type div
18:09:57 <lambdabot> forall a. (Integral a) => a -> a -> a
18:10:27 <glasser> I'm not sure which way div goes when an arg is negative though if you're concerned about that
18:11:07 <dbw-LAPTOP> i'm not
18:11:08 <dbw-LAPTOP> thanks
18:28:05 <Cale> > div (-3) 2
18:28:06 <lambdabot> -2
18:28:21 <Cale> > mod (-3) 2
18:28:24 <lambdabot> 1
18:28:53 <Cale> quot (-3) 2
18:28:55 <Cale> > quot (-3) 2
18:28:57 <lambdabot> -1
18:28:57 <palomer> is it possible to annotate a function with the type: I don't care what it takes but it returns an Int?
18:29:00 <Cale> > rem (-3) 2
18:29:02 <lambdabot> -1
18:29:12 <Cale> f :: a -> Int
18:29:39 <Cale> Such a function must be constant
18:30:38 <Cale> (or nonterminating, which I guess counts as constant)
18:31:18 <palomer> Couldn't match the rigid variable `z' against `[Char]'
18:31:28 <palomer> runParse::a -> z -> Maybe c
18:31:47 <Cale> maybe runParse :: a -> [Char] -> Maybe c ?
18:32:00 <Cale> though that looks wrong :)
18:32:13 <palomer> but, like, no no, it's write
18:32:18 <palomer> but why won't z match against [Char]
18:32:24 <palomer> I thought z was free
18:32:25 <Cale> because that's forall z
18:32:41 <Cale> any free variables are implicitly forall'd
18:32:48 <Cale> at the start of the type signature
18:32:56 <Cale> f :: a -> z -> Maybe c
18:32:59 <Cale> is the same as
18:33:11 <Cale> f :: forall a,z,c. a -> z -> Maybe c
18:33:37 <palomer> so, erm, it's impossible to annotate my function with It takes something, I don't care what, and returns Int
18:33:41 <Cale> f actually does care about the type of z
18:33:44 <Cale> er
18:33:52 <Cale> what type z is
18:34:06 <Cale> It doesn't ignore that parameter, so you have to specify it
18:34:08 <palomer> but I don't!
18:34:18 <Cale> hmm
18:34:30 <Cale> You can annotate the result of f directly, if that's what you want
18:34:48 <palomer> oh, true
18:35:09 <Cale> or just leave the type signature off, load the file in ghci, and type  :t runParse
18:35:11 <palomer> f a b= (..)::blargh
18:35:16 <Cale> yeah
18:35:31 <dbw-LAPTOP> is there a predefined "identity" function?  identity = \x -> x
18:35:31 <palomer> is it possible to tell ghci to load the extensions from the source file?
18:35:35 <palomer> dbw-LAPTOP: id
18:35:37 <palomer> > id
18:35:38 <Cale> yeah
18:35:39 <lambdabot>  add an instance declaration for (Show (a -> a))
18:35:41 <palomer> @type id
18:35:43 <lambdabot> forall a. a -> a
18:35:49 <Cale> {-# OPTIONS_GHC -fglasgow-exts #-}
18:35:50 <palomer> @pretty id
18:35:51 <lambdabot> "Parse error" at column 3
18:35:56 <palomer> Cale: 
18:35:56 <palomer> thx
18:36:05 <psnl> how can you input \r as a char?
18:36:18 <dbw-LAPTOP> thanks
18:36:21 <Cale> > ord '\r'
18:36:22 <lambdabot> 13
18:36:26 <Cale> > ord '\n'
18:36:28 <lambdabot> 10
18:36:35 <psnl> thnaks
18:36:57 <dbw-LAPTOP> one last stupid question... is there a heap implementation built in?
18:37:21 <Cale> heap, as in a memory manager?
18:37:27 <Cale> Or a data structure?
18:37:33 <SamB> @pretty let in id
18:37:34 <lambdabot>  i = let in id
18:37:38 <palomer> I put {-# OPTIONS_GHC -fglasgow-exts #-} on top of my source file, and ghci tells me:
18:37:43 <palomer> ERROR "/usr/lib/hugs/packages/mtl/Control/Monad/Reader.hs":46 - Haskell 98 does not support dependent parameters
18:37:58 <Cale> oh
18:38:04 <dbw-LAPTOP> data structure
18:38:11 <Cale> palomer: in hugs...
18:38:15 <palomer> yeah
18:38:25 <palomer> Cale: do you use emacs?
18:38:31 <palomer> I want to use ghci instead of hugs
18:41:12 * palomer kicks hugs
18:42:17 <Cale> dbw-LAPTOP: well, Data.Set ought to give you something similar. There's been some recent implementations of priority queues, if that's the sort of thing you want.
18:42:34 <Cale> It doesn't come with anything explicitly labelled as a heap anyway :)
18:42:57 <dbw-LAPTOP> okay
18:43:02 <Cale> palomer: I use emacs somewhat
18:43:07 <psnl> is there a normal way to strip \r off the end of lines?
18:43:19 <Cale> psnl: shouldn't that be done for you?
18:43:21 <dbw-LAPTOP> i'm doing basic little exercises in an effort to learn haskell, and it's heapsort time :P
18:44:01 <Cale> well, yeah, you can use Data.Set to sort things :)
18:44:22 <glasser> heapsort without mutable arrays seems a little tough
18:44:23 <dbw-LAPTOP> no, don't sort things for me! i have to write the sort myself
18:44:30 <dbw-LAPTOP> but implementing heaps will be a pain
18:44:36 <Cale> > S.toList (S.fromList [5,2,7,1,3])
18:44:38 <lambdabot> [1,2,3,5,7]
18:44:44 <Cale> :)
18:44:54 <glasser> that'll uniq them too of course
18:44:54 <dbw-LAPTOP> heh
18:44:57 <psnl> Cale: I don't know, The data is coming from a socket and there is a comment in the code suggesting that ghc doesn't strip \r s
18:45:00 <Cale> S is a qualified import of Data.Set in the bot
18:45:08 <glasser> > S.toList (S.fromList [5, 2, 7, 7, 1, 3])
18:45:09 <lambdabot> [1,2,3,5,7]
18:45:11 <palomer> http://www.rafb.net/paste/results/0RC1BV92.html <--how in the blazes can that print out a Maybe?
18:45:43 <glasser> palomer: throw in some more type annotations?
18:45:56 <Cale> palomer: load it in ghci and type :t runParse
18:46:34 <Cale> It sounds like you need an extra join somewhere
18:46:39 <palomer> glasser: runParse :: GenParser Token () a -> [Char] -> Maybe (Maybe a)
18:46:51 <Cale> Well, there's your answer :)
18:46:52 <palomer> run :: GenParser tok () a -> [tok] -> Maybe a
18:46:58 <palomer> but run returns a Maybe a
18:47:01 <Cale> right
18:47:09 <Cale> and then runParse wraps its result in a Just
18:47:17 <Cale> making it Maybe (Maybe a)
18:47:21 <glasser> but you're calling runParse in main
18:47:22 <palomer> Cale: does it?
18:47:27 <Cale> look
18:47:28 <palomer>         Just x -> Just (run p x) 
18:47:30 <Cale> Just x -> Just (run p x) 
18:47:32 <Cale> yeah
18:47:42 <palomer> oh, I'm being an idiot
18:48:27 <Cale> btw,  runParse p input = do x <- run lexer input; run p x
18:49:02 <Cale> You can let the Maybe monad take care of the case matching junk for you :)
18:49:19 <palomer> yay!
18:49:32 <palomer> what's the easiest way to read from a file?
18:49:40 <SamB> @type readFile
18:49:42 <Cale> probably readFile
18:49:42 <lambdabot> FilePath -> IO String
18:49:55 <palomer> nice
18:50:00 <palomer> @hoogle FilePath
18:50:00 <Cale> If you really don't want to care about all that filehandle crap :)
18:50:02 <lambdabot> Prelude.FilePath :: String
18:50:02 <lambdabot> System.IO.FilePath :: String
18:50:02 <lambdabot> Distribution.Compat.FilePath.splitFilePath :: FilePath -> (String, String,
18:50:02 <lambdabot> String)
18:50:05 <SamB> a warning!
18:50:14 <palomer> eh?
18:50:23 <SamB> you will be annoyed at other languages for not being able to do this ;-)
18:50:32 <Cale> readFile is lazy by the way
18:50:44 <Cale> It will read from disk as characters are needed
18:50:53 <Cale> so don't go deleting the file :)
18:51:10 <SamB> or, even worse, overwriting it
18:51:24 <SamB> deleting isn't as bad as overwriting
18:54:09 <palomer> SamB: not being able to do what?
18:54:48 <SamB> palomer: lazilly read in a file like that
18:55:31 <palomer> is it possible to ask haskell to give me a lambda term representation of a function?
18:55:39 <Cale> a cool thing about it is that if the file is 2 GB or whatever, no problem.
18:56:02 <palomer> (I don't feel like writing out the Y combinator)
18:56:09 <Cale> y f = f (y f)
18:56:17 <palomer> Cale: in closed form
18:56:32 <Cale> Can't you just use your parser for that?
18:56:35 <Cale> :)
18:56:51 <palomer> yeah, I guess I could:O!
18:58:49 <palomer> oh wait, I better write the typechecker before going ahead
18:58:50 <palomer> ugh.
19:03:19 <palomer> oh boy, here comes mr ugly monad, the great state
19:05:58 <space-age> hi
19:06:13 <space-age> if I dont know programming how can I learn to program in haskell?
19:06:19 <space-age> thank for help
19:06:23 <Cale> space-age: sure
19:08:17 <palomer> where are all the datastructures located again?
19:09:47 <palomer> @hoogle data
19:09:48 <lambdabot> Data.Generics.Basics.Data :: Typeable a => Data a
19:09:48 <lambdabot> Data.Generics.Basics.dataTypeOf :: Data a => a -> DataType
19:09:48 <lambdabot> Data.Generics.Basics.dataCast1 :: (Data a, Typeable1 t) => c (t a) ->
19:09:48 <lambdabot> Maybe (c a)
19:10:30 <Korollary> space-age: you're asking the chicken vs egg question. You can start by learning haskell, though.
19:13:09 <palomer> @hoogle (Eq a) => a -> b
19:13:12 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
19:13:12 <lambdabot> Prelude.id :: a -> a
19:13:12 <lambdabot> Prelude.undefined :: a
19:13:25 <palomer> hrm, is there an equality map anywhere?
19:14:00 <Korollary> palomer: What do you mean?
19:14:02 <audreyt> Data.Map ?
19:14:09 <palomer> oh, that could work
19:15:37 <Cale> space-age: oh, missed the "how" -- I recommend starting with a tutorial like YAHT
19:16:25 <palomer> ok, so now that I have experience using the State monad
19:16:30 <palomer> how do I use the reader monad?
19:17:30 <Cale> space-age: http://www.haskell.org/hawiki/FirstSteps
19:18:16 <Cale> palomer: it's similar to State, only you can't 'put' to the state, only 'ask' for the environment, which is similar to 'get'.
19:18:49 <Cale> However, there is 'local' which makes a local modification to the environment within a given computation to run
19:19:02 <Cale> @type Control.Monad.Reader.ask
19:19:04 <lambdabot> forall r (m :: * -> *).
19:19:04 <lambdabot> (Control.Monad.Reader.MonadReader r m) =>
19:19:04 <lambdabot> m r
19:19:07 <Cale> @type Control.Monad.Reader.local
19:19:09 <lambdabot> forall r (m :: * -> *) a.
19:19:09 <lambdabot> (Control.Monad.Reader.MonadReader r m) =>
19:19:09 <lambdabot> (r -> r) -> m a -> m a
19:19:35 <Cale> those are the two most interesting actions with a Reader
19:20:00 <Cale> The un-generalised types of those are:
19:20:06 <Cale> ask :: Reader r r
19:20:08 <Cale> and
19:20:21 <Cale> local :: (r -> r) -> Reader r a -> Reader r a
19:21:12 <dbw-LAPTOP> thanks for your help, all
19:22:19 <space-age> so functional programming techniques let you modularize programs in superior ways?
19:22:34 <space-age> is there a spreadsheet program for windows in haskell?
19:23:03 <space-age> can haskell deal with large data sets in high performance ways?
19:27:10 <Saulzar> Yes certainly.
19:27:14 <Saulzar> I don't think there is a spreadsheet program for windows, but only because Haskell is not massively popular. 
19:27:34 <Saulzar> Certainly it can deal with large data sets, but it has different strengths and weaknesses to other things.
19:27:59 <monochrom> There is a p2p program in haskell, that's all I know.
19:28:18 <holmesbj> how would one go about creating binding between C and Haskell for things such as.... GTK or the windows api?
19:28:41 <Saulzar> There is a gtk binding, gtk2hs
19:29:38 <rep> what's the point of fixed point combinators?
19:29:40 <Saulzar> It is done through the foreign function interface (I don't know much about it)
19:31:03 <holmesbj> ah, thanks
19:32:36 <monochrom> fixed point combinators get you fixed points.
19:33:00 <monochrom> fixed points are the whole point of programming.
19:33:19 <palomer> the whole fixed point of programming
19:33:21 <rep> they are?
19:33:25 <palomer> fixed points give you solutions to equations
19:33:49 <palomer> lennart: what are your favourite papers on type inference (easy stuff)?
19:34:48 <palomer> I'm using the fixed point combinator to implement recursion in my little interpreter
19:35:09 <rep> palomer why?
19:35:18 <rep> why not do recursion in the "regular way"?
19:35:23 <palomer> which is?
19:35:37 <monochrom> First, do you agree that programming would be rather boring and inexpressive if you did not have loops, recursions, any kind of general repetition?
19:35:52 <rep> f x n = f x (n - 1)
19:35:58 <rep> monochrom yes
19:36:16 <monochrom> Alright, general repetition = fixed point.
19:37:15 <palomer> rep: now say you wanted a lambda term representing f, how would you do it?
19:37:55 <palomer> monochrom: how do you represent a for loop as a fixed point?
19:37:56 <rep> i wouldn't
19:38:39 <palomer> the fixed point operator is useless if you want to get stuff done
19:38:51 <palomer> but useful if you want to reason
19:38:54 <rep> actuall, let f = (\x -> f x (n - 1))
19:38:58 <palomer> kind of like haskell
19:38:59 <rep> should'n tath twork?
19:39:05 <monochrom> haha
19:39:31 <palomer> rep: but, you see, you have f on both the left hand side and the right hand side
19:39:44 <rep> palomer is that wrong?
19:39:45 <palomer> it's not a lambda term, it's an equation
19:39:52 <Saulzar> I wouldn't use haskell if it was useless to get stuff done!
19:40:08 <rep> palomer why isn't it a lambda?
19:40:18 <monochrom> You can give the fixed point operator (if you're referring to such an operator in a programming language) an operational semantics, that will get things done.  Then you can give it a denotational semantics, and you can reason.
19:40:19 <palomer> rep: lambdas don't have the = symbol in them
19:44:04 <palomer> a programmer can live all his life and not ever encounter the fixed point operator
19:44:12 <palomer> and he will not be less of a programmer because of it
19:45:16 <dons> well, maybe you're a better programmer if you know about this stuff..
19:46:53 <palomer> f x = e has a solution Y (\f x-> e)
19:47:15 <palomer> wait...isn't \f x-> e = id ?
19:47:19 <monochrom> "for", "while", "map", "fold", ... these are all specialized fixed point operators.
19:47:47 <palomer> monochrom: inasmuch as they are defined by a set of equations
19:48:09 <palomer> or do you mean something else?
19:48:41 <monochrom> Yes inasmuch as they are defined by a set of equations, or equivalently by special uses of Y.
19:48:56 <palomer> special uses of Y?
19:49:17 <monochrom> I'll agree that most programmers get by with just knowing an operational semantics.
19:49:36 <palomer> what's the denotational semantics associated with Y?
19:49:41 <rep> where can one read more about these kinds of things?
19:50:06 <monochrom> least fixed point in a suitable domain.
19:51:10 <palomer>  f x = e  => f = Y (\f x -> e) , does everyone agree?
19:51:20 <monochrom> Yes.
19:51:27 <rep> what's e?
19:51:31 <psnl> maybe
19:51:34 <palomer> but isn't \f x -> e the identity function?
19:51:53 <palomer> since f = \x -> e
19:52:35 <monochrom> No.  (\f x -> e) g = (\x -> e[g/f]).
19:52:43 <dons> rep, in Barendreght, and in Pierce
19:52:53 <palomer> dons: programming and types?
19:52:59 <dons> yep
19:53:19 <palomer> monochrom: yeah, but f = \x -> e => \f ->\x->e = \f -> f = id
19:53:30 <dons> also, Harper's online book: http://www.cs.cmu.edu/~rwh/plbook/
19:53:52 <rep> oh good
19:54:00 <monochrom> May I ask you what you mean by "the identity function"?
19:54:02 <rep> i was planning to read TaPL next
19:54:10 <palomer> monochrom: \x -> x
19:54:15 <palomer> or \f -> f
19:54:17 <dons> we teach a course at unsw from that Harper's book, with TaPL in addition
19:54:34 <monochrom> Does it go like "forall v. id v = v" or does it go like "exist v. id v = v"?
19:54:44 <palomer> ooooh, harper's book has existential types
19:54:52 <palomer> ugh, I don't feel like printing this monster
19:54:57 <palomer> is there a print version?
19:55:01 <dons> of course, ML is big on that stuff :)
19:55:08 <dons> palomer, it's a draft so not yet.
19:55:12 <dons> i suggest: don't print it
19:55:16 <palomer> monochrom: id in haskell
19:55:22 <palomer> @type id
19:55:24 <lambdabot> forall a. a -> a
19:55:28 * rep downloads
19:55:28 <monochrom> Please answer my question.
19:55:34 <palomer> lambdabot just did
19:55:39 <rep> dons why not?
19:55:48 <rep> (not printing it)
19:55:52 <dons> it's big, read it online, save trees.
19:55:52 <monochrom> No, I am not asking about type.  I am asking about functionality.
19:56:13 <dons> though I guess for study dead trees are useful 
19:56:30 <palomer> monochrom: oh, forall v. id v = v
19:56:57 <dons> the questions in Harper's book can be good to work through.
19:57:00 <palomer> is a solution to exist v. id v = v a greatest fixed point?
19:57:19 <palomer> dons: omg, it doesn't even cover type inference
19:57:27 <monochrom> Thus if you have a function (\f x -> e) and I exhibit a value g such that (\f x -> e)g is not g, will you still say (\f x -> e) is the identity function?
19:57:41 <palomer> monochrom: I know my reasoning is off
19:57:47 <monochrom> Ok good.
19:57:49 <palomer> monochrom: but I'm wondering where I'm goofing up
19:58:04 <palomer> because, well, I just showed you it IS the identity function
19:58:24 <dons> palomer, yes it does.
19:58:40 <monochrom> Let's get back to CS 101.
19:59:03 <palomer> my question is: which part of my reasoning do you disagree with?
19:59:16 <monochrom> If I have a function and it behaves like f 0 = 0, will you conclude that f is the identity function over the naturals?
19:59:48 <palomer> If I have a function and I prove it's the identity, will you conclude that it isn't?
19:59:57 <palomer> a proof is as valid as a counter example.
20:00:30 <monochrom> What is your proof obligation?  State it formally and completely.  No handwaving.  (So it is easier to see what is missed.)
20:00:35 <palomer> dons: where does it cover type inference?
20:00:51 <palomer> ok, a simplified version
20:01:26 <dons> simplified == hindley-milner..
20:01:42 <rep> hm should i read this or TaPL first
20:01:44 <dons> unless he's changed the content since I last read this book.
20:01:46 <palomer> f = e => id = \f -> f = \f -> e => f = Y (\f -> e) = Y id = id
20:02:14 <palomer> dons: I was talking about my proof
20:02:22 <palomer> dons: got a chapter?
20:02:33 <monochrom> I am not asking for a proof yet.  I am asking what is the proof obligation.  What must be proven before you can conclude.
20:02:57 <dons> I seem to recall around chapter 12? been a while since I read it. the inference rules for each construct are introduced at each chapter, iirc.
20:04:10 <palomer> monochrom: well, I just proved that alpha/beta/eta equality is not sound
20:04:12 <rep> hm the chapter on concurrent ML is missing
20:04:43 <palomer> monochrom: I don't believe my proof is correct, but I'm asking where it's incorrect
20:04:52 <space-age> hi 
20:04:58 <psnl> evening
20:05:00 <space-age> can someone learn programming from scratch
20:05:03 <palomer> since, if my proof is correct, I could probably find a contradiction in ZF
20:05:08 <space-age> with just a bit of linux know how
20:05:18 <palomer> space-age: no, you're born with it
20:05:20 <space-age> haskell seems really powerful
20:05:38 <monochrom> You have mixed up "it must work for all parameters" with "it works with one parameter".  You proved the latter.
20:07:00 <palomer> monochrom: I proved that f = id (it's the last equation in my reasoning)
20:07:33 <monochrom> variable capture.
20:07:55 <palomer> monochrom: where?
20:08:04 <monochrom> \f -> f = \f -> e
20:08:43 <monochrom> You are doing \x->x = \x->e
20:09:11 <palomer> if f is eta/beta/alpha equal to e, then surely \f -> f is alpha/beta/eta equivalent to \f -> e, no?
20:09:16 <monochrom> Or in more detail, \x->x = \x->f = \x->e
20:09:46 <glasser> Why do you think f is eta/beta/alpha equal to e?
20:09:57 <Saulzar> space-age, Yes, but perhaps power is not important to begin - start with simple stuff :)
20:10:03 <monochrom> Try using de Brujn (sp?) indexing for your \x->x.  You can't rewrite x to e.
20:10:05 <palomer> glasser: because we assumed that f = e
20:10:13 <glasser> oh, I thought we assumed f x = e
20:10:23 <palomer> I simplified my assumptions:o
20:10:34 <monochrom> The assumption is ok.
20:10:55 <palomer> monochrom: a priori, I still don't see why this is illegal
20:11:53 <palomer> intuitively
20:12:08 <monochrom> http://www.google.com/search?q=variable+capture  sorry this is my last resort.
20:12:10 <dons> de Bruijn
20:12:41 <monochrom> You have \1->1  is there any rule you can rewrite 1 to e?
20:12:53 <palomer> nope
20:13:23 <palomer> but I don't see the connection
20:13:47 <monochrom> You tricked yourself by writing the deceiving \f->f rather than the safe \1->1
20:14:15 <palomer> I have to admit, I've never seen de Bruijn indices
20:14:30 <monochrom> int i=0; /* global */  int h(int i) { return i; }   What does h(2) return?
20:15:05 <dons> they're described nicely in Barendreght
20:15:12 <monochrom> Can you go like this?  int h(int i) { return i;}.  But the global i is set to 0.  int h(int i) {return 0;}.  h(2) returns 0.
20:15:22 <dons> and I think there's an exercise in Harper on them as well.
20:16:29 <palomer> h(2) returns 2
20:17:15 <palomer> monochrom: are you saying that h(2) should return 0, or are you saying that my reasoning could lead one to believe that h(2) = 0?
20:17:25 <monochrom> The latter.
20:17:30 <palomer> I don't see the connection
20:18:10 <space-age> is haskell a form of lisp?
20:18:39 <Saulzar> space-age, No
20:19:00 <monochrom> In \f->f, that inner f is not the global f.  Whatever you know about the global f (it's e), you can't use it here.
20:19:23 <palomer> global f?
20:19:39 <monochrom> You have f=e but that's global f.
20:20:30 <palomer> monochrom: I think of f = e as simply an equation, a specification
20:22:38 <palomer> and sure if two things are equal, than one can perform any operation on either of them and have their respective results be equal too
20:22:53 <monochrom> x=0 ==> id = \x->x = \x->0 = const 0.  You're doing this.
20:23:17 <palomer> monochrom: yes, it's wrong in so many ways, and I don't see why
20:23:44 <monochrom> "if two things are equal", yes, if.  Here the two things are not equal.
20:23:56 <Saulzar> You're re-abusing x by using it as a parameter as well as in your global assumption
20:24:41 <Saulzar> > let x = 0 in f x = x in f 5
20:24:42 <lambdabot>  parse error on input `='
20:24:48 <Saulzar> > let x = 0; f x = x in f 5
20:24:49 <lambdabot> 5
20:25:18 <palomer> Saulzar: re-abusing x? 
20:25:47 <monochrom> You tried to use the same name.  But they aren't even in the same namespace.  One is outside, one is inside.  One is free, one is bound.
20:26:45 <palomer> monochrom: assume e is a closed lambda term
20:26:55 <monochrom> I'm talking about x.
20:27:07 <palomer> oh, I see the problem
20:27:16 <palomer> we're not saying that two terms are equal
20:27:17 <monochrom> THANK GOD
20:27:39 <palomer> we're saying "f is a lambda term such that f = e"
20:27:46 <palomer> so you can't bind a lambda term in a lambda
20:28:01 <palomer> f = e as terms does imply absurdity
20:28:22 <palomer> phew, thought I was going nuts there
20:28:34 <monochrom> You did go nuts for half an hour.
20:29:00 <palomer> however, if f and e are really alpha/beta/eta equivalent , then \x -> f = \x -> e for any x
20:29:07 <monochrom> It's like why am I explaining Logic 101 to this grad student while I could be writing Java code.
20:30:24 <palomer> all you had to say was 'f != Variable "f" ' instead of talking about C
20:30:26 <monochrom> But you still can't go from \x->x to \x->f
20:30:47 <dons> "while I could be writing Java code" ... now monochrom has gone nuts ;)
20:31:03 <palomer> monochrom: well, if we assume that the inner x in \x -> x is actually represents a lambda term, then we can
20:31:08 <palomer> but \x -> x != id
20:31:22 <monochrom> That's topicable.
20:31:38 <palomer> that's not a word!
20:32:10 <monochrom> If you intend the inner x in \x->x to be a lamba term and not the bound variable x, why on Earth would you write \x->x in the first place?
20:32:25 <monochrom> Are you trying to set us up or something?
20:32:52 <palomer> monochrom: the fact is, I still can
20:32:58 <monochrom> Please, for your sake and our sake as well, stop using the same letter for five different things.
20:33:27 <palomer> well, yes, I wasn't doing it on purpose
20:33:30 <palomer> just seemed strange
20:33:46 <space-age> is porgramming or algorith more important
20:33:50 <space-age> programming
20:33:55 <palomer> the fact is, people don't think about these things
20:33:58 <space-age> lang flexability
20:34:06 <space-age> so haskell is no lisp?
20:34:09 <space-age> then what is it?
20:34:09 <palomer> space-age: how much programming do you know?
20:34:17 <space-age> bash shell
20:34:20 <space-age> :(
20:34:32 <palomer> space-age: I recommend C++ for starters
20:34:39 <palomer> or maybe ruby?
20:34:53 <Cale> Haskell is not a bad starting point :)
20:35:06 <gzl> no way, C++ is terrible for starters
20:35:06 <Cale> Actually, one thing you might try reading is the Haskell Road
20:35:11 <palomer> well, one good thing about haskell is that #haskell is extra friendly to newbies
20:35:29 <palomer> gzl: very easy to get started
20:35:35 <Cale> http://homepages.cwi.nl/~jve/HR/HR.ps.gz
20:35:37 <palomer> gzl: and you get to do stuff righta way
20:35:42 <gzl> confusing, complicated, big language. I disagree.
20:35:54 <palomer> you only need to use a very small subset
20:35:57 <Cale> I think that's a pre-release of the book. Anyway, it's still on the web :)
20:36:05 <monochrom> Yeah, on efnet #math, if someone uses the word "it" twice in the same sentence for two different things, I ban immediately.
20:36:15 <gzl> and it's still much more confusing than something like python to start out
20:36:43 <palomer> gzl: yeah, my second suggestion was ruby
20:36:49 <palomer> ruby and python, same difference
20:36:52 <gzl> yeah, but your first suggestion was C++. :)
20:37:05 <palomer> space-age: what do you want to do exactly?
20:37:38 <gzl> space-age: consider http://www.ibiblio.org/obp/thinkCSpy/
20:38:00 <Cale> Haskell would actually be my first suggestion, since it's rather good if you haven't been exposed to programming in other languages, and then probably Python since there's a lot of beginner materials for Python.
20:38:02 <palomer> Cale: is that book any good?
20:38:17 <Cale> palomer: It's good if you're new to programming and mathematics.
20:38:27 <palomer> oh
20:38:28 <palomer> first year CS
20:39:00 <Cale> It's really more an intro to logic, but you get some functional programming experience in there too.
20:40:04 <Cale> another good place to start would simply be YAHT -- it's not perfect, but if anything troubles you, you can come here :)
20:40:37 <Cale> space-age: you catching this? :)
20:41:00 <palomer> I've yet to meet anyone who started programming in haskell
20:41:24 <palomer> I have a friend who's a haskell nut, and he started his son on java
20:41:47 <Philippa> java is a nasty, nasty language to foist on a beginner
20:41:52 <Cale> palomer: Well, my friend did. He has a degree in mathematics, so perhaps he doesn't count. He'd had a small small bit of C++ programming, but he hated it, so I gave him Haskell, and he enjoyed that a lot more.
20:42:14 <gzl> Philippa: why?
20:42:25 <Philippa> gzl: (almost) worst of all worlds
20:42:36 <Cale> Also, we taught programming in Haskell to some kids in grade 6 using The Haskell Road, and that was pretty fun.
20:42:40 <Philippa> it really doesn't reward you for creative thinking about abstraction
20:42:57 <Cale> I can say that I taught monads to 11 year olds :)
20:42:57 <Philippa> while buffering you with just enough fluff you can't do any low level work either
20:43:09 <Philippa> cool, I knew that should be possible
20:43:25 * Philippa is currently feeling rather disappointed
20:43:45 <Cale> why disappointed?
20:43:47 <Philippa> I (think I) just figured out a type system that can infer (map show)::([exists t.Show t.t]-> String)...
20:43:48 <gzl> some schools use functional languages in the intro course
20:43:59 <Philippa> ...and I also figured out why that's not such a great thing after all
20:44:09 <gzl> so people in those courses with no background would be started on FP
20:44:19 <gzl> generally not Haskell in particular, though
20:44:55 <Cale> Haskell is a pretty big language, but you don't need to know everything there is to know about it in order to get things done
20:45:26 <Philippa> (consider map show [1,2,3] - the compiler's got to include a dictionary with each item, and unless you hardcode it it doesn't even know how to - it wouldn't with user-defined versions of map, show and the list type)
20:46:05 <Cale> Philippa: maybe runtime type information?
20:46:39 <Philippa> yeah. On *everything*.
20:46:45 <Cale> yeah
20:46:52 <monochrom> I would start my children with logo.
20:47:07 <Philippa> IOW, it comes at the cost of sucking for the kinds of application I'm most excited about using a language that can pull that kind of stunt for
20:47:18 <monochrom> It's simple, it gets drawings done easily, and it has easy recursion.
20:47:42 <monochrom> My children will grow up saying "whadaya mean loops are more intuitive?!!"
20:48:02 <Cale> I was wondering what the effects of only teaching your kids to count and add and multiply modulo 5 would be :)
20:48:10 <Philippa> except most times I've seen logo taught, kids're taught to repeat x [code]
20:48:30 <Philippa> which is essentially a loop, even if a HOFed one
20:48:50 <monochrom> Oh but I will teach them recursion. Or maybe they'll discover it anyway.
20:49:06 <Philippa> you'd better teach more of logo than any of the schools I saw use it did, then
20:49:08 <Saulzar> Hmm, but that's how you end up using things like haskell too - by defining the low level stuff in terms of recursion then combining the intuitive slightly higher level stuff, no?
20:49:29 <Philippa> Saulzar: yep
20:49:58 <Cale> Saulzar: what counts as low-level?
20:50:03 <monochrom> So, I'll put logo on the computer, and its reference manual too.  They're free to pick their tools.  I won't bias them much.  I learned programming that way anyway.
20:52:22 <Saulzar> Well, I guess all the primitives. map fold etc. Stuff which directly recurses on lists... I guess it's slightly hard to pin down.
20:52:38 <Saulzar> As recursion is certainly useful with high level stuff too.
20:53:20 <palomer> kids, I want you to draw a dodecahedron by 5pm or else no supper
20:54:29 <space-age> how can I learn computers and make a bundle of $$$
20:54:33 <space-age> thats what i wana know
20:54:41 <space-age> :-*
20:55:12 <Cale> Haskell isn't the easy route to big money, but it's perhaps a good one anyway.
20:55:34 <Cale> Learning Haskell is a good way to become a good programmer.
20:55:49 <palomer> Peirce has a new book out, if anyone cares
20:55:58 <monochrom> Go get an MCSE or something, then go around helping people remove spyware and viruses etc.  That is easy money.  Oh, the MCSE part is just for credentials, it is not useful.
20:56:13 <space-age> jeez
20:56:29 <space-age> why do most linux types say linux is better
20:56:41 <monochrom> Err, by definition?
20:56:42 <palomer> I don't
20:56:43 <space-age> and microsoft programming langs and stuff suck
20:56:57 <palomer> linux is certainly not better
20:56:58 <space-age> and lisp user says lisp is most powerful lang
20:57:07 <monochrom> Thus, most windows types say windows is better, did you notice that too?
20:57:10 <space-age> and use it you like see how other langs are useless
20:57:15 <space-age> yeah
20:57:20 <space-age> I dunno
20:57:34 <palomer> yeah, there's too much haskell patriotism in this channel
20:57:40 <palomer> down with haskell!
20:57:48 <Cale> A lot of the programming languages out there really do suck. You have to actually use them, and then use a better language to find out. It's harder to see that a programming language sucks if it's all that you program in.
20:57:49 <monochrom> So, you can decide for yourself what is better as far as you're concerned.  Don't worry what other people think.
20:59:10 <space-age> hmm
20:59:22 <space-age> so haskell is not a lisp
20:59:30 <monochrom> Moreover keep an open mind, keep looking around.  Things change.  Even though A is better today, tomorrow may be different.
20:59:30 <space-age> is it considered an imporvement over lisp?
20:59:34 <Cale> Linux is better for me because it's more flexible than most of the other operating systems out there, and more of the software that I want to run, runs on it (or runs better on it).
20:59:45 <Cale> space-age: depends who you ask
20:59:57 <Cale> It's better than common lisp, I'd say
21:00:19 <Cale> It certainly has more interesting things in it than most lispy languages do right now.
21:00:20 <monochrom> Thus, at first I thought Pascal was the best.  Then I thought C was the best.  Then I thought C++ was the best.  Then I thought Lisp was the best.  Then I thought Perl was the best.  Then I thought SML was the best.  Then I saw the pattern.
21:00:43 <monochrom> (And no, before all that, I was using basic and I did not think it was the best.)
21:01:27 <Cale> <dcnstrct> alright people the choice is clear, even the #lisp people say go with haskell so I will
21:01:36 <monochrom> haha
21:02:08 <adu> lol
21:02:38 <adu> if you have the luxury of choosing any language ya, go with haskell
21:05:41 <space-age> really?
21:05:53 <space-age> like wha tkind fo coolthings does haskell have in it that lisp does not so far
21:06:01 <space-age> lisp claims u can build anything into it
21:06:11 <Cale> Static typing.
21:06:16 <space-age> Im still trying to find thsi scheme i read about a long time ago that had APL implemented in it
21:06:25 <Cale> Basically eliminating much of the need for debugging
21:06:35 <space-age> static typing
21:06:37 <space-age> what is that
21:06:38 <Cale> (though of course it's still there)
21:06:45 <adu> space-age: 1) haskell has nicer syntax
21:06:55 <adu> space-age: 2) similar semantics to lisp
21:07:09 <Cale> Basically, the compiler makes sure that things don't behave in various bad ways before it will even let your program run.
21:07:26 <monochrom> Parser combinators are cool.
21:07:52 <Cale> I'm sure parser combinators could be done in lisp, but GHC comes with some :)
21:07:57 <monochrom> Lazy evaluation is also cool for the most part.
21:08:11 <Cale> Lazy evaluation is pretty essential
21:08:16 <Cale> :)
21:08:50 <Cale> I think that people who are doing functional programming without laziness are seriously missing out on some of the best glue for putting programs together
21:09:19 <adu> plus i like the lambda syntax, i think its pretty
21:09:37 <adu> much easier to understand than Mathematica's lambda syntax
21:09:41 <Cale> The "Why Functional Programming Matters" paper is quite clear on that point, but people seem to miss that on their first read through (so maybe it's still not clear enough?)
21:10:33 <Cale> http://www.md.chalmers.se/~rjmh/Papers/whyfp.html  by the way :)
21:11:06 <adu> Haskell: \x->(x**2) is in Mathematica: (#^2)&
21:11:18 <space-age> hmm
21:11:19 <space-age> ok
21:11:23 <space-age> in brief
21:11:28 <space-age> what does that paper say
21:11:34 <musasabi> evening
21:11:41 <Cale> space-age: read the abstract
21:11:53 <space-age> I saw that it mentions that modularizing program is essenttial and functional programming langs allow this in ways others dont
21:12:49 <Cale> space-age: I think the best thing for you to do is to actually try programming a bit. Haskell is a great starting point -- grab the YAHT tutorial, install ghc/ghci and play around a bit :)
21:13:15 <Cale> @google Yet Another Haskell Tutorial pdf
21:13:16 <lambdabot> http://www.isi.edu/~hdaume/htut/tutorial.pdf
21:13:24 <adu> space-age: as you may be able to tell, I'm mainly concerned about syntax, and yet most of the people in this room seem concerned about semantics / typing and so on, if haskell entices people both with its syntax and semantics, you should take that to imply that its a pretty damn cool language...
21:14:01 <monochrom> Ah, this is neat.  You have done shell programming.  You know that being able to do "grep '^X-Spam-Level' | sort | unique | wc -l" is essential, isn't it?
21:14:28 <monochrom> In Haskell it's   "length . List.nub . sort . filter (List.isPrefixOf "X-Spam-Level")
21:14:28 <monochrom> "
21:15:04 <Cale> and you can leave the List.'s off if you import List :)
21:15:28 <glasser> adu: I'm actually making some slides now for an intro haskell class I'm teaching soon related to that point
21:15:46 <monochrom> http://www.vex.net/~trebla/weblog/pointfree.html
21:15:47 <glasser> basically I'm going to show implementation of something like factorial in ruby, java, and haskell
21:15:51 <adu> glasser: nice
21:16:08 <glasser> and say "look, haskell looks a lot like ruby, in that it doesn't need to declare everything explicitly everywhere"
21:16:19 <glasser> and then change all the base cases from 1 to "1" or something like that
21:16:30 <adu> glasser: are you going to mention its standing in "The Language Shootoffs" as well?
21:16:33 <Cale> I like how in Haskell, the layout rule is optional, which means that there's a quick counter to C programmers who complain about it, even though you know that they'll end up using it themselves in a week anyway :)
21:16:42 <glasser> and say "look, haskell has nice compile-time errors like java for many common mistakes"
21:16:47 <adu> if i recall correctly, it was 2nd on several tests
21:17:21 <glasser> (though I might want something a little more involved than factorial, since most haskellers would put the same level of type annotations on fact that a java person would)
21:17:26 <adu> which is very good out of like 20-30 languages
21:17:34 <glasser> Cale: how is it optional?
21:17:36 <rep> glasser implement a web server in each :)
21:17:40 <adu> lol
21:17:49 <Cale> glasser: you can put curly braces and semicolons if you want
21:18:07 <Cale> > let { x = 5; y = 20 } in x * y
21:18:09 <lambdabot> 100
21:18:14 <Cale> > let x = 5; y = 20 in x * y
21:18:16 <lambdabot> 100
21:18:16 <glasser> rep: dude, I don't want to implement a web server in java!
21:18:31 <adu> glasser: have you figured out the most compact haskell factorial? is it one-part or two-part?
21:18:44 <Cale> factorial n = product [1..n]
21:18:46 <Cale> :)
21:18:51 <adu> wow
21:18:51 <rep> Cale i was gonna say :)
21:19:07 <rep> i implemented one in haskell, and it was fun
21:19:12 <rep> glasser ^-
21:19:26 <glasser> well, I was planning to do the standard obvious one, just so that the three programs looked roughly alike.  Also that this will probably be in like minute 5 of the class :)
21:19:28 <rep> it'll probably be fun in java too
21:19:35 <monochrom> How difficult is it in Java?  You just e = new JEditorPane("http://www.vex.net/~trebla/"); e.pack(); e.setVisible(true); ...
21:19:54 <Cale> monochrom: that's a web server?
21:20:07 <space-age> I feel like a beginning magic user
21:20:07 <monochrom> oops!  I misread.  It's a web browser.
21:20:24 <Cale> space-age: yeah :)
21:20:28 <adu> magic as in magick?
21:20:31 <space-age> I work in businesses where there is precious litte thought given to how to store and reuse infomation
21:20:37 <space-age> without reapeating things 100s fo times
21:21:13 <glasser> Yeah, in ruby I'd just require WEBRick
21:21:40 <rep> and in haskell you'd just import hws?
21:22:09 <glasser> :)
21:23:21 <space-age> webrick
21:23:22 <space-age> ?
21:23:24 <space-age> whats that
21:23:30 <space-age> check this out
21:23:34 <space-age> www.gobolinux.org
21:23:39 <space-age> pretty crazy eh
21:24:18 <rep> what's so crazy about it?
21:25:12 <monochrom> pretty neat, it seems
21:25:41 <glasser> Looks like OSX .app
21:26:45 <Cale> Yeah, that's probably closer to how a proper administrator would handle programs :)
21:27:26 <Cale> I think the whole "let's put everything in /usr/bin" idea is wearing thin.
21:28:40 <monochrom> Hmm, this is not bad.
21:29:19 <Cale> Especially as gnome isn't lazy, and it takes forever to display /usr/bin on my system when it asks me to pick an app.
21:34:06 <rep> so you end up with a huge PATH?
21:35:34 <Cale> That's one way to manage it. Another is to put symlinks to desired versions of things in one or more directories which get added to users paths.
21:37:06 <Cale> It'd actually nice to have all those symlinks categorised somewhat too, though not enough that path management becomes a problem. Also, a system tool can construct paths pretty easily if needs be :)
21:37:18 <Cale> be*
21:40:03 <Cale> If you want to go to a little more trouble, you could get the shell to use a specialised locate database (restricted to paths under which installed packages reside)
21:40:56 <Cale> There are lots of ways to solve the problem, and the way that it's currently done doesn't seem to scale too nicely.
21:41:37 <space-age> unix is a bugger soemtimes
21:41:49 <binary42> Rubyx/Heretix uses a symlink system. It turns out to work quite well.
21:42:31 <space-age> whats rubyz?
21:42:55 <binary42> It is a linux distro built using some ruby scripts.
21:43:18 <binary42> Rubyx is outdated and now replaced by a rewritten system called heretix.
21:44:18 <binary42> though heretix is still considered underground so support for easy install is minimal.
22:12:02 <space-age> hmm
22:13:36 <int-e> > error (map (chr.(100+)) [4,9,9])
22:13:37 <lambdabot> Add a type signature
22:13:41 <int-e> > error (map (chr.(100+)) [4,9,9]) :: Int
22:13:42 <lambdabot> Exception: hmm
22:13:51 <rep> hmm
22:14:18 <monochrom> > map (chr.(100+)) [4,9,9]
22:14:20 <lambdabot> "hmm"
22:14:39 <monochrom> Everything's alright!
22:15:49 <jlenor1_> ugh
22:15:51 <jlenor1_> I'm at school
22:16:12 <palomer_> I have types and programming languages no a web page in front of me
22:16:16 <palomer_> but I can't print it properly!
22:16:38 <musasabi> > error (concat $ replicate 100 "foobar")
22:16:39 <lambdabot> Add a type signature
22:16:43 <musasabi> > error (concat $ replicate 100 "foobar") :: ()
22:16:45 <lambdabot> Exception: foobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoob
22:16:45 <lambdabot> arfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarf
22:16:45 <lambdabot> oobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoob
22:16:45 <lambdabot> arfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarf
22:16:45 <lambdabot> oobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoob
22:16:47 <lambdabot> [4 @more lines]
22:16:57 <musasabi> > error (concat $ replicate 1000000 "foobar") :: ()
22:17:46 <palomer_> the page runs off the right side of the screen!
22:17:47 <lambdabot> Exception: foobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoob
22:17:47 <lambdabot> arfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarf
22:17:47 <lambdabot> oobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoob
22:17:47 <lambdabot> arfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarf
22:17:47 <lambdabot> oobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoob
22:17:49 <lambdabot> plugs module failed: thread killed
22:18:26 <musasabi> nice. no problem there either.
22:18:59 <rep> palomer_ url?
22:19:13 <palomer_> erm, you need vpn to access it
22:20:23 <palomer_> www.magnesium.net:~/public_html/mozilla.ps
22:21:12 <rep> http://www.magnesium.net/~palomer/mozilla.ps ?
22:21:18 <palomer_> try again
22:21:27 <palomer_> err
22:21:27 <palomer_> yeah
22:21:29 <palomer_> that's the one
22:21:49 <space-age> hmmm
22:21:49 <rep> oh they don't hvae the whole book
22:21:54 <rep> or do they?
22:21:59 <palomer_> rep, they do, but I can only download by page
22:22:03 <palomer_> sections, really
22:22:04 <rep> lame
22:22:15 <rep> i'd rather just buy it :)
22:22:17 <palomer_> but check it out: it runs off the right side of my screen!
22:22:28 <rep> very lame
22:22:42 <palomer_> very
22:22:47 <palomer_> grrrr
22:25:05 <palomer_> the world is against me
22:25:08 <tewk> What does a period(.) between functions mean?  say . pack2 . splitWords
22:25:36 <palomer_> tewk, f . g = \x -> f g x
22:26:04 <palomer_> tewk, f . g = \x -> f (g x)
22:26:12 <space-age> what is the best source code management system?
22:26:16 <palomer_> imoff!
22:26:24 <tewk> function composition right.
22:30:48 <rep> space-age cvs
22:31:19 <ricebowl> is it possible to do a cheap comparison of a large data structure in Haskell? i.e. compare pointer values
22:31:21 <space-age> what about subversion
22:31:25 <space-age> and mercutial
22:31:40 <space-age> http://www.selenic.com/mercurial/wiki/index.cgi/Mercurial
22:31:45 <space-age> mercurial
22:31:45 <ricebowl> Subversion is very nice
22:34:58 <Cale> ricebowl: No, but see http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-Mem-StableName.html
22:35:04 <musasabi> ricebowl: yes, but you don't usually want that.
22:35:45 <ricebowl> well I do right now
22:35:52 <Cale> pointer equality is somewhat meaningless when the garbage collector moves things around on you
22:36:11 <ricebowl> I have an algorithm which modifies my (potentially large) data structure iteratively until it makes no more changes
22:36:14 <m3ga> people, is there any docs on Parsec that is more up-to-date than http://www.cs.uu.nl/people/daan/download/parsec/parsec.html?
22:36:38 <ricebowl> Cale - no, if I have the same object then the pointer values will be equal regardless of whether a collection occurs
22:36:41 <musasabi> ricebowl: so make it detect whether it changed the structure in a cheap way
22:37:05 <ricebowl> musasabi - I suppose I can use unboxed tuples, but comparing by pointer value is cheapest
22:37:15 <Cale> m3ga: there is the GHC Hierarchical libraries documentation, but it's sparser
22:37:30 <Cale> m3ga: the only thing that's changed is the location of the library (what you import)
22:38:10 <ricebowl> the point is that if the initial object does not have the same address of the resultant object then obviously it was modified
22:38:12 <m3ga> so where do I import ParsecExpr from?
22:38:27 <Cale> ricebowl: well, do you mind if it's unreliable? You can't really control if the compiler decides to duplicate things.
22:38:31 <ricebowl> it is impossible to have different pointer values and the object not have been modified
22:38:40 <ricebowl> eh? That wouldn't make any sense
22:38:43 <ricebowl> why would it do that?
22:38:47 <musasabi> or the compiler being really clever and updating things in-place ;)
22:39:12 <ricebowl> well I don't think I have to worry about that heh
22:39:26 <space-age> hello
22:39:38 <space-age> what source code management system do you use?
22:39:43 <ricebowl> a bright compiler would note that I am repeatedly modifying the same object... but I don't think it will figure it out
22:39:44 <Cale> basically, nothing in the language spec, or the way that GHC works will guarantee that pointers to values mean much at all -- you should compare StableNames
22:39:45 <musasabi> space-age: darcs.
22:39:48 <ricebowl> anyway, you do have a point
22:40:07 <ricebowl> Cale - looks like pain :/
22:40:12 <ricebowl> I can use the boxed tuples strategy
22:40:12 <Cale> it's trivial
22:40:18 <musasabi> (if you are meaning a VCS)
22:40:39 <Cale> you run makeStableName on your values, and then compare for equality :)
22:41:01 <Cale> Stable names have the following property:
22:41:01 <Cale>     * If sn1 :: StableName and sn2 :: StableName and sn1 == sn2 then sn1 and sn2 were created by calls to makeStableName on the same object. 
22:41:01 <musasabi> or rather change your computation into CPS and then the worry goes away.
22:41:14 <Cale> But the reverse is not true
22:41:31 <musasabi> ricebowl: do you currently have 1) recurse, 2) return, 3) decide whether to re-recurse ?
22:41:41 <m3ga> Cale: thanks for http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
22:41:56 <musasabi> ricebowl: changing that to 1) recurse, 2) either return or re-recurse (via CPS) will help.
22:41:59 <Cale> You can have equal values (maybe even computed in the same way!) but the StableNames may not be equal.
22:42:08 <ricebowl> musasabi - I'm still working out how to write this exactly
22:42:21 <ricebowl> trying to avoid duplication of effort algorithmically
22:42:47 <musasabi> Cale: StableNames can bring nasty suprises, as differently typed values may share the same stablename.
22:42:57 <Cale> space-age: People mostly use darcs around here.
22:43:01 <ricebowl> musasabi - that's not a problem in my case...
22:43:15 <Cale> musasabi: hehe :)
22:43:38 <space-age> darcs?
22:43:46 <Cale> @where darcs
22:43:48 <space-age> what is a link to the darcs system?
22:43:48 <lambdabot> http://darcs.net/
22:43:56 <Cale> there :)
22:44:58 <m3ga> space-age: I use bzr (http://bazaar-ng.org)
22:45:04 <ricebowl> I am thinking that perhaps I can keep a list of accumulated changes. In that case, I just check for an empty list to determine if the structure has changed...
22:45:18 <Cale> or simply a boolean :)
22:45:24 <ricebowl> well, yes
22:45:25 <musasabi> ricebowl: or just a boolean
22:45:38 <space-age> wow
22:45:40 <ricebowl> but if I'm keeping a list of accumulated changes, then it's easier not to
22:45:42 <musasabi> guess which one is more easy on the GC ;)
22:45:45 <space-age> so cvs not only game in town
22:45:51 <ricebowl> I know, I know
22:46:00 <space-age> amazing how much for free on the web there is
22:46:06 <space-age> amazing
22:46:18 <ricebowl> but if I'm modifying immutable arrays, then I presume it's a bit faster to accumulate changes in a list and apply them all simultaneously
22:46:24 * musasabi goes on advocating "coding assembler like haskell"
22:46:38 <ricebowl> hah, how do you code assembler like Haskell?
22:46:40 <space-age> so hey is the webssytem wash any good?
22:46:49 <ricebowl> or are you referring to one of those functional CPU projects?
22:46:52 <musasabi> dirty and evil.
22:47:14 <musasabi> ricebowl: for immutable arrays you may want to look at DiffArrays (same interface, faster for some code)
22:47:52 <ricebowl> p'raps...
22:48:10 <ricebowl> it's already amazingly slow :|
22:48:21 <ricebowl> with n=7 it runs the same speed as my C code with n=200
22:48:40 <ricebowl> ...and I've not even completed the program :|
22:48:46 <ricebowl> it only approximates the solution at the moment
22:49:11 <musasabi> what are you trying to do?
22:49:30 <ricebowl> you mean what algorithm?
22:49:49 <ricebowl> same thing I was doing before Christmas... I'm writing the maxflow algorithm (Ford-Fulkerson)
22:49:58 <ricebowl> and yes, I know that it's available in Data.Graph
22:50:30 <space-age> php and mysql
22:50:33 <space-age> scare me
22:50:55 <ricebowl> I quickly approximate the solution with a greedy algorithm
22:50:55 <space-age> I instlaled this
22:51:06 <space-age> www.sugarcrm.com
22:51:06 <space-age> but its half assed
22:51:06 <space-age> Im full of fear
22:51:06 <space-age> lol
22:53:06 <ricebowl> I need to sleep, will hack more on this tomorrow and hopefully finish it (grr)
23:00:11 <m3ga> @show
23:00:12 <lambdabot> I hope something GOOD came in the mail today so I have a REASON to
23:00:12 <lambdabot> live!!
23:01:20 <m3ga> @map
23:01:21 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
23:08:31 <palomer>  woot, I'm finally worthy of the haskell user title
23:08:56 <icb1> what makes you say that, palomer?
23:10:02 <palomer> because I've used it?
23:27:49 <shapr> yow
23:28:20 <ikegami--> hej
23:28:24 <ikegami--> happy new year
23:28:33 <shapr> konichiwa
23:28:49 <ikegami--> :)
23:34:30 <tewk> What is (,,)?  a prefix operator?  Where is it defined?
23:34:58 <shapr> It's the three tuple builder.
23:35:11 <shapr> @type (,,) 
23:35:16 <lambdabot> forall c b a. a -> b -> c -> (a, b, c)
23:35:29 <shapr> > (,,) 1 2 3
23:35:33 <lambdabot> (1,2,3)
