00:27:41 <SOLARMASTER> If you are bored of IRC, take time to join my game at : http://sre.servegame.com, I need some beta-testers who like strategics webgames (Its a port/clone of SRE[SOLAR REALMS ELITE]), come and play
00:28:05 --- mode: ChanServ set +o shapr
00:28:09 --- kick: SOLARMASTER was kicked by shapr (Kicked by shapr)
00:28:21 <astrolabe> Good kick shapr!
00:28:34 --- mode: shapr set -o shapr
00:29:03 * shapr doesn't enjoy spam.
00:29:07 * Beelsebob kicks shapr into #unicycling
00:29:12 <shapr> :-P
00:29:14 <shapr> I'm werkin
00:29:17 <Beelsebob> :P
00:29:18 <Korollary> lies
00:29:19 <Beelsebob> borin!
00:29:38 * Beelsebob runs away for a shower
00:29:39 <astrolabe> Oh god.  Work :(
00:29:58 <astrolabe> (sorry for profanity)
00:30:15 <Korollary> Which?
00:31:10 <astrolabe> "Thou shalt not use the name of the lord thy God in vain" (not that I follow the commandments, but I don't want to offend people.
00:32:08 <Korollary> I never got that anyway.
00:38:32 <astrolabe> I think it's a matter of respect.  Anyway, work for me now.
00:39:37 <JohnMeacham> woot woot.
00:40:08 <pesco> Morning John, what's new?
00:41:06 <JohnMeacham> lots of new optimizations for jhc.
00:41:12 <Heffalump> surely you'd only be using his/her name in vain if you capitalised the 'G'?
00:41:23 <pesco> JohnMeacham: Cool. :)
00:41:32 <pesco> Heffalump: Muahahaha. :)
01:16:50 <SimonRC> hi
01:20:45 <ibid> astrolabe: i think the theory is, or at least was, that using the name summoned the deity, and you don't want a deity to get irritated with you :)
01:21:38 <ibid> astrolabe: otoh, in jewish tradition, apparently, the name of god, once fixed in tangible form, must not be broken or destroyed
01:23:26 <pesco> Oh my god, god must be pretty irritated by now, listening to all those careless crackheads. ;)
01:23:54 <shapr> I think it's more like the 'Coke' lawsuits.
01:23:54 <pesco> (wrt. him being summoned on mention of his name)
01:24:15 <shapr> Coca-Cola wants brand name recognition, they don't want to become just another soft drink.
01:26:08 <Saulzar> Are IRC logs considered tangible form?
01:26:18 <pesco> LOL
01:29:50 <pesco> Aww, "Module `Grin.DeadCode' is imported, but nothing from it is used"
01:30:27 <SimonRC> hi
01:30:47 <pesco> Hi SimonRC.
01:31:40 <pesco> JohnMeacham: How much work do you estimated it to be to make something like hs-plugins work with jhc?
01:31:47 <pesco> s/estimated/estimate/
01:32:00 <SimonRC> Muad_Dibber: Hi, Dune fan.
01:32:25 <Muad_Dibber> Hi, Simon, where I do not know what RC stands for :)
01:32:44 * SimonRC considers the problems with extending a strongly-typed program at runtime.
01:32:54 <SimonRC> Muad_Dibber: ahahha!
01:33:03 <shapr> You can do it with Template Haskell by running the program at compile time.
01:33:10 <Heffalump> doesn't jhc make a closed world assumption?
01:33:20 <Heffalump> so you'd have to be able to tell it "arbitrary code may run here"
01:33:23 <pesco> SimonRC: You got bitchX to run on your remote control?
01:33:24 <SimonRC> Muad_Dibber: there is an easy way ot find out.
01:33:34 <SimonRC> pesco: eh? what?
01:34:03 <pesco> SimonRC: Just joking! I just remembered shapr coming in as shapr770 the other day, when he got xchat working on his nokia 770. So...
01:34:04 <SimonRC> there is always the possibility that you will want to re-arrange the type system.
01:34:23 <SimonRC> pesco: Well I didn't remember :-(.
01:34:40 <pesco> SimonRC: I thought it was kind of a justom.
01:34:43 <pesco> custom.
01:38:15 <pesco> Heffalump: Hmmm. Yes, something like that would be the case, I guess.
01:39:26 <pesco> Heffalump: Nevertheless, I think the ability to extend a program at run-time is very important...
01:42:18 <pesco> Anyway, I have work to do. BBL!
01:46:33 <SimonRC> hi*2
01:47:07 <tromp> [1..3]>>"hi"
01:49:41 <SimonRC> tromp: 
01:49:45 <SimonRC> erm
01:49:55 <SimonRC> > [1..3]>>"hi"
01:49:56 <lambdabot> "hihihi"
01:55:18 --- topic: set to '["Haskell is still the language of choice for discriminating hackers","logs:","http://tunes.org/~nef/logs/haskell/","http://www.haskell.org/learning.html","http://www.haskell.org/tmrwiki/IssueFive","We put the Funk in Funktion","http://sequence.complete.org/hwn/20060123","HCAR 11/2005:","http://haskell.org/communities/"]' by SimonRC
01:55:29 <SimonRC> there, updated the hwn link
01:56:41 <araujo> Good morning.
02:13:46 <Lemmih> dcoutts: ping.
02:13:56 <dcoutts> hia Lemmih 
02:14:51 <Lemmih> The 'Messages', 'Search' and 'Todo' tabs shouldn't be hardcoded, right?
02:15:35 * Heffalump thinks the topic is too crowded
02:18:05 <dcoutts> Lemmih, right, they're only there as an example. It's just in the .glade file. Easy to remove.
02:18:38 <dcoutts> Lemmih, that area is for another category of GUI plugin, but we've not defined its roll as well as the others.
02:19:00 <dcoutts> Lemmih, they're supposed to be tool areas that correspond to the current main page.
02:19:23 <dcoutts> Lemmih, eg compile errors, search results, TODO lists.
02:28:17 <shapr> @yow !
02:28:18 <lambdabot> I'm QUIETLY reading the latest issue of "BOWLING WORLD" while my wife
02:28:18 <lambdabot> and two children stand QUIETLY BY ...
02:28:19 <Lemmih> dcoutts: So we need a interface for adding widgets to the Tools notebook? And then we create GUI specific plugins which uses the non-gui plugins?
02:28:50 <dcoutts> Lemmih, right
02:29:11 <Lemmih> dcoutts: Ie. a Gtk plugin and a ncurses plugin who both use HaskellSense to display errors?
02:30:06 <dcoutts> Lemmih, do they both display errors inline or out-of-line or both?
02:30:29 <Lemmih> inline?
02:30:36 <dcoutts> Lemmih, the curretn gtk+ one does them inline but you want some extra space to display more detail?
02:30:54 <dcoutts> inline meaning in the source code itself by highliting/underlining
02:31:12 <dcoutts> as opposed to out-of-line ie in a seperate pannel
02:31:20 <dcoutts> like the tools pannel
02:31:27 <Lemmih> We need to underline errors AND print the error msg.
02:31:53 <Lemmih> The editor abstraction should handle the underlining.
02:32:29 <dcoutts> ok so prinint the error message will use a tools tab
02:32:37 <dcoutts> in the gtk version
02:33:02 <dcoutts> and you say that CommonSense already has an API for that and now you need a GUI for it?
02:33:03 <dcoutts> right?
02:33:20 <dcoutts> which should be a tools tab
02:33:23 <Lemmih> Yeah.
02:33:36 <dcoutts> and so we need to implement that interface in the main gui
02:33:54 <dcoutts> since at the moment I've only got round to the browser views & the editor page interfaces
02:35:24 <Lemmih> And all the tabs should be page specific, right? Where do we keep the global tools?
02:35:28 <dblhelix> @seen dons
02:35:29 <lambdabot> dons is in #haskell-blah and #haskell. Last spoke 4 hours, 21 minutes and
02:35:29 <lambdabot> 17 seconds ago.
02:36:46 <dcoutts> Lemmih, I'm not sure yet. What global tools can we imagine?
02:37:08 <dcoutts> and these are global tools that need to be visible at the same time as any other page
02:37:18 <dcoutts> since we can certainly have glbal tools as pages themselves
02:37:22 <Lemmih> A global todo/fixme list.
02:38:15 <dcoutts> I guess search results can span several pages/ files
02:38:25 <dcoutts> anything else?
02:38:56 <dcoutts> I guess we could say they can live there too, they just ignore the signals telling them that thecurrent page has changed.
02:39:08 <Lemmih> yeah
02:47:53 * beelsebob_ is a fucking moron
02:48:11 * beelsebob_ has used three nested nubs and a list, rather than just using Data.Set
02:49:24 <shapr> I just blame lack of sleep.
02:50:27 <beelsebob_>     chldrn :: FileNode -> [NodeExp] -> [NodeExp]
02:50:27 <beelsebob_>     chldrn n exps = nub (newApps ++ if null newApps then [] else (chldrn n (nub (foldr ((++) . branches) [] newApps))))
02:50:30 <beelsebob_>                     where newApps = nub (foldr ((++) . (findAppsMatching ((==n) . redexParent . getNode))) [] exps)
02:50:34 <beelsebob_> eek!
02:52:55 * SimonRC goes
02:53:08 <Lemmih> dons: I'm forking hs-plugins until it's buildable with GHC-6.5.
02:53:26 <Lemmih> (or until I find something more suitable)
03:09:52 <musasabi> dons: random committed.
03:19:28 <Heffalump> beelsebob_: why not use concatMap (or concat and map) rather than that foldr?
03:40:14 <dons> Lemmih, hmm. ok. want to submit a bug report though? I'm happy to merge changes back in
03:40:53 <dons> musasabi, cheers
03:41:17 <dblhelix> dons: did you receive my e-mail message wrt hs-plugins and class dicts?
03:42:57 <Lemmih> dons: I "fixed" it by removing AltData, so a merge is probably out of the question.
03:43:40 <dons> yep, I'm thinking about this problem. let me get back to you in a day or so. i'm surprised it doesn't `just work', so I need to think why it's breaking
03:43:54 <dons> Lemmih, I want to remove AltData too. how do you make Typeables work though?
03:44:07 <dblhelix> dons: okay, tia
03:44:10 <dons> Lemmih, ah, I see you sent me a patch.
03:44:40 <dons> Lemmih, or are you ignoring typeables shared between static and dynamic code?
03:45:26 <Lemmih> dons: HIDE doesn't use dynamic exceptions.
03:45:48 <Lemmih> dons: But in HASP I worked around it with some nasty unsafeCoerce# hacks (:
03:46:07 <dons> when things are dynamic from the ground up you can ignore this problem.
03:46:15 <dons> ah, coerce, my favourite :)
03:46:43 <dons> ok, that's cool. wipe AltData from the face of the earth.
03:47:19 * Lemmih goes out to shop.
04:10:15 <dons> musasabi, ah, I see we sneaked a few more points up. but still 6 or so behind C :/
04:12:50 <dcoutts> morning JaffaCake 
04:12:57 <JaffaCake> hiya
04:16:06 <JaffaCake> musasabi: are you there?
04:22:13 * beelsebob_ tries to remember the syntax for renaming a module as you import it
04:22:40 <edwinb> import Foo as Bar I believe
04:22:47 <beelsebob_> ah, cool :)
04:23:10 <edwinb> I'd like to rename the current module sometimes, but I don't know if that's possible...
04:23:22 <beelsebob_> not import qualified Foo as Bar (....)?
04:23:45 <edwinb> that's okay too I think
04:24:26 * beelsebob_ now wonders why Set.map is undefined
04:25:37 <beelsebob_> hmm, map and unions don't appear to be defined... how odd
04:25:53 <beelsebob_> all the other Data.Set functions appear to be working
04:26:04 <musasabi> JaffaCake: here now.
04:26:12 <JaffaCake> hi there
04:26:24 <JaffaCake> just wondering if you had any news on the gethostbyname fixes?
04:26:32 <dcoutts> xerox, oh yeah, I've got createImageSurface working and my clock now draws correctly on resizing. And it frees the image data correctly.
04:26:42 <JaffaCake> we're thinking about 6.4.2 and it's one of the bugs we need to get fixed
04:27:52 <dcoutts> xerox, I've got it working so that as you resize the window it draws in a lower detail mode which is much quicker. Then when you've finnished resizing it redraws in the high quality mode.
04:28:35 <dcoutts> xerox, I use the persistent image surfaces to cache the high quality mode layers so they don't get redrawn each second.
04:28:54 <musasabi> ah, I have the code lying around.
04:29:18 <dcoutts> xerox, only the clock hands get redrawn, the other pre-drawn layers get composited into the final image.
04:30:01 <dcoutts> xerox, so I've now got all the features of the original C version, in less code and with a 30x speed improvement. :-)
04:30:13 <dcoutts> not bad I reckon
04:31:36 * musasabi creates a darcs patch against the new darcs packages.
04:31:42 <gour> dcoutts: do i hear properly?
04:31:51 <gour> 30x?
04:31:56 <dcoutts> yep
04:32:02 <Lemmih> Hiya nibro.
04:32:08 <gour> hmm..not bad
04:32:09 <nibro> hullo :)
04:32:12 <gour> lol
04:32:13 <musasabi> JaffaCake: basically it just adds a global lock, which is the only thing that does not break existing code.
04:32:21 <dcoutts> gour, mine takes 1% cpu, the original took 36%
04:32:37 * nibro is wrestling cabal... again
04:32:37 <JaffaCake> musasabi: ok, that'll do for now
04:32:45 <gour> dcoutts: good ad for haskell ;)
04:32:50 <JaffaCake> musasabi: thanks for taking the time to look into it
04:33:11 <musasabi> JaffaCake: getnameinfo is better, but it works in different ways in some cases.
04:33:21 <dcoutts> gour, actually it's not because of Haskell exactly, it because we're doing something cleverer. But using Haskell made that easier.
04:33:24 <nibro> Cannot import `Distribution.Simple':
04:33:24 <nibro>   it was found in multiple packages: Cabal-1.1.4 Cabal-1.0
04:33:24 <nibro>   (imported from Setup.hs)
04:33:45 <nibro> 1.1.4 installed as --user, 1.0 as root which I cannot touch
04:33:52 <dcoutts> nibro, which ghc version?
04:34:01 <nibro> 6.4.1, using runghc
04:34:17 <dcoutts> I thought that kind of thing was mostly fixed with 6.4.1
04:34:18 <Lemmih> nibro: --ignore-package Cabal-1.0 --package Cabal-1.1.4?
04:34:23 <gour> dcoutts:sure, but 'written in haskell' :-)
04:34:28 <dcoutts> gour, indeed
04:34:34 <JaffaCake> musasabi: I'm keen to get something better for 6.6, the old API can be completely deprecated if necessary
04:34:53 <nibro> Lemmih: tried that, same problem
04:35:03 <musasabi> ok, the getXEntry functions are inherently unsafe on some operating systems.
04:35:31 <gour> dcoutts: have you seen latest post from axel? i'll reply later. no time atm
04:35:37 <JaffaCake> musasabi: then a global lock is certainly necessary for some OSs, that's no problem
04:35:49 <dcoutts> gour, yes I have. I've not replied yet either.
04:35:57 <gour> :-)
04:36:49 <musasabi> http://cs.helsinki.fi/u/ekarttun/haskell/network.patch
04:37:42 <musasabi> JaffaCake: no, the whole idea of those functions is unsafe. Basically they have hidden state that is kept between calls and that other functions can destroy.
04:38:11 <nibro> doh, I'm too used to ghc it seems... argument order matters :-)
04:38:27 <musasabi> JaffaCake: but I think that no-one is actually uses them in a threaded application.
04:38:44 <nibro> but now I get "Could not find module Main" instead ???
04:39:02 <musasabi> the patch has variants of them that are safe.
04:39:06 <JaffaCake> musasabi: ok, I wasn't aware the API was broken, thanks
04:39:14 <JaffaCake> all the more reason to replace it
04:39:31 <Lemmih> dcoutts, dons: I've branched GHC for HIDE at http://darcs.haskell.org/ghc.hide
04:39:36 <musasabi> you might want to remove the changes to the export list for 6.4.2 so the interface is kept stable.
04:39:51 <JaffaCake> right
04:40:00 <dcoutts> Lemmih, that's so we can do what?
04:40:39 <dcoutts> Lemmih, fix stuff, test it and submit it back? What sort of stuff?
04:40:40 <Lemmih> dcoutts: That's a stable GHC-6.5. HIDE should always be buildable with that version.
04:41:03 <musasabi> JaffaCake: want to commit the faster replicateM_ (would be nice to use that instead of manually writing it in the code) ?
04:41:22 <dcoutts> Lemmih, ok
04:41:37 <JaffaCake> musasabi: I can't remember where it is.. did you send me a patch?
04:41:43 <JaffaCake> :-/
04:42:03 <musasabi> http://cs.helsinki.fi/u/ekarttun/haskell/replicateM_.patch (that is for the old darcs, but the diff is easy enough(
04:42:35 <JaffaCake> I wonder why the original isn't optimised properly
04:42:52 <JaffaCake> that might be a bug
04:44:12 <nibro> hmm, is there a bug in runhaskell, or am I just stupid?
04:44:49 <nibro> as soon as I give any argument *not* starting with -, it thinks that it's the Main module
04:45:26 <nibro> as in 'runhaskell -package foo Foo.hs', it will treat foo as the module to look for 'main' in
04:46:51 <musasabi> hmm, it seems that newer GHC versions make the original implementation better.
04:47:13 <musasabi> just tested with CVS and that makes the sequence_ (replicate ) route better
04:47:52 <musasabi> or not.
04:50:08 <nibro> oh, I *am* stupid (or unix illiterate), just putting " " around the argument pairs solved it...
04:50:45 <musasabi> JaffaCake: here are test results for replicateM_ http://youzen.b2.fi/~musasabi/test.hs
04:51:31 <musasabi> JaffaCake: seems like the original one is 10x slower on pure looping speed.
04:51:50 <JaffaCake> yes... I don't think it should be tho
04:52:03 <JaffaCake> this is probably related to the mapM_ optimisation bug we have
04:52:20 <JaffaCake> mapM_ f [n..m] should be optimised into a loop, but it isn't
04:52:56 <JaffaCake> so thanks.. we'll either fix the optimisation bug or commit your replacement
04:53:47 <musasabi> thanks
04:56:58 <Lemmih> nibro: It sounds like a bug.
04:58:00 <nibro> Lemmih, thanks for the support, then maybe I'm not stupid after all... at least it's not *only* that. :-)
05:10:21 <nibro> dons: ping
05:36:40 <glasser> Hmm. Should I expect a new install of GHC to come with everything listed in http://haskell.org/ghc/docs/latest/html/libraries/?
05:37:02 <glasser> Specifically, I just did an install of ghc via darwinports on OSX, and I don't think it installed the X11 or HGL packages
05:38:08 <neologism> check the port setting
05:46:49 <Igloo> X11 at least will probably only be built if you have the appropriate libraries
05:57:30 * SamB wonders how Bob is running what looks like mc if Dr. Wily's computer is really running Windows 20XX: Evil Scientist Edition
06:00:15 <xerox> dcoutts: hi!
06:00:24 <dcoutts> hia xerox 
06:00:37 <xerox> I'm very interesed in how did you accomplish that goal...
06:00:54 <SamB> anyone know where I can get mc for Win2kXX ESE?
06:02:54 <dcoutts> xerox, want to see the code?
06:03:01 <xerox> dcoutts: yeah.
06:03:05 <dcoutts> xerox, gobby?
06:03:13 <xerox> Okay!
06:03:19 <xerox> (I've got 0.3 now)
06:04:08 <dcoutts> xerox, me too. I've started a session
06:06:09 <ihope> Return type (m a), contained type (a -> m b).
06:07:00 <xerox> ihope: ?
06:07:09 <ihope> @type Cont callCC
06:07:10 <lambdabot> Not in scope: data constructor `Cont'
06:07:10 <lambdabot>  
06:07:10 <lambdabot> <interactive>:1:5: Not in scope: `callCC'
06:07:29 <ihope> @type Control.Monad.Cont.Cont Control.Monad.Cont.callCC
06:07:30 <lambdabot> forall (m :: * -> *) a b.
06:07:30 <lambdabot> (Control.Monad.Cont.MonadCont m) =>
06:07:30 <lambdabot> Control.Monad.Cont.Cont (m a) (a -> m b)
06:08:35 <xerox> ihope: what does it exactly mean?
06:09:03 <glasser> neologism: I don't see anything about it in the Portfile
06:09:48 <ihope> It means callCC's contained monadic type is (a -> m b), and the result of any CPS expression containing it must be m a.
06:10:28 <ihope> Well... not callCC but Cont callCC.
06:11:42 <ihope> @djinn m a -> Cont (m b) a
06:11:42 <lambdabot> -- f cannot be realized.
06:11:58 <xerox> @djinn-env
06:11:58 <lambdabot> data () = ()
06:11:58 <lambdabot> data Either a b = Left a | Right b
06:11:58 <lambdabot> data Maybe a = Nothing | Just a
06:11:58 <lambdabot> data Bool = False | True
06:11:58 <lambdabot> data Void
06:12:00 <lambdabot> type Not x = x -> Void
06:12:05 <xerox> (It doesn't have Cont)
06:12:10 <ihope> Ah.
06:12:16 <xerox> One could add it I think...
06:13:48 <ihope> @djin
06:13:48 <lambdabot> Maybe you meant: djinn djinn-add djinn-clr djinn-del djinn-env djinn-
06:13:48 <lambdabot> ver
06:13:51 <glasser> Hmm. Typing ["foo", 4] in GHC gives error messages including
06:13:59 <glasser>     Probable fix: add an instance declaration for (Num [Char])
06:14:05 <ihope> :-)
06:14:20 <ihope> Well, that would allow it to turn that 4 into a String.
06:14:22 <glasser> however, given "instance Num [Char] where" ... GHC says that it's an illegal instance declaratoin
06:14:32 <ihope> Heh...
06:15:00 <glasser> Am I doing something wrong, or is it impossible to declare that instance, and thus it's a misleading suggestion?
06:15:19 <glasser> (I mean, other than trying to define this instance at all :) )
06:15:19 <ihope> Well, are you declaring everything not declared in the class definition?
06:15:34 <glasser> No, but that would be a different error message
06:15:42 <glasser> (specifically I'm getting
06:15:43 <glasser>     Illegal instance declaration for `Num [Char]'
06:15:43 <glasser>         (The instance type must be of form (T a b c)
06:15:44 <glasser>          where T is not a synonym, and a,b,c are distinct type variables)
06:16:10 <flux__> @help djinn-add
06:16:11 <lambdabot> Define a new function type or type synonym
06:16:11 <ihope> Hmm. Maybe using String, instead?
06:16:15 <xerox> glasser: lists are omogeneous.
06:16:20 <xerox> homogeneous, whatever.
06:16:36 <glasser> xerox: I'm aware
06:17:00 <glasser> I'm not surprised that it doesn't like ["foo", 4]
06:17:16 <glasser> but the suggestion to fix it is "tell us how to turn 4 into a string", which I don't think is legal
06:17:31 <xerox> Or make an union type of your types.
06:17:43 <ihope> > [Left "foo", Right 4]
06:17:44 <lambdabot> [Left "foo",Right 4]
06:17:47 <glasser> (Can we add instances to [Foo] for particular types Foo, as opposed to [a])
06:17:59 <glasser> xerox: I understand. I'm just wondering if this suggestion is a bug in GHC
06:18:07 <xerox> glasser: oh, sorry.
06:18:47 <glasser> Like if I had typed [Succ Succ Zero, 5], and it told me to declare a Num Nat, that would make sense
06:19:26 <ihope> > (error . error) "Test"
06:19:26 <lambdabot> Add a type signature
06:19:32 <ihope> > (error . error) "Test" :: Int
06:19:33 <lambdabot> Test
06:19:43 <flux__> @djinn-add data Nat = Zero | Succ Nat
06:19:50 <flux__> hm
06:19:55 <xerox> @djinn-env
06:19:56 <lambdabot> data () = ()
06:19:56 <lambdabot> data Either a b = Left a | Right b
06:19:56 <lambdabot> data Maybe a = Nothing | Just a
06:19:56 <lambdabot> data Bool = False | True
06:19:56 <lambdabot> data Void
06:19:58 <lambdabot> type Not x = x -> Void
06:20:00 <lambdabot> Error: Recursive types are not allowed: Nat
06:20:02 <flux__> ;(
06:20:04 <xerox> :-)
06:20:20 <xerox> What about coinductives? :-)
06:20:43 <flux__> @help djinn-del
06:20:44 <lambdabot> Remove a symbol from the environment
06:20:46 <ihope> @djinn-del Nat
06:20:46 <lambdabot> Cannot parse command
06:20:54 <ihope> @djinn-del data Nat
06:20:54 <lambdabot> Cannot parse command
06:20:57 <flux__> I broke it :)
06:21:09 <flux__> @djinn-del data Nat = Zero | Succ Nat
06:21:10 <lambdabot> Cannot parse command
06:21:19 <ihope> @djinn (a -> b -> c) -> (a -> b) -> a -> c
06:21:19 <lambdabot> Cannot parse command
06:21:19 <lambdabot> f :: (a -> b -> c) -> (a -> b) -> a -> c
06:21:19 <lambdabot> f a b c = a c (b c)
06:21:25 <flux__> nice ;)
06:22:18 <ihope> @djinn-env
06:22:18 <lambdabot> data () = ()
06:22:18 <lambdabot> data Either a b = Left a | Right b
06:22:18 <lambdabot> data Maybe a = Nothing | Just a
06:22:18 <lambdabot> data Bool = False | True
06:22:18 <lambdabot> data Void
06:22:20 <lambdabot> type Not x = x -> Void
06:22:22 <lambdabot> Error: Recursive types are not allowed: Nat
06:22:33 <ihope> @djinn Coid
06:22:34 <lambdabot> Cannot parse command
06:22:34 <lambdabot> -- f cannot be realized.
06:22:37 <ihope> @djinn Void
06:22:37 <lambdabot> Cannot parse command
06:22:37 <lambdabot> -- f cannot be realized.
06:22:53 <ihope> @djinn Either a b -> Either b a
06:22:54 <lambdabot> Cannot parse command
06:22:54 <lambdabot> f :: Either a b -> Either b a
06:22:54 <lambdabot> f a =
06:22:54 <lambdabot>   case a of
06:22:54 <lambdabot>   Left b -> Right b
06:22:56 <lambdabot>   Right c -> Left c
06:23:01 <ihope> Weerd.
06:23:22 <ihope> @help djinn-clr
06:23:23 <lambdabot> Reset the djinn environment
06:24:00 <ihope> ...I'll let someone else do that one.
06:24:13 <xerox> @listcommands djinn
06:24:14 <lambdabot> djinn provides: djinn djinn-add djinn-del djinn-env djinn-clr djinn-
06:24:14 <lambdabot> ver
06:24:16 <flux__> djinn could be fun to have djiin integrated into haskell somehow (template haskell)
06:24:20 <xerox> @djinn-del Nat
06:24:20 <lambdabot> Cannot parse command
06:24:23 <flux__> s/djinn/it/
06:24:24 <xerox> @djinn-del data Nat
06:24:24 <lambdabot> Cannot parse command
06:24:31 <ihope> Yeah.
06:25:02 <flux__> so you could say, like (@Either a b -> Either b a) foo
06:25:19 <ihope> Yeah.
06:25:40 <eivuokko> Heh
06:25:44 <ihope> Yeah.
06:25:48 <glasser> Whoa. Djinn generated that Either function... without having knowledge of Either built in?
06:25:52 <glasser> I continue to be awed
06:25:56 <eivuokko> Make a preprocessor? :)
06:26:02 <ihope> Um.
06:26:06 <ihope> @djinn-env
06:26:06 <lambdabot> data () = ()
06:26:06 <lambdabot> data Either a b = Left a | Right b
06:26:06 <lambdabot> data Maybe a = Nothing | Just a
06:26:06 <lambdabot> data Bool = False | True
06:26:06 <lambdabot> data Void
06:26:08 <lambdabot> type Not x = x -> Void
06:26:18 <ihope> Right up at the top, sorta.
06:26:20 <glasser> Well, I mean, we told it that, sure
06:26:26 <glasser> But it's not in the code
06:26:37 <ihope> Oh?
06:26:55 <ihope> @index Void
06:26:56 <lambdabot> bzzt
06:27:01 <glasser> @djinn-add data E3 = A a | B b | C c
06:27:16 <glasser> @djinn E3 a b c -> Either c a
06:27:17 <lambdabot> Cannot parse command
06:27:17 <lambdabot> -- f cannot be realized.
06:27:38 <flux__> @djinn E3 a b c -> E3 b c a
06:27:39 <lambdabot> Cannot parse command
06:27:39 <lambdabot> -- f cannot be realized.
06:27:41 <glasser> @djinn-env
06:27:42 <lambdabot> data () = ()
06:27:42 <lambdabot> data Either a b = Left a | Right b
06:27:42 <lambdabot> data Maybe a = Nothing | Just a
06:27:42 <lambdabot> data Bool = False | True
06:27:43 <lambdabot> data Void
06:27:45 <lambdabot> type Not x = x -> Void
06:27:47 <lambdabot> Error: type variable not bound a
06:27:54 <glasser> @djinn-add data E3 a b c = A a | B b | C c
06:27:55 <lambdabot> Cannot parse command
06:27:59 <Heffalump> glasser: you can (in theory) define instance Num [a]
06:28:03 <glasser> @djinn-env
06:28:05 <lambdabot> data () = ()
06:28:05 <lambdabot> data Either a b = Left a | Right b
06:28:05 <lambdabot> data Maybe a = Nothing | Just a
06:28:05 <lambdabot> data Bool = False | True
06:28:05 <lambdabot> data Void
06:28:06 <lambdabot> type Not x = x -> Void
06:28:08 <eivuokko> E3 a b c = ...
06:28:08 <lambdabot> Error: type variable not bound a
06:28:13 <xerox> Maybe only admins can mess with deletions and clearings.
06:28:22 <glasser> @djinn-add data F3 a b c = A a | B b | C c
06:28:23 <lambdabot> Cannot parse command
06:28:23 <flux__> someone(tm) should add that support for recursive types
06:28:25 <int-e> @djinn Either a b -> Either b a
06:28:26 <lambdabot> Cannot parse command
06:28:26 <lambdabot> f :: Either a b -> Either b a
06:28:26 <lambdabot> f a =
06:28:26 <lambdabot>   case a of
06:28:26 <lambdabot>   Left b -> Right b
06:28:28 <lambdabot>   Right c -> Left c
06:28:30 <glasser> eh
06:28:34 <ihope> Listies!
06:28:47 <int-e> sorry. I should read scrollback :)
06:28:47 <ihope> @djinn [a] -> (a -> b) -> [b]
06:28:48 <lambdabot> Cannot parse command
06:28:48 <lambdabot> -- f cannot be realized.
06:29:33 <int-e> @djinn-add data List a = Nil | Cons a (List a)
06:29:34 <lambdabot> Error: Recursive types are not allowed: List
06:29:39 <int-e> aww
06:31:48 <ihope> Why not? *bang bang bang*\
06:38:56 <ADEpt> @index Either
06:38:57 <lambdabot> Data.Either, Prelude
06:51:39 <ihope> @help kind
06:51:39 <lambdabot>  @kind: return the kind of a type (GHC)
06:51:48 <ihope> @kind Data.Either.Either
06:51:49 <lambdabot> * -> * -> *
07:02:40 <ihope> Mmh, Ruby.
07:05:02 <ihope> "Varying number of arguments for function `compose'"
07:05:39 <ihope> I don't suppose GHC wanted to actually typecheck that...
07:30:04 <xerox> ihope: you can do variadic functions in Haskell.
07:31:55 <syntaxfree> join us now and share the software.. you'll be free, you'll be free.
07:32:10 * SimonRC goes
07:33:21 <xerox> syntaxfree: got the FSF-flu?
07:33:29 * Saulzar goes crazy
07:33:49 <syntaxfree> nah, I'm just wondering if RMS is a big Sokal-like hoax.
07:34:27 <tromp_> i doubt it, xerox
07:34:46 <tromp_> variadic in haskell
07:35:22 <xerox> tromp_: it's Oleg's!
07:36:15 <tromp_> well, then anything's possible:)
07:36:34 <xerox> Want a link?
07:37:06 <tromp_> but they cannot be functions yielding String, can they?
07:37:29 <xerox> tromp_: Oleg's example does exactly build a list
07:37:46 <xerox> *VarArg> build 'a' 'b' 'c' 'd' 'e' :: [Char]
07:37:47 <xerox> "abcde"
07:37:49 <xerox> heh
07:38:08 <tromp_> but that's a polymorphic function
07:38:17 <xerox> Hm, surely.
07:38:25 <xerox> http://okmij.org/ftp/Haskell/vararg-fn.lhs
07:38:28 <tromp_> ok, you're right then
07:38:46 <shapr> As long as you make the types explicit, it all works out.
07:38:55 <shapr> But it screws with partial application in very weird ways.
07:39:14 <xerox> Agreable... :-)
07:40:12 <tromp_> so you cannot do it without typing the result
07:40:24 <tromp_> i guess:)
07:41:18 <tromp_> > cycle "uni"
07:41:20 <lambdabot> "uniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniun
07:41:20 <lambdabot> iuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniun
07:41:20 <lambdabot> iuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniun
07:41:20 <lambdabot> iuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniun
07:41:20 <lambdabot> iuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniun
07:41:22 <lambdabot> [23 @more lines]
07:41:38 <xerox> ...subliminal message? :-)
07:42:21 * shapr grins
07:43:23 <tromp_> it would be cool if lambdabot caught this expression and instead gave the answer
07:43:26 <tromp_>    _O
07:43:26 <tromp_>    (`
07:43:26 <tromp_>    |>
07:43:26 <tromp_>   ,|.
07:43:26 <tromp_>   `-'
07:44:07 <xerox> hah.
07:44:43 <xerox> @yarr! The irate pirate!
07:44:43 <lambdabot> I'd like to drop me anchor in her lagoon
07:44:47 <ihope> ...I don't get it.
07:44:51 <tromp_> altough newbies would freak out:(
07:44:54 <ihope> The uni thing.
07:45:05 <xerox> ihope: _ and ` are the arms, ( the body, > the legs.
07:45:27 <xerox> ihope: the |s make the unicycle, with pointy points making the wheel.  Ah, yes, O is the head.
07:45:32 <tromp_> use a fixed font
07:47:22 <ihope> Eh... okay.
07:48:30 <xerox> I was thinking of some kind of 'spot the expression' with an ascii gift in return too, some days ago.
07:49:39 <ihope_> What the what?
07:57:09 <ihope_> Pi time...
08:00:46 <ihope_> let s func p param = replicate 2 6 ++ param -- ...
08:28:50 <ihope_> > pi
08:28:51 <lambdabot> 3.141592653589793
08:28:57 <ihope_> Aha!
08:29:30 <tromp_> > e
08:29:31 <lambdabot>  Not in scope: `e'
08:30:20 <xerox> @index e
08:30:21 <lambdabot> Data.Graph.Inductive.Example
08:31:05 <ihope_> Mmh. Haskell pi...
08:33:53 <ihope_> @type fix const
08:33:55 <lambdabot> Not in scope: `fix'
08:34:03 <ihope_> @type Control.Monad.Fix.fix const
08:34:04 <lambdabot>   Occurs check: cannot construct the infinite type: t = b -> t
08:34:04 <lambdabot>   Expected type: (b -> t) -> b -> t
08:34:30 <Saulzar> There's a hole in my bucket...
08:34:45 <ihope_> One would wonder why the first parameter has infinite type as well.
08:36:04 <ihope_> @type const (Control.Monad.Fix.fix const)
08:36:05 <lambdabot>   Occurs check: cannot construct the infinite type: t = b -> t
08:36:05 <lambdabot>   Expected type: (b -> t) -> b -> t
08:36:15 <xerox> > exp 1 -- tromp
08:36:16 <lambdabot> 2.718281828459045
08:36:38 <znephf> :)
08:36:52 <roconnor> @type Control.Monad.Fix.fix id
08:36:52 <ihope_> > exp (exp 1)
08:36:53 <lambdabot> forall a. a
08:36:54 <lambdabot> 15.154262241479262
08:37:12 <ihope_> > exp 0
08:37:13 <lambdabot> 1.0
08:37:21 <xerox> > "I know math"
08:37:22 <lambdabot> "I know math"
08:37:26 <ihope_> > exp (-1)
08:37:27 <lambdabot> 0.36787944117144233
08:37:28 <xerox> :-P
08:37:36 <ihope_> Nger.
08:37:42 <tromp_> > exp (pi*i)
08:37:43 <lambdabot>  Not in scope: `i'
08:37:53 <ihope_> Ooh, imaginary numbers?
08:37:55 <xerox> -1 !
08:38:03 <ihope_> > sqrt (-1)
08:38:03 <lambdabot> NaN
08:38:09 <ihope_> Ah.
08:38:14 <xerox> > exp (pi * sqrt (-1))
08:38:16 <lambdabot> NaN
08:38:23 <ihope_> > NaN
08:38:24 <lambdabot>  Not in scope: data constructor `NaN'
08:38:29 <int-e> 'not a number'
08:38:31 <Si\Uni> Does anyone know who maintains/develops fgl these days?
08:38:33 <znephf> hehe
08:38:45 <ihope_> How would one check for NaN?
08:38:48 <ihope_> > read "NaN"
08:38:49 <lambdabot> Add a type signature
08:38:50 <int-e> > 0/0
08:38:51 <znephf> isNan?
08:38:52 <lambdabot> NaN
08:38:56 <int-e> > 0/0 == 0/0
08:38:57 <lambdabot> False
08:38:58 <xerox> @index isNaN
08:38:58 <lambdabot> Prelude
08:39:05 <xerox> :-)
08:39:08 <ihope_> > isNaN (0/0)
08:39:10 <lambdabot> True
08:39:31 <dcoutts> xerox, darcs pull!
08:39:47 <tromp_> > 1 :+ 1
08:39:48 <lambdabot>  Not in scope: data constructor `:+'
08:39:54 <xerox> dcoutts: all right!
08:40:06 <ihope_> I want a type with :-) as a data constructor.
08:40:08 <xerox> > 1# +# 1#
08:40:09 <lambdabot>  parse error on input `+#'
08:40:10 <tromp_> > 1 Data.Complex.:+ 1
08:40:10 <lambdabot>  Not in scope: data constructor `Data.Complex.:+'
08:40:17 <xerox> <g>
08:40:22 <xerox> @index (:+)
08:40:22 <lambdabot> Data.Complex
08:40:38 <xerox> Oh.
08:40:39 <tromp_> > Data.Complex.(:+) 1 1
08:40:40 <lambdabot>  Not in scope: data constructor `:+'
08:40:41 <xerox> @docs Data.Complex
08:40:42 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Complex.
08:40:42 <lambdabot> html
08:40:47 <ihope_> More @index boochery?
08:40:51 <ihope_> @index callCC
08:40:51 <lambdabot> Control.Monad.Cont
08:40:58 <ihope_> > Control.Monad.Cont.callCC
08:40:58 <lambdabot>  Not in scope: `Control.Monad.Cont.callCC'
08:41:26 <tromp_> @index id
08:41:27 <lambdabot> Prelude
08:41:32 <tromp_> Prelude.id 1
08:41:36 <xerox> So..
08:41:37 <tromp_> > Prelude.id 1
08:41:39 <lambdabot> 1
08:42:37 <ihope_> @djinn ((a -> ((b -> c) -> c)) -> ((a -> c) -> c)) -> ((a -> c) -> c)
08:42:37 <lambdabot> Cannot parse command
08:42:37 <lambdabot> f :: ((a -> (b -> c) -> c) -> (a -> c) -> c) -> (a -> c) -> c
08:42:37 <lambdabot> f a b = a (\ c _ -> b c) b
08:43:22 <dcoutts> xerox, darcs pull again!
08:43:48 <dcoutts> xerox, I pushed the window icon png file.
08:43:55 <xerox> Heh.
08:45:44 <ihope_> I have a monadToCPS function. Does it do anything?
08:45:59 <xerox> @index monadToCPS
08:46:00 <lambdabot> bzzt
08:48:01 <ihope_> monadToCPS = (Cont . (>>=))
08:48:39 <znephf> @index interact
08:48:40 <lambdabot> System.IO, Prelude
08:49:00 <ihope_> @type interact
08:49:02 <lambdabot> (String -> String) -> IO ()
08:50:04 <ihope_> The other function in my continuation library: exit = (Cont . const)
08:51:02 <xerox> @type Control.Monad.Cont.Cont . (>>=)
08:51:03 <lambdabot> forall (m :: * -> *) a b.
08:51:03 <lambdabot> (Monad m) =>
08:51:03 <lambdabot> m a -> Control.Monad.Cont.Cont (m b) a
08:51:07 <xerox> @type Control.Monad.Cont.Cont . const
08:51:07 <lambdabot> forall a a1. a1 -> Control.Monad.Cont.Cont a1 a
08:51:49 <ihope_> exit stops execution immediately and returns a value.
08:51:59 <ihope_> Sounds suspiciously like what callCC does, more-or-less.
08:52:45 <ihope_> I guess callCC functions as a "stop here!"
08:53:20 <ihope_> Or rather, "stop here if you're using the special function I gave you!"
08:55:23 <sproingie> technically it can all boil down to callCC
08:55:41 <sproingie> syntax sugar is just a good thing :)
08:57:18 <ihope_> But callCC seems weird right now.
08:57:46 <nuffer> um, so, multithreading in haskell
08:57:47 <nuffer> any info?
08:57:57 <sproingie> check out Control.Concurrent
08:58:01 <nuffer> sure
08:58:04 <xerox> ...and STM? :-)
08:58:42 <sproingie> isn't that part of Control.Concurrent?
08:58:50 <nuffer> google seems to think so
08:59:11 <xerox> The STM paper is cool, apart from the Concurrent docs.
08:59:36 <sproingie> papers confuse and frighten me.  i like simple code examples
08:59:56 <ihope_> three = 3
08:59:59 <xerox> That paper is _really_ cree.
09:00:01 <xerox> *clear
09:00:01 <ihope_> A simple code example.
09:00:01 <sproingie> yoikes i'm late.  gotta get going
09:00:16 <pesco> code examples confuse and annoy me.  i like clear papers.
09:00:22 <sproingie> ihope: i like confusing people
09:00:30 <sproingie> > let 2 + 2 = 5 in 2 + 2
09:00:31 <lambdabot> 5
09:00:44 <ihope_> > let 2 + 2 = 5 in 3 + 3
09:00:45 <lambdabot>  Non-exhaustive patterns in function +
09:00:50 <Heffalump> do you want standard concurrency primitives based on shared variables, or cool new funky stuff?
09:01:04 <Heffalump> the former is provided by MVars in Control.Concurrent. The latter is provided by STM.
09:01:12 <Heffalump> In either case, forking threads is easy. Just call forkIO.
09:01:29 <syntaxfree> what are threads?
09:01:30 <Heffalump> oh, sorry, it's probably forkSTM if you are doing STM, or something.
09:01:34 <Heffalump> Either way it's quite simple.
09:01:44 <pesco> Heffalump: No, it's forkIO.
09:01:49 <Heffalump> ok.
09:02:04 <Heffalump> oh, right, you just drop into purer STM computations when you need to.
09:02:07 <syntaxfree> > exp(1) + 1
09:02:09 <lambdabot> 3.718281828459045
09:02:29 <nuffer> what's the type on main?  IO ()?
09:02:37 <ihope_> Think so,
09:02:40 <xerox> (syntaxfree: the parens are unnecessary)
09:02:40 <pesco> nuffer: Yes.
09:02:48 <nuffer> okay, excellent
09:03:11 <syntaxfree> xerox: (um, yes, you're right. php is ruining my mind)
09:03:36 <syntaxfree> @hoogle php
09:03:36 <lambdabot> No matches found
09:03:54 <pesco> @vixen PHP
09:03:55 <lambdabot> hey, who did we fight in WWII besides Germany and Russia?
09:04:07 <_|_kid_lambda^> ahoy hoy
09:04:08 <sieni> php should be linked to  http://www.bitstorm.org/edwin/en/php-sucks/
09:04:08 <pesco> LOL
09:04:16 <xerox> pesco: hah.
09:04:18 <_|_kid_lambda^> anybody used hsSDL on windows?
09:04:23 <pesco> Quote! Quote!
09:10:24 <_|_kid_lambda^> i guess not :(
09:11:20 <nuffer> I tried to get a bunch of SDL packages for windows working
09:11:23 <nuffer> couldn't get any of them
09:11:32 <nuffer> I'm using Graphics.GUI.SDL on Linux now
09:11:40 <nuffer> er, Graphics.UI.SDL rather
09:12:48 <_|_kid_lambda^> well from what i gather, i need cygwin just to make a build but i can't be arsed with cygwin so i was just asking for clarification
09:14:50 <gba> Beginner question: How can I write a function that gives me with every call a random number in the range 1..MAX (for MAX is some constant)?
09:15:47 <pesco> gba: Do you know randomRIO?
09:16:13 <gba> pesco, no I don´t 
09:16:14 <_|_kid_lambda^> @type randomR
09:16:16 <lambdabot> Not in scope: `randomR'
09:16:23 <_|_kid_lambda^> @type Random.randomR
09:16:24 <lambdabot> forall a g.
09:16:24 <lambdabot> (System.Random.Random a, System.Random.RandomGen g) =>
09:16:24 <lambdabot> (a, a) -> g -> (a, g)
09:16:42 <_|_kid_lambda^> @type Random.Random
09:16:43 <lambdabot> Not in scope: data constructor `Random.Random'
09:16:53 <_|_kid_lambda^> @type Random.random
09:16:54 <lambdabot> forall a g.
09:16:54 <lambdabot> (System.Random.Random a, System.Random.RandomGen g) =>
09:16:54 <lambdabot> g -> (a, g)
09:17:01 <_|_kid_lambda^> @type Random.randomRs
09:17:02 <lambdabot> forall a g.
09:17:02 <lambdabot> (System.Random.Random a, System.Random.RandomGen g) =>
09:17:02 <lambdabot> (a, a) -> g -> [a]
09:17:08 <_|_kid_lambda^> @type Random.randomRIO
09:17:10 <lambdabot> forall a. (System.Random.Random a) => (a, a) -> IO a
09:17:14 <_|_kid_lambda^> @type Random.randomIO
09:17:15 <lambdabot> forall a. (System.Random.Random a) => IO a
09:17:46 <gba> _|_kid_lambda^, okay thanks ;-)
09:18:37 <xerox> @docs System.Random
09:18:37 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Random.
09:18:37 <lambdabot> html
09:18:42 <xerox> Better lookup there :)
09:19:05 <_|_kid_lambda^> i need to read up about lambdabot, so freekin useful :D
09:19:07 <gba> xerox, I will lokk there, thanks
09:30:10 <nuffer> is there a (non-blocking) way to check if there's a connect waiting to be accepted?
09:31:25 <eivuokko> Set the socket non-blocking and then you can use select for, iirc, writeable.  In Winsock2 you can use ConnectEx with overlapped io.
09:31:30 <dcoutts_> nuffer, the more traditional way to do it is to forkIO and wait for incomming connections in that thread
09:31:56 <eivuokko> Oh, in haskell, sorry, wrong channel...nevermind me
09:31:56 <nuffer> dcoutts_: how do I pass the socket back to the parent thread once that's done?
09:32:05 <sieni> why doesn't windows just die
09:32:20 <musasabi> nuffer: you don't want to do that in haskell.
09:32:22 <dcoutts_> nuffer, use MVars or fork another thread to handle the connection
09:32:49 <nuffer> don't want to do what?
09:33:00 <musasabi> nuffer: just use one thread per connecition.
09:33:02 <dcoutts_> nuffer, there's no need to multiplex your IO manually, Haskell threads do that for you
09:33:03 <musasabi> that is the best way.
09:33:10 <gba> So, what does this syntax description mean:  getStdRandom :: (StdGen -> (a, StdGen)) -> IO a  ? 
09:33:15 * dcoutts_ agrees with musasabi 
09:33:27 <nuffer> hmm
09:33:37 <nuffer> I guess what I'm not clear on is how to do inter-thread communication
09:33:55 <dcoutts_> nuffer, MVars and things based on MVars like channels
09:33:57 <musasabi> gba: it applies that transformation to the global random number generator.
09:35:04 <gba> musasabi, getStdRandom is a function that takes a function as parameter, right?
09:42:08 <Saulzar> Hmm, the effect of the strictness annotation ! only makes the top level strict, right? So using it on a list like ![Int] wouldn't be much use I assumed... but just doing a few experiments it seems to evaluate the whole list (at least .. not leak)
09:42:18 <Heffalump> Saulzar: correct.
09:42:39 <Heffalump> well, evaluating the top-level might be enough to solve your leak.
09:42:52 <Saulzar> Hmm. 
09:43:07 <Heffalump> for example, consider the logic of the thing that generates the list.
09:43:10 <dcoutts_> if the way you generate the list is such that evaluating the top forces the whole thing
09:43:13 <Heffalump> right.
09:44:11 <Saulzar> Ah, true. It is a literal of the form [1..100]
09:45:23 <Heffalump> errm.
09:45:25 <Heffalump> that's not a literal.
09:45:29 <Heffalump> That's enumFromTo 1 100
09:45:57 <Heffalump> I don't see why that was causing you a space leak in the first place.
09:46:06 <Heffalump> It has a nice compact representation that will produce elements one at a time on demand.
09:46:16 <Heffalump> 1:enumFromTo 2 100, 1:2:enumFromTo 3 100 etc
09:46:31 <Heffalump> oh, you'll get a space leak if you walk over it once and keep it around for future use.
09:46:32 <Igloo> It'll take linear space if you don't actually look at the elements
09:46:46 <Heffalump> why does looking at the elements matter?
09:46:58 <Igloo> It forces the +1 (or succ or whatever it is)
09:47:13 <Saulzar> It wasn't, I'm messing with Yampa - which it turns out, if one does not evaluate all the output it will always leak
09:50:16 <nuffer> is sending data over a socket a blocking operation?
09:51:02 <dcoutts_> nuffer, for that thread, yes.
09:51:16 <dcoutts_> remember, threads are cheap
09:51:22 <Saulzar> Space leaks are not an exciting thing to meet, I've been trying to remove stuff to discover the source. Now I'm starting from the ground up.
09:51:46 <Heffalump> Igloo: oh, duh
09:52:06 <Heffalump> though the strictness analyser really ought to sort that out.
09:52:10 <Heffalump> but probably doesn't.
09:52:25 <Heffalump> (1 is not bottom, succ is strict, so succ 1 should be forced)
09:52:30 <nuffer> okay
09:52:38 <nuffer> so if I'm writing a client
09:52:52 <Igloo> That assumes you're going to look at at least one element, though
09:53:00 <nuffer> would it be normal to have three threads, one for reading from the network, another for writing to the network, and the third for logic, all synced with MVars?
09:53:06 <Igloo> (or you know succ terminates and you don't care about burning CPU cycles if it doesn't)
09:53:11 <Heffalump> hangon, you have to inspect it anyway
09:53:15 <Heffalump> to see if enumFromTo has terminated
09:53:24 <Heffalump> if you have the structure of the list, you must have evaluated the elements.
09:53:27 * SyntaxNinja hands succ a cookie
09:53:50 <Heffalump> even if you just know that it is 100 elements followed by something unevaluated, you have to have evaluated the elements.
09:54:27 <tromp_> wow, exp actually works on complex numbers
09:54:35 <tromp_> Prelude Data.Complex> exp $ pi * (0:+1)
09:54:35 <tromp_> (-1.0) :+ 1.2246063538223773e-16
09:55:00 <Igloo> Oh, true
09:55:12 <xerox> tromp_: yay.
09:55:24 <nuffer> dcoutts_: how does that setup sound?
09:56:14 <vincenz> > (0:+1) * (0:+1)
09:56:14 <lambdabot>  Not in scope: data constructor `:+'
09:56:44 <tromp_> is there no empty type?
09:56:50 <vincenz> tromp_: empty type?
09:57:09 <tromp_> with no values except bottom
09:57:19 <vincenz> > undefined
09:57:19 <lambdabot> Add a type signature
09:57:22 <vincenz> > undefined :: Bot
09:57:23 <lambdabot>  Not in scope: type constructor or class `Bot'
09:57:27 <dcoutts_> nuffer, I would use one thread per incomming connection, with one thread to listen for new connections
09:57:28 <vincenz> > undefined :: Bottom
09:57:28 <lambdabot>  Not in scope: type constructor or class `Bottom'
09:57:28 <palomer> yeah, forall a.a
09:57:30 <xerox> no, undefined is of all types
09:57:37 <vincenz> well yeah
09:57:43 <vincenz> but te Empty type only has bottom :)
09:57:56 <robdockins> Haskell 98 has no way to create empty types (that I know of)
09:57:57 <tromp_> i thought there would be a Void type or something
09:58:10 <vincenz> tromp_: it seems logical in a way
09:58:12 <nuffer> dcoutts_: this is for a client, not a server, I'm talking about
09:58:14 <eivuokko> There is always atleast one data constructor, but you can hide it in module export list.
09:58:15 <vincenz> tromp_: you'd havea value that's only error
09:58:18 <robdockins> GHC extensions allow you to create ADT with no constructors
09:58:19 <nuffer> well, I guess in general
09:58:33 <nuffer> how can you get away with just one thread per connect, if reading and writing from that socket are blocking?
09:58:35 <dcoutts_> nuffer, ok, you can't use one thread for it all? That makes syncing easy.
09:59:02 <nuffer> well, I'm wondering how to get around this whole blocking thing, really
09:59:18 <dcoutts_> nuffer, usually the blocking is what you want
09:59:21 <eivuokko> nuffer, is your protocol synchronous?
09:59:32 <nuffer> synchronous how?
09:59:45 <dcoutts_> you send a message it replies
09:59:50 <nuffer> no
10:00:19 <dcoutts_> each end can be sending and recieving stuff all the time?
10:00:24 <nuffer> yes
10:00:37 <dcoutts_> ok then yes your system sounds ok
10:00:38 <nuffer> no way to tell what's going to happen in the future
10:00:47 <nuffer> is there a better way?
10:00:59 <dcoutts_> I don't know what you're doing
10:01:24 <nuffer> well, are there any obvious flaws with the three thread method?
10:01:28 <palomer> > let (a::b) = a in a
10:01:29 <lambdabot>   Illegal signature in pattern: b
10:01:29 <lambdabot>    Use -fglasgow-exts to permit it
10:01:31 <nuffer> can the same thing be accomplished with less threads?
10:01:52 <palomer> > let a (x::b) = x in a
10:01:52 <lambdabot>   Illegal signature in pattern: b
10:01:52 <lambdabot>    Use -fglasgow-exts to permit it
10:02:02 <palomer> how do we do this?
10:02:05 <palomer> > let a (x::'b) = x in a
10:02:06 <lambdabot>  lexical error in string/character literal
10:02:11 <palomer> > let a (x::B) = x in a
10:02:12 <lambdabot>   Illegal signature in pattern: B
10:02:12 <lambdabot>    Use -fglasgow-exts to permit it
10:02:29 <xerox> If it says you can't put signatures in patterns... you can't.
10:02:47 <palomer> whoa, that's odd
10:02:52 <palomer> is there a reason for this?
10:03:05 <palomer> is it because haskell doesn't want to do unification under a mixed prefix?
10:03:14 <xerox> Because ghci is not called with -fglasgow-exts is the evitend cause.
10:03:16 <dcoutts_> nuffer, it's not the number of threads that's important, it's the complexity of the solution. I think 3 sounds ok, with both of the others passing info to the centeral thread.
10:03:32 <palomer> (it is legal in sml, and I thought that the sml type system was a subset of the haskell type system
10:03:33 <nuffer> okay, thanks
10:04:10 <palomer> > let a::a->b ;a x = x in a
10:04:11 <lambdabot>   Quantified type variable `b' is unified with another quantified type
10:04:11 <lambdabot> variable `a'
10:04:11 <lambdabot>   When trying to generalise the type inferred for `a'
10:04:11 <lambdabot>   Signature type:     forall a b. a -> b
10:04:14 <palomer> > let a::a->a ;a x = x in a
10:04:15 <lambdabot>  add an instance declaration for (Show (a -> a))
10:05:01 <palomer> > let a::a->b ;a a = a in a
10:05:01 <lambdabot>   Quantified type variable `b' is unified with another quantified type
10:05:01 <lambdabot> variable `a'
10:05:01 <lambdabot>   When trying to generalise the type inferred for `a'
10:05:01 <lambdabot>   Signature type:     forall a b. a -> b
10:05:04 <palomer> > let a::a->a ;a a = a in a
10:05:04 <lambdabot>  add an instance declaration for (Show (a -> a))
10:05:33 <palomer> > let a::a->a ;a a = a;eh=5 in a eh
10:05:34 <lambdabot> 5
10:06:13 <palomer> hrm, maybe the sml type system and the haskell type system aren't as close as people believe
10:06:52 <dcoutts_> nuffer, you might want to start with Chans but be careful since they are just simple unbounded queues. For a robust network app you'll need to know if your input or output queues are getting too big.
10:07:37 <dcoutts_> nuffer, for communicating between the threads I mean. So Chans might be the easiest thing to start with, but in the end you might have to build something custom using MVars.
10:08:09 <Philippa> palomer: both're hindley-milner based and support algebraic datatypes. That's about it
10:09:08 <Philippa> when people say the SML type system's a subset of the haskell type system, they're not talking about where you're allowed to annotate
10:12:22 <palomer> so in haskell you're only allowed to annotate at let bindings
10:12:45 <palomer> err, maybe not
10:12:56 <palomer> you're not allowed to annotate formal parameters?
10:15:25 <Philippa> you're not allowed to annotate patterns
10:15:41 <Philippa> the parameters on a lambda or a function binding're patterns
10:16:58 <weffort> @pl avlength x = ((fromIntegral . sum . map length . words) x)/((fromIntegral . length . map length . words) x)
10:16:59 <lambdabot> avlength = ap ((/) . fromIntegral . sum . map length . words) (fromIntegral
10:16:59 <lambdabot> . length . map length . words)
10:17:08 <weffort> @type ap
10:17:09 <lambdabot> Not in scope: `ap'
10:17:16 <weffort> @type Control.Monad.ap
10:17:17 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
10:17:39 <weffort> @pl bigword x = (unwords . filter isGood .  nub . (filter ((>=(avlength x)) . length)) . words) x
10:17:40 <lambdabot> bigword = ((unwords . filter isGood . nub) .) =<< (. words) . filter . (.
10:17:40 <lambdabot> length) . flip (>=) . avlength
10:18:48 <weffort> @pl isBig x = filter (>(avlength x)) x
10:18:49 <lambdabot> isBig = filter =<< flip (>) . avlength
10:18:49 <palomer> Philippa: and applications can be annotated
10:18:54 <palomer> why not let anything be annotated?
10:30:54 <Philippa> palomer: expressions can be annotated. Pattern annotations're a ghc extension
10:31:16 <Philippa> and I'd be utterly surprised if they don't make it into Haskell'
10:31:49 <palomer> they make unification harder
10:33:03 <eivuokko> Why let a :: A = foo is harder to unify then let [a] = foo?
10:34:53 <palomer> you get universal quantifiers that come into play
10:35:01 <palomer> at least, that's what my supervisor claims
10:35:06 <eivuokko> Hmmm.
10:35:29 <palomer> actually, I'm about to read odersky's paper on this
10:37:30 <palomer> and it makes sense, really, saying let a :: t = foo is saying that this is true for any foo
10:37:39 <palomer> err, for any t
10:42:18 <Philippa> yeah, but it infers a type variable for a's type before it starts applying additional info anyway
10:43:49 <Philippa> pattern annotations on top of a basic hindley-milner system're a piece of piss, IIRC I've implemented them myself
10:44:07 <palomer> do you have any references?
10:44:22 <Philippa> *checks*
10:44:24 <Philippa> OK, I hadn't
10:44:30 <eivuokko> Anyway, that claim would mean that there is something hard about let a::A = foo transforming into let a = ((foo)::A)
10:44:38 <palomer> forall t. (a = t) ^ a = foo where a is the type of a, foo is the type of foo
10:45:04 <Philippa> not to hand. But doing it on a case analysis is easy because you just match the pattern's type with the relevant part of the value being analysed's type...
10:45:27 <palomer> yes, but the type variables are going to be universally quantified
10:45:30 <palomer> so they can't be instantiated
10:46:00 <palomer> for example:
10:46:18 <Philippa> yeah, but how's that a big deal if you're doing rank-n types anyway?
10:46:30 <palomer> rank-n types?
10:46:40 <Philippa> types-with-foralls, if you like
10:46:45 <Philippa> all haskell98 types're rank 1
10:46:57 <palomer> oh, but type inference with rank-n types is undecidable
10:47:13 <palomer> rank-n is the number of alterations allowed?
10:47:16 <weffort> palomer: hmm. is that a demonstrated result?
10:47:18 <Philippa> brb
10:47:33 <Philippa> (you /don't need to do full inference/, you've got a goddamn annotation to take info from)
10:48:05 <palomer> weffort: rank-n = system F, from my understanding, and this is very well known
10:49:44 <palomer> ok, so you're doing rank-n types but you only have rank-1 inference, so the problem remains the same, allowing universal quantifiers in your unificating equations
10:49:56 <palomer> oh, you mean rank-n annotations?
10:50:03 <palomer> anywhere?
10:51:43 <Philippa> palomer: rank-n in haskell's predicative System F
10:52:27 <Philippa> you only have rank-1 inference and you can't unify a type variable with something with a forall in it
10:52:58 <Philippa> however, the other thing that can make pattern annotations useful is scoped type variables
10:53:44 <Philippa> (that is, scoped beyond the annotation they appear in to include annotations inside the scope of the expression being annotated)
10:54:05 <palomer> so the implementation is the same as unifying sets of equations with universal quantifiers in them, right?
10:56:13 <palomer> which means you have existential variables (which can be instantiated) and universal quantifiers (which can't)
10:56:27 * Philippa nods
10:56:31 <SyntaxNinja> is it ever possible to do something like this:
10:56:31 <SyntaxNinja> > class (Monad m, (MyClass parent parentsParent))
10:56:31 <SyntaxNinja> >     => MyClass child parent | parentsParent -> parent where
10:56:32 <lambdabot>  parse error on input `class'
10:56:32 <lambdabot>  parse error on input `=>'
10:56:38 <SyntaxNinja> shut up lambdabot
10:56:51 <Philippa> something which treatments of extensions to H-M get very careful about
10:57:16 <SyntaxNinja> er, ignore that Monad m
10:57:21 <palomer> I'm still trying to figure out how to deal with these universal quantifiers
10:57:37 <Philippa> imagine that function applications come with type applications ala System F?
10:58:08 <palomer> yeah, things could get cookie
10:58:09 <Philippa> alternatively: read the papers on rank-n types and boxy types (which handle impredicativity, and thus with scoped type variables are as expressive as System F)
10:58:36 <palomer> you'd have to add second order existential variables
10:58:39 <palomer> and higher order unification
10:58:41 <palomer> right?
10:58:43 <Philippa> nope
10:58:48 <Philippa> they don't do full inference
10:58:55 <Philippa> and higher order unification's undecidable
10:58:55 <palomer> well, if you were to do full inference
10:59:06 <Philippa> right, which you can't, so nobody does because it's not interesting
10:59:21 <palomer> ghc's type system is undecidable
10:59:41 <Philippa> what you mean is: some combinations of extensions supported by GHC are undecidable
10:59:48 <palomer> C++'s type system is undecidable
10:59:51 <Philippa> remind me if there's anything other than the option for undecidable instances that does it?
11:00:01 <Philippa> yes, but both support annotations
11:00:01 <palomer> Philippa: I don't know
11:00:10 <Philippa> full inference isn't interesting because you can't fix it if it fucks up
11:00:16 <Philippa> AFAIK there isn't
11:00:19 <palomer> C++'s type system is undecidable no matter how many annotations you ad
11:00:21 <palomer> add
11:00:29 <Philippa> yes, but C++ is broken in many other ways :-)
11:00:30 <eivuokko> In what case?
11:00:43 <Philippa> eivuokko: in what case what? :-)
11:00:54 <eivuokko> It is undecidable
11:01:03 <Philippa> C++'s or GHC's?
11:01:06 <palomer> Philippa: well, the compiler could say "I tried to apply inference to this specific part of the program and it screwed up. please annotate more"
11:01:07 <eivuokko> C++'s
11:01:27 <Philippa> palomer: you can't. Undecidable doesn't mean "you don't always know the answer"
11:01:32 <Philippa> it means "you don't even know if you can get one"
11:01:50 <palomer> Philippa: right, so it would say "inference took too long in this specific part, annotate more so I can speed things up"
11:02:01 <Philippa> eivuokko: trivially, you can set up a recursive template instantiation that never terminated
11:02:10 <eivuokko> Philippa, that is undecidable?
11:02:11 <Philippa> palomer: this is called icky and crappy
11:02:23 <eivuokko> Can't you do that with multiparam typeclasses?
11:02:25 <Philippa> eivuokko: okay, more formally you can encode the lambda calculus in it
11:02:41 <eivuokko> Yeha, I got it
11:02:43 <Philippa> no, you need to turn on an additional flag -fallow-undecidable-instances for that
11:02:46 <eivuokko> Hmm
11:03:03 <palomer> reasoning is the ability to solve problems in an undecidable domain. I like my compilers to reason for me
11:03:06 <eivuokko> Ah, yes, I think I see.
11:03:07 <flux__> well, c++ has a number of steps, for which the standard defines the lower bound. dunno if it defines the upper bound, though :-o
11:03:16 <eivuokko> It doesnt
11:03:41 <palomer> so when you go to unify universal quantifiers, how does that work?
11:03:49 <Philippa> palomer: RTFP
11:04:00 <Philippa> google boxy types, you'll get the relevant paper straight away
11:04:36 <palomer> ugh, an SPJ paper
11:04:37 <flux__> I don't understand which kind of things could be expressed with the forementioned extensions, but in practice I think some sort of (large) limit is rerely hit in c++ templates, and similarly I would imagine haskell type extensions could have such a limit without much limiting their use, and still be decidable
11:04:38 <Trevion> Is there a monadic equivalent to mapAccumL in the standard libraries?
11:04:49 <flux__> but then again maybe there are interesting things that would knock those limits
11:05:26 <Philippa> flux__: a trivial example'd be encoding transitive relationships
11:05:38 <Philippa> palomer: what's wrong with SPJ's papers?
11:05:50 <Philippa> the boxy types one's good, especially the new revision of it
11:05:53 <flux__> philippa, so, O(2^n) steps would be required?
11:05:56 <palomer> he reinvents the wheel
11:06:05 <palomer> boxy types, wobbly types, rigid types
11:06:45 <palomer> flux__: it's quite easy to hit the limit in c++ templates
11:06:51 <palomer> if one wants to
11:06:56 <Philippa> he doesn't entirely though
11:07:08 <flux__> palomer, the definining part being 'if one wants to'?-)
11:07:09 <Philippa> boxy and wobbly types have distinctly different invariants, for example
11:07:28 <Philippa> and he's been clawing his way towards a nice generalisation of bidi type inference
11:08:04 <palomer> flux__: and if you're nuts about optimizing, you can still hit the limit
11:08:34 <palomer> Philippa: I think all these things have been studied in theorem proving
11:08:52 <palomer> hrm, I'll read the paper though
11:08:58 * palomer is off to read odersky's paper
11:10:26 <Saulzar> If you are doing template loop unrolling and other wierdness for "optimisation" :)
11:10:52 <Philippa> palomer: they may well've been. References would be good :-)
11:11:50 <eivuokko> There are normal usage that can easily hit the limits, with C++ templates, like writing spirit parsers or expression templates or especially if doing something like haskelldb types do.
11:12:09 <Philippa> (btw, 'rigid' types're just non-wobbly ones so they don't really count for reinvention...)
11:28:25 <tmoertel> ?lmer
11:28:37 <RemiTurk> hoi allemaal
11:33:27 <tromp> ook hallo
11:38:22 <kevind> are there any known issues with STM in GHC 6.4.1?
11:38:37 <kevind> besides the nested atomically badness
11:38:53 <ADEpt> kevind: yes :) you can't do "unsafePerformIO $ atomically $ ..." :)
11:39:29 <RemiTurk> ADEpt: that _is_ the nested atomically badness (well, together with unsafeInterleaveIO)
11:39:56 <ADEpt> RemiTurk: ah
11:40:58 <kevind> I don't know if my problem is related to STM, but my threads seem to be hanging in the middle of STM actions
11:40:59 <Cale> (unsafePerformIO . atomically) seems like a bad idea anyway
11:41:17 <kevind> well, if you want a global TVar its kinda necessary
11:41:26 <Cale> global TVars are also a bad idea
11:41:32 <kevind> why
11:41:43 <Cale> State should be explicit
11:41:57 <RemiTurk> Cale: I thought my implementation of Single Assignment Variables using unsafeInterleaveIO + STM was quite nice. But the nested atomically issue broke it.
11:42:25 <kevind> I'm implementing a synchronization library which requires shared state, but I want it to be invisible from the outside
11:42:27 <Cale> (in some sense of the word 'explicit')
11:42:35 <kevind> global state is the only solution I came to
11:42:51 <Cale> Why not use a state monad?
11:42:58 <Cale> (or even a Reader)
11:43:40 <kevind> the state needs to be shared between threads, but I dont want to require that it be explicitly shared
11:44:22 <kevind> I need one global table that computations use to synchronize with eachother
11:44:31 <RemiTurk> kevind: but what if the user wants it to be shared only between threads A and B, but not C?
11:44:44 <kevind> too bad, thats not how it works
11:44:50 <kevind> heh :)
11:44:55 <RemiTurk> haha :)
11:45:16 <RemiTurk> I can imagine some quite similiar reply to "I want global variables" ;)
11:45:31 <kevind> it really aught to be implemented in the runtime system I think, but I didnt want to get into that
11:46:46 <kevind> anyway, I'm having a hell of a time figuring out why my threads just hang for no apparent reason
11:46:55 <Philippa> it's very difficult to prevent something being passed from A or B to C
11:47:01 <Cale> I'd probably implement the thing as a newtyped ReaderT over IO, where my run function sets up the shared table.
11:47:23 <kevind> problem is that the table needs to be shared between different run functions
11:47:31 <Cale> no, you don't want that
11:47:45 <kevind> I think I do
11:47:51 <Cale> (it's less flexible anyway)
11:48:08 <Cale> the usage scenario you're thinking of just uses one call to the run function
11:48:24 <kevind> no, multiple calls from separate threads
11:48:30 <palomer> > (\(x:a) -> x)
11:48:30 <lambdabot>  add an instance declaration for (Show ([a] -> a))
11:48:32 <palomer> > (\(x::a) -> x)
11:48:33 <lambdabot>   Illegal signature in pattern: a
11:48:33 <lambdabot>    Use -fglasgow-exts to permit it
11:48:33 <kevind> but all sharing some state
11:48:41 <Cale> okay, you mean something different by "run function" than I do.
11:48:52 <kevind> I mean the equivalent of "atomically"
11:48:53 <Cale> I'm talking about the function M a -> IO a
11:48:59 <kevind> yes, same thing
11:49:08 <Cale> where M is the monad which keeps track of the shared table
11:49:31 <kevind> the state is not local to one instance of the monad, but shared between all
11:50:03 <kevind> I could change the interface to make it like you are suggesting, but I dont want to
11:50:09 <Cale> Why not?
11:50:11 <kevind> i am basically implementing a synchronous version of STM
11:50:17 <kevind> I want a similar inferface as STM
11:51:17 <Cale> It doesn't sound too similar
11:51:44 <kevind> I want a function sync :: TS a -> IO a
11:51:55 <kevind> rather than sync :: TSTable -> TS a -> IO a
11:52:21 <xerox> [TS a] -> IO a, maybe?
11:53:07 <dcoutts_> hey xerox did you get that clock to build?
11:53:15 <xerox> Also, I have to say that it has born a new freenode channel about those topics: ##concurrency.
11:53:27 <xerox> dcoutts_: nope :(
11:53:42 <xerox> dcoutts_: physics is hard :)
11:53:52 <Cale> xerox: hm?
11:54:12 <xerox> Cale: what are you hming about exactly? :)
11:54:28 <Cale> physics?
11:54:44 <xerox> I know nearly no physics, and I have to learn much, today I did one full immersion afternoon
11:54:47 <dcoutts_> poor xerox :-)
11:55:13 <dcoutts_> Cale, have you tried the pretty new cairo clock?
11:55:30 <Cale> dcoutts_: nope, hadn't heard of it
11:55:45 <dcoutts_> Cale, darce pull the latest gtk2hs :-)
11:56:16 <dcoutts_> Cale, oh, btw it might help with your cairo surface problem
11:56:31 <dcoutts_> Cale, you wanted surfaces that were more than temporary didn't you?
11:56:55 <Cale> yeah
11:56:57 <dcoutts_> that you could keep around rather than just the withImageSurface style?
11:57:04 <dcoutts_> well that's done
11:57:10 <dcoutts_> and it's used in the clock demo
11:57:34 <xerox> which is WAY cool!
11:57:44 <dcoutts_> :-)
11:57:53 <Cale> hmm, that can't be right. No remote changes to pull in
11:57:58 <dcoutts_> and xerox hasn't even run it yet
11:58:14 <dcoutts_> Cale, darcs get --partial http://darcs.haskell.org/gtk2hs/
11:58:18 <Cale> okay
11:58:21 <dcoutts_> Cale, we moved the repo
11:58:51 * dcoutts_ ought to go actually
11:59:20 <Cale> (so the old one isn't quite a mirror)
11:59:56 <dcoutts_> we wouldn't be able to change it to point at the new master since you'd get loads of conflicts
12:00:11 <dcoutts_> since we regenerated the darcs from cvs with tailor
12:00:22 <dcoutts_> I did put a message in the motd of the old repo
12:00:34 <dcoutts_> but perhaps you only see that if there are patches to pull
12:00:49 <dcoutts_> maybe I'll push a patch that tells people to move! :-)
12:01:19 <Cale> I saw a message which said that the repo was redundant, but not that it's out of date :)
12:01:28 <dcoutts_> Cale, we're using darcs now properly, not just as a mirror, so no synching delay
12:01:34 <Cale> ah, okay
12:01:44 <dcoutts_> Cale, oh right! I'll change the message to make it clearer
12:05:07 <dcoutts_> done
12:05:10 * dcoutts_ &
12:30:48 <pesco> JohnMeacham: Is it normal for jhc to turn 13 lines of Haskell into >300,000 lines of C?
12:32:35 <Beelsebob> :o
12:33:07 <Philippa> what were the 13 lines?
12:33:12 <Philippa> I could see how it could be done...
12:33:41 <xerox> repeat "import ..." 13
12:33:43 <xerox> ;-)
12:34:20 <TFK> Guys, what do you think of the Mercury language?
12:36:08 <pesco> Philippa: The only significant line is this: let x = replicate n 0; v = replicate n 1 in print (iterate (zipWith (+) v) x !! m)
12:36:46 <davidw> Has anyone read "The next mainstream programming language: a game developer's perspective"?
12:36:50 <davidw> by Tim Sweeney
12:40:52 <eivuokko> I've been waiting to hear about Time Sweeney and Haskell since I saw him post on haskell ml.
12:41:17 <eivuokko> (I take the paper talks about haskell as you meantion it here)
12:41:45 <davidw> I haven't read it
12:41:54 <davidw> I'd like to, but I don't have ACM access
12:41:56 <eivuokko> Mhm, google says it does..
12:41:59 <eivuokko> Yeah, me neither
12:42:10 <davidw> Thomas Felleisen called it an advertisement for Haskell, though
12:52:28 <bringert> any users of the NewCGI or FastCGI modules here?
12:52:36 <eivuokko> _o/
12:52:54 <Lemmih> bringert: Yeah.
12:53:07 <bringert> I've changed them to use FastPackedString to support large file uploads.
12:53:22 <bringert> I hope the fps dependency isn't a problem?
12:53:37 <Philippa> davidw: haven't read it. Not entirely convinced gamedev wants mainstream languages any more
12:53:46 <Lemmih> Not currently.
12:54:30 <eivuokko> Hmm, all my newcgi progs are small, so it's easy to convert.
12:54:49 <bringert> the old interface hasn't changed
12:54:53 <bringert> just added a few new functions
12:55:01 <eivuokko> Ah
12:55:06 <bringert> the main new thing is the dependency on fps
12:55:42 <eivuokko> It's no problem.
12:56:19 <bringert> the only new function which users should have to care about is getInputFPS :: MonadCGI m => String -> m (Maybe FastString)
12:56:47 <bringert> everything else should be the same, unless I screwed up and changed something else
12:57:44 <kevind> I have a question, shouldn't "do (x <- return N; M)" act the same as "let x = N in do M"?
12:58:03 <xerox> kevind: no.
12:58:13 <kevind> why
12:58:28 <Beelsebob> the first creates a structure that first evaluates N and binds it to x, then runs M
12:58:31 <xerox> kevind: '<-' binds the value returned from the monadic action to the variable, let just binds the value.
12:58:38 <Beelsebob> the second lazily binds the value
12:58:44 <kevind> assuming N is pure
12:59:01 <Beelsebob> no
12:59:09 <Beelsebob> the first still stuffs it into a monad
12:59:10 <xerox> Well, if it's pure...
12:59:16 <kevind> oh, i see, its a sequencing thing then right?
12:59:38 <bringert> Beelsebob: does return really force its argument?
12:59:38 <xerox> It depends on the definition of the monad, prolly.
12:59:40 <eivuokko> It is the same, if monad is strict, it is "seq" worth strict.
12:59:52 <xerox> With something like the List Monad, they're equivalent.
12:59:59 <beelsebob_> bringert: yes, depends on the monad
12:59:59 <kevind> cause I am getting a confusing error
13:00:02 <beelsebob_> xerox: are they?
13:00:07 <xerox> beelsebob_: yeah.
13:00:09 <bringert> kevind: another difference is if N uses x
13:00:22 <bringert> let is recursive, <- isn't
13:00:39 <xerox> There is mdo, right? :)
13:00:51 <bringert> sure
13:01:04 * beelsebob_ wonders why hat-delta.prof is empty
13:01:29 <kevind> when i do: mySync <- return (sync table)
13:01:29 <kevind>     c <- mySync newTSChan
13:01:29 <kevind>     mySync (sendTSChan c (0,1))
13:01:32 <kevind> I get a type error
13:01:44 <kevind> but if I replace mySync with (sync table) then there is no error
13:01:52 <kevind> so I am highly confused
13:01:58 <xerox> kevind: heh.
13:02:17 <xerox> sync table :: function type; mSync :: m (function type).
13:02:37 <xerox> You need to use lift to do that, IIUC.
13:02:56 <xerox> (It doesn't make much sense, too)
13:03:40 <kevind> hmm, i thought using <- stripped the monad
13:03:42 <xerox> That is, return (foo :: a -> b) :: m (a -> b); not a -> m b.
13:03:51 <xerox> UH, mumble.
13:04:07 <xerox> That's right
13:04:15 <xerox> @type (Control.Monad.lift)
13:04:16 <lambdabot> Not in scope: `Control.Monad.lift'
13:04:19 <xerox> @type (Control.Monad.liftM)
13:04:20 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
13:04:35 <xerox> @index newTSChan
13:04:35 <lambdabot> bzzt
13:04:42 <xerox> @index newTChan
13:04:42 <lambdabot> Control.Concurrent.STM.TChan, Control.Concurrent.STM
13:04:57 <xerox> @type (Control.Concurrent.STM.TChan.newTChan)
13:04:59 <lambdabot> forall a. GHC.Conc.STM (Control.Concurrent.STM.TChan.TChan a)
13:05:04 <xerox> Duh.
13:05:15 <xerox> So the problem is that mySync :: function type
13:05:57 <kevind> why is that a problem
13:06:04 <xerox> liftM mySync $ sendTSChan x (0,1))
13:06:15 <xerox> Hmm
13:06:18 <xerox> Wat's the type of sync?
13:06:25 <kevind> TSTable -> TS a -> IO a
13:06:25 <xerox> Sorry, I can't type this night.
13:07:17 <kevind> newTSChan :: TS(TSChan a)
13:07:25 <kevind> sendTSChan :: TS a -> a -> TS ()
13:07:52 <xerox> Does it work with the let/where clause?
13:08:00 <kevind> dunno, lemma try
13:10:07 <kevind> yes it does
13:10:18 <xerox> Mumble.
13:10:40 <xerox> What is the exact error in the other case?
13:10:54 <kevind> without it it says:
13:10:55 <kevind>     Couldn't match `TSChan a' against `()'
13:10:55 <kevind>       Expected type: TS (TSChan a)
13:10:55 <kevind>       Inferred type: TS ()
13:10:55 <kevind>     In the application `sendTSChan c (0, 1)'
13:10:55 <kevind>     In the first argument of `mySync', namely `(sendTSChan c (0, 1))'
13:11:37 <xerox> Ah.
13:12:17 <kevind> is it monomorphising it or something?
13:12:19 <xerox> Maybe the problem is that in the do block, something bound with '<-' can't change type.
13:12:22 <xerox> Yeah, that's it.
13:12:31 <xerox> Well, defaulting, whatever.
13:13:11 <kevind> why is that
13:13:13 <xerox> When you use it the first time, it is stated that it has the type TS (TSChan a) -> IO a
13:13:28 <xerox> Then passing it a TS () raises the type error.
13:13:58 <kevind> I see, but that seems like strange behavior, why does it not just keep the polymorphic type
13:14:07 <xerox> Whereas, the let binding can be type-specialized (unified) anytime.
13:14:30 <xerox> Because of the semantic of the do block?
13:15:04 <kevind> ahh, right cause that would amount to higher-rank polymorphism
13:15:05 <xerox> do { x <- action; c <- x k; x y }
13:15:09 <robdockins> regarding kevind's earlier question, do (x <- return N; M) desugars to (return N >>= \x -> M), and according to the monad laws, this is equal to (\x -> M) N.
13:15:28 <robdockins> which is not exactily let x = N in M
13:15:47 <kevind> yep, thanks, I get it
13:15:51 <xerox> OK, good.
13:16:33 <xerox> (Sorry for confusing you initially)
13:21:15 <tromp> when is (\x->M)N different from let x=N in M?
13:21:53 <xerox> When M uses x multiple times it seems.
13:22:37 <kevind> when x is used polymorphically in M
13:22:45 <xerox> > (\x -> ((1::Int) + x,(1::Double) + x)) 1
13:22:46 <lambdabot> Couldn't match `Double' against `Int'
13:23:00 <xerox> > let x = 1 in ((1::Int) + x,(1::Double) + x))
13:23:01 <lambdabot>  parse error on input `)'
13:23:04 <xerox> > let x = 1 in ((1::Int) + x,(1::Double) + x)
13:23:05 <lambdabot> Couldn't match `Double' against `Int'
13:23:11 <xerox> Uh-oh.
13:23:31 <tromp> only top level defs have polymorphism, no?
13:24:24 <xerox> Right.
13:24:29 <simona> dcoutts, are you awake?
13:24:34 <kevind> non top-level let's should allow polymorphism too, right?
13:24:42 <xerox> f = let x = 1 in (x+(1::Int),x+(1::Double))
13:24:43 <kevind> just not lambda bindings
13:24:46 <tromp> so, unless x occurs free in N, i think they're equivalent
13:24:51 <xerox> This works if wrote in an .hs and loaded in GHCi.
13:24:56 <xerox> Without problems.
13:25:08 <tromp> oh, lemme try that
13:25:30 <xerox> It doesn't work if x is a formal parameter, because it cant unify the type, logically.
13:25:33 <xerox> can't, even.
13:26:06 <xerox> > f
13:26:06 <xerox> (2,2.0)
13:26:07 <lambdabot>  Not in scope: `f'
13:26:17 <xerox> in the other case:     Couldn't match `Int' against `Double'
13:26:28 <tromp> doesn't load here
13:26:49 <tromp>     Couldn't match `Int' against `Double'
13:26:49 <tromp> my ghci 6.4.1 says     Couldn't match `Int' against `Double'
13:27:08 <xerox> Maybe it's -fglasgow-exts, or some other option?
13:37:51 <kevind> Anyone want to help me debug my concurrent program?  Threads hang.  I put putTraceMsg's just about everywhere and I think I see where it is hanging but still I dont know why
13:45:37 <Cale> I could have a look
13:47:13 <davidw> here is an interesting talk from POPL06: http://www.cs.princeton.edu/~dpw/popl/06/Tim-POPL.ppt
13:47:34 <davidw> it's about game programming and language issues
13:48:10 <kevind> ok, the library I am programming is here: http://cs-people.bu.edu/kevind/TS.hs
13:48:26 <kevind> and a program that uses it and causes the bug is: http://cs-people.bu.edu/kevind/GR.hs
13:48:51 <kevind> I am new to haskell, so its definitely ugly as hell
13:49:26 <kevind> Cale: also, I followed your suggestion and removed the global state
13:50:12 <Cale> cool
13:50:14 <kevind> it hangs while in the cleanup function, which is the last thing in TS.hs
13:50:15 <dons> palomer, you'll be happy to see that 'simple unification-based type inference' for GADTs just got comitted into ghc :)
13:51:13 <Cale> btw,  x <- return y  is the same as  let x = y
13:51:17 <Cale> in a do-block
13:51:33 <Trevion> dons, does that fix the old issue with constraints being forgotten in GADTs?
13:51:39 <kevind> not type-wise
13:52:00 <Cale> kevind: well,  x <- return y  is more work
13:52:09 <kevind> it seems that while let does polymorphic generalization, <- does not
13:52:20 <Cale> oh, that's true
13:52:24 <kevind> heh, I think x <- return y is easier
13:52:48 <Cale> more work for the compiler/program, I mean
13:53:59 <itsmeeh> must go today 1 alienware area51-m 5700 laptop price 650 includes shipping, carry case. message me on mcsltd@telusmail.net on msn or on mikcomputing on aim.
13:54:41 <Cale> kevind: what freezes?
13:54:50 <kevind> the cleanup function
13:55:09 <kevind> the last function in TS.hs
13:55:15 <Cale> I ran it and it finished
13:55:23 <Cale> oh, hmm
13:55:29 <Cale> compiled, it doesn't
13:55:36 <Cale> perhaps a race?
13:55:43 <kevind> hmm, i had only used GHCi
13:55:56 <kevind> races there should be benign
13:56:08 <Cale> {ThreadId 5:=.}
13:56:10 <kevind> since it would just killThread on an already dead thread
13:56:17 <Cale> is the last line of output for me
13:56:22 <dons> huh. russia announced plans to mine Helium-3 on the moon.
13:57:00 <JKnecht> where?
13:57:52 <pesco> dons: What is He3 used for?
13:58:17 <JKnecht> http://english.pravda.ru/science/19/94/379/16403_moon.html ?
13:58:41 <JKnecht> fusion power, apparently.
13:59:02 <dons> i heard this on the radio, but seems like this: http://www.interfax.ru/e/B/0/28.html?id_issue=11454555
13:59:03 <kevind> yeah, but cleanup never finishes
13:59:10 <kevind> so some thread is hanging there
13:59:22 <kevind> the last debugging msg in cleanup never fires
14:00:40 <Cale> kevind: hmm, okay, it freezes most of the time
14:01:51 <Cale> are you aware of mapM?
14:02:00 <Cale> @type mapM
14:02:01 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
14:02:02 <Cale> @type mapM_
14:02:03 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> [a] -> m ()
14:03:13 <kevind> hmm, where would that be used?
14:04:00 <kevind> like where i use "fold f (return ()) l"?
14:04:03 <Cale> yeah
14:04:27 <kevind> cool
14:05:10 <Cale> It's not in the libraries, but I often like to define forM = flip mapM and forM_ = flip mapM_, which are handy when you have a largish action.
14:05:40 <kevind> @type flip
14:05:41 <lambdabot> forall c a b. (a -> b -> c) -> b -> a -> c
14:06:46 <Cale> :q
14:06:49 <Cale> oops :)
14:07:30 <Cale> ah, okay
14:07:46 <Cale> I get killed done, but only for the first time through
14:08:20 <kevind> yeah, the first time through its trivial, there is nothing to kill
14:09:47 <kevind> the first TS action just allocates and channel, the second does some synchronization then fails to cleanup
14:09:55 <kevind> err, allocates a channel
14:14:34 <Cale> @type when
14:14:35 <lambdabot> Not in scope: `when'
14:14:39 <Cale> @type Control.Monad.when
14:14:40 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
14:14:58 <Cale> when b x = if b then x else return ()
14:15:39 <kevind> thanks :)
14:16:07 <palomer> when you're doing type checking without type inference, you have to annotate your applications, right?
14:17:00 <kevind> I think binders need annotating
14:17:10 <palomer> but not application?
14:17:20 <palomer> how does the type checker know what type to check?
14:17:59 <kevind> it syncthesizes a type for the function then checks the argument
14:18:08 <kevind> err, synthesizes
14:18:37 <palomer> ahh, so it isn't completely straightfoward
14:19:00 <kevind> if you write mutually recusive synth and check then its pretty straightforward
14:19:14 <palomer> and the type has to be an instantiation of the synthesized type?
14:19:48 <kevind> ahh, I was thinking simple types, you might need to provide instantiations for polymorphic types
14:20:37 <palomer> here's the deal: (\(x::a) -> x) (\x -> x) doesn't type check in sml (which is H-M, really)
14:20:54 <palomer> yet (\(x::a) -> x) has an inferable type forall a. a-> a
14:21:54 <kevind> it doesnt know how to type the argument
14:22:05 <kevind> cause it needs a monomorphic type, but there is not a unique one to pick
14:22:44 <palomer> actually, synthesis only yields monomorphic types
14:23:07 <palomer> so you need to synthesize the right hand side
14:23:16 <palomer> ie \x -> x
14:23:30 <kevind> there is no unique monomorphic type for it
14:24:23 <palomer> but (\x -> x) (\x -> x) works fine
14:24:45 <palomer> the annotation forces the lhs to be polymorphic
14:24:48 <kevind> what does it type it as?
14:24:54 <palomer> forall a. a-> a
14:25:17 <kevind> thats weird, doesnt that type require impredicative polymorphism?
14:25:36 <palomer> what's that?
14:25:43 <kevind> cause then the type of the first \x -> x needs to be instantiated with a polymorphic type 
14:26:00 <palomer> oh, but I understood that the lhs is typed
14:26:10 <palomer> err, rhs
14:26:11 <nibro> @seen dons
14:26:12 <lambdabot> dons is in #haskell-blah and #haskell. Last spoke 27 minutes and 9
14:26:12 <lambdabot> seconds ago.
14:26:17 <palomer> and then that type is used to check the lhs type
14:26:34 <palomer> so the right hand side is a -> a
14:26:40 <palomer> note that this is not generalized
14:26:54 <palomer> and it's easy to check that the lhs has type (a->a)->(a->a)
14:26:57 <palomer> is this correct?
14:27:00 <nuffer> what would happen if I killed a thread that was waiting for a connection?
14:27:25 <eivuokko> nuffer, thread would get killed
14:27:31 <eivuokko> nuffer, ie nothing much
14:27:39 <kevind> i thought all varaibles are implicitly quantified during H-M type inference
14:27:53 <palomer> kevind: only at let bindings
14:28:08 <nuffer> sweet deal
14:29:43 <kevind> I dont think that (\x -> x) (\x -> x) can be given the type forall a. a->a in HM
14:30:07 <dcoutts> simona, hia
14:31:20 <palomer> kevind: do you mean that the type is not inferable?
14:31:20 <dcoutts> simona, resurecting hircules? :-)
14:31:24 <palomer> or that it isn't checkable?
14:32:18 <kevind> I mean there is no such typing using H-M rules
14:32:31 <kevind> there is a -> a for any particular a
14:32:37 <kevind> but not forall a. a -> a
14:32:41 <palomer> so you don't agree that (\x -> x) (\x -> x) does not have type forall. a->a ?
14:32:47 <palomer> err
14:32:53 <palomer> that it does have
14:33:21 <palomer> lemme get the TaPL
14:33:48 <Speck> kevind is correct, to the best of my knowledge.
14:34:39 <Speck> not possible without impredicative polymorphism
14:37:10 <Speck> @where Morrow
14:37:11 <lambdabot> I know nothing about morrow.
14:37:20 <Speck> @where+ Morrow http://www.cs.uu.nl/~daan/morrow/
14:37:20 <lambdabot> Done.
14:37:58 <kevind> actually, looking at the H-M let rule, you should be able to do "let f = (\x -> x)(\x -> x) in f" and get a polymorphic type
14:37:59 <Cale> kevind: when you're in a do-block, you can just write  do {...; let x = y; ..} rather than  do {...; let x = y in ...}
14:38:18 <kevind> ahh, cool
14:38:20 <Cale> rather than  do {...; let x = y in do {...}} 
14:38:31 <palomer> > let a = (\x -> x)(\x -> x) in a 5
14:38:32 <lambdabot> 5
14:38:38 <palomer> so haskell > H-M?
14:39:03 <kevind> let a = (\x -> x)(\x -> x) in (a 5, a True)
14:39:09 <kevind> > let a = (\x -> x)(\x -> x) in (a 5, a True)
14:39:10 <lambdabot> (5,True)
14:39:26 <kevind> I think H-M does let you do that
14:39:56 <palomer> in H-M, you first infer the types of the bindings before the type of the body
14:40:05 <palomer> (\x -> x) (\x -> x) 5
14:40:10 <palomer> > (\x -> x) (\x -> x)
14:40:11 <lambdabot>  add an instance declaration for (Show (t -> t))
14:40:13 <palomer> @type (\x -> x) (\x -> x)
14:40:14 <lambdabot> forall t. t -> t
14:40:17 <kevind> but not "let f = (\x -> x) in let g = f f in g"
14:40:17 <palomer> there
14:40:33 <palomer> > let f = (\x -> x) in let g = f f in g
14:40:34 <lambdabot>  add an instance declaration for (Show (t -> t))
14:40:37 <palomer> @type let f = (\x -> x) in let g = f f in g
14:40:38 <lambdabot> forall t. t -> t
14:41:28 <kevind> > let f = (\x -> \x) in (f f 5, f f True)
14:41:29 <lambdabot>  parse error on input `)'
14:41:36 <kevind> > let f = (\x -> x) in (f f 5, f f True)
14:41:37 <lambdabot> (5,True)
14:41:47 <palomer> bindings are generalized
14:42:30 <palomer> so that's fine
14:42:35 <kevind> > let f = (\x -> x) in ((f f) (\g -> (g 5, g True)))
14:42:36 <lambdabot>  add an instance declaration for (Show ((Bool -> a) -> (a, a)))
14:42:55 <palomer> ok, type inference for (\x -> x) (\x -> x) :: alpha
14:42:59 <kevind> > let f = (\x -> x) in ((\g -> (g 5, g True))(f f))
14:42:59 <lambdabot>  add an instance declaration for (Num Bool)
14:43:27 <Speck> an instance for what? Show?
14:43:27 <palomer> that doesn't type check in H-M
14:43:29 <palomer> which is fine
14:43:54 <Speck> oh nm
14:43:54 <palomer> Speck: it's asking to make Bool a Num
14:44:09 <palomer> (\y -> y) (\x -> x) :: alpha
14:44:13 <Speck> yeah, I thought I saw a comma between Num and Bool
14:44:45 <palomer> (\y -> y) :: beta -> alpha, (\x -> x) :: beta, 
14:45:36 <kevind> ahh
14:45:41 <palomer> the lhs yields alpha=beta
14:45:45 <kevind> I think the reason it does not work in SML is the value restriction
14:45:47 <palomer> the rhs yields beta = gamma -> gamma
14:45:58 <palomer> so you get alpha = gamma -> gamma
14:46:01 <palomer> and then you generalize
14:46:02 <kevind> generalization only applies to syntactic values
14:46:15 <palomer> (\x -> x) (\x -> x) does work in sml
14:46:26 <palomer> you only generalize at let bindings
14:47:09 <kevind> ok, I mean you cant get (\x -> x) (\x -> x) :: forall a. a -> a
14:47:15 <palomer> so you can
14:47:21 <palomer> err, sure you can
14:47:29 <JohnMeacham> pesco: not any more. have you pulled the latest patches?
14:47:30 <palomer> oh, righto, you can't
14:47:33 <palomer> but I don't mind
14:47:35 <ihope> @type (\x -> x) (\x -> x)
14:47:37 <lambdabot> forall t. t -> t
14:48:11 <palomer> however, what bothers me, is that (\(x::'a) -> x) (\x -> x) does not have an inferable type
14:49:02 <kevind> can you even write such things in SML?
14:49:08 <kevind> with the free type var
14:49:21 <palomer> (fn (x:'a) => x) (fn x => x) 
14:49:31 <palomer> this is syntactically correct
14:49:39 <kevind> stdIn:2.8 Error: unbound variable or constructor: a
14:50:16 <palomer> val it = fn : 'a -> 'a
14:50:22 <palomer> that's what I get
14:50:53 <kevind> oh, i forget the parens
14:51:13 <kevind> but I still get a type error
14:51:17 <palomer> yeah
14:51:24 <palomer> now remove the annotation
14:51:28 <palomer> and the type error dissapears
14:51:34 <palomer> (I said it wasn't typeable in sml!)
14:51:53 <kevind> val it = fn : ?.X1 -> ?.X1
14:52:23 <palomer> yeah, I don't get that either
14:52:28 <palomer> but it doesn't barf!
14:53:43 <dcoutts> JohnMeacham, will we know JHC has "arrived" when a google search for "Haskell JHC" stops asking you if you meand "Haskell GHC"? :-)
14:54:15 * dcoutts darcs gets jhc
14:54:52 <JKnecht> it still does for me (w 'JHC haskell')
14:54:55 <ihope> Oh... oh right...
14:55:00 <ihope> @getinstance
14:55:01 <lambdabot> Unknown command, try @listcommands.
14:55:07 <ihope> I knew that wouldn't work.
14:55:45 <ihope> @pl (>>=) :: Cont c a -> (a -> Cont c b) -> Cont c b
14:55:46 <lambdabot> (line 1, column 19):
14:55:46 <lambdabot> unexpected ">" or "-"
14:55:46 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
14:56:03 <kevind> I think SML just doesn't let you provide polymorphic annotations the way haskell does
14:56:20 <kevind> but it will happily infer the monomorphic type ?.X1 -> ?.X1
14:56:43 <palomer> oh, that's because it's not part of a let binding
14:56:45 <palomer> so it won't generalize
14:57:15 <palomer> whoa, it doesn't 
14:57:17 <palomer> that's _odd_
14:57:27 <palomer> oh, it's the value restriction
14:57:59 <palomer> only values have polymorphic type
14:58:18 <JohnMeacham> dcoutts: I'll have my friends at google get on that..
14:58:29 <dcoutts> JohnMeacham, heh :-)
14:58:32 <palomer> so you can't do things like: let a = ref (\x -> x) in a := (\x -> x+1); a true end
14:58:41 <SamB> Well, I worked on my TMR article today some, though it was all offline and I still have to type it in... and read my horrible handwriting...
14:59:01 <palomer> guys, I don't think we should use ghc extensions for the shootout
14:59:15 <palomer> unless it's really idiomatic
15:00:18 <SamB> Today in english class, the essay I did in-class last monday was put on the overhead. The illegibility of its contents was equaled only by the illegibility of my name...
15:01:26 <Cale> kevind: almost finished idiomatizing your code so as to be able to read it ;)
15:01:43 <kevind> haha, thanks
15:01:51 <Cale> 90% of your parens are unnecessary
15:02:13 <kevind> yeah, but it kept complaining about indentation so I started parenthesizing everything to be safe
15:02:30 <Cale> you had mixed tabs and spaces in there
15:02:35 <palomer> kevind: but (fn (x:'a) => x) works fine
15:02:54 <Cale> also, your layout is a bit unconventional :)
15:03:24 <kevind> yeah but (fn (x:'a) => x) is useless since there is nothing of type 'a :)
15:03:44 <kevind> try (fn (x:'a) => x) 5
15:03:47 <kevind> it no work
15:07:26 <palomer> let val x = fn (x:'a) => x
15:07:26 <palomer> in
15:07:26 <palomer>     x 5
15:07:26 <palomer> end works fine
15:09:01 <kevind> yep,
15:10:52 <ihope> Many lines.
15:10:59 <xerox> dcoutts: cairo/Graphics/Rendering/Cairo/Types.hs:24:3: Parse error
15:11:01 <xerox> dcoutts: :-\
15:11:29 <ihope> So what's (>>=) :: Cont c a -> (a -> Cont c b) -> Cont c b?
15:11:34 <xerox> dcoutts: it misses a ','.
15:11:59 <ihope> ...Ah, here we go.
15:12:25 <kevind> wow, this is weird:
15:12:26 <kevind> - (fn (x:'a->'a) => x);
15:12:26 <kevind> val it = fn : ('a -> 'a) -> 'a -> 'a
15:12:26 <kevind> - (fn (x:'a) => x);
15:12:26 <kevind> val it = fn : 'a -> 'a
15:12:26 <kevind> - (fn (x:'a->'a) => x)(fn (x:'a) => x);
15:12:28 <kevind> stdIn:24.1-24.37 Error: explicit type variable cannot be generalized at its binding declaration: 'a
15:12:36 <xerox> What is "'a" ?
15:12:38 <simona> dcoutts: hi, so you're online
15:12:40 <kevind> type variable
15:12:46 <xerox> Howdy simona :-)
15:13:09 <simona> xerox: ok.. self?!
15:13:25 <astrolabe> Why does GHC warn me " Pattern match(es) are overlapped"?  Is it bad style to overlap pattern matches?
15:13:35 <simona> dcoutts: I saw you heeded my complaint...
15:13:45 <xerox> Uh, it doesn't miss a ',', mumble.
15:13:49 <xerox> simona: sorry?
15:14:08 <simona> xerox: well. you asked.
15:14:25 <franka> Yes, it's bad style.
15:14:37 <simona> dcoutts: I have a question: why does apiGen not generate attributes for the CellRenderers? In fact, nothing is generated for CellRenderers.
15:14:41 <xerox> Ah, you mean "'a" is "self" ?
15:15:25 <simona> xerox: rephrase: ok. And yourself?
15:16:21 <xerox> simona: wee, I'm too tired, sorry.  The '?!' fooled me :-)
15:17:30 <simona> xerox: did you ever get the money from Google?
15:18:31 <xerox> simona: the cheque arrived, they said (in november) that it would take 2 months to cash it.  The money still haven't flow in in fact :-\
15:19:48 <simona> xerox: uh, that sucks. But in principle you succeeded?
15:20:02 <xerox> Yes, yes.
15:20:12 <xerox> I got a certificate, and a t-shirt too :-)
15:21:06 <ihope> I'm tired of calling these things CPS values. What should I be calling them?
15:22:54 <kevind> whats wrong with CPS values?
15:23:15 <ihope> Nobody else seems to be calling them that :-P
15:24:01 <kevind> how about CPS closures
15:24:38 <simona> xerox: t-shirt is cool :=)
15:25:00 <ihope> Maybe just "closures"?
15:25:16 <xerox> simona: indeed :-D
15:30:36 <xerox> Hi riffraff :-)
15:30:41 <riffraff> eh xerox
15:31:06 <dcoutts> simona, I'm not sure.
15:32:02 <xerox> @djinn a -> a
15:32:03 <lambdabot> Cannot parse command
15:32:03 <lambdabot> f :: a -> a
15:32:03 <lambdabot> f a = a
15:32:18 <xerox> @. pl djinn a -> a
15:32:18 <lambdabot> (line 2, column 8):
15:32:18 <lambdabot> unexpected ">" or "-"
15:32:18 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
15:32:19 <Cale> kevind: getThidsRunning is a little odd...
15:33:01 <Cale> kevind: is there a reason you're reading pathvar over and over again?
15:33:47 <dcoutts> simona, it generates attributes for me.
15:33:50 <kevind> it should be a different pathVar each time
15:33:56 <kevind> topm is a list of pathVar's
15:34:03 <simona> dcoutts: hm. ok. I couldn't find it in the exclude list.
15:34:06 <Cale> ah
15:34:07 <Cale> yeah
15:34:13 <dcoutts> simona, eg gtk-modules/Graphics/UI/Gtk/TreeList/CellRendererText.chs has dozens of attributes
15:34:19 <simona> dcoutts: it works for you? I once worked for me, too...
15:34:21 <Cale> okay then
15:35:14 <dcoutts> simona, perhaps it's due to some apiGen patches I haven't pushed but I don't think so, they were mostly doc related.
15:35:29 <dcoutts> simona, oh and changing the signals about
15:35:33 <simona> dcoutts: no, it's me, I'm stupid. I only looked in the top-level dir
15:35:37 <dcoutts> let me go push them
15:35:43 <dcoutts> simona, oh ok. :-)
15:36:04 <jophar_> >:t group
15:36:06 <simona> dcoutts: I have some changes, too. About paths not being created when you apiGen the very first time.
15:36:28 <dcoutts> simona, yeah the apiGen Makefile is rather less than perfect
15:37:47 <simona> dcoutts: I removed all of mogul from my makefile. Didn't you say you did that too? I tried darcs pull, but you didn't commit that.
15:38:22 <simona> dcoutts: The apiGen makefile does it's job. It's fine.
15:38:26 <dcoutts> simona, I rolled that back actually before pushing it. I/you can do it again though.
15:39:27 <dcoutts> simona, wel it doesn't work smoothly from a clean chckout, it needs some hand holding an poking to get the C source code downloaded & set up properly
15:41:00 <simona> dcoutts: Could you push the mogul removal, then? I'd like to resolve my first conflict :-O
15:43:05 <dcoutts> simona, ok hold on a sec
15:43:11 * dcoutts pushes apiGen patches
15:47:12 * dcoutts pushes mogul removal patch
15:47:26 <dcoutts> simona, I don't think this will resolve you conflict btw
15:47:33 <dcoutts> what is the conflict?
15:48:04 <simona> dcoutts: I don't have one as of yet. I will have one once you push the mogul-removal since I removed mogul myself already.
15:48:13 <dcoutts> ah ok
15:48:21 <dcoutts> did you record that change?
15:48:33 <simona> dcoutts: no
15:48:39 <dcoutts> then you'll be ok
15:49:45 <simona> dcoutts: darcs seems to be full of nice concepts. The only thing that threw me is that you can't delete a file that you've screwed up and say cvs update to resurrect it.
15:49:59 <dcoutts> simona, you can!
15:50:04 <dcoutts> you can darcs revert it
15:50:18 <xerox> Goodnight!
15:50:29 <simona> goodnight xerox
15:50:33 <dcoutts> "revert" changes thing back to the current recorded state
15:50:45 <dcoutts> including minor changes or whole file deletes
15:50:59 <dcoutts> and it promptes you for each change that you might want to revert
15:51:37 <simona> dcoutts: hm ok. I'll try that next time. The docs for 'darcs remove' seemed to say that unix 'rm' is final. I'll have a look again.
15:52:03 <dcoutts> simona, oh you did darcs remove, not just rm?
15:52:29 <dcoutts> because the deleted file is still there under _darcs/current/
15:52:34 <simona> dcoutts: I'm off. I'm too tired to get this function callback to work. Tomorrow.
15:52:49 <dcoutts> simona, ok see you
15:52:54 <simona> dcoutts: No, I was naive.  I did'rm'.
15:52:58 <simona> dcoutts: bye
15:53:01 <dcoutts> bye
15:53:02 <kevind> Cale: I gotta go now, but Ill be back
15:59:32 <araujo> Hello.
16:23:02 <mmc> i don't know haskell. But i am reading about monads this page: http://haskell.org/hawiki/MonadsAsContainers  and i don't undestand this line:
16:23:02 <mmc>   join xss = State (\s -> uncurry runState (runState xss s))
16:23:02 <mmc> for example: "runState xss s"  does haskell know that it applies  runState function to (only) the one argument xss?  and then from the result just the second "coordinate" is taken?
16:23:48 <mmc> I also wonder what is the meaning of "\s"
16:24:01 <gzl> it's a lambda expression
16:24:15 <gzl> (\x -> x + 1) is a function that takes one argument (call it x) and then adds 1 to it
16:24:41 <gzl> > f 4 where f = \x -> x + 1
16:24:45 <lambdabot> 5
16:26:04 <mmc> thanks;  what does (runState xss s)  mean?
16:26:23 <gzl> I don't know what runState does.
16:26:46 <ihope> @index runState
16:26:47 <lambdabot> Control.Monad.State, Control.Monad.RWS
16:26:56 <ihope> @type Control.Monad.State.runState
16:26:57 <lambdabot> forall s a. Control.Monad.State.State s a -> s -> (a, s)
16:27:23 <ihope> I'm guessing runState "removes" a data comstructor.
16:27:34 <ihope> @type Control.Monad.State.State
16:27:35 <lambdabot> forall a s. (s -> (a, s)) -> Control.Monad.State.State s a
16:27:49 <ihope> Yep. That one.
16:30:28 <gzl> hm, runState only takes one argument
16:30:31 * gzl scratches head
16:30:46 <ihope> Think of it as being s a -> (s -> (a, s))
16:31:03 <gzl> where do you get the s a from?
16:31:08 <gzl> it's just s -> (a,s)
16:31:11 <ihope> Remember that a function of 2 arguments is "really" a function of 1 argument returning a function of 1 argument.
16:31:20 <gzl> sure
16:31:21 <ihope> Hmm, whoops.
16:31:24 <gzl> but this is a function of one argument. :)
16:31:29 <gzl> so how do you give it two?
16:31:43 <ihope> Well, runState looks to have two to me.
16:31:59 <gzl> oh, wait. I'm looking at the wrong thing
16:32:13 <gzl> was looking online, where it said runState :: (s -> (a, s))
16:32:32 <ihope> Hmm...
16:32:45 <gzl> I must not be reading somethign properly
16:32:53 <Igloo> Because it's declared as a record, so being used as an accessor gives it the other argument
16:33:00 <gzl> ahh
16:33:02 <gzl> didn't know that
16:33:10 <ihope> ...Ah, I see.
16:33:54 <ihope> Now, why do we need callCC when we have (Cont . const)?
16:42:38 <ihope> Hey, it seems to be easy to write obfuscated code in Haskell!
16:43:21 <mmc> what did Igloo  mean by "being used as an accessor"?  Also I don't know what "uncurry" does?
16:43:30 <ihope> @type uncurry
16:43:31 <lambdabot> forall c b a. (a -> b -> c) -> (a, b) -> c
16:44:29 <ihope> And for the accessor thing: in a declaration such as data Foobar a b = {getFirst :: a, getSecond :: b}, getFirst and getSecond are the accessors.
16:44:45 <ihope> They take a Foobar a b and return whatever's in their type thingies.
16:45:31 <ihope> Ooh, wait...
16:45:45 <ihope> There should be a data constructor before those braces.
16:46:06 <nuffer> so uh
16:46:14 <ihope> Another example: data (a,b) = (,) {fst :: a, snd :: b}
16:47:04 <nuffer> if I have a network connection
16:47:10 <nuffer> and I write, say, 50 bytes to it via hPutBuf
16:47:27 <nuffer> and I attempt to read, say, 50 bytes on the other end with hGetBuf
16:47:41 <nuffer> is there any chance that I'll only get some of those in that first call to hGetBuf?
16:47:56 <nuffer> or does hGetBuf block until it reads the specified number of bytes?
16:54:41 <ihope> I'm guessing it'll do the blockage...
16:55:17 <nuffer> yeah, kind of looks like it
16:56:45 <nuffer> something belongs to a class if... it has all the functions associated with that?
16:56:56 <ihope> Yep.
16:57:13 <nuffer> I don't need to specify anywhere that I want it to be an instance of that class?
16:57:14 <ihope> Defining (>>=) and return makes something a Monad, for example.
16:57:23 <nuffer> okay
16:57:27 <ihope> Well, yes, you need to do it in an instance declaration.
16:57:35 <nuffer> huh?
16:57:45 <ihope> instance Monad [] where...
16:58:01 <nuffer> where... what?
16:58:16 <ihope> where... all the functions
16:58:16 <fatbrain> What ever happend to that cool watch we had on display the other day?
16:58:27 <ihope> instance Monad [] where
16:58:29 <nuffer> okay
16:58:32 <ihope>   return x = [x]
16:58:33 <nuffer> why the []?
16:58:43 <nuffer> oh, that's the Monad
16:58:48 <ihope> Yep.
17:03:13 <nuffer> um, for Storable, what's the point of alignment?
17:03:42 <nuffer> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Foreign-Storable.html#t%3AStorable
17:06:27 <eivuokko> Many processors behave unoptimally or plain send error if data is tried to access from wrongly aligned addresses.  Like typically you'd want to put 32bit words in addresses that are dividable by four.
17:06:44 <nuffer> right, I know that
17:06:53 <nuffer> but what does the alignment function in Storable want from me?
17:07:37 <eivuokko> The value of argument is not used.
17:07:48 <eivuokko> Reads there.  It is just to mark what type it's used on.
17:08:00 <nuffer> What?
17:08:23 <eivuokko> @type Foreign.alignment
17:08:25 <lambdabot> forall a. (Foreign.Storable.Storable a) => a -> Int
17:08:40 <eivuokko> The class constraint is resolved by giving a dummy parameter.
17:08:43 <nuffer> okay, can you give me an example implementation, or something?
17:08:54 <nuffer> because I'm just not understanding the point of this function
17:09:31 <eivuokko> instance Storable Data.Word32 where alignment _ = 4
17:09:37 <eivuokko> ?
17:10:10 <eivuokko> Typically used by alignment (undefined::Data.Word32)
17:10:20 <nuffer> so... is four a good value for that function regardless of what it is?
17:11:20 <eivuokko> It obviously is the alignment that is correct in regards of the type and underlying platform.
17:12:22 <nuffer> okay, I'm trying to Storable a binary tree type
17:12:28 <eivuokko> ..do you know how typeclasses work?
17:12:35 <nuffer> not in particular, no
17:12:41 <nuffer> I'm kind of new to this whole haskell thing
17:12:47 <eivuokko> Varied sized data structures aren't good candidates for Storable
17:12:51 <eivuokko> Ok..
17:13:06 <nuffer> well, ultimately I want to send this over a network, so it needs to be marshalled somehow
17:13:17 <nuffer> the docs made it seem like Storable is the standard way of doing that
17:13:37 <eivuokko> It is not for varied-size datastructures
17:13:59 <eivuokko> Or, rather, you use functions, but you don't specify instance of Storable
17:14:18 <nuffer> I'm sorry, explain a little more?
17:14:50 <eivuokko> Mhm, you should really read up on typeclasses.
17:15:46 <nuffer> why would I not specify instance of Storable?
17:15:57 <eivuokko> Because sizeOf can't work right for you
17:16:08 <nuffer> why not?
17:16:13 <nuffer> I can calculate sizeOf for a given a
17:16:16 <nuffer> it just won't be the same for every a
17:16:18 <eivuokko> Yea
17:16:24 <eivuokko> But read sizeOf docs
17:16:32 <nuffer> and why can't I just encode the sizeOf as the first byte of the new data structure?
17:16:34 <eivuokko> The value of the argument is not used.
17:16:55 <nuffer> oh... I missed that
17:17:08 <eivuokko> Well, ok, you *can* do it, very large portion of functions using Storable won't work right
17:17:21 <nuffer> right, right, I don't want to
17:17:32 <nuffer> so how do I want to marshall things to send them over the network?
17:17:33 <nuffer> by hand?
17:18:22 <eivuokko> Well, I usually make a functions like ... sizeOfMyStruct :: a -> Int  and pokeMyStruct :: Ptr b -> a -> IO ()
17:18:25 <eivuokko> .. ;)
17:18:51 <nuffer> Ptr b -> a -> IO ()?
17:18:54 <nuffer> why?
17:19:03 <eivuokko> Why which part?
17:19:13 <nuffer> b, a, the ()
17:19:16 <nuffer> basically all of it...
17:19:41 <nuffer> mostly why isn't it Ptr a -> a -> IO ()
17:19:41 <nuffer> I guess
17:20:00 <eivuokko> Ptr b because b doesn't matter when using pokeByteOff, a being mystruct-type, and () because it just pokes memory and doesn't return anything worthwhile
17:20:48 <nuffer> okay, and then I... poke my structure into memory, pass that pointer to the IO handle, and then on the other end, peek at it?
17:20:58 <eivuokko> Uhm
17:21:08 <eivuokko> Ah, you mean Handle, yeah.
17:21:17 <nuffer> sorry, not IO Handle
17:21:21 <nuffer> the Handle to IOy stuff
17:21:25 <eivuokko> Basically, yes.  Same rules apply as normally on marshalling, byteordering etc.
17:21:56 <eivuokko> (you need to take care of all those details by hand)
17:22:01 <nuffer> blech
17:22:02 <nuffer> thanks
17:23:08 <ihope> > fix return
17:23:10 <lambdabot>   Occurs check: cannot construct the infinite type: a = m a
17:23:10 <lambdabot>   Expected type: a -> a
17:23:10 <lambdabot>   Inferred type: a -> m a
17:23:51 <eivuokko> nuffer, http://darcs.tamelambda.net/repo/win32asio/System/Win32/Asio/CompletionPort.hsc <- there is very primitive writeOverlapped (could be done better esp because it uses hsc2hs already)
17:24:16 <eivuokko> There I don't have free variables on Ptr, tho.
17:24:52 <nuffer> mmmkay
17:24:53 <Oejet> Good evening.
17:25:02 <Speck> > liftM fix $ return
17:25:03 <lambdabot>  add an instance declaration for (Show (a -> a))
17:25:13 <Speck> @type liftM fix $ return
17:25:14 <lambdabot> Not in scope: `liftM'
17:25:14 <lambdabot>  
17:25:14 <lambdabot> <interactive>:1:6: Not in scope: `fix'
17:25:21 * Speck grumbles
17:25:35 <Speck> @type liftM Control.Monad.Fix.fix $ return
17:25:36 <lambdabot> Not in scope: `liftM'
17:25:42 * Speck gives up and goes away
17:26:50 <nuffer> so how do I allocate a chunk of memory to use with a Ptr?
17:27:42 <kevind> what does $ do?
17:27:56 <eivuokko> There is bunch of allocation functions, some in ForeignPtr (mallocForeignPtrBytes is fast and keeps itself garbage collected) and Foreign.Alloc
17:28:08 <eivuokko> @type ($)
17:28:10 <lambdabot> forall b a. (a -> b) -> a -> b
17:28:31 <eivuokko> It basically chains functions.
17:28:49 <nuffer> mmmkay
17:29:09 <kevind> so its used in place of parens?
17:29:23 <eivuokko> Indeed.
17:29:37 <kevind> cool
17:29:49 <eivuokko> foo a (bar c d (baz e)) becomes foo a $ bar c d $ baz e
17:31:32 <kevind> is it just like a ( whose pairing ) is as far to the right as possible?
17:31:45 <eivuokko> Yeah.
17:32:19 <eivuokko> I was just trying to figure out a way to explain that :)
17:33:48 <kevind> so what is the point of the $ in "liftM fix $ return"
17:34:01 <audreyt> there is no point :)
17:34:07 <eivuokko> Yeah, no idea.
17:34:37 <eivuokko> $ often linger in code after refactoring :)
17:35:26 <audreyt> the first time I read darcs's source, it's the $ that made absolutely no sense to me :)
17:35:46 <eivuokko> $\_->  ? ;)
17:35:46 <audreyt> (especially when there are two or more in a line)
17:36:01 <nuffer> so how do I actually write to a pointer?
17:36:02 <audreyt> which is why in my tutorial I made sure it's covered in the beginning
17:36:23 <dons> nuffer, newArray?
17:37:07 <audreyt> dons: this is your irregularly scheduled ping about releasing hs-plugins :)
17:37:23 <nuffer> oh, poke
17:37:24 <dons> sigh, yes  :) ACK :)
17:39:16 <jethr0_> i've got a question concerning haskell's records / data types...
17:39:46 <jethr0_> if i use a data type and later add another element, i'll have to change all the pattern matches to allow for an extra argument
17:40:03 <jethr0_> records on the other hand solve this problem, but clutter the namespace with their utility functions
17:40:25 <jethr0_> how do you solve this? with long, tedious record names?
17:42:58 <audreyt> jethr0: several ideas:
17:43:10 <audreyt> if you just want to match constructor, you can use the form
17:43:18 <audreyt> foo Constructor{} = ...
17:43:23 <audreyt> which works on non-record types
17:43:46 <nuffer> for a function like castPtr, how do I specify a and b?
17:43:50 <jethr0> interesting, didn't know that
17:43:51 <nuffer> (the types)
17:43:59 <audreyt> another idea is to use DrIFT to manufacture shorthands
17:44:21 <audreyt> and use (pattern) guards in place of explicit pattern matches
17:44:24 <kevind> you could use long tedious names in records but write your own accessor function to which you pass a more convenient label (lake a datatype member perhaps)
17:44:32 <jethr0> but most often i'd want to pattern match one of the many "arguments" out. isn't there some standard haskell way of addressing this, apart from drift?
17:44:33 <eivuokko> nuffer, they will be infered for you, if not, compiler will tell you you need to put annotations that take form of: foo :: A  where foo is an expression and A is the type it is.
17:45:08 <jethr0> hmm
17:45:17 <audreyt> jethr0: record type is the currently (admittably bad) only standard way
17:45:40 <audreyt> nuffer: you can say (castPtr :: Ptr CInt -> Ptr Int)
17:45:57 <jethr0> finding good record internal names is hard, as they describe the content as well as the accessor...
17:46:23 <nuffer> yay, it compiles
17:48:24 <audreyt> jethr0: if you always use qualified imports, that makes it easier (a bit)
17:48:37 <audreyt> otherwise you'll have to use per-data prefix.
17:48:57 * audreyt returns to $job &
17:50:00 <jethr0> thx
17:52:33 <Beelsebob> @paste
17:52:33 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
19:23:44 <nuffer> so if I have a Ptr Int
19:23:52 <nuffer> and I want to write out a sequence of Ints, that I have in a list
19:23:58 <nuffer> is there an easy way to do that?
19:30:55 <nuffer> basically I want a Ptr a -> [a] -> IO () function
19:32:40 <nuffer> does pokeArray do what I want?
19:32:46 <nuffer> @pokeArray
19:32:47 <lambdabot> Unknown command, try @listcommands.
19:32:51 <nuffer> @listcommands
19:32:51 <lambdabot> use listcommands [module|command]. Modules are:
19:32:51 <lambdabot> babel base code compose dice dict djinn dummy dynamic elite fact haddock
19:32:51 <lambdabot> help hoogle karma lShell localtime more pl plugs poll pretty quote search
19:32:51 <lambdabot> seen spell state system todo topic type version vixen where
19:33:25 <jethr0> @hoogle pokeArray
19:33:26 <lambdabot> Foreign.Marshal.Array.pokeArray :: Storable a => Ptr a -> [a] -> IO ()
19:33:26 <lambdabot> Foreign.Marshal.Array.pokeArray0 :: Storable a => a -> Ptr a -> [a] -> IO
19:33:26 <lambdabot> ()
19:34:22 <Korollary> nuffer: I don't see what the "Ptr a" is used for.
19:34:43 <nuffer> it gives the uh, pointer to where I want to write
19:38:17 <Korollary> it looks like poke is what you want
19:38:29 <Korollary> @index poke
19:38:29 <lambdabot> Foreign.Storable, Foreign
19:38:38 <Korollary> @type Foreign.poke
19:38:39 <lambdabot> forall a.
19:38:39 <lambdabot> (Foreign.Storable.Storable a) =>
19:38:39 <lambdabot> GHC.Ptr.Ptr a -> a -> IO ()
19:43:52 <nuffer> Korollary: no, I want to write out a list of values, not just one
19:44:00 <nuffer> I think pokeArray is what I want
19:47:21 <Korollary> nuffer: You can write a list of them. You'll need to advance the pointer.
19:59:13 <araujo> Haskell is bad, it makes you hate other programming languages.
20:00:32 <lispy> araujo: yes and appreciate things in some languages that you used to hate
20:00:50 <lispy> actually...maybe i can't back up that claim
20:02:38 <araujo> :-]
20:03:43 <lispy> the fact that you have unlimited eta expansion is really nice
20:04:01 <lispy> that's why we can have point free code (accroding to something i read anyway)
20:04:39 <dons> araujo, can I quote that for this weeks HWN?
20:05:01 <dons> well, maybe I'll just do it anyway ;)
20:05:06 <sh10151> i have plenty of point free code where I work
20:05:29 <sh10151> people just do any ol thing without bothering to see if it is needed
20:05:31 <lispy> sh10151: in haskell?
20:05:39 <lispy> heh
20:05:41 <sh10151> lol, no I am making a joke
20:05:43 <sh10151> :)
20:05:55 <dons> point less ;)
20:06:15 <lispy> dons: how would i make a code coverage tool for haskell?
20:06:27 <lispy> dons: please answer in 25 words or less ;)
20:06:37 <dons> to check that your tests are covering all top-level functions?
20:06:45 <dons> (for example?)
20:06:53 <lispy> i want to check that all definitions and uses are covered
20:07:03 <lispy> so, i'd want to check where clauses and let as well
20:07:18 <lispy> not sure what should happen in the case of optimizations
20:07:34 <Korollary> static coverage analysis?
20:07:45 <lispy> Korollary: what does static mean in this context?
20:07:52 <Korollary> without executing the program
20:08:01 <dons> harder. but I imagine you could run with profiling (or some other mechanism) to find all cost centres. then run the testing tool compiled against your code. then diff the cost centres produced by the test run, against the normal run.
20:08:09 <dons> anything missing isn't covered.
20:08:13 <dons> how's that?
20:08:15 <lispy> Korollary: i want to run unit tests (mostly) or even bigger tests and measure how much of the code is exercised
20:08:27 <Korollary> then, it's something like dons said.
20:08:40 <lispy> hmm...
20:09:05 <dons> just keep it simple at first. and extract top-level decls that are missing in the profiled/testing run.
20:09:09 <Korollary> c++ analyzers 'instrument' the binary where they insert data collection functions for example.
20:09:12 <dons> but that do appear in the normal run.
20:09:17 <lispy> so one tool would process the source, find the cost centers, generate an annotated source file, compile, run the tests, then measure percent hit?
20:09:28 <dons> yep, I reckon.
20:09:45 <dons> compile prog with profiling, run it. compile tests against prog, run that. diff foo.prof
20:10:10 <lispy> okay, not sure i follow that reasoning.  Why do you run it then compile tests against it?
20:10:20 <dons> you have to use profiing, as its our only built in mechanism to inspect program behaviour at runtime.
20:10:37 <dons> ah, the tests invoke different parts of the prog, right?
20:11:06 <dons> i'd run it first just to find out what code is actually executed. you could probably come up with that list statically though.
20:11:16 <dons> just dump all top level decls to a file, perhaps
20:11:31 <lispy> i want more than top level decls, but i think i see what you mean
20:11:39 <lispy> i wonder if the RTS should be changed
20:11:49 <dons> once you know what's in the code, link tests against profile prog, run that. diff all known decls against those that appeared in profiled test run
20:12:02 <dons> this would be a cool tool
20:12:19 <lispy> well, for one thing, it could help tell us how good a test suite is
20:12:57 <dons> yeah, you'd get some automagic feedback on how well you're doing testing
20:14:00 <lispy> the other tool i want, would let me single step through cost centers and inspect the heap
20:14:18 <dons> ah, that sounds like budha? or one of the other tracing tools
20:14:30 <dons> buddha/flamelghast or whatever it's called
20:14:31 <lispy> is budha interactive tho?
20:14:46 <lispy> when i looked at it i got the impression it wouldn't be useful
20:14:54 <dons> yup, i think you can go forwards and backwards, or maybe i'm on crack.
20:15:12 <dons> some tool out there lets you eval forwards and backwards. buddha i think lets you look into the heap.
20:15:20 <dons> none support all the ghc extns
20:15:20 <lispy> i wanted to inspect darcs runs so i get a picture of whats happening internally
20:15:44 <dons> i think the only thing that'll work on darcs in profile info atm.
20:15:53 <dons> adding more instrumentation would be cool though
20:15:53 <lispy> damn
20:20:57 <yain> hi.
20:21:52 <Korollary> hello
20:22:26 <yain> I'm building ghc from ports, it emits a lot of warnings about deprecated modules, does it signify that I'm doing something wrong?
20:23:28 <dons> nope, should be fine.
20:25:05 <yain> by the way, how long this procedure takes on the average?
20:25:32 <lispy> yain: took about 6 hours on my ibook
20:25:34 <yain> it's been around five hours already.
20:25:35 <yain> ok.
20:25:40 <lispy> yain: and that's at about 1.25Ghz
20:25:49 <lispy> yain: but, ibook is slow for its speed
20:26:39 <dons> people often complain about ghc when compiling on the ibook, i think it highlights the cpu perf a bit
20:27:11 <dons> s/often/i've seen it 3 or 4 times/
20:27:49 * Korollary doesn't 'get' Rebol.
20:28:25 <nuffer> is ghc coded in haskell?
20:29:09 <lispy> nuffer: i think a large portion of it is yeah
20:29:16 <nuffer> cool
20:29:20 <lispy> seems like there is a large body of C code for the run time as well
20:30:12 <araujo> dons, yeah, quote it !!
20:30:13 <araujo> :-)
20:30:17 <araujo> How you doing?
20:31:23 <dons> good good. though i just tried to mentally `grep' my living room for some tape i'd lost
20:31:36 <dons> note to self: grep only works on disks
20:32:01 <lispy> lol
20:32:19 <lispy> @quote+ dons note to self: grep only works on disks
20:32:19 <lambdabot> dons note to self: grep only works on disks hasn't said anything memorable
20:32:20 <dons> you've never done something like that?
20:32:29 <araujo> hah
20:32:33 <lispy> dons: how do i quote you on that?
20:32:54 <dons> when I was 16 and doing technical drawing, I would mentally hit ^Z (undo on my Mac) to erase pencil lines. didnn't work :/
20:32:57 <lispy> @help quote
20:32:57 <lambdabot>  @quote <nick>/@quote-add <nick> <quote>
20:32:57 <lambdabot> Quote somebody, or a random person, or save a memorable quote
20:33:05 <dons>  @remember 
20:33:16 <lispy> @quote-add dons note to self: grep only works on disks
20:33:34 <lispy> @quote dons
20:33:34 <lambdabot>  who was it who said (shapr?) that they welcome their competitors using
20:33:34 <lambdabot> languages other than haskell? it's a bad sign if your enemies start
20:33:34 <lambdabot> coding in haskell!
20:33:53 <lispy> heh, i could see shapr saying that
20:34:04 <lispy> dons: yeah, i've done those sorts of things befoer
20:35:08 <dons> grr. this is annoying not being able to find something. i just want to have the structure of my house make it easy to find things. a log n search tree of some kind would be good
20:35:27 <dons> it'll just require instance Ord for everything I own
20:36:03 <dons> pity you can't derive Ord on objects stored in my cupboard or desk
20:37:17 <lispy> hehe
20:37:25 <ozone> or Binary
20:37:39 <lispy> donOS is thrashing trying to find objects...
20:37:55 <lispy> quick, someone upgrade his ram
20:39:58 <dons> yeah NZone ;) Binary would be good!
20:41:20 <dons> oh well, looks like this missing tape is just going to be a memory leak. the GC has lost all references to it, but it's not collected
20:41:46 <lispy> heh
21:02:35 <Cale> hmm, kevind is gone
21:02:40 <Cale> I fixed his bug.
21:02:42 <Cale> (I think)
21:03:00 <Cale> also made his code readable :)
22:21:02 <shapr> lispy: Why did you ping me?
22:21:44 <shapr> Man, I want non-Plone contract work. Anybody know of some I can apply for? If it's Haskell contract work I would b especially interested.
22:50:40 <gour> dcoutts: ping
23:19:19 <shapr> Sure is quiet today.
23:20:20 <gour> and cold too, here, at least
23:27:01 <shapr> It's shockingly warm here today, 3Â° C
23:28:39 <dons> @yow!
23:28:39 <lambdabot> NATHAN ... your PARENTS were in a CARCRASH!!  They're VOIDED -- They
23:28:39 <lambdabot> COLLAPSED They had no CHAINSAWS ... They had no MONEY MACHINES ...
23:28:39 <lambdabot> They
23:28:39 <lambdabot> did PILLS in SKIMPY GRASS SKIRTS ... Nathan, I EMULATED them ... but
23:28:39 <lambdabot> they were OFF-KEY ...
23:30:25 <Korollary> My unit tests fail because I make more typos in the tests than in the actual code. Blargh!
23:30:40 <shapr> Korollary: Are you writing your tests first?
23:30:41 <dons> hehe
23:30:44 <shapr> g,day dons 
23:30:53 * shapr dropped his apostrophe, oops.
23:30:54 <Korollary> not really.
23:30:55 <dons> unit tests are good for finding bugs in unit tests
23:31:21 <dons> heya shapr
23:31:42 <dons> mm. hot summer nights. too hot to think
23:32:00 * shapr wishes...
23:32:03 <Korollary> "test first" is a good idea, but I play with my function types too often.
23:32:23 <shapr> How so?
23:32:41 <shapr> I exploit type inferencing to let me change my types without changing my unit tests.
23:33:02 <shapr> Doesn't always work, admittedly.
23:33:53 <gour> shapr: here it is -14C :-(
23:34:05 <dons> when I flew from helsinki to bangkok, the plane was full of pale pale finns heading south for the sun. maybe shapr should catch a flight..
23:34:23 <shapr> Yeah, I wish :-)
23:34:34 <shapr> I'd like to fly to a too-hot Oz.
23:34:36 <dons> on the way back, they were all sun burnt and pink :)
23:34:46 * shapr checks flight prices...
23:34:50 <dons> it's a long long flight though
23:35:42 <gour> shapr: you'd need some coins too - pocket money - besides the ticket :-)
23:35:50 <dons> hmm, maybe 1500 US return to northern europe?
23:36:00 <dons> thats somewhere around what I paid to go the other way
23:36:19 <dons> @google 1500 US dollars in australia dollars
23:36:21 <lambdabot> http://www.taiwan.com.au/Polieco/Trade/Australia/20050806.html
23:36:23 <dons> i wonder...
23:36:26 <dons> ah well.
23:37:10 <dons> nah, he can sleep on the beach, and eat the chips that the seagulls don't get to.
23:37:24 * shapr laughs
23:38:32 <dons> oh, more fun patches to ghc: * add double colon and double arrow symbols (-fglasgow-exts)
23:38:41 <dons> there's a double colon symbol?
23:39:09 <Korollary> Ugh
23:39:18 <dons> now, I just need vim *cough* I mean yi, to support unicode rendering of foralls and such like
23:39:36 <Korollary> Maybe somewhere deep in 8869-1 or something?
23:39:37 <dons> K, you don't like?
23:41:28 <Korollary> I dont see anything like those in windows' character map for courier.
23:42:51 <shapr> double arrow? -> -> ?
23:43:02 <gour> dons: pida project develops nicely (of course, they use vim), so i wonder whether yi can catch up for the hIDE?
23:43:51 <dons> pida?
23:44:01 <dons> shapr, => maybe?
23:45:34 <gour> dons:http://pida.vm.bytemark.co.uk/projects/pida/wiki
23:46:31 <dons> ah, I see what you mean
23:47:35 <shapr> oh, that double arrow.
23:48:15 <shapr> I'm confused.. what does symbol mean in this context? How is a symbol different from the :: and => we've used for years?
23:48:30 <Korollary> those are not symbols iirc
23:48:36 <dons> instead of typing two chars, you can use one unicode char
23:48:46 <shapr> oh!
23:48:59 <dons> and instad of the 'forall' keyword, for example, you use \/  -- youknow what i mean.
23:49:09 * Korollary tries to remember the symbol vs lexeme stuff from the dragon book.
23:49:10 <shapr> Yeah, nifty.
23:49:10 <dons> sorry, /\
23:49:32 <Korollary> no, forall is like \/, sorta like an upside down A
23:49:35 <shapr> So ghc can handle unicode sources now?
23:50:02 <dons> oh, yeah, of course. /silly me.
23:50:10 <dons> shapr, yes. recent patches went in
23:50:34 <Korollary> why 'double' arrow then? why not single?
23:50:43 <dons>  well, we already have a symbol for ->
23:50:47 <dons> and now we also get =>
23:50:51 <dons> (I think)
23:51:29 <astrolabe> I'm not sure allowing unicode is a good idea (though english is my native language, so I'm biased).
23:51:39 <Korollary> ah, double arrow for the context
23:52:06 <dons> it's really nice in some of the theorem provers, particularly the `proof general' interface to Isabelle.
23:52:06 <shapr> English is my native language, but I've wanted unicode support for years.
23:52:38 <astrolabe> My worry is that it makes it harder to edit a source code file.
23:52:40 <flux__> can we use the unicode representations of \alpha and \beta in haskell?-)
23:53:08 <dons> they're valid varids, so i hope so
23:54:23 <nnunley> Biggest problem with unicode is keyboard input
23:54:56 <shapr> I'll just set hyper-a to \/, hyper l to \lambda, etc
23:55:12 <nnunley> It makes for the same issue as what APL has.
23:55:14 <shapr> It's nice to have meta, alt, super, and hyper available.
23:55:19 <nnunley> True.
23:55:57 <dons> maybe just as good would be to keep the src ascii, but have the editor markup 'forall' as the a symbol, and so on.
23:55:57 <astrolabe> What do you do with characters you don't recognise?
23:56:09 <shapr> Oh hey, for inputting unicode chars, interactive input modes would be handy.
23:57:43 <Korollary> I think the idea was that the non-english unicode texts would come from the non-english keyboards. I'd have to program the f-keys to print out exotic symbols for a programming language.
23:58:04 <Korollary> or a haskell programmer's keyboard layour with an extra row of keys.
23:58:07 <astrolabe> Also, it is nice being able to at least pronounce variable names, it helps me think about code.  I've noticed that people that don't know the greek alphabet have to make up names for the greek letters in order to think about formulas using them.
23:58:07 <shapr> astrolabe: That problem has existed forever. I've publically wished for a community indexable symbol lookup repository.
23:58:35 * sieni wonders if one should start hacking Yi
23:58:49 <Korollary> sieni: read TaPL instead
23:58:49 <shapr> astrolabe: I don't get that, speech has nothing to do with programming for me. Admittedly past discussions here on #haskell have shown me that it *is* important to 99% of humans.
23:58:58 <shapr> hack Yi!
23:59:03 <shapr> I despise emacs!
23:59:11 <shapr> And yet, it's the best editor I've found :-/
23:59:45 <astrolabe> shapr: It is definitely important to me.  I must sub-vocalise or something.  I would get confused if two variables sounded the same.
