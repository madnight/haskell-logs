00:01:27 <ncalexan> @hoogle topSort
00:01:28 <lambdabot> Data.Graph.topSort :: Graph -> [Vertex]
00:01:28 <lambdabot> Data.Graph.Inductive.Query.DFS.topsort :: Graph gr => gr a b -> [Node]
00:01:28 <lambdabot> Data.Graph.Inductive.Query.DFS.topsort' :: Graph gr => gr a b -> [a]
00:01:28 <palomer> ie, build the lattice
00:01:31 <jethr0> is an NTree a forest or how will you deal with multiple trees? if you can find some kind of GCD then you won't have to check all combinations...
00:02:17 <ncalexan> palomer: that probably does it.  You topSort them, then find longest path.  Remove longest path, and repeat on the remaining forest.
00:02:25 <ncalexan> Anyway, g'night all.
00:02:27 <palomer> NTree a = Empty | Node a [NTree]
00:03:16 <jethr0> yes, but what do you do if you have no common minimum in the list? if you have a way of finding a minimum then you can just find it on the whole list, instead of trying the list elements against each other
00:03:30 <palomer> oh, true
00:04:06 <palomer> ok, then I need a full blown graph
00:04:10 <palomer> assymetric
00:04:23 <jethr0> uhu
00:04:45 <jip> anyone familiar with the yampa switch function?
00:05:13 <jethr0> not really, sth technically you're struggling with?
00:05:54 <jip> yeah, switch requires that a single event source be used for switching, but my switch event source is part of the switched signal function
00:07:57 <jethr0> hmm, that's _way_ over my head :).
00:09:19 <jethr0> but i would guess that most times the event source would lie inside the switched part or at least have its origins in there
00:10:08 <jethr0> although i have no clue of yampa, couldn't run the events from inside the switch to another node which forwards them and sends them back to the switch :)
00:10:08 <jip> hm.... i probably can use rSwitch
00:28:59 <gour> dcoutts: ping
00:42:17 <newsham> re
00:43:30 <jethr0> re
00:43:40 <newsham> ahh, just the person I wanted to see. :)
00:43:48 <jethr0> good to hear
00:43:56 <newsham> I'm looking over your examples, and I'm not sure it will work for me.
00:44:05 <jethr0> which one?
00:44:26 <newsham> TH, using $(dyn ...)
00:44:36 <jethr0> ah, why won't it work?
00:45:26 <newsham> so at compile time I am running my generation function.. and it has to do the equivalent of   foreach name [list of names from argument] : .... do stuf ...
00:45:48 <newsham> and part of .. do stuff..  it needs to know the length of what name refers to
00:45:56 <newsham> ie if "name" is "x" it needs to know "length x"
00:46:08 <jethr0> do you want to print the resulting code or directly compile it?
00:46:38 <newsham> so I want a function     "getLen n"  which somehow does     "appE length (mkName n)"
00:46:47 <newsham> I need the result while doing my generation.
00:46:53 <newsham> I dont want to generate the result, I need it during generation.
00:47:24 <newsham> you're example was:  let x = "hello" in $([| length $(dyn "x") |])
00:47:38 <newsham> which is similar, except the whole $(...) bit only gets expanded just the once, right?
00:47:38 <Lemmih> dons: ping.
00:49:13 <jethr0> hmm
00:49:36 <newsham> I want something more like:   getLen n = $( appE (mkName "length") (mkName n) )
00:50:08 <jethr0> just a sec
00:50:16 <newsham> except obvously not just expanded the one time for one particular "n" :)
00:50:48 <newsham> is there any function to "run" an AppE?
00:50:54 <newsham> (an ExpQ I guess)
00:51:14 <newsham> I dont imagine so, since its type wouldn't be fixed :\
00:54:21 <newsham> ok, here's a good example of what I'm trying to do thats pretty simple.
00:54:29 <jethr0> but it's pretty certain that you're touching on the less beautiful things in TH :)
00:54:47 <newsham> > genLen n fs = funD (mkName "containerLength") [c] where
00:54:47 <newsham> >       l = sum (map flen fs)
00:54:47 <newsham> >       c = clause [(varP (mkName "x"))] (normalB (iLit l)) []
00:54:48 <lambdabot>  parse error on input `='
00:54:48 <lambdabot>  parse error on input `='
00:54:48 <lambdabot>  parse error on input `='
00:55:04 <jethr0> problem is: you can't have a function "f x = $(...x...)" because the splice is evaluated before the function is even called
00:55:21 <newsham> thats just trying to generate "containerLength x = 20"   for some constant "20" that is created by     sum (map flen fs)
00:56:04 <newsham> I just need to make the "flen", the function which takes in a name of an object, and returns whatever "containerLength obj" would return
00:58:22 <jethr0> working on it...
00:58:58 <jethr0> $([|let getLen = $(do name <- (newName "n"); lamE [varP name] (appE (dyn "length") (varE name))) in getLen "hello"|])
00:59:05 <jethr0> *brr*
01:02:24 <jethr0> this creates a function that takes a name, and applies length to the variable with that name
01:03:01 <jethr0> pseudocode:  let getLen = \n -> length (resolve n) in getLen "hello"
01:05:47 <newsham> but only for "hello" right?
01:05:57 <newsham> i mean..it only expands that once for "hello", youc ant reuse it for other strings
01:06:34 <jethr0> newsham: you mean because of the let? otherwise it's a normal function
01:07:28 <newsham> so I can say   foo = $( ... )   and then at the ghci prompt type   foo "bar"    to get "length bar" ?
01:08:10 <jethr0> $([|let getLen = $(do name <- (newName "n"); lamE [varP name] (appE (dyn "length") (varE name))) in (getLen "hello") + (getLen "abc")|])
01:08:15 <jethr0> results to "8"
01:09:08 <jethr0> yes. but if you want to make that call inside a file you'll have to declare the function in another module (i.e. another file and import it from there) or use let inside your top-level splice.
01:10:10 <jethr0> actually "varE 'length" is cleaner than 'dyn "length"'
01:10:33 <newsham> I'm not sure I understand why you use a let statement.
01:11:41 <jethr0> because you can't use functions declared inside the same module within a splice. you either have to declare them in another module or locally declare them using "let" inside the splice you need them in.
01:13:15 <dcoutts> gour, pong
01:13:29 <dcoutts> Lemmih, pong
01:14:04 <newsham> I still dont think this is going to work.  perhaps I'm just not getting it.   would you be interested in looking at what I have?
01:14:16 <jethr0> sure
01:14:17 <jip> man this yampa shit can be quite difficult :'(
01:15:04 <dcoutts> dons, I run gentoo on 32bit x86, 64bit x86 and 64bit/32bit (kernel/user) Sparc. Does that help?
01:15:14 <Saulzar> jip, How goes tetris?
01:15:20 <gour> dcoutts: just a min to finish something on #evolution
01:15:25 <jip> Saulzar: slow progress but i'm getting there
01:16:17 <newsham> http://lava.net/~newsham/x/jethr0/   has four files (all pretty small, except maybe ByteContainer and Gen)
01:16:45 <newsham> tst is the one I am testing on     ghc -c -fth -ddump-splices tst.lhs for example
01:16:48 <Lemmih> dcoutts: I was interested in the patch for gtk2hs but I worked around it by unpulling some patches.
01:17:02 <newsham> right now ti all works, except I'm faking the length as 2 for each field, instead of computing it
01:17:09 <dcoutts> Lemmih, yeah, that'd work too.
01:17:35 <newsham> (I copied the files as both .txt and .lhs, because my browser tries to run hugs if I click on a .lhs)
01:17:36 <dcoutts> Lemmih, I'll tel you when the main repo is buildable again
01:17:44 <Lemmih> dcoutts: But neither hs-plugins or yi+gtk works with GHC-6.5 so I'm stuck again /-:
01:18:24 <jethr0> newsham: i'll have a look at it
01:18:28 <dcoutts> Lemmih, well you know who to bug about that :-)
01:18:40 <Lemmih> @localtime dons 
01:18:44 <lambdabot> Local time for dons is Fri Jan 20 20:16:25 2006
01:20:49 <newsham> all types "X" have a definition "newX = .." to create a default object.
01:21:11 <newsham> so the function   "containerLength newX" should return the length for any type "X"
01:22:14 <newsham> which is what I want to call dynamically during generation to get a length given a string name of a type
01:24:29 <jethr0> working on it :)
01:25:36 <jethr0> what is the type of "n" in "flen"?
01:25:49 <newsham> t = type name, n = field name, d = default value ,  all three strings.
01:26:35 <newsham> probably easiest to generate is   containerLength of  ("new" ++ t)
01:26:47 <newsham> ie.  "newIP" or "newWord8" etc..
01:29:22 <jethr0> having some typing problems...
01:29:30 <newsham> seems like what I really want is introspection.  :(
01:29:49 <newsham> I want to be able to fetch an object by dynamic name.
01:30:42 <newsham> seems like that would be hard to make type safe
01:30:49 <jethr0> > containerLength = $(do name <- (newName "n"); lamE [varP name] (appE (varE 'length) (varE name)))
01:30:50 <lambdabot>  parse error on input `='
01:30:55 * jip brain implode
01:30:56 <jethr0> > flen (t, n, d) = toInteger $ containerLength "ab"
01:30:57 <lambdabot>  parse error on input `='
01:30:59 <jethr0> works
01:31:15 <Lemmih> Wow. (.) looks really cool in UTF-8.
01:31:57 <newsham> hmmm?  I already have a "containerLength" defined in ByteContainer.lhs
01:32:07 <jethr0> ups
01:32:53 <jethr0> so, what should "flen" do?
01:33:08 <jethr0> or should i just rename my function to sth else?
01:33:17 <jethr0> name it nameLength
01:33:46 <newsham> flen("Word8",_,_)    should return whatever    "containerLength newWord8"   evaluates to
01:34:00 <newsham> and flen("IP",_,_)    shoudl return whatever "containerLength newIP" evaluates to
01:34:04 <jethr0> ah, ok
01:35:19 <newsham> hmm.. does this mean that Gen.lhs will ahve to know about all containerLength definitions?
01:35:36 <newsham> or is it ok if the module that invoked the expansion (ie. tst.lhs) knows
01:36:15 <jethr0> argh
01:36:40 <jethr0> let me think a moment. this is pretty confusing...
01:39:15 <jethr0> newsham: this'll take me a while :)
01:39:40 <newsham> sorry for the headache.  wish I could offer you some asprin.
01:40:28 <jethr0> hehe
01:42:10 <gour> dcoutts: huh, had to submit some bug reports for evo crashes :-(
01:42:29 <gour> dcoutts: forgot to ask you yesterday when pinging you...
01:43:15 <gour> dcoutts: anything new with SF archives? this week I'm holding a new seminar, but next week i can find some free-slot to help if we'd do migration
01:43:52 <gour> dcoutts: s/this weeek/this weekend/
01:44:23 <gour> dcoutts: and one humble request..if you can do me a favor...
01:45:13 <jethr0> newsham: i'm not sure what you want to do is possible with TH. my guess that you'd have to use some kind of "eval" for it
01:45:24 <newsham> yah, thats what I was thinking.
01:45:50 <newsham> since how could you know that making a new expression and evaluating it is even going to return the right type you want
01:46:11 <jethr0> you only have to find a way to eval 'varE "hello"' or sth like that
01:46:20 <newsham> well, this is somewhat disappointing.
01:46:42 <jethr0> TH checks for type safety at each substitution
01:47:11 <newsham> I'll post the problem to TH list to see if anyone has any bright ideas.
01:47:20 <jethr0> maybe i'm missing sth. i'll ponder the matter a little longer :)
01:52:58 <dcoutts> gour, Axel is not so sure we need to move. I've changed the email that I subscribe to the lists and it does seem to be quicker. So perhaps the problems were not with the mailing list.
01:53:32 <newsham> jethr0: how about a completely different angle....
01:54:04 <newsham> is it possible for me to lookup the definition of "makeContainer" in a given class?
01:54:08 <gour> dcoutts: i also had a problem with my server as well :-)
01:54:25 <newsham> if so, I can just peek at the constant value on the RHS of the definition.
01:54:31 <dcoutts> gour, so we'll leave it for the moment and see how it's going.
01:54:32 <gour> dcoutts: if Axel is not for it - fine, i.e. less work ;)
01:54:40 <dcoutts> yeah
01:54:57 <jethr0> newsham: as far as i know not. but my knowledge is pretty limited
01:55:19 <jethr0> all you need is to eval a variable to its content, but i'm not sure whether TH can do that
01:55:34 <gour> dcoutts: can you do me a favor (it's not rush) ?
01:55:38 <newsham> cant you get a handle on things with reify?
01:55:58 <newsham> ie. can I "reify 'makeContainer" and then get back an AST of its definition?
01:56:05 <dcoutts> gour, what?
01:56:23 <newsham> hmm.. that will just give me its type I guess
01:56:24 <jethr0> newsham: that's what i'm missing myself, but i don't think so (i.e. i'm not sure)
01:57:11 <gour> dcoutts: i'm considering that  A Functional Programming Approach book (by Fethi & Lapalme) could be (maybe) better suited for me than Okasaki (at least after finishing with thompson's)
01:57:49 <dcoutts> gour, I don't know that book.
01:57:55 <gour> dcoutts: i'm sure you have a copy in you uni-lib. can you once (when you ahve some time) just skim through and telly me your opinion
01:58:26 * gour has cold fingers and types badly :-)
01:58:28 <dcoutts> gour, oh, I see. Hmm. I can take a look.
01:59:01 <gour> dcoutts: thanks a lot. you're aware of my skills & my needs :-)
02:04:19 <jip> does (||) use "short circuit logic", like in c? since haskell is lazy i'm thinking that it might, but it also might not
02:04:43 <jethr0> newsham: hmm, i'm pretty much out of ideas
02:04:56 <newsham> I appreciate your help.  thank you.
02:05:01 <int-e> > True || error "Blah"
02:05:03 <lambdabot> True
02:05:07 <int-e> > False || error "Blah"
02:05:08 <lambdabot> Exception: Blah
02:05:16 <int-e> jip: see? it does :)
02:05:18 <newsham> jip: if computation has no side effect, does it matter if it is short circuited or not?
02:05:19 <jip> > error "Blah" || True
02:05:21 <lambdabot> Exception: Blah
02:05:38 <tibbe> hmm
02:05:38 <jethr0> np, sry that i didn't see this problem coming earlier
02:05:41 <jip> newsham: yes if there is an error like we see here :)
02:06:19 <jip> int-e: but isn't this behaviour implementation dependant?
02:06:22 <newsham> maybe someone on TH list will tell me I'm doing it all wrong and show me the way.
02:07:14 <jethr0> what you're trying to do is letting TH generate meta code...
02:07:53 <int-e> jip: the standard Prelude defines it to check the first argument first.
02:08:32 <newsham> True  || _       =  True
02:08:33 <newsham> False || x       =  x
02:09:13 <jip> int-e: interesting.... but doesn't this requirement potentially limit optimizations?
02:09:21 <int-e> jip: and implementations have to provide the same semantics for those functions, although they do not necessarily have to use the same implementation.
02:09:49 <int-e> jip see http://www.haskell.org/onlinereport/standard-prelude.html ... especially the first sentence.
02:10:03 <int-e> and the second.
02:11:05 <newsham> time to sleep.
02:11:36 <jethr0> nite
02:13:16 <jip> int-e: thank you
02:14:33 <jip> ghci has a major flaw
02:16:34 <eivuokko> Hmm?
02:17:37 <jip> if i do :reload and it fails, then it should revert to having the previous version of the module loaded, instead of not having it loaded at all
02:26:46 <eivuokko> I don't feel that as a great burden, but I guess.  I think also that I'd it rather load as much as it can, so I can play with the parts that were ok.
02:28:00 <jip> it's a burden for me because if i modify some code and i get errors then i like to be able to examine the types and values of expressions so that i can figure out the reason for the error
03:30:23 <dcoutts> Lemmih, you can try pulling now, it should work.
04:07:39 <eivuokko> Where could I find information how IORef and StablePtrs affect gc performance?  (In GHC)
04:10:04 <Philippa> eivuokko: I'm pretty sure IORef works much the same as STRef, not that that's necessarily useful
04:10:29 <eivuokko> It really isn't, unless there are docs about STRef properties.
04:10:47 <eivuokko> I just recall seeing people on mailing lists saying iorefs are somehow slow for gc
04:10:47 <Philippa> probably somewhere. Had a poke around the GHC documentation page? There's quite a lot on the RTS
04:11:38 <eivuokko> http://hackage.haskell.org/trac/ghc/wiki/GhcPapers This one?
04:14:01 <eivuokko> I was just wondering if it is bad if I have ioref per open file/other device handle and stableptr per io-request (in my async io code)
04:26:58 <araujo> Good morning.
04:27:33 <Lemmih> Hiya araujo.
04:30:40 <pesco> Hi wilx.
04:32:16 <wilx> Hi.
04:32:42 <pesco> Are you still up for a meeting?
04:33:12 <wilx> Sure :)
04:35:23 <pesco> wilx: Cool! When do you have time? I'm pretty flexible.
04:38:21 <wilx> Pretty much whole weekend.
04:48:15 <eivuokko> Philippa, I read/skimmed through the relevant looking rts docs, but they offer (as far as I can tell) no information on performance characteristics.  Thanks for help, anyhow :)
04:49:11 <eivuokko> Well, *real* performance anyway.
04:50:22 <Lemmih> dcoutts: I really wanna use something else than hs-plugins for hIDE.
04:50:38 <dcoutts> Lemmih, like?
04:51:35 <Lemmih> A small rewrite specialized for hIDE.
04:51:54 <dcoutts> Lemmih, if it's causing troubles we can build things statically for the moment
04:52:31 <dcoutts> A static build should just be a matter of making a top level bit that deps on all the modules and calls their initialisation funcs.
04:53:16 <dcoutts> we can then fix hs-plugins or extract the minimal features that we need, but in the mean time it will not hold things up
04:53:37 <dcoutts> using the GHC api might be easier in the short term with a static build.
04:54:35 <dcoutts> Lemmih, we need to be able to do satic builds anyway for arches where hs-plugins doesn't work.
04:55:30 <jip> what is wrong with hs-plugins?
04:55:39 <dcoutts> Lemmih, what do you reckon?
04:55:57 <kolmodin> hey guys
04:56:05 <dcoutts> Lemmih, yes, what is the exact problem at the moment with hs-plugins?
04:56:09 <dcoutts> hia kolmodin 
04:56:13 <Lemmih> jip: It's a horrible dirty hack.
04:56:18 <dcoutts> heh :-)
04:56:30 <jip> but it works! :o
04:56:32 <dcoutts> is that all :-)
04:56:50 <dcoutts> Lemmih, how might it be improved do you think?
04:56:50 <Lemmih> jip: No, it doesn't! That's the problem (:
04:57:38 <dcoutts> Lemmih, with our module/package organisation we ought to be able to support both dynamic and static builds.
04:57:58 <kolmodin> is there a holdup on hIDE? there hasn't been much done lately (that I've seen)
04:57:59 <Lemmih> Indeed.
04:58:22 <dcoutts> kolmodin, I've been hacking on Gtk2Hs featuresneeded for the hIDE GUI.
04:58:32 <kolmodin> yes, the treeview
04:58:35 <jip> but i think that hs-plugins would be useful for an ide for more then just dynamic loading of ide plugins
04:58:37 <dcoutts> yep
04:58:55 <kolmodin> is the treeview online somewhere? :)
04:59:11 <dcoutts> kolmodin, the docs are, the code is nearly in the repo
04:59:24 <kolmodin> ok
04:59:26 <Lemmih> jip: How so?
04:59:36 <dcoutts> kolmodin, http://haskell.org/gtk2hs/docs/devel/Graphics-UI-Gtk-TreeList-CustomStore.html
04:59:46 <dcoutts> and: http://haskell.org/gtk2hs/docs/devel/Graphics-UI-Gtk-TreeList-ListStore.html
04:59:59 <dcoutts> and the TreeStore, though it's less done
05:00:09 <kolmodin> dcoutts: thanks
05:00:17 <dcoutts> kolmodin, the CustomStore is a low level interface that one can implement
05:00:36 <dcoutts> to get a TreeModel which one can connect to the TreeView
05:00:50 <kolmodin> hmm, ok
05:00:51 <jip> Lemmih: like for creating something like ghci directly in the ide, or being able to highlight an expression in your code and being told of what type it is
05:01:07 <dcoutts> kolmodin, the ListStore uses that CustomStore interface to provide an ordinary list style store.
05:01:13 <Lemmih> jip: hs-plugins can't do that.
05:01:29 <dcoutts> kolmodin, but with a nicer Haskell api than the old C ListStore that we've got now.
05:01:33 <Lemmih> jip: We'll do that with the GHC library.
05:01:36 <kolmodin> ohh, generated with haddock 0.8
05:02:03 <dcoutts> kolmodin, er, yes. I've been hacking on haddock too.
05:02:09 <kolmodin> :D
05:02:10 <dcoutts> kolmodin, see the wiki links? :-)
05:02:31 <kolmodin> dcoutts: yes, impressive :) good idea
05:02:54 <Lemmih> jip: hIDE is already capable of doing runtime typechecking.
05:02:56 <dcoutts> kolmodin, now I'm looking at geting source code links to work.
05:03:24 <dcoutts> kolmodin, which requires teaching haddock how to read {-# LINE ... #-} pragmas.
05:03:55 <kolmodin> ah, not trivial I belive
05:04:15 <dcoutts> kolmodin, mmm, not quite sure yet.
05:04:23 <dcoutts> kolmodin, want to help? :-)
05:05:28 <kolmodin> you need to fix the lexer, the parser, the AST just to get the pragma
05:05:33 <kolmodin> ... etc
05:05:48 <dcoutts> not the parser I think.
05:05:55 <dcoutts> it can all be done in the lexer
05:05:58 <kolmodin> oh
05:06:20 <dcoutts> one just extends the SrcLoc with a file name, in addition to the line & column
05:06:44 <dcoutts> then when you get the src loc of a func it includes the file name
05:06:53 <dcoutts> (I think)
05:07:11 <dcoutts> that's how ghc's lexer does it anyway
05:07:17 <kolmodin> right
05:07:36 <dcoutts> and haddock's lexer/parser were originally based on ghc's
05:07:53 <kolmodin> too bad you can't just use GHC's parser in haddock :)
05:08:32 <dcoutts> yeah
05:08:42 <dcoutts> haddock's parser needs re-syncing with ghc's
05:09:14 <dcoutts> haddock produces pretty terrible parse error messages.
05:10:25 <kolmodin> a year ago when I was working on haste I wanted to use the GHC package to parse haskell code to get all sorts of cool features
05:10:42 <dcoutts> but it wasn't really ready then?
05:10:48 <kolmodin> it ended up with that I took haddock's parser istead
05:10:55 <dcoutts> ah
05:11:04 <dcoutts> so you probably know it better than me
05:11:05 <kolmodin> no it wasn't, couldn't even get it to compile
05:11:35 <kolmodin> even though I got help from the mailing list :)
05:12:42 <kolmodin> it was to, among other things, get this feature: http://haste.dyndns.org:8080/screenshots/screenshot_hovering_r305.png
05:12:56 <dcoutts> right
05:13:08 <dcoutts> nice
05:13:16 <jip> are there any screenshots of hIDE?
05:13:20 <kolmodin> I thought so too :)
05:13:32 <dcoutts> kolmodin, so you show the haddock doc for a func when you hover over it
05:13:39 <kolmodin> so if we could make hIDE do that too it would be great
05:13:43 <kolmodin> dcoutts: exactly
05:13:49 <dcoutts> kolmodin, as well as it's type. That is really cool.
05:14:02 <kolmodin> it's very helpful
05:14:08 <kolmodin> (and cool :))
05:14:08 <dcoutts> I bet
05:14:19 <dcoutts> @where hIDE
05:14:20 <lambdabot> http://www.haskell.org/hawiki/hIDE
05:14:42 <kolmodin> ah, there is a screenshot on the wiki
05:15:08 <dcoutts> jip, and I've got a couple hIDE screenshots:
05:15:09 <dcoutts> http://www.haskell.org/~duncan/hIDE/hIDE%20main%20window.png
05:15:16 <dcoutts> http://www.haskell.org/~duncan/hIDE/hIDE-htmlviewer.png
05:15:34 <dcoutts> http://www.haskell.org/~duncan/hIDE/hIDE2.png
05:16:15 <dcoutts> the last one shows type errors being highlited in the buffer
05:17:07 <Lemmih> There's also: http://212.242.49.100/typechecking.png
05:17:23 <kolmodin> in haste we ran ghc as an external process and parsed the output :)
05:17:44 <kolmodin> to get error messages and stuff :)
05:17:49 <jip> cool
05:17:53 <dcoutts> kolmodin, I bet it's quicker doing it in process :-)
05:18:13 <dcoutts> for one thing we can avoid generating any code.
05:18:14 <kolmodin> I bet :)
05:18:49 <dcoutts> kolmodin, how often did you run ghc?
05:18:55 <dcoutts> every time the buffer changed?
05:19:02 <dcoutts> after a timeout?
05:19:14 <kolmodin> no, only when the user pushed the compile button
05:19:18 <tic|school> kolmoooo-din
05:19:19 <dcoutts> ok
05:19:23 <kolmodin> tic|school: hi
05:19:33 <tic|school> kolmodin, decided yet?:)
05:19:33 <eivuokko> Visual Haskell runs parser on save, I think.
05:19:40 <kolmodin> tic|school: nope
05:20:04 <dcoutts> I think hIDE currently runs the ghc parser in a new thread each time the buffer changes, but with a second or so delay
05:20:09 <eivuokko> It is slightly annoying as it cannot be turned off, and it can eat battery when working on laptop without external power.
05:20:14 <dcoutts> so that if you're typing rapidly it doesn't do anything
05:20:29 <tic|school> kolmodin, m'kay.
05:20:38 <dcoutts> Lemmih, right?
05:20:42 <Lemmih> dcoutts: Right.
05:21:04 <kolmodin> dcoutts: sounds good
05:21:04 <pesco> eivuokko: Just keep typing! ;)
05:21:08 <dcoutts> Lemmih, how well did that seem to be in the end? from an interactivity point of view?
05:21:25 <eivuokko> pesco, Hehe :)
05:21:27 <Lemmih> dcoutts: It worked really great.
05:21:29 <kolmodin> perhaps we should implement a battery saving mode :)
05:21:31 <dcoutts> Lemmih, cool
05:21:39 <dcoutts> kolmodin, yeah, a pref somewhere.
05:22:08 <dcoutts> Lemmih, so it kills any existing GHC background thread? or did GHC complain about that?
05:22:28 <dcoutts> Lemmih, I seem to remember it didn't handle async exceptions well.
05:24:25 <Lemmih> Hm, right, I can't remember if I got around that.
05:26:06 <dcoutts> Lemmih, I'm sure we can work around it. The only problem would be if the GHC thread didn't clear up its resources properly.
05:37:17 <araujo> hellu Lemmih !
05:37:25 <araujo> dcoutts, hiya!
05:37:38 <jip> man threading RandomGens through yampa programs is more painful then having toe-nails ripped off :'(
05:40:18 <Saulzar> Hmm, didn't the space invaders thingey just pass it as a top level to the func returning an object SF ?
05:40:24 <Heffalump> jip: could you use an state arrow transformer?
05:40:31 <dcoutts> hi araujo 
05:43:16 <Saulzar> I'm having a fun time debugging space leaks with my program, I have a suspicion it doesn't help to use a half-yampa bastardised design.
05:46:50 <SamB> Saulzar: probably it doesn't ;-)
05:47:19 <SamB> what exactly is a state arrow
05:47:21 <Saulzar> I have removed all functionality and it still leaks :)
05:47:41 <SamB> Saulzar: ouch
05:48:27 <Saulzar> retainer profiling isn't helping, it just says the retainer is "react"  which is the yampa entry point...
05:49:23 <SamB> what are you trying to write? that robot match thingy?
05:49:46 <Saulzar> Yeah.
05:50:42 <SamB> what are the random numbers for?
05:51:07 <SamB> also, how do you build Yampa?
05:52:10 <Saulzar> Hmm, the build files are slightly out of date, I've just been using it by pointing to the source directly
05:52:32 * SamB discovers that there is apparantly an ATL
05:53:06 <SamB> or rather, that there are arrow transformers in the arrows package
05:53:55 <Saulzar> Hmm, interesting
05:56:48 <Saulzar> Yampa has already support for state, all it should need is for the initial generator to be visible. Maybe you could have a global generator and seed that with an object's id or something
05:59:09 <SamB> Saulzar: ah.
05:59:55 <tromp_> hi shapr
06:00:00 <shapr> hoi tromp_, how's code?
06:00:05 <lypanov> yoyo shapr
06:00:14 <shapr> y0 lypanov, long time no see! How's code?
06:00:27 <shapr> I hear you joined the #perl6 community?
06:00:37 <tromp_> shaved some bits of my integer parsing code:)
06:01:10 <shapr> #haskell: I'm going to release the last Shae-edited TMR on Feb 1st, anyone who wishes to contribute articles please do so. Anyone who wishes to be editor, jump in!
06:01:17 <SamB> hmm, I seem to have deleted yampa for some reason
06:01:27 <SamB> @where yampa
06:01:28 <lambdabot> I know nothing about yampa.
06:01:33 <shapr> http://www.haskell.org/yampa/
06:01:50 <shapr> @where+ yampa http://www.haskell.org/yampa/
06:01:50 <lambdabot> Done.
06:02:32 <SamB> @where should resort to a google search if it doesn't find anything in its database
06:02:32 <lambdabot> I know nothing about should.
06:02:36 <jethr0> hey shapr, what happened to the TH entry on tmrwiki?
06:02:47 <shapr> jethr0: er?
06:02:50 <SamB> oh, oops, forgot to add a space
06:02:50 <jethr0> shapr: sorry to hear that you won't be continuing with TMR :(
06:02:53 <shapr> Did it disappear?
06:03:10 <jethr0> shapr: well sth like that...
06:03:22 <SamB> haskell.org ought to have a "directory" or "index" of all the directories under it
06:03:26 <shapr> jethr0: I've had enough of community organizing for awhile, I want to go back to coding.
06:03:33 <jip> i forgot, how do you make an infinite list where all elements have the value x?
06:03:34 <jethr0> :)
06:03:36 <shapr> SamB: Yes, that's one reason I suggested the darcsforge organization, or at least an index.
06:03:39 <jip> is there a better way then [x,x..]?
06:03:42 <shapr> jip: cycle
06:03:49 <jip> > cycle 2
06:03:50 <lambdabot>  add an instance declaration for (Num [a])
06:04:01 <shapr> > cycle [2]
06:04:03 <lambdabot> [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
06:04:03 <lambdabot> 2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
06:04:03 <lambdabot> 2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
06:04:03 <lambdabot> 2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
06:04:04 <lambdabot> 2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
06:04:05 <lambdabot> [23 @more lines]
06:04:12 <jethr0> shapr: never mind, i was looking in the wrong place...
06:04:14 <SamB> shapr: hack on Conjure!
06:04:22 <jip> shapr: is that better then [2,2..]?
06:04:32 <shapr> SamB: I may do that, but I want to get gtk2hs running on my 770.
06:04:38 <shapr> jip: Performance-wise, I don't know.
06:04:41 <SamB> shapr: it works fairly well now
06:04:45 <shapr> spiffy!
06:04:56 <shapr> I may hack conjure to run on the 770 then.
06:05:06 <SamB> how about
06:05:17 <tromp_> > unicycle [2]
06:05:18 <SamB> > repeat 2
06:05:19 <lambdabot>  Not in scope: `unicycle'
06:05:20 <lambdabot> [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
06:05:20 <lambdabot> 2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
06:05:20 <lambdabot> 2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
06:05:20 <lambdabot> 2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
06:05:20 <lambdabot> 2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
06:05:22 <tromp_> darn:(
06:05:23 <lambdabot> [23 @more lines]
06:05:39 <SamB> shapr: it doesn't run *that* well
06:05:50 <shapr> tromp_: hah :-)
06:05:58 <jip> yes, i knew there was a repeat!
06:06:03 <SamB> it has some really wierd issues with tracing output
06:06:40 <SamB> I'm thinking repeat is likely the fastest
06:06:40 <SamB> or whateverest
06:06:58 <jethr0> samb, BTW, what happened to your BF interpreter article. i've been looking at that page at regular intervals and noticed no changes ;)
06:07:02 <tromp_> @pl a b c d e = b(\z y z-> y (c z x)) id e d
06:07:04 <lambdabot> a = (flip .) . flip flip id . (. (const . flip (.) . flip flip x))
06:07:15 <tromp_> @pl a b c d e = b(\x y z-> y (c z x)) id e d
06:07:16 <lambdabot> a = (flip .) . flip flip id . (. ((flip (.) .) . flip))
06:07:40 <shapr> Anyway, I'm switching my focus to coding, and so shutting down my various organizational responsibilities.
06:07:54 <SamB> jethr0: okay, the thing to do about that is email me.
06:07:55 <tromp_> @pl bla c d e = b(\x y z-> y (c z x)) id e d
06:07:57 <lambdabot> bla = flip . flip b id . (flip (.) .) . flip
06:08:03 <shapr> If anyone wishes to take over anything I'm organizing now, please contact me.
06:08:10 <SamB> I just keep forgetting to work on it.
06:09:26 <tromp_> always a fun exercise...
06:10:01 <tromp_> writing foldl in terms of foldr
06:10:16 <shapr> audreyt: Last night I dreamed I got to pair-program with you in australia or taiwan or someplace. It was fun :-)
06:11:58 <audreyt> shapr: :D
06:12:07 <audreyt> wouldn't that be nice!
06:12:26 <audreyt> any Yhc people around?
06:12:46 * shapr wants to run YHC on the Nokia 770 he purchased
06:13:11 <audreyt> I've revived my Perl5/Hugs bindings
06:13:16 <jethr0> SamB: in what sense? to nag you?
06:13:18 <audreyt> wonders if it's possible to do a Yhc RTS binding
06:13:27 <shapr> Check it out - x-chat and #haskell on the modified debian that the Nokia 770 runs - http://www.scannedinavian.org/~shae/screenshot00.png
06:13:32 <audreyt> or (more bizzarely) transform Yhc bytecode to parrot/pugs/perl5
06:14:00 <Philippa> the former I kinda expect to happen
06:14:09 <Philippa> Yhc/GHC RTS crossover projects seem a likely thing
06:14:16 <Philippa> the latter? Meh :-)
06:14:43 <Philippa> btw, you considered using the GRIN parts of JHC as a backend for anything? I've been toying with the idea
06:15:12 <shapr> You think YHC or JHC would be easier to port to debian/arm and use with gtk2hs?
06:15:26 <Philippa> probably
06:15:29 <audreyt> Philippa: aye, I had thought about it, but it doesn't match pugs
06:15:37 <Heffalump> GHC should be quite easy to port too
06:15:39 <audreyt> Philippa: E (\cube) on the other hand is very useful.
06:15:46 <Heffalump> (well, as easy as GHC is to port to anything, which isn't all that easy)
06:15:48 <Philippa> what's pugs doing for compilation these days, anyway?
06:15:56 <shapr> GHC binaries are too large.
06:16:06 <Heffalump> I got stuck when gcc on qemu-arm segfaulted on a 1.2MB C file.
06:16:14 <Heffalump> and I don't know whether to blame gcc or qemu.
06:17:21 <audreyt> Philippa: two internal languages; one more akin to two-level lambda calculus; one fairly lower-level smalltalk-ish OO language
06:18:06 <dcoutts> shapr, Yhc is closer to supporting ordinary H98 progs than Jhc isn't it?
06:18:16 <shapr> dcoutts: I think so.
06:18:29 <shapr> YHC is probably closer to being FFI-ready as well.
06:18:51 <shapr> But JohnMeacham is here, though probably not active.
06:19:01 <dcoutts> shapr, right. Which is the more significant for gtk2hs on the 770
06:19:18 <shapr> JohnMeacham: hi! thoughts on JHC on debian/arm and FFI readiness?
06:19:42 <dcoutts> shapr, mind you, the portable C focus should make it not to bad to get progs to work on the 770
06:20:02 <dcoutts> shapr, build them on linux, then cross-compile them with gcc
06:20:26 <shapr> And small and fast binaries is a great benefit on a 220MHz cpu with 64mb of ram.
06:20:39 <dcoutts> shapr, presumably that's how most C software is built for the 770.
06:20:55 <shapr> Yup, maemo uses scratchbox, cross compiling is a breeze.
06:21:20 <shapr> Of course, compared to the time I spent developing for the Nokia 9210, anything would be a breeze.
06:21:29 <dcoutts> does jhc produce one big .c file?
06:22:00 <dcoutts> shapr, which gcc version is used for the 700? 4.x ?
06:22:06 <dcoutts> 700/770
06:22:26 <shapr> 3.3 or 3.4
06:22:39 <dcoutts> so no -funit-at-a-time flag thingy
06:23:00 <shapr> What does that flag do?
06:23:21 <dcoutts> it makes gcc do optimisation on a whole translation unit at a time rather than per-function
06:23:31 <dcoutts> which allows it to do rather better
06:23:38 <dcoutts> but it uses more memory etc
06:23:43 <BuZzY> people: a person as just said to me that she has reached my site(that is not google indexed, so not foundable) thanks to a program that shows the last hosted sites!!! is it possible??
06:23:47 <tromp_> @pl bla x = (.($x).f)
06:23:48 <lambdabot> bla = flip (.) . flip f
06:23:57 --- mode: ChanServ set +o shapr
06:24:07 <shapr> BuZzY: This channel is about the programming language Haskell.
06:24:13 <Philippa> BuZzY: if your host gives that info somewhere then yeah. And what shapr said
06:24:15 * dcoutts stands back
06:24:25 <Philippa> if you really need private, FFS just slap some authorisation requirements on it
06:24:33 <BuZzY> oh sorry people!
06:24:36 <shapr> BuZzY: You may want to ask that question on #web or some other general purpose channel.
06:24:56 <BuZzY> such as?
06:25:46 <shapr> Maybe ask on #linuxhelp or one of the other channel you're already on? :-)
06:25:50 <tromp_> @pl bla x = x
06:25:51 <lambdabot> bla = id
06:26:37 --- mode: shapr set -o shapr
06:26:46 <pesco> Could also be Dan Kaminsky scanning the whole Internet again. ;-)
06:26:56 <shapr> hiya pesco 
06:27:26 <pesco> Hey shapr! Long time no see.
06:27:45 <jip> alright i almost got this tetris shit working
06:28:04 <shapr> pesco: Yeah, life is busy.
06:28:14 <tromp_> @pl myfoldl f = flip (foldr (flip (.) . flip f) id)
06:28:15 <lambdabot> myfoldl = flip . flip foldr id . (flip (.) .) . flip
06:28:24 <pesco> shapr: Yeah. Your's too, I take it.
06:28:50 <pesco> shapr: Coding anything currently?
06:29:11 <shapr> Nah, just trying to get nhc98 working on the nokia 770
06:29:36 <pesco> shapr: Ah, wow. I don't know what a Nokia 770 is, but I guess it's a powerful phone?
06:29:37 <shapr> It builds fine, but I don't know enough about packaging debs to make it install correctly
06:29:57 <pesco> shapr: Oh, packaging debs, the eternal mystery. (To me, that is)
06:30:04 <Saulzar> jip, Great :)
06:30:37 <pesco> shapr: But maybe this will be useful to you? Ubuntu people just held an IRC-Lesson on basic deb packaging. Let me find the URL.
06:31:52 <srle> Hi, all.
06:31:57 <jip> Saulzar: this is a super intense struggle for me... i am slowly adding a line and another line, but the code is becoming horribly messy... i can just barely get the shit to work, i am not powerful enough to keep the code clean
06:32:17 <srle> where can i find source code for:"Composing contracts An adventure in financial engineering"
06:32:34 <pesco> shapr: https://wiki.ubuntu.com/MOTU/School/2005-12-10
06:34:33 <jip> has anyone seen dons?
06:34:40 <xerox> @seen dons
06:34:43 <lambdabot> dons is in #haskell-blah and #haskell. Last spoke 11 hours, 30 minutes
06:34:43 <lambdabot> and 50 seconds ago.
06:35:01 <Heffalump> srle: I believe none is available apart from the paper itself.
06:35:21 <pesco> shapr: I've set myself the task of carving up a fast real-time graph visualizer in Haskell. It's killing me, because my code-perfectionism bites me on nearly every line.
06:35:50 * boegel pings astrolabe 
06:35:50 <SamB> shapr: debs aren't that hard...
06:35:53 <jip> pesco: cool, what are you using for the user interface?
06:36:07 <xerox> pesco: heh, I know the feeling.
06:36:14 <xerox> Anyway, howdy people :-)
06:36:26 <pesco> jip: Currently, I'm planning on Gtk2HS and Cairo.
06:36:47 <pesco> jip: Even thought I would be more familiar with OpenGL...
06:36:55 * dcoutts congratulates pesco on his selection :-)
06:36:55 <tromp_> are you writing a tetris in haskell, jip?
06:37:02 <jip> tromp_: yes
06:37:17 <xerox> Wazzam!
06:37:38 <jip> dcoutts: does gtk2hs have support for gtkgl-ext yet?
06:37:39 <tromp_> graphical?
06:37:40 <pesco> jip: But OpenGL doesn't give you GUI widgets. :/
06:37:47 <dcoutts> jip, yes.
06:37:53 <srle> Does anyone use haskell for financial markets?
06:37:59 <jip> pesco: so you can use gtk2hs and opengl
06:37:59 <dcoutts> jip, in the current darcs version.
06:38:11 <dcoutts> jip, yes. There's som demo code too.
06:38:19 <dcoutts> jip, let me find it for you...
06:38:20 <jip> dcoutts: excellent
06:38:33 <pesco> jip: If I use gtk, I might as well use Cairo.
06:39:16 <dcoutts> jip, some info:
06:39:17 <dcoutts> http://haskell.org/gtk2hs/archives/2005/11/04/start-of-opengl-binding/
06:39:22 <dcoutts> http://haskell.org/gtk2hs/archives/2005/11/11/more-opengl-goodness/
06:39:30 <pesco> jip: But I'd really like to have some g-wiz OpenGL widget library...
06:39:59 <dcoutts> jip, docs:
06:39:59 <dcoutts> http://haskell.org/gtk2hs/docs/devel/Graphics-UI-Gtk-OpenGL.html
06:40:33 <dcoutts> jip, and a simple demo:
06:40:34 <dcoutts> http://darcs.haskell.org/gtk2hs/demo/opengl/RotatingCube.hs
06:41:57 <dcoutts> jip, and that opengl in a gtk widget stuff work with gtk2hs on linux, windows and solaris. I've tested it.
06:42:09 <jip> sweet
06:42:32 <dcoutts> jip, but I've not done much serious with it yet. So bug reports are welcome. :-)
06:42:49 <dcoutts> I'm going to use it for teaching a course in October.
06:43:35 <dcoutts> jip, on the other hand, I know other people are using it and I've not had any bug reports yet, so it seems ok.
06:44:59 <SimonRC> anyone experienced with hscurses?
06:45:27 <int-e> is there an easy way to do darcs pull non-interactively?
06:46:06 <int-e> err. darcs pull -a ...
06:46:12 <int-e> there is :)
06:46:35 <SimonRC> int-e: the --all option, as with several commands
06:47:06 <int-e> SimonRC: I didn't read the first paragraph of the manpage which suggests using darcs <command> --help :)
06:47:32 <SimonRC> you'll know next time.
06:47:59 <SimonRC> The worst that can happen is usually "--help -- file not found."
06:48:00 <jip> dcoutts: you should make it so that the webpage http://gtkglext.sourceforge.net/ mentions the availability of haskell bindings
06:48:43 <dcoutts> jip, I think I did email the guy. He didn't get back to me. :-(
06:48:53 <jip> :'(
06:49:03 <dcoutts> jip, feel free to try emailinh him yourelf.
06:50:57 <dcoutts> oh, from looking at their mail archive, it looks liek they've got a new maintainer since the previosu one dissapeared
06:51:03 <dcoutts> I'll try again
06:54:51 <tromp_> @type unfold
06:55:00 <lambdabot> Not in scope: `unfold'
06:55:06 <dcoutts> @type Data.List.unfold
06:55:15 <lambdabot> Not in scope: `Data.List.unfold'
06:55:17 <dcoutts> ?
06:55:22 <dcoutts> @index unfold
06:55:25 <tromp_> @type List.unfold
06:55:28 <dcoutts> grr
06:55:41 <dcoutts> lambdabot is being rather slow today
06:55:48 <tromp_> i'll say!
06:55:54 <int-e> @type Data.List.unfoldr
06:55:58 <dcoutts> @botsnack
06:56:06 <tromp_> @botfodder
06:56:22 <int-e> Data.List.unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
06:56:23 <tromp_> @bottom
06:56:25 * int-e shrugs
06:56:27 <dcoutts> lambdabot! speak to us!
06:56:28 <lambdabot> bzzt
06:56:28 <lambdabot> Not in scope: `List.unfold'
06:56:28 <lambdabot> forall a b. (b -> Maybe (a, b)) -> b -> [a]
06:56:28 <lambdabot> :)
06:56:28 <lambdabot> Unknown command, try @listcommands.
06:56:29 <lambdabot> Unknown command, try @listcommands.
06:56:32 <dcoutts> heh
06:58:40 <dcoutts> JaffaCake, do you think it's possible/likely we could integrate the ghc and haddock parsers? It'd help haddock keep up with ghcisms and allow VisualHaskell & hIDE to get doc fragments via the GHC API.
06:59:06 <JaffaCake> certainly possible, but non-trivial I think
06:59:33 <dcoutts> JaffaCake, I say integrate, but what that really means is adding the haddock markup rules to ghc's parser.
06:59:48 <dcoutts> JaffaCake, difficult because of the changes in the AST for ghc?
06:59:53 <JaffaCake> yes, right, but it means switching to GHC's abstract syntax too
07:00:13 <JaffaCake> I was thinking more of changing Haddock to use GHC's AST
07:00:38 <dcoutts> at which point the GHC AST would need the doc bits
07:00:46 <JaffaCake> yes
07:01:17 <JaffaCake> but it woiuld be nice... then Haddock could sit on top of the GHC API, and get support for preprocessing, and type checking, etc.
07:01:18 <dcoutts> I'm currently looking at getting haddock to grok {-# LINE ... #-} pragmas.
07:01:34 <JaffaCake> yes
07:02:10 <dcoutts> it's not so easy to steal code from the current ghc lexer/parser since it got changed after haddock ranched from the ghc parser/lexer.
07:02:22 <dcoutts> ranched/branched
07:02:49 <JaffaCake> haddock is really a branch of the haskell-src bits, rather than GHC itself
07:02:55 <dcoutts> oh right
07:03:04 <dcoutts> that's why they're so different :-)
07:03:10 <JaffaCake> they don't have a common ancestry, except perhaps in my mind :)
07:03:29 <dcoutts> getting haddock to use the ghc api would also give haddock decent error messages
07:03:35 <JaffaCake> yup
07:03:42 <JaffaCake> it's the way to go, it's just a lot of work
07:03:48 <dcoutts> currently it produces non-pretty printed lists of tokens :-)
07:03:48 <jip> where can i find more information about the ghc api?
07:04:02 <dcoutts> JaffaCake, yeah, sure. priorities.
07:04:05 <JaffaCake> jip: there's a wiki page, hang on
07:04:26 <JaffaCake> http://haskell.org/haskellwiki/GHC:as_a_library
07:05:05 <JaffaCake> BTW, GHC's main documentation page is now in the wiki: http://haskell.org/haskellwiki/GHC:Documentation
07:05:25 <JaffaCake> we'd like to encourage everyone to add stuff to here, so we have a common root for ghc-related notes
07:07:00 <jip> will ghc api obsolete hs-plugins?
07:07:41 <JaffaCake> jip: good question... you can do a lot of what hs-plugins does using the GHC API, but not all
07:08:25 <JaffaCake> dons should be able to give you the definitive answer, but my guess is that eventually it should be possible to build hs-plugins on top of the GHC API
07:08:42 <dcoutts> JaffaCake, perhaps when VisualHaskell & hIDE progress more there'll be more demand (and hence more spare dev time) to build haddock on the ghc api. Another thing hIDE would like is a structured format for the api docs so it can do things like: 
07:08:42 <dcoutts> http://haste.dyndns.org:8080/screenshots/screenshot_hovering_r305.png
07:09:21 <JaffaCake> yes!
07:09:32 <dcoutts> eg a binary .haddock file that contains all the doc text as well as just references
07:09:46 <JaffaCake> we could use that in GHCi too
07:09:51 <dcoutts> yeah
07:09:59 <jip> interesting
07:10:15 <JaffaCake> so many ideas... where do we put them all
07:10:19 <pesco> Hs-plugins might evolve into a standard API for dynamic access to the Haskell system, so it can be portable.
07:10:23 <dcoutts> JaffaCake, the wiki!
07:10:32 <JaffaCake> good idea :)
07:11:01 <dcoutts> JaffaCake, does haddock have a bit on the wiki yet?
07:11:07 <dcoutts> the new wiki I mean
07:11:08 <JaffaCake> not yet
07:11:32 <JaffaCake> by all means create a page
07:11:34 <dcoutts> ok: http://haskell.org/haskellwiki/Haddock
07:11:37 <JaffaCake> heh
07:12:17 <dcoutts> btw what;s the significance of the ':' in the wiki page names?
07:12:38 <dcoutts> eg "GHC:as_a_library" vs "GHC/as_a_library"
07:12:48 <JaffaCake> don't know, I just saw other pages doing it
07:12:52 <dcoutts> ok
07:13:07 <tibbe> what's the best way to go from a lambda calculus interpreter that support functions with one parameter to a general solution with functions of many arguments but still support partial application?
07:13:11 <JaffaCake> there's something called "categories" in mediawiki, I wonder if it's related
07:15:08 <jip> yay my single-brick-tetris works :D http://img220.imageshack.us/img220/5016/hstetris0014es.png
07:15:41 <Lemmih> jip: Nice title.
07:15:44 <pesco> tibbe: Er, it is able to return functions? Then you're done already.
07:15:56 <edwinb> and are the functions arbitrary terms?
07:16:27 <jip> Lemmih: this might be a bug in your SDL bindings or it might be a bug in my window manager
07:17:25 <tibbe> pesco, I guess, it's a complete lambda calculus
07:17:50 <tibbe> http://www.itstud.chalmers.se/~larssont/Main.hs
07:17:58 <tibbe> that's a kinda in transition version
07:18:21 <tibbe> I'm not sure if I should have a separate value type or have eval return Term:s
07:18:34 <pesco> tibbe: How are "multi-argument" functions done in Haskell?
07:18:46 <pesco> tibbe: Because that's the way, it's done in the lambda calculus.
07:18:50 <edwinb> A separate value type is usually better since then the type checker can confirm you're always returning a normal form.
07:19:01 <tibbe> edwinb, okay
07:19:32 <tibbe> edwinb, it felt a bit like duplicating some of the Term data type that's why I haven't done it yet but that sounds like a good reason
07:19:39 <SimonRC> tibbe: take a look at mine.
07:19:53 <SimonRC> it does it by having closure
07:19:59 <edwinb> It is, yes, but as you say, there is a good reason for it.
07:20:13 <edwinb> you can always have a forgetful map back to Term if you need one.
07:20:17 <SimonRC> though I haven't introduced the sugar to look like multi-arg funcs
07:20:21 <tibbe> SimonRC, where's yours?
07:20:34 <SimonRC> http://compsoc.dur.ac.uk/~sc/Shakell/
07:20:45 <SimonRC> It runs at the moment
07:21:03 <SimonRC> very primative though
07:21:18 <SimonRC> see the IRC log for the only documentation
07:22:05 <SimonRC> do ask if you have questions
07:23:20 <tibbe> SimonRC, I will, reading it atm
07:23:40 <tibbe> I do:
07:23:42 <tibbe> eval (App (Lam id e1) e2) env = let env' = (id, (eval e2 env)) : env
07:23:42 <tibbe>                                 in eval e1 env'
07:24:21 <tibbe> to bind the expr being applied to the lambdas argument but I was thinking that the binding is probably unnecessary
07:25:04 <SimonRC> where does env come from?  the function or the outer scope?
07:25:08 <tibbe> it would enough to add the expr to apply to the function to the head of the environment and then just have the application just remove the first
07:25:20 <tibbe> outer scope
07:25:27 <araujo> What is the best way to define a function that takes a String and returns a polimorphic value (like error) ?
07:25:46 <SimonRC> You've been reading McCarthey's LISP haven't you? :-)  That's dynamic scope, which makes multi-arg functions rather hard.
07:26:38 <tibbe> have I implemented dynamic scopes? that certainly wasn't on purpose ;)
07:26:59 <SimonRC> araujo: maybe use: "class Foo a where bar :: String -> a"
07:27:19 <SimonRC> araujo: see definition of Read module
07:28:01 <SimonRC> tibbe: Haskell and lambda calculus and modern LISPs use lexical scope, which means you can have closures.
07:28:20 <tibbe> SimonRC, I do want closures and lexical scope
07:28:33 <araujo> Thanks SimonRC 
07:28:53 <BuZzY> how can i approssimatively locate a ip(geographically)?
07:29:01 <araujo> SimonRC, i tried with making a class... but doesn't work :-/
07:29:01 <SimonRC> okay, then you need to carry around the scope at time of creation in your function data.
07:29:23 <SimonRC> araujo: what was the error?
07:29:28 <tibbe> yes, I probably need a reference to a mutable store right?
07:29:37 <SimonRC> tibbe: no
07:29:42 <SimonRC> ...
07:29:54 <araujo> BuZzY, Check Network.Socket module
07:29:57 <tibbe> SimonRC, so I can define two functions in the same scope and have them change the same variable?
07:30:03 <tibbe> unpure style
07:30:12 <SimonRC> ah, dunno about *that*
07:30:38 <tibbe> you're talking about pure functional right?
07:30:44 <SimonRC> tibbe: yes
07:30:58 <SimonRC> I think you could put an IORef or SomethinRef into your environment, and it'd DTRT.
07:31:57 <SimonRC> In my lambda data I have a function that takes the argument the function is applied to and returns the environment with the variable bound (for use when evaluating the expression).
07:32:04 <tibbe> that's what I had in mind
07:32:48 <tibbe> but I guess I want to do a pure lambda calculus with multi arg and closures before I do anything else
07:32:59 <tibbe> what features did the implementation you linked to have?
07:33:51 <SimonRC> wait, you do realise that (\a b c -> foo) is just sugar for (\a -> (\b -> (\c -> foo))) right?
07:34:00 <tibbe> I'm not very good at lambda calculus, does closures have anything to do with free variables?
07:34:12 <tibbe> SimonRC, yes
07:34:17 <Philippa> sort-of, yes
07:34:19 <araujo> SimonRC, check http://pastebin.com/514668
07:34:23 * int-e wonders what'll happen to App (App (Lam x (Lam a (Var x))) (Var a)) (Var z)
07:34:34 <Philippa> in practice free variables're just ones defined higher up in the environment though
07:34:46 <Philippa> (or else, if a variable's truly free, you just don't know what to do with it)
07:34:49 <SimonRC> tibbe: closures are just done by keeping a copy of the env-at-time-of-creation
07:34:57 <Philippa> yup
07:35:16 <tibbe> hi Philippa, as you see I'm still at it :)
07:35:51 <dcoutts> JaffaCake, here's the pages:
07:35:52 <dcoutts> http://haskell.org/haskellwiki/Haddock
07:35:53 <SimonRC> araujo: what was the error?
07:35:54 <dcoutts> http://haskell.org/haskellwiki/Haddock:development_ideas
07:36:00 <dcoutts> JaffaCake, did I miss anything?
07:36:00 <tibbe> SimonRC, there is alot more code in your "version" what more does it do?
07:36:19 <SimonRC> let's see...
07:36:29 <JaffaCake> dcoutts: nice, thanks
07:36:39 <araujo> SimonRC, i get this while trying to use bar
07:36:41 <araujo>     Ambiguous type variable `a' in the constraints:
07:36:41 <araujo>       `F a' arising from use of `bar' at <interactive>:1:0-2
07:36:43 <SimonRC> the botom 1/3 is a parser
07:36:51 <tibbe> SimonRC, ah
07:37:07 <SimonRC> araujo: what did you type to get that
07:37:12 <SimonRC> tibbe: and...
07:37:27 <araujo> SimonRC, only , 'bar "hello"' 
07:37:32 <araujo> at ghci
07:37:49 <edwinb> you'd need to say what type you're expecting
07:37:51 <SimonRC> araujo: what do you expect it to return?
07:38:03 <edwinb> try bar "hello" :: Test
07:38:05 <SimonRC> tibbe: above the parser is Show for values, then ...
07:38:07 <araujo> yeah, i see
07:38:09 <araujo> mmm...
07:38:32 <SimonRC> tibbe: function application, then above that...
07:38:59 <SimonRC> evaluation, then the monad that passes the env around
07:39:04 <araujo> I was trying to do something like 'error' , but i suppose 'error' is internally being told what type to return right?
07:39:23 <SimonRC> tibbe: above that is pattern matching.
07:40:05 <SimonRC> tibbe: then the builtin values (just cons, nil, and the function-combiner)
07:40:30 <JaffaCake> wow, zsh completion is the worst case of over engineering I've ever seen
07:40:52 <edwinb> araujo: Yes, error can return anything. Your 'bar' as it stands needs to be told what to return.
07:41:05 <araujo> JaffaCake, really?, it's usually what they try to get better :-P
07:41:19 <araujo> edwinb, how can i get something like error?
07:41:20 <SimonRC> tibbe: the function combiner I have seen nowhere else.  It allows a function to have multiple bodys for different argument structures, but combines them at runtime!
07:41:32 <tibbe> :D
07:41:35 <edwinb> depends why you want something like error...
07:41:40 <SimonRC> tibbe: run-time pattern-matching assembly!
07:41:42 <tibbe> I think I'll print it, wasier to read then
07:41:55 <tibbe> s/wasier/easier/
07:41:57 <araujo> edwinb, im actually only testing atm
07:42:47 <SimonRC> tibbe: I recommend concentreating on the data statements first.
07:42:49 <edwinb> I've always thought of error as just being a special case that is a member of any type.
07:43:35 <edwinb> the type forall A:Type => A is a lie after all ;)
07:43:43 <SimonRC> tibbe: oh, and "Bottom" is the error type, named after the "inverted T" shape used for contradictions in propositional logic, AFAICT.
07:43:45 <tibbe> SimonRC, yes
07:44:45 <araujo> edwinb, haha, that's what ive noticed :-]
07:45:18 <tibbe> SimonRC, I'm a bit curious about this: Func [(Pattern, (Value -> Result Env), Expr)]
07:45:19 <araujo> edwinb, it looks like if error were actually casted .....
07:45:37 <tibbe> SimonRC, so I guess the Pattern is for pattern matching?
07:45:53 <SimonRC> yes
07:45:58 <tibbe> SimonRC, the last Expr is the one to be applied?
07:46:05 <SimonRC> the body, yes
07:46:19 <SimonRC> and Value -> Result Env creates the env to eval it in
07:46:25 <tibbe> as in \x. BODY ?
07:46:34 <SimonRC> pattern is just in case I want to print the function out
07:46:38 <SimonRC> tibbe: yes
07:46:41 <tibbe> is Result a monad?
07:46:46 <SimonRC> yes
07:46:49 <SimonRC> MoadPlus
07:46:55 <SimonRC> it's a MonadPlus
07:47:03 <tibbe> combined error, reader or something?
07:47:09 <SimonRC> erm, ...
07:47:23 <tibbe> or perhaps, was does it do? :)
07:47:46 <tibbe> s/was/what/
07:48:10 <tibbe> why a list of functions?
07:48:40 <SimonRC> result is used for patter-matchin results, to avoisd excesive case expressions.
07:48:55 <SimonRC> the list of functions are the case alternatives to be checked
07:48:55 <tibbe> okay
07:49:05 <tibbe> for pattern matching?
07:49:07 <SimonRC> just like haskell's cases
07:49:10 <SimonRC> yes
07:50:10 <tibbe> so if I don't want pattern matching yet what would my function be, expression to be evaluated plus environment bindings?
07:50:22 <SimonRC> but the syntax only supports 1-case functions, with the | builtin constructing multi-case functions from single-case ones
07:51:02 <SimonRC> tibbe: you need some way to say what the parameter's called, unless...
07:51:23 <SimonRC> you use the clever name-elimination trick that edwin can explain better
07:51:40 <SimonRC> I recommend doing it the simple way first
07:52:54 <tibbe> SimonRC, that was what I was trying to achieve by keeping the argument to be applied first, but I can see that wouldn't work since the expression might contain variables from outer scopes
07:53:09 <SimonRC> tibbe: yes
07:53:49 <SimonRC> tibbe: do you know a bit of LISP?
07:54:07 <tibbe> so if my Env is [(Id,Value)] then I need to keep (Id,Env,Expr) ?
07:54:15 <tibbe> SimonRC, some LISP yes
07:54:54 <SimonRC> look at http://www.paulgraham.com/rootsoflisp.html if you want
07:55:06 <SimonRC> it has the original paper there
07:55:40 <tibbe> I've read most of the paper briefly but I guess I should read it again
07:56:16 <SimonRC> you may see some simplifications you could make
07:56:58 <tibbe> okay, too bad I haven't read any lambda calculus, feels like things would be easier then
07:57:19 <SimonRC> Yes to your question:  "< tibbe> so if my Env is [(Id,Value)] then I need to keep (Id,Env,Expr) ?"
07:57:45 <SimonRC> tibbe: I only know a few bits from using HoF
07:59:08 <tibbe> addins cons and nil is enough to implement list right? and something like car and cdr to get the things out of the lists again
07:59:24 <SimonRC> If you want to be confused or terrified, try lambda calculus without the lambdas: http://www.madore.org/~david/programs/unlambda/
07:59:30 <SimonRC> tibbe: yes
07:59:37 <SimonRC> any data structur, in fact
07:59:42 <tibbe> seen unlambda already ;)
07:59:56 <SimonRC> I do CAR and CRD by pattern matching
08:00:00 <tibbe> SimonRC, you mean that tree etc can be encoded as lists right?
08:00:12 <SimonRC> they're the examples at the top of my lhs file
08:00:17 <SimonRC> tibbe: yes
08:00:47 <tibbe> I have lots of input now, I think I can make some progress now
08:01:08 <tibbe> thanks alot
08:01:14 <SimonRC> for a binary tree, each node is: (cons lable (cons left right))
08:01:18 <tibbe> (and God bless the logs)
08:01:48 <SimonRC> or for a leaf-labled tree: (cons left right) or (cons 'leaf data)
08:02:04 <tibbe> then I need a way to bind functions to names to create top level combinators/functions
08:02:13 <SimonRC> general tree: (cons lable (list child1 child2 ...))
08:02:46 <SimonRC> tibbe: see my "baseEnv" constant
08:03:14 <SimonRC> "runTree expr = runReader (eval expr) baseEnv"
08:03:35 <SimonRC> i.e. you just call your evaluator with an enviroment with initial binding in it.
08:04:16 <SimonRC> or (evil):
08:04:34 <tibbe> does that allow for adding if new named functions and not just built in ones?
08:04:50 <SimonRC> take the user's function and apply it to all the builtins
08:05:03 <SimonRC> tibbe: ah, waitamo
08:06:32 <SimonRC> Shakell is an *esoteric" language, based on Haskell, but with the syntax of SADOL and syntax and some style from unlambda.
08:07:57 <SimonRC> I have to translate top level bindings into one bunch of nested LETs (LISP style), then turn those into their function-application equivalents before I can write in unlambda.
08:08:36 <SimonRC> recursion and mutual recursion must be done with y and its larger relatives.
08:09:24 <SimonRC> I may add ':' for 1-variable "let" to improve the line-noise appearance.
08:10:01 <SimonRC> oh, and I have the ability to add libraries at a later date, if needed
08:10:07 <SimonRC> tibbe: what did you miss?
08:10:32 <SimonRC> tibbe_: what did you miss?
08:10:35 <tibbe_> dunno if there's something missing or if I just haven't gotten that dar
08:10:37 <tibbe_> far*
08:11:05 <SimonRC> I mean, what was the last line that got through to your ghost?
08:11:15 <tibbe_> named functions like bound to identifiers at the top level, i.e. some top level (let map (lambda_for_map))
08:11:33 <tibbe_> oh, i didn't notice i was disconnected
08:11:48 <tibbe_> "recursion and mutual recursion must be done with y and its larger relatives." was the last line
08:12:06 <SimonRC> "16:08 < SimonRC> I may add ':' for 1-variable "let" to improve the line-noise appearance.
08:12:09 <SimonRC> 16:08 -!- tibbe_ [n=Johan@johtib.brg.sgsnet.se] has joined #haskell
08:12:12 <SimonRC> "
08:12:24 <SimonRC> 16:08 < SimonRC> oh, and I have the ability to add libraries at a later date, if needed
08:12:27 <SimonRC> 16:08 < SimonRC> tibbe: what did you miss?
08:12:30 <SimonRC> 16:09 < SimonRC> tibbe_: what did you miss?
08:12:32 <SimonRC> 16:09 < tibbe_> dunno if there's something missing or if I just haven't gotten that dar
08:12:35 <SimonRC> taht was all you missed, then
08:12:42 <tibbe_> :)
08:12:44 <tibbe_> logs are nice
08:13:17 <SimonRC> tibbe_: see topic
08:13:41 <tibbe_> I've already bookmarked today's log so I can find them later
08:16:14 <SimonRC> anyone know what (\x.xx)(\f.\a.\b.(cons (a(ffab)) (bffab))) is called?
08:16:32 <SimonRC> oops
08:16:48 <SimonRC> no, it's ok
08:17:28 <SimonRC> it takes two functions, then basses each of them a cons containing the two functions for recorsion or mutual recursion.
08:17:38 <SimonRC> like y but for two functions.
08:18:09 <SimonRC> (\x.xx)(\f.\a.\b.(cons (a(ffab)) b(ffab)))
08:18:13 <SimonRC> evenm
08:19:02 <tibbe_> *reboot -> gentoo*
08:30:52 <vincenz> hello
08:34:03 <jip> yo
08:49:17 <Saulzar> jip, Nice work (saw the tetris)
08:49:39 <Philippa> Dammit, I keep finding list funcs I want monadic versions of
08:49:43 <Saulzar> All the logic is in Yampa stuff? Could I have a look? :)
08:49:47 <Philippa> anyone know a quickish way to write anyM?
08:50:00 <Philippa> (preferably in terms of any)
08:50:14 <jip> Saulzar: yeah, it's all yampa.... i'll paste the code
08:51:31 <jip> @paste
08:51:32 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
08:53:14 <tromp_> anyM p = any p . tolist  :)
08:56:55 <Saulzar> Hmm, a monadic any would want to shortcircut? 
08:56:59 <gour> dcoutts: what is the origin of that wonderfully-looking snapshot in Haddock:development_ideas?
08:57:29 <jip> lisppaste2: help
08:57:30 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
08:57:47 <jip> the paste service seems to be down :/
08:59:06 <tromp_> some monads of course do not have sensible tolist
08:59:10 <dcoutts> gour, haste
08:59:12 <dcoutts> @where haste
08:59:13 <lambdabot> I know nothing about haste.
08:59:18 <Philippa> like, all the monads I'm interested in
08:59:27 <Saulzar> Can hijack some other irc paste site maybe ;) http://www.noidea128.org/  
08:59:33 <Philippa> and I'm after the "monadic predicate" variant anyway
08:59:55 <tromp_> you mean, yielding m Bool ?
09:00:11 <Philippa> yeah
09:00:12 <dcoutts> @where+ haste http://haste.dyndns.org:8080/
09:00:12 <lambdabot> Done.
09:00:22 <dcoutts> gour, http://haste.dyndns.org:8080/
09:00:25 <Philippa> and given an a -> m Bool func and a [a]
09:00:29 <Saulzar> > let anyM f xs = do bs <- sequence xs; return (any f bs) in anyM (>5) [Just 3, Just 6, Just 2]
09:00:29 <tibbe> SimonRC, are you still there? :)
09:00:30 <lambdabot> Just True
09:00:31 <tromp_> then it's no longer a generalized any
09:00:42 <gour> dcoutts: i heard for it, but could not recognize it ;)
09:00:43 <dcoutts> gour, it was a Haskell ide project that kolmodin was involved in as a student project.
09:01:10 <gour> dcoutts: wxhaskell..no more in dev?
09:01:22 <dcoutts> gour, right
09:01:41 <tromp_> oh, i thought you wanted anyM :: (a->Bool) -> m a -> Bool
09:01:48 <dcoutts> gour, but it did prove that one can build an IDE in Haskell in a few months with a fairly small team
09:02:15 <Philippa> tromp_: it's just no longer a /fully/ generalised any, no?
09:02:28 <Philippa> heh
09:02:32 <Philippa> that... wouldn't make sense
09:02:43 <Philippa> not all monads are collections
09:02:51 <tromp_> that wld reduce any[] to normal any ;)
09:02:53 <Xianianol> Humm, what is the difference between "zero :: (Int,Int) -> Int   zero(x,y) = 0"  and "zero :: (Int,Int) -> Int   zero1 p = 0" ?
09:03:04 <gour> dcoutts: i hope someone will take advantage of this property :-)
09:03:08 <jip> Saulzar: here we go, the code is messy and also there are a few functions that aren't used:
09:03:09 <jip> http://rafb.net/paste/results/ylFUsv51.html
09:03:12 <SimonRC> tibbe: yes
09:03:29 <dcoutts> gour, yeah, we're working on it :-)
09:03:51 <gour> dcoutts: despite that ghc-6.6 is not ready?
09:03:52 <tromp_> but of course yours reduces to normal any for m=identity
09:04:32 <Saulzar> jip, Cool, thanks.
09:04:33 <gour> dcoutts: i hope hs-plugins will stay or at least get appropriate replacement. i'm counting on that technology
09:04:34 <dcoutts> gour, sure. We need to fix the bugs in the GHC API before 6.6 comes out! :-)
09:05:12 <jip> Saulzar: if you have Lemmih's SDL bindings installed then the code should compile, except for the fact that i've modified yampa slightly
09:06:37 <tromp_> @type mapM
09:06:38 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
09:07:49 <tromp_> anyM p xs = do { bools <- mapM p xs; return (or bools); }
09:08:10 <SimonRC> @help
09:08:12 <lambdabot>  @help <command> - ask for help for <command>
09:08:17 <SimonRC> @help commands
09:08:18 <lambdabot>  @help <command> - ask for help for <command>
09:08:25 <SimonRC> @help type
09:08:26 <lambdabot>  @type: return the type of a value
09:08:29 <SimonRC> @help ap
09:08:30 <lambdabot>  @help <command> - ask for help for <command>
09:08:33 <SimonRC> @help apply
09:08:35 <lambdabot>  @help <command> - ask for help for <command>
09:08:37 <SimonRC> @help eval
09:08:38 <lambdabot>  @eval <expr>
09:08:38 <lambdabot> You have Haskell, 3 seconds and no IO. Go nuts!
09:09:12 <SimonRC> @eval (\x->x x)(\x->x x)
09:09:13 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
09:09:13 <lambdabot>   Expected type: t
09:09:13 <lambdabot>   Inferred type: t -> t1
09:09:19 <SimonRC> ah, of course
09:10:58 <Saulzar> jip, Hmm, delaySF and accumList are modified Yampa?
09:11:45 <jip> Saulzar: no, delaySF is my attempt at making a SF that outputs a delayed version of it's input. amazingly it works :)
09:11:53 <jip> Saulzar: but the tetris does not use this function
09:12:11 <jip> Saulzar: the modified yampa is that i import "AFRP.Utilities" instead of "AFRPUtilities"
09:12:32 <Saulzar> Ah, ok.
09:12:33 <jip> and "AFRP.Point2" instead of "AFRPPoint2". change those 2 lines and it should work with an unmodified yampa
09:12:34 <pesco> AFRP! AFRP!
09:12:47 <pesco> Isn't it the nicest-sounding name?
09:12:58 <jip> but keep in mind that an unmodified yampa will also imo not compile with ghc 6.4
09:13:06 <Saulzar> I guess that's why they changed it to Yampa
09:13:16 <jip> hm?
09:13:17 <pesco> Stupid! ;)
09:13:42 <jip> i'm using the latest "yampa core" package - afrp-0.4-src.tgz
09:13:49 <pesco> Since I relocated to the Czech Republic, I can pronounce AFRP without too much of a problem. :)
09:13:54 <Saulzar> I'm using 6.4.1, but I haven't modified it except by fixing the extra <<^ etc.
09:14:10 <jip> Saulzar: yeah, that's all that i had to change also
09:14:21 <Saulzar> aff-rip-ih ?
09:14:45 <pesco> Saulzar: No, aff-rr-ip
09:14:53 <pesco> Where there is actually no 'i' sound.
09:15:06 <Saulzar> It sounds awful either way :)
09:15:13 <pesco> You can attach the 'p' directly to a tounge-r.
09:15:19 <pesco> No, I think it sounds cool!
09:15:23 <pesco> AFRP! AFRP! AFRP!
09:15:36 <gour> pesco:from where are you otherwise?
09:15:43 <pesco> gour: Germany.
09:16:14 <gour> pesco: oh, nice...somebody close to me
09:16:15 <tibbe> SimonRC, sorry was AFK, be right back
09:16:24 <jip> i gotta go eat dinner. if you have more questions Saulzar you can msg me and i'll try to answer them when i get back
09:51:24 <tibbe> SimonRC, your language is lazy right?
09:55:45 <SimonRC> tibbe: yes
09:56:14 <SimonRC> I wasn;t thinking about it.  It is just a natural effect of Haskell.
10:00:43 <tibbe> SimonRC, if I would eval and bind the expression when evaluating the (Lam ...) constructor it would make the language strict right?
10:01:22 <tibbe> and then I wouldn't need to pass the id of the var around
10:01:56 <tibbe> SimonRC, I take it back
10:02:23 <tibbe> that wouldn't work 'cause I would try to evaluate functions that hasn't been applied yet
10:06:39 <psnl> I hear that people are going mad here
10:06:42 <Philippa> tibbe: you need closures as soon as you support something lazy like 'if'
10:11:52 <SimonRC> Philippa: note really
10:11:57 <SimonRC> Philippa: oops
10:12:10 <SimonRC> psnl: not really
10:15:33 <Philippa> heh
10:15:37 <Philippa> psnl: where's here?
10:15:53 <astrolabe> mad in what way?
10:17:32 <tibbe> Philippa, I'm gonna have closures and even the language is strict I think I'll have if as a built-in with lazy evaluation
10:17:54 <tibbe> Philippa, but it would be nicer with closures, then I don't need as many built-ins
10:17:57 * Philippa nods
10:18:11 <Philippa> I should start writing lambda lifters and so forth
10:21:33 <tibbe> hmmm, I'm using the reader monad but at some point I need to add new bindings to the env. should I use "local" then?
10:21:37 <vincenz> an that alex.g...@gmail.com is one hardass
10:21:49 <Philippa> vincenz: you read clf?
10:21:52 <vincenz> yeah
10:22:13 <Philippa> tibbe: yeah
10:22:16 <xerox> tibbe: yes.
10:22:22 <xerox> Oops :)
10:22:41 <vincenz> Philippa: he's personally called at least 3 people idiots
10:22:42 <Philippa> xerox: I had to go look it up because I've never used it in anger and thus don't know the function names...
10:22:48 * SimonRC goes
10:23:08 <xerox> @type Control.Monad.Reader.local
10:23:10 <lambdabot> forall r (m :: * -> *) a.
10:23:10 <lambdabot> (Control.Monad.Reader.MonadReader r m) =>
10:23:10 <lambdabot> (r -> r) -> m a -> m a
10:23:10 <Philippa> yeah. I've been skirting the edge, mostly because I can't be arsed with a flamewar
10:23:24 <vincenz> I saw your post ;)
10:23:27 <vincenz> was a few days ago
10:23:28 <xerox> Right-o.
10:27:46 <Philippa> vincenz: you don't want to actually hang around in #polyamory after joining? :-)
10:28:10 <vincenz> hmm
10:28:20 <vincenz> I whoised you and was curious about the channel
10:28:27 <vincenz> Philippa: what do you do
10:28:33 <vincenz> Philippa: study, work, graduate?
10:28:38 * Philippa nods - you'll find I post on alt.polyamory too
10:28:46 <Philippa> none of the above. Mostly being not quite well enough to work
10:29:21 * vincenz LAUGHS
10:29:27 <vincenz> http://www.cip.physik.uni-muenchen.de/~tf/raytracer/ocaml.html
10:29:32 <vincenz> did you see the link that jon harop sent?
10:29:43 <vincenz> some guy compares an OCaml implementation to an Objective Caml implementation
10:30:01 <vincenz> Philippa: ill?
10:30:11 * vincenz coughs as he laughed too hard
10:30:20 <Philippa> vincenz: sort of, yeah
10:30:35 <Philippa> OCaml has extensions beyond the Objective Caml language? Or is it considered definitional?
10:30:40 <vincenz> sorry to hear that :/
10:30:43 <vincenz> Philippa: they're the same
10:30:51 <vincenz> ocaml stands for objective caml
10:31:35 <Philippa> I thought OCaml referred to a specific implementation of Objective Caml these days?
10:31:48 <Philippa> at least, officially?
10:32:06 <vincenz> Philippa: there isi only one implementation 
10:32:27 <psnl> Philippa: #haskell
10:32:49 * vincenz raises his eyebrow at Philippa 
10:32:54 <Philippa> caml light's still minus the objective bit, then?
10:32:56 <vincenz> s/Philippa/psnl
10:32:59 <Philippa> fair enough
10:33:00 <vincenz> Philippa: yes
10:33:17 <vincenz> Philippa: it's just a prior implementation by the same group before the advent of objects
10:33:26 * psnl deicdes it clearly was false
10:33:30 <Philippa> yeah, I know a little of caml's history
10:33:39 <Philippa> am mildly annoyed that I can't dig up the paper on the CAM
10:33:56 <Philippa> psnl: yerwhat? :-)
10:34:44 <vincenz> CAM?
10:34:58 <psnl> 18:14 <Philippa> psnl: where's here? >>= 18:31 <psnl> Philippa: #haskell
10:35:01 <Philippa> Categorical Abstract Machine. Upon which the earliest caml implementations were based
10:35:20 <Philippa> psnl: ah, thanks. Context switched so many times I overflowed the stack
10:35:37 <vincenz> Philippa: didn't know that
10:35:52 <psnl> your context switches need a stack?
10:36:27 <tibbe> how do I know if I've implemented dynamical scoping by mistake? xD
10:36:32 <Philippa> psnl: yeah, my head's full of broken implementation cruft or I would be doing a PhD by now :-)
10:36:39 <psnl> heh
10:38:00 <vincenz> Philippa: why aren't you
10:39:05 <Philippa> for the same reason I'm not working
10:39:27 <vincenz> Philippa: the punchline is where he shows how to compile the two programs
10:39:30 <Philippa> the short version is there're times I have enough difficulty motivating myself to get a glass of water, let alone actually work
10:39:31 <vincenz> thiis is jon harop's version
10:39:34 <vincenz> ocamlopt -inline 100 -ffast-math ray.ml -o bench.ocaml
10:39:37 <vincenz> and this is his versioin
10:39:43 <vincenz>  ocamlopt.opt -ffast-math -inline 100 ray-tf.ml -o bench.objective-caml
10:40:09 <vincenz> ocamlopt.opt is basically the native code version of the native code compiler, ocamlopt is the bytecode version of the native code compiler
10:40:14 <Philippa> that being the only difference?
10:40:18 <Philippa> ah
10:42:07 <Korollary> in my junior year there was a class that I couldn't motivate myself to study.
10:42:17 <Korollary> It was a very peculiar experience.
10:42:51 * Philippa nods
10:42:57 <Philippa> I'm like that enough for it to really screw my life up :-(
10:43:13 <Korollary> I saw a psychologist who didnt help much. I barely passed.
10:43:22 <Saulzar> I didn't attend my classes, that was very bad for my grades
10:44:23 <Korollary> Well, that's always bad. The weird thing was that I wanted to study. I needed to study. I was afraid of failing. I still couldn't bring myself to study. It was hell (a minor hell compared to Philippa's)
10:44:39 <Saulzar> Motivation is everything, I think anyone can do extremely well if they're motivated...
10:44:58 <Philippa> tbh, these days life's... the 'hell' parts're more recovering from stuff that's happened in the past. Luckily the UK's not too crappy about welfare - I'd be in a bad way in the US
10:45:15 <Philippa> perhaps. Certainly you get 'smarter' if you throw yourself at lots of problems
10:45:43 <Korollary> or you come across as smarter
10:45:48 <Philippa> I always used to be slightly bothered that other people weren't playing the sorts of games I was in lectures - "where're they going next?" "what properties can I figure out about what they're describing before being told?" and so forth
10:46:05 <Philippa> I think in a meaningful sense you /are/ smarter, because you've added more abstractions, more analysis to your capabilities
10:46:15 <Korollary> most people lag weeks behind the prof let alone wonder what's next.
10:46:36 <Philippa> having encountered half the material beforehand's kinda cheating, yeah
10:47:02 <Korollary> Well, breadth of knowledge is good. But I did prove my understandings/expectations wrong in a few subjects after going deep as well.
10:48:22 * Philippa nods
10:48:29 <Philippa> sometimes you form slightly the wrong understanding
10:48:30 <Philippa> happens
10:48:41 <Korollary> and there's the iceberg sometimes.
10:49:25 <Philippa> yeah. Fewer of those these days, I've seen a greater variety of systems - they're more sort of interesting quirks usually now
10:49:31 <astrolabe> iceberg?
10:49:36 <astrolabe> lettuce?
10:49:44 <Korollary> titanic?
10:49:44 <Philippa> astrolabe: big sod-off confusing thing that sinks you
10:49:56 <astrolabe> Ah
10:50:00 <Korollary> oh
10:50:03 <Korollary> I didnt mean that
10:50:21 <Xianianol> A question, I got a function "substring" that checks if a list A is a substring of list B. It works, now someone told me that my function can be improved by implementing not only Eq but also Ord, so that I can use "<". Also, he mentioned that it would be a lot faster if I was comparing "repetition free ordered list", why is that ?
10:50:23 <Korollary> I meant the "only one third above the surface" metaphor.
10:50:56 * Philippa nods
10:51:02 <Philippa> but usually that's why it sinks you, too
10:51:27 <Korollary> Right.
10:51:52 <Korollary> well, from a turing machine perspective everything's a quirk ;)
10:51:52 <astrolabe> Xianianol: Eq and Ord on the type of the elements of the list?
10:52:51 <Xianianol> Well, ist just that I am defining my own data.
10:53:09 <Xianianol> For example, instead of calling [a]. I call it Set a
10:53:55 <Xianianol> But you can think that Ord is already implemented, is just that I don't see where can I use a "<" to improve my function.
10:54:15 <astrolabe> Xianianol: if the element type has an order and the list is ordered, then you could use a binary tree to search it.
10:54:25 <Xianianol> The only thing that I can see is to check if list A is < than list B. If it is not, then list A can't be a substring of B.
10:55:22 <Xianianol> However I don't see a big improvement coming in or why does it make a difference between a regular list or a "repetition free ordered list"
10:55:32 <astrolabe> Xianianol: When you implement Ord, do you do it on the list type or the type of the elements of the list?
10:56:45 <Xianianol> Humm, I do something like Ord a => Set a -> Set a -> Bool
10:57:36 <cakoose> I need to read data from two files and process them together.  What's the cleanest way to bail out if either call to openFile fails (and to make sure both handles are closed when I'm done)?
10:58:32 <astrolabe> Xianianol: Then you could store your list in a binary tree, which would speed up searching for the beginning of the potential sub-list.
11:00:03 <Xianianol> So, I put the say, the main string into a binary tree, then I find the elements of the substring 1 by 1 in the binary tree ?
11:02:38 <astrolabe> Xianianol: I'd suggest just finding the first element of the substring using a tree search, then work out a way to traverse along the bottom of the tree.
11:03:43 <Xianianol> Humm, okay, I'll try that. Thanks
11:05:29 <astrolabe> Xianianol: It is only worthwhile if you are searching for lots of substrings of the same string.
11:06:23 <Xianianol> Well, that may be needed.
11:07:26 <astrolabe> Maybe an easier approach than traversing would be to store the long string in a array as well, and store array indices at the leaves of the tree.
11:07:54 <Xianianol> Like a B+ tree ?
11:09:55 <astrolabe> Yes, a bit.
11:10:33 <Xianianol> I'll try that too then.
11:37:57 <lispy> where can i find a mathematical treatment of monads?
11:38:02 <SimonRC> yo
11:38:18 <SimonRC> lispy: Wikipedia should have a link to some.
11:38:22 <Philippa> how big a treatment do you want?
11:38:35 <jip> what about a mathematical treatment of arrows?
11:39:14 <lispy> Philippa: well, enough to understand them from scratch in terms of math
11:39:32 <Philippa> so really you want a large dose of category theory and then the categorical definition?
11:39:33 <lispy> http://www.cs.man.ac.uk/~pt/Practical_Foundations/html/s75.html
11:39:41 <lispy> that url talks about them but assumes too much
11:39:48 <lispy> Philippa: ah
11:49:06 <lispy> i think between my topology book and algebra book i can get some category theory
11:49:21 <lispy> in fact, i tihnk my topology book miht be exactly what i wanted
11:49:38 <Cale> which books?
11:49:40 <Philippa> understanding categories, functors and natural transformations should be enough
11:49:54 <Philippa> most of 'what it means' comes down to how you interpret the categories involved
11:50:00 <lispy> Cale: it's a dover book, "Introduction to topology"
11:50:05 <Philippa> for functional programming purposes, they're descriptions of language semantics
11:50:51 <lispy> i'm looking at an abstraction notion of time for animations, so i'm thinking of covers for time and ways to identify times in different "domains"
11:51:10 <lispy> i think topology will serve my purposes well
11:51:25 <Cale> oh, you were looking for the mathematical definition of monad?
11:51:44 <Philippa> for an understanding thereof, I think
11:52:31 <lispy> yeah
11:52:34 <vincenz> hello
11:52:47 <vincenz> blegh...that book from the websitie makes me understand nada
11:53:07 <Cale> vincenz: which one?
11:53:15 <vincenz> the one lispy gave
11:53:19 <lispy> my url?  that link was pretty bad :)
11:53:27 * vincenz has no formal CS backgrond :/
11:53:30 <astrolabe> I remember reading a Bertram Russell Essay about the fine-scale properties of time.  I don't really see why you can't just use the real numbers as a model though.
11:53:32 <lispy> it's meant for a different audience
11:53:37 <vincenz> I wish there was a nice book I could get to learn about all this
11:53:39 <vincenz> any suggestioins
11:54:08 <lispy> astrolabe: oh hm...i'll look him up, the reals are fine to an extent, but we need to structure them
11:54:37 <gzl> Bertrand, not Bertram
11:54:55 <vincenz> the constructionist :)
11:55:06 <astrolabe> lispy: I'm not sure he'll be helpful.  I was mentioning him as a counterweight to my implication that it was all worked out these days.
11:55:15 <astrolabe> gzl: thanks.
11:55:17 <vincenz> Cale: any suggestion for a good book to get me up to speed with CS?
11:55:28 <vincenz> like when people talk about "catamorphisms"
11:56:13 <Cale> vincenz: hmm... I don't have many books on CS myself. I have a pure math education though, so it helps to read papers.
11:56:14 <gzl> lispy: general topology doesn't really use any category theory, that stuff is used in algebraic topology
11:56:44 <astrolabe> lispy: The reals come with all the structure you need.  They do have a topological structure, but they are sort of a trivial case, topology tends to be used to study more general spaces.
11:56:47 <Cale> there are a few papers with silly titles about {cata,ana,hylo,etc}-morphisms
11:56:54 <gzl> vincenz: do you want to learn about CS or learn about catamorphisms?
11:57:07 <Cale> Bananas Lenses and Barbed Wire
11:57:22 <Cale> @google Bananas Lenses and Barbed Wire
11:57:24 <lambdabot> http://citeseer.ist.psu.edu/meijer91functional.html
11:57:44 <vincenz> gzl: the formal stuff
11:57:59 <gzl> that's really vague.
11:58:06 <vincenz> yeah wlel
11:58:27 <gzl> just in PL theory? something more specific in PL? all of CS? what are you trying to do
11:58:40 <vincenz> understand what people talk about when they talk about "catamorphisms
11:58:46 <vincenz> but I have to run to catch my bus
11:58:58 * vincenz *detaches and unlogs from ssh*
11:59:07 <Cale> well, I could introduce you to that
11:59:09 <Cale> next time
12:03:36 <lispy> i don't think studying topology will be a waste here, we'll be transforming between different sets of time points
12:03:56 <lispy> and hopefully we'll always be dealing with cases that are almost trivial to a topologiest
12:04:09 <Cale> what are you doing?
12:05:37 <lispy> Cale: trying to automatically transform simulation data to presentations
12:06:18 <lispy> and do it in a way that is interactive and tries to minimize the need to rerun the simulation when the user wants a different presentation
12:06:45 <Cale> hmm
12:07:36 <lispy> having a robust model of time seems like a good starting point
12:07:54 <lispy> we'll also need a concept of styles and so on, but just focusing on this aspect for now :)
12:08:26 <Cale> so which kind of topology are you studying?
12:08:44 <SimonRC> Anyone know of a library that allow one to assemble GUIs as data structures, rather than building them using IO?  Like Text.Html, but for GUIs.
12:09:08 <jip> SimonRC: fruit
12:09:15 <lispy> Cale: this book is pointset topology, afaict
12:09:21 <Cale> FunctionalForms
12:10:07 <Cale> lispy: you might find that it's not directly useful, but who knows, it might get you started thinking the right way :)
12:11:35 <SimonRC> lispy: examine Haskore for hints.
12:11:45 <lispy> Cale: i already have some topology under my belt, so really i'm just reading a few chapters to find out how applicable this stuff will be
12:11:56 <lispy> SimonRC: okay, thanks for the reference
12:12:32 <SimonRC> the :+: and :=: operators are a cool idea
12:14:03 <_|_kid> hello all :P
12:15:02 <SimonRC> hi
12:15:24 * SimonRC applies snd to _|_kid.
12:15:37 <SimonRC> there, defined now
12:15:40 <_|_kid> heh
12:16:36 <_|_kid> is there some kind of correlation between type classes or C++0x Concepts and category theory (i was never thought category Theory)?
12:17:21 <Cale> not a direct one
12:17:29 <_|_kid> i'm awhere that Concepts & type classes are strictly not equivalent ;)
12:17:41 <Cale> it just turns out that they're useful for expressing some category theoretic things.
12:17:57 <Cale> I have no idea about C++ concepts
12:19:03 <_|_kid> Cale: as of this moment there is there non-exist and not first-class entities in C++ but there  being thrown into C++0x, quite simillar to type classes although not strictly true, there to do with generic programming in C++
12:19:16 <_|_kid> *non-existant
12:19:32 <Heffalump> there's a POPL 06 paper about them, I believe
12:19:40 <lispy> Cale: if you want to learn about them, http://public.research.att.com/~bs/popl06.pdf
12:20:17 <Philippa> _|_kid: are you aware of how your nick could be taken by someone who's both familiar with its literal meaning and possibly at least a mild perv? :-)
12:20:30 <lispy> the author's comment that templated classes are analgous to parametric polymorphism ala system F
12:20:36 <_|_kid> Philippa: yep ;)
12:21:02 * lispy wonders what the perv meaning would be
12:21:08 <lispy> O
12:21:10 <lispy> n/m
12:21:16 <Cale> heh
12:21:32 * _|_kid is an ass
12:21:56 <Philippa> lispy: you're assuming there's only the one
12:22:46 <Philippa> actually that'd be better than the Dom/sub nick convention if there were a good symbol for switch, but hey
12:22:47 <lispy> Philippa: heh
12:24:34 <_|_kid> considering all the proposed language additions/changes/modifications to C++ in C++0x some of which contradictory, there would do better to throw out the old type system and throw in a formalized one like haskell's one ;)
12:25:46 <lispy> yeah
12:26:01 <SimonRC> But that would stop it being good for systems programming.
12:26:07 <lispy> but one of the explicit requirements of Concepts is that existing C++ software engineers would be able to adapt
12:26:36 <Philippa> SimonRC: not necessarily
12:26:53 <Philippa> you can have a formalised type system that admits unions and casts still
12:26:54 <_|_kid> SimonRC: why would it stop it from being that, you could replace a thew things without having to have lazy evalution
12:27:42 <Cale> C++ is good for systems programming? ;)
12:27:51 * SimonRC considers Haskell's Libraries.
12:28:03 <SimonRC> I was talking nonsense, evidently.
12:28:48 <_|_kid> have you seen the proposed syntax to combot the forward problem with local inference? 0_o it almost resembles ML functions
12:28:57 <_|_kid> *combat
12:29:31 <Cale> heh, in 5 or 6 years, maybe the C++ people will have something resembling ML
12:29:55 <_|_kid> sorry, *forwarding problem
12:30:14 <_|_kid> i'm suck :(
12:30:18 <_|_kid> ...
12:30:23 <_|_kid> see what i mean 
12:30:57 <lispy> Cale: i think google's success/strategy will definitely make fp more attractive in the future
12:31:35 <_|_kid> erh?, i thought google changed all it's code to C++ from lisp or was that another company...
12:31:48 <lispy> MapReduce as they call it, is prefect for promoting FP
12:32:05 <lispy> _|_kid: you're thinking of ebay stores, written originally by Paul Graham
12:32:05 <_|_kid> yeah but the example code is in C++ 0_o
12:32:06 <SimonRC> Yup, read about that.
12:32:21 <SimonRC> aha: on c++
12:32:28 <SimonRC> "We were after the C++ programmers. We managed to drag a lot of them about halfway to Lisp."
12:32:29 <Cale> I can't believe MapReduce is considered a big deal :) It's like, turning prelude functions into programming paradigms.
12:32:32 <SimonRC> - Guy Steele, co-author of the Java spec
12:32:33 <lispy> _|_kid: or maybe i mean yahoo stores...i forget
12:32:51 <lispy> Cale: yeah :(
12:32:59 <Cale> I should come up with ZipWith and make millions
12:33:04 <lispy> Cale: but whatever it takes for fp to become mainstream :)
12:33:13 <_|_kid> Cale: like OO with the composite and visitor pattern ;)
12:33:22 <Cale> _|_kid: yeah
12:33:42 <PerlJam> As long as lisp is the predominant FP language, FP will never be main stream.
12:33:57 <SimonRC> Cale: actually, I have read map-reduce, and AFAICT: map::a->[(b,c)]; reduce::(b,[c])->d
12:33:58 <_|_kid> PerlJam: i don't believe so
12:34:27 <_|_kid> PerlJam: take alook a thew new OO languages, there typically hybrid OO-functional
12:34:39 <Cale> SimonRC: there are no functions of those types though
12:35:06 <SimonRC> but that's what the operations are doing to lists, I think
12:35:48 <lispy> SimonRC: is reduced typed correctly?
12:36:19 <lispy> reduce::[(b,c)]->d seems like the more natural choice given the definition of map
12:36:19 <SimonRC> lispy: waitamo
12:36:27 <SimonRC> lispy: waitamo!
12:36:50 <lispy> waitamo :: Nick -> IO ()
12:36:55 <SimonRC> the "map" operation turns each item of a list into zero-or-more (key,value) pairs, these are collected together by key, then the collected lists of values are put through the "reduce" operation.
12:37:13 <lispy> ah
12:38:15 <PerlJam> _|_kid: All that tells me is that a pure-fp language will never be main stream  :)
12:38:52 <_|_kid> PerlJam: either that or we going slowly towards them ;)
12:39:17 <lispy> IMHO, multiparadigm is better than single paradigmn anyway
12:39:29 <PerlJam> lispy: yep.  That's why I like languages like perl.
12:39:31 <_|_kid> anyone played with Curry, i know it can be hot ;)
12:39:54 <Philippa> I don't buy multiparadigm languages
12:40:07 <Philippa> OTOH, I kind of have a tendency to look for a holistic approach
12:40:14 <_|_kid> heh
12:40:22 <Philippa> so I want FP where product and sum types are on an equal footing for example
12:40:32 <Philippa> (and where it's not both feet crippled)
12:40:56 <_|_kid> not even functional-logic?
12:41:24 <SimonRC> Philippa: product and sum?  is that struct and union types?
12:41:30 <Philippa> not on a foundational level, though I could be convinced
12:41:38 <Philippa> SimonRC: nearly. Disjoint unions
12:41:54 <_|_kid> Curry looks tasty but no type classes in the offical standard :(
12:42:12 <Heffalump> wdym by an equal footing?
12:42:52 <Philippa> Heffalump: good question - I'm not sure they're that far off it in Haskell for some values of 'equal'
12:43:13 <Philippa> I'm mostly thinking things like not having subtyping on one and not the other
12:43:18 <SimonRC> indeed: "data Foo = Foo A B C; data Bar = Bar1 A | Bar2 B | Bar3 C"
12:43:39 <SimonRC> Philippa: erm, what?
12:43:49 <Philippa> SimonRC: not quite. The sum's labelled there, whereas the product's not (but if you used a record...)
12:43:53 <_|_kid> nah main, it's all about generlized ADTs :P
12:44:07 <_|_kid> even OO is trying to get in on the action 
12:44:21 <musasabi> mmh, Haskell lacks automatic deconstructor functions for datatypes.
12:44:31 <SimonRC> Philippa: isn;t the sum labled Foo?
12:44:48 <SimonRC> and the product BAr?
12:44:48 <lispy> musasabi: yeah, lisp has those and it's nice
12:44:56 <Philippa> SimonRC: I'm talking about the components. And you've got 'em the wrong way round
12:44:59 <_|_kid> musasabi: you mean destructor ;)
12:45:03 <SimonRC> Philippa: ah, yes
12:45:14 <Cale> Large product types seem to be bad style in Haskell, but they seem hard to avoid when interacting with programs and libraries designed with OO in mind.
12:45:27 <Philippa> that, and they often become necessary from a sweng POV
12:45:28 <musasabi> Given "data Foo = Foo1 A B | Foo2 C" "deFoo :: (A -> B -> t) -> (C -> t) -> Foo -> t" or similar
12:45:46 <Philippa> records're a godsend for long-term code maintenance, sometimes they even trump currying on functions
12:45:51 <SimonRC> "data Foo = Foo {a::A, b::B, c::C}; data Bar = Bar1 A | Bar2 B | Bar3 C"  almost works
12:46:01 <_|_kid> "deconstructor" reads/sounds silly, just say destructor :P
12:46:12 <Philippa> (admittedly it's mostly when you're pretty sure there's no good reason to curry because you're not going to expose the damn function, but hey)
12:46:26 <Philippa> _|_kid: it doesn't destroy though, it only takes apart
12:46:31 <musasabi> _|_kid: imho destructor has too many other meanings.
12:46:39 <Philippa> exactly
12:46:44 <Philippa> what happens if you have a language that has both?
12:46:48 <SimonRC> so does "constructor"
12:47:12 <Philippa> I dunno, the meaning's pretty much the same in haskell as in C++, it's just a question of what it belongs to
12:47:15 <_|_kid> i see i what you, i wasn't actually paying attension, you mean deconstruct interms of a pattern?
12:47:18 <Cale> You're not destroying the data
12:47:26 <Philippa> "function that builds a value"
12:47:49 <musasabi> _|_kid: yes.
12:48:11 <_|_kid> musasabi: okay, i'll let you off ;)
12:48:34 <Philippa> in fairness, it's a far less dangerous piece of sugar with records
12:50:26 <_|_kid> you know i was suggesting to the developers of Nemerle to add first-class phantom types, i gave a paper that described GADTs in OO C# they got all excited and then relized it wasn't possible for Nemerle ^_^
12:51:22 <jip> _|_kid: is nemerle any good:?
12:52:42 <_|_kid> for what it is or tries to do it's decent, i'd use it over C# 2.0, seems to have a very good macro system in vein of lisp macros and syntax extension support
12:53:34 <_|_kid> obviously MSIL has limitations for functional features so somethings are implicitly possible
12:53:49 <_|_kid> *aren't
12:54:22 <_|_kid> for e.g. Nemerle functions are not curried, .NET restriction
12:55:05 <lispy> how can the .NET runtime prevent functions from being curried?
12:55:34 <_|_kid> i don't know something about portability of CLR
12:55:42 <_|_kid> i can't remember exactly
12:55:46 <lispy> with the JVM it is possible to generate an anonymous class which is runable and then run it, thus getting something close enough for lambda
12:56:27 <lispy> but, the JVM allows you to generate bytecode, verify it, load it, instantiate an object of that type, and then invoke methods on your object
12:56:46 <cakoose> lispy: They probably aren't curried to allow interoperability with C#.
12:57:29 <_|_kid> cakoose: i think that is case plus other .NET languages
12:57:58 <cakoose> I think overloaded methods are the main issue.
12:58:20 <lispy> F# can curry
12:58:22 <_|_kid> lispy: so maybe not an IL issue but CLR issue
12:58:38 <_|_kid> lispy: F# is compiled to XIL i believe
12:58:48 <lispy> XIL = unmanagade code?
12:58:54 <lispy> er unmanaged
12:58:55 <dstatyvka> lispy: but only private functions
12:59:13 <_|_kid> extensions to IL to support functional languages but it's only in MS research
12:59:31 <cakoose> Scala (JVM based) allows currying but not by default.  I think this is for interoperability and performance.  You write: myFunc(int x)(int y).
13:00:17 <_|_kid> nemerle does have a parital application operator though
13:00:52 <_|_kid> quite simillar to boost.lambda/phoenix with there placeholders
13:01:51 <dstatyvka> _|_kid: is closures partial evaluated functions?
13:02:00 <lispy> what is the difference between partial application and currying?
13:02:03 <cakoose> One cool feature is that you can write "_.Jump(4)" as well as "x.Jump(_)"
13:02:31 <cakoose> Currying is, I believe, what happens when you define such a function.
13:02:38 <cakoose> Partial application is when you invoke it.
13:03:09 <_|_kid> dstatyvka: i'm not sure, it's probably a macro so it might do
13:03:47 <_|_kid> dstatyvka:oh wait you meant something else
13:05:05 <SimonRC> dstatyvka: also functions that capture variables from the surrounding context.
13:05:18 <tromp__> @type curry
13:05:19 <lambdabot> forall c b a. ((a, b) -> c) -> a -> b -> c
13:05:32 <_|_kid> @type uncurry
13:05:34 <lambdabot> forall c b a. (a -> b -> c) -> (a, b) -> c
13:05:35 <dstatyvka> in boost bind and lambda constructs callable classes.  This is what I call closures in c++ now
13:07:19 <_|_kid> dstatyvka: yes, but there not partially evaluted
13:07:54 <_|_kid> dstatyvka: have you seen pheonix yet?
13:08:03 <dstatyvka> _|_kid: exactly
13:09:55 <dstatyvka> _|_kid: I have
13:10:45 <dstatyvka> _|_kid: well, documentation only :-)   and interfaces.
13:12:07 <_|_kid> dstatyvka: boost fusion 2? ;)
13:12:12 <SamB> partially applied functions are pretty much closures, yeah...
13:12:54 <lispy> closures and instantiated objects are very similar
13:13:01 <SamB> so is just about anything that isn't a supercombinator, I guess...
13:13:03 <_|_kid> partial evalution != partially applied
13:14:36 <SamB> hmm, point
13:14:50 <SamB> it would be nice to have a JIT PE
13:15:32 <lispy> is partial evaluation the creation of thunks?
13:16:08 <dstatyvka> _|_kid: who nows...  But it's not a tools I'd like to use.
13:16:10 <SamB> no, actually, partial evaluation is some kind of specialization technique which
13:16:25 <dstatyvka> I prefer suitable tools
13:16:39 <SamB> ... er, I'm not sure how it works exactly, but it seems to involve taking some input early
13:17:04 <SimonRC> lispy: yes
13:17:26 <SamB> SimonRC: wait, what?
13:17:51 <_|_kid> if a composition of boost::lambda *clousures* where partially evaluted only one closure exist instead of nesting of clousres, however if a C++ user-defined types that has functional operator overloaded and has trivial state (i.e. next no state) and is not allocated on the heap (as is the typical case) the compiler will optimize away many of those instances i believe that would be like a partial evalutor
13:17:58 <SimonRC> SamB: what did I say?
13:18:15 <SamB> SimonRC: is that what partial evaluation means?
13:18:32 * SamB looks it up in the dictionary
13:18:35 <SimonRC> I think so
13:18:45 <SimonRC> as opposed to partial application
13:18:54 <SamB> From The Free On-line Dictionary of Computing (27 SEP 03) [foldoc]:
13:18:54 <SamB>   partial evaluation
13:18:54 <SamB>        
13:18:54 <SamB>           <compiler, algorithm> (Or "specialisation") An {optimisation}
13:18:54 <SamB>           technique where the {compiler} evaluates some subexpressions
13:18:55 <SamB>           at {compile-time}.
13:19:32 <SimonRC> except, we're evaluating parts of expresions at reun-tim
13:20:04 <_|_kid> yes, you can write partial evalutors in C++ with template metaprogramming techniques
13:20:48 <_|_kid> simple exmple would be like unrooling loops with template tricks
13:21:03 <_|_kid> or partially evaluted sqr
13:21:39 <SamB> hmm. It says "See also {full laziness}.
13:21:39 <SamB> "...
13:21:55 <SamB> oops.  didn't mean to paste the newline.
13:21:56 <dstatyvka> _|_kid: compiler often does no optimizations.  And programmer has no possibilities to control optimizations.  At least with C++ compilers
13:22:26 <SamB> okay, so what were we saying again?
13:23:02 <_|_kid> dstateyvka: was that in response my boost.lamdba comment?
13:23:08 <_|_kid> *to my
13:24:55 <SamB> is it just me or is foldoc using Haskell for example code?
13:27:02 <Heffalump> Google suggests that the author of FOLDOC was involved in Haskell as far back as 93.
13:27:12 <Heffalump> So that wouldn't be surprising.
13:27:29 <ibid> who is the author of foldoc?
13:27:46 <Heffalump> Denis Howe
13:28:17 <SamB> so, let me ask a strange question.
13:28:22 <SamB> what isn't a closure?
13:28:28 <Heffalump> me.
13:28:38 <xerox> Heh.
13:28:40 <dstatyvka> :-D 
13:28:41 <SamB> hmm.
13:28:44 <xerox> elisp code
13:28:57 <SamB> okay, this question needs refinement.
13:29:00 <Heffalump> Any piece of code that doesn't have an environment (possibly empty) wrapped up with it.
13:29:07 <SamB> okay.
13:29:14 <Heffalump> s/piece of code/piece of code being passed around as data/
13:29:27 <SamB> so can you give an example?
13:30:00 <xerox> bzzt
13:30:03 <tromp__> 0
13:30:17 <SamB> which zero?
13:30:28 <tromp__> or x with a binding [x:=0]
13:30:34 <xerox> I think he means 'values like numbers'.
13:30:46 <SamB> oh. well. depends on the type ;-)
13:30:46 <Heffalump> that *is* a closure.
13:31:04 <tromp__> it's any expression without unbound variables
13:31:09 <SimonRC> SamB: do you read LISP?
13:31:15 <xerox> Hmm.
13:31:16 <SamB> I can.
13:31:24 <SamB> but I wasn't talking about LISP ;-)
13:31:35 <Heffalump> a closure is any expression without unbound variables.
13:31:42 <Heffalump> So any expression *with* unbound variables is clearly not a closure.
13:31:46 <SamB> lisp has a clearer distinction between code and data
13:31:50 <xerox> ...unbound?
13:31:50 <tromp__> or the combination of an expression plus bindings for all free variables
13:31:55 <SamB> Heffalump: so what happened to that "possibly empty"
13:32:17 <SamB> oh, wait. nevermind. I'm clearly mixed up.
13:32:18 <SimonRC> how about (LET ((FOO 1)) (DEFINE (BAR X) (SET! FOO (+ FOO BAR)) FOO)))
13:32:21 <SimonRC> oops
13:32:34 <SimonRC> how about (LET ((FOO 1)) (LAMBDA (X) (SET! FOO (+ FOO BAR)) FOO)))
13:32:35 <tromp__> a closure is something that no longer depends on the context in which it occurs
13:32:58 <SimonRC> it wraps up bindings from the environment in which it was defined.
13:33:02 <Heffalump> well, if you have a piece of code that has no unbound variables in it, it's hard to tell whether or not this is by accident or design
13:33:15 <xerox> Ah, gotcha.
13:33:16 <dstatyvka> Heffalump: so clousre == combinator?
13:33:19 <Heffalump> but in practice, any machine representation of a closure must allow for the possibility of an environment being needed.
13:33:20 <_|_kid> strangest thing is closures are typically implemented by allocated them on the (gc) heap, in C++ they can be simulated by user-defined types overloading function call operator and using templates and there typically allocated on the stack, the only problem is to return them requires either compiler support to infer return types (ala typeof/decltype) or some complex template metaprogramming (ala result_type)
13:33:31 <xerox> We need Riastradh :)
13:33:33 <Heffalump> So you ought to find some empty environment.
13:33:38 <Heffalump> dstatyvka: no.
13:34:40 <SamB> so is a combinator not a closure?
13:34:52 <tromp__> yes it is
13:35:03 <dstatyvka> why?
13:35:20 <tromp__> a combinator has no unbound variables
13:35:38 <_|_kid> <_|_kid> dstateyvka: was that in response my boost.lamdba comment?
13:35:40 <SamB> what is an expression with unbound variables, anyway?
13:35:53 <SamB> I don't believe they exist.
13:35:56 <dstatyvka> you say "a closure is any expression without unbound variables"
13:36:10 <tromp__> x is not a closure
13:36:20 <SamB> but is x anything?
13:36:30 <tromp__> a variable
13:36:37 <Heffalump> closures are really an implementation technique, not a classification of lambda terms.
13:36:44 <SamB> how do you figure it is a variable?
13:36:47 <_|_kid> zing
13:37:00 <Heffalump> after all, you can implement stuff by substitution and then you don't need an environment at all
13:37:12 <Heffalump> But a closure is normally seen as some code + an environment.
13:37:20 <Heffalump> So probably it's misleading to talk about expressions in that way.
13:37:24 <SamB> okay, this is interesting.
13:37:38 <tromp__> the notion is originally defined for lambda calculus
13:37:51 <SamB> its an implementation technique?
13:38:13 <Heffalump> I think so, yes.
13:38:14 <Cale> The wikipedia article talks about storing information across function calls, which I see as sort of wrong, unless you're just talking about constants.
13:38:26 <tromp__> so \x.\y.x is a combinator
13:38:27 <MenTaLguY> hello
13:38:34 <Heffalump> combinator is an ill-defined term.
13:38:40 <tromp__> and \x.z x is not
13:38:44 <Heffalump> I had a go some time ago on here, but I can't find the logs.
13:38:51 <Heffalump> or rather, I can't remember the date so I can't find the logs easily.
13:38:57 <Heffalump> But you could try searching them for combinator.
13:39:31 <MenTaLguY> the "traditional" short definition of a combinator is a function with no free variables
13:39:38 <Philippa> the translate-to-supercombinators thing does seem to have its advantages
13:39:51 <dstatyvka> _|_kid: sorry, which comment?
13:40:01 <SamB> I think a *real* combinator is probably just a function that doesn't refer to any names that aren't its arguments ;-)
13:40:12 <Cale> SamB: I kind of agree with that one
13:40:26 <MenTaLguY> SamB: wasn't that what I said? ^^;
13:40:32 <SamB> MenTaLguY: yes ;-)
13:40:37 <_|_kid> dstateyvka: you meantioned some about c++ compiler optimizations, i'd assume that was in response to my large comment on boost.lambda and partial evalution vs partial application
13:41:08 <dstatyvka> _|_kid: oh.  yes
13:41:14 <MenTaLguY> I've got a question ... is there a consise way to get a slice of an IArray?
13:41:16 <Cale> It's a function which takes some arguments and produces some term consisting of applications of those arguments to one another.
13:41:41 <SamB> however, coloquially a combinator is something that combines *active* things
13:41:54 <SamB> which are things that semm to do something
13:42:00 <SamB> s/semm/seem/
13:42:27 <_|_kid> dstatyvka: i'm not sure what you mean then, with optimizations turn on trivial c++ functors are optimized out, further more read this: http://www.boost.org/doc/html/lambda/s07.html#id2712759
13:42:44 <SamB> MenTaLguY: a slice?
13:42:59 <SamB> hmm.
13:43:04 <tromp__> so \x.(x(\y.y)) is not a combinator?
13:43:09 <lisppaste2> araujo pasted "pseudo-code" at http://paste.lisp.org/display/15856
13:43:23 <araujo> Can anyobody takea look at that please?
13:43:24 <Cale> tromp_: right
13:43:38 <MenTaLguY> eh, that would be a combinator, actually, by the "no free variables" definition
13:43:47 <MenTaLguY> both x and y are bound
13:43:55 <SamB> tromp_: sure it is
13:44:00 <SamB> I think.
13:44:36 <SamB> Cale's definition isn't complete, I guess ;-)
13:44:38 <ADEpt> araujo: why do you need this?
13:45:03 <araujo> ADEpt, well, im trying to map certains strings to data types.
13:45:04 <Cale> araujo: you can't quite do that
13:45:05 <tromp__> I've seen Cale's definition as well
13:45:16 <Cale> my definition is different
13:45:24 <dstatyvka> _|_kid: I mean a problems with optimization (i.e. no optimization) of real code.  When compiler has all nedded to optimize but does not.  "no inlining" is a most typical problem.
13:45:25 <ADEpt> araujo: you can have it with type forall a . String -> a, i think. Rank2, -fglasgow-exts, and all that.
13:45:28 <MenTaLguY> so, array slices?
13:45:55 <araujo> Cale, yeah, im sure i can't do something just like it is there
13:45:59 <ADEpt> araujo: no, i'm wrong. Cale: this is (in)famous monomorphism restriction at work, right?
13:46:15 <araujo> I just wanted to know if there eexisted a purely functional alternative.
13:46:24 <Cale> ADEpt: hm?
13:46:43 <SimonRC> araujo: Haskell doesn't like functions whose return types can't be predicted from other types around at the point at which they are called.
13:46:51 <Cale> araujo: you can create a tagged union type
13:47:04 <tromp__> so a closure is just a closed term; but it's normally used to describe an open term together with bindings for all free variables
13:47:56 <araujo> SimonRC, i see.. it's like dynmic typing what i try to achive here right?
13:48:07 <SamB> slice arr bounds = listArray bounds $ map (arr!) (range bounds)
13:48:15 <lisppaste2> Cale annotated #15856 with "union" at http://paste.lisp.org/display/15856#1
13:48:20 <araujo> Cale, yeah, i was thinking probably some tagged union and type class combination.
13:48:22 <SamB> and I didn't even have to use arrows!
13:48:31 <SamB> MenTaLguY: see? slices!
13:48:48 <MenTaLguY> yeah, that should work
13:49:06 <_|_kid> sorry i must have caused confusion earlier to others talking about clousres and combintor when i mentioned boost.lambda where i meant boost.bind :P
13:49:35 <SamB> MenTaLguY: it definately typechecks; I wrote it in GHCi and it has the desired type ;-)
13:50:30 <SamB> MenTaLguY: you may or may not wish to constrain the array types to be the same
13:50:35 <MenTaLguY> where does range come from?
13:51:01 <int-e> @index either
13:51:01 <lambdabot> Data.Either, Prelude
13:51:04 <MenTaLguY> the array types would need to be the same because of bounds and the element type
13:51:10 <MenTaLguY> @index range
13:51:11 <lambdabot> Data.Ix, Data.Array, Data.Array.IArray, Data.Array.Unboxed, Data.Array.
13:51:11 <lambdabot> MArray, Data.Array.IO, Data.Array.ST, Data.Array.Storable, Data.Array.
13:51:11 <lambdabot> Diff
13:51:13 <int-e> @type Data.Either.either
13:51:15 <lambdabot> forall c b a. (a -> c) -> (b -> c) -> Either a b -> c
13:51:32 <SamB> MenTaLguY: actually...
13:51:42 <SamB> the type inferred is:
13:51:43 <SamB> slice :: (Ix i, IArray a1 e, IArray a e) =>
13:51:44 <SamB>          a1 i e -> (i, i) -> a i e
13:52:03 <MenTaLguY> huh, okay
13:52:04 <SamB> and I'd say Data.Array.IArray is what you want to import
13:52:23 <_|_kid> if i was going to sort C++ i would, get rid of dumb linkers & preprocessor includes, replace templates, concepts, typeof/auto/decltype, and C++ style overloading with parametric polymorphism, type classes, type inference, nemerle style macro system :P
13:52:28 <int-e> araujo: Either is a standard union type for two types. data Either a b = Left a | Right b
13:52:36 <SamB> or a module for a specific kind of IArray
13:53:15 <SamB> _|_kid: that sounds a lot like Haskell to me
13:53:32 <SamB> only with better macros
13:53:45 <SamB> and probably not lazy evaluation
13:54:05 <_|_kid> SamB: better than abuse templates, macros, and only local inference ;)
13:54:27 <_|_kid> *abusing even
13:56:09 <MenTaLguY> probably not necessary in this case
13:56:42 <_|_kid> oh operator overloading with the haskell ability to state associativity & precedence level. Support for predicate dispatching but thats probably going to far :D
13:56:46 <SimonRC> araujo: it *is* dynamic typing, AFAICT.
14:01:01 <Cale> _|_kid: you'd end up with something that wasn't C++ anymore, so why bother calling it C++ at that point?
14:03:28 <_|_kid> Cale: doesn't have to be called C++ ;) besides like was saying earlier if you have seen all the additions/modifications proposed for C++0x you may aswell just fix it all together ;)
14:04:06 <_|_kid> Cale: it's like they don't relize other languages exist :D
14:05:21 <_|_kid> Cale: Bjarne's even claims *Concepts* are not just type classes and even claims they are better :P
14:07:57 <tromp__> i wonder if stroustrup ever studied haskell in detail
14:08:19 <_|_kid> actually i have Q, i read that for type infered polymorphis languages, ad-hoc polymorphism the C++/C#/Java way is non trivial to impossible hence languages like haskell use alternative methods such type classes
14:08:38 <_|_kid> is that true?
14:10:46 <_|_kid> if so, would that mean if a language adopted the C++/C#/Java way you would have to loose full type inference to only local inference at most
14:11:21 <_|_kid> hence C# never being fully type inferred and only local inference as in C# 3.0
14:11:38 <Philippa> you mean ad-hoc overloading, or inheritance/overriding type polymorphism?
14:13:09 <_|_kid> ad-hoc polymorphism (overloading), isn't overriding just a special case of overloading where overloading resolution (dispatch/binding) is dynamic on a single polymorphic type (sub-type polymorphism) and multimethods generlizes to multiple polymorphic type
14:14:09 <Philippa> FCVO 'just'
14:14:22 <_|_kid> FCVO?
14:14:22 <Philippa> 'just' is often a uselessly reductive term, frequently it throws away some of the info available
14:14:50 <Philippa> For Certain Values Of
14:15:47 <_|_kid> okay how about, "overriding can be seen as a special case of overloading" better? ;)
14:16:04 <Philippa> significantly
14:16:54 <Philippa> to point out the obvious (though less so with multimethods, where it's easier to just shove it all in a typeclass), you've got enough useful constraints there to start inferring useful info
14:17:18 <Philippa> what you /can't/ do is resolve the situation where there's no least upper bound of two types you're unifying
14:17:25 <Philippa> so that needs annotations straight away
14:17:32 <Philippa> (I've written a typechecker that does that much)
14:20:00 <_|_kid> i guess what meant to say is lets throw out type classes for the moment, let say haskell tries to do ah-hoc polymorphism the C#/java/C++ way would that be non-trivial with the type inference thous limiting it uses to only local inference?
14:20:49 <_|_kid> if i remember correctly i read it in TAPL book
14:21:24 <Cale> Unrestricted ad-hoc polymorphism would basically totally break inference. I'm not sure you could even do it locally in a meaningful way.
14:22:30 <_|_kid> Cale: locally it seems to be possible since C++ compilers with extensions you can do some, it's being added to C++0x and C# 3.0 is getting some
14:23:14 <Cale> Well, in order to do inference then, you have to be certain that nothing is going to come along and define further overloadings of your function
14:23:16 <_|_kid> probably Java will lag behind with some too ;)
14:23:43 <Cale> I suppose if you don't want separate compilation.
14:24:10 <Cale> Or you define some mechanism to limit the polymorphism, like all overloadings of a name have to be defined in one module
14:24:22 <Cale> (which is less flexible than typeclasses)
14:24:30 <cakoose> The C#/C++0x inference is only for local variables and only on the initializer.
14:24:55 <_|_kid> Cale: what cakoose said is what i meant by local inference ;)
14:25:00 <Cale> ah
14:25:02 <Cale> okay
14:25:09 <eivuokko> It isn't inference really.  It is just normal typing.
14:25:28 <cakoose> eivuokko: Yeah...no significant compiler changes needed.
14:25:29 <eivuokko> It is same functionality sizeof already provides.
14:25:33 <Cale> yeah, I'd hardly call that inference :)
14:25:57 <_|_kid> deduction a better term then?
14:25:59 <Cale> ad-hoc polymorphism is obviously bad
14:26:20 <Cale> There are lots of downsides to it, and not many benefits over typeclasses.
14:26:58 <cakoose> Cale: There was an interesting writeup (by SPJ, I think) that implemented ad-hoc polymorphism using type classes.
14:27:22 <Cale> Well, it's not really ad-hoc, if it's using typeclasses :)
14:27:40 <lispy> when i was learning haskell i was told that type classes were ad-hoc polymorphism
14:27:51 <_|_kid> lispy: tis
14:27:52 <cakoose> Yeah...the problem was that type classes can't be "closed" and so extra crap was getting passed around.
14:27:57 <_|_kid> lispy: controlled form i gather
14:28:28 <Cale> I don't regard typeclasses as ad-hoc polymorphism
14:28:35 <eivuokko> Why not?
14:28:40 <Cale> They're restricted parametric polymorphism.
14:29:17 <Cale> They really don't have much to do with ad-hoc polymorphism at all.
14:29:19 <cakoose> It kind of is ad-hoc polymorphism, except that the class is open instead of closed.
14:29:51 <cakoose> But yeah, maybe "ad-hoc" isn't the proper way to describe it.
14:29:54 <_|_kid> i've read countless times that is what there original purpose was to allow some form of ad-hoc polymorphism in haskell
14:30:03 <cakoose> It's closer to OO polymorphism.
14:30:26 <Cale> _|_kid: well, it was to solve the problems which ad-hoc polymorphism had been used to solve in the past
14:30:38 <Cale> but it's not to introduce ad-hoc polymorphism :)
14:30:55 <_|_kid> lets just call it overloading then :P
14:31:46 <Cale> I'm not even sure if I care for that term. Would you consider  map :: (a -> b) -> ([a] -> [b]) to be an overloaded function?
14:32:05 <Cale> It's polymorphic, sure, but there's only one implementation.
14:32:38 <Cale> I suppose that the class members are overloaded in some sense.
14:32:51 <eivuokko> Well, class constraints make haskell typeclasses sort of ad-hoc, don't they?
14:33:04 <Heffalump> yes, typeclasses are ad-hoc polymorphism
14:33:21 <Heffalump> no type class restriction => parametric polymorphism
14:33:49 <Philippa> I wouldn't say they're ad-hoc, they're constrained parametric polymorphism
14:33:57 <Cale> Philippa: I agree with you
14:34:19 <Philippa> cf System Fsub
14:34:46 <_|_kid> i see, simillar to .NET generic constraint but in static form i guess
14:36:05 <astrolabe> Doesn't the fact that different functions are used for (a::Int == b) and (a::Float == b) mean it is ad-hoc polymorphism?
14:36:11 <Cale> no
14:36:20 <Cale> it doesn't :)
14:36:20 <eivuokko> Yes?
14:36:25 <Heffalump> yes, it does.
14:36:34 <astrolabe> oooh fight!
14:36:42 <Heffalump> Philippa: it's clearly ad-hoc, you can have different implementations for different types.
14:36:50 * _|_kid causes contraverse again
14:36:50 <Heffalump> There's nothing parametric about it. It's not independent of the parameter type.
14:37:26 <Cale> the type of (==) is parametric over a constrained set of values
14:37:35 <Cale> (of types)
14:37:40 <tromp__> for normalized floats, isn't == just a matter of comparing all bits?
14:38:04 <Heffalump> the wikipedia page calls it bounded parametric polymorphism.
14:38:12 <tromp__> hmm, exactly NaN doesn't compare with another NaN
14:38:17 <Heffalump> but there's no difference between it and ad-hoc polymorphism, IMO.
14:38:21 <tromp__> exactly->actually
14:38:21 <Philippa> yeah, bounded is a better word than constrained here (and is what I meant)
14:38:38 <Philippa> the bound is the difference
14:38:57 <tromp__> it is ad-hoc in the sense of requiring different implementations
14:39:03 <Itkovian> night
14:39:22 <Philippa> You /could/, in a coercion-based implementation, implement the whole thing as a single function which happens to've been broken into multiple parts in the source, for example
14:39:24 <Heffalump> I guess the way you can write new functions might make it a bit more than ad-hoc.
14:40:20 <_|_kid> haskell wiki calls it ad-hoc poly too
14:40:23 <astrolabe> Philippa: are you implying that true 'ad-hoc p' will apply to any type?  Are there any languages where that is possible?
14:40:25 <eivuokko> It seems clearly ad hoc when the type used is exaclty known, and parametric when it is quantified.
14:40:44 <Philippa> astrolabe: I'm saying you won't have a clue which types it applies to
14:41:05 <Philippa> (at least, without context)
14:42:20 <astrolabe> But you don't know what types Ord applies to.  Scamps will be instancing it without you're knowledge.
14:42:28 <astrolabe> *your
14:42:42 <Cale> astrolabe: but when they do, they have to play by your rules
14:43:08 <Philippa> and that's an artefact of the module system, too
14:43:16 <Cale> they can't decide that (>) :: Foo -> Foo -> Integer, for example
14:43:20 <jip> is there something like type FilePath = String that is already defined somewhere?
14:43:30 <eivuokko> Prelude, yes.
14:43:48 <jip> whoah great minds think a like
14:44:47 <Heffalump> Philippa: but you have no more clue about what instances have been defined than you do about what ad-hoc overloads have been
14:45:22 <Heffalump> it's no more an artefact of the module system than this behaviour in C++ is an artefact of C++'s module system
14:45:43 <_|_kid> so aleast my thoughts have been clarified, full type inference looks virtually impossible in C# 4.0/5.0/etc for the forseeable future ;)
14:45:48 <Philippa> but what you do know is how to ask for something that has the function defined
14:46:18 <Heffalump> which is how?
14:46:32 <Philippa> the bound
14:46:50 <Heffalump> but you can do that with the name in C++
14:47:00 <Philippa> No you can't
14:47:05 <Philippa> not in C++98, not at the type level
14:47:09 <eivuokko> Which part of the C++ is the question, probably.
14:47:27 <Heffalump> you must be able to, otherwise how would the compiler work?
14:47:51 <Philippa> on the term level
14:48:11 <Heffalump> that's a meaningless distinction in this context.
14:48:31 <Heffalump> in Haskell you list all the instances of class Foo (which is not an explicit part of the Haskell type system, I might add)
14:48:39 <Cale> instance Monad m => MonadState s (StateT s m)
14:48:39 <Heffalump> in C++ you list all the overloads of function foo.
14:48:57 <_|_kid> yeah C++ templates are an odd ball, your template code can do just about any operation you want the compiler wont say anything until you actually instantiate the template with a type that doesn't support those operations.
14:48:57 <Cale> that's not a finite set of types which that instance applies to.
14:49:01 <Philippa> what do you count as "an explicit part of the Haskell type system"?
14:49:05 <Philippa> type classes are in my book
14:49:17 <Heffalump> the ability to list all members isn't
14:49:39 <Heffalump> type checking is defined by checking that a member satisfies a constraint, not looking for one that does
14:49:53 <Heffalump> (default declarations just cause a fixed list to be looked up)
14:49:56 <Cale> what's our definition of ad-hoc polymorphism here?
14:50:06 <Heffalump> that's the debate, really.
14:50:21 <Heffalump> I say that anything where you can get (semantically) different implementations at different types is ad-hoc.
14:50:22 <Philippa> I'd say that at the least typeclasses are /less/ ad-hoc than the C++ method
14:50:22 <Cale> "If the range of actual types that can be used is finite and the combinations must be specified individually prior to use, it is called ad-hoc polymorphism." is what wikipedia says
14:50:38 <Cale> which does not describe typeclasses
14:51:02 <eivuokko> Uhm, that is so restrictive.  It doesn't describe any of the C++ (typelevel) polymorphism either, does it?
14:51:10 <Heffalump> ok, then C++ templates+overloading are bounded parametric too.
14:51:24 <_|_kid> so why does haskell wiki say ad-hoc polymorphism in haskell is using type classes ^_^
14:51:24 <Cale> I was never discussing templates
14:51:26 <Heffalump> cos those give you an infinite set of types in the same way
14:51:39 <Heffalump> pure overloading is finite, though.
14:51:39 <Cale> _|_kid: because some people are obviously confused :)
14:52:12 <Philippa> C++ templates+overloading are at best a dodgy hack for bounding
14:52:32 <Philippa> now, I'll accept "dodgy hack for bounding" if you will :-)
14:52:35 <eivuokko> Soometimes, so are haskell typeclasses...
14:52:49 <_|_kid> Philippa: add Concepts is adding a patches to those hacks ;)
14:52:54 <Philippa> sometimes they're used to provide a dodgy hack for a different kind of bounding, yes
14:53:15 <Philippa> but C++ doesn't actually have a notion of bound in the first place
14:53:39 <Cale> Also, generally when ad-hoc polymorphism is applied, the specific set of types at which you're applying the overloaded function must be known at the call-site.
14:53:53 <_|_kid> until C++0x will have a kind of bounds with Concepts of-course 
14:53:55 <Philippa> Cale: that's what the bound buys you :-)
14:53:55 <Cale> Which is quite different from typeclasses
14:54:07 <Cale> Philippa: right
14:54:20 <Cale> Philippa: well, the negation of that :)
14:55:58 <Cale> With typeclasses, the constraint is explicitly named
14:56:38 * jip prods Lemmih 
14:56:38 <Heffalump> cale: not with templates
14:56:43 <jip> @seen Lemmih 
14:56:44 <lambdabot> Lemmih is in #haskell. Last spoke 7 hours, 41 minutes and 29 seconds ago.
14:57:00 <Heffalump> the only hacky thing about templates in this context is that they are not type checked until instantiation, which is grotesque.
14:57:03 <Cale> templates don't seem like ad-hoc polymorphism to me anyway
14:57:07 <int-e> Those C++ concepts look like type classes to me. The syntax is ugly (what did you expect) but I'd welcome the feature.
14:57:20 <eivuokko> It is the part of "finite" in wikipedia definition of ad-hoc polymorphism that doesn't match templates, nor class reference/pointer conversions.
14:57:25 <Philippa> Heffalump: insofar as it'll fail to typecheck once the template is instantiated if it's instantiated to the wrong thing
14:58:03 <eivuokko> Philippa, not true in all context.  There is a principle of SFINAE, substitution failure is not an error ;)
14:58:13 <Heffalump> Philippa: yes, precisely
14:58:36 <Philippa> but that's not something that's itself documented on the type level - you have to look at the terms to see that it'll fail to typecheck
14:58:52 <Philippa> there's no "hasFuncFoo" constraint being propagated
14:58:53 <_|_kid> Cale: i don't think anyone said templates where ad-hoc polyrmorphism
14:59:11 <Cale> _|_kid: it seemed to be implied by what Heffalump was saying
14:59:57 <Philippa> you can't build a non-template function that insists on being passed something that has Foo () defined on it, and you can't build a template whose parm type says it needs to be a type with Foo () defined
15:00:00 <Heffalump> if we accept that ad-hoc = finite and bounded parametric = infinite, which I'm not sure I do, then C++ overloading is ad-hoc and C++ templates+overloading give you bounded parametric
15:00:06 <PerlJam> parameterized classes and ad-hoc polymorphism are orthogonal.
15:00:09 <Heffalump> (and C++ templates without overloading give you parametric)
15:00:15 <Philippa> I didn't state bounded parametric = infinite
15:00:28 <Philippa> at best, it was implied that bounded parametric => possibly infinite
15:00:32 <Heffalump> yes, sorry.
15:00:48 <Cale> Heffalump: actually, I have a more specific distinction
15:00:51 <Philippa> one way I might put this is "C++ templates aren't kind-safe" :-)
15:00:55 <eivuokko> Philippa, what about class reference/pointer conversions? Class that has virtual Foo()?
15:00:58 <Cale> which may apply to templates
15:01:13 <Heffalump> eivuokko: that's just overloading (ad-hoc)
15:01:27 <Philippa> no, that's subtype polymorphism
15:01:47 <Cale> But basically the difference is that ad-hoc polymorphism just lets you define a function or value at multiple types, and which overloading is used is determined at the call site.
15:01:48 <eivuokko> The point wasnt what polymorphism it is, but that you can.
15:01:51 <Philippa> it may /also/ be subject to ad-hoc polymorphism in C++, but you don't need ad-hoc polymorphism to implement it
15:02:02 <eivuokko> And it is two kinds of polymorphism, subtyping and conversions arent the same thing.
15:02:07 <Philippa> at least, if I've understood eivuokko's intention there
15:02:30 <Heffalump> well, it's a specific instance of ad-hoc polymorphism, that can be resolved at runtime.
15:02:32 <Cale> Bounded parametric polymorphism gives a name to that overloading, and lets the polymorphism extend out to applications of the overloaded functions.
15:02:48 <Cale> it's still resolved at compile time.
15:02:57 <Cale> just not at the call site.
15:03:02 <Heffalump> ok, fair enough.
15:03:13 <Heffalump> (I did point out that difference at the beginning of the argument :-)
15:03:31 <_|_kid> conversion between super-sub type i'd call sub-type polymorphism, invoking virtual member functions i'd call ad-hoc polymorphism dynamic overloading
15:03:36 <Heffalump> I think C++ templates+overloading give you that, but without good kind-checking.
15:04:06 <Cale> possibly
15:04:08 <Philippa> I'd say they give you something near-equivalent to
15:04:31 <Philippa> but that the bad kind-checking means they're lacking an essential feature
15:04:48 <Heffalump> no, it just means that they're a pain.
15:04:56 <_|_kid> Philippa: thats what Concepts are kinda of meant to patch up
15:05:34 <Cale> Heffalump: can you do anything like constructor classes in C++, I can't remember the details of how it worked well enough.
15:05:38 <Cale> ?
15:05:48 <_|_kid> so i don't know if you guys know about compile-time tag/type dispatching in C++ do you?
15:05:49 <SamB> CUPS sharing is *way* too hard to configure, especially over the phone...
15:05:50 <eivuokko> Hey, that reminds me of a question I had...is haskell kind checking done at the same binding groups as inference?
15:05:51 <Heffalump> I don't think so, no.
15:05:57 <Philippa> I consider being able to tell whether something'll typecheck without having to (re)-examine the terms inside given the type to be an essential feature
15:05:59 <Philippa> YMMV
15:06:33 <Heffalump> this is degenerating into a language advocacy discussion
15:06:49 <Heffalump> _|_kid: what about it?
15:07:00 <Philippa> I'm happy to keep it a type system advocacy discussion
15:07:00 <Heffalump> eivuokko: can you give an example where it'd matter?
15:07:03 <SamB> I advocate Language X!
15:07:06 <Philippa> I still find it to be a broken type system
15:07:26 <Heffalump> yes, C++ is clearly a broken type system.
15:07:26 <eivuokko> Heffalump, nope, but there must be some bound to it, and I was just wondering if it is the same as inference.
15:07:29 <_|_kid> Heffalump: you know what i'm talking about right?
15:07:49 <Heffalump> _|_kid: do you just mean template specialisation?
15:08:17 <cakoose> I have a simple state machine, how can I use the state monad to apply it to a list of events?  I think I'm looking for (initialState -> events -> finalState)
15:08:21 <_|_kid> Heffalump: neah, it's technique and it would bring something interesting to are topic discussion if people knew it though
15:08:46 <Heffalump> I think template specialisation is equivalent to default type class members.
15:08:53 <Philippa> Heffalump: I consider the lack of a visible type-level bound to indicate lack of bounded parametric polymorphism
15:09:00 <Heffalump> (but more powerful, because default type class members all have to be listed in the instance)
15:09:11 <Philippa> is that a sufficiently concise statement for us to argue about usefully? :-)
15:09:31 <Heffalump> it's sufficiently concise, but I see little point in arguing.
15:09:36 <_|_kid> Heffalump: put it this it's like simulating partial specialization for template functions, you can't partially specialize template functions
15:09:46 <_|_kid> *put it this way it's like
15:09:47 <Heffalump> I think they both offer the same power, just C++ is more of a pain to use.
15:10:11 <Heffalump> _|_kid: really? I'm not very familiar with template specialisation.
15:10:15 <Philippa> I don't think they do once you start loading code at runtime
15:10:21 <SamB> arguing is more interesting than agreeing!
15:10:32 <SamB> unless you haven't figured out what is going on yet.
15:10:42 <Heffalump> neither language has a type safe mechanism to load code at runtime, though
15:11:14 <Philippa> assume them for a moment
15:11:23 <SamB> Neither language has such a mechanism at all ;-)
15:11:24 <_|_kid> Heffalump: a concial example is std::copy and iterator concepts, if the iterator is a model of the random accessible iterator Concept and the value type is POD-type you can dispatch at compile-time to use memmove/cpy
15:11:31 <Philippa> (hs-plugins + Dynamic good enough for you? Similarly an equivalent mechanism for C++)
15:11:52 <_|_kid> Heffalump: that is using tag dispatching
15:11:53 <Heffalump> no, hs-plugins + Dynamic isn't good enough for type-safety, that's the point.
15:11:59 <eivuokko> Philippa, there exists plenty of those.
15:12:13 <SamB> Heffalump: why isn't it?
15:12:15 <Heffalump> But if it was, the equivalent mechanism for C++ would have to include the entire template instantation mechanism, in which case you'd get exactly the same level of type-safety.
15:12:28 <Heffalump> SamB: because anything can lie about the types.
15:12:40 <SamB> Heffalump: lets just say that lying isn't allowed ;-)
15:12:43 <Heffalump> contrast with Java reflection, where loaded things actually get verified.
15:12:56 <eivuokko> Or .net
15:12:58 <Philippa> okay, a from-source-only hs-plugins s.t. we've typechecked it ourselves
15:13:10 <Heffalump> ok, so then we get the same for C++
15:13:12 <eivuokko> The diffrence to compiling it ourself from C++?
15:13:13 <SamB> lets say that there are no explicit instances of Typeable?
15:13:17 <Heffalump> and we can do exactly the same checks
15:13:34 <SamB> that they are all derived?
15:13:54 <_|_kid> okay so next Q after the whole debate about ad-hoc polymorphism ;)
15:13:54 <Heffalump> SamB: you can still lie with binary code.
15:14:01 <jip> how can i multiply a Double by an Int?
15:14:05 <SamB> Heffalump: but how?
15:14:05 <Philippa> except that to do those checks you have to go build additional code as specced by your already-running program. How do you handle it when two pieces of loaded code/values are being hooked up?
15:14:34 <Heffalump> Philippa: how do you handle it in Haskell?
15:14:38 <SamB> Heffalump: but the interface files wouldn't match!
15:14:47 <Heffalump> SamB: you can fake them..
15:14:50 <eivuokko> Philippa, at that point using type classes and dictionaries vs C++ classes vs virtual tables..big deal?
15:15:04 <Philippa> eivuokko: templates, that's the deal
15:15:04 <Heffalump> runtime loading and static type systems don't really agree with each other in any way, unless you go the verification route.
15:15:28 <Heffalump> you could implement templates by dictionary-passing and indirection as you do in Haskell.
15:15:28 <SamB> so Haskell is still more fun!
15:15:34 <Philippa> you don't know which templates one piece of code's going to want to instantiate on classes from the other
15:15:50 <Heffalump> It's equivalent. But C++ has some different implementation expectations.
15:15:52 <eivuokko> You can't instantiate new classes on haskell either..
15:15:57 <_|_kid> Why doesn't OCaml adopt type classes, i've read it's require great efforts but still it's been ages
15:16:02 <eivuokko> Err, instance restrictions
15:16:05 <Philippa> eivuokko: they mean completely difference things
15:16:17 <Heffalump> eivuokko: you probably can in theory, since type classes are normally implemented by dictionary passing.
15:16:27 <eivuokko> Uhm.
15:16:28 <SamB> _|_kid: I heard some ML was going to have Monads
15:16:29 * Philippa nods
15:16:30 <Heffalump> But it all comes down to the same expressive power.
15:16:37 <Philippa> you just need some sufficiently unique token to throw around
15:17:09 <Heffalump> A normal C++ implementation uses template instantiation. A normal Haskell implementation uses dictionary passing. Either could use the other.
15:17:10 <_|_kid> SamB: you can monads in Scheme
15:17:23 <_|_kid> *you can have
15:17:29 <Philippa> er, no. C++ *has* to do template instantiation to some extent, or it can't typecheck
15:17:39 <int-e> Heffalump: with templates you wouldn't know which dictionary to pass
15:17:42 <SamB> okay, so lets say we replace machine code with the last type-safe IR
15:17:56 <Heffalump> int-e: yes you would, because you know the concrete type at the original call site
15:17:59 <tic> Philippa, how come?
15:17:59 <int-e> Heffalump: xyzzy<int> can provide a completely different interface from xyzzy<double>, if you like.
15:18:27 <Heffalump> Philippa: it can do that just with the function signatures
15:19:06 <Philippa> true
15:19:14 <eivuokko> Philippa, C++ template instantiation is the same as using haskell instance that has class constraints (at the callsite, in this context).  Neither can be used in dynamic loading anyway I see, except compiling some fresh code.
15:19:20 <Heffalump> in the end it'll come down to inferring a class from the signatures.
15:19:23 <Philippa> I have to admit, the biggest problem with C++ and templates in this situation is the ease of DoSing the host code
15:19:46 <eivuokko> Anything binary can do that?
15:19:51 <eivuokko> And btw
15:19:57 <Philippa> yeah, but the C++ can DoS the typechecker
15:20:02 <int-e> Heffalump: so ... basically you'd build the required dictionary for each call site? that could work.
15:20:03 <eivuokko> There is an implementation of .Net where it is more safe than given here.
15:20:10 <eivuokko> Because .net clr can be verified.
15:20:30 <SamB> Philippa: how do you know you can't DoS the GHC typechecker? you could until joelr got them to fix it, anyways...
15:20:56 <Philippa> you definitely can with the right options on
15:20:59 <SamB> it doesn't have to be Turing complete to allow DoS attacks
15:21:00 <musasabi> and there are still ways...
15:21:05 <_|_kid> it's funny how long this discussion has been going on from my little Q on ad-hoc polymorphism ^_^
15:21:12 <SamB> I don't think it even required special options
15:21:12 <Heffalump> int-e: right
15:21:20 <Heffalump> Philippa: I'm sure Haskell can DoS the type checker if you try.
15:21:36 <Philippa> Heffalump: GHC-Haskell or Haskell98, for "non-terminating" values of DoS?
15:21:41 <Heffalump> some tricks with polymorphic recursion.
15:21:41 <musasabi> Heffalump: it is quite simple. Use type level numbers and calculate pi.
15:21:49 <SamB> but, can you compute factorial in the type system without overlapping and undecidable instances?
15:22:01 <Philippa> you can chew up a lot of time just with nested let statements and H-M
15:22:03 <Heffalump> Haskell98, but probably only complexity blowup.
15:22:07 <SamB> or Pi?
15:22:19 <Philippa> I don't /want/ to :-)
15:22:35 <musasabi> SamB: I haven't tried without extensions.
15:22:42 * int-e has an idea for doing ad-hoc polymorphism in GHC: {-# RULE "foo/1" foo_poly = foo1 #-} {-# RULE "foo/2" foo_poly = foo2 #-} ...
15:22:47 <_|_kid> from what i understand templates can simulate a limited form depedant typing just with inferenc
15:22:57 <SamB> anyway, complexity blowup is sufficient to exhaust RAM
15:23:03 <_|_kid> *without inference
15:23:09 <Philippa> templates arguably do give you dependant types
15:23:18 <Philippa> the parms don't have to be types at all
15:23:22 <int-e> (I think that works because rules are only applied if the types can match)
15:23:31 <_|_kid> Phillippa: that was kinda of my point ;)
15:23:33 <SamB> did you see that boost::spirit thingy?
15:23:34 <Philippa> template <int size> class IntArray...
15:23:45 <eivuokko> SamB, what about it?
15:23:56 <eivuokko> SamB, if you ask me, better primitives thant Parsec... :)
15:23:56 <Philippa> most of the classic dependantly-typed languages don't do inference anyway
15:24:00 <SamB> Philippa: but, sadly, no strings...
15:24:06 <Heffalump> anyway, back in a while.
15:24:07 <SamB> eivuokko: oh?
15:24:22 <_|_kid> yes boost::spirit is DSEL in C++ (ganted not a great one but great for C++)
15:24:45 <eivuokko> SamB, Yeah, Parsec could (imo) take some leaps forward.  Boost:spirit has very active devel-team.
15:24:53 <SamB> _|_kid: it looks pretty nice to me
15:25:07 <Philippa> the biggest thing Parsec needs IMO is better interaction with other monads
15:25:11 <SamB> _|_kid: I mean, this is C++ we are talking about
15:25:12 <_|_kid> SamB: as i said "it's great for C++ "
15:25:14 <eivuokko> SamB, boost:spirit loses, naturally, because no proper first class function-as-value in C++.
15:25:30 <eivuokko> Philippa, ParserT ?
15:25:40 <Philippa> eivuokko: that kinda thing, yeah
15:25:55 <SamB> eivuokko: what about the boost:: closure thingies?
15:26:00 <int-e> _|_kid: DSEL?
15:26:13 <eivuokko> Philippa, the types woudl sure look horrifying tho!  So many parameters.
15:26:25 <_|_kid> SamB: there going to be replaced by proper scoped variables, check boost::phoenix
15:26:31 <eivuokko> SamB, it isn't the same as language level lambda, trust me, it never is :-(
15:26:58 <_|_kid> int-e: Domain specific embedded language
15:27:17 <eivuokko> SamB, or what I call here lambda, is in C++ expression templates that require significant amount of auxliary code vs functions-as-valus in haskell.
15:27:31 <int-e> thanks
15:28:07 <_|_kid> int-e: it gives you a EBNF *like* grammer written directly C++
15:28:52 <Philippa> eivuokko: I can cope with that. Rather big types than no code at all
15:29:12 <Philippa> (and at least you can use type synonyms to keep the written types smaller)
15:29:18 <_|_kid> writing DSELs in C++ amounts to writing expression templates, overloading operators, and some template (and/or macro) metaprogramming
15:30:33 <_|_kid> it's no where near the elegance of haskell DSELs of-course ;)
15:30:45 <eivuokko> Philippa, do you know why it hasn't been done yet?  Because optimising the PArsec primitives is a lot of work or what?
15:31:07 <Philippa> There might be some awkward laziness issues
15:31:15 <eivuokko> Hmm
15:31:23 <Philippa> failing that? Because the original authors haven't done it and nobody else feels it's their place
15:31:30 <_|_kid> what about doing a mix with template haskell?
15:31:48 <eivuokko> Philippa, haskell community is so wierd...why not do it for fun?
15:32:14 <jip> how do i multiply a Double by an Int?
15:32:37 <_|_kid> jip: you'll need to use conversion function in prelude
15:32:39 <Philippa> well yeah, but if it's for fun then why release it?
15:32:46 <_|_kid> jip: and then do the multiplication
15:33:15 <eivuokko> Philippa, as I said.  Wierd if showing off your code isn't fun? :)
15:33:40 <jip> > (3 :: Int) * (2.5 :: Double)
15:33:42 <lambdabot> Couldn't match `Int' against `Double'
15:33:50 <tromp> use fromIntegral
15:33:57 <jip> > fromIntegral (3 :: Int) * (2.5 :: Double)
15:33:59 <lambdabot> 7.5
15:34:14 <jip> thanks
15:34:15 <_|_kid> jip: justas said before ^_^
15:35:16 <_|_kid> Why doesn't OCaml adopt type classes, i've read it's require great efforts but still it's been ages?
15:35:39 <Philippa> eivuokko: it's potentially embarassing, no?
15:35:51 <_|_kid> i can't imagine SML doing so
15:36:46 <eivuokko> Philippa, yeah, it isn't I don't understand.  It just seems to me a bit wierd, as Parsec seems to have been really stable for atleast few years.
15:37:20 <Philippa> I think there might be some awkwardness between typeclasses and structural subtyping
15:37:30 <Philippa> a clean design'd take both into account at the start, sort of thing
15:38:20 <_|_kid> i dislike the thought of +\+. and overloading in general
15:38:32 <_|_kid> well the ablitily not being able to
15:39:50 <_|_kid> what does it mean *structural* subtyping i get the sub-type polymorphism, how does that differ?
15:41:49 <jip> i have a Ptr... how can i "dereference" it?
15:42:10 <Igloo> peek
15:42:13 <eivuokko> Foreign.Storable
15:42:14 <ihope> Wherezee identity monad?
15:42:43 <astrolabe> control.monad?
15:43:56 <tromp> Control.Monad.Identity
15:44:14 <jip> @type peek
15:44:15 <lambdabot> Not in scope: `peek'
15:44:31 <eivuokko> @type Foreign.peek
15:44:32 <lambdabot> forall a. (Foreign.Storable.Storable a) => GHC.Ptr.Ptr a -> IO a
15:44:59 <_|_kid> Philippa: what do you mean by structural subtyping, is that any different from typical OO languages?
15:45:50 <Philippa> _|_kid: yup. Typical OO languages don't let you say "anything with a field named foo of type bar"
15:47:29 <_|_kid> what are polymorphic variants, do they just allow you to add data constructors later on, is that all?
15:49:06 <Philippa> I *think* (but I'm not an ocaml user and could be wrong) that you get "any variant with construcors..."
15:50:18 <_|_kid> sorry i don't think i understand that sentance :P
15:52:00 <_|_kid> anyways i have gtg, seeya all
15:54:14 <jip> how do i convert a Word8 to an Int?
15:54:36 <musasabi> fromIntegral ?
15:54:44 <musasabi> and fromEnum
15:55:54 <int-e> \W# x -> I# x ... *ducks*
15:56:56 <ihope> > fromEnum
15:56:57 <lambdabot>  add an instance declaration for (Show (a -> Int))
15:57:01 <ihope> > fromEnum Nothing
15:57:02 <lambdabot>  add an instance declaration for (Enum (Maybe a))
15:57:02 <lambdabot>   In the definition of `reb': reb = fromEnum Nothing
15:57:02 <lambdabot>   In the definition of `v': v = let reb = fromEnum Nothing in take 2048 (
15:57:02 <lambdabot> show reb)
15:57:04 <tromp> fromIntegral works
15:57:15 <musasabi> > fromEnum (1 :: Word8) :: Int
15:57:17 <lambdabot> 1
15:57:24 <musasabi> > fromIntegral (1 :: Word8) :: Int
15:57:26 <lambdabot> 1
15:58:01 <ihope> < length "Llanfairpwllgwyngyllgogerychwyrndrobwllllantysiliogogoggoch"
15:58:01 <jip> @type fromIntegral (1 :: Word8)
15:58:03 <lambdabot> Not in scope: type constructor or class `Word8'
15:58:22 <tromp> > fromEnum (-1::Int) :: Int8
15:58:23 <lambdabot> Couldn't match `Int8' against `Int'
15:58:33 <tromp> > fromEnum (-1::Int8) :: Int
15:58:35 <lambdabot> -1
15:58:36 <ihope> > length "Llanfairpwllgwyngyllgogerychwyrndrobwllllantysiliogogoggoch"
15:58:38 <lambdabot> 59
15:58:40 <ihope> > length "Llanfairpwllgwyngyllgogerychwyrndrobwllllantysiliogogogoch"
15:58:41 <lambdabot> 58
15:59:08 <tromp> 1st has an extra g
15:59:14 <ihope> Yep.
16:04:05 <ihope> I was once a treehouse...
16:05:16 <ihope> I lived in a cake!
16:05:30 <Cale> http://llanfairpwllgwyngyllgogerychwyrndrobwllllantysiliogogogoch.com/
16:08:34 <SamB> is ihope drunk?
16:09:21 <Cale> Did you ever live in a drum?
16:10:43 <Cale> http://globalia.net/donlope/fz/lyrics/Lumpy_Gravy.html#Nostalgia
16:11:05 <jip> man fp can be annoying sometimes :'(
16:11:13 <Cale> jip: what's troubling you?
16:11:22 <ihope> I swear to drunk I'm not god!
16:11:32 <ihope> http://www.albinoblacksheep.com/flash/llama.php
16:11:51 <jip> trying to port some opengl code from python to haskell... in python the code is short and elegant but my haskell version is quickly getting complicated and ugly :(
16:12:10 <Cale> jip: what is it that's not translating well?
16:12:29 <Cale> You can usually expect direct translations to be difficult
16:12:48 <jip> yeah i guess i need to just think about this a little bit more
16:13:23 <jip> Cale: btw did you see the screenshot of my yampa tetris?
16:13:25 <Cale> If there's a particular control structure you need, you might be able write it.
16:13:29 <Cale> no, I haven't
16:13:32 <jip> http://img220.imageshack.us/img220/5016/hstetris0014es.png
16:13:47 <dons> moin
16:13:47 <ihope> > length "Krungthepmahanakornamornratanakosinmahintarayutthayamahadilokphopnopparatrajathaniburiromudomrajaniwesmahasatharnamornphimarnavatarnsathitsakkattiyavisanukamprasit"
16:13:49 <lambdabot> 163
16:13:58 <jip> dons: !
16:14:50 <Cale> jip: nice start, though it doesn't look like it would be very challenging yet if the clearing rule is the usual one :)
16:15:18 <Cale> or is it a 'line up n of the same colour' one?
16:16:06 <jip> it's supposed to be regular tetris... but so far i have only got to the stage of it being single-brick-tetris :)
16:16:58 <Cale> still looks like a nice start -- what gui library are you using? There are some flashy cairo bindings now :)
16:17:25 <jip> it uses opengl.... but i've now put this tetris on hold and i'm going for a more ambitious 3d car racing game
16:18:12 <dons> Lemmih, pong
16:29:46 <tromp> l
16:49:15 <Philippa> Cale: did you ever see a (spoof) game called Cratemaster?
16:49:26 <Philippa> it was single-block tetris with three columns
16:49:26 <Cale> nope
16:49:28 <Cale> heh
16:49:36 <Philippa> only it got so damn fast it actually took some skill to play
16:50:50 <Cale> http://www.theonion.com/content/node/43441 :)
16:55:32 <SamB> jip: is car racing really more ambitious than tetris?
16:56:26 <MarcWeber> I'm trying to compile the example of a parser given in the happy manual. Invoking happy mygrammarfile.y causes the error " ../happy/src/HappyTemplate: openFile: does not exist". What is missing?
16:58:19 <sethk> MarcWeber, well, the short answer is, of course, that the file doesn't exist
16:58:39 <MarcWeber> May I rephrase my question? How to make it work?
16:58:56 <MarcWeber> Haven't used happy before.
16:59:05 <jip> SamB: i believe it is
16:59:20 <sethk> MarcWeber, I've not used happy for several months, I'm trying to remember the layout of installed files.
16:59:35 <sethk> MarcWeber, note that it's a relative path, which suggests that the current directory is wrong
16:59:53 <sethk> MarcWeber, or a permissions problem
17:00:00 <SamB> jip: what kind of design are you using?
17:00:04 <MarcWeber> I'm on windows.. ;-)
17:00:08 <jip> SamB: design of what?
17:00:31 <SamB> jip: er, like, are you using Yampa?
17:00:37 <jip> SamB: of course :)
17:01:17 <SamB> like, why does Yampa not want to build?
17:01:43 <MarcWeber> sethk: Ok I'll just pass the directory as parameter.. Thanks
17:02:19 <jip> SamB: it defines some arrow combinators that conflict with the ones that have been added to ghc
17:02:40 <SamB> jip: why is there no patch for this on the Yampa page?
17:03:08 <jip> SamB: yampa page seems to be dead :(
17:03:17 <SamB> ah
17:03:25 <SamB> someone should liberate it!
17:04:31 <jip> yeah, someone should put it on sourceforge :)
17:04:51 <SamB> no, I meant the page
17:05:00 <SamB> it is on haskell.org after all
17:07:59 <SamB> okay, so I commented out all the stuff about >>^, ^<<, ^>>, <<^ and it built. that is nice.
17:08:18 <jip> yep
17:09:48 <SamB> but, Yampa still needs someone to look after it.
17:10:38 <jip> yep
17:10:56 <SamB> okay, so how do you build the examples?
17:11:32 <jip> i have not succeeded
17:11:53 <jip> but do you have Lemmih's SDL bindings installed?
17:12:09 <SamB> I'm stuck on the "arrowp" thing
17:12:31 <jip> ghc -fglasgow-exts -farrows
17:16:15 * palomer invents the paskell programming language, simply to make things even harder to understand
17:20:17 <SamB> palomer: you better make it interesting enough that people will want to talk about it, or it won't help
17:20:29 * araujo has proved Haskell is purely functional during these last 2 days
17:20:54 <dons> proved it?
17:21:08 <araujo> palomer, Do a Purely Functional Malbolge :-]
17:21:13 <araujo> dons, hiya!
17:21:23 <Heffalump> did you start with the semantics of the hardware and verify the GHC implementation from that?
17:21:30 <araujo> dons, yeah, ive been trying to break the functional approach :-]
17:21:36 <SamB> someone needs to maintain Yampa
17:21:40 <SamB> any volunteers?
17:21:47 <araujo> @where yampa
17:21:47 <lambdabot> http://www.haskell.org/yampa/
17:21:59 <dons> Heffalump, ;) meanie
17:22:01 <SamB> araujo: it doesn't like to actually build, though
17:22:32 <SamB> it *really* doesn't want to build examples.
17:23:59 <Heffalump> dons: should just be a simple extension of http://pauillac.inria.fr/~xleroy/compcert-backend/ ;-)
17:24:34 <JKnecht> looks like it (yampa) hasn't been maintained since '04.
17:25:00 <Heffalump> that's a bit odd, Henrik Nilsson had a paper about it a few months ago
17:25:03 <SamB> so, who has root on haskell.org (in order to takeover the web page)
17:27:00 <SamB> hmm, the SpaceInvaders example doesn't like my HGL
17:27:53 <jip> *** Exception: Error in array index
17:28:01 <jip> how can i find out where in my code that happens?
17:28:17 <SamB> well, I'd search for !
17:28:38 <jip> but i have a lot of ! :(
17:28:42 <Cale> also, make sure that in calls to array/listArray, you specify the indices correctly
17:28:47 <palomer> @type (!)
17:28:48 <lambdabot> Not in scope: `!'
17:28:52 <palomer> @hoogle (!)
17:28:53 <lambdabot> No matches found
17:28:57 <palomer> @hoogle !
17:28:58 <lambdabot> Data.Array.IArray.(!) :: (IArray a e, Ix i) => a i e -> i -> e
17:28:58 <lambdabot> Data.Array.(!) :: Ix i => Array i e -> i -> e
17:28:58 <lambdabot> Data.IntMap.(!) :: IntMap a -> Key -> a
17:29:08 <SamB> hoogle is wierd like that, isn't it?
17:29:10 <Cale> If you have a 2d array, you pass something of the form ((xmin, ymin), (xmax, ymax))
17:29:35 <palomer> Monad should be renamed to Computation
17:29:44 <palomer> infact, all type name should be pluralized
17:29:55 <palomer> s/name/names
17:30:02 <palomer> s/infact/in fact
17:30:03 <Cale> I don't think so, monads aren't just computations
17:30:08 <Cale> or types of computation
17:30:12 <Cale> they're more than that
17:30:14 <SamB> palomer: you's crazy.
17:30:20 <palomer> Cale: like what?
17:30:24 <jip> but how can i get ghc to tell me exactly on what line of the source file the error happens?
17:30:26 <SamB> is Nothing a computation?
17:30:33 <palomer> sure
17:30:38 <palomer> it computes nothing
17:30:42 <Cale> They're also like containers
17:30:44 <SamB> jip: build with profiling and --auto-all
17:30:49 <Cale> of a certain type
17:30:55 <SamB> then invoke with +RTS --help
17:31:07 <palomer> the List monad represents computation of many things
17:31:27 <SamB> palomer: you are crazy, I tell you.
17:31:42 <palomer> someone give me an example of a Monad which does not represent a computation in any way
17:31:43 <Cale> sure, but you don't *have* to think about it like that
17:31:44 <SamB> do you want us to rename our other classes too?
17:31:52 <Cale> there's a benefit to thinking about them like containers
17:32:06 <jip> don't all the libraries that i use have to be built with profiling if i want to build with profiling?
17:32:09 <SamB> ComputationState? ComputationReader? ComputationPlus?
17:32:19 <Cale> Computations are dynamic and hard to pin down in your head.
17:32:20 <cakoose> palomer: A monad is a computation that has certain properties.  There are other computations besides monads.
17:32:25 <Cale> Containers are static.
17:32:26 <SamB> jip: maaaaybeee
17:32:28 <palomer> well, no, the names would be descriptive
17:32:59 <SamB> palomer: descriptive! but then NOBODY would EVER read the DOCUMENTATION!
17:33:05 <Philippa> palomer: if by Monad you mean an instance of the typeclass monad, I guess you /could/ say the (uninterpreted) AST you saw in my code the other day
17:33:05 <Cale> Containers are a much more concrete analogy, and one which is very important to the understanding of monads.
17:33:24 <Philippa> (that is, not-a-computation)
17:33:27 <palomer> Philippa: I could say "the AST you saw in my code the other day" ?
17:33:51 <Philippa> but it just represents an uninterpreted one, so I'm not sure how much that buys you
17:34:10 <palomer> Cale: I could think of a List b as a computation which returns a list of b's
17:34:16 <Philippa> the underlying category the monad's based on is one of computations, so you're kind of stuck with it
17:34:33 <Cale> palomer: you could, but sometimes that's an inconvenient way to view it.
17:34:46 <cakoose> palomer: But what about functions.  How are they not computations?
17:35:03 <palomer> they aren't
17:35:14 <Cale> they are -- that's the reader monad
17:35:40 <palomer> function definitions simply give specifications written in the language of term equalities (plus some mumbo jumbo)
17:35:47 <Philippa> they're computations more generally, but we tend not to count them so that "returns a computation" and "is a computation" are useful
17:36:08 <Philippa> they all desugar to lambda calculus + let + case...
17:36:18 * palomer petitions Monad to be renamed to Computations and all type names to be pluralized !
17:36:27 <palomer> Cale: when is it inconvenient?
17:36:38 * Philippa petitions palomer to stop fucking around with mathematical terminology
17:36:44 <cakoose> palomar: What would you rename 'arrow' to?
17:36:46 <SamB> @index RGB
17:36:47 <lambdabot> Graphics.HGL.Draw.Text, Graphics.HGL.Draw, Graphics.HGL.Core, Graphics.
17:36:47 <lambdabot> HGL, Graphics.HGL.Draw.Text, Graphics.HGL.Draw, Graphics.HGL.Core,
17:36:47 <lambdabot> Graphics.HGL, Graphics.Rendering.OpenGL.GL.PixelRectangles.Rasterization,
17:36:47 <lambdabot> Graphics.Rendering.OpenGL.GL.PixelRectangles, Graphics.Rendering.OpenGL.
17:36:47 <lambdabot> GL, Graphics.Rendering.OpenGL, Graphics.UI.GLUT
17:36:48 <Philippa> Computations is overly generic, Arrows describe families of computations too
17:36:55 * palomer petitions the haskell community to name things more intuitively 
17:37:11 <Philippa> go code in perl :-)
17:37:19 <palomer> aren't arrows going to replace monads?
17:37:21 <Cale> palomer: Computations are not very concrete to most people.
17:37:27 <SamB> palomer: no!
17:37:28 <palomer> Cale: and Monad is?
17:37:30 <JKnecht> or Smalltalk.
17:37:36 <Cale> palomer: Containers are.
17:37:47 <Philippa> Monad had a lot of meaning at the point where monads became commonly used in haskell
17:38:01 <palomer> Cale: yes, but container is often unsuitable
17:38:08 <dons> you have some strong views, don't you palomer ;)
17:38:10 <palomer> as a description
17:38:22 <palomer> yes, yes I do
17:38:28 <Cale> palomer: I've found it fairly suitable for all the monads I've run into.
17:38:32 <cakoose> palomer: Well, the term "Monad" refers to a computation that satisfies a specific set of rules.  Someone needs to find a good name for those rules.
17:38:44 <SamB> container is really more of an analogy
17:38:50 <palomer> Cale: but, for examples, computations can fail, so fail is a valid member of Computation, whereas containers cannot
17:38:55 <SamB> or an example
17:38:59 <palomer> s/examples/example
17:39:11 <SamB> palomer: sure they can
17:39:18 <palomer> a container can fail?
17:39:20 <SamB> what if you throw a stick of dynamite in a crate?
17:39:21 <Philippa> cakoose: I can give a good single-sentance description, but that's not good enough ("has higher-order computations, has a notion of dependancy that may be an order")
17:39:24 <Cale> palomer: containers can be empty
17:39:30 <palomer> but that's not failing!
17:39:35 <Cale> it's the same thing here
17:39:41 <SamB> palomer: sure it is
17:39:57 <SamB> looky here:
17:40:05 <cakoose> Philippa: Yeah...  So might as well call it something.  I'm sure someone who has taken the time to understand the rules has no problem using an arbitrary name to refer to them.
17:40:09 <SamB> > fail "ack!" :: Maybe ()
17:40:11 <lambdabot> Nothing
17:40:22 <palomer> see, I find that code unredable
17:40:28 <Philippa> quite. It's just a noun, guys
17:40:43 <palomer> and redability should be a priority!
17:40:57 <SamB> palomer: why do you think we have otherwise?
17:41:05 <palomer> otherwise what?
17:41:05 <Philippa> oh fuck off. Really, the only reason you find it unreadable is you're not familiar with it
17:41:19 <Philippa> if you know :: is type annotation it's simplicity itself to read off
17:41:34 <SamB> monads take getting used to, lets not make it harder by using words that sound like they have meaning ;-)
17:41:34 <palomer> Philippa: you find writing { fail "ack!" } when using a container readable?
17:41:52 <Philippa> I don't view monads as containers :-)
17:42:00 <palomer> yes, because they're computations!
17:42:02 <Philippa> I do have some quibbles with fail taking a string parm
17:42:10 <eivuokko> Some? ;)
17:42:17 <cakoose> palomer: Yes... Monad -> Computation, but the implication doesn't go both ways.
17:42:19 <Philippa> but that aside, it's as readable as any other piece of code
17:42:27 <cakoose> palomer: That's why "Computation" would be an inappropriate term.
17:42:30 <Philippa> cakoose: Value of monadic type -> Computation...
17:42:32 <palomer> but it's how haskellers generally represent computations
17:42:46 <SamB> Philippa: it is to aid debuggability when your monad can handle error messages ;-)
17:42:52 <palomer> if not, let's call Arrow Computations, and have monad be a subclass or something
17:42:57 <Philippa> that's because they represent a particularly common class of computations - ones which include haskell, may be higher-order and may have an ordering to them
17:43:04 <Philippa> doesn't work
17:43:14 <palomer> because?
17:43:14 <Philippa> there're more general classes than Arrow
17:43:18 <Philippa> (for example, Functor)
17:43:49 <palomer> ok
17:43:51 <Philippa> you end up defining categories, categories-with-return, all sorts of stuff
17:43:54 <palomer> have Arrow be a subclass of Functor
17:44:07 <palomer> wait, functor is overly general
17:44:23 <palomer> we should have a Computation typeclass.
17:44:24 <Philippa> and most of these things /aren't used very often/ and don't necessarily get used as computations per se when they are
17:44:33 <Philippa> the majority of instances of Functor are data structures
17:44:45 <Philippa> right, is that a category or a category-with-lift?
17:44:53 <SamB> @index Event
17:44:54 <lambdabot> Graphics.HGL.Window, Graphics.HGL.Core, Graphics.HGL, Graphics.SOE
17:45:12 <Philippa> by the time you've done all this, you end up implementing half of category theory
17:45:30 <ncalexan> Philippa: that might be a Good Thing.
17:45:38 <Philippa> which may have some uses if you want to do some serious metawankery, but for the most part is total overkill
17:45:55 <Philippa> ncalexan: perhaps. I'm not sure it's a good thing for Haskell though
17:46:02 * ncalexan is always up for 'serious metawankery'
17:46:10 * Philippa throws lisp at ncalexan
17:46:35 <ncalexan> Right.
17:46:40 <SamB> Philippa: that sounds pornographic
17:47:00 <SamB> in a deeply disturbing, recursive way
17:48:26 <SamB> did I scare everyone away or have I just been disconnected?
17:48:36 <eivuokko> You're seen.
17:49:26 <SamB> am I *that* ugly?
17:50:01 <SamB> w00t, I've got space invaders to compile ;-)
17:56:28 <SamB> I can't figure out how to use that space invaders...
17:58:36 <araujo> SamB, youve got it!?
17:58:37 <shredme> must go TODAY.  MESSAGE ME ONLY ON MSN AT MCSLTD2@HOTMAIL.COM, AIM AT OGD443 or YAHOO at MCSLTD2 IF INTERESTED! 1 alienware desktop computer price $550, one alienware area51-m 5700 notebook price $550.  prices include sameday shipping, case, wireless router.
17:58:59 <araujo> uh?
17:59:13 <SamB> oh, I think it is one of those stupid screen savers
17:59:15 <Heffalump> advert spam.
17:59:25 <SamB> note again!
17:59:29 <SamB> er, not again.
17:59:49 <lispy> if someone starts spamming, lilo will do something else stupid...
18:00:10 <Heffalump> lispy: hasn't the spamming been going on for a while?
18:00:32 <SamB> oh, you use the mouse actually
18:00:33 <lispy> Heffalump: hasn't lilo's stupid ideas been plauging us for a while :)
18:00:41 <Heffalump> fair point ;-)
18:00:47 <Heffalump> has anything got worse lately?
18:01:02 <lispy> i'm still miffed about losing /msg
18:01:04 <araujo> Some of them are (admittely) "weirds".
18:01:19 <araujo> But i think that to have such a big net free of spams is something very good.
18:01:53 <lispy> i never received spam sent as a /msg
18:02:00 <lispy> did you?
18:02:14 <araujo> Well, if you don't consider lilo global msg'ing you from time to time as spam :-]
18:02:23 <araujo> lispy, yes, i have had
18:02:37 <araujo> Though not too much lately.
18:02:45 <araujo> Probably 2-3 times last year
18:02:49 <lispy> well, now you have to be logged in
18:03:17 <Philippa> see, global messaging I don't mind. The risk I take in mentioning #brits, OTOH...
18:03:56 <araujo> I don't visit other irc networks like i used to, but i remenber all the bunch of spam i used to have with other (even smaller) irc networks before.
18:04:16 <Heffalump> Philippa: lol
18:04:21 <Heffalump> did that ever recover?
18:04:27 <Philippa> no idea. You wanna join and find out?
18:04:33 <dons> musasabi, an entry for the (new) `recursive' benchmark: http://www.haskell.org/hawiki/RecursiveEntry. Want to commit it?
18:04:35 <Heffalump> you think it's *still* juped?
18:04:47 <Philippa> a quick /mode suggests it's ded
18:04:49 <Philippa> *dead
18:04:55 <araujo> we actually have started getting this spam problem in freenode just from a couple of years 
18:05:06 <Philippa> OTOH, I wouldn't be surprised if nobody could be arsed to tell chanserv to stop doing it
18:05:11 <araujo> I don't remenber any spam message when it was openprojects
18:05:47 <Heffalump> it's empty, ChanServ sets it +tcns and takes away my ops when I join
18:05:52 <lispy> araujo: (playing devil's advocate) but maybe that is because freenode now has the critical mass?
18:06:11 <Heffalump> presumably it migrated to OFTC?
18:06:21 <araujo> lispy, yes, it is around 60% bigger than in those days i talk about.
18:06:32 <lispy> only channel i go to on oftc is #monotone, and i've not seen spam there
18:07:00 <Cale> btw, the phone number of that annoying alienware spammer is apparently 403-472-2269
18:07:03 <araujo> Well, oftc is smaller than freenode.
18:07:16 <Cale> :)
18:07:25 <lispy> Cale: hmm..i get free calling in the US....
18:07:27 <araujo> lispy, Though size usually doesn't care, you can find very small irc networks out there with bunch of spams.
18:07:27 <Heffalump> Cale: in which country?
18:07:38 <Heffalump> </challenge-American-centric-views> :-)
18:07:44 <araujo> length....
18:07:58 <Heffalump> how'd you get the number, OOI?
18:08:15 <lispy> Heffalump: oh, you're canadian? ;)
18:08:22 <dons> hehe
18:08:24 <Philippa> Heffalump: I assume so, I rather thought it was the reason for OFTC's existance
18:08:26 <dons> bad lispy
18:08:30 <Philippa> I know #nott went there
18:08:56 <Heffalump> oh well, at least he didn't accuse me of being a convict.
18:09:04 <lispy> heh
18:09:17 <Cale> everyone send him lots of flak on MSN/Yahoo
18:09:25 <Heffalump> I did say American-centric, not USA-centric, anyway. Why are you assuming America = USA? ;-)
18:09:27 <Cale> he seems pretty quick to anger :)
18:09:46 <Heffalump> (that number would also be valid from Canada, wouldn't it?)
18:09:56 * Heffalump has no MSN/Yahoo account.
18:10:06 <Cale> Heffalump: the message didn't give a country code
18:10:17 <Cale> but I
18:10:21 <Cale> I'm assuming 1
18:11:42 <palomer> America = USA
18:12:00 <lispy> palomer = Troll ;)
18:12:04 <palomer> in much the same way that we call "People's republic of china" china, we call "united states of america" america
18:12:19 <lispy> hmmm
18:12:29 <lispy> but what about the United States of Canada?
18:12:39 <palomer> that's not for at least another 10 years
18:12:45 <lispy> and i thought we'd changed our name to United States of Jesus Land
18:13:06 <SamB> happily no
18:13:24 <SamB> that would be, like, taking his name in vain, no?
18:13:40 <lispy> i'm not sure, i'm not christian
18:14:15 <palomer> in many places, religion is what's stopping things from deterioting into pre-1995 new york city
18:15:04 <lispy> palomer: that statement requires knowledge i don't posses, what do you mean?
18:15:11 <SamB> anyway, canada IS in america. so are a lot of other things, if you consider South America to be part of America.
18:15:23 <araujo> hah
18:15:29 <araujo> America is the whole continent.
18:15:29 <palomer> we're america in more ways than one
18:15:47 <palomer> lispy: in keeps people in line
18:15:50 <palomer> s/in/it
18:16:04 <Heffalump> you're America because you (collectively) arrogantly chose to call yourselves that :-)
18:16:17 <lispy> heh, no kidding
18:16:40 <Heffalump> China is rather different, it isn't a continent.
18:16:50 <Heffalump> Just two countries that both sides claim should be one.
18:17:01 <Heffalump> albeit ever more weakly on the Taiwanese side
18:17:20 <lispy> i thought Taiwan wanted independence?
18:17:39 <Heffalump> it's complicated
18:17:40 * lispy just realized this is way OT
18:17:48 <dons> did I drop in on #haskell-blah by mistake?
18:17:50 <Heffalump> I'm off to bed.
18:17:52 <palomer> Taiwan wants more bubble tea
18:18:03 <SamB> uh, like, why would we want to talk about things that are on topic?
18:18:16 <SamB> people can't even bother to maintain Yampa!
18:18:18 <SamB> I mean really.
18:18:21 <lispy> so i was playing with this fix point operator today...
18:18:38 <jip> dons: hi, did you ever look into that bug btw?
18:18:43 <lispy> and GHC says to me, "<<loop>>"
18:18:57 <dons> it's on the todo list. i won't release a new hs-plugins till it's fixed, so don't worry
18:19:03 <lispy> > let bottom = bottom in bottom
18:19:05 <lambdabot> Add a type signature
18:19:06 <dons> i've been busy with other things 
18:19:11 <jip> k
18:19:28 <palomer> I don't see why let bottom = bottom in bottom doesn't type check
18:19:32 <SamB> > let bottom = bottom in bottom :: ()
18:19:33 <lambdabot> Exception: <<loop>>
18:19:35 <palomer> according to HM, it should get type forall a.a
18:19:35 <lispy> > let bottom :: a; bottom = bottom in bottom
18:19:36 <lambdabot> Add a type signature
18:19:50 <dons> palommer, there's a good reason..
18:19:51 <SamB> palomer: it does, its just that it has a polymorphic type
18:20:10 <palomer> err, I meant a type cannot be infered
18:20:20 <SamB> however, show (let bottom = bottom in bottom) does not
18:20:27 <dons> there's an extra constraint, that's due to the implementation..
18:20:30 <lispy> well, it's uninhabitied right? so you can't infer a type, right?
18:20:33 <SamB> @type let bottom = bottom in bottom
18:20:34 <lambdabot> forall t. t
18:20:49 <SamB> palomer: that looks like a type to me
18:20:52 <palomer> ah, so why can't it evaluate it?
18:20:53 <SamB> its just that
18:20:59 <SamB> @type show let bottom = bottom in bottom
18:21:00 <dons> lispy, it's fine. try it in ghci.
18:21:01 <lambdabot> parse error on input `let'
18:21:11 <SamB> @type show (let bottom = bottom in bottom)
18:21:12 <lambdabot> String
18:21:14 <dons> SamB has the right idea
18:21:14 <lispy> dons: yeah, i see what SamB just did
18:21:29 <lispy> well, let bottom = bottom is equivalent to undefined right?
18:21:41 <SamB> huh...
18:21:44 <SamB> thats funny!
18:21:49 <SamB> why do I get String
18:22:05 <lispy> @type show undefined
18:22:07 <lambdabot> String
18:22:09 <SamB> @type show undefined
18:22:10 <lambdabot> String
18:22:11 <palomer> @type show
18:22:13 <lambdabot> forall a. (Show a) => a -> String
18:22:23 <lispy> well, that makes sense
18:22:24 <SamB> I bet it is defaulting to Integer
18:22:28 <SamB> or Int
18:22:29 * SimonRC goes to bed
18:22:30 <sethk> of course, show anythingAtAll has to have type String
18:22:30 <palomer> yeah, that's fine, all you need to do is show that let bottom = bottom in bottom is of type a
18:22:57 <lispy> @type show (undefined `seq` undefined)
18:22:59 <lambdabot> String
18:23:09 <SamB> sethk: yeah, but it also wouldn't typecheck unless it could decide on a type for anythingAtAll 
18:23:17 <palomer> why does  let bottom = bottom in bottom need a type signature?
18:23:24 <sethk> SamB, yes, that's true.
18:23:38 <SamB> palomer: it doesn't
18:23:45 <palomer> > let bottom = bottom in bottom
18:23:46 <lispy> is undefined an istance of show?
18:23:46 <lambdabot> Add a type signature
18:23:47 <sethk> I would argue that  let bottom - bottom in bottom    is not the best choice of names  :)
18:23:51 <lispy> > show undefined
18:23:53 <lambdabot> Add a type signature
18:23:55 <Philippa> it probably does actually, it's not got the slightest damn clue what type you want
18:24:02 <SamB> palomer: the boilerplate needs the sig
18:24:19 <palomer> boilerplate?
18:24:27 <lispy> > show undefined :: 1
18:24:29 <lambdabot> Couldn't match `GHC.Base.Unit' against `String'
18:24:41 <palomer> oh, righto, it works in ghci
18:24:44 <Philippa> palomer: the stuff ghci generates in order to print a value out
18:24:53 <SamB> palomer: @eval wraps your code in boilerplate and runs the whole thing through GHC
18:25:12 <SamB> Philippa: no, not the GHCi boilerplate, the @eval boilerplate
18:25:12 <palomer> Philippa: but it does work in ghci
18:25:21 <Philippa> SamB: fair enough, my bad
18:25:24 <SamB> they don't use the same boilerplate, you know
18:25:26 <lispy> bottom :: t
18:25:28 <Philippa> palomer: wrong interpreter :-)
18:25:29 <lispy> yup, it works
18:25:34 <dons> you see the difference in the defaulting
18:25:38 <SamB> Philippa: this is kinda confusing
18:25:50 <lispy> that's the way undefined is defined (ironic?) in Prelude right?
18:26:11 <SamB> I wouldn't be surprised if GHCi was trying it at an IO type first
18:26:26 <SamB> lispy: maybe
18:26:36 <lispy> so if C++ templates are akin to paramateric polymorphism, what is _|_ in C+?
18:26:42 <SamB> I'm pretty sure you are allowed to use any bottom you like...
18:26:57 <Philippa> lispy: _|_ in C++ is *(0)
18:27:08 <lispy> Philippa: ah, clever
18:27:09 <SimonRC> no
18:27:13 <SamB> Philippa: in templates?
18:27:13 <lispy> no?
18:27:21 <SimonRC> e.g. 1 + _|_ == _|_
18:27:38 <SamB> 1 + *(0) still segfaults, though
18:27:40 <SimonRC> 1 + *0 == random crap or segfault.
18:27:56 <lispy> how about void?
18:27:56 <SimonRC> only on some machines
18:27:58 <SamB> so is *(0)
18:27:59 <dons> well, it's strict. does it need a bottom?
18:28:07 <SimonRC> lispy: void is more like ()
18:28:15 <SimonRC> dons: I suspect not
18:28:34 <lispy> but you can't instantiate void, only pointers to it
18:28:41 <Philippa> SimonRC: random crap or segfault is the interpretation of _|_ :-)
18:29:04 <lispy> next in #haskell; interpretive bottoms
18:29:14 <SimonRC> IIRC, some compilers made *0==0
18:29:40 <Philippa> well yeah, that's undefined too
18:29:45 <SimonRC> lispy: ah, but functions return void if they have nothing useful to say.
18:29:49 <Philippa> lispy: BTDT
18:29:56 <palomer> there is no bottom in C++
18:29:56 <SimonRC> like :: IO ()
18:29:59 <Philippa> the rope'n'stuff's next door :-)
18:30:03 <palomer> nothing even acts remotely like bottom
18:30:06 <SimonRC> palomer: I suspect you are right
18:30:08 <Philippa> palomer: there is no explicit bottom value in C++, that's not the same thing
18:30:27 <Philippa> there's much in C++ which has semantics that would be denoted by bottom
18:30:51 <palomer> but they're so different!
18:31:06 <SamB> yes, remember, Haskell == denotational semantics - inteligent readers
18:31:32 <lispy> SimonRC: I would argue that void in a function signature has a different meaning
18:31:46 <Philippa> palomer: not really. _|_ = "screws up somehow". It's just that f _|_ isn't necessarily denoted by _|_ in haskell
18:32:53 <SamB> so, maybe most C++ programs == _|_
18:33:10 <palomer> C++ == _|_
18:33:13 <palomer> end of discussion
18:33:24 * palomer actually quite likes C++
18:33:24 <lispy> QED
18:33:33 <SamB> yes
18:33:46 <SamB> okay, now what will we talk about?
18:33:53 <palomer> women
18:33:53 <araujo> palomer, it's ok, nobody is perfect.
18:33:56 <lispy> i prefer C over C++, but to get any real work done in either, C++ is probably better
18:34:11 <SamB> women look nice...
18:34:22 <araujo> SamB, pics?
18:34:24 <araujo> :-]
18:34:56 <SamB> @google pictures of women
18:34:58 <lambdabot> http://womenshistory.about.com/library/pic/bl_p_suffrage_movement.
18:34:58 <lambdabot> htm
18:35:07 <lispy> here is an exercise, rewrite the C spec in denotational semantics
18:35:09 <araujo> mm....
18:35:26 <SamB> huh
18:35:49 <SamB> lispy: wouldn't it make more sense to just write an interpreter in Haskell/
18:35:50 <SimonRC> SamB: how about the analytic and algebraic topology of locally Euclidean parameterization of infinitely differentiable Riemannian manifold?
18:35:55 <SamB> s|/|?|
18:36:51 <SamB> SimonRC: I'm currently in Calculus II, for the 2nd time
18:36:58 <SamB> SimonRC: I don't know anything about that
18:37:04 <SimonRC> # I have a friend in Minsk, #
18:37:10 <SimonRC> # Who has a friend in Pinsk, #
18:37:20 <lispy> @google analytic and algebraic topology of locally euclidean parameterization of infinitely differentialable riemannian manifold
18:37:22 <lambdabot> No Result Found.
18:37:32 <SimonRC> # Whose friend in Omsk / Has friend in Tomsk #
18:37:39 <SimonRC> # With friend in Akmolinsk. #
18:37:58 <lispy> SimonRC: i understood part of that, and it sounds like a complicated way to refere to something like the reals
18:38:09 <lispy> refer*
18:38:39 <SimonRC> Damn, does no-one STR?
18:38:46 <lispy> STR?
18:38:52 <ncalexan> Tom Lehrer?
18:38:56 <SimonRC> You people's geek education is seriously lacking
18:39:00 <SimonRC> ncalexan: yop
18:39:05 <SimonRC> *yup
18:39:06 <ncalexan> STR?
18:39:14 <SimonRC> @google STR
18:39:16 <lambdabot> http://www.str.org/
18:39:16 <lispy> tom lehrer?
18:39:20 <dons> dcoutts, could you grab http://www.cse.unsw.edu.au/~dons/regex-dna.tgz, compile (ghc -o a A.hs) and then run it with /a < input.txt. it should complete within 30seconds or so. if not, let me know.
18:39:32 <SimonRC> lispy: yes
18:39:32 <dons> it seems to diverge on the shootout machine, I'm not sure why
18:39:43 <SimonRC> Spot The Reference
18:39:44 <dons> dcoutts, on a 32bit x86 gentoo box
18:40:12 <SimonRC> (BTW, the song is _Lobachevsky_)
18:40:12 <Cale> SimonRC: what the heck is that?
18:40:13 <ncalexan> Never seen STR before.
18:40:21 * Philippa poisons SimonRC in the park
18:40:28 <ncalexan> Like a Pigeon!
18:40:39 <ncalexan> Lehrer is a very funny ex-mathematician comedian/song writer.
18:40:39 <SimonRC> Cale: some words from a song.
18:40:49 <Cale> SimonRC: no, the link
18:40:58 <SimonRC> Cale: dunno, didn;t look
18:41:08 <Cale> SimonRC: oh
18:41:09 <Cale> okay
18:41:12 <lispy> how would writing a C interpreter in haskell give the denotational semantic?  I guess because you could infer them from the mapping of C to Haskell?
18:41:39 <Cale> lispy: yeah, probably
18:41:59 <Cale> lispy: if there was a *current* denotational semantics for Haskell.
18:42:00 <Philippa> yeah, with IO actions as the domain
18:42:21 <Philippa> point
18:42:29 <Philippa> it'd give you something pretty close to it, though
18:42:43 <lispy> ah, my idea was related to this idea i've been having.  Replace C with something that fills the same niche in systems programming but which is more ammenable to writing code you can trust
18:43:09 * SimonRC *really* goes to bed this time.
18:43:14 <rep> really?
18:43:30 <lispy> it's not even 19:00
18:43:41 <SimonRC> 02:42
18:43:41 <rep> indeed
18:43:51 <rep> 18:43
18:43:58 <lispy> SimonRC: you should check your clock
18:44:06 <SamB> what is the difference between Haskell and denotational semantics, besides all the funny symbols?
18:44:07 <SamB> and the non-overloading of constructors and functions in Haskell
18:44:07 <SamB> (which is to say, you can't just decide that there are two functions with this name on different types; you actually need a typeclass)
18:44:11 <lispy> it's obviously not set to PST
18:44:18 <SimonRC> lispy: indeed
18:44:25 <SimonRC> UTC
18:44:32 <SamB> @timefor SimonRC 
18:44:33 <lambdabot> Unknown command, try @listcommands.
18:44:37 <SimonRC> zZzZ
18:44:43 <SamB> @localtime SimonRC 
18:44:45 <lambdabot> Local time for SimonRC is Sat Jan 21 02:44:01 2006
18:44:45 <lispy> @time Portland
18:44:46 <lambdabot> Maybe you meant: dice type uptime
18:44:52 <dons> here's a Twelf implementation of ghc Core (twelf is a theorem prover) http://www.cse.unsw.edu.au/~sjw/non-cvs/code/coreLF.tar.gz
18:44:59 <SamB> @uptime
18:45:00 <lambdabot> uptime: 3 days, 23 hours, 57 minutes and 23 seconds
18:45:00 <Philippa> SamB: denotational semantics for concurrent systems looks a bit different, for one
18:45:01 <dons> lispy, @timein is broken for now
18:45:11 <lispy> @localtime lispy
18:45:13 <lambdabot> Local time for lispy is Fri Jan 20 18:40:07 2006
18:45:17 <SamB> Philippa: how do they do those? functional nets?
18:45:27 <lispy> dons: how does it know my timezone? from hawiki?
18:45:40 <SamB> lispy: hahaha
18:45:41 <Philippa> SamB: dunno, you'd have to look it up
18:45:42 <lispy> or does it do a traceroute sort of lookup?
18:45:42 <dons> CTCP pings
18:45:46 <lispy> ah
18:45:52 <dons> or sorry, I meant the NSA
18:45:53 <SamB> CTCP TIME
18:45:57 <dons> @keal
18:45:58 <lispy> @keal
18:45:58 <lambdabot> i think i know what code does but code looks to simple to actually do
18:45:58 <lambdabot> it
18:45:59 <lambdabot> 99% of my book has been erased by faulty hdd's
18:46:14 <dons> ah, so many memories
18:47:23 <lispy> oh wow, my clock was 5 minutes off
18:47:27 <lispy> @localtime lispy
18:47:30 <lambdabot> Local time for lispy is Fri Jan 20 18:46:46 2006
18:47:50 <lispy> i think i need to run ntpdate in a cron job
18:48:08 <SimonRC> who is keal?
18:48:35 <lispy> SimonRC: annoying crazy person that get themselves banned from #haskell
18:49:01 <dons> @keal
18:49:02 <lambdabot> i can explain why something is without knowing what the rules decided by
18:49:02 <lambdabot> man are
18:49:06 <lispy> SimonRC: /msg lambdabot @keal to read through the logs of what keal said
18:50:13 <lispy> i should work more on this memory problem in darcs
18:50:39 <NoobLuck> hiii
18:50:47 <NoobLuck> question
18:51:12 <NoobLuck> CPU aiming to the functionl paradigm
18:51:28 <NoobLuck> that was a dream?
18:51:34 <lispy> er?
18:51:38 <NoobLuck> yes
18:51:42 <NoobLuck> my teacher
18:51:57 <lispy> i'm not your teacher
18:51:59 <NoobLuck> said that it existed a project
18:52:03 <NoobLuck> XDD
18:52:08 <lispy> lisp machines?
18:52:16 <SimonRC> "i only trust opensource tools. where can i download haskell for windows?" hehehe
18:52:25 <NoobLuck> XDDD
18:52:29 <lispy> SimonRC: hehe
18:52:34 <NoobLuck> yeah
18:52:46 <NoobLuck> 2 questions
18:53:27 <lispy> NoobLuck: i don't know of any processor that was design to be functional.  But, there are processors that can exploit functional code more than traditional imperative code.  Take for example, graphics processors or clusters like google luses
18:53:48 <lispy> s/luses/uses/
18:53:53 <NoobLuck> ghci
18:54:13 <NoobLuck> haskell can be as fast as C?
18:54:28 <NoobLuck> whe compiled / not interpreted?
18:54:47 <Cale> NoobLuck: basically, yes
18:55:04 <lispy> NoobLuck: http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
18:55:09 <Cale> NoobLuck: it can require knowing what you're doing as well :)
18:55:48 <NoobLuck> ahh
18:55:53 <Cale> I see that gcc has improved its score recently, not wanting to be outdone by ghc
18:55:56 <Cale> :)
18:56:00 <NoobLuck> ok this goes to second question
18:56:35 <lispy> i notice fortran is way down on the list, what happened to the (myth) of fortran as a performance master?
18:56:45 <lispy> maybe it's because of the sorting i'm using
18:56:46 <NoobLuck> so there is a harder to understand way fo programing in haskel
18:57:17 <Cale> NoobLuck: not so much harder, but you eventually learn ways to spot inefficiencies
18:57:20 <JKnecht> yep.
18:57:20 <NoobLuck> that is faster but inteligible
18:57:24 <lispy> NoobLuck: that varies from person to person.  Some people find FP to be quite a mind bender, others find in it elegance and simplicity.
18:57:34 <NoobLuck> yeah
18:57:39 <Cale> Often simplifying code is all it takes to make it run faster
18:58:08 <Cale> if that's not enough, you can add strictness annotations which help *when appropriate*
18:58:10 <NoobLuck> inefficiencies of the compiler or the language
18:58:13 <NoobLuck> ??
18:58:27 <Cale> inefficiencies in the code you've written
18:59:00 <Cale> (I guess the compiler)
18:59:17 <Cale> Languages don't inherently possess any measure of speed.
18:59:32 <SamB> Cale: be careful when you talk like that
18:59:37 <SamB> maybe some do!
18:59:49 <NoobLuck> just execute a program
18:59:50 <dons> it all depends on the code you write. unless you're using java
18:59:50 <Cale> It's just about how difficult it is to translate the language into efficient machine code.
18:59:58 <JKnecht> the further the model of computation is from the hardware running it, the more you need to understand about it's implementation on said hardware.
19:00:04 <NoobLuck> and measure time X-P
19:00:05 <Cale> Java has native compilers now too.
19:00:07 <SamB> yeah, in Java everything is slow
19:00:09 <lispy> dons: lol
19:00:10 <NoobLuck> java sucks
19:00:13 <NoobLuck> XDDD
19:00:21 <NoobLuck> i don not like java
19:00:23 <NoobLuck> sorry
19:00:25 <Cale> Java sucks, but not for being slow anymore
19:00:29 <lispy> what does XDD* mean?
19:00:35 <SamB> it is still slow
19:00:36 <NoobLuck> same as lol
19:00:42 <SamB> it is just slow to write now ;-)
19:00:43 <NoobLuck> XD
19:00:43 <Cale> I think it's a smiley with multiple mouths
19:00:53 <Cale> I don't really get that.
19:00:57 <NoobLuck> correct
19:01:05 <NoobLuck> XDDDDDDDDDDDDDDDDDDD
19:01:08 <NoobLuck> i laugh more
19:01:12 <dons> please stop doing that.
19:01:13 <NoobLuck> with more mouths
19:01:13 <SamB> is XDD where you have two mouths and your eyes are jammed shut from laughing so hard?
19:01:17 <NoobLuck> why?
19:01:21 <NoobLuck> is tipicall
19:01:32 <Cale> Like, who has 19 mouths?
19:01:38 <SamB> that was 19?
19:01:43 <Cale> something like that
19:01:43 <NoobLuck> feah
19:01:45 <SamB> > length "XDDDDDDDDDDDDDDDDDDD"
19:01:47 <lambdabot> 20
19:01:48 <NoobLuck> genetic isusus
19:01:52 <NoobLuck> XDDDD
19:01:53 <SamB> it was 19!
19:01:54 <NoobLuck> sorry
19:02:08 <NoobLuck> all my friends do
19:02:15 <SamB> all your friends...
19:02:17 <lispy> wow, do you know keal? ;)
19:02:21 <SamB> ... have 19 mouths?
19:02:23 <NoobLuck> keal?
19:02:24 <dons> oh boy.
19:02:26 <Cale> man, all your friends are mutant freaks?
19:02:30 <SamB> @keal
19:02:31 <lambdabot> where can i find opensource schematics of Linus Torvalds' x86 clone?
19:02:36 <Cale> @keal
19:02:36 <NoobLuck> recorsive lauging
19:02:37 <lambdabot> bot seems useless
19:02:43 <Cale> @. elite keal
19:02:44 <SamB> @keal
19:02:44 <lambdabot> bE77eR be a7L34st 16x16 C0|or With 3XteNd3d 45(II 53t
19:02:44 <lambdabot> tomorrow i share next mathematical secrety
19:02:51 <Cale> @. elite keal
19:02:52 <lambdabot> i T|-|iNx I Kn0w W|-|a7 (Ode DO3$ Bu7 COd3 |0oxS +0 zI/\/\p|e tO 4cTUA||y
19:02:52 <lambdabot> D0 It
19:03:12 <SamB> @keal
19:03:12 <lambdabot> you think i am one of them persnipity uppity men are pig lesbian mathematic
19:03:12 <lambdabot> ians?
19:03:16 <lispy> @. vixen keal
19:03:18 <lambdabot> I don't think you are the one you say you are!
19:03:27 <Cale> heh
19:03:38 <Cale> even vixen is suspicious!
19:03:41 <SamB> @keal
19:03:41 <lambdabot> i cant think anymore
19:03:44 <NoobLuck> > "X" ++ "DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD"
19:03:46 <lambdabot> "XDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD"
19:03:49 <SamB> that one sounds true enough
19:03:57 <Cale> > "X" ++ repeat "D"
19:03:59 <NoobLuck> lambda bot is laughing
19:03:59 <lambdabot> Couldn't match `Char' against `[Char]'
19:04:06 <Cale> > "X" ++ repeat 'D'
19:04:08 <lambdabot> "XDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD
19:04:08 <lambdabot> DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD
19:04:08 <lambdabot> DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD
19:04:08 <lambdabot> DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD
19:04:08 <lambdabot> DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD
19:04:09 <NoobLuck> jajaj
19:04:10 <lambdabot> [23 @more lines]
19:04:16 <NoobLuck> ohohoh
19:04:17 <SamB> > x : replicate 19 'D'
19:04:18 <lambdabot>  Not in scope: `x'
19:04:20 <NoobLuck> functional power
19:04:25 <SamB> > 'X' : replicate 19 'D'
19:04:26 <lambdabot> "XDDDDDDDDDDDDDDDDDDD"
19:05:09 <SamB> > map ('X':) $ inits $ repeat 'D'
19:05:10 <lambdabot> ["X","XD","XDD","XDDD","XDDDD","XDDDDD","XDDDDDD","XDDDDDDD","XDDDDDDDD","
19:05:10 <lambdabot> XDDDDDDDDD","XDDDDDDDDDD","XDDDDDDDDDDD","XDDDDDDDDDDDD","XDDDDDDDDDDDDD",
19:05:10 <lambdabot> "XDDDDDDDDDDDDDD","XDDDDDDDDDDDDDDD","XDDDDDDDDDDDDDDDD","XDDDDDDDDDDDDDDDD
19:05:10 <lambdabot> D","XDDDDDDDDDDDDDDDDDD","XDDDDDDDDDDDDDDDDDDD","XDDDDDDDDDDDDDDDDDDDD","
19:05:10 <lambdabot> XDDDDDDDDDDDDDDDDDDDDD","XDDDDDDDDDDDDDDDDDDDDDD","XDDDDDDDDDDDDDDDDDDDDDDD
19:05:12 <lambdabot> [23 @more lines]
19:05:36 <SamB> look, ma, I have the whole set!
19:06:10 * Philippa attempts to resist the temptation to post a bad pun to the "what is a proposition?" thread on LtU
19:06:11 <lispy> yes, yes you do
19:06:31 <NoobLuck> look this emot
19:06:39 <NoobLuck> looking a beauty girl
19:06:51 <NoobLuck> 8-)' ' ' '
19:07:04 <SamB> is that drool?
19:07:15 <NoobLuck> what is drool?
19:07:17 <SamB> @type (.).(.)
19:07:18 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
19:07:36 <SamB> its that dribbly stuff that comes out of your mouth, going down
19:07:36 <lispy> @type (.)^(.)
19:07:38 <lambdabot>   No instance for (Integral ((b -> c) -> (a -> b) -> a -> c))
19:07:38 <lambdabot>   arising from use of `^' at <interactive>:1:3
19:08:25 <JKnecht> drool es escupir.
19:09:07 <SamB> @dict web1913 drool
19:09:08 <lambdabot> Supported dictionary-lookup commands:
19:09:08 <lambdabot>  @all-dicts @devils @easton @elements @foldoc @gazetteer @hitchcock @
19:09:08 <lambdabot> jargon @lojban @vera @web1913 @wn @world02
19:09:08 <lambdabot> Use "@dict-help [cmd...]" for more.
19:09:10 <NoobLuck> jajaj
19:09:13 <NoobLuck> vale nen
19:09:18 <SamB> @web1913 drool
19:09:20 <NoobLuck> yeah
19:09:20 <lambdabot> *** "Drool" web1913 "Webster's Revised Unabridged Dictionary (1913)"
19:09:20 <lambdabot> Drool \Drool\, v. i. [imp. & p. p. {Drooled}; p. pr. & vb. n.
19:09:20 <lambdabot>  {Drooling}.] [Contr. fr. drivel.]
19:09:20 <lambdabot>  To drivel, or drop saliva; as, the child drools.
19:09:20 <lambdabot>  
19:09:22 <lambdabot>    His mouth drooling with texts.           -- T. Parker.
19:09:22 <NoobLuck> is drool
19:09:37 <lispy> remeber, you can /msg lambdabot as well
19:09:44 <lispy> remember*
19:09:47 <SamB> @devils drool
19:09:47 <NoobLuck> XDD
19:09:48 <lambdabot> No match for "drool".
19:09:52 <SamB> aww
19:10:00 <SamB> @devils friend
19:10:02 <lambdabot> No match for "friend".
19:10:05 <NoobLuck> @web1913 pikachu
19:10:07 <lambdabot> No match for "pikachu".
19:10:12 <NoobLuck> damm
19:10:21 <SamB> NoobLuck: that dictionary came out in 1913
19:10:26 <SamB> pikachu is much more recent
19:10:29 <NoobLuck> ok
19:10:33 <NoobLuck> no problem
19:10:36 <SamB> hence, no pikachu in that one ;-)
19:10:39 <NoobLuck> frikipedia
19:10:39 <NoobLuck> !
19:10:49 <SamB> @frikipedia pikachu
19:10:52 <lambdabot> http://en.wikipedia.org/wiki/Pikachu
19:11:02 <NoobLuck> no frikipedia
19:11:24 <SamB> what is frikipedia?
19:11:26 <NoobLuck> is in spanish
19:11:29 <SamB> ah
19:11:35 <NoobLuck> is like wikipedia
19:11:39 <NoobLuck> but
19:11:40 <SamB> well, you can write that command ;-)
19:11:42 <NoobLuck> for example
19:11:48 <NoobLuck> macgiver
19:12:21 <NoobLuck> :
19:12:51 <NoobLuck> macgyver is soldier electricist mechanic explosive expert pilot spy 
19:13:05 <NoobLuck> electronic expert and diplomatic
19:13:08 <NoobLuck> all in one
19:13:31 <NoobLuck>  is whitout any doubt one of thu great forgiven en the world's history books
19:14:00 <lispy> so anway, back to haskell....
19:14:10 <NoobLuck> a brilliant
19:14:14 <lispy> how do i find the source of strictness?
19:14:34 <SamB> lazilly?
19:14:37 <SamB> i.e. you don't?
19:14:46 <SamB> </dumb joke>
19:14:56 <NoobLuck> ZzZZz
19:15:07 <lispy> i have datatypes that are strict in each parameter except their packed strings (which they have a list of) when i request the first packed string in thel ist it appears to construct the entire list
19:15:10 <NoobLuck> i have the bird book
19:15:27 <SamB> lispy: well, where do they come from?
19:15:33 <NoobLuck> bt it does not explains nothing about  ghc
19:15:47 <lispy> SamB: they are read from a file.  According to ghc the file reads are all lazy in each argument
19:16:18 <SamB> lispy: well, the contents of the file doesn't come from an argument ;-)
19:17:12 <lispy> SamB: so it's strict in the return value?
19:17:15 <lispy> is that possible
19:17:42 <SamB> and, well, are these lines being read with FPS?
19:18:14 <SamB> or whatever they are
19:18:19 <NoobLuck> DX
19:18:22 <NoobLuck> oh no
19:18:42 <lispy> SamB: yes, i think so
19:18:53 <lispy> maybe i haven't checked that layer
19:19:16 <SamB> perhaps they are read all at once and then split into pieces?
19:20:04 <lispy> i don't think so...Igloo converted this code to be lazy in the past
19:20:13 <lispy> but i should still check
19:20:25 <SamB> yeah. maybe some crazy person converted it back!
19:21:04 * lispy looks alound
19:21:06 <lispy> er around
19:21:31 <lispy> funny thing about dvorak is that it can give you an asian accent on your typing
19:22:10 <SamB> heh
19:22:15 <lispy> well, ghc thinks that FPS read functions are lazy
19:22:37 <SamB> GHC doesn't have the same concept of lazy as you and I do
19:22:54 <SamB> anyway, funnier is that I read that right even though you wrote it wrong
19:22:56 <Philippa> it probably means "potentially lazy"
19:23:16 <Philippa> as in "I can't prove to myself that it's strict"
19:23:33 <SamB> and it is thinking only one constructor in, too, I expect
19:24:02 <lispy> SamB: what did i write wrong?
19:24:12 <lispy> hmm..that's not fun (about the difference in lazy)
19:24:13 <SamB> lispy: that "alound" thing
19:24:18 <lispy> ah
19:24:53 <NoobLuck> I USE DVORAK
19:25:22 <NoobLuck> jeje
19:25:24 <SamB> asian people don't use uppercase that much do they?
19:25:35 <lispy> no, that's typical of canadians
19:25:37 <NoobLuck> spanish adaptation
19:26:12 <SamB> I'm only pretending to know how to type
19:27:13 <NoobLuck> in dvorak?
19:27:15 <lispy> SamB: your imagination is powerful
19:28:00 <SamB> that is, I seem to have learned to mostly touch type without noticing until afterwards
19:28:51 <NoobLuck> i think is
19:29:13 <NoobLuck> i have learned by the repetition
19:29:32 <NoobLuck> i dont think were is the key most of the times, i feel it
19:29:56 <SamB> sometimes I typo the wrong vowel or silly things like that...
19:30:12 <SamB> and no, I apparantly don't know where anything is on the keyboard myself
19:30:20 <SamB> I didn't know that though ;-)
19:30:37 <NoobLuck> happens same to me
19:30:58 <NoobLuck> now my typing errors
19:31:05 <SamB> sometimes I get some fingers off by one or something, and often my fingers fire out of order
19:31:10 <NoobLuck> are order errors
19:31:11 <lispy> NoobLuck: "same happens to me"
19:31:25 <NoobLuck> thanks
19:31:36 <lispy> np :)
19:31:38 <SamB> word order or letter order?
19:31:46 <NoobLuck> letter order
19:31:54 <NoobLuck> using the devorak
19:32:08 <SamB> word order typos would be really impressive
19:32:08 <NoobLuck> but is very confortable
19:32:16 <SamB> I actually use QWERTY
19:32:25 <NoobLuck> i use DVORAK
19:32:55 <SamB> you said that already ;-)
19:33:19 <NoobLuck> yeahh
19:33:29 <SamB> which is why I mentioned that I use QWERTY, though I imagine they are fairly similar except for the particular errors you make
19:33:41 <NoobLuck> no
19:33:50 <NoobLuck> similar to?
19:33:54 <Cale> I've typoed complete words. It happens when your fingers move to type a common word starting with a sequence occurring inside another word.
19:34:13 <SamB> hmm?
19:34:29 <JKnecht> or when your typing connects directly to your speech center.
19:34:31 <Cale> like, my typo was another correct English word
19:34:40 <NoobLuck> criptography?
19:34:42 <SamB> I sometimes forget what word I meant to say too
19:35:04 <SamB> And I really do mix up my vowels ;-)
19:35:10 <Cale> This was almost certainly a typo, since I was thinking the correct word, but typed this other one.
19:35:31 <SamB> Hmm.
19:35:35 <SamB> dunno if I do that.
19:35:47 <SamB> sometimes I forget to type complete words. though usually small ones.
19:37:21 <SamB> its annoying when I forget "not"
19:37:40 <Cale> hehe, yeah, that's an important word :)
19:39:09 <Lemmih> jip: pong.
19:40:07 <dons> Lemmih, you pinged?
19:41:41 <Lemmih> Yeah, I found a bug in hs-plugins. Will mail you a patch soon.
19:41:58 <dons> ok, good.
19:48:25 <lispy> i'm slowly coming to the conclusion that this darcs preformance problems is only truely fixable if the patch format is changed.  I guess that's where Igloo has been for quite some time...
19:50:26 <lispy> if that is the case, maybe i should drop this line of work
20:04:39 <ForgeAus> hey all :)
20:05:59 <lispy> hi
20:23:22 <lispy> http://pastebin.com/515660 based on run time performance, i think that function is strict in the parameter s, but the .hi file shows it as L, any suggestions on how to findout if it is the problem or not?
20:23:52 <lispy> i want it to be lazy, but i think it is forcing the string s to be completely processed
20:24:17 <Cale> what kind of string is it?
20:25:03 <lispy> Stringalike is an abstraction for String and PackedStrings
20:25:13 <lispy> in this case, it should be a PackedString
20:25:37 <Cale> I figured as much -- are PackedStrings even lazily allocatable?
20:25:50 <Cale> I'd expect them to be strict.
20:26:03 <lispy> in darcs they must be, i can read a 360mb file and write out the patch using only 350kb
20:26:04 <Cale> (that's what makes them fast)
20:26:20 <Cale> hmm
20:26:36 <lispy> i think what is happening is that when i read a patch i do, new <- work $ lines_starting_with '+'
20:26:52 <lispy> and i think, lines_starting_with doesn't return until it has found all the lines that start with +
20:27:02 <lispy> instead of doing enough work to find one, and then creating a thunk for the next
20:28:33 <Cale> oh
20:28:46 <Cale> yeah, it can't return any of them
20:29:00 <Cale> until it's finished the calls to lsw
20:29:16 <Cale> and it processes the whole thing as it calls lsw over and over
20:29:38 <Cale> it's written like a foldl
20:29:46 <lispy> hmm...
20:30:07 <lispy> how can we rewrite it so that it can pause when it finds one line?
20:30:21 <lispy> would that be possible...
20:30:27 <Cale> surely it's possible
20:30:40 <lispy> how would you do it in the case of fold?
20:30:55 <lispy> also, how do i test for that?
20:31:00 <sethk> If I #import one of my modules, and that module imports, say, System.Directory, is that import inherited?  Or do I have to import System.Directory (or whatever) in the .hs file even though I've imported another module (of my own) that imports System.Directory?
20:31:22 <Cale> after all, lines_starting_with c xs = filter (isPrefixOf [c]) . lines
20:31:27 <lispy> sethk: my understanding is that it depends on what the improting module exports
20:31:31 <Cale> for ordinary strings :)
20:31:46 <lispy> Cale: i'm too dense to get your point :)
20:31:49 <sethk> lispy, so unless I explicitly re-export, the answer to my question is no?
20:32:18 <Cale> lispy: lazily break the string into lines, then filter the lines
20:32:26 <Cale> sethk: right
20:32:34 <sethk> Cale, lispy, thanks, as usual.
20:32:42 <lispy> sethk: you're welcome
20:32:52 <lispy> Cale: hmm...yes i'll think about that, that sounds reasonable
20:33:10 <Cale> don't write it tail-recursively
20:33:14 <lispy> Ah
20:33:22 <Cale> tail recursion is the enemy of laziness
20:33:52 <lispy> hmm...never thought of that
20:34:14 <lispy> is lines in the standard prelude lazy?
20:34:18 <Cale> it is
20:34:21 <lispy> http://www.cs.uu.nl/~afie/haskell/tourofprelude.html#lines
20:34:40 <lispy> i'll follow that model
20:34:45 <sethk> Cale, that's an interesting observation.  Doesn't the compiler try to add tail recursion wherever it can?
20:35:16 <Cale> sethk: if you write code which is tail recursive, it will be optimised as tail recursive code
20:35:29 <Cale> but otherwise, it shouldn't
20:35:43 <Cale> lispy: there you see that lines (x:xs) = l : ls
20:35:59 <Cale> so to get the first line, you just compute l
20:36:08 <sethk> so the compiler won't exchange the order of evaluation as part of an attempt to optimize, at least in that particular context?
20:36:35 <Cale> sethk: it would have to be overly clever to know when it's safe to do so
20:36:54 <sethk> Cale, indeed.  or too stupid to care, which is what I expected.  :)
20:36:55 <Cale> Since it would have to know, for example, that a list was going to be finite
20:37:05 <sethk> right, I see the problem, hence the question
20:37:38 <Cale> As a language claiming to be lazy, Haskell does try to preserve lazy semantics. :)
20:37:56 <sethk> I need a new keyboard, I have to hit my left shift key with a hammer before it works.  ;)
20:38:58 <Cale> There may actually be one or two places where an optimisation subtly fails to preserve the semantics, I'm not sure, but those would be considered bugs.
20:47:23 <sethk> is there an md5 hash or some similar hash in the libraries?
20:48:04 <Cale> http://www.haskell.org/crypto/doc/html/
20:48:08 <Cale> http://www.haskell.org/crypto/
20:52:43 <sethk> thanks.  is it a separate download?  I grepped my local docs and I don't find it.
20:53:14 <sethk> must be.
20:53:19 <Cale> yes
20:53:30 <Cale> that second link gives the darcs command to run
20:53:51 <Cale> (or you can just download it)
20:55:03 <sethk> Cale, thanks, I'll try that.
20:55:07 <lispy> filter is hard to write on packed strigs
20:55:29 <Cale> lispy: you should be operating on a list of packed strings
20:55:35 <Cale> use the ordinary filter :)
20:55:43 <lispy> oh, yeah, true
20:57:43 <sethk> Darcs seems to be quite stable
20:58:02 <lispy> sethk: what version are you using?
20:58:05 <sethk> what's the magic phrase to install a darcs source package?
20:58:10 <lispy> 1.0.4 has an unpull bug
20:58:14 <sethk> 1.0.4rc2
20:58:31 <sethk> lispy, ok, as long as I don't unpull I'll be ok.  I should update, though.
20:58:36 <lispy> darcs get http://abridgegame.org/repos/darcs
20:58:48 <lispy> sethk: unstable and 1.0.5 have the bug as well
20:58:51 <lispy> 1.0.3 is safe
20:59:00 <sethk> lispy, k, thanks for the info.
20:59:49 <sethk> ot
20:59:55 <sethk> it's runhaskell Setup.hs install, correct?
21:00:06 <lispy> Cale: i don't think the definition of lines_starting_with is right.  I need to return nothing is some cases, and i need to return the unprocessed part of the string
21:00:25 <lispy> not sure, i use make install
21:01:11 <Cale> lispy: when should you return nothing?
21:01:16 <lispy> Cale: actually, i like your type signature better, andi don't see a need for the Maybe
21:01:30 <lispy> yeah, exactyl, this function cannot return nothing
21:02:20 <lispy> although, how would i return the unprocessed part of the string?
21:02:34 <Cale> ([PackedString], s) or ([s],s) would be enough
21:02:38 <lispy> i think the calling monad uses that and passes it to the next string parsing function
21:02:42 <Cale> but what's the unprocessed part?
21:02:52 <Cale> aren't you going to process the whole thing?
21:03:06 <Cale> or do you mean the complement of those lines?
21:03:32 <lispy> this is for parsing darcs hunks, there is a run of lines that start with + followed by lines that start with -
21:03:49 <lispy> and other cases where this function is used
21:03:58 <lispy> so in some sense it parses like parsec does
21:04:18 <Cale> is it a takeWhile / span thing rather than a filter / partition thing?
21:04:25 <lispy> when i hit a line that doesn't start with the prefix i care about, i want to stop and return the unprocessed part
21:04:32 <lispy> yeah
21:04:40 <Cale> > span (<5) [1..10]
21:04:42 <lambdabot> ([1,2,3,4],[5,6,7,8,9,10])
21:04:44 <lispy> takeWhile/span is probably about riht, but i don't know much about span
21:04:59 <Cale> span p xs = (takeWhile p xs, dropWhile p xs)
21:05:06 <lispy> > span (<5) [1..]
21:05:08 <lambdabot> ([1,2,3,4],[5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,
21:05:08 <lambdabot> 27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,
21:05:08 <lambdabot> 51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,
21:05:08 <lambdabot> 75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,
21:05:08 <lambdabot> 99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,
21:05:10 <lambdabot> [24 @more lines]
21:05:41 <lispy> > fst (span (<5) [1..])
21:05:43 <lambdabot> [1,2,3,4]
21:05:56 <lispy> Cale: thanks
21:06:58 <sethk> Cale, is this the only crypto that you know about?  I have to install several things, including an out of date cabal, to build it.   or run it.  or both, I'm not sure.
21:07:24 <Cale> sethk: hmm
21:07:32 <lispy> Cale: i want span p xs = (takeWhile p (lines xs), dropWhile p (lines xs)) though right?
21:07:48 <Cale> that's just composition
21:07:55 <Cale> span p . lines
21:08:02 <lispy> ah, true
21:08:04 <sethk> Cale, it's got urls for them, let me see how painful it is.
21:08:14 <Cale> sethk: it's probably possible to update
21:08:32 <Cale> I'll look on the mailing lists for announcements
21:08:47 <Cale> there's Shaskell
21:09:01 <Cale> which is SHA256/SHA512
21:09:33 <sethk> Cale, doesn't matter to me which hash, I'm only using it for verifying binary integrity
21:09:59 <Cale> http://davidmercer.nfshost.com/projects/shaskell/shaskell.html
21:12:00 <lispy> Cale: does it matter how i turn the (snd . span) back into one string?
21:12:14 <lispy> i think i need an unlines
21:12:24 <Cale> lispy: right, you need an appropriate unlines
21:12:41 <Cale> hmm
21:12:51 <Cale> that will come with some costs
21:14:35 <lispy> yeah, map is not defined for PackedStrings
21:14:47 <lispy> er wait
21:15:03 <lispy> i keep getting confused about which functons i can keep and which ones to rplace
21:15:22 <Cale> perhaps a custom implementation is indeed in order
21:15:51 <Cale> write a breakLine function  s -> Maybe (PackedString, s)
21:16:27 <lispy> i have a break function
21:16:44 <Cale> which separates a single line from the string?
21:17:19 <Cale> the intent there is that it returns Nothing when s is empty, and otherwise returns Just (first line of s, rest of s)
21:17:46 <lispy> i think so
21:17:51 <Cale> Shaskell's wiki is cool
21:18:03 <lispy> i need to wrap it up, but i think breakPS will do that
21:18:41 <Cale> yeah
21:18:52 <Cale> span on FastStrings looks like the way to go
21:19:05 <Cale> or break
21:19:42 <Cale> > break (/= '\n') "This is a\ntwo-line string."
21:19:45 <lambdabot> ("","This is a\ntwo-line string.")
21:19:50 <Cale> > break (== '\n') "This is a\ntwo-line string."
21:19:51 <lambdabot> ("This is a","\ntwo-line string.")
21:20:04 <lispy> well, i have mapPS, let me add sal_map and see what i get using the previous strategy
21:21:01 <Cale> or even breakOn which is apparently faster
21:21:29 <Cale> You need some polymorphism, but I don't know what your Stringlike class has in it
21:21:54 <lispy> so far just string and faststring
21:22:02 <lispy> stringalike is a pain
21:22:06 <Cale> I mean in terms of members
21:22:17 <lispy> oh right, it's got not enough :)
21:23:42 <lispy> oh wait, PackedStrings has an unlines
21:23:50 <lispy> i'll just add unlines to string aline
21:23:54 <lispy> er stringalke
21:25:11 <Cale> if you're really concerned heavily about efficiency, you don't want to have to unlines the rest of the string
21:28:31 <lispy> yeah
21:30:52 <rep> yeah?
21:31:18 <lispy> yeah
21:32:02 <lispy> Cale: i'll try it real quick with this inefficient unlines, if this improves things i'll know to do the more indepth version with custom break
21:33:49 <lispy> it's not clear to me how a better break will save the day
21:34:23 <Cale> okay
21:34:25 <lispy> i need to dice the string into lines and filter based on the first char of each line
21:34:34 <Cale> yeah
21:34:47 <lispy> that part seems unavoidable, but the killer constraints is returning the unprocessed part
21:34:53 <Cale> but you do that, and then pass on the unprocessed part of the file to presumably do it again, right?
21:35:12 <lispy> yeah
21:35:16 <NoobLuck> hi
21:35:23 <SamB> lispy: you could look at the first character before splitting each time...
21:35:28 <lispy> so, i should just split it into lines at the begining...
21:35:39 <Cale> but if the 'unprocessed' part of the file has undergone (unlines . lines) that will add a potentially significant constant hit to accesses
21:36:07 <lispy> SamB: so then i'd be looking for '\n'++c
21:37:05 <Cale> whereas, you'd rather just chop out that part and hopefully copy a pointer to the rest
21:37:10 <NoobLuck> haskell is similar to lisp?
21:37:18 <Cale> NoobLuck: not that similar
21:37:27 <Cale> It's closer to lisp than it is to C.
21:37:35 <SamB> NoobLuck: not terribly
21:38:14 <NoobLuck> wich is better for general purpose
21:38:16 <lispy> NoobLuck: i don't know which is better because you gave me insufficient information :)
21:38:40 <Cale> I'd say Haskell most of the time.
21:39:03 <lispy> Cale: hmm..so i should change break to carve out the piece i want, but actually break does that now right?
21:39:15 <lispy> type safety is nice
21:39:15 <Cale> If you're going to use a lisp, go with scheme.
21:39:33 * SamB wonders why Conjure is prepending most of a webpage to its trace messages
21:39:45 <Cale> some variant of scheme anyway. Lisp has some annoying misfeatures which make it somewhat inappropriate for functional programming.
21:39:51 <Cale> (common lisp)
21:40:08 <lispy> i'd say common lisp is a nice language, just big and dirty
21:40:21 <lispy> it has some features that make it better for "real-world" than scheme
21:40:31 <lispy> CLOS is nice
21:40:34 <SamB> lispy: I particularly mind the "big" part
21:40:40 <Cale> lispy: I hate the 'functions are in a different namespace from everything else' bit
21:40:45 <SamB> because its libraries are a mess, especially in the spec...
21:40:49 <dons> hmm. that's a bit sillly, isn't it.
21:40:53 <docl> forth is nice and small. maybe dirty though.
21:41:10 <lispy> Cale: but, that's nice for writing code, (defun foo (list))
21:41:19 <lispy> Cale: you can't do that in schemem
21:41:28 <Cale> lispy: I found it terribly terribly irritating
21:41:43 <SamB> I also hate the "oops, I didn't know I had imported that symbol! I totally did *not* wan't to overwrite that definition!"
21:41:51 <lispy> Cale: this new version doesn't seem to be any more lazy than the last
21:41:57 <Cale> because you have to call apply to apply half of the functions which are floating around, and there's #' everywhere :)
21:42:01 <lispy> SamB: yeah, i hate that
21:42:07 <docl> fwiw retroforth.net
21:42:43 <lispy> Cale: hah, because i forgot to compile in my new function :)
21:42:50 <Cale> lispy: hehe
21:43:44 <SamB> docl: does that emulate an ancient system with miniscule ram and disk and puny graphics to run forth?
21:44:04 <docl> no, it's modern
21:44:18 <Philippa> forth isn't dirty. It's utterly filthy
21:44:19 <docl> no graphics that I know of
21:44:26 <docl> as filthy as you make it
21:44:43 <Philippa> OTOH, it's utterly filthy in the "ooh look, I've got low-level hardware access and no typing constraints!" kind of way
21:44:55 <docl> if it has a fault, it's just overly permissive :)
21:45:18 <Philippa> exactly
21:45:25 <Philippa> well, that and being a pointless language
21:45:54 <docl> I think it has potential as a meta-language, i.e. for making other languages in
21:47:09 <Philippa> some, yeah. Categories sort-of form concatenative languages too, from which you can find all sorts of possibilities for silly metaness
21:47:32 <NoobLuck> > 0 : 1 : (zipWith (+) fibs (tail fibs))
21:47:34 <lambdabot>  Not in scope: `fibs'
21:47:44 <Cale> Yeah, categories just generalise monoids when you get right down to it.
21:47:53 <NoobLuck> > fibs = 0 : 1 : (zipWith (+) fibs (tail fibs))
21:47:54 <lambdabot>  parse error on input `='
21:48:04 <NoobLuck> ^^U
21:50:14 <Philippa> is there some kind of 'type system for category theory' out there?
21:50:46 <Cale> apart from the usual formalisms?
21:50:51 <Philippa> (I ask because if so I could just go straight out and implement a thoroughly metamasturbatory language rather than spend ages thinking what such a type system'd look like first)
21:51:13 <lispy> Cale: this time i did it right, and it still doesn't appear lazy, but i'll have to work on this more later, thanks for your help
21:51:24 <Philippa> hrmm, which ones would you count as 'the usual'? I suspect there's a need for some equivalent of arbitraryish typeclasses
21:51:42 <Cale> lispy: hmm, okay -- talk to me later about it and I'll have a closer look
21:52:31 <Cale> Philippa: well, usually we use some kind of natural deduction
21:53:37 <Cale> Are you going to implement category theory, or a language with categories?
21:54:24 <Philippa> hard to decide where the line's drawn
21:54:50 <Philippa> probably a metalanguage with categories and the ability to build objects in said categories
21:55:12 <Cale> I suppose if the primary goal of your language is proving theorems in category theory, then they're pretty much the same.
21:56:20 <Philippa> it's not though
21:56:33 <Philippa> it's being the sort of hackish that makes lisp break down and cry
21:56:40 <Cale> hehe
21:59:06 <mwc> I have a question about iterate
21:59:11 <Cale> mwc: sure
21:59:12 <mwc> how the hell can it be implemented efficiently?!
21:59:21 <Cale> mwc: lots of ways?
21:59:35 <Cale> depends on what you mean by 'efficiently'
21:59:36 <mwc> [x, f x, f $ f x, etc]
21:59:46 <mwc> I mean, isn't that the wrong way around?
21:59:52 <Cale> iterate f x = x : iterate f (f x)
22:00:03 <mwc> hmmm
22:00:13 <mwc> Ok, I was having a brainfart. 
22:00:47 <mwc> I was thinking it would be nigh on impossible to build a list like that from the front, since appending to the back of a list is expensive
22:00:50 <Cale> that's poor if you intend to use values really far out into the list
22:01:13 <Cale> because you'll eventually build yourself a stack overflow
22:01:24 <Cale> > iterate (+1) 0 !! 1000000
22:01:26 <lambdabot> Exception: stack overflow
22:01:49 <Cale> but there's nothing that can be done about that without making the application of f strict
22:01:59 <lispy> Cale: i'm not really here, but http://pastebin.com/515728 that should be lazy in giving lines right?
22:02:36 <mwc> Cale, hmmm, maybe I should make f strict in this case
22:02:39 <Cale> lispy: yes
22:02:40 <lispy> i wonder if the parser monad is not as lazy as we think
22:02:46 <mwc> thank you
22:02:51 <Cale> mwc: you have to rewrite iterate too
22:03:46 <Cale> iterate' f xs = let y = f x in y `seq` x : iterate f y
22:04:02 <lispy> couldn't you use $! ?
22:04:09 <Cale> yes, you could
22:04:21 <Cale> iterate' f xs = x : iterate f (f $! x)
22:04:27 <Cale> this is a little slower
22:04:32 <lispy> oh
22:04:36 <mwc> Yeah, oh?
22:04:38 <Cale> but clearer, certainly
22:04:49 <Cale> yeah, it has to evaluate the $!
22:04:55 <Cale> then the seq
22:05:26 <mwc> hmm, I thought f $! x = x `seq` f x
22:05:29 <Lemmih> Aren't they both optimized away?
22:05:36 <Cale> that's something the compiler should do, but it didn't last time I checked
22:05:40 <lispy> bah, seq is for people that don't value eta expansion anyway....
22:06:12 <sethk> hmm., System.Posix.Files isSymbolicLink is returning false for links.  The other tests work, though (isDirectory, etc.)  isRegularFile returns true for symbolic links.
22:06:20 <Cale> Or if that wasn't the reason, I have no idea why the latter version ran slower.
22:06:31 <Cale> It was pretty slight though
22:07:08 <lispy> did you guys read what Wirth said about FP?
22:07:25 <lispy> he said it had too many problems to use in practice (or was it in industry)
22:07:34 <sethk> lispy, something about your mother using functional languages?
22:07:36 <sethk> :)
22:07:56 * lispy is playing wesnoth and chatting in #haskell at the same time
22:08:07 <sethk> lispy, does that mean I have to rewrite all the programs I've delivered and are already deployed?
22:08:11 <Cale> lispy: when did he say this? And do you mean FP the language or functional programming in general?
22:08:13 <lispy> me and a friend have a scheduled match, but his turns take hours....
22:08:50 <lispy> Cale: functional programming in general, and he said it recently in an essay that gave a good hard, critical look at CS as a field
22:09:09 <lispy> i had no idea FP was a language :)
22:09:14 <Cale> http://en.wikipedia.org/wiki/FP_programming_language
22:09:33 * NoobLuck says that weshnot is slowwwwwwww
22:09:35 <mwc> Yeah, it was Backus' attempt to 'liberate programming from von Nuemann'
22:09:43 <lispy> the eassy was called something about, "Good ideas throughout computer science"
22:10:45 <Cale> there was a great video I watched a while back with Backus talking about his language FP and CS in general. It was pretty old, but a lot of the things he was saying about CS still ring true.
22:10:50 <lispy> he's apparently never seen haskell, at least that was the impression we got.  Because he said the problem with passby value vs. passby name still doesn't have a good solution.
22:11:18 <sethk> lispy, that's an odd thing to say.
22:11:35 <lispy> pascal is an odd language to invent :)
22:11:41 <Cale> there seem to be lots of old CS people that don't have a clue about FP
22:12:04 <lispy> Cale: i think old is an unnecessary restriction :)
22:12:21 <Cale> lispy: well, people you'd think should know better
22:12:27 <sethk> lispy, at the time pascal was quite advanced
22:12:41 <Cale> http://www.archive.org/details/JohnBack1987 -- I think this was it
22:12:45 <lispy> sethk: yeah, but i still like to make fun of it
22:12:47 <Cale> check it out :)
22:12:59 <Cale> (the download link is along the sidebar)
22:14:14 <Cale> the language itself is a bit antiquated, but his comments for the most part aren't.
22:15:09 <jimmy---> hello
22:15:22 <Cale> jimmy---: hello :)
22:15:57 <jimmy---> hoe are you Cale
22:15:59 <Cale> The FL which he's talking about in that video is a successor to FP
22:16:08 <Cale> jimmy---: fine, and yourself?
22:16:19 <jimmy---> IM fine too
22:16:24 <jimmy---> where you from?
22:16:49 <Cale> Canada
22:16:55 <Cale> learning Haskell?
22:17:00 <mwc> I keep forgetting Cale lives just up the road from me
22:17:09 <jimmy---> mmm
22:17:14 <jimmy---> I from chile
22:17:29 <jimmy---> Cale you are male or female
22:17:34 <Cale> jimmy---: yeah, I saw the .cl domain :)
22:17:36 <Cale> male
22:17:38 <mwc> I met a physician from Chile, nice guy
22:17:46 <jimmy---> ok
22:17:55 <jimmy---> mwc
22:18:01 <jimmy---> you know chile?
22:18:17 <mwc> Not really, I know somebody from Chile
22:18:40 <jimmy---> a ok
22:18:49 <jimmy---> where you from mwc?
22:20:45 <mwc> Canada as well
22:20:47 <bouma> hello. i
22:21:00 <jimmy---> mi server is irc.cl
22:21:14 <jimmy---> alguien compra shells?
22:21:35 <bouma> 'm wondering if haskell can be considered 1st class under windows. as in will i be compromising over using it under unix??
22:21:48 <jimmy---> somebody buy shells?
22:21:51 <Philippa> a little, but it's not bad
22:22:00 <Philippa> you do want MSYS though
22:22:29 <lispy> Cale: i think maybe the parsing is not as lazy as i expected because maybe the monad causes it to process all the lines
22:22:41 <lispy> it's "Lazy" monad, but i'm wondering
22:22:51 <Lemmih> bouma: s/haskell/ghc/
22:22:58 <jimmy---> somebody buy shells?
22:26:03 <Cale> jimmy---: what brings you to #haskell? Are you an experienced Haskell programmer, or just starting out?
22:27:01 <jimmy---> mmmm really i dont know what is haskell
22:27:39 <mwc> bouma, I understand GHC win32 to be pretty good, the guys who develop it are Microsofters
22:27:48 <Cale> Haskell is a general purpose, lazily evaluated, functional programming language
22:27:56 <jimmy---> mmm
22:27:58 <jimmy---> ok
22:28:03 <Philippa> mwc: the problem's libraries
22:28:06 <mwc> I think the primary PITA is stuff like GTK2 that has DLL pains on WIndows, but they're all worked out
22:28:07 <mwc> yeah
22:28:11 <jimmy---> nothing speak?
22:28:44 <Cale> Of the 15 or so programming languages I've used, Haskell is far and away the nicest in many respects.
22:28:53 <jimmy---> only there are 5 talking
22:28:55 <jimmy---> .....
22:28:57 <Philippa> a secondary PITA is libs that were developed by *nixers that haven't been gone over for ease of building under win32 yet
22:29:57 <Philippa> evenin'
22:30:05 <Lemmih> lilo is a Haskeller?
22:30:09 <Philippa> jimmy---: you want complete silence, or would you rather at least one person talking?
22:32:13 <Cale> we have no problem with idling for hours at a time in this channel :)
22:34:47 * lilo is just checking in to make sure no one is annoying anyone 8)
22:34:57 <jimmy---> what kind of music do you like?
22:35:00 <Philippa> no more'n'usual at the mo
22:35:01 <lilo> if you are being annoyed, you'll know it; hopefully not
22:35:05 <lilo> kay
22:35:12 <Philippa> we did get a spammer briefly earlier
22:35:37 <Lemmih> jimmy---: There's #haskell-blah for non-haskell stuff.
22:36:18 <jimmy---> hahaha
22:36:20 <jimmy---> ok
22:36:25 <Philippa> but mostly for sex, no?
22:36:28 <jimmy---> forget me
22:36:31 <jimmy---> good bye
22:36:44 <lispy> bye
22:36:55 <Cale> lilo: I've been annoyed by that alienware spammer that's been generating a k-line a day. I haven't been noting the IPs -- are the k-lines getting removed, or is he just hopping around?
22:36:56 <jimmy---> nice to meet you
22:37:17 <bouma> ok, i think once under linux i saw a one page demo using haskell and some openglish library (i think it was an example that came with hugs graphics or something) that rendered a simple 3d tornado.. would that run under windows?
22:37:56 <Philippa> bouma: if it was the hugs graphics thing, I don't know if it runs anywhere these days. IIRC HOpenGL works fine though
22:38:42 <bouma> ok, so there is 1st class opengl 'wrappers' that interface with haskell under windows, freely avail?
22:39:25 <Philippa> comes with GHC these days, I think
22:39:30 <lilo> Cale: they keep hopping around
22:40:05 <Philippa> and there's a GLUT binding too
22:40:14 <lilo> Cale: it's their strategy....seems like they're putting a lot of effort into it, which makes it odd that they're doing it here
22:40:35 <Philippa> less odd if they think this is target market
22:40:36 <lilo> Cale: I'm sure they just grab a list of irc servers from different networks and cram them into the config file
22:40:52 <lilo> Philippa: it's very unlikely.... most of the channels here have something to do with FOSS
22:41:04 <lilo> Philippa: not really likely to buy much of anythingware
22:41:08 <bouma> what _free_node ?? really?
22:41:18 <lilo> hehe bouma 
22:41:21 <Philippa> sure. I don't think I've been anywhere myself that didn't have at least one FPSer though
22:41:33 <lilo> Philippa: there's usually no science to it, if they spend too much time on it, it's not worth the investment
22:41:42 <Philippa> and IME free hardware's beyond even RMS's mystical ability
22:41:44 * Philippa nods
22:41:47 <lilo> Philippa: in their best markets, the number of genuine sales leads is going to be microscopic
22:42:07 <Cale> lilo: the guy seemed pretty upset when I heckled him on MSN about it.
22:42:16 <Philippa> it's still a better shot than irc.bondage.com though
22:42:25 <lilo> Cale: interesting
22:42:50 <lilo> Cale: if there was a human involved, he must have been kind of misdirected....there are lots of better networks than this one for selling stuff....people usually complain to the staff
22:43:21 <Cale> Perhaps just getting people to say "hey, you shouldn't be doing that -- stop spamming freenode" etc. enough would eventually deter him :)
22:43:35 <lilo> Cale: it might
22:43:42 <Cale> He might have just been pissed off about the k-line though :)
22:43:51 <Cale> (but what did he expect?)
22:43:57 <lilo> Cale: you just never know which ones have a human being behind them....people don't usually wait to find out 8)
22:44:09 <lilo> Cale: I message them but I rarely get a response
22:44:49 <Cale> the guy gave his email address along with an msn and yahoo account. When I added him to gaim, his auto away message gave me his phone number.
22:45:32 <Cale> I just messaged him asking him to stop and he seemed pretty annoyed.
22:46:05 <mwc> Hmm, I get a type error when I try to use Data.Array.IArray, but it works with Data.Array: periods = array ((1,1),(99,99)) [((a,s),lcgPeriod ourM a ourI s) | a <- [1,2..ourM -1], s <- [1,2..ourM - 1]]
22:46:05 <mwc>  where lcgPeriod is Int -> Int -> Int -> Int -> Maybe Int    
22:46:14 <mwc> the error seems to be a problem with the Maybe
22:46:50 <mwc> No instance for (IArray a (Maybe Int))
22:46:50 <mwc>       arising from use of `array' at Main.hs:17:14-18
22:46:50 <mwc>     Probable fix: add an instance declaration for (IArray a (Maybe Int))
22:47:11 <lispy> @type array
22:47:13 <lambdabot> Not in scope: `array'
22:47:26 <lispy> @type Data.Array.array
22:47:27 <lambdabot> forall e i.
22:47:27 <lambdabot> (GHC.Arr.Ix i) =>
22:47:27 <lambdabot> (i, i) -> [(i, e)] -> GHC.Arr.Array i e
22:47:45 <lilo> Cale: I always explain to them that this is a special purpose network, and advertising here is likely to cause users to complain to staffers and get them klined
22:47:55 <lilo> Cale: then I suggest that they should pick a network where that's not a problem
22:48:18 <lilo> Cale: http://irc.netsplit.de/networks/ lists nearly every IRC network on the planet, so I point them there....it points to server lists, statistics, sorted lists by size, and so on
22:48:47 <mwc> Frack, still no BSG torrents from tonight
22:49:01 <lilo> Cale: I try to appeal to their self-interest rather than just complaining
22:49:14 <lilo> Cale: if they reply at all, they're often willing to listen
22:49:33 <mwc> I'd like to understand what's going on with this error
22:49:34 <lilo> the problem is getting them to reply 8)
22:49:43 <lispy> mwc: i think maybe the problem is the 'a' in IArray a (Maybe Int), but that doesn't seem likeit
22:49:45 <lilo> anyway, I'll background, I just thought there might be a problem user
22:49:46 <Cale> lilo: cool, I'll try that
22:49:48 <Korollary> mwc: It was a sadly predictable episode.
22:49:55 <lilo> Cale: thanks
22:50:01 <mwc> Korollary, yeah, I've got the theory that Roslin is a cylon
22:50:01 <lilo> Cale: the more people do that, the better, I think
22:50:18 <lilo> mwc: yeah, I get that impression
22:50:56 <mwc> I mean, they did that cylon test thing early in the first season
22:51:03 * lilo nods
22:51:12 <mwc> but wasn't Baltar passing everybody at that point?
22:51:12 <lilo> you know, I haven't really had an episode I didn't enjoy
22:51:17 <lilo> yeah, he was
22:51:19 <mwc> yeah, I'll say the same
22:51:34 <lilo> and there was specific mention that something was going on with Roslin (Rosalind?)
22:51:41 <lilo> but not what
22:51:57 <mwc> Clearly, Roslin is a cylon: programmed to have the visions to lead the human survivors through a gamut. I'm thinking the cylon mission is actuallly to "purge" and purify humanity
22:52:03 <lispy> they have a TV show about haskell?
22:52:05 <mwc> judging by the comments of eps 11 and 12
22:52:07 <mwc> hahaha
22:52:10 <lilo> you know, sometimes I know what's going to happen, sometimes not, but either way, the character development and the sf is good stuff
22:52:13 <lilo> lispy: hehe
22:52:26 <Korollary> I just watch it for the hot ladies
22:52:30 <lilo> I get the impression they really do want to wipe out humanity, or change it significantly
22:52:38 <lilo> so that it's, well, not humanity any more
22:52:46 <lilo> and I think Earth is probably attractive to them, if they believe in it
22:52:47 <mwc> yeah, that's my impression
22:52:59 <lilo> lots of humans to change/control
22:53:00 <mwc> I think that's how the show will finally end
22:53:00 <adu> to who?
22:53:02 * lispy mumbles about #haskell-blah
22:53:12 <lilo> lispy: yeah, sorry about that 8)
22:53:17 <lispy> :)
22:53:28 <lilo> /join ##bsg
22:53:37 <mwc> true
22:53:55 <adu> who wants to change the world?
22:54:10 <lispy> adu: functional programmers :)
22:54:28 <adu> then their under-developed humans
23:22:26 <lilo> anyway, sorry for the digression 8)
23:22:40 * lilo seems to have found another network for jimmy-many-dashes
23:22:44 * lilo waves
23:31:16 <dons> @shootout
23:31:17 <lambdabot> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=
23:31:17 <lambdabot> all
23:31:21 <dons> (just testing)
23:33:42 <dons> @seen dcoutts
23:33:43 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-blah and #haskell. Last spoke 14
23:33:43 <lambdabot> hours, 29 minutes and 59 seconds ago.
23:55:15 <lispy> gentoo haskell?
23:55:31 <Lemmih> gentoo haskell!
23:55:43 <ForgeAus> hehe
23:56:27 <lispy> they really do like their compile times :)
