00:00:46 <Korollary> I'm not up to that point in TaPL yet
00:10:23 <gizban> combine_core ::  Int -> ([Integer],[Integer]) -> [Integer]            I want to insert the Int between the two [Integer] lists and return a new [Integer] list.  How do I do this?  I keep getting type errors
00:11:41 <aleator> cc i (a,b) = a++[i]++b ?
00:12:23 <gizban> I tried that but it said couldn't match 'Int' against 'Integer'
00:12:54 <int-e> ah. use [fromIntegral i] instead of [i] then
00:13:48 <gizban> thanks, that worked.  These types are a real head ache.  Worse than ada
00:14:01 <aleator> gizban: Why don't you use Ints/Integers everywhere?
00:15:09 <gizban> the assignment requirements mix the two types, which causes me a lot of problems
00:26:56 <Mitar> how can i write an exit case for: putStrListLn (x:xs) = do
00:26:56 <Mitar>   putStrLn x
00:26:56 <Mitar>   putStrListLn xs
00:27:17 <Cale> putStrListLn [] = return ()
00:27:25 <Cale> or you could write that function as
00:27:36 <Cale> putStrListLn = mapM_ putStrLn
00:28:45 <Mitar> ooho, there is a monad map!
00:29:00 <tic> mapM_ has type m ()
00:29:21 <Cale> @type mapM
00:29:23 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
00:29:24 <Cale> @type mapM_
00:29:26 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> [a] -> m ()
00:29:27 <Mitar> yes ...
00:29:37 <tic> Cale cheating! :)
00:29:46 <Cale> I already know the types :)
00:30:01 <Cale> I'm just showing that there are indeed two versions :)
00:30:21 <Heffalump> I doubt I would remember that the argument to mapM_ is a -> m b rather than a -> m () without looking it up
00:30:27 <Cale> (and I'm too lazy to type them when I can have the bot do it :)
00:32:21 <Heffalump> woo! /me reduces the heap usage of a program from >1.6G (at which point I killed it) to 240M with a few well placed strictness annotations
00:39:24 <Mitar> any comment (suggestion) on this: mapM_ putStrLn [(show x ++ " factorial is " ++ (show . factorial) x) | x <- numbers]
00:40:18 <Korollary> that works
00:40:34 <Mitar> yes, it works, but any idea for improvement
00:40:38 <Mitar> (i am still learning)
00:40:46 <Korollary> it looks good enough to me
00:40:47 <Mitar> for making code more "Haskell"?
00:40:49 <Mitar> ok
00:41:33 <Mitar> but why: mapM_ putStrLn fact_strings where fact_string = [(show x ++ " factorial is " ++ (show . factorial) x) | x <- numbers] does not work?
00:41:58 <Korollary> typo in fact_strings vs fact_string ?
00:42:23 <Mitar> ups, yes
00:42:32 <Mitar> but there is "Not in scope: `numbers'"
00:43:05 <Korollary> I dont know where numbers comes from for either of them.
00:43:10 <joelk> Woohoo! got my nbody giving the correct results. And it's only 2.5x slower than the current version...
00:43:44 <Korollary> joelk: Hehe. I slowed down a few benchmarks muyself. Weird feeling, eh?
00:44:54 <joelk> Well, it doesn't use "Open Mutable Records", just a list of states. I also calculate the forces between each pair, which is 2x redundant.
00:47:02 <Korollary> joelk: this looks like another example begging for mutable state
00:47:41 <Mitar> numbers come from: numbers <- readNumber
00:48:21 <Mitar> a line before that line
00:48:32 <Korollary> Mitar: if they are in a do block, maybe you got the indentation wrong.
00:49:32 <Mitar> http://pastebin.com/489897
00:49:59 <joelk> yes. But if I can remove the redundancy in my inner loop, that will be a pretty good speed up. Probably prettier too if my current idea works.
00:52:21 <Mitar> i think that identation is correct?
00:52:33 <Korollary> Mitar: You wanna use a "let" instead of where in a do block. Use "let fact_strings " without an "in" at the end before the mapM line at the same indentation level.
00:53:05 <Mitar> hmm
00:53:10 <Mitar> ok, but why?
00:54:07 <Heffalump> where applies to a declaration, so it can only see things that are in scope for the whole declaration
00:54:33 <Heffalump> let ... in a do block can see everything that's in scope at the point where it is in the do block
00:55:31 <Mitar> thanks 
00:55:35 <Mitar> to all
01:24:32 <ADEpt> twb: here?
01:25:48 <twb> ADEpt: what?
01:26:22 <ADEpt> twb: forgot to tell you yesterday that Parsec does not like left-recursive grammars/parsers - tends to go into infinite loops :)
01:26:33 <twb> I know :-)
01:26:45 <ADEpt> twb: ah :)
01:26:46 <twb> There is cyclel or something to handle them.
01:26:59 <ADEpt> twb: chainl/chainl1
01:27:03 <twb> Yeah.
01:28:51 <ADEpt> twb: good. now my conscience is clear :)
02:09:40 <araujo> Good morning.
02:14:47 <triplah> 'evening
02:20:11 <ADEpt> nah, it's mid-day :)
02:23:57 <Saulzar> Night :)
02:31:25 <triplah> Wed Jan  4 20:36:15 EST 2006
02:31:28 <triplah> ;>
02:35:40 <Heffalump> is there a good way of making a Map that is strict in its elements?
02:35:51 <Heffalump> (I don't really count DeepSeqing every operation as "good")
03:29:44 <int-e> is Chris Kuklewicz here?
03:44:39 <JKnecht> "New Scientist" reports Xiaoyun Wang broke MD5 and SHA-1.
03:45:16 <basti_> broke how?
03:45:20 <basti_> analytically?
03:46:09 <Buggaboo> give me the code and I'll break it too. make sure it won't work afterwards.
03:46:23 <JKnecht> looks like brute force, but haven't gotten to details yet.
03:47:00 <basti_> pfffff
03:47:06 <basti_> so what?
03:47:06 <basti_> ^^
03:47:07 <joelk> Are you referring to the 17Dec story?
03:47:35 <JKnecht> yes.
03:49:55 <JKnecht> I consider it a big enough deal to cough up the 5 bucks for the article.
03:51:18 <joelk> And it's not referring to the August 2005 results? Something new? I ask because I would have expected Bruce Schneier to comment on any new developments before now.
03:52:35 <JKnecht> I'll tell you in a few minutes after I read the article.
03:53:01 <joelk> OK. Thanks :-)
03:56:25 <JKnecht> nope it's not brute force, and it's new. Severe situation actually.
03:56:41 <basti_> :-O
03:58:35 <JKnecht> People are actually using her results to forge signatures.
03:59:44 <joelk> that's bad
03:59:48 <basti_> wtf
04:00:12 <C-Keen> JKnecht: is that article available online?
04:00:28 <joelk> And this New Scientist article is nearly a month old and I haven't seen anything else about it...
04:02:53 <JKnecht> Sorry, my mistake. People have shown how her results could be used to forge signatures, but actually do it is considered sufficiently immanent that MS is recommending dumping the codes.
04:02:54 <basti_> apparently it's old news...
04:03:30 <JKnecht> s/do/doing/
04:13:17 <Nanar> what mean syntax Foo.Bar ?
04:13:34 <Nanar> call result of Bar in module Foo ?
04:13:41 <gour> @index join
04:13:42 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.
04:13:42 <lambdabot> State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont,
04:13:42 <lambdabot> Control.Monad.Error, Control.Monad.List
04:23:04 <gour> dcoutts: ping
04:23:08 <Saulzar> Nanar, Yeah - Bar is probably a constructor or data type in Foo (alternatively Bar is another module in Foo)
04:23:40 <Nanar> Saulzar: ok, thanks
04:24:43 <Nanar> Saulzar: yup in my case DarcsRepo.read_pending, read_prendind is function of DarcsRepo
04:24:48 <gour> @url tmr
04:24:49 <lambdabot> Maybe you meant: arr pl
04:25:09 <gour> @listcommands
04:25:11 <lambdabot> use listcommands [module|command]. Modules are:
04:25:11 <lambdabot> babel base code compose dice dict djinn dummy dynamic elite fact haddock
04:25:11 <lambdabot> help hoogle karma lShell localtime more pl plugs poll pretty quote search
04:25:11 <lambdabot> seen spell state system todo topic type version vixen where
04:25:40 <joelk> @where tmr
04:25:41 <lambdabot> http://www.haskell.org/tmrwiki/FrontPage
04:26:05 <gour> joelk: thanks, how to learn those lambdabot commands?
04:26:28 <joelk> gour, I did the same thing as you the other day and couldn't remember. Today it came to me.
04:26:54 <Nanar> stupid question, is there example of simple code somewhere ?
04:27:00 <Nanar> like reading a file
04:27:15 <gour> joelk: :-) 
04:27:31 <gour> joelk: are you familiar with ogasaki's book?
04:27:34 <ADEpt> Nanar: mail = conents <- readFile "foo.txt"; putStrLn contents :)
04:28:01 <gour> joelk: err. okasaki, funct. data structures
04:28:03 <joelk> Chris Okasaki? Lazy Functional Datatypes?
04:28:03 <ADEpt> Nanar: it's 'main', not 'mail', of course
04:28:16 <joelk> oh... structures... right
04:28:19 <Nanar> ADEpt: and content, no onents
04:28:33 <Nanar> ADEpt: well yeah sure :)
04:28:50 <ADEpt> Nanar: you could try haskell wiki, and PLEAC (if i am not mistaken. it a partial rewrite of perl cookbook in haskell)
04:29:09 <gour> joelk: yep, that one..
04:29:29 <kzm> Hmm...my memory is stuck here: is there a way (i.e. prelude function), similar to groupBy, but grouping alternating matching some criterion?  I.e. :: (a->Bool) -> [a] -> [[a]]
04:29:29 <joelk> gour, some, and It's on my (not so short) list of things to read more closely
04:29:41 <Nanar> ADEpt: ah cookbook is a good beginning
04:29:59 <ADEpt> Nanar: it's not THAT good, IMO, but could be a start
04:30:05 <gour> joelk: you already have it or it's on to-buy list too?
04:30:07 <Saulzar> I don't think the PLEAC for haskell is very complete, seems to be littered with pseudo-perl
04:30:12 <ADEpt> kzm: whats wrong with groupBy?
04:30:19 <ADEpt> Saulzar: +!
04:30:23 <ADEpt> Saulzar: +1
04:30:32 * ADEpt feels extremely dyslectic today
04:31:03 <joelk> gour. Actually I just have the pdf of his thesis... not the book at all
04:31:11 <Nanar> ADEpt: my concern is having some piece of code to have idea how it works, how to do things, and start to code something that works
04:31:27 <Nanar> ADEpt: I started haskell for 2 days only :)
04:31:53 <Saulzar> There's a lot of great examples on the haskell wiki though, as ADEpt mentioned 
04:32:02 <ADEpt> Nanar: take a look at "yet another haskell tutorial"
04:32:06 <kzm> ADEpt, you're right. I think I can use groupBy with a slightly creative predicate.  Thanks :-)
04:32:07 <ADEpt> @where YAHT
04:32:08 <lambdabot> http://www.isi.edu/%7Ehdaume/htut/
04:32:08 <gour> joelk: i'm thinking if the book will be ok after i finish with thompson's book, however it looks thatthe book uses ML
04:33:18 <kzm> @karma+ ADEpt
04:33:19 <lambdabot> ADEpt's karma raised to 1.
04:33:23 * kzm smiles.
04:35:44 <joelk> gour, yes the thesis uses ML with a laziness construct added. I don't think that's a high barrier for a haskell person though.
04:35:51 <Nanar> ADEpt: PLEAC was made by a friend of me
04:36:10 <gour> joelk: do you have url for his thesis?
04:37:19 <joelk> @google "Purely Functional Data Structures"
04:37:20 <lambdabot> http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf
04:37:37 <joelk> that'll work...
04:39:08 <gour> joelk: thanks, it looks i also hit the right one, i'm just wondering what the books brings over the thesis?
04:44:39 <joelk> gour, The tables of contents on amazon and in the thesis are very similar. I see the book also has an Appendix "Haskell Source Code".
04:45:32 <gour> joelk: yes, i also found out about hs source code. it sounds nice...
04:45:46 <joelk> gour, indeed.
04:48:27 <vincenz> Anyone know any literature that describes a model for modelling sequences
04:48:32 <tromp_> any spanish people here?
04:48:42 <vincenz> andd I mean sequences in the CS sense, not mathematical
04:48:57 <joelk> gour: Huh, a local Uni library has it... I'll probably check it out when they reopen on the 10th.
04:50:37 <Oejet> tromp_: #haskell.es perhaps?
04:50:46 <gour> joelk: well i (probably) won't find it here in croatia, so if you manage to take a look, pls. share it
04:52:47 <joelk> gour: Will do. I was surprised because my university, with its big engineering and science departments, doesn't have it, but a nearby liberal arts college does. This has happened before, that's why I already have a library card there :-)
04:54:37 <gour> joelk: so, it must be that the book has a strong touch of art :-)
04:56:08 <praseodym> can I run gtk2hs on mac os x?
04:56:38 <joelk> gour: I'll let you know what I find. Got to go for now.
04:57:25 <carp> praseodym: I've got it installed, works with the darwinports gtk stuff
04:57:53 <praseodym> how did you get it working?
04:58:15 <praseodym> havent tried yet 
04:59:12 <praseodym> is there a binary :P
04:59:31 <carp> buit it from source
05:00:20 <praseodym> I installed ghc from a pkg, will it work then?
05:01:12 <carp> should do, why don't you try it rather than worrying about it ;) what's the worst that can happen ?
05:01:30 <praseodym> dont know :)
05:01:38 <praseodym> can I also get cairo working?
05:02:10 <carp> think so, it's pretty sweet
05:03:09 <praseodym> installed darwinports - but it cant even find the port command
05:03:54 <carp>  /opt/local/bin/port ?
05:04:18 <praseodym> that works
05:04:26 <praseodym> but doesnt the installer add it to my path?
05:04:29 <carp> you need to set it in you path
05:04:36 <praseodym> http://darwinports.opendarwin.org/getdp/ says the installer does so
05:05:00 <praseodym> "If needed, your shell configuration files will be adapted by the installer to include the necessary settings to run DarwinPorts. You may need to open a new shell for these changes to take effect."
05:07:33 <praseodym> how do I add it to my path
05:23:05 <praseodym> could anyone guide me to installing gtk2hs on mac os x
05:23:30 <boegel> praseodym: dcoutts is your man
05:23:50 <praseodym> dcoutts: ping
07:03:40 <Lemmih> CosmicRay: Using type classes for record getters is a can of worms.
07:55:55 <gour> anyone familiar with the 'tree' data structures?
07:56:21 <twb`> How do I add comments to http://cvs.haskell.org/trac/ghc/ticket/631 ?
07:57:23 <gour> i'm trying to solve exercise 14.33 in thompson's book...
08:12:47 <sjanssen> gour: what kind of tree?
08:16:11 <gour> sjanssen: well, after some googling it looks like exercise deals with rose-tree, i.e.
08:16:23 <gour> sjanssen: data GTree a = Leaf a | Gnode [GTree a]
08:16:58 <gour> by looking into hawiki, i saw following definition: data Tree a = Leaf a | Branch a [Tree a]
08:17:34 <gour> so i wonder whether the 1st definition (from the book) should be:
08:17:46 <gour> data GTree a = Leaf a | Gnode a [GTree a]
08:18:31 <PerlJam> gour: depends on if you want only the leaves to hold data or all nodes in the tree.
08:18:54 <gour> PerlJam: so both defs are ok?
08:18:59 <Cale> yeah
08:19:14 <sjanssen> gour: they do mean different things though
08:19:25 <gour> sjanssen: i assume so :-)
08:22:12 <gour> binary trees 8exercises) were simple...just found that Haskell Xml Toolbox has Data.Tree.NTree.TypeDefs
08:23:13 <gour> i'd like to see graphical representaion of those...
08:27:21 <sproingie> huh.  do Channels block after a write until they're read, or do they just keep receiving data?
08:27:37 <sjanssen> does anyone here hack on conjure?
08:29:46 <Cale> sproingie: I think the whole point of them is that they don't block :)
08:29:50 <sproingie> hm, figured it out ... they just keep receiving data.  how do i make them synchronize with the reader?
08:30:08 <sproingie> Cale: i was thinking of them as being like stackless python's channels
08:30:26 <sproingie> not blocking is more flexible, just not sure what the best way is to make them block
08:30:30 <Cale> You could write a bounded version by simply including an MVar with a counter in it
08:30:38 <CosmicRay> somewhere there is a way to use a monad for extracting things out of lists.  Say you want to do something with the first element, then the 2nd, etc.  you could either user l !! x, or a very nasty chain of splitAt calls.  anyone know where I could read about using a monad to do that?
08:30:44 <CosmicRay> I'm pretty sure I've done it before but can't figure out how.
08:31:21 <Cale> CosmicRay: Surely you don't mean 'map'?
08:31:32 <CosmicRay> no.
08:31:33 <lennart> CosmicRay: why not map?
08:31:38 <CosmicRay> I'm thinking of something like:
08:31:41 <Cale> there's also concatMap, a.k.a. >>=
08:31:46 <CosmicRay> var1 <- takefrom list
08:31:49 <CosmicRay> var2 <- takefrom list
08:31:52 <CosmicRay> var3 <- takefrom list
08:32:01 <CosmicRay> doSomething (var1 ++ [1], var2, var3)
08:32:14 <Cale> > do x <- [1,2,3]; y <- [4,5,6]; return (x * 10 + y)
08:32:15 <lambdabot> [14,15,16,24,25,26,34,35,36]
08:32:22 <lennart> what's the type of 'list' and 'var1' ?
08:32:54 <CosmicRay> lennart: let's say list is [[Int]] in the above example, and var1 is [Int]
08:32:59 <Cale> bind in the list monad is the same as concatMap
08:33:04 <CosmicRay> maybe list looks like [[1, 2], [], [3, 4, 5]]
08:33:10 <CosmicRay> so I'd want var1 to be [1, 2]
08:33:10 <sproingie> Cale: using the mvar as a semaphore, basically?
08:33:11 <CosmicRay> var2 to be []
08:33:15 <CosmicRay> var3 to be [3, 4, 5]
08:33:23 <Cale> CosmicRay: pattern match
08:33:39 <CosmicRay> I know I could do that, but I'm looking for a monad to do this ;-)
08:33:45 <lennart> CosmicRay: would there be any iteration?
08:33:52 <Cale> The list monad doesn't work that way :)
08:34:04 <Cale> sproingie: I guess so, yeah
08:34:24 <Cale> sproingie: there's also QSem/QSemN
08:34:33 <CosmicRay> Cale: I know, but there is some monad that does, I think.
08:34:40 <CosmicRay> lennart: no, just this one bit.
08:34:51 <sproingie> Cale: aha.  thanks
08:34:58 <CosmicRay> could it be the State monad?
08:35:16 <Cale> CosmicRay: could you give a more specific example of the mess you're trying to clean up? :)
08:35:43 <CosmicRay> Cale: this is a thought experiment only ;-)
08:35:52 <CosmicRay> I know I've done this in the past, and I can't remember how.
08:35:52 <Cale> ah, okay, I think I might know what you mean
08:36:33 <int-e> CosmicRay: a state monad with the list in the state will work.
08:36:33 <Cale> you want a monad with a primitive to supply you values from a list
08:36:36 <Cale> yeah
08:36:47 <CosmicRay> right.
08:36:49 <Cale> (if that's what you mean :)
08:36:50 <Cale> okay
08:37:02 <CosmicRay> that keeps an internal state of some sort, so that the next time I call it, I get the next value.
08:37:21 <Cale> One sec, let me write something up :)
08:38:16 <int-e> it even fits the reader monad I think (although the getfromlist operation needs to have a concrete implementation then)
08:38:42 * shapr still doesn't really understand the reader monad...
08:38:50 <CosmicRay> ah yes, I think it is the state monad that I want.
08:38:58 * int-e is wrong.
08:38:58 <Cale> hmm... I don't know about that (using the reader monad)
08:39:02 <shapr> Is reader like an environment?
08:39:09 <Cale> shapr: yeah
08:39:12 <int-e> shapr: it can just pass constants into computations ... so yeah
08:39:26 <shapr> Oh, that's simple enough.
08:39:33 <Cale> CosmicRay: I'll write you up a nice custom module for this :)
08:39:44 <int-e> Cale: looking at >>= it's clear that you can't make a monad operation that modifies that state - my bad.
08:40:03 <CosmicRay> Cale: if you include a copyright statement, I'll put it in MissingH ;-)
08:40:06 <int-e> Cale: err, constant (this remark was about the Reade monad)
08:40:10 <SamB> shapr: its appparantly like dynamic variables only without the confusion about what they should mean
08:40:20 <CosmicRay> ah, I think this is pretty trivial with the state monad now.
08:40:21 <SamB> and with being able to be in Monad
08:40:30 <Cale> CosmicRay: it is quite trivial
08:41:14 <Cale> You just implement some operation which returns the head of the state and at the same time modifies the state with tail
08:41:24 <SamB> perhaps MonadReader should be renamed?
08:41:25 <ski> (SamB : 'should mean' ?)
08:41:49 <ski> (maybe 'MonadEnvironment', then ?)
08:42:38 <Cale> CosmicRay: what would you like to do about the empty supply condition?
08:43:01 <SamB> ski: confusion about where the variables get passed from?
08:43:24 <SamB> and yes, I was thinking MonadEnvironment would be a good name...
08:43:33 <CosmicRay> Cale: should probably use error
08:43:55 <Cale> CosmicRay: we could either use error or mzero
08:44:13 <Cale> (but mzero will add a constraint to the kinds of monad we can transform)
08:44:28 <CosmicRay> hmm, I'm not sure I fully understand what using mzero in this situation would do.
08:44:49 <SamB> what about "fail"?
08:44:59 <Cale> Over the list monad, it'll cause backtracking. Over Maybe, it'll just cause failure (Nothing)
08:45:07 <Cale> fail is an abomination :)
08:45:26 <CosmicRay> ah ha.
08:45:31 <SamB> Cale: how so?
08:45:31 <CosmicRay> get1 :: State [a] a
08:45:31 <CosmicRay> get1 = do n <- get
08:45:31 <CosmicRay>           put (tail n)
08:45:31 <CosmicRay>           return (head n)
08:45:31 <CosmicRay> test = do v1 <- get1
08:45:32 <CosmicRay>           v2 <- get1
08:45:34 <CosmicRay>           return (v1, v2)
08:45:36 <CosmicRay> main = do print $ evalState test [1,2,3,4,5,6,7]
08:45:45 <Cale> Okay, so we could use it, but I wish that it had been put in a special class.
08:46:35 <Cale> The only purpose of fail is handling failed pattern matches specially, and I really think is was a design flaw in the language, since there's an obvious better way to handle that.
08:48:13 <Cale> (namely, make 'do' interact with the type system a little, and use mzero just when it's available, rather than try to kludge this extra operation into Monad that was never meant to be there
08:49:13 <Cale> Getting rid of the MonadZero class was a mistake
08:52:46 <Cale> hmm, I wonder whether an instance of MoandReader is appropriate, or if that violates expectations
08:52:58 <Cale> I wish the documentation made laws explicit.
08:57:52 <Staos> HOW CAN YOU CODE IN MATHS LOL
08:58:22 <Cale> what?
08:58:42 <Staos> LOL HY, HOW2CODE IN MATH.
08:59:21 <Nanar> need a hint
08:59:27 <Cale> Staos: You shouldn't type in all caps.
08:59:33 <Nanar> what does "PatchRead.lhs:281:6: Parse error in pattern
08:59:33 <Nanar> make: *** [PatchRead.o] Erreur 1
08:59:37 <Nanar> mean
08:59:42 <Cale> Staos: also, I don't really understand what you're asking.
08:59:47 <Staos> In all seriousness, folks, Haskell is the language of choice for retards.
09:00:16 <Nanar> is it a pure syntax error or error about declaration/code ?
09:00:17 <Staos> WHT IS A CAP LOCK KEY LOL
09:00:27 <Cale> Nanar: syntax
09:00:29 <C-Keen> Staos: *plonk*
09:00:43 <Nanar> ok
09:00:55 <Nanar> I don't understand what is wrong
09:01:27 <Staos> YOU CAN  RITE MORE THAN 281 LINES OF HASKELL? I THOUGHT IT WAS TO COMPACT 4 THAT LOL
09:01:40 --- mode: ChanServ set +o Igloo
09:01:43 <Cale> Staos: Make a coherent argument. I find that Haskell is quite practical, while allowing for lots of neat abstractions to save time and effort directly in the language -- the sorts of things other languages end up putting in their IDEs, if they allow them at all.
09:01:47 <Staos> OH NOES
09:01:52 <Nanar> if someone can have a quick a look:
09:01:54 <Nanar> http://mandrivafr.pastebin.com/490397
09:01:59 <Cale> Nanar: sure
09:02:08 --- mode: Igloo set +b *!*@pcp0010570833pcs.epensb01.pa.comcast.net
09:02:12 --- kick: Staos was kicked by Igloo (Igloo)
09:02:49 <Nanar> Cale: it is mainly copy/paste of existing code :) I just start haskell so...
09:03:32 <Cale> Igloo: that was perhaps a little quick, I think. I'd rather have gotten him to try arguing his point and shown him where he was wrong :)
09:03:58 <Igloo> Cale: Personally I'd rather you didn't feed trolls
09:03:58 <Cale> Nanar: hmm, which line of that is the error occuring on?
09:04:15 <Nanar> p <- work my_lex
09:04:39 <Cale> Nanar: ah
09:04:41 <Nanar> Cale: ah no, just beofre
09:04:46 <int-e> indentation?
09:04:59 <Cale> Nanar: untab everything in that block by 2 spaces
09:05:08 <Nanar> int-e: I checked, only space
09:05:25 <Cale> http://mandrivafr.pastebin.com/490403
09:05:29 <int-e> Nanar: as Cale said. the p ought to line up with the work above.
09:06:02 --- mode: ChanServ set +o shapr
09:06:26 <shapr> Igloo: oh, thanks
09:06:27 --- mode: shapr set -o shapr
09:06:32 <Nanar> int-e: aka p just under the d of do ?
09:07:11 <int-e> Nanar: look at Cale's paste. and no, it has to go under the w of work
09:07:44 <int-e> Nanar: (it belongs inside the logical block that starts after the do keyword)
09:08:44 <Nanar> Cale, int-e: a yes many thanks, I still have an error but it is another problem :)
09:09:47 <Nanar> btw indentation is evil
09:10:42 <Nanar> the best thing to is surelly:
09:10:44 <Nanar> readSetProp = do  work my_lex
09:11:05 <Nanar> erf, I mean cutting after do and indent work
09:11:23 <Cale> Nanar: the basic idea is to make things line up, and when things are inside other things, indent them more
09:11:40 <ibid> which is better? ReaderT (IORef State) IO a or StateT State IO a? (the latter is a bit more convenient, but does it generate equivalent or better code?)
09:11:48 <int-e> Nanar: you might want to have a look at http://haskell.org/hawiki/HaskellStyle
09:11:53 <Cale> If all else fails, you can add braces and semicolons
09:12:08 <int-e> Nanar: just for inspiration :)
09:12:10 <Cale> ibid: better?
09:12:49 <ibid> Cale: ok, based on the "goodness" of the generated code
09:13:07 <ibid> object code
09:13:08 <Cale> I'd expect them to be pretty similar.
09:13:26 <Nanar> my vim is set indent per 4 spaces, and it reajust to 4 spaces, so keeping the do alone is better I think
09:13:50 <Cale> If the first does better, just write an instance of MonadState for  ReaderT (IORef s) IO
09:14:13 <Nanar> but, I don't know enought to given lesson :)
09:14:20 <ibid> i mean, IORef is, to my knowledge, implemented directly as mutable cells, while StateT probably is based on the State -> m (a, State) model
09:14:23 <Cale> then they can be used interchangeably with the same interface
09:14:26 <ibid> Cale: hmm, that's a good point
09:14:48 <Cale> You probably should be getting type signatures which are more general anyway :)
09:15:02 <ibid> ?
09:15:08 <SamB> @type Control.Monad.State.StateT
09:15:09 <lambdabot> forall a (m :: * -> *) s.
09:15:09 <lambdabot> (s -> m (a, s)) -> Control.Monad.State.StateT s m a
09:15:20 <Cale> @type Control.Monad.State.get
09:15:22 <lambdabot> forall s (m :: * -> *). (Control.Monad.State.MonadState s m) => m
09:15:22 <lambdabot> s
09:15:47 <ibid> why should i be getting more general types?
09:16:02 <Cale> @type do { x <- get; put (x+1); liftIO $ print x }
09:16:04 <lambdabot> Not in scope: `get'
09:16:04 <lambdabot>  
09:16:04 <lambdabot> <interactive>:1:15: Not in scope: `put'
09:16:25 <Cale> @type do { x <- Control.Monad.State.get; Control.Monad.State.put (x+1); Control.Monad.Trans.liftIO $ print x }
09:16:25 <int-e> @type Control.Monad.State.get
09:16:26 <lambdabot> forall s (m :: * -> *). (Control.Monad.State.MonadState s m) => m
09:16:26 <lambdabot> s
09:16:27 <lambdabot> forall s (m :: * -> *).
09:16:27 <lambdabot> (Control.Monad.Trans.MonadIO m,
09:16:27 <lambdabot> Num s,
09:16:28 <lambdabot> Control.Monad.State.MonadState s m) =>
09:16:30 <lambdabot> m ()
09:16:46 <Cale> sorry for all the qualified names
09:16:47 <ibid> Cale: note that the question is prompted by a specific situation, where i do have a specific State type and a specific reason why the underlying monad is IO
09:17:19 <Cale> But you can see there that the type signature I get for that code is pretty general
09:17:24 <shapr> Igloo , Cale : a bit of google research suggests that Staos is a member of a trolling organization (I kid you not.)
09:17:33 <ibid> Cale: yes, but what's your point?
09:17:51 <SamB> ibid: heard of liftIO?
09:17:57 <ibid> SamB: yes, i'm using it
09:18:04 <Cale> ibid: my point is that you shouldn't be relying on the representation of the state monad you're using anyway, so they should be interchangeable after the fact
09:18:20 --- mode: Igloo set -b *!*@pcp0010570833pcs.epensb01.pa.comcast.net
09:18:24 <ibid> Cale: point which i conceded above :)
09:18:31 <Cale> okay :)
09:18:44 <Cale> I was a bit curious as to why you questioned my comment :)
09:18:49 <ibid> 19:13  <ibid> Cale: hmm, that's a good point
09:18:53 <Cale> yeah
09:19:18 <SamB> ibid: just use a type synonym for your monad stack?
09:19:29 <ibid> Cale: i didn't see how it added anything new, and i was just asking whether i was missing something there :)
09:19:32 <ibid> SamB: i am
09:19:59 <SamB> ibid: then get back to your problem
09:20:07 <ibid> SamB: huh?
09:20:15 <ibid> SamB: ah. i have
09:20:43 <ibid> SamB: i'm currently off hack mode, and i remembered wondering about it, and asked in case somebody had insights
09:20:47 <ibid> (which cale did)
09:21:23 * CosmicRay disappears for lunch
09:21:31 <CosmicRay> Cale: I'd still like to see your code when I get back ;-)
09:21:35 <Cale> What's the minimal string I should stick on something to BSD license it?
09:21:37 <SamB> ah
09:21:44 <Cale> CosmicRay: I'm done :)
09:22:05 <ibid> Cale: you need to put the full license
09:22:14 <ibid> Cale: the BSD license cannot be referred to reliably
09:22:24 <SamB> anyway, I personally suspect that StateT gives better code...
09:22:28 <ibid> (hrm, because "the" is a misnomer here:)
09:22:36 <ibid> SamB: why do you think that?
09:23:15 <SamB> ibid: because the compiler doesn't have to don a biohazard suit to deal with it?
09:23:36 * ibid wishes all the IO functions were in a IO type class, then one could forget about liftIO :)
09:23:48 <ibid> SamB: heh
09:24:14 * int-e agrees with SamB there - there's no speed advantage to be gained from additional operations: storing in and retrieving from an IORef.
09:25:00 <ibid> so, what you two are saying is that emulating a reference is better than using the real thing, because the former does not screw up optimizations?
09:25:21 <int-e> ibid: the values that are passed around are pointers in either case
09:25:25 <ibid> (mutable reference)
09:25:44 <int-e> ibid: using an IORef makes that a pointer to a pointer.
09:25:56 <ibid> int-e: that's not a bad point
09:26:16 <Philippa> OTOH, not using an IORef and faking it with a map makes it a /slowly dereferenced/ pointer to a pointer, assuming I've caught enough context?
09:26:30 <ibid> not using a map
09:26:39 <Philippa> okay. Yeah, for a single layer of state I'm inclined to agree
09:26:53 <Philippa> as soon as you've got anything more complex, references pay off
09:26:59 <ibid> my state in this case is essentially a tuple
09:27:13 <ibid> yeah, i'm using STRefs in the graph data structure that this code will be building
09:27:39 <Philippa> a tuple's not really 'more complex' from the POV I have in mind...
09:27:48 <Philippa> a tree structure might be depending on the update patterns
09:27:55 <Philippa> a graph? Yep, definitely :-)
09:28:06 <ibid> i didn't think it was :)
09:28:22 <ibid> this stuff that i'm talking about here is just the internal state of the code that builds the graph
09:29:12 <ibid> (otoh, it might just be easier to switch to IORefs there, STRef RealWorld is just clumsier to use :)
09:29:51 <ibid> (hmm, but then all my algorithms will be in IO. with STRefs, i can have them pretend to be in other ST monads :)
09:30:17 <Cale> Ugh, even BSD seems too heavyweight for this.
09:30:20 <ibid> thanks all
09:30:58 <ibid> Cale: what i write usually in such situations is "Written by Antti-Juhani Kaijanaho.  You may treat this file as if it were in the public domain."
09:31:25 <Cale> that should do :)
09:31:39 <ibid> (though some people apparently consider this a dangerous license for me to use, as it doesn't disclaim any warranties)
09:31:52 <Philippa> I tend to stick to a BSD license
09:32:06 <ibid> yeah, but that's a lot of verbiage, still :)
09:32:20 <ibid> i usually use a variant of the classical X license
09:32:27 <ibid> when i'm not using the gpl
09:32:39 <Cale> This is a trivial piece of software though :)
09:32:54 <ibid> well, it might not be copyrightable, then :)
09:33:22 <Cale> http://www.haskell.org/hawiki/MonadSupply
09:33:25 <ibid> (but it'd have to be very trivial)
09:33:53 <Cale> I'd call that obvious.
09:34:12 <ibid> okay, that probably is just above the copyright treshold
09:34:39 <Cale> I'd consider it a piece of mathematics.
09:34:53 <ibid> at least here, the basic criterion is, would everyone write a program (or module) that solves the same problem in the same way
09:35:06 <ibid> Cale: that makes it unpatentable. but it's irrelevant to copyright
09:35:15 <ibid> copyright is not about ideas, it's about expression
09:35:15 <Cale> Ah, that's true.
09:35:45 <gour> anyone knows where i can find some code using ghc's Data.Tree ?
09:36:09 <int-e> copyright is irrelevant to independent reimplementation though.
09:36:16 <ibid> yes
09:36:34 <gour> e.g. drawTree...
09:36:45 <Philippa> with copyright, the issue is things like "could I reasonably expect someone else reimplementing it to use the same identifier names?"
09:36:49 <ibid> the standard for copyright is essentially, would an independent reimplementation look the same or not
09:36:51 <gour> unfoldTree..
09:37:56 <SyntaxNinja> w00w00
09:39:09 <int-e> gour: putStrLn $ drawTree $ Node "xxx" [Node "abc" [], Node "def" [Node "xyz" []], Node "qwerty" []]
09:43:59 <int-e> gour: here's one using unfoldTree: putStr $ drawTree $ unfoldTree (\n -> (show n, [m | m<-[2..n-1], n`mod`m==0])) 50   ;-)
09:45:56 <Cale> Does anyone know anything about the progress of the Haskell 1.6/2005 proposal?
09:46:08 <Cale> er
09:46:10 <Cale> 2006 *
09:46:12 <Cale> :)
09:48:11 <Heffalump> I haven't heard anything, but I don't read the list
09:49:13 <gour> int-e: thanks a lot. it's a good kick to let me start and (hopefully) solve that exercises from thompson's book
09:50:30 <Igloo> Heffalump: Which list?
09:51:20 <Cale> I hope that the next Haskell looks more like the previous one :)
09:53:30 <Heffalump> any list :-)
09:53:40 <Heffalump> I meant the Haskell mailing list, though.
09:54:55 <Cale> How about the following translation of do:  Barring an explicit type signature, translate the do block naïvely as lambdas, then check the inferred type. If a typeclass constraint of MonadZero can be inferred, rewrite the do-block such that pattern match failures are written to use mzero. If MonadError can be inferred, rewrite the pattern match failures to reply with a meaningful string error message.
09:56:09 <Cale> That is, you'd infer the type of the do block based on the naïve translation, and then rewrite it with a more specific one in those special cases.
09:59:58 <Heffalump> you can't do that, noone will be able to predict whether mzero or fail gets called
10:00:14 <Heffalump> shouldn't fail be mzero in any MonadZero anyway? And likewise shouldn't fail DTRT in MonadError?
10:00:14 <Cale> It's quite predictable.
10:00:44 <Heffalump> no, it could be changed by an instance declaration far away
10:00:48 <int-e> heh. unfolding trees is fun. > putStr $ drawTree $ fmap (:[]) $ evalState (unfoldTreeM (\_ -> get >>= \(a:as) -> put as >> if a =='`' then return (a,[(),()]) else return (a,[])) ()) "```sii``sii"
10:00:51 <Heffalump> if the whole thing infers as monad Foo
10:01:03 <Heffalump> then the translation will depend on whether Foo is an instance of MonadZero or not
10:01:35 <Heffalump> not only that, but you probably break referential transparency
10:01:50 <Heffalump> or at least referential transparency + some obvious laws about merging do blocks
10:01:52 <Cale> If an instance of MonadZero isn't visible, then it can't be rewritten in terms of mzero
10:02:12 <Heffalump> so the behaviour of something will depend on whether or not an instance is visible..
10:02:16 <Cale> Forward instances of MonadZero should not affect it
10:02:27 <Heffalump> sorry?
10:02:28 <Cale> only imported instances and instances in the module itself
10:02:48 <int-e> Cale: there will always be the problem of separate compilation and the possibility of adding instances afterwards
10:03:05 <int-e> Cale: thus, with such a rule, the same code can have different results in different modules.
10:03:23 <Cale> Well, yes. It already can.
10:03:54 <Cale> (I think)
10:04:27 <Heffalump> so if you abstract a block of code into an imported module, its behaviour might change
10:04:30 <Heffalump> I doubt that's already true
10:04:51 <Cale> hmm...
10:05:57 <Cale> Well, the instances which are visible at any module will affect the way that things work. You could move code from one module to another where different instances are visible and have the meaning of the code change.
10:06:14 <Heffalump> yes, but then you are explicitly using the instance
10:06:32 <Heffalump> also, you'll notice you have different instances if you end up with both in the same compilation
10:06:47 <Heffalump> I don't even understand what problem you are trying to solve here.
10:07:28 <Cale> Well, I think that the inclusion of fail in the Monad class is a pretty ugly way to solve the problem.
10:07:58 <int-e> I guess the point is that the way pattern matching is implemented every monad is an instance of MonadZero ;)
10:08:23 <Cale> Yeah, with often broken implementations of the zero
10:08:38 <int-e> so we should rename the fail to mzero, perhaps.
10:09:14 <Cale> Well, my point is that monads don't have an inherent zero.
10:09:15 <Heffalump> a more reasonable suggestion would be to translate any do block with a potential pattern match failure to use mzero (and thus force there to be a MonadZero constraint)
10:09:39 <Cale> ah, that's decent
10:09:39 <Heffalump> well, they do, its called _|_
10:10:05 <mwc> Is _|_ identical semantically to Haskell's undefined ?
10:10:06 <Heffalump> the behaviour where the default zero is _|_ but can be overriden is a bit ugly, I agree.
10:10:08 <Cale> I don't accept that as non-broken :)
10:10:09 <Heffalump> mwc: yes
10:10:30 <Heffalump> Cale: but it is the zero. Execution of the monadic code "fails", so the program fails.
10:10:49 <Heffalump> it obeys the laws you'd expect, too
10:11:26 <Heffalump> I've always found it a bit ugly, but actually now I think about it carefully I don't think it is.
10:12:09 <Cale> what about m >>= \_ -> mzero = mzero ?
10:12:10 <Heffalump> Normal pattern matching failure results in bottom. Do notation introduces a new semantic domain why you have the opportunity to handle it differently.
10:12:39 <Cale> that's not going to be satisfied by IO
10:12:54 <Cale> or any monad for which failure isn't explicitly represented
10:12:57 <Philippa> I don't like fail for pattern match failure because of the type, I guess
10:13:23 <Philippa> I'm not sure mzero is appropriate for all failure in all monads though?
10:13:27 <Heffalump> cale: why isn't it satifisfied for non-IO?
10:13:32 <Philippa> (or even all /catchable/ failure)
10:13:45 <Cale> Heffalump: How about State?
10:13:51 <Cale> That's not going to be able to satisfy that
10:14:08 <Heffalump> who can observe the state?
10:15:17 <Heffalump> I think it's ok for IO too, it's fine for a program that results in _|_ to do random stuff first.
10:15:26 <Heffalump> (semantically speaking, that is)
10:17:04 <Philippa> up to and including starting rogue, right?
10:17:09 <Cale> hehe
10:18:14 <Heffalump> Philippa: yes, but I think the dungeon would have to collapse at some point.
10:20:54 <Cale> anyway, I think that accepting undefined as a valid way to make types instances of classes is a bit disingenuous.
10:22:00 <palomer> ugh
10:22:08 <palomer> getting types and programming languages is turning out to be a challenge
10:22:13 <palomer> and it's a required text book for my class!
10:22:25 <Cale> palomer: Chapters doesn't have it?
10:22:37 <palomer> I would doubt it, they never have text books
10:22:43 <palomer> (or do you mean chapters.ca?)
10:22:50 <Cale> Chapters.ca
10:22:59 <Cale> is where my dad got my copy
10:23:12 <Heffalump> cale: why?
10:23:12 <Cale> (got it as a present this christmas)
10:23:30 <palomer> I'm not willing to wait weeks!
10:24:00 <shapr> palomer: You could drive to pennsylvania.
10:24:34 <Philippa> Cale: I think it's perfectly acceptable /if it's acceptable for that class/
10:24:52 <Philippa> for defining failure modes it seems a perfectly sensible thing to do
10:25:05 <Philippa> (how else is the identity monad supposed to define fail?)
10:25:14 <Heffalump> am I allowed to use let { f n | n `mod` 2 == 0 = n `div` 2 ; f n = 3*n+1 } in fix f to implement a class member?
10:25:15 <Cale> It's not supposed to define fail
10:25:23 <Cale> There's no failure in the identity monad
10:25:31 <Philippa> yes there is. There's just no way to catch it
10:25:41 <Heffalump> yes there is, there's failure in "normal" code
10:25:52 <Heffalump> so there must be failure in the identity monad
10:26:11 <Heffalump> actually, one argument against the model is that it only gives you a way of catching some failures.
10:26:14 <Cale> Well, the identity monad introduces no further notion of failure than that already present in the underlying type.
10:26:35 <Heffalump> pattern matches in do syntax have different zero characteristics to pattern matches in normal expressions
10:26:40 <int-e> @type let { f n | n `mod` 2 == 0 = n `div` 2 ; f n = 3*n+1 } in fix f
10:26:41 <lambdabot> Not in scope: `fix'
10:26:49 <int-e> @type let { f n | n `mod` 2 == 0 = n `div` 2 ; f n = 3*n+1 } in Control.Monad.Fix.fix f
10:26:50 <lambdabot> forall a. (Integral a) => a
10:27:04 <palomer> cool, we're going to learn about de bruijn in class
10:27:16 <Heffalump> int-e: errm, I didn't quite mean that function, you have to give it some value to start with
10:27:26 <Philippa> palomer: better to get the book a couple of weeks late and cram than to never get the book, is all the advice I'm going to give
10:27:33 <Heffalump> my point was that we don't know whether that function produces _|_ or not
10:27:39 <Heffalump> but it does something that you might consider useful
10:27:40 <int-e> Heffalump: I thought you wanted some clever way of writing 'undefined'
10:27:44 <palomer> Philippa: I need the book for the assignments
10:27:56 <Heffalump> no, I wanted a clever way of writing something whose undefinedness was unknown :-)
10:28:03 <Heffalump> s/clever //
10:28:49 <Philippa> palomer: ouch
10:29:10 <int-e> Heffalump: takeWhile (/=1) $ iterate f <n> then
10:29:13 <Philippa> that's something I do find really *stupid* in courses: requiring students to obtain textbooks in order to be able to do the course at all
10:29:38 <Philippa> Heffalump: just use a function 'halting' :-)
10:29:50 <palomer> @hoogle (/=)
10:29:52 <lambdabot> No matches found
10:30:00 <palomer> @type (/=)
10:30:02 <lambdabot> forall a. (Eq a) => a -> a -> Bool
10:30:24 <int-e> . o O ( let f = if halting f then fix id else () in halting f )
10:30:29 <palomer> well, the actual bookstore doesn't have it
10:30:36 <Cale> Using something that's at least sometimes defined is better than using something which is just obviously undefined.
10:30:53 <int-e> > fix not
10:30:55 <lambdabot> Exception: <<loop>>
10:31:00 <palomer> @type not
10:31:02 <lambdabot> Bool -> Bool
10:31:22 <palomer> whoa, lambdabot can dectect loops?
10:31:28 <Cale> ghc can
10:31:31 <int-e> stg can
10:31:32 <palomer> > fix and
10:31:34 <lambdabot> Couldn't match `[Bool]' against `Bool'
10:31:35 <Cale> yeah
10:31:45 <int-e> probably the g-machine does, too.
10:31:48 <palomer> @type and
10:31:50 <lambdabot> [Bool] -> Bool
10:31:57 <palomer> > True and False
10:31:59 <lambdabot>   The function `True' is applied to two arguments,
10:31:59 <lambdabot>   but its type `Bool' has none
10:31:59 <lambdabot>   In the definition of `mix': mix = True and False
10:32:06 <int-e> > True && False
10:32:08 <lambdabot> False
10:32:09 <Cale> When you force a thunk, you replace the code pointer with a pointer to a black hole which fails with that exception.
10:32:13 <int-e> > and [True, False]
10:32:14 <lambdabot> False
10:32:18 <palomer> > fix (&&)
10:32:19 <lambdabot>   Expecting a function type, but found `a'
10:32:19 <lambdabot>   Expected type: Bool -> Bool
10:32:19 <lambdabot>   Inferred type: Bool -> Bool -> Bool
10:32:44 <Cale> That way, if the thunk is reentered, the program stops immediately, because it must be an infinite loop.
10:32:45 <palomer> > fix (+1)
10:32:47 <lambdabot> Exception: <<loop>>
10:32:57 <int-e> > fix (const 3)
10:32:59 <lambdabot> 3
10:33:31 <palomer> > fix abs
10:33:33 <lambdabot> Exception: <<loop>>
10:33:39 <palomer> abs does have a fixed point!
10:33:43 <palomer> > abs 0
10:33:44 <lambdabot> 0
10:33:48 <int-e> palomer: yes, but fix can't find it
10:34:03 <palomer> is there a better fixed point operator than fix?
10:34:04 <Cale> @type fix
10:34:06 <lambdabot> Not in scope: `fix'
10:34:18 <Cale> @type Control.Monad.Fix.fix
10:34:20 <lambdabot> forall a. (a -> a) -> a
10:35:22 <Cale> Polymorphic functions aren't allowed to observe the representations of types which they're instantiated at.
10:35:22 <int-e> > fix (\(a,b,c,d,e,f) -> (1,a,b,c,d,e))
10:35:23 <lambdabot> Exception: <<loop>>
10:35:38 <int-e> > fix (\~(a,b,c,d,e,f) -> (1,a,b,c,d,e))
10:35:39 <lambdabot>  parse error on input `->'
10:35:49 <palomer> what's \~x -> e?
10:35:59 <Cale> So there's no way for fix to even know that there's a value called 0.
10:36:21 <ibid> palomer: lazy pattern
10:36:32 <int-e> > fix (\ ~(a,b,c,d,e,f) -> (1,a,b,c,d,e))
10:36:33 <lambdabot> (1,1,1,1,1,1)
10:36:53 <Cale> palomer: x will be evaluated to see if it matches only if it's actually needed
10:37:09 <Cale> well, the parameter to the lambda will be
10:37:21 <Cale> It's more interesting when the pattern has a little structure to it
10:38:05 <Cale> > fix (\(a,b,c,d,e,f) -> (1,a,b,c,d,e))
10:38:07 <lambdabot> Exception: <<loop>>
10:38:16 <int-e> in this case it's required to make the first 'call' to that function succeed.
10:38:21 <int-e> I think.
10:38:29 <palomer> can someone give me an example where it differs?
10:38:39 <Cale> that's an example right there
10:38:42 <Cale> > fix (\(a,b,c,d,e,f) -> (1,a,b,c,d,e))
10:38:44 <lambdabot> Exception: <<loop>>
10:38:45 <Cale> > fix (\~(a,b,c,d,e,f) -> (1,a,b,c,d,e))
10:38:46 <lambdabot>  parse error on input `->'
10:38:50 <Cale> > fix (\ ~(a,b,c,d,e,f) -> (1,a,b,c,d,e))
10:38:52 <lambdabot> (1,1,1,1,1,1)
10:39:08 <palomer> whoa, how does that work?
10:39:28 <Cale> well, with the lazy pattern, 'a' isn't bound until required
10:39:30 <Heffalump> magic of lazy evaluation
10:39:31 <ibid> it's essentially the same as
10:39:37 <Cale> > fix (\ ~(a,b) -> (1,a))
10:39:38 <int-e> > let (a,b,c,d,e,f) = (1,a,b,c,d,e) in (a,b,c,d,e,f)
10:39:39 <lambdabot> (1,1)
10:39:40 <lambdabot> (1,1,1,1,1,1)
10:39:47 <Cale> let's look at the smaller version
10:39:50 <ibid> > let a@(a,b,c,d,e,f) = (1,a,b,c,d,e) in a
10:39:50 <Cale> > fix (\ (a,b) -> (1,a))
10:39:51 <lambdabot>   Conflicting definitions for `a'
10:39:51 <lambdabot>   In the binding group for: a, a, b, c, d, e, f
10:39:52 <lambdabot> Exception: <<loop>>
10:40:00 <ibid> > let p@(a,b,c,d,e,f) = (1,a,b,c,d,e) in p
10:40:01 <lambdabot> (1,1,1,1,1,1)
10:40:07 <Cale> the lazy pattern version is equivalent to
10:40:20 <ibid> (let implicitly adds the ~ to the pattern)
10:40:29 <Cale> > fix (\ pair -> (1,fst pair))
10:40:30 <lambdabot> (1,1)
10:41:21 <Heffalump> repmin is a cool example of that kind of trick
10:41:31 <palomer> Cale: and the non lazy version?
10:42:22 <Cale> > fix (\ pair -> case pair of (a,b) -> (1,a))
10:42:24 <lambdabot> Exception: <<loop>>
10:44:14 <Cale> case forces evaluation (in fact, apart from seq, and the execution of IO (however the RTS decides to implement it), case is the only thing which causes evaluation of any kind to occur.
10:44:23 <Cale> )
10:44:25 <Cale> hehe
10:44:28 <palomer> whoa
10:44:33 <palomer> case isn't lazy
10:44:38 <Cale> right
10:44:39 <palomer> so ~ is a lazy case
10:44:42 <Cale> right
10:44:50 <Cale> lazy pattern
10:44:52 <palomer> why isn't case lazy?
10:44:56 <Heffalump> Cale: what about strict datatypes?
10:44:57 <ibid> ~ is lazy _pattern_
10:45:00 <Heffalump> palomer: because it can't be
10:45:07 <ibid> palomer: case is the only place where evaluation happens
10:45:17 <Heffalump> case xs of { [] -> ... ; _:_ -> ... } requires xs to be evaluated
10:45:21 <ibid> palomer: ... after sugar is taken off
10:45:28 <Heffalump> at least to find out if it is [] or :
10:46:12 <Cale> Heffalump: yeah, strict datatypes too, I suppose
10:46:47 * Heffalump asked a question this morning about making a strict Map but didn't get any answer
10:47:08 <Heffalump> if I want a Map that is strict in its elements, is there any way short of deepSeq I can get one from the existing Map?
10:47:10 <Cale> case is the core language's way to express evaluation
10:47:28 <palomer> I still don't understand why case can't be lazy
10:47:42 <Heffalump> palomer: how would you evaluate the case statement above lazily?
10:47:51 <Cale> palomer: It can be, but you don't want it to be lazy too when it's your only form of evaluation :)
10:48:27 <Cale> cases with more than one branch would become meaningless
10:48:42 <Cale> well, they'd be equivalent to cases with just one branch
10:48:47 <palomer> well, the only thing that would evaluate is the RTS
10:48:58 <palomer> Cale: why would they become meaningless?
10:49:00 <Cale> another name for patterns with ~ is irrefutable patterns
10:49:40 <Cale> > (\ [] -> 5) [1,2,3]
10:49:42 <lambdabot>  Non-exhaustive patterns in lambda
10:49:45 <Cale> > (\ ~[] -> 5) [1,2,3]
10:49:47 <lambdabot> 5
10:49:53 <ibid> Cale: i though irrefutable pattern is a common name for ~, x and _ patterns?
10:50:05 <Cale> ibid: ah, yeah
10:50:16 <ibid> +t :)
10:50:20 <basti_> i didnt know ~!
10:50:20 <Cale> well, they're a specific case of irrefutable patterns anyway :)
10:50:34 <palomer> ok, someone give me a case where lazy case would differ from non lazy case (except infinite looping)
10:50:47 <Cale> > case [1,2,3] of ~[] -> 5; ~(x:xs) -> x
10:50:49 <lambdabot> 5
10:50:52 <basti_> and, why would someone call _ irrefutable?
10:50:55 <Cale> there you go :)
10:51:07 <Cale> there's lazy case doing exactly what you don't want :)
10:51:13 <basti_> hmm ah yes you would ok.
10:51:19 <ibid> basti_: because a) it doesn't force evaluation and b) it cannot be refuted:)
10:51:22 * basti_ was just confused about the word
10:51:40 <Cale> > case [1,2,3] of ~(x:xs) -> x; ~[] -> 5 
10:51:41 <lambdabot> 1
10:51:48 <ibid> a refutable pattern is one that can fail to match
10:51:49 <basti_> ibid: well i was thinking like: if you match [x] against [], you refute it (and break), but probably that's not the intended meaning.
10:52:00 <Cale> > case [1,2,3] of ~[] -> 5; ~(x:xs) -> x -- let's see that one again :)
10:52:02 <lambdabot> 5
10:52:11 <ibid> basti_: well, [x] is a refutable pattern :)
10:52:16 <basti_> uhm.
10:52:30 <ibid> (note the missing _ir_:)
10:52:34 <basti_> yea
10:52:37 <Cale> palomer: see why you don't want it to be lazy?
10:53:19 <basti_> > let [x]=[1,2,3] in x
10:53:21 <lambdabot>  Irrefutable pattern failed for pattern [x]
10:53:27 <basti_> hmmm
10:53:29 <ibid> basti_: let adds an implicit ~
10:53:56 <Cale> yeah, that's called a pattern binding, and they're irrefutable by default
10:54:01 <ibid> basti_: let [x]=[1,2,3] in x is desugared to case [1,2,3] in ~[x] -> x
10:54:10 <int-e> > (\True -> False) False
10:54:11 <lambdabot>  Non-exhaustive patterns in lambda
10:54:17 <int-e> > (\ ~True -> False) False
10:54:18 <lambdabot> False
10:54:35 <Cale> > let True = False in True
10:54:35 <ibid> case ... of, of course :)
10:54:37 <lambdabot> True
10:54:42 <xerox> const ~x _ = x -- then ?
10:55:00 <basti_> ibid: hmmm
10:55:05 <ibid> xerox: a variable pattern is already lazy, no need for the ~
10:55:45 <palomer> Cale: case [1,2,3] of ~[] -> 5 <--how does this work?
10:56:31 <Cale> none of the variables mentioned in ~[] (well, there are none) are ever needed, so it just continues on its merry way never evaluating [1,2,3]
10:56:44 <Cale> that is, it's lazy
10:57:16 <palomer> > case  [1,2,3] of ~[a] -> a
10:57:18 <lambdabot>  Irrefutable pattern failed for pattern [a]
10:57:35 <palomer> Cale: so it only differs when it need not be evaluated (which is only when there are no bound variables)
10:57:36 <int-e> > case  [1,2,3] of ~[a] -> 42
10:57:38 <lambdabot> 42
10:57:40 <palomer> > case  [1,2,3] of ~[_] -> 5
10:57:42 <lambdabot> 5
10:58:00 <Cale> palomer: just not using any variables is good enough
10:58:12 <palomer> Cale: are there any other cases where it differs?
10:59:01 <ibid> you know, the difference between eager and lazy evaluation is that the latter succeeds more often than the former; when they both succeed, they get identical results
10:59:06 <Cale> > case [1] of ~(x:y:xs) -> 5; ~(x:xs) -> x
10:59:08 <lambdabot> 5
10:59:17 <Cale> > case [1] of (x:y:xs) -> 5; (x:xs) -> x
10:59:19 <lambdabot> 1
10:59:51 <Cale> there are lots of cases. Basically, making the first pattern lazy makes it the only pattern which matters.
11:00:02 <Cale> all the others will be ignored from that point on
11:00:27 <Cale> after all, it's irrefutable, so nothing else will ever get a chance
11:00:43 <palomer> what if there's a free variable on both the lhs and rhs
11:00:47 <palomer> can lazy and strict differ?
11:00:59 <Cale> lazy will just fail when the pattern doesn't match
11:01:07 <Cale> > case [1] of (x:y:xs) -> x; (x:xs) -> x
11:01:09 <lambdabot> 1
11:01:13 <Cale> > case [1] of ~(x:y:xs) -> x; (x:xs) -> x
11:01:15 <lambdabot>  Irrefutable pattern failed for pattern (x : y : xs)
11:01:17 <resiak> Where could I look up what ~ does ?
11:01:28 <ibid> resiak: the report
11:01:34 <resiak> ibid: That's a good point.
11:01:36 <Cale> resiak: the Gentle introduction also does a nice job of describing it
11:01:38 <ibid> resiak: though it's defined rather technically
11:01:41 * resiak digs it out.
11:01:56 <Philippa> the report's useful
11:01:57 <int-e> > case [1] of (x:~(y:xs)) -> x; (x:xs) -> x
11:01:58 <lambdabot>  Not in scope: data constructor `:~'
11:02:04 <int-e> > case [1] of (x: ~(y:xs)) -> x; (x:xs) -> x
11:02:05 <Philippa> it's the only place I've seen the layout rule clearly defined
11:02:05 <lambdabot> 1
11:02:20 <ibid> but it's in an appendix even there
11:02:35 <int-e> > case [] of (x: ~(y:xs)) -> x; [] -> 42
11:02:36 <lambdabot> 42
11:02:49 <palomer> is it possible to make case fully lazy?
11:02:58 <palomer> > case undefined of ~[] -> 5
11:03:00 <lambdabot> 5
11:03:08 <palomer> case undefined of [] -> 5
11:03:16 <palomer> > case undefined of _ -> 5
11:03:18 <lambdabot> 5
11:03:34 <ibid> palomer: what do you mean by "make case fully lazy"?
11:03:50 <palomer> ibid: it doesn't evaluate it's argument
11:04:22 <palomer> case  fix (+1) of _ -> 5
11:04:31 <palomer> > case  fix (+1) of _ -> 5
11:04:33 <lambdabot> 5
11:04:41 <ibid> palomer: just use lazy patterns
11:05:01 <palomer> so as soon as you have a non lazy pattern, it evaluates its argument?
11:05:08 <palomer> even if there are lazy patterns before?
11:05:12 <ibid> palomer: it finds its WHNF
11:05:33 <ibid> palomer: if the pattern is tested, the scrutinee is evaluated to WHNF
11:05:39 <palomer> ibid: probably more than just the WHNF if the pattern is more complicated
11:05:43 <ibid> case does not force it all the way to normal form
11:05:46 <ibid> palomer: well, yes
11:06:06 <palomer> > case  fix (+1) of x -> 5
11:06:07 <lambdabot> 5
11:06:13 <ibid> palomer: the way to think about is, all complicated patterns are desugared into nested cases
11:06:22 <ibid> palomer: after that, it works as i said :)
11:06:30 <r3tex> how come fromInt  Int -> Float doesn't work ? do i need to import it?
11:06:47 <int-e> r3tex: use fromIntegral
11:06:50 <palomer> > let fac x = fac (x*x) in case fac 5 of _ -> 5
11:06:52 <lambdabot> 5
11:06:55 <palomer> > let fac x = fac (x*x) in case fac 5 of 4 -> 5
11:07:07 <lambdabot> Terminated
11:07:07 <r3tex> int-e:  aha, book is outdated?
11:07:13 <int-e> @index fromInt
11:07:14 <lambdabot> bzzt
11:07:16 <palomer> > let fac x = fac (x*x) in case undefined of 4 -> 5
11:07:18 <int-e> @index fromInteger
11:07:21 <ibid> r3tex: which book?
11:07:21 <lambdabot> Undefined
11:07:21 <lambdabot> Prelude
11:07:32 <palomer> hrm, isn't an infinite loop and undefined semantically equivalent?
11:07:38 <int-e> @type fromInteger
11:07:40 <lambdabot> forall a. (Num a) => Integer -> a
11:07:43 <int-e> @type fromIntegral
11:07:44 <lambdabot> forall b a. (Num b, Integral a) => a -> b
11:07:45 <ibid> palomer: yes
11:07:53 <r3tex> ibid:  The craft of functional programming
11:08:00 <int-e> fromIntegral is more general. I've never heard of fromInt.
11:08:00 <ibid> r3tex: which edition?
11:08:08 <ibid> fromInt is obsolete, i think
11:08:11 <palomer> ibid: but one expression gives me Terminated while the other gives me undefined
11:08:14 <ibid> from 1.4 or 1.3
11:08:21 <xerox> > case fix (+1) of _ -> 5
11:08:22 <lambdabot> 5
11:08:24 <xerox> Foo.
11:08:29 <ibid> palomer: well, ghc has the ability to distinguish between different bottoms :)
11:08:48 <palomer> > case (let fac x = fac (x*x) in case undefined of 4 -> 5) of _ -> 5
11:08:50 <lambdabot> 5
11:08:53 <int-e> > error "Fancy error"
11:08:54 <lambdabot> Add a type signature
11:08:57 <int-e> > error "Fancy error" :: Int
11:08:58 <palomer> > case (let fac x = fac (x*x) in case fac 5 of 4 -> 5) of _ -> 5
11:08:58 <lambdabot> Exception: Fancy error
11:08:59 <xerox> > let fac x = x*x in case fac 2 of 4 -> 4
11:09:00 <lambdabot> 5
11:09:01 <lambdabot> 4
11:09:37 <xerox> > let fac x = fac x*x in case fac 2 of x | (x>4) -> x
11:09:39 <lambdabot> Exception: stack overflow
11:09:49 <palomer> xerox: how did of 4-> 4 work?
11:10:03 <xerox> palomer: it was fac x = x*x :-)
11:10:20 <palomer> oh
11:10:33 <palomer> is it possible to match against undefined and nothing else?
11:10:49 <xerox> Does it make any sense?
11:10:51 <xerox> @type undefined
11:10:53 <lambdabot> forall a. a
11:10:58 <ibid> palomer: no, not really
11:11:08 <xerox> It means *every* value.
11:11:18 <palomer> every value?
11:11:37 <sjanssen> xerox: I think it means that it's a member of all types
11:11:44 <r3tex> ibid:  second edition
11:11:52 <r3tex> :p am i oldschool
11:12:00 <palomer> but wait, the exception handling in haskell lets you deal with undefined
11:12:04 <palomer> but not infinite loops!
11:12:05 <Philippa> to match against undefined requires solving the halting problem
11:12:15 <palomer> Philippa: that's what  Iwas thinking
11:12:18 <ibid> r3tex: hmm, that ought to be reasonably up to date
11:12:22 <Philippa> it lets you deal with /some kinds/ of undefined
11:12:28 <r3tex> ibid:  ah whatever =)
11:13:18 <palomer> Philippa: so some kinds of undefined are semantically different from the infinite loop?
11:13:49 <Philippa> palomer: FCVO 'semantically' that apply from the context of whatever's doing the evaluating rather than the functions themselves
11:14:02 <Philippa> for example, pattern-match failure
11:14:34 * CosmicRay returns
11:16:05 <palomer> Philippa: I mean in haskell
11:16:09 <ibid> CosmicRay: hmm, now that i remember, you might want to change my rss feed address again, what i gave you includes my finnish posts too (my mistake)
11:16:15 <Philippa> palomer: so do I
11:16:28 <Philippa> it's the IO monad (which knows what the haskell implementation looks like) that does all the catching
11:16:44 <palomer> ahh
11:16:50 <CosmicRay> ibid: could you drop me an e-mail?
11:17:00 <palomer> gotcha
11:17:05 <ibid> CosmicRay: i'll try to remember :)
11:21:39 <xerox> sjanssen: a value of non-constrained type 'a', is a value of all the types.
11:22:06 <xerox> For that reason, error has type forall a. String -> a
11:25:49 <sjanssen> xerox: but it isn't really all types
11:25:59 <sjanssen> xerox: correction: it isn't really all values
11:26:24 <palomer> yeah, that's what I was objecting to before
11:32:08 <xerox> Hmm.
11:33:29 <xerox> I think Cale said that a value of type forall a. a is usually something that either stops your program, or make it behave in some way, when, for example, Exceptions are involved.   Correct me please :-)
11:33:50 <int-e> it's semantically bottom
11:33:58 <ibid> values of type forall a. a are nasal demonifiers :)
11:34:20 <xerox> What's the wordy explanation of 'it's semantically bottom' ?
11:34:26 <araujo> Hello.
11:34:29 <sjanssen> xerox: one can say that, because you can't write anything else thats a member of all types
11:35:11 <int-e> why? the value of a term of type forall a.a has to inhabit all types - that includes phantom types (data x) that have no value besides bottom. bottom is the value used in the semantics for the value of infinite computations and errors.
11:35:38 <xerox> That's what I said, right?
11:35:43 <int-e> xerox: yes
11:35:47 <xerox> Great.
11:35:55 <int-e> xerox: I wanted to confirm what you said :)
11:36:20 <xerox> I wanted to confirm that you wanted to confirm what you said :)  No, I dind't.  <hug>
11:37:05 <sjanssen> what are we confirming? "a value of non-constrained type 'a', is a value of all the types."?
11:37:44 <xerox> Yes, that, and the fact that the computations that behave strangely have that type.
11:37:52 <SamB> is DEVELOPING any kind of convention?
11:37:59 <xerox> Pass me the term, I'm running to dinner :-)  Later.
11:38:53 <sjanssen> SamB: are you talking about the Conjure source?
11:40:00 <SamB> sjanssen: well. actually I was wondering if there was a convention for files like that
11:40:38 <sjanssen> SamB: I dunno.  I think I've seen HACKING or something like that before
11:41:13 <SamB> yeah, me too
11:41:41 <shapr> It came from pugs' READTHEM
11:42:06 <shapr> But I think the convention is clear enough.
11:43:03 <SamB> shapr: I didn't ask about READTHEM, your telepathic powers must be leaking again
11:43:39 <sjanssen> SamB: would a rewrite of the Data.LRU module with faster data structures be useful?
11:44:01 <sjanssen> SamB: seems everything is O(n) right now, I think I can do it in O(log n)
11:45:33 <SamB> sjanssen: figuring out what Lemmih has done would be useful, actually
11:46:05 <SamB> and figuring out why Lemmih has broken the Makefile
11:46:43 <shapr> Hm, someone updated conjure to use cabal, who was that?
11:46:51 <CosmicRay> GC question.  Let's say I have two records.  Both contain a ForeignPtr, and in addition, one of the fields of the second record holds the first record.  Is there any case in which the ForeignPtr of the first record could be finalized before that of the second?
11:47:05 <sjanssen> SamB: I'm afraid I know very little about Conjure as a whole, so I probably can't help much
11:48:33 <shapr> Mmm, man I love Sambal Olek.
11:48:44 <SamB> Lemmih moved everything around and it makes my head spin...
11:49:17 <Heffalump> CosmicRay: I don't know the specifics of the GHC GC, but imagine both records go dead at the same time.
11:49:17 <SamB> worse, its all in just Lemmih's repo.
11:49:33 <Heffalump> (cos the only pointer to the first record was the second record, that then goes dead, say)
11:49:49 <CosmicRay> Heffalump: I know that this owuldn't be the case in Python's, where the first wouldn't be considered dead until the second has been finalized
11:49:49 <Heffalump> then I don't see any reason why the ForeignPtrs might not be finalized in an arbitrary order
11:50:01 <CosmicRay> the pointer to the first wouldn't really be dead until the second was removed in python.
11:50:17 <Heffalump> but the ForeignPtr and the pointer to the other record are separate members of the record
11:50:47 <Heffalump> I don't see any obvious relationship between them that would force the GC to consider the pointer live until the ForeignPtr was finalized.
11:51:03 <CosmicRay> ah, I think I see what you're saying.
11:51:27 * SamB decides to go through Lemmih's stuff one patch at a time and merge it with his own
11:51:46 <SamB> oh. anyone know where (Conjure) can get a mailing list?
11:51:52 <SamB> s/where/where we/
11:52:15 <Heffalump> SamB: mailman do?
11:52:19 <CosmicRay> I also don't really understand the point of touchForeignPtr.
11:52:39 <Heffalump> CosmicRay: isn't it for foreign stuff to indicate to the Haskell GC that it has a reference to it?
11:52:40 <SamB> Heffalump: you mean would it do?
11:52:45 <SamB> sure, doesn't everyone use mailman?
11:52:48 <Heffalump> (guessing from the name, I can't remember the details)
11:52:54 <r3tex> ((x+y+z)/3 < x) && ((x+y+z)/3 < y)      gives me     Instance of Fractional Int required for definition....  what have I done wrong?
11:52:56 <Heffalump> SamB: yeah. I can give you one, then.
11:52:57 <CosmicRay> touchForeignPtr :: ForeignPtr a -> IO ()
11:52:57 <CosmicRay> This function ensures that the foreign object in question is alive at the given place in the sequence of IO actions. In particular withForeignPtr does a touchForeignPtr after it executes the user action. 
11:53:07 <CosmicRay> I don't really understand the need for this.
11:53:28 <Heffalump> ah, I see
11:53:37 <Heffalump> to ensure that the GC doesn't clean it up while the user action is running, then.
11:53:47 <Heffalump> which it might, since there is no Haskell reference to it
11:54:10 <Heffalump> SamB: (same place that hosts the debian-haskell mailing list)
11:55:06 <SamB> keeps the ForeignPtr going dead while just the Ptr is referenced, I suppose...
11:55:14 <SamB> Heffalump: oh?
11:55:20 <CosmicRay> SamB: yeah, that makes sense.
11:55:53 <SamB> +from (for posterity)
11:56:12 <SamB> (also, posterity, it might be a waste of time to read these logs)
11:56:22 <Philippa> heh, I think touchForeignPtr would break my brain in most other languages, in a "How the hell does that work?" kinda way
11:56:29 <Heffalump> samb: as in, I part-own a colo'd machine that could host the mailing list if you want. It already hosts the debian-haskell mailing list.
11:56:46 <SamB> Heffalump: that would be nice
11:57:10 <Heffalump> what would you like the list to be called?
11:57:16 <Philippa> (I'd expect an alloc/release type setup)
11:57:18 <Heffalump> conjure@lists.urchin.earth.li ?
11:57:35 <SamB> sure
11:57:55 <Heffalump> (you might want conjure-something if you forsee the need for other somethings in future)
11:58:18 <SamB> well, if we became that popular we'd probably move the list elsewhere anyway
11:59:03 <Heffalump> ok
12:05:07 <rep> did you know taht panama is the only place in the world where you can see the sun rise in the atlantic ocean and set in the pacific ocean?
12:05:10 <rep> wrong chan
12:05:26 <Heffalump> not the tip of Chile, then?
12:05:31 <Heffalump> is it some other ocean by then?
12:05:38 <rep> hm
12:05:47 <rep> i'm not sure actually
12:05:51 <rep> good point
12:08:07 <astrolabe> I've been asked to give a presentation about haskell at work.  Does anyone know of any other haskell presentations I might steal from?
12:08:26 <Heffalump> astrolabe: what kind of presentation?
12:09:07 <astrolabe> I keep telling them that haskell's types are much nicer than C++'s, and I think I've made them curious.
12:09:21 <astrolabe> Just a half a dozen people I think.
12:09:27 <Heffalump> ok, so introductory
12:09:30 <Heffalump> I don't know of any, sorry.
12:09:38 <astrolabe> Yes introductory.
12:09:50 <astrolabe> thanks anyway.
12:09:51 <Heffalump> I suggest you pick some nasty C++ from code you all work on, and show equivalents in Haskell.
12:10:06 <astrolabe> That's a good idea.
12:10:43 <davidw_> autrijus did a haskell presentation for some perl people
12:11:11 <Heffalump> oh, good point
12:11:19 <astrolabe> hmmm, does he have a web site?
12:11:53 <sjanssen> is there any advantage to using a newtype with a big tuple over using data with a single constructor?
12:12:05 <Heffalump> http://www.pugscode.org/osdc/haskell.xul
12:12:15 <astrolabe> thanks
12:12:16 <Heffalump> sjanssen: I was wondering the same thing a day or two ago.
12:12:20 <Heffalump> I think the answer is no.
12:12:38 <Heffalump> because the big tuple will have the same strictness and efficiency properties as the data constructor
12:12:59 <sjanssen> Heffalump: I would tend to agree, just saw it some where
12:19:04 <sylvan> newtype can't be bottom, though?
12:19:07 <sylvan> or something like that
12:19:38 <Cale> newtype N a = N a
12:19:42 <sylvan> so it's slightly different semantically, and more efficient.. or something =)
12:19:43 <Cale> N _|_ = _|_
12:20:01 <Cale> data D a = D a
12:20:09 <Cale> D _|_ /= _|_
12:20:35 <sylvan> ah..
12:20:57 <Cale> Since if we define f (D x) = 5, we can still do f (D undefined) and get 5
12:20:59 <sjanssen> I think newtype has the syntax (or so) of data at compile time, with the semantics and performance of a type synonym at run time
12:21:03 <sjanssen> is that right?
12:21:37 <Cale> no, different runtime semantics
12:21:47 <r3tex> how do i convert an Int to a Float?
12:21:49 <sylvan> I wonder how useful this distinciton is in practice.. I've certainly never thought "Ah shoot, I need to use a newtype there to get it to do what I want".. Maybe removing newtype for increased simplicity is worth more than the semantic differences compared to single-constructor data
12:21:52 <r3tex> fromInt doesn't work
12:22:09 <Cale> sylvan: we also have newtype deriving
12:22:14 <sjanssen> Cale: different from a type synonym?  in which ways?
12:22:27 <sylvan> Cale, ?
12:22:37 <sjanssen> Cale: ah typeclasses, anything else?
12:22:58 <sylvan> r3tex: fromIntegral
12:23:19 <sylvan> @type fromIntegral
12:23:20 <lambdabot> forall b a. (Num b, Integral a) => a -> b
12:23:31 <Cale> http://www.haskell.org/onlinereport/decls.html#sect4.2.3
12:23:36 <r3tex> sylvan:  tjena! but i get the error that Int does not match Integral
12:23:43 <sylvan> converts integral values to numeric values (which may also be integral)
12:23:53 <Cale> In particular, read the section starting "The following examples..."
12:23:56 <sylvan> >fromIntegral (4::Int) :: Float
12:24:15 <sylvan> @eval fromIntegral (4::Int) :: Float
12:24:17 <lambdabot> 4.0
12:25:04 <Cale> If I have newtype N a = N a
12:25:12 <Cale> and I define g (N x) = 5
12:25:19 <Cale> then g undefined = 5
12:25:30 <Cale> Whereas if I have data D a = D a
12:25:44 <Cale> and I define f (D x) = 5
12:25:50 <Cale> then f undefined = undefined
12:25:58 <Heffalump> sylvan: belatedly, it doesn't matter that newtype can't be bottom, because the tuple can be
12:26:15 <Heffalump> in the specific comparison of newtype with a tuple and data with a single constructor with >1 argument
12:26:22 <palomer> Cale: that's really strange
12:26:29 <Cale> palomer: it's not that strange
12:26:35 <palomer> how does that work?
12:26:38 <Cale> The newtype constructor is just a tag.
12:26:45 <palomer> yeah
12:26:56 <Cale> The data representation is the same as the original type
12:26:57 <palomer> so g (N x) is almost the same as g x?
12:27:07 <lennart> at runtime it is the same
12:27:19 <Cale> I mean, for newtype, the runtime representation is the same as the original type
12:27:20 <Heffalump> newtype changes type checking behaviour
12:27:38 <Heffalump> but not runtime behaviour (except in as much as different classes lead to different dictionaries being used)
12:27:53 <sjanssen> I wonder how one implements classes with newtypes
12:27:54 <Cale> Whereas, for data, the runtime representation has an additional layer of indirection
12:28:09 <Heffalump> sjanssen: sorry?
12:28:12 <Heffalump> it's just a type-checking issue.
12:28:31 <lennart> sjanssen: the type checker treats data and newtype the same way
12:29:04 <sjanssen> and the type checker/compiler would know which dictionary to pass at that time, so there's no problem
12:29:15 <sjanssen> does that make sense?
12:29:25 <lennart> yes
12:31:30 <Cale> Heffalump: do you have a good example not involving getArgs where you actually wanted a complete program failure on pattern match in do-syntax?
12:31:40 <Heffalump> lennart: so is it true that newtype N = N (Foo, Bar) and data D = D Foo Bar have the same efficiency and strictness problems?
12:31:54 <Heffalump> Cale: any program in which its unexpected, surely
12:32:08 <Heffalump> s/problems/properties/ two lines up
12:32:24 <Cale> Heffalump: yeah, those two are the same
12:32:27 <palomer> did anyone read that "exceptional syntax" paper?
12:32:33 <Heffalump> palomer: which one?
12:32:43 <Heffalump> oh, the one by Andrew Kennedy et al?
12:32:49 <Cale> (those types are isomorphic in terms of their efficiency and strictness)
12:32:58 <lennart> Heffalump: yes N and D should be identical (well, implementation might differ exactly ho many bits are used for the tag)
12:33:22 <palomer> Heffalump: the one advocating try
12:34:20 <Heffalump> palomer: by the authors I mentioned?
12:34:39 <Heffalump> if so, I read it recentlyish, can't remember why
12:34:49 <palomer> Heffalump: yeah
12:34:57 <palomer> Heffalump: do you agree with the authors?
12:36:52 <Heffalump> palomer: their basic point was that they needed to be able to separate the range over which exceptions were caught from the point to which control is transferred when an exception happens.
12:36:56 <Heffalump> Which is a fair point.
12:37:03 <Heffalump> I'm not sure how common their scenario really is, though.
12:37:31 <noj> dons, you there? OpenBSD-current ghci is broken: Loading package base ... linking ... /usr/local/lib/ghc-6.2.2/HSbase_cbits.o: unknown symbol `__errno'
12:42:31 <wilx> Hmm, 6.2.2 is a bit old.
12:42:49 <noj> tell that to dons, he's the maintainer for ghc in OpenBSD ;)
12:43:01 <noj> s/for/of/
12:43:33 <palomer> whoa, there hasn't been a ghc release since october
12:44:43 <takuan> anybody in here ever heard about module views?
12:45:13 <takuan> oops
12:45:15 <takuan> that's oo
12:45:23 * palomer kills hugs
12:45:33 <palomer> why the blazes does emacs-mode use hugs?
12:45:43 <rep> does GHC work in amd64 machines?
12:45:50 <rep> (running a 64-bit kernel)
12:47:09 <Heffalump> rep: well, I'm using it on such a machine.
12:47:33 <Heffalump> but I'm using a 32-bit version running on 32-bit userland.
12:47:33 <rep> so ghc is a 64-bit binary?
12:47:33 <Heffalump> which one would really hope would work
12:47:38 <rep> well, yeah
12:47:49 <rep> what i'm really asking is if it works as a 64-bit binary
12:47:54 <Igloo> it does
12:47:58 <Heffalump> I believe proper amd64 binaries do exist, but they won't be very efficient because the amd64 port is still unregisteristed.
12:48:04 <Heffalump> s/isted/ised/
12:48:08 <Igloo> It's registerised now
12:48:17 <palomer> hrm
12:48:26 <palomer> how would I get the fixed point combinator written out in full?
12:48:27 <shapr> spiffy
12:48:32 <shapr> conjure list.
12:48:33 <palomer> (from haskell)
12:48:35 <Heffalump> Igloo: oh, cool.
12:48:45 <Heffalump> palomer: sorry?
12:48:55 <shapr> Is there an arm port of ghc?
12:49:03 * shapr is looking at a Nokia 770
12:49:03 <palomer> Heffalump: like > show fix
12:49:47 <Heffalump> shapr: nope, but you're the second person to ask in a few days :-)
12:50:00 <Heffalump> igloo: can you remind me what's missing at the moment?
12:50:23 <Igloo> Floating point encoding/decoding
12:50:40 <Cale> The 1.4 prelude was a lot prettier than the 98 prelude.
12:51:01 <Heffalump> were you expecting gcc 4 to fix this, or something?
12:51:18 <Igloo> I'm confused as to whether or not that happened
12:51:42 <Heffalump> whether or not it's moved to gcc 4, or whether it got fixed?
12:51:54 <Heffalump> do you know more about what the actual problem was, or have a reference?
12:52:21 <Igloo> Whether it got fixed
12:52:30 --- mode: Igloo set -o Igloo
12:53:03 <Igloo> The problem was when compiling it thought pi was Inf, and the assembler got upset at that not being a numeric constant
12:53:19 <lennart> Heffalump: Do I remember right that you work for ARM?
12:53:37 <ihope> Does anybody know a good monad for Unlambda programs?
12:53:48 <ihope> Or if monads are good for Unlambda programs? :-)
12:54:20 <Heffalump> lennart: right
12:55:21 <lennart> Heffalump: I'm just curious, do you use Haskell at work?
12:55:25 <Heffalump> Igloo: you actually tried to port it, then?
12:55:32 <Heffalump> lennart: off and on
12:55:37 <Heffalump> (more off than on at the moment)
12:55:40 <Igloo> Yes
12:55:50 <Igloo> What gcc does sarge have again?
12:56:10 <Heffalump> ii  gcc            3.3.5-3        The GNU C compiler
12:56:20 <Igloo> ta
12:56:22 <lennart> Heffalump: I remember that Nikhil said that ARM is the only company he has been to descibing Bluespec where people actually asked for the old Haskell syntax. :)
12:56:57 <Heffalump> lennart: some people in R&D used it quite a bit for a while, to write a prototype vectorising compiler for our new SIMD architecture
12:57:04 <Heffalump> but that's dead now
12:57:09 <Heffalump> and I don't work in R&D anyway
12:57:17 <Heffalump> Alastair Reid does, though
12:57:51 <Heffalump> (and it was R&D doing the Bluespec evaluation)
12:58:04 <lennart> Yeah, that makes sense
12:58:28 <palomer> > show (Just "hello")
12:58:30 <lambdabot> "Just \"hello\""
12:58:49 <palomer> err
12:58:54 <Heffalump> palomer: belatedly, you can't write a show instance for functions that actually prints out the definition
12:58:55 <palomer> why does show insert \ characters?
12:59:09 <Heffalump> > show "foo"
12:59:10 <lambdabot> "\"foo\""
12:59:20 <Heffalump> > print "foo"
12:59:22 <lambdabot> No IO allowed
12:59:39 <palomer> print keeps them there
12:59:40 <Heffalump> palomer: one answer is because show is making something that read could accept
12:59:50 <Heffalump> > show "5"
12:59:52 <lambdabot> "\"5\""
12:59:55 <Heffalump> > show 5
12:59:57 <lambdabot> "5"
13:00:07 <lennart> show makes a string, " has to be quoted in strings
13:00:19 <palomer> > filter (\='\\') $ show "5"
13:00:21 <lambdabot>  Not in scope: `\='
13:00:29 <Heffalump> lennart: that doesn't explain why show on String isn't id, though
13:00:35 <palomer> > filter (not.=='\\') $ show "5"
13:00:37 <lambdabot>  Not in scope: `.=='
13:00:41 <palomer> > filter (not . =='\\') $ show "5"
13:00:42 <lambdabot>  parse error on input `=='
13:00:45 <Heffalump> > filter (/= '\\') $ show "5"
13:00:47 <lambdabot> "\"5\""
13:01:08 <palomer> > filter (not . (==)'\\') $ show "5"
13:01:09 <lambdabot> "\"5\""
13:01:16 <Heffalump> the backslashes are just the way of displaying the embedded quotation marks
13:01:25 <Igloo> You aren't actually seeing what you ask it to evaluate. You are seeing the result of show applied to that
13:01:52 <Igloo> So when you ask for show "foo" you are seeing   show (show foo)
13:02:15 <lennart> Heffalump: show of a string could be the identity, and show of an Int could print banana.  But then read wouldn't work, as you said
13:02:21 <palomer> show "foo" == show $ show foo?
13:02:39 <palomer> eh?
13:03:00 <palomer> anyways, how do I filter out those pesky \" ?
13:03:01 <Heffalump> lennart: actually, I haven't quite convinced myself that read wouldn't work
13:03:15 <Heffalump> bearing in mind that the result type is what determines what read parses something as
13:03:24 <SamB> conjure peoples, you can join conjure@lists.urchin.earth.li at http://urchin.earth.li/mailman/listinfo/conjure or by cleverer means which you don't want to use unless you know anyway
13:03:27 <Igloo> reads wouldn't know when to stop
13:03:30 <palomer> so read is the left inverse of show?
13:03:34 <Heffalump> ah, yes.
13:03:40 <Heffalump> palomer: yes.
13:03:54 <palomer> too bad it's not the right inverse too
13:03:55 <Heffalump> or should be, and is for all inbuild definitions of Read and Show
13:03:58 <palomer> that would be too good:o
13:04:11 <Heffalump> palomer: bit hard, really :-)
13:04:23 <Heffalump> > read "Just  5" :: Maybe Int
13:04:25 <lambdabot> Just 5
13:04:31 <Heffalump> well, if you also want read to be helpful.
13:04:38 <CosmicRay> SamB: is jlouis ever going to apply my patches?  I haven't heard a peep.
13:04:39 <lennart> Heffalump: show ("1,2","3") printing as (1,2,3) ?  sounds like a bad idea
13:04:49 <Heffalump> but I expect there's a galois connection there if you care about such things
13:04:50 <CosmicRay> and I don't want to send more patches until I know somebody will apply them
13:04:51 <Heffalump> lennart: good point
13:05:17 <palomer> so, erm, how can I remove the pesky \" ?
13:05:25 <Heffalump> palomer: what are you actually trying to do?
13:05:30 <palomer> (I'm showing a datatype element, and I want to paste it into my code)
13:05:32 <Heffalump> in this case,
13:05:34 <Heffalump> > "foo"
13:05:35 <lambdabot> "foo"
13:05:54 <TNKS> hi all.  I just took a short detour into the world of Lua.  Does anybody here have any experience with Lua, because there's a mentality in Lua of storing using straight Lua code as a database for large amounts of data.  Evidently, the Lua designers have strived to maintain compiling efficiency.  Does anybody here have an opinion regarding doing that with Haskell?
13:06:41 <palomer> Heffalump: I'm doing it in IO ()
13:07:15 <lennart> palomer: are you using print?
13:07:45 <Heffalump> (if so, use putStrLn instead)
13:07:59 <Heffalump> print is just putStrLn . show
13:08:09 <TNKS> My beef with Lua is that it's imperative and dynamically typed, so in a way, it's far removed from what I consider to be the "graces" of Haskell.  Frankly I'd rather stick with Haskell if I can.
13:08:57 <palomer> Heffalump: oh my!
13:08:58 <palomer> now you tell me
13:09:05 <Heffalump> TNKS: I don't believe that Haskell implementers pay much attention to the efficient representation of data in the compiled program.
13:09:36 <Heffalump> but I'm not really sure what the actual cost of lots of data would be
13:09:40 <palomer> efficiency is for chumps
13:09:56 <Heffalump> palomer: and people who work on small systems ;-)
13:10:27 <TNKS> Well, in this case, it's not so much an issue of efficiency, as much as the scalability of using Haskell for this purpose.
13:11:19 <Heffalump> well, it'll just be a constant factor overhead
13:11:35 <Heffalump> the size taken up isn't going to change by 4 when the volume of data changes by 2 or anything
13:11:40 <Heffalump> so it's scalable in that sense
13:11:45 <TNKS> Lua uses the terse syntax for constructing data as an incentive for storing data as code (kind of like the Lisp-ers do).  But Haskell's syntax is really concise too.
13:11:53 <Heffalump> but the constant factor may be too large for the things you actually want to do
13:12:27 <Heffalump> I think you will just have to experiment to find out, though.
13:12:40 <TNKS> Well, let me just start with an example of what I'm thinking of.
13:13:11 <TNKS> LDAP is fast for the end user, but at the expense of really not offering administrators much flexibility.
13:13:50 <CosmicRay> TNKS: what sort of data are you planning to store, and would ConfigParser or AnyDBM in MissingH possibly be useful for you?
13:14:48 <TNKS> I was thinking about storing data as instances of Haskell data types in a code file.  Then I'd just have a function to generate an LDIF stream.
13:15:09 <CosmicRay> btw, are you aware of the haskell ldap library already?
13:15:09 <TNKS> This would allow me the flexibility to make huge changes to all entries.
13:15:35 <CosmicRay> TNKS: I'm confused about how ldap fits into your question.
13:15:37 <TNKS> CosmicRay, yeah, I just looked into it.  I think it will provide some convienient hooks to implement the changes.
13:15:48 <CosmicRay> you're considering either storing some large set of data as haskell source, or as ldap?
13:16:07 <CosmicRay> TNKS: ok, do feel free to send any gripes or patches my way.  (I'm the author of that library)
13:16:27 <TNKS> CosmicRay, oh, okay, so you probably know LDAP better than me.
13:16:40 <TNKS> CosmicRay, I'm just dealing with schema-hopping.
13:16:42 <CosmicRay> not necessarily.  I may know the C API better than you only ;-)
13:17:10 <TNKS> But parsing an LDIF file into an intermediate language, just to spit it back out into another LDIF file is a pain.
13:17:19 <CosmicRay> I know enough about LDAP to know how to use it for centralized authentication for unix and windows boxen.  We are certainly not using the full extent of its capabilities here.
13:17:22 <CosmicRay> ah.
13:17:24 <TNKS> so I just thought I'd maintain my data in the intermediate language.
13:17:47 <TNKS> And then have flexibility to make any LDIF I see fit.
13:17:56 <CosmicRay> well surely the data's native representation isn't an LDIF file, but rather what's in the LDAP database directly, right?
13:18:11 <TNKS> CosmicRay, that's true.
13:18:40 <PerlJam> It's an odd thing to say that data has a "native representation"  :)
13:18:43 <TNKS> But the functions that OpenLDAP provide are expecting the LDIF format, no?
13:18:47 <CosmicRay> TNKS: well then, I'd say you should use ldap-haskell to extract the data directly, store it in whatever data structure you find helpful, and use read and show to serialize it.
13:20:17 <palomer> have you guys ever thought "man I wish I was working in system F"?
13:20:33 <Heffalump> palomer: no. :-)
13:20:40 <TNKS> CosmicRay, that sounds like a good plan.  I'm kind of a half-baked Haskell programmer.  Haskell can induce default read and show serialization, right?
13:20:46 <Heffalump> I like type inference.
13:22:00 <PerlJam> Heffalump: are you saying ML is better than Haskell?  And that we should all switch now?
13:22:03 <PerlJam> ;-)
13:22:23 <Heffalump> well, it has the major advantage of being strict by default :-)
13:23:49 <Igloo> Heffalump: Looks like arm still has its old float format
13:24:00 <Heffalump> Igloo: ah, ok.
13:24:11 <CosmicRay> brb
13:24:13 <Heffalump> so do you know what is confused, or can you point me at something I can look at?
13:24:37 <Heffalump> (short of telling me to try the port myself, which I will try at some point when I get a round tuit, but not now)
13:25:13 <Igloo> http://musketeer.comlab.ox.ac.uk/~igloo/f.c is neither the same as x86's, nor the same reversed
13:26:24 <Heffalump> why is it printing a char with %d ?
13:26:46 <Heffalump> oh, I guess variadic calling should zero-pad.
13:27:11 <SamB> CosmicRay: bug shapr about a writable HTTP repo
13:27:13 <CosmicRay> back.
13:27:58 <Heffalump> I don't quite see why the loop is up to 6, either.
13:27:59 <Igloo> variadic calling should zero-pad?
13:28:16 <CosmicRay> TNKS: yes.
13:28:16 <Heffalump> printf will be reading an int off the stack, when a char was put there
13:28:27 <CosmicRay> TNKS: the normal representation from the LDAP API is not just LDIF strings
13:28:32 <CosmicRay> TNKS: it's more structured than that
13:28:34 * shapr buzzes around randomly
13:28:34 <Heffalump> but I think any sane calling convention will have passed the char as a 4-byte value, zero padded, because printf is variadic.
13:28:41 <Heffalump> but I'm not actually certain of that
13:28:49 <dcoutts> praseodym: pong
13:28:55 <Igloo> 4 and 8 would be sufficient for the two loops
13:28:57 <Igloo> Hmm
13:29:06 * palomer is implementing my own little evaluator...
13:29:16 <palomer> are there any tutorials on implementing an evaluator in haskell?
13:29:25 <palomer> I'm trying to pick my datatypes
13:29:26 <CosmicRay> SamB: a writable repo for what?
13:29:27 <Igloo> ISWYM, it's a bit dodgy that. It should have another cast to int
13:29:35 <SamB> Heffalump: on any sane platform, it will be fine
13:29:44 <SamB> so says the GNU libc documentation
13:29:52 <SamB> CosmicRay: conjure
13:29:53 <CosmicRay> TNKS: it's more like lists of fields and parameters, rather than making you parse things directly.
13:29:56 <CosmicRay> SamB: ah
13:30:09 <SamB> presumably governed by some sort of keyring or something like that
13:30:10 <Heffalump> SamB: GNU libc documentation says that any sane platform passes chars as words?
13:30:19 <CosmicRay> SamB: who should I be sending patches to?  darcs send defaulted to jlouis but I haven't heard anything from him, and this was about 3 weeks ago
13:30:25 <SamB> Heffalump: well, to printf you need to anyway
13:30:36 <Heffalump> printf is just a variadic function
13:30:45 <wilx> That is C's property, not libc's.
13:30:49 <Heffalump> right.
13:30:50 <TNKS> CosmicRay, Is there some place convenient that has an example of this format?
13:31:04 <SamB> varargs have default argument promotions applied
13:31:16 <Heffalump> SamB: ok.
13:31:31 <SamB> libc docs say that on sane platforms arguments are always passed that way
13:31:41 <Heffalump> biab
13:31:55 <TNKS> Ultimately, I'd like to has something human-readable, so I can just make changes to my LDAP data with a text-editor.  If the serialization is too obscure, then I do loose that.
13:32:07 <CosmicRay> TNKS: if you download ldap-haskell with darcs get http://darcs.complete.org/ldap-haskell/, then run make doc, you'll get nice HTML docs output.
13:32:16 <CosmicRay> TNKS: or, if you run debian, apt-get install ldap-haskell-doc
13:32:22 <palomer> peyton's Term type in his wobbly paper is practically useless
13:32:37 <TNKS> CosmicRay, yeah, I'm on debian, so I'll do that.
13:32:56 <CosmicRay> actually, it appears I have a bug in the ldap-haskell-doc package that prevented it from containing anything.
13:32:57 <PerlJam> TNKS: YAML is human readable  :)
13:33:01 <CosmicRay> best to download and run make doc then ;-)
13:33:22 <TNKS> PerlJam, YAML?  I don't know that acronym.
13:33:28 * SamB wonders what the nomail flag does
13:33:46 <PerlJam> TNKS: http://www.yaml.org/
13:34:03 <Heffalump> Igloo: do you have any cross-compilation tools anywhere convenient (gcc + a disassembler)?
13:34:11 <Igloo> no
13:34:24 <Igloo> I don't have access to an arm either
13:34:43 <CosmicRay> Heffalump: are you considering fixing ghc on arm?
13:34:54 <Heffalump> CosmicRay: I am trying to understand the problem.
13:35:02 <CosmicRay> excellent.
13:35:35 <Igloo> I expect the problem is in ghc/rts/StgPrimFloat.c, incidentally
13:36:19 <Heffalump> Igloo: do you know what that program prints on ARM?
13:38:47 <Igloo> arm: 238,210,48,67   93,26,102,64,184,59,107,183
13:39:01 <Igloo> x86: -18,-46,48,67  -72,59,107,-73,93,26,102,64
13:39:12 <Heffalump> ok so the float is only different based on sign extension
13:39:27 <Heffalump> the char has been promoted to a signed int on x86 and an unsigned one on ARM
13:40:06 <Heffalump> is the actual going-wrongness just with a float, or with a double too?
13:40:45 <Heffalump> (what I'm saying with float is that the problem is just caused by the dodgy printf, the actual representation of the float was identical)
13:40:50 <Heffalump> s/problem/difference/
13:41:20 <TNKS> Seems kind of weird that the Debian ghc6 has dependencies to hugs.  I thought they'd be independent.
13:41:46 <Heffalump> TNKS: in what, sarge or sid?
13:41:59 <TNKS> Heffalump, Etch.
13:41:59 <Heffalump> it doesn't seem to have in either for me
13:42:06 <Heffalump> so I doubt it does in etch either
13:42:19 <Igloo> It depends indirectly through haskell-utils
13:42:24 <Heffalump> oh, right
13:42:32 <TNKS> Igloo, yeah. . . that was what I saw.
13:42:49 <Heffalump> why does that require hugs?
13:42:59 <TNKS> Does that make sense, or is a Debian maintainer that's made too strong an assertion?
13:43:10 <Igloo> I don't remember whether it was Float or Double it went wrong with, or even whether I worked out which was the problem at the time, but I assume it was just Double given the above
13:43:12 <Heffalump> TNKS: Igloo is the Debian maintainer in question :-)
13:43:16 <r3tex> does anyone here crush their noodlepacks before they eat them?
13:43:36 <Igloo> It requires hugs because it needed to be built at a time when ghc6 was uninstallable
13:43:52 <Igloo> The next one probably won't require hugs on arches where ghc6 works
13:44:16 <TNKS> Igloo, okay, will then hugs should automatically uninstall then when your new package hits Etch.
13:44:32 <TNKS> :s/will/well/
13:44:53 <Igloo> That might depend on what you use to install things
13:45:38 <TNKS> Igloo, yeah, you're right, I'm using automarking with aptitude.
13:45:48 * Igloo has no idea what aptitude will do
13:46:55 <TNKS> Aptitude's automarking is pretty nice.  Does pretty much what I was trying to do with deborphan and orphaner.
13:47:14 * Igloo fails to find the mails from when I tried the arm port. It shouldn't be hard for you to reproduce if you have an arm, though
13:47:28 <Heffalump> and time to bootstrap ghc on it..
13:47:50 <Igloo> It's should be mostly CPU time it needs, rather than Heffalump time
13:48:48 <Heffalump> do you know what CPU precisely it was compiled for?
13:49:28 <Heffalump> ohoh, I see the problem.
13:49:51 <Heffalump> the Double has the words in the opposite order, and the unsigned versus signed difference.
13:49:53 <Igloo> Probably the lowest Debian supported back then, but no idea
13:49:53 <TNKS> CosmicRay, any idea why the libghc6-ldap-dev ends in "-dev" but the libhugs-ldap one doesn't?
13:50:30 <TNKS> I don't see libghc6-ldap or libhugs-ldap-dev packages.
13:50:38 <Igloo> It's more than that, isn't it?
13:51:03 <Heffalump> Igloo: no, swap the words in the double, then subtract 256 from anything >= 128
13:51:05 <Igloo> Oh, hang on
13:51:06 <Igloo> Oh, words
13:51:41 <Igloo> Well, that's disappointingly simple  :-)
13:52:42 <Heffalump> surely people must have run into this before, though...
13:52:59 <Heffalump> or does noone use double literals on gcc on arm?
13:53:20 <Igloo> Presumably most people don't try to decode floating point numbers themselves...
13:54:06 <Heffalump> but you'll get the wrong answers when you do anything with your literals
13:54:30 <SamB> why do you need to fix the signage issue?
13:54:39 <Heffalump> SamB: you don't. The flipped words, otoh..
13:55:02 <SamB> Heffalump: well yeah.
13:58:17 <SamB> hmm, this song has rotten lyrics
13:58:36 <basti_> which one?
13:58:38 <tennin> most songs do
14:00:08 <SamB> css_descramble_joe_wecker.mp3
14:10:51 <ihope> > 1 + 5
14:10:51 <Lemmih> SamB: ping.
14:10:53 <lambdabot> 6
14:10:59 <ihope> > 8 + 1
14:11:01 <lambdabot> 9
14:11:08 <ihope> > 1 + 5 * 8 + 1
14:11:10 <lambdabot> 42
14:11:11 <ihope> :-)
14:11:44 <xerox> > "J!dbo!dbmdvmbuf\"" >>= return . pred
14:11:46 <lambdabot> "I can calculate!"
14:11:56 <ihope> Gasp!
14:12:01 <SamB> Lemmih: ping
14:12:08 <SamB> er, pong
14:12:29 <TNKS> CosmicRay, I don't know why, but ldap-haskell-doc is a practically empty package; verified with `dpkg -L ldap-haskell-doc`.  
14:12:33 <bigbabyjesusfoo> > 4377
14:12:34 <lambdabot> 4377
14:12:39 <Lemmih> SamB: I removed the Makefile because Cabal is way easier to use.
14:12:45 <TNKS> Is there some documentation on-line?
14:13:13 <ihope> > map pred "J!dbo!dbmdvmbuf\"" -- for the non-monadically minded of us out there
14:13:15 <lambdabot> "I can calculate!"
14:13:30 <Lemmih> SamB: I'll send a mail to the conjure list about all the changes I've made.
14:13:34 <dons> moin
14:13:36 <SamB> Lemmih: hmm...
14:13:51 <SamB> I don't think it is very nice when I don't want to install something...
14:14:40 * xerox mumbles something about a cairo-powered app he just foresaw...
14:15:18 <dons> @seen noj
14:15:18 <lambdabot> noj is in #haskell. Last spoke 1 hour, 32 minutes and 19 seconds ago.
14:15:32 <dons> noj, hmm.. ok. I'll have a look a tit.
14:15:38 <dons> s/t//
14:15:44 <SamB> Lemmih: maybe you should wait a bit until more join it?
14:16:18 <Lemmih> SamB: Oki.
14:16:27 <SamB> at the moment, its you, me, and sjanssen
14:17:02 <ADEpt> SamB: hi. where are those patches you are talking about? :)
14:17:35 <SamB> ADEpt: Lemmih has some
14:17:53 <SamB> http://scannedinavian.org/~lemmih/conjure
14:18:14 <noj> dons, cheers
14:18:21 <SamB> someone please merge them with mine and ADEpt's?
14:18:26 <SamB> my computer is too slow...
14:18:31 <xerox> dons: oi!  Did you see the 'error' bug?
14:19:05 <ADEpt> SamB: I can try
14:19:25 <ADEpt> Lemmih: is there lots of code to merge?
14:19:31 * ADEpt pulls, meanwhile
14:19:50 <dons> noj, are you using ghci from a snapshot ?
14:19:54 <SamB> ADEpt: yes!
14:19:56 <dons> and latest -current?
14:20:02 <dons> xerox?
14:20:06 <noj> dons, yeah. upgraded this very evening
14:20:14 <SamB> the part where I pull into the same repo takes forever
14:20:26 <SamB> even for Lemmih's first patch
14:20:26 <xerox> dons: the lambdabot bug about 'error' and '>>='
14:20:36 <dons> and ghci is borken. ok. thanks for the report. what I'll look to do is just push 6.4.1 in
14:20:45 <dons> give me a week or so
14:21:14 <dons> noj, by the way, you could try a 6.4.x snapshot from http://www.cse.unsw.edu.au/~dons/haskell_openbsd.html
14:21:18 <noj> dons, that sounds great. let me know if you need testing help
14:21:26 <dons> noj, do you use any other haskell software from ports?
14:21:30 <noj> darcs
14:21:32 * ADEpt postpones pull till tomorrow :)
14:21:41 <SamB> ADEpt: also, *join the list*
14:21:47 <dons> ah, I should update to darcs 1.0.5 too then, noj.
14:21:50 <ADEpt> SamB: i'll be alive, btw, with respect to conjure :)
14:21:53 <Lemmih> ADEpt: Yes. I've rewritten almost all of Conjure.
14:21:54 <ADEpt> SamB: which list?
14:22:11 <ADEpt> SamB: (ADEpt:what) ? :)
14:22:13 <SamB> ADEpt: the mailing list you should have been invited to
14:22:27 <ADEpt> SamB: well, i havent :)
14:22:46 <Lemmih> I'm planning to restart my Conjure repo because the code in the first 270 patches are not in the repo anymore.
14:22:49 <ADEpt> SamB: either wrong address, or too eager antispam measures somewhere down the road
14:22:50 <SamB> http://urchin.earth.li/mailman/listinfo/conjure
14:22:55 <ihope> Wait, what's the error/bind bug?
14:23:11 <SamB> Lemmih: don't do that!
14:23:28 <SamB> Lemmih: you'll lose people that way
14:23:43 <Lemmih> ):
14:24:02 <ADEpt> Lemmih: what do you mean, "restart"??
14:24:08 * ADEpt subscribes to the list
14:24:43 <SamB> Lemmih: you got the invite, I hope?
14:24:53 <dons> I got an invite :)0
14:25:08 <Lemmih> ADEpt: Copy my code to another repo with the entire history as one big comment.
14:25:15 <Lemmih> SamB: Yeah, I did.
14:25:32 <Lemmih> dons: You hack conjure?
14:25:40 <SamB> dons: what kind of face is that
14:25:42 <ihope> You got an error in your code? There's an easy fix: use "fix error"!
14:25:59 <dons> SamB, for some reason my finger often hits '0' after ')'
14:26:15 <dons> Lemmih, well, I think some of my code is in there: </>  :)
14:26:25 <SamB> oh
14:26:32 <xerox> ....anybody knows about Haskell programs using BOTH Gtk2Hs and Networking?
14:26:37 <ADEpt> Lemmih: 1 large commit? wow :)
14:27:05 <palomer> fix error doesn't typecheck
14:27:07 <palomer> > fix error
14:27:12 <SamB> dons: you are in AUTHORS, and I did not somehow miss you, and the invites worked, so you got an invite
14:27:12 <lambdabot> Terminated
14:27:17 <Lemmih> ADEpt: Yeah, it would be ugly. But at least faster to download than 270 useless patches.
14:27:18 <palomer> @type error
14:27:20 <lambdabot> forall a. [Char] -> a
14:27:26 <dons> SamB, it's ok :)
14:27:30 <SamB> @type fix error
14:27:31 <palomer> does does fix error typecheck?
14:27:31 <lambdabot> Not in scope: `fix'
14:27:41 <xerox> @type Control.Monad.Fix.fix error
14:27:42 <lambdabot> [Char]
14:27:45 <ihope> :-)
14:27:46 <xerox> :_)
14:27:55 * xerox lost the nose
14:28:13 <SamB> Lemmih: um.
14:28:14 <ihope> ": )"?
14:28:18 <SamB> checkpoints, anyone?
14:28:21 <palomer> oh, it does typecheck
14:28:30 * palomer ponders putting on a fourth layer of clothing
14:28:48 <ihope> Wait a minute...
14:28:56 <xerox> I just undressed, it's way too hot here.
14:28:58 <ihope> @type Control.Monad.Fix.fix error
14:29:00 <lambdabot> [Char]
14:29:07 <palomer> seriously, GADTs are useless for interpreters
14:29:08 <ihope> @type error (Control.Monad.Fix.fix error)
14:29:09 <xerox> Heh.
14:29:10 <lambdabot> forall a. a
14:29:20 <Lemmih> SamB: Will that work?
14:29:30 <Lemmih> My darcs-fu is a bit weak.
14:29:55 <SamB> Lemmih: if you do it right and people pull from your repo or a clone, sure
14:30:09 <dons> mmm. espresso
14:30:31 <SamB> where by "clone", I mean something copied by extra-darcs means
14:31:04 <SamB> anyway, someone can get that taken care of without having to restart the repo from scratch
14:31:15 * ADEpt subscribed
14:31:38 * SamB hits refresh on his subscriber list
14:31:54 <palomer> what's the definition for identifier in haskell?
14:32:12 <SamB> why is everyone @gmail.com
14:32:16 <ihope> :-)
14:32:24 <ihope> 'Cause it's free and we like it.
14:32:56 <SamB> hehe
14:33:14 <dons> doesn't it make it much more difficult to apply darcs patches, and otherwise interact with unix programs?
14:33:20 <palomer> for me, it's a space issue
14:33:23 <palomer> I have 4 email addresses
14:33:25 <ulfdoz> SamB: If you don't like it, pay me for it. :)
14:33:28 <palomer> all of them are forwarded to gmail
14:33:34 <dons> i.e. a decent editor to compose mail?
14:33:50 <araujo> dons, hey!
14:33:55 <dons> hey araujo.
14:34:01 <ulfdoz> dons: vi(m)?
14:34:02 * araujo throws lambdas at everyone
14:34:15 <SamB> dons: darcs patches are a bit trickier
14:34:16 <noj> dons, also, does darcs really have to depend on ghc being installed?
14:34:22 * palomer wonders how to parse string literals using parsec
14:34:24 <dons> no.
14:34:29 <xerox> Tell me.  For a Go program, would you prefer a cairo based, or an opengl based "client"?
14:34:31 <SamB> but I've noticed I can apparantly get them to actually work
14:34:31 <dons> noj, yeah, I noticed that too.
14:34:35 * ihope throws combinators at araujo
14:34:38 <SamB> noj: does it?
14:34:46 <noj> SamB, in OpenBSD land
14:34:52 <dons> noj, ah, so that would be annoying when installing packages.
14:34:54 <noj> pkg-wise
14:34:56 <SamB> noj: must be maintainer error
14:34:59 * araujo jumps over each combinators
14:35:05 <noj> SamB, hehe
14:35:05 <dons> SamB, yes thanks :)
14:35:23 <dons> it's due to the Haskell module infrastructure we use in ports
14:35:38 <dons> which by default sets a ghc dep at runtime.
14:35:48 * ihope throws call/cc at araujo
14:35:50 <dons> which is a bit silly, since it's always statically liinked.
14:35:55 <noj> :)
14:36:25 <SamB> dons: yes!
14:36:35 * araujo wears his monadic shield to avoid further attacks
14:36:39 <dons> it's good to get user feedback
14:37:01 <dons> since I always have ghc installed anyway, I don't notice some things.
14:37:11 <noj> I don't think lots of people use the more "esoteric" programming languages and related stuff in OpenBSD land
14:37:22 <noj> which is a shame
14:37:28 * ihope pops into an identical monadic shield and calculates (araujo >>)
14:37:32 <dons> true. but there's 4 or 5 openbsd's on this channel, at least.
14:37:38 <dons> and darcs must have some users.
14:37:44 <noj> yeah
14:37:49 <ADEpt> SamB: i use gmail as a forwarder to my real email with HUGE cache attached :)
14:38:19 <dons> noj, actually, quite a few of the kernel hackers are interested in static typing and safety issues, so there's a little bit of interest.
14:38:41 <dons> anil@ for example, uses ocaml, and works on extending gcc with more static checks.
14:38:45 <noj> yeah, I guess avsm@ has been pushing it there
14:38:48 <noj> yeah :)
14:38:56 <dons> ah, yeah, avsm. i forget his nick.
14:38:58 <palomer> hrmph, how do I use the stringLiteral token in parsec?
14:38:59 * araujo throws a big functor into ihope head
14:39:12 <dons> nordin@ works on ghc too
14:39:17 <dons> or nhc, actually.
14:39:17 <araujo> That will teach you
14:39:23 * ihope turns the functor into an arrow and shoots it at araujo
14:39:46 <araujo> :-P
14:39:50 <dons> and over in netbsd of course, there's lennart.
14:39:57 <noj> dons, cool. I wish they would look at the erlang port as well. it has been brought up several times that it's broken, by me among others. but no one does anything
14:40:24 <SamB> dons: but if they have ghc installed anyway, they'll likely not notice the problem
14:40:24 <dons> someone needs to just step up and fix it, I guess. or maybe the fix is hard. 
14:40:49 <dons> SamB? 
14:40:56 <SamB> or maybe nobody has actually complained about it in an "I want to uninstall GHC" way
14:40:57 <noj> dons, not really, it's been posted a couple of times but it just gets ignored. anyway, I'll post a patch this week :)
14:41:03 <dons> SamB, ah right.
14:41:30 <dons> SamB, I think the problem is people installing only from binary packages are surprised to find a ghc dep on darcs.
14:42:23 <dons> wow. I actually got really nice espresso from this new stove top espresso thing
14:42:29 * dons does the happy caffeine dance
14:42:32 <Igloo> Huh? darcs depends on ghc?
14:43:04 <dons> Igloo, don't worry :S legacy issue on openbsd. it's an old bug that's been around for a while in our ports system
14:43:09 * ADEpt is off to bed
14:43:12 <ADEpt> bb
14:43:21 <dons> happy new year, btw, Igloo!
14:43:28 <Igloo> You too  :-)
14:43:51 <Igloo> Is there a summary of the bug anywhere?
14:44:51 <dons> here: this line "RUN_DEPENDS+=   bin/ghc::lang/ghc" should not be in the `module ghc' template
14:44:52 <SamB> Lemmih: shall I just subscribe jlouis myself?
14:45:25 <dons> or there should be a separate include for binaries, different to libraries
14:45:41 <Igloo> Ah, right
14:47:08 <dons> btw, shootout hackers, I think the only way to improve the dna-regex is with faststring regexes, which needs FPS :/
14:48:10 <Lemmih> SamB: I could just CC him for now.
14:50:14 <palomer> Cale: you around?
14:50:42 <dcoutts> xerox: will you still be about in an hour or so?
14:50:45 <Nanar> I wrote a module and I want to test a function
14:50:50 <Cale> palomer: yeah?
14:50:54 * dcoutts is half way through a film
14:50:54 <SamB> Lemmih: or that
14:51:00 <xerox> dcoutts: I think so
14:51:00 <Nanar> with ghci, I am sure I can do this
14:51:05 <xerox> dcoutts: if I resist :)
14:51:25 <dcoutts> xerox: heh ;-) cool, I was hoping to talk about svg-cairo bindings
14:51:27 <xerox> dcoutts: today I played Shogi all the afternoon, so I'm a bit tired; I'll try my best :-)
14:51:39 <dcoutts> @google Shogi
14:51:41 <lambdabot> http://www.shogi.net/shogi.html
14:51:56 <dcoutts> I see
14:51:58 <xerox> @wikipedia Shogi
14:52:01 <lambdabot> http://en.wikipedia.org/wiki/Shogi
14:52:03 <xerox> Better explanation :-)
14:52:34 <SamB> because there isn't really anyone else I was waiting on, exactly...
14:52:36 <Cale> xerox: how do you find it?
14:52:40 <xerox> (No, I'm not a good player, just starting; it seems fun, heh.)  (I like Go better.)
14:52:50 <SamB> unless you count gmane.org
14:53:04 <xerox> But it's quite cool, in fact.  Surely _more_ fun than standard chess.
14:53:34 * psi has only seen it in hikaru no go :)
14:53:36 <xerox> Pieces being caught can be played again under the opposite army.
14:54:09 <dcoutts> xerox: so it looks like the libsvg-cairo api is really simple and should be an easy extension to your cairo bindings
14:54:14 <xerox> (I.e. the direction indicates the membership)
14:54:22 <xerox> dcoutts: good, good!
14:54:36 <xerox> dcoutts: what's exactly its purpose?
14:55:16 <dcoutts> xerox: eg renderSVGFromFile :: FilePath -> Render ()
14:55:27 <xerox> !!!
14:55:36 <dcoutts> xerox: so it renders svg files/data using cairo
14:55:45 <xerox> It doesn't go the other way around right now, right?
14:55:48 <dcoutts> so you can mix in svg files with custom drawing
14:55:52 <palomer> Cale: how do I parse string literals with parsec (I saw a stringLiteral token, but I have no clue how to use it)
14:55:56 <xerox> Yeah.  I got it.
14:55:59 <dcoutts> including scaling & other transfomations
14:56:13 <dcoutts> so it's not the svg cairo backend
14:56:13 <xerox> It's a very very very very good idea.
14:56:17 <dcoutts> yeah
14:56:30 <dcoutts> http://scret.sourceforge.net/
14:56:42 <xerox> Cale could get its Haskell svg and programmatically render them, heh.
14:56:46 <Nanar> any ghci pro ?
14:56:58 <Nanar> ghci -cpp
14:57:03 <dcoutts> xerox: someone was looking into reimplementing that prog in Haskell with Gtk2Hs using cairo
14:57:16 <Nanar> ./PatchCore.lhs:37: error: impossible.h: no such file or directory
14:57:24 <xerox> dcoutts: ...aaand?
14:57:38 <Nanar> How can I say to ghci to looking for .h in current directory ?
14:57:50 <dcoutts> xerox: it currently uses pngs of svg files for the various musical notation
14:58:01 <xerox> Heh.
14:58:08 <xerox> Is it avaialable somewhere online?
14:58:09 <dcoutts> xerox: so using cairo it'd be better to use the svg directly rather than via a png
14:58:14 <xerox> Indeed!
14:58:15 <dcoutts> http://scret.sourceforge.net/
14:58:23 <xerox> No I mean, the Haskell version.
14:58:35 <dcoutts> not yet
14:58:41 <xerox> Okay.
14:58:50 <Lemmih> Nanar: -I.
14:59:10 <dcoutts> xerox: Pupeno was talking about a port yesterday
14:59:11 <xerox> dcoutts: ok, I'll look into it tomorrow.  I'm sorry I got at the computer only this late.
14:59:18 <xerox> Ah, I know him.  Cool!
14:59:19 <Cale> palomer: ah, stringLiteral is part of the whole TokenParser thing
14:59:20 <dcoutts> heh
14:59:20 <Lemmih> Nanar: Using C header files in Haskell?
14:59:29 <Nanar> Lemmih: ah, was simple :) thanks
14:59:30 <xerox> That game was challenging, heh.
14:59:42 <palomer> Cale: yeah, so I need to do (stringLiteral lexer) to extract the CharParser
14:59:46 <Nanar> Lemmih: not me, I am try to patch anoter a soft (darcs)
14:59:56 <dcoutts> xerox: if you'll be about later we can talk about what the Haskell API should look like
15:00:03 <palomer> Cale: but, for some reason, using that charparser changes the type of parseToken
15:00:13 <Cale> oh, right, it would
15:00:15 <Nanar> Lemmih: I am not sure it C code: #define fromJust (\m_fromJust_funny_name -> case m_fromJust_funny_name of {Nothing ->
15:00:34 <palomer> Cale: but how is that charparser any different from the other charparsers I've been using?
15:00:34 <Lemmih> oh
15:00:44 <Nanar> Lemmih: but there is also C code
15:00:50 <Cale> palomer: oh, it shouldn't be different from other CharParsers
15:00:55 <xerox> dcoutts: there are other things I want to talk about too.  I'm trying to compile darcs pull of the Gtk2Hs repo, but it has some problems, here...
15:01:29 <dcoutts> xerox: yeah it does :-)
15:01:37 <xerox> dcoutts: above some deprecation warning, it fails on "cairo/Graphics/Rendering/Cairo/Internal/Drawing/Cairo.chs:35:28: Not in scope: `withArrayLen'"
15:01:42 <dcoutts> were moving to darcs fully!
15:01:49 <dcoutts> the current darcs mirror is borked
15:01:54 <xerox> ah.
15:02:01 <dcoutts> I should take it down really
15:02:04 <xerox> I should rely on cvs?
15:02:06 <palomer> Cale: but (string "hey!") is also a CharParser
15:02:24 <dcoutts> xerox: for the next week or two 'til the darcs conversion is done. Yes. sorry.
15:02:31 <xerox> dcoutts: no problem.
15:02:45 <Cale> palomer: yeah, they're the same type
15:02:59 <Cale> palomer: this'll be part of your lexer right?
15:03:51 <xerox> dcoutts: do you have any deadlines or something that impose us to talk about the API today?  I'm sorry I'm kinda sleepy.
15:04:39 <palomer> Cale: I have parseToken = choice [...,(stringLiteral lexer) >> return [TokenString "hello"],..]
15:05:18 <palomer> http://www.rafb.net/paste/results/Qloyb178.html
15:05:37 <palomer> http://www.rafb.net/paste/results/ES6sGw16.html
15:05:46 <xerox> Goodnight folks.
15:05:49 <palomer> the second one is line 69
15:05:51 <palomer> night xerox 
15:06:03 <Cale> palomer: oh
15:06:11 <Cale> palomer: not that lexer 
15:06:13 <Cale> hehe
15:06:23 <Nanar> so well
15:06:38 <Cale> stringLiteral (makeTokenParser haskellDef)
15:06:55 <Nanar> today I was to write code, compil it, I want to stop on this :)
15:07:36 <palomer> Cale: haskellDef is in which module?
15:09:17 <palomer> lexer  = makeTokenParser 
15:09:17 <palomer>          (haskellDef
15:09:17 <palomer>          { reservedOpNames = ["*","/","+","-"]
15:09:17 <palomer>          }
15:10:14 <Cale> palomer: you shouldn't actually care about the reservedOpNames unless you're going to use the results of makeTokenParser a whole bunch
15:10:40 <palomer> @hoogle haskellDef
15:10:41 <lambdabot> Text.ParserCombinators.Parsec.Language.haskellDef :: LanguageDef st
15:11:08 <palomer> @hoogle haskellDef
15:11:09 <lambdabot> Text.ParserCombinators.Parsec.Language.haskellDef :: LanguageDef st
15:11:12 <palomer> err, woops
15:11:24 <palomer> oh my, it worked
15:11:36 <palomer> but, erm, why does lexer differ from (makeTokenParser haskellDef) ?
15:12:09 <palomer> (typewise)
15:12:58 <Cale> @type Text.ParserCombinators.Parsec.Token.makeTokenParser Text.ParserCombinators.Parsec.Language.haskellDef
15:13:00 <lambdabot> forall st. Text.ParserCombinators.Parsec.Token.TokenParser st
15:13:31 <Cale> http://www.cs.uu.nl/~daan/download/parsec/parsec.html#TokenParser
15:14:11 <palomer> but...lexer and makeTokenParser haskellDef are practically the same expression!
15:15:26 <palomer> they should obviously have the same type
15:15:30 <Cale> what?
15:15:43 <Cale> lexer is quite different
15:16:00 <palomer> Cale: check out the definition I just pasted
15:16:17 <palomer> lexer = ...
15:16:33 <Cale> sure, but you already have something called 'lexer'
15:16:36 <Cale> don't you?
15:16:43 <Cale> in the error message, it said:
15:16:48 <Cale>     In the definition of `lexer':
15:16:48 <Cale>         lexer = do
15:16:48 <Cale>                   xs <- fmap concat (many parseToken)
15:16:48 <Cale>                   eof
15:16:48 <Cale>                   return xs
15:16:58 <Cale> which is quite different :)
15:17:39 <palomer> so the docs are wrong?
15:17:44 <Cale> what?
15:18:01 <Cale> You have your own definition of lexer
15:18:06 <Cale> in your source code
15:18:50 <xerox> Bash, today, runs this, heh: [[ $(date '+%m+%d==%y') ]] && echo 'heh.'
15:18:50 <Cale> and its type is different from the other 'lexer' from the documentation
15:19:07 <xerox> (At least in my timezone)
15:19:21 <palomer> Cale: oh no, lexer is already used by the Token module, I don't use the keyword "lexer"
15:19:34 <palomer> Cale: I use Token's lexer, which is makeToken haskellDef...
15:19:42 <palomer>  makeTokenParser haskellDef...
15:19:52 <Cale> The error message you pasted says otherwise :)
15:20:30 <Cale> http://www.rafb.net/paste/results/Qloyb178.html
15:20:50 <ihope> I just thought of something.
15:20:56 <ihope> haskell_dubiosity++;
15:21:28 <Cale> ihope: hm?
15:22:15 <ihope> In an imperative language, haskell_dubiosity is increased by one. In Haskell, you can't do that.
15:23:21 <palomer> Cale: http://www.rafb.net/paste/results/vZkvTT97.html
15:24:01 <Cale> ihope: right, not directly anyway
15:24:20 <ihope> Right. You can add some type of variable monad.
15:24:39 <Cale> > let x = x + 1 in x
15:24:40 <lambdabot> Exception: <<loop>>
15:25:30 <Cale> > let inc x = x + 1; x = 5 in inc x
15:25:32 <lambdabot> 6
15:25:45 <Cale> not quite the same thing though :)
15:26:05 <ihope> > inc 5
15:26:07 <lambdabot>  Not in scope: `inc'
15:26:11 <ihope> > succ 5
15:26:13 <lambdabot> 6
15:28:13 <Cale> > let inc = do x <- get; put (x + 1) in evalState (do inc; inc; inc) 0
15:28:15 <lambdabot>  Not in scope: `evalState'
15:28:24 <Cale> > let inc = do x <- get; put (x + 1) in Control.Monad.State.evalState (do inc; inc; inc) 0
15:28:25 <lambdabot>  Not in scope: `Control.Monad.State.evalState'
15:28:40 <palomer> hrmph, implementing an evaluator in a typed system is hard stuff. in particular, how would I evaluate expressions containing built in functions?
15:29:02 <Lemmih> SamB: My mail is written. Should I CC anyone besides jlouis?
15:29:04 <Cale> built into what?
15:29:18 <palomer> like, eval Application (Var "successor") (IntLit 2) <--how would I evaluate this?
15:29:46 <Cale> However you'd like :)
15:29:57 <gizban> haskell's type checking is going to cause me to snap
15:30:13 <palomer> Cale: I would have to look up successor in a table, correct?
15:30:19 <Cale> eval (Application (Var "successor") (IntLit x)) = IntLit (x+1)
15:31:00 <palomer> ok, what about Application (Var "firstCharacter") (StringLit "hello")
15:31:42 <Cale> eval (Application (Var "firstCharacter") (StringLit xs)) = if null xs then Wrong else CharLit (head xs)
15:31:44 <palomer> the problem is that successor and firstCharacter cannoct reside in the same table because they aren't part of the same type
15:32:12 <Lemmih> palomer: But they /do/ have the same type.
15:32:15 <Cale> They aren't?
15:32:27 <Cale> They're just maps Expr -> Expr
15:32:50 <palomer> oh, righto
15:33:08 <palomer> good point
15:33:57 <palomer> Cale: how is the Term datatype presented in the wobbly type paper (seen previously elsewhere) useful for anything?
15:34:02 <palomer> Cale: it doesn't contain the function Terms
15:35:04 <lennart> palomer: As long as you have untyped expression trees you are fine.  It's when you use GADTs to have typed expression trees that you have to work harder.
15:36:12 <palomer> lennart: yeah, but in peyton's paper, he doesn't give a constructor for lambdas
15:36:21 <palomer> or application
15:36:29 <lennart> no, but you can
15:36:36 <lennart> it's just tricky
15:37:05 <lennart> you need a typed environment
15:37:54 <lennart> I don't know where it might be written up, but if you get Tim Sheard's Omega I'm sure it's in his examples.
15:38:34 <palomer> but Omega is depedently typed
15:38:34 <palomer> no?
15:38:49 <lennart> no
15:39:04 <lennart> Just GADTs, but with a richer kind system
15:39:15 <lennart> you can do it with ghc too
15:39:29 <palomer> lennart: is that what you did with your HOAS interpreter?
15:40:13 <lennart> no, I only have a universal type
15:40:35 <lennart> expression type, I mean
15:40:43 <lennart> like your Expr
15:40:57 <Mitar> i can use "foldr (:) list" and get the same list
15:41:06 <Mitar> how could i use foldr in the same manner?
15:41:12 <Mitar> (just curious)
15:41:17 <lennart> huh?
15:41:43 <lennart> Mitar: was one of those foldr supposed to be something else?
15:42:10 <Mitar> ah
15:42:13 <palomer> foldr (:) nil list
15:42:15 <Mitar> foldr (:) [] list
15:42:30 <lennart> yes, but what was your question?
15:42:41 <Mitar> so is there a way to make a similar function with foldl
15:42:52 <lennart> ah, foldl (you said foldr)
15:42:54 <Mitar> is there any inverse :
15:43:08 <palomer> foldl (\x y -> concat x  [y]) nil list should do it
15:43:14 <lennart> there's no nice inverse
15:43:33 <palomer> grr, import Data.Map gives a name collision, namely lookup
15:43:42 <palomer> how do I stop these collisions?
15:43:55 <lennart> Use a qualified name, or hide one of them
15:44:03 <palomer> lennart: how do I hide?
15:44:08 <lennart> import Prelude hiding (lookup)
15:44:30 <palomer> but Prelude is imported by default, no?
15:44:48 <lennart> yes, but if you import it yourself that overrides the implicit import
15:44:59 <palomer> ah, gotcha
15:45:07 <palomer> ah, gotcha
15:45:22 <lennart> e.g. 'import Prelude()' to get rid of it all :)
15:46:21 <Nanar> what mean (..) in import Foo (..) ?
15:47:44 <palomer> ok, I see how my base functions have to be of type Exp -> Exp
15:47:56 <palomer> but what if I have something like add, which is of type Exp -> Exp -> Exp
15:48:23 <lennart> what about it?
15:48:25 <palomer> eval (Var "add") (IntLit 2) would return what?
15:48:45 <palomer> eval (Application (Var "add") (IntLit 2)) env
15:48:58 <lennart> yes
15:49:07 <lennart> something likethat
15:49:17 <palomer> but what would it return?
15:49:30 <lennart>  (Application (Var "add") (IntLit 2))
15:49:57 <lennart> You can't do anything, so you have to return it as is
15:50:06 <palomer> oh my, this makes my rules much more complicated
15:50:18 <palomer> it means I need to keep an arity in my lookup table
15:50:25 <lennart> yep
15:51:03 <palomer> it also means that the first argument to an Application may neither be a lambda nor a var
15:51:10 <lennart> yep
15:51:17 <palomer> how do I deal with the latter case?
15:51:37 <lennart> you can pattern match on that case too
15:51:46 <lennart> but it can easily get messy
15:52:43 <palomer> yeah
15:52:57 <palomer> like if I have an arity 5 function, I would need 5 patterns!
15:53:01 <lennart> what I usually do is to keep a stack of arguments.  as you traverse down the left spine of a chain of applications you put the arguments on a stack (i.e. a list).  when you hit a lambda or a primitive you take arguments from the stack and reduce
15:53:59 <lennart> the primives can then take the stack and return a new expression and the left-over stack
15:54:18 <lennart> but there are many ways to skin a cat. :)  this is just one
15:55:23 <palomer> eval foo = foldl (\x sofar-> case x of Application (Application a) b -> sofar::b ; Application (Var x) b -> pass sofar to x) nil foo 
15:55:26 <palomer> something like that?
15:55:59 <palomer> lennart: using HOAS, we avoid all this mess, right?
15:56:11 <ihope> @pl \n k -> fac n / (fac k * fac (n-k))
15:56:12 <lambdabot> ap ((.) . (/) . fac) (liftM2 (*) fac . (fac .) . (-))
15:56:52 <lennart> palomer, hmmm, i'm not sure
15:57:21 <ihope> @hoogle liftM2
15:57:22 <lambdabot> Control.Monad.liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m
15:57:22 <lambdabot> r
15:58:01 <lennart> palomer: if you look at hfnd in darcs.augustsson.net/Darcs/PTS/PTSEval.hs you can see what i meant with the stack
15:58:01 <palomer> lennart: that would map Application (Application (Application "foo" a) b) c to ("foo",[a,b,c]) or something
15:59:58 <palomer> yeah, that could work
16:00:54 <Cale> palomer: what's wrong with simply extending the GADT with:
16:00:57 <Cale>     Fun    :: (a -> b) -> Term (a -> b)
16:00:58 <Cale>     App    :: Term (a -> b) -> Term a -> Term b
16:01:04 <Cale> and eval with:
16:01:05 <Cale> eval (Fun f)      = f
16:01:06 <Cale> eval (App f x)    = eval f (eval x)
16:01:55 <Cale> for builtins, that'll work just fine. For lambdas, you have to do some more work perhaps.
16:02:33 <palomer> the problem is Fun, it would mean that I would have to translate the interpreted code into haskell code
16:02:43 <palomer> making eval pretty useless
16:02:46 <lennart> Cale: building something of type Term T is a little tricky
16:02:48 <SamB> Lemmih: thats fine...
16:03:11 <SamB> I've got the list in emergency moderated mode anyway
16:03:17 <lennart> Cale: building it dynamically, i mean.  from parsing a file
16:03:22 <Cale> ah
16:03:32 <lennart> not impossible, but tricky
16:03:50 <Cale> I suppose it's tricky to assign a type to the parser
16:03:56 <palomer> I'd like to see a haskell implementation of it
16:04:26 <palomer> Cale: convert "\x -> x y" into something of type a -> b
16:04:32 <lennart> palomer: Stephanie Weirich has one.  I'm not sure it it's available anywhere
16:05:02 <lennart> and i'm not totally sure how much it covers
16:05:31 <ihope> @pl \x y -
16:05:32 <lambdabot> (line 1, column 6):
16:05:32 <lambdabot> unexpected end of input
16:05:32 <lambdabot> expecting "->"
16:05:42 <lennart> but it has lambda and application
16:05:43 <ihope> @pl \x y -> y x
16:05:44 <lambdabot> flip id
16:08:12 <lennart> @pl \ a b c d e f g h i j k l m n o p q r s t u v w x y z -> t h e f o x j u m p s o v e r t h e l a z y d o g
16:08:29 <lambdabot> const . const . (((((const .) .) .) .) .) . ((((((const .) .) .) .) .) .)
16:08:29 <lambdabot> . ((((((((const .) .) .) .) .) .) .) .) . ((((((((((const .) .) .) .) .) .
16:08:29 <lambdabot> ) .) .) .) .) . (((((((((((((((const .) .) .) .) .) .) .) .) .) .) .) .) .
16:08:29 <lambdabot> ) .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .)
16:08:29 <lambdabot> .) . ((((((flip .) .) .) .) .) .) . (((((((flip .) .) .) .) .) .) .) . (((
16:08:31 <lambdabot> [66 @more lines]
16:08:32 <lambdabot> optimization suspended, use @pl-resume to continue.
16:09:38 <shapr> What's the opposite of golf?
16:09:41 <lennart> i'm just as glad i left out "quick brown"
16:09:50 <Heffalump> @pl \ a b c d e f g h i j k l m n o p q r s t u v w x y z -> t h e q u i c k b r o w n f o x j u m p s o v e r t h e l a z y d o g
16:09:51 <dcoutts> hey xerox, still about?
16:09:54 <lennart> shapr: flog?
16:09:55 <lambdabot> (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . (((((((flip .) .
16:09:55 <lambdabot> ) .) .) .) .) .) . ((((((((flip .) .) .) .) .) .) .) .) . (((((((((flip .)
16:09:55 <lambdabot> .) .) .) .) .) .) .) .) . ((((((((((flip .) .) .) .) .) .) .) .) .) .) . (
16:09:55 <lambdabot> ((((((((((flip .) .) .) .) .) .) .) .) .) .) .) . ((((((((((((flip .) .) .
16:09:55 <lambdabot> ) .) .) .) .) .) .) .) .) .) . (((((((((((((flip .) .) .) .) .) .) .) .) .
16:09:57 <lambdabot> [182 @more lines]
16:10:00 <lambdabot> optimization suspended, use @pl-resume to continue.
16:10:00 <Heffalump> cool, no consts
16:10:06 <shapr> Ok, Haskell flog it is :-)
16:10:25 <shapr> Flogging the channel no doubt.
16:10:28 <lennart> Heffalump: you're right.  silly me :)
16:11:54 <dcoutts> xerox: oh I see. We can talk later.
16:12:04 <Heffalump> shapr: FWIW, Igloo and I have tracked down the current known problem with GHC and ARM and know how to fix it. When and whether it'll happen is a different matter, but I can explain it to anyone else that wants to too.
16:12:30 <shapr> Would be useful to me. I think it's likely I'll have a Nokia 770 and the wish to run GHC on it.
16:12:44 <shapr> even at .. 200MHz?
16:13:07 <shapr> I suspect the 770 will be the first in a series much like the palm.
16:13:22 <lennart> shapr: i think i'd rather run hugs
16:13:53 <Heffalump> it would be nice if GHC could cross-compile
16:14:22 <shapr> Maybe jhc or nhc98 would be nicer on the 770?
16:14:32 <palomer> @hoogle lookup
16:14:33 <Heffalump> the fix actually seems relatively simple, so if someone has the infrastructure set up (e.g. an ARM, or an emulation environment), I could probably talk them through the fix.
16:14:33 <lambdabot> Data.HashTable.lookup :: HashTable key val -> key -> IO (Maybe val)
16:14:33 <lambdabot> Data.IntMap.lookup :: Key -> IntMap a -> Maybe a
16:14:33 <lambdabot> Data.List.lookup :: Eq a => a -> [(a, b)] -> Maybe b
16:14:44 <palomer> @hoogle Data.Map.lookup
16:14:46 <lambdabot> Prelude.undefined :: a
16:14:46 <lambdabot> Test.QuickCheck.Batch.bottom :: a
16:14:52 <palomer> @type Data.Map.lookup
16:14:54 <lambdabot> forall a (m :: * -> *) k.
16:14:54 <lambdabot> (Ord k, Monad m) =>
16:14:54 <lambdabot> k -> Data.Map.Map k a -> m a
16:15:00 <palomer> where does that m popup?
16:15:17 <shapr> Maemo is a modified debian on ARM
16:15:30 <Heffalump> palomer: so you can get a result in any monad you want
16:15:34 <Heffalump> the most common one to use would be Maybe
16:15:54 <lennart> Heffalump: i think that's very fishy
16:15:56 <palomer> Heffalump: and how would it guess which monad I want?
16:16:03 <Heffalump> palomer: type inference
16:16:14 <Heffalump> lennart: my explanation, or the behaviour of lookup?
16:16:22 <lennart> the behaviour
16:16:50 <lennart> i'm guessing it's using mfail?
16:17:08 <Heffalump> it uses fail.
16:17:33 <Heffalump> it's acutally implemented in terms of a version that is just Maybe :-)
16:17:35 <lennart> yeah, I too long for the days of MonadZero
16:17:51 <Heffalump> isn't fail just mzero for any sane MonadZero, though?
16:18:36 <lennart> Heffalump: probably, but i don't think there's even such a recommendation in the report
16:18:37 <palomer> and how do you insert many items into a Map ?
16:19:07 <lennart> palomer: foldr (uncurry insert)
16:20:00 <palomer> uncurry?
16:20:03 <palomer> @type uncurry
16:20:05 <lambdabot> forall c b a. (a -> b -> c) -> (a, b) -> c
16:20:05 <palomer> @hoogle uncurry
16:20:06 <lambdabot> Data.Tuple.uncurry :: (a -> b -> c) -> (a, b) -> c
16:20:06 <lambdabot> Prelude.uncurry :: (a -> b -> c) -> (a, b) -> c
16:20:18 <Heffalump> that's just to make insert have the right type to feed to foldr
16:20:18 <palomer> foldr doesn't use tuples, does it?
16:20:29 <Heffalump> no, but your list of many items to insert will be a list of tuples of key,value
16:20:45 <palomer> oh
16:21:36 <Heffalump> @type foldr (uncurry Data.Map.insert)
16:21:37 <lambdabot> forall a b.
16:21:37 <lambdabot> (Ord a) =>
16:21:37 <lambdabot> Data.Map.Map a b -> [(a, b)] -> Data.Map.Map a b
16:21:43 <Heffalump> see :-)
16:22:14 <lennart> I wish Data.Map had that function instead of 53 others that I never use :)
16:25:16 <palomer> but it reversese the order of the arguments
16:25:30 <palomer> @type Data.Map.insert
16:25:32 <lambdabot> forall a k.
16:25:32 <lambdabot> (Ord k) =>
16:25:32 <lambdabot> k -> a -> Data.Map.Map k a -> Data.Map.Map k a
16:26:18 <palomer> @type \x y -> foldr (uncurry Data.Map.insert) y x
16:26:19 <lambdabot> forall a b.
16:26:19 <lambdabot> (Ord a) =>
16:26:19 <lambdabot> [(a, b)] -> Data.Map.Map a b -> Data.Map.Map a b
16:26:33 <palomer> there we go
16:26:41 <lennart> use flip :)
16:27:15 <palomer> @type flip
16:27:15 <SyntaxNinja> anyone trying to get ahold of me lately?
16:27:16 <lambdabot> forall c a b. (a -> b -> c) -> b -> a -> c
16:27:30 <palomer> flip x y z = y x z ?
16:28:28 <lennart> @djinn (a -> b -> c) -> b -> a -> c
16:28:29 <lambdabot> f a b c = a c b
16:30:53 <Heffalump> SyntaxNinja: naah, you're far too boring for interesting people like us to talk to
16:32:39 <SyntaxNinja> Heffalump: oh, to answer a question you had some time back: "sudo rm -rf ~/ /"
16:32:56 <SyntaxNinja> you'll have to type your password into IRC.
16:33:47 <Heffalump> SyntaxNinja: ah, ta
16:34:12 <Heffalump> it wants a password, should I type it into the shell too?
16:35:29 * palomer is starting to better understand the state monad
16:35:33 <SyntaxNinja> Heffalump: it should be your IP address.
16:36:31 <palomer> is there a reason why we never evaluate inside a lambda?
16:36:42 <palomer> (is it semantically goofy?)
16:37:43 <lennart> no, it's fine.  but it's easier for real implementations not to go inside lambda
16:38:22 <lennart> if you evaluate under lambda you have to be able to evaluate with free variables
16:38:40 <Heffalump> you also can't do anything that might cause non-termination
16:39:16 <Heffalump> SyntaxNinja: is your email working again now, btw?
16:40:28 <SyntaxNinja> Heffalump: ijones@debian.org for now
16:41:02 <Heffalump> ok (not that I can think of a reason I need to email you for in the near future)
16:43:49 <SyntaxNinja> oh :(
16:45:13 <_deepfire> guten tag, folks
16:45:42 <_deepfire> does anybody know a nice haskell-based wiki with access control?
16:46:14 <_deepfire> flippi doesn`t seem to provide such, aiui
16:46:48 <Lemmih> _deepfire: I don't think there are any.
16:47:16 <_deepfire> how unfortunate... :-/
16:47:32 <Lemmih> _deepfire: You could write one (:
16:47:39 <palomer> @type flip $ foldr (uncurry Data.Map.insert)
16:47:41 <lambdabot> forall a b.
16:47:41 <lambdabot> (Ord a) =>
16:47:41 <lambdabot> [(a, b)] -> Data.Map.Map a b -> Data.Map.Map a b
16:48:16 <_deepfire> Lemmih, that sounds like a compliment :-)
16:49:58 <_deepfire> but, unfortunately, i have no heart for this...
16:50:34 <_deepfire> i`m afraid i`m on the consumer side of the affair
16:50:55 <_deepfire> anyway, sorry to disturbance, if any...
16:51:40 <SyntaxNinja> why do so many ppl care what language things are written in?
16:52:43 <dons> because you go to hell if you use the wrong language.
16:52:53 <dons> didn't you know? ;)
16:53:32 <SyntaxNinja> even if you just use the application?!
16:53:33 <lennart> or the wrong OS
16:53:36 <Heffalump> makes hacking on them easier, potentially
16:53:43 <SyntaxNinja> I thought you went to hell if you had to learn a new language ;)
16:54:11 <Heffalump> but didn't sound like he wanted to hack on the wiki he was looking for
17:07:05 <lennart> is there any way to have darcs preserve the executable flag of files?
17:09:37 <SyntaxNinja> there's --set-scripts-executable on pull (or get?)
17:09:59 <Mitar> are those correct "filter" and "map" functions in CPS style: http://pastebin.com/491087
17:10:09 <Mitar> (i am reading yet another tutorial)
17:10:19 <lennart> SyntaxNinja: ah, thanks.  And why isn't that default?
17:10:46 <SyntaxNinja> lennart: not sure, actually.
17:12:36 <lennart> hmmm, and how do I get darcs to notice that the executable flag of a file has changed?
17:14:34 <SyntaxNinja> lennart: it doesn't work like that; it looks for the #! at the top of the file, as I understand it.
17:14:50 <lennart> Urgh!
17:15:01 <lennart> Then I understand why it's not default
17:15:10 <SyntaxNinja> it's pretty quirky. this strangeness has to do with the fact that darcs works for operating systems which don't have such things as permissions
17:15:26 <SyntaxNinja> or filesystems which don't have such things
17:15:28 <lennart> and so the rest of us have to be punished
17:15:52 <SyntaxNinja> well, in general, it's not clear that permissions "translate" between users even. my groups are not your groups, my world is not your workd.
17:16:16 <Mitar> SyntaxNinja, can you throw an eye on my code?
17:16:17 <Mitar> :-)
17:16:27 <lennart> I think preserving the flags for the owner would go a long way
17:16:30 <SyntaxNinja> I'm sure this has been discussed, you might google around for solutions if no one here has more input
17:16:49 <lennart> even cv preserved my flags
17:16:51 <lennart> cvs
17:17:12 <SyntaxNinja> lennart: I have the feeling that it might be one of the many things he's waiting for the haskell filesystem for. so you can whip me (or my employer) to get that out.
17:17:28 <SyntaxNinja> Mitar: if it's really easy ;) link?
17:17:53 <Mitar> http://pastebin.com/491087
17:18:03 <Mitar> (02:11:38) Mitar: are those correct "filter" and "map" functions in CPS style: http://pastebin.com/491087
17:18:03 <Mitar> (02:11:47) Mitar: (i am reading yet another tutorial)
17:18:23 <lennart> SyntaxNinja: I'll whip John, but I'm not sure I'll switch file system anyway. :)
17:18:51 <SyntaxNinja> lennart: it doesn't actually require you to switch filesystems, it would be something that darcs uses internally
17:19:33 <lennart> oh yes, good point
17:22:13 <Squall`> I'm sorry for asking such a basic question, but I've only been learning Haskell for a few minutes. I'm reading a tutorial and as an exercise it asked me to use the fst and snd functions to extract 'a' from ((1,'a'),"foo"). I assumed fst snd ((1,'a'),"foo") would work, but it doesn't. I'm pretty sure the error is in the syntax, rather than my approach. Can someone point me toward the right answer?
17:22:30 <SyntaxNinja> Mitar: sorry, I don't know what CPS is/
17:22:50 <Mitar> continuation passing style
17:22:56 <SyntaxNinja> Squall`: try parens :)
17:23:00 <lennart> Squall: fst (snd ((1,'a'),"foo"))
17:23:04 <SyntaxNinja> > fst (snd (1,2))
17:23:05 <lambdabot>  add an instance declaration for (Num (a, b))
17:23:16 <SyntaxNinja> >  fst (snd ((1,'a'),"foo"))
17:23:18 <lambdabot> Couldn't match `(a, b)' against `[Char]'
17:23:42 <lennart> hmmm, yes :)
17:23:46 <Mitar> yet another tutorial, page 53
17:24:05 <Squall`> SyntaxNinja, thanks. I'm trying out haskell and functional programming for the first time.
17:24:16 <Squall`> oh, and lennart too
17:24:39 <Mitar> http://www.isi.edu/~hdaume/htut/
17:25:33 <SyntaxNinja> squall, also ,it's not the first of the second, it's the second of the first.
17:25:49 <SyntaxNinja> >  snd (fst ((1,'a'),"foo"))
17:25:50 <lambdabot> 'a'
17:26:29 <Mitar> anyone?
17:28:33 <lennart> Mitar: no, that's not right
17:29:12 <lennart> cmap needs a continuation argument
17:31:16 <Mitar> is not that it: (\x g -> (f x) : g)
17:32:54 <Squall`> So far, this seems to be a very refreshing break from Java and C :)
17:33:28 <Mitar> lennart: a suggestion please ...
17:34:01 <Cale> Squall`: Watch out, it's addictive :)
17:36:07 <orzo> hello
17:36:24 <orzo> I know absolutely no haskell
17:36:40 <orzo> I'm curious what haskell really excels at
17:37:00 <orzo> what people apreciate about it
17:43:36 <gizban> orzo: check out "Real World Applications of Functional Programming" http://www.haskell.org/practice.html.  I've only been using haskell for about a week, so I'm no expert.
17:46:16 <Mitar> hm
17:46:23 <Mitar> so what is wrong?
17:46:48 <Cale> Mitar: hm?
17:46:59 <Mitar> http://pastebin.com/491087
17:47:06 <Cale> orzo: It's quite good at a lot of things
17:47:34 <gizban> I've learned that it's not very good at making emulators
17:47:57 <Cale> gizban: emulators of what sort?
17:48:17 <Mitar> i would like to make it in "Continuation Passing Style"
17:48:24 <gizban> Core War is kind of like an emulator.  I'm in the process of making a core war implementation
17:48:41 <Cale> gizban: it would be fine at that
17:49:11 <gizban> the lack of global variables is kind of annoying, having to pass the core to every function that uses it
17:49:38 <Cale> Mitar: the basic idea with CPS is that functions take an extra parameter which is the function to which their result should be passed
17:51:39 <Cale> For example, where I might normally write  succ x = x + 1
17:51:51 <Cale> I'd write  succ x k = k (x + 1)
17:52:35 <araujo> > maximum ["hello" , "hi world" , " foo bar baz"]
17:52:36 <lambdabot> "hi world"
17:52:47 <araujo> Shouldn't it take the latest element?
17:52:52 <Cale> gizban: that's what a reader monad or state monad is for
17:53:27 <gizban> I don't know what a monad is.  Maybe I should look that up.
17:53:59 <Cale> araujo: hm?
17:54:05 <Cale> > minimum ["hello" , "hi world", "foo bar baz"]
17:54:07 <lambdabot> "foo bar baz"
17:54:10 <Cale> > minimum ["hello" , "hi world", " foo bar baz"]
17:54:12 <lambdabot> " foo bar baz"
17:54:47 <Cale> > ord 'f'
17:54:49 <lambdabot> 102
17:54:51 <Cale> > ord ' '
17:54:53 <lambdabot> 32
17:54:55 <Cale> > ord 'h'
17:54:57 <lambdabot> 104
17:55:42 <araujo> Cale, oh, thanks
17:55:51 * araujo was confused about what maximum did
18:00:32 <Mitar> Cale: is this better: http://pastebin.com/491139
18:02:34 <boobhz> word
18:02:39 <boobhz> hows life in haskell world
18:02:54 <boobhz> hey
18:03:01 <boobhz> Im looking a lot at perl poe
18:03:03 <boobhz> poe
18:03:07 <boobhz> and it seems cool
18:03:13 <boobhz> can haskell do this kinda stuff?
18:03:25 <Heffalump> yes, though AFAIK no such framework exists now
18:15:50 <Mitar> is this now correct CPS version of functions: http://pastebin.com/491139
18:15:51 <Mitar> ?
18:17:20 <boobhz> ok
18:17:36 <boobhz> is learning haskell a better way to go to eventually make cool webapps because it has more power than say perl
18:17:48 <boobhz> or is haskell tooo young
18:17:51 <Mitar> it has the same power
18:17:58 <Mitar> both are turing complete
18:18:11 <orzo> so is assembler language
18:18:17 <orzo> you want to write web aps in it?
18:18:40 <Mitar> nice idea
18:18:41 <Mitar> i have never ...
18:18:48 <Mitar> but it would be interesting
18:18:50 <sproingie> haskell is strongly typed.  it demands a lot that way
18:19:02 <sproingie> comparing it to perl is ... not entirely useful
18:19:23 <orzo> i know ocaml
18:19:33 <orzo> hows it compare to that?
18:19:54 <sproingie> less noisy-looking than ocaml
18:20:09 <sproingie> type classes rule
18:20:39 <orzo> does any other language do type classes haskell style?
18:21:06 <sproingie> don't really know offhand.  nothing mainstream
18:21:13 <Oejet> Grrr, the current record selector functions are noise in my eyes.
18:22:50 <sproingie> boobhz: perl POE is heinous nasty stuff.  real concurrency is a lot more elegant
18:23:56 <orzo> partial differential equations?
18:25:38 <sproingie> math is hard, let's go shopping
18:32:57 * araujo next to upload the new hashell web site design
18:40:31 <araujo> Done.
18:46:26 <SamB> shapr: want to join the list?
18:47:28 <sproingie> (32bit)chuck@tetsuo:~/dl/hashell-0.011a$ runhaskell Setup.hs configure
18:47:28 <sproingie> *** Exception: Line 14: Unknown field 'hs-source-dirs'
18:48:22 <araujo> mmm....
18:49:45 <araujo> sproingie, which version of Cabal and ghc?
18:50:03 <sproingie> ghc6.4 ... how do i know what version of Cabal that has?
18:50:24 <araujo> ghc-pkg list
18:50:45 <sproingie> 1.0 ... guess i gotta upgrade
18:50:53 * araujo nods
18:52:34 <SamB> dons: hmp3 doesn't like emtpty files much, does it?
18:52:52 <sproingie> hm.  latest version i see on cabal's site is 1.2 ... do i need to get it out of darcs?
18:54:56 <araujo> sproingie, taht should work
18:55:40 <araujo> mmm....
18:55:50 <araujo> sproingie, sorry, just fixed the typo in the web site
18:57:27 <sproingie> argh.  i installed the new cabal and now it has conflicts all over
18:57:42 <sproingie> how do i delete the old version?
18:58:11 <sproingie> ghc-6.4: Error: module 'Distribution.Compat.ReadP' is exposed by package Cabal-1.0 and package Cabal-1.1.4
18:58:21 <sproingie> ... and so on for many lines
19:02:11 <palomer> is Kind application left or right associative?
19:02:21 <SamB> ghc-package hide?
19:02:28 <lispy> palomer: hmm...same as types iiirc
19:02:32 <SamB> palomer: huh?
19:02:38 <dons> SamB, empty .mp3 files?
19:02:52 <SamB> dons: yes!
19:02:55 <sproingie> aha, ghc-pkg unregister
19:03:03 <SamB> from not-totally-downloaded torrents!
19:03:14 <palomer> and why don't people boost up the precendence of return?
19:03:21 <SamB> here is some test data: ""
19:03:25 <palomer> lispy: thx
19:03:45 <palomer> SamB: is A B C = A ( B C) or (A B) C
19:03:59 <sproingie> still no luck building hashell
19:04:00 <dons> SamB, thanks. but reallyy it's mpg321 that doesn't like []
19:04:06 <sproingie> ghc-6.4: unknown package: plugins-1.0
19:04:18 <sproingie> and it is installed
19:04:21 <dons> @where hs-plugins
19:04:22 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
19:04:28 <SamB> how do you apply kinds, anyway
19:04:35 <SamB> dons: what does it do?
19:04:38 <palomer> A kind is a function from types to types
19:04:39 <sproingie> i already built and installed hs-plugins
19:04:45 <sproingie> it shows up in ghc-pkg list
19:05:02 <SamB> palomer: you mean like this?
19:05:17 <SamB> @kind (#,#)
19:05:18 <lambdabot> parse error on input `,'
19:05:33 <SamB> hmm.
19:05:46 <SamB> @kind []
19:05:47 <lambdabot> * -> *
19:05:52 <SamB> @kind (->)
19:05:54 <lambdabot> ?? -> ? -> *
19:06:05 <SamB> where is the application going on?
19:06:16 <palomer> @kind Maybe
19:06:17 <lambdabot> * -> *
19:06:25 <palomer> @kind Maybe String
19:06:27 <lambdabot> *
19:06:34 <araujo> sproingie, What distro are you using?
19:06:38 <palomer> Maybe String is Maybe applied to String
19:06:43 <lispy> palomer: it's safest to get a second opinion :)
19:06:48 <SamB> Maybe is not a kind
19:07:10 <SamB> a kind is the "type" of a function from types to types...
19:07:14 <SamB> or of a type
19:07:45 <SamB> so, a kind is to a type expression as a type is to a regular expression...
19:08:02 <lispy> regular expressions? ;)
19:08:46 <SamB> normal expressions...
19:09:05 <sproingie> araujo: ubuntu
19:09:27 <lispy> SamB: normal expressions is somewhat missleading too....normal order...normal form...
19:09:30 <araujo> sproingie, mm.. i suppose you are using apt and such?
19:09:32 <sproingie> in a 32bit chroot, since the 64bit ghc is broken
19:09:34 <palomer> ok, so parametric type application
19:09:34 <lispy> SamB: it's hard to clarify :)
19:09:47 <Saulzar> fred expressions
19:09:56 <SamB> like, you know, this kind!
19:10:00 <SamB> > []
19:10:01 <sproingie> araujo: yeah, this one is installed from apt
19:10:01 <lambdabot> Add a type signature
19:10:08 <SamB> > [] :: String
19:10:09 <lambdabot> ""
19:10:22 <lispy> > [] :: Int
19:10:23 <lambdabot> Couldn't match `Int' against `[a]'
19:10:30 <araujo> sproingie, test with hs-plugins 0.9.10
19:10:32 <lispy> er...
19:10:37 <lispy> > [] :: [Int]
19:10:39 <lambdabot> []
19:11:23 <SamB> anyway, as far as I can see, you can't apply kinds, except for ->, which is infix and has the same associativity as usual...
19:11:53 <SamB> and arguably isn't a kind
19:12:05 <lispy> SamB: not all possible types are available in haskell or ghc
19:12:11 <sproingie> araujo: it has a ./configure script, which never fails to fuck up in a chroot
19:12:15 <SamB> lispy: oh.
19:12:17 <sproingie> (32bit)chuck@tetsuo:~/dl/hs-plugins-0.9.10$ ./configure --prefix=/usr/local
19:12:17 <sproingie> checking build system type... x86_64-unknown-linux-gnu
19:12:20 <SamB> you mean in general?
19:12:22 <sproingie> one of these lines is not like the other
19:12:59 <dons> sproingie -- it wants hs-plugins 1.0
19:13:00 <SamB> in Agda, Cayenne, in Omega or in Epigram?
19:13:14 <sproingie> dons: that's what i installed
19:13:27 <dons> why are you building 0.9.10 then?
19:13:49 <SamB> in those, I'd imagine the usual application associativity would apply...
19:13:57 <sproingie> dons: because araujo suggested it
19:14:30 * sproingie shudders at hacking the configure script to make the arch detect right...
19:14:52 <sproingie> arch on ia32 just returns 'x86', right?
19:15:19 <SamB> arch?
19:15:23 <sproingie> uname -m
19:15:34 <SamB> i686
19:15:48 <SamB> thats on a 686
19:15:50 <sproingie> ah, duh.  ok.
19:16:22 <SamB> you might want a [345]86 instead
19:16:23 <sproingie> i should just replace uname and arch with wrappers that lie
19:16:38 <araujo> dons, i suggested, since ive only tested hashell with 0.9.10
19:16:44 <araujo> dons, should it also work with 1.0?
19:17:00 <SamB> or 32-bit versions ;-)
19:17:39 <dons> araujo, should work. only the bulid system has changed significantly, to use Cabal
19:18:17 <araujo> sproingie, So, you shouldn't have problem using 1.0 then
19:18:45 <sproingie> well, it doesn't appear to find it
19:20:04 <araujo> sproingie, it is in your list of ghc-pkg?
19:20:08 <sproingie> yes
19:20:46 <araujo> sproingie, Do you use hs-plugins with anything else?
19:20:49 <sproingie> meh.  i just rebuilt hs-plugins and reinstalled and it works now
19:21:01 <sproingie> rebuilt with the newer cabal.. wonder if there was a problem with the old one
19:21:57 <sproingie> yay, it works
19:22:10 <araujo> Good.
19:22:17 <sproingie> it doesn't chmod +x /usr/local/bin/hashell, btw
19:23:07 <palomer> yes!
19:24:11 <araujo> sproingie, it does here.....
19:24:18 <sproingie> strange
19:30:01 <palomer> seriously, someone boost up the precedence of return!
19:30:45 <Heffalump> palomer: huh?
19:32:50 <palomer> return (a b c) should really be written return a b c
19:33:18 <Heffalump> return $ a b c
19:33:29 <SamB> you want to confuse people even more?
19:33:36 <Heffalump> one of the nice things of the design of Haskell is that it doesn't have very many special cases
19:33:45 <Heffalump> Adding one for return would be bad for that reason, if nothing else.
19:33:56 <SamB> I like knowing that I don't have to worry about precedence unless I've got an infix funtion
19:34:15 <Heffalump> and you'd have to majorly rework the way Haskell handles precedence to make it even possible.
19:35:15 * Heffalump goes to bed, really late
19:36:07 <araujo> sproingie, i appreciate any bug report if possible :-]
19:38:10 <palomer> is + considered an identifier in haskell?
19:38:37 <SamB> yup!
19:46:48 <lispy> anyone around that knows the darcs code?
19:47:01 <lispy> i could use some help understanding some code
19:47:54 <lispy> @type (+)
19:47:55 <lambdabot> forall a. (Num a) => a -> a -> a
19:51:11 <lispy> palomer: if return a b c = (return a b c) then what about return 1 ++ [2]
19:51:29 <lispy> hm...maybe that's a bad example...
19:51:59 <lispy> yup...bad example :)
19:55:10 <palomer> somebody should write a tutorial on how to properly display a lambda term
19:55:36 <palomer> seriously, everyone is used to return having greater precedence
19:55:54 <SamB> not unless it is a keyword
19:56:21 <SamB> they are also used to it leaving a function entirely...
19:58:04 <lispy> what is a pre_changed_file in darcs terminology?
19:58:47 * lispy grumbles about lack of documentation in darcs source
20:01:35 <palomer> stop grumbling!
20:02:17 * lispy grumbles about being told what not to do
20:02:46 * lispy ;)
20:05:52 <lispy> does anyone understand Slurpy?
20:07:17 <palomer> darn, lennart left
20:12:47 <palomer> emacs should get smarter about identation
20:14:04 <lispy> palomer: yes, yes it should
20:16:16 <palomer> yes!
20:16:22 <palomer> I have a lambda calculus evaluator
20:16:24 <palomer> no recursion yet
20:16:25 <palomer> :(
20:19:25 <palomer> (coming up!)
20:28:21 <SamB> what is that Parsec-like thingy for Python
20:28:22 <SamB> ?
20:30:11 <shapr> spark? poetix' small imitation?
20:35:38 <SamB> the one you aren't supposed to use?
20:36:28 <SamB> shapr: oh, have you gotten your invite to the Conjure list?
20:37:33 <lispy> i can barely read the code in Diff.lhs...
20:39:59 * lispy is comment as he goes...
20:41:45 <SamB> shapr: where can it be found?
20:42:39 <shapr> poetix' put a version in his blog.
20:45:33 <SamB> @where poetix' blog
20:45:34 <lambdabot> I know nothing about poetix'.
20:46:38 <SamB> shapr: I don't see you on my subscriber list
20:49:23 <palomer> there's this one teacher at my school, she teaches the same thing no matter which class she's teaching
20:49:30 <SamB> ah, http://codepoetics.com/poetix/ for the blog...
20:49:33 <palomer> I've implemented a mini-ml interpreter twice
20:49:38 <palomer> and I'm going to do it a third time this semester
20:49:39 <palomer> weeee
20:50:01 <SamB> why don't you complain?
20:50:24 <SamB> or use the same one?
20:50:27 <palomer> because she's paying me
20:50:56 <palomer> well, I didn't actually implement it the second time, but I was TAing a course in which she was making the students implement it
20:52:34 <SamB> ah
20:52:59 <lispy> hmm...i can tell if this function is being lazy or not
20:53:13 <palomer> is it laying on the couch?
20:53:14 <lispy> i stare at the darcs source and just feel dumb
20:53:31 <lispy> palomer: heh, yeah and eating all my cheetos
20:53:48 <lispy> i've asked it to do the dishes 3 times already...
20:54:03 <SamB> hmm... maybe I cannot find it!
20:54:04 <palomer> my god I hate parsec
20:54:15 <SamB> I don't!
20:54:21 <SamB> you must hate the grammar!
20:54:33 <palomer> no no, it's parsec
20:54:40 <SamB> the grammar!
20:54:44 <palomer> parsec!
20:54:46 <SamB> or you've factored it wrong
20:54:55 <palomer> I like my parser generators to tell me when my grammar is ambiguous
20:55:18 <SamB> parsec is not omniscient
20:55:28 <SamB> anyway, it isn't
20:55:46 <SamB> it just goes left at every opportunity
20:55:53 <palomer> but bison/happy/sablecc are!
20:56:10 <palomer> I like to know that my parsers always halt!
20:56:22 <SamB> they do!
20:56:28 <SamB> sometimes with a stack overflow
20:56:35 <lispy> heh
20:56:48 <lispy> they halt whenever i press Ctrl+C!
20:56:53 <palomer> I've never had bison/happy/sablecc overflow
20:57:08 <palomer> I like that I don't have to add 5 lines of code for every lexical token I add!
20:57:32 <palomer> I like having a grammar tailored to EBNF
20:57:39 <SamB> I admit I'd like a generator that could read my mind, but those that try to fake it never give good errors
20:57:49 <lispy> lets say i have this function.  I suspect it is being strict, how do i check this theory?
20:58:11 <palomer> lispy: sneak up behind it and then WHAMO
20:58:19 <SamB> lispy: you could look at the .hi file to see if GHCi thinks so too
20:58:23 <SamB> er. GHC
20:58:34 <lispy> SamB: just open it in vi?
20:58:42 <SamB> ah, here I am calling Parsec a generator...
20:58:46 <SamB> lispy: no.
20:58:56 <SamB> its in Binary
20:59:00 <lispy> SamB: then how do i "look" at it :)
20:59:25 <SamB> ghc --show-iface, I think
20:59:30 <palomer> Cale: you around?
20:59:31 <SamB> yeah
20:59:51 <lispy> SamB: interesting, what should i look for?
20:59:58 <lispy> i get lots of output...
21:00:09 <SamB> well, | less
21:00:22 <SamB> then /functionIWasWonderingAbout
21:01:11 <lispy> {- Arity: 3 Strictness: SSL -}
21:01:15 <lispy> ssl?
21:01:30 <SamB> strict, strict, lazy
21:01:38 <SamB> notice the arity of 3?
21:01:41 <lispy> for the parameters?
21:01:48 <lispy> okay....
21:01:51 <SamB> of course, GHC could be wrong about the lazy one
21:02:00 <lispy> oh
21:02:28 <SamB> and I think these only refer to WHNF
21:02:39 <SamB> in fact I'm nearly positive
21:02:47 <palomer> ice ice baby
21:03:22 <lispy> well, it's not really helpful anyway since I still don't know anything about the "thingy" i want to be lazily evaluated
21:03:51 <palomer> smoky the bear says : never be lazy with your thingies
21:03:55 <SamB> there isn't much that helps in that kind of situation
21:04:06 <SamB> except learning about thingies
21:04:26 <lispy> emperically, darcs seems to be reading the whole file when it really won't need to...
21:04:35 <SamB> which?
21:04:42 <lispy> which which?
21:04:48 <SamB> which file?
21:05:01 <lispy> `darcs whats -l` appears to force darcs to read all the files in the directory
21:05:13 <SamB> well yeah...
21:05:29 <lispy> but, if i just created a file it should just say, yeah that file is new...
21:05:35 <SamB> hmm?
21:06:16 <lispy> darcs init; cat /dev/zero > foo (interrrupt it after a few seconds); darcs whats -l
21:06:22 <SamB> well, it has to also look at old files to see if you changed them
21:06:29 <lispy> darcs should see foo and immeditately just say "oh, foo is new."
21:06:40 <lispy> instead it reads in foo
21:06:48 <SamB> well.
21:06:48 <palomer> gah!
21:06:54 * palomer beats parsec over the head
21:06:57 <SamB> darcs is expecting foo to be a textfile!
21:07:08 <lispy> computes the patch to add foo to the repository, and then says, oh, btw foo is new and throws away the patch
21:07:08 * SamB beats palomer's grammar over the parsec
21:07:18 <palomer> SamB: you don't understand
21:07:32 <palomer> SamB: here, lemme show you
21:07:37 <SamB> lispy: only because foo turned out to be in binary!
21:07:43 <SamB> it doesn't want to garble the screen.
21:07:52 <lispy> er?
21:08:12 <SamB> what happens if you cat /dev/stdin instead?
21:08:15 <lispy> SamB: --look-for-adds implies --summary, meaning it doesn't need to display the patch details
21:08:29 <SamB> possibly I have an old darcs...
21:08:31 <lispy> just that the file is new
21:08:43 <SamB> but anyway, I don't see how you expect it to do that just by using laziness...
21:09:12 <lispy> isn't that what laziness is for?  computing only what is needed?
21:09:27 <SamB> well, sort of
21:09:30 <lispy> the whole Slurpy thingy seems to be all about storing files so they can be read on demand
21:09:31 <palomer> http://www.rafb.net/paste/results/961Tyf80.html <---/me screams
21:10:13 <SamB> but just like the GC can't get rid of everything that won't be read again, laziness won't avoid computing all results that will not be used...
21:11:30 <lispy> SamB: yeah, i think i need to check for --summary and abort as soon as i notice the new file if it is there
21:12:43 <palomer> SamB: any insight?
21:12:57 <SamB> I think my insight unit is worn out
21:13:03 <SamB> or rather, in need of repose
21:13:07 * SamB goes to bed...
21:13:07 <lispy> problem is...i don't know how to construct a proper return value in that case
21:13:15 <lispy> palomer: i think you need to break it down
21:13:28 <lispy> it looks like a very....monolithic....function
21:13:35 <SamB> lispy: error "something or other"
21:15:06 <lispy> SamB: i know where that place in the code is...i actually wanted to return the proper value...
21:15:45 <lispy> palomer: i think you need try
21:16:00 <palomer> lisppaste2: but choice picks the first one to succeed
21:16:54 <lispy> hmm....
21:17:02 <lispy> does try use choice?
21:17:56 <palomer> hmm?
21:18:05 <palomer> this is the code for the lexer
21:18:18 <palomer> all I did was move up the "if" "then" and "else" tokens
21:18:49 <awarth> hello guys, does anyone here know of a decent intro to template haskell?
21:19:45 <lispy> palomer: yeah, and that's why i think parsec is consuming some input and not behaving in the try/fail manner that you expect.  But, you are using choice.  This made me wonder if try is implemented using choice.
21:20:56 <palomer> choice ps  = foldl (<|>) pzero ps
21:22:13 <lispy> how does parseToken = choice (mapM try [....])  fair?
21:22:25 <lispy> it may not even type check, but it should be close
21:22:51 <lispy> maybe ti's map (try.) [....]
21:22:56 <palomer> yeah, mapping try worked
21:24:00 <lispy> i don't understand try, and it's not always easy to tell when i will have inifinite recursion in my grammer using parsec
21:24:07 <lispy> but otherwise i really likeit
21:24:45 * palomer wishes that he could tell ghc to check that certain functions have exhaustive pattern searches
21:25:35 <lispy> what do you mean?
21:25:53 <lispy> are you compiling with -Wall and -Werror?
21:26:03 <lispy> if not add them and see if you get better results ;)
21:27:39 <palomer> -Wall will give me a _ton_ of warnings
21:27:45 <palomer> a superton!
21:27:55 <lispy> a super megaton!
21:28:21 <lispy> -Wall is -Worth it
21:32:38 <palomer> is it's not like I care about the quality of my code
21:32:48 <palomer> I just want to interpret the factorial function properly
21:36:30 * palomer thinks it's super cool that haskell enforces indentation
21:36:42 <palomer> grr
21:37:18 <palomer> I'm translating let a = b in c as c[Y (\a->b)/a]
21:40:41 <dons> it doesn't, you can always use { ;;; } style code
21:41:16 <lispy> dons: true, but  if finfd when modifying other people code i have to deal with it
21:41:40 <palomer> > fix \fac n -> if n == 0 then 1 else 0 
21:41:41 <lambdabot>  parse error on input `\'
21:41:47 <palomer> > fix (\fac n -> if n == 0 then 1 else 0)
21:41:49 <lambdabot>  add an instance declaration for (Show (a -> t))
21:41:54 <palomer> @type fix (\fac n -> if n == 0 then 1 else 0)
21:41:56 <lambdabot> Not in scope: `fix'
21:42:00 <palomer> grr
21:42:11 <palomer> @pl fix (\fac n -> if n == 0 then 1 else 0)
21:42:12 <lambdabot> flip (flip if' 1 . (0 ==)) 0
21:42:32 <palomer> @pretty fix (\fac n -> if n == 0 then 1 else 0)
21:42:33 <lambdabot> "Parse error" at column 40
21:42:38 <palomer> eh?
21:42:39 <palomer> @help
21:42:41 <lambdabot>  @help <command> - ask for help for <command>
21:42:46 <palomer> @help all
21:42:47 <lambdabot>  @help <command> - ask for help for <command>
21:42:52 <palomer> grr
21:43:00 <Pseudonym> @pretty if True then 1 else 0
21:43:00 <lambdabot> "Parse error" at column 1
21:43:02 <Pseudonym> Ah.
21:43:07 <Pseudonym> Makes sense.
21:43:27 <palomer> eh?
21:43:34 <Pseudonym> It can't handle if-then-else.
21:43:55 <palomer> oh lambdabot, you stupid donkey
21:44:10 <palomer> the fixed point combinator seems evil
21:44:40 <Pseudonym> It is evil.  It causes all sorts of semantic difficulties.,
21:44:47 <palomer> for example?
21:45:20 <Pseudonym> Well, for example, the free theorems only apply to functions expressible without it.
21:45:40 <Pseudonym> But see also this:
21:45:47 <Pseudonym> @google "fast and loose reasoning is morally correct"
21:45:49 <lambdabot> http://lambda-the-ultimate.org/node/view/879
21:45:57 <Pseudonym> Cool name for a paper.
21:46:43 <palomer> makes me want to go to vegas
21:46:58 <palomer> so the paper is about bottom?
21:47:08 <Pseudonym> Something like that.
21:47:29 <Pseudonym> Basically, reason about your programs as if there were no bottom.
21:47:50 <Pseudonym> But then once you've done that, it's possible to repair your reasoning to include the effect of bottom.
21:48:05 <Pseudonym> Read the paper.  It's quite well-written.
21:48:08 <palomer> seems like something a calc I student would be with infinity
21:48:23 <palomer> s/be/do
21:48:28 <Pseudonym> Possibly.
21:48:35 <palomer> yeah, I'll read it once I get my fixed point operator to work
21:48:49 <Pseudonym> From a categorical point of view, the fixpoint operator makes the semantics not Cartesian closed.
21:49:18 <Pseudonym> And from a Curry-Howard point of view, it makes for a more complicated and incomplete logic.
21:49:21 <Pseudonym> Or something.
21:49:48 <Pseudonym> I understand what the C-H correspondence says, but I've never figured out a use for it.
21:50:13 <palomer> I've only found one
21:50:17 <palomer> but it applies to second order logic
21:50:19 <Pseudonym> Which is?
21:50:21 <palomer> C-H is overrated
21:50:25 * Pseudonym nods
21:50:33 <palomer> Pseudonym: do you know about model theory?
21:50:35 <Pseudonym> I used to use it to teach recursion to first years.:-)
21:50:45 <Pseudonym> "Recursion is like proof by induction."
21:50:54 <Pseudonym> I was shocked how well that analogy worked.
21:51:06 <palomer> induction, recursion, same difference
21:51:10 <sieni> palomer: huh, I thought you were talking about emacs
21:51:12 <Pseudonym> Because they'd already seen proof by induction.
21:51:15 <Pseudonym> Anyway.
21:51:16 <palomer> sieni: when?
21:51:20 <Pseudonym> Model theory.  Uhm... a little.
21:51:30 <sieni> palomer: "C-H is overrated" :-)
21:51:35 <palomer> pfft
21:51:52 <lispy> but you can put Curry-Howard to work
21:52:01 <Pseudonym> I understand what a model is, and I know what the category of models for certain types of structure look like.
21:52:02 <lispy> there is a paper that says so
21:52:06 <palomer> Pseudonym: well, you can extend C-H to second order logic (now your types can take terms (not lambda terms, just general terms))
21:52:21 <Pseudonym> Right.
21:52:34 * Pseudonym is reminded of the sillier examples of C++ template metaprogramming
21:52:36 <palomer> Pseudonym: and, well, all arithmetic functions which can be represented by term equalities can be typed in this logic, and the type is going to be:
21:53:16 <palomer> forall n_{i}. (N(n_0) -> N(n_1) -> ... -> N(f(n_0,...,n_n)))
21:53:27 <Pseudonym> Right.
21:53:31 <palomer> and given the type, I can find the term
21:53:42 <palomer> so, for example, I can find the predecessor term with this
21:53:58 <palomer> (it's hard to find without this little theorem)
21:54:24 <palomer> furthermore, I can interpret types in these models
21:54:38 <palomer> and the interpretations of types gives us that all terms typable in this logic are total
21:54:43 <Pseudonym> Ah, cool.
21:54:53 <Pseudonym> It's actually the inverse of theorems for free.
21:55:11 <palomer> I'll have to read that paper one of these days
21:55:27 <palomer> anyways, CH is otherwise useless
21:55:27 <Pseudonym> Or something.
21:55:33 <palomer> I can find a hundred other morphisms with similar properties
21:55:41 <Pseudonym> I think it's interesting.
21:55:53 <palomer> it's only interesting because it's syntactic
21:55:54 <sieni> note to self: get a copy of "types and programming languages"
21:55:58 <Pseudonym> But I think it's also interesting that there's a third "point" so it forms a triangle.
21:56:05 <palomer> sieni: it's free
21:56:13 <palomer> category theory?
21:56:19 <Pseudonym> Yes.
21:56:38 <palomer> categorical models are uninteresting
21:56:42 <Pseudonym> For example: Simply-typed lambda calculus == sequent calculus == Cartesian closed category
21:56:45 <palomer> because the underlying language is uninteresting
21:56:59 <palomer> and what kind of theorems can we state and prove about cartesian closed categories?
21:57:00 <palomer> not much.
21:57:01 <Pseudonym> So there's actually a correspondence between THREE things.
21:57:17 <palomer> Pseudonym: you can throw in games too
21:57:18 <Pseudonym> Well, aren't Cartesian closed categories toposes?
21:57:42 <Pseudonym> If so, there's a lot of things you can prove about them.
21:57:42 <palomer> and what kinds of theorems can we state about these topii?
21:57:52 <palomer> Pseudonym: the predicates are quite silly
21:58:15 <gzl> Pseudonym: other way
21:58:17 <palomer> there exists a,b such that Pair(a,b) isomorphic to Pair(b,a) and other silliness
21:58:19 <Pseudonym> Greek grammar nit: "topoi" is nominative plural.
21:58:25 <Pseudonym> "about these topoi" is therefore wrong
21:58:41 <Pseudonym> gzl: Uhm...right.
21:58:48 <Pseudonym> Anyway.
21:59:23 <Pseudonym> Thinking of programs as proofs does help when you're writing programs sometimes.
21:59:29 <palomer> the most interesting model, by far, is the lambda calculus
21:59:34 <Pseudonym> But apart from that, yeah, I can't really see the point.
21:59:57 <palomer> since you can state things like P=NP
22:01:23 <gzl> what's interesting about cartesian closed categories?
22:01:26 <gzl> never read about them
22:02:14 <Pseudonym> You can program lambda calculus in them.  Duh.
22:02:16 <Pseudonym> :-)
22:02:51 <palomer> you can't "program" anything into them
22:02:54 <palomer> they just sit there and act dumb
22:03:28 <Pseudonym> That's true of many of the programs that I write.
22:03:45 <palomer> gzl: they're a model with the following predicates: Pair, fst, snd, initial, final, isomorphic
22:03:54 <palomer> or, rather, they are a family of models
22:05:12 <gzl> no, I know roughly what they are, but what does all this buy you? you can program lambda calculus in them, fine, but does it really matter?
22:05:22 <palomer> > ((\f -> ((\x -> (f)(x x)))((\x -> (f)(x x)))))((\s -> (\t -> 5)))
22:05:23 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
22:05:23 <lambdabot>   Expected type: t
22:05:23 <lambdabot>   Inferred type: t -> t1
22:05:31 <gzl> does sticking it into a category buy you much?
22:05:32 <palomer> darn you
22:05:42 <palomer> > let y = ((\f -> ((\x -> (f)(x x)))((\x -> (f)(x x))))) in y ((\s -> (\t -> 5)))
22:05:44 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
22:05:44 <lambdabot>   Expected type: t
22:05:44 <lambdabot>   Inferred type: t -> t1
22:05:59 <palomer> > let y = ((\f -> ((\x -> (f)(x x)))((\x -> (f)(x x))))) in y
22:06:00 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
22:06:00 <lambdabot>   Expected type: t
22:06:00 <lambdabot>   Inferred type: t -> t1
22:06:03 <palomer> whoa
22:06:09 <palomer> haskell can't type the fixed point operator
22:06:11 <palomer> wicked.
22:06:19 <Pseudonym> Nope.
22:06:26 <palomer> why the hell not?
22:06:31 <palomer> it's semantically equivalent to:
22:06:37 <palomer> to fix, actually
22:06:46 <Pseudonym> Yes, but you can't type it.
22:06:58 <Pseudonym> Getting rid of the occurs check is possible.
22:07:06 <Pseudonym> But it'd make all sorts of errors correct.
22:07:22 <Pseudonym> So it's generally considered undesirable.
22:07:25 <palomer> so is there a typable fixed point lambda term?
22:07:34 <Pseudonym> Sure.
22:07:39 <palomer> which one?
22:07:43 <Pseudonym> let y f = f (y f) in y
22:07:48 <palomer> that's not a lambda term!
22:07:57 <Pseudonym> Sorry, I misread.
22:08:05 <Pseudonym> No,there's not.  Not in System F.
22:08:22 <palomer> what's the occurs check?
22:08:40 <Pseudonym> It's the rule that says that you can't unify x with f(x)
22:08:54 <palomer> you can never unify x with f(x)
22:09:20 <Pseudonym> You could if you allowed types based on regular trees.
22:09:50 <palomer> meaning?
22:10:22 <Pseudonym> Regular trees are trees with loops.
22:10:47 <Pseudonym> So in this case it would be f(.) with the . pointing to the outer f(.)
22:11:57 <palomer> unification is based on type equalities
22:12:03 <palomer> so you'd have t = t -> t1
22:12:07 <Pseudonym> Right.
22:12:11 <palomer> what type could possibly satisfy this?
22:12:49 <Pseudonym> (((...) -> t1) -> t1) -> t1
22:12:54 <Pseudonym> That one.
22:13:04 <lispy> hmm...
22:13:05 <palomer> and ,erm, what could we represent with that type?
22:13:06 <lispy> that's is odd
22:13:17 <lispy> induction?
22:13:51 <Pseudonym> Well, you could represent some types which currently require newtype.
22:13:52 <lispy> er sorry, recursion
22:14:27 * palomer will have to ponder this
22:15:04 <palomer> I'm writing an interpreter, and I'd like to interpret (Y f), so I evaluate it and get... f (Y f) and then ... f (f (Y f))
22:15:10 <palomer> so on and so forth
22:15:21 <palomer> now the term does have a normal form
22:15:53 <palomer> bah, looks like I'm going to have to evaluate using head normal form
22:22:55 <palomer> how do I add on to the end of a list?
22:23:15 <Pseudonym> @eval [1..10] ++ [11]
22:23:16 <lambdabot> [1,2,3,4,5,6,7,8,9,10,11]
22:23:22 <Pseudonym> That's the usual approach.
22:23:39 <Pseudonym> If you find yourself needing to do this a lot, then you may be using the wrong data structure.
22:24:36 <palomer> yes! we have recursion
22:24:38 <palomer> woooooooooooooooooooot
22:25:02 * palomer wishes that ghc could decide which data structure I need
22:25:31 <Pseudonym> Submit a patch to djinn.
22:26:06 <palomer> for what?
22:26:18 <ibid> usually, when you need to add to the end of a list in recursion, it pays off to build the list in the wrong order, and then reverse it at the end
22:26:20 <palomer> @djinn forall a. (a->a) -> a
22:26:21 <lambdabot> -- f cannot be realized.
22:26:32 <Pseudonym> Right, so submit a patch.
22:27:06 <palomer> Pseudonym: you realize that if you can prove that theorem ,then you can prove anything, right?
22:27:27 <Pseudonym> Sounds useful.
22:27:40 <Pseudonym> There's a lot of crap I can't prove.
22:27:49 <palomer> har har har
22:27:55 <ibid> but then again, often i find that i can rewrite it so that i don't need to add to the end
22:28:20 <Pseudonym> If what you actually have is a queue, it makes more sense to use a real queue, for example.
22:28:23 <ibid> the most commmon case where i can't do that is when i'm building a string, in which case ShowS is a simple solution
22:28:28 <palomer> odd, someone was running "find" on my box
22:28:41 <palomer> grr, my box is hacked
22:29:15 <cmcq> are on GMT by any chance?
22:29:24 <Pseudonym> Grrr indeed.
22:29:32 <Pseudonym> Been there done that.
22:29:49 <palomer> everytime I log on to windows my box switches to GMT
22:29:57 <palomer> why do you ask?
22:30:02 <cmcq> check when cron.daily runs
22:30:29 <Pseudonym> The convenient thing about these script kiddie types is that they're usually stupid.
22:30:38 <palomer> why would find be part of my cron?
22:30:45 <Pseudonym> One installed a rootkit designed for RH7 onto my Debian box.
22:31:01 <cmcq> because you use debian I'd guess
22:31:04 <palomer> I do
22:31:06 <Pseudonym> My suspicions were first aroused when everything didn't work.
22:31:23 <palomer> debian runs find daily?
22:31:38 <cmcq> it does indeed
22:31:55 <palomer> to do what?
22:32:06 <cmcq> /etc/cron.daily/find
22:32:10 <Pseudonym> Must away.  Fare well.
22:32:16 <cmcq> updating updatedb supposedly
22:32:25 <cmcq> *locatedb
22:32:33 <palomer> updatedb uses find?
22:32:40 <ibid> yes
22:32:44 <ibid> does that surprise you?
22:32:48 <palomer> oh, that explains quite a bit
22:33:01 <palomer> then who was running ls?
22:34:47 <cmcq> grep ls /etc/cron.daily/*
22:36:36 <cmcq> apt autoclean perhaps
22:37:08 * ibid has been contemplating a new locate/updatedb that runs the update as a daemon, which then does low-intensity scanning all the time
22:37:22 <ibid> perhaps with the help of the kernel
22:37:38 <ibid> (the new syscalls that alllow one to follow changes to a directory)
22:37:59 <palomer> ehm?
22:38:42 <rep> inotify?
22:38:47 <rep> it's not portable.
22:38:57 <ibid> of course it isn't
22:39:14 <ibid> but it doesn't matter in this case
22:39:24 <ibid> dnotify too
22:39:41 <rep> dnotify has been removed in the newer 2.6 kernels
22:40:10 <wolverian> are fam/gamin portable?
22:40:16 <rep> wolverian yes
22:40:25 <rep> gamin is better
22:40:28 <wolverian> that's the bill, then.
22:41:00 <wolverian> yes. I use gamin in my minimal project editor :) it's nice to tie your project tree to the FS tree.
22:41:21 <ibid> rep: hmm
22:41:22 <palomer> yes! check out what I can compute:
22:41:29 <palomer> let fac n = if equals n 0 then 1 else times n (fac (minus n 1)) in fac 4
22:41:53 <palomer> soon I'll have proper operator precedence
22:41:57 <palomer> and type inference
22:41:58 <palomer> muhahaha!
22:42:03 <rep> ?
22:42:08 <rep> what are you doing, palomer 
22:42:16 <palomer> writing an interpreter
22:42:20 <rep> sweeet
22:42:39 <palomer> that's right, it'll be haskell without typeclasses
22:42:41 <palomer> or modules
22:42:50 <palomer> and strict
22:42:56 <palomer> actually, it's nothing like haskell
22:43:00 <rep> ML?
22:43:06 <palomer> yeah, botched-ml
22:43:11 <palomer> shower time!
22:44:11 <ibid> i've been contemplating a haskell-like language that allows arbitrary unions of labelled data types
22:44:30 <ibid> hmm, that's hard to explain simply
22:44:32 <skew> is that like a record calculus?
22:45:10 <skew> a row polymorphism system like Daan's work with the record calculus?
22:45:10 <ibid> haven't heard of a record calculus before, so i don't know, but it sounds potentially right
22:45:54 <skew> do you mean union in the sense of a varient?
22:46:26 <ibid> well, tagged union (ie. variant) except that the tags are part of the component types, not the union itself
22:48:49 <ibid> basically like this:
22:50:06 <ibid> type ::= ...  | union; union ::= record | union '|' record; record ::= conid type*
22:50:55 <skew> read Daan's paper on first class labels
22:51:00 <ibid> ref?
22:51:33 <skew> http://www.cs.uu.nl/~daan/download/papers/fclabels.pdf
22:52:01 <skew> your '|' looks like concatenation rather than a single-field extension, but there's a translation
22:52:23 <ibid> thanks. i'll have a look at that
22:53:36 <skew> basically, if { x :: T | r} extends record type r with a field x of type T, and you allow { x1 :: T1, x2 :: T2 ... xn :: Tn | r} as shorthand for iterated extensions,
22:54:33 <skew> replace everywhere in the source program records of type {x1 :: T1 , ... , xn :: Tn} by functions of type (r -> {x1::T1, ... ,xn::Tn | r})
22:58:22 <icb> is the yampa-users list archived anywhere?
22:58:37 <skew> "Typing Record Concatenation for Free", at http://pauillac.inria.fr/~remy/publications.html
22:59:44 <skew> you should look at Daan's other paper on records, http://www.cs.uu.nl/~daan/download/papers/scopedlabels.pdf
23:01:15 <skew> that system is fairly unique in that new labels shadow existing labels, rather than conflicting (with a type error)
23:02:01 <skew> for Daan's paper, the motivation is that this lets you type record operations without qualified types (the has,lacks, or row equality predicates of other systems)
23:03:03 <skew> I was contemplating unifying this with his first class labels, but decided that the shadowing was basically useless in it's own right
23:05:11 <skew> I wasn't thinking of varients, though, and it seems like a crucial property for your application
23:06:00 <skew> something similar, anyway, if you want to be able to re-use constructor names between types
23:09:27 <skew> hmm, does yi come with an uninstall command?
23:10:51 <lispy> skew: blasphemy!
23:11:00 <skew> well, I installed it as root
23:11:13 <lispy> skew: ...but i don't think it does...did you grep the makefile?
23:11:21 <skew> so it put a bunch of binaries owned (and usable only by) root in system directories...
23:11:34 <skew> I'd rather have it runnable by me
23:11:39 <lispy> oh hm...
23:11:46 <lispy> i've installed it as root before and not had that problem
23:11:52 <lispy> but this was quite a hile
23:12:14 <skew> It's just using a standard Cabal file
23:12:33 <skew> main = defaultMainWithHooks defaultUserHooks
23:14:44 <skew> well, it looks like it just installed one executable, and I can chmod that
23:14:46 * lispy has no concept of Cabal
23:16:04 <palomer> when's the next release of ghc planned?
23:16:09 <palomer> september is quite a while ago
23:16:18 <skew> it's coming along, I think
23:16:33 * palomer sometimes thinks that the purpose of ghc is to implement itself
23:17:18 <skew> ok, from the ghc wiki it looks like there will be a 6.4.2 before 6.6 comes out
23:17:30 <Speck> Hey -- I'm interested in learning about pure type systems like Henk or E from GHC and jhc respectively (that is, as an intermediate language for functional languages). Aside from the papers describing Henk (none exists for E), does anyone know of something a non-math-whiz like me could read?
23:17:42 <palomer> skew: what's going to be new in 6.6?
23:17:54 <palomer> E = Epigram?
23:17:55 <skew> the multithreaded runtime is the big point, I think
23:18:19 <Speck> E is jhc's Henk equivalent
23:18:39 <lispy> Speck: i would recommend investing the time to learn the math, but i don't have any more info than that :)
23:18:40 <palomer> what are pure type systems?
23:19:09 <Speck> lispy: I am definitely going to learn the math -- I want to, but the more math-oriented papers are somewhat over my head at this point.
23:19:31 <lispy> Speck: that's fair
23:19:35 <lispy> wish i colud help :)
23:19:43 <skew> improved (fancy modes working) heap profiling of STM programs seems to be the big bug outstanding listed for inclusion in 6.4.2
23:19:48 <lispy> well,i think i have a workaround patch for this darcs bug
23:19:50 <skew> Speck: do you have examples of papers with lots of math?
23:20:11 <skew> more for my interest, a bit to get an idea of what you mean by math.
23:20:15 <Speck> skew: the papers I'm referring to are about the calculus of constructions and the lambda cube
23:20:42 <lispy> Speck: check wikipedia, they have a bit on lambda cube that might be at the right level
23:21:09 <Speck> thanks. I was around those parts when I was starting out learning, maybe I'll be able to get more information the second time around :-)
23:21:11 <joelk> Hehe. My new and "improved" nbody is my slowest yet *and* fills up nearly 700MB on the heap.
23:21:14 <palomer> Berendregt is still alive?
23:21:37 <lispy> joelk: heh
23:21:56 <palomer> everyone knows that System F > E
23:22:28 <palomer> Under the Curry-Howard isomorphism, System F corresponds to a second-order logic. <--this is a blatant lie
23:22:33 <Speck> what about system omega?
23:22:42 <Speck> or Fomega
23:23:02 <palomer> I don't know about Fomega
23:23:07 <Speck> foux-mega
23:23:11 <Korollary> joelk: rock on.
23:23:12 <Speck> faux rather
23:23:18 <Speck> I dunno, something from the Henk paper
23:23:53 <Speck> it's all quite over my head, but this is how I learn -- bashing my head against the wall until it makes sense, making a fool of myself along the way
23:24:51 <Korollary> the wall does make sense sometimes...
23:25:43 <Speck> Korollary: yes, after much bashing
23:26:05 <skew> Speck: is it just the formalisms of type theory you are not used to, or are they actually bringing out heavy stuff like category theory
23:28:07 <Speck> skew: I'm not used to the type theory at this level.
23:28:38 <Speck> simpler type theory makes sense to me, but once I get to the dependently-typed lambda calculus things stop making sense
23:29:36 <skew> what about medium things like MLF, with no dependent types but some hairy inference rules?
23:30:14 <Speck> was MLF in a recent paper about records in haskell?
23:30:47 <Speck> I remember something like the acronym, but I didn't investigate it further
23:31:40 <Speck> http://www.cs.uu.nl/~daan/pubs.html#scopedlabels  this was the paper
23:34:55 <dons> joelk, cool. I've put up some faster possibilities on the Shootout page on the hawiki
23:35:03 <dons> not for nbody though..
23:35:32 <skew> no, that's a bit different. I meant http://www.cs.uu.nl/~daan/pubs.html#qmlf , which is more complicated
23:35:55 <skew> was the scoped labels paper understandable?
23:36:21 <Speck> yeah it made sense, but I probably didn't understand every nuance
23:37:21 <Speck> I'll read the MLF paper, and if the inference for impredicative rank-n polymorphism is too hard to grasp (which is what I assume you meant when you said hairy) I'll go down another step and work my way back up
23:37:26 <joelk> Bah. Why does it leave the intermediates in the heap, but my first version didn't?
23:46:46 <palomer> GAH
23:46:55 <palomer> types and programming languages can't even be ordered from chapters.ca
23:46:57 <palomer> the humanity!
23:47:17 * Speck got it from his school's library and never returned it cuz it was too good
23:47:37 <palomer> and amazon.ca has a 5-8 week waiting period!
23:47:48 <palomer> the semester will be practically over!
23:48:14 <Speck> does your school have it? or maybe an inter-college book loan system?
23:48:21 <Korollary> really? wow
23:48:59 <joelk> Woohoo! nbody2 no longer takes O(n) heap space and is only the slowest yet by a small margin. Can you tell I'm easily impressed?
23:49:06 <palomer> and it's a required textbook!
23:49:11 <Korollary> yes, amazon (us) has a 9-10 day waiting period as well
23:49:54 <palomer> oh my, it's much cheaper from amazon.com
23:50:01 <Speck> more people should use lulu :-(
23:50:09 <Korollary> you should just have a friend cross the border for you
23:50:18 <palomer> amazon.com doesn't ship to canada?
23:50:22 <Korollary> Speck: what's lulu?
23:50:54 <Speck> Korollary: lulu is a publishing house created by I believe someone at RedHat. It prints books/cds/etc. on demand when it's ordered and ships it to you.
23:51:10 <Speck> http://www.lulu.com/
23:51:31 <joelk> This is funny: amazon.co.jp ships TaPL within 24hrs...
23:52:38 <Korollary> It's a stocking issue.
23:52:49 <Korollary> The japanese should buy more ;)
23:52:58 <ADEpt> morning
23:52:58 <ADEpt> need advice in english - i'm doing typeclass that is akin to Arbitrary, but instances of it are not "arbitrary", they are either "valid" or "invalid". What will be the proper name for typeclass?
23:53:12 <palomer> wow lulu rocks
23:53:35 <Korollary> ADEpt: Quantum typeclass?
23:54:11 <Speck> palomer: yeah, my dad wrote a book and couldn't find a publisher -- he self published out of principle, but it was expensive and he was never satisfied. He eventually gave up writing. I showed him lulu and now he's working on another book :-)
23:54:36 <palomer> >:O
23:54:41 <palomer> crap I need this book
23:54:49 <skew> ADEpt: what are you using the typeclass for?
23:56:01 <ADEpt> skew: i'm using QuickCheck combinators to generate test data sets for existing software. Thus I need two generators for each datatype - one for valid test samples, one for invalid. I hope to capture that in a typeclass.
23:56:25 <Korollary> Speck: what was his book about?
23:56:34 <palomer> hrm, if I buy from amazon.com, how much tax would apply?
23:56:40 <ADEpt> Korollary: Quantum seems too convoluted :(
23:57:00 <Korollary> palomer: you're in canada, right? I don't think tax is your problem. More like customs.
23:57:09 <palomer> yeah
23:57:11 <palomer> customs
23:57:23 <palomer> how much are we talking about?
23:57:35 <Speck> Korollary: he's writes business humor. it was an allegory with plumbers
23:59:30 <Korollary> palomer: http://www.amazon.com/exec/obidos/tg/browse/-/468520/104-6087657-6931151
