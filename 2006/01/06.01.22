01:57:58 <bisby> how can i refer to the same expression several times in a list comprehension?
01:59:16 <bisby> [(a,map toLower a) | a <- files, a /= map toLower a] 
01:59:46 <bisby> i have to do map toLower twice here
01:59:49 <Cale> [(a,b) | a <- files, let b = map toLower a, a /= b] 
02:00:11 <dons>  hey: http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all  almost there!
02:00:12 <bisby> thx
02:00:14 <Cale> or
02:00:36 <Cale> do a <- files; let b = map toLower a; guard (a /= b); return b
02:00:41 <Cale> do a <- files; let b = map toLower a; guard (a /= b); return (a,b)
02:00:57 <Cale> dons: wow :)
02:01:14 <bisby> the first one seems more elegant
02:02:03 <Cale> bisby: I agree. Some people like to use do-notation in place of list comprehensions though
02:02:19 <Cale> I wish they'd bring back monad comprehensions
02:02:52 <audreyt> did GHC implement monad comprehenstions at any point?
02:02:59 <bisby> I want to rename files to lower case, but only the ones that have uppercase. hence the question.
02:03:48 <audreyt> [ (a, map toLower a) | a <- files, any isUpper a ]
02:04:25 <bisby> audreyt: yep that works as well
02:04:25 <Cale> audreyt: yeah, it did
02:04:34 <Cale> audreyt: they were in Haskell 1.4
02:04:37 <audreyt> Cale: bring back the patch then :)
02:04:49 * audreyt believes in code :)
02:04:53 <Cale> If you've never seen the Haskell 1.4 prelude, I highly recommend it
02:05:11 <Cale> It would be pretty trivial to bring them back, I'd think
02:06:23 <audreyt> do it then :D
02:09:53 <Cale> actually, I wonder if they would already work if I just fixed the prelude functions to have the right type.
02:13:06 <gour> hi
02:13:20 <gour> ot: anyone uses some volume manager on linux desktop?
02:14:43 <Cale> hmm, well, Haskell98 says that ""concatMap" used in the translation of list comprehensions (Section 3.11) means the concatMap defined by the Prelude, regardless of whether or not the identifier "concatMap" is in scope where the list comprehension is used, and (if it is in scope) what it is bound to."
02:14:56 <Cale> but I'll try it anyway
02:15:20 <Lemmih> gour: I use aumix.
02:15:49 <_|_kid> anyone used hsSDL? i'm trying to make a build but i get this error message "*** Exception: sh: runProcess: does not exist (No such file or directory)"
02:16:10 <_|_kid> on winxp by the way
02:16:43 <gour> Lemmih: i am thinking about lvm2 vs. evms2. have all the volumes on desktop machine under evms, but think whether it is worth fiddling with it on laptop (got a new one)
02:18:31 <_|_kid> is there a program called "runProcess" on windows?
02:20:00 <musasabi> @index runProcess 
02:20:01 <lambdabot> bzzt
02:20:32 <musasabi> @hoogle runProcess 
02:20:33 <lambdabot> System.Process.runProcess :: FilePath -> [String] -> Maybe FilePath ->
02:20:33 <lambdabot> Maybe [(String, String)] -> Maybe Handle -> Maybe Handle -> Maybe Handle -
02:20:33 <lambdabot> > IO ProcessHandle
02:20:51 <musasabi> it is a function in the library, not an executable.
02:20:59 <_|_kid> i see ^_^
02:22:23 <_|_kid> is that part of GHC or a darcs dependance?
02:22:53 <Cale> that's in the GHC library
02:23:45 <_|_kid> odd then, it can find it yet it finds ghc (i've setup envi paths)
02:25:15 <Cale> funny that the exception mentions sh
02:25:22 <Cale> but before runProcess
02:26:09 <Cale> I wonder what it is that runProcess is trying to run
02:27:36 <Lemmih> _|_kid: You probably need cygwin to install hsSDL.
02:28:00 <Lemmih> It's trying to run 'sh configure'.
02:28:15 * _|_kid *sigh* and new this would be the case
02:28:20 <_|_kid> *knew this
02:29:55 <_|_kid> there seems to be a visual haskell project in here though
02:29:59 <Lemmih> Windows is pretty funky when it comes to SDL.
02:30:43 <_|_kid> really? i've never had problems before with it
02:31:39 <_|_kid> and SDL on cygwin is slugesh
02:32:25 <Lemmih> There's no good way to find where SDL is installed and what the DLL is called so most people resorts to hard coded values.
02:33:00 <Lemmih> (at least that's what I've been told)
02:34:18 * _|_kid *sighs* again
02:51:32 <roconnor> @hoggle (a->b)->a->a->bool
02:51:34 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
02:51:34 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
02:51:34 <lambdabot> Data.Generics.Schemes.everywhere :: (a -> a) -> a -> a
02:51:47 <roconnor> @hoggle (a->b)->a->a->Bool
02:51:49 <lambdabot> No matches, try a more general search
02:52:02 <Cale> roconnor: what is it supposed to do?
02:52:10 <roconnor> @hoggle (Eq b)=> (a->b)->a->a->Bool
02:52:11 <lambdabot> No matches, try a more general search
02:52:33 <roconnor> @type (\f x y -> (f x)=(f y))
02:52:34 <lambdabot> parse error on input `='
02:52:37 <roconnor> @type (\f x y -> (f x)==(f y))
02:52:39 <lambdabot> forall a t. (Eq a) => (t -> a) -> t -> t -> Bool
02:52:41 <Cale> @pl \f x y -> f x == f y
02:52:42 <lambdabot> flip =<< (((.) . (==)) .)
02:52:49 <Cale> heh
02:53:01 <roconnor> that's way clearer
02:53:33 <roconnor> wow, it even uses bind.
02:53:45 <Cale> bind in the reader monad
02:53:49 <roconnor> yep
02:55:19 <roconnor> the poinless command seems to really illustrate the problems with point-free programming
02:57:18 <Cale> yeah, at least in Haskell
02:59:42 <Cale> If the intent was a point-free language, probably there'd be a larger number of convenient compositional primitives. 
03:01:35 <Cale> Of course, there are things which are obviously always going to be a problem
03:02:06 <Cale> @pl 3*x^5 + 2*x^4 + 7*x^3 - 2*x^2 + x - 1
03:02:08 <lambdabot> 3 * x ^ 5 + 2 * x ^ 4 + 7 * x ^ 3 - 2 * x ^ 2 + x - 1
03:02:11 <Cale> @pl \x -> 3*x^5 + 2*x^4 + 7*x^3 - 2*x^2 + x - 1
03:02:13 <lambdabot> subtract 1 . ((+) =<< ap ((-) . ap ((+) . ap ((+) . (3 *) . (^ 5)) ((2 *)
03:02:13 <lambdabot> . (^ 4))) ((7 *) . (^ 3))) ((2 *) . (^ 2)))
03:04:16 <roconnor> it should be in horner normal form first. ;)
03:05:15 <tromp> it's almost a compiler into S,K
03:05:59 <tromp> if you read S(KS)K for .
03:07:16 <tibbe> > data Term = Lam [a] (Expr -> a)
03:07:17 <lambdabot>  parse error on input `data'
03:12:26 <xerox> dcoutts: yow!
03:31:59 <dcoutts> xerox, yarr!
03:51:03 <roconnor> @hoggle IO ()
03:51:04 <lambdabot> Control.Concurrent.yield :: IO ()
03:51:04 <lambdabot> Foreign.C.Error.resetErrno :: IO ()
03:51:04 <lambdabot> GHC.Conc.yield :: IO ()
03:52:18 <xerox> dcoutts: very good work with haddock, my friend.
03:52:36 <dcoutts> xerox, thanks :-)
03:53:27 <xerox> dcoutts: maybe it could be part of haddock to html-ify the sources, in a compliant fashion to your new addings.
03:53:29 <dcoutts> and I fixed c2hs and hsc2hs :-)
03:53:55 <dcoutts> xerox, yeah, perhaps
03:54:15 <dcoutts> we could borrow the hscolour code to produce html
03:55:06 <xerox> ...and then show off to the doxygen folks ;-) hehe.
03:55:10 <ndm> dcoutts, have you seen the programatica syntax hilighter?
03:55:21 <dcoutts> ndm, I havn't
03:55:23 <ndm> it does links between identifiers as well, and might be better to go from that
03:55:32 <dcoutts> indeed
03:56:01 <ndm> http://www.cse.ogi.edu/~hallgren/Programatica/tools/pfe.cgi?HsDeclPretty
03:56:37 <dcoutts> ndm, I was meaning to ask you, it's another Yhc Q, does the size of various integer types change from one platform to another? eg 32/64 bit
03:56:55 <ndm> dcoutts, no idea...
03:57:08 <dcoutts> ndm, eg with ghc Int & Word follow the native machine word size
03:57:20 <ndm> possibly, or we might have  just gone with 32 bit for portability
03:57:27 <dcoutts> ndm, some FFI things in gtk2hs depend on that behaviour at the moment
03:57:35 <dcoutts> since we need to store some C pointers
03:57:48 <ndm> in that case i guess we follow the platform size
03:58:10 <ndm> i'll just check...
03:58:13 <dcoutts> so probably all theinteger types are 32 bit and the Ptr a is 32/64 bit as appropriate
04:00:46 <ndm> dcoutts, at first glance it appears on a 64 bit platform all integers are 64 bit
04:01:13 <dcoutts> ndm, ok, that's probably fine. It follows what ghc does.
04:02:26 <dcoutts> ndm, so the only problem we'll have is with field offsets in FFI marshaling code.
04:02:49 <dcoutts> gtk2hs uses very few raw C strucures, it's almost all caling C functions
04:02:55 <dcoutts> but there are one or two
04:03:58 <ndm> ok, and their field width changes depending on the platform?
04:04:48 <dcoutts> probably only for 32/64 bit
04:05:15 <dcoutts> but I am not 100% sure they can't changeon other platforms differences
04:05:17 <ndm> perhaps the runtime can patch that up
04:05:36 <ndm> i'm not really sure though, Tom would be the only one who knows
04:05:47 <roconnor> @type ""
04:05:48 <lambdabot> [Char]
04:05:59 <dcoutts> ndm, oh, actually it's different on win32 because on that platform gtk follows the msvc structure layout system rather than the normal gcc one.
04:06:15 <ndm> ah, that will be a problem...
04:06:22 <dcoutts> ndm, msvc uses differentpadding for bitfields than gcc
04:06:53 <dcoutts> ndm, but in practice I don't think we actually marshal any gtk structs that have bitfields
04:07:16 <ndm> ok, we might survive that then
04:07:25 <ndm> i'm not sure how we'll create struct's on the fly, could be trick
04:07:49 <dcoutts> ndm, perhaps we should have a way of checking all these things on each arch and then add a table to the code with the offsets for each arch.
04:08:11 <dcoutts> ndm, so we run a little prog on the target which generates the entry for that arch
04:08:18 <ndm> yes, in Gtk2Hs, or in Yhc?
04:08:26 <dcoutts> and then include that table into the bytecode file
04:08:34 <dcoutts> ndm, sort of both
04:09:00 <dcoutts> ndm, yhc would support reading that table, and we'd have to run a prog on each arch to generate the entries
04:09:58 <ndm> sounds deeply infectious
04:10:02 <dcoutts> ndm, perhaps we could write a special version of hsc2hs to do it
04:10:07 <roconnor> @type intersperse
04:10:08 <lambdabot> Not in scope: `intersperse'
04:10:15 <roconnor> @type List.intersperse
04:10:17 <lambdabot> forall a. a -> [a] -> [a]
04:10:40 <dcoutts> ndm, or ask Tom for ideas. :-)
04:11:12 <ndm> dcoutts, i will do - we obviously want 100% cross platform, and to work with Gtk2Hs
04:11:15 <dcoutts> ndm, in practice gtk2hs will probably be ok for all 32bit arches
04:11:35 <dcoutts> without any special support I mean
04:11:52 <ndm> dcoutts, since we have a maintained 64 bit support, it would be a shame not to have Gtk2Hs on it
04:11:59 <dcoutts> ndm, indeed
04:12:48 <ndm> and i think the only person who is using Yhc as his main haskell compiler actually runs linux 64 bit :)
04:12:55 <dcoutts> ndm, and we can check fairly accurately, we build gtk2hs on each arch and check if the .hs files are different on any of them. (which they mgiht be if hsc2hs or c2hs generate different code)
04:13:10 <dcoutts> ndm, heh :-)
04:32:56 <astrolabe> "Could not find module `Parsec': locations searched: Parsec.hs Parsec.lhs"
04:33:08 <astrolabe> Any ideas why?
04:35:40 <Lemmih> Tried Text.ParserCombinators.Parsec?
04:35:55 <astrolabe> nope.  thanks
04:38:39 <astrolabe> That worked :)  Now onto the next error :(
05:02:24 <jyp> @quote
05:02:25 <lambdabot> jlouis says: Q: When does one know he has programmed too much Haskell? A:
05:02:25 <lambdabot> When he uses == and /= in everyday IRC chat or when he tries to fix a
05:02:25 <lambdabot> relationship by passing himself as a continuation
05:07:25 <xerox> @quote
05:07:26 <lambdabot> cjs says: I have to explain this shit to people. I mean, I start out
05:07:26 <lambdabot> right, "Hey, you know how you always have these bugs because what you
05:07:26 <lambdabot> thought was in the variable is not there?" And I get all of these nods of
05:07:26 <lambdabot> agreement. "Well, I've found a new language that solves that problem."
05:07:26 <lambdabot> Audience: "Ooooh! How?" Me: "There's no variables!" And then they all
05:07:28 <lambdabot> start moving away from me slowly....
05:12:05 <jyp> Good one :)
05:13:03 <jyp> -- So how can you compute stuff without variables ?
05:14:10 <jyp> Me: just directly define the good result.
05:14:34 <dcoutts> gour, hey, you about?
05:15:20 <dcoutts> xerox, you too?
05:15:42 * dcoutts is looking for people to help him start a Gtk2Hs tutorial on the new haskell wiki
05:16:07 <astrolabe> That would be good
05:16:32 <xerox> Yup.
05:16:35 <xerox> astrolabe: I got it :-)
05:16:41 <jyp> There are articles from TMR that can be re-used, iirc.
05:17:10 <astrolabe> xerox:  Good!
05:18:24 <jyp> btw, lambdabot needs a @acronym command or something.
05:20:09 <xerox> @wtf btw
05:20:12 <lambdabot> No match for "btw".
05:20:25 <xerox> @wtf wtf
05:20:27 <lambdabot> No match for "wtf".
05:20:34 <xerox> @wtf bbiab
05:20:34 <jyp> neat :)
05:20:36 <lambdabot> No match for "bbiab".
05:20:38 <xerox> @help wtf
05:20:40 <lambdabot>  @help <command> - ask for help for <command>
05:20:44 <xerox> ...
05:20:51 <jyp> yeeck
05:21:20 <jyp> @wtf
05:21:43 * jyp slaps lambdabot
05:21:52 <jyp> wake up!
05:24:31 <jyp> @quote
05:24:33 <lambdabot> Alanna says: Saying that Java is nice because it works on all OS's is
05:24:33 <lambdabot> like saying that anal sex is nice because it works on all genders.
05:24:36 <araujo> Good morning.
05:24:44 <jyp> yuck
05:24:53 <jyp> morning araujo.
05:25:10 <araujo> Hello jyp :-)
05:26:10 <xerox> @quote
05:26:11 <lambdabot> samc says: monads are hard, let's go shopping
05:27:03 <xerox> Do you know of some realtime collaborative *blackboard* ?
05:28:29 <jyp> @google collaborative whiteboard
05:28:29 <flux__> so.. whiteboards aren't sufficient for your needs?
05:28:31 <lambdabot> http://www.imaginationcubed.com/
05:28:41 <xerox> flux__: whiteboards are ok.
05:29:01 <flux__> well, google knows plenty, and I think even freshmeat has a post on those every now and then
05:29:28 <xerox> cool.
05:31:02 <xerox> That one is cool, anyone has time to try it?
05:32:24 <dcoutts> xerox, oh there you are :-) want to help?
05:33:03 <xerox> dcoutts: yeah.
05:33:18 <dcoutts> xerox, cool
05:33:21 <xerox> Hmm.
05:33:35 <dcoutts> xerox, so I was thinking we should start by making a skeliton of the structure 
05:33:48 <dcoutts> borrowing from the Gtk+ and pygtk tutorials
05:33:56 <dcoutts> their structure at least
05:34:06 <dcoutts> the rubygtk tutorial is good too
05:34:20 * dcoutts copies stuff over to http://haskell.org/haskellwiki/Gtk2Hs
05:34:57 <pesco> @quote
05:34:58 <lambdabot> kolmodin says: i.e. I would rather lose my left arm than write it in
05:34:58 <lambdabot> Java
05:36:13 <xerox> The 'ink left' doesn't sound right.
05:41:07 <xerox> The new wiki looks very nicely :-)
05:47:36 <sylvan> hmm... why are there two benchmarks "missing" (error and timeout) for GHC on the debian version, but none on the gentoo version?
05:48:32 <musasabi> sylvan: because the debian version is run less frequently.
05:48:51 <musasabi> sylvan: thus updates are propagated slower to it.
05:49:02 <sylvan> ah
06:17:02 <dcoutts> xerox, ok: http://haskell.org/haskellwiki/Gtk2Hs/Tutorials/Intro
06:17:16 <dcoutts> here's a skeliton
06:17:34 <dcoutts> What I really want to get is a sane order of introducing concepts to people
06:18:02 <dcoutts> let me add a little bit about what I want to introduce in each section
06:30:34 <pejo> change du
06:30:55 <pejo> Wrong window.
06:35:37 <dcoutts> gour, you had some ideas about how to organise a Gtk2Hs tutorial didn't you?
06:35:42 <dcoutts> http://haskell.org/haskellwiki/Gtk2Hs/Tutorials
06:35:46 <dcoutts> http://haskell.org/haskellwiki/Gtk2Hs/Tutorials/Intro
06:39:35 <jonkri> dcoutts: that's cool
06:39:53 <dcoutts> jonkri, feel free to add your suggestions
06:40:19 <dcoutts> I'm trying to get the order of introduction of concepts right
06:40:49 <jonkri> dcoutts: i have no idea how it would work, even though i've been using glade. can you call haskell functions instead of c functions or what?
06:41:12 <jonkri> dcoutts: i will comment if i come up with something
06:41:25 <dcoutts> jonkri, oh you mean in glade?
06:41:36 <dcoutts> like adding a haskell name as a signal handler
06:41:54 <dcoutts> the name of a haskell function as a signal hander in a glade file
06:42:05 <dcoutts> well the answer is that one cannot do that :-(
06:42:06 <dcoutts> however...
06:42:42 <dcoutts> you can get ahold of the named widget in the glade file and then attach the signal handler youself in code
06:42:46 <dcoutts> which isn't very hard.
06:42:55 <dcoutts> 2 lines of code
06:43:20 <jonkri> oh, i see
06:43:25 <jonkri> nice
06:43:41 <dcoutts> I could think about adding a function to connect a signal handler without having to get a reference to the object. Then it'd be one line of code to connect a signal handler.
06:44:10 <dcoutts> but I've not found it annoying so far
06:52:13 <sylvan> I've spent some type working on the "WhyHaskell" section of the new wiki. There's plenty of stuff that "sounds wrong" but I just can't come up with anything better. So if someone wants to take a stab at it, that would be great: http://www.haskell.org/haskellwiki/WhyHaskell
06:52:55 <sylvan> It should probably be shortened, for instance
06:59:06 <xerox> dcoutts: indeed.  Also, I've been loving using glade.
06:59:40 <dcoutts> xerox, yeah it does make it much easier to build nice looking GUIs
06:59:46 <jvw> I'm trying to compile a ghc application (UUAG) with latest Debian Sid, but it fails with "Could not find module `System.IO':" -- I have no idea yet where to look, anyone have a hint what would be most likely, problem in my ghc insatllation/version, or in UUAG?
07:00:01 <Saulzar> Me too, have barely needed to look at any gtk stuff.
07:00:26 <Lemmih> jvw: Can you access System.IO from GHCi?
07:02:01 <jvw> hm, didn't work with ghci yet, how do I check that? import doesn't exist there
07:02:14 <jvw> ah, nvm, :load does
07:03:00 <jvw> err, :module I mean
07:03:02 * Lemmih wonders why jhc generates 47000 lines of C for 'print (sum [1..10]::Int)'.
07:03:12 <jvw> (afk, sorry)
07:03:29 <Heffalump> how much does it generate for print (1::Int) ?
07:04:02 <tromp_> how much for main = return ()   ?
07:04:56 <xerox> main = undefined ?  :)
07:05:15 <tromp_> xerox wins:)
07:05:39 <tromp_> well, main = main is a bit shorter:)
07:06:51 <pesco> Lemmih: Good reading. ;)
07:08:48 <Lemmih> main = print (1::Int) === 46255 lines of C.
07:09:04 <pesco> Nice boilerplate.
07:09:22 <pesco> How big is the compiled binary?
07:09:24 <Lemmih> main = return () === 155 lines of C.
07:09:35 <flux__> lemmih, so, if you change that 1 to 2, it's 92510 lines?
07:09:39 <pejo> Lemmih, clearly it's a sign of a plea for help. 
07:09:44 <pesco> flux__: Haha.
07:09:56 * xerox stabs flux__ 
07:09:58 <Saulzar> or [1..] it never finishes? :)
07:10:35 <Heffalump> I'm sure the Hello World program I wrote was quite short.
07:10:38 <Saulzar> Hmm, very succesful leak finding. Program does absolutely nothing except leak 4x faster after searching for 2 days.
07:11:07 <dcoutts> @index on
07:11:08 <Lemmih> Heffalump: Yeah, I think it's the 'show' that makes it blow up.
07:11:08 <lambdabot> bzzt
07:11:10 <dcoutts> @index after
07:11:11 <lambdabot> bzzt
07:11:30 <Heffalump> interesting
07:11:36 <xerox> dcoutts: succ?
07:11:52 <dcoutts> xerox, no I want to make sure I'm not picking names that clash with exiting stuff
07:12:17 <dcoutts> button `on` pressed $ do ...
07:12:22 <dcoutts> button `after` pressed $ do ...
07:12:35 <dcoutts> or maybe it should be:
07:12:43 <dcoutts> on button pressed $ do ...
07:12:50 <dcoutts> yes that reads well :-)
07:13:01 <dcoutts> after button pressed $ do ...
07:13:39 <musasabi> Lemmih: that seems very pathological, I think John will like to see it.
07:13:49 <musasabi> (I can reproduce it here)
07:15:57 <musasabi> It seems that the show does not get specialized for some reason.
07:16:24 <xerox> dcoutts: very very very very nice.
07:16:38 <dcoutts> xerox, :-)
07:16:40 <xerox> dcoutts: it would be cool to update the update the demos with them.
07:16:52 <dcoutts> xerox, I've got to make it work first :-)
07:17:01 <xerox> hehe yeah.
07:17:24 <Saulzar> Hmm, what is different? Seperating the event type "pressed" from "on"?
07:18:21 <Heffalump> I was going to ask if you can use SPECIALIZE directives to shrink it.
07:19:00 <wilx> Bah, how do I revert whole page with moinmoin?
07:19:03 <musasabi> Heffalump: it should happen automatically, I think it is due to the new typechecker import having destabilized something.
07:20:17 <musasabi> basically it is dead code elimination.
07:22:42 <lennart> howdy
07:22:57 <Lemmih> Hiya lennart.
07:25:51 <edwinb> morning
07:26:40 <psnl> evening
07:26:42 <musasabi> How is Djinn faring?
07:27:08 <Heffalump> wilx: I think it's quite easy if you ask it to show you all revisions or something like that.
07:27:19 * musasabi wants haskell-mode djinn integration
07:27:21 <dcoutts> Saulzar, yeah that's the differentce, at the moment we've got function like onClicked button $ do ...
07:27:46 <lennart> musasabi: i've not had time to work any more on djinn
07:27:56 <dcoutts> Saulzar, one reason for separating it out is to reduce the number of functions, instead of onClicked and afterClicked, we just have clicked
07:28:35 <dcoutts> Saulzar, which means the docs are shorter/simpler. It means we can store more meta info about signals.
07:28:55 <dcoutts> so we can do things with them other than just connecting callbacks to them
07:29:04 <dcoutts> it makes signals first class values
07:29:31 <dcoutts> as well as making the syntax slightly nicer.
07:35:57 * edwinb finally gets around to learning Parsec and decides it is lovely.
07:39:21 <shapr> lispy: You like The Pragmatic Programmer then?
07:42:08 <shapr> pesco: Can you ues ekiga with asterisk?
07:42:37 <pesco> shapr: Yes, as in Asterisk supports SIP (and H.323 IIRC).
07:43:17 <Lemmih> dcoutts: Did I miss something? http://haskell.org/haskellwiki/HIDE/Design#Project_management
07:43:35 * dcoutts takes a look
07:43:43 <pesco> shapr: I'm just having a problem with authenticating it to partysip. Not sure which one of the two is to blame. Probably both, partysip for not supporting WWW-Authenticate correctly and Ekiga for not supporting Proxy-Authenticate. ;)
07:43:54 <jvw> Lemmih: thanks, I'm going to assume now the software in question of the buildsystem is broken, because System.IO seems to be installed fine
07:43:56 <dcoutts> Lemmih, sounds right
07:44:11 <pesco> shapr: But it's the beta, so hey.
07:45:30 <dcoutts> Lemmih, I added just one clarification.
07:46:04 <Lemmih> jvw: The GHC build system has changed a lot lately. It's likely that the buildsystem needs some tweaks if the software is more than a couple of months old.
07:47:01 <jvw> Lemmih: ah, that's most likely it then, because the author obviously was able to build it, and it's also installed at a university server running centos
07:49:58 <dcoutts> Lemmih, do you know who suggested "Hades: HAskell DEvelopment System (or Studio)" as a new name for hIDE? It's a very cool/silly name. :-)
07:50:06 <jvw> unfortunately, the software also uses some features of the newest ghc...
07:50:49 <jvw> Lemmih: any pointer to those changes and/or a guide what to change?
07:51:16 <Lemmih> jvw: Is it using a Makefile based system?
07:51:23 <jvw> yeah
07:51:53 <jvw> with autoconf, but otherwise mostly hand-written
07:53:23 <jvw> last change to buildsystem was 2005/03/16 14:55:57 // updated to work with ghc 6.4
07:53:31 <Saulzar> dcoutts, Ahh, cool. I thought it looked very similar.
07:53:58 <Lemmih> dcoutts: I would like a general GUI interface to avoid adding new GUI hooks all the time.
07:54:24 <dcoutts> Lemmih, that's rather tricky. What do you suggest?
07:54:56 <dcoutts> Lemmih, I'm more than happy to try an partition most hIDE APIs into gui and non gui bits, but making it totally independent is hard.
07:55:05 <Lemmih> I don't know. Not even sure if it's possible.
07:55:11 <dcoutts> eg alowing more than one gui toolkit is very hard
07:55:33 <dcoutts> I think most APIs need not depend on the GUI
07:55:59 <dcoutts> and then we write GUI bits that stich the features into the GUI
07:56:06 <araujo> Does this statement make sense "small media at haskell" ?
07:56:17 <dcoutts> Lemmih, but keeping the GUI layer as small as possible is certainly a good idea.
07:56:17 <Heffalump> no
07:56:26 <araujo> dcoutts, Lemmih hiy!
07:56:30 <dcoutts> Lemmih, I don't like common sense depending on Gtk+ either.
07:56:36 <araujo> Heffalump, 'on' ?
07:56:49 <Heffalump> what's the context?
07:56:57 <dcoutts> araujo, what are you trying to say?
07:57:07 <dcoutts> haskell on small devices?
07:57:13 <dcoutts> eg PDAs etc
07:57:22 <araujo> dcoutts, haskell for playing media
07:57:26 <araujo> :-]
07:57:39 <Lemmih> dcoutts: So every time someone hacks a plugins like CommonSense or the ProjectManagement we add the appropriate hooks to the GUI?
07:58:13 <dcoutts> Lemmih, we don't add hooks to the GUI, we using the existing hooks to add an extra bit to the GUI.
07:58:35 <Heffalump> araujo: I still don't quite follow. What is "small media"?
07:58:56 <araujo> Heffalump, media, as in videos, music, etc etc
07:59:02 <dcoutts> Lemmih, the GUI is supposed to be flexable and not need to be coded monolithically for each feature.
07:59:17 * shapr bops cheerfully
07:59:26 <Lemmih> dcoutts: But the existing hooks can't facilitate something like the ProjectManagement.
07:59:38 <dcoutts> Lemmih, why not?
07:59:46 <dcoutts> Lemmih, what GUI does it need?
08:00:00 <dcoutts> eg editing .cabal files?
08:00:09 <dcoutts> via a custom gui
08:00:13 <Lemmih> We need a "New Cabal Project" form and stuff like that.
08:00:24 <dcoutts> so that's adding new menu items etc
08:00:35 <dcoutts> that is not yet implemented but is part of the plan
08:00:46 <Heffalump> araujo: ok, but what's small about it?
08:01:00 <araujo> shameplayer !
08:01:06 * araujo likes the name
08:01:14 <Lemmih> dcoutts: We also need a nice way to add a library and executables to the .cabal file.
08:01:33 <dcoutts> Lemmih, via a custom editor for files of type .cabal
08:01:49 <dcoutts> that's possible by defining a custom editor page thingy
08:02:21 <dcoutts> Lemmih, the way that'd work is that the GUI layer of the project management feature adds a menu item or toolbar button which then brings up its form or whatever.
08:02:38 <Lemmih> dcoutts: Ah. So the project management doesn't modify the .cabal files at all. We just write a custom editor for all the GUIs?
08:03:20 <dcoutts> Lemmih, so the GUI layer of the project management depends on the core project management API (which does not depend on any gui)
08:03:43 <dcoutts> Lemmih, so we provide a custom editor which uses the project management api to make its changes
08:04:05 <dcoutts> Lemmih, that way other clients of the projet menagement component can get notified of changes in the project settings.
08:04:17 <araujo> Heffalump, just trying to name some code i wrote for playing media from console
08:04:27 * Lemmih goes to write this down.
08:04:33 <dcoutts> Lemmih, so it's reasonably well layered I think.
08:04:54 <dcoutts> Lemmih, perhaps I should draw a dependency diagram to make it clearer
08:05:29 <Heffalump> ah, so the code is small, not the media?
08:06:04 <dcoutts> Lemmih, where are you writing this? on the wiki? I can add my notes too.
08:06:30 <Lemmih> dcoutts: Yeah. HIDE/Design at the new wiki.
08:06:31 <araujo> Heffalump, hah yeah :-]
08:07:54 <Lemmih> dcoutts: So the first thing on my TODO list should be to extend the GUI interface?
08:08:09 <dcoutts> Lemmih, no I don't think so
08:08:20 <dcoutts> Lemmih, it'd be to design the main api
08:08:31 <Lemmih> Main api?
08:08:36 <dcoutts> Lemmih, bearing in mind the clients of that api, which includes the gui
08:08:44 <dcoutts> the main project management api
08:09:04 <dcoutts> what do other components want to know from the project management component?
08:09:11 <dcoutts> what actions do they want to perform?
08:09:29 <dcoutts> eg the interactive type checking needs to know what options to supply to ghc etc
08:09:43 <Heffalump> araujo: I suggest putting 'small' with 'Haskell' not with 'media', then.
08:09:49 <Heffalump> e.g. Small Haskell Media Player
08:09:49 <dcoutts> like flags, include paths, dependent packages etc
08:10:14 <dcoutts> Lemmih, then the gui wants to get and modify settings in the .cabal files
08:10:19 <Lemmih> Shouldn't the project management plugin just add some menu items for starting a new project and running 'configure|build|...'?
08:10:39 <araujo> Heffalump, hah, yeah, that's what shameplayer means :-]
08:10:41 <dcoutts> Lemmih, that's the gui part of the plugin, which actually is the least important.
08:10:43 <Heffalump> ok :-)
08:10:51 <wilx> Yup, I found out.
08:11:07 * araujo really likes the name
08:11:17 <Lemmih> dcoutts: All other plugins just need the .cabal file info.
08:11:23 <tromp_> there's a free go lecture on KGS...
08:11:34 <dcoutts> Lemmih, at the end the gui part of the project managemtn should be as simple as adding a couple menu items which then use the project management component to actually do the build/configure etc
08:11:39 <Lemmih> dcoutts: The project manager can't really give them any more information.
08:11:57 <dcoutts> Lemmih, any more than?
08:12:13 <dcoutts> Lemmih, it can figure out which files belong to which .cabal files
08:12:22 <Lemmih> dcoutts: Any more than the .cabal file.
08:12:32 <dcoutts> given the root of the source tree
08:12:46 <dcoutts> Lemmih, right, it gives access to the info in the .cabal file
08:12:56 <dcoutts> Lemmih, probably including notification of when it changes.
08:13:44 <Lemmih> Right, does it offer more than that?
08:13:57 <dcoutts> Lemmih, and actions like configure, build etc
08:14:48 <dcoutts> we'll have to think about if that's for individual .cabal packages or for whole collections of cabal packages in a source tree that depend on each other
08:15:00 <dcoutts> basically we need to figure out all the requirements
08:15:07 <Lemmih> I don't wanna handle more than one .cabal for now.
08:15:09 <dcoutts> which are not that trivial
08:15:17 <dcoutts> Lemmih, ok that's an ok place to start.
08:15:54 <dcoutts> Lemmih, so we should have a function to set what we believe the root of the build tree is.
08:15:59 <Lemmih> I wanna wait till shipments in Cabal are properly defined.
08:16:04 <dcoutts> Lemmih, sure
08:16:20 <dcoutts> and then we'll expect that root dir to contain one .cabal file.
08:16:33 <dcoutts> which is what the current cabal system expects
08:16:47 <dcoutts> we can wait for shipments or whatever they turn out to be
08:16:58 <Lemmih> Isn't the .cabal file always at the root?
08:17:12 <dcoutts> yes it should be
08:17:17 <dcoutts> under the current system
08:17:33 <dcoutts> eventually it might get extended to allow more, but not at the moment
08:18:36 <dcoutts> Lemmih, so for example if I start up hIDE we'd set ProjectManagement.setBuildTreeRoot currentWorkingDirectory
08:18:57 <dcoutts> which will do the right thing if we're in the root of a cabal package build tree
08:19:14 <Lemmih> "< dcoutts> Lemmih, and actions like configure, build etc" You want the plugin to suppy hooks just like Cabal's UserHooks?
08:20:02 <dcoutts> Lemmih, I'm not quite sure what you mean
08:20:03 <Lemmih> *supply
08:20:23 <jvw> Could not find module `System.IO': locations searched: System/IO.hs System/IO.lhs /usr/lib/ghc-6.4.1/imports/System/IO.p_hi -- but it's located in System/IO.hi ?
08:20:38 <dcoutts> Lemmih, I'd guess the project management would have a function that gives us a CabalPackage object
08:20:50 <dcoutts> Lemmih, and that would have a function to invoke the configure or build etc
08:20:56 <Lemmih> jvw: Ah. It's because you don't have the profiling version of the standard libraries.
08:21:14 <dcoutts> (so that leaves open the possability to have more than one CabalPackage later)
08:21:46 <dcoutts> Lemmih, does that make any sense?
08:21:52 <Lemmih> dcoutts: Yeah, it does.
08:22:08 <dcoutts> what do other IDEs call packages?
08:22:20 <dcoutts> components, projects, "solutions"
08:22:39 <dcoutts> maybe CabalPackage will do
08:22:44 <JKnecht> all of which are different in th MS universe.
08:22:46 <jvw> Lemmih: ah, hm. Unclear error message, then... indeed dropping -prof seems to fix this, I don't give anything about the profiling anyway
08:23:47 <dcoutts> Lemmih, so the CabalPackage will enable us to get at the info in the .cabal file.
08:23:49 <jvw> hm, and Debian has a 'ghc6-prof' package
08:24:08 <dcoutts> Lemmih, we can reuse the data strucures that the Cabal library provides.
08:24:55 <dcoutts> Lemmih, so then the type checking plugin will extract the info from that so that it has the right packages imported etc.
08:26:50 <dcoutts> Lemmih, I think we do want to have a function which maps a file back to a CabalPackage
08:26:55 <dcoutts> Lemmih, the reason for that is:
08:27:15 <dcoutts> there may be no .cabal package to which the file belongs
08:27:35 <dcoutts> in which case to compile it we use default setting, correspondign basically to doing ghc --make
08:28:13 <dcoutts> when we have build trees that have more than one .cabal file, we need to know which setting to use when building it, hence mapping the file to the CabalPackage
08:28:23 <dcoutts> the mapping is constructed when we set the build root
08:28:30 <Lemmih> ./dcoutts >> wiki
08:28:36 <dcoutts> :-)
08:29:02 <dcoutts> by looking at the source files in the build tree and the .cabal file(s) to see which files belong to the .cabal package(s)
08:29:17 * dcoutts will now copy'n'paste the above into the wiki :-)
08:30:07 <Lemmih> The project manager should also be affecting the file browser.
08:31:59 <Lemmih> And we need to use the GHC api to verify that Exposed-modules + Other-modules actually cover all the needed modules.
08:39:37 <dcoutts> http://haskell.org/haskellwiki/HIDE/Design/Project_management
08:56:25 * Lemmih isn't sure whether to fork hs-plugins or to use the GHC api instead.
08:56:42 <SimonRC> hi
08:56:58 <dcoutts> Lemmih, I've added some more notes to http://haskell.org/haskellwiki/HIDE/Design/Project_management
08:57:07 <dcoutts> Lemmih, tell me if I'm talking ****
08:59:23 <jvw> Lemmih: thanks, the whole thing compiles now, and I can work with it
08:59:53 <jvw> so I can finally resume my work on this haskell compiler...
09:01:13 <Lemmih> dcoutts: I think it's pretty sound what you're saying.
09:01:32 <Lemmih> jvw: You're hacking a Haskell compiler?
09:01:35 <dcoutts> Lemmih, ok good. :-)
09:02:00 <jvw> Lemmih: I'm working on a feature in helium
09:02:29 <dcoutts> Lemmih, I've missed out the api for updating a .cabal file, but I guess it's just the opposite of the function for getting the info.
09:02:38 <dcoutts> Lemmih, oh, and the change notification.
09:02:42 <jvw> www.cs.uu.nl/helium -- ote: Helium does not support type classes yet. For that reason it is incompatible with Haskell text books. <<-- I'm working on making that note obsolete
09:03:30 <Lemmih> I wonder if we could hack a wiki recording plugin for lambdabot.
09:05:44 <dcoutts> Lemmih, heh, that could be useful.
09:07:59 <vincenz> what is helium
09:08:43 <Cale> It's a cut-down variant of Haskell with nice error messages for newbies.
09:08:55 <kosmikus> jvw: you're at uu?
09:09:21 <jvw> kosmikus: yes
09:09:42 <kosmikus> jvw: ok, great. good to see that helium is still alive. is this your master's project, or something else?
09:10:40 <jvw> kosmikus: no, just a programming project for my studies, but not my master's project
09:11:59 <Heffalump> how much work is adding type classes?
09:12:12 <jvw> Heffalump: 'quite a bit'
09:12:35 <jvw> my main problem is that I previously was not familiar with helium at all
09:12:45 <jvw> in progress, I"m also documenting the internals a bit
09:13:29 <jvw> there's a lot of places to change and adapt
09:13:59 <jvw> and each of them take a conderate amount of time to see how that part works, but once you understand, it's not that much work anymore
09:18:58 <wheekwkw> Is it possible to compile and execute haskell code on the fly in a restricted environment?  I have a game idea that's reminiscent of Grid Wars, with programs battling it out, but higher level programs.  I was going to use Lua, but it would be so leet if I could use Haskell.
09:19:16 <Cale> > map (*2) [1..10]
09:19:18 <lambdabot> [2,4,6,8,10,12,14,16,18,20]
09:19:21 <Cale> yes
09:19:28 <Cale> > print "Hello"
09:19:30 <lambdabot> No IO allowed
09:19:52 <Cale> > let loop = loop in loop
09:19:53 <lambdabot> Add a type signature
09:19:56 <Cale> > let loop = loop in loop :: Integer
09:19:58 <lambdabot> Exception: <<loop>>
09:20:07 <Cale> > let loop f = loop (f + 1) in loop 0 :: Integer
09:20:16 <lambdabot> Terminated
09:21:17 <Cale> @help eval
09:21:18 <lambdabot>  @eval <expr>
09:21:18 <lambdabot> You have Haskell, 3 seconds and no IO. Go nuts!
09:22:33 <wheekwkw> How do I implement my own eval, and set my own resource restrictions?
09:22:46 <Cale> have a look at hs-plugins
09:22:54 <Cale> @where hs-plugins
09:22:54 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
09:23:47 <Lemmih> wheekwkw: eval just write the expression in a file, compiles it with GHC and then runs the program limited with ulimit.
09:23:52 <Lemmih> *writes
09:24:39 <Cale> well, it may, but it's not written like that
09:24:43 <ndm_> wheekwkw: someone is doing that with Yhc
09:25:09 <ndm_> since that allows you to limit at the bytecode level to safe operations, and you can control the IO quite precisely
09:25:11 <wheekwkw> For the game I'm thinking about, the resource restrictions would have to be completely deterministic.  A given user program would have to have exactly the same output or failure each time, so I couldn't use, say, just processor clock as a resource.
09:25:12 <Cale> It uses runPlugs, which uses System.Posix.Resource, and hs-plugins
09:25:58 <ndm_> wheekwkw: that should be possible with Yhc, since you can limit the number of Haskell instructions, and provided you ban IO, those will take roughly the same time
09:26:04 <ndm_> but be entirely deterministic
09:26:48 <Cale> heh, a functional version of Core Wars, with lambda terms battling it out in a referentially transparent arena!
09:27:55 <ndm_> indeed, Yhc has a Core language now, just like GHC does...
09:27:59 <wheekwkw> I was thinking of just a framework where you can define a bunch of two person games, and a player for a game, and the players are automatically played against each other and rated.
09:29:06 <Cale> Wouldn't it be easy enough to define that as simply a higher-order function which takes the n players input as a list of pure functions?
09:29:20 <Cale> pure functions for making decisions
09:29:52 <Cale> I suppose you also need to limit the amount of time spent on computation for those
09:30:12 <wheekwkw> Yeah, that's the main problem, limiting the computation, and doing it in a deterministic manner.
09:30:24 <wheekwkw> (and also creating the web interface for the game)
09:30:52 <wheekwkw> (and I guess a database to store all of the games and the players)
09:31:10 <wheekwkw> I'll look into Yhc, I guess.
09:32:05 <ndm_> Yhc doesn't currently support resource limiting, but it would be much easier to do that GHC
09:32:27 <ndm_> and there is already someone looking into it
09:41:15 <nibro> anyone know where I can find info on the latest version of cabal?
09:41:30 <nibro> i.e. how I can get my .cabal files right...
09:42:18 <Lemmih> Hi nibro. Ltns.
09:42:25 <nibro> hi Lemmih :)
09:42:37 <nibro> indeed, I've had my hands more than full :(
09:42:47 <Lemmih> http://www.haskell.org/ghc/docs/latest/html/Cabal/index.html
09:43:35 <nibro> seen that one already, but I keep getting parse errors
09:43:54 <Lemmih> What version of Cabal are you using?
09:43:55 <nibro> that one seems to be for 1.0, no?
09:44:11 <nibro> 1.1.3
09:44:38 <Lemmih> What does it choke on?
09:45:00 <nibro> I'm trying to install haskelldb, and it chokes on the 'extensions' field
09:45:17 <nibro> Extensions: ExistentialQuantification,
09:45:17 <nibro>             OverlappingInstances,
09:45:17 <nibro>             UndecidableInstances,
09:45:17 <nibro>             MultiParamTypeClasses
09:46:08 <Lemmih> I think they changed it to AllowOverlappingInstance and AllowUndecidableInstances.
09:46:24 <nibro> hmm, would that be a "parse error"?
09:46:28 <nibro> I'll try it :)
09:46:59 <nibro> yup, it worked, thx a lot :)
09:47:25 <Lemmih> I really hope Cabal will be more stable after GHC-6.6
09:47:59 <nibro> couldn't agree more
09:48:50 <nibro> and that the documentation will be up to date...
10:28:24 * araujo back from lunch
10:28:33 * araujo points Nomius to #haskell.es
10:31:09 <ADEpt> Unusually low temperature (-22) and recent discussion on haskell-cafe mailing list lead to the series of (un)fortunate events which resulted in me writing page http://www.haskell.org/hawiki/HitchhickersGuideToTheHaskell
10:31:33 <ADEpt> this is (you knew it) yet another haskell tutorial. Comments are greatly appreciated.
10:33:19 <Saulzar> Hehe, first paragraph is pretty accurate.
10:34:29 <vincenz> ADEpt: you using the knapsack algo?
10:36:01 <ADEpt> vincenz: eventually will
10:37:57 <ADEpt> vincenz: my first target was to get over IO and monads, and then go for the problem itself.
10:41:30 <Saulzar> Looks good, I like the piece about the Data constructor, that got me hung up for a while
10:42:20 <_|_kid> yet another haskell tutorial been updated?
10:42:25 <ADEpt> anything I should have covered in more detail, in your opinion?
10:42:34 <_|_kid> or you mean yet another another? ;)
10:42:35 <Saulzar> Once it is seen that IO is not a dirty hack then I think a lot of people are more happy...
10:42:37 <ADEpt> _|_kid: rather, re-done :)
10:42:54 <_|_kid> link? :D
10:43:05 <ulfdoz> Is there a general way to combine a monad and a value, e.g. to have function f of type 'Monad m => m a -> m a -> m a' which adds the two values contained in the monads and returns the sum in a new one?
10:43:18 <ADEpt> _|_kid: of course. It's like "planting a tree, raising a kid, ...". Comes time, one should write a tutorial.
10:43:26 <ADEpt> _|_kid: http://www.haskell.org/hawiki/HitchhickersGuideToTheHaskell
10:43:31 <palomer> @hoogle (Monad m) => m a -> m a -> m a
10:43:33 <lambdabot> No matches, try a more general search
10:43:39 <ADEpt> ulfdoz: liftM
10:43:44 <int-e> @type Control.Monad.liftM2
10:43:47 <lambdabot> forall r (m :: * -> *) a2 a1.
10:43:47 <lambdabot> (Monad m) =>
10:43:47 <lambdabot> (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
10:44:05 <int-e> @type Control.Monad.liftM2 (+)
10:44:06 <lambdabot> forall a2 (m :: * -> *). (Monad m, Num a2) => m a2 -> m a2 -> m a2
10:44:12 <Saulzar> Might be nice to know what "getContents" does, though I guess it is just an example...
10:44:32 <ulfdoz> Ic, thx.
10:44:49 <_|_kid> ADEpt: i thought you where talking about that YAHT paper
10:44:53 <ADEpt> Saulzar: it is there, in the first example of using "ghci"
10:46:08 <_|_kid> guys wanna read something funny? :P
10:46:52 <ADEpt> _|_kid: when YAHT was planned, i was greatly discouraged by intention to go "from scratch" and since then i was planning to "do it my way"
10:46:52 <_|_kid> course you do ;)
10:48:49 <Saulzar> Hmm, probably a bit of both helps
10:51:22 <_|_kid> i was chating in another room, so this guy was asking whether it was possible to use C# generic containers to make a heterogeneous container, of-course the answer to the question is no, not without abusing OO so once i mentioned *abuse OO* he got all defensive telling me about the whole principles of OO and abstraction that i'm already fully aware of and then said that perhaps i favour procedural paradigm o_0
10:52:02 <_|_kid> OO-zealots goto far!
10:52:18 <palomer> OO is good for getting stuff done
10:52:20 <_|_kid> that
10:52:29 <musasabi> ulfdoz: maybe mplus is what you aer looking for?
10:52:54 <palomer> OO with OO style generics gives you much of the power of sml's higher order modules with cleaner syntax
10:53:11 <_|_kid> ...
10:53:14 <musasabi> *are
10:54:11 <palomer> mzero is a fixed point of every function?
10:54:26 <palomer> (but the instance for IO defined in Control.Monad.Error  does not satisfy the second one). <--whoa
10:54:35 <Heffalump> what's unclean about the SML module syntax?
10:55:14 <_|_kid> palomer: you don't need to tell me these things as i said i'm already fully aware of that stuff, as far as i'm concerned forcing a bunch of unrelated types/concepts under a base man straw class just to get a heterogeneous container isn't a good thing
10:55:16 <Heffalump> mzero isn't a fixed point of (const (return 3))
10:55:22 <palomer> Heffalump: the fact that you either have to pollute the namespace with the structure namespace, or explicitly refer to the structure
10:55:33 <palomer>  mzero >>= f  =  mzero
10:55:50 <palomer> a fixed point of \x -> x >>= f for every f
10:56:27 <palomer> _|_kid: I'm not telling you anything!
10:56:32 <palomer> I'm discovering this thing for myself
10:57:04 <mwc> Could somebody take a look at this function: http://nomorepasting.com/paste.php?pasteID=56295 and tell me why it's so slow?
10:57:10 <palomer> it says it supports choice and failure... doesn't Monad support failure?
10:58:23 <mwc> I'm wondering if I need some seq somewhere
10:58:34 <musasabi> different kinf of failure.
10:58:48 <musasabi> a zero value rather than the fail one.
10:59:38 <Heffalump> MonadZero guarantees that you'll get a trappable failure.
10:59:53 <mwc> Just for reference, that function takes 1 minute 18 seconds of user time to execute
10:59:57 <Heffalump> sorry, MonadPlus does.
11:00:06 <SimonRC> Am I imagining it or do Haskell programmers have a tendancy to solve many problems by writing combinator libraries?
11:00:12 <mwc> shows is the best way to concat strings for printing, right?
11:00:25 <SimonRC> mwc: Yes, IIRC.
11:00:55 <_|_kid> SimonRC: http://www.willamette.edu/~fruehr/haskell/evolution.html
11:01:22 <_|_kid> read it for a laugh ;)
11:01:39 <palomer> mzero seems to be a member of MonadPlus
11:02:00 <musasabi> palomer: yes.
11:02:33 <musasabi> Although Monad has "fail" there is no generic mechanism to catch it.
11:02:36 <SimonRC> _|_kid: I've seen that before.
11:03:08 <palomer> how can you catch it with MonadZero?
11:03:13 <_|_kid> well i don't know that you have, how would i? ;)
11:03:25 <ulfdoz> liftM is implemented using do! I should have come to this soulution myself. *grml*
11:03:47 <musasabi> palomer: one can use mplus to "catch" mzero.
11:04:00 <musasabi> usually mzero and fail are different things.
11:04:15 <musasabi> but for some monads they may be the same.
11:04:31 <mwc> Hey, can anybody tell me if this could be a problem? foldl (showString) headerString dataLines
11:04:35 <palomer> define catching
11:04:39 <mwc> where dataLines is [String] and headerString is String
11:04:45 <vincenz> w
11:04:54 <Lemmih> mwc: How about profiling your program?
11:05:02 <mwc> Lemmih, I am
11:05:09 <mwc> the profile run started 3 minutes ago and I'm impatient
11:18:28 <SimonRC> _|_kid: I wasn't complaining, just stating
11:19:34 <_|_kid> i know, don't worry about it ;)
11:22:05 <mwc> Lemmih, it actually is this line that eats up 99.8% of the time and allocations: csvData = {-# SCC "csvData" #-} foldl (showString) headerString
11:25:23 <jophar_> hey ppl
11:25:31 <jophar_> anyone here uses macosx?
11:25:52 * palomer_ is anti macosx ever since it became hip
11:26:03 <jophar_> hehe =)
11:26:17 <int-e> palomer: linux, windows, and *bsd are hip - where do you go?
11:26:18 <jophar_> Darwin LapZ-G4.local 8.3.0 Darwin Kernel Version 8.3.0: Mon Oct  3 20:04:04 PDT 2005; root:xnu-792.6.22.obj~2/RELEASE_PPC Power Macintosh powerpc
11:26:22 <jophar_> pure ppc =)
11:26:24 <pesco> shapr: GHC has no ARM support yet, right?
11:26:50 <jophar_> anyways, I am getting some trouble with strings :\ 
11:27:03 <vincenz> shapr: hiya
11:27:15 <mwc> int-e, Hurd/GnuMach
11:27:20 <mwc> Hurd/L4 is too cool
11:27:26 <palomer> linux isn't hip yet
11:27:30 <pesco> int-e: Plan 9
11:27:47 <mwc> palomer, where are you from?
11:27:52 <jophar_> they are for example ''example'' || "example" || ´´example´´ || ``example`` || ``example´´ 
11:27:56 <jophar_> how are they!?
11:28:03 <palomer> canada
11:28:20 <mwc> palomer, so am I. Linux is hip here
11:28:36 <phys_rules> solaris is hip
11:28:37 <phys_rules> :)
11:28:39 <jophar_> sorry by hasking, but what is hip? :X
11:28:46 <jophar_> omg *asking
11:28:47 <pesco> phys_rules: Haha! :]
11:28:49 <mwc> you know, cool, unsquare
11:28:57 <int-e> mwc: mach isn't that cool - the performance of a unix kernel and the functionality of a microkernel ... :P
11:29:05 <mwc> hahahaha
11:29:32 <int-e> mwc: hmm. I need to catch up on Hurd/L4 news.
11:29:35 <mwc> you mean the performance of an anethetitized sloth and the functionality of a unix kernel after you build one into kernelspace :P
11:29:38 <phys_rules> pesco: I even managed to build ghc6.4 for solaris i386 :) and it runs great too :)
11:29:41 <jophar_> pesco lol cool? :X I use macosx because it has better performance than ubuntu =)
11:29:47 <mwc> wow, I need to learn how to spell difficult words
11:29:55 <jophar_> and airport extreme support  ^^
11:30:08 <mwc> Yes, but there are linux drivers for that now jophar_ 
11:30:19 <jophar_> airport extreme? 
11:30:26 <pesco> phys_rules: Nice. :)
11:30:27 <jophar_> or airport?
11:30:27 <mwc> http://bcm43xx.berlios.de/
11:30:31 <mwc> AE
11:30:37 <palomer> mwc: linux isn't hip in canada
11:30:46 <palomer> I haven't seen a single reference in Vice
11:30:52 <mwc> Hahaha
11:30:58 <pesco> jophar_: I use Ubuntu because I got sick of hand-compiling all kinds of open source programs and always having problems.
11:31:08 <phys_rules> tricia heffman is hip
11:31:15 <phys_rules> if I spelled her name right :\
11:31:18 <mwc> pesco, I found Arch to be a nice happy medium between Gentoo and Debian
11:31:21 <pesco> mwc: Have you tried the broadcom driver?
11:31:32 <pesco> mwc: I'm happy with Ubuntu, actually.
11:31:35 <jophar_> but in macosx I only compile my programs
11:31:45 <mwc> up to date like Gentoo, configurable like Gentoo, but reasonable binaries
11:31:52 <mwc> anyways
11:32:01 <jophar_> and many software does not run in PPC plataform
11:32:09 <palomer> debian is up to date
11:32:26 <pesco> jophar_: Yeah, Flash, and some porn codecs.
11:32:46 <mwc> pesco, no, I haven't, I use a powerbook, and I avoid linux on notebooks
11:32:49 <jophar_> lol 
11:33:19 <jophar_> ghc for example, I can compile the source without troubles?
11:33:27 <jophar_> I kinda like ubuntu :X
11:33:29 <jophar_> really
11:34:00 <jophar_> mwc why?
11:35:00 <jophar_> hello?
11:35:10 <mwc> jophar_, I find it has terrible support for the reasons I buy laptops: portability. Sleep/Suspend generally broken, etc.
11:35:37 <jophar_> sleep suspend at macosx is a must
11:35:43 <jophar_> works 110%
11:35:49 <mwc> exactly
11:35:57 <edwinb> I got a Mac for my new laptop because I was fed up of having to fiddle to achieve anything.
11:36:06 <mwc> I don't mind tinkering
11:36:12 <mwc> I'd just rather do it on a desktop
11:36:17 <edwinb> This one has an uptime of 49 days now...
11:36:32 <jophar_> I have just rebooted mine
11:36:35 <jophar_> had 18 days
11:36:38 <edwinb> I don't mind tinkering on a desktop, since I feel I have some chance of being successful there...
11:37:04 <tibbe> I read ( http://www.cse.unsw.edu.au/~chak/haskell/ghc/comm/the-beast/stg.html ) that Haskell generates C--, anyone knows if it (still) is the case?
11:37:07 <jophar_> well ppl... how do I use that string represent? :X
11:37:19 <mwc> I wish I knew why: csvData = foldl' (showString) headerString dataLines was so bloody slow
11:37:25 <Lemmih> tibbe: It is.
11:38:16 <chucky> tibbe: GHC generates something that isn't quite C-- though, so at the moment you wouldn't be able to run it through a C-- compiler
11:38:17 <tibbe> Lemmih, is it possible to its (GHC's) generation facilities from somewhere in Haskell? I need a good IL language.
11:38:24 <Lemmih> mwc: Concatenating lists can be really slow if done wrong.
11:38:38 <chucky> (it uses C-- as an intermediate form and then compiles it itself)
11:38:38 <mwc> yeah, I just don't understand why this is wrong
11:38:49 <jophar_> lemmih: ++ ftw ^^
11:38:56 <mwc> I thought that showString was the correct way to concat strings
11:39:00 <tibbe> chucky, itself, doesn't it use QuickC-- ?
11:39:07 <chucky> no
11:39:17 <tibbe> why?
11:40:07 <chucky> I'm not sure, but I think it more or less has to do with the fact that noone has done the work required. Plus QuickC-- isn't a very good compiler (yet)
11:40:45 <Lemmih> mwc: You're doing (("str1"++"str2")++"str3") which is bad.
11:41:23 <tibbe> chucky, I would like to use the C-- generator and GHC's garbage collector if possible
11:41:49 <eivuokko> tibby, what's your project?
11:41:51 <Lemmih> mwc: You'll be much better off with foldr or ShowS, I think.
11:41:59 <mwc> okay
11:42:02 <mwc> thanks
11:42:55 <palomer> > mplus (map ([]) [1..])
11:42:57 <lambdabot>   Expecting a function type, but found `[a]'
11:42:57 <lambdabot>   Expected type: a -> b
11:42:57 <lambdabot>   Inferred type: [a1]
11:43:02 <chucky> tibbe: GHC:s C-- generator is extremely hard to decouple from GHC. I tried once but gave up. I have an abstract syntax that closely mimics the BNF in the C-- spec and a pretty printer for it if you want it?
11:43:08 <tibbe> eivuokko, a small strict, functional language (educational, for me)
11:43:14 <palomer> > foldl1 mplus (map ([]) [1..])
11:43:16 <lambdabot>   Expecting a function type, but found `[a]'
11:43:16 <lambdabot>   Expected type: a1 -> m a
11:43:16 <lambdabot>   Inferred type: [a2]
11:43:22 <palomer> @type mplus
11:43:23 <lambdabot> Not in scope: `mplus'
11:43:27 <palomer> @hoogle mplus
11:43:28 <lambdabot> Control.Monad.mplus :: MonadPlus m => m a -> m a -> m a
11:43:32 <tibbe> chucky, sure, I would love to
11:43:33 <Lemmih> mwc: 'showString' == '++', btw.
11:43:37 <eivuokko> tibbe, Ah.  As chuck says, C-- or gc are both pretty tied to ghc.
11:43:44 <eivuokko> *and
11:44:13 <mwc> Lemmih, ah
11:44:15 <mwc> Okay
11:44:32 <xerox> palomer: what are you trying to do?
11:44:44 <palomer> get back [1..]
11:44:45 <mwc> I didn't realize that's how it worked
11:44:48 <chucky> tibbe: it's in the darcs repo for mine and farre's thesis, here: http://www.dtek.chalmers.se/~d00farre/thesis/repository The C-- things are in: http://www.dtek.chalmers.se/~d00farre/thesis/repository/src/Language/Cmm/
11:44:52 <tibbe> eivuokko, you mean the C-- generation or C-- itself?
11:45:04 <xerox> palomer: map (const []) [1..] = repeat []
11:45:06 <tibbe> chucky, I'm at CTH too ;)
11:45:11 <chucky> I know
11:45:20 <palomer> @type ([])
11:45:21 <lambdabot> forall a. [a]
11:45:32 <palomer> oh, righto
11:45:48 <palomer> hrm, I've always seen [] as an operator
11:45:49 <tibbe> chucky, oh, I said so before?
11:46:13 <chucky> tibbe: You did. :) We'll probably release the C-- lib stand-alone when we get the time. We just have to find time to fix my lexer/parser first
11:46:15 <xerox> palomer: maybe you mean (:[]) :: a -> [a], or return.
11:46:16 <palomer> so is there a function  \x -> [x] ?
11:46:21 <palomer> ah, gotcha
11:46:28 <palomer> > foldl1 mplus (map (:[]) [1..])
11:46:29 <araujo> palomer, return ?
11:46:35 <lambdabot> Terminated
11:46:38 <palomer> > foldr1 mplus (map (:[]) [1..])
11:46:40 <lambdabot> [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,
11:46:40 <lambdabot> 28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
11:46:40 <lambdabot> 52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,
11:46:40 <lambdabot> 76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,
11:46:40 <lambdabot> 100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,
11:46:42 <lambdabot> [24 @more lines]
11:46:47 <tibbe> chucky, lexer/parser for C-- ?
11:46:48 <int-e> > return 1 :: [Int]
11:46:49 <lambdabot> [1]
11:47:01 <chucky> tibbe: exactly
11:47:05 <palomer> > foldr1 mplus (map return [1..])
11:47:07 <lambdabot>  add an instance declaration for (Show (m a))
11:47:13 <araujo> > return 1 :: [Int]
11:47:15 <lambdabot> [1]
11:47:20 <int-e> araujo: return in the list monad builds a singleton list.
11:47:34 <araujo> int-e, yes
11:47:55 <tibbe> chucky, okay, but I don't need them for generating C-- right
11:48:20 <xerox> @pl foldr1 mplus (map return)
11:48:21 <lambdabot> foldr1 mplus (map return)
11:48:35 <chucky> tibbe: no, you just have to convert your programs into the abstract syntax, then you can pretty print it
11:48:37 <xerox> @pl foldr1 mplus . map return
11:48:38 <lambdabot> foldr1 mplus . map return
11:48:47 <xerox> @pl foldr mplus mzero . map return
11:48:49 <lambdabot> foldr mplus mzero . map return
11:49:09 <tibbe> chucky, great, converting my languages AST to a C-- AST should be too hard
11:49:18 <tibbe> chucky, what's your thesis about?
11:49:30 <chucky> we're building a Ruby to C-- compiler
11:49:49 <palomer> chucky: very cool
11:49:51 <chucky> it's very incomplete, but it can compile some programs
11:49:51 <tibbe> chucky, Ruby is garbage collected, right?
11:49:51 <xerox> Why?  :-)
11:50:12 <chucky> xerox: Why not? :)
11:50:32 <xerox> Meh.
11:50:34 <palomer> C-- seems like a good intermediate language
11:50:37 <chucky> we wanted to explore whether C-- is a good fit for a dynamically typed object-oriented language
11:50:42 <xerox> Ah!
11:50:43 <chucky> and it is
11:50:50 <palomer> I always thought that all languages should compile down to a common intermediate language
11:50:54 <tibbe> what GC do you use? the Boehm one?
11:51:13 <xerox> DSILs :-)
11:51:46 <chucky> we don't have a GC. We haven't had the time to write one. Plugging in Boehm's should be trivial if we feel like it
11:52:27 <tibbe> chucky, that's my thinking exactly, C-- and interface the Boehm collector from within C--
11:53:18 <chucky> tibbe: You could also have a look at the Tiger to C-- compiler on the C-- homepage. They implement a copy-collect GC
11:53:21 <tibbe> I'm a bit unsure how much interaction between the C-- runtime and the GC runtime is needed.
11:53:29 <tibbe> chucky, seen it
11:53:47 <farre> but plugging in Boehm would require some extensive re-writing of the rts, or am I wrong now chucky?
11:54:13 <tibbe> farre, rts?
11:54:22 <Heffalump> doesn't the Boehm collector rely on the semantics of C?
11:54:24 <tibbe> the GC need to walk the C-- stack right?
11:54:33 <farre> (r)un (t)ime (s)ystem
11:54:46 <tibbe> Heffalump, that was my thinking, it must use some C info to walk the stack
11:55:15 <chucky> farre: not that much work I think. We just have to explicitly call malloc instead of having our own heap? Or am I, to steal a Swedish expression, "out bicycling"? :)
11:55:21 <Heffalump> does C-- allow more pointer hiding than C?
11:56:35 <tibbe> perhaps it would be easy just use a simple copy collector at first so I don't have to change the RTS
11:56:59 <davidhouse> hi, i started learning haskell about twenty minutes ago. i'm just working through some exercises and wondered if someone could give me a hand:
11:57:07 <SimonRC> anyone know what the binding for getstr() is in hscurses?
11:57:25 <davidhouse> the exercise is to write a recursive function my_map which behaves exactly like map
11:57:43 <davidhouse> now, i've got started, but i'm getting some compilation errors. let me pastebin.
11:57:44 <SimonRC> yes, and...?
11:57:48 <SimonRC> oops
11:58:26 <davidhouse> http://pastebin.com/517911 is what i have
11:58:48 <davidhouse> the error is "Couldn't match `[a]' against `t -> t1'"
11:58:59 <farre> chucky: nope, no bicycles. but that would make the heap implicit, wouldn't it?
11:59:22 <SimonRC> davidhouse: without looking, I can say that you are applying a function to too many arguments, or applying a non-function to something
11:59:25 * SimonRC checks
11:59:58 <SimonRC> in the second line, you are applying f to tail
11:59:59 <Lemmih> davidhouse: "f tail (l)" means "(f tail) l".
12:00:08 <davidhouse> oops
12:00:17 <SimonRC> application is right-assoociative.
12:00:18 <davidhouse> hmm
12:00:23 <davidhouse> what would the syntax be then?
12:00:33 <davidhouse> i want to pass both f and tail(l) to my_map
12:00:36 <Lemmih> davidhouse: "f (tail l)"
12:00:57 <davidhouse> Lemmih, i don't want to do that
12:01:02 <SimonRC> my_map f l = f (headl) : my_map f (taill)
12:01:03 <SimonRC> my_map f l = f (headl) : my_map f (tail l)
12:01:12 <Lemmih> davidhouse: Sure you do (:
12:01:12 <SimonRC> my_map f l = f (head l) : my_map f (tail l)
12:01:46 <davidhouse> cool, thanks SimonRC, Lemmih :)
12:01:58 <SimonRC> a general guide for nested function application is that you can't go very wrong if you write it like LISP
12:02:26 <SimonRC> davidhouse: you might be less confused once you learn about currying
12:02:43 <davidhouse> yeah
12:02:53 <SimonRC> also, if you use hugs, try ghci, and vice-versa
12:03:04 <davidhouse> yeah
12:03:08 <SimonRC> sometimes one understands the problem better than the other
12:03:46 <davidhouse> hugs sounds like such a friendly program :)
12:04:17 <davidhouse> you're frustrated after hours of fruitless debugging, nothing seems to be working.
12:04:23 <SimonRC> I assume that no-one here knows abut hscurses then.
12:04:25 <davidhouse> but it's okay, you've got an intepreter called hugs!
12:04:29 <SimonRC> :-)
12:05:01 <SimonRC> davidhouse: If you are confused now, just wait till you get onto monads.
12:05:10 <davidhouse> hehe
12:05:23 <SimonRC> nothing like a really inscrutable monad type problem to ruin your day
12:05:24 <araujo> monads are fun, don't be scared :-P
12:06:17 <SimonRC> They are fun when you don't try to compose monad type transformers in a way that '98 doesn;t support
12:06:19 <ndm_> davidhouse: have you tried WinHugs, that implies both success and friendliness
12:06:27 <davidhouse> yay! :)
12:06:48 <SimonRC> the line-editing in WinHugs is frankly crap.
12:07:07 <ndm_> SimonRC, which version?
12:07:13 <ndm_> 2005, or 2003?
12:07:22 <davidhouse> was haskell written with maths in mind? there seem to be some similarities
12:07:31 <davidhouse> more so than other languages, at least
12:08:18 <Cale> It was certainly designed by people with a fair amount of mathematical knowledge
12:08:31 <SimonRC> ndm_: dunno, the one I have at Uniu
12:08:32 <Cale> Monads and Functors come from category theory
12:08:39 <ndm_> SimonRC, I recently rewrote WInHugs, in particular the line handling bits, so its now really good
12:08:54 <ndm_> the unoffical build, the official one is still the old version
12:09:11 <davidhouse> oh, hey Cale. I took your advice.
12:09:15 <Cale> :)
12:09:16 <davidhouse> :)
12:09:17 <SimonRC> you don;t enter line-drawing charaters when you hit control cahraters now?
12:09:48 <ndm_> SimonRC, no
12:10:04 <ndm_> at least i'm pretty sure i don't - if i do give me an exact instance, and i'll fix it
12:10:24 <ndm_> @where winhugs
12:10:25 <lambdabot> http://www.cs.york.ac.uk/~ndm/projects/winhugs.php
12:10:29 <ndm_> thats the new version
12:11:51 <SimonRC> I'll try to persuade the ITS to upgrade :-)
12:12:16 <ndm_> SimonRC, with any luck there will be an official release in a month or so, so you might want to wait
12:12:30 <ndm_> although that version is an awful lot better than the old one, more haskell compliant as well
12:14:09 <edwinb> ndm: if the upgrade process is the same as it used to be, he should start asking now then ;)
12:14:36 <ndm> edwinb: York is certainly worse, we're still running Linux Hugs 2000, Windows 2001
12:14:56 <ndm> and there is a standing request for "the latest version" of Hugs for the last 5 years
12:15:23 <ndm> thats why i made MinHugs - Hugs in 2mb, so students can install it on their disk space
12:15:50 <gour> dcoutts: ping
12:16:14 <chucky> at Chalmers, we have an "unsupported" area with programs installed by various students and employees. I tend to ensure that we have the latest hugs/ghc there.
12:16:39 <ndm> chucky, York too, but no students know of its existance, so they can't use it
12:16:45 <chucky> :/
12:20:16 <edwinb> well it's all better than here. As far as I know we're not teaching a functional language at all this year...
12:20:33 <ndm> where is that?
12:20:37 <edwinb> St Andrews
12:20:54 <edwinb> apparently there was a course last year, but only one person took it.
12:28:10 <SimonRC> edwinb: heh
12:33:15 <Cale> davidhouse: how are you finding it?
12:33:35 <davidhouse> Cale, i'm just writing my first program longer than a couple of lines
12:33:39 <Cale> :)
12:33:59 <davidhouse> it looks nice. i've played around a little with functional programming before with XSLT
12:34:23 <davidhouse> it's still going to be a shock to my PHP-based system, but it's worth checking out :)
12:34:32 <davidhouse> just working through that textbook you found me
12:34:40 <Cale> yeah, XSLT is like what you get when you take a functional lanuage and remove all the convenient bits :)
12:34:56 <davidhouse> by the way, is there a built-in factorial function?
12:35:09 <Cale> no, but you can write  fact n = product [1..n]
12:35:32 <davidhouse> that'll do
12:36:41 <davidhouse> right, lets give this a compile
12:37:36 <davidhouse> hmm... the whitespace sensitivity is going to take some getting used to
12:37:51 <tromp> layout rules are tricky
12:38:01 <Heffalump> hmm. One of the suggestions for Haskell' is to rename the composition operator.
12:38:15 <Cale> Heffalump: yeah, that's not going to happen ;)
12:38:16 <tromp> rename to what?
12:38:24 <Heffalump> they don't say.
12:38:33 <Cale> davidhouse: make sure that your editor converts tabs to spaces
12:38:36 <Heffalump> the point is to avoid the lexical problems from the collision with module namespacing
12:38:40 <kosmikus> Heffalump: I'll do all I can to prevent that.
12:38:44 <Cale> davidhouse: the compiler treats tabs as 8 spaces
12:38:45 <tromp> if there was a centered dot, that wld be the best choice
12:39:00 <davidhouse> Cale, i'm a hard-tabs kind of guy anyway, so that's okay
12:39:04 <Cale> a centred circle
12:39:16 <tibbe> hmmm, implementing strict fuctional languages should be much easier than implementing lazy ones right? no G-machine needed, just convert functions to assembler "procedures"
12:39:18 <Heffalump> kosmikus: I doubt it'll succeed.
12:39:29 <Cale> davidhouse: yeah, but you're going to find that annoying unless you explicitly use braces and semicolons everywhere
12:39:40 <kosmikus> Heffalump: why not?
12:39:46 <Korollary> A real composition operator (in unicode) would be nice, though.
12:39:55 <edwinb> we'll all just stick (.) = nameWeDidntLike in our code anyway...
12:40:01 <Heffalump> kosmikus: because a lot of people will have the same reaction, and Haskell' is supposed to be a conservative extension
12:40:03 <tromp> i guess i'd have to be a normal word then
12:40:04 <davidhouse> oh? are tabs not easier then?
12:40:08 <Heffalump> edwinb: no, the idea is to make . a reserved character
12:40:08 <tromp> like after
12:40:13 <edwinb> oh, I see...
12:40:17 <edwinb> that would be annoying.
12:40:24 <Heffalump> otherwise you still have the same lexical problems as now
12:40:27 <Cale> davidhouse: sometimes you need to line things up by character, which tabs are no good for
12:40:32 <davidhouse> true
12:40:36 <Cale> s/need to/want to/
12:40:41 <edwinb> I can generally overcome the lexical problems we get now
12:41:01 <Cale> most editors can convert both ways and make sure only spaces are in the output file
12:41:04 <tromp> although `after` looks bad:(
12:41:17 <Heffalump> I agree that it's an unfortunate situation. But removing . would be worse than not doing so.
12:41:34 <kosmikus> Heffalump: ah, I misunderstood you then.
12:42:12 <kosmikus> Heffalump: it's listed as "probably no" anyway.
12:42:12 <Heffalump> anyway, if you need an extra voice raised in opposition, let me know :-)
12:42:23 <Heffalump> ok, that wasn't clear from the wiki page, or I missed that
12:42:40 <Heffalump> but I'm sure that's just a work in progress
12:42:43 <Cale> saner would be to use a different character for module qualification
12:42:47 <ndm> Heffalump: the wiki page doesn't give the probably, its on a trac page
12:43:18 <Heffalump> I meant the trac page.
12:43:24 <Heffalump> Since trac claims to be a wiki too.
12:43:33 <Heffalump> or at least the page in question does
12:44:18 <ndm> there seem to be tickets that link to wiki pages
12:44:25 <ndm> and the ticket has the probably no on it
12:44:35 <ndm> but i can't find any way from the wiki to the ticket, although the reverse is easy
12:44:41 <davidhouse> what's the function to convert integers -> strings? the opposite of read
12:44:46 <Heffalump> ah.
12:44:51 <Heffalump> davidhouse: show
12:44:52 <eivuokko> davidhouse, show
12:44:55 <davidhouse> thanks
12:45:44 <davidhouse> i still prefer invisible casting, but meh. :)
12:46:08 <SamB> anyway, hardly anyone would go along with a move to take out (.)...
12:46:24 <araujo> oh no, please
12:46:40 <SamB> davidhouse: well, it is difficult for the compiler to determine when to do that without you giving types for *every single subexpression*
12:46:55 * araujo throws poisoned lambdas at anybody willing to do that
12:47:12 <SamB> which gets VERY unwieldy
12:47:17 <SamB> or at least, things like that do
12:47:34 <davidhouse> SamB, well if i do "some string" ++ num, it'd be reasonable for the compiler to automatically cast the num
12:47:46 <Korollary> haskell is very anti-dwim
12:47:49 <phys_rules> a . b rocks, a real unicode composition would be nice, but it's better to have all the files in ASCII imho...
12:48:23 <roconnor> Coq allows you to declare implict coercions.  The results aren't too bad.
12:48:25 <Heffalump> I think once Unicode becomes ubiquitous, I would support the idea.
12:48:28 <SamB> davidhouse: no, because that would require magical typing
12:48:45 <Heffalump> (with a convertor provided for old code)
12:48:53 <SamB> roconnor: that might be interesting...
12:48:58 <Heffalump> and a compiler flag that allowed it for some time
12:49:00 <tromp> i don't want to see umlauts in identifiers...
12:49:18 <Heffalump> why not?
12:49:21 <davidhouse> no it wouldn't. the compiler would recognise that a string had been asked for and you've got a int, so instead of throwing a type mismatch it could just do a silent cast
12:49:31 <SamB> phys_rules: I think utf-8 is the way to go for text files myself, but then there'd be the matter of binary files...
12:49:48 <Heffalump> davidhouse: that wouldn't provide deterministic behaviour
12:49:49 <SamB> davidhouse: that *is* magic types
12:50:11 <eivuokko> davidhouse, ++ asks for list, not string.  If it was just for String, it would be workable with typeclasses.
12:50:20 <SamB> davidhouse: unless you have a set of rules that makes this behaviour systematic and extensible, of course ;-)
12:50:23 <Heffalump> the type system makes it well-defined what is and isn't a type error, but it doesn't make it well-defined where the error will be found in code that has errors
12:50:49 <Heffalump> so if you add a hack that adds a "cast" in places it finds an error, your programs become dependent on the particular type checking implementation
12:51:21 <davidhouse> hmm...
12:51:27 <phys_rules> SamB: but where's the limit, for example in mathematica you can type both code or use symbols, [Esc]...[Esc], it all looks pretty and all, but quite often it's a loss of time I think :)
12:51:45 <davidhouse> well i've come from PHP and i know it works well there.
12:52:01 <SamB> anyway, you have to write a paper with maths showing the inference rules for this to work
12:52:07 <Heffalump> PHP isn't a strongly typed language, though.
12:52:19 <davidhouse> true
12:52:19 <Heffalump> it also doesn't have higher-order functions
12:52:31 <SimonRC> PHP's type system isn;t very powerful
12:52:38 <SamB> phys_rules: oh, I never said I think its really a good idea to use for source code ;-)
12:52:39 <davidhouse> okay, so really what i'm saying is that i like the loose typing :)
12:52:43 <tromp> php is a hack
12:52:48 <Heffalump> ok, then don't use Haskell
12:53:02 <eivuokko> davidhouse, Stick fow a hiwle with haskell and you might change your mind ;)
12:53:11 <SamB> phys_rules: maybe a few more symbols which are specifically layed out as symbols that should be easy to type, for infix usage...
12:53:15 <Heffalump> that really is one thing you can't get away from with Haskell.
12:53:48 <roconnor> http://coq.inria.fr/doc/Reference-Manual019.html
12:53:53 <roconnor> Coercions in Coq
12:53:57 <SamB> Heffalump: yes, but you can learn to love it ;-)
12:55:04 <roconnor> It ought to be easier in Haskell because in Haskell the result of a function is never a type.
12:55:14 <qwr> davidhouse: take ruby or lisp/scheme for example, if you want dynamic typeing
12:55:24 <edwinb> I quite like the type system telling me when I've been dumb, rather than an obscure bug that only manifests itself at weird times.
12:55:40 <lispy> anyone here looked at hIDE?
12:55:44 <phys_rules> SamB: all haskell needs is 1) good books for java, c, c#, etc.. programmers 2) a good IDE, and it will rock even more =) the kewl symbols could come well after that ;)
12:55:47 <edwinb> roconner: There was a paper in Types 2003 about Coercions in Hindley-Milner...
12:56:01 <Lemmih> lispy: I've had my eyes on it for a while (:
12:56:04 <lispy> this is what i get when i try to build
12:56:05 <edwinb> I don't remember the details, but it's not quite so easy as that...
12:56:05 <lispy> $ sh build.sh 
12:56:06 <lispy> *** Exception: Line 9: Unknown field 'hs-source-dirs'
12:56:09 <SamB> qwr: they don't generally implicitly cast between types
12:56:19 <lispy> grep -rn "hs-source-dirs" * returns nothing
12:56:42 <roconnor> Hmm, this document doesn't seem to discuss when coercions are inserted.
12:56:50 <Lemmih> lispy: Building is really hard currently. It borders to the impossible.
12:57:05 <lispy> Lemmih: hehe, any idea what it is looking for?
12:57:07 <SamB> phys_rules: yeah, that is a pretty sane outline, I guess... though not everyone will want to use hIDE
12:57:15 <SamB> no matter how nice it is, some die-hards will want to use something else
12:57:38 <Lemmih> lispy: You need a newer version of Cabal to make it to the next error message.
12:57:42 <qwr> SamB: i would call not doing so a feature ;)
12:57:43 <SamB> Lemmih: worse than before?
12:58:00 <lispy> SamB: i'm just annoyed that emacs and eclipse can't parse my haskell source and get it all wrong...(eclipse is very wrong)
12:58:11 <lispy> Lemmih: hehe, okay
12:58:31 <SamB> qwr: well, yeah. but apparantly this guy doesn't care so much about static/dynamic typing as about implicit casts
12:58:32 <phys_rules> eclipse is java, java is slow, java is lots of memory gone, gone, gone
12:58:33 <phys_rules> =)
12:58:55 <SamB> lispy: Emacs doesn't parse much.
12:58:57 <ndm> SamB, no matter how nice it is, if it forces GHC, its going to be pretty slow to compile
12:58:58 <tromp> it's much easier to control memory in java than in ghc
12:59:08 <SamB> it can parse elisp, and it can parse XML
12:59:24 <SamB> but only without mule-ucs
12:59:37 <phys_rules> SamB: the lack of books is quite bad though, there are tutorials here and there, but not something at the level of "thinking in java"
12:59:52 <SamB> oh, it can parse relax NG compact as well
12:59:53 <lispy> SamB: yeah, it gets the syntax colors all wrong and doesn't understand indentation :(
13:00:14 <SamB> phys_rules: yeah, we could use more/better books I'm sure ;-)
13:00:20 <SamB> lispy: that is bad.
13:00:24 <phys_rules> SamB: I mean I only know 2 books, one is The craft of functional programming, and the other is well, I forgot the title ;)
13:00:42 <phys_rules> lispy: and you use the haskell plugin ?
13:00:43 <SamB> Emacs gets the colors right at least, though sometimes it won't indent right
13:00:51 <lispy> phys_rules: yes
13:01:00 <phys_rules> yikes, sounds bad
13:01:10 <SamB> *usually* when emacs gives me wierd colors, my code doesn't parse right anyway
13:01:15 <lispy> SamB: put some characters in stringsand it won't get it riht anymore
13:01:16 <roconnor> I've been using Kate lately to write my Haskell
13:01:30 <lispy> SamB:  "{-" for example
13:01:41 <Korollary> yeah I've seen the {- as well
13:01:43 <SamB> lispy: hmm, yes, there is that.
13:02:01 <lispy> roconnor: kate supports haskell?
13:02:30 <SamB> but if you follow it soon with "-}" you're okay
13:04:08 <lispy> hmm..i guess SEE does haskell, maybe i should try it again, although seems like it did something that really bothered me
13:04:10 <Cale> davidhouse: Well, you can define operations like that in Haskell.
13:04:39 <Cale> davidhouse: but it's a bit of work, and you'll end up with some pretty funny looking types :)
13:04:40 <davidhouse> like what sorry?
13:04:52 <davidhouse> i was afk for a while
13:05:09 <matchthis> must go today message me if interestedon aim at mikcomputing, msn at mcsltd3@hotmail.com or yahoo at mcsltd2 only if your interested and want to buy! .  prices are 550 each includes shipping case and wireless router.2 alienware products, 1 area51-m 5700 notebook, and one area51 7500 desktop tower system.  
13:05:25 <Cale> "50" +++ 7 :: String  ==>  "507", while  "50" +++ 7 :: Integer  ==> 57
13:05:37 <Cale> where by ==> I mean "evaluates to"
13:05:50 <davidhouse> so :: casts?
13:05:50 <Cale> let me write one for you
13:05:56 <Cale> It specifies the type
13:06:10 <davidhouse> right
13:06:20 <Cale> let me construct an example :)
13:06:20 <Korollary> Cale: What happens for '7 +++ "50" +++ 3' ?
13:06:38 <Cale> Korollary: depends on associativity and the instances that are defined
13:06:58 <SamB> Korollary: presumably you have to parenthesise and put a type sig on some part of that
13:06:59 <Cale> you probably want to specify that +++ is nonassociative if it's going to behave like that
13:07:54 <SamB> soon enough, you will be specifically avoiding types like that...
13:08:26 <Cale> yeah, this isn't exactly the best idea, but my point is just that it can be done if you really really want it
13:08:52 <Heffalump> it'll only work with newly written functions, though
13:09:49 <roconnor> lispy: keywords are highlighted.  So are some prelude functions
13:10:04 <roconnor> comments are in grey
13:10:07 <Cale> well, it's restricted to this +++ function you're defining
13:11:40 <Cale> and the number of instances you'll be forced to define for it to work on more types goes up real fast
13:11:48 <xerox> Cale: is it like (+++) :: a -> b -> c with fundep'd class constraints on a b c?
13:12:05 <Cale> xerox: or non-fundepped class constraints
13:12:40 <xerox> Well, yes
13:12:58 * araujo thinking to use tuples to do some kind of 'dynamic typing' tricks
13:14:51 <JKnecht> would that work with ghc?
13:14:55 <Cale> You can do some pretty neat things with typeclasses -- see: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Text-Printf.html
13:15:07 <roconnor> Hmmm, maybe I should have used Parsec to solve my parsing problems yesterday
13:15:15 <araujo> parsec++
13:16:07 <edwinb> parsec is lovely. I have finally noticed ;)
13:19:06 <davidhouse> okay, well i've got some more compilation errors. for people that didn't catch my previous pretext, i've been writing haskell for about an hour now so no sniggers :)
13:19:16 <davidhouse> code is http://pastebin.com/518012 errors http://pastebin.com/518020
13:20:22 <JKnecht> it's snicker.
13:20:23 <Cale> oh
13:20:30 <Cale> let sum = foldr + 0 nums
13:20:35 <davidhouse> JKnecht: err, that too
13:20:44 <Cale> that parses as  (foldr) + (0 nums)
13:20:45 <musasabi> foldr + 0 nums => foldr (+) 0 nums
13:20:58 <JKnecht> you must want the lisp channel :)
13:20:59 <Cale> you don't have to define sum and product
13:21:07 <Cale> they're in the Prelude
13:21:13 <Cale> > product [1..10]
13:21:15 <lambdabot> 3628800
13:21:28 <davidhouse> oh good
13:21:48 <Cale> also, farther down, you have (show product)
13:21:49 <davidhouse> okay, well that first error has disappeared
13:21:51 <musasabi> davidhouse: the following might be more intuitive:
13:21:53 <Cale> which won't work
13:21:54 <roconnor> map printfact nums => mapM_ printfact nums  , I think
13:22:14 <Cale> yeah, that too
13:22:14 <davidhouse> Cale, well sum/product were variables
13:22:16 <roconnor> (which I learned about yesterday)
13:22:22 <Cale> yeah, that's true
13:22:25 <davidhouse> roconnor: what's the difference?
13:22:32 <musasabi> getNumbers = do putStrLn "..." ; inp <- getContents; return $ map read $ lines inp
13:22:34 <Cale> but then you went and used the ordinary sense of product
13:22:41 <roconnor> You want to sequence each printing
13:22:49 <roconnor> that requires using mapM
13:22:57 <Cale> @type map
13:22:58 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
13:22:59 <roconnor> so it knows to process the list from front to back
13:23:06 <Cale> @type mapM
13:23:08 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
13:23:12 <Cale> @type mapM_
13:23:14 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> [a] -> m ()
13:23:15 <roconnor> then you want to ignore the output, that requires mapM_
13:23:22 <SamB> roconnor: well, or you could use sequence . map, but that is pretty much the same thing, no?
13:23:26 <Cale> yes
13:23:32 <Cale> mapM = sequence . map
13:23:35 <roconnor> mapM would return IO [()]
13:23:36 <Cale> mapM_ = sequence_ . map
13:23:44 <Cale> @type sequence
13:23:45 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
13:23:49 <Cale> @type sequence_
13:23:51 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
13:24:01 <roconnor> @type sequence . map
13:24:03 <lambdabot>   Expecting a function type, but found `b'
13:24:03 <lambdabot>   Expected type: (a1 -> b) -> [m a]
13:24:12 <musasabi> hmm, you stop at 0, then your code is good.
13:24:13 <Cale> sequence takes a list of actions and turns it into an action running each and returning a list of results
13:24:23 <roconnor> SamB, you could, except map is a binary function.
13:24:25 <davidhouse> roconnor, Cale, musasabi: thanks, it compiles onw :)
13:24:33 <Cale> davidhouse: cool
13:24:46 <SamB> roconnor: I don't see how that is relevant
13:25:03 <roconnor> sequence . map doesn't typecheck
13:25:05 <SamB> doesn't mean it isn't!
13:25:14 <SamB> hmm, let me see...
13:25:20 <roconnor> @pl (\x y -> sequence (map x y))
13:25:21 <lambdabot> (sequence .) . map
13:25:28 <roconnor> SamB, that's what you want
13:25:48 <Heffalump> @pl mapM
13:25:49 <lambdabot> mapM
13:25:53 <Heffalump> @type mapM
13:25:55 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
13:25:56 <SamB> roconnor: hmm.
13:26:01 <Heffalump> @type (sequence .) . map
13:26:02 <lambdabot> forall (m :: * -> *) a a1.
13:26:02 <lambdabot> (Monad m) =>
13:26:02 <lambdabot> (a1 -> m a) -> [a1] -> m [a]
13:26:07 <SamB> those things are so ugly
13:26:12 <Heffalump> I suggest mapM instead :-)
13:26:25 <roconnor> mapM is good
13:26:26 <SamB> yes.
13:26:29 <Heffalump> oh, sorry, there's been a discussion about this already
13:26:33 <Heffalump> I should read scrollback.
13:27:28 <SamB> but when you actually go to write code, you don't need two dots to use sequence and map, though I agree this would be silly to do intentionally...
13:28:27 <roconnor> SamB, yes when writing real code you will write sequence $ map f l
13:29:29 <lispy> roconnor: is it easy to change those colors?  I like a dark background, i can read the code for longer without eyestrain
13:30:00 <roconnor> lispy: I'm not sure.  I've only just started using Kate recently.
13:30:18 <lispy> okay, well not sure how i would install kate on osx, so i'll look at SEE first
13:30:45 <roconnor> sure, I just used Kate 'cause it was on my system.
13:31:43 <SamB> lispy: personally, I'm more concerned with brain strain than eyestrain, though perhaps I should worry more about eyestrain than I do...
13:33:24 <roconnor> :type newline
13:33:34 <roconnor> @type newline
13:33:35 <lambdabot> Not in scope: `newline'
13:33:42 <roconnor> @hoggle Char
13:33:43 <lambdabot> Data.Char.Char :: Char
13:33:43 <lambdabot> GHC.Exts.Char :: Char
13:33:43 <lambdabot> Prelude.Char :: Char
13:34:05 <roconnor> that's a bizarre response
13:34:12 <SamB> "@hoggle", eh?
13:34:13 <roconnor> @hoggle String
13:34:14 <lambdabot> Data.Char.String :: [Char]
13:34:14 <lambdabot> Prelude.String :: [Char]
13:34:14 <lambdabot> Text.ParserCombinators.ReadP.string :: String -> ReadP String
13:34:32 <roconnor> @hoggle [Char]
13:34:33 <lambdabot> No matches, try a more general search
13:34:35 <SamB> yeah, those "::"s are nonsensical
13:34:46 <roconnor> @hoggle Char -> Char
13:34:47 <lambdabot> Data.Char.toUpper :: Char -> Char
13:34:47 <lambdabot> Data.Char.toLower :: Char -> Char
13:34:47 <lambdabot> GHC.Unicode.toUpper :: Char -> Char
13:34:52 <SamB> it is really spelled "@hoogle", btw
13:35:05 <roconnor> oh right
13:35:18 <SamB> > Char.isNewline '\n'
13:35:19 <lambdabot>  Not in scope: `Char.isNewline'
13:35:23 <SamB> >isNewline '\n'
13:35:25 <SamB> > isNewline '\n'
13:35:26 <lambdabot>  Not in scope: `isNewline'
13:35:42 <SamB> @hoogle newline
13:35:43 <lambdabot> Text.ParserCombinators.Parsec.Char.newline :: CharParser st Char
13:35:43 <lambdabot> Graphics.UI.ObjectIO.StdSystem.newLineChars :: String
13:35:43 <lambdabot> Text.Regex.Posix.regNewline :: Int
13:36:23 <SamB> > lines "\n"
13:36:25 <lambdabot> [""]
13:36:56 <roconnor> > Graphics.UI.ObjectIO.StdSystem.newLineChars
13:36:57 <lambdabot>  Not in scope: `Graphics.UI.ObjectIO.StdSystem.newLineChars'
13:39:19 <orbitz> is there any documetnation system like help() or describe in python/lisp?
13:39:35 <SamB> not like that
13:39:36 <Cale> there's :t
13:39:40 <SamB> you can do :b
13:39:41 <Cale> and :info
13:39:43 <SamB> and :t
13:39:45 <SamB> and :i
13:39:58 <SamB> which is presumably the same as :info
13:39:59 <palomer> hrm, has anyone studied doing unification where implication is your only logical operator
13:40:06 <Cale> but for real descriptions, use the haddock docs on the web
13:40:07 <palomer> and you can't parenthize
13:40:11 <SamB> and then there are haddock docs
13:40:25 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
13:40:28 <SamB> @index Ratio
13:40:29 <lambdabot> Data.Ratio
13:40:35 <SamB> @docs Data.Ratio
13:40:36 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Ratio.
13:40:36 <lambdabot> html
13:41:02 <SamB> hmm. someone needs to do something about that URL wrapping; it is BAD.
13:41:28 <orbitz> i take it nobody has written an emacs hyperspec functions for haddock?
13:41:30 <eivuokko> All wrapping is bad in lambdabot, imo.
13:41:34 <Cale> yeah, plugins who emit URLs should be exempt from line wrapping
13:42:42 <SamB> orbitz: not that I know of
13:42:59 <palomer> omg, parenthesization is not a word!
13:43:21 <SamB> palomer: the dictionary is necesarily incomplete
13:44:34 <Heffalump> probably the interface between plugins and line wrapping needs to be made richer.
13:44:55 <Heffalump> why not use pretty printing combinators?
13:45:00 <SamB> ooh, like some kind of "document" thingys?
13:45:02 <SamB> yeah, like that.
13:45:42 <eivuokko> How could line wrapping be sensible (except explcit newlines) when it depends on client how it's shown?
13:48:12 <mwc> eivuokko, that's my thought exactly: line wrapping is a client problem
13:49:24 <SamB> maybe #haskell ought to be a MOO
13:50:05 <mwc> MUD?
13:50:07 <Cale> SamB: Or some kind of MUSH
13:50:42 * mwc hits Cale with +9 Sword of Polymorphism for 6 HP
13:50:51 <SamB> @foldoc mush
13:50:53 <philip>  /msg NickServ HELP REGISTER
13:50:54 <lambdabot> *** "mush" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
13:50:54 <lambdabot> MUSH
13:50:54 <lambdabot>  
13:50:54 <lambdabot>    1. <games> {Multi-User Shared Hallucination}.
13:50:54 <lambdabot>  
13:50:55 <lambdabot>    2. <messaging> {Mail Users' Shell}.
13:50:56 <palomer> a multi lingual MOO has just been released
13:50:58 <lambdabot>  
13:51:11 <mwc> @foldoc MOO
13:51:13 <lambdabot> *** "moo" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
13:51:13 <lambdabot> MOO
13:51:13 <lambdabot>  
13:51:13 <lambdabot>    {MUD Object Oriented}
13:51:13 <lambdabot>  
13:51:22 <mwc> wtf...
13:51:33 <eivuokko> ^^
13:51:47 <SamB> mwc: wtf what?
13:51:55 <mwc> Cale.hit(myInventory.search(Sword)) ?
13:52:20 <mwc> how is an OO MUD different than any other MUD I've heard vaguely about
13:52:43 <eivuokko> Maybe MUD means something else on that context.
13:52:55 <mwc> It would have to.
13:52:57 <SamB> mwc: the potential to have players writing objects?
13:53:03 <mwc> @foldoc MUD
13:53:05 <lambdabot> *** "mud" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
13:53:05 <lambdabot> MUD
13:53:05 <lambdabot>  
13:53:05 <lambdabot>    <games> {Multi-User Dimension} or "Multi-User Domain".
13:53:05 <lambdabot>    Originally "Multi-User Dungeon".
13:53:06 <Cale> mwc: MUDs are usually primarily based on dungeons and fighting, whereas there are more abstract sorts of games
13:53:07 <lambdabot> [5 @more lines]
13:53:11 <Korollary> I think there's such a game.
13:53:14 <mwc> Cale, ahhhh
13:53:20 <mwc> Makes sense now, kind of
13:53:32 <Cale> MUSH -> Multi-user shared hallucination
13:53:32 <mwc> Lemmih, thatnks for the help earlier, runtime from 1.18s to 0.245
13:53:52 <Cale> A MOO is an OO MUSH
13:54:16 <Cale> Many of them allow users to create new rooms and devices
13:54:17 * SimonRC goes to eat
13:54:36 <SamB> A normal application is just an H
13:54:48 <Cale> it would be neat to see a MUSH in which one could write code in Haskell to compose rooms :)
13:54:53 <SamB> and a pretty bad one at that
13:55:09 <Cale> SamB: heh
13:55:31 <Cale> unless it's a fractal program with palette colour cycling
13:55:33 * SamB wonders for the nth time why his gopher slates are broken
13:56:00 <palomer> MOO is a combination MUD and programming language
13:56:17 <mwc> Ahhh
13:56:27 <mwc> So we need to write a room combinator
13:56:48 <docl> MOO is cool :)
13:56:56 <SamB> even if you don't have the programmer bit, you can use other people's objects...
13:57:24 <SamB> not that it isn't MFP, but rather MOO. there is a reason for this.
13:57:50 <shapr> pesco: Don't think so
13:57:51 <shapr> vincenz: hiya
13:58:25 <SamB> so who thinks we should have a MOO?
13:59:51 * SamB wonders how hard it would be to integrate a MOO with IRC...
14:00:21 <docl> that would be cool
14:00:59 <SamB> you'd have to set things up with Freenode so they'd let you have a massive number of connections from the same IP, of course
14:01:32 <_|_kid_lambda^> hrm, interesting didn't know GHC had an extension to support dynamic binding
14:02:50 <SamB> actually, it probably wouldn't be all that usefull to integrate MOO and IRC
14:03:23 <Korollary> I thought @karma was some kind of a game.
14:03:51 <SamB> @karm me
14:03:52 <lambdabot> Maybe you meant: karma karma+ karma-
14:04:05 <SamB> @karma me
14:04:05 <lambdabot> me has a karma of 1
14:04:20 <SamB> @karma+ Parsec
14:04:20 <lambdabot> Parsec's karma raised to 1.
14:04:29 <palomer> @karma+ palomer
14:04:31 <lambdabot> You can't change your own karma, silly.
14:04:35 <palomer> @karma palomer
14:04:36 <lambdabot> You have a karma of 0
14:04:41 <palomer> @karma dons
14:04:42 <lambdabot> dons has a karma of 21
14:04:46 <palomer> @karmo samb
14:04:46 <jyp> lol
14:04:47 <lambdabot> samb has a karma of 0
14:04:53 <palomer> eh?
14:04:55 <palomer> it corrects typos?
14:04:56 <SamB> @karma+ palomer
14:04:57 <lambdabot> palomer's karma raised to 1.
14:04:59 <palomer> yay!
14:05:02 <palomer> @karma+ samb
14:05:03 <lambdabot> samb's karma raised to 1.
14:05:05 <SamB> @karma SamB
14:05:06 <lambdabot> You have a karma of 9
14:05:15 <palomer> @karmo samb
14:05:16 <lambdabot> samb has a karma of 1
14:05:25 <palomer> oh, it's case sensitive
14:05:31 <palomer> that isn't right
14:05:32 <SamB> @karma- samb
14:05:32 <jyp> @viken =<< quote dons
14:05:33 <lambdabot> samb's karma lowered to 0.
14:05:33 <lambdabot> do you trust the government?
14:05:42 <SamB> no, it isn't
14:05:55 <SamB> @quote dons
14:05:55 <lambdabot>  but let is more lazy ;)
14:06:19 <SamB> @vixen   but let is more lazy ;)
14:06:20 <lambdabot> Ok
14:06:34 <mwc> I have a theoretical question about building lists. Is building a string using ++ to append in a recursive setting good? See the IRC paste page for example> http://www.haskell.org/hawiki/HaskellIrcPastePage
14:06:58 <Lemmih> @. vixen keal
14:06:58 <lambdabot> You think this is a botiecall??
14:07:11 <boegel|home> I'm glad to see some real effort is put into the next Haskell standard...
14:07:22 <Cale> mwc: you shouldn't append lots of small bits to the right side of the list
14:07:27 <jyp> hey boegel
14:07:32 <boegel|home> yo jyp
14:07:33 <lispy> does ghc mmap files when you open them?
14:07:34 <mwc> Hmm, should I try building the list to the left?
14:07:55 <palomer> ghc should have a compiler optimization where it makes accessing the tail of a list a constant time operation
14:08:05 <Korollary> mwc: for appending strings, ShowS is better.
14:08:20 <mwc> Lemmih was telling me that showString is just ++
14:08:21 <palomer> err, the tail reference
14:08:24 <SamB> mwc: building a list backwards and reversing is better than appending to the end...
14:08:24 <lispy> palomer: really?  what about [1..] ?
14:08:32 <boegel|home> jyp: had any fun with raytracing-related stuff lately ?
14:08:42 <palomer> lispy: it wouldn't apply the optimization always
14:08:55 <jyp> boegel|home: no :/
14:08:56 <lispy> palomer: how would it know when it's safe?
14:09:00 <Korollary> mwc: It acts like ++, but it actually composes functions that return strings, so no strings are concatenated.
14:09:16 <palomer> lispy: it would some some smart heuristic
14:09:27 <palomer> anyways, if you care about performance, use fast packed strings
14:10:04 <Lemmih> Korollary: mwc was using 'showString' to concatenate strings. Ie. "str1" `showString` "str2".
14:10:10 <jyp> speaking of performance, has anyone tried Jhc lateley
14:10:14 <jyp> ?
14:10:39 <Lemmih> mwc: Using 'showString' like that doesn't buy you anything.
14:10:54 <mwc> Huh? how should I be using it?
14:10:58 <Lemmih> mwc: You should generate ShowS and concatenate them with (.).
14:11:12 <jyp> @seen JohnMeacham 
14:11:13 <lambdabot> JohnMeacham is in #haskell-blah and #haskell. Last spoke 22 hours, 18
14:11:13 <lambdabot> minutes and 36 seconds ago.
14:11:27 <mwc> Lemmih, as an example? str1 ++ str2 ++ str3 becomes...
14:11:39 <SamB> Lemmih: isn't there another name for (.) :: ShowS -> ShowS -> ShowS ?
14:11:43 <Lemmih> > showString "hello " . showChar ':' . showString " world" $ []
14:11:45 <lambdabot> "hello : world"
14:12:35 <Lemmih> mwc: Do you see why ("str1"++"str2")++"str3" is a lot less efficient than "str1"++("str2"++"str3")?
14:12:41 <mwc> ah, I see. before I was using showString "hello" $ showString ":" $ showString " World" \n"
14:12:41 <palomer> how do I find out the prefedence of an operator in haskell?
14:12:45 <mwc> Lemmih, yes
14:13:07 <Korollary> palomer: in the report, the modules list them.
14:13:53 <palomer> I mean in ghci
14:14:10 <SamB> palomer: :i (++)
14:14:14 <SamB> or is it :i ++
14:14:22 <palomer> ahh, I see
14:14:28 <boegel|home> jyp: no problem, neither have I
14:14:28 <palomer> @index (++)
14:14:29 <lambdabot> Data.List, Prelude
14:14:37 <SamB> very useful feature ;-)
14:14:39 <palomer> @index Prelude.(++)
14:14:40 <lambdabot> bzzt
14:14:44 <palomer> @index Prelude.++
14:14:45 <lambdabot> bzzt
14:14:55 <jyp> @index ++
14:14:55 <lambdabot> Data.List, Prelude
14:15:21 <SamB> @docs Prelude
14:15:21 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
14:15:55 <Lemmih> mwc: Before you were using "foldl (++) [] strings". 'foldl (++) [] [a,b,c]' => ((a++b)++c)++[].
14:16:15 * SamB wonders if he has a blackbelt yet
14:16:38 <SamB> concat works fairly well
14:17:06 <SamB> @type concat
14:17:08 <lambdabot> forall a. [[a]] -> [a]
14:17:37 * SamB thinks he only has a brown belt
14:20:38 <SamB> is #haskell still half newbies?
14:20:48 <lispy> i'm half newbie
14:22:08 <palomer> what's the prededence of application?
14:22:19 * palomer thinks application should be an operator like any other
14:22:22 <lispy> functions, then other stuff
14:22:38 <palomer> app : (a->b) -> a -> b
14:22:39 * SamB hands palomer a pile of $s
14:22:57 <Lemmih> @type ($)
14:22:58 <lambdabot> forall b a. (a -> b) -> a -> b
14:23:06 <SamB> app is a different function
14:23:09 <Heffalump> palomer: that doesn't work, it leaves you without any root to base precedence on
14:23:11 <SamB> maybe
14:23:16 <SamB> @hoogle app
14:23:17 <lambdabot> Control.Arrow.app :: ArrowApply a => a (a b c, b) c
14:23:17 <lambdabot> Data.PackedString.appendPS :: PackedString -> PackedString -> PackedString
14:23:17 <lambdabot> Data.Ratio.approxRational :: RealFrac a => a -> a -> Rational
14:23:18 <lispy> @type Control.Monad.ap
14:23:19 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
14:23:34 <dcoutts> @seen gour
14:23:35 <lambdabot> I saw gour leaving #haskell 1 hour, 52 minutes and 9 seconds ago.
14:23:37 <lispy> @type Control.Monad.liftM2 (.)
14:23:38 <Heffalump> oh, actually, I suppose it might work. Confusing if someone changes it, though.
14:23:38 <lambdabot> forall b c a (m :: * -> *).
14:23:38 <lambdabot> (Monad m) =>
14:23:38 <lambdabot> m (b -> c) -> m (a -> b) -> m (a -> c)
14:23:48 <palomer> yes, but app should work for regular values too
14:23:59 <palomer> like, I should be able to redefine ( )
14:24:06 <lispy> i thought ap was just lifted .
14:24:43 <lispy> @type ( )
14:24:45 <lambdabot> ()
14:24:53 <palomer> right, ( ) is just nil
14:25:06 <SamB> what?
14:25:08 <lispy> i thouht [] was nil
14:25:12 <palomer> err, I meant unit
14:25:20 <SamB> I didn't know you could put anything between the parens!
14:25:22 <palomer> oh, but then you'd need application to apply app
14:25:48 <lispy> what is strace called on osx?
14:25:54 <lispy> er..i'll google it
14:25:55 <dcoutts> @seen SyntaxNinja
14:25:56 <lambdabot> I saw SyntaxNinja leaving #haskell and #haskell-blah 1 day, 20 hours, 23
14:25:56 <lambdabot> minutes and 21 seconds ago.
14:26:28 <lispy> ktrace, apparantly
14:28:15 <lispy> hmm..yes i do think ghc uses mmap to open files
14:28:46 <lispy> or wait, no
14:28:53 <lispy> it uses mmap, but maybe not for opening the file
14:34:14 <ksandstr> am I right that haddock doesn't support n+k patterns or template haskell? I just had it produce parse errors on both. if there's some option I've missed, I'd quite like to know of it...
14:35:17 <musasabi> ksandstr: #ifndef __HADDOCK__ is your friend.
14:35:45 * dcoutts thinks haddock should be based on GHC's parser
14:37:37 <ksandstr> ugh. I guess I'll just use the haddock-style comments and hope for something more ghc-complete in the future :)
14:39:14 <xerox> Do you happe to know why OCaml has only 'type' ?
14:39:17 <xerox> *happen
14:39:28 <xerox> (While Haskell has both data, type, and newtype)
14:39:56 <dcoutts> newtype and data are basically the same
14:40:09 <jyp> well, newtype and data become the same in a strict context
14:40:11 <Heffalump> doesn't OCaml have datatype ?
14:40:26 <Heffalump> jyp: YM if there are no bottom values anywhere?
14:40:42 <xerox> dcoutts: yes
14:40:50 <jyp> YM?
14:40:54 <Heffalump> "you mean"
14:40:54 <lispy> you mean
14:41:23 <xerox> dcoutts: what about Haskell's data & type vs. Ocaml's type?
14:41:36 <jyp> yes.
14:41:59 <dcoutts> xerox, I'm not sure, but I think ocaml must have a way of distinguishing type aliases from constructed data types
14:42:32 <dcoutts> but it may well distinguish some way other than by using a different keyword
14:42:58 <jyp> Heffalump: or rather, haskell's newtype become pointless when there are no bottoms.
14:43:41 <Heffalump> agreed
14:43:44 <dcoutts> jyp, nice pun
14:44:01 <dcoutts> except that newtype is already pointless
14:44:04 <jyp> unintended... :)
14:44:19 <Heffalump> dcoutts: in what way is it pointless?
14:44:22 <dcoutts> in fact the whole point of new type is that it's pointless :-)
14:44:29 * boegel|home leaves for bed
14:44:32 <boegel|home> g'night everyone !
14:44:36 <lispy> boegel|home: night
14:44:38 <dcoutts> it doesn't introduce an extra bottom element
14:44:47 <Heffalump> ah, in the sense of pointed domains
14:44:49 <tromp> @weather
14:44:50 <lambdabot> Unknown command, try @listcommands.
14:44:50 <dcoutts> right
14:44:57 <tromp> @forecast
14:44:58 <lambdabot> Unknown command, try @listcommands.
14:44:59 <Heffalump> as opposed to pointfree code
14:45:08 <dcoutts> yeah
14:45:29 <dcoutts> Heffalump, you should have taken domain theory! :-)
14:47:08 <Heffalump> s'ok, I like being ignorant ;-)
14:50:34 <phys_rules> just tried ruby's IDE, FreeRIDE, darn it's slow, I bet a haskell IDE would be way faster %)
14:58:49 <Lemmih> IDE will be superfast!
14:58:52 <Lemmih> *HIDE
15:00:34 <phys_rules> HFast IDE 
15:00:35 <phys_rules> hehe
15:01:08 <lispy> it will be super fast it just won't compile ;)
15:01:13 <phys_rules> hehe
15:02:50 <phys_rules> well, I think hide is not that important at the moment, it's more important to improve yi (add complete syntax highlighting, smart identation, search, code folding)
15:03:08 <phys_rules> then follows the completion/smart completion, on-fly code check, snippets, 
15:03:55 <jyp> exactly
15:04:21 <lispy> long live Yi!
15:05:56 * edwinb is bored so investigates Yi
15:07:22 <edwinb> hacking emacs lisp has become too much pain
15:07:48 <xerox> Fiddling with haskell-mode?
15:08:08 <edwinb> no, just fiddling with anything is painful...
15:08:19 <edwinb> I was hacking proof-general but I got fed up.
15:21:09 <jethr0> ls
15:21:44 <edwinb> dependency fps-any ought to be satisfied by fps-0.1, oughtn't it?
15:22:27 <edwinb> oh, never mind, I'd forgotten --user...
15:24:49 <NoobLuck> sip
15:25:00 <Selu> joder
15:25:11 <NoobLuck> > "X" ++ "D"
15:25:13 <lambdabot> "XD"
15:25:21 <Selu> xD
15:25:23 <NoobLuck> > "X" ++ repeat "D"
15:25:24 <lambdabot> Couldn't match `Char' against `[Char]'
15:25:31 <NoobLuck> > "X" ++ repeat 'D'
15:25:33 <lambdabot> "XDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD
15:25:33 <lambdabot> DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD
15:25:33 <lambdabot> DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD
15:25:33 <lambdabot> DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD
15:25:33 <lambdabot> DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD
15:25:33 <JohnMeacham> jyp: I have. didn't work. :) (I am in the middle of changing it)
15:25:35 <lambdabot> [23 @more lines]
15:25:36 <Selu> putos freks
15:25:36 <NoobLuck> jajaj
15:25:44 <NoobLuck> es lambdabot
15:25:56 <NoobLuck> tb haskell.es
15:26:14 <Heffalump> sorry?
15:26:20 <NoobLuck> sorry
15:26:33 <Selu> a fuckin' n00b
15:26:39 <NoobLuck> not talking in channel language
15:26:54 <NoobLuck> yeah
15:27:17 <palomer> @hoogle concat
15:27:18 <lambdabot> Data.List.concat :: [[a]] -> [a]
15:27:18 <lambdabot> Prelude.concat :: [[a]] -> [a]
15:27:18 <lambdabot> Data.List.concatMap :: (a -> [b]) -> [a] -> [b]
15:27:27 <Selu> i don't like haskell
15:27:48 <palomer> how do you copy a list n times?
15:28:08 <Heffalump> @type \n -> concat . repeat n
15:28:09 <lambdabot>   Expecting a function type, but found `[a]'
15:28:09 <lambdabot>   Expected type: a1 -> [[a]]
15:28:10 <Selu> list.copy(n)
15:28:28 <Heffalump> @type repeat 5
15:28:30 <lambdabot> forall a. (Num a) => [a]
15:28:30 <Selu> in a objected-oriented languaje
15:28:31 <dcoutts> @type cycle
15:28:33 <lambdabot> forall a. [a] -> [a]
15:28:34 <tromp> you mean replicate
15:28:38 <Heffalump> oh, duh.
15:28:46 <dcoutts> > take 50 $ cycle "foo"
15:28:48 <lambdabot> "foofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofo"
15:29:02 <Heffalump> I'm always getting those two confused.
15:29:07 <NoobLuck> i think lisp is a better language
15:29:27 <Selu> or assembly
15:29:31 <NoobLuck> lol
15:29:37 <Selu> it's tons faster
15:29:43 <Selu> and easier
15:29:50 <Heffalump> well, I think the untyped lambda calculus is better, but we can't have everything
15:30:05 <dcoutts> SKI!
15:30:14 <Heffalump> X!
15:30:14 <tromp> just S and K
15:30:31 <NoobLuck> i prefer typed languages
15:30:40 <dcoutts> NoobLuck, like lisp ?
15:30:41 <tromp> you mean X = <S,K,S> ?
15:30:44 <NoobLuck> no
15:30:48 <Selu> or ocaml
15:30:55 <Heffalump> tromp: I can't remember the definition
15:31:02 <NoobLuck> ii don not knoow
15:31:03 <Heffalump> but you end up with S = X(XX) and K = XXX
15:31:05 <Heffalump> or vice versa
15:31:08 <NoobLuck> i only know haskell
15:31:35 <Selu> haskell is like hasecorp
15:32:29 <tromp> XX = <S,K,S> S K S = S S K S K S = S K S S = S
15:32:46 <Selu> Scheie
15:33:15 <palomer> iota!
15:33:56 <tromp> no, it was X = <K,S,K>
15:34:15 <Heffalump> what does <K,S,K> mean?
15:34:17 <tromp> then XX = KK, XXX = K , X(XX) = S
15:34:40 <tromp> <a,b,c,...> = \x. x a b c ...
15:34:46 <Heffalump> ah
15:35:12 <tromp> cons x y = <x,y>
15:36:59 <tromp> trolls these days have no stamina
15:37:25 <tromp> even unfed, you'd think they can last hours
15:37:29 <palomer> @hoogle replicate
15:37:30 <lambdabot> Data.List.replicate :: Int -> a -> [a]
15:37:30 <lambdabot> Prelude.replicate :: Int -> a -> [a]
15:37:30 <lambdabot> Control.Monad.replicateM :: Monad m => Int -> m a -> m [a]
15:37:58 <palomer> concat (replicate 5 "-/|\")
15:38:01 <palomer> > concat (replicate 5 "-/|\")
15:38:02 <lambdabot>  lexical error in string/character literal
15:38:11 <palomer> > concat (replicate 5 "-/|\\")
15:38:13 <lambdabot> "-/|\\-/|\\-/|\\-/|\\-/|\\"
15:38:19 <palomer> grr
15:38:42 <palomer> > concat (replicate 5 "._-")
15:38:43 <lambdabot> "._-._-._-._-._-"
15:38:48 <palomer> fun with patterns!
15:39:07 <Heffalump> yeah, that was a particularly inept bit of trolling
15:39:21 <Korollary> *I* can do better
15:39:33 <edwinb> it's more fun when they at least pretend to argue
15:39:44 <jonkri> if i have a data type that is defined as "data Tree = Empty | Root Tree Tree", how can i create a variable "left" of that type?
15:39:52 <tromp> [c|_<-[1..5],c<-"._-"]
15:40:02 <tromp> > [c|_<-[1..5],c<-"._-"]
15:40:04 <lambdabot> "._-._-._-._-._-"
15:40:40 <tromp> > [1..5] >> "._-"
15:40:42 <lambdabot> "._-._-._-._-._-"
15:40:50 <tromp> :-)
15:40:53 <Korollary> jonkri: what do you mean by 'left' ?
15:41:07 <jonkri> Korollary, oh, that's just the name of the variable. could be anything
15:41:24 <palomer> > concat (replicate 5 "!-+")
15:41:26 <lambdabot> "!-+!-+!-+!-+!-+"
15:41:34 <Heffalump> my _real_ opinions on Haskell generate more controversy than that lot did
15:41:47 <Korollary> jonkri: you can have "x = Empty", or "x = Root Empty Empty", etc.
15:42:28 <jonkri> Korollary, thanks
15:42:28 <NoobLuck> really
15:42:29 <Korollary> Heffalump: They didn't have opinions.
15:42:33 <SamB> Heffalump: which are what? "(.) should be removed?"
15:42:34 <jonkri> Korollary, so i don't have to specify what type it is?
15:42:37 <NoobLuck> writting an application
15:42:45 <SamB> that is the only controversial opinion I can think of...
15:42:57 <Korollary> jonkri: No, you don't need to annotate.
15:43:00 <NoobLuck> haskell does something better than an imperative low-level language?
15:43:10 <palomer> is green!
15:43:31 <jonkri> Korollary, but if i want to?
15:43:40 <Heffalump> mainly about Haskell not being suitable for many applications
15:43:58 <SamB> Heffalump: I'd tend to agree.
15:43:59 <NoobLuck> so for what is used haskell?
15:44:00 <Korollary> jonkri: You can if you want to. "x :: Tree".  next line: "x = ..."
15:44:03 <NoobLuck> mostly
15:44:08 <SamB> for instance, it would suck at MOO scripting.
15:44:27 <Heffalump> oh, I actually think it'd be an excellent scripting language
15:44:33 <jonkri> Korollary, ah, thanks
15:44:34 <palomer> I think you're nuts!
15:44:34 <Korollary> I use it like a scripting language
15:44:50 <palomer> scripting=sloppy=state
15:44:52 <Heffalump> but I think it's a poor choice for any application where performance is critical
15:44:59 <Heffalump> that's what monads are for :-)
15:44:59 <NoobLuck> yes
15:45:12 <Heffalump> s/excellent scripting language/excellent embedded scripting language/
15:45:28 <Heffalump> define an appropriate monad, and your scripts use operations from that monad along with the full power of Haskell
15:45:39 <SamB> Heffalump: yes, but for a MOO...
15:45:52 <Heffalump> because of the OOness?
15:45:59 <SamB> well, you kinda want an object oriented language, if you know what I mean ;-)
15:46:25 <SamB> yes, because of the OOness.
15:46:31 <Heffalump> do MOOs make a lot of use of inheritance and such like?
15:46:53 <SamB> a fair bit, yes
15:47:00 <Heffalump> you can get quite a lot of OO-like behaviour with type classes and records, say
15:47:03 <edwinb> for how many people is performance critical these days?
15:47:15 * edwinb is absent from the 'real' world.
15:47:18 <Heffalump> edwinb: well, the entire industry I work in :-)
15:47:26 <Heffalump> (embedded stuff)
15:47:30 <edwinb> Hmm
15:47:57 <edwinb> haskell is perhaps less suitable for that. you want hume ;)
15:48:07 <Korollary> It's critical for me
15:48:30 <Korollary> but haskell's got a nice ffi interface.
15:48:38 <Heffalump> darcs is a good example of why it has problems even with mainstream applications
15:48:55 <Heffalump> it requires experts to sort out the scaling problems it has, and even then they're not fully solved
15:49:04 * docl knows of a python-based MOO
15:49:11 <Korollary> I would recommend haskell for projects that are algorithmically very complicated but perhaps not that performance critical.
15:49:19 <Heffalump> Korollary: right
15:49:26 <edwinb> yes, I'd agree with that.
15:49:28 <dcoutts> Heffalump, is that because of lazyness or just because people are doing complex things they don't fully understand?
15:49:37 <SamB> Heffalump: but aren't RCSes pretty difficult anyway?
15:49:46 <jonkri> i have "height Empty = 0" and "height (Root left right) = max(height(left) height(right)) + 1", left and right are both set to empty. why do i get an error? "*** Does not match : a -> b -> c -> d"
15:49:47 <Heffalump> the space problems are an issue with Haskell, IMO.
15:49:58 <jonkri> i just want to take the highest of left and right and add 1
15:50:00 <Heffalump> laziness means it's very hard to understand what the memory behaviour will be
15:50:30 <Heffalump> commutation is something that is nothing to do with Haskell, and indeed Haskell offers a lot of language features that may be useful in coming up with a solution
15:50:31 <tromp> use max (height left) (height right)
15:50:42 <edwinb> sometimes I think having laziness as the default isn't such a good idea...
15:50:54 <Heffalump> well, the Simons think that too :-)
15:51:00 <jonkri> tromp, thanks, but what if i wouldn't want height right to be an argument to max?
15:51:02 <edwinb> so I've gathered.
15:51:15 <edwinb> it's very handy sometimes, but I tend to know when, so I wouldn't mind making it explicit.
15:51:20 <Korollary> jonkri: it is. In haskell, fun args are not within parens.l
15:51:30 <dcoutts> what's the alternative? One would have to explicitly delay but not explicitly force?
15:51:30 <Heffalump> same here.
15:51:44 <tromp> then dont use max:)
15:51:45 <tromp> \
15:51:45 <jonkri> Korollary, never?
15:51:45 <Heffalump> dcoutts: probably mark data structures
15:51:56 <edwinb> much the same as marking things strict, but the other way around...
15:51:58 <dcoutts> Heffalump, we can already do that
15:52:01 <SamB> hmm, yes. that is true.
15:52:08 <Korollary> jonkri: If f takes two arguments, you write "f x y".
15:52:19 <jonkri> Korollary, ok
15:52:26 <jonkri> Korollary, new error: "*** Does not match : (Tree -> Integer) -> Tree -> a"
15:52:29 <Heffalump> I still haven't found a way of making a strict Map..
15:52:36 <jonkri> Korollary, height (Root left right) = max height(left) height(right) + 1
15:52:46 <NoobLuck> ok
15:52:56 <tromp> use max (height left) (height right)
15:52:58 <NoobLuck> scripting language
15:52:59 <Korollary> jonkri: you're still parenthesizing the arg to height. Use max (height left) ..
15:53:05 <NoobLuck> but can make posix calls
15:53:08 <dcoutts> Heffalump, ok, it's harder with abstract data types, but you can do it for any concrete data type
15:53:09 <jonkri> oh, sorry
15:53:16 <NoobLuck> and a lot of things
15:53:48 <Heffalump> I don't have a complete picture of the right design.
15:53:56 <NoobLuck> bye
15:53:59 <NoobLuck> sleep
15:54:03 <Korollary> Heffalump: Is there a limit to the strictness analyses ghc can perform? I don't like lazy evaluation leading to unevaluated space waste, either.
15:54:14 <Heffalump> much of the problem I have with marking things strict is that it turns out that either the contained things or the containing things are not strict.
15:54:34 <Heffalump> Korollary: well, it's (I assume) an undecidable problem, so there must be some limit.
15:54:55 <dcoutts> yes, it's equivalent to the halting problem in the end
15:55:03 <Heffalump> I'd be very surprised if it analyses a whole program to see that every use of a data structure is strict so it might as well mark some fields strict.
15:55:06 <dcoutts> but you can do a good job in many cases
15:55:17 <dcoutts> and better than ghc does no I think
15:55:19 <Heffalump> which is often where the biggest gains are to be had from manual annotation
15:55:21 <dcoutts> onow
15:55:55 <dcoutts> Jhc might be able to do that kind of whole prog analysis eventually
15:56:04 <jonkri> i have "left = Empty", "right = Empty", "height Empty = 0", "height (Root left right) = max (height left) (height right) + 1" and when i type "height Root left right" i get this error: "*** Does not match : a -> b -> c -> d". i would want the result to be 1
15:56:28 <Heffalump> height (Root left right)
15:56:36 <jonkri> oh
15:56:37 <Heffalump> the application operator associates to the left
15:56:47 <Heffalump> it thought you were trying to call height with three arguments, Root, left and right.
15:56:57 <jonkri> thanks Heffalump 
15:58:30 <jonkri> it works now, thanks a lot all! :-)
15:59:19 <SamB> hmm, perhaps there should be a dialect called "Strict Haskell" :->
15:59:50 <Heffalump> I suspect it will also be necessary to mark functions strict, TICBW.
16:00:01 <Heffalump> Perhaps someone should make a strict set of libraries.
16:00:03 <SamB> JHC might be able to decide that a particular instance of a constructor can always be strict, too...
16:00:06 <Heffalump> and see how far we can get with those
16:00:29 <dcoutts> I think better feedback from the compiler about what is strict and why would be good
16:00:43 <Korollary> yes
16:00:51 <dcoutts> a tool that helps people to understand the dependencies in the order of evaluation
16:00:52 <Korollary> + ide interaction heh
16:01:04 <jonkri> good night
16:01:08 <Heffalump> the fundamental problem, even with such help, is that it is still hard to understand what's going on.
16:01:23 <Heffalump> compared to languages where you have to handle all this stuff explicitly
16:01:50 <Korollary> I expect a true haskell ide to do a lot of eval's, expansions, etc.
16:05:44 <JohnMeacham> dcoutts: actually, it sort of can. it can 'flatten' certain data types if they always contain the same value, like an evaluated Int. this is done deep in Grin though.
16:06:05 <dcoutts> JohnMeacham, interesting
16:06:29 <dcoutts> JohnMeacham, at kind of strictness analysis does JHC use generally?
16:06:37 <dcoutts> at/what
16:06:43 <JohnMeacham> dcoutts: which is effectivly the same transformation, at a much lower level
16:07:20 <JohnMeacham> dcoutts: right now, just a basic abstract interpretation similar to ghc's. I hope to replace it with the HORN-clause based verson.
16:07:38 <pesco> Ah, JohnMeacham, I had a slight problem getting jhc compiled on Linux-PPC. I think the linker chocked on a relocation. Any idea whether this can be side-stepped somehow?
16:08:12 <JohnMeacham> pesco: no idea off the top of my head. it should be portable, so it is a bug if it isn't.
16:08:34 <pesco> JohnMeacham: I'm suspecting GHC actually. Probably a very large binary or something.
16:08:46 <dcoutts> JohnMeacham, so is the HORN-clause based analysis a whole program analysis?
16:10:15 <pesco> JohnMeacham: Oh, and I had a look at your definition of the Array module. Please don't tell me JHC turns [v | (j,v) <- xs, j==i] into constant-time lookup! :-0
16:10:35 <JohnMeacham> dcoutts: no. 
16:10:52 <JohnMeacham> dcoutts: only my grin analysis are whole-program.
16:12:16 <dcoutts> So strictness anlysis is basically finding the dependencies between the output value of a function and its inputs right?
16:12:52 <dcoutts> it seems awfully close the analysis that I'm working on
16:13:30 <dcoutts> which is a binding time analysis
16:19:51 <Heffalump> I expect it is quite close.
16:20:58 <stepcut> my freebsd boxs appears to be randomly crashing between 3:04 and 3:07 every few days
16:21:17 <dcoutts> stefanw, a cron job?
16:22:07 <dcoutts> stefanw, check what cron jobs you have that are kicked off at 3:00
16:22:08 <stepcut> I am thinking that may be when updatedb runs
16:22:25 <dcoutts> and updatedb is pretty hard on the file system
16:22:42 <dcoutts> it could trigger a kernel bug I guess
16:22:58 <stepcut> no, I have been running this same version for several years now
16:23:02 <stepcut> I suspect hard drive failure 
16:23:23 <edwinb> could it be a memory problem?
16:23:26 <Korollary> those wouldn't be that accurate on the clock
16:23:54 <stepcut> Korollary: oh? I figure if there is a bad sector that is only hit by updatedb...
16:23:55 <edwinb> they would if there was heavy system activity at that time...
16:24:10 <Korollary> stepcut: ah. yes.
16:25:46 <stepcut> hrm, it appears that is around when the daily crontab is run
16:26:00 <stepcut> well, I better do a backup or something :p
16:26:48 <stepcut> I looks like all my important data should fit on 1-2 dvds
16:28:29 <stepcut> whoa, google took a big drop this week
16:28:41 <Korollary> the stock market bogus
16:37:53 <palomer> hrm, type inference with references doesn't scale
16:37:59 <palomer> this sucks
16:42:47 <lispy> palomer: example?
16:43:40 <palomer> scaling in the sense of adding features
16:44:10 <lispy> now i'm even more lost...
16:44:48 <palomer> I'm doing type inference with generalised algebraic datatypes
16:45:02 <lispy> okay
16:45:24 <palomer> so my inference algorithm has to return many types
16:45:32 <palomer> if I'm using references, this doesn't work
16:45:54 <lispy> many types or many kinds?
16:46:26 <palomer> no, many types
16:47:13 <lispy> alright.  i'll admit, i don't understand GADTs nearly as well as i'd like to
16:47:58 <palomer> GADT type inference is being dominated by that wobbly types paper
16:48:00 <palomer> which is pure crap
16:48:03 <palomer> ok, not pure crap
16:48:07 <palomer> but you can do much better
16:49:03 <Heffalump> don't they have a better version now?
16:49:33 <palomer> Heffalump: better version of the paper or a better paper?
16:49:40 <Heffalump> a better way of doing the inference
16:49:40 <palomer> there is a newer, better paper by some french guys
16:50:02 <palomer> Heffalump: links?
16:50:42 <palomer> Saulzmann (sp?) is the closest to something sane
16:51:23 <Heffalump> ah, no, it's still wobbly types, just simplified.
16:51:35 <palomer> oh, the newer webbly types paper
16:51:40 <palomer> s/webbly/wobbly
16:53:05 <palomer> grr
16:53:43 <palomer> anyways, anyone know how to do unification in the presence of disequalities?
16:54:07 <Heffalump> errm, is that possible?
16:54:10 <Heffalump> (decidably)
16:54:16 <astrolabe> Where does 'find' live?
16:54:26 <palomer> Heffalump: why wouldn't it be?
16:54:49 <Heffalump> hmm. No reason, I guess.
16:55:13 <Heffalump> can't you just propagate the disequalities around and abandon solutions that introduce a contradiction?
16:55:48 <dcoutts> palomer, do you mean subtyping?
16:56:03 <astrolabe> Ah Data.List 
16:56:29 <palomer> dcoutts: err no, you have a set of equations, each equation of the form  t = t' or t != t'
16:56:45 <dcoutts> palomer, oh ok that's different then
16:57:18 <dcoutts> I'm working on an algorithm that deal with inequalities between type variables. In the case of all == rather than <= it degenerates to normal HM type inference.
16:57:51 <palomer> yeah, these are inequalities
16:58:20 <Heffalump> so why do you have disequalities?
16:58:26 * dcoutts thinks of inequalities as being <=, >=
16:58:34 <olliej> oh... i might finally get ghc.show to compile...
17:00:10 <palomer> woops, no inequalities
17:00:12 <palomer> just disequalities
17:00:35 <JohnMeacham> pesco: no, jhc doesn't do arrays yet. I am still trying to come up with a suitable set of primitives.
17:00:56 <pesco> JohnMeacham: oic, interesting.
17:02:13 <JohnMeacham> pesco: I just copied it right out the report. a lot of the libraries can be improved a whole lot actually, most are just the exact report definitions. I have not gone through fixing them yet because there are other areas that are hurting performance more.
17:02:32 <pesco> JohnMeacham: I see.
17:03:02 <JohnMeacham> pesco: of course, arrays are just a joke at the moment. feel free to suggest some good primitives. mainly I don't want to make lists a part of the interface because that is too high level for a primitive.
17:03:21 <JohnMeacham> pesco: I am thinking something continuation based.. hmm..
17:03:47 <pesco> JohnMeacham: Does it still suffer from space leaks? I have a program with a very tight loop (matrix-vector mult and friends). Is it still worth it to try to get jhc compiled?
17:04:34 <Heffalump>           joined #darcs
17:04:36 <Heffalump> oops, sorry
17:04:59 <palomer> grrr, this unification problem is driving me nuts
17:05:14 <Heffalump> http://research.microsoft.com/Users/simonpj/papers/not-not-ml/index.htm
17:05:17 <Heffalump> is what I was trying to post.
17:05:27 <Heffalump> on the subject of laziness+strictness.
17:05:54 <JohnMeacham> pesco: well, the boehem GC is not really good enough to catch all the leaks. it is possible the loop can be compiled to a nice tight C-esque loop. you'd have to look at the grin or generated C though to be sure.
17:06:12 <pesco> JohnMeacham: Okay, I'll give it another go.
17:07:20 <pesco> What exactly do you mean by array primitives? An interface for the user like MArray and IArray? Or low-level stuff that's supposed to be hidden?
17:07:48 <JohnMeacham> Heffalump: very interesting. though I much much prefer monadic to CPS. I'll have to read it to see if it can be reformulated.
17:08:04 <dcoutts> JohnMeacham, buildArraySequential :: (a -> (b, a)) -> b -> Arr a
17:08:09 <JohnMeacham> pesco: low level stuff that is hidden.
17:08:25 <palomer> monadic IS CPS
17:08:41 <Cale> palomer: not necessarily
17:08:46 <palomer> @hoogle Monad
17:08:47 <lambdabot> Control.Monad.Monad :: Monad m
17:08:47 <lambdabot> Prelude.Monad :: Monad m
17:08:47 <lambdabot> Control.Monad.Fix.MonadFix :: Monad m => MonadFix m
17:08:54 <JohnMeacham> palomer: I know (more or less). but presentation and terminology are everything :)
17:08:58 <palomer> @hoogle (>==)
17:08:59 <lambdabot> No matches found
17:09:21 <palomer> Cale: show me an instance where ==<  doesn't take a continuation
17:09:24 <JohnMeacham> dcoutts: hmm.. I don't quite understand. but looks interesting.
17:09:26 <palomer> @hoogle (==<)
17:09:28 <lambdabot> No matches found
17:09:42 <Cale> @type (>>=)
17:09:44 <dcoutts> JohnMeacham, it's like unfoldr :: (a -> Maybe (b,a)) -> a -> [b]
17:09:44 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
17:09:54 <Jaen> hmm, monads seem almost like CPS, but with apply replaced with >>=, or what do you think?
17:10:04 <dcoutts> JohnMeacham, but you don't need the Maybe since we know in advance the length of the array
17:10:15 <JohnMeacham> dcoutts: ah. should that b be an a?
17:10:28 <Cale> I wouldn't say they're necessarily CPS. CPS can be encoded as a monad.
17:10:40 <dcoutts> JohnMeacham, err, buildArraySequential :: (b -> (b, a)) -> b -> Arr a
17:10:48 <dcoutts> JohnMeacham, yes you're right
17:10:57 <TheHunter> and every monad can be imbedded in CPS.
17:11:13 <SamB> you mean >>=?
17:11:15 <Cale> but it's not like you have callCC
17:11:21 <palomer> yeah >>=
17:11:36 <Cale> In most monads, the current continuation is inaccessible.
17:11:41 <TheHunter> you need shift+reset.
17:11:47 <SamB> yes, monads do look an awful lot like CPS
17:11:55 <Cale> well, you can't get those either, afaict
17:12:09 <JohnMeacham> but looks promising. I'll just unbox that tuple and those are all suitable primitives... hmm.. lets me build an array... and unsafeIndex :: Int -> Arr a -> a is pretty simple... hmm.. oh.. building an array out-of-order is not obvious though... 
17:12:12 <TheHunter> Cale, I'm not sure I understand what you are saying.
17:12:28 <Cale> TheHunter: you can't implement shift and reset for an arbitrary monad
17:12:35 <dcoutts> JohnMeacham, you've seen accumArray ?
17:12:46 <dcoutts> JohnMeacham, and the ordinary 'array'
17:12:56 <dcoutts> JohnMeacham, you just want non-list versions of those
17:13:05 <TheHunter> Cale, of course not.
17:13:08 <Cale> right
17:13:44 <Cale> since there's no access to that continuation, it might as well not be CPS, since that's really the distinguishing feature of CPS
17:13:47 <JohnMeacham> dcoutts: basically yeah.
17:14:05 <SamB> Cale: oh?
17:14:22 <TheHunter> for example, (forall m. Monad m => m a) and (forall r. Cont r a) are basically the same thing.
17:14:30 <JohnMeacham> dcoutts: not that there is any theoretical reason I couldn't have lists in a primitive interface, but it would inhibit a lot of optimizations and is unpleasant to my sensibilities.
17:14:37 <dcoutts> JohnMeacham, if you take out the lists, each of those should compile into a low level loop that writes into the array.
17:14:43 <TheHunter> i'm not sure that was a meaningful statement...
17:14:52 <dcoutts> JohnMeacham, sure, use something without lists as the primitive
17:15:00 <dcoutts> and then implement the list versions on top
17:15:04 <Cale> TheHunter: "basically the same"?
17:15:28 <Cale> I disagree. In the first case, you have callCC, in the second, you have nothing like that.
17:15:37 <Cale> er, vice versa
17:15:49 <JohnMeacham> dcoutts: yup. that is my plan. I have just not decided on a listless interface I am happy with. but I have not put a whole lot of thought into it. but the buildArraySequential seems like a good start.
17:16:02 <dcoutts> JohnMeacham, the accumArray is underapreciated as a high level array construction func.
17:16:17 <dcoutts> it basically does destructive array update, but safely
17:16:17 <TheHunter> ok, here's what I wanted to say. (forall r. Cont (m r) a) is the same as (m a).
17:16:42 <JohnMeacham> dcoutts: I have never actually used it.
17:17:15 <dcoutts> JohnMeacham, imagine summing a list of vectors (arrays)
17:17:31 <dcoutts> the imperitive algorithm is to have one accumulator array
17:17:49 <dcoutts> that can be done with accumArray
17:18:57 <SamB> hmm. that sounds even nicer than using foldr-style versions of array and listArray...
17:19:03 <dcoutts> the combining function combines and replaces the current value of the array element with the incomming value
17:20:14 <pesco> I'm off to bed, good night!
17:20:27 <palomer> night pesco 
17:20:27 <dcoutts> what stops it from being a totally general destructive array update is that the incomming values cannot depend on existing values in the array
17:20:45 <pesco> Good night, GHC! And don't choke on that compile again! *pat* *pat*
17:20:49 <TheHunter> Cale, is there a conceptual difference between deciding not to use callCC and deciding to use a monad that doesn't provide callCC?
17:22:00 <SamB> TheHunter: well, why *would* you use a monad that provided callCC if you weren't going to *use* it?
17:22:32 <SamB> so bascically, the first conceptual difference is that the former is silly
17:23:28 <TheHunter> what's the point of having the identity monad, then?
17:23:44 <SamB> also, I rather expect it is inefficient to use a monad with callCC but not use callCC...
17:23:45 <SamB> eh?
17:23:58 <SamB> what does that have to do with callCC?
17:24:30 <TheHunter> all I'm trying to say here, that monadic style and CPS are equally powerful concepts.
17:24:50 <SamB> probably!
17:24:57 <palomer> monadic style and CPS are pretty much equivalent, as for as I'm concerned
17:25:20 <TheHunter> right. They're pretty much the same thing.
17:25:24 <palomer> you could probably provide a transformation from monadic style to normal style which would be identical to the CPS transformation
17:25:30 <SamB> except that CPS doesn't llok as nice ;-)
17:25:40 <palomer> SamB: just add do notation to CPS
17:25:42 <glasser> hmm, can somebody help me get "newtype" straight?
17:25:52 <palomer> I'm saying all this without any regard to the type system
17:25:56 <glasser> i get that "type" is a pure synonym, all functions of the old type work on the new, etc
17:26:00 <TheHunter> the Cont monad *is* CPS.
17:26:08 <glasser> and that "data" gives you constructors
17:26:13 <glasser> how does newtype fit in?
17:26:38 <SamB> I was referring to the use of the word "style" in CPS
17:27:03 <SamB> glasser: newtype is like data except you can only have one constructor with one field
17:27:26 <SamB> and that field is strict, and the representation of that newtype is the representation of the type of that field
17:28:12 <SamB> so, basically, you get to make a new type with the same representation as an old one, hence the name
17:28:16 <glasser> so it's basically an optimization?
17:28:20 <eivuokko> Yup.
17:28:37 <dons> the field is strict?
17:28:42 <SamB> dons: of course!
17:28:56 <JohnMeacham> dcoutts: very interesting! hmm.. another option I was thinking of was just implementing IOArrays and wrapping the primitives in an unsafePerformIO.
17:29:04 <SamB> otherwise, you'd need to box the whole thing and you would just use data for that!
17:29:22 <dcoutts> JohnMeacham, that'd be equivalent I guess.
17:29:53 <JohnMeacham> dcoutts: yeah, but a lot less clean. but I need to do IOArrays at some point anyway...
17:30:01 <dcoutts> JohnMeacham, eventually at some level the Array implementation has to be non-haskell
17:30:12 <SamB> nah!
17:30:19 <SamB> you could use Ptrs ;-)
17:30:19 <TheHunter> SamB, |data Foo a = Foo !a| and |newtype Foo a = Foo a| behave differently, at least wrt pattern matching.
17:30:37 <dcoutts> JohnMeacham, so being on top of IOArrays or on top of some primitive doesn't really matter.
17:30:53 <SamB> hrm, except that probably only works for boxed arrays...
17:31:02 <SamB> er, unboxed/
17:31:03 <dcoutts> JohnMeacham, so long as the performance comes out ok :-)
17:31:19 <JohnMeacham> dcoutts: well, the problem with IOArrays is that since they are mutable, points-to analysis is a lot trickier, so it might be useful to have an internal distinction between mutable and immutable arrays.
17:31:23 <SamB> I doubt IOArrays would do worse than the other kind
17:31:30 <SamB> oh, points-to. maybe.
17:31:33 <dcoutts> JohnMeacham, ah right, yes
17:31:52 <JohnMeacham> SamB: yeah, just using malloced Ptr's is my plan for unboxed arrays.
17:31:54 <SamB> but you *can* change it later.
17:32:19 <JohnMeacham> SamB: actually, that could easiliy be implemented portably. perhaps it is already on the web somewhere...
17:32:30 <SamB> and GHC's technique wouldn't help your compiler in its points-to technique...
17:32:30 <dcoutts> JohnMeacham, you're going to support the same high level IArray & MArray interface that GHC provides?
17:32:47 <SamB> dcoutts: isn't that kind of a given?
17:32:54 <dcoutts> JohnMeacham, though they use multi-parameter type classes
17:33:31 <JohnMeacham> dcoutts: yeah, but it needs some patching. well, mainly, HasBounds should not be a superclass of MArray because it makes resizable arrays impossible.
17:33:37 <SamB> he doesn't want to end up like edison
17:34:01 <SamB> JohnMeacham: I don't think that will be a serious issue ;-)
17:34:02 <JohnMeacham> dcoutts: it would not be much of a change. some type signatures would change, perhaps I would try to get it into ghc 6.6. 
17:34:16 <dcoutts> JohnMeacham, yeah, I'd noticed that annoyance.
17:34:26 <dcoutts> JohnMeacham, there was something else too...
17:34:30 * dcoutts tries to remember
17:34:45 <SamB> perhaps that will make usage of HasBounds less efficient with GHC, though...
17:35:05 <JohnMeacham> dcoutts: do you want to write the list about it or should I? :) we actually should get this fixed before ghc 6.6
17:35:22 <dcoutts> JohnMeacham, my change was bigger :-(
17:35:25 <sebell> Pardon the stupid question, but how do I convert CTime to an Integer? (Since CTime doesn't derive from Integral)
17:35:42 <SamB> sebell: what do you want to *do* with it after that?
17:35:56 <SamB> @index CTime
17:35:57 <lambdabot> Foreign.C.Types, Foreign.C
17:36:09 <SamB> @docs Foreign.C.Types
17:36:10 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign-C-Types.
17:36:10 <lambdabot> html
17:36:25 <dcoutts> JohnMeacham, I think I didn't like the way that all arrays had to be fully polymorphic in the index type so I couldn't make a specialised 2D array type an instance of IArray since it had to work for any Ix type. I wanted the index type to be another parameter of the IArray & MArray classes.
17:36:40 <JohnMeacham> SamB: not really, I can't imagine it not being specialized  away with any arrays. and there would be a monadic replacement, so no new classes would need to be passed at runtime because the replacement will already be a part of MArray.
17:36:56 <sebell> SamB: Addition. Preferably as an Int32 I suppose then
17:37:13 <JohnMeacham> dcoutts: yeah, does assosiated type synonyms provide a nice solution to that?
17:37:19 <dcoutts> JohnMeacham, I was trying to make Gtk's Pixbuf 2D bitmap an instance of MArray, but I couldn't because of the indexing issue. A bitmap is quite fundamentally 2D.
17:37:33 <dcoutts> JohnMeacham, not sure about that. I don't know them well enough.
17:37:59 <dcoutts> JohnMeacham, it wasn't just that I wanted a specialisation. It doesn't work for other Ix types. Just (Int,Int).
17:38:04 <SamB> JohnMeacham: hmm, there is that. I suppose it would be very rare indeed for anyone to actually use the bounds stuff at a non-specific type
17:38:15 <SamB> sebell: hmm, I see CTime is an instance of Real...
17:38:18 <JohnMeacham> dcoutts: perhaps MArray could be split up somehow to at least allow some syntax reuse in cases like that..
17:38:37 <dcoutts> JohnMeacham, it just requires the index type to be a paremeter of the class
17:38:38 <SamB> as well as of Num
17:39:14 <JohnMeacham> dcoutts: I think that is actually one of the examples used in the assosiated types paper, one of them.
17:39:39 <dcoutts> JohnMeacham, but that's having a specialised representation though right?
17:39:43 <SamB> sebell: so it looks like you could just add something to it
17:39:55 <dcoutts> i'm talking about an instance that is not valid for all Ix types.
17:40:25 <dcoutts> class HasBounds a => IArray (a::* -> * -> *) e where
17:40:25 <dcoutts>   unsafeArray :: Ix i => (i, i) -> [(Int, e)] -> a i e
17:40:45 <JohnMeacham> dcoutts: yeah, that makes sense.
17:40:52 <dcoutts> that's the current class definition (modulo a few members)
17:40:55 <dcoutts> I'd want...
17:40:58 <JohnMeacham> dcoutts: I think... I'd have to reread the papers.
17:41:25 <dcoutts> class (HasBounds a, Ix i) => IArray (a::* -> * -> *) i e where
17:41:30 <dcoutts>   unsafeAt :: a i e -> Int -> e
17:42:00 <dcoutts> so the (Ix i) is in the class, rather than it requiring unsafeAt work for any Ix i
17:42:04 <dcoutts>   unsafeAt :: a i e -> Int -> e
17:42:06 <dcoutts> vs.
17:42:11 <dcoutts>   unsafeArray :: Ix i => (i, i) -> [(Int, e)] -> a i e
17:42:16 <dcoutts> oops!
17:42:22 <dcoutts>   unsafeAt :: Ix i => a i e -> Int -> e
17:42:28 <dcoutts> that's the original
17:42:32 <dcoutts>   unsafeAt :: a i e -> Int -> e
17:42:34 <JohnMeacham> dcoutts: that would be mostly backwords compatable. 
17:42:40 <SamB> dcoutts: that makes me feel ill-at-ease
17:42:51 <dcoutts> except that it adds another parameter to the class
17:42:53 <dcoutts> SamB, how?
17:43:07 <dcoutts> the existing IArray instances would just be for an Ix i
17:43:09 <SamB> dcoutts: I'm not sure.
17:43:20 <dcoutts> and some new instances might be for restricted Ix types
17:43:30 <JohnMeacham> dcoutts: yeah, but type inference should work the same. you'd only need to change type signatures, but not code.
17:43:33 <sebell> SamB: I should rephrase my question, I'm trying to sum a CTime and a literal integer and have the result be Int32
17:43:52 <dcoutts> JohnMeacham, changing type signatures is still breaking old code.
17:44:12 <dcoutts> sebell, use fromIntegral
17:44:21 <SamB> sebell: why do you want the result to be an Int32
17:44:28 <JohnMeacham> dcoutts: that's why i said 'mostly backwards compatable' :) it is fairly benign as things go. in any case, we are allowed to break it for the ghc 6.6 release.
17:44:37 <SamB> dcoutts: CTime isn't Integral, apparantly...
17:44:38 <dcoutts> JohnMeacham, but I'd be happy to suggest the change for Haskell' ! :-)
17:45:02 <Korollary> sebell: you may floor a real.
17:45:02 <dcoutts> JohnMeacham, well then lets suggest it! :-)
17:45:13 <SamB> JohnMeacham: I have this sneaking suspicion that it might break more than sigs
17:45:45 <SamB> Korollary: I think that is just RealFloats...
17:45:59 <SamB> @type floor
17:46:00 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
17:46:02 <sebell> SamB: Because 8 bytes isn't enough for the sum, and the final structure that I want will be 32 bits long
17:46:03 <SamB> oh, RealFrac
17:46:24 <JohnMeacham> dcoutts: it would need to be done to the libraries first probably. or perhaps just submitted to the haskell' repo as a proposal. if you write up the code and submit it, I can explain it on the wiki. though, putting it to libraries first would be good, then I can add it to the haskell' site.
17:46:42 <SamB> sebell: what in the world are you trying to do, though?
17:46:48 <JohnMeacham> but I gotta go shower at the moment.
17:47:04 <JohnMeacham> just be sure to fix the HasBounds as superclass of MArray thing :)
17:47:08 <dcoutts> JohnMeacham, right 'o
17:47:33 <dcoutts> JohnMeacham, actually I'm not sure what you mean about the HasBounds
17:47:51 <dcoutts> what should it be if it's not a super class?
17:47:56 <dcoutts> just unrelated?
17:49:10 <sebell> SamB: I'm preparing an example implementation of rfc868, which is a deprecated time mechanism, and whose representation is a 32-bit integer with a 70-years difference in seconds from that of the unix epoch
17:49:17 <JohnMeacham> dcoutts: yeah, it only makes sense for arrays with immutable bounds. with MArrays shouldn't be required to have. a 'getBounds :: m (i,i)' would be added to MArray instead and the default routines modified to use that.
17:49:34 <sebell> No Instance of RealFrac for EpochTime though
17:49:39 <dcoutts> JohnMeacham, yes I see
17:50:27 <SamB> @index EpochTime
17:50:28 <lambdabot> System.Posix.Types, System.Posix
17:50:38 <JohnMeacham> dcoutts: this again is a 'mostly backwards compatable' change as mainly what would change are type signatures.
17:50:47 <dcoutts> JohnMeacham, right
17:51:13 <SamB> @docs System.Posix.Types
17:51:14 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Posix-Types.
17:51:14 <lambdabot> html
17:51:31 <sebell> SamB: toRational will get me there though
17:51:55 <SamB> sebell: true...
17:52:03 <SamB> but it makes me nervous.
17:52:34 <sebell> SamB: Yes, me too :)
17:53:25 <sebell> SamB, Korollary: Thanks for the help, gotta run now
17:55:45 <palomer> hrm...
17:55:53 <palomer> unification in the presence of disequalities is hard stuff
17:58:18 <stepcut> but useful
18:06:01 <palomer> stepcut: any links?
18:06:15 <stepcut> no
18:06:26 <stepcut> but I keep wanting them in my haskell programs :p
18:06:28 <palomer> is it decidable?
18:06:40 <palomer> you keep wanting what in your haskell programs?
18:07:11 <stepcut> well, I want to have a type class, class MyClass a b
18:07:30 <stepcut> and then declare: instance MyClass a a
18:07:54 <stepcut> but *also* declare: instance MyClass a b, where a /= b
18:08:08 <palomer> oh, that could be cool
18:08:14 <greenrd> yeah, me too
18:08:16 <stepcut> so I can use one instance when the types are equal, and a different when they are not equal
18:08:16 <palomer> can't you do that with fundeps?
18:08:20 <greenrd> why is that hard?
18:08:24 <greenrd> to implement
18:08:38 <palomer> I don't even know if it's decidable
18:08:51 <palomer> but it is definitely a challenge if it is decidable
18:09:08 <stepcut> because MyClass a a is a subset of MyClass a b, so the compiler thinks there are overlapping instances and does not know which one to pick
18:09:30 <greenrd> well, value equality is not decidable, but type equality should be...
18:09:54 <palomer> value equality?
18:09:55 <palomer> eh?
18:10:16 <greenrd> er, equality of values in general (as opposed to types)
18:10:54 <palomer> greenrd: we're referring to a specific problem
18:11:12 <palomer> which is: given type equalities and disequalities, find a most general unifier
18:11:27 <palomer> actually, a most general unifier may not exist
18:12:05 <palomer> fifor example, unify a != b
18:12:14 <SamB> palomer: which sounds like it would make that undecidable to me...
18:12:27 <palomer> you may need a disunifier!
18:12:28 <palomer> oh my
18:12:46 <stepcut> palomer: in HList they actually figured out how to solve the problem I mentioned above -- though it involves the use of three type classes and you have to enable overlapping and undecidable instances
18:12:59 <palomer> SamB: well, it would return fail if no most general unifier exists
18:13:43 <SamB> palomer: wouldn't that kick off one of those "the impossible happened" errors?
18:13:54 <palomer> SamB: eh?
18:14:12 <SamB> what would return fail?
18:14:36 <palomer> the algorithm
18:14:52 <dons> musasabi, around? 
18:15:00 <palomer> or, rather, it would return a finite set of most general unifiers , or fail if that set is infinite or empty
18:28:22 <SamB> how can they be most general if there are more than one?
18:31:55 <palomer> well, a set which covers all possibilities
18:32:06 <palomer> (which may overlap)
18:42:33 <palomer> monochrom: know anything about unification in the presence of disequalities?
18:43:38 <monochrom> No.
18:44:00 <palomer> hrmph.
18:48:40 <Heffalump> I still (a) don't see why you can't do what I suggested and (b) am confused about where they might have come from
18:52:00 <araujo> Will explicit typing be considered for Haskell' ?
18:56:40 <JohnMeacham> araujo: what do you mean? everything we know about is on the wiki, but we are probably missing some things.
18:57:52 <araujo> JohnMeacham, For example, to be able to do things like, (\ (x :: Int) -> ..... )
18:58:11 <Beelsebob> you can't do that?
18:59:07 <edwinb>     Illegal signature in pattern: Int
18:59:07 <edwinb>         Use -fglasgow-exts to permit it
18:59:11 <edwinb> apparently
19:10:38 <glasser> What library do people like for playing with graphics, that works with ghc? I'm talking more like teaching things
19:10:48 <glasser> like the library from Hudak's book, except that's hugs-only I think
19:10:49 <JohnMeacham> araujo: see the scoped type variables entry.
19:11:01 <glasser> (and it has to work on OSX, though X11 is fine)
19:11:10 <araujo> glasser, gtk2hs?
19:11:10 <Cale> glasser: the library from Hudak's book is now included with GHC and Hugs
19:11:15 <JohnMeacham> http://haskell.galois.com/cgi-bin/haskell-prime/trac.cgi/wiki/ScopedTypeVariables
19:11:17 <araujo> JohnMeacham, oh, it's there?
19:11:18 <glasser> Cale: oh :)
19:11:21 * araujo checks
19:11:30 <glasser> araujo: is that graphics stuff, or more gui?
19:11:52 <Cale> glasser: actually, two versions are there - the original used with the book, and an updated version
19:12:08 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/HGL/Graphics-SOE.html
19:12:22 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/HGL/Graphics-HGL.html
19:12:54 <glasser> cool.
19:13:04 <glasser> Is there a good summary of incompatibilities between the two?
19:16:01 <glasser> Bah. Loading package X11-1.1 ... can't load .so/.DLL for: X11 (dlopen(libX11.dylib, 10): image not found)
19:16:18 <glasser> I wonder why it can't find it. (Note that I only just installed X11, long after installing ghc -- could that be a problem?)
19:16:37 <Cale> no idea -- this is on OSX?
19:17:16 <Cale> I wonder if it will mention where it's looking for that file if you turn up the verbosity
19:18:33 <glasser> I found something helpful in a #haskell log, I think
19:18:38 <glasser> (yeah, OSX)
19:21:00 <glasser> Yay, it worked. (Setting DYLD_FALLBACK_LIBRARY_PATH)
19:26:05 <dons> new command:
19:26:08 <dons> @faq
19:26:09 <lambdabot> The answer is: Yes! Haskell can do that.
19:26:18 <palomer> well...
19:26:22 <dons> ;)
19:26:32 <palomer> it turns out that unification in the presence of disequalities is decidable
19:26:36 <palomer> and you get a most general disunifier
19:26:54 <Heffalump> a what?
19:27:21 <palomer> (dis)unifier
19:27:30 <Heffalump> what is it, though
19:27:56 <palomer> well, a unifier is something of the sort {a := t_1, b := t_2,...}
19:28:18 <palomer> well, a disunifier (no, I haven't seen this word anywhere else) is something like
19:28:29 <palomer> {a := t_1, b !:= t_2 , ....}
19:28:37 <Heffalump> ah, ok.
19:29:10 <Heffalump> I'm not actually sure why my initial reaction was that it's undecidable. It seems obvious you can do that.
19:29:31 <palomer> actually, a disunifier will be of the form
19:29:35 <Heffalump> are you allowed to say Foo a b != Foo c d ?
19:29:44 <Heffalump> in your original set of disequalities
19:30:05 <palomer> a_1 != t_1 and a_2 != t_2 and ... => {b_1:=u_1,...}
19:30:13 <palomer> Heffalump: sure
19:30:24 <Heffalump> then I don't believe you have a most general disunifier.
19:30:26 <palomer> replace and by or
19:30:30 <Heffalump> ah, ok.
19:30:39 <Heffalump> no, even so.
19:30:53 <Heffalump> Foo a b != Foo c d, e != f
19:30:58 <Heffalump> what's the most general disunifier for that?
19:31:08 <Heffalump> you'll have to allow both 'and' and 'or'.
19:31:23 <palomer> actually, change the hypothesis to conjuction of disjuctions
19:31:38 <Heffalump> ok
19:31:49 <glasser> ok, wishful thinking: ghc doesn't have a pragma to allow a spurious comma at the end of list syntax, does it?
19:32:01 <palomer> glasser: that would be evil
19:32:16 <luqui> palomer, why would that be evil?
19:32:22 <Cale> glasser: nope
19:32:25 <luqui> that's one of the things I like most about Perl
19:32:30 <glasser> ah well
19:32:43 <SamB> we have decent pretty printers and such...
19:32:46 <palomer> increasing freedom without increasing expression is not a good idea
19:32:55 <glasser> it's a pain to build up lists of things if you always have to add the comma to the last one before you add a new one (say, a list of HUnit tests)
19:32:58 <luqui> palomer, that's a good principle...
19:33:12 <luqui> but I don't think it's a good reason in this case
19:33:46 <Heffalump> it would be a trivial parser extension
19:33:56 <Heffalump> and quite useful
19:34:22 <SamB> well, someone wanted to change tuple syntax for some convoluted reason that somehow involved such trailing commas, but was VERY ugly looking...
19:34:34 <luqui> ahh, Pythonesque
19:34:52 <luqui> but lists are a different story, because they don't change semantics, it's just to make layouts nice
19:35:13 <luqui> (1,) is different from (1), which is why that's ugly.
19:35:27 <luqui> i.e. "nothing means something"
19:35:33 <SamB> well, this reason involved tuple sections
19:35:39 <Heffalump> @type (1,)
19:35:40 <lambdabot> parse error on input `)'
19:35:53 <SamB> and if Haskell had such trailing commas in tuples, then (1,) would probably mean the same as (1)
19:35:58 <Heffalump> @type (,)
19:35:58 <SamB> which is the same as  1
19:35:59 <luqui> oh, tuple sections... yeah, I've always wondered why we didn't have those
19:36:17 <luqui> I would think (1,) would mean (,) 1
19:36:20 <SamB> this proposal involved list sections as well
19:36:28 <Heffalump> bah, who HUPed lambdabot?
19:36:32 <luqui> list... sections...? ack
19:36:47 <dons> me... on its way
19:36:48 <Heffalump> @type (,,,)
19:36:49 <SamB> however, they way to write them looked horrid and totally inconsistant with the way you write them in patterns.
19:36:56 <SamB> it much abused underscores
19:37:02 <Heffalump> dons: it's ok, I'll forgive you ;-)
19:37:06 <lambdabot> forall d c b a. a -> b -> c -> d -> (a, b, c, d)
19:37:10 <dons> :)
19:37:15 <SamB> takes long enough to warm up
19:37:16 * Heffalump never knew you could do that before
19:37:28 <Heffalump> SamB: it'll have a queue of stuff to send to the server on startup
19:37:35 <Heffalump> that it has to dribble out so as not to get flooded off
19:37:38 <SamB> Heffalump: and recieve
19:37:40 <dons> SamB, it lazily has to suck in all the sate
19:37:42 <dons> state.
19:37:48 <SamB> hmm, and state.
19:37:51 <dons> that too.
19:37:54 <Heffalump> I run an irc bot written in C that has exactly the same problem
19:38:04 <SamB> lazy state?
19:38:31 <dons> lazy IO
19:49:17 <vincenz> Hello everyone, I was curious whether there was a nice browseable interface to the std haskell libs
19:49:59 <araujo> @where haskell libraries
19:49:59 <lambdabot> http://haskell.org/
19:50:02 <SamB> you mean like the haddock docs?
19:50:08 <araujo> @where haskell library
19:50:08 <lambdabot> http://haskell.org/
19:50:20 <vincenz> something a la rubydocs
19:50:36 <SamB> araujo: I'm pretty sure it only pays attention to the first word
19:50:48 <vincenz> preferably browserbased, indexed, searchable (by type as well as by name), automatically updatable if you load new code
19:50:49 <SamB> @docs Prelude
19:50:49 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
19:51:07 <vincenz> is there a standard documentation format for haskell code?
19:52:00 <vincenz> cause it would be nice if you could just say "here, these are my libs I have installed, generate me documentation files that are indexeable and searchable by name and type"
19:52:07 <araujo> SamB, yup :-)
19:53:01 <vincenz> No tool like that?
19:53:31 <Cale> vincenz: Haddock
19:53:37 <vincenz> Cale: ah cool :)
19:53:42 <vincenz> @google haddock
19:53:43 <lambdabot> http://www.haddock.org/
19:53:59 <vincenz> I'm liking haskell more and more as I think of things doable in haskell
19:54:03 <Cale> @where haddock
19:54:03 <lambdabot> http://www.haskell.org/haddock/
19:54:14 * palomer is not so sure about his result anymore
19:54:46 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/index.html -- this is generated by Haddock
19:55:31 <vincenz> Cale: is it searchable by type?
19:55:34 <Cale> oh, not searchable by type (at least not yet -- perhaps ndm's work will cross over into that)
19:55:34 <vincenz> ala hoogle
19:55:51 <Cale> hoogle is relatively speaking pretty new
19:55:55 <vincenz> ah
19:56:05 <vincenz> well a combination of hoogle, haddock and ajax to make it more seamless would be neat
19:57:14 <vincenz> it's a pity that the .hi files (I take it that's the compiled code) do not support containing doccumentation
19:58:17 <vincenz> cause then you could just make a minimal webserver in haskell
19:58:23 <vincenz> that generates documentation on the fly
19:58:29 <vincenz> and allows such things as hoogle
19:58:34 <vincenz> :)
19:58:46 <Cale> That would be pretty cool
19:58:59 <vincenz> yeah
19:59:05 <vincenz> it should be possible right now without documentation
19:59:12 <vincenz> cause the haddock stuff is not in the compiled interfaces
19:59:23 <vincenz> but it wouldn't give you much info, just type specs and modules
19:59:42 <SamB> well, it shouldn't be too hard to get Haddock to do that
19:59:48 <vincenz> SamB: do what?
20:00:03 <vincenz> haddock generates static html afaict
20:00:04 <SamB> well, output suitable metadata
20:00:13 <vincenz> true
20:00:20 <vincenz> I think it would be very useful
20:00:33 <vincenz> throw in some ajax and firefox and you havea nice little tool for during coding
20:01:14 <vincenz> make some gui for haskell coding, and make a separate browsre pane that can do ajax, and you have yourself a nice little haskell ide
20:01:34 <vincenz> great for beginners like me
20:02:03 <vincenz> (possibly adding an easier way of loading modules you define a la drscheme interface)
20:02:56 <SamB> there is work being done on a hopefully-nice IDE, but it sounds like it is difficult to compile right now :-(
20:03:01 <vincenz> how so
20:03:28 <Cale> oh, it's actually not usable yet anyway
20:03:30 <vincenz> I mean drscheme requires you to push the button "reload" so you could just let it save it in a file, compile and load that file
20:03:44 <Cale> as in, you still can't save your file
20:03:48 <SamB> I mean, to compile the IDE, not to compile in the IDE
20:04:01 <vincenz> SamB: I figured as much, why
20:04:06 <SamB> it certainly is no good at development
20:04:13 <vincenz> how does hoogle work?
20:04:44 <Cale> however, hIDE already has some pretty cool features despite being unusable :)
20:04:53 * SamB evades the barage of questions by switching computers on his KVM -- actually he was just burning a CD anyway
20:05:15 <Cale> like using GHC for syntax colouring and being able to underline type errors on the fly
20:05:23 <vincenz> Cale: nice
20:05:32 <vincenz> Cale: remind me what you do?
20:05:54 <Cale> me? Not much at the moment.
20:06:04 <vincenz> Cale: study, work, else?
20:06:12 <vincenz> @hoogle group
20:06:13 <lambdabot> Data.List.group :: Eq a => [a] -> [[a]]
20:06:13 <lambdabot> Data.List.groupBy :: (a -> a -> Bool) -> [a] -> [[a]]
20:06:13 <lambdabot> Graphics.Rendering.OpenGL.GL.SavingState.ServerAttributeGroup :: ServerAttr
20:06:13 <lambdabot> ibuteGroup
20:06:18 <Cale> I've just finished a Bachelor's in pure mathematics
20:06:23 <vincenz> ah
20:06:40 * vincenz thinks that group should be defined for monads
20:06:43 <Cale> and I've been doing some odd jobs, and I'll be applying to some universities shortly
20:06:57 <Cale> hmm
20:07:10 <vincenz> Eq a => ma -> m m a
20:07:26 <vincenz> it would allow more efficient implementations 
20:07:48 <Cale> hm, that doesn't seem possible but Eq a => [a] -> m [a] would be
20:08:26 <vincenz> Cale: how so?
20:08:58 <Cale> How would you implement it just for IO?
20:08:59 <vincenz> [a] -> m [a] seems preposterous
20:09:04 <Cale> why?
20:09:14 <vincenz> well given what group is supposed to do
20:10:04 <vincenz> maybe m a -> m [a]
20:10:08 <vincenz> or ... [m a]
20:10:17 <vincenz> not sure
20:10:23 <vincenz> I think the latter
20:10:29 <vincenz> yeah m a -> [m a]
20:10:52 <vincenz> but that doesn't get you much
20:10:53 <lennart> oh, (:[])
20:10:55 <Cale> can you write it?
20:11:00 <vincenz> Cale: sure
20:11:26 <vincenz> Eq a implies Eq (m a)?
20:11:31 <Cale> no
20:11:34 <vincenz> hmm
20:12:17 <vincenz> I was just thinking that cause for instance, it could be done much more efficiently with a tree
20:12:24 <vincenz> than a list
20:12:44 <vincenz> I mean in a tree, the data that is supposed to be brough together will already be close to each other
20:12:49 <lennart> but how would you make a tree with just Eq?
20:12:55 <Cale> oh, you actually need a MonadPlus
20:13:10 <vincenz> Cale: bleh, I'm not yet at that profiency 
20:13:13 <lennart> i mean, a useful tree
20:13:24 <vincenz> lennart: true
20:13:59 <Cale> lennart: did you have any further ideas regarding default instances?
20:14:08 <lennart> but group is efficient.  it doesn't reorder elements
20:14:20 <vincenz> lennart: it's single traversal?
20:14:26 <lennart> Cale: no, moving to NYC has consumed all my time
20:14:32 <Cale> lennart: ah
20:14:33 <lennart> vincenz: yes
20:14:38 <vincenz> ok, then it's good
20:14:53 <vincenz> :)
20:15:06 <lennart> vincenz: i often find myself doing group . sort
20:15:22 <vincenz> you can't do group?
20:15:24 <vincenz> without sort
20:15:43 <vincenz> conceptually that should be possible
20:15:46 <lennart> then it will not bring equal elements together that are not already next to each other
20:15:46 <Cale> you can, it's just a quick way to collect equal elements together
20:15:58 <vincenz> > List.group [1,2,1]
20:15:59 <lambdabot> [[1],[2],[1]]
20:16:00 <Cale> > group "Mississippi"
20:16:01 <lambdabot> ["M","i","ss","i","ss","i","pp","i"]
20:16:02 <vincenz> doh
20:16:09 <Cale> > (group . sort) "Mississippi"
20:16:10 <lambdabot> ["M","iiii","pp","ssss"]
20:16:23 <vincenz> Cale: the latter behaviour should be possible without sort, I mean in O(N)
20:16:35 <Cale> It's not possible.
20:16:49 <Cale> O(n log n) is the best you'll do with these data structures.
20:16:56 <vincenz> hmm
20:17:07 <vincenz> sort is O(n log n)?
20:17:11 <Cale> right
20:17:26 <lennart> Cale: O(N) is possible with almost all types
20:17:34 <vincenz> lennart: using a hash?
20:17:49 <Cale> lennart: oh?
20:17:51 <lennart> no, using some version of bucket sort
20:18:19 <vincenz> not familiar with bucket sort
20:18:27 <vincenz> another question I had concerns folding
20:18:29 <lennart> sorting is O(N) in the number of bits you want to sort.  if your elements can be represented as bits
20:18:34 <vincenz> foldl doesn't create stack problems, foldr does...
20:18:41 <vincenz> but you can't foldl an infinite list
20:19:13 <Cale> lennart: but is this really doable with lists? (i.e. stacks)
20:19:33 <Cale> I suppose you could construct an array
20:19:35 <lennart> oh, i see.  no, you need arrays
20:19:55 <vincenz> why?
20:19:57 <lennart> well, i've never seen a proof that you need arrays, but i don't know how to do it without
20:20:07 <Cale> vincenz: lists are not random access
20:20:18 <lennart> Haskell provides accumArray for these kind of things
20:20:18 <vincenz> right
20:20:22 <vincenz> but how would you solve it with arrays
20:20:48 <Cale> actually, it seems pretty hard with just Ord
20:21:06 <lennart> vincenz: say you want to sort a sequence of bytes.  just use the byte as an index in the array and increment the array element
20:21:20 <vincenz> Cale: you know how you can make a recursive function tailcall recursive if you use an accumulator... is it possible tto do this on an infinite list by allowing someone to say (I want the accumulated value after 10 items)?
20:21:23 <Cale> since it's tough to know how to place your buckets
20:21:33 <lennart> You need more than Ord, but it can be defined for most types
20:21:35 <vincenz> lennart: it implies your data is hashable
20:22:08 <Cale> vincenz: if you write it that way, it'll usually diverge -- it's possible that it doesn't, but you have to be careful
20:22:16 <lennart> vincenz: you are right, but probably not the way you think :)
20:22:20 <vincenz> Cale: how would you do taht?
20:22:44 <Cale> If your accumulation is such that you only have to read a finite amount of the input before the head of the accumulator is completely specified, it will work.
20:23:01 <vincenz> Cale: no I was thinking of each accumulated value to be a partially defined answer
20:23:09 <vincenz> and you can specify how far you want to go
20:23:19 <Cale> Well, you want scanl/r
20:23:23 <vincenz> take 10 (fold over your data with an acucmulator but keep intermediate results)
20:23:39 <vincenz> cause I don't get how you can foldr over an infinite list without getting a stack exception
20:23:40 <Cale> > scanl (+) 0 [1..10]
20:23:41 <lambdabot> [0,1,3,6,10,15,21,28,36,45,55]
20:24:00 <vincenz> > take 10 . scanl (+) 0 $ [1..]
20:24:01 <lambdabot> [0,1,3,6,10,15,21,28,36,45]
20:24:06 <vincenz> > take 100 . scanl (+) 0 $ [1..]
20:24:07 <lambdabot> [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,
20:24:07 <lambdabot> 253,276,300,325,351,378,406,435,465,496,528,561,595,630,666,703,741,780,
20:24:07 <lambdabot> 820,861,903,946,990,1035,1081,1128,1176,1225,1275,1326,1378,1431,1485,
20:24:07 <lambdabot> 1540,1596,1653,1711,1770,1830,1891,1953,2016,2080,2145,2211,2278,2346,
20:24:07 <lambdabot> 2415,2485,2556,2628,2701,2775,2850,2926,3003,3081,3160,3240,3321,3403,
20:24:09 <lambdabot> 3486,3570,3655,3741,3828,3916,4005,4095,4186,4278,4371,4465,4560,4656,
20:24:11 <lambdabot> 4753,4851,4950]
20:24:19 <vincenz> neat
20:24:29 <lennart> vincenz: it depends on what your foldr does to the list
20:24:38 <Cale> > map sum (inits [1..10])
20:24:39 <lambdabot> [0,1,3,6,10,15,21,28,36,45,55]
20:24:49 <Cale> that's a not so good way to write that
20:24:51 <Cale> > map sum (inits [1..])
20:24:52 <lambdabot> [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,
20:24:52 <lambdabot> 253,276,300,325,351,378,406,435,465,496,528,561,595,630,666,703,741,780,
20:24:52 <lambdabot> 820,861,903,946,990,1035,1081,1128,1176,1225,1275,1326,1378,1431,1485,
20:24:52 <lambdabot> 1540,1596,1653,1711,1770,1830,1891,1953,2016,2080,2145,2211,2278,2346,
20:24:52 <lambdabot> 2415,2485,2556,2628,2701,2775,2850,2926,3003,3081,3160,3240,3321,3403,
20:24:54 <lambdabot> [24 @more lines]
20:25:00 <vincenz> Cale: why
20:25:02 <Cale> hmm, actually, never mind
20:25:06 <Cale> it's fine
20:25:31 <vincenz> there should be a way of making the type system more precise so you know what you can do on infinite data structures and what can not be done
20:25:49 <Cale> however, scanl (+) 0 will likely be more efficient than map sum . inits
20:25:52 <lennart> vincenz: you can
20:25:56 <vincenz> lennart: you can?
20:26:11 <vincenz> there's a ListNonInfinite that subsumes ListInfinite?
20:26:41 <lennart> well, not in Haskell
20:26:42 <Cale> vincenz: not in Haskell
20:26:46 <vincenz> which language?
20:27:04 <vincenz> (and is that the right subsumption order? I'm not a formal cs forte)
20:27:24 <lennart> vincenz: it becomes more cumbersome.  finite and inifite list become totally different types
20:27:51 <vincenz> lennart: well you could make finite list a parent of infinite list
20:27:57 <vincenz> lennart: what do you do?
20:28:13 <frevidar> vincenz: I imagine that would be difficult.
20:28:21 <vincenz> frevidar: why?
20:28:24 <frevidar> vincenz: you can sum an infinite list.
20:28:41 <frevidar> vincenz: you only get a problem if it needs to be evaluated at runtime.
20:28:53 <lennart> frevidar: you can sum it if you have some kind of inifinite numbers
20:29:13 <vincenz> Inf [a] -> Inf a
20:29:14 <Cale> sum [1/n | n <- [1..]]
20:29:21 <Cale> :)
20:29:25 <Cale> er
20:29:27 <vincenz> Cale: right but
20:29:30 <frevidar> lennart: yeah, you know what I mean.
20:29:30 <Cale> sum [1/(2^n) | n <- [1..]]
20:29:39 <vincenz> Cale: that's 2
20:29:47 <Cale> vincenz: yeah
20:29:48 <vincenz> erm
20:29:48 <vincenz> 1
20:29:55 <ncalexan> No, 2.
20:29:58 <vincenz> no 2
20:30:00 <vincenz> I mean 1
20:30:02 <vincenz> it starts at 1/2
20:30:02 <ncalexan> And it's not 2, it approaches 2.
20:30:03 <Cale> hehe
20:30:05 <vincenz> not 1
20:30:13 <vincenz> if it had been [0..]
20:30:16 <vincenz> then it'd be 2
20:30:17 <ncalexan> Or 1, it approaches 1 :)
20:30:25 <Cale> take 20 $ scanl (+) 0 [1/(2^n) | n <- [1..]]
20:30:29 <Cale> > take 20 $ scanl (+) 0 [1/(2^n) | n <- [1..]]
20:30:30 <lambdabot> [0.0,0.5,0.75,0.875,0.9375,0.96875,0.984375,0.9921875,0.99609375,0.
20:30:30 <lambdabot> 998046875,0.9990234375,0.99951171875,0.999755859375,0.9998779296875,0.
20:30:30 <lambdabot> 99993896484375,0.999969482421875,0.9999847412109375,0.9999923706054688,0.
20:30:30 <lambdabot> 9999961853027344,0.9999980926513672]
20:30:35 <frevidar> vincenz: all I'm saying is that its difficult to determine which operations on infinite lists are valid and which ones aren't.
20:31:05 <Cale> lazy lists are a nice way to represent numerical iterations
20:31:16 <vincenz> > (flip (!!) 20 $ scanl (+) 0 [1/(2^n) | n <- [1..]]
20:31:16 <lambdabot>  parse error on input `}'
20:31:26 <vincenz> > (flip (!!)) 20 $ scanl (+) 0 [1/(2^n) | n <- [1..]]
20:31:27 <lambdabot> 0.9999990463256836
20:31:30 <vincenz> :)
20:31:42 <Cale> if you haven't seen it, read http://www.md.chalmers.se/~rjmh/Papers/whyfp.html for lots of reasons why laziness matters
20:31:43 <vincenz> > (flip (!!)) 200 $ scanl (+) 0 [1/(2^n) | n <- [1..]]
20:31:44 <lambdabot> 1.0
20:32:12 <Cale> > (flip (!!)) 200 $ scanl (+) 0 [1/n | n <- [1..]]
20:32:13 <lambdabot> 5.878030948121446
20:32:17 <Cale> > (flip (!!)) 2000 $ scanl (+) 0 [1/n | n <- [1..]]
20:32:18 <lambdabot> 8.178368103610284
20:32:21 <joelk> > iterate (1+) 0 !! 200
20:32:22 <lambdabot> 200
20:32:27 <vincenz> Cale: it's interesting, but sometimes I'm bogged down to how inefficient it must be at runtime, I mean just look at Io a ... it's basically a function which means after you run your entire program you have a main that's one big function
20:32:28 <joelk> heh
20:32:44 <Cale> vincenz: things are lazy
20:32:44 <dons> @shootout ;)
20:32:45 <lambdabot> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=
20:32:45 <lambdabot> all
20:33:03 <Cale> a lazy list should be regarded as no different from a loop
20:33:05 <vincenz> Cale: yeah but doesn't that mean a whole lot of closures?
20:33:18 <Cale> only if they don't become garbage
20:33:21 <vincenz> Cale: that's why I'm studying transformations from imperative to functional code
20:33:35 <Cale> it is different from a loop really
20:33:49 <Cale> in that you can consider it as a whole
20:33:52 <Cale> or chunks of it
20:33:58 <vincenz> basically I'm trying to model how to remove intermediate DDts (specifically sequences like vector and list) by mapping it to a func lang and then doing the reasoning there
20:34:00 <Cale> and you can pass it around
20:34:17 <Cale> but if you use it the right way, it's a loop :)
20:34:30 <vincenz> tho mapping X.set(20, somevalue) becomes inefficient in that representation
20:34:33 <Cale> vincenz: have you heard of deforestation?
20:34:36 <vincenz> Cale: yeah
20:34:43 <vincenz> Cale: the premise is different however
20:35:09 * vincenz is looking at c++ codebases, more specifically multimedia software
20:35:17 <lambdabot> Haskell Weekly News: January 23, 2006 is out: http://sequence.complete.
20:35:17 <lambdabot> org/hwn/20060123
20:35:57 <Cale> Have you read whyfp?
20:36:03 <vincenz> Cale: going to do so now
20:36:08 <vincenz> shit
20:36:11 <vincenz> it's a pdf
20:36:11 <vincenz> I
20:36:18 <Cale> or postscript
20:36:18 <vincenz> I'll download it onto my lappy when I'm at work
20:36:26 <vincenz> cause I'm on my desktop right now
20:36:44 <vincenz> (here's a reason why I want an ircbot that logs urls :))
20:37:04 <Cale> wait, why can't you read it on this machine?
20:37:14 <Cale> are you on a text-only terminal?
20:37:19 <vincenz> no
20:37:23 <vincenz> just I have to get going soon
20:37:27 <Cale> ah
20:37:30 <vincenz> 5:18 am
20:37:39 <vincenz> well 5:30, my computer is off
20:38:07 <vincenz> anyways, I think another interesting thing of FP is the fact how you can optimize much eeasier
20:38:20 <vincenz> for instance concurrency extraction
20:39:10 <vincenz> is there any work done in haskell for doing (forgot the term) remote calculation
20:39:13 <vincenz> ala jocaml
20:39:24 <vincenz> basically making the migration of computation transparent
20:40:21 <frevidar> does wxhaskell have a media control that plays videos?
20:45:05 <vincenz> @hoogle List.
20:45:06 <lambdabot> Prelude.undefined :: a
20:45:06 <lambdabot> Test.QuickCheck.Batch.bottom :: a
20:45:10 <vincenz> @hoogle List.*
20:45:10 <lambdabot> hoogle: Unexpected character when parsing: *
20:45:10 <lambdabot>  
20:45:45 <dons> @docs List
20:45:46 <lambdabot> List not available
20:45:54 <dons> @docs Data.List
20:45:55 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
20:46:24 <vincenz> anyways, concerning migration of computation... anything being done in that ?
20:46:49 <lispy> migration?  like taking it south for the winter?
20:47:10 <vincenz> see I thought of this simple system that would ease things like SETI and make it reusable... Basically have the program you distribute do nothing except register itself with a server... And then the server, whenever it needs to compute something, sends a computation to the differentactive works.
20:47:15 <vincenz> workers
20:47:53 <vincenz> let f = original_f `migrate worker in f input
20:48:03 <lispy> isn't that how distcc work?
20:48:18 <vincenz> no idea, jocaml had a nice system but it kinda went extinct
20:49:24 <vincenz> but basically computations hsould be easily migrated and the calling of a remote computation should be transparent
20:49:40 <vincenz> tho I've read that it can cause trouble with the GC
20:49:42 <stepcut> vincenz: do you know about mobile haskell ?
20:49:47 <vincenz> stepcut: I do not
20:49:52 <vincenz> @google mobile haskell
20:49:53 <lambdabot> http://citeseer.ist.psu.edu/650618.html
20:50:24 <stepcut> vincenz: it is a derivative of ghc that supports process migration -- not sure if a public release is available yet -- but there are some papers
20:51:03 * lispy is becoming convinced haskell does not (yet) scale well to large datasets
20:52:09 <vincenz> stepcut: just looked at a paper, it claipms that it's very slow compared to jocaml due to the fact that haskell is not strict
20:52:40 <vincenz> but it could be used in conjunction with the idea of mapreduce that google published a paper on
20:52:56 <vincenz> especially if you make it transparent and lightweight on the programmer
20:52:58 <stepcut> vincenz: did you also check out 'implementing mobile haskell' ?
20:53:06 <vincenz> stepcut: that's the paper I looked at 
20:53:13 <stepcut> ah
20:53:14 <vincenz> I mean briefly diagonalized ;)
20:53:18 <stepcut> ;)
20:53:51 <vincenz> but yeah it claims slowness issues due to haskell being lazy and the fact it has to go over a certain graph twice (didn't check the details) but it sounded like a fundamental problem
20:54:39 <dons> vincenz, you've seen the shootout results, right?
20:55:04 <vincenz> dons: yeah
20:55:12 <vincenz> dons: looks impressive
20:55:13 <stepcut> vincenz: well, I suspect it is definaly hard to make haskell fast and mobile than ocaml
20:55:20 <vincenz> stepcut: why?
20:55:28 <dons> so I would take `fundamental slowness' as basically FUD 
20:55:36 <vincenz> FUD?
20:55:49 <dons> fear, uncertainty and doubt
20:56:32 <monochrom> Lots of so-called "conventional wisdom" and "rules of thumb" out there are FUD or obsolete myth.
20:56:39 <vincenz> dons: it's in their own paper
20:56:50 <monochrom> For example "recursive is expensive" is one of those.
20:56:50 <vincenz> @google implementing mobile haskell
20:56:51 <lambdabot> http://www.macs.hw.ac.uk/~trinder/papers/TFP03-mhaskell.pdf
20:57:03 <vincenz> check the initial evaluation section
20:57:05 <vincenz> (page 12)
20:57:59 <vincenz> monochrom: recursive is expensive when it's not tailcall
20:58:14 <dons> yeah, obsolete myth is probably more often the case
20:58:15 <sebell> vincenz: Expensive on what?
20:58:24 <vincenz> sebell: your stack
20:58:30 <dons> and people keep repeating it years after it is false
20:58:40 <monochrom> Haha look what I started.
20:59:03 <vincenz> anyways, haskell is becoming more and more intriguing to me
20:59:17 <vincenz> especially the fact how the libs are written in such a way that you can easily redo things with different datatypes
20:59:20 <sebell> vincenz: Certainly, but not on CPU time. Shallow recursions are definitely acceptable in a non-tail position
20:59:37 <vincenz> sebell: function call overhead = nil?
20:59:57 <dons> monochrom ;)
21:00:19 <stepcut> vincenz: non-strict evaluation opens up a lot more possibilities for when things get evaluated -- and more possibilities == harder problem. On the other hand, more possibilities == more opportunities to optimize in ways that you can not in a strict language
21:00:21 <sebell> vincenz: We're speaking on relative terms, everything has a cost.
21:00:21 <lennart> vincenz: function call overhead can be very small
21:04:09 <vincenz> 6am
21:04:12 <vincenz> time to get ready
21:04:16 * vincenz waves
21:04:32 <monochrom> Good morning.
21:19:30 <sebell> I wonder if someone might know an idiomatic way of converting an Integer into an byte array of length 4?
21:21:06 <stepcut> 'tis tricky
21:21:33 <stepcut> especially since and Integer is unbounded
21:22:44 <palomer> oh, then you just compress it
21:23:10 <stepcut> but for Int you can either do bit shifting with Data.Bits, or use Foreign.Storable depending on your goals
21:23:27 * araujo wonders if we consider special chars for function names in Haskell'
21:23:50 <sebell> Well let's make it an Int32, does that simplify things? 
21:23:56 <dons> well. shift and .|. I wrote such a function a couple of days ago: pack p (j-1) $! n .|. (fromIntegral c `shiftL` (8*j))
21:24:06 <palomer> oh my god!
21:24:16 <sebell> I know the method I would use in dynamic languages, but it doesn't seem idiomatic for typed :)
21:24:32 <dons> (for [Char] -> Int, and Int -> [Char], let c = chr $ (w `shiftR` (8 * (j-1))) .&. 0xff in unpack w (j-1) $! c:s
21:25:12 <dons> but stepcut, why try to pack an Integer into 4 bytes? is it always within Int range?
21:25:43 <sebell> dons: I asked the original question
21:25:57 <sebell> dons: And it will be an Int32.
21:26:03 <dons> oh. sorry. here, let me get you the Int -> Ptr Word8 code.
21:31:38 <dons> ah, here it is. you'll just have to tweak it for you circumstances:
21:31:39 <dons> pack :: Ptr Word8 -> Int -> Int -> IO Int
21:31:39 <dons> pack p 0 n = do c <- peek p :: IO Word8 ; return $! n .|. (fromIntegral c)
21:31:40 <dons> pack p j n = do c <- peek (p `plusPtr` j) :: IO Word8
21:31:40 <dons>                 pack p (j-1) $! n .|. (fromIntegral c `shiftL` (8*j))
21:31:43 <dons> unpack _ 0 s = s
21:31:45 <dons> unpack w j s = let c = chr $ (w `shiftR` (8 * (j-1))) .&. 0xff in unpack w (j-1) $! c:s
21:31:50 <dons> (you're not reading and writing Ptr Word8 buffers, I guess)
21:33:20 <sebell> dons: Well, I was planning on it
21:34:55 <dons> you could always have a look at the Binary class for hints: 
21:35:04 <dons> instance Binary Word32 where
21:35:05 <dons>   put_ h w = do
21:35:05 <dons>     putByte h (fromIntegral (w `shiftR` 24))
21:35:05 <dons>     putByte h (fromIntegral ((w `shiftR` 16) .&. 0xff))
21:35:05 <dons>     putByte h (fromIntegral ((w `shiftR` 8)  .&. 0xff))
21:35:07 <dons>     putByte h (fromIntegral (w .&. 0xff))
21:35:44 <sebell> dons: That's what I've written in dynamic languages :)
21:36:57 <dons> it's the same in Haskell, why wouldn't it be?
21:39:30 <sebell> I was curious to see if that was the idiomatic approach, or if some implicit coercion could be possible
21:41:30 <sebell> dons: This will work just fine, thanks
21:43:03 <dons> i guess if performance is critical you could write the Int32 to a Ptr location, and then coerce the type of the Ptr to be Ptr Word8. just as evil as C
21:43:16 <sebell> dons: Indeed
21:46:30 <dons> import Foreign; import Data.Word
21:46:30 <dons> main = do ptr <- newArray [0xdeadbeef] :: IO (Ptr Word32)
21:46:31 <dons>           w1  <- peekByteOff ptr 0 :: IO Word8
21:46:31 <dons>           w2  <- peekByteOff ptr 1 :: IO Word8
21:46:31 <dons>           w3  <- peekByteOff ptr 2 :: IO Word8
21:46:33 <dons>           w4  <- peekByteOff ptr 3 :: IO Word8
21:46:35 <dons>           print [w1,w2,w3,w4]
21:46:58 <lispy> dead beef?
21:47:08 <dons> canonical int
21:47:12 <lispy> hehe
21:48:17 <lispy> well, i'm stumped for making darcs better.  Time to ask haskell-cafe i think
21:48:29 <lispy> can't hurt anyway
21:49:00 <dons> go for it
21:52:06 <dons> oh, there you go, my school used to be known as the Department of Electronic Computation. I wish it was still called that :)
21:52:29 <lispy> heh
22:06:20 <vincenz> dons: mind regiving me the link?/
22:06:43 <vincenz> @google whyfp
22:06:45 <lambdabot> http://www.md.chalmers.se/~rjmh/Papers/whyfp.html
22:07:25 <palomer> is this paper new?
22:14:23 <dons> vincenz? which link was that?
22:22:15 <vincenz> dons: the one I just googled :)
22:24:05 <dons> ah, it was Cale talking about that paper.
22:24:46 <Cale> vincenz: whyfp is pretty old, but it's still right :)
22:28:27 <vincenz> oki :)
22:29:07 <vincenz> anything newer?
22:32:11 <Cale> vincenz: have you already read it?
22:35:36 <Cale> It's not outdated, though the lazy functional language it uses isn't quite Haskell.
22:38:12 <frevidar> does wxhaskell support wxmediactrl?
22:39:03 <frevidar> it says on the website its based on wxwidget 2.6.0, which has wxmediactrl, but I can't find wxmediactrl in the wxhaskell docs.
22:39:39 <lispy> alright, i sent it
22:40:10 <Cale> vincenz: there are plenty of other papers out there, though I'm not sure there's any I know which is quite as good as that at giving good examples of the use of laziness.
22:40:10 <lispy> the email was getting really long so i cut some of the details and talked at a higher level, i hope there is still enough information to get some good ideas
22:40:53 <Cale> the examples that whyfp gives are all very generalisable
22:45:53 <lispy> darc
22:45:55 <lispy> eh
22:46:05 <lispy> sorry, emacs typo :)
22:50:21 <vincenz> Cale: thanks :)
23:02:06 <vincenz> time to go supervise an exam
23:02:07 * vincenz waves
23:49:27 <gour> dcoutts_: ping
