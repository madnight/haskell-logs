00:00:44 <Cale> palomer: something there is causing it to infer that getNext is in the list monad
00:01:42 <palomer> but I'm not using it anywhere
00:02:20 <palomer> try running the getNext function in any interpreter
00:03:11 <Cale> oh, of course :)
00:03:14 <Cale> er
00:03:34 <musasabi> Is there a clean way to break a string into substrings of a fixed length?
00:03:40 <palomer> getNext = do {y <- Control.Monad.State.get;             Control.Monad.State.put (tail y);             Control.Monad.State.return (head y);}
00:03:47 <palomer> getNext = do {y <- Control.Monad.State.get;             Control.Monad.State.put (tail y);             Control.Monad.State.return (head y);}
00:03:48 <palomer> > getNext = do {y <- Control.Monad.State.get;             Control.Monad.State.put (tail y);             Control.Monad.State.return (head y);}
00:03:50 <lambdabot>  parse error on input `='
00:03:55 <musasabi> Something like "iterate (take N)" except working.
00:04:00 <palomer> > let getNext = do {y <- Control.Monad.State.get;             Control.Monad.State.put (tail y);             Control.Monad.State.return (head y);} in getNext
00:04:02 <lambdabot>  Not in scope: `Control.Monad.State.return'
00:04:12 * lispy likes haskell
00:04:19 <lispy> haskell++
00:04:20 <Cale> getNext :: (MonadState [a] m) => m a
00:04:20 <Cale>  -- add this type sig
00:04:30 <ncalexan> musasabi: -- | split 2 "xxyyzzw" == ["xx", "yy", "zz", "w"]
00:04:30 <ncalexan> split :: Int -> [a] -> [[a]]
00:04:30 <ncalexan> split n = takeWhile (not . null) . unfoldr (Just . splitAt n)
00:04:48 <palomer> Cale: why do I need that?
00:04:52 <ncalexan> No idea why that's not in the standard lib.
00:05:13 <lispy> ncalexan: there is a break
00:05:21 <lispy> but it's not based on positions
00:05:26 <palomer> Cale: isn't it supposed to infer the type itself?
00:05:29 <lispy> @hoogle Int -> [a] -> [[a]]
00:05:30 <lambdabot> Data.List.inits :: [a] -> [[a]]
00:05:30 <lambdabot> Data.List.tails :: [a] -> [[a]]
00:05:55 <ncalexan> How do I query lambdabot to find out how to use it?
00:06:11 <palomer> @modules
00:06:12 <lambdabot> Unknown command, try @listcommands.
00:06:16 <palomer> @listcommands
00:06:17 <lambdabot> use listcommands [module|command]. Modules are:
00:06:17 <lambdabot> babel base code compose dice dict djinn dummy dynamic elite fact haddock
00:06:17 <lambdabot> help hoogle karma lShell localtime more pl plugs poll pretty quote search
00:06:17 <lambdabot> seen spell state system todo topic type version vixen where
00:06:18 <Cale> palomer: it doesn't seem capable of inferring that you need an instance of MonadState [a] m
00:06:44 <palomer> wow that sucks
00:06:44 <palomer> night!
00:06:59 <Cale> probably some good reason forit
00:07:02 <Cale> for it*
00:07:19 <lispy> ncalexan: http://www.cs.uu.nl/~afie/haskell/tourofprelude.html#break
00:08:01 <ncalexan> @type break
00:08:03 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
00:08:46 <ncalexan> lispy: you still need to iterate break, and it doesn't do what musasabi asked for.
00:09:14 <lispy> ncalexan: yeah you do still have to iterate.  I didn't see musasabi's question
00:09:41 <lispy> ncalexan: i mentoined it because it seemed related
00:10:05 <ncalexan> mmm.
00:10:46 <lispy> span and splitAt (which you used) are related as well
00:11:13 <int-e> musasabi: splitChunks n = takeWhile (not . null) . unfoldr (Just . splitAt n)
00:11:53 <Cale> hey look, it's just the same as ncalexan's :)
00:11:56 <ncalexan> lispy: I'm aware... and int-e provided the same soln.
00:12:11 <lispy> ncalexan: cool
00:13:01 <lispy> unfoldr is still a function i have yet to really grasp
00:13:14 <int-e> ncalexan: sorry, didn't see it :)
00:13:23 <lispy> i think Cale or someone gave mea really good explanation once...but i lost it :)
00:13:41 <lispy> anyway, i'm going to crash soon
00:13:51 <ncalexan> int-e: I like it actually... independent verification that my idea of idiomatic haskell is similar to someone elses...
00:14:14 <ncalexan> It's a little difficult to know what code is considered 'good bedtime reading'.
00:14:30 <lispy> @pl \n -> takeWhile (not . null) . unfoldr (Just . splitAt n)
00:14:31 <lambdabot> (takeWhile (not . null) .) . unfoldr . (Just .) . splitAt
00:14:46 <lispy> that's the idiomatic version! ;)
00:14:53 <int-e> nah, that's unreadable
00:14:53 <musasabi> mmh, I ended up using the trivial recursive definition
00:15:25 <dons> point free is more idiomatic, I would argue (usually)
00:15:53 <dons> unless it introduces more than 1 partially applied '.'
00:15:55 <ncalexan> dons: with something like that split, I like to think of (split n) as the natural function, and make that point-free...
00:15:55 <int-e> I usually avoid (x .) . y constructs.
00:16:05 <lispy> i was teasing, i'd say the mostly point free version by int-e  and ncalexan are more idiomatic
00:16:27 <dons> the \n ->  takeWhile .. .. is best, I think
00:16:52 <lispy> dons: does @pl have an inverse?
00:17:06 <dons> no, but you could write one!
00:17:13 <int-e> Oh I also tend to avoid lambdas.
00:17:48 <dons> @pl \_ -> putChar ' '
00:17:48 <ncalexan> dons: you have a few minutes to talk about yi?  I have half an email, but chat is easier...
00:17:49 <lambdabot> const (putChar ' ')
00:18:09 <dons> email is better :)
00:18:23 <lispy> how is yi these days?
00:18:29 <int-e> often I feel that the lambda expression deserves to have a name. uses of lambda in monad operations is a notable exception.
00:18:35 <ncalexan> n/p.
00:18:44 <lispy> i've been in a long sumber doing "research" and now i'm awake and can live my life again
00:18:55 <lispy> so i should find out where yi is these days...
00:19:23 <lispy> but
00:19:28 <lispy> i should go to sleep first :)
00:19:34 <lispy> night all
00:19:45 <ncalexan> night.
00:21:15 <dons> @djinn replicateM_ :: Int -> IO () -> IO ()
00:21:16 <lambdabot> Cannot parse command
00:21:28 <dons> @djinn replicateM_ ? Int -> IO () -> IO ()
00:21:29 <lambdabot> Cannot parse command
00:21:40 <dons> @djinn Int -> IO () -> IO ()
00:21:40 <lambdabot> f _ a = a
00:21:45 <dons> oh well
00:22:00 <dons> @djinn Int -> IO () -> [IO ()]
00:22:01 <lambdabot> -- f cannot be realized.
00:34:45 <Cale> Is there a yi mailing list? :)
00:41:02 <dons> nope. but I happily answer email
00:41:07 <dons> there's a wiki
00:44:50 <Cale> SUBSCIRBE
00:44:54 <Cale> :)
00:45:06 <dons> I'm subscribed (or at lesat I was)
00:45:20 <dons> unless something changed.
00:45:28 <ncalexan> subscribed to what?
00:45:39 <dons> the wiki. if you post msgs on the yi wiki, I get mail :)
00:45:40 <Cale> oh, I'm just imitating clueless mailing list users
00:45:46 <dons> oh, sorry. :)
00:52:27 <dons> @pl \z n -> comp (LFT 10 (-10*n) 0 1) z
00:52:28 <lambdabot> flip (comp . flip (flip (LFT 10 . subtract . (10 *)) 0) 1)
01:09:22 <musasabi> Data.Bits.comlement is one's complement?
01:14:37 <Saulzar> Seems so
01:33:16 <dons> @pl \n -> tak (3*n) (2*n) n
01:33:17 <lambdabot> join (liftM2 tak (3 *) (2 *))
01:47:28 <jyp> @yow
01:47:29 <lambdabot> CONGRATULATIONS!  Now should I make thinly veiled comments about
01:47:29 <lambdabot> DIGNITY, self-esteem and finding TRUE FUN in your RIGHT VENTRICLE??
01:49:02 <jyp> dons: ping
01:58:52 <dons> pong
02:08:33 <dons> @yOw
02:08:34 <lambdabot> Used staples are good with SOY SAUCE!
02:19:04 <jyp> Any ongoing plans for Yi ?
02:28:34 <JKnecht> notice of a fork a couple of days ago on the Yi wiki.
02:31:13 <dons> hmm. someone must have put something up.
02:32:00 <jyp> ?
02:32:24 <jyp> I don't see anything close to that
02:33:31 <JKnecht> http://www.scannedinavian.org/YiWiki/DownloadYi
02:34:05 <dons> my ongoing plans are to finalise the syntax highlighting in the curses yi. nothing else concrete at this stage.
02:34:39 <jyp> ok
02:34:49 <dons> JKnecht, that `fork' info has been up for months, since we started on hIDE.
02:35:23 <neologism> functional languages are (formally) based on lambda calculus or partially recursive functions?
02:35:26 * neologism confused
02:36:12 <dons> lambda calculus.
02:36:40 <JKnecht> Oh, the page indicates only last change 3 days ago.
02:36:57 <neologism> my profesor is trying to convince me its partially recursive functions
02:40:23 <defcon8> lambdabot, are you ok?
02:41:06 <carp_> depends what you mean by 'based on' I suppose. They often support recursive definitions of partial functions
02:42:32 <neologism> formal model of computation
02:42:39 <dons> @bot
02:42:40 <lambdabot> :)
02:49:37 <carp_> Amusingly 'the underlying model of computation is the function" http://www.haskell.org/haskell-history.html
02:53:19 <neologism> btw; is ackermann's function actually good for anything?
02:54:28 <jyp> keeping computer scientists busy
02:56:08 <carp_> wikipedia redirected model of computation to abstract machine
02:56:33 <jips> how do i use Data.Map.lookup so that it will return a Maybe value?
02:57:29 <int-e> Maybe is a Monad.
02:58:04 <jips> hm... yeah i just used the value like a Maybe and it works. monads are cool :D
02:58:42 <int-e> > M.lookup M.empty "Foo" :: Maybe Int
02:58:44 <lambdabot> Couldn't match `Data.Map.Map (Data.Map.Map k a) Int' against `[Char]'
02:59:25 <int-e> > M.lookup "foo" M.empty :: Maybe Int
02:59:26 <lambdabot> Nothing
03:00:37 <int-e> (lambdabot's environment has an 'import qualified Data.Map as M' in it)
03:09:08 <araujo> Good morning.
03:09:29 <chucky> I was just about to say the same. Good morning araujo
03:10:24 <araujo> chucky, hello :-)
03:11:26 <chucky> in Cabal, is there any way to control the output of "./Setup.hs --help"? I want it to include the help output from a plain ./configure (since the user should never call configure directly)
03:11:47 <jips> f x = map snd x
03:11:50 <jips> is there such a function?
03:12:29 <chucky> jips: I'm pretty sure there's not
03:13:35 <jyp> map.snd 
03:14:13 <jyp> (map . snd) in a slightly better style
03:14:40 <Saulzar> @type map . snd
03:14:42 <lambdabot> forall a b a1. (a1, a -> b) -> [a] -> [b]
03:14:45 <Saulzar> @type map snd
03:14:47 <lambdabot> forall a b. [(a, b)] -> [b]
03:15:14 <jyp> oops :)
03:15:24 <xerox> nah :)
03:15:25 <adu> which is the one?
03:15:33 <Saulzar> snd :)
03:15:41 <basti_> "oops" = "i shouldnt have typed 'mkfs'"?
03:16:06 <jyp> @pl \x->map snd x
03:16:06 <lambdabot> map snd
03:16:10 <xerox> > (>>= return . snd) $ zip [0..] "hello"
03:16:11 <lambdabot> "hello"
03:16:51 <Saulzar> Inventing a very complicated id xerox?
03:16:54 <adu> > putStr "test"
03:16:55 <lambdabot> No IO allowed
03:17:00 <xerox> Saulzar: dang.
03:17:01 <adu> hehe
03:17:16 <xerox> Who was working on a safe-IO module for lambdabot?
03:17:44 <adu> >[1..5]
03:17:58 <adu> > [1..5]
03:18:00 <lambdabot> [1,2,3,4,5]
03:18:02 <adu> yey
03:18:17 <jyp> that might be a cool application for haskell: running secure applets in a web browser
03:18:23 <jyp> (no IO allowed)
03:18:30 <jyp> :)
03:18:41 <xerox> > enumFromTo 1 5
03:18:43 <lambdabot> [1,2,3,4,5]
03:21:14 <adu> > (\x -> map snd x) [(1,2),(3,4)]
03:21:15 <lambdabot> [2,4]
03:21:36 <adu> ic
03:22:13 <xerox> Ick!
03:22:34 <adu> ?
03:22:45 <xerox> New to Haskell?
03:22:51 <adu> ya
03:23:16 <adu> whats wrong?
03:23:22 <xerox> Nothing :-)
03:24:01 <adu> i think you see something wrong
03:24:52 <adu> are there any arbitrary precision arithmetic modules in haskell?
03:25:13 <basti_> Integer.
03:25:30 <jyp> Rational
03:25:41 <xerox> > 2^5000
03:25:41 <Cale> adu: There are a few for arbitrary precision reals
03:25:42 <lambdabot> 141246703213942603683520966701614733366889617518454111681368808585711816984
03:25:42 <lambdabot> 270751255808912631671152637335603208431366082764203838069979338335971185726
03:25:42 <lambdabot> 639923431051777851865399011877999645131707069373498212631323752553111215372
03:25:42 <lambdabot> 844035950900535954860733418453405575566736801565587405464699640499050849699
03:25:42 <lambdabot> 472357900905617571376618228216434213181520991556677126498651782204174061830
03:25:44 <lambdabot> [16 @more lines]
03:25:45 <adu> wow builtin? cool
03:25:53 <neologism> haskell is a cool language
03:25:56 <Cale> but yeah, for integers, the Integer type does that
03:26:16 <jips> can i give a type signature for an inline let function? would this ever be necessary?
03:26:20 <adu> maybe i should implement my tetration algorithm in haskell
03:26:33 <basti_> jips: whats an "inline let function"?
03:26:39 <jyp> > 3^3^3
03:26:40 <lambdabot> 7625597484987
03:26:56 <Cale> > let f :: Integer -> Integer; f x = x + 1 in f (f 0)
03:26:57 <jips> > let f x = x + 1 in f 3
03:26:58 <lambdabot> 2
03:26:59 <lambdabot> 4
03:27:03 <adu> jyp: i'm surprised someone knows about tetration
03:27:12 <jyp> I don't
03:27:22 <adu> hehe thats what 3^3^3 is
03:27:24 <Cale> jyp: you just happened to apply it :)
03:27:25 <Cale> hehe
03:27:39 <jyp> But I'm known for mind reading
03:27:41 <adu> tetration = iterated exponentiation
03:27:42 <Cale> > let tetra k = k^k^k in tetra 4
03:27:44 <lambdabot> 134078079299425970995740249982058461274793658205923933777235614437217640300
03:27:44 <lambdabot> 735469768018742981669034276900318581864860508537538828119465699464336490060
03:27:44 <lambdabot> 84096
03:27:48 <Cale> er
03:27:52 <Cale> not quite that
03:27:54 <jips> Cale: ah nice
03:27:56 <xerox> ....tetra?
03:28:01 <basti_> adu: ic, like "ackermann function"?
03:28:06 <adu> basti: yes
03:28:25 <Cale> > let tetra k = foldr1 (^) (replicate k k) in tetra 4
03:28:27 <lambdabot> 1
03:28:29 <xerox> Heh.
03:28:31 <adu> only ackerman is like hyper(x, n, y)
03:28:36 <basti_> .)
03:28:38 <xerox> @pl \k -> foldr1 (^) (replicate k k)
03:28:38 <adu> tetration is hyper(x, 4, y)
03:28:39 <lambdabot> foldr1 (^) . join replicate
03:28:42 <xerox> !!
03:28:46 <basti_> i see
03:29:23 <adu> hyper(x, 3, y) = x^y
03:29:26 <adu> hyper(x, 2, y) = x*y
03:29:27 <adu> hyper(x, 1, y) = x + y
03:29:28 <Cale> um
03:30:13 <adu> nono i have an algorithm for finding the real valued tetration
03:30:15 <Cale> aha
03:30:24 <xerox> hyper x n y | x == 3 = x^y | x == 2 = x*y | x == 1 = x+y | otherwise = error "Foo."
03:30:28 <Cale> should have guessed :)
03:30:38 <Cale> let tetra k = foldr1 (^) (replicate (fromIntegral k) k) in tetra 3
03:30:38 <adu> like x^^y == x^x^x^...^x (y times) 
03:30:51 <Cale> > let tetra k = foldr1 (^) (replicate (fromIntegral k) k) in tetra 3
03:30:53 <lambdabot> 7625597484987
03:31:08 <adu> and with my algorithm you can find x^^0.5 or 3^^Pi or e^^e etc...
03:31:26 <jips> how do i know which fold to use?
03:31:43 <xerox> > let tetra k = foldr1 (^) (replicate (fromIntegral k) k) in tetra pi
03:31:44 <lambdabot> Add a type signature
03:31:46 <adu> but it needs huge matricies and very precice arithmetic
03:31:51 <xerox> @type pi
03:31:52 <lambdabot> forall a. (Floating a) => a
03:31:56 <xerox> > let tetra k = foldr1 (^) (replicate (fromIntegral k) k) in tetra pi :: Double
03:31:57 <lambdabot>  add an instance declaration for (Integral Double)
03:31:57 <lambdabot>   In the expression: tetra pi :: Double
03:31:57 <lambdabot>   In the definition of `zar':
03:32:02 <xerox> OK, ok.
03:32:14 <basti_> jips: look where the parenthenses ought to pile up
03:32:42 <adu> x^(x^(x^(...)))
03:33:06 <Cale> http://vx.hn.org/autoshare/folds.png
03:33:43 <adu> hoe do i make an array with a formula in j, k?
03:33:47 <xerox> > let tetra x = iterate (^x) x !! (x-1) in tetra 2
03:33:48 <lambdabot> 4
03:33:50 <xerox> > let tetra x = iterate (^x) x !! (x-1) in tetra 4
03:33:51 <basti_> an array with a formula?
03:33:52 <lambdabot> 0
03:33:57 <Cale> adu: an array, or a list?
03:34:01 <adu> matrix
03:34:03 <xerox> Hm.
03:34:11 <adu> um doesn't haveto be a list
03:34:30 <xerox> ....and Array indexed by tuples?
03:34:32 <adu> i need constant-time indexing
03:34:33 <Cale> > [ [j + k | k <- [1..3]] | j <- [1..3]]
03:34:35 <lambdabot> [[2,3,4],[3,4,5],[4,5,6]]
03:34:42 <Cale> oh, then you want an array
03:34:45 <adu> ok
03:35:08 <Cale> > array ((1,1),(3,3)) [ [((j,k), j + k) | k <- [1..3]] | j <- [1..3]]
03:35:10 <lambdabot>  Not in scope: `array'
03:35:14 <adu> thanx
03:35:24 <Cale> You have to import Data.Array
03:35:55 <int-e> @pl (iterate (\f -> (iterate f 1 !!) . (1+)) (1+) !!)
03:35:56 <lambdabot> (iterate ((. (1 +)) . (!!) . flip iterate 1) (1 +) !!)
03:36:11 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Array.html
03:36:18 * xerox stares at int-e
03:36:57 <int-e> xerox: that's just the Ackermann function ;)
03:37:02 <xerox> Foobar!
03:41:53 <adu> lol
03:50:43 <jips> does ghc know how to cache results when useful? like if i have a huge list and several functions call maximum on it will ghc figure out that it only needs to calculate it once?
03:51:24 <xerox> jips: yes.  It's called CSE, common subexpressions eliminator - if that's what you meant :-)
03:52:12 <jips> i guess so
03:52:41 <jips> but does it know how to do this let's say in seperate IO actions?
03:53:27 <xerox> IO actions have side effects, hence every run has a potentially different outcome.
03:55:02 <adu> YEY i did the first part
03:55:13 <xerox> I think it's safer to do non-side-effectful computations explicitly in pure code; than having the compiler analyze IO code for pure bits to cache.
03:55:37 <adu> side-effectful?
03:56:04 <xerox> adu: i.e. actions whose type last in '... IO a'
03:56:31 <adu> ok
03:56:32 <jips> xerox: ok that's sort of what i mean, but what if you need to load the inital values for this large list from a file?
03:57:06 <xerox> jips: you *can* run pure code inbetween of side-effectful one; and the compiler understands the difference.
03:58:18 <xerox> That is, imagine a |do { contents <- getContents; print (pureComputation contents) }|.
04:00:00 <xerox> |pureComputation| could run a whole lot of other statically analyzed pure computations.
04:00:30 <jips> ok now imagine that the "print" part is performed twice... would ghc know that it is allowed to compute "pureComputation contents" and use the result also for the second print?
04:00:46 <xerox> jips: yes, it would.
04:00:58 <dons> haskell must be one of the best languages around for doing arbitrary precision math, and its fast: http://shootout.alioth.debian.org/benchmark.php?test=pidigits&lang=all
04:01:00 <jips> hm... cool
04:01:24 <jips> do { contents <- getContents; print (pureComputation contents); print (pureComputation contents) }
04:01:38 <jips> so if pureComputation is really expensive, then ghc in practice really would only compute it once?
04:01:46 <xerox> jips: Right.
04:02:02 <jips> sweet
04:02:19 <adu> not any suggestions for a row-reduction algorithm?
04:02:21 <jips> does it use some sort of complexity measurement to know if it's worthwhile to do this or something?
04:02:41 <xerox> jips: it just do that, except if you explicitly ask to not do so.
04:02:54 <dons> well, it'll always reuse the result if you use a `let'. then you don't have to guess
04:03:19 <jips> dons: yeah, i've heard that... this bothers me
04:03:34 <dons> why?
04:04:02 <dons> except for actually timing the cost of pure computations, i can hardly think of a case where you really want to recompute a pure value
04:04:02 <jips> i have this feeling that let is supposed to be pure syntax sugar
04:04:09 <dons> no, it's not.
04:04:11 <xerox> Unlike Scheme, which has a CSE-enable-by-default-policy stated in its Report, Haskell hasn't.  But as far as I know, GHC is pretty smart.
04:04:27 <blm> Can someone give me tips or pointers for understanding tuple types mentioned in 2.2 User defined Types in A Gentle Introduction to Haskell?
04:04:28 <dons> it means: allocate a suspended computation (a thunk) for the expr
04:04:29 <jips> anyway though, sometimes you can't really use let
04:04:37 <xerox> dons: yeah, that's what I thought.
04:05:04 <dons> let, case, lambda, primops and application. that's really the core. everything else is sugar.
04:05:36 * xerox licks his lambdacandy
04:05:50 <dons> for some reason, beginners rarely use `let'. in fact, I think it's only mentioned once in Thompson.
04:06:06 <xerox> I personally like 'where' more than 'let'.
04:06:23 <dons> whereas hard core hackers almost always program in let and case. only sometimes using other stuff. take ghc as an example of this kind of code.
04:06:43 <dons> you _really_ know what is happening at the lowest level if you use just let and case.
04:07:00 <jips> what's the difference between let and where?
04:07:01 <xerox> Is there much a difference between let and where clauses?
04:07:06 <jyp> none
04:07:28 <lennart> let is an expression, where is for declarations
04:07:32 <jyp> http://research.microsoft.com/users/simonpj/papers/haskell-retrospective/HaskellRetrospective.pdf
04:08:02 <jyp> around page 15
04:09:30 <Heffalump> I've started using let more than I used to.
04:09:44 <Heffalump> I think it's because I've started thinking bottom-up more, not sure why..
04:10:43 <kosmikus> I usually prefer if variables are introduced before the point where they are used; I think that's the main reason I prefer let
04:11:01 <lennart> using 'do' a lot get's you into the 'let' mind set
04:11:25 <kosmikus> I use 'where' mainly together with guards
04:11:29 <jyp> kosmikus: except that let can be recursive :)
04:11:42 <dons> that's a good point, lennart.
04:11:52 <kosmikus> jyp: I don't understand, "where" can be recursive, too
04:12:47 <jyp> What I mean is, in the presence of recursion, one cannot claim defintion come before usage
04:12:58 <adu> is floatDigits what i need to change?
04:13:12 <jyp> ... whatever the syntactic construct used
04:13:32 <kosmikus> jyp: you mean multiple mutually recursive declarations, then. that doesn't happen frequently, and if it does, it's usually top-level for my programs.
04:13:34 <JKnecht> jyp: why not?
04:14:12 <lennart> adu: floatDigits is unchangable.  what are you trying to do?
04:14:17 <jyp> let fib x = fib (x-1) + fib (x-2)
04:14:20 <jyp> ...
04:14:52 <kosmikus> jup: that's "declaration before usage" for me
04:15:07 <jyp> you use it /while/ defining it
04:15:25 <adu> lennart: arbitrary precision arithmetic
04:15:35 <kosmikus> I don't want to argue about terminology; this situation doesn't confuse me
04:15:53 <kosmikus> if I use an identifier that's only introduced at a later point in the program, it sometimes does
04:15:57 <adu> like i want 200 digits for example
04:16:00 <lennart> adu: Haskell doesn't have arbitrary precision floating point
04:16:05 <adu> oh
04:16:11 <adu> they told me it did
04:16:18 <adu> i guess that was int
04:16:25 <lennart> adu: there are implementations you can find, but not built in
04:16:54 <lennart> yes, integers and rational numbers are available with arbitrary precision
04:18:24 <lennart> there are also some implementations of real numbers for Haskell
04:23:30 <adu> and you can convert rational -> float?
04:24:25 <Cale> > fromRational (3%5)
04:24:26 <lambdabot> 0.6
04:24:37 <adu> yey!
04:24:48 <Cale> @type fromRational
04:24:50 <lambdabot> forall a. (Fractional a) => Rational -> a
04:26:01 * JKnecht has never heard of arbitrary precision floating point. Or even really big precision floating point analogous to what GMP and the like do with integers/rationals.
04:26:16 <Heffalump> yeah, how would you represent pi?
04:26:32 <adu> > pi
04:26:34 <lambdabot> 3.141592653589793
04:26:35 <Cale> with a lazy sequence of approximations to pi
04:26:41 <basti_> with an alogrithm, of course
04:26:49 <lennart> Mathematica has arbitrary precision floating point
04:26:50 <Heffalump> and does that idea generalise?
04:26:58 <Cale> Heffalump: to computable reals
04:27:02 <basti_> it does not?
04:27:09 <adu> lennart: i already have a many Mathematica algorithms for tetration
04:27:13 <lennart> yes, all (constructive) real numbers can be represented with an algorithm
04:27:14 <basti_> methinks, there's lazy algorithms for the usual algorithms
04:27:18 <adu> lennart: you want to see them?
04:27:22 <defcon8> there are *
04:27:23 <JKnecht> but there is that savant in the U.K. that compute to like a hundred decimal places in his head ('Brainman').
04:27:42 <Heffalump> where the algorithm can always be asked "give me the first n decimal places"?
04:28:08 <defcon8> JKnecht, read a book called "use your head" by steve buzan
04:28:09 <Heffalump> I guess Haskell laziness is a win here, since you can just write the program and store it in the datatype.
04:28:10 <lennart> no, give me the number to within a specified delta
04:28:21 <Heffalump> lennart: same thing, surely..
04:28:24 <lennart> which is not quite the same as a number of decimals
04:28:27 <Heffalump> ok, that's more general
04:28:36 <Heffalump> and more logical to ask for, but it's the kind of thing I meant
04:29:01 <lennart> certain numbers have multiple representations in decimal notation, which causes trouble
04:29:19 <Heffalump> oh, true
04:29:21 <lennart> like 0.99999999999999... and 1
04:29:48 <Heffalump> not much of a problem, though, because "first n decimal places" implies that you round the last one.
04:30:12 <Heffalump> oh, yes, 0.34999999.... and 0.35 have a problem if you want the first decimal place
04:30:25 <dons> > 0.2 + 0.1
04:30:27 <lambdabot> 0.30000000000000004
04:30:32 <Heffalump> :-)
04:30:32 <lennart> yes, so you might have to compute forever to make sure which number it is
04:30:39 <astrolabe> but 'first n decimal places' might not be a computable problem
04:30:40 <Heffalump> right
04:30:55 <lennart> real numbers are a bit unpleasent.  equality is undecidable
04:31:44 <lennart> so Haskell insistng Eq is a superclass of Num can't really be implemented
04:32:03 <lennart> nor can Show be implemented for real numbers
04:32:26 <lennart> at least not a normal show
04:32:32 <dons> @remember lennart real numbers are a bit unpleasent.
04:32:38 <dons> :)
04:32:43 <lennart> :)
04:32:54 <astrolabe> I suppose it is because there are too many of them.
04:32:59 <Heffalump> > 0.2 + 0.1 == 0.3
04:33:01 <jips> hm.... conclusion is that haskell's type system is broken
04:33:01 <lambdabot> False
04:33:17 <lennart> No, there are not "too many" of the constructive reals.
04:33:27 <Heffalump> the constructive reals are countable?
04:33:28 <Cale> only countably many constructible reals
04:33:29 <lennart> They are countable
04:33:33 <Heffalump> how?
04:33:36 <Cale> for obvious reasons
04:33:46 <lennart> They can all be represented by algorithms
04:33:46 <Heffalump> oh, enumerate the programs
04:33:47 <Heffalump> duh
04:33:48 <Cale> there are only countably many TMs
04:33:53 <jips> does ghc optimize floating point calculations by doing factoring and stuff?
04:33:59 <Heffalump> jips: no
04:34:07 <jips> Heffalump: how to enable this? :)
04:34:11 <lennart> jips: but with -O2 gcc kicks in
04:34:33 <lennart> but you probably need flags to enable unsafe optimizations
04:34:39 <dons> and then pass through -optc-O3 or whatever to gcc, that sometimes helps
04:34:45 <Heffalump> jips: you could use RULES pragmas to enable some
04:34:50 <Heffalump> s/enable/write/
04:35:12 <JKnecht> defcon8: would The Mind Map Book be better?
04:35:25 <jips> hm.... scary stuff... later channel
04:35:45 <defcon8> JKnecht, that is just for studying i guess. 
04:35:55 <defcon8> you know, to organise info so you can easily remember stuff
04:35:59 <defcon8> it is highly effective
04:36:08 <defcon8> and enabled me to get 95 out of 100 from history
04:36:52 <Cale> I want an implementation of actual real numbers as existence proofs in ZFC, together with a suitable theorem prover. ;)
04:37:20 <astrolabe> but to compare constructive reals, you cannot in general compare the algorithms that construct them, so you have to chuch that information away, and you are left to compare reals, which can come down to infinitely many questions.
04:38:09 <Cale> It comes down to comparing programs, which is undecidable.
04:39:10 <BuZzY> hello
04:39:10 <Cale> My suggestion would be quite ridiculous indeed, as there are apparently real numbers, the existence of which is equivalent to various large cardinal axioms independent of ZFC :)
04:39:22 <Cale> BuZzY: hi
04:39:54 <JKnecht> defcon8: thanks, this also reminds me to get 'Drawing on the Right Side of the Brain' if I don't already have.
04:40:03 <lennart> Cale: it's your own fault for thinking that there's anything more than the constructive reals ;)
04:40:08 <defcon8> steve buzan rules
04:40:17 <defcon8> i highly recommend getting use your head first
04:40:18 <Cale> lennart: Of course there are ordinary reals.
04:40:32 <Cale> lennart: they're willed into existence by the powerset axiom
04:40:33 <lennart> Why do you say of course?
04:40:46 <Cale> and the axiom of infinity
04:40:56 <lennart> you use axioms I don't :)
04:41:09 <Cale> which of those do you reject?
04:41:13 <lennart> axioms are supposed to be slf evident, and I don't think they are 
04:41:26 <Cale> (of course, you're not talking about sets anymore, hehe :)
04:41:32 <Cale> no
04:41:35 <defcon8> self evident but not proved
04:41:39 <Cale> axioms don't have to relate to anything
04:41:45 <defcon8> ok
04:41:49 <defcon8> logical but not proved
04:41:51 <Cale> axioms are completely arbitrary statements which we choose
04:42:15 <Heffalump> why does this algorithm for producing a real number not count? Enumerate the constructive reals (lazily), pick some digit different from the 1st decimal digit of the 1st constructive real, pick some number different from the 2nd digit of the 2nd constructive real, etc.
04:42:19 <astrolabe> Cale, a moment ago you sounded like a platonist, now you've gone all formalist
04:42:33 <Cale> usually to model some fuzzy notion, of course :)
04:43:05 <Cale> astrolabe: I'm a formalist.
04:43:15 <lennart> well, if we're just formalist, i start from different axioms because I like the hair shirt :)
04:43:24 <Cale> Of course
04:43:34 <lennart> and I like constructive proofs
04:43:48 <Cale> but by doing so, you're depriving yourself of a lot of existing work
04:44:09 <Cale> however, if you *need* different axioms, that's another thing
04:44:13 <astrolabe> Cale: Then what do you mean by 'Of course there are ordinary reals.'
04:44:32 <Cale> astrolabe: they exist formally as part of ZFC, which is the default system :)
04:45:15 <lennart> your default system ;)
04:45:26 <Cale> unless anyone says otherwise, I generally assume that the axioms of ZFC are the foundation, simply because that's what practically everyone uses.
04:45:38 <astrolabe> Did you think lennart was claiming they weren't in ZFC?
04:46:06 <astrolabe> Ah ok, maybe you did :)
04:46:07 <Cale> I took his statement to mean that they didn't exist as a concept.
04:47:04 <astrolabe> Well, you are both a bit unusual I suspect.
04:47:25 <lennart> This is #haskell, we're all strange
04:47:28 <sieni> Heffalump: you can't algorithmically enumerate the constructive/recursive reals
04:47:32 <astrolabe> :)
04:47:49 <Cale> I'm fairly sure the reals (in ZFC) are well-defined at least. (Unless you want me to speculate that, say, the ZFC axioms are inconsistent -- still, I think you'd have trouble pointing out an inconsistency :)
04:47:51 <adu> lol
04:47:52 <Heffalump> sieni: why not?
04:48:31 <lennart> Cale: I would not be surprised if ZFC is inconsistent.  I'm hoping.
04:48:34 <astrolabe> @remember lennar This is #haskell, we're all strange
04:48:41 <astrolabe> @remember lennart This is #haskell, we're all strange
04:48:44 <Cale> lennart: Good luck :)
04:49:02 <lennart> Cale:  I'm not holding my breath
04:49:08 <Heffalump> @quote lennart
04:49:09 <lambdabot>  real numbers are a bit unpleasent.
04:49:10 <sieni> Heffalump: basically you would end up with an algorithm, that could detect, whether a given turing machine terminates with a given input
04:49:12 <Heffalump> @quote lennart
04:49:13 <lambdabot>  real numbers are a bit unpleasent
04:49:17 <Cale> Why would one hope that a system is inconsistent?
04:49:34 <Heffalump> sieni: I don't see why.
04:49:44 <Cale> We know that it's incomplete, which is a good thing :)
04:49:45 <lennart> Because then people would finally see the light!
04:49:53 <Cale> what light?
04:49:55 <Heffalump> I just want the nth digit of the output, not to know if it terminates.
04:50:03 <lennart> All interesting systems are incomplete.
04:50:08 <Cale> We'd switch to what is likely a very similar system
04:50:09 <adu> cuz inconsistency makes people scratch heads
04:50:21 <astrolabe> Heffalump: I don't think that is any easier.
04:51:00 <Cale> adu: Inconsistency means that every statement is both true and false.
04:51:25 <Cale> (as P and not P implies Q)
04:51:39 <Heffalump> astrolabe: sorry, I just want to pick a digit that isn't the same as the nth digit of the output. And I think that is easier.
04:51:48 <sieni> Heffalump: well, your constructive real is something like an algorithm that computes nth digit on request. How do you decide, whether the program fails to compute the nth digit instead of just taking a very long time?
04:51:57 <adu> don't scratch your head at that?
04:52:11 <Cale> adu: nope, it's perfectly ordinary
04:52:12 <Heffalump> because if you get a "I don't know if it's 3 or 4 type problem", just pick 2.
04:52:18 <astrolabe> For example to add two decimals, calculating the most significant digit of the sum in general requires knowledge of all of the digits of the summands.
04:52:27 <Heffalump> sieni: oh, right.
04:52:30 <adu> haskell ppl are wierd
04:53:55 <astrolabe> You've only scratched the surface.
04:54:09 <psi> ot: are there any simple rules of deciding whether an english word is pronouncable or not?
04:55:17 <Heffalump> yes, find native English speaker, ask him or her
04:55:27 <Heffalump> if answer seems dubious, find another one, repeat
04:55:32 <astrolabe> There is no simple rule for deciding how to pronounce them.  They got closest in the 19th century I beleive.
04:55:43 <Heffalump> (no)
04:55:45 <Cale> adu: Suppose that P and ~P. Then if ~Q, we'd certainly have ~P, so ~Q => ~P. But then by contrapositive, P => Q. But P is true, so Q.
04:56:23 <JKnecht> There are lots of negative rules, length, bad letter combos and the like.
04:56:39 <psi> ok :-)
04:56:59 <psi> i guess i just want to filter out as many as possible
04:58:31 <astrolabe> psi: http://en.wikipedia.org/wiki/Phonics
04:59:41 <astrolabe> The ones you can't pronounce are the ones that are left when you have removed all the ones you can pronounce.
05:00:12 <astrolabe> I suspect there will be some sporadic ad hoc prouncables though.
05:01:07 <psi> ok, thanks
05:01:43 <astrolabe> There is a longer list here http://www.edsanders.com/phonics/phonrule.htm
05:03:00 <Cale> Here we go. Kwyjibo. K-W-Y-J-I-B-O. Twenty-two points, plus triple-word-score, plus fifty points for using all my letters.  Game's over.  I'm outta here.
05:03:52 <Heffalump> :-)
05:04:08 <adu> i'm having trouble constructing an array
05:04:20 <Cale> @type Data.Array.array
05:04:21 <lambdabot> forall e i.
05:04:21 <lambdabot> (GHC.Arr.Ix i) =>
05:04:21 <lambdabot> (i, i) -> [(i, e)] -> GHC.Arr.Array i e
05:04:35 <Cale> @type Data.Array.listArray
05:04:37 <Heffalump> why do you want an array?
05:04:37 <lambdabot> forall e i. (GHC.Arr.Ix i) => (i, i) -> [e] -> GHC.Arr.Array i e
05:04:47 <adu> i know i see that same information in the error mesages
05:05:04 <adu> i'm not type-literate tho
05:05:12 <Cale> what are you passing to array?
05:05:24 <adu> slogMatrixE x n = array ((0, n-1), (1, n)) (j, k):     [         ((k**j)/(product [1..k])) -          (if j == k then 1 else 0)     | j <- [0..(n-1)], k <- [1..n]     ] 
05:05:45 <Cale> ah, actually, I may have misled you earlier :)
05:05:55 <Cale> you have to flatten that list, or construct it flat
05:06:14 <adu> ?
05:06:17 <xerox> @type (>>= return)
05:06:18 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m a
05:06:26 <xerox> Nawh...
05:06:39 <Cale> er, hmm
05:06:41 <Cale> no
05:06:45 <Cale> that is flat
05:06:51 <xerox> @type (>>= (>>= return))
05:06:52 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
05:07:14 <Cale> > [((k**j)/(product [1..k])) - (if j == k then 1 else 0) | j <- [0..(5-1)], k <- [1..5] ]
05:07:16 <lambdabot> [1.0,0.5,0.16666666666666666,4.1666666666666664e-2,8.333333333333333e-3,0.
05:07:16 <lambdabot> 0,1.0,0.5,0.16666666666666666,4.1666666666666664e-2,1.0,1.0,1.5,0.
05:07:16 <lambdabot> 6666666666666666,0.20833333333333334,1.0,4.0,3.5,2.6666666666666665,1.
05:07:16 <lambdabot> 0416666666666667,1.0,8.0,13.5,9.666666666666666,5.208333333333333]
05:07:20 <xerox> Ah okay.
05:07:21 <adu> do i haveto have all entries in ((j, k), value) form?
05:07:26 <xerox> @pl (>>= (>>= return))
05:07:27 <lambdabot> join
05:07:28 <Cale> ah, but yes
05:07:30 <Cale> you do
05:07:30 * xerox laughs
05:07:35 <Cale> unless you use listArray
05:08:02 <astrolabe> Your bounds look funny too.
05:08:07 <Cale> but it is probably safer to use array, since it's harder to get things in the wrong spot
05:08:18 <Cale> yeah
05:08:19 <adu> ok
05:08:29 <Cale> and there's that extra element you're consing on there
05:08:35 <adu> bounds? why?
05:08:38 <Cale> where j and k are out of scope
05:08:42 <astrolabe> maybe you want ((0,1),(n-1,n))
05:08:52 <Cale> ((xmin,ymin),(xmax,ymax))
05:09:14 <adu> your right
05:09:18 <adu> oops
05:09:19 <xerox> @type join
05:09:20 <lambdabot> Not in scope: `join'
05:09:31 <Cale> @type Control.Monad.join
05:09:32 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
05:09:55 <Cale> xerox: ever looked at the Haskell 1.4 prelude?
05:10:03 <xerox> Why I do recall 'join x = x x' ?
05:10:10 <Cale> um
05:10:22 <Cale> @pl f x = x x
05:10:23 <lambdabot> f = join id
05:10:28 <xerox> Ah, there's an f.
05:10:33 <xerox> @type join f x = f x x
05:10:34 <Cale> of course, that's not well-typed
05:10:35 <lambdabot> parse error on input `='
05:10:39 <adu> Cale: ya
05:10:43 <xerox> @type \f x -> f x x
05:10:45 <lambdabot> forall t t1. (t -> t -> t1) -> t -> t1
05:10:48 <adu> its not very readable
05:10:58 <Cale> xerox: what?
05:11:02 <Cale> @type \x -> x x
05:11:03 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
05:11:03 <lambdabot>   Expected type: t
05:11:12 <xerox> I know that that one is not well typed
05:11:14 <Cale> @pl \x -> x x
05:11:15 <lambdabot> join id
05:11:20 <Cale> it's the same one
05:11:27 <xerox> @pl \f x -> f x x
05:11:28 <lambdabot> join
05:11:33 <Cale> oh
05:11:34 <Cale> okay
05:11:35 <xerox> Eh.
05:11:59 <Cale> yeah, it makes sense that's the join for Reader
05:12:08 <xerox> Ah, it cheat.s
05:12:11 <xerox> join              :: (Monad m) => m (m a) -> m a
05:12:11 <xerox> join x            =  x >>= id
05:12:34 <Cale> hm?
05:12:42 <Cale> cheats?
05:12:57 <xerox> Isn't bind theoretically defined in terms of fmap and join?
05:13:22 <Cale> well, that's the usual way
05:13:32 <Cale> in mathematics
05:13:40 <adu> ?
05:13:44 <Cale> but in Haskell, the Monad class just has return and bind
05:14:01 <adu> so whats the proper way to make a matrix with array?
05:14:43 <Cale> array ((1,1),(n,m)) [((i,j), f i j) | i <- [1..n], j <- [1..m]] where f i j = ...
05:14:57 <Heffalump> however if you want an unboxed array you'll need to make it an array of arrays instead.
05:15:06 <xerox> > (join . fmap) (+1) [1..5]
05:15:07 <lambdabot>   Occurs check: cannot construct the infinite type: f = (->) (f a)
05:15:07 <lambdabot>   Expected type: (a -> b) -> f a -> f a -> a1
05:15:07 <lambdabot>   Inferred type: (a -> b) -> f a -> f b
05:15:07 <Heffalump> but you probably don't want one
05:15:12 <Cale> Heffalump: the opposite
05:15:31 <Heffalump> cale: huh?
05:15:44 <Heffalump> oh, I see
05:15:44 <xerox> How would you write join without bind?
05:15:45 <Cale> Heffalump: Unboxed arrays can't have arrays as elements.
05:15:55 <adu> does that make an unboxed array?
05:15:57 <Heffalump> can't they? Array# exists.
05:16:04 <Cale> xerox: it would be in the Monad class
05:16:13 * xerox sees.
05:16:38 <Cale> Heffalump: it does? where?
05:16:59 <Cale> @index Array#
05:17:00 <lambdabot> bzzt
05:17:04 <Cale> @index Array
05:17:05 <lambdabot> Data.Array, Data.Array.IArray, Data.Array.Unboxed, Data.Array.Diff
05:18:19 <Cale> It's fine to use whatever index type you want with unboxed arrays because that gets translated away by Ix anyway.
05:18:28 <Heffalump> you can find it by grepping the library source
05:18:34 <Heffalump> yeah, good point
05:18:38 <Cale> oh, it's probably internal
05:18:49 <Heffalump> but it's mentioned in GHC docs
05:18:58 <xerox> > let join = concat; fmap = map; return = (:[]); bind xs f = join (fmap f xs) in [1,2,3] `bind` (return . (*2))
05:18:59 <lambdabot> [2,4,6]
05:19:04 <adu> > slogMatrixE n = array ((0, 1), (n-1, n)) [((j, k), slogMatrixElementE j k) | j <- [0..(2)], k <- [1..3] ] where slogMatrixElementE j k = ((k**j)/(product [1..k])) - (if j == k then 1 else 0) 
05:19:05 <lambdabot>  parse error on input `='
05:19:08 <Cale> Heffalump: where?
05:19:12 <xerox> Cale: right?
05:19:13 <adu> > slogMatrix E 2
05:19:14 <lambdabot>  Not in scope: data constructor `E'
05:19:31 <adu> > slogMatrixE 2
05:19:33 <lambdabot>  Not in scope: `slogMatrixE'
05:19:39 <Cale> xerox: sure, that's the list monad
05:20:53 <Heffalump> it's used by base/GHC.{PArr,Weak,Arr}
05:21:00 <Heffalump> I guess it must actually be defined by GHC itself.
05:22:48 <xerox> > (+1) >>= (*) $ 4
05:22:49 <lambdabot> 20
05:24:04 <Cale> Winning ways for your obfuscation plays.
05:24:14 * xerox boings happily
05:26:44 <xerox> > (++ "o") >>= (++) $ "w"
05:26:45 <lambdabot> "wow"
05:26:46 <xerox> !
05:26:54 <Cale> heh
05:26:57 <xerox> haha :)
05:27:08 <int-e> A new fan of the reader monad :)
05:27:11 <Cale> > "wow"
05:27:12 <lambdabot> "wow"
05:27:17 <xerox> Whoopee.
05:27:57 <Heffalump> @type (++ "o") >>= (++)
05:27:58 <lambdabot>   No instance for (Monad ((->) [Char]))
05:27:58 <lambdabot>   arising from use of `>>=' at <interactive>:1:9-11
05:28:04 <xerox> :)
05:28:11 <adu> ?
05:28:47 <adu> the array isn't working
05:28:50 <adu> i get an error
05:29:01 <Cale> adu: what error?
05:29:51 * xerox rolls on the floor laughing.
05:30:06 <xerox> I think I found the CRAZIEST way to define `flatten'.
05:30:36 <xerox> Let's do a contest :-)
05:30:54 <jips> is there like a scanf or something?
05:31:13 <adu> ERROR - Unresolved overloading *** Type       : (Ix a, Floating a, Enum a) => Array (a,a) a *** Expression : slogMatrixE 2 
05:31:15 <xerox> jips: you have the Read framework
05:31:32 <jips> xerox: is that builtin to haskell?
05:31:37 <xerox> jips: yup.
05:31:47 <Cale> adu: you're using floating point values as indices somehow
05:31:49 <Cale> ah
05:31:50 <jips> cool, is there a tutorial or something?
05:32:09 <adu> maybe the n-1?
05:32:10 <Cale> apply fromIntegral to your elements
05:32:20 <xerox> jips: that's a good question, I never got around using all the functions proposed.  Let me see.
05:32:22 <Cale> that way, they'll get a separate type
05:32:25 <adu> ok
05:32:42 <Cale> er
05:32:51 <Cale> no, to the parameters, hehe
05:32:52 <jips> xerox: basicly what i need to do is have a file with a bunch of floating point values and load them in
05:33:24 <Cale> array ((1,1),(n,m)) [((i,j), f (fromIntegral i) (fromIntegral j)) | i <- [1..n], j <- [1..m]] where f i j = ...
05:34:00 <xerox> > read "1.1" :: Float
05:34:01 <lambdabot> 1.1
05:34:20 <Cale> adu: the problem is that it's seeing the array indices get used by the function which computes the elements in ways which apply only to floating values, and so it infers that they're floating
05:34:40 <Cale> adu: and then it can't deal with floating point indices for the matrix
05:34:43 <jips> xerox: yeah that's cool but what if i have like a string, "foo = 3.2"?
05:34:43 <adu> wow
05:34:47 <adu> that works
05:35:27 <Cale> jips: there are some really nice parser combinator libraries
05:35:42 <jips> Cale: any of them builtin to haskell other then parsec?
05:35:57 <Cale> jips: well, other than Parsec, GHC comes with ReadP
05:35:58 <xerox> @type System.IO.readFile >>= return . map (read :: String -> Float) . lines
05:35:59 <lambdabot>   Couldn't match `String' against `IO String'
05:35:59 <lambdabot>   Expected type: IO String -> FilePath -> b
05:36:13 <jips> Cale: which is better? :)
05:36:17 <xerox> @type \filename -> System.IO.readFile filename >>= return . map (read :: String -> Float) . lines
05:36:19 <lambdabot> FilePath -> IO [Float]
05:36:21 <xerox> :-)
05:36:23 <Cale> jips: depends on what you want
05:37:14 <Cale> jips: I think Parsec is a little faster usually, and has better error messages, but the <|> combinator (OR of two parsers) is left-biased
05:37:54 <Cale> so in parsec,  string "aa" <|> string "ab" doesn't work right off the bat
05:38:00 <jips> maybe i should just use haskell syntax and use hs-plugins :)
05:38:07 <Cale> hehe :)
05:38:11 <Cale> that's also a possibility
05:38:15 * xerox giggles, thinking of whether let Cale play with his discovery or not, being busy as he is, heh.
05:38:18 <Cale> you could also just do the parsing by hand
05:38:52 <Cale> > break (== "=") "f = 0.365"
05:38:53 <lambdabot> Couldn't match `[Char]' against `Char'
05:38:59 <Cale> > break (== '=') "f = 0.365"
05:39:01 <lambdabot> ("f ","= 0.365")
05:39:09 <xerox> @type break
05:39:10 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
05:39:16 <jips> if i have 4 bytes that represent a single precision floating point number in ieee format, how can i convert it to a Float?
05:39:33 <Cale> jips: 4 bytes as what type?
05:39:36 <adu> so i just do (slogMatrixE 5) ! (j,k) to get stuff?
05:39:40 <jips> Cale: let's say Word8
05:39:53 <jips> or Word32, whatever is easiest
05:40:21 <xerox> > (>>= fix . return) [[1,2,3],[4,5,6],[7,8,9]]
05:40:23 <lambdabot> [1,2,3,4,5,6,7,8,9]
05:40:30 <adu> and (slogMatrixE 5) // (a,b) to set stuff?
05:40:32 <xerox> Dissect it!
05:40:33 <xerox> :-)
05:41:57 <Cale> jips: hmm... ah
05:42:22 <Cale> > decodeFloat pi
05:42:23 <lambdabot> (7074237752028440,-51)
05:42:46 <adu> > decodeFloat (exp 1)
05:42:48 <lambdabot> (6121026514868073,-51)
05:42:58 <Cale> > decodeFloat 1
05:43:00 <lambdabot> (4503599627370496,-52)
05:43:04 <jips> nice :)
05:43:05 <Cale> > decodeFloat 0
05:43:06 <lambdabot> (0,0)
05:43:11 <adu> ??
05:43:13 <Cale> there's also encodeFloat
05:43:31 <jips> > decodeDouble 1
05:43:31 <int-e> xerox: hmm, that's an interesting id
05:43:32 <lambdabot>  Not in scope: `decodeDouble'
05:43:39 <xerox> int-e: id?!
05:43:45 <Cale> @type decodeFloat
05:43:47 <lambdabot> forall a. (RealFloat a) => a -> (Integer, Int)
05:43:47 <xerox> int-e: but yes, very interesting.
05:43:50 <int-e> > (>>= id) [[1,2,3],[4,5,6],[7,8,9]]
05:43:51 <lambdabot> [1,2,3,4,5,6,7,8,9]
05:43:57 <xerox> haha.
05:44:08 <xerox> Right, that's how join is defined.
05:44:35 <xerox> @type (>>= Control.Monad.Fix.fix . return)
05:44:36 <lambdabot> forall (m :: * -> *) b.
05:44:36 <lambdabot> (Monad m, Monad ((->) (m b))) =>
05:44:36 <lambdabot> m (m b) -> m b
05:44:48 <xerox> `Monad ((->) (m b))' bites me.
05:45:11 <Cale> (e -> (e -> a)) -> e -> a
05:45:21 <Cale> is return
05:45:22 <int-e> @type Control.Monad.Fix.fix . return
05:45:23 <lambdabot> forall a. (Monad ((->) a)) => a -> a
05:46:03 <xerox> Hmm.
05:46:06 <int-e> so - as (->) a *is* a monad, that's the identity
05:46:07 <Cale> (a -> (a -> a)) -> a -> a
05:46:21 <xerox> Refuges me atm.
05:46:55 <Cale> > floatDigits pi
05:46:57 <lambdabot> 53
05:47:08 <Cale> > floatRadix pi
05:47:10 <lambdabot> 2
05:47:12 <xerox> > digitsFloat 53
05:47:14 <lambdabot>  Not in scope: `digitsFloat'
05:47:15 <xerox> :D
05:47:27 <Cale> > floatRange pi
05:47:29 <lambdabot> (-1021,1024)
05:47:36 <xerox> @index floatRange
05:47:37 <lambdabot> Prelude
05:47:40 <xerox> foo..
05:47:40 <int-e> ah. the return there is 'const' of course.
05:47:45 <xerox> int-e: is it?
05:47:58 <int-e> > (>>= fix . const) [[1,2,3],[4,5,6],[7,8,9]]
05:47:59 <lambdabot> [1,2,3,4,5,6,7,8,9]
05:48:07 <int-e> xerox: sure, you're using the reader monad
05:48:14 <Saulzar> I think I now have the worlds most unstable collision response system.
05:48:28 <Cale> > (-0) == 0
05:48:30 <lambdabot> True
05:48:45 <Cale> > isNegativeZero (-0) == isNegativeZero 0
05:48:47 <lambdabot> False
05:48:57 <Saulzar> > (1/0) == (1/-0)
05:48:58 <lambdabot>  Not in scope: `/-'
05:49:02 <Saulzar> > (1/0) == (1/(-0))
05:49:03 <lambdabot> False
05:49:12 <Saulzar> Hehe.
05:49:19 <xerox> So instance Monad Reader where return = const ?
05:49:30 <xerox> Hmm, in some sense, I se...
05:49:49 <xerox> I.e. 'the environment doesn't matter' ?
05:50:16 <int-e> yeo
05:50:17 <int-e> p
05:50:24 <Cale> sorry, I'm tired, I was giving the type of join
05:50:43 <Cale> return :: a -> e -> a
05:50:54 <xerox> Yeah.
05:51:21 <Cale> > significand pi
05:51:23 <lambdabot> 0.7853981633974483
05:51:39 <xerox> Where are you finding all those functions? :)
05:51:41 <Cale> > exponent pi
05:51:42 <lambdabot> 2
05:51:46 <Cale> Prelude
05:51:56 <xerox> Cale: also, where is Haskell 1.4 Prelude you were suggesting me to read before?
05:52:23 <Cale> http://www.haskell.org/definition/haskell-report-1.4.ps.gz
05:52:49 <adu> haskell has a big lerning curve
05:53:25 <Cale> adu: doesn't take long before you can do stuff with it, but there's a ridiculous amount of room to learn more stuff
05:53:31 <dons> oh, it's not too hard. there's just lots of stuff up at the far end of the curve. getting most of the way along the curve is pretty easy, I think 
05:55:38 <jips> dons: did you by any chance discover recently a bug in hs-plugins where when the merge has errors the file isn't closed properly?
05:56:16 <dons> hmm. now did someone mention that? who was it?
05:56:26 <jips> jips: me :)
05:56:31 <dons> and noone sent me a test case..
05:56:36 <jips> jips: but you told me to send a test case and i never did
05:57:02 <dons> ah, well. bad jips. send me a test case
05:57:09 <jips> yes sir
05:57:20 <dons> good. just in time for hs-plugins 1.0
05:57:37 <jips> dons: you said something about sending a bug report through darcs or something...
05:58:00 <xerox> Cale: is it today's Haskell?
05:58:06 <dons> oh, no, just mail me the code that is casuing trouble.
05:58:13 <xerox> It seems to be a cool reading.
05:58:21 <Cale> xerox: it's the version just before 98
05:58:34 <Cale> note for instance filter and concat
05:59:39 <dons> I enjoy reading the Gofer source. there's lots of fun stuff in there.
06:00:33 <dons> ah, there: http://www.cse.unsw.edu.au/~dons/standard.prelude
06:00:37 <dons> v1.2
06:00:46 <xerox>  * The fixity of >>= has changed.
06:00:47 <xerox> heh.
06:01:32 <Cale> @index scanl'
06:01:33 <lambdabot> bzzt
06:01:35 <dons> and we have no fst3/snd3/thd3 anymore :/
06:01:56 <dons> (though I note an internal version defined in GHC.PArr)
06:01:56 <Cale> cjustify, ljustify, rjustify :: Int -> String -> String
06:02:01 <Cale> those are handy
06:02:23 <astrolabe> I wondered about making fst and snd work on higher tuples?  Would that be sensible?
06:02:50 <Cale> astrolabe: there'd be a typeclass HasFirst and HasSecond?
06:02:58 <dons> class (Eq a, Text a) => Num a where
06:03:13 <astrolabe> Cale: I guess so.
06:03:47 <Cale>  -- simplified numeric class
06:05:11 <Cale> primitive strict "primStrict" :: (a -> b) -> a -> b
06:05:19 <dons> undefined              :: a
06:05:19 <xerox> > gcd 0 0 
06:05:20 <dons> undefined | False       = undefined
06:05:21 <lambdabot> Exception: Prelude.gcd: gcd 0 0 is undefined
06:05:28 <dons> nice defn of undefined.
06:05:29 <xerox> > lcm 0 0
06:05:31 <lambdabot> 0
06:05:36 <xerox> dons: right on!
06:05:53 <Cale> hehe
06:06:12 <xerox> > atan2 pi
06:06:13 <lambdabot>  add an instance declaration for (Show (a -> a))
06:06:26 <Cale> scanl'           :: (a -> b -> a) -> a -> [b] -> [a]
06:06:26 <Cale> scanl' f q xs     = q : (case xs of
06:06:26 <Cale>                          []   -> []
06:06:26 <Cale>                          x:xs -> strict (scanl' f) (f q x) xs)
06:06:30 <xerox> > atan2 0 1
06:06:31 <lambdabot> 0.0
06:06:33 <Cale> that's just gone entirely
06:06:50 <xerox> class Functor f where
06:06:53 <xerox>     map :: ...
06:06:54 <xerox> !!!
06:06:57 <Cale> right
06:07:13 <Cale> xerox: did you see filter yet?
06:07:16 <dons> and this stuff is always amazing: readFile        :: String ->           FailCont -> StrCont     -> Dialogue
06:07:30 <xerox> Yay, just now, Cale.
06:08:06 <xerox> Cool one.
06:08:14 <Cale> takeUntil!
06:08:18 <dons> yeah !
06:08:20 <xerox> applyM = flip (>>=)
06:08:35 <xerox> applyM = (=<<)
06:08:58 <xerox> No more Eval class too.
06:09:43 <Cale> yeah
06:10:15 <xerox> MonadPlus used 'zero' and '++'
06:10:20 <Cale> hehe, it makes you wonder what they were thinking when writing up Haskell98
06:10:23 <xerox> No sorry.
06:10:25 <xerox> Heh.
06:10:38 <xerox> MonadZero defined 'zero' and MonadPlus defined '++'.
06:10:42 <Cale> Hey, this language has too much cool stuff in it. Let's nerf things a bit.
06:10:58 <dons> hehe
06:11:00 <Cale> xerox: yes
06:11:09 <xerox> asTypeOf O_o
06:11:17 <Cale> asTypeOf is still there
06:11:25 <Cale> @type asTypeOf
06:11:27 <lambdabot> forall a. a -> a -> a
06:11:30 <int-e> . o O ( let's remove lists )
06:12:04 <xerox> D'oh.
06:12:23 <Cale> The idea of removing lists from a lazy functional language is absurd :)
06:12:50 <Cale> It would be like removing loops from C.
06:13:01 <xerox> Reverse was really defined as this, reverse = foldl (flip (:)) [], foo..
06:13:11 <Saulzar> Sounds good. We have arrays right? :)
06:13:24 <dons> @pl foldl (flip (:)) []
06:13:25 <lambdabot> foldl (flip (:)) []
06:13:42 <dons> ah well, we couldn't have asked @pl to write a better defn of reverse now, could we :)
06:13:55 <int-e> @pl reverse
06:13:56 <lambdabot> reverse
06:13:56 <int-e> ;)
06:14:31 <xerox> @pl foldl (flip (:)) []
06:14:32 <lambdabot> foldl (flip (:)) []
06:14:38 <xerox> Heh, anyway...
06:14:41 <dons> I know, let's take Prelude, apply @pl to it, and then use the result as the basis of this language.
06:14:55 <dons> it would be beautifull.
06:15:01 <xerox> Let's put dons in some dark and closed place during the next committee.
06:15:31 <dons> :p
06:15:53 <xerox> 'The committee decided that the language, being function, should be defined only in terms of composition of fuctions, hence everything is written in points-free style'
06:16:07 <Cale> why did they remove the Eval class?
06:16:19 <Saulzar> What about doing that for the language shootout entries?
06:16:29 <Saulzar> As example of "model" haskell code
06:16:42 <Cale> Let's remove explicit application from the language, and only allow composition.
06:16:44 <dons> a lot of the shootout code already does use @pl
06:17:03 <dons> well, the entries that I've worked on, at least.
06:17:05 <Cale> That would be quite ridiculous :)
06:17:07 <Saulzar> Well, another way is to ban lambda expressions from the next standard
06:17:30 <Cale> Yeah, if python is doing it, why can't we?
06:17:34 <Cale> ;)
06:17:37 <dons> yeah, lamdbas are ugly. lets keep the logo though!
06:17:43 <Cale> heh
06:17:48 <Saulzar> Maybe top level functions too, point-free main
06:17:53 <int-e> Cale: do you know unlambda?
06:17:57 <Cale> int-e: yeah
06:18:51 <Cale> why was Eval removed?
06:19:48 <dons> we should read the h98 discussions at some point.
06:20:27 <dons> mmm. tdidn't know that. the Array interface was inplace by 1.2
06:20:42 <Cale> I recall reading them at one point, but that was before I actually knew enough Haskell to appreciate what was going on.
06:20:54 <dons> yeah, same.
06:21:06 <dons> array      :: Ix a => (a,a) -> [Assoc a b] -> Array a b
06:21:22 <dons> data Assoc a b =  a := b
06:21:23 * xerox was young.
06:21:58 <Cale> I want an automatically implicitly derived version of NFData
06:22:06 <Cale> maybe rename things a little
06:22:27 <Cale> and put Control.Parallel.Strategies somewhere more prominent
06:22:27 <xerox> What is NFData?
06:22:34 <dons> "Enhanced prelude for use of overloading with constructor classes". Gofer is fun.
06:22:40 <Cale> @type Control.Parallel.Strategies.rnf
06:22:42 <lambdabot> forall a.
06:22:42 <lambdabot> (Control.Parallel.Strategies.NFData a) =>
06:22:42 <lambdabot> Control.Parallel.Strategies.Strategy a
06:22:57 <xerox> Haskell playing Warcraft?
06:23:08 <Cale> dons: hehe, that's when they still called them constructor classes
06:23:22 <xerox> dons: what is Gofer?
06:23:33 <Cale> a related language
06:23:37 <dons> Mark Jones' Haskell 1.2 impl.
06:24:01 <Cale> it's the G in hugs
06:24:14 <dons> class Monad0 c => MonadPlus c where
06:24:15 <dons>     (++) :: c a -> c a -> c a
06:24:24 <xerox> Duh.
06:24:26 <Cale> hehe, Monad0
06:24:39 <dons> class (Functor left, Functor right) => Adjoint left right where
06:24:47 <Cale> where is that?
06:24:50 <xerox> Adjoint != Bifunctor?
06:24:52 <dons> class (Functor f, Functor g) => NatTransf f g where
06:24:52 <dons>     eta :: f a -> g a
06:24:57 <xerox> BiFunctor, even.
06:25:07 <dons> hang on, i'll post this constructor class prelude
06:25:14 <xerox> Cool.
06:25:35 <Cale> dons: oh, that kind of thing has to go into the next Prelude :)
06:25:47 <dons> http://www.cse.unsw.edu.au/~dons/cc.prelude
06:25:49 <xerox> Nowadays it should be 'NatTransf f g | f -> g' in today's Haskell?
06:26:28 <Cale> beautiful, exactly how I want it
06:26:29 <Saulzar> That's something different, functional dependancies
06:26:44 <Cale> xerox: no, you wouldn't want that dep.
06:26:46 <xerox> Cale: care to elaborate on that?
06:26:51 <dons> this Adjoint class is wacky
06:26:59 <dons> class (Functor left, Functor right) => Adjoint left right where
06:26:59 <dons>     univ    :: (a -> right b) -> (left a -> b)
06:26:59 <dons>     unit    :: a -> right (left a)
06:26:59 <dons>     couniv  :: (left a -> b) -> (a -> right b)
06:26:59 <dons>     counit  :: left (right a) -> aclass (Functor left, Functor right) => Adjoint left right where
06:27:02 <dons>     univ    :: (a -> right b) -> (left a -> b)
06:27:04 <dons>     unit    :: a -> right (left a)
06:27:07 <dons>     couniv  :: (left a -> b) -> (a -> right b)
06:27:14 <Saulzar> xerox, That would mean that g is uniquely determined by f
06:27:20 <Cale> dons: I'm almost certain we'll eventually find some really deep and meaningful applications for that class.
06:27:26 <dons> hehe
06:27:37 <Cale> There are some incredible examples of adjoints in mathematics.
06:27:40 <xerox> Saulzar: I know
06:28:07 <dons> ah, I'd forgotten this notation:  f @@ g            = join . map f . g
06:28:14 <xerox> bind?
06:28:22 <Cale> Kleisli composition
06:28:38 <Cale> a particularly elegant definition of it too
06:28:56 <xerox> @type let join = concat; fmap = map; in \f g -> join . fmap f . g
06:28:57 <lambdabot> forall a a1 a2. (a1 -> [a]) -> (a2 -> [a1]) -> a2 -> [a]
06:29:00 <Cale> (@@) :: Monad m => (a -> m b) -> (c -> m a) -> (c -> m b)
06:29:24 <Cale> class (Functor f, Functor g) => NatTransf f g where
06:29:24 <Cale>     eta :: f a -> g a
06:29:35 <xerox> sheesh, what's eta.
06:29:36 <Cale> I know you pasted that, I'm pasting it again :)
06:29:36 <dcoutts> yo xerox, got half an hour for a cairo-svg api review?
06:29:40 <pierre-> hi all
06:29:44 <xerox> dcoutts: sure!
06:29:44 <Cale> xerox: the greek letter η
06:29:51 <dcoutts> xerox, cool
06:29:52 * xerox stabs Cale
06:30:00 <dons> @djinn f a -> g a
06:30:01 <lambdabot> -- f cannot be realized.
06:30:22 <Cale> xerox: If you have two functors, a natural transformation is a natural way to go from one to the other.
06:31:19 <xerox> Cale: don't you lose information in this transformation?
06:31:22 <Cale> that is, if I have some tree type with data on the leaves, oh,  data Tree a = Branch [Tree a] | Leaf a
06:31:28 <xerox> Yeah.
06:31:34 <Cale> then there's a natural transformation Tree -> List
06:31:44 <dons> getchar = getch       `thenST` \c ->
06:31:45 <dons>           putchar c   `thenST_`
06:31:45 <dons>           returnST c
06:31:45 <Cale> which throws away the tree structure
06:32:32 <Cale> there's also a natural transformation which goes the other way, and imposes some arbitrary regular tree structure
06:32:40 <Saulzar> Hmm, where would you want that in general? (ie. using it with general functors...)
06:33:43 <Cale> Saulzar: well, it gives a name to the general change between various data structures
06:33:46 <Saulzar> I guess it's just a nice consistant interface.. better than a million thisToThat
06:33:51 <Cale> yeah
06:33:54 <xerox> Cale: so there are *many* N.T. Tree -> List
06:34:06 <Cale> xerox: yeah, and the other way
06:34:27 <Cale> xerox: but for Tree -> List, there's only one which you'd normally care about
06:34:32 <xerox> I'd say two
06:34:33 <dons> yeah, eta would be cool.
06:34:43 <xerox> Depth-first and breadth-first.
06:34:55 <Cale> oh, my trees only have values on the leaves
06:35:02 <Cale> but yeah
06:35:48 <xerox> I agree, I usually use those trees too.
06:35:56 <Saulzar> eta sounds like a mathematicians name for it :)
06:36:02 <Cale> It is
06:36:28 <Cale> eta is the usual first variable you choose when you want to name a natural transformation
06:36:38 <xerox> naturalTransformation :: (Functor f, Functor g) => f a -> g a ?
06:36:41 <Cale> interestingly enough, it's also used for return
06:36:45 <Saulzar> I know that - but surely it's quite poor name as a function
06:36:55 <Cale> since return is a perfect example of a natural trans.
06:37:12 <Cale> join (also a natural transformation) is usually called mu
06:37:23 <Cale> Saulzar: why?
06:37:52 <xerox> Hmm.
06:38:01 <xerox> Cale: how is it return a natural transformation?
06:38:07 <Saulzar> Well, you could use greek letter names for everything
06:38:08 <Cale> η . Τμ = μ . μΤ
06:38:08 <xerox> 'f' = Void or something?
06:38:30 <Cale> xerox: It maps from the identity functor to the monad
06:38:39 <Cale> (which is itself a functor)
06:38:42 <xerox> Let's say identity functor, ok.
06:38:53 <Cale> η: 1 -> T
06:39:00 <Cale> μ: T^2 -> T
06:39:07 <xerox> I don't see the first one :-|
06:39:22 <Cale> 1 being the identity functor
06:39:26 <Cale> @type return
06:39:28 <lambdabot> forall (m :: * -> *) a. (Monad m) => a -> m a
06:39:39 <Cale> Surely Identity a is the same as a
06:39:41 <Cale> :)
06:39:49 <xerox> ...the types show how the amount of informations are being constructed, and then `reduce`d.
06:41:23 <Cale> http://en.wikipedia.org/wiki/Natural_transformation
06:41:42 <xerox> Cale: the (^2) part of T^2 has the same meaning of R, R^2, R^3 ?
06:41:53 <Cale> it's repeated application
06:42:01 <Cale> @type join
06:42:02 <lambdabot> Not in scope: `join'
06:42:07 <Cale> @type Control.Monad.join
06:42:08 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
06:42:14 <Cale> m^2 a -> m a
06:42:15 <Cale> :)
06:42:23 <jips> hm... i can't import two packages that have the same name?
06:42:59 <Cale> jips: two modules?
06:43:35 <xerox> Cale: whoopee...
06:44:10 <jips> Cale: yeah, i have a file System.hs that makes module System and i'm trying in it to import System.Plugins
06:44:57 <Cale> oh, you probably shouldn't name your modules the same as existing modules
06:46:19 <dons> jips, your 'System' conflicts with the existing 'System' in the base library
06:47:44 <jips> but what should i do if i want to use the name "System"?
06:48:29 <Cale> MySystem?
06:48:49 <jips> :\ why won't it let me import System.Plugins qualified or as or something?
06:49:23 <dons> that's not the problem. the fact that there's another module, in base, called System.hs is the problem here, as far as I can tell.
06:49:59 <Cale> If you want to use the base libraries, you shouldn't have a module called System
06:50:36 <jips> hm...
06:51:12 <jips> thing is, it would be good to be able to have a hierarchy
06:51:19 <dons> you could put your own module under System.* though. System.MyCcode
06:51:31 <jips> and what you guys are saying is that no where in the "module" hierarchy can i have a module named System
06:51:47 <jips> i can't have Foo.Bar.System
06:51:49 <Cale> you already have one, it's provided
06:51:52 <Cale> ho
06:51:53 <Cale> no
06:51:53 <dons> there's already a root of the hierarchy called System. you can't have two, without hiding one.
06:52:05 <jips> dons: yeah, but why not allow Foo.Bar.System?
06:52:09 <Cale> You can have Foo.Bar.System
06:52:10 <dons> you can have Foo.Bar.System. just not `System'.
06:52:36 <jips> well, i'm using the system of filesystem hierarchy for module paths
06:53:16 <Cale> http://www.qwantz.com/index.pl?comic=352 -- heh
06:53:37 <dons> you would need to create the F/G/System.hs and use: module F.G.System where
06:53:57 <dons> then import F.G.System in other modules. that's all ok.
06:54:21 <Cale> the next is also amusing :)
06:56:45 <jips> hm.... ok thanks
06:57:12 <araujo> Hello.
07:19:16 <pierre-> hm... i've got some strange idea 
07:19:30 <basti_> don't worry, thats normal
07:19:50 <SamB> is it a scheme to revive Self?
07:20:22 <pierre-> is it possible to build cpu architecture optimized for functional programming? 
07:20:43 <chucky> pierre-: Ever heard of Lisp machines?
07:20:51 <pierre-> yes :-)
07:21:14 <SamB> that isn't the same kind of "functional"
07:21:41 <chucky> true
07:21:48 <SamB> personally, I think normal CPU architectures with clever tricks work better...
07:21:50 <pierre-> they supported lisp this hardwarelly? 
07:21:55 <twb`> Possibly you could implement S and K in hardware.
07:22:00 <neologism> iirc lisp machines were normal cpus with clever trics
07:22:05 <SamB> oh?
07:22:11 <twb`> pierre-: yes, LispM boxes evaluated lisp in hardware.
07:22:58 <SamB> neologism: why call them "lisp machines", then?
07:23:28 <neologism> cause the clever tricks let lisp evaluation be very fast?
07:23:33 <pierre-> twb`: interesting... i thinked it's not possible
07:23:47 <twb`> pierre-: why do you say that?
07:24:34 <neologism> there were macintoshes iirc
07:24:41 <pierre-> twb`: in my view lisp is too high level language for direct hw evaluation
07:24:51 <twb`> pierre-: that is silly.
07:24:55 <lennart> Lisp machines and similar machines were interesting in their time when the limiting factor was the CPU speed.
07:25:06 <neologism> http://fare.tunes.org/LispM.html
07:25:15 <twb`> pierre-: about 90% of commercial lisp environments are written in Lisp, and the rest in C and assembly.
07:25:20 <SamB> the limiting factor is what now?
07:25:30 <lennart> Memory references.
07:25:39 <twb`> lennart: agreed.
07:25:51 <lennart> Unless you have something very FP intensive.
07:25:58 <SamB> hmm
07:26:01 <Saulzar> Memory references?
07:26:09 <SamB> Saulzar: reads/writes
07:26:10 <Heffalump> yes, reading and writing to memory
07:26:11 <lennart> loads and stores
07:26:16 <lennart> very expensive
07:26:27 <Heffalump> when did FPCA get renamed to ICFP?
07:26:28 <twb`> It does depend on what work you're doing, but most of it is memory-bound these days.
07:26:47 <lennart> Heffalump: 1995 was the last FPCA
07:27:03 <Heffalump> was there any argument about the name change?
07:27:04 <SamB> its especially nasty when you don't have enough memory
07:27:37 <lennart> Heffalump: No, most people agreed that CA was not really relevant in the title anymore
07:28:04 <lennart> Heffalump: there was a lot of discussion about what the new name would be
07:28:10 <twb`> "This was originally envisaged as a way to implement FunctionalProgramming languages efficiently. However, it turned out to be a rather bad representation for implementation on stock hardware. Nowadays, industrial-strength FPL implementations rewrite LambdaCalculus expressions into SuperCombinators."
07:28:13 <twb`> http://c2.com/cgi/wiki?EssAndKayCombinators
07:28:14 <SamB> what did it stand for?
07:28:47 <lennart> Functional Programming and Computer Architecture
07:28:54 <SamB> ah.
07:29:23 <lennart> it was every other year.  on alternate years there was L&FP, LISP and Functional Programming
07:30:04 <lennart> Burroughs built a combinator machine in the mid 80ies
07:30:44 <lennart> Many years later I met one of the guys who had worked on it.  He (jokingly) accused me of putting hi out of his job.
07:30:59 <Saulzar> twb`, I wonder if lambdabot uses something similar...
07:31:07 <SamB> even if special FP hardware *could* be more efficient, there are economies of scale that would make stock hardware faster...
07:31:11 <Heffalump> by writing efficient compilers for "normal" hardware?
07:31:27 <SamB> plus nobody wants computers that run just FP code...
07:31:55 <Saulzar> They would if it completely whiped the floor of traditional computers... but that seems hard :)
07:32:02 <lennart> people just didn't realize that you could compile FP efficiently in those days
07:32:46 <SamB> Saulzar: you think they want to give up their MP3 players and web browsers and C libraries just to run pure FP code faster?
07:33:21 <lennart> SamB: but we want all those applications written with FP!
07:33:23 <SamB> granted, those web browsers probably shouldn't be written in C++...
07:33:46 <SamB> lennart: how are you going to do FPS that way?
07:34:16 <SamB> what about your GL?
07:35:46 <Saulzar> Well, clearly it would involve some "minor" architectural changes ;)
07:36:24 <jips> frag!
07:37:07 <lennart> FPS?
07:37:14 <Saulzar> jips, Tetris?!
07:37:18 <SamB> Fast Packed Strings
07:38:00 <lennart> Oh, I don't mind some primitives like arrays in the state monad.
07:38:45 <lennart> As for graphics, I think most of that would be much more elegantly expressed with FP.  And as efficient with the right compilers
07:39:03 <lennart> It's just "signal processing" after all
07:39:26 <lennart> Conal Elliot is doing some interesting stuff on this
07:40:01 <SamB> right compilers? to FP arches?
07:40:09 <SamB> you must be joking!
07:42:52 <Saulzar> If people devoted the same time to a system as say... C# .NET and Windows, I'm sure it's not impossible
07:42:57 <jips> Saulzar: :O
07:44:02 <jips> thing is, there still are those apps where people still even use assembly language for performance
07:44:07 <jips> like video decoding and shit
07:44:58 <twb`> 02:30 <SamB> Saulzar: you think they want to give up their MP3 players and web browsers and C libraries just to run pure FP code faster?
07:45:20 <twb`> SamB: it could be a coprocessor, like having a coprocessor for graphics or memory management.
07:45:36 <SamB> coprocessor?
07:45:56 <SamB> those are so annoying to work with...
07:47:43 <SamB> except when you get to write code that only has to run on one system, and the coprocessor gets to mostly just do its own thing...
07:54:26 <jips> efd
08:54:24 <palomer> http://www.rafb.net/paste/results/tXlrYW80.html <--anyone have any idea about this type error?
08:56:43 <Saulzar> Use a type signature for one :P
08:57:28 <Saulzar> (Not that it nesescarily will help with the error, but certainly help track it down)
08:58:03 <palomer> yeah
08:58:43 <int-e> well, the getConstraints should be run inside the monad instead of being used as a normal function in the return
08:59:15 <int-e> I suppose
09:01:24 <palomer> yeah
09:02:00 <xerox> palomer: you can use pattern matching if you want here:
09:02:09 <xerox> getNext = do (x:xs) <- get
09:02:18 <xerox>              put xs
09:02:21 <xerox>              return x
09:29:42 <astrolabe> I'm buying some stuff from amazon.  I thought maybe I'd get a programming or CS book.  Does anyone have any ideas?  I've got 'The Haskell school of expression', The report and a couple of functional data-structure books.
09:32:20 <JKnecht> Best new stuff tends to be online. Maybe classics like Art of Computer Programming which aren't.
09:32:39 <astrolabe> That's a thought.
09:34:02 <astrolabe> I was wondering about something more theoretical.  A textbook explaining fixed points, the link to category theory, that isomorphism between programs and proofs.
09:34:31 <JKnecht> that kind of stuff is better gotten from academic publishers.
09:34:54 <astrolabe> why do you say that?
09:36:02 <JKnecht> by better I meant available. I do see such titles in places the Strand in NYC and such like so could be on Amazon, but tend to doubt it and your best selection would be elsewhere.
09:36:44 <JKnecht> OTOH once a title reaches a certain level, Amazon and the like does become an option.
09:36:49 <astrolabe> I suspect amazon do a full range.  I've got a few Springer titles from amazon with no problems.
09:37:18 <astrolabe> Including categories for the working mathmo :)
09:38:48 <sieni> JKnecht: why? I have always bought my math books from amazon
09:38:58 <JKnecht> hmm, they (Amazon) have both the mentioned work by Knuth and the Handbook of Mathematical Logic, but those are both definitely at the classic level.
09:41:40 <JKnecht> yeah, I guess near full reversal on what I said, subject to degree of original distribution from the publisher, in which case it couldn't have reached a point in the Amazon tree.
09:45:13 <JKnecht> s/couldn't/might not have/
09:47:48 <JKnecht> "Behind Deep Blue" and "Geography of Thought" are also titles I've recently got/reccommend.
09:49:28 <astrolabe> GoT looks interesting.
10:00:32 <Mitar> what :+: means in: data Expr = Value Int | Expr :+: Expr
10:00:37 <Mitar> is this correct syntax?
10:01:11 <Lemmih> Yes.
10:01:21 <Lemmih> It's an infix data constructor.
10:03:00 <Mitar> interesting
10:03:01 <Mitar> thanks
10:04:14 <palomer> will it be printed as infix?
10:05:52 <astrolabe> printed?
10:06:10 <palomer> when deriving Show
10:06:13 <palomer> cool, it will
10:06:24 <palomer> and, erm ,is it left or right associative?
10:06:28 <palomer> (can I choose this?)
10:06:42 <Heffalump> you can use an infix declaration to choose it, yes
10:07:10 <xerox> infix <op> <n>
10:07:16 <xerox> ...or <n> <op>
10:07:25 <xerox> or even infixl or infixr
10:07:53 <palomer> there should be a way to deal with ternary operators
10:08:30 <Saulzar> 2D layout? You can have 4 that way - left right up and down
10:09:03 <palomer> oh, that would be interesting
10:09:04 <Saulzar> Maybe 8 if you use diagonals - 26 if you go to 3D screens
10:09:11 <xerox> Saulzar: hah, cool.
10:09:26 <palomer> so infix dataconstructors have to be surrounded by : :, right?
10:09:26 <basti_> >_<
10:09:28 <xerox> 2D layout sounds like something worth trying playing with.
10:09:35 <basti_> palomer: they start with :
10:09:43 <xerox> Saulzar: even thought writing some Haskell app to try to combine Haskell 2D?
10:11:09 <palomer> data Type = IntType | Type :-> Type Type deriving Show <---this should be legal haskell!
10:11:19 <Saulzar> Hmm, then you can write software with drag and drop. Well, I've seen such things for shading language editors
10:11:26 <xerox> :->: ?
10:11:31 <palomer> ?
10:11:37 <xerox> Ah, d'oh.  Should it?
10:12:02 <xerox> What does Type Type mean?
10:12:16 <palomer> that would mean :-> is a ternary operator
10:12:32 <palomer> so you'd have to write (IntType :-> IntType IntType)
10:12:42 <xerox> I don't think there are ternary operators at all
10:12:52 <Saulzar> You just want the smiley face operator don't you?
10:12:54 <xerox> How do they act wrt currying?
10:13:35 <Saulzar> What is an example of a ternary operator?
10:13:57 <xerox> Saulzar: let's do 2D code composition.
10:14:08 <palomer> hrmphrm
10:14:12 <palomer> ?:
10:14:30 <palomer> Type = IntType | IntType ? IntType : IntType
10:14:42 <xerox> Foo...
10:14:49 <Saulzar> Hmm
10:14:56 <palomer> Term = ... | If Term then Term else Term
10:15:28 <Saulzar> The trouble is that haskell already has 2D stuff...
10:16:05 <xerox> Saulzar: hmm?
10:16:11 <xerox> Arrows?
10:16:40 <Saulzar> I meant if you were to try and do it with text layout, it would mess up the existing layout stuff
10:17:05 <Saulzar> I guess you do it with a pre-processor with a graphical editor or something to make it even slightly sane 
10:17:32 <xerox> Yeah, that's what I was thinking about
10:17:39 <xerox> Something where you can drag stuff around
10:17:43 <xerox> And connect it
10:18:47 <palomer> we already have haskell2d?
10:18:48 <palomer> where?
10:19:09 <Saulzar> In the air
10:23:28 <Saulzar> Hmm, reminds me of some more mainstream "AI game" types... where all the coding was done by connecting some boxes with arrows everywhere
10:23:42 <palomer> what's the easiest way to ++ a list of things?
10:23:54 <Saulzar> ??
10:23:55 <ndm> palomer, concat
10:24:09 <palomer> I remember there was something in one of lists typeclasses...
10:25:05 <palomer> I want to do return $ concat (map foo [a,b,c])
10:25:07 <palomer> but foo is monadic
10:25:40 <Saulzar> mapM ?
10:25:41 <int-e> palomer: hmm. liftM concat $ mapM foo [a,b,c] ?
10:25:55 <xerox> int-e: is right I think
10:26:05 <ndm> return $ concatMap foo [a,b,c] is an option
10:26:16 <xerox> Well, Saulzar too, heh.  I was noting that \f -> concat . (map f) is >>=.
10:26:22 <int-e> ndm: not if foo is monadic
10:26:24 <palomer> http://www.rafb.net/paste/results/F169d145.html <--this is what I'm trying to do
10:26:33 <ndm> oh, yeah - woops
10:26:58 <Heffalump> quick, someone write concatMapM
10:27:27 <int-e> @pl concatMapM f = liftM concat . mapM f
10:27:28 <lambdabot> concatMapM = (fmap join .) . mapM
10:27:55 * palomer feels that monads make us duplicate code
10:28:05 <int-e> argh. no! they're not the same monads!
10:28:22 <xerox> @type fmap join
10:28:23 <lambdabot> Not in scope: `join'
10:28:27 <xerox> @type fmap Control.Monad.join
10:28:29 <lambdabot> forall (f :: * -> *) (m :: * -> *) a.
10:28:29 <lambdabot> (Functor f, Monad m) =>
10:28:29 <lambdabot> f (m (m a)) -> f (m a)
10:28:32 <xerox> foo...
10:28:40 <xerox> @type (fmap Control.Monad.join .)
10:28:42 <lambdabot> forall (f :: * -> *) (m :: * -> *) a a1.
10:28:42 <lambdabot> (Functor f, Monad m) =>
10:28:42 <lambdabot> (a1 -> f (m (m a))) -> a1 -> f (m a)
10:28:53 <xerox> @type (fmap Control.Monad.join .)  . mapM
10:28:55 <lambdabot> forall a a1 (m :: * -> *).
10:28:55 <lambdabot> (Functor m, Monad m) =>
10:28:55 <lambdabot> (a1 -> m [a]) -> [a1] -> m [a]
10:29:01 <xerox> Wah.
10:29:07 <int-e> hmm.
10:29:49 <palomer> why do I get the feeling that monads are simply a way to rewrite terms so that control is explicit?
10:30:08 <xerox> Because that's one side of the coin, I'd say.
10:30:15 * int-e is impressed
10:30:42 <int-e> @pl (liftM f) . g
10:30:43 <lambdabot> fmap f . g
10:31:04 <xerox> well
10:31:06 <xerox> @pl liftM
10:31:07 <lambdabot> fmap
10:31:08 <xerox> you see.
10:31:38 <int-e> it rewrites concat to join. I should know that by now.
10:31:53 <int-e> @pl concat
10:31:54 <lambdabot> join
10:32:05 <xerox> int-e: AH!  Right on.
10:33:27 <Saulzar> @pl concatMap
10:33:28 <lambdabot> (=<<)
10:34:16 <int-e> @pl map
10:34:17 <lambdabot> map
10:34:19 <int-e> @pl fmap
10:34:20 <lambdabot> fmap
10:35:32 <palomer> there should be monad application
10:35:52 <palomer> a @ b == let temp <- a in temp b
10:36:06 <palomer> or something
10:36:49 <int-e> @pl a @ b = a >>= ($ b)
10:36:49 <palomer> actually, make that a @ b == do {t1 <- a; t2 <- b; return $ t1 t2}
10:36:50 <lambdabot> (line 1, column 7):
10:36:50 <lambdabot> unexpected "="
10:36:50 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
10:36:57 <int-e> @pl x a b = a >>= ($ b)
10:36:58 <lambdabot> x = (. flip id) . (>>=)
10:37:51 <int-e> @pl x a b = a >>= \a' -> b >>= \b' -> return $ a' b'
10:37:52 <lambdabot> x = (. ((. (return .)) . (>>=))) . (>>=)
10:38:03 <int-e> ugly :)
10:38:15 <xerox> liftM2
10:38:29 <xerox> @pl x a b = a >>= \a' -> b >>= \b' -> return (a',b')
10:38:29 <lambdabot> x = liftM2 (,)
10:39:00 <int-e> @pl x a b = a >>= \a' -> b >>= \b' -> return $ a' $ b'
10:39:01 <lambdabot> x = (. ((. (return .)) . (>>=))) . (>>=)
10:39:03 <xerox> @pl x f a b = a >>= \a' -> b >>= \b' -> return $ f a' b'
10:39:04 <lambdabot> x = liftM2
10:39:17 <int-e> @pl x a b = a >>= \a' -> b >>= \b' -> return $ a' + b'
10:39:17 <lambdabot> x = liftM2 (+)
10:39:28 <xerox> right.
10:39:53 <Saulzar> @pl x a b = a >>= \a' -> b >>= \b' -> return $ (a' $ b')
10:39:54 <lambdabot> x = (. ((. (return .)) . (>>=))) . (>>=)
10:40:04 <basti_> what is that going to be?
10:40:20 <int-e> apparently, $ is just syntax for the pointless plugin
10:40:25 <Saulzar> @pl liftM2 ($)
10:40:26 <lambdabot> ap
10:40:26 <xerox> x = liftM2 ($)
10:40:29 <xerox> Yes.
10:40:44 <xerox> @type Control.Monad.ap
10:40:46 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
10:40:51 <xerox> @type (. ((. (return .)) . (>>=))) . (>>=)
10:40:52 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m (a -> b) -> m a -> m b
10:41:19 <palomer> why isn't ap infix :o
10:41:32 <int-e> `ap` is
10:42:09 <xerox> > [(+),(*)] `ap` [1,2,3] `ap` [3,2,1]
10:42:10 <lambdabot> [4,3,2,5,4,3,6,5,4,3,2,1,6,4,2,9,6,3]
10:43:01 <palomer> hah
10:45:03 <arjanb> palomer: http://www.cs.nott.ac.uk/~ctm/IdiomLite.pdf
10:49:53 <CosmicRay> FFI question.  How can I pass, to a C function that expects a pointer, the equivolent of the C expression ((void *) 3) from Haskell?
10:50:39 <Igloo> You have to do nasty things
10:51:00 <Heffalump> what's wrong with unsafeCoerce of an Int# ?
10:51:25 <CosmicRay> ah, well that's the sort of option I was looking for ;-)
10:51:25 <Igloo> Int is not necessarily the same size as (void *)
10:51:30 <CosmicRay> though that sounds nasty
10:51:41 <CosmicRay> indeed, it's different on Alpha, for instance
10:51:53 <Heffalump> if you're doing that kind of shit you probably know that it is :-)
10:52:02 <Igloo> I did "plusPtr nullPtr 3" when I wanted to do something similar
10:52:17 <CosmicRay> ahh, good thought.
10:52:26 <Heffalump> that's not nasty
10:52:35 <Igloo> Heffalump: The problem is C APIs that take either a pointer or a special few values that they assume aren't valid pointers
10:52:46 <Igloo> Assuming nullPtr+3 == 3 isn't nasty?
10:52:56 <Heffalump> ah, fair point
10:53:13 <Heffalump> actually, no. It's no more nasty than (void*) 3
10:53:24 <CosmicRay> I'll just write a C wrapper maybe.
10:53:46 <Saulzar> It's the C api which is nasty
10:53:50 <Igloo> There's nothing wrong with (void*) 3 except the assumption it can't be a valid pointer
10:53:54 <Igloo> AFAIK, anyway
10:54:08 <Saulzar> Substituting pointers and values is terrible
10:54:17 <basti_> the null pointer doesn't have to have numerical value 0 btw.
10:54:32 <basti_> Saulzar: why? memory cells and natural numbers are both countable
10:54:36 <Igloo> Yes, that's why the Haskell is a nasty hack (aroudn the C nasty hack)
10:54:36 <Saulzar> Is there any imp you know of which doesn't? :)
10:54:43 <ibid> the null pointer doesn't have to have the _bit pattern all zero_
10:55:00 <Heffalump> it can never be valid C to cast an integer that didn't originally come from a pointer to a pointer.
10:55:02 <ibid> but the null pointer is always obtainable by (void*)0 regardless of the bit pattern
10:55:03 <Igloo> but it's the best I came up with when I needed to do it
10:55:12 <Saulzar> basti_, It works but it's just ugly ..
10:55:14 <Heffalump> And since 3 itself clearly didn't come from a pointer, it's evil
10:55:19 <ibid> Heffalump: except when the integer is the constant 0
10:55:23 <Heffalump> yes, sorry
10:55:25 <Igloo> Heffalump: Even if you don't want to dereference it?
10:55:30 <int-e> > let ap' = liftM2 $ flip ($) in [1,2] `ap'` ([2,3] `ap'` [(+),(*)])
10:55:32 <lambdabot> [3,2,4,3,4,4,5,6]
10:55:41 <Heffalump> oh, true
10:55:41 <ibid> but yeah, (void*)3 is nasal demon territory
10:55:59 <Heffalump> but using them as distinguished values that will never overlap with real pointers is also outside the standard
10:56:05 <CosmicRay> that's what certain constants in the ODBC API evaluate to, so blame microsoft
10:56:08 <Heffalump> so what remaining use is there?
10:56:15 <Igloo> Anyway, the Haskell is clearly going to be at least as bad as the C, and I don't know of a way to do it that isn't worse  :-)
10:56:28 <ibid> the C standard also allows for (void*)3 making no sense
10:56:46 <ibid> the pointers don't need to be isomorphic to an integer subrange
10:57:08 <CosmicRay> the function that takes this has another parameter that says what the void * value is to be interpreted as.
10:57:16 <CosmicRay> in this case, it will never be interpreted as a pointer.
10:57:20 <Heffalump> so why not pass a union?
10:57:33 <CosmicRay> Heffalump: ask microsoft
10:57:57 <CosmicRay> this isn't my api 
10:58:48 <Saulzar> Seems to happen when there is an old API and they think "Hmm, how can we extend this and change nothing?"
10:58:56 <CosmicRay> heh
10:59:13 <CosmicRay> Saulzar: I think that microsoft designs things to be crufty right out of the box ;-)
10:59:16 <Saulzar> There are OpenGL extensions which do the same thing, icky
11:00:22 <palomer> http://www.rafb.net/paste/results/5pQ5xp72.html
11:00:29 <palomer> infinite loop problem
11:00:54 <palomer> which doesn't make sense, because I'm always calling the function with a term of smaller size
11:01:11 <ibid> (consider, for example, an architecture where memory is two-dimensional; each time you ask the OS for some memory, you get an area (x,0)..(x,k), and (x,k+1) is not accessible. the mapping from these pairs to the actual 1D memory is private to the OS. what does (void*3) mean?)
11:01:32 <Aaargh> Hi
11:01:47 <ibid> palomer: language: c++?:)
11:02:00 <palomer> ibid: eh?
11:02:07 <int-e> ibid: the best you could hope for is to cast it back to an int and get 3 ... but even that may not be true for some architectures
11:02:16 <palomer> oh, right
11:02:17 <Lemmih> Hi Aaargh.
11:02:28 <Aaargh> I'm trying to learn haskell and one of the exercises in my book is driving me crazy.
11:02:32 <ibid> int-e: i think i just described one :)
11:02:50 <ibid> btw, there are even architectures where even loading an invalid pointer causes a trap
11:02:52 <Saulzar> ibid, Er - I think that would break just about every C program ever written
11:02:54 <Aaargh> can anyone take a look at my attempt and tell me what my thinko is ?
11:03:00 <Lemmih> Aaargh: Sure.
11:03:06 <int-e> ibid: that depends on which level the cast is done in
11:03:09 <Aaargh> one sec, I'll post the code to a .html 
11:03:13 <ibid> Saulzar: not standards-compliant programs
11:03:16 <Lemmih> lisppaste2: url
11:03:18 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
11:03:25 <Lemmih> Aaargh: You can use that.
11:03:37 <Saulzar> ibid, How is pointer++ defined in the 2D case?
11:03:52 <ibid> Saulzar: (x,y) -> (x,y++), naturally
11:04:04 <ibid> err, y+1
11:04:15 <Saulzar> Hmm
11:05:09 <ibid> Saulzar: the c standard only allows that when the pointer points to an array and both the old and the new values of the pointer variable are in bounds for the variable (or off by one at the high end)
11:05:24 <Aaargh> ok. here it is: http://130.89.164.246/~aaargh/haskell.html
11:05:47 <Aaargh> Lemmih: ah, too late :-P
11:06:33 <xah> can haskell drive postgre?
11:06:34 <int-e> Aaargh: function application binds stronger than binary operators
11:06:35 <Lemmih> arjanb: 'iter n-1 f x' == '(iter n) - (1 f x)'
11:06:43 <dcoutts> xah, yes
11:06:52 <Lemmih> Aaargh: You need 'iter (n-1) f x'.
11:06:59 <xah> dcoutts: really or academically?
11:07:02 <Aaargh> ah
11:07:07 <ibid> dcoutts: seen unbounded yet? :)
11:07:24 <xah> dcoutts: i'm new to haskell
11:07:25 <Aaargh> let's try that.
11:07:42 <ibid> xah: for some values of "really", at least, yes
11:07:52 <Aaargh> Doh!, works :) 
11:08:02 <xah> ibid: url please?
11:08:07 <Aaargh> thanks!
11:08:12 <ibid> xah: for what?
11:08:21 <xah> ibid: the library to do it or such...
11:08:26 <palomer> found my error
11:08:28 <ibid> xah: CosmicRay's hdbc might work
11:08:33 <palomer> I keep using runState instead of evalState
11:08:34 <Lemmih> @where HDBC
11:08:34 <lambdabot> I know nothing about hdbc.
11:08:54 <ibid> xah: it has a postgres driver. i haven't tried that myself, though
11:08:55 <Lemmih> @where+ HDBC darcs get --partial http://darcs.complete.org/hdbc
11:08:55 <lambdabot> Done.
11:09:02 <Heffalump> what is the relationship between hdbc and hsql?
11:09:08 <xah> “might work”? does that mean i have to hack much like to get it to work?
11:09:13 <CosmicRay> Heffalump: there isn't one really
11:09:29 <Lemmih> xah: HDBC /does/ work.
11:09:32 <Heffalump> what does hdbc actually do? Connect to a database via the ODBC interface?
11:09:35 <ibid> xah: that means that i have no personal experience. i'd say "ought to work",, really
11:09:38 <CosmicRay> Heffalump: there are a few ideas from hsql that are present in hdbc, but really I wanted hdbc to avoid what I consder some design flaws in hsql
11:09:39 <dcoutts> ibid, unbounded?
11:09:48 <Heffalump> what flaws?
11:09:49 <ibid> dcoutts: my gtk2hs-based game :)
11:09:52 <CosmicRay> Heffalump: it's similar to perl's DBI or java's JDBC
11:09:53 <xah> there's no proper sites? just a depository?
11:09:53 <dcoutts> xah, there's HDBC and HSQL
11:09:54 <Heffalump> (is there a document somewhere I could read?)
11:09:57 <dcoutts> ibid, cool
11:10:01 <ibid> dcoutts: which i hacked on during the holidays
11:10:02 <dcoutts> @where HDBC
11:10:03 <lambdabot> darcs get --partial http://darcs.complete.org/hdbc
11:10:09 <dcoutts> @where HSQL
11:10:09 <lambdabot> http://htoolkit.sourceforge.net
11:10:17 <CosmicRay> the HDBC download site is http://quux.org/devel/hdbc
11:10:24 <CosmicRay> end-users should use that instead of the darcs repos
11:10:36 <Lemmih> @where+ HDBC http://quux.org/devel/hdbc
11:10:37 <lambdabot> Done.
11:10:45 <cinema> dcoutts, have you considered a real arrow front-end for gtk2hs ?
11:10:51 <CosmicRay> Heffalump: I wrote an e-mail about that, just  bit...
11:11:08 <dcoutts> cinema, I'd like one, though I'm not writign one myself
11:11:12 <pierre-> > 2 + 2
11:11:14 <lambdabot> 4
11:11:23 <cinema> dcoutts, I am (re)working on arrows at present, and it is really powerful
11:11:25 <ibid> dcoutts: http://antti-juhani.kaijanaho.info/newblog/archives/23 <- this is my first post about it. see the pingbacks for more
11:11:28 * dcoutts will be back soon
11:11:36 <palomer> woot
11:11:37 <CosmicRay> heffalump: http://article.gmane.org/gmane.comp.lang.haskell.general/12911
11:11:39 <palomer> finished my constraint generator
11:11:41 <cinema> dcoutts, I am (re)working on arrows at present, and it is really powerful
11:11:42 * palomer does a dance
11:11:53 <CosmicRay> Heffalump: I am working on an odbc backend for hdbc right now
11:11:54 <palomer> cinema: are arrows as intuitive as monads?
11:12:00 <CosmicRay> Heffalump: I hope to have a first version completed later today.
11:12:48 <CosmicRay> I have postgresql and sqlite3 drivers written already, both of which pass a fairly extensive test suite.
11:13:04 <CosmicRay> I'll probably do a mysql driver if there's demand for it, even though I have no use for it myself.
11:13:26 <CosmicRay> or someone else could.
11:16:14 <Heffalump> CosmicRay: ta.
11:16:17 <Heffalump> (for the URL)
11:16:20 <cinema> palomer, arrows are more diificult than monad, but very powerful
11:16:30 <Heffalump> I like the idea of prepared queries, so I'd probably switch if you made a mysql driver.
11:17:07 <CosmicRay> mysql is going to be a trick due to its uneven support for transactions.
11:17:31 <CosmicRay> it's the only database I've seen that supports transactions "sometimes".
11:18:08 <jyp> flip a coin. on head, rollback.
11:18:16 <xah> CosmicRay: mysql is a criminal software
11:18:21 <CosmicRay> hehe
11:18:40 <JKnecht> CosmicRay: are you using unixodbc?
11:18:44 <sieni> of course one should only use innodb tables with mysql
11:18:46 <pierre-> someone here works with visual haskell?
11:18:48 <CosmicRay> JKnecht: yes
11:19:10 <JKnecht> Thank You (for using unixodbc).
11:19:35 <CosmicRay> JKnecht: of course, in theory, this should also be compatible with MS ODBC, Merant ODBC, iODBC, etc.
11:19:45 <CosmicRay> but I'm using unixODBC for my development work.
11:19:49 <jips> CosmicRay: do you know microsoft access?
11:20:12 <CosmicRay> jips: no
11:20:13 * JKnecht does.
11:20:32 <jips> JKnecht: if i want to access an oracle database from microsoft access then i *must* have the oracle client software installed, right?
11:21:10 <JKnecht> not necessarily. Loads of Oracle drivers come bundled IIRC, been a few years since I used with Oracle.
11:21:42 <jips> JKnecht: yeah, there's this ms oracle obdc thing that's bundled but it still depends on oracle client
11:21:46 <JKnecht> i.e. yes you must have ODBC drivers ...
11:21:59 <JKnecht> but if you have Oracle it probably provided some.
11:22:23 <jips> JKnecht: problem is i can't install the oracle client software
11:22:29 <JKnecht> why not?
11:22:36 <jips> not allowed
11:22:49 <jips> this is the most f*cked up organization ever
11:22:52 <JKnecht> then you wouldn't have access to the data either prolly.
11:23:00 <jips> JKnecht: i have access
11:23:41 <JKnecht> you can probably get a client that will work with Access if you have the access rights by scrounging around.
11:24:15 <jips> there is the oracle server and i have a user that can access the database
11:24:25 <jips> i have a local pc workstation that i am administrator of
11:24:44 <jips> there's this shitty java app that accesses the oracle database
11:24:54 <jips> but i need to use microsoft access
11:25:05 <JKnecht> ah but it might use JDBC.
11:25:05 <jips> problem is the oracle client stuff isn't installed on the pc so it doesn't work
11:25:11 <jips> JKnecht: yeah, could be
11:25:24 <jips> JKnecht: it seems to use this oracle java product called jiniator or something
11:25:51 <jips> and when the java app throws an exception i see that it's using things like java.oracle.connection
11:27:16 <JKnecht> if this were unix you could get free/eval stuffs from Oracle, that might also work elsewhere. I've only ever used JDBC and that always in conjunction with a web server.
11:27:57 <JKnecht> bottom line is that if it is an institutional datastore, it's owners must provide basic access/tools.
11:28:32 <JKnecht> s/institutional/organizational/
11:28:50 <jips> well, if i were able to install the oracle client software then i think that microsoft's oracle obdc driver would work
11:29:29 * araujo just uploaded new hashell version
11:29:39 <araujo> let's hope those bugs are properly fixed :-]
11:29:47 * Saulzar looks at the time 8:28, must be about sleep time
11:30:14 * palomer doubts haskell is the best language for a shell
11:30:21 <Saulzar> araujo, Cool
11:32:13 <dcoutts> cinema, is any of your gui arrow code available? or some demo code?
11:32:22 <JKnecht> jips: just checked and MS Access comes out the box with an Oracle Driver. If you don't have it was removed.
11:32:48 <jips> JKnecht: yeah, it has a driver for oracle but it relies on the oracle client software for the actual connection
11:33:27 <Saulzar> araujo, Might be extremely useful - I always seem to type :t .... in bash, and ls in ghci :)
11:34:23 <dcoutts> ibid, it looks nice, I'll take a look at the code...
11:35:14 <araujo> Saulzar, :-]
11:37:19 <JKnecht> jips: right. Your java app being able to access doesn't imply that your workstation can directly connect to the server.
11:37:31 <dcoutts> ibid, I've got a technique for avoiding having a record of IORefs for the state if you're interested
11:37:41 <araujo> palomer, don't underestimate it!
11:37:51 <Mitar> agh, i read the yet another tutorial and started writing simple program and stuck almost immediately
11:38:02 <jips> JKnecht: well i theoretically can connect since i can connect with telnet to the server :)
11:38:08 <Mitar> i would like to parse a, or "die" if it is not a
11:38:09 <Mitar> http://pastebin.com/495312
11:38:35 <dcoutts> ibid, basically instead one uses a record of ordinary values and a thread which runs in a loop modifying that state each iteration. It gets it's input over a channel.
11:39:08 <dcoutts> so one runs actions :: State -> IO State
11:39:25 <JKnecht> jips: not the same as Oracle accepting a connection though.
11:39:33 <ibid> dcoutts: i'm aware with that technique :)
11:39:39 <dcoutts> ibid, by posting them to the channel and then the other thread runs them and maintains the state
11:39:39 <ibid> of. i'm aware of.
11:39:42 <dcoutts> ibid, ok :-)
11:40:02 <jips> JKnecht: ok well i'm pretty sure that if i were to install the oracle client software, i would be able to connect using it's sql*plus program
11:40:03 <ibid> hmm. you seem to have a fetish with threads, dcoutts :)
11:40:08 <dcoutts> ibid, heh
11:40:23 <ibid> i, on the other hand, prefer to avoid them when there is no compelling reason to use them
11:40:26 <dcoutts> ibid, it can be done without threads
11:40:31 <ibid> they just tend to complicated things
11:40:35 <JKnecht> absolutely and with high probability Access will then work too.
11:40:46 <ibid> -d
11:40:46 <dcoutts> ibid, have an IORef of State rather than a State containing IORefs
11:40:59 <dcoutts> and a 'run' wrapper
11:41:20 <palomer> Heffalump: you here?
11:41:48 <ibid> dcoutts: well, a state containing IORefs or an IORef containing state is more or less the same thing. a matter of taste, i'd say
11:42:00 <Heffalump> palomer: yes
11:42:04 <ibid> dcoutts: normally i'd just thread the state through without using any refs but the callbacks make that tricky
11:42:10 <dcoutts> ibid, true
11:42:21 <palomer> Heffalump: I'm implementing unification, and I'm wondering about the case [(x=y),(x=z)]
11:42:38 <Heffalump> as a problem to solve, or as a substitution?
11:42:41 <palomer> Heffalump: step 1: env(x) = y, step 2: env(x) = z ?
11:42:42 <dcoutts> ibid, my taste preference would be to use the IORef of a record rather than a record of IORefs since it means fewer IORefs! :-)
11:42:50 <palomer> Heffalump: as a set of constraints to solve
11:42:59 <Mitar> can someone look at this and tell me what i am doing wrong: http://pastebin.com/495312
11:43:03 <ibid> dcoutts: if you have significantly more comments, i suggest you make a comment against some of the posts :
11:43:07 <ibid> )
11:43:08 <dcoutts> ok
11:43:19 <Heffalump> step 1: env(x) = y, then you solve y=z cos you apply the substitution to both sides
11:43:34 <palomer> Heffalump: oh, you need to apply the substitution on both sides
11:43:44 <palomer> Heffalump: but who says this algorithm will terminate?
11:43:45 <ibid> dcoutts: once you have one IORef, is there a reason to making them as few as possible? (given that you need an IORef there somewhere)
11:43:56 <dcoutts> ibid, actually the only reason I needed a thread in hIDE is because we're using threads anyway and so have to be threadsafe, so we can't use an IORef. It'd have to be an MVar.
11:44:03 <Heffalump> then you get env(y) = z, and finally you apply y:=z to the existing substitution
11:44:09 <dcoutts> ibid, well if there's just the one it can be hidden more easily
11:44:10 <Heffalump> palomer: I do :-)
11:44:21 <ibid> dcoutts: point
11:44:36 <Heffalump> but I'm not really in the mood to prove it carefully. If you can come up with a reason you think it won't I'll look at it
11:44:54 <palomer> Heffalump: so the final solution is env(x) = y, env(y) = z ?
11:45:04 <Heffalump> env(x) = z, env(y) = z
11:45:08 <dcoutts> ibid, and an MVar would not do since the ops I was running in response to events generated more events so we'd get deadlock with an MVar, hence the need for a channel and thus a thread to read the channel.
11:45:13 <Heffalump> remember the bit about applying y:=z to the existing substitution
11:45:21 <palomer> Heffalump: oh, right
11:45:27 <ibid> dcoutts: yeah, that makes sense
11:45:43 <palomer> Heffalump: so if the first constraint is (X,Y), then my final solution will have a mapping for X
11:45:52 <palomer> (but it may not have a mapping for Y)
11:46:00 <palomer> actually, can it have a mapping for Y?
11:46:09 <palomer> (if y appears in any other constraint)
11:46:12 <ibid> dcoutts: btw, i also wrote a retrospective on my fp course on my blog. it's rather shallow, unfortunately
11:46:25 <jips> give me blog
11:46:53 <dcoutts> http://antti-juhani.kaijanaho.info/newblog/archives/21
11:47:23 <ibid> yes
11:47:48 <palomer> Heffalump: so the only time you ever update the environment is when you have a constraint a = b where a and b are both type variables, right?
11:48:15 <Heffalump> no
11:48:26 <Heffalump> you update it whenever you have a constraint with a type variable on either side
11:48:35 <Heffalump> a = Int, Float = b etc
11:48:37 <palomer> Heffalump: after the substitution is done
11:48:39 <Heffalump> as well as a = b
11:48:43 <ibid> dcoutts: and the followup course starts on tuesday. i'll probably start with giving them the full story on typeclasses
11:48:58 <Heffalump> palomer: you still might get a = Int
11:49:02 <dcoutts> ibid, sounds good
11:49:13 <dcoutts> ibid, 18 out of 20 sounds ok too
11:49:57 <ibid> yeah, better than i expected, though worse than i hoped
11:50:27 <dcoutts> ibid, this year the FP course I was helping with was more practical than in previous years, less abstract equational reasoning
11:50:41 <palomer> unify ((Tyvar x,y):t)  env = case substitute x env of Tyvar z -> updated environment; z->unify ((z,y):t) env 
11:51:21 <palomer> Heffalump: but when you have a type variable, you still have to apply the substitution to both sides!
11:51:24 <ibid> dcoutts: of course, the dropout rate in that course was large
11:51:34 <Heffalump> palomer: huh?
11:52:55 <palomer> Heffalump: ok, say you encounter the constraint a = b
11:53:01 <palomer> Heffalump: a and b both tyvars
11:53:11 <palomer> Heffalump: then you have to apply the substitution on both sides, right?
11:53:16 <Heffalump> yes
11:53:50 <palomer> Heffalump: and after the substitution there might not be a tyvar left on either side, right?
11:54:03 <Heffalump> palomer: correct.
11:54:10 <Heffalump> but if there is, then you make a new binding
11:54:26 <dcoutts> ibid, yeah, that's a shame
11:54:55 <dcoutts> ibid, well you'll know more for next year
11:55:04 <Heffalump> ibid: in unbounded, isn't the first player guaranteed to win? It feels that way, though I can't prove it.
11:55:18 <palomer> Heffalump: and you only substitute when you see a tyvar, ditto for occurs checks, right?
11:55:41 <ibid> Heffalump: with n < 7, it is a proven fact. beyond that, the game is fair
11:55:51 <ibid> (n being the n in 'n-in-a-row')
11:56:07 <Saulzar> It is fair, or it's unknown?
11:56:20 <ibid> fair, iirc
11:56:24 <Saulzar> Hmm
11:56:43 <Heffalump> palomer: given a constraint, you always substitute into both sides. Then if there is a tyvar (at the head) on either side, you make a new binding. The first thing you do with this new binding is an occurs check. The second thing you do is apply it to the RHS of everything in the existing substitution. Finally, you add it to the existing substitution.
11:56:51 <ibid> ie. each player can prevent the other from winning
11:57:09 <Saulzar> So it's a forced draw (given best play)?
11:57:13 <ibid> yes
11:57:45 <palomer> Heffalump: why do you always substitute?
11:57:45 <ibid> of course, in the case of unbounded, draw means "never ends":)
11:58:18 <ibid> but with a completely deterministic game, that's the best definition of 'fair' i can think of:)
11:58:45 <ibid> dcoutts: well, the dropout rate is not unusual for a course like this
11:58:48 <palomer> Heffalump: isn't that equivalent to only substituting the tyvars?
11:59:01 <ibid> dcoutts: elective courses frequently see large dropout rates
11:59:03 <astrolabe> Do you have a link to a description of this game?
11:59:04 <Heffalump> well, obviously it's trivial to substitute into Int
11:59:13 <Heffalump> but substituting into C a b is necessary
11:59:17 <ibid> astrolabe: hm?
11:59:19 <Saulzar> I guess it must be drawn, if a game is to be fair
11:59:51 <palomer> http://www.rafb.net/paste/results/JO7F6918.html <--my code so far, it explains how I'm doing it
12:00:04 * Igloo is lost. Is unbounded a game? If so, what are the rules?
12:00:28 <ibid> unbounded is n-in-a-row on an unbounded board
12:00:31 <palomer> "I'm thinking of a number, find a number greater than the number I'm thinking of"
12:00:45 <Heffalump> lines 15 and 16 look wrong.
12:01:06 <Heffalump> palomer: I have told you quite a lot about how to do this. How about you actually try to get it working with what I've said?
12:01:15 <palomer> okok, fine
12:01:24 <palomer> just seems easier to only substitute tyvars
12:01:30 <astrolabe> board is a square grid?  horizontal, vertical and diagonal lines count?
12:01:32 <Heffalump> well, feel free to do it your way :-)
12:01:32 <ibid> the first post on unbounded: http://antti-juhani.kaijanaho.info/newblog/archives/23
12:01:44 <Heffalump> we may just be disagreeing over terminology and not method.
12:01:51 <Heffalump> I think you should substitute into both a and C a b
12:01:55 <Igloo> ibid: Unbounded left-right-up, but things drop to the bottom like in connect 4?
12:02:00 <astrolabe> Looks like go-moku
12:02:00 <Heffalump> Igloo: no
12:02:14 <Heffalump> real tic-tac-toe, with an unbounded board and variable 3.
12:02:17 <ibid> Igloo: think generalized tic-tac-toe
12:02:40 <cinema_> dcoutts,  sorry for the interruption (computer froze during the compilation of ghc...)
12:03:13 <cinema_> dcoutts, I haven't written any code using arrows for gtk2hs yet, but I'd be interested in doing so
12:03:20 <astrolabe> http://en.wikipedia.org/wiki/Go-moku
12:03:44 <Igloo> OK, P2 can't have a winning strategy then. If it did P1 could play his first piece randomly and then follow P2's strategy. Anytime he needs to play where he already has done he makes another random play. Having an extra piece on the board is never bad for you.
12:03:53 <palomer> Heffalump: how about http://www.rafb.net/paste/results/7UgbP418.html
12:03:54 <ibid> go-moku is a special case, as tic-tac-toe is
12:04:10 <Igloo> So the best possible for P2 is the game doesn't terminate
12:04:46 <Heffalump> what does a :-> b mean?
12:04:54 <astrolabe> http://en.wikipedia.org/wiki/Mnk-games
12:04:55 <palomer> Heffalump: it's the type a -> b
12:05:06 <ibid> astrolabe: i've read all that :)
12:05:29 <palomer> hrm, make that let [a',b',c',d'] = ...
12:05:31 <Heffalump> oh, sorry
12:05:42 <Heffalump> I think I was confused when I said lines 15,16 were wrong before, sorry.
12:05:50 <ibid> http://www.klab.caltech.edu/~ma/tictactoe.html <- good page about the properties of this family of games
12:06:14 <Heffalump> ok, I agree that if you don't have a tyvar at the head on either side, you don't need to substitute immediately.
12:06:25 <palomer> yay!
12:06:27 <Heffalump> but if you do, you must substitute on both sides.
12:06:28 <palomer> makes life simpler
12:06:38 <palomer> oh, righto
12:14:15 <conal> has anyone run ghcprof on Windows?
12:16:05 <jyp> yes, but that was years ago (ghc 5)
12:16:51 <jyp> mmm... thinking twice, it was hp2ps
12:19:04 <conal> there's a nifty-looking version that uses uDraw 
12:19:11 <conal> but i can't quite get it to work
12:42:44 <palomer> Heffalump: using your method, I'll never insert the same variable twice into the environment, right?
12:44:35 <Heffalump> palomer: no
12:44:40 <Heffalump> (you won't)
12:46:07 <palomer> @hoogle apply
12:46:08 <lambdabot> Data.Graph.Inductive.Query.Monad.apply :: GT m g a -> m g -> m (a, g)
12:46:08 <lambdabot> Data.Graph.Inductive.Query.Monad.apply' :: Monad m => GT m g a -> g -> m (
12:46:08 <lambdabot> a, g)
12:46:08 <lambdabot> Data.Graph.Inductive.Query.Monad.applyWith :: Monad m => (a -> b) -> GT m
12:46:08 <lambdabot> g a -> m g -> m (b, g)
12:49:54 <ncalexan> What's a good name for the inverse of lifting a function?  Like if there was an inverse to liftM, what would it be called?
12:50:13 <Heffalump> dropM? :-)
12:50:17 <Heffalump> unliftM?
12:50:34 <ncalexan> ... I thought of drop, but too list-y... I think unliftM is good, I'll use that.
12:50:37 <ncalexan> Thanks.
12:50:54 <Heffalump> lowerM is another option
12:51:25 <palomer> I like lower
12:51:33 <ncalexan> palomer: any deep reason?
12:51:50 <ncalexan> @djinn [a] -> a
12:52:11 <lambdabot> -- f cannot be realized.
12:52:34 <palomer> i don't like using radicals when other options are available
12:52:49 <ncalexan> radicals meaning caps at the end?
12:52:58 <palomer> err, I mean prefixes
12:53:02 <palomer> un is a prefix
12:53:15 <ncalexan> kk.
12:53:27 * palomer wishes that I could say "function a factors through constructor B"
12:53:43 <ncalexan> palomer: that's what I'm expressing :)
12:53:50 <Heffalump> palomer: you roughly can with typeclasses.
12:54:04 <palomer> with a similar syntax?
12:54:10 <ncalexan> Heffalump: I'm doing that via a lot of lifting... is there a slick way?
12:54:12 <Heffalump> similar to what?
12:54:14 <palomer> I just want to save the typing
12:54:25 <Heffalump> well, you have to implement the type class
12:54:32 <Heffalump> but you do get to use the same name everywhere
12:54:38 <Heffalump> which you don't without a type class
12:54:50 <palomer> foo B a b c d = B (foo a) (foo b) (foo c) (foo d)<--- much easier to write foo factors through B
12:55:06 <palomer> saves typing, and thus errors
12:55:36 <Heffalump> ok, you'd need Generic Haskell for that kind of thing.
12:55:43 <Heffalump> or a bit of TH
12:55:44 <palomer> oh, so it can be done
12:55:47 <palomer> TH?
12:55:56 <Heffalump> Generic Haskell is a different language to Haskell
12:55:59 <Heffalump> TH = Template Haskell
12:56:06 <Heffalump> TH might be better for this, actually.
12:56:12 <Heffalump> and it's in GHC
12:57:19 <palomer> template haskell simply gives you access to the abstract syntax tree, right?
12:57:27 <Heffalump> yes, and lets you change it
12:57:35 <Heffalump> well, generate new code from it
12:58:01 <palomer> so it increases the keyword space, right?
12:58:02 <greenrd> I think code you want to read has to be put inside [| ... |] brackets, but that's a small price to pay
12:59:48 <palomer> hrmph
12:59:57 <palomer> Import would have been a better solution, imho
13:00:15 <palomer> or something
13:00:41 <palomer> module `Main' is defined in multiple files: unify.hs monad4.hs <--I don't have Module Main anywhere in my unify.hs file
13:00:44 <palomer> how can this be?
13:00:45 <ncalexan> @djinn a -> a
13:00:46 <lambdabot> f a = a
13:01:09 <ncalexan> @djinn (Monad m) => (a -> b) -> (m a -> m b)
13:01:14 <lambdabot> Cannot parse command
13:01:16 <palomer> @djinn a -> [a]
13:01:17 <lambdabot> -- f cannot be realized.
13:01:22 <palomer> eh?
13:01:28 <Heffalump> I don't think it knows about []
13:01:30 <musasabi> no recursive tyoes
13:01:33 <musasabi> *types
13:01:43 <palomer> a -> [a] is recursive?
13:01:55 <xerox> @type Control.Monad.liftM
13:01:56 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
13:02:00 <xerox> There you go.
13:02:24 <ncalexan> xerox: actually, I was interested in learning how to get djinn to tell me if the inverse of liftM has a name in some special case...
13:02:29 <xerox> palomer: [a] is a recursive type
13:02:53 <xerox> (m a -> m b) -> a -> b ?
13:02:55 <ncalexan> Can someone explain how to invoke djinn with a context?
13:03:03 <ncalexan> xerox: yes.
13:03:08 <xerox> @djinn-env
13:03:09 <lambdabot> data () = ()
13:03:09 <lambdabot> data Either a b = Left a | Right b
13:03:09 <lambdabot> data Maybe a = Nothing | Just a
13:03:09 <lambdabot> data Bool = False | True
13:03:09 <lambdabot> data Void
13:03:11 <lambdabot> type Not x = x -> Void
13:03:13 <lambdabot> type Cont r a = (a -> r) -> r
13:04:00 <xerox> Specifically forall the non-oneway-monads?
13:04:03 <greenrd> What is Void?
13:04:07 <greenrd> Is it () ?
13:04:40 <xerox> Void is 'data Void'
13:04:52 <xerox> (no constructor exported)
13:05:23 <palomer> is it possible to import everything thats in a module, even what doesn't want to be exported?
13:05:37 <xerox> > () :: ()
13:05:38 <lambdabot> ()
13:06:05 <xerox> I don't know how Void and _|_ relate.
13:06:16 <xerox> palomer: I don't think so.
13:06:58 <xah> xerox: hi 
13:07:04 <palomer> xerox: do you mean void and forall x.x ?
13:07:10 <xah> xerox: http://media.arstechnica.com/images/tiger/automator-icon.png
13:09:33 <xerox> Hi xah!
13:09:51 <xerox> palomer: Yes.
13:09:55 <xah> xerox: lots of os x screenshots in http://arstechnica.com/reviews/os/macosx-10.4.ars/20
13:10:11 <xerox> Heh, thanks much, xah.
13:10:39 <palomer> @hoogle member
13:10:40 <lambdabot> Data.IntMap.member :: Key -> IntMap a -> Bool
13:10:40 <lambdabot> Data.IntSet.member :: Int -> IntSet -> Bool
13:10:40 <lambdabot> Data.Map.member :: Ord k => k -> Map k a -> Bool
13:10:51 <palomer> what's the list function for member?
13:11:24 <xerox> > let evens = map (+1) odds; odds = 1 : map (+1) evens; in 1000 `elem` evens
13:11:26 <lambdabot> True
13:14:58 <xerox> palomer: that is, elem.  There also is notElem.
13:16:46 <palomer> elem = not . elem ?
13:16:59 <palomer> err notElem = not . elem
13:26:58 <Mitar> how could i remove spaces at the end of the string?
13:27:27 <basti_> a) regexes
13:28:19 <Mitar> ok
13:28:22 <Mitar> i want a simple solution
13:28:33 <basti_> you could play around with inits and tails maybe
13:28:34 <ncalexan> b) dropWhile isSpace and reverse...
13:28:44 <ncalexan> @type isSpace
13:28:45 <basti_> or that
13:28:46 <lambdabot> Not in scope: `isSpace'
13:28:52 <basti_> (==' ')
13:28:58 <basti_> @type (==' ')
13:28:59 <lambdabot> Char -> Bool
13:29:12 <xerox> @type Char.isSpace
13:29:13 <lambdabot> Char -> Bool
13:29:20 <ncalexan> Doesn't take tabs and newline into account, or locales... but probably... that's what I wanted, thanks xerox.
13:29:35 <xerox> You're welcome!
13:41:16 <SamB> what is a good AIM client for windows?
13:41:37 <SamB> my sister keeps bugging me about it...
13:41:48 <xerox> gaim, I'd say, but I don't know your sister's needs
13:41:59 <SamB> she is even threatening to install the one from AOL!
13:43:26 <sproingie> there really isn't much
13:43:30 <sproingie> trillian and regular aim
13:43:42 <sproingie> gaim might run, but on windows it's probably worse than trillian
13:43:48 <xerox> trillian is kinda of more good-looking, gaim is more powerful
13:43:56 <xerox> I'd say use skype :)
13:44:07 <sproingie> trillian is a pig
13:44:17 <Korollary> I bet his hister is a true power user.
13:44:23 <sproingie> does AIM still spew ads at you?
13:44:55 <sproingie> i found aim more stable and nicer on resources than yahoo im's latest offering
13:45:12 <sproingie> yim draws its own gui and all
13:45:24 <sproingie> gotta be its own window manager
13:49:49 <SamB> why wold gaim be worse than trillian?
13:51:41 <MarcWeber> SamB: I love Miranda.. 
13:56:40 <SamB> MarcWeber: thats an AIM client?
13:57:07 <SamB> or are you talking about that programming language for no reason?
13:57:29 <sproingie> it's an im client
13:57:31 <sproingie> i forgot about it
13:57:34 <MarcWeber> www.miranda-im.org
13:58:07 <MarcWeber> It supports many protocols and has got some 100 plugins.. ;-)
14:18:24 <Mitar> how can i, with Parsec, skip a line of input?
14:19:31 <jyp> just parse it as normal and discard the result
14:20:09 <jyp> Are you writing a parser or is it a theoretical question?
14:20:11 <Mitar> manyTill  newline
14:20:18 <Mitar> i am writing a parser
14:20:30 <astrolabe> or skip many  not newlines  (I've forgotten the syntax)
14:20:35 <jyp> ok, then you should know what I mean :)
14:21:15 <Mitar> is there not?
14:21:41 <Mitar> i didn't find any
14:22:04 <jyp> notFollowedBy
14:22:26 <SamB> Mitar: why would you WANT to?
14:22:58 <Mitar> i am reading a datafile and lines with % are comments, so i want to skip them
14:23:40 <Oejet> @paste
14:23:41 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
14:23:59 <SamB> ah
14:25:26 <jyp> you may put (skipMany comment) before parsing each data line
14:26:25 <jyp> where comment = do char '%'; manyTill anyChar endOfLine; endOfLine
14:26:33 <Oejet> Why can't I edit the paste page even when I'm logged in?
14:26:42 <jyp> (not sure of the exact syntax)
14:27:46 <Mitar> hmm
14:27:47 <jyp> Oejet, I can edit it...
14:28:00 <Mitar> (newline <|> eof) does not seem to work
14:28:30 <Mitar> manyTill anyChar newline; works, but manyTill anyChar (newline <|> eof); does not
14:29:57 <ADEpt> @seen Lemmih
14:29:58 <lambdabot> Lemmih is in #haskell-blah and #haskell. Last spoke 3 hours, 19 minutes
14:29:58 <lambdabot> and 26 seconds ago.
14:30:07 <Lemmih> Hi ADEpt.
14:31:01 <ADEpt> Lemmih: hi. got a minute? i got a strange bug that I want to talk about
14:31:12 <jyp> Mitar, maybe manyTill anyChar (try (newline <|> eof))
14:31:22 <Lemmih> ADEpt: Sure.
14:31:29 <Oejet> jyp: Works now.
14:32:07 <Mitar> it does not want to compile: Couldn't match `Char' against `()'  Expected type: GenParser Char st Char  Inferred type: GenParser Char st ()
14:33:02 <jyp> Mitar, I'm afraid I need to see the source code to help you on this one
14:33:22 <ADEpt> Lemmih: i've tried to get seeding working. Uncommented 'runServer' in Cnjure.hs, sprinkled a bit of putStrLn all around to see what comes from and goes to the network. What happens is this - immediately after I send request to the tracker, tracker connects to my listening port (3000) and send me handshake. Well, almost handshake, since it hase no peer id. After which tracker closes socket. 
14:33:31 <Mitar> pastebin?
14:33:44 <jyp> lisppaste2 ?
14:33:45 <Oejet> I'm trying to see how easy it would be to implement something BRL or Embperl in Haskell.
14:33:53 <jyp> or @paste
14:33:56 <jyp> @paste
14:33:57 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
14:33:58 <SamB> jyp: I'm afraid (newline <|> eof) probably doesn't typecheck
14:34:10 <ADEpt> Lemmih: it could be see in 'putStrLn's, it could be seen via 'ethereal', it does not happen when I use 'official' client with the same tracker. Got any ideas what this might be?
14:34:17 <Lemmih> ADEpt: After a peer connects to you, you mean?
14:34:24 <jyp> SamB, indeed
14:34:30 <SamB> ADEpt: oh, yeah. I had code for that before
14:34:40 <ADEpt> Lemmih: no, not peer. it is tracker.
14:34:41 <SamB> Lemmih: no!
14:34:48 <Mitar> hmm, lisppaste2? i do not know this
14:34:49 <SamB> the tracker is specifically allowed to do this!
14:35:02 <jyp> so replace newline with (newline >> return ())
14:35:09 <Lemmih> ADEpt: The tracker connects to you? Hmm, I better read some more about the bittorrent protocol.
14:35:16 <ADEpt> Lemmih: it is my own host, my own tracker, and no other clients save 'conjure'. And 'netstat -npa' confirms that source port belongs to tracker.
14:35:19 <SamB> Lemmih: you must have obliterated the code that handled this
14:35:28 <SamB> which admittedly needed work
14:35:53 <ADEpt> Lemmih: people on #bittorent said me that bittorent spec is "slightly" outdated :(
14:36:01 <SamB> ADEpt, Lemmih: this was mentioned in one of the documents in READTHEM...
14:36:19 <Mitar> yes, manyTill anyChar ((newline >> return ()) <|> eof) is the way
14:36:34 <Lemmih> ADEpt: Why would the tracker connect to you?
14:36:44 <SamB> probably http://wiki.theory.org/BitTorrentSpecification
14:36:57 <ADEpt> Lemmih: to check if i am alive, indeed a bittorrent client and all that? (maybe)
14:37:03 <SamB> look at your backup of the pre-Lemmih conjure to see
14:37:08 <ADEpt> SamB: do you know why?
14:38:31 <SamB> ADEpt: well, presumably to make sure you are actually reachable, presumably...
14:38:59 <ADEpt> SamB: there was code that binds/accepts on listening port and sends there handshake, but I assumed it is a placeholder for future seeding code.
14:39:16 <SamB> ADEpt: oh!
14:39:37 <SamB> well, it was a placeholder for future code, but also it was for that!
14:39:58 <SamB> I should probably have written a comment about that.
14:40:32 <Lemmih> What's the right thing to do when the tracker connects to you?
14:41:41 <jyp> Mitar, maybe a somewhat nicer solution is  do skipMany notNewLine; optional newLine
14:41:46 <SamB> can someone download http://map.squeak.org/loadgz?mapversion=2.1&checkpoint=0 and send it to me?
14:42:13 <ADEpt> Lemmih: quoting from wiki.theory.org "The initiator of a connection is expected to transmit their handshake immediately. The recipient may wait for the initiator's handshake, if it is capable of serving multiple torrents simultaneously (torrents are uniquely identified by their info_hash). However, the recipient must respond as soon as it sees the info_hash part of the handshake. The tracker's NAT-checking feature does not send the peer_id field of the handsh
14:42:24 <ADEpt> SamB: is it large?
14:42:52 <Mitar> but does there exist notNewLine?
14:42:59 <SamB> The initiator of a connection is expected to transmit their handshake immediately. The recipient may wait for the initiator's handshake, if it is capable of serving multiple torrents simultaneously (torrents are uniquely identified by their info_hash). However, the recipient must respond as soon as it sees the info_hash part of the handshake. The tracker's NAT-checking feature does not send the peer_id field of the handshake.
14:43:25 <jyp> Mitar: notNewLine = satisfy (/= '\n')
14:43:40 <SamB> ADEpt: its about half a meg
14:43:40 <SamB> but it won't resume
14:43:45 <SamB> oh. great. we both pasted the same thiing...
14:43:47 <Mitar> hmm, what about \r?
14:44:05 <Mitar> or is this cared of automatically?
14:44:07 <ADEpt> Lemmih: so the right thing is to handle socket close in the handshake reception while waiting for peer id and return not 'Handshake x y', but 'TrackerNatCheck', upon which Peer will disconnect. I think.
14:44:29 <SamB> wouldn't noneOf "\n" be more appropriate?
14:44:41 <jyp> Mitar, I'm always assuming nice unix newlines...
14:44:51 <jyp> so it may not apply
14:45:20 <SamB> Actually, you should handle closing everywhere...
14:45:25 <Lemmih> ADEpt: What's the difference between a slow connection and a peer that doesn't send its peer id?
14:45:59 <SamB> Lemmih: what does it matter?
14:46:37 <Lemmih> SamB: How would you tell the difference between a bittorrent client and a tracker?
14:46:53 <ADEpt> Lemmih: tracker sends handshake without the last 20 bytes
14:46:56 <SamB> Lemmih: its irrelevant, really...
14:47:29 <ADEpt> Lemmih: that is, it sends '19', 'Bittorr...ol', 8 reserved bytes, infohash, and closes connection.
14:48:00 <ADEpt> Lemmih: correction. closes connection as soon as it sees handshake from you or after a short timeout
14:48:09 <SamB> Lemmih: just don't read past there in the handshake until you've sent your, info period...
14:48:31 <SamB> move the comma one word to the right
14:49:07 <Lemmih> Ah, so 'client <- FS.hGet h 20' -> 'client <- unsafeInterleaveIO $ FS.hGet h 20'?
14:50:07 <ADEpt> Lemmih: hard to say :) i am not used to unsafeInterleaveIO :)
14:50:29 <Lemmih> unsafeInterleaveIO = return . unsafePerformIO
14:51:00 <Lemmih> That means that we wont actually read the peer id before we use it.
14:51:34 <Lemmih> (Which will be after we send our handshake)
14:51:48 <SamB> Lemmih: wouldn't it be cleaner to just put that part after the part where you send the message?
14:51:55 <SamB> also work?
14:52:05 <ADEpt> Lemmih: actually, it will be befor, but I think I can correct that. Wait 2 minutes :)
14:52:36 <SamB> Lemmih: I think you are attempting to show off!
14:52:46 <Lemmih> ADEpt: Oh, that's right.
14:53:24 <ADEpt> SamB: no, he is not
14:53:47 <Lemmih> SamB: Reading the client id outside of 'hGetHandshake' seems ugly.
14:54:20 <ADEpt> SamB: look at the code. We need infohash to find out active torrent, to find out our peerid for that torrent, only that we can send our peerid. Putting that into hGetHandshake seems like violation of incapsulation
14:55:09 <SamB> ADEpt: why do we have an hGetHandshake in the first place?
14:55:12 <Lemmih> ADEpt: Registering the peer after we send our handshake would solve it.
14:55:39 <Lemmih> SamB: Because we need to read handshakes?
14:55:45 <SamB> unsafeInterleaveIO is not the way
14:56:00 <Lemmih> How so?
14:56:36 <SamB> because you are only suppose to do relatively safe things with it
14:56:44 <SamB> like implementing hGetContents
14:57:11 <Lemmih> Why isn't it safe?
14:57:21 <SamB> and hGetContents reads the rest of the file, so you don't use that handle again
14:58:04 <SamB> Lemmih: well, there is the "unsafe" at the beginning of the name, which is the Haskell convention for placing the obligation of proof on the caller
14:58:17 <SamB> so you get to prove how its safe
14:58:19 <ADEpt> Lemmih: what will be the value of peerId which is not there, since socket is closed?
14:58:35 <SamB> and then keep anyone from changing it in a seemingly-inoccuous way to make it unsafe
14:58:40 <Lemmih> SamB: Yes, and I'm telling you: It's just as safe as hGetContents.
14:58:53 <SamB> anyway, you should probably split hGetHandshake
14:59:01 <SamB> Lemmih: no it isn't.
14:59:11 <SamB> you still need this handle afterwards
15:00:14 <Lemmih> So? The peer id will be forced when we check whether or not it's unique.
15:00:30 <ADEpt> why dont we just do something like:
15:00:30 <ADEpt>  client <- (FS.hGet h 20) `catch` (return "Tracker NAT checker"), 
15:00:30 <ADEpt> and check for that later?
15:00:36 <SamB> I suppose so.
15:01:00 <Lemmih> ADEpt: "FS.hGet h 20" will not terminate unless the peer sends us his peer id.
15:01:04 <SamB> but think how easy it would be to get crazy errors later?
15:01:18 <ADEpt> Lemmih: ah yes. that's what happen now
15:01:26 <SamB> anyway, why don't we just do it by the book?
15:01:35 <SamB> unsafe isn't by the book...
15:02:07 <Lemmih> Is it doable in a non-ugly way?
15:02:57 <SamB> probably...
15:03:22 <ADEpt> Lemmih: well, we could have hGetHandshake + hGetPeerId, but that will require split of the Handshake constructor, which is ugly
15:04:36 <SamB> just have hGetHandshake1 :: Handle -> (String, String, String) or whatever?
15:04:43 <Lemmih> ADEpt: (re your patch) @Left@ is an Int?
15:04:48 <ADEpt> Lemmih: or we need to pass the torrentMap to hGetHandshake in order to be able to send handshake from inside it.
15:05:01 <twb> Is there an "advanced" textbook for Haskell similar to On Lisp for CL?
15:05:25 <Lemmih> ADEpt: That pure evil (:
15:05:28 <ADEpt> Lemmih: I dont see any reason why it should not be Int. Along with other ActiveTorrent fields. Am I wrong?
15:05:47 <ADEpt> Lemmih: (re evil) I agree
15:05:57 <SamB> well, please avoid unsafe* things...
15:06:12 <SamB> I have to go, we have company.
15:06:16 <Lemmih> Bye.
15:06:52 <Lemmih> SamB: I'll go with unsafeInterleaveIO. Feel free to send a patch if you find a pretty solution.
15:07:15 <ADEpt> Lemmih: i have it with interleave working already, wait :)
15:07:33 <Lemmih> ADEpt: What do we do about files bigger than 2^32?
15:08:07 <ADEpt> Lemmih: now you got me :)
15:08:18 <ADEpt> Lemmih: we compile on x64 :)
15:08:29 <ADEpt> Lemmih: no, we change it back to Integer, of course
15:08:38 <ADEpt> Lemmih: i'll do that
15:14:55 <ncalexan> @pl fmap not $ f x y
15:14:55 <lambdabot> fmap not (f x y)
15:15:08 <ncalexan> @pl g x y = fmap not $ f x y
15:15:09 <lambdabot> g = (fmap not .) . f
15:16:25 <ncalexan> @pl g x y z = fmap not $ f x y z
15:16:25 <lambdabot> g = ((fmap not .) .) . f
15:18:55 <jwp> Does hmake only do programs/executables? (looking for an easy way to set up a haskell module project)
15:19:38 <Lemmih> Haskell module project?
15:20:40 <ncalexan> Cabal builds libraries, if that's what you're interested in, jwp.
15:21:02 <jwp> Lemmih: I'm playing with haskell. I got a directory and a source file. Looking for an easy way to do the "make all & install" thing.
15:21:09 <jwp> ncalexan: thanks, I'll take a look
15:21:19 <ncalexan> jwp: I think cabal will be overkill for that.
15:21:37 <Lemmih> jwp: What does 'install' mean?
15:21:59 <jwp> Lemmih: put in the ghc' modules directory?
15:22:36 <Lemmih> jwp: You can't install single modules without putting them in a library.
15:23:39 <jwp> Lemmih: ok
15:25:25 <Lemmih> You can compile and use the module without installing them, though.
15:27:20 <ADEpt> Lemmih: patches on the way
15:29:39 <ADEpt> Lemmih: i think it will do no harm to start our peer id with "conjure" and filter out such peers in Network.Cient - that is, just do it "for now" since conjure tends to connect to it's own self :)
15:29:49 <Lemmih> ADEpt: Um, you're still changing @left@ to Int.
15:31:22 <Lemmih> ADEpt: How about unrecording your bug fix?
15:32:10 <ADEpt> Lemmih: second patch corrects that
15:32:25 <ADEpt> Lemmih: i feel uneasy unrecording things that I have sent out
15:33:42 <Lemmih> I think it would make the handshake patch cleaner.
15:36:06 <ADEpt> Lemmih: well, let's do it
15:37:30 <jwp> ncalexan: Cabal sounds like what I want; thanks. It may be overkill for some of the beginner stuff I will be doing. However, the desired result of this "play" is to learn about haskell, haskell modules, and, perhaps, to produce something useful.
15:40:19 <ncalexan> jwp: oh, good.  For now, though, you probably can just edit your Module.hs and use 'import Module' in Main.hs; then ghc --make Main.hs -o main will do all the chasing you need...
15:40:49 <Lemmih> jwp: How about using GHCi?
15:44:08 <palomer> Heffalump: at the end of unification, every tyvar appearing in my formula will have been mapped in my env, right?
15:44:46 <Heffalump> palomer: one would hope so
15:44:56 <Heffalump> to ground types, too
15:45:04 <jwp> Lemmih: I've played with it a bit.
15:45:12 <palomer> let's say I'm unifying (a=b)
15:45:14 <Heffalump> oh, no.
15:45:19 <Heffalump> anything that's left unmapped really is free.
15:45:21 <palomer> wouldn't that simply be {a:=b}
15:45:31 <palomer> oh, gotcha
15:48:19 <palomer> hrm
15:49:00 <palomer> say I have id :: forall a. a -> a, and I try to unify that with b, then it would be b = Newvar -> Newvar, right?
15:49:37 <jips> what are some really good nes games?
15:50:24 <jwp> hehe
15:50:43 <jwp> metroid?
15:50:54 <ncalexan> original zelda.
15:50:58 <jwp> yeah :)
15:51:17 * ncalexan hums the Hyrule overworld theme...
15:52:49 <Cale> Final Fantasy
15:52:54 <jwp> It's a secret to everyone. (body?)
15:53:05 <lennart> palomer: you don't normally unify those things in HM type checking
15:53:26 <lennart> palomer: you instantiate foralls as soo as you encounter them
15:53:34 <jips> i've already played those 3
15:53:50 <Cale> Also, Dragon Warrior 2,3,4 were all pretty good.
15:53:52 <palomer> lennart: what do you mean?
15:54:52 <jips> Cale: what about dragon warrior 1?
15:54:57 <Cale> 1 was okay
15:55:02 <jwp> jips: Did you fight the WarMech on the bridge before the fourth boss(the wind/snake thing)(Final Fantasy)?
15:55:05 <ihope> So what's in ((a -> b) -> a) -> a?
15:55:09 <lennart> say you have id in your code, you'll give it type v->v where v is a fresh type variable
15:55:17 <Cale> But it's not quite representative of the rest of the series.
15:55:31 <palomer> http://www.rafb.net/paste/results/OIcT4d20.html <--here's my code
15:55:37 <lennart> ihope: i see an a and a b ;)
15:55:49 <ihope> :-)
15:56:04 <jips> jwp: i actually haven't finished ff yet :O i've entered the cave near the initial city(celindia?)
15:56:05 <ihope> data Id a = a
15:56:07 <palomer> lennart: yeah, that's what I'm doing
15:56:14 <jwp> rather, I should say: "Did you find the WarMech" ;)
15:56:16 <palomer> man, generating new type variable names is a _huge_ pain:o
15:56:38 <lennart> huge pain?  aren't you in a suitable monad?
15:56:38 <ihope> instance Monad Id where return = id; fail = error; x >>= y = y x
15:56:49 <palomer> lennart: yeah, but sometimes I want to add on another monad
15:57:13 <jwp> jips: oh, right. you get to fight "garland"(?) again.
15:57:24 <palomer> so yeah, instantiateAll instantiates every variable with something
15:57:34 <ihope> @pl \x y -> y x
15:57:35 <lambdabot> flip id
15:57:48 <lennart> palomer: sounds good
15:58:09 <lennart> ihope: so what was you question about  ((a -> b) -> a) -> a?
15:58:16 <ihope> What has that type?
15:58:34 <lennart> well, call/cc would have that type
15:58:46 <lennart> kinda
15:59:11 <lennart> But Haskell doesn't have call/cc
15:59:16 <ihope> :-)
16:00:01 <lennart> @type Control.MonadCont.callCC
16:00:02 <lambdabot> Couldn't find qualified module.
16:00:02 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
16:00:02 <lambdabot> \\)?
16:00:25 <lennart> @type Control.Monad.Cont.callCC
16:00:27 <lambdabot> forall (m :: * -> *) a b.
16:00:27 <lambdabot> (Control.Monad.Cont.MonadCont m) =>
16:00:27 <lambdabot> ((a -> m b) -> m a) -> m a
16:00:41 <ihope> Aha!
16:00:47 <lennart> that's the closest you'll get
16:00:54 <ihope> Just set m to the identity type constructor and...
16:01:15 <lennart> excelt that m has to be a MonadCont
16:01:25 <ihope> What's a MonadCont?
16:01:39 <ihope> Oh yeah. Not just a monad.
16:01:52 <ihope> Then make ol' Id a MonadCont >:-)
16:02:09 <lennart> if you can implement it, go ahead
16:02:39 <ihope> type Sub a b c = a c (b c)
16:03:08 <lennart> callCC is actually the method in MonadCont.  it's the feature that makes it a continuation monad
16:03:27 <ihope> Oh
16:03:59 <lennart> And in Haskell you can't implement for Id
16:04:26 <lennart> Unless you hack your Haskell compiler and add it there
16:04:30 <ihope> Hah
16:05:07 <ihope> Wait. This takes something of kind * -> * -> *... why doesn't (* -> *) -> * -> * qualify?
16:05:35 <ihope> (I'm trying to get some SKI calculus lodged in Haskell's type system.)
16:05:39 <lennart> *-> doesn't look like * to me
16:05:50 <lennart> *->* i meant
16:06:03 <ihope> ...Oh yeah,
16:06:17 <ihope> So * has to be an actual type?
16:06:24 <lennart> yes
16:06:53 <lennart> you can't get SKI into Haskell's type system
16:07:20 <ihope> How much computing *can* that type system handle?
16:07:43 <lennart> HM can do anything that Turing Machines with finite tapes can
16:08:15 <lennart> so the same as your computer (unless you have infinite memory)
16:08:16 <ihope> ...Oh
16:08:24 <ihope> Ah?
16:08:46 <lennart> but your computer has a longer finite tape ;)
16:08:48 <ihope> So, supposing I do have infinite memory, it is Turing-complete somehow?
16:09:04 <ADEpt> Lemmih: those better? :)
16:09:33 <lennart> your computer would be Turing complete with infinite memory.  HM type checking is limitied to emulating finite tapes
16:10:01 <Lemmih> ADEpt: Yep, thanks.
16:10:09 <ihope> Okay.
16:10:28 * ihope gets hascking
16:10:32 <ihope> *hacking
16:10:55 <ADEpt> Lemmih: i like them better myself. 
16:11:02 <ihope> (Then again, "hascking" has a certain Haskell sound to it. But maybe "hasking" is better?)
16:16:36 <Heffalump> palomer: I think so.
16:16:43 <Heffalump> (re instantiating the type of id)
16:16:54 <Heffalump> I've never written a HM type-checker, though.
16:17:11 <Heffalump> (I haven't actually written a unifier either, but I have written lots of matchers)
16:18:48 <ihope> So Id :: * -> *
16:19:05 <ihope> Why can't I stick it in the Monad class?
16:20:06 <lennart> How is Id defined?
16:20:13 <ihope> type Id a = a
16:20:18 <ihope> :-)
16:20:37 <lennart> No type synonyms allowed in instance declarations
16:20:46 <ihope> Oh
16:21:13 <Heffalump> use a newtype
16:22:21 <ihope> "newtype Id a = a"?
16:22:29 <Heffalump> Id a = Id a
16:22:37 <Heffalump> or Id a = Id { unId :: a }
16:22:46 <ihope> Hmm?
16:23:08 <Heffalump> newtype Id a = Id a
16:23:09 <mauke> Control.Monad.Identity?
16:23:15 <Heffalump> or newtype Id a = Id { unId :: a }
16:23:19 <Heffalump> (or use that, yes :-)
16:24:03 <ihope> Wait, whazzat?
16:24:50 <mauke> http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Identity.html
16:41:07 <jwp> sweet, cabal is nice. :)
16:49:59 <ski> also
16:52:24 <palomer> do let statements generate new constraints for typechecking?
16:53:25 <Mitar> is there some standard function which would tell if there are duplicates in list?
16:53:58 <palomer> @hoogle [a] -> Bool
16:53:59 <lambdabot> Data.List.null :: [a] -> Bool
16:53:59 <lambdabot> Prelude.null :: [a] -> Bool
16:53:59 <lambdabot> Graphics.UI.ObjectIO.CommonDef.isSingleton :: [x] -> Bool
16:54:07 <palomer> Mitar: doesn't look like it
16:54:17 <Korollary> @type nub
16:54:19 <lambdabot> Not in scope: `nub'
16:54:31 <Korollary> @index nub
16:54:32 <lambdabot> Data.List
16:54:40 <Korollary> @type Data.List.nub
16:54:42 <lambdabot> forall a. (Eq a) => [a] -> [a]
16:55:31 <ihope> dupes [] = False
16:55:50 <palomer> @hoogle Map k a -> k -> a
16:55:52 <lambdabot> Data.Map.(!) :: Ord k => Map k a -> k -> a
16:55:52 <lambdabot> Data.Map.findWithDefault :: Ord k => a -> k -> Map k a -> a
16:55:52 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
16:55:53 <ihope> dupes (x:xs) = xs `contains` x || dupes xs
16:56:11 <ihope> @index contains
16:56:12 <lambdabot> bzzt
16:56:17 <ihope> :-P
16:56:46 <Lemmih> x `elem` xs?
16:56:51 <ihope> Aha
17:00:06 <Mitar> how can i get a second element of a triplets?
17:00:16 <palomer> > [1,1] \\ [1]
17:00:18 <lambdabot> [1]
17:00:23 <Mitar> (i think that i am asking a very obvious question)
17:00:30 <ihope> \(x,y,z) -> y
17:00:53 <Mitar> palomer, not a list
17:01:12 <palomer> what's not a list?
17:01:16 <Mitar> nothing
17:01:17 <Mitar> :-)
17:01:19 <Mitar> mixed
17:02:18 <palomer> dupes y = foldl (&&) $ map (\x. x `elem` y \\ [x]) y
17:02:22 <palomer> that should work:o
17:02:40 <palomer> do I win a prize for ugliness?
17:02:57 <ihope> Yes, you do.
17:03:17 <ihope> @index (\\)
17:03:18 <lambdabot> bzzt
17:03:32 <palomer> @type (\\)
17:03:32 <Heffalump> > nub [5,4,3,1,3,5]
17:03:32 <ihope> @hoogle \\
17:03:33 <lambdabot> Not in scope: `\\'
17:03:34 <lambdabot> [5,4,3,1]
17:03:34 <lambdabot> Data.IntMap.(\\) :: IntMap a -> IntMap b -> IntMap a
17:03:34 <lambdabot> Data.IntSet.(\\) :: IntSet -> IntSet -> IntSet
17:03:34 <lambdabot> Data.List.(\\) :: Eq a => [a] -> [a] -> [a]
17:03:42 <ihope> Whoo.
17:05:17 <Heffalump> > tails [5,4,3,5]
17:05:18 <lambdabot> [[5,4,3,5],[4,3,5],[3,5],[5],[]]
17:05:40 <ihope> Wow!
17:05:48 <ihope> > heads [5,4,3,5]
17:05:50 <lambdabot>  Not in scope: `heads'
17:05:56 <Heffalump> > inits [5,4,3,5]
17:05:56 <palomer> > [[1..4]..[1..6]]
17:05:57 <lambdabot> [[],[5],[5,4],[5,4,3],[5,4,3,5]]
17:05:58 <lambdabot>  add an instance declaration for (Enum [a])
17:05:58 <lambdabot>   In an arithmetic sequence: [[1 .. 4] .. [1 .. 6]]
17:05:58 <lambdabot>   In the definition of `vfl': vfl = [[1 .. 4] .. [1 .. 6]]
17:06:13 <ihope> > let heads = id in heads [5,4,3,5]
17:06:15 <lambdabot> [5,4,3,5]
17:06:18 <ihope> :-)
17:06:31 <Heffalump> :-p
17:08:20 <ihope> If Debug.Trace.trace isn't referentially transparent, then what's it doing in Haskell?
17:08:45 <Cale> It's just for debugging
17:08:48 <ihope> We be stuck in a monad, chum!
17:09:25 <Cale> There's also unsafePerformIO, if you want it, with which you can also break the type system.
17:09:36 <ihope> You can? >:-)
17:10:06 <ihope> Say... if imperative languages can be thought of as places where the IO monad is everywhere, why not make a language where EVERYTHING is everywhere?
17:10:23 <Cale> um
17:10:41 <ihope> Yeah. Instead of a, we'd have IO [Maybe a].
17:10:51 <Cale> heh
17:10:53 <ihope> And every other monad you care about.
17:11:27 <palomer> ghc should have  a --superquickcompile option
17:11:31 <Cale> * autrijus stares at type Eval x = forall r. ContT r (ReaderT x IO) (ReaderT x IO x) and feels very lost
17:11:31 <Cale> <shapr> Didn't you write that code?
17:11:31 <Cale> <autrijus> yeah. and it works
17:11:31 <Cale> <autrijus> I just don't know what it means.
17:11:47 <Lemmih> heh
17:11:58 <ihope> palomer: append an interpreter to the code?
17:12:22 <ihope> No, no. Compile into a thunk!
17:12:32 <Cale> ihope: we have a language in which all these monads are available. It's called Haskell. :)
17:12:46 <ihope> Really? Where can I get this language?
17:13:07 <Cale> caml.inria.fr
17:13:14 <jzz_> what are those gonads monads thingies?
17:13:32 <gzl> if Simon had named them gonads EVERYBODY would want to know what they were :P
17:14:03 <ihope> Monads provide ways for values to exist, ways for them not to exist, ways for them to be accessed, and consequences of said access.
17:14:06 <palomer> YES!
17:14:11 <palomer> we have type inference!
17:14:14 <palomer> but man is it ugly
17:14:21 <palomer> ok, how do I keep track of many states?
17:14:27 <Cale> ST monad
17:14:29 <ihope> Put them all in a list?
17:14:32 <palomer> what does it stand for?
17:14:41 <Cale> State thread
17:14:56 <ihope> Then use the list monad to treat that list as a single state, and...
17:15:02 <palomer> what's the best place to learn how to use it?
17:15:03 <ihope> Lists are COOL!
17:15:52 <Cale> Just look in the documentation under Control.Monad.ST and Data.STRef. If that's not enough, SPJ has written at least one paper on ST.
17:16:25 <dons> ST was one of the first monads
17:16:36 <Mitar> is there some function for "debug" output?
17:16:48 <Mitar> so that i can print some data just for debuging out?
17:16:50 <Cale> palomer: look up "Lazy functional state threads"
17:16:52 <ihope> I thought the identity monad was first...
17:16:53 <ihope> :-)
17:17:05 <dons> iomonad.hs in gofer ('94) is actually implemented as: module  LazyStateThd ...
17:17:19 <elk> Mitar: trace ?
17:17:46 <palomer> ok, someone ask me to type something
17:18:14 <dons> -- You will not be able to use this file unless the version of Gofer that
17:18:14 <dons> -- is installed on your machine has been compiled with the IO_MONAD flag set to 1.
17:18:17 <palomer> @hoogle ST
17:18:18 <lambdabot> Control.Monad.ST.Lazy.ST :: ST s a
17:18:18 <lambdabot> Control.Monad.ST.ST :: ST s a
17:18:18 <lambdabot> Graphics.UI.ObjectIO.CommonDef.St :: s -> (a, s)
17:18:45 <palomer> the docs say that ST = State Transformer
17:19:09 <dons> palomer, it was state thread, hence in '94 we had strict and lazy (StateThd)/ST 
17:19:30 <dons> module LazyStateThd( thenST, thenST_, returnST, newVar, ...
17:19:43 <palomer> @hoogle LazyStateThd
17:19:43 <dons> getchar = getch       `thenST` \c -> putchar c   `thenST_` returnST c
17:19:44 <lambdabot> No matches found
17:19:58 <palomer> erm, so... is it state transformer or state thread?
17:20:04 <dons> palomer, I'm referring to obsolete versions of experimental IO defns from 15 years ago.
17:20:07 <Mitar> and what should i specify for second parameter?
17:20:12 <dons> ST stands for state thread.
17:20:35 <Mitar> putTraceMsg ...
17:21:00 <dons> putString     :: String -> IO ()
17:21:01 <dons> putString      = seqST . map putchar
17:21:01 <Cale> palomer: basically, it's a monad whose only special operations are the maintenance of STRefs and ST(U)Arrays
17:21:20 <palomer> The ST Monad
17:21:21 <palomer> data ST s a
17:21:21 <palomer> The strict state-transformer monad.
17:21:38 <Cale> palomer: and there's a runST :: (forall s. ST s a) -> a
17:22:00 <palomer> how do you put and get?
17:22:18 <Cale> newSTRef :: a -> ST s (STRef s a)
17:22:21 <Cale> readSTRef :: STRef s a -> ST s a
17:22:25 <Cale> writeSTRef :: STRef s a -> a -> ST s ()
17:22:34 <Cale> and  modifySTRef :: STRef s a -> (a -> a) -> ST s ()
17:22:38 <dons> palomer, did you read Control.Monaad.ST? :
17:22:39 <dons> -- This library provides support for /strict/ state threads, as
17:22:39 <dons> -- described in the PLDI \'94 paper by John Launchbury and Simon Peyton
17:22:39 <dons> -- Jones /Lazy Functional State Threads/
17:22:57 <palomer> dons: yeah, just realized it, but that seems confusing
17:23:08 <dons> it's just a name
17:23:12 <Cale> there are both strict and lazy versions of ST.
17:23:48 * palomer still doesn't see how one could possibly use this stuff
17:24:20 <dons> palomer, seriously?/
17:24:25 <palomer> seriously
17:24:28 <dons> didn't I just say you can implement IO with it.
17:25:20 <Cale> > Control.Monad.ST.runST $ do { r <- newSTRef 0; writeSTRef r 5; modifySTRef r succ; readSTRef r }
17:25:21 <lambdabot>  Not in scope: `readSTRef'
17:25:24 <dons> check STRef, that's the most common use these days
17:25:30 <dons> ah, as Cale points out.
17:25:39 <Cale> > Control.Monad.ST.runST $ do { r <- Control.Monad.ST.newSTRef 0; Control.Monad.ST.writeSTRef r 5; Control.Monad.ST.modifySTRef r succ; Control.Monad.ST.readSTRef r }
17:25:41 <lambdabot>  Not in scope: `Control.Monad.ST.readSTRef'
17:25:52 <Cale> well, that module isn't available
17:26:04 <ihope> You know, I can't figure out what type of programming lanugage wouldn't be functional...
17:26:18 <palomer> oh, I see
17:26:22 <Korollary> yes, perl is very dysfunctional
17:26:32 <palomer> so if I wanted to name my states I would do stateNames = A | B | C | ...
17:26:37 <Cale> ihope: any which doesn't support functions as first class values?
17:27:00 <ihope> Cale: But isn't the whole program a function?
17:27:08 <dons> ihope, my supervisor often says that every language approaches/is doomed to rediscover functional programming in its limit.
17:27:08 <Cale> ihope: no
17:27:17 <ihope> RealWorld -> RealWorld?
17:27:36 <Cale> ihope: That's a useless way to think of it.
17:28:11 <palomer> Cale: but, erm, that would mean that I would have to pass r around everywhere, right?
17:28:36 <ihope> Cale: but it's surely correct...
17:28:37 <Cale> palomer: yeah, but you get as many references as you like
17:28:51 <Cale> ihope: I'm unconvinced that it's well-defined :)
17:29:15 <Heffalump> hi pitarou
17:29:28 <Cale> It'll pretty quickly degenerate into philosophical nonsense
17:29:39 <palomer> Cale: doesn't that kind of defeat the purpose?
17:29:46 <Cale> palomer: how so?
17:29:52 <ihope> Cale: Still, the umbrella type of all its instructions...
17:30:01 <palomer> passing around references explicitly
17:30:25 <Cale> palomer: well, passing references is much different from passing values.
17:30:49 <pitarou> Heffalump:  Hello.  You can't have my hunny!
17:30:57 <Heffalump> aww :-)
17:31:17 <Heffalump> (I'm guessing from your hostname that you're in the same city as me, so I could come and steal it really easily..)
17:31:38 <pitarou> Heheh.  No you can't.  I only have treacle.
17:31:48 <Heffalump> most inconsiderate of you
17:32:39 <pitarou> Sorry, Heffalump.  This is my first time in #haskell.  Is that a channel rule?
17:33:07 <Heffalump> if only :-)
17:33:46 <pitarou> Is there anybody here who would like to share their wisdom regarding installing Gtk2Hs?  (Gtk2 bindings for Haskell.)
17:34:01 <Heffalump> what platform?
17:34:07 <Cale> ihope: besides, the idea of a functional language isn't to model the program as a whole as a function, but for the language to provide semantics to manipulate proper referentially transparent, first class, mathematical functions
17:34:18 <Heffalump> @seen dcoutts
17:34:18 <pitarou> debian
17:34:19 <lambdabot> dcoutts is in #haskell and #gentoo-haskell. Last spoke 5 hours, 39
17:34:19 <lambdabot> minutes and 33 seconds ago.
17:34:41 <ihope> Meh
17:34:45 <Heffalump> I don't use it, but lots of people do.
17:34:51 <pitarou> Oh dear.  It looks like dcoutts goes to bed at a sensible hour.
17:34:52 <Heffalump> are you having a specific problem?
17:35:16 <Cale> ihope: and to generally support the style of "functional programming"
17:35:36 <pitarou> Yes.  It's really only a tiny glitch.  I wouldn't even have noticed it if it weren't for the fact that everything else Just Works (TM) so well.
17:36:12 <Cale> pitarou: I install it from the darcs repo
17:36:18 <Cale> (I'm on debian)
17:36:24 <pitarou> Thanks, Cale!  My hero.
17:36:46 <Heffalump> woohoo. I nearly have a Debian ARM system running under qemu.
17:37:07 <Heffalump> well, I have one, and it's nearly at a point where I could try to build GHC on it.
17:37:45 <pitarou> Cale: I installed it with the --enable-docs option.  The problem is, I don't know what directory to give for the --with-ghc-docdir= option.
17:38:29 <Cale> /usr/share/doc/ghc6-doc ? I don't really know
17:38:36 <Heffalump> that would be my guess too
17:38:37 <Cale> I just use the docs on the web.
17:38:45 <pitarou> I prefers to install things using aptitude whenever humanly possible.  This whole "./configure, make, make install" business is pretty new territory for me.
17:38:58 <Cale> http://haskell.org/gtk2hs/docs/current/
17:39:06 <Heffalump> make a deb, then :-)
17:39:16 <dons> using a flop function that reverses by pattern matching takes 25% off the fannkuch benchmark. hmm
17:39:30 <Heffalump> /usr/share/doc/ghc6-doc/html would be the other possibility
17:39:40 <pitarou> Thanks, Heffalump.  >:-(
17:39:46 <Heffalump> you'll need ghc6-doc, of course.
17:40:48 <pitarou> I have ghc-doc, and I tried both of those suggestions, and one other, but haddock still doesn't link the Gtk2Hs docs to the standard library docs.
17:41:53 <Cale> pitarou: I'm not sure if it's even supposed to do that
17:42:06 <pitarou> Cale: It does in the on-line version.
17:42:06 <Heffalump> I think it is.
17:42:31 <Heffalump> what was the other idea you tried?
17:42:38 * pitarou looks up the relevant quote from the installation guide
17:42:38 <Heffalump> /usr/share/doc/ghc6-doc/html/libraries is my next bet.
17:42:43 <Korollary> dons: any new ideas on the mandelbrot entry?
17:42:49 <pitarou> Heffalump: That was the other one I tried!
17:42:51 <Heffalump> (having actually looked at the directory tree properly, now)
17:43:22 <Heffalump> /usr/share/doc/ghc6-doc/html/libraries/base is my next next bet.
17:43:28 <pitarou> --with-ghc-docdir=<dir to haddock documentation of GHC libraries>   This option is necessary if haddock should link standard data types   (like Maybe) to the GHC documentation.
17:44:04 <pitarou> Ah-ha!  Thanks, Heffalump.
17:44:39 <pitarou> I'll try that.
17:44:43 <dons> anyone want to write the TH to generate this:
17:44:44 <dons> flop 2 (x1:x2:xs) = x2:x1:xs
17:44:44 <dons> flop 3 (x1:x2:x3:xs) = x3:x2:x1:xs
17:44:44 <dons> flop 4 (x1:x2:x3:x4:xs) = x4:x3:x2:x1:xs
17:44:46 <dons> ..
17:44:53 <dons> or will the TH be more lines anyway?
17:44:55 <Heffalump> how far?
17:45:06 <dons> up to flop 10.
17:45:11 <Heffalump> what happens beyond that?
17:45:16 <dons> see, http://www.haskell.org/hawiki/FannkuchEntry
17:45:27 <Korollary> ahaha
17:45:28 <dons> a degenerate case for flop n kicks in
17:45:47 <pitarou> flop n list = reverse (take n list) ++ (drop n list)  ??
17:45:58 <Heffalump> pitarou: he wants speed
17:46:03 <Heffalump> not prettiness
17:46:26 <dons> right :) it just so happens that pattern matching is really fast in this problem
17:46:27 <pitarou> Oh....  Speed and Haskell.  It's a long time since I've heard of those two in the same sentence!
17:46:36 <dons> pitarou, you'd be surprised.
17:46:58 <pitarou> dons:  I already am!
17:47:06 <Korollary> excluding line i/o, that sentence is ok
17:48:41 <dons> pitarou, see for example http://shootout.alioth.debian.org/benchmark.php?test=pidigits&lang=all
17:49:28 <dons> or http://shootout.alioth.debian.org/benchmark.php?test=chameneos&lang=all
17:50:15 <Heffalump> why is there GHC and GHC #2 ?
17:50:32 <dons> for some reason, if you submit improved versions, sometimes they keep around the old version
17:53:21 <dons> the idea is to allow a idiomatic and fast-hack version, but I don't know how they decide which ones to keep and which it replace
17:53:30 <dons> s/it/to/
17:53:51 <pitarou> dons:  I stand corrected!  Thanks.
17:54:34 <dons> for one, looks like concurrency is really haskell's forte these days
17:54:40 <pitarou> Is "TH" some kind of Haskell templating system that I have yet to learn about?
17:54:50 <dons> yep, a compile-time metaprogramming language.
17:55:07 <dons> it lets you construct and manipulate the program's abstract syntax inside the compiler
17:55:49 <pitarou> Like with Scheme macros?
17:56:03 <Heffalump> yes
17:57:32 <pitarou> Sweet.
17:57:43 <ihope> @index (>>>)
17:57:45 <lambdabot> Control.Arrow
17:58:05 <Heffalump> @type Control.Arrow.(>>>)
17:58:07 <lambdabot> Couldn't find qualified module.
17:58:07 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
17:58:07 <lambdabot> \\)?
17:58:29 <Heffalump> @type (Control.Arrow.>>>)
17:58:31 <lambdabot> forall (a :: * -> * -> *) d b c.
17:58:31 <lambdabot> (Control.Arrow.Arrow a) =>
17:58:31 <lambdabot> a b c -> a c d -> a b d
17:58:37 <Heffalump> helpful, is lambdabot
17:58:40 <pitarou> Heffalump: Are you based in Cambridge, then?
17:58:48 <Heffalump> yeah (Cherry Hinton)
17:58:51 <ihope> I need to learn arrows.
18:00:32 <pitarou> Heffalump:  And there was me thinking I was the only person in Cambridge who had any knowledge of Haskell!
18:01:24 <dons> pitarou, you know the secret Haskell HQ is at Cambridge?
18:01:42 <pitarou> With the obvious exception of Dr P-J himself, of course!
18:01:48 <gzl> huh?
18:01:56 <gzl> no, he's there.
18:01:58 <Heffalump> and Simon Marlow.. :-)
18:02:07 <Heffalump> and Alastair Reid
18:02:24 * pitarou blushes at his ignorance
18:02:26 <gzl> wait, are you talking about Cambridge the school, or just Cambridge, England?
18:02:28 <Heffalump> and lots of people at the Cambridge Computing Lab, surely.
18:02:31 <Heffalump> gzl: the latter.
18:02:31 <pitarou> I'm obviously moving in the wrong circles.
18:02:39 <gzl> ah, then all these people are there. :)
18:02:42 <pitarou> Cambridge the town.
18:03:05 <gzl> well, a lot of them, anyway
18:03:21 <Heffalump> I know of three people (including me) where I work that know Haskell well. Then there's the Simons at MSR at the very least.
18:03:21 <gzl> so Wadler visited yesterday and I couldn't go. :(
18:03:29 <Heffalump> :-(
18:03:51 <pitarou> My experience of the Cambridge CompSci department -- from the perspective of the one-year diploma course -- was that the only languages that count are Java, ML and BCPL.
18:04:13 <Heffalump> Oh, and dcoutts lives in Cambridge when he's not in Oxford.
18:04:26 <gzl> BCPL??
18:04:33 <gzl> people still use that?
18:04:45 <Heffalump> it was invented in Cambridge, so there are probably still some people in the lab who are obsessed with it :-)
18:04:54 <pitarou> Mind you, my perspective was rather warped.  I missed enormous chunks of it due to illness.
18:04:58 <gzl> bizarre!
18:05:10 <gzl> because BCPL was a precursor to B, not even C
18:05:16 <gzl> and nobody even uses B
18:05:23 <pitarou> BCPL.  Oh yes.  There's one lecturer who still raves about how wonderful it is because you don't have to worry about types.
18:05:33 <Heffalump> :-)
18:05:44 <Heffalump> I assume it's not actually taught, though?
18:05:57 <pitarou> It's part of the comparative languages course.
18:06:01 <gzl> wow
18:06:01 <Heffalump> ah, ok
18:06:06 <pitarou> The languages taught are Java, ML and Prologue.
18:06:16 <gzl> is there something called Prologue, or do you mean Prolog?
18:06:19 <Heffalump> so what got you into Haskell?
18:06:23 <Igloo> dons: http://musketeer.comlab.ox.ac.uk/~igloo/Q.hs works with ghc-cvs
18:06:41 <Igloo> although it's not much of a saving in terms of lines, or clarity
18:06:46 * Heffalump thinks enumerating it was clearer :-)
18:06:49 <pitarou> gzl:  Sorry.  Prolog.
18:06:55 <Heffalump> TH really needs quotation.
18:07:00 <Heffalump> though I guess that wouldn't help much here.
18:07:20 <Igloo> It has some, but not enough. But no, it wouldn't help much
18:07:41 <Heffalump> oh, of course it does
18:07:42 <Heffalump> duh
18:07:44 <pitarou> A slowly burgeoning interest in Programming Language Theory, I guess.
18:08:36 <pitarou> Before Haskell, I was big on Scheme.  Blame _Structure and Interpretation of Programming Languages_ for that.  Basically, I've got a lot of time on my hands.
18:09:02 <gzl> of Computer Programs, you mean? :)
18:10:25 <pitarou> Thanks again, gzl.  I saw a proof-readers position advert in the _Cambridge Weekly News_, if you're interested.  ;-)
18:10:38 <gzl> haha
18:10:44 <gzl> no thanks. I just do it as a hobby.
18:11:02 <gzl> but getting paid to be pedantic and annoying does sound tempting
18:11:04 <pitarou> In that case, check out Project Gutenberg.
18:11:36 <gzl> pitarou: you might like Types and Programming Languages
18:11:42 <gzl> if you're interested in PL theory
18:12:03 <ihope> I'd like some new syntax for comments.
18:12:12 <gzl> like what?
18:12:38 <araujo> pitarou, SICP isn't bad.You might be doing worse things, like programming in java for example.....
18:12:39 <ihope> Well, currently, if you want to comment a single piece of a line of code, you have to use the {- -} notation.
18:12:39 <Korollary> hmm. annoying & pedantic. That sounds like fun.
18:12:58 <Korollary> ihope: try "--"
18:12:58 <pitarou> gzl: Would that help me to grok Curry--Howard, Martin-Loef and Hindley--Milner?
18:13:03 <gzl> pitarou: yes
18:13:06 <ihope> I'd like some syntactic sugar for that.
18:13:17 <tic> syntactic sugar for comments? :)
18:13:26 <ihope> Korollary: comments in the middle of a line of code.
18:13:28 <ihope> tic: yes.
18:13:31 <araujo> Use literal hashell
18:13:47 <Heffalump> where you want to continue the code after the comment on the same line?
18:14:00 <Heffalump> how much shorter than {- -} do you want?
18:14:23 <gzl> pitarou: I don't think it covers C-H explicitly, but it certainly covers the background you need to read about it. it has stuff on HM. a lot of people in the channel have read it.
18:14:30 <ihope> Well, I want the comment to come on the line following the code.
18:14:37 <Heffalump> ihope: huh?
18:14:51 <araujo> Heffalump, That is kind of ugly, isn't that? 
18:14:58 <ihope> But I'd have the comment reference a specific piece of code.
18:15:20 <araujo> I just use, -- at the end of the line if necessarily needed
18:15:58 <araujo> And for things liñke, -- split of die!!!
18:16:05 <araujo> or*
18:17:08 <ihope> let r = aof $$ \x -> (3 |- (.) [head, last]) in r + 3
18:17:22 <ihope> -- The definition of r above means...
18:18:14 <ihope> Now, I could use slashes, but those aren't recognized by all interpreters as pertaining to that one bit of code...
18:18:39 <dons> Igloo, cheers! I'll stick it on the wiki as an option.
18:19:02 <pitarou> gzl:  Thanks.  That book has been recommended to me in a few places.  I'll ask the library to lend me a copy.
18:19:19 <Heffalump> which library?
18:20:03 <pitarou> Cambridge??
18:20:16 <pitarou> Cambridge City Library.
18:21:06 <Heffalump> you reckon that'll have it?
18:21:09 <Igloo> IME city libraries aren't much use for computer books unless you want to use Word and are a Dummy
18:21:32 <Korollary> ditto
18:22:00 <ihope> Igloo: IME?
18:22:07 <Igloo> In My Experience
18:22:09 <pitarou> Heffalump:  If I make a specific request, there's a good chance that they'll be able to get hold of a copy somewhere or, failing that, buy one.
18:22:12 <ihope> Ah
18:22:36 <Heffalump> I didn't know libraries had enough money to buy books on request these days
18:22:43 <Heffalump> s/libraries/city libraries/
18:22:47 <jwp> Are there any standard functions(in ghc) for converting a String to an Integer based upon a stated format(ie, network byte ordered int "string" to Integer[serialized int to Integer])?
18:23:25 <Lemmih> I recently donated 'Haskell: The Craft of Functional Programming' to Copenhagen's City Library. Their first and only book on functional programming (:
18:23:34 <dons> Igloo, I get: E.hs:17:2: Not in scope: data constructor `:'. Any idea why?
18:23:44 <ihope> Gasp.
18:23:48 <pitarou> Heffalump:  Well here's hopin'.
18:24:43 <sproingie> Lemmih: my library's cs section consists of books on cutting edge topics like PL/1 and FORTH
18:24:44 <Igloo> dons: I vaguely remember it being fixed a while back. I don't know if there's a way that does work OTTOMH and I'm too lazy to look  :-)
18:24:53 <dons> ok :)
18:24:54 <sproingie> Lemmih: and cobol.  lots of cobol.
18:26:57 <pitarou> My uncle still uses IBM punched cards as notepaper.
18:28:38 * pitarou has to go to the library on Monday anyway.  A book was due on Saturday.
18:30:00 <pitarou> Anyway, enough of my idle chatter about libraries -- of both kinds --  I need my beauty sleep.  Nice talking to y'all, and goodnight folks.
18:30:20 <ihope> Don't we all love COBOL?
18:30:59 <Korollary> I don't because I forgot cobol
18:31:44 <dons> I think Ralf Lammel is a big cobol fan.
18:31:48 <dons> @google ralf cobol
18:31:49 <lambdabot> http://www.cs.vu.nl/Cobol/
18:32:36 <dons> `COBOL is still the "market leader" when it comes to programming languages'
18:32:54 <dons> http://www.cs.vu.nl/Cobol/stop-bashing-cobol.pdf
18:32:56 <dons> hehe
18:34:15 <dons> Korollary, you asked about mandelbrot? have you tried the current proposal on the wiki?
18:38:11 <ihope> WOW, don't we all hate Adobe Acrobat Reader?
18:39:46 <Korollary> dons: I
18:39:58 <Korollary> dons: I've  been looking at your sml translation version
18:45:16 <ihope> So, I'm pondering whether or not to refresh that PDF file, thereby allowing Reader to go crazy with my system once again...
18:56:06 <Korollary> dons: On my linux x86 ghc-6.4.1, Int and Word32 perform identically for the mandelbrot.
18:58:17 <Korollary> @index (+#)
18:58:18 <lambdabot> bzzt
18:58:48 <ihope> @pretty newtype Var var val = [(String,var)] -> ([(String,var)], val)
18:58:49 <lambdabot> "Illegal data/newtype declaration" at column 38
18:58:56 <ihope> Eh.
18:59:05 <Heffalump> you missed out a data constructor
18:59:20 <ihope> ...Hmm?
18:59:23 <Heffalump> @pretty newtype Var var val = Var ([(String,var)] -> ([(String,var)], val)
18:59:24 <lambdabot> "Parse error" at column 67
18:59:29 <Heffalump> @pretty newtype Var var val = Var ([(String,var)] -> ([(String,var)], val))
18:59:30 <lambdabot>  newtype Var var val = Var ([(String, var)] ->
18:59:30 <lambdabot>            ([(String, var)], val))
18:59:44 <ihope> Oh
18:59:50 <Lemmih> Not very pretty.
19:02:18 <ihope> @type (>>=)
19:02:20 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
19:04:28 <dons> Korollary, ok. that's interesting. there seem to be a number of differences on OpenBSD.
19:04:38 <dons> @pl \i -> peekElemOff perm1 i >>= putStr . show . (+1)
19:04:39 <lambdabot> (putStr . show . (1 +) =<<) . peekElemOff perm1
19:05:04 <ihope> @index (-<)
19:05:05 <lambdabot> bzzt
19:05:07 <ihope> >:-)
19:06:37 <ihope> Aah! My brain crashed!
19:07:20 <dons> @index pokeElemOff
19:07:21 <lambdabot> Foreign.Storable, Foreign
19:07:46 <ncalexan> @type modifyMVar
19:07:47 <lambdabot> Not in scope: `modifyMVar'
19:07:58 <ncalexan> @type Control.Concurrent.modifyMVar
19:07:59 <lambdabot> forall b a. GHC.IOBase.MVar a -> (a -> IO (a, b)) -> IO b
19:08:21 <ncalexan> @type Control.Concurrent.modifyMVar_
19:08:22 <lambdabot> forall a. GHC.IOBase.MVar a -> (a -> IO a) -> IO ()
19:08:50 <ihope> @djinn ([(String,a)] -> ([String,a],b)) -> (b -> ([(String,a)] -> ([String,a],c))) ->  ([(String,a)] -> ([String,a],c))
19:08:52 <lambdabot> Cannot parse command
19:08:58 <ihope> :-D
19:12:19 <Korollary> Why am I getting compile errors for "a = 1#" ? I do import GHC.Base.
19:12:52 <Lemmih> Korollary: What error?
19:13:43 <Korollary> Lemmih: parse error (possibly incorrect indentation). But there isn't any. It goes away if I remove the #.
19:13:59 <ihope> What is #?
19:14:07 <Lemmih> Did you give -fglasgow-exts to GHC?
19:14:31 <Korollary> oops. Cheers.
19:16:16 <SamB> ihope: it is sharp syntax which you should be careful with lest you get hurt
19:17:04 <ncalexan> It gives unboxed reprs, no?
19:17:48 <SamB> ncalexan: something like that
19:17:59 <SamB> primitive variants of things, mostly
19:18:57 <SamB> like, "Hello, Sharp Pointy Death"# is the Addr of a C-style string containing those bytes
19:19:19 <ihope> Oh my.
19:19:29 <ncalexan> Oh?  That could be very useful at some point, thanks.
19:19:44 <ncalexan> Cheap marshalling :)
19:20:19 <SamB> ncalexan: dons has taken to scattering those throughout hmp3
19:20:33 <SamB> apparantly he has to get them out of his system somewhere ;-)
19:20:57 <ncalexan> hehe... we all have the dark side inside...
19:21:35 <ihope> The ugliest Haskell code I've ever written:
19:21:37 <ihope> (x >>= y) vars = breakVar (y (snd ((breakVar x) vars))) ((breakVar x) vars)
19:21:47 <dons>  as long as I keep them all in hmp3, they can't hurt anything else.
19:21:56 <ncalexan> dons: what are they there for?
19:22:03 <ncalexan> curses?
19:22:09 <SamB> ihope: you can factor out the ((breakVar x) vars)
19:22:25 <SamB> so that you only have one of them
19:22:28 <ihope> SamB: I'm not that kind of guy, am I?
19:22:45 <ihope> First I gotta get this stuff to actually work.
19:23:01 <SamB> ncalexan: so he can construct FastStrings directly
19:23:03 <ncalexan> SamB: I expect the compiler to do that; do you happen to know if GHC does all the time?
19:23:22 <Lemmih> It does.
19:23:26 <ncalexan> thx.
19:23:36 <SamB> well, the CSE pass doesn't make the source code easier to read!
19:23:36 <Lemmih> It even saves strings in a global hash table.
19:24:05 <SamB> sometimes the CSE pass is not run
19:24:13 <ncalexan> CSE = ?
19:24:16 <SamB> if you explicitly request this, for instance
19:24:20 <ncalexan> Constant sub expression?
19:24:28 <SamB> common sub expression
19:24:45 <ihope> Aah! I can't do it!
19:24:45 <SamB> I think that other thing is called lambda lifting or something like that...
19:24:52 <ihope> Somebody provide me with a variable monad.
19:25:46 <dons> ncalexan, yep curses, via FastStrings
19:27:56 <ncalexan> @type >>
19:27:57 <lambdabot> parse error on input `>>'
19:28:01 <ncalexan> @type (>>)
19:28:02 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> m b -> m b
19:28:30 <SamB> I tried to make him a RULE to keep them out of the source, but it doesn't seem to have worked...
19:28:42 <ncalexan> lambdabot is fantastic; the only problem is that I pollute the channel a lot ;)
19:29:06 <ncalexan> @type (>>=)
19:29:07 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
19:29:17 <SamB> ncalexan: at least when you can't get it right we can walk up behind you and give you hints ;-)
19:29:51 <ncalexan> :)  Many a lambdabot user setting that pms you the answer unless it fails, copying output to channel only then.
19:30:01 <ncalexan> But I guess that's a little anti-social.
19:30:08 <ncalexan> s/many/maybe/
19:30:40 <dons> SamB, it mostly worked.
19:30:47 <Korollary> We just love channel clutter
19:30:49 <dons> sometimes it doesn't fire. sometimes I'm lazy.
19:30:59 <dons> sometimes I just like ######
19:31:12 <SamB> dons: ah
19:31:26 <SamB> dons: one comment sounded as if it was firing BACKWARDS, which shouldn't be possible
19:31:32 <dons> 577:07 hmp3 0.3
19:31:48 <dons> ? backwards. no.
19:32:13 <lispy> OT: anyone here keep tropical pets like tarantulas?  I need advice on setting up/maintaining the environment/enclosure
19:32:38 <SamB> dons: okay, so I didn't really understand the comment ;-)
19:36:38 <azuroth> is there a mod_haskell? :-)
19:38:46 <azuroth> or a better question might be, I want a simple-ish project to get used to haskell: any suggestions?
19:41:02 <Korollary> azuroth: You can hack on some shootout entries like this: http://haskell.org/hawiki/KnucleotideEntry :)
19:41:31 <lispy> azuroth: do you have a math background?
19:41:40 <azuroth> no, not much maths
19:41:54 <lispy> azuroth: i got my feet wet implementing number theortic...oh n/m then :)
19:42:00 <lispy> hmm..
19:42:06 <lispy> azuroth: what is your background in?
19:42:11 <lispy> we'll find you something cool to work on
19:42:38 <lispy> azuroth: and there is WASH and one other web framework for haskell
19:42:42 <jwp> azuroth: I think I saw a mod_haskell floating around somewhere.
19:43:08 <azuroth> my background is mainly just procedural coding
19:45:08 <Korollary> azuroth: do you want to start from scratch or work on something that already exists?
19:45:26 <azuroth> would a GUI take lots of scary monads?
19:45:29 <azuroth> probably from scratch
19:45:48 <lispy> azuroth: then you probably want to stay away from "gentle introduction to haskell", it assumes functional programming knowledge
19:45:59 <jwp> hehe
19:46:08 <jwp> "gentle"
19:46:13 <lispy> heh, yeah
19:46:39 * jwp has been trying to read it..
19:46:53 <lispy> man, ocaml still cleans the floor with ghc http://shootout.alioth.debian.org/debian/benchmark.php?test=all&lang=ghc&lang2=ocaml
19:47:03 <azuroth> maybe I should just go through all the examples in craft of functional programming. I think I skipped a fair few
19:47:09 * Korollary is possibly the only person in the world who had no issues with the gentle intro.
19:48:03 <jwp> Korollary: did you write anything good directly after reading it? :)
19:49:01 <Korollary> jwp: I could read integers from a file and print out their sum. Things like that.
19:50:53 <Korollary> A haskell tutorial is a difficult project. It's either too terse, or too long to be called a tutorial if the reader is not supposed to have any fp experience.
19:50:59 <lispy> Korollary: i never read it :)  but i had enough fp bg that i just needed to learn haskell specific things when i started...
19:51:29 <lispy> well, and i had a class at my school that taught haskell
19:51:47 <lispy> i've actually taken 3 classes, two were intros and one was about monads and topics of that nature
19:53:16 * jwp shakes his fist at his almost useless python and C experience. ;)
19:53:16 * SamB gives up on SqueakMap until they put out a newer image and/or he gets a better net connection...
19:53:24 <SamB> jwp: C is good!
19:53:30 <lispy> jwp: python should help, it has list comps
19:53:33 <SamB> just don't think Haskell will be a thing like it
19:53:33 <Korollary> tutorials are for dialects of the languages you already know. c# tutorial for java coders, scheme for lisp coders, ruby for perl coders, etc. You could write a haskell tutorial for ML coders, but not for C++ coders, imho.
19:53:46 <lispy> SamB: squeakMap?
19:53:50 <SamB> jwp: you can use that once you get to FFI
19:54:03 <SamB> lispy: SqueakMap
19:54:18 <jwp> FFI?
19:54:18 <SamB> it keeps giving nasty errors when I try to update to the newest version...
19:54:26 <lispy> SamB: so it's a data construtor?
19:54:33 <azuroth> python's list comprehensions are ugly, in my opinion. ;-p
19:54:38 <SamB> jwp: Interfacing Foreign Functions.
19:54:46 <SamB> its from the french ;-)</silly-joke>
19:54:51 <lispy> SamB: oh
19:55:10 <SamB> lispy: the package system for Squeak?
19:55:19 <lispy> SamB: the only time i tried squeak i wanted to use ThingLab, but it was horribly broken
19:55:20 <jwp> SamB: ah, yes. That C experience also came in handy when I needed to speed things up in Python.
19:55:51 <SamB> jwp: Haskell's FFI seems easier
19:56:02 <lispy> SamB: when i tried to open the thinglab package squeak would work till about 90% complete then disappear without a trace
19:56:16 <jwp> SamB: If you don't have to INC/DEC ref anything, it probably is. :)
19:56:50 <SamB> that is, you don't need all that boilerplate to just create a module, and you only actually have to write C if you need extra glue...
19:57:10 <SamB> or if you want to interface with *new* C code
19:58:13 <SamB> as long as you don't have to pass structs directly or access their fields directly, you can generally do it fine straight from Haskell...
19:58:22 <SamB> 'course sometimes its easier to do some in C ;-)
20:00:46 <jwp> hrm
20:04:13 <lispy> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=ghc&lang2=ocaml
20:04:24 <lispy> hmm...maybe ghc is better than ocaml ona pentium4 :)
20:05:10 <Korollary> it's not conclusively better
20:05:34 <lispy> yeah, but it does a lot better on that pentium than it does on the other machine they have
20:05:40 <Korollary> sempron
20:05:41 <palomer> 	Full CPU Time 	Memory Use 	Code Lines 	  	 
20:05:41 <palomer>   	6:12 	6:11 	7:8 	 
20:05:50 <palomer> it seems that ocaml beat ghc
20:06:29 <Korollary> the interesting one is ghc vs java, imho.
20:07:01 <palomer> java still beat ghc in cpu time
20:07:16 <Korollary> the gap is very narrow
20:07:44 <lispy> what is interesting to me is that ocaml appears to be a pretty solid fp lang, but seems close to C in performance
20:08:05 <Korollary> it doesnt look like an fp lang if you read the entries, tho.
20:08:18 <palomer> is the mandelbrot code idiomatic?
20:09:02 <Korollary> mandelbrot requires you to print out character by character, so it's a bit hard.
20:09:20 <SamB> looks like erlang barely beats GHC in cheap concurrency, and loses everywhere else...
20:09:54 <SamB> unless you count the dramatically lower memory usage in "fasta"
20:10:10 <Korollary> fasta is a ghc library problem
20:10:20 <Korollary> so is reverse-comp
20:10:49 <lispy> the one that surprised me was ghc vs. sbcl
20:10:53 <palomer> going to be fixed?
20:11:14 <Korollary> once FPS is comes with GHC, we can use it for shootout entries.
20:11:17 <lispy> well, if they get fixed it should be the haskell library that gets the fix
20:11:18 <Korollary> -is
20:11:20 <palomer> oh my, ghc is 16 times slower than C
20:11:34 <palomer> FPS?
20:11:39 <Korollary> FastPackedStrings
20:11:44 <Korollary> -s
20:11:50 <Korollary> @where fps
20:11:51 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
20:13:27 <lispy> hmm...just comparing the debian to gentoo results gives very different benchmarks
20:13:40 <palomer> which is faster?
20:13:41 <jwp> is there an ntohl/htonl equivalent in ghc's standard lib or do I have to write my own? (asked earlier, but not as clearly :)
20:13:43 <lispy> i need to readup on the difference between the setups
20:14:02 <Korollary> jwp: what is ntohl ?
20:14:16 <jwp> htonl, htons, ntohl, ntohs -- convert values between host and network
20:14:16 <jwp>      byte order
20:14:22 <lispy> are those the network byte ordering functions from C?
20:14:27 <lispy> ah
20:15:17 <jwp> and perhaps something to convert the raw strings to Integers. |sorry for the lame questions :(
20:15:33 <SamB> I notice we get 2nd place in the pidigits benchmark
20:16:12 * palomer wonders how jhc will perform
20:16:13 <SamB> jwp: what for?
20:16:28 <SamB> you don't likely need them...
20:16:50 <jwp> SamB: first attempt at a binary protocol implementation.
20:16:58 <SamB> oh
20:17:11 <SamB> well, I'd just write it straight
20:17:15 <SamB> its probably faster anyway
20:17:26 <SamB> @docs Data.Bits
20:17:27 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Bits.html
20:18:10 <SamB> that, or just use divMod/*
20:18:16 <SamB> @type divMod
20:18:17 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
20:18:33 <SamB> also fromEnum/toEnum...
20:19:09 <SamB> anyway, where do you expect to put the output of htonl?
20:20:33 <jwp> mm
20:21:32 <SamB> binary protocals are a bit painful...
20:21:36 <azuroth> are 'chr' and 'ord' library functinos?
20:21:39 <SamB> I used Parsec for reading ;-)
20:21:43 <SamB> azuroth: yeah
20:21:48 <SamB> @docs Data.Char
20:21:49 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Char.html
20:22:02 <jwp> the output of the "htonl" is used to specify the length of the message
20:22:11 <SamB> they are restricted-type versions of fromEnum/toEnum
20:22:31 <SamB> jwp: no, I mean how do you intend to turn it into something you can put on the wire?
20:22:38 <jwp> so, I would then use that size to either base how much I would be reading, or perhaps, later, validate that I have read the expected amount
20:23:05 <azuroth> that's weird. ghci doesn't seem to like them
20:23:18 <jwp> SamB: that's likely the other functions that I was looking for. something that gives me the functionality of python's struct.pack and struct.unpack, more or less.
20:24:00 <jwp> was/am
20:24:01 * SamB wonders how Conjure does it now that Lemmih moved everything around and changed stuff
20:24:56 <jwp> feh, I guess I'll write em' myself for now with ord and chr
20:25:39 <SamB> hmm
20:25:47 <SamB> its been remodeled a good bit...
20:26:08 <SamB> one thing I wonder about is why node IDs are still Strings...
20:26:14 <SamB> and not FPS.FastStrings
20:26:31 <SamB> it still has mostly the same shape, except it doesn't seem to use Parsec for input anymore
20:26:42 <SamB> I admit that was just a "get it to work" solution
20:29:21 <azuroth> hmm. I don't have isDigit or anything
20:29:35 <azuroth> but I do have elem. :s
20:30:46 <SamB> azuroth: you need to do :m +Data.Char
20:31:31 <azuroth> aha! cool. is there any way to do that in the source file? import Data.Char?
20:32:30 <SamB> exactly
20:32:59 <azuroth> cool. I'm surprised the book didn't mention that
20:33:03 <SamB> would be silly for there to be a way in GHCi but none in a source file...
20:33:11 <SamB> that would be kinda useless ;-)
20:41:14 <palomer> the second item on LtU is a dead link:(
20:43:18 <palomer> pfft
20:45:22 <jwp> Are there any other haskell tutorials that might be good reading? (I've seen the "C programmer's intro to haskell", and, of course, haskell.org/tutorial)
20:45:33 <SamB> probably
20:45:36 <SamB> maybe YAHT
20:45:49 <SamB> @google YAHT Haskell Tutorial
20:45:50 <lambdabot> http://www.isi.edu/~hdaume/htut/
20:45:55 <SamB> thats it
20:46:11 <SamB> @google YAHT
20:46:11 <jwp> aye, got it from haskell.org/learning.html
20:46:12 <lambdabot> http://www.urbandictionary.com/define.php?term=yaht
20:46:25 <SamB> we still need to work on our plans for world domination...
20:47:16 <jwp> mm, 193 pages :)
20:53:17 <palomer> I plan to dominate with my voice
21:02:23 <lispy> i want a wiki specificly designed for working on research papers (ie, it should support the right look and feel, probably meaning all the mark up is latex)
21:03:18 <azuroth> @docs fromInt
21:03:19 <lambdabot> fromInt not available
21:03:42 <azuroth> @help
21:03:43 <lambdabot>  @help <command> - ask for help for <command>
21:03:51 <azuroth> @commands
21:03:53 <lambdabot> Unknown command, try @listcommands.
21:19:08 <ncalexan> @type (<<)
21:19:09 <lambdabot> Not in scope: `<<'
21:30:16 <nathan_> hi
21:30:34 <nathan_> anybody here read ``The Haskell School of Expression'' ?
21:30:40 <palomer> no!
21:30:56 <SamB> I have it!
21:31:06 <SamB> what about it are you wondering?
21:31:22 <nathan_> Well, I am trying to do the chapter 3 exercise (snowflake fractal)
21:31:29 <SamB> oh.
21:31:38 * SamB hasn't done any of the exercises yet
21:31:44 <nathan_> and I am having a bunch of trouble turning floating point type numbers into integers
21:31:49 <SamB> ah
21:32:10 <SamB> I thought you were supposed to use integers from the start?
21:32:20 <nathan_> I need to scale stuff by sin and cos
21:32:29 <SamB> oh.
21:32:41 <SamB> maybe I'm thinking of the Seirpinski gasket
21:32:50 <lispy> fromIntegral
21:32:57 <lispy> @type fromIntegral
21:32:58 <lambdabot> forall b a. (Num b, Integral a) => a -> b
21:32:59 <SamB> :i RealFrac 
21:33:03 <nathan_> yeah, on that one you can get away with just using `div`
21:33:08 <SamB> lispy: only works on integrals
21:33:23 <SamB> @type round
21:33:24 <lispy> SamB: hmm...
21:33:25 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
21:33:41 <SamB> anyway, like I said. :i RealFrac should prove interesting.
21:34:44 * SamB checks to make sure Ratio is an instance... and it is
21:35:14 <SamB> would seem silly to distinguish it from RealFloat if it didn't have an instance for Ratios
21:38:44 <nathan_> I have tried using fromInteger and fromIntegral in various ways, but I always end up with an error like: instances of ... required for definition of ...
21:39:16 <SamB> yeah.
21:39:27 <SamB> because floating point numbers are of course not integral ;-)
21:40:01 <nathan_> oh, sorry, I am trying truncate and floor too
21:46:14 <orbitz> morning SamB 
21:46:31 <SamB> orbitz: night orbitz
21:46:58 <SamB> should have gone to bed already...
21:53:37 <nathan_> ok, I think I got it: if I do truncate (x + l * sin t) but x and l are both supposed to be of type Int (so I can use them to construct Points elsewhere) then I need to pass them to fromIntegral first.  Of course, if I just move them outside the truncate call, the whole problem disappears.
21:57:25 <SamB> but that is probably not a good idea...
21:57:35 <SamB> maybe you should move the truncate call out even further?
21:57:55 <orbitz> SamB: night
21:58:32 <SamB> yes. okay, I'm going to go to bed...
21:58:36 <SamB> NOW!
22:00:34 <nathan_> move the truncate call out further ?
22:12:52 <azuroth> aww. I wish there was a ':time' function in ghci
22:18:04 <palomer> why?
22:24:42 <palomer> WHY
22:26:30 <azuroth> no really good reason
22:27:03 <ncalexan> Benchmarking code in GHCi is probably not meaningful, anyway.
22:28:26 <azuroth> I want to know which of two ways of factorial are faster
22:29:16 <azuroth> factorial n = foldl1 (*) [1..n]        or  facorial n | n > 1 = factorial (n - 1) ...
22:30:08 <azuroth> I mean.. I don't _want_ to know, I was just interested
22:39:55 <TheHunter> in an ideal world, they should be the same, but I fear that the second one will actually be faster.
23:26:09 <dons> ah, the fannkuch rewritten in imperative style is much faster, without even trying
23:26:22 <dons> some of these benchmarks are way biased to imperative impls.
23:29:22 <ncalexan> How can a benchmark be biased?  It's just a problem statement.
23:31:28 <dons> they're problems with given C solutions in mind. (so restrictions to word-sized values, for example. or they state other limits, such as maximum line lengths)
23:32:05 <ncalexan> Mmm.
23:33:06 <Korollary> dons: iirc, the fannkuch problem came from a LISP paper.
23:33:07 * araujo greets dons 
23:34:22 <dons> yeah, fannkuch has some nice functional implementations
23:34:57 <dons> but it really wants you to destructively overwrite memory, oh well
23:35:40 <Korollary> a lot of things in the world benefit from smart space management.
23:37:52 <dons> true. like my lounge room!
23:41:04 <dons> anyway, I translated the C version into Haskell, and already its much faster than our nice functional versions. yay for destructive updates
23:41:11 <dons> (of fannkuch)
23:43:15 <Korollary> Did you use arrays or Ptr's?
