00:00:02 <Keal> those only 3 opcodes other than peek and carry
00:01:34 <Keal> alogithm is called flegm
00:01:46 <Keal> not many people know about flegm
00:01:54 <Keal> mabey 20 people most
00:03:23 <Keal> nsa seized flegm
00:03:31 <Keal> so i reproduce from memory tomorrow
00:03:49 <lispy> Keal: please don't reproduce :(
00:04:25 <Keal> i am unable to reproduce :'(
00:04:35 <Keal> i am fiancee isnt
00:04:46 <Keal> supposedly i am
00:04:49 <Keal> but i love her
00:04:59 <Korollary> oh please tell us more
00:05:00 <integral> please don't get the NSA to shut down this channel
00:05:19 <Keal> might not be able to since was once electrocuted while tied to chair
00:05:59 <Keal> nsa only prevent me from returning to math on efnet
00:06:14 <Keal> they send enormous flood from asu
00:06:24 <Keal> and it never stop
00:07:06 <Keal> 3 years later... still being flooded
00:07:50 <Keal> they think a script kiddie is doing it. but is done by nsa
00:08:37 <Keal> nsa try kill me numerous times
00:08:46 <Keal> i even memorized assassin's face
00:09:10 <Keal> they even make light green both ways once
00:09:20 <sieni> where are the channel ops? could you please do your duty!
00:10:15 <Keal> ok i shup
00:10:23 <Keal> :<
00:10:55 * Keal gets head start on plegm
00:12:29 <newsham> no channel ops.  use your /ignore
00:15:07 <sieni> newsham: this is freenode. the actual channel operators can request the server to op themselves
00:17:34 <C-Keen> as in real live you can always ignore the idiots silently...
00:18:30 <maitscha> hallo! is there a function in haskell for factoriell, eg 7! = 7*6*5*4*3*2*1 ??
00:20:17 <skew> maitscha: there are many! see http://www.willamette.edu/~fruehr/haskell/evolution.html
00:23:43 <skew> you probably want to define fact n = product [1..n]
00:24:43 * Keal fails you :(
00:25:03 <sieni> hmm... this /ignore thingie seems to work well
00:26:33 * Keal turns off vb6
00:27:45 * Keal tired -.-;
00:28:15 <araujo> Hello.
00:28:54 * Keal need to buy rack of ribs tomorrow
00:28:58 <Keal> ribs good food
00:29:28 <chucky> hi araujo
00:29:34 * lispy is not a fan of ribs
00:29:48 <lispy> i find i'm moving towards vegetarianism as the years go by
00:29:48 <araujo> Hello chucky , how you doing?
00:30:31 <chucky> araujo: Great. You?
00:32:20 * gour 'celebrates' 19th year of being vegetarian, next year 20th, huh..time's passing quickly
00:32:43 <sieni> that's a while
00:32:58 <sieni> I used to be vegetarian for several years, but eventually quit
00:33:07 <gour> why?
00:33:21 <newsham> gour: more options?
00:33:37 <araujo> chucky, well, thanks, just got up and hungry! :-)
00:33:38 <gour> newsham: i don't think so
00:34:08 <newsham> |meats| + |vegetables| > |vegetables|
00:34:45 <sieni> It just somehow gradually finished
00:35:07 <sieni> Some of my favourite dishes are vegetarian, still.
00:35:20 <gour> |vegetables| + |grains| + |milk| + |fruits| >> |meats| + |vegetables|
00:35:50 <gour> (i.e. no need for meat)
00:35:52 <newsham> x < x +|meats|
00:36:18 <gour> newsham: what you get by meat (except some taste) ?
00:36:42 <Keal> i dont really eat vegetables
00:37:41 <Keal> unless cheese is a vegetable
00:37:50 <dons> congrats gour. i'm up to my 10th year of vegan bliss :)
00:38:19 <gour> dons: i hope you noticed how the brain functions differently :-)
00:38:37 <newsham> except taste?  heh..  you ask as if thats unimportant.
00:38:45 <gour> dons: and i wish you to have 20th year too
00:38:45 <newsham> social convenience I guess would be another
00:39:03 <dons> newsham, taste can be the same, if you like meat tastes
00:39:09 <dons> cheers gour
00:39:12 <chucky> newsham: the taste of meat seems rather unimportant after a while anyway
00:39:29 <gour> if i'd care for social convenience, i'd probably java :-)
00:39:30 <chucky> (I'm one of those pesky vegetarians as well, for 4 months now)
00:39:44 <dons> hooray!
00:39:49 <maitscha41> sorry, my telefon-line hanged up.
00:39:53 <Keal> pork steaks taste like dick
00:39:55 <Keal> :(
00:39:57 <newsham> here's a convenience factor in practice -- you can make good vegetarian dishes that taste as good as good meat dishes, but usually at increased effort
00:40:04 <dons> we need to start #haskell-vege
00:40:06 <chucky> keal: How do you know? ;)
00:40:09 <newsham> and in many places you cant buy good vegetarian meals
00:40:22 <maitscha41> has somebody see my last message
00:40:26 <maitscha41> @seen maitscha
00:40:27 <lambdabot> I saw maitscha leaving #haskell 33 seconds ago.
00:40:28 <gour> newsham: that's another reason to start prepare food by yourself
00:40:40 <newsham> gour: cooking is one of my hobbies.
00:40:47 <newsham> but like most my hobbies, I dont have a lot of free time to do it
00:40:52 <maitscha41> interpretNext :: [Token] -> [Int] -> [Int]
00:41:00 <maitscha41> interpretNext (Add : xs) l
00:41:01 <maitscha41>     | length l >= 2 = interpretNext $ xs ([head l + second l] ++ (tail (tail l)))
00:41:17 <maitscha41> type error in application, xs, [Token] does not match a->b
00:41:29 <gour> newsham: sure, but it is worth enough, instead of eating all the vibrations of horribly slaughtered poor animals
00:41:43 <newsham> (not to mention you cant make vegetables taste like a braised rabbit or a duck liver)
00:41:49 <Korollary> only vegetarian people think vegetarian dishes can be as good as meat dishes :)
00:41:59 <newsham> I dont eat vibrations of horribly slaughtered poor animals.
00:42:04 <Keal> i want to invent white dye
00:42:13 <gour> today all the animals are under the drugs in teh slaughterhouse in order to survive until execution
00:42:15 <Keal> i think i shall call is boliche
00:42:24 <newsham> I eat a combination of dead animal and plant matter.
00:42:32 <maitscha41> @localtime maitscha
00:42:38 <gour> newsham: you eat 100%
00:43:00 <newsham> dead animals dont vibrate any differently than dead plants.
00:43:11 <Keal> does newsham eat dead plants too?
00:43:18 <Keal> or just living ones?
00:44:05 <gour> newsham: not true, and besides that for many vegetables you don't kill the plant, just pick the fruit
00:44:36 <maitscha41> does anybody know what the error could be?
00:44:58 <gour> newsham: anyway, no use to preach vegetarianism to those not interested in. i'm enjoying myself and share with others ;)
00:45:05 <Keal> so menstrual blood is like picked fruit?
00:45:10 <dons> maitscha41, you're trying to apply 'xs' to rguments.
00:45:16 <dons> are you missing a function call ?
00:45:37 <newsham> animals are just waving particles
00:45:53 <gour> newsham: as yourself?
00:45:55 <Korollary> maitscha41: What is "Add" ? A type?
00:46:08 <newsham> plants and animals eat each other.  thats what made our planet so pleasantly blue and green
00:46:41 <Korollary> gour: do cats eat other cats?
00:47:06 <newsham> korollary: are we talking house cats, or the family of all cats?
00:47:10 <newsham> if the latter, yes.
00:47:34 <gour> newsham: any living entity has its own prescribed food. tigers usually don't eat rice and for them it is allowed to eat flesh, but humans have a power of discrimination and therefore responsibility
00:47:49 <Korollary> newsham: I think it's a matter of inconvenience. My fellow human beings can defend themselves too well. I'd probably end up eating an animal I can dominate. Nothing philosophical.
00:47:50 <gour> Korollary: what's the point?
00:48:31 <newsham> gour: humans do not have responsibilities other than those they imose on themselves.
00:48:45 <gour> newsham: you'll see later..
00:49:13 <newsham> existence is.  there is no moral judgement.
00:49:15 <Korollary> I'm with newsham on that one.
00:49:21 <newsham> thats a construct of our overly active grey matter.
00:49:32 <Keal> i am going to bed
00:49:36 <Korollary> newsham: overly is also arbitrary. it is what it is.
00:49:38 <Keal> i cant think anymore
00:49:38 <newsham> useful for social interaction
00:49:49 <Keal> nite
00:49:52 <Keal> zzz
00:50:03 <dons> @seen shapr
00:50:04 <lambdabot> shapr is in #ScannedInAvian. Last spoke 17 hours, 55 minutes and 30
00:50:04 <lambdabot> seconds ago.
00:50:19 <newsham> all these moments will be lost like tears in rain.
00:50:19 <gour> that's because we think we are the only ones in the whole universe...so strange...
00:50:23 <newsham> time to die.
00:50:32 <Korollary> gour: it doesnt even matter if we're the only ones
00:50:54 <gour> Korollary: it matters...God does not throw the dice
00:51:12 <Korollary> oh, I was largely ignoring God's part in all this.
00:51:19 <gour> :-)
00:51:19 <Keal> nite
00:52:01 <JKnecht> definitely matters, only intelligent species would be proof of a stern and very active external intelligence.
00:52:07 <gour> 'night
00:52:12 <Korollary> night
00:53:04 --- mode: ChanServ set +o dons
00:54:23 --- mode: ChanServ set -o dons
01:14:33 <gour> anyone familiar with thompson's "craft of fp" book and/or can help with type unification exercise?
01:15:14 <chucky> gour: Which exercise is it, and which page?
01:15:48 <gour> chucky: 14.48 (p274)
01:18:18 <chucky> *looking at it now*
01:18:26 <gour> chucky: thanks
01:21:07 <chucky> it feels obvious (to me) that the method is generalisable, but I'm not sure how to prove it (yet any way)
01:21:30 <gour> same here
01:21:45 <gour> i.e. if i have instance A a => A (a,b)
01:22:02 <gour> and instance B b => B (a,b)
01:22:26 <gour> then we have to show: instance (A a, B b) => C (a,b) holds, true?
01:22:52 <gour> anyone can help proving the above?
01:23:24 <chucky> yeah that's what we want to prove
01:23:32 <gour> chucky: do you have  idea for the next one, ie. 14.49?
01:25:27 <gour> chucky: it looks a bit trickier (to me) to prove that one
01:27:52 <chucky> I'm not sure I understand the question. He talks about String, but the example is about Name? Is that a typo or am I missing something?
01:28:27 <dons> type Name = String, perhaps?
01:28:47 <gour> chucky: well, instance of Named class is given as data = Pair a String
01:29:00 <lispy> dons: breakPS seems to be horribly inefficent in darcs
01:29:16 <gour> err. data Name a = Pair a String
01:29:17 <lispy> dons: i think darcs is overusing it
01:29:48 <gour> chucky: see p272 (top)
01:30:00 <chucky> aah there it is
01:30:50 <dons> lispy, be aware that darcs's FPS has some differences to mine.
01:31:22 <dons> not all tweaks in FPS made it back into darcs.
01:31:23 <lispy> dons: has yours been further optimized?
01:31:28 <lispy> okay
01:31:40 <dons> yes. and many many more functions. 
01:31:52 <lispy> @where fps
01:31:53 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
01:32:00 <dons> yeah, you could check against mine if you're running into issues.
01:32:03 <chucky> gour: these exercises seem quite challenging to me. And I have to go take a shower now, and perhaps eat something. Sorry I couldn't be of any help
01:32:36 <gour> chucky: ok, thank you for your attempt. enjoy your meal ;)
01:35:13 <lispy> dons: well, breakPS is using like 80% of the memory in this darcs test run, but it's also getting called 37million times
01:35:27 <gour> any theorem prover around?
01:36:07 <gour> lispy: so there is room for improvement reg. darcs' performance?
01:36:42 <lispy> gour: not sure if i'm parsing that correctly, but yes there is major room for improvement in darcs performance
01:37:35 <gour> lispy: that's great to hear considering i really like darcs and performance is definitely no. #1 reason of not being deployed more widely
01:38:15 <lispy> gour: right now i'm looking at memory consumption required to record a 37meg file
01:38:50 <lispy> profiling claims that during the run, darcs allocated over 3gigs of memory
01:39:11 <gour> i hope someone will be able to give a hand to darcs' devs
01:39:12 <dons> well, not all at once, I hope ;)
01:39:33 <lispy> dons: i think the most at once was about 1/10 of that
01:39:44 <lispy> gour: well, that's why i'm looking at it :)
01:40:09 <lispy> darcs could also use some help from the ghc devs
01:40:14 <dons> @karma+ lispy
01:40:15 <lambdabot> lispy's karma raised to 4.
01:40:27 <lispy> i guess the GC in ghc is broken in some cases
01:40:27 <gour> lispy. great. thank you from my humble side
01:40:45 <lispy> heh, i didn't say i'd be able to fix it, just that i'm trying :)
01:40:59 <gour> that's also something :-)
01:41:24 * dons is using Text.Printf a lot more than i thought I ever would.
01:41:29 <dons> hmm. should put it in @eval.
01:42:05 <gour> dons: you can take some of my karma and gives it to lispy :-)
01:42:17 <gour> s/gives/give
01:42:30 <dons> hehe
01:42:45 <gour> i'm charitably disposed today ;)
01:43:27 <dons> that's because of all the karma you get from not killing animals ;)
01:43:53 <gour> lol
01:44:29 <gour> dons: what's missing (if something) in your hs-plugins, i.e. is there space for 2.0 ?
01:45:06 <gour> dons: and can one have app with some of the plugins close-sourced (license issue) ?
01:45:13 <dons> yeah. ghci-basssed eval. more typing games.
01:45:59 <chucky> gour: I might have solved 14.48 in the shower. Let me write it up and see if it makes sense. :)
01:46:26 <gour> chucky: yes, this is one of my favorite places/times for solving problems...
01:46:28 <dons> it's LGPL. so yes, I think you can have source object code linked dynamically.
01:47:48 <gour> dons: fine. someone may have a use for it, although i'm fine with open-source. btw, thank you for hs-plugins technology. i believe it is revolutionary for spreading haskell, it's just i need to solve some exercises first :-)
01:49:05 <dons> cool :)
01:55:18 <lispy> i really, really wish i had an interactive debugger for haskell.  I think even with the "unpredictable" order of evaluation it would still been extremely handy at times
01:57:34 <gour> dons: btw, do you use and/or can find dahl (a kind of lentil9 in au?
01:59:08 <jip> lispy: what kind of code are you interested in debugging? purely functional? or with lots of IO?
02:00:53 <dons> yeh, I live on red lentils and mung beans mostly. but also green lentils (and blue sometimes), yellow split peas and so on. i think you can get most of anything here.
02:03:10 <gour> dons: ohh, great. theye are very important source of proteins for vegs, i also like urad dahl, while mung dahl is recommended by ayurveda to be consumed even by cancer-patients 'cause it has almost 100% absorption (no retention stuff)
02:03:53 <lispy> jip: the code i'm looking at now is mostly IO, but it would be nice to use it on any haskell code
02:04:16 <jip> well, debugging IO in any language is always a pain
02:05:27 <dons> i think as long as you know nutrition it's not too hard to look after yourself on a vege or vegan diet. i've found it not too hard to gain muscle for sports, for example
02:05:29 <lispy> i'd just like to be able to step through the evaluation and see how much of the objects have been assembled
02:06:30 <lispy> dons: nutrition is improtant.  In the last 6 months I changed my diet to just watch my fat intake and replace it with carbs.  I lost about 25 lbs in the first 3 months and then stabilized.
02:07:00 <lispy> actually, i probably didn't lose it quite that quick
02:07:13 <lispy> i didn't get a scale for quite some time so i'm not sure about the rate
02:08:56 <dons> interesting. i increased my protein, and gained about 20 lbs :) but i'm also working out more.
02:11:34 <gour> reducing salt helps with the weight...
02:13:20 * jip eats meat and bread
02:13:24 <tre> i've begun eating healthier as well
02:14:12 <tre> last year I lost about 30 lbs, gained about 10 back, who knows what will happen now. for me the big thing was just eating balanced meals ... 'french fries' are no longer my #1 vegetable ;)
02:15:09 <Korollary> it'll pass
02:15:19 <gour> tre: that's good, considering the quality in which they are 'fried'
02:16:30 <tre> Although, its truly a sad state of affairs when I get hassled by my coworkers for eating a sandwich + apple + carrots for lunch. I guess if it doesn't come in a plastic wrapper it isn't good enough for some people.
02:18:07 <gour> tre: well, for those accustomed to eat plastic food, no wonder..
02:18:15 <Saulzar> There are people at my Uni who won't drink water.
02:18:20 <Saulzar> It tastes bad.
02:18:38 <tre> It tastes like Haskell ...
02:19:30 <gour> Saulzar: water is the original taste
02:19:39 <Saulzar> You should hastle your coworkers instead, tre - that's sad
02:19:44 <gour> (i'm not sure whether it's the same with haskell :-)
02:19:54 <Saulzar> Hehe.
02:20:37 <tre> Saulzar, nahh, it's not worth me spending my time, they are all grownups after all ;)
02:20:45 <Saulzar> We go outside and play cricket often, I'll come inside and drink 3 cups of water, they will wait until they go to the dairy and buy chocolate milk. Bizzare.
02:20:48 <lispy> i think the basic problem here is that darcs is rereading the patch after it has already constructed it.  I think looking for lines that start with + 37million times is just a manefestation of that greater problem.
02:20:52 <gour> one thing for sure: God has lazy intelligence :-)
02:21:23 <tre> Saulzar, where do you live?
02:21:56 <jip> i think the basic problem is that there are people who play the game of cricket
02:21:58 <Saulzar> New Zealand
02:22:40 <Saulzar> jip, One of the enemy... :)
02:23:06 <tre> Are people nuts about rugby in New Zealand?
02:23:11 <Saulzar> Yes
02:23:31 <jip> Saulzar: what about "football"?
02:23:41 <Saulzar> Soccor?
02:23:43 <jip> yeah
02:24:00 <Saulzar> What about it?
02:24:13 <jip> do you personally go crazy about it?
02:24:42 <Saulzar> It's not big here, I like soccor but not crazy about it
02:25:25 <Saulzar> Where abouts are you? In a football crazy place?
02:25:34 <jip> yeah
02:26:06 <Saulzar> cricket > soccor > * > rugby :)
02:26:12 <jip> it and basketball are pretty much the only games that are more then minimally popular
02:26:15 <Saulzar> Ok soccor doesn't really compare with *
02:27:12 <dons> Saulzar, you should add yourself to the map.
02:27:15 <dons> @map
02:27:16 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
02:27:26 * dons waves from across the tasman
02:29:58 <Saulzar> Quite a few in Aus? Lambdabot too I see.. :)
02:30:46 <dons> yeah, mostly at UNSW.
02:31:19 * jip always thought that lambdabot was from the depths of hell
02:34:07 <dons> @version
02:34:08 <lambdabot> lambdabot 3p266, GHC 6.5.20050806 (Linux i686)
02:34:08 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
02:34:35 <dons> ^^ nope. sydney is quite nice, actually ;)
02:36:27 <lispy> what does 3p266 mean?
02:36:42 <lispy> third version, patch 266?
02:37:04 <dons> yep.
02:38:18 <dons> @dynamic-reload version
02:38:20 <lambdabot> module reloaded
02:38:27 <dons> @version
02:38:28 <lambdabot> lambdabot 3p283, GHC 6.5.20050806 (Linux i686)
02:38:28 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
02:39:07 <lispy> nice
02:39:19 <lispy> @keal
02:39:21 <lambdabot> Keal angry @ dons
02:39:44 <lispy> i hope he's learning his lesson
02:40:46 <cpatrick> none on the west coast? shall have to fix that then!
02:41:35 <dons> ah ha! yes :)
02:42:05 <astrolabe> hee hee
02:42:11 <Mitar> this is not possible: type Foo = Int | Char
02:42:23 <Mitar> ?
02:42:31 <jip> data Foo = Int | Char
02:42:34 <dons> data Foo = I Int | C Char
02:42:48 <jip> i meant that :P
02:42:52 <Mitar> with data i have to specify contructors?
02:42:57 <astrolabe> dataFoo = MyInt Int | MyChar Char
02:43:02 <Mitar> is there a way without them?
02:43:43 <jip> Mitar: i think some people use the style data Foo = FooInt Int | FooChar Char
02:43:44 <astrolabe> That wouldn't be typesafe would it?
02:43:52 <dons> it's a sum. you need to tag it so case analysis works
02:44:11 <dons> jip, I've never seen that style before :}
02:44:26 <jip> ok i need sleep
02:44:39 <jip> dons: btw any updates on that bug? :)
02:44:44 <Mitar> thanks
02:44:49 <dons> you could use Either, Mitar.
02:44:55 <dons> > Left 1
02:44:56 <lambdabot> Add a type signature
02:45:08 <dons> > Right'x'
02:45:09 <lambdabot>  Not in scope: data constructor `Right'x''
02:45:18 <dons> sigh.
02:45:28 <dons> > Right 'x'
02:45:29 <lambdabot> Add a type signature
02:46:51 <jip> > Right ('x' :: Char)
02:46:53 <lambdabot> Add a type signature
02:46:57 <astrolabe> @type either
02:46:58 <lambdabot> forall c b a. (a -> c) -> (b -> c) -> Either a b -> c
02:47:14 <jip> > (Right 'x') :: (Either Int Char)
02:47:16 <lambdabot> Right 'x'
02:47:29 <jip> > (Left 2) :: (Either Int Char)
02:47:30 <lambdabot> Left 2
02:48:17 <astrolabe> > (Left 2) ::(Either Int a)
02:48:18 <lambdabot> Add a type signature
02:48:31 <astrolabe> Why doesn't it like that?
02:48:46 <astrolabe> er * she like that
02:49:50 <dons> it needs to be able to `show' the result.
02:50:51 <astrolabe> but wouldn't showing only depend on the left type?
02:53:24 <dons> it'll still need to be able to find a Show a for the right side, otherwise instance (Show a, Show b) => Show (Either a b) where wouldn't be true, would it?
02:53:44 <dons> (without some defaulting?)
02:54:02 <dons> I think this is why it works in ghci, but not in the compiled/spliced @eval.
02:55:07 <astrolabe> Ah thanks. Complicated.
02:55:23 <lispy> module Complicated where ...
02:57:08 <lispy> i just realized it would be fun to take that list of factorial implementantions and benchmark them against each other
02:57:28 <jip> you have a strange idea of fun :P
02:57:31 <lispy> find out which one is the speedest, slowest, most memory, and least memory
02:57:53 <lispy> jip: let's just say, i'm not going to argue ;)
03:05:52 <neologism> lispy: I think it would be roughly from the simplest to the most complicated
03:18:20 <skew>  /quit
03:19:06 <lispy> neologism: i'd like to see them all be really efficient, that would mean ghc can optimize a wide variety of code
03:20:14 <lispy> furthermore, it would be interesting to compare jhc vs. ghc vs. hugs vs. etc on that set of programs
03:28:54 <Saulzar> lispy, Somehow I don't think the list-encoded or unary recursive numbers will hold up
03:30:09 <lispy> Saulzar: heh, yeah, those probably don't stand a chance.
03:46:18 <jip> man i have this idea but i can't quite figure out the details of coding it in haskell
04:07:19 <Mitar> is there a map on pair?
04:07:49 <Mitar> (a,b) -> ((a,b) -> (c,d)) -> (c,d)?
04:08:26 <cpatrick> what you wrote there is just ($)
04:08:32 <Heffalump> @type flip ($)
04:08:33 <cpatrick> @type ($)
04:08:33 <lambdabot> forall b b1. b1 -> (b1 -> b) -> b
04:08:35 <lambdabot> forall b a. (a -> b) -> a -> b
04:08:43 <xerox> @type (map :: ((a,b) -> (c,d)) -> [(a,b)] -> [(c,d)]
04:08:45 <lambdabot> parse error (possibly incorrect indentation)
04:08:52 <xerox> @type (map :: ((a,b) -> (c,d)) -> [(a,b)] -> [(c,d)])
04:08:53 <lambdabot> forall a b c d. ((a, b) -> (c, d)) -> [(a, b)] -> [(c, d)]
04:09:23 <xerox> Mitar: you want this one, I think:
04:09:30 <lispy> @type ($) (1,'a')
04:09:31 <xerox> @type (Control.Arrow.***)
04:09:32 <lambdabot>   Couldn't match `a -> b' against `(a1, b1)'
04:09:32 <lambdabot>   Expected type: a -> b
04:09:33 <lambdabot> forall (a :: * -> * -> *) c' c b' b.
04:09:33 <lambdabot> (Control.Arrow.Arrow a) =>
04:09:33 <lambdabot> a b c -> a b' c' -> a (b, b') (c, c')
04:09:51 <lispy> @type ($) fst
04:09:51 <xerox> > (+1) &&& (*2) $ (0,1)
04:09:52 <lambdabot> forall a b. (a, b) -> a
04:09:53 <lambdabot>  add an instance declaration for (Num (a, b))
04:10:08 <xerox> > (+1) *** (*2) $ (0,1)
04:10:09 <lambdabot> (1,2)
04:11:11 <xerox> (f *** g) (x,y) = (f x,g y)
04:11:39 <cpatrick> xerox: that is cool, even if I don't understand it :-)
04:11:47 <xerox> > let mitar f = f *** f in mitar (+1) (1,2)
04:11:48 <lambdabot> (2,3)
04:12:14 <xerox> cpatrick: it's not difficult: (f *** g) (x,y) = (f x,g y)
04:12:33 <xerox> cpatrick: you also have (f &&& g) x = (f x,g x)
04:12:53 <xerox> cpatrick: and then, first f (x,y) = (f x,y); and second f (x,y) = (x,f y)
04:12:57 <Mitar> i see *** for the first time
04:13:00 <Mitar> what is this?
04:13:06 <xerox> It's an Arrow combinator.
04:13:15 <xerox> The definition I wroter are the Arrow instance for functions.
04:13:20 <xerox> definitions, even.
04:14:08 <xerox> Lunchtime :-)
04:14:22 <cpatrick> dunno. the arrow stuff just kind of throws me
04:14:47 <xerox> cpatrick: play with &&&, ***, first and second.
04:15:04 <xerox> > let dup x = id &&& id in dup 2
04:15:06 <lambdabot>  add an instance declaration for (Show (b -> (b, b)))
04:15:12 <xerox> > let dup = id &&& id in dup 2
04:15:14 <lambdabot> (2,2)
04:15:19 <xerox> (oops... later, boys.)
04:49:43 <jyp> @yaow
04:49:44 <lambdabot> ... Now, it's time to "HAVE A NAGEELA"!!
04:54:35 <Mitar> @yaow
04:54:36 <lambdabot> I'm ZIPPY the PINHEAD and I'm totally committed to the festive mode.
05:01:55 <xerox> @yarr!
05:01:56 <lambdabot> Ahoy mateys
05:23:55 <Saulzar> gc beep mode for ghc runtime sound like a machine gun for my code
05:25:49 <ulfdoz> strange machine guns, you know. :)
05:27:09 <jip> that sounds cool, where can i find more information about this?
05:29:13 <Saulzar> http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html
05:31:53 <jip> -B?
05:32:15 <Saulzar> Yeah
05:32:59 <jip> hm... i get a constant rythm of about 5 beats per second
05:36:08 <Saulzar> Me too, though it seems quite rapid
05:37:56 <ksandstr> a neat hack would be to wire up a LED instead of a beeper to your motherboard, then observe the (singular) blinkenlight
05:38:22 <gour> hey guys, you could record those music and put somewhere online for the pleasure of haskell-audience
05:39:04 <jip> led arrays on your box should be a standard output device nowadays
06:01:18 <Igloo> Where's the new wiki again?
06:01:41 <Igloo> Oh, n/m, got it
06:02:24 <xerox> new wiki?
06:02:38 <Igloo> http://haskell.org/haskellwiki/Haskell
06:03:08 <Igloo> (I think it's still unofficial)
06:04:56 <xerox> Uh-oh.
06:05:37 <araujo> Good morning.
06:43:10 <reddi> hi, short question: i have to write a function with the following signatur: inOut::(String->String)->IO Integer
06:43:15 <reddi> what does IO Integer mean
06:43:43 <reddi> why is it not inOut::(String->String)->IO->Integer
06:43:58 <neologism> IO is monad
06:44:07 <jip> the "IO Integer" means that your inOut function is supposed to perform some IO
06:44:27 <reddi> but i have to read normal lines, not integer
06:44:32 <reddi> i have to output integer
06:44:36 <neologism> its is output
06:45:01 <jip> inOut takes a function from String to String, and using that function it does some IO and returns an Integer
06:47:50 <reddi> jip: what is the difference between: inOut::(String->String)->IO ()
06:48:06 <reddi> and the signature i pasted before?
06:48:20 <Mitar> how can i "multiply" a list (make a list from few concatenations of original list)
06:48:56 <jip> reddi: the one you pasted before at the end gives an Integer result, and this one doesn't give any result
06:50:34 <neologism> > let f x n = foldr (++) [] $ replicate n x in f [1,2,3] 4
06:50:35 <lambdabot> [1,2,3,1,2,3,1,2,3,1,2,3]
06:50:39 <reddi> so i have to use something like putint as output
06:51:22 <neologism> Mitar: like this?
06:52:29 <reddi> i simply want a function which works with my signature! http://pastebin.com/505350
06:52:33 <reddi> how can i perform this?
06:54:07 <SamB> apparantly people have actually heard of Conjure now
06:54:20 <jip> reddi: what is the function supposed to do?
06:56:24 <reddi> jip: the function shall read lines (without "\n"), use the function which was passed, put the results in stdout! if someone writes "end" it will be cancele! the result of inOut is the number of outputed lines
06:56:56 <jip> is this a homework assignment? :)
06:57:13 <reddi> jip: yep
06:57:45 <reddi> jip: how do i call that function?
06:57:55 <reddi> inOut fkt
06:58:05 <reddi> and then i can write on the command line?
06:58:26 <jip> main = inOut fkt >> return ()
06:58:59 <reddi> hm i have to write a function main too (but as an last example)
06:59:12 <reddi> so i cannot test inout alone?
06:59:20 <SamB> main :: IO ()
06:59:31 <SamB> reddi: you can load up your file in GHCi without a main
06:59:33 <jip> reddi: you can from within ghci
07:04:47 <jip> reddi: here...
07:06:13 <jip> reddi: http://pastebin.com/505359
07:09:03 <reddi> jip: thx, i will look @ it
07:16:56 <reddi> jip: ok, u helped me! now i understand a bit more, what the String->String meant and the working of main and io
07:17:43 <reddi> do i see it right that i have to use main for every inout operation?
07:17:51 <reddi> if i dont use ghci
07:19:52 <jip> pretty much
07:20:03 <jip> eventually you will need main to call all your functions that do IO
07:53:02 <jyp> > let q@(a,b) = ("> let q@(a,b) = ","a++show q++b") in a++show q++b
07:53:03 <lambdabot> "> let q@(a,b) = (\"> let q@(a,b) = \",\"a++show q++b\")a++show q++b"
07:53:53 <jyp> Too bad he quotes the result...
07:57:25 <kpreid_> > (\a -> a ++ show a) "(\\a -> a ++ show a) "
07:57:26 <lambdabot> "(\\a -> a ++ show a) \"(\\\\a -> a ++ show a) \""
07:58:02 <jyp> nice one :)
07:58:26 <jyp> though obligatory quotation is still annoying
07:58:48 <kpreid_> blame lambdabot, not the quine :)
07:59:26 <jyp> well... we'll have to conclude lambdabot is not turing complete
07:59:50 <kpreid_> they're still strings such that eval on them is the identity function
07:59:58 <ulfdoz> What's wrong with "instace foo [Char] where <bla>"? ghc complains Illegal instance declaration for `Poliophie [Char]' (The instance type must be of form (T a b c) ...)?
08:00:01 <kpreid_> my quine page: http://homepage.mac.com/kpreid/quines.html
08:01:02 <jyp> ulfdoz, foo must be a type constructor
08:01:13 <jyp> instance Foo ...
08:01:53 <gour> what is the status of interfacing python & haskell. iirc there are some binding s for using python libs, but cannot find them
08:03:54 <ulfdoz> jyp: There is still some other error.
08:04:15 <jyp> indeed, I did not read enough of your question, sorry
08:05:56 <jyp> you can either use a newtype declaration for [Char] or use overlapping/undecidable instances
08:08:00 <Neonsquare> hi
08:08:25 <Neonsquare> is anyone here using wxhaskell?
08:09:01 * gour found out about MissingPy, but wonders if there is something (special) for calling Haskell from Python?
08:10:44 <gour> is CosmicRay author of MissingPy?
08:34:33 <reddi> hi, short question:
08:35:05 <reddi> how can i test whether the list is empty if i use the following statement
08:35:05 <reddi> interpret_rek (x:xs,list)
08:35:05 <reddi>    | x==[] = list
08:35:54 <TFK> null x, I believe
08:36:51 <xerox> interpret_rek xs ys | null xs = ys
08:36:57 <Cale> or just
08:37:05 <xerox>                    | otherwise = ...
08:37:05 <Cale> interpret_rek [] ys = ys
08:37:21 <xerox> Right!
08:37:42 <Cale> morning :)
08:38:09 <xerox> Hey Cale :-)
08:38:17 <araujo> morning Cale !
08:38:19 <reddi> damn, that was so clear ;-(
08:38:23 <gour> evening :-)
08:40:04 <gour> who is the author of MissingPy?
08:40:31 <ibid> CosmicRay, iirc
08:40:31 <Cale> CosmicRay
08:40:46 <Cale> a.k.a. John Goerzen
08:40:50 <gour> ta, i thought so, but wasn't sure
08:40:52 <Neonsquare> wxhaskell on mac os x seems to have problems using image loaders
08:41:03 <Neonsquare> er image handlers ;-)
08:41:07 <gour> it looks he is not around...
08:41:40 <ibid> @seen CosmicRay 
08:41:41 <lambdabot> CosmicRay is in #haskell-blah and #haskell. Last spoke 21 hours, 20
08:41:41 <lambdabot> minutes and 21 seconds ago.
08:41:56 <reddi> foldr (*) 1 [1..100]  is the normal ! - function, correct?
08:42:15 <gour> in the morning i had some exchange regarding some prove from thompson's book, but i'm not sure the proof is strong enough
08:42:18 <gour> anyone can help?
08:42:32 <Cale> reddi: sure, or product [1..n]
08:47:20 <tromp_> ! =  product . enumFromTo 1
08:47:57 <ihope> Ahoy
08:48:18 <Cale> however, you can't write it as ! in Haskell
08:49:13 <ihope> Talking about the factorial function?
08:49:23 <Cale> yeah
08:50:17 <ihope> Omgwtfbbq. Why is Firefox using up all my CPU time?
08:50:31 <tromp_> how cld you make lambdabot give point-free definitions?
08:50:41 <ihope> @pl
08:50:42 <lambdabot> (line 1, column 1):
08:50:42 <lambdabot> unexpected end of input
08:50:42 <lambdabot> expecting white space, natural, identifier, lambda abstraction or
08:50:42 <lambdabot> expression
08:50:50 <ihope> ...Heh
08:50:55 <Cale> @pl fac n = product [1..n]
08:50:56 <lambdabot> fac = product . enumFromTo 1
08:51:14 <ihope> Hmm. I thought @pl only worked on expressions...
08:51:14 <tromp_> cool:)
08:51:53 <tromp_> @pl k x y = x
08:51:54 <lambdabot> k = const
08:52:01 <tromp_> @pl s x y z = x z (y z)
08:52:02 <lambdabot> s = ap
08:52:12 <ihope> @type ap
08:52:13 <lambdabot> Not in scope: `ap'
08:52:18 <ihope> @index ap
08:52:19 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.
08:52:19 <lambdabot> State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont,
08:52:19 <lambdabot> Control.Monad.Error, Control.Monad.List, Data.Graph.Inductive.Query.
08:52:19 <lambdabot> ArtPoint, Data.Graph.Inductive.Query, Data.Graph.Inductive
08:52:21 <Cale> @type Control.Monad.ap
08:52:23 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
08:52:32 <ihope> @type Control.Monad.Reader.ap
08:52:33 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
08:52:37 <ihope> Hmm.
08:52:47 <Cale> It likes to use  m = (->) a
08:53:33 <Cale> which makes the type (e -> a -> b) -> (e -> a) -> (e -> b)
08:53:39 <ihope> Yep.
08:54:24 <xerox> > (+) `ap` (+1) `ap` (*2) $ 1
08:54:26 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> b
08:54:26 <lambdabot>   Expected type: (a -> b) -> a
08:54:26 <lambdabot>   Inferred type: (a -> b) -> a -> b
08:54:45 <Cale> > return (+) `ap` (+1) `ap` (*2) $ 1
08:54:46 <lambdabot> 4
08:55:05 <xerox> (+) is not enough?
08:55:07 <Cale> > return (+) `ap` [1,2,3] `ap` [4,5,6]
08:55:08 <lambdabot> [5,6,7,6,7,8,7,8,9]
08:55:15 <Cale> > return (,) `ap` [1,2,3] `ap` [4,5,6]
08:55:17 <lambdabot> [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
08:55:39 <Mitar> is there a way to make this nicer: (concat . replicate ates $ "<td></td>") ++ (concat . replicate alength $ "<td>X</td>") ++ (concat . replicate (tall - alength - ates) $ "<td></td>")
08:56:05 <xerox> > foldl1 ap [return (,,),[1,2],[3,4],[5,6]]
08:56:06 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> b
08:56:06 <lambdabot>   Expected type: m (a -> b) -> m (a -> b) -> m (a -> b)
08:56:06 <lambdabot>   Inferred type: m (a -> b) -> m a -> m b
08:56:11 <xerox> It's not my day.
08:56:14 <ihope> Maybe do-notation?
08:56:39 <Cale> Mitar: separate those with 'where' or 'let'?
08:56:50 <Mitar> hmm
08:57:04 <Mitar> the idea is that it is too much "command" for me
08:58:35 <xerox> @type \xs -> concat . replicate xs
08:58:37 <lambdabot> forall a. Int -> [a] -> [a]
08:58:57 <Mitar> because there is in fact something like this: i would like to produce some number of cells, some of them fulfil some predicate (that the index of the cell is less >= ates and less then ates + alength) and should be different cells then other
08:58:58 <Cale> Have you looked at Text.Html? It's not ideal, but it gives some structure
08:59:17 <Cale> oh
08:59:45 <Mitar> so i would like that to make it nicer with more "functional" code
08:59:57 <Mitar> because this now is not in Haskell spirit
09:00:44 <Cale> map (\i -> if i >= ates && i < ates + alength then "<td>X</td>" else "<td></td>") [1..tall]
09:00:52 <Cale> concatMap (\i -> if i >= ates && i < ates + alength then "<td>X</td>" else "<td></td>") [1..tall]
09:01:03 <Cale> which we can then transform as
09:01:17 <Mitar> do i need  [1..tall]?
09:01:34 <Cale> [1..tall] >>= \i -> if i >= ates && i < ates + alength then "<td>X</td>" else "<td></td>"
09:02:06 <Cale> do i <- [1..tall]; if i >= ates && i < ates + alength then "<td>X</td>" else "<td></td>"
09:02:12 <Mitar> (i mean, why should we produce a list only to iterate through it)
09:02:31 <Cale> who cares? That list won't stick around
09:03:10 <Cale> It's just a loop counter :)
09:04:45 <Heffalump> it might get deforested, actually
09:06:52 <Cale> > map (inRange (12,17)) [1..20]
09:06:53 <lambdabot> [False,False,False,False,False,False,False,False,False,False,False,True,
09:06:53 <lambdabot> True,True,True,True,True,False,False,False]
09:07:24 <Cale> do i <- [1..tall]; if inRange (ates, ates + alength) i then "<td>X</td>" else "<td></td>"
09:07:47 <Cale> watch the boundaries though, might need tweaking
09:08:55 <Cale> ates + alength - 1
09:12:09 <Mitar> oho
09:12:13 <Mitar> this is what i like
09:12:32 <Mitar> but i hope inRange is not O(n)
09:12:42 <Mitar> egh
09:12:43 <Mitar> :-)
09:12:45 <Mitar> forget
09:12:48 <Mitar> :-))
09:25:54 <ihope> Oops!
09:26:18 <alar> @oops
09:26:19 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
09:26:25 <ihope> ?
09:26:35 <xerox> It is corrected as 'doc' o_O
09:26:46 <alar> @ihope
09:26:46 <ihope> @lp 32
09:26:47 <lambdabot> Unknown command, try @listcommands.
09:26:47 <lambdabot> Maybe you meant: . help id lam map pl wn
09:32:25 <Mitar> where is inRange defined?
09:33:37 <neologism> can I force ghc to compile files which are not Main.hs ?
09:33:56 <xerox> @index inRange
09:33:57 <lambdabot> Data.Ix, Data.Array, Data.Array.IArray, Data.Array.Unboxed, Data.Array.
09:33:57 <lambdabot> MArray, Data.Array.IO, Data.Array.ST, Data.Array.Storable, Data.Array.
09:33:57 <lambdabot> Diff
09:34:05 <xerox> Mitar: in one of those modules :-)
09:34:25 <Saulzar> Seems there are a lot of useful range/bounds functions in array which are useful outside arrays too
09:34:43 <Mitar> yes ...
09:37:52 <Heffalump> neologism: have you seen -main-is ?
09:38:06 <Heffalump> I suspect -main-is Foo.main is what you want
09:39:18 <neologism> hm.. I should improve my doc-reading skill
09:39:22 <neologism> thnx
09:41:18 <Nanar> sutip question
09:41:47 <Nanar> bad chan
09:43:03 <Saulzar> Hmm, you can also just call your Foo.hs module Main apparently
09:43:48 <Nanar> I have a question: does anoyone allready think to create a CPAN like for haskell ?
09:44:03 <Lemmih> Yeah.
09:44:10 <Nanar> ah :)
09:44:32 <Mitar> not a bad idea
09:44:42 <Mitar> chan?
09:44:42 <Nanar> any ptr about discuss / website / what ever ?
09:45:11 <Lunar^> Nanar: google cabal and hackage
09:45:14 <Nanar> I am thinking to to create rpm binding for haskell for my need
09:45:27 <Lunar^> http://www.haskell.org/cabal/hackage/
09:45:47 <Nanar> for perl I have allready put it on CPAN
09:46:03 <Lemmih> Nanar: http://hackage.haskell.org/ModHackage/Hackage.hs
09:46:04 <Nanar> I talk with Rafael (perl maintainers) about it a bit
09:46:33 <Nanar> and he said to first talk about this here of course :)
09:49:19 <Nanar> seems to be young be exists
09:50:24 <palomer> haskell needs a better module system for a CPAN clone to be really useful
09:50:27 <alar> #seen psnl
09:50:37 <alar> @seen psnl
09:50:38 <lambdabot> psnl is in #haskell. Last spoke 11 hours and 46 seconds ago.
09:53:01 <Nanar> palomer: CPAN is old and improved for years
10:04:08 <tony2> does anyone know how to enable profiling for a package that uses distribution.simple? 
10:15:12 <Welshy> Hey guys, I've got a bit of trouble with Haskell, and I was wondering if someone could help me out.
10:15:56 <tony2> what's the trouble Welshy?
10:17:02 <Welshy> I've got to modify a tree, so that it takes other values (It started with only taking an ID and a string, but I need to change it to take some other things.) 
10:17:33 <Welshy> I've been working on it for a few days now, and the trees have stopped building.
10:17:49 <Welshy> I was wondering if someone could have a quick look and see if they knew why this was.
10:18:16 <Cale> This is a school assignment, or something else?
10:18:33 <Welshy> Part of one.
10:18:36 <Cale> okay
10:19:02 <Welshy> I'm not going to lie :) I honestly don't want people to give me the answers; I just need a little help here and there.
10:19:02 <Cale> What exactly do you mean by 'stopped building'?
10:19:07 <Cale> yeah
10:19:14 <Cale> It's just good to have some context :)
10:19:18 * Welshy nods.
10:19:51 <Welshy> Well to be honest, I don't really understand the code that I've been told to modify, and as such; I think that I've done something that's broken it.
10:20:26 <Welshy> It builds a tree based on id numbers in a mailing list, with children referencing parents by their id.
10:20:50 <Welshy> I'm not sure why, but it doesn't seem to be building a list of children any more. It stops at the root.
10:20:58 <Cale> okay
10:21:33 <Cale> how much work have you done to the code? Perhaps compare it with the original code? It sounds like some recursive call has been removed.
10:21:47 <Cale> We could have a look if you paste it somewhere
10:21:49 <Cale> lisppaste2: url
10:21:50 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
10:22:38 <Welshy> http://www.dur.ac.uk/richard.welsh/haskell
10:22:46 <Welshy> is where my editted code is.
10:23:14 <Welshy> I suspect that the parent_info function at the bottom is what has stopped working; although I'm not too sure.
10:23:51 <Welshy> (If I could find out if I'm passing information about properly, it would be a good start) 
10:23:55 <carp__> did Paul Callaghan set it?
10:23:59 <carp__> just wondering
10:24:03 <Welshy> He did, yeah.
10:24:11 <Welshy> Do you know Paul?
10:24:29 <carp__> yeah, he's a nice guy
10:25:16 <Welshy> I do like Paul. He's one of the better lecturers that we've got.
10:25:23 <carp__> cool
10:28:39 <Welshy> Cale: Any idea where I've gone wrong? The code compiles; but I think that's because I went through each error and picked at it until it went away.
10:29:44 <Cale> Welshy: well, often that's enough to get things to work :)
10:30:23 <Welshy> Cale: I was really pleased, to be honest! But then I found out that the GTrees weren't working *chuckles* 
10:31:21 <Cale> this is quite a lot of code to sift through just on its own -- where do you think things are going wrong?
10:32:18 <Cale> One good thing to do is to try some function, and if it gives you the wrong result, recursively break it down and try the parts it's composed of until you find something that isn't doing what it's supposed to do.
10:33:09 <Welshy> From mkTrees onwards.
10:33:51 <Welshy> The top half of the code all works, then mkTrees half-works... It builds an empty tree, giving it a root; but then doesn't build the rest of the tree.e
10:34:50 <Cale> hmm
10:35:08 <Welshy> I have a feeling that it's because I've tried to change Ref i (which is what it started as) to a Ref with 3 variables.
10:35:09 <Cale> What is mkTrees supposed to return, exactly?
10:36:43 <Welshy> I think it's meant to return a Gtree.
10:37:52 <Cale> it says that it returns a list of Gtree Ancestor
10:38:04 <Cale> but that doesn't exactly say what it does :)
10:38:22 <Welshy> I know :/ 
10:38:25 <Cale> also, what's a Gtree?
10:38:50 <Welshy> A Gtree is just Paul's own implementation of a tree.
10:39:02 <Cale> what's the data declaration?
10:39:07 <Welshy> The problem is lack of understanding on my behalf.
10:39:12 <Welshy> The data declaration? 
10:39:35 <Cale> import Gtree -- pop open the Gtree module and look for something that says  data Gtree = ...
10:39:41 <Cale> er
10:39:46 <Cale> data Gtree a = ...
10:41:11 <Welshy> ok.
10:41:50 <Welshy> = Gtree { root_item :: a, children :: [Gtree a] }
10:42:04 <Cale> aha, okay
10:42:22 <Cale> so it's a tree with every vertex labelled, with arbitrary degree
10:42:31 <Welshy> Yep.
10:43:16 <Cale> okay, so now we can tell what 'adjust' does..
10:43:36 <Cale> How about dependenciesToTree?
10:44:08 <Welshy> dependenciesToTree :: Ord a => FiniteMap a [a] -> FiniteMap a (Gtree a) 
10:44:22 <Cale> hmm
10:45:18 <Cale> okay, so your refsToChildList is generating input to that
10:45:40 <Cale> but I don't see an implementation of dependenciesToTree, so presumably it's not your code?
10:46:16 <Cale> I'm also not completely sure what dependenciesToTree does, but I can hazard a guess :)
10:46:16 <Welshy> No. I didn't originally write any of the Gtree stuff; I just tried to update it.
10:46:58 <Cale> Does FiniteMap have a Show instance where you are?
10:47:03 <tony2> I really haven't a clue how to build SerTH for profiling. Anyone know how to do that with cabal?
10:47:04 <Cale> so we can test this in GHCi?
10:47:15 <Lemmih> tony2: --enable-library-profiling.
10:47:36 <Welshy> Is there a way to check to see if there's a show instance? 
10:47:38 <Lemmih> tony2: You need a version of Cabal newer than 1.0, though.
10:48:05 <tony2> Lemmih, do I pass that to Setup.lhs configure?
10:48:11 <Cale> Welshy: just try to print one :)
10:48:22 <Lemmih> tony2: Yes.
10:48:23 <Welshy> okey doke. I'll see what it does.
10:48:39 <tony2> thanks, I'll upgrade then.
10:48:44 <Cale> 'work' is so annoyingly constructed
10:49:23 <Lemmih> tony2: Note that profiling doesn't work with TH.
10:49:35 <Cale> Perhaps it would be possible to break it into smaller chunks so that they could be tested separately.
10:50:14 <Cale> Welshy: you really want to get the input to mkTrees, so as to be able to test it.
10:50:33 <Welshy> I got a Type error when I tried to use show.
10:51:43 <Welshy> I think I can look at the input.
10:53:08 <Welshy> Which part should I try to get?
10:53:35 <Cale> well, if the thing runs, you could get it to print the id_table, info_table, tables and rs, but some of those are finitemaps, and if your Data.FiniteMap (which GHC are you using) doesn't have a Show instance, we can quickly add one
10:54:17 <Welshy> (I'm using hugs 98 )
10:54:25 <Cale> ah, okay
10:54:52 <Cale> instance (Show a, Show b) => Show (FiniteMap a b) where show fm = "listToFM " ++ (fmToList fm)
10:57:12 <Welshy> okey doke. I've added that line.
10:57:49 <Cale> that'll let you print out the relevant finitemaps, so that at least we'll have some test input (hopefully) :)
10:58:07 <Welshy> How can I add a second set of commands for showing things to the mkTrees function? I thought you could only have one series of commands when using pattern matching? 
10:59:22 <Cale> don't bother with adding anything to mkTrees at the moment -- go to the line in 'work' which is just above the call to mkTrees, and add lines like 'print id_table' 
10:59:31 <Welshy> Okey doke.
11:01:52 <Welshy> It doesn't like the instance of show that I've just put in.
11:02:35 <Welshy> Expression: "listToFM " ++ fmToList fm      Term: "listToFM "    Type: String      Does not match: [(a,b)]
11:02:47 <Cale> oh
11:02:52 <Cale> instance (Show a, Show b) => Show (FiniteMap a b) where show fm = "listToFM " ++ (show $ fmToList fm)
11:02:54 <Cale> oops :)
11:05:14 <Welshy> ok, I've got the id_table and info_table printed out.
11:05:23 <Cale> are they huge, or manageable?
11:05:52 <Cale> we just need something which we can use to actually test mkTrees
11:06:29 <Welshy> They seem to be really small...
11:06:35 <Cale> okay, that's good
11:07:08 <Welshy> Which is weird. I'd have thought they'd have been much bigger; there's about 25 posts; but these tables only have 2-3 each
11:07:14 <Cale> also, tables and rs
11:07:39 <Cale> hmm
11:08:03 <Welshy> It wont let me print tables; It says that I require an instance of Show NG_Info
11:08:16 <palomer> grr
11:08:18 <palomer> where's lennart
11:09:04 <Cale> hmm, I wonder where that type is defined
11:09:21 <Welshy> I'll have a look for it
11:09:31 <palomer> Cale: I'm pretty sure type inference for guarded algebraic datatypes is decidable
11:09:31 <psnl> hello
11:09:53 <psnl> Welshy: ping?
11:09:57 <palomer> though I'm not completely sure
11:10:38 <Cale> palomer: It just seems to me that if it was known how to do it, we'd have better type inference for them in GHC :)
11:11:09 <Welshy> psnl: pong!
11:11:11 <Cale> (and the wobbly types thing wouldn't depend quite so much on type declarations)
11:12:02 <psnl> Welshy: still haskell fighting?
11:12:09 <Welshy> I've found NG_Info's declaration. It's long.
11:12:16 <Cale> palomer: http://research.microsoft.com/Users/simonpj/papers/gadt/ seems like it ought to be the state of the art as far as that matter is concerned
11:12:16 <Welshy> psnl: Yeah :( 
11:12:26 <Cale> Welshy: hmm
11:12:52 <Cale> Annoying that they'd give you code which is pretty hard to even test.
11:15:39 <psnl> Welshy: is your problem explainable in one line, or should I walk down to cm001 in a bit?
11:15:58 <Welshy> psnl: If you'd come visit me, I'd be really grateful!
11:16:42 <Cale> psnl: this looks fairly complex :) I'd like to help more, but we can't even properly test this code at the REPL (at least not without heavy refactoring)
11:16:47 <alar> psnl: does epigram support the notion of infinite data structures? e.g., infinite lists
11:16:50 <alar> ?
11:16:59 <psnl> alar: yes
11:17:02 <psnl> I think
11:17:09 <psnl> edwinb is the person to ask
11:17:42 <psnl> Cale: its not really, having done the same assignment
11:18:42 <Cale> psnl: How do you get an NG_Info for testing?
11:19:05 <Cale> I suppose we could just call buildBasicInfo on the hugs prompt
11:19:24 <Cale> hmm, but does hugs even allow that? GHCi might be more convenient
11:19:38 <alar> psnl: but those would be datattypes where induction is not derivable
11:19:50 <alar> @seen edwinb
11:19:52 <lambdabot> edwinb is in #haskell. I don't know when edwinb last spoke.
11:25:56 <psnl> Welshy: on my way
11:26:45 <edwinb> hello
11:27:00 <edwinb> alar: epigram doesn't have it yet, but I believe it will
11:27:05 <Welshy> psnl: You're a lifesaver.
11:27:10 <Welshy> Heya Edwin :) 
11:27:14 <alar> hello
11:27:15 <edwinb> It'll separate coinductive types and inductive types
11:27:17 <edwinb> hi welshy
11:27:25 <edwinb> but I'm not hacking epigram directly any more
11:27:31 <edwinb> when carp is about, he's your man ;)
11:27:41 <alar> =))
11:27:52 <alar> why habe you dropped epigram?
11:27:56 <alar> why have you dropped epigram?
11:28:08 <alar> and what's "coinductive"?
11:28:37 <edwinb> I haven't dropped it as such; just got a different job at a different place
11:28:46 <edwinb> so I'm still interested, but doing other stuff
11:29:36 <edwinb> coinductive types, put simply (since I know little of these things) are kind of an opposite to inductive types in that they allow production of data, rather than consumption
11:30:08 <edwinb> so, a function which returns an element of a coinductive type needs to return a constructer headed value
11:31:06 <alar> then there is no proof that coinductive-valued functions always terminate?
11:31:56 <edwinb> no, but there *is* proof that they produce more useful data
11:32:14 <edwinb> you don't want your OS to terminate, after all, but you do want it to produce a response to every request
11:38:49 <alar> sometimes I want my OSs responce to terminate in bounded amount of time :) To be able to give it the next request
11:39:31 <edwinb> yes, that's one thing that provable termination doesn't necessarily tell you...
11:40:13 <edwinb> "it'll terminate, but I'm not saying whether it's in 2 seconds or 2 years"
11:40:29 <carp__> alar: I don't know much either but http://types2004.lri.fr/SLIDES/altenkirch.pdf has some references
11:40:48 <int-e> edwinb: hmm, what's a few millenia among friends :)
11:40:53 <edwinb> heh
12:08:56 <alar> carp__: even(from 0) diverges. Why shouldn't it?
12:27:37 <alar> ahh, that means infinite datatypes are not the same as finite!
12:33:00 <psnl> welshy fixed his haskell problem
12:34:00 <Welshy> Hi again.
12:34:09 <Welshy> I fixed the problem... :) 
12:34:52 * psnl prods Welshy so that the channel can extract their pound of felsh
12:35:11 <Welshy> Near the bottom of the page, I'd done a little bit of copying and pasting.
12:35:36 <Welshy> and I forgot to rename a variable 'i' to 'p'.
12:36:15 <psnl> at least you spotted it
12:36:16 <Welshy> ... funny how one character can make all the difference, huh? :) 
12:37:38 <Welshy> Thankyou all for your help though; Especially Cale, you were really helpful.
12:37:50 <palomer> yeah, haskellians are a helpful bunch
12:37:54 <Welshy> (And psnl, who graciously came all the way down to the computer lab to help me locate this typo )
12:38:06 <psnl> well, I was going to the pub
12:38:14 <palomer> I regard an element of a monad type as a sequent of steps to perform
12:38:25 <palomer> is this wrong?
12:40:46 <Korollary> what's an element of a monad type?
12:41:47 <SamB> palomer: well, to confuse matters, lists are, well, just lists
12:42:23 <palomer> s/sequent/sequence
12:42:37 <palomer> SamB: but you can regard lists as a sequence of steps!
12:42:56 <palomer> Korollary: I mean (Monad m) => m a
12:43:22 <SamB> palomer: if you feel like it, but really its more an iterator over some values...
12:43:42 <Korollary> palomer: that looks like a type signature. How is it a sequence of steps to perform?
12:44:02 <palomer> I regard a value of (Monad m) => m a as a sequence of steps
12:54:39 <Cale> palomer: well, that view is a little odd in the case of say, the list, or Maybe monad, but it works okay :)
12:56:11 <palomer> we should have syntactic sugar so that STRefs get sml reference syntax
12:57:05 <palomer> we should have a Super Monad type which would encompass all the monad types, and would describe any sequence of events!
12:57:24 <Cale> "all the monad types"?
12:57:32 <palomer> all the monad type constructors
12:57:39 <araujo> Is there any way of doing reflective programming with haskell in the sense that a function could know its own name?
12:57:55 <Cale> There's almost certainly infinitely many monad types.
12:58:05 <palomer> so you could do 'putStrLn "hello" << a <- get <<= ...   '
12:58:18 <palomer> s/<<=/=<<
12:58:21 <Cale> You can't possibly anticipate them all
12:58:38 <palomer> Cale: yeah, we would need to change the type system
12:59:09 <Cale> besides, it would spoil one of the largest benefits of using monads in the first place
12:59:22 <palomer> but, on the upside, we'd keep referential transparency and we'd get mutability
12:59:30 <Cale> Monads can create nice restrictions.
12:59:48 <palomer> referential transparency + mutability = palomer's happy
13:00:02 <araujo> anyone?
13:00:07 <Cale> Often, even a simple state monad is a little too much, so I'll restrict it to something weaker
13:00:08 <palomer> and we could use the restrictions when we'd find it useful
13:00:28 <Cale> araujo: you could tuple the function with a string
13:00:28 <ski> araujo : how would that work with alpha-conversion ?
13:00:28 <Korollary> araujo: that could be (if it is not already) a ghc pragma or something.
13:01:00 <palomer> imoff!
13:01:18 <Cale> practically speaking, if your code needs to know the name of one of your functions, you're probably doing something wrong :)
13:01:48 <araujo> why? :-P
13:02:02 <Cale> otoh, if you just need to have things which are named and have bits of code of a particular type attached, you can just use tuples or a custom datatype
13:02:05 <araujo> ski, ?
13:02:26 <Cale> data NamedFunction a b = NFun String (a -> b)
13:02:41 <ski> araujo : local functions (and other named values) can be renamed, and there should be no observable difference
13:02:53 <Cale> apply :: NamedFunction a b -> a -> b
13:03:01 <Cale> apply (NF s f) x = f x
13:03:18 <Cale> NFun rather
13:03:25 <alar> oh, there's Observational Type Theory!
13:03:36 <alar> not just Intuitionistic and Classical
13:03:44 <araujo> mmm.. ok Cale , i think i can work around that idea.
13:03:48 <ski> araujo : renaming 'foo' to a fresh name 'bar' in 'let foo ... = ..foo.. in ..foo..' into 'let bar ... = ..bar.. in ..bar..' should not change semantics
13:04:47 <araujo> So, it is almost impossible to get the name of it?
13:05:06 <Cale> araujo: many functions don't even have names
13:05:25 <araujo> Right.
13:05:52 <araujo> Well, that's what i was asking, if there existed some way of getting names for those functions with names of course.
13:05:57 <ski> just like you don't always name 'a * (b + 1)' so you don't always name functions
13:06:29 <Cale> araujo: the names don't necessarily even exist after compilation
13:06:36 <Cale> so no, there's no way to access them
13:06:43 <araujo> Right.
13:06:58 * ski wonders why araujo would want something like this
13:07:20 <araujo> Just curious :-]
13:08:34 <araujo> Cale, But i suppose, this is something very much implementation-dependent right?
13:09:10 <Cale> well, an implementation may choose to retain names of functions
13:09:41 <Cale> and might even go to the extra trouble of storing pointers to strings in all of its values where appropriate
13:09:54 <Cale> it's not an impossible language feature, but it's certainly quite strange :)
13:10:06 <araujo> I see.
13:10:35 <araujo> Well, i suppose this is something valid in that thing called "reflective" programming right?
13:10:49 <araujo> Or at least, it should be....
13:11:05 <Cale> potentially
13:11:27 <Cale> I don't think it's even quite required there (but it would probably be convenient)
13:11:43 <araujo> Right, thanks!
13:11:51 <Cale> If you use template haskell, it's certainly possible to get functions and values with particular names.
13:12:00 <Cale> but that's compile-time programming anyway
13:12:14 <araujo> yeah, i was thinking abuot template-haskell.....
14:18:33 <lispy> can the ghc profiler report peak memory usage?
14:18:52 <Cale> yeah
14:19:02 <Korollary> you can even get a chart
14:21:38 <skew> .. with the memory usage sliced up in all kinds of ways
14:21:40 <lispy> i tried the heap profiler but the output was not useful to me before, and i don't see anything in the manual that says, "peak memory"
14:21:53 <skew> have you used hp2ps?
14:22:18 <lispy> yeah
14:22:46 <lispy> BTW, i have to use only the simplest RTS options to profiling. The more advanced onces cause my program to segfault
14:23:59 <skew> I don't know if you can get the peak memory listed as a number somewhere
14:24:13 <lispy> okay, because that's all i'm after at this point
14:24:24 <lispy> i'm on linux so i can't use 'time', it won't report the peak
14:24:31 <lispy> right now i'm just watching the program run and looking at top
14:24:36 <skew> but you have used hp2ps and read peak memory off the graph, right?
14:24:37 <lispy> but that's very pedestrian
14:24:56 <lispy> i didn't see it lasttime, let me see if i have a valid .ps file laying around
14:25:19 <jip> good evening haskell
14:26:03 <lispy> skew: okay, i guess i'd just look at where the graph peaks?
14:26:17 <lispy> but that number is less than what top reports
14:26:34 <skew> yeah, it will be a bit less
14:26:44 <skew> It's the heap space used by the program
14:28:00 <skew> I don't remember everything that isn't included. loaded code? stacks? a C heap if you use ffi?
14:28:40 <lispy> well, FFI would be really important
14:28:41 <skew> does it really matter for what you are trying to do?
14:29:15 <skew> You should see if there are already bugs filed on those crashes.
14:30:27 <lispy> yeah, i should be less lazy about bug reports
14:30:35 <lispy> but ghc doesn't seem to have an easy way to submit bugs
14:31:01 <lispy> the last time i submited one i had to email it and i think they decided it wasn't a bug because they couldn't reproduce
14:31:12 <lispy> so i'm annoyed at ghc bug system :)
14:31:28 <skew> there's a relatively recent bug tracker
14:31:31 <skew> http://hackage.haskell.org/trac/ghc
14:31:44 <skew> I haven't used it myself
14:32:15 <lispy> cool
14:33:23 <lispy> looks nice
14:33:31 <lispy> i'll have to submit my bugs today
14:34:10 <lispy> i have another amd64 specific bug too
14:34:30 <lispy> when i try to build darcs with profiling on that platform gcc gets axed by the oom killer
14:34:42 <lispy> not sure if that qualifies as a ghc bug or not tho
14:37:21 <SamB> @docs Text.Html
14:37:22 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Text-Html.html
14:44:06 <jtokle> has anyone heard of a problem with wxHaskell, where if i load a .hs into ghci and type main, it runs
14:44:18 <jtokle> but if i close the window, and type main a second time, ghci segfaults and quits?
14:45:55 <SamB> jtokle: either yes, or gtk2hs has the same problem
14:46:39 <lispy> jtokle: GLUT seems to have a similar problem where when you call the glut exit function ghci dies
14:47:00 <jtokle> hm
14:47:43 <jtokle> it makes learning wxH a slow process, since i'm constantly restarting ghci
14:47:53 <lispy> jtokle: :(
14:48:14 <lispy> jtokle: are you trying to make a darcs frontend?
14:48:30 <jtokle> no, just trying to learn the language for now
14:49:17 <lispy> well, darcs had a wxHaskell UI at one point, but it has bitrotted.  It might even not compile, but it could be resurectable
14:50:28 <SamB> probably doesn't compile if its actually bitrotted...
14:50:40 <lispy> SamB: it didn't 1.5 years ago
14:50:47 <lispy> so i doubt it compiles now
14:50:56 <lispy> but debugging can be a great way to learn :)
14:51:23 <jtokle> thanks for your responses -- i'll have to take another look at this later
14:51:29 <jtokle> i should get out of the house -- and get some coffee
14:53:48 <lispy> oh hm...he uses qwest, he must live in the NW of the US
14:55:08 <Korollary> tukwila, washington maybe
14:56:05 <lispy> someone should make a C compiler in haskell that can be used in place of gcc for porting ghc to new platforms
14:56:16 <lispy> then things would be really circular :)
14:56:20 <tic> :)
14:56:30 <Korollary> how about just a c-- compiler?
14:57:31 <lispy> oh, maybe that's better.  I don't know much about c-- other than it is supposed to be better for compilers right?
14:58:18 <lispy> "better for compilers" meaning it allows them to generate code which may be more efficient but not expressable easily in c
15:05:33 <chucky> c-- supports tailcalls natively, which is a very very good thing to have when implementing a compiler for a functional language. There are many other benefits as well
15:08:51 <SamB> this is lovely!
15:08:51 <SamB> conjure just segfaulted.
15:09:11 <lispy> SamB: haskell programs can't segfault because you don't manage memory.
15:09:15 <lispy> ;)
15:09:46 <SamB> lispy: that is *so* comforting
15:10:15 <SamB> unfortunately, once you start playing with Ptrs, that ceases to be true
15:10:36 <lispy> SamB: i just find it amusing because someone gave me that exact argument once, but anecdotal evidence seems otherwise...
15:11:40 <SamB> lispy: well, in 95% of your program it is true, isn't it?
15:11:52 <musasabi> unsafePerformIO can make Haskell programs segfault.
15:12:29 <musasabi> basically: "foobar = unsafePerformIO $ newIORef []" and then use it in a polymorphic way.
15:12:30 <SamB> I blame syslog
15:12:58 <jip> how can unsafePerformIO be more prone to segfaults then regular IO?
15:13:37 <SamB> jip: regular IO can't create a polymorphic IORef?
15:15:14 <jip> hm...... hrmm..........
15:15:24 <musasabi> then there are things like Data.Array.Base.unsafeWrite or Foreign.Ptr.poke which allow arbitrary memory writes.
15:15:35 <SamB> jip: anyway, the "unsafe" should be a clue that nasty things can happen if you misuse that function
15:15:35 <musasabi> but with those it is your own fault.
15:16:48 <musasabi> and probably tons of others.
15:16:54 <Heffalump> jip: it's possible to write code with unsafePerformIO that reads an Int from a IORef Char
15:17:06 <Heffalump> this has a tendency to cause segfaultiness
15:17:40 <musasabi> but is also nice, for defining unsafeCoerce# by hand.
15:17:45 <Heffalump> :-)
15:18:16 <jip> it's nice.... because you can? or because it's useful? :)
15:18:33 <musasabi> jip: both.
15:20:24 <mahogny> if I were to use haskell for a program, what would be my best option for adding a plugin system and how easy is it to use?
15:20:47 <jip> hs-plugins
15:21:00 <jip> it's very easy
15:21:00 <mahogny> good?
15:21:02 <mahogny> ok
15:21:06 <lispy> mahogny: hs-plugins, but also remember that good design contributes to plugin-ability
15:21:27 <jip> has anyone tried using a scripting language with haskell, like lua?
15:21:52 <mahogny> well. not lua. working on mirc script in haskell
15:24:34 <musasabi> jip: usually one defines a DSL in Haskell and uses that.
15:26:01 <jip> musasabi: yeah, doing that together with hs-plugins should be a good solution in a lot of cases where people would use lua together with c or c++
15:26:26 <mahogny> I guess the quick follow-up is: how can I control the ABI (for between version module compatibility) or will I have to bother about it at all with this dynamic loader?
15:26:36 <mahogny> using hs-plugins that is
15:31:36 <musasabi> mahogny: most of the time it will "just work".
15:32:03 <mahogny> hm. ok
15:32:38 <mahogny> well, I'll mail the owner. it's worth the effort
15:32:59 <Heffalump> mahogny: no, you're probably screwed for compatibility.
15:33:07 <mahogny> ok
15:33:12 <Heffalump> I'm fairly sure objects from different versions of ghc just don't work together
15:33:27 <Heffalump> though I may be unfairly extending that to hs-plugins, but from what I know of its architecture I think it's unlikely
15:33:47 <mahogny> not even minor ghc versions?
15:34:58 <Heffalump> I believe not.
15:35:02 <lispy> mahogny: you could use your OS provided shared object libraries or dlls i'd think
15:35:02 <mahogny> ouch
15:35:09 <Heffalump> again, I could be wrong about this applying to hs-plugins
15:35:14 <mahogny> yeah. but that suddenly makes a mess
15:35:31 <lispy> dons probably knows theanswers to these hs-plugin questons
15:36:03 <mahogny> I was thinking python otherwise but I guess it is about time to require that ppl have ghc installed by default :)
15:36:25 <mahogny> that would solve it completely
15:38:45 <jip> mahogny: no need, if you are willing to ship plugins as source code then hs-plugins can automatically compile and load them at runtime
15:39:55 <mahogny> yeah. that was my point. it's currently a bit too much to ask that ghc is installed by default on the system though so shipping binaries might make a hell
15:40:11 <musasabi> source version compatiblity is something that is looked after.
15:40:23 <musasabi> but use the same version of GHC for everything.
15:42:14 <Lemmih> mahogny: Using hs-plugins on a system without GHC will most likely be very difficult.
15:43:21 <newsham> hi
15:44:02 <newsham> question: shouldnt it be possible to specify a binary layout in a declarative fashion rather than an imperative way as is done in NewBinary?
15:44:25 <newsham> ie. "the foo field occupies bytes 4 through 7"
15:44:46 <newsham> instead of "get four bytes into bar, then get four bytes into foo"
15:47:07 <newsham> why has the imperative style been preferred, is there something that makes it hard to do in a declarative way?
15:48:03 <integral> hmm, is there a difference since you can convert from one to the other quite simply if it's as simple as you say :)
15:48:16 <newsham> i didnt say its simple.
15:48:22 <musasabi> newsham: there are other more declarative libraries.
15:48:29 <newsham> the difference is that one describes a stepwise process
15:48:40 <newsham> musasabi: cool.  which ones?  got urls?
15:48:49 <musasabi> newsham: declaritive approaches usually are not nice if there are lots of special cases.
15:49:04 <newsham> integral: the stepwise process implies that one thing must be done before the other.
15:49:27 <newsham> sometimes one thing must be done before another, but many times ordering is not important.
15:49:55 <newsham> ie. you have to read a discriminator before you interpret a union, but you do not have to read any one field before any other in a fixed layout structure
15:50:16 <integral> Oh, I was assuming this was in some domain specific monad, so that particular monad could say something about the ordering
15:50:31 <integral> (like there's the identity monad, which is just as lazy as haskell normally is)
15:50:38 <lispy> newsham: what if the layout  is being read over a stream like a networking socket?
15:51:11 <newsham> lispy: perhaps, but maybe not.  (also a networking socket isnt really a "stream" when you look really closely at it)
15:51:58 <newsham> concretely (for my situation) I'm interested in structures pulled out of both packets and streams.
15:52:52 <newsham> http://wagerlabs.com/articles/2006/01/01/haskell-vs-erlang-reloaded  <- somewhat disheartening :(
15:54:04 <lispy> newsham: you're not joelr are you?
15:54:15 <newsham> no, i'm tim newsham.
15:54:25 <lispy> ah, okay
15:54:54 <lispy> i've only followed that thread lightly
15:55:12 <lispy> i know that joel wanted to use haskell, but he ran into a lot of problems and then used erlang
15:55:49 <newsham> if i wanted to use a dynamically typed language, i'd use python
15:57:40 <musasabi> newsham: but other people have much better parser combinators like Bulat's which do 50mb/sec
15:58:27 <newsham> musasabi: what are the names of some declarative marshallers?
16:02:14 <musasabi> newsham: I think e.g. http://cs.helsinki.fi/u/ekarttun/haskell/binser.tar.gz has some declaritive stuff SerLang, and other people will probably have their own equivalents.
16:30:16 <palomer> one advantage of no mutability: memory leaks are impossible
16:30:56 <lispy> palomer: you mean impossible to fix
16:31:11 <lispy> lazy evaluation has lots of memory leak issues, at least in ghc it does
16:31:41 <palomer> but no user induced memory leaks
16:31:50 <palomer> ie references which are never cleared
16:32:20 <lispy> i don't understand the difference
16:32:48 <lispy> i've been looking at a memory leak in darcs since last night without a clue how to proceed :)
16:33:01 <palomer> darcs has a memory leak?
16:33:05 <lispy> this "constant space" version is eating about 1 gig of ram right now
16:33:13 <lispy> and it dosen't always need 1gb of ram
16:33:34 <lispy> palomer: create a very large file and record it in darcs 1.0.5.
16:34:05 <lispy> that version is supposed to use lazy reading/writing to only process as much of the incoming patch as it has to
16:34:08 <palomer> I don't use darcs yet
16:34:15 <lispy> but, in reality it uses a huge amount of memory
16:34:30 <palomer> is this because of ghc?
16:34:36 <palomer> better compilers will reduce leaks?
16:34:47 <lispy> palomer: ah, well you should.  For things like small projects it's a dream.  very easy to setup and you won't hit any of the performance problems.
16:35:18 <palomer> yeah, but I don't know anyone who would host it
16:35:32 <lispy> palomer: i'm not sure, simonm has acknowledged at least one GC bug in ghc that could be at play, but it could also be the way the code is structured.  It could very well be that laziness is causing the leak
16:35:41 <lispy> palomer: you don't need a host
16:35:46 <lispy> there is no server with darcs
16:35:54 <lispy> if you have webspace you can host a darcs repo
16:35:59 <lispy> just make it world readable
16:36:18 <palomer> but I can only write with ssh
16:36:23 <lispy> then you accept patches via email, 'darcs send' creates them and optionally mails them
16:36:27 <psnl> or email
16:36:42 <jip> you can also get memory leaks from recursive IO operations that run the length of the program and wrongfully allocate a bit of memory each time
16:37:02 <palomer> can darcs work with ssh?
16:37:15 <lispy> palomer: yes
16:37:22 <palomer> so I don't need a server
16:37:26 <palomer> all I need is an ssh account
16:37:41 <lispy> well, if you want to use ssh you need darcs on the remote machine
16:37:52 <lispy> on the 'server' that is
16:37:58 <lispy> remote is ambiguous :)
16:38:06 <palomer> hrm, but I can't install darcs on the server
16:38:30 <lispy> well, you can apply patches locally and rsync, unison or scp the repo to the server
16:38:47 <lispy> and you can use posthooks to make it sync them on every record or apply
16:39:11 <palomer> sounds complicated
16:39:52 <lispy> does the server have unison or rysnc?
16:40:15 <palomer> yeah, probably
16:40:26 <lispy> a posthook is just a way to tell darcs that it should run a certain command whenever a darcs action completes successfully
16:41:22 <lispy> you'd probably just need "apply posthook scp -r . me@myserver.net/public_html/myrepo"
16:41:52 <lispy> but rysnc would be more efficient
16:43:18 <lispy> if you get interested and want to start using it, i'm sure i can help, plus there is #darcs
16:43:56 <lispy> all it takes to start a darcs repos is: mkdir myproj; cd myproj; darcs init
16:44:54 <palomer> hrm, that's pretty easy
16:45:13 <palomer> and the source would go into myproj?
16:45:36 <lispy> yeah, darcs add foo; darcs record
16:45:50 <palomer> add foo adds a file?
16:45:52 <lispy> that would add the file foo if were working in myproj
16:46:04 <palomer> what if I add a file in some other directory
16:46:05 <palomer> say /mnt
16:46:15 <palomer> can this be done?
16:46:19 <lispy> you'd need to copy it to myproj
16:46:55 <donal> hello
16:47:07 <palomer> and darcs record updates every file in the repo?
16:48:04 <lispy> darcs record makes a patchset from all the changes which haven't been commited yet
16:48:27 <lispy> so if you edit some files and then type darcs record it will ask you for each file if you want to record the changes in those files
16:48:42 <palomer> and then darcs commit commits all the patches
16:48:44 <palomer> is that correct?
16:48:49 <lispy> but you can also have files which are in the myproj directory that haven't been "added" to the repository yet
16:49:05 <lispy> in darcs terminology there is no commit
16:49:28 <palomer> oh, so all you can do is record
16:49:30 <lispy> darcs record makes a record of the the changes, and darcs push or darcs send helps you share those changes
16:49:47 <psnl> DrHyde: I should ask you what you are doing in this corner of the net
16:50:09 <lispy> palomer: try this: darcs get http://projects.codersbase.com/repos/nehe-tuts/
16:50:52 <lispy> palomer: that will fetch a copy of my nehe-tuts repository.  It's a small repo that will let you play with some of the darcs features.  But you won't be able to push a patch to me because you fetched over http
16:51:43 <lispy> palomer: there is also a cgi script i installed for browsing them: http://projects.codersbase.com/cgi-bin/darcs.cgi
16:51:54 <lispy> it's not a very good script, i think darcsweb and trac are better
16:59:59 <lispy> palomer: if you've used cvs/svn in the past darcs might be a little forgein in that you can record in your repository, because your changes are just stored locally.  Sharing those changes is a separate operation like send or push.
17:09:51 <Mitar> how can i easy make a comparator on multiple keys
17:10:02 <Mitar> compare a b
17:10:07 <Mitar> is simple for one key
17:10:30 <Mitar> but what if i want that if this is the same, that then it should compare another key?
17:10:32 <wilx> Lexical ordering?
17:10:36 <Mitar> yes
17:10:37 <Mitar> lexical
17:10:49 <Mitar> i do not like an idea of multiple if sentences
17:12:19 <palomer> Ord is derivable on tuple types, methinks
17:12:22 <palomer> or something
17:13:15 <palomer> lispy: nope, never used svn/cvs
17:13:24 <palomer> never used any source backing up system
17:14:18 <lispy> oh, well, if you use darcs keep in mind it's very different than the others
17:14:19 <Cale> If you just derive Ord, you get lexicographical ordering, by constructor, and then by each of the components.
17:14:35 <Cale> (in order)
17:14:46 <Mitar> i would just like to make a comparator function
17:14:52 <Mitar> not a class function
17:15:32 <Cale> case x `compare` y of
17:15:47 <Cale>    LT -> LT
17:15:50 <Cale>    GT -> GT
17:16:02 <Cale>    EQ -> case x' `compare` y' of
17:16:06 <Cale>        ...
17:16:07 <Mitar> what about
17:16:28 <Mitar> compare (k1,k2,k3) (k1',k2',k3')?
17:16:43 <palomer> sure
17:16:48 <Cale> well, that just uses the Ord instance for triples
17:16:50 <Cale> sure
17:17:02 <palomer> @index Ord
17:17:03 <lambdabot> Prelude
17:17:05 <Mitar> and this would be lexicographical?
17:17:09 <Cale> yeah
17:17:19 <palomer> how do I get more information for typeclasses from lambdabot?
17:17:36 <lispy> @doc Prelude
17:17:37 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
17:18:08 <Cale> you can also type  :info Ord  into GHCi and get a list of methods and instances
17:34:24 <Mitar> is it possible to have "if ... then ... " without else in IO monad?
17:34:37 <Mitar> i know that it is possible to do if ... then ... else ()
17:34:56 <Mitar> but is there a way without even this?
17:35:00 <sproingie> @hoogle when
17:35:01 <Cale> when
17:35:02 <lambdabot> Control.Monad.when :: Monad m => Bool -> m () -> m ()
17:35:08 <sproingie> @hoogle unless
17:35:09 <lambdabot> Control.Monad.unless :: Monad m => Bool -> m () -> m ()
17:37:27 <Mitar> thanks
17:40:41 <dons> musasabi, there was a bug in yesterday's ackermann, and i've posted a slighly less space-hungry mandelbrot. both on the wiki.
17:40:55 <dons> good to see that many of yesterdays entries jumped a few spots higher :)
17:41:19 <dons> and all I did was refactor. it must expose new optimisation opportunities to ghc.
17:41:51 <lispy> dons: one of the shootout pages updated?  what is the url so i can see what you see
17:41:52 <dons> see cheap-concurrency and binary-trees as examples. much faster, only by refactoring :)
17:42:26 <dons> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=ghc&lang2=ghc
17:42:55 <dons> I concentrated on shrinking the loc (since I think that is what SML is doing to be ranked so high, atm). the side effect was many got faster.
17:43:06 <ncalexan> dons: your guess as to what was beneficial?  moving to smaller functions?
17:43:54 <lispy> dons: cool
17:52:07 <dons> I think just simplying things seems to help ghc out.
17:52:19 <dons> removing points, for one.
17:53:40 <dons> the global rankings haven't been updated yet (currently behind C,D and SML)
17:53:43 <ncalexan> Quite a contrast to other languages, where speed usually means doing more things at the same place, rather than spreading things out.
17:53:56 <dons> I think we can probably get ranked first, with a little more effort.
17:54:12 <dons> clexan, yeah. I think refactoring tends to expose the fundamentals.
17:54:44 <dons> see the pidigits as an example of this. the haskell one is faster and more than 2x smaller.
17:55:18 <dons> the verbosity of other langs tends to obscure optimisation opportunities
17:56:54 <dons> here's the global rankings, but they're a few days behind: http://shootout.alioth.debian.org/benchmark.php?test=all&lang=all&sort=cpu
18:07:17 <Cale> hmm, regex-dna is timing out?
18:09:19 <dons> on the amd, yes. it's horribly inefficient.
18:10:02 <dons> it runs successfully on the p4 though: http://shootout.alioth.debian.org/gp4/benchmark.php?test=regexdna&lang=all
18:10:13 <dons> (and we get some points for having the shortest code :)
18:11:11 <dons> I just tweaked slighly what was already submitted, but I have a feeling that the proposed algo is all wrong.
18:11:28 <dons> looking at the OCAml one might be an idea.
18:14:07 <Cale> why aren't we using subRegex?
18:14:52 <dons> please hack away, Cale. no one has looked at this entry in a few weeks. post it on the wiki, and perhaps compare it to the existing one if you like.
18:36:34 <Cale> whoever wrote Text.Regex probably wasn't thinking too hard about argument order
18:37:23 <lispy> heh
18:40:35 <Cale> @type Text.Regex.mkRegexWithOpts
18:40:37 <lambdabot> String -> Bool -> Bool -> Text.Regex.Posix.Regex
18:41:33 <dons> there should be a packed string or Ptr Word8 interface to Text.Regex too.
18:41:38 <dons> (i.e. expose the underlying bindings)
18:41:44 <Cale> subRegex takes the search pattern, then the input string, then the replacement text
18:42:00 <dons> that would make combing Foreign.Marshall.Array with regexes a lot easier.
18:42:06 <dons> regexes suck in haskell atm :/
18:43:09 <Cale> hmm, how is JRegex?
18:43:25 <dons> maybe we should all be using nibro's regex preprocessor.
18:44:20 <Cale> are we allowed to bring in libraries for the shootout?
18:45:10 <dons> I don't know. the D guys use libggmp though. and libz. but maybe that's like us using base.
18:45:27 <Cale> http://repetae.net/john/computer/haskell/JRegex/ -- that looks quite impressively convenient :)
18:46:04 <musasabi> I think it is mostly "whatever is shipped with the compiler"
18:46:41 <musasabi> So no "install this library", but "-package foobar" is fine (at least most of time).
18:47:34 <Cale> I think we should get things like JRegex, PArrows and Parsek added to the libraries
18:47:40 <dons> musasabi, i've posted a fix for ackermann, a less space-hungy mandelbrot, and am hinting at the sum-file and shorter nsieve-bits I posted yesterday.
18:47:52 <Lemmih> Cale: No, we shouldn't.
18:48:35 <dons> musasabi, nice to see even more tests improving, though. several jumped a few places overnight.
18:48:38 <Cale> JRegex at least would make a nice replacement for Text.Regex
18:50:17 <musasabi> dons: yes, I am waiting for a reply from Isaac Gouy, (he apparently wants us to make all the improvements as new entries, which is fine with me, but would result in foobar.ghc-10.ghc)
18:51:05 <musasabi> dons: so I am waiting to get his opinion does he really want to go that route "submit the bugfixes as new and only remove old ones after some weeks" or whether go forward and fix things,.
18:51:09 <dons> musasabi, just _refactoring_ binary-trees moved it into 3rd, and cheap-conc into 3rd as well.
18:51:20 <dons> ah, and maybe a global -optc-O3 helped.
18:53:13 <musasabi> dons: you seem to know how to refactor things :-)
18:53:20 <dons> actually, cheap-conc really improved a lot. that's weird. i don't know why it is so much better. ah, maybe a space leak was squashed.
18:53:41 <musasabi> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all ;)
18:53:57 <musasabi> dons: yes, the old had a space leak.
18:54:01 <dons> heh!
18:54:18 <dons> 2nd place. and so close to 1st
18:54:21 <musasabi> @karma+ dons
18:54:21 <dons> yay :D
18:54:22 <lambdabot> dons's karma raised to 24.
18:54:31 <Cale> @karma+ dons
18:54:32 <musasabi> dons: hit reload.
18:54:32 <lambdabot> dons's karma raised to 25.
18:55:31 <Korollary> craptastic
18:55:40 <musasabi> C is our only foe ;)
18:56:08 <dons> yeah, but 2 pts is easy enough to get back
18:57:17 <dons> just fixing the broken fasta entry by Chris would probably do it.
18:59:31 <musasabi> imporoving nbody should be possible - http://shootout.alioth.debian.org/gp4/benchmark.php?test=nbody&lang=ghc&id=3
18:59:54 <musasabi> that is just written without any tweaks.
19:00:37 <dons> yeah, haven't looked at this yet. so: nbody, fasta, k-nuc, regex, and i have short nsieve-bits, ackermann, mandel and sum-file on the wiki atm.
19:01:55 <musasabi> then again nbody is the only example where we have a monad transformer
19:02:03 <dons> if you look at the fasta entry, Chris's is much better, but has a small bug somewhere.
19:02:16 <dons> just fixing that might be enough for 1 more pnt or so
19:03:05 <musasabi> in the long term GHC6.6 will do it.
19:04:04 <dons> for one, all the packed string stuff will come in. so we'd be back to 20 line dna entries.
19:04:42 <musasabi> yes :-)
19:08:52 <Igloo> Say dons, once you've overtaken C and are back to twiddling your thumbs you could take a look at http://urchin.earth.li/~ian/bench/bench-0.2/ghc-6.4.1.html and try writing some C-- optimisation passes  :-)
19:09:20 <dons> oh, actually that would be good Igloo.
19:09:49 <dons> musasabi, also, did you know that {- -} style comments aren't removed, and count towards our line count?
19:10:06 <dons> which damages a couple of our entries a little bit.
19:10:56 <Igloo> How does linecount work, incidentally? Does it count semicolons as ending lines?
19:11:26 <dons> I _think_ it strips out comments, based on the languages idea of comments, then counts non-blank lines
19:11:41 <dons> you can join lines with ; and they count as only 1 line
19:11:56 <Igloo> So they just assume people aren't going to be silly, then?
19:12:06 <dons> I noticed SML was doing this, so we do too with some of our import IO; import System
19:13:03 <dons> they warn that they will rearrange the code at will, to scare off this being exploited I think.
19:14:09 <Igloo> That nbody URL could have its linecount shortened with some >>=s. And pretiness increased with (! a) sections  :-)
19:14:52 <dons> yeah. noone's tackled nbody yet.
19:15:31 * Igloo vanishes
19:24:09 <musasabi> the scripts are in the repos for linecount.
19:24:42 <musasabi> dons: I favor -- in new entries, but haven't gone on a spree deleteing all {- -} comments
19:24:54 <musasabi> dons: and I think that counting {-# is fair.
19:27:12 <musasabi> I think common sense is a good guideline. All C entries could be lines of #include + 1.
19:29:10 <musasabi> and all Haskell entries 1 line.
19:51:04 <SamB> hmm, maybe lines should be limited in length to, oh, 160 chars?
19:52:46 <Korollary> 80 is standard in many companies
19:58:03 <musasabi> SamB: and then people invent "if we make all identifiers to be single characters the entries will be shorter" etc
20:03:11 <dons> yeah, it's fair enough to count pragmas
20:03:52 <dons> but haskell has this great pointfree game, that looks really nice, and is less sillly than 1 letter var names
20:04:33 <Cale> heh, shorten code by not using new identifiers at all :)
20:05:16 <dons> huh, on cpu time haskell is ranked 5th. even with the really bad regex-dna
20:05:24 <Cale> That ought to look silly if attempted in C
20:05:33 <dons> My pronouncement: Haskell is a very fast language
20:06:39 <dons> and 7th on memory usage, 1st on linoes of code :)
20:07:03 <dons> quite a long way ahead of SML, too, on loc.
20:07:23 <Cale> and that'll only improve as the compiler gets better :)
20:07:47 <dons> yeah, and this is still with some space leaking entries floating around.
20:08:14 <dons> fasta, k-nucl and regex-dna all use too much space
20:08:18 <Cale> I somehow doubt there's as much room for compiler optimisation of C code right now as with Haskell
20:08:37 <Cale> s/as/than/
20:08:40 <dons> yeah, that's right. there's so many more avenues of improvement to follow
20:08:57 <dons> C-- level optimisations are pretty much unexplored, for one.
20:16:19 <lispy> @keal
20:16:20 <lambdabot> actually it bug in math
20:20:59 <alar> actually I'm too stupid to understand why codata is function
20:28:14 <Beelsebob> @yow
20:28:15 <lambdabot> Should I get locked in the PRINCICAL'S OFFICE today -- or have a
20:28:15 <lambdabot> VASECTOMY??
20:28:27 <Beelsebob> @vasectomy
20:28:28 <lambdabot> Unknown command, try @listcommands.
21:02:39 <Lemmih> A vasectomy command sounds a bit scary.
21:16:03 <Keal> i changed my user od
21:16:06 <Keal> i changed my user id
21:16:09 <Keal> @keal
21:16:10 <lambdabot> where can i find opensource schematics of Linus Torvalds' x86 clone?
21:17:22 <Keal> > let fl = fromIntegral. floor; inf = 2**64; epsilon = 1/inf; dv = [inf,(inf-epsilon)..0]; db = [2..inf]; dp = [(-inf),(-inf+epsilon)..inf]; digit (v,b,p) = b*(fl (v/b**p)/b - fl(fl (v/b**p)/b)) in map digit [ (v, b, p) | v <- dv, b <- db, p <- dp]
21:17:23 <lambdabot> []
21:18:33 <Keal> bot defective
21:21:46 <musasabi> Keal: dv is an empty list.
21:22:25 <musasabi> Keal: you should just write your definitions into a source file and use ghci.
21:22:37 <musasabi> Keal: then you would have seen this instantly.
21:25:32 <Keal> lamadabot took 5 to 8 whole seconds to return []
21:26:03 <musasabi> Keal: and irc has a lag of many seconds.
21:26:17 <musasabi> Keal: if you want something fast, then use ghc on your local machine.
21:26:28 <Keal> i aint running that on my puter
21:27:33 <musasabi> Keal: then don't wish for things working.
21:27:35 <Keal> i dont want to say... oh btw my fpu is blown due to a hardcased failsafe i have 3 year warranty right. and then they call fads
21:27:50 <Keal> feds*
21:29:06 <cpatrick> Keal: so in that case, do you think it isn't exactly polite to be running that on dons's server
21:29:14 * Keal was going to work on something today but got laid instead and now too sleepy due to fiancees good cooking
21:40:26 <lispy> @kel
21:40:27 <lambdabot> what is the max amount of operands haskell can handle in a single
21:40:27 <lambdabot> expression?
21:47:40 <lispy> there is no limit on the operands per se is there?
21:52:22 <skew> lispy: what?
21:54:13 <Keal> cpatrick
21:54:24 <lispy> oh, someone asked if there wasa max amount of operands in a single haskell expression
21:55:04 <Keal> there is no way to prove the failsafe exists. since the computer simply acts like it was in close enough range to be slighly affected by nuclear emp
21:56:50 <lispy> well, that seems reasonable
21:58:55 <Keal> that would heve been me
21:59:27 <Keal> that was today's haskell project but i was too busy chasing tail
22:02:17 <Keal> today's 24hour project was supposed to be logical overloading using plegm method
22:03:14 <Keal> but i woke at 12 chased tail at 2 reached home at 4 ate a wonderous mel cooked by said tail at 6 and took er home at 8 and got home at 10
22:03:55 <Keal> so i am pewped
22:04:51 <Keal> perhaps i overload haskell more tomorrow
22:04:54 <adu> tired?
22:49:57 * gour is worried that haskell is on drugs and therefore get disqualified seeing latest shootout results
22:53:18 <gour> what substances is haskell taking in a recent time so that he climbed to the 2nd top
22:54:12 <gour> or is it due to veget. meals...
22:54:33 <gour> anyone saw dons post or http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
22:56:22 <Lemmih> I wonder how jhc compiled programs would perform in the benchmark.
22:57:06 <gour> i wonder how many programs can be written for jhc
22:57:32 <Lemmih> Aren't they all Haskell98?
22:57:46 <cpatrick> nope, lots use ghc extensions
22:58:33 <lispy> i could be wrong, but i think most "real-world" haskell programs use ghc extensions
22:59:07 <Lemmih> lispy: The shootout benchmarks aren't related to real-world problems.
22:59:50 <gour> lispy: what about your darcs profiling?
23:03:17 <Poeir> Functional programming has given me a grossly unfair advantage in a game of Axis & Allies.  This is the coolest thing.
23:03:24 <me22> O_o
23:04:12 <Poeir> me22: I wrote a program that calculates the probability of taking out any number of units in an attack in Axis & Allies.  Meaning I can guarantee a 2:1 advantage on any of my attacks.
23:04:24 <Poeir> me22: We only get together once a week and are between turns right now.
23:04:28 <me22> ah
23:04:34 <lispy> gour: what about it?
23:05:16 <lispy> gour: well, i figured out that darcs rereads the patch it creates during record
23:05:44 <lispy> gour: this is done so that the whole patch need not be in memory at once, but in practice doing this leads to horrible performance
23:06:35 <lispy> gour: i made darcs stop rereading the patchand it was a huge performance savings, but i don't think the devs liked the patch.  so then i tried to prove to them that the current way is actually worse in terms of peak memory consumption and time
23:07:10 <KirinDave> lisphy: Hello. How goes?
23:07:28 <lispy> KirinDave: not bad, you?
23:07:34 <gour> lispy: why they don't like it?
23:07:37 <KirinDave> tired.
23:08:22 <lispy> gour: because it forces darcs to hold the whole patch in memory at once.  But the current way does that too, so it's not the status quo is actually better.  I hope to have showed them that.
23:14:10 <gour> lispy: i hope so. iirc, i never saw on darcs' list that the behaviour of holding everything memory changed, so if yours is better...hmm..strange
23:19:47 <lispy> gour: imho, what darcs really needs is bounded buffers doing the io
23:22:28 <gour> lispy: latest shootout results (i believe) show that  haskell code can be tweaked to have decent performance
23:22:58 * gour does not know the internals of the darcs code, so cannot comment on the details
23:23:06 <lispy> gour: yeah, the problem with darcs are all solvable, some are just poor inital engineering
23:23:40 <lispy> for example patches are a sequence of lines all starting with either + or -, and so the parser has to read line by line getting rid of pluses and minuses
23:23:48 <lispy> on a 500mb file that sucks
23:27:58 <gour> true, david acknowledged he was still learning haskell when started
23:28:48 <gour> linux kernel is the measuring stick...
23:30:33 <lispy> gour: i backup my homedir using darcs, that's been a measuring stick for me
23:30:45 <lispy> but for the last 9 months i haven't been able to use darcs
23:30:54 <lispy> part of my incentive to work on the preformance
23:31:21 <gour> huh, how big is your homedir?
23:31:36 <lispy> not that bad, but i have some very large patchs from when i imported
23:31:42 * gour hopes lispy still does backup of his homedir
23:31:44 <lispy> and i wante to be able to use --look-for-adds
23:32:04 <lispy> gour: i backup it up using conventional tools, but i don't version it at the moment
23:33:00 <gour> btw, what do you use for backup?
23:33:08 <lispy> cpbk
23:33:24 <lispy> think of it like a simplified rsync that is local to local only
23:33:41 <lispy> but i want to try unison
23:33:43 <lispy> mjust lazy
23:34:03 <lispy> unison is written in ocaml, fyi
23:34:52 <gour> i heard about unison. rsync?
23:35:00 <cpatrick> unison is very cool
23:35:07 <cpatrick> but it solves a different problem to rsync
23:35:31 <lispy> gour: rsync is a very common backup utility
23:35:42 * gour uses (k)dar and looking to buy external hd
23:35:43 <lispy> it synchronizes directories
23:35:57 <lispy> ah, yeah i use a USB drive, it works great
23:35:58 <gour> is unison still developed?
23:36:02 <lispy> not sure
23:36:03 <cpatrick> gour: yep
23:36:18 <cpatrick> or at least it was a few months ago
23:36:18 <Cale> anyone here play rocksndiamonds? (the boulderdash clone)
23:36:27 <lispy> Cale: sorry
23:36:32 <lispy> anyone here play llor.nu?
23:36:32 <gour> lispy: i'm thinking about firewire (seagate)
23:36:50 * gour has no time for playing :-(
23:36:53 <lispy> gour: USB2 is very fast, and so if you already have it it's cheaper :)
23:37:18 <cpatrick> unless you also already have firewire ;P
23:37:23 <lispy> true
23:37:24 <gour> lispy: yep, but i have firewire on mobo, and the drive has dual-connectors
23:38:18 <lispy> i have an external usb drive connected to my debian fileserver and i do a backup once a week
23:38:35 <lispy> works pretty good, plus i have a server in a datacenter that i have a copy on
23:39:35 <gour> for personal backup, the most reliable media for me was(is) MO disks, not a single failure. (i had tapes, DAT...)
23:39:58 <gour> and my fujitsu is still working, but the media size of 640MB :-(
23:53:15 <Mitar> i read that it is possible to convert haskell code to c code
23:53:18 <Mitar> it is? how?
23:53:43 <lispy> Mitar: well, you translate it
23:53:56 <lispy> it doesn't look the same afterwards :
23:53:58 <lispy> :)
23:54:52 <Mitar> i would just like to see what it makes
23:54:55 <Mitar> so it is possible?
23:57:33 <Lemmih> Mitar: Sure, GHC does it all the time.
23:57:42 <cpatrick> there's a ghc option to just spit out the C code
23:58:34 <Mitar> ok
23:58:35 <Mitar> thanks
23:58:43 <Mitar> i will look for it
