00:02:20 <lispy> Mitar: -E
00:03:24 <Mitar> -C
00:03:38 <lispy> oh, am i thinking of preprocessing
00:08:34 <skew> Mitar: it's nearly impossible to read the C
00:08:50 <Mitar> :-)
00:08:53 <Mitar> i see that
00:09:21 <skew> there is some chance of understanding the core
00:09:28 <skew> I think -ddump-simpl is the option
00:13:38 <araujo> Hello.
00:16:30 <jip> yo
02:05:18 <Mitar> what is possible use of pgmdep flag in GHC?
02:10:46 <Mitar> and possible values for optdep?
02:21:16 <Mitar> how can i specify filename of file to which ghc -M should output?
02:23:44 <Mitar> aa
02:23:45 <Mitar> found
02:23:45 <Mitar> ghc -M -optdep-f -optdep.depend
02:24:23 <genneth> hey all
03:12:43 <eivuokko_> Is there some convient (and more or less standard) way to handle multiple "bracket"-style resources?  I have been using (self-written) functions like use2 :: ((a->r)->r) -> ((b->r)->r) -> (a->b->r) -> r
03:13:05 <xerox> .....seems like Cont Monad?
03:13:34 <eivuokko_> Uhhuh
03:14:39 <xerox> What does the implementation look like?
03:14:58 <eivuokko> use2 r1 r2 f = r1 $ \p1 -> r2 $ \p2 -> f p1 p2
03:15:10 <eivuokko> .. just like when combining multiple brackets..
03:15:56 <eivuokko> If I understand correctly, Cont cannot express that because function types cannot be generalised by last return value.
03:16:08 <eivuokko> But I have never used Cont, so I dunno.
03:16:17 * xerox joins the dunno club
03:16:24 * Beelsebob would never know
03:16:39 <xerox> Hmmm.
03:16:41 * Beelsebob stands around singing
03:16:43 <ulfdoz> What does the "~" do in ~[num] <- getArgs
03:16:57 <xerox> ulfdoz: irrefutable match, or refutable match, check the docs
03:17:00 <eivuokko> It means pattern match can fail, it is refutable pattern.
03:17:15 <eivuokko> (pattern match is postponed until you use binded variable)
03:17:44 <xerox> Yah!
03:17:57 <xerox> @type runCont
03:17:59 <lambdabot> Not in scope: `runCont'
03:18:01 <xerox> @type Control.Monad.Cont.runCont
03:18:03 <lambdabot> forall r a. Control.Monad.Cont.Cont r a -> (a -> r) -> r
03:18:13 <xerox> You see, (a -> r) -> r, foo!
03:22:27 <eivuokko> If I have two of those, and a->b->r, how does it combine?  I am using something like use2 alloca allocae $ \item1 item -> do checkError $ callSomethingFFI item1 item2 and_other
03:23:28 <xerox> @type ((>>=) (undefined :: Cont a) undefined)
03:23:29 <lambdabot> Not in scope: type constructor or class `Cont'
03:23:36 <xerox> @type ((>>=) (undefined :: Control.Monad.Cont.Cont a) undefined)
03:23:37 <lambdabot>   `Control.Monad.Cont.Cont a' is not applied to enough type arguments
03:23:37 <lambdabot>   Expected kind `*', but `Control.Monad.Cont.Cont a' has kind `* -> *'
03:23:42 <xerox> @type ((>>=) (undefined :: Control.Monad.Cont.Cont r a) undefined)
03:23:44 <lambdabot> forall r b. Control.Monad.Cont.Cont r b
03:23:49 <xerox> @type ((>>=) (undefined :: Control.Monad.Cont.Cont r a))
03:23:51 <lambdabot> forall r a b.
03:23:51 <lambdabot> (a -> Control.Monad.Cont.Cont r b) -> Control.Monad.Cont.Cont r b
03:24:11 <eivuokko> Hmmm.
03:26:10 <eivuokko> Maybe it works, but I fail to see how.  I'll play with it later.  Thanks :)
03:26:31 <xerox> @type \r1 r2 f -> r1 $ \p1 -> r2 $ \p2 -> f p1 p2
03:26:33 <lambdabot> forall b b1 t t1 t2.
03:26:33 <lambdabot> ((t1 -> b1) -> b) -> ((t2 -> t) -> b1) -> (t1 -> t2 -> t) -> b
03:26:57 <xerox> eivuokko: good luck, I hope it goes well either case.
03:33:24 * pesco starts screaming.
03:33:30 <pesco> Wuaaaaaah....
03:33:53 <pesco> I think I have a mental block on computer programming!
03:34:21 <pesco> As soon as I sit down at the computer, I cannot concentrate on code anymore!
03:34:32 <pesco> Please, doctor, what's wrong with me?!
03:35:45 <genneth> what is the type of a cache?
03:36:04 <genneth> i'm trying to implement an algo that uses coherence between computations as an optimization
03:36:21 <genneth> but it seems to me that it shouldn't affect the type
03:36:32 <gour> pesco: add :-)
03:36:59 <pesco> gour: Starting to manifest at age 25?
03:37:02 <pesco> :)
03:37:28 <gour> pesco: well, our 'civilization' is advancing rapidly :-)
03:38:23 <pesco> Actually, internal self-diagnosis suggests guilt over neglected coursework a more likely explanation...
03:38:27 <pesco> :/
03:38:36 <pesco> s/a more/as a more/
03:39:13 <gour> well, that's also something - internal voice, conscience ;)
03:39:21 <pesco> (Did the authors of sed know how many IRC-conversations they would be saving?)
03:40:48 <gour> pesco: why?
03:41:11 <pesco> gour: Just a thought.
03:41:14 <gour> ok
03:42:21 <pesco> Okay, I'm finishing this program. Then I'm writing my professor that I'm sorry for the delay and if I can take the exam in a week. Okay, Mom?
03:43:59 <gour> go ahead, son ;)
03:49:02 * pesco cheers.
03:49:05 <pesco> Thanks, gour.
03:49:30 * audreyt praises Writer.censor
03:49:57 <pesco> Heh.
03:51:14 <Heffalump> @type Control.Monad.Writer.censor
03:51:15 <lambdabot> forall a (m :: * -> *) w.
03:51:15 <lambdabot> (Control.Monad.Writer.MonadWriter w m) =>
03:51:15 <lambdabot> (w -> w) -> m a -> m a
03:55:11 <audreyt> a single censor plus a list comprehension = lambda lifting
03:55:23 <audreyt> (in pugs's parrot codegen that I'm writing now)
03:55:55 <audreyt> is there a name for (:[]) ?
03:55:59 <audreyt> @hoogle a -> [a]
03:56:00 <lambdabot> Data.List.repeat :: a -> [a]
03:56:00 <lambdabot> Prelude.repeat :: a -> [a]
03:56:00 <lambdabot> Data.List.replicate :: Int -> a -> [a]
03:56:07 <audreyt> apparently not
03:56:12 <Heffalump> audreyt: no, but it's often called wrap
03:56:21 <audreyt> in Data.Sequence it's called singleton
03:56:42 <pesco> audreyt: You can also use the list monad's return.
03:57:02 <audreyt> good idea.
03:57:05 <Heffalump> but don't do that, it's really confusing :-)
03:57:10 <audreyt> a wee bit obfu
03:57:12 <Heffalump> and it'll make type errors harder to understand
03:57:14 <pesco> audreyt, Heffalump: ;) You're right.
03:57:17 <audreyt> I think I'll just use :[] :)
03:57:41 <pesco> (:[]) is only one character more than "wrap" ;)
03:58:48 <jyp>  > (return 5) :: [Int]
03:58:55 <jyp> > (return 5) :: [Int]
03:58:56 <lambdabot> [5]
04:00:37 <audreyt> > return return
04:00:38 <lambdabot>  add an instance declaration for (Show (m (a -> m1 a)))
04:00:53 <audreyt> > instance Num ()
04:00:54 <lambdabot>  parse error on input `instance'
04:01:56 <gour> CosmicRay: ping
04:09:14 <dons> audreyt, http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
04:09:50 <audreyt> ooh, my claim is made true
04:10:08 <dons> which claim was that?
04:10:19 <bringert> anyone else working on the shootout k-nucleotide benchmark?
04:10:40 <dons> brignert, have a go. i will have an attempt in the next few days sometime.
04:10:41 <audreyt> "Haskell is faster than C++, more concise than Perl, more regular than Python, more flexible than Ruby, more typeful than C#, more robust than Java, and has absolutely nothing in common with PHP."
04:10:49 <audreyt> dons: oh, hsplugins-release-p?
04:11:08 <dons> fasta, k-nuc, n-body, regex-dna and spectral-norm could be improved
04:11:13 <dons> ah, that claim!
04:11:30 <Heffalump> "faster than C++" sounds rather dodgy :-)
04:12:53 <audreyt> indeed, if not for dons's link above :)
04:13:03 <dons> yes, experimental evidence.
04:13:15 <dons> hs-plugin 1.0 is tagged, waiting to be shipped
04:13:24 <mahogny> haskell is one of those languages that is semi-bad to compare though. you can easily gain in speed if you are willing to pay with more lines of code
04:13:27 <jyp> kudos, dons 
04:13:38 <dons> mahogny, check the line count though...
04:13:53 <dons> we actually often got speed ups as we _reduced_ the lines of code
04:14:07 <dons> see pidigits, cheap-conc and binary-trees as examples of this
04:14:11 <jyp> I wish they'd keep also the smallest programs as well as the fastests
04:14:21 <audreyt> jyp: they do that
04:14:23 <audreyt> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all&xfullcpu=1&xmem=0&xloc=0
04:14:25 <dons> jyp, true. but mostly the smallest are the fastest.
04:14:27 <audreyt> # count cpu only
04:14:53 <audreyt> counted this way, GHC is faster than C++ but slower than a few others
04:14:54 <jyp> sumfile is a counter example 
04:14:58 <audreyt> but if you count only LOC:
04:15:00 <audreyt> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all&xfullcpu=0&xmem=0&xloc=1
04:15:07 <audreyt> then GHC wins #1 easily
04:16:10 <audreyt> the by-cpu winners before GHC are: C, D, SML, Eiffel
04:16:42 <dons> there's some more improvement on the cpu front to be made yet, as well.
04:16:49 <Mitar> is it possible to make a source file such that on different version of GHC it would use different module (older interface)
04:17:01 <dons> Mitar, cpp
04:17:03 <Mitar> i have let (graphrev, vertexToActivity, _) = graphFromEdges graphdata
04:17:19 <Mitar> but on 6.4 it does not work and it should be
04:17:21 <Mitar> let (graphrev, vertexToActivity) = graphFromEdges graphdata
04:17:27 <Mitar> dons, how?
04:18:11 <dons> check the value of __GLASGOW_HASKELL__
04:18:22 <audreyt> (down that way lies madness though.)
04:18:39 <Mitar> my mistake
04:18:44 <Mitar> on 6.2 it does not work
04:18:47 <Mitar> on 6.4 it does
04:19:00 <Mitar> so what should i do?
04:19:05 <Mitar> ignore the 6.2 version?
04:19:12 <Mitar> and require 6.4?
04:19:19 <Mitar> as there is only one difference - this line
04:19:45 <audreyt> Mitar: is it inconvenient to your users to upgrde to 6.4?
04:20:54 <Mitar> i do not know if it is possible
04:21:07 <Mitar> (on Debian, there is no 6.4 stable package)
04:21:53 <dons> i.e. #if __GLASGOW_HASKELL__ >= 503
04:22:09 <Mitar> 503?
04:22:44 <ibid> Mitar: there is  an unofficial package
04:22:49 <dons> ghc version, e.g. 5.0.3 or 6.4.0
04:23:57 <Mitar> what is difference between 5.0.3 and 6.4.0?
04:24:11 <Mitar> the reason why they are at stable is because they want official packages
04:24:14 <dons> 5.0.3 was several years ago.
04:24:41 <Mitar> should't i do
04:24:49 <Mitar> < 604
04:24:50 <Mitar> ?
04:29:42 <Mitar> what's the point of having a function named graphFromEdges' for "backwards compatibility" when this function does not exist in older versions
04:29:43 <Mitar> ??
04:30:48 <Mitar> or it is really so much harder to add one _ to the result match than to add ' when using new version on old code
04:42:22 <Mitar> why i get at linking many: ActivityReader.o(.text+0x1a55): In function `s9fN_ret':
04:42:22 <Mitar> : undefined reference to `TextziParserCombinatorsziParsecziChar_zdwsatisfy_entry'
04:42:33 <Mitar> (but the objects compile ok)
04:43:34 <Mitar> if i use ghc --make -cpp it works
04:43:52 <basti_> maybe you forgot a -package that you're using (but not relying to any parts of it that have to be linked)?
04:44:16 <eivuokko> -package parsec in this case, most likely
04:44:16 <Mitar> but if i use ghc -o out -cpp -O *.o it does not
04:45:00 <basti_> -O *.o might not do what you suppose it to do btw.
04:45:17 <eivuokko> It is because automatic package detection works during compile, if linking step is done later, the information is lost.
04:45:24 <Mitar> i am making a make script
04:45:33 <Mitar> and i have $(GHC) -o $@ $(GHCFLAGS) $+
04:45:40 <Mitar> for linking
04:46:10 <Mitar> is there a way to store this automatic package detection data for later?
04:46:20 <Mitar> (for linking)
04:46:27 <eivuokko> Not afaik.
04:46:29 <basti_> did you try adding -package parsec to the linking line?
04:47:33 <Mitar> it works with it
04:47:50 <Mitar> but i do not like an idea of manually adding/removing this when i add a package
04:48:01 <Mitar> i like the ghc -M functionality
04:50:11 <araujo> Good morning.
04:51:38 <der_eq> morning
05:03:16 <Mitar> what would you recommend for making a "make test" target for haskell program? hunit?
05:07:30 <bringert> in the shootout, are there any extra libraries installed, or just the stuff that comes with GHC?
05:07:52 <bringert> specifically, I'd like fps...
05:10:01 <Saulzar> I don't think so, if I recall people were talking about using it when it was distributed.
05:12:50 <araujo> What is the opposite of an abstract data type?
05:14:33 <mahogny> a data structure
05:16:19 <Mitar> this is an exam question?
05:25:53 <bringert> what is the opposite of a horse?
05:27:25 <Saulzar> A duck
05:27:44 <dcoutts> burn the witch!
05:28:48 <dcoutts> @google She turned me into a newt
05:28:49 <lambdabot> http://www.imdb.com/title/tt0071853/quotes
05:28:55 <Saulzar> Logically, if she does not weigh the same as a horse, she weighs the same as a duck, and therefore...
05:30:39 <dcoutts> burn the witch!
05:31:19 <dcoutts> ... she's made of wood?
05:40:12 <gour> dcoutts: ping
05:41:23 <dcoutts> gour, pong
05:41:43 <gour> dcoutts: hi, have you some free slot?
05:41:56 <dcoutts> I guess so
05:42:22 <gour> i have two exercises i'd like to complete so i can move to 15th ch.
05:42:49 <gour> we discussed them here yesterday, but i'm not (fully) satisfied
05:42:54 <dcoutts> ok
05:43:08 <gour> 1st (both are kind of proofs)
05:43:26 <gour> we have instance A a => A (a,b)
05:43:38 <gour> instance B b => (a,b)
05:44:10 <gour> and have to show that we can do: instance (A a, B b) => C (a,b)
05:44:38 <gour> (generalization of the previous exercise from the book)
05:44:47 <dcoutts> oh, by providing an implementation?
05:44:55 <dcoutts> ie a constructive proof
05:45:26 <gour> noj, i did implementation in the exercise, not the proof should be constructed that above is valid for any two classes
05:46:05 <dcoutts> do we know anything about the class C ?
05:46:09 <gour> the example in the book was combining Named & Movable class in two ways
05:46:56 <dcoutts> are these specific classes A,B,C or for any possible class?
05:47:26 <gour> let me paste you my solution: http://pastebin.com/506661
05:47:57 <gour> the exercising are dealing with class inheritance
05:48:56 <dcoutts> so C is a class with no methods?
05:49:15 <gour> it looks so
05:49:25 <dcoutts> can you paste the full question. I don't think I have enough information.
05:49:42 <dcoutts> I don't know how A,B,C,a,b,c are qualified
05:49:45 <gour> ok, here is the 1st way: http://pastebin.com/506663
05:51:12 <gour> and simon explains that with this method "we can combine an arbitrary instance of the Movable class with a particular instance of the Named class, String"
05:52:09 <gour> "..show how it can be used to combine an arbitrary instance of one class with a particular instance of another for any two classes whatever."
05:52:26 <gour> that is the 1st method, and the 2nd:
05:53:02 <gour> "a different way of combininig the classes Named and Movable is to establish the instance
05:53:27 <gour> instance (Movable b, Named c) => NamedMovable (b,c)
05:54:05 <gour> "this is done by giving the instances: instance Movable b => Movable (b,c) where ...
05:54:23 <gour> instance Named c => Named (b,c) where... "
05:55:32 <gour> so 1st paste contains the declarations which i wrote to combine the two classes, and we have to show "that the method of the previous question can be used to combine instances of any two classes."
05:55:34 <gour> that's all
05:55:40 <dcoutts> ok
05:55:46 * dcoutts will be back shortly
05:56:11 <gour> dcoutts: sorry for bothering. it's a 15th. ch. showstopper :-)
05:57:37 <araujo> mm.. interesting thread about generic programming
05:58:43 <gour> araujo: where?
05:58:55 <araujo> oh, comp.lang.functional
05:59:23 <gour> araujo: i gave it up after several brandon's threads :-)
05:59:58 <araujo> this is a new thread
15:01:06 --- topic: '["Haskell is still the language of choice for discriminating hackers","logs: http://tunes.org/~nef/logs/haskell/","http://www.haskell.org/learning.html","http://www.haskell.org/tmrwiki/IssueFive","We put the Funk in Funktion","http://sequence.complete.org/hwn/20051129","HCAR 11/2005: http://haskell.org/communities/"]'
15:01:06 --- topic: set by lambdabot on [Sun Jan 08 06:02:33 2006]
15:01:06 --- names: list (clog triplah Buggaboo mauke sh10151 sethk ncalexan glasser Cale franka f5n2r1l RemiTurk Nioate greenrd neurogeek glasse golos slipstream-- SamB Lokadin Nomius Philippa esap tic jorik int-e Revision17 kpreid_ ronnie nomeata jberg jyp arjanb basti_ cooz masm psi genneth mahogny magagr nnunley liyang kaol eno Touqen kisu ex_nor pgavin rblackwe svens moonlite eyck_ eivuokko Igloo Saulzar exnor lispy carp_ insheerd` carp__ wilx iratsu boozee)
15:01:06 --- names: list (chucky ski sylvan ksandstr binary42 gzl_ dons psnl neologism ramki Mitar Pupeno newsham Poeir xinming integral borism johs Lemmih djw Trixsey|Laptop ozone_ Twigathy cognominal pesco mornfall norpan sieni AtnNn Heffalump cods kosmikus Nanar edwinb tromp_ cpatrick calvin__ xerox jiing dcoutts arguile tuomov Spark WillKW skylan emu kolmodin tic|school metaperl dcoutts_ tumm wli frederik_ CosmicRay astrolabe PerlJam ulfdoz stesch Speck Si\Uni)
15:01:06 --- names: list (spamsch cmeme araujo fatbrain dany2k audreyt lambdabot JohnMeacham juhp wolverian drbean_ cjs_ gdsx Khisanth musasabi orbitz alch` C-Keen tre kzm palomer Korollary scw rep zamez noj Lunar^ cbus jp-autark Matt-W jlouis Wallbraker tewk mattam seafood ricebowl resiak nathan_ CLxyz JKnecht Jaen kpk aleator ValarQ ibid flux__ earthy)
15:01:45 <Mitar> so what is difference between quickcheck and hunit?
15:01:55 <dcoutts> RemiTurk, http://cvs.freedesktop.org/xcb/xhsb/
15:01:55 <dons> QC generates tests for you
15:02:11 <dcoutts> RemiTurk, that might be helpful for writing an X11 window manager
15:02:13 <RemiTurk> dcoutts: cool, though I'd have to install XCB first I guess... Actually, I have some working (Xlib) code right now that doesn't really work after all and I'm looking for eyes ;)
15:02:15 <dons> with HUnit you write the tests by hand.
15:02:21 <dons> almost always QC is what you want.
15:02:23 <RemiTurk> dcoutts: thanks, I'll take a look :)
15:02:29 <dons> Hunit is good for large stress tests, however
15:02:33 <jyp> You can have a look here... http://darcs.haskell.org/testsuite/driver/
15:03:24 <Mitar> i need hunit then
15:03:36 <sh10151> *boggle* http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
15:04:23 <dons> sh10151, oh cool. I knew I picked the right language to do a phd on.
15:04:51 <sh10151> dons: C? ;)
15:04:54 <jyp> ... if only the industry could see the light :)
15:06:14 <Mitar> hmm, any examples on how can i test with hunit?
15:06:25 <Mitar> (if i want to test console input/outpu)
15:06:37 <Mitar> i am quite lost in the manual
15:06:50 <jyp> btw, with all due respect, such things are too ugly for my taste... http://shootout.alioth.debian.org/gp4/benchmark.php?test=fannkuch&lang=ghc&id=2
15:07:51 <RemiTurk> jyp: ugh, indeed, when is the next international obfuscated haskell code contest? :S
15:08:11 <dons> jyp, yes. but we have no fast packed string standard library
15:08:18 <sh10151> jyp: you like http://shootout.alioth.debian.org/gp4/benchmark.php?test=fannkuch&lang=gcc better? :)
15:08:19 <dons> when that's available, we'll use it.
15:09:15 <jyp> Speaking of obfuscation, I like the way the parser mistakes a big chunk of it as comments :)
15:09:53 <jyp> sh10151, I must say it's less obfuscated...
15:09:56 <dons> it's all a matter of balancing the competing constraings of cpu, memory and lines of code/beauty
15:10:20 <jyp> plus, when I think haskell, I generally think "neat"... thus my disappointment
15:10:35 <jyp> dons: agreed
15:10:43 <dons> jyp, it's only due to the missing packed string library. 
15:11:00 <dons> once that's in base, i'd say this entry will be 20 lines of beauty :)0
15:11:12 <dcoutts> jyp, I guess one point of the shootout when it comes to Haskell is that it shows that we can actually write fast code if necessary
15:11:38 <lispy> this is my view of the rankings
15:11:39 <lispy> http://tinyurl.com/at2qg
15:11:44 <dons> yes *we must kill the myth that haskell is slow and memory hungry*
15:11:46 <dcoutts> jyp, so while most of your program can be readable, if you find that one bit is too slow then it can be optimised (and uglified) within the same language
15:12:19 <dcoutts> jyp, compare that with Python, where they recommend to drop to C for the hot spots
15:12:42 <dcoutts> we can have fst ugly code and nice code all within the same language
15:12:42 <dons> and it was quite embarrassing how poor the IO/string intensive entries for Haskell were. now they're not so bad.
15:13:18 <jyp> well, dropping to C may be a sensible approach
15:13:44 <dons> oh, I see, the syntax highlighter doesn't know about the use of ' on varids
15:14:08 <dons> anyway, we use this kind of code every day. ever look at GHC.* ;)
15:14:43 <dcoutts> jyp, but if we can get reasonable performance without dropping to C then we get benefits like retaining type checking, not having to do marshaling code.
15:15:00 <jyp> that's right
15:15:01 <dons> so we shouldn't be pretentious that such code is just not worthy of haskell ;)
15:15:08 <Dfhaii> evenin'
15:15:21 <SamB> dcoutts: and think of all the boilerplate to write Python extension modules!
15:15:32 <jyp> I'm just afraid some of the low-levelness creeps up to the upper layers
15:15:53 <Dfhaii> wonder if anyone can help with what is probably a simple question
15:15:55 <dcoutts> dons, and if we can get the effecient stuff without too much work, eg {-# UNPACK #-} then that's ideal.
15:15:57 <dons> that's reasonable, but there's a *lot* of social pressure against it..
15:16:11 <Dfhaii> i have a list of pairs, is there anyway of counting how many times each of the pairs come up
15:16:19 <dons> jyp, so I doubt we'll see too much pollution of the nice haskell world
15:16:26 <Philippa> jyp: a LowLevelness monad may be useful sometimes
15:16:37 <Philippa> at least, if there's a sensible notion of runLowLevelness
15:16:57 <Dfhaii> ie [(a,1),(a,1),(b2)] would return a list [((a,1),2), ((b,2)1)]
15:16:57 <dcoutts> jyp, speaking of which, we're pushing down the low-levelness of the Gtk+ TreeView API at the moment. Due to social pressure. :-)
15:17:06 <dons> here for example, speed and memory are critical, and the reputation of haskell is at stake, yet still i get criticised for writing low level code. so I doubt the every day hacker will dare write such code :)
15:17:07 <Philippa> Dfhaii: yep. You need a map from pairs to natural numbers (OK, OK, integers)
15:17:13 <jyp> dcoutts: :)
15:17:43 <jyp> dons: don't take it as a criticism
15:17:44 <Dfhaii> ah i think i get you
15:17:50 <Dfhaii> not good at haskell at all
15:17:56 <Dfhaii> more of a procedural person ;)
15:18:07 <dons> jyp, no , I'm just joking. I'm just happy we're ranked _almost first_ :)
15:18:11 <Philippa> Dfhaii: it's up to you where/how you get that map
15:18:19 <Philippa> you'd do it the same way in a procedural language btw
15:18:30 <Philippa> it's just you probably already know how to build a map in a procedural language
15:18:40 <Philippa> dons: how far from first are we, btw?
15:18:51 <dons> about 1%, i.e. 5 or 6 hours :)
15:19:04 <Philippa> heh
15:19:16 <ulfdoz> I don't understand the type of Data.Map.lookup. What's this ominous m a it returns? From context I can see, it is a Monad, but which one?
15:19:29 <dcoutts> @type Data.Map.lookup
15:19:31 <lambdabot> forall a (m :: * -> *) k.
15:19:31 <lambdabot> (Ord k, Monad m) =>
15:19:31 <lambdabot> k -> Data.Map.Map k a -> m a
15:19:33 <Dfhaii> thanks for help, will have a go, and may return if i canna figure it out
15:19:33 <dons> and consider, for example: http://shootout.alioth.debian.org/gp4/benchmark.php?test=pidigits&lang=ghc&id=3
15:19:37 <palomer> lookup also bothers me
15:19:40 <dcoutts> ulfdoz, any monad you like.
15:19:43 <dons> it's the 2nd fastest, but also 2x shorter than anything else
15:19:53 <dons> and I think it's lovely :)
15:19:55 <palomer> how does it create an instance of m a?
15:20:07 * jyp can't keep up with the channel rate
15:20:08 <ulfdoz> dcoutts: What from does it determine what I like?
15:20:09 <dcoutts> palomer, instance Monad Foo where ...
15:20:19 <dcoutts> ulfdoz, from the context
15:20:27 <dcoutts> ulfdoz, by type inference
15:20:51 <jyp> dons: I sure agree.
15:20:54 <palomer> dcoutts: that creates an instance of Monad Foo
15:20:56 <dons> this is another nice one: http://shootout.alioth.debian.org/gp4/benchmark.php?test=message&lang=ghc&id=0
15:21:15 <dcoutts> palomer, no it makes Foo an instance of Monad
15:21:16 <ulfdoz> dcoutts: Sounds like real autoMAGIC.
15:21:35 <palomer> dcoutts: sure, and then you return a value of Foo, right?
15:21:38 <dons> again the shortest, and 3rd fastest
15:21:44 <jyp> dons: My "dream" is that we'd be able to move the optimisations down into the compiler so the code would be neat and fast for every benchmark :)
15:21:47 <dcoutts> ulfdoz, it's perfectly well defined. You can read about the type inference and type classes.
15:22:15 <dons> jyp, i think this is doable, if we have packed strings. the 2 or 3 ugly entries would disappear
15:22:30 <dons> and a mutable array interface that's super-fast.
15:22:44 <Philippa> ulfdoz: if you buy ordinary Hindley-Milner, the type class bit is mostly just collecting constraints on type variables
15:23:14 <dcoutts> palomer, right, if you use the return value of lookup as if it were a Foo, then you're using the lookup with the type: k -> Data.Map.Map k a -> Foo a
15:23:22 <palomer> dcoutts: right!
15:23:32 <palomer> dcoutts: but this doesn't generalize to all typeclasses!
15:23:40 <dcoutts> huh?
15:23:49 <palomer> because we defined a particular instance of Monad, namely Foo
15:23:53 <palomer> and then returned a value of Foo
15:23:58 <palomer> which is not a value of Maybe
15:24:01 <jyp> I think I should add a note to lookup saying that m can be Maybe :)
15:24:20 <Philippa> palomer: it does within Haskell 98. Outside the language, that's not our problem (unless we use badly-documented extensions ;-)
15:24:25 <jyp> 3rd time I see the question in 10 days or so...
15:24:29 <dcoutts> palomer, no it's the type which you use the return type as, which determines what exactly the return type is!
15:24:45 <dcoutts> palomer, so you can use it for any Monad type you like, Maybe, etc.
15:24:52 <Philippa> jyp: it was List I shot myself in the foot with most. Forgetting to return's a PITA
15:25:28 <dcoutts> palomer, the lookup function doesn't know exactly what monad type it's using. It can work with any monad the caller chooses.
15:25:48 <palomer> dcoutts: ok, and how does it create a value of that type?
15:25:58 <jyp> the perfect application for dcoutts idea
15:26:02 <dcoutts> palomer, so which monad we're using is resolved when you call the function.
15:26:15 <jyp> (linksto wiki)
15:26:25 <Philippa> palomer: using appropriately generic functions
15:26:29 <dcoutts> palomer, using other functions that return/construct that type.
15:26:33 <palomer> dcoutts: oh, I see
15:26:37 <palomer> yes yes, makes sense
15:26:41 <Philippa> for example, return works for any monad
15:26:54 <ulfdoz> So what Monad would it choose for Data.Map.Lookup key >>= putStrLn?
15:26:58 <dcoutts> palomer, in this case it'll be the functions from the monad type class.
15:27:06 <dcoutts> ulfdoz, IO
15:27:12 <dcoutts> @type Data.Map.Lookup key >>= putStrLn
15:27:14 <lambdabot> Not in scope: data constructor `Data.Map.Lookup'
15:27:14 <lambdabot>  
15:27:14 <lambdabot> <interactive>:1:16: Not in scope: `key'
15:27:21 <dcoutts> @type Data.Map.Lookup "foo" >>= putStrLn
15:27:22 <lambdabot> Not in scope: data constructor `Data.Map.Lookup'
15:27:30 <dcoutts> @type Data.Map.lookup "foo" >>= putStrLn
15:27:31 <lambdabot>   Couldn't match `(->) (Data.Map.Map [Char] Char)' against `IO'
15:27:31 <lambdabot>   Expected type: [Char] -> Data.Map.Map [Char] Char -> b
15:27:39 <Philippa> ulfdoz: IO, because putStrLn only works with IO
15:27:45 <xerox> @type Data.Map.lookup `liftM` putStrLn
15:27:46 <lambdabot> Not in scope: `liftM'
15:27:52 <Philippa> if it doesn't have to choose, it won't - it'll just collect any necessary constraints
15:27:53 <xerox> @type Data.Map.lookup `Control.Monad.liftM` putStrLn
15:27:55 <lambdabot>   No instance for (Ord (IO ()))
15:27:55 <lambdabot>   arising from use of `Data.Map.lookup' at <interactive>:1:0-14
15:28:01 <xerox> Well, whatever
15:28:38 <dcoutts> @type Data.Map.lookup Data.Map.empty "foo" >>= putStrLn
15:28:40 <lambdabot>   Couldn't match `Data.Map.Map (Data.Map.Map k a1) a' against `[Char]'
15:28:40 <lambdabot>   Expected type: Data.Map.Map (Data.Map.Map k a1) a
15:28:40 <xerox> @type \x m -> Data.Map.lookup x m `liftM` putStrLn
15:28:41 <lambdabot> Not in scope: `liftM'
15:28:50 <xerox> @type \x m -> Data.Map.lookup x m `Control.Monad.liftM` putStrLn
15:28:51 <lambdabot>   No instance for (Monad ((->) (IO ())))
15:28:51 <lambdabot>   arising from use of `Data.Map.lookup' at <interactive>:1:8-22
15:28:55 <xerox> Nah.
15:28:59 <xerox> @type Data.Map.lookup
15:29:00 <lambdabot> forall a (m :: * -> *) k.
15:29:00 <lambdabot> (Ord k, Monad m) =>
15:29:00 <lambdabot> k -> Data.Map.Map k a -> m a
15:29:05 <xerox> Woo.
15:29:15 <xerox> @type \x m -> Data.Map.lookup x m >>= putStrLn
15:29:16 <lambdabot> forall k. (Ord k) => k -> Data.Map.Map k String -> IO ()
15:30:13 <dcoutts> @type Data.Map.lookup "foo" Data.Map.empty >>= putStrLn
15:30:14 <lambdabot> IO ()
15:30:16 <dcoutts> yay!
15:30:41 <ulfdoz> I think, I got it.
15:30:54 <dcoutts> ulfdoz, so there we go. (We couldn't remember the order of the args :-) )
15:31:08 <glasse> Excuse the newbie question. I understand that Maybe lets you programatically check if something is there or not. But I know that this function will always return something of type Just a. Is it bad style to write a function to un-Maybe something?
15:31:24 <ncalexan> glasse: fromJust.
15:31:37 <SamB> glasse: no!
15:31:41 <SamB> in fact:
15:31:51 <jyp> except that the error might be difficult to track
15:31:57 <dcoutts> ulfdoz, so because >>= requires that both actions be in the same monad, and putStrLn is in the IO monad, then it constrains lookup to use that monad too.
15:32:00 <SamB> @type Data.Maybe.fromJust
15:32:01 <jyp> if ever Nothing is returned
15:32:01 <lambdabot> forall a. Maybe a -> a
15:32:06 <glasse> Wow, thanks a lot!
15:32:22 <jyp> > Data.Maybe.fromJust Nothing
15:32:23 <lambdabot> Add a type signature
15:32:27 <Philippa> glasse: IMO it's bad style to do it without at the very least noting that you've just required that invariant be maintained
15:32:35 <ulfdoz> dcoutts: Yeah, now it is really easy to understand. Thanks.
15:32:38 <SamB> glasse: if you aren't positive it will always return a Just, you can use fromMaybe
15:32:39 <jyp> > Data.Maybe.fromJust (Nothing :: Maybe Int)
15:32:41 <lambdabot> Exception: Maybe.fromJust: Nothing
15:33:06 <dcoutts> glasse, it's common to do: case valueThatMightBeNothing of { Nothing -> error "some sensible error message"; Just a -> doSomethingWith a }
15:33:34 <xerox> > Just (error "foo!") >>= ()
15:33:35 <lambdabot>   Expecting a function type, but found `()'
15:33:35 <lambdabot>   Expected type: a -> Maybe b
15:33:35 <lambdabot>   Inferred type: ()
15:33:40 <SamB> > Data.Maybe.fromMaybe (error "foo") Nothing :: Int
15:33:42 <lambdabot> Exception: foo
15:33:46 <xerox> > Just (error "foo!") >>= error "bar!"
15:33:48 <lambdabot> Add a type signature
15:33:54 <xerox> > Just (error "foo!") >>= error "bar!" :: Maybe ()
15:33:55 <lambdabot> Exception: bar!
15:33:58 <glasse> OK. Thanks a lot.
15:34:37 <jyp> xerox, you're confusing me :)
15:34:48 <ulfdoz> glasse: Basically there is no evil, to extract the data from the wrapper type, I think.
15:35:05 <SamB>  > Just (error "foo!") >>= return "bar!"
15:35:05 <SamB> > Just (error "foo!") >>= return "bar!"
15:35:07 <lambdabot> Couldn't match `Maybe b' against `[Char]'
15:35:08 <jyp> ask Connor Mc Bride about it :)
15:35:39 <xerox> jyp: sorry.
15:36:02 <jethr0> moin moin
15:36:26 <Philippa> ulfdoz: it's only the IO monad that works like that
15:36:35 <Philippa> for all other monads, you /need/ to be able to get values out for them to be interesting
15:36:56 <Philippa> in the case of Maybe, you know the type's structure and can just pattern-match away :-)
15:37:12 <lispy> @type ($!)
15:37:13 <lambdabot> forall b a. (a -> b) -> a -> b
15:37:28 <lispy> @index ($!)
15:37:29 <lambdabot> Prelude
15:37:35 <lispy> @doc Prelude
15:37:36 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
15:38:03 <lispy> oh hm...
15:38:22 <lispy> that would explain why Diff.smart_diff in darcs is strict
15:38:55 <Philippa> is $! defined in terms of seq?
15:39:03 <lispy> Philippa: the docs say yes
15:39:11 <lispy> "Strict (call-by-value) application, defined in terms of seq."
15:39:40 <jyp> f $! x  = x `seq` f x
15:40:00 <jyp> (Prelude.hs, line185)
15:40:21 <dons> @yow
15:40:22 <lambdabot> ... I don't like FRANK SINATRA or his CHILDREN.
15:40:30 <lispy> @keal
15:40:31 <lambdabot> someone needs to write a boids for haskell that emulates humans going on
15:40:31 <lambdabot> and off topic
15:40:41 <jyp> @vixen . keal
15:40:41 <lambdabot> I will NOT be ignored...
15:41:00 <lispy> @vixen =<< keal
15:41:01 <lambdabot> If I was looking for anonymous casual sex, I wouldn't be sitting here
15:41:01 <lambdabot> behind my computer talking to you!
15:41:08 <lispy> ;)
15:41:12 <jyp> rofl
15:41:44 <psi> haha
15:41:59 <jethr0> i see you've been busy working on lambabot :)
15:42:09 <SamB> @vixen =<< yow
15:42:11 <lambdabot> I will NOT be ignored...
15:42:18 <jyp> too bad we don't see keal lines
15:42:47 <jyp> well... good nights everyone.
15:42:53 <Dfhaii> :'(
15:44:32 <SamB> @vixen =<< yow
15:44:33 <lambdabot>  key
15:44:45 <SamB> @eliza =<< yow
15:44:46 <lambdabot> =<< yoW
15:44:55 <jethr0> hmm
15:45:00 <lispy> i'm pretty sure vixen ignores arguments
15:45:03 <SamB> @eliza yow
15:45:04 <lambdabot> yOw
15:45:19 <SamB> lispy: no it doesn't
15:45:27 <SamB> @vixen what do you think of Haskell?
15:45:28 <lambdabot> church is my favourite computer scientist.
15:46:57 <lispy> heh
15:47:36 <SamB> @vixen do you like Haskell programmers?
15:47:37 <lambdabot> church is my favourite computer scientist.
15:48:11 <Dfhaii> i have tried to write a function which replaces the first item in a pair with one
15:48:20 <SamB> @vixen HOT
15:48:21 <lambdabot> you sir are no gentleman
15:48:33 <SamB> @vixen cold
15:48:34 <lambdabot> oh, well, bundle up tight :)
15:48:35 <Dfhaii> i have > replaceWithOne :: (int, string) -> (int, String)
15:48:57 <Dfhaii> > replaceWithOne (_, y) = (1, y)
15:48:59 <lambdabot>  parse error on input `='
15:49:15 <dons> > let replaceWithOne (_, y) = (1, y) in replaceWithOne (7,3)
15:49:16 <lambdabot> (1,3)
15:49:16 <SamB> @pl \(x, y) -> (1, y)
15:49:17 <lambdabot> (,) 1 . snd
15:49:56 <Dfhaii> crackin
15:50:24 <Dfhaii> SamB, can i use that lambda expression in map such as map (\(x,y) -> (1, y)) theList
15:51:09 <dons> > map ((,) 1 . snd) [(7,2),(8,3)]
15:51:10 <lambdabot> [(1,2),(1,3)]
15:51:45 <Dfhaii> thanks alot people
15:51:46 <Dfhaii> :D
15:59:19 <skew> Is there any way to get the type of an expression in TH?
15:59:57 <dcoutts> skew, no :-(
16:00:11 <skew> then why are the contents of a quasiquote typechecked?
16:00:23 <dons> hmm. why does Clean: import StdEnv, LanguageShootout
16:00:26 <dcoutts> skew, because they can be
16:00:27 <dons> very suspicious...
16:00:54 <skew> main = LanguageShootout.unreadableOptimizedBenchmark1?
16:01:01 <dcoutts> skew, getting the type would be rather tricky apparently. So says SPJ.
16:01:26 <skew> I was writing something like a rudimentary version of this: http://cs-www.cs.yale.edu/homes/dvm/format-stinks.html
16:01:27 <dons> skew, yeah. that's very odd, isn't it..
16:01:35 <SamB> what I want to know is why are the contents of [t| |] supposed to be of kind *?
16:01:42 <jethr0> dcoutts, well, if TH had access to the type checker. but that would open a whole can of worms with regards to cyclic dependencies, i guess
16:01:53 <skew> I had to make class G a where g :: a to get around it
16:02:26 <dcoutts> jethr0, I believe so.
16:02:38 <skew> brackets like [|g "A string " (reverse htiw) " " (show 2) " things interpolated"|]
16:02:54 <skew> Nemerle does something like that
16:02:54 <dons> hmm, Oberon: IMPORT Shootout, Out;
16:03:52 <Korollary> lol
16:04:35 <SamB> dons: you'd think that stuff would be against the rules
16:04:47 <skew> what is that module?
16:05:10 <skew> The Nemerle macro system is pretty interesting
16:05:19 <skew> macros can specify what stage of typechecking they want in at
16:05:21 <dons> I was just looking at: http://shootout.alioth.debian.org/gp4/benchmark.php?test=fannkuch&lang=ooc&id=0
16:06:11 <skew> I don't see anything being used from that module
16:06:47 <skew> A Nemerle macro can say it wants to run before the class hierarchy is fixed, so it can inject superclasses and such, or after so it can use reflection to walk it
16:06:56 <dons> BEGIN
16:06:57 <dons>    n := Shootout.Argi();
16:07:37 <jwp> Is there a standard class that specifies serialization/parsing interfaces? (I'm structuring the elements(messages) of a binary protocol and specifying how they are parsed from the wire and serialized onto it).
16:08:21 <SamB> jwp: someone wanted to make parse/print bi-arrow thingy
16:38:05 <edwinb> hello carp
16:40:58 <carp> hi
16:41:37 <lambdabot> Haskell Weekly News: January 16, 2006 is out now!
16:42:10 <RemiTurk> good night everybody
16:44:08 <edwinb> carp: I've just had mail from Conor telling me about today's epigram hacking. Sounds like it's going well...
16:44:36 <carp> yeah, 2+2 :)
16:44:42 <edwinb> hoorah! ;)
16:44:55 <edwinb> it's always nice to get the advanced maths going.
16:45:16 <carp> :)
16:47:46 <carp> how much more kit would we need to have to hook up your compiler?
16:48:28 <carp> i'm presuming that that would require a not insignificant amount of work!
16:48:31 <edwinb> I'd tell you if I'd been following...
16:48:38 <edwinb> I'm not sure it'd be too bad, to be honest.
16:48:57 <edwinb> I think I'm probably duplicating some of the work you're doing anyway at the minute.
16:49:39 <edwinb> I'm hacking a theorem proving api in haskell, which I'd ultimately want compiled...
16:49:52 <palomer> which logic?
16:49:55 <carp> cool
16:50:22 <edwinb> it's dependent type theory, roughly the same type theory as epigram.
16:50:53 <palomer> so, terms in your types?
16:50:57 <edwinb> yes
16:51:05 <palomer> higher order unification
16:51:07 <palomer> fun fun fun
16:56:29 <palomer> alpha/beta/eta equality between terms?
16:57:13 <edwinb> alpha/beta. could add eta, haven't had need for it though.
16:57:37 <edwinb> haven't needed higher order unification, come to think of it...
16:58:05 <palomer> can you quantify on terms?
16:58:40 <edwinb> like forall bindings?
16:58:47 <palomer> yeah
16:58:48 <palomer> and exists
16:58:50 <edwinb> yes
16:58:55 <palomer> and on predicates?
16:58:56 <edwinb> you can add exists as an inductive type
16:59:08 <edwinb> this is all part of the type theory, yes.
16:59:56 <palomer> as soon as you can quantify on predicates, you need higher order unification
17:00:01 <edwinb> I'm using it as a core type theory for some work on resource bounded computation, but it seemed like it might be fun to export an API too.
17:00:07 <edwinb> oh, i expect I will eventually.
17:19:29 <glasse> I'm writing a program that looks at all possible ways to play out a solitaire game. It runs very slow because it's a big space to explore, but I've been trying to speed it up. I profiled it and found that the function responsible for 60% of the runtime is a function which creates a list by replacing an item from another list. I use this to create new game states -- I move one card from one stack to another stack, so I need to splice n
17:19:29 <glasse> ew stacks into the old stack list.
17:20:06 <glasse> I tried to use IntMaps and Arrays instead, but then this takes even longer, because I make a call to nub in order to keep the number of game states down. Is there some way I can make both of these operations fast?
17:20:15 <dons> can you use an array instead?
17:20:21 <dons> ah. hmm.
17:21:06 <dons> use one of the standard search space pruning /search algos from AI, rather than nub?
17:21:36 <dons> write your own nub on arrays?
17:22:14 <dons> nub is only about 4 lines, you could rewrite an array versoin
17:22:34 <glasse> It's not doing a nub on the arrays, it's doing a nub on a list of the arrays. So I don't know how much I could improve that.
17:23:23 <glasse> I was thinking about using a different search algorithm, but in the worst case it still has to check all game states, and I was hoping that the nub would cut down on the time to do that.
17:23:40 <Korollary> when you do a nub on a list of arrays, does it reconstruct a new list of arrays?
17:24:27 <lispy> is there e away to tell the GC in ghc to run?
17:24:42 <lispy> (in the IO monad, of course)
17:25:56 <glasse> Korollary: I think so
17:25:57 <dons> @index performGC
17:25:58 <lambdabot> System.Mem
17:26:09 <lispy> dons: thanks
17:26:15 <lispy> @doc System.Mem
17:26:16 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Mem.
17:26:16 <lambdabot> html
17:26:54 <Korollary> glasse: that sounds expensive as well. You may have to switch to a dict or array of arrays.
17:28:03 <glasse> Korollary: Hmm. I'll try it. Thanks.
17:31:38 <Korollary> glasse: what criteria are you using to eliminate those arrays?
17:32:51 <glasse> Korollary: Each Game is a list of 10 arrays of stacks. I'm removing duplicate Game states, where duplicate Game states are defined as those with arrays that compare equal.
17:33:07 <glasse> Korollary: arrays of cards, not arrays of stacks, sorry.
17:33:17 <Korollary> Use Data.Set then
17:33:21 <Igloo> Why a list?
17:33:58 <glasse> Igloo: It hadn't occurred to me to use something else.
17:34:06 <glasse> Korollary: I'll look into it, thanks.
17:34:43 <Igloo> Well, it depends what you want to do with it, but an array might be better
17:34:58 * Igloo is somewhat confused by what the problem is, though
17:35:18 <glasse> Igloo: Ack, I messed up all over. Let me start over.
17:35:25 <glasse> Each Game is an array of 10 lists of cards.
17:36:12 <glasse> I used the Array (//) function to splice new stacks in.
17:36:40 <glasse> But doing a nub on the Arrays of lists seems to be slower than doing a nub on the lists of lists that I had before.
17:38:14 <glasse> Korollary: Correct me if I'm wrong, but Data.Set stores them in order, right? I don't think that'll help, because I access them by index -- stacks 2..5 are the foundations, for instance.
17:39:00 <Korollary> glasse: Ah. I recommended Set because of its uniqueness guarantee.
17:39:20 <glasse> Korollary: Oh, a set of Games? Let me think about that.
17:39:31 <Korollary> maybe you want multiple sets if some sets have a special meaning?
17:48:51 <lispy> after ghc mallocs memory for my program and my program is done with the memory, does ghc free the memory or just return it to a pool?
17:49:01 <lispy> is there any way to control that...
17:58:31 <palomer> pfft, my prof gave us an assignment, and the final question of the assignment is "type checking"
17:58:44 <palomer> however, the question is about type inference
18:41:54 <jargon> bioooooo
18:41:58 <jargon> dome
18:44:29 <glasse> Is there any reason Data.Set.fromList should ever hang?
18:44:57 <Korollary> it shouldnt hang. Is it a huge list?
18:45:05 <glasse> No, two elements.
18:45:07 <cpatrick> it will hang if the list is infinite
18:45:23 <glasse> It's definitely finite.
18:46:27 <Keal> will it return [] if map gives fpu infinite list?
18:48:08 <dons> please don't start on the fpu stuff, Keal
18:48:20 <Keal> it serious q
18:48:34 <glasse> Korollary: Never mind, the bug is in my (<)
18:48:40 <glasse> Korollary: Thanks anyhow.
18:48:48 <Korollary> glasse: np
18:52:35 <Keal> the following is a curious series... > let fl = fromIntegral. floor; inf = 4; epsilon = 1/inf; dv = [inf,(inf-epsilon)..0]; db = [2..inf]; dp = [(-inf),(-inf+epsilon)..inf]; digit (v,b,p) = floor( b*(fl (v/b**p)/b - fl(fl (v/b**p)/b))) in map digit [ (v, b, p) | v <- dv, b <- db, p <- dp]
18:56:45 <Keal> my very first computer was an  80-0840
18:59:33 <lispy> Keal: in your case, you most likely get [] because one of your lists is []
19:00:21 <Keal> ?
19:00:38 * Keal looks at lispy like he sprouted antennae and green skin
19:00:48 <dons> stay on topic today Keal, or you will be banned
19:18:08 <dons> hmm, n-body broke: http://shootout.alioth.debian.org/benchmark.php?test=nbody&lang=ghc&id=2
19:24:31 <dons> musasabi, could it be optc-O3 killing the nbody benchmark? both broke.
19:24:52 <Keal> dons
19:24:55 <dons> @seen musasabi
19:24:56 <lambdabot> musasabi is in #haskell-overflow, #haskell-blah and #haskell. Last spoke
19:24:56 <lambdabot> 7 minutes and 6 seconds ago.
19:25:28 <Keal> dons how do i have haskell convert a series of integers into an expression?
19:25:50 <Keal> need 1 to do a while 0 does !a
19:26:02 <musasabi> dons: I think it was a bad run of the benchmarks.
19:26:20 <dons> ah, ok. really?
19:26:36 <dons> oh, they've run with -optc-O3 before, and been ok, haven't they?
19:26:54 <musasabi> Yes.
19:27:08 <musasabi> -fglasgow-ext was new, -optc-O3 has been for some time.
19:27:10 <Keal> dons need 1 to do a while 0 does !a
19:27:16 <dons> Keal, I think you're trying to do a map. or you can write an explicit loop with recursion. check the learner info on the haskell website.
19:27:21 <dons> do not repeat yourself.
19:27:23 <dons> @learn
19:27:24 <lambdabot> http://www.haskell.org/learning.html
19:27:42 <musasabi> dons: I say we wait if it is fixed in a later run.
19:27:56 <dons> yep. ok.
19:28:16 <musasabi> if it persists then we have a ghc/gcc bug (and probably depends on the version of both)
19:28:39 <dons> i've written a new n-body, just profiling it now.
19:29:25 <dons> yep. i've had segfaults with -optc-O3 in the past. very dependent on gcc versions. and OS.
19:30:36 <dons> (which is why I assumed gcc was at fault ;)
19:31:01 <Keal> what is an n-body?
19:32:05 <musasabi> Keal: http://shootout.alioth.debian.org/benchmark.php?test=nbody&lang=ghc&id=2
19:32:12 <Keal> already saw that
19:32:52 <dons> try google.
19:33:21 <Keal> wouldnt an elliptic orbit foul n-body up?
19:33:25 <wchogg> How hard is it to write code for the different benchmarks?  Is it something I could try for Haskell practice?
19:34:22 <dons> wchogg, it's not hard to solve them. to be as competitive as C takes a little practice
19:35:12 <wchogg> dons:  Thanks.  I think I should probably  try a few then.
19:35:42 <wchogg> Why is it though that the memory usage for the Haskell programs is pretty high sometimes?  Are those spaceleaks?
19:36:24 <dons> it is possible to cause excessive memory allocation, a spaceleak, yes. in general, haskell is very tight on memory though.
19:37:37 <Keal> dons would an elliptic orbit run an n-body afoul?
19:37:43 <wchogg> When you say "tight", you mean good at managing memory or that it runs out easily?
19:37:46 <dons> Keal, don't repeat yourself.
19:38:01 <dons> wchogg, it is good. it's ranked 9th currently in least memory usage.
19:38:02 <Keal> i waited a whole damn screen dons
19:38:25 <dons> Keal, I don't have to answer every dumb question, ok. i'm not paid to listen to your crap.
19:38:44 <Keal> so you do not understand your own project?
19:38:54 <wchogg> Yeah, I actually just checked and now there's only a few programs that have significantly higher memory usage than c.  I seem to remember it not even being close last month!
19:39:40 <SamB> Keal: of course, if you payed for our first-class tech support contract, dons *would* be paid to listen to your crap!
19:40:00 <SamB> he wouldn't necessarily have to do anything about it, though
19:40:11 <wchogg> Ooh...how much is that contract?
19:40:17 <palomer> I have two datatypes, which are incidentally called Type
19:40:18 <wchogg> Can I pay in karma?
19:40:26 <Keal> i am paid to answer any question you ask, however i am not required to answer it, i still get paid
19:40:26 <palomer> simpleType and polymorphicType
19:40:35 <palomer> and polymorphicType has one more constructor
19:40:48 <palomer> Hole IORef (Maybe Type)
19:41:01 --- mode: ChanServ set +o dons
19:41:05 <SamB> wchogg: you don't need one; anyway, what crap?
19:41:11 <Keal> hrm
19:41:16 <palomer> what's the best way to represent these two datatypes?
19:41:28 * palomer sometimes wishes he had inheritance for this kind of stuff
19:41:38 <palomer> I don't want to copy code
19:41:49 <Cale> palomer: Hole IORef (Maybe t)
19:42:28 <palomer> Cale: hmm?
19:42:44 <Cale> You want to treat the two Type types the same?
19:42:57 <palomer> Cale: I really want to treat one type as  a subtype of the other
19:43:05 <Cale> What operations apply to them both?
19:43:26 <Cale> You can make a class of which they will be instances.
19:43:43 <palomer> but I don't want to have to copy the constructors twice
19:43:49 <palomer> and have to name them differently, too
19:44:07 <Cale> Well, yes, everything has to be named differently, that's no big deal
19:44:14 <palomer> I'll only write one function which will apply to both
19:44:21 <Cale> But you can write polymorphic code
19:44:23 <palomer> but I want more type safety
19:45:03 <palomer> hrm, I guess the best idea is to put "isNotPolymorphic" checks everywhere
19:45:12 <Cale> isNotPolymorphic?
19:45:45 <palomer> yeah, sometimes I know that a function will not return a polymorphicType
19:45:52 <palomer> and I want the compiler to check this
19:46:43 <Cale> Well, can't you use a typeclass to say when you want to work with both, and specify a single one where it is appropriate?
19:47:27 <palomer> still, I much rather not have to name the constructors differently
19:47:59 <Cale> write abstract constructors and make them members of the typeclass
19:48:06 <palomer> and I would still have to change the other if I change either
19:48:20 <Cale> why?
19:48:20 <palomer> hmm?
19:48:39 <SamB> GADT!
19:48:39 <palomer> because polymorphicType and simpleType differ only in one constructor
19:48:44 * SamB teases
19:49:19 <Cale> palomer: exactly how do they differ?
19:49:33 * lispy thought SamB was serious
19:49:33 <Cale> can't you factor that difference out into a parameter?
19:49:38 <palomer> polymorphic type has one more constructor: Hole (IORef Maybe)
19:49:50 <SamB> well, it could work, but I don't see palomer liking the idea
19:49:51 <Cale> ah, okay
19:49:53 <palomer> Hole (IORef Maybe PolymorphicType)
19:51:22 <Cale> okay, so that's probably not too suitable for abstraction through a type parameter
19:51:31 <Cale> but the typclass idea works fine
19:51:35 <Cale> type*
19:52:01 <palomer> how would it work?
19:52:22 <ptolomy> Anybody know what Dons's pretty.hs does?
19:52:31 <Cale> You figure out what operations you need common to both types, and you add them to a typeclass, and make both types instances of that
19:52:44 <lispy> ptolomy: no, but i was tempted to type itin
19:53:01 <ptolomy> if I decide I'm not going out tonight, I'll have to try to figure it out before I run it.
19:53:15 <Cale> pretty.hs?
19:53:44 <ptolomy> the word "writeFile" is in there, so I'm not running it until I've figured it out.
19:53:46 <Cale> oh, (???) etc
19:53:48 <lispy> Cale: i'd fetch you a link but i just closed that window :(
19:53:55 <ptolomy> Cale, http://www.cse.unsw.edu.au/~dons/pretty.html
19:54:00 <Cale> yeah, that one
19:55:08 <Keal> explain to me nbody.
19:55:13 <Keal> it looks to simple
19:56:02 <SamB> @type uncurry print
19:56:03 <lambdabot>   Expecting a function type, but found `IO ()'
19:56:03 <lambdabot>   Expected type: a -> b -> c
19:56:14 <Keal> i think i know what code does but n-body code looks to simple to actually do it
19:56:31 <SamB> @type curry print
19:56:33 <lambdabot> forall a b. (Show (a, b)) => a -> b -> IO ()
19:57:13 <lispy> Keal: let's start with what you think it does
19:57:36 <Keal> looks like it takes a multitude of vectors and applies g of each among them
19:59:06 <lispy> i've actually never looked at it :)
20:00:25 <lispy> haskell has a curry function, but no haskell function!?!
20:01:55 <wchogg> lispy-What would a haskell function do?  Would it be like Lisp's eval?
20:01:58 <SamB> okay, I replaced writeFile with curry print, and now I know what it does ;-)
20:02:25 <lispy> wchogg: good question
20:02:55 <Korollary> Curry denies to have invented currying anyways.
20:02:59 <Korollary> *denied
20:03:13 <SamB> perhaps it sorts or something first?
20:03:15 <palomer> why can't typeclasses have constructors?
20:03:15 <dons> it was schonfinkel
20:03:16 <Korollary> Schonfinkel
20:03:33 <wchogg> Curry didn't curry?  Does that mean he uncurried?
20:03:35 <palomer> constructors as members, rather
20:03:46 <palomer> that would _rock_
20:03:53 <wchogg> palomer: What do you mean, constructors as members?
20:04:14 <SamB> was it just named after curry because schonfinkel doesn't sound good to eat?
20:04:18 <wchogg> Oh, never mind.  I get it.
20:04:35 <wchogg> Sam-That sounds reasonable.  I wouldn't want to schonfinkel my function.
20:04:50 <SamB> palomer: you mean like views or something?
20:04:56 <wchogg> ...that sounds like some sortof geeky euphemism, doesn't it?
20:04:57 <palomer> views?
20:05:04 <Cale> Regardless of who invented it, it's the sort of thing one would have to be cautious about claiming.
20:05:05 <palomer> I want to be able to pattern match against typeclass members
20:05:23 <Korollary> It was misattributed to Curry, which is not the end of the world, really.
20:05:27 <Cale> palomer: well, you can't do that, but you can write yourself equivalents
20:05:52 <palomer> Cale: is there a theoretical reason why you can't do this?
20:06:03 <palomer> I think this would be _very_ useful
20:06:21 <Cale> palomer: just that you can't define your own constructors
20:06:30 <palomer> Cale: ?
20:06:44 <Cale> (aside from those introduced by a data declaration)
20:06:49 <Keal> perhaps they misattributed it to Tim Curry? :D
20:07:07 <palomer> Cale: yeah, let's say you did
20:07:33 <palomer> typeclass a where constructor b :: Int -> a
20:08:03 <palomer> then you could do instance a foo where b = Bar
20:08:11 <palomer> B = Bar, rather
20:08:23 <Keal> i'm sorry i missed whoever said wtf n-body does >.<
20:08:42 --- mode: ChanServ set -o dons
20:08:50 <Cale> oh, you can do that
20:09:00 <Cale> you just can't pattern match with little b
20:09:25 <Cale> In fact, I suggest that you do that
20:09:46 <palomer> Cale: nono, I'm suggesting an enhancement to haskell
20:10:16 <palomer> constructor B :: Int -> a
20:11:13 <Cale> yeah, I suppose that would be possible
20:11:56 <Cale> If you want to go farther you end up with something like views or laws.
20:12:36 <lispy> i compiled with profiling, profilied it, but hp2ps generated an empty graph :(
20:13:25 <Cale> is your profiling output nonempty?
20:13:31 <palomer> views? laws?
20:13:33 <palomer> sounds exciting
20:13:34 <Cale> how did you run the program?
20:13:57 <Cale> http://www.haskell.org/development/views.html
20:14:04 <dons> lispy, perhaps you need to tweak the sample rate?
20:14:13 <dons> sometimes i needed -i0.001 for hmp3.
20:14:23 <dons> (since it slept most of the time)
20:14:38 <lispy> Cale: probably empty, i changed my rts options and this time i get a graph, not that i understand it, but it's there
20:14:44 <Cale> okay
20:14:52 <lispy> dons: ah, i don't think that's my problem, it works away for quite some time
20:15:58 <lispy> this graph is almost all black and the legend says that black means, (79)linesPS,takePS
20:16:05 <lispy> any idea how i should interpret that?
20:16:40 <Korollary> lispy: you can zoom in in ghostview.
20:16:41 <lispy> i guess those functions hogged all the memory?  what is the 79?
20:16:59 <lispy> i should mention, this is a retainer graph
20:18:20 <lispy> Korollary: why would i zoom?
20:18:42 <lispy> why don't i post it so you can see it yourself :)
20:18:48 <Korollary> lispy: I thought you were having trouble seeing through the black tree of lines.
20:20:31 <lispy> http://files.codersbase.com/tmp/darcs.debug.ps
20:21:11 <lispy> at max zoom it still looks solid black to me
20:21:44 <Cale> um, yeah, there's only one item there
20:22:22 <Cale> what does ordinary profiling tell you?
20:22:35 <lispy> whatis ordinary profiling?
20:23:09 <Cale> compile with --prof --auto-all and run with +RTS -p
20:24:15 <lispy> finding out, but i doubt it will tell me much
20:24:44 <palomer> hrm, I'm doing type checking...
20:24:52 <palomer> how do we check against polymorphic types?
20:25:06 <lispy> Cale: well, i see lots of stuff, but it doesn't "tell" me much :)
20:26:27 <lispy> takePS and linesPS don't really show up as high memory consumers
20:26:38 <lispy> i wonder why they were listed as retainers
20:28:45 <SamB> lispy: maybe it reuses the buffer from the original packed string?
20:30:13 <Cale> You wouldn't need to consume a lot of memory to hold on to a pointer to something which consumes lots of memory
20:30:47 <Cale> but I haven't done lots of retainer profiling so I'm not sure exactly how it should be read
20:31:07 <Cale> plus I'm tired, goodnight!
20:31:49 <SamB> hmm...
20:31:57 <lispy> Cale: thanks, g'night
20:32:17 <palomer> night Cale
20:33:02 <Keal> do i return the highest power of two for x
20:33:20 <Keal> how?
20:33:50 <lispy> Keal: your question doesn't make sense
20:34:14 <Keal> how do i return the amount of digits
20:34:40 <lispy> > (length.show) 123
20:34:42 <lambdabot> 3
20:34:52 <Keal> using base 2
20:36:16 <Keal> not 10
20:37:02 <wchogg> lispy-So something like (length.show) is a good example of something I've wondered about.  In Haskell, does it actually do all the work of converting the type into a string and *then* calculates the length of the list of Char, or does it short circuit the process somehow and use laziness to do less work?
20:37:58 <Keal> prolly lazy since you cant say which base
20:38:35 <Keal> ockams razor
20:38:39 <SamB> wchogg: I suspect it just fuses
20:38:59 <wchogg> SamB-Fuses?  Not familiar with the term.
20:39:17 <Keal> i think it was a joke
20:39:41 <SamB> wchogg: which is to say, if length is a good consumer and show is a good producer, it will fuse... if not, it will be lazy but generate the intermediate list at some point...
20:40:21 <wchogg> How does one know, or define, what it means for something to be a good consumer or producer?
20:41:23 <SamB> it has to do with "a short cut to deforestation"
20:41:36 <wchogg> So should I read up on deforestation then?
20:41:45 <SamB> also to do with RULEs in GHC.Base and GHC.List
20:41:45 <SamB> er, RULES
20:42:12 <lispy> > let dec2bin' 0 = []; dec2bin' n = n `mod` 2 : dec2bin' (n`div`2); dec2bin n = reverse (dec2bin' n) in dec2bin 6
20:42:14 <lambdabot> [1,1,0]
20:42:19 * Keal thinks #haskell needs to take its meds
20:42:19 <SamB> wchogg: well, it will be lazy regardless
20:42:51 <SamB> wchogg: but if you want to understand what I meant about fusion then yes ;-)
20:43:01 <SamB> Keal: you need to take yours.
20:43:13 <SamB> and I need a prescription or I won't have any after tomarrow
20:43:35 <SamB> which is why I'm at 2/3 strength on mine
20:43:37 <wchogg> Yeah, I really do want to understand fusion.  Does deforestation actually rely on laziness at all or are they separate things?
20:44:21 <lispy> > let dec2bin' 0 = []; dec2bin' n = n `mod` 2 : dec2bin' (n`div`2); dec2bin n = reverse (dec2bin' n) in dec2bin 2
20:44:23 <lambdabot> [1,0]
20:44:39 <lispy> that's actually pretty handy
20:44:51 <lispy> @hoogle Int -> Char
20:44:53 <lambdabot> Data.Char.intToDigit :: Int -> Char
20:44:53 <lambdabot> Data.Char.chr :: Int -> Char
20:44:53 <lambdabot> Data.PackedString.indexPS :: PackedString -> Int -> Char
20:45:12 <wchogg> lispy-I'm not quite sure what your function is doing.
20:45:15 <lispy> > let dec2bin' 0 = []; dec2bin' n = n `mod` 2 : dec2bin' (n`div`2); dec2bin n = reverse (dec2bin' n) in read (map intToDigit (dec2bin 2)) ::Int
20:45:17 <lambdabot> 10
20:45:31 <wchogg> Oh, it's just converting.  Nevermind.
20:46:05 <lispy> > let dec2bin' 0 = []; dec2bin' n = n `mod` 2 : dec2bin' (n`div`2); dec2bin n = reverse (dec2bin' n) in read (map intToDigit (dec2bin 10000000)) ::Int
20:46:07 <lambdabot> -316484480
20:46:10 <lispy> heeh
20:46:17 <lispy> > let dec2bin' 0 = []; dec2bin' n = n `mod` 2 : dec2bin' (n`div`2); dec2bin n = reverse (dec2bin' n) in read (map intToDigit (dec2bin 10000000)) ::Integer
20:46:19 <lambdabot> 100110001001011010000000
20:47:15 <wchogg> That's a fun little function.  I wouldn't have thought of doing it that way.
20:47:36 <lispy> wchogg: well, it's based on the fastest way i know how to do it by hand
20:48:48 <lispy> dons: have you optimized linesPS specificly in FPS?
20:49:25 <dons> i don't think so. check the src if you like
20:49:59 <lispy> dons: yeah, i was already there :)
20:50:12 <lispy> dons: it looks like latest FPS lines is differenth than linesPS
20:50:33 <lispy> but maybe only superficially
20:54:29 * Keal digs
20:54:43 <Keal> its is never good when i dig. were other country i'd die.
20:56:25 <Keal> goddamn mofo's closed my p2p 
20:57:09 <dons> off topic. you need to try harder.
20:59:55 <wchogg> I've been using ghci for the first time instead of hugs, and I've been pretty impressed by the error messages I've been getting.
21:00:56 <lispy> dons: oh hm...i cut&paste'd elemIndexWord8 and i get type errors...
21:01:09 <lispy> wchogg: yeah :)
21:01:31 <wchogg> I mean, I'd be happier if I'd made no errors...
21:01:40 <lispy> Expected: IO (Ptr Word8), Inferred: Ptr a
21:02:03 <lispy> nullPtr has the wrong type i think
21:06:47 <lispy> i need better tools
21:07:02 <lispy> this is like voodoo since i don't know wwhat difference if any, my changes are making
21:07:15 <Keal> dons how to i model using haskell global climate change due to the sustained 3c change due to no airplanes in sky during aftermath of 9/11
21:07:27 <Keal> is there a prexisting weather sim?
21:08:27 --- mode: ChanServ set +o dons
21:08:43 --- mode: dons set +b *!*@ip68-99-90-191.ph.ph.cox.net
21:08:51 --- mode: dons set +b *!*n=TRK@*.ph.ph.cox.net
21:08:51 --- kick: Keal was kicked by dons (Continued off-topic trolling and provocation)
21:10:44 --- mode: ChanServ set -o dons
21:10:48 <araujo> @karma+ dons 
21:10:48 <lambdabot> dons's karma raised to 26.
21:13:03 * Korollary pops the cork
21:13:37 <wchogg> Hrmm...I guess that was enough of that?
21:14:19 <Korollary> I've been /ignore'ing
21:14:54 * araujo never understood anything from him anyway
21:15:11 <dons> wchogg, you might have missed the last 3 or 4 days of his activities.
21:15:21 <dons> oh well, at least we have @keal to remember him by
21:15:54 <araujo> I think this is the first time i see a ban in here in my 1.5 years around.
21:16:06 <dons> oh, there's been 3 or 4
21:16:27 <dons> but shapr isn't here often enough these days. he normally takes care of this stuff
21:16:30 <palomer> we don't want to ban too much
21:16:36 <palomer> or we'll end up like efnet #math
21:16:44 <wchogg> dons-No, I haven't *really* been on lately.  So he's just been a jerk?
21:16:50 <araujo> well, we don't, because we don't need it too much.
21:17:02 <Korollary> he's been plainly insane iirc.
21:17:08 <dons> wchogg, some delightful samples:
21:17:12 <dons> @keal
21:17:12 <araujo> incoherent i'd say.
21:17:13 <lambdabot> know you know this 24 periods Keal SecretTM
21:17:15 <wchogg> Well, if this is only the fourth one in the past year or so I think things are fine.
21:17:17 <dons> @keal
21:17:18 <lambdabot> when i put what i dat recoved from that tile into a ti92. the damn thing
21:17:18 <lambdabot> blew up
21:17:32 <wchogg> @keal
21:17:32 <lambdabot> endian mirrors the decimal
21:17:54 <wchogg> It's so...zen.
21:18:01 <palomer> hiding constructors is fun
21:18:04 <araujo> Too much indeed.
21:19:14 <wchogg> Sorry, I just have to do one more.
21:19:15 <wchogg> @keal
21:19:16 <lambdabot> endian mirrors the decimal
21:19:35 <wchogg> Darnit.
21:20:06 <dons> he actually stated a few times that he was playing a troll experiment. 
21:20:24 <wchogg> Oh really?  So he was just trying to annoy everyone?
21:20:35 <wchogg> So, by banning him did he succeed or fail?
21:21:18 <dons> the src of the quotes is here: http://www.cse.unsw.edu.au/~dons/code/lambdabot/Plugins/Quote.hs 
21:21:27 <araujo> haha
21:22:03 <wchogg> Thanks.  I'll skim it so I don't have to annoy people by doing the command.
21:22:15 <Korollary> come on. @keal is fun.
21:22:27 <dons> @keal is fun
21:22:28 <lambdabot> perhaps i just genius and never tested
21:22:46 <araujo> @keal
21:22:47 <lambdabot> i lack in verbal and social expression
21:22:50 <wchogg> And all these quotes were just this past week?  Geez.
21:22:57 <dons> the last couple of days.
21:23:12 <palomer> @palomer
21:23:13 <lambdabot> Unknown command, try @listcommands.
21:23:23 <palomer> damnit, why doesn't lambdabot quote me?
21:23:31 <dons> it's funny how everyone seems to think there is a @<name> for them :)
21:23:37 <dons> maybe we should write one.
21:23:53 <palomer> have a @quote command !
21:24:00 <dons> @quote palomer
21:24:01 <lambdabot> palomer hasn't said anything memorable
21:24:05 <dons> @quote shapr
21:24:06 <lambdabot>  I am hexed and vexed ;-)
21:24:15 <araujo> @quote dons 
21:24:15 <lambdabot>  boegel, stop polluting the quote-space please
21:24:24 <dons> hehe
21:24:28 <araujo> :-)
21:24:39 <palomer> and what are his criteria for selecting quotes?
21:25:02 <wchogg> @quote dons
21:25:02 <lambdabot>  but let is more lazy ;)
21:25:20 <dons> @quote
21:25:21 <lambdabot> skew says: Swapping is just a constant factor
21:25:34 <palomer> @quote
21:25:35 <lambdabot> xerox says: > take 10 lol where lol = "ol" : zipWith (:) (intersperse 'o'
21:25:35 <lambdabot> $ cycle "l") lol
21:25:45 <dons> palomer, oh, anyone can add them with @remember
21:25:51 <palomer> @remember palomer
21:25:59 <palomer> @quote palomer
21:26:23 <dons> ok, so you just gave yourself an empty quote. 
21:26:44 <palomer> @remember palomer Sorry, quoting the almighty would be blasphemous.
21:26:48 <palomer> @quote palomer
21:27:59 <dons> hmm.
21:28:05 <dons> not sure what happened there.
21:28:15 <wchogg> @quote palomer
21:28:16 <lambdabot>  Sorry, quoting the almighty would be blasphemous.
21:28:21 <wchogg> Worked for me.
21:28:26 <dons> oh, interesting.
21:32:38 <palomer> @quote palomer
21:32:43 <palomer> lambdabot hates me
21:33:05 <wchogg> That's what you get for claiming to be the almighty.
21:33:12 <palomer> hrm
21:33:12 <dons> @bot
21:33:13 <lambdabot> :)
21:33:21 <wchogg> lambdabot is no blasphemer
21:33:22 <palomer> hrm
21:33:29 <palomer> it seems typechecking is harder than type inference!
21:33:32 <palomer> @bot
21:33:33 <lambdabot> :)
21:35:10 <SamB> @quote
21:35:10 <lambdabot> ChilliX says: You need to seek a balance between category theory and
21:35:10 <lambdabot> VLSI
21:35:37 <Korollary> lol
21:35:47 <SamB> @quote
21:35:48 <lambdabot> wilx says: I mean, besides the murders, it all looks so nice.
21:45:59 <dons> ah memories: when the OCaml guys got stuck into Haskell's shootout performance: http://groups.google.com/group/fa.haskell/msg/897b4eeb37cb3d31?hl=en&lr=&c2coff=1&safe=off
21:50:16 <Korollary> although the shootout situation has much improved, strings as lists is really a luxurious choice.
21:51:30 <dons> we'll all be rich in 20 years, with our bug free list code ;)
21:51:37 <Korollary> heh
21:53:43 <Korollary> I suppose it's possible to treat a char[] like a list in library code.
21:54:25 <dons> yeah, in IO intensive code, just use packed strings. it's simple.
21:54:54 <Korollary> but then you can't use the generic map because it expects a generic string.
21:55:13 <dons> use packedstring.map
21:55:45 <dons> so much bandwidth has been wasted on the [Char] issue over the years. and it has been blamed for all the evils that have ever befallen haskell.
21:56:08 <Korollary> I don't think it's responsible for all that
21:56:44 <sethk> hey, all, I need a bit of help.
21:56:51 <dons> not responsible, no. my point is that critics use it as a target.
21:56:56 <sethk> this works:  listenOn (PortNumber 25555)
21:56:59 <sethk> but this doesn't
21:57:17 <sethk> pnum <- return (read (args !! 0))
21:57:23 <sethk> listenOn (PortNumber pnum)
21:57:44 <sethk> I've tried using :: for Word16, Word32, but the compiler barfs
21:57:45 <Korollary> args !! 0 could be the program name
21:57:46 <sethk> for example:
21:57:54 <Korollary> oops its not
21:57:56 <Korollary> my bad
21:58:00 <Lemmih> sethk: s/pnum/fromIntegral pnum/
21:58:01 <sethk> (pnum :: Word16) <- return (read (args !! 0))
21:58:14 <Lemmih> PortNum isn't an instance of Read, iirc.
21:58:23 <sethk> Lemmih, ok.  I noticed PortNumber is an instance of Integral but I didn't know what that implied
21:58:28 <Korollary> Lemmih: It's an Integer
21:59:21 <sethk> Korollary, that's what I thought.  However, fromIntegral does shut the compiler up
21:59:47 <Lemmih> Korollary: No, it's not.
21:59:50 <sethk> oh, wait, PortNumber is defined with data
21:59:59 <sethk> sorry about that
22:00:20 <Lemmih> Korollary: data PortID = ... | PortNumber PortNumber | ...; newtype PortNumber = PortNum GHC.Word.Word16
22:00:29 <Korollary> ah
22:01:51 <Korollary> @type fmap (read . head)
22:01:53 <lambdabot> forall (f :: * -> *) a. (Functor f, Read a) => f [String] -> f a
22:44:41 <Lokadin> say
22:44:54 <Lokadin> how do i find the full address of a link
22:45:03 <Lokadin> anyone here btw?
22:45:19 <Korollary> wget? curl?
22:45:29 <Lokadin> o
22:45:35 <Lokadin> :)
22:45:43 <Lokadin> thanx
22:45:48 <Korollary> np
22:45:48 <Lokadin> that should work
22:51:06 <Lokadin> oh say
22:51:32 <Lokadin> would you know where i could read something about sentance construction algorithms?
22:56:30 <dons> what are you working on?
23:03:34 <Lokadin> oh
23:03:41 <Lokadin> i wanna make a typing game
23:04:11 <Lokadin> i find it really hard to type single words
23:04:31 <Lokadin> but i think it would be easier for me to type generated sentances
23:04:52 <dons> could you use a large dictionary of phrases?
23:04:58 <Lokadin> so it would be ncurses based.
23:05:10 <Lokadin> well i could i guess
23:05:21 <Lokadin> but that wouldn't be much fun
23:05:21 <Lokadin> :(
23:05:24 <Lokadin> lol
23:05:31 <dons> otherwise, something simple like a markov chain could do it in a few lines (a la MegaMonad)
23:06:04 <Lokadin> oh okay thanks :) i'll look it up
23:15:14 <Lokadin> wow did you know that people decide if they like a website in the first 50 milliseconds?
23:15:27 <Korollary> not possible
23:16:19 <Lokadin> http://www.nature.com/news/2006/060109/full/060109-13.html
23:16:21 <Korollary> there are 3 monitor frames in 50 ms heh. Maybe the first second.
23:16:33 <Lokadin> they did a study
23:17:42 <Korollary> ah, the visual layout of the site. Not the contents heh.
23:17:57 <Lokadin> yep
23:18:11 <Korollary> I'd believe that. We're very shallow creatures.
23:18:16 <Lokadin> same
23:18:28 <Lokadin> i mean i can't stand sites with bad layout
23:18:37 <Lokadin> drives me crazy
23:18:57 <Lokadin> hmmm
23:19:54 <Lokadin> i think wired is terribly overrated
23:20:07 <Korollary> I haven't visited wired by myself in ages.
23:20:16 <Lokadin> nor i 
23:20:29 <Lokadin> i just removed the rss frome my google home
23:35:33 <Lokadin> what keyboard layout do you use?
23:50:46 <astrolabe> I often leave a website if it is taking a long time to load.
