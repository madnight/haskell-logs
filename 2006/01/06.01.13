00:00:04 <newsham> I got NewBinary but I dont see docs.  any docs?
00:00:45 * Keal angry @ dons
00:03:18 <newsham> sleep
00:16:04 <dons> @keal
00:16:05 <lambdabot> T seems to be haskell, except with a decent interface at this point
00:16:41 <lispy> dons: i love that @dons => @doc
00:17:00 <dons> ah, that's what''s happening.
00:17:26 <dons> joelk, got your patch. cheers.
00:17:59 <joelk> cool.
00:18:19 <joelk> lispy is helping me set up an MTA for next time :-)
00:18:36 <Keal> dons, i can explain why something is without knowing what the rules decided by man are. making a bot of me is highly offensive.
00:18:39 <dons> hehe. good idea if you send a lot of patches.
00:20:32 <lispy> Keal: immitation is the highest form of flattery.  just consider it flattery from lambdabot 
00:20:33 <joelk> That remains to be seen... :-)
00:20:46 <Keal> its 100% opposite of immitation
00:20:54 <Keal> i will tell you why
00:21:18 <Keal> imitation in in self is the opposite of imitating me
00:21:23 <dons> 15:27:35 <Keal> naw just seeing how offtopic i could get everyone 
00:21:56 <Keal> http://www.dinosauria.com/jdp/misc/parsimony.htm
00:22:04 <Keal> that is the way of math and science
00:22:10 <Keal> i follow not
00:22:26 * Heffalump lol @keal
00:22:34 <Keal> i do not use parsimony method
00:22:36 <Heffalump> or rather, lol @ @keal
00:23:11 <Keal> i always build from scratch
00:23:37 <Keal> every time i am to solve a word prollem
00:23:47 <Keal> since i am unable to memorize
00:24:14 <Keal> and have 167pt iq and intuition i am able to solve prollem anyway 'knowing nothing'
00:24:16 <dons> @keal
00:24:17 <lambdabot> i try make program called Glyph to do it but my script lang called T too
00:24:17 <lambdabot> slow. i invent T
00:24:54 <dons> @keal
00:24:55 <lambdabot> the fractal is 5 irrationals
00:25:02 <dons> hehe
00:34:32 * pesco yawns.
00:34:39 <pesco> Hello #haskell.
01:34:59 <JaffaCake> dons: ping?
01:42:42 <noj> a bit off topic, but does anyone know of a nice javascript interpreter, standalone, not browser-based?
01:46:09 <twb> noj: gtk-webcore has a ecmascript module...
01:46:24 <twb> I dunno how easy it is to remove from the other stuff.
01:57:49 <pesco> Igloo: ping?
02:15:08 <araujo> Good morning.
02:16:18 <pesco> araujo: Morning.
02:20:40 <dcoutts> boegel, ping
02:21:27 <araujo> Hello pesco 
02:21:31 <araujo> What's up?
02:21:55 <pesco> Trying to hunt down GHC(i) Linux/PPC crash bugs.
02:23:53 <aleator> Anyone familiar with cabal? I've got a project which I'm cabalizing and it has a c file in it. Trying to use it gives "linking ... <interactive> /usr/local/lib/<libname>: unknown symbol `<mangled name>'" 
02:24:09 * aleator feels that he has asked this before..
02:26:08 <boegel> dcoutts: pong !
02:27:06 <pesco> dons: ping?
02:28:24 <boegel> dcoutts: I've replyed to Peter, and made the adjustments he suggested... didn't test it though, no time.. but I guess some changes were made to Gtk2Hs since tmr1 ?
02:29:41 <dcoutts> boegel, yeah, some minor changes.
02:30:06 <dcoutts> boegel, actually I was wondering if you'd mind if we include your memory game in the Gtk2Hs demo collection?
02:30:24 <boegel> dcoutts: off course not, why should I ? :)
02:30:47 <dcoutts> boegel, cool. Well I needed to at least ask! :-)
02:31:05 <boegel> heh, yeah, although I don't know why I'd object against it
02:31:13 <boegel> aslong as you pay for it :P
02:31:58 <dcoutts> boegel, in English "would you mind if..." is just an extra-polite way of asking something. It doesn't literally mean that the person expects that you would object.
02:32:52 <dcoutts> it's more deferential
02:32:52 <dcoutts>  I guess
02:33:06 <boegel> I know :)
02:33:10 <boegel> still, I find it funny
02:33:18 <boegel> I'm not that polite irl ;)
02:33:25 * dcoutts grins
03:05:21 <jip> how does one add a new line in a string literal in haskell source code?
03:06:30 <magr> jip: "Hello\n World"
03:06:52 <jip> thanks but i meant breaking the line in the source file itself without adding a newline in the actual string
03:07:02 <jip> "Hello\
03:07:04 <jip> World"
03:07:49 <basbom> how can I do list comprehension with a monad function? an example. let's say i have a list of files called fs. Now I want to filter out those elements in fs that satisfy the function 'doesDirectoryExist'. Something along the lines [e | e<-fs, doesDirectoryExist e]
03:08:24 <basbom> that is i only want those files that are directories.
03:12:34 <magr> jip: not possible, IIRC
03:12:48 <jip> hm.... it's gotta be possible :O
03:12:49 <magr> "Hello\n" ++ "World"
03:17:53 <sylvan> jip, "Hello\
03:17:55 <sylvan> \wold
03:17:57 <sylvan> "
03:18:04 <sylvan> bah... you get what I mean =)
03:18:11 <chucky> sylvan: Who's wold? :)
03:18:18 <sylvan> you need two slashes
03:18:20 <sylvan> =)
03:18:34 <jip> aha, thanks man
03:23:32 <magr> lpq
03:23:45 <farre> flistugg is ready
03:23:45 <farre> no entries
03:24:02 <magr> lpq -Pflabber
03:24:12 <farre> lpq: Unknown destination "flabber"!
03:24:27 <magr> cat /etc/printcap
03:24:34 <jip> does anyone else use vim?
03:24:34 <magr> (sorry folks)
03:25:05 <farre> magr: got you ;)
03:26:23 <magr> no, got you :)
03:46:41 <musasabi> dons: starting to look at the entries.
04:06:00 <jip> anyone good with parsec?
04:15:21 <jip> i have a parser that parses and returns [(a, b)]
04:15:37 <jip> how can i convert this parser into one that returns Data.Map.Map a b?
04:20:20 <aleator> doesn't Data.Map have fromList or somesuch?
04:20:27 <dons> musasabi, just tried to ensure haskell had the least loc for some of the entries today. and noticed some missing compiler flags, iirc. feel free to use your judgement.
04:22:50 <aleator> jip: if you have parser p returning [(a,b)] then p >>= return . Map.fromList will make it return Data.Map a b
04:23:46 <jip> aleator: hm.... thanks that makes sense, and if i have to do a more complex tranformation then instead of fromList i can use my own function, right?
04:24:15 <aleator> jip: Yes. basicly.
04:25:23 <jip> coolness
04:25:30 <jip> dons: hi, any updates on that bug?
04:25:50 <JaffaCake> dons: question for you
04:26:04 <bourbaki> moin
04:26:15 <JaffaCake> dons: I'm wondering how your Dynamic support works in hs-plugins
04:26:16 <dons> JaffaCake, yep?
04:26:36 <dons> do you mean, the use of String keys instead of int keys?
04:26:46 <JaffaCake> how do you get around the problem where the client is using a different hash table from the dynamically loaded code?
04:26:54 <JaffaCake> ah, is that it
04:27:07 <dons> a hack. yep. the canonical type names.
04:27:13 <JaffaCake> you're not using a hash table, then
04:27:26 <dons> musasabi, I see our fannkuch is the same as SMLs now :)
04:27:30 <dons> JaffaCake, nope.
04:27:36 <dons> but that's what should be done.
04:27:36 <JaffaCake> right, that explains it, thanks
04:27:53 <JaffaCake> we've had a request for something similar in GHC
04:28:06 <JaffaCake> ie. the GHC API should be able to return a Dynamic for an expression you eval
04:28:26 <dons> ah. interesting.
04:28:43 <JaffaCake> it suffers from the same Dynamic problem, though
04:29:02 <dons> and just when I was going to add a ghc api-based eval.
04:29:12 <JaffaCake> heh
04:29:22 <dons> yeah, it becomes a problem in other places too. like catching DynExceptions in mixed dynamic/static code.
04:29:30 <JaffaCake> right
04:29:37 <JaffaCake> guess we should fix it properly
04:29:41 <MarcWeber> Is there some kind of regexp lib where you can also search for characters "xy" with ord(x)-ord(y)=const or something like this?
04:30:28 <JaffaCake> you really do need to make sure that the server code is running with the same base package as the client code, though - that is, the representation of types must be the same
04:30:46 <JaffaCake> actually all packages, not just the base package
04:31:05 <dons> yep.
04:31:23 <Lemmih> ADEpt: I don't really like that name of that patch.
04:33:00 <ADEpt> Lemmih: one of them I sent by accident :(
04:33:01 <ADEpt> Lemmih: the old one.
04:33:15 <ADEpt> Lemmih: you probably dont like the name of the new one, though :)
04:36:13 <ADEpt> Lemmih: what would you like more?
04:40:35 <JaffaCake> dons: http://cvs.haskell.org/trac/ghc/ticket/652
04:40:56 <dons>   yep. i see it in my mailbox :)
04:42:18 <JaffaCake> I probably should have mentioned hs-plugins, but if we fix it for GHCi it'll work for you too
04:42:34 <dons> yeah.
04:42:35 <jip> can i easily make a record type showable?
04:42:50 <Saulzar> deriving Show ?
04:50:59 <dons> I see Haskell/GHC is now 5th in the language shootout overall rankings. up another 2 or 3 places overnight :) only C, D and SML ahead.
04:52:19 <dons> and we've still got plenty of benchmarks to improve on :)
04:52:43 <dons> http://shootout.alioth.debian.org/benchmark.php?test=all&lang=all&sort=cpu
04:53:00 <JKnecht> SML = S ML of NJ?
04:53:16 <dons> MLton.
04:53:57 <JKnecht> got it.
04:55:45 <musasabi> back from lunch.
04:56:01 <musasabi> for ackerman I am submitting:
04:56:17 <musasabi> import System(getArgs)
04:56:17 <musasabi> main = putStrLn . (\n -> "Ack(3,"++n++"):"++n) . show . ack 3 . read . head =<< getArgs
04:56:20 <musasabi> ack (0::Int) (n::Int) = n+1
04:56:22 <musasabi> ack  m        n       = ack (m-1) $ if n == 0 then 1 else ack m (n-1)
04:56:41 <dons> ok. good. do we need the (getArgs) seems ugly imo.
04:57:47 <musasabi> well we can live without out.
04:58:41 <dons> opinions on other shrinkified entries?
04:59:11 <musasabi> dons: Looking at them. Would making -optc-O3 global be fine?
04:59:30 <dons> I think so. those that need -fasm (only 1 I think) can override as needed
04:59:54 <musasabi> and isn't it just ignored if -fasm is given?
05:00:02 <dons> yep.
05:00:31 <bourbaki> i am looking for an nlp parser for haskell that can deal with ambigious sentences
05:03:52 <musasabi> any reason your takfp uses "putStrLn . show" instead of "print" ?
05:04:08 <dons> ah. no!
05:04:14 <dons> :) 
05:05:16 <MarcWeber> bourbaki: nlp= neurolinguistic programming? I don't think that I can help you but I'm interested anyway.. Would you mind giving me an example sentence? What are you going to do?
05:05:31 <dons> natural language, usually.
05:07:36 <bourbaki> natrual language
05:07:40 <Philippa_> dons: at least, in a CS context
05:07:52 <bourbaki> i want to write a parser for nlp mixed with some nsm ideas
05:07:55 <Philippa_> I think I see it meaning neurolinguistic programming slightly more often
05:08:09 <bourbaki> maybe anyone is interested to listen for a sec and maybe help me programming
05:08:11 <Philippa_> bourbaki: how do you want it to deal with ambiguity?
05:08:14 <Philippa_> sure
05:08:32 <MarcWeber> I only know nlp=neurolinguistic programming, yet nl=natural language p=?
05:08:36 <Philippa_> (well, you get listening - on average it's easier to get blood from a stone than code out of me, sadly)
05:08:37 <bourbaki> sec i have an article on that just want to refine that and get that to haskell
05:08:39 <Philippa_> MarcWeber: Parsing
05:09:06 <bourbaki> http://ai-depot.com/Articles/49/Semantics.html
05:09:07 <musasabi> dons: the pidigits is really nice :-)
05:09:51 <dons> yeah, I think the structure of the algo is actually clear now.
05:09:58 <bourbaki> the idea is to take nl sentences of a specific kind and parse them extract all possible surface structures and build the same amount of closures that represent the meaning of that sentence
05:10:49 <bourbaki> the language i want to build is something like a caveman language with just a few words that though will be able to build more complex words (so its like a programming language)
05:11:07 <bourbaki> http://www.une.edu.au/arts/LCL/disciplines/linguistics/nsmpage.htm
05:11:22 <dons> i've noticed during these refactoring games that shrinking the code often tends to make it clearer, as you expose the fundamental building blocks of the algorithm
05:11:23 <bourbaki> nsm is this natural semantic metalanguage
05:11:35 <Philippa_> it looks a lot like just a standard non-det parser plus some simple list monad-style semantics?
05:11:35 <dons> i don't think this would be true in other languages, when shrinking code size.
05:11:45 <bourbaki> so there always is a semantic for these cavemen words
05:11:46 <Philippa_> heh
05:11:53 <jip> *** Exception: stack overflow
05:12:08 <Philippa_> dons: I refactored our budget yesterday, shoving a lot of the parms inside where clauses and thus lowering the global count. It's a *lot* clearer
05:12:18 <bourbaki> Philippa_: i dont know to be honest i really suck at parseing :)
05:12:19 <Philippa_> strictly speaking the code size increased, but hey
05:12:26 <jip> what should i do?
05:12:31 <bourbaki> i spell parse like pARSE
05:12:40 <Philippa_> oi! Arses good ;-)
05:12:46 <bourbaki> heh
05:13:23 <bourbaki> i thought to use that earley parser but it wont give me the surface structure
05:14:03 <Philippa_> I think the idea there is just that individual words get looked up in a map afterwards to dispatch them to functions that yield their semantics...
05:14:28 <Philippa_> I suspect someone else'll be better at explaining than I will right now though
05:14:37 <Philippa_> try porting all the lisp code as directly as you can?
05:15:06 <bourbaki> Philippa_: i have written the article :)
05:15:26 <Philippa_> ah :-)
05:15:28 <bourbaki> though i just copied the parse code cause im a lazy bastard
05:15:38 * Philippa_ nods
05:15:49 <bourbaki> i just want to write a follow up article that targets on the tactical games thingy
05:15:55 <Philippa_> ah...
05:15:58 <Philippa_> yeah, that makes some sense
05:16:01 <bourbaki> so you can talk to your teammates and give them commands
05:16:11 <Philippa_> talking more about the semantics of a teammate-abuse language?
05:16:14 <bourbaki> maybe with a circular menu
05:16:20 <bourbaki> that represents the grammar
05:16:28 <bourbaki> yes
05:16:44 <Philippa_> I'd just go build an AST for one in Haskell and sod the lispers, but then I'm like that :-)
05:17:24 <Philippa_> skip the parsing if need be, that's somebody else's problem except insofar as how you handle ambiguity. It's fair to assume that you can have lists of all possible parses at a given point
05:18:06 <bourbaki> if someone would prvide me with the parser id be super happy i found a paper on that ill read that first i guess
05:18:25 <bourbaki> the lisp code (though i think the one i upped back then is broken) is doing quite well already
05:18:33 <Philippa_> cool
05:18:37 <bourbaki> you connect a function to all terminals in the grammar
05:18:40 <Philippa_> the original article doesn't /have/ a parser
05:18:43 * Philippa_ nods
05:18:51 <bourbaki> verbs are functions and terminals are 0 arity functions
05:18:58 <bourbaki> Philippa_: the parser is in the code
05:19:11 <bourbaki> i copied it from that norvig book
05:19:14 <Igloo> pesco: ?
05:19:33 <Philippa_> ah, just not in the article itself
05:19:38 <bourbaki> right
05:19:43 <bourbaki> sec
05:19:58 <bourbaki> http://ai-depot.com/Articles/49/ps.lisp
05:20:21 <Philippa_> yeah, I can follow the link :-)
05:20:29 <bourbaki> though haskell doesnt feature dynamic functions as lisp does i think that the nsm thingy will make it more reasonable
05:20:29 <musasabi> dons: all updates done.
05:20:33 <bourbaki> sry
05:20:41 <Philippa_> I need syntax highlighting in firefox
05:20:44 <Philippa_> "dynamic functions"?
05:21:03 <bourbaki> i can compile new functions in lisp
05:21:31 <musasabi> We should get a way to display a RSS feed out of the CVS commit messages.
05:21:34 <bourbaki> that is what i do is nothing but translateing the nl sentence into a set of closures that follow the semantic
05:21:39 <Philippa_> how does that make any real difference but speed?
05:21:45 * Philippa_ nods
05:21:48 <Philippa_> can do that in haskell too
05:21:55 <Philippa_> you've got higher-order functions, use 'em
05:23:20 <pesco> Igloo: You're debian package maintainer for ghc6. Do you have anything to do with the linux-ppc deb? I'm looking for clues what's going on with this: http://hackage.haskell.org/trac/ghc/ticket/631
05:23:25 <bourbaki> ok in the end this doesnt make a big difference
05:24:16 <bourbaki> i can compile .o files with ghc that i can use in c++ in the end cant i?
05:24:24 <Philippa_> I believe so, yeah
05:24:34 <Philippa_> I'm not an FFI guru though, so I don't know how you'd need to call
05:24:42 <bourbaki> ah thats cool then i can do my math stuff in haskell also
05:25:04 <Philippa_> you can even use hs-plugins and use haskell as if it were a scripting lang
05:25:06 <bourbaki> maybe i also could do that for my new article in shaderx5 :)
05:25:13 <Igloo> pesco: When http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=346248 is fixed I will hopefully be able to apply the patch in http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=343428 and see if it is still broken
05:25:14 <dcoutts> bourbaki, calling C++ from Haskell is a pain, the other way around is ok
05:25:25 <bourbaki> i might do but the prob is that i suck at getting deep into languages
05:25:42 <bourbaki> i want to call the haskell .o file in c++
05:26:04 <bourbaki> that is write all the math and parse stuff in haskell nice and well formed :) and then do the dirty work in c++
05:28:07 <dcoutts> bourbaki, yeah that's ok since C++ can call C functions easily and the Haskell FFI exposes exported Haskell functions as if they were ordinary C functions.
05:29:01 <bourbaki> i have asked this a million times by now but is there any module for haskell that features a lot of the mathlab functions?
05:29:23 <bourbaki> i so need a good LA module but dont dare to write one myself cause its painstakeing work to do that well
05:29:27 <difosfor> Hey folks, quick question: I'm getting a program error (Program error: Prelude.!!: index too large
05:29:41 <aleator> bourbaki: hmatrix?
05:29:46 <difosfor> how do I find in which function this was caused?
05:30:06 <bourbaki> aleator: does it also feature eigenvalues and vectors and so?
05:30:13 <musasabi> bourbaki: I think there was much discussion about it at least.
05:30:26 <aleator> bourbaki: Yes. I use it for pca.
05:30:46 <bourbaki> aleator: ah cool thats what i want to use it for also for my hand detection
05:31:06 <Cale> difosfor: do you use !! a lot in your app?
05:31:07 <aleator> bourbaki: Neat. Doing computer vision also?
05:31:12 <bourbaki> cool will look into that hmatrix thingy
05:31:40 <bourbaki> aleator: yep did that here at uni in a project and wanted to do that 3d webcam hand cursor thingy for a while now 
05:32:05 <pesco> Igloo: I have GHC 6.4 (i.e. not .1) on Ubuntu here, and the Jump Islands problem doesn't appear...
05:32:08 <bourbaki> i just need to get the camera pic into haskell then though i can do that within c++ then it still sucks a bit
05:32:26 <Cale> difosfor: the simplest say might just be to search for instances of !!, and examine the functions containing them. IIRC there was a more decisive way which involved some profiling options
05:32:33 <aleator> bourbaki: That must be fun. I'm stuck with analysing images of nonprinted paper. :)
05:32:42 <difosfor> Cale: Hmm.. I guess not that much.. 7 times.. but I was wondering if there was a way to get a stacktrace or something in general
05:32:54 <bourbaki> aleator: non printed paper?
05:33:07 <edwinb> difosfor: yes, compile for profiling (-prof -auto-all)
05:33:09 <Cale> difosfor: stack traces are generally fairly useless
05:33:13 <bourbaki> aleator: do you know about #ai and #computervision here?
05:33:15 <edwinb> then run with the RTS option that I can't find ;)
05:33:15 <Igloo> pesco: I'm not interested in fixing bugs in 6.4, sorry
05:33:23 <bourbaki> no #machinevision
05:33:29 <aleator> bourbaki: As in looking at paper that is beeing manufactured.
05:33:38 <aleator> bourbaki:  umm. no.
05:33:47 <edwinb> a stack trace might at least tell you which !! was the culprit
05:33:59 <pesco> Igloo: No no, I just happen to have 6.4, I think the trac bug I gave is still current!
05:34:05 <difosfor> edwinb: that is using GHC I guess?
05:34:09 <edwinb> yes
05:34:14 <bourbaki> cool i got mail from these reseach guys !:)
05:34:32 <edwinb> ah. run your program with +RTS -xc
05:34:35 <pesco> Igloo: Do you suppose the Jump Islands problem is something that was only introduced with 6.4.1?
05:34:36 <Cale> edwinb: I suspect it would still be tricky
05:34:44 <edwinb> yes, it depends. it might not help.
05:34:45 <difosfor> Ok, thanks for the tips. Was using WinHugs/Hugs so far, will play with GHC now :)
05:34:47 <Cale> edwinb: that's the one :)
05:35:02 <Igloo> I think it was
05:35:06 <edwinb> but it gives you something to do while you think about what the problem really is ;)
05:35:13 <pesco> Igloo: Igloo Oh, ok.
05:35:29 <difosfor> Heheh, exactly :)
05:36:17 <Philippa_> ghc(i) and a good text editor is good. You may well still have uses for winhugs though, it does some good IDE-like stuff
05:36:23 <Lemmih> Anyone got a test file for the SumFile Shootout Entry?
05:36:37 <pesco> Igloo: The Ticket #631 bug happens with 6.4 as well, though...
06:16:01 <pesco> Igloo: The bug report I mentioned says that it appears to be only a packaging problem, because it does not manifest with a self-compiled ghc on the same machine. So are you the one making the ppc packages?
06:17:05 <Igloo> pesco: Indirectly, yes
06:18:15 <pesco> Igloo: But you have no idea what could be the cause, right?
06:18:32 <Igloo> Unless it's building it unregisterised, no
06:18:35 <bourbaki> pesco: been on the congress?
06:19:00 <pesco> bourbaki: Yes, I was a lecturer!
06:19:12 <bourbaki> ah heh :) what lecture did you give?
06:19:22 <bourbaki> i again didnt make it
06:19:34 <pesco> bourbaki: "Logical Language Lojban - A Hackers' /Spoken/ Language"
06:19:58 <bourbaki> ah right
06:20:20 <araujo> Hello.
06:20:26 <Cale> heh, this paper mentions (n * k + p) patterns.
06:20:39 <Cale> (which apparently were in Gofer)
06:23:02 <pesco> Igloo: Maybe it's building it unregisterised then? And why would it occur with an unregistereised build? Why do I have to pull every single word out of your nose?
06:23:24 <Saulzar> What next (n + k) (n' + k')  and cos theta patterns? :)
06:25:22 <aleator> Finally got my libsvm wrapper cabalized. And it only needed a minor hack!
06:26:43 <Igloo> pesco: No idea. Didn't I already say that was the only possible cause that sprang to mind in the bug?
06:29:32 <pesco> Igloo: Where do you mean? I don't see anything.
06:29:40 <Philippa_> Saulzar: transformational patterns
06:30:24 <pesco> Igloo: For the next obvious question, can you find out if the magic build machine or whatever is producing the ppc packages is performing an unregisterised build? And if so, could you try telling it not to?
06:30:34 <Igloo> Hmm, maybe it only went to g-h-bugs then
06:33:13 <Igloo> pesco: I know it's doing an unregisterised build, I just don't know if that's the problem. And no, I can't tell it not to do so until make is fixed. (and I probably won't either, as bugs in the registerised code are a real pain to fix, and powerpc seems to have a history of not being tested before release)
06:34:49 <Igloo> pesco: If you want to try and debug it then I suggest you build a registerised and unregisterised ghc on the same system and see if you can reproduce the problem on either of them
06:35:20 <Igloo> For both 6.4 and 6.4.1+patch
06:36:00 <pesco> Igloo: Okay, thanks. That's what I needed to know.
07:27:48 <jip> anyone familiar with fruit?
07:51:16 <maitscha> Hallo. I have the data-type "data my_data = data1 | data 2 | data3 Int" Now I have the function my_function :: my_data -> Int
07:51:56 <maitscha> Now I need a method which returns -1 when my_function is called with data1, -2 for data2 and Int for data3.
07:52:15 <maitscha> How can I do that within my_function?
07:52:34 <Cale> maitscha: that's not the exact declaration I hope :)
07:52:41 <Cale> (Capitalisation counts)
07:52:56 <maitscha> Cale, no it isn't the exact declaration.
07:53:04 <Cale> data MyData = Data1 | Data2 | Data3 Int
07:53:16 <maitscha> ok.
07:53:20 <Cale> myFunction Data1 = -1
07:53:31 <Cale> myFunction Data2 = -2
07:53:37 <Cale> myFunction (Data3 x) = x
07:53:46 <maitscha> Is it also possible with the condition operator?
07:53:51 <Cale> sure
07:53:54 <maitscha> how?
07:54:17 <Cale> myFunction x = case x of Data1 -> -1; Data2 -> -2; Data3 x -> x
07:54:47 <maitscha> hmmm... ok. I think I like the first solution.
07:54:50 <Cale> or, if you add an instance of Eq for MyData, you can use an if-then-else expression and test for equality with Data1 and Data2
07:55:15 <Cale> you still need to pattern match at some point to get the x out of Data3 x though
07:55:43 <maitscha> but what I I have the function MyFunction :: [MyData] -> [Int]
07:55:56 <maitscha> And I have to see in the head of the list...
07:56:10 <maitscha> I will need several conditions...
07:56:20 <ski> (Cale : could use a selector on 'Data3', too)
07:56:37 <maitscha> How can I use the "|" for my 3 cases?
07:56:41 <jip> what's a selector?
07:56:59 <Cale> ski: yeah, but that'll require a pattern match, or record syntax
07:57:07 <Cale> (to write)
07:57:19 <ski> data MyData = Data1 | Data2 | Data3 {foo :: Int}
07:57:45 <ski>   deriving Eq
07:57:51 <ski> myF md
07:57:59 <ski>   | md == Data1 = -1
07:58:04 <ski>   | md == Data2 = -2
07:58:08 <Cale> maitscha: this wouldn't happen to apply a function to each element of the list?
07:58:11 <ski>   | otherwise = foo md
07:59:02 <maitscha> md == Data3 _ ??
07:59:25 <maitscha> or: md == Data3 i ??
07:59:25 <ski> nope .. that only works in logic programming
07:59:41 <maitscha> hehe, sure.
08:00:05 <ski> (one could use an extension '| Data3 n <- md = n')
08:00:06 <maitscha> but I left logic programming behind me since 1 year.
08:03:57 <maitscha> no. the last one doesn't work.
08:04:48 <ski> works here, in ghc with -fglasgow-exts
08:06:29 <maitscha> | (Data3 n) <- (head t) = next tail t ++ head t
08:07:18 <ski> hm, did you mean 'next (tail t)' ?
08:07:20 <maitscha> ERROR "D:\test.hs":86 - Syntax error in declaration (unexpected `<-')
08:07:34 <ski> are you running this in ghc ?
08:07:38 <ski> or hugs ?
08:07:38 <maitscha> no.
08:07:40 <maitscha> hugs
08:07:47 <maitscha> hugs98
08:07:53 <ski> ok, i think hugs doesn't support this extension
08:08:29 <ski> right, at least my version doesn't (and apparently your neither)
08:08:53 <maitscha> hmm... any other ideas?
08:08:55 <ski> btw, why do you use 'head t' and 'tail t' instead of pattern-matching on that list ?
08:09:24 <ski> you can always use pattern-matching / case to extract to number from the 'Data3', as Cale suggested
08:09:36 <maitscha> I have only to put the first element after the last element of the list.
08:09:42 <ski> (also, in this case, you can use a selector, as i showed a bit above)
08:09:47 <Cale> you really ought to use pattern matching instead of equality testing when possible
08:10:08 <Cale> Especially with recursive types
08:11:02 <Cale> Or parametric types
08:11:11 <Cale> Note that
08:11:16 <Cale> f [] = True
08:11:19 <Cale> f (x:xs) = False
08:11:31 <Cale> has type [a] -> Bool
08:11:34 <Cale> whereas
08:11:43 <Cale> g x = if x == [] then True else False
08:11:54 <Cale> has type  (Eq a) => [a] -> Bool
08:12:08 <ski> also
08:12:12 <Cale> which is kind of a subtle point about the instance of Eq for lists :)
08:12:12 <ski> @type null
08:12:13 <lambdabot> forall a. [a] -> Bool
08:12:22 <Cale> right, that's a prelude function
08:12:30 <Cale> f = null
08:15:26 <maitscha> ok. pattern matching.
08:15:40 <maitscha> but | (head (Data3 x)) = ... doesnt work.
08:16:23 <maitscha> ok. that can't work.
08:16:46 <Cale> head needs a list
08:17:08 <Cale> and in order to produce a boolean for the guard, that list had better be a list of booleans
08:17:28 <maitscha> head t == (Data3 x) = ... also doesn't works.
08:17:36 <Cale> um
08:17:57 <Cale> f (Data3 x) | x > 0 = x | x <= 0 = -x
08:18:18 <Cale> there's an example using both guards and pattern matching
08:18:27 <Cale> sorry for the lack of layout
08:19:00 <maitscha> I would like to use pattern matching...
08:19:13 <Cale> then just follow my original example :)
08:19:24 <Cale> you said you have a list?
08:19:35 <Cale> f (Data3 x : xs) = ...
08:19:44 <maitscha> yes.
08:19:51 <Cale> you could do that
08:20:39 <Cale> though usually it's possible to break up an operation like that into a part which is purely a list operation and a part which acts on the elements of the list
08:21:17 <Cale> like, if I was adding 1 to all the elements of a list, I could write my function like:
08:21:21 <Cale> f [] = []
08:21:31 <Cale> f (x:xs) = (x + 1) : (f xs)
08:22:01 <Cale> or, I could notice that this is really just applying the function which adds one to each of the elements of the list
08:22:11 <Cale> which is  f = map (+1)
08:23:35 <maitscha> hmmm... ok. that works nice.
08:26:48 <maitscha> Thank you Cale!
08:26:54 <Cale> no problem :)
08:32:47 <maitscha> Only one question: When I want to check if the last 2 elements from the list are of type Data3, what should I do?
08:33:26 <Cale> write a function like:
08:33:31 <Cale> isData3 (Data1) = False
08:33:34 <Cale> isData3 (Data2) = False
08:33:39 <Cale> isData3 (Data3 _) = True
08:34:12 <Cale> then  all isData3 (take 2 (reverse xs))
08:35:48 <maitscha> ok. yes. thank you.
08:35:59 <Cale> note that this has complexity on the order of the length of the list, but there's no way around that with a list
08:36:02 <maitscha> I have had the function isData3 allready.
08:46:07 <jip> is there something like PyDispatcher for haskell?
08:46:59 <Cale> what is PyDispatcher?
08:47:00 <CosmicRay> what is pydispatcher?
08:47:25 <jip> it's an implementation of the gang-of-four "observable" pattern for python
08:47:55 <jip> http://pydispatcher.sourceforge.net/
08:48:15 <CosmicRay> from looking at the site, I don't know of any existing Haskell implementation, but I think it could probably be implemented in less than 100 lines of code in haskell.
08:48:49 <Saulzar> Does that make sense?
08:48:54 <jip> well, pydispatcher itself is only 700 lines of python
08:49:04 <CosmicRay> so my estimate is about right ;-)
08:49:19 <Cale> It doesn't seem to be very meaningful without a notion of objects.
08:49:30 <Cale> What do you want objects to be represented by?
08:49:44 <CosmicRay> all you'd need is functions
08:50:11 <bourbaki> are there any go players in here?
08:50:12 <jip> well, the only 2 important functions are dispatcher.send and dispather.connect
08:50:12 <Saulzar> One would need an object collection to go with it... or some kind of state, right?
08:50:16 <Cale> I'm looking at the description and I'm not even sure why you'd need such a thing at all.
08:50:27 <CosmicRay> Cale: yes, I agree.
08:50:42 <CosmicRay> jip: what is the type of the signal?
08:50:57 <Cale> It represents a pattern in python, but that doesn't necessarily translate into a Haskell pattern.
08:51:05 <CosmicRay> a "pattern"?
08:51:33 <jip> CosmicRay: i'm not sure what haskell type one would use, but they use a python function that takes a single argument that is the value of what was passed to send
08:52:09 <jip> i actually have a much more important and interesting question not related to pydispatcher but i have to eat now :'(
08:52:10 <CosmicRay> so if you try to connect a signal handler that expects something of a different type, you're hosed at runtime?
08:52:10 <Saulzar> It might be useful for a discrete version of Yampa or something, deliver events on demand rather than stream them continuously
08:52:10 <Cale> CosmicRay: An oft-repeated structure which is usually hard or impossible to abstract directly in the language.
08:52:17 <jip> CosmicRay: correct
08:52:44 <CosmicRay> I think in Haskell, I'd keep a list of functions and use mapM or map over them.
08:52:53 <CosmicRay> 5 lines or less ;-)
08:53:07 <Cale> Many OO languages are insufficiently expressive, and as a result there are a lot of patterns which crop up that people talk about. They tend to be the sort of thing we'd turn into a higher order function.
08:53:29 <jip> Cale: try turning "singleton" into a high order function :P
08:53:32 <jip> anyway, i gotta eat
08:53:46 <Cale> jip: that's called 'return'
08:53:52 <MarcWeber> I'm still struggling with Cont Monads.. I can type runCont (return 2) (print) and will get 2. Can you give a short example how to combine this with >>= anyfunction where anyfunction should return another one?
08:53:53 <Cale> :)
08:53:54 <Saulzar> Singleton in haskell is easy  foo = 3  :)
08:54:24 <Cale> MarcWeber: you saw my long recent post?
08:54:34 <Cale> did you try any of the examples there?
08:55:59 <Cale> MarcWeber: First you might be interested in understanding the Identity monad
08:56:01 <MarcWeber> Cale: Yes, thanks.. I did and after running the modulo I even got an idea of what it does and how.. 
08:58:23 <MarcWeber> Cale: "A typical use of the Identity monad is to derive a monad from a monad transformer" which is chapter II in "All about monads" but I'm still at II .. I'll have look at it again.. 
08:59:19 <Cale> MarcWeber: also, did you read my MonadsAsContainers article (though Cont is among the hardest monads to understand as a container, Identity is really easy)
08:59:26 * Saulzar read it too, very interesting stuff.
09:02:55 <jip> are there any other haskell logging libraries other than the one in MissingH?
09:04:38 <Cale> jip: usually one uses a Writer monad/transformer
09:04:46 <Cale> depending on what is needed
09:05:07 <jip> Cale: i suppose.... are you familiar with the MissingH logging module though?
09:05:16 <Cale> jip: not terribly so
09:05:20 <Cale> let me have a look
09:05:23 <MarcWeber> Cale: Haskell Wiki? Not yet.. Have to think about the Identity Monad again..
09:05:42 <Cale> MarcWeber: yeah, it's on hawiki, I very much recommend it
09:06:16 <Cale> since it gives you another perspective on monads from that posed in All About Monads, and more perspectives on an abstraction are usually a good thing :)
09:07:42 <Cale> CosmicRay: I can't connect to quux.org
09:08:18 <Cale> it also doesn't seem to respond to pings
09:08:20 <MarcWeber> *smile*.. Will beg you again in 8 days.. :) (or hopefully sooner..)
09:08:36 <Cale> @wiki MonadsAsContainers
09:08:37 <lambdabot> http://www.haskell.org/hawiki/MonadsAsContainers
09:08:53 <Cale> do you have any more directed questions?
09:10:07 <Cale> jip: Okay, there's nothing I know of that's quite that refined.
09:10:36 <jip> Cale: so would you recommend using MissingH's logging shit?
09:10:49 <Cale> jip: I've never used it. I have no idea ;)
09:11:00 <sproingie> i wish i could get missingH to compile
09:11:15 <jip> ok but would you recommend trying it? or should i just use some writer monad/transformer thing?
09:12:01 <Cale> hmm... well, if it's not obvious how the WriterT thing should work, try that first on a small example so you get a feel for it :)
09:13:00 <jip> hm..... maybe i'll just stick with putStr and error(for fatal errors) =]
09:13:13 <Cale> hehe
09:13:17 <Cale> yeah
09:13:40 <Cale> I've never had the need for such exceptionally detailed logging.
09:14:56 <jip> anyway, i gotta eat... coming up when i get back: the big question
09:14:56 <Cale> also, the logger in MissingH uses an unsafePerformIO to get a top-level MVar which is a bit of a hack
09:15:39 <jip> unsafePerformIO is how one does singleton in haskell :D
09:16:11 * jip is really gone now
09:17:02 <Saulzar> Heh, I guess that's the "proper" singleton in Haskell...
09:17:13 <Saulzar> Whoops, didn't read half a line up
09:17:32 <sproingie> haskell's singleton is IO.  and you get it for free.
09:18:01 <Philippa_> not quite true
09:18:10 <Philippa_> the IO monad doesn't stop you accidentally trying to initialise stuff twice
09:18:47 <Saulzar> I guess it's justified to use such hacks for debugging, where WriterT is not going to be fantastically convenient..
09:19:26 <MarcWeber> Cale: I think I got it.. I can do stupid things like this: 
09:19:30 <MarcWeber> @>> runIdentity (((return 2) >>= (return.(+1)) ) >>= (return.(**2)) )
09:19:32 <lambdabot> Maybe you meant: . id pl wn
09:19:48 <Cale> MarcWeber: yep
09:20:02 <MarcWeber> which should return 9
09:24:16 <SyntaxNinja> w00t
09:40:33 <MarcWeber> Cale: Thanks!! I will learn what liftM means.. I was faced with it some times before.. it was like a not yet know function!! Great work!! (me hugs you)
09:41:17 <Cale> liftM is the same as fmap
09:41:57 <Cale> It basically applies a function to every element of the container (in the container view), or applies a function to the result of a computation (in the computation view)
09:51:38 <ski> hyv‰‰ iltaa, esap
09:54:29 <esap> iltaa ski!
09:55:20 <esap> what's up?
09:55:52 <ski> pondering some on an effect system
09:56:34 * esap attempts to get my compiler to compile with GHC. Not that easy.
09:56:42 <ski> (that i'm trying to construct myself, i.e.)
09:56:57 <ski> your compiler ?
09:57:06 <ski> the cat-lang ?
09:57:10 * esap nods.
09:57:27 <ski> so you have concrete syntax, yet ?
09:57:51 <esap> well, some of it.
09:58:30 <esap> But I'm having trouble with the type checker. GHC can't handle the code I'm writing for the type checking algorithm....
09:58:53 <ski> more trouble with existentials ?
09:58:59 <esap> the same trouble.
09:59:08 <ski> m
09:59:41 <esap> I've even thought about removing existentials and replacing contexts with explicit argument passing. But it's not that simple.
10:00:37 <ski> in what sense ?
10:01:22 <esap> well because what I'd get is just bigger existential chunks of data.
10:01:42 <esap> And I fear I would then run into the same GHC bug.
10:01:57 * ski tries to recall what the exact trouble was (that i saw)
10:02:55 <esap> the problem was that my type checking had to open an existential package, then manipulate the data, and then repackage based on the computations. And pass contexts in between. I think GHC can't choose how to pass the existential contexts from output to input.
10:03:53 <esap> At least if there are more than one alternative for how to pass it.
10:04:23 <ski> hm, could you give a link to the function in question, again ?
10:05:15 <esap> http://www.kotiposti.net/epulkkin/TTypeCheck.txt
10:05:45 <ski> 'tyCheckObject', yes ?
10:05:49 <esap> yes.
10:06:10 <esap> STModule and STObject are existential packaging.
10:06:20 <esap> and STFunctor, of course.
10:07:12 <ski> esap : @type sfunctor_signature
10:07:17 <ski> (yes)
10:07:38 <ski> err, nvm
10:08:15 <ski> sfunctor_signature :: SFunctor -> (SModule,SModule)
10:08:19 <esap> sfunctor_signature :: SFunctor -> (SCategory, SCategory)
10:09:03 <esap> hmm.. I think I'm mixing two different versions of the code... :-)
10:09:21 <ski> SModule = SCategory ?
10:09:42 <esap> yes, I've done some renaming there.
10:09:53 * ski inferred the above from 'tyCheckFunctor :: SModule -> SModule -> TChkA SFunctor STFunctor'
10:10:54 <ski> hm, so an (untyped) 'SFunctor' value includes the dom and cod, then ?
10:11:28 <esap> dom and cod will be computed during type checking.
10:12:01 <ski> 'sfunctor_signature' returns them ..
10:12:09 <ski> err
10:12:18 <ski> you called those 'fdom','fcod'
10:12:45 <esap> those are untyped representations of the dom and cod.
10:13:24 <ski> hm .. so are those checked somewhere, too ?
10:14:05 <esap> yes, let me put in a new version of the file...
10:14:17 <ski> m, right
10:14:31 <esap> ok, now look at it.
10:14:38 <esap> same URL
10:21:12 <ski> hm
10:21:35 <ski> for what reason do you pass in extra args to 'tyCheckObject' and 'tyCheckFunctor' ?
10:22:07 <esap> it's the context of an object and the context of a functor.
10:22:57 <ski> then, why is the context to objects typed but the context to functors not ?
10:23:53 <esap> what do you mean? I think both are typed.
10:26:10 <ski> tyCheckObject :: STModule -> TChkA SObject STObject
10:26:11 <ski> tyCheckFunctor :: SModule -> SModule -> TChkA SFunctor STFunctor
10:26:35 <ski> 'STModule' is checked, but 'SModule' is not, yes ?
10:26:36 <esap> >tyCheckFunctor :: {- (ModuleCtx cat) => -} TCategory cat -> TCategory cat' -> TChkA SFunctor STFunctor
10:26:46 <ski> hm
10:26:59 <esap> >tyCheckObject :: (ModuleCtx cat) => TCategory cat -> TChkA SObject STObject
10:27:07 <ski> arg, sorry
10:27:19 <ski> browser didn't reload properly
10:27:24 <esap> ok
10:27:36 * ski rechecks
10:29:54 <ski> hm, need to check typedefs ..
10:30:54 <ski> url ?
10:31:41 <esap> http://www.kotiposti.net/epulkkin/TTree.txt  (for the types)
10:32:09 <esap> http://www.kotiposti.net/epulkkin/TSynTree.txt (for untyped tree)
10:32:29 <esap> http://www.kotiposti.net/epulkkin/TTypeCheck.txt (for type checker)
10:45:02 <ski> STCategory :: TCategory s -> STCategory
10:45:05 <ski> what is 's' ?
10:45:24 <esap> it's a Haskell type that represents the category.
10:46:00 <ski> (existential)
10:46:04 <esap> yes
10:46:32 <esap> it's phantom type that is used to ensure I don't accidentally mix different categories.
10:47:43 <esap> With category theory, you have to be very careful to distinguish between different categories.
10:48:48 <ski> m
10:48:50 <esap> One task that the type checking algorithm must do is to find concrete type for that existential type parameter.
10:48:59 <ski> hmm
10:49:27 <esap> for all existential parameters I have.
10:49:41 * ski waits with comment 'til he's gone through the whole function
10:51:26 <ski> @type functor_signature
10:51:27 <lambdabot> Not in scope: `functor_signature'
10:52:31 <esap> functor_signature :: forall cod dom (f :: * -> *). TFunctor f dom cod -> (TCategory dom, TCategory cod)
10:53:17 <ski> what is 'f' here, btw ?
10:53:41 <esap> it's phantom type for representing category theory functorss
10:54:45 <esap> it's kind is * -> *, because (one-argument) category theory functors have that kind in Haskell, or actually, closest approximation to that....
10:57:34 <MarcWeber> Cale: I'm now through most of your Monads as containers.. Well done.. It does help.. But thinking in terms of join.fmap doesn't help in any case because >>= is given most of the time and not fmap and join.. ;) Is there an implementation of Functor for Cont type?
10:58:33 <Cale> yeah, Cont is a functor
10:58:35 <ski> esap : @type is_equal_type
10:58:42 <ski> esap : @type map_eqtype
10:59:14 <Cale> MarcWeber: or rather, Cont r is a functor for each r.
10:59:18 <esap> ski: is_equal_type: (forall (rep :: * -> *) a b. (TypeRep rep) => rep a -> rep b -> Maybe (EqType a b)
10:59:46 <esap> ski: map_eqtype :: forall b (f :: * -> *) a. EqType a b -> f a -> f b
10:59:57 <jip> you guys know how in fruit widgets are arrows and you put together a lot of widgets to make one big widget that is your window?
11:00:12 <Cale> @djinn-env
11:00:13 <lambdabot> data () = ()
11:00:13 <lambdabot> data Either a b = Left a | Right b
11:00:13 <lambdabot> data Maybe a = Nothing | Just a
11:00:13 <lambdabot> data Bool = False | True
11:00:13 <lambdabot> data Void
11:00:15 <lambdabot> type Not x = x -> Void
11:00:25 <ski> esap : missing ')'
11:00:41 <Cale> @djinn-add type Cont r a = ((a -> r) -> r)
11:01:04 <Cale> @djinn (a -> b) -> Cont a -> Cont b
11:01:13 <esap> ski: is_equal_type :: forall (rep :: * -> *) b a. (TypeRep rep) => rep a -> rep b -> Maybe (EqType a b)
11:01:39 <Cale> @help djinn-add
11:01:40 <lambdabot> Define a new function type or type synonym
11:02:15 <Cale> @djinn-env
11:02:16 <lambdabot> data () = ()
11:02:16 <lambdabot> data Either a b = Left a | Right b
11:02:16 <lambdabot> data Maybe a = Nothing | Just a
11:02:16 <lambdabot> data Bool = False | True
11:02:16 <lambdabot> data Void
11:02:18 <lambdabot> type Not x = x -> Void
11:02:20 <lambdabot> type Cont r a = (a -> r) -> r
11:02:35 <Cale> @djinn (a -> b) -> Cont r a -> Cont r b
11:02:36 <lambdabot> f a b c = b (\ d -> c (a d))
11:02:41 <Cale> there we go :)
11:02:56 <ski> esap : @type functor_inverse_image
11:03:01 <ski> esap : @type object_category
11:03:05 <ski> esap : @type object_change_category
11:03:36 <ski> @djinn (a -> b) -> (Not b -> Not a)
11:03:36 <lambdabot> f a b c = b (a c)
11:03:37 <esap> ski: functor_inverse_image :: TFunctor f dom cod -> TCategory cod -> TCategory dom
11:04:02 <esap> ski: object_category :: TObject cat t -> TCategory cat
11:04:33 <esap> ski: object_change_category :: EqType cat cat' -> TObject cat t -> TObject cat' t
11:12:10 <Keal> dons
11:12:18 <Keal> so you want make bot of me?
11:13:06 <Keal> have bot use visual system composed of spacial graphs
11:13:19 <Keal> have bot be able to recombine the simplistic representations
11:13:25 <Keal> that step 1
11:13:43 <Keal> step 2 is have bot always start from scratch
11:14:02 <Keal> step 3 is have bot ignore parsimony
11:15:12 <Keal> step 4 is have bot explain what it is doing using a small vocabulary of spacially translative concepts
11:15:56 <Keal> that is how you make bot of me dons
11:16:45 <Keal> also do not forget to have bot alternate between simplified english and more complex flowing language similiar to how a beatnik would speak
11:20:10 <Keal> simplified english meaning zork-like sentences
11:21:17 <CosmicRay> you know keal, we already made a bot of you.
11:21:18 <CosmicRay> @wiki MegaMonad
11:21:18 <lambdabot> http://www.haskell.org/hawiki/MegaMonad
11:21:19 <Keal> bot should alternate between two two ways of speaking based on mood, lethargy, and impatience
11:22:05 <Keal> by mood i mean mood swings
11:22:47 <ski> esap : what instance is there for 'FApp' in first arg of class 'TypeCxt' ?
11:23:36 <Keal> megahal is the worst example of ai i have ever seen
11:23:37 <ski> s/in first arg of/with/
11:23:49 <jip> i have a nice IO main function, but sometimes it doesn't complete because of an error is encountered. how can i have a specified IO function be executed before quitting if such an error happens? something like atexit
11:24:25 <esap> ski: instance (TypeCtx mid, PpShowF f) => TypeCtx (FApp dom f mid)
11:24:29 <Saulzar> jip, You can catch exceptions
11:24:39 <esap> ski: f has kind * -> * there.
11:24:44 <ski> ya
11:24:46 <Saulzar> jip, error is catchable as an exception at IO level
11:25:03 <jip> Saulzar: cool, what about things like bad pattern match?
11:25:08 <Keal> i tell you how to make functional intelligence. you give me bullcrap called megahal
11:25:21 <Saulzar> Yeah, I think that's error as well
11:25:24 <Keal> zork-like mode is for parity
11:25:46 <Keal> beatnik mode is for influence
11:26:18 <Keal> as in direct exchange vs abstract inherited exchange
11:26:22 * Saulzar notes that this new bot should also talk to itself a lot :)
11:26:25 <jip> Saulzar: i see... so how do i catch this exception?
11:27:10 * Keal notes that this new bot should be accompanied my a bucnh of ninny bots that ignore important info
11:27:15 <Keal> :P
11:27:20 <Saulzar> Control.Exception, I've never used anything except IO exceptions myself as yet...
11:29:08 <Keal> also to show off bot should make typos by swapping adjecent letters doubling or removing syllables or replacing with similiarlly spelled or related word
11:29:53 <Saulzar> Are you a bot Keal?
11:30:24 <Keal> how does my telling you how to reproduce me using a machine make me a bot?
11:30:50 <Saulzar> Well, it could exist already
11:30:57 <KirinDave> Keal: It raises some interesting philosophical questions about machine intelligence as life.
11:31:12 <Keal> it is called the human err.
11:31:40 <Keal> assuming since method of bot duplication of human exists thus humans more likely to be bot
11:32:05 <Keal> but humans != bot
11:32:23 <Keal> and bot iq < human iq
11:32:35 <Keal> bot is program
11:32:38 <Keal> human is not
11:33:18 <Keal> but human can mimic program especially if human needs to in order to cope or behave in understandable way
11:34:40 <Keal> intuitive != imperative
11:35:30 <Keal> anwyays i am going wo eat breakfast
11:35:45 <KirinDave> keal: Watch out, it might begin reproducing as well.
11:36:00 <ski> esap : where should 'instance PpShowF f' come from ? (where "f' :: TFunctor f domB codB")
11:38:20 <esap> ski: FunctorRep instance of STFunctor constructor's constraints.
11:38:53 <esap> ski: class (PpShowF f, Functor f) => FunctorRep f
11:39:27 <esap> ski: data STFunctor where STFunctor :: (FunctorRep f, ModuleCtx dom, ModuleCtx cod) => TFunctor f dom cod -> STFunctor
11:40:30 <ski> hm, you modified that last, now ?
11:40:40 <ski> ('STFunctor')
11:41:29 <esap> probably was just PpShowF f constraint in STFunctor before.
11:41:47 <esap> anyway I think it should come from the existentially bound package
11:41:48 * ski saw 'STFunctor :: TFunctor f dom cod -> STFunctor'
11:41:53 <Keal> KirinDave of course Keal bot is to reproduce. what you think Keal bot supposed to do? it meant to recreate from scratch new foundation for self
11:42:10 <KirinDave> Keal: I meant your breakfast.
11:42:29 <Keal> i do not eat gerbils
11:42:30 <esap> ski: I did some modifications, because I had some intermediate version where I tried something out that didn't quite work :-)
11:42:39 <ski> k
11:43:05 <ski> this extra evidence prolly helps some .. lemmesee
11:44:10 * Keal goes to work on recreating a program that spits back nanobot insect algorithm contructable endless ramdrive
11:44:36 <MarcWeber> Cale: I have this working now : runCont(do {a<-return 2; Cont (\y -> y (1+a) )}) (print) ;).. I tried this some times before but I must have forgotten some pharentesis or the like .. *jump* Now my new goal: two continuation functions (+1 and **2 ;)
11:45:59 <jip> hm... ok with Control.Exception i can use catch, but is there something similar to "finally" in python's exception system?
11:46:23 <jip> or even better something like c# "using"?
11:48:03 <MarcWeber> jip Just put your "finally" statement after the catch? finally does mean execute no matter what happens.. and this will done after your .. catch .., too, won't it?
11:48:16 <MarcWeber> What's using about?
11:48:24 <ski> esap : there is still type error, with this later version ?
11:48:45 <esap> ski: type error?
11:48:59 <ski> esap : in ghc
11:48:59 <esap> ski: I get GHC panic
11:49:17 <jip> MarcWeber: but then if there is an exception then the finally will be executed twice
11:49:17 <ski> hmhm
11:49:22 * ski ponders
11:49:56 <esap> ski: "ghc-6.4.1: panic! (the 'impossible' happened, GHC version 6.4.1): cgPanic   zddModuleCtx{v a3Ns} static binds for: local binds for: ...
11:50:00 <ski> esap : you have duplicate instances there, but i don't think ghc should notice that, with current shape of code
11:50:34 <ski> (more specifically, with how you handle 'EqType')
11:51:02 <monochrom> bracket is for jip
11:51:28 <jip> monochrom: hm?
11:51:40 <esap> ski: yea, they're distinct types at compile time
11:51:45 <monochrom> hahaha as it happens there is also finally.
11:52:13 <monochrom> Go through the Control.Exception API.
11:52:36 <jip> monochrom: ah... hm.. what is the difference between finally and bracket?
11:52:59 <MarcWeber> jip: Why twice?  execution will be skipped until catch .. you can do nothing there and your program will continue after that like nothing has happened..
11:53:00 <jip> monochrom: i guess with bracket the release code isn't run if the aquire throws an exception
11:53:18 <monochrom> Um, the doc already says the relation?
11:53:32 <jip> yeah i guess i need sleep and shit
11:53:39 <jip> anyway thanks men
11:53:40 <monochrom> finally is "A specialised variant of bracket with just a computation to run afterward."
11:53:44 <esap> ski: The strange thing is, if I use ghci, the similar kind of error only occurs once I start 'main'.
11:54:54 <esap> ski: Clearly ghci is postponing some checks to the point where ghci starts to evaluate the program.
11:55:05 <esap> ski: and that's where it fails....
11:55:15 <Keal> only prollem with MegaHal is i make it seem smarter since it tends to fully quote me
11:56:03 <Keal> i dont understand why you want make bot? why not just have baby.
11:56:17 <Keal> no girlfriend for you?
11:57:04 <ski> esap : strange
11:57:54 * ski wonders whether one could skip sending in one of the duplicate instances
12:05:16 <Keal> ski can you tell a sleeping cat is breathing from 30 feet away?
12:06:03 <Philippa_> I don't think most people could, assuming it's not snoring
12:06:14 <Keal> i can
12:06:38 <Philippa_> you'd be hard pressed with mine against any level of background noise
12:06:50 <Philippa_> beyond the obvious "assume it's breathing because odds are you wouldn't be seeing it if it wasn't"
12:07:01 <Keal> i meant visually  be able to tell
12:07:14 <Philippa_> she's not exactly a deep breather in her sleep
12:08:22 <Keal> watching to see if a cat is breathing from 30ft away is like eating a half dozen shrooms
12:10:18 <Keal> eventually the longer you stare the cat turns into candy canes and daisies
12:10:55 <Keal> especially with a black kitten like mine
12:13:56 * araujo wishes to know what Keal talks about at least once in his life
12:15:06 <KirinDave> araujo: Some things... man was never meant to know.
12:15:15 <maitscha> I have a short question: what exactly is called "guard" in haskell?
12:15:24 <araujo> hah
12:15:26 <Philippa_> KirinDave: for the rest, there's mastercard?
12:15:34 <araujo> haha
12:15:40 <KirinDave> Philippa_: Haha. Well played. :)
12:15:52 <maitscha> is it the ability of haskell to call the function with the parameters that match?
12:15:53 * araujo likes Philippa_ sense of humor
12:16:02 <mauke> pattern guards?
12:16:16 <sproingie> i think he means just regular guards
12:16:21 <araujo> maitscha, that's pattern matching
12:16:26 <monochrom> guard is called guard.  monochrom is called monochrom.
12:16:36 <maitscha> yes, pattern matching.
12:16:36 <Philippa_> maitscha: the conditions you can put on patterns
12:16:39 <mauke> what are regular guards?
12:16:52 <sproingie> guards that take their metamucil
12:16:53 <ski> s/regular/ordinary/
12:16:54 <Philippa_> case foo of {bar | 1 == 2 -> undefined;}
12:17:03 <Philippa_> the | 1 == 2 bit is a guard
12:17:23 <araujo> yeah, guards are boolean expressions on patterns
12:17:53 <Philippa_> that case statement always evaluates to undefined btw, but not the undefined in the pattern
12:17:54 <monochrom> I was thinking of Monad.guard
12:18:00 <Philippa_> because 1 /= 2
12:18:11 <sproingie> Monad.guard is something very different
12:18:29 <monochrom> Yes, but it is also called guard.
12:18:36 <sproingie> same name, different thing
12:18:40 <Philippa_> yeah? I thought it was a function that's supposed to provide a monadic equivalent of guards?
12:18:58 <Philippa_> calls fail if the guard evaluates to false or something?
12:19:03 <monochrom> So, "what is called guard" is ambiguous.
12:19:03 <mauke> @type Monad.guard
12:19:05 <lambdabot> forall (m :: * -> *). (Control.Monad.MonadPlus m) => Bool -> m ()
12:19:18 <sproingie> hmm.  yah, looks like it
12:19:24 <monochrom> calls mzero (of MonadPlus)
12:19:42 <Philippa_> ah. Better'n'fail, then :-)
12:28:08 <Keal> see cat got up and walk then lay other direcution
12:28:14 <Keal> i right. he breathing
12:28:17 <Keal> :p
12:29:38 <Keal> watching cat breathe crazy :)
12:29:46 <Keal> cya
12:34:11 <jip> how do i convert a Double to a Float?
12:35:08 <Igloo> realToFrac
12:36:54 <jip> thanks
12:37:54 <Keal> doubles and floats suck imo
12:38:01 <Keal> ieee should never have made them
12:38:18 <liyang> Exact real arithmetic FTW.
12:38:29 <jip> Keal: what's the alternative?
12:38:51 <Keal> lasercell i guess
12:38:57 <sproingie> there's interval arithmetic.  sun's supposedly working on a FPU that uses it
12:39:16 <sproingie> still have to support ieee for compatibility with buttloads of stuff tho
12:39:58 <alar> Keal: they do not suck if you consider performance
12:40:04 <Philippa_> interval arithmetic?
12:40:21 <Keal> doubles and floats cause b*(Floor[v/b^p]/b-Floor[Floor[v/b^p]/b) to fuck up
12:40:23 <Philippa_> they also don't suck if you consider that in practice they have more precision than we typically have accuracy on real numbers anyway
12:40:37 <Keal> doubles and floats cause b*(Floor[v/b^p]/b-Floor[Floor[v/b^p]/b]) to fuck up
12:41:19 <Philippa_> deal with it. The real world has epsilons
12:41:24 <xerox> @type \p | not p -> mzero
12:41:25 <lambdabot> parse error on input `|'
12:41:50 <xerox> @type let guard p | not p = mzero
12:41:51 <lambdabot> not an expression: `let guard p | not p = mzero'
12:41:55 <alar> is there something interval-arithmetic as robust and as easy to program as i387?
12:41:55 <xerox> @type let guard p | not p = mzero in guard
12:41:56 <lambdabot> Not in scope: `mzero'
12:42:05 <liyang> http://www.doc.ic.ac.uk/~ae/exact-computation/
12:42:05 <xerox> @type let guard p | not p = Control.Monad.mzero in guard
12:42:06 <lambdabot> forall (m :: * -> *) a. (Control.Monad.MonadPlus m) => Bool -> m a
12:42:24 <xerox> @type let guard p | not p = Control.Monad.mzero | otherwise = return () in guard
12:42:25 <lambdabot> forall (m :: * -> *). (Control.Monad.MonadPlus m) => Bool -> m ()
12:42:34 <monochrom> Control.Monad.mzero, Control.Monad.guard
12:42:53 <Keal> Philippa_ what are epsilons?
12:42:59 <sproingie> eh.  on second thought it doesn't look like a representation, just an approach to solutions.  algorithms.
12:43:34 <xerox> monochrom: trying to guess the implementation.
12:43:42 <monochrom> Oh but all representations are approaches to solutions.
12:43:42 <alar> Keal: supposedly epsilons are relative errors
12:43:47 <sproingie> Bill Walster is the name that keeps coming up
12:44:02 <alar> common to everything in reallife physics etc.
12:44:17 <sproingie> http://research.sun.com/projects/dashboard.php?id=164
12:44:28 <Keal> even mathematica fucks it up tho
12:44:46 <Philippa_> Keal: the smallest sanely-discernable difference. If you do enough floating point work they can potentially get quite big
12:44:49 <Keal> it simplifies it wrong when b is Sqrt[1] and v is Pi
12:45:01 <Philippa_> alar: exactly
12:45:03 <Keal> it simplifies it wrong when b is Sqrt[2] and v is Pi
12:45:18 <Philippa_> and floating point units're primarily intend for applications that resemble real world physics
12:46:26 <Keal> b*(Floor[v/b^p]/b-Floor[Floor[v/b^p]/b])
12:47:16 <Philippa_> get over it
12:47:25 <jip> is there like a mapM that works on Data.Map instead of List?
12:47:42 <Philippa_> jip: very probably
12:47:56 <Philippa_> er, wait. Not a mapM. There's probably a way to build it though
12:48:49 <monochrom> You have to decide how to view Map as monad first.  There are several such views.  It is never clear which one you prefer.
12:48:51 <Philippa_> do you need mapM or just mapM_?
12:49:13 <jip> i think i need mapM
12:49:18 <Philippa_> monochrom: er, except insofar as 'how to sequence it' I don't think that's relevant?
12:49:27 <Philippa_> monochrom: mapM works on any monad
12:49:45 <jip> actually i think i can just use Data.Map.toList and use regular mapM
12:50:03 <xerox> @type (Control.Monad.sequence)
12:50:04 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
12:50:34 <Philippa_> jip: cool, that works
12:50:46 <Philippa_> it's if you need a Data.Map back out again that's the slow bit
12:50:47 <monochrom> Your are given "Map Int String".  Is it a "Monad Int", "Monad String", "Monad (Int,String)", or "Monad (Int->String)"?
12:51:08 <Philippa_> monochrom: we're *not talking about that*
12:51:14 <jip> hm.... i gotta watch some tv now bbiab
12:51:19 <xerox> o_O
12:51:29 <Philippa_> if you use mapM in the List monad, you get a [[foo]] back out...
12:51:31 <chucky> according to the docs, "mapM f is equivalent to (sequence . map f)", so you could probably use (sequence . Data.Map.map)
12:51:57 <Philippa_> chucky: no. The problem is that sequence takes a list as a parm
12:52:11 <chucky> d'oh, of course!
12:52:49 <monochrom> I am never understood.  That is because I see ambiguities other people never imagine.
12:53:17 <Philippa_> monochrom: I think I can see the ambiguity you're talking about. I don't think it's what's being discussed though
12:53:26 * xerox too!
12:54:13 <monochrom> But "mapM for Map Int String" would be meaningless until the ambiguity is resolved.
12:54:35 <Philippa_> which you can do by probabilistic means and context
12:55:05 <goron> By probabilistic means and context you can do everything :)
12:55:24 <goron> Like letting the program build itself. 
12:55:30 <monochrom> There was no context at the beginning.  As for probability I've seen all four cases desired by people in equal probability.
12:56:00 <Philippa_> monochrom: also, the context would be overspecified if jip meant "is there a monad instance for..."
12:56:17 <Philippa_> which, assuming jip is competant ;-), is a big hint
12:57:11 <Philippa_> goron: "you were probably going to write a program that crashes anyway" :-)
13:04:33 * Keal takes a shower
13:27:33 <frederik_> i wrote a linear algebra library where vector and matrix dimension compatibility is enforced by the type-checker, but i can't profile it because it uses template haskell
13:27:38 <frederik_> it's quite annoying.
13:27:51 <frederik_> it's about 200x slower than matlab for matrix inversion
13:27:55 <frederik_> i mean octave
13:30:52 <monochrom> Can you first benchmark a more basic operation first, e.g., multiplication?
13:31:20 <Keal> http://MyPyramid.gov
13:34:40 <Keal> according to that site my fiancee is starving
13:35:08 <Keal> she weighs 300lbs how can she be starving.
13:35:15 * Keal thinks gov is whacked
13:35:49 <Keal> he goal to lose 100lbs
13:36:01 <Keal> she doing good with that
13:36:06 <flux__> frederik_, it uses the same algorithm for doing the inversion?
13:36:47 * Keal think site not account for body mass and muscle tone
13:36:50 <frederik_> it uses LU decomposition
13:36:52 <frederik_> sorry
13:36:57 <frederik_> i think it's standard
13:37:16 * Keal also think site not account for fact some women do not menstruate despite age
13:37:51 <frederik_> monochrom: i wouldn't expect there to be much difference...
13:37:53 <Philippa_> Keal: if she's losing weight then odds are medically speaking she is indeed starving
13:38:05 <Keal> gov site useless tho
13:38:15 <Keal> not account for important things
13:38:20 <SamB> Philippa_: medical idea of starving very stupid, then
13:38:52 <Philippa_> SamB: not really. If you're losing weight rapidly, you are very likely not eating anywhere near as much as you're burning
13:39:27 <Keal> she need lose weight tho
13:39:30 <Philippa_> having a spare internal supply doesn't mean you're suddenly taking in enough, or that your body won't be using its starvation mechanisms
13:39:35 <monochrom> It is prudent to confirm before expect.
13:39:38 <Keal> she could die or get sick if she dont
13:39:59 <SamB> Philippa_: oh, right
13:40:03 <Philippa_> yeah, 300lb is a bit much even if you've got a big frame
13:40:03 <SamB> starvation mode...
13:40:28 <Keal> starvation mode does not feed off body
13:40:41 <Keal> starvation mode instead enact lethargy
13:40:43 <KirinDave> Hey folks.Brief haskell question.
13:40:44 <Philippa_> it does sooner or later
13:40:47 <Keal> and save most atp for brain
13:40:55 <SamB> KirinDave: sure!
13:41:00 <Philippa_> but yes, it also makes you lethargic, alters where energy's distributed etc etc
13:41:03 <KirinDave> SamB: Haha. Is it refreshing? :D
13:41:08 <orbitz> losing weight should really only be done with mild calorie cutting + exercerize
13:41:09 <SamB> that is the topic of this channel, after all...
13:41:12 <KirinDave> I was talking with lispy about dynamic languages.
13:41:14 <Philippa_> which is why it actually makes it harder to lose weight
13:41:23 <SamB> we might as well talk about it every know and then...
13:41:35 <KirinDave> And we wondered if Haskell's undefined is the same as the infinite type in languages like Python or Ruby.
13:41:41 <KirinDave> Is it?
13:41:49 <Keal> only way to lose weight is to be hyperactive
13:41:56 <SamB> KirinDave: the what?
13:41:58 <Keal> but she cannot
13:42:00 <Philippa_> Keal: not true
13:42:05 <orbitz> what is python's infinite type?
13:42:08 <Keal> she need to use starve i guess
13:42:10 <SamB> I don't remember anything called infinite in __builtins__
13:42:16 <orbitz> Keal: get on meth then
13:42:22 <Philippa_> I've lost craploads of weight in the past largely through simply not eating anywhere near enough
13:42:22 <orbitz> SamB: nor do i
13:42:30 <KirinDave> SamB: IN Ruby, Python, Smalltalk, Io, etc, they have an infinite open type for every object (which effectively means they are typeless).
13:42:31 <orbitz> SamB: does python have an infinity value for float type?
13:42:39 <Philippa_> (the good ol' depression diet - you just don't have the appetite)
13:42:42 <KirinDave> And lispy mentioned undefined. I don't know haskell more than casually, so i don't know.
13:42:56 <Philippa_> KirinDave: the undefined value in Haskell is effectively 'not a real value'
13:43:01 <KirinDave> Hmm.
13:43:04 <Philippa_> if something evaluates to undefined, it's effectively crashed
13:43:07 <orbitz> Philippa_: i have done that too, i prefer the gym
13:43:07 <KirinDave> Ahh.
13:43:13 <SamB> orbitz: such values can be obtained, but there is no easy way to get them and they don't print in a standard way...
13:43:16 <KirinDave> So then the answer is No.
13:43:19 <KirinDave> Good to know. :)
13:43:27 <Philippa_> orbitz: me too. Actually I /really/ prefer martial arts, but the gym'll do if I've stuff to think about
13:43:37 <SamB> KirinDave: undefined in Haskell is like throwing an exception in Python
13:43:46 <orbitz> Philippa_: i'll consider martial arts a gym activity, assuming you put the effort in
13:44:00 <KirinDave> Okay.
13:44:21 <SamB> only it doesn't hurt until you actually try to extract something from the value/apply the value to something, because of Haskell's non-strict semantics
13:44:21 <monochrom> How do you use the infinite open type in Python?
13:44:23 <Philippa_> orbitz: I wouldn't, it's more akin to other things you can do outside the gym
13:44:32 <Keal> hyperactive people tend to eat a lot and crap a lot and not gain weight since atp converted faster than normal diet consumes
13:44:45 <Philippa_> especially if you're not spending a lot of time doing specific fitness training within your martial arts training
13:45:00 <SamB> monochrom: apparantly all variables are of this type or something like that
13:45:54 <orbitz> Philippa_: in the martial arts i have done sparring was quite a good cardio workout (although not quite long enough) and various other activties helepd buidl muscle quite well
13:46:05 <KirinDave> Heh, so it's more of an error placeholder :)
13:46:08 <Philippa_> sure. I walk a lot, too
13:46:09 <monochrom> Haskell has such an open infinite type too.  It's called "a". :)
13:46:10 <SamB> KirinDave: you can even catch the exception if you use Control.Exception
13:46:23 <SamB> monochrom: but it doesn't do a whole lot
13:46:44 <Keal> when i was a kid i used to burn food fast since i run all time to avoid being hit by bully
13:46:53 <Keal> then i grow big
13:46:55 <SamB> KirinDave: generally it is more useful to use the error function for that
13:47:01 <SamB> observe:
13:47:01 <monochrom> Of course not.  Initial and terminal objects do nothing.
13:47:06 <SamB> > undefined
13:47:07 <Keal> and instead bullies get to run and i beat them :>
13:47:07 <lambdabot> Add a type signature
13:47:19 <SamB> > error "foo barfed"
13:47:20 <lambdabot> Add a type signature
13:47:23 <SamB> > undefined :: ()
13:47:25 <lambdabot> Undefined
13:47:27 <SamB> > error "foo barfed" :: ()
13:47:28 <lambdabot> Exception: foo barfed
13:47:37 <monochrom> > 1/0
13:47:38 <lambdabot> Infinity
13:47:45 <monochrom> > 1/0 :: Int
13:47:47 <lambdabot>  add an instance declaration for (Fractional Int)
13:47:47 <lambdabot>   In the expression: 1 / 0 :: Int
13:47:47 <lambdabot>   In the definition of `vse': vse = 1 / 0 :: Int
13:47:54 <monochrom> oops
13:48:00 <monochrom> > 1 `div` 0 :: Int
13:48:02 <lambdabot> Exception: divide by zero
13:48:05 <monochrom> there.
13:48:14 <ihope> > ['\0'..]
13:48:16 <lambdabot> "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\
13:48:16 <lambdabot> SYN\ETB\CAN\EM\SUB\ESC\FS\GS\RS\US !\"#$%&'()*+,-./0123456789:;<=>?@
13:48:16 <lambdabot> ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\DEL\128\
13:48:16 <lambdabot> 129\130\131\132\133\134\135\136\137\138\139\140\141\142\143\144\145\146\
13:48:16 <lambdabot> 147\148\149\150\151\152\153\154\155\156\157\158\159\160\161\162\163\164\
13:48:18 <KirinDave> SamB: Okay. So the two concepts are pretty much unrelated. undefined is itself is not untyped. :)
13:48:18 <lambdabot> [24 @more lines]
13:48:25 <monochrom> > const 5 (1 `div` 0)
13:48:26 <lambdabot> 5
13:48:35 <monochrom> That shows non-strictness.
13:48:43 <monochrom> Another example of non-strictness:
13:48:54 <monochrom> > head [ 1, 1 `div` 0]
13:48:56 <lambdabot> 1
13:49:00 <SamB> KirinDave: the only reason it has this infinite open type or whatever is that it isn't really a value
13:49:10 <monochrom> In a strict language the above two examples would blow up.
13:49:17 <ihope> Let's try this:
13:49:28 <ihope> > (\() -> 3) undefined
13:49:29 <lambdabot> Undefined
13:49:45 <Philippa_> ihope: it has to pattern-match against ()
13:49:51 <Philippa_> because () is a data constructor
13:49:56 <Philippa_> (\_ -> 3) undefined
13:49:58 <Philippa_> > (\_ -> 3) undefined
13:50:00 <lambdabot> 3
13:50:06 <monochrom> Pattern-matching introduces some strictness.
13:50:13 * SamB wants to download Manga with BitTorrent
13:50:16 <monochrom> > (\ ~() -> 3) undefined
13:50:17 <lambdabot> 3
13:50:25 <monochrom> And that is how to work around it.
13:50:33 <ihope> Wait, what did you do?
13:50:38 <monochrom> ~
13:50:39 <ihope> (\x -> seq x ())
13:50:46 <ihope> Yeah, whazza tilde?
13:50:47 <monochrom> "irresistible pattern" or something
13:50:54 <ihope> As-pattern?
13:51:08 <monochrom> No, as-pattern uses the symbol @
13:51:19 <ihope> Oh.
13:51:23 <Keal> haskell not seem useful if it glitch all time
13:51:29 <SamB> monochrom: irrefutable?
13:51:33 <SamB> or ible
13:51:38 <Philippa_> Keal: yerwhat?
13:51:58 <monochrom> heh, "irresistible" is a name I coin.  I couldn't resist. :)
13:52:16 <SamB> aka lazy, I think...
13:52:43 <monochrom> I enjoy asking you to read the doc.
13:53:12 <ihope> Last time I checked, Haskell wasn't glitchy...
13:53:13 <SamB> Keal: you mean all those GHC bugs?
13:53:29 <SamB> like with FFI, and all the stuff joelr ran into?
13:53:59 <SamB> and probably some GCC bugs too...
13:54:02 <Keal> :/
13:54:15 <monochrom> Thus, I ask you to take a look at http://www.haskell.org/onlinereport/exps.html#sect3.17.2  see point 2.
13:54:28 <Keal> you complain haskell always said undefined
13:54:46 <monochrom> Think of ~ as asking "postpone the evaluation"
13:55:03 * Keal goes for cig
13:55:09 * Keal need pick up baby bro soon
13:55:58 <monochrom> But really, (\() -> 3) and (\~() -> 3) show you exactly the difference and what ~ is about.  There is little to be said.
13:56:49 <SamB> since apparantly nobody wants to talk about Haskell anymore, anyone know where I can find manga torrents?
13:56:51 <monochrom> You may also like to try (\(x:xs) -> 3) and (\~(x:xs) -> 3)
13:57:22 <Philippa_> monochrom: what happens if there're multiple irrefutable patterns in a case statement?
13:57:26 <monochrom> Generally try it on any pattern with constructors.
13:57:41 <monochrom> Interesting, let me see the doc.
13:58:14 <SamB> > undefined :: String
13:58:15 <lambdabot> Undefined
13:58:43 <monochrom> > case undefined of {~[] -> 1; ~(x:xs) -> 2)
13:58:45 <lambdabot>  parse error on input `)'
13:58:49 <monochrom> > case undefined of {~[] -> 1; ~(x:xs) -> 2}
13:58:51 <lambdabot> 1
13:59:09 * ihope lubs the lazy evaluation
13:59:10 <monochrom> Oh haha, the earliest one is taken.
13:59:25 <monochrom> "Matching the pattern ~apat against a value v always succeeds"  the doc says.
13:59:34 <ihope> How about matching against ~_?
13:59:38 <monochrom> So, the computer will not look further.
13:59:50 <monochrom> > case [1,2] of {~[] -> 1; ~(x:xs) -> 2}
13:59:52 <lambdabot> 1
14:00:06 <monochrom> That reinforces the meaning of "always succeeds".
14:00:22 <ihope> Hmm...
14:00:25 <monochrom> Now of course if you actually do something non-trivial:
14:00:37 <Keal> philosophical mathematics question..
14:01:00 <Philippa_> monochrom: what happens if it doesn't match the constructor and you use it?
14:01:02 <Keal> do you think no two quantum events happen simultaneous in entire universe?
14:01:05 <monochrom> > case [] of {~(x:xs) -> x+1; ~[] -> 1}
14:01:06 <lambdabot>  Irrefutable pattern failed for pattern (x : xs)
14:01:22 <Philippa_> > case 1:[] of {~x@[] -> x}
14:01:24 <lambdabot>  Irrefutable pattern failed for pattern (x@[])
14:02:01 <monochrom> So, when the evaluation can no longer be postponed, it blows up.
14:02:07 <ihope> Boomy!
14:02:13 <Keal> how do i tell bot floor?  do i use _
14:02:37 <monochrom> So, ~ makes a promise and postpone checks.  If you break the promise, you will pay later, but not now.
14:03:17 <Keal> sounds biblical, monochrom
14:03:26 <monochrom> Think of it as filing a dishonest tax return.
14:03:59 <Keal> think of it as living in sin
14:04:03 <tre> And then spending the money you save on ALCOHOL.
14:04:06 <ihope> Keal: you mean checking for _|_? You can't do it.
14:04:28 <Keal> what you mean ihope
14:04:39 <ihope> _|_ = bot
14:05:46 <Keal> what is _|_
14:06:40 <ihope> It's either nontermination or an error.
14:06:55 <SamB> any undefined value
14:07:07 <SamB> like what error returns, or undefined, or an infinite loop...
14:07:13 <Keal> i want to tell bot floor
14:07:22 <SamB> or a failed pattern match in a let or case...
14:07:27 <Philippa_> Keal: you're not making sense
14:07:31 <ihope> What do you mean by "bot floor"?
14:07:33 <SamB> or a partial function, such as head...
14:07:44 <Keal> b*(Floor[v/b^p]/b-Floor[Floor[v/b^p]/b])
14:08:26 <Philippa_> that's not a haskell expression that actually means anything
14:08:27 <Keal> how i tell bot that
14:08:34 <Philippa_> I'm guessing there's a floor function called floor though
14:08:36 <Philippa_> > floor 1.2
14:08:37 <lambdabot> 1
14:08:37 <ihope> Ohh! lambdabot!
14:08:54 <ihope> Well, it depends of what v, b and p are.
14:09:02 <ihope> *on
14:09:25 <Philippa_> identifiers starting with a Capital are constructors, so it couldn't be Floor. That said, floor was always a likely bet
14:09:53 <Philippa_> also, [this] probably doesn't do what you expect
14:10:17 <ihope> Right. You probably want (these).
14:10:25 <Keal> > b*((floor (v / b ^ p)) / b - floor ( (floor (v / b ^ p)) / b))
14:10:26 <lambdabot>  Not in scope: `b'
14:10:36 <Keal> what that mean
14:10:50 <Philippa_> it means it doesn't know WTF b is
14:10:56 <ihope> It means you haven't given b a value.
14:10:57 <Keal> :(
14:10:59 <alar> > b*((floor (v / b ^ p)) / b - floor ( (floor (v / b ^ p)) / b)) where b=1.2
14:11:01 <lambdabot>  Not in scope: `p'
14:11:06 <Philippa_> how would it? You didn't say
14:11:06 <Keal> > d = b*((floor (v / b ^ p)) / b - floor ( (floor (v / b ^ p)) / b))
14:11:07 <lambdabot>  parse error on input `='
14:11:09 <alar> and so on
14:11:14 <Keal> > d == b*((floor (v / b ^ p)) / b - floor ( (floor (v / b ^ p)) / b))
14:11:15 <lambdabot>  Not in scope: `b'
14:11:19 <Philippa_> Keal: *it doesn't know where your variables came from*
14:11:28 <ihope> Maybe you want a function?
14:11:30 <Philippa_> you can't just use them without binding them anywhere
14:11:38 <Philippa_> d b v p = ...
14:11:41 <ihope> >\b p v -> b*((floor (v / b ^ p)) / b - floor ( (floor (v / b ^ p)) / b))
14:11:54 <Philippa_> and you can't feed that into the bot because it doesn't take function definitions
14:12:02 <Keal> > d v b p = b*((floor (v / b ^ p)) / b - floor ( (floor (v / b ^ p)) / b))
14:12:03 <lambdabot>  parse error on input `='
14:12:07 <Philippa_> ihope: you forgot to apply it
14:12:11 <Philippa_> Keal: what did I just say?
14:12:18 <Keal> :(
14:12:30 <ihope> Philippa: functions don't need to be applied...
14:12:36 <Philippa_> if you want to play with haskell properly, grab an interpreter
14:12:40 <Cale> > let fl = fromIntegral . floor in (\b v p -> round $ b*(fl (v/b^p) / b - fl (fl (v/b^p)/b))) 10 5678 0
14:12:40 <monochrom> Could we please not use lambdabot for troll code?
14:12:41 <lambdabot> 8
14:12:46 <Cale> > let fl = fromIntegral . floor in (\b v p -> round $ b*(fl (v/b^p) / b - fl (fl (v/b^p)/b))) 10 5678 1
14:12:48 <lambdabot> 7
14:12:50 <Philippa_> ihope: they can't be shown though, so what else're you going to do with it and the bot?
14:13:01 <Keal> bot seems useless
14:13:20 <Philippa_> monochrom: I don't think he's a troll, just that he doesn't speak english very well or have the sense to grab his own haskell implementation
14:13:28 <ihope> Keal: let d v b p = b*((floor (v / b ^ p)) / b - floor ( (floor (v / b ^ p)) / b)) in ...
14:13:29 <Cale> > let fl = fromIntegral . floor; digit b v p = round $ b*(fl (v/b^p) / b - fl (fl (v/b^p)/b))) in map (digit 10 5678) [0..3]
14:13:30 <lambdabot>  parse error on input `)'
14:13:33 <Keal> cale order of vars is v b p
14:13:33 <Philippa_> Keal: you don't know haskell well enough to judge that
14:13:52 <Keal> there is a function that does v
14:13:59 <Keal> a function that does v b
14:14:04 <Keal> and a function that does v b p
14:14:06 <Cale> > let fl = fromIntegral . floor; digit v b p = round $ b*(fl (v/b^p) / b - fl (fl (v/b^p)/b)) in map (digit 10 5678) [0..3]
14:14:08 <lambdabot> [10,0,0,0]
14:14:15 <Cale> > let fl = fromIntegral . floor; digit v b p = round $ b*(fl (v/b^p) / b - fl (fl (v/b^p)/b)) in map (digit 5678 10) [0..3]
14:14:17 <lambdabot> [8,7,6,5]
14:15:33 <Keal> what are you doing?
14:16:08 <Cale> using the function to extract the digits of 5678 in base 10
14:16:20 <SamB> hmm.
14:16:44 <ihope> flip digit 10...
14:16:51 <SamB> apparantly Conjure doesn't like the tracker for rippersanime.com
14:17:24 <Keal> Cale extract digits of pi now :)
14:17:41 <ihope> :-)
14:17:49 <Philippa_> I detect a homework question...
14:18:10 <ihope> Hey, why not make a way to code infinite-precision reals?
14:18:35 <SamB> ihope: its not hard
14:18:43 <SamB> it is impossible to compare them, though
14:18:47 <ihope> :-)
14:18:52 <SamB> at least for equality
14:18:52 <Cale> > let fl = fromIntegral . floor; digit v b p = round $ b*(fl (v/b^^p) / b - fl (fl (v/b^^p)/b)) in map (digit pi 10) [0,(-1)..(-10)]
14:18:53 <lambdabot> [3,1,4,1,5,9,2,6,5,3,5]
14:19:26 <ihope> How'd that song-thing go?
14:19:31 <Keal> > let fl = fromIntegral . floor; digit v b p = round $ b*(fl (v/b^^p) / b - fl (fl (v/b^^p)/b)) in map (digit pi 10) [0,(-1)..(-64)]
14:19:32 <lambdabot> [3,1,4,1,5,9,2,6,5,3,5,8,9,7,9,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
14:19:32 <lambdabot> 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
14:19:35 <Keal> haah
14:19:37 <Keal> bot stupid
14:19:44 <Cale> pi is a Double
14:19:53 <Cale> so there's only limited precision to it
14:20:10 <Keal> so have pi be formula for pi
14:20:24 <ihope> Keal: what is it? :-)
14:20:30 <Keal> no lcue
14:21:05 <ncalexan> You could approximate using well known series expansions (that's how calculators compute sin/cos)
14:21:25 <Keal> > let fl = fromIntegral . floor; digit v b p = round $ b*(fl (v/b^^p) / b - fl (fl (v/b^^p)/b)) in map (digit pi (sqrt 2)) [0,(-1)..(-64)]
14:21:27 <lambdabot> [0,1,0,1,1,0,1,1,1,0,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,1,0,1,0,1,
14:21:27 <lambdabot> 0,1,1,0,1,1,0,1,1,0,1,0,1,0,1,1,0,1,1,1,0,0,1,1,1,1,1,1,0]
14:21:40 <Keal> :/
14:22:00 <ihope> Hmm. I have pi right here...
14:22:24 <ihope> http://keithschofield.com/pi/std.html
14:22:25 <JKnecht> wow, did expect that here.
14:22:31 <JKnecht> but right on
14:23:23 <JKnecht> hmmm, requires QT.
14:23:24 <Cale> > let pi = g(1,180,60,2) where g(q,r,t,i) = let (u,y)=(3*(3*i+1)*(3*i+2),div(q*(27*i-12)+5*r)(5*t)) in y : g(10*q*i*(2*i-1),10*u*(q*(5*i-2)+r-y*t),t*u,i+1) in pi
14:23:26 <lambdabot> [3,1,4,1,5,9,2,6,5,3,5,8,9,7,9,3,2,3,8,4,6,2,6,4,3,3,8,3,2,7,9,5,0,2,8,8,
14:23:26 <lambdabot> 4,1,9,7,1,6,9,3,9,9,3,7,5,1,0,5,8,2,0,9,7,4,9,4,4,5,9,2,3,0,7,8,1,6,4,0,6,
14:23:26 <lambdabot> 2,8,6,2,0,8,9,9,8,6,2,8,0,3,4,8,2,5,3,4,2,1,1,7,0,6,7,9,8,2,1,4,8,0,8,6,5,
14:23:26 <lambdabot> 1,3,2,8,2,3,0,6,6,4,7,0,9,3,8,4,4,6,0,9,5,5,0,5,8,2,2,3,1,7,2,5,3,5,9,4,0,
14:23:26 <lambdabot> 8,1,2,8,4,8,1,1,1,7,4,5,0,2,8,4,1,0,2,7,0,1,9,3,8,5,2,1,1,0,5,5,5,9,6,4,4,
14:23:28 <monochrom> Mathematica (and similar programs) are infinite precision, by keeping Pi as Pi and Sqrt[2] as Sqrt[2].  Thus, it can tell you Sqrt[2]^2 = 2.  No numerical error.  "Infinite precision."
14:23:28 <lambdabot> [23 @more lines]
14:23:55 <Cale> there you go.
14:24:15 <alar> i387+ know pi with precision one digit more than it can handle =)
14:24:41 <ncalexan> Cale: what series is that?  (Or what approximation)
14:25:14 <Cale> http://web.comlab.ox.ac.uk/oucl/work/jeremy.gibbons/publications/spigot.pdf
14:25:41 <Cale> It's Rabinowitz and Wagon's algorithm in a somewhat obfuscated compact form.
14:26:11 <Cale> or based on it anyway
14:26:55 <Keal> that video was nonsensical
14:27:08 <JKnecht> the 'Brainman' savant can recite 20,000 digits of pi.
14:27:29 <KirinDave> Sweet moses, what is that Pi video?
14:27:32 <KirinDave> It's like, insane.
14:27:39 <Keal> my formula breaks matheamtica tho
14:28:42 <KirinDave> Oh my god. It's like Pi invokes Through The Looking GLass Rap.
14:28:59 <ihope> Sigh. I found a link somewhere to http://pi.ytmnd.com/
14:29:04 <ihope> That lead to that video.
14:29:09 <SamB> @type Text.ParserCombinators.Parsec.runParser
14:29:10 <lambdabot> forall a tok st.
14:29:10 <lambdabot> Text.ParserCombinators.Parsec.Prim.GenParser tok st a
14:29:10 <lambdabot> -> st
14:29:10 <lambdabot> -> Text.ParserCombinators.Parsec.Pos.SourceName
14:29:10 <lambdabot> -> [tok]
14:29:12 <lambdabot> -> Either Text.ParserCombinators.Parsec.Error.ParseError a
14:29:16 <Keal> > let fl = fromIntegral . floor; digit v b p = round $ b*(fl (v/b^^p) / b - fl (fl (v/b^^p)/b)) in map (digit pi .1) [0,(-1)..(-64)]
14:29:17 <lambdabot>  add an instance declaration for (Show (b -> b1))
14:29:33 <Keal> ?
14:29:41 <Cale> 0.1
14:29:52 <Keal> > let fl = fromIntegral . floor; digit v b p = round $ b*(fl (v/b^^p) / b - fl (fl (v/b^^p)/b)) in map (digit pi 0.1) [0,(-1)..(-64)]
14:29:54 <lambdabot> [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
14:29:54 <lambdabot> 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
14:30:12 <Keal> > let fl = fromIntegral . floor; digit v b p = round $ b*(fl (v/b^^p) / b - fl (fl (v/b^^p)/b)) in map (digit pi 0.1) [0,(-1)..(64)]
14:30:13 <lambdabot> []
14:30:35 <ncalexan> 64? or (-64)?
14:30:39 <Keal> 64
14:30:50 <Keal> i reversed the direction of the digits
14:31:05 <Cale> > let fl = fromIntegral . floor; digit v b p = round $ b*(fl (v/b^^p) / b - fl (fl (v/b^^p)/b)) in map (digit pi 0.1) [0,1..64]
14:31:05 <ncalexan> > [0,(-1)..64]
14:31:06 <lambdabot> [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
14:31:06 <lambdabot> 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
14:31:07 <lambdabot> []
14:31:10 <ncalexan> Not so much :)
14:31:19 <Keal> i know why
14:31:25 <Cale> > let fl = fromIntegral . floor; digit v b p = round $ b*(fl (v/b**p) / b - fl (fl (v/b**p)/b)) in map (digit pi 0.1) [0,1..64]
14:31:27 <lambdabot> [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
14:31:27 <lambdabot> 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
14:31:27 <Keal> is that bot using haskell?
14:31:41 <ihope> I think it's a mod of GHC...
14:31:44 <SamB> Keal: yuppers!
14:31:46 <Cale> yeah, it evaluates Haskell expressions.
14:31:48 <Keal> then that is a glitch
14:31:48 <SamB> ihope: not a mod
14:32:02 <Keal> its only returning whole numbers
14:32:09 <Keal> it is flooring all results
14:32:17 <Cale> rounding actually
14:32:18 <SamB> Keal: how's that a glitch?
14:32:19 <Keal> which is not what the expression does
14:32:26 <Keal> Cale its not supposed to round
14:32:29 <Cale> > let fl = fromIntegral . floor; digit v b p = b*(fl (v/b**p) / b - fl (fl (v/b**p)/b)) in map (digit pi 0.1) [0,1..64]
14:32:31 <lambdabot> [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,
14:32:31 <lambdabot> 0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.
14:32:31 <lambdabot> 0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,
14:32:31 <lambdabot> 0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0]
14:32:31 <SamB> Keal: thats what Cale's expression says...
14:32:34 <ihope> SamB: it's obviously not *exactly* the same, otherwise it wouldn't be here on IRC.
14:32:48 <SamB> it says right here: "fromIntegral . floor"
14:33:14 <Cale> > let fl = fromIntegral . floor; digit v b p = b*(fl (v/b**p) / b - fl (fl (v/b**p)/b)) in map (digit pi 0.1) [0,(-1)..(-10)]
14:33:16 <lambdabot> [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0]
14:33:33 <Keal> > let fl = fromIntegral . floor; digit v b p = b*(fl (v/b**p) / b - fl (fl (v/b**p)/b)) in map (digit pi 1.7) [0,(-1)..(-64)]
14:33:33 <ihope> I want a way to have fractional number bases...
14:33:34 <lambdabot> [1.2999999999999998,1.6000000000000003,0.4999999999999997,1.400000000000001
14:33:34 <lambdabot> ,0.5000000000000012,1.5000000000000007,0.1999999999999993,0.500000000000004
14:33:34 <lambdabot> 2,1.3999999999999828,1.4000000000000312,0.6000000000000341,1.60000000000009
14:33:34 <lambdabot> 1,0.8000000000000455,0.0,0.3000000000005002,0.7000000000009095,0.5999999999
14:33:34 <lambdabot> 994543,0.10000000000145519,0.3999999999996362,0.0,0.8000000000116415,0.
14:33:36 <lambdabot> [10 @more lines]
14:33:40 <Keal> yay i show you!
14:33:43 <Philippa_> Keal: I strongly suggest that unless you know haskell well enough to understand *exactly* what the code being thrown around here does that you stop talking about glitches as soon as you don't understand what's going on
14:33:44 <SamB> anyway, if the code doesn't behave as expected, don't start complaining about glitches
14:33:52 <Philippa_> snap!
14:33:54 <SamB> simply say that the code is wrong
14:34:19 <Keal> see above is base 1.7 for pi
14:34:25 <monochrom> "The human mind doesn't work."  I used to say.
14:34:27 <SamB> also, note that most glitches involve FFI or RTS arcana
14:34:43 <SamB> if you don't know what that means, you probably haven't encountered them
14:35:17 <Keal> see above is base 1.7 for pi
14:35:31 <ihope> But those are whole numbers, almost.
14:35:40 <ihope> The rest seems to be rounding error
14:35:40 <Keal> ok i just calim Cale typed it wrong
14:36:19 <SamB> also, usually the term "glitch" involves that the program is mostly working
14:36:19 <Keal> they are not whole numbers
14:36:21 <Keal> it wraps
14:36:32 <SamB> er, implies
14:36:45 <ihope> Whole numbers, plus rounding error, I believe.
14:36:59 <Keal> it wraps dammit
14:37:11 <Keal> see no comma after number mean it wraps to next line
14:37:23 <ihope> Mmh,
14:37:50 <Philippa_> at which point you get a load more nines followed by ~an epsilon's difference
14:38:18 <Keal> btw theoretically if i plugged enough of those style evals in, lambdabot's floating point portion of cpu will fry
14:38:41 <Philippa_> wow, check out the 1337 /-\4x012
14:38:46 <jip> ok, i have a serious question now for Cale
14:38:54 <Keal> so yes math itself can be malicious ;)
14:38:58 <Cale> jip: thanks :)
14:39:00 <Philippa_> eventually all hardware fails, big deal
14:39:09 <SamB> Keal: just lovely! and dons was so happy to have her on her on box too!
14:39:16 <SamB> s/on/own/
14:39:44 <Keal> i have a theory that this expression was the reason library of alexandria burned down, their crappy primitive computers couldnt handle it :0
14:39:55 <Keal> proof is in recovered table of nines artifact
14:40:03 <ihope> Wait, which expression?
14:40:09 <jip> Cale: you are familiar with the ideas behind fruit, right?
14:40:17 <Keal> when i put what i dat recoved from that tile into a ti92. the damn thing blew up
14:40:22 <SamB> Keal: um
14:40:23 <Cale> jip: I've never used fruit
14:40:27 <SamB> it was burned, was it not?
14:40:32 <jip> Cale: but you've read the paper, right?
14:40:41 <Cale> jip: quite a while back
14:40:44 <SamB> I mean, didn't somebody burn it down on purpose?
14:41:00 <Cale> jip: let me just refresh myself on which one it is
14:41:00 <Keal> not really
14:41:04 <jip> Cale: ok, but you know how the idea is that a widget takes some input signals, and outputs a Picture?
14:41:14 <Keal> my theory is they had some sort of primitive computer that caught fire
14:41:29 <jip> wasn't it burned down for religious reasons?
14:41:51 <KirinDave> Keal: That's... just... amazing. You really do it all. Science, Math, Cryptography, Anthropology, History...
14:41:57 <Cale> jip: okay, right, this is the one with Arrows
14:41:59 <SamB> Keal: I'm pretty sure some idiots burned it down for some stupid reason
14:42:40 <SamB> I mean, they tend to keep mad scientists from experinmenting in libraries...
14:42:42 <Shapr-nokia770> Y0
14:42:48 <SamB> hello
14:42:55 <SamB> are you phoning us shapr?
14:42:57 <jip> Cale: yeah, so a widget outputs a Picture... and you can combine 2 widgets together, the semantic output of the first goes into the semantic input of the 2nd, and the Picture output of them both is drawn one next to the other
14:43:10 <Cale> jip: yeah
14:43:14 <SamB> or is that some kind of PocketPC or something like that?
14:43:27 <KirinDave> Ancient Egyptian PocketPC?
14:43:30 <Cale> jip: at least, that's one way to connect them
14:43:52 <jip> Cale: ok, but basicly you put together a bunch of widgets and you end up with one big Picture in the output, right?
14:44:04 <Shapr-nokia770> SamB, not exactly, I'm using my nokia 770 handlet and a random open wifi
14:44:44 <SamB> Shapr-nokia770: are you STEALING internet?
14:44:56 <Cale> jip: presumably
14:45:26 <jip> Cale: ok, but the problem is that with this sytem, every frame, you have to render the entire picture, right?
14:45:31 <ihope> Hmm? Internet?
14:45:37 <SamB> conjure's BEncode handling is having issues...
14:45:48 <Cale> jip: maybe, maybe not.
14:45:59 <Lemmih> SamB: Really?
14:46:04 <Cale> It's up to the implementation to decide what needs to be drawn
14:46:09 <SamB> Lemmih: yes!
14:46:20 <SamB> not sure what kind yet.
14:46:40 <jip> Cale: ok, but the only real option for optimization is to compare the previous picture with the current one and someone find the difference
14:46:42 <ihope> What's the Internet? What's IRC? What's Haskell?
14:46:49 <Cale> jip: really?
14:46:58 <jip> Cale: what else can you do?
14:47:11 <Lemmih> SamB: How is it having issues?
14:47:19 <ncalexan> jip: two techniques are dirty rectangles and, if you're doing a widget set, propogating state changes up the widget hierarchy.
14:47:29 <ncalexan> (Dirty rectangles apply to sprite drawing.)
14:47:52 <jip> ncalexan: ok well i don't think that either of these techniques can be applied to the fruit model
14:47:55 <Keal> ihope: b*(Floor[v/b^p]/b-Floor[Floor[v/b^p]/b])
14:47:57 <SamB> Lemmih: well, it isn't working with the tracker for rippersanime.com, apparantly
14:47:58 <Keal> that one
14:48:13 <Cale> jip: have you looked at the actual library
14:48:14 <Cale> ?
14:48:24 <Lemmih> SamB: It fails to parse some BEncoded data?
14:48:30 <SamB> Lemmih: yes
14:48:33 <Keal> anways i need to leave for bookstore now
14:48:38 <jip> Cale: not really, but i have a strong feeling that they just render everything each frame
14:48:38 <ncalexan> jip: no?  I thought fruit followed the container packed with widgets paradigm... then you could be clever about redrawing unchanged widgets.
14:48:46 <Lemmih> SamB: Got the data round?
14:48:49 <SamB> though to be fair, I can't figure out how to parse it myself
14:48:50 <Keal> baby bro need to be pick up from after work
14:49:05 <SamB> "2c \r\nd8:intervali1800e12:min intervali300e5:peers\r\n1  \r\nl\r\n82 \r\nd2:ip12:82.74.151.757:peer id20:-UT1400-\146\129`\USU\SO\135\DC1\240*,\145\&4:porti14600eed2:ip11:64.0.113.937:peer id20:vulftqfsyrrkdzvrsjaa4:porti3000ee\r\n84 \r\nd2:ip13:84.43.101.1717:peer id20:-BC0061-=-\195/\246\243\\@K\SI\194q4:porti65535eed2:ip11:64.0.113.937:peer id20:qbblqxxxdlyoujlqfcsq4:porti3000eee\r\n15 \r\n10:tracker id5:11955e\r\n0\r\n\r\n"
14:49:08 <Lemmih> SamB: It's invalid?
14:49:17 <jip> ncalexan: in terms of layout yet, but in fruit the widgets themselves don't even know when they change
14:49:31 <SamB> Lemmih: well, not in the wiki.theory.org spec
14:49:33 <jip> Cale: anyway, my idea is to somehow analyze the input to each widget
14:49:48 <jip> Cale: if the input is the same as it was the previous frame, then the output will be the same and then you know that you don't have to redraw
14:49:49 <Cale> jip: Your application of combinators to this abstract type could, for all you know, be writing a bunch of GTK calls which just have the semantics you want.
14:50:09 <jip> Cale: hm... i think that's what i mean :)
14:50:28 <Cale> Everything is hidden in the arrow, you don't get to see how it's implemented.
14:50:35 <Cale> It can be arbitrarily optimised.
14:50:42 <jip> Cale: yeah..... that's what i was thinking, it's all in the arrow
14:53:11 <ncalexan> jip: one of the Yampa papers talks about optimising the stream so that Events don't get polled too often.  That sounds pretty similar to what you want.
14:53:26 <Keal> > let fl = fromIntegral . floor; digit v b p = b*(fl (v/b**p) / b - fl (fl (v/b**p)/b)) in map (digit pi -3) [0,(-1)..(-64)]
14:53:27 <lambdabot>  add an instance declaration for (Show (a -> a))
14:53:34 <SamB> Lemmih: hmm, probably there is a problem somewhere else...
14:53:41 <Keal> what i do wrong
14:54:14 <Shapr-nokia770> I couldn't carry the internet if I stole it.
14:55:14 <jip> ncalexan: what i'd like to do is optimize the stream so that when the signal in an input stream to an arrow changes i can get this message out somehow
14:55:17 <ihope> > (map head . words) "Waters are vertical! Eep!"
14:55:19 <franka> Any GHC type checker hackers here?
14:55:19 <lambdabot> "WavE"
14:55:29 <ihope> > (map head . words) "Really annoying poetry"
14:55:31 <lambdabot> "Rap"
14:55:37 <ihope> :-)
14:56:03 <alar> =)
14:56:09 <Keal> > let fl = fromIntegral . floor; digit v b p = b*(fl (v/b**(p+q)) / b - fl (fl (v/b**(p+q))/b)) in map (digit pi 10) [0,(-1)..(-64),(0..<1)]
14:56:10 <lambdabot>  parse error on input `,'
14:56:13 <Keal> :/
14:56:17 <ncalexan> jip: there's a combinator to do that... isn't that &&&?
14:56:32 <ncalexan> jip: perhaps with an edge function?
14:56:54 <jip> ncalexan: no, i want something on a totally different level
14:57:15 <SamB> Lemmih: okay, that really seems to be what the server is returning...
14:57:46 <Keal> how do i have bot prove that for each sum of all digit*b^(p+q) for p that that sum is same over all q 0..<1
14:58:00 <SamB> Lemmih: oh, it seems to be using some strange HTTP option
14:58:04 <Keal> Cale
14:58:11 <Keal> i need help i ask again when i come home
14:58:15 <SamB> Transfer-Encoding: chunked
14:58:44 <ihope> Keal: probably list comprehensions...
14:58:51 <SamB> Lemmih: should we switch to a real HTTP library?
15:01:46 <monochrom> >:-)
15:02:30 <monochrom> >():[]
15:03:03 <monochrom> >1
15:03:09 <monochrom> > 1
15:03:10 <ihope> > :-)
15:03:11 <lambdabot> 1
15:03:11 <lambdabot>  parse error on input `:-'
15:03:17 <monochrom> > ():[]
15:03:18 <lambdabot> [()]
15:03:24 <ihope> > []:()
15:03:25 <lambdabot> Couldn't match `[[a]]' against `()'
15:03:42 <monochrom> Let's have a contest on designing emoticons that parse. :)
15:03:52 <ihope> > (:)
15:03:53 <lambdabot>  add an instance declaration for (Show (a -> [a] -> [a]))
15:03:58 <alar> =)
15:04:02 <ihope> > =)
15:04:04 <lambdabot>  parse error on input `='
15:04:12 <ihope> > (=)
15:04:14 <lambdabot>  parse error on input `='
15:04:41 <ihope> > [P-)]
15:04:42 <lambdabot>  parse error on input `)'
15:04:53 <alar> ﬁ (==)
15:04:58 <alar> > (==)
15:04:59 <lambdabot>  add an instance declaration for (Show (a -> a -> Bool))
15:05:01 <ihope> Oh my
15:05:03 <jip> > 8-3
15:05:05 <lambdabot> 5
15:05:10 <lispy> we had a good one orce
15:05:21 <lispy> and if you use my numlist code you can get a few more
15:05:22 <alar> > --)
15:05:24 <lambdabot>  parse error on input `}'
15:05:28 <ihope> > (8-)
15:05:29 <lambdabot>  add an instance declaration for (Show (a -> a))
15:05:46 <ihope> > !-?
15:05:47 <lambdabot>  parse error on input `!-?'
15:05:52 <ihope> Aww.
15:07:38 <lispy> > (:=<<)
15:07:40 <lambdabot>  Not in scope: data constructor `:=<<'
15:07:46 <lispy> > (:)=<<
15:07:46 <ihope> Does anybody use MemoServ?
15:07:47 <lambdabot>  parse error on input `}'
15:07:55 <lispy> ihope: not i
15:08:20 <ihope> Well, *should* I use it to send something to a person who's not online?
15:08:24 <franka> Does anyone know of any extensions of THIH with higher-rank polymorphism?
15:08:35 <Cale> ihope: you could, but you can't expect them to read it
15:08:45 <Cale> ihope: email is better ;)
15:08:50 <ihope> :-)
15:09:13 <SamB> ihope: I might notice a memo
15:09:17 <ihope> How do I find the person's address?
15:09:35 <SamB> ihope: look through "darcs changes" on a repo they've contributed to
15:09:53 <SamB> it helps if you know their real name
15:10:37 * ihope sends a memo to lambdabot
15:10:59 <SamB> lambdabot will probably not notice it
15:11:22 <SamB> seeing as lambdabot is unlikely to have any MemoServ-related plugins
15:11:52 <ncalexan> One wonders what lambdabot would reply with...
15:12:37 <SamB> ncalexan: the results of the command you memo'd her with, of course ;-)
15:13:04 <KirinDave> lispy: I asked your question.
15:13:08 <KirinDave> lisp: About _|_
15:13:13 <SamB> Lemmih: the *real* data is "d8:intervali1800e12:min intervali300e5:peersld2:ip12:82.74.151.757:peer id20:-UT1400-`U√∞*,4:porti14600eed2:ip11:64.0.113.937:peer id20:vulftqfsyrrkdzvrsjaa4:porti3000eed2:ip13:84.43.101.1717:peer id20:-BC0061-=-√É/√∂√≥\@K√Çq4:porti65535eed2:ip11:64.0.113.937:peer id20:qbblqxxxdlyoujlqfcsq4:porti3000eed2:ip11:64.0.113.937:p"
15:13:30 <KirinDave> lispy: It turns out the answer is "no, it is nothing like undefined in haskel :)"
15:14:01 <Cale> KirinDave: what was the question?
15:14:29 <KirinDave> Cale: is the infinite type of a dynamic language like ruby, python or smalltalk equivalent to the undefined value of haskell.
15:14:51 <KirinDave> Cale: I saw in a log he didn't know why some dynamic languages are called "typeless," so we were talking about it. :)
15:14:51 <Cale> infinite type?
15:14:54 <KirinDave> Yes.
15:14:56 <Lemmih> SamB: Does 'wget' get the correct data?
15:15:06 <SamB> Lemmih: curl does
15:15:37 <SamB> wget is apparantly forbidden
15:15:48 <KirinDave> Cale: In Ruby, Python, Io, and Smalltalk (for example) there are no types, because type signatures can be infinitely big because of doesNotImplement/doesNotRespond/method_missing/forward allow them to be defined programatically.
15:17:35 <Lemmih> SamB: You could add it to the TODO file.
15:17:59 <SamB> there *is* a real library available
15:18:00 <monochrom> That's misleading.  There are infinitely many natural numbers, and yet we can summarize them by one symbol N.  I am saying, just because an object supports/not-supports infinitely many methods doesn't mean a finite type signature cannot be written.
15:18:07 <SamB> written in Haskell, even
15:18:29 <Cale> yeah, I'd think it would just mean that you need a more expressive type system
15:18:39 <KirinDave> monochrom: It can't really be computed either, since you'd have to enumerate every possible output value for a method_missing method.
15:20:19 <monochrom> Isn't there no more than one output value for a method_missing method?  Am I misunderstanding "method_missing"?
15:20:56 <KirinDave> monochrom: A common joke with method_missing is to make "Roman" class such that when you send a message to a class, it interprets it as a roman numeral and outputs a number.
15:21:30 <KirinDave> But you could, for example, output the current time of day every time you sent a message to that object.
15:21:45 <KirinDave> There's no real limit to what can happen, especially in Actor based languages.
15:22:58 <KirinDave> In Ruby, for example, there is no way to tell if an object is a string, or merely a pretender acting very much like a string, but really shoveling all your operations into a logfile and returning garbage.
15:24:05 <monochrom> In the latest example, you can still give it the string type.  It breaks referential transparency, that's all.
15:24:33 <KirinDave> Well, you can call it a string if that makes you feel comfortable. :D
15:24:39 <KirinDave> But that doesn't mean it is a string.
15:25:17 <KirinDave> It's a real problem when trying to use Ruby's $SAFE mechanism, because someone could construct a malicious return object and fool you into running values in a privledged state if you're not careful.
15:25:38 <franka> What is the difference between a string and something that acts like a string?
15:25:41 <chucky> KirinDave: You could likely test if something is REALLY a string by using Ruby's C interface
15:25:50 <chucky> (but that would really be cheating)
15:25:58 <KirinDave> chucky: Yes. it would be. :)
15:26:21 <KirinDave> franka: Well what if has all the outward appearance of a string, but really is doing things remotely on another machine? :D
15:26:43 <franka> Huh?
15:26:47 <jip> KirinDave: doesn't ruby have something like python's "type"?
15:27:00 <KirinDave> jip: It has a class call, but that means 0, since classes are open.
15:27:18 <KirinDave> And heck, even individual instances of classes can have unique responses that are only set for *that particular object*
15:27:26 <franka> What I am asking is, how do you distinguish a string from a nonstring?
15:27:31 <KirinDave> franka: You cannot.
15:27:35 <binary42> class typing can be useful in ruby still but it is a rare mechanism in most code.
15:27:48 <jip> KirinDave: well in python if type(a) says str then a is absolutely a string
15:27:49 <franka> If you cannot, then the ability to masquerade as a string is not very significant, is it?
15:27:57 <KirinDave> jip: Ruby has no such mechanism.
15:28:09 <KirinDave> franka: What's not very significant is the concept of type. :D
15:28:13 <jip> KirinDave: this should be filed as a bug then :P
15:28:15 <KirinDave> franka: In ruby.
15:28:25 <KirinDave> jip: No, people exploit it.
15:28:27 <monochrom> Babara Liskov's principle of substitution will say the malicious object has type string.
15:28:40 <franka> My point is that what you are describing is a defect, not a feature.
15:28:51 <binary42> =D Ruby makes use of this relativity in great lengths though. It is one power of dynamic languages.
15:28:53 <KirinDave> franka: The ruby community feels it is a feature and write code that exploits it.
15:29:02 <KirinDave> It's called duck typing.
15:29:04 <jip> KirinDave: they exploit a missing query operation? :O
15:29:25 <franka> That's great for the Ruby community, but not my point.
15:29:30 <KirinDave> jip: There is no possible query operation that makes sense. You'd have to validate that the methods do what you expect over all possible inputs. It's impossible.
15:29:30 <binary42> jip: that too (but that is more about interface than typing)
15:30:29 <chucky> you could ensure most of the safety you might want by freezing stuff though, I imagine
15:30:37 <franka> Besides, how do you exploit the fact that you have LESS information about objects?
15:30:55 <KirinDave> You should check out duck typing.
15:31:06 <binary42> it is not that you have less. It is that libraries and interfaces are designed to work with that.
15:31:06 <franka> That is like saying I am going to exploit my ignorance about boxing to win the championship.
15:31:10 <binary42> like collections.
15:31:11 <KirinDave> However, I'm not here to singlehandedly take on #haskell. :D
15:31:12 <monochrom> That. The caller has less information.  The callee has more freedom.
15:31:18 <binary42> include Enumerable
15:31:29 <binary42> you now have an object that has all kinds of nice stuff.
15:31:32 <monochrom> The callee has freedom to fool the caller.  Thus the callee can exploit.
15:31:40 <binary42> as long as it has #each
15:31:40 <franka> It IS that you have less.
15:31:44 <KirinDave> binary42: But at least I am hanging out here and watching the code that flashes by. You've convinced me that far. :D
15:31:59 <franka> But nobody likes to admit it.
15:32:01 <monochrom> Thus, of course, you cannot exploit your ignorance, but I can.
15:32:03 <KirinDave> franka: It's more that both sides have fewer constraints. By definition, that's less information you can rely on.
15:32:09 <KirinDave> franka: So yes.
15:32:21 <KirinDave> monochrom: That's a quotable. :)
15:33:02 <franka> No, there is a difference between being free to do something and not knowing that you are not free to do it.
15:33:08 <monochrom> ocaml can achieve duck typing too.
15:33:29 <binary42> sometimes a rule can get in the way. In Haskell the type system is very powerful so it isn't as big of a problem but compare to something like Java and you might understand.
15:33:30 <franka> If someone sticks me in a prison cell, and I close my eyes and imagine a green field, I am still in the cell.
15:33:42 <astrolabe> Are there well known problems that you can't solve with static typing?
15:33:47 <KirinDave> Haha.
15:33:48 <monochrom> But there are two parties, franka.  One party has less information, the other party will exploit that.
15:33:55 <chucky> franka: Yes, but if you never find out you're in that cell, wouldn't you still be just as happy?
15:34:13 <franka> Who are the two parties?
15:34:21 <monochrom> caller, callee.
15:34:23 <KirinDave> franka: For example, a library developer and a library user.
15:34:29 <binary42> astrolabe: 
15:34:33 <binary42> no.
15:34:41 <binary42> It is about style.
15:34:50 <binary42> the whole lisp vs haskell stuff.
15:34:54 <KirinDave> franka: I may have a UTF-8 string, and you may no nothing of it. However, because it quacks like a string, your library will cheefully use it.
15:35:05 <KirinDave> Erhem, know nothing.
15:35:09 <binary42> I think we can all imagine what would ensue if we went down that path.
15:35:18 <KirinDave> yeah. Not my intent. :D
15:35:21 <monochrom> Well I suppose if caller code is written with that in mind it won't be fooled by the callee, in fact it doesn't have to call the callee at all.  In fact you can just say let's never write programs, then no exploitation.
15:35:28 <KirinDave> I do not believe either is universally superior,personally. :D
15:35:53 <KirinDave> There are problems that are easier one way or easier another.
15:36:00 <astrolabe> What is an advantage of dynamic typing?
15:36:09 <franka> KirinDave, you just told me that there is no such thing as a string in Ruby.
15:36:38 <KirinDave> franka: Well, there isn't. There is what is a way to create what is commonly believed to be a string in ruby.
15:36:44 <jip> KirinDave: ok but python can do all this stuff too, you can have a class emulate a string, but it still allows you to check the absolute type of an object when you really want to. i don't see why you should forbid this
15:36:49 <monochrom> An advantage of dynamic typing is that you can make the type system undecidable.
15:36:50 <binary42> astrolabe: how I develop in Haskell in comparison to Ruby is like night and day. The way I think about things is at the root I think. It will be hard to quantify though.
15:36:59 <KirinDave> But people generally know not to mess with String.
15:37:09 <chucky> jip: Because Ruby's type system doesn't know it's a string
15:37:11 <KirinDave> jip: I have stronger feelings about Python. I don't want to discuss them.
15:37:11 <franka> Untyped languages have no type system, by definition.
15:37:16 <franka> There is nothing to make undecidable.
15:37:59 <KirinDave> I am sorry for suddenly creating such a stir then running away, but I have a birthday dinner to make it to.
15:38:02 <monochrom> But I claim that Ruby etc. are dynamically typed, not untyped.  They are nothing like untyped lambda calculus.
15:38:15 <jip> chucky: i'm sure that in the internals ruby does know that it's a string.... otherwise the implementation would be horribly slow
15:38:17 <franka> There you are wrong, monochrom.
15:38:24 <KirinDave> monochrom: You should check out Io. It's even more loose. :D
15:38:37 <binary42> In ruby type is a behavior not a tag. People get confused with this when they first come to ruby.
15:38:42 <chucky> jip: It does. But the model of the object system that ruby exposes knows nothing about strings. It only knows about objects
15:38:50 <chucky> a class is an object as well
15:39:00 <monochrom> I actually have no problem with type = behaviour.
15:39:03 <jip> chucky: also in python a class is an object
15:39:19 <KirinDave> jip: The way it works is that String's default internals are all CFuncs, so you get good performance.
15:39:36 <KirinDave> jip: But it's no secret that python is faster than ruby, so it shouldn't shock you when you hear of an implementation detail that points to that. :D
15:39:42 <franka> If you compare Haskell programs to Ruby programs, and you call a type in Haskell something different from a type in Ruby, then you cannot compare the type erasure of  Haskell code sensibly with ordinary Ruby code.
15:40:07 <chucky> kirindave: that's because ruby has a worse implementation than ruby. I think it could easily be as fast
15:40:07 <KirinDave> franka: Which brings us full circle to lispy's question to me. :D
15:40:18 <KirinDave> chucky: Maybe.
15:40:26 <KirinDave> I don't work much on the Ruby interpreter.
15:40:30 <KirinDave> Anyways, really, gotta dash.
15:40:32 <chucky> and I have a master's thesis to prove it (well, not really, but still)
15:41:08 <jip> well, he's gone... time to change the subject :P
15:41:09 <binary42> franka: to me it is about when the binding of the type happens. In ruby the code must be running to be sure of things. In Haskell it is completely static so it can be at compile time. That is my view between behavior and tagging.
15:41:41 <monochrom> me too (if I understand binary42 correctly)
15:42:00 <binary42> jip: :) I've been pushing him towards Haskell for a little while. It took some time for it to happen.
15:42:18 <franka> What is the difference between Ruby's run-time "type" checking, and a case-expression in Haskell?
15:42:57 <dons> @seen Philippa_
15:42:58 <lambdabot> I saw Philippa_ leaving #flippi, #scannedinavian, #haskell-overflow, #
15:42:58 <lambdabot> haskell-blah and #haskell 26 minutes and 58 seconds ago.
15:43:01 <binary42> In ruby messages always have a target. That itself is a dynamic form of typing.
15:43:25 <jip> sometimes i feel like i'm in the movie the matrix - haskell is the real world - and i sometimes wish that i was never introduced to the real world because it is a hard world, things were nice back in the matrix
15:43:40 <jip> you guys know what i mean?
15:43:50 <binary42> so ruby can have a comparison op for Object#class and that will give back String but that could be determined by change at runtime.
15:43:52 <monochrom> Yes, but I feel the other way round.
15:43:55 <SyntaxNinja> like the IO monad?
15:44:32 <binary42> mmm. not really.
15:44:47 <jip> i mean like c++ used to taste like good steak, but now that i've been exposed to the real world i know that c++ is fake, but i still sort of wish that i never new about the real world so i could have kept using c++ all along
15:45:05 <palomer> I disagree
15:45:07 <jip> since this haskell shit can be really painful sometimes
15:45:10 <palomer> haskell is still a pain to do anything useful
15:45:15 <jip> yeah
15:45:23 <binary42> c++ has hell IMO ;-)
15:45:23 <jip> that's my point
15:45:31 <binary42> s/has/was/
15:45:46 <monochrom> Oh, but in Haskell you get parametric polymorphism by just thinking, whereas in C++ you have to do physical work.
15:46:03 <binary42> Haskell is getting better over time. I wonder if it will still be Haskell when we end up seeing mass use of its concepts.
15:46:37 <chucky> binary42: Have you seen the stuff they're putting in the new versions of C#?
15:46:43 <binary42> yes.
15:46:44 <chucky> local type inference, for example
15:46:56 <binary42> It is ok but a _long_ ways from Haskell.
15:47:05 <jip> c# will have lambda functions and type inference... but still no tuples
15:47:30 <SamB> no tuples!
15:47:31 <chucky> yeah, but then 10 years from now C# will "invent" tuples (but they will be called something else and be much harder to use)
15:47:34 <SamB> thats... horrible!
15:47:49 <SamB> chucky: surely it won't take them ten years!
15:48:01 <SamB> they do actual employ Haskell hackers, after all!
15:48:05 <monochrom> A class with all public fields and not much of methods, that is, a record, is a tuple.
15:48:12 <chucky> samb: type inference was invented in the 60s, wasn't it? :)
15:48:37 <SamB> chucky: weren't tuples invented hundreds of years ago?
15:48:46 <chucky> and C# 3.0 (with local type inference) isn't out yet.
15:49:04 <chucky> probably. But you may be right, 10 years might be too much
15:50:09 <monochrom> http://lambda-the-ultimate.org/node/view/1227  "New for Python 2.5"
15:50:41 <SamB> no, no!
15:50:54 <SamB> a tuple is just a bunch of stuff thrown together
15:51:03 <SamB> if you have to define a type it isn't a tuple...
15:51:39 <monochrom> A tuple has a type.  The type has to be defined by someone somewhere.
15:52:16 <SamB> monochrom: in the standard lib
15:52:25 <SamB> or the compiler
15:52:26 <sproingie> things staying in 2.5: two separate and subtly different object systems.  reference counting.  read-only closures.
15:53:27 <SamB> sproingie: haskell does just fine with read-only closures, you notice, and nobody ever complains...
15:53:52 <monochrom> In fact we're also fine with read-only integers.
15:54:04 <SamB> Pythonites don't complain about that...
15:54:39 <monochrom> But by that I mean this: "x = 1;"  In Haskell henceforth we don't change x, but in Python they do.
15:55:04 <binary42> well, there is a difference between imperative languages with r/o closures and a functionally pure language with r/o closures.
15:55:07 <SamB> monochrom: oh, well, thats called a mutable variable
15:55:14 <SamB> if you changed the actual int object, there would be trouble
15:55:29 <monochrom> Heh, so, we're fine with read-only variables!
15:55:32 <SamB> i.e. if you somehow incremented 1, you'd get stuff like:
15:55:37 <SamB> >>> 1
15:55:38 <SamB> 2
15:55:56 <monochrom> In ocaml strings are mutable.
15:56:15 <binary42> that is when you look at what values are immediate and which will be references.
15:56:40 <binary42> 1 = 1 + 1 makes no sense and that is why numbers are often immediate types.
15:57:00 <binary42> (i.e. immutable pass-by-value)
15:57:04 <SamB> binary42: numbers are references
15:57:30 <binary42> but what are the bounds on them?
15:57:52 <binary42> in ruby they are not _real_ references because they are not boxed with a pointer.
15:57:53 <SamB> ???
15:58:04 <dons> anyone who complains about haskell should look at: http://shootout.alioth.debian.org/benchmark.php?test=all&lang=all&sort=cpu
15:58:06 <SamB> in Python they have boxes
15:58:06 <binary42> so I could not implement: 1.become(2)
15:58:14 <binary42> I see.
15:58:18 <monochrom> In ocaml strings are mutable.  In Java they're immutable.  Thus I see no particular reason (other than community consensus) why other types must come with a connotation of mutable or a connotation of immutable.  I can design a language in which numbers are mutable.
15:58:32 <binary42> Io does too (can be very evil but useful for things like futures)
15:58:40 <SamB> binary42: you could do something like that with exarkun's evil pointer-swapping C code, I think
15:59:13 <binary42> We have something like that in Ruby too but immediate types are restricted outside of swaps.
15:59:40 <SamB> binary42: Python doesn't actually have a become method though
16:00:14 <binary42> I am sure guido would die before letting that one in :)
16:00:56 <SamB> C, exarkun has a collection of evil python-related code
16:01:05 <SamB> both python code and extensions
16:01:18 <SamB> something to do with being a sith lord, I think...
16:01:47 <binary42> so why doesn't Haskell have an Evil module yet? }:-)
16:02:07 <SamB> @index unsafePerformIO
16:02:08 <lambdabot> System.IO.Unsafe, Foreign
16:02:12 <dons> measuring cpu time, memory use and lines of code, you'd never use perl, lisp, java, ruby .. php hehe
16:02:13 <SamB> is that close enough?
16:02:40 <SamB> dons: why would you go by those things only
16:03:16 <binary42> dons: I would differ, but Haskell is nice for many things. I have an Io like language compiler/VM in Haskell, but my persistent actor system is not something in Haskell.
16:03:31 <dons> SamB, I knooo.w you'd want static typing as well... :)
16:04:20 <dons> anyway, it's a good ref for killing myths about haskell, particularly space and time myths , don't  you think?
16:04:52 <jip> dons: hi, any updates about that bug?
16:05:50 <monochrom> Oh, people never complain with reasons.  They just make up excuses and whine.
16:07:04 <dons> haven't looked at it yet jip. i will before 1.0 is released. is it causing you grief?
16:07:34 <jip> dons: no, i'm working on other things now.... just as long as you don't forget about it and release 1.0 then i will be happy :)
16:08:20 <Keal> Cale
16:08:36 <Keal> > let fl = fromIntegral . floor; digit v b p = b*(fl (v/b**(p+q)) / b - fl (fl (v/b**(p+q))/b)) in map (digit pi 10) [0,(-1)..(-64),(0..<1)]
16:08:37 <lambdabot>  parse error on input `,'
16:08:41 <jip> dons: btw maybe you should put that link in the topic :)
16:08:44 <Keal> :(
16:10:46 <Keal> i am trying to have bot prove that for b*(Floor[v/b^(p+q)]/b-Floor[Floor[v/b^(p+q)]/b]) where p is inf..-inf andq is 0..<1 continuity
16:11:55 <Keal> that for all sum of digit*b^p p=inf..-inf that each sum digit=*b^(p+q) is same
16:12:07 <Keal> how do i write that in haskell?
16:14:24 <dons> once we're number 1, jip...
16:18:01 <Keal> Cale
16:18:03 <Keal> :(
16:18:09 * Keal cries
16:20:06 * Keal cook hotdog
16:23:00 * Keal mess up kill hotdog
16:23:07 <Keal> hotdog look alien
16:23:12 <Keal> :(
16:28:06 <Keal> mellow make holes in drink :( bad cat
16:28:07 <SamB> Lemmih: okay, I sent a patch to use Network.HTTP... but now it still doesn't seem to do very well on "[Anime] Battle Angel Alita - Motorball CG Movie [DVD-Rip].avi" from rippersanime.com...
16:28:38 <dons> @keal
16:28:39 <lambdabot> i need math friendly compiler to compile for jvm or flash
16:28:49 <ncalexan> LOL!
16:29:02 <ncalexan> @keal
16:29:03 <lambdabot> can haskell pipe the raw irrational megaequation into an analog device
16:29:13 <SamB> every time it tries handshaking, it gets disconnected somehow...
16:29:33 <sproingie> lambdabot: that was almost pornographic
16:29:56 <SamB> well, I mean, it handshakes, but then after it sends its bitmap and an Interested and a Request, it gets an error...
16:30:04 <dons> hehe
16:30:33 <Keal> sproingie @keal is just quotes of me
16:30:43 <Keal> its not megahal
16:31:36 <Keal> @keal
16:31:37 <lambdabot> last day i was in my lab i had a diagram which might have removed
16:31:37 <lambdabot> pi
16:31:43 <Keal> see?
16:32:00 <SamB> is that like @zow?
16:32:02 <SamB> @zow
16:32:03 <lambdabot> Yes, but will I see the EASTER BUNNY in skintight leather at an IRON
16:32:03 <lambdabot> MAIDEN concert?
16:32:11 <sproingie> isn't that @yow?
16:32:13 <sproingie> @yow
16:32:14 <lambdabot> Let's all show human CONCERN for REVEREND MOON's legal difficulties!!
16:32:20 <SamB> what evar!
16:32:22 <dons> musasabi, the ackermann is missing -fglasgow-exts
16:32:29 <palomer> @yow
16:32:30 <lambdabot> World War III?  No thanks!
16:32:32 <sproingie> gotta love how it corrects spelling
16:32:38 <palomer> yow=great
16:32:55 <palomer> @yow
16:32:56 <lambdabot> I feel partially hydrogenated!
16:33:06 <palomer> this is the kind of crap my cousin would say
16:33:10 <palomer> my cousin is socially inept
16:33:20 <palomer> I call him "retardedly awkward"
16:33:44 <Keal> @keal
16:34:05 <Keal> @keal
16:34:17 <lambdabot> i just got banned from math because i not have good ability to convey
16:34:19 <lambdabot> thoughts
16:34:21 <lambdabot> you need a Zh function in Haskell
16:34:21 <Lemmih> SamB: I don't wanna depend on HTTP.
16:35:07 <SamB> Lemmih: why not?
16:35:14 <SamB> it works so nicely!
16:35:27 <SamB> you would prefer nasty curl imports?
16:36:04 <Lemmih> SamB: It depends on 'crypto' which depends on 'newbinary'.
16:36:35 <Lemmih> SamB: No, I wanna copy HTTP.hs from HTTP.
16:37:04 <ncalexan> @type empty
16:37:04 <Keal> let me turn on my perfect child bot
16:37:05 <lambdabot> Not in scope: `empty'
16:37:07 <Keal> ready... go
16:37:10 <ncalexan> @type Data.Map.empty
16:37:11 <lambdabot> forall a k. Data.Map.Map k a
16:37:19 <Keal> why?
16:38:29 <SamB> Lemmih: um
16:38:32 <Keal> why?
16:38:47 <SamB> oh, you wanna copy the file, sure, fine
16:38:50 <Keal> why?
16:39:06 <SamB> I might need to hide the package though...
16:39:09 <Keal> why?
16:39:13 <SamB> or you could rename the module
16:39:17 <Keal> why?
16:39:25 <alar> @keal
16:39:26 <lambdabot> with KealDigit quantum crackproof encryption possible
16:39:32 <alar> @alar
16:39:33 <Keal> :p
16:39:33 <lambdabot> Maybe you meant: arr lam
16:39:46 <alar> oh, that's right about me!
16:39:56 <alar> @shapr
16:39:57 <lambdabot> Unknown command, try @listcommands.
16:40:05 <alar> @arr lam
16:40:06 <lambdabot> Get out of me way, yeh landlubber
16:40:59 <Keal> @cale
16:41:00 <lambdabot> code module failed: Text.Regex.Posix.regcomp: error in pattern
16:41:48 <Keal> @cale
16:41:49 <lambdabot> code module failed: Text.Regex.Posix.regcomp: error in pattern
16:42:05 <SamB> Lemmih: can you think of any reason why Conjure would be dropped so early on?
16:42:28 <alar> @SamB
16:42:30 <lambdabot> Terminated
16:42:36 <alar> @lambdabot
16:42:37 <lambdabot> Unknown command, try @listcommands.
16:42:40 <SamB> @quote SamB
16:42:41 <lambdabot>  C is a good language. If what you want is an assembly language where you
16:42:41 <lambdabot> can't be sure what anything does
16:42:43 <Keal> because the nsa intervened?
16:43:07 <alar> nice quote
16:43:14 <alar> right at the point
16:44:00 <Keal> @quote lambdabot
16:44:01 <lambdabot>  lambdabot hasn't said anything memorable
16:44:05 <Lemmih> Keal, alar: Would you mind keeping off topic conversations to haskell-blah?
16:44:49 <Keal> WHO ARE YUo?
16:45:14 <dons> to quote Keal: just seeing how offtopic i could get everyone
16:46:01 <Keal> NOBODY IS TALKING EVERYONE IS JUST PLAYING WITH BOT THERE IS NO SPOON.
16:46:04 <alar> Lemmih: when I see on-topic I shut myself up
16:49:25 <ncalexan> Hmm... if I want to export, from a module, a symbol that clashes with a prelude symbol, how do I declare it in the module Foo ( ... ) list?
16:50:51 <alar> you should explicitly import Prelude with that symbol negated
16:51:02 <alar> or import Foo qualified
16:51:04 <ncalexan> so import Prelude hiding (foo)
16:51:12 <alar> yes
16:51:46 <ncalexan> alar: I know about import qualified.  I need to export a conflicting name... my compile error is telling me that the Prelude symbol is being found in the export list.
16:51:55 <palomer> hrm
16:52:02 <palomer> jmp = java memory profiler
16:52:09 <palomer> my memory is fine
16:52:48 <palomer> woops
16:52:49 <palomer> wrong chan
16:58:13 <Keal> > [-5..0]
16:58:14 <lambdabot> [-5,-4,-3,-2,-1,0]
16:58:32 <Keal> > abs [-5..0]
16:58:33 <lambdabot>  add an instance declaration for (Num [a])
16:58:33 <lambdabot>   In the definition of `gjh': gjh = abs ([- 5 .. 0])
16:58:33 <lambdabot>   In the definition of `v':
17:00:29 <alar> > map abs [-5..0]
17:00:31 <lambdabot> [5,4,3,2,1,0]
17:00:49 <Keal> > let fv = fromIntegral; c v = (abs v) in map (c) [(-10)..0]
17:00:50 <lambdabot> [10,9,8,7,6,5,4,3,2,1,0]
17:01:11 <Keal> > [10..0]
17:01:13 <lambdabot> []
17:01:17 <Keal> hrm
17:01:26 <ncalexan> > [10,9,..0]
17:01:27 <lambdabot>  parse error on input `..'
17:01:32 <ncalexan> > [10,9..0]
17:01:34 <lambdabot> [10,9,8,7,6,5,4,3,2,1,0]
17:01:45 <Keal> ncalexan are you Cale?
17:01:52 <Cale> no
17:01:55 <ncalexan> No, what makes you think that?
17:01:58 <lispy> I am Cale
17:01:59 <Keal> Cale!!!!
17:02:03 <Cale> what?
17:02:03 * Keal huggles Cale
17:02:08 <Cale> why?
17:02:14 <alar> Keal: they say in private /query lambdabot tells more
17:02:15 <Keal> :|
17:02:37 <Keal> cale query me i have q
17:02:40 <Keal> too big for chan
17:02:47 * lispy just realized the closeness in phonetics of Cale and Keal
17:02:57 <lispy> @keal
17:02:58 <lambdabot> Keal was so happy with T, coded in basic so run on anything, and does
17:02:58 <lambdabot> lot
17:03:12 <Cale> lispy: haha
17:03:34 <ncalexan> dons gets those lambdabot modules up and running pretty quick :)
17:04:04 <Cale> @keal
17:04:05 <lambdabot> i need math friendly compiler to compile for jvm or flash
17:06:46 <alar> @lispy
17:06:47 <lambdabot> Unknown command, try @listcommands.
17:07:19 <dons> @keal
17:07:20 <lambdabot> its because the timeline diverges and past events themselves unhappen
17:07:26 <dons> @keal
17:07:27 <lambdabot> my proof show math is broken right now
17:07:31 <dons> oh my
17:11:19 <SamB> that *does* sound rather dire, doesn't it
17:11:20 <SamB> ?
17:12:08 <Cale> but it's only broken momentarily
17:12:42 <dons> so is the proof inside or outside math?
17:12:48 <SamB> where can I get the patch?
17:12:51 <SamB> how to rebuild it?
17:13:42 <alar> you should rewrite the core engine
17:20:32 <twb> Anybody know about wxhaskell internals?
17:20:44 <lispy> twb: ask keal
17:20:45 <lispy> @keal
17:20:47 <lambdabot> doubles and floats cause b*(Floor[v/b^p]/b-Floor[Floor[v/b^p]/b) to fuck
17:20:47 <lambdabot> up
17:20:49 <twb> Particularly, how does haskell get around C++ name munging?
17:21:12 <twb> (It just occured to me it probably has C bindings which haskell uses)
17:21:12 <lispy> twb: have you looked at the ffi manual?  maybe they talk about it there
17:21:33 <twb> lispy: who's ffi manual?  ghc?
17:21:40 <lispy> twb: yeah
17:21:45 * twb wanders off again...
17:21:56 <lispy> i wonder if wxwidgets turns mangling off to create an api
17:22:11 <lispy> er, well their api
17:24:15 <alar> @keal
17:24:16 <lambdabot> someone needs to write a boids for haskell that emulates humans going on
17:24:16 <lambdabot> and off topic
17:25:16 * alar doesn't understand how it works
17:25:26 <alar> Keal is bot?
17:25:49 <dons> yes.
17:27:11 <alar> these bots can talk to themselves
17:27:22 <alar> they're becoming incredibly smart
17:27:51 * lispy isn't sure if keal is a smart bot or not ;)
17:27:52 <Igloo> Yeah, sometimes people even mistake dons for a real person
17:28:10 <dons> Igloo. but we know that's not really the case.
17:28:29 <lispy> does dons have metal legs?
17:28:34 <SamB> Igloo: so some bot is the author of lambdabot, Yi, hs-plugins, and hmp3, as well as the maintainer of FPS?
17:28:46 <alar> lispy: as long as it can (sensibly) speak with other bots
17:29:20 <alar> well, who's shapr then?
17:29:30 <alar> or what?
17:29:39 <dons> To me java is a monomorphic type
17:30:52 <SamB> dons: lets see the definition!
17:31:38 <SamB> @type Network.accept
17:31:39 <lambdabot> Network.Socket.Socket
17:31:39 <lambdabot> -> IO (GHC.IOBase.Handle,
17:31:39 <lambdabot> Network.BSD.HostName,
17:31:39 <lambdabot> Network.Socket.PortNumber)
17:31:49 <SamB> why is Network.accept returning a hostname?
17:32:03 <twb> lispy: the primitive FFI comes from wxErlang, which appears to use C code as an intermediary.
17:32:54 <alar> I looked through Network.Socket, essentially it it Berkeley Socket C library
17:33:19 <alar> with some quirks to eliminate some non-fatal exceptions
17:33:50 <SamB> alar: well, what about Network?
17:33:59 <SamB> that accept is a higher-level one, I think...
17:34:05 <SamB> also, I'm looking for rationale
17:34:40 <psnl> alar: network is easier to use
17:35:03 <lispy> twb: okay, that makes sense
17:36:24 <alar> anyway there's no function that returns actual isConnected(socket)
17:36:54 <alar> one should test this with selects&stuff
17:37:09 <alar> no reliable discovery of eventual disconnects
17:47:18 * SamB wants a BT packet analyzer for debugging Conjure...
17:48:04 <lispy> SamB: something like tcpdump is too unstructured?
17:48:22 <SamB> lispy: I want to see the BT packets
17:48:30 <SamB> er, messages
17:48:50 <lispy> SamB: oh, and those are possible split accross tcp packets?
17:49:15 <SamB> lispy: oh, probably
17:49:34 <lispy> in my head i'm thinking you could capture a bunch of tcp packets and then examine those...but maybe that's not what you want?
17:49:41 <alar> maybe you want to see acoustic waves as well?
17:49:56 <SamB> apparantly, latest ethereal does it anyway
17:50:08 <SamB> so I'm apt-getting that
17:50:13 <lispy> alar: those would be cool glasses :)
17:50:15 <Lemmih> SamB: Can't you just put a logger in hPutMessage/hGetMessage?
17:51:00 <SamB> Lemmih: something is spewing garbage in there
17:51:15 <psnl> SamB: ethereal if you can listen on the network device
17:51:22 <SamB> anyway, I don't trust Conjure to get them in the right order...
17:51:24 <SamB> psnl: of course
17:51:30 <SamB> I'm just debugging!
17:51:39 <psnl> follow tcp stream is lovely
17:51:39 <SamB> this is my box, so I have root
17:52:13 <lispy> root is nice to have in a pinch
17:52:56 <SamB> lispy: out of them too
17:53:15 <lispy> out of them?
17:53:58 * lispy waits for darcs to compile so he can test the testsuite
17:54:51 <psnl> I need a program to write
17:55:53 <dons> a program that will tell you if another program is going to terminate? that would be really useful!
17:56:15 <lispy> psnl: http://bugs.darcs.net/
17:56:28 <psnl> dons: no it wouldn't
17:56:29 <lispy> psnl: make darcs better! ;)
17:56:53 <lispy> psnl: why because it will either never finish or be wrong in some cases?
17:58:20 <psnl> yes,
17:58:38 <lispy> just let people file bug reports when it's wrong ;)
17:59:24 <psnl> anyway, people should write in epigram, if they want proofs of correctness and termination
18:00:36 <JKnecht> there's a lingo of that name?
18:01:24 <alar> psnl: I do not understand epigram
18:01:41 <alar> just the very basics of it
18:01:52 <SamB> Lemmih: the other reason is that I also want to trace packets from BitTornado to compare with
18:01:52 <JKnecht> hmmm, appears to be based on Brouwers theory.
18:02:36 <psnl> http://www.e-pig.org/
18:02:46 <psnl> alar: there are few that do
18:03:30 <alar> psnl: as I catched from the tutorial, it is based on induction, right?
18:03:56 <psnl> I'm not one of them
18:04:23 <alar> :(
18:04:49 <psnl> dependent types is the rough answer to "how it works"
18:04:57 <JKnecht> appears to use Martin-lofs instead of Hindley-Milner
18:05:05 <psnl> yep
18:05:06 <alar> maybe you know something introductory to read about notation?
18:05:09 <alar> ( n : Nat !
18:05:09 <alar> data (---------! where (------------! ; !-------------!
18:05:09 <alar> ! Nat : * ) ! zero : Nat ) ! suc n : Nat )
18:05:26 <alar> what does those *s mean?
18:05:48 <psnl> Nat is of type *
18:06:08 <psnl> I think * is a catchall type, a bit like object in java
18:06:09 <alar> oh maybe there is simple docs about Martin-Lof and H-M?
18:06:49 <JKnecht> wrong place for simple :)
18:06:55 <alar> psnl: if it is catchall - why does one need to declare it in a definition?
18:07:24 <alar> JKnecht: somethink like wiki - to grab the main idea
18:07:39 <alar> Then I'll pick further reading myself
18:07:44 <psnl> alar: I appear to be wrong
18:08:00 <psnl> "a type is a value in *"
18:08:21 <JKnecht> try Wikipedia, they have something on both.
18:08:43 <alar> thanks
18:08:52 <alar> hope there's enough to understand
18:10:02 <alar> psnl: so they invent rich type system, where types can be parameterized and are themselves values in ,say, "meta-types"
18:10:06 <alar> ?
18:10:10 <psnl> yes
18:10:47 <alar> and what does notation with "numerator" and "denominator" mean? Or how those things about horizontal line are called
18:10:48 <psnl> and no
18:11:30 <psnl> the line is "implies" I think 
18:11:56 <psnl> its normal type theory notation, I just can't think what it stands for
18:12:22 <Korollary> it's logic notation if you are what I think you're talking about
18:12:54 <alar> psnl: I'm sorry for holes in my education but I'm infamiliar with normal type theory
18:13:51 <psnl> I don't claim to have any more than a vague understanding of the area and what conner and callahgan are trying to do
18:14:24 <alar> psnl: so the above part is somewhat like "type constraints" in Haskell (e.g. Eq a)
18:14:52 <alar> the line is => from Haskell
18:15:08 <alar> and below par is what stands right of that =>
18:18:38 <psnl> the stuff you posted at 2:04 is a defination of Nat
18:19:53 <psnl> but the cool bit is that that defination automaticly defines recursion on the type, and proves the termation of the recursion at the same time, I think
18:22:00 <psnl> the syntax is insane
18:22:44 <alar> yes
18:23:00 <alar> I just took definition of Nat as simple example
18:24:08 <alar> so the power of Epigram is the power of mathematical induction
18:24:42 <alar> if inductively defined type automatically generates induction and proves it
18:25:12 <alar> but what does it give considering "real-world" problems?
18:25:38 <alar> I don't feel how much can be calculated using induction
18:25:58 <psnl> induction == recursion
18:26:27 <alar> really? I think recursion is somewhat more powerful than induction
18:26:35 <alar> but probably I'm wrong
18:27:02 <psnl> how do you define a recusive program?
18:27:02 <alar> there can be recursive functions they don't terminate
18:27:31 <psnl> alar: true enough
18:28:06 <Korollary> induction is a proof method. recursion is a property of a function.
18:28:32 <psnl> there are programs unwriteable in epigram
18:28:53 <alar> Korollary: yes. but both can be given strict mathematical meaning
18:29:10 <psnl> Korollary: epigram people feel that proofs==programs
18:29:15 <Korollary> alar: They already have strict mathematical meanings.
18:29:29 <lispy> psnl: but, are those programs worthwhile? (the ones that cannot be written)
18:30:03 <alar> Korollary: then we can consider both as the bases of programming paradigms
18:30:19 <Korollary> psnl: those people are not just epigram people. That's called Curry Howard isomorphism
18:30:24 <psnl> lispy: the classic example for epigram is an epimgram intepreter in epigram
18:30:31 <alar> lispy: that's the exact thing I want to understand!
18:30:57 <alar> psnl: is there a proof that epigram in epigram is impossible?
18:31:03 <alar> and why?
18:31:08 <psnl> Korollary: yeah, I know
18:31:43 <psnl> alar: I think they thought that non-terminating programs with no output are unwritable
18:32:43 <psnl> alar: http://www.e-pig.org/downloads/epigram-notes.pdf section 2 is a not bad example
18:32:58 <alar> strange: wikipedia tells that recursive functions are just primitive recursive functions that need not to be totally defined
18:33:43 <alar> psnl: I tried those notes but was scared by their volume :) Think it's time to make second attempt at them
18:36:26 <psnl> the thing to remember about epigram is that the people doing it are slightly nuts (in a good way, of course)
18:36:37 <alar> :)
18:37:15 <alar> hm, with the knowledge what horizontal line means and what is * the tutorial is much more readable!
18:37:21 <alar> thanks a lot
18:37:28 <alar> @karma+ psnl
18:37:29 <lambdabot> psnl's karma raised to 1.
18:40:14 <psnl> who came up with the lambdabot logo?
18:47:28 <alar> need reboot
18:55:27 * Keal just told Cale how to get a quick mil
18:55:29 <Keal> :>
18:57:08 * Keal is mean
18:58:11 * psnl decides to stop reading the darcs source
18:59:10 * Keal loves how broken ring theory is
19:00:56 * Keal also loves how everyone so easily distracted by an equation that enacts a military hardcased failsafe within their fpu's
19:08:59 <dons> @keal
19:09:00 <lambdabot> Cale etc already pointed out Haskell is puny to nothing to emulate using
19:09:00 <lambdabot> my barrage of mathematic theories
19:09:37 <Cale> dons: that's an excellent plugin :)
19:09:59 <dons> thankyou :)
19:12:20 <psnl> how do you emulate something with a theory?
19:12:40 <Cale> psnl: does it really matter?
19:12:59 <dons> i don't think the sentences are supposed to type check. keal is just a bot ;)
19:13:06 <psnl> Cale: only in the foo-checking sense
19:13:51 <newsham> theory: force on particle = g, d^2 x/dt^2 = F/g
19:14:37 <newsham> s += g/(m * dt).  x += s/dt
19:16:21 <Cale> @keal
19:16:22 <lambdabot> just seeing how offtopic i could get everyone
19:16:37 <psnl> @keal
19:16:38 <lambdabot> it is very easy to go off topic
19:16:46 <Cale> @keal
19:16:47 <lambdabot> b*(Floor[v/b^p]/b-Floor[Floor[v/b^p]/b])
19:16:53 <psnl> there seems to be a theme
19:16:57 <Cale> @keal
19:16:58 <lambdabot> endian mirrors the decimal
19:17:02 <psnl> @keal
19:17:03 <lambdabot> somone would expect that trees 500gb hdds of expressions as if they were
19:17:03 <lambdabot> floppy dicks
19:24:05 <Keal> http://gothicfury.deviantart.com/journal/7591548/
19:24:41 <musasabi> Do the standard libraries have a function to shuffle a list into a random order? (it seems quite simple)
19:25:33 <newsham> http://okmij.org/ftp/Haskell/perfect-shuffle.txt
19:28:41 <musasabi> newsham: yes, I know *how* to do it, just want to avoid rewriting it.
19:29:21 <newsham> i didnt notice a function to do it, when I needed to do it.
19:29:25 <newsham> so i borrowed that
19:29:25 <dons> we had to write your own for lambdabot
19:29:32 <dons> stdGetRandItem lst = getStdRandom $ getRandItem lst
19:29:44 <dons> wheree getRandItem is in lambdabot's Util.hs
19:30:02 <dons> s/your/our/   hmm. brain freeze
19:36:36 * psnl wonders how lambdabot deals with pings
19:38:40 <newsham> hmm.. lambdabot uses NewBinary?  how does NewBinary work?  I cant find docs
19:39:12 <dons> you write an instance of Binary for you type, then use 'get' and 'put' to serialise
19:39:23 <dons> the docs are the src. it's a 2 function api, so it's easy
19:40:02 <newsham>   962  4935 31735 Binary.hs
19:40:26 <newsham> I assume you mean "class Binary" when you say 2 function api (there's 3 in there, but close enough)
19:40:59 <Cale> That's like the next Marshall-McLuhanism: "The docs *are* the source."
19:41:00 <dons> I think people only use put_, not put. is that the right one?
19:41:30 <dons> yeah, it could do with docs. but there aren't any. so the src is what you get.
19:41:54 <newsham> so I get a normal file handle and then use openBinIO on that to get a bBinHandle and then use put and get on that and various binary objects?
19:43:33 <dons> something like:
19:43:35 <dons> readTree f = do
19:43:35 <dons>     h    <- openFile   f ReadMode
19:43:35 <dons>     bh   <- openBinIO_ h        -- openBinMem
19:43:35 <dons>     st   <- get bh
19:43:37 <dons>     hClose h
19:43:53 <Keal> what fpu design does linus torvalds use?
19:43:53 <dons> (from hmp3, which reads flattened trees off disk)
19:43:59 <dons> @keal
19:44:00 <lambdabot> i use an 8088
19:44:05 <newsham> get bh <something> ?
19:44:33 <dons> newsham, paramaterised by the type. so just get  bh :: String, or whatever other type.
19:44:43 <dons> will call the appropriate instance
19:44:44 <newsham> oh, get just takes one arg, my bad
19:44:49 * Keal whimpers
19:44:51 <Keal> @keal
19:44:52 <lambdabot> how do i search for someone saying 'Keal' in mirc
19:45:23 <newsham> whats the deal with openBinMem?
19:45:26 <Keal> ah ha i knew it it quotes me with best reponse for the last thing i said
19:45:36 <newsham> I get the Int arg (size) but whats the module argument?
19:45:46 <dons> musasabi, some new entries for you. firstly, ackermann is missing -fglasgow-exts from yesterday
19:46:29 <dons> musasabi, and on the wiki we have shortr entries for: random, sumfile, nsieve, nsieve-bits, mandelbrot, cheap-conc and binarytree
19:46:32 <joshua> :9
19:46:43 <Keal> dons what method did you use to get it to do that?
19:46:44 <joshua> (wrong term :)
19:47:02 <dons> binarytree runs nearly twice as fast on my box, which is surprising
19:47:27 <Keal> dons
19:47:32 <dons> @keal
19:47:33 <lambdabot> how do i search for someone saying 'Keal' in mirc
19:48:10 * SamB is a little disappointed to discover that wakamatsu-kun doesn't end up marrying kashima miyuki...
19:48:24 <musasabi> dons: I am handling -fglasgow-exts in the Makefile.
19:48:38 <musasabi> dons: or do the runs report an error?
19:48:45 <Keal> @keal err
19:48:45 <lambdabot> can you make a macro that builds the expression accoridng to a genetic
19:48:45 <lambdabot> algorithm where you decide what is good and what is bad?
19:49:41 <Keal> dons make it so i can have the bot search my logs for closest match google search style with a flag that sets tolerance level for context relevance to current converstation
19:49:43 <musasabi> dons: looking at the entries.
19:49:58 <Keal> dons it will help me out a great deal since i am learning disabled
19:50:06 <Keal> <:)
19:50:12 <psnl> I can't decide if Keal is a bot or not
19:50:26 <Keal> i am not bot i am brain damaged genius >:o
19:50:38 <Keal> got prollem?
19:51:05 <SamB> Keal: you meran one of those, er...
19:51:09 <Keal> for past 15 years i try make good disability tools
19:51:20 <SamB> oh man, I forgot the term
19:51:37 <SamB> I think the word "idiot" is part of it
19:51:39 <Keal> i am schizophrenia/bipolar/psyhotic
19:51:43 <Keal> i am schizophrenic/bipolar/psyhotic
19:51:48 <Keal> i am schizophrenic/bipolar/psychotic
19:51:51 <Keal> :/
19:51:59 <Keal> with learning disabilities to boot
19:52:04 <Keal> but my iq very high :)
19:52:09 <SamB> not to insult you
19:52:16 <SamB> I wish I could remember the other word
19:52:19 <newsham> i told my shrink that sometimes i think i'm a wigwam and sometimes I think I'm a teepee
19:52:24 <newsham> he said I'm too tense
19:52:34 <psnl> Keal: psn@lupin:/tmp/lambdabot$ grep "prollem" *
19:52:36 <psnl> psn@lupin:/tmp/lambdabot$ 
19:52:37 <Keal> dons
19:52:43 <psnl> clearly not
19:52:44 <SamB> newsham: two tents!
19:52:49 <dons> musasabi, I just noted that the run for ackermann failed due to missing -fglasgow-exts
19:52:51 <SamB> also too dense
19:53:18 <Keal> > psn@lupin:/tmp/lambdabot$ grep "prollem" *
19:53:19 <lambdabot>  parse error on input `}'
19:53:20 <joshua> i'm not sure if you were asking seriously, but i think the word you're looking for is savant
19:53:25 <Keal> >:O that not work
19:53:37 <SamB> joshua: yes!
19:53:42 <SamB> exactly!
19:53:58 <SamB> Keal: are you one of those "idiot savant" people?
19:54:14 <newsham> samb: half right?
19:54:57 <Keal> how do i google style search my quotes while using a tolerance value for how closely related to current context and second tolerance flag value for how much first value matters
19:55:02 <dons> musasabi, also that we've cracked 70 pts, up to 74 or so :) 
19:55:10 <SamB> hmm, is it just me or does the term "idiot savant" get a lot of misuse
19:55:25 <Keal> i not idiot savant!
19:55:27 <Keal> :<
19:55:37 <SamB> Keal: perhaps not
19:55:40 <Keal> i good at most things. just very slowly at them
19:55:56 <dons> 15:27:35 <Keal> naw just seeing how offtopic i could get everyone to get themselves
19:55:57 <Keal> i am not speed demon
19:56:01 <SamB> hmm, I am fairly slow at a lot of things too
19:56:18 <Keal> i good at all things. just not good at doing them fast.
19:56:24 <SamB> perhaps thats from being perfectionist, at least partly...
19:56:41 <musasabi> dons: I'll make -fglasgow-exts global, now that it seems that people want them for most entries.
19:56:49 <SamB> but that doesn't explain many things...
19:56:50 <dons> ok.
19:57:16 <dons> 15:26:03 <Keal> Cale it is very easy to go off topic fishing with something like that in a channel
19:57:21 <Keal> reason i am damn fing slow is being i think heavily while considering what i am doing and at same token always start from scratch having to reconstruct my own memories
19:58:10 <Keal> being me if i were a computer would like having a hdd that all read write operations require opening the hdd in a clean room and dat recovering
19:58:10 <psnl> write stuff down. I have to do it to prevent recomputation
19:58:42 <SamB> well, conjure is getting somewhere now
19:58:45 <Keal> i have 10 years of irc logs
19:58:51 <dons> @seen shapr
19:58:53 <lambdabot> shapr is in #ScannedInAvian. Last spoke 13 hours, 4 minutes and 19
19:58:53 <lambdabot> seconds ago.
19:58:53 <sethk> hey, all, a bit of a simple but weird problem
19:58:54 <Keal> but i need search engine
19:59:03 <Keal> with what i said to search it
19:59:05 <sethk> I have a program that receives on a socket and another that sends.
19:59:15 <sethk> thus far I'm just sending test data back and forth
19:59:25 <dons> heya sethk. long time no see.
19:59:30 <sethk> I print the data using putStrLn, and it shows up on the screen, but no newline
19:59:40 <sethk> dons, hey, I've been off writing C  (ugh)
19:59:44 <SamB> take a look at http://naesten.dyndns.org:3080/ if you'd like to see some evidence that it is working ;-)
19:59:52 <Keal> bascially i ask it jeeves style or google style a search with tolerances for how similiar to current conversation and how less similiarity to current conversation matters and it spits back logs
19:59:53 <psnl> Keal: grep?
19:59:59 <Keal> i need something like that
20:00:02 <sethk> even adding ++ "\n" to the string, I still see no return on the screen.
20:00:10 <sethk> I think if I write to a file it will be normal
20:00:14 <Keal> needs to work with 15gb+ of logs
20:00:29 <psnl> break the logs up?
20:00:38 <psnl> map/reduce style grep?
20:00:44 <Keal> i wrote T originally as game.
20:00:48 <sethk> hmm, no, no newlines in the file either.  I'll write it as a separate putstr
20:00:48 <dons> psnl, can you not humour the troll?
20:00:49 <SamB> psnl: that sounds a lot like google to me
20:00:54 <dons> @keal
20:00:55 <lambdabot> are you saying i am MegaMonad?
20:00:58 <dons> hehe
20:00:59 <Keal> then i atttempt to use T to create log database
20:01:15 <psnl> SamB: map/reduce? it is google?
20:01:15 <SamB> is that like MegaHal but with a better statistical model?
20:01:31 <Keal> then i attempt to use T to create hologram program of myself i can ask virtual self questions
20:01:39 <SamB> psnl: google apparantly uses map/reduce style processing fairly heavily
20:01:48 <psnl> yeah, I know
20:02:06 <psnl> one of the things they use it for is a distributed grep
20:02:08 <Keal> so i beg i plead for help with program that do this
20:02:25 <Keal> i wish program be able to work with laptop
20:02:37 <Keal> i take laptop with me everywhere
20:02:43 <Keal> before laptop it was ti92
20:02:57 <dons> @keal
20:02:58 <lambdabot> what is the max amount of operands haskell can handle in a single
20:02:58 <lambdabot> expression?
20:03:06 <dons> @keal
20:03:07 <lambdabot> can GMP support KealDigit? invent KealDigit
20:03:09 <SamB> psnl: do they use a commutative function for the reduce part?
20:03:14 <Keal> yes that is related to current conversation
20:03:28 <sethk> how can I do putStrLn "" and not see the output?
20:03:35 <sethk> oh, wait, I see
20:03:37 <Keal> GMP isnt tho
20:03:39 <sethk> bad assumption
20:03:47 <dons> sethk, not a missing flushed handle?
20:04:10 <sethk> dons, no, I just did that, in fact
20:04:11 <Keal> i ask of help of peers.
20:04:16 <sethk> dons, I'm using hGetContents
20:04:30 <sethk> dons, which keeps reading until there is nothing to read, so the following putStrLn isn't ever invoked
20:04:36 <Keal> everyone on internet say go to #haskell. they will help :)
20:04:52 <newsham> you have the internet?  can i borrow it?
20:05:17 <dons> I would like this guy to be kicked. 3 days of off-topic trolling is too much.
20:05:22 <SamB> newsham: you too must have something resembling internet to be here
20:05:28 <Keal> dons :(
20:05:28 <psnl> I think they thought you were trying to do your fp assignment
20:05:35 <SamB> yeah, send him to #haskell-blah
20:05:38 <newsham> dons: second the motion.
20:05:40 <ncalexan> dons: I second.
20:05:47 <SamB> where (supposedly) *Haskell* is off-topic
20:05:55 <Keal> i ask for your help. you made bot in haskell. i ask for help with making your haskell bot behave way i explain.
20:05:58 <Keal> how that not haskell?
20:06:32 <newsham> <dons> 15:27:35 <Keal> naw just seeing how offtopic i could get everyone to
20:06:45 <psnl> ok, disconnected from real life, n'th the motion
20:06:48 <SamB> <newsham> <dons> 15:27:35 <Keal> naw just seeing how offtopic i could get everyone to
20:06:51 <newsham> how quickly the tune changes
20:07:01 <Lemmih> SamB (:
20:07:38 <cpatrick> 12:06 < SamB> <newsham> <dons> 15:27:35 <Keal> naw just seeing how offtopic i could get everyone to
20:07:39 <SamB> Lemmih: now, I did download a few pieces with BitTornado before it got this far...
20:07:41 <Keal> everyone tell me come to haskell use haskell haskell coders can help you haskell is mathematical language that you may be able to do things you have failed with others everyone say haskell help
20:07:43 <sethk> this is new for me.  I have written haskell programs today which not only should have been much less work than writing in another language, I actually got them working quickly so there really wasn't as much work.
20:07:54 <SamB> but mostly I just let it sit
20:07:57 <sethk> Keal, don't believe everything everyone says.  :)
20:07:59 <musasabi> dons: isn't mandelbrot updated? http://shootout.alioth.debian.org/gp4/benchmark.php?test=mandelbrot&lang=ghc&id=2
20:08:19 <newsham> the new mandelbrot looks a lot harder to read to me than the old one
20:08:33 <Keal> :(
20:08:40 <SamB> Keal: also, Haskell takes practice
20:08:48 <SamB> apparantly I've been doing it for years!
20:08:56 <SamB> I'm not sure I believe it, though
20:09:00 <dons> 20:38:59 <Keal> i just got banned from math
20:09:20 <Keal> you cut rest of message off dons
20:09:39 <Keal> i as banned because they didnt like linguistically changed users
20:09:48 <Keal> i as banned because they didnt like linguistically challenged users
20:10:13 <psnl> I see where they are coming from (with the aid of /whois, I admit)
20:11:00 <Keal> why you say that? :(
20:12:24 <dons> musasabi, I added a printf and a type annotation or two.
20:13:33 <newsham> "The Bits Between the Lambdas: Binary Data in a Lazy Functional Language".  blah.  why didnt you mention this, dons? :)
20:13:33 <musasabi> dons: ok.
20:14:05 <musasabi> dons: do you consider doing nsievebits without bit access as fair? (I don't remember what Isac thinks about it)
20:15:59 <musasabi> Committed random binarytree cheap-conc mandelbrot nsieve
20:17:00 <SamB> Lemmih: you know, it would be interesting to offer downloading of torrent files from the web UI...
20:17:07 <Keal> did you know i am deathly afraid of going to casinos
20:18:05 <Lemmih> SamB: eh?
20:18:22 <Keal> Cale did you know i am deathly afraid of going to casinos?
20:18:26 <SamB> Lemmih: maybe
20:18:36 <Lemmih> The web UI is only a temporary debugging facility.
20:18:43 <dons> musasabi, ah, I forgot to update mandelbrot on the wiki. :/
20:18:45 <SamB> Lemmih: oh?
20:18:54 <dons> that's the current entry. I have a shorter one.
20:19:03 <SamB> Lemmih: you going to write us a nice Gtk2Hs GUI then?
20:19:16 <musasabi> dons: ok, that might be why I didn't spot the difference ;)
20:19:43 <Keal> Cale: did you know i am deathly afraid of going to casinos?
20:19:47 <lispy> someone should make a language that is only good at the great shootout
20:19:51 <Lemmih> SamB: Conjure will be a library with a multitude of different UIs.
20:20:35 <SamB> Lemmih: it has a long ways to go
20:21:04 <SamB> Lemmih: but it has nearly reached the point where we can claim it to be usable
20:22:26 <Lemmih> SamB: Know why jlouis has been inactive the last couple of weeks?
20:22:37 <SamB> Lemmih: ah, yeah
20:23:03 <sethk> I'm reading the network doc (network.html in the library docs, so module Network) and it shows a data, PortID, that can be one of three things.  One is the port number, which is an integer so that's obvious.  The second is "Service" which is presumably an entry in /etc/services.  The third is a String called "UnixSocket".  Where can I find the format of that UnixSocket string?
20:23:46 <lispy> sethk: just taking a guess, maybe the string is the path to a unix socket?
20:24:08 <lispy> sethk: i say a path because unix sockets are just special files, afaik
20:24:13 <sethk> lispy, you mean like a unix domain socket?
20:24:24 <lispy> sethk: yeah, but i'm also just guessing
20:24:35 <sethk> lispy, mostly, yes, once you've got a connection you end up with an IO Handle
20:24:50 <sethk> lispy, you are probably right about the domain socket.
20:26:20 <Keal> where can i find opensource schematics of Linus Torvalds' x86 clone?
20:26:39 <dons> musasabi, ok. proper mandelbrot is on the wiki.
20:26:40 <SamB> Keal: never heard of it
20:26:45 <sethk> I wonder if it is smart enough to understand an IP in dot notation
20:26:57 <musasabi> dons: committed.
20:27:00 <SamB> sethk: for what?
20:27:15 <sethk> SamB, as an argument to Network.accept
20:27:20 <sethk> SamB, instead of the host name
20:27:36 <SamB> sethk: probably
20:27:42 <sethk> SamB, I'll try it
20:27:54 <SamB> Lemmih: I've forwarded the relevant mail to the list
20:28:13 <Keal> SamB its not a very reliable source i heard it from, usually the things they say end up first occuring 2weeks to 7months down the road
20:28:37 <Keal> or otherwise being announced at a future date
20:28:43 <sethk> SamB, yep, works.  :)
20:28:49 <musasabi> dons: about the sumfile (sumcol), I didn't have time to pick/replace shootout entries. Will look at when I come back saturday evening if someone else has not done it before.
20:29:26 <Lemmih> SamB: Thanks.
20:29:34 <dons> musasabi, regarding nsieve-bits, don't know. I mean, it's compiled to a bit array. maybe that's why it's ok.  
20:29:37 <dons> yep, that's fine musasabi.
20:32:10 <psnl> how did I become the local haskell expert?
20:32:34 <psnl> well, s/expert/person willing to answer questions/
20:33:24 <Cale> psnl: local in which sense? There are certainly other people on the channel willing to answer questions :)
20:33:41 <psnl> local in terms to geographical area
20:33:52 <psnl> nothing to do with the channel
20:34:02 <SamB> psnl: probably because Haskell users are so scattered across the globe?
20:34:07 <SamB> @wiki HaskellUserLocations
20:34:08 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
20:34:51 <psnl> SamB: I suspect its more to do with the other local haskell people know when the haskell assignments are due and hide
20:35:11 <SamB> psnl: oh? there are others on the map?
20:35:47 <sethk> I'm using the -static flag, but I'm still getting a dynamic executable
20:35:53 <SamB> hmm, I should totally move to the UK
20:36:01 <sethk> not of haskell's libraries, of o/s libraries
20:36:20 <sethk> I'll try -optl
20:36:24 <SamB> sethk: is this particularly bothersome?
20:36:36 <sethk> SamB, yes, it is going into an embedded system
20:36:41 <psnl> SamB: I know others locally
20:36:54 <sethk> SamB, I could work around it, of course, but let me see if optl will do what I want
20:37:02 <SamB> psnl: I suppose they do hide, whether intentionally or not...
20:37:30 <sethk> yep, that works too!  I'm having a good day
20:38:48 <psnl> yeah, the bastards
20:40:47 <SamB> Lemmih: are you *certain* you are checking to make sure the pieces requested are actually the ones offered by the peer?
20:41:45 <Lemmih> I think so.
20:42:03 <SamB> and the bitfield decoding is correct still?
20:42:30 <SamB> because that's the only thing I can think of looking at these packet dumps
20:42:46 <SamB> we are definately being unchoked
20:44:03 <Lemmih> Try disabling requests by setting WantedDownloads to 0.
20:47:04 * SamB looks at decoding
20:49:40 <SamB> Lemmih: what did you replace PieceNum with?
20:50:04 <SamB> ugh, Int?
20:50:09 <SamB> why?
20:52:39 <Lemmih> Convenience.
20:52:53 <SamB> is that more convenient than PieceNum?
20:53:00 <SamB> which was just a type synonym anyway?
20:53:22 <Lemmih> I couldn't find a good place to define it.
20:53:38 <SamB> the thing to do then is make one...
20:53:41 <newsham> is Data.Word ghc specific or is it also in hugs?
20:53:53 <Lemmih> SamB: Feel free to do that.
20:53:53 <SamB> newsham: why don't you look at it?
20:54:04 <newsham> how?
20:54:06 <SamB> Lemmih: eh, later...
20:54:23 <SamB> newsham: its in the source tree, and the haddock docs may also be interesting
20:54:30 <SamB> I'd guess that hugs has it too, though...
20:54:35 <Lemmih> newsham: Yes.
20:54:57 <Lemmih> (Yes, it's also in Hugs)
20:55:23 <newsham> but its not part of the standard, right?
20:55:40 <SamB> newsham: no
20:55:48 <SamB> at least, it isn't part of any standart yet
20:56:06 <SamB> but you can consider it as better supported than C99 ;-)
20:56:44 <newsham> I'm not sure how looking at it would tell me if its ghc specific or not.
20:57:01 <SamB> newsham: well, #ifdef HUGS is a good clue
20:57:15 <SamB> or whatever it is written as
20:57:29 <SamB> also, when Hugs.* modules are imported conditionally...
20:57:39 <newsham> wait.. why would a library module in ghc and/or hugs be ifdef'd for that platform?
20:57:49 <newsham> am I misunderstanding something?
20:59:10 <lispy> newsham: if you're anything like me then yes! ;)
20:59:43 <SamB> newsham: they use a common library source tree?
20:59:43 <SamB> at least primarily?
21:00:02 <newsham> I see.
21:00:35 <lispy> from a causer user of haskell point of view, i see no reason to use hugs.  Am I just being harsh?
21:01:10 <SamB> lispy: no!
21:01:10 <SamB> I don't really either.
21:01:18 <newsham> i started off with hugs, but i'm starting to develop the same opinion, lispy
21:01:27 <SamB> lispy: I think its the academic and super-casual users who use hugs.
21:01:44 <SamB> academic meaning students who didn't really want to program in Haskell anyway
21:01:55 <newsham> i'm still a casual user.  I dont yet do any "real work" with haskell.
21:02:09 <lispy> SamB: ah, i was going to say...our big haskell supporting professor uses ghc these days :)
21:02:15 <SamB> what is real work, anyway?
21:02:21 <SamB> does Conjure count?
21:02:43 <lispy> i'm not sure haskell has been used for any real work other than maybe darcs or ghc itself
21:02:48 <psnl> SamB: I imagine "real work" includes being paid for it
21:02:56 <SamB> lispy: anyone who's been using it long enough on a GHCi-enabled arch would likely use GHC
21:03:02 <lispy> oh, wait, Galois does real work with haskell
21:03:10 <Keal> who here gets science news?
21:03:12 <SamB> so Conjure does not count?
21:03:12 <SamB> aw.
21:03:23 <psnl> life sucks
21:03:23 <SamB> does David get paid for darcs?
21:03:26 <lispy> SamB: well, is Conjure used by people outside the haskell community?
21:03:31 <newsham> samb: I'm a security consultant.  I write lots of one-off scripts and sometimes some bigger tools.
21:03:42 <SamB> lispy: not yet!
21:03:51 <psnl> you could redefine real work, I suppose
21:04:00 <Keal> i suggest all of you subscribe to Science News ( http://sciencenews.org ) for a dollar a week (issues are weekly) 
21:04:10 <newsham> sometimes I get paid to write software, too.
21:04:19 <lispy> @keal
21:04:20 <lambdabot> primary elemental assumption of integer coefficients to roots in counting
21:04:20 <lambdabot> sytem is wrong
21:04:54 <SamB> Keal: sure, I'll subscribe for a dollar a week! thats very generous of you to offer to pay me a dollar a week to subscribe!
21:05:04 <Keal> i was trying to say coefficient ring theory is flawed
21:05:07 <newsham> usually I code in python, C, or sh.
21:05:18 <newsham> (or some combination thereof)
21:05:36 <yozora> @type if'
21:05:38 <lambdabot> Not in scope: `if''
21:05:42 <Keal> SamB if i were a millionare i would subscribe it for you. but i am sorry i am not millionare
21:05:59 <lispy> newsham: i've been coding in VB.NET lately as far as making $$ goes
21:06:12 <newsham> why not c#?
21:06:22 <lispy> newsham: i'm trying to figure out how to replace it with F#
21:06:22 <Keal> if i were millionare i would buy myself a hardbound compiliation of every year
21:06:33 <newsham> havent heard of f#.  gotta url?
21:06:35 <lispy> newsham: manager said VB :)
21:06:50 <newsham> found it.. looking
21:06:51 <musasabi> lispy: that sounds quite ugly.
21:07:05 <yozora> @pl \x -> if x == 1 then x else 0
21:07:05 <newsham> lispy: i think managed code apis will be accessible directly from msh.
21:07:06 <lambdabot> flip (if' =<< (1 ==)) 0
21:07:08 <lispy> musasabi: hey, F# isn't that bad! :)
21:07:12 <newsham> might be another interesting alternative
21:07:21 <Keal> phase lock....
21:07:22 <Keal> hrm
21:07:45 <Keal> will the real slim shady please stand up you all act like you never seen a white person before
21:07:45 <musasabi> lispy: but VB...
21:08:06 <musasabi> starving is not that bad ;)
21:08:13 <lispy> musasabi: i know. my manager started the project, and a think he's not very good with other languages
21:08:22 <newsham> lispy: i had a vb question last week.  I'll have to msg you next time I run across one :)
21:08:28 <musasabi> manager. more evil words.
21:08:40 * Keal grooves
21:08:44 <musasabi> next you start speaking about time sheets...
21:09:19 <musasabi> s/sheet/report
21:09:38 <newsham> ugh, curent project client has me filling out a time card (its an odd setup, I dont want to get into it)
21:09:41 <newsham> how demeaning.
21:09:56 <Keal> hrm need to plan a fieldtrip to Frederick B. Mancoff of Freescale Semiconductor in Chandler, Az.
21:09:59 <Korollary> consultants do that a lot.
21:10:25 <newsham> i usually just tell em # of hours when its done.
21:10:29 <newsham> not fill out a timecard.
21:10:48 <newsham> then again, usually i'm 1099, not w2.
21:11:28 <newsham> lispy: any idea if they intend to push f# out of research ever?
21:11:43 <Keal> i forget what is f#
21:13:07 <musasabi> functional language for .NET
21:14:54 * Keal happens upon a dream
21:15:07 <yozora> what's this "if'" function?
21:15:13 <yozora> @pl \x -> if x == 1 then x else 0
21:15:14 <lambdabot> flip (if' =<< (1 ==)) 0
21:15:24 <yozora> @type if'
21:15:26 <lambdabot> Not in scope: `if''
21:16:17 <yozora> @type Control.Monad.if'
21:16:18 <lambdabot> Not in scope: `Control.Monad.if''
21:17:02 <lispy> newsham: no clue, when i tried it, i didn't see a way to build a gui.  In fact, when i did the hello world example that brings up a window the exe had to be run from the command line (it didn't behave correctly when double clicked)
21:20:37 <yozora> @hoogle if'
21:20:39 <lambdabot> Prelude.undefined :: a
21:20:39 <lambdabot> Data.Graph.Inductive.Monad.emptyM :: GraphM m gr => m (gr a b)
21:20:39 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
21:22:24 <lispy> yozora: if' is the function version of if. Maybe you already knew that.
21:22:58 <SamB> Lemmih: hmm, patching in ADepts old code for bitmap encoding/decoding doesn't seem to have helped much...
21:22:59 <newsham> "ML in .NET heaven"
21:23:00 <newsham> heh.
21:23:18 <newsham> never heard it referred to as heaven before ;-)
21:23:23 <iratsu> where should i go to learn haskell?
21:23:26 <Keal> > let fl = fromIntegral . floor; digit v b p = b*(fl (v/b**p) / b - fl (fl (v/b**p)/b)) in map (digit) [0..1000000000] [2..10000] [10000,(9999)..(-10000)]
21:23:27 <lambdabot>   The function `map' is applied to four arguments,
21:23:27 <lambdabot>   but its type `(a -> b) -> [a] -> [b]' has only two
21:23:27 <lambdabot>   In the definition of `url':
21:23:46 <newsham> iratus: there are tutorials on haskell.org
21:24:28 <Keal> > let fl = fromIntegral . floor; digit v b p = b*(fl (v/b**p) / b - fl (fl (v/b**p)/b)) in map (digit) [0..1000000000] [2..10000] [10000..(-10000)]
21:24:29 <lambdabot>   The function `map' is applied to four arguments,
21:24:29 <lambdabot>   but its type `(a -> b) -> [a] -> [b]' has only two
21:24:29 <lambdabot>   In the definition of `qws':
21:24:29 <Lemmih> SamB: I'm pretty sure my code is correct. It even has QuickCheck tests.
21:24:49 <SamB> Lemmih: ah. well.
21:25:05 <SamB> do they test to make sure it is not only internally consistant but also interoperable?
21:25:21 <SamB> though I'm inclined to believe you at this point ;-)
21:25:31 <Keal> > let fl = fromIntegral . floor; digit v b p = b*(fl (v/b**p) / b - fl (fl (v/b**p)/b)) in map (digit 0..1000000000 2..10000 10000..(-10000))
21:25:32 <lambdabot>  parse error on input `..'
21:25:50 <Keal> > let fl = fromIntegral . floor; digit v b p = b*(fl (v/b**p) / b - fl (fl (v/b**p)/b)) in map (digit [0..1000000000] [2..10000] [10000..(-10000)])
21:25:51 <lambdabot> Couldn't match `a -> b' against `[a1]'
21:25:56 <Keal> why it not work?
21:26:28 <Keal> > let fl = fromIntegral . floor; digit v b p = b*(fl (v/b**p) / b - fl (fl (v/b**p)/b)) in map (digit) [0..1000000000] [2..10000] [(-10000)..10000]
21:26:29 <lambdabot>   The function `map' is applied to four arguments,
21:26:29 <lambdabot>   but its type `(a -> b) -> [a] -> [b]' has only two
21:26:29 <lambdabot>   In the definition of `lwy':
21:26:29 <lispy> ocaml is not the coolest language, but the fact that there might be a good FP language choice for .NET is really cool
21:26:33 <Keal> godamnit
21:26:42 <sethk> Keal, it's telling you that one of those arguments is a a->b, but it wants a list
21:26:47 * Keal screams a rabid horrid parade of dead donkey monks
21:27:09 <Keal> its supposed to dump as 3d array
21:27:37 <sethk> Keal, that doesn't matter.  First you have to figure out where your type errors are
21:27:48 <SamB> Keal: try zipWith3
21:27:56 <SamB> instead of map
21:28:09 <Keal> what is syntax for that
21:28:49 <SamB> Keal: I think if you just write "zipWith3" instead of "map", your program just might work
21:29:36 <Keal> it screeam NaN all over place
21:29:59 <SamB> Keal: well, that hasn't a whole lot to do with Haskell...
21:30:23 <SamB> its more related to floating-point arithmetic in general
21:30:39 <Keal> it dint work
21:30:45 <SamB> not that it isn't useful to talk about here, just that I don't think I'll be much help
21:30:53 <Keal> it not do 3d array
21:31:13 <SamB> Keal: NaN sounds like it worked to me
21:31:21 <Keal> it not do 3d array
21:31:28 <SamB> Keal: you wanted a 3d array?
21:31:31 <Keal> yes
21:31:37 <SamB> you need to be more specific!
21:31:45 <Keal> >:|
21:32:23 <SamB> Keal: I mean, you are specific now when the program doesn't do what you wanted...
21:32:32 <SamB> but before when it gives type errors would also be good
21:32:36 <SamB> anyway...
21:32:42 <SamB> you should look at arrays
21:32:44 <Keal> syntax?
21:32:58 <SamB> @index Data.Array
21:32:59 <lambdabot> bzzt
21:33:14 <SamB> @docs Data.Array
21:33:15 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array.
21:33:15 <lambdabot> html
21:33:24 * SamB needs to go to bed soon
21:33:30 <Keal> > let fl = fromIntegral . floor; digit v b p = b*(fl (v/b**p) / b - fl (fl (v/b**p)/b)) in zipWith3 (digit) [0..100] [2..10] [(-10)..10]
21:33:32 <lambdabot> [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0]
21:33:37 <Keal> does that look 3d to you???
21:34:05 <Keal> it didnt work right at all
21:34:16 <psnl> yes, but it might be the lack of sleep 
21:34:21 <Keal> i want to cycle thru 3 args
21:35:14 <Keal> :(
21:35:35 <SamB> @type Data.Array.array
21:35:36 <lambdabot> forall e i.
21:35:36 <lambdabot> (GHC.Arr.Ix i) =>
21:35:36 <lambdabot> (i, i) -> [(i, e)] -> GHC.Arr.Array i e
21:36:22 <Keal> > let fl = fromIntegral . floor; digit v b p = b*(fl (v/b**p) / b - fl (fl (v/b**p)/b)) in map (digit) [0..100,2..10,(-10)..10]
21:36:23 <lambdabot>  parse error on input `,'
21:36:25 <Keal> :(
21:36:34 <Keal> how doi do it
21:37:31 <Keal> > let fl = fromIntegral . floor; digit v b p = b*(fl (v/b**p) / b - fl (fl (v/b**p)/b)) in map3 (digit) [0..100] [2..10] [(-10)..10]
21:37:32 <lambdabot>  Not in scope: `map3'
21:37:42 <Keal> > let fl = fromIntegral . floor; digit v b p = b*(fl (v/b**p) / b - fl (fl (v/b**p)/b)) in map 3 (digit) [0..100] [2..10] [(-10)..10]
21:37:42 <psnl> when the time is right for you to do it, you will be able to do it
21:37:43 <lambdabot>   The function `map' is applied to five arguments,
21:37:43 <lambdabot>   but its type `(a -> b) -> [a] -> [b]' has only two
21:37:43 <lambdabot>   In the definition of `clt':
21:38:29 <Keal> > let fl = fromIntegral . floor; digit v b p = b*(fl (v/b**p) / b - fl (fl (v/b**p)/b)) in map (digit) -> [0..100] -> [2..10] -> [(-10)..10]
21:38:30 <lambdabot>  parse error on input `->'
21:38:33 * Keal screams
21:38:44 <psnl> Keal: msg it
21:39:03 <Keal> > let fl = fromIntegral . floor; digit v b p = b*(fl (v/b**p) / b - fl (fl (v/b**p)/b)) in map (digit [0..100] [2..10]) [(-10)..10]
21:39:04 <lambdabot>  add an instance declaration for (Enum [a])
21:39:04 <lambdabot>   In an arithmetic sequence: [(- 10) .. 10]
21:39:19 <Keal> i fucking kill you you flaming bitch!!!
21:39:28 * Keal blows away lambdabot
21:39:41 <Keal> -.-;
21:40:32 <Keal> how do i do an instance declaration?
21:40:46 <SamB> Keal: pardom me for intruding, but, ah, lambdabot is not a dog ;-)
21:42:25 <yozora> sure, if' is the function version, but where is it?
21:42:43 <yozora> @hoogle Bool -> a -> a -> a
21:42:45 <lambdabot> Control.Exception.assert :: Bool -> a -> a
21:42:45 <lambdabot> Prelude.asTypeOf :: a -> a -> a
21:42:45 <lambdabot> Control.Parallel.par :: a -> b -> b
21:43:08 <newsham> data BinHandle = BinMem {      off_r :: !FastMutInt,  ....
21:43:16 <newsham> what does the '!' signify?  is that just part of the type name?
21:43:30 <lispy> yozora: it's not defined anywhere, i tihnk it's jus ta convention used by @pl in lambda bot
21:44:06 <lispy> > let if' b c d = if b then c else d in if' True 1 2
21:44:08 <lambdabot> 1
21:44:56 <yozora> last time i learned how to use join and (,) from lambdabot
21:45:27 <yozora> to get \x -> (x,x)
21:45:47 <yozora> so i was hoping to find that another function that i wrote already exists
21:46:21 <yozora> if .. else should be a function rather than special syntax :)
21:48:42 <lispy> yozora: i've sead that many times myself
21:49:18 <yozora> i hate not being able to partial apply, flip, etc it :)
21:50:49 <Keal> > let fl = fromIntegral . floor; digit v b p = b*(fl (v/b**p) / b - fl (fl (v/b**p)/b)) in map (digit) ([0..100] [2..10] [(-10)..10])
21:50:50 <lambdabot>   The function `[0 .. 100]' is applied to two arguments,
21:50:50 <lambdabot>   but its type `[a]' has none
21:51:12 <Keal> > let fl = fromIntegral . floor; digit v b p = b*(fl (v/b**p) / b - fl (fl (v/b**p)/b)) in map (digit [0..100] [2..10] [(-10)..10])
21:51:13 <lambdabot> Couldn't match `a -> b' against `[a1]'
21:51:20 <yozora> there's been quite a lot of activity with the benchmarks lately
21:52:11 <lispy> yozora: i'd so so far as to say more than there needs to be.  But maybe haskell will improve as a result.
21:52:16 <Keal> how do i do a nested ..
21:52:33 <SamB> yozora: well, in this one instance the function wasn't already written, but it is even more trivial than usual...
21:53:25 <Keal> how do i do a nested '..'?
21:53:43 <SamB> lispy: well, if people like doing it...
21:53:49 <lispy> when i try to do a heap profile of darcs it segfaults.  But the same binary runs fine when i don't give the rts options for profiling.
21:53:59 <SamB> Keal: read up on list comprehensions
21:54:07 <yozora> SamB: true, though if-else should go back to the purgatory of C and friends where it came from
21:54:09 <Keal> syntax?
21:54:21 <lispy> SamB: yeah, but it seems like the haskell community could work on things like fixing the GC bugs in ghc instead of optimizing some shootout entries :)
21:54:31 <Keal> i just want it to churn out all possible results of function
21:54:48 <SamB> yozora: at least you don't need any parens/brackets
21:54:54 <yozora> maybe they think of it as raising the profile/reputation of haskell
21:54:58 <Keal> i just want it to churn out all possible results of function
21:55:13 <SamB> lispy: GC bugs require GC hackers
21:55:20 <yozora> that's true, i can't stand having to put in the if brackets in my day job
21:55:24 <SamB> shootout entries do not
21:55:38 <yozora> they're just so redundant, just like the braces and semicolons
21:55:49 <Keal> i just want it to churn out all possible results of function
21:56:08 <Keal> i just want it to churn out all possible results of function
21:56:11 <lispy> SamB: yeah, if i understood the problem better i'm sure i'd be working on it :)
21:56:56 <Keal> i just want it to churn out all possible results of function
21:57:02 <SamB> lisppaste2: if you catch GC hackers working on shootout entries when they need to be fixing the GC, then *maybe* you should be worried
21:57:18 <psnl> Keal: you understand that if you had a function that could take in a function and return all the possible results of that function, the world would expode?
21:57:44 <yozora> and then the NSA would get you
21:57:52 * Keal sets to work..
21:58:33 <lispy> SamB: all i know is that simon acknowledged the bug but said he wasn't going to fix it
21:58:36 <newsham> is there any way to convert a record into a list?
21:59:11 <newsham> I would like to make a record composed of Binarys an instance of Binary
21:59:26 <SamB> newsham: show
21:59:36 <newsham> I dont follow.
21:59:43 <SamB> newsham: oh, that
21:59:48 <SamB> why a list?
21:59:58 <newsham> well, thats just one way.  i'm open to other suggestions
21:59:58 <SamB> dons knows all about Binary...
22:00:04 <newsham> I know how to iterate over a list.
22:00:08 <yozora> sounds like a job for TH
22:00:14 <newsham> template haskell?
22:00:32 <yozora> yeah, i think there was an example of tuple to list somewhere
22:00:58 <newsham> wish haskell had some introspection or something.
22:03:27 <newsham> how does "deriving Show" work for records?
22:04:01 <yozora> maybe treats it like its tuple?
22:04:07 <SamB> newsham: builtin glue-magic
22:04:07 <SamB> or maybe it is magic-glue
22:04:22 <newsham> suspected as much.
22:04:32 <SamB> newsham: eventually there should be a system for automating this for other classes...
22:04:34 <newsham> so basically I would love it if I could "deriving Binary" on record types
22:05:20 <newsham> also this namespace thing is going to be a royal pain.  i was getting name conflicts from other modules for record field names.
22:05:20 <SamB> newsham: a lot of people have been saying this many times
22:05:25 <newsham> I take it records arent a seperate namespace
22:06:23 <palomer> magic-glue induces language enhancements
22:06:36 <palomer> and then the language becomes so enhanced it's a monster
22:07:32 <newsham> put_ bh (IP a b c d e f g h i j k l m) = put_ [a,b,c,d,e,f,g,h,i,j,k,l,m
22:07:33 <SamB> palomer: come on! sniff the magic-glue!
22:07:39 <newsham> is there any easier way to do that?
22:11:37 <lispy> oh hm...i if i compile darcs with -prof on AMD64 IsoDate.hs will not compile (gcc goes mad and sucks up all the memory it can) but without -prof it will compile
22:11:53 <Keal> > let fl = fromIntegral . floor; let dv = [0..10]; let db = [2..10]; let dp = [(-10)..10]; digit v b p = b*(fl (v/b**p) / b - fl (fl (v/b**p)/b)) in map (digit dv db dp)
22:11:54 <lambdabot>  parse error (possibly incorrect indentation)
22:11:57 <Keal> why doesnt that work?
22:12:08 <yozora> @keal
22:12:09 <lambdabot> i think it because mathematics damage you cpu
22:12:16 <yozora> lol
22:12:37 <lispy> Keal: i tihnk you use let too many times
22:13:10 <SamB> Keal: you are aware that Haskell is *not* a dialect of BASIC?
22:13:32 <Keal> shup :P
22:13:36 <Keal> i know that
22:13:47 <lispy> > let fl = fromIntegral . floor; dv = [0..10]; db = [2..10]; dp = [(-10)..10]; digit v b p = b*(fl (v/b**p) / b - fl (fl (v/b**p)/b)) in map (digit dv db dp)
22:13:48 <SamB> then why you code like that?
22:13:48 <lambdabot> Couldn't match `a -> b' against `[a1]'
22:14:07 <Keal> thought maybe haskell is asinine
22:14:13 <lispy> > let fl = fromIntegral . floor; dv = [0..10]; db = [2..10]; dp = [(-10)..10]; digit v b p = b*(fl (v/b**p) / b - fl (fl (v/b**p)/b)) in (digit dv db dp)
22:14:14 <lambdabot>  add an instance declaration for (Floating [a])
22:14:21 <Keal> sicne i been working on this for past 2.5 hours
22:15:26 <Keal> yes and @keal spill beans damn you all
22:15:48 <Keal> :)
22:16:02 <lispy> > let fl = fromIntegral . floor; dv = [0..10]; db = [2..10]; dp = [(-10)..10]; digit v b p = b*(fl (v/b**p) / b - fl (fl (v/b**p)/b)) in zipWith3 digit dv db dp
22:16:04 <lambdabot> [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0]
22:16:13 <Keal> not workie
22:16:45 <Keal> it only cycled thru b
22:18:04 <Keal> lispy :/
22:18:26 <lispy> > take 10 (zipWith3 (+1) [0,0..] [1,1..] [2,2..])
22:18:27 <lambdabot>  add an instance declaration for (Num (b -> c -> d))
22:18:27 <lambdabot>   In an arithmetic sequence: [0, 0 .. ]
22:18:40 <lispy> > take 10 (zipWith2 (+) [0,0..] [1,1..] [2,2..])
22:18:42 <lambdabot>  Not in scope: `zipWith2'
22:18:50 <lispy> > take 10 (zipWith (+) [0,0..] [1,1..] [2,2..])
22:18:51 <lambdabot>   The function `zipWith' is applied to four arguments,
22:18:51 <lambdabot>   but its type `(a -> b -> c) -> [a] -> [b] -> [c]' has only three
22:18:58 <lispy> heh
22:19:02 <lispy> i'm being silly
22:19:07 <lispy> > take 10 (zipWith (+) [0,0..] [1,1..])
22:19:09 <lambdabot> [1,1,1,1,1,1,1,1,1,1]
22:19:27 <psnl> is anyone aware of what Keal is trying to do?
22:19:34 <Keal> @keal is
22:19:35 <lambdabot> i try make program called Glyph to do it but my script lang called T too
22:19:35 <lambdabot> slow. i invent T
22:19:36 <lispy> not sure if you can tell, but zipWith takes an element from each list, applies the function then does it with the next element and so on
22:19:45 <SamB> > [1,1..2]
22:19:47 <lambdabot> [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
22:19:47 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
22:19:47 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
22:19:47 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
22:19:47 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
22:19:49 <lambdabot> [23 @more lines]
22:20:02 <lispy> SamB: heeh, neat trick
22:20:18 <SamB> > [1..1.5]
22:20:19 <lambdabot> [1.0,2.0]
22:20:26 <SamB> strange...
22:20:31 <Keal> > let fl = fromIntegral . floor; let dv = [0..10]; let db = [2..10]; let dp = [(-10)..10]; digit v b p = b*(fl (v/b**p) / b - fl (fl (v/b**p)/b)) zipWith (digit dv db dp)
22:20:32 <lambdabot>  parse error (possibly incorrect indentation)
22:20:50 <Keal> > let fl = fromIntegral . floor; dv = [0..10]; db = [2..10]; dp = [(-10)..10]; digit v b p = b*(fl (v/b**p) / b - fl (fl (v/b**p)/b)) zipWith (digit dv db dp)
22:20:50 <lambdabot>  parse error on input `}'
22:21:22 <Keal> > let fl = fromIntegral . floor; dv = [0..10]; db = [2..10]; dp = [(-10)..10]; digit v b p = b*(fl (v/b**p) / b - fl (fl (v/b**p)/b)) zipWith (digit dv db dp);
22:21:23 <lambdabot>  parse error on input `}'
22:21:25 <Keal> wtf
22:21:42 <SamB> conjure DEFINATELY has SERIOUS issues talking to non-seeders when not a seeder itself...
22:22:14 <SamB> Keal: probably a parse error at the end of your code due to boilerplate
22:22:19 <SamB> > let fl = fromIntegral . floor; dv = [0..10]; db = [2..10]; dp = [(-10)..10]; digit v b p = b*(fl (v/b**p) / b - fl (fl (v/b**p)/b)) zipWith (digit dv db dp)
22:22:20 <lambdabot>  parse error on input `}'
22:22:31 <SamB> I mean, the strange message due to boilerplate...
22:22:52 <Keal> > let fl = fromIntegral . floor; dv = [0..10]; db = [2..10]; dp = [(-10)..10]; digit v b p = b*(fl (v/b**p) / b - fl (fl (v/b**p)/b)) zipWith {(digit dv db dp)}
22:22:53 <lambdabot>  parse error on input `digit'
22:23:07 <lispy> you need a semicolon before zipWith, and zipWith needs to be zipWith3 and you need to get rid of the last paren set
22:23:13 <Keal> > let fl = fromIntegral . floor; dv = [0..10]; db = [2..10]; dp = [(-10)..10]; digit v b p = b*(fl (v/b**p) / b - fl (fl (v/b**p)/b)); zipWith (digit dv db dp)
22:23:13 <lambdabot>  parse error (possibly incorrect indentation)
22:23:32 <Keal> > let fl = fromIntegral . floor; dv = [0..10]; db = [2..10]; dp = [(-10)..10]; digit v b p = b*(fl (v/b**p) / b - fl (fl (v/b**p)/b)) zipWith3 digit dv db dp
22:23:33 <lambdabot>  parse error on input `}'
22:23:36 <Keal> > let fl = fromIntegral . floor; dv = [0..10]; db = [2..10]; dp = [(-10)..10]; digit v b p = b*(fl (v/b**p) / b - fl (fl (v/b**p)/b)); zipWith3 digit dv db dp
22:23:37 <lambdabot>  parse error (possibly incorrect indentation)
22:23:45 <Keal> LIIIIIIIIIIIIAAAAAAAAAAAAAAAAAAARRRRRRRRRRRRRRRRRRr
22:24:33 <lispy> > let fl = fromIntegral . floor; dv = [0..10]; db = [2..10]; dp = [(-10)..10]; digit v b p = b*(fl (v/b**p) / b - fl (fl (v/b**p)/b)) in zipWith3 digit dv db dp
22:24:35 <lambdabot> [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0]
22:24:47 <Keal> > let fl = fromIntegral . floor; dv = [0..10]; db = [2..10]; dp = [(-10)..10]; digit v b p = b*(fl (v/b**p) / b - fl (fl (v/b**p)/b)) in zipWith3 digit dv db dp
22:24:48 <lambdabot> [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0]
22:24:52 <Keal> still not work
22:25:16 <lispy> > [(-10)..10]
22:25:17 <lambdabot> [-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7,8,9,10]
22:25:20 <palomer> pft.
22:25:25 <lispy> >[0..10]
22:25:32 <lispy> > [2..10]
22:25:33 <lambdabot> [2,3,4,5,6,7,8,9,10]
22:25:35 <lispy> > [0..10]
22:25:37 <lambdabot> [0,1,2,3,4,5,6,7,8,9,10]
22:25:47 <lispy> your lists are different sizes
22:25:52 <Keal> sooooo?
22:26:01 <lispy> well, it has to stop when the shortest list is finished
22:26:17 <Keal> LAMEEE3
22:26:42 <lispy> do you want it to loop instead?
22:26:49 <Keal> YES
22:26:55 <Keal> no
22:26:59 <Keal> i mean...
22:27:03 <Keal> ...
22:27:10 <Keal> i want it to nest them
22:28:04 <Keal> think of it as 3 axis
22:28:20 <Keal> and fill volume with results
22:28:33 <lispy> you want the value of digits for each tuple is the cartsean product of those three lists?
22:29:18 <Keal> yes dump function
22:30:07 <SamB> lispy: I could have told you that if I could have remembered what you call them ;-)
22:30:41 <Keal> in other words i want to dump the entire fpu
22:30:57 <yozora> are there any simple applications of arrrows i could play with?
22:32:19 <yozora> i've read about yampa but preferably something simpler to start with...
22:32:24 <Keal> there is an infrared beam aimed at my back porch again ><
22:32:34 <palomer> kill it!
22:32:52 <Keal> i complained to neighbors they say it is not from them
22:32:53 <lispy> > let fl = fromIntegral. floor; dv = [0..10]; db = [2..10]; dp = [(-10)..10]; digit (v,b,p) = b*(fl (v/b**p)/b - fl(fl (v/b**p)/b)) in map digit [ (v, b, p) | v <- dv, b <- db, p <- dp]
22:32:55 <lambdabot> [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,
22:32:55 <lambdabot> 0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.
22:32:55 <lambdabot> 0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,
22:32:55 <lambdabot> 0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.
22:32:55 <lambdabot> 0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,
22:32:57 <lambdabot> [23 @more lines]
22:33:05 <Keal> @more
22:33:05 <lambdabot> 0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.
22:33:05 <lambdabot> 0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,
22:33:07 <lambdabot> 0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.
22:33:09 <lambdabot> 0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,
22:33:10 <lambdabot> 0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.
22:33:13 <lambdabot> [18 @more lines]
22:33:20 <Keal> i could more and more and more...
22:33:22 <palomer> I think we get the idea
22:34:11 <lispy> there is a bug i think
22:34:17 <Keal> > let fl = fromIntegral. floor; dv = [123..125]; db = [2..3]; dp = [10,9..0]; digit (v,b,p) = b*(fl (v/b**p)/b - fl(fl (v/b**p)/b)) in map digit [ (v, b, p) | v <- dv, b <- db, p <- dp]
22:34:18 <lispy> when you lookat the tuples they all start with 0
22:34:29 <lambdabot> [0.0,0.0,0.0,0.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,
22:34:31 <lambdabot> 0.9999999999999998,0.9999999999999991,1.9999999999999982,0.0,0.0,0.0,0.0,
22:34:33 <lambdabot> 0.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.9999999999999
22:34:35 <lambdabot> 998,0.9999999999999991,1.9999999999999982,1.000000000000007,0.0,0.0,0.0,0.
22:34:37 <lambdabot> 0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.999999999999999
22:34:39 <lambdabot> 8,0.9999999999999991,1.9999999999999982,1.999999999999993]
22:34:45 <lispy> oh, no they don't
22:34:51 <dons> > map (ord *** ord) (zip ['A..'Z'] ['a'..'z'])
22:34:52 <lambdabot>  lexical error in string/character literal
22:35:00 <Keal> yay i just showed how crappy x86 fpu is
22:35:27 <dons> yozora, simple arrows ;)
22:35:32 <SamB> Keal: too bad we are running lambdabot on an x86
22:35:34 <SamB> @version
22:35:45 <lambdabot> lambdabot 3p266, GHC 6.5.20050806 (Linux i686)
22:35:47 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
22:35:55 <Keal> now... /me grins evilly
22:36:59 <lispy> i just heap profiled darcs but the output is meaningless to mee...
22:37:20 <SamB> lispy: hehe
22:37:30 <SamB> tried hp2ps/hp2graph
22:37:33 <dons> > 0.1 + 0.2 -- oh no the NSA!
22:37:35 <lambdabot> 0.30000000000000004
22:37:42 <SamB> I can never remember which is for GHC and which is for nhc98
22:37:50 <palomer> oh my
22:38:13 <SamB> dons: that'll teach you to use FP
22:38:30 <Keal> > let fl = fromIntegral. floor; dv = [inf..0]; dvq = [inf..0]/inf; db = [2..inf]; dp = [(-inf)..inf]; dpq = [inf..0]/inf; digit (v,b,p) = b*(fl (v/b**p)/b - fl(fl (v/b**p)/b)) in map digit [ (v, b, p) | v <- (dv+dvq), b <- db, p <- (dp+dpq)]
22:38:31 <lambdabot>  Not in scope: `inf'
22:38:33 <Keal> wtf
22:38:37 <Keal> how do i define inf
22:38:37 <SamB> > 1%10 + 2%10
22:38:39 <lambdabot> 3%10
22:38:44 <palomer> > foldl1 (+) (\x -> x/10.0) [1..10]
22:38:46 <lambdabot>   The lambda expression `\ x -> ...' has one arguments,
22:38:46 <lambdabot>   but its type `[a]' has none
22:39:01 <palomer> > foldl1 (+) (map (\x -> x/10.0) [1..10])
22:39:03 <lambdabot> 5.5
22:39:09 <palomer> > foldl1 (+) (map (\x -> x/10.0) [1..100])
22:39:10 <lambdabot> 505.0
22:39:18 <palomer> > foldl1 (+) (map (\x -> x/10.0) [1..2])
22:39:20 <lambdabot> 0.30000000000000004
22:39:30 <dons> @keal is a troll
22:39:31 <palomer> > foldl1 (+) (map (\x -> x/100.0) [1..2])
22:39:31 <lambdabot> all i know is i have experienced my own death unhappening...
22:39:33 <lambdabot> 3.0e-2
22:39:35 <lispy> SamB: that was the output i'm talking about..it made a nice graph that makes no sense, it's basically not labeled
22:39:36 <palomer> > foldl1 (+) (map (\x -> x/100.0) [1..10])
22:39:38 <lambdabot> 0.55
22:39:41 <palomer> > foldl1 (+) (map (\x -> x/100.0) [1..20])
22:39:41 <Keal> how do i tell haskell inf
22:39:43 <lambdabot> 2.0999999999999996
22:39:56 <yozora> I'll try the Paterson paper again perhaps
22:40:06 <SamB> lispy: doesn't it have a legend?
22:40:07 <Keal> how do i tell haskell inf
22:40:30 <yozora> is that arrow syntax part of ghc?
22:40:34 <SamB> lispy: maybe you don't have cost centers in your darcs build?
22:40:49 <lispy> SamB: yeah, but it was weird stuff and everything was abbreviated so it was illegiable
22:40:51 <SamB> > 1/0
22:40:53 <lambdabot> Infinity
22:41:00 <lispy> SamB: well, i have auto-all for cost centers
22:41:10 <Keal> but n/1/0 not make sense tho
22:41:11 <lispy> SamB: so i have some...but probably no useful ones
22:41:29 <Keal> > Infinity
22:41:30 <lambdabot>  Not in scope: data constructor `Infinity'
22:41:38 <Keal> see wrong
22:41:42 <lispy> SamB: i don't even know where to put them right now, i was hoping the profiling would give me a clue
22:41:48 <dons>  /ignore Keal
22:42:02 <Keal> :<
22:42:17 * Keal compromises...
22:42:32 <SamB> Keal: you write it "1/0"
22:42:40 <SamB> > read "Infinity" :: Double
22:42:42 <lambdabot> Infinity
22:42:42 <lispy> i thought haskell wasn't supposed to segfault, but i just got "*** glibc detected *** double free or corruption (!prev): 0x0896a5c0 ***"
22:43:41 <Keal> > let fl = fromIntegral. floor; dv = [2**64..0]; dvq = [2**64..0]/2**64; db = [2..2**64]; dp = [(-2**64)..2**64]; dpq = [2**64..0]/2**64; digit (v,b,p) = b*(fl (v/b**p)/b - fl(fl (v/b**p)/b)) in map digit [ (v, b, p) | v <- (dv+dvq), b <- db, p <- (dp+dpq)]
22:43:42 <lambdabot>  add an instance declaration for (Floating [a])
22:44:18 <lispy> Keal: you can't divid a list by a number
22:44:28 <Keal> then how do i do that?
22:44:49 <lispy> you have to map the division onto the elements of the list
22:44:58 <Keal> how :(
22:45:23 <lispy> using map
22:45:30 <psnl> map clue Keal
22:45:34 <lispy> @type map
22:45:36 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
22:47:30 <Keal> > map [ (v, c) | v < c/10 | c <- [0..10]]
22:47:31 <lambdabot>  Not in scope: `c'
22:47:34 <Keal> :/
22:47:49 <Keal> > map [ (v, c) | v <- c/10 | c <- [0..10]]
22:47:50 <lambdabot>  Not in scope: `c'
22:48:09 <Keal> > map [ (c) | c <- [0..10]]
22:48:10 <lambdabot> Couldn't match `a -> b' against `[a1]'
22:48:23 <dons> Keal. Do not continue to experiment in the channel. use your own instance of ghc.
22:48:36 <Keal> ghc work with this???
22:48:54 <dons> idiot.
22:49:51 <psnl> or /msg lambdabot, assuming you aren't using too much of dons' processing power
22:50:25 <Keal> paste not work with ghc :(
22:51:58 <Keal> ghc worthless if i cannot paste
22:52:04 <lispy> dons: have you ever done a memory profile of FPS?
22:52:48 <lispy> dons: i'm guessing yes, and it was pretty efficient?
22:55:28 <dons> lispy, yes. lots of profiling
22:57:47 <newsham> advice on this code please?  http://www.lava.net/~newsham/x/Pkts.lhs.txt
22:57:59 <newsham> I'm sure lots of it could be better.
22:58:28 <lispy> >
22:59:18 <lispy> dons: okay, it looks like dacrs wastes a lot of memory in the FPS modules, but i don't think that's FPS's fault
23:02:02 <Keal> why does it ask about `in'?
23:02:03 <Keal> > let fl = fromIntegral. floor; dv = [2**64..0]; dvq = [2**64..0]/2**64; db = [2..2**64]; dp = [(-2**64)..2**64]; fpq (q) = q/2**64 in map fpq [ (q) | q <- [0..2**64]]; fvq (q) = q/2**64 in map fvq [ (q) | q <- [0..2**64]]; digit (v,b,p) = b*(fl (v/b**p)/b - fl(fl (v/b**p)/b)) in map digit [ (v, b, p) | v <- (dv+fvq(), b <- db, p <- (dp+dpq)]
23:02:04 <lambdabot>  parse error on input `in'
23:03:19 <newsham> anybody have ideas on how I can avoid the manual Binary instantiation?
23:03:25 <lispy> newsham: do youinsert all the ">" yourself?
23:03:33 <newsham> yah.
23:03:48 <SamB> newsham: hire monkeys to do it for you?
23:04:07 <newsham> >'s arent much more expensive than tabs
23:04:18 <lispy> Keal: because you have more than one in
23:04:26 <Keal> :o?
23:04:38 <newsham> trust me, those >'s are not slowing me down at all.. i move at the speed of molasses with haskell still :)
23:04:53 <Keal> i am trying to plug the first two maps into the third map
23:05:05 <lispy> newsham: i was really wondering, i've thought about using Bird style, but i don't want to type those
23:05:23 <newsham> :%s/^/>/g   if you wanna add em after the fact
23:05:37 <SamB> lispy: I'm not sure if you have to type them or not
23:05:38 <lispy> Keal: write it in file, then you don't have to use one huge unmanagble line
23:05:59 <Keal> lispy i try write secret project must be one line
23:06:01 <Keal> @keal
23:06:02 <musasabi> newsham: use drift?
23:06:02 <lambdabot> antiparsimony were 100% correct...
23:06:11 <SamB> lispy: oh, in Vi I have no clue...
23:06:12 <lispy> SamB: well, with a good editor it should be transparent, but i don't think emacs will do it
23:06:59 <SamB> lispy: certainly Emacs does indentation fine without bothering them
23:07:21 <lispy> indentation in haskell-mode?  it can't even get that right...
23:08:01 <SamB> lispy: true!
23:08:01 <SamB> and annoying
23:08:12 <SamB> however, I really can't blame it for being confused
23:08:23 <SamB> Haskell syntax is awful complicated in that sort of way
23:08:26 <lispy> but probably my biggest petpeeve with haskell-mode in emacs is that you can't use block uncomment and get valid code.  It leaves a space and then the indentation is off and you get compilation errors
23:08:43 <lispy> SamB: yeah, it probably needs a parser to get it right
23:09:06 <SamB> lispy: ouch
23:09:20 <SamB> well, thats what nested {--}s are for...
23:11:01 <newsham> drift?
23:12:11 <musasabi> You may wish to DrIFT to http://repetae.net/~john/computer/haskell/DrIFT/
23:13:39 <Keal> how do i collate maps
23:13:43 <newsham> so you're recommending preprocessing the record to generate the marshall function?
23:15:42 <Keal> what is wrong with the following?
23:15:43 <Keal> in map digit [ (v, b, p) | v <- dv+fq(dvq), b <- db, p <- dp+fq(dpq)]
23:16:20 <Keal> lispy?
23:16:35 <lispy> what is dv+fq(dvq) supposed to do?
23:16:40 <Keal> fq is function
23:16:50 <Keal> dvq is [blah..blah]
23:17:07 <Keal> dv is another [blah..blah]
23:17:33 <lispy> try this v <- zipWith (+) dv (map fq dvq)
23:17:37 <Keal> i am trying to overload the map
23:18:16 <Keal> can haskell not overload mappings?
23:19:24 <lispy> haskell has overloading, but i don't think map can be overloaded in the way you want to overload
23:20:30 <Keal> i would like it to overload so that it collates
23:20:33 <Keal> :>
23:21:13 <Keal> but i am thinking i must add two extra arguments to digit
23:21:14 <musasabi> newsham: yes.
23:21:20 <musasabi> Now -> Tampere
23:21:40 <lispy> well the thing i typed would apply fq to every element of dvq then sum the lists dv and the previous result element-wise.  Isn't that the same thing as you want?
23:21:45 <newsham> anything else that can make the code better?
23:21:54 <Keal> i try and overload in order to cut down on code and have haskell automatically combine the mapping while retaining original fucntion
23:24:02 <Keal> ghc need to have plugin that allow copy paste in xp
23:24:18 <lispy> > let (.+) = zipWith in [1..3] .+ [1..3]
23:24:19 <lambdabot> Couldn't match `a -> b -> c' against `[a1]'
23:24:55 <newsham> copy and paste works in xp.  if you're in a cmd window you might want to set 'quickedit' in the properties
23:25:30 <lispy> Keal: try somethinglike this > let (.+) = zipWith (+) in [1..3] .+ [1..3]
23:25:38 <lispy> Keal: then you can use .+ to add two lists
23:28:03 <Keal> tnkq
23:28:50 <Keal> > let fl = fromIntegral. floor; dv = [2**64..0]; db = [2..2**64]; dp = [(-2**64)..2**64]; dvq = [0..2**64]; dpq = [0..2**64]; fq (q) = q/2**64; digit (v,b,p) = b*(fl (v/b**p)/b - fl(fl (v/b**p)/b)) in map digit [ (v, b, p) | v <- dv.+fq(dvq), b <- db, p <- dp.+fq(dpq)]
23:28:51 <lambdabot>  Not in scope: `.+'
23:28:52 <Keal> not work
23:29:24 <lispy> Keal: you have to define it like i did before you can use it
23:29:35 <newsham> > let (.+) = zipWith (+) in [1..3] [4..6]
23:29:36 <lambdabot>   The function `[1 .. 3]' is applied to one arguments,
23:29:36 <lambdabot>   but its type `[a]' has none
23:29:36 <lambdabot>   In the definition of `njw': njw = let .+ = zipWith (+) in [1 .. 3] ([4 .
23:29:36 <lambdabot> . 6])
23:29:52 <newsham> > let (.+) = zipWith (+) in [1..3] .+ [4..6]
23:29:54 <lambdabot> [5,7,9]
23:30:04 <Keal> i simply need to have passed [inf..-inf]+[0..<1] in other words
23:30:44 <newsham> zip(aleph0, aleph1) 
23:31:06 <Keal> i used [(-2**64)..2**64] + [0..2**64]/2**64
23:31:10 <Keal> in a sense
23:31:30 <Keal> iterate by 1/2**64 in other words
23:31:38 <Keal> :/
23:31:47 <Keal> is what need done
23:32:36 <Keal> newsham how i iterate by a fraction?
23:32:48 <Keal> using [blah..blah] ?
23:32:54 <lispy> something like? let inf = 2**64; epsilon = 1/inf; [-inf,-inf+epsilon..inf]
23:33:41 <Keal> oh i see
23:34:14 <newsham> [n/d | n <- [0..d], d <- [1..]]  ?
23:39:03 <Keal> > let fl = fromIntegral. floor; inf = 2**64; epsilon = 1/inf; dv = [inf,(inf-epsilon)..0]; db = [2..inf]; dp = [(-inf),(-inf+epsilon)..inf]; dvq = [0..inf]; digit (v,b,p) = b*(fl (v/b**p)/b - fl(fl (v/b**p)/b)) in map digit [ (v, b, p) | v <- dv, b <- db, p <- dp]
23:39:05 <lambdabot> []
23:39:08 <Keal> :/
23:39:15 <Keal> i busted his puter
23:39:28 <Keal> sorry dons
23:40:20 <Keal> newsham what i do wrong?
23:41:19 <Keal> hello?
23:41:31 <Keal> did i break entire internet?
23:41:52 <lispy> Keal: you probably have an empty list
23:41:57 <Keal> ok
23:42:13 <lispy> one of dv, db or dvp
23:42:14 <Keal> i make epsilon to small?
23:42:47 <lispy> > 1/2**64
23:42:49 <lambdabot> 5.421010862427522e-20
23:43:24 <Keal> i think...
23:43:26 <Keal> > let fl = fromIntegral. floor; inf = 2**64; epsilon = 1/inf; dv = [inf,(inf-epsilon)..0]; db = [2..inf]; dp = [(-inf),(-inf+epsilon)..inf]; digit (v,b,p) = b*(fl (v/b**p)/b - fl(fl (v/b**p)/b)) in map digit [ (v, b, p) | v <- dv, b <- db, p <- dp]
23:43:27 <lambdabot> []
23:43:29 <Keal> broke haskell
23:43:35 <Keal> ?:/
23:44:25 <newsham> no channel ops?
23:44:33 <lispy> > let inf = 2**64; e = 1/inf in take 5 [inf, (inf-e)..0]
23:44:35 <lambdabot> []
23:44:51 <lispy> Keal: it's a problem with dv
23:45:01 <Keal> perhaps i blow out dons's fpu
23:45:04 <Keal> :/
23:45:38 <newsham> > [5..0]
23:45:39 <lambdabot> []
23:45:42 <Keal> because that expression i typed is a malicious fpu destroyer
23:46:10 <Keal> only malicious because nsa hardcase a failsafe in fpu
23:46:18 <Keal> otherwise it would work
23:46:51 <Keal> if that expression did indeed return a full [] then dons would be out a computer
23:47:24 <newsham> *** Ignoring ALL messages from KEAL
23:48:08 * Keal cries :(
23:48:36 <Keal> lucky thing is it covered by warranty
23:48:42 <sieni> lambdabot: [5,4..0]
23:48:52 <sieni> > [5,4..0]
23:48:54 <lambdabot> [5,4,3,2,1,0]
23:49:40 * Keal tries again..
23:50:19 <Keal> yes i think i broke ghc
23:50:52 <Keal> performing that operation is blocked by nsa failsafe
23:51:44 <Keal> reason it is blocked due to usage for decryption
23:52:09 <Keal> like biblecode on crack
23:52:46 <Keal> and know you know this 24 periods Keal SecretTM
23:53:39 <Keal> tomorrow i share next mathematical secrety
23:53:55 <Keal> tomorrow i shall share secret regarding logic
23:54:56 <Keal> btw that failsafe is even in Linus Torvalds' x86 clone chip
23:55:25 <Keal> zilogs have failsafe too
23:55:55 <lispy> what about magic-1?
23:55:59 <Keal> ?
23:56:13 <Keal> i forget
23:56:16 <Keal> :/
23:56:17 <Keal> sorry
23:56:47 <lispy> http://www.homebrewcpu.com/
23:57:00 <Keal> tomorrow i tell other half of secret
23:57:08 <Keal> how to emulate in order to avoid failsafe
23:57:24 <Keal> because emulation alone does not avoid failsafe
23:57:31 <Keal> but my program seles can ;)
23:57:55 <Keal> only prollem is it spawns massive emulated ramdrive
23:58:09 <Keal> which is not exactly ramdrive...
23:58:19 <Keal> is moreso massive transistor
23:58:42 <newsham> interesting.  i've seen the MyCpu before, but not some of these other ones
23:58:46 <Keal> bascially turn ram into mega chip
23:58:53 <newsham> i was thinking of making a pdp8 out of lsi but it never happened
23:58:59 * integral has been meaning to write his own floating point + fixed point library for fun
23:59:13 <Keal> prollem with mega chip is it very very slow
23:59:16 <newsham> nothing fun about writing a floating point library
23:59:24 <Keal> only performs bitwise operation per cycel
23:59:29 <lispy> newsham: yeah, magic-1 is very impressive.  Apparently it's serving webpages now and has preemptive multitasking.  And the whole thing is built from scratch except maybe the C compiler and the networking stack
23:59:44 <Keal> either an and or an or or a not
23:59:55 <newsham> http://docs.sun.com/source/806-3568/ncg_goldberg.html
