01:06:36 <JohnMeacham> jyp musasabi: both your bugs should be fixed in darcs jhc
01:06:44 <jonkri> hello people
01:21:45 <musasabi> JohnMeacham: now it compiles to much fewer lines, but the resulting executable segfaults.
01:23:48 <musasabi> JohnMeacham: latest darcs version and with: main = print (sum [1..10] :: Int)
01:24:21 <JohnMeacham> musasabi: hrm? it shouldn't segfault. will test it in a bit.
01:44:57 <musasabi> JohnMeacham: the problem is that jhc_mem is not initialized.
01:47:21 <musasabi> JohnMeacham: I'll submit a patch to fix things up.
01:48:06 <JohnMeacham> mussabi: works fine for me.
01:48:18 <JohnMeacham> musasabi: works fine for me I mean. hmm.
01:49:08 <JohnMeacham> what sort of system do you have?
01:49:46 <JohnMeacham> if you have the boehm gc installed, you can compile with -fboehm and have it use that memory allocator instead.
01:53:21 <dcoutts> JohnMeacham, how is Jhc's FFI support these days?
01:53:26 <musasabi> JohnMeacham: the problem is that malloc(1gb) fails on my machine (linux with 512mb of ram)
01:54:06 <musasabi> JohnMeacham: I'll make it use JHCMEM if defined instead of 1gb ?
01:55:34 <JohnMeacham> musasabi: okay, I made it succesivly try lower values until it succeeds. patch forthcoming.
01:55:45 <JohnMeacham> dcoutts: pretty much perfect except for calling haskell from C code.
01:56:05 <JohnMeacham> dcoutts: a goal of jhc was no built in primitives, almost everything is done via the FFI
01:56:11 <dcoutts> JohnMeacham, oh, you've got the export "wrapper" thing
01:56:28 <dcoutts> import wrapper I mean
01:56:29 <JohnMeacham> dcoutts: hrm.. maybe not. 
01:56:31 <musasabi> JohnMeacham: ok, that works fine too.
01:56:33 <dcoutts> previously known as dynamic export
01:56:54 <JohnMeacham> dcoutts: yeah, I don't think I have that either. I guess the FFI support is 'mediocre' then :)
01:57:00 <dcoutts> which allows me to convert a Haskell closure to a C function pointer to pass to C code.
01:57:19 <JohnMeacham> dcoutts: oh. that is calling haskell from C, so no I don't support that.
01:57:41 <dcoutts> JohnMeacham, as you can imagine, I would need such support for gtk2hs, since the GUI has to call back
01:58:00 <dcoutts> ok, I thought you meant a C interface to the Haskell runtime
01:58:03 <dcoutts> which I don't need
01:58:13 <dcoutts> just to be able to hand out C pointers to Haskell functions
01:58:13 <JohnMeacham> musasabi: don't you have any swap?
01:59:17 <musasabi> JohnMeacham: I add when I need, but no local hd, and swapping over network is kind of slow.
01:59:49 <dcoutts> JohnMeacham, it's in the FFI spec, section 4.1.1
01:59:50 <dcoutts> http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffise4.html#x7-160004.1
02:01:08 <JohnMeacham> musasabi: we actually had a whole cluster at tech for a while that swapped over the network to other machines RAM because that was faster than the local hard disk.
02:01:16 <dcoutts> it's a very minor point in the spec but is quite a large feature to implement
02:01:18 <dcoutts> it says:
02:01:20 <dcoutts>  The second and third alternative, identified by the keywords dynamic and wrapper, respectively, import stub functions that have to be generated by the Haskell system. In the case of dynamic, the stub converts C function pointers into Haskell functions; and conversely, in the case of wrapper, the stub converts Haskell thunks to C function pointers.
02:01:45 <JohnMeacham> dcoutts: yeah, I know of them, I just have not had a need of them yet.
02:02:13 <dcoutts> JohnMeacham, there's a wadge of assembly code in the ghc rts which implements it. It's not all that easy. :-(
02:02:13 <JohnMeacham> musasabi: patch published
02:02:33 <JohnMeacham> dcoutts: I know. I have not figured out a portable way to do it yet... 
02:03:43 <dcoutts> JohnMeacham, a slightly more portable way might be to use libffi
02:03:58 <dcoutts> but that's just using a pre-packaged bit of assembly :-)
02:04:08 <musasabi> JohnMeacham: that might true for gig networks, with linux I have had too many performance and stability issues with network swapping. (my NetBSD machines do it however)
02:04:35 <JohnMeacham> dcoutts: I don't really want any external library dependencies. but I might have to settle for one in that case. it would probably just be a header file with a whole lot of system dependent #ifdefs.
02:04:54 <dcoutts> JohnMeacham, people often statically link to libffi
02:05:03 <JohnMeacham> musasabi: this was HPUX on thicknet. so a while ago :)
02:06:27 <JohnMeacham> dcoutts: do you know where the main libffi page is? I can only find one that says it is out of date.
02:08:51 <musasabi> JohnMeacham: now jhc works fine :-)
02:08:51 <JohnMeacham> dcoutts: hmm. looks like libffi might give me what I need. none of the standard libraries need dynamic/wrapper so jhc won't normally hane to link against it anyway. library dependences are determined lazily, so you can link against haskell libraries that depend on C libraries that don't exist if you just happen to not use any of the functions that need said libraries. this also lets the generated C files be compiled on some 
02:08:51 <JohnMeacham> other random system.
02:13:11 <musasabi> Is libffi GCC specific?
02:13:50 <sieni> JohnMeacham: I found the actual documentation from somewhere, when I was looking for it... maybe from the gcc source tarball
02:16:53 <dblhelix> dons: ping?
02:17:01 <dcoutts> JohnMeacham, yeah the libffi web page is well out of date
02:17:12 <dcoutts> libffi is now distributed with gcc
02:17:28 <dcoutts> it comes with some docs
02:17:39 <JohnMeacham> dcoutts: I see. I will give it a look when I need dynamic/wrapper ffi bindings. (unless someone beats me to it :) )
02:17:55 <dcoutts> JohnMeacham, great
02:18:10 * dcoutts is looking to get gtk2hs working with more than just ghc
02:18:17 <dblhelix> someone knows what to do if hs-plugins complains about "unknown symbols"? (in this case,  it's about System.IO.getContents)
02:18:32 * dcoutts wants gtk2hs to work with yhc, jhc and maybe even hugs!
02:18:54 * JohnMeacham wants 'Hello World' to work with jhc
02:20:11 <musasabi> it works, doesn't it?
02:20:44 <JohnMeacham> musasabi: yup. and in 4120 bytes :)
02:21:23 <musasabi> Having jhc compile itself would be nice++ ;)
02:23:17 * gour desires to compile gtk2hs with more than just ghc
02:23:45 <JohnMeacham> musasabi: that's a long way off. but a whole lot more of the nofib suite compiles now. there are a few major looming projects very much holding jhc back, none of which have an easy starting point: one is rewriting the code generator to produce loops, do region inference, and use c-- as an intermediate language, the other is arrays, which entails updatable heap entries, which are complicated. (it would make Data.IORef work to
02:23:46 <JohnMeacham> o though)
02:24:43 <JohnMeacham> musasabi: my current plan for unboxed arrays is just to implement them via Foreign.Storable. those can be done portably actually.
02:25:30 <JohnMeacham> musasabi: oh, and finishing the new typechecker, which will give rank-n types, which will give foldr/build deforestation when combined with user specified rules.
02:25:41 <musasabi> hmm, what does that mean for STUArray code performance?
02:25:49 <kosmikus> ProfTeggy: hey, you made it to LtU :)
02:26:11 <ProfTeggy> kosmikus, uh oh
02:26:14 <ProfTeggy> Recently?
02:26:42 <JohnMeacham> musasabi: should be as fast as it possibly can be. Foreign.Storable code should compile to be as fast as C code. though, we need the ForeignData extension, which is not too tricky.
02:27:09 <kosmikus> ProfTeggy: comments for the "Wadler" entry ...
02:27:29 <ProfTeggy> kosmikus, let me see
02:28:06 <musasabi> JohnMeacham: ok :-)
02:32:24 <ProfTeggy> kosmikus, aha -- thanks for the pointer.  
02:33:29 <ProfTeggy> Although I would be more interested in the 'Theorems for Free'-based answer to the question ;-)
02:34:54 <ProfTeggy> I could convince Philip to be a PC member of the upcoming XIME-P 2006 workshop.
02:34:58 <ProfTeggy> Nice guy.
02:36:00 <kosmikus> well, just ask him ;)
02:42:35 <ProfTeggy> The second comment got it wrong, by the way
02:47:16 <jonkri> anyone knows where i can get a good explanation about properties?
02:50:50 <JohnMeacham> musasabi: I'm glad someone finally motivated me to fix that type-analysis thing. it sure makes a big difference in compile time.
02:53:12 <jonkri^haskell> sorry for nick changes
03:07:02 <joelk> what's the ghc option to pass through options to gcc?
03:07:41 <JohnMeacham> -optc-m32
03:08:01 <joelk> thanks!
03:15:47 <lome> @lam C
03:15:48 <lambdabot> variable 'C' not in scope
03:16:24 <lome> lambdabot understands I, K, S, B, W but not C
03:21:25 <dcoutts> xerox, Cale, you about? want to play with some nice cairo code?
03:23:29 <jonkri^haskell> bye all
03:33:55 <tromp_> > K K K
03:33:56 <lambdabot>  Not in scope: data constructor `K'
03:35:54 <lome> @lam K
03:35:54 <earthy> lam K K K
03:35:54 <lambdabot> \x. \y. x
03:36:04 <lome> @lam K K K
03:36:05 <lambdabot> K
03:42:24 <tromp_> @lam S K S
03:42:24 <lambdabot> \x. x
03:42:37 <musasabi> JohnMeacham: yes, it seems very fast now :-)
03:43:21 <tromp_> @lam KKK
03:43:22 <lambdabot> variable 'KKK' not in scope
03:43:42 <tromp_> @lam S S K (S S K) (S S K)
03:43:54 <lambdabot> Terminated
04:11:41 <Lemmih> dcoutts: I changed getCabalPackageForFile to getBuildInfoForFile.
04:12:16 <dcoutts> Lemmih, fair enough. Any reason?
04:13:23 <Lemmih> Otherwise the using plugins would have to figure out if the file belongs to the library or one of the executables.
04:15:05 <dcoutts> I don't follow
04:16:23 <Lemmih> Just knowing which package a file belongs to isn't enough to build it.
04:16:59 <Lemmih> The library and the executables can have different build options.
04:25:22 <dcoutts> Lemmih, so what's the solution do you think?
04:26:41 <Lemmih> Getting a BuildInfo instead of a CabalPackage.
04:27:47 <ulfdoz> Is it me or does Data.Map use a quite strange argument ordering in its functions?
04:30:47 <musasabi> ulfdoz: having the Map as last is convenient when composing things
04:33:33 <flux__> I've sometimes wondered if it would work (sufficiently) if instead of the order of argumnts the types of the arguments would be used instead
04:33:47 <ulfdoz> I trapped into it, when using Map.fold, which uses for the function in the first argument a different argument order than I was used to from List.fold*
04:34:00 <flux__> so, atleast in the case you wouldn't have maps of maps, Map.foo a b would work the same as Map.foo b a
04:34:17 <flux__> that would be very nice when partially applying functions
04:34:31 <ulfdoz> wouldn't this impy different types for all arguments?
04:35:23 <flux__> yes, that's mostly the problem
04:35:31 <flux__> but in many cases that holds true
04:35:49 <flux__> and maybe you could wrap certain types, such as Map.foo (Wrap a) b
04:39:02 <dcoutts> Lemmih, and how does that solve the issue?
04:41:28 <flux__> also I think it might make type inference algorithms more difficult
04:42:04 <Lemmih> dcoutts: The BuildInfo contains all the information needed to build a file.
04:42:08 <Lemmih> (well, almost)
04:42:36 <dcoutts> Lemmih, and how is that different from the info from the .cabal file?
04:42:56 <Lemmih> dcoutts: The PackageDescription contains several BuildInfo's.
04:43:12 <dcoutts> Lemmih, oh I see
04:43:31 <dcoutts> Lemmih, so we match it to the right stanza in the .cabal file
04:44:18 <dcoutts> Lemmih, can one file be built by more than one stanza?
04:44:58 <dcoutts> eg if a .cabal file has a lib and a prog
04:45:13 <dcoutts> can a single module be used in both and with different flags?
04:45:22 <dcoutts> if so I don't think the current cabal copes with that
04:47:03 <flux__> hmm.. infact Map.foo (Map.Arg2 foo) (Map.Arg1 bar) could almost be usable, I wonder if that kind of arrangement is impossible with plain (template?) haskell
04:49:05 <flux__> (hmm, maybe infact I could give more use to ocaml's labeled arguments)
05:11:41 <zacch> hi, I've got 2 questions concerning lazy evaluation - the first one is that I read it makes tail recursion optimization unnecessary - how exactly?
05:14:52 <sieni> zacch: well, at least using tail recursion won't necessarily do what you would expect
05:15:32 <sieni> zacch: if you try to compute the factorial tail-recursively, you end up computing something like: fact(3,1) = fact(2,3*1) = fact(1,2*3*1) = fact(0,1*2*3*1) = 1*2*3*1 = 1*2*3 = 1*
05:15:36 <sieni> 6 = 1
05:15:56 <sieni> (I guess)
05:16:12 <zacch> the second one is about memoization: if I write down for example fibonacci naively (double-recursion), I need exponential stack space - so OK, there are ways to do it with streams or currying such that all thunks are evaluated at most once - but how exactly do these versions differ, i.e., what is necessary to make the interpreter realize that two expressions are really "the same"
05:17:06 <zacch> sieni: that's clear, it is therefore slower for large numbers because intermediate results are bigger, you would introduce a third argument to circumvent that
05:18:30 <zacch> sieni: what I'm referring to is tail-recursion optimization done by the compiler, i.e., not having to preserve stack frames that are no longer needed - I don't see how lazy evalution removes that special case yet
05:35:00 <Lemmih> zacch: In a strict language it would be problematic if 'map' wasn't tail-recursive.
05:41:48 <zacch> Lemmih: I think it usually ISN'T tail-recursive anyways no? (in Prolog it is, because you have logical variables, but if you think in terms of return values it has to be non-tail-recursive, no? (cons f(x) (map f xs))
05:53:34 <araujo> God morning.
06:02:24 <SimonRC> @help
06:02:24 <lambdabot>  @help <command> - ask for help for <command>
06:02:34 <SimonRC> @type S
06:02:34 <lambdabot> Not in scope: data constructor `S'
06:02:43 <SimonRC> @type k
06:02:44 <lambdabot> Not in scope: `k'
06:03:32 <SimonRC> @type let y = \f -> f(y f) in y
06:03:33 <lambdabot> forall t. (t -> t) -> t
06:03:46 <SimonRC> hmm
06:03:51 <SimonRC> :-S
06:04:40 <SimonRC> @type (\x->x x)(\z f -> f(z z f))
06:04:41 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
06:04:41 <lambdabot>   Expected type: t
06:04:44 <SimonRC> hmm
06:04:57 <SimonRC> but they're the same in \ calc
06:09:07 <bet0x> what is Haskell?¿
06:09:42 <Heffalump> it's a programming language.
06:10:53 <bet0x> like C / C++ ?
06:11:06 <tromp_> i don't think you can give a non-recursive typable definition for fix
06:11:38 <xerox> You can't type \x -> x x, IIRC.
06:11:39 <samc> almost, but not quite, completely unlike C
06:12:09 <xerox> bet0x: it is a pure functional, strongly/strict typed programming language.
06:12:19 <tromp_> that's right, you can not apply any expression to itself in typed lambda calculus
06:12:56 <bet0x> hum
06:13:03 <bet0x> i can write games with this?
06:13:19 <xerox> It depends upon you :)
06:13:19 <bet0x> or simple windows/linux apps for X / gui?
06:13:31 <xerox> It has the potential, yes.
06:13:43 <bet0x> perfect
06:13:44 <glauber_sp> bet0x, www.haskell.org has a lot of projects. give a look on it
06:13:50 <bet0x> i will learn something
06:14:04 <bet0x> yes glauber_sp, im reading
06:14:17 <xerox> bet0x: they usually advice this as a good haskell tutorial:
06:14:19 <ValarQ> bet0x: do you know any other programming language?
06:14:21 <xerox> @where yaht
06:14:22 <lambdabot> http://www.isi.edu/%7Ehdaume/htut/
06:14:33 <xerox> @google Yet Another Haskell Tutorial filetype:pdf
06:14:34 <lambdabot> http://www.isi.edu/~hdaume/htut/tutorial.pdf
06:14:34 <samc> "completely" or is it  "entirely"?
06:14:38 <bet0x> what is the compiler, i see 3 "Implementations"
06:14:58 <xerox> Go for GHC.
06:15:00 <dblhelix> xerox: well, you can, actually... but somehow it causes the type checker to loop indefinitely... mmm... wait a minute, let me try
06:15:28 <flux__> maybe "thoroughly"?
06:15:48 <xerox> @type \x -> x x
06:15:49 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
06:15:49 <lambdabot>   Expected type: t
06:15:59 <samc> no that doesn't sound right
06:18:07 <bet0x> darcs its a nice app
06:19:02 <xerox> ..it indeed is!
06:19:09 <SamB> yes
06:19:20 * SimonRC wishes Haskell could reason about infinite types, as long as the overall expression had a finite type.
06:19:21 <samc> google gives 414 "completely" vs. 984 "entirely"
06:19:24 <SamB> it has scaling issues, though
06:19:45 <xerox> SimonRC: what would it give in terms of power to the programmer?
06:19:53 <SimonRC> the quote is: "Almost, but not entirely, unlike tea."
06:19:54 <SamB> a headache!
06:20:08 <samc> cheers SimonRC :)
06:20:18 <SimonRC> xerox: dunno, but I' be able to define y as above.
06:20:29 <SamB> that is what infinite types would give in terms of power to the programmer
06:20:44 <samc> wait are you sure
06:21:10 <SimonRC> SamB: Maybe they would give nothing much.  But they *might* be useful.
06:21:13 <int-e> I have "A liquid that was almost, but not quite, entirely unlike tea."
06:21:37 <SimonRC> I was just doing ottomh.
06:21:59 <bet0x> who have coffee?
06:22:02 <samc> ah, thanks int-e
06:22:02 <bet0x> i need some
06:22:11 <xerox> @where coffee
06:22:12 <lambdabot> I know nothing about coffee.
06:22:23 <bet0x> dabot -.-
06:22:29 <bet0x> @where sugar
06:22:29 <lambdabot> I know nothing about sugar.
06:22:51 <samc> now I can sleep soundly ;)
06:23:01 <bet0x> @where Coffee Sugar
06:23:01 <lambdabot> I know nothing about coffee.
06:23:04 <bet0x> omg
06:23:06 <bet0x> im lost
06:23:09 <bet0x> =/
06:23:25 <int-e> you shouldn't ask a bot for help.
06:23:32 <xerox> @help
06:23:32 <lambdabot>  @help <command> - ask for help for <command>
06:23:44 <bet0x> @help coffee
06:23:45 <lambdabot>  @help <command> - ask for help for <command>
06:23:56 <bet0x> @coffee
06:23:57 <lambdabot> Unknown command, try @listcommands.
06:24:06 <bet0x> @dam_bot_die
06:24:06 <lambdabot> Unknown command, try @listcommands.
06:24:18 <SimonRC> @listcommands
06:24:19 <lambdabot> use listcommands [module|command]. Modules are:
06:24:19 <lambdabot> babel base code compose dice dict djinn dummy dynamic elite fact haddock
06:24:19 <lambdabot> help hoogle karma lShell localtime more pl plugs poll pretty quote search
06:24:19 <lambdabot> seen spell state system todo topic type version vixen where
06:24:21 <ValarQ> you shouldn't ask it for coffee either...
06:24:21 <bet0x> @where_coffee
06:24:22 <lambdabot> Unknown command, try @listcommands.
06:24:38 <xerox> @vixen where is the coffee?
06:24:38 <lambdabot> is that really what you want to know?
06:24:38 <bet0x> o
06:24:41 <int-e> @botsnack
06:24:41 <bet0x> i see
06:24:42 <lambdabot> :)
06:24:47 <bet0x> ty
06:24:55 <dblhelix> xerox: wanna give it a go?
06:24:58 <xerox> @vixen welcome bet0x
06:24:58 <lambdabot> why do you keep repeating yourself?
06:24:58 <SimonRC> @help vixen
06:24:59 <lambdabot> sergeant curry's lonely hearts club
06:25:06 <SimonRC> @help vixen
06:25:07 <lambdabot> sergeant curry's lonely hearts club
06:25:10 <xerox> dblhelix: 'it' being what?
06:25:12 <SimonRC> :-S
06:25:17 <bet0x> @search coffee
06:25:17 <lambdabot> Unknown command, try @listcommands.
06:25:29 <bet0x> =/
06:25:29 <xerox> @yarr!
06:25:29 <lambdabot> Well me 'earties, let's see what crawled out of the bung hole...
06:25:36 <dblhelix> newtype F a = F {unF :: F a -> a}
06:25:36 <dblhelix> fix f =  (\x -> f (unF x x)) (F (\x -> f (unF x x)))
06:25:36 <dblhelix> fac = fix (\f -> \n -> if n == 0 then 1 else n * f (n - 1))
06:25:38 <bet0x> @hoogle coffee
06:25:38 <lambdabot> No matches found
06:25:58 <xerox> FOO.
06:26:11 <SimonRC> dblhelix: :-S okaay
06:26:47 <SimonRC> actually not bad at all
06:27:02 <bet0x> wer
06:27:15 <bet0x> Hask looks easy
06:27:17 <SimonRC> now if only that coul dbe done auotmatically, transprently, and invisibly
06:27:20 <bet0x> very easy
06:27:28 <xerox> dblhelix: is that a proof of what you said about spinning the type checker in an infinite loop?
06:27:31 <SimonRC> bet0x: MWAHAAHH!
06:27:37 <xerox> bet0x: yeah, right.
06:27:46 <bet0x> SimonRC, what is funny? :P
06:27:57 <SimonRC> bet0x: It may actually be easier if you haven't programmer before.
06:28:04 <bet0x> ye
06:28:18 <SimonRC> Haskell is well-know for being hard for many people to get their heads round.
06:28:40 <dblhelix> xerox: well the following prog compiles, i.e., compilation terminates:
06:28:44 <dblhelix> newtype F a = F {unF :: F a -> a}
06:28:44 <dblhelix> fix f =  (\x -> f (unF x x)) (F (\x -> f (unF x x)))
06:28:44 <dblhelix> fac = fix (\f -> \n -> if n == 0 then 1 else n * f (n - 1))
06:28:44 <dblhelix> main = return ()
06:28:44 <bet0x> i code some PHP, Perl, and now learning Ruby for Rails and looking this Haskell
06:28:44 <ValarQ> bet0x: programmers often requires a lot of rethinking for old programmers
06:29:03 <dblhelix> xerox: but the following does not:
06:29:04 <dblhelix> newtype F a = F {unF :: F a -> a}
06:29:05 <dblhelix> fix f =  (\x -> f (unF x x)) (F (\x -> f (unF x x)))
06:29:05 <dblhelix> fac = fix (\f -> \n -> if n == 0 then 1 else n * f (n - 1))
06:29:05 <dblhelix> main = print (fac 2)
06:29:06 <SimonRC> bet0x: get ghc, use ghci, and go throught some tutorials.
06:29:09 <dcoutts> gour, ping
06:29:19 <bet0x> im doing that
06:29:32 <xerox> dblhelix: it doesn't load in ghci here.
06:29:34 <flux__> bet0x, of those I would say haskell is the different one
06:29:46 <xerox> Uh, what's the difference?
06:29:53 <dblhelix> xerox: stefannb:~/lab stefan$ ghc --version
06:29:54 <dblhelix> The Glorious Glasgow Haskell Compilation System, version 6.4.1
06:30:08 <bet0x> i got GHC from Ubuntu
06:30:11 <bet0x> apt-get rules
06:30:14 <xerox> GHC Interactive, version 6.4.1, for Haskell 98.
06:30:16 <SimonRC> bet0x: yes
06:30:17 <gour> dcoutts: pong
06:30:21 <bet0x> ghc-cvs 20050331-2ubuntu2
06:30:26 <dblhelix> xerox: no in ghci it does not load... it compiles with ghc --make however
06:30:38 <xerox> Uh-oh.
06:30:38 <dcoutts> gour, Axel was wondering about the gtk2hs site layout again.
06:30:48 <xerox> dcoutts: hiya!
06:30:52 <dcoutts> gour, maybe we can chat about it if you've got time
06:30:55 <dcoutts> xerox!
06:31:00 <xerox> dcoutts: how's code?
06:31:08 <dcoutts> xerox, you have *got* to see my code!
06:31:15 <dcoutts> xerox, it's so slick.
06:31:15 <xerox> dcoutts: indeed!
06:31:20 * xerox arfs
06:31:26 <dcoutts> xerox, and there's only one missing feature!
06:31:35 <xerox> I read something in the backlog.
06:31:53 <dcoutts> xerox, I need more flexible lifetime management for surfaces
06:32:04 <dcoutts> via ForeignPtr
06:32:08 <xerox> ...and bind surface_finish or whatever is called.
06:32:18 <dcoutts> that's already bound I think
06:32:32 <xerox> What's the problem exactly?
06:32:36 <dcoutts> it shouldn't alter the existing interface, just add a couple extra funcs
06:32:41 <bet0x> haskell-mode its GHCI ?
06:32:50 <bet0x> for "Emacs" ?
06:32:58 <dcoutts> xerox, well it's just a bit of work, we need to change some of the marshaling code for surfaces
06:33:14 <dcoutts> xerox, when you've got some time we can gobby it
06:33:18 <xerox> bet0x: haskell-mode is an Emacs mode implementing goodies to edit Haskell.  It can use either GHC or Hugs as interpreters in some buffer, with a convenient interface.
06:33:28 <xerox> dcoutts: okay.
06:33:47 <dcoutts> xerox, do you have a convenient time?
06:33:52 <gour> dcoutts: some guy arrived who has to fix something regarding gas-install., i'll ping you later, ok?
06:33:58 <dcoutts> xerox, maybe I should send you my code first :-)
06:34:05 <dcoutts> gour, ok thanks
06:34:08 <xerox> Yeah.
06:34:44 <bet0x> i never use emacs
06:34:47 <bet0x> i use vim
06:35:10 <xerox> Now somebody pops up and yells either Yi! or hIDE!, usually.
06:36:09 <int-e> joe. nano. kedit. notepad. ... so many options.
06:36:20 <bet0x> ye, i see
06:36:54 <int-e> real hardcore coders use cat > file ;-)
06:37:07 <sieni> ed!
06:37:20 <bet0x> no
06:37:32 <bet0x> use echo "main { bla bla" >> file.c
06:37:32 <int-e> ed is comparatively usable.
06:37:33 <bet0x> :P
06:37:38 <bet0x> ed ?
06:37:39 <bet0x> jejeje
06:37:47 <bet0x> in my city ed its hated
06:37:48 <bet0x> :P
06:38:29 <jethr0> @seen philippa
06:38:29 <lambdabot> I saw philippa leaving #scannedinavian, #haskell-overflow, #haskell-blah
06:38:29 <lambdabot> and #haskell 1 hour, 17 minutes and 20 seconds ago.
06:39:00 <dcoutts> xerox, http://darcs.haskell.org/gtk2hs/demo/cairo/Clock.hs
06:39:38 <dcoutts> xerox, oh, you'll need to comment out the line: windowSetIconFromFile window "cairo-clock-icon.png"
06:39:44 <dcoutts> since I didn't include the .png
06:40:10 <bet0x> int-e look http://bet0x.pastebin.com/520608
06:40:12 <dcoutts> xerox, oh, hmm you can't run it yet since it depends on some recent changes in gtk2hs
06:40:22 <dcoutts> xerox, but you can see what I'm trying to do hopefully
06:40:27 <samc> @seen Philippa_
06:40:27 <lambdabot> Philippa_ is in #scannedinavian, #haskell-overflow, #haskell-blah and #
06:40:27 <lambdabot> haskell. I don't know when Philippa_ last spoke.
06:40:28 <bet0x> that is my first time with ed
06:40:45 <SimonRC> bet0x: use vi or emacs.
06:40:50 <SimonRC> bet0x: anythign but ed.
06:41:01 <dcoutts> xerox, in particular in the onExpose and onConfigure handlers.
06:41:48 <dcoutts> xerox, do you have time to gobby now, or you want to do it some other time?
06:42:13 <shapr> SimonRC: Is that the sort of infinite type you were looking for?
06:42:19 <zacch> hi shapr!
06:42:36 <shapr> hiya zacch! I continue to enjoy your blog.
06:42:43 <zacch> I posed 2 questions above - do you know the answers?
06:42:53 <shapr> I didn't see the questions.
06:42:57 <zacch> both are related to lazy evaluation:
06:43:15 <zacch> first is: how does it make tail recursion optimization unnecessary (I saw this claim on Usenet)
06:43:46 <xerox> dcoutts: this night, I think
06:43:54 <dcoutts> xerox, ok cool
06:44:15 <zacch> second is about memoization - if I code e.g. fibonacci naively, memoization does not come into play, but if I code appropriately (currying and streams), it does - how do I know when it does?
06:44:19 <shapr> Can you quote the claim?
06:44:29 <zacch> ok, one moment.
06:44:40 <shapr> memoize' f range = ((map f range) !!)
06:44:40 <shapr> memoize f range = ((array (minimum range, maximum range) (map (\x -> (x,f x)) range)) !)
06:44:50 <shapr> Those are simple memoization tools by Lor.
06:44:52 <shapr> @seen lor
06:44:53 <lambdabot> lor is in #haskell. Last spoke 17 hours, 48 minutes and 30 seconds ago.
06:45:20 <bet0x> @seen Nomius
06:45:20 <lambdabot> Nomius is in #Haskell. I don't know when Nomius last spoke.
06:45:27 <zacch> http://groups.google.at/group/comp.lang.functional/tree/browse_frm/thread/40f1d2b959155044/7d29be18571cdcc0?rnum=1&hl=de&q=ulrich+neumerkel&_done=%2Fgroup%2Fcomp.lang.functional%2Fbrowse_frm%2Fthread%2F40f1d2b959155044%2F7d29be18571cdcc0%3Flnk%3Dst%26q%3Dulrich+neumerkel%26rnum%3D68%26hl%3Dde%26#doc_81573678af00f722
06:45:39 <zacch> starting with the paragraph "but in a lazy language"
06:45:57 <xerox> @type \f range -> ((map f range) !!)
06:45:57 <lambdabot> forall b a. (a -> b) -> [a] -> Int -> b
06:46:56 <xerox> @type \f range -> ((array (minimum range, maximum range) (map (id &&& f) range)) !)
06:46:57 <lambdabot> Not in scope: `array'
06:46:57 <lambdabot>  
06:46:57 <lambdabot> <interactive>:1:60: Not in scope: `&&&'
06:47:08 <xerox> @type \f range -> ((Data.Array.array (minimum range, maximum range) (map (id Control.Arrow.&&& f) range)) !)
06:47:09 <lambdabot> Not in scope: `!'
06:47:12 <zacch> and another thing: I installed Haskell mode for Emacs, but how do I start hugs for interactive querying?
06:47:14 <xerox> @type \f range -> ((Data.Array.array (minimum range, maximum range) (map (id Control.Arrow.&&& f) range)) Data.Array.!)
06:47:15 <lambdabot> forall c' a. (GHC.Arr.Ix a) => (a -> c') -> [a] -> a -> c'
06:47:25 <xerox> Whoopee.
06:47:50 <shapr> zacch: I think he's talking about thunks not requiring extra space. Have you seen the evaluation pattorn of foldr vs foldl?
06:48:35 <zacch> no - have you got a reference?
06:48:49 <shapr> Cale: Do you have the nifty evaluation gif urls handy?
06:49:03 <xerox> Yes: http://vx.hn.org/autoshare/folds.png
06:49:14 <xerox> PNG, sir.
06:49:14 <shapr> http://vx.hn.org/autoshare/folds.png
06:49:19 <shapr> You beat me
06:49:23 <xerox> Dang.
06:49:32 <shapr> Cale also has animated pix of folds, do you know where they are?
06:49:38 <xerox> UH.
06:49:54 <zacch> but I think you're reading it with too much charity maybe - tail recursion optimization IMHO specifically refers to not keeping unneeded stack frames
06:50:21 <xerox> No.
06:50:46 <xerox> (Answering to shapr, I think you're right on the latter part on the phrase, zacch)
06:52:04 <tennin> zacch: it's something like turn-on-haskell-hugs or such
06:52:08 <zacch> xerox: thank you for the PNG - ok, that's pretty clear, and IMHO things like map etc. can't be tail recursive anyways in functional languages - but I don't see how lazy evaluation make tail recursion optimization unnecessary as claimed in the usenet post
06:52:27 <shapr> I think tail recursion elimination means turning a tail call into iteration. You don't need that with a nonstrict language because a single thunk can hold a bunch of the future of the computation.
06:52:39 <zacch> tennin: thank you, that's it
06:53:55 <shapr> Maybe I should read the whole thread...
06:54:53 <zacch> shapr: yes that would be good, it's rather interesting. 
06:55:52 <pejo> shapr!
06:56:12 <pejo> shapr, did you get any answers about the SSA and GRIN?
06:56:15 <shapr> If that's the same Mark P. Jones who wrote "Functional Programming with Overloading and Higher-Order Polymorphism" http://www.cse.ogi.edu/~mpj/pubs.html then he probably knows what he's talking about.
06:56:21 <shapr> pejo: Nope
06:56:27 <shapr> Have you found new info?
06:57:11 <xerox> zacch: another simple way to think about them is the following:
06:57:33 <xerox> foldl f k [a,b,c] = k `f` a `f` b `f` c
06:57:34 <pejo> shapr, nah, been quite busy lately. And I really can't spend too much time doing 'other' things. =/
06:57:42 <xerox> foldr f k [a,b,c] = a `f` b `f` c `f` k
06:58:51 <SimonRC> xerox: make sure you get the assicativity correct
06:58:55 <shapr> pejo: I've been doing too much Python lately... but I think you're working with Timber or O'Hugs?
06:59:10 <shapr> Sad that I can't remember :-/
06:59:14 <pejo> shapr, teaching for hte moment. 
06:59:16 <shapr> Ah, ok
06:59:24 <xerox> SimonRC: it bothers me in some sense.
06:59:55 <pejo> shapr, but yeah, Timber it is. The Boquist stuff is a bit low level for us yet though.
07:00:25 <shapr> Boquist's work is impressive. JohnMeacham's results with JHC are too :-)
07:00:45 <xerox> SimonRC: for example, have you ever see this transpose definition here?
07:00:47 <xerox> > foldr (zipWith (:)) (repeat []) [[1,2],[3,4],[5,6]]
07:00:48 <lambdabot> [[1,3,5],[2,4,6]]
07:01:03 <xerox> SimonRC: it does exibit strange properties with infinite lists, and it is a foldr.
07:01:05 <shapr> I have a suspicion that Boquist's work can be ported to other corners of the lambda cube, but I'm not sure how to approach that.
07:01:08 <pejo> shapr, sure. Some of those problems are interesting for strict languages as well.
07:01:39 <shapr> Boquist's writings are much more interesting than client emails ;-)
07:03:36 <pejo> shapr, if you're interested in compiler technology you might want to read Leroy's paper nfor POPL. Depending on how low level you want to go there was some paper about cache stuff by authors I don't remember as well.
07:04:40 <shapr> I have been thinking about an ELF binary re-optimizer that uses cpu cache size to reorganize the binary.
07:04:59 <shapr> Is it Xavier Leroy's paper?
07:05:19 <pejo> shapr, yep. Avail on his homepage. Sounds like you've seen it already. :-)
07:05:21 <zacch> but still: tail recursion means the stack frame of the caller can be discarded and directly replaced with that of the callee - I don't see how lazy evaluation implies that this is done.
07:05:42 <shapr> No, I haven't seen the paper, but Xavier Leroy is the only Leroy I know who does compiler tech.
07:07:27 <shapr> pejo: What's the name of the paper? I don't see anything about cache on http://pauillac.inria.fr/~xleroy/
07:07:47 <shapr> I was thinking about reoptimizing binaries after seeing the SGML optimization IOHCC contest.
07:07:48 <pejo> shapr, oh. That was a different paper. His was about programming a compiler backend in a proof assistant.
07:08:03 <shapr> I definitely want to read that!
07:08:16 <vincenz> > tuples 2 [1,2,3]
07:08:17 <lambdabot>  Not in scope: `tuples'
07:08:35 <xerox> @index tuples
07:08:35 <lambdabot> bzzt
07:08:36 <shapr> > map (2 (,)) [1,2,3]
07:08:37 <lambdabot>   add an instance declaration for (Num ((a1 -> b1 -> (a1, b1)) -> a -> b))
07:08:42 <shapr> er
07:08:45 <xerox> heh.
07:08:45 * Philippa_ wants to have a play around with Boquist's stuff further
07:08:52 <Philippa_> I could use a codemonkey or a partner though
07:08:53 <shapr> > map ((,) 2) [1,2,3]
07:08:54 <lambdabot> [(2,1),(2,2),(2,3)]
07:09:07 <xerox> > map (const 2 &&& id) [1,2,3]
07:09:08 <lambdabot> [(2,1),(2,2),(2,3)]
07:09:11 <edwinb> Mmm, it's an interesting paper. I think I need to lock myself in a room for a week and read it closely to get all the details though.
07:09:15 <pejo> Philippa, don't we all want a partner? :-)
07:09:29 <int-e> > zip (repeat 2) [1,2,3]
07:09:29 <shapr> edwinb: Where can I discuss proof programming with others?
07:09:30 <lambdabot> [(2,1),(2,2),(2,3)]
07:09:38 <vincenz> shapr: not exactly what I was looking for
07:09:38 <shapr> I haven't found any good fora for that subject.
07:09:45 <edwinb> There is a Coq mailing list, but I don't know of other fora.
07:09:51 <xerox> int-e: good one
07:10:14 <Philippa_> pejo: I have an SO :-)
07:10:25 <Philippa_> oh, and someone best described as a playmate, too
07:10:35 <shapr> Play with code? :-)
07:10:51 <pejo> Philippa, oh, I was refering to the codemonkey. :-)
07:10:53 <Philippa_> I don't think he's into compiler hacking, and he mostly codes in perl5 doing admin-type stuff
07:10:57 <shapr> edwinb: I wish there were a proof programming forum. I've been on TYPES for awhile, but it's not the same.
07:11:17 <edwinb> shapr: I don't think there is anything that specific. Possibly not enough people really do it...
07:11:48 <shapr> I also want to figure out how Michael Dummet's extension of the Curry Howard isomorphism into philosophy fits into proof programming.
07:12:15 <pejo> shapr, the cache paper was  "A Hierarchical Model of Data Locality" by Zhang. And consideirng your profession the paper "The next 700 Data Description Languages" might be worth a read as well. 
07:12:26 <shapr> It would be especially nice if all the existing philosophical proofs could be exploited to make faster code :-)
07:12:44 <pejo> shapr, err, Zhang wasn't alone on that one, more authors that I can't pronounce the name of either.
07:12:45 <shapr> I think I read the 700 langs paper already.
07:13:14 * shapr checks
07:13:58 <shapr> Oh no I haven't read this paper, it looks good!
07:14:31 <Philippa_> the title's from something else about programming languages, which I imagine you would've read :-)
07:14:45 <shapr> Yes, that's why I was confused.
07:15:07 <shapr> Is there Haskell code for this?
07:15:36 <pejo> shapr, a friend started implementing it, but he went to france. I can get back to you by the end of the week or so.
07:15:56 <shapr> I would appreciate that.
07:16:05 <shapr> This would fit nicely into some QuickCheck code I've been writing.
07:17:00 <shapr> Huh, they even talk about packrat parsing.
07:17:19 <Philippa_> cool
07:18:15 <shapr> Wow, nice paper.
07:19:10 <flux__> zacch, hmm.. have you considered about the task of mapping in strict and non-strict languages? in a strict, to be able to use tail recursion optimization and retrieve the list in the original order, you need to have an accumulation buffer, and finally reverse the buffer
07:19:47 <flux__> zacch, while in a nin-strict you can just implement it in one intuitive way: map f [] = []; map f (x:xs) = f x:map f xs
07:20:02 <flux__> zacch, which would not be such a good idea in a strict language
07:20:30 <flux__> zacch, and because you probably will consume the elements one by one, there is never n stack frames in the memory at the same time
07:20:45 <shapr> pejo: This would be especially useful for Yi, allowing users to quickly (and probably interactively) define modes for just about anything.
07:21:37 <zacch> flux__: yes Lemmih suggested mapping too - why exactly does the non-strict version not allocate linear stack?
07:22:32 <shapr> Too bad joelk isn't here, he'd love this paper.
07:22:38 <flux__> zacch, consider program main = putStr (map succ "hello")
07:22:52 <flux__> zacch, when map produces one character, putStr will output it
07:22:54 <shapr> It even mentions Erlang's packet parsing primitives on the second page.
07:23:02 <flux__> zacch, and after that the context may be discarded
07:23:14 <shapr> pejo: Thanks for suggesting this paper!
07:23:30 <flux__> zacch, so even if the "hello" was an infinite string, it would consume constant amount of memory
07:23:42 <pejo> shapr, glad you enjoyed it. Wadlers blog has some more suggestions about nice papers. :-)
07:23:58 <flux__> zacch, while the naive non-tail-recursive version would have n stack frames
07:24:04 <zacch> flux__, OK, than you very much - it seems that lazy evaluation requires a greater rethink of it all than I initially thought
07:24:07 <flux__> (in a strict language that is)
07:24:35 <shapr> zacch: Once you understand nonstrict eval, you'll have superpowers ;-)
07:24:46 <pejo> flux/zacch, sorry about jumping into hte middle of the conversation, but what are you discussing?
07:25:00 <shapr> At least, I've been able to write nonstrict code that mystified imperative programmers.
07:25:00 <flux__> zacch, btw, one related example is (in pseudo, I can't remember the function names ;)): main = do data <- readFile "input"; outputFile "output" data
07:25:12 <zacch> pejo: why lazy evalution makes tail recursion optimization unnecessary
07:25:29 <flux__> zacch, which will also use constant amount of memory regardless of the input size
07:25:30 <SimonRC> flux__: I think you need getContents, which reads lazily.
07:25:45 <flux__> simonrc, yeah, well the sentence in parenthesis was my disclaimer ;)
07:26:18 <Lemmih> SimonRC: 'readFile' uses hGetContents.
07:26:22 <shapr> I think someone should start #sam for samb, samc, samk, and samx. Or maybe I should instead stop trying to distract myself from work.
07:26:44 <SimonRC> Is it a bad sign that I have wanted to use LISP macros when writing Haskell?
07:26:56 <shapr> SimonRC: Means it's time to learn Template Haskell.
07:27:00 <SimonRC> :-)
07:27:16 <zacch> flux__: I read the Fibonacci example on Wikipedia, it implicitly makes use of "memoization" in that values are not computed redundantly
07:27:20 <SimonRC> I'll wait until it get into the standard.
07:27:35 <shapr> You have more patience than I do.
07:27:57 <flux__> zacch, the memoization works when you have a place to store the data to
07:27:59 <zacch> flux__: but how do I make sure of that - for example, if I code Fibonacci naively (double tail recursion), there will be redundant computations - what is it that lets the compiler differentiate?
07:28:04 <SimonRC> Hmm, here really needs be an InfiniteMap type.
07:28:10 <zacch> flux__: what is that specifically?
07:28:14 <flux__> zacch, for example if you're defining a sequence, you have a place to store the values (the sequence)
07:28:18 <SimonRC> For memoizing fibbonacci numbers and the like.
07:28:35 <flux__> so foo 42 + foo 42 will not memoize in regards to foo
07:28:51 <flux__> (but it might use common subexpression elimination if you give ghc some options)
07:29:03 <xerox> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in take 20 fibs
07:29:03 <zacch> flux__, OK, I seem to remember a case of Fibonacci using currying alone which also memoized - is this possible, or is my memory wrong?
07:29:04 <lambdabot> [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765]
07:29:07 <samc> ooh, samx sounds much better than samc
07:29:13 <SimonRC> the problem with naive fibb is that it grow exponentionally.
07:29:23 <shapr> Yeah, referential transparency allows common subexpression elimination.
07:29:29 <flux__> zacch, do you have the code somewhere? wiki?
07:29:43 <zacch> I read it on a mailing list - not sure I can find it again
07:29:47 * zacch is trying...
07:29:54 <xerox> That zipWith?
07:30:01 <zacch> no, that's the list version
07:30:26 <flux__> hmm, 'fibonacci using currying alone'?
07:30:42 <SimonRC> Ah!  I have remembered a question I wanted to ask...
07:30:51 <shapr> I've forgotten mine :-(
07:31:04 <shapr> I was going to ask ndm something about yhc...
07:31:10 <int-e> > let fib 0 = 1; fib 1 = 1; fib n = fib (n-1) + fib (n-2) in map fib [0..19]
07:31:12 <lambdabot> [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765]
07:31:22 <ndm> shapr, ask away
07:31:29 <shapr> ndm: But I forget what...
07:31:31 <int-e> that version is horribly inefficient because no memoizing is done.
07:31:41 <shapr> something about yhc with gtk2hs on debian/arm.
07:31:46 <SimonRC> I have a m-by-n grid of values (for line-of-sight calculations in a roguelike game)...
07:32:17 <vincenz> > drop 22 []
07:32:18 <lambdabot> Add a type signature
07:32:22 <vincenz> > drop 22 []::Int
07:32:23 <lambdabot> Couldn't match `Int' against `[a]'
07:32:30 <vincenz> > drop 22 []::[Int]
07:32:30 <SimonRC> Each time the user presses a key, several lookups in this grid must be made...
07:32:31 <lambdabot> []
07:32:31 <ndm> shapr, that all requires FFI, which is outside my ability unfortunately
07:32:44 <ndm> although we have got ffilib working on Windows and Linux already
07:32:53 <dcoutts> shapr, ndm and I talked it over the other day
07:32:59 <shapr> SimonRC: http://www.scannedinavian.com/~shae/mage-1.0pre35.tar.gz
07:33:07 <dcoutts> ndm, ffilib? is that the same as libffi? :-)
07:33:20 <kosmikus> SimonRC: you're programming a roguelike?
07:33:20 <dcoutts> ndm, the gcc libffi with MSVCC ?
07:33:36 <SimonRC> If I evaluate lazily or re-evaluate each time, there will be (initially at least) a long pause as LoS calcs are done...
07:33:47 <ndm> dcoutts, the python CTypes port of it has MSVC and GCC compatible code
07:34:06 <dcoutts> ndm, oh cool, well found
07:34:10 <ndm> which we are basically going to steal :)
07:34:35 <shapr> How does gcc libffi and CTypes help yhc's FFI?
07:34:37 <dcoutts> ndm, I was going to suggest you look at what python does but then I though that they build C stubs for linking to C code.
07:34:48 <dcoutts> I guess I was wrong
07:34:59 <SimonRC> shapr: what's that?
07:35:24 <ndm> shapr, it means we can easily do the actual call bit with runtime binding and no pre-generated stubs
07:35:37 <ndm> so you can keep 100% cross platform haskell, and just switch in different C libraries
07:35:40 <SimonRC> How do I split off a demon that intelligently does LoS claulations while waiting for the user's keypress?
07:36:02 <sproingie> forkIO comes to mind
07:36:16 <shapr> SimonRC: It's a roguelike written in Haskell by Richard Braakman
07:36:45 <SimonRC> gr, my idea isn't original
07:36:45 <shapr> It's GPL'd, you might want to steal some ideas from it.
07:36:54 <samc> I too was mulling over writing a roguelike in haskell
07:37:08 <shapr> Well, you guys could grab mage and do a lambdabot on it.
07:37:18 <zacch> flux__, sorry, I can't find the code right now, it was most probably wrongly remembered anyways
07:37:32 <samc> I wrote one in forth long ago but now it's gone :(
07:37:39 <zacch> flux__, does anything else except "lists" qualify as "store anywhere"?
07:37:42 <shapr> ndm: Oh that's nice. Any idea when it'll work?
07:37:53 <dcoutts> ndm, do you have any yhc people in the Haskell-prime committee?
07:38:10 <kevind> @type foldl
07:38:11 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
07:38:18 <ndm> shapr, good question - there is still other stuff needed for FFI and Tom is quite busy unfortunately
07:38:20 <shapr> ndm: I'm considering starting with nhc98 on my 770, and then moving to yhc as it gains gtk2hs proximity.
07:38:31 <ndm> shapr, why not start with Yhc directly?
07:38:40 <dcoutts> ndm, they're talking about the FFI. Yhc wanting full cross-platform compatabiity without having to compile seperately on each arch might need some extensions.
07:38:43 <ndm> dcoutts, no - but malcolm is kind of close
07:38:43 <flux__> zacch, well, if needs to have a name
07:38:48 <flux__> I think
07:38:49 <shapr> Will yhc already run on debian/arm?
07:39:06 <ndm> shapr, if it has a C compiler, its a 5 minute port :)
07:39:25 <ndm> dons ported it to Irix in about 5 mins I think, and thats usually pretty weird
07:39:29 <flux__> shapr, is 770 fun?
07:39:42 <shapr> I'd like to port Fermat's Last Margin to the 770. Is YHC complete enough to run Flippi and maybe darcs?
07:39:45 <dcoutts> ndm, ah right malcolm. For exaple they already have an item about libs like HOpenGL which use stdcall on win32 and ccall on unix.
07:39:49 <shapr> flux__: It's very much fun.
07:40:09 <shapr> Yeah, Irix is a PITA. I did a lot of work on Irix 5.2.
07:40:10 <ndm> shapr - well, C compiler, GMP library and files
07:40:11 <dcoutts> ndm, that issue would be even more important for yhc since you can't use per-arch #ifdefs
07:40:33 <Philippa> Flippi's still just about Haskell98 + hierarchical modules, though it needs mutually recursive modules
07:40:37 <ndm> shapr, Yhc is probably not ready enough to run Flippi, but its more a library thing
07:40:50 <ndm> we don't support mutually recursive modules, without hand writing .hi files
07:41:03 <ndm> and the heirarchical libaries are still "ion progress"
07:41:09 <SimonRC> shapr: hmm, too player-centric.
07:41:15 <SimonRC> AFAICT
07:41:15 <SamB> what? no .hs-boot?
07:41:17 <ndm> dcoutts - we can use #ifdefs, but then you loose cross platform binary
07:41:18 <Philippa> I *think* the major libs Flippi uses're largely Parsec and Network.CGI, both of which AFAICT are reasonably clean H98?
07:41:25 <dcoutts> ndm, exactly.
07:41:44 <ndm> Philippa: we still don't have some things like Directory working yet
07:41:48 <Philippa> ah
07:41:51 <Philippa> yeah, that'd kill it
07:41:55 <ndm> but its not fundamental problems - just polish required
07:41:58 <shapr> flux__: It has surprising wifi range, meaning I can get on the 'net in nearly any area with buildings. I get about seven hours of heavy use before needing a charge. It already has openssh, nmap, and other network tools. It has only three PIM packages, but more should appear soon.
07:42:06 <SamB> maybe .hs-boot should be standardized for the benefit of less-than-perfect compilers?
07:42:15 <Philippa> good idea. You on the haskell' list?
07:42:25 <Philippa> standardised .hs-boot would make a lot of sense
07:42:27 <SamB> no
07:42:29 <ndm> dcoutts, yes - we are the only cross platform haskell compiler, so that would help
07:42:33 <shapr> flux__: And #maemo is quite helpful and friendly, even in the case of newbie questions.
07:42:42 <ndm> Philippa: we hope to support mutually recursive modules automatically reasonably soon
07:42:46 <Philippa> cool
07:42:52 <ndm> without boot files
07:42:58 <flux__> shapr, have you used wlan or bluetooth?
07:43:03 <dcoutts> ndm, well jhc is cimilar in that it is supposed to produce ISO portable C code which could then be transporetd and built on any platform.
07:43:04 <Philippa> I'd like the option to have GHC do that with an additional flag or variant of --make
07:43:04 <ndm> although there was a proposal on teh wiki to have annotations in export lists
07:43:20 <dcoutts> ndm, cimilar/similar
07:43:23 <ndm> then anyone could be mutually recursive
07:43:24 <Philippa> hrmm, that might work too
07:43:47 <Philippa> I just need to be able to keep such annotations out of Flippi's config file :-)
07:43:49 <shapr> flux__: I've used wlan heavily, the 770 has amazing range. I've used the bluetooth only a few minutes, my 6310i only supports the audio profile, and the 770 doesn't yet support that (though maybe with the next version).
07:43:58 <dcoutts> ndm, yeah, some sort of annotaion to use different names or calling conventions on different patforms.
07:44:15 <flux__> shapr, I was just thinking that it is likely with bluetooth you'd get extended battery time..
07:44:18 <ndm> dcoutts, indeed - i think they should be looking for ways to remove #ifdef entirely
07:44:27 <ndm> since its not part of haskell, and its nto a very good idea...
07:45:00 <dcoutts> ndm, that might help with the fact that for gtk2hs some functions have a different symbol name on win32 compared to unix though the calling convetion and function prototype are the same
07:45:01 <shapr> flux__: I'm tempted to wrap tinfoil around the inside of my jacket to make an unobtrusive wifi dish for the 770 in my front jacket pocket ... I should be able to explore the entire neighborhood from my balcony then =)
07:45:42 <dcoutts> ndm, perhaps the whole foreign import could be given an arch parameter?
07:46:00 <ndm> dcoutts, as the biggest user, you should definately think of a solution and push it
07:46:12 <dcoutts> ndm, and they you could have several import for different arches, so long as the types are equal, or something like that.
07:46:27 <ndm> ifdef's are nasty...
07:46:35 <ndm> although now Yhc is entirely cpp free
07:46:36 <dcoutts> ndm, yeah.
07:46:51 <dcoutts> ndm, even in the C code?
07:47:02 <ndm> oh, no - the C runtime has ifdef's
07:47:13 <dcoutts> that's to be expected
07:47:15 <ndm> but the haskell i meant - the runtime should take care of everything else
07:47:21 <dcoutts> right
07:48:11 <kevind> what happens if you use killThread on an already dead thread?
07:48:15 <kevind> does it block forever?
07:49:11 <dcoutts> kevind, a thread can't die untill all it's handls dissapear. If you can call killThread then you must have a handle to it and so it must be alive.
07:49:32 <dcoutts> it may have finnished executing however
07:49:56 <dcoutts> in which case I expect raising an exception in that thread does nothing.
07:49:58 <kevind> ahh, okay but the call to killThread should still return right?
07:50:02 <dcoutts> try it
07:50:24 <dcoutts> I think it works that way
07:53:34 <kevind> yeah it does, guess thats not my bug, doh
07:55:02 <SamB> why would it block forever if you attempted to kill a thread that was done?
07:55:07 <SamB> that would be stupid.
07:56:57 <kevind> it sure would
08:07:36 <shapr> jethr0: Want to publish meta-haskell aka second.ps as another TMR article?
08:16:55 <jophar_> hello there!! how can I convert an Int to a string? Is it possible?
08:17:26 <musasabi> > show 500
08:17:27 <lambdabot> "500"
08:17:42 <jophar_> humm
08:17:54 <jophar_> > head(show 500)
08:17:56 <lambdabot> '5'
08:18:07 <jophar_> beauty! thanks
08:20:50 <ihope> If I wanted to have a newtype declaration for CPS values, what would it have to be?
08:21:11 <ihope> I have "newtype CPSVal a = ToCPS {fromCPS :: (a -> b) -> b}", but that doesn't seem to work.
08:21:40 <xerox> newtype CPS a k = CPS { unCPS :: (k -> a) -> a } -- ?
08:22:00 <ihope> ...Yeah, I suppose that'd do it.
08:25:28 <kevind> are there any debugging tools for haskell?
08:25:41 <ihope> Well, there's the debug functions.
08:25:56 <ihope> Dunno just where they are...
08:26:07 <kevind> been using Debug.Trace
08:26:49 <kevind> I have a thread hanging and I am having a hard time figuring out why
08:26:49 <kevind> I think lazy evaluation might be throwing me off the track
08:27:13 <ihope> You can use "seq a b" to evaluate a, then return b.
08:27:52 <lispy> shapr: ping?
08:29:43 <ihope> So is it just me, or did I just define CPS as a monad?
08:30:02 <ihope> (And the declaration "x >>= y  = ToCPS (\z -> fromCPS x (\a -> fromCPS (y a) z))" is really ugly, isn't it?)
08:30:09 * SamB wonders how you'd write a parser/lexer that supported something like #line directives
08:30:41 <xerox> ihope: Cont Monad.
08:31:05 <lispy> SamB: well, wouldn't the lexer pickup "pragrama" tokens and then the parser would cobble them into the AST as an annotation?
08:31:16 <ihope> I knew I was doing something redundant...
08:31:19 <lispy> and that was so high level it probably wasn't helpful :)
08:31:31 <xerox> ihope: it's cool, keep it :)
08:31:36 <ihope> :-)
08:31:47 <SamB> lispy: I had just about figured that much out, yes ;-)
08:32:12 <glauber_sp> guys, may I ask lambdabot the meaning of ~ ?
08:32:19 <SamB> anyway, at this point I'd be happy to have the parser just give positions in parse errors
08:32:34 <SamB> glauber_sp: lambdabot doesn't really know what that means
08:32:47 <xerox> @vixen what does ~ mean?
08:32:47 <lambdabot> i'm not sure what i mean
08:33:02 <glauber_sp> SamB, hum, ok =) thanks
08:33:21 <SamB> @google haskell report irrefutable pattern
08:33:23 <lambdabot> http://www.haskell.org/onlinereport/exps.html
08:33:29 <ihope> Now all I gotta do is figure out what this monad *does*.
08:33:41 <gour> dcoutts: ping
08:33:49 <xerox> ihope: nomaware's has some examples.
08:33:51 <dcoutts> hia gour 
08:33:52 <xerox> @google All About Monads
08:33:54 <lambdabot> http://www.nomaware.com/monads/html/
08:34:05 <glauber_sp> SamB, thanks again =)
08:34:23 <gour> dcoutts: it tooks longer than expected (murphy's law, you know..)
08:34:55 <dcoutts> gour, yeah I know
08:36:01 <ihope> Whoa. I DID redefine the Cont monad.
08:36:13 <ihope> But I used @djinn. Is that cheating?
08:36:20 <lispy> heh
08:36:29 <lispy> @djin (a,b)
08:36:29 <lambdabot> Maybe you meant: djinn djinn-add djinn-clr djinn-del djinn-env djinn-
08:36:29 <lambdabot> ver
08:36:39 <lispy> @djinn (a,b)
08:36:39 <lambdabot> -- f cannot be realized.
08:36:49 <ihope> @type undefined :: (a,b)
08:36:50 <lambdabot> (a,b) :: forall a b. (a, b)
08:36:52 <lispy> do i have to give it as a function?
08:36:55 <xerox> @djinn a -> b -> (a,b)
08:36:55 <lambdabot> f a b = (a, b)
08:37:12 <ihope> I think you gotsed it.
08:37:36 <lispy> @djinn m a -> m b -> m (a, b)
08:37:36 <lambdabot> -- f cannot be realized.
08:37:40 <int-e> @djinn Int
08:37:41 <lambdabot> -- f cannot be realized.
08:37:47 <SimonRC> @djinn Data.Map.Map a b -> Data.Map.Map b [a]
08:37:48 <lambdabot> -- f cannot be realized.
08:37:52 <SimonRC> :-(
08:37:57 <glauber_sp> Does " *** Exception: part11.lhs:45:1-49: Irrefutable pattern failed for pattern (x : xs)" means: in line 45, columm 49 starts the error: Irrefutable pattern failed for pattern (x : xs) ?
08:38:12 <SimonRC> about there, usually
08:38:14 <lispy> glauber_sp: i think so
08:38:22 <ihope> Yay, obfuscated error message.
08:38:42 <lispy> ihope: if you tihnk that's bad, try using g++ with templated classes :)
08:38:47 <ihope> Heh...
08:38:52 <Saulzar> @djinn ((a -> b) -> b) -> ((b -> c) -> c) -> a -> c
08:38:52 <lambdabot> -- f cannot be realized.
08:38:52 <glauber_sp> the line is: lazy ~(x:xs) isNull  = if isNull then [] else [x] AND the error is because the x was patterns macthed agains _/_
08:39:08 <ihope> So I have the definition exit = (Cont . const). Does this do anything useful? :-P
08:39:27 <xerox> @pl \ma mb -> ma >>= \a -> mb >>= \b -> return (a,b)
08:39:28 <lambdabot> liftM2 (,)
08:39:31 <xerox> RIGHT.
08:39:33 <glauber_sp> pattern macthed against
08:40:14 <ihope> Whoa...
08:40:39 <SimonRC> @type Data.Map.fromListWith
08:40:40 <lambdabot> forall a k.
08:40:40 <lambdabot> (Ord k) =>
08:40:40 <lambdabot> (a -> a -> a) -> [(k, a)] -> Data.Map.Map k a
08:41:33 <SimonRC> @type Data.Map.fromListWith (++) . map (\(x,y)->(y,x)) . Data.Map.toList
08:41:34 <lambdabot> forall a a1. (Ord a1) => Data.Map.Map [a] a1 -> Data.Map.Map a1 [a]
08:41:42 <SimonRC> hmm
08:42:00 <SimonRC> @type Data.Map.fromListWith (++) . map (\(x,y)->(y,[x])) . Data.Map.toList
08:42:01 <lambdabot> forall k a. (Ord a) => Data.Map.Map k a -> Data.Map.Map a [k]
08:42:09 <SimonRC> that's it
08:42:15 <xerox> > (snd *** fst) (1,2)
08:42:16 <lambdabot>  add an instance declaration for (Num (a, b))
08:42:17 <SimonRC> @djinn forall k a. (Ord a) => Data.Map.Map k a -> Data.Map.Map a [k]
08:42:17 <lambdabot> Cannot parse command
08:42:22 <xerox> wtf.
08:42:28 <SimonRC> @djinn (Ord a) => Data.Map.Map k a -> Data.Map.Map a [k]
08:42:28 <lambdabot> Cannot parse command
08:42:33 <xerox> > (snd &&& fst) (1,2)
08:42:34 <lambdabot> (2,1)
08:42:34 <SimonRC> @djinn Data.Map.Map k a -> Data.Map.Map a [k]
08:42:35 <lambdabot> -- f cannot be realized.
08:42:37 <SimonRC> @djinn Data.Map.Map k a -> Data.Map.Map a [k]
08:42:37 <lambdabot> -- f cannot be realized.
08:42:39 <ihope> Los tacos son amarillo? Por que?
08:42:45 <ihope> (More-or-less.)
08:42:48 <SimonRC> djinn isn' that smart
08:42:57 <SimonRC> @type Data.Map.fromListWith (++) . map (\(x,y)->(y,[x])) . Data.Map.toList
08:42:58 <lambdabot> forall k a. (Ord a) => Data.Map.Map k a -> Data.Map.Map a [k]
08:43:05 <ihope> @djinn ((a -> ct) -> ct) -> (a -> ((b -> ct) -> ct)) -> (b -> ct) -> ct
08:43:06 <lambdabot> f a b c = a (\ d -> b d c)
08:43:08 <ihope> It can do that.
08:43:26 <int-e> @djinn (a->a) -> a
08:43:26 <lambdabot> -- f cannot be realized.
08:43:31 <SimonRC> :-)
08:43:51 <ihope> Heh.
08:44:02 <ihope> @djinn (a -> a) -> (a -> a) -> a
08:44:03 <lambdabot> -- f cannot be realized.
08:44:08 <ihope> How many does it need?
08:44:17 <ihope> @djinn [(a -> a)] -> a
08:44:18 <lambdabot> -- f cannot be realized.
08:44:27 <ihope> @djinn a -> (a -> a)
08:44:28 <lambdabot> f _ a = a
08:44:33 <ihope> 'Ere we go.
08:44:58 <SimonRC> :-S
08:45:04 <Saulzar> @djinn ((a -> b) -> b) -> ((b -> c) -> c) -> (a -> b) -> c
08:45:05 <lambdabot> -- f cannot be realized.
08:45:17 <ihope> ...Wait, what?
08:45:20 <SimonRC> @djinn [a->a]->(a->a)
08:45:21 <lambdabot> f _ a = a
08:45:30 <SimonRC> grr
08:45:30 <SimonRC> grr
08:45:32 <SimonRC> @djinn [a->a]->(a->a)
08:45:32 <lambdabot> f _ a = a
08:45:39 <musasabi> Djinn does not do lists.
08:45:44 <Saulzar> @djinn ((a -> b) -> b) -> ((b -> c) -> c) -> (a -> b) -> (a -> c)
08:45:44 <lambdabot> -- f cannot be realized.
08:45:44 <int-e> @djinn [a] -> a
08:45:45 <lambdabot> -- f cannot be realized.
08:45:47 <ihope> A Cont a b -> Cont b c -> (a -> b) -> c?
08:45:51 <SimonRC> @type foldr1 (.)
08:45:52 <lambdabot> forall c. [c -> c] -> c -> c
08:45:58 <SimonRC> grr * 2
08:46:11 <SimonRC> @@
08:46:12 <lambdabot> Not enough arguments to @.
08:46:14 <SimonRC> @@@
08:46:15 <lambdabot> Maybe you meant: . id pl wn
08:46:17 <Saulzar> @djinn ((a -> b) -> b) -> ((b -> c) -> c) -> (a -> b) -> (a -> c) -> c
08:46:18 <lambdabot> -- f cannot be realized.
08:46:20 <SimonRC> @@ @
08:46:20 <lambdabot> Not enough arguments to @.
08:46:22 <SimonRC> @@ @ @
08:46:23 <lambdabot> compose module failed: Parse error: "@"
08:46:30 <SimonRC> @help @
08:46:30 <lambdabot>  @help <command> - ask for help for <command>
08:46:31 <ihope> Mmh.
08:46:32 <Saulzar> @djinn ((a -> b) -> b) -> ((b -> c) -> c) -> (a -> c) -> c
08:46:32 <lambdabot> -- f cannot be realized.
08:46:34 <SimonRC> @help @@
08:46:34 <lambdabot>  @help <command> - ask for help for <command>
08:46:35 <musasabi> @type (\xs -> head (repeat id ++ xs))
08:46:36 <lambdabot> forall a. [a -> a] -> a -> a
08:46:54 <int-e> @@ @djinn a -> a @eval
08:46:55 <lambdabot> compose module failed: Parse error: "@djinn"
08:47:03 <Saulzar> Hmm
08:47:51 <glauber_sp> guys, I've already read some tutorials (the craft of functional programming book and A gentle introduction..). Now should I read the Report itself?
08:48:03 <ihope> Nope. Just use it as a reference...
08:48:17 <ihope> Use tutorials wherever possible ;-)
08:48:36 <_Codex> glauber: good to browse it through so you know what kind of things to expect
08:48:54 <lispy> glauber_sp: i'd look at the report, but i'd recommend things like nomeware(sp?) that talk about concepts and things you can do with haskell
08:48:58 <ihope> It helps to know the Prelude, too.
08:49:01 <samc> it isn't hard reading
08:50:01 <glauber_sp> lispy, nomeware is about monads, right? i saw the link some minutes before
08:51:56 <ihope> @index Cont
08:51:57 <lambdabot> Control.Monad.Cont, Control.Monad.Cont
08:52:19 <ihope> One would wonder why that's in there twice.
08:52:34 <ihope> Probably because it's both a type constructor and a data constructor.
08:52:56 <glauber_sp> another thing: I wanted to do my final work  in algebraic specification of ADT. I guess I may learn haskel in the place of CASL, didn't I?
08:53:15 <ihope> @index callCC
08:53:15 <lambdabot> Control.Monad.Cont
08:53:19 <glauber_sp> lambdabot, nomeware?
08:53:35 <glauber_sp> @seach nomeware
08:53:36 <lambdabot> Unknown command, try @listcommands.
08:53:41 <glauber_sp> @google nomeware
08:53:42 <lambdabot> http://nomeware.dy.fi/
08:54:20 <shapr> lispy: pong?
08:56:03 <jophar_> can I paste something here? or I have to use pastebin?
08:56:20 <ihope> One-liners are fine, I think.
08:56:30 <jophar_> 2 lines
08:56:41 <shapr> two lines is okay
08:57:19 <tromp_> 4 lines is ok too:)
08:57:36 <ihope> 20 lines is not, I'm assuming...
08:57:45 <shapr> I tend to stop at three lines.
08:57:51 <tromp_> 10 or more is frowned upon
08:57:55 <jophar_> funcAux [] l = l
08:57:55 <jophar_> funcAux [(x,y,z):cauda] l = if(head(show y) == '2') then( funcAux [cauda] (l:z) ) else funcAux cauda l
08:58:10 <jophar_> ok it is giving me an error
08:58:18 <shapr> The whole spirit of not pasting is about not interrupting existing conversations and not irritating other users.
08:58:27 <jophar_> type a does not match [a]
08:58:28 <shapr> So if the channel is dead, pasting more is fine.
08:58:36 <shapr> If it's fast and furious, pasting less is suggested.
08:58:41 <jophar_> I dont see where I use a type :\
08:59:06 <ihope> Well, everything in Haskell has a type, whether you like it or not.
08:59:16 <ihope> > let funcAux [(x,y,z):cauda] l = if(head(show y) == '2') then( funcAux [cauda] (l:z) ) else funcAux cauda l
08:59:17 <lambdabot>  parse error on input `}'
08:59:21 <ihope> > let funcAux [(x,y,z):cauda] l = if(head(show y) == '2') then( funcAux [cauda] (l:z) ) else funcAux cauda l in ()
08:59:22 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
08:59:22 <lambdabot>   Expected type: a
08:59:22 <lambdabot>   Inferred type: [a]
08:59:25 <tromp_> you don't mean [(x,y,z):cauda] but ((x,y,z):cauda)
08:59:40 <jophar_> hummm
08:59:50 <tromp_> sam emistake you made before
09:00:06 <ihope> > Control.Monad.Cont.callCC
09:00:07 <lambdabot>  Not in scope: `Control.Monad.Cont.callCC'
09:00:11 <jophar_> same error :\
09:00:22 <ihope> @index callCC
09:00:23 <lambdabot> Control.Monad.Cont
09:00:45 <ihope> ...So, uh...
09:00:54 <xerox> Potentially dangerous?
09:02:11 <jophar_> funcAux :: [(String,String,String)] -> [String] -- ?
09:02:34 <jophar_> this is the objective
09:02:52 <xerox> jophar_: and what should it do?
09:03:41 <jophar_> if the firtst digit of y is '2' he adds z to a list
09:03:51 <jophar_> in the end, it returns that list
09:04:20 <jophar_> x y and z are name, number, email but are not relevant in this case (I think)
09:05:03 <ihope> May help to have a newtype here.
09:05:32 <ihope> newtype Person = Person {name :: String, number :: String, email :: String} --?
09:05:49 <Lemmih> Hiya SyntaxNinja.
09:06:22 <JaffaCake> hey SyntaxNinja
09:07:28 <jophar_> ihope I cannot use new types :X
09:08:27 <xerox> > let f = (>>= \(_,y,z) -> if (head . show $ y) == '2' then return z else mzero) in f [(0,200,"John"),(1,100,"Mariah"),(2,250,"Phil")]
09:08:28 <lambdabot> ["John","Phil"]
09:08:40 <dcoutts> SyntaxNinja, do you think your concerns over the wiki comments on library documentation have been alayed?
09:09:40 <xerox> Like that?
09:09:47 <jophar_> monads ftw
09:10:19 <shapr> ftw?
09:10:23 <xerox> wtf.
09:10:25 <shapr> oh
09:10:32 <jophar_> for the win
09:10:35 <xerox> :-D
09:10:37 <wchogg> Are you sure he didn't mean "for the win"?
09:10:44 <wchogg> Ah, day late and a dollar short.
09:10:44 <xerox> <blink>
09:11:13 <jophar_> but xerox thats it
09:12:09 <xerox> Plenty of ways to do it, in fact.
09:12:25 <jophar_> I am trying without monads...
09:14:03 * SimonRC grins: "I've said it before and I will say it again, until people stop repeating the party line and start using their brains. / * Static typing is superior to dynamic typing in every way. / Static typing imposes no limitations. / "...
09:14:07 <SimonRC> hehehe
09:14:39 <xerox> > foldl (\xs (x,y,z) -> if (head . show $ y) == '2' then z:xs else xs) [] [(0,200,"John"),(1,100,"Mariah"),(2,250,"Phil")]
09:14:40 <lambdabot> ["Phil","John"]
09:15:12 <xerox> jophar_: it's ok to discard the first member of the triple?
09:15:30 <jophar_> yepp, in this case is not used
09:15:47 <xerox> Great.
09:16:40 <xerox> This one is nice...
09:16:45 <xerox> > filter (\(x,y,z) -> (head $ show y) == '2') [(0,200,"John"),(1,100,"Mariah"),(2,250,"Phil")]
09:16:46 <lambdabot> [(0,200,"John"),(2,250,"Phil")]
09:16:58 <xerox> If you want:
09:17:22 <xerox> Ah, name is the first one.
09:17:58 <xerox> > let f xs = [ name | (name,number,_) <- xs, head (show number) == '2' ] in f [(0,200,"John"),(1,100,"Mariah"),(2,250,"Phil")]
09:17:59 <lambdabot> [0,2]
09:18:01 <xerox> Ops.
09:18:39 <xerox> > let f xs = [ name | (name,number,_) <- xs, head (show number) == '2' ] in f [("Jophar",200,".."),("Xerox",100,".."),("Shapr",250,"..")]
09:18:40 <lambdabot> ["Jophar","Shapr"]
09:18:49 <jophar_> > let "test" ++ "test2"
09:18:50 <lambdabot>  parse error (possibly incorrect indentation)
09:19:25 <xerox> > "foo" ++ "bar"
09:19:26 <lambdabot> "foobar"
09:19:41 <xerox> > concat ["foo","bar"]
09:19:42 <lambdabot> "foobar"
09:19:47 <jophar_> but...
09:20:05 <jophar_> > [jophar] ++ [test]
09:20:06 <lambdabot>  Not in scope: `test'
09:20:16 <jophar_> ./suicide
09:20:17 <xerox> > (>>= fix . return) ["foo","bar"]
09:20:18 <lambdabot> "foobar"
09:20:22 <xerox> (ok I'm cheating ;-))
09:20:44 <xerox> jophar_: 'jophar' and 'test' are free vars in that expression.
09:21:05 <jophar_> humm
09:22:36 <xerox> What do you mean to express with [jophar] ?
09:23:04 <eivuokko> Does anyone know off-hand what is the register ghc uses to point to haskell regs in ia-32?
09:23:13 <jophar_> xerox... lol I am so stupid :X
09:23:58 <xerox> It's just syntax.
09:38:48 <roconnor> Time to learn Parsec
09:40:30 <ronnie> Question: How come the type incAngle :: Int -> Int -> Float doesn't hold for the function incAngle i n = (360 / n) * i? ghc complains about the body evaluating to Int rather than Float
09:42:27 <xerox> @type let incAngle i n = (360 / n) * i in incAngle
09:42:27 <lambdabot> forall a. (Fractional a) => a -> a -> a
09:42:28 <Lemmih> > let incAngle i n = (360 / fromIntegral n) * fromIntegral i in incAngle 10 32
09:42:29 <lambdabot> 112.5
09:42:36 <xerox> Yeah.
09:42:58 <int-e>  @type let incAngle i n = (360 / fromIntegral n) * fromIntegral i in incAngle
09:42:59 <xerox> Point being: the two arguments have to have the same type.
09:43:11 <int-e> @type let incAngle i n = (360 / fromIntegral n) * fromIntegral i in incAngle
09:43:12 <lambdabot> forall a a1 b.
09:43:12 <lambdabot> (Integral a1, Fractional b, Integral a) =>
09:43:12 <lambdabot> a -> a1 -> b
09:48:17 <xerox> > let f [] = []; f ((name,number,_):xs) | head number == '2' = name : f xs | otherwise = f xs; in f [("joao","253678","test@1"),("pedro","43552","test2@2"),("test","28732","test3@3")]
09:48:18 <lambdabot> ["joao","test"]
09:53:11 <roconnor> @hoogle Parsec
09:53:12 <lambdabot> Distribution.Setup.parseConfigureArgs :: ConfigFlags -> [String] -> [
09:53:12 <lambdabot> OptDescr a] -> IO (ConfigFlags, [a], [String])
09:53:12 <lambdabot> Distribution.Setup.parseCleanArgs :: [String] -> [OptDescr a] -> IO (Int,
09:53:12 <lambdabot> [a], [String])
09:53:12 <lambdabot> Distribution.Setup.parseCopyArgs :: CopyFlags -> [String] -> [OptDescr a]
09:53:14 <lambdabot> -> IO (CopyFlags, [a], [String])
09:53:20 <roconnor> @info Parsec
09:53:20 <lambdabot> Unknown command, try @listcommands.
09:53:30 <xerox> roconnor: what are you looking for?
09:53:37 <xerox> Text.ParserCombinators.Parsec, maybe?
09:53:39 <roconnor> ys
09:53:54 <xerox> xs.
10:07:47 <ronnie> I'm reading "The Haskell School of Expression". Can it be that to generally solve the exercises in the book, it requires more Haskell knowledge than has actually been introduced at that point? Specifically, I'm looking at Exercise 2.2 og Page 25 and it doesn't appear solvable with what Hudak has presented thus far.
10:08:40 <xerox> What does it state?  (Sorry, I do not have a copy of the text)
10:09:38 <ronnie> Exercise 2.2: "Define a function regularPolygon :: Int -> Side -> Shape such that regularPolygon ns is a regular polygon with n sides, each of length s"
10:09:54 <ronnie> oops regularPolygon n s
10:10:32 <SimonRC> is Shape defiend by that point?
10:11:16 <ronnie> yes, shape is data Shape = Polygon [(Float, Float)] | ...
10:11:28 <xerox> Cool.
10:11:48 <xerox> What are the other data costructors?
10:14:35 <ronnie> So regularPolygon should keep a counter of how far it is in the process of defining the vertexes of the polygon, and compute something like  (s * cos(angle), s * sin(angle)) for n different angles.
10:15:20 <xerox> Yeah, sounds like a fold.
10:16:16 <ronnie> but you can't compute s * cos(angle), since s is a Side, not an Int or what cos requires.
10:16:30 <xerox> @type cos
10:16:31 <lambdabot> forall a. (Floating a) => a -> a
10:16:36 <xerox> What is a Side?
10:16:42 <ronnie> type Side = Float
10:17:02 <xerox> Then 's * cos(angle)' is legal.
10:18:53 <xerox> (If angle :: Float, that is :-))
10:20:19 <ronnie> I'm sure I could come up with a solution, but it would be interesting to know if I should generally expect to use features not explained. That's ok if it's intended. If not, then my solution is probably "wrong", although it works.
10:23:05 <xerox> (If your problem is to cast an Int to a Float, you can use fromIntegral)
10:23:41 <xerox> roconnor: was that book a good reading so far?
10:26:47 <ronnie> xerox: Me? So far it's been good, but I'm only at page 40 something.
10:27:22 <roconnor> @hoogle natural
10:27:22 <xerox> ronnie: what about the exercises?  Are there many?
10:27:23 <lambdabot> Text.ParserCombinators.Parsec.Token.natural :: TokenParser st -> CharParser
10:27:23 <lambdabot> st Integer
10:27:23 <lambdabot> Text.ParserCombinators.Parsec.Token.naturalOrFloat :: TokenParser st ->
10:27:23 <lambdabot> CharParser st (Either Integer Double)
10:27:47 <glauber_sp> t
10:28:02 <glauber_sp> guys, is there any pdf version of that All About Monads tutorial?
10:28:20 <xerox> Sure there is.
10:28:28 <xerox> Err, misread.
10:28:35 <xerox> I don't know if there is one, sorry.
10:28:52 <xerox> I fooled you!  <blink>
10:29:17 <roconnor> xerox: what book?
10:29:33 <roconnor> oh, wasn't for me
10:29:34 <xerox> roconnor: Hudak's School of Expression
10:30:05 <roconnor> @hoogle tab
10:30:06 <lambdabot> Text.ParserCombinators.Parsec.Char.tab :: CharParser st Char
10:30:06 <lambdabot> Data.Graph.Table :: Array Vertex a
10:30:06 <lambdabot> Text.Html.table :: Html -> Html
10:30:28 <ronnie> xerox: Not too many exercises. Maybe a handful in each chapter
10:30:30 <roconnor> @hoogle natural
10:30:30 <lambdabot> Text.ParserCombinators.Parsec.Token.natural :: TokenParser st -> CharParser
10:30:30 <lambdabot> st Integer
10:30:30 <lambdabot> Text.ParserCombinators.Parsec.Token.naturalOrFloat :: TokenParser st ->
10:30:30 <lambdabot> CharParser st (Either Integer Double)
10:30:51 <roconnor> what's a TokenParser st?
10:32:22 <xerox> roconnor: it's explained thoughtfully here: http://www.cs.uu.nl/~daan/download/parsec/parsec.html  I think.
10:32:47 <xerox> There's a big 'data TokenParser st = = TokenParser{ ... }'.
10:33:12 <xerox> ``The type of the record that holds lexical parsers that work on character streams with state st.''
10:33:15 <roconnor> hmm, all I want to do is parse a natural number
10:33:30 <roconnor> which TokenParser do I want
10:33:55 <xerox> nat = many1 (oneOf "0123456789") ?
10:34:02 <roconnor> that's a string
10:34:05 <glauber_sp> xerox, no problem. I'll read the html version =)
10:34:14 <roconnor> someone suggests parsing a string and running read on it.
10:34:15 * SamB wants skipManyTill
10:34:17 <roconnor> :-/
10:35:03 <xerox> roconnor: hmm.
10:35:10 <xerox> Give me a minute, I'll try.
10:36:03 * SimonRC goes
10:39:25 <xerox> roconnor: this seem to work:
10:39:26 <xerox> import Text.ParserCombinators.Parsec
10:39:26 <xerox> import qualified Text.ParserCombinators.Parsec.Token as P
10:39:26 <xerox> import qualified Text.ParserCombinators.Parsec.Language as L
10:39:26 <xerox> lexer = P.makeTokenParser L.emptyDef
10:39:28 <xerox> nat = P.natural lexer
10:40:30 <roconnor> oh
10:41:15 <xerox> @index run
10:41:15 <lambdabot> Data.Graph.Inductive.NodeMap, Data.Graph.Inductive, Test.QuickCheck.Batch,
10:41:15 <lambdabot> Debug.QuickCheck.Batch
10:41:22 <xerox> @index runLex
10:41:23 <lambdabot> bzzt
10:42:34 <xerox> OK:  parse nat "" "123"  to test it out.
10:42:52 <xerox> There is a commodity 'run' function defined on that page, too.
10:44:46 <roconnor> I'm using parseTest
10:46:11 <xerox> 'run' just cases on the 'Either a b' returned by 'parse'.
10:47:29 <roconnor> hmm letter probably doesn't match on Ã©
10:48:02 <roconnor> oh it does
10:49:25 <jethr0> glauber_sp: i did a pdf conversion of the tutorial...
10:50:03 <xerox> jethr0: is it public?
10:50:03 <jethr0> cd
10:50:18 <jethr0> sure, i'm just gonna reupload it...
10:50:43 <glauber_sp> jethr0, I did one, too. but some code did not appear in the pdf
10:50:50 <glauber_sp> I used htmldoc
10:51:06 <jethr0> well, there's always problems with conversions. but mine is reasonably complete
10:51:20 <glauber_sp> jethr0, can u send me?
10:52:28 <jethr0> glauber_sp: i'm uploading it onto the wiki (with sources). just a moment
10:53:01 <xerox> Someone should mail that Nomaware Guy.
10:53:27 <jethr0> ya, well, there's still the occasional error in the conversion so i'm not sure he'd be too grateful :)
10:54:09 <xerox> Mail him to ask him to provide one :-)
10:54:23 <xerox> HTML is passÃ¨.  <grin>
10:54:35 <jethr0> g
10:54:42 <glauber_sp> jethr0, no problems. I've downloaded the html version =) thanks anyway 
10:55:10 <jethr0> np
10:55:48 <glauber_sp> =) well, I'll go read that. see you later, guys =)
11:00:16 <jethr0> xerox: http://haskell.org/tmrwiki/AllAboutMonads
11:01:16 <roconnor> ooooooooh "." isn't a letter
11:01:20 <roconnor> parsing is hard
11:02:26 <roconnor> can I parse everything that isn't a tab?
11:02:46 <xerox> Hopefully :-)
11:02:59 <jethr0> roconnor: i don't mean to be rude, but have you glanced over the tutorials?
11:03:05 <jethr0> are you using parsec BTW?
11:03:42 <roconnor> I glanced over them, but I'm trying to write something really simple
11:03:56 <roconnor> and they go into matching parentesis, and all that sort of thing
11:03:59 <roconnor> *sigh*
11:04:51 <jethr0> noneOf
11:05:19 <xerox> noneOf "\t"
11:05:20 <SamB> roconnor: noneOf "\t"
11:05:51 <xerox> There's a list of functions at the very end of the online documentation.
11:06:09 <Lemmih> SyntaxNinja: Hey. Would you mind if I exported 'constructGHCCmdLine' from Distribution.Simple.Build? I need it for the Cabal integration in hIDE.
11:06:24 <roconnor> thx
11:06:29 <jethr0> http://www.cs.uu.nl/~daan/download/parsec/parsec.html#ParsecChar has the atomic functions
11:06:42 <jethr0> http://www.cs.uu.nl/~daan/download/parsec/parsec.html#ParsecCombinator has the combinators
11:06:59 <xerox> http://www.haskell.org/ has you
11:07:25 <jethr0> in soviet russia haskell like you!
11:07:27 <roconnor> It's all a matter of becoming familar with the primitives
11:07:31 <jethr0> *likes
11:07:41 <xerox> Indeed roconnor.
11:07:55 * xerox hopes roconnor will teach him Coq someday.
11:09:04 <jethr0> @where all about monads
11:09:04 <lambdabot> I know nothing about all.
11:09:32 <xerox> jethr0: why did you put it on TMRwiki?
11:09:41 <jethr0> http://haskell.org/tmrwiki/AllAboutMonads
11:13:38 <roconnor> yay I'm parsing
11:13:48 <roconnor> @where cut-and-paste
11:13:49 <lambdabot> I know nothing about cut-and-paste.
11:13:58 <jethr0> nice
11:14:05 <astrolabe> There is hat.  But I've never used it.
11:14:33 <roconnor> I want to show off my parser, to get advice on if it should be written differently
11:14:39 <roconnor> maybe I'm missing better combinators
11:14:47 <roconnor> where's that cut and paste place?
11:15:28 <roconnor> xerox: see #coq
11:15:30 <shapr> jethr0: You want to put meta-haskell into the next TMR as well?
11:15:32 <jethr0> http://paste.lisp.org/new/haskell
11:15:49 <jethr0> shapr: as well? yes i'd love to
11:16:00 <lisppaste2> roconnor pasted "my first parser" at http://paste.lisp.org/display/15995
11:16:20 <roconnor> is that what it ought to look like?
11:16:32 <astrolabe> roconnor: using parsec?
11:16:39 <Lemmih> dcoutts: The project manager now works with HaskellSense. hIDE would almost be usable if it could save files (:
11:16:41 <roconnor> astrolabe: yep
11:16:59 <dcoutts> Lemmih, cool!
11:17:36 <astrolabe> roconnor: maybe abstract out the   manyTill ? tab   pattern
11:17:54 <jethr0> roconnor: hmm, i'm not so sure. so much code duplication...
11:18:03 <astrolabe> and then the other repeated stuff
11:18:56 <roconnor> Perhaps a ntimes p num is appropriate
11:19:31 <jethr0> roconner the consecutive "manyTill anyChar" could be done with sepBy IMHO
11:20:36 <roconnor> still, I need to bind all the names.
11:21:16 <astrolabe> I agree with jethr0.  I try to eliminate repeated code as much as possible.
11:21:34 <roconnor> as it stands it is easy to modifiy some of the manyTill anyChar tab can be replaced by more specific parsers in the future
11:21:53 <roconnor> duplicate code should only be shared if there is a semantic reason to share it.
11:21:56 <lisppaste2> jethr0 annotated #15995 with "untested annotation" at http://paste.lisp.org/display/15995#1
11:22:58 <jethr0> roconnor: depends what methodology/paradigm you follow. in test driven development / extreme programming _any_ form of duplication is removed.
11:23:37 <jethr0> roconnor: my annotation is probably totally wrong (even considering types)...
11:24:51 <jethr0> roconnor: forget what i annotated. but you might consider writing a parser that does "manyTill anyChar tab" and call that!
11:25:53 <jethr0> but "(many1 anyChar) `sepBy` tab" might even work
11:26:21 <roconnor> jethr0: xp programming: interesing.  I suppose it isn't too hard to reduplicate the code if that is needed.
11:26:41 <roconnor> as in one needs to be severly modified, but the other doesn't
11:27:07 <astrolabe> what does it do?
11:27:36 <jethr0> exactly
11:27:55 <roconnor> what does what do?
11:27:59 <jethr0> but you might not even want to do that, but rather extract the commonalities and write specializations
11:29:30 <Lemmih> dcoutts: Wanna help me plan the GUI interface?
11:30:01 <dcoutts> Lemmih, sure
11:32:35 <roconnor> [disenname, disfrname, ten, tfr, sur, middle, first, pen, pfr] <- sequence $ replicate 9 (manyTill anyChar tab)
11:33:07 <jethr0> yep, sequence crossed my mind too :)
11:33:35 <astrolabe> roconnor: I wondered what the purpose of the parser was going to be (or the code that includes it).
11:34:05 <roconnor> I'm parsing the preliminary results file that elections canada publishes
11:34:19 <roconnor> It is tab-separeted data
11:34:36 <astrolabe> Ah.  I gathered about the tabs :)
11:35:22 <lisppaste2> roconnor annotated #15995 with "InfoLine" at http://paste.lisp.org/display/15995#2
11:35:31 <roconnor> There is the datatype
11:35:37 <Lemmih> dcoutts: I added a GUI section on the Wiki.
11:35:46 * dcoutts looks for ie
11:42:19 <roconnor> @hoogle lift
11:42:20 <lambdabot> Text.ParserCombinators.ReadPrec.lift :: ReadP a -> ReadPrec a
11:42:20 <lambdabot> Control.Monad.Trans.lift :: (MonadTrans t, Monad m) => m a -> t m
11:42:20 <lambdabot> a
11:42:20 <lambdabot> Language.Haskell.TH.Syntax.Lift :: Lift t
11:43:43 <roconnor> @hoogle m a -> IO a
11:43:44 <lambdabot> Control.Exception.evaluate :: a -> IO a
11:43:44 <lambdabot> System.Exit.exitFailure :: IO a
11:43:44 <lambdabot> Control.Concurrent.Chan.readChan :: Chan a -> IO a
11:44:10 <roconnor> @hoogle liftIO
11:44:11 <lambdabot> Control.Monad.Trans.liftIO :: MonadIO m => IO a -> m a
11:44:11 <lambdabot> Graphics.UI.ObjectIO.StdIOBasic.liftIO :: IOMonad m => IO a -> m a
11:47:15 <canada2>  has to go today 1 alienware laptop 1 alienware desktop. price 500 each includes shipping and carry case for the laptop or monitor/keyboard/mouse for the desktop. message me if your interested at mcsltd1@hotmail.com, or ogd443 on aim or mcsltd2 on yahoo messenger. these MUST go today!
11:48:18 <roconnor> @hoogle right
11:48:19 <lambdabot> Control.Arrow.right :: ArrowChoice a => a b c -> a (Either d b) (Either d
11:48:19 <lambdabot> c)
11:48:19 <lambdabot> Data.Either.Right :: b -> Either a b
11:48:19 <lambdabot> Prelude.Right :: b -> Either a b
11:49:11 <Lemmih> @hoogle wrong
11:49:12 <lambdabot> No matches found
11:55:31 <Lemmih> dcoutts: Indeed. But I'd like enumerate all the use cases first.
11:56:14 * astrolabe is tempted to give canada2's email addresses to a spam bot.
11:56:40 <Lemmih> Isn't canada2 a spam bot?
11:56:47 <Cale> He's not a bot
11:56:57 <Cale> Well, possibly using one
11:57:10 <astrolabe> He's disguising his addresses.
11:57:18 <Cale> I talked to him on MSN at one point.
11:57:44 <Cale> He doesn't seem to get the picture.
11:57:52 <vincenz> can't sell on the net?
11:59:10 <Cale> Well, not on freenode anyway. Topic directed channels not directed at selling hardware aren't really a great place to spam.
12:01:12 <Heffalump> if someone complains to hotmail they will probably shut down his account
12:01:21 <Heffalump> I managed to really piss off a spammer by doing that once.
12:01:27 <Cale> ah, go for it
12:01:48 <SimonRC> Heffalump: real spammers have spam-permitting contracts with ISPs
12:02:01 <Heffalump> this was a particularly inept spammer.
12:03:40 <SamB> if you are a regular and/or the item in question is on-topic, is it okay to ask if anyone is interested in a conversational manner?
12:04:31 <Heffalump> I would consider it fine.
12:04:43 <musasabi> SamB: yes, I think that makes sense.
12:05:21 <Philippa> SimonRC: for values of "real spammers" that don't just use botnets to do it
12:05:45 <SimonRC> true
12:08:36 * SamB thinks there ought to be a version of option that returns a maybe
12:11:12 <SimonRC> @type option
12:11:13 <lambdabot> Not in scope: `option'
12:11:30 <SimonRC> SamB: what's option?
12:11:37 <SimonRC> @hoogle option
12:11:37 <lambdabot> System.Console.GetOpt.Option :: [Char] -> [String] -> ArgDescr a ->
12:11:37 <lambdabot> String -> OptDescr a
12:11:37 <lambdabot> Text.Html.option :: Html -> Html
12:11:37 <lambdabot> Text.ParserCombinators.ReadP.option :: a -> ReadP a -> ReadP a
12:12:06 <SamB> Text.ParserCombinators.ReadP.option <- that one
12:12:12 <SamB> er.no
12:12:16 <SamB> .the one in Parsec..
12:12:28 <SamB> @hoogle Parsec.Option
12:12:28 <lambdabot> Prelude.undefined :: a
12:12:28 <lambdabot> Test.QuickCheck.Batch.bottom :: a
12:12:32 <SamB> hmm.
12:12:53 <SimonRC> can't you write it?
12:12:59 <SamB> the one in ReadP is more-or-less the same thing
12:13:14 <SamB> I could write it, but I don't know what to call it ;-)
12:14:16 <ADEpt> @type Text.ParserCombinators.Parsec.option
12:14:17 <lambdabot> forall a st tok.
12:14:17 <lambdabot> -> Text.ParserCombinators.Parsec.Prim.GenParser tok st a
12:14:17 <lambdabot> -> Text.ParserCombinators.Parsec.Prim.GenParser tok st a
12:14:39 <SamB> it lost the "a" somewhere
12:14:47 <SimonRC> yse
12:16:24 * SimonRC goes
12:17:56 * SamB realizes his function will look nicer another way anyway
12:24:05 <SamB> @djinn a -> (a, a)
12:24:05 <lambdabot> f a = (a, a)
12:24:44 <SamB> @. pl djinn a -> (a, a)
12:24:44 <lambdabot> f = join (,)
12:25:44 <SamB> okay....
12:25:48 <xerox> (id &&& id) :: a -> (a,a)
12:25:53 <SamB> that is one of those Monad (->) thingies, isn't it?
12:25:56 <xerox> Yes.
12:26:19 <xerox> @type Control.Monad.join
12:26:19 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
12:26:56 <xerox> @type (Control.Monad.join :: Monad ((->) a) => (a -> a -> a) -> a -> a)
12:26:57 <lambdabot> forall a. (Monad ((->) a)) => (a -> a -> a) -> a -> a
12:27:09 <Cale> in the reader monad,  join f x = f x x
12:28:16 <xerox> @type (Control.Monad.join (,) :: Monad ((->) a) => a -> (a,a))
12:28:17 <lambdabot> forall a. (Monad ((->) a)) => a -> (a, a)
12:28:37 <xerox> So one _can_ type \x -> x x !
12:28:46 <xerox> @type (Control.Monad.join id)
12:28:47 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a1
12:28:47 <lambdabot>   Expected type: a -> a -> a1
12:28:51 <xerox> No, okay :-)
12:40:17 <Heffalump> :-)
12:40:27 <xerox> grmbl ;)
12:41:15 <Heffalump> @type \f g x -> f x (g x)
12:41:16 <lambdabot> forall t t1 t2. (t1 -> t -> t2) -> (t1 -> t) -> t1 -> t2
12:41:33 <Heffalump> @type \x y -> x
12:41:33 <lambdabot> forall t t1. t -> t1 -> t
12:41:50 <Heffalump> just cos we can type S and K doesn't mean we can type W :-)
12:45:39 <xerox> We don't have @get-definition anymore, right?
12:50:33 <ihope> In Soviet Russia, Control.Monad.Cont is not in callCC.
12:50:43 <ihope> At least, it doesn't seem to be.
12:50:50 <shapr> Are there any good tutorials specifically on nonstrict eval and its benefits?
12:51:11 <ihope> If you don't need to do it, Haskell doesn't do it.
12:51:32 <ihope> s/you don't/Haskell doesn't/
12:52:33 <shapr> Cale: Want to write about nonstrict eval and benefits for the next (and probably last) TMR?
12:55:48 * xerox freezes
12:56:37 <ihope> How come Control.Monad.Cont.callCC returns a scoping error?
12:57:05 <ihope> > Control.Monad.Cont.callCC :: ((a -> Cont c b) -> Cont c a) -> Cont c a
12:57:07 <lambdabot>  Not in scope: type constructor or class `Cont'
12:57:13 <ihope> ...Bleh.
12:59:03 <Philippa> shapr: I can give some example code (taken from Flippi) that uses it to its advantage
13:00:22 <shapr> Philippa: mikaeli wants to read about nonstrict eval.. and I realize I don't know any docs that specifically cover it.
13:05:37 <palomer> hrmph
13:05:40 <palomer> trying to find an algorithm for solving hornsat isn't very easy
13:07:05 <monochrom> "why functional program matters" has benefits of lazy evaluation.
13:09:07 <monochrom> Actually it *is* a tutorial on lazy evaluation combined with higher-order functions.
13:09:42 <sylvan> One nice benefit of lazy evaluation is when implementing progress-bars in a GUI. That's really ugly to do in most imperative languages, but in Haskell you can cleanly separate the algorithm from the presentation
13:09:44 <Heffalump> the data-driven coroutines point of view is neat
13:10:00 <Heffalump> sylvan: really? how?
13:10:22 <SamB> sylvan: so how does that give you progress bars?
13:10:25 <musasabi> I think that collecting statistics about things is one of the hard things to do in Haskell
13:10:30 <sylvan> well, if your algorithm produces a list, then present the list one item at a time (or some other forcing operation) and update the progress bar each step
13:11:00 <sylvan> whereas in an imperative solution you'd need the algorithm to send back an event or something every n steps so that you could update the progress bar
13:11:23 <monochrom> Thus, John Hughes's point is that these two features - higher-order functions and lazy evaluation - enables further modularisation and reuse than imperative programming offers.
13:11:28 <SamB> I suppose they are easier than in other languages, maybe, but not just "drop in an algorithm and tada! progress bar!"
13:11:42 <Heffalump> ok, but it depends on your progress being in step with the list production
13:11:54 <ihope> @quote
13:11:55 <lambdabot> vixen says: If you see this, gentle sir, know that you are being trolled
13:11:55 <lambdabot> by a poorly configured VixenLove program
13:12:05 <sylvan> Yes, you'd still have the problem of deciding where and how much to update the progress bar
13:12:27 <sylvan> but you can separate that problem from the problem of the actual algorithm
13:12:32 <sylvan> so laziness == more modularity
13:12:36 <Cale> monochrom: or even strict functional programming
13:12:41 <Heffalump> only if you produce data bit by bit
13:12:48 <monochrom> Sprinkling a couple of "unsafePerformIO (updateProgressBar)" in your recursive function will do the trick. :)
13:12:49 <SamB> quick! somebody tell me how to do a progress bar for my C-- parser!
13:12:55 <ihope> C--?
13:13:08 <Heffalump> Cale: one of the points of why FP matters is that laziness gets you more, because you consume data as you produce it
13:13:17 <sylvan> Heffalump, well that's probably not a problem in any algorithm which lends itself to a progress-bar =)
13:13:19 <Cale> yeah
13:13:35 <Heffalump> sylvan: what about an algorithm that just produces an answer...?
13:13:39 <SamB> certainly I agree that lists-as-iterators is a very powerful aid to reuse
13:14:11 <sylvan> Heffalump, I supppose you could always generalise it to produce the steps of acquiring this answer as a list (or any other data structure)
13:14:19 <SamB> monochrom: you'd still need some way of telling how far along you were in some basic sense
13:14:20 <sylvan> but there may be exceptions
13:14:25 <xerox> ...folding unsafePerformIO updateProgressBar is cool, heh.
13:14:29 <monochrom> So, if you plan to write your own "why lazy evaluation matters" tutorial, remember to #include "why fp matters"
13:14:55 <neologism> why fp matters is a great article
13:15:45 <monochrom> ln why-fp-matters.ps why-lazy-matters.ps
13:16:28 <SamB> I mean sure diff(progress, time) doesn't need to be constant, but it at least needs to be >= 0, and progress(t_0) has to be 0, and progress(t_end) has to be 1...
13:17:16 <SamB> hmm, s/diff(progress/diff(progress(time)/
13:18:19 <ihope> > (>>) `asTypeOf` (>>>)
13:18:20 <lambdabot>  add an instance declaration for (Show (a b b -> a b b1 -> a b b1))
13:18:51 <Heffalump> SamB: it bloody well should be constant.
13:18:58 <Heffalump> I get really annoyed as a user when it isn't.
13:18:58 <SamB> @type [(>>), (>>>)]
13:18:59 <lambdabot> Not in scope: `>>>'
13:19:11 <Heffalump> of course, in some cases you just can't provide one that is, because you don't know.
13:19:15 <Heffalump> But if you do, you ought to provide it.
13:19:50 <xerox> Uh.
13:19:51 <SamB> if you know, yeah. but it is awfully hard to know.
13:20:02 <xerox> @type ((>>),(Control.Arrow.>>>))
13:20:03 <lambdabot> forall (m :: * -> *) a b (a1 :: * -> * -> *) b1 c d.
13:20:03 <lambdabot> (Monad m, Control.Arrow.Arrow a1) =>
13:20:03 <lambdabot> (m a -> m b -> m b, a1 b1 c -> a1 c d -> a1 b1 d)
13:20:21 <SamB> @type [(>>),(Control.Arrow.>>>)]
13:20:22 <lambdabot> forall b (a :: * -> * -> *) b1.
13:20:22 <lambdabot> (Monad (a b1), Control.Arrow.Arrow a) =>
13:20:22 <lambdabot> [a b1 b1 -> a b1 b -> a b1 b]
13:20:35 <xerox> Yay.
13:22:46 <dcoutts> xerox, I'll be back in an hour or so. Probably a bit late for hacking on cairo?
13:23:21 <xerox> dcoutts: ping me, I hope to be up :-)
13:24:13 <dcoutts> xerox, ok
13:24:20 * dcoutts &
13:25:09 <palomer> sylvan, just start a thread which accesses a progress floating point value
13:25:10 <palomer> which is common to all threads
13:26:38 <Heffalump> palomer: not much use if your algorithm isn't in IO
13:31:59 <glasser> so, I wrote this sieve of erasthowhosit
13:32:04 <glasser> primes = primer [2, 3..]
13:32:04 <glasser>   where primer (x:xs) = x : primer (filter (notDivBy x) xs)
13:32:04 <glasser>         notDivBy x y  = y `mod` x /= 0
13:32:05 <ihope> Eratosthenes?
13:32:11 <glasser> Yeah, that dude.
13:32:28 <glasser> Now, it's obviously stupid to think about "optimizing a sieve of Eratosthenes"
13:32:34 <ihope> Heh...
13:32:48 <glasser> but I notice that this function is basically checking each number from largest known prime down to 2
13:32:52 <glasser> (right?)
13:33:00 <neologism> no
13:33:03 <ihope> ...I think it's checking every prime number.
13:33:09 <glasser> as opposed to 2 on up, which would probably be more efficient, since half the numbers are 2
13:33:13 <glasser> oh, yeah, sorry, every prime
13:33:21 <neologism> glasser: do tyou know hot the sieve works?
13:33:23 <glasser> but the point is that the order of checking is decreasing
13:33:26 <neologism> s/hot/how
13:33:27 <glasser> neol: yeah
13:33:33 <neologism> the order is increasing
13:33:36 <glasser> (I did write that version)
13:33:50 <glasser> Oh wait, am I totally wrong?
13:33:59 <glasser> Yay, I'm totally wrong
13:34:07 <glasser> OK, "problem" solved :)
13:34:09 <monochrom> You should hand-execute it before claiming what it does.
13:34:10 <ihope> Well, it seems you could pass the list of primes around, and check on that.
13:34:28 <glasser> monochrom: good call
13:35:51 <tromp> there are many more efficient sieves, but none as simple to express as this...
13:36:51 <palomer> this would be in an imperative programming language
13:37:19 <xerox> tromp is the sieve master.
13:37:39 <monochrom> A benefit of lazy evaluation is that imperative programmers can't figure out why your program runs fast. :)
13:38:22 <ihope> Heh...
13:38:56 <xerox> The real benefit of lazy evaluation still has to be evaluated out.
13:39:01 <xerox> <grin>
13:40:37 <ihope> In Unlambda, it's easy to callCC callCC.
13:42:12 <tromp> http://www.cs.kent.ac.uk/people/staff/cr3/toolbox/haskell/GHood/primes.html
13:42:20 <tromp> has a nice animated sieve
13:42:24 <ihope> callCC callCC = callCC [continuation of callCC callCC] = [continuation of callCC callCC] [continuation of callCC [continuation of callCC callCC]] = [continuation of callCC [continuation of callCC callCC]]
13:43:25 <ihope> tromp: ooh... shiny...
13:44:34 <ihope> Uh oh, Java asplode.
13:46:45 <ihope> Ooh, she's a-stuck fast...
13:50:07 <ihope> Eesh! That one Firefox window contains my place in Many Things.
13:50:45 <JKnecht> is hIDE gonna have a symbolic debugger?
13:51:37 <ihope> BANG!
13:51:45 <ihope> Aah, I've been shot!
13:52:41 <JKnecht> obituary?
13:57:39 <TheHunter> it's not a word.
13:57:58 <imix> is there somewhere a slice function on lists defined? (like in python myList[2:5])
13:58:25 <Heffalump> @type \n m -> take (m-n+1) . drop n
13:58:25 <lambdabot> forall a. Int -> Int -> [a] -> [a]
13:58:43 <Heffalump> (\n m -> take (m-n+1) . drop n) 2 5 [0..]
13:58:46 <Heffalump> > (\n m -> take (m-n+1) . drop n) 2 5 [0..]
13:58:47 <lambdabot> [2,3,4,5]
14:00:25 <imix> I already found out how to write this function, I just wondered that such a basic (?) function is not already defined in the Prelude or List
14:01:04 <monochrom> It is not already defined.
14:01:28 <imix> ok, i see
14:04:22 <Heffalump> one of the benefits of being able to write a lot of stuff concisely is that there's no need to clutter up the libraries with it.
14:05:37 <TheHunter> to be fair, Data.List does need a rework.
14:06:47 <eivuokko> Data.List is sort of annoying, for almost all list tasks it almost does it, but not quite :)  Or that's how I often feel.
14:08:19 <Cale> what's it missing?
14:09:23 <TheHunter> for starters, it would be nice to have a way to split a list (e.g. splitting before commas) just as easily as one can do |filter (>0)|
14:09:55 <eivuokko> I dunno, just somehow I don't find the functions in it interact well with each other, needs pattern-matching-using glue often.
14:11:11 <TheHunter> The imho most annoying thing, tho, is that list operations are not compositional enough. A halfway efficient solution of the shootout program that computes lenght, number of lines, and number of words, should be an at-most-two-liner.
14:12:39 <Heffalump> (length xs, length (lines xs), length (words xs)) isn't efficient enough?
14:12:51 <araujo> What's the problem with lists?
14:14:07 <TheHunter> > let xs = replicate 1000000 =<< "abcd" in (length xs, length (lines xs), length (words xs))
14:14:11 <lambdabot> (4000000,1,1)
14:14:29 <TheHunter> > let xs = replicate 10000000 =<< "abcd \n" in (length xs, length (lines xs), length (words xs))
14:14:34 <lambdabot> Terminated
14:14:49 <Heffalump> get a better compiler ;-)
14:45:46 <JohnMeacham> _write_ a better compiler.
14:46:05 <tromp> _be_ a better compiler:)
14:48:13 <Heffalump> JohnMeacham: ok, there's a nice challenge for jhc :-)
14:48:15 <boegel|home> _invent_ a better compiler ?
14:49:18 <_SamB_> hmm. parsing C-- is tricky.
14:50:32 <Igloo> It would be a pretty scary compiler that managed to do that optimisation
14:50:50 <SamB> which optimization?
14:51:08 <Igloo> count characters, words and lines in constant space
14:51:20 <Igloo> From the obvious naive definition
14:52:43 <Heffalump> what's the definition of words?
14:52:51 <Heffalump> or lines
14:53:33 <Heffalump> I don't think it's that hard.
14:53:54 <monochrom> Need a parallelizing compiler.
14:54:01 <Heffalump> first of all length . words gets turned into something that counts the breaks
14:54:07 <Heffalump> then tuple the whole lot
14:54:34 <SamB> Heffalump: expressing the problem to the compiler in a way that would allow the compiler to optimize it to shootout standards is probably not possible
14:55:06 <Heffalump> what's wrong with the specification I gave?
14:55:45 <Igloo> You need to either work out they'll all be needed or that they all fail to terminate in the same cases
14:56:34 <monochrom> In effect you are looking at the difference between Parsec and ReadP.  Parsec is coded to be sequential: in some cases it holds a reference to the beginning of the input list, thus slurping the whole list into memory.  ReadP is coded to interleave: it loses the reference to the beginning.
14:56:36 <Igloo> It's not as bad as it could be due to length's constrained type
14:56:46 <Igloo> I still think it would be scary, anyway  :-)
14:56:54 <Igloo> It clearly is /possible/
14:57:35 <Heffalump> I think it's somewhat beyond MAG.
14:57:39 <Heffalump> But not completely beyond it.
14:58:09 <Igloo> Doesn't mag stick its head in the sand re strictness?
14:58:28 <Heffalump> that's a minor technical detail ;-)
14:58:46 <Heffalump> but strictness analysis isn't the problem
14:59:00 <Heffalump> you can imagine implementing something that did it
14:59:18 <Heffalump> as you say, showing that they have equivalent strictnesses is hard
15:01:22 <tromp> it wld have to recognize that all 3 uses are low-cost operations
15:02:01 <tromp> so that they're worth doing, even if not needed, for the sake of saving memory
15:02:42 <Lemmih> tromp: The compiler is not allowed to change the strictness of the code.
15:02:54 <Heffalump> is (foldr f e xs, foldr f' e' xs) => foldr (\x (a,b) -> (f a, f' b)) (e,e') xs
15:02:58 <Heffalump> always a valid transformation?
15:03:05 <Heffalump> (strictness-preserving)
15:03:31 <Igloo> Presumably you mean with appropriate seq's?
15:04:06 <Heffalump> I didn't, no.
15:04:22 <Heffalump> why do I need appropriate seqs?
15:05:21 <tromp> you meant (f a x, f' b x)
15:05:27 <Heffalump> yes, I did mean that.
15:05:28 <Igloo> Oh, it isn't anyway as the RHS will force the spine
15:05:38 <Heffalump> what isn't?
15:05:41 <Igloo> YM (f x a, f' x b)
15:05:47 <Heffalump> whatever :-)
15:05:52 <Igloo> The above transformation isn't valid
15:05:52 <Heffalump> you all know what I mean.
15:05:55 <Heffalump> because?
15:06:08 <Heffalump> oh, I see.
15:06:10 <Heffalump> sorry.
15:06:12 <Heffalump> bah.
15:06:27 <Heffalump> ok, assuming good strictness analysis, we can do it.
15:07:36 <tromp> if you make (a,b) irrefutable, the spine isn't forced
15:13:08 <syntaxfree> yo! holla!
15:53:58 <dcoutts> xerox, still awake?
15:54:52 <vincenz> Holy crap
15:55:00 <vincenz> ghc is the second biggest package on my system
15:55:01 <vincenz> at 82MB
15:58:06 <vincenz> time to build my first simple haskellprograms :)
15:58:11 <vincenz> suggestions?
15:58:18 <dcoutts> hello world!
15:58:32 <vincenz> prtStrLn "hello world!"
15:58:47 <vincenz> I meant something slightly more involved than that
15:58:57 <vincenz> requiring me to do some thinking ini how to solve it the "haskell way(TM)"
16:01:45 <tromp> a sudoku generator?
16:02:14 <vincenz> are there algos out there to generate a sudoku that's solveable?
16:02:25 <tromp> obvisouly
16:02:45 <dcoutts> or easier would be to write a sudoku solver
16:02:52 <dcoutts> the generator is harder I think
16:02:54 <tromp> Cale did that alrd
16:03:15 <vincenz> I already did a sudoku solver in ruby that was more elegant than a full search space traversal
16:03:20 <tromp> heck, therre's a 3 line solver in perl:)
16:03:55 <Heffalump> I assume Simon Tatham's puzzle collection will have a generator.
16:04:13 <tromp> i got a generator here as a widget
16:12:27 <vincenz> so no suggestions?
16:14:53 <tromp> a go program:)
16:15:38 <vincenz> :)
16:16:39 <tromp> a surreal number calculator
16:17:15 <vincenz> what's a surreal number
16:17:42 <tromp> it's {L|R} where L and R are sets of surreal numbers
16:17:54 <vincenz> I'm afraid that syntax is not familiar to me
16:18:06 <tromp> it wouldn't
16:18:11 <vincenz> so what does that mean
16:18:14 <vincenz> {L|R}
16:18:17 <tromp> just invented for surreal numbers
16:18:21 <vincenz> but what does it mean
16:18:43 <tromp> it denotes the simplest number that's between the Left and Right set
16:19:08 <tromp> then there are definitions for comparing them, adding them etc
16:19:21 * vincenz needs something tangible to grok this
16:19:36 <vincenz> {L|R} is a surreal number
16:19:38 <vincenz> and so is L and R
16:19:45 <vincenz> basically you have a recurisve definition
16:19:46 <tromp> no, L and R are sets
16:19:58 <vincenz> and {L|R} is a set and not a number
16:20:06 <tromp> the simplest surreal number is {|}
16:20:12 <tromp> where both sets are empty
16:20:15 <vincenz> right
16:20:22 <vincenz> and what would {{|}|{|}} mean
16:20:24 <tromp> that happens to be 0 :)
16:20:47 <vincenz> so hw do you get anything BESIDEs 0
16:20:56 <tromp> that's {{0}|{0}} which is called *
16:21:05 <vincenz> oh right
16:21:07 <vincenz> forgot the xtra {}
16:21:08 <tromp> you get all the integers
16:21:09 <vincenz> they're stes
16:21:11 <vincenz> sets eve
16:21:11 <tromp> all fractions
16:21:18 <tromp> all kinds of infinities
16:21:25 <tromp> and infintely small numbers
16:21:27 <tromp> and reals
16:21:28 <vincenz> I only know two
16:21:30 <vincenz> -inf and inf
16:21:33 <tromp> and lots more
16:21:43 <tromp> well, there's inf+1
16:21:51 <vincenz> well one could argue that inf and -inf are the same
16:21:52 <tromp> and 2*inf
16:21:54 <vincenz> in real numbers
16:21:55 <tromp> and inf^2
16:21:57 <vincenz> so
16:21:57 <vincenz> hmm
16:21:59 <vincenz> wait
16:22:01 <vincenz> how do I get 1?
16:22:01 <SamB> how does operator precedence work in C--
16:22:03 <SamB> ?
16:22:16 <vincenz> SamB: C--?
16:22:18 <tromp> 1 = {0|}
16:22:22 <SamB> yeah, C--.
16:22:30 <SamB> I'm hoping the answer is "there isn't any"
16:22:32 <tromp> -1 = {|0}
16:22:35 <vincenz> tromp: yeamn {{0}|}
16:22:44 <vincenz> SamB: that's a lang?
16:22:55 <vincenz> s/yeamn/you mean/
16:22:57 <tromp> yeah, but it's customary not to write the braces of the L and R sets
16:23:02 <vincenz> ah
16:23:19 <tromp> so you can write {-2,-4|1,5}
16:23:26 <vincenz> which means
16:23:32 <tromp> oh, that's 0 again
16:23:36 <vincenz> ??
16:23:41 <vincenz> what's the rule
16:23:44 <vincenz> L+R?
16:23:45 <tromp> Knuth wrote a lovely little novel about it
16:23:53 <vincenz> free pdf somewhere?
16:23:58 <tromp> called Surreal Numbers
16:24:03 <tromp> not free
16:24:06 <vincenz> tromp: still not grokking it
16:24:10 <tromp> try amazon:)
16:24:41 <tromp> i can't possibly explain it well here
16:24:48 <vincenz> tromp: but hmm
16:24:53 <vincenz> {0|} can also be infinity
16:25:03 <vincenz> if I grok wikipedia
16:25:12 <tromp> no, it's definately 1
16:25:14 <vincenz> basically any number > 0
16:25:18 <vincenz> and smaller than no number
16:25:28 <tromp> to get infinite you need {0,1,2,... | }
16:25:42 <vincenz> The informal interpretation of a pair { L | {} } will be "a number higher than any number in L", and of { {} | R } "a number lower than any number in R". This leads to the following construction rule:
16:26:04 <tromp> but not any number; it denotes the simplest one
16:26:18 <tromp> 1 is simpler than inf
16:26:24 <vincenz> oh you define 1 to be that
16:26:30 <vincenz> it's not just set operations on the underlying numbers
16:26:41 <syntaxfree> joy-like people may be boy-like.
16:26:41 <vincenz> so how do you get 1/2
16:26:54 <tromp> 1/2 = {0|1}
16:27:03 <vincenz> always take the middle?
16:27:07 <tromp> the simplest number between 0 and 1
16:27:09 <tromp> no
16:27:21 <vincenz> {0,1|2} == ?
16:27:34 <tromp> 1.5
16:27:44 <vincenz> so {0,1|2} == {1|2}
16:27:53 <vincenz> or otherwise set
16:27:58 <pesco> Why is 1.5 simpler than say 1.3?
16:28:04 <tromp> yes, you can ignore smaller numbers in L
16:28:08 <tromp> and larger ones in R
16:28:10 <vincenz> {A|B} where A and B are sets == {max(A)|min(B)}
16:28:26 <tromp> you cannot always take max A
16:28:30 <glasser> knuth? I thought it was conway
16:28:30 <vincenz> well
16:28:32 <tromp> some elements are incomparable
16:28:34 <vincenz> given that A and B are sets of real numbers
16:28:34 <tromp> like 0 and *
16:28:42 <glasser> Oh, I guess I'm wrong
16:28:43 <tromp> there not real
16:28:46 <tromp> 'they're
16:28:51 <vincenz> "given that..."
16:28:53 <tromp> it's a much richer class
16:28:58 <tromp> * is no real number
16:29:02 * vincenz repeats himself
16:29:06 <vincenz> given that A and B are stes of real numbers
16:29:06 <tromp> it's surreal
16:29:14 <vincenz> {A|B} == {max(A)|min(B)}
16:29:14 <tromp> yes, in that case
16:29:19 <vincenz> oki
16:29:25 <vincenz> a nice degenerate case :)
16:29:32 <vincenz> and of coursegiven that
16:29:34 <vincenz> A and B have bounsd
16:29:49 <vincenz> or more genreally
16:29:52 <vincenz> if it can
16:30:01 <tromp> it's the rules for comparison and addition that tell you why {|} is 0
16:30:08 <vincenz> {A|B} == {LUB(A)| GLB(B)}
16:30:09 <tromp> and {0|} is 1
16:30:31 <tromp> bedtime here...
16:30:36 <vincenz> {{x | x < 1} | {x | x >2}} == 1.5
16:30:52 <tromp> that's false
16:31:01 <vincenz> so can't work with LUB and GLB?
16:31:10 <tromp> {0.999|2.01} = 1
16:31:24 <vincenz> odd
16:31:31 <vincenz> so there's a partial order on numbers
16:31:33 <vincenz> "simple"
16:31:50 <vincenz> 1 being simpler than any other real number in [0.999, 2.01]
16:31:57 <tromp> yes, basically how deep the definition is
16:32:01 <vincenz> ouch
16:32:38 <tromp> g'night...
16:33:20 <mwc> Does anybody know of some well documented example State monad code?
16:33:45 <vincenz> tromp_: night
16:36:07 <Philippa> mwc: as in, does something useful with the State?
16:36:21 <Philippa> I tend to see smallish snippets using it, usually because that way they stay small...
16:38:46 <syntaxfree> PHP.
16:40:23 <dons> why do people want to implement more python/perl/ruby languages? sigh.
16:41:15 <monochrom> They do?
16:43:12 <syntaxfree> isn't there a quotation to the effect that Java brought C programmers a little closer to Lisp?
16:43:36 <dons> :) pugs bought C programmers a bit closer to haskell
16:43:37 <syntaxfree> Python/Ruby are compromises in the direction of Good Languages, away from C/Bash/etfc.
16:43:54 <syntaxfree> I'm having to write stuff in PHP.
16:44:13 <syntaxfree> God knows I wish I could write in Python.
16:44:13 <dons> poor syntaxfree
16:45:39 <syntaxfree> it's mostly simple XML parser stuff.
16:45:53 <Philippa> I don't think bash is a bad language, FWIW
16:45:59 <Philippa> it's rather nice for what it's for
16:46:03 <syntaxfree> Not even writing the parser, just doing some parsing.
16:46:22 * Philippa was rather amused that kludging up a shoutcast player was a one-liner given an mp3 player and wget, for example
16:46:27 <syntaxfree> Ya know, Web 2.0 nudge nudge knowwhatImean?
16:46:44 <Philippa> free silly money?
16:46:57 <Philippa> me, I'm just waiting for the bubble to burst so I can point and laugh again
16:47:01 <syntaxfree> Philippa: well, but then that's really a result of Unix pipes, not of Bash.
16:47:33 <syntaxfree> the same can be accomplished in, say, csh.
16:47:57 <dons> yeah, lazy IO is really cool ;)
16:48:05 <syntaxfree> http://www.alistapart.com/articles/web3point0
16:49:22 <Philippa> syntaxfree: sure. A retarded dog could figure out how to use bash from the man page though
16:49:32 <Philippa> I mean, I'd even let my boyfriend loose with it and no further docs
16:49:57 <syntaxfree> Philippa: the same could be said about very basic Haskell.
16:50:56 <Philippa> yeah. Just not quite Haskell that does IO. And I know, because I've tried to teach him it
16:51:34 <syntaxfree> well, I'd be more comfortable leaving an unknowledgeable unknowing person on ghci than on bash.
16:51:49 <Philippa> well yes, any time they can't do any harm is good
16:51:53 <Philippa> but assuming they have to do IO?
16:52:01 <Philippa> well yeah, IKWYM, but hey
16:52:02 <syntaxfree> simple IO is easy with Haskell too. You just have to skip the monads stuff and tell them to use do, print and x<-getLine
16:52:21 <Philippa> trust me, I've been teaching this stuff a while :-)
16:52:27 <syntaxfree> "This stuff inside the do block is imperative, and hence has diff'rent syntax".
16:52:42 <Philippa> which then leads to "what's this weird type error?" when they forget to use return
16:52:57 <syntaxfree> most simple IO won't require return.
16:53:04 <syntaxfree> They just want to prettily print their results.
16:53:28 <Philippa> that's a big assumption about how someone codes there
16:53:44 <Philippa> a lot of the people I know would end up in a situation that wants return pretty quickly
16:55:10 <syntaxfree> is that situation more easily fixed with Bash?
16:56:34 <Philippa> IIRC (it's been a while), yes
16:59:08 <dons> musasabi, the `recursive' problem spec changed, here's an amended entry: http://www.haskell.org/hawiki/RecursiveEntry
16:59:09 <syntaxfree> well, then it is.
16:59:25 <syntaxfree> In one of my classes they're using Maple.
16:59:29 <syntaxfree> It's so confusing.
16:59:54 <syntaxfree> x:=eigenvalues(matrix)  returns a vector with the eigenvalues of a matrix.
17:00:19 <syntaxfree> x:=eigenvalues(matrix,vec) returns the eigenvalues, and sets an array of vectors named "vec" with the eigenvectors.
17:00:39 <syntaxfree> That's side effects gone bloody rotten.
17:01:43 <dons> horrible
17:01:44 <vincenz> odd
17:01:56 <vincenz> I get compilation without do errors
17:02:04 <vincenz> main::IO()
17:02:07 <vincenz> main = do
17:02:09 <dons> and that is supposed to be math ;)
17:02:13 <vincenz>     putStr $ show $ "hello"
17:02:23 <vincenz> no return ()
17:02:25 <vincenz> and it works fine
17:02:37 <vincenz> @type putStr
17:02:38 <lambdabot> String -> IO ()
17:02:39 <vincenz> do
17:02:42 <dons> sure, putStr has type ... -> IO ()
17:02:47 <vincenz> so I don't even need do?
17:03:00 <dons> nope.
17:03:04 <vincenz> what does the do do in this case
17:03:05 <dons> main = putStr "foo"   -- is ok
17:03:14 <dons> nothing
17:03:19 <vincenz> (the show is a remnant of a long program)
17:03:36 <dons> also, putStr . show == print (almost)
17:04:10 <vincenz> ah coolies
17:04:12 <vincenz> @type print
17:04:13 <lambdabot> forall a. (Show a) => a -> IO ()
17:04:15 <dons> main = do a <- x ; b <- y ; return b  ==>  main = x >>= \a -> y >>= \b -> return b
17:04:28 <dons> @type (>>=)
17:04:29 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
17:04:33 <vincenz> so for a single liner?
17:04:47 <dons> do is just syntax sugar for plugging together computations with >>= and >>
17:04:50 <vincenz> yeah I know
17:04:56 <vincenz> just not fully wrapping my head arond it yet
17:05:07 * vincenz needs a simple program to code and test out his haskellfu
17:06:03 <glasser> so if there's only one computation, it's extraneous
17:06:52 <dons> yeah, it doesn't desugar to anything, it's thrown away
17:09:03 <vincenz> thx
17:16:03 <musasabi> dons: why do we need the signatures, aren't those the exact same as inferred?
17:16:56 <musasabi> dons: I can see fib needing the signature, but the other ones?
17:17:36 <vincenz> heh
17:18:57 <dons> hmm, I think it inferrred some more general signatures. i.e. a  -> a -> a1 (which is why Isaac tweaked the spec, I think). 
17:20:00 <vincenz> Anyone have a laptop/linux and a touchpad
17:20:02 <musasabi> @type (let tak x y z = if y >= x then z else tak (tak (x-1) y z) (tak (y-1) z x) (tak (z-1) x y) in tak)
17:20:03 <lambdabot> forall a. (Ord a, Num a) => a -> a -> a -> a
17:20:48 <musasabi> for fib the signature is needed I think
17:23:41 <dons> ah, just fib. yes.
17:23:52 <dons> fib :: (Num a, Ord a) => a -> a
17:24:01 <dons> fib n = if n < 2 then 1 else fib (n-2) + fib (n-1)
17:24:29 <dons> (Note the C guys picked up some more points, another 3. it's hard to keep up)
17:25:18 <dons> on my box, -fexcess-precision is an almost 40% gain improvement . quite amazing
17:25:30 <musasabi> yes, that is double store.
17:25:41 <musasabi> I have it on in many benchmarks
17:26:00 <dons> ah, good.
17:28:31 <ihope> Now I can freak everybody out with double clienting!
17:28:50 <dons> so, any chance to submit the non-leaking knuc entry (the "Proposed entry" on the wiki?) Chris has given it his ok.
17:31:17 <ihope> @djinn ContT r m a -> Cont (m r) a
17:31:17 <lambdabot> -- f cannot be realized.
17:31:24 <ihope> Bleh.
17:31:38 <musasabi> dons: committed knucleotide.
17:32:03 <vincenz> @type portNumber
17:32:05 <lambdabot> Not in scope: `portNumber'
17:32:07 <ihope> @type Control.Monad.Cont.Cont . Control.Monad.Cont.runContT
17:32:08 <lambdabot> forall r (m :: * -> *) a.
17:32:08 <lambdabot> Control.Monad.Cont.ContT r m a -> Control.Monad.Cont.Cont (m r) a
17:32:12 <vincenz> @type Network.portNumber
17:32:13 <lambdabot> Not in scope: `Network.portNumber'
17:32:36 <vincenz> @index PortNumber
17:32:37 <lambdabot> Network, Network.Socket, Network.BSD, Network
17:35:01 <dons> musasabi, and the other two outstanding things are the shorter sum-file and harmonic on the wiki
17:36:17 <dons>  hmm, so with the fixed recursive we get to around 100, and I wonder now, with a better knuc, maybe we can pick up enough... fingers crossed :)
17:36:54 <musasabi> dons: isn't harmonic updated?
17:37:06 <musasabi> harmonic.ghc and the wiki look like the same thing.
17:37:22 <dons> ah, maybe. let me check. is it the non-unboxed version?
17:39:04 <dons> oh, yes. I see. unfortunately it runs marginally slower. ok. 
17:39:06 <musasabi> http://cvs.alioth.debian.org/cgi-bin/cvsweb.cgi/shootout/bench/harmonic/harmonic.ghc?rev=1.6&content-type=text/x-cvsweb-markup&cvsroot=shootout
17:39:47 <musasabi> well it is the "Proposed entry", and much more pretty than the unboxed one.
17:39:54 <dons> the size of 'N' for harmnonic should probably be increased.
17:42:04 <dons> ok, so `recursive' is comitted?  
17:45:03 <dons> if so, then only Lemmih's sum-file is not yet committed.
17:48:33 <musasabi> recursive is committed.
17:51:02 <dons> now, barring any new benchmarks, we basically have to improve the libraries to get any further.
17:51:42 <SamB> hoorjay!
17:52:02 * SamB waits for better libraries to arrive
17:52:09 <SamB> ...
17:52:14 <SamB> ...
17:52:21 * SamB is very, very impatient!
17:52:29 <SamB> ...
17:52:37 <SamB> ...
17:53:00 <musasabi> dons: committed.
17:53:54 <dons> a high-perf regex lib, and the grand unified packed string lib are on the todo list for 6.6
17:54:10 <dons> and we have a better hashtable on its way
17:54:48 <musasabi> those are very good for non-shootout purposes too :-)
17:56:07 <SamB> it would be silly to waste time writing libs *just* for the shootout, you know!
17:57:31 <wchogg> I have a type inference question.  Why does the list [(+),(-),(*)] have the inferred type [Integer->Integer] in Hugs?
17:57:43 <musasabi> SamB: as opposed to writing inlined IO into the entries directly?
17:58:19 <wchogg> Sorry, I meant [Integer->Integer->Integer]
17:58:46 <musasabi> wchogg: defaulting.
17:59:35 <musasabi> wchogg: what do you think should be the type?
17:59:37 <wchogg> So it chooses the simplest type it can?  Is that why it's not Num a => [a->a->a]?
18:01:21 <musasabi> wouldn't that be (forall a. Num a. a -> a -> a) for each of the three functions and then they would fail to unify.
18:02:21 <Igloo> The above list does have type [(+),(-),(*)], but Haskell defaults numerical types because of things like typing 5 at the hugs prompt or a program saying x^2
18:02:36 <Igloo> If you say :t [(+),(-),(*)] it'll give you the type you expect
18:03:11 <dons> inlined IO gets more bad press than it deserves ;)
18:03:42 <shapr> Wow, Haskell is faster than C and only slightly slower than Fortran for the harmonic benchmark.
18:04:28 <wchogg> Igloo-I'm not sure if I understand why it gives the [Integer->Integer->Integer] type if I load a file, but it gives the most general type if I type it at the prompt.
18:05:15 <Igloo> Because defaulting has happened during typing while loading the file
18:06:09 <wchogg> And defaulting is just choosing the simplest type allowed in the program?
18:06:18 <jethr0> shapr: where are those benchmarks (url)?
18:06:31 <shapr> http://shootout.alioth.debian.org/benchmark.php?test=all&lang=all
18:06:38 <musasabi> dons: badness = length . filter ('#'==)
18:06:41 <Igloo> By default, it takes the first of Integer, Int, Double, Float (IIRC) that satisfies the constraints
18:06:42 <SamB> musasabi: no, I mean as opposed to libs that *happened* to be good for shootout entries but that you could use for other things too
18:07:08 <jethr0> thx
18:07:14 <wchogg> Ah, that makes sense now thanks.
18:07:41 <SamB> musasabi: that sounds like a simplistic if effective metric
18:08:23 <SamB> for instance, not every bad thing involves a #
18:09:00 <musasabi> SamB: but they might be implemented in terms of #
18:10:09 <dons> @shootout in fact, shapr :)
18:10:10 <lambdabot> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=
18:10:10 <lambdabot> all
18:10:11 <SamB> musasabi: well, that doesn't come up in length . filter (=='#')
18:10:34 <jethr0> damn, ghc is getting close to g++ on many benchmarks. i'm impressed!
18:11:17 <syntaxfree> ghc is teh ghc.
18:12:18 <dons> hmm, on memory and cputime alone, ghc already beats g++
18:12:51 <jethr0> haskell markup seems to be broken for single quotes, but i guess you realized already :)
18:13:06 * jethr0 is still impressed :)
18:15:15 <dons> let it never be said that haskell is slow or memory hungry
18:15:35 <wchogg> I'm still amazed at how much the benchmarks have changed in a month.
18:16:04 <Philippa> do we have a case of haskell faster than C on a platform where GHC compiles via C and doesn't screw with the output yet?
18:16:43 <jethr0> wouldn't that just be a blatant case of slow c benchmarking code? :)
18:17:08 <Philippa> well duh :-) Though perhaps also one of superior expressiveness of haskell
18:17:10 <shapr> Or a blatant case of abstraction benefits.
18:17:38 <dons> the concurrency or binary tree benchmarks?
18:17:47 <jethr0> someone could put the haskell intermediate c code up as the c benchmark *g*
18:18:10 <musasabi> yes, 30000 lines of C? ;)
18:18:15 * shapr snickers
18:18:39 <Philippa> dons: ooh, that'd figure
18:18:48 <shapr> Is there a haskellwiki QuotesPage yet?
18:19:05 <Philippa> if not, copy over the existing one?
18:19:18 <Philippa> or don't you want it to include me talking kink? :-)
18:20:09 <dons> mmm python perl and ruby are really bad on cpu and space :) they're in fact they're possibly the bottom 3 considering how many benchmarks they implement
18:20:17 <shapr> I'd like to reformat QuotesPage into a fortune file, and include a sed script to cut off the wiki bits.
18:20:45 <Philippa> dons: that figures
18:20:49 * jethr0 found ruby to be generally not as fast as python.
18:21:02 <shapr> Then @quote could use the fortune format as well and sync lambdabot and the QuotesPage.
18:22:29 <vincenz> re
18:22:39 <shapr> So, Philippa, jethr0, dons, and musasabi, do I have your permission to submit a quote to the haskellwiki?
18:23:00 <Philippa> heh
18:23:11 <Philippa> a new one, or just copying my existing ones? (yes)
18:23:22 <jethr0> :)
18:23:33 * shapr wonders about licensing of quotes..
18:24:14 <Philippa> "fair use, don't need no stinkin' license"
18:24:21 <jethr0> why isn't wiki migration not automated. there are some moinmoin to mediawiki conversion scripts out there...
18:24:31 <Philippa> really, that's one of the few cases it actually is intended to cover
18:24:38 <Philippa> jethr0: licensing issues
18:24:38 <shapr> jethr0: licensing
18:25:41 <jethr0> ah, but wouldn't getting permission from the authors be easier than letting them port pages one-by-one and most likely without good conversion scripts?
18:25:41 <dons> hehe, if you google for 'haskell language shootout' you now get "Haskell #1 in the Shootout" instead of "abysmal Language Shootout results" :D
18:25:52 <jethr0> *yeah*
18:25:52 <shapr> yay!
18:26:13 * dons feels the wheels of the PR machine tunring
18:26:33 <vincenz> @type getContents
18:26:34 <lambdabot> IO String
18:27:23 <dons> oh, and a msg on the erlang list " the overall statistics the Haskell GHC results appear awesome" hehe 
18:27:50 <vincenz> how's this for my first proggy
18:27:52 <vincenz> main :: IO ()
18:27:52 <vincenz> main = do
18:27:52 <vincenz>   contents <- getContents
18:27:52 <vincenz>   putStr contents
18:27:54 <vincenz> 	
18:28:09 <dons> main = getContents >>= putStr   ?
18:28:10 <dons> :)
18:28:24 <vincenz> how do I get the arguments?
18:29:08 <dons> which arguments? the command line ones?
18:29:11 * shapr kicks mediawiki
18:29:19 <vincenz> dons: yeah
18:29:24 <dons> getArgs
18:29:27 <dons> import System
18:29:27 <vincenz> :)
18:30:33 <vincenz> @type liftM
18:30:34 <lambdabot> Not in scope: `liftM'
18:30:38 <vincenz> @type lift
18:30:39 <lambdabot> Not in scope: `lift'
18:30:41 <vincenz> @index lift
18:30:42 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.
18:30:42 <lambdabot> Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error,
18:30:42 <lambdabot> Control.Monad.List, Language.Haskell.TH.Syntax, Text.ParserCombinators.
18:30:42 <lambdabot> ReadPrec, Text.Read
18:30:46 <vincenz> @type Control.liftM
18:30:47 <lambdabot> Couldn't find qualified module.
18:30:47 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
18:30:47 <lambdabot> \\)?
18:30:52 <vincenz> @type Control.lift
18:30:53 <lambdabot> Couldn't find qualified module.
18:30:53 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
18:30:53 <lambdabot> \\)?
18:31:46 <vincenz> hmm
18:31:55 <vincenz> getArgs: IO [String]
18:31:59 <vincenz> how do I do something with each string
18:32:17 <vincenz> @type unlift map
18:32:19 <lambdabot> Not in scope: `unlift'
18:32:23 <dons> import System ; main = do args <- getArgs ; print $ map reverse args
18:32:29 <vincenz> ah
18:32:32 <vincenz> close
18:33:26 <vincenz> hmm
18:33:31 <vincenz> seems my idea of multiple dos ain't that grea
18:33:40 <vincenz> I mean [] is a Monad right
18:35:47 <vincenz> @type sequence
18:35:48 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
18:36:58 <vincenz>   sequence $ map print args
18:37:24 <vincenz> IO [()]
18:37:31 <vincenz> @type sequence_
18:37:32 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
18:37:47 <SamB> mapM
18:37:51 <vincenz> @type mapM
18:37:53 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
18:38:17 <SamB> @type mapM print
18:38:18 <lambdabot> forall a. (Show a) => [a] -> IO [()]
18:38:25 <vincenz> yip
18:38:30 <vincenz> same as sequence $ map print
18:38:35 <vincenz> @type sequence $ map print
18:38:37 <lambdabot>   Expecting a function type, but found `a'
18:38:37 <lambdabot>   Expected type: [m a]
18:38:49 <dons> if you're throwing away the result, mapM_ is much faster. ghc does magic there
18:38:53 <vincenz> @type \l -> sequence $ map print l
18:38:55 <lambdabot> forall a. (Show a) => [a] -> IO [()]
18:39:01 <vincenz> dons: using sequence_
18:39:17 <vincenz> @type mapM_
18:39:18 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> [a] -> m ()
18:39:32 <vincenz> @type sequence_
18:39:33 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
18:39:45 <vincenz> sequence_ $ map == mapM_ ?
18:40:28 <dons> mapM_ f as      =  sequence_ (map f as)
18:40:34 <dons> (from the src)
18:40:41 <vincenz> :)
18:40:45 <vincenz> \o/
18:41:28 <glasser> so I'm playing around with a reimplementation of the tic-tac-toe engine from Hughes' "why functional programming matters"
18:42:10 <glasser> and I really like how in the paper, board state objects print out as multiline grids that look like the board
18:42:20 <vincenz> ooh
18:42:31 <sethk> hmm., when I use \x0d in a string, the error message for that line prints \r.  which is correct, but odd.
18:42:31 * vincenz tries implementing that
18:42:38 <glasser> what I want is to be able to see lists of board states, printed out like that
18:42:48 <dons> > '\x0d'
18:42:49 <vincenz> glasser: what does the board state look like
18:42:49 <lambdabot> '\r'
18:42:50 <glasser> (like he does in his paper, which isn't really haskell)
18:42:54 <glasser> | | 
18:42:54 <glasser> -+-+-
18:42:54 <glasser> | | 
18:42:55 <glasser> -+-+-
18:42:55 <glasser> | | 
18:42:57 <glasser> er,
18:42:59 <vincenz> glasser: the state 
18:43:00 <SamB> glasser: not too hard
18:43:01 <vincenz> aka haskell
18:43:15 <glasser>   |   | 
18:43:15 <glasser> -+-+-
18:43:15 <glasser>   |   | 
18:43:16 <glasser> -+-+-
18:43:16 <glasser>   |   | 
18:43:18 <vincenz> glasser: NONO
18:43:20 <glasser> you get the point
18:43:20 <SamB> @type showList
18:43:21 <lambdabot> forall a. (Show a) => [a] -> ShowS
18:43:22 <vincenz> glasser: the STATE not the repr
18:43:41 <glasser> SamB: hmm, how's that?
18:43:54 <vincenz> glasser: how do you encode the state
18:43:59 <SamB> glasser: you have to implement showList to work the way you want, I guess.
18:44:04 <glasser> ah...
18:44:07 <SamB> or you could use pretty printing instead ;-)
18:44:07 <glasser> that's cool
18:44:29 <vincenz> glasser: what does the board state look like internally
18:44:40 <glasser> the next question is, has anyone done for me a "showList for variable-height lists" implementation or do I have to deal myself?
18:44:57 <SamB> glasser: you know how when you do this
18:45:00 <glasser> vincenz: doesn't specify in paper, I guess I'd do something like a record with nine fields
18:45:09 <vincenz> hmm
18:45:13 <SamB> > ['a'..'z'] -- you get this:
18:45:14 <lambdabot> "abcdefghijklmnopqrstuvwxyz"
18:45:23 <glasser> ah, that's how that works?
18:45:31 <glasser> neat, I thought it was some terribly hardcoded thing
18:45:42 <SamB> glasser: yup!
18:46:10 <SamB> the instance for Show Char overrides the default implementation of showList to show strings as, well, strings
18:46:24 <vincenz> > showList [1]
18:46:25 <lambdabot>  add an instance declaration for (Show (String -> String))
18:46:28 <glasser> But I still get to write my own showList to actually put them together?
18:46:32 <vincenz> > showList [1] ""
18:46:34 <lambdabot> "[1]"
18:46:49 <vincenz> glasser: start with the internals: board state repr
18:47:00 <glasser> > showList [1] "x"
18:47:02 <lambdabot> "[1]x"
18:47:08 <SamB> why would we horribly hardcode things when we have people like Oleg?
18:47:11 <vincenz> shouldn't that be showsList
18:47:16 <vincenz> SamB: Oleg?
18:47:43 <SamB> not to say that Oleg is responsible for this, but it is obviusly within his abilities ;-)
18:47:49 <vincenz> who is oleg
18:47:52 <SamB> Oleg the type-programmer?
18:48:20 <vincenz> data Board = [Field]
18:48:27 <vincenz> gives me an error on that
18:48:33 <SamB> ask a question about performing computations in the type system sometime ;-)
18:48:40 <SamB> on a mailing list, that is
18:48:45 <glasser> Hmm, how much will Text.PrettyPrint make me happy?
18:48:50 <SamB> Oleg will probably reply at some point ;-)
18:48:59 <glasser> vincenz: right, you need constructors for a data declaration
18:49:01 <vincenz> SamB: he got a site
18:49:04 <SamB> glasser: not sure
18:49:05 <glasser> either do: type Board = [Field]
18:49:11 <vincenz> glasser: ah, thx
18:49:22 <glasser> or data Board = Board [Field] (where those two Boards don't need to be the same)
18:49:44 <vincenz> okies
18:50:05 <SamB> > unlines ["foo\nbar","baz"]
18:50:06 <lambdabot> "foo\nbar\nbaz\n"
18:50:16 <vincenz> how do you do an instance again
18:50:21 <vincenz> Instance Show (Field)
18:50:23 <SamB> vincenz: has oleg got a site... hmm...
18:50:24 <vincenz> instance Show (Field) where
18:50:44 * SamB googles his mail to find oleg's actual name
18:51:41 <dons> Ooleg Kiselyov
18:51:46 <dons> s/Oo/O/
18:52:44 <sproingie> oobleck
18:53:08 <SamB> huh, he doesn't even put his whole name in his From: fields!
18:53:12 <vincenz> hmm
18:53:23 <vincenz> crapperoli, making a Show is not easy
18:53:24 <vincenz> :/
18:53:29 <vincenz> @type > print
18:53:31 <lambdabot> parse error on input `>'
18:53:34 <vincenz> @type print
18:53:35 <lambdabot> forall a. (Show a) => a -> IO ()
18:53:44 <vincenz> data Field = O | X | Empty
18:53:51 <vincenz> I want it to print it as "O" "X" or " "
18:54:04 <vincenz> so I thought of
18:54:07 <vincenz> instance Show Field where...
18:54:11 <vincenz> but showsPrec ... yick
18:55:13 <SamB> vincenz: showsPrec isn't that bad...
18:55:20 <araujo> @index sleep
18:55:20 <lambdabot> System.Posix.Unistd, System.Posix
18:55:43 <SamB> @hoogle ShowS
18:55:44 <lambdabot> Prelude.ShowS :: String -> String
18:55:44 <lambdabot> Prelude.shows :: Show a => a -> ShowS
18:55:44 <lambdabot> Text.Show.ShowS :: String -> String
18:56:19 <SamB> just ignore the precedence, why don'tcha?
18:56:34 <glasser> Hmm, Text.PrettyPrint is helpful
18:56:39 <vincenz> @type (!!)
18:56:41 <lambdabot> forall a. [a] -> Int -> a
18:56:57 <glasser> How do I find the source of random things in the hierarchical libraries?
18:58:07 <dons> the source?
18:58:13 <glasser> yeah
18:58:14 <dons> what do you mean?
18:58:18 <vincenz> @type show
18:58:20 <lambdabot> forall a. (Show a) => a -> String
18:58:23 <glasser> If they're written in Haskell, their source code
18:58:26 <dons> @index show
18:58:27 <lambdabot> Text.Show, Prelude
18:58:34 <dons> @darcs Text.Show
18:58:35 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Text-Show.html
18:58:42 <dons> @fptools Text.Show
18:58:42 <lambdabot> http://darcs.complete.org/fptools/libraries/base/Text/Show.hs
18:58:50 <dons> like that?
18:58:54 <glasser> Aha, exactly.
18:59:13 <vincenz> mind if I paste?
18:59:41 <vincenz> got something better than: http://rafb.net/paste/results/IbG3RD81.html
19:00:18 <vincenz> (and what is a haskell-syntax aware paste site)
19:00:20 <glasser> Well, the part I'm working on is "how do I display a list of these things"
19:01:38 <glasser> Oh, hmm. No, PrettyPrint isn't going to help me -- it's not really for laying out 2D blocks of code
19:01:44 <glasser> s/ of code//
19:02:15 <vincenz> grr
19:02:33 <vincenz> http://rafb.net/paste/results/345G1s18.html
19:02:36 <vincenz> it complains on the where clause
19:02:47 <vincenz> line 18
19:03:39 <glasser> you don't need two where's in a row
19:03:44 <vincenz> fixed that
19:03:52 <vincenz> now it complains on the (l !! (3*i))
19:03:55 <glasser> but the putStrs should be indented more than printRow, I think
19:03:55 <vincenz> (parenthesized it
19:04:44 <vincenz> http://rafb.net/paste/results/lHjdfb70.html
19:05:59 <vincenz> too bad tuples can't be abstracted away from their size
19:06:19 <glasser> Maybe I'll email the cafe
19:07:55 <vincenz> \o/
19:09:23 <vincenz> @type iterate
19:09:24 <lambdabot> forall a. (a -> a) -> a -> [a]
19:09:33 <vincenz> @type repeat
19:09:34 <lambdabot> forall a. a -> [a]
19:09:38 <vincenz> nope
19:09:44 <vincenz> how do I do something n times
19:10:08 <vincenz> > "+-"*3
19:10:09 <lambdabot>  add an instance declaration for (Num [Char])
19:10:20 <vincenz> that's a flaw
19:11:05 <vincenz> they should have a subclass of Num just having + and *
19:11:26 <vincenz> anyways, how do I do something n times?
19:11:32 <vincenz> like
19:11:38 <vincenz> showString x . showString x ... n times
19:12:40 <vincenz> > foldl (\x -> showString x .) (showString .) ["a", "b"]
19:12:41 <lambdabot>  parse error on input `)'
19:12:45 <vincenz> > foldl (\x -> showString x .) (showString .)) ["a", "b"]
19:12:46 <lambdabot>  parse error on input `)'
19:13:00 <vincenz> > foldl (\x -> showString x .) (showString "-") ["a", "b"]
19:13:01 <lambdabot>  parse error on input `)'
19:13:27 <vincenz> > foldl (.) map showString ["a", "b"]
19:13:28 <lambdabot>   Expecting a function type, but found `[b]'
19:13:28 <lambdabot>   Expected type: [(a -> b) -> a -> b]
19:13:28 <lambdabot>   Inferred type: String -> ShowS
19:13:33 <vincenz> > foldl (.) $ map showString ["a", "b"]
19:13:34 <lambdabot> Couldn't match `b -> c' against `[b1]'
19:13:45 <vincenz> > foldl (.) (showString "c") $ map showString ["a", "b"]
19:13:46 <lambdabot>  add an instance declaration for (Show (String -> String))
19:13:53 <vincenz> > foldl (.) "c" $ map showString ["a", "b"]
19:13:54 <lambdabot> Couldn't match `b -> c' against `[Char]'
19:14:02 <vincenz> @type showString
19:14:04 <lambdabot> String -> ShowS
19:14:14 <vincenz> > showString "a" . showString "b" "c"
19:14:15 <lambdabot>   Expecting a function type, but found `[Char]'
19:14:15 <lambdabot>   Expected type: a -> String
19:14:15 <lambdabot>   Inferred type: String
19:14:42 <dons> vincenz, perhaps experiment in a /msg window?
19:14:45 <vincenz> sorry
19:17:30 * araujo looks around
19:21:45 <vincenz> this is not valid
19:21:57 <vincenz> fold1 (. someop .) [listoffuncs]
19:30:25 <glasser> well, here's a start
19:30:26 <glasser> http://rafb.net/paste/results/lcJajg31.html
19:30:45 <vincenz> this is annoying
19:31:45 <dons> what's the type of someop, vincenz?
19:32:00 <vincenz> getting closer
19:32:03 <vincenz> but my typing is messing up
19:33:17 <vincenz> ShowS : a -> String -> String?
19:38:04 <vincenz> hard to tell when to use $ and when to use .
19:38:22 <vincenz> I had (for a single list of showables)
19:38:31 <vincenz> \l -> interleaveShow "| $ map shows l
19:38:35 <vincenz> then I wanted dual list
19:38:35 <vincenz> so
19:38:42 <Korollary> It's not hard
19:38:44 <Korollary> err
19:38:49 <Korollary> they're so different heh
19:38:50 <vincenz> \l -> interleaveShow "a" $ map (interleaveShow "|" $ map shows) l
19:38:56 <vincenz> but apparently now it has to be a .
19:39:09 <vincenz> (the second one
19:40:30 <vincenz> sure it is
19:40:38 <vincenz> @pl \a -> f $ g $ a
19:40:39 <lambdabot> f . g
19:40:42 <vincenz> not f $ g
19:40:51 <vincenz> still don't get that one
19:41:12 <dons> f $ g == f g
19:41:14 <dons> not f . g
19:41:21 <vincenz> k
19:41:28 <vincenz> woo
19:41:30 <vincenz> generic board printer
19:43:19 <dons> \a -> f $ g $ a => \a -> f $ g a => \a -> f (g a) 
19:44:29 <vincenz> is there a function that does this:
19:44:39 <vincenz> interleaveDo c = foldl1 (\x y -> x . c . y)
19:44:55 <vincenz> or some nice pattern
19:45:56 <dons> sorry, \a -> f $ g a => \a -> f (g a) => \a -> (f . g) a => f . g
19:46:15 <dons> @pl (\x y -> x . c . y)
19:46:16 <lambdabot> (. (c .)) . (.)
19:46:32 <dons> there aren't many nice ways to mess with lists of functions (they're a little unusual)
19:46:40 <vincenz> ok
19:46:45 <vincenz> hmm
19:46:51 <vincenz> quick way to show n "+-" ?
19:46:59 <vincenz> (preferably ending in -> ShowS
19:49:25 <vincenz> \o/
19:49:51 <vincenz> http://rafb.net/paste/results/8nkT6B89.html
19:50:00 <vincenz> comments are welcome
19:51:03 <vincenz> I could prolly take out the interleaveDo (lala) . map b $ x out
19:57:52 <vincenz> @type interleaveFoldMap f g = foldl1 (\x y -> x . f . y) . map g
19:57:53 <lambdabot> parse error on input `='
19:58:01 <vincenz> @type let interleaveFoldMap f g = foldl1 (\x y -> x . f . y) . map g in interleaveFoldMap
19:58:02 <lambdabot> forall c c1 a. (c -> c1) -> (a -> c1 -> c) -> [a] -> c1 -> c
19:58:04 <vincenz> :)
19:59:22 <vincenz> \o/
20:22:13 <SamB> soon enough, the @docs link should have links to source code as well...
20:24:22 <dons> like @fptools does?
20:24:44 <SamB> I mean, that stuff dcoutts has been working on ;-)
20:24:53 <dons> ah. yes  :)
20:25:16 <samx> trying to learn to use error monads here. It seems Either type is an instance of Monad, but I can't seem to find the instance declaration anywhere?
20:25:48 <SamB> which is to say "as soon as the docs are rebuilt with the appropriate haddock/options"
20:26:44 <dons> anyone know what :== does in clean?
20:27:18 <SamB> linear assignment? who knows!
20:27:47 <dons> ah, maybe
20:27:55 <dons> seems like some magic
20:28:25 <SamB> it was the first wierd clean-related thing I could think of that has anything to do with eqauls symbols ;-)
20:28:48 <dons> hehe
20:31:26 <vincenz> samx: how is either a monad?
20:33:13 <samx> vincenz, I'm trying to interpret the example from http://www.nomaware.com/monads/examples/example12.hs    which seems to return Either in a do block
20:33:51 <vincenz> Soad is a good group
20:34:51 <vincenz> samx: where does it return an Eitehr
20:35:06 <samx> "do { n <- parseHex s; toString n }", where parseHex and toString both return Either  (in convert function)
20:36:41 <vincenz> erm
20:36:52 <vincenz> toString returns a ParseMonad Integer
20:36:56 <vincenz> I mean String
20:37:11 <samx> yes, and ParseMonad is a type alias for Either ParseError, if you look up
20:38:09 <vincenz> samx: easy
20:38:13 <vincenz> samx: just consider it like a Maybe
20:38:17 <vincenz> where the Nothing case is more informative :)
20:38:31 <vincenz> fail s = Left s
20:39:06 <vincenz> Left s >>= f = Left s
20:39:14 <samx> yes, but I can't figure out where the instance of the Either monad is defined.. which gets me all confused, as I don't understand how I should be able to figure out that it's a monad, without just 'knowing' it :-)
20:39:16 <vincenz> Right l >>= f = f l
20:39:20 <vincenz> oh!
20:39:28 <vincenz> @index Either
20:39:29 <lambdabot> Data.Either, Prelude
20:40:26 <samx> neither of those two modules have an instance of Either monad, as far as I can tell
20:40:34 <palomer> Either is a monad?
20:40:42 <vincenz> Either Error is a Monad
20:41:59 <palomer> Either is not a Monad, since it has kind *->*->*
20:42:10 <vincenz> Either applied to one thing is a monad
20:42:38 <samx> ok, how would I have been able to figure out that Either Error is a monad then? :-)
20:43:19 <palomer> :i Either Error in ghci
20:45:14 <samx> from the "Error e => MonadError e (Either e)" in Control.Monad.Error, I guess.. one of these days I'll actually start to understand all this.. not today though :-)
20:45:14 <vincenz> samx: it seems logical
20:45:14 <vincenz> they reserve the left for failure
20:45:14 <vincenz> and right for value
20:45:14 <vincenz> then it's just like a Maybe
20:45:14 <vincenz> except with more informative stuff in Nothing
20:45:35 <samx> vincenz, yes.. I don't really have any problems understanding how it works, but just can't grasp how it got to be an instance
20:45:49 <vincenz> ah!
20:45:59 <vincenz> how do I right apply a monad?
20:46:15 <vincenz> like :i Either a Error
20:47:09 <vincenz> how do you import something in the toplevel of ghci
20:47:35 <samx> you don't, you can go to the module context with ":m Control.Monad.Error" though
20:48:07 <vincenz> instance Error e => MonadPlus (Either e)
20:48:07 <vincenz>         -- Imported from Control.Monad.Error
20:48:21 <vincenz> ;)
20:48:29 <vincenz> and you know that MonadPlus a => Monad a
20:49:15 <samx> hmm.. I've been trying to find it from the hierarchial documenation for GHC on the GHC website, and I don't see anything like that there :-)
20:49:34 <vincenz> damn
20:49:35 <vincenz> :i is nic
20:49:40 <vincenz> nice even
20:50:55 <samx> hmm.. seems to be. perhaps I should just forget about browsing the docs and read the source code or use :i instead :-)
20:51:27 <dons> hmm. not to self: `rem` is faster than `mod`  
20:51:55 <vincenz> dons: why
20:52:10 <palomer> > -1 `rem` 3
20:52:11 <lambdabot> -1
20:52:17 <palomer> > -i `mod` 3
20:52:18 <lambdabot>  Not in scope: `i'
20:52:21 <palomer> > -1 `mod` 3
20:52:22 <lambdabot> -1
20:52:28 <vincenz> seems the same ;)
20:52:35 <palomer> > 1 `rem` -3
20:52:37 <lambdabot>   precedence parsing error
20:52:37 <lambdabot>    cannot mix `rem' [infixl 7] and prefix `-' [infixl 6] in the same
20:52:37 <lambdabot> infix expression
20:52:46 <palomer> > 1 `mod` (-3)
20:52:46 <lambdabot> -2
20:52:50 <palomer> > 1 `rem` (-3)
20:52:51 <lambdabot> 1
20:53:03 <samx> vincenz, anyone, I get it now. Thanks for all your help :-)
20:53:10 <samx> s/anyone/anyway/
20:53:59 <vincenz> hmm
20:54:14 <vincenz> interleaveFoldMap f g =
20:54:19 <vincenz> foldl1 (\x y -> x . f . y) . map g
20:54:51 <vincenz> @type show
20:54:52 <lambdabot> forall a. (Show a) => a -> String
20:56:31 <vincenz> still not happy with my board printer
20:56:34 <vincenz> its not generic enough
20:56:51 <vincenz> (it only handles boards with single-character elements
20:57:13 <palomer> nethir rem nor mod correspond to intel's mod instruction
20:57:17 <palomer> netheir
20:57:22 <palomer> neither
20:58:06 <vincenz> > foldl1 (.) [+2,*3,+4] 1
20:58:07 <lambdabot>  parse error on input `+'
20:58:14 <vincenz> > foldl1 (.) [(+2),(*3),(+4)] 1
20:58:15 <lambdabot> 17
20:59:17 <dons> hmm. `rem` instead of `mod` halved the random benchmark time on linux, and about 10% better on openbsd. very interesting
20:59:26 <vincenz> dons: whatcha working on
20:59:29 <dons> (these are calls into libgmp)
20:59:32 <dons> @shootout
20:59:32 <lambdabot> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=
20:59:32 <lambdabot> all
20:59:34 * vincenz would like to get his hands dirty
21:00:14 <vincenz> holy cow
21:00:21 <vincenz> ghc is secodn best
21:01:55 <vincenz> oddly however
21:02:01 <vincenz> ocaml performs better on more cases
21:02:15 <vincenz> I guess it is the really high factors of cheap-concur and chameneous
21:03:07 <dons> concurrency is something haskell is really good at, yes. also, haskell is usually shorter than ocaml.
21:03:25 <fragyspaz> hey whats this langauge for?
21:03:41 <fragyspaz> is it a compiled language or an interpereted?
21:03:48 <vincenz> fragyspaz: compiled 
21:04:00 <dons> writing programs. compiled or interpreted.
21:04:12 <fragyspaz> why is it the choice of hackers?
21:04:26 <shapr> coi fragyspaz .i xu do tavla mi bau la lojban
21:04:28 <vincenz> dons: thats odd
21:04:33 <dons> because that's the title it was awarded when it one the icfp contest.
21:04:43 <vincenz> dons: there's program for nsieve for ocaml but it claims "No Program" for that entry
21:05:43 <fragyspaz> coi shapr, i cant talk lojban yet
21:05:56 <vincenz> dons: about the concurrency one
21:06:07 <vincenz> dons: why is it spawn c _
21:06:15 <vincenz> @type foldM
21:06:16 <lambdabot> Not in scope: `foldM'
21:06:21 <vincenz> @index foldM
21:06:22 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.
21:06:22 <lambdabot> State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont,
21:06:22 <lambdabot> Control.Monad.Error, Control.Monad.List
21:06:28 <vincenz> @type Control.Monad.foldM
21:06:29 <lambdabot> forall a (m :: * -> *) b.
21:06:29 <lambdabot> (Monad m) =>
21:06:29 <lambdabot> (a -> b -> m a) -> a -> [b] -> m a
21:06:32 <vincenz> ah
21:06:43 <vincenz> @type Control.Monad.foldM_
21:06:45 <lambdabot> forall (m :: * -> *) b a.
21:06:45 <lambdabot> (Monad m) =>
21:06:45 <lambdabot> (a -> b -> m a) -> a -> [b] -> m ()
21:07:43 <dons> vincenz?
21:08:55 <vincenz> dons: got it
21:09:58 <vincenz> hmm
21:10:08 <vincenz> main = do {x <- [1,2,3]; print x}
21:10:14 * vincenz scratches his head
21:10:15 <vincenz> that won't compile
21:10:28 <dons> musasabi, an improved `random'. http://www.haskell.org/hawiki/RandomEntry (using `rem` a la Clean will make the cputime much more competitive). Commit away :)
21:12:16 <dons> vincenz, intermixing list and IO monad.
21:12:20 <vincenz> yeah
21:12:23 <vincenz> and this won't work either
21:12:29 <vincenz> main = sequence_ $ do 
21:12:33 <vincenz>   x <- [1,2,3]
21:12:34 <vincenz>    print x
21:12:47 <dons> x <- return [1,2,3]
21:13:03 <dons> not sure what you're trying to do though.
21:13:04 <vincenz> what does that do
21:13:15 <vincenz> dons: print each number
21:13:22 <vincenz> with the do syntax
21:13:30 <dons> mapM_ print [1,2,3]  ;)
21:13:34 <vincenz> nono
21:13:38 <vincenz> I want to use the do syntax
21:13:46 <vincenz> I figured sequence_ should put me in the clear
21:13:51 <dons> you can't just use IO inside the list monad.
21:14:14 <vincenz> hence
21:14:18 <vincenz> sequence_ $ do 
21:14:22 <vincenz>    x <- [1,2,3]
21:14:24 <vincenz>    print x
21:14:29 <dons> use 'show' perhaps, insttead of print, and then print the result
21:14:40 <vincenz> I'm still trying to figure out how this code hsould work
21:14:56 <dons> you're trying to use 'print :: String -> IO ()' in the list monad..
21:15:00 <vincenz> yes
21:15:06 <vincenz> bt the list monad is used inside the sequence
21:15:15 <vincenz> oh!
21:15:22 <dons> sure. but _print_ ...
21:15:27 <vincenz> yeah
21:15:30 <vincenz> but print inside seuqence!
21:15:33 <vincenz> @index liftM
21:15:34 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.
21:15:34 <lambdabot> State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont,
21:15:34 <lambdabot> Control.Monad.Error, Control.Monad.List
21:15:37 <samx> sequence_ $ do { x <- [1,2,3]; [print x] }
21:15:39 <vincenz> @type Control.Monad.liftM
21:15:40 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
21:15:48 <vincenz> samx: oh!
21:15:50 <vincenz> I gotta return a list
21:15:53 <vincenz> or do return $ print x
21:16:05 <vincenz> \o/
21:16:14 <vincenz> samx: thx :)
21:16:16 <vincenz> that's what I needed
21:16:28 <vincenz> I think return $ print x makes it more grokkable
21:16:46 <dons> yeah, wrap it up in some way
21:16:50 <vincenz> dons: I'm not actually doiing the print, I'm makinig a list of print stms
21:16:53 <vincenz> that I then sequence_
21:16:56 <vincenz> that was the intent :)
21:17:05 <dons> I see now :)
21:17:28 <vincenz> just needed the return
21:17:46 <vincenz> ooh
21:18:00 <dons> so I would write, fwiw: sequence_ $ [1,2,3] >>= return . print
21:18:30 <dons> but then again, @pl rots the brain
21:19:25 <vincenz> hmm
21:19:31 <vincenz> so as long as you stay inside the same monad
21:19:34 <vincenz> you don't need to sequence em
21:20:11 <dons> yup, sequence_ is usually only pulled out when forcing a bunch of IO actions. that's it's most common use anyway
21:20:26 <vincenz> ok
21:20:53 <vincenz> these are the same: http://rafb.net/paste/results/TrXP9g37.html
21:21:41 <vincenz> @type do {x<-[1,2,3]}
21:21:42 <lambdabot> The last statement in a 'do' construct must be an expression
21:21:53 <vincenz> @type do {x<-[1,2,3];x}
21:21:54 <lambdabot> forall b. (Num [b]) => [b]
21:22:05 <vincenz> @type do {x<-[1,2,3];return x}
21:22:06 <lambdabot> forall a. (Num a) => [a]
21:22:22 * vincenz scratches his head
21:22:48 <dons> got to return out of a monad somehow
21:23:01 <vincenz> yeah 
21:23:03 <vincenz> so what's the first one?
21:23:06 <vincenz> @type do {x<-[1,2,3];x}
21:23:07 <lambdabot> forall b. (Num [b]) => [b]
21:23:34 <vincenz> oh it unifies ma with a
21:23:38 <vincenz> and m = []
21:23:45 <vincenz> so 1 must be of type []
21:23:48 <glasser> uh. What is a "GHC stage restriction"?
21:24:01 <glasser>     GHC stage restriction: `b'
21:24:01 <glasser>       is used in a top-level splice, and must be imported, not defined locally
21:24:01 <glasser>     In the first argument of `map', namely `($[splice]b)'
21:24:02 <glasser>     In the definition of `orbit':
21:24:02 <glasser>         orbit b = map ($[splice]b)
21:24:21 <glasser> huh, wait, that's not what my code looked like. I wrote map ($b), not map ($[splice]b)
21:25:52 <dons> are you using '$' the TH splice function, or '$' the application op?
21:26:04 <dons> if the latter, write: map ($ b)
21:26:04 <glasser> I mean to be using the application op
21:26:09 <glasser> writing ($ b) fixed it, yeah
21:26:15 <dons> but you've got -fglasgow-exts turned on?
21:26:20 <glasser> Huh, I thought I had to put in a special flag or something to do TH
21:26:26 <dons> which enables '$' the splice operator.
21:26:35 <glasser> Oh, right I do :) I was using newtype autoderiving, except then I stopped
21:26:37 <dons> nah, -fglasgow-exts gives you most everything
21:26:55 <vincenz> what's an MVar?
21:27:07 <dons> nice error message, seemingly totally unrelated eh glasser?
21:27:19 <glasser> Oh, huh, that apparently wasn't even the only glasgow ext I was using
21:27:21 <glasser> dons: yup
21:27:23 <dons> vincenz, a semaphore-like concurrency primitive in concurrent haskell
21:27:43 <glasser> since I had written \(b :: Board) -> (refl . refl) b == b
21:27:46 <glasser> in a quickcheck test
21:27:56 <dons> yeah, that's another extension
21:28:06 <dons> hopefully to be standard in Haskell'
21:28:13 <vincenz> dons: ah
21:28:13 <glasser> it's a nice one
21:28:28 <vincenz> dons: I take it that Control.Monad is not part of haskell 98 std lib
21:28:37 <dons> um, I think it is. yes.
21:28:52 <vincenz> odd
21:28:55 <dons> except that it's not H98, since it's a hier lib. use import Monad if  you really really care about H98
21:29:19 <vincenz> no just trying to find it in the report ;)
21:29:46 <dons> vincenz, so you're ditching the darcs side^h^h^hOCaml and finally learning haskell?
21:29:54 <dons> s/brain explosion/dark
21:29:55 <vincenz> dons: yeah
21:30:38 <vincenz> Where do I find the stuff you used in the concurrency proggy?
21:30:42 <vincenz> on haskell.org
21:31:32 <dons> @docs Control.Concurrent
21:31:32 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.
21:31:32 <lambdabot> html
21:31:43 <dons> @fptools Control.Concurrent
21:31:43 <lambdabot> http://darcs.complete.org/fptools/libraries/base/Control/Concurrent.
21:31:43 <lambdabot> hs
21:31:52 <vincenz> ah thx
21:31:56 <vincenz> hmm
21:32:03 <vincenz> what is a good book for something past what you learn in the tutorials
21:32:05 <glasser> wee, my tic tac toe program is coming along
21:32:06 <glasser> *TicTacToe> orbit (place X 3 emptyBoard)
21:32:07 <glasser> X| |    | |X   | |    | | 
21:32:07 <glasser> -+-+-  -+-+-  -+-+-  -+-+-
21:32:08 <glasser>  | |    | |    | |    | | 
21:32:10 <glasser> -+-+-  -+-+-  -+-+-  -+-+-
21:32:13 <glasser>  | | ,  | | , X| | ,  | |X
21:32:18 <vincenz> ooh nice
21:32:27 <glasser> vincenz: the Thompson and Hudak books are both great
21:32:28 <dons> hmm. a good book. hmm. TaPL ?
21:32:37 <glasser> I like the Hudak one myself
21:32:38 <vincenz> glasser: what's the internal repr of your board type
21:32:44 <dons> ah, yeah, maybe that level is better :) 
21:32:45 <vincenz> dons: I have tapl, but I meant haskell related
21:32:48 <glasser> TaPL isn't exactly a haskell book
21:33:06 <glasser> newtype Board = Board (Array Spot Square)
21:33:08 <vincenz> to get a feel of programming haskell in the (nontiny)
21:33:18 <vincenz> glasser: Spot Square?
21:33:24 <glasser> and type Spot = Int, data Square = O | X | Empty
21:33:37 <vincenz> what is the difference between newtype and data?
21:33:51 <samx> i have the thompson book, but i've found it as useless as most tutorials.. that is, it only goes over the very basics, but not anything related to real world program creation
21:33:51 <glasser> aha! I know this as of like yesterday! :)
21:34:04 <glasser> apparently newtype A = B Type 
21:34:13 <glasser> is the exact same as data A = B Type
21:34:18 <glasser> but can be optimized better.
21:34:19 <vincenz> yeah seems so
21:34:33 <vincenz> samx: thanx, good to know :)
21:35:08 <glasser> samx: yeah, I'd say the Thompson is a very well done tutorial, whereas the Hudak (while it does start from the beginning) is more of a "cool things you can do with Haskell" 
21:35:34 <glasser> Is there any reason that "data A = B Type" can't just be treated as a newtype by the compiler
21:35:37 <vincenz> glasser: does it cover stuff like control monads?/
21:35:37 <glasser> ?
21:35:47 <glasser> hudak definitely does
21:35:53 <vincenz> neat
21:35:59 <glasser> gives you a little imperative robot control language
21:36:06 <vincenz> you mean "The Haskell School of Expression: Learning ..."
21:37:00 <vincenz> woo, amazon and "look inside book" is great :)
21:37:22 <vincenz> (tho I admit I don't get amazon...sometimes amazon.co.uk doesn't have it while amazon.com does....you'd think they'd share their data)
21:38:12 <vincenz> samx: you sure?  Hudak seems to stick to the basics too
21:39:18 <vincenz> (not even mvars)
21:39:28 <cjs> Hey, you guys know anything about types?
21:39:47 <cjs> (Ok, that was a joke. But maybe you guys can enlighten me about a sort of a theoretical question.)
21:39:52 <samx> vincenz, umm? i've only scanned throught the hudak book for 10 minutes (a coworker bought it recently).. it didn't seem to cover anything related to monad transformers at least
21:40:06 <vincenz> yeah, I'd like a GOOD book
21:40:25 <dons> there aren't really any advanced haskell hacking books as yet
21:41:06 <dons> reading the relevant papers on the feature you want to use, is the best way
21:41:20 <dons> we must have a list of such papers somewhere on the wiki
21:41:57 * vincenz nods
21:41:57 <cjs> Given "lengths = map length", "lengths [[], [0,1], ['a']]" is not valid. Ought it be? Why is it a good thing that it isn't?
21:42:00 <vincenz> it just be nice to get a good overview
21:42:04 <vincenz> of the featuritis of haskell
21:42:06 <vincenz> :P
21:42:18 <vincenz> cjs: your list is not typeable
21:42:21 <sethk> does anyone know how to use the extended baud rate capability with Posix.Terminal?
21:42:22 <vincenz> cjs: it's not the func but the list
21:42:31 <dons> cjs, write a type for that list please :)
21:42:35 <vincenz> > [[], [0,1], ['a']]
21:42:36 <lambdabot>  add an instance declaration for (Num Char)
21:42:36 <lambdabot>   In the list element: 1
21:42:36 <lambdabot>   In the list element: [0, 1]
21:42:47 <vincenz> > [[], [0,1], [2]]
21:42:48 <lambdabot> [[],[0,1],[2]]
21:42:56 <dons> heterogeneous lists are afunny thing. there's ways around them, but generally just avoid them.
21:42:57 <vincenz> > let lengths = map length in lengths [[], [0,1], [2]]
21:42:59 <lambdabot> [0,2,1]
21:43:05 <vincenz> ;)
21:44:47 <cjs> I know it's not typable in Haskell; I'm trying to work out why it ought not be. My instinctive "type", in English, would be "a list of lists of I-don't-care-what."
21:45:01 <vincenz> cjs: no, types are deep
21:45:07 <vincenz> it's a list of a list of ints
21:45:38 <dons> well, you need to be able to compile in code to access those lists. so you need to know either the shape of the elements of the list, or at least have some kind of dictionary of functions for getting at the list
21:45:50 <dons> or 3), dispatch at runtime to the right accessor functions
21:46:02 <dons> > [toDyn (1::Int), toDyn "foo"]
21:46:03 <lambdabot> [<<Int>>,<<[Char]>>]
21:46:06 <vincenz> > undefined :: Typeable
21:46:07 <lambdabot>   Class `Typeable' used as a type
21:46:07 <lambdabot>   In the type `Typeable'
21:46:07 <lambdabot>   In an expression type signature: Typeable
21:46:07 <dons> that's one way.
21:48:02 <vincenz> @type toDyn
21:48:02 <lambdabot> Not in scope: `toDyn'
21:48:02 <vincenz> o.o
21:48:02 <vincenz> dons: what's the type of that dyn thing
21:48:02 <vincenz> dons: or is that something embedded in the compiler
21:48:02 <dons> @type Data.Typeable.toDyn
21:48:02 <lambdabot> Not in scope: `Data.Typeable.toDyn'
21:48:02 * vincenz fails to see how that is typeable
21:48:02 <cjs> Oh, wait, I'm starting to see, perhaps.
21:48:02 <vincenz> @type Typeable.toDyn
21:48:02 <lambdabot> Couldn't find qualified module.
21:48:02 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
21:48:02 <lambdabot> \\)?
21:48:02 <vincenz> o.O
21:48:02 <dons> @type Data.Dynamic.toDyn
21:48:02 <lambdabot> forall a. (Data.Typeable.Typeable a) => a -> Data.Dynamic.Dynamic
21:48:02 <vincenz> dons: yeah but what's the impl of Dynamic?
21:48:02 <cjs> So when I map length, it's going to chose one "length" function at compile time, but I actually need different "length" functions for [1] and ['a']?
21:48:02 <dons> toDyn wraps up list elements in a uniform "box", along with a tag  indicating what the type of the elemtns are.
21:48:06 <vincenz> dons: compiler magic?
21:48:14 <dons> then as you walk your list, you can access the elements by looking at the tag
21:48:19 <dons> vincenz, no magic
21:48:37 <sethk> any clues about my serial port situation?  I know it isn't as sexy as dynamic lists, but I need to figure it out.  :)
21:48:40 <vincenz> @fptools toDyn
21:48:40 <lambdabot> toDyn not available
21:48:45 <vincenz> @fptools Data.Dynamic.toDyn
21:48:46 <lambdabot> Data.Dynamic.toDyn not available
21:48:48 <vincenz> @fptools Data.Dynamic
21:48:48 <lambdabot> http://darcs.complete.org/fptools/libraries/base/Data/Dynamic.hs
21:48:58 <dons> cjs, no, iit's not length that is the problem. it's the type of the list itself.
21:49:13 <dons> @type length
21:49:14 <lambdabot> forall a. [a] -> Int
21:49:20 <samx> if it's anything like the ocaml dyn hacks i've seen, the type would be something like unit -> unit :-)
21:49:38 <dons> it takes a list of some type 'a'. but you have a list whose elements  are Int, Char ... and so on.
21:49:51 <dons> you need to hide them in some way, so they appear to be just some uniform type 'a'.
21:50:20 <dons> dynamics or existentials to just this.
21:50:24 <vincenz> dons: oh you can have forall types as types
21:50:25 <cjs> Err...no, I don't think so. Each list within the outer list is typable, or at least that's what I wanted to write.
21:50:25 * vincenz whistles
21:50:39 <vincenz> fancy type system, that doesn't work in ocaml
21:50:43 <cjs> @eval length [1, 2]
21:50:44 <lambdabot> 2
21:50:52 <cjs> @eval length ['a']
21:50:53 <lambdabot> 1
21:51:05 <cjs> @eval map length [[1, 2], ['a']]
21:51:06 <lambdabot>  add an instance declaration for (Num Char)
21:51:06 <lambdabot>   In the list element: 2
21:51:06 <lambdabot>   In the list element: [1, 2]
21:51:06 <dons> cjs, you wanted a list containing: [ [1,2,3], [], ['x'] ] didn't you?
21:51:15 <dons> what's the type of the outer list?
21:51:21 <dons> [[a]]? but what 'a'
21:51:47 <vincenz> > [[1,2,3], ["a"]] :: [[forall a.a]]
21:51:48 <lambdabot> Couldn't match `. (forall a)' against `[]'
21:52:00 <cjs> We're getting into the dynamic vs. static mindset here, I think. I tend to think, "All I care is that everything in that list supprorts length."
21:52:22 <cjs> Ok, so I define a type that is "something I can do 'length' on, but nothing else"?
21:52:29 <dons> sure. so you need to use existentials that provide static guarantees about what you can do to the element
21:52:41 <dons> (I just suggest dynamics since they're easy to grok)
21:52:46 <vincenz> dons: how does the Obj work?
21:52:50 <vincenz> in the dynamic module
21:52:51 <cjs> Ah, and then my argument is not [[a]] but [a].
21:53:00 <vincenz> cjs: yes but a must be typed
21:53:14 <vincenz> in this case it's [b]
21:53:16 <vincenz> so you have [[b]]
21:53:18 <cjs> dons: that static thing is exactly what i want to learn.
21:53:20 <vincenz> so now you have to find b
21:53:57 <cjs> Oh, hey, yeah, because of the map...hmmm....it's not [a] after all...
21:54:11 <vincenz> cjs: even then
21:54:15 <dons> cjs, check the page on 'existential types' in the ghc users manual section on type extensions
21:54:16 <vincenz> lenght :: [a] -> int
21:54:23 <vincenz> cjs: but for each call, the a must be instantiated
21:54:41 <dons> or can you build up a list of [length xs, length ys] .. ?
21:55:12 <vincenz> dons: I wouldn't mention existential types to someone starting to grok static typing
21:55:29 * vincenz has the advantage of having learned ocaml first
21:55:47 <dons> ok. well, I at first just said: don't build heterogeneous lists :)
21:55:53 <vincenz> :)
21:56:02 <vincenz> dons: anyways, I see it uses something like
21:56:05 <vincenz> type Obj = forall a.a
21:56:13 <vincenz> how come you can't use that directly
21:56:15 <vincenz> as in
21:56:18 <vincenz> [forall a.a]
21:56:32 <cjs> Well, if i start with something like "data Lengthable a = L a" as a constructor, does that seem to be going in a reasonable direction?
21:56:44 <vincenz> cjs: it doesn't matter
21:56:50 <dons> @type sum [ length [1,2,3], length "foo", length [1.0, 2.0] ]
21:56:51 <lambdabot> Int
21:57:00 <vincenz> cjs: eventually you'll still only be able to have a list of L a, L b, Lc
21:57:01 <vincenz> which is not allowed
21:57:18 <cjs> Right. HUGS just told me that.
21:57:52 <vincenz> cjs: length is polymorphic (parametetric, whatever the term yo use)
21:58:08 <vincenz> but each piece of data must have a unique type
21:58:17 <vincenz> cjs: you know any other languages besides ruby?
21:58:20 <cjs> I'm beginning to think that this may be a silly example, because it keeps degenerating into something trivial.
21:58:34 <vincenz> cjs: either way, you gotta think "why would I even have such a list"
21:58:42 <cjs> yeah, exactly.
21:59:08 <vincenz> static typing might seem like bondage to a dynamic typer, but it isn't, cauise those cases just don't come up
21:59:13 <cjs> I know lots of Java (ouch!), bits of Smalltalk, C, Scheme, etc. etc.
21:59:22 <vincenz> hmm
21:59:28 <vincenz> cjs: c++?
21:59:29 <cjs> It's not bondage to me; it's what I'm aiming for.
21:59:35 <vincenz> cjs: templates?
21:59:57 <cjs> I've touched C++, but it seems the worst of all worlds. Didn't do any template stuff.
22:00:01 <dons> you could have a list of [forall a. Lengthable a => A a], and then map lengthable over the list. but we just don't do this very often at all. it's not idiomatic haskell by a long way
22:00:32 <cjs> Ok, so this basically doesn't come up, then.
22:00:42 <dons> (the class constraint keeps the compiler happy that nothing bad will happen)
22:01:06 <vincenz> dons: so how does Data.Dynamic work?
22:01:12 <vincenz> dons: I mean it says "type Obj = forall a.a"
22:01:33 <vincenz> > []::[forall a.a]
22:01:34 <lambdabot>  add an instance declaration for (Show (. (forall a) a))
22:01:39 <vincenz> > [1]::[forall a.a]
22:01:40 <lambdabot>   add (Num (. (forall a) a)) to the expected type of an expression
22:01:40 <lambdabot>   or add an instance declaration for (Num (. (forall a) a))
22:01:40 <lambdabot>   In the list element: 1
22:01:43 <dons> yeah but the elements are [forall a. Typeable a => Obj a] and you can only do fromDyn,toDyn on them
22:01:45 <vincenz> > [1]::[forall a . a]
22:01:46 <lambdabot>   add (Num (. (forall a) a)) to the expected type of an expression
22:01:46 <lambdabot>   or add an instance declaration for (Num (. (forall a) a))
22:01:46 <lambdabot>   In the list element: 1
22:02:07 <vincenz> dons: It still reeks like some compiler trick
22:02:10 <vincenz> Ala Obj.magic in ocaml
22:02:18 * vincenz can't get his head around it
22:02:32 <dons> cjs, when you want such structures, we usually use union types
22:02:46 <vincenz> aka variiants
22:02:53 <dons> data A = MyString String | MyInt Int ... ; and then have a list of [A]
22:03:04 <dons> or some such.
22:03:27 <cjs> I see. Cool.
22:03:50 <dons> > [Left 1, Right 'x', Left 2]
22:03:51 <lambdabot> [Left 1,Right 'x',Left 2]
22:04:18 <glasser> hmm, why is this?
22:04:30 <glasser> *TicTacToe> :type [4,3,2]
22:04:30 <glasser> [4,3,2] :: (Num a) => [a]
22:04:31 <glasser> *TicTacToe> [4,3,2]
22:04:31 <vincenz> > let lengths = map length in [Left [1,2,3], Right ["a"], Left[1,2,3]]
22:04:31 <glasser> [4,3,2]
22:04:32 <glasser> *TicTacToe> :type it
22:04:32 <lambdabot> [Left [1,2,3],Right ["a"],Left [1,2,3]]
22:04:34 <glasser> it :: [Integer]
22:04:49 <vincenz> glasser: default instances
22:05:05 <vincenz> glasser: 3 :: Num a
22:05:09 <glasser> what's a default instance?
22:05:14 <vincenz> but the actualy data must be a SPECIFIC type
22:05:21 <vincenz> so it defaults to Integer for the Num class
22:05:29 <glasser> Ah
22:05:48 <vincenz> similarly Float or Double (cant remember) for Real
22:06:00 <vincenz> @type a / b
22:06:01 <lambdabot> Not in scope: `a'
22:06:01 <lambdabot>  
22:06:01 <lambdabot> <interactive>:1:4: Not in scope: `b'
22:06:07 <vincenz> @type \a b -> a / b
22:06:08 <lambdabot> forall a. (Fractional a) => a -> a -> a
22:06:20 <vincenz> @type let x = \a b -> a / b in x 3
22:06:21 <lambdabot> forall a. (Fractional a) => a -> a
22:06:29 <vincenz> @type let x = \a b -> a / b in x 3 4.5
22:06:30 <lambdabot> forall a. (Fractional a) => a
22:06:41 <vincenz> > let x = \a b -> a / b in x 3 4.5
22:06:42 <lambdabot> 0.6666666666666666
22:06:45 <vincenz> blegh
22:06:58 <vincenz> that should be a Float I think
22:07:17 <vincenz> Double
22:07:34 <joelk> hmm.. I can't build gtk2hs from darcs. autoreconf doesn't like Makefile.am *at all*.
22:09:52 <AndroFlux> newbie question: Why doesn't Hugs or GHCi allow you to define things at the REPL?
22:10:05 <AndroFlux> ...or maybe they do, and I just don't know how...
22:10:36 <dons> it does. paprika$ ghci
22:10:36 <dons> Prelude> let f x = x + x 
22:10:36 <dons> Prelude> f 3
22:10:37 <dons> 6
22:10:42 <vincenz> Concurrent Haskell is neat
22:10:46 * vincenz has the paper :)
22:11:29 <dons> and you can always write:
22:12:45 * joelk checks the gtk2hs faq /after/ blurting out on the channel...
22:13:03 <dons> > let f x = x + x in f 3  
22:13:03 <lambdabot>  lexical error
22:13:22 <dons> hmm.
22:13:24 <vincenz> Hehe, great title : "How to Replace Failure by a List of Successes"
22:13:28 <dons> > let f x = x + x in f 3
22:13:30 <lambdabot> 6
22:13:42 <vincenz> that was odd
22:14:11 <dons> (control chars sneaking in when my wifi dropped out)
22:14:19 <vincenz> ah yeah
22:14:21 <vincenz> same here apparently
22:14:26 <vincenz> sometimes my irssi screen becomes blue
22:20:34 <AndroFlux> Okay, thanks. I had been doing a plain "f x = x * x", which works in a file, but not on the REPL, and I didn't (and still don't) understand why.
22:54:28 <shapr> @quote
22:54:29 <lambdabot> Pseudonym says: Lazy evalution is really, really trippy.
22:59:18 <vincenz> dons: ping
22:59:27 <vincenz> shapr: you familiar with concurrent haskell?
22:59:40 <sieni> @quote
22:59:41 <lambdabot> joelr says: Fundeps, existential types, HList take a while to grasp
23:14:25 <lispy> i want a code coverage tool
23:14:30 <lispy> and i want it now :)
23:18:40 <rep> coverity?
23:18:46 <rep> what do you mean by code coverage
23:20:21 <lispy> code covered during testing, specifically i want to have a measure of the coverage of definition and use pairs
23:20:26 <rep> oh
23:20:41 <rep> wouldn't profiling kinda work?
23:20:45 <ncalexan> lispy: you might get some of that from ghc's time profile.
23:20:52 <rep> ya
23:21:06 <lispy> my motiviation is that darcs has a growing test suite that takes longer and longer, but isn't very good at finding new bugs. 
23:21:33 <lispy> i'd like to find out how much of the code we are actually testing
23:21:59 <lispy> the profiling tools might be a place to start, then build something to visualize the output
23:22:17 <lispy> but, i think it would just tell me how often cost centers are invoked
23:23:50 <lispy> anyone used haste before?  the haskell gui? http://haste.dyndns.org:8080/screenshots.php
23:23:56 <lispy> er ide not gui
23:27:55 <lispy> ah well...i need to go to bed
23:27:59 <lispy> night, night all!
23:30:16 <gour> night lispy
