00:17:13 <ProfTeggy> Moin
01:24:29 <srle> hello
01:24:45 <Lemmih> Hi.
01:25:10 <srle> Lemmih : is foldr tail recursive?
01:27:06 <ski> no
01:27:18 <JaffaCake> monring #haskell
01:27:23 <musasabi> > foldr (\x y -> let z = x + y in z `seq` z) 0 [1..5000000]
01:27:25 <lambdabot> Exception: stack overflow
01:27:35 <musasabi> (the easy way to get the answer)
01:27:39 <Lemmih> Hiya JaffaCake.
01:28:23 <srle> Does "mapM_ print [1..5000000]" overflow?
01:28:25 <ski> (but depending on how it's used, it can run in O(1) space anyway
01:28:30 <ski> )
01:28:49 <Lemmih> musasabi: Does 'z `seq` z' make sense?
01:29:13 <musasabi> Lemmih: yes, it makes.
01:29:23 <srle> ski : mapM_ uses foldM which is basicly foldr for monads.
01:29:29 <flux__> > foldr (\x y -> let z = x + y in z) 0 [1..5000000]
01:29:31 <lambdabot> Exception: stack overflow
01:29:34 <ski> srle : no
01:29:52 <flux__> > foldr (\x y -> x + y) 0 [1..5000000]
01:29:54 <lambdabot> Exception: stack overflow
01:30:02 <flux__> > foldr (+) 0 [1..5000000]
01:30:04 <lambdabot> Exception: stack overflow
01:30:27 <Lemmih> musasabi: Isn't it just saying that 'z' will be evaluated when 'z' is evaluated?
01:30:30 <musasabi> > foldl' (+) 0 [1..500000]
01:30:32 <lambdabot> 125000250000
01:30:54 <srle> ski : why doesn't "mapM_ print [1..500000]" overfow?, it should overflow.
01:31:04 <srle> ski : because it is not tail recursive.
01:31:13 <srle> ski : am I wrong?
01:31:26 <musasabi> mapM_ f [] = return ()
01:31:49 <musasabi> mapM_ f (x:xs) = f x >> mapM_ f xs
01:31:53 <ski> srle : foldM corresponds more to foldl
01:32:12 <musasabi> quite tail recursive if that definition is used.
01:32:18 <srle> musasabi : what about mapM? does it overflow?
01:33:14 <musasabi> > mapM return [1..500000] >> Just ()
01:33:17 <lambdabot> Just ()
01:33:18 <ski> (musasabi : strictly that depends on monad, yes ?)
01:33:29 <musasabi> ski: point.
01:37:43 <Lemmih> musasabi: I really can't see why 'seq a a' would be different from 'a'.
01:37:45 <srle> is it posible to make followint thig tail recursive? it is commont pattern
01:37:47 <srle> sequence []     = return []
01:37:47 <srle> sequence (c:cs) = do x  <- c
01:37:47 <srle>                      xs <- sequence cs
01:37:47 <srle>                      return (x:xs)
01:37:50 <Lemmih> Am I missing something obvious?
01:38:11 <musasabi> let me think
01:40:11 <ibid> srle: yes it is
01:40:36 <srle> ibid : how?
01:41:05 <ibid> srle: by using the standard tail recursion translation afaict
01:41:33 <musasabi> Lemmih: yes, they are the same, it should be seqing the arguments (to force the old +)
01:42:12 <srle> ibid : can you give me the actual code? it is not obviout for me how to do it
01:42:28 <ibid> something like f = loop [] >>= return . reverse where loop a [] = return a ; loop a (x:xs) = loop (x:a) xs or something to the effect
01:43:51 <ibid> blah
01:43:57 <ibid> that's wrong
01:44:19 <murdock> therules.dat
01:44:33 <murdock> HEH
01:44:34 <ibid> f = loop [] >>= return . reverse where loop a [] = return a ; loop a (x:xs) = do x' <- x ; loop (x':a) xs
01:45:39 <ibid> (of course, depending on the monad, this may not actually be tail-recursive, but it ought to be in IO)
01:45:43 <ski> (that won't work for infinite lists though, of course)
01:46:12 <ibid> true, but the original won't either in strict monads at least
01:46:21 <ibid> dunno about lazy ones
01:46:48 <ski> (one could do stuff with unsafeInterleaveX ..)
01:47:04 <ibid> yes, but then it's a different function :)
01:47:36 <ski> somewhat :)
01:51:16 <JaffaCake> I'm thinking about starting a "Haskell Performance Resource" on the wiki, where we'd collect together all the useful info about how to make Haskell programs go faster.  Any thoughts anyone?  I have a few ideas about how to structure it.  Anyone interested in helping?
01:53:54 <srle> ibid : you want to say that 'sequence' is tail recursive in IO monad.
01:54:35 <ibid> srle: my version ought to be. dunno about the one in libraries
01:58:15 <srle> ibid : this was strange for me. I tought that 'sequence' would overflow but it didn't. I was looking the definition of 'sequence' in Prelude.
01:58:32 <dcoutts> JaffaCake, I've bumped into perf problems occasionally so I might be able to contribute a little
01:58:50 <JaffaCake> great
01:59:02 <srle> ibid : definition of 'sequence' is not tail recursive. sorry for bothering
01:59:10 <JaffaCake> I just want to put a structure together so we can start collecting material
01:59:36 <musasabi> JaffaCake: how about "ship fps with the next GHC release" ;)
01:59:41 <JaffaCake> it's important to separate out techniques that are specific to one particular compiler from those that are compiler-independent, too
01:59:51 <JaffaCake> musasabi: that's my plan for 6.6
02:00:13 <JaffaCake> musasabi: but I'm waiting on dons's updated fps
02:00:36 <dcoutts> JaffaCake, do you know anything about gcc's non-exeutable stack support? In Gentoo land they're having a war against programs that have executable stacks and unfortunately all ghc-produced binarys have executable stacks.
02:01:07 <dcoutts> at least they seem to for us, with the versions of libs we're using
02:01:23 <JaffaCake> oh grrrr.  I wonder if that's just the adjustor stuff
02:01:26 <musasabi> JaffaCake: nice :-)
02:01:37 <dcoutts> we thoguht the culrpit was libgmp, but now that that one's fixed it's still not right
02:01:45 <dcoutts> JaffaCake, I thought that too, but..
02:02:31 <JaffaCake> what does it have to do with gcc?  I thought it was an OS issue
02:02:35 <dcoutts> JaffaCake, apparently each .o file is marked with a special section .GNU_STACK.note (or something) if gcc believes that it works with a non-executable stack.
02:02:46 <JaffaCake> I see
02:03:10 <dcoutts> then if each .o & .so file that get linked together have that section then the linker preserves it in the final binary
02:03:17 <JaffaCake> right
02:03:18 <dcoutts> and then the OS makes the stack non-exec
02:03:33 <dcoutts> so we've got a tool that tells us if the .o files are ok
02:03:38 <dcoutts> and they all are!
02:03:47 <dcoutts> even all the GHC rts .o files
02:03:49 <Heffalump> JaffaCake: how often do the instructions for porting ghc get tested?
02:03:55 <dcoutts> which surprised us
02:04:10 <JaffaCake> Heffalump: not very often
02:04:18 <Heffalump> so it's likely that they're out of date for 6.4.1?
02:04:39 <Heffalump> (just trying to work out if misbehaviour is something silly I'm doing, or if I just need to adapt them sensible)
02:04:47 <JaffaCake> dcoutts: so the problem is that you get crashes?
02:04:50 <dcoutts> so our problem is tracking down exactly why the final binary has an exec stack when it seems like all the things ghc asks gcc to like are ok with non-exec stacks.
02:05:14 <maitscha> hallo. how can I read a line from input and compare it with some value?
02:05:15 <dcoutts> JaffaCake, no, it's jsut that the final binary always uses an executable stack
02:05:16 <JaffaCake> Heffalump: I vaguely remember fixing some things recently
02:05:38 <JaffaCake> dcoutts: ah
02:05:46 <maitscha> why does ...
02:05:48 <maitscha> readNext :: String -> String
02:05:48 <maitscha> readNext s = if line == "end"
02:05:48 <maitscha>                   then return s
02:05:48 <maitscha>                   else do nextString s
02:05:48 <maitscha>     where
02:05:49 <maitscha>     line <- getLine
02:05:51 <maitscha> not work?
02:06:19 <JaffaCake> Heffalump: what are you porting to?  arm? :)
02:06:24 <Heffalump> JaffaCake: yeah
02:06:26 <dcoutts> JaffaCake, I even unpacked all the libHS*.a files and ran our checker on the .o files and they're apparently ok too. So we're stumped.
02:06:27 <JaffaCake> cool
02:06:49 <JaffaCake> Heffalump: where are you stuck at?
02:07:05 <Heffalump> various little details were going wrong, but I have some ideas about some of them and ought to go to work now
02:07:22 <dcoutts> JaffaCake, the reason we're thinking about it is that now all our packages flag up QA warnings (and users are encouraged to file bugs against us) since we install binaries with executable stacks. :-(
02:07:24 <Heffalump> one of the worrying things was that building the .hc archive failed to find a few files:
02:07:28 <Heffalump> e.g.
02:07:29 <Heffalump> tar: ghc-6.4.1/ghc/rts/AutoApply_thr.hc: Cannot stat: No such file or directory
02:07:29 <Heffalump> tar: ghc-6.4.1/ghc/rts/AutoApply_thr_p.hc: Cannot stat: No such file or directory
02:07:32 <Heffalump> tar: ghc-6.4.1/ghc/rts/AutoApply_debug.hc: Cannot stat: No such file or directory
02:07:51 <JaffaCake> dcoutts: you checked libHSbase_cbits?
02:07:51 <dcoutts> JaffaCake, there's some info here: http://www.gentoo.org/proj/en/hardened/gnu-stack.xml
02:07:57 <dcoutts> JaffaCake, yeah
02:08:12 <JaffaCake> Heffalump: those are harmless
02:08:41 <Heffalump> ok. I also seemed to be missing some _hsc.c files on the target, but I just copied those across from the host directory.
02:09:48 <JaffaCake> dcoutts: not sure what to suggest, other than scrutinising that link command line very closely
02:10:03 <Saulzar> maitscha, line <- getLine won't work outside do notation
02:10:08 <Heffalump> oh, actually, I think the missing files was caused by a cockup on my part anyway
02:10:15 <Heffalump> (the .hsc_c files, not the rts ones)
02:10:20 <Saulzar> maitscha,  Might be easier to paste large chunks with the lisppaste2 bot
02:10:27 <Saulzar> lisppaste2, paste
02:10:46 * Heffalump tries something to fix things and really goes
02:11:11 <maitscha> Saulzar: I know, but 6 lines are not "large chunks"
02:12:50 <ibid> actually, they are
02:13:00 <ibid> anything longer than 4 is on irc :)
02:16:31 <dcoutts> JaffaCake, actually I suspect the object splitting might be part of the issue
02:17:11 <dcoutts> JaffaCake, all the .o files in libHSbase_cbits.a have the special ".note.GNU-stack" section
02:17:36 <dcoutts> but the same is not true for the multitude of .o files in libHSbase.a
02:30:58 <maitscha> i have a problem with a do statement...
02:31:42 <Saulzar> maitscha, What's the problem?
02:32:04 <maitscha> I have the expression        if (line == [])
02:32:04 <maitscha>          then return ()
02:32:04 <maitscha>          else (do putStrLn line
02:32:04 <maitscha>                goUntilEmpty )
02:32:23 <maitscha> I get the error unexpected symbol
02:32:31 <maitscha> "goUntilEmpty"
02:32:38 <maitscha> but goUntilEmpty is a function...
02:33:19 <maitscha> http://rafb.net/paste/results/JzbH9k28.html
02:33:50 <Beelsebob> maitscha: is your indenting correct?
02:34:16 <maitscha> yes. I'm using only blanks, no tabs.
02:34:45 <Beelsebob> I've often had problems embedding ifs in dos... usually fixable by using case instead
02:35:37 <maitscha> hmmm.... never used cases.
02:36:28 <joelk> What's the type of goUntilEmpty?
02:36:37 <Beelsebob> goUntilEmpty = do line <- getLine; case line of [] -> return (); l -> (do putStrLn line; goUntilEmpty)
02:36:51 <joelk> Oh, right, I can look myself...
02:39:06 <Saulzar> maitscha, Your 2nd line on the do should line up with the text on the fist
02:39:27 <Saulzar> do Foo
02:39:30 <Saulzar>    Bar
02:40:34 <maitscha> Saulzar: yes. that worked!!
02:41:13 <maitscha> wow... haskell is really pedantic
02:42:23 <Saulzar> Hm, you might say that - then you might say it's very flexible by allowing two ways :)
02:43:52 <joelk> You can also use curly braces and semicolons ala "do {putStrLn line; goUntilEmpty}" with any layout you want.
02:44:05 <musasabi> maitscha: well if you enjoy the C way you can say: do { foo; bar } in Haskell.
02:56:35 <dcoutts> JaffaCake, does the ghc darcs repo send all patches to the ghc commit mailing list now?
02:56:47 <JaffaCake> dcoutts: no, not yet
02:56:52 * dcoutts is trying to figure out how to set that up for the gtk2hs darcs repo
02:57:19 <JaffaCake> dcoutts: ask CosmicRay 
02:57:36 <dcoutts> right oh
02:57:44 <dcoutts> @seen CosmicRay
02:57:45 <lambdabot> I saw CosmicRay leaving #haskell-blah and #haskell 11 days, 14 hours, 28
02:57:45 <lambdabot> minutes and 1 second ago, and I have missed 11 days, 2 hours, 49 minutes
02:57:45 <lambdabot> and 39 seconds since then.
03:01:51 <JaffaCake> http://haskell.org/haskellwiki/Haskell_Performance_Resource
03:01:55 <JaffaCake> it's a start
03:02:33 <JaffaCake> I'm going to start moving the GHC content over from the GHC User Guide
03:06:18 <JKnecht> JC: Thank You.
03:29:34 <maitscha> is there a function to check if a string is a valid number, e.g. "-23" -> 23
03:29:40 <maitscha> s/23/-23
03:29:57 <maitscha> "-23" -> -23
03:30:05 <maitscha> "99" -> 99
03:30:37 <joelk> there's read. It throws an exception on invalid input.
03:30:46 <joelk> >read "-23"
03:30:50 <joelk> > read "-23"
03:30:51 <lambdabot> Add a type signature
03:30:56 <joelk> > read "-23" ** Int
03:30:57 <lambdabot>  Not in scope: data constructor `Int'
03:30:59 <joelk> > read "-23" :: Int
03:31:01 <lambdabot> -23
03:31:01 <dcoutts> or reads
03:31:05 <dcoutts> @type reads
03:31:07 <lambdabot> forall a. (Read a) => ReadS a
03:31:10 <joelk> > read "foo" :: Int
03:31:11 <lambdabot> Exception: Prelude.read: no parse
03:31:20 <dcoutts> which gives [] on invalid input
03:31:27 <dcoutts> > reads "foo" :: Int
03:31:29 <lambdabot> Couldn't match `Int' against `[(a, String)]'
03:31:38 <dcoutts> > reads "foo" [] :: Int
03:31:39 <lambdabot>   The function `reads' is applied to two arguments,
03:31:39 <lambdabot>   but its type `ReadS a' has only one
03:31:39 <lambdabot>   In the expression: reads "foo" [] :: Int
03:32:05 <maitscha> > reads "foo" :: Int
03:32:06 <lambdabot> Couldn't match `Int' against `[(a, String)]'
03:32:08 <ibid> > reads "foo" :: [(Int, String)]
03:32:09 <lambdabot> []
03:32:24 <dcoutts> > reads "foo" :: [(Int,String)]
03:32:25 <lambdabot> []
03:32:30 <ibid> > reads "123foo" :: [(Int, String)]
03:32:31 <lambdabot> [(123,"foo")]
03:32:32 <dcoutts> oh ibid beat me :-)
03:32:56 <maitscha> reads "-123" :: [(Int,String)]
03:33:09 <ibid> > !
03:33:10 <lambdabot>  parse error on input `!'
03:33:11 <ibid> :)
03:33:15 <maitscha> > reads "-123" :: [(Int,String)]
03:33:17 <lambdabot> [(-123,"")]
03:33:46 <maitscha> hmmm..... but "-123abc" should be parsed as -123 and abc, but as -123abc
03:34:05 <maitscha> because there is no blank between Num and Char.
03:34:28 <Saulzar> > reads "-123" :: [(String,Int)]
03:34:29 <lambdabot> Couldn't match `Int' against `String'
03:34:49 <Saulzar> @type reads
03:34:51 <lambdabot> forall a. (Read a) => ReadS a
03:34:52 <dcoutts> Saulzar, the second type in the pair must be String
03:35:08 <dcoutts> type ReadS a = [Char] -> [(a,[Char])]
03:35:17 <joelk> > reads "74foo13-15 bar hello world" :: [(Int, String)]
03:35:19 <lambdabot> [(74,"foo13-15 bar hello world")]
03:35:20 <dcoutts> type ReadS a = String -> [(a,String)]
03:35:22 <Saulzar> Ah, as ShowS 
03:35:27 <araujo> Good morning.
03:35:35 <Lemmih> > (reads :: ReadS Int) "123foo"
03:35:36 <lambdabot> [(123,"foo")]
03:35:55 <joelk> gour, ping!
03:35:59 <JKnecht> Good morning.
03:36:02 <maitscha> is there a way to catch the exception in the function?
03:36:27 <maitscha> > read "-23abc" :: Int
03:36:29 <lambdabot> Exception: Prelude.read: no parse
03:36:39 <gour> joelk: pong
03:36:39 <maitscha> > read "-23" :: Int
03:36:41 <lambdabot> -23
03:37:31 <joelk> gour, As promised, I checked out Okasaki's book today. Anything specific you want me to look up?
03:38:53 <ibid> maitscha: reads returns the read value plus the characters that follow the value returned
03:40:24 <gour> joelk: thanks. i'm primarily interested whether the books is worth buying over the thesis and/or whether the appendix code contains all the exampes from the book?
03:42:56 <joelk> Hmm... Looks like they got him a good editor. The first section seems changed a bit, but the meat of it just looks like an edited version of the thesis. 
03:43:10 <gour> ok
03:43:21 <joelk> I'll have to look closer to see how different things are.
03:44:12 <joelk> The appendix seems to list all code examples in Haskell. 6 queus
03:44:25 <maitscha> ibid: I think reads is not usable for me. Perhaps there is a function which returns True on "123" and False on "123aa"
03:45:30 * gour is thankful to joelk for reviewing the okasaki book
03:45:40 <joelk> 6 queues, 1 deque, 1 catenable list, 3 random access lists, 7 heaps, mergesort, 2 sets, and 2 finite maps
03:46:04 <joelk> I've been meaning to look into it for a *long* time.
03:46:07 <ibid> maitscha: you can make one from reads
03:46:33 <ibid> maitscha: f x = case reads of [(x,_)] -> True ; _ -> False
03:46:35 <ibid> :)
03:46:51 <maitscha> ibid: that looks great
03:47:05 <ibid> argh
03:47:09 <ibid> maitscha: f x = case reads x of [(x,_)] -> True ; _ -> False
03:47:11 <ibid> :)
03:47:36 <ibid> > let f x = case reads x of [(x,_)] -> True ; _ -> False in f "123xyz"
03:47:38 <lambdabot> Add a type signature
03:48:05 <ibid> > let f x = case reads x :: [(Int,String)] of [(x,_)] -> True ; _ -> False in f "123xyz"
03:48:06 <lambdabot> True
03:48:12 <ibid> blah
03:48:17 <ibid> > let f x = case reads x :: [(Int,String)] of [(x,[])] -> True ; _ -> False in f "123xyz"
03:48:18 <lambdabot> False
03:48:21 <ibid> > let f x = case reads x :: [(Int,String)] of [(x,[])] -> True ; _ -> False in f "123"
03:48:23 <lambdabot> True
03:48:26 <ibid> maitscha: there :)
03:48:39 <maitscha> ibid: thx a lot!!
03:49:44 <gour> joelk: so, it looks good..
03:50:42 <joelk> Yes, I think a lot of work went into preparing it for general consumption. Not that the thesis is hard to read.
03:51:35 <gour> but not the easiest as well :-)
03:52:40 <joelk> I hope my thesis will be deemed easy to read, but I'm not very hopeful! :-)
03:53:04 <gour> what is your thesis about?
03:54:11 <joelk> astronomy
03:54:40 <joelk> Why isn't ReadS a :: String -> Maybe (a,String)
03:55:00 <gour> jolek: hmm..interesting. do you know something about vedic astronomy?
03:55:42 <ibid> joelk: because it can be ambiguous?
03:57:44 <gour> joelk: hmm..interesting. do you know something about vedic astronomy?
03:57:58 <joelk> gour, no. I'll google it though.
03:58:29 <gour> joelk: http://www.amazon.com/gp/product/0963530933/qid=1136894137/sr=12-6/002-3478915-8804042?s=books&v=glance&n=283155
03:58:46 <joelk> ibid, so, a list of alternatives? I'm looking at the library source and it isn't obvious yet if anything uses it... I'll keep digging.
03:58:56 <gour> joelk: and http://www.amazon.com/gp/product/0892132698/qid=1136894137/sr=1-2/ref=sr_1_2/002-3478915-8804042?s=books&v=glance&n=283155
03:59:16 <dcoutts> @seen shapr
03:59:17 <lambdabot> shapr is in #ScannedInAvian. Last spoke 56 minutes and 25 seconds ago.
04:00:39 <ibid> joelk: i think it's supposed to be a generic type that supports nondeterminism, even if the standard Read instances don't use it
04:08:20 <maitscha> how can i convert a Int to String?
04:08:49 <joelk> maitscha, show
04:09:23 <maitscha> ahhh.. yeah. thx
04:25:58 <ADEpt> @seen Lemmig
04:25:58 <lambdabot> Lemmig has changed nick to lemmih.
04:25:58 <lambdabot> lemmih is in #haskell-blah and #haskell. Last spoke 50 minutes and 23
04:25:58 <lambdabot> seconds ago.
04:26:16 <ADEpt> Lemmih: ping
04:43:53 <Lemmih> ADEpt: pong.
04:49:12 <maitscha> @type putInt
04:49:14 <lambdabot> Not in scope: `putInt'
04:49:24 <maitscha> @type putInteger
04:49:25 <lambdabot> Not in scope: `putInteger'
04:49:36 <maitscha> hmm... is there something like putInt ???
04:50:38 <Lemmih> maitscha: print?
04:51:16 <maitscha> Lemmih: no.
04:51:36 <Lemmih> maitscha: no?
04:51:44 <maitscha> > print [2,3]
04:51:46 <lambdabot> No IO allowed
04:52:28 <maitscha> I have to print out something like in c "The value is %d", &d
04:52:39 <maitscha> and d is from type IO Int.
04:53:26 <Lemmih> Prelude Text.Printf> printf "The value is %d\n" (10::Int)
04:53:26 <Lemmih> The value is 10
04:53:49 <maitscha> coool.
04:53:51 <Lemmih> Or: '"The value is " ++ show (10::Int)'
04:53:52 <dcoutts> maitscha, do { value <- d; putStr ("The value is " ++ show value) }
04:55:54 <dcoutts> @seen CosmicRay
04:55:55 <lambdabot> I saw CosmicRay leaving #haskell-blah and #haskell 11 days, 16 hours, 26
04:55:55 <lambdabot> minutes and 11 seconds ago, and I have missed 11 days, 2 hours, 49
04:55:55 <lambdabot> minutes and 39 seconds since then.
04:59:07 <gour> dcoutts: on gtk2hs site it is written 'subscibe', but i believe it should be 'subscribe' true?
04:59:23 <dcoutts> gour, yep
04:59:57 * dcoutts fixes it
05:01:28 * gour fixed
05:01:53 <dcoutts> ta
05:02:18 <gour> dcoutts: have you applied for akismet key?
05:02:34 <dcoutts> gour, oh I thought you were doing that :-)
05:02:50 <gour> with your email = :-)
05:03:08 * dcoutts has been trying to figure out how to get darcs to send emails of patches to a mailing list
05:03:13 <gour> dcoutts: ok, i'll do it and send you copy of the key, ok?
05:03:18 <dcoutts> gour, ok
05:03:45 <gour> dcoutts: darcs (project) uses roundup with command line interface
05:03:57 <dcoutts> huh?
05:04:04 <dcoutts> roundup?
05:05:15 <gour> http://roundup.sourceforge.net
05:05:25 * gour applied for a key
05:05:55 <dcoutts> gour, oh for bug/issue tracking
05:06:21 <gour> dcoutts:yes, but i like trac more
05:06:41 <gour> dcoutts: the point is to have email interface
05:07:19 <dcoutts> right
05:07:20 <gour> dcoutts: you have a gpg key?
05:07:24 <dcoutts> yep
05:09:21 <dcoutts> http://pgp.mit.edu:11371/pks/lookup?search=Duncan+Coutts&op=index
05:09:47 <gour> i found them, which one you prefer?
05:09:57 <dcoutts> http://pgp.mit.edu:11371/pks/lookup?op=get&search=0x383350B6
05:10:08 <dcoutts> the others are for gentoo manifest signing
05:10:20 <dcoutts> and are only valid for 6 months at a time
05:10:44 <gour> ok
05:22:02 <gour> dcoutts: hmm, it looks like evo does not like to encrypt message if sent to different addres than the key. is your uklinux.net email active?
05:22:15 <dcoutts> yep
05:22:19 <gour> ok
05:23:46 * gour thinks that gpg is a bit broken in evo..
05:25:25 <gour> dcoutts: encryption does not work, sent signed only
05:25:32 <dcoutts> ok
05:28:55 <ADEpt> Lemmih: hi. wanted to ask: any specific reasons for "catchDisconnect" not to catch all and every IO error?
05:29:28 <tre> lambdabot, pointless
05:37:57 <Lemmih> ADEpt: It should exit silently when the exception is a disconnect.
05:39:49 <ADEpt> Lemmih: let me rephrase. Suppose that remote side did a disconnect. In this case we will get "hGetChar: end of input" or something similar. It seems to be reasonable to catch THIS kind of disconnect in catchDisconnect, no?
05:42:05 <Lemmih> ADEpt: Well, it does catch all exceptions and rethrows them if isn't a disconnect.
05:42:49 <ADEpt> Lemmih: yes, but who will catch those rethrows?
05:43:35 <Lemmih> Noone. They're printed to stdout.
05:43:56 <ADEpt> Lemmih: :)
05:44:04 <Lemmih> Why do you wanna catch them?
05:44:46 <ADEpt> Lemmih: i'd rather print them to stdout via "debug", so when debug output is suppressed they will not "pollute" stdout
05:45:46 <Lemmih> Can't it wait till debug/=putStrLn? (:
05:46:08 <ADEpt> Lemmih: well, it sure can. Just reject my patch then :)
06:16:44 <gour> dcoutts: i changed password on wordpress.com to the one we use on regular site, but akismet key does not work, so i re-activated sk2. tomorrow i'l ltry to upgrade to wp2 and check again
06:17:05 <dcoutts> gour, ok
06:53:04 <Cale> *Main> let a = Set.fromList [1,2,3,4]
06:53:05 <Cale> *Main> let f x = Set.fromList [x, 2*x]
06:53:05 <Cale> *Main> a >>= f
06:53:05 <Cale> {1,2,3,4,6,8}
06:53:53 <Speck> Set is a monad now?
06:54:13 <Speck> (At least as far as Haskell is concerned...)
06:54:16 <Cale> Well, I figured out one trick.
06:54:26 <Cale> class Monad m a b where
06:54:26 <Cale>     return :: a -> m a
06:54:26 <Cale>     (>>=) :: m a -> (a -> m b) -> m b
06:54:34 <Cale> instance (Ord a, Ord b) => Monad Set a b where
06:54:35 <Cale>  ...
06:54:37 <Speck> Doesn't it need to be a functor to be a monad?
06:54:48 <Cale> class Functor f a b where
06:54:48 <Cale>     map :: (a -> b) -> (f a -> f b)
06:55:04 <Cale> oh, yeah, I neclected to include that constraint there
06:55:10 <Cale> neglected*
06:55:23 <Cale> class (Functor m a b) => Monad m a b where
06:55:36 <Cale> It's not that pretty, but it works.
06:55:51 <Cale> In some sense, it's too general.
06:56:07 <Speck> Well, sets are general.
06:56:22 <Cale> I mean, this way of defining the classes
06:56:56 <Cale> You really just want to constrain the parameters to f without allowing for arbitrary specific instances at various types.
06:58:12 <Speck> Hm, who should I talk to if I want to change my username on the new wiki. I want to use my real name instead of Speck.
07:01:01 <Speck> eh, what is my evil clone doing here
07:03:40 <H1ghlander> :o
07:03:52 <Speck> stupid irc client
07:04:28 * Speck wished Hircule were still being developed, and is inclined to pick it up himself.
07:07:18 <dcoutts> Speck, well tell us if you need any help on the Gtk2Hs side of things for that
07:07:33 <Speck> I'll keep it in mind :-)
07:07:53 <dcoutts> @where hircules
07:07:54 <lambdabot> I know nothing about hircules.
07:08:02 <dcoutts> @where+ hircules http://haskell.org/hircules/
07:08:03 <lambdabot> Done.
08:04:55 <lispy> morning
08:07:55 <edwinb> Hmm. ghc isn't supposed to say "panic! (the `impossible' happened, GHC version 6.4.1)" is it?
08:08:38 <Trevion> edwinb, sure it is.  That means you're doing something worth doing.
08:08:43 <SamB> edwinb: only when something happened that was not supposed to happen
08:09:18 <edwinb> Oh. Good. ;)
08:09:24 <edwinb> Now, if only I could actually reproduce it...
08:09:48 <SamB> edwinb: that is always nice!
08:09:57 <SamB> were you playing with TH?
08:10:05 <edwinb> No, it was really simple.
08:10:19 <edwinb> I changed the version number on a cabal package, and relinked something that used that package.
08:10:19 <gour> dcoutts: i tried again with akismet and not wp accepted the key. let's see how this plugins works..
08:10:24 <edwinb> and it panicked.
08:10:38 <gour> dcoutts: s/not/now
08:12:35 <SamB> Heffalump: okay, gmane has finally subscribed to the conjure list. mbox file, please ;-)
08:17:41 <Heffalump> prod me this evening (say in 5 hours time) if I don't send it to you before
08:35:10 <mjl69> I needed a calculator for a few quick calculations and ghc won out over the Apple widget.
08:35:39 <xerox> bc?
08:36:45 <wolverian> calc? :) (apcalc in debian)
08:38:28 <carp> hi edwinb 
08:38:30 <integral> perl compiles faster though
08:38:55 <int-e> dc *ducks*
08:39:00 <edwinb> Oh, hello carp. I didn't know you lived here...
08:39:31 <carp> I'm a recent visitor
08:40:23 <carp> you should come and visit us some time soon
08:41:19 <edwinb> Yes, that would be good.
08:44:11 <srle> is there function in haskell like:  isInt :: String -> Bool?
08:44:38 <mauke> @hoogle String -> Bool
08:44:39 <lambdabot> Network.URI.isURI :: String -> Bool
08:44:39 <lambdabot> Network.URI.isURIReference :: String -> Bool
08:44:39 <lambdabot> Network.URI.isRelativeReference :: String -> Bool
08:46:05 <srle> and, who to recover from error? read "5.5" :: Int. Is exception thrown or else?
08:46:35 <ibid> you can't really recover from that
08:46:44 <carp> edwinb: Conor says you're very welcome and perhaps we should head up for SPLS
08:46:52 <ibid> you need to check the syntax beforehand or to use shows
08:46:56 <ibid> argh, reads
08:47:42 <srle> ibid : why?
08:47:51 <ibid> srle: because
08:48:02 <srle> ibid : tnx
08:48:24 <ibid> srle: the error that read triggers there is of the "assertion failure" kind. it's not meant to be recoverable
08:48:29 <mauke> see also the functions in Numeric
08:48:33 <ibid> srle: but read is anyway just a wrapper for reads
08:49:12 <edwinb> carp: One of you could even give a talk if you came up ;)
08:49:15 <ibid> > reads "5.5"  :: Double
08:49:16 <lambdabot> Couldn't match `Double' against `[(a, String)]'
08:49:26 <ibid> > reads "5.5"  :: (Double,String)
08:49:27 <lambdabot> Couldn't match `(Double, String)' against `[(a, String)]'
08:49:32 <ibid> > reads "5.5"  :: [(Double,String)]
08:49:33 <lambdabot> [(5.5,"")]
08:49:38 <ibid> > reads "5.5"  :: [(Int,String)]
08:49:39 <lambdabot> []
08:49:47 <ibid> @type reads
08:49:48 <lambdabot> forall a. (Read a) => ReadS a
08:51:21 <srle> > read "5.5" :: Double
08:51:23 <lambdabot> 5.5
08:51:57 <ibid> (didn't we discuss this earlier today on this channel?:)
08:52:43 <srle> sin 4
08:52:50 <ibid> > sin 4
08:52:51 <lambdabot> -0.7568024953079282
08:53:19 <mjl69> thanks for calculator recommendations!  funny how it never occurred to me to see what's already on my system.  I guess since I have ghc open most of the time anyway it was just convenient at the moment.
08:53:48 <ibid> ghc is a fairly good calculator :)
08:53:54 <ibid> well, ghci
08:54:22 <ibid> and it's extensible, too, with a great extension language ;) (ghci the calculator, that is)
08:54:28 <dcoutts> gour, oh great.
08:54:50 <dcoutts> gour, are you planning to use that before upgrading to wp2 ?
08:55:01 <mjl69> how about loan calculator functions and stuff like that?  has anyone put together a useful calculation library like that?
08:55:14 <gour> dcoutts: it's already in use
08:55:19 <dcoutts> oh wp2 ?
08:55:21 <ibid> i once wrote an extension that allowed me to carry units with the values, so i got dimension tests for free when i calculated physics
08:55:28 <gour> dcoutts: no, just plugin
08:55:38 <dcoutts> gour, oh right
08:55:47 <dcoutts> gour, and it seems to work?
08:56:13 <gour> dcoutts: well, it accepted the key which was sent to me
08:56:56 <gour> dcoutts: under Manage menu, there is menu entry to check what's going on..
08:57:07 * dcoutts takes a look
08:58:27 <gour> (it is recommended to disable al lthe other spam-plugins)
08:58:57 <gour> so let's see how it works. we can always go back to  sk (now at 2.1)
08:59:42 <dcoutts> gour, sure
09:00:06 <dcoutts> nice, there's not much to configure with Askimet, which is nice
09:00:44 <gour> dcoutts: btw, i'm approaching theend of 14th chapter
09:00:59 <dcoutts> what's that chapter about?
09:01:26 <gour> algebraic data types
09:01:31 <dcoutts> good good
09:02:15 <gour> and simon introduces Maybe, Either, some 'lifting' with mapMaybe & maybe funcs
09:02:41 <gour> for error handling
09:03:53 <gour> (15th ch. is case study dealing with module system)
09:05:18 <mjl69> sounds like the book I'm reading :-)
09:05:37 <mjl69> I skipped a few of the exercises.  I should go back and do my homework.
09:05:54 <gour> mjl69: me too, there are too many :-)
10:37:19 <ulfdoz> @hoogle a -> b -> m b
10:37:20 <lambdabot> Control.Parallel.par :: a -> b -> b
10:37:20 <lambdabot> Control.Parallel.seq :: a -> b -> b
10:37:20 <lambdabot> GHC.Conc.par :: a -> b -> b
10:56:08 <SyntaxNinja> hi #haskell
10:59:24 <ptolomy_> AaaH. Intel Apple laptop!
10:59:29 * ptolomy_ 's head explodes.
11:00:39 <mornfall> lambdabot: pointless f x y = a x + b y
11:00:51 <mornfall> hmm, wrong bot?
11:01:06 <mauke> @pl f x y = a x + b y
11:01:08 <lambdabot> f = (. b) . (+) . a
11:03:02 <SamB> @timefor Heffalump 
11:03:03 <lambdabot> Unknown command, try @listcommands.
11:03:25 <SamB> @listcommands time
11:03:26 <lambdabot> No module "time" loaded
11:04:45 <SamB> why isn't lambdabot identified?
11:04:55 <SamB> @listmodules
11:04:56 <lambdabot> babel base code compose dice dict djinn dummy dynamic elite fact haddock
11:04:56 <lambdabot> help hoogle karma lShell localtime more pl plugs poll pretty quote search
11:04:56 <lambdabot> seen spell state system todo topic type version vixen where
11:05:14 <SamB> @localtime Heffalump 
11:05:16 <lambdabot> Local time for Heffalump is Tue Jan 10 19:04:52 2006
11:06:11 <SamB> hmm. does Heffalump have a strange definition of evening, a mis-set clock, a chat session in another timezone, or a jet-lagged laptop?
11:07:36 <Philippa> it's pitch black outside, that do?
11:08:03 <Philippa> 7's just about "early evening" anyway
11:09:15 <SamB> Philippa: well. the thing is he said "in 5 hours time" a little under three hours ago...
11:11:41 * Heffalump gets home
11:12:47 <Heffalump> I was a bit unclear, what I meant was "I'll do it this evening, prod me at the end of the evening (i.e. 11pm) if I don't"
11:12:52 <SamB> ah
11:13:10 <SamB> I didn't realize evening lasted that long
11:13:10 <Heffalump> anyway, I shall do it now.
11:13:16 <Heffalump> does for me :-)
11:13:46 <Heffalump> but I was also answering quickly and not applying very much thought
11:14:06 <SamB> @devils evening
11:14:09 <lambdabot> No match for "evening".
11:14:13 <SamB> aww
11:14:17 <Heffalump> what do you want me to do with this mbox?
11:14:32 <SamB> I want you to put it up somewhere and give me the URL
11:15:09 <Heffalump> done
11:16:24 <Heffalump> gah. gcc segfaulted trying to bootstrap ghc.
11:18:02 <SamB> typical!
11:18:38 <Heffalump> typical?
11:21:07 <SamB> well, okay. not quite.
11:21:22 <SamB> but GCC is known to do that sometimes when it gets strange programs...
11:21:34 <SamB> and if ever there was a source of strange programs, GHC is it
11:22:41 <SamB> clearly the answer is to write your own C compiler in Haskell
11:22:55 <Philippa> producing haskell code? ;-)
11:23:15 <SamB> well, maybe as an option, but normally producing ASM
11:53:54 <wilx> Heh, well you should report such crashes with preprocessed sources attached if you think it is GCC bug.
11:55:19 <SamB> wilx: course its a bug!
11:55:26 <Heffalump> I was about to say it's clearly a GCC bug, it segfaults, but it's running on qemu, so it's not 100% clearcut.
11:55:33 <SamB> segfaulting is nearly always a bug!
11:55:38 <SamB> hmm.
11:55:40 <SamB> on qemu...
11:55:42 <wilx> I guess.
11:55:51 <SamB> so it *could* be a qemu bug
11:55:55 <wilx> If it is any of the recent GCC versions you should really report it.
11:55:55 <Heffalump> on the plus side, my manager is the person who would be likely to look at the bug.
11:56:09 <SamB> gcc bug or qemu bug?
11:56:13 <Heffalump> the gcc bug
11:56:16 <wilx> Heh, really? You know something who works on GCC?
11:56:27 <wilx> Err, somebody :)
11:57:15 <Heffalump> it's not that uncommon..
12:01:05 <wilx> Heh, it is, imvho.
12:01:36 <Heffalump> there must be several tens of people who do
12:02:22 <Heffalump> and I work for a compiler group (though most of the group including me works on a proprietary compiler, not gcc)
12:02:27 <wilx> Sure, but it is not common for him/her to be your boss :)
12:02:36 <wilx> I see.
12:22:41 <Heffalump> oh, wow, this C file is 3MB preprocessed (and 1MB before preprocessing)
12:23:33 <Heffalump> and it doesn't segfault preprocessed. Bugger.
12:23:54 <SamB> so about how many people know any of these several tens?
12:41:54 <dcoutts> JaffaCake, about the warnings that people are complaining about: "warning: assignment discards qualifiers from pointer target type" perhaps ghc should call gcc with the "-Wno-cast-qual" flag
12:42:32 <dcoutts> since the FFI spec doesn't allow us to do anything about these warnings, and since we believe them to be harmless
12:44:51 <dcoutts> on the same theme, ghc could use gcc's -Werror-implicit-function-declaration flag
12:45:10 <ptolomy_> I doubt there are many more who can make this claim or would be willing to, but recently haskell got me laid.
12:45:22 <dcoutts> to catch more forcefully the cases where people forget to tell ghc about the header files.
12:45:53 <musasabi> ptolomy_: want to share it with us on #haskell-blah ? ;)
13:24:58 <orbitz> (a -> b -> b) -> b -> [a] -> b
13:25:09 <orbitz> the () signifty the first paremter is a function taking those types, aye?
13:25:18 <Cale> orbitz: yep
13:25:25 <orbitz> thank ya
13:25:33 <Cale> @type foldr
13:25:34 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
13:25:41 <orbitz> yeah that's wher ei got that from:)
13:26:01 <Cale> http://vx.hn.org/autoshare/folds.png -- some pictures of folds which I made
13:26:26 <orbitz> is 'fold' similar to reduce?
13:26:31 <Cale> yeah
13:26:41 <Cale> that's another common name for it
13:27:00 <Cale> > foldr (+) 0 [1..10]
13:27:01 <lambdabot> 55
13:27:02 <Heffalump> I think reduce implies an associativity property that means order doesn't matter.
13:27:09 <Heffalump> whereas folds have a direction
13:27:13 <orbitz> i am reading whyfp.pdf and it's reduce seems to act diffierent than common lisps, as ini need to specify some special arguemtns for common lisps to act the same as teh basic reduce in there, i think that paper uesrs miranda
13:27:16 <Heffalump> s/order/bracketing/
13:27:19 <orbitz> whic his quite similar to haskell IIRC
13:27:54 <SamB> orbitz: yes it is
13:28:20 <orbitz> i implemented factorial via creating a list and then fold'ing over it, is that evil or no?
13:28:37 <orbitz> factorial 1 = []; factorial n = n : factorial (n - 1)
13:28:53 <Cale> well, the CL reduce defaults to foldl, and if given :from-end t will give foldr
13:29:08 <SamB> orbitz: evil, no. probably not the most efficient...
13:29:16 <orbitz> SamB: i figurd
13:29:23 <orbitz> a decent way to play with lists/fold'ing though
13:29:29 <Cale> It's fine, though you should use foldl'
13:29:45 <Cale> > foldl' (*) 1 [1..20]
13:29:46 <lambdabot> 2432902008176640000
13:29:55 <SamB> orbitz: although usually you call that function something else
13:30:07 <orbitz> oh, i thouht foldr was the one that could be implemented with tail calls
13:30:13 <orbitz> SamB: yesh, i wasn't thinkign at the time
13:30:29 <Cale> foldl is the one with tail calls, foldr is the one with good laziness properties
13:30:42 <SamB> foldr is the one that is good for lazy things
13:30:55 <orbitz> why does foldr work ebtter for lazy things, i didn' quite follow that in YAHT
13:31:07 <SamB> foldl' is the one which doesn't smash into the end of the stack
13:31:08 <Cale> You hardly get the benefits of tail calls if foldl is lazy though, since it will build up a large expression which will only get evaluated at the end
13:31:31 <dons> moin
13:31:37 <Cale> So foldl' is used to force evaluation to occur as it goes along
13:31:43 <Cale> dons: morning
13:33:30 <dons> Lemmih, re your wiki comment, I think the data I = I !Int and -funbox-strict-fields was suggested by simonM as a nice way to get unboxed ints without ugly #'s
13:41:46 <Heffalump> is -funbox-strict-fields semantics-preserving?
13:42:21 <SamB> Heffalump: why do you think it only works on strict fields?
13:43:36 <dons> hmmm: /home/chakcvs/darcs/c2hs/_darcs/inventory: openBinaryFile: hardware fault 
13:43:43 <dons> not your everyday darcs msg
13:44:02 <Cale> ouch
13:44:16 <lispy> wow
13:44:38 <SamB> how?
13:44:57 <dons> not sure. it appeared in a cron job
13:46:46 <SyntaxNinja> eww
13:48:45 <lispy> i blame cron
13:49:06 <dons> well, it could be hardware.
13:49:20 <dons> wouldn't be the first time there's been a hardware failure.
13:49:27 <SamB> when does software ever know that?
13:49:41 <musasabi> the OS knows and returns a suitable errno.
13:49:56 <dons> errno, Samb?
13:50:38 <musasabi> that is EIO
13:50:42 <Heffalump> SamB: I'm just wondering what happens to the bottom value in the datatype.
13:51:09 <SamB> Heffalump: you aren't allowed to have bottom in a strict field anyway
13:51:14 <dons> Heffalump, you can still stick undefined in such a type, but it will get evaluated at program startup..
13:51:14 <Heffalump> does I still have a tag, or is it isomorphic to Int# ?
13:51:26 <dons> (/me knows this from experience)
13:51:35 <musasabi> "data I = I Int" is not the same as "data I = I !Int"
13:51:48 <Heffalump> if I write "data C = C I"
13:51:52 <musasabi> "data I = I !Int" is the same as "data I = I !Int" + -funbox-strict-fields
13:51:59 <SamB> Heffalump: probably GHC does not support unboxing multi-constructor datatypes yet
13:52:06 <Heffalump> what happens if I do C (error "foo")  ?
13:52:20 <dons> the error gets hit at startup
13:52:27 <SamB> dons: no!
13:52:39 <Heffalump> iff you use -unbox-strict-fields?
13:52:45 <Heffalump> IM -funbox..
13:52:47 <SamB> the error sits there until you try to do something with it
13:52:49 <SamB> either way
13:52:53 <dons> no?/
13:53:06 <Heffalump> SamB: in that case I is not isomorphic to Int#
13:53:10 <SamB> if you, on the other hand, write "data C = C !I"...
13:53:11 <dons> SamB, really?
13:53:18 <SamB> oh, wait.
13:53:23 <SamB> I got I mixed with Int
13:53:26 <dons> yeah, if it's strict. that's the interesting case.
13:53:29 <Heffalump> which is what I am trying to understand.
13:53:31 <SamB> you are confusing me
13:53:33 <SamB> !
13:53:41 <dons> sorry.
13:53:46 <SamB> no, not you
13:53:46 <Heffalump> data I = I !Int
13:53:49 <Heffalump> data C = C I
13:53:57 <dons> if you have C !I, and put error in it, it will be evaluated at  startup.
13:54:02 <SamB> hmm.
13:54:07 <Heffalump> I don't want C !I, I want C I.
13:54:08 <SamB> actually I am right.
13:54:12 <Heffalump> I want to know if I has any bottom values.
13:54:13 <dons> this is what i learnt from experience. bitter bug chasing experience
13:54:37 <SamB> dons: not startup
13:54:40 <Philippa> Heffalump: haskell-values or haskell-semantics-values?
13:54:43 <SamB> well, maybe sort of.
13:54:47 <Heffalump> Philippa: huh?
13:55:06 <SamB> but the exception will be thrown when only when you enter the C value...
13:55:12 <dons> SamB, oh, it might be at some other point, I guess. I only ever tried it on yi and hmp3 data structures that were global vars.
13:55:18 <Philippa> oh, wait. Yeah, never mind
13:55:25 <Philippa> not much of a distinction
13:55:34 <Heffalump> C (error "foo") `seq` 5
13:55:37 <Heffalump> what does that evaluate to?
13:55:47 <Heffalump> with my data declarations, and with and without -funbox-strict-fields
13:55:48 <musasabi> basically if it is unboxed bottom is lifted to the level of the constructor.
13:56:05 <musasabi> Heffalump: try it out?
13:56:17 <Lemmih> dons: I think it's an misinterpretation of what SimonM said.
13:56:20 <SamB> even without -funbox-strict-fields, C (error "foo") `seq` 5 ==> error "foo" with data C = C !I
13:56:23 <Heffalump> that'd be, like, effort, and all :-)
13:56:36 <Philippa> SamB: that's not what's being discussed though, no?
13:56:43 <Heffalump> I want data C = C I, as I've said, repeatedly.
13:56:44 <musasabi> while it is no effort on irc?
13:56:46 <SamB> okay.
13:56:47 * Heffalump goes to try it for himself.
13:57:04 <dons> Lemmih, ah. how so?
13:57:08 <SamB> C (error "foo") `seq` 5 ==> 5 with data C = C I
13:57:09 <Heffalump> musasabi: I was hoping that someone who understood what was going on could just tell me, but I was wrong.
13:58:07 <Lemmih> dons: Because you don't get any benefits when you add the box yourself.
13:58:33 <Heffalump> ok, in all cases I get 5.
13:58:37 <dons> ah, yes :) of course. except you don't need GHC.Base
13:58:38 <SamB> Lemmih: huh?
13:58:40 <Heffalump> So I is not isomorphic to Int#
13:58:53 <Lemmih> dons: 'data I# = I# Int#' is pretty much the same as 'data I = I !Int' when !Int gets unboxed.
13:59:20 <Lemmih> You're better off just making the argument strict in the function and let GHC handle the unboxing.
14:00:19 <dons> oh, maybe you should try that. a a `seq` b `seq` False = undefined guard, perhaps
14:00:44 <Lemmih> SamB: 'data I = I !Int' ~= 'newtype I = I Int'.
14:00:47 <Heffalump> does the # in I# in that data declaration mean anything?
14:01:06 <Heffalump> or is it just to reduce confusion?
14:01:08 <musasabi> Heffalump: that you are not supposed to mess with it.
14:01:12 <musasabi> nothing else.
14:01:35 <Heffalump> so what is being done with this I value?
14:02:00 <Mitar> is it possible to eta reduce: def v = fromJust . lookup v $ tef to something nice?
14:02:22 <Heffalump> @plugs \v -> fromJust . lookup v $ tef
14:02:23 <Lemmih> 'data Int = I# Int#' I meant.
14:02:23 <lambdabot> Unknown command, try @listcommands.
14:02:29 <Heffalump> @pl \v -> fromJust . lookup v $ tef
14:02:30 <lambdabot> flip (fromJust .) tef . lookup
14:02:32 <Heffalump> doh, thinko
14:02:55 <Heffalump> err, sorry, I may have got the precedence wrong there
14:03:01 <Heffalump> @pl def v = fromJust . lookup v $ tef
14:03:02 <lambdabot> def = flip (fromJust .) tef . lookup
14:03:05 <Heffalump> ok, I didn't.
14:04:05 <Mitar> aa
14:04:09 <Mitar> there is flip
14:04:10 <Mitar> nice to know
14:05:17 <dons> hmm. we realy need a command line interface to lambdabot
14:05:30 <dons> then people could add editor bindings and so on.
14:06:19 <dons> i'd like it so I could bind @pl in vim, at least.
14:09:22 * Heffalump is a bit confused by what unboxing does and doesn't allow.
14:09:45 <Heffalump> there's basically no way to make new unboxed types, is there?
14:10:05 <dons> not that I know of. without adding new primops.
14:10:08 <Heffalump> apart from using unboxed tuples for return values
14:10:23 <dons> and that yeah.
14:10:26 <SamB> Heffalump: unboxing is just an optimization
14:10:39 <Heffalump> and is that a fundamental restriction, or just "they haven't got round to doing more"?
14:10:52 <Heffalump> (fundamental in the sense of "very hard to make GHC support more")
14:11:13 <SamB> what good would it do?
14:11:49 <Heffalump> well, you can't make an efficiently stored data structure, as things stand
14:12:08 <SamB> its not like C where you can only use certain syntax with primitive types...
14:12:24 <Heffalump> how would you get a value that is just two Int#s in memory and nothing else?
14:12:29 <Lemmih> Heffalump: I don't think unboxing would help there.
14:12:46 <Philippa> how're unboxed tuples represented?
14:12:56 <Philippa> aside from "in registers where possible"?
14:13:14 * Heffalump reads about UNPACK
14:13:24 <dons> hmm. time to read 'unboxed values as first class cit
14:13:28 <dons> izens
14:13:50 <dons> Philippa, don't they encode stack allocation?
14:13:57 <dons> been a while since I checked this.
14:14:00 <SamB> Philippa: just stuffed where they'll fit, most likely...
14:14:21 <Heffalump> ok, that does give you what I was asking for
14:14:44 <Heffalump> (UNPACK is what -funbox-strict-fields does on a field-by-field basis)
14:14:49 <Mitar> what is the way to convert a associations list to the Array?
14:15:03 <Heffalump> @type Data.Array.listArray
14:15:05 <lambdabot> forall e i. (GHC.Arr.Ix i) => (i, i) -> [e] -> GHC.Arr.Array i e
14:15:11 <Heffalump> not that :-)
14:15:31 <dons> being able to declare new unboxed values would be very powerful -- device drivers.
14:15:33 <Heffalump> @type Data.Array.accumArray
14:15:34 <lambdabot> forall e i a.
14:15:34 <lambdabot> (GHC.Arr.Ix i) =>
14:15:34 <lambdabot> (e -> a -> e) -> e -> (i, i) -> [(i, a)] -> GHC.Arr.Array i e
14:15:57 <Heffalump> dons: arguably the bit manipulation ideas the Oregon people had at ICFP would be better for that
14:16:04 <SamB> Heffalump: oh, you want to do it in an unpointed way?
14:16:04 <Heffalump> Mitar: that
14:16:19 <Heffalump> SamB: unpointed?
14:16:26 <dons> Heffalump,maybe. but not with Nats on the type level :)
14:16:37 <dons> a bitdata would also be nice, yes.
14:17:50 <dons> oh, the 'unboxed values' paper describes: data unboxed C# = Red#  |Green# | ...
14:18:18 <ulfdoz> For some unknown reason, I get read no parse, when loading module into ghci and executing main. call shound be (read "17.5") :: Double, any hints?
14:18:42 <Heffalump> this one? http://portal.acm.org/citation.cfm?id=128066 (PJ+Launchbury, 1991)
14:19:04 <SamB> > read "17.5"
14:19:05 <lambdabot> Add a type signature
14:19:09 <SamB> > read "17.5" :: Double
14:19:11 <lambdabot> 17.5
14:19:15 <SamB> no hints!
14:19:16 <dons> spj and launcbury, 91, "Unboxed values as first class citizens  in a non-strict functional language" ?/
14:19:31 <Heffalump> yes
14:19:42 <dons> that's the one i'm looking at.
14:19:46 <Heffalump> gah, I'll have to jump through hoops to get a copy of that
14:20:10 <ulfdoz> Ah, It seems to be the following newline.
14:20:15 <SamB> Heffalump: you could also look on SPJ's website
14:20:19 <dons> Heffalump, it'll be on spj's page.
14:20:23 <SamB> @google simonpj papers
14:20:25 <lambdabot> http://research.microsoft.com/Users/simonpj/papers/Proposal.html
14:20:33 <SamB> try http://research.microsoft.com/Users/simonpj/papers/
14:20:34 <Heffalump> oh, duh
14:20:38 <Heffalump> I'd forgotten he does that
14:20:49 <Heffalump> ta
14:20:53 <SamB> he has a bunch of papers up there, including some that don't seem to be written by him
14:21:41 <SamB> remember, just because ACM has it, doesn't mean they are the only ones!
14:23:08 <Mitar> is there better way to get all values from assoc list then: snd . unzip $ asoclist
14:23:35 <dons> map snd ?
14:23:42 <tic> heh :)
14:23:47 <Mitar> heh
14:23:48 <Mitar> nice
14:23:59 <Mitar> this map is really great
14:24:12 <Mitar> it is probably most used function
14:24:19 <tic> yes. :)
14:24:29 <Mitar> and folding is also nice
14:24:31 <SamB> besides id under its various guises
14:25:11 <Mitar> so map snd would be probably better choice
14:25:26 <Heffalump> does that paper describe what is actually done in GHC?
14:25:31 <Heffalump> (or a subset of it, or whatever)
14:25:42 <Mitar> or is there no difference and is it just a matter of taste?
14:25:43 <SamB> I have never, ever heard of "data unboxed"
14:25:53 <Heffalump> SamB: I think they introduce it for the purposes of exposition
14:26:19 <SamB> Mitar: people who think "snd . unzip $ asoclist" is nicer than "map snd" are just insane
14:26:38 <Mitar> ok, but what about perfomance?
14:26:47 <SamB> Heffalump: you could look at your lib sources to see...
14:27:02 <SamB> Mitar: map snd is at least as good
14:27:11 <SamB> probably a good deal better
14:27:33 <Heffalump> SamB: YM the GHC sources..
14:27:37 <Philippa> yes, it'll generate less crap
14:27:42 <Philippa> er, garbage :-)
14:27:45 <SamB> depends if the compiler is smart enough to optimize "snd . unzip $ asoclist"
14:27:52 <Heffalump> Philippa: which will?
14:27:54 <Philippa> SamB: you mean, to map snd? ;-)
14:27:58 <Philippa> snd . unzip
14:28:09 <musasabi> if it clever it will optimize the map too.
14:28:15 <Heffalump> what's the garbage in map snd?
14:28:18 <SamB> musasabi: to what?
14:28:29 <musasabi> SamB: depends on what it is applied to.
14:28:34 <Philippa> sorry, I meant that one's /more/ garbage
14:28:40 <SamB> musasabi: sure, it would likely inline...
14:29:04 <Philippa> (it may build the conses for the intermediate list)
14:29:20 <SamB> but I meant it depends whether the compiler can tell that "snd . unzip $ asoclist" should be written "map snd"
14:29:20 <Heffalump> yeah, I doubt snd . unzip will deforest.
14:29:23 <Heffalump> map snd really ought to
14:29:26 <musasabi> SamB: e.g. map snd [ (x,2*x) | x <- [1..100]], could optimize the tuples wholly away.
14:29:45 <Heffalump> i.e. be a good producer and consumer
14:29:52 <Heffalump> whereas snd . unzip will just be a good consumer
14:30:51 <Mitar> thanks
14:31:10 <palomer> @type unzip
14:31:12 <lambdabot> forall b a. [(a, b)] -> ([a], [b])
14:33:26 * Philippa is reading Boquist's PhD thesis and just had a cute thought: I think deepSeq is expressible in GRIN
14:34:15 <SamB> Philippa: how?
14:34:31 <SamB> doesn't that have one big extensible ADT?
14:34:33 <Philippa> SamB: the same way you build eval in it, only recursively
14:34:59 <Philippa> it might need building per-app though
14:35:40 <SamB> per compilation-unit at least
14:35:50 <SamB> as much as you can have those with GRIN
14:36:00 <Heffalump> how is it different from deepSeq in Core, then?
14:36:11 <SamB> Core doesn't have one big ADT?
14:36:56 <Heffalump> sorry, I may be misunderstanding since I don't know anything about GRIN. But deepSeq can presumably be written in Core on a per-app/per-compilation unit basis.
14:37:06 <Heffalump> So why is it interesting that this can be done in GRIN too?
14:37:06 <SamB> @hoogle deepSeq
14:37:07 <lambdabot> No matches found
14:37:29 <SamB> Heffalump: you can't do generics in Core exactly
14:38:00 <Heffalump> oh, do you mean you can write deepSeq once in GRIN, but have to rebuild it per-app/compilation unit?
14:38:02 <ulfdoz> f$%&, I'm my biggest enemy. :(
14:38:37 <Philippa> I'll need to read more of the paper and see what form everything's expected to be in before handing off to the next code generator. Might well be
14:39:43 <Philippa> It may be deepSeq can be a one-off but needs a data table that's built per app
14:40:21 <Philippa> that said, the data's probably there in Boquist's GC implementation anyway
14:41:34 <Heffalump> deepSeq is a hack anyway
14:41:49 <Philippa> in what sense?
14:41:59 <Philippa> I guess a strictness monad'd be better sometimes
14:42:11 <Philippa> (see "everything should be in a monad" and relatives)
14:42:16 <Heffalump> it's overkill, and it's a separate pass
14:42:33 <Heffalump> (I'm not saying I don't use it, but I generally feel like it's a last resort when I do)
14:42:41 * Philippa nods
14:42:49 <Heffalump> s/it's a last resort/it's a last resort and I'm being personally lazy/
14:43:07 <Philippa> a strictness monad, the identity monad and monad-polymorphic code'd be nicer in one sense (eliminating the pass)
14:43:14 <Philippa> heh
14:43:22 <Philippa> ITYM it *should* be a last resort
14:43:30 <Heffalump> whatever :-)
14:43:34 <Heffalump> what's a strictness monad, then?
14:43:59 <Philippa> bind looks like bind in the identity monad only with a seq involved
14:44:06 <Heffalump> deepSeq *should* be unnecessary, not just a last resort
14:44:30 <Philippa> on what particular grounds?
14:44:57 <Heffalump> well, the existence proof that it's unnecessary is that you can rewrite it.
14:45:22 <Heffalump> the more sensible explanation is that you can fold it into the data generation
14:45:39 <Heffalump> thus eliminating the extra pass it imposes
14:46:16 <Philippa> hence strictness monad
14:47:12 <Heffalump> hmm. I see yet another application for my (hypothetical) TH monadifier.
14:47:35 <dcoutts> or that Haskell refactorer
14:47:43 <dcoutts> "monadify!"
14:47:52 <Heffalump> you can't edit that, though
14:48:10 <Philippa> you can edit the output, OTOH
14:48:36 <Heffalump> doesn't the strictness monad fix evaluation order, btw?
14:48:50 <Heffalump> why is editing the output useful?
14:49:06 <Philippa> further optimisation-by-hand work
14:49:17 <Philippa> (eg if you have a better evaluation order for something)
15:43:54 <dons> @pl map \(x,y) -> (f x, f y)
15:43:55 <lambdabot> (line 1, column 5):
15:43:55 <lambdabot> unexpected "\\"
15:43:55 <lambdabot> expecting variable, "(", operator or end of input
15:44:16 <dons> @pl map (\(x,y) -> (f x, f y))
15:44:17 <lambdabot> map (f *** f)
15:44:20 <dons> good bot.
15:44:26 <monochrom> *** ?
15:44:41 <monochrom> @index ***
15:44:42 <lambdabot> Control.Arrow
15:44:49 <monochrom> Oh God.
15:49:13 <Heffalump> lol
15:49:28 <Heffalump> @type (Control.Arrow.***)
15:49:29 <lambdabot> forall (a :: * -> * -> *) c' c b' b.
15:49:29 <lambdabot> (Control.Arrow.Arrow a) =>
15:49:29 <lambdabot> a b c -> a b' c' -> a (b, b') (c, c')
15:49:46 <Heffalump> so that's not type equivalent
15:53:12 <Igloo> Why not?
15:55:35 <Heffalump> @type map \(x,y) -> (f x, f y)
15:55:37 <lambdabot> parse error on input `\'
15:55:58 <Heffalump> @type map (\(x,y) -> (f x, f y))
15:56:00 <lambdabot> Not in scope: `f'
15:56:00 <lambdabot>  
15:56:00 <lambdabot> <interactive>:1:21: Not in scope: `f'
15:56:05 <Heffalump> @type \f -> map (\(x,y) -> (f x, f y))
15:56:06 <lambdabot> forall b a. (b -> a) -> [(b, b)] -> [(a, a)]
15:56:15 <Heffalump> @type \f -> map (f *** f)
15:56:16 <lambdabot> Not in scope: `***'
15:56:28 <Heffalump> @type \f -> map ((Control.Arrow.***) f f)
15:56:30 <lambdabot> forall b c. (b -> c) -> [(b, b)] -> [(c, c)]
15:56:34 <Heffalump> oh. :-)
15:56:43 * Heffalump applies brain
16:03:46 * palomer thinks that we need a haskell keyboard
16:03:48 <palomer> who's with me?
16:04:16 <basti_> one word: macros!
16:04:26 <palomer> macros?
16:04:32 <basti_> yes.
16:04:54 <basti_> like, editor.
16:05:04 * basti_ is being unverbose today.
16:05:16 <Trevion> Or like keyboard.
16:05:50 <Trevion> Some keyboards - I think mainly aiming for gamers - have a number of programmable keys.
16:06:02 <monochrom> hahahaha
16:06:14 <star-trekio> well
16:06:23 <monochrom> I also have a voice command device.
16:06:26 <star-trekio> what does haskell do better than java perl or ruby?
16:06:34 <star-trekio> gime some reasons to learn the bugger
16:06:45 <star-trekio> will it save me money in larger systems?
16:07:43 <monochrom> HaskellDB is a type-safe and straightforward library for talking to relational databases.
16:07:52 <dons> it's better at writing large systems.
16:08:01 <Philippa> it beats the pants off all three for 'language' manipulation, too
16:08:07 <monochrom> So that's one thing Haskell (ghc anyway) is better than java perl and ruby.
16:08:08 <Philippa> which can turn out to mean a lot of stuff
16:08:16 <Philippa> you know how perl has pattern-matching on text? Haskell has it on data
16:08:44 <dons> it uses less memory, is faster,  and irequires much less code to solve problems in haskell than in java
16:08:55 <Heffalump> palomer: http://www.artlebedev.com/portfolio/optimus/
16:09:01 <palomer> Heffalump: yeah, just saw that
16:09:15 <Philippa> it's easier to be certain about things in Haskell, and it's easier to express 'architectural' thought in it than in perl, ruby or java
16:09:27 <palomer> Heffalump: we need to get one of those and add keys like "arrow" and "forall" and "exists" and "Int" and "Bool" and "do"
16:09:35 <Heffalump> :-)
16:09:42 <Philippa> many "design patterns" are represented by type signiatures, one line functions or datatypes (or if you're unlucky, a combination of all three) in haskell
16:10:17 <dons> yes, it's a lot more expressive. so no need for mindless patterns. you abstract
16:10:22 <palomer> > case "hello" of ['h',_,_,'/',..] -> 4
16:10:23 <lambdabot>  parse error on input `..'
16:10:33 <palomer> how do I pattern match on strings?
16:11:01 <basti_> > case "hello" of [a,b,c,d,e] -> d
16:11:01 <palomer> higher order patterns looks like a promising programming feature
16:11:02 <lambdabot> 'l'
16:11:14 <Philippa> palomer: parsec :-)
16:11:20 <palomer> basti_: but I want to match a string starting with h and having f as a second character?
16:11:23 <Philippa> palomer: or treat them as list-of-char
16:11:24 <monochrom> > case "hello" of 'h':_:_:'l':_ -> 4
16:11:26 <lambdabot> 4
16:11:31 <palomer> oh, good point
16:11:48 <palomer> with higher order patterns, you could apply regular expressions to _any datastructure_
16:12:01 <star-trekio> wow
16:12:05 <star-trekio> and its all free?
16:12:16 <Philippa> the compiler and many libs are, yeah
16:12:26 <Philippa> I believe it's seen some commercial uses for which the code isn't available
16:12:37 <star-trekio> wow
16:12:42 <star-trekio> is it a form of lisp?
16:12:52 <basti_> >_<
16:12:56 <palomer> no.
16:12:58 <basti_> it has lambdas.
16:13:03 <monochrom> When I took a public exam in Hong Kong, the English composition exam gave the choice of three titles.  One was "The best thing is free."  I now know how to write that.
16:13:14 <basti_> it is strictly typed
16:13:18 <star-trekio> oh
16:13:20 <palomer> monochrom: you're kidding me
16:13:24 <star-trekio> how does that afect things
16:13:25 <Philippa> it's somewhat related to lisp, but the branch is waaaay up the family tree
16:13:31 <star-trekio> ok
16:13:36 <palomer> what's the best thing?
16:13:37 <Philippa> it's a good thing, you can prove many things with the type system
16:13:38 <basti_> star-trekio: no segfaults
16:13:49 <Philippa> you can tell a given piece of code doesn't access the disk, for example
16:13:50 <star-trekio> so its very safe to program in?
16:13:53 <Philippa> yep
16:13:57 <Igloo> Heffalump: Is there a price for those keyboards?
16:14:02 <star-trekio> tha tis huge for larger systems yes
16:14:10 <star-trekio> safety
16:14:11 <basti_> Igloo: they are sci fi
16:14:14 <Heffalump> Igloo: nafaik
16:14:20 <basti_> its just a study
16:14:36 <basti_> nobody will build these keyboards, and if they do, there will be no software to make sense of it
16:15:13 <palomer> these keyboards will rock
16:15:17 <basti_> -would-
16:15:22 <palomer> will!
16:15:39 * Igloo suspects software would appear fairly rapidly after non-insanely-expensive keyboards appeared
16:15:51 <basti_> yea, like if the 3 possible uses and 3 years of software development would justify it...
16:16:00 <star-trekio> I read somewhere that large systms get confusing and haskell ends up as a bunch of functions
16:16:06 <star-trekio> can haskell scael up well?
16:16:09 <basti_> I mean I'm typing blind anyway.
16:16:14 <star-trekio> and not become confusing
16:16:28 <palomer> well
16:16:32 <basti_> star-trekio: well...
16:16:33 <palomer> looks like I'll never be using evolution again
16:16:45 <Igloo> Hmm, size might be an issue, actually
16:16:53 <palomer> star-trekio: once it gets higher order modules, sure
16:17:02 <palomer> higher orderness is the future!
16:17:42 <Philippa> star-trekio: it's known to do fairly well into tens of thousands of lines of code. It's also much easier to unravel large systems on average due to the lack of side-effects
16:17:43 <basti_> no, higher order is what has been missing from programming all the time ^^
16:18:05 <palomer> first you had functions
16:18:10 <palomer> and then came... higher order functions!
16:18:19 <basti_> lambda was first.
16:18:40 <palomer> lambda is pointless without HOF
16:18:46 <Heffalump> # in the beginning was the lambda
16:19:40 <Philippa> # in the beginning there was church, and church had a lambda ?
16:19:42 <ndm> star-trekio, have you seen GHC - it's 10000's of lines
16:19:52 <palomer> I heard it was half a million
16:19:59 <palomer> which, to me, makes _no_ sense
16:20:18 <palomer> haskell's type system isn't that complicated
16:20:31 <Philippa> the type system isn't all it deals with. There's a lot of optimisation in there
16:20:33 <palomer> neither is parsing
16:20:50 <Philippa> plus the RTS does quite a lot. I thought the figure was 50KLoC though
16:20:55 <palomer> sml is the world's greatest optimising compiler
16:20:56 <basti_> you could do a simple wc -l ;)
16:21:00 <palomer> and it's nowhere near that number
16:21:03 <Heffalump> palomer: you mean mlton?
16:21:07 <palomer> err, yeah
16:21:08 <palomer> mlton
16:21:14 <basti_> instead of debating :D
16:21:40 <ndm> Yhc is  23578
16:21:50 <Heffalump> oh, how is that going?
16:21:56 <ndm> quite nicely
16:21:59 * basti_ goes nighty
16:22:06 <Heffalump> can it compile the entire world yet? :-)
16:22:08 <ndm> its nearly got integrated hat-trace generation
16:22:15 <ndm> it can barely compile everything
16:22:29 <ndm> but entirely due to missing libraries, and some annoying mini-bugs
16:22:47 <ndm> so as far as a compiler goes, its pretty much there, just tweaking required
16:23:08 <ndm> just everyone keeps going off with insane features, rather than finishing the dull bits :)
16:23:08 <Heffalump> missing libraries? Aren't most just pure Haskell?
16:23:26 <ndm> they are, no one has been bothered to cvs get them and run cpphs over them :)
16:23:44 <Igloo> A lot are modern Haskell, not H98
16:23:47 <Heffalump> and fix all the (GHC|NHC|Hugs) assumptions ;-)
16:24:02 <ndm> indeed, that might take a while
16:24:14 <ndm> we're also rewritting the type checker
16:24:14 <palomer> ghc should publish it's own standard above haskell98
16:24:28 <SamB> palomer: would be sorta nice
16:24:29 <palomer> ndm: how are you type checking?
16:24:30 <ndm> which will hopefully give us some weird type extensions
16:24:37 <Philippa> that would rather defy the point of having extensions, no? You need a /common/ standard
16:24:46 <palomer> ndm: are you using references and in place unification?
16:24:48 <ndm> http://yhc06.blogspot.com/2006/01/more-on-type-checking.html
16:24:52 <Philippa> (and too many of the fun things are still WIP - fundeps're still being looked at, for example)
16:25:16 <ndm> palomer, i'm not personally doing the type checker, but the person who is wrote the above blog post
16:25:26 <ndm> he's either going for Neil Typing, or Olaf Typing :)
16:25:53 <palomer> ndm: got a paper on olaf's method?
16:26:04 <SamB> ndm: I haven't heard of Neil Typing
16:26:10 <SamB> is it as crazy as Olaf Typing?
16:26:23 <ndm> palomer: http://yhc06.blogspot.com/2005/12/yhc-and-types.html, a ref at the bottom
16:26:29 <ndm> SamB, crazier :)
16:26:36 <ndm> and much less well defined
16:26:41 <SamB> ndm: I did not know that such was possible!
16:26:57 <ndm> SamB: http://www.livejournal.com/users/nmitchell/79435.html - a rough overview of some bits
16:27:14 <ndm> of Neil typing
16:27:14 <SamB> I'm not sure what Olaf Typing is either, but I at least know what the name Olaf means
16:27:24 * Heffalump gets distracted by ndm's perpetual motion machine
16:27:28 <ndm> Olaf's typing is a pure combination approach
16:27:34 <ndm> * combinator
16:27:41 <Heffalump> (I can explain why it doesn't work, FWIW)
16:27:44 <ndm> Heffalump: have you figured out why it won't work?
16:27:50 <palomer> is olaf's method completely different?
16:27:50 <ndm> cool, why?
16:27:59 <Heffalump> the gas would condense on the way up
16:28:24 <ndm> palomer, its a compositional approach based on combinators, i know nothing more (read the paper, understood nothing)
16:28:38 <ndm> how? O2 and H2 don't condense at those sort of termperates
16:28:47 <ndm> only H2O
16:29:04 <palomer> ndm: have you ever implemented type inference?
16:29:19 <ndm> palomer, only once, and only briefly
16:29:24 <Heffalump> how do you expect to maintain those temperatures in a closed system?
16:30:06 <Heffalump> actually, a simpler argument is that it'll just stop rising
16:30:08 <ndm> it would have to get really cold for O2 and H2 to condense - i hadn't thought about temperates though to be honest
16:31:16 <Heffalump> what gas would you use for the white thing?
16:31:17 <ndm> why would the gas stop rising? i guessed gas being lighter would displace the water
16:31:35 <ndm> O2 and H2, oxygen and hydrogen
16:31:52 <ndm> the whole point is that the water (H2O) and the gases are the same molecules
16:32:20 * Heffalump thinks it through a bit more carefully
16:32:28 <Igloo> Where's the description?
16:33:10 <ndm> http://www.nmitchell.co.uk/articles/perpetual.htm
16:33:10 <Heffalump> oh, duh, it's zero-sum.
16:33:16 <Heffalump> (as one would expect)
16:33:51 <ndm> what bit is zero sum, the top and the bottom chemical equations are
16:34:00 <ndm> but hte power comes from the distance between them
16:34:08 <Heffalump> yes, as is the displacement of the liquid and the gas
16:35:08 <ndm> yes, but they displace each other, which causes movement
16:36:33 <Heffalump> oh, got it.
16:36:42 <Igloo> Isn't friction why it won't work?
16:36:44 <Heffalump> when you turn water into gas, it expands
16:37:02 <Heffalump> to expand, it has to move a huge mass of water on top of it
16:37:16 <Heffalump> so to do the conversion, you have to supply more energy than you get out at the top
16:37:42 <Heffalump> Igloo: friction is why you'd lose energy and it's worse than zero sum
16:37:43 <ndm> i guess that pressure is a function of the chemical equation then
16:37:58 <Heffalump> ndm: well, you can look at it two ways
16:38:04 <ndm> so the top equation and the bottom equation are not zero sum, because of the difference in presssure
16:38:12 <Heffalump> the normal way chemical equations are quoted is certainly at a certain temperature and pressure
16:38:30 <Heffalump> but another way of looking at it is to consider the equation in vacuo, and then consider the energy change of the pressure involved
16:39:05 <ndm> yes, ah - thats almost certainly the "flaw" in this machine
16:39:10 <ndm> i'll update teh website tomorrow
16:40:42 <Pseudonym> Sorry, where's this perpetual motion machine?
16:40:48 <Heffalump> on the subject of updating wrong websites, I emailed the explanation requested at the bottom of http://henning.makholm.net/hwracist several months ago, and it still hasn't changed. Most annoying.
16:41:01 <Heffalump> gravity based one on http://www.nmitchell.co.uk/articles/perpetual.htm
16:42:12 <Pseudonym> OK, question: How is the liquid turned into gas and back again?
16:42:32 <star-trekio> I displace gas from my ass
16:42:34 <star-trekio> ok
16:42:40 <star-trekio> why haskell over lisp?
16:42:45 <ndm> Pseudonym, a chemical equation - you can combine o2 and h2 to make h2o with a bang :)
16:42:58 <ndm> star-trekio: haskell has types, they mean you make less mistakes at runtime
16:43:03 <Pseudonym> Yes, but how?
16:43:04 <ndm> its a LOT nicer syntax
16:43:12 <Pseudonym> The only way I know to hydrolise water is to give it energy.
16:43:23 <Heffalump> Pseudonym: the idea was that the conversion back and forth would be zero-sum
16:43:30 <Heffalump> however, if you consider the ambient pressure, it isn't
16:43:55 <ndm> and its a pure language
16:44:06 <ndm> with lisp you can "cheat", by doing things like set!, not in haskell
16:44:22 <Pseudonym> True.  If you make the thing really tall, the pressure is greater at the bottom than at the top.
16:44:40 <sproingie> even assuming that gas exchanger thingie is a perpetual motion machine (which it isn't), it certainly stops being one the moment you add fins or turbines
16:45:06 <Pseudonym> You might be able to turn this into a solar power source.
16:45:23 <Heffalump> sproingie: you have to notice the energy imbalance in the conversions caused by pressure to show that, though
16:45:34 <Heffalump> otherwise, potential energy appears out of nowhere at both conversions
16:45:47 <sproingie> yay free energy
16:45:56 <Pseudonym> The only reason that gas rises is that it's displaced by something else.
16:45:57 <Heffalump> which definitely would be a perpetual motion machine even with fins and turbines :-)
16:46:17 <SamB> Heffalump: assuming they were not too heavily loaded
16:46:22 <Heffalump> (which are mostly irrelevant, because you have friction anyway. If the device can keep going for ever without fins and turbines, it's still generating energy)
16:47:21 <Heffalump> SamB:  a heavy load would just slow down the rate at which the device operated, unless it was so heavy it could actually keep liquid suspended above a gast
16:47:25 <Heffalump> s/gast/gas/
16:47:35 <SamB> hmm?
16:47:52 <sproingie> i'm agast at such a typo
16:48:24 <Heffalump> if the turbines are heavily loaded, they will slow down the rate at which the gas rises and the liquid falls
16:48:47 <Heffalump> in the limit, you will end up with just gas at the bottom and just liquid at the top
16:49:01 <Heffalump> if your turbine is so heavily loaded it can resist that pressure, then the system grinds to a halt
16:49:07 <Heffalump> otherwise, it will keep going, albeit slowly
16:49:11 <star-trekio> the rate of gas from my ass is larged when i drink thsoe liquid yogurt things at 99 cent store
16:49:22 <star-trekio> they make me fart like a popcorn machine
16:49:26 <sproingie> thanks for sharing that
16:49:39 <star-trekio> hey
16:49:41 <star-trekio> np
16:50:17 * Igloo wonders why henning.makholm rings a bell. Is he a Haskeller or Debianite or somesuch?
16:51:24 <Heffalump> he gave a talk, barefoot, at ICFP 05
16:51:45 <Heffalump> about some complicated and clever system for dealing with modules
16:51:54 <Igloo> Ah, OK
16:52:15 <Igloo> You should phone him
16:52:49 <Heffalump> I think he may be a Debianite too, but I don't think he's a Haskeller.
16:52:55 <Igloo> (http://henning.makholm.net/)
16:53:13 <Heffalump> cos he doesn't like it? :-)
16:53:46 <Igloo> I'd have suggested it even if he didn't say that  :-)
16:54:23 <JKnecht> seems like pretty petty shit.
16:54:54 <Heffalump> I find those questionnaires annoying too. But I think he's being a bit extreme.
16:54:54 <JKnecht> maybe that kind of stuff comes standard with savanterie.
16:55:25 <Heffalump> (and it didn't take me very much research at all to find the legislation that underlies them)
16:55:36 <ndm> don't those questionaires usually come with a "choose not to disclose" option?
16:56:05 <Heffalump> I believe so
16:57:08 <Heffalump> if my answer would have put me in an obvious majority group, I would have not answered them
16:57:23 <Heffalump> (so as to reduce the chances of the institution seeming racist)
16:57:38 <ndm> i occasionally tick "do not disclose"
16:57:48 <ndm> just for a laugh really
16:57:52 <Heffalump> though that kind of trickery is a bit more complicated when applying for jobs, rather than when being surveyed in a job
16:59:28 <ndm> anyway, goodnight - someone wants to have a meeting with me at 9:30 in the morning (silly people)
17:30:37 <star-trekio> ok
17:30:50 <star-trekio> do u ned to use  a data base with haskell
17:30:55 <star-trekio> for big projects
17:30:59 <star-trekio> or can one simply use
17:31:12 <star-trekio> like hashes
17:31:15 <ptolomy> star-trekio, Depends if your big project needs a database without haskell.
17:31:15 <star-trekio> or something
17:31:23 <sproingie> is there a "bob the angry flower" treatise on use of the letter 'u'?
17:31:28 <star-trekio> lol
17:31:35 <sproingie> not to mention lol
17:31:37 <star-trekio> its ok bob wont mind 
17:31:40 <star-trekio> lol
17:31:41 <star-trekio> its
17:32:08 <star-trekio> are databases needed?
17:32:16 <star-trekio> or unneccesry complications?
17:32:18 <Pseudonym> sproingie: No, but I'm certain there's one on proper capitalisation.
17:32:42 <Pseudonym> One of the Rules of Usenet is that every grammar flame contains at least one grammatical error.
17:32:51 <Pseudonym> That's also true of spelling flames.
17:33:23 <sproingie> Pseudonym: which always leads to a ridiculous recursive squabble.  perhaps "grammar nazi" was coined to invoke godwin's law?
17:33:53 <SyntaxNinja> syntaxPolice!
17:37:56 <JKnecht> and this months CACM Presidents letter.
17:39:42 <star-trekio> wow
17:39:54 <star-trekio> working in a company making like 40 million a year is interesting
17:40:02 <star-trekio> many tools are half utilized
17:40:05 <star-trekio> much chaos
17:40:07 <sproingie> is 40 mil supposed to be big or small?
17:40:09 <star-trekio> no documents
17:40:16 <star-trekio> kinda big
17:40:20 <star-trekio> I dunno
17:40:26 <JKnecht> small cap
17:40:32 <star-trekio> we use redhat linux and mysql apache java
17:40:39 <star-trekio> and im a linux admin
17:40:43 <star-trekio> Im not very good
17:40:50 <star-trekio> so Im constantly learning new stuff
17:41:14 <star-trekio> I fantasize about using something cool like haskell to build killer aps
17:41:29 <star-trekio> does haskel support event driven programming?
17:41:58 <SamB_XP> hmm, anyone know how to spell \x -> ... in maple?
17:42:44 * sproingie works for a $3B company ... and they also use redhat and mysql (as well as oracle)
17:42:52 <star-trekio> really?
17:42:53 <JKnecht> well there's threading support.
17:42:58 <star-trekio> do you use mysql 5.0
17:43:10 <star-trekio> it was ahead of redhat which is only to 4.12
17:43:11 <sproingie> star-trekio: i think you'll be best served by learning some haskell first, many of your own questions will be answered
17:43:17 <star-trekio> we had bugger of a time installing it
17:43:22 <star-trekio> redhats package system is nazi like
17:43:27 <dons> everyone in #haskell works for a $3B company, didn't you know?
17:43:31 <star-trekio> woa
17:43:33 <star-trekio> lol
17:43:36 <sproingie> star-trekio: i doubt it.  it's just used as an embedded store for logs and such
17:43:44 <sproingie> star-trekio: the heavy lifting gets done with oracle
17:43:48 <dons> even lambdabot.
17:43:51 <star-trekio> oracle is $$
17:44:04 <star-trekio> I heard postgresql is best
17:44:11 <star-trekio> firebird looks interesting too
17:44:14 <JKnecht> you heard right.
17:44:19 <star-trekio> then some claim oo dbs are fastest of all
17:44:35 <sproingie> some claim that they're emperor of the united states
17:44:41 <star-trekio> lol
17:44:59 <star-trekio> as linux admin im hit with like 60 different programs
17:45:41 <sproingie> i bang together most of my programs out of python and perl.  hopefully haskell, though i doubt i'll get away with it for more than prototyping
17:45:53 <sproingie> prototypes have a way of becoming production though
17:46:23 <sproingie> now if i could only get missingH to compile
18:10:57 <star-trekio> why haskell over say clsip or smalltalk?
18:11:01 <star-trekio> clisp
18:12:44 <sproingie> because it's different
18:12:56 <sproingie> try learning some haskell and see
18:14:44 <Pseudonym> But Common Lisp and Smalltalk are worth knowing too.
18:15:00 <Pseudonym> Well... Scheme is.  Common Lisp is probably unknowable, if you include all of the libraries.
18:16:08 <sproingie> yes but what is language without support for roman numerals in its specification?
18:27:46 <Pseudonym> Good point.  But people who use Babylonian base 60 like me are still stuffed.
18:28:37 <twb> xerox: can the cairo bindings be used to spit out PDFs as well as PNGs?
18:30:35 <twb> Pseudonym: because CL only supports bases up to 26?
18:30:52 <twb> star-trekio: btw, clisp /= Common Lisp.
18:31:23 <twb> star-trekio: what languages do you have experience with?
18:31:35 <Pseudonym> Ah.  What's clisp?
18:31:45 <twb> clisp is an implementation of CL.
18:31:47 * Pseudonym assumes it's Yet Another Lisp(tm)
18:31:55 <Pseudonym> Right.
18:31:56 <twb> It's by the author of libreadline.
18:32:10 <twb> In addition, GNU Clisp /= GNU Common Lisp.
18:32:42 <twb> @seen xerox
18:32:43 <lambdabot> xerox is in #haskell.it, #haskell-overflow, #haskell-blah and #haskell.
18:32:43 <lambdabot> Last spoke 8 hours, 19 minutes and 34 seconds ago.
18:37:47 <Pseudonym> BBL
18:38:43 <twb> Does haskell have a "system" function that can execute shell commands?
18:38:49 <Korollary> yes
18:38:54 <twb> Awesome.
18:38:56 <sproingie> @hoogle system
18:38:58 <lambdabot> System.Cmd.system :: String -> IO ExitCode
18:38:58 <lambdabot> System.Cmd.rawSystem :: String -> [String] -> IO ExitCode
18:38:58 <lambdabot> Graphics.UI.ObjectIO.StdMenu.enableMenuSystem :: GUI ps ()
18:39:13 <Korollary> I prefer runProcess myself to system. No argument quoting.
18:39:33 <twb> I wonder if I can sucker my PHP-toting colleague into using haskell.
18:39:43 <sproingie> pretty different worlds
18:39:49 <twb> Yeah.
18:40:10 <twb> He wanted to try doing the project in ruby, which we neither know :P
18:40:11 <Korollary> you may have to kidnap his ass
18:40:24 <sproingie> takes a lot of deprogramming to learn haskell
18:40:28 <sproingie> i'm still undergoing it myself
18:41:02 <twb> sproingie: not if you're a lispnik.
18:41:09 <twb> sproingie: then you only have to fight the type system.
18:41:25 <twb> Especially if you first learnt SML, because then Haskell looks *much* nicer :-)
18:41:31 <sproingie> maybe scheme.  CL these days is an OO language with macro tricks
18:41:36 <twb> Fuck CL.
18:41:49 <twb> I write CL as if it were scheme.
18:42:01 <sproingie> must be hard without guaranteed tailcall elimination
18:42:47 <twb> Well, apart from that bit.
18:43:03 <twb> But writing as FP as possible, dodging OO as much as possible.
18:43:29 <SamB_XP> that, and being a 2-lisp...
18:43:31 <sproingie> most of my lisp experience is in emacs lisp
18:43:42 <sproingie> which actually forces you to be more functional, since it doesn't have clos
18:43:50 <sproingie> it has eieio, but hardly anything uses it
18:44:09 <twb> sproingie: but it has dynamic scope, which makes *really* F FP hard.
18:44:30 <sproingie> the dynamic scope isn't so much a problem.  lack of closures is a problem
18:44:37 <sproingie> there's a macro that adds closures tho
18:44:44 <sproingie> big gensym hack
18:44:57 <twb> closures require lexical scope.
18:45:26 <twb> Well, unless you kluge it.
18:45:45 <sproingie> much of elisp is a big ol kludge
18:45:57 <twb> No kiddin.
18:45:59 <ncalexan> hence, yi.
18:46:01 <SamB_XP> I thought it was a big ol kludge
18:46:11 <sproingie> when my haskell-fu is stronger, i'll start hacking on yi
18:46:19 <SamB_XP> with a lot more piled on top
18:48:02 <lennart> elisp was even more interestin the the old gosling emacs days when it didn't have cons
18:48:18 <ncalexan> lennart: how did one build lists?
18:48:26 <ncalexan> . ?
18:48:47 <lennart> there were no lists
18:49:02 <lennart> there were only numbers and strings
18:49:22 <SamB_XP> lennart: how did one write code?
18:49:44 <twb> Presumably the same way Schemers write code.
18:50:01 <twb> Unlike CL, scheme doesn't guarantee that source code is a list.
18:50:02 <SamB_XP> hmm... there is that.
18:50:10 <SamB_XP> that is true
18:50:14 <lennart> the code had had lists
18:50:14 <SamB_XP> though silly!
18:50:24 <SamB_XP> because it is much easier to parse that way
18:50:39 <lennart> I mean, the code looked as ususal.  but those lists were only for code, not data
18:50:43 <SamB_XP> I wish it were documented as if it were
18:52:36 <dons> oh that's nice. reverse-complement goes from 134M heap to 11M :)
18:52:44 <twb> What's the best XML/SVG I/O library?
18:52:54 <lispy> dons: nice
18:53:40 <dons> mutable state, onward!
18:53:57 <lispy> but is mutable state idomatic?
18:54:01 <lispy> idiomatic*
18:54:27 <sproingie> MVars have been accepted.  using unsafePerformIO probably wouldn't be
18:54:50 <dons> no unsafes. just mutable arrays
18:54:59 <dons> if OCaml can do it, so can we
18:55:58 <dons> sproingies, I don't know about unsafePerformIO. It's very common in fast/low-level code. thaat talks to C.
18:55:58 <lennart> it's sad to use mutable data structures :)
18:56:32 <dons> this is true, lennart. we should pose more problems that are better solved without inplace, destructive updates.
18:57:06 <sproingie> halting problem
18:58:06 <monochrom> One way to do that is to pose backtracking problems.  In an imperative language you have to save states manually.  In a functional language that's free, you don't even have to think about it.
18:58:13 <SamB_XP> not as sad if you don't have to look at them
18:58:30 <dons> monochrom, excellent idea.
18:58:52 <monochrom> "This is a Chess program in Haskell."  That will rock.
18:58:54 <star-trekio> is functional progrmaming the same as object oriented?
18:59:03 <sproingie> star-trekio: no
18:59:11 <star-trekio> do "objects" and functions act the same?
18:59:22 <sproingie> star-trekio: in theory, yes.  in practice, no
18:59:28 <SamB_XP> objects don't often take arguments
18:59:29 <star-trekio> why would one prefer oo or functional
18:59:44 <monochrom> "This program solves Sudoku."  "This second one generates Sudoku puzzles."
19:00:10 <SamB_XP> because it gave you more clarity and more bang/line?
19:00:25 <sproingie> ooh sudoku solver, that'd be an excellent shootout entry 
19:00:53 <dons> also, requiring arbitrary precision integers is another good trick. and lots of concurrency.
19:01:02 <dons> haskell does _very_ well at those benchmarks.
19:01:30 <monochrom> Let's show them imperative languages are good at toy problems only!
19:01:34 <SamB_XP> Haskell is already third or fourth in cheap concurrency, right?
19:01:39 <sproingie> first
19:01:41 <SamB_XP> after two erlangs I think...
19:01:44 <Igloo> dons: DYM when measuring speed?
19:01:54 <dons> solve concurrently n sudokus of m size.
19:02:01 <sproingie> first place in the chameneos entry
19:02:08 <Igloo> I would have thought all languages would ultimately be using gmp
19:02:28 <SamB_XP> is that why we program robots in imperative languages?
19:03:13 <SamB_XP> Igloo: well, the lines of code look a lot better with Haskell using gmp over using C with gmp...
19:03:30 <ncalexan> dons: concurrently could just mean popen-ing child processes.
19:03:42 <ncalexan> That's pretty idiomatic for C.
19:03:43 <Igloo> Yes, which is why I was asking dons if he meant performance rather than aestheics
19:03:56 <twb> Surely gmp is beneath the level of the programmer?
19:04:05 <dons> performance, yes.
19:04:12 <twb> The programmer just uses numbers and the language automatically picks the best representations.
19:04:19 <solair> I have a Haskell question to interrupt the Lisp chat... :-) I thought I wanted to declare 'instance Storable a => Readable a where ...', but AFAICT Haskell won't let me do that. Why not, and what should I be doing?
19:04:22 <dons> so let the popens try to compete with haskell threads.
19:05:07 * SamB_XP tries to play streetfighter and watch chat at same time without much success
19:05:08 <Igloo> Oh, concurrency. I thought you were talking about arbitrary range integers.
19:05:20 <dons> and with integers.
19:05:41 <dons> I'm thinking of the pidigits test, where haskell is 2nd.
19:06:11 <sproingie> D is definitely impressing me as a better C++
19:08:21 * solair has issues with IRC servers, apparently.
19:09:09 <SamB_XP> solair: well, you need a type constructor in an instance head in Haskell 98
19:09:17 <SamB_XP> and really its best to have one anyway
19:09:54 <star-trekio> ok
19:09:58 <star-trekio> Im getting lost here
19:10:08 <star-trekio> why haskell over say smalltalk
19:10:12 <SamB_XP> because otherwise your programs are ambiguous
19:10:18 <star-trekio> what weaknesses does haskell addresse in other tools?
19:10:30 * sproingie is starting to think star-trekio is a bot
19:10:36 <SamB_XP> star-trekio: well, Haskell is much better for writing functional programs in
19:10:37 <star-trekio> no Im a newbie
19:10:42 <star-trekio> ;)
19:10:50 <SamB_XP> also, Haskell has type classes
19:11:03 <monochrom> I think you're a manager or a newspaper reporter.
19:11:23 <SamB_XP> even slate, which has some nice FP-style facilities, is no Haskell
19:11:43 <solair> SamB_XP: I gathered that was the requirement, but I have a function that will work for any instance of Storable, and satisfies the signature of my class Readable. How should I be making it available?
19:11:44 <ncalexan> star-trekio: specific to Haskell compared to Smalltalk, ST is almost untyped.  Haskell is strongly typed.
19:12:21 <Igloo> dons: The Int's in that benchmark look suspicious to me
19:12:22 <sproingie> also see http://www.haskell.org/aboutHaskell.html
19:12:32 <SamB_XP> solair: just export it by name?
19:12:48 <cpatrick> star-trekio: since you're curious enough haskell to ask a bunch of questions in here, why don't you find out for yourself what the fuss is about by writing some programmes in it?
19:12:58 <SamB_XP> you can't dispatch on return type in Smalltalk...
19:13:07 <monochrom> Precisely my sentiment, cpatrick.
19:13:11 <Igloo> Hmm, the OCaml one at least seems to be doing likewise, though
19:13:14 <SamB_XP> and it doesn't have proper functions...
19:13:49 * sproingie gets extra-cranky when sick
19:13:53 <dons> Igloo, which benchmark?
19:13:57 <Igloo> pidigits
19:14:19 <solair> SamB_XP: yeah, I could do that, it just makes me unhappy. can you explain, or point to an explanation, of why a type constructor is necessary?
19:14:19 <monochrom> Only managers (including politicians) and news reporters keep asking such "decision support" questions without investing time in learning the thing oneself.
19:14:20 <dons> on the wiki?
19:14:24 <SamB_XP> I mean, you have to write blocks that call methods out longhand rather than just giving the method name...
19:14:28 <Igloo> on the shootout page
19:14:42 <Igloo> It might be OK; I'm not clear on whether you're allowed to assume n = 1000
19:14:53 <dons> http://www.haskell.org/hawiki/PidigitsEntry, btw.
19:14:59 <SamB_XP> solair: because the type checker doesn't look at constraints when deciding which instance to use
19:15:08 <sproingie> monochrom: most managers can be assed to google things and try reading the home page
19:15:14 * solair ponders that.
19:16:12 <SamB_XP> star-trekio seems to have left...
19:16:28 <sproingie> ah indeed
19:16:35 * Igloo wonders how to convince people to spend their time fixing GHC performance bugs I've already found rather than tweaking pointless performance benchmarks  :-)
19:16:48 <solair> SamB_XP: Oh, I see. Is it hard to make the type checker look at constraints, or just considered not generally useful, or...?
19:17:05 <sproingie> i give little respect to people who use 'lol' as punctuation.  is that a flaw?
19:17:06 <dons> hehe
19:17:13 <SamB_XP> solair: well, for one thing, principle types are at stake here
19:17:30 <monochrom> lol^H^H^H No it is not a flaw.
19:17:30 <SamB_XP> oh lol oh?
19:18:20 <monochrom> There was a person doing that.  I banned him.
19:18:41 <sproingie> there's a type of troll i've noticed called a questiontroll
19:18:46 <SamB_XP> that sounds like a pretty boring ban
19:18:49 <sproingie> keeps asking the same really basic questions over and over
19:19:08 <sproingie> usually trying to start a language/os/desktop war
19:19:13 <SamB_XP> sproingie: well, when they do that you need to make/update/use an FAW
19:19:17 <SamB_XP> s/W/Q/
19:19:37 <SamB_XP> anyway, we *like* smalltalk
19:19:38 <monochrom> Yeah they're news reporters.
19:19:55 <twb> Waah, wash debian packages are broken.
19:20:09 <sproingie> i guess my presumption that reporters possess spelling and grammar skills makes me a quixotic anachronism
19:20:23 <solair> SamB_XP: OK, thanks for the insight. I'll go quit trying to use type classes for this. :-/
19:21:01 <monochrom> The news reporter algorithm is very simple.  Any robot can do it.  Between two groups of differing opinions, he runs back and forth saying "the other group has said so-and-so. what is your response?"  He does not even have to understand the responses.
19:22:07 <SamB_XP> and that is the *good* reporter algorithm
19:22:18 <SamB_XP> the bad reporter algorithm doesn't even go back and forth
19:22:22 <monochrom> Oh damn, I must be living in heaven then.
19:23:54 <monochrom> Does the news reporter algorithm pass the Turing test? :)
19:24:47 <SamB_XP> is it really an algorithm?
19:26:00 <monochrom> The mechanical running part is problematic.  But let's say in the 21st Century he can just send emails instead. :)
19:26:18 * monochrom goes write NewsReporter.pl
19:27:44 <solair> monochrom: presumably an Eliza-like algorithm suffices?
19:27:51 <monochrom> Indeed.
19:28:12 <monochrom> Hell, Eliza is far more intelligent in comparison.
19:28:22 <lispy> and how does an eliza-like algorithm make you feel?
19:29:04 <monochrom> It makes me feel like the programmer behind it has actually done some homework.
19:30:04 <lispy> before you mentoined mechinical running part is problematic, do you think this is because of the 21st century?
19:30:31 <monochrom> Damn, I'm talking to eliza!
19:30:49 <lispy> always
19:39:03 <SamB_XP> lispy: but it works better if you are picking and choosing which things to feed it and/or which responses to pass on
19:52:12 <lispy> SamB_XP: i still hate perl
19:52:21 <dons> nested unboxed tuples don't work :)
19:53:51 * jwp hates perl too
19:56:31 <SamB_XP> monochrom: I thought it was supposed to go between, say, #haskell and #squeak or something
19:57:01 <SamB_XP> dons: heh
19:57:08 <SamB_XP> yeah, I hate that stuff too...
19:58:26 <twb> What's the deal with unicode source code?
19:58:48 <twb> I mean, Char is supposed to be unicode, but I heard that it's only supported as ASCII atm.
19:59:02 <SamB_XP> Char supports Unicode fine
19:59:03 <Korollary> I'm going to design yet another language like Ruby or Python, and it would differ only in nontechnical aspects like naming conventions, whitespace, etc. and I will split the world in 4.
19:59:21 <SamB_XP> its the hGetChar/hPutChar and relatives that have problems
19:59:30 <twb> SamB_XP: how does it handle characters like reverse-direction?
19:59:41 <SamB_XP> it doesn't care
19:59:55 <twb> It just sees a n*8 bit number?
19:59:55 <SamB_XP> thats a library issue
20:00:22 <SamB_XP> > min :: Char
20:00:23 <lambdabot>   Expecting a function type, but found `Char'
20:00:23 <lambdabot>   Expected type: Char
20:00:23 <lambdabot>   Inferred type: a -> a -> a
20:00:31 <SamB_XP> > minimum :: Char
20:00:32 <lambdabot>   Expecting a function type, but found `Char'
20:00:32 <lambdabot>   Expected type: Char
20:00:32 <lambdabot>   Inferred type: [a] -> a
20:00:35 <SamB_XP> hmm...
20:00:40 <SamB_XP> > lowerBound :: Char
20:00:41 <lambdabot>  Not in scope: `lowerBound'
20:00:45 <SamB_XP> ...
20:00:52 <lispy> @type min
20:00:53 <lambdabot> forall a. (Ord a) => a -> a -> a
20:01:02 <SamB> > minBound
20:01:03 <lambdabot> Add a type signature
20:01:04 <SamB> > minBound :: Char
20:01:06 <lambdabot> '\NUL'
20:01:10 <SamB> > maxBound :: Char
20:01:12 <lambdabot> '\1114111'
20:01:21 <twb> I see.
20:01:27 <SamB_XP> ew, yuck, I'm green!
20:01:43 <SamB_XP> a worse-looking green than you!
20:01:49 <twb> So can I have e.g. variable names with kana in them?
20:01:51 <SamB_XP> you have nice green, actually.
20:02:20 <SamB_XP> not until we have decent support for reading/writing files of specified encoding
20:02:43 <twb> Ah, so *unicode* is supported but *utf-8* is not?
20:03:24 <SamB_XP> at this time, your best bet is to either assume there is only support for ASCII, or realize that its basically latin-1
20:03:57 <SamB_XP> we don't even have standardized Binary I/O iirc!
20:05:39 <twb> "A unique syntactic feature of Haskell is the offside rule."  (from WASH docs)
20:05:58 <twb> I would've thought that it's pretty similar to python's indent/dedent stuff.
20:06:07 <SamB_XP> offside rule?
20:06:13 <Korollary> the layout rule
20:06:14 <monochrom> Soccer? :)
20:06:15 <SamB_XP> layout rule?
20:06:23 <SamB_XP> and not really...
20:06:26 <twb> lining up case,do, etc forms with indentation instead of {;}
20:06:41 <twb> How are they different?
20:06:53 <monochrom> When was the statement written?
20:07:08 <twb> monochrom: may 2003
20:07:28 <SamB_XP> Python's syntax doesn't involve "when there would otherwise be a syntax error immediately after keyword1, keyword2, or keyword3, do blah blah"
20:07:51 <SamB_XP> twb: well, in Python there is no {;} form at all
20:08:06 <sethk> python is really another animal altogether in this particular area
20:08:14 <SamB_XP> in Haskell, not only is there such, but the other way is spec'd in terms of it
20:08:38 <sethk> as SamB said, in haskell the layout rule is defined in terms of the explicit terminators
20:08:43 <twb> OK, but from the user's perspective (i.e. a programmer), it's quite similar surely?
20:08:43 <SamB_XP> and almost- syntax-errors are part of the spec too
20:08:51 <SamB_XP> twb: only cooler
20:08:55 <SamB_XP> but yes
20:09:03 <twb> Neato.
20:09:07 <Korollary> it's a bit different actually
20:09:23 <sethk> twb, when you are chasing down an error you treat the two somewhat differently
20:09:36 <Korollary> python could be thought of invisible curly braces, which are identical to what you could see in java.
20:09:38 <SamB_XP> Korollary: well, it gives you the same freedom from having to decide where to put the { and }
20:10:06 <SamB_XP> Korollary: Haskell is spec'd in terms of invisible curly braces!
20:10:36 <Korollary> SamB_XP: right, but they dont have to look like what you would see in java.
20:10:50 <SamB_XP> oh?
20:10:55 <SamB_XP> what is that supposed to mean?
20:11:11 <Korollary> python just keeps the indentation and remove the braces. In haskell, a closing block may go back to the first column if you like.
20:11:38 <SamB_XP> closing?
20:11:44 <SamB_XP> are you sure you mean closing?
20:12:24 <Korollary> yeah, you could indent *any* amount less than the first lexeme of the do/etc block. In python, you have to go back to a predetermined indentation level.
20:12:31 <ncalexan> Evidence that Haskell's layout rules are in some sense correct: I have never had any idea of how they actually work, and yet, I have never -- not once -- had trouble with them.
20:13:13 <SamB_XP> Korollary: are you sure?
20:13:39 <Korollary> SamB_XP: of which part? haskell?
20:13:42 <SamB_XP> I was pretty sure the spec said something about a list of indentation offsets
20:14:11 <SamB_XP> oh, you mean you can do something between two levels?
20:14:30 <Korollary> from the report: "if it is indented the same amount, then a new item begins (a semicolon is inserted); and if it is indented less, then the layout list ends (a close brace is inserted)."
20:14:59 <twb> ncalexan: I have -- when I rename a function and the new name is longer/shorter :-)
20:15:19 <monochrom> heh yeah that's a problem
20:15:42 <ncalexan> Right.  That's frustrating, but for some reason I don't forget to change the indent.  Something about it being visually unappealing.
20:15:46 <SamB_XP> bah. thats just an editor issue!
20:16:05 <ncalexan> twb: and ... ditto what SamB said.  A little structured editing might go a long way here.
20:16:17 <SamB_XP> and have I mentioned that Emacs sucks at this?
20:16:27 <ncalexan> No, but I second :)
20:16:28 <twb> ncalexan: where is paredit for haskell, then?
20:16:38 <ncalexan> I don't recognize paredit.
20:16:40 <lispy> what does qw/blah/ do in perl?
20:16:47 <twb> paredit = structured editing for sexprs
20:17:01 <SamB_XP> sounds like a quoted word or something...
20:17:04 <lispy> i see things like darcs qw/mv ping PING/; in the test suite
20:17:04 <ncalexan> Is that an Emacs mode?
20:17:05 <twb> lispy: "blah"
20:17:09 <twb> ncalexan: yes.
20:17:29 <ncalexan> twb: I wouldn't want to write than in elisp.  Would you?  (I hope not.)
20:17:33 <twb> lispy: or possibly ["mv","ping","PING"]
20:17:41 <twb> ncalexan: what's the alternative?
20:17:59 <twb> ncalexan: does yi do structured haskell editing yet?
20:18:01 <ncalexan> 20 years of yi development.
20:18:08 <SamB_XP> twb: write it in Haskell and slave Emacs to it?
20:18:32 <twb> ncalexan: by which time haskell will be to $newlang what elisp is to haskell ;-)
20:18:34 <ncalexan> Then write your own... and yi doesn't really do editing at all right now.  It's very concept code.
20:18:47 <lispy> perl is so cryptic....
20:18:49 <twb> ncalexan: it edits as good as nvi.
20:18:50 <ncalexan> twb: a time at which I will be happy.
20:18:54 <lispy> twb: thanks, you're probably right in both clases
20:18:57 <lispy> er cases
20:19:17 <twb> perl is a very featureful language under all that syntax.
20:19:18 <ncalexan> twb: I guess I should say that yi has no concept of mode.
20:19:32 <twb> ncalexan: it has syntax hilighting now!
20:19:41 <lispy> any idea what "ok((-r "PING"), $test_name);" does?
20:20:04 <SamB_XP> thats right, it does!
20:20:13 <ncalexan> twb: it uses GtkSourceview, which is a regexp highlighter AFAICT.
20:20:14 <SamB_XP> stolen from hmp3 iirc!
20:20:16 <twb> lispy: no.
20:20:34 <twb> regexp hilighter?  I thought it used parsec!
20:20:37 <ncalexan> There is some hope that yi could be made to use the GHC api to get much better highlighting.
20:20:55 <SamB_XP> ncalexan: haskellsense doesn't do that already?
20:21:09 <ncalexan> twb: the version I darcs get'ed ... oh wait.  Perhaps these newer features happen in hIDE?
20:21:36 <twb> ncalexan: I only heard about it from dons.  I haven't tried these new fangled things yet.
20:22:00 <ncalexan> twb: if the haskellsense code exists (which I don't doubt it does) it wasn't in Darcs a week ago.
20:22:04 <SamB_XP> Yi does have highlighting even in Curses now, iirc what dons told me in passing
20:22:27 <SamB_XP> ncalexan: haskellsense is in hIDE's repo
20:22:34 <ncalexan> Ah, the haskellsense is hIDE.
20:22:40 <SamB_XP> being, as it is, a hIDE plugin
20:22:50 <SamB_XP> I can't get it to build with 6.4 though
20:23:33 <SamB_XP> ooh, cool, MSIE is warning me that my security settings forbid ActiveX
20:24:13 <Korollary> who's warning you that you are using MSIE?
20:24:59 <SamB_XP> thats that nagging voice in my head that says "aren't you going to pick up malware that way?"
20:25:30 <SamB_XP> I wish it wouldn't warn me though
20:27:40 <solair> I think I heard that lambdabot can generate a function of a given type... how do I ask it to do so?
20:27:53 <ncalexan> @djinn :: a -> a
20:27:54 <lambdabot> Invalid command
20:28:13 <monochrom> perhaps single colon?
20:28:23 <monochrom> or even no colon?
20:28:25 <ncalexan> Can't recall.
20:28:28 <SamB_XP> @djinn a -> a
20:28:29 <lambdabot> f a = a
20:28:37 <solair> @djinn IO a -> IO [a]
20:28:39 <lambdabot> -- f cannot be realized.
20:28:45 <monochrom> @djinn g :: x -> (x,x)
20:28:47 <solair> oh well. thanks anyway. :-)
20:28:47 <lambdabot> Cannot parse command
20:28:48 <ncalexan> solair: no recursive types :(
20:29:08 <monochrom> @djinn  x -> (x,x)
20:29:09 <SamB_XP> @type liftM (:[])
20:29:09 <lambdabot> f a = (a, a)
20:29:10 <lambdabot> Not in scope: `liftM'
20:29:22 <SamB_XP> @type Control.Monad.liftM (:[])
20:29:23 <lambdabot> forall a1 (m :: * -> *). (Monad m) => m a1 -> m [a1]
20:29:56 <solair> SamB_XP: hmm. that certainly has the type signature I requested, but isn't quite what I wanted. :-)
20:30:12 <solair> I think.
20:30:29 <SamB_XP> @type Control.Monad.liftM repeat
20:30:30 <lambdabot> forall a1 (m :: * -> *). (Monad m) => m a1 -> m [a1]
20:30:54 <SamB_XP> @type Control.Monad.repeatM
20:30:56 <lambdabot> Not in scope: `Control.Monad.repeatM'
20:31:08 <SamB_XP> @type Control.Monad.replicateM
20:31:09 <lambdabot> forall a (m :: * -> *). (Monad m) => Int -> m a -> m [a]
20:31:34 <solair> yeah, that sounds promising.
20:31:41 <monochrom> There is also cycle :)
20:32:09 <monochrom> err nevermind, repeat it is.
20:32:58 <solair> I was fiddling with (sequence $ repeat $ ...), but it seems my FFI usage isn't quite right... :-/
20:35:39 <SamB_XP> maybe its just that you never finish if you try to sequence an infinite list?
20:36:03 <solair> I'm trying to write a Haskell binding to my X-protocol C Binding (http://xcb.freedesktop.org) library.
20:36:40 <SamB_XP> and what are you trying to bind here?
20:37:44 <solair> There's a really annoying X request, ListFontsWithInfo, that returns multiple replies from the X server in response to a single request from the client.
20:38:33 <solair> I have a C function, XCBWaitForReply, that waits for a single reply to a given request. I need to call it multiple times to get all the replies.
20:39:34 <solair> You can browse my last commit of the Haskell binding at http://cvs.freedesktop.org/xcb/xhsb/ -- it produced correct results for the one X protocol request it implemented.
20:39:55 <monochrom> Right, that's analogous to many database bindings.  Client sends one query, many rows are to be returned.  Some code has to call a function many times, one per row.  How did they do that in HSQL etc?
20:41:24 <solair> One thing I'm very pleased with in this code is that I got unsafeInterleaveIO to give me lazy access to the results; Debug.Trace confirms that all my requests are being issued first, then the replies are waited for.
20:41:56 <monochrom> Ah, that's how!
20:42:29 <SamB_XP> you'll probably need to do something similar with this...
20:42:35 <solair> I thought it might be part of the answer. :-)
20:42:45 <SamB_XP> or perhaps more similar to what hGetContents does
20:43:23 <solair> My friend got help from some of you folks recently in writing http://psas.pdx.edu/~josh/haskell/Main.lhs, which I've been studying as I work on this.
20:46:26 <SamB_XP> it is common to get help in writing things here ;-)
20:47:11 <lispy> help is good
20:47:13 <solair> yes, his recommendation of this channel was glowing. :-)
20:48:32 <solair> I think what I'm doing wrong at the moment is issuing the request multiple times in addition to trying to get the reply multiple times. guess I'll try rearchitecting a bit...
20:48:42 <SamB_XP> hmm, they ought to make an HTML tag for that
20:48:47 <SamB_XP> would be a lot less annoying than that FLASH tag
20:49:35 <dons> finallly, a reasonably fast reverse-complement: http://www.haskell.org/hawiki/ReverseComplementEntry
20:51:14 <Korollary> ax times slower than the C version where a = ... ?
20:51:41 <Korollary> ah, arrays
20:52:52 <dons> a = 5. or so.
20:52:52 <Korollary> 5x still
20:53:09 <dons> yeah, but hard without packed string input.
20:53:13 <solair> ooh, all fixed. I'm so pleased.
20:54:15 <Korollary> dons: yeah. very good effort tho
20:54:19 <Korollary> @karma+ dons
20:54:20 <lambdabot> dons's karma raised to 22.
20:54:31 <SamB_XP> wow
20:54:37 <SamB_XP> @karma SamB
20:54:38 <lambdabot> SamB has a karma of 9
20:54:42 <SamB_XP> @karma shapr
20:54:43 <lambdabot> shapr has a karma of 16
20:54:50 <SamB_XP> @karma dcoutts 
20:54:51 <lambdabot> dcoutts has a karma of 6
20:54:53 <Korollary> @karma Cale
20:54:54 <lambdabot> Cale has a karma of 5
20:55:02 <monochrom> @karma oleg
20:55:03 <lambdabot> oleg has a karma of 0
20:55:09 <monochrom> heh heh heh!
20:55:18 <Korollary> @karma JaffaCake
20:55:19 <lambdabot> JaffaCake has a karma of 4
20:55:22 <SamB_XP> oleg doesn't have karma because oleg doesn't IRC (or not much)
20:55:38 <Korollary> @karma dave_m
20:55:39 <lambdabot> dave_m has a karma of 0
20:56:07 <Korollary> @karma Pseudonym 
20:56:08 <lambdabot> Pseudonym has a karma of 2
20:56:16 <SamB_XP> either that, or lambdabot is making a statement about the difficulty of understanding his types
20:56:16 <SamB_XP> somebody just start a listcommands?
20:56:51 <SamB_XP> @karma SyntaxNinja 
20:56:52 <lambdabot> SyntaxNinja has a karma of 4
20:57:01 <solair> @hoogle (a -> Bool) -> [a] -> [a]
20:57:02 <lambdabot> Data.List.takeWhile :: (a -> Bool) -> [a] -> [a]
20:57:02 <lambdabot> Data.List.dropWhile :: (a -> Bool) -> [a] -> [a]
20:57:02 <lambdabot> Data.List.filter :: (a -> Bool) -> [a] -> [a]
20:58:17 * SamB_XP wonders why dcoutts has a karma lower than his own
20:58:17 <SamB_XP> @karma ADEpt 
20:58:18 <lambdabot> ADEpt has a karma of 0
20:58:24 <twb> Anybody here familiar with WASH?
20:58:36 <Pseudonym> How did I manage to get 2?
20:58:44 <SamB_XP> @karma jlouis
20:58:44 <lambdabot> jlouis has a karma of 0
20:58:52 <Pseudonym> @karma shapr
20:58:53 <lambdabot> shapr has a karma of 16
20:58:56 <Pseudonym> Woah.
20:59:01 <Pseudonym> Completely undeserved.
20:59:05 <monochrom> haha
20:59:23 <lispy> @karma lispy
20:59:24 <lambdabot> You have a karma of 3
20:59:27 <lispy> w00t!
20:59:28 <SamB_XP> @karma dons
20:59:29 <twb> Is it possible to stop WASH using ECMAscript?  Some of my browsers don't support it.
20:59:29 <lambdabot> dons has a karma of 22
20:59:53 <lispy> twb: just force them to use ff ;)
21:00:14 <twb> lispy: no no, firefox is a piece of shit.
21:00:21 <twb> lispy: it requires X, ffs.
21:00:26 <Korollary> ugh
21:00:31 <lispy> ffs?
21:00:38 <Korollary> for f...'s sake
21:00:40 <twb> ffs = for fuck's sake
21:00:42 <lispy> oh
21:00:52 <Korollary> you need framebuffer?
21:01:01 <twb> Korollary: huh?
21:01:03 <lispy> w3m doesn't do javascript yet?
21:01:05 <rep> ffs = find first (bit) set
21:01:08 <twb> lispy: correct
21:01:09 <Korollary> what's wrong with requiring X?
21:01:22 <lispy> twb: in that case, i'd say fix w3m
21:01:23 <twb> Korollary: X is not feasible over public internet, for one thing.
21:01:41 <twb> ECMAscript is *NOT* a prerequisite for using web applications!
21:01:54 <SamB_XP> twb: I thought that was just 56k!
21:02:00 <lispy> but, webapps without are really gimped
21:02:11 <SamB_XP> also annoying over wireless because you lose your X session sometimes
21:02:20 <twb> SamB_XP: nod nod.
21:02:35 <twb> SamB_XP: firefox can't run inside a detachable screen session.
21:02:49 <Korollary> it can run inside a detachable vnc session heh
21:02:57 <SamB_XP> twb: well, there is Xvnc
21:03:22 <lispy> how do you view postscript and pdf?
21:03:34 <Korollary> just read as ascii hah
21:03:35 <twb> lispy: with the local X server.
21:03:37 <lispy> and what about using aalib to render X to ascii and then send that
21:03:51 <SamB_XP> lisppaste2: gv and Xpdf. not necessarily respectively. which is to say, sometimes I use gv for pdfs.
21:03:52 <twb> Can we get back to the original question please?
21:04:05 <SamB_XP> er, lispy even. 
21:04:10 <lispy> twb: well, that i don't know the answer to...
21:04:24 <lispy> SamB_XP: np, happens quite often, i'm used to it :)
21:05:00 <SamB_XP> WASH with no JS?
21:05:05 <lispy> pull......................ok                                                 
21:05:05 <lispy>         1/15 unexpectedly succeeded
21:05:10 <SamB_XP> what does WASH do?
21:05:17 <lispy> how can it unexpectedly succeed...
21:05:26 <SamB_XP> lispy: do you have lambdabot on your highlight list?
21:05:28 <lispy> SamB_XP: it's a framework for haskell webapps
21:05:30 <SamB_XP> er, lisppaste2 ?
21:05:41 <lispy> i have no highlight list
21:05:48 <twb> SamB_XP: it's like PHP, but for Haskell.
21:05:54 <lispy> i use erc with pretty much the defaults
21:06:00 <SamB_XP> twb: only PHP doesn't ask for JS
21:06:10 <dons> musasabi, would you like to submit the fast version of http://www.haskell.org/hawiki/ReverseComplementEntry and the fast pure and impure versions of http://www.haskell.org/hawiki/FannkuchEntry
21:06:22 <araujo> Hello.
21:06:29 <twb> SamB_XP: right.
21:06:51 * araujo gets some cake and coke while start working
21:08:44 <twb> SamB_XP: but PHP is nasty horrible imperative yuk.
21:10:38 <lispy> twb: and a security vulnerablity waiting to happen
21:11:19 <lispy> i'll only use a php app if it has a large following to ensure it has reasonable eyes looking for security flaws in the code
21:22:09 <ncalexan> @djinn (a -> b) -> (a -> m b)
21:22:10 <lambdabot> -- f cannot be realized.
21:23:45 <twb> Cripes.  Wash too 2hrs to compile
21:27:31 <lispy> does haskell cooperate with .lhs?
21:27:49 <SamB_XP> huh?
21:28:03 <lispy> twb: welcome to haskell, code takes ages to compile, but you already have garantees about certain properties
21:28:13 <lispy> SamB_XP: hehe
21:28:23 <lispy> does HADDOCK cooperate with .lhs
21:29:12 <lispy> i was wondering how hard it would be to generate haddock docs from darcs source code.  Currently darcs source is written for the latex style literate haskell
21:30:26 <psnl> isn't the first stage of ghc an lhs to hs converter?
21:30:28 <SamB_XP> haddock absolutely abhors .lhs
21:30:44 <dons> you should unlit it first then, SamB.
21:31:21 <lispy> well, i think it's time darcs became happy with haddock
21:31:43 <lispy> http://www.haskell.org/haddock/haddock-html-0.7/invoking.html#cpp
21:32:54 <lispy> but, i'm not sure how i would want to modify the Makefile
21:37:37 <solair> if anyone is interested, my Haskell binding for (a small part of) the X protocol, using lazy evaluation to hide latency to the X server, is updated at http://cvs.freedesktop.org/xcb/xhsb/ and supports the hard case of ListFontsWithInfo quite nicely.
21:40:29 <solair> next I have to decide how to generate binding code for the whole protocol from XML descriptions of the X protocol, which we've spent a while building for XCB.
21:41:27 <twb> Damn, damn, damn.
21:41:37 <twb> And wash looked so nice, too :-(
21:42:33 <lispy> twb: can't remove the emcascript?
21:42:46 <lispy> i think i misspeled that...
21:42:54 <lispy> irony strikes again
21:43:19 <lispy> solair: i'm not really interested, but i think that is very cool.
21:43:23 <twb> lispy: I can't see how easily.
21:43:29 <lispy> @karma-add solair
21:43:30 <lambdabot> Unknown command, try @listcommands.
21:43:39 <lispy> @listcommands
21:43:40 <lambdabot> use listcommands [module|command]. Modules are:
21:43:40 <lambdabot> babel base code compose dice dict djinn dummy dynamic elite fact haddock
21:43:40 <lambdabot> help hoogle karma lShell localtime more pl plugs poll pretty quote search
21:43:40 <lambdabot> seen spell state system todo topic type version vixen where
21:43:53 <lispy> @help karma
21:43:54 <lambdabot> return a person's karma value
21:44:13 <lispy> @listcommands karma
21:44:14 <lambdabot> karma provides: karma karma+ karma-
21:44:21 <lispy> @karma+ solair 
21:44:21 <lambdabot> solair's karma raised to 1.
21:44:45 <lispy> twb: it's probably glued right in.  Perhaps you want hsp (haskell server pages)
21:47:20 <twb> lispy: afaict, hsp is dead.
21:55:24 <lispy> twb: i think you are probabyl right
21:55:34 <solair> if I mention my Summer of Code project where I coded the basic DSP algorithms for the 802.11 physical layer in Haskell (http://svcs.cs.pdx.edu/trac/wifi)... do I get another karma point? ;-)
21:55:51 <lispy> solair: heh
21:56:35 <lispy> solair: if you made trac support darcs i'd give you several karma points :)
21:56:53 <solair> ooh, that's an interesting idea.
21:57:10 <solair> I haven't tried darcs yet.
21:57:37 <lispy> darcs is great, but it is not mature
21:57:41 <lispy> it needs more devs
21:57:45 <SamB_XP> I thought there was already something called trac with darcs support?
21:57:49 <SamB_XP> though I heard that it was really slow
21:58:12 <lispy> SamB_XP: i've seen darcsweb and darcs.cgi but nothing about trac, i should look again
21:58:32 <SamB_XP> lispy: also ask in #darcs
21:58:43 <solair> anyone written anything comparing darcs to monotone?
21:59:38 <SamB> probably!
21:59:42 <lispy> solair: mm...i think so
21:59:47 <SamB> I think so.
21:59:52 <solair> monotone is also not mature and is written in C++ (shudder) so I'm not excited about actually using it, but I'm quite excited about its feature set.
22:00:05 <lispy> solair: there are several sites with comparisons between various distributed vcs, but nothing really indepth on the subject
22:00:05 <stacy> I am trying to figure out what I will pay my landlord in total over 5 years if the rent is 2838.50 monthly with a $75/month yearly increase.  How's this:
22:00:09 <stacy> > f 5 where f x = if x == 0 then  0 else (2838.50+(75*x))*12 + f(x-1)
22:00:11 <lambdabot> 183810.0
22:00:33 <SamB> solair: I thought it was in Python? am I confused?
22:00:50 <SamB> stacy: is this homework?
22:01:07 <solair> SamB: I'm pretty confident monotone is written in C++. trac is in python though, IIRC...
22:01:10 <lispy> f 0 = 0; f x = (2838.5+(75*x)*12 + f(x-1)
22:01:11 <stacy> no, an actual real world situation where I am examining the terms of a lease.
22:01:27 <SamB> and the rent increases linearly?
22:01:59 <lispy> stacy: pattern matching is often easier to read than an "if" when you can use it
22:02:02 <stacy> it seems crazy to go up so much
22:02:24 <SamB> stacy: maybe you should read that paper about composing financial contracts?
22:02:31 <stacy> lispy: thanks. 
22:02:38 <SamB> should be in spj's paper bin
22:03:02 <stacy> SamB: where is that?
22:03:24 <SamB> @google simonpj
22:03:25 <lambdabot> http://research.microsoft.com/Users/simonpj/
22:04:46 <stacy> SamB: Thanks!
22:05:58 <stacy> hey, that's the name I keep seeing everywhere in my books, Simon Peyton Jones.
22:06:11 <stacy> I think.  I just remember Peyton.
22:06:47 <SamB> stacy: it seems likely enough
22:07:16 <SamB> he does have a way of popping up again and again and again and again and ...
22:07:47 <SamB> possibly related to him being (a) maintainer of GHC
22:08:36 <SamB> see also http://www.haskell.org/humor/enron.html
22:17:11 <rep> http://people.freebsd.org/~ssouhlal/stuff/fidel-castrofl.jpg
22:19:15 <solair> OK, I can see that the Enron story was an April 1st thing, but everything in it that I can personally verify is true. So how much truth is there to the story overall?
22:21:58 <Korollary> err, none, I hope heh
22:22:03 <SamB> solair: I'd say everything but the parts where people are quoted and where this supposed "discovery" by SPJ is claimed as significant
22:22:22 <Korollary> cute joke, though
22:22:31 <SamB> so basically none of the parts about Haskell
22:23:54 * SamB wonders how long ago he wrote @google
22:25:48 <rep> you mean the code that handles the command?
22:27:03 <SamB> rep: yup
22:27:20 <SamB> I suppose I could just run darcs changes on lambdabot to find out...
22:27:46 * Korollary wonders why downcase-region is disabled by default in emacs...
22:28:44 <rep> it's dangerous
22:30:42 * joelk wants to modify Search.hs to handle @google 1 troy ounce in picograms, @google 3 usd per gallon in jpy per liter, etc.
22:32:03 <rep> @google 1 usd in chf
22:32:05 <lambdabot> No result found.
22:32:32 <SamB> joelk: well, I don't think "I'm feeling lucky" is a good calculator
22:33:02 <joelk> SamB, precisely why I said I want to instead of actually doing :-)
22:34:09 * SamB goes to bed finally
22:34:14 <joelk> hmm. It would be simpler to just make a new command.
22:37:03 <joelk> Actually "I'm feeling lucky" works too. Just have to look at the contents if the header has no Location field.
22:56:20 <Keal> Cale :|
22:56:37 <Keal> i send proof of mathematica's glitch to you in pm
22:57:10 <Keal> i assume mbot use it
22:58:24 <Keal> it simplified simple algebraic expression wrong
23:00:55 <Keal> <Keal> expression was:
23:00:56 <Keal> <Keal> % (Floor[3.141592653589793238462643383279502884197169399375105820974944*((1/Sqrt[2])^-(-2))]*((1/Sqrt[2])^-1)-Floor[Floor[3.141592653589793238462643383279502884197169399375105820974944*((1/Sqrt[2])^-(-2))]*((1/Sqrt[2])^-1)])*(1/Sqrt[2])
23:00:56 <Keal> <Keal> it simplified it as:
23:00:56 <Keal> <Keal> <+mbot> Keal: (-1 + Sqrt[2])/Sqrt[2]
23:02:06 <Keal> which is not correct
23:09:52 <joelk> my quick attempt to parse and simplify that agrees with mbot, whatever that is.
23:10:27 <jargon> ?
23:10:31 <jargon> how explain to me
23:10:43 <jargon> other parsers agree with me
23:11:36 <joelk> I see ( floor(pi/2) * sqrt 2 - floor(floor(pi/2) * sqrt 2)) / sqrt 2
23:11:48 <jargon> visual basic, and c++ both agree with me :|
23:11:54 <joelk> = (sqrt 2 - 1) /sqrt 2
23:12:16 <jargon> you forget it is isolating a digit of pi in base 1/Sqrt[2]
23:13:01 <jargon> :(
23:13:02 <joelk> ?
23:13:13 <jargon> its an isolation expression
23:13:25 <jargon> it goes fdigit(value,base,power)
23:13:31 <jargon> plugs as that
23:13:52 <jargon> the (-2) is power -2
23:14:11 <jargon> (1/Sqrt[2]) is where the base goes
23:14:26 <jargon> where pi is is where the value goes
23:14:40 <jargon> result is isolated digit
23:14:57 <jargon> i show you...
23:15:18 <jargon> (Floor[value*(base^-(power))]*(base^-1)-Floor[Floor[value*(base^-(power))]*(base^-1)])*base
23:15:49 <jargon> mathematica does it proper for base 10
23:15:56 <jargon> but not base 1/Sqrt[2]
23:16:37 <jargon> in c++ and visual basic it does proper in all bases within proper ranges
23:16:45 <jargon> ok joelk?
23:17:26 <jargon> all bases >1
23:17:39 <jargon> all powers inf .. -inf
23:17:51 <jargon> all values inf .. -inf
23:19:39 <joelk> but look, you've got: (someInt / base - anotherInt) * base, and you're expecting an Int no matter what base is?
23:20:33 <jargon> int?
23:21:02 <joelk> I guess I don't understand. What is the expected result?
23:21:06 <jargon> the floor craps chop off the leading digits before . place
23:21:54 <jargon> for example: fdigit(12345.6789,10,0) would return 5 ,1) would return 4 ,-1) would return 6
23:22:28 <jargon> what it does is chop all digits off after power digit and before power digit
23:22:36 <jargon> thta is what the floor stuff does
23:22:39 <joelk> and in your case, what do vb and c++ say?
23:22:52 <jargon> also it adjusts it to be in correct 0 power
23:23:00 <jargon> correct
23:23:08 <jargon> mathematica does it correct for base 10
23:23:14 <jargon> but not base 1/Sqrt[2]
23:23:28 <jargon> vb and c++ do correct, almost
23:23:31 <joelk> What is the correct answer that you want with base = 1/sqrt 2???
23:23:45 <jargon> except for rounding errors and float inprecisions
23:23:57 <jargon> termination of pi
23:24:08 <jargon> in the long run
23:24:11 <jargon> what i want
23:24:14 <jargon> but not likely
23:24:31 <jargon> closest i got was -192 digits correct but the ti92 blew up
23:25:11 <jargon> ti92 did not glitch unlike mathematica
23:25:23 <jargon> it just eventually blew its circuits is all
23:25:39 <joelk> I know what floor is, I know what a digit is. My question is: What is the correct value of fdigit(pi,1/sqrt(2),0)?
23:26:14 <jargon> would be what of 3 fits in 1/sqrt(2)
23:26:35 <jargon> like modolo
23:26:40 <jargon> fmod
23:26:43 <jargon> in other words
23:27:11 <jargon> but since it goes 3.xxxxxxxxxx
23:27:19 <jargon> then it may be little off
23:27:30 <jargon> but yes. 3 fmod 1/sqrt(2)
23:27:42 <jargon> i believe
23:27:56 <jargon> anyways i must go to bed now
23:28:35 <joelk> Well, I think my statement stands. I don't know why c++ would give a different answer. 
23:28:38 <joelk> goodnight
23:28:51 <jargon> nite-.-
23:33:06 <kzm> Probably an old hat, but how about a class for formatted data output?  Something a bit more advanced than Show - e.g. class Format spec datum where format :: spec -> datum -> String
23:34:02 <kzm> this way you can overload formatting, e.g. Format Int Double gives the number of decimals, Format (Int,Int) Double gives the number of digits before and after decimal point, etc.
23:34:25 <kzm> Format String Double could give you full printf-style if you prefer...
23:34:51 <jargon> >:|
23:35:01 * jargon whackamoles kzm
23:37:57 <jargon> you....
23:38:06 * jargon whackamoels kzm again
23:38:46 <jargon> >8(
23:39:56 * kzm is unsure whether that should hurt.
23:44:21 <jargon> kzm bush is crazy
23:44:36 <jargon> first he wants anyone arrested that wont show id
23:44:42 <jargon> thta are on the street
23:45:01 <jargon> then he wants anyone arrested that annoys someone on the net anonymously
23:45:16 <jargon> bush needs to die
23:45:42 <jargon> >8O
23:46:07 <jargon> oh and he knows i just said that
23:46:37 <jargon> right gour?
23:47:23 <gour> jargon: ?
23:47:32 <jargon> i just said bush needs to die
23:47:43 <gour> ?
23:47:56 <jargon> the president of the united states, comeon man
23:48:30 <ProfTeggy> jargon, take such messages elsewhere.
23:48:45 <jargon> hes a damn monkey for all i care
23:48:55 <jargon> i just wish he dies natural
23:49:12 <jargon> that way there is no trials to wade thru
23:49:15 <gour> the soul never dies ;)
23:50:07 <jargon> soul? hes is like monkey mountian
23:50:11 <binary42> jargon: as much as I might agree. please don't.
23:50:19 <jargon> alrigth
23:51:39 <jargon> stoping airflight during 9/11 for 2 weeks and the resulting 3c drop in temp imo was why there were so many big hurricanes.
23:51:51 <jargon> what you think?
23:52:10 <binary42> I think you are searching for excuses.
23:52:15 <jargon> ?
23:52:55 <jargon> menot understand why you mean by excuse. people always ask why there were so many hurricanes
23:53:46 <kzm> Who is Bush anyway?
23:53:54 <jargon> ...
23:53:55 <binary42> well, I was saying no in an indirect way. It is too much political bashing. It is getting to the point where bush sucks but so do the anti-bush people.
23:54:00 <kzm> I can't find any of his papers in JFP.
23:54:06 <binary42> :)
23:54:21 <kzm> Or am I in the wrong channel by mistake?
23:54:42 <jargon> bush invented haskell
23:54:46 <binary42> the only channel I get OT in is #io :-)
23:54:59 <jargon> :P
23:55:27 <binary42> haskell has great lazy eval so we can avoid the whole _|_ issue and skip this discussion. ok?
