00:32:31 <ncalexan> Can someone tell me why GHC barfs on 'data Foo = forall a. Foo { foo :: a }' with 'Can't combine named fields with locally-quantified type variables or context'?
00:38:05 <dons> Korollary, mallocArray in Foreign, with peek and poke
00:41:53 <dons> ah, but unboxed arrays are just as good
02:02:47 <lispy> is there anything like rails for haskell yet?
02:05:43 <araujo> Good morning.
02:07:51 <JKnecht> morning.
02:08:12 <lispy> morning
02:31:32 <Cale> lispy: what exactly do you mean by "something like rails"? I'm not even sure what rails is trying to be. All the descriptions I've seen of it have been in the form of "Here's how you create an X with rails!" where X is some web service which should be pretty trivial to write anyway. Is it just a bunch of web and database libraries?
02:34:11 <Cale> John Goerzen is working on a database connectivity library for Haskell called HDBC, which has Sqlite and PostgreSQL drivers, and he seems to be writing more (there's been lots of complaining about ODBC :)
02:34:32 <wolverian> Cale, yes. it's a full-stack (read: integrated and not flexible) set of libraries and architectural concepts.
02:36:56 <Cale> I had an easy enough time just using Network.CGI and Text.Html. Then again, my app is pretty trivial. :)
02:39:44 <xerox> Ciao.
02:41:41 <Cale> hi
02:46:44 <ulfdoz> Sorry for off-topic, but how to get a vector (a, b) in latex to be written with the a above the b?
02:47:09 <Cale> use a matrix
02:47:41 <ulfdoz> Ok, thx
02:48:22 <Cale> or if you just want a binomial coefficient, you can write {a \choose b}
02:54:00 <lennart> howdy
02:54:31 <Cale> hi
02:54:33 <xerox> lennart: hi!  You were in the Haskell 1.4 committee?
02:54:46 <lennart> yes
02:56:23 <lennart> why?
02:57:41 <xerox> I read the .ps yesterday, cool one.
02:59:07 <lennart> The really big changes happened in 1.3
02:59:40 <lennart> Or was it 1.2?  lol
02:59:48 <xerox> :)
03:00:03 <lennart> when we switched to monadic I/O
03:00:39 <xerox> I read on it yes
03:00:41 <neologism> what IO had haskell before?
03:01:02 <wilx> Ruby on rails is iirc some MVC library for making webs.
03:01:20 <xerox> stream-based, I think
03:01:37 <Cale> hehe, "Ringad" for MonadPlus, I like it. :)
03:02:52 <lennart> Haskell had a stream baseed version and a continuation based version of I/O.  Both rather messy
03:04:45 <Cale> lennart: The move from Haskell 1.4 to 98 looks mostly like decisions to cripple various things and remove generality. Why did they do that?
03:06:20 <lennart> You mean removing monad comprehensions, etc?
03:06:21 <araujo> lennart, interesting and new to me :-]
03:07:02 <lennart> It was because of experiences from teaching.  A lot of generality leads to very strange error mesages.
03:07:07 <Cale> lennart: yeah, and specialising filter, map, (++), concat, removing MonadZero,...
03:07:43 <Cale> I've heard this, but it sounds like a poor reason to me. Why not just include a beginner mode which doesn't implement the full standard?
03:08:15 <lennart> You were not there to offer to implement it in all Haskell implementations. :)
03:08:22 <Cale> hehe
03:09:00 <lennart> So, some of those decisions I think were OK.  Others I really disagreed with.
03:09:11 <Cale> I mean, it's not terribly hard, you write a beginner prelude which just reexports things from the real prelude, but with less-general types.
03:09:12 <lennart> Like putting a fail method if Monad
03:09:18 <Cale> yeah, that too
03:10:49 <lennart> I didn't mind so much that the list functions reverted to their old types.  That's what I was used to anyway.
03:11:30 <Saulzar> Were they all written in terms of Monad?
03:11:36 <Cale> Saulzar: yeah
03:11:47 <lennart> map, ++, etc, yeah
03:11:51 <Cale> I really wish that map wasn't degeneralised
03:12:18 <Cale> There's no need for a special list version of that, and having separate fmap and liftM functions also seems ugly.
03:12:31 <lennart> Cale: write your own prelude that reexports them with the type you like.  It's not terribly hard. ;)
03:13:08 <lennart> Yeah, why Functor was removed as a superclass of Monad is a mystery to me
03:13:35 <Cale> I could write my own Prelude, but then that's another thing which I have to import every time.
03:13:41 <Saulzar> Hmm, that would be cool.
03:14:09 <Cale> whereas beginners shouldn't need to spend too long in beginner mode
03:14:22 <Cale> really, monads aren't that hard :)
03:14:45 <xerox> Agreed.
03:15:04 <araujo> I think that the difficulty of understand monad depends upon how deep you wanna understand them.
03:16:15 <lennart> As I said, using fmap instead of map etc doesn't bother me.  Buth having both fmap and liftM does.
03:16:28 <lennart> and having mfail does
03:16:43 <Cale> They renamed mfail to fail :)
03:17:06 <lennart> oh...  that's how much I use it
03:17:09 <lennart> :)
03:17:16 <lennart> I try to ignore it
03:17:36 <Cale> but yeah, I think that having fail in Monad is really poor, since it gives people the wrong impression that monads have a builtin notion of failure
03:17:39 <xerox> @index mfail
03:17:40 <lambdabot> bzzt
03:17:51 <xerox> Where should it stay?
03:17:59 <araujo> Cale, Where should it be?
03:18:01 <Cale> @index fail
03:18:02 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer,
03:18:02 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.
03:18:02 <lambdabot> Monad.Cont, Control.Monad.Error, Control.Monad.List
03:18:19 <Cale> araujo: MonadZero, though with a different type
03:18:27 <Cale> or MonadError, if you want strings
03:18:49 <Cale> combining MonadZero and MonadPlus was another poor idea
03:19:37 <Cale> It results in less informative type signatures, or worse yet, people using Monad and fail when they should be using MonadZero
03:19:41 <lennart> The class hierarchy could need a revision now that we have more experience.
03:19:44 <araujo> hah, well, yes, fail looks like sort of "out of" place in that class :-)
03:20:37 <Cale> We really need a more general tool for automatically deriving instances from other instances though.
03:21:32 <Cale> It would be nice to have a really finely grained hierarchy for functors with various properties, but defining all those instances when they could be automatic is annoying.
03:21:32 <lennart> Yeah, that would be nice
03:25:32 <lennart> I have a feeling that some simple mechanism for deriving instances from others is lurking behind the suggestions I've seen so far.
03:26:04 <araujo> instances deriving from instances?
03:26:52 <lennart> in the sense that Cale was talking about
03:27:15 <Cale> Did you have a look at my suggestion on the mailing list?
03:27:48 <Cale> It wasn't terribly well-defined, but something along those lines I think would be nice.
03:28:18 <Cale> Basically, the idea is to allow default instances similarly to how default methods in classes are currently handled.
03:28:20 <lennart> I only looked briefly.  There was something about the syntax that annoyed me
03:28:32 <Cale> Oh, ignore the syntax :)
03:29:55 <lennart> But I think syntax is important here, because we all want similar semantics :)
03:30:15 <Cale> well, figuring out the semantics is the tough part
03:30:28 <Cale> it's easy to come up with suggestions that don't work
03:30:41 <Cale> I'm still not sure that my suggestion works well
03:30:55 <Cale> (with modules etc)
03:31:35 <JKnecht> the suggestions in "A collection of related ...."?
03:31:47 <Cale> JKnecht: yeah
03:31:54 <Cale> JKnecht: specifically the ones later on
03:31:57 <Cale> in that thread
03:32:05 <JKnecht> ack.
03:33:05 <lennart> I'd love to see such a change, because I've missed that feature myself.
03:34:16 <Cale> It also subsumes John Meacham's suggestion about class aliases
03:34:21 <lennart> I don't like David Roundy's proposal to change the record system.  Haskell records are broken, but he's just opening the can of worms without providing a new container for them.
03:34:37 <Cale> yeah, I didn't care for that either
03:35:22 <lennart> And I think and change in Haskell'06 should be backwards compatible
03:35:42 <lennart> I'll read your proposal again
03:39:39 <gour> lennart: and what about Haskell-2.x ?
03:40:52 <Cale> lennart: What do you think about splitting <- in do-notation into a variant which allows for failing in MonadZero, and one equivalent to lambda pattern matching, where an exception gets thrown as usual when the pattern match fails?
03:43:05 <lennart> gour: I think Haskell-2 should have a clean slate and get everything right :)
03:43:43 <lennart> Cale: I don't really care for haveing different syntax for the two.
03:44:02 <lennart> I was happy with the way things were before (m)fail
03:44:58 <Cale> Well, the original complaint that got all this started, now that I'm looking at the old mailing lists, seems to be that changes to a datatype can introduce typeclass constraints on do-blocks which weren't there before
03:45:21 <Cale> Which, I have to admit, is potentially confusing.
03:46:02 <Cale> i.e. going from a one-constructor datatype to a multi-constructor datatype, and turning a bunch of irrefutable pattern matches into refutable ones
03:46:03 <lennart> Yeah, but it serves as a warning to you :)
03:46:09 <Cale> That's true.
03:46:17 <lennart> because your code is probably wrong now
03:46:39 <Cale> I don't see why people want to provide for a string message *in the class* though.
03:46:53 <lennart> me neither
03:47:11 <gour> lennart: and what about transition from haskell '06 -> 2.x, i.e haskell is catching lot of interest lately and working (just) on '06 will postpone work on 2.0. why not starting straight with the 2.x and take advantage of momentum to make haskell what is deserves?
03:47:26 <Cale> There's nothing you could possibly want that string for, other than for the same purpose that throwing an exception would achieve.
03:47:33 <lennart> I read your class proposal again.  As I said before, I think there's something simple lurking here trying to get out.
03:47:51 <chucky> hello everyone
03:47:57 <Cale> chucky: hello
03:48:30 <Cale> lennart: yeah, I think that perhaps the need to define which things are required is possibly unnecessary, but I wanted to be safe
03:48:50 <Cale> I don't really understand what would be needed to infer which instance to take otherwise.
03:49:54 <lennart> gour: Two reasons to postpone Haskell 2, first there's still a lot of developments in type systems that should stabilize first (I think), second (and more importantly) I think you need a small group of dedicated people to do the work, and I'm not sure you can find those.
03:51:17 <lennart> I think Haskell 2 should have some mild form of dependent types, like Tim's Omega stuff (but done right ;) )
03:51:50 <Cale> I think that Haskell 1.6 could possibly be less conservative though.
03:52:18 <gour> lennart: no #1 i understand, but if there are people who will (are) work on '06, why not start with the 2.x?
03:53:08 <Cale> It's good to shake things up once in a while to keep the language moving ;) hehe
03:53:14 <lennart> gour: if you can find the right people, sure work could start
03:53:26 <gour> there are (probably) enough things to prepare for 2.x while type systems get ready
03:54:21 <lennart> language design is tricky.  i think Haskell was lucky to get as good as it did with a committee doing the work.
03:54:23 <gour> i.e. my point is that (i believe) haskell community has enough experience to design 2.x properly
03:54:59 <gour> and it's time to do it here & now :-)
03:55:10 <lennart> I think there are many conflicting ideas on what Haskell 2 should be
03:55:32 <lennart> but that's no reason not to start
03:56:21 <gour> if it is clear that something is not right in '98, what will work on '06 bring anyway?
03:56:40 <JKnecht> huh?
03:56:41 <gour> except in case that '06 dev goes into 2.x?
03:57:04 <JKnecht> oh.
03:57:26 <lennart> What it will bring?  Happiness to Haskell users.
03:57:34 <chucky> :)
03:57:40 <chucky> and certainly sadness to some?
03:58:12 <lennart> I try to only use Haskell 98 since it's the standard.  There are a few things I wouldnt mind seeing in the standard. :)
03:58:45 <gour> that's nice, but '06 will change it?
03:59:15 <lennart> If there's an '06 with a few more things, I think that would be the standard.
03:59:57 <gour> or let me ask directly, can we assume that '06 is dev version for 2.x or 2.x will become a (completely) new branch?
04:00:19 <gour> (breaking some '076 things) ?
04:00:33 <gour> s /076/06
04:00:35 <lennart> oh, i'd expect Haskell 2 to break everything
04:00:48 <chucky> I'm hoping Haskell 2 will break the record system or remove it
04:00:51 <gour> so, then what's the point in doing '06?
04:01:02 <lennart> Haskell 2 is far away
04:01:07 <gour> why build to break it?
04:01:20 <gour> so, my point is why not making it closer?
04:01:23 <chucky> gah, I meant break compatibility with the existing record system by replacing it with a better
04:01:42 <lennart> If you have to worry about backwards compatibility your hands are tied
04:02:21 <Cale> I think we'd better drop backwards compatibility soon, or else more and more people will be around to complain when we do it.
04:02:30 <lennart> I don't mean that Haskell 2 should break things on purpose, just that it shouldn't have to be restrained by backwards compatibility
04:02:30 <Cale> :)
04:02:56 <Cale> Fear popularity!
04:03:03 <lennart> I think it might be too late for Haskell 2 already
04:03:10 <gour> if haskellers can live in 2006 with '98, then they will survive for some more time, but let's move to the right thing, i.e. 2.0
04:03:28 <Cale> Well, people have an implementation of Haskell 98 or two.
04:03:47 <Cale> It's not like that code is going away immediately if the standard changes.
04:04:23 <gour> sure, and people are getting interested in haskell, so it's not late, but better to start working now
04:04:52 <gour> on 2.x than working on a dead-end of '06
04:05:23 <Cale> Also, what's with the year-based version numbers?
04:05:33 <Cale> hehe
04:05:47 * gour has to go away shortly
04:05:57 <Cale> Does this have something to do with the Simons working for Microsoft?
04:06:23 <chucky> Cale: I agree! I've actually heard the argument "are you still on Haskell '98? That sounds like a very old standard"
04:06:30 <lennart> I think it should be Haskell XP next time
04:06:42 <chucky> Haskell Vista?
04:06:43 <Cale> haha
04:06:54 <Cale> Haskell ME
04:07:06 <lennart> Haskell You
04:08:13 <Cale> Haskell ME will be even more broken than 98, but will acquire a cult following of users new to Haskell and programming.
04:10:48 <JKnecht> The Rapture!
04:11:48 <Saulzar> Haskell CE ME NT will be a standard which weathers the test of time
04:12:54 <JKnecht> whose Redmond code name will be "Tribulation".
04:12:58 <araujo> Any House hacker around?
04:13:42 <Cale> If you worry too much about backwards compatibility, it eventually becomes impossible to use feedback from experience in improving your design.
04:15:02 <Cale> I think the reason that Haskell is as good as it is, is from not worrying about backwards compatibility on several levels. (Including backwards compatibility with imperative programmers!)
04:19:14 <JKnecht> "go fuck yourself" type forward migration is a bad idea. People who have committed to your stuffs need a migration path.
04:20:13 <araujo> That's the danger of being popular.
04:20:25 <JKnecht> even if it's just being told explicitly how to do it themselves.
04:21:01 <Cale> yeah, I doubt the language is going to change so drastically that code will be untranslatable though :)
04:21:17 <flux__> would the changes be so great that it would be difficult to write a source converter?
04:21:23 <flux__> that could be one migration path.
04:21:37 <Cale> A source converter is a great idea.
04:21:47 <araujo> Well, it is not like we would be the first ones doing it... *cough* perl *cough*
04:22:12 <flux__> well, atleast with haskell it should be much feasible than for perl, right?-)
04:22:21 <flux__> (+more)
04:22:21 <Cale> or just keep around support for Haskell 98 for a while.
04:22:47 <flux__> but, code rot sucks
04:22:58 <flux__> finding 10 years old code and not being able to compile it really blows ;)
04:23:09 <Cale> We already have that situation.
04:23:33 <flux__> and whenever incompatible changes are made, the 'border' is reset to the present
04:23:48 <araujo> Haskell is a new language, we can give us that luxury.
04:25:29 <JKnecht> it's actually older than Java though isn't it?
04:25:44 <Cale> yes and no
04:25:52 <JKnecht> especially if you include Miranda.
04:26:28 <araujo> Well, i talk about Haskell per se.
04:26:39 <Cale> However, Haskell breaks backwards compatibility with programmers, which Java doesn't, so much. :)
04:27:05 <araujo> I heard they recently did it though with the new API?
04:27:09 <JKnecht> If it were me I would want to leave darcs and perl6 unbroken.
04:27:23 <flux__> java has its depreciated apis, aren't there any removed ones yet?
04:27:31 <Cale> Those are actively maintained projects
04:27:36 <flux__> but I suppose the ones that may have been removed might've been some more obscure ones anyway
04:27:43 <araujo> Well, java is an ugly thing
04:27:45 <Cale> they can be updated easily
04:28:06 <Cale> the real loss is when you break lots of code which people are using but nobody is working on
04:28:09 <chucky> jknecht: darcs and perl6 are not haskell98, so they can't very well claim we are breaking anything if we change haskell98 ;)
04:28:11 <flux__> I read some discussion about (now dead?) python 3000
04:28:17 <Cale> but I don't think there's too much of that
04:28:23 <araujo> JKnecht, perl has always been broken ;-)
04:28:50 <flux__> one point was that some people were thinking that it might not be worthwhile to start studying the current python if python 3000 is going to change everything
04:29:28 <Cale> then again, since there's not a whole lot of proprietary Haskell code, most of the code which isn't actively maintained, if it's used a lot, will suddenly find maintainers
04:29:46 <flux__> and if it isn't used a lot, you lose..?-)
04:29:58 <Cale> If it's not used a lot, then nobody cares.
04:30:04 <araujo> Right.
04:30:41 <flux__> it was annoying enough that the haskell curses module didn't build nicely with ghc 6.4 for some time ;)
04:30:58 <araujo> As i said, haskell is new (both language and community), we can pay the price.
04:31:07 <flux__> btw, what kind of changes are there on the table, that would break backwards compatibility? language-wise or library-wise?
04:31:27 <Cale> Well, people want a records proposal of some kind.
04:31:58 <Cale> I and lots of others want to fix the class hierarchy, but that's not going to break *too* much.
04:32:25 <chucky> why do we want records in a functional language anyway? Isn't there some more functional construct?
04:32:35 <Cale> If your code relied on 'fail' in the Monad class really heavily somehow, then it might break :)
04:32:39 <araujo> Cale, like for example, putting 'fail' into a better class and such?
04:32:53 <araujo> mm ok
04:32:54 <flux__> are the records going to be much more than tuples with field names?
04:32:59 <Cale> araujo: we have a better class for fail anyway, MonadError
04:33:39 <araujo> Cale, right
04:33:41 <Cale> chucky: there are certain problems which are really messy which records deal with elegantly, but more functional approaches have trouble with
04:34:27 <flux__> maybe ghc could be patched to produce a summary of used language features, to semiautomatically gather statistics on how many programs would break if feature x was removed/changed
04:34:32 <Cale> Basically, exactly when you have a mandate to deal with great big globs of data of varying types.
04:35:09 <Saulzar> Hmm, are there any programs which don't use records?
04:35:11 <Cale> More specifically, when those data are fields with particular meanings.
04:35:15 <araujo> flux__, :-P
04:35:20 <Saulzar> I would have thought that just about everything ended up using records
04:35:24 <Cale> Saulzar: many programs don't use records
04:36:05 <chucky> I'm not really advocating removing records, I'm just wondering if thinking in terms of records is hindering us from seeing some better form of "functional records"
04:36:17 <Cale> Records in Haskell 98 are basically isomorphic to algebraic data types anyway
04:36:22 <chucky> because records, to me, seem more like an imperative constructs
04:36:23 <Cale> but that's also the problem
04:36:58 <Saulzar> What do you use instead? It seems often that there is a bunch of data which is indivisible
04:37:41 <Cale> Well, by breaking the data into fields in the first place, you're dividing it. You could carry that division further.
04:38:04 * araujo doesn't complain about records. They are needed sometimes.
04:38:10 <Saulzar> Also, if you're ever changing the data in a construct then that will break pattern matching
04:38:28 <araujo> I also don't see them as imposing some kind of 'imperative' impurity.
04:38:46 <Saulzar> Records do nicely with that, since usually your accessors won't change
04:38:49 <Cale> Saulzar: right. That's one of the reasons that we need a completely separate record construct
04:39:09 <Cale> Algebraic data types aren't really meant to be used in the way that people are using them for records.
04:39:17 <araujo> Saulzar, that's sweet
04:39:54 <Cale> We really need something closer to Trex records.
04:39:57 <Saulzar> I seem to use records everywhere, but I can't say I like 'em
04:40:16 <araujo> Saulzar, That's also why i see them as a mapping between data and functions.
04:40:49 <Saulzar> Though they're bearable if you stick to a strict hungarian-style prefix (ugh!)
04:40:56 <araujo> A nice encapsulated mapping.
04:40:57 <Cale> Algebraic data types are really more useful for types in your program which it doesn't make sense to "extend"
04:41:08 <Cale> Like, a binary tree data type
04:41:14 <Cale> you're never going to extend that
04:41:21 <Saulzar> Right
04:41:25 <Cale> Or lists, or various other things
04:42:05 <Cale> The fact that they can approximate records is perhaps unfortunate, because people start using them that way, and then wonder why their code has to be so inflexible
04:42:08 <Saulzar> Things which have certain structure by definition..
04:42:59 <Cale> Really, chucky is somewhat right, in that you should be designing things differently in a functional language. Then again, there are needs to interface with external systems which were designed in an OO fashion.
04:43:26 <Cale> In OO languages, they have the reverse situation as us.
04:43:35 <chucky> records are damn useful when you have state monads. :)
04:43:38 <Cale> Data is easy to extend, but interfaces to it aren't.
04:44:08 <araujo> They are still trying to figure out what the heell OO is all about? :-)
04:44:28 <Saulzar> Just changing the syntax to allow layout instead of { } would make them feel much nicer I suspect :)
04:44:49 <Cale> Whereas, in Haskell, the interface to data is easy to extend, but data types are inflexible. You set them once, and if they need to be changed, you have major rewriting to do.
04:45:36 <araujo> mm.. well Cale , it depends pretty much upon the OOP model really.
04:45:56 <Cale> The typeclass system helps that quite a bit here, but it's still a concern.
04:46:09 <araujo> That, considering, there exist 'differen't OOP models of course.
04:46:46 <Cale> Proper records would help a lot in cases where you expect that data will need extending.
04:46:49 <Saulzar> Hmm, they're all more or less similar with respect to defining data structures..
05:14:38 <JohnMeacham> Cale: what subsumes the proposal?
05:15:03 <Cale> Default class instances
05:15:56 <Cale> (by subsumes, I just mean that class aliases should be expressible in terms of it)
05:16:04 <JohnMeacham> I don't see how it allows abstraction of the class hierarchy though. (which is the major goal). allowing aliases to have different default instances is just an incidental step towards that goal.
05:16:29 <JohnMeacham> well, class aliases can be simply rewritten to standard classes. they were designed that way.
05:17:11 <Cale> Well, the annoyance is when you have some finely grained class hierarchy, and you want users to be able to define just one instance to get to the top of it.
05:17:20 <Cale> (or to some various point along it)
05:17:36 <Cale> Right?
05:18:06 <JohnMeacham> indeed. that is something the class aliases proposal allows. but it is just part of what lets the hierarchy abstraction happen.
05:18:28 <Cale> hmm
05:19:32 <JohnMeacham> however, I have not seen an alternate proposal that doesn't suffer from the issues raised in the thread about class aliases. namely that just allowing instances to declare methods of superclasses breaks certain important properties which were detailed in a mail to the list a while ago.
05:20:22 <JohnMeacham> Which I think the proposal floating on the list right now is. but have not been paying too much attention.
05:20:40 <Cale> yeah, I'd like to check that :)
05:22:21 <JohnMeacham> I want to implement the class alias thing for ghc. mainly because I need it :). also, I want people to be able to experiment with replacing the prelude in a non-toy-fashion.
05:22:22 <Cale> Really, my proposal is not to allow instances to declare methods of superclasses, but for the classes themselves to define the mechanism by which superclasses should be constructed.
05:23:29 <Cale> Which seems like it has a better chance of maintaining some of those properties, but I'm not completely sure about it.
05:24:38 <Cale> Perhaps it doesn't quite abstract the class hierarchies, but it does make such finely grained class hierarchies easy to use.
05:26:02 <Cale> JohnMeacham: do you have any real example where the string argument to 'fail' was useful?
05:26:22 <Cale> and which wouldn't be better served by MonadError or just throwing an exception?
05:26:56 <JohnMeacham> I use it constantly. I mean, it is how the pattern match failure message is generated.
05:27:07 <Cale> yes, but it doesn't need to be
05:27:19 <JohnMeacham> which not having would be a big problem.
05:27:27 <Cale> Lambdas already produce proper exceptions when they fail to pattern match
05:27:33 <Cale> with the line/column number
05:28:06 <JohnMeacham> but they just bottom out. you want the string to be processed by the monad as appropriate.
05:28:17 <Cale> but how do you use that string?
05:28:23 <JohnMeacham> that is the message which is passed to 'fail'
05:28:32 <Cale> It seems like in most monads, you can't really use it.
05:28:48 <JohnMeacham> 'runIdentity'
05:28:55 <Cale> hm?
05:29:15 <JohnMeacham> the identity monad. the NotJustMaybe pattern. I seriously use it a whole whole lot.
05:29:53 <Cale> Sorry, what? The identity monad has no natural notion of failure apart from bottoming out.
05:30:26 <Heffalump> didn't you have a good idea for making it possible to get error messages about the call site when you try to do head [] ?
05:30:29 <Cale> and when you do want a proper error monad, why not use MonadError?
05:30:45 <JohnMeacham> indeed. which is sometimes what you want, but other times you want to use Either and get the string out. you shouldn't have to rewrite your monadic code depending on whether you want to look at the pattern match failure message or not.
05:31:08 <Heffalump> that's one of the biggest problems I have with a program I wrote for work that an inexperienced (in Haskell programming) colleague has to modify - he makes silly mistakes and then we can't track them down easily
05:31:13 <Cale> Why not just catch the exception?
05:31:48 <JohnMeacham> Cale: because imprecise exceptions from pure code are really ugly and very difficult to use properly.
05:31:53 <Cale> Like, you're going to get an exception with a meaningful error message
05:32:03 <Cale> With a source code location in it
05:32:04 <Heffalump> mapException is ok, but a pain to annotate *everything* with it
05:32:06 <JohnMeacham> and you wouldn't be able to do anything with it until you get up to an IO monad.
05:32:24 <Cale> sure, but you can't do anything with that string anyway
05:32:31 <Cale> since you'd need to parse it in order to determine what's going on
05:32:42 <Cale> and the standard doesn't say how the string should look
05:32:57 <JohnMeacham> Cale: sure you can. I have monads which follow various paths and collect all error messagse into a list and present them to me in a pretty format.
05:33:24 <Cale> Okay, so why not use MonadError?
05:33:30 <JohnMeacham> Cale: there is no need to parse the string. but you often might need to process it.
05:33:55 <JohnMeacham> because pattern match failure is part of the 'do' notation translation.
05:33:57 <Cale> I suppose you don't get automatic pattern match failure exceptions that way
05:34:14 <Cale> But how often to you write refutable patterns like that anyway?
05:34:30 <Cale> It seems very very rare to me.
05:34:39 <JohnMeacham> and sometimes I do use a monad error. Either String, other times I use Identity and let it bottom out. but the code itself shouldn't change.
05:35:10 <Cale> hmm...
05:35:14 <JohnMeacham> parsers? 'x' <- char
05:35:19 <JohnMeacham> True <- assert something
05:35:33 <JohnMeacham> "this is the right string" <- parseString
05:35:46 <Cale> I just don't feel that people should be given this misconception that monads have a natural notion of failure.
05:35:57 <Heffalump> but they do :-)
05:35:59 <Cale> no
05:36:02 <JohnMeacham> they do.
05:36:02 <Heffalump> Haskell monads do.
05:36:07 <Cale> no they don't
05:36:10 <JohnMeacham> every haskell value does. 
05:36:14 <Cale> the Identity monad certainly doesn't.
05:36:21 <Heffalump> it does, because it lifts normal values
05:36:23 <JohnMeacham> bottom is an element of every haskell type.
05:36:26 * gour thinks it is getting interesting here...
05:36:29 <Cale> no, it's a newtype
05:36:39 <Cale> it's unlifted
05:36:40 <Heffalump> but it lifts the failure of the values it contains
05:37:01 <Heffalump> and they all have a notion of failure
05:37:06 <JohnMeacham> yeah, it need not 'double-lift'. but I wonder if such a monad would be useful? hmm...
05:37:29 <Heffalump> JohnMeacham: I doubt it, since you'd have to do evil things to distinguish the two bottoms.
05:37:47 <Heffalump> well, maybe not that evil, but it's not exactly nice
05:37:48 <JohnMeacham> Heffalump: I was thinking more for finely controling when things are evaluated.
05:37:52 <Heffalump> oh, right
05:38:01 <Heffalump> >>= would have to strip off the constructor
05:38:08 <Heffalump> so I don't think you'd get much more control
05:38:15 <Cale> I think that if you want failure, you should be very explicit about it, and use MonadZero
05:38:17 <Cale> or MonadError
05:38:49 <Heffalump> and we think that Haskell's _|_ is a good thing to use in some circumstances :-)
05:38:49 <Cale> and your monad should have non-bottom values in it to support that failure.
05:39:02 <JohnMeacham> their semantics are different though. 'fail' is sort of like their join. (handwavy, don't take too seriously)
05:39:13 <Cale> I don't think that bottom should ever be an expected way to define a class method.
05:40:05 <Cale> It's much much nicer when code is written to handle the errors as properly defined values.
05:40:06 <Heffalump> why not?
05:40:18 <Heffalump> it's more work that isn't needed
05:40:43 <JohnMeacham> bottom is just a reasonable default. the obvious one for the base 'identity' monad. 
05:41:53 <JohnMeacham> the beauty of this is that it does allow you to handle errors if you want. I pretty much always return results in a monad, even if I expect to only use them via 'runIdentity' because well, you never know. sometime I might want to properly handle errors. 
05:42:10 <JohnMeacham> not to say bottoming out is not a proper way to handle errors.
05:42:24 <JohnMeacham> sometimes it is a perfectly reasonable thing to do.
05:43:22 <JohnMeacham> though. I need to implement SRCLOC_ANNOTATE for ghc so it can be applied to runIdentity, then we can get the best of all worlds, the location runIdentity was called at _and_ the error message out of the monad. right now, you have to choose one or the other.
05:44:02 <JohnMeacham> (using a irrefutable pattern match on Just to get the monad call location in the error message)
05:44:25 <Cale> I'd rather people just stop thinking that monads support any separate notion of failure that we didn't already have.
05:44:53 <Cale> If it supports failure, it's more than just a monad.
05:45:19 <JohnMeacham> it's a lifted value :)
05:45:28 <Cale> hm?
05:46:33 <JohnMeacham> if you just let fail be its default implementation, then there is no problem. bottom was already a value in the monad.
05:46:45 <Cale> I'm okay with things bottoming out in case of programmer errors, but I'm not okay with using bottom as a representation for user failure.
05:47:10 <JohnMeacham> Cale: which is exactly why 'fail' is  a member of the monad class :)
05:47:28 <Cale> but no! It breaks that rule.
05:47:32 <Heffalump> why isn't bottom a valid representation of user failure?
05:47:36 <JohnMeacham> so you can redefine it as something other than bottom.
05:47:39 <Heffalump> a program can be a partial function
05:47:57 <Cale> Partiality should be represented with Maybe
05:48:27 <Cale> Not with exceptions that you have to apply Control.Exception.evaluate in order to catch in IO.
05:48:29 <JohnMeacham> Cale: ack! no. functions that return 'Maybe a' should be banned as horrible.
05:48:46 <Cale> JohnMeacham: with Maybe or MonadZero
05:48:56 <Heffalump> but all Haskell values are partial anyway
05:49:22 <Heffalump> I don't necessarily want to write several extra lines of code to handle user failure at the point I could detect it.
05:49:32 <JohnMeacham> Cale: hrm? no. I never use 'evaluate' or imprecise exceptions. I just call my partial functions with the 'Either String' monad rather than the 'Identity' monad if I want to recover from the error message.
05:49:46 <Cale> Heffalump: there's a difference between me screwing up and ending up with a nonterminating program, and the situation where I expect failure, and catch it responsibly.
05:50:08 <Heffalump> well, I don't always write robust programs.
05:50:11 <Heffalump> More effort, more robustness.
05:50:15 <JohnMeacham> Cale: which is exactly what 'fail' lets you do.
05:50:16 <Heffalump> And sometimes I want a program with little effort.
05:50:18 <Cale> JohnMeacham: why not just use Maybe instead of Identity and MonadZero rather than Monad?
05:50:33 <JohnMeacham> Cale: because that is horrible. you loose your error message! 
05:50:52 <Cale> well, you lose it anyway
05:51:06 <Heffalump> no, either the program fails with it or you can pull it out of the Either
05:51:09 <JohnMeacham> Cale: no you don't. it is returned as (Left "error message")
05:51:33 <JohnMeacham> or you can even have a monad that collects a non-deterministic list of all possible errors generated. 
05:51:34 <Cale> The identity monad isn't going to represent your error message for you any better than Maybe will
05:51:54 <JohnMeacham> Cale: yes it does, because it prints the error to the screen.
05:52:12 <Heffalump> it is, because _|_ in haskell actually has an error message attached usually
05:52:21 <Cale> ugh
05:52:26 <JohnMeacham> Cale: with Maybe, I just get a mysterious 'fromJust: not Just' error or something.
05:52:33 <Heffalump> it may not be semantically pure, but it's very useful and it works.
05:53:27 <Cale> Okay, then let's change the meaning of do-notation rather than the Maybe class.
05:53:28 <Cale> er
05:53:29 <JohnMeacham> Cale: or a location for the pattern match failure of the calling of the monad (not where the monad itself failed). that I can't get both those messages out was a major motivation of the SRCLOC_ANNOTATE pragma.
05:53:30 <Cale> Monad class
05:53:52 <Heffalump> or lets leave Haskell alone so that we can use the helpful features it has :-)
05:54:16 <Cale> I see fail as a misleading abomination
05:54:23 <Heffalump> and we like it
05:54:41 <JohnMeacham> Heffalump: I wouldn't leave it completly alone. but I don't think fail being in monad is all that unclean at all. it makes theoretical sense in a lazy language, and is wildly useful in practice.
05:54:50 <Heffalump> JohnMeacham: right
05:54:59 <Heffalump> I really just meant "let's not change it how Cale wants :-)"
05:55:17 <jyp> I'm with you Cale :)
05:55:24 <Heffalump> what exactly does SRLOC_ANNOTATE do?
05:55:37 <gour> i'm for haskell 2.x :-)
05:55:46 <Cale> I really don't understand why you'd want to allow for bottom at all if you expect failure.
05:55:59 <Heffalump> @topic-snoc The great fail-abolishment debate. For: Cale, jyp. Against: Heffalump, JohnMeacham
05:56:00 <JohnMeacham> A very common idiom is something like 'True <- assert something true' I'd hate to have to suddenly change my type signatures to use it.
05:56:01 <lambdabot> I do not know the channel The
05:56:07 <Heffalump> @topic-snoc #haskell The great fail-abolishment debate. For: Cale, jyp. Against: Heffalump, JohnMeacham
05:56:08 --- topic: set to '["Haskell is still the language of choice for discriminating hackers","logs: http://tunes.org/~nef/logs/haskell/","http://www.haskell.org/learning.html","Haskell IDE: http://haskell.org/hawiki/hIDE","http://www.haskell.org/tmrwiki/IssueFive","We put the Funk in Funktion","http://sequence.complete.org/hwn/20051129","HCAR 11/2005: http://haskell.org/communities/","dons for Emperor !","The great fail-abolishment debate. For: Cale, jyp. Against: Hef' by lambdabot
05:56:14 <Heffalump> bah
05:56:24 <Heffalump> topics need to be larger
05:56:30 <chucky> ha ha ha
05:56:36 <jyp> ;)
05:56:37 <Heffalump> @topic-init
05:56:38 <Heffalump> @topic-init
05:56:38 <lambdabot> I do not know the channel
05:56:39 <lambdabot> I do not know the channel
05:56:42 <Heffalump> @topic-init #haskell
05:56:43 <lambdabot> Topic does not parse. Should be of the form ["...",...,"..."]
05:56:49 <Cale> haha
05:56:52 <Heffalump> stupid bot
05:57:22 --- topic: set to '["Haskell is still the language of choice for discriminating hackers","logs: http://tunes.org/~nef/logs/haskell/","http://www.haskell.org/learning.html","http://www.haskell.org/tmrwiki/IssueFive","We put the Funk in Funktion","http://sequence.complete.org/hwn/20051129","HCAR 11/2005: http://haskell.org/communities/","The great fail-abolishment debate. For: Cale, jyp. Against: Heffalump, JohnMeacham"]' by Heffalump
05:57:40 <Heffalump> actually,we have @poll, don't we
05:57:49 <Cale> I really think that bottom should be reserved for unexpected failure.
05:58:02 <Heffalump> I expect users to be well-behaved.
05:58:23 <Cale> and that if you want your program to deal with failure, you should be representing it explicitly.
05:58:32 <gour> although a newbie, i've a feeling that Cale's proposition is right
05:59:40 <jyp> So, my contribution: I was quite surprised the first time I saw "fail" was in Monad. And since then always found the current state of things a bit hackish
05:59:46 <Saulzar> Hmm
05:59:57 <Saulzar> This reminds me of the "checked vs. unchecked" exceptions debate
06:00:06 <jyp> (but I'm not sure return to 1.4 is /the/ solution)
06:00:27 <gour> jyp: let's go to 2.x ;)
06:00:57 <Saulzar> Where, despite good intentions - the Java checked exceptions forcing you to be explicit about your behaviour, are mostly a pain in the ass
06:01:45 <Heffalump> @help poll
06:01:46 <lambdabot> poll provides: poll-list poll-show poll-add choice-add vote poll-result
06:01:46 <lambdabot> poll-close poll-remove
06:02:09 <Heffalump> @poll-add Should we remove the fail member from the Monad class?
06:02:10 <lambdabot> usage: @poll-add <poll>   with "ThisTopic" style names
06:02:16 <Heffalump> @poll-add "Should we remove the fail member from the Monad class?"
06:02:17 <Cale> Saulzar: except that programming with a general MonadError isn't a pain in the ass, and it does basically everything that these folks want fail to do, except implicitly catching pattern match failures.
06:02:17 <lambdabot> usage: @poll-add <poll>   with "ThisTopic" style names
06:02:51 <Heffalump> @poll-add RemoveFailMemberFromMonadClass
06:02:52 <lambdabot> Added new poll: "RemoveFailMemberFromMonadClass"
06:03:02 <Heffalump> @choice-add RemoveFailMemberFromMonadClass yes
06:03:03 <lambdabot> New candidate "yes", added to poll "RemoveFailMemberFromMonadClass".
06:03:11 <Heffalump> @choice-add RemoveFailMemberFromMonadClass no
06:03:12 <lambdabot> New candidate "no", added to poll "RemoveFailMemberFromMonadClass".
06:03:22 <Heffalump> @vote RemoveFailMemberFromMonadClass no
06:03:23 <lambdabot> voted on "no"
06:03:29 <Cale> @vote RemoveFailMemberFromMonadClass yes
06:03:29 <Heffalump> @help vote
06:03:30 <lambdabot> voted on "yes"
06:03:30 <lambdabot>  @vote <poll> <choice>        vote for <choice> in <poll>
06:03:54 <Heffalump> @poll-result  RemoveFailMemberFromMonadClass
06:03:55 <lambdabot> Poll results for RemoveFailMemberFromMonadClass (Open): no=1, yes=
06:03:55 <lambdabot> 1
06:04:01 <gour>  @vote RemoveFailMemberFromMonadClass yes
06:04:06 <Heffalump> @topic-init #haskell
06:04:07 --- topic: set to '["Haskell is still the language of choice for discriminating hackers","logs: http://tunes.org/~nef/logs/haskell/","http://www.haskell.org/learning.html","http://www.haskell.org/tmrwiki/IssueFive","We put the Funk in Funktion","http://sequence.complete.org/hwn/20051129","HCAR 11/2005: http://haskell.org/communities/"]' by lambdabot
06:04:17 <Heffalump> gour: get rid of the spaces at the start
06:04:23 <gour> @vote RemoveFailMemberFromMonadClass yes
06:04:24 <lambdabot> voted on "yes"
06:05:26 <Cale> Perhaps we need extended do-syntax for handling different kinds of failure with different corresponding class constraints.
06:06:02 <jyp> This feels the best to me...
06:06:21 <Cale> Or just disallow refutable pattern matches altogether. ;)
06:06:40 <jyp> Epigram for haskell 2.0!
06:06:41 <lennart> yes! :)
06:06:44 <chucky> @vote RemoveFailMemberFromMonadClass yes
06:06:44 <Saulzar> Hmm
06:06:45 <lambdabot> voted on "yes"
06:06:54 <jyp> gotcha lennart :)
06:07:18 <jyp> :p
06:07:27 <Saulzar> Disalowing refutable pattern matches _would_ be a pain :)
06:07:30 <lennart> @vote RemoveFailMemberFromMonadClass yes
06:07:31 <lambdabot> voted on "yes"
06:07:46 <jyp> @vote RemoveFailMemberFromMonadClass maybe
06:07:47 <lambdabot> "maybe" is not currently a candidate in this poll
06:07:54 <lennart> Saulzar: in do notation?
06:07:56 <jyp> @vote RemoveFailMemberFromMonadClass fail
06:07:57 <lambdabot> "fail" is not currently a candidate in this poll
06:08:14 <gour> jyp: yes or no
06:08:32 <Cale> jyp already voted, he's just joking :)
06:08:40 * jyp loves being stupid
06:08:53 <gour> ahh, i missed it :-(
06:09:21 <Saulzar> lennart, I wouldn't really know, though I suppose it feels nice if it is consistent
06:09:51 <Saulzar> Is there a real need to have pattern match in do trigger fail for the monad? (Rather than spit error at you as usual)
06:10:08 <JohnMeacham> Cale: it would be horribly anoying to rewrite my type sigantures just because I want to add an assertion.
06:10:46 <dcoutts> we've already mentioned I presume that removing fail from the monad class would break filtering in the list monad? Or is the idea that using a pattern would introduce an extra class constraint MonadZero?
06:13:29 <gour> dcoutts: hi, welcome back
06:13:50 <dcoutts> gour, ta
06:17:49 <gour> dcoutts: wp-2.0 is out, as well as spam-karma-2.1...however i'm reluctant to upgrade thinking about old mysql. what about migration to darcs?
06:18:21 <dcoutts> gour, wp-2.0 doesn't need a newer mysql does it?
06:18:25 <arjanb> what about introducing a MonadComprehension class that supports failing pattern matches plus some additional functions for efficiency?
06:18:33 <dcoutts> gour, yeah, I'd like to talk about the darcs conversion
06:18:38 * gour is checking...
06:18:55 <dcoutts> gour, I've got a bit of time this afternoon to do the conversion
06:19:08 <Heffalump> how are all these proposals for a different class intending to overload do notation?
06:23:27 <gour> dcoutts: yup, php &  mysql are ok..
06:23:35 <dcoutts> gour, ok
06:24:03 <gour> next week i can do it. i had seminar on friday & yesterday, today i take a break
06:25:21 <gour> dcotts: hower, in the meantime, i managed to arrive towards the end of 14th chapter (finally :-)
06:25:43 <gour> dcoutts: and i'm waiting for gnome dev guide book to arrive ;)
06:26:20 <gour> dcoutts: btw, what do you think about timing for haskell 2.x?
06:27:14 * gour happy to hear about gtk2hs' darcs migration to happen
06:27:50 <davidw> will there ever be a haskell 2.x? :)
06:28:06 <davidw> seems like that talk has been going on for quite a while
06:28:10 <dcoutts> gour, I got some nice books for myself for xmas too :-)
06:28:35 <dcoutts> "Types and Programming Languages" & "Advanced Topics in Types and Programming Languages" :-)
06:28:58 <dcoutts> (quite a variety I think you'll agree)
06:30:25 <gour> i assume it's for your phd thesis...
06:30:40 <lennart> @seen Cale
06:30:41 <lambdabot> Cale is in #haskell. Last spoke 22 minutes and 9 seconds ago.
06:31:30 <Philippa> dcoutts: cool, they're well worth reading
06:31:41 <Philippa> ATTaPL's got some decidedly interesting stuff in it
06:33:25 <gour> are you familiar with okasaki's book & Algorithms : A Functional Programming Approach
06:34:42 <gour> dcoutss: so now you can start working on a haskell-2.x draft fixing wahtever needs to be fixed in '98 :-)
06:34:56 <gour> dcoutts: so now you can start working on a haskell-2.x draft fixing wahtever needs to be fixed in '98 :-)
06:46:00 <Philippa> gour: I've not read it
06:47:08 <gour> Philippa: which one?
06:47:35 <lennart> Chris' book is worth reading.
06:48:08 <gour> lennart: how much it differs from the thesis?
06:48:24 <gour> and what about the 2nd book?
06:49:02 <lennart> gour: the one I read was basically the thesis, I think
06:49:19 <Philippa> gour: Okasaki's. I've got TaPL right next to me and ATTaPL somewhere behind me...
06:49:32 <Philippa> ah, there're two now? Cool
06:50:10 <gour> lennart: ahh,ok
06:51:01 <gour> anyone familiar with Algorithms: AFPA
06:57:27 <gour> is hs-plugins technology more or less finished?
06:57:42 <Philippa> depends how you define it, from what I can see
06:57:54 <Philippa> there're things that can be improved that'd involve improvements to the GHC RTS, for example
06:58:19 <Philippa> I wouldn't be surprised if someone looks at loading bytecode at some point, too
06:58:42 <gour> (i'm familiar with the concept, not the details, therefore asking for opinion of more experienced users)
06:59:46 <gour> but otherwise, it works?
06:59:55 <Philippa> yep
07:00:04 <gour> thanks
07:04:26 <dcoutts> Philippa, yeah, I've been working from a draft version of the 10th chapter of ATTaPL for several months.
07:05:00 <dcoutts> gour, I read Okasaki's Purely Functional Data Structures, but not A Functional Programming Approach
07:05:38 <gour> dcoutts: how you like it, ie. is it useful from a pragmatical point of view?
07:06:02 <gour> (i'm not interested for theoretical research)
07:06:17 <dcoutts> gour, Okasaki's book was one of the things that really got me interested in FP as an undergraduate
07:06:22 <dcoutts> it amazed me
07:06:32 <gour> hmm, interesting..
07:06:49 <gour> have you read his thesis, i.e. how much they differ?
07:07:04 <dcoutts> I've not read the thesis
07:07:28 <dcoutts> it does have practical hints about constant factors as well as theoretical complexity results
07:07:35 <gour> don't know is it useful to buy the book (after completing) thompson
07:07:43 <dcoutts> and it gives you a new perspective on lazyness
07:08:00 <dcoutts> it's a more advanced book than thompson's
07:08:11 <dcoutts> not much overlap I'd say, quite complementary
07:09:05 <gour> yes, that i understand, just wonder is it practical enough for my purpose, thesis is at: www.cs.cmu.edu/~rwh/theses/okasaki.pdf
07:09:30 <dcoutts> It does have quite a bit of theoretical stuff though. Eg how to construct amortized complexity proofs, which I did as an undergraduate but never understood until reading the book.
07:10:02 <gour> afaik, there are haskell examples at the end, for the whole book or just a sample?
07:10:11 <Philippa> you got to do far more fun stuff as an undergrad than UoN offers
07:10:48 <gour> dcoutts: i believe i'm not too interested for the proofs (had enough of them)
07:11:07 <dcoutts> that pdf looks like it has the same contents as the book
07:11:19 <Philippa> knowing how to prove something correct's often helpful in knowing how to construct something so you're pretty sure you could build the proof if you had to though
07:11:39 <Philippa> which is a good way of being 'reasonably' confident it's correct, not least because it also helps you figure out what tests to apply
07:12:56 * dcoutts agrees with Philippa 
07:13:33 <Saulzar> Hmm, an example?
07:14:22 <Saulzar> I've never felt the need to prove anything, testing seems easier than proving
07:14:25 <gour> Philippa: that's true, however my interest for haskell is more as a tool for solving concrete problems which have straightforward algorithms and/or procedures already defined
07:14:34 <Heffalump> Philippa: Okasaki's book isn't part of any course at Oxford, AFAIK
07:14:52 <Philippa> Heffalump: yeah, I'm more complaining about general lack of fun stuff than specific details as such
07:14:55 <gour> i.e. pragmatical approach :-)
07:15:14 <Philippa> gour: usually it's still helpful in being sure you're solving the right bunch of problems though
07:15:15 <Cale> dcoutts: the idea is to go back to the Haskell 1.4 way of doing things, or similar.
07:15:19 * Heffalump grumbles at Sunday trading laws and disappears
07:15:24 <Cale> lennart: back
07:15:52 <Philippa> Saulzar: write foldr. I bet you'll have something with a structure amenable to inductive proofs
07:16:28 <Cale> JohnMeacham: the idea is that only some monads actually support assertions.
07:17:12 <gour> Philippa: well, i'm trying not to skip over all the proof's-exercises in thompson book, but i believe those in okasaki's book are above my head and/or interest
07:17:20 <Cale> (properly anyway, you can always just bottom out, but I think that's a stupid way to explicitly handle failure)
07:19:02 <gour> Philippa: but i agree with you: deeper understanding (i.e. being able to prove) helps in better usage
07:20:14 <Welshy> Hey guys; I know this is really rude to just join and ask a favour, but I've got a haskell problem about data types, and was wondering if someone could help me out.
07:20:50 <Cale> Welshy: no problem!
07:21:00 <Cale> That's what we're here for :)
07:21:07 <Cale> What's your question?
07:21:56 <Welshy> > data Ancestor = Root | Ref ArticleIndex | Earlier [ArticleRef] deriving Ord
07:21:57 <lambdabot>  parse error on input `data'
07:22:10 <Welshy> I've got this data type, and I need to modify the Ref part to have two fields.
07:22:22 <Welshy> I'm not really sure how to go about that, though.
07:22:47 <Cale> you just write the type of the other field next to the ArticleIndex field that's already there
07:22:49 <lennart> Cale: I've got a new proposal for classes&instances based on yours.  I'll email it to you
07:22:59 <Cale> lennart: cool :)
07:23:14 <Welshy> So I'd just change it to 'Ref ArticleIndex Int', for example? 
07:23:17 <Cale> yeah
07:23:39 <Welshy> Wow, that was a lot easier than I thought it would be!
07:23:42 <Cale> Welshy: of course, if you do that, you'll have to modify all the functions which use that datatype
07:23:53 <Cale> there's no way around that though
07:24:07 <Welshy> That shouldn't be too bad, I was just a bit flummoxed on where to start.
07:28:39 <dcoutts> dons, you about?
07:33:37 <lennart> Cale: sent
07:37:25 <psnl> Welshy: your name is ringing a bell for some reason
07:38:04 <Cale> lennart: hmm... I seem to recall proposing that kind of thing before and people not liking it for some reason, however, it does seem quite similar to my current proposal, now that I think about it.
07:38:15 <Cale> How does it interact with the module system?
07:39:01 <Cale> I think we have that problem regardless.
07:39:21 <lennart> I don't think there's a problem with modules
07:39:34 <lennart> Not any more than we have now
07:39:37 <Cale> If a future module comes along and defines a new instance, it changes the way that previous modules worked.
07:40:04 <Cale> oh, however...
07:40:14 <Cale> hmm
07:40:47 <lennart> If the future module is in scope in the old one it can change things.  Otherwise it will be a multiple instance declaration error
07:40:49 <Cale> no, maybe not with the way we're doing things, because we're actually generating instances, no matter what
07:40:53 <lennart> which you can get today too
07:41:24 <lennart> All I see this as is a shorthand for writing instance declarations
07:41:29 <Cale> yeah
07:41:30 <Cale> okay
07:41:49 <Cale> hmm
07:41:57 <lennart> the only sematic part of it is checking what instances are already in scope
07:42:04 <Cale> how about multiparameter classes?
07:42:20 <Cale> (not that they're crucial)
07:42:28 <lennart> I don't know how it interacts with multiparameter classes
07:42:48 <lennart> I was just thinking of extending Haskell 98
07:42:53 <Cale> yeah
07:43:17 <lennart> but if it doesn't play with multiparam I don't think we can convince anyone
07:43:19 <Cale> We can probably save that problem for when it arises
07:43:25 <Cale> oh
07:43:41 <Cale> I mean, just don't allow this mechanism to apply to multiparameter classes.
07:43:55 <lennart> It would be a shame.
07:44:04 <Cale> hmm
07:44:09 <lennart> But do you think there's some problem?
07:44:34 <Cale> Well, how do you tell which instance you're actually defining?
07:44:37 <lennart> I mean, it's mostly a syntactic transformation (or can be seen as one)
07:44:58 <Cale> The rules you have there specifically mention the type T
07:45:12 <lennart> hmmm, yes
07:45:26 <lennart> it needs a little thought
07:45:29 <Cale> but if there are multiple parameters, you probably want to be able to say which type variables are going up
07:46:39 <Heffalump> could I see this proposal?
07:47:03 <lennart> what's your email address?
07:47:11 <Heffalump> ganesh at earth.li
07:47:27 <Heffalump> (not sure why I bothered spamtrapping that, it already gets loads :-)
07:49:10 <lennart> what I like about my version is that it can be seen as just relaxing restrictions rather than introducing new things
07:49:31 <Cale> lennart: aha, but your point about the class being in scope already or not is exactly what we need to make this sane
07:50:07 <Cale> I think the problem with previous proposals was that you could have this derived superclass sitting there and working, and then a future module could come along and override it.
07:50:30 <Cale> But with this, it's as if the programmer typed a complete instance into that module.
07:50:40 <lennart> Yes
07:50:43 <Cale> and so you'll just get the usual multiple instances error
07:50:51 <Heffalump> isn't this quite similar to JohnMeacham's proposal?
07:51:00 <Heffalump> (received, ta)
07:51:02 <lennart> It probably is
07:51:04 * jlouis returns from his absence
07:51:10 <Cale> JohnMeacham's proposal looks pretty different to me
07:51:46 <Cale> though it also has consequences which I don't fully understand which do look beneficial
07:52:24 <Heffalump> maybe I'm misremembering it
07:52:27 * Heffalump goes to read it again
07:52:28 <Cale> (you can define names for sets of classes, which you can't do here)
07:52:39 <lennart> that's true
07:53:01 <lennart> I should just grab ghc and implement it.
07:53:05 <Cale> however, I think the problems being solved are somewhat different
07:53:09 <Cale> lennart: yeah!
07:53:22 <Cale> I'd like to try this out and see how it works
07:53:25 <lennart> trying to implement something usually reveals all sorts of problems :)
07:53:29 <Heffalump> I was thinking of the supertyping proposal.
07:53:30 <Cale> hehe
07:53:34 <Heffalump> Which I think this would be needed for.
07:53:35 <Cale> oh
07:53:44 <Heffalump> but isn't enough for
07:55:11 <Cale> lennart: suppose that we remove the 'requiring' bit from my syntax, and simply allow classes to define instances which will always take effect when an instance for that class isn't already in scope -- does that solve the problem with multiparameter classes?
07:55:38 <lennart> I would have to think about that.
07:56:02 <lennart> Could you write up an example where my proposal breaks down?
07:56:11 <Cale> It's a little more typing for the class implementor, but I think that you'll end up needing to say what exactly instance you want at some point.
07:56:23 <Cale> Okay
07:57:26 <Cale> Let's say we want to allow, oh, say an instance of MonadState to give an instance of Monad, provided some extra details. (this isn't the best example, I'll admit :)
07:57:45 <Cale> MonadState has two type parameters, s and m
07:57:57 <Cale> and you need to say which one is going to get the instance of Monad
07:58:40 <Cale> I'm sure I could come up with a better example with a little work :)
07:59:39 <Cale> Say, some graph typeclass with the graph type, along with some additional label types, but you also want to be able to derive Functor from it and need to know which thing is getting the Functor instance.
08:00:22 <lennart> hmmmm, yeah.  I need to make some real examples to stare at
08:00:30 <Cale> more complicated is when you want to derive a generic instance for a multiparameter class from an instance of a single parameter class.
08:00:47 <Cale> though I suspect that's really rare
08:02:01 <Cale> I think that the proposal only applying to single parameter classes would be enough in practice, at least for now, but it would be nice not to have that seemingly arbitrary restriction.
08:02:16 <dcoutts> @seen CosmicRay
08:02:16 <lambdabot> I saw CosmicRay leaving #haskell-blah and #haskell 14 hours, 26 minutes
08:02:16 <lambdabot> and 10 seconds ago.
08:02:49 <lennart> yeah, arbitrary restrictions are annoying
08:03:24 <lennart> well, I'll ponder it.  but now I have to get going
08:07:46 <Heffalump> I think both of JohnMeacham's proposals sort of imply this proposal, FWIW
08:11:03 <jlouis> Lemmih: available?
08:11:13 <daten_> hey
08:11:20 <daten_> one question...
08:11:27 <daten_> whats wrong?
08:11:28 <daten_>      13 blub :: Int -> Int -> Bool
08:11:28 <daten_>      14 blub n i
08:11:28 <daten_>      15         | n == i        =       True
08:11:28 <daten_>      16         | teilbar n i   =       False
08:11:28 <daten_>      17         | otherwise     =       blub n i+1
08:11:38 <daten_> ERROR fu:15 - Instance of Num Bool required for definition of blub
08:12:01 <mauke> predefined factoid: "you're trying to make a career in computer science, that's what's wrong"
08:12:11 <Heffalump> daten_: blub n i+1 parses as (blub n i)+
08:12:11 <mauke> it's a precedence problem
08:12:12 <Heffalump> 1
08:12:17 <Heffalump> IM (blub n i)+1
08:12:21 <Heffalump> try blub n (i+1)
08:12:37 <daten_> thanks !!
08:12:40 <daten_> iw works
08:12:41 <daten_> it
08:13:50 <tromp_> looks like a slow primality test:(
08:14:27 <Heffalump> tromp_: what does?
08:15:10 <mauke> yeah, it checks all numbers from i to n for divisibility
08:15:48 <tromp_> blub does
08:16:24 <Heffalump> how do you know what teilbar does?
08:16:35 <Heffalump> I guess if you speak German you might have a better guess than me, though :-)
08:17:09 <mauke> http://dict.leo.org/?search=teilbar
08:17:41 <basti_> heffalump: divisible.
08:17:58 <Heffalump> ok :-)
08:18:07 <Heffalump> I still claim you can't _know_ what that program does ;-)
08:18:18 <basti_> i don't know, but i know what the name means
08:18:28 <Heffalump> but I guess you didn't say you did (where you = tromp_/mauke)
08:19:27 <basti_> uh
08:20:31 <Heffalump> anyway.
08:25:27 <tromp_> being dutch, i can understand basic german:)
08:25:52 <tromp_> teilbar == deelbaar
08:25:55 <basti_> ^^
08:27:13 <tromp_> so, a simple way to speed up blub is to replace n==i with n<=i*i
08:27:37 <tromp_> i mean n < i*i
08:28:27 <tromp_> and i+1 with i+2 after testing separately for even n
08:28:57 <Heffalump> in that route lies Eratosthenes
08:36:47 <sylvan> Is there any good way to do a "fair" orElse in STM? I.e. an orElse which doesn't necessariliy tries the LHS first? So if I read from one of two bounded channels which are hardly ever empty, I don't end up only reading the first one and ignoring the second?
08:37:44 <basti_> how about implementing something that alternates?
08:37:54 <ibid> could you somehow make it so that one channel is on the LHS only half of the time?
08:38:33 <sylvan> well i suppose for a special case, but then tomorrow I might want to choose between three channelse so I was thinking about implementing something more general
08:39:00 <ibid> well, the idea does generalize
08:39:12 <ibid> afaict
08:40:04 <sylvan> you mean that I write 2 handlers which does it in different orders, rigth?
08:40:15 <sylvan> so the number of handlers grows fast as more channels are added
08:40:40 <ibid> i don't follow
08:40:56 <ibid> bbl
08:41:12 <sylvan> so I have channels x and y.. When reading x it will continue by invoking a handler which tries y first, and vice versa
08:41:46 <sylvan> but that will mean what? 6 different ways to read three channels?
08:45:25 <sylvan> it gets ugly.. I'd want something like choice :: [STM a] -> (a -> Maybe (STM b)) -> STM [b], which will repeatedly try the STM actions in the list in a round robin order and if it succeds run the supplied action, and then continue running the rest, until the action returns Nothing
08:46:12 <sylvan> hmm.. I think that can be implemented actually..
08:49:18 <xerox> Who was the guy doing symbolic derivation in prolog here?
08:50:53 <_Codex> prolog sounds fun
09:02:31 <xerox> No luck, eh.
09:05:32 <musasabi> @poll-list
09:05:33 <lambdabot> Missing argument. Check @help <vote-cmd> for info.
09:05:40 <musasabi> This seems to be broken.
09:05:46 <musasabi> @help @poll-list
09:05:47 <lambdabot>  @help <command> - ask for help for <command>
09:05:56 <musasabi> @help poll-list
09:05:57 <lambdabot>  @poll-list                 shows all current polls
09:06:25 <xerox> Agreed.
09:08:08 <palomer> @help <vote-cmd>
09:08:09 <lambdabot>  @help <command> - ask for help for <command>
09:08:13 <palomer> @help vote-cmd
09:08:14 <lambdabot>  @help <command> - ask for help for <command>
09:08:16 <palomer> @help vote
09:08:17 <lambdabot>  @vote <poll> <choice>        vote for <choice> in <poll>
09:08:40 <palomer> lambdabot, you rock
09:08:45 <Heffalump> @poll-list #haskell
09:08:46 <lambdabot> ["BestBotPlugin","BestHarryPotterBook","BestPoll","RemoveFailMemberFromMona
09:08:46 <lambdabot> dClass","TheLanguageOfChoiceForDiscriminatingHackers","TopTenLibraries"]
09:08:49 <xerox> ah-ha.
09:09:01 <xerox> @poll-results TheLanguageOfChoiceForDiscriminatingHackers
09:09:02 <lambdabot> Poll results for TheLanguageOfChoiceForDiscriminatingHackers (Open):
09:09:02 <lambdabot> 13375p34k=1, Norvegian=3, Whitespace=1, Haskell=2
09:09:07 <xerox> Foo.
09:09:15 <Heffalump> @poll-results BestHarryPotterBook
09:09:16 <lambdabot> Poll results for BestHarryPotterBook (Open):
09:09:20 <palomer> whitespace the programming language?
09:09:27 <xerox> palomer: right.
09:09:28 <Heffalump> @poll-choices BestHarryPotterBook
09:09:29 <lambdabot> Unknown command, try @listcommands.
09:09:39 <Heffalump> @help poll
09:09:40 <lambdabot> poll provides: poll-list poll-show poll-add choice-add vote poll-result
09:09:40 <lambdabot> poll-close poll-remove
09:09:47 <Heffalump> @poll-show BestHarryPotterBook
09:09:48 <lambdabot> []
09:09:50 <xerox> @poll-show
09:09:51 <lambdabot> Missing argument. Check @help <vote-cmd> for info.
09:09:58 <Heffalump> oh dear :-)
09:09:59 <xerox> @vote
09:10:00 <lambdabot> Missing argument. Check @help <vote-cmd> for info.
09:10:11 <xerox> heh
09:12:08 <Saulzar> @poll-show BestPoll
09:12:09 <lambdabot> ["BestPoll"]
09:12:26 <Saulzar> @choice-add BestPoll BestHarryPotterBook
09:12:27 <lambdabot> New candidate "BestHarryPotterBook", added to poll "BestPoll".
09:12:52 <xerox> O_o
09:13:21 <Saulzar> Somone got rid of the Java votes in TheLanguageOf... :)
09:22:03 <ihope> Here's a function that grows decently fast.
09:22:16 <xerox> tetra? :)
09:22:52 <ihope> Let f(x) = the index of the first occurence of x in the list:
09:23:21 <xerox> s/=/be/, heh, if you want ;)
09:23:29 <ihope> do {a <- [1..], b <- [1..a], c <- [1..b], d <- [1..c], e <- [1..d], f <- [1..e], [1..f]}
09:28:23 <ihope> > let compose 0 _ param = param; compose num func param = func (compose (num-1) func param) in (\x -> compose x (\y -> compose y (\z -> z^z) y) x) 2
09:28:29 <lambdabot> Terminated
09:28:39 <ihope> Is that the Haskell expression for Mega?
09:30:56 <xerox> What is Mega?
09:31:26 <ihope> Well, here's a better definition:
09:32:59 <ihope> let compose 0 _ param = param; compose num func param = func (compose (num-1) func param); triangle x= x^x; square x = compose x triangle x; circle x = compose x square x in circle 2
09:39:53 <dcoutts> gour, you about?
09:40:15 <dcoutts> want to help me with the cvs->darcs conversion?
09:40:42 <dcoutts> I want to make sure I'm doing it right, and since you've done it before... :-)
09:42:43 <tromp_> those are all pretty slow growing
09:43:27 <tromp_> if you want fast growing functions, try
09:43:30 <tromp_> g b 0=b;g b n=g c$s 0n-1where s _ 0=0;s e n=mod n b*c^s 0e+s(e+1)(div n b);c=b+1
09:43:58 <tromp_> main=mapM_(print.g 2)[0..]where
09:47:11 <tromp_> this computes goodstein sequences
09:48:47 <gour> dcoutts:yep, solving some exercises :-)
09:53:46 <gour> dcoutts: what can i do?
09:54:31 <dcoutts> gour, I just want do double check with you that I'm using the right command/config to do the conversion
09:54:49 <gour> ok..
09:54:50 <dcoutts> I'll get back to you in a minute after re-reading the tailor README
09:55:01 <dcoutts> unless there is a better doc to read elsewhere?
09:56:21 <dcoutts> gour, should I be using darcs-1.0.5 do you think?
09:56:44 <ihope> tromp: is that an expression?
09:56:49 <ptolomy> Say, I created a special purpose multi-threaded webserver, but whenever the browser hits "stop", it kills the whole app with "broken pipe". I'm doing a 'catch' on my hPutStr, but it ain't catching it. I need something else?
09:57:24 <gour> dcoutts: i think so
09:57:31 <dcoutts> ok
09:57:32 <gour> dcoutts: http://darcs.net/DarcsWiki/Tailor/VersionOne
09:58:12 <Heffalump> ptolomy: is the code somewhere?
09:58:19 <dcoutts> gour, but for tailor manual/docs?
09:58:22 <ptolomy> No, but it can be..
09:58:28 <Heffalump> catch isn't enough to catch signals, anyway
09:58:36 <Heffalump> you need a signal handler
09:59:05 <Heffalump> also, be careful about catching exceptions in one thread before passing data to another thread
09:59:19 <Heffalump> often, you'll find that the data isn't evaluated before being passed, so catching the exception doesn't help
09:59:28 <Heffalump> I find myself using DeepSeq a lot to do that kind of thing
10:00:36 <gour> dcoutts: right, i was thinking about README.html referred
10:00:39 <sproingie> anyone successfully used tailor to do a two-way sync?
10:01:42 * sproingie is looking at the TwoWaySync page which is just a vague description of how it *might* work
10:04:09 <ptolomy> Heffalump, http://kyle.consal.us/code/haskell/Main.hs   --  So I'll want to be making use of System.Posix.Signals?
10:06:09 <Heffalump> ptolomy: yeah
10:06:15 <ptolomy> Thanks.
10:06:28 <Heffalump> well, I assume so, if you're dying with broken pipe
10:10:17 * ihope writes a Malbolge interpreter
10:13:40 <musasabi> What is System.Console.Shell and why does lambdabot require it?
10:13:50 <musasabi> scripts/lambda/src/LambdaShell.hs:import System.Console.Shell
10:26:14 <musasabi> mmh, just noticed. lambdabot does not work on a channel named #lambdabot
10:27:11 <Heffalump> how come?
10:27:31 <ihope> > [ undefined | _ <- undefined | _ <- undefined ]
10:27:33 <lambdabot>  Illegal parallel list comprehension: use -fglasgow-exts
10:29:46 <musasabi> Heffalump: I think it is the "ignore stuff said by myself" code acting up.
10:30:27 <Heffalump> ah :-)
10:30:27 <ihope> > let orange = ("1,7"++) in orange "No, I do NOT use mIRC."
10:30:29 <lambdabot>  lexical error in string/character literal
10:30:55 <ihope> ...Huh?
10:33:21 <ihope> > ""
10:33:23 <lambdabot>  lexical error in string/character literal
10:35:38 <lennart> huh?
10:35:55 <ihope> > error "Huh?" :: Int
10:35:56 <lambdabot> Exception: Huh?
10:35:58 <lennart> > "a"
10:36:00 <lambdabot> "a"
10:36:11 <ihope> > "%H"
10:36:13 <lambdabot> "%H"
10:36:24 <lennart> error "" :: Int
10:36:30 <lennart> > error "" Int
10:36:31 <lambdabot>  Not in scope: data constructor `Int'
10:36:33 <ihope> I think lambdabot doesn't like mIRC color codes.
10:36:49 <ihope> ...Or any mIRC codes.
10:36:51 <Heffalump> ihope: I except they get turned into something that confuses it by the time it sees them
10:36:58 <Heffalump> > ""
10:36:59 <lambdabot>  lexical error in string/character literal
10:37:05 <lennart> > ""
10:37:07 <lambdabot> ""
10:37:08 <ihope> Probbertively.
10:37:11 <Heffalump> > show ""
10:37:13 <lambdabot>  lexical error in string/character literal
10:37:18 <Heffalump> > show "\\"
10:37:19 <lambdabot>  lexical error in string/character literal
10:37:37 <lennart> well, it's your own fault then :)
10:38:03 <ihope> > let 1,9green = 3 in 1,9green
10:38:04 <lambdabot>  parse error on input `,'
10:38:14 <Heffalump> :-)
10:38:34 <_Codex> what's with these green boxes?
10:38:35 <ihope> let 3green = 3 in 3green
10:38:49 <ihope> %C1,7
10:39:03 <ihope> ...I mean %C1,9
10:39:14 <ihope> > let 3green = 3 in 3green
10:39:15 <lambdabot>  lexical error
10:39:24 <sieni> argh
10:40:07 <jyp> This kind of stuff deserves kick-out in some channels :)
10:40:21 <Heffalump> trying to confuse lambdabot is funny, though :-)
10:40:32 <lennart> > let (+) + 1 = 3 in 1 + 1
10:40:34 <lambdabot> 3
10:40:49 * edwinb checks the haskell report to see what the semantics of green text is
10:40:55 <Heffalump> evil lennart :-)
10:41:26 <Heffalump> > let (+) (+) 1 = 3 in 1 + 1
10:41:28 <lambdabot> 3
10:41:37 <Heffalump> > let (+) (+) 1 = 3 in 4 + 1
10:41:38 <lambdabot> 3
10:41:56 <jyp> > let 1 + 1 = 1 in 1 + 1 + 1
10:41:58 <lambdabot> 1
10:42:15 <Heffalump> I didn't know you could make function arguments be operators
10:42:23 <lennart> > let (+) + (n + 1) = 3 in 1 + 1
10:42:25 <lambdabot> 3
10:42:32 <Heffalump> > let (+) + 1 = (+) in 1 + 1
10:42:33 <lambdabot> 1
10:42:34 <ihope> @type let (+) (+) 1 = 3 in 1 + 1
10:42:36 <lambdabot> forall t. (Num t) => t
10:42:47 <ihope> Hmm.
10:42:58 <ihope> Oh, I get it!
10:43:03 <basti_> you're sick
10:43:12 <ihope> The (+) is being assigned a value...
10:43:15 <jyp> it can make sense...
10:43:16 <Heffalump> ihope: right
10:43:25 <Heffalump> well, bound to a value
10:43:29 <jyp> foldr k (*) l = ...
10:43:33 <ihope> > let 1 + 1 = 1 in 1 + 1 + 2
10:43:35 <lambdabot>  Non-exhaustive patterns in function +
10:43:39 <Heffalump> jyp: right
10:43:50 <lennart> it's especially confusing with n+k patterns :)
10:44:15 <jyp> Let vote n+k patterns out of haskell 2.0, btw :)
10:44:15 <Heffalump> lennart: yeah :-)
10:44:16 <ihope> let ((+)+3)+(-) = ...
10:44:44 <ihope> Oh, uh, testing.
10:45:09 <ihope> 3,4Moretesting(!)
10:45:18 <basti_> reverse text is allowed by the IRC standard.
10:45:22 <jyp> Now, that makes me sick L)
10:45:27 * dcoutts too
10:45:36 <ihope> All I see is [\0x12]
10:45:48 <_Codex> boxes, more boxes, more more boxes, ...
10:46:48 <basti_> I have colors turned off.
10:47:32 <lennart> help, I can't stop
10:47:34 <lennart> > let (-)+((+)+1) = (*)(+)(-) in 1 + 3
10:47:36 <lambdabot> 2
10:47:44 <ihope> Hehe
10:47:51 <basti_> urts.
10:47:53 <basti_> hurts.
10:48:23 <_Codex> it looks bad even with colors on.
10:48:24 <chucky> lennart: ouch, you are breaking my brain! :)
10:48:31 <ihope> > let x + y = (y-1) * x in 1 + 3
10:48:33 <lambdabot> 2
10:48:50 <ihope> Might as well make that x * (y-1)
10:49:01 <Heffalump> let y+1 = 3 in y
10:49:06 <Heffalump> > let y+1 = 3 in y
10:49:08 <lambdabot>  Not in scope: `y'
10:49:17 <Heffalump> why isn't that an n+k pattern?
10:49:28 <Heffalump> (obviously it _could_ be parsed two ways)
10:49:30 <lennart> > let (y+1) = 3 in y
10:49:32 <lambdabot> 2
10:49:34 <Heffalump> ok
10:49:39 <ihope> Wow!
10:49:39 <lennart> it's sick
10:49:44 <Heffalump> yeah.
10:49:48 <Heffalump> down with n+k!
10:50:09 <lennart> but you've been educatued at the bastion of n+k ;)
10:50:10 <_Codex> oh that is so neat.
10:50:10 <ihope> Well, me gots to go.
10:50:12 <edwinb> which is more sick between let (y+1) = 3 in y and let (-)+((+)+1) = (*)(+)(-) in 1 + 3?
10:50:17 <edwinb> Actually, don't answer that.
10:50:40 <sproingie> wow, i thought n+k was gone
10:50:54 <ihope> You know, n+k patterns in lambda calculus are... common or useful or something like that.
10:51:11 <Heffalump> actually, often I'd argue for n+k on the grounds that it's just a special view.
10:51:18 <Heffalump> But that example is a good reason not to.
10:51:22 <sproingie> why not generalize it?
10:51:34 <basti_> n^k patterns?
10:51:44 <sproingie> n! patterns :p
10:51:46 <lennart> yes, if there were a good generalization I'd be for it
10:52:12 <_Codex> > let (y*2) = 3 in y
10:52:13 <lambdabot>  Parse error in pattern
10:53:31 <lennart> Some language had some sick extension with multiplication as well
10:53:44 <lennart> like 'f (2*n+1) = n'
10:54:13 <jyp> looks like the good generalization is called logic programming
10:55:06 <_Codex> yeah, if (+) works, then (*) has to work, or its completely unusable.
10:56:01 <lennart> having n+k work makes sense for natural numbers.  But Haskell doesn't have a type of Natural numbers
10:56:03 <_Codex> but ideally we would have it for general functions: let (f a b) = 4 in a + b :)
10:59:58 <ivank> a newby question: is there a standart balanced tree implementation? like map or set in c++
11:00:15 <jyp> _Codex, you might be interested in mercury :)
11:00:25 <jyp> ivank: yes
11:00:41 <jyp> Data.Map & Data.Set
11:00:55 <ivank> oh. thank you
11:01:05 <jyp> my pleasure
11:01:45 <jyp> @seen shapr
11:01:46 <lambdabot> I saw shapr leaving #haskell and #ScannedInAvian 7 hours, 14 minutes and
11:01:46 <lambdabot> 44 seconds ago.
11:03:58 <lennart> Has ghc converted to darcs yet?
11:04:15 <jyp> readonly
11:04:28 <lennart> good enough for me
11:05:25 <lennart> where can i find it?
11:05:52 <jyp> I'm looking for the announce... 
11:06:18 <jyp> http://cvs.haskell.org/trac/ghc/wiki/GhcDarcs tells about it
11:06:27 <lennart> thanks!
11:06:58 <jyp> my pleasure :)
11:15:35 <musasabi> dons: What is the best way to do cron-like actions with lambdabot ?
11:16:34 <musasabi> dons: my module wants to do stuff once in a month.
11:27:35 <JKnecht> add a function (to bot) which writes a cron script given path of your module and time spec?
11:32:52 <xerox> musasabi: what exactly? :)
11:32:54 <Cale> musasabi: Other modules seem to store and keep track of state in files in the State/ directory, so conceivably you could store the time that the job last ran in a file there, and compare the current time to that of the file periodically.
11:41:48 <musasabi> xerox: log file rotation.
11:42:31 <ihope> Let's see. A sequence beginning with 2...
11:42:34 <musasabi> currently I just check for "should we do stuff" once for each irc-message which is kind of excessive.
11:42:43 <ihope> sequence = 2 : undefined
11:42:50 <ihope> Aha!
11:44:06 <ihope> > let sequence = scanr (^) 2 sequence in sequence
11:44:08 <lambdabot> Exception: <<loop>>
11:44:17 <ihope> ...Um.
11:44:29 <ihope> > let sequence = 2 : scanr (^) undefined sequence in sequence
11:44:31 <lambdabot> Exception: stack overflow
11:47:57 <ihope> What I'm looking for is a sequence, starting with 2, in which each number is all the previous numbers stacked in a "power tower".
11:49:09 <ihope> 2 : 2 : 4 : 65536 : error "After all, error never returns the wrong value."
11:49:58 <ihope> If I'm not mistaken, that makes for a quickly-growing sequence.
11:51:34 <sylvan> power tower?
11:51:54 <ihope> Like 1^2^3^4^5...
11:52:14 <ihope> All right-associative, thus making a "tower" of powers in the "normal" notation.
11:52:20 <ihope> i.e. superscript.
11:52:22 <sylvan> so [2, 2, 2^2, 2^2^(2^2), ...]?
11:52:31 <ihope> Yeah.
11:52:45 <ihope> > 2^2^(2^2)
11:52:46 <lambdabot> 65536
11:53:52 <ihope> I suppose each would be the self-exponentiation of the previous one.
11:55:21 <sylvan> hmmm
12:03:29 <jwp> how do I get a list to span multiple lines? f = [\n2,\n4,\n,etc..]
12:03:46 <sylvan> jwp, what do you mean?
12:03:47 <gzl> what do you mean?
12:04:26 <jwp> something like:
12:04:28 <jwp> f = [
12:04:30 <jwp>  2,
12:04:32 <jwp>  3,
12:04:33 <jwp> ]
12:04:36 <jwp> however
12:05:03 <jwp> The elements(?) are much longer, so having them all on the same is ugly.
12:05:16 <Cale> that should work
12:05:17 <jwp> same^line^
12:05:19 <jwp> hrm
12:05:29 <Cale> just make sure that the ] is spaced in farther than f
12:05:44 <gzl> oh, you mean when you define it?
12:05:47 <gzl> or when it gets printed out?
12:07:08 <jwp> ugh
12:08:17 <jwp> http://rafb.net/paste/results/a2ilx893.html
12:09:19 <Cale> jwp: missed a ) in the first element
12:09:25 <astrolabe> You don't need all those ((()))) I don't think.
12:09:36 <jwp> fsc k
12:10:21 <jwp> Cale: I think I accidentally deleted one when I was testing a change from using (foo:bar:feh:[]) before
12:10:27 <jwp> arg
12:10:47 <Cale> chr $ fromEnum $ x `shiftR` 24
12:10:53 <Cale> no parens
12:11:17 <ptolomy> hm. apparently asking ghci to tell me how many digits are in the millionth fibonacci number causes it to commit suicide.
12:11:18 <jwp> ah, nice
12:11:23 <Cale> also, .&. is an infix operator
12:11:32 <Cale> x .&. 0x00ff0000
12:11:43 <Cale> you don't have to use it prefix
12:11:45 <jwp> Cale: I think it cursed at me when I tried that in ghci
12:11:55 <Cale> try again :)
12:12:31 <astrolabe> prolomy: Roughly how many do you think that would be?
12:12:58 <gour> any haskell lib for calculating min/max/zero, lagrange interpolation etc. ?
12:13:08 <ptolomy> astrolabe, If I were forced to guess, I'd say 400,000..
12:13:14 <Heffalump> ptolomy: segfault?
12:13:19 <jyp> jwp, map is also your friend to apply a function to every element of a list
12:13:31 <ptolomy> nah. "Killed". Euthenized by linux, methinks.
12:13:32 <jwp> 123 .&. 0x00FF; <interactive>:1:4: Not in scope: `.&.'
12:13:32 <jwp> , :m +Data.Bits <interactive>:1:4:
12:13:32 <jwp>     Ambiguous type variable `a' in the constraint:
12:13:32 <jwp>       `Bits a' arising from use of `.&.' at <interactive>:1:4-6
12:13:32 <jwp>     Probable fix: add a type signature that fixes these type variable(s)
12:13:58 <Heffalump> ptolomy: ah, ok. I managed to make a pure Haskell program segfault once by getting it to ask gmp to do something unreasonable.
12:13:59 <jwp>  (123 :: Int) .&. 0x00FF
12:14:01 <jwp> that works
12:14:03 <ncalexan> Try (123 .&. 0xFF) :: Int.
12:14:20 <jwp> ncalexan: thanks :)
12:14:45 * jwp can't wait till he fully groks haskell =)
12:15:25 <Cale> jwp: yeah, in ghci, you don't have the benefit of all the type constraints that you'd have in a real program
12:15:35 * ptolomy really enjoys the fact that with haskell, stories of segfaults fall into the same category as ghost stories.. unlike C/C++, where they fall into the same category as "yesterday I saw a car" stories.
12:15:38 <Cale> so you have to resolve ambiguities more often
12:15:44 <jwp> jyp: right, I imagine I could generalize that function eventually. However, my limited fp-wisdom prohibits it for the time being.
12:16:23 <Cale> jwp: You'll likely have a type signature already in your actual program which takes care of the job of the ":: Int" here
12:18:10 <Cale> jwp: what jyp was referring to is pulling the repeated chr . fromEnum out
12:18:31 <Cale> serializeNetworkWord32 x = map (chr . fromEnum) [ ... ]
12:18:59 <jwp> ah
12:20:04 <Heffalump> ptolomy: I was still a bit upset to get it :-)
12:20:33 <jwp> Cale: nice
12:20:39 <Cale> What's with these people that claim it's hard to come up with unique names for functions, and therefore want arbitrary ad-hoc overloading?
12:21:01 <Cale> Or obscene amounts of namespace partitioning.
12:21:22 <Heffalump> it would be nice if record accessors could implement type classes
12:21:25 <ncalexan> Cale: don't you find that prefixes and suffixes get a little annoying?
12:21:32 <Cale> BUY A THESAURUS!
12:21:33 <Cale> hehe
12:21:34 <ncalexan> leftM, rightM, leftB, rightB.
12:21:57 <ncalexan> addE, subE... some things have good names that are a little too general :)
12:22:10 <jyp> Cale: They are still thinking in foreign languages ...
12:22:11 <Cale> I don't really mind them, up to the point where you really should be using a typeclass.
12:22:16 <Heffalump> class HasLeft a b | a -> b where left :: a -> b
12:22:31 <Heffalump> class HasRight a b ....
12:22:35 <Cale> mapM is fine, for example.
12:22:56 <Cale> mplus mzero, don't bother me.
12:23:11 <Cale> (though I'd rather the former was called ++)
12:23:35 <jyp> mappend ?
12:24:03 <Cale> jyp: ?
12:24:11 <Cale> We're referring to the prefixes
12:24:20 <Cale> or postfixes
12:24:23 <jyp> How would Monoid fit into your grand scheme ? :)
12:24:57 <Cale> oh, those names are fine
12:25:27 <Cale> I don't really mind that mempty is different from mzero too much.
12:26:20 <Cale> Though it does suggest a potential use for kind-polymorphism
12:28:31 <musasabi> @seen dons
12:28:32 <lambdabot> dons is in #haskell. Last spoke 11 hours, 46 minutes and 56 seconds ago.
12:29:23 <ncalexan> Cale: I can only imagine trying to decipher the GHC kind-polymorphism error messages...
12:31:16 <musasabi> Is there a clean way to get from LB land to the ModuleT land in a given module with lambdabot?
12:31:33 <Cale> ncalexan: :)
12:33:03 * musasabi is trying to decide whether to use his own ugly state or the lambdabot provided clean one.
13:10:58 <ihope> Aah, my username keeps changing itself!
13:11:16 <ihope> Good thing it's not my password that's gone crazy...
13:11:36 <xerox> When it'll get to some risky evoluionary stage you'll either have to kill it, or let it free.
13:26:35 <ihope> Wait... my password or the tripods?
13:26:36 <ihope> http://urlx.org/wikimedia.org/f884
13:29:50 <ihope> Those are cute little guys, in their own special way...
13:43:26 <ihope> > lex "~hdc0D!308hyS@h8"
13:43:27 <lambdabot> [("~","hdc0D!308hyS@h8")]
13:44:27 <ihope> I heard that if you define a readsPrec function for a type, you'll be able to use it in Haskell programs as if it were a builtin...
13:44:33 <ihope> Just how true is that?
13:44:45 <basti_> heh?
13:45:17 <ihope> > lex "<345>"
13:45:18 <lambdabot> [("<","345>")]
13:45:38 <ihope> > lex "#hat"
13:45:39 <lambdabot> [("#","hat")]
13:48:31 <ihope> > let bot = bot in bot
13:48:33 <lambdabot> Add a type signature
13:48:58 <ihope> > let self x = x x in self Just
13:49:00 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
13:49:00 <lambdabot>   Expected type: t
13:49:00 <lambdabot>   Inferred type: t -> t1
13:49:04 <ihope> Yay!
13:51:35 <Heffalump> yay?
13:51:51 <Heffalump> > let self x = x (x self) in self Just
13:51:53 <lambdabot>   Occurs check: cannot construct the infinite type: t = (t -> t) ->
13:51:53 <lambdabot> t
13:51:53 <lambdabot>   Expected type: t
13:51:53 <lambdabot>   Inferred type: (t -> t) -> t
13:52:24 <Heffalump> > let self = fix (\x -> x (x self)) in self Just
13:52:25 <lambdabot>   Occurs check: cannot construct the infinite type: t = t1 -> t
13:52:25 <lambdabot>   Expected type: t1 -> t
13:52:25 <lambdabot>   Inferred type: t
13:53:10 <ihope> Are you trying to make a \x -> x x?
13:53:21 <Heffalump> not very seriously
13:54:45 <SamK> hi, I was wondering, is haskell basically compiled by substitution?
13:55:36 <ihope> Compiling of a functional language into an imperative one is never (especially) easy.
13:56:03 <lennart> how it's compiled depends on the compiler
13:56:09 <ihope> Bingo
13:56:38 <lennart> but in some sense it compiled by substitution
13:57:09 <ihope> True
13:58:07 <SamK> ok, I can picture each function being inlined into the place of reference, with params subtituted, until the whole thing is one huge thing to execute, would this be vaguely accurate?
13:58:31 <Heffalump> yes
13:58:39 <Heffalump> except for recursion
13:58:49 <ihope> Haskell can be compiled however the compiler wants to compile it.
13:59:04 <ihope> As long as it's correct, that is.
13:59:07 <SamK> ihope: ok, I was trying to get a general feel of how it might work
14:00:09 <lennart> SamK: most (all?) compilers use a version of compiled graph reduction
14:00:45 <lennart> and graph reducion can be viewed as an efficient way to do substitution
14:00:58 <sproingie> isn't all compilation substitution in some way?
14:01:25 <ihope> ...Yes.
14:01:26 <sproingie> or is there a more formal definition of substitution?
14:01:39 <ihope> Except those which leave the source code intact.
14:01:44 <lennart> well, in some way they have to be since Haskell semantics is defined that way
14:03:25 <SamK> so, is machine code (basically) produced by stitching together the resulting primitives after reduction?
14:04:15 <lennart> ummmmm, i'm not really sure what you mean, but it doesn't sound right
14:05:20 <ihope> Well, since Haskell is referentially transparent (or approximating it), there's not much need to know...
14:05:35 <ihope> @index performUnsafeIO
14:05:37 <lambdabot> bzzt
14:06:31 <dcoutts> The semantics of Haskell is actually quite tricky to pin down. There's a couple of papers in JFP dedicated to the issues.
14:06:35 <SamK> guess I'm curious how the result of graph reduction gets transformed into proccessor code
14:07:02 <SamK> probably should examine a compiler ;)
14:07:21 <dcoutts> or read Simon PJ's book
14:07:30 <lennart> it's not the result of graph reduction that is transformed.  the graph reduction itself is turned into machine code
14:07:45 <lennart> yes, Simon's book explains it well
14:07:52 <SamK> ah, I think I understand
14:08:28 <SamK> will check out the book, thanks
14:09:00 <lennart> Or if you want something shorter you can look at Thomas Johnsson
14:09:16 <lennart> 's original G-machine paper
14:17:03 <lennart> @seen Cale
14:17:04 <lambdabot> Cale is in #haskell. Last spoke 1 hour, 45 minutes and 34 seconds ago.
14:17:39 <ihope> @seen lambdabot
14:17:40 <lambdabot> Yes, I'm here. I'm in #ScannedInAvian, #haskell.es, #haskell.it, #gentoo-
14:17:40 <lambdabot> haskell, #haskell-overflow, #flippi, #haskell-blah and #haskell
14:17:44 <ihope> :-)
14:18:34 <lennart> @yow
14:18:35 <lambdabot> Is this an out-take from the "BRADY BUNCH"?
14:19:25 <lennart> @djinn-env
14:19:26 <lambdabot> data () = ()
14:19:26 <lambdabot> data Either a b = Left a | Right b
14:19:26 <lambdabot> data Maybe a = Nothing | Just a
14:19:26 <lambdabot> data Bool = False | True
14:19:26 <lambdabot> data Void
14:19:28 <lambdabot> type Not x = x -> Void
14:19:30 <lambdabot> type Cont r a = (a -> r) -> r
14:22:44 <araujo> Hello.
14:22:55 <akemp> Hey.
14:23:39 <akemp> Anyone want to answer some questions about how to make certain arguments to a function Strict?
14:24:04 <ihope> I know you can use the seq function.
14:24:15 <ihope> \x -> seq x ...
14:24:17 <akemp> Doesn't seem to work for me.
14:24:28 <ihope> Just what are you trying to do?
14:24:30 <dcoutts> or you can pattern match on the argument
14:24:31 <akemp> (According to the -ddump-simpl
14:24:33 <lennart> seq makes it strict
14:24:47 <akemp> I'm trying to make the following strict:
14:25:03 <akemp> loopArray n f arr | n==0 = do return arr
14:25:15 <akemp>                       | otherwise = do arr' <- f arr
14:25:16 <Heffalump> strict in what?
14:25:27 <akemp>                                       loopArray (n-1) f arr'
14:25:38 <akemp> Strict in n, f and arr
14:25:49 <Heffalump> ok, it's already strict in n
14:25:50 <akemp> Currently the function is strict in "n"
14:26:03 <Heffalump> it'll have to be strict in f if n/=0
14:26:05 <lennart> strict in f seems like overkill
14:26:23 <akemp> True.  Okay, then strict in n and arr
14:26:38 <Heffalump> is f strict in arr?
14:26:44 <ihope> And seq's not doing it?
14:27:04 <akemp> "seq" didn't do it (according to my memory).
14:27:05 <lennart> so use 'seq arr $ do ...' in the second clause
14:27:06 <Heffalump> actually, it doesn't matter
14:27:50 <lennart> but why are you trying to do this?
14:28:10 <akemp> I think that "f" is strict in its arguments.
14:28:23 <akemp> I'm trying to do this because I'm getting massive space usage for a relatively simple algorithm.
14:28:31 <ihope> Ah
14:28:56 <akemp> Let me try "seq" again and I'll report back.  brb
14:29:02 <lennart> then I don't think making it strict in arr necessarily help.  arr is some data structure, right?
14:29:17 <akemp> arr is a datastructure (STArray)
14:29:40 <akemp> I'm trying to loop a function "f" over an array "arr" n times.
14:29:45 <lennart> So you want to make use the array elements are evaluated too
14:29:54 <lennart> you might want an UArray
14:30:25 <akemp> UnboxedArray?  My elements are not primitives.
14:30:38 <lennart> ah
14:30:45 <Heffalump> it seems most likely that its them not being evaluated that is your problem
14:30:58 <dcoutts> that is the array elements, not the array itself
14:31:38 <lennart> you might want to try some ! in the data structure you store in the array
14:31:59 <dcoutts> or seq the value before adding it into the array
14:32:36 <akemp> The low level datastructures are strict in their elements.  The STArray Int Planets might not be strict in Planets, though.
14:33:10 <akemp> e.g. Planet !Vec !Vec !Double
14:34:20 <dcoutts> STArray is non-strict in it's elements
14:34:28 <Heffalump> try doing seq before inserting them
14:36:04 <ihope> "map seq"?
14:36:46 <ihope> ...Eh. Something.
14:37:46 <jwp> haskell kicks ass =)
14:38:50 <ihope> No it doesn't. It allows the "kick ass" IO value to be executed.
14:38:55 <ihope> ;-)
14:39:35 <lennart> lol
14:40:05 <akemp> hmm...  Noodling with "seq"s and my heap is still growing to 3M when I'm looping over relatively simple datastructures.
14:40:36 <jwp> ihope: =)
14:41:23 <lennart> What's the type of Planets?
14:41:46 <lennart> or rather, what type is Planets
14:42:32 <akemp> data Planet = Planet !Vec !Vec !Double
14:43:15 <lennart> And you have an STArray of those?
14:43:26 <akemp> Yes, STArray s Int Planet
14:43:44 <lennart> And Vec?
14:43:58 <akemp> data Vec = Vec !Double !Double !Double
14:44:19 <lennart> Then it all looks very strict to me :)
14:44:27 <akemp> Yup.  Hence my confusion!
14:44:30 <lennart> what does the heap profiler say?
14:44:43 <akemp> Shows me using about 3M of heap
14:44:49 <lennart> of what?
14:45:04 <lennart> you need to look at the graphs
14:45:55 <akemp> Oh, the breakdown.  1M of "System", 500k of loopArray, 500k new_vel, update_velocity, etc
14:47:40 <lennart> System, not very helpful
14:47:48 <lennart> and loopArray?
14:48:27 <akemp> loopArray is the function that I provided above.  Used as follows
14:48:47 <akemp> loopArray (read arg) (update_position 0.01) arr
14:50:37 <lennart> And you're using the strict version of ST?
14:50:56 <akemp> I think so.  I pulled in Control.Monad.ST.
14:51:05 <lennart> yup
14:51:41 <akemp> Although I love Haskell as a language, this memory issue kills me.
14:52:34 <lennart> well, my experience is that with some experience with heap profiling you can usually fix space leaks pretty fast
14:52:42 <lennart> but it takes some work
14:52:50 <akemp> I'd love to have that experience!!!  
14:53:50 <akemp> I'm not unfamiliar with the heap profiling tools, I just don't know how to convert that to fixing my issue.
14:54:58 <jethr0> moin moin
14:55:16 <lennart> so first figure out what all those loopArray things that are hanging around is.  Limit the profile to loopArray and look at a different view
14:55:44 <edwinb> Does anyone know if there is a wxhaskell binary for ghc 6.4.1 on linux anywhere? Or am I going to have to work out why it doesn't compile?
14:55:56 <lennart> Have you read Colin Runciman's original heap profiling paper?
14:56:08 <akemp> I have not read that.  I'll look right now.
14:56:13 <lennart> It gives some good hints on how to proceed
14:56:39 <lennart> Getting the general profile is just the first step.  Then you need to focus
14:56:57 <akemp> Which flags would you recommend for following loopArray?  -hcloopArray?
14:57:25 <lennart> I can't remember the exact ghc flag names
14:59:28 <jethr0> @seen
14:59:29 <lambdabot> Lately, I have seen akemp, edwinb, jethr0 and lennart.
15:00:20 <lennart> akemp: Yes, -hcloopArray together with some other -h flag
15:01:08 <lennart> -hy can be useful
15:02:50 <akemp> This view is much more useful.  I don't grok the output of -hy, though.
15:04:30 <Lemmih> jlouis: ping.
15:04:39 <lennart> -hy is supposed to be by type
15:04:51 * jethr0[A] is now away - Reason : weg
15:05:40 <akemp> It was, but the largest consumer of memory was "stg_ap_2_upd_info"
15:08:17 <lennart> hmmm, sounds like something to do with applying an unknown function.
15:08:37 <lennart> Have you tried not using f in loopArray, but the actual function?
15:08:55 <akemp> will try right now.
15:10:57 <akemp> same result
15:12:51 <lennart> You can always try simplifying your code so the updating function gets simpler and see what happens
15:13:31 <lennart> e.g., make it the identity
15:17:57 <akemp> Excellent suggestion.  The profiler now shows some pretty interesting results.
15:19:22 <Cale> hmm... I wish there was a proper identity functor, where the image was really treated the same.
15:20:14 <lennart> You mean as in 'type Id a = a'?
15:20:34 <Heffalump> treated the same in what sense?
15:20:37 <Cale> yeah, only type synonyms don't really do it for me
15:20:43 <Heffalump> same type classes?
15:20:50 <Cale> since they always must be fully applied
15:20:57 <lennart> Ah
15:21:11 <lennart> Nor can you use them in instance declarations
15:21:14 <Cale> right
15:21:41 <lennart> Yes, it would be handy.  But I wonder if type inference would break down.
15:23:21 <ihope> Hmm, broken type system.
15:25:54 <ihope> Unable to construct infinite type: [[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[...
15:26:17 <lennart> huh?
15:26:44 <ihope> Infinite type already constructed :-)
15:27:13 <musasabi> @type (let foo = [foo] in foo)
15:27:15 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
15:27:15 <lambdabot>   Expected type: a
15:27:20 <musasabi> bah.
15:29:24 <Mitar> any idea how to test if come list is sublist of another?
15:29:44 <ihope> No.
15:30:10 <ihope> If I understand you correctly, that is.
15:30:16 <alar> Mitar: if your list is finite - try straightforward 
15:30:26 <Mitar> s/come/some/
15:30:39 <ihope> > straightforward
15:30:41 <lambdabot>  Not in scope: `straightforward'
15:30:46 <basti_> i'd consider using Data.Set (via fromList) for superior time behaviour
15:30:51 <Mitar> there is no builtin?
15:30:57 <basti_> > [1,2,3,4] \\ [2,3]
15:30:59 <lambdabot> [1,4]
15:31:01 <basti_> its O(n)
15:31:04 <Philippa> I think there's something in Data.List
15:31:11 <Philippa> if not, there's certainly the obvious components
15:31:14 <Mitar> ah, it must be in same order
15:31:18 <basti_> uhm
15:31:21 <basti_> i was talking BS
15:31:29 <basti_> this is difference not sublist
15:31:36 <Mitar> so ordered list a sublist of another
15:31:36 <Philippa> (aka List if you're working in Haskell 98)
15:31:47 <basti_> Mitar: sorry i was talking BS
15:31:55 <basti_> Mitar: this is subtraction
15:32:16 <musasabi> > let subList small large = all (\c -> elem c large) small in (subList [1,2] [1..10], subList [1,2,77] [1..10])
15:32:17 <basti_> Mitar: but,I'm certain that Data.Set has a subset, and it will be quicker. Naive lists would be O(n*m)
15:32:17 <lambdabot> (True,False)
15:32:28 <Mitar> the order is important
15:32:30 <alar> Data.Set would outperform naive straightforward attempt a lot
15:32:38 <musasabi> ah, then discard that one.
15:33:02 <ihope> l \\ i = do {a <- i; return l !! a)
15:33:02 <Philippa> there's an IsPrefixOf
15:33:08 <Philippa> isPrefixOf, even
15:33:09 <lennart> Mitar: a combination of isPrefixOf and tails would work
15:33:13 <basti_> good night...
15:33:15 <Philippa> right
15:33:16 <Mitar> in fact, i have two lists and i have to find out if one is a roll of another (for example [1,2,3] is a roll of [2,3,1])
15:33:38 <Mitar> i thought of duplicating a second one and trying to match a first one in there
15:33:51 <Mitar> so try to match [1,2,3] in [2,3,1,2,3,1]
15:34:43 <Mitar> is there some better way?
15:36:16 <lennart> I'd just generate all rotations and check if it's equal to one of those
15:36:33 <lennart> Unless you need this to be very efficient
15:37:36 <Mitar> hm
15:37:48 <Mitar> i think that my idea is better in this case
15:38:03 <Mitar> but tails and isPrefixOf is good trick
15:38:41 <alar> can't imagine more straightforward attempt than tails + isPrefixOf
15:38:57 <Mitar> tes ..
15:39:00 <Mitar> yes
15:39:02 <Mitar> i agree
15:39:14 <Mitar> but tails of duplicated list
15:39:20 <Mitar> (if this is a correct word)
15:40:23 * ihope dubs da do notation
15:40:30 <ihope> *lubs
15:40:38 <ihope> But only on lists...
15:43:58 <lennart> ugh, building ghc is such a pain...
15:44:35 <astrolabe> Why is it necessary?
15:45:03 <lennart> if you want to modify it
15:45:20 <astrolabe> Ah
15:46:28 <ihope> @djinn a -> a -> a
15:46:29 <lambdabot> f _ a = a
15:46:56 <ihope> @djinn ((a -> m b) -> m a) -> m a
15:46:57 <lambdabot> -- f cannot be realized.
15:47:53 <lennart> @djinn ((a -> Cont r b) -> Cont r a) -> Cont r a
15:47:54 <lambdabot> f a b = a (\ c _ -> b c) b
15:49:44 <lennart> @djinn-add data C r a = C ((a->r)->r)
15:50:07 <ihope> @index callCC
15:50:08 <lambdabot> Control.Monad.Cont
15:50:13 <lennart> @djinn ((a -> C r b) -> C r a) -> C r a
15:50:14 <lambdabot> f a =
15:50:14 <lambdabot>   C (\ b ->
15:50:14 <lambdabot>    case a (\ c -> C (\ _ -> b c)) of
15:50:14 <lambdabot>    C d -> d b)
15:51:21 <lennart> C is the type use for continuations in Control.Monad.Cont
15:51:32 <lennart> but it's called Cont there
15:54:30 * dcoutts has just written a 30 line graphical svg viewer using Gtk2Hs + cairo + the new svg-cairo bindings
15:54:35 <dcoutts> xerox, ping!
15:55:19 <dcoutts> it scales the image as the window is resized
15:55:30 <ihope> data Natural = Zero | Inc Natural
15:55:59 <ihope> add Zero y = y
15:56:12 <ihope> add (Inc x) y = add x (Inc y)
15:57:10 <dcoutts> Pupeno, you were interested in the svg stuff wern't you?
15:58:05 <dcoutts> Pupeno, for your music app if I recall correctly
15:58:45 <Pupeno> dcoutts: yes, I was, but I am now using characters (unicode). I am still interested in SVG.
15:59:21 <dcoutts> the SVG method will probably be more reliable since you can supply the .svg files with the app which is easier than ensuring the user has the font installed
15:59:46 <dcoutts> we've got a nice simple SVG api:
15:59:56 <dcoutts> newSVGFromFile :: FilePath -> IO SVG
16:00:05 <dcoutts> renderSVG :: SVG -> Render ()
16:00:24 <alar> what is SVG method?
16:00:26 <dcoutts> (and there are other variant for loading an SVG from a String or Handle)
16:00:44 <alar> I'm now writing transcoder XSDE -> SVG
16:00:49 <dcoutts> alar, rendering .svg images rather than using unicode fonts
16:00:58 <dcoutts> for Pupeno's music app
16:01:05 <dcoutts> for the musical notation
16:01:12 <dcoutts> alar, XSDE?
16:01:22 <alar> nasty proprietary format
16:01:31 <alar> XML-based
16:01:55 <dcoutts> Pupeno, so you could load all the .svg bits at the beginning of the program with newSVGFromFile and then render them each time with renderSVG
16:02:11 <alar> used for description of electric power networks
16:02:29 <dcoutts> Pupeno, or it mgiht be quicker to render them to intermediate surfaces and then composite them whenever you need to redraw
16:02:50 <alar> > renderSVG
16:02:52 <lambdabot>  Not in scope: `renderSVG'
16:02:56 <dcoutts> then you'd need to re-generate the interbediate bitmaps when the zoom factor changes
16:02:58 <alar> @index renderSVG
16:02:59 <lambdabot> bzzt
16:03:05 <dcoutts> alar, it's in Gtk2Hs
16:03:10 <alar> ok thanks
16:03:16 <dcoutts> and in the development version
16:03:55 <dcoutts> actually it's not quite in the development version yet, it's new code xerox and I have been working on yesterday and today.
16:04:07 <Pupeno> dcoutts: Thanks.
16:04:07 <dcoutts> I just got the demos working
16:08:36 <Mitar> is it possible to use where in lambda function?
16:09:18 <Lemmih> Mitar: No.
16:09:28 <Mitar> what about let?
16:09:31 <Heffalump> yes
16:14:54 <dons> Moin
16:15:52 <dcoutts> hia dons
16:16:29 <dcoutts> dons, do you know anything about non-executable stacks & ghc ?
16:16:49 <dcoutts> I figured you might since OpenBSD is hot on security
16:17:07 <dcoutts> and hence making things work in a non-executable stack environment
16:17:26 <Heffalump> GHC doesn't use the C stack, does it?
16:17:29 <dons> yep, it has a non-exec stack for ages
16:17:32 <dcoutts> we (gentoo folk) can't get ghc to produce binaries with a non-executable C stack
16:17:57 <dcoutts> all the .o files it generates have the non-exec stack option set but the final binary doesn't
16:18:07 <dons> hmm. no idea why.
16:18:12 <dcoutts> we guessed it was gmp's fault
16:18:30 <dcoutts> but after updating that to a version that uses non-exec stack too it's still not working
16:18:57 <dcoutts> all the .o files in all of ghc's .a libs are ok too as ar all the .o files (like crt.o) that ghc links in
16:19:02 <dcoutts> so we're stumped
16:19:37 <dcoutts> dons, how do you know it's working on OpenBSD ?
16:19:52 <dcoutts> how do you check that a binary is going to use a non-exec stack?
16:25:19 <musasabi> dons: hello
16:30:51 <dons>  dcoutts, good question. gcc produces non-exec by default  (I seem to recall) and I've just assumed it worked. when this was introduced, some ports broke, but not ghc. -- i've only assumed it's been working
16:30:59 <dons> heya musasabi
16:31:14 <ihope> > Pieces of Eight, arr.
16:31:16 <lambdabot>  parse error on input `of'
16:31:24 <dcoutts> dons, http://www.gentoo.org/proj/en/hardened/gnu-stack.xml
16:31:30 <ihope> > Pieces Of Eight, arr.
16:31:31 <lambdabot>  parse error on input `,'
16:31:37 <ihope> > Pieces Of Eight arr.
16:31:38 <dcoutts> dons, that page has some utils that allow one to check
16:31:38 <lambdabot>  parse error on input `}'
16:31:45 <dons> ihope?
16:31:54 <ihope> :-)
16:32:31 <dons> musasabi: cron-job modules eh?
16:32:35 <dcoutts> dons, and it's the guide we've been following. It's just been made an automatic Gentoo QA warning to install binaries with executable stacks. And all our ghc binaries fail that.
16:32:50 <musasabi> dons: What is the correct way of getting into the ModuleT-land from the LB-land?
16:33:18 <dcoutts> dons, there's this pax-utils
16:33:24 <musasabi> dons: more specifically - I have a module which installs a Callback, which is in LB and want to use the module state inside the callback.
16:34:13 <dons> ah, you need to make sure it has the write module context, from the implicit vars (I think). using withModule
16:34:25 <dons> I think that's it, from memory: 
16:34:26 <dons> withModule :: (Ord k)
16:34:26 <dons>   => (IRCRWState -> Map k ModuleRef)
16:34:26 <dons>   -> k
16:34:26 <dons>   -> LB a 
16:34:28 <dons>   -> (forall mod s. Module mod s => mod -> ModuleT s LB a)
16:34:31 <dons>   -> LB a
16:35:02 <dons> TheHunter might remember better than I do
16:35:22 <dons> type ModuleT s m a = (?ref :: MVar s, ?name :: String) => m a
16:35:33 <musasabi> dons: but that has the problem with the "forall mod"
16:35:56 <musasabi> dons: I need mod to be the type of the state of the module.
16:36:12 <musasabi> and forall mod does not unify with FooState
16:36:12 <dons> sure.
16:37:07 <dons> have you seen how withModule is used. I think in some of the plugins it is used for this problem.
16:37:20 <musasabi> withModule ircModules "foo" (fail "foo not loaded") (function :: ModuleT FooState LB a)
16:37:31 <musasabi> is what I want, but it doesn't seem to be working.
16:37:46 <dons> hmm
16:37:59 <musasabi> dons: localtime was changed away from that and I thing base and help use it in ways where they don't touch the actual state.
16:38:20 <dons> ah, possibly. 
16:39:48 <dons> i need coffee before i can solve this. 
16:40:12 <dons> what kind of module only does a job once a month? an improved log module?
16:40:27 <musasabi> yes.
16:40:59 <musasabi> then again the cron issue is just about performance, if I get the LB stuff done it should work for now.
16:41:42 <dons> dcoutts, PaX isn't the same as the W^X mechanism used on OpenBSD, btw. So I'm not sure this GNU stuff all applies.
16:41:53 <dcoutts> ah, right
16:50:01 <akemp> Is ghcprof still working anymore?
16:51:42 <dons> sure.
16:52:06 <akemp> hmmm...  I'm not having much luck on a Ubuntu system.
16:52:26 <dons> the best graphical profiling fun is with the uDrawGraph alternative mentioned in the docs
16:52:50 <akemp> ghcprof never actually shows any of the graph.
16:53:17 <akemp> actually., it's taking 90% of the CPU right now.
16:54:59 <ihope> mult Zero _ = Zero
16:55:30 <ihope> mult (Inc x) y = add y (mult x y)
17:11:36 <Igloo> Are there any screenshots of these profilers?
17:12:49 <dons> not that I know of. uDrawGraph idoes a very pretty version of the normal .prof files. hp2ps does nice  heap profiling with graphs. I should post a screenshot
17:13:15 <dons> i'm not sure that pretty uDrawGraph actually buys you anything though...
17:13:27 <dons> but it's nice to look at.
17:20:45 <Igloo> I've seen the hp2ps stuff; is that what is meant by ghcprof then?
17:26:00 <akemp> ghcprof is a script that runs uDrawGraph on a special .prof file.
17:26:06 <akemp> different than hp2ps
17:26:41 <musasabi> TheHunter: ping
17:28:53 <ihope> @type replicate
17:28:54 <lambdabot> forall a. Int -> a -> [a]
17:28:58 <ihope> Oh
17:35:38 <ihope> I want to teach someone Haskell! *pouts*
17:38:55 <resiak> You could explain to me, or point me to a good guide on, how state monads work and are used :-)
17:39:23 <ncalexan> resiak: monads for the working programmer has a reasonable discussion.
17:39:34 * resiak applies Google.
17:40:04 <Heffalump> State s a is just a function s -> (a,s)
17:40:16 <Heffalump> you pass around a state s, and produce a result a
17:40:27 <Heffalump> simple :-)
17:40:43 <resiak> Hmm. Maybe I've been expecting too much magic dust to appear
17:41:35 <Cale> Monads are really a lot simpler than the buzz would indicate
17:41:38 <Heffalump> imagine writing a program where you were doing some stuff, but every often you needed to read or change some state
17:41:38 <ncalexan> resiak: the magic dust is notation...
17:41:48 <ncalexan> Cale: "warm fuzzy things" (SPJ, Hair shirt...)
17:41:56 <Cale> ncalexan: yeah
17:42:33 <Heffalump> you'd have to pass the state around everywhere, so you had it when you needed it, and you'd need to make sure that things were done in a clear order, so that later things got the effect of any earlier changes to the state
17:42:35 <Cale> ncalexan: btw, did you see my article on monads?
17:43:19 <Cale> http://www.haskell.org/hawiki/MonadsAsContainers
17:43:21 <Heffalump> that's basically all a state monad, the machinery for passing it around everywhere and enforcing the clear order
17:43:53 <resiak> This is basically the thing: I thought that part of the point of state monads was that they avoided the whole pass-it-around-everywhere thing.
17:44:13 <ncalexan> Yes, I did, actually.  It's quite good.  I would like a little more detail on how (a+b) where a and b are lists returns the cartesian product zippedWith +, though :)
17:44:15 <Heffalump> no, they just hide it
17:44:31 <resiak> I see.
17:44:43 <Heffalump> newtype State s a = State (s -> (a,s))
17:45:01 <Heffalump> (>>=) :: State s a -> (a -> State s b) -> State s b
17:45:24 <ncalexan> resiak: if you want state that doesn't get passed around, try Ref's, like STRef or IORef.
17:45:24 <Heffalump> the implementation of (>>=) takes care of passing s into the first thing, getting a new s out, passing it into the second thing etc.
17:45:52 <resiak> Ah, and then this gets further prettified by do notation
17:46:02 <Heffalump> monads like ST and IO avoid passing the state around at all operationally, but conceptually they do just the same thing as State above.
17:46:09 <Heffalump> resiak: right
17:46:19 <resiak> and so we end up in a joyous world which looks pretty, but is in fact really totally obvious once you look at it from the right angle.
17:46:20 <Heffalump> that's really all there is to it
17:46:47 <ncalexan> resiak: yes, and I think that really describes a lot of haskell.
17:46:50 <Heffalump> once you've understood State, you can think of IO as State RealWorld
17:46:56 <Cale> see also my container analogy, which works somewhat poorly for State, but well for a bunch of other monads
17:47:07 <Heffalump> it's just a *very* big piece of state
17:47:42 <ncalexan> Cale: oh, I think it does okay for State.  I like your interpretation; I never expressed it so well as you, but that's how I view monads most of the time.
17:48:02 <ncalexan> You just have to be flexible with the term 'container' :)
17:48:06 <dons> @karma+ bringert
17:48:07 <lambdabot> bringert's karma raised to 1.
17:48:10 <Cale> ncalexan: yeah :)
17:48:15 <dons> (he sent me a Knuth-Morris-Pratt algorithm for FPS)
17:48:32 <Heffalump> well, there's a value in there just waiting to get out when some state is applied.
17:49:00 <Heffalump> But join for State is still more confusing than illuminating, IMO.
17:49:23 <Cale> Heffalump: yeah, one could also view it as a container indexed by states
17:50:00 <Cale> which, at each location has a state/value pair.
18:54:06 <orbitz> afternoon
18:54:26 <Korollary_> @localtime orbitz
18:54:28 <lambdabot> Local time for orbitz is Sun Jan  8 21:53:12 2006
18:55:27 <orbitz> it's afternoon for someone
18:55:38 <Korollary_> .au maybe
18:55:41 <Korollary_> @localtime dons
18:55:44 <lambdabot> Local time for dons is Mon Jan  9 13:50:11 2006
18:55:59 <orbitz> technically, i am afternoon
18:56:26 <Korollary_> that'll get overturned in the appeals court
18:57:24 <orbitz> my kitten really enjoys a good caucasion
18:58:47 <Korollary_> the table's turned eh
19:00:06 <Squall`> My cat used to jump up on my keyboard and keep my fingers warm... I miss him :(
19:00:40 <orbitz> so in a 'do' you don't need a 'in' in a 'let'?
19:00:58 <Squall`> orbitz, that's right.
19:01:01 <orbitz> why
19:01:24 <Korollary_> it's sugar to reduce extra typing and indentation
19:01:33 <orbitz> ok
19:02:05 <Squall`> I'm not sure, I think it's to model a function you'd write in an imperative language while still being purely functional. That's just my guess.
19:02:27 <Korollary_> if you want, you can still use a let-in
19:02:32 <Squall`> I really only use do in a main function.
19:03:06 <Korollary_> do { a <- getLine; let x = something in do { ... } } . So the extra do is unpleasant, thus there's more sugar.
19:08:34 <araujo> Hello.
19:09:05 <LAPA> :t add
19:09:42 <Korollary_> @type (+)
19:09:43 <lambdabot> forall a. (Num a) => a -> a -> a
19:13:34 <orbitz> when do you have to write the 'do' again?
19:16:57 <TheHunter> musasabi, pong.
19:27:31 <musasabi> TheHunter: do you know more of the lambdabot withModule thing?
19:28:01 <musasabi> TheHunter: I have a module which installs a callback (an LB action), that needs to access the state of the module.
19:28:29 <lambdabot> Haskell Weekly News: January 9, 2006 - http://sequence.complete.org/
19:29:22 <TheHunter> that shouldn't require anything special, thanks to the way implicit paramters work.
19:29:53 <musasabi> TheHunter: how do I get it to work? seems harder than it should be.
19:30:12 <musasabi> withModule has the forall for the state which does not unify with FooState
19:30:34 <TheHunter> you don't need withModule, if I understand you correctly.
19:32:02 <musasabi> hmm, if I "gets ircModules" and then Map.lookup from that I get the ModuleRef, but the constructor is not exported, so no luck.
19:33:11 <musasabi> http://youzen.b2.fi/~musasabi/l.hs (does not work, but should show the idea)
19:33:32 <TheHunter> i'll have a look.
19:35:40 <TheHunter> you can just give logger the type IRC.Message -> ModuleT blah LB (), then you will have access to the state
19:36:08 <dons> oh interesting, the lego mindstorm vm is going to be documented... anyone want to write a ghc backend?
19:37:02 <TheHunter> that is, logger = const handler.
19:37:22 <musasabi> TheHunter: except, that I need to have the top level type as Callback.
19:37:42 <TheHunter> no you don't. That's the beauty of implicit parameters.
19:37:42 <musasabi> with type Callback = IRC.Message -> LB ()
19:37:56 <orbitz> in a 'do', does returnning an integer actually return an integer or does it return somethign else?
19:38:20 <musasabi> TheHunter: actually I have because it is called from code that does not set any implicit parameters.
19:39:15 <TheHunter> hmm, that's strange, I'd expect ircSignalCOnnect to be called from something like moduleInit.
19:39:55 <musasabi> yes, does it get the parameters from there rather than from the actual call site?
19:40:10 <TheHunter> yes.
19:40:51 <musasabi> mmh, nice :-)
19:41:06 <musasabi> I thought they were callsite specific
19:41:13 <orbitz> is there a haskell pastebin
19:41:17 <musasabi> @paste
19:41:17 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
19:41:23 <orbitz> moof
19:41:24 <musasabi> lisppaste2: paste?
19:41:29 <Cale> lisppaste2: url
19:41:29 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
19:41:44 <orbitz> meh this isn't so hot
19:42:03 <musasabi> TheHunter: thanks, now everything just works.
19:42:04 <Cale> orbitz: hm?
19:42:38 <lisppaste2> orbitz pasted "Does this really return the sum, because I get an error trying to do math with it" at http://paste.lisp.org/display/15528
19:42:50 <orbitz> Cale: the wiki page wasn't os hot, lispbot is fine
19:43:31 <dons> orbitz, it's just an empty page on a wiki. what's to be hot about it?
19:43:50 <Cale> orbitz: sumInput has an incorrect type signature, first of all
19:43:56 <orbitz> it' not empty here
19:44:14 <orbitz> Cale: right, i know that, that's wha ti want  it to be
19:44:29 <Cale> It can't have type Int -> Int since it does IO
19:44:38 <orbitz> ok
19:44:45 <Cale> It could have type Int -> IO Int
19:44:59 <orbitz> right
19:45:08 <orbitz> i havn't gotten tehre in my book. i guess i'll have to wait
19:45:22 <Cale> also, you'll want to return the sum
19:45:35 <Cale> return :: a -> IO a
19:46:06 <orbitz> i do return the sum dont' I?
19:46:19 <Cale> no, what you have is a type error
19:46:36 <Cale> well, that's "returning" the sum in some sense, but you need an IO Int there
19:46:45 <Cale> rather than an Int
19:46:48 <orbitz> right i know that know
19:46:58 <orbitz> i know the type's were wrong, i just had it there to decoumetn wha ti was after
19:47:10 <Cale> I mean
19:47:19 <Cale> the type of 'sum' is Int there
19:47:28 <orbitz> right
19:47:43 <Cale> but  'sumInput (sum + inNum)' is of type IO Int
19:47:50 <orbitz> ok
19:48:01 <Cale> and so the 'then' part of the if has to have the same type
19:48:29 <Cale> so it should read  'if inNum == 0 then return sum else sumInput (sum + inNum)'
19:48:59 <orbitz> so I need the return there?
19:49:27 <Cale> In the IO monad, return x is just the IO action which has no side effects and always returns x when run.
19:49:44 <orbitz> ok
19:50:21 <Cale> It's useful at the ends of do-blocks like that to return a specific value.
19:50:41 <Cale> It's also useful as a no-op on occasion
19:51:36 <Cale> note that, in the middle of a sequence of IO actions, 'return ()' will just essentially be ignored
19:54:29 <orbitz> so if do return sum is my reutrn type still IO Int
19:55:26 <Cale> yeah
19:55:57 <wchogg> "return" just means that when the action is executed, the result will get placed in the left hand side of the "<-" statement.
19:55:59 <Cale> you can't escape the icy grasp of the IO monad, which is why you should endeavour to do most of your computation outside of it.
19:56:42 <orbitz> so if i do return sum
19:56:51 <orbitz> shold i do sum <- sumInput 0
19:56:56 <orbitz> then can i do show sum
19:57:08 <Cale> right
19:57:21 <Cale> 'x <- return y' is the same as 'let x = y'
19:57:57 <Cale> (modulo recursion)
19:58:07 <orbitz> fantastic
19:58:07 <orbitz> thanks
20:05:03 <Cale> untilM p a = do { x <- a; if p x then return [] else do xs <- untilM p a; return (x:xs) }
20:05:31 <Cale> readNumbers = untilM (== 0) (do putStrLn "Enter number to sum, 0 to stop."; x <- getLine; return (read x))
20:06:02 <Cale> main = do xs <- readNumbers; putStrLn ("Your sum is " ++ show (sum xs) ++ ".")
20:10:20 <Cale> orbitz: the above code shows one way to factor out the looping
20:10:46 <orbitz> Cale: thanks, i'll keep it around
20:44:45 <musasabi> dons: new log module in 80 lines of code. (old one was 280 lines)
20:45:02 <dons> cool!
20:45:55 <dons> what do you want to do with the logs? do you have some scheme?
20:46:01 <musasabi> Added small nondestructive changes to Lambdabot.hs to make raw input filters possible.
20:46:17 <dons> sure, sounds good. hack away!
20:46:30 <dons> if you want, faststring network io would be nice
20:46:38 <musasabi> first is logging to text files which seems to work nice, I need to do a wikibased logging thing later.
20:47:05 <dons> ah, good idea.
20:52:26 <araujo> Hello hello.
20:53:17 <dons> hey araujo
20:54:17 <araujo> how that hasking goes dons ?
20:54:19 <araujo> :-)
20:55:01 <dons> well, we made some progress on the shootout entries, amongst other things.
20:55:28 * araujo updated hashell version yesterday
20:55:38 <araujo> Cool.
20:55:55 <dons> ah, you should have sent me a mail so it would have been in the HWN
20:56:07 <araujo> oh :-(
20:56:18 <dons> send me one now, and it'll be in next weeks'
20:56:30 <araujo> Cool, :-)
20:56:47 <dons> unless things get announced on haskell@, they don't get into HWN unless someone tells me explicitly
20:56:48 <araujo> This one fixed several bugs, it also uses parsec... so it is kind of improved.
20:56:58 <dons> improved is good
20:56:59 <araujo> oh, ok
20:57:02 <araujo> Good.
20:57:20 <araujo> I still wanna change several things.
20:57:30 <araujo> Ive been reading about Esther and Es
20:57:40 <araujo> would like to get some of those features into hashell too.
20:57:50 <dons> that would be cool.
20:58:01 <araujo> Saddly, i start univ today, and probably i won'tbe hacking on it until a couple of weeks :-(
20:58:31 <dons> but aren't the first weeks of uni when nothing happens anyway? ;)
20:58:41 * araujo would like to be at least taking interesting courses
20:59:01 <araujo> Oh, these are actually my last two weeks.
20:59:07 <araujo> So there are a bunch to happen :-P
20:59:09 <dons> ah, ok.
20:59:22 <araujo> Yes, kind of a weird semester system.
21:25:30 <wchogg> Hi, I've got a dumb question that has been bothering me:  when you fold or map, and you have a function that takes constant time, is the time complexity O(n) or O(n^2)?  Is it just following the list or is it accessing each element?
21:26:15 <Pseudonym> That depends what the function does.
21:26:16 <Korollary_> it's following the list down 
21:26:23 <Korollary_> well, assuming unary func
21:26:40 <Pseudonym> There's no requirement for map to access the elements.
21:26:51 <Pseudonym> @eval [ undefined | i <- [1..10] ]
21:26:52 <lambdabot> Add a type signature
21:26:57 <Pseudonym> @eval [ undefined | i <- [1..10] ] :: [Int]
21:26:59 <lambdabot> Undefined
21:27:14 <Pseudonym> @eval let { xs = [ undefined | i <- [1..10] ] :: [Int] } in map (\_->1) xs
21:27:15 <lambdabot> [1,1,1,1,1,1,1,1,1,1]
21:27:26 <Pseudonym> See?
21:27:58 <wchogg> Ah, sure.  
21:28:30 <Pseudonym> If I understand your question correctly, if the function is O(1), then map and fold are O(n) in the size of the list.
21:28:54 <Pseudonym> That's also assuming that everything that the function needs is evaluated.
21:30:03 <wchogg> Yeah, that answers the question just fine, thanks.  List operations are a little more efficient than I thought then.
21:30:14 <Korollary_> I think he was worried whether the list would be accessed via !! and a full traversal end up nonlinear
21:30:19 <Pseudonym> Right.
21:30:20 <Pseudonym> OK
21:30:27 <Pseudonym> Avoid !!
21:30:42 <Korollary_> or use arrays
21:32:08 <wchogg> I haven't really tried Haskell's arrays.  How convenient are they?
21:32:31 <Korollary_> quite convenient actually
21:36:29 <wchogg> Has anyone played much with other functional languages besides haskell?  I've been looking for something else to play with a little, sortof to "expand my mind".
21:36:51 <dons> Array> let arr = array (0,9) (take 10 $ zip [0..] ['a'..]) in arr ! 8
21:36:52 <dons> 'i'
21:37:09 <dons> you could try OCaml or SML.
21:37:11 <Korollary_> wchogg: I played (and play) with ocaml a bit
21:37:53 <dons> but does anyone ever leave haskell for another fp lang and stay happy?
21:38:02 <wchogg> dons-If Arrays use lists to define their elements, won't they be slowed down by that?
21:38:27 <Korollary_> wchogg: they use lists for instantiation. The rest of the accesses don't use lists.
21:38:30 <wchogg> Hah, well I was turned off by Oz this morning because I thought the syntax seemed so much uglier than Haskell.
21:38:48 <Korollary_> ocaml syntax is ugly, too. I am over it, though.
21:38:53 <ncalexan> wchogg, dons: actually, I find ocaml great, save for the syntax, which is actually a deal-breaker.
21:39:35 <Korollary_> man, that must for a language designer when everybody deams ocaml syntax bad.
21:39:35 <wchogg> Korollary:  Well ocaml has MetaOcaml, which looks lovely to me from some presentations I flipped through.  I'd be willing to put up with ugly syntax for that.
21:39:36 <musasabi> wchogg: not really.
21:39:50 <musasabi> wchogg: the list does not need to exist at any point of time.
21:40:10 <wchogg> So the list is essentially syntactic sugar for the array initialization?
21:41:15 <wchogg> Korollary_:  For me the problem with Ocaml syntax is things like using "+" vs "+."  Even in C++ I haven't had to do little things like that.
21:42:08 <Korollary_> wchogg: well, c++ does coercion. Actually, in c++ I always use static_cast<int>
21:43:33 <wchogg> Is coercion for numbers really so bad?  Should I feel guilty for doing things like ||'ing integers?
21:44:28 <Korollary_> wchogg: I've done quite a bit of numeric stuff, so it became a habit since I was concerned with where such things happened. 99% of the time people don't care.
21:45:17 <wchogg> Since I'm starting to do a good bit of numeric stuff, I suppose I probably should start caring.  I've just never thought much about representation of numbers.
21:45:18 <dons> there's a lot of array interace fun to play with. you can have flat chunks of uninitialised malloc memory if you want (to go nuts)
21:48:04 <ncalexan> @type ($)
21:48:06 <lambdabot> forall b a. (a -> b) -> a -> b
21:48:24 <musasabi> wchogg: no, the list is there. But Haskell compilers are clever and can optimize lists away in some places.
21:48:32 <musasabi> wchogg: this is called deforestation.
21:49:15 <wchogg> Okay.
21:50:01 <musasabi> and you have an interface for creating mutable arrays with uninitialized contents if that is really what you want.
