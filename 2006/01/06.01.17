00:00:17 <Korollary> It was on artima.com
00:00:21 <vincenz> yeahy
00:00:24 <vincenz> reading it now
00:00:30 <vincenz> but a colleague already gave me the heads up
00:00:34 <vincenz> reflection for c++
00:00:36 * vincenz shudders
00:00:41 <vincenz> talk about taking a beast and adding more haeds
00:01:26 <Korollary> I dont care really. I write c++ for a living, but by the time the new version comes out, I will have switched to something else.
00:01:48 * vincenz grins
00:02:10 <vincenz> btw
00:02:14 <vincenz> how do you install an rpm locally
00:02:17 <vincenz> as in as nonroot
00:02:23 <tibbe> http://www.artima.com/cppsource/cpp0x.html ?
00:02:27 <vincenz> yip
00:02:40 <vincenz> anyone?
00:02:46 <sieni> the worst trouble with c++ is that even though it adds a plethora of improvements to c, it also provides a great variety of completely novel ways to shoot yourself in the foot.
00:03:01 <vincenz> the problem with c++ is too much backwards cmopatible
00:03:12 <vincenz> I mean there's many things that peopel say "don't use them or it'll blow up your code"
00:03:25 <vincenz> besides most modern compiler research makes assumptions about people not using certain ugly cnostructs
00:03:28 <vincenz> so why not just take em out
00:09:04 <zamez> the problem with C++ is that it's not Haskell :>
00:11:21 <vincenz> nor ocaml
00:12:20 <zamez> or even Perl
00:12:38 <zamez> almost feel sorry for it ;)
00:12:55 <Korollary> c++ is better than perl imho
00:13:07 * vincenz smacks zamez 
00:13:11 <vincenz> yes
00:13:18 <zamez> really depends what for
00:13:19 <vincenz> perl is the abyss of lost semantics
00:13:25 <vincenz> zamez: there is no excuse for perl
00:13:28 <vincenz> you've got ruby and python
00:13:32 <AtnNn> actually, isn't the next version of perl haskell?
00:13:41 <zamez> at least it has good string handling and built-in lists and maps
00:13:56 <Korollary> AtnNn: The first implementation is done in haskell. It has nothing to do with it otherwise.
00:14:03 <zamez> it's quite possible to write good code in Perl too
00:14:17 <sieni> python makes me vomit... if they want to make a indentation sensitive syntax, it would be nice to have some substance in the language as well.
00:14:18 <vincenz> LOL
00:14:24 <vincenz> sieni: ruby is nice
00:14:26 <vincenz> anyways
00:14:30 <vincenz> this c++ article is too funny
00:14:45 <AtnNn> since they've got haskell devellopers working on it, i'm sure some nice stuff will rub off
00:15:06 <Korollary> sieni: everybody and their broter is over the forced indentation by now.
00:15:10 <vincenz> "In my opinion, C++ has becmoe too "expert friendly" and it will cost us little to prvodie much better support for "novices".  It will cost us nothing in terms of performance, flexibility, or in _terseness_ of code"
00:15:10 <Korollary> +h+
00:15:20 <vincenz> that last part makes me laugh
00:15:33 <vincenz> c++ is as terse as perl is readable
00:15:50 <zamez> I disagree, but not about the C++ part ;)
00:15:57 <Korollary> vincenz: He means relative terseness
00:16:04 <vincenz> Korollary: relative to what
00:16:07 <Korollary> to itself
00:16:10 <vincenz> fortran?
00:16:46 <Korollary> you have to focus on c++ in a stroustrup article. He's not trying to make it more like <insert your fav>
00:16:49 <vincenz> hmm
00:16:52 <vincenz> another bad thing he says
00:16:58 <vincenz> he wants to support threads usnig library facilities
00:17:07 <vincenz> afaik I read a paper thatyou can't provide threading through libraries
00:17:14 <vincenz> I think it aws boehm who wrote it
00:17:44 <Korollary> vincenz: He probably read that paper, too. It doesn't matter. It's probably too late for drastic changes.
00:17:53 <vincenz> true enough
00:18:55 <vincenz> Korollary: you read the article?
00:19:02 <Korollary> yes, a while ago
00:19:06 <vincenz> hmm
00:19:08 <vincenz> why does
00:19:16 <vincenz> cout << *p << endl; not compile in c++98?
00:19:18 <Korollary> also, there's much more detail on Stroustrup's own website
00:19:22 <vincenz> afaik it looks fine
00:19:26 <vincenz> Korollary: got a link?
00:19:35 <flux__> vincenz, namespaces?
00:19:36 <Korollary> no, sorry
00:20:18 <vincenz> hmm
00:20:22 <vincenz> http://www.artima.com/cppsource/cpp0x.html
00:20:29 <vincenz> the second section "Language features"
00:20:40 <vincenz> it claims that the cout << *p << endl; line would not compile under c++98
00:21:36 <Korollary> no, that's the only line that would
00:22:19 * vincenz mutters
00:22:24 <vincenz> I should learn to decode english properly
00:22:32 * vincenz had too much beer last night
00:23:11 <pvgorp> hi all, in http://www.cs.nott.ac.uk/~gmh/mgs-appsem1.ppt i read "Unless tupling is explicitly required, all functions in Haskell are normally defined in curried form."  However, no motivation is given.  Could you explain to a Java-person why currying is preferred over using tuples as arguments?
00:23:12 <vincenz> Gotta admit however that generic programming in c++ is rather succint
00:23:30 <vincenz> pvgorp: cause then you can pass single parameters to it and get back a function
00:23:39 <vincenz> pvgorp: simple exmaple
00:23:41 <vincenz> add a b = a + b
00:23:43 <pvgorp> sure, but why would you want to do that?
00:23:49 <vincenz> map (add 1) [1;2;3]
00:23:55 <vincenz> => [2;3;4]
00:24:05 <vincenz> pvgorp: partial binding to create closures
00:24:19 <Korollary> pvgorp: it's got to do with using functions as values (i.e. higher order functions)
00:24:35 <pvgorp> ok, looking forward to those higher order functions...
00:24:42 <pvgorp> i'll continue the tutorial, thanks!
00:32:39 <chucky> @seen lennart
00:32:40 <lambdabot> Last time I saw lennart was when I left #flippi, #gentoo-haskell, #
00:32:40 <lambdabot> haskell, #haskell-blah, #haskell-overflow, #haskell.es, #haskell.it and #
00:32:40 <lambdabot> scannedinavian 1 month, 8 hours, 56 minutes and 15 seconds ago, and I
00:32:40 <lambdabot> have missed 25 days, 6 hours, 32 minutes and 24 seconds since then.
00:33:10 <chucky> hmm...
00:33:32 <vincenz> @seen shappr
00:33:32 <lambdabot> I haven't seen shappr.
00:33:35 <vincenz> @seen shapr
00:33:36 * tibbe laughs
00:33:36 <lambdabot> shapr is in #ScannedInAvian. I don't know when shapr last spoke.
00:33:51 <vincenz> Why is shapr no longer on haskell
00:38:45 <sieni> vincenz: unicycling is probably taking all his free time
00:41:04 <boegel> when he needs to focus, he leaves
00:51:00 * pesco yawns.
00:51:12 <tibbe> pesco, you said it
00:52:13 <pesco> tibbe: Greetings, are you new to #haskell?
00:53:00 <tibbe> kinda, I where here for a brief period before Christmas during a advanced functional programming course I was taking
00:53:42 <tibbe> and now I'm taking a programming language (creation) course :)
00:54:26 <pesco> Aha! Very good. Have you already received The Tour?
00:55:44 <tibbe> umm, guess not ;)
00:56:20 <pesco> tibbe: Okay, I'll try my best, though this is traditionally shapr's job.
00:56:35 <tibbe> I see, I heard he was away today
00:56:46 <tibbe> he was very active during my last visit
00:56:50 <pesco> tibbe: Directly in front of you, notice the channel topic.
00:57:19 <pesco> Yes, he usually is, but enters pause periods every once in a while.
00:57:50 <pesco> The topic gives you links to the most important things and latest news. But you probably already know that.
00:58:30 <pesco> Also the channel logs are linked there. It's managed by lambdabot, btw.
00:58:45 <tibbe> I like lambdabot :)
00:59:08 <pesco> Yes, she's the main attraction, have you seen her website?
00:59:19 <tibbe> I haven't
01:00:23 <pesco> Then look over to http://www.cse.unsw.edu.au/~dons/lambdabot.html real quick. ;)
01:01:12 <tibbe> there, done
01:02:56 <pesco> Good. Lambdabot has accumulated a myriad of features, which you will quickly pick up, er /msg her for @help.
01:03:23 <hellish> Oops.
01:04:03 <tibbe> pesco, she won't tell me which commands she can help me with though
01:05:03 <pesco> Ah yes, use @listcommands.
01:07:24 <pesco> Among the most useful comands are @hoogle, @type, and @pl.
01:07:43 <pesco> She will also happily perform in-channel evaluation:
01:08:06 <pesco> > putStrLn "Hello, tibbe! Nice to meet you..."
01:08:07 <lambdabot> No IO allowed
01:08:16 <pesco> But she won't do IO ;-)
01:08:35 <vincenz> pesco: he not she
01:08:50 <pesco> > reverse "!ebbit olleH"
01:08:52 <lambdabot> "Hello tibbe!"
01:08:59 <tibbe> > msum [(Just 1), Nothing]
01:09:00 <vincenz> split "pesco"
01:09:01 <lambdabot> Just 1
01:09:04 <vincenz> > split "pesco"
01:09:05 <lambdabot>  add an instance declaration for (RandomGen [Char])
01:09:05 <lambdabot>   In the definition of `slz': slz = split "pesco"
01:09:05 <lambdabot>   In the definition of `v': v = let slz = split "pesco" in take 2048 (
01:09:05 <lambdabot> show slz)
01:09:07 <pesco> vincenz: Since when!?
01:09:20 <vincenz> pesco: bots are always male
01:09:39 <pesco> vincenz: Er, how so?!
01:09:55 <vincenz> lambdabot: are you open source?
01:10:28 <pesco> vincenz: Look at her photo on the homepage, lambdabot is surely female.
01:10:45 <hellish> Bots are like boats.
01:11:09 <tibbe> i guess i shouldn't have asked her for a list of commands...
01:11:42 <tibbe> @get-shapr
01:11:43 <lambdabot> shapr!!
01:12:20 <pesco> :)
01:12:32 <vincenz> pesco: open source?
01:12:47 <vincenz> How do you get a list of options
01:12:48 <pesco> vincenz: What?
01:12:51 <vincenz> @help only gives "@help command"
01:12:51 <lambdabot>  @help <command> - ask for help for <command>
01:12:53 <vincenz> pesco: lambdabot 
01:13:18 <vincenz> Anyways, can I install her on my pc to use her for something?
01:13:27 <pesco> vincenz: Yes, completely open source! The design is modular, you can write new commands if you like!
01:13:44 <pesco> vincenz: Yes.
01:13:47 <vincenz> I was hoping to make a simple bot to do link-logging
01:14:02 <vincenz> whenever anyone puts in a webreference in a channel
01:14:42 <pesco> vincenz: Have a look at how the handler for '> expr' evaluation is implemented.
01:14:48 <vincenz> pesco: nope
01:15:01 <pesco> vincenz: Suite yourself.
01:15:07 <vincenz> pesco: ?
01:15:11 <vincenz> oh
01:15:12 <vincenz> sorry
01:15:16 <vincenz> I thought you asked if I had lookekd
01:15:24 <vincenz> don't have darcs at the moment
01:15:25 <pesco> Ah, heh.
01:15:27 <vincenz> I'll look later :)
01:16:37 <pesco> @hoogle a -> b -> a
01:16:39 <lambdabot> Control.Parallel.par :: a -> b -> b
01:16:39 <lambdabot> Control.Parallel.seq :: a -> b -> b
01:16:39 <lambdabot> GHC.Conc.par :: a -> b -> b
01:17:03 <vincenz> @hoogle split
01:17:04 <lambdabot> Data.IntMap.split :: Key -> IntMap a -> (IntMap a, IntMap a)
01:17:04 <lambdabot> Data.IntSet.split :: Int -> IntSet -> (IntSet, IntSet)
01:17:04 <lambdabot> Data.Map.split :: Ord k => k -> Map k a -> (Map k a, Map k a)
01:17:07 <pesco> Hrm? That's not what I asked for?
01:17:22 <vincenz> @hoogle seems impressive
01:17:23 <lambdabot> Prelude.undefined :: a
01:17:23 <lambdabot> Data.Graph.Inductive.Monad.emptyM :: GraphM m gr => m (gr a b)
01:17:23 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
01:17:27 <pesco> @type const
01:17:28 <vincenz> woops
01:17:29 <lambdabot> forall a b. a -> b -> a
01:17:33 <vincenz> @hoogle const
01:17:34 <lambdabot> Prelude.const :: a -> b -> a
01:17:34 <lambdabot> Data.Generics.Basics.Constr :: Constr
01:17:34 <lambdabot> Data.Generics.Basics.ConstrRep :: ConstrRep
01:17:45 <vincenz> @hoogle forall a b.a -> b -> a
01:17:46 <lambdabot> Control.Parallel.par :: a -> b -> b
01:17:46 <lambdabot> Control.Parallel.seq :: a -> b -> b
01:17:46 <lambdabot> GHC.Conc.par :: a -> b -> b
01:17:50 <vincenz> @hoogle forall a b.a -> b -> b
01:17:52 <lambdabot> Control.Parallel.par :: a -> b -> b
01:17:52 <lambdabot> Control.Parallel.seq :: a -> b -> b
01:17:52 <lambdabot> GHC.Conc.par :: a -> b -> b
01:18:10 <vincenz> @hoogle is very impressive, is it builtin to lambdabot, or does she use that hoogle site?
01:18:12 <lambdabot> No matches, try a more general search
01:18:30 <pesco> Dunno.
01:18:41 <vincenz> not the hoogle site
01:18:45 <vincenz> cause it returns the correct answer
01:18:49 <vincenz> http://www-users.cs.york.ac.uk/~ndm/hoogle/
01:18:55 <pesco> Heh. :)
01:19:21 <vincenz> although many incorrect ones
01:19:30 <pesco> tibbe: Anyway, another useful thing is
01:19:38 <tibbe> pesco, yes?
01:19:38 <pesco> @wiki LambdaBot
01:19:40 <lambdabot> http://www.haskell.org/hawiki/LambdaBot
01:19:47 <tibbe> ah
01:19:56 <pesco> lambdabot: A bit slow today, aren't we?
01:19:57 <vincenz> @wiki gentle
01:19:58 <lambdabot> http://www.haskell.org/hawiki/gentle
01:20:05 <vincenz> lambdabot: speedup
01:20:21 <vincenz> she's pretty impressive
01:20:26 <pesco>  @wiki doesn't check anything, just prepends the wiki URL. ;)
01:20:30 <vincenz> oh
01:20:40 <vincenz> is she single?
01:20:44 <pesco> @wiki is still helpfull.
01:20:45 <lambdabot> http://www.haskell.org/hawiki/is still helpfull.
01:20:51 <pesco> vincenz: Ask her!
01:21:00 <vincenz> lambdabot: are you single?
01:21:03 <eivuokko> @vixen Are you single?
01:21:04 <lambdabot> yeah, no boyfriend or prospects
01:21:04 <pesco> @vixen Lambdabot, are you single at the moment?
01:21:05 <lambdabot> yeah, no boyfriend or prospects
01:21:16 <vincenz> @vixen cow
01:21:17 <lambdabot> what is pron?
01:21:20 <vincenz> hmm
01:21:32 <vincenz> I thought it was just the generic @vixen response, impressive
01:21:39 <vincenz> @vixen Lambdabot, do you have a mate?
01:21:40 <lambdabot> i do occassionally, i guess
01:22:04 <vincenz> @vixen Lambdabot, have you entered the turing contest?
01:22:05 <lambdabot> let me answer that later, okay?
01:22:11 <pesco> So, yeah, that's lambdabot. :)
01:22:16 <vincenz> she rocks
01:22:46 <pesco> tibbe: I guess you know the GHC haddock library documentation, the invaluable reference.
01:23:08 <pesco> tibbe: If you're looking for libraries, watch hackage, which is still in development, but already lists some useful stuff.
01:23:18 <pesco> @google haskell hackage
01:23:19 <lambdabot> http://haskell.org/~gentoo/gentoo-haskell/portage/dev-haskell/hackage-
01:23:19 <lambdabot> client/
01:23:33 <pesco> hm...
01:23:48 <pesco> Not the right one. :(
01:23:54 <tibbe> pesco, with the libraries doc and such?
01:24:22 <tibbe> @seen Philippa
01:24:23 <lambdabot> Philippa is in #ScannedInAvian, #haskell-overflow, #flippi, #haskell-blah
01:24:23 <lambdabot> and #haskell. I don't know when Philippa last spoke.
01:24:34 <tibbe> Philippa, you there?
01:24:46 <pesco> Ah yes, and of course, there's #haskell-blah!
01:24:49 <eivuokko> http://hackage.haskell.org/trac/hackage for hackage and especially http://hackage.haskell.org/ModHackage/Hackage.hs
01:25:02 <vincenz> pesco: what's haskell-blah
01:25:18 <pesco> If you ever feel like talking _not_ about haskell, just go over there and have a chat.
01:25:26 <vincenz> oh
01:26:33 <tibbe> #ScannedInAvian, that's pretty funny
01:27:28 <pesco> Unfortunately, hackage is kind of buried because it's not done, yet...
01:28:10 <pesco> But it's there! http://hackage.haskell.org/
01:28:43 <vincenz> what is it
01:29:17 <pesco> It's a database for listing "third-party" haskell libraries.
01:29:53 <pesco> It's part of an ongoing effort to make it easier to find, install, and use libraries that are not in the standard distribution.
01:30:01 <pesco> Because there are quite a bunch, but they're scattered over the net.
01:30:14 * vincenz nods
01:30:40 <pesco> It goes along with Cabal, which is an automatic package, build, and install system for them.
01:31:18 <pesco> So this concludes the tour for today! If you have any questions, feel free to ask!
01:31:24 <vincenz> thanks
01:31:29 <vincenz> pesco: what do you do
01:31:31 <tibbe> pesco, thank you very much, I will
01:31:54 <pesco> My pleasure.
01:31:54 <tibbe> if I just could find Philippa so she could continue where we left of yesterday
01:31:58 * pesco resumes coding.
01:32:33 <pesco> tibbe: She's online, right? Just not in #haskell ATM... Maybe send her a quick /msg?
01:32:49 <vincenz> pesco: what do you do besides tour on #haskell
01:32:52 <pesco> What were you talking about yesterday?
01:33:43 <pesco> vincenz: I code whatever I feel like, mostly "infrastructural" things, i.e. libraries, tools, etc. for better coding of other things on top of them. ;)
01:33:51 <vincenz> pesco: student?
01:34:29 <pesco> vincenz: Yes, I'm also enrolled at a University, working on diplomas in Informatics and Mathematics.
01:34:36 <vincenz> ah :)
01:35:24 <tibbe> pesco, writing a programming language
01:35:40 <pesco> tibbe: Ah, right!
01:36:06 <pesco> tibbe: Functional? Or what kind?
01:36:14 * vincenz listens attentively
01:36:40 <tibbe> pesco, well functional, lispish syntax atm
01:36:54 <tibbe> pesco, mostly in my head, i want partial application and closures
01:37:06 <tibbe> pesco, but I don't really "get it" yet
01:37:24 <tibbe> I wrote a simple procedural language but that's boring
01:38:00 <tibbe> I want a good implementation and not just "a" implementation
01:38:07 <tibbe> I basically try to write eval
01:38:10 <pesco> tibbe: Ah yes. Do you know Abelson/Sussman's "Structure and Interpretation of Programming Languages"?
01:38:25 <pesco> They basically show how to implement Scheme.
01:39:20 <tibbe> I've a data structure like so: data Expr = Var Id | App Expr Expr | Lam Id Expr
01:39:26 <tibbe> pesco, haven't read it now
01:39:42 <pesco> But I need to get back to work. I'm writing The World's Best Benchmarking Script (TM). ;-)
01:39:58 <tibbe> and I also have: type Env = [(Id, Value)] probably will change it to a nested list to allow nested scopes
01:40:05 <pesco> tibbe: It's a very nice book, I think.
01:40:08 <tibbe> pesco, good luck :)
01:40:14 <tibbe> I'll have a look
01:40:14 <pesco> tibbe: They even build a compiler.
01:40:40 <pesco> Ah yes, environments and closures are explained really nice there, too.
01:40:50 <tibbe> is it available online?
01:41:02 <pesco> Not sure.
01:43:45 <gour> @where yi
01:43:46 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
01:43:57 <gour> @where hs-plugins
01:43:59 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
01:50:47 <tibbe> @why me
01:50:53 <lambdabot> Maybe you meant: ghc what wn
01:56:24 <tibbe> @seen Philippa
01:56:25 <lambdabot> Philippa is in #ScannedInAvian, #haskell-overflow, #flippi, #haskell-blah
01:56:25 <lambdabot> and #haskell. I don't know when Philippa last spoke.
02:44:46 <ADEpt> hi there. I have a code with lots of similar sections looking like:
02:44:46 <ADEpt> data Foo = Foo String String String String | Bar String String
02:44:46 <ADEpt> instance Arbitrary Foo where arbitrary = oneof [ liftM4 Foo arbitrary arbitrary arbitrary arbitrary, liftM Bar arbitrary arbitrary]
02:44:46 <ADEpt> Could I use something like Template Haskell to facilitate derivation of such class instances?
02:49:34 <Lemmih> Is this for Conjure?
02:50:19 <ADEpt> Lemmih: no, this is for my work :)
02:50:45 <ADEpt> Lemmih: i'm using QuickCheck machinery to generate test data sets for some other software. Actually, quite exciting :)
02:50:56 <Lemmih> Neat. (:
02:51:44 * Lemmih takes off to grill a guidance counselor.
02:52:08 <ADEpt> but i have too much boilerplate in my code, and hope to reduce it somehow...
03:01:43 <audreyt> @pl asks envBody >>= \main -> return (VStr $ pretty main)
03:01:44 <lambdabot> (VStr . pretty) `fmap` asks envBody
03:01:50 <audreyt> lambdabot: thanks
04:00:05 <vincenz> whats pl?
04:00:29 <vincenz> @pl \x map (x+)
04:00:29 <lambdabot> (line 1, column 10):
04:00:29 <lambdabot> unexpected "+"
04:00:29 <lambdabot> expecting letter or digit, operator or ")"
04:00:33 <vincenz> @pl \x -> map (x+)
04:00:34 <lambdabot> map . (+)
04:00:43 <vincenz> @pl \x -> map (+x)
04:00:43 <lambdabot> map . (+)
04:00:48 <vincenz> o.O
04:00:51 <vincenz> @pl \x -> map (x/)
04:00:51 <lambdabot> map . (/)
04:00:54 <vincenz> @pl \x -> map (/x)
04:00:55 <lambdabot> map . flip (/)
04:01:01 <boegel> vincenz: pointless, i.e. without 'variables'
04:01:03 <vincenz> it knows that + is commutative?
04:01:21 <boegel> @pl x + y * z
04:01:21 <lambdabot> x + y * z
04:01:29 <boegel> @pl \x y z -> x + y * z
04:01:30 <lambdabot> (. (*)) . (.) . (+)
04:01:46 <vincenz> how does it know that + is commutative?
04:01:59 <vincenz> @pl \x -> map (x*)
04:02:00 <lambdabot> map . (*)
04:02:02 <vincenz> @pl \x -> map (*x)
04:02:03 <lambdabot> map . (*)
04:02:05 <boegel> > eval ((. (*)) . (.) . (+)) 1 2 3
04:02:05 <vincenz> same for *
04:02:06 <lambdabot>  Not in scope: `eval'
04:02:09 <boegel> > ((. (*)) . (.) . (+)) 1 2 3
04:02:11 <lambdabot> 7
04:02:15 <boegel> 1+2*3
04:02:19 <vincenz> no I know
04:02:26 <vincenz> I'm still wondering about th ecommutative bit
04:02:39 <boegel> I'm no expert...
04:02:46 <sieni> Haskell the boob language
04:02:49 <vincenz> is the @pl algo complex?
04:02:53 <vincenz> sieni: hehe
04:02:58 <vincenz> @type (.)
04:02:59 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
04:03:02 <vincenz> @type (.) . (.)
04:03:03 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
04:03:17 <vincenz> (. (*)) . (.) . (+)
04:03:20 <vincenz> >(. (*)) . (.) . (+)
04:03:26 <vincenz> > (. (*)) . (.) . (+)
04:03:27 <lambdabot>  add an instance declaration for (Show (a -> a -> a -> a))
04:03:39 <vincenz>  > ((. (*)) . (.) . (+)) 1 2 3
04:03:45 <vincenz> > (*) . (.) . (+)
04:03:46 <lambdabot>   add an instance declaration for (Show (a1
04:03:46 <lambdabot>                -> ((a -> a1) -> a -> a1)
04:03:46 <lambdabot>                -> (a -> a1)
04:03:53 <vincenz> > (*) . (.) . (+) 1 2 3
04:03:54 <lambdabot>   add an instance declaration for (Show (a1
04:03:54 <lambdabot>                -> ((a -> b) -> a -> c)
04:03:54 <lambdabot>                -> (a -> b)
04:04:13 <vincenz> hmm
04:04:20 <vincenz> > (. (*))
04:04:21 <lambdabot>  add an instance declaration for (Show (((a -> a) -> c) -> a -> c))
04:04:30 <vincenz> @type (. (*))
04:04:31 <lambdabot> forall a c. (Num a) => ((a -> a) -> c) -> a -> c
04:05:27 <vincenz> boegel: what's the advantage of pointlessness
04:07:04 <vincenz> @pl \c n -> foldr (\a b -> c (f a) b) n xs)
04:07:04 <lambdabot> (line 1, column 39):
04:07:04 <lambdabot> unexpected ")"
04:07:04 <lambdabot> expecting variable, "(", operator or end of input
04:07:15 <vincenz> @pl \c n -> foldr (\a b -> c (f a) b) n xs
04:07:16 <lambdabot> flip flip xs . foldr . (. f)
04:07:25 <vincenz> @pl \xs -> \c n -> foldr (\a b -> c (f a) b) n xs
04:07:26 <lambdabot> flip (flip . foldr . (. f))
04:07:35 <vincenz> @pl \f xs -> \c n -> foldr (\a b -> c (f a) b) n xs
04:07:35 <lambdabot> flip . ((flip . foldr) .) . flip (.)
04:08:35 <vincenz> @pl \f xs -> \c n -> foldr (\a b -> if f a then c a b else b) n xs
04:08:36 <lambdabot> flip . ((flip . foldr) .) . flip flip id . ((flip . (ap .)) .) . liftM2 ((
04:08:36 <lambdabot> .) . if')
04:08:46 <vincenz> o.O
04:08:58 <vincenz> @type flip
04:08:59 <lambdabot> forall c a b. (a -> b -> c) -> b -> a -> c
04:09:10 <vincenz> @type flip flip
04:09:11 <lambdabot> forall a c b. b -> (a -> b -> c) -> a -> c
04:09:28 <vincenz> @type flip flip flip
04:09:29 <lambdabot> forall a c a1 b c1.
04:09:29 <lambdabot> (a -> ((a1 -> b -> c1) -> b -> a1 -> c1) -> c) -> a -> c
04:09:39 <vincenz> @type flip flip id
04:09:40 <lambdabot> forall a c a1. (a -> (a1 -> a1) -> c) -> a -> c
04:10:30 <vincenz> @type liftM2
04:10:31 <lambdabot> Not in scope: `liftM2'
04:10:48 * vincenz cuts the spam
04:11:56 <saintiss> hi
04:12:05 <boegel> vincenz: well, for one, it's looks cooler :P
04:12:28 <boegel> also, the code will be shorter, and some argue more transparent, although I don't agree on that part
04:12:31 <saintiss> where is the (==) operator implemented for Integers? it seems to me that would be an operation which is directly delegated to C, but is that so?
04:12:56 <boegel> saintiss: Eq class, probably
04:13:22 <saintiss> boegel, Eq class, which means it has the same implementation for every Eq type?
04:13:50 <ibid> the instance Eq Integer, obviously
04:14:26 <saintiss> instance Eq integer... hmm... ok, I'm browsing through prelude
04:18:49 <saintiss> hmm, I only find this:
04:18:50 <saintiss> data  Integer  =  ... -1 | 0 | 1 ...
04:18:51 <saintiss>  
04:18:51 <saintiss>  instance  Eq       Integer  where ...
04:19:06 <saintiss> maybe something is missing there instead of the ... after "where"?
04:20:38 <vincenz> C++ and Java attach identifying information (such as a VTable) to the runtime representation of an object. In Haskell, such information is attached logically instead of physically to values, through he type system.
04:20:49 <vincenz> this is not fully accurate as someone told me this morning that a dict is passed
04:21:22 <earthy> the dict is passed for classes
04:21:35 <vincenz> I fail to see the distinction
04:21:37 <earthy> in those functions where there has not been any specialization
04:21:44 <vincenz> right
04:21:52 <vincenz> why not do code instnatiations for each call site?
04:22:00 <earthy> code blowup
04:22:04 <vincenz> it would limit the overhead of table lookup
04:22:10 <vincenz> I mean remove
04:22:15 <earthy> which was a problem in early C++ implementations of templates, e.g.
04:22:39 <earthy> vincenz: you're assuming a closed world
04:22:42 <vincenz> well that's cause it would instantiate everything
04:22:46 <vincenz> not just the needed stuff
04:23:04 <vincenz> earthy: well you could jit instantiate it
04:23:09 <vincenz> afaik c# does it that way
04:23:25 <earthy> um. but then you pay quite massive startuptimes
04:23:38 <earthy> b'sides, most values are boxed anyway
04:23:48 <saintiss> hrmm... is it possible that "primitive" means a certain function is implemented in C?
04:23:51 <vincenz> you're still doing a table lookup
04:23:52 <earthy> looking up a codepointer is not that much more expensive. ;)
04:24:00 <earthy> saintiss: yup.
04:24:09 <vincenz> earthy: it's integer indexed?
04:24:12 <vincenz> it's not a LUT?
04:24:13 <saintiss> earthy, ok, that would explain a few things... thanks
04:24:40 <earthy> not sure
04:24:52 <earthy> depends on the implementation, really
04:25:03 <vincenz> which is the best implementation?
04:25:10 <earthy> ain'
04:25:16 <earthy> ain't no such thing as best
04:25:26 <earthy> different implementations have different properties
04:25:48 <earthy> you could do it with integer indexing, but that'd imply having a unique identifying number for each type
04:26:00 <earthy> which is not theoretically impossible, but quite hard
04:26:29 <earthy> especially under the open world assumption
04:26:36 <Philippa_> saintiss: Integer'll delegate to C code eventually, yeah
04:35:34 <vincenz> Philippa_: hi
04:35:46 * vincenz is reading the gentle introduction but has a small question
04:35:55 <vincenz> he type system.
04:35:58 <vincenz> data Point = Pt {pointx, pointy :: Float}
04:36:04 <vincenz> shouldn't that be
04:36:07 <vincenz> ::Float*Float
04:36:15 <vincenz> or :: Float,Float
04:36:22 <vincenz> or pointx::Float, pointy::Float
04:41:47 <gour> @where yi
04:41:48 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
04:41:57 <vincenz> @type do
04:41:58 <lambdabot> Empty 'do' construct
04:42:26 <gour> @where hs-plugins
04:42:27 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
04:42:45 <vincenz> let x = c <- getChar in 1
04:42:47 <vincenz> > let x = c <- getChar in 1
04:42:48 <lambdabot>  parse error on input `<-'
04:42:54 <vincenz> > let x = do c <- getChar in 1
04:42:55 <lambdabot>  The last statement in a 'do' construct must be an expression
04:43:05 <vincenz> > let x = {do c <- getChar} in 1
04:43:06 <lambdabot>  parse error on input `{'
04:43:12 <vincenz> > let x = getChar in 1
04:43:13 <lambdabot> 1
04:43:18 <vincenz> > let x = getChar in x
04:43:19 <lambdabot> No IO allowed
04:43:25 <vincenz> hmm
04:44:40 <vincenz> this is the example that makes me wonder whether monad based io would work in a strict fp
04:44:52 <vincenz> cause let x = getChar in 1 has type Int but still performs an io action
04:45:45 <vincenz> or is IO() a closure that doesn't actually do anything until it's called with the syntactic construct "do"
04:48:06 <Lemmih> The do-notation is just syntactic sugar. It's not necessary in any way.
04:48:52 <vincenz> so...how would you get IO monads to work in a strict language
04:49:14 <tromp_> let x = getChar in 1 doesn't perform any IO
04:49:36 <vincenz> not in a lazy lang
04:49:45 <tromp_> only things of type IO a  can perform IO
04:49:46 <vincenz> I'm saying a strict lang
04:49:52 <vincenz> ...
04:50:04 <vincenz> tromp_: yes you're guaranteed that by teh lazyness of haskell
04:50:07 <Lemmih> vincenz: It doesn't do any IO even if 'x' is forced/evaluated.
04:50:09 <vincenz> because x is not used in the return type
04:50:20 <vincenz> Lemmih: how so
04:50:48 <vincenz> IO Char is actually (some internal -> Char)?
04:51:01 <Lemmih> vincenz: You can think of an IO action as a function of type "RealWorld -> (a,RealWorld)".
04:51:18 <vincenz> and main passes the realworld
04:51:37 <vincenz> hmm
04:51:44 <vincenz> so you could in theory make haskell strict
04:52:33 <araujo> Good morning.
04:52:54 <Lemmih> vincenz: Yeah. It would break all the software which depends on laziness, though.
04:53:15 <vincenz> Lemmih: right but then you could introduce a lazy constructor
04:53:22 <vincenz> just you like have a strict constructor now
04:53:37 <Lemmih> Indeed.
04:53:48 <vincenz> neat
04:54:08 <earthy> given how useful laziness is I'd say that is going the wrong way 'round
04:54:08 <tromp_> strictness does not mean that y is evaluated in const x y
04:54:27 * vincenz comes fro ocaml
04:54:30 <vincenz> s/fro/from
04:54:48 <vincenz> @type const
04:54:49 <lambdabot> forall a b. a -> b -> a
04:54:50 * gour screams: don't make haskell strict
04:54:57 <vincenz> ...
04:54:58 <earthy> maybe I've been spoiled: my first fpl was Clean
04:55:08 <vincenz> just I like haskell
04:55:17 <vincenz> I have an idea of a haskell likek language but strict and with an oo likek syntax
04:55:20 <vincenz> so instead of
04:55:23 <vincenz> map f l
04:55:26 <vincenz> l.map(f)
04:55:38 <vincenz> l.map(f).filter(x).map(*2)
04:55:44 <Lemmih> yak. (:
04:55:45 <vincenz> :)
04:55:50 <vincenz> Lemmih: it reads very naturally
04:55:52 <vincenz> from left to right
04:55:59 <gour> vincenz: perl6?
04:55:59 <vincenz> not likek
04:56:00 <gour> lol
04:56:31 <vincenz> -> (map (*2) (filter x (map f l))
04:56:46 <vincenz> @pl (map (*2) (filter x (map f l))
04:56:46 <lambdabot> (line 1, column 31):
04:56:46 <lambdabot> unexpected end of input
04:56:46 <lambdabot> expecting variable, "(", operator or ")"
04:57:00 <Lemmih> or: map (*2) . filter x . map f
04:57:08 <vincenz> right which is backwards
04:57:33 <vincenz> hmm
04:57:34 <Lemmih> Nono, that's the right way (:
04:57:35 <vincenz> > flip .
04:57:35 <earthy> let (.|.) = flip ($) in [1..5] .|. map (+ 1) .|. filter (even) .|. map (* 2)
04:57:36 <lambdabot>  parse error on input `}'
04:57:40 <vincenz> @type flip .
04:57:41 <lambdabot> parse error (possibly incorrect indentation)
04:57:47 <vincenz> @type flip (.)
04:57:48 <lambdabot> forall b c a. (a -> b) -> (b -> c) -> a -> c
04:57:55 <vincenz> > flip (.)
04:57:55 <lambdabot>   add an instance declaration for (Show ((a -> b) -> (b -> c) -> a -> c))
04:57:57 <earthy> @type filp ($)
04:57:58 <lambdabot> Not in scope: `filp'
04:58:06 <earthy> @type flip ($)
04:58:07 <vincenz> why $ and not .
04:58:07 <lambdabot> forall b b1. b1 -> (b1 -> b) -> b
04:58:49 <earthy> vincenz: because your dot is a 'apply to' kind of operator
04:58:56 <vincenz> rigiht
04:58:57 <vincenz> so 
04:59:07 <vincenz> (.) a b = \x a (b x)
04:59:08 <vincenz> so
04:59:38 <vincenz> flip (.) would be b (a x)
04:59:51 <earthy> um.
05:00:03 <earthy> yeah
05:00:22 <vincenz> let `o` = flip (.) in map (+ 1) `o` filter (even) `o` map (* 2) l
05:00:37 <vincenz> let `o` = flip (.) in (map (+ 1) `o` filter (even) `o` map (* 2)) [1..5]
05:00:39 <vincenz> >let `o` = flip (.) in (map (+ 1) `o` filter (even) `o` map (* 2)) [1..5]
05:00:42 <vincenz> > let `o` = flip (.) in (map (+ 1) `o` filter (even) `o` map (* 2)) [1..5]
05:00:43 <lambdabot>  parse error on input ``'
05:00:54 <vincenz> > let o = flip (.) in (map (+ 1) `o` filter (even) `o` map (* 2)) [1..5]
05:00:55 <lambdabot> [4,8,12]
05:01:36 <vincenz> > let o = flip (.) in [1..5] $ map (+ 1) `o` filter (even) `o` map (* 2)
05:01:37 <earthy> yeah, but that's a different thing from what you proposed
05:01:37 <lambdabot> Couldn't match `a -> b' against `[a1]'
05:01:37 <dons> Lemmih, here's the regex-dna entry, you wanted a link: http://www.haskell.org/hawiki/RegexDna
05:02:12 <earthy> let o = flip (.) in let s = flip ($) in [1..5] `s` map (+1) `o` filter even `o` map (* 2)
05:02:13 <vincenz> > let o = flip (.) in let p = flip ($) in [1..5] `p` map (+ 1) `o` filter (even) `o` map (* 2)
05:02:13 <lambdabot>   Expecting a function type, but found `b'
05:02:13 <lambdabot>   Expected type: a -> b
05:02:13 <lambdabot>   Inferred type: [a1]
05:02:23 <vincenz> I was getting there :)
05:02:30 <earthy> let o = flip (.) in let s = flip ($) in [1..5] `s` (map (+1) `o` filter even `o` map (* 2))
05:03:01 <vincenz> > let o = flip (.) in let p = flip ($) in [1..5] `p` (map (+ 1) `o` filter (even) `o` map (* 2))
05:03:03 <lambdabot> [4,8,12]
05:03:08 <vincenz> yeah I have to learn the precedence rules
05:03:12 <vincenz> oki
05:03:19 <vincenz> I like your buttcheeks better
05:03:22 <earthy> that's why I used flip ($)
05:03:34 <earthy> less parentheses
05:03:35 <vincenz> (.|.)
05:03:41 <earthy> s/less/fewer/
05:03:43 <vincenz> @type ($)
05:03:44 <lambdabot> forall b a. (a -> b) -> a -> b
05:04:02 <vincenz> hmm
05:04:06 <earthy> oh, that's just to indicate its equivalence to unix pipes. ;)
05:04:08 <Lemmih> dons: Thanks.
05:04:09 <vincenz> > + $ *
05:04:10 <lambdabot>  parse error on input `+'
05:04:16 <vincenz> > (+) $ (*)
05:04:17 <lambdabot>   add an instance declaration for (Show ((a -> a -> a) -> a -> a -> a))
05:04:43 <vincenz> > (+ 2) $ (*)
05:04:43 <lambdabot>  add an instance declaration for (Num (a -> a -> a))
05:04:48 <vincenz> > (+ 2) $ (* 3)
05:04:49 <lambdabot>  add an instance declaration for (Num (a -> a))
05:04:52 <vincenz> > (+ 2) $ (* 3) 4
05:04:53 <lambdabot> 14
05:04:56 <vincenz> > (+ 2) $ (* 3) $ 4
05:04:57 <lambdabot> 14
05:05:25 <dons> Lemmih, it's still not competive with perl though. there's an order of magnitude something wrong :/
05:05:29 <vincenz> that's odd
05:05:34 <earthy> what is odd?
05:05:37 <vincenz> @type ($)
05:05:38 <lambdabot> forall b a. (a -> b) -> a -> b
05:05:46 <vincenz> now
05:05:57 <earthy> > (+ 2) . (* 3) $ 4
05:05:59 <lambdabot> 14
05:06:01 <vincenz> (+) $ (*) = ($) (+) (*) = 
05:06:03 <vincenz> wait
05:06:03 <dons> we'd have to look at how they do global search-and-replace efficiently
05:06:08 <vincenz> @type (+)
05:06:10 <lambdabot> forall a. (Num a) => a -> a -> a
05:06:10 <vincenz> @type (*)
05:06:11 <lambdabot> forall a. (Num a) => a -> a -> a
05:06:13 <earthy> dons: what, perl?!
05:06:21 <dons> it's a regex prblem.
05:06:22 <vincenz> how does that fit into (a -> b) -> a -> b
05:06:29 <earthy> they've written *highly* optimized text handling cod
05:06:40 <dons> yes, I know :)
05:06:47 <vincenz> what?
05:06:49 <vincenz> regex-dna?
05:06:55 <vincenz> @google shootout
05:06:57 <lambdabot> http://www.miniclip.com/bushshootout.htm
05:07:04 <vincenz> @google regex-dna
05:07:06 <lambdabot> http://www.haskell.org/hawiki/RegexDna
05:07:14 <earthy> vincenz: simple. a and b can be instantiated with any type
05:07:18 <vincenz> earthy: I know
05:07:19 <vincenz> but
05:07:36 <vincenz> (+) and (*) are bot a->a->->a
05:07:45 <vincenz> so what's the (a) in (a -> b) -> a -> b
05:08:02 <vincenz> cause (+) should be a function and (*) the b
05:08:54 <earthy> so, ($) can also have type  Num a => (((a -> a -> a) -> a -> a -> a) -> (a -> a -> a) -> (a -> a -> a)
05:09:06 <vincenz> but
05:09:12 <earthy> which is does in (+) $ (*)
05:09:15 <vincenz> no
05:09:29 <vincenz> (+) does not have type ((a -> a -> a) -> a -> a -> a)
05:09:30 <earthy> true. I'm fucking up
05:10:23 <vincenz> @type ($) (+)
05:10:24 <lambdabot> forall a. (Num a) => a -> a -> a
05:10:31 <vincenz> @type ($) (+) (*)
05:10:32 <lambdabot> forall a.
05:10:32 <lambdabot> (Num (a -> a -> a), Num a) =>
05:10:32 <lambdabot> (a -> a -> a) -> a -> a -> a
05:10:53 <vincenz> o.O
05:10:58 <earthy> makes sense
05:11:04 <vincenz> it's saying it takeks another function
05:11:10 <earthy> yeah
05:11:16 <vincenz> @type ($) (+) (*) 2
05:11:18 <lambdabot> forall a. (Num a, Num (a -> a -> a)) => a -> a -> a
05:11:27 <vincenz> but 2 ain't a function
05:11:48 <vincenz> I mean
05:11:52 <vincenz> Num (a -> a -> a)
05:11:55 <vincenz> o.O
05:12:05 <earthy> in ((+) $) $ has type  a -> (a -> a) -> a -> (a -> a)
05:12:18 <vincenz> I don't get it
05:12:23 <earthy> in ((+) $) $ has type  (a -> (a -> a)) -> a -> (a -> a) (sorry)
05:12:24 <vincenz> I doubt this would compile on ocaml
05:12:31 <vincenz> let me try
05:12:38 <vincenz> what's the definition of ($)
05:12:45 <earthy> f $ s = f x
05:13:09 <earthy> f $ x = f x   ofcourse
05:13:17 * earthy 's fingers are too cold
05:13:29 <dons> musasabi, can you commit the proposed entry on http://www.haskell.org/hawiki/RegexDna?
05:13:29 <vincenz> won't compile 
05:13:30 <vincenz> on ocaml
05:13:38 <vincenz> let dol f x = f x;;
05:13:44 <vincenz> dol (+) ( * );; 
05:13:52 * dons hopes regex-dna gets us into 1st... fingers crossed
05:13:54 <vincenz> ( * ) has type int -> int -> int but should be of type int
05:14:09 <earthy> ah, but + is not overloaded in ocaml
05:14:15 <gour> dons: what we'll do then?
05:14:15 <earthy> whereas it is in haskell
05:14:37 <dons> gour, celebrate with lentils and rice ;)
05:14:38 <vincenz> fine
05:14:44 <vincenz> earthy: to what?
05:14:46 <earthy> note the requirement for  Num (a -> a -> a)   in the type
05:14:53 <vincenz> earthy: yeah whiich makes no sense to me
05:15:01 <vincenz> how can a number be a function of two parameters
05:15:12 <earthy> so, *given* an instance of the Num typeclass for functions of two parameters
05:15:24 <earthy> and an instance of the Num typeclass for the parameters
05:15:26 <vincenz> btw, someone has flipped up the regex-dna thingy, the ocaml one used to work
05:15:46 <vincenz> earthy: what is a Num typeclass for finctions of two parameters
05:15:52 <vincenz> conceptually
05:16:00 <Saulzar> Num has one parameter
05:16:02 <gour> dons: in vedic culture, 'feast' means '..with baked grains..' :-)
05:16:09 <vincenz>  Num (a -> a -> a)
05:16:11 <dons> oh, it was working last time i checked.http://shootout.alioth.debian.org/gp4/benchmark.php?test=regexdna&lang=all
05:16:14 <earthy> conceptually it is a way of adding, subtracting and multiplying such functions
05:16:16 <dons> gour, ah!
05:16:20 <Saulzar> Num a => (a -> a -> a)
05:16:38 <vincenz> yeah duh
05:16:46 <vincenz> Error, could not exec regexdna.ocaml_run 1 (No such file or directory)
05:16:47 <vincenz> Saulzar: no
05:16:48 * gour likes bread
05:16:50 <vincenz> Saulzar: ealrier it said
05:16:52 <earthy> ofcourse, that may not mean anything, vincenz. ;)
05:16:55 <vincenz> Num (a -> a -> a)
05:16:59 <earthy> but the typesystem does not know that
05:17:02 <vincenz> ...
05:17:06 <vincenz> well
05:17:08 <Saulzar> You must have been trying to use a function as a number type :)
05:17:17 <vincenz> I'm trying to figure out what
05:17:23 <earthy> saulzar: that is exactly what he was doing
05:17:32 <vincenz> (+) $ (*) means
05:17:37 <earthy> and the typesystem doesn't forbid him to do that
05:17:37 <vincenz> apply + to *
05:18:10 <vincenz> oh
05:18:12 <vincenz> I see why it fails for ocaml
05:18:28 <vincenz> the idiots gave the wrong compile line
05:18:29 <earthy> it just requires him to give an instance of what addition would mean on functions from two paramters to a result 
05:18:33 <vincenz> they forgot to include str.cmxa
05:18:56 <vincenz> although it clearly states so in the ocaml file
05:19:32 <vincenz> How do I fix that?
05:20:29 <gour> dons: http://shootout.alioth.debian.org/debian/benchmark.php?test=all&lang=all
05:23:36 <earthy> timeout. hm.
05:25:41 <vincenz> clean seems a lot like haskell
05:26:01 <vincenz> what's the diff
05:26:34 <Lemmih> Yeah, I also think Haskell is very clean.
05:26:47 <earthy> finer grained class system, uniqueness types
05:26:54 <vincenz> which one?
05:27:05 <earthy> clean has those
05:27:20 <vincenz> so why is there no clean channel but is there a haskell channel
05:27:21 <earthy> oh, neatly optimized implementation as well
05:27:25 <vincenz> clean's newer?
05:27:28 <earthy> not even
05:27:45 <earthy> no, Clean was only available commercially until a couple of years ago
05:27:52 <vincenz> oh
05:27:54 <earthy> and there were fewer people working on it
05:27:54 <vincenz> so
05:27:57 <vincenz> why don't the two unify?
05:28:03 <earthy> egos. :)
05:28:07 <vincenz> LOL
05:28:11 <vincenz> which is better
05:28:26 <earthy> actually, there's hacle, which compiles haskell to clean
05:28:35 <earthy> ain't no such thing as better. :)
05:28:43 <earthy> it really depends
05:28:47 <vincenz> well
05:28:51 <vincenz> waht's the tradeoff curve
05:28:52 <earthy> clean's records system is nicer
05:28:55 <earthy> clean has faster arrays
05:28:55 <vincenz> there must be pareto curve
05:29:04 * vincenz nods
05:29:13 <earthy> clean's support and takeup is lower
05:29:27 <vincenz> even though it's better?
05:29:34 <earthy> nope. it isn't better
05:29:35 <earthy> that's the thing
05:29:42 <vincenz> you just gave two things clean was better at
05:29:44 <earthy> it's just as good really
05:29:46 <vincenz> without anything for haskell
05:30:03 <earthy> because haskell has more tools
05:30:07 <earthy> and more libraries
05:30:13 <earthy> and more support and documentation
05:30:14 <vincenz> yeah but that's mostly a support thing
05:30:23 <vincenz> so given the same amount of people working on both
05:30:25 <vincenz> clean would be better
05:30:28 <earthy> and haskell is catching up. fast. :)
05:30:44 <vincenz> does haskell have uniqueness typinig?/
05:30:49 <earthy> yes. but that's the thing. there's like 10 people working on clean
05:31:06 <vincenz> earthy: well more people should work on it if it's clearly better
05:31:09 <vincenz> :)
05:31:09 <earthy> no, it does not. but uniqueness typing is more of a style issue than a real advantage
05:31:21 <vincenz> earthy: I just read it's necessary for concurrenc
05:31:22 <vincenz> y
05:31:25 <earthy> that's the thing: clean is not clearly better.
05:31:38 <earthy> uniqueness typing facilitates concurrency
05:31:43 <vincenz> right
05:31:59 <vincenz> so I take it this is like a holy war
05:32:03 <vincenz> such as sml vs ocaml?
05:32:08 <earthy> not really
05:32:13 <vincenz> How come there's no clean channel
05:32:23 <earthy> there's too few people playing with clean
05:32:43 <earthy> and many of them are in one building in Nijmegen anyway. :)
05:32:48 <vincenz> :)
05:32:49 <vincenz> pity
05:32:51 <vincenz> it seems neat
05:32:56 <earthy> oh, it is.
05:33:14 <earthy> it's just that the main ego behind it should wake up and start doing haskell. :P
05:33:18 <vincenz> I'm amazed at just HOW similar they are
05:33:29 <vincenz> earthy: or haskell should get behind clean
05:33:30 <earthy> he won't do that ofcourse
05:33:54 <earthy> okay, should 10 research groups switch, or 1? :)
05:34:38 <vincenz> btw
05:34:42 <vincenz> does haskell have something like sparkle
05:35:26 <vincenz> earthy: I doubt all 10 research groups are researching haskell itself instead of using it as a basis, if they use it as a basis, a migration shouldn't be difficult, the languages look nearly identical
05:35:51 <vincenz> damn
05:35:53 <vincenz> but they look ALIKE
05:36:48 <earthy> type signatures look different though
05:37:45 <vincenz> does haskell have something like sparkle?
05:38:00 <earthy> yep. programmatica
05:38:52 <earthy> err, programatica that is
05:39:06 <vincenz> and a clean gui lib like clean
05:39:45 <earthy> a choice of wxHaskell and gtk2hs
05:39:54 * dcoutts reccomends Gtk2Hs
05:40:14 <vincenz> gotta amid
05:40:15 <vincenz> admit
05:40:19 <vincenz> clean looks rather attractive
05:40:34 <earthy> true. if you're on windows. :P
05:40:56 * vincenz is on windows
05:41:13 <vincenz> foot $ insert $ shoe
05:41:39 <vincenz> so hacle basically compiles haskell to clean
05:41:45 <vincenz> who made it? clean people or haskell people
05:41:59 <earthy> 'Marco Pil is in the process of finishing up his Ph.D. thesis.'
05:42:01 * earthy laughs
05:42:07 <earthy> yeah. and has been for 5 years. :)
05:42:15 <earthy> vincenz: haskell people. IIRC
05:42:25 <vincenz> isn't that likek kshooting yourself in the foot?
05:43:00 <sieni> I'm in the process of finishing up learning to juggle 7 clubs and will be for the foreseeable future.
05:43:29 <vincenz> o.O
05:44:03 <vincenz> it's rather sad
05:44:12 <vincenz> it's likek most optimization efforts going into sml although ocaml is better
05:45:00 <kosmikus> ?
05:47:52 <earthy> actually, there's a shiteload of optimization going into haskell
05:48:02 <vincenz> people on #ocaml are so complacent
05:48:08 <earthy> plus, ÃClean got started as basically abackend for a miranda-compiler
05:49:46 <wilx> @yow
05:49:48 <lambdabot> hubub, hubub, HUBUB, hubub, hubub, hubub, HUBUB, hubub, hubub, hubub.
05:52:10 <sieni> well, it would help if ocaml had an implementation without a crappy license for the compiler (QPL)
06:09:30 <wilx> How crappy is it?
06:09:46 <vincenz> qpl
06:09:47 <vincenz> ?
06:13:34 <mfgl> After a quick read, I think qpl only lets you patch the source, but not to do your own modified version.
06:42:28 <vincenz> @type compare
06:42:29 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
06:42:43 <vincenz> Is there some kind of function to give me SOME value of a certain type?
06:44:24 <kosmikus> undefined
06:44:38 <vincenz> > undefined(Ordering)
06:44:38 <lambdabot>  Not in scope: data constructor `Ordering'
06:44:44 <vincenz> nope
06:44:54 <kosmikus> ??
06:45:07 <vincenz> I basically want a way to generate a value of some type
06:45:09 <vincenz> I don't care
06:45:10 <vincenz> any
06:45:22 <ValarQ> > 1
06:45:23 <kosmikus> as I said, undefined does that; it's just not a useful value
06:45:24 <lambdabot> 1
06:45:30 <vincenz> ValarQ: of a certaini type
06:45:38 <ValarQ> 1::Int
06:45:40 <vincenz> kosmikus: undefined = _|_ ?
06:45:46 <kosmikus> yes
06:45:52 <vincenz> ValarQ: and I want a different type, as in give na type, give me a value
06:46:08 <vincenz> should be feasible
06:46:10 <vincenz> I mean for a union type
06:46:13 <vincenz> just takek the first possibility
06:46:21 <vincenz> and then recurse down into any parts of that type
06:46:32 <kosmikus> yes, it's feasible, but you need generic programming then
06:46:32 <vincenz> with like 0 and 0.0 as defaults for int and float
06:46:51 <vincenz> hmm
06:47:00 <vincenz> Just curious what Ordering looked like
06:47:05 <vincenz> I guess googling would be faster
06:47:23 <kosmikus> :i Ordering
06:47:23 <TheHunter> > [minBound::Ordering..maxBound]
06:47:25 <lambdabot>  parse error on input `Ordering..'
06:47:29 <TheHunter> > [(minBound::Ordering)..maxBound]
06:47:31 <lambdabot> [LT,EQ,GT]
06:47:39 <vincenz> o.O
06:47:40 <vincenz> woow
06:48:14 <vincenz> > [(minBound::(Maybe Int))..maxBound]
06:48:15 <lambdabot>  add an instance declaration for (Bounded (Maybe Int))
06:48:15 <lambdabot>   In an arithmetic sequence: [(minBound :: Maybe Int) .. maxBound]
06:48:15 <lambdabot>   In the definition of `sns': sns = [(minBound :: Maybe Int) .. maxBound]
06:48:32 <vincenz> > [(minBound::Int)..maxBound]
06:48:33 <lambdabot> [-2147483648,-2147483647,-2147483646,-2147483645,-2147483644,-2147483643,-
06:48:33 <lambdabot> 2147483642,-2147483641,-2147483640,-2147483639,-2147483638,-2147483637,-
06:48:33 <lambdabot> 2147483636,-2147483635,-2147483634,-2147483633,-2147483632,-2147483631,-
06:48:33 <lambdabot> 2147483630,-2147483629,-2147483628,-2147483627,-2147483626,-2147483625,-
06:48:33 <lambdabot> 2147483624,-2147483623,-2147483622,-2147483621,-2147483620,-2147483619,-
06:48:35 <lambdabot> [24 @more lines]
06:48:41 <vincenz> only 24?
06:48:48 <ValarQ> not really
06:48:50 <sieni> they must be long lines :-)
06:48:54 <vincenz> seemed very little :)
06:49:05 <ValarQ> i think there is a cpu time limit
06:49:08 <vincenz> I'm starting to like haskell
06:49:12 <vincenz> a lot
06:49:14 <ValarQ> which cuts the rest
06:49:15 <vincenz> and I don't know it yet
06:49:24 <ValarQ> vincenz: i know the feeling :)
06:49:27 <vincenz> just a shame
06:49:54 <vincenz> .. it's actually rather sad that haskell uses runtime dispatching, it has such an amazing compiletime type system and then for the implementatio nbasically reaches for the same solution as a dynamically typed langauge
06:50:55 <vincenz> @type bot
06:50:56 <lambdabot> Not in scope: `bot'
06:51:00 <vincenz> @type bottom
06:51:01 <lambdabot> Not in scope: `bottom'
06:51:04 <vincenz> @type _|_
06:51:05 <lambdabot> parse error on input `|'
06:54:58 <Saulzar> vincenz, Where the instance is known it may be specialised, and there are times when it can't (existential types) 
06:55:35 <vincenz> not certain
06:55:36 <musasabi> dons: not really sure if we are allowed to call into C with FFI without being labelled unfair.
06:55:44 <gour> dcoutts: ping
06:55:47 <vincenz> ... what you mean
06:55:54 <dcoutts> gour, pong
06:56:09 <vincenz> anyway
06:56:14 <vincenz> gonna reboot my laptop to linux
06:56:17 <vincenz> so I can get darcs
06:56:20 <vincenz> and lambdabot
06:56:21 <Saulzar> vincenz, You're still on about vtables right?
06:56:22 <vincenz> and take a look
06:56:24 <vincenz> Saulzar: yeah
06:56:46 * vincenz thinks you do call-site based instantation
06:56:55 * vincenz adds a _should_
06:57:16 <vincenz> call-site based instantiation during whole program optimization
06:57:50 <gour> dcoutts: do you receive all your email from .*haskel & .*gtk2hs lists?
06:58:00 <dcoutts> gour, no :-(
06:58:01 <Saulzar> It can be, but it isn't always - and there is compiler specific stuff to force it.
06:58:09 <gour> dcoutts: i see that i'm missing some
06:58:10 <Saulzar> I really think it's not such a worry, I enjoy not being paranoid about each instruction :)
06:58:18 <dcoutts> gour, well in paticular from the gtk2hs list
06:58:27 <dcoutts> gour, some of the stuff I send doesn't make it.
06:58:28 <vincenz> Saulzar: ah, yeah well I come from a different field, I am :)
06:58:46 <gour> dcoutts: e.g. i saw only axel's reply, but got no original post
06:58:58 <dcoutts> gour, I think it's because the SourceForge use a spam blacklist and somehow my unifersity smtp server got onto the spam blacklist
06:59:15 <gour> dcoutts: similar with some posts on .*haskell
06:59:31 <dcoutts> gour, well somethimes that happens because we start private discussions and later cc replies to the devel list
06:59:38 <gour> dcoutts: i also do not get my posts...
07:00:02 <dcoutts> gour, we should look again at migrating the mailing lists to haskell.org
07:00:16 <dcoutts> gour, what do you think?
07:00:22 <araujo> Anyone knows if there exist a function that helps me to find the extension of a file?
07:00:53 <araujo> dcoutts, hey!... this time gtk2hs compilation took practically nothing and went so smooth!!
07:01:06 <dcoutts> araujo, yay :-)
07:01:44 <gour> dcoutts: i'm for it. what else we need SF for?
07:01:54 <dcoutts> gour, file release?
07:02:55 <dcoutts> > let getExtension = reverse . takeWhile (/='.') . reverse in getExtension "foo.txt"
07:02:56 <lambdabot> "txt"
07:03:03 <gour> dcoutts: is it worth to keep sf for it?
07:03:04 <dcoutts> araujo, how about that?
07:03:20 <dcoutts> gour, well it doesn't hurt
07:03:40 <dcoutts> gour, there is no problem in keeping the SF resources
07:03:44 <gour> dcoutts: ok, but let's move lists to haskell.org
07:03:55 <dcoutts> gour, yes lets investigate it
07:04:01 * gour still thinks about using trac
07:04:14 <dcoutts> gour, moving the archives might be tricky
07:04:25 <araujo> dcoutts, yeah, i know i can do it with parsing the name.. but i was trying to get something like the file unix command.
07:04:27 <gour> dcoutt: you must have access to archives?
07:04:39 <gour> dcoutts: why?
07:04:45 <dcoutts> araujo, oh, you mean like getting the mime type?
07:04:50 <araujo> dcoutts, right
07:05:12 <dcoutts> gour, well we've got the web interface, I don't know about getting it as an mbox file for example
07:05:30 <gour> dcoutts: there is mailman script to convert from one domain to another
07:05:43 <dcoutts> araujo, I don't know of any Haskell libs that will do that. But I'm sure you can bind one. Or call "file".
07:06:02 <dcoutts> gour, but that assumes we have access to the machine doesn't it?
07:06:15 <gour> dcoutts: yep
07:06:32 <dcoutts> gour, and I'm not sure we do.
07:06:45 <araujo> dcoutts, yeah, im between usinf "file" or parsing the name.....
07:06:51 <dcoutts> araujo, you can call out to "file --mime"
07:07:18 * gour forgot his passwd for SF :-(
07:08:13 <dcoutts> araujo, or bind libmagic
07:08:26 <dcoutts> araujo, the file prog comes with libmagic which has a C API
07:09:08 * gour didn't forget his passwd, but his username on SF :-(
07:09:18 <dcoutts> gour, oops
07:09:54 <dcoutts> gour, it's "ggd"
07:10:09 * dcoutts checked the gtk2hs project members
07:11:02 <gour> dcoutts: ta, i'm already on sf :-)
07:11:29 <araujo> dcoutts, yeah!!.. looking at that right now
07:11:36 <araujo> I think i'll do that, thanks dcoutts 
07:13:32 <dcoutts> araujo, you've used c2hs before right?
07:16:34 <araujo> dcoutts, not really... but ive read about it, it doesn't look that hard.
07:16:38 <araujo> I guess :-)
07:16:49 <vincenz> > (1:) . (2:) 
07:16:50 <lambdabot>  add an instance declaration for (Show ([a] -> [a]))
07:16:57 <dcoutts> araujo, yep, it's not too hard, and the manual is quite good
07:16:59 <vincenz> > ((1:) . (2:) ) $ []
07:17:00 <lambdabot> [1,2]
07:17:10 * gour is reading SF docs
07:17:31 <araujo> dcoutts, do you recommend c2hs over ffi?
07:17:47 <dcoutts> araujo, yes, especially for anything non-trivial
07:17:55 <araujo> Good.
07:18:12 <dcoutts> araujo, c2hs uses the FFI of course, but it does more stuff for you
07:18:22 <araujo> ah, i see, great.
07:21:47 <vincenz> (read . show ) 1
07:21:50 <vincenz> > (read . show ) 1
07:21:51 <lambdabot> Add a type signature
07:22:12 <vincenz> > (read . (show::ShowS Int)) 1
07:22:13 <lambdabot>   Kind error: `ShowS' is applied to too many type arguments
07:22:13 <lambdabot>   In the type `ShowS Int'
07:22:13 <lambdabot>   In an expression type signature: ShowS Int
07:22:20 <vincenz> > (read . (show::Show Int)) 1
07:22:21 <lambdabot>   Class `Show' used as a type
07:22:21 <lambdabot>   In the type `Show Int'
07:22:21 <lambdabot>   In an expression type signature: Show Int
07:22:33 <Cale> > (read . (show :: Int -> String)) 1
07:22:35 <lambdabot> Add a type signature
07:22:39 <Cale> > (read . (show :: Int -> String)) 1 :: Double
07:22:41 <lambdabot> 1.0
07:22:45 <vincenz> o.O
07:22:56 <vincenz> ((read :: String -> Int ) . show )1
07:23:03 <vincenz> > ((read :: String -> Int ) . show )1
07:23:04 <lambdabot> 1
07:23:06 <vincenz> ah
07:23:07 <vincenz> :)
07:23:15 <vincenz> > ((read :: String -> Maybe Int ) . show )1
07:23:16 <lambdabot> Exception: Prelude.read: no parse
07:23:22 <Cale> > (read . show) 1 :: Double
07:23:24 <lambdabot> 1.0
07:23:36 <vincenz> > (read . show) (1:: Double)
07:23:37 <lambdabot> Add a type signature
07:23:38 <vincenz> should give error
07:23:40 <vincenz> yip
07:23:44 <vincenz> cool :)
07:24:27 <Cale> Normally the fact that the type of 1 is unknown would be a problem too, but there's a defaulting mechanism for numbers
07:24:49 <vincenz> ah
07:24:51 * vincenz nods
07:24:58 <vincenz> > (read . show) 1::Char
07:24:59 <lambdabot> Exception: Prelude.read: no parse
07:25:03 <vincenz> > (read . show) 1::String
07:25:04 <lambdabot> Exception: Prelude.read: no parse
07:25:06 <vincenz> odd
07:25:17 <vincenz> Why do they not work
07:25:18 <Cale> > read "\"1\"" :: String
07:25:20 <lambdabot> "1"
07:25:24 <vincenz> ah
07:25:26 * vincenz nods
07:25:29 <vincenz> how about char then
07:25:35 <vincenz> < read "'1'"::Char
07:25:35 <Cale> show 'c'
07:25:37 <Cale> > show 'c'
07:25:38 <lambdabot> "'c'"
07:25:43 * vincenz nods
07:25:44 <Cale> > read "'c'"
07:25:45 <lambdabot> Add a type signature
07:25:46 <vincenz> coolies, thanks
07:25:51 <vincenz> > read "'1'"::Char
07:25:51 <Cale> > read "'c'" :: Char
07:25:52 <lambdabot> '1'
07:25:52 <lambdabot> 'c'
07:26:53 <vincenz> > map (\x -> ''' : x : [''']) "lambdabot" 
07:26:54 <lambdabot>  lexical error in string/character literal
07:27:17 <Cale> > map (\x -> '\'' : x : ['\'']) "lambdabot" 
07:27:19 <lambdabot> ["'l'","'a'","'m'","'b'","'d'","'a'","'b'","'o'","'t'"]
07:27:36 <vincenz> > map (read :: String -> Char . show) $ (map (\x -> '\'' : x : ['\'']) $ "lambdabot"
07:27:37 <lambdabot>  parse error on input `}'
07:27:46 <vincenz> > map (read :: String -> Char . show) $ map (\x -> '\'' : x : ['\'']) $ "lambdabot"
07:27:47 <lambdabot>   add (Read (. Char show)) to the expected type of an expression
07:27:47 <lambdabot>   or add an instance declaration for (Read (. Char show))
07:27:47 <lambdabot>   In the expression: read :: String -> Char . show
07:27:58 <vincenz> > map ((read :: String -> Char) . show) $ map (\x -> '\'' : x : ['\'']) $ "lambdabot"
07:28:00 <lambdabot> Exception: Prelude.read: no parse
07:28:21 <vincenz> > map (\x -> (read :: String -> Char) . show) x) $ map (\x -> '\'' : x : ['\'']) $ "lambdabot"
07:28:21 <lambdabot>  parse error on input `)'
07:28:24 <gour> dcoutts: http://www.python.org/cgi-bin/faqw-mm.py?req=show&file=faq04.018.htp
07:28:25 <Cale> > map (read :: String -> Char) $ map (\x -> '\'' : x : ['\'']) $ "lambdabot"
07:28:27 <lambdabot> "lambdabot"
07:28:35 <vincenz> oh right
07:28:35 <vincenz> duh
07:28:39 <Cale> you're already doing show :)
07:28:40 <vincenz> thx
07:28:45 <vincenz> true :)
07:28:53 * vincenz feels like an idioit and continues reading gentle intro
07:29:04 <vincenz> any more advanced texts for after it?
07:29:13 <ihope> > (show . show . show . show . show . show . show) "Foobar!"
07:29:16 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\
07:29:16 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\
07:29:16 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
07:29:16 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Foobar!\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
07:29:17 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
07:29:19 <lambdabot> \\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
07:29:21 <lambdabot> \\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\"\\\"\""
07:29:22 <Cale> heh
07:29:23 <ihope> ...Maybe that wasn't a good idea.
07:29:44 <o_Rocky> @type Maybe True
07:29:45 <lambdabot> Not in scope: data constructor `Maybe'
07:29:56 <ihope> @type Just True
07:29:57 <lambdabot> Maybe Bool
07:29:59 <vincenz> show $ show $ show
07:30:08 <ihope> > show $ show $ show
07:30:08 <vincenz> > show $ show $ show show
07:30:09 <lambdabot>  add an instance declaration for (Show (a -> String))
07:30:09 <lambdabot>  add an instance declaration for (Show (a -> String))
07:30:12 <ihope> :-P
07:30:30 <musasabi> > foldl1 (.) (replicate 5 show) "foo"
07:30:32 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"foo\\\\\\\\
07:30:32 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\"\\\"\""
07:30:33 <Cale> vincenz: Well, you could read/flip through the report. I highly recommend reading the prelude. There's also "Yet Another Haskell Tutorial" which, while it's less advanced, I think it covers some extra ground with regards to practical issues :)
07:30:39 <musasabi> is much more elegant.
07:30:44 <vincenz> Cale: thank you :)
07:30:54 <vincenz> @type foldl1
07:30:55 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
07:31:00 <vincenz> @type foldl
07:31:01 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
07:31:03 <vincenz> oh right
07:31:23 <vincenz> hmm
07:31:34 <vincenz> foldl1(.) (replicate 1000 show) "HAHAHA"
07:31:34 <Cale> vincenz: You'll also probably want to learn about monads at some point. I recommend my tutorial MonadsAsContainers, which is on the wiki, followed by "All About Monads"
07:31:57 <vincenz> Cale: looked at that one in the past I believe but I'll relook at it
07:32:03 <vincenz> @wiki MonadsAsContainers
07:32:04 <lambdabot> http://www.haskell.org/hawiki/MonadsAsContainers
07:32:12 <vincenz> lambdabot: thanks doll
07:32:24 <tromp_> isn't iterate more elegant still, musasabi?
07:32:44 <Cale> > iterate show "haha" !! 3
07:32:45 <vincenz> @type iterate
07:32:46 <lambdabot> "\"\\\"\\\\\\\"haha\\\\\\\"\\\"\""
07:32:47 <lambdabot> forall a. (a -> a) -> a -> [a]
07:32:52 <tromp_> > iterate show "foo" !! 5
07:32:53 <vincenz> !type !!
07:32:53 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"foo\\\\\\\\
07:32:53 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\"\\\"\""
07:33:02 <vincenz> !type (!!)
07:33:07 <Cale> @type (!!)
07:33:07 <vincenz> @type (!!)
07:33:08 <lambdabot> forall a. [a] -> Int -> a
07:33:09 <lambdabot> forall a. [a] -> Int -> a
07:33:20 <vincenz> ponder
07:33:27 <Cale> List indexing
07:33:30 <vincenz> ah
07:33:30 <tromp_> @type replicate
07:33:31 <lambdabot> forall a. Int -> a -> [a]
07:33:33 <musasabi> tromp_: depends on whether one wants a list of the results or a function producing the nth show.
07:33:35 <vincenz> @type iterate
07:33:36 <lambdabot> forall a. (a -> a) -> a -> [a]
07:33:38 <vincenz> ah I see
07:33:55 <Cale> > iterate (*2) 1
07:33:56 <lambdabot> [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,
07:33:56 <lambdabot> 131072,262144,524288,1048576,2097152,4194304,8388608,16777216,33554432,
07:33:56 <lambdabot> 67108864,134217728,268435456,536870912,1073741824,2147483648,4294967296,
07:33:56 <lambdabot> 8589934592,17179869184,34359738368,68719476736,137438953472,274877906944,
07:33:56 <lambdabot> 549755813888,1099511627776,2199023255552,4398046511104,8796093022208,
07:33:58 <lambdabot> [24 @more lines]
07:33:59 <tromp_> even if you want the n'th
07:34:10 <vincenz> t> replicate 
07:34:16 <vincenz> iterate is endless?
07:34:19 <Cale> yeah
07:34:24 <musasabi> of course one could define: showN i str = iterate show str !! i
07:34:26 <tromp_> i think of iterate f x !! n as the idiomatic translation of f^n x
07:34:29 <Cale> [x, f x, f (f x), ...
07:34:30 <vincenz> > iterate (*2) 1 !! 1000
07:34:32 <lambdabot> 107150860718626732094842504906000181056140481170553360744375038837035105112
07:34:32 <lambdabot> 493612249319837881569585812759467291755314682518714528569231404359845775746
07:34:32 <lambdabot> 985748039345677748242309854210746050623711418779541821530464749835819412673
07:34:32 <lambdabot> 987675591655439460770629145711964776865421676604298316526243868372056680693
07:34:32 <lambdabot> 76
07:34:37 <vincenz> > iterate (*2) 1 !! 1000000
07:34:38 <lambdabot> Exception: stack overflow
07:34:44 <vincenz> :D
07:34:45 <sieni> <3
07:34:59 <vincenz> I never understood the <3 smiley
07:35:27 <Cale> > map (<3) [1..10]
07:35:29 <lambdabot> [True,True,False,False,False,False,False,False,False,False]
07:35:46 <neologism> vincenz: <3 is heart
07:35:49 <vincenz> yeah I figured that much I meant the smiley
07:35:57 <vincenz> oh
07:36:00 <vincenz> it looks likek someone else
07:36:05 <vincenz> youd imagine hearts the right side up
07:36:12 <vincenz> I mean something else
07:36:13 <tromp_> recurrence coeff basis = rec where
07:36:13 <tromp_>  rec = basis ++ rest
07:36:13 <tromp_>  rest = foldl (zipWith (+)) (repeat 0) $ zipWith (map.(*)) coeff $ tails rec
07:36:42 * vincenz peers at tromp_ 
07:37:08 <tromp_> hmm, is lambdabot stateless?
07:37:18 <vincenz> I would presume so
07:37:26 <vincenz> @start state
07:37:26 <lambdabot> Maybe you meant: part state
07:37:28 <vincenz> definition
07:37:29 <vincenz> @stop tate
07:37:30 <lambdabot> Unknown command, try @listcommands.
07:37:43 <vincenz> it would be nice to have a per-user state
07:37:47 <vincenz> for definitions
07:37:52 <tromp_> can you give it a function def, and use it later?
07:38:25 <tromp_> that'd be most useful
07:38:27 <vincenz> > let recurrence coeff basis = rec where {rec = basis ++ rest; rest = foldl (zipWith (+)) (repeat 0) $ zipWith (map.(*)) coeff $ tails rec} in recurrence 1 [1,1]
07:38:28 <lambdabot>  add an instance declaration for (Num [a])
07:38:47 <tromp_> that's not the way to use it
07:38:53 <tromp_> think of fib = recurrence [1,1] [0,1]
07:39:02 <vincenz> > let recurrence coeff basis = rec where {rec = basis ++ rest; rest = foldl (zipWith (+)) (repeat 0) $ zipWith (map.(*)) coeff $ tails rec} in recurrence [1,1] [1,1]
07:39:03 <lambdabot> [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,
07:39:03 <lambdabot> 17711,28657,46368,75025,121393,196418,317811,514229,832040,1346269,
07:39:03 <lambdabot> 2178309,3524578,5702887,9227465,14930352,24157817,39088169,63245986,
07:39:03 <lambdabot> 102334155,165580141,267914296,433494437,701408733,1134903170,1836311903,
07:39:03 <lambdabot> 2971215073,4807526976,7778742049,12586269025,20365011074,32951280099,
07:39:05 <lambdabot> [24 @more lines]
07:39:06 <vincenz> yeah I aws thinking fib
07:39:17 <gour> dcoutts: see http://sourceforge.net/docs/G01#backup (Mailing list archives are provided upon request to a project administrator.)
07:39:26 <vincenz> @type tails
07:39:28 <lambdabot> Not in scope: `tails'
07:39:28 <dcoutts> gour, ah ha
07:39:35 <vincenz> o.O
07:39:38 <vincenz> . tails
07:39:41 <vincenz> > tails
07:39:42 <lambdabot>  add an instance declaration for (Show ([a] -> [[a]]))
07:39:52 <gour> dcoutts: so we'd need to prepare ground on haskell.org 1st
07:40:05 <dcoutts> gour, right
07:40:28 <earthy> @type tails
07:40:30 <lambdabot> Not in scope: `tails'
07:40:37 <earthy> weirdness.
07:40:38 <gour> dcoutts: and when we have access to lists on haskell.org, do the archives
07:40:57 <dcoutts> right
07:40:57 <gour> dcoutts: do we need commit-list ?
07:41:06 <dcoutts> gour, why not?
07:41:12 <gour> (i mean its archive)
07:41:36 <dcoutts> well if we can do the others I don't see any reason to leave one out
07:42:05 <gour> i mean, we have history in darcs...
07:43:55 <vincenz> I never got this for monads
07:44:02 <vincenz> xs >>= return . flux__ =fmap f xs
07:44:14 <vincenz> xs >>= return . f      =    fmap f xs
07:44:25 <vincenz> (disregard first line, bad copy from website)
07:44:33 <ihope> @index tails
07:44:34 <lambdabot> Data.List
07:44:44 <ihope> @type Data.List.tails
07:44:46 <lambdabot> forall a. [a] -> [[a]]
07:44:57 <vincenz> > tails [1;2;3]
07:44:58 <lambdabot>  parse error on input `;'
07:45:01 <vincenz> > tails [1,2,3]
07:45:02 <lambdabot> [[1,2,3],[2,3],[3],[]]
07:45:06 <vincenz> ah
07:45:15 <dcoutts> gour, true. A permanent mail archive of all the changes is rather reasuring though. :-)
07:45:18 <ihope> > (concat . tails) [1,2,3,4,5,6,7,8,9]
07:45:20 <lambdabot> [1,2,3,4,5,6,7,8,9,2,3,4,5,6,7,8,9,3,4,5,6,7,8,9,4,5,6,7,8,9,5,6,7,8,9,6,
07:45:20 <lambdabot> 7,8,9,7,8,9,8,9,9]
07:45:30 <ihope> > (concat . inits) [1,2,3,4,5,6,7,8,9]
07:45:32 <lambdabot> [1,1,2,1,2,3,1,2,3,4,1,2,3,4,5,1,2,3,4,5,6,1,2,3,4,5,6,7,1,2,3,4,5,6,7,8,
07:45:32 <lambdabot> 1,2,3,4,5,6,7,8,9]
07:46:02 <Cale> Five golden rings!
07:46:15 <Cale> heh
07:46:21 <vincenz> it should be 12 the
07:46:23 <vincenz> not 9
07:46:27 <Cale> yeah
07:46:32 <Cale> and it should count down
07:48:28 <gour> dcoutts: i wanted to avoid migration of the biggest one (haskell's laziness influences me :-)
07:48:39 <dcoutts> gour, heh 
07:48:54 <vincenz> @pointless \a b -> a >>= (\x -> b >>= (\y -> if x=\y then (x,y) else fail ""))
07:48:54 <lambdabot> (line 1, column 39):
07:48:54 <lambdabot> unexpected "="
07:48:54 <lambdabot> expecting letter or digit, variable, "(", operator or "then"
07:49:02 <vincenz> @pointless \a b -> a >>= (\x -> b >>= (\y -> if x/=y then (x,y) else fail ""))
07:49:03 <lambdabot> (. ((. flip (flip . ap (ap . (if' .) . (/=)) (,)) (fail [])) . (>>=))) . (
07:49:03 <lambdabot> >>=)
07:49:37 <vincenz> > (. ((. flip (flip . ap (ap . (if' .) . (/=)) (,)) (fail [])). (>>=))) . (>>=) $ [1,2,3] [1,2,3]
07:49:37 <lambdabot>  Not in scope: `if''
07:49:50 <vincenz> @index if'
07:49:50 <lambdabot> bzzt
07:50:00 <vincenz> odd
07:50:02 <musasabi> if' a b c = if a then b else c
07:50:13 <gour> dcoutts: so, what's next? you'll create new lists and ask for the archives?
07:50:14 <vincenz> so why is the pointless thingy not executable
07:50:17 <vincenz> it's flawed
07:50:25 <dcoutts> gour, I guess so
07:50:26 <ihope> @type sequence_
07:50:27 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
07:50:38 <vincenz> basically it's this
07:50:40 <vincenz> > [(x,y) | x <- [1,2,3] , y <- [1,2,3], x /= y]
07:50:42 <musasabi> > let if' a b c = if a then b else c in  (. ((. flip (flip . ap (ap . (if' .) . (/=)) (,)) (fail [])). (>>=))) . (>>=) $ [1,2,3] [1,2,3]
07:50:42 <lambdabot> [(1,2),(1,3),(2,1),(2,3),(3,1),(3,2)]
07:50:43 <lambdabot>   The function `[1, 2, 3]' is applied to one arguments,
07:50:43 <lambdabot>   but its type `[a]' has none
07:50:45 <ihope> > sequence_ [[1,2,3],[4,5,6],[7,8,9]]
07:50:46 <lambdabot> [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(
07:50:46 <lambdabot> ),(),()]
07:50:53 <gour> dcoutts: ok, let me know when you'll have archives, if i can help something
07:50:59 <musasabi> > let if' a b c = if a then b else c in  (. ((. flip (flip . ap (ap . (if' .) . (/=)) (,)) (fail [])). (>>=))) . (>>=) $ [1,2,3]
07:51:00 <lambdabot> Couldn't match `(a, a)' against `[a1]'
07:51:00 <dcoutts> gour, ok ta.
07:51:10 <ihope> @type sequence
07:51:11 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
07:51:14 <musasabi> hmm, has some errors, but you get the point.
07:51:20 * vincenz nods
07:51:28 <ihope> > sequence [[1,2,3],[4,5,6],[7,8,9]]
07:51:30 <lambdabot> [[1,4,7],[1,4,8],[1,4,9],[1,5,7],[1,5,8],[1,5,9],[1,6,7],[1,6,8],[1,6,9],[
07:51:30 <lambdabot> 2,4,7],[2,4,8],[2,4,9],[2,5,7],[2,5,8],[2,5,9],[2,6,7],[2,6,8],[2,6,9],[3,
07:51:30 <lambdabot> 4,7],[3,4,8],[3,4,9],[3,5,7],[3,5,8],[3,5,9],[3,6,7],[3,6,8],[3,6,9]]
07:51:34 <vincenz> >  let if' a b c = if a then b else c in  (. ((. flip (flip . ap (ap . (if' .) . (/=)) (,)) (fail [])). (>>=))) . (>>=) $ [1,2,3] [1,2,3]
07:51:35 <lambdabot>   The function `[1, 2, 3]' is applied to one arguments,
07:51:35 <lambdabot>   but its type `[a]' has none
07:51:38 <ihope> Cough cough.
07:55:54 <lome> hi! is there a way to see implementation of a function with lambdabot?
07:55:57 <Cale> > (let if' a b c = if a then b else c in  (. ((. flip (flip . ap (ap . (if' .) . (/=)) (,)) (fail [])). (>>=))) . (>>=)) [1,2,3] [1,2,3]
07:55:58 <lambdabot> Couldn't match `(a, a)' against `[a1]'
07:56:06 <ihope> @info
07:56:07 <lambdabot> Unknown command, try @listcommands.
07:56:12 <ihope> I don't think so.
07:56:15 <Cale> @docs iterate
07:56:16 <lambdabot> iterate not available
07:56:20 <ihope> Oh
07:56:21 <Cale> @index iterate
07:56:22 <lambdabot> Data.List, Prelude
07:56:30 <Cale> @libsrc Prelude
07:56:31 <lambdabot> http://darcs.complete.org/fptools/libraries/base/Prelude.hs
07:56:42 <Cale> @libsrc Data.List
07:56:43 <lambdabot> http://darcs.complete.org/fptools/libraries/base/Data/List.hs
07:57:03 <lome> oh... libsrc only?
07:57:09 <lome> thx!
07:57:40 <Cale> lome: for the Prelude, you should probably just look in the Prelude in the report
07:57:41 <SamB> there isn't actually any code in Prelude, is there?
07:57:52 <Cale> http://www.haskell.org/onlinereport/standard-prelude.html
07:57:53 <ihope> ...Yes...
07:58:05 <SamB> hmm
07:58:24 <SamB> oh
07:58:34 <lome> oh! i know it, i just want to see it in the lambdabot window without switching between screens
07:58:36 <SamB> there is $!
07:59:06 <SamB> and there is a fake implementation for Haddock's benefit
07:59:22 <SamB> s// of seq/
07:59:52 <Cale> lome: well, you can get the types anyway, as you probably know
08:04:43 <lome> Cale: thx, yes i know
08:06:34 <vincenz> http://www.haskell.org/tutorial/monads.html
08:06:37 * vincenz isi slightly stuck
08:06:44 <dcoutts> @seen ndm
08:06:45 <lambdabot> I saw ndm leaving #haskell-overflow, #haskell-blah and #haskell 1 month,
08:06:45 <lambdabot> 22 hours, 11 minutes and 54 seconds ago, and I have missed 25 days, 6
08:06:45 <lambdabot> hours, 32 minutes and 19 seconds since then.
08:07:44 <tibbe> @seen Philippa
08:07:45 <lambdabot> Philippa is in #scannedinavian, #haskell-overflow, #haskell-blah and #
08:07:45 <lambdabot> haskell. I don't know when Philippa last spoke.
08:08:03 <dcoutts> juhp, you about?
08:08:27 <dcoutts> juhp, I was wondering how you went about setting up the fedora-haskell mailing list on haskell.org.
08:08:38 <dcoutts> juhp, who did you ask etc?
08:10:21 <vincenz> > numerator (3 % 6)
08:10:22 <lambdabot> 1
08:21:42 <beelsebob_> YAY for hat-delta
08:21:50 <beelsebob_> YAY for quickcheck too
08:22:43 <lispy> beelsebob_: hat-delta is ready?
08:23:17 <beelsebob_> lispy: it's in the cvs repo, it works, and it does many funky things... But it's a little slow
08:23:27 <beelsebob_> and it's still heavily research biased
08:24:27 <beelsebob_> I've just made it so it automagically recognises quickCheck testing, finds which tests passed and failed, and uses that info in the debug sesion
08:24:56 <vincenz> so remind me
08:24:58 <vincenz> after a gentle intro
08:25:00 <vincenz> what should I read
08:25:02 <vincenz> the prelude and
08:26:43 <Cale> vincenz: Yet another haskell tutorial (you should be able to go quickly, as you'll already be familiar with lots of it)
08:26:54 <Cale> There's lots of cool stuff on the wiki
08:27:49 <vincenz> thx
08:27:57 <vincenz> I do admit I had some problems with the monads section in "gentle
08:28:03 <vincenz> Cale: btw, what do you do
08:28:51 <Cale> what do I do? Well, not much at the moment. I've just finished an undergrad degree in pure mathematics.
08:29:21 <vincenz> ah
08:30:01 <Cale> I've done paid work in Haskell. I did summer research at a nearby university writing part of a compiler for a new high level language for image and signal processing in Haskell.
08:30:26 <vincenz> lol
08:30:27 <vincenz> I love it
08:30:41 <vincenz> on the 5th page of YAHT he offers ocaml as alternative
08:31:02 <vincenz> Cale: what sort of processing
08:32:08 <Cale> Well, the first application would be processing the output of fMRI machines
08:33:12 <Cale> resampling, fourier transform, differentiation, integration, that sort of thing :)
08:33:35 <gour> dcoutts: ping
08:33:40 <dcoutts> gour, yes?
08:33:55 <Cale> vincenz: I wrote a pipeline scheduler and register allocator which was quite fun :)
08:34:02 <gour> dcoutts: on haskell.org mailman is under /home/..
08:34:48 <vincenz> Cale: ooh
08:34:55 <vincenz> Cale: got a link?
08:35:20 <Cale> nope -- I'm not sure they've released anything yet.
08:35:31 <Cale> (pretty sure they haven't yet actually)
08:35:35 <vincenz> I meant the pipeline thing
08:35:45 <Cale> I know :)
08:35:48 <vincenz> ah
08:36:07 <vincenz> for what sort of arch?
08:36:13 <Cale> PPC/Altivec
08:36:35 <Cale> It was the G4, but it easily generalised to other systems
08:36:43 <Cale> (well, relatively speaking)
08:37:02 <vincenz> complex?
08:37:31 <Cale> hm?
08:37:36 <vincenz> well was it complex code
08:37:41 <Cale> fairly.
08:37:44 <vincenz> and YAHT is a seriously overnewbized book
08:37:46 <Cale> It came to 600 lines
08:37:54 <Cale> yeah, it is -- skim it though
08:38:14 <Cale> 600 lines of code and about the same in documentation
08:38:16 <dcoutts> gour, thanks
08:38:26 <Cale> That included a parser for an intermediate language
08:38:38 <vincenz> ini only 600 lines?
08:38:40 * vincenz whistles
08:38:48 <vincenz> how did it schedule
08:38:53 <vincenz> what's the idea bheind it
08:39:09 <vincenz> and I take register allocation was something like graph coloring
08:39:35 <Cale> yep
08:40:16 <Cale> Well, are you familiar with the trick of having multiple pieces of data live after a few warm up iterations to avoid unrolling loops?
08:40:17 <rep> is tail call optimization mandated by the haskell specification?
08:40:44 <Saulzar> Hmm, that withFile handles stuff on the mailing list is exactly like the C++ "RAII" idom
08:40:54 <vincenz> Cale: yeah
08:41:08 <vincenz> software pipelining
08:41:20 <Cale> vincenz: yeah
08:42:52 <Cale> The input was essentially machine code abstracted over the registers, so you had named results. You could define a result in multiple ways and it would try to determine which way was best.
08:43:12 <vincenz> ah
08:43:21 <vincenz> basically assembly with virtual registers
08:43:26 <Cale> yeah
08:43:31 <Cale> and nondeterminism :)
08:43:48 <vincenz> how did you do that bit?
08:44:15 <vincenz> divide it up into basic blocks and then say "they are not dependent on each other" so they can be parallel?
08:44:21 <Cale> It just works its way backwards through the dependencies and schedules them in all possible ways with the list monad, greedy first.
08:44:35 <vincenz> by basic block?
08:44:38 <Cale> vincenz: well, it's just a dependency graph
08:44:43 <vincenz> right
08:44:50 <vincenz> but a node is a basic block or a statement?
08:44:53 <Cale> plus nodes can optionally be computed in multiple ways
08:45:01 <Cale> a node is a machine instruction, basically
08:45:04 <vincenz> ah
08:45:09 <vincenz> how does that work with loops
08:45:15 <Speck> self-optimizing constraint solving?
08:45:30 <Cale> Well, this is just for scheduling loop bodies.
08:45:44 <Cale> Basically, for scheduling 'map f' for some f
08:45:46 <vincenz> @type (head . head)
08:45:47 <lambdabot> forall a. [[a]] -> a
08:46:01 <vincenz> Cale: oh... so you assume the loop index is not used?
08:46:01 <Cale> (and possibly certain folds)
08:46:12 <vincenz> ah k
08:46:25 <vincenz> so you didn't model it ini an imperative model?
08:46:30 <vincenz> at least not the loop bits
08:46:37 <Cale> nope, purely functional for the moment
08:46:42 <vincenz> hmm
08:46:44 <vincenz> interesting
08:47:47 <Cale> well, it's an easier problem that way
08:47:51 <vincenz> true
08:47:58 <vincenz> I'm considering a similar step
08:48:03 <vincenz> be interested to look at your model
08:48:20 <Cale> I suspect it would not be too hard to hook up some other kinds of loop mechanics
08:48:35 <Cale> anyway, this was quite a good example of the use of laziness
08:48:47 <Cale> the whole thing was a nondeterministic computation in the list monad
08:48:55 <vincenz> that's just an iteration...
08:48:59 <Cale> I basically didn't have to think about backtracking
08:49:06 <vincenz> hmm
08:49:15 <Cale> See, it's easy to schedule yourself into a corner
08:49:38 <Cale> But all I had to do in that case is return the empty list :)
08:49:46 <vincenz> hmm
08:49:49 <Saulzar> The problem is some kind of search?
08:49:52 <Cale> yeah
08:50:01 <vincenz> I still fail to see the exceptionality of that
08:50:03 <vincenz> I mean
08:50:12 <vincenz> for x elof solutionset
08:50:14 <vincenz>   if goodsolution
08:50:19 <vincenz>      finals.add(x)
08:50:44 <vincenz> or
08:50:48 <Cale> vincenz: you're iteratively adding instructions to your schedule, and backtracking if you can't add any
08:51:10 <vincenz> Cale: so what happens when you can't
08:51:13 <vincenz> you go all the way back up?
08:51:25 <Cale> you go up and try the next thing
08:51:27 <vincenz> and does this mean that you can also return something somewhere halfway
08:51:31 <vincenz> and that would be a final soliution?
08:51:47 <Cale> well, I picked finished solutions from the front of the list on each step
08:51:48 <vincenz> oh wait
08:52:08 <Cale> with takeWhile :)
08:52:19 <Cale> and continued processing the rest
08:52:20 <vincenz> Cale: you could also just do a foldr to find the best solution ;)
08:52:37 <Cale> well, there's trillions and trillions of possible schedules
08:52:42 <vincenz> oh
08:52:52 <Cale> the idea is to produce a list of all of them, in order of greediness
08:53:09 <vincenz> Cale: and greediness was easily defined?
08:53:13 <Cale> to take the head of that list is to run the greedy algorithm
08:53:29 <Cale> well, yeah, schedule as soon as possible
08:53:34 <vincenz> ah yeah
08:53:35 <vincenz> soorry
08:53:40 <vincenz> rather tired today
08:53:58 <Cale> so it's sort of neat, you end up treating data as control.
08:54:09 <vincenz> ...?
08:54:11 <vincenz> how
08:54:23 <lisppaste2> The extended lisppaste outage was caused by a server move this weekend. paste.lisp.org is now on a significantly faster server, and should be available as soon as your DNS catches up. Thanks for your patience!
08:54:59 <Cale> Well, it's a list, but you're using it to express a multilayered loop with all this backtracking going on
08:55:22 <Saulzar> Hmm, what kind of instructions? Assembler? 
08:55:26 <Cale> Saulzar: yes
08:55:41 <Cale> PowerPC/Altivec
08:55:59 <Saulzar> I dont quite understand, so you have a whole lot of different ways of producing code for certain constructs?
08:56:05 <Cale> yes
08:56:23 <Cale> you have a huge huge number of ways to order the instructions you give to the CPU
08:56:26 <Saulzar> What heuristic makes one "best" ?
08:56:36 <Cale> it uses the fewest cycles
08:56:53 <Cale> the CPU has a bunch of separate units which can be working on different instructions at once
08:56:59 <Saulzar> Hmm, so this is after it is combined and optimised down?
08:57:17 <Cale> well, lots of optimisation will happen at higher levels
08:57:48 <Cale> If an instruction comes along and a unit is busy, the CPU will have to hold on to it and wait until that unit is finished before running the given instruction.
08:58:00 * SamB wonders why there are two lisppaste bots
08:58:17 <Saulzar> I don't quite see how you'd find one had fewer cycles unless the different combinations of constructs interacted in some way...
08:58:31 <Saulzar> Ahh
08:58:32 <Cale> So the trick is getting the instructions in a good order to maximise use of different units in the processor.
08:58:32 <Saulzar> I see.
08:58:55 <Saulzar> Cool. :)
08:59:10 <Cale> yeah, it was a neat problem
08:59:36 <kpreid_> SamB: because freenode only allows 20 channels per connection
08:59:44 <Cale> we ended up with some code for computing sine/cosine pairs which ran at about 2.7 clocks/float
08:59:51 <SamB> on some x86 cpus, you may want to get them in a good order to maximise the number of registers you can actually use
09:00:33 <Cale> SamB: we actually had no problem eating all the G4's registers
09:00:53 <SamB> huh
09:01:00 <SamB> how many registers does a G4 have
09:01:02 <SamB> ?
09:01:17 <SamB> anyway, a lot of x86 cpus have more registers than names
09:01:33 <Cale> 32 vector registers anyway
09:02:08 <SamB> only 32?
09:02:17 <Cale> well, more if you include renames
09:02:24 <SamB> mmm.
09:02:58 <Cale> I can't recall how many other registers there were
09:07:23 <Cale> each of those 32 is 128 bits wide, I should mention
09:08:00 * tibbe thinks he must be really thick
09:09:10 <Cale> vincenz: anyway, I have some simplistic code for solving Sudoku puzzles which makes use of a similar technique if you're interested. The sudoku solver uses a special Nondet monad as I have it written, but you could swap it out for the list monad just by changing a newtype declaration
09:09:46 <SamB> tibbe: why? won't your jeans fit?
09:11:01 <Cale> http://vx.hn.org/autoshare/MonadicSudoku.tar.bz2
09:11:39 <Cale> solve = forM [(i,j) | i <- [1..9], j <- [1..9]] $ \(i,j) -> do
09:11:39 <Cale>     v <- valAt (i,j)
09:11:39 <Cale>     when (v == 0) $ do
09:11:39 <Cale>         a <- option [1..9]
09:11:39 <Cale>         place (i,j) a
09:11:42 <vincenz> thanx
09:11:43 <vincenz> re
09:12:09 <Philippa> tibbe: you were after me earlier?
09:12:26 <vincenz> I actually made a sudoku solver in ruby that did not try all possibilitiies
09:12:35 <vincenz> basically it iterated two steps recursively
09:12:44 <Cale> This is just the naive backtracking solution, but you don't even have to think about the backtracking because the monad takes care of it.
09:12:52 <vincenz> one step was to remove all possibilities no longer valid
09:13:19 <vincenz> the other was to check whether you had to force a certain possibility to one valuie cause no other in the row/column/square had a certaini possibiity
09:13:52 <bringert> dons: I've added a k-nucleotide shootout entry to the wiki (http://haskell.org/hawiki/KnucleotideEntry)
09:14:10 <bringert> I think that the current entry is cheating
09:15:59 <Cale> Knuth recommends the dancing links algorithm. I should really design a monad around that :)
09:16:18 <vincenz> ?
09:16:42 <Cale> http://en.wikipedia.org/wiki/Dancing_Links
09:16:43 * SamB imagines four green-clad guys dancing around in a circle
09:16:45 <integral> http://www-cs-faculty.stanford.edu/~knuth/papers/dancing-color.ps.gz; http://en.wikipedia.org/wiki/Dancing_Links
09:16:46 <Saulzar> Hmm, would there be a simple heuristic which would help such a brute force search?
09:17:49 <glasser> Dancing links works pretty well, though it's definitely all about the state
09:17:51 <Saulzar> Maybe pick the square which reduced possibilties in other squares the most, or pick squares with the least possibilities first
09:18:10 <Igloo> bringert: Why/how is it cheating, OOI?
09:18:36 <Cale> glasser: yeah, that's why I was thinking it would be nice for a monad to take care of that
09:18:38 <bringert> The benchmark description says: "count all the 3- 4- 6- 12- and 18-nucleotide sequences, and write the count and code for specific sequences"
09:18:59 <glasser> Saulzar:  so Knuth's algorithm basically does that all at once
09:19:00 <bringert> The current entry uses filter to count the occurences of the given nucleotide, but does not count all the other ones.
09:20:02 <glasser> it treats the constraints of "need an N in row X", "need an N in col Y", "need an N in square Z", and "need someting in square (x,y)" as isomorphic, and choosing the one with the fewest possibilities
09:20:21 <bringert> it also does not sort nucleotides by name, only frequency (this only changes the results if there are two nucleotides with the same frequency)
09:20:23 <tibbe> Philippa, yeah, couldn't really figure out it all by myself yesterday
09:20:32 <Saulzar> Hmm, cool... will take a look
09:20:40 <tibbe> SamB, :p
09:21:28 <tibbe> Philippa, the interpreter thingy
09:21:31 <Saulzar> I would like to see a Haskell chess program, unfortunately I don't think it's going to be as simple as Sudoku :)
09:21:51 <glasser> OK, MonadNondet is hurting my head
09:22:11 <Cale> glasser: you can ignore it and treat it like a fast version of the list monad
09:22:27 * glasser nods
09:22:40 <glasser> implemented in terms of function composition?
09:23:53 <vincenz> > enumFromTo 1 5
09:23:54 <lambdabot> [1,2,3,4,5]
09:23:56 <vincenz> > enumFromThenTo 1 5
09:23:57 <lambdabot>  add an instance declaration for (Show (a -> [a]))
09:24:00 <Cale> Basically, you can represent lists by foldrs
09:24:09 <SamB> > enumFromThenTo 1 3 5
09:24:11 <lambdabot> [1,3,5]
09:24:16 <vincenz> what does it mean
09:24:21 <vincenz> > enumFromThenTo 1 3 7
09:24:23 <lambdabot> [1,3,5,7]
09:24:26 <SamB> > [1,3..7]
09:24:28 <lambdabot> [1,3,5,7]
09:24:30 <Saulzar> Would there be any way around the traditional "transposition table" in Haskell? Usually chess programs store one absolutely massive hash table wich caches searches
09:24:37 <vincenz> > enumFromThenTo 1 4 7
09:24:39 <lambdabot> [1,4,7]
09:24:44 <vincenz> oh basically you specify a delta
09:25:02 <SamB> vincenz: its just the desugared form of [a,b..c]
09:25:25 <vincenz> SamB: you presume I knew that form
09:25:32 <SamB> vincenz: hehe
09:25:38 <gour> anyone familiar with the book Introduction to Algorithms by Cormen et al. ?
09:25:40 <SamB> but haven't you seen it in maths?
09:25:54 <glasser> gour: sure
09:26:15 <gour> ie. how does it compare with Knuth's?
09:26:55 <glasser> pretty different
09:27:09 <gour> glasser: in what sense?
09:27:44 <Trevion> Cormen et. al. is a decent reference.  It's decent as a text book as long as the prof. doesn't follow it slavishly.
09:27:53 <gour> glasser: which one(s) are better for haskell implementation?
09:28:05 <glasser> different algorithms covered
09:28:22 <glasser> Knuth is much more formal, ad invents his own crazy assembly instead of just using higherlevel pseudocode
09:28:25 <Trevion> Cormen, et. al. is very routed in an imperative approach.
09:28:34 <glasser> yeah, even Cormen doesn't follow it slavishly :)
09:28:41 <glasser> Trevion: arguably Knuth is even more
09:28:51 <gour> glasser: that's one thing which speaks against it
09:28:53 <glasser> (disclaimer: only read vol. 1 of Knuth, and not all of it)
09:29:06 <vincenz> knuth's boook really that interesting?
09:29:06 <cooz> SamB: I was reading backlog, g4 actually have 32 general purpose registers (32bit), 32 floating point register (64bit) and 32 vector registers (128bit) IIRC.
09:29:43 <musasabi> Has anyone got a monad for a make like application? (mainly I need some sort of State/Cont of dependencies to be handled and to jump around to get at the right ones)
09:30:02 <glasser> gour: well, as in "he adds extra topics and doesn't cover everything in it", but it's not like Knuth is exactly up to date with all of the cutting edge research
09:30:21 <gour> glasser: so you recommend cormen?
09:30:45 <musasabi> The trick is that the graph is dynamic with loading one node maybe adding new dependencies (which may need to be loaded before that node)
09:31:08 <glasser> i like it. maybe not the best for a functinoal language, but I'm not sure what is
09:31:55 <psnl> vincenz: reading them is a long term thing
09:33:35 <gour> what about Algorithms : A Functional Programming Approach
09:33:46 <gour> by Fethi A. Rabhi, Guy Lapalme
09:34:15 <gour> i need something best suited for fp (haskell)
09:35:29 <vincenz> > foldr (++) [] [1,2,3]
09:35:30 <lambdabot>  add an instance declaration for (Num [a])
09:35:30 <lambdabot>   In the list element: 3
09:35:38 <vincenz> > foldr (++) [] [[1,2,3][1,2,3]]
09:35:39 <lambdabot>   The function `[1, 2, 3]' is applied to one arguments,
09:35:39 <lambdabot>   but its type `[a]' has none
09:35:39 <lambdabot>   In the list element: [1, 2, 3] [1, 2, 3]
09:35:42 <vincenz> > foldr (++) [] [[1,2,3],[1,2,3]]
09:35:43 <lambdabot> [1,2,3,1,2,3]
09:35:46 <gour> however it's not a big volume (250p) in comparison with cormen's ~1200
09:37:04 <tromp_> > join [[1,2,3],[1,2,3]]
09:37:06 <lambdabot> [1,2,3,1,2,3]
09:37:42 <tromp_> [[1,2,3],[1,2,3]] >>= return
09:37:48 <tromp_> > [[1,2,3],[1,2,3]] >>= return
09:37:50 <lambdabot> [[1,2,3],[1,2,3]]
09:38:11 <vincenz> > ["tromp_", " tromps ", "trump"] >>= return
09:38:12 <lambdabot> ["tromp_"," tromps ","trump"]
09:38:17 <vincenz> > ["tromp_", " tromps ", "trump"] >>= return >>= return
09:38:18 <lambdabot> ["tromp_"," tromps ","trump"]
09:38:30 <Speck> > concatMap [[1,2,3],[1,2,3]]
09:38:31 <lambdabot> Couldn't match `a -> [b]' against `[a1]'
09:38:35 <vincenz> > concat  ["tromp_", " tromps ", "trump"]
09:38:36 <tromp_> what i meant was
09:38:37 <lambdabot> "tromp_ tromps trump"
09:38:42 <tromp_> [[1,2,3],[1,2,3]] >>= id
09:38:54 <vincenz> > ["tromp_", " tromps ", "trump"] >>= id
09:38:55 <lambdabot> "tromp_ tromps trump"
09:39:03 <tromp_> > [[1,2,3],[1,2,3]] >>= id
09:39:05 <lambdabot> [1,2,3,1,2,3]
09:39:10 <Speck> fancy
09:39:12 <tromp_> that's the same as join
09:42:54 <beelsebob_> YAY!
09:43:09 <beelsebob_> hat-delta will tell you when your test is buggy and when your code is buggy, and exactly which bit of it is :)
09:43:32 <beelsebob_> I've not managed to get it to ask more than 2 questions while it's in quickcheck mode
09:44:11 <xerox> @type (>>= return)
09:44:13 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m a
09:44:39 <xerox> @type (Control.Monad.join)
09:44:40 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
09:44:44 <vincenz> @type (>>= id)
09:44:45 <lambdabot> forall (m :: * -> *) b. (Monad m) => m (m b) -> m b
09:45:06 <xerox> @type (Control.Monad.Fix.fix . return)
09:45:08 <lambdabot> forall a. (Monad ((->) a)) => a -> a
09:45:56 <palomer> that's a weird type
09:47:49 <vincenz> what does that mean
09:48:13 <vincenz> iti constructs a monad?
09:48:17 <xerox> vincenz: it's the monad instance for ((->) a), i.e. Reader.
09:48:19 <vincenz> @type Control.Monad.Fix.fix
09:48:20 <lambdabot> forall a. (a -> a) -> a
09:48:39 <vincenz> (fix . return) == id
09:48:42 <xerox> Yes.
09:48:48 <vincenz> so what's special about it
09:49:11 <vincenz> what is ((->) a)?
09:49:25 <xerox> Environment/Reader ?
09:49:29 <vincenz> ...?
09:49:34 <vincenz> any function taking a?
09:49:56 <vincenz> xerox: don't talk to me in haskell lingo, I don't know it yet
09:50:01 * vincenz is trying to learn
09:50:03 <xerox> @type (+) :: (Num a) => ((->) a) a
09:50:05 <lambdabot>   Expecting a function type, but found `a'
09:50:05 <lambdabot>   Expected type: a -> a
09:50:24 <xerox> @type (+1) :: (Num a) => ((->) a)
09:50:25 <lambdabot>   `(->) a' is not applied to enough type arguments
09:50:25 <lambdabot>   Expected kind `*', but `(->) a' has kind `? -> *'
09:50:28 <xerox> Hm.
09:51:01 <xerox> Ah-uhm!
09:51:16 <xerox> ((->) a) = (a ->) :: ? -> *
09:51:47 <xerox> @type (+1) :: ((->) Int) Int
09:51:49 <lambdabot> ((->) Int) Int :: Int -> Int
09:52:48 <vincenz> forall a. (Monad ((->) a)) => a -> a
09:52:57 <vincenz> any type that can be passed to a monad that accepts that type
09:53:10 <vincenz> correct?
09:53:20 <xerox> ...and we have a Monad ((->) a) instance, yeah.
09:54:12 <vincenz> and Moand ((->) a) is basically any monad of a function a -> something
09:54:35 <xerox> Yes, the 'a' is like an environment.
09:55:26 <vincenz> you mean the key into an environment
09:55:44 <xerox> 'The type of the value of the environment', okay?
09:55:55 <vincenz> no
09:55:58 <vincenz> (->) a
09:56:00 <vincenz> it takes an 
09:56:02 <vincenz> a
09:56:04 <vincenz> doesn't return one
09:56:19 <xerox> ((->) a) isn't a complete type
09:56:23 <vincenz> yes
09:56:26 <vincenz> its' a-> something
09:56:28 <xerox> It's parametrical on the return value
09:56:29 <vincenz> whatever is passed after
09:56:32 <vincenz> so a is the key
09:56:37 <xerox> 'key' ?
09:56:44 <vincenz> (->) a b = a -> b
09:56:50 <xerox> @type (Control.Monad.Reader.runReader)
09:56:51 <vincenz> hence it's the input, not output
09:56:52 <lambdabot> forall r a. Control.Monad.Reader.Reader r a -> r -> a
09:57:04 <xerox> vincenz: Yes, it's the input, that's why I called it 'environment'.
09:57:13 <vincenz> I would call it the key into that environment...
09:57:56 <vincenz> it's not the same as reader
09:58:09 <vincenz> thats Monad a -> (-> r)
09:58:10 <xerox> It is.
09:58:20 <vincenz> i disagree :)
09:58:44 <vincenz> (Monad ((->) a))
09:58:46 <vincenz> not
09:58:53 <vincenz> (Monad r a -> ((->) r)0
09:58:58 <vincenz> s/0/)
10:00:38 * vincenz detaches and leaves for home
10:00:38 <vincenz> later
10:02:30 <xerox> Mumble.
10:45:18 <SamB> @pl sequence . replicate
10:45:19 <lambdabot> sequence . replicate
10:47:50 <SamB> @type mapM
10:47:52 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
10:49:12 <newsham> I'm having some problems with syntax.  What is wrong with the following:
10:49:19 <newsham>  > data ByteContainerSlice = Slice (ByteContainer Int)
10:49:22 <newsham>  > instance ByteContainer (ByteContainerSlice b n) where
10:49:25 <newsham> >       getByteAt (ByteContainerSlice b n') n = getByteAt b (n+n')
10:49:27 <lambdabot>  parse error on input `='
10:49:44 <newsham> the last line gives me an error that "ByteContainerSlice" is not in scope
10:50:08 <astrolabe> parentheses on first line?
10:50:38 <newsham> fixed that, same error.
10:50:43 <newsham> Pkts5.lhs:21:18: Not in scope: data constructor `ByteContainerSlice'
10:50:57 <newsham> oh!  I'm dumb
10:51:06 <astrolabe> me too!
10:51:07 <SamB> newsham: well, that isn't a data constructor
10:51:11 <newsham> samb++
10:53:38 <newsham> ok, my type constructor is still bogus.
10:53:51 <newsham> data Slice = Slice ByteContainer Int.        where ByteContainer is a class.
10:54:05 <newsham> how do I declare that a slice contains any ByteContainer and an Int?
10:54:44 <SamB> newsham: I would tell you that the right command is @karma+, but my @karma is already so high...
10:55:59 <astrolabe> Something like ByteContainer a => data Slice = Slice a Int?
10:56:04 <Philippa> SamB: ...that it wrapped round?
10:56:16 <newsham> I tried: > data Slice = (ByteContainer b) => Slice (ByteContainer b) Int
10:56:25 <newsham> that didnt seem to work.  also just "Slice b Int"
10:57:59 <newsham> also (ByteContainer b) => data Slice = Slice b Int    doesnt work
10:58:13 <astrolabe> data ByteConstainer b => ...
10:58:48 <newsham> data (ByteContainer b) => Slice = Slice (ByteContainer b) Int
10:58:52 <newsham> Pkts5.lhs:19:21: Not in scope: type variable `b'
10:58:58 <newsham> (also with just "Slice b Int")
10:59:21 <dcoutts> So I was going on about linking haddock documentation to a wiki the other day. Well I've patched Haddock with the feature. Here's an example:
10:59:21 <dcoutts> http://haskell.org/gtk2hs/docs/devel/Graphics-Rendering-Cairo-SVG.html
10:59:38 <dcoutts> xerox, gour, what do you think?
10:59:52 <astrolabe> data (ByteContainer b) => Slice b = Slice (ByteContainer b) Int
11:01:38 <newsham> astro: thank you.  that makes sense I guess.
11:08:07 <newsham> ok, I'm finally somewhat happy with this:  http://www.lava.net/~newsham/x/Pkts5.lhs.txt
11:15:33 <gour> dcoutts: what is the link?
11:16:53 <gour> dcoutts: to the wiki?
11:17:29 <dcoutts> http://haskell.org/gtk2hs/docs/devel/Graphics-Rendering-Cairo-SVG.html
11:17:38 <dcoutts> gour, it's on that page. See?
11:17:59 <dcoutts> each haddock html page links to a corresponding wiki page
11:18:07 <dcoutts> one per module
11:18:38 <gour> ahh now, i get it. was in the different mode :-(
11:19:15 <dcoutts> so the idea is that people could add their own notes to the wiki page for any module
11:19:22 <dcoutts> like code snippets etc
11:19:38 <dcoutts> or more details, whatever
11:20:08 <gour> dcoutts: sorry, have to go out. bbl
11:20:12 <dcoutts> ok
11:20:25 <xerox> dcoutts: cool!
11:20:40 * dcoutts grins
11:26:00 <Lokadin> pang
11:58:43 <pesco> Booh, I'm such an idiot! I forgot that GHC runs without optimizations by default. :-O *headpound*
11:59:08 <jlenor1_> goody, the lag isn't too bad
11:59:21 <palomer_> god I hate these keyboards
11:59:29 * palomer_ slaps palomer
12:00:25 <palomer_> @hoogle state
12:00:27 <lambdabot> Test.HUnit.Base.State :: State
12:00:27 <lambdabot> Test.HUnit.Base.State :: Path -> Counts -> State
12:00:27 <lambdabot> Control.Monad.State.State :: State s a
12:01:43 <palomer_> @hoogle StateMonad
12:01:44 <lambdabot> No matches found
12:01:51 <palomer_> @hoogle MonadState
12:01:52 <lambdabot> Control.Monad.State.MonadState :: Monad m => MonadState s m
12:06:06 <palomer_> haskell mode should come standard with emacs
12:07:20 <KirinDave> Could someone point me to an introduction to monads? I have run into a lot of haskell intros that aren't too dense, but they just brush off monads.
12:07:45 <KirinDave> Something like "A C programmer's introduction to haskell", but for monads and how to make use of them?
12:08:07 <ncalexan> http://www.nomaware.com/monads/html/
12:08:18 <palomer_> cale has a pretty decent tutorial
12:08:22 <palomer_> monads as containers
12:08:22 <ithika> KirinDave: I have the same problem, but I don't know if there is a single good reference
12:08:23 <neologism> http://www.nomaware.com/monads/html/
12:08:40 <KirinDave> Okay. I'll check it out, thanks.
12:08:57 <ithika> Try reading all the tutorials and piecing them together in your head :-)
12:11:23 <Cale> @wiki MonadsAsContainers
12:11:24 <lambdabot> http://www.haskell.org/hawiki/MonadsAsContainers
12:12:17 <neologism> the nomaware one is great I think
12:12:32 <Cale> it is pretty good
12:13:04 <palomer_> hrm
12:13:14 <palomer_> I wish it was possible to ask ghc the type of a toplevel binding
12:13:20 <KirinDave> Lately I've been running into problems where speed and clarity on simple ops are a benefit, and I don't really need any dynamic-type craziness.
12:13:23 <Cale> :t whatever
12:13:27 <palomer_> in ghc?
12:13:29 <Cale> palomer: ^^ like that
12:13:32 <Cale> yeah
12:13:33 <KirinDave> So I'm hoping Haskell can fill that gap over what I'm currently using.
12:13:33 <Cale> ghci
12:13:34 <palomer_> not ghci
12:13:36 <palomer_> :o
12:13:39 <Cale> not ghci?
12:13:47 <palomer_> nope
12:14:31 <Philippa> now there's a nick that looks like a bot
12:14:55 <ithika> Philippa: Or there's a cat fallen asleep on a keyboard
12:17:28 <Philippa> ithika: unlikely
12:17:36 <Philippa> I mean, it'd have to manage the /join afterwards
12:18:13 <ithika> don't cats have scripts for that kind of thing?
12:18:29 <ithika> I've never met a cat that would knowingly do work
12:27:27 <JKnecht> f5n2r1l: are you human?
12:31:50 <pesco> Anybody here on powerpc-linux?
12:49:37 <dcoutts> pesco, Gentoo has some ppc support for Haskell. What's the question exactly?
12:52:24 * palomer_ doesn't like the state monad terminology
12:52:34 <palomer_> State should be called StateTransition
12:52:36 <gour> dcoutts: hi, i'm back. chatted before with some friend and could not see wiki link at the top
12:52:51 <palomer_> and runState should be called getStateTransition
12:53:18 <Philippa> "State" accurately describes the new semantics though
12:53:31 <Philippa> there couldn't be a State monad in the sense you're describing
12:53:42 <palomer_> why not?
12:54:06 <pesco> dcoutts: Oh, I had a problem with profiling, but then I noticed I still have ghc 6.4, so it will likely go away with 6.4.1
12:54:08 <Philippa> because you'd just get single values tagging along and doing buggerall
12:54:35 <dcoutts> gour, do you see it now?
12:54:53 <Philippa> it's not a state unless there's means to change it
12:54:54 <dcoutts> pesco, good idea
12:54:58 <palomer_> I don't calla function (s -> (a,s)) a state
12:55:17 <gour> dcoutts: yep, it is nice
12:55:24 <dcoutts> :-)
12:55:35 <araujo> dcoutts, heya! , got a sec for a question about c2hs?
12:55:37 <dcoutts> I've sent the patch to JaffaCake
12:55:40 <dcoutts> araujo, sure
12:55:42 <gour> dcoutts: i was looking for a link in the text, lookin' in the morning at http://projects.edgewall.com/trac/wiki/InterWiki
12:55:43 <Philippa> sure. But it does form the basis of a language which features state
12:55:59 <araujo> dcoutts, well, it's more that im trying to figure out what an example does....
12:56:02 <araujo> sin :: Float -> Float
12:56:02 <araujo> sin  = {#call pure sin as "_sin"#}
12:56:14 <sieni> nice disclaimer: http://en.wikipedia.org/wiki/Monads_in_functional_programming
12:56:22 <gour> dcoutts: however, i still think would be nice to have more structure in wiki pages...
12:56:35 <Philippa> once you stop looking at 'found' monads like List and Maybe, the only really sensible naming scheme is 'what features do I get?'
12:56:36 <dcoutts> gour, what do you mean?
12:56:37 <Philippa> (hence IO)
12:56:53 <Philippa> it's got nothing to do with the type inside the black box
12:57:01 <araujo> dcoutts, That's assgining the sin C function , to sin?
12:57:19 <dcoutts> araujo, I've never used "as" in a {# call #} hook. It's very rare I'd say.
12:57:34 <araujo> dcoutts, that's the part i don't get :-/
12:57:36 <dcoutts> araujo, but yes
12:57:39 <gour> dcoutts: some kind of toc, sections, subsections...more like a tutorial, book
12:57:46 <dcoutts> sin  = {#call pure sin #}
12:57:50 <dcoutts> would be the normal
12:57:58 <araujo> Right.
12:57:59 <palomer_> Philippa, I don't understand your argument
12:58:11 <araujo> dcoutts, And.. whatexactly woulkd do the 'as' there?
12:58:22 <dcoutts> araujo, I bet you'll never need "as" in a {# call #} hook. I've never seen it before.
12:58:44 <vincenz> re
12:59:50 <vincenz> hello Philippa !
12:59:50 <araujo> dcoutts, Ok
12:59:50 <vincenz> anyone use synergy by any chance
12:59:50 * araujo doesn't get it at all.....
12:59:50 <palomer_> Philippa, how could an element of s -> (a,s) represent a state?
12:59:50 <palomer_> (btw, I prefer Option over Maybe)
13:00:05 <dcoutts> araujo, ah from looking at the manual...
13:00:16 <dcoutts> http://www.cse.unsw.edu.au/~chak/haskell/c2hs/docu/c2hs-2.html#ss2.6
13:00:18 <monochrom> type Option a = Maybe a -- hehe
13:00:27 <araujo> dcoutts, It looks like the haskell id for the function would be renamed to "_sin" ?!?
13:00:29 <Philippa> palomer: it doesn't. It represents a program in a language that has state
13:00:50 <monochrom> s->(a,s) is a state transformer with a "return value"
13:00:50 <dcoutts> araujo, it says that the "as" allows you to give a different name to the imported function. However that name is almost never important.
13:00:57 <vincenz> Philippa: hello :)
13:01:00 <Cale> palomer_: it's not a state, it's a value whose computation may be dependent on, and may alter some state of type s
13:01:04 <Philippa> vincenz: boo
13:01:15 <araujo> dcoutts, ooh.. i se i see
13:01:29 <dcoutts> araujo, because the C function is called "sin" and so the foreign import decl would also be called sin
13:01:32 <araujo> dcoutts, Right, because i am binding to a variable name anyway right?
13:01:43 <dcoutts> araujo, but that'd clash with the function we're defining
13:01:52 <palomer_> so values of State are "mutators"
13:01:55 <vincenz> I must say YAHT introduces monads slightly better than gentle
13:02:08 <dcoutts> araujo, I've never had function name clashes like that so I've never used "call as"
13:02:25 <araujo> dcoutts, oh, i see... so, in that precise case, we do need 'as' right?
13:02:32 <dcoutts> araujo, right
13:02:45 <dcoutts> araujo, eg all the gtk stuff is like: gtk_foo_bar and so I call the bound func Gtk.fooBar
13:03:00 <araujo> dcoutts, i see
13:03:02 <dcoutts> araujo, so there is no name clash and so no need for "call as"
13:03:15 <Philippa> palomer: yes, but mutator'd be a bad name for the monad
13:03:18 <monochrom> This is analogous to c++ of C++: (\c -> (c, c+1)) :: \Int -> (Int, Int)
13:03:27 <palomer_> YAHT's introduction to Monads isn't half bad
13:03:35 <palomer_> though the best way to introduce monads is with continuations!
13:03:40 <Philippa> nope
13:03:43 <dcoutts> araujo, take a look at the .hs file that c2hs generates from your .chs file. It's quite interesting to see what it does. It'll help your understanding of what's going on.
13:03:43 <Philippa> I have a better one :-)
13:04:04 <araujo> dcoutts, ok, i think i understand a bit more....
13:04:14 <monochrom> The best way to introduce monads is to find out what the reader already knows and likes, then extend it to a monad.
13:04:36 <monochrom> In fact, the best way to introduce ___s is to find out what the reader already knows and likes, then extend it to a ___.
13:05:05 <monochrom> This requires a crystal ball or a dictatorship.
13:05:05 * palomer_ is still trying to wrap his head around MonadState
13:05:39 <Philippa> it's just a typeclass that represents the features provided by State, no?
13:06:24 <araujo> dcoutts, i think i'll better avoid clash names :-]
13:06:25 <monochrom> What you need is a general learning algorithm.
13:06:45 <dcoutts> araujo, yeah, it's usually not a problem.
13:07:07 <Heffalump> IO and ST aren't members of MonadState, are they?
13:07:17 <araujo> Ok, Thanks dcoutts 
13:07:24 <dcoutts> araujo, np
13:07:27 <Cale> palomer: the idea is that you have this monad transformer StateT, as well as the plain State monad, and any other monad which might be constructed using StateT, and they all have get and put operations, and you want to standardise that interface and make it derivable when possible
13:07:40 <Cale> Heffalump: right, they aren't
13:07:47 <vincenz> what's a monad transformer?
13:08:06 <palomer_> Cale, I meant, really ,wrap my head around using State
13:08:42 <SamB> palomer: there isn't much to it
13:09:09 <monochrom> I think you just need time and experimentation.
13:09:36 <palomer_> I know how to use it
13:09:41 <palomer_> but I don't see how it works!
13:09:57 <Cale> vincenz: If m is a monad, (StateT s m) is a monad which is like m but in addition to the features m has, it also threads a state of type s through the computation.
13:10:13 <Philippa> palomer: I think I can show you something...
13:10:19 <Philippa> can you read types involving GADTs OK?
13:10:26 <Philippa> (simple ones, no foralls or class constraints or anything)
13:10:35 <Cale> (which one can access via 'get' and 'put')
13:10:38 <SamB> palomer: it just passes state around
13:10:40 <palomer_> Philippa, yes
13:10:48 <vincenz> Cale: ah thx :)
13:10:50 <palomer_> but State isn't state!
13:10:54 <Philippa> right, I'll drag up the code I've got
13:10:57 <SamB> @type Control.Monad.State.State
13:10:58 <lambdabot> forall a s. (s -> (a, s)) -> Control.Monad.State.State s a
13:11:38 <SamB> palomer: no, it is record newtype of a function
13:13:07 <palomer_> but it doesn't represent state!
13:13:33 <Philippa> but it does represent functions that have stateful semantics
13:13:36 <monochrom> Heh, State isn't state, Nothing isn't nothing, fail doesn't fail.  What's new?
13:13:47 <araujo> dcoutts, ok, so, i also can see that 'as' got kind of a different meaning in 'func'
13:14:25 <araujo> dcoutts, That's actually the name of the haskell function right?
13:15:34 <dcoutts> araujo, right
13:15:56 <dcoutts> araujo, so you can either use {# call ... #} or {# func ... #}
13:16:18 <dcoutts> araujo, the func version is a bit higher level since it includes parameter marshaling
13:16:41 <dcoutts> araujo, I always use call however since I often need non-trivial marshaling
13:17:10 <dcoutts> araujo, take a look at a random Gtk2Hs .chs module for an example
13:17:42 * palomer_ wishes haskell would show all the reductions when using MonadState
13:18:06 <Philippa> palomer: build big function. Pass initial state into function. Start reducing.
13:18:11 <Philippa> give or take
13:18:16 <araujo> dcoutts, Goodie.
13:18:22 <araujo> dcoutts, Thanks!
13:18:24 <Philippa> in practice, you don't really want to see the reduction order for most haskell code because it'll fuck with your mind
13:18:47 <Philippa> for example, when I say "build big function", it won't be actually /evaluated/ again until after that state's passed in
13:19:05 <monochrom> Are you looking for an example?
13:19:44 <SamB> its like algebra
13:19:44 <SamB> you don't set breakpoints in algebra, do you?
13:19:57 <SamB> or try to trace reductions?
13:20:19 * Saulzar tries to trace blatant errors
13:20:35 <monochrom> We do trace reductions in algebraic calculations.  It's for beginners.
13:20:39 <Philippa> palomer: you taking a look at the stuff I PMed you?
13:20:55 <palomer_> SamB, tracing reductions is often what's done in high school
13:20:57 <Philippa> you might find that illuminating
13:20:59 <vincenz> wow
13:21:10 <vincenz> statemonads are EXACTLY like the foldmap I invented for extlib List
13:21:11 <palomer_> Philippa, don't you need to understand what I'm trying to understand to understand your stuff?
13:21:13 <vincenz> (ocaml)
13:21:40 <Philippa> palomer: possibly. Have you at least looked at the page?
13:21:48 <Philippa> I can happily answer questions
13:21:58 <SamB> palomer: well, there is HAT
13:22:37 <Philippa> you'll probably find my first implementation on that page easier to trace mentally
13:22:58 <SamB> palomer: and that thing with the boxes and lines...
13:23:16 <Philippa> then because I derive the 'normal' implementation from it, you can derive the normal version's trace from my first implementation's trace, if that makes sense
13:23:17 <palomer_> Philippa, what does AST represent?
13:23:29 <Philippa> it's an Abstract Syntax Tree for a language
13:23:42 <Philippa> much like this is an AST for the untyped lambda calculus:
13:23:48 <palomer_> right, but my ASTs don't have Return, Bind, Put and Get
13:23:58 <palomer_> my ASTs are binary trees
13:24:17 <araujo> dcoutts, I see you use only call :-)
13:24:22 <vincenz> one question about monads... I'm studying the YAHT, and it shows an implementation for mapTreeM but that's a left to right, what if you wanted another sort of walk
13:24:29 <Philippa> yeah? They are for the lambda calculus I guess, but they're not in general
13:24:41 <dcoutts> araujo, actually when Gtk2Hs was started c2hs only supported {# call ... #}
13:24:56 <araujo> Oh, i see
13:25:09 <dcoutts> araujo, but it's still more felxable. On the other hand the cairo bindings use {# func ... #} exclusively.
13:25:10 <Philippa> at least, not unless you're using a binary tree as an underlying representation of a heterogenous tree where different node types have different numbers of parameters...
13:25:15 <araujo> dcoutts, so, func is kind of an extension to call?
13:25:32 <palomer_> Philippa, ok, n-ary trees then
13:25:55 <dcoutts> araujo, sort of. It adds marshaling.
13:25:56 <Philippa> yeah. If you look at the type, my AST's an n-ary tree too. It's just that Get, Put and Return are all leaf-only nodes
13:26:15 <Philippa> Bind provides the branches, it's just that the branch is a bit odd
13:27:15 <vincenz> let cross l1 l2 = do { x <- l1; y <- l2; return (x,y) in cross (Just 1) None
13:27:19 <vincenz> > let cross l1 l2 = do { x <- l1; y <- l2; return (x,y) in cross (Just 1) None
13:27:20 <lambdabot>  parse error on input `in'
13:27:25 <vincenz> > let cross l1 l2 = do { x <- l1; y <- l2; return (x,y)} in cross (Just 1) None
13:27:26 <Philippa> (that is, the RHS takes a function returning a tree node rather than an ordinary tree node)
13:27:26 <lambdabot>  Not in scope: data constructor `None'
13:27:44 <monochrom> use Nothing
13:27:48 <vincenz> > let cross l1 l2 = do { x <- l1; y <- l2; return (x,y)} in cross (Just 1) Nothing
13:27:49 <lambdabot> Add a type signature
13:27:53 <vincenz> > let cross l1 l2 = do { x <- l1; y <- l2; return (x,y)} in cross (Just 1.0) Nothing
13:27:54 <lambdabot> Add a type signature
13:27:59 <vincenz> > let cross l1 l2 = do { x <- l1; y <- l2; return (x,y)} in cross (Just 'a') Nothing
13:28:00 <lambdabot> Add a type signature
13:28:06 <SamB> Philippa: what is the document under discussion?
13:28:16 <Philippa> SamB: a WIP version of an article I'm writing
13:28:18 <vincenz> > let cross l1 l2 = do { x <- l1; y <- l2; return (x,y)} in cross (Just 'a') (Nothing:: Maybe Char)
13:28:19 <lambdabot> Nothing
13:28:22 <Philippa> http://www.haskell.org/tmrwiki/PhilippaCowderoy_2fWIP_2fMonadArticleThingy
13:29:09 <Philippa> palomer: if you're concerned that the AST "cheats" by using the metalanguage as part of the object language, you're right, it does. That's because the metalanguage /is/ part of the object language
13:29:33 <palomer_> Philippa, nonono, I don't see how this AST relates to any other ASTs I've seen
13:29:50 <palomer_> for example, what do the type parameters represent?
13:29:50 <Philippa> palomer: why not?
13:30:05 <palomer_> I've yet to see a parametrized AST
13:30:10 <Philippa> constraints on the terms that're valid there
13:30:26 <Philippa> it's not an uncommon trick now we've got GADTs, you can use it to ensure all terms're well-typed
13:31:02 <vincenz> question about monads...why does searchAll in YAHT chapter 9 not return all possibilities
13:31:09 <Philippa> for example, the language in question can work for any kind of state, but you can't construct a valid program that mixes state types
13:31:26 <Philippa> (if you like, there's an entire family of languages parameterised by state)
13:31:49 <palomer_> Philippa, if Get is a leaf, why is it an AST?
13:31:49 <vincenz> nm
13:32:05 <Philippa> palomer: because it's a valid part of the AST and it's syntactically important that it's a Get
13:32:28 <Philippa> Var is a leaf in the usual AST for the lambda calculus
13:32:38 <Philippa> (give or take the identifier in question)
13:33:02 <palomer_> so Var == Get ?
13:33:08 <Philippa> 'leaf' just says it doesn't have child nodes in the AST
13:33:16 <dfhaii> psnl: are you about?
13:33:32 <Philippa> no. They both carry information still - they just don't have child expressions
13:34:01 <Philippa> and that information is different - Var carries an identifier, Get carries a value of type state
13:34:48 <palomer_> ok, so the first parameter represents the type of the AST, right?
13:34:53 <SamB> s/(when Get is fully applied/(when Put is fully applied
13:35:21 <Philippa> SamB: yeah
13:35:37 <Philippa> palomer: the first parameter of what?
13:35:57 <palomer_> Philippa, of AST
13:36:05 <palomer_> the first type parameter (called state)
13:36:15 <monochrom> An example tree would be "Bind (Put r) (Bind Get Return)" (for a suitable r), right?
13:36:24 <Philippa> the first parameter represents the type of the state manipulated by the program the AST describes
13:36:30 <Philippa> monochrom: yup
13:37:03 <Philippa> wait, you missed a \_ ->
13:37:05 <Philippa> but yeah
13:37:16 <monochrom> iiiiieeeee....
13:37:26 <Philippa> Bind (Bind Get Return) (Put r)?
13:37:45 <Philippa> you intend to Get, Return the value and then finally Put?
13:37:53 <Philippa> Bind (Bind Get Return) (Put), then
13:38:23 <Philippa> Bind is just an ordinary function for (>>=), if that helps
13:38:28 <Philippa> go write ordinary monadic code ;-)
13:38:45 <monochrom> Hard to write any code in prefix notation.
13:38:56 <Philippa> palomer: "the type of the AST" doesn't make sense to me, except insofar as it's AST foo bar
13:39:21 <Philippa> monochrom: yeah. I use `these` when I give examples
13:39:32 <monochrom> hohoho
13:43:12 <palomer_> type of the expressions which are represented by the AST
13:44:38 <Philippa> ah. result's the return type of those expressions
13:44:51 <Philippa> (and so yes, the type of them I guess)
13:45:10 <Philippa> result's the second parm. In the case of Get, result = state
13:46:01 <monochrom> Bind (Bind Get Return) (Put) :: AST state ().  "state" is still a type variable.
13:46:13 <Philippa> yup
13:46:37 <Philippa> standard polymorphism - that's a valid program regardless of the state type you put through it, so why not?
13:47:43 <Philippa> (the Put happens last, and is the result type that gets propagated outwards - the type of Bind is mildly horrible if you're only used to Haskell98)
13:48:04 <SamB> @type Control.Monad.State.get >>= return >>= Control.Monad.State.put
13:48:06 <lambdabot> forall s (m :: * -> *).
13:48:06 <lambdabot> (Control.Monad.State.MonadState s m) =>
13:48:06 <lambdabot> m ()
13:51:15 <Philippa> palomer: the AST making sense now?
13:51:31 <ihope> > let l = \a b c d e f g h i j k l m n o p q s t u v w x y z r -> r (t h i s i s a f i x e d p o i n t c o m b i n a t o r) in l l l l l l l l l l l l l l l l l l l l l l l l l l l l
13:51:32 <lambdabot>   Occurs check: cannot construct the infinite type:
13:51:32 <lambdabot>   t
13:51:32 <lambdabot>   =
13:51:44 * vincenz smacks ihope 
13:51:53 <vincenz> ihope: stop spamming poor lambdagirl
13:51:53 <Philippa> ihope: looks more like fuxed point to me
13:52:00 * vincenz *laughs*
13:52:01 <ihope> :-P
13:52:07 <Nanar> I need a hint
13:52:23 <Philippa> Nanar: sure. Try telling people what you need a hint about
13:52:29 <Philippa> (oh okay, I might give you a second if you're lucky)
13:52:33 <SamB> ihope: neato
13:52:38 <ihope> :-)
13:52:39 <Nanar> Philippa: thanks
13:52:43 <Nanar> :)
13:52:56 <Nanar> I read a file, it describe package
13:53:10 <Nanar> I don't how many line describe it
13:53:34 <Nanar> I know begining of line is a type of information
13:53:35 <ihope> @type \x x -> x
13:53:37 <lambdabot>   Conflicting definitions for `x'
13:53:37 <lambdabot>   In a lambda abstraction
13:53:57 <Philippa> ihope: no non-linear patterns
13:54:01 <Nanar> last line for each package begin by @info@
13:54:04 <SamB> @type \x -> x x
13:54:06 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
13:54:06 <lambdabot>   Expected type: t
13:54:25 <ihope> > @
13:54:26 <Nanar> what is the better in haskell to parse this kind of file
13:54:26 <lambdabot>  parse error on input `@'
13:54:55 <TheHunter> @type \(x :: forall a. a) -> x x
13:54:56 <lambdabot> forall t. (forall a. a) -> t
13:54:58 <Nanar> aka read 1, 2, found @info@ => building one entry in memory
13:56:06 <Nanar> hum
13:56:36 <Nanar> I am thinking, a function grouping line by array after each @info@...
13:57:20 <SamB> Nanar: looked at Parsec?
13:57:34 <Nanar> SamB: no
13:57:56 <Nanar> SamB: notice I am really begining haskell :)
14:02:55 <vincenz> @type mapM_ print []
14:02:56 <lambdabot> IO ()
14:02:59 <vincenz> @type mapM print []
14:03:00 <lambdabot> IO [()]
14:04:50 <ihope> @type elem
14:04:51 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
14:04:57 <vincenz> what's "i"
14:04:59 <vincenz> what's "it"
14:05:15 <ihope> @type mapM
14:05:17 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
14:05:36 <Cale> vincenz: ghci binds the last value computed to 'it', if that's what you mean
14:06:22 <ihope> @type mapM_
14:06:23 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> [a] -> m ()
14:06:44 <vincenz> Cale: thx
14:06:46 <ihope> @type (>> return ())
14:06:48 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
14:07:17 <ihope> A bad name: "Thimbledrahonknockeroozchschnooglecheese"
14:11:41 <jonkri> i had my first haskell lesson today
14:11:55 <monochrom> As long as it's cheese, I'm fine with it!
14:12:09 <monochrom> What did the lesson cover today?
14:12:10 <Cale> jonkri: cool
14:12:28 <jonkri> he talked about functions, pretty much
14:12:44 <jonkri> defined and used a function that converted a euro price into swedish crowns and also defined an ~== operator
14:12:44 * monochrom expects "we defined categories and functors. he says next time he will do monads."
14:12:47 <Cale> Is this a university course?
14:12:56 <jonkri> Cale: yes
14:13:03 <Cale> which uni?
14:13:11 <jonkri> Cale: chalmers, gothenburg, sweden
14:13:28 <monochrom> chalmers == the place
14:13:31 <Cale> ah, I think there's a bunch of people from there around here :)
14:13:38 <jonkri> monochrom: yeah. www.chalmers.se
14:13:44 <monochrom> Who is the instructor?  We'll recognize the name most probably.
14:13:44 <jonkri> hold on
14:13:57 <monochrom> Actually don't tell us.  Let us guess.
14:14:06 <jonkri> here's the site: http://www.cs.chalmers.se/Cs/Grundutb/Kurser/funvt/
14:14:18 <jonkri> oh, ok. go on :)
14:14:28 <jonkri> it's a young guy
14:14:33 <jonkri> phd student
14:14:43 <monochrom> Then it won't be Classen.
14:14:52 <jonkri> no
14:15:12 <monochrom> Alright, K. Classen is all I know. :)
14:15:31 <monochrom> But the other people here will recognize other names.
14:15:38 <palomer_> >> is the same as >>= id, right?
14:15:51 <musasabi> @type (>>)
14:15:52 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> m b -> m b
14:15:56 <musasabi> @type (>>= id)
14:15:57 <lambdabot> forall (m :: * -> *) b. (Monad m) => m (m b) -> m b
14:16:04 <jonkri> please talk a look at http://appserv.cs.chalmers.se/users/nad/wiki/wiki.cgi#head-20102717b1d8b69c503bc4a0d569448d3214815b
14:16:05 <monochrom> No.  x >> y is the same as x >>= \_ -> y
14:16:13 <jonkri> that's the teachers
14:16:23 <Cale> Nils Anders Danielsson apparently. I recognise him from the mailing lists.
14:17:00 <monochrom> @pl x >>= \_ -> y
14:17:02 <lambdabot> x >> y
14:17:09 <jonkri> cool
14:17:15 <monochrom> @pl x >>= const y
14:17:16 <lambdabot> x >> y
14:17:27 <jonkri> anyway, i'm not impressed yet :)
14:17:28 <musasabi> @pl (>>= . const)
14:17:28 <lambdabot> (line 1, column 2):
14:17:28 <lambdabot> unexpected ">"
14:17:28 <lambdabot> expecting lambda abstraction or expression
14:17:30 <monochrom> @pl \x y -> x >>= const y
14:17:31 <lambdabot> (. const) . (>>=)
14:17:34 <palomer_> so how do we define >> in terms of >>= ?
14:17:45 <monochrom> Thus, >> is the same as (. const) . (>>=)
14:17:47 <palomer_> @index Monad
14:17:48 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer,
14:17:48 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.
14:17:48 <lambdabot> Monad.Cont, Control.Monad.Error, Control.Monad.List
14:17:53 <musasabi> a >> b = a >>= \_ -> b
14:17:55 <palomer_> @index Control.Monad
14:17:56 <lambdabot> bzzt
14:18:33 <palomer_> >> = \a b -> a >>= const b 
14:18:34 <musasabi> @index Control.Monad.Monad
14:18:35 <lambdabot> bzzt
14:18:41 <palomer_> @type \a b -> a >>= const b
14:18:42 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
14:18:49 <palomer_> @type >>=
14:18:51 <lambdabot> parse error on input `>>='
14:18:58 <palomer_> @type (>>=)
14:19:00 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
14:19:31 <palomer_> so I can think of every line of a do statement as producing an m a, right?
14:20:04 <vincenz> how is the difference between lift and return?
14:20:15 <Heffalump> they have different types..
14:20:34 <vincenz> how so
14:20:37 <vincenz> return: a -> ma
14:20:42 <Philippa> palomer: pretty much, yeah
14:20:45 <Cale> @type lift
14:20:45 <Heffalump> @type Control.Monad.liftM
14:20:46 <lambdabot> Not in scope: `lift'
14:20:47 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
14:20:47 <vincenz> lift : m a -> t m a or (abstracting ma)
14:20:54 <vincenz> b -> t b
14:20:54 <Philippa> (the exception's if it starts "let")
14:20:54 <Cale> @type Control.Monad.Trans.lift
14:20:55 <Heffalump> oh, that lift
14:20:56 <lambdabot> forall (t :: (* -> *) -> * -> *) a (m :: * -> *).
14:20:56 <lambdabot> (Control.Monad.Trans.MonadTrans t, Monad m) =>
14:20:56 <lambdabot> m a -> t m a
14:20:59 <jonkri> i'm off to do some terrible calculus now, see you guys!
14:21:02 <Heffalump> t has a different type class.
14:21:05 <vincenz> oh
14:21:08 <vincenz> so it's not
14:21:10 <vincenz> t (m a)
14:21:24 <Heffalump> yeah, and that.
14:21:37 <araujo> @index CInt
14:21:38 <lambdabot> Foreign.C.Types, Foreign.C
14:23:01 <Philippa> palomer_: are you identified? If you're responding to my PMs at all I can't see it
14:30:59 <Nanar> data Package = Pack { pname :: String, pgroup :: Maybe String }
14:31:18 <Nanar> I want to update pgroup, how do I do ?
14:31:41 <Cale> myPackage { pgroup = Just "blah" }
14:32:01 <Nanar> assuming p = Pack { pname = "foo", pgroup = "" }
14:32:51 <Cale> pgroup = "" isn't valid, it could be  pgroup = Just ""  or  pgroup = Nothing
14:32:51 <Nanar> Cale: I allready have p partially filled
14:33:19 <Nanar> ok, good to know, was just an exemple
14:33:35 <Cale> (you can't use a String in the place of a Maybe String)
14:34:26 <Nanar> so I have p, I want p' from p + pgroup updated ?
14:38:04 <vincenz> I have a question about YAHT virtual page 141, actual pdf page 152
14:38:43 <vincenz> mapTreeM:: (MonadTrans t, Monad (t IO), Show a) => (a -> t IO al) -> Tree a -> t IO (Tree al)
14:38:55 <vincenz> shouldn't this just return Tree al
14:41:35 <Cale> I don't think it could
14:41:59 <Cale> It involves IO so IO has to occur somewhere in the result type :)
14:43:05 <Cale> It uses IO as the base monad for an arbitrary transformer.
14:43:32 <Cale> (all the IO actions are lifted there)
14:46:49 <Cale> vincenz: make sense?
14:47:42 <vincenz> yeah
14:47:49 <vincenz> the text just didn't
14:47:53 <vincenz> it stated something else
14:48:28 <Cale> oh
14:48:40 <Cale> It said "returns a tree"?
14:48:51 <Cale> it only does that in a rather abstract way
14:49:06 <vincenz> yeah
14:49:09 <vincenz> ooh
14:49:12 <vincenz> time for an excercise
14:49:53 <vincenz> @type Either String
14:49:54 <lambdabot> Not in scope: data constructor `Either'
14:49:54 <lambdabot>  
14:49:54 <lambdabot> <interactive>:1:7: Not in scope: data constructor `String'
14:50:05 <vincenz> @kind Either String
14:50:06 <lambdabot> * -> *
14:50:11 <vincenz> thought so :)
14:52:15 <vincenz> care to help me with an excercise?
14:53:14 <vincenz> newtype ListT m a = ListT m [a]
14:53:17 <vincenz> this seem good?
14:59:00 <Cale> It can work somewhat, and that's the version in the libraries, but I recall there was something wrong with it
15:00:02 <Cale> Sometimes you could end up with something that didn't satisfy the monad laws.
15:00:09 <araujo> lisppaste2, help?
15:00:09 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
15:01:59 <vincenz> how do you do definitions in ghci?
15:02:08 <monochrom> let x=1
15:02:14 <monochrom> let f x = x+1
15:02:15 <Cale> You can temporarily define functions and values with let
15:02:36 <vincenz> and types?
15:02:36 <monochrom> You can't define data types.
15:02:40 <vincenz> a
15:02:40 <vincenz> h
15:02:58 <Cale> it's intended that you put your code into a separate file and load it with ghci
15:06:35 <vincenz> hmm
15:06:46 * vincenz continues reading
15:06:50 <vincenz> I can sort of understand it
15:06:54 <vincenz> but the excercises are still out my scope
15:06:56 <vincenz> so I just read the answers
15:07:24 <vincenz> why is mzero for a Parser a failure
15:08:23 <monochrom> So that "p `mplus` mzero" is the same as p.
15:08:41 <ihope> Are we talking about MonadPlus?
15:08:52 <monochrom> Yes
15:09:08 <monochrom> Also Parser as MonadPlus.
15:10:19 <vincenz> hmm
15:10:24 <vincenz> is there such a thing as ParserT
15:10:33 <vincenz> so you could possibly parse an ambiguous text as multiple options
15:10:33 <ihope> @type \_ _ -> 3
15:10:35 <lambdabot> forall t t1 t2. (Num t) => t2 -> t1 -> t
15:10:46 <ihope> @type \_ -> _
15:10:48 <lambdabot> Pattern syntax in expression context: _
15:10:49 <ihope> :-)
15:10:49 <vincenz> given the underlying monad is List?
15:11:30 <vincenz> also why does matchChar use left and right
15:11:32 <vincenz> instead of the more generic
15:11:34 <vincenz> fail and return
15:11:38 <SamB> any graphic designers about who would be interested in doing stuff for a crazy programming language project?
15:11:38 <vincenz> such that you could use other monads
15:11:40 <Cale> vincenz: most parsing monads already have some notion of nondeterminism, but ParserT would more likely allow you to perform other sorts of computations while parsing
15:11:58 <vincenz> thx
15:12:02 <vincenz> so you could for instance parse c
15:12:17 <vincenz> where you need the environment to distinguish types from variables
15:12:35 <vincenz> (or for that case c++ which typically is done with GLR)
15:12:56 <monochrom> Text.ParserCombinators.ReadP is friendly to ambiguous grammars and multiple options
15:13:24 <monochrom> But then ReadP is probably ParserT with new names.
15:14:14 <Philippa> Cale: I get the impression a ParserT isn't as strongly needed as it could be in that parsing mostly makes more sense at the bottom of the transformation stack
15:14:57 <Philippa> the notable exception is when you want to do IO as well
15:15:06 <Cale> Philippa: I've had the desire for a ParserT from time to time though.
15:15:09 <Cale> yeah
15:15:43 <Philippa> that or ST or...
15:15:56 <Philippa> it's all those built-in can't-be-transformer monads that're the problem
15:16:43 <vincenz> Philippa: what if your parsing is environment dependent?
15:17:48 <monochrom> My approach is http://www.vex.net/~trebla/tmp/ParsecIO.hs
15:18:25 <Philippa> vincenz: if we're talking about a Reader-style environment, you can use a ReaderT fine
15:18:57 <dfhaii> is there a method to take the last item in a list?
15:19:01 <vincenz> Philippa: but the parser needs info form it
15:19:04 <vincenz> s/form/from
15:19:10 <vincenz> so wouldn't it be ParserT Reader
15:19:17 <vincenz> iso ReaderT Parser
15:19:29 <Philippa> vincenz: no
15:19:44 <vincenz> could you explain?
15:20:15 <monochrom> dfhaii: last
15:20:23 <Philippa> vincenz: ReaderT Parser gives you a reader-thingy implemented on top of something that already parses - you can implement that 'by hand' by just passing an environment around
15:20:49 <Philippa> similarly, you can pass stuff from the environment into parsing operations lifted into the ReaderT Parser
15:21:00 <vincenz> oh
15:21:19 <vincenz> but the environment changes as it parses
15:21:42 <Cale> Reader is for static (or locally static) environments
15:21:47 <Philippa> yes, but bind happens and so it all gets propagated
15:22:23 <vincenz> so I want a StateT instead
15:22:31 <Cale> yeah, probably
15:22:38 <Philippa> yep
15:22:41 <Philippa> same thing applies though
15:23:48 <dfhaii> thanks monochrom 
15:24:07 <Cale> STT would actually be pretty interesting.
15:24:29 <Cale> (that is, ST as a monad transformer)
15:25:12 <vincenz> what's ST?
15:25:28 <monochrom> Control.Monad.ST
15:25:39 <Cale> It's a monad in which you can have an arbitrary number of mutable cells.
15:25:52 <Cale> But you still can't do IO
15:26:09 <Cale> @type Data.STRef.newSTRef
15:26:10 <lambdabot> forall a s. a -> GHC.ST.ST s (GHC.STRef.STRef s a)
15:26:23 <monochrom> An example of using ST: http://www.cs.toronto.edu/~trebla/Shuffle.hs
15:26:52 <Cale> There's also STArrays which are mutable arrays in the ST monad.
15:27:02 <Cale> @type Control.Monad.ST.runST
15:27:04 <lambdabot> forall a. (forall s. GHC.ST.ST s a) -> a
15:27:15 <Cale> You can still get a pure result out at the end.
15:27:42 <Cale> However, that little bit of type hackery there prevents you from sneaking STRefs out.
15:28:49 <Philippa> I'm not sure that works if you're silly enough to deliberately instantiate s to a pre-existing type?
15:29:12 <Heffalump> the only way you can do that is to instantiate it to RealWorld
15:29:34 <SamB> Philippa: I'm sure it does't
15:29:34 <vincenz> on page 160 of YAHT
15:29:36 <Heffalump> well, you could do it with any type, but you couldn't then do anything with the result
15:29:44 <vincenz> why is the parser with lines not done as a StateT Parser
15:29:49 <Philippa> oh, of course. Insufficiently polymorphic function
15:30:06 <SamB> Heffalump: thats called "not working"
15:30:08 <Cale> Philippa: right, you'll never be able to apply runST
15:30:14 <Heffalump> well, clearly it's insufficiently polymorphic for runST
15:30:32 <Heffalump> so you have to look for other things that can use a ST (...)
15:30:44 <vincenz> ?
15:30:57 * vincenz nods as he listens to the conversation, rather lost
15:31:03 <SamB> Philippa: thats like the whole point of s ;-) :-(
15:31:04 <Heffalump> and the only things that exist are >>= (and derivative functions), which just makes another one, and the top-level IO execution.
15:32:02 <ihope> Hmm, how about a >>>= operator?
15:32:10 <ihope> I don't know what it would do, but...
15:32:20 <dfhaii> :e
15:32:21 <SamB> ihope: which would do what?
15:32:30 <Cale> vincenz: hm? which one?
15:32:38 <ihope> <ihope> I don't know what it would do, but...
15:32:57 <SamB> ihope: I'm lagged!
15:33:02 <ihope> :-)
15:33:03 <SamB> I asked before you said that
15:33:09 <Cale> vincenz: ah
15:33:17 <Cale> vincenz: yeah, it could be, and you usually would
15:33:18 <ihope> @index (>>>)
15:33:19 <lambdabot> Control.Arrow
15:33:29 <vincenz> and
15:33:33 <vincenz> it gives me a ParsecI> ...
15:33:37 <vincenz> how do I do that with ghci?
15:34:15 <Cale> vincenz: how do you load Parsec you mean?
15:34:21 <vincenz> yeah
15:34:28 <Cale> :m + Text.ParserCombinators.Parsec
15:34:29 <vincenz> ParsecI> parse (char 'a') "stdin" "a"
15:34:47 <ihope> @type [(>>=),(>>>)]
15:34:48 <lambdabot> Not in scope: `>>>'
15:34:56 <ihope> @type [(>>=),(Control.Arrow.>>>)]
15:34:58 <lambdabot>   Occurs check: cannot construct the infinite type: b = b1 -> b
15:34:58 <lambdabot>   Expected type: (b1 -> a) -> (a -> b1 -> b) -> b1 -> b
15:35:31 <SamB> @type [(>>),(Control.Arrow.>>>)]
15:35:32 <lambdabot> forall b (a :: * -> * -> *) b1.
15:35:32 <lambdabot> (Monad (a b1), Control.Arrow.Arrow a) =>
15:35:32 <lambdabot> [a b1 b1 -> a b1 b -> a b1 b]
15:36:33 <Cale> SamB: heh
15:37:07 <vincenz> @type [(>>=),(Control.Arrow.>>>=)]
15:37:08 <lambdabot> Not in scope: `Control.Arrow.>>>='
15:38:09 <Cale> It's a bit of a fluke that the types of (>>) and (>>>) unify in the first place
15:38:13 <dfhaii> hmm
15:38:15 <ihope> Hah.
15:38:42 <ihope> @type (undefined :: ((a -> b) -> a) -> a)
15:38:44 <lambdabot> forall a b. ((a -> b) -> a) -> a
15:38:49 <ihope> Yay!
15:39:19 <dfhaii> i have a list of type (int, maybe int), and have some values in it which are (int, nothing) nad some which are (int, Just int),  what is the best way of removing all the ones which are (int, Nothing) leaving only those with 2 values
15:40:13 <ihope> filter ((== Nothing) . snd)
15:40:17 <dcoutts> [ x | xs@(_, Just _) <- xs ]
15:40:48 <Cale> filter (isNothing . snd)
15:40:54 <ihope> Bah.
15:40:58 <ihope> @type isJust
15:41:00 <lambdabot> Not in scope: `isJust'
15:41:00 <Cale> @type isNothing
15:41:02 <lambdabot> Not in scope: `isNothing'
15:41:05 <Cale> @type Data.Maybe.isNothing
15:41:06 <dcoutts> > let foo xs = [ x | xs@(_, Just _) <- xs ] in [(1, Nothing), (2, Just 3)]
15:41:07 <lambdabot> forall a. Maybe a -> Bool
15:41:07 <lambdabot>  Not in scope: `x'
15:41:12 <Cale> @type Data.Maybe.isJust
15:41:13 <lambdabot> forall a. Maybe a -> Bool
15:41:22 <dcoutts> > let foo xs = [ x | x@(_, Just _) <- xs ] in [(1, Nothing), (2, Just 3)]
15:41:23 <lambdabot> [(1,Nothing),(2,Just 3)]
15:41:32 <dcoutts> oops
15:41:32 <Cale> hehe, have to apply foo
15:41:33 <ihope> @index isEmpty
15:41:34 <lambdabot> Data.Graph.Inductive.Graph, Data.Graph.Inductive, Data.Graph.Inductive.
15:41:34 <lambdabot> Internal.Heap, Language.Haskell.TH.PprLib, Text.PrettyPrint.HughesPJ,
15:41:34 <lambdabot> Text.PrettyPrint
15:41:36 <dcoutts> > let foo xs = [ x | x@(_, Just _) <- xs ] in foo [(1, Nothing), (2, Just 3)]
15:41:38 <lambdabot> [(2,Just 3)]
15:41:59 <ihope> data InfList a = Cons a (InfList a)
15:42:01 <dcoutts> dfhaii, there you go. Three different answers. :-)
15:42:08 <dfhaii> thanks :D
15:42:22 <dfhaii> slowly getting the hang of this functional programming lark
15:42:46 <dcoutts> personally I think the pattern match style filtering in list cmprehensions is great
15:42:55 <dcoutts> cmprehensions/comprehensions
15:43:13 <ihope> I lubs da do notation.
15:43:18 <ihope> When done on lists, that is,
15:43:45 <dfhaii> the way i see that is xs is all the items which match x, and x allows anything, just anything?
15:44:06 <dcoutts> dfhaii, well...
15:44:09 <dcoutts> [ x | x@(_, Just _) <- xs ]
15:44:16 <dcoutts> there's a couple things going on here
15:44:25 <dcoutts> we could write it a bit simpler:
15:44:42 <dcoutts> [ (a, Just b) | (a, Just b) <- xs ]
15:45:07 <psnl> dfhaii: hello?
15:45:08 <dcoutts> so the pattern "(a, Just b) <- xs" means we only get the elements of xs that patch that patter
15:45:17 <dcoutts> pattern
15:45:24 <dcoutts> dfhaii, see?
15:45:50 <dcoutts> patch/match
15:45:56 * dcoutts can't spell!
15:46:12 <dfhaii> yeah, thanks for the explanation
15:46:28 <dfhaii> sorry to highlight you psnl, sorted what i wanted to ask now
15:48:01 <dcoutts> dfhaii, if you want to understand the other form:
15:48:05 <dcoutts> [ x | x@(_, Just _) <- xs ]
15:48:25 <dcoutts> then look in a tutorial about what '@' means in pattern matching
15:49:35 <dfhaii> will do, thanks again
15:49:39 <psnl> dfhaii: deadline is thursday morning, so you have lots of time
15:49:52 <dfhaii> thurs mornin? thought it was tomorow afternoon
15:50:19 <dfhaii> am finishing off the last bit of coding now, once i actually started it's not as bad as i though
15:50:22 <dfhaii> t
15:51:00 <dfhaii> psnl: The submission thing lists it as 18:15 tomorow
15:51:05 <dfhaii> still plenty of time though
15:51:28 <psnl> ooh, I really should submit
15:53:22 <dfhaii> lol
15:53:27 <dfhaii> s'alright for some
15:54:15 <tony2> I never think to pattern match in comprehensions, I would have done filter (isJust.snd) xs
16:00:27 <ihope> Does anybody know any infinite web pages?
16:01:08 <eivuokko> Netradios?
16:01:27 <dfhaii> one of the chaps in #php on quakenet has an infinate page
16:02:00 <ulfdoz> Hey, it's quakenet... ;)
16:04:38 <psnl> ihope: define infinate web page
16:04:47 <tony2> {-# OPTIONS_GHC -package fastcgi #-} main = do print [1..] ?
16:06:05 <ihope> Hmm... one that never stops loading, yet that can be loaded to any point.
16:06:52 <monochrom> Heh, I have always wanted to make one.
16:07:29 <SamB> foldr (+++) undefined (repeat $ "Hello, World!" +++ br)
16:07:58 <monochrom> Say, the web page is merely an image (as far as content type is concerned), but the image is generated on the fly on the server side, and it needs not end.
16:08:19 <monochrom> Of course text is easier.
16:08:31 <SamB> monochrom: eh, you'd need an image format with no "height"
16:08:33 <KirinDave> monochrom: The very definition of server-push animation, used by some webcam setups. :)
16:08:48 <monochrom> Right, need an image format with no upfront bound.
16:09:07 <monochrom> Ah ha, yes there are many of those.
16:09:31 <SamB> let inf = ("Hello, World!" +++ br +++ inf) in inf
16:09:40 <ihope> @type br
16:09:41 <lambdabot> Not in scope: `br'
16:09:45 <ihope> @index br
16:09:46 <lambdabot> Text.Html
16:09:52 <ihope> @type Text.Html.bf
16:09:54 <lambdabot> Not in scope: `Text.Html.bf'
16:09:55 <ihope> @type Text.Html.br
16:09:57 <lambdabot> Text.Html.Html
16:09:57 <monochrom> If you open your spam mail folder you can probably find a hundred references to such "click here for my web cam, I'm naked!" pages.
16:09:59 <dfhaii> something like that would be very easy in php
16:10:17 <ihope> @type (+++)
16:10:19 <lambdabot> Not in scope: `+++'
16:10:25 <ihope> Sigh.
16:10:28 <ihope> @index (+++)
16:10:30 <lambdabot> Control.Arrow, Text.Html, Text.ParserCombinators.ReadP, Distribution.
16:10:30 <lambdabot> Compat.ReadP, Text.ParserCombinators.ReadPrec, Text.Read
16:10:46 <ihope> > (+++)
16:10:48 <lambdabot>   add an instance declaration for (Show (a b c
16:10:48 <lambdabot>                -> a b' c'
16:10:48 <lambdabot>                -> a (Either b b') (Either c c')))
16:11:01 <KirinDave> I am still getting used to lambdabot...
16:11:03 <ihope> So much easier!
16:11:18 <KirinDave> It's a pretty entertaining tool you have there. :)
16:11:23 <ihope> :-)
16:12:02 <ihope> > \a b c d e f g h i j k l m n o p q r s t u v w x y z -> y e s i (a g r e e) (c o m p l e t e l y)
16:12:03 <lambdabot>   add an instance declaration for (Show ((t -> t1 -> t2 -> t2 -> t3)
16:12:03 <lambdabot>                -> t4
16:12:03 <lambdabot>                -> (t5
16:13:13 <KirinDave> You could steal tryruby code and make tryhaskell, I'd imagine.
16:13:20 <monochrom> ihope what are you trying to achieve?!
16:13:35 <ihope> monochrom: confusion and disorder!
16:14:06 <monochrom> You are not succeeding. :)
16:14:16 <ihope> > fix \fix x -> x (fix x)
16:14:17 <KirinDave> I am cornfused.
16:14:17 <lambdabot>  parse error on input `\'
16:14:20 <Heffalump> @pl \a b c d e f g h i j k l m n o p q r s t u v w x y z -> t h e q u i c k b r o w n f o x j u m p s o v e r t h e l a z y d o g
16:14:28 <ihope> Fused corn, eh?
16:14:31 <KirinDave> Yes.
16:14:32 <monochrom> Now that's something.
16:14:32 <lambdabot> (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . (((((((flip .) .
16:14:32 <lambdabot> ) .) .) .) .) .) . ((((((((flip .) .) .) .) .) .) .) .) . (((((((((flip .)
16:14:32 <lambdabot> .) .) .) .) .) .) .) .) . ((((((((((flip .) .) .) .) .) .) .) .) .) .) . (
16:14:32 <lambdabot> ((((((((((flip .) .) .) .) .) .) .) .) .) .) .) . ((((((((((((flip .) .) .
16:14:32 <lambdabot> ) .) .) .) .) .) .) .) .) .) . (((((((((((((flip .) .) .) .) .) .) .) .) .
16:14:35 <lambdabot> [182 @more lines]
16:14:36 <KirinDave> I am stuck to a piece of corn.
16:14:36 <lambdabot> optimization suspended, use @pl-resume to continue.
16:14:37 <ihope> !!!
16:14:41 <Heffalump> that one's quite entertaining.
16:14:41 <ihope> Oh dear.
16:14:42 <monochrom> 182 more lines hahaha
16:14:53 <ihope> Listen to this entire song, and you'll be unstuck:
16:15:03 <KirinDave> Umm. What the hell?
16:15:04 <ihope> http://picard.ytmnd.com/
16:15:50 <KirinDave> ihope: http://familyguyrocklobster.ytmnd.com/
16:16:38 <KirinDave> So there. :)
16:21:22 <ihope> Many blue balls:
16:21:23 <ihope> http://blueballfixed.ytmnd.com/
16:34:51 <ihope_> > error ("Omgwtf" ++ error "bbq")
16:34:52 <lambdabot> Add a type signature
16:35:11 <ihope_> > error ("Omgwtf" ++ error "bbq") :: Int
16:35:12 <lambdabot> bbq
16:37:02 <ihope_> > error "> error \"I know this won't work...\" :: Int" :: Int
16:37:04 <lambdabot> Exception: > error "I know this won't work..." :: Int
16:37:13 <ihope_> Ah, I get it.
16:38:10 <Heffalump> what is it about this bbq thing?
16:38:31 <ihope_> I dunno. Found it once, and...
16:43:22 <dfhaii> :(
16:44:29 <dfhaii> i have 2 lists now, one of type [(int, int)] and one of type [(int, string)],  i need to make a third list of type [(string, string)] where the strings are those from the second list associated with those in the first list
16:45:44 <dfhaii> ie [(1,2),(3,4)] and [(1,a),(2,b),(3,c),(4,d)] and i need to get [(a,b),(c,d)]
16:45:44 <vincenz> you mean lista = int -> int
16:46:03 <vincenz> dfhaii: I'd use a map
16:46:39 <dfhaii> why did i not think to
16:46:40 <dfhaii> :|
16:46:48 <dfhaii> taa, will probably be back when stuck
16:46:49 <dfhaii> :D
16:46:56 <vincenz> > \li ls -> map (\(x,y) -> (assocGet ls x, assocGet ls y)) ls
16:46:57 <lambdabot>  Not in scope: `assocGet'
16:47:10 <vincenz> @pl \li ls -> map (\(x,y) -> (assocGet ls x, assocGet ls y)) ls
16:47:11 <lambdabot> const (map =<< (`ap` snd) . (. fst) . ap (flip . (((.) . (,)) .) .
16:47:11 <lambdabot> assocGet) assocGet)
16:47:26 <vincenz> @pl \li ls -> map (\(x,y) -> (assoc ls x, assoc ls y)) ls
16:47:26 <psnl> dfhaii: finiteMap, Paul uses it all over the place
16:47:27 <lambdabot> const (map =<< (`ap` snd) . (. fst) . ap (flip . (((.) . (,)) .) . assoc)
16:47:27 <lambdabot> assoc)
16:47:32 <vincenz> > \li ls -> map (\(x,y) -> (assoc ls x, assoc ls y)) ls
16:47:33 <lambdabot>  Not in scope: `assoc'
16:49:19 <vincenz> dfhaii: not fully specified tho
16:49:24 <vincenz> what if yu have : no matches, multiple matches
16:49:30 <vincenz> use a monad to accumulate
16:50:02 <vincenz> how do I do
16:50:03 <dfhaii> there will definatly be matches for all, and no multiple
16:50:07 <vincenz> a -> [(a,b)] -> [b]
16:50:11 <psnl> vincenz: trust me, he doesn't have dups
16:50:21 <vincenz> or
16:50:24 <vincenz> a -> [(a,b)] -> Maybe b
16:50:46 <vincenz> @hoogle a -> [(a,b)] -> Maybe b
16:50:47 <lambdabot> Data.List.lookup :: Eq a => a -> [(a, b)] -> Maybe b
16:50:47 <lambdabot> Prelude.lookup :: Eq a => a -> [(a, b)] -> Maybe b
16:50:52 <psnl> A finiteMap will do the second, and since the input doesn;t have dups...
16:50:54 <vincenz> @hoogle a -> [(a,b)] -> [b]
16:50:55 <lambdabot> No matches, try a more general search
16:51:12 <vincenz> > \li ls -> map (\(x,y) -> (lookup x ls, lookup y ls)) ls
16:51:13 <lambdabot>   add an instance declaration for (Show (t -> [(b, b)] -> [(Maybe b,
16:51:13 <lambdabot> Maybe b)]))
16:51:25 <pesco> Has anybody seen jhc's implementation of Array?
16:51:39 <vincenz> > \li ls -> map (\(x,y) -> (lookup x ls, lookup y ls)) ls [(1,2),(3,4)] [(1,"a"), (2,"b"), (3, "c"), (4, "d")]
16:51:40 <lambdabot>   The function `map' is applied to four arguments,
16:51:40 <lambdabot>   but its type `(a -> b) -> [a] -> [b]' has only two
16:51:40 <lambdabot>   In a lambda abstraction:
16:51:52 <vincenz> > (\li ls -> map (\(x,y) -> (lookup x ls, lookup y ls)) ls) [(1,2),(3,4)] [(1,"a"), (2,"b"), (3, "c"), (4, "d")]
16:51:53 <lambdabot>  add an instance declaration for (Num [Char])
16:51:53 <lambdabot>   In the list element: (4, "d")
16:52:15 <vincenz> o.O
16:52:35 <vincenz> > (\li ls -> map (\(x,y) -> (lookup x ls, lookup y ls)) li) [(1,2),(3,4)] [(1,"a"), (2,"b"), (3, "c"), (4, "d")]
16:52:37 <lambdabot> [(Just "a",Just "b"),(Just "c",Just "d")]
16:52:53 <ihope_> > map toLower "FLOCCINAUCINIHILIPILIFICATION "
16:52:55 <lambdabot> "floccinaucinihilipilification "
16:54:09 <vincenz> > (\li ls -> zip (map ((`lookup` ls) . fst) li) (map ((`lookup` ls) . fst) li)) [(1,2),(3,4)] [(1,"a"), (2,"b"), (3, "c"), (4, "d")]
16:54:10 <lambdabot> [(Just "a",Just "a"),(Just "c",Just "c")]
16:54:27 <vincenz> @pl (\li ls -> zip (map ((`lookup` ls) . fst) li) (map ((`lookup` ls) . fst) li))
16:54:28 <lambdabot> ap (ap . (zip .) . flip (map . (. fst) . flip lookup)) (flip (map . (.
16:54:28 <lambdabot> fst) . flip lookup))
16:56:54 <vincenz> @type ap
16:56:55 <lambdabot> Not in scope: `ap'
16:57:05 <vincenz> @hoogle ap
16:57:06 <lambdabot> Control.Monad.ap :: Monad m => m (a -> b) -> m a -> m b
16:57:06 <lambdabot> Data.Graph.Inductive.Query.ArtPoint.ap :: Graph gr => gr a b -> [Node]
16:57:06 <lambdabot> Control.Arrow.app :: ArrowApply a => a (a b c, b) c
17:08:19 <dfhaii> cannot work this out
17:30:56 <dfhaii> ah sorted
17:30:57 <dfhaii> :D
17:34:44 <eivuokko> Are Foreign.StablePtr-operations expensive?
17:55:45 <ptolomy> > reverse ":-("
17:55:46 <lambdabot> "(-:"
17:55:55 * ptolomy hugs lambdabot.
17:59:07 <rep> heh.
17:59:36 <rep> > reverse "):"
17:59:38 <lambdabot> ":)"
17:59:52 <juhp> dcoutts: pong
18:00:06 <juhp> (x days lag?)
18:01:29 <Lemmih> > error("(:"++error(reverse"):"))::()
18:01:30 <lambdabot> :)
18:05:59 <musasabi> mmh, that is seriously evil.
18:07:05 <musasabi> > error (error "> \"it is a pity there is only a single bot\"")
18:07:06 <lambdabot> Add a type signature
18:07:09 <musasabi> > error (error "> \"it is a pity there is only a single bot\"") :: ()
18:07:11 <lambdabot> Exception: > "it is a pity there is only a single bot"
18:07:31 <musasabi> hmm.
18:08:06 <palomer> Philippa: sorry, I had left my computer on at school
18:08:13 <palomer> Philippa: but I had actually left:o
18:10:02 <palomer> if m is a monad, then m a usually represents a computation returning a value of a, right?
18:10:50 <palomer> (in fact, all the monads I've seen so far have this property)
18:11:07 <Cale> palomer: yeah, when you're thinking of monads as kinds of computations
18:12:02 <palomer> if m is a monad container, then m a usually represents something containing a value of a
18:12:10 <palomer> are there any other ways of thinking of monads?
18:12:16 <Cale> values of type a, yeah
18:12:34 <Cale> other ways -- well, I don't have any further analogies to offer
18:12:49 <Cale> You can reason about them purely formally just using the laws
18:13:30 <palomer> so (State s) a is a computation returning a value of type a
18:14:09 <Cale> right
18:14:29 <Cale> and maintaining a state of type s as that value is computed
18:14:57 <Cale> one of the classic examples worth looking at is relabelling a tree. Take this type:
18:15:12 <Cale> data Tree a = Leaf a | Branch (Tree a) (Tree a)
18:15:30 <Cale> Suppose we want to write relabel :: Tree a -> Tree Integer
18:16:03 <Cale> which just throws away the values of type a, and labels the leaves from left to right with integers from 1 up to n, where n is the number of leaves.
18:17:08 <palomer> this is a one liner if you have foldl
18:18:03 <Cale> which foldl?
18:19:03 <palomer> foldl on Tree
18:19:27 <Cale> what's it's type? (there are lots of folds on trees)
18:19:34 <Cale> its*
18:21:28 <palomer> @type foldl
18:21:29 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
18:21:41 <palomer> (a->b->a)->a->Tree b -> a
18:21:41 <dons> musasabi, so what do you think of the binding to regexec? 
18:21:51 <dons> i mean, it's all that Text.Regex does anyway
18:21:55 <palomer> @type return
18:21:57 <lambdabot> forall (m :: * -> *) a. (Monad m) => a -> m a
18:22:57 <dons> the other option is to then add the Word8 regexec backend to Text.Regex
18:23:05 <palomer> wait, gtg
18:23:06 <palomer> bbl
18:23:07 <Cale> palomer: not sure exactly how you'd do it cleanly with that
18:23:12 <Cale> oh
18:23:13 <Cale> okay
18:23:25 <musasabi> dons: Would fps support Text.Regexp be a horrible thing? ;)
18:23:45 <dons> I plan to add this, yes.
18:26:04 <palomer> back
18:26:20 <palomer> cale: it's one line!
18:26:27 <musasabi> dons: at least we can add it as an interesting alternative, but I don't think that using FFI to C counts as fair.
18:26:54 <dons> it's silly, since it's the same binding as Text.Regex :/
18:27:07 <dons> we have to call C somewhere
18:27:07 <musasabi> dons: I agree to that.
18:27:11 <palomer> Cale: oh ,you're right, I don't see how either:o
18:27:21 <palomer> Cale: but if you wanted to relabel a list you could do this!
18:28:14 <palomer> @type (>>=)
18:28:16 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
18:28:21 <lisppaste2> Cale pasted "old-fashioned and monadic relabeller" at http://paste.lisp.org/display/15765
18:28:33 <musasabi> dons: the problem is basically that is one enables FFI it gets very hard to decide in a fair fashion in which benchmarks it is fair to use.
18:28:57 <dons> yes, I understand. *sigh*
18:29:13 <musasabi> dons: the result would be most languages using FFI to C rather than the regexp module provided by the language and that would be quite sad.
18:29:13 <dons> it just means we have to distribute the bindings with the base system.
18:29:43 <dons> btw, did you see Chris's fasta: http://shootout.alioth.debian.org/gp4/benchmark.php?test=fasta&lang=all
18:29:44 <SamB> musasabi: well, C gets to use all those functions...
18:29:47 <dons> much improved :)
18:29:56 <Cale> palomer: at first it looks like it might be a bit more typing but ignore that, it's mostly a constant term, and the amount of stuff you really have to keep track of goes down
18:29:58 <dons> SamB, in fact, C sucks at regex. we need a binding to perl's regexes
18:30:11 <palomer> Cale: anyways, what's your example with labeling?
18:30:16 <musasabi> or TCL
18:30:17 <Cale> I pasted i
18:30:19 <Cale> I pasted it
18:30:24 <Cale> <lisppaste2> Cale pasted "old-fashioned and monadic relabeller" at http://paste.lisp.org/display/15765
18:30:31 <SamB> dons: C has regexes?
18:30:42 <dons> man 3 regexecc
18:31:19 <SamB> I mean it doesn't seem unfair to me that Haskell should get to use functions from libc...
18:31:52 <musasabi> dons: that is even pretty (except for the IO bits) :-)
18:32:26 <dons> we gained another 3 pnts overnight. just from the fasta entry and ackermann, I guess
18:32:48 <dons> but I don't know if we can catch C now, without fixing regex-dna. hmm. what to do..
18:33:11 <musasabi> SamB: then the end result is that most languages can use libc and basically it is about how efficient interfacing libc is.
18:33:26 <Cale> palomer: note that in the old version, the stateful plumbing is there, but it's exposed where we can make a typo and mess it up. In the monadic version all that plumbing is exactly the same, but it's hidden away in >>=
18:34:17 <palomer> Cale: where did you paste it?
18:34:28 <Cale>  <lisppaste2> Cale pasted "old-fashioned and monadic relabeller" at http://paste.lisp.org/display/15765
18:34:32 <Cale> there
18:34:35 <dons> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all, still second, since C submitted a regex-dna, and picked up 6 points.
18:34:39 <musasabi> dons: you can always ask Isaac whether the regex is game.
18:35:02 <palomer> oh, righto
18:35:14 <dons> ok, yes. maybe regex is a special case. it could be argued, since there's no other way.
18:35:38 <SamB> musasabi: so basically you need to use more realistic benchmarks where interfacing libc won't really help anyways ;-)
18:35:50 <palomer> someone remind me what do {x<-foo ; bar} is without the do notation
18:35:54 <SamB> (or will only help with certain parts of the problem)
18:36:02 <Cale> foo >>= \x -> bar
18:36:23 <dons> well, I actually do think the regex example is a good one. there seems to be a very wide range of cputime solns. it's hard to do well without high-perf lib support, I think.
18:36:31 <musasabi> SamB: well if one wants to see what kind of facility does language X's standard library offer, then interfacing libc is not that fair.
18:36:42 <palomer> so foo must be of type m a
18:36:44 <SamB> Cale: exactly what I was about to say
18:36:50 <Cale> SamB: :)
18:36:58 <Cale> palomer: yeah
18:37:12 <dons> good to see that now knuc appears to be the only memory leaking entry.
18:37:21 <musasabi> dons: another attack angle is to fix the memleak in knukleotide.
18:37:25 <palomer> is there an easier way to get MonadState than by using State ?
18:37:34 <dons> yes. I think maybe that's the way to go, musasabi.
18:37:35 <SamB> musasabi: but if the problems were not things that libc was particularly good at, there wouldn't be a problem
18:37:44 <musasabi> it appears I am the one to blame for that memleak.
18:37:48 <Cale> State is the simplest monad which is capable of MonadState
18:38:06 <Cale> There are lots of more complicated ways :)
18:38:15 <SamB> musasabi: like, you know, interesting problems?
18:38:41 <Cale> Perhaps it will seem slightly less mysterious if we actually reimplement State (again)
18:38:58 <Cale> I seem to remember forcing you to implement it at one point :)
18:39:14 <palomer> gah
18:39:17 <SamB> palomer: what could be easier?
18:39:22 <dons> I also still have a shorter sum-file (no type annotations) and a shorter nsieve-bits (just a refactor) on the wiki, yet to be committed
18:39:27 * palomer doesn't understand why he doesn't understand State
18:39:36 <musasabi> SamB: yes. interesting problems suffer from the problem that they are hard to spec in a way that withstands a dozen programmers trying to find a way to bypass the description.
18:39:39 <dons> could you push those in, musasabi? I think there's 2 or 3 points there.
18:39:51 <SamB> I mean, that is the simplest state monad I can concieve of
18:39:53 <palomer> SamB: newtype State s a = State (a,s) <--I've thought about this, but couldn't implement it
18:39:55 <musasabi> dons: ok.
18:40:14 <palomer> maybe it's the terminology used
18:40:18 <Cale> palomer: the State monad is just the natural thing to do after you've done that helper-function-with-extra-parameter deal a million times
18:40:25 <SamB> musasabi: hmm?
18:40:27 <dons> After implementing about 10 of the problems now, I have a lot of respect for the guys who come up with this stuff. some of the problems really push hard on language features.
18:41:08 <palomer> Cale: I agree it is the most natural to use
18:41:13 <palomer> Cale: I'm questioning the implementation
18:41:14 <dons> ok, maybe then with a better knuc, and a shorter couple of others, we could get the 6 or so points to get ahead of C... for a while at least.
18:42:17 <SamB> palomer: its very simple
18:42:28 <palomer> maybe if we rename State to that which it really represents
18:42:39 <palomer> which is StateTransition
18:42:40 <Cale> palomer: It's a monad for keeping track of State
18:42:50 <Cale> so State is a natural name for it
18:43:04 <SamB> palomer: we really don't want a StateTT
18:43:09 <SamB> it looks like stuttering
18:43:21 <SamB> palomer: anyway, its simple.
18:43:31 <SamB> its basically:
18:44:15 <SamB> return x = (\s -> (x, s))
18:44:32 <musasabi> dons: which of the sumfiles do you want to see in?
18:44:58 <palomer> SamB: that part I'm ok with
18:45:26 <dons> checking...
18:46:08 <palomer> maybe if we put more work on the shoulders of put and get
18:46:14 <palomer> and less on the shoulders of State
18:46:45 <Cale> how could you though?
18:46:55 <palomer> I have no clue
18:47:11 <SamB> f >>= g = \s -> let (x, s') = f s in g x1 s' -- I think
18:47:16 <Cale> palomer: >>= does exactly the least amount of work that it could do to accomplish its job
18:47:17 <SamB> palomer: you can't
18:47:35 <SamB> you *can* put more work on the shoulders of runState
18:47:52 <SamB> but that misses out on all the functional optimizations
18:48:08 <palomer> but it would be clearer
18:48:47 <Cale> x >>= f = State $ \s -> let (y, s') = runState x s in runState (f y) s'
18:49:07 <Cale> where we have
18:49:15 <palomer> yeah, that's the definition I have in front of me
18:49:23 <palomer> and that I've been staring at for 1 and a half hours today
18:49:24 <Cale> newtype State s a = State { runState :: s -> (a,s) }
18:49:37 <Cale> okay, so look at what it does
18:50:27 <dons> musasabi, Proposal 1, seems 10-15% faster on my testing.
18:50:28 <Cale> it gives you a new State computation, which runs x with the input state, getting a value y and a new state s'
18:50:43 <Cale> and then it applies f to y, getting another state computation
18:50:51 <Cale> which it runs with the updated state
18:50:57 <Cale> s'
18:51:56 <palomer> so I can think of it as sending  (a,s) to (f(a),x s) ?
18:52:26 <Cale> um...
18:52:49 <Cale> Well, let's look at >>
18:53:00 <Cale> Let's just implement it directly, rather than in terms of >>=
18:53:14 <palomer> ok
18:53:24 <palomer> @type (>>=)
18:53:26 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
18:53:31 <palomer> @type (>>)
18:53:33 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> m b -> m b
18:53:43 <Cale> x >> y = State $ \s -> let (v, s') = runState x in runState y s'
18:53:48 <Cale> x >> y = State $ \s -> let (v, s') = runState x s in runState y s'
18:54:03 <SamB> Cale: the definition in terms of >>= would be kind of boring, applicable as it is to all monads...
18:54:11 <Cale> SamB: right
18:54:13 <palomer> isn't that the same as before?
18:54:27 <Cale> it's similar, but a little simpler
18:54:39 <palomer> oh , runState y s'
18:54:41 <Cale> we're throwing away the result of the first computation
18:54:55 <Cale> but keeping that state parameter
18:55:11 <Cale> so any updates to the state in x are preserved
18:55:24 <Cale> and carried through to y
18:56:01 <Cale> which is then executed with the new state, and its result, along with further changes to the state are returned
18:56:47 <palomer>  State (s->(a,s))  <---the a is barely ever used!
18:57:15 <palomer> actually, I take that back
18:57:18 <Cale> the a is usually important, but it's not that important to the monadic chaining.
18:57:22 <Cale> it's important in ind
18:57:23 <Cale> bind*
18:57:33 <palomer> could you have defined state as (s->s,a) ?
18:58:04 <Cale> hmm... no
18:58:25 <Cale> because in general we want the value of 'a' returned to be able to depend on the state
18:58:36 <Cale> the value of type a
18:58:51 <palomer> return a = State $ (\s -> s,a)
18:59:07 <Cale> that bit is fine
18:59:32 <Cale> try writing get.
18:59:42 <Cale> get :: State s s
19:00:13 <palomer> oh, good point
19:00:17 <Cale> rb
19:00:19 <Cale> brb*
19:01:47 <palomer> oh, I think I'm seeing it clearer
19:02:46 <palomer> class MonadState m s | m -> s where 
19:02:46 <palomer>     get :: m s
19:02:46 <palomer>     put :: s -> m ()
19:02:58 <palomer> what does this mean? (the m s | m -> s bit)
19:04:07 <lispy> palomer: functional dependencies i think
19:04:19 <lispy> but that's about all i know about it
19:06:16 <palomer> ok, if I have a State a and a state b, then I can combine them like so : \s -> (b snd(a s))
19:07:52 <palomer> would it be possible to define get and put if my monad had return and combine instead of return and >>= ?
19:08:11 <palomer> wait, combine is the same as >>
19:09:32 <palomer> a `combine` b = a >> b = State $ \s -> let (u,v) = a s in runState b v
19:10:43 <palomer> what bothers me about State, when using it with MonadState, is that the value is most always discarded!
19:12:39 <dfhaii> what's the easiest way to join two lists into a list of pairs [(1,2,3,4)] [(5,6,7,8)] into [(1,5),(2,6),(3,7),(4,8)]
19:12:47 <sproingie> zip
19:12:53 <dfhaii> star thankyou
19:13:40 <Cale> palomer: the value is only discarded when you only care about the state
19:13:52 <Cale> palomer: if the value is important, it can be kept
19:14:00 <palomer> it can be put into the state!
19:14:15 <Cale> Oh, sure, if you'd like to do that, it can
19:14:20 <Cale> that's rare though
19:15:04 <Cale> usually your primary value is just plain accessible because it's been lambda bound
19:15:08 <palomer> oh? getting the state, doing some computation involving the state, and then storing this computation into the state doesn't seem rare to me
19:15:24 <Cale> oh, that's not rare
19:15:41 <Cale> but copying that 'a' into the 's' is rare
19:15:47 <palomer> righto
19:15:55 <TheHunter> > zip [1,2,3,4] [5,6,7,8]
19:15:57 <lambdabot> [(1,5),(2,6),(3,7),(4,8)]
19:15:59 <Cale> I suppose that's put, sometimes
19:16:19 <Cale> er, my complaint is just a philosophical one really
19:16:42 <Cale> you think of the value of type 'a' as the main thing you're manipulating, and the state as incidental to that, usually
19:17:43 <Cale> the monad just makes sure that the state is available where you need it, and otherwise keeps it out of your hair
19:18:08 <palomer> what bothers me the most is that get and put are really trivial functions who don't involve the value, so it would seem reasonable to remove all references to the value in get and put
19:18:25 <Cale> they do involve the value
19:18:38 <Cale> get returns the state as the value
19:18:52 <Cale> get = State $ \s -> (s,s)
19:19:03 <Cale> put, however, doesn't
19:19:05 <palomer> oh, good point
19:19:11 <Cale> it needs to return something though
19:19:15 <Cale> so it returns ()
19:19:19 <palomer> and then f takes this value and returns another state!
19:19:40 <Cale> another State s a
19:20:08 <Cale> (if you're referring to f in  get >>= f
19:20:09 <Cale> )
19:20:20 <palomer> so evalState (State x) y = fst (x y)
19:20:34 <Cale> yes
19:20:40 <palomer> ok, it's a little clearer now
19:21:08 <Cale> incidentally, execState (State x) y = snd (x y)
19:21:18 * palomer wonders if this would be possible with State s a = State (s -> a) 
19:21:29 <Cale> oh, that's called Reader
19:21:33 <Cale> and it's quite different
19:21:43 <Cale> You can't modify the 'state'
19:21:48 <palomer> so >> just passes the state through, right?
19:21:50 <Cale> only observe it
19:21:53 <Cale> yeah
19:22:08 <Cale> and throws away the result of the first computation
19:22:38 <Cale> data Reader e a = Reader (e -> a)
19:22:38 <palomer> so Reader can only get
19:22:42 <Cale> right
19:22:46 <palomer> and Writer can only put
19:22:49 <palomer> right?
19:22:51 <Cale> yeah
19:22:55 <Cale> though that's a bit funny
19:23:03 <palomer> ok, let's see if I can implement them
19:23:06 <Cale> because how do you know how to put if you can't get?
19:23:27 <Cale> so Writer has the additional requirement that the 'state' type is a monoid
19:23:28 <palomer> Cale: you'll always put the same thing, no?
19:23:42 <Cale> no, you still want to be able to put different things in there
19:24:04 <palomer> you mean Writer type?
19:24:16 <Cale> a good use of the Writer monad is logging some process
19:24:52 <palomer> return a = \_ -> a
19:24:58 <Cale> you can use a list of strings, with concatenation as the monoid operation
19:25:07 <Cale> yep
19:25:23 <Cale> (for Reader)
19:25:42 <Cale> or, more verbosely,  return a = Reader $ const a
19:25:58 <Cale> (if you're using the whole newtype thing)
19:27:06 <palomer> (Reader x) >>= f = Reader $ \y -> f (x y) ?
19:27:46 <Cale> nearly
19:28:11 <Cale> that results in a Reader e (Reader e a)
19:28:32 <palomer> (Reader x) >>= f = Reader $ \y -> runReader f $ (x y) ?
19:28:52 <Cale> pass the environment again
19:29:01 <palomer> hmm?
19:29:39 <Cale> x >>= f = Reader $ \e -> let y = runReader x e in runReader y e
19:30:09 <Cale> mm, sorry
19:30:10 <palomer> is there a reason why it's called runState and runReader?
19:30:21 <Cale> x >>= f = Reader $ \e -> let y = runReader x e in runReader (f y) e
19:30:52 <palomer> oh, right, we need to constantly pass the environment
19:31:01 <Cale> well, you think of a value of type  Reader e a  as a computation which can read from an environment of type e before returning a value of type a
19:31:19 <Cale> runReader runs that computation with a given environment
19:31:38 <palomer> so a >> b = Reader $ \e = runReader b e ?
19:31:46 <Cale> (it just so happens, it's the same as the extractor for the data type because of the way we're representing these computations)
19:32:01 <Cale> yeah
19:32:09 <Cale> >> is kind of stupid in Reader
19:32:19 <Cale> a >> b = b
19:32:25 <palomer> yeah
19:32:33 <palomer> so I'm guessing it's never used
19:32:48 <Cale> yeah
19:33:25 <palomer> then again, is Reader ever used?
19:33:31 <SamB> probably
19:33:37 <palomer> State should be called ReaderWriter
19:33:44 <SamB> palomer: nah
19:33:58 <Cale> State is a nice name, really :)
19:34:02 <SamB> yes!
19:34:05 <palomer> no!
19:34:13 <SamB> it is a state monad
19:34:18 <SamB> therefor it is called State
19:34:21 <palomer> Cale: have you ever used the reader monad in your code?
19:34:35 <SamB> perhaps the ReaderT gets used more...
19:34:46 <Cale> palomer: I can think of cases where it might be handy. I've never really used it.
19:35:07 <SamB> *somebody* must use MonadReader for *something*
19:35:11 <Cale> ReaderT is certainly pretty useful
19:35:34 <SamB> in fact, StateT probably also gets more usage than State
19:35:37 <Cale> The general idea of Reader is useful, even if the plain monad is a bit clunky
19:35:44 <palomer> class MonadState m s | m -> s where  <---what does this mean?
19:35:52 <Cale> The idea is useful for, say, configuration information
19:35:54 <SamB> maybe you'd understand StateT better in some paradoxical kind of way
19:36:02 <Cale> palomer: m determines s
19:36:13 <SamB> palomer: means that the "m" determines the "s"
19:36:19 <SamB> oh, oops.
19:36:35 <palomer> is that special syntax?
19:36:38 <Cale> So that there can be only one instance of MonadState for a given "m"
19:36:48 <Cale> It's a special feature
19:36:53 <SamB> whats it called...
19:36:59 <SamB> functional dependancies?
19:37:01 <Cale> It's a functional dependency
19:37:02 <Cale> yeah
19:37:08 <palomer> hrmph
19:37:11 <palomer> so it's safe to ignore?
19:37:16 <Cale> sort of
19:37:19 <SamB> palomer: yeah
19:37:22 <Cale> it basically makes things nice
19:37:38 <sproingie> how does m determine s?  is that specified elsewhere?
19:37:38 <Cale> so that you don't get errors where types are underdetermined somehow
19:37:47 <SamB> it basically means that you don't need to put a type signature on every single thing...
19:38:04 <SamB> sproingie: it is specified in each instance
19:38:08 <Cale> It just asserts that m must determine s, in the sense that you can't have two different instances with a given m.
19:38:31 <SamB> meaning, the compiler will have to be able to figure out what the dependancy is
19:38:37 <sproingie> so it's more of a hint to the compiler?
19:38:41 <Cale> this means that the type of thing you're getting with 'get' is determined by the monad alone, without extra annotation.
19:38:59 <Cale> that's exactly what it is, as well as a rule which is enforced in the code
19:39:19 <Cale> Functional dependencies are actually very powerful.
19:39:22 <sproingie> i guess i'm still lost.  is state a reasonably simple example of fundeps?
19:39:32 <SamB> sproingie: yeah
19:39:33 <Cale> Fairly simple
19:39:46 <Cale> Not that brutally obvious an application
19:39:50 * sproingie digs around for the code
19:39:57 <SamB> instance MonadState (State s) s, right?
19:40:02 <Cale> right
19:40:34 <SamB> sproingie: see how the second parameter is fully determined by the first parameter?
19:41:17 <SamB> I suppose you could use this to write a special case with unboxing or something...
19:41:24 <Cale> It means that you can't come along and define another  instance MonadState (State s) ()
19:41:49 <sproingie> ah, so both must use the same type?
19:41:53 <Cale> (which is admittedly a stupid instance)
19:42:06 <Cale> yeah, they ought to have something in common
19:42:25 <Cale> not sure if that's quite necessary
19:42:50 <dons> has anyone ever written TH code to generate normal args bindings to varargs functions?
19:42:55 <Cale> Well, do you know about relations (in the mathematical sense)?
19:43:07 <sproingie> not in the mathematical sense, not really
19:43:11 <Cale> You can view multiparameter typeclasses as relations on types
19:43:35 <SamB> newtype IntState a = Int# -> (# Int#, a #)
19:44:11 <SamB> instance MonadState IntState Int
19:44:41 <Cale> hmm
19:45:16 <SamB> or something like that
19:45:28 <SamB> maybe not the (# , #)
19:47:23 <dons> not sure you can do that with kind #
19:47:44 <dons> though I'll be pleasantly surprised if that does compile
19:47:55 <dons> and even more so if it actually runs ;)
19:48:04 <monochrom> hee
19:48:09 <SamB> well, the point is, something of that sort
19:48:18 <dons> I know ghc has trouble with (# x, (# y, z #) #)
19:48:20 <SamB> you might need your own tuple or something
19:48:47 <dons> SamB, who's src code have you been reading that you'd want to do that anyway, eh?
19:49:06 <SamB> well, thats confusing
19:49:06 <SamB> dons: nobodies.
19:49:20 <SamB> I'm just trying to rationalize the usage of fundeps here ;-)
19:49:29 <dons> ah, a worthy cause.
19:49:53 <SamB> like, what would be the point if you weren't interested in specialized instances?
19:50:49 <Cale> SamB: of what?
19:50:59 <Cale> of fundeps?
19:51:28 <Cale> You're not interested in specialised instances, which is why you're using the fundep to prevent them.
19:51:49 <Cale> The fundep strictly limits the instances you could possibly define
19:52:00 <Cale> (afaict anyway)
19:52:06 <SamB> Cale: what do you mean?
19:52:09 <SamB> if you didn't care about them, wouldn't you just do
19:53:07 <Cale> The reason for the fundep is precisely to ease type inference so as to require fewer annotations
19:53:27 <Cale> As a result, say if you had something like
19:53:43 <Cale> well, let's say you didn't have the usual instance for State s
19:53:46 <SamB> oh, because Monad (m :: * -> *)...
19:53:53 <Cale> and you decided you wanted
19:54:04 <Cale> MonadState (State (a,b)) a
19:54:05 <Cale> and
19:54:09 <Cale> MonadState (State (a,b)) b
19:54:14 <SamB> well, it could still potentially be used for something...
19:54:18 <Cale> well, the fundep stops that kind of thing
19:55:05 <Cale> While still letting you have this general interface for different monads, just only one type of state per monad.
19:55:05 <dons> mmm. monadic regions.
19:55:33 <monochrom> monadic regions? sounds neat.
19:55:50 <monochrom> ("monadic ___" sounds neat :) )
19:56:21 <Cale> monochrom: another Oleg goodie
19:56:22 <dons> forall a. Monad a => Neat a
19:56:29 <Cale> heh
19:56:31 <monochrom> haha
19:56:33 <SamB> Cale: personally I thought the point was to avoid typesigs
19:56:42 <Cale> SamB: yes
19:56:48 <SamB> by reassuring the compiler that *it* didn't have to worry about that
19:57:12 <Cale> well, right, but it also ties your hands somewhat as to what instances you're allowed to define
19:57:30 <SamB> Cale: not a whole lot
19:57:45 <SamB> Cale: you just have to pick one and stick with it...
19:58:21 <Cale> SamB: right, in this case, it's not too big a deal, it just means you're only allowed one type of MonadState state per monad.
19:59:34 <SamB> Cale: I mean, you don't see people complaining that they have to newtype their functions to make them Monads
20:00:13 <Cale> hehe
20:00:33 <Cale> well, that's usually more an overlapping instances issue
20:00:44 <Cale> I'm not against using the fundep here, by the way :)
20:00:52 <SamB> its not really any different...
20:01:27 <SamB> Cale: if you were I believe you would repent upon attempting to go without it
20:01:39 <Cale> hehe
20:01:41 <Cale> me too
20:01:43 <Cale> :)
20:03:40 <Cale> but I did want to mention it because it is an important concern when adding your own fundeps to a class
20:04:03 <SamB> ah, yes
20:04:12 <SamB> balance is vital
20:04:23 <Cale> you get some convenience, and often some new things become possible, but you lose flexibility too
20:04:32 <SamB> helps if you own both class and instance types ;-)
20:04:45 <Cale> hehe, yeah
20:05:11 <dons> musasabi, nice, Isaac says regex-dna is legal! :)
20:05:22 <dons> but I need to document the magic a bit.
20:05:29 <sproingie> have we beat C yet?
20:05:37 <SamB> yes, well, rigidity is your friend, as you will discover if you try to do ad-hoc+parametric polymorphism in another language...
20:05:48 <SamB> which is to say if you try to do just about anything in another lang
20:05:53 <Cale> hehe
20:06:10 <sproingie> yay bondage and discipline!
20:06:30 <SamB> of course, you'll also notice the lack of type classes
20:06:32 <Cale> Rigidity is meaning
20:06:48 <SamB> Cale: yes.
20:07:49 <SamB> rigidity in the concrete and flexibility in the abstract are...
20:08:46 * sproingie likes his concrete nice and rigid
20:09:27 <SamB> just try not to scrape your knees on the concrete or get a paper cut on the abstract
20:09:35 <SamB> ;-)
20:09:38 <Cale> You can create a formal system which applies to anything, just the empty formal system. It's completely flexible, but it also doesn't help at all :)
20:10:13 <SamB> Cale: its awfully difficult to apply something empty to anything
20:10:26 <SamB> it keeps slipping out of your grasp!
20:10:35 <Cale> This is one of the problems with category theory, at least, without defining special types of categories, you can't say much.
20:11:30 <SamB> Cale: which is why monads came from denotational semantics
20:11:36 <SamB> you could say that Haskell is applied denotational semantics
20:12:08 <Cale> denotational semantics is just applied formal logic :)
20:12:26 <Cale> (well, a little more than that)
20:12:27 <gzl> beware sentences with "just" in them
20:12:45 <Cale> It does have a really model-theoretic feel to it, from what I've seen of it though.
20:18:49 <monochrom> denotational semantics is applied lattice theory and topology, and on steroid at that.
20:19:54 <monochrom> Though, the applied topology side looks more like logic than topology.
20:22:13 <Cale> Yeah, it looked like they were using the topological names more as a language than as a place where you're going to get a lot of theorems
20:23:08 <Cale> Sort of like how algebraic geometry uses the Zariski topology, but since it's pretty much horrible topologically, you're just using it to automatically name things :)
20:25:40 <dfhaii> is there a website with all the list functions listed
20:26:08 <dfhaii> i have a list containing pairs, wanna check if they're the same thing and if so keep one item from the pair
20:27:51 <Korollary> @docs Data.List
20:27:53 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
20:28:02 <Korollary> You can also use the index
20:28:19 <Korollary> or @hoogle here based on type signatures
20:28:35 <Korollary> @hoogle [a] -> [a]
20:28:37 <lambdabot> Data.List.tail :: [a] -> [a]
20:28:37 <lambdabot> Data.List.init :: [a] -> [a]
20:28:37 <lambdabot> Data.List.reverse :: [a] -> [a]
20:29:03 <dfhaii> thanks
20:30:13 <Cale> @type uncurry (==)
20:30:15 <lambdabot> forall b. (Eq b) => (b, b) -> Bool
20:31:13 <newsham> hi.  Anyone here familiar with DrIFT?
20:36:36 <ptolomy> Say, if I wanted to use a string that wasn't the standard list representation of Chars for speed and space reasons, but still wanted the convvenient functions, what would I use?
20:36:52 <Cale> FastPackedString
20:36:57 <Cale> by dons 
20:37:15 <Lemmih> @where fps
20:37:16 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
20:38:35 <ptolomy> tahnks.
20:43:03 <TheHunter> what do you guys think about this: http://www.haskell.org//pipermail/glasgow-haskell-users/2006-January/009565.html
20:44:54 <dons> ah, I thought you'd be interested in that.
20:46:20 <TheHunter> I just skimmed it, don't have time to deeply investigate it.
20:47:12 <TheHunter> 	k :: forall b. b -> b
20:47:12 <TheHunter> 	k (x::c) = x	-- NO, it can't be both b and c
20:47:23 <TheHunter> 	f :: a -> Bool -> Maybe a
20:47:23 <TheHunter> 	f (x::p) True  = Just x  :: Maybe p
20:47:23 <TheHunter> 	f (y::q) False = Nothing :: Maybe q
20:47:36 <TheHunter> it seems weird that k is forbidden and f allowed.
20:49:45 <TheHunter> ah, I missed that f has no forall in its signature.
20:49:47 <Lemmih> Isn't it because 'x' isn't of type 'a' in 'f'?
20:57:37 <newsham> nobody here familiar with DrIFT?
20:59:38 <Lokadin> drift?
20:59:43 <Lokadin> what's that?
20:59:59 <Cale> It's a tool for automatically writing instances of various classes iirc
21:00:14 <Lokadin> o cool
21:00:32 <Cale> http://repetae.net/~john/computer/haskell/DrIFT/
21:00:35 <newsham> *nod* preprocessor.
21:00:44 <newsham> someone recommended I use it.  I'm trying to now. :)
21:02:58 <newsham> it doesnt seem to be working properly :(
21:03:23 <Cale> what are you using it for?
21:04:03 <newsham> see the big instance declaration at the bottom:  http://www.lava.net/~newsham/x/Pkts5.lhs.txt
21:05:43 <Cale> somehow I figured it would be something like that
21:05:44 <newsham> I'm printing the data structure that DrIFT is passing me and it doesnt have any info in it :(
21:07:31 <dfhaii> 4 hours to write 9 lines of code
21:07:31 <dfhaii> :|
21:07:34 <dfhaii> works though
21:08:06 <ptolomy> dfhaii, I'll assume it is mindbendingly awesome.
21:08:15 <newsham> dfhaii: I bet they are really good lines
21:08:34 <dfhaii> nope, just don't know haskell at all well
21:08:51 <dfhaii> -well
21:09:28 <Cale> Still, 9 lines can be a significant amount of code, depending on what it does :)
21:09:50 <ptolomy> heh. I've found a major plus/minus of haskell is that programming-by-guessing doesn't work well.
21:10:14 <dfhaii> this is true
21:10:16 <Cale> ptolomy: it works quite well if you only guess things which are type-correct
21:10:25 <Cale> :)
21:10:32 <ptolomy> heh.
21:10:33 <dfhaii> if you have done anything with c style syntax you can guess most others
21:10:40 <ptolomy> My brain sucks at type inference.
21:12:47 <newsham> ask your interpretter for types
21:13:41 <Cale> well, you need to be good at doing some type inference in your head to guess things of the right type
21:19:53 <dons> musasabi, ok, I think regex-dna is ready to be comitted: http://www.haskell.org/hawiki/RegexDna
21:20:07 <dons> fingers crossed that that's enough to get us over the line.
21:28:33 <newsham> ok, I'm writing off DrIFT for now.  any other suggestions for preprocessors?
21:53:55 <Lokadin> so i don't get it why is it that haskell discriminates hackers i understand it's an award and all
21:54:00 <Lokadin> but ???
21:55:26 <Korollary> The award itself was phrased like that.
21:55:39 <Lokadin> well does anyone know why
21:55:46 <Lokadin> i mean it's that kind of award
21:55:47 <dons> no, discriminating (in the positive sense) hackers choose to use haskell. begin able to discriminate things is good.
21:55:49 <Korollary> It's their award. Their wording.
21:56:06 <Lokadin> oh okay
21:56:29 <dons> it's seems that 'discriminate' commonly means 'discriminate against other humans' in the US?
21:56:36 <Korollary> no
21:56:53 <Lokadin> dons: yea
21:56:53 <Korollary> that's not the only meaning
21:57:07 <Lokadin> well i now know that i opened a dictionary
21:57:08 <Lokadin> lol
21:57:10 <musasabi> dons: regexdna committed.
21:57:17 <Korollary> http://m-w.com/cgi-bin/dictionary?va=discriminate
21:57:25 <dons> excellent. cheers musasabi
21:57:57 <Lokadin> #
21:57:57 <Lokadin>    1. Able to recognize or draw fine distinctions; perceptive.
21:58:00 <Lokadin>    2. Showing careful judgment or fine taste: a discriminating collector of rare books; a dish for the discriminating palate.
21:58:13 <dons> perceptive. that's what we're looking for. and having fine taste.
21:58:18 <Lokadin> i understand (Y)
21:58:26 <Lokadin> that's a thumbs up btw
21:58:33 <Lokadin> i'm just too used to msn
21:58:48 <dons> it probably should just be: Smart Hackers Chooise Haskell
21:58:59 <dons> without the 'i' ;)
21:59:08 <Lokadin> lol yea
22:00:44 <musasabi> discriminate is correct, but many people don't know the positive meaning of the word.
22:01:02 <Lokadin> yep
22:02:05 <Lokadin> makes it seem like hackers are being discrimnated against as opposed to them doing the discriminating
22:03:08 <Cale> I'm fairly certain that both senses are in reasonably common use. Actually, I'd probably assume the good sense of the word unless it was qualified with "racial" or something like that.
22:03:10 <musasabi> then again we may sometimes discriminate against Cobol or even VB for complex applications ;)
22:04:06 <Lokadin> hmmm
22:04:11 <Cale> Certainly "discriminating" unqualified and without context is a positive adjective to apply to a person or group of people.
22:06:53 <dons> I think a large number of people have unfairly discriminated against haskell's speed and memory consumption.
22:07:14 <Lokadin> i dono i often hear phrases like "don't discriminate" and "they discriminate therefore they are bad" or "discrimination is against the law" 
22:07:15 <^kdonn^> discriminated against?
22:07:51 <dons> well, you need to see how you're discriminating, right? dicriminate :: (a -> Bool) -> a -> Bool
22:07:51 <Korollary> Lokadin: That usage is correct as well. What we're saying is that the usage you're more familiar with is not the only meaning.
22:07:57 <Cale> To discriminate in general is just to classify.
22:08:03 <Lokadin> i know
22:08:09 <Lokadin> i realize i'm just saying
22:08:44 <Cale> "Discrimination is against the law" is certainly false.
22:09:03 <Lokadin> yep
22:09:12 <^kdonn^> i would think: discriminate :: (a -> Bool) -> [a] -> [a]
22:09:28 <Lokadin> it's commonly used as a synonym to racism/sexism/and other ism's
22:09:32 <Korollary> discriminate = filter ?
22:09:38 <^kdonn^> soemthing like that
22:09:41 <dons> @type filter
22:09:42 <dons> yes.
22:09:43 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
22:09:46 <^kdonn^> lazy filter
22:10:06 <dons> if only the dictionary had type annotations
22:10:14 <Korollary> it does
22:10:16 <Cale> I'm pretty sure if you looked at the laws, they'd say something like "Discrimination by race or gender for purposes of employment", and other qualified specific uses.
22:10:19 <Korollary> accusative, etc. heh
22:10:24 <musasabi> english has -fallow-overlapping-instances, thus all the trouble.
22:10:35 <Cale> heh
22:10:39 <dons> ah, true. and unsafeCoerce# is used _all_ over the place
22:10:47 <Lokadin> Cale: i'm sure as well it's just how people speak here
22:11:44 <Cale> "Don't discriminate" sounds sort of zen. :)
22:11:44 <dons> in .au we in fact have an Anti-Discrimination Board
22:12:20 <Cale> All is one.
22:12:26 <Lokadin> .au :D! i've never seen someone do that before that's pretty cool
22:12:37 <Lokadin> lol
22:12:52 <Lokadin> bah i hate carpal tunnel
22:14:01 <Cale> The Anti-Discrimination Board discriminates between Board-members and non-Board-members.
22:14:20 <Lokadin> lol that's pretty funny
22:14:27 <Korollary> No, they just make bad judgements
22:15:22 <Cale> I think they should stop that. Even so, if they kept the name, they'd still be discriminating between something which supposedly exists and nothingness.
22:15:46 <Cale> clearly against their own principles :)
22:19:06 <Lokadin> lol
22:23:24 <^kdonn^> anyone know what a TChan does?
22:23:50 <^kdonn^> the only documentation I find with google is pretty ambiguous
22:26:05 <Korollary> I dont know myself, but I remember seeing some stuff about them in the haskell-cafe mailing list
22:26:56 <mahogny> TChan is used in STM, a lib for handling data atomically with threads
22:27:30 <mahogny> the original paper with the proposal is still the best documentation IMO
22:28:13 <^kdonn^> I read the STM paper, but it doesnt talk about TChan
22:28:18 <^kdonn^> only TVar's
22:28:48 <mahogny> GHC doesn't document them?
22:29:06 <mahogny> data TChan a
22:29:06 <mahogny> TChan is an abstract type representing an unbounded FIFO channel.
22:29:09 <mahogny> there you go
22:29:14 <^kdonn^> ok
22:29:15 <musasabi> TChan is exactly like Chan.
22:29:21 <musasabi> Only for STM instead of IO.
22:29:31 <^kdonn^> okay, so an asynchronous channel
22:29:33 <^kdonn^> ?
22:30:10 <mahogny> asynchronous.. I guess
22:30:10 <musasabi> yes.
23:12:08 <palomer> :o
23:12:20 <palomer> so (>>) in State is useless, right?
23:13:28 <musasabi> quite usefull (if we are talking about the normal State monad)
23:18:05 <palomer> how so?
23:18:08 <palomer> it simply passes on the state
23:18:10 <palomer> nothing more
23:18:37 <palomer> @type \x -> x>>= return
23:18:39 <lambdabot> forall a (m :: * -> *). (Monad m) => m a -> m a
23:19:17 <palomer> @type (>>)
23:19:18 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> m b -> m b
23:21:49 <palomer> \a b -> b
23:22:15 <palomer> @type ((\a b -> b):: forall (m :: * -> *) b a. (Monad m) => m a -> m b -> m b
23:22:17 <lambdabot> parse error (possibly incorrect indentation)
23:22:24 <palomer> @type ((\a b -> b):: forall (m :: * -> *) b a. (Monad m) => m a -> m b -> m b)
23:22:26 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
23:22:42 <palomer> so >> is the same as \a b -> b ?
23:27:00 <palomer> @type \a b -> a >>= const b
23:27:02 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
23:45:19 <gour> dcoutts: ping
