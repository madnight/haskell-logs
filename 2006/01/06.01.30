00:01:08 <Lokadin> say does haskell relate a lot to logic?
00:01:20 <Lokadin> i mean like predicate logic and the like
00:01:33 <Lokadin> or propasitional as it is sometimes called 
00:02:35 <Lokadin> i was just thinking that if it related to a sufficient amount of concepts it could be used as an aide in teaching a course on say logic
00:03:13 <Lokadin> but i personally just started taking a course in logic and don't have sufficient understanding of haskell to know how deep the resemblance can go
00:03:31 <Lokadin> so i was wondering ...
00:03:48 <Lokadin> if Cale or someone else might know
00:04:10 <Lokadin> Cale: you there? or is this one of those once in a week sleeping periods?
00:04:10 <Lokadin> lol
00:05:24 <Lokadin> guess it might be
00:05:49 <Lokadin> hey
00:05:54 <Lokadin> ADEpt: you there?
00:06:31 <Lokadin> bah
00:06:43 <ADEpt> Lokadin: yep
00:06:45 <Lokadin> to think there were people here 8 minutes ago
00:06:46 <Lokadin> o
00:06:48 <Lokadin> :)
00:06:55 <Lokadin> know much about haskell?
00:07:33 <palomer> hrm
00:07:43 <palomer> are there any restrictions on adding to widgets and then displaying?
00:08:03 <ADEpt> Lokadin: hm. I hope so :)
00:08:25 <dcoutts> palomer, don't think so.
00:08:45 <Lokadin> lol :D yea well i was just wondering if there was a lot of similarity between say propasitional logic and haskell
00:08:53 <dcoutts> palomer, are you thinking something in particular?
00:09:18 <Lokadin> or predicate logic, or any particular logic really that you'd find in a first year comp sci course?
00:09:58 <Lokadin> i was just wondering if there could be enough similarity found that it could pass off as an aide in the teaching
00:10:36 <Lokadin> therby sneaking haskell into the mandatory comp sci curriculum of whichever university 
00:10:43 <ADEpt> Lokadin: well, there is enough similarity, IMO. However, Haskell is not a theorem prover, merely a tool to write one ;)
00:11:09 <palomer> containerClear somehow stops me from adding anything to my vbox
00:11:57 <Lokadin> i was just wondering if you think it could be used in such a context as say imperitaive languages certainly don't fit the requirments as far as i understand them anyways
00:12:04 <Lokadin> of making the course simpler that is
00:12:58 <Lokadin> hmmm i can try asking my prof what he thinks actually, but then again i don't even know if he knows what haskell is
00:13:29 <palomer> dcoutts: is it possible that containerClear runs much after it is called?
00:14:00 <dcoutts> palomer, shouldn't do
00:14:11 <dcoutts> palomer, what seems to be happening?
00:14:14 <Lokadin> bah anyways it's 3:13 and i have to wake up at 7 so later!
00:15:24 <palomer> http://www.rafb.net/paste/results/p8Qjj485.html
00:15:38 <palomer> this is part of what happens on the onMotion
00:15:47 <palomer> if I remove the containerClear, then lots of stuff gets added
00:15:55 <palomer> if I keep it, nothing gets added
00:19:50 <dcoutts> palomer, hmm, odd indeed
00:20:37 <dcoutts> palomer, oh I see what you're doing
00:20:43 <dcoutts> palomer, you need to sleep :-)
00:20:52 <dcoutts> palomer, you're clearing the tipWindow
00:20:56 <palomer> yeah
00:20:59 <dcoutts> and then filling the tipBox
00:21:01 <palomer> and then filling it up with addAll
00:21:13 <palomer> oh my god
00:21:13 <dcoutts> but the tipBox was inside the tipWindow
00:21:19 <dcoutts> sleep!
00:21:21 <palomer> yeah, I'm going to sleep in 5 minutes
00:21:26 <palomer> im so close!
00:21:29 <dcoutts> :-)
00:21:32 <ValarQ> :)
00:22:10 <dcoutts> try:
00:22:16 <dcoutts> containerClear tipBox
00:22:20 <dcoutts> addAll tipBox typeStrings
00:22:23 <dcoutts> widgetShowAll tipWindow
00:22:27 <dcoutts> in that order
00:22:44 <dcoutts> otherwise the new bits you add to the tipBox do not get shown
00:22:56 <palomer> dcoutts: last thing: how do I make it so that it's as small as possible?
00:23:00 <dcoutts> palomer, the widgetShowAll only applies at the time, not to thing you add after
00:23:08 <palomer> the tipwindow, that is
00:23:32 <palomer> dcoutts: yeah, I realized that afterwards
00:23:35 <dcoutts> palomer, that should happen automatically
00:23:53 <dcoutts> palomer, set the vbox spacing to 0
00:23:57 <gour> dcoutts: do you hack continuously since yesterday?
00:24:15 <dcoutts> gour, no I got up about an hour ago
00:24:18 <dcoutts> :-)
00:24:32 <dcoutts> gour, but araujo and palomer have been hacking continuously since yesterday!
00:24:45 <gour> dcoutts:oh. ok then. i left you yesterday in a similar mood :-)
00:24:52 <dcoutts> gour, heh :-)
00:24:55 <palomer> oh my
00:25:00 <palomer> the showall are making my cursor dissapear
00:25:03 <palomer> how do I fix this?
00:25:23 <palomer> dcoutts: it doesn't happen, here's a screenshot:
00:25:31 <dcoutts> which cursor?
00:26:17 <palomer> dcoutts: mouse cursor
00:26:35 <palomer> www.magnesium.net/~palomer/bam.jpg
00:26:48 <palomer> 1 sec
00:27:02 <palomer> www.magnesium.net/~palomer/bam.png
00:27:04 <dcoutts> palomer, what the popup window obscures the mouse pointer?
00:27:20 <dcoutts> palomer, ah ok, I see
00:27:24 <palomer> dcoutts: nope, the mouse pointer is below the popup
00:27:33 <palomer> it appears sometimes
00:27:36 <dcoutts> that's very odd
00:28:20 <palomer> oh, it's working again
00:28:28 * palomer just doesn't get it
00:28:31 <palomer> must be a problem on my side
00:28:34 <palomer> (for the cursor)
00:28:45 <dcoutts> the gtktooltip uses gtk_window_set_resizable window false
00:30:44 <palomer> hrm, how do you fix this?
00:30:51 <palomer> (I'm starting to see double:O!)
00:30:55 <dcoutts> palomer, also you might find that using "boxPackStart vbox label1 PackNatural 0" does what you want
00:31:06 <dcoutts> for adding the labels to the vbox
00:31:28 <dcoutts> but the real way to make it all just work is to come back to it later
00:32:09 <palomer> dcoutts: same result
00:32:18 <palomer> dcoutts: but im so close!
00:32:25 <palomer> I can't quit now! I'll be dreaming about it!
00:32:31 <dcoutts> :-)
00:33:02 <gour> palomer: then you'll find a solution, i.e. in a dream ;)
00:33:14 <dcoutts> palomer, to understand Gtk+ packing/layout I usually find that playing around with glade helps
00:33:14 <palomer> oh no, I want to dream of nicer things
00:33:29 <palomer> dcoutts: isn't this a window issue?
00:33:41 * gour has lot of experiences with finding solutions while sleeping (dreaming)
00:33:41 <palomer> ie the window is a certain size, and even if the widget shrinks the window won't?
00:33:53 <dcoutts> palomer, it should shrnk
00:34:00 <dcoutts> it's possible to make it do so
00:34:26 <palomer> but is it the default behaviour?
00:34:27 <dcoutts> I'd have to figure out what it is though :-)
00:34:41 <dcoutts> I thought it was, but seems not
00:35:02 <palomer> it could very well be the widget also
00:35:09 <palomer> since resizable is off by default (or so you claim)
00:35:51 <dcoutts> palomer, ok so yeah, it's getting a default size
00:37:43 <palomer> setResizeMode doesn't fix anything
00:42:29 <palomer> ok, that's it, I'm going to bed
00:42:40 <palomer> cyas
00:42:43 <palomer> and thx!
00:42:52 <dcoutts> g'night palomer 
00:43:50 <gour> happy dreaming, palomer
00:46:27 <gour> dcoutts: yestered you said that gui should be written last. it means one can write the rest and (easily) add gui layer on the top?
00:48:39 <dcoutts> gour, one would hope so
00:49:02 <dcoutts> gour, but it's more likely to be that way if you do the gui last
00:49:26 <dcoutts> the interaction model is different from a text interface however
00:50:31 <gour> that's why i'm asking how difficult it could be to migrate from text --> gui interface
00:51:09 <dcoutts> it depends on what you're doing
00:51:48 <gour> dcoutts: but you recommend to start with text interface?
00:52:21 <gour> dcoutts: i'm sure there are lot of things that will be 'pure'
00:52:37 <dcoutts> gour, I reccomend keping as much of the program as possible pure
00:52:44 <dcoutts> and gainv only a thin gui layer
00:53:01 <dcoutts> so developing the core logic of the program first is probably a good idea
00:53:16 <gour> thanks, that's what i wanted to know
00:54:16 <gour> i did not start working on bindings for that ephemeris lib, but i see that many funcs are 'almost' pure, passing just a char* in case of error
00:55:01 <gour> dcoutts: would it be possible to have 'pure' function in haskell and handle error exceptions separately?
00:55:16 <dcoutts> gour, yes
00:55:33 <dcoutts> you can throw exceptions in pure code and catch them in IO
00:56:05 <gour> great, e.g. int swe_calc_ut ( double tjd_ut, int ipl, int iflag, double* xx, char* serr)
00:56:20 <gour> char* serr is used just in case of error
01:08:31 <Saulzar> Applies equally for imperitive programs, it's too easy to fall into the trap of having everything-in-the-gui
01:09:23 <gour> true
01:17:15 <gour> anyone has experience with unison? (need a tool to sync laptop <--> deskop )
01:17:30 <boegel> gour: darcs ! :P
01:17:42 <aleator> gour: kinda works..
01:17:51 <gour> really? how?
01:18:22 <gour> i believe lot of mp3s will choke it
01:39:55 <ulfdoz> q/gone
02:50:21 <gour> dcoutts: ping
02:51:51 <beelsebob_> @seen JaffaCake
02:51:51 <lambdabot> I saw JaffaCake leaving #haskell 3 days, 17 hours, 43 minutes and 19
02:51:51 <lambdabot> seconds ago, and I have missed 4 seconds since then.
02:51:55 <beelsebob_> damn
02:52:20 <beelsebob_> can lambdabot tell give people messages these days?
02:52:33 <beelsebob_> @listcommands
02:52:33 <lambdabot> use listcommands [module|command]. Modules are:
02:52:33 <lambdabot> babel base code compose dice dict djinn dummy dynamic elite fact haddock
02:52:33 <lambdabot> help hoogle karma lShell localtime more pl plugs poll pretty quote search
02:52:33 <lambdabot> seen spell state system todo topic type version vixen where
02:52:57 <beelsebob_> @listcommands todo
02:52:58 <lambdabot> todo provides: todo todo-add
02:53:24 <beelsebob_> @todo-add "@tell command to make lambdabot give someone a message when they're next seen"
02:53:24 <lambdabot> Entry added to the todo list
02:53:28 <beelsebob_> @todo
02:53:29 <lambdabot> 0. SamB: A way to get multiple results from a google search
02:53:29 <lambdabot> 1. SamB: @get-shapr summons shapr instantly
02:53:29 <lambdabot> 2. SamB: stop mangling long urls
02:53:29 <lambdabot> 3. dons: improve formatting of @dict
02:53:29 <lambdabot> 4. dons: write Haskell Manifesto
02:53:31 <lambdabot> [22 @more lines]
02:53:45 <beelsebob_> @get-shapr
02:53:46 <lambdabot> shapr!!
02:53:50 <beelsebob_> *g*
02:55:20 <alar> poor shapr
02:55:35 <beelsebob_> hehe
02:55:41 <alar> once in a while someone finds this command and tests it
02:55:47 <beelsebob_> his fault for accepting being lambdabot's bitch
02:57:37 <beelsebob_> @todo-add "@remind command formatted as '@remind <person> {at <time> | in <time interval>} {to | about} <reminder message>' to get lambdabot to remind someone to do something"
02:57:37 <lambdabot> Entry added to the todo list
02:57:38 <alar> I suppose he compensates for some missing functionality in lambdabot =)
02:57:45 <beelsebob_> lol
03:01:56 <beelsebob_> @todo-add "@pester command to make lambdabot pester you in PM to do something"
03:01:57 <lambdabot> Entry added to the todo list
03:02:02 <beelsebob_> @todo
03:02:02 <lambdabot> 0. SamB: A way to get multiple results from a google search
03:02:02 <lambdabot> 1. SamB: @get-shapr summons shapr instantly
03:02:02 <lambdabot> 2. SamB: stop mangling long urls
03:02:02 <lambdabot> 3. dons: improve formatting of @dict
03:02:02 <lambdabot> 4. dons: write Haskell Manifesto
03:02:04 <lambdabot> [27 @more lines]
03:02:04 <beelsebob_> @more
03:02:06 <lambdabot> 5. lispy: don't let lambdabot's prettyprinter split the sequence @foo
03:02:08 <lambdabot> across lines
03:02:10 <lambdabot> 6. TheHunter: priviledged users should get priviledged listcommands.
03:02:12 <lambdabot> 7. TheHunter: @type 1 :: Int
03:02:14 <lambdabot> 8. lispy: haddock gives a link from a type signature to the types.  It
03:02:16 <lambdabot> [22 @more lines]
03:02:20 <beelsebob_> @more
03:02:20 <lambdabot> would be nice if it also let you find functions in the given module that
03:02:20 <lambdabot> use a type.
03:02:22 <lambdabot> 9. dons: Implement @whatis
03:02:24 <lambdabot> 10. dcoutts: implement @cool list, as a clone of the @todo(-add) commands
03:02:26 <lambdabot> 11. dons: there's some bug in the 'when i left' code of @seen
03:02:28 <lambdabot> [17 @more lines]
03:02:35 <beelsebob_> @more
03:02:35 <lambdabot> 12. dons: sarahbot style @tell
03:02:35 <lambdabot> 13. beelsebob_: @tell command - relays a message to someone when they
03:02:35 <lambdabot> next speak
03:02:36 <lambdabot> 14. dons: @seen on lambdabot should report lambdabot's channels too
03:02:38 <lambdabot> 15. ski: when printing first lines of infinite things (or all cases with
03:02:40 <lambdabot> [12 @more lines]
03:02:49 <beelsebob_> @more
03:02:50 <lambdabot> nonexact), should say 'at least'
03:02:50 <lambdabot> 16. ski: provide '@more <number>', at least for privmsg
03:02:50 <lambdabot> 17. ski: '@todo-remove <number>' for priviledged users, and possibly the
03:02:50 <lambdabot> user who added the todo note (is @todo-replace worth it ?)
03:02:50 <lambdabot> 18. dons: BUG: @pl (\_ -> return ()) --> const return
03:02:52 <lambdabot> [7 @more lines]
03:02:59 <beelsebob_> @more
03:02:59 <lambdabot> 19. beelsebob_: "@tell command to make lambdabot give someone a message
03:02:59 <lambdabot> when they're next seen"
03:02:59 <lambdabot> 20. beelsebob_: "@remind command formatted as '@remind <person> {at <time>
03:03:00 <lambdabot> | in <time interval>} {to | about} <reminder message>' to get lambdabot
03:03:02 <lambdabot> to remind someone to do something"
03:03:04 <lambdabot> 21. beelsebob_: "@pester command to make lambdabot pester you in PM to do
03:03:06 <lambdabot> something"
03:03:18 <beelsebob_> oh... I didn't realise I set that ages ago
03:03:35 <beelsebob_> oh well, guess I have a use for @todo-remove
03:04:09 <beelsebob_> @pl (\_ -> return ())
03:04:10 <lambdabot> const return
03:37:57 <alar> Hugs spit @ record syntax
03:38:05 <alar> what am I doing wrong?
03:38:40 <alar> data DChan = DC (did::String,dname::String,dnorm::String)
03:38:41 <beelsebob_> dunno... what's the code look like?
03:38:51 <beelsebob_> you need braces not parenthesies
03:39:16 <alar> ah
03:39:24 <alar> how stupid I am
03:39:34 <beelsebob_> no... record syntax is just a tempramental bitch
03:40:03 <alar> @karma+ beelsebob
03:40:04 <lambdabot> beelsebob's karma raised to 2.
03:40:10 <beelsebob_> :D
03:40:59 <alar> I've used records only once or twice before, didn't remeber the syntax :)
03:41:48 <pejo> I have an evaluation context which I intend to make smaller by removing stuff from it. What is a good word for that? I can't find any opposite of 'extend' that seems suitable.
03:42:25 <alar> expand
03:42:40 <alar> ah, opposite
03:43:06 <alar> reduce/shorten
03:43:21 <alar> intend =)))
03:43:23 <Speck> @karma Speck
03:43:24 <lambdabot> You have a karma of 1
03:43:42 <Speck> I wish it would keep track of who @karma+'ed you
03:44:02 <binary42> @karma + lambdabot
03:44:03 <lambdabot> + has a karma of 0
03:44:17 <binary42> @karma+ lambdabot
03:44:18 <lambdabot> lambdabot's karma raised to 10.
03:44:22 <binary42> :-)
03:45:24 <Speck> actually, karma should be based on the karma of the person who karma+s that person, kinda like pagerank but useless
03:45:44 <binary42> Good idea. You ought to tell dons that.
03:46:18 * Speck goes to get fresh bagels
03:47:18 <beelsebob_> yay for bagels
03:47:31 <beelsebob_> bah... I need tic tacs
03:47:33 <beelsebob_> nasty :(
03:47:55 <beelsebob_> oh... gum... yay :)
04:02:11 <alar> it's odd: I have to use {,} in type construction but space in data construction
04:02:24 <alar> inconsistency :(
04:04:15 <jethr0> has anyone used the FGL graph library before?
04:04:28 <shapr> me me! pick me!
04:05:03 <shapr> Ok, I haven't used it that much, but it sure is cool.
04:05:23 <jethr0> hehe, i'm having ghasthly typing problems with "Data.Graph.Inductive.Graph"
04:05:24 <shapr> I especially like the incremental inductive approach.
04:05:50 <jethr0> have you used any functions on (Graph gr)?
04:05:59 <shapr> um, not sure...
04:06:08 * shapr looks at his Data.Graph prototyping sources...
04:06:10 <jethr0> i'll paste sth
04:06:52 * beelsebob_ wonders where the haskell' mailing list is
04:07:10 <shapr> beelsebob_: haskell.org/$SOMETHING/haskell-prime
04:07:17 <shapr> probably mailman/
04:07:18 * shapr checks
04:07:35 <shapr> beelsebob_: http://haskell.org/mailman/listinfo/haskell-prime
04:07:41 <beelsebob_> cool, cheers
04:08:03 <alar> maybe someone  can tell me epigram mailing list addr?
04:08:43 <edwinb> to subscribe?
04:08:51 <alar> yes
04:08:55 <edwinb> majordomo@dur.ac.uk
04:08:57 * beelsebob_ now wonders where the haskell' wiki is
04:09:00 <edwinb> subscribe epigram in the body. I think.
04:09:13 <lisppaste2> jethr0 pasted "studid FGL" at http://paste.lisp.org/display/16201
04:09:30 <alar> thanks!
04:09:59 <alar> I'll post some stupid newbie questions in a while
04:10:10 <edwinb> excellent :)
04:10:19 <beelsebob_> okay... google would appear to have done something extremely clever
04:10:28 <beelsebob_> (not that this isn't rare, but wow to this one...)
04:10:30 <jethr0> shapr: don't be confused by the "()"s. i've tried it with numbers too :(
04:10:43 <beelsebob_> any link I click directly linked from google is highlighted with the search term
04:10:51 <beelsebob_> I don't have google toolbar, and I am actually at the page
04:10:55 <beelsebob_> so... wtf!
04:12:49 <jethr0> shapr, any ideas?
04:13:03 <jethr0> "esp" comes from Data.Graph.Inductive.Query.BFS
04:14:40 <Saulzar> jethr0, You're returning a "gr" which is a typeclass, and not a concrete data type...
04:15:37 <jethr0> Saulzar: k, so what would the concrete type be?
04:15:51 <vincenz> jethr0: hi
04:15:52 <Saulzar> What is an instance of gr?
04:16:10 <jethr0> http://www.haskell.org/ghc/docs/latest/html/libraries/fgl/Data-Graph-Inductive-Graph.html#t%3AGraph
04:16:17 <jethr0> Saulzar: i don't know
04:16:19 <jethr0> vincenz: hi
04:17:05 <jethr0> Saulzar: i have a graph of "Data.Graph.Graph" and want to find shortest paths... for this i have to have a Graph of type "Graph gr" or sth.
04:17:27 <vincenz> jethr0: found the digraph issue?
04:17:35 <jethr0> digraph?
04:17:45 * beelsebob_ probably just started a flame war on the haskell-prime list :)
04:17:49 <vincenz> jethr0: yeah your comment said that Graph wasn't directed
04:18:10 <jethr0> vincenz: i haven't looked into that... trying to get shortest f*cking path to work
04:18:22 <Saulzar> Trouble is you're calling path on something which could be any type of Graph, since your "g" is generic for any graph
04:18:30 <vincenz> jethr0: ah, committed anything yet? (
04:18:39 <jethr0> try :)
04:18:44 <jethr0> but nothing great
04:18:50 <vincenz> jethr0: from last night?
04:18:59 <jethr0> don't remember
04:19:21 <vincenz> jethr0: since when you been busy?
04:20:00 <Saulzar> I have no idea what all the parameters about, there must be some concrete instance of graph listed in the docs somewhere.. :)
04:20:04 <jethr0> Saulzar: it says "instances of class Graph are: Graph, Gr". but i can't find no data type "DIG.Graph"
04:20:20 <Saulzar> Ah hah
04:20:22 <Saulzar>  
04:20:22 <Saulzar> Operations 
04:20:22 <Saulzar> Graph Folds and Maps 
04:20:22 <Saulzar> Graph Projection 
04:20:22 <Saulzar> Graph Construction and Destruction 
04:20:24 <Saulzar> Graph Inspection 
04:20:26 <Saulzar> Context Inspection 
04:20:42 <Saulzar>   Static and Dynamic Inductive Graphs 
04:20:44 <Saulzar>   Synopsis
04:20:46 <Saulzar>   type Node = Int
04:20:48 <Saulzar>   type LNode a = (Node, a)
04:20:50 <vincenz> jethr0: join meta-science?
04:20:52 <Saulzar>   type UNode = LNode ()
04:20:54 <Saulzar>   type Edge = (Node, Node)
04:20:56 <Saulzar>   type LEdge b = (Node, Node, b)
04:20:58 <Saulzar>   type UEdge = LEdge ()
04:21:00 <Saulzar>   type Adj b = [(b, Node)]
04:21:02 <Saulzar>   type Context a b = (Adj b, Node, a, Adj b)
04:21:04 <Saulzar>   type MContext a b = Maybe (Context a b)
04:21:07 <wilx> wth?!
04:21:08 * beelsebob_ wonders if Saulzar needs a pasteboard
04:21:10 <Saulzar>   type UContext = ([Node], Node, [Node])
04:21:12 <Saulzar>   type Decomp g a b = (MContext a b, g a b)
04:21:14 <Saulzar>   type GDecomp g a b = (Context a b, g a b)
04:21:18 <Saulzar>   type UDecomp g = (Maybe UContext, g)
04:21:22 <Saulzar>   type Path = [Node]
04:21:23 <beelsebob_> Saulzar: stop spamming!
04:21:24 <Saulzar>   newtype LPath a = LP [LNode a]
04:21:26 <Saulzar>   type UPath = [UNode]
04:21:28 <Saulzar>   class Graph gr where
04:21:30 <Saulzar>   empty :: gr a b
04:21:32 <Saulzar>   isEmpty :: gr a b -> Bool
04:21:33 <xerox> Poor Saulzar :-\
04:21:34 <Saulzar>   match :: Node -> gr a b -> Decomp gr a b
04:21:39 <jethr0> Saulzar: wtf. i'm on the same page :)
04:21:40 <Saulzar>   mkGraph :: [LNode a] -> [LEdge b] -> gr a b
04:21:42 <Saulzar>   labNodes :: gr a b -> [LNode a]
04:21:44 <Saulzar>   matchAny :: gr a b -> GDecomp gr a b
04:21:46 <Saulzar>   noNodes :: gr a b -> Int
04:21:48 <Saulzar>   nodeRange :: gr a b -> (Node, Node)
04:21:51 <ProfTeggy> Eehm...
04:21:52 <Saulzar>   labEdges :: gr a b -> [LEdge b]
04:21:54 <Saulzar>   class Graph gr => DynGraph gr where
04:22:09 <xerox> :)
04:22:15 <jethr0> Saulzar: i've tried using mkUGraph, but it returns a "gr () ()" and you said that wasn't valid?!??
04:22:19 <ProfTeggy> Martin Erwig will be delighted
04:22:37 <jethr0> *grr*, me can't figure out how to use FGL
04:22:47 <vincenz> jethr0: two seconds
04:22:50 <ProfTeggy> jethro?
04:23:03 <vincenz> jethr0: and join meta-science
04:23:23 <Saulzar> Erk, sorry.
04:23:40 <Saulzar> Meant to paste one line and for some reason the whole page was pasted.
04:23:52 <xerox> No problem :-)
04:23:56 <Saulzar> What I meant to paste was, take a look under: "Types Supporting Inductive Graph View"
04:24:08 <Saulzar> Gives some concrete instances of Graph
04:24:35 <vincenz> Saulzar: what's this link
04:25:08 <Saulzar> It's a sub heading at the page jethr0 pasted earlier
04:25:08 <jethr0> Saulzar: constructing a graph is no problem. i did that before. but when using it i get this stupid type error. and i don't know why
04:25:28 <jethr0> http://www.haskell.org/ghc/docs/latest/html/libraries/fgl/Data-Graph-Inductive-Graph.html#t%3AGraph
04:26:03 <Saulzar> jethr0, Yes, because ppath is passing "g" (which has no fixed type)
04:26:20 <jethr0> Saulzar: any ideas how to solve this?
04:27:09 <Saulzar> I guess you'd give "g" a specific type
04:27:41 <vincenz> jethr0: what is the difference with what you had yesterday, that seemed to work
04:28:11 <vincenz> jethr0: I think I know what it is
04:28:20 <vincenz> jethr0: Graph is the generic one... you want an implementation
04:28:29 <vincenz> for instance Tree (tree bassed implementation)
04:29:22 <jethr0> Saulzar: i did it. i just typed the return of "makeUGraph" as a "Data.Graph.Inductive.Tree.Gr" and it worked
04:29:30 <vincenz> :)
04:29:33 <vincenz> jethr0: commit?
04:29:37 <jethr0> but i thought the type system should have helped me...
04:29:41 <jethr0> vincenz: not using it yet
04:29:52 <vincenz> jethr0: yea but I'd like an idea so I can start working on cop
04:29:58 <Saulzar> Well, it is ambiguous... which is the problem
04:30:27 <jethr0> saulzar: hmm, just confused
04:30:38 <Saulzar> It could work for any of those instances of Graph, right?
04:30:46 <jethr0> because i couldn't find another instance that "Tree.Gr"
04:30:58 <vincenz> jethr0: well if people ever make other ones....
04:31:03 <jethr0> *grr*
04:31:17 <carp> fairp.
04:31:41 <Saulzar> Hmm
04:34:24 <kzm> For optimization purposes, I want a variable to hold a map of Ints when that is enough, but with the ability to overflow to Integer if necessary.  I think I need some quanitfication tricks to do it.  Any hints?
04:35:00 <wilx> Interesting.
04:35:02 <Saulzar> I think that's what Integer does already
04:35:25 <kzm> I.e. I want to do something like: x = if large then foo :: Foo Integer else foo :: Foo Int
04:36:07 <kzm> Saulzar: I think there is some overhead - in particularly space-wise.  Could be wrong, and I can do the benchmark fairly easily.
04:36:37 <Saulzar> Yes, but you're going to have overhead too, and it probably makes little sense to have 2 lots of indirection...
04:37:11 <Saulzar> Though you could do an existential of Integral or something
04:37:31 <kzm> I don't want a discriminated union type, I want to select either Foo Int or Foo Integer.
04:38:25 <kzm> The Integral thing was what I had in mind, but I'm only vaguely intimate with the quantification stuff.
04:41:35 <Saulzar> Trouble is, when you do that you lose the ability to manipulate it except with the Integral interface.
04:41:50 <Saulzar> You also don't get away from overhead, since it passes a dictionary with your value (I think)
04:42:26 <Saulzar> > let x :: forall a. Integral a => [a]; x = [1, 2, 3, 48888888888888888888] in sum (map fromIntegral x)
04:42:26 <lambdabot>  parse error on input `=>'
04:44:30 <Saulzar> Hmm, that's the wrong one
04:47:15 <kzm> I don't mind being limited to Integral functions.  Anyway, I worked around it.
04:48:00 <kzm> Made a polymorphic main_continue function, and if large then main_continue foo :: Int else main_continue foo :: Integer :-)
04:49:29 <Saulzar> Ah, I was thinking you wanted each element to be different :)
04:50:20 <kzm> I see. No.  Anyway, it works (apparently).  Using Integer is only a bit slower (so far).
04:50:30 <kzm> My main concern is space anyway.
05:00:25 <Speck> yampa is really cool; I just wish there were more high-level apis built on top of it so I wouldn't have to worry about the nitty-gritty :-(
05:02:39 <Saulzar> Hmm, what kind of high level API could be built for it? Talking game frameworks or?
05:03:40 <Speck> domain specific stuff I guess... like fruit; but even fruit is too complicated!
05:03:52 <Saulzar> Hmm.
05:04:25 <Speck> I should really just try my hand at writing one, like a dialect for SMIL animations or something, just to see if it's possible
05:06:14 * shapr swears at Python
05:06:21 * shapr stabs Python with a dull spoon.
05:06:27 <Speck> uh oh
05:07:07 <carp> apparently so, news to me
05:07:23 <carp> wrong window
05:07:32 <shapr> carp: News to me too.
05:08:17 <shapr> jberg: Sorry, I got distracted by paying work, did you get Data.Graph to talk nice to you?
05:08:33 <shapr> I found some Data.Graph demo code I got from poetix.
05:08:55 <shapr> doh, jethr0 
05:09:00 * shapr is still distracted.
05:09:01 * Speck forks a brain-thread to think about a SVG authoring library for haskell using Yampa to model user interaction :-|
05:10:38 <xerox> shapr: I got distracted in drawing for two days, heh!
05:12:18 <vincenz> how do you use where clauses in conjunction with do?
05:12:21 <vincenz> xxx = do
05:12:24 <vincenz>    state <- getState
05:12:26 <vincenz>     blablab (me)
05:12:31 <vincenz>     where me = something state
05:12:42 <musasabi> Is getFileStatus from System.Posix.Files supported under Windows?
05:12:47 <xerox> vincenz: indent the where another time
05:12:58 <vincenz> xerox: how does it know where to place this?
05:13:04 <xerox> do ..
05:13:06 <xerox>    ..
05:13:11 <xerox>      where .. = ..
05:13:15 <vincenz> xerox: right but the where depends on stuff coming from <-
05:13:19 <vincenz> do ...
05:13:21 <vincenz>  ...
05:13:24 <vincenz>    a <- xxx
05:13:27 <xerox> no.
05:13:27 <vincenz>      ..
05:13:31 <vincenz>    where  b = .. a
05:13:32 <xerox> hehe
05:13:46 <vincenz> not feasible?
05:13:48 <xerox> I think it's possible
05:14:13 <vincenz> does the where have access to that lexical context?
05:14:46 <shapr> xerox: What did you draw?
05:14:57 <musasabi> hmm, seems unsupported.
05:16:05 <musasabi> How is one supposed to copy the contents of directory "foo" under "bar" and work if "bar" happens to be a subdirectory of "foo" (just ignore it) on Windows?
05:16:05 <dcoutts_> gour, pong
05:17:04 <Speck> anyone read any good papers lately? I'm out of reading material
05:17:46 <shapr> Speck: I have bunches
05:18:24 <Speck> shapr: I'll take anything, I've been reading mostly about FRP and I'm tired of it
05:18:32 <shapr> "abstraction and performance from explicit monadic reflection" by McBride et al
05:18:42 <Speck> I like McBride et al
05:18:51 <shapr> aka 'Idiom Lite' referring to his haskell mailing list posts, and associated submonaci library.
05:18:53 <Speck> epigram is super cool
05:18:57 <shapr> er wait
05:18:59 <shapr> wrong title
05:19:09 <shapr> "applicative programming with effects" sheesh
05:19:28 <shapr> The previous title is another neat paper.
05:19:38 <shapr> 'arrows for invertible programming'
05:19:44 <Speck> that's a good one :-)
05:19:52 <shapr> 'bayesian suprise attracts human attention'
05:20:05 <shapr> 'finger trees a simple general purpose data structure'
05:20:18 <shapr> 'verifying haskell programs using constructive type theory'
05:20:47 <shapr> 'derivatives of containers' by Altenkirch, McBride, et al
05:21:14 <Speck> cool
05:21:22 <Speck> that should be enough for now :-) thanks!
05:21:50 <Speck> oh anything accessible on index types?
05:21:50 * shapr can list a bunch more...
05:22:01 <shapr> index types?
05:22:40 <Speck> from dependent type research, I think Hongwei Xi
05:23:23 <Speck> but I can't understand what those people are saying yet :-P
05:23:59 <pejo> shapr, about that data languages article - the guy said "Ping me tomorrow". Apparently the implementation wasn't ready, and he didn't seem sure about what state it was in.
05:31:55 <SamB> somebody needs to clean out that todo-list...
05:32:06 <SamB> someone who lambdabot listens to...
05:34:20 <vincenz> how do you create a data type (like) ABC x y
05:34:23 <vincenz> but with named parameters?
05:34:28 <vincenz> ABC{x=x, y=y}?
05:35:06 <SamB> you don't, sorry :-(
05:35:12 <vincenz> you DONT?
05:35:27 <vincenz> SamB: assuming
05:35:36 <SamB> we don't even have named parameters to functions
05:35:37 <beelsebob_> you do... you use a record
05:35:45 <vincenz> data ABC a b = ABC{ p :: a, q::b}
05:35:50 <beelsebob_> indeed
05:35:53 <vincenz> right
05:35:55 <vincenz> so now I just do
05:36:00 <vincenz> ABC { p = a, q=b}
05:36:04 <vincenz> and it'll complain if I leave something out?
05:36:07 <SamB> oh, I thought you meant type parameters ;-)
05:36:28 <beelsebob_> ABC {p = (x::a), q = (y::b)}
05:36:40 <beelsebob_> except that those type annoctatinos aren't allowed until Haskell'
05:36:42 <SamB> vincenz: it usually complains when I do, but it might not by default...
05:36:44 <vincenz> beelsebob_: I need to typeify?
05:36:59 <vincenz> why the typesigs?
05:37:00 <beelsebob_> vincenz: no... I was merely pointing out that you put values there, not types
05:37:06 <vincenz> right, that's what I meant :)
05:37:09 <SamB> if it doesn't complain by default, there is a -W option to make it do so
05:37:21 <beelsebob_> because a and b had already been used to refer to types
05:39:44 <beelsebob_> interesting... my proposal hasn't actually come up against any opposition
05:40:12 <SamB> beelsebob_: proposal?
05:40:31 <SamB> I'm not on the Haskell' list...
05:40:38 <beelsebob_> SamB: make '--' a comment, rather than requiring a space after it
05:40:50 <SamB> Beelsebob: hmm.
05:40:51 <beelsebob_> we don't after all reserve {-> for being an operator
05:41:00 <beelsebob_> so why should we be inconsistant and reserve -->
05:41:24 <SamB> hmm?
05:41:27 <Saulzar> yampa has an operator -->  :)
05:41:29 <SamB> oh.
05:41:30 <beelsebob_> it makes it (a) inconsistant with other language features (b) confusing for newbies (c) inconsistant with most syntax highlighters
05:41:54 <beelsebob_> Saulzar: lucky that Simon Thompson is considering writing the "make Haskell'" refactoring in Hare
05:42:10 <SamB> which syntax highlighters?
05:42:22 <SamB> and you have to admit that { isn't a valid operator character
05:42:32 <beelsebob_> most ones on Windows, the SubEthaEdit one, and I'm not sure about the vi and emacs ones
05:42:39 <Saulzar> Kdevelop gives --> as a comment
05:42:58 <SamB> the emacs one seems to be accurate
05:43:11 <kosmikus> (c) hardly counts as a failure of Haskell
05:43:14 <SamB> at first I thought it was a bug, but then I tried to load my code, and it didn't work ;-)
05:43:31 <beelsebob_> kosmikus: no, but it adds to the confusion
05:44:31 <SamB> > "Hello" {-> <-}
05:44:33 <lambdabot> "Hello"
05:45:13 <beelsebob_> > let (-->) = ($) in "Hello" --> ++ " World"
05:45:14 <lambdabot>  parse error on input `++'
05:45:26 <beelsebob_> oh... bugger, infix operator precidence
05:45:42 <SamB> > let (-->) = (++) in "Hello" --> " World"
05:45:43 <lambdabot> "Hello World"
05:45:54 <beelsebob_> indeed
05:45:56 <SamB> beelsebob_: you just aren't allowed two infix ops in a row
05:46:02 <beelsebob_> > let (-->) 
05:46:03 <lambdabot>  parse error (possibly incorrect indentation)
05:46:04 <beelsebob_> bah
05:46:15 <beelsebob_> > "Hello" -- > "World"
05:46:16 <lambdabot> "Hello"
05:46:21 <beelsebob_> confusing that is
05:46:22 <SamB> > let in ()
05:46:23 <lambdabot> ()
05:48:48 <Si\> Has anyone ever written anything setting forth guidelines for "acceptable" uses of unsafePerformIO?
05:49:03 <beelsebob_> Si\: It's very hard to define
05:49:16 <Si\> I know, that's why I'm asking
05:49:29 <shapr> Si\: I've heard "as long as it doesn't change semantics."
05:49:29 <beelsebob_> I use it for example to grab text from a file at the very end of a program and display it
05:49:43 <SamB> do you want to do anything?
05:49:50 <SamB> shapr: change them from what?
05:50:16 <beelsebob_> > let (--) (x:xs) ys | ys `List.isPrefixOf` (x:xs) = (drop (length ys) (x:xs)) -- ys | otherwise = x:(xs -- ys)
05:50:16 <lambdabot>  parse error (possibly incorrect indentation)
05:50:22 <beelsebob_> hehe, no, didn't think so
05:50:39 <beelsebob_> > let (--) (x:xs) ys | ys `List.isPrefixOf` (x:xs) = (drop (length ys) (x:xs)) -- ys | otherwise = x:(xs -- ys) in "jam" -- "a"
05:50:40 <lambdabot>  parse error (possibly incorrect indentation)
05:52:53 <Si\> Ok, so to put it another way - which is better to abuse type-classes or use unsafePerformIO (in general, and if the latter is guaranteed safe)
05:53:09 <SamB> Si\: abuse type classes?
05:53:15 <SamB> how do you do that?
05:53:50 <SamB> and generally it is best to consider unsafePerformIO on a case-by-case basis, I think...
05:54:11 <Si\> use overlapping/undecidable instances
05:54:30 <dcoutts_> @seen Lemmih
05:54:31 <lambdabot> I saw Lemmih leaving #haskell-blah and #haskell 2 days, 22 hours, 13
05:54:31 <lambdabot> minutes and 24 seconds ago, and I have missed 4 seconds since then.
05:55:14 <Si\> for example, if I want to define an optional property for _every_ type in Haskell (i.e. Maybe Thing) which can be changed, I can either use overlapping instances to define a base instance for a, or use a file based type-mapping database
05:55:20 <SamB> Si\: how is this an alternative to unsafePerformIO?
05:56:59 <SamB> you could maybe use Data.Typeable...
05:57:05 <Si\> You can effectively fake type-classes with unsafePerformIO in fact with a global type-mapping database
05:57:20 <Si\> yes I can, but Data.Typeable isn't defined for every type
05:57:42 <Si\> and yes, I would use typeOf to allow a Map TypeRep Property base
05:57:45 <SamB> how are you going to look things up in the database if they aren't Typeable?
05:58:06 <SamB> and what is the point of all this?
05:59:18 <Si\> sorry, yes you're right you'd have to have them all as being Typeable, what I mean to say is Typeable only defines a single property
05:59:47 <SamB> so, what are you trying to *do*?
06:00:37 <Si\> Ok, imagine I'm trying to create a foreign type schema-definition for a Haskell data-type
06:01:03 <SamB> eh?
06:01:29 <Si\> like XML Schema or Relax-NG or IDL
06:02:13 <SamB> okay...
06:02:23 <SamB> I don't see why anyone would ever want to create an XML Schema, but okay...
06:02:43 <SamB> (Relax NG being so much nicer)
06:03:12 <Si\> agreed, but moving on
06:04:05 <vincenz> @pl (\(x,y) -> (y,x))
06:04:05 <lambdabot> uncurry (flip (,))
06:04:14 <Si\> so I take my alg data-type which is made of a bunch of types, some of which already have schema definitions (like Ints, Strings and so on) and some of which also need type strucutres defining for them (e.g. other alg types)
06:04:21 <Si\> how do I figure out which is which?
06:06:01 <SamB> not sure.
06:06:49 <Si\> precisely, I can use Data.Generics to figure out the type of child-type
06:07:00 <Si\> each child-type even
06:07:04 <beelsebob_> @pl (\(x,y,z) -> (z,y,x))
06:07:05 <lambdabot> (line 1, column 7):
06:07:05 <lambdabot> unexpected ","
06:07:05 <lambdabot> expecting letter or digit, operator or ")"
06:07:05 <lambdabot> ambiguous use of a non associative operator
06:07:20 <Si\> but I can't tell if something _doesn't_ have an instance of a particular type-class
06:07:23 <SamB> I'd probably use some kind of typecase...
06:07:58 <SamB> or I'd just make everything be in my typeclass
06:08:27 <Si\> so I have to either avoid type-classes altogether by defining a data-base : Map TypeRep ForeignType, and then work out whether another type needed mapping by inclusion
06:09:09 <Si\> or somehow define a default instances for any type which would define that it doesn't have an instance
06:09:18 <SamB> eh, it wouldn't have to be a database
06:10:13 <Si\> how would you do it?
06:10:15 <SamB> and I'd write out my instances one by one...
06:10:33 <Si\> instances for what?
06:20:41 <blazoldX> hello, please, how can i count n-th root in haskell ? or real power of some Real number
06:20:46 <blazoldX> like 2^(1/2)
06:21:01 <earthy> @hoogle **
06:21:02 <lambdabot> Prelude.(**) :: Floating a => a -> a -> a
06:21:02 <lambdabot> Control.Arrow.(***) :: Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
06:21:18 <earthy> > 2 ** (1/2)
06:21:19 <lambdabot> 1.4142135623730951
06:21:22 <beelsebob_> @hoogle * -> *
06:21:23 <lambdabot> hoogle: Unexpected character when parsing: * -> *
06:21:23 <lambdabot>  
06:21:23 <blazoldX> ah, great, tx !
06:21:28 <blazoldX> i always tried ^, ^^ 
06:21:37 <beelsebob_> hehe, okay... neil needs to make hoogle support kinds *g*
06:21:40 <earthy> @hoogle ^
06:21:41 <lambdabot> Prelude.(^) :: (Num a, Integral b) => a -> b -> a
06:21:41 <lambdabot> Control.Arrow.(^>>) :: Arrow a => (b -> c) -> a c d -> a b d
06:21:41 <lambdabot> Control.Arrow.(^<<) :: Arrow a => (c -> d) -> a b c -> a b d
06:21:55 <beelsebob_> @hoogle --
06:21:56 <lambdabot> HOOGLE - Haskell API Search
06:21:56 <lambdabot> (C) Neil Mitchell 2004-2005, York University, UK
06:21:56 <lambdabot>  
06:22:02 <beelsebob_> HAHA!
06:22:05 * earthy laughs
06:22:18 <beelsebob_> no operators with -- in them \o/
06:22:43 <beelsebob_> @hoogle (c)
06:22:44 <lambdabot> Prelude.undefined :: a
06:22:44 <lambdabot> Data.Graph.Inductive.Monad.emptyM :: GraphM m gr => m (gr a b)
06:22:44 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
06:22:50 <beelsebob_> heh... interesting
06:36:17 <vincenz> how do you update record?
06:39:49 <phas> I have a problem. I connect to a socket with connectTo, but if there isn't a server listening on the other side, the program freezes, how can i make a control on it? What returns connectTo if cannot create the connection?
06:41:00 <beelsebob_> vincenz: you don't... this is a referentially transparent language, remember
06:41:08 <vincenz> beelsebob_: you know what I mean
06:41:43 <beelsebob_> f (ABC {x = x', y = y'}) = ABC {x = g x', y = h y'}
06:41:56 <vincenz> nah... found it
06:42:03 <vincenz> someX {someField = ..}
06:42:21 <beelsebob_> ah, okay... yes, that too
07:04:18 <jethr0> @pl \(x,y) -> (y,x)
07:04:18 <lambdabot> uncurry (flip (,))
07:04:47 <jethr0> @hoogle flip
07:04:48 <lambdabot> Prelude.flip :: (a -> b -> c) -> b -> a -> c
07:09:52 <Shinji_san> hello - can someboy help me..? :)
07:09:52 <Shinji_san> i need a function to split a list into n preferably equal parts
07:11:50 <ADEpt> Shinji_san: and what seems to be the problem?
07:15:11 <Shinji_san> > split :: Int -> [a] -> [[a]]
07:15:11 <Shinji_san> > split i l = divide (length(l) `div` i) l
07:15:11 <Shinji_san> >	      where
07:15:11 <Shinji_san> >	      divide n xs = case splitAt n xs of
07:15:11 <Shinji_san> >		            ([],_) -> []
07:15:12 <Shinji_san> >                           (ys, zs) -> ys:divide n zs  
07:15:12 <lambdabot>   Expecting a function type, but found `(g, g)'
07:15:12 <lambdabot>   Expected type: Int -> [a] -> [[a]]
07:15:12 <lambdabot>   Inferred type: Int -> (Int, Int)
07:15:12 <lambdabot>  parse error on input `='
07:15:13 <lambdabot>  parse error on input `->'
07:15:35 <Shinji_san> split 3 "hellofolks"
07:15:35 <Shinji_san> ["hel","lof","olk","s"] 
07:15:46 <Shinji_san> but i need
07:16:09 <Shinji_san> split 3 "hellofolks"	
07:16:09 <Shinji_san> ["hel","lof","olks"]
07:18:56 <Trevion> > let l = reverse (split 3 "hellofolks") in if (length (head l) < 3) then reverse ((l !! 1 ++ l !! 0) : tail (tail l)) else reverse l
07:18:57 <lambdabot>   The function `split' is applied to two arguments,
07:18:57 <lambdabot>   but its type `g -> (g, g)' has only one
07:19:13 <Trevion> oh, oops
07:19:30 <Trevion> but that's about how I'd do it.  Kinda clumsy though.
07:20:37 <vincenz> Anyone ever use Data.Inductive.Graph?
07:34:12 <ADEpt> vincenz: i used it (for icfp ;)
07:35:48 <vincenz> :)
07:39:00 <jethr0> @pl \x -> (x+1) == 2 || (x+2) == 2
07:39:00 <lambdabot> ap ((||) . (2 ==) . (1 +)) ((2 ==) . (2 +))
07:44:34 <jethr0> @pl \x y -> fst x == fst y
07:44:35 <lambdabot> (. fst) . (==) . fst
08:00:36 <Si\> Would there be a problem if, in a language like Haskell, you could define functions whose values would change dependant on their context. For example, if v is defined in module A, if we import it into module B it could have a different value to if we import it into module C. So it would be somewhat like a global variable, but you couldn't change it at runtime - its value is fixed at link time. Would that break referential trans
08:02:19 <sieni> Si\: That was cut at "Would that break referential trans"
08:02:56 <Si\> well that was about it, it ended with "parency?"
08:03:33 <sieni> No I don't think it would :-)
08:04:14 <Si\> what I'm thinking about is a kind of distributed values, whose definition can spread over a number of modules, and the final definition would only be decided when they're all linked.
08:05:35 <Si\> in reality you would define the value as a function from V to V, and the linker would join them all up to form the actual value.
08:10:04 <Trevion> Si\, it sounds like you're suggesting some kind of module-dependent scoping.  It's quite possible, but I'm not sure why you'd want it..
08:12:07 <Si\> I don't think I worded it quite right, I mean that the value of the function depends on the all the modules being linked together.
08:12:30 <Trevion> How would it depend on those, though, unless it were using values defined in those modules?
08:12:37 <Saulzar> What you're talking about sounds like parameterised modules, like ML Functors
08:15:09 <Si\> It's difficult to explain what I mean, but imagine this scenario. In module A we define that value of v to be insert 1 (so it would have type Set -> Set), in module B we could set it to insert 2, in C to insert 3 and so on. When we finally link the program with A,B and C v would have type Map and value {1,2,3}. If with just A and B, {1,2} and so on
08:16:34 <Trevion> ick?
08:16:46 * Saulzar agrees
08:17:20 <Si\> But why?
08:18:32 <Saulzar> Sounds like inducing side effects on existing modules depending on what you link, "But why?" sounds like an appropriate question to me :)
08:18:36 <Trevion> Eh.  You could only do that for some data types (how would you combine functions, for example), the compiler would have to know that the definitions were supposed to overlap, what initial object to use, and so forth.
08:18:57 <Trevion> When you can get exactly the same effect with one line in your main module: v = A.v (B.v (C.v Set.empty))
08:19:27 <shapr> Si\: How's that differenct from implicit parameters? http://www.haskell.org/tmrwiki/FunWithLinearImplicitParameters
08:19:32 <Si\> but that's not scalable
08:19:57 <Si\> shapr: Implicit Parameters only define that a value "is there", not where it has come from
08:20:10 <Trevion> Si\, I suppose not, but it's really not that expensive to maintain.
08:20:30 <shapr> Could local typeclasses do that?
08:20:34 <shapr> Or whatever it's really called...
08:23:35 <Si\> Ok, my rationale for wanting something like this is, imagine that I wanted to define a generic function which was going to traverse a data-type and create a schema for it. I want to state that each type down the tree has a property possibly defined for it, but possibly not. Like for example (as I was talking about earlier) a foreign type schema.
08:25:02 <Si\> Now, type-classes allow you to assign properties to types, but they do not allow to state that a type does not have a property.
08:26:14 <Trevion> Maybe?
08:26:49 <Si\> No, that type has a property, I mean a type which does not have an instance
08:27:25 <sproingie> iterating over over all your values looking for a property does in a strict sense mean they all have that property for the purposes of that query, even if it's undefined.
08:27:45 <sproingie> otherwise it's an illogical query
08:27:54 <Trevion> You could accomplish something similar using Maybe types and defining a default instance which has Nothing for all the properties.
08:28:00 <Trevion> You'd have to use overlapping instances...
08:29:58 <sproingie> sounds like a lot of work to get a default, but if you find yourself having to substitute defaults a lot, your design might need work
08:30:46 <shapr> Si\: If the proposed local typeclasses could override global typeclasses, you could use that to figure out whether a type had a local lass defined.
08:30:53 <shapr> It's pretty cheesy though. You should ask Oleg =)
08:30:56 * sproingie is thinking in an OO and relational sense tho, might be more elegant in functional
08:32:25 <sproingie> the type language doesn't understand scope, does it?
08:34:04 <shapr> Si\: You can define default implementations in a typeclass definition. What about that?
08:34:19 <Si\> The function I'm trying to write it something along the lines of toSchema :: Data a => a -> [ForeignTypeRep]. The default cases in this instances are types for which no foreign definition as yet exists
08:34:44 <Si\> shapr: Again, that would require overlapping, which everyone keeps telling me I shouldn't be using
08:35:10 <Si\> and my context stack keeps exploding anyway
08:36:03 <Saulzar> Sounds like something which could relate closely to the design of Binary IO libs... 
08:37:43 <Si\> there are a number of resources which need distributing over modules, for example locations of foreign type representations, module namespace/foreign namespace mapping etc.
08:38:30 <Saulzar> More specifically, serialisation
08:38:45 <Saulzar> Sounds like the same problem, no?
08:38:55 <Si\> undoubtedly
08:39:16 <Si\> I'm not an expert in Binary Serialization, I work mainly with XML
08:40:04 <Saulzar> There are some which use template haskell to do the dirty work
08:40:49 <Si\> so do I, but that only makes things more convenient, not more expressive
08:41:41 <Saulzar> Ah. Well, maybe worth a look :)
08:42:06 <Si\> there just simply isn't a way of distributing meta-data nicely over a number modules
08:43:19 <Si\> I've tried both way; overlapping instances are nasty, databases need populating somehow. No-one wants to have to use a serialization function with the signature serialize :: Data a => MassiveBlockOfMetaData -> a -> Rep
08:44:32 <Si\> in order to use the latter you also need apriori knowledge of every single type that is going to be serialized when you use it. This simply isn't possible if you want polymorphism.
08:46:22 <Si\> So my next thinking was that if I used unsafePerformIO to act as a proxy to a database of meta-data, which could be updated but in the Haskell program would look like a regular value, that would enable distribution of data across modules. But does anyone seriously want a program with unsafePerformIO?
08:47:31 <Saulzar> You could use a pre-processor or something instead, I guess
08:48:53 <Si\> To gather all the data from all the modules and place it in once place?
08:48:58 <Saulzar> Yeah
08:49:18 <Si\> Suppose they're already in binary form
08:51:55 <Saulzar> You make things difficult then :)
08:52:08 <Si\> I suppose you could associate textual meta-data with each module somehow, but I just think it's easier if this data is contained in the module itself
08:52:16 <Si\> i.e. in volatile, distributed values
08:55:03 <vincenz> does trace write to stdout or stderr?
09:06:55 <ndm> vincenz: on Hugs, stderr
09:27:11 * vincenz hmms
09:27:15 <vincenz> ADEpt: ping
09:27:27 <ADEpt> vincenz: pong
09:27:32 <vincenz> ADEpt: you did icfp 2005?
09:27:58 <ADEpt> vincenz: yep
09:28:07 <vincenz> ADEpt: for some reason I can't do ./bdk/server --robber ./Robber..... but I can do ./bdk/server --robber "ghc Robber.hs -e main"
09:28:14 <vincenz> do you have any knowledge about htis?
09:28:24 <ADEpt> no. windows?
09:28:29 <vincenz> linux
09:28:48 <vincenz> seems odd
09:28:58 <ADEpt> hSetBlockingMode NoBlocking?
09:29:03 <vincenz> ah
09:29:04 <vincenz> nope
09:29:06 <vincenz> wherE?
09:29:32 <vincenz> @hoogle hSetBlockingMode
09:29:32 <lambdabot> No matches found
09:29:43 <vincenz> @hoogle NoBlockin
09:29:44 <lambdabot> No matches found
09:29:44 <vincenz> @hoogle NoBlocking
09:29:44 <lambdabot> No matches found
09:31:41 <beelsebob_> > split :: Int -> [a] -> [[a]]
09:31:41 <beelsebob_> > split i xs =
09:31:41 <beelsebob_> >   divide n n l
09:31:41 <beelsebob_> >   where
09:31:41 <beelsebob_> >   n = ((length l) `div` i)
09:31:42 <lambdabot>   Expecting a function type, but found `(g, g)'
09:31:42 <lambdabot>   Expected type: Int -> [a] -> [[a]]
09:31:42 <lambdabot>   Inferred type: Int -> (Int, Int)
09:31:42 <lambdabot>  parse error on input `='
09:31:42 <lambdabot>  Not in scope: `l'
09:31:43 <beelsebob_> >   divide :: Int-> Int -> [a] -> [[a]]
09:31:44 <lambdabot>  parse error on input `where'
09:31:46 <lambdabot>  parse error on input `='
09:31:46 <beelsebob_> >   divide 0 n xs = []:(divide n n xs)
09:31:48 <lambdabot>  Not in scope: `divide'
09:31:49 <beelsebob_> >   divide m n [] = [[]]
09:31:50 <lambdabot>  parse error on input `='
09:31:51 <beelsebob_> >   divide m n (x:xs) = (x:r):rs where (r:rs) = divide (m-1) n xs
09:31:52 <lambdabot>  parse error on input `='
09:31:55 <lambdabot>  parse error on input `='
09:32:00 <beelsebob_> um... interesting
09:32:13 <beelsebob_> oh... stupid bob
09:33:22 <beelsebob_> let split i xs = divide n n l where n = ((length l) `div` i); divide 0 n xs = []:(divide n n xs); divide m n [] = [[]]; divide m n (x:xs) = (x:r):rs where (r:rs) = divide (m-1) n xs in split 5 "superduperjamcaketypethings"
09:33:26 <ADEpt> vincenz: in System.IO
09:33:39 <beelsebob_> > let split i xs = divide n n l where n = ((length l) `div` i); divide 0 n xs = []:(divide n n xs); divide m n [] = [[]]; divide m n (x:xs) = (x:r):rs where (r:rs) = divide (m-1) n xs in split 5 "superduperjamcaketypethings"
09:33:40 <lambdabot>  Not in scope: `l'
09:33:44 <vincenz> ADEpt: thx
09:34:00 <vincenz> ADEpt: you still have your bots for a little competition once jethr0 and I get a bit further?/
09:34:02 <beelsebob_> > let split i xs = divide n n xs where n = ((length xs) `div` i); divide 0 n xs = []:(divide n n xs); divide m n [] = [[]]; divide m n (x:xs) = (x:r):rs where (r:rs) = divide (m-1) n xs in split 5 "superduperjamcaketypethings"
09:34:03 <lambdabot> ["super","duper","jamca","ketyp","ethin","gs"]
09:34:09 <beelsebob_> there you go :)
09:34:27 <ADEpt> vincenz: i dont mind, but usually they are too scared of themselves to play properly :)
09:34:52 <vincenz> ADEpt: ?
09:37:07 <magnus--> Hi, do ghci and hugs do tail calls?
09:37:10 <dcoutts_> vincenz, you were another of the icfp05 Haskell teams? how did it go?
09:37:40 <magnus--> I'm asking because (maximum [1..999999]) stack overflows on both
09:38:26 <flux__> @index maximum
09:38:27 <lambdabot> Data.List, Prelude
09:38:45 <Spark> has anyone seen this syntax for evaluation contexts?  C ::= [] | [] ; T | blah C blah | blah blah C blah
09:39:17 <Spark> i'm used to things like E[.] ::= E[.] ; e | v ; E[.] | if E[.] e e | etc
09:39:39 <flux__> magnus--, it's not really related, it happens because max 1 (max 2 (max 3 (max 4... eats all the task, before it finally evaluates max 999998 999999
09:39:43 <Spark> im fairly certain this guy hasnt defined []
09:40:13 <vincenz> dcoutts_: no, jethr0 annd I are doing it now as haskell-learning experiment
09:40:32 <dcoutts_> vincenz, oh right, nice
09:40:38 <ADEpt> vincenz: i've got my heuristics all tangled, and half of the time they tend to err on the safe side. Very safe side. Which means that my robber is left without any money. Oh, and my cops are average-good, so there is no need to mention them at all.
09:40:48 <orbitz> vincenz: i looked at jocaml a bit, join caculus certainly is interesting
09:40:54 <dcoutts_> vincenz, to be honnest the problem from 2004 was neater and more fun.
09:41:05 <Spark> i did my msc thesis on chords
09:41:14 <vincenz> orbitz: yeah :)
09:41:14 <magnus--> flux_: That would be a very stupid way to define maximum
09:41:24 <vincenz> orbitz: werent' you a c++ regular earlier
09:41:43 <vincenz> dcoutts_: heh...2004 we took the wrong approach...trying to apply GA
09:42:05 <orbitz> vincenz: i still am, have been here for a month or so
09:42:09 <ADEpt> dcoutts_: +!
09:42:10 <ADEpt> dcoutts_: i mean, +1. I like ant much more than cops
09:42:11 <vincenz> orbitz: welcome :)
09:42:34 <magnus--> flux: maximum can be written in a tail-recursive way that shouldn't eat up any stack space
09:42:56 <orbitz> vincenz: ##concurrency is a ncie channel too if you have any interest in it, 
09:43:00 <vincenz> ah thx
09:43:08 <wilx> maximum xs              =  foldl1 max xs
09:43:13 <wilx> Interesting.
09:43:15 <vincenz> orbitz: is it my impression, or are you less wacky when you're on here wihtout blank
09:43:49 <wilx> I think it build up huge chain of unevaluated chunks or whatever it is called.
09:44:36 <orbitz> vincenz: i'm not regular enough to be wacky in here
09:45:06 * shapr neither
09:45:34 <shapr> Maybe I should start frequenting the C++ channel.
09:45:43 <tibbe> How can I get a list of say [1,2,3] into one built with a data type like so (Cons 1 (Cons 2 3)?
09:45:45 <vincenz> I only have one quote oni the c++ channel
09:45:49 <vincenz> "This channel is degrading by the moment"
09:45:56 <orbitz> vincenz: :( too bad
09:46:07 <orbitz> vincenz: keep on truckin, you'll get more
09:46:12 <vincenz> orbitz: no I think it applies
09:46:17 <vincenz> often c++ seriously degenerates
09:46:27 <vincenz> well ##C++ (not much unlike the language)
09:46:34 <orbitz> when i'm there?
09:46:35 <Spark> if you want my opinion on the join calculus, i dont think message passing should be tied up with method invocation, since you have to make more methods every time you want to send / receive a message, there was something i liked better from MSR but i cant find the email from the person who sent it to me
09:46:39 <vincenz> orbitz: no
09:47:00 <orbitz> vincenz: maybe people realize the langauge sucsk and just use the langauge to play around
09:47:05 <orbitz> i know that's what i do
09:47:07 <magnus--> So it seems maximum is not properly tail recursive
09:47:10 <magnus--> that seems like a bug.
09:47:16 <Spark> it was a library though
09:47:27 <vincenz> orbitz: checked out ocaml?
09:47:30 <orbitz> vincenz: nice little quote from ##c last night "haskell is the wrost language ever developed"
09:47:32 <wilx> foldl1 max xs looks ok to me.
09:47:38 <orbitz> vincenz: only breifly
09:47:41 <shapr> tibbe: What about  a Cons a = Cons a Cons | Nil and then Cons 1 $ Cons 2 $ Cons 3 Nil ?
09:47:46 <orbitz> vincenz: i looked at jocaml more for documetnaiton on join calc
09:47:48 <shapr> tibbe: just off the top of my head, may not work.
09:47:54 <vincenz> orbitz: ah k
09:47:59 <shapr> orbitz: What's the reasoning there?
09:48:20 <shapr> Isn't C++? =)
09:48:27 <orbitz> shapr: the individual feels recursion is a poor substitute for iteration as you 'have to write all sorts of wrapper functions just to do a simple loop'
09:48:30 <magnus--> wilx: can you try out foldl1 max [1..999999] in hugs or ghci?
09:48:41 <shapr> orbitz: bwahahaa
09:48:44 <wilx> I tried, it dies on stack overflow for me too.
09:48:46 <orbitz> shapr: yes, quite laughable
09:48:52 <wilx> But I think it looks tail recursive enough :)
09:49:07 <wilx> There must be something else that kicks in. Like laziness, maybe.
09:49:16 <shapr> orbitz: Have you asked him to implement functions calls via iteration yet?
09:49:25 <flux__> @hoogle fold
09:49:25 <lambdabot> Data.IntMap.fold :: (a -> b -> b) -> b -> IntMap a -> b
09:49:25 <lambdabot> Data.IntSet.fold :: (Int -> b -> b) -> b -> IntSet -> b
09:49:25 <lambdabot> Data.Map.fold :: (a -> b -> b) -> b -> Map k a -> b
09:49:32 <flux__> @index fold
09:49:32 <lambdabot> Data.IntMap, Data.IntSet, Data.Map, Data.Set
09:49:35 <tibbe> shapr, would be nice if I could just fold something like the constructor
09:49:36 <orbitz> shapr: no, someoen liek that is probably nto worth communicating with
09:49:56 <flux__> > Data.List.foldl1' max [1..999999]
09:49:58 <lambdabot> 999999
09:50:12 <edwinb> "I prefer java to haskell, you can write a program without knowing what it's meant to do."
09:50:19 <Saulzar> Hmm, all sorts of people have bad opinions, they can come around if you rub their nose in it enough...
09:50:22 <shapr> Maybe... I started out as a total zealot when I knew only one programming language. I was a complete Blub Paradox poster boy.
09:50:32 <palomer> guess who's back
09:50:42 <Spark> Saulzar: its more likely they have valid opinions that they cannot express very well
09:50:47 <shapr> Now that I know a bunch of programming languages, I'm far more of a zealot..
09:50:51 * shapr is only joking
09:50:53 <Spark> Saulzar: if you treat them like idiots you wont learn anything
09:50:53 <shapr> palomer: you are?
09:50:56 <palomer> yes!
09:51:00 <shapr> palomer: wow!
09:51:02 <Saulzar> Spark, Right..
09:51:02 <palomer> isn't this wonderful?
09:51:08 <shapr> palomer: It's definitely exciting.
09:51:31 <magnus--> flux: That works... weird
09:51:40 <shapr> tibbe: Hey, if that code works, I'm happy.
09:51:57 <shapr> tibbe: It comes from too many hours of reading Oleg's code.
09:52:04 <Saulzar> It's hard to get over the barrier of thinking "This isn't what I'm used to"
09:52:09 <shapr> He gave me a short description on how to do typed adjacency testing once.
09:52:15 <shapr> I was like totally %-O
09:52:22 <Saulzar> I was of the opinion that Haskell was only for crazy people and math Phd's until I bothered to actually look. Clearly mis-informed...
09:52:40 <tibbe> shapr, actually I'm trying to translate (Lambda [Ident] Expr) so it looks very much like a fold with a base case of Expr
09:53:29 <Philippa_> Saulzar: I'm definitely not a maths PhD :-)
09:53:37 <wilx> >let cmp x y = x `seq` y `seq` (compare x y) in maximumBy cmp [1..999999]
09:53:46 <shapr> edwinb: I told my gf today that programming isn't hard unless you're writing Haskell. Because then a few lines of code can do everything, and you have to actually understand what someone else was thinking.
09:54:06 <Philippa_> heh
09:54:25 <edwinb> so true
09:54:26 <shapr> tibbe: My brain is full of Plone internals. Please leave a message at the list comprehension.
09:54:50 <Spark> shapr: surely thats a criticism of haskell
09:54:56 <edwinb> It's not a criticism
09:54:56 <wilx> Why do I get stack overflow even for this?: let cmp x y = x `seq` y `seq` (compare x y) in maximumBy cmp [1..999999]
09:54:58 <shapr> Spark: Heck no, that's the best praise ever.
09:54:58 <edwinb> it's a good thing!
09:54:59 <wilx> Hm...
09:55:04 <wilx> Some strange interactions.
09:55:22 <gour> shapr: when will you marry so you can really try to understand what 'someone else' is thinking :-)
09:55:34 <edwinb> In the same way, if you know exactly what you're trying to do, it's dead easy.
09:56:04 <glasser> Anyone here familiar with installing GHC via Darwinports on OSX, and getting the X bits (Graphics.HGL, say) with it?
09:56:19 <orbitz> do you have teh X11 SDK installed
09:56:20 <vincenz> hey ...
09:56:25 <vincenz> nm
09:56:35 <shapr> gour: Well, I had a six year relationship that stopped about six months ago, so... 
09:56:45 <magnus--> wilx: If I write maximum myself using plain recursion it works fine
09:56:56 <magnus--> recursion with an accumulator.
09:57:03 <orbitz> shapr: how does such a long relatinoship finally end?  was it alwasy held together by a thread?
09:57:08 <Spark> i have a theory where you have two kinds of languages -- research languages which are incredibly expressive and you can invent lots of new and strange idioms for doing conventional things, like lua for example, and this is ok because you learn from it, but then you have the industrial languages where the fewer strange and new idioms there are embedded in code, the less difficult it will be to understand by other maintainers
09:57:39 <SyntaxNinja> greetings!
09:57:40 <gour> shapr: ahh.."without commitment, there is no deeper relationship", so better wathc out about your revision control system
09:57:52 <shapr> Spark: Other languages are like the tire spikes at toll booths, you can go against the grain, but it's gonna *hurt*. Haskell is like having your own machine shop. You can build any machine you want to do anything you can think up.
09:58:43 <tibbe> @quote
09:58:43 <lambdabot> SamB says: Boy, point-free Arrows are worse than Forth...
09:58:47 <Spark> shapr: but then your replacement wont be able to understand it
09:59:13 <Spark> shapr: because youve created many levels of abstractions
09:59:14 <icbt> how does one correctly use ghc to compile/link a .c file to its corresponding .hs processed with ghc -C -fffi ?
09:59:18 <edwinb> I don't program so that Joe Programmer can understand it. I program so that I can understand it...
09:59:24 <glasser> orbitz: yeah
09:59:35 <orbitz> glasser: hrm, it doesne't jsut find i ton ti's own?
09:59:37 <shapr> Spark: Yeah, I'm with you. But my theory extends one step further and says that using research languages is what commercial programming should be all about, and everything else is just being a hi-tech ditch digger.
09:59:46 <glasser> orbitz: so I think I didn't when I installed ghc the first time, so it magically decided not to install that stuff
09:59:50 <Spark> shapr: we need hi-tech ditch diggers too :)
10:00:03 <glasser> I guess if I just wipe it somehow and make it recompile from scratch it'll work?
10:00:03 <shapr> And they should write Python
10:00:05 <Spark> shapr: surely what youre saying is that haskell should only be used for prototypes therefore
10:00:30 <glasser> (there's no --without-x or whatever in the Portfile: does the GHC build process autodetect that stuff?)
10:00:31 <Spark> shapr: because once something becomes well-understood, it becomes less interesting for smart people, and starts becoming mass produced
10:00:52 <roconnor> > Data.List. foldl1' max [1..9999999]
10:00:52 <lambdabot>  Not in scope: data constructor `Data.List'
10:00:52 <Spark> shapr: and prototypes are hacked up :)
10:00:54 <shapr> Spark: No, I'm saying that on the notepad to emacs scale of complexity, Java is write.exe and Haskell is somewhere close to emacs.
10:01:01 <roconnor> > Data.List.foldl1' max [1..9999999]
10:01:02 <sieni> well, Scheme is nice as well <3
10:01:04 <lambdabot> 9999999
10:01:06 <vincenz> someFunc A x = ...
10:01:09 <vincenz> someFunc B x = ...
10:01:15 <vincenz> someFunc C x = someFunc B x
10:01:18 <vincenz> any fix for this?
10:01:31 <shapr> Spark: I think that commercial programming should be done with Haskell level tools/languages and produce a toolkit that can be scripted by ditch diggers.
10:01:44 <hyp> @moo
10:01:45 <lambdabot> Maybe you meant: map more msg todo yow
10:01:51 <edwinb> To solve any programming problem, first implement the language that best solves it.
10:01:55 <edwinb> Haskell is a good tool for that ;)
10:01:56 <shapr> Right!
10:01:57 <roconnor> wilx: The problem is probably with maximumBy, not the comparision.
10:02:04 <shapr> PHP is the one of the best examples of that.
10:02:12 <vincenz> nm
10:02:16 <edwinb> That's the first time I've heard PHP described as a good example of anything...
10:02:18 <Spark> php is also one of the worst languages ever :)
10:02:19 <roconnor> @wiki StackOverflow
10:02:19 <lambdabot> http://www.haskell.org/hawiki/StackOverflow
10:02:39 <shapr> Spark: Still anyone can learn to do html processing with it. That's its strength.
10:02:53 <Spark> shapr: if you write code with emacs, someone else can edit it with write.exe
10:03:12 * palomer pokes dcoutt
10:03:18 <Spark> shapr: this is true, but it could be made a lot better without crippling it in that regard
10:03:20 <palomer> or dcoutts, rather
10:03:24 <shapr> Yeah, but woe to the person who tries to refactor with write.exe
10:03:29 <dcoutts> hello?
10:03:36 <dcoutts> palomer, hia
10:03:43 <Spark> shapr: more likely they'll import it into an IDE which will reformat it all and everything
10:03:45 <shapr> Yeah, I think PHP should have been designed from the ground up as an html scripting language.
10:03:51 <Spark> shapr: thats what we used to use when i worked for a defence contractor
10:04:18 <shapr> write.exe? or an IDE that reformatted?
10:04:26 <shapr> SyntaxNinja: hiya!
10:04:42 <Spark> most people use IDEs these days
10:04:52 <Spark> eclipse, visual studio, whatever
10:05:01 <Spark> at least where i worked, they employer forced me to :)
10:05:02 <hyp> emacs
10:05:04 <gour> we want hide...
10:05:14 <orbitz> hrm, how abotu a liquor store that sells bloodwine
10:05:19 <Spark> because it enforced their coding standards
10:05:21 <palomer> dcoutts: good afternoon
10:05:59 <shapr> orbitz: imho, communication, trust, commitment is the order of important for a relationship. My previous relationship lost communication, and after a certain amount of time (2+ years) trying to regain that, I had to timeout.
10:06:00 <dcoutts_> palomer, evening
10:06:05 <palomer> dcoutts: I'm calling textViewGetIterAtLocation , which still returns a value even if I'm not pointing at any text
10:06:24 <dcoutts_> palomer, what location does it return?
10:06:34 <orbitz> shapr: too bad, good lesson to learn though. even if painfully
10:06:39 <palomer> dcoutts: for example:, if I print "hello", and I maximize my screen, the hello is going to be at the top left corner
10:06:39 <shapr> yup
10:06:40 <Spark> my girlfriend cant use my linux desktop as i have personalised it too much :(
10:07:00 <sieni> Spark: why are you letting her use your account?
10:07:00 <palomer> dcoutts: yet if I move my mouse to the top right corner, textViewGetIter still returns the position at the o
10:07:06 <palomer> or, rather, the iter at the o
10:07:08 <orbitz> shapr: i'm tryign to an adopt a 'not care' policy and communicate good and bad withotu regard:)
10:07:08 <palomer> "o"
10:07:21 <shapr> My gf taught herself dvorak in ten minutes yesterday ... so she can use my desktop just fine. 
10:07:25 * shapr wasn't expecting that...
10:07:28 <dcoutts_> palomer, so perhaps you should check if the pointer is in the window at all
10:07:30 <Spark> heh
10:07:33 <dcoutts_> window/widget
10:07:39 <Spark> i tried to use dvorak when i was a teenager
10:07:51 <palomer> dcoutts: oh, but it's still in the window, and inside the widget
10:07:52 <shapr> orbitz: What do you mean by 'not care' ?
10:07:55 <Spark> but it took me a long time and i still wasnt as fast on it so i gave up
10:07:57 <palomer> dcoutts: it's just that there's no text there
10:07:59 <Spark> i think im not very coordinated
10:08:22 <Spark> shapr: the problem is the obscure key bindings and the lack of anything to click on
10:08:24 <shapr> orbitz: You mean communicate equal amounts of praise and criticism?
10:08:32 <Spark> because things to click on cost pixels
10:08:39 <orbitz> shapr: as in less fearful of critism
10:08:45 <dcoutts_> palomer, well I guess it considers the space after a line to be at the location at the end of the line
10:09:09 <shapr> Spark: Well, once I showed my gf that hyper-n was next workspace and super-n was next app inside the workspace, she was just fine.
10:09:38 <shapr> orbitz: Yeah, I'm trying to improve there also. I want to know the truth, no matter how much I may not enjoy what I hear, because how else can I improve?
10:09:47 <orbitz> shapr: exactly
10:09:49 <Spark> she can do that, but she gets a bit confused when it wraps around at the top
10:09:55 <dcoutts_> palomer, you could check if the iter you get back is at the end of a line
10:09:59 <Spark> but then she cant tell which ones focussed and closes the wrong window
10:10:06 <Spark> and then doesnt know what hte program was so cant get it back again
10:10:08 <orbitz> shapr: many peoepl are fearful of that, and i can be fearful of giving the raw truth too, just have to communicate that flaws are ok
10:10:10 <palomer> dcoutts_: how do I do that?
10:10:26 <dcoutts_> palomer, are you using gtk_text_view_get_iter_at_position orbitz or gtk_text_view_get_iter_at_location?
10:10:26 <shapr> orbitz: Yeah, criticism /= disapproval
10:10:35 <dcoutts_> palomer, have you noticed what the difference is?
10:10:36 <orbitz> exactly
10:10:51 <shapr> orbitz: Still, it's hard. Have you heard of E-Prime language?
10:11:01 <orbitz> shapr: yes
10:11:06 <palomer> dcoutts: location
10:11:06 <shapr> Wow, shocking.
10:11:20 <orbitz> shapr: e-prime is fairly interesting.  i'm not sure hwo well it works for verbal comm. but writing docmetnation in it is a belssing
10:11:31 <shapr> It's *great* for verbal communication.
10:11:49 <shapr> Not as a standard to stick to, but as an ideal to follow.
10:11:53 <orbitz> lookd at lojban?
10:11:57 <shapr> go'i
10:12:06 <shapr> xu do tavla mi bau la lojban
10:12:13 <palomer> dcoutts: I don't quite understand the difference between atLocation and atPosition
10:12:35 <orbitz> heh i don't speak it, but i have looked at it, it is a similar idea to e-prime i find, in terms of communicating things efficiently (although a compeltley dfiferent way to go about it)
10:12:55 <magnus--> Why does List.Data.foldl1' work but not foldl1?
10:13:08 <dcoutts_> palomer, look at the C docs
10:13:15 <tic> Ugh, English is expressive as it is, let alone forcing E' everywhere
10:13:23 <palomer> dcoutts: either way, I think both would return the iterator at the end of the line
10:13:26 <dcoutts_> palomer, the other thing you might find handy is gtk_text_view_starts_display_line
10:13:40 <shapr> I don't think lojban is any good for e-prime, but I do think it's good for investigating the Sapir-Whorf hypothesis.
10:13:44 <shapr> tic: haha, you used identity!
10:13:50 <shapr> Of course.. so did I :-/
10:13:57 <shapr> Let me try that in E' ...
10:14:11 <orbitz> shapr: off to number theory, nice talking
10:14:13 <tic> I read your scentence as using identity? Hm..
10:14:19 <shapr> orbitz: Yeah, fun
10:14:24 <orbitz> take it easy
10:14:41 <roconnor> foldl  f z []     =  z
10:14:41 <roconnor> foldl  f z (x:xs) =  foldl f (f z x) xs
10:14:41 <roconnor> foldl' f z []     =  z
10:14:41 <roconnor> foldl' f z (x:xs) =  (foldl' f $! f z x) xs
10:15:02 <shapr> tic: No, I mean... how can you compare the expressiveness of English and E' while using E' ?
10:15:10 <tic> shapr, I wasn't using E'
10:15:23 <shapr> If you use identity while comparing them it's almost like Godwin's Law :-)
10:15:46 <tic> shapr, and as in chattyness -- I find esp. Americans saying a whole lot more words than the average Swede to get the same message through.
10:16:06 <magnus--> roconnor: looking and thinking...
10:17:05 <roconnor> magnus--: I don't think I understand it.
10:17:13 <shapr> tic: After experiences of the last few months, I perceive Americans as actually communicating, and the average Swede in Boden as being unable to say what they actually think.
10:17:47 <tic> shapr, Boden's an exception; everyone knows people in the north are unable to express feelings. :)
10:17:59 <roconnor> magnus--: I guess the idea is taht foldl' will compute f before proceeding with demaning a new item from the list.
10:18:00 <shapr> I recently learned that a bunch of people here strongly disapproved of something I did, but I only heard about it second-third-fourth hand and many many months later.
10:18:01 <tic> shapr, a bit further south, though, like myself.. Find a bit more terse.
10:18:09 <tic> shapr, weird.
10:18:46 <sieni> tic: shapr: it might be true, but don't even dare to think that the Finnish influence close to border has contributed to that!
10:18:52 <magnus--> roconnor: This is scary... I'm getting scared of lazy evaluation
10:19:27 <tic> sieni, heh, I'm not assuming anything. :-)  Personally, I think it's because of the vast distances and short days.
10:19:29 <shapr> sieni: I spent three years in Tornio. People insulted me regularly, but hey at least I couldn't understand them ;-)
10:19:33 * shapr is joking...
10:20:03 <palomer> dcoutts: I would really need iterEndsDisplayLine
10:20:12 <roconnor> magnus--: Lazy evaluation can have some memory issues.
10:20:24 <gour> shapr: then you should come to bosnia...there you get a hug or a knife :-)
10:20:29 <shapr> haha
10:20:31 <dcoutts_> palomer, that's the same as advancing by one character and seeing if it's at the beginning :-)
10:20:48 <roconnor> magnus--: But I've never had a problem. ... not that I do THAT much programming.
10:20:49 <shapr> sieni: Seriously though, I think the nice/mean people ratio is the same in Sweden, Finland, USA, etc.
10:21:58 <magnus--> roconnor: It's the first time I have it too, but it stopped me completely in my programming
10:22:08 <magnus--> 'til i could narrow down where the stack overflow is
10:22:45 <palomer> dcoutts: unless it's at the very end of the buffer
10:23:01 <dcoutts_> palomer, true and you can detect that too
10:23:10 <dcoutts_> palomer, so you can write iterEndsDisplayLine
10:23:12 <palomer> btw, which window does widgetGetDrawindow return?
10:23:18 <roconnor> magnus--: It's still better that strict evaluation which would evaluate [1..10000000] first ;)
10:23:33 <roconnor> You'd always be screwed then.
10:23:47 <dcoutts_> palomer, whichever DrawWindow the widget draws onto at the top level, the one containing the whole widget
10:23:51 <magnus--> roconnor: that's true... unless you use streams
10:23:54 <Si\> is it possible to de/serialize a TypeRep?
10:24:11 <dcoutts_> palomer, so not any of the internal DrawWindows that a text view uses
10:24:30 <palomer> is it a TextWindowWidget?
10:24:34 <roconnor> magnus--: If your problem is streamable, then you shouldn't be running into a stack overflow with your code.
10:24:48 <palomer> dcoutts: because I need to convert drawWindowCoordinates to buffer coordinates
10:25:17 <magnus--> roconnor: but the solution involves using strict evaluation in some places. the list is still consumed as a stream
10:25:39 <dcoutts_> palomer, using gtk_text_view_window_to_buffer_coords
10:26:17 <roconnor> magnus--: I guess I don't know what it means to use streams in a strict language.
10:26:24 <palomer> dcoutts: yeah, but that requires a TextWindowType
10:26:40 <magnus--> roconnor: It's like doing lazy evaluation only on lists
10:28:05 <dcoutts_> palomer, it'll be GTK_TEXT_WINDOW_WIDGET
10:28:38 <palomer> thx
10:29:00 <vincenz> is it posisble to do something like
10:29:06 <magnus--> sum [1..999999] works, but maximum [1..999999] does not. That seems inconsistent
10:29:07 <vincenz> import qualified XXX(a,b) as X
10:29:45 <musasabi> import qualified XXX as X(a,b)
10:30:17 <magnus--> I'll never use foldl again :)
10:30:31 <magnus--> sum is not implemented in terms of foldl
10:31:12 <shapr> It's good to know when to use foldl and when to use foldr
10:31:30 <magnus--> neither foldl or foldlr (+) 0 [1..999999] works
10:31:44 <shapr> What about adding a ' to the end of them?
10:31:51 <shapr> foldl' or foldr' ?
10:32:15 <magnus--> not defined in the standard prelude
10:32:24 <shapr> @index foldl'
10:32:25 <lambdabot> Data.List
10:32:28 <shapr> @index foldr'
10:32:29 <lambdabot> bzzt
10:32:31 <shapr> hm
10:32:35 <vincenz> @hoogle folrd'
10:32:36 <lambdabot> Prelude.undefined :: a
10:32:36 <lambdabot> Data.Graph.Inductive.Monad.emptyM :: GraphM m gr => m (gr a b)
10:32:36 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
10:32:37 <vincenz> @hoogle foldr'
10:32:37 <lambdabot> Prelude.undefined :: a
10:32:37 <lambdabot> Data.Graph.Inductive.Monad.emptyM :: GraphM m gr => m (gr a b)
10:32:38 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
10:32:53 <vincenz> @fptools sum
10:32:54 <lambdabot> sum not available
10:32:55 <shapr> Interesting result...
10:33:18 <vincenz> hmm
10:33:20 <TuringTest> foldr' is not space safe--there is no point
10:33:22 <vincenz> I have a list of results....
10:33:27 <vincenz> [a,b,c...]
10:33:33 <vincenz> where each is a list
10:33:35 <vincenz> now I would like to have
10:33:41 <vincenz> [a, a++b, a++b++c, ...]
10:33:44 <vincenz> for an infinite list
10:33:51 <roconnor> @wiki StackOverflow
10:33:52 <lambdabot> http://www.haskell.org/hawiki/StackOverflow
10:33:57 <roconnor> ``When should foldl be used? The pragmatic answer is: by and far it shouldn't be used. A case where it makes a difference is if the function is conditionally strict in its first argument depending on its second, where I use conditionally strict to mean a function that is strict or not in one argument depending on another argument(s).''
10:33:59 <TuringTest> @index scanl
10:34:00 <lambdabot> Data.List, Prelude
10:34:05 <TuringTest> @type scanl
10:34:05 <palomer> dcoutts: the problem is that moving the iter is stateful
10:34:05 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
10:34:19 <TuringTest> vincenz: scanl
10:34:21 <vincenz> th
10:34:22 <vincenz> x
10:35:37 <TuringTest> > scanl (++) "I" [" ","am"," ","happy"]
10:35:38 <lambdabot> ["I","I ","I am","I am ","I am happy"]
10:36:07 <palomer> > foldl1 + [1]
10:36:07 <lambdabot> Couldn't match `(a -> a -> a) -> [a] -> a' against `[a1]'
10:36:10 <palomer> > foldl1 (+) [1]
10:36:11 <lambdabot> 1
10:36:18 <palomer> @type foldl1
10:36:18 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
10:36:22 <palomer> @type foldl
10:36:23 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
10:44:14 <magnus--> http://www.dcs.gla.ac.uk/mail-www/glasgow-haskell-users/msg00636.html
10:44:21 <magnus--> it's a very old problem it seems
10:44:29 <dcoutts_> palomer, you can use textIterCopy, or if you don't need the visual line / logical line distinction then you could use textIterEndsLine
10:45:15 <dcoutts_> palomer, the distinction is desribed here: http://haskell.org/gtk2hs/docs/current/Graphics-UI-Gtk-Multiline-TextView.html#v%3AtextViewForwardDisplayLine
10:49:02 <frobenius> What is the meaning of !  in datatype definitions?
10:49:27 <frobenius> like "data Rec f = In (f ! (Rec f))"
10:49:49 <dcoutts_> it means the follwing data field is strict
10:49:51 <TuringTest> Strictness annotation 
10:50:09 <frobenius> Is it important? And does it work also with records?
10:50:33 <dcoutts_> I'm not sure that "data Rec f = In (f !(Rec f))" is valid
10:51:00 <dcoutts_> I think you can only apply it to the fields in the data type, not arbitrary subcomponents of the field's type
10:51:34 <frobenius> so where can I put the bang then?
10:51:42 <dcoutts_> eg:
10:51:52 <dcoutts_> data Foo = Foo !Int !Int
10:51:55 <dcoutts_> not:
10:52:01 <dcoutts_> data Foo = Foo !Int [!Int]
10:52:13 <dcoutts_> but this is ok:
10:52:14 <dcoutts_> data Foo = Foo !Int ![Int]
10:52:15 <frobenius> correct, data Rec f = In !(f (Rec f))  worked
10:52:30 <dcoutts_> frobenius, perhaps you want:
10:52:45 <dcoutts_> newtype Rec f = In (f (Rec f))
10:52:47 <frobenius> but how do I do it for records, e.g. data Rec f = In { out :: (f (Rec f)) }   where do I put the bang now?
10:53:00 <frobenius> newtype, aha, that's equivalent but not lifted?
10:53:01 <dcoutts_> data Rec f = In { out :: ! (f (Rec f)) }
10:53:08 <dcoutts_> frobenius, right
10:53:17 <dcoutts_> the strictness is basically non-lifting
10:53:28 <palomer> is there a "stop doing anything else in this do block" combinator :P?
10:53:32 <palomer> (for IO)
10:53:37 <frobenius> so newtype is equal to the bang bussiness?
10:53:45 <dcoutts_> and newtype is a special optimisation of a non-lifting data type
10:54:23 <frobenius> semantically, can they be interchanged, I mean the ! versions above and the corresponding newtype def's without !
10:54:25 <dcoutts_> frobenius, it's semantically equivalnt, the newtype will use the same representation as the original rather than an extra boxing/indirection
10:54:51 <frobenius> boxing?
10:55:06 <dcoutts_> it's a represnetation / implementationg thing
10:55:18 <dcoutts_> it's how lifted types are represented
10:55:19 <frobenius> so for MU I should always use newtype
10:55:39 <dcoutts_> the rule of thumb is use newtype in situations where it applies
10:55:40 <frobenius> so boxing means precisely what?
10:55:57 <dcoutts_> boxing is basically an extra pointer indirection
10:56:15 <frobenius> is something domain theoretic going on?
10:56:27 <dcoutts_> it's just an implementation thing
10:56:39 <dcoutts_> a value is represented by a pointer to a box containing the value
10:57:01 <dcoutts_> that allows values with different sized representations to be treated unformly
10:57:02 <frobenius> sounds like references to me
10:57:17 <frobenius> in SML
10:57:21 <dcoutts_> and it allows the value to be an unevaluated thunk, ie lazyness
10:57:28 <frobenius> aha
10:57:39 <frobenius> anyways, what are the consequences of forgetting to !
10:57:39 <frobenius> ?
10:57:40 <dcoutts_> it's not references
10:57:50 <dcoutts_> your constructor becomes lazy
10:58:02 <frobenius> e.g. using data without ! instead of newtype in a REC thingie
10:58:05 <dcoutts_> with ! the constructor function is strict inthose arguments
10:58:25 <dcoutts_> semantically it'll be the same, but the newtype will be more effecient
10:58:27 <frobenius> i.e. not lazy
10:58:47 <frobenius> hm, I thought i was cruical in this case that data Rec ... had the bang
10:58:54 <frobenius> for modelling inductive types e.g.
10:58:54 <dcoutts_> right, no *extra* laxyness by the use of the In constructor
10:59:04 <frobenius> perhaps the coinductive types arises if we forget !?
10:59:22 <frobenius> is there a good example?
10:59:31 <frobenius> take a Conslist.... ?
10:59:50 <dcoutts_> you could build a strict list by using ! in the Cons constructor
11:00:02 <dcoutts_> you could make it lazy in the list spine or the list elements or both
11:00:10 <dcoutts_> depending on the Cons:
11:00:51 <dcoutts_> data List a = Nil | Cons a !(List a)
11:00:51 <frobenius> what _is_ a strict list?
11:00:51 <dcoutts_> it's one that must always be fully evaluated
11:00:51 <frobenius> does it behave ML-ish?
11:00:51 <dcoutts_> yes
11:00:51 <frobenius> aha
11:01:00 <frobenius> so what is this talk about the _extra_ lifting?
11:01:13 <frobenius> let me try to summarise
11:01:26 <palomer> dcoutts: btw, I found a cheap fix to the resizing problem
11:01:31 <frobenius> although a node may be evaluated itself lazily, the lack of ! makes the whole list be lazily evaluated e.g. for a list-function
11:01:34 <dcoutts_> palomer, oh yeah?
11:01:40 <palomer>       windowSetDefaultSize tipWindow 0 0
11:01:47 <dcoutts_> palomer, ah!
11:02:13 <dcoutts_> palomer, sounds like the right fix. Well done.
11:02:18 <palomer> :P
11:02:52 <dcoutts_> frobenius, the most precise way to desribe it is in terms of the strctness of the constructor funcion
11:03:10 <dcoutts_> frobenius, you know what function strictness mean precisely, right?
11:03:23 <vincenz> is there some function that removes duplicates?
11:03:36 <dcoutts_> @type Data.List.nub
11:03:36 <vincenz> (from lists)
11:03:37 <lambdabot> forall a. (Eq a) => [a] -> [a]
11:04:06 <frobenius> f(bot)=bot
11:04:12 <dcoutts_> vincenz, nub preserves order too, so it's more expensive than if you don't care about reordering
11:04:16 <dcoutts_> frobenius, right
11:04:26 <vincenz> dcoutts_: so if I don't care about reordering, then whay?
11:04:27 <vincenz> what even
11:04:49 <dcoutts_> frobenius, so without ! annotations there is no way of making a constructor function strict in any argument.
11:05:04 <dcoutts_> vincenz, map head . group . sort
11:05:17 <vincenz> thx
11:05:35 <frobenius> unless we use newtype, so newtype can e.g. give a ML-list?
11:05:59 <frobenius> in the same way as !
11:06:01 <dcoutts_> frobenius, no because a newtype can only have a single constructor with a single field.
11:06:02 <frobenius> so newtype gives strictness
11:06:17 <frobenius> aha, additional restriction then
11:06:20 <dcoutts_> frobenius, no data with ! gives strictness, newtype is just a special case of data
11:06:23 <frobenius> but for my situation I can, if I encode lists cleverly
11:06:29 <frobenius> ok, that was very useful
11:06:31 <frobenius> thanks a lot for that
11:06:38 <dcoutts_> frobenius, you can define strict lists with data & !
11:06:41 <frobenius> got to see if the head of department is around, bye!
11:06:54 <dcoutts_> data StrictList a = Nil | Cons a !(List a)
11:06:58 <frobenius> dcoutts_ yes I got that much!
11:07:05 <dcoutts_> data UnreasonablyStrictList a = Nil | Cons !a !(List a)
11:07:34 <frobenius> please explain the latter
11:07:50 <dcoutts_> frobenius, look at the possabilities:
11:07:56 <dcoutts_> data List a = Nil | Cons a (List a)
11:07:59 <dcoutts_> data List a = Nil | Cons a !(List a)
11:08:01 <dcoutts_> data List a = Nil | Cons !a (List a)
11:08:03 <dcoutts_> data List a = Nil | Cons !a !(List a)
11:08:11 <dcoutts_> what do each mean?
11:08:23 <dcoutts_> 1. is an ordinary lazy list
11:08:47 <dcoutts_> 2. is a list that is strict in its spine but lazy in its elements
11:08:59 <dcoutts_> 3. & 4. are strict in their elements
11:09:17 <dcoutts_> 3. is just odd, you'd never need that combination
11:16:12 <araujo> Hello.
11:21:01 <araujo> dcoutts_, ping
11:21:04 <frobenius> dcoutts_ excellent, but what does it mean to be lazy in its elements?
11:22:31 <dcoutts_> > length [undefined, undefine]
11:22:32 <lambdabot>  Not in scope: `undefine'
11:22:34 <dcoutts_> > length [undefined, undefined]
11:22:35 <lambdabot> 2
11:22:46 <dcoutts_> that is a list that is lazy in its elements
11:23:00 <frobenius> aha
11:23:01 <frobenius> I see.
11:23:04 <frobenius> Clever stuff.
11:23:25 <dcoutts_> and a list that is lazy in it's structure:
11:23:28 <frobenius> and by default everything is lazy
11:23:44 <dcoutts_> > take 2 (1:2:undefined)
11:23:46 <lambdabot> [1,2]
11:24:23 <dcoutts_> with a strict (ML-like) list that would return undefined
11:24:26 <palomer> dcoutts: how do you change a TextTagClass self => WriteAttr self String ?
11:24:42 <araujo> dcoutts_, hello there, wanted just to ask you... where is it treeViewColumnAssociate in the api?
11:24:48 <dcoutts_> palomer, set widget [ arrt := value ]
11:24:57 <dcoutts_> palomer, set widget [ attr := value ]
11:25:27 <dcoutts_> araujo, look at the name. *treeViewColumn*Associate
11:25:42 <dcoutts_> try the TreeViewColumn module
11:26:11 <dcoutts_> araujo, you can also use the index of the haddock docs
11:26:24 <araujo> dcoutts_, not there :-(
11:26:29 <palomer> adding a tag to a buffer is nothing more than calling textBufferApplyTag?
11:26:32 <icbt> @seen Lemmih
11:26:32 <lambdabot> I saw Lemmih leaving #haskell-blah and #haskell 3 days, 3 hours, 45
11:26:32 <lambdabot> minutes and 25 seconds ago, and I have missed 4 seconds since then.
11:26:42 <araujo> dcoutts_, ive been looking throuhg the api, but nothing....
11:26:54 <frobenius> should I ask for a lecture in boxing too? ;-)
11:27:51 <dcoutts_> araujo, why do you think there is such a function?
11:28:33 <dcoutts_> palomer, yep
11:29:44 <araujo> dcoutts_, http://darcs.haskell.org/gtk2hs/demo/treeList/ListTest.hs
11:30:50 <palomer> dcoutts: so you don't have to add it to the tagTable manually?
11:31:13 <frobenius> byer
11:31:14 <frobenius> bye
11:34:58 <araujo> dcoutts_, i also fail to find treeViewColumnNewText
11:35:58 <dcoutts_> palomer, actually yes the tag has to bin in the tag table already.
11:37:12 <palomer> dcoutts: do I need to apply it after I add it to make it work?
11:37:47 * frobenius I have a persisting problem with hmake --- I keep getting: ghc      -c -package hat -o Hat/hoas.o Hat/hoas.hs
11:37:50 * frobenius ghc-6.2: unknown package name: hat 
11:38:02 <frobenius> I get the following from hmake : ghc      -c -package hat -o Hat/hoas.o Hat/hoas.hs
11:38:06 <frobenius> ghc-6.2: unknown package name: hat 
11:38:06 <dcoutts_> palomer, you add the differnt kinds of tags you want to use in a buffer to the buffer's tag table. Then you can apply any of those tag kinds to as many spans of text in the buffer as you like.
11:38:19 <dcoutts_> araujo, those were from the mogul package which we removed.
11:38:38 <frobenius> I have a problem with hat (and now also with irc...)
11:38:41 <frobenius> hello?
11:38:59 <dcoutts_> araujo, so that demo/treeList/ListTest.hs is old and borken. Sorry.
11:39:12 <dcoutts_> araujo, look at the demo I sent you the other day instead.
11:40:16 <araujo> dcoutts_, ok.. looking through the api, i suppose i wanna something like treeViewColumnPackStart instead...?
11:40:22 <palomer> dcoutts: oh, nice
11:40:31 <frobenius> hi, did you get my messages?
11:40:37 <frobenius> I have a problem with the IRC software it seems
11:40:50 <araujo> frobenius, ghc-pkg list
11:40:56 <frobenius> aha
11:40:57 <dcoutts_> araujo, look at the demo I sent.
11:40:58 <araujo> And see if you have hat there
11:40:58 * dcoutts_ has to go
11:41:04 <araujo> OK dcoutts_ 
11:41:21 <frobenius> there is no hat there in the list
11:41:26 <frobenius> thanks dcoutts
11:41:31 <frobenius> for the help
11:41:42 <araujo> Well, then that's your problem :-)
11:41:43 <frobenius> it was quite interesting! ;-)
11:42:02 <palomer> in sml I would do something like this: local val a = ref 2 in inc () = a := 2 end     , is there a way to do this in haskell?
11:42:13 <palomer> (I want to implement global variables through functions)
11:42:56 <frobenius> Ok so I need to add a package (hat is already installed though)
11:43:16 <palomer> getCounter () = readIORef counter where counter = newIORef 0 <--something like this would be nice
11:43:30 <palomer> but would that work:o?
11:46:08 <frobenius> is there a package configuration file in the hat distribution?
11:46:24 <frobenius> is it perhaps the file .../lib/hat/.../config ?
11:52:41 <palomer> monads, they're everywhere!
11:53:00 <waern> gotta love them
11:54:56 <palomer> what are the standard ways to iterate over datatypes?
11:55:04 <palomer> preOrderFold? inOrderFold?
11:56:35 <palomer> @hoogle IORef
11:56:37 <lambdabot> Data.IORef.IORef :: IORef a
11:56:37 <lambdabot> Data.IORef.newIORef :: a -> IO (IORef a)
11:56:37 <lambdabot> Data.IORef.readIORef :: IORef a -> IO a
11:56:44 <palomer> > newIORef 2
11:56:45 <lambdabot>  Not in scope: `newIORef'
11:56:53 <palomer> Data.IORef.newIORef 2
11:56:54 <palomer> > Data.IORef.newIORef 2
11:56:55 <vincenz> @hoogle [a] -> Maybe a
11:56:55 <lambdabot>  Not in scope: `Data.IORef.newIORef'
11:56:56 <lambdabot> Data.Maybe.listToMaybe :: [a] -> Maybe a
11:56:56 <lambdabot> Data.Maybe.Nothing :: Maybe a
11:56:56 <lambdabot> Prelude.Nothing :: Maybe a
11:57:31 <palomer> round should really appear for @hoogle Double -> int
12:04:31 <glauber_sp> guys, does anyone has any suggestion of paper or book on algebraic specification of abstract data types?
12:05:15 <frobenius> what do you mean by _abstract_ ? existential quantifier?
12:05:55 <frobenius> is anybody good at ghc-pkg?
12:07:09 <machack666> here's what's wrong with haskell:
12:07:10 <frobenius> if you mean just usual datatypes with equations, then I have many references for you.
12:07:43 <frobenius> otherwise existential quantifier makes things rather tricky, consider hidden algebra
12:07:46 <glauber_sp> frobenius, yes, it's datatypes with equations defining their operations
12:07:52 <frobenius> ok
12:07:57 <frobenius> then there are many good references.
12:08:00 <machack666> once you learn it, when you have to do something else in another language, you think "oh, why can't I just use (autocurrying | function pattern matching| ... whatever else)".
12:08:05 <frobenius> check meinke's Universal Algebra in a handbook. not online
12:08:07 <machack666> but you can't
12:08:10 <frobenius> that's a really good one
12:08:23 <machack666> you can't go home again. :( :)
12:08:26 <frobenius> now, I sort of desperate here, can someone help me to get ghc-pkg to add something?
12:08:57 <glauber_sp> frobenius, do u have any online or downloadable source?
12:08:59 <frobenius> there are also books Erwig et al getting a bit old, but check library for it
12:09:04 <sieni> machack666: are you suggesting, that the biggest problem of Haskell is its superiority comparet to other languages?
12:09:06 <frobenius> search for "algebraic specifications"
12:09:15 <frobenius> that should give you some hits
12:09:23 <frobenius> nope, not really
12:09:33 <frobenius> there are some on-line books though on Universal Algebra.
12:09:35 <frobenius> Check them out too
12:09:39 <frobenius> But mostly, check the meinke ref.
12:09:42 <frobenius> for computer science
12:09:56 <glauber_sp> frobenius, I've done this already. a lot of fonts, even in ACM library. I don't know which one to read =)
12:09:57 <machack666> sieni: it sure is a problem getting me to work on my $job :)
12:10:01 <frobenius> Erwig and Mahr
12:10:11 <frobenius> mmm, well I'd get the above book really
12:10:16 <frobenius> or the handbook chapter
12:10:24 <frobenius> or else, check Joseph Goguen's homepage
12:10:25 <glauber_sp> frobenius, I'll search for and take a look , so =)
12:10:28 <frobenius> that might give you some stuff
12:10:39 <glauber_sp> ok, thanks =) I'll take note on this
12:10:47 <frobenius> why interested in this btw?
12:11:56 <glauber_sp> frobenius, I want to do my final work at the university in algebraic specification, lambda calculus. Now I've read a lot of haskell tutorials and maybe I use haskell not OBJ3 or CASL
12:12:19 <frobenius> algebraic spec is very different to lambda calculus
12:12:23 <frobenius> no binders in algebhra
12:12:31 <palomer> @hoogle readioref
12:12:31 <lambdabot> Data.IORef.readIORef :: IORef a -> IO a
12:12:49 <frobenius> but it might be interesting to try to combine them!!!
12:13:31 <palomer> @hoogle newIORef
12:13:32 <lambdabot> Data.IORef.newIORef :: a -> IO (IORef a)
12:13:33 <glauber_sp> frobenius, I know (a little). that't the idea. combine alg. spcecification of ADTs using lambda calculus and functional languages
12:13:48 <frobenius> good luck
12:13:48 <palomer> grr
12:13:57 <palomer> is there a way to have global variables through functions in haskell?
12:14:03 <frobenius> palomer, do you know ghc-pkg
12:14:05 <glauber_sp> frobenius, thanks =) i guess I'll need eheh
12:14:10 <palomer> frobenius: nope
12:14:33 <JKnecht> ADT = Algebraic Data Type?
12:14:39 <glauber_sp> JKnecht, yeap
12:14:43 <frobenius> or abstract perhaps
12:14:44 <glauber_sp> no, abstract
12:14:45 <frobenius> not sure
12:14:52 <glauber_sp> abstract data types
12:15:05 <frobenius> we got to be careful here
12:15:35 <frobenius> but generally, I think it meens abstract
12:15:49 <glauber_sp> it's almost like the haskell modules import/export stuff. u define the methods that ADT will have to operate it.
12:16:07 <glauber_sp> and don't show the implementation.
12:16:35 <glauber_sp> and use algebra to prove which methods are necessary and make the ADT complete
12:17:16 <glauber_sp> sigma-algebras are involved too
12:18:34 <frobenius> sure
12:19:04 <frobenius> work on examples, that's my final suggestion for you
12:19:06 <frobenius> goodnight
12:19:20 <glauber_sp> frobenius, thanks. good bay =)
12:22:41 <araujo> dcoutts_, goodie... got itto work without mogul!
12:22:42 <palomer> this is the first time I'm aching for global variables
12:23:20 * araujo wonders if the segfaults still happen though
12:24:04 <araujo> bah, yes :-(
12:28:54 <waern> palomer, check out implicit parameters
12:29:28 <palomer> of course segfaults still happen
12:30:51 <palomer> dcoutts: how do you get the TextIter on line 5 offset 6?
12:31:57 <palomer> ahh, got it
12:32:03 <palomer> textBufferGetIterAtLineOffset
12:32:07 <palomer> kept looking at textview
12:34:00 <araujo> No, they don't have to happen!
12:34:11 <araujo> @yay!
12:34:11 <lambdabot> Unknown command, try @listcommands.
12:34:16 <araujo> @yaw!
12:34:17 <lambdabot> My life is a patio of fun!
12:36:03 <dcoutts> palomer, in general, the textbuffer ones give operations in "buffer space" ie logical lines etc and the textview has some extra ones for "view space" eg visual lines and stuff related to the bit of the buffer that is currenty visible in the view.
12:39:37 <palomer> dcoutts: yeah, but some functions in textview do act on textiterators
12:40:01 <dcoutts> palomer, yeah, that's what i mean about the view space
12:40:19 <palomer> hrm
12:40:24 <dcoutts> it only has ones that would not make sense in the buffer
12:40:24 <palomer> how do I remove all highlighting?
12:40:30 <palomer> err, all tag applications
12:40:39 <dcoutts> since they depend on aspects of the view
12:40:53 <palomer> dcoutts: textIterBeginsLine?
12:41:40 <dcoutts> palomer, http://haskell.org/gtk2hs/docs/current/Graphics-UI-Gtk-Multiline-TextBuffer.html#v%3AtextBufferRemoveAllTags
12:42:03 <dcoutts> http://haskell.org/gtk2hs/docs/current/Graphics-UI-Gtk-Multiline-TextIter.html#v%3AtextIterStartsLine
12:42:12 <dcoutts> palomer, check the docs, it's all there
12:43:18 <palomer> dcoutts: yeah, texitIterStartsLine should be in textbuffer
12:43:48 <palomer> dcoutts: btw, my check to see if a TextIter is at the end of a line is to move it to the end of the line and see if it changed
12:46:36 <dcoutts> palomer, I guess the ones that only operate on a single text iter are in the TextIter module. We're just following the Gtk+ module naming convention.
12:49:50 <palomer> @hoogle Maybe a -> a
12:49:51 <lambdabot> Data.Maybe.fromJust :: Maybe a -> a
12:49:51 <lambdabot> Data.Maybe.fromMaybe :: a -> Maybe a -> a
12:49:51 <lambdabot> Data.Graph.Inductive.Monad.emptyM :: GraphM m gr => m (gr a b)
12:53:36 <TuringTest> @seen dons
12:53:36 <lambdabot> dons is in #haskell-blah and #haskell. Last spoke 13 hours, 27 minutes
12:53:36 <lambdabot> and 40 seconds ago.
12:55:26 <TuringTest> I have a question about a ghc error message.
12:55:34 <TuringTest> Interface file inconsistency:
12:55:34 <TuringTest>   home-package module `Language.Hi.Parser' is mentioned,
12:55:34 <TuringTest>   but does not appear in the dependencies of the interface
12:55:48 <TuringTest> does anyone know what this trying to tell me?
12:56:29 <chuck1> turingtest: your .hi- and .o-files might be out of sync, try removing them and compiling again?
12:56:34 <chuck1> (just a guess)
12:56:42 <chuck1> don't delete anything you can't restore of course. :)
12:57:12 <TuringTest> I am trying to get hs-plugins working.  I got the code to run in ghci, but ghc won't compile it.
12:57:35 <chuck1> ah okay. Sorry, I have very limited experience with hs-plugins
12:57:56 <phas> @seen phas
12:57:56 <lambdabot> You are in #haskell.it and #haskell. Last spoke just now.
13:12:08 <palomer> hrm
13:12:16 <palomer> so implicit arguments is the only way to have global state?
13:12:43 <ndm> palomer: IORef's?
13:12:57 <Trevion> a top level State monad?
13:13:55 <palomer> ndm: how do IORefs give me global variables?
13:14:11 <ndm> palomer: you can use them as global variables
13:14:18 <palomer> ndm: how?
13:14:19 <bosie> hello
13:15:36 <ndm> palomer: easily, http://haskell.org/ghc/docs/latest/html/libraries/base/Data-IORef.html
13:15:43 <ndm> declare your global variable
13:15:58 <ndm> myGlobal = newIORef "value"
13:16:04 <palomer> ahh, righto
13:16:29 <ndm> palomer: i think, i've never actually done it - so it may nto work
13:16:35 <ndm> but thats my best understanding of it
13:17:24 <palomer> yeah, it should
13:18:05 <bosie> the primary difference between "normal" functions and monads is that monads have side effects and normal functions dont right?
13:18:49 <ndm> bosie, thats only true for the IO monad
13:18:56 <bosie> oki
13:18:59 <ndm> well, roughly true for the IO monad
13:19:36 <int-e> ndm, palomer: http://haskell.org/hawiki/GlobalMutableState
13:19:49 <chuck1> int-e: Wow, beat me by a second. :)
13:20:06 <chuck1> I had *just* pasted the link and was about to hit enter.
13:20:22 <shapr> I am NOT sharper! It's shay-per! sheesh.
13:20:42 <hyp> shaper
13:20:48 <shapr> y0 hyp 
13:20:54 <palomer> sounds sharp to me
13:21:04 <hyp> :) hi
13:21:05 <shapr> palomer: pale-omar?
13:21:29 <shapr> How's code?
13:21:49 <shapr> So, anyone want to hire me for contract programming work? :-)
13:22:16 <palomer> shapr: out of work?
13:22:29 <shapr> palomer: No, but wishing to be out of the work I have.
13:23:38 <palomer> which is?
13:23:55 <palomer> @hoogle newIORef
13:23:56 <lambdabot> Data.IORef.newIORef :: a -> IO (IORef a)
13:24:02 <shapr> Minimally paid Zope/Plone work for clients with unrealistic expectations.
13:24:49 <shapr> Sadly, I contributed to those unrealistic expectations myself somewhat...
13:24:56 * shapr shrugs
13:30:10 <shapr> shazam!
13:30:12 <palomer> how do you catch mouse click events?
13:30:19 * shapr gets a catcher's mitt
13:30:24 <basti_> palomer: onButtonSomething
13:30:33 <int-e> Clicked
13:30:51 <basti_> palomer: why didnt you just look near where you found the last callback thing? ;)
13:31:08 <palomer> I'm using onButtonPress
13:31:18 <palomer> oh wait, it works
13:31:19 <palomer> nevermind
13:31:20 <palomer> :P
13:33:10 <palomer> top level IORef doesn't seem to work
13:34:37 <palomer> @hoogle unsafePerformIO
13:34:38 <lambdabot> Foreign.unsafePerformIO :: IO a -> a
13:34:38 <lambdabot> System.IO.Unsafe.unsafePerformIO :: IO a -> a
13:35:47 <palomer> @hoogle readIORef
13:35:47 <lambdabot> Data.IORef.readIORef :: IORef a -> IO a
13:35:58 <palomer> @hoogle newIORef
13:35:59 <lambdabot> Data.IORef.newIORef :: a -> IO (IORef a)
13:36:25 <palomer> why isn't newIORef of type a -> IO () ?
13:36:44 <palomer> or, rather
13:36:48 <palomer> a -> IORef a
13:42:51 <palomer> weee
13:43:08 <palomer> someone give me a fun lambda term (integers allowed)
13:44:02 <TuringTest> @type newIORef
13:44:03 <lambdabot> Not in scope: `newIORef'
13:47:04 <palomer> @hoogle newIORef
13:47:05 <lambdabot> Data.IORef.newIORef :: a -> IO (IORef a)
13:48:02 <waern> dcoutts, there?
13:49:41 <palomer> dcoutts: it works great:P!
13:49:58 <palomer> dcoutts: is it possible to say "when this event happens, just pass it along to this widget" ?
13:52:25 * SamB again wonders how a C-- compiler is supposed to work...
14:00:59 <palomer> very carefully
14:01:35 <palomer> Philippa_ was right, Monad is really a fancy word for higher order abstract syntax
14:01:42 <palomer> which is 4 fancy words
14:01:48 <int-e> palomer: widgetAddEvents should do that.
14:02:11 <int-e> palomer: if I understand the question correctly
14:05:28 <dcoutts> palomer, what do you mean exactly with "when this event happens, just pass it along to this widget"
14:05:44 <dcoutts> palomer, do you have an example of what would that be for?
14:05:50 <dcoutts> waern, hia
14:06:16 <waern> dcoutts, i was trying to build gtk2hs.hide and got errors in hsgclosure.c
14:06:36 <waern> i'm almost finished with hIDE building :) 
14:06:48 <waern> i'm trying the regular gtk2hs now instead
14:06:58 <palomer> dcoutts: well, when I click on the tooltip, I want the click to pass through to the textview
14:07:12 <dcoutts> waern, the problem is the version of ghc.
14:07:26 <dcoutts> waern, gtk2hs needs a patch to work with ghc-6.5
14:07:36 <waern> aha
14:07:39 <waern> i'll stop building then :)
14:07:55 <dcoutts> waern, I sent the patch to Lemmih but it doesn't look like he comitted it to that gtk2hs repo.
14:08:17 <waern> mmkay
14:08:18 <dcoutts> palomer, I see. That is possible I think.
14:08:29 <dcoutts> palomer, it's not nice though :-)
14:08:42 <ADEpt> is it true, that there is, in fact, NO well-known implementation of the simplex method in Haskell?
14:08:53 <palomer> dcoutts: how so?
14:09:08 <palomer> ADEpt: it would be trivial to write
14:09:10 <waern> dcoutts, could you send it to me? davve at dtek.chalmers.se
14:09:49 <dcoutts> waern, give me a moment, I'll see if I can apply the patch to that gtk2hs darcs repo
14:09:58 <waern> okay
14:10:14 <dcoutts> palomer, we've actually been trying to get rid of the event data structure
14:10:36 <ADEpt> palomer: i feel so, but i;ve managed to forget half that i was taught about it AND i've lost my copies on Knut and Algorithms somewhere :(
14:10:40 <dcoutts> palomer, which is possible since all the signals that take an event only use a specific constructor of the event type
14:12:35 <TuringTest> @seen dons
14:12:35 <lambdabot> dons is in #haskell-blah and #haskell. Last spoke 14 hours, 46 minutes
14:12:35 <lambdabot> and 39 seconds ago.
14:13:01 <dons> hey
14:15:33 <dcoutts> palomer, there is gtk_propagate_event, but I don't like it. It's rather low level.
14:15:48 <palomer> yeah, why not simply create an Event class?
14:15:56 <palomer> which is subclassed
14:16:09 <dcoutts> palomer, or gtk_widget_event
14:16:54 <dcoutts> palomer, it's not something apps are really supposed to do
14:17:01 <palomer> yeah, maybe you're right
14:17:09 <dcoutts> palomer, just because it's part of the gtk+ api doesn't mean it's ok
14:17:10 <palomer> hrmph
14:17:20 <dcoutts> palomer, gtk exposes a bunch of stuff for widget implementations
14:17:36 <dcoutts> and C is not really a language that allows you to hide things very well anyway
14:17:59 <palomer> true true
14:18:09 <palomer> so are you guys going to implement the Event class anytime soon?
14:18:24 <dcoutts> not sure, perhaps
14:18:35 <dcoutts> palomer, the docs for gtk_propagate_event say:
14:18:39 <dcoutts> All that said, you most likely don't want to use any of these functions; synthesizing events is rarely needed. Consider asking on the mailing list for better ways to achieve your goals. For example, use gdk_window_invalidate_rect() or gtk_widget_queue_draw() instead of making up expose events.
14:18:51 <dcoutts> and the gtk_widget_event are similar
14:19:19 <dcoutts> it says: If you want to synthesize an event though, don't use this function; instead, use gtk_main_do_event()
14:19:26 <dcoutts> and gtk_main_do_event says don't use it :-)
14:19:37 <palomer> okay okay, I'm convinced!
14:19:41 <dcoutts> :-)
14:19:56 <palomer> oh, wait, having an event datatype is useful
14:20:03 <dcoutts> where?
14:20:08 <palomer> since I can write an event handling function for my widget
14:20:22 <palomer> and all events will be directed towards this one function
14:20:25 <dcoutts> that handles any kind of event?
14:20:36 <palomer> that handles many kinds of events
14:20:41 <palomer> this way I can reroute safely
14:20:44 <dcoutts> palomer, it's not more sensible to have different functions for different events?
14:21:17 <int-e> I think palmomer just wants to forward them to another handler.
14:21:29 <palomer> dcoutts: in this case I think the overloading makes sense
14:21:40 <palomer> dcoutts: you also don't have to remember 10 different function names
14:22:17 <dcoutts> palomer, the main reason I'd like handlers to take only one event type is that it makes it clear from the type which constructor you need to match against
14:22:42 <dcoutts> if it's just (Event -> IO ()) in the docs, how do you know what event constructor it should be?
14:22:52 <palomer> dcoutts: good point
14:22:59 <dcoutts> if the type is right the it's self documenting
14:23:01 <palomer> I guess this is a usability vs clarity
14:23:02 <palomer> issue
14:23:15 <dcoutts> I think it's more a 90%/10% issue
14:23:26 <dcoutts> 90% is clearer and easier to do it that way
14:23:37 <dcoutts> 10% if the time the extra flexibiltiy comes in handy
14:23:48 <dcoutts> palomer, you're in the 10% :-)
14:23:52 <palomer> if your widget does a lot of signal handling, it would suck to have to write 10 different functions where one would do
14:24:08 <dcoutts> palomer, you have to write 10 different functions anyway
14:24:17 <palomer> yes, but under the same name!
14:24:22 <dcoutts> palomer, it's just one way you can give them all the same name
14:24:26 <dcoutts> yeah
14:24:33 <palomer> dcoutts: and if you're rerouting, you would only write one function
14:24:37 <palomer> how would you reroute otherwise?
14:25:08 <dcoutts> palomer, for rerouting you want to have one signal handler that catches all event types
14:25:27 <dcoutts> palomer, not connect the same handler 10 times
14:25:50 <palomer> onMotion tipWindow True $ reroute textView
14:26:09 <vincenz> is there something like concatMap for set?
14:26:24 <dcoutts> palomer, except that you have to adjust the coords to pass it on to another widget
14:26:49 <palomer> dcoutts: it depends on the event
14:27:00 <palomer> dcoutts: for example, I simply detect mouseclicks and toggle a boolean
14:27:07 <dcoutts> palomer, I don't think rerouting is either very common or very easy
14:27:45 <palomer> I'm just playing devil's advocate
14:27:53 <dcoutts> sure :-)
14:28:03 <palomer> haskell should have some form of ad-hoc polymorphism
14:28:16 <vincenz> concatMap for set?
14:28:29 <int-e> palomer: I believe it'd be a nightmare.
14:28:40 <SamB> palomer: type classes
14:28:42 <palomer> int-e: not if it's done right!
14:28:52 <SamB> "making ad-hoc polymorphism a little less ad-hoc"
14:29:06 <dcoutts> vincenz:
14:29:06 <dcoutts> @type Data.Set.unions
14:29:07 <lambdabot> forall a. (Ord a) => [Data.Set.Set a] -> Data.Set.Set a
14:29:12 <vincenz> dcoutts: that's not concatMap
14:29:16 <dcoutts> no?
14:29:20 <palomer> @hoogle concatMap
14:29:21 <lambdabot> Data.List.concatMap :: (a -> [b]) -> [a] -> [b]
14:29:21 <lambdabot> Prelude.concatMap :: (a -> [b]) -> [a] -> [b]
14:29:24 <vincenz> ;)
14:29:24 <dcoutts> oh no map :-)
14:29:44 <palomer> @index Set
14:29:45 <lambdabot> Data.Set, Graphics.Rendering.OpenGL.GL.PerFragment, Graphics.Rendering.
14:29:45 <lambdabot> OpenGL.GL, Graphics.Rendering.OpenGL, Graphics.UI.GLUT
14:30:03 <palomer> hmmm
14:30:08 <palomer> Set isn't even a Monad!
14:30:09 <vincenz> I do it like this
14:30:10 <palomer> I'm shocked
14:30:16 <dcoutts> vincenz, you want to map each member of a set to another set and then union them all?
14:30:18 <int-e> @type S.unions . fmap . fmap
14:30:19 <lambdabot> Couldn't find qualified module.
14:30:19 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
14:30:19 <lambdabot> \\)?
14:30:24 <SamB> @hoogle (a -> [b]) -> Data.Set.Set a -> Data.Set.Set b
14:30:25 <lambdabot> No matches, try a more general search
14:30:28 <int-e> @type Data.Set.unions . fmap . fmap
14:30:30 <lambdabot>   Couldn't match `[Data.Set.Set a]' against `f (f1 a1) -> f (f1 b)'
14:30:30 <lambdabot>   Expected type: (a1 -> b) -> [Data.Set.Set a]
14:30:38 <vincenz> unionManySets $ map mkSet $ map f $ setToList s
14:30:43 <vincenz> is this inefficient?
14:31:01 <palomer> yes
14:31:09 <palomer> but who cares? you're using haskell anyways
14:31:17 <vincenz> well before
14:31:18 <vincenz> I had
14:31:29 <vincenz> map head . group . sort $ concatMap f x
14:31:38 <dcoutts> @type Data.Set.unions . map f . Data.Set.elems
14:31:39 <lambdabot> Not in scope: `f'
14:31:44 <dcoutts> @type \f -> Data.Set.unions . map f . Data.Set.elems
14:31:45 <lambdabot> forall a a1.
14:31:45 <lambdabot> (Ord a) =>
14:31:45 <lambdabot> (a1 -> Data.Set.Set a) -> Data.Set.Set a1 -> Data.Set.Set a
14:32:02 <vincenz> is the new approach more efficient?
14:32:04 <vincenz> map head . group . sort $ concatMap f x
14:32:05 <vincenz> vs
14:32:08 <vincenz> unionManySets $ map mkSet $ map f $ setToList s
14:32:18 <jethr0> @pl \x y -> compare (snd x) (snd y)
14:32:18 <lambdabot> (. snd) . compare . snd
14:32:52 <int-e> hmm, why isn't Set an instance of Functor?
14:33:06 <dcoutts> int-e, because of the Ord constraint problem
14:33:32 <SamB> dcoutts: ouch
14:33:49 <dcoutts> SamB, propose it for Haskell-prime!
14:34:05 <int-e> vincenz: Data.Set has a map function
14:34:16 <int-e> (for sets)
14:34:18 <SamB> dcoutts: how?
14:34:24 <SamB> I don't have a clue how to make it not be ouch!
14:34:33 <dcoutts> SamB, make "data Ord a => Foo a = Bar ..." mean what everyone thinks it ought to mean!
14:34:49 <int-e> dcoutts: thanks
14:34:52 <SamB> dcoutts: oh
14:34:56 <SamB> that
14:35:03 <SamB> so do I need to join the list?
14:35:16 <dcoutts> SamB, yep
14:35:34 <dcoutts> SamB, so what does the above mean and what should it mean?
14:36:50 <SamB> dcoutts: good question
14:36:54 <SamB> I'm not sure GHC can handle it
14:37:04 <dcoutts> data Ord a => Set a = Set [a]
14:37:09 <dcoutts> that works in hugs & ghc
14:37:47 <SamB> well, without tucking the dictionaries into the constructors
14:39:07 <dcoutts> SamB, so what does it mean curently?
14:39:37 <dcoutts> SamB, it means that the constructor Set has the type: Set :: (Ord a) => [a] -> Set a
14:39:45 <dcoutts> and what does it not mean...
14:39:49 <SamB> I have no idea, but it seems to do next to nothing
14:40:06 <dcoutts> it does not mean that you can only form types Set a for a in the type class Ord
14:40:44 <dcoutts> it means merely that you can only *construct* values of type Set for some a in Ord
14:41:01 <dcoutts> but you can never rely on that fact anywhere else in your program
14:41:17 <dcoutts> just because you've got a Set a doesn't mean the a is in Ord
14:41:46 <dcoutts> despite the fact that the only way you could ever construct such a value (appart from _|_) would mean a was in Ord
14:41:51 <dcoutts> so it's useless
14:42:20 <dcoutts> if it meant what it looks like it means then you could make Set a and instance of Ord (for a in Ord)
14:42:27 <dcoutts> and/an
14:45:31 <shapr> Hey, do you say "write on a keyboard" or "write with a keyboard" ?
14:46:20 <waern> dcoutts, any chance i'll get that patch tonight? :)
14:46:30 <waern> or else i'm going to bed now
14:47:34 <dcoutts> waern, oh, bummer, it turns out that only Lemmih can commit to that repo, I'll email you the file.
14:51:46 <dcoutts> waern, sent
14:52:00 <dcoutts> @seen Lemmih
14:52:01 <lambdabot> I saw Lemmih leaving #haskell-blah and #haskell 3 days, 7 hours, 10
14:52:01 <lambdabot> minutes and 53 seconds ago, and I have missed 4 seconds since then.
14:52:43 <waern> dcoutt, got it, thanks
14:53:11 <shapr> dcoutts: Which repo?
14:53:26 <dcoutts> shapr, gtk2hs.hide on darcs.haskell.org
14:53:28 <shapr> oh
14:53:35 * shapr has no power there
14:53:47 <dcoutts> not our server :-(
14:55:18 <vincenz> they should make a typeclass Mappable
14:55:24 <vincenz> so that map of Set and List don't interfere
14:56:44 <vincenz> @pl (\(x,y) -> (y,x))
14:56:45 <lambdabot> uncurry (flip (,))
14:59:11 <dons> vincenz, maybe you want Functor class for that.
14:59:31 <dons> use fmap, which is just `map' on lists
15:00:17 <dons> oh, but Set isn't in Functor :/
15:08:45 <TuringTest> dons: I just started using hs-plugins
15:09:06 <dons> cool.
15:09:31 <TuringTest> dons: I hooked up my http://haskell.org/hawiki/ShortExamples_2fSymbolDifferentiation code to it
15:10:20 <TuringTest> So I can disassemble a (Floating a => a -> a) function, differentiate and simplify it, and the pretty print and recompile it.
15:10:33 <TuringTest> Who needs lisp?
15:10:44 <dons> ah, ok. cool!
15:10:49 <Nanar> stupid question, return does not end the function, only the block ?
15:10:50 <dons> yeah, _exactly_
15:11:18 <Igloo> return doesn't end the block either
15:11:20 <dons> Nanar, hmm. it's not quite like that.
15:11:25 <Igloo> It just makes a monadic value
15:11:40 <Nanar> ah ok
15:11:54 <musasabi> Is there a reason that not all Monads are Functors?
15:12:05 <Nanar> very different with return from C :)
15:12:10 <TuringTest> Nanar: it passes the value to the next statement, which may be right under it, otherwise it will be at where the block was called.
15:12:25 <TuringTest> musasabi: That a FAQ.
15:12:38 <Nanar> TuringTest: ok many thanks
15:12:53 <dons> TuringTest, http://www.cse.unsw.edu.au/~dons/papers.html "We show that Haskell can be comfortably used as a statically typed extension language" ;)
15:14:15 <jethr0_> can you export everything from a module except a few bindings?
15:14:29 <Igloo> import Foo hiding (bar, baz)
15:14:33 <jethr0_> like "module ABC hiding lol where ..."
15:14:36 <TuringTest>   unsafeEval_ tocompile []                ["-package-conf","/Users/chrisk/Documents/projects/haskell/hs-plugins/hs-plugins-0.9.10/plugins.conf.inplace",
15:14:36 <TuringTest>                   "-O2","-fglasgow-exts","-package","altdata","-fexcess-precision","-optc-ffast-math"] 
15:14:38 <jethr0_> Igloo: no, i mean when exporting
15:14:44 * TuringTest oops
15:14:58 <Igloo> Ah. Don't think so.
15:15:38 <dons> TuringTest is up to some tricks. -ffast-math and runtime compilation, eh?
15:15:45 <TuringTest> :)
15:16:14 <TuringTest> dons: It works.  It is 1.7 times slower than simply compiling it in (which will INLINE it)
15:16:29 <TuringTest> (Not counting the overhead of the eval)
15:16:49 <TuringTest> Without hs-plugins it was 15x slower
15:16:54 <dons> ah, interesting. yeah, that sounds about right.
15:17:24 <dons> conal elliot found simillar things when going from GADT-style interpreted graphics plugins to compiled ones.
15:18:30 <TuringTest> Oddly , the http://haskell.org/hawiki/RunTimeCompilation page does not mention hs-plugins
15:18:49 <dons> oh.
15:18:51 <dons> hmm.
15:19:18 <dons> ah, but that's about the weird "runtime compilation" that isn't really.
15:19:49 <TuringTest> Yeah.  It was what I did with the symbolic functions: Run Time Function Composition
15:20:09 <TuringTest> (which was way too hard to make strict)
15:20:12 <dons>   let (!) a b = a `seq` b   eh?
15:20:36 * TuringTest nods at dons
15:22:31 <TuringTest> Not that I want to replace Mathematica.  But I liked being able to take symbol derivatives in Scheme.
15:22:59 <TuringTest> It made the physics of classical dynamics much easier to code.
15:25:28 <dons> why not replace mathematica, isn't it the epitome of evil?
15:26:13 <TuringTest> No, you are thinking of the head of the company
15:27:00 <dons> ah maybe. though whenever mathematica fragments are shown here the semantics seem bizarre
15:27:59 <TuringTest> dons: It is ... unusual.  It has a lisp-like syntax tree, but you rarely type it that way
15:28:12 <waern> dons, i'm trying to build yi with ghc 6.5.. boot/Static.hs fails because it can't find module Yi
15:28:52 <dons> hmm. waern, do you want the gtk yi or the curses yi?
15:29:09 <waern> the gtk yi I guess.. it's for hIDE
15:29:28 <dons> ah ok. what Cabal aree you using?
15:29:33 <waern> 1.0
15:30:00 <dons> ah, you need to update Cabal. try 1.1.3 or later.
15:30:15 <waern> ah, okay
15:30:23 <waern> i'll do that tommorow then.. time to sleep
15:30:59 <TuringTest> I tried to build ghc-6.4.2.20060129-src.tar.bz2 on OS X today and it failed partway through
15:31:37 <TuringTest> It was processing   System/Console/Readline.hsc  and failed
15:32:02 <dons> maybe readline isn't found?
15:32:13 <dons> (it's a typical problem when building ghc on the mac)
15:32:47 <TuringTest> sigh
15:33:29 <TuringTest> I thought it would help with hs-plugins, which I got working while it was off building.   So I can be patient again.
15:39:50 <ihope> This is WAY too late a reply, but I hate $.
15:40:01 <shapr> I like them in my wallet.
15:40:12 <ihope> :-)
15:40:27 <ihope> Well, I suppose they're okay then.
15:40:28 <dons> I also like $$
15:40:34 <ihope> I like $$$...
15:40:39 <ihope> > repeat '$'
15:40:40 <lambdabot> "$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
15:40:40 <lambdabot> $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
15:40:40 <lambdabot> $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
15:40:40 <lambdabot> $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
15:40:40 <lambdabot> $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
15:40:42 <lambdabot> [23 @more lines]
15:42:13 <ihope> > 80*24
15:42:14 <lambdabot> 1920
15:43:14 <ihope> (putStr . cycle) (replicate 1920 '$' ++ replicate 24 '\n')
15:44:38 <dons> > 75 * 28
15:44:39 <lambdabot> 2100
15:45:08 <dons> > 75 * 28 - 52
15:45:09 <lambdabot> 2048
15:45:12 <dons> ;)
15:45:53 <ihope> > 1 + 8
15:45:54 <lambdabot> 9
15:45:57 <ihope> > 5 + 1
15:45:59 <lambdabot> 6
15:46:05 <ihope> > 1 + 8 * 5 + 1
15:46:06 <lambdabot> 42
15:49:11 <ihope> @pl \[a,b,c,d,e,f,g,h,i] -> [f,g,h,i,a,b,c,d,e]
15:49:11 <lambdabot> (line 1, column 2):
15:49:11 <lambdabot> unexpected "["
15:49:11 <lambdabot> expecting pattern
15:49:27 <TuringTest> I noticed that GHC.Float has an interesting array
15:49:31 <ihope> @pl \(a:b:c:d:e:f:g:h:i:[]) -> [f,g,h,i,a,b,c,d,e]
15:49:31 <lambdabot> (line 1, column 21):
15:49:31 <lambdabot> unexpected "["
15:49:31 <lambdabot> expecting natural, identifier, "_" or "("
15:49:37 <TuringTest> expts :: GHC.Arr.Array Int Integer      -- Imported from GHC.Float
15:49:52 <ihope> ...Um?
15:50:07 <ihope> @pl \(a:b:c:d:e:f:g:h:i:null) -> [f,g,h,i,a,b,c,d,e] ++ null
15:50:18 <dons> ? haven't seen that before
15:50:22 <lambdabot> ap (flip ap tail . (. head) . flip (flip . (ap .) . flip (flip . ((.) .) .
15:50:22 <lambdabot> flip (flip . (flip .) . ((ap .) .) . flip (flip . (flip .) . (((.) .) .) .
15:50:22 <lambdabot> flip (flip . (flip .) . ((flip .) .) . (((ap .) .) .) . flip (flip . (
15:50:22 <lambdabot> flip .) . ((flip .) .) . ((((.) .) .) .) . flip (flip . (flip .) . ((flip
15:50:22 <lambdabot> .) .) . (((flip .) .) .) . ((((ap .) .) .) .) . flip (flip . (flip .) . ((
15:50:24 <lambdabot> [18 @more lines]
15:50:26 <lambdabot> optimization suspended, use @pl-resume to continue.
15:50:26 <ihope> Oops...
15:50:31 <TuringTest> expts ! n == 2 ^ n  for n in (0,1100)
15:50:50 <dons> ah, a cache
15:51:26 <dons> expt base n =
15:51:26 <dons>     if base == 2 && n >= minExpt && n <= maxExpt then
15:51:26 <dons>         expts!n
15:51:26 <dons>     else
15:51:27 <dons>         base^n
15:51:51 <ihope> Let's see here...
15:52:06 <ihope> aah func 0 y = func y
15:52:26 <ihope> aah func x y = compose y (aah func (x-1)) y
15:52:59 <ihope> s/compose/churchify/, if you feel like it
15:53:33 <TuringTest> Of course 2^425 particles are enough to fill the entire universe.
15:54:02 <TuringTest> So 2^1100 is big enough for everything short of cryptography
15:54:33 <ihope> 2^1100 isn't big enough for whatever problem.
15:54:46 <ihope> The one that Graham's number placed an upper bound on.
15:55:59 <vincenz> > 3 div 2
15:56:00 <lambdabot>  add an instance declaration for (Num ((a -> a -> a) -> t -> a1))
15:56:00 <lambdabot>   In the definition of `spl': spl = 3 div 2
15:56:00 <lambdabot>   In the definition of `v': v = let spl = 3 div 2 in take 2048 (show spl)
15:56:01 <vincenz> > 3 `div` 2
15:56:02 <lambdabot> 1
15:56:04 <vincenz> > 4 `div` 2
15:56:05 <lambdabot> 2
15:57:51 <ihope> Anyway, in my above function "aah", is there a function func such that x does not affect the speed of growth of aah func x, other than the constant function?
16:02:30 <ihope> @type let compose 0 f p = p; compose n f p = compose (n-1) f (f p); aah f 0 y = f y; aah f x y = compose (aah func (x-1)) y in aah
16:02:30 <lambdabot> Not in scope: `func'
16:02:36 <ihope> @type let compose 0 f p = p; compose n f p = compose (n-1) f (f p); aah f 0 y = f y; aah f x y = compose (aah f (x-1)) y in aah
16:02:37 <lambdabot> forall t a.
16:02:37 <lambdabot> (Num ((t -> t) -> t -> t), Num a) =>
16:02:37 <lambdabot> ((t -> t) -> t -> t) -> a -> (t -> t) -> t -> t
16:02:55 <ihope> Huh?
16:03:06 <ihope> @type let compose 0 f p = p; compose n f p = compose (n-1) f (f p); aah f 0 y = f y; aah f x y = compose y (aah f (x-1)) in aah
16:03:07 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
16:03:07 <lambdabot>   Expected type: a -> a
16:03:28 <ihope> @type let compose 0 f p = p; compose n f p = compose (n-1) f (f p); aah f 0 y = f y; aah f x y = compose y (aah f (x-1)) y in aah
16:03:29 <lambdabot> forall a a1. (Num a, Num a1) => (a -> a) -> a1 -> a -> a
16:03:37 <ihope> 'Ere we go.
16:13:31 <vincenz> is there an easy way to remove a data constructo from an element
16:13:33 <vincenz> something like
16:13:35 <vincenz> A a -> a
16:13:48 <vincenz> but in a generica way
16:14:08 <vincenz> @hoogle toList
16:14:08 <lambdabot> Data.HashTable.toList :: HashTable key val -> IO [(key, val)]
16:14:08 <lambdabot> Data.IntMap.toList :: IntMap a -> [(Key, a)]
16:14:08 <lambdabot> Data.IntSet.toList :: IntSet -> [Int]
16:14:09 <edwinb> no, since it might have multiple constructors
16:14:14 <vincenz> darn
16:14:36 <dons> you could write a typeclass..
16:14:51 <edwinb> I have known people write typeclasses to do it...
16:15:00 <edwinb> un (A x) = x
16:15:03 <edwinb> nu x = A x
16:15:42 <dons> but it is a weird question. why would you need to do this?
16:15:56 <dons> maybe there's a way with Data.Generics, i can think of at least one way
16:16:09 <dons> fromConstr :: Data a => Constr -> a maybe?
16:16:43 <vincenz> dons: Constr is not a type is it?
16:16:52 <dons> but that's crazy stuff anyway. 
16:17:08 <vincenz> should prolly go into the standard
16:17:11 <vincenz> make a typeclass
16:17:16 <vincenz> and all types with single data constructor...
16:17:36 <edwinb> It does seem to break some of the point of newtype to me.
16:19:11 <dons> vincenz, you haven't motivated why you want this? maybe there's a more haskellish way to do what you want.
16:20:37 <dons> hehe  http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=erlang&lang2=ghc
16:21:56 <sethk> hey, all.  I'm using a function in System.Posix.Files, and it is giving me an error.  Presumably it is throwing an exception.  Where do I look to determine what exception is being thrown?  More generally all the doc I've found on this is the haddoc generated stuff, which is basically useless, just tells you the function names and types.  Where do I get more info?
16:22:24 <dons> can you catch the exception and show it?/
16:22:37 <vincenz> dons: to remove stupid stuff like
16:22:38 <vincenz>             othersInfo    = concat $ map (\(InformMessage l) -> l) notMyInfo
16:22:44 <dons> catch fn (\e -> show e >> return ())
16:22:47 <sethk> dons, possibly.  I don't know what exception to catch, although I presume it is an IO exception
16:23:14 <dons> @fptools System.Posix.Files
16:23:14 <lambdabot> http://darcs.complete.org/fptools/libraries/unix/System/Posix/Files.
16:23:14 <lambdabot> hs
16:23:15 <vincenz> InformMessage  = [Inform]   I have a [InformMessage] and want [Inform] by concattenating all the underlying Inform's
16:23:17 <sethk> dons, but I already know what's happening, it is telling me a file doesn't exist.  It exists, but it is a symbolic link.  I've found several library errors related to symbolic links
16:23:20 <dons> read the src :)
16:23:31 <sethk> dons, right, only I don't find the source.
16:23:51 <dons> the above link?
16:24:04 <sethk> dons, didn't see it.  let me look.
16:24:18 <dons> http://darcs.complete.org/fptools/libraries/unix/System/Posix/Files.hs
16:24:20 <dons> hmm.
16:24:24 <sethk> dons, The requested URL /fptools/libraries/unix/System/Posix/Files was not found on this server
16:24:34 <dons> ah, maybe they've moved things around. let me see..
16:24:44 <ihope> vincenz: define a function to remove that constructor specifically?
16:24:56 <vincenz> can you use questionmarks in function names
16:24:58 <vincenz> like past?
16:25:03 <dons> http://darcs.complete.org/fptools/libraries/unix/System/Posix/Files.hsc
16:25:03 <ihope> > foo?bar
16:25:04 <lambdabot>  Not in scope: `bar'
16:25:06 <ihope> Nope.
16:25:10 <vincenz> > foo>
16:25:11 <lambdabot>  parse error on input `}'
16:25:12 <vincenz> > foo?
16:25:12 <lambdabot>  parse error on input `}'
16:25:17 <vincenz> darn
16:25:18 <dons> vinzenz. no.
16:25:28 <dons> you can't mix syms and varids
16:25:48 <vincenz> be nice if there was a small subset like !?= that would allow this
16:26:08 <ihope> > foo'bar
16:26:08 <lambdabot>  Not in scope: `foo'bar'
16:26:13 <ihope> There's one.
16:26:21 <vincenz> heh
16:26:27 <vincenz> well ? and ! would be nice too
16:26:36 <ihope> > foo!bar
16:26:37 <lambdabot>  Not in scope: `bar'
16:26:41 <ihope> Yep.
16:26:53 <vincenz> [a-z_A-Z']*[?!]
16:26:56 <Igloo> Ooo, oo, can we argue about whether or not ' is a letter now?  :-)
16:26:59 <vincenz> [a-z_A-Z']+[?!]
16:27:06 <vincenz> well you get the idea
16:27:13 <vincenz> unlike '...only allow as terminal
16:27:44 <dons> Igloo, i say yes!
16:27:52 <dons> hehehe
16:28:03 <ihope> isLetter '\NUL' = False; isLetter '\SOH' = False; isLetter '\STX' = False...
16:28:21 <ihope> ..isLetter '\'' = error "We haven't decided yet"...
16:28:22 <lambdabot> No! you're crazy. ' is clearly a symbol
16:28:41 <ihope> Hmm...
16:28:44 <dons> @vixen what do you think? is ' a letter?
16:28:45 <lambdabot> i dunno...
16:28:47 <Igloo> dons: Damn, I wanted yes, but someone has to take no...  :-(
16:28:54 <vincenz> > isLetter '\''
16:28:55 <lambdabot> False
16:28:58 * ihope does the same ritual as he did with EgoBot
16:29:07 <ihope> ...Whoa!
16:29:08 <vincenz> EgoBot?
16:29:20 <vincenz> > isLetter '0'
16:29:21 <lambdabot> False
16:29:22 <ihope> The bot over at #esoteric.
16:29:28 <vincenz> ;0
16:29:30 <ihope> > isNumber 'f'
16:29:31 <lambdabot> False
16:29:38 <ihope> > isHex 'f'
16:29:39 <lambdabot>  Not in scope: `isHex'
16:30:06 <ihope> @hoogle Char -> Bool
16:30:07 <lambdabot> Data.Char.isAscii :: Char -> Bool
16:30:07 <lambdabot> Data.Char.isLatin1 :: Char -> Bool
16:30:07 <lambdabot> Data.Char.isControl :: Char -> Bool
16:30:20 <ihope> ...Is that it?
16:32:35 <ihope> > n0p
16:32:36 <lambdabot>  Not in scope: `n0p'
16:32:45 <ihope> > p=3
16:32:45 <lambdabot>  parse error on input `='
16:32:55 <sethk> dons, help me with this syntax.  I have    fstat <- getFileStatus fname1        which is where the error is occuring.  I know in this context that the file not found error cannot be correct.  I can't figure out what kind of syntax to use to catch this within the context of my function.  I can't use    catch (fstat <- getFileStatus fname1)         or can I?
16:33:08 <astrolabe> @hoogle isHexDigit
16:33:09 <lambdabot> Data.Char.isHexDigit :: Char -> Bool
16:33:09 <lambdabot> GHC.Unicode.isHexDigit :: Char -> Bool
16:33:42 <sethk> dons, in this particular case what I would like to do is call getSymbolicLinkStatus when getFileStatus errors out
16:33:57 <sethk> dons, before you suggest it, the function that labels it a link (rather than a file) doesn't work either
16:34:37 <sethk> dons, I guess I can make my own function to wrap getFileStatus
16:35:19 <sethk> dons, but I'm not clear enough about how exceptions work to come up with what I need that way either
16:42:41 <Lokadin> hey guys
16:42:54 <Lokadin> you are all soo wonderful!! :D i love you all
16:42:55 <Lokadin> lol
16:43:05 <Lokadin> \clear
16:43:08 <Lokadin> oops
16:43:13 <Lokadin> there
16:43:15 <Lokadin> hmmm
16:43:18 <Lokadin> oh well
16:43:40 * araujo already knows he is wonderful :-)
16:43:52 <araujo> @yaw!
16:43:53 <lambdabot> What I need is a MATURE RELATIONSHIP with a FLOPPY DISK ...
16:44:00 <araujo> hahah
16:44:03 <Beelsebob> rofl
16:44:18 <araujo> lambdabot, do you love me?
16:44:29 <araujo> lambdabot, no?
16:44:31 <ihope> > (error.error)"no"
16:44:31 <lambdabot> Add a type signature
16:44:35 <ihope> > (error.error)"no"::Int
16:44:36 <lambdabot> no
16:44:52 <dons> sethk, fstat <- Control.Exceptions.catch (getFileStatus fname1) (\e -> error . show $ e)
16:45:21 <sethk> dons, ok.  I did something somewhat similar which, actually, appears to be working...
16:45:50 <sethk> dons, I did    catch (getFileStatus fname) (\e -> getSymbolicLinkStatus fname)
16:46:01 <sethk> dons,  as a separate function to replace getFileStatus
16:46:08 <dons> ok. good.
16:46:29 <sethk> dons, thanks, though, I was seriously confused about how to put a catch in a x <- ......   statement
16:46:57 <vincenz> @type \x y -> x `div` y
16:46:58 <lambdabot> forall a. (Integral a) => a -> a -> a
16:47:06 <vincenz> Integer doesn't allow `div`?
16:47:32 <ihope> @index if'
16:47:32 <vincenz> @type \x y -> x - y
16:47:33 <lambdabot> bzzt
16:47:33 <lambdabot> forall a. (Num a) => a -> a -> a
16:47:42 <ihope> Urmp.
16:47:56 <ihope> @pl \x y z -> if x then y else z
16:47:56 <lambdabot> if'
16:48:13 <ihope> @hoogle if'
16:48:14 <lambdabot> Prelude.undefined :: a
16:48:14 <lambdabot> Data.Graph.Inductive.Monad.emptyM :: GraphM m gr => m (gr a b)
16:48:14 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
16:48:35 <vincenz> @type \w y -> (w - y) `div` 2
16:48:35 <ihope> So, uh.
16:48:36 <lambdabot> forall a. (Integral a) => a -> a -> a
16:48:54 <vincenz> @type \w y b-> if b then (w - y) `div` 2 else 0
16:48:55 <lambdabot> forall a. (Integral a) => a -> a -> Bool -> a
16:49:59 <ihope> Ugh, this code's too obfuscated for its own good.
16:50:00 <ihope> Control.Monad.Fix.fix(Control.Monad.liftM2 Control.Monad.ap((Control.Monad.ap.flip(\x y z -> if x then y else z.(0==))).).flip flip id.((flip.((Control.Monad.ap.flip(Control.Monad.Fix.fix((Control.Monad.ap(Control.Monad.ap.(\x y z -> if x then y else z).(0==)).).flip flip id.(Control.Monad.liftM2(.).).(.subtract 1)))).)).).flip flip(subtract 1).((.).))
16:50:13 <vincenz> @type (!!)
16:50:14 <lambdabot> forall a. [a] -> Int -> a
16:50:21 <vincenz> why is this Int and not Integer??
16:50:30 <ihope> Dunno.
16:50:32 <vincenz> or Integral at that
16:50:35 <vincenz> it's really annoying
16:50:36 <Igloo> No good reason
16:50:36 <ihope> @type fromIntegral
16:50:37 <lambdabot> forall b a. (Num b, Integral a) => a -> b
16:50:56 <ihope> @pl \x y -> x !! fromIntegral y
16:50:57 <lambdabot> (. fromIntegral) . (!!)
16:50:58 <vincenz> they should change that
16:51:13 <lennart> It's an Int because of bad afficiency reasons made very early in Haskell's history.
16:51:23 <lennart> efficiency, even
16:51:25 <vincenz> (!!) :: forall a b. (Integral b) => [a] -> b -> a
16:51:29 <Igloo> @type Data.List.genericIndex
16:51:30 <lambdabot> forall b a. (Integral a) => [b] -> a -> b
16:51:37 <vincenz> Igloo: they ever plan on changing it?
16:51:43 <vincenz> but thankx for  all the input
16:51:59 <Igloo> You can try arguing for it for Haskell'
16:52:08 <vincenz> I mean
16:52:11 <vincenz> if it's efficiency
16:52:15 <vincenz> just add a fromIntegral
16:52:18 <lennart> I think it's a good candidate for change.  Going to Integral
16:52:23 <vincenz> perfect
16:53:31 <ihope> AAAAAAAHHH!
16:53:34 <Igloo> Part of me tends to agree, but another part doesn't want to have to write type signatures for things like   xs !! length ys   to avoid defaulting warnings
16:53:35 <ihope> @type flip flip id . (ap .) . liftM2 (.) flip ((. subtract 1) . join id)
16:53:36 <lambdabot> Not in scope: `ap'
16:53:36 <lambdabot>  
16:53:36 <lambdabot> <interactive>:1:24: Not in scope: `liftM2'
16:53:45 <ihope> > flip flip id . (ap .) . liftM2 (.) flip ((. subtract 1) . join id)
16:53:46 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a1 ->
16:53:46 <lambdabot> c
16:53:46 <lambdabot>   Expected type: a -> a -> a1 -> c
16:53:46 <lambdabot>   Inferred type: a -> a
16:53:50 <Igloo> I don't actually know how often that would be a problem in practice, though
16:53:50 <ihope> Whew.
16:53:52 <dons> vincenz, it's _really_ annoying, or marginally annoying?
16:54:00 <dons> or not actually annoying at all?
16:54:46 <vincenz> dons: well it's an uncleaniness
16:54:47 <ihope> Can't be right.
16:54:49 <vincenz> ime
16:54:51 <vincenz> but yeah, just marginally
16:54:57 <ihope> It looks like @pl is brokeded.
16:56:15 <ihope> I give it @pl let compose num 0 param = param; compose num func param = compose (num-1) func (func param); yow func 0 y = func y; yow func x y = compose y (yow func (x-1)) y in yow
16:56:18 <Igloo> dons: It can be really annoying if you want to do lots of things with Word32, say, and suddenly all of your function names are twice as long
16:56:30 <ihope> It tosses back flip flip id . (ap .) . liftM2 (.) flip ((. subtract 1) . join id)
16:56:33 <Igloo> Maybe we need Data.List and Data.List.Generic exporting the same functions with different types
16:56:45 <ihope> Input typechecks, output doesn't.
16:57:58 <vincenz> @hoogle unions
16:57:59 <lambdabot> Data.IntMap.unions :: [IntMap a] -> IntMap a
16:57:59 <lambdabot> Data.IntSet.unions :: [IntSet] -> IntSet
16:57:59 <lambdabot> Data.Map.unions :: Ord k => [Map k a] -> Map k a
16:58:11 <vincenz> hoogle is flawed
16:58:15 <dons> Igloo, ah good point.
16:58:54 <dons> yeah, Wordn in general can be a bit awkward.
16:59:19 <palomer> hoogle is a great idea
16:59:43 <Igloo> Same for Integer, of course
17:02:42 <palomer> hrmphrm
17:07:39 <palomer> I _so_ want to work on this, but I can't
17:08:08 <palomer> btw, can I distribute ghc binaries?
17:09:12 <Igloo> yes
17:09:13 <dons> yep.
17:21:44 <SyntaxNinja> Philippa_: can you help me corral this monomorphism restriction thread?  it is getting a bit long :)
17:25:09 <Spark> heh i'm reviewing this paper that mentions "monotonic mealy machines" so i put that into google and the only thing that comes up is the paper i'm reviewing
17:25:16 <Philippa_> SyntaxNinja: by means other than stopping posting?
17:25:42 <Philippa_> I do think there's further room for discussion re the warnings idea at least
17:25:47 <heatsink> Spark: it'd be fun to googlewhack a paper
17:25:48 <SamB> try "mealy machines"?
17:26:00 <Spark> yeah i know what a mealy machine is
17:26:02 <vincenz> anyone have experience with guis?
17:26:04 <SamB> @google "mealy machines"
17:26:05 <lambdabot> http://www.olemiss.edu/courses/EE/ELE_335/Spring2000/Htmlnotes/MealyMooreST
17:26:05 <lambdabot> TSTD/
17:26:57 <Spark> i just find it amusing that his is the only thing that mentions monotonic ones (he has a definition so thats ok)
17:27:13 <vincenz> how hard is it to draw something on a gui with haskell?
17:27:57 * heatsink keeps seeing "moronic mealy machines"
17:28:06 <SamB> vincenz: reportedly cairo is easy-to-use
17:28:06 <vincenz> any demos around
17:28:25 <ndm> vincenz, loads!
17:28:29 <ndm> @google gtk2hs blog
17:28:31 <lambdabot> http://haskell.org/gtk2hs/archives/2005/04/29/building-on-machines-with-
17:28:31 <lambdabot> less-ram/
17:28:42 <ndm> @where gtk2hs
17:28:42 <SamB> however I apparantly need a newer GDK in order for it to work with Cairo, or something like that
17:28:43 <lambdabot> http://haskell.org/gtk2hs/
17:29:05 <ndm> you generally need Gtk2Hs from head, they keep changing it :)
17:29:26 <SamB> ndm: who, me or vincenz ?
17:29:48 <SamB> in any case, it is the C headers and .so that are too old...
17:30:01 <ndm> SamB, you
17:30:08 <ndm> but generally, they keep breaking Gtk2Hs
17:30:08 <ihope> IDEA! Never mind.
17:37:25 <ihope> IDEA!
17:37:40 <SyntaxNinja> oh no
17:40:27 <ihope> I found a function that grows "eek! fast".
17:40:40 <ihope> Of course, it's easy to make such things.
17:40:53 <heatsink> as long as you're not putting it in a virus
17:41:30 <ihope> It's simple enough.
17:41:57 <heatsink> what I meant was, I hope you're not putting it in a virus.
17:42:08 <ihope> Digging up the "aah" function above, it's aah (product . enumFromTo 1)
17:42:27 <ihope> eek 0 x = product [1..x]
17:43:01 <ihope> eek n x = church x (eek (n-1)) x
17:44:31 <ihope> For values such as 3 and 3, the factorial of 3 is calculated Many Times.
17:47:23 <vincenz> what's stroke for?
17:48:02 <vincenz> pity GTk /Cairo is not part of GHC
17:50:28 <palomer> it probably will be
17:50:32 <palomer> it's quite usable
17:50:37 <palomer> easier to use than the C version, even
17:51:05 <SyntaxNinja> is cairo cabal-ized?
17:51:15 <JKnecht> any F# users here?
17:51:16 <SyntaxNinja> someone should upload it to hackageDB so ppl can cabal-get install it :)
17:52:04 <ihope> Hmm. 0^0 = join [0,1]
17:52:15 <palomer> > 0 ^ 0
17:52:16 <lambdabot> 1
17:52:22 <palomer> > 0 ^ -1
17:52:23 <lambdabot>   precedence parsing error
17:52:23 <lambdabot>    cannot mix `(^)' [infixr 8] and prefix `-' [infixl 6] in the same
17:52:23 <lambdabot> infix expression
17:52:26 <palomer> > 0 ^ (-1)
17:52:27 <lambdabot> Exception: Prelude.^: negative exponent
17:52:31 <ihope> :-P
17:52:32 <palomer> btw, how does - work?
17:52:33 <dons> musasabi, ooh nice. we beat Clean (and =~ optimised C) in partial-sums. I have a faster version on the wiki, can you commit it?
17:52:42 <ihope> palomer: who knows?
17:52:43 <dons> http://shootout.alioth.debian.org/gp4/benchmark.php?test=partialsums&lang=all
17:52:54 <ihope> @pl \x -> -x
17:52:54 <lambdabot> (line 1, column 7):
17:52:54 <lambdabot> unexpected "-"
17:52:54 <lambdabot> expecting lambda abstraction or expression
17:52:58 <ihope> @pl \x -> (-x)
17:52:59 <lambdabot> subtract
17:53:27 <heatsink> negate
17:53:27 <ihope> > (-1) 3
17:53:28 <lambdabot>  add an instance declaration for (Num (t -> a))
17:53:28 <lambdabot>   In the definition of `urm': urm = (- 1) 3
17:53:28 <lambdabot>   In the definition of `v': v = let urm = (- 1) 3 in take 2048 (show urm)
17:56:07 <dons> TuringTest, see this: http://shootout.alioth.debian.org/gp4/benchmark.php?test=partialsums&lang=all
17:56:20 <ihope> eek 3 3 = eek 2 (eek 2 (eek 1 (eek 1 (eek 0 720))))
17:58:30 <dons> musasabi, hmm, but mandelbrot and nbody still didn't get rerun with -fexcess-precision. weird.
18:00:37 <vincenz> How do I set the pen to pixel size 1?
18:21:29 <araujo> There exist some function in the prelude to repeat  N times an expression.
18:23:10 <AtnNn> take N . repeat expression ?
18:23:26 <vincenz> AtnNn: you mean
18:23:42 <vincenz> iterate expression d !! N
18:23:54 <Cale> replicate n x?
18:24:08 <Cale> > replicate 5 1
18:24:09 <lambdabot> [1,1,1,1,1]
18:24:20 <Cale> > iterate 5 (+1) 0
18:24:21 <lambdabot>   The function `iterate' is applied to three arguments,
18:24:21 <lambdabot>   but its type `(a -> a) -> a -> [a]' has only two
18:24:21 <lambdabot>   In the definition of `sbl': sbl = iterate 5 ((+ 1)) 0
18:24:31 <Cale> > iterate (+1) 0 !! 5
18:24:32 <lambdabot> 5
18:25:15 <Cale> take 5 $ iterate (+1) 0
18:25:20 <Cale> > take 5 $ iterate (+1) 0
18:25:21 <lambdabot> [0,1,2,3,4]
18:26:02 <tnks> Hi.
18:26:07 <AtnNn> hello
18:26:08 <Cale> hi
18:26:09 <vincenz> why is it that when you draw with cairo...the lines are either thicky or fuzzy
18:26:19 <Cale> vincenz: hm?
18:26:33 <tnks> I have a quick question.  I looked at the Curry website, and I had a hard time finding out what the real difference was between it and Haskell.
18:26:33 <vincenz> Cale: well some lines were too thick so
18:26:36 <vincenz> setLineWidth 0.1
18:26:39 <vincenz> now they're about the same thickkness
18:26:40 <vincenz> just lighter
18:26:45 <vincenz> like gray
18:26:47 <Cale> that's 1/10 of a pixel
18:27:03 <Cale> so it's "supersampling"
18:27:03 <vincenz> yeah
18:27:18 <vincenz> so how would I get nice thin liines?
18:27:26 <Cale> setLineWidth 1
18:27:31 <Cale> if your scale is 1:1
18:27:32 <vincenz> some turn out to be too thick
18:27:37 <SamB> hmm
18:27:45 <Cale> screenshot?
18:27:47 <vincenz> especially slanted ones
18:27:59 <Cale> Like, they're anti-aliased
18:28:00 <SamB> I seem to have somehow gotten mozilla stuck halfway in print-preview mode
18:28:01 <vincenz> @type round
18:28:02 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
18:28:03 <vincenz> Cale: yeah
18:28:10 <Cale> how many colours is your display?
18:28:55 <Cale> They might just look thick if you were on some video mode with few colours.
18:28:57 <vincenz> Cale: many?
18:29:08 <vincenz> damn
18:29:12 <vincenz> I even rounded the start and end coordinates
18:29:18 <Cale> as in, what is the depth?
18:29:22 <vincenz> and vertical/horizontal lines still look like 2 lines thick
18:29:24 <vincenz> Cale: highest?
18:29:29 <Cale> okay
18:29:40 <Cale> can I get a screenshot?
18:29:46 <vincenz> how to on linux?
18:30:03 <Cale> what desktop? there are lots of apps for it
18:30:06 <vincenz> gnome
18:30:09 <vincenz> hmm
18:30:10 <vincenz> wait..
18:30:14 <vincenz> can't I ihave cairo render to png?
18:30:22 <Cale> you can add a screenshot frob to your panel
18:30:30 <Cale> yeah, you can
18:30:56 <vincenz> how do I do that
18:31:28 <Cale> right click an empty space on the panel -> Add To Panel... -> Take Screenshot -> Add
18:31:36 <orbitz> vincenz: oink oink moo moo
18:31:47 <vincenz> Cale: I meant to png ;)
18:32:10 <Cale> surfaceWriteToPNG
18:32:15 <vincenz> it requires a Surface
18:32:17 <vincenz> no idea on how to get that
18:32:44 <vincenz> ah got it
18:33:24 <vincenz> nope
18:33:59 <Cale> I think you use withTargetSurface
18:40:36 <lennart> hmmm, how do you access the ffi addendum from the Haskell web site these day?
18:41:01 <Cale> heh, oops :)
18:41:06 <lennart> when i click on the link it says I have to log in to edit it
18:41:14 <Cale> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
18:41:18 <lennart> i don't want to edit it!
18:41:20 <lennart> :)
18:42:58 <Cale> fixed
18:43:19 <lennart> speedy!
18:44:12 <Cale> well, anyone can edit it :)
18:47:46 <lennart> anyone who has logged in
18:47:51 <Cale> yeah
18:50:50 <vincenz> Cale: at last!
18:52:03 <vincenz> heh
18:52:04 <vincenz> fully blakck
18:52:30 <vincenz> Cale: I tried writing to png
18:52:31 <vincenz> and well...
18:52:34 <vincenz> it turns out a black png
18:56:43 <Cale> vincenz: hmm, odd
18:57:05 <Cale> are you making sure to initialise the surface with a white rectangle or some background?
18:57:53 <vincenz> Cale: no
18:57:56 <vincenz> Cale: how?
18:58:18 <Cale> say, with a rectangle
18:58:24 <Cale> and fill
19:00:53 <vincenz> now it's all white
19:01:02 <vincenz>                                                     setSourceRGBA 1 1 1 1
19:01:02 <vincenz>                                                     rectangle 0 0 550 550
19:01:02 <vincenz>                                                     fill
19:01:02 <vincenz>                                                     setSourceRGBA 1 0 1 1
19:01:02 <vincenz>                                                     setOperator OperatorAdd
19:01:04 <vincenz>                                                     (drawMap skel)
19:01:11 <vincenz> whoops
19:01:17 <vincenz> setSourceRGBA 1 1 1 1
19:01:17 <vincenz> rectangle 0 0 550 550
19:01:17 <vincenz> fill
19:01:17 <vincenz> setSourceRGBA 1 0 1 1
19:01:20 <vincenz> setOperator OperatorAdd
19:01:23 <vincenz> (drawMap skel)
19:01:36 <Cale> OperatorAdd?
19:01:37 <vincenz> aha!
19:01:44 <vincenz> at last!
19:02:52 <vincenz> http://img228.imageshack.us/my.php?image=test7sy.png
19:04:54 <Cale> okay
19:05:34 <Cale> setAntialias AntialiasNone ?
19:05:47 <Cale> that'll kill the antialiasing, if that's what you don't like
19:06:46 <vincenz> ah much better, thanks
19:07:03 <vincenz> alright now a harder question (more mathematical)
19:07:33 <vincenz> give startx, starty, endx, endy
19:07:45 <vincenz> draw a line from (starx,starty) to (endx,endy)
19:07:54 <vincenz> 2 pixels parallel to the line straight from those points
19:11:51 <Cale> (scale * (ys - ye), scale * (xe - xs)) where scale = 2 / (sqrt ((ys - ye)^2 + (xe - xs)^2))
19:12:10 <Cale> is the displacement vector
19:12:26 <vincenz> o.O
19:12:35 <Cale> basically, you're starting with the vector between your start and end points, which is:
19:12:51 <Cale> d = (xe - xs, ye - ys)
19:12:53 <vincenz> right
19:13:02 <Cale> take a vector perpendicular to that
19:13:12 <Cale> n = (ys - ye, xe - xs)
19:13:18 <vincenz> is it?
19:13:33 <Cale> (-y,x) is perpendicular to (x,y)
19:14:04 <Cale> then you want to travel two units of distance in the direction of n
19:14:16 <vincenz> yeah
19:14:20 <Cale> so normalise n and multiply by 2
19:14:20 <vincenz> the rest is just unitizinig
19:14:25 <vincenz> thx
19:15:34 <vincenz> I'll take (y,-x)
19:15:41 <Cale> yeah, that's the other one
19:16:14 <vincenz> I want the one to the "left"
19:18:23 <vincenz> Cale: why 2/sqrt
19:18:41 <Cale> that's just combining the two scaling factors
19:18:52 <Cale> you normalise, then multiply by 2
19:18:53 <vincenz> thot so
19:19:03 <vincenz> oh yeah... I did say 2 :P
19:24:49 <vincenz> @hoogle round
19:24:50 <lambdabot> Prelude.round :: (RealFrac a, Integral b) => a -> b
19:24:50 <lambdabot> Text.Html.background :: String -> HtmlAttr
19:26:09 <vincenz> @hoogle (&&&)
19:26:09 <lambdabot> No matches found
19:26:15 <vincenz> @type (&&&)
19:26:16 <lambdabot> Not in scope: `&&&'
19:26:22 <vincenz> @type Control.Arrow.(&&&)
19:26:23 <lambdabot> Couldn't find qualified module.
19:26:23 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
19:26:23 <lambdabot> \\)?
19:26:33 <vincenz> @type (Control.Arrow.&&&)
19:26:34 <lambdabot> forall (a :: * -> * -> *) c' c b.
19:26:34 <lambdabot> (Control.Arrow.Arrow a) =>
19:26:34 <lambdabot> a b c -> a b c' -> a b (c, c')
19:26:54 <vincenz> @hoogle (a -> b) -> (a,a) -> (b,b)
19:26:55 <lambdabot> Data.Graph.Inductive.Query.Monad.mapFst :: (a -> b) -> (a, c) -> (b, c)
19:26:55 <lambdabot> Data.Graph.Inductive.Query.Monad.mapSnd :: (a -> b) -> (c, a) -> (c, b)
19:43:03 <vincenz> Cale: mind if I bother you again?
19:45:41 <Cale> vincenz: I don't mind
19:46:06 <vincenz> well this time it's more involved
19:46:08 <vincenz> as you might have guess
19:46:14 <vincenz> I took the code from cairo site
19:46:22 <vincenz> that basically takes a Render() and slaps it onto a dialogbox
19:46:49 <Cale> yeah
19:47:01 <vincenz> what I would like to do is basically
19:47:08 <vincenz> have thiis dialog box be created at start
19:47:14 <vincenz> and then have my robot basically have
19:47:19 <vincenz> drawSomething :: IO()
19:47:29 <vincenz> such that it will darw that extra thing besides the main graph
19:47:43 <Cale> drawSomething :: Render () -> IO () ?
19:47:49 <vincenz> correct
19:48:08 <vincenz> a) most likely this means that the run thingy that shows the dialogbox will need to be in a separate thread
19:48:47 <vincenz> and an MVar to communicate the Render () to this thread, as well as tell it to refresh the drawing
19:48:49 <Cale> well, it shouldn't be too hard
19:49:01 <Cale> hmm, yeah
19:49:07 <vincenz> Cale: and most likely a return MVar
19:49:12 <vincenz> such that I can have a little OK button
19:49:21 <vincenz> and when I click it my bot continues
19:49:26 <Cale> You just modify the onExpose to read from an MVar which you pass back a closure over
19:49:34 <vincenz> Cale: right
19:50:01 <vincenz> wait "pass back a closure over" ?
19:50:05 <vincenz> syntax does not compute
19:50:08 <Cale> heh, sorry
19:50:17 <Cale> You return a function which updates the image
19:50:29 <vincenz> oh right
19:51:10 <vincenz> canvas `onExpose` updateCanvas canvas (act >> takeMvar Mvar)
19:51:18 <vincenz> where act is the basic graph
19:51:49 <Cale> join (takeMVar v)
19:51:55 <vincenz> ?
19:52:10 <vincenz> @type join
19:52:11 <lambdabot> Not in scope: `join'
19:52:18 <Cale> @type Control.Monad.join
19:52:19 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
19:52:28 <vincenz> oh
19:52:29 <vincenz> ok
19:54:03 <vincenz> Cale: do I need to launch a separate thread for the gui?
19:54:45 <jethr0> hi, i've got a debian system. and cairo supposedly needs gtk+ 2.8
19:54:50 <jethr0> anyone had this problem in here?
19:55:14 <Cale> My debian system has Gnome 2.10
19:55:28 <Cale> are you running stable?
19:57:04 <jethr0> Cale: i'm running testing/unstable
19:57:17 <ibid> jethr0: unstable has gtk 2.8
19:57:23 <ibid> don't know about testing
19:58:11 <vincenz> Cale: adding a forkIO basically doesn't show my gui
19:58:27 <jethr0> ibid: any idea how the package is called? i only find gtk+ 2.4 stuff
19:59:12 <ibid> jethr0: hrm, that's wayy old. even stable has gtk 2.6
19:59:21 <ibid> jethr0: when did you last upgrade?
19:59:25 <lambdabot> The 22nd issue of the Haskell Weekly News is out: http://sequence.
19:59:25 <lambdabot> complete.org/hwn
20:00:02 <ibid> jethr0: the package names haven't changed
20:00:54 <jethr0> ibid: apt-cache search libgtk --names-only | grep 2.8
20:01:19 <jethr0> ibid: i believe you that they're there. but i can't find them :)
20:01:28 <vincenz> @index finally
20:01:28 <lambdabot> Control.Exception, Distribution.Compat.Exception
20:01:29 <jethr0> ibid: above yielded no results.
20:02:38 <jethr0> ibid: sorry, it's just debians weird package naming scheme
20:02:41 <jethr0> i apologize
