00:11:02 <mempko> never mind :)
00:56:48 <musasabi> dons: nbody committed.
01:18:18 <dcoutts> vincenz, did you get your gtk2hs prog to work?
01:18:33 <xerox> Howdy dcoutts!
01:18:38 <dcoutts> hia xerox!
01:18:56 <xerox> dcoutts: what was the Right Way to combine networking and Gtk in an Haskell program?
01:19:04 <dcoutts> threads probably
01:19:11 <dcoutts> or this other nasty thing...
01:19:32 <xerox> Oh, right.  I'm reading the backlog.
01:19:42 <gour> hi, dcoutts
01:20:05 <dcoutts> xerox, someone really didn't want to use threads so we added inputAdd
01:20:14 <dcoutts> morning gour 
01:20:26 <gour> thank you for fixing tabs
01:20:28 <dcoutts> gour, does the size of the tabs seem ok now?
01:20:32 <dcoutts> oh good :-)
01:20:40 <dcoutts> I checked it on IE on win32
01:20:42 <gour> i'm busy these days - household duties :-)
01:21:40 <gour> dcoutts: anything important in new gtk+ *
01:22:10 <dcoutts> gour, you mean the next version og Gtk+ like what's going to be in 2.10 ?
01:22:40 * dcoutts has access to win32 via X to a linux box in the department which runs rdesktop to a win32 server
01:23:06 * dcoutts hopes that's enough indirections to keep him clean
01:24:03 <gour> dcoutts: i think abour gtk-2.8.11 ?
01:24:42 <dcoutts> gour, new features don't get added in point releases, only bug fixes
01:24:46 * gour does did not play with rdesktop (yet)
01:25:30 <gour> dcoutts: what's going on with hIDE?  i see Lemmih quite active
01:26:11 <xerox> Let's see if I can build gtk2hs today...
01:27:06 <dcoutts> gour, Lemmih has been improving the interactive type checking to use information from the cabal file
01:27:34 <dcoutts> xerox, do you run X11 with XComposite turned on?
01:27:51 <xerox> cairo/Graphics/Rendering/Cairo/Types.hs:24:3: Parse error
01:27:51 <xerox> make[1]: *** [docs/reference/System-Glib-FFI.html] Error 1
01:27:57 <xerox> dcoutts: I think not.
01:28:23 <gour> dcoutts: and for the gnome-2.14, what will gtk bring up?
01:28:25 <dcoutts> xerox, oh, odd
01:28:40 <xerox> :-\
01:28:52 <dcoutts> xerox, ./configure --disable-docs
01:28:59 <xerox> Oh-ho!
01:29:24 <dcoutts> gour, gnome 2.14 will be out before gtk+ 2.10
01:30:34 <xerox> make[1]: Leaving directory `/home/paolo/haskell/archive/gtk2hs'
01:30:39 <xerox> Eek Eek Eek!
01:30:51 * xerox built successfully, finally.
01:31:50 <dcoutts> xerox, which haddock version have you got?
01:32:01 * gour reads abour gtk 2.10 plan
01:33:17 <xerox> 0.6-2ubuntu1
01:33:24 <xerox> err..
01:33:25 <xerox> Haddock version 0.7, (c) Simon Marlow 2003
01:34:12 <gour> dcoutts: do you believe 3.0 will follow 2.10, or some 2.x in between?
01:35:06 <dcoutts> xerox, which? 0.6 or 0.7
01:35:11 <xerox> 0.7
01:35:17 <dcoutts> gour, 2.12 I reckon
01:35:24 <xerox> ..at least that's what haddock says.
01:35:26 <dcoutts> xerox, ok, odd
01:36:05 * dcoutts checks with haddock 0.7
01:36:10 <gour> dcoutts: so, 3.0 is far away
01:36:19 * dcoutts has been using his patched 0.8
01:36:43 <dcoutts> gour, if 3.0 means an abi/api change then yes it probably is far away
01:36:50 <nibro> @seen dons
01:36:51 <lambdabot> dons is in #haskell-blah and #haskell. Last spoke 4 hours, 13 minutes and
01:36:51 <lambdabot> 11 seconds ago.
01:39:18 <gour> dcoutts: well, it looks so, i.e. 3.0 will break backeard comp.
01:39:32 * gour is building latest gtk2hs
01:39:40 <dcoutts> which is why it's not planned for any time soon
01:39:45 <dcoutts> it's just an idea
01:41:15 <xerox> dcoutts: drawing2 is pretty expensive, isn't it?  heh.
01:42:01 <dcoutts> xerox, drawing2?
01:42:07 <xerox> (the demo)
01:44:05 <dcoutts> oh that, nice aint it?
01:44:48 <dcoutts> a bit random
01:45:18 <xerox> :-)
01:48:44 <xerox> dcoutts: what's the practical solution for install GHC on Jen2?
01:49:11 <dcoutts> xerox, gentoo? just emerge ghc
01:49:21 <dcoutts> or emerge ghc-bin
01:49:30 <dcoutts> since that wont take so long
01:49:41 <xerox> greaty.
01:49:43 <xerox> -y
01:49:50 <dcoutts> xerox, you moving to gentt?
01:49:56 <dcoutts> *gentoo
01:50:03 <xerox> Nope, it's for a friend.
01:50:37 <xerox> Still, ubuntu gets in my way too often, at least in this installation - I'll have to clean things up somehow soon.
01:51:50 * gour is interested to hear more about experiences with ubuntu considering to put it on some friend's machine too lazy to deal a bit with gentoo
01:53:54 <xerox> My installation is a bit weird, it's very handy if you don't boot it from an external hard-drive with no space left :-P
02:13:53 <gour> xerox: pls. excuse me, was busy with phone-conversation
02:14:10 <xerox> np :)
02:14:12 <gour> xerox: i tried to install ubuntu on my new amd64 laptop, but no luck
02:14:23 <gour> so i continued with gentoo
02:14:25 <xerox> Tried a dapper snapshot?
02:14:38 <gour> nope, 5.10 cds, which i got for free
02:14:54 <xerox> you can get the devel snapshots for free too
02:15:08 <gour> ist i had to pass 'noapic nolapic vga=xxx' to boot
02:15:22 <gour> but later the install failed during the base-install
02:15:37 <xerox> ouch.  probably support is getting better these days
02:15:52 <xerox> IIRC they have some wiki where they put notes about laptop's installations
02:16:48 <gour> otoh, gentoo livecd boots and installs without a hitch
02:17:33 <gour> for myself, i still consider portage package management superior (i used synaptic with suse in the past), bit i am aware gentoo is too much for some :-)
02:17:43 <gour> s/bit/but
02:33:25 <davidhouse> is there a 'while' type construction in haskell?
02:33:42 <dcoutts> not built in, but you can write one
02:33:59 <dcoutts> there isn't because normally it would not make much sense
02:34:18 <dcoutts> it's not very functional
02:34:18 <davidhouse> right. thanks.
02:34:23 <davidhouse> no, true.,
02:36:05 <roconnor> @hoogle while
02:36:06 <lambdabot> Data.List.takeWhile :: (a -> Bool) -> [a] -> [a]
02:36:06 <lambdabot> Data.List.dropWhile :: (a -> Bool) -> [a] -> [a]
02:36:06 <lambdabot> Prelude.takeWhile :: (a -> Bool) -> [a] -> [a]
02:36:33 <roconnor> @hoogle untill
02:36:34 <lambdabot> No matches found
02:36:35 <roconnor> @hoogle until
02:36:36 <lambdabot> Prelude.until :: (a -> Bool) -> (a -> a) -> a -> a
02:37:24 <dcoutts> oh I forgot about that function
02:37:52 <davidhouse> how does that work?
02:38:14 <roconnor> > until (==7) (+1) 0
02:38:15 <lambdabot> 7
02:38:17 <dcoutts> > unitl (>10) (+1) 0
02:38:18 <lambdabot>  Not in scope: `unitl'
02:38:22 <dcoutts> > until (>10) (+1) 0
02:38:24 <lambdabot> 11
02:38:26 <dcoutts> yeah
02:38:37 <davidhouse> okay, thanks.
02:38:54 <dcoutts> @type iterate
02:38:55 <lambdabot> forall a. (a -> a) -> a -> [a]
02:40:43 <dcoutts> > head $ dropWhile (not . (>10)) $ iterate (+1) 0
02:40:44 <lambdabot> 11
02:42:51 <dcoutts> > let while p f = head . dropWhile p . iterate f in  while (<=10) (+1) 0
02:42:52 <lambdabot> 11
02:44:32 <roconnor> woa, FiniteMap is depricated
02:45:24 <dcoutts> use Data.Map
02:45:35 <dcoutts> xerox, fixed your build bug
02:46:42 <roconnor> Sweet, this will make my program 12 characters shorter
02:46:56 <roconnor> maybe more
02:47:17 <xerox> Good :-)
02:47:19 <dcoutts> xerox, darcs pull; ./configure --with-hcflags=-fasm --enable-docs
02:50:25 <lightstep> what is the type the dataTypeOf returns? the type that the initial constructor for that value belongs to?
02:57:46 <roconnor> @hoogle (Map a b) -> [(a,b)]
02:57:47 <lambdabot> Data.Map.assocs :: Map k a -> [(k, a)]
02:57:47 <lambdabot> Data.Map.toList :: Map k a -> [(k, a)]
02:57:47 <lambdabot> Data.Map.toAscList :: Map k a -> [(k, a)]
02:57:58 <davidhouse> what's the difference between mapM and mapM_?
02:58:12 <lightstep> mapM collects the results, and mapM_ doesn't
02:58:20 <lightstep> like map and for-each in scheme
02:58:36 <xerox> foreach = flip mapM_
02:58:58 <roconnor> @hoogle [(a,b)] -> Map a b
02:58:59 <lambdabot> Data.Map.fromDistinctAscList :: [(k, a)] -> Map k a
02:58:59 <lambdabot> Data.Map.fromList :: Ord k => [(k, a)] -> Map k a
02:58:59 <lambdabot> Data.Map.fromAscList :: Eq k => [(k, a)] -> Map k a
02:59:01 <lightstep> @type mapM
02:59:03 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
02:59:13 <lightstep> @type mapM_
02:59:14 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> [a] -> m ()
02:59:25 <davidhouse> ah.
02:59:34 <lightstep> xerox, actually this is the argument order for scheme's for-each
03:00:23 <xerox> lightstep: in the Haskell world is idiomatic to write that definition, or even forM_ = flip mapM_, to do things like forM_ [1..] $ do ...
03:00:33 <davidhouse> well, what i have a list of strings. i basically want to write them to a file, one line per item in the list. i tried something like the following:
03:00:42 <davidhouse> mapM_ (hPutStrLn h) content
03:01:13 <davidhouse> it compiles okay but doesn't seem to write anything
03:02:07 <lightstep> it should
03:02:34 <davidhouse> hmm... maybe there's an error further up then
03:04:10 <davidhouse> openFile takes a relative path, right?
03:07:34 <davidhouse> well, the two lines doing the writing basically look like this:
03:07:35 <davidhouse>  h <- openFile filename WriteMode
03:07:35 <davidhouse>  mapM_ (hPutStrLn h) content
03:09:29 <lightstep> hClose?
03:10:31 * davidhouse slaps forehead
03:10:55 <davidhouse> yeah, i put it in a bracket and it started working :) guess it was the lack of hClose.
03:11:19 <lightstep> @type writeFile
03:11:20 <lambdabot> FilePath -> String -> IO ()
03:11:49 <davidhouse> i could do that, i suppose.
03:12:05 <phas> @type openFIle
03:12:07 <lambdabot> Not in scope: `openFIle'
03:12:17 <phas> uh O_o
03:12:24 <phas> ah lol
03:12:28 <phas> @type openFile
03:12:29 <lambdabot> Not in scope: `openFile'
03:12:30 <lightstep> @type IO.openFile
03:12:32 <lambdabot> FilePath -> GHC.IOBase.IOMode -> IO GHC.IOBase.Handle
03:12:35 <phas> lul
03:12:37 <davidhouse> i'd need some func to collapse the list of strings into one long string: something like foldr (++) "" contents would do?
03:12:51 <lightstep> @type unlines
03:12:52 <lambdabot> [String] -> String
03:12:53 <phas> concat
03:12:57 <phas> or unword
03:13:04 <lightstep> it depends
03:13:09 <phas> @type unword
03:13:11 <lambdabot> Not in scope: `unword'
03:13:15 <phas> euuuuuuh
03:13:17 <lightstep> s
03:13:21 <davidhouse> @type concat
03:13:23 <lambdabot> forall a. [[a]] -> [a]
03:13:28 <phas> #type String.unword
03:13:45 <lightstep> @type unwords
03:13:47 <lambdabot> [String] -> String
03:13:56 <phas> lol
03:14:26 <phas> concat do ["blah","asd","blu"] -> "blahasdblu"
03:14:51 <phas> unwords do ["blah", "asd","blu"]-> "blah asd blu"
03:15:26 <roconnor> @hoogle Map
03:15:27 <lambdabot> Data.IntMap.map :: (a -> b) -> IntMap a -> IntMap b
03:15:27 <lambdabot> Data.IntSet.map :: (Int -> Int) -> IntSet -> IntSet
03:15:27 <lambdabot> Data.List.map :: (a -> b) -> [a] -> [b]
03:17:40 <lightstep> i don't get gfoldl
03:17:58 <phas> uhm
03:18:08 <lightstep> @type Data.Generics.gfoldl
03:18:10 <lambdabot> forall a (c :: * -> *).
03:18:10 <lambdabot> (Data.Generics.Basics.Data a) =>
03:18:10 <lambdabot> (forall a1 b.
03:18:10 <lambdabot> (Data.Generics.Basics.Data a1) =>
03:18:10 <lambdabot> c (a1 -> b) -> a1 -> c b)
03:18:12 <lambdabot> [3 @more lines]
03:18:35 <lightstep> howcomes the combiner takes just one argument?
03:19:04 <lightstep> i looked at the implementation, but they just give it the subterms, one at a time
03:19:17 <lightstep> but it should be parametric in b
03:34:11 <xerox> phas!
03:37:40 <basti_> phas?
03:38:30 <xerox> He's one italian friend of mine :-)
03:38:58 <basti_> ah
03:44:17 <jyp> @where phrac
03:44:17 <lambdabot> I know nothing about phrac.
03:45:15 <phas> uh? eh? ah? who names me?
03:45:49 <jyp> @where+ phrac http://www.cse.unsw.edu.au/~pls/repos/phrac/
03:45:50 <lambdabot> Done.
03:51:21 <xerox> :-)
03:51:27 <xerox> jyp: what is phrac?
03:52:07 <jyp> Phrac is a type checker and interpreter for a Haskell-like language with associated
03:52:07 <jyp>  type synonyms
03:54:24 <jyp> xerox: Are you italian or french ?
03:54:36 <jyp> or something else altogether ? :)
03:57:45 <xerox> The former :-)
03:57:56 <cyberz> hello
03:58:20 <xerox> Hi!
03:58:35 <xerox> cyberz is another my italian friend.  Today we've got plenty of them ;-)
03:59:56 <Saulzar> Are you starting a haskell revolution over there? :)
03:59:58 <xerox> (We've also got #haskell.it, you would be the 6th member!)
04:04:47 <cyberz> hehe
04:06:22 <astrolabe> Not many Italians on the map.
04:06:26 <astrolabe> @map
04:06:27 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
04:06:29 * xerox
04:25:28 <integral> @libsrc Control.Arrow
04:25:28 <lambdabot> http://darcs.complete.org/fptools/libraries/base/Control/Arrow.hs
04:25:32 <integral> @index Kleisli
04:25:33 <lambdabot> Control.Arrow, Control.Arrow
04:26:18 <integral> @pl (\b -> f b >>= g)
04:26:19 <lambdabot> (g =<<) . f
04:42:58 <phas> hi
04:43:14 <phas> i've a app that initializes a GUI with gtk2hs in a new thread
04:43:39 <phas> but on mainQuit
04:43:54 <phas> nor the thread or the windows quits
04:44:08 <phas> @paste
04:44:09 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
04:44:46 <phas> @lispaste
04:44:46 <lambdabot> Unknown command, try @listcommands.
04:44:52 <phas> @listcommands
04:44:52 <lambdabot> use listcommands [module|command]. Modules are:
04:44:52 <lambdabot> babel base code compose dice dict djinn dummy dynamic elite fact haddock
04:44:52 <lambdabot> help hoogle karma lShell localtime more pl plugs poll pretty quote search
04:44:52 <lambdabot> seen spell state system todo topic type version vixen where
04:45:18 <phas> whoha
04:45:26 <phas> how to get the link to lisppaste site?
04:45:46 <dcoutts> phas, use flush just after the call to mainGUI
04:46:25 <phas> flush?
04:46:38 <phas> @hoogle flush
04:46:39 <lambdabot> Graphics.Rendering.OpenGL.GL.FlushFinish.flush :: IO ()
04:46:39 <lambdabot> GHC.ConsoleHandler.flushConsole :: Handle -> IO ()
04:46:39 <lambdabot> System.IO.hFlush :: Handle -> IO ()
04:46:43 <dcoutts> it's a Gtk func
04:46:59 <dcoutts> it's just Graphics.UI.Gtk.flush :: IO ()
04:48:00 <phas> and what it does?
04:48:35 <dcoutts> it flushes all pending commands to the X11 server
04:48:58 <dcoutts> perhaps we should just include it in mainGUI
04:49:06 <phas> uhm
04:49:09 <dcoutts> it's not often needed
04:49:26 <dcoutts> try it, it's not an important gui concept, it's just a quirk
04:49:47 <phas> tryed
04:49:49 <phas> nothing changed
04:50:16 <dcoutts> did you hide the window before calling mainQuit ?
04:50:25 <phas> nope
04:50:38 <dcoutts> then it stays :-)
04:50:49 <dcoutts> mainQuit doesn't terminate the whole program
04:50:54 <phas> oh
04:51:00 <dcoutts> it jsut stops the GUI running and makes mainGUI return
04:51:10 <phas> yeah but
04:51:41 <phas> the structure of the thread is forkIO $ do initGUI
04:52:11 <phas> so it's supposed to exit when the GUI is stopped
04:52:13 <phas> or not?
04:52:44 <phas> i don't remember how to get the link for code pasting
04:52:55 <phas> otherwise i'll show you
04:56:37 <dcoutts> http://www.haskell.org/hawiki/HaskellIrcPastePage
04:56:51 <phas> thx
04:57:16 <phas> but wasn't lisp paste or something like that?
05:06:28 <jethr0> http://paste.lisp.org/new/haskell
05:07:14 <lisppaste2> Phas pasted "thWin" at http://paste.lisp.org/display/16147
05:08:04 <lisppaste2> Phas annotated #16147 with "Bug" at http://paste.lisp.org/display/16147#1
05:09:13 <dcoutts> phas, ok, so if you 'widgetHide window' or 'widgetDrestroy window' after mainGUI and before flush then the window will be removed from the screen
05:09:31 <dcoutts> if you're not reusing the window then use widgetDrestroy
05:09:49 <dcoutts> widgetDrestroy/widgetDestroy
05:09:51 <phas> ok
05:10:47 <dcoutts> you see it's perfectly ok to call mainGUI more than once in a program so it would not be right for mainQuit to destroy all the windows
05:11:01 <phas> i see
05:11:27 <dcoutts> (unlike wxwidgets where after finnishing the main loop it cannot be restarted)
05:11:51 <phas> ok, now it works
05:11:59 <dcoutts> good :-)
05:12:25 <phas> the last ting
05:12:46 <phas> is that when there is a windows
05:13:01 <phas> it doesn't design another if it receive a new message
05:13:15 <phas> like it doesn't use a separated thread
05:13:21 <phas> i think i have to add something like
05:13:41 <phas> timeoutAddFull (yield >> return True) priorityDefaultIdle 20
05:13:45 <phas> in the main
05:13:50 <dcoutts> yes
05:15:22 <phas> @hoogle yeld
05:15:23 <lambdabot> No matches found
05:15:27 <phas> uhm
05:15:38 <roconnor> @hoogle yield
05:15:39 <lambdabot> Control.Concurrent.yield :: IO ()
05:15:39 <lambdabot> GHC.Conc.yield :: IO ()
05:16:26 <phas> d'uh
05:17:29 <phas> uh, weird
05:17:33 <phas> i added that line
05:17:46 <phas> now it draws a window on the first message
05:17:58 <phas> it receives a seconds and draws a second window
05:18:06 <phas> but when receives a third one
05:18:13 <phas> it doesn't draw the third
05:18:33 <phas> when i close one of the previous, it draws one of the new
05:18:37 <phas> uh O_o
05:18:41 <dcoutts> phas, what does your code do when it recieves a message?
05:19:13 <dcoutts> phas, I think you should be doing initGUI and mainGUI in the main thread, not in each thread
05:19:25 <dcoutts> otherwise you're doing mainGUI several times concurrently
05:19:32 <dcoutts> which probably doesn't make sense
05:19:43 <phas> yeah, i know this very bad
05:19:54 <dcoutts> then instead of using: button `onClicked` mainQuit
05:19:59 <lisppaste2> Phas annotated #16147 with "server code" at http://paste.lisp.org/display/16147#2
05:20:15 <dcoutts> button `onClicked` widgetDestroy window
05:20:32 <phas> uh
05:20:50 <dcoutts> phas, that way the gui is running all the time but you only create windows and destroy them individually
05:21:05 <xerox> Ah-ha, I thought so.
05:21:21 <phas> mmh
05:22:21 <phas> so you are saying to move the mainGUI in the Server.hs code
05:22:35 <dcoutts> phas, take another look at the IRC example code in this FAQ:
05:22:35 <dcoutts> http://haskell.org/gtk2hs/archives/2005/07/24/writing-multi-threaded-guis/
05:22:48 <xerox> phas: did you quit gobby?
05:23:15 <dcoutts> see how it does initGUI in the main thread and does forkIO for acepting connections
05:23:36 <phas> yeah
05:23:45 <phas> xerox: no, connection died
05:24:02 <phas> but it's totally another design of code
05:24:09 <phas> and design of app
05:24:13 <dcoutts> phas, it's not very different
05:24:33 <dcoutts> phas, you just move the initGUI from inside winDraw to main
05:24:56 <phas> well you have a main thread wich write a GUI and a forked thread wich update it reading messages
05:25:11 <dcoutts> yep
05:25:25 <dcoutts> so only two threads are needed
05:25:28 <phas> there i have the opposite
05:25:44 <xerox> dcoutts: do you know what to do if one loses the wiki's password?
05:25:52 <dcoutts> xerox, nope, sorry
05:25:57 <phas> i have a main thread that listen on messagges and creates a windows if it's needed
05:26:12 <phas> mainly beacuse this would be somewhat like a deamon
05:26:21 <dcoutts> phas, that's ok
05:26:23 <phas> it doesn't need a GUI while listening
05:26:52 <dcoutts> phas, but the problem is that you are forking a thread for each incomming connection and each one is calling mainGUI
05:27:07 <dcoutts> but you really only want mainGUI called once at a time
05:27:26 <dcoutts> it's not necessary to start the GUI right at the beginning
05:27:29 <phas> Yeah I noted this while i began to write the GUI
05:27:38 <dcoutts> you can delay it until a window is needed
05:27:55 <phas> ok
05:28:08 <dcoutts> phas, you can do:
05:28:09 <phas> but when i start the GUI
05:28:43 <dcoutts> forkIO loop >> mainGUI
05:30:25 <phas> uuh?
05:31:39 <dcoutts> phas, or the other way around
05:31:47 <dcoutts> forkIO mainGUI >> loop
05:32:34 <dcoutts> phas, the point is you only want mainGUI once
05:32:39 <dcoutts> not for each incomming message
05:32:47 <phas> dcoutts, yeah, this is clear
05:33:44 <dcoutts> phas, how about this...
05:36:44 <lisppaste2> dcoutts pasted "server GUI" at http://paste.lisp.org/display/16148
05:37:13 <dcoutts> oh I mised something...
05:40:05 <lisppaste2> dcoutts annotated #16148 with "update" at http://paste.lisp.org/display/16148#1
05:40:28 <phas> uuuh cool
05:40:37 <dcoutts> phas, see what's going on?
05:40:50 <dcoutts> we just init the gui once
05:40:59 <dcoutts> and do it just after the first message arrives
05:41:10 <xerox> dcoutts: can't we init the GUI and then let it that way forever?
05:41:22 <dcoutts> xerox, sure
05:41:43 <dcoutts> then the winDraw doesn't quit the GUI loop, it just closes the window it created
05:42:35 <dcoutts> xerox, that's what the code I pasted does 
05:42:59 <dcoutts> xerox, you'd have to do something more cunning to start it and stop it as necessary
05:43:38 <dcoutts> ie keep a count the number of windows open. But it's not necessary. It's ok to leave the GUI main loop running.
05:43:55 <xerox> dcoutts: no I mean, initGUI >> forkIO loop >> mainGUI ?
05:44:13 <dcoutts> xerox, sure, that's ok too
05:44:23 <xerox> OK.
05:44:31 <dcoutts> but phas whated to delay initialisng the gui until the first message arrived
05:44:58 <dcoutts> it's even easier as you say to do it unconditionally at the beginning
05:45:04 <xerox> Yeah.
05:45:09 <dcoutts> that's what I suggested first :-)
05:46:09 <xerox> :-)
05:46:13 <xerox> I was away, sorry.
05:46:26 <dcoutts> np :-)
05:50:10 <xerox> Anybody knows what to do when one doesn't remember the wiki account's password?
05:50:58 <Saulzar> I would guess the proper way to do it is to create the gui but not show windows, then pass messages - but that's more cunning :)
05:52:09 <dcoutts> Saulzar, that's what we started with
05:52:17 <dcoutts> and it's the simplest thing to do
05:52:21 <dcoutts> which is nice :-)
05:52:25 <xerox> And that's how we're gobbying
05:52:31 <xerox> dcoutts: want to join the gobby session?
05:52:34 <dcoutts> sure!
05:52:56 <xerox> Saulzar: if you have ideas feel free to come :-)
05:53:22 <Saulzar> I'll need to install it :)
05:54:03 <xerox> Install the 0.3 version, it is not compatible with previous ones.
06:35:11 <SimonRC> hi *2
06:37:14 <tromp> > [hi]>>[hi]
06:37:15 <lambdabot>  Not in scope: `hi'
06:37:29 <tromp> > "hi">>"hi"
06:37:30 <lambdabot> "hihi"
06:37:32 <SimonRC> @hoogle intereact
06:37:33 <lambdabot> No matches found
06:37:40 <SimonRC> @hoogle interact
06:37:41 <lambdabot> Prelude.interact :: (String -> String) -> IO ()
06:37:41 <lambdabot> System.IO.interact :: (String -> String) -> IO ()
06:37:41 <lambdabot> System.Process.runInteractiveCommand :: String -> IO (Handle, Handle,
06:37:41 <lambdabot> Handle, ProcessHandle)
06:38:02 <tromp> funny how you can make >> look like concatenation:)
06:38:34 <tromp> > "hi">>"hi">>"hi"
06:38:36 <lambdabot> "hihihihi"
06:39:15 <SimonRC> [1,2]>>[3,4]
06:39:19 <SimonRC> > [1,2]>>[3,4]
06:39:20 <lambdabot> [3,4,3,4]
06:39:50 <SimonRC> [y | x <- [1,2], y <-[3,4]]
06:40:00 <SimonRC> > [y | x <- [1,2], y <-[3,4]]
06:40:02 <lambdabot> [3,4,3,4]
06:40:05 <SimonRC> ah, yes
06:40:34 <SimonRC> didn't Haskell use to allow comprhensions for any monad
06:40:36 <SimonRC> ?
06:41:32 <tromp> not that i know
06:41:32 <Igloo> It did
06:41:32 <SimonRC> > do { x <- [1,2] ; y <- [3,4] ; return y }
06:41:32 <lambdabot> [3,4,3,4]
06:41:32 <SimonRC> Igloo: why not now?
06:41:39 <Igloo> It was thought not worth it for the more confusing error messages
06:41:50 <tromp> using the same syntax?
06:41:54 <SimonRC> :-(
06:43:25 <tromp> like [() | a<-getLine, putStrLn a] ?
06:43:31 <SimonRC> Module main where; using DontTreatMeLikeANewbie; foo = [ () | xs <- getStrLn ; putStrLn $ reverse xs ]
06:43:41 <SimonRC> :-)))
06:44:21 <SimonRC> and I suppose [ a |] == return a
06:44:23 <tromp> it makes more sense to abolish comprehensions in favor of do notation:)
06:44:44 <SimonRC> but [ a |] == return (a::[a])
06:44:46 <SimonRC> oops
06:44:50 <SimonRC> but [ a ] == return (a::[a])
06:45:16 <tromp> [a] == return a
06:45:39 <tromp> but only for lists:(
06:45:43 <SimonRC> yesw
06:45:51 <SimonRC> tromp: nah, just use >> and >>=
06:46:06 <tromp> do looks nice
06:46:42 <SimonRC> I was kidding (mostly)
06:48:03 <MarcWeber> Hi. I need some advice. I want to write a simple program using com/hdirect on windows. The examples distributed with hdirect show that everything is compiled via C. So you use the com dll file and ihc to create the haskell interface file. Those are compiled with ghc to .o files -> exe.  
06:48:13 <SimonRC> > [1,2] >>= (([3,4] >>=).(*)) 
06:48:14 <lambdabot>  add an instance declaration for (Num [b])
06:48:19 <SimonRC> feh
06:48:27 <SimonRC> > [1,2] >>= (([3,4] >>=).map (*)) 
06:48:28 <lambdabot> Couldn't match `a -> [b]' against `[b1]'
06:48:31 <SimonRC> hmm
06:48:34 <MarcWeber> My problem when trying to use make: make wants cygwin path, ihc wants win path. 
06:48:35 <int-e> liftM2?
06:48:47 <SimonRC> > [1,2] >>= (([3,4] >>=).liftM2 (*)) 
06:48:48 <lambdabot>  add an instance declaration for (Num [a2])
06:48:48 <lambdabot>   In the list element: 4
06:48:53 <SimonRC> never mind
06:50:29 <int-e> > liftM2 (*) [1,2] [3,4]
06:50:31 <lambdabot> [3,4,6,8]
06:51:59 <MarcWeber> I'ts kind of ugly trying to tell make to escape \ from windows. So thought of using cabal... In which way can cabal support me ? I mean are there any plans to implement some platform independent make like features?
06:58:17 <astrolabe> Are there any haskell tracers that a unix ignoramus can use?
06:59:54 <int-e> > [1,2] >>= ([3,4] >>=) . (return.) . (*)
06:59:55 <lambdabot> [3,4,6,8]
07:06:30 <jethr0> int-e: i never understood how liftM knows into which monad to lift. or is that a stupid question?
07:06:46 <int-e> jethr0: it doesn't.
07:06:57 <int-e> @type Control.Monad.liftM
07:06:59 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
07:07:51 <jethr0> int-e: ahh, so it only starts lifting when you give it the target monad
07:07:57 <int-e> @type let liftM' f m = m >>= (return . f) in liftM'
07:07:59 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b) -> m a -> m b
07:08:36 <jethr0> int-e: cool, thx
07:08:42 <int-e> jethr0: it's defined in terms of monad operations and thus works for all monads.
07:15:31 <jix> hi
07:19:37 <roconnor> jix: hi
07:30:43 <phas> @hoogle unword
07:30:44 <lambdabot> Data.List.unwords :: [String] -> String
07:30:44 <lambdabot> Data.PackedString.unwordsPS :: [PackedString] -> PackedString
07:30:44 <lambdabot> Prelude.unwords :: [String] -> String
07:32:32 <phas> @hoogle [a] -> a -> [a]
07:32:33 <lambdabot> Data.List.intersperse :: a -> [a] -> [a]
07:32:33 <lambdabot> Data.List.delete :: Eq a => a -> [a] -> [a]
07:32:33 <lambdabot> Data.List.insert :: Ord a => a -> [a] -> [a]
07:33:37 <jethr0> @seen adept
07:33:38 <lambdabot> adept is in #haskell. I don't know when adept last spoke.
07:36:45 <SimonRC> hi * 2
07:37:16 <jyp> hi! hi!
07:37:25 <roconnor> cycle "hi"
07:37:41 <jyp> >cycle "hi"
07:37:46 <ibid> repeat "hi"
07:37:46 <jyp> > cycle "hi"
07:37:48 <lambdabot> "hihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihi
07:37:48 <lambdabot> hihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihih
07:37:48 <lambdabot> ihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihi
07:37:48 <lambdabot> hihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihih
07:37:48 <lambdabot> ihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihi
07:37:50 <lambdabot> [23 @more lines]
07:37:56 <jyp> @spam
07:37:57 <lambdabot> Terminated
07:38:05 <jethr0> hmm, must be 23 _pretty_ long lines
07:38:14 <jethr0> at least some of them
07:38:20 <ibid> > repeat "hi"
07:38:21 <lambdabot> ["hi","hi","hi","hi","hi","hi","hi","hi","hi","hi","hi","hi","hi","hi","
07:38:21 <lambdabot> hi","hi","hi","hi","hi","hi","hi","hi","hi","hi","hi","hi","hi","hi","hi",
07:38:21 <lambdabot> "hi","hi","hi","hi","hi","hi","hi","hi","hi","hi","hi","hi","hi","hi","hi"
07:38:21 <lambdabot> ,"hi","hi","hi","hi","hi","hi","hi","hi","hi","hi","hi","hi","hi","hi","
07:38:21 <lambdabot> hi","hi","hi","hi","hi","hi","hi","hi","hi","hi","hi","hi","hi","hi","hi",
07:38:23 <lambdabot> [24 @more lines]
07:38:28 <ibid> @spam
07:38:29 <lambdabot> Terminated
07:39:09 <jyp> Now that I got you attention ;) those who care can check http://hackage.haskell.org/trac/ghc/wiki/CollectionClassFramework
07:43:00 <jethr0> jyp: i have not idea what i'm talking about, but don't you have "map" in collection?
07:43:20 <jyp> map as in Functor ?
07:43:28 <jethr0> *why
07:43:32 <jethr0> yes
07:43:48 <jethr0> some sort of one-by-one iteration
07:43:54 <vincenz> re
07:44:11 <Saulzar> Hmm.. does set support Map? You could make it "not a set"
07:44:20 <jethr0> true
07:44:30 <jyp> then we'd want Functor to be a superclass of collection; but that is not really feasible
07:44:42 <jethr0> i didn't think of set :(
07:44:54 <jyp> Functor alone does the job just as fine
07:45:22 <Saulzar> Looks cool. Not sure if collections are entirely about performance, are they?
07:45:25 <jethr0> well, map _could_ return a list, or sth. but i guess it's really non-sensical
07:45:53 <roconnor> A Bag is a Finite Multiset?
07:46:52 <jyp> roconnor: no; it's an extremely bad named abstraction for Sets.
07:47:00 <vincenz> jyp: do you need some special typing stuff for this
07:47:32 <jyp> vincenz: for what ?
07:47:38 <vincenz> for that collection impl
07:48:07 <jyp> Functional dependencies
07:48:15 <jyp> ie; it's not 98
07:48:29 <jethr0> (\\) = difference
07:48:29 <jethr0> difference = (\\)
07:48:30 <jethr0> :)
07:48:34 <Saulzar> Yeah, I think a Bag usually refers to multisets, I guess the trouble is that Set is taken, do classes and types exist in the same namespace?
07:49:10 <vincenz> there was once a discussion on c.f.l about mapping over a set
07:49:15 <vincenz> (or maybe iti aws fa.caml)
07:50:07 <Saulzar> There would be a lot of implementation choices for when it goes wrong
07:50:08 <jethr0> well, you could always do "fromList . map f . toList" :)
07:50:21 <xerox> There is a Map's map
07:50:50 <jyp> Indeed, types can be made instances of Functor just the same.
07:50:56 <phas> @hoogle PortNumber -> string
07:50:57 <lambdabot> Prelude.undefined :: a
07:50:57 <lambdabot> Data.Graph.Inductive.Monad.emptyM :: GraphM m gr => m (gr a b)
07:50:57 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
07:51:01 <phas> @hoogle PortNumber -> String
07:51:02 <lambdabot> System.Info.os :: String
07:51:02 <lambdabot> System.Info.arch :: String
07:51:02 <lambdabot> System.Info.compilerName :: String
07:51:21 <vincenz> jyp: what are functional dependencies
07:51:26 <vincenz> jyp: and how do you differ from edison
07:52:47 <jyp> FDs: http://citeseer.ist.psu.edu/jones00type.html
07:53:00 <jyp> I'm looking for a better reference...
07:53:22 <jyp> I differ by using FDs :)
07:53:44 <jyp> and quite a lot of other things.
07:55:05 <jyp> Like having more specialized classes instead of big one fits alls.
07:55:19 <vincenz> you're working on that impl?
07:55:32 <jyp> yes
07:55:42 <vincenz> hmm
07:55:51 <vincenz> you do know that there are more categorizations?
07:56:10 <jyp> yes
07:56:38 <jyp> but what are you referring to exactly? :)
07:57:00 <vincenz> let me find my document
07:58:16 <jyp> http://hackage.haskell.org/trac/haskell-prime/wiki/FunctionalDependencies
07:59:33 <vincenz> jyp: I have (from stl/java literature):
08:00:27 <vincenz> collection -> (Set -> SortedSet) <+> Sequence <+> (Map -> SortedMap)
08:00:38 <vincenz> -> subderivation
08:00:45 <vincenz> <+> are parallel branches under a parent
08:01:25 <vincenz> actually it goes further
08:01:32 <SimonRC> Actually, That Coll module looks great.
08:01:41 <vincenz> you also haev MultiSet and MultiMap
08:02:11 <SimonRC> MultiMap a b === Map a [b] ?
08:02:19 <vincenz> good point :)
08:02:25 <jyp> SimonRC: thanks :)
08:02:29 <SimonRC> That's what Iwrite
08:02:44 <jyp> or even Map a (Set b)
08:02:59 <SimonRC> yeah, but my version has actually been used by me
08:03:05 <vincenz> but yeah it's great work already :)
08:03:18 <SimonRC> MultiSet a === Map a Integer
08:03:20 <SimonRC> ?
08:03:49 <SimonRC> but make sure the integers aren't null
08:04:04 <jyp> The thing is, I did not want to write a framework to accomodate every possible concrete data structure that can exist, but have something that fits what currenty exists.
08:04:12 <SimonRC> yes
08:04:20 <vincenz> jyp: well the idiea is that you can orthogonalize the different constraints
08:04:44 <SimonRC> By drawing the lines around it, you can see the holes in the existing types.
08:04:48 <vincenz> that's whya SortedMap Int a = Sequence a
08:04:49 <SimonRC> i.e. what could be add4ed
08:05:54 <SimonRC> UnsortedMap must be slow, surely, as the keys cannot be treated as Ord?
08:06:39 <SimonRC> hi
08:06:48 <SimonRC> Ditto UnsortedSet
08:13:15 <vincenz> hmm
08:13:22 * vincenz ran into an issue with monads yesterday
08:15:02 <jyp> Saulzar: classes and type constructors share the same namespace indeed.
08:15:11 <SimonRC> vincenz: yeah?
08:16:14 <SimonRC> hi
08:16:25 <vincenz> yea
08:16:30 <vincenz> basically it forces reevaluation
08:18:31 <vincenz> SimonRC: have you read whyfp?
08:18:37 <SimonRC> yes
08:18:44 <SimonRC> great, isn't it?
08:19:04 <vincenz> yeah
08:19:05 <vincenz> well basically
08:19:13 <vincenz> I wanted to find out how many timmes it evals the actual function
08:19:15 <vincenz> so
08:19:17 <vincenz> I first did
08:19:26 <vincenz> myfunc x = trace "Evaluating" (x*x)
08:19:35 <vincenz> and for the super version with take 2
08:19:37 <vincenz> it resulted in 5-6 evals (can't remember)
08:20:01 <vincenz> now I wanted to use a monad to just count it up, instead of manually counting the unsafe io lines
08:20:03 <vincenz> so I made it into a monad
08:20:08 <vincenz> but this resulted ini a lot more evaluations
08:20:14 <SimonRC> It would
08:20:19 <vincenz> because terms are being reevaluated
08:20:49 <SimonRC> You want UnsafePerformIO and an IORef
08:20:59 <vincenz> can't do it without going unsafe?
08:21:14 <SimonRC> I don't think so.
08:21:19 <vincenz> too bad
08:21:24 <SimonRC> anyway, trace does it.
08:21:48 <roconnor> persumably the compiler gets to do more optimizations when you do it outside a monad?
08:21:48 <vincenz> yeah I know
08:21:57 <SimonRC> roconnor: yes
08:21:59 <vincenz> it's obvious why
08:22:00 <vincenz> basically
08:22:01 <vincenz> if I have 
08:22:04 <vincenz> [value]
08:22:06 <vincenz> where value is a monad
08:22:08 <vincenz> it's actually a function
08:22:11 <vincenz> that is being passed the state
08:22:15 <vincenz> so it can't lazily eval it once
08:22:26 <vincenz> can't they invent some new kind of 'monad' that does abide by this rule?
08:22:35 <SimonRC> Not ness a functions, but otherwisw correct
08:22:50 <SimonRC> vincenz: erm, investigate Arrows.
08:23:23 <vincenz> @pl (+1).(+1).(+1)
08:23:24 <lambdabot> (3 +)
08:23:26 <vincenz> woo!
08:23:59 <ADEpt> jethr0: ping
08:24:12 <roconnor> @pl (1+).(1+).(1+)
08:24:12 <lambdabot> (3 +)
08:24:20 <vincenz> @pl (+1).(1+).(+1)
08:24:20 <lambdabot> (3 +)
08:24:29 <vincenz> @pl (+1).(1+).(*2)
08:24:30 <lambdabot> (2 +) . (2 *)
08:24:37 <roconnor> oh wait, why is the answer (3+) and not (+3)?
08:24:37 <vincenz> @pl (+1).(1+).(*2).(+1)
08:24:37 <lambdabot> (2 +) . (2 *) . (1 +)
08:24:39 <jethr0> ADEpt: pong
08:24:42 <vincenz> roconnor: it's commutative
08:24:46 <roconnor> pl is pretty smart
08:24:56 <roconnor> a little too smart
08:25:54 <jethr0> ADEpt: just wanted to tell you how much i enjoyed your "HitchhikersGuide" on hawiki
08:26:47 <jethr0> haskell.org seems down :(
08:27:08 <ADEpt> jethr0: cool :) it's to be continued PrettySoon(tm)
08:27:28 <jethr0> yeah, up to chapter 1000 i saw
08:27:32 <jethr0> it's really good!
08:27:52 <jethr0> although at times jumping between topics a bit :)
08:28:32 <dcoutts> is it just me or is the haskell.org web site down?
08:28:37 <jethr0> yup
08:28:48 <dcoutts> though the machine is still ok, I can ssh in
08:28:54 <jethr0> hmm
08:29:28 <jethr0> i can telnet to port 80 :)
08:29:59 <vincenz> site works fine for me
08:30:13 <vincenz> nm, was cached
08:31:21 <ADEpt> jethr0: one question. you already knew everything, and enjoyed the text, you you actually found something new there?
08:32:13 <jethr0> ADEpt: i pretty much knew everything. for absolute beginners the tempo might be a bit steep. but it's perfect for the "exponential speedup" guys!
08:33:10 <dcoutts> I can't even connect to haskell.org port 80 from haskell.org itself
08:33:51 <dcoutts> I might reload apache on haskell.org
08:34:42 <jethr0> dcoutts: sth is running on port 80 (with telnet). it's just not responding!
08:34:56 <dcoutts> sth?
08:35:35 <jethr0> something
08:35:58 <jethr0> but reloading apache might be worth a try
08:38:43 <SimonRC> yo
08:40:52 <dcoutts> yep, restarted apache and it all seems ok now
08:41:33 <dcoutts> when I logged in initially there were loads & loads of httpd processing running
08:42:01 <dcoutts> I reloaded apache and everything slowed to a crawl as every httpd process started taking cpu
08:42:28 <dcoutts> that wne to for a while, so I stopped apache and restarted it.
08:42:32 <dcoutts> it seems fine now
08:46:55 <dcoutts> there was a spider "hl_ftien_spider indexing all of haskell.org which was putting a lot of load on the server it seems
08:54:19 <dcoutts> hmm, I wonder if we can tell bots not to index every single diff in the history of each wiki page
08:56:25 <ibid> might also want to consider using a cache between the net and mediawiki
08:56:41 <ibid> (that's what, afaict, wikipedia does)
08:58:05 <araujo> Good morning.
08:58:59 <dcoutts> ibid, mmm yeah, but for the page history we don't really want it to be indexes, because it is just so large
08:59:05 <SimonRC> araujo: afternoon
08:59:13 <araujo> Hello SimonRC 
08:59:26 <dcoutts> perhaps if it wen't links but a button/POST system for selecting diffs then bots would not index them
08:59:34 <SimonRC> dcoutts: why doesn't robots .txt work?
08:59:36 <ibid> dcoutts: nofollow?
08:59:47 <ibid> dcoutts: i mean, use the nofollow attribute for links?
08:59:54 <dcoutts> ibid, that'd be good
09:00:08 <ibid> dcoutts: dunno how many bots honor it, though
09:00:22 <dcoutts> SimonRC, I'm not quite sure how much control one can have in robots.txt
09:00:24 <ibid> dcoutts: you could use a rewriterule to deny access to bots that don't :)
09:00:30 <dcoutts> we don't want to exclude bots completely
09:01:00 <dcoutts> ibid, heh, that probably needs apache skills beyond mine
09:01:21 <ibid> dcoutts: well, i can't say you can write a rewrite rule that detects bots automatically
09:01:49 <ibid> dcoutts: what you can do is keep an eye on the logs and blacklist bad bots as you notice them
09:02:06 <ibid> dcoutts: you can blacklist them selectively so that they still can index the non-history
09:02:34 <dcoutts> ibid, yes, I'm looking at the robots.txt docs
09:03:02 <ibid> well, my scheme is complementary to robots.txt :)
09:03:15 <dcoutts> ibid, oh I see what you mean
09:03:27 <dcoutts> it's facinating looking at the web server logs, seeing what people are googling for that brings them to various pages on haskell.org
09:03:48 <ibid> i've been tempted to blacklist msnbot
09:04:23 <ibid> nevermind any anti-microsoft bias i might have, indexing stuff more than once a day is a little too often :)
09:04:32 <sproingie> tarpit 'em
09:05:13 <dcoutts> [Sat Jan 28 11:59:53 2006] [error] server reached MaxClients setting, consider raising the MaxClients setting
09:05:20 <dcoutts> hmm that's not good
09:05:24 <ibid> especially when those stuff have proper expiration headers that tell the bot the stuff is good for at least one month
09:05:29 <sproingie> DOS attack?
09:05:34 <dcoutts> and now haskell.org is not responding again
09:05:40 <ibid> dcoutts: gee
09:05:43 <dcoutts> at least apache
09:05:49 <ibid> dcoutts: reaching MaxClients tends to do that :)
09:06:01 <dcoutts> really? how?
09:06:16 <dcoutts> all the sub processes are serving pages?
09:06:22 <dcoutts> so none for new clients?
09:06:30 <ibid> dcoutts: iirc it tells apache to not accept any connections until the connection count gets lowered by other connections dying
09:06:44 <ibid> dcoutts: the clients are queued up
09:06:57 <ibid> dcoutts: and eventually timeout if apache can't get to them in time
09:06:59 <dcoutts> there are 151 httpd processes running
09:07:29 <ibid> dcoutts: are all the connections bots?
09:07:32 <sproingie> and none are finishing apparently.  sounds a bit like a DOS.
09:07:33 <Hans> np: noizmakaz fiit. kozy, reket, - enka, pıhjamaade hirm, stupid ( 4:52 )
09:07:33 <ibid> dcoutts: or most of them?
09:07:46 <ibid> it sounds like overload
09:07:49 <dcoutts> let me see...
09:07:53 <ibid> not necessarily a DoS attack
09:08:12 <ibid> dcoutts: note that apache logs requests when they finish
09:08:13 <sproingie> could be.  151 processes not timing out sounds like a bot run amok
09:08:15 <dcoutts> the most frequent of the last 500 acceses are:
09:08:17 <dcoutts>      90 134.36.80.135
09:08:17 <dcoutts>      58 66.171.173.244
09:08:17 <dcoutts>      26 210.139.103.206
09:08:17 <dcoutts>      18 129.67.90.21
09:08:17 <dcoutts>      16 69.92.106.115
09:08:28 <sproingie> no rdns?
09:08:38 <ibid> sproingie: that's the preferred setup
09:08:41 <dcoutts> that'd be really slow in a log file
09:09:00 <sproingie> i'm used to log munchers that do rdns for me.  lazy evaluation basically :)
09:09:00 <ibid> dcoutts: the user-agent data is more interesting
09:09:14 <dcoutts> yep, I'll get that
09:10:06 <ibid> there are apache modules that allow limiting number of connections per ip
09:10:14 <ibid> help to reign in amokbots
09:10:41 <dcoutts>     300 "Mozilla/5.0
09:10:41 <dcoutts>      91 "egothor/7.0c
09:10:41 <dcoutts>      54 "Mozilla/4.0
09:10:41 <dcoutts>      18 "Liferea/0.9.6
09:10:41 <dcoutts>       9 "Googlebot/2.1
09:10:41 <sproingie> it's like a one-liner iptables rule to
09:10:42 <dcoutts>       7 "msnbot/1.0
09:10:44 <dcoutts>       7 "IRLbot/2.0
09:10:46 <dcoutts>       3 "hl_ftien_spider"
09:11:16 <dcoutts> and the server is 98.0% idle
09:11:34 <sproingie> i have an iptables rule to limit connections for ssh, kills brute force attacks dead.  that rule just sends 'em to reject, you could always send 'em to tarpit
09:11:41 <ibid> are there still a lot of nontimeouting connections?
09:11:50 <ibid> sproingie: can you msg me the rule?
09:11:57 <sproingie> sure
09:12:00 <dcoutts> $ ps -A | grep httpd | wc -l
09:12:00 <dcoutts>     151
09:12:02 <ibid> sproingie: (not connected to this one)
09:12:37 <dcoutts> the thing I can't figure out is which hosts are the ones that are creating the dead connections
09:12:40 <sproingie> is any of haskell.org's storage on nfs?  got network issues?
09:12:52 <dcoutts> nope
09:12:58 <dcoutts> all mounts are ext3
09:13:01 <ibid> dcoutts: are they all connected to cgis?
09:13:06 <dcoutts> hmm
09:13:34 <ibid> i mean, do you have a lot of cgi processes around?
09:15:12 <dcoutts> doesn't look like it
09:15:31 <dcoutts> most of the most frequently last accessed url look ok
09:15:47 <ibid> hrm. ok, i'm out of ideas then
09:16:19 <dcoutts> what I really want to know are the ips and addresses of existing connections
09:16:38 <dcoutts> ok, it's serving again
09:16:46 <ibid> what i do is kill the cgis and watch the aborted connections get logged
09:16:46 <dcoutts> perhaps the connections timed out
09:16:51 <ibid> but if they're not c«µis...
09:17:12 <ibid> (apache only logs a completed request, usually)
09:17:25 <dcoutts> right
09:17:44 <ibid> hrm, in other news, i introduced monads to my students this week
09:18:28 <_Codex> what was the reaction?
09:18:31 <SimonRC> hehehe
09:18:46 <ibid> what's so funny, SimonRC? :)
09:18:52 <ibid> _Codex: attentive
09:19:07 <SimonRC> Monads are difficult.
09:19:12 <ihope> Monads are fun!
09:19:16 <ihope> @arr
09:19:17 <lambdabot> quote module failed: getRandItem: empty list
09:19:17 <SimonRC> Okay, maybe not funny
09:19:39 <ibid> i scared them first, then told them they can handle it if they work hard
09:19:54 <ibid> they seem to believe me
09:21:25 * _Codex thinks it's best start monads with combinatory parsers -examples.
09:21:49 <ibid> i've done them, just didn't tell them it's monad-related :)
09:26:09 <ihope> So what's this empty list stuff?
09:26:30 <xerox> > null []
09:26:31 <lambdabot> True
09:26:56 <ihope> @arr
09:26:56 <lambdabot> quote module failed: getRandItem: empty list
09:27:01 <ihope> That stuff.
09:27:30 <ihope> @type null
09:27:31 <lambdabot> forall a. [a] -> Bool
09:27:32 <sproingie> @yow
09:27:33 <lambdabot> quote module failed: getRandItem: empty list
09:27:38 <sproingie> :(
09:27:50 <ihope> @type 3
09:27:51 <lambdabot> forall t. (Num t) => t
09:27:59 <ihope> @elite bleh
09:27:59 <lambdabot> elite module failed: getRandItem: empty list
09:28:12 <ihope> @. type type 3
09:28:14 <lambdabot> parse error on input `=>'
09:28:23 <ihope> :-)
09:28:58 <ihope> @type parse error on input `=>'
09:28:59 <lambdabot> parse error on input `=>'
09:29:06 <ihope> There's a @type quine...
09:29:37 <tromp_> not quite
09:29:54 <ihope> Well, sorta.
09:30:02 <xerox> dons' server finished entropy.
09:30:04 <ihope> About as close as it'll get.
09:30:38 <tromp_> can't you make lambdabot replicate your line?
09:30:46 <ihope> > (error . error) (\x -> x ++ show x) "> (error . error) (\x -> x ++ show x) "
09:30:46 <lambdabot>  lexical error in string/character literal
09:30:53 <tromp_> with something other than @type?
09:30:54 <ihope> > (error . error) (\x -> x ++ show x) "> (error . error) (\\x -> x ++ show x) "
09:30:55 <lambdabot>   The lambda expression `\ x -> ...' has one arguments,
09:30:55 <lambdabot>   but its type `String' has none
09:31:16 <ihope> > (error . error . \x -> x ++ show x) "> (error . error . \\x -> x ++ show x) "
09:31:17 <lambdabot> Add a type signature
09:31:23 <tromp_> can lambdabot output start with > ?
09:31:32 <ihope> It'll ignore it
09:31:38 <xerox> yay
09:31:48 <xerox> Will it make lb spin?
09:31:49 <ihope> > (error . error . \x -> x ++ show x) :: String -> Int "> (error . error . \\x -> x ++ show x) :: String -> Int "
09:31:50 <lambdabot>  parse error on input `"'
09:31:56 <ihope> Grr.
09:31:58 <xerox> :-)
09:32:13 <ihope> > (error . error . \x -> x ++ show x :: String -> Int) "> (error . error . \\x -> x ++ show x :: String -> Int) "
09:32:14 <lambdabot>   Expecting a function type, but found `[a]'
09:32:14 <lambdabot>   Expected type: String -> Int
09:32:14 <lambdabot>   Inferred type: [Char]
09:32:29 <ihope> Bzuh?
09:32:39 <xerox> The hunt for type-checked quines.
09:32:47 <tromp_> > putStrLn ">"
09:32:49 <lambdabot> No IO allowed
09:32:54 <ihope> > ((error . error . \x -> x ++ show x) :: String -> Int) "> ((error . error . \\x -> x ++ show x) :: String -> Int) "
09:32:55 <lambdabot> > ((error . error . \x -> x ++ show x) :: String -> Int) "> ((error .
09:32:55 <lambdabot> error . \\x -> x ++ show x) :: String -> Int) "
09:32:57 <tromp_> d'oh!
09:33:03 <xerox> uhuh.
09:33:06 <ihope> Yay!
09:33:15 <xerox> wow.
09:33:19 <xerox> @karma+ ihope
09:33:19 <tromp_> gratz!
09:33:20 <lambdabot> ihope's karma raised to 1.
09:33:26 <ihope> :-
09:33:32 <xerox> :=
09:33:35 <ihope> ::
09:33:39 <xerox> =:
09:33:44 <ihope> =/=
09:34:36 <tromp_> can you do without error?
09:34:46 <tromp_> > ">"
09:34:48 <lambdabot> ">"
09:35:09 <ihope> I don't think so.
09:35:51 <ihope> Well... if you managed to booch the Show class, then it'd work.
09:36:13 <tromp_> > error ">"
09:36:14 <lambdabot> Add a type signature
09:36:30 <tromp_> > error ">" "" Int
09:36:32 <lambdabot>  Not in scope: data constructor `Int'
09:36:42 <tromp_> > error ">" :: Int
09:36:43 <lambdabot> Exception: >
09:37:06 <ihope> (error . error) seems the way to go.
09:37:27 <tromp_> > error(error ">"):: Int
09:37:28 <lambdabot> Exception: >
09:37:37 <ihope> Hmm.
09:37:58 <ihope> > (error.error):: Int
09:37:59 <lambdabot>   Expecting a function type, but found `Int'
09:37:59 <lambdabot>   Expected type: Int
09:37:59 <lambdabot>   Inferred type: String -> c
09:38:10 <ihope> > (error.error)"foo"::Int
09:38:12 <lambdabot> foo
09:38:17 <mmc> what's the meaning of "=>" in H.? The tutorial starts using it as "gives value", so not part of the language, but later it contains " (==)   :: (Eq a) => a -> a -> Bool"   which i don't know if it has a different meaning.
09:38:34 <basti_> mmc: its sort of like an implication
09:38:35 <ihope> That means that a has to be in the Eq class.
09:38:42 <ihope> @type 3
09:38:43 <lambdabot> forall t. (Num t) => t
09:38:52 <astrolabe> It is a different meaning.
09:38:52 <ihope> So 3 is anything in the Num class.
09:39:14 <tromp_> > (rror.error)">":: Int
09:39:15 <lambdabot>  Not in scope: `rror'
09:39:18 <tromp_> > (eror.error)">":: Int
09:39:20 <lambdabot>  Not in scope: `eror'
09:39:32 <basti_> mmc: you can think of it as a kind of type constraint.
09:39:44 <ihope> > (undefined . error) "foo"
09:39:45 <lambdabot> Add a type signature
09:39:48 <SimonRC> ihope: 3 is polymorphic
09:39:49 * astrolabe can see why tromp likes statically typed languages :)
09:39:51 <tromp_> > (error.error)">":: Int
09:39:52 <ihope> > (undefined . error) "foo" :: a
09:39:52 <lambdabot> >
09:39:53 <lambdabot> Add a type signature
09:40:04 <mmc> basti_: i'll try. thanks.
09:40:14 <SimonRC> astrolabe: yes, once you get it to compile, it has not bugs.
09:40:16 <SimonRC> (usually)
09:40:30 <tromp_> > (error.error.error.error.error)">":: Int
09:40:32 <lambdabot> >
09:40:42 <ihope> > (error . undefined) "foo" :: Int
09:40:43 <lambdabot> Undefined
09:40:54 <ihope> I've managed to compile bugs before.
09:41:00 <basti_> mmc: see, a formulation like "myfunction :: (Eq a) => a->a->Bool" means that you have to supply an "a" that is "Eq" (whatever Eq might be)
09:41:17 <basti_> this is an implication in the sense that, if a is Eq, the existence of the function is implied.
09:41:50 <SimonRC> ihope: hence "(usually)"
09:42:11 <SimonRC> basti_: really it would be clearer the other way round
09:42:34 <ihope> Well... I've only written a couple of "real" programs, and one didn't work.
09:42:54 <ihope> Another one didn't really work either, I guess.
09:43:02 <basti_> SimonRC: which way round?
09:43:47 <ihope> myfunction :: a->a->Bool => (Eq a)?
09:49:04 <SimonRC> basti_: surely the function being able to have that type implies the parts of that type belong to particular calsses, no the other way round.
09:49:27 <SimonRC> i.e. (+) :: a -> a -> a => (Num a)
09:49:51 <SimonRC> or: (+) :: (Num a) <= a->a->a
09:50:02 <basti_> uhm no why? the constraint is a fact about the type, and it implies the existence of the function
09:50:07 <ibid> SimonRC: you should remember the implicit forall. (+) :: forall a: Num a => a -> a -> a
09:50:12 <basti_> yes that too ibid 
09:50:18 <basti_> that makes it easier
09:50:29 <ibid> SimonRC: that mirrors perfectly the usual forall pattern in logic
09:50:36 <SimonRC> ah, ok
09:50:55 <ibid> forall x . P(x) => Q(x), which is read, "for all x that satisfy P(x), Q(x) holds"
09:51:31 <SimonRC> Though the existance of the function is actually *equivalent* to the certain set of type constraints.
09:51:53 <ibid> when P(x) is of the form x in S, it's often abbreviated as forall x in S . Q(x)
09:52:25 <SimonRC> So: ((+) :: a->a->a) <==> ((Num a))
09:52:32 <SimonRC> but that's weird
09:53:17 <basti_> what would that mean? if i can add things, they have to be numbers?
09:53:22 <basti_> the type system already does this
09:53:53 <SimonRC> You can add thing *if and only if* they're numbers.
09:54:16 <SimonRC> I was merely suggesting a different notation that could have been used.
09:54:37 <SimonRC> Changing the current notation is not worth the hassle.
09:55:15 <basti_> hmm i actually don't think its <->... it is because of haskell's concept of namespaces
09:55:19 <basti_> not because its natural
09:55:36 <basti_> for example, you could add numbers, but also things of class "Foo"
09:57:19 <SimonRC> eh?
09:57:21 <ihope> What about numbers of class "Foo"?
09:57:29 <basti_> yea or that
09:58:01 <SimonRC> (Num a) is *like* a predicate stating that a is a numeric type (among other things)
09:58:02 <basti_> SimonRC: well you could imagine some other definition (+) :: (Foo a) => a->a->a
09:58:22 <SimonRC> that isn't allowed, is it?
09:58:24 <ihope> But would they follow the definition for numbers, or the definition for things of class "Foo"?
09:58:30 <SimonRC> ihope: indeed
09:58:40 <basti_> it is not, but you could imagine
09:58:51 * SimonRC is in favour of adding yet *more* type classes below Num, actually...
09:58:53 <basti_> and then, there might be a type that extends Num
09:59:09 <SimonRC> Field, Group, and something I don't know the name of.
09:59:18 <basti_> ring
09:59:23 <SimonRC> to allow you to add and multiply vectors and amtrices
09:59:51 <SimonRC> I'm nto sure if it could be done usefully, though :-(
10:00:05 <frobenius> hi, is there a way 
10:00:30 <frobenius> to trace a reduction in Haskell?
10:00:49 <frobenius> e.g. with GHC
10:00:59 <jethr0> frobenius: hat
10:01:00 <ihope> Um... there's Debug.Trace.Trace
10:01:28 <frobenius> what is Debug.Trace.Trace
10:01:36 <Philippa> Debug.Trace.trace is useful, although a Writer or WriterT is better if you want an actual value as your log
10:01:47 <Philippa> trace "this string" (code-to-actually-run)
10:01:56 <Philippa> prints "this string" and evaluates code-to-actually-run
10:02:14 <Philippa> (and does it all immediately when the entire expression is evaluated)
10:02:27 <frobenius> so with Debug.Trace.trade I'd have to lift all my terms to a peculiar monad?
10:02:41 <frobenius> I'd rather note change anything
10:02:50 <ihope> @type Debug.Trace.Trace
10:02:51 <lambdabot> Not in scope: data constructor `Debug.Trace.Trace'
10:02:58 <ihope> @type Debug.Trace.trace
10:02:59 <lambdabot> forall a. String -> a -> a
10:03:06 <ihope> No monads needed.
10:03:45 <frobenius> Prelude> Debug.Trace.trace "list" [1]
10:03:45 <frobenius> list
10:03:45 <frobenius> [1] 
10:03:49 <frobenius> is not so fantastic, is it?
10:04:02 <SimonRC> what do you want it to do?
10:04:04 <basti_> frobenius: you can use "trace" anywhere, thats the point
10:04:11 <ihope> Yep.
10:04:35 <Philippa> frobenius: it did exactly what you asked for, no?
10:04:56 <Philippa> Debug.Trace> trace "start" (1+ (trace "two" 2))
10:05:10 <Philippa> > Debug.Trace.trace "start" (1+ (Debug.Trace.trace "two" 2))
10:05:11 <lambdabot>  Not in scope: `Debug.Trace.trace'
10:05:20 <Philippa> Prelude> Debug.Trace.trace "start" (1+ (Debug.Trace.trace "two" 2))
10:05:22 <ihope> Lambdabot doesn't like unsafe functions.
10:05:25 <Philippa> bah, irritating bot :-)
10:06:00 <Philippa> anyway, feel free to feed that into ghci
10:06:21 <frobenius> so "trace" is imperative programming in guises 
10:06:35 <frobenius> I will check hat
10:06:46 <SimonRC> Debugging only, mind.
10:07:11 <SimonRC> you can make sure you get rid of it by removing the import statement.
10:07:22 <Philippa> yup
10:07:43 <Philippa> nothing wrong with using Debug.Trace if you would've used printf-style debugging other than laziness might break your brain
10:07:54 <Philippa> Writer/WriterT is nicer if you would have use for values rather than strings
10:08:09 <frobenius> Is there an example of "trace" usage somewhere?
10:08:13 <Philippa> hat isn't really any 'purer' than Debug.Trace, it just does the dirty stuff from the outside
10:08:25 <Philippa> frobenius: I just gave you one, the bot barfed but ghci should take it fine
10:08:52 <basti_> frobenius: basically you just put 'trace "something"' at a place...
10:09:17 <Philippa> or even trace <some expression of type String>
10:09:31 <basti_> yep
10:09:33 <Philippa> trace "foo" (<whatever you had before>)
10:09:50 <Philippa> or generally trace <some string expression> (<whatever you had before>)
10:10:14 <frobenius> hm, I really want to see lambda calculus reductions, it seems hard to keep track of variables etc with "trace"
10:11:07 <Philippa> trace (show foo) (<expression>)
10:11:42 <Philippa> IMO putting lambda calculus evaluators into monads is a good idea anyway
10:12:09 <Philippa> you can always use the identity monad if you really don't need any extra semantics, and it makes it a lot easier to build more interesting stuff. Plus they benefit from a Reader layer anyway
10:12:34 <ihope> I like the Continuation monad.
10:12:52 <SimonRC> Philippa: my evaluator has a reader monad to hold the current bindings
10:13:03 <Philippa> yeah, 'sgood innit?
10:13:23 <Philippa> what I mean by "Reader layer" is that it might be provided by a monad transformer instead
10:13:31 <Philippa> ReaderT IO might make some sense, for example :-)
10:13:51 <Philippa> "how to fuck your box up in 5 easy reduction steps" ;-)
10:14:30 <SimonRC> hmm, any clues on writing co-routines in Haskell.
10:14:42 <SimonRC> I would just use lazyness, but one of them does IO
10:14:50 <frobenius> (comonads?)
10:15:07 <basti_> SimonRC: you can just "return ..." the other one cant you?
10:15:15 <SimonRC> basti_: eh?
10:15:31 <Cale> Philippa: heh, unsafePerformContTIO
10:15:45 <basti_> SimonRC: well one is IO, you have to lift the other. you do that with return.
10:16:16 <SimonRC> How would that help me write coroutines?
10:16:43 <SimonRC> I will re-check out Control.Monad.Cont
10:17:00 <basti_> one does:  a' = do { x<-return a ; b x } , the other does  b' = do { y<-b';return y } ?
10:17:34 <Cale> what sort of coroutines are you talking about?
10:17:47 <SimonRC> Cale: weelll...
10:17:50 <Cale> Lazy evaluation basically gives you most of the benefits of coroutines.
10:17:54 <SimonRC> I am writing a roguelike...
10:18:06 <basti_> i thought coroutines are routines that call each other all the time arent they?
10:18:11 <SimonRC> It will not be player-centric at all...
10:18:28 <Cale> basti_: yeah, they call back and forth
10:18:37 <SimonRC> Player interaction will be done inside the AI for the player's object...
10:19:06 <Cale> > let a = 1 : b; b = 2 : a in take 20 a
10:19:08 <lambdabot> [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2]
10:19:30 <SimonRC> So, the simulator part and the interface will be co-routines.
10:20:04 <Cale> okay
10:20:10 <frobenius> I can't that hat thingie to compile
10:20:53 <SimonRC> The simulator will call the interface, which percieves this as a returned value, and asks the player for their nex move, then calls the simulator with the requested action, which percieves *that* as a returned value.~
10:21:07 <SimonRC> I know how to do it in Scheme...
10:21:30 <SimonRC> I suspect that Cotrol.Monad.Cont will allow me to do the same thing
10:21:53 <ihope> Control.Monad.Cont can do ANYTHING.
10:22:39 <basti_> continuations have the clarity of GOTO 
10:22:45 <SimonRC> I found recently that callCC makes much more sense if you consider what it does when you are using CPS.
10:22:59 <Cale> basti_: worse, they're sort of more general than GOTO
10:23:05 <basti_> thats right, yes.
10:23:07 <SimonRC> basti_: I.e. very clear if used well and carefully commented.
10:23:22 <basti_> you -can- do continuations right
10:23:27 <basti_> thats true
10:23:33 * SimonRC imagines his code if he turned his interface code inside-out.
10:23:46 <SimonRC> or worse, turned my *simulator* code inside-out.
10:23:50 <Cale> hell, you could do computed goto's :)
10:24:06 <basti_> you could even do computed gosubs ;)
10:24:13 <ihope> SimonRC: }a ;x -< a{ od
10:24:13 <Cale> heh
10:24:31 <SimonRC> hehehe
10:25:48 <Cale> One idea I've been playing around with is having a Chan (IO ()) for sending actions to a looping thread to have it perform in its idle time.
10:26:05 <SimonRC> yeah
10:27:10 <SimonRC> Is there a way to start evaluating a gian datastructure while waiting for the user's keypress?
10:27:17 <SimonRC> It may proove handy.
10:27:46 <Cale> well, you can evaluate it in another thread
10:27:49 <Philippa> Cale: that works, and even gives you a free mechanism to block if you intend to: the IO action writes to an MVar you do a blocking read on. 'sgenerally a cool idea
10:27:55 <ihope> @index Chan
10:27:55 <lambdabot> Control.Concurrent.Chan, Control.Concurrent
10:28:02 <ihope> Whoa!
10:28:36 * SimonRC goes.
10:30:27 <dcoutts> bugger, it's happening again haskell.org has 100+ httpd process running
10:30:55 <dcoutts> they're all in the " 'w' Sending Reply " state
10:31:03 <roconnor> is haskell.org running that webserver written in haskell ;)
10:31:07 <int-e> > let f x y = ap (++) (f y) (x++y) in take 70 $ f "*" " "
10:31:08 <lambdabot> "*  * *  *  * *  * *  *  * *  *  * *  * *  *  * *  * *  *  * *  *  * * "
10:31:28 <xerox> @pl \x y -< ap (++) (f y) (x++y)
10:31:29 <lambdabot> (line 1, column 6):
10:31:29 <lambdabot> unexpected "<"
10:31:29 <lambdabot> expecting "->"
10:31:33 <xerox> @pl \x y -> ap (++) (f y) (x++y)
10:31:33 <lambdabot> ap (ap (++) . f) . (++)
10:31:59 <ihope> int-e: eh?
10:32:56 <int-e> ihope: just a Haskell version of an Unlambda program. (pattern.unl in CUAN)
10:33:42 <ihope> Ah.
10:33:49 <ihope> Unlambda is confusing ;-)
10:39:19 <ihope> Whoa, that's quite a leave-message-thingy...
10:41:04 <int-e> > let f x y = x $ y $ f y (x.y) in take 70 $ f ('*':) (' ':) -- that's closer to my actual unlambda program
10:41:06 <lambdabot> "*  * *  *  * *  * *  *  * *  *  * *  * *  *  * *  * *  *  * *  *  * * "
10:43:50 <vincenz> Hello everyone
10:44:34 <dcoutts> damn bots
10:44:47 <dcoutts> they're holding open a connection to wiki history pages
10:44:48 <palomer> I just woke up
10:44:54 <palomer> and I'm going to code before eating breakfast
10:44:55 <dcoutts> and taking up all the httpd processes
10:45:01 <basti_> ihope: how did you get Nomius' quitmessage to compile?
10:45:12 <basti_> what is R and C?
10:45:26 <dcoutts> I restarted httpd on haskell.org a couple minutes ago and already there are 80 httpd processes running
10:45:52 <ihope> basti_: I didn't...
10:45:56 <basti_> dcoutts: is that problematic?
10:45:57 <basti_> ihope: oh
10:46:23 <dcoutts> basti_, yes because once there are 150 httpd processes running then you can't make new connections to haskell.org
10:46:31 <dcoutts> 97 and climbing
10:46:44 <basti_> dcoutts: i was asking if that is unusual... did you try server-status?
10:46:54 <basti_> we had referrer spam on one server, which did pretty much the same
10:46:54 <dcoutts> yes, that's what I'm looking at now
10:47:03 <dcoutts> it's all one bot
10:47:17 <dcoutts> holding open requests to wiki history pages
10:47:30 <int-e> basti_: http://www0.us.ioccc.org/1985/shapiro.c
10:47:45 <basti_> int-e: ah.
10:47:59 <basti_> int-e: i thought it would be somewhere near complete
10:49:14 <vincenz> out of curiousity
10:49:18 <vincenz> is ghc written in c or in haskell
10:49:38 <int-e> Yes. Much more haskell than C though.
10:49:44 <vincenz> hmm
10:49:45 <palomer> f . g $ x == f $ g x == f . g x  <--are these 3 equal?
10:49:50 <vincenz> so what happens if you don't have a haskell compiler?
10:50:05 <vincenz> palomer: not the last
10:50:11 <vincenz> g x binds tigher than the .
10:50:14 <vincenz> but
10:50:18 <vincenz> f $ g $ x is also the same
10:50:24 <palomer> oh, yeah, righto
10:50:29 * vincenz cheers for his newly learned knowledge :)
10:50:29 <palomer> application binds tighter than anything
10:50:42 <ihope> Parentheses?
10:50:49 <palomer> hmm?
10:51:00 <ihope> Parentheses bind tighter than anything.
10:51:25 <ihope> ...Anything else, that is.
10:51:44 <palomer> ok, fine
10:51:45 <vincenz> int-e: so how do you bootstrap if you're suddenly without haskell compiler?
10:51:57 <palomer> very carefully
10:52:00 <vincenz> heh
10:52:02 <vincenz> no seriously
10:53:10 <astrolabe> You download the compiler as an executable
10:53:13 <sproingie> haskell.org is hung again
10:53:19 <tromp_> parentheses don't bind...
10:53:26 <vincenz> astrolabe: what if there's suddenly no executable
10:53:32 <vincenz> astrolabe: I mean you gotta bootstrap it somehow
10:53:51 <astrolabe> So what do you have?
10:54:02 <int-e> hmm. they used to bootstrap via hbc. is that still possible?
10:54:04 <robdocki1s> vincenz: you cross-compile
10:54:10 <ihope> tromp_: they don't?
10:54:17 <vincenz> robdocki1s: ?
10:54:22 <astrolabe> Ah source code :)
10:54:36 <vincenz> assume for some reason... you're left with only the sources of ghc
10:54:41 <int-e> vincenz: you don't
10:54:45 <tromp_> not in the sense of operators bindinf
10:54:53 <robdocki1s> vincenz:  ah.  bootstrap with a different compiler...
10:54:54 * vincenz focuses the attention on *assume*
10:55:06 <vincenz> robdocki1s: yeah but the compiler of haskell is written in haskell
10:55:07 <int-e> vincenz: you write a haskell interpreter that's powerful enough first.
10:55:14 <robdocki1s> just like every other doggyfood compiler out there
10:55:16 <vincenz> obviously the same question could be made about c compilers
10:55:30 <vincenz> what if suddenly you're left in a world where you only have the c sources of the c compilers
10:55:42 <robdocki1s> right.  well, at some point in the past, someone wrote a compiler in a "lower" language
10:55:45 <vincenz> we bootstrapped ourselves into a world that's vulnerable
10:56:00 <robdocki1s> eg, GHC was entirely C until version *muble*
10:56:15 <robdocki1s> 4.x ish I think
10:56:27 <robdocki1s> as oppposed to what other language?
10:56:27 <int-e> vincenz: you curse and then write one in assembly language. if you don't have an assembler, you will write that in bare machine code. it has been done, we could do it again and it's unlikely that will ever be necessary
10:56:32 <vincenz> robdocki1s: right so the question is, can the current version of ghc (written in haskell) still be compiled by that old version, or is taht c version out of date
10:56:58 <vincenz> int-e: true but the phiilosophical thought experiment is interesting, the only reason we can go on is cause somewhere there's already a binary version of a compiler
10:57:08 <robdocki1s> If you really wanted to go to the trouble, you could start with a pure C version, and bootstrap up through the various versions until now
10:57:13 * vincenz wonders if he can meta-instantiate this concept to other things besides compilers
10:57:23 <vincenz> for instance technology
10:57:30 <vincenz> imagine suddenly all the machines broke down...
10:57:34 <robdocki1s> sure
10:57:41 <vincenz> we can't make the machines cause we don't have the machines to make em
10:57:49 <sproingie> isn't there some "evil haskell compiler" written in perl?
10:58:03 <robdocki1s> so we go back to making tools from rocks and build up from there
10:58:10 <vincenz> robdocki1s: yeah, painful
10:58:29 <vincenz> it just sometimes makes you wonder about the value of all the machines we have as they're only useful in this world of machines
10:58:41 <astrolabe> Iff all the machines broke down, we'd be stuffed.
10:58:49 <vincenz> astrolabe: iff?
10:58:51 <vincenz> or if?
10:58:52 <sproingie> vincenz: most modern humans are the same way 
10:59:03 <sproingie> vincenz: most specialists can't do their job without the work of many others
10:59:05 <robdocki1s> eh... same argument for an society with a sufficent degree of division of labor
10:59:05 <vincenz> sproingie: yeah, we built ourselves into a society where we lost the bootstrapping stage
10:59:11 <astrolabe> oops.. If  hehe
10:59:18 <vincenz> sproingie: and most markets are not necessary but are only there cause of the world we live in
10:59:25 <vincenz> I mean, one could argue that software is not a useful concept
10:59:38 <sproingie> bootstrapping is hunter-gatherer.  if even that, hunter-gatherers had to have a society to direct efficient hunting and gathering
10:59:40 <robdocki1s> I mean really, how many of us could grow enough crops to feed ourselves if necessary?
10:59:43 <vincenz> they don't fundamentally provide something new
10:59:49 <vincenz> robdocki1s: it wouldnt' work
11:00:01 <vincenz> robdocki1s: see ... we've moved to a cropping society cause we already plucked empty the resources
11:00:14 <vincenz> 1000 years ago, you could survive alone in a forest, nowadays theforests are too bare
11:00:17 <sproingie> i suppose we have enough instincts to bash rabbits with rocks by ourselves
11:00:30 <vincenz> sproingie: you assume enough rabbits still living in the wild
11:00:43 <sproingie> vincenz: if enough humans die to force us to bootstrap, they'll come back
11:00:50 <astrolabe> Ever tried to get close to a rabbit?
11:01:01 <vincenz> I saw this tv show where they took these people and made them relive the new australian life (you know like the first settlers), the natural food sources were FAR less than back then
11:01:06 <robdocki1s> well sure  --- if we lost all machines today in a magic worldwide catastrophic event, the death toll would be huge
11:01:14 <sproingie> australia's lousy with rabbits anyway
11:01:36 <vincenz> I think that holds in europe too for instance, I doubt wildlife nowadays is the same like 1000 years ago
11:01:39 <sproingie> i live in the bay area.  guess i could fish.
11:01:50 <vincenz> sproingie: I think the same applies to that
11:02:20 <sproingie> like i said, if it came to that and i was still around for some reason, there'd probably be less competition
11:02:29 <vincenz> true
11:02:46 <vincenz> you'd have massive city emigration after the looting stopped
11:02:50 <sproingie> easier to fish in the sacramento delta than the bay tho, that's for sure
11:03:25 <vincenz> but sometimes it makes you wonder, what is really truly relevant knowledge... I mean would it help you if you got dropped on an island
11:03:51 <vincenz> or is it really helping humanity
11:03:53 <vincenz> on a longterm
11:04:35 <robdocki1s> define "helping humanity"
11:05:51 <robdocki1s> I think the "desert island survival skills" angle is a bit straw-man
11:05:54 <sproingie> very easy to get existential angst over doing abstract things like programming
11:06:17 <sproingie> i stop spam.  i perform a fairly immediate benefit, but i doubt it really elevates the whole of humanity all that much.
11:06:33 <palomer> ugh
11:06:41 <palomer> my haskell code is starting to look like lisp code
11:06:49 <sproingie> but frankly, i don't aim at some ordained higher purpose.  no harm done, do what ye will, etc
11:07:02 <vincenz> sproingie: exactly, but I''m thinking of redefinig usefullness
11:07:09 <vincenz> sproingie: it used to be quite simple: procreate
11:07:26 <vincenz> but in our current knowledge-based society, I think you can have an impact on humanity without procreation
11:07:26 <sproingie> biologically speaking, that's still it
11:07:48 <vincenz> sproingie: not sure, we're overpopulated as it is
11:08:00 <robdocki1s> humm, so the only useful skills in life are those that get you laid?  We're all in the wrong field...
11:08:23 <vincenz> robdocki1s: no but often you say "I'm more successfull, I've got a great job, high pay, fast car, beautiful wife"
11:08:29 <vincenz> but then you should stop and consider, is that really more successful
11:08:35 <vincenz> or is the poor guy with 10 kids more successful?
11:08:58 <sproingie> thus our big brains tend to provide distractions from procreation as necessary.  hell, many states are actually shrinking
11:08:58 <robdocki1s> I don't think 'successful' is a total order
11:09:09 <vincenz> currently people are driven too much by selfish reasons (me inicluded) we want happiness, but taht hardly helps humanity on a long run
11:09:44 <tibbe> vincenz, how are humanity helped if all are unhappy?
11:09:56 <vincenz> tibbe: it wouldn't but it shouldn't be the sole purpose
11:10:12 <vincenz> my professor (promotor) is for instance an example of really humanity-oriented person
11:10:14 <tibbe> vincenz, what should it be and who should define it?
11:10:20 <tibbe> how so?
11:10:26 * ADEpt wonders if ANYONE did SAX-like XML processing in Haskell?
11:10:31 <sproingie> beware of those promoting humanity over humanness
11:10:31 <vincenz> this guy is brilliant but he lives for his job and helping students and cooperating, not getting his name out there
11:10:47 <tibbe> vincenz, so he doesn't like helping students?
11:11:02 <vincenz> and it's true, in academia there's too much competition, collaboration would really increase research on the long run
11:11:11 <palomer> hrm, I have a class Tagged in module Lambda and I'm exporting it but module Main doesn't see the instance I declared in Lambda, is this possible?
11:11:14 <vincenz> tibbe: not saying that, but most academia are focussed on publishing
11:11:21 <tibbe> vincenz, what's competition and collaboration in this case?
11:11:29 <vincenz> tibbe: working on the same domain
11:11:36 <vincenz> vs agreeing what the boundaries are
11:11:46 <tibbe> vincenz, because that's the government incentive, that's why they publish so much
11:11:51 <vincenz> true
11:12:18 <vincenz> anyways, I rambled too much, sorry for the spam
11:12:48 <tibbe> vincenz, I should really try to avoid politics too, I get drawn in all too easily. sorry :)
11:12:56 <vincenz> no need to apologize
11:13:11 <vincenz> but for instance, he has this metaflow for the research area our group isi focussed on
11:13:19 <vincenz> and he spends a lot of time making sure people don't do the same things
11:14:00 <vincenz> now if this was brought to an inter-university level (which we already do with some universities) it would seriously speed up research by removing redudancy, but people have to be a bit more lefty, instead of just shooting on what they'll publish
11:14:01 <tibbe> all I'm saying is that people usually disagree and "compete" beacuse 1) they think someone else is or 2) they get paid for writing alot
11:14:03 <vincenz> I hope that makes sense
11:14:13 <vincenz> tibbe: exactly, the premise is wrong
11:14:16 <sproingie> ADEpt: i believe haxml has a sax mode
11:14:32 <vincenz> I mean imagine if everyone worked on ghc instead of also hugs and jhc
11:14:40 <tibbe> vincenz, and who sets the premise?
11:14:45 <vincenz> people are stuck with the NIH syndrome
11:14:50 <vincenz> tibbe: I think it's psychological
11:14:57 <vincenz> tibbe: mostly society-related
11:15:03 <vincenz> so it'll take a while to change that mentality
11:15:14 <vincenz> I think in the US more than in Europe
11:15:18 <vincenz> I went to hs in us
11:15:24 <vincenz> there people are really put into a winner mentality "you're the best"
11:15:27 <sproingie> if everyone worked on ghc, ghc might have trex records, or perhaps no haskell implementation at all would
11:15:43 <vincenz> if I may elucidate with an anecdote
11:16:13 <tibbe> but why do you think people work on hugs? isn't it because they feel it's different in some way?
11:16:27 <vincenz> tibbe: partly: NIH
11:16:37 <sproingie> hugs predates the existence of ghci
11:16:40 <vincenz> the other part I'd have to think about it
11:16:44 <sproingie> used to be the only way to get interactive haskell
11:16:46 <vincenz> sproingie: I'm very new to the haskell community, sorry
11:16:54 * vincenz started haskelling this week
11:17:16 <sproingie> vincenz: welcome :)  i'm a noob to the language myself, but i've lurked at the fringes for years
11:17:17 <vincenz> tho it's true, I think the amount of competitiveness in US is higher than EU
11:17:26 <vincenz> sproingie: ah likewise, I often idled in here
11:17:44 <vincenz> tibbe: and that's why I think it's society based and hence changeable
11:18:03 <tibbe> but should it be changed?
11:18:07 <vincenz> tibbe: I think so
11:18:53 <vincenz> but I should think about this some more, either way, time to cook, I gotta go to a party after so a friend can introduce me to this girl
11:18:57 <tibbe> what I'm getting at is that the word competition in this context is something positive since it's about producing something better
11:19:08 <vincenz> tibbe: yes but we're often reinventing wheels
11:19:12 <tibbe> have a nice evening then ;)
11:19:15 <vincenz> thx
11:19:17 <vincenz> sorry for my spam
11:19:21 <vincenz> I enjoyed it
11:19:31 <tibbe> me too
11:19:38 <vincenz> hmm
11:19:41 * vincenz starts a channel
11:20:42 <vincenz> #meta-science ;)
11:23:53 <palomer> is it possible for parsec to succeed yet not eat all the input?
11:25:22 <tibbe> A guess would be yes but I dunno
11:25:59 <vincenz> palomer: yes
11:26:33 <palomer> how so?
11:28:20 <vincenz> palomer: well it could match the start
11:28:24 <vincenz> @index letter
11:28:25 <lambdabot> Text.ParserCombinators.Parsec.Char, Text.ParserCombinators.Parsec
11:28:34 <vincenz> > Text.ParserCombinators.Parsec.letter "a"
11:28:35 <lambdabot>  Not in scope: `Text.ParserCombinators.Parsec.letter'
11:28:45 <vincenz> yick
11:29:51 <palomer> can I force it to fail if it doesn't eat anything?
11:30:10 <vincenz> palomer: eof?
11:31:52 <palomer> good point
11:33:59 * palomer spends a considerable amount of time re aligning his code
11:37:27 <palomer> @hoogle ST
11:37:28 <lambdabot> Control.Monad.ST.Lazy.ST :: ST s a
11:37:28 <lambdabot> Control.Monad.ST.ST :: ST s a
11:37:28 <lambdabot> Graphics.UI.ObjectIO.CommonDef.St :: s -> (a, s)
11:42:30 <JohnMeacham> a language like haskell _needs_ multiple implementations to thrive.
11:42:48 * palomer clamours for jhc
11:43:05 <palomer> how is coming along?
11:43:51 <tibbe> my eager lambda calculus interpreter works :)
11:45:05 <palomer> tibbe: nice
11:46:49 <JohnMeacham> palomer: great. I have been working on it a ton the last few days.
11:47:13 <tibbe> it has named functions as well
11:47:56 <ihope> Eager lambda calculus?
11:48:17 <vincenz> ihope: pass by value
11:48:41 <ihope> And all the weird fixed-pointers that come with it? ;-)
11:49:28 <orbitz> vincenz: i'm watching american ninja 4
11:49:40 <tibbe> ihope, well, I don't know if lambda calculus can have eager evaluation and still be called lambda calculus but mine is anyway
11:50:55 <tibbe> it here: http://www.itstud.chalmers.se/~larssont/Main2.hs
11:51:05 <tibbe> feel free to critique it or report bugs
11:53:24 * palomer still thinks references is the best way to implement the lambda calculus
11:53:40 <tibbe> palomer, what do you mean?
11:53:55 <tromp_> i think translation to sk is the best way
11:54:02 <tibbe> sk?
11:54:14 <tromp_> combinators s and k
11:54:20 <tibbe> i see
11:54:45 <tibbe> this will evolve to an interpreter for a haskell light light language for a course project
11:55:07 <palomer> tibbe: I mean that variables are actually references
11:55:17 <tromp_> what's Con stant for?
11:55:24 <tromp_> Constant?
11:55:24 <tibbe> palomer, they will be, I'll have a store later
11:55:29 <tibbe> tromp_, yes
11:55:32 <palomer> STRefs
11:55:45 <tromp_> if you have to limit yourself to 3 chars...
11:55:52 <tromp_> i'd pick Lit instead
11:55:58 <tromp_> for Literal
11:56:04 <tibbe> palomer, but that only makes sense if they reference something that's bigger than the referense itself right?
11:56:20 <palomer> tibbe: what do you mean?
11:56:24 <tromp_> Con doesn't really hint at constant
11:56:26 <tibbe> tromp_, I'll probably do VInt later
11:56:37 <palomer> I just don't thing strings should have any place when interpreting terms
11:56:41 <tromp_> V for?
11:56:56 <tibbe> palomer, perhaps I missunderstood you, you always need an environment of references right?
11:56:59 <palomer> Var (STRef s (Term s)) instead of Var String
11:57:08 <palomer> tibbe: this is for your terms
11:57:21 <tibbe> I see
11:57:27 <roconnor_> > (\x -> (\y -> (\x -> y) x) 5
11:57:28 <lambdabot>  parse error on input `}'
11:57:38 <roconnor_> > (\x -> (\y -> (\x -> y)) x) 5
11:57:38 <lambdabot>  add an instance declaration for (Show (t1 -> t))
11:57:45 <tromp_> oh, you also use Num
11:57:51 <roconnor_> > (\x -> (\y -> (\x -> y) 7) x) 5
11:57:52 <lambdabot> 5
11:58:15 <tibbe> tromp_, so the names are a mess right now, I'll probably prefix values with V and expressions with E
11:58:37 <tibbe> tromp_, and have VInt VDbl, EInt EDbl etc
11:58:41 <palomer> wee
11:58:44 <palomer> we have lift off
11:58:48 * palomer makes a rocket sound with his mouth
11:58:52 <tibbe> palomer, STRefs for Ids?
11:58:59 <palomer> tibbe: you got it
11:59:00 <tromp_> don't hesitate to use more than 3 or 4 letters:)
11:59:09 * tibbe cheers as he watches the explosion...
11:59:25 <tibbe> tromp_, I wont
11:59:54 <Nanar> sorry but a stupid question:
11:59:57 <palomer> tibbe: note that using STRefs will force you to do some pretty funky things with your code
12:00:12 <Nanar> data PatchInfo = PatchInfo !PackedString !PackedString
12:00:16 <palomer> tibbe: however, it will let you evaluate inside lambdas
12:00:19 <Nanar> what does mean '!' here ?
12:00:21 <tibbe> palomer, I aim at readability atm so I'll understand my own code later
12:00:42 <tibbe> palomer, I did have lambdas as: m Value -> m Value before
12:00:47 <palomer> yeah, I don't recommend using STRefs at this stage, but I still think it's the best implementation
12:01:02 <palomer> tibbe: so lambdas were not part of your terms?
12:01:07 <palomer> that's higher order abstract syntax
12:01:17 <tibbe> palomer, I need something that I can easily translate to C-- later so I don't want to have high order functions as my representation
12:01:49 <tibbe> palomer, oh, the VFun representation was the -> thing
12:02:21 <roconnor_> tibbe: How do I see the result of eval?
12:02:41 <tibbe> roconnor_, run: runReader (eval <expr>) []
12:02:43 <palomer> STRefs don't need higher order f unctions
12:03:11 <tibbe> palomer, but wouldn't they complicate the representation and make it harder to traverse the tree and generate code?
12:03:50 <Philippa> only if c-- doesn't support mutability
12:03:52 <tibbe> what I meant was that I had a more complex representation before and I went for this one to allow easier manipulation
12:04:01 <Philippa> if you can implement a heap with pointers into it, you can handle STRefs
12:04:36 <Philippa> also, they don't really force that much funky stuff on the actual code, especially if it's already monadic
12:04:38 <tibbe> Philippa, I will have a heap
12:04:41 <Philippa> (the types get odder, yes)
12:04:51 <palomer> Philippa: I've had to use monad transformers because of my STRefs
12:05:01 <Philippa> to do what?
12:05:10 <palomer> to print the terms
12:05:12 <tibbe> Philippa, but do I gain anything buy exchanging ids as strings for STRefs?
12:05:26 <Philippa> ah. Yeah, you do have to call your prettyprinter from within the ST monad
12:05:38 <Philippa> tibbe: speed, not passing around a state
12:06:00 <Philippa> oh, and a cleaner semantic mapping
12:06:14 <palomer> maket that (STref s (Maybe (Term s)))
12:06:15 <Philippa> you *know* ST means "has a heap" and that's what STRefs do, it's less clear that's what's going on elsewhere
12:06:23 <palomer> tibbe: and application becomes a _breeze_
12:06:31 <tibbe> Philippa, but I'm not passing around any state right now right?
12:06:33 <tromp_> will this remain untyped, tibbe?
12:06:53 <Philippa> tibbe: what're you replacing with STRefs?
12:07:00 <tibbe> tromp_, it will be typed
12:07:16 <Cale> Philippa: oh right, I was going to talk to you about the MR. What was the naive fix to the problem again, and why did it break?
12:07:27 <palomer> apply (Lam x  y) z = do{x <- writeSTRef  $ Just z; return $ Lam x y}
12:07:29 <tromp_> then translating to s & k is not a good choice:)
12:07:39 <tibbe> Philippa, palomer suggested that I should replace the ids in (Lam Id Expr) with STRefs
12:07:44 <Philippa> Cale: doesn't fix the "when do I default?" problem for things like read or the numeric constants
12:07:59 <palomer> oh no, I'm not suggesting you do that, but I think that in the end STRefs are a better choice
12:08:04 <Philippa> tibbe: ah
12:08:22 <Philippa> first of all, I absolutely *would not do that* in a source representation :-)
12:08:27 <Cale> hmm
12:08:37 <palomer> Philippa: would not do what?
12:08:47 <Philippa> use STRefs
12:08:53 <tibbe> Philippa, I will have refs in C-- of course
12:09:00 <Cale> there's defaulting for read?
12:09:03 <palomer> yeah, STRefs are for evaluation
12:09:14 <Philippa> Cale: no, and there probably shouldn't be either, but YKWIM
12:09:29 <Philippa> it's something for which in the absence of a defaulting mechanism it may never find out what you meant
12:09:31 <roconnor_> tibbe: Your evaluator is broken, I think
12:09:44 <roconnor_> > ((\f -> (\x -> f 5)) (\x -> x)) 7
12:09:46 <lambdabot> 5
12:09:50 <Cale> hmm
12:10:01 <roconnor_> *Main> App (App (Lam "f" (Lam "x" (App (Var "f") (Var "x")))) (Lam "x" (Var "x"))) (Con 7)
12:10:01 <roconnor_> (((\ f. (\ x. (f x))) (\ x. x)) 7)
12:10:01 <roconnor_> *Main> runReader (eval it) []
12:10:01 <roconnor_> 7
12:10:13 <tibbe> Philippa & palomer, so I'm going to write an interpreter and a compiler, the AST should be easy to work with in both cases and doesn't need to be fast in the interpreter
12:10:15 <roconnor_> oops
12:10:30 <roconnor_> ah
12:10:33 <palomer> tibbe: yeah, I heartily suggest you keep on your path
12:10:33 <roconnor_> my bad
12:10:38 * Cale looks at the translation again :)
12:10:42 <Philippa> tibbe: source+intermediate forms might be a good idea
12:10:46 <roconnor_> tibbe: please ignore me
12:10:59 <Philippa> that is, don't parse directly to a form with STRefs. If your intermediate form uses them, that's cool
12:11:30 <tibbe> Philippa, sounds like a good idea
12:11:45 <tibbe> roconnor_, did you find a bug?
12:11:51 <tromp_> no he didnt
12:12:21 <tromp_> he confused f 5 with f x :)
12:12:22 <roconnor_> tibbe: I was looking hard for an common named varible bug, but I mistyped something.
12:12:51 <tibbe> roconnor_, I think you won't get that since it has eager evaluation
12:13:07 <roconnor_> lisp has egar evalutaion, and it still has this bug
12:13:16 <roconnor_> *cough* I mean ``feature''
12:13:25 <tibbe> the dynamic scoping?
12:13:30 <roconnor_> yes
12:13:40 <tibbe> well, I'm certainly not going to have THAT!
12:13:47 <roconnor_> no
12:14:43 <tibbe> hmmm, representing a program with an inital environment [(Id, Expr)] of top level functions would work nicely right?
12:14:51 * palomer finds it impossible to think in terms of dynamic scoping
12:14:55 <Philippa> tibbe: yup
12:15:32 <tibbe> palomer, most lispers would probably say that you just don't get it ;) it a "hacker" thing...
12:20:05 <palomer> reasoning with free variables?
12:20:06 <palomer> ugh
12:33:30 <david> what has happened to the gtk2hs site?
12:42:21 <cinema> franka, is the code for UUXML available somewhere ?
12:44:43 <palomer> does space include eof?
12:45:01 <tromp> which space?
12:45:10 <Philippa> I don't think so
12:45:20 <tromp> eof is not a char
12:46:32 <palomer> hrmph
12:47:20 <palomer> I want my keywords to be followed by a space
12:47:37 <Philippa> you can always define a parser that's space <|> eof
12:47:45 <palomer> typechecker won't let me
12:47:55 <palomer>       Expected type: GenParser Char st Char
12:47:55 <Philippa> space returns something?
12:47:55 <palomer>       Inferred type: GenParser Char st ()
12:48:06 <Philippa> space >> return () <|> eof, then
12:48:14 <palomer> good point
12:48:21 <tromp> i think it's a bad idea to require keywords to be followed by space
12:48:33 <Philippa> I don't
12:48:42 <Philippa> I think it makes it clear they're not identifiers
12:49:05 <Philippa> (however: a paren or something similarly non-alphanumeric as the next char is also a good thing)
12:49:35 <tromp> they are by definition
12:49:50 <Philippa> no. They are things that *look* like identifiers
12:49:52 <tromp> followed by non-alpha that is
12:50:01 <Philippa> IYO :-)
12:50:05 <Philippa> (but yes
12:50:06 <Philippa> )
12:50:23 <palomer> ugh, type errors in parsec are a PITA to route out
12:50:32 <Philippa> to rephrase: I'm pretty sure there's at least one old language with a fuckwitted grammar that doesn't get that right
12:50:57 <Philippa> palomer: build your parser with lots of small, named ones. Comment them out as needed
12:51:02 <Philippa> finds type errors pretty quick
12:52:08 <palomer> omg, emacs adds a newline everytime you save a file
12:52:18 <Nanar> a carriage return in haskell is "\n" ?
12:52:25 <tromp> no
12:52:28 <tromp> that's a newline
12:52:42 <tromp> well, '\n' is
12:53:02 <tromp> '\r' is carriage return
12:53:30 <Nanar> hum
12:53:57 <Nanar> well newline I meant, thanks tromp 
12:59:14 <palomer> @hoogle [a] -> a -> Bool
12:59:15 <lambdabot> Data.List.elem :: Eq a => a -> [a] -> Bool
12:59:15 <lambdabot> Data.List.notElem :: Eq a => a -> [a] -> Bool
12:59:15 <lambdabot> Prelude.elem :: Eq a => a -> [a] -> Bool
12:59:38 <dcoutts> david, all of the haskell.org web site is being DOSed by a web crawler
12:59:44 <palomer> how do you fail in parsec?
13:00:16 <Nanar> dcoutts: ah that's why haskell.org is so slow
13:00:34 <Philippa> palomer: pzero is preferable
13:00:35 <palomer> oh, righto, found it
13:00:41 <palomer> Philippa: hmm?
13:00:45 <Philippa> at least, IIRC
13:01:11 <david> dcoutts, ouch..
13:01:41 * dcoutts restarts apache on haskell.org
13:01:53 <dcoutts> and we're back
13:01:55 <palomer> http://www.rafb.net/paste/results/xCis1T89.html <--/me is puzzled
13:01:59 <palomer> pzero is polymorphic, no?
13:02:16 <dcoutts> but eventually the web bot takes up all the 150 available connections
13:02:24 <musasabi> Has anyone got a lntree implementation in Haskell that works on both *nix (symlinks) and windows (copy) ?
13:02:55 <dcoutts> anyone know much about apache? we need to exclude the web bot from the wiki because it makes connections hang
13:03:30 <musasabi> dcoutts: robots.txt is not enough ?
13:03:56 <dcoutts> musasabi, well I added that, but probably the bot already looked once before beginning the scan
13:04:01 <palomer> nevermind:o
13:05:15 <musasabi> dcoutts: I would just block the block ip temporarily in iptables rather than playing around with apache. (if it is a bot we don't care about)
13:05:41 <dcoutts> hmm, maybe it has finished it's scan, I don't see it in the access logs now
13:07:32 <dcoutts> oh, no it is back
13:08:40 <Philippa> palomer: pzero's polymorphic so it can be a failing parser of any type
13:09:19 <Philippa> the error there's a classic "forgot to use return" one
13:09:29 <franka> cinema, The UUXML code may be in the UU CVS repository.
13:09:47 <franka> OTOH, when I looked at one point it had mysteriously disappeared.
13:10:49 <ADEpt> what's UUXML?
13:11:07 <ADEpt> is it perchance XML parser?
13:13:08 * ADEpt just googled it. from second try. why first failed? who knows....
13:13:44 <franka> UUXML is a Haskell-XML Schema data binding.
13:14:29 <franka> The code does not parse XML or XML Schema.
13:14:40 <franka> It uses a more abstract representation.
13:15:21 <ADEpt> eh. pity.
13:15:26 <dcoutts> musasabi, heh, excelent. I've modified the apache config to block the bad robot.
13:21:10 <cinema> franka, I am browsing the repository, but everything seems to be 2 years old. Is it normal ?
13:22:33 <franka> Yes, I haven't touched it in a long time.
13:22:58 <franka> It is not meant to be distributed.  It was only a proof-of-concept for the paper.
13:23:22 <franka> Frankly I don't think it would be of much use to you.
13:23:59 <cinema> franka, I read your paper and found it extremely interesting
13:24:17 <franka> I'm glad you liked it.
13:25:29 <cinema> I was wondering if that could be adpated to weaker generic forms, like SYB + GADT
13:26:27 <franka> I think it's possible; the translation would need to be tightened to make it practical.
13:27:15 <cinema> I'll look at the code I have grabbed
13:28:13 <franka> Good luck.  :) It was never meant for anybody but me to see.
13:29:17 <cinema> franka, I won't tell anybody about it, I swear
13:29:43 <franka> heh
13:39:38 <frobenius> somebody experienced in using darwinports with ghc?
13:41:00 <robdockins> frobenius: define "experienced" :)  (I'm currently using darwinports GHC)
13:45:30 <lambdabot> Haskell separates Church and State. (Alonzo Church, that is.)
13:49:52 <palomer> har har
13:59:01 <JKnecht> funny I thought it was functional fundamentalism :)
14:00:36 <palomer> how do I create a TextIter?
14:01:03 <palomer> in gtk2hs
14:01:07 * palomer pokes dcoutts 
14:01:10 <palomer> @hoogle TextIter
14:01:11 <lambdabot> No matches found
14:08:00 <palomer> hrm
14:08:04 <palomer> we should hook up hoogle to gtk2hs
14:08:06 <palomer> seriously:o
14:08:15 <palomer> I feel so lost without it
14:21:34 <palomer> anyone know where the mouse signals are?
14:22:01 <basti_> ?
14:23:24 <palomer> I want to set a handler for when the mouse gets over a particular piece of text in a textview
14:23:35 <palomer> but I see no way of catching such a signal
14:24:39 <basti_> uhm
14:24:46 <basti_> what kind of a lib displays your "textview"?
14:25:29 <palomer> lib?
14:25:41 <basti_> no?
14:25:46 <basti_> you mean like putStrLn? ;)
14:25:53 <palomer> http://www.rafb.net/paste/results/s9fTSE52.html <--here's my code
14:26:07 <palomer> textBufferInsertAtCursor textbuffer  "hello"
14:26:29 <basti_> ah
14:26:34 <basti_> so you're using Gtk
14:26:55 <basti_> there is set-callback-functions like onDestroy onResize etc.
14:27:07 <basti_> at least one of them reacts to mouse events
14:29:36 <palomer> where are they?
14:31:05 <basti_> uhm
14:31:12 <basti_> ...Gtk.Widget or something
14:31:18 <palomer> not there:(
14:31:42 <basti_> wait
14:31:46 <palomer> (I wish!)
14:31:59 <basti_> Graphics.UI.Gtk.Abstract.Widget
14:32:09 <basti_> onMotionNotify etc.
14:32:15 <basti_> patience is a virtue.
14:32:37 <palomer> ahhh!
14:32:42 <palomer> I can't believe I missed that one
14:32:50 <palomer> they should call it onMouseMotionNotify
14:32:55 <basti_> i can, actually
14:33:06 <basti_> ^^
14:35:55 <palomer> but that only creates a message when my mouse goes over a widget
14:36:18 <basti_> what are you looking for?
14:36:25 <palomer> well, I'll have text in my buffer
14:36:42 <palomer> and I want it to display something every a word if my cursor is over that word
14:36:51 <palomer> s/every a word/over my cursor
14:36:59 <basti_> you mean a tooltip?
14:37:15 <basti_> http://haskell.org/gtk2hs/docs/gtk2hs-docs-0.9.10/Graphics-UI-Gtk-Misc-Tooltips.html
14:37:46 <palomer> yeah, but that's per widget, no?
14:38:20 <basti_> yea
14:38:23 <basti_> so? ^^
14:38:24 <palomer> (as opposed to per character)
14:38:43 <basti_> you're inviting evil demons at the moment.
14:38:55 <palomer> so I have to turn my string into a tree of widgets?
14:39:10 <basti_> i don't say this is the only way
14:39:20 <basti_> I just say "invariance of difficulties"
14:40:25 <palomer> so how do I compose widgets so they look like text?
14:40:37 <palomer> like, "so far" is going to be two widgets
14:40:40 <basti_> what did I say about inviting evil demons? ;)
14:40:46 <basti_> did you think about an alternative solution?
14:41:04 <palomer> to what?
14:41:29 <basti_> to displaying a tooltip for every letter
14:41:40 <basti_> which does not appear to be practical to me
14:41:42 <palomer> well, it'll actually be over every lexical token
14:41:49 <basti_> i see
14:41:56 <palomer> actually, I have an AST
14:42:03 <palomer> and to every node of the AST I've attached a range
14:42:06 <basti_> you definitely should render these as widgets.
14:42:14 <basti_> you might recode half of gtk's anus to do so.
14:42:18 <basti_> might have to
14:42:37 <palomer> is there a widget that acts like a piece of text and is composable?
14:43:06 <basti_> not to my knowledge
14:43:22 <basti_> as i said, you might have to recode half of gtk's anus
14:43:28 <basti_> maybe you can find a tricky way around
14:43:34 <palomer> oh my, and this seemed simple enough!
14:43:49 <basti_> like, making the tooltip depend on position in the widget
14:44:00 <basti_> then getting a function position -> AST
14:44:10 <basti_> and then making the tooltip depend on the AST instead
14:44:42 <palomer> but if you move around in a widget, the tooltip doesn't change
14:44:47 <palomer> right?
14:44:51 <basti_> not at the moment no
14:44:54 <basti_> but maybe you can make it
14:45:17 <basti_> you could set it right before it is displayed
14:46:25 <palomer> set what?
14:46:27 <palomer> the tooltip?
14:46:35 <basti_> yes
14:46:49 <palomer> err, the tip?
14:46:59 <basti_> hmm?
14:47:10 <palomer> you want the tip to change right before it is displayed?
14:47:39 <basti_> yes
14:48:02 <palomer> but I want the tip to change while I'm moving around in the widget
14:48:17 <basti_> well, maybe it gets hidden at some point
14:48:30 <basti_> maybe people adopt to the conditions, and will make it hide when they need it to change
14:49:27 <palomer> but the whole point of my application are these tips, really
14:49:47 <palomer> and it wouldn't be fun for the user if he had to spend most of his time waiting for the tip to disappear
14:50:34 <basti_> I won't stop you from reinventing the weel
14:50:35 <basti_> wheel
14:50:45 <basti_> you'll have to search for somebody else to do that
14:51:14 <palomer> if only onMotion called its event every time the mouse moved
14:51:23 <palomer> isn't there a signal like that?
14:51:53 <basti_> ?
14:51:57 <basti_> what are you asking?
14:52:25 <palomer> I want to call a function every time the mouse moves
14:52:29 <palomer> inside a widget
14:52:37 <basti_> yes, thats what onMotion does.
14:52:42 <basti_> thats why its called onMotion
14:52:43 <palomer> it doesn't!
14:52:52 <basti_> it sets a callback, that is called every time the mouse is moved
14:52:58 <palomer> nope
14:53:02 <palomer> not in my code anyways
14:53:21 <basti_> "If hint is False, a callback for every movement of the mouse is generated."
14:53:29 <basti_> well... what does that tell us?
14:53:31 <palomer> well then there's a bug
14:53:46 <basti_> or maybe you did something wrong?
14:53:47 <basti_> :D
14:54:00 <palomer> http://www.rafb.net/paste/results/GxsUWL40.html
14:54:01 <palomer> try it out
14:54:12 <basti_> care is a virtue, too.
14:54:29 <ADEpt> @where HaXml
14:54:30 <lambdabot> http://haskell.org/HaXml
14:54:32 <palomer> care?
14:54:39 <basti_> like, caring about stuff
14:54:39 <basti_> wait
14:55:43 <basti_> palomer: http://pastebin.com/527988
14:55:49 <basti_> thats what appeared on my screen
14:56:03 <palomer> yeah
14:56:09 <palomer> now press enter a few times after the hello
14:56:13 <palomer> the textview will get bigger
14:56:18 <palomer> now move your mouse inside the textview
14:56:39 <basti_> so?
14:56:59 <palomer> well, I want it to do something every time the mouse moves
14:57:25 <basti_> yes i see the problem
14:57:40 <basti_> now we take a look at the documentation
14:57:52 <basti_> like, the third line after the description of said function
14:58:00 <basti_> "The application now has to state that it is ready for the next message by calling drawWindowGetPointer."
14:59:52 <palomer> check this out: if I attach the signal to window, and I move around in the space between the textview and the border, hello is printed every time I move the mouse
14:59:55 <palomer> but not in the textview
15:00:02 <palomer> are there any other widgets for displaying text?
15:00:06 <palomer> (but not editing!)
15:00:28 <basti_> probably the textview catches the events
15:01:36 <basti_> try marking some of the typed text
15:01:48 <palomer> basti_: marking?
15:02:21 <basti_> like, holding the button and dragging it
15:02:55 <palomer> if I click then move, hello is printed
15:03:54 <palomer> if I select text, and then drag it, hello is printed on every movement
15:03:59 <palomer> s/movement/motion
15:04:12 <basti_> http://pastebin.com/527994 < this reacts to drag motion for me
15:04:39 <palomer> yeah, drag is given
15:04:50 <palomer> you didn't change anything!
15:04:58 <basti_> i just rearranged it some
15:05:03 <basti_> i wasnt entirely sure if.
15:05:12 <basti_> i'm trying to avoid stupid mistakes, you know?
15:05:15 <palomer> yeah
15:06:29 <basti_> btw i DID change something, i'm returning "false"
15:06:33 <basti_> (not catching the event)
15:06:48 <palomer> oh, righto
15:07:03 <palomer> if you press alt and then move, it prints hello once
15:07:07 <basti_> which now gives a pretty sane response
15:07:32 <basti_> except for drag without click
15:07:54 <palomer> basti_: I see no difference between returning True and returning False
15:08:10 <basti_> palomer: i do.
15:08:20 <palomer> for example?
15:08:59 <basti_> with False, the thing reacts to dragging (moving with pressed button), and not to motion (without pressed button)
15:09:20 <basti_> with True, marking text (by dragging) doesnt work and doesn't trigger the callback, and motion is the same
15:10:36 <palomer> dragging the text or marking?
15:10:42 <palomer> dragging gives me the same result (lots hellos"
15:10:43 <basti_> marking by dragging
15:10:58 <palomer> you drag after you mark
15:11:24 <basti_> dragging means to click, and then to move the mouse
15:11:37 <basti_> I'm not referring to some higher order functionality that might be implemented by that
15:12:11 <palomer> ok, dragging only gives me 1 hello
15:12:14 <palomer> with False
15:12:23 <basti_> with false where?
15:12:31 <basti_> returned from callback or as the "hint" parameter?
15:12:41 <palomer> both
15:12:56 <palomer> oh, you changed it to true
15:13:42 <palomer> hint=True,callback=False
15:13:47 <palomer> only 1 hello on drag
15:14:00 <basti_> with me, it gives many
15:14:06 <basti_> but still, this is absolutely uninteresting
15:14:12 <basti_> because it doesn't do what you're looking for
15:14:14 <palomer> however, when I move outside the textview, I get only 1 hello now
15:14:18 <palomer> yeah
15:14:34 <basti_> i think this is related to textview's event processing
15:14:42 <basti_> best you ask some gtk2hs developer
15:14:54 <basti_> no, best you try yourself a little, and then, when you're damn sure, then you ask a dev
15:15:14 <palomer> are there any other widgets for text?
15:15:18 <palomer> I don't need it to be editable
15:16:20 <basti_> probably
15:16:25 <basti_> i doubt they do what you need
15:18:00 <palomer> do you think that I could retrieve the cursor position even if I could get the onmotion not to be caught?
15:18:48 <basti_> well, probably there is some other way
15:19:23 <basti_> like drawWindowGetPointer
15:19:51 <basti_> will suck, though
15:21:24 <palomer> oh my that sounds evil
15:22:28 <basti_> maybe you can trick around a bit
15:22:36 <basti_> like, putting a transparent widget over the textentry
15:22:40 <basti_> and catch the events there
15:22:48 <basti_> preventing them from ever reaching the text thingy
15:23:02 <palomer> you can put widgets over other widgets?
15:23:04 <palomer> that would rock
15:23:09 <basti_> i think you can
15:23:21 <basti_> it sucks a little, but not as much as the thing with drawWindowGetPointer
15:23:54 <palomer> yeah, I don't mind putting widgets over other widgets
15:25:31 <palomer> I could probably get the widget to catch the event, and then spit it out with some extra tagging information
15:26:22 <palomer> then, I can draw a widget right over my cursor
15:26:30 <palomer> wait, can you simply draw widgets wherever you want:O?
15:26:37 <palomer> whenever you want
15:26:43 <basti_> effectively, i think so yes.
15:26:53 <basti_> it is just plain ugly
15:28:05 <palomer> isn't that what tooltip does? (basically)
15:28:56 <basti_> yes
15:29:02 <basti_> but it's hidden
15:29:05 <basti_> hidden things never hurt
15:29:21 <palomer> :P
15:29:27 <basti_> for example, if you have a hidden rattlesnake
15:29:33 <basti_> for it to hurt you, it'd have to appear first
15:29:37 <basti_> then it wouldnt be hidden anymore
15:30:08 <palomer> though onMotion on a TextView would solve all my problems
15:30:22 <palomer> given I can figure out the cursor position
15:30:22 <basti_> ask a dev ^^
15:30:27 <basti_> yes you can
15:30:40 <palomer> I can what?
15:31:06 <palomer> the cursor position associated with the mouse position
15:31:09 <palomer> textview cursor
15:31:17 <palomer> the blinking vertical line
15:31:47 <basti_> oh
15:31:51 <basti_> i don't know about that
15:46:31 <ihope> Hmm, edible Haskell code?
15:48:57 <palomer> if only
15:49:05 <palomer> @soon dcoutts_ 
15:49:06 <lambdabot> Maybe you meant: join seen
15:49:08 <palomer> @seen dcoutts_ 
15:49:09 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell-blah and #haskell. Last spoke 3
15:49:09 <lambdabot> days, 3 hours, 43 minutes and 56 seconds ago.
15:49:17 <palomer> @seen dcoutts 
15:49:18 <lambdabot> I saw dcoutts leaving #gentoo-haskell, #haskell-blah and #haskell 41
15:49:18 <lambdabot> minutes and 15 seconds ago.
15:49:34 <palomer> dcoutts_: you around?
15:51:21 <ihope> @help join
15:51:21 <lambdabot> join <channel>
15:51:38 <ihope> ...Wait, does that send lambdabot over there?
15:52:26 <palomer> @join #lojban
15:52:27 <lambdabot> Not enough privileges
15:52:34 <palomer> I guess so
15:55:01 <ihope> @join dcoutts_
15:55:02 <lambdabot> Not enough privileges
15:55:15 <ihope> @. join arr
15:55:16 <lambdabot> compose module failed: Privledged commands cannot be composed
15:55:21 <ihope> Aww.
16:20:48 <ihope> @arr
16:20:49 <lambdabot> quote module failed: getRandItem: empty list
16:21:00 <ihope> Burble bumble fix bibble?
16:24:45 <astrolabe> How do I set the source line in Parsec?
16:31:11 <robdocki1s> setPosition?
16:32:25 <robdocki1s> @hoogle setPosition
16:32:26 <lambdabot> Text.ParserCombinators.Parsec.Prim.setPosition :: SourcePos -> GenParser
16:32:26 <lambdabot> tok st ()
16:42:36 <astrolabe> thanks
16:42:51 <athomason> Is this a good place to inquire about errors building hugs?
16:48:06 <robdocki1s> athomason: should be -- unfortunately I'm not familiar with hugs myself
16:48:27 <vincenz> re
16:49:14 <athomason> I'll throw it out there then: the build completes, but the prelude isn't ever installed
16:49:29 <athomason> and along the way I get a bunch of ERROR "libraries/bootlib/Data/HashTable.hs" - Can't find imported module "Control.Monad"
16:55:03 <dcoutts> palomer, yarr!
16:55:39 <dcoutts> TextIter eh?
16:56:20 <dcoutts> http://haskell.org/gtk2hs/docs/current/Graphics-UI-Gtk-Multiline-TextBuffer.html
16:56:45 <dcoutts> there are lots of ops which give you TextIters or take TextIters
17:31:42 <vincenz> hmm
17:31:46 <vincenz> hopengl is not ini ghc
17:31:57 <vincenz> and hopengl requires greencard (which is apparently using old haskell)
17:32:00 <vincenz> suggestions?
17:32:25 <Cale> um, it should come with ghc
17:32:44 <Cale> the separate package on the website is outdated
17:32:59 <vincenz> I tried compiling something
17:33:02 <Cale> which distribution?
17:33:08 <vincenz> and it complaine about lackking Graphics.UI.GLUT
17:33:16 <vincenz> Could not find module `Graphics.UI.GLUT':
17:33:22 <vincenz> while compiling "frag"
17:33:27 <Cale> debian?
17:33:28 <vincenz> http://haskell.org/hawiki/Frag
17:33:31 <vincenz> ubuntu
17:33:34 <Cale> okay
17:33:47 <Cale> let me have a look -- it could be separated into an extra package
17:33:50 <vincenz> thx
17:34:06 <vincenz> ah indeed
17:34:12 <vincenz> ;)
17:34:19 <vincenz> got it
17:34:20 <Cale> okay, cool
17:34:31 <vincenz> let's try this againi
17:34:47 <vincenz> woo
17:34:52 <Cale> cool
17:35:13 <vincenz> thx
17:36:04 <Cale> @seen lennart
17:36:05 <lambdabot> lennart is in #haskell. Last spoke 19 hours, 38 minutes and 23 seconds
17:36:05 <lambdabot> ago.
17:38:06 <vincenz> /usr/bin/ld: cannot find -lSM
17:42:01 <ihope> Spanish quit message?
17:42:11 <Korollary> why not
17:42:44 <ihope> Because the only word I understood there is "andando"...
17:43:11 <ihope> ..."Sto" isn't a Spanish word, is it?
17:43:35 <ihope> Here's an ad to buy STO on eBay, though.
17:43:49 <astrolabe> @babel sp en Sto andando via
17:43:50 <lambdabot> babel module failed: Error: Language sp not supported
17:44:01 <astrolabe> @babel es en Sto andando via
17:44:03 <lambdabot>  Sto walking via
17:44:12 <astrolabe> hmm
17:44:23 <astrolabe> via = road?
17:44:53 <astrolabe> @babel it en Sto andando via
17:44:55 <lambdabot>  I am going via
17:44:56 <ihope> Hmm, incompatible character sets.
17:45:07 <ihope> Aha!
17:45:17 <ihope> This says "m?nada".
17:46:29 <ihope> Now it's fixed. "mÛnada", which may or may not appear correctly.
17:50:45 <ihope> Now is this correct or not?
17:50:49 <ihope> "°MÛnadas son provechosas!"
17:51:06 <ihope> ...Maybe not.
17:52:23 <ihope> "⁄tiles"?
17:54:16 <araujo> Si ihope 
17:56:43 <ihope> Now, I'm too lazy to scrape together all the special characters in Spanish.
17:57:38 <Cale> ihope: hm?
17:58:01 <ihope> Upside-down punctuation, acute accents, tildes.
17:58:49 <Cale> what do you mean by scraping it together?
18:00:05 <Cale> √Å√°√â√©√ç√≠√ë√±√ì√≥√ö√∫√ú√º¬°¬ø
18:00:06 <ihope> Going to some website and copying it in order to paste here.
18:00:15 <Cale> I can just type them :)
18:00:23 <ihope> Heh, cool...
18:00:38 <ihope> That's one of the reasons I love Macintosh.
18:00:51 <ihope> But this *isn't* a Macintosh.
18:00:52 <Cale> I rebound caps-lock to compose in X
18:01:05 <Cale> (I'm running Debian)
18:01:19 <ihope> Cool.
18:02:43 <vincenz> hmm
18:02:57 <vincenz> how do I test if opengl is running via hardware or software
18:03:03 <vincenz> it seems this app runs via software 
18:03:12 <Cale> glxinfo
18:03:23 <Cale> glxinfo | grep "direct"
18:03:37 <vincenz> heh, direct rendering no
18:03:38 <vincenz> :/
18:03:56 <Cale> that would be your problem
18:04:36 <vincenz> yeah
18:04:38 <vincenz> :D
18:04:41 <vincenz> but ubuntu is great
18:04:44 <vincenz> I never have issues wiith packages
18:04:51 <vincenz> not like debian where you ahd to manually iinstall half the stuff
18:05:04 <vincenz> do I reboot?
18:05:04 <Cale> hm?
18:05:11 <Cale> you need to install a driver for your video card
18:05:20 <Cale> what kind of video card do you have?
18:06:07 <Cale> usually this involves installing a kernel module, and an X driver.
18:06:42 <Cale> both of which you obtain from your chipset manufacturer (NVidia or ATi usually :)
18:07:09 <vincenz> nvidia
18:07:17 <vincenz> but apprently, newer than I thought
18:07:44 <Cale> ah, they have a nice installer
18:08:01 <Cale> http://www.nvidia.com/object/unix.html
18:09:29 <vincenz>  crap, apprently not an nvidia
18:09:45 <vincenz> it's a laptop (dell)
18:10:08 <Cale> cat /proc/pci
18:10:20 <Cale> and look to see if something recognisable shows up
18:10:21 <vincenz> no proc/pci
18:10:28 <Cale> hmm
18:10:44 <Cale> okay, I have no experience with laptops whatsoever :)
18:10:54 <vincenz> it's reasonably new
18:11:34 <vincenz> lspci
18:11:45 <Cale> yeah, that also might help :)
18:12:39 <vincenz> GA compatible controller: ATI Technologies Inc: Unknown device 5460
18:12:46 <Cale> ah, okay
18:12:49 <vincenz> I didn't upgrade my video card optioin when ordering my laptop :B
18:13:09 <vincenz> 2aha got it
18:13:10 <vincenz> X300
18:13:12 <vincenz> now I remember :D
18:13:30 <Cale> that is pretty new
18:14:39 <vincenz> really?
18:15:24 <vincenz> heh, someone tells meo n ubuntu that d610 (my laptop) is a business laptop (which is true, but I love it) and says that opengl might not work :
18:15:28 <vincenz> let's see if I can prove them wrong
18:15:47 <Cale> oh, I suppose they have progressed quite a way since then too
18:16:23 <Cale> oh, it'll certainly work
18:16:56 <Cale> the X300 is newer than the Radeon 9800, which I can play Doom 3 on just fine.
18:17:35 <Cale> I'm not sure what the mobile versions are like, but I'd think they'd be comparable
18:18:51 <Cale> ati's driver install is horrible
18:19:03 <vincenz> timee for a reboo
18:19:09 <Cale> read carefully, you have to compile and install a kernel module
18:19:10 <vincenz> bbl
18:19:17 <vincenz> https://wiki.ubuntu.com/BinaryDriverHowto/ATI
18:19:19 <Cale> shouldn't need to do a full reboot
18:19:23 <vincenz> ubuntu is much nicer than debian
18:19:25 <vincenz> Cale: it says full reboot
18:19:29 <vincenz> bbl
18:19:29 <Cale> hmm
18:19:43 <Cale> oh, okay
18:19:53 <Cale> they have ubuntu packages
18:21:10 <ihope> @. djinn arr
18:21:11 <lambdabot> compose module failed: getRandItem: empty list
18:21:16 <ihope> Waah...
18:21:27 <Cale> all the quote module stuff is broken today
18:23:28 <vincenz> Cale: I think reason for reboot is the change of kernel to 686
18:23:40 <Cale> ah, that would do it
18:23:56 <Cale> normally, it just involves a module being installed
18:24:06 <vincenz> yeah
18:24:08 <vincenz> so x300 is a good card?
18:24:34 <vincenz> ubuntu is great tho, debian is a lot of manual hackery to get stuff going
18:24:36 <Cale> I've never bothered to look if there are debian packages for ATi, but the stuff that ATi provides is pretty awful if you're not used to it
18:24:45 <Cale> You found that?
18:24:51 <vincenz> yeah
18:24:56 <Cale> I haven't done much manual hacking to my machine in years
18:24:58 <vincenz> my desktop is debian
18:25:08 <vincenz> every time I installed a new x, I had to reinstall my nvidia driver
18:25:10 <vincenz> which was a big mes
18:25:26 <Cale> nvidia-installer makes it pretty easy
18:26:11 <vincenz> true but still
18:26:21 <vincenz> I honestly think ubuntu is a even easier
18:26:34 <vincenz> let's try frag again :)
18:27:14 <vincenz> holy crap
18:27:16 <vincenz> nearly too fast
18:29:04 <vincenz> oh well
18:29:06 <vincenz> that was fun
18:29:31 <ihope> So big 1 is the doubling function.
18:29:54 <ihope> That means big 2 is \x -> x * 2^x
18:30:10 <ihope> At least, the equivalent that works on integers and all that.
18:34:07 <Cale> big 1 ?
18:34:23 <ihope> big 0 x = x+1
18:34:36 <ihope> big y x = compose x (big (y-1)) x
18:34:55 * ihope needs to get his variable names straightened out
18:35:04 <ihope> compose 0 _ p = p
18:35:16 <ihope> compose n f p = f (compose (n-1) f p)
18:35:31 <ihope> I just realized...
18:35:42 <ihope> compose n f p = fcompose (n-1) f (f p)
18:35:56 <ihope> s/fcompose/f compose/
18:49:41 <vincenz> there's an easier way
18:49:43 <vincenz> ihope: ping
18:49:48 <vincenz> damn, he left
18:50:05 <vincenz> compose n f p = (iterate f p) ! n
18:50:08 <vincenz> compose n f p = (iterate f p) !! n
18:50:16 <vincenz> Cale: correct?
18:50:43 <Cale> yep
18:51:15 <vincenz> \o
18:51:24 * vincenz wants something fun to code on to improve his haskell skills
18:54:20 <jethr0_> vincenz: have you tried a raytracer. that's really easy and fun with haskell!
18:54:28 <vincenz> jethr0_: hehe
18:54:34 <jethr0_> see also the hray TMR article
18:54:42 <vincenz> jethr0_: there's yours, hray (Boeml)..
18:54:54 <vincenz> is the world ready for another?
18:55:04 <vincenz> jethr0_: you are learning haskell?
18:55:11 <jethr0_> vincenz: i didn't say you'd enrich the community. but it's a nice project
18:55:15 <jethr0_> vincenz: yes
18:57:24 <jethr0_> but i've got a whole lot of learning still in front of me (like monad transformers, ...)
18:57:24 <vincenz> jethr0_: feel like tackling a past icfp contest together?
18:57:39 <vincenz> like the 2005 one
18:57:42 <vincenz> it's easy on libs
18:57:50 <vincenz> all it requires is stdin/stdout for interfacing
18:58:03 <jethr0_> vincenz: although i keep cheating myself, i don't have too much time at hands. but i guess i could fit a dozen hours in there somehow :)
18:58:16 <jethr0_> vincenz: is that the robbers?
18:58:20 <vincenz> yea
18:58:57 <jethr0_> vincenz: i thought about competing, but was a bit overwhelmed. don't remember by what exactly. yes, why not do it :)
18:59:07 <jethr0_> @localtime vinzenz
18:59:17 <jethr0_> vincenz: what's the time at your end?
18:59:20 <vincenz> 3:58am
18:59:29 <vincenz> @localtime jethr0_ 
18:59:33 <lambdabot> Local time for jethr0_ is Sun Jan 29 03:59:08 2006
18:59:40 <vincenz> @localtime vincenz is gmt
18:59:41 <jethr0_> me too :). just checking for compatible times *ggg*
18:59:44 <lambdabot> Local time for vincenz is Sun Jan 29 03:59:19 2006
18:59:54 <vincenz> perfect
19:00:01 <vincenz> jethr0_: what do you do
19:00:08 <jethr0_> professionally?
19:00:13 <vincenz> yeah
19:00:28 <vincenz> btw does trac work with darcs?
19:00:35 <vincenz> or is there something similar to trac for darcs?
19:00:36 <jethr0_> i'm a CS student, and i've got only one oral exam left. and afterwords it's the grim reality of life :)
19:00:46 <jethr0_> so i keep postponing the exam...
19:00:56 <jethr0_> vincenz: where're you from? i'm from germany.
19:01:04 <vincenz> belgium
19:01:19 <jethr0_> i don't even know what trac does. but everyone seems to be using it with darcs
19:02:45 <vincenz> jethr0_: it's a source browser/wiki/issue tracker
19:02:48 <vincenz> via http
19:03:04 <jethr0_> vincenz: would you start modelling the world first, or do you have any ideas how to tackle the "AI"?
19:04:14 <jethr0_> i guess one could model the world, create some "AI"s and then choose the best one in fair competition :)
19:04:27 <jethr0_> vincenz: sure, let's do it!
19:04:34 <vincenz> jethr0_: start by downloading the bdk
19:04:40 <vincenz> and see if you can get the gui to run
19:04:51 <vincenz> let me look it up
19:05:04 <jethr0_> got the url
19:05:06 <vincenz> http://icfpc.plt-scheme.org/
19:05:18 <vincenz> want to do the original one or the twist/
19:05:32 <vincenz> it's a shame none of the sources were given for that year so you can't look at how you compete with the winners :/
19:05:51 <jethr0_> hmm, i haven't read the twist yet. but if we do the original, we can see how well we'd incorporate the twist. unless you already know it by heart...
19:06:07 <jethr0_> vincenz: maybe some of the haskell teams are in here from time to time
19:06:22 <vincenz> true
19:06:34 <vincenz> jethr0: I'd start with original one, seems simpler :D
19:08:25 <jethr0> how should we do the collaboration? and what time do you normally "work" at? it's getting kinda late even for me, although i'm flexible on that :)
19:09:21 <vincenz> jethr0: we could have a darcs somewhere
19:09:23 <vincenz> and irc
19:09:49 <vincenz> what port does darcs use for connectiing?
19:09:52 <jethr0> vincenz: do you have a place to host some small files? i've only got my flatrate pc, which is on 24/7, but it might be rather slow at times
19:10:05 <vincenz> I could use my desktop
19:10:09 <vincenz> I did that for past icfps
19:10:21 <jethr0> vincenz: i've never used it directly. i'm not sure it even supports that. maybe with an addon, or sth
19:10:21 <vincenz> tho I'd have to know the port spec of darcs cause I use a firewall
19:10:43 <jethr0> i've only used darcs with email patches...
19:10:50 <vincenz> oh
19:10:51 <vincenz> hmm
19:10:53 <vincenz> Cale: ping
19:11:49 <Cale> hello
19:12:04 <vincenz> hiya
19:12:10 <vincenz> Cale: how do I host a darcs repo?
19:12:21 <Cale> you start a webserver and make it available there
19:12:30 <vincenz> Cale: just plain files?
19:12:32 <Cale> yep
19:12:39 * vincenz has a webserver but it serves trac
19:12:56 <Cale> just copy the directory to /var/www or whatever
19:13:06 <Cale> (or symlink it)
19:13:12 <vincenz> alright
19:13:46 <jethr0> Cale: is there a way to directly commit patches to a darcs repo? (instead of mail?)
19:14:54 <jethr0> vincenz: i can host this. i'll just disable my mldonkey and i should have 16kb upload
19:14:57 <Cale> not that I'm aware of
19:15:02 <jethr0> hmm
19:15:26 <Cale> you can give people ssh accounts
19:15:41 <jethr0> sure
19:16:08 <vincenz> jethr0: ah, I have cable, also 16kb
19:16:11 <vincenz> (upload)
19:16:16 <vincenz> but that ain't so bad for source
19:16:20 <jethr0> yup
19:16:44 <vincenz> my place or yours?
19:16:47 <jethr0> hehe
19:16:56 <jethr0> i guess i can set sth up.
19:18:35 <vincenz> Cale: is it possible to give people only access to part of a darcs repo... I mean I see you can do trac+darcs, however if you have several projects...you'd have to put them all in one darcs repo
19:19:21 <Cale> I have no experience with trac + darcs, but you should use groups on your machine to give accounts access to specific files
19:19:29 <Cale> s/should/could/
19:20:28 <vincenz> Cale: yeah but the darcs repo part bit is one folder in the root of your project
19:20:43 <vincenz> it's not tree based ala svn
19:24:32 <user317> is anyone familiar with haskore?
19:27:20 * araujo back form dinner
19:27:26 <araujo> @where haskore
19:27:27 <lambdabot> http://cvs.haskell.org/darcs/haskore/
19:27:35 <Cale> ... and haskell.org was switched to WikiMedia, and a million tiny links cried out and were broken.
19:27:56 <Cale> including all my bookmarks into the Report
19:28:13 <araujo> Cale, Fix!
19:28:13 <Cale> I had to remove the 'www' from them for some reason
19:28:21 * araujo thinks it is cool
19:36:53 <user317> i already know where it is :)
19:37:08 <vincenz> blegh
19:37:10 <vincenz> I hate debian
19:37:50 <Cale> vincenz: why?
19:37:56 <Cale> what's wrong?
19:38:24 <jethr0> vincenz: i love it. but sometimes you gotta study the docu a little longer :)
19:38:35 <jethr0> like, for setting up a chrooted ssh account *dumdidum*
19:38:51 <Cale> I like debian quite a lot. I hardly ever have to think about what's going on :)
19:39:01 <Cale> setting up chroots is always a pain
19:39:16 <Cale> There are a few half-baked tools out there for it
19:39:24 <jethr0> i know
19:39:35 <Cale> but I know of nothing which is even remotely as sophisticated as you'd want
19:42:44 <vincenz> Cale: software is WAY old
19:43:07 <vincenz> Cale: for instance subversion is a majorly old version
19:43:10 * vincenz prefers ubuntu
19:43:16 <vincenz> I'm gonna dump ubuntu on my desktop
19:43:25 <vincenz> and I'm currently porting my svn repos to darcs :)
19:43:28 <Cale> um, which debian?
19:43:29 <vincenz> so I can just put em on my lappy
19:43:33 <vincenz> Cale: not sure
19:43:35 <Cale> you should run unstable or testing
19:43:46 <Cale> stable is really only for servers
19:43:54 <vincenz> Cale: how do I tell?
19:44:19 <Cale> /etc/apt/sources.list
19:44:27 <Cale> deb http://http.us.debian.org/debian unstable main contrib non-free
19:44:34 <jethr0> cale, always quicker than me :)
19:44:36 <Cale> is what you'll see if you're running unstable
19:44:51 <vincenz> stable :/
19:44:54 <Cale> if you're running something else, you can just edit that line
19:45:08 <vincenz> deb http://ftp.belnet.be/debian/ stable main contrib non-free
19:45:09 <vincenz> deb-src http://ftp.belnet.be/debian/ stable main contrib non-free
19:45:13 <vincenz> deb http://security.debian.org/ stable/updates main
19:45:13 <vincenz> deb ftp://ftp.nerim.net/debian-marillat/ sarge main
19:45:17 <Cale> unstable occasionally lets bugs through, testing is more stable
19:45:26 <Cale> (but about a week's lag from unstable)
19:45:38 <Cale> and stable is updated once every couple of years
19:45:47 <vincenz> so just change those lines to unstable and voila?
19:45:56 <Cale> yeah
19:46:04 <vincenz> coolies
19:46:18 <Cale> er, I'm not sure whether there is a separate security branch for unstable
19:46:27 <Cale> since it gets updated fast anyway
19:49:38 <jethr0> Cale: no, only stable has security updates. but testing and unstable are supposed to track security updates themselves. doesn't always work :)
19:50:09 <jethr0> ls
19:50:31 <Cale> sudo rm -rf /
19:50:40 <Cale> oh, good thing I typed that here ;)
19:52:02 <vincenz> hehe
19:52:51 <jethr0> ha ha
19:53:14 <jethr0> mysupersecretpassword
19:53:17 <jethr0> *d'oh*
19:54:40 * vincenz loves his lappy
20:12:33 <vincenz> jethr0: ping
20:12:42 <jethr0> pong, still doing some debian stuff.
20:13:02 <jethr0> i'd love to do this icfp thing with you. but i'll have to go to bed sometime.
20:13:24 <jethr0> i'll read through the problem description, make some notes and maybe sketch some haskell ideas about them
20:13:37 <jethr0> should we "meet" tomorrow sometime?
20:14:06 <vincenz> okies
20:14:17 <jethr0> what time? after 14h ok?
20:14:21 <vincenz> yeah prolly ;)
20:14:52 <jethr0> i can't promise anything, but i'll definitely be in the channel after 3pm or so
20:15:32 <vincenz> okies
20:17:07 <vincenz> Cale: so as for darcs via webserver...
20:17:11 <vincenz> Cale: how does that work with perms?
20:17:28 <Speck> which are the haskell gui libraries that use AFRP (Yampa)? Fruit is one, are there others?
20:17:43 <Cale> you have to give the webserver read permissions to the _darcs directory trees.
20:19:36 <vincenz> Cale: but a perproject if I simlink my projects to different urls
20:20:05 <Cale> hm?
20:21:27 <vincenz> like I want to be able to get project http://xxx/a/b and http://xxx/a/a but I want users only to get /a/a and not /a/b
20:22:41 <vincenz> @hoogle Signal
20:22:42 <lambdabot> Control.Concurrent.QSem.signalQSem :: QSem -> IO ()
20:22:42 <lambdabot> Control.Concurrent.QSemN.signalQSemN :: QSemN -> Int -> IO ()
20:22:42 <lambdabot> System.Console.Readline.setSignals :: IO ()
20:22:44 <vincenz> @hoogle Time
20:22:45 <lambdabot> Graphics.HGL.Units.Time :: Integer
20:22:45 <lambdabot> System.Locale.TimeLocale :: TimeLocale
20:22:45 <lambdabot> System.Locale.TimeLocale :: ([(String, String)] -> [(String, String)] -> [
20:22:46 <lambdabot> (String, String)] -> String, String -> String -> String -> String ->
20:22:48 <lambdabot> String -> TimeLocale)
20:29:17 <Beelsebob> > "> 2 + 2"
20:29:18 <lambdabot> "> 2 + 2"
20:29:22 <Beelsebob> damn
20:29:47 <Beelsebob> > print "> (2 + 2)"
20:29:48 <lambdabot> No IO allowed
20:29:52 <Beelsebob> damn you
20:29:52 <luqui> what are the new features of 6.4.1 over 6.4.0?
20:30:04 <Cale> > error (error "> (2+2)")
20:30:05 <lambdabot> Add a type signature
20:30:08 <Cale> > error (error "> (2+2)") :: Int
20:30:09 <lambdabot> Exception: > (2+2)
20:30:26 <Cale> hmm
20:30:31 <Cale> has that been fixed? :)
20:30:39 <Beelsebob> damn... was trying to get lambdabot to recurse
20:30:44 <luqui> was it a bugfix release, or are there any new language features?
20:31:30 <Beelsebob> > (> 2)
20:31:31 <lambdabot>  add an instance declaration for (Show (a -> Bool))
20:31:39 <Beelsebob> bah
20:31:54 <jethr0> Beelsebob: it ignores messages by bots anyways
20:32:02 <Beelsebob> bah... silly thing
20:32:22 <jethr0> otherwise you could get two of them to recurse, easily :)
20:32:27 <Beelsebob> indeed
20:32:37 <Beelsebob> but it's much more fun to try to get one to
20:33:52 <vincenz> Beelsebob: you mean
20:34:01 <vincenz> > show "> (2 + 2)"
20:34:02 <lambdabot> "\"> (2 + 2)\""
20:34:17 <vincenz> > showString "> (2 + 2)"
20:34:18 <Beelsebob> no, I don't :P
20:34:19 <lambdabot>  add an instance declaration for (Show (String -> String))
20:34:21 <vincenz> > showString "> (2 + 2)" ""
20:34:22 <lambdabot> "> (2 + 2)"
20:34:30 <vincenz> > eval "2+2"
20:34:31 <lambdabot>  Not in scope: `eval'
20:34:45 <Cale> actually, it doesn't
20:34:52 <Cale> (ignore messages by bots)
20:35:05 <Beelsebob> > Eval.eval "2+2"
20:35:05 <Cale> well, it ignores notices
20:35:06 <lambdabot>  Not in scope: `Eval.eval'
20:35:09 <Beelsebob> nope
20:35:16 <vincenz> @index eval
20:35:16 <Cale> but bots are free to privmsg it
20:35:17 <lambdabot> bzzt
20:35:24 <Cale> or privmsg the channel
20:35:37 <vincenz> privmsg a channel?
20:35:43 <Cale> yep
20:35:46 <vincenz> o.O
20:35:49 <Cale> like we're doing right now
20:35:52 <vincenz> > iterate (+1] 1
20:35:53 <lambdabot>  parse error on input `]'
20:35:55 <vincenz> > iterate (+1) 1
20:35:57 <lambdabot> [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,
20:35:57 <lambdabot> 28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
20:35:57 <lambdabot> 52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,
20:35:57 <lambdabot> 76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,
20:35:57 <lambdabot> 100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,
20:35:59 <lambdabot> [24 @more lines]
20:36:18 <vincenz> Cale: well PRIVmsg just sounded like odd terminology ;)
20:36:49 <Beelsebob> vincenz: that's how IRC works
20:36:53 <vincenz> I know
20:36:56 <vincenz> I just call it MSG
20:36:57 -Cale(n=cale@Toronto-HSE-ppp3866769.sympatico.ca)- Bots are supposed to use notices. This is an example of a notice. However, lots of IRC clients render them incorrectly in irritating ways.
20:37:10 <Beelsebob> the question iss... how to get lambdabot to start somethnig with > or @
20:37:21 <jethr0> vincenz: how do you open a private channel? i.e. one-to-one?
20:37:46 -Beelsebob(n=Beelsebo@212.32.88.119)- is this a notice?
20:37:53 -vincenz(n=vincenz@d51533C46.access.telenet.be)- hi
20:37:59 <vincenz> Beelsebob: yeah
20:38:00 <vincenz> did I notice?
20:38:14 <Beelsebob> vincenz: interesting... I don't see my own notices
20:38:20 <vincenz> did I do a notice?
20:38:25 <Beelsebob> yes
20:38:30 <vincenz> coolies
20:38:32 <vincenz> looked differnet
20:38:36 <vincenz> -Beelsebob:#haskell- is this a notice?
20:38:42 <vincenz> in purple
20:38:47 <vincenz> [notice(#haskell)] hi
20:38:48 <vincenz> in red
20:38:57 <vincenz> (irrsi)
20:39:18 <vincenz> @type curry
20:39:18 <Beelsebob> yeh, my client uses an irrsi backend
20:39:19 <lambdabot> forall c b a. ((a, b) -> c) -> a -> b -> c
20:39:28 * jethr0 's using irssi too
20:39:42 <vincenz> > let combo f l = map (uncurry f) (zip l (tail l))
20:39:43 <Beelsebob> @help
20:39:43 <lambdabot>  parse error on input `}'
20:39:43 <lambdabot>  @help <command> - ask for help for <command>
20:39:45 <vincenz> > let combo f l = map (uncurry f) (zip l (tail l)) in combo
20:39:46 <lambdabot>   add an instance declaration for (Show ((a -> a -> c) -> [a] -> [c]))
20:39:50 <vincenz> woo
20:40:05 <Beelsebob> @help commands
20:40:06 <lambdabot>  @help <command> - ask for help for <command>
20:40:07 <vincenz> > let combo f l = map (uncurry f) (zip l (tail l)) in combo (\x y -> y -x) $ iterate (+1) 1
20:40:08 <lambdabot> [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
20:40:08 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
20:40:08 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
20:40:08 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
20:40:08 <lambdabot> 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
20:40:11 <lambdabot> [23 @more lines]
20:40:12 <Beelsebob> @commands
20:40:13 <lambdabot> Unknown command, try @listcommands.
20:40:18 <Beelsebob> @listcommands
20:40:19 <lambdabot> use listcommands [module|command]. Modules are:
20:40:19 <lambdabot> babel base code compose dice dict djinn dummy dynamic elite fact haddock
20:40:19 <lambdabot> help hoogle karma lShell localtime more pl plugs poll pretty quote search
20:40:20 <lambdabot> seen spell state system todo topic type version vixen where
20:40:24 <vincenz> oy
20:40:32 <Beelsebob> @listcommands compose
20:40:33 <lambdabot> compose provides: . compose
20:40:37 <vincenz> @.
20:40:38 <lambdabot> Not enough arguments to @.
20:40:40 <vincenz> @. f g
20:40:41 <lambdabot> compose module failed: Parse error: "f"
20:40:41 <Beelsebob> @help .
20:40:42 <lambdabot>  @compose/@. is the composition of two plugins, where: . f g xs == g xs >>=
20:40:42 <lambdabot> f
20:40:44 <vincenz> @help .
20:40:45 <lambdabot>  @compose/@. is the composition of two plugins, where: . f g xs == g xs >>=
20:40:45 <lambdabot> f
20:40:52 <Cale> @. elite keal
20:40:52 <lambdabot> compose module failed: getRandItem: empty list
20:40:53 <vincenz> @. f g xs == gxs >>=
20:40:53 <lambdabot> compose module failed: Parse error: "f"
20:41:05 <Cale> @. elite localtime vincenz 
20:41:06 <lambdabot> Say again?
20:41:08 <lambdabot> Local time for vincenz is Sun Jan 29 05:40:44 2006
20:41:09 <Beelsebob> @. vixen vixen beelsebob
20:41:10 <Cale> grr
20:41:10 <lambdabot> compose module failed: getRandItem: empty list
20:41:15 <vincenz> @elite vincenz
20:41:15 <Beelsebob> :o
20:41:16 <lambdabot> elite module failed: getRandItem: empty list
20:41:20 <Cale> @keal
20:41:20 <lambdabot> quote module failed: getRandItem: empty list
20:41:25 <vincenz> @restart
20:41:26 <Cale> grr
20:41:26 <lambdabot> Unknown command, try @listcommands.
20:41:29 <Beelsebob> lambdabot is broken!
20:41:33 <vincenz> @listcommands system
20:41:34 <lambdabot> system provides: echo listchans listcommands listmodules uptime
20:41:34 <Cale> @reconnect
20:41:46 <Cale> not going to help though
20:41:49 <Cale> @keal
20:41:54 <jethr0> vincenz: ping in channel
20:42:06 <lambdabot> quote module failed: getRandItem: empty list
20:42:23 <vincenz> jethr0: pong
20:42:56 <Cale> @seen dons
20:42:56 <lambdabot> dons is in #haskell-blah and #haskell. Last spoke 23 hours, 19 minutes
20:42:56 <lambdabot> and 15 seconds ago.
20:43:03 <vincenz> 24 hours
20:43:30 <jethr0> vincenz: in the _private_ channel :)
20:44:07 <vincenz> I don't call that a channel
20:44:18 <jethr0> what's it called? chat window?
20:46:20 <jethr0> Cale: so how do several people work on a single darcs repo? do they usually scp their patches in and apply them?
20:47:00 <Cale> If I'm the maintainer, I usually just have people e-mail me the patches, I look at them, and then apply them.
20:47:20 <Cale> (or just apply them blindly)
20:47:20 <jethr0> sure, but in a more collaborative situation. with more than one maintainer?
20:47:37 <Cale> well, you can darcs pull from each other
20:47:45 <Cale> if you all have webservers
20:47:46 <vincenz> hmm
20:47:53 <jethr0> hmm
20:47:57 <vincenz> Cale: and if you had ssh?
20:47:58 <jethr0> vincenz: we might do that
20:48:01 <Cale> sure
20:48:12 <Cale> you could ssh in and apply the patch yourself
20:48:13 <vincenz> jethr0: yeah, I guess, it seems like the most communist thing to do :)
20:48:24 <vincenz> jethr0: it's a bit of a pingpong effect :)
20:48:33 <vincenz> jethr0: just make sure to have two repos
20:48:35 <vincenz> a) your main repo
20:48:39 <vincenz> b) where you're currently hacking
20:48:40 <Cale> it'll know which patches to apply
20:48:41 <vincenz> or is that not necessary?
20:48:43 <Cale> no
20:48:43 <jethr0> if you'd reply to me in our private conversation you'd already have ssh access
20:48:51 <vincenz> jethr0: I did
20:48:52 <Cale> you darcs record things which you want to make available
20:48:56 <Cale> to others
20:49:02 <Cale> you can hack away
20:49:07 <vincenz> jethr0: I never saw any of your text
20:49:09 <Cale> and only darcs record once in a while
20:49:11 <jethr0> vincenz: with a question
20:49:14 <vincenz> jethr0: are you regged?
20:49:25 <jethr0> vincenz: not that i know of :)
20:49:26 <vincenz> Cale: ah cool!
20:49:36 <vincenz> jethr0: gotta be regged to privmsg on freenode
20:49:45 <vincenz> with nickserv
20:49:49 <vincenz> just join my channel meta-science
20:49:51 <jethr0> hmm
20:50:06 <vincenz> (it's my new channel on meta-instantiations of ideas and philosophy at large :)
20:50:11 * vincenz needs  blog
20:50:26 <vincenz> suggestions?
20:51:03 <vincenz> Cale: so
20:51:06 <vincenz> Cale: hack hack
20:51:09 <vincenz> Cale: darcs record
20:51:29 <vincenz> Cale: jethr0 wakes up: darcs pull "mylink" and it'll pull it into darcs wiithout affecting his current hacks?
20:52:27 <Cale> right
20:52:33 <vincenz> coolies
20:52:36 <Cale> so long as they don't collide of course
20:53:57 <vincenz> yeah
20:53:58 <vincenz> last question
20:54:17 <vincenz> typically you see the current hacked files as well as the _darcs stuff on a webserver if you just symlink your current hack dir to the /www/ stuff
20:54:26 <vincenz> do I only need to symlink _darcs
20:57:37 <Cale> you need to make it look like _darcs is a subdir of what you'll be pulling/getting from
20:58:12 <Cale> like, if you do darcs get --partial http://www.example.com/myProject
20:58:23 <Cale> it will look in http://www.example.com/myProject/_darcs
20:58:31 <Cale> for the requisite files
20:59:04 <Cale> it shouldn't even need proper read access to the main directory, as long as it can get the _darcs, iirc.
20:59:36 <Cale> actually, it shouldn't even need read or execute perms on _darcs either, since it has its own index, I think
20:59:39 <jethr0> vincenz: BTW, i'd like to do this test-first. would that be okay with you?
20:59:46 <Cale> hmm
20:59:50 <Cale> maybe execute
21:00:10 <jethr0> Cale: what does the "--partial" do?
21:00:10 <Cale> I suppose that would be up to the operation of your webserver
21:00:36 <Cale> it only gets as much as needed to reconstruct the current state of the repository
21:00:46 <Cale> not enough to preserve all history
21:01:09 <vincenz> jethr0: what test?
21:01:22 <vincenz> ok...changed my lighttpd
21:01:24 <vincenz> but for some reason
21:01:29 <vincenz> when I do /icfp
21:01:31 <vincenz> it won't list contents
21:01:36 <vincenz> (I need to place index.html files)
21:01:44 <Cale> maybe /icfp/ ?
21:01:44 <vincenz> gotta be a prob in my lighttpd.conf
21:01:51 <vincenz> Cale: no it just doesn't do directory indexing
21:01:56 <Cale> okay
21:01:57 <vincenz> same problem with the /
21:02:01 <vincenz> until I added index.html
21:02:07 <jethr0> vincenz: writing unit tests first. test-driven-development.
21:02:32 <jethr0> vincenz: it's a really nice experience, but in the end it's up to you if you like it / like to try it
21:02:34 <vincenz> woo
21:02:35 <vincenz> got it
21:02:50 <jethr0> a
21:03:40 <vincenz> jethr0: 
21:03:41 <vincenz> jethr0: ok
21:03:44 <vincenz> go to your icfp dir
21:03:56 <vincenz> darcs pull http://abstractoasis.dyndns.org:8080/icfp/
21:04:15 <vincenz> Cale: hmm once you do a pull..and you have local hackery, how do you go to that version
21:04:25 <vincenz> jethr0: or just record a change in the TODO file?/
21:05:34 <Cale> vincenz: at any given point, you'll have some set of patches
21:05:38 <vincenz> Cale: right
21:05:48 <Cale> some patches commute with each other, and some don't
21:06:00 * vincenz nods
21:06:12 <jethr0>  darcs pull http://abstractoasis.dyndns.org:8080/icfp/
21:06:16 <Cale> if you do a darcs pull, and you've hacked on some things which get pulled in, you'll be notified about conflicts
21:06:16 <jethr0> Pulling from "http://abstractoasis.dyndns.org:8080/icfp/"...
21:06:21 <jethr0> darcs: failed to read patch in get_extra:
21:06:24 <jethr0> Perhaps this is a 'partial' repository?
21:06:28 <vincenz> nope
21:06:47 <vincenz> Cale: ah so pulling is to your "checked out version" meaning the hackery, not what you have in your local darcs repo
21:06:56 <Cale> and the source files will be marked with lines consisting of vvvvvv and ^^^^^ to show you where the conflicts happened.
21:06:59 <vincenz> jethr0: apply your changes that you did to TODO?
21:07:01 <vincenz> jethr0: darcs record
21:07:14 <Cale> there's no checking in and out
21:07:17 <jethr0> sry
21:07:19 <vincenz> Cale: oh
21:07:20 <Cale> everyone has their own repo
21:07:22 <vincenz> jethr0: no worries
21:07:29 <Cale> and those repos are simply combined
21:07:30 <vincenz> Cale: right but you have local stuff that is not in your repo yet
21:07:35 <Cale> oh, right
21:07:37 <vincenz> basically current hackage that's unrecorded
21:07:41 <Cale> yeah
21:07:42 <vincenz> do you pull patches into that or only the repo
21:07:48 <Cale> that can still cause conflicts
21:07:59 <vincenz> so pull does both repo AND local hackage files
21:08:04 <Cale> right
21:08:08 <jethr0> still the same error
21:08:13 <vincenz> jethr0: no I meant
21:08:15 <vincenz> jethr0: darcs record
21:08:20 <vincenz> jethr0: you changes some stuff
21:08:25 <vincenz> on the TODO file
21:08:30 <jethr0> yes, i did
21:08:39 <jethr0> and i recorded
21:08:41 <vincenz> Cale: all the info is in _darcs, right, does that mean you only have to zip that if you ever want to take it with you?
21:08:47 <Cale> darcs get http://abstractoasis.dyndns.org:8080/icfp/
21:08:48 <vincenz> jethr0: works :)
21:09:02 <jethr0> yes, but not for me :(
21:09:04 <vincenz> Cale: I did a darcs get from him, he has to do a darcs get from me too?
21:09:12 <jethr0> get or pull?
21:09:19 <Cale> oh
21:09:35 <jethr0> inside the "icfp" dir or one above?
21:09:38 <vincenz> Cale: I did a get from him, then a record off a change locally and now I want him to pull my change into his repo
21:09:43 <Cale> if you have a copy of the repo, doing a pull will merge in changes from where you got it
21:09:54 <vincenz> jethr0: darcs pull http://abstractoasis.dyndns.org:8080/icfp/
21:09:57 <Cale> you don't need to specify the url
21:10:01 <Cale> (though you can)
21:10:12 <vincenz> Cale: oh wait, no recursion?
21:10:18 <Cale> it remembers where it got the thing from
21:10:19 <vincenz> A <-> B
21:10:48 <jethr0>  i can't be _that_ stupid!!! i'm in my "icfp" folder and type "darcs pull <url>".
21:11:01 <vincenz> jethr0: I think it's cause you didn't do a get, I did a get from you, not viceversa
21:11:02 <jethr0> and then it says "... darcs: failed to read patch in get_extra:"
21:11:09 <jethr0> "Perhaps this is a 'partial' repository?"
21:11:13 <Cale> I think if you do a pull, then it will remember where you pulled from too.
21:11:21 <vincenz> Cale: so why is he having issues?
21:11:28 <Cale> one of the patches is broken or has bad permissions
21:11:33 <jethr0> vincenz: but i've already got it. why should i "get" it from you again?
21:11:34 <Cale> darcs failed:  Failed to download URL http://abstractoasis.dyndns.org:8080/icfp/_darcs/patches/20060129050646-88db5-f97342514f98a9bbcf0f70ba9063f41b14a5412f.gz
21:11:54 <jethr0> chmod a+r -R _darcs
21:11:57 <vincenz> Cale: yeah same here
21:12:03 <vincenz> Cale: port maybe?
21:12:08 <vincenz> jethr0: no idea
21:12:20 <vincenz> jethr0: I just wasn't sure you could use cycles or just trees
21:12:21 <jethr0> vincenz: your patch doesn't seem to have read permissions?
21:12:25 <vincenz> hmm
21:12:27 <vincenz> lemme check ;)
21:12:39 <vincenz> aha
21:12:49 <vincenz> try again?
21:13:05 <jethr0> *ah*, much better
21:13:10 <Cale> yep
21:13:13 <vincenz> jethr0: it pulled it in?
21:13:15 <Cale> I can get the repo too :)
21:13:16 <jethr0> will your next patch be readable again?
21:13:16 <jethr0> yes
21:13:22 <vincenz> woo
21:13:29 <vincenz> jethr0: I'll fix it so it will ;)
21:13:32 <Cale> cale@zaphod[~/icfp]$ darcs pull
21:13:32 <Cale> Pulling from "http://abstractoasis.dyndns.org:8080/icfp"...
21:13:32 <Cale> No remote changes to pull in!
21:13:44 <vincenz> however
21:13:46 <vincenz> it's actually three repos
21:13:47 <vincenz> not two
21:13:48 <vincenz> :/
21:13:52 <vincenz> jethr0's
21:13:57 <vincenz> mine that is on my website (desktop)
21:13:59 <vincenz> and then my lappy
21:14:05 <vincenz> so I'll push stuff from lappy to desktop via ssh
21:14:16 <jethr0> vincenz: well, you can sync the lappy with the desktop, so i won't have to worry about the lappy :)
21:14:30 <vincenz> jethr0: or just push whenever I record
21:14:35 <vincenz> unless cale has better solutions
21:14:50 <Cale> you can do whatever you like to keep things synched
21:14:50 <jethr0> how does "push" work? is that via email?
21:14:54 <jethr0> :)
21:15:06 <Cale> darcs will work out whatever is needed to sync things
21:15:06 <jethr0> vincenz: make another change and let's see whether perms will be okay
21:15:10 <vincenz> jethr0: sure
21:15:35 <Cale> you need local access to both repos to do a push, afaik
21:15:37 <jethr0> vincenz: what editor are you using?
21:15:45 <vincenz> jethr0: hmm, vim
21:16:08 <vincenz> Cale: not via ssh?
21:16:15 <Cale> not that I know of
21:16:22 <Cale> I wish there was a protocol for that.
21:16:52 <Cale> I suppose you could use shfs :)
21:16:53 <jethr0> vincenz: cool, me too.
21:17:00 <jethr0> Cale: it would be easy to wrap, wouldn't it?
21:17:03 <Cale> or even ftpfs :)
21:17:16 <jethr0> vincenz: you ok with "expand tabs to spaces", and if so, how many?
21:17:45 <vincenz> jethr0: ok did it
21:17:50 <vincenz> jethr0: typically I go for 2
21:17:59 <vincenz> jethr0: I changed my .bashrc
21:18:02 <vincenz> now files are o+r
21:18:14 <jethr0> fine, 2 it is. thx
21:18:27 <Cale> expand tabs to spaces is almost necessary for working on Haskell code :)
21:18:28 <vincenz> jethr0: I rmeoved the stupid test line from TODO and applied the patch
21:18:44 <vincenz> I mean "recorded
21:18:57 <jethr0> it worked just fine, cool
21:18:58 <Cale> In fact, there's a slight chance it'll be regulated by Haskell' :)
21:20:50 <jethr0> vincenz: cool. i gotta go to bed. see you tomorrow at 3pm or slightly later :)
21:21:38 <vincenz> jethr0: take care
21:22:02 <jethr0> thx, good night
21:22:14 <jethr0> looking forward to some nice haskell hacking :)
21:22:21 <vincenz> :)
21:26:33 <jethr0>  /part
21:47:52 <dons> moin
21:47:57 <dons> @keal
21:47:57 <lambdabot> i think it because mathematics damage you cpu
21:53:37 <Cale> moin dons :)
21:54:41 <Cale> dons: what do you think of the idea of attaching a cryptographic hash to each instance of a class, so that they can be compared for equality at runtime to avoid repeated work? (i.e. to obviate the need for the monomorphism restriction)
21:57:23 <vincenz> oh yeah
21:57:29 <vincenz> that burns a hole in your nose
21:57:38 <Cale> hm?
21:57:46 <vincenz> it's this white paste
21:57:51 <vincenz> let me look up the english name
21:57:58 <Cale> white-out?
21:58:01 <vincenz> @babel mierikswortel
21:58:01 <lambdabot>  bzzt.
21:58:04 <vincenz> @babel mieriks wortel
21:58:04 <lambdabot>  bzzt.
21:58:12 <Cale> @babel de en mierikswortel
21:58:14 <lambdabot>  mierikswortel
21:58:21 <Cale> er
21:58:27 <Cale> which language?
21:58:38 <vincenz> dutch
21:58:46 <vincenz> it's horseradish I think
21:58:47 <vincenz> it's white paset
21:58:49 <Cale> oh
21:58:51 <vincenz> great with fish
21:58:53 <Cale> yeah
21:58:59 <Cale> probably horseradish
21:59:02 <vincenz> about as strong as wasabi
21:59:07 <vincenz> tho I though horserabish was milder
21:59:20 <dons> hmm. crypto hash eh? sounds a bit scary.
21:59:37 <Cale> dons: I suppose any kind of hash would do :)
22:00:11 <Cale> some sort of tag which lets you know that its really the same instance
22:00:19 <Cale> so that if you had, say
22:00:26 <Cale> b = (x,x) where x = 5
22:00:35 <Cale> b :: (Num a, Num b) => (a,b)
22:00:50 <dons> yeah, hmm. like a Typeable annotation
22:01:36 <vincenz> @type b = (x,x) where x = 5
22:01:37 <lambdabot> parse error on input `='
22:01:41 <Cale> so when x gets evaluated at a particular instance of Num, say the one for Double, the cached copy gets associated with the tag for Num Double
22:01:41 <vincenz> @type let b = (x,x) where x = 5
22:01:42 <lambdabot> not an expression: `let b = (x,x) where x = 5'
22:01:57 <Cale> @type let b = (x,x) where x = 5 in b
22:01:58 <lambdabot> forall a. (Num a) => (a, a)
22:02:06 <vincenz> seems to work :)
22:02:08 <Cale> that's the MR kicking in
22:02:15 <vincenz> aha
22:02:48 <Cale> note that b's type isn't quite as general as you'd like it to be
22:03:17 <Cale> but the knowledge that the same instance will be used ensures that the computation of x can be shared
22:03:32 <vincenz> Cale: why would you want it more general?
22:03:48 <Cale> well, obviously, it could have type (Num a, Num b) => (a,b) right?
22:03:54 <vincenz> with the purpose of?
22:04:05 <Cale> well, this specific case is sort of dumb
22:04:12 * vincenz loves the socratic method
22:04:28 <vincenz> so is there a case when it's not dumb and feasible like this?
22:04:28 <Cale> in general, this can really hurt the types of things
22:04:43 <Cale> and the MR can force you to give type signatures
22:04:55 <vincenz> Cale: can you find a simple example that's not dumb?
22:05:30 <vincenz> Lol, I love the intro section for "Theory of Patches"
22:05:52 <vincenz> I am a physicist, and think like a physicist. ...  but I am not a mathematician, and don't care for math.
22:06:22 <vincenz> especially how his proofs are practical (does that imply math-proofs aren't?)
22:06:33 <Cale> well, even this one isn't so dumb
22:06:44 <vincenz> Cale: sure it is, you're gonna have a shared value
22:06:53 <vincenz> so that shared value will have a single type
22:06:58 <Cale> you might genuinely want to use that tuple at the type (Double, Int)
22:07:09 <vincenz> Cale: how can one piece of data be two types?
22:07:18 <Cale> @type (5,5) :: (Double, Int)
22:07:19 <lambdabot> (Double, Int) :: (Double, Int)
22:07:19 <vincenz> it's shared
22:07:25 <vincenz> Cale: that 5 is not shared
22:07:46 <vincenz> you have two pieces of memory containing 5
22:07:52 <Cale> @type 5
22:07:53 <lambdabot> forall t. (Num t) => t
22:08:00 <vincenz> Cale: I know, but inevitably
22:08:03 <vincenz> when you compile
22:08:07 <vincenz> 5 must have a concrete type
22:08:10 <vincenz> be it Double or Int
22:08:19 <vincenz> now if you have (a,a) where both a's point to one memory cell
22:08:20 <vincenz> it must be one type
22:08:23 <vincenz> so it can't be both
22:08:27 <vincenz> unless you remove sharing
22:08:29 <Cale> x could have a polymorphic type
22:08:40 <vincenz> Cale: not implementation wise
22:08:44 <vincenz> you're either boxing an int or a float
22:08:55 <Cale> with the MR off, let x = 5 in (x,x) gets type (Num a, Num b) => (a,b)
22:09:02 <vincenz> assembly instructions will either work on int or float
22:09:11 <vincenz> Cale: so you're saying, don't share 5
22:09:17 <Cale> not necessarily
22:09:20 <vincenz> let x = 5 in (x,x) -> occupies two 5s
22:09:29 <vincenz> (plus the tuple structure)
22:09:35 <Cale> It would be nice if it could just share 5 when a = b
22:09:37 <vincenz> doesn't that kinda go against the whole idea of laziness
22:09:46 <Cale> right?
22:09:57 <vincenz> Cale: right, and why do you want this, why does anyone want this
22:10:05 <vincenz> cause they want to have functions work on multiple types
22:10:06 <Cale> because the MR is ugly
22:10:08 <vincenz> right
22:10:09 <vincenz> now
22:10:16 <vincenz> that means a) code duplication
22:10:27 <vincenz> b) possibly code duplication at runtime (to a different type would this even be possible?)
22:10:33 <Cale> but you don't want things to perform exponentially slower either
22:10:47 <vincenz> I think b) might be an issue
22:10:49 <vincenz> Cale: imagine
22:11:01 <Cale> currently, typeclasses are implemented with dictionary passing
22:11:10 <vincenz> let tupler f = (f,f) where tupler :: (a->b) -> ((a->b), (a->b)
22:11:28 <vincenz> Cale: yeah but ideally with classes and firm types you can get rid of that
22:11:43 <vincenz> with strong typing, in theory you should be able to directly call
22:11:44 <Cale> no, because of modules
22:11:56 <vincenz> Cale: assuming whole-program-optim
22:12:00 <Cale> you want separate compilation
22:12:10 * vincenz votes for whole-program-optim at link time
22:12:11 <Cale> I don't think people are willing to give up separate compilation
22:12:27 <Cale> that's pretty tough :)
22:12:37 <vincenz> Cale: not really, just keep the type annotations
22:12:42 <vincenz> then do an extra compile pass at link time
22:12:47 <Cale> hmm
22:12:56 <vincenz> (I think
22:13:02 <vincenz> not an expert, but it seems that's feasiible
22:13:09 <vincenz> and I think removing MR might make that unfeasible
22:13:24 <Cale> hm?
22:13:40 <vincenz> Cale: an example
22:13:43 <Cale> I thought you wanted to remove MR by doing whole program optimisation
22:13:57 <Cale> (i.e. remove the problems associated with MR in that way)
22:13:59 <vincenz> Cale: no
22:14:03 <Cale> which would certainly be possible
22:14:08 <vincenz> Cale: I think that removing MR might make the whole program optim impossible
22:14:12 <Cale> why?
22:14:33 <vincenz> Cale: cause you might pass a function to something that suddenly duplicates this function in a tuple
22:14:36 <vincenz> without MR
22:14:41 <Cale> In fact, the problem that MR solves is a sort of whole-program-optimisation problem to begin with.
22:14:46 <vincenz> and then...whenever you call it, you'd have to recast that funcition to a different type
22:14:58 <Cale> You need to detect the cases where sharing can be done
22:15:09 <Cale> hm?
22:15:15 <Cale> we already have that problem
22:15:39 <vincenz> I know ocaml does inlining
22:15:45 <vincenz> and I think that for this it might duplicate code
22:15:50 <vincenz> and I know that ocaml requires MR as well
22:16:30 <vincenz> (within one module, but assuming a smart linker that's a nopoint)
22:17:03 <vincenz> in fact the only time when you do a type-based call-lookup is for the == operator
22:17:20 <vincenz> the assembly that comes out of ocaml is so nice
22:17:29 <vincenz> it's impressive
22:19:00 <dons> musasabi, the nbody flags are missing -fexcess-precision and -optc-ffast-math, (due to requirements of the old entry?)
22:19:52 <dons> we found 2x speedup in testing with those flags on, so it would be worth setting them somehow.
22:27:25 <dons> musasabi, also, how to get the mandelbrot entry rerun, now that you've added the -fexcess-precision flag to its makefile?
22:31:57 <dons> i'm fairly certain now that we won't catch C until 6.6 is out -- at the point all bets are off. all the long entries will disappear, which will probably be enough.
22:49:18 <Cale> dons: what's new in 6.6 which will shorten the entries so much?
22:51:35 <dons> D[D[Dfast packed strings
22:51:42 <Cale> ah
22:52:18 <dons> we reimplement them from scratch in 3 or 4 entries atm :/
22:52:35 <dons> just enough to solve the problem, any way.
23:34:09 <pundai> hi, whats a polymorphic function
23:39:16 <Cale> pundai: a function which can be applied to values of multiple types
23:39:53 <pundai> Cale, this would be implemented in a language like c++ with overloading right?
23:40:07 <Cale> yeah, that's one way, or templates
23:40:12 <pundai> like func(T); func(U);
23:40:13 <pundai> yep
23:40:21 <pundai> ok people in ##c++ are stupid osmetimes
23:40:22 <pundai> thanks Cale 
23:40:24 <pundai> !
23:40:26 <Cale> heh
23:40:44 <pundai> "no pundai, you meant overriding" "no i didnt, ass"
23:40:44 <Cale> out of curiosity, what did they tell you?
23:40:47 <pundai> anyway thanks
23:40:53 <Cale> heh
23:41:06 <pundai> well they were confusing it with polymorphism even though i said polymorphic function
23:41:14 <pundai> but i guess it could be confusing
23:41:35 <pundai> i only wish i knew haskell
23:41:36 <pundai> damnit
23:41:45 <pundai> caml turned me off functional languages for ever
23:41:52 <pundai> anyway gnight!
23:42:23 <Cale> in Haskell, there are essentially two forms of polymorphism: parametric, via type variables, and bounded parametric, via type variables with class constraints on them
23:42:32 <Cale> oh
23:42:33 <Cale> heh
23:48:49 <dons> weird
