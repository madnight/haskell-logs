02:35:32 --- topic: '["Haskell is still the language of choice for discriminating hackers","logs:","http://tunes.org/~nef/logs/haskell/","http://www.haskell.org/learning.html","http://www.haskell.org/tmrwiki/IssueFive","We put the Funk in Funktion","http://sequence.complete.org/hwn/20060123","HCAR 11/2005:","http://haskell.org/communities/"]'
02:35:32 --- topic: set by SimonRC on [Wed Jan 25 01:54:56 2006]
02:35:32 --- names: list (clog waern frederik Lokadin perspectival Nioate CosmicRay Frederick mauke jberg sproingie frobenius Si\Uni nothingmuch_ chucky kevind cptchaos JaffaCake bosie CrewdenX arjanb ihope chris2 kpreid_ robdockins Akshaal neurogeek kzm jethr0 MarcWeber dcoutts psi iblechbot cajole ski shapr Wi masm tic Muad_Dibber jak Cale kisu takuan Beelsebob feucht roconnor nnunley eno-away phredpenguin Si\ lispy Trixsey gour kpk ADEpt user317 ozone slipstream--)
02:35:32 --- names: list (Korollary wolverian SamB audreyt sumire Dorirh helgim Twigathy triplah zamez ed-209 lisppaste2 Khisanth pesco metaperl frederik_ svens arguile p_frici flux__ dcoutts_ astrolabe Pupeno_ Saulzar eyck Lunar^ mornfall noj lome farre Nomius rasfar orbitz Poeir lucs dv_ icbt ramkrsna sellout lambdabot fatbrain emu Philippa_ lde dany2k spamsch Nanar JKnecht norpan johs cmeme cods wilx resiak ulfdoz earthy araujo Godeke SimonRC integral llappala)
02:35:32 --- names: list (Igloo jp-autark tmoertel Matt-W cognominal musasabi WillKW_ cpatrick ibid Speck aleator wli cjs alec marcellus pejo Lor qwr palomer glasser liyang moonlite cbus dons sethk TheHunter ex_nor tewk tumm jlouis mattam binary42 boegel sieni lennart jvw ValarQ Jaen CLxyz rep C-Keen juhp JohnMeacham stesch skylan Spark tuomov Gniij xerox edwinb kosmikus AtnNn neologism gzl ksandstr sylvan eivuokko nomeata gdsx tic|school magagr shrimpx kolmodin)
02:35:32 --- names: list (alch` Wallbraker borism djw tromp_ samx scw)
02:38:43 * beelsebob_ wonders what the operator precidence level for negation is
02:40:31 <Si\Uni> For example is there any way of creating a decent instance of Ord for TypeRep?
02:41:16 <beelsebob_> anyone?
02:41:22 <beelsebob_> even know where to look?
02:41:49 <ski> lexp6 	 -> 	 - exp7
02:41:50 <ski> http://www.haskell.org/onlinereport/exps.html
02:42:37 <beelsebob_> ski: I'm missing what that's meaning
02:42:54 <ski> precedence level 6, if i understand it correctly
02:43:07 <beelsebob_> ah, okay
02:47:25 * beelsebob_ carries on coming up with contrived examples to break haskell's comments
02:56:51 * roconnor wonders if beelsebob is going to fix Haskell's broken negation operator.
02:57:35 <ski> hm, broken in which way ?
02:57:41 * roconnor wonders if it is possible to fix Haskell's broken negation operator.
02:57:46 <roconnor> > print -5
02:57:47 <lambdabot>  add an instance declaration for (Num (a -> IO ()))
02:58:08 <roconnor> >print (-5)
02:58:20 <roconnor> > print (-5)
02:58:21 <lambdabot> No IO allowed
02:58:24 <ski> that's just negation having less precedence than function application
02:58:41 <waern> dons, there?
02:59:05 <ski> recall that the '-' is not part of the number literal
03:01:09 <roconnor> ski: look at the code: print -5
03:01:18 <roconnor> what do you think it ought to do.
03:01:20 <roconnor> free your mind.
03:02:18 <beelsebob_> roconnor: I think that the proposal for fixing it is remove it
03:02:38 <roconnor> interesting
03:02:43 <ski> well, if i'm freeing my mind of old math conventions, and applies the knowledge that application binds strongest, then that subtracts five from whatever number 'print' stands for
03:03:08 <beelsebob_> at the moment I'm trying to demonstrate the massive inconsistancy in {- being two characters, while -- is a reserved word
03:03:30 <beelsebob_> ski: indeed
03:03:42 * ski thinks "--" is also two characters
03:04:01 <beelsebob_> ski: nope, it's a reserved word
03:04:14 <beelsebob_> hence --> is an operator while {-> -} is a comment
03:04:29 <ski> it's two characters when i write it .. maybe you have a fancy editor which displays it as a single glyph ?
03:04:30 <beelsebob_> sorry... I should say "just" two characters
03:04:46 <ski> ah, better :)
03:04:48 <beelsebob_> point being that -- is special, while {- is not
03:05:03 <ski> hm, what could be the rationale for that ?
03:05:13 <beelsebob_> this is a good way of confusing newbies, or people trying to write haddoc docs
03:05:31 <roconnor> obviously {-> ought to be an operator.  ;)
03:05:54 <beelsebob_> no
03:05:55 <roconnor> maybe even a type constructor.
03:06:10 <roconnor> probably both.
03:06:22 <ski> (in that case, yes)
03:06:26 <robdockins> BTW anybody know why '--' and '{- -}' are the comment forms chosen for Haskell?
03:06:46 <beelsebob_> { is not allowed in an operator
03:06:57 <ski> aha
03:07:14 <beelsebob_> but it's still incredibly inconsistant
03:07:22 <beelsebob_> --| This is not a comment, it's a line that produces garbage
03:07:22 * ski seems to recall some other language having '{- -}' block comments .. Pascal ?
03:07:49 <roconnor> (* *) is  Pascal
03:07:59 <earthy> { is often a comment introducer, and has been at least sinds the algol 68 report
03:08:01 <ski> (ok, must be some other i'm thinking of, then)
03:08:54 <earthy> but I think the question might be answered more readily if posed on haskell-cafe
03:09:40 <Saulzar> I guess there is no reasonable opertor which uses {} but several potentially using --
03:09:51 <earthy> yeah, -- I don't really get either
03:10:17 <robdockins> indeed, in a number of other popular languages it is a rather important operator
03:10:29 <Saulzar> People like arrow-ish like notations for operators, and you can only have so many :)
03:10:51 <edwinb> ->, -->, --->, ---->, ... ;)
03:11:23 <beelsebob_> yeh... but why not use ~~> for an arrow
03:11:30 <beelsebob_> and let --> still be a comment
03:11:34 <roconnor> --* the hairy lolipop operator
03:11:43 <wilx> Heh.
03:12:24 <beelsebob_> when we get unicode support... --â€¢ the lolipop opperator
03:12:50 <Saulzar> Heh, in this font the last char is tiny
03:12:52 <beelsebob_> but... can't you be happy with ~~* the slightly bent stalked hairy lollypop opperator
03:13:09 <edwinb> that's more like a tadpole I think
03:13:44 <edwinb> I recently used >-> instead of --> because emacs was highlighting it irritatingly.
03:13:57 <Saulzar> ~o is the tadpole operator :)  
03:14:12 * dcoutts_ notes that hIDE get's the -- syntax highliting right
03:14:34 <dcoutts_> (but that's because it uses GHC's lexer rather than regexp based colouring)
03:14:37 <beelsebob_> ~~o the sperm opperator
03:15:06 <sieni> what operator is <3==3
03:15:46 <dcoutts_> how many ascii smileys are valid Haskell operators I wonder
03:16:07 <dcoutts_> :-$
03:16:30 <Saulzar> ^_^ 
03:16:50 <dcoutts_> < let ^_^ = (+) in 3 ^_^ 2
03:16:52 <dcoutts_> > let ^_^ = (+) in 3 ^_^ 2
03:16:53 <lambdabot>  parse error on input `^'
03:16:59 <dcoutts_> > let (^_^) = (+) in 3 ^_^ 2
03:17:00 <lambdabot>  parse error on input `)'
03:17:12 <Saulzar> Hmm
03:17:39 <dcoutts_> > let (<:-$) = (+) in 3 <:-$ 2
03:17:40 <Saulzar> No underscore allowed?
03:17:40 <lambdabot> 5
03:17:53 <beelsebob_> > let (.Y.) = (+) in 3 (.Y.) 2
03:17:54 <lambdabot>  parse error on input `)'
03:18:01 <dcoutts_> ah, underscore isn't a symbol
03:18:05 <beelsebob_> it's the boobies operator!
03:18:37 <beelsebob_> > let (o|o) = (+) in 3 (o|o) 2
03:18:37 <lambdabot>  parse error on input `|'
03:18:40 <beelsebob_> damn
03:19:07 <beelsebob_> > let boobs = (,) [] [] in show boobs
03:19:08 <lambdabot> Add a type signature
03:19:24 <waern> dcoutts, I unregistered Cabal-1.0 and installed Cabal-1.1.4 => ghc-6.5: unknown package: Cabal-1.0 when building yi or hIDE
03:19:47 <beelsebob_> > let boobs :: ([Int],[Int]); boobs = (,) [] [] in show boobs
03:19:48 <lambdabot> "([],[])"
03:19:50 <beelsebob_> *g*
03:20:07 <neologism> not very nooce one :)
03:20:09 <neologism> nice
03:20:10 <Saulzar> let (^^) = '@'; keke = replicate 2 in keke ^^ 
03:20:13 <Saulzar> > let (^^) = '@'; keke = replicate 2 in keke ^^ 
03:20:14 <lambdabot>  parse error on input `}'
03:20:42 <Saulzar> What } ?
03:20:55 <beelsebob_> that is indeed an interesting one
03:22:30 <Saulzar> Ah, well that'd be because ^^ is not valid.. but wierd error.
03:23:44 <dcoutts_> waern, you've got something that was built with Cabal-1.0
03:24:04 <waern> ok, but why does that matter?
03:24:05 <Saulzar> I guess lambdabot may wrap the whole thing in { }
03:24:47 <dcoutts_> waern, make sure you're building yi & hIDE from clean so that there are no left over Cabal-1.0 dependencies.
03:24:52 <dcoutts_> waern, and check if you have any packages that depend on Cabal-1.0
03:25:12 <dcoutts_> waern, registered packages I mean, check using ghc-pkg
03:25:26 <waern> i'm building them from clean, but I know that I have registered packages that was *built* with Cabal-1.0
03:25:38 <beelsebob_> let (*.*) = (+) in 5 *.* 3
03:25:38 <waern> but depends on Cabal-1.0 is another thing right?
03:25:46 <beelsebob_> > let (*.*) = (+) in 5 *.* 3
03:25:47 <lambdabot> 8
03:25:50 <beelsebob_> :)
03:26:02 <waern> ah, okay.. I can check that with ghc-pkg
03:27:55 <waern> oh, okay I see why I need Cabal-1.0 now 
03:29:36 <beelsebob_> ohh, yay
03:29:44 <beelsebob_> office mate has OS X running on his dell :)
03:32:31 <SyntaxNinja> 'morning
03:34:02 <gour> dcoutts_: what open-sourced VS plugin means for hIDE? (btw, pida-0.3beta released)
03:37:34 <dcoutts_> gour, more code sharing perhaps?
03:37:37 <dcoutts_> hia SyntaxNinja 
03:38:06 <dcoutts_> waern, so what was it?
03:38:30 <gour> dcoutts_: but hIDE will stay with hs-plugins?
03:39:26 <dcoutts_> gour, probably, but we'll have a static build option
03:40:43 <waern> dcoutts, I don't know.. but I had forgot to clean the hIDE dir and i'm trying again
03:41:03 <waern> ah
03:41:27 <waern> it was the ghc package that depended on Cabal-1.0 
03:41:58 <waern> that explains why it was hidden
03:42:08 <dcoutts_> that makes sense
03:42:44 <waern> can I just go and rebuild it, or do I need to unregister the package first?
03:43:21 <waern> it still doesn't explain why yi wouldn't build
03:43:39 <waern> it was the executable part of yi...
03:45:50 <dcoutts_> waern, I think you can just rebuild it
03:45:59 <waern> hm..
03:46:15 <waern> can I build it separately from ghc?
03:46:51 <waern> I should say "install it" instead
03:53:15 <gour> frobenius: have you seen that pida-0.3beta was released recently
03:53:29 <frobenius> gour, no
03:53:54 <gour> frobenius:  http://download.berlios.de/pida/pida-0.3.0beta.tar.gz
04:09:24 <frobenius> but I use mac os x...
04:09:28 <frobenius> and not particularly X11
04:09:31 <frobenius> or GNOME
04:09:54 <dcoutts_> waern, I'm not sure what "it" you are referring to
04:09:56 <Cale> frobenius: sorry, what are you looking for?
04:10:09 <frobenius> we spoke about ide's
04:10:26 <waern> dcoutts, the ghc package. anyway, i'm recompiling ghc now :)
04:10:56 <waern> so that it gets the latest cabal from the ground up
04:14:40 <Cale> why do people want to treat classes as types?
04:15:52 <dcoutts_> Cale, people want to pass around interfaces rather than concrete objects
04:16:08 <dcoutts_> Cale, it's a Javaism
04:16:10 <Cale> What's wrong with doing that the usual way?
04:16:21 <dcoutts_> Cale, so what is the usual way?
04:16:30 <dcoutts_> there are several ways
04:17:15 <Cale> Create an existential newtype and wrap things with it
04:17:36 <dcoutts_> I'm not sure everyone thinks that usual
04:17:42 <dcoutts_> it's not H98 for starters
04:18:03 <gour> frobenius: it's python, it should work on mac os
04:18:06 <Cale> Lots of things aren't H98 :)
04:18:09 <dcoutts_> the H98 way is by a record of functions
04:18:18 <Cale> Yeah, that ought to work too
04:18:49 <dcoutts_> Cale, but to make it as convenient as type clases we need existentials + newtype deriving
04:18:55 <gour> frobenius: http://pida.vm.bytemark.co.uk/projects/pida/wiki/PidaDocumentation/UserManual#requirements-to-run-pida
04:19:01 <dcoutts_> I think this ought to work:
04:19:06 <dcoutts_> class Foo a where
04:19:09 <dcoutts_>   ...
04:19:44 <dcoutts_> data AbstractFoo = forall a. Foo a => AbstractFoo a
04:19:48 <dcoutts_>   deriving Foo
04:20:38 <Cale> yeah, that looks good -- you'll need a usually-obvious extension to deriving.
04:20:55 <dcoutts_> is that not just ordinary newtype deriving?
04:21:02 * dcoutts_ checks with ghc
04:21:05 <Cale> that was 'data'
04:21:13 <dcoutts_> oops
04:21:19 * dcoutts_ meant newtype
04:23:14 <Cale> newtype doesn't seem to like foralls
04:24:16 <dcoutts_> indeed
04:24:17 <dcoutts_> :-(
04:24:22 <dcoutts_> why not I wonder
04:24:50 <Cale> well, there's no unwrapped version of that existential type
04:25:00 <Cale> so there's no implementation for it to copy
04:25:15 <dcoutts_> hmmm
04:25:30 <dcoutts_> I don't see the implementation problem
04:25:58 <dcoutts_> if it can be done boxed then why is it a problem with no extra boxing?
04:26:04 <Cale> Well, an AbstractFoo can't be implemented the same as any particular existing type. It's got to carry around a dictionary
04:26:29 <dcoutts_> but the thing already has a dictionary
04:26:36 <Cale> oh?
04:26:46 <dcoutts_> that's what the forall a. Foo a => ... says
04:27:11 <dcoutts_> it's a value with a dictionary for a Foo
04:27:20 <dcoutts_> it's a value with a dictionary for the Foo class
04:27:42 <dcoutts_> it ought to be possible to use exactly the same runtime representation
04:28:05 <dcoutts_> it's the same object, we've just got less type information about it
04:28:14 <Cale> aha, newtype AbstractFoo = AbstractFoo (forall a. Foo a => a)
04:28:26 <Cale> but you still can't derive the class
04:28:29 <dcoutts_> that's not the same is it?
04:28:42 <Cale> perhaps not quite
04:28:53 <dcoutts_> that's forall rather than exists
04:29:02 <Cale> oh, right, sorry
04:29:23 <dcoutts_> newtype AbstractFoo = exists a. Foo a => AbstractFoo a
04:29:27 <Cale> however, there's no way to write the exists inside like that
04:29:33 <dcoutts_> indeed
04:29:39 <Cale> newtype AbstractFoo = AbstractFoo (exists a. Foo a => a)
04:29:44 <Cale> is what we want
04:29:50 <dcoutts_> right
04:29:52 <Cale> but exists a. Foo a => a isn't already a type
04:30:00 <dcoutts_> yep
04:30:06 <Cale> which is why the other way fails too
04:30:08 <xerox> Why?
04:30:26 <dcoutts_> xerox, well it's not a type that any Haskell extension yet supports
04:30:48 <dcoutts_> though many people would like it
04:31:10 <Cale> You'd also have a heckuva time using it unless Foo got automatically derived for it.
04:31:17 <dcoutts_> ghc allows arbitrary foralls but only exists on data constrctors
04:32:14 <Cale> data AbstractFoo = forall a. Foo a => AbstractFoo a
04:32:44 <Cale> it would seem to me that this would have to also carry around an explicit Foo dictionary for each value of type a
04:33:05 <Cale> (as opposed to simply requiring that one be hanging around somewhere)
04:33:14 <dcoutts_> hmm
04:33:20 <dcoutts_> so we can make AbstractFoo an instance of Foo manually
04:33:25 <Cale> right
04:33:35 <Cale> that's what I usually do in that sort of case
04:33:39 <dcoutts_> so how does that work with the dictionary passing
04:33:42 <dcoutts_> instance Foo AbstractFoo where
04:34:08 <Cale> well, that's the same as any instance
04:34:10 <dcoutts_>   bar (AbstracFoo a) = bar a
04:34:30 <dcoutts_> so you're saying that this must be plucking a dictionary out of the AbstracFoo constructor
04:34:36 <Cale> I suppose at that point, you can do things like  AbstractFoo (AbstractFoo x)
04:34:53 <Cale> which involves passing a dictionary for Foo AbstractFoo
05:12:22 <waern> hm.. I think they have forgot to update the makefile in http://darcs.haskell.org/packages/Cabal .. it register the package as 1.0 even though it is actuall 1.1.4 
05:13:58 <frobenius> has anyone used Self, Omega, NewtonScript or any such language? Is there a channel for object-based PLs?
05:21:49 <sethk> frobenius, I've read a bit about self, but I haven't used it for anything
05:22:14 <SamB> I've run Self.
05:22:21 <SamB> but it doesn't run too well on x86...
05:26:02 <araujo> Hello
06:06:03 <jethr0> @type uncurry (+)
06:06:04 <lambdabot> forall b. (Num b) => (b, b) -> b
06:06:33 <jethr0> @type let f a b c = 0 in uncurry f
06:06:34 <lambdabot> forall a b t t1. (Num t1) => (a, b) -> t -> t1
06:07:59 <vincenz> @type not
06:08:00 <lambdabot> Bool -> Bool
06:12:29 <jlenor1_> well
06:12:42 <palomer_> it's time I start learning the dark art of writing monads
06:13:18 <SamB> not *that* dark
06:13:27 <palomer_> yes, that  dark art
06:13:33 <frobenius> sethk, interesting
06:13:34 <SamB> just because they are black boxes doesn't mean it is dark inside
06:13:43 <palomer_> ok, I want to write a monad which acts very much like List
06:14:13 <palomer_> however, it has an extra function getState, which binds a variable to a state
06:14:48 <palomer_> and a function runLocal, which takes a continuation and adds to that state (but only in that conntinuation)
06:15:08 <palomer_> actually, it takes something to add to the state and a continuation
06:15:10 <palomer_> how do I do this?
06:16:17 <SamB> mmm.
06:16:35 <SamB> that sounds like you want to use some monad transformers to me, actually...
06:17:19 <palomer_> oh, and it can fail, but when it fails I don't want everything to stop, I just want it to return the "empty list" equivalent in my monad
06:20:47 <palomer_> whew, this black art seems really hard
06:21:03 * palomer_ thinks writing an instance of monad is like writing an interpreter
06:21:07 <Cale> palomer_: how should those features interact?
06:21:24 <Cale> It is rather like that, but often you don't have to do it yourself
06:21:32 * ptolomy is happy with the "ShortExamples" thing on the wiki. Complete, simple, and diverse programs are such a learning aid.
06:22:01 <Cale> newtype MyMonad s a = MyMonad (ContT (StateT s [] a)) deriving (Functor, Monad)
06:23:08 <vincenz> Cale: question: in a buttonMonad I'm changing the onClicked...unfortunately it seems to fire the new one right away, how do I tell it no longer to consume the event
06:23:52 <palomer_> Cale, I should be able to write something of the sort (x <- runLocal ["foo":=2] (\x -> bar)) >>= \f -> y <- runLocal ["bar":=3] (\x -> bar') >>= \f -> return f
06:24:20 <palomer_> or let x = blargh in if (predicate x) then fail else x
06:24:26 <palomer_> or let x = blargh in if (predicate x) then fail else return x
06:24:47 <Cale> what's runLocal?
06:24:53 <Cale> vincenz: hmm
06:25:00 <palomer_> it takes something to add to the state and a continuation
06:25:05 <Cale> vincenz: buttonMonad?
06:25:08 <vincenz> Cale: well a button
06:25:14 <vincenz> onclicked buttom some action
06:25:16 <vincenz> in that action I change the onclicked
06:25:20 <palomer_> such that the state is only changed in that continuation
06:25:22 <vincenz> it seems to fire the new onclick handler
06:25:28 <Cale> ah
06:26:48 <Cale> I'm not sure, really.
06:27:06 <Cale> palomer: okay
06:27:36 <Cale> palomer: do you also want to be able to modify the state apart from runLocal?
06:28:22 <palomer_> Cale, nope
06:28:34 <Cale> so it's really a Reader
06:28:51 <palomer_> but I also want to get the state!
06:29:02 <palomer_> @hoogle Reader
06:29:03 <lambdabot> Control.Monad.Reader.Reader :: Reader r a
06:29:03 <lambdabot> Control.Monad.Reader.Reader :: r -> a -> Reader r a
06:29:03 <lambdabot> Control.Monad.Reader.ReaderT :: ReaderT r m a
06:29:09 <Cale> ask
06:29:12 <palomer_> and I want to return multiple values
06:29:19 <Cale> ReaderT []
06:29:31 <Cale> er
06:29:34 <Cale> ReaderT r []
06:29:46 <palomer_> wait, why not Reader r [a] ?
06:29:55 <frobenius> #lisp is a pack of wolves
06:29:57 <frobenius> really angry people there
06:30:09 <palomer_> frobenius, they're bitter that their programming language sucks
06:30:13 <Cale> palomer: that could also work
06:30:23 <frobenius> asking sensible questions gets you banned
06:30:24 <Cale> frobenius: what happened?
06:30:40 <frobenius> I was very polite, but for some reason they banned me suddenly
06:31:24 <sethk> frobenius, you must have implied that lisp is not the ultimate programming language perfect in every way.
06:31:25 <frobenius> I inquired about self-updating code (politely and out of genuine interest). At a point I asked (re: self-updating code): yes, from a software engineering point of view I agree that it may be very useful. but in small scale. examples
06:31:43 <palomer_> Cale, here's the gist: creating a new state requires to modify some STRefs, and then you need to unmodify them afterwards
06:31:46 <icbt> @seen lemmih
06:31:46 <lambdabot> I saw lemmih leaving #haskell-blah and #haskell 4 days, 5 hours, 10
06:31:46 <lambdabot> minutes and 30 seconds ago, and I have missed 4 seconds since then.
06:31:54 <palomer_> Cale, so I'll also be doing this in ST
06:32:17 <palomer_> Cale, this is so I can do everything in place
06:32:56 <Cale> hmm
06:33:31 <frobenius> the ultimate statement at #lisp: "But we won't be able to convince you about anything, unless you actually learn a bit of CLOS, I'm afraid. It appears to be rather more different from most "OO" than people expect, or even accept."
06:33:43 <frobenius> In other words, we are bettern than any lambda calculus you can ever think about.
06:33:43 <palomer_> so runLocal x f is really writeSTRef y $ Just 5; f state; writeSTRef y Nothing
06:34:31 <sethk> frobenius, I wouldn't associate OO with lambda calculus
06:34:54 <frobenius> I would.
06:35:07 <frobenius> C.f. Benjamin Pierce
06:35:26 <frobenius> chocking experience with #lisp ... ;-) 
06:35:28 <sethk> frobenius, I'm not saying that you can't find a single case where someone uses lambda calculus to describe something that is OO
06:35:53 <palomer_> OO is more of a style than anything
06:35:53 <sethk> frobenius, but lambda calculus is certainly not, in general, associated with 00, and that is certainly not what the #lisp line you quoted is talking about
06:35:56 <frobenius> sethk, OO can be reduced to typed lambda calculus
06:36:12 <palomer_> everything can be reduced to typed lambda calculus
06:36:14 <frobenius> sethk, no like many channels there is a lot of bad behaviour
06:36:20 <sethk> frobenius, I didn't say that it couldn't (nor that it could).  I said that the line you quoted has nothing to do with lambda calculus
06:36:31 <sethk> frobenius, sure, check out #debian  :)
06:36:33 <neologism> isnt OO described by sigma calculus
06:36:43 <neologism> which is basically lambda + syntax ?
06:36:46 <frobenius> neologism, I am an expert on sigma calculus more or less
06:36:55 <frobenius> sorry for the claim
06:37:00 <frobenius> but it might be true I think
06:37:05 <frobenius> I have studied it for 4 years
06:37:06 <neologism> ?
06:37:34 <frobenius> no, it is not just lambda + syntax.
06:37:39 <frobenius> there is some more things to it
06:37:41 <frobenius> subtyping
06:37:44 <frobenius> in particular
06:38:00 <palomer_> nominal subtyping?
06:38:05 <frobenius> and self type polymorphism (Cardelli) aka mytype polymorphism (Bruce)
06:38:33 <frobenius> the method labels matters, yes.
06:38:36 <palomer_> Cale, no ideas?
06:39:43 <Cale> palomer_: sorry, I just had to get up for a bit
06:39:47 <frobenius> another highlight from #lisp --- "I'd argue that it pays off in terms of debugging...."
06:40:10 <Cale> palomer_: hmm, you could certainly implement that in terms of ST, but I'm not quite sure why a Reader won't do
06:40:30 <palomer_> Cale, the state has STRefs
06:40:38 <frobenius> (on the flexibility in Lisp)
06:40:39 <frobenius> ;-)
06:40:41 <palomer_> in fact, the state is a list of strefs
06:41:08 <palomer_> Cale, and runlocal will writeref and then writeref back
06:41:39 <Cale> but why?
06:41:54 <Cale> do you need arbitrarily many states?
06:42:00 <lispy> of course
06:42:40 <palomer_> Cale, for performance reasons
06:42:59 <palomer_> Cale, well, updating the state IS writing to a ref, this is for sure
06:43:10 <palomer_> it's also a cleaner implementation
06:44:33 <Cale> Performance reasons? I don't see a performance benefit to STRefs here, though I'm not quite sure what you have in mind
06:44:45 <palomer_> Cale, I have no choice but to use STRefs
06:44:52 <Cale> hm, okay
06:45:14 <palomer_> no, seriously,for this particular case STRefs is the best solution
06:45:32 <palomer_> state isn't really state
06:46:12 <Cale> okay
06:46:17 <Cale> What is it? :)
06:46:23 <palomer_> well, I'm doing unification
06:46:34 <palomer_> STRefs are existential variables, and I'm instantiating them
06:46:54 <palomer_> doing this saves me the trouble of doing explicit substitutions
06:46:56 <palomer_> which is a pain
06:47:11 <palomer_> and is slower
06:47:28 <Cale> ah, all right, so you have STRefs stuck in structures which you're operating on
06:47:32 <SamB> why are you using STRefs for this rather than IORefs
06:47:41 <Cale> SamB: purity
06:48:46 <palomer_> oh, I'll be using these unifiers to generate types, which have no STRefs
06:49:10 <palomer_> and I don't want my term values to be polluted by IO types
06:49:27 <palomer_> and, erm, it doesn't change anything in my code to use IORefs instead of STRefs
06:49:42 <palomer_> (except one call to runST)
06:50:30 <SamB> okay then
06:50:57 <palomer_> so, how do I implement this beast?
06:51:34 <lispy> palomer_: i'd recommend going the declarative route and rewriting it to use STRef if it becomes a performance problem
06:52:14 <palomer_> lispy, it would take much more code and would look much uglier
06:52:30 <palomer_> seriously, STRefs is the cleanest representation
06:54:47 <sethk> clean is entirely subjective
06:54:48 <palomer_> it takes the least amount of code, and  acting on the datastructuro is very straightforward
06:54:48 <palomer_> s/datastructoro/datastructure
06:54:48 <palomer_> furthermore, I'm assured integrity
06:54:48 <palomer_> (it's safer)
06:54:53 <lispy> if it's so straightforward then why do you not know how to get started?
06:54:57 <palomer_> and I don't have to generate new names
06:55:07 <palomer_> lispy, I don't know how to write the monad!
06:55:19 <palomer_> the underlying language of the algorithm
06:56:06 <Cale> You usually start out writing a monad by stacking some monad transformers on top of a base monad (in your case, it'll have to be ST)
06:56:26 <Cale> Then you can restrict and specialise the operations
06:56:43 <Cale> Doesn't work for everything, but when it does, it's quite easy
06:58:37 <palomer_> I don't think I can do it in this case
06:59:23 <Cale> It really sounds from what you've told me that you should be able to
07:00:19 <TuringTest> palomer_: I am aorry for joining midstream.  I did not see your runLocal requirements, but does the ReaderT on IO with IORefs at the bottom of http://haskell.org/hawiki/ImperativeHaskell resemble this?
07:00:26 <TuringTest> aorry -> sorry
07:01:10 <palomer_> http://www.rafb.net/paste/results/bZIiWD85.html
07:01:19 <palomer_> this'll probably be what my runLocal function will look like
07:01:55 <Cale> that return s in the middle isn't doing anything
07:02:17 <TuringTest> That looks confusing without some comments or description.
07:02:35 <lispy> yeah, you need something like runLocal x s = { apply x; s' <- computeWith s; unapply x; return s'}
07:02:40 <palomer_> http://www.rafb.net/paste/results/eRBDJu87.html
07:03:15 <lispy> but, if you're going to do that, what was the point of applying x?
07:03:32 <palomer_> lispy, it changes the state
07:03:36 <TuringTest> So apply x modifies some environment that 's' is evaluated in.
07:03:43 <palomer_> yes!
07:03:54 <palomer_> and then unapply brings it back to the old state
07:04:11 <lispy> when i was writing my lisp evaluator someone told me ReaderT would have been really nice to use for things like that.
07:04:18 <TuringTest> Ok.  So this is just a stack.  apply is push, unapply is pop
07:04:18 <Cale> why not implement this with local though?
07:04:23 <lispy> why do you want to bring it back to the old state?
07:04:49 <TuringTest> lispy: For a brute force algorithm doing a search, perhaps.
07:05:02 <lispy> oh, backtracking?
07:05:08 <TuringTest> for example
07:05:20 <palomer_> apply ((stref,x),t) = do{writeSTRef stref x; apply t}
07:05:20 <palomer_> appty [] = return []
07:05:20 <TuringTest> Knuth's dancing links works like this for the binary cover algorithm
07:05:25 <lispy> yeah, that does sound very stack lik
07:05:49 <lispy> palomer_: that types?
07:05:58 <palomer_> probably not
07:06:00 <palomer_> but it gives you an idea
07:06:01 <palomer_> :o
07:06:22 <lispy> oh you meant apply [(stref,x),t] = ...
07:06:24 <Cale> actually, it does type
07:06:25 <TuringTest> How does unapply know what to do?  Where is the overwritten state stored?
07:06:37 <Cale> since apply is misspelled in the second line ;)
07:06:49 <lispy> Cale: hehe, i saw that too :)
07:06:50 <MarcWeber> Is anyone using hdirect with com on windows?
07:06:55 <palomer_> Cale, how would I implement this with Reader? local needs me to create a new state, while all I'm doing is modifying the current state with writeIORef
07:07:07 <lispy> MarcWeber: no, but i considered it.  Looked old and hard to build
07:07:11 <Cale> palomer: right, you don't do that
07:07:18 <palomer_> Cale, I don't do what?
07:07:36 <Cale> palomer: you just give a function from the old state to the new one -- you'll be adding a binding to a map or something, right?
07:08:02 <palomer_> Cale, binding to a map?
07:08:20 <palomer_> Cale, but the function from the old state to the new state will wreck the state for everyone else, no?
07:08:27 <TuringTest> The old values in stref is lost, I don't see what unapply is supposed to do.
07:08:36 <Cale> runLocal ["bar":=3]
07:08:47 <Cale> you want "bar" to locally be set to 3
07:09:07 <palomer_> Cale, it'll be more like runLocal [x:=3] where x is an STRef
07:09:16 <MarcWeber> lispy: I spend some time and you can build it (I did it) most of the examples are even working.
07:09:39 <MarcWeber> You just have to check out the whole fptools directory..
07:10:08 <MarcWeber> lispy: Do you still consider using it? for what?
07:10:10 <Cale> palomer_: ah, okay
07:10:42 <palomer_> Cale, however, I'm pretty sure that runLocal will actually change the local state since I'll be calling writeSTRef
07:10:46 <lispy> MarcWeber: i played around with the idea of letting haskell communicate with the software I develop at work
07:10:50 <MarcWeber> does where import <modulename> ( <classxy>(..) mean import everything from that class?
07:10:53 <Cale> palomer_: that's quite different -- this STRef going to occur in various data structures which need to be manipulated with that value set
07:10:55 <lispy> MarcWeber: so no serious projects, just something to play with
07:11:07 <Cale> ?
07:11:15 <MarcWeber> lispy Do you want to play? Perhaps I can help you and you me?
07:11:19 <palomer_> Cale, hmm?
07:12:00 <MarcWeber> lispy: Do you have cygwin installed?
07:12:14 <palomer_> @hoogle stref
07:12:14 <lambdabot> Data.STRef.Lazy.STRef :: STRef s a
07:12:14 <lambdabot> Data.STRef.STRef :: STRef s a
07:12:14 <lambdabot> Data.STRef.Lazy.newSTRef :: a -> ST s (STRef s a)
07:12:17 <Cale> palomer_: You couldn't implement this with a ReaderT (Map String Integer) {-something-}
07:12:20 <Cale> ?
07:12:46 <palomer_> Cale, I could, but I think it would be uglier
07:12:50 <Cale> okay
07:13:10 <palomer_> @hoogle ST
07:13:10 <lambdabot> Control.Monad.ST.Lazy.ST :: ST s a
07:13:10 <lambdabot> Control.Monad.ST.ST :: ST s a
07:13:10 <lambdabot> Graphics.UI.ObjectIO.CommonDef.St :: s -> (a, s)
07:13:33 <TuringTest> palomer_: which bits of code do the "newSTRef" creation?
07:13:39 <Cale> so you're putting these STRefs into some structure, not just looking them up once to replace them with their values
07:14:39 <palomer_> TuringTest, oh, that's somewhere else entirely in my code
07:14:47 <TuringTest> ok
07:15:16 <palomer_> Cale, I'll never need to look them up (which is where the performance boost comes in)
07:15:36 <Cale> palomer: that's silly, of course you'll have to
07:16:25 <palomer_> I can assure you I won't
07:17:06 <palomer_> they'll be passed around
07:17:17 <palomer_> and different datatype values will contain them
07:18:47 <palomer_> Cale, hrm, maybe it would help if you understood STRef based unification
07:18:51 <xinming> will be building ghc 6.4.1 cost a day?
07:18:51 <xinming> on a P-M 1.73G machine
07:19:22 <palomer_> @hoogle writeSTRef
07:19:22 <lambdabot> Data.STRef.Lazy.writeSTRef :: STRef s a -> a -> ST s ()
07:19:22 <lambdabot> Data.STRef.writeSTRef :: STRef s a -> a -> ST s ()
07:19:35 <Cale> palomer_: you surely will have to observe their values, or else STRefs are total overkill
07:19:47 <Cale> If you're just using them as uniques, that's silly.
07:19:58 <Cale> You'd be just as well off with integers
07:20:26 <palomer_> oh, looking up means dereferencing
07:20:30 <Cale> yes
07:20:30 <palomer_> then yes, I'll be looking up
07:20:41 <palomer_> I thought you meant looking them up
07:20:51 <palomer_> (and I don't think that STRef s () as a unique is silly!)
07:20:54 <Cale> I mean calling readSTRef
07:20:58 <palomer_> yeah
07:21:00 <palomer_> I do that a lot
07:21:00 <Cale> I think it is :)
07:21:27 <ihope> @djinn Either (Either a (a -> a)) (Either a (a -> a) -> Either a (a -> a)) -> Either a (a -> a)
07:21:27 <lambdabot> f a =
07:21:27 <lambdabot>   case a of
07:21:27 <lambdabot>   Left b -> b
07:21:27 <lambdabot>   Right c -> case c (Right (\ d -> d)) of
07:21:27 <lambdabot>      Left e -> Left e
07:21:29 <lambdabot>      Right _ -> Right (\ f -> f)
07:21:31 <ihope> WOOT!
07:21:34 <palomer_> @hoogle readIORef
07:21:34 <lambdabot> Data.IORef.readIORef :: IORef a -> IO a
07:21:37 <Cale> Using ST for uniques is like, well, it's really overkill, and a lot more awkward than it needs to be :)
07:21:43 <palomer_> @hoogle readSTRef
07:21:43 <lambdabot> Data.STRef.Lazy.readSTRef :: STRef s a -> ST s a
07:21:43 <lambdabot> Data.STRef.readSTRef :: STRef s a -> ST s a
07:21:54 <palomer_> Cale, not if it fits perfectly with the rest
07:22:55 <palomer_> btw, how can I make my apply function typecheck?
07:23:00 <xinming> ?? anyone would answer my question? How long will it take to build ghc 6.4.1 :-/
07:23:33 <ihope> ...Wait a minute...
07:23:52 <TuringTest> xinming: not a day
07:23:54 <xinming> I noticed that while `make all` in `/ghc-6.4.1/ghc/compiler`; the make eats all cpu usage. and does nothing.
07:24:00 <xinming> Is it a bug?
07:24:09 <edwinb> It does take a while...
07:24:11 <Igloo> It's a make bug
07:24:12 <TuringTest> maybe...what version of make?
07:24:39 <ihope> Dang. @djinn took the easy way out.
07:24:55 <Igloo> 3.80 is the only version of make I know works
07:25:01 <TuringTest> This sound like a previously noticed bug -- check the ghc or haskell mailing list archive for a make bug.
07:25:54 <TuringTest> palomer_: what is the base case to apply [ (STRef foo, foo) ] ?
07:26:24 <ihope> True or false: any function in lambda calculus is the fixed point of a function in simply typed lambda calculus.
07:29:03 <TuringTest> ibid: http://www.catb.org/~esr/jargon/html/M/mu.html
07:29:27 <ihope> Well, lemme see here.
07:29:40 <ihope> A Turing machine is just the fixed point of an iterate function, aye?
07:30:00 <bosie> ihope funny i just stopped learning turing machines like a sec ago
07:30:07 <ihope> ...Hmm. Good question.
07:30:16 <TuringTest> bosie: you halted?
07:30:19 <Heffalump> ihope: probably, yes.
07:30:35 <dcoutts> SyntaxNinja, what is the scope of cabal-install? My fear is that it has too large a scope and so will not serve the purpose of a stable interface to existing and future versions of the cabal libs & file format. The user should (almost) never have to upgrade the cabal/cabal-install prog.
07:30:41 <bosie> TuringTest ;)
07:30:47 <ihope> Well, a Turing machine returns something of type TuringTape.
07:31:04 <ihope> The iterate function is (TuringTape -> TuringTape).
07:31:04 <bosie> sorry i thought you were talking about something else
07:31:23 <ihope> But how do we know whether it halted or not?
07:31:36 <dcoutts> SyntaxNinja, I was thinking of something that would be really very simple and still work with new versions of cabal without being upgraded, something simple that could come with the compiler for example.
07:31:40 <TuringTest> ihope: no.  you need the location on the tape explicitly somewhere
07:31:59 <TuringTest> unless that is part of the TuringTape type
07:32:06 <ihope> It would be, I think.
07:32:40 * ihope goes off to eat
07:34:07 <palomer_> TuringTest, I don't care what it returns, really
07:34:44 <sethk> if you are going to emulate a turing machine, then you have to emulate a turing machine, so you care what it returns
07:34:49 <TuringTest> apply :: [ (STRef s foo, foo ] -> ST s ()
07:34:57 <TuringTest> apply [] = return ()
07:35:16 <palomer_> righto
07:35:20 <sethk> if that's not the goal, then my comment doesn't apply, I guess
07:35:24 <TuringTest> apply ( (ref, x) : rest ) = writeSTRef ref x >> apply rest
07:35:43 <xinming1983> hmm, How can I resolve this problem please? Sorry for my poor Internet contection, :-/
07:36:05 <TuringTest> apply :: [ (STRef s foo, foo ) ] -> ST s ()
07:36:10 <Igloo> Hmm, splitAts :: [Int] -> [a] -> [[a]] doesn't come out as a nice one-liner, right?
07:36:26 <TuringTest> But apply does not remember how to undo the writeSTRef.  So I hope you do not need the old values
07:36:43 <palomer_> http://www.rafb.net/paste/results/uLjVm931.html
07:36:53 <palomer_> TuringTest, the old values are always the same
07:37:20 <TuringTest> palomer_: your line 11 is wrong : you cannot have an infinite tuple
07:37:29 <Heffalump> \as -> zipWith splitAt (repeat as)
07:37:31 <Heffalump> surely?
07:37:41 <TuringTest> palomer_: You are deconstructing a list, you need a colon :
07:37:42 <ibid> TuringTest: hrm?
07:38:19 <TuringTest> ibid: infinitely  nested tuples do not exist.
07:38:58 <Igloo> It should chop it into pieces, e.g. splitAts [3,4,5] ['a'..'z'] == ["abc", "defg", "hijk", "l..z"]
07:39:11 <TuringTest> palomer_ : of course the same bug is in line 14
07:39:12 <palomer_> @hoogle readSTRef
07:39:12 <lambdabot> Data.STRef.Lazy.readSTRef :: STRef s a -> ST s a
07:39:12 <lambdabot> Data.STRef.readSTRef :: STRef s a -> ST s a
07:39:20 <palomer_> TuringTest, yeah, everything is fixed
07:39:24 <xinming1983> No one would help? :-S
07:39:50 <TuringTest> palomer: yeah, pasting that made things much much clearer
07:40:26 <Cale> xinming: building GHC takes quite a long time
07:40:58 <Cale> xinming: I think there was a bug in make though which made it spin at 100% cpu
07:41:45 <Cale> xinming: I recommend not building GHC if you can avoid it. Unless you're going to actually work on it, or you're on a very strange platform, there shouldn't be any need.
07:41:46 <sethk> Cale, still there in the distribution?
07:42:12 <Heffalump> or you're using gentoo :-)
07:42:46 <Cale> Heffalump: even if you're using gentoo, there's a binary package now
07:42:55 <xinming1983> Cale: hmm, I'm now trying the snapshot version, Pugs needs 6.4.1, I use Debian, ghc in testing is 6.4. It's a pain to choose sid sometimes. :-/
07:43:29 <Cale> xinming: yeah, I use unstable, which gets me 6.4.1
07:43:42 <Cale> I find it odd that 6.4.1 isn't in testing
07:43:55 <Heffalump> Cale: yes, but gentoo encourages recompilation from source
07:44:05 <Cale> Heffalump: it's a bad idea in this case
07:44:14 <Cale> (in my opinion anyway)
07:44:20 <Heffalump> igloo: how long can the line be? :-)
07:44:28 <sethk> Cale, it's a bad idea in most cases, not just this case
07:44:33 <Igloo> Heffalump: Huh?
07:44:37 <Igloo> Oh, I see
07:44:45 <Igloo> "nice" is the operative word
07:44:48 <Heffalump> if you define splitBetween it becomes quite a short one-liner.
07:44:49 <Cale> sethk: well, yes, but an especially bad one here
07:44:50 <ihope> So running a Turing machine requires knowing the initial state of it.
07:45:21 <Heffalump> \ns as -> zipWith3 splitBetween ns (tail ns) (repeat as)
07:45:32 <Igloo> I think I'll just recommend he writes splits as a recursive function
07:45:47 <musasabi> an EitherN (for N=1..) datatype would be nice.
07:45:54 <Heffalump> splitBetween m n as = fst . splitAt n . snd . splitAt m
07:45:56 <sethk> Cale, I agree the lack of gain is exacerbated by the time and effort involved
07:45:57 <Igloo> (someone's sent a bug report with   scanl (flip ($) . snd) ([], toSplit) (map splitAt splitPoints)   in)
07:46:11 <Igloo> Oh, and a   map fst $ tail   on the front of course
07:46:21 <Heffalump> s/ as//
07:46:34 <sethk> Cale, but in general, 0 gain for a small effort is just as foolish as 0 gain for a larger effort.  :)
07:46:58 <Heffalump> @pl let splitBetween m n = fst . splitAt n . snd . splitAt m in \ns as -> zipWith3 splitBetween ns (tail ns) (repeat as)
07:46:59 <lambdabot> (. repeat) . ap (zipWith3 (((fst .) .) . flip ((.) . splitAt) . (snd .) .
07:46:59 <lambdabot> splitAt)) tail
07:47:06 <Heffalump> suggest they use that instead ;-)
07:47:14 <Igloo> :-)
07:47:36 <Heffalump> well, it's about as readable.
07:48:52 <TuringTest> ihope: I think of a TuringMachine and a TuringTape separately, that is why I misread your type
07:49:48 * xinming1983 wonders why if I install ghc 6.4.1 in debian will cause the needs of dist-upgrade of the system. :-/
07:50:12 <xinming1983> Cale: It's a bug in Make. It also hangs in snapshot of ghc.
07:55:19 <SyntaxNinja> dcoutts: yeah, I've been considering having another program between cabal-install and ./setup.
07:55:58 <dcoutts> SyntaxNinja, so cabal-install does? does it include dep resolution and/or download?
07:56:44 <palomer_> http://www.rafb.net/paste/results/6FOqMH63.html
07:57:12 <ihope> @help babel
07:57:12 <lambdabot> usage: babel lang lang phrase
07:57:26 <ihope> @babel de en Bitte waehlen Sie eine Beerdigungnachricht
07:57:28 <lambdabot>  Please you select a funeral message
07:57:38 <dcoutts> SyntaxNinja, if so then it's probably more than we can cope with in a tool that has to cope with many versions of the libs & file format
07:57:57 <dcoutts> SyntaxNinja, dep resolution in particual gets more complex as we add more features
07:58:00 <SyntaxNinja> dcoutts: it doesn't do download; and for now doesn't do dep resolution
07:58:09 <SyntaxNinja> cabal-get does the download
07:58:16 <dcoutts> SyntaxNinja, oh, ok. What is it's scope exactly?
07:58:26 <dcoutts> SyntaxNinja, perhaps we're talking about the same thing.
07:58:28 <palomer_> any ideas?
07:58:32 <waern> dcoutts, I have hIDE up and running now! :)
07:58:40 <dcoutts> waern, hey well done
07:58:40 <SyntaxNinja> cabal-install --prefix=/tmp --user foo.tar.gz bang/bang.cabal 
07:58:57 <dcoutts> SyntaxNinja, ah so it includes untaring, ok
07:59:06 <waern> dcoutts, the cabal repository was actually 1.1.3 but the makefile registered it as 1.0 :/
07:59:24 <waern> dcoutts, the cabal repository in ghc/libraries that is
07:59:31 <SyntaxNinja> dcoutts: basically compiles the setup program, or just interprets it w/ runhugs, configures, builds, installs, unpacks.
07:59:38 <dcoutts> waern, I don't really know anything about that
08:00:00 <waern> yeah well ok
08:00:11 <SyntaxNinja> dcoutts: but if you give it a set of cabal packages, I'd like it to install them in the right order
08:00:39 <dcoutts> SyntaxNinja, ok, so it's a tool for end users to install a package, not for people working with a package in a build tree.
08:01:19 <SyntaxNinja> dcoutts: right. but I was thinking of having it do a bit more. basically by default, install, but maybe you could have it build instead
08:01:27 <dcoutts> SyntaxNinja, it'd be nice if the dep resolution were in the Cabal library, since then hIDE & VS could use it too.
08:01:49 <SyntaxNinja> also I'd like to integrate support for a "closed" package database in cabal-install, maybe
08:01:55 <SyntaxNinja> dcoutts: yeah, it should be moved from cabal-get to cabal.
08:02:10 <SyntaxNinja> dcoutts: unfortunitely, that code would need to be refactored because it's highly tied to downloading.
08:03:18 <dcoutts> SyntaxNinja, I was initially thinking of something minamilistic that passes on most/all commands to the setup program that it builds. So it's only job would be to select the right Cabal lib version for the .cabal file in question and build/interpret the Setup.lhs (or a default if it were missing).
08:03:58 <SyntaxNinja> dcoutts: right. so like I said, I'm thinking about that, but I feel like it would be annoying to have Yet Another Program layered in there.
08:04:34 <dcoutts> SyntaxNinja, yeah maybe, though there are different audiences with slighlt different needs, package developers and package users
08:05:03 <dcoutts> package users start with a desire to install a package either from hackage or that they downloaded themselves
08:05:10 <SyntaxNinja> yeah. 
08:05:23 <dcoutts> they would like automatic package dep selection etc
08:05:55 <SyntaxNinja> so the only thing that cabal-install does now that you don't like is that it builds and installs the package as the only option; you'd like it to just build it.
08:06:01 <SyntaxNinja> or optionally build it
08:06:03 <dcoutts> package developes have a build tree and want to do various things including incremental rebuilds
08:06:26 <dcoutts> SyntaxNinja, I wonder if we are putting the layers at the right places
08:06:45 <dcoutts> since at the top level we want dep resolution and downloads too I guess
08:06:57 <dcoutts> so is that another layer on top of cabal-install?
08:07:21 <dcoutts> my suggestion would be a minimal impedance layer for building the setup prog
08:07:42 <dcoutts> and then a top layer focused on the users desire to install a package
08:08:33 <SyntaxNinja> maybe cabal-get should be the only top layer, but I wanted to separate the downloading from the installing bits.
08:08:37 <dcoutts> so no additional layer between having an unpacked cabalised build tree and the top cabal-get layer
08:09:22 <SyntaxNinja> cabal-get: downloads and does some dependency stuff, cabal-install: installs a given set of packages, cabal-setup: compiles/interprets the Setup file if appropriate, setup does what setup always does.
08:09:29 <SyntaxNinja> a little complex.
08:10:02 <palomer_> http://www.rafb.net/paste/results/R4d3JE39.html
08:10:06 <SyntaxNinja> there's really no reason we need cabal-setup if we could count on runhaskell; I think it's silly to add cabal-setup to the compilers, honestly.
08:10:20 <dcoutts> we can't count on runhaskell
08:10:30 <SyntaxNinja> we can count on it as much as we can count on cabal-setup :)
08:10:32 <dcoutts> not that it doesn't exist or doesn't work but it's not sufficient
08:10:42 <SyntaxNinja> why not?
08:10:48 <palomer_> anyone have any ideas?
08:10:50 <SyntaxNinja>  oh, because you want it to detect which versin of cabal it needs
08:11:05 <dcoutts> it's about selectign the version of the Cabal libs that will be used to build the Setyp.lhs prog
08:11:14 <dcoutts> it uses the currently exposed version
08:11:24 <dcoutts> but we need the version that is compatible with the .cabal file
08:11:33 <dcoutts> which is specified in a field in the .cabal file
08:11:51 <dcoutts> and we want to do magic like -fignore-all-packages
08:12:14 <dcoutts> so that people don't accidentally include dependencies on other packages into their Setup.lhs files
08:12:37 <Cale> palomer: hmm -- the error occurs on a line which you didn't paste?
08:13:21 <SyntaxNinja> dcoutts: well, the problems w/ building the Setup.lhs program might be transitory, really.
08:13:27 <dcoutts> SyntaxNinja, and i'm not sure about JohnMeacham's question/problem with runhaskell and the Haskell implementation we want to build the package for.
08:13:35 <dcoutts> SyntaxNinja, because?
08:13:45 <palomer_> Cale, nope, on the main
08:13:56 <SyntaxNinja> dcoutts: because the hooks interface is not going to be experimental forever.
08:14:05 <palomer_> oh, I screwed up the paste
08:14:06 <palomer_> one sec
08:14:15 <SyntaxNinja> dcoutts: some of hte problem comes from people using the darcs version.
08:14:37 <Cale> oh, I see
08:14:41 <dcoutts> SyntaxNinja, but it still happens every time we add a new field to the .cabal file.
08:14:46 <SyntaxNinja> dcoutts: I think you should become a cabal hacker. i need help w/ this stuff.
08:15:06 <dcoutts> SyntaxNinja, I would like to get involved, it's a matter of time comittments.
08:15:30 <dcoutts> SyntaxNinja, my plan is to get gtk2hs to work with cabal eventually so that will need several cabal patches.
08:15:44 <dcoutts> and hIDE has some interaction with cabal too
08:16:13 * SyntaxNinja nods
08:16:21 <dcoutts> SyntaxNinja, perhaps I should make a concrete implementation of this wrapper script thingy
08:16:32 <dcoutts> based on what our gentoo cabal eclass does
08:16:39 <SyntaxNinja> yeah, that would be nice.
08:16:53 <dcoutts> then we could try it and see if I'm talking nonsense
08:17:00 <dcoutts> or if it solves any problems
08:17:14 <SyntaxNinja> you should look at the tricks cabal-install does to parse the command line, fwiw.
08:17:27 <dcoutts> one thing that would help is if the .cabal file parser was a biy less strict about fields it doesn't know about.
08:18:07 <dcoutts> have the rejection based on unknown fields done at a higher level
08:18:17 <SyntaxNinja> dcoutts: yeah, that might be nice.
08:18:21 <dcoutts> so that some tools can work with several versions
08:18:29 <dcoutts> and just ignore fields they don't know about
08:18:35 <SyntaxNinja> but really, it _is_ going to stabalize somewhat some day! and the more hackers we can get on it, the faster that'll happen
08:18:46 <SyntaxNinja> my ambition is to stabalize cabal and focus on layered tools more.
08:19:01 <SyntaxNinja> that way there will be less breakage when we change stuff.
08:20:04 * dcoutts darcs gets cabal
08:20:43 <SyntaxNinja> dcoutts: trouble is that people keep seeing the promise that cabal offers w/ complex packages, but no one wants to do the work to make that promise come alive :)
08:20:52 <dcoutts> yeah :-)
08:20:58 <Cale> palomer: comment out main, and ask ghci what it infers as the type of doit
08:21:30 <palomer_> doit :: ST () (Maybe [Char])
08:21:31 <SyntaxNinja> dcoutts: kinda like Haskell itself ;)
08:21:47 <dcoutts> heh, more people with ideas than implementations
08:22:07 <Cale> palomer_: right, so something's obviously gone wrong there
08:22:15 <palomer_> Cale, probably in apply/unapply
08:22:22 <edwinb> Can cabal build a library then an executable that depends on that library?
08:22:24 <edwinb> I'd quite like that...
08:22:32 <Cale> palomer_: nope, in bloo
08:22:44 <Cale> bloody MR :)
08:23:00 <palomer_> hmm?
08:23:06 <Cale> ask for the type of bloo and compare it with the type of return
08:23:38 <TuringTest> I expect you want bloo :: [ (STRef s a,a) ] -> ST s (STRef s a)
08:23:54 <TuringTest> oh
08:24:11 <TuringTest> List is a monad
08:24:17 <Cale> no, just bloo :: a -> ST s a
08:24:59 <Cale> since it's a pattern binding, the MR applies, and forces bloo to be monomorphic
08:25:20 <Cale> if you write bloo x = return x, it'll work
08:25:25 <Cale> or write a proper type sig
08:25:55 <palomer_> bloo :: forall a. a -> ST () a
08:26:02 <Cale> right, that's wrong
08:26:15 <palomer_>  that's really strange
08:27:05 <palomer_> ok, so ReaderT will work, I'll pass around the STRefs and nothing more
08:27:07 <palomer_> how do I do thisL
08:27:08 <palomer_> ?
08:27:20 <TuringTest> The MR that bit you is heavily discussion on the Haskell' mailing list
08:27:35 <palomer_> monad restriction?
08:27:43 <Cale> monomorphism restriction
08:29:12 <TuringTest> palomer_: http://www.haskell.org/onlinereport/decls.html#sect:monomorphism-restriction 
08:30:54 <Cale> so s is getting considered to be ambiguous and being defaulted to ()
08:31:09 <Cale> which breaks, because runST requires that polymorphism
08:32:13 <TuringTest> Cale: Is there a Haskell compiler that emits all the type signatures it infers (as an optional feature)?
08:32:29 <Cale> I think there's a way to get GHC to do it
08:33:26 <palomer_> is there a monad which only has "get" ?
08:33:38 <Cale> palomer_: that's Reader
08:33:38 <palomer_> I just don't want to pass around this one argument all the time
08:33:45 <Cale> it's called ask there
08:33:47 <palomer_> Cale, reader has also runlocal
08:33:56 <palomer_> this is even simpler
08:34:20 * TuringTest nods
08:34:23 <palomer_> Cale, so how do I use ReaderT with ST?
08:34:41 <Cale> (ReaderT r ST) is your monad
08:34:55 <Cale> where r is whatever type you like
08:35:07 <TuringTest> palomer_: look at the example at the bottom of http://haskell.org/hawiki/ImperativeHaskell for ReaderT r IO
08:35:18 <TuringTest> as an example
08:35:49 <SyntaxNinja> edwinb: yeah, it can, though we might remove this feature because it's a bit hackish. it's definitely cleaner to break it into separate packages.
08:35:54 <palomer_> thx
08:36:04 <franka> Isn't it ReaderT a (ST r) or something?
08:36:05 <JohnMeacham> dcoutts: indeed. I think we really need to make cabal a program (at least optionally) because this sort of problem is going to crop up a lot and we really gain nothing from having it required to be a library.
08:36:12 <franka> (he says without consulting the docs)
08:36:31 <JohnMeacham> dcoutts: it is just a brittle set up.
08:36:35 <palomer_> @hoogle liftST
08:36:36 <lambdabot> No matches found
08:36:38 <palomer_> @hoogle liftIo
08:36:39 <lambdabot> Control.Monad.Trans.liftIO :: MonadIO m => IO a -> m a
08:36:39 <lambdabot> Graphics.UI.ObjectIO.StdIOBasic.liftIO :: IOMonad m => IO a -> m a
08:36:55 <TuringTest> @hoogle lift
08:36:55 <dcoutts> JohnMeacham, so how would you see Cabal working when someone has ghc and jhc on their system?
08:36:56 <lambdabot> Text.ParserCombinators.ReadPrec.lift :: ReadP a -> ReadPrec a
08:36:56 <lambdabot> Control.Monad.Trans.lift :: (MonadTrans t, Monad m) => m a -> t m
08:36:56 <lambdabot> a
08:36:56 <lambdabot> Language.Haskell.TH.Syntax.Lift :: Lift t
08:37:20 <TuringTest> palomer: you should only need lift 
08:37:40 <JohnMeacham> dcoutts: cabal configure --compiler jhc
08:37:48 <JohnMeacham> dcoutts: cabal configure --compiler ghc
08:38:17 <TuringTest> liftIO is ultimately just iterated lift, and you only need a single lift
08:38:59 <ihope> Hmm, what's a MonadIO?
08:40:38 <ihope> Is there a MonadMaybe too?
08:40:42 <JohnMeacham> I should say, I am perfectly willing to put my money where my mouth is and write said program and submit it to the repo. I just want to make sure I am not wasting my time.
08:41:38 <edwinb> SyntaxNinja: It probably is cleaner, it's just that I have a library with a small test app.
08:41:49 <edwinb> I guess I should just leave the app out of the cabal stuff.
08:45:23 <TuringTest> MonadIO is something a MonadTrans can implement that allows liftIO.  It just iterates lift until you get to the undermost Monad, which is IO
08:46:46 <dcoutts> JohnMeacham, I'm looking at doing the same thing, perhaps we can work on it together
08:47:45 <dcoutts> SyntaxNinja, would it be ok to just emit a warning if a field is not understood then? I've got a one line patch to do that.
08:47:54 <palomer_> @hoogle ask
08:47:55 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
08:47:55 <lambdabot> Control.Monad.Reader.asks :: MonadReader r m => (r -> a) -> m a
08:47:55 <lambdabot> Graphics.Rendering.OpenGL.GL.Framebuffer.indexMask :: StateVar GLuint
08:48:14 <dcoutts> SyntaxNinja, Though it uses trace which seems less than nice. But I note that the parser already uses trace to emit warnings rather than accumulating them in the ParseResult
08:49:18 <JohnMeacham> dcoutts: if you are changing that, can you also make it ignore and not warn about any fields starting with 'x-'
08:49:34 <dcoutts> JohnMeacham, yeah, that'd be good.
08:49:44 <SyntaxNinja> dcoutts, JohnMeacham: sounds
08:49:46 <SyntaxNinja> good
08:49:58 <ihope> @type (Nothing >>=) `asTypeOf` Control.Monad.Cont.callCC
08:49:59 <lambdabot>   No instance for (Control.Monad.Cont.MonadCont Maybe)
08:49:59 <lambdabot>   arising from use of `Control.Monad.Cont.callCC' at <interactive>:1:25-
08:49:59 <lambdabot> 49
08:50:07 <dcoutts> SyntaxNinja, so trace for a warning on unknow fields is ok by you?
08:50:15 <palomer_> http://www.rafb.net/paste/results/3cvit740.html
08:50:57 <JohnMeacham> gotta go to work. will catch up later.
08:51:11 <SyntaxNinja> dcoutts: if it's already happening, go ahead, but if it's not hard to do it the right way, please do it the right way :)
08:51:15 <dcoutts> JohnMeacham, right o
08:51:24 <SyntaxNinja> l8r JohnMeacham
08:51:38 <dcoutts> SyntaxNinja, mmm, I can change the ParseResult monad I guess.
08:51:49 <ihope> @type (Nothing >>=)
08:51:50 <lambdabot> forall a b. (a -> Maybe b) -> Maybe b
08:52:11 <SyntaxNinja> dcoutts: to add a Warning field or something?
08:52:13 <ihope> instance MonadCont where callCC = (Nothing >>=)
08:52:15 <SyntaxNinja> 'twould be nice.
08:52:31 <dcoutts> SyntaxNinja, right
08:52:53 <dcoutts> data ParseResult a = ParseFailed PError | ParseOk a
08:52:56 <dcoutts> becomes
08:52:57 <TuringTest> palomer: reading
08:53:05 <dcoutts> data ParseResult a = ParseFailed PError | ParseOk PWarnings a
08:53:18 * palomer_ loves $
08:53:43 <TuringTest> palomer:  You musts not use runST $
08:53:55 <TuringTest> it has to do with the type of runST
08:54:06 <SyntaxNinja> dcoutts: sounds good. how hard?
08:54:09 <TuringTest> You have to use runST ( doit Nil )
08:54:16 <dcoutts> SyntaxNinja, I'll see... :-)
08:54:33 <franka> SyntaxNinja: I see you and raise twenty.
08:55:06 <TuringTest> palomer: You should really try writing explicit type signatures when using ST.
08:56:51 <TuringTest> palomer:  You need a runReader or similar to use a ReaderT
08:57:39 <palomer_> oh,righto
08:57:55 <palomer_> @hoogle runReaderT
08:57:56 <lambdabot> Control.Monad.Reader.runReaderT :: ReaderT r m a -> r -> m a
08:58:40 <palomer_> oh my
08:58:45 <palomer_> monad transformers hurt my head
08:58:48 <palomer_> gotta go
08:59:15 <palomer_> wait
08:59:22 <palomer_> I just realized that my STRefs have to come from somewhere
08:59:32 <palomer_> so this readerT will have to work INSIDE ST
08:59:38 <palomer_> this is pretty screwed up
08:59:48 <palomer_> isn't there an STT ?
09:00:18 <Cale> nope, no STT
09:00:42 <palomer_> so its okay to use a readerT inside an ST? so it'll be an ST using a readerT using an ST
09:00:47 <palomer_> 3 layers of abstraction!
09:00:51 <palomer_> oh my
09:01:06 <palomer_> oh, screw this, I'll just pass the argument every time
09:01:32 <palomer_> bbl
09:02:30 <nonon> @find xhtml
09:02:31 <lambdabot> Not in scope: type variable `xhtml'
09:02:39 <nonon> !list
09:08:16 <franka> I think palomer's brain is about to explode.
09:09:54 <TuringTest> palomer: Oh.. you left
09:10:24 <TuringTest> palomer_ I have to go as well, but here is a link to a paste with working code
09:10:34 <Cale> franka: he's sort of jumping right into the thick of things
09:10:45 <TuringTest> http://www.rafb.net/paste/results/BiRO4038.html
09:10:49 <TuringTest> oh well
09:11:17 <TuringTest> He never write the type signatures, which makes it way to hard to learn new things
09:12:55 <TuringTest> I like the idiom of wrapping ST in a transformer, however.
09:13:16 <franka> Yes, he is humping the thick of thongs.
09:13:26 <franka> I mean, jumping into the thing of things.
09:13:34 <franka> think
09:13:36 <franka> thick
09:14:01 <Cale> @help quote
09:14:01 <lambdabot>  @quote <nick>/@quote-add <nick> <quote>
09:14:01 <lambdabot> Quote somebody, or a random person, or save a memorable quote
09:14:03 * TuringTest sees franka is still talking to himself
09:14:05 * franka nods knowledgeably.
09:14:22 <Cale> @quote-add franka Yes, he is humping the thick of thongs.
09:14:53 <Cale> excellent typo :)
09:14:57 <franka> I'm just such an infuriatingly quotable prick, aren't I?
09:15:10 <franka> Er, that was no typo.
09:15:35 <Cale> ah, I thought it was a bit too much of a coincidence
09:16:02 <franka> Cale, you must never assume.
09:16:11 <franka> Because when you ASSUME, you make an ASS out of U and ME.
09:16:33 <Cale> You have to assume something, or you'd never come to any conclusions.
09:17:00 <TuringTest> Can you derive that statement?
09:17:17 <franka> It is inderivaribabuble.
09:17:48 <Cale> I might be able to formalise it and give it a meta-proof.
09:18:06 <TuringTest> gÃ¶del would approve
09:18:20 <franka> But I do not.  Twenty lashes!
09:18:38 <franka> And a long hard screw agains the wall, bartender.
09:18:39 <TuringTest> instance Lashes Eyer where...
09:19:37 <TuringTest> Eyer --? Eyes
09:19:49 <TuringTest> crap...it is contagioueus
09:20:31 <TuringTest> Cale: If palomer comes back, tell him to look a the logs for the link to the paste of the code he wishes he could Type.
09:20:40 <TuringTest> I have to go
09:20:47 * TuringTest leaves
09:21:00 <franka> Ciao, TuringTest.
09:21:39 <TuringTest> (toLocal "Cheers")
09:42:12 <jethr0_> isn't there some nice form of a comined sort and group
09:42:29 <jethr0_> first sorting and then grouping by the nearly the same predicate seems so superfluous
10:25:31 <nerdlor> Hi haskellers. I have a function akin to this one:
10:25:34 <nerdlor> doit [] = []; doit (x:xs) = if x == 7 then [] else x:doit xs
10:25:43 <nerdlor> which collects everything up to the 7
10:26:01 <nerdlor> what I want is to return Just [] if there was no 7
10:26:04 <nerdlor> and Nothing if there was
10:26:18 <nerdlor> and the "Monad" part of my brain isn't working right now :(
10:26:35 <nerdlor> mapM works with this:
10:26:38 <nerdlor> f x = if x == 7 then Nothing else Just x
10:26:50 <nerdlor> but not with "doit" above
10:27:39 <edwinb> hmm
10:28:23 <Heffalump> you want to return Nothing if there _was_ a 7, but Just [] if there wasn't?
10:28:24 <nerdlor> I have a feeling I'm supposed to be "lifting", but that could just mean that I should shut things down and go to sleep.
10:28:42 <nerdlor> ah, i should say Just [...the entire list...]
10:28:45 <nerdlor> not the empty list
10:29:05 <nerdlor> doit [1, 2, 3, 4] ---> [1, 2, 3, 4]
10:29:11 <nerdlor> doit [1..7] ---> Nothing
10:29:14 <nerdlor> I'm sorry
10:29:18 <nerdlor> Just [1, 2,3 , 4] above
10:29:28 <Heffalump> doit xs = if any (==7) xs then Nothing else Just xs
10:30:00 <nerdlor> ah, there is that
10:30:20 * edwinb prods his network connection to stop dying when in the middle of answering something ;)
10:31:06 <nerdlor> is there a way to express it like so, though:
10:31:07 <nerdlor> but let's say I'm interested in
10:31:11 <nerdlor> (crap)
10:31:16 <nerdlor> doit [] = []; doit (x:xs) = if x == 7 then [] else x:doit xs
10:31:32 <nerdlor> (the ==7 is contrived in this example)
10:32:23 <Heffalump> doit [] = Just [] ; doit (x:xs) = if x == 7 then Nothing else liftM (x:) (doit xs)
10:32:27 <nerdlor> doit [] = Just []; doit (x:xs) = if x == 7 then Nothing  else <?some just/fromMaybe stuff here?> x:doit xs
10:32:29 <Heffalump> (not tested or typechecked, but that's my guess)
10:32:43 <nerdlor> ah
10:32:53 <Heffalump> and maybe s/liftM/fmap/ depending on your mood
10:33:12 <Heffalump> (they are equivalent, but in different typeclasses, and some people get religious over using one or the other in certain contexts)
10:33:12 <nerdlor> Heffalump: very good -- that's the ticket!
10:33:15 <nerdlor> i thank you
10:36:12 <dons> @seen musasabi
10:36:13 <lambdabot> musasabi is in #haskell-blah and #haskell. Last spoke 37 minutes and 25
10:36:13 <lambdabot> seconds ago.
10:36:34 <dons> musasabi, a faster partial-sums is at: http://www.haskell.org/hawiki/PartialSumsEntry
10:37:59 * musasabi looks at it
10:40:31 <musasabi> dons: committed.
10:41:37 <dons> also, mandelbrot and nbody didn't get rerun with the -fexcess-precision flags, any idea why? 
10:45:54 <araujo> @index sort
10:45:55 <lambdabot> Data.List
10:46:25 <araujo> dons, hiya!
10:46:54 <musasabi> dons: nbody has had fexcess-precision the whole time.
10:47:25 <musasabi> dons: as for mandelbrot I even touched the entry and recommitted, but still no rerun.
10:53:17 <dons> hmm.
10:55:27 <dons> musasabi, looking at the build log for n-body, it says: /usr/bin/ghc -O3 -optc-O3 -fglasgow-exts -fno-excess-precision -fglasgow-exts
10:55:54 <dons> last run Jan 28
10:58:03 <musasabi> dons: sounds very strange. "grep no-ex nbody/*" returns nothing for me.
11:02:00 <dons> is it possible that you changed the flags, but it didn't get rerun?
11:02:25 <dons> i'm looking at: http://shootout.alioth.debian.org/gp4/benchmark.php?test=nbody&lang=ghc&id=0
11:05:54 <dons> yeah, I see your cvs diff to nbody, you removed -fno-excess-precision on the 28th.
11:06:30 <dons> but it hasn't been rerun since then? or it was run, but with the old flags?
11:13:35 <musasabi> hmm, seems still in need of rerun.
11:27:00 <dons> did you see the partial-sums was as fast as C (until last night when they vectorised the C entry :/ )
11:27:44 <Philippa_> yuck, I swear that should count as cheating
11:28:03 <Philippa_> or else, there should be a separate "portable code only" section
11:30:07 <dons> nah, we all take advantage of cpu stuff. they ust use -msse, which isn't very helpful to us, unfortunately. but they can do it, we can't. oh well.. someone should add sse instrs to the -fasm generator
11:51:43 <dons> @yow
11:51:43 <lambdabot> I once decorated my apartment entirely in ten foot salad forks!!
11:52:32 <jethr0_> /quit/quit
11:55:06 <shapr> on-topic entertainment: http://lwn.net/Articles/169974/
12:12:29 <shapr> That's awesome, an article on monads in the linux journal!
12:13:02 <shapr> bah, Cale beat me there...
12:33:57 <orbitz> hrm, is ther ea math module or soem docmetnation for a math module i can find? lookign ofor natural log
12:36:08 <joelk> > log 2.7 -- like that?
12:36:10 <lambdabot> 0.9932517730102834
12:36:26 <orbitz> yesm
12:36:33 <orbitz> wher do i hav eot do to find thos eon my own?
12:36:54 <joelk> It's in the prelude... perhaps the class Real
12:37:02 <joelk> @type log
12:37:03 <lambdabot> forall a. (Floating a) => a -> a
12:37:10 <joelk> ah, Floating
12:37:39 <joelk> you can use lambdabot's index command, like this
12:37:41 <joelk> @index log
12:37:42 <lambdabot> Prelude
12:38:13 <orbitz> thanks
12:38:22 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/index.html -- here are the libraries which come with GHC, you can also look through them and find lots of cool stuff.
12:43:11 <joelk> orbitz, and there's also hoogle
12:43:13 <joelk> @where hoogle
12:43:14 <lambdabot> http://www.haskell.org/hoogle
12:44:35 <orbitz> thanks
13:09:35 <ihope> @djinn (a -> a) -> (a -> b -> b) -> b -> b
13:09:35 <lambdabot> f _ _ a = a
13:09:42 <ihope> ...
13:10:28 <ihope> Now, I *thought* djinn could solve this Big Problem...
13:10:47 <ihope> Hee hee.
13:10:57 <kevind> f g h x = h (fix g) x
13:11:05 <ihope> No fix allowed.
13:11:56 <ihope> I'm trying to figure out a Haskell without recursion.
13:13:07 <ihope> @djinn ((a -> a) -> (a -> a)) -> a -> a
13:13:07 <lambdabot> f a b = a (\ c -> c) b
13:13:27 <ihope> ...Is that right?
13:13:49 <ihope> ...No.
13:13:58 <kevind> well, its definately the identity
13:14:22 <ihope> Yes...
13:15:25 <ihope> What I'm looking for is a non-recursive version of (fix :: ((a -> a) -> (a -> a)) -> a -> a).
13:16:12 <ihope> Is it possible?
13:17:13 <kevind> uh, isnt that recursion?
13:17:55 <ihope> Well, the idea is that there's still some room left for holding a lack of definite value.
13:18:12 <ihope> Just like in [[a]] -> [a], there's still some room left for holding multiple values.
13:18:56 <kevind> hmm, I don
13:19:11 <kevind> err, I don't think that will work if -> doesnt have recursion
13:19:29 <kevind> including that last ->
13:19:47 <ihope> Well...
13:20:17 <ihope> We're given an a and an ((a -> a) -> (a -> a)).
13:20:49 <ihope> To grab the a from the ((a -> a) -> (a -> a)), we need an (a -> a) and an a.
13:21:15 <ihope> The question, of course, is "where does the (a -> a) come from?".
13:21:33 <kevind> I'm confused
13:21:56 <ihope> Well, I think you're right. There is no answer.
13:22:14 <kevind> there are some trivial answers
13:22:21 <ihope> Yes, there are.
13:22:27 <ihope> But are any of them equal to fix?
13:22:56 <kevind> only if they use recursion
13:23:02 <ihope> Now, if ((a -> a) -> a -> a) -> a -> a were in the Num class, we could easily have an answer.
13:23:08 <ihope> Namely, fromIntegral 42.
13:23:10 <ihope> ;-)
13:23:17 <kevind> heh
13:23:22 <ihope> Well, I guess I need to rework this, then.
13:23:45 <ihope> One nice answer would be to have this monad be abstract.
13:23:56 <kevind> what are you trying to do
13:24:09 <ihope> I'm trying to make a monad for recursion.
13:24:40 <kevind> ah, so use recursion
13:24:59 <ihope> Use recursion in my monad for recursion?
13:25:19 <dons> a monad for recursion?
13:25:25 <ihope> Yep.
13:25:33 <kevind> fixM :: Monad M => ((a -> M a) -> (a -> M a)) -> a -> M a 
13:25:46 <kevind> you need recursion to have recursion
13:25:48 <SamB> eh
13:25:59 <SamB> @hoogle fixM
13:25:59 <lambdabot> No matches found
13:26:06 <SamB> @hoogle MonadFix
13:26:07 <lambdabot> Control.Monad.Fix.MonadFix :: Monad m => MonadFix m
13:26:16 <SamB> @hoogle mfix
13:26:16 <lambdabot> Control.Monad.Fix.mfix :: MonadFix m => (a -> m a) -> m a
13:26:27 <ihope> @type Control.Monad.Fix.MonadFix
13:26:28 <lambdabot> Not in scope: data constructor `Control.Monad.Fix.MonadFix'
13:26:32 <ihope> ...Right
13:26:34 <dons> yeah, mfix is one of my favorites: mfix :: (a -> m a) -> m a
13:26:50 <dons> @type Control.Monad.Fix.mfix
13:26:51 <lambdabot> forall (m :: * -> *) a.
13:26:51 <lambdabot> (Control.Monad.Fix.MonadFix m) =>
13:26:51 <lambdabot> (a -> m a) -> m a
13:27:04 <ihope> Hmm. Sounds about right.
13:27:15 <dons> for monadic fix points
13:27:30 <dons> heya SamB, how's code?
13:27:36 <SamB> hmm.
13:27:40 <SamB> let me think.
13:27:41 <dons> ooh, 1153:28 hmp3 0.3
13:27:48 <dons> I guess that's kinda stable ;)
13:27:52 <SamB> I haven't done anything in a week or so
13:27:57 <SamB> really
13:28:15 <kevind> mfix uses recursion though
13:28:25 <SamB> well, I started writing a C-- parser but it turned out someone else had already written one
13:28:37 <ihope> kevind: it's a class method, aye?
13:28:40 <SamB> writing a C-- compiler is apparantly beyond me at the moment
13:28:49 <dons> a C-- parser is already in ghc :)
13:28:59 <SamB> oh, that one doesn't actually work
13:29:00 <dons> well, most of one. then robdockins wrote one
13:29:12 <SamB> it doesn't support arguments to functions
13:29:17 <ihope> @djinn Monad m => ((a -> a) -> m a) -> (a -> m a) -> m a
13:29:18 <lambdabot> Cannot parse command
13:29:21 <dons> it works plenty fine for ghc-style .cmm files, though
13:29:23 <SamB> robdockins' is the one I meant
13:29:35 <SamB> well, yes, but I'm pretty sure those are nonstandard :-(
13:29:39 <dons> @karma+ robdockins -- for the c-- lib
13:29:40 <lambdabot> robdockins's karma raised to 1.
13:29:46 <dons> @karma+ robdockins -- for the type level arith library
13:29:46 <lambdabot> robdockins's karma raised to 2.
13:29:49 <kevind> I think any non-trivial implementation has to use recursion
13:29:49 <dons> @karma+ robdockins -- for @lam
13:29:50 <lambdabot> robdockins's karma raised to 3.
13:30:08 <SamB> I find the C-- standard overwhelming
13:30:17 <dons> it's kinda complex, no?
13:30:22 <SamB> yes!
13:30:24 <dons> there's a lot of fun corner cases
13:30:31 <SamB> I feel as if it would be easier to write a C compiler!
13:30:40 <SamB> if only the parser was written already, that is
13:30:43 <dons> ghc uses only a very small subset of C--, just the non-insane stuff ;)
13:30:47 <ihope> 'Hope want monad. 'Hope MAKE.,
13:30:57 <dons> ah, but wait for the day we have C-- on a chip. the ghc takes over the world
13:31:11 <SamB> C-- on a chip?
13:31:15 <dons> isa level
13:31:16 <SamB> you must be joking!
13:31:26 <dons> :)
13:31:30 <SamB> that is too complicated for a chip afaict!
13:31:49 <dons> ah well. there goes my plans for world domination.
13:32:00 <SamB> continuations? activations? RTS calls? oh my?
13:32:11 <kevind> you could encode fix with references
13:32:28 <dons> you don't want continuation support on the chip? we have stack support for decades..
13:32:40 <dons> the hegemony of C should perish!
13:32:49 <SamB> well, I'm thinking of "also cuts to" or whatever
13:32:55 <SamB> all the "also" stuff
13:32:55 <dons> yeah, that's a weird one
13:32:58 <ihope> data NonTerm a = Term a | Fix (NonTerm a -> NonTerm a)
13:33:01 <ihope> Will that work?
13:33:08 <SamB> I really haven't a clue where to start
13:33:25 <SamB> it might help if they would give a simple example implementation...
13:33:46 <dons> of C--?
13:33:50 <SamB> ... written in something besides the ML-of-the-day
13:33:55 <dons> don't we have Tiger, and some other stuff?
13:34:12 <SamB> tiger?
13:34:14 <dons> ah. have you seen nr's commits into ghc?
13:34:26 <SamB> no
13:34:28 <dons> tiger, wasn't it a reference C-- compiler?
13:34:47 <SamB> I thought the reference compiler was qc--
13:34:55 <dons> ah, that's the new one
13:34:55 <kevind> ihope: sure, that works, but how do you use it?
13:35:15 <kevind> NonTerm a -> a needs recursion
13:35:20 <ihope> kevind: I was wondering how to use the old one for a long time!
13:35:57 <ihope> Well, let's try to capture the basic... you know. Stuff.
13:36:42 <dons> oh, that's interesting, now we beat C: http://shootout.alioth.debian.org/gp4/benchmark.php?test=partialsums&lang=all
13:36:46 <dons> they must have been rerun
13:38:01 <kevind> you could encode fix using references and just use IO as the non-termination monad
13:38:14 <kevind> and banish non-termination from the rest of the language :)
13:38:21 <ihope> Ooh! Ooh!
13:38:24 <ihope> Continuation!
13:38:38 * ihope runs off, screaming "CONTINUATION!"
13:39:37 <ihope> Yes! Yes!
13:40:13 <ihope> NonTerm a -> Cont (NonTerm b) a
13:43:02 <ihope> Or, put another way:
13:43:14 <ihope> NonTerm a -> (a -> NonTerm b) -> NonTerm b
13:43:16 <ihope> :-P
13:44:56 <kevind> i'm confused
13:45:35 <kevind> is that supposed to be the type of fix?
13:45:49 <ihope> No; it's supposed to be the type of (>>=).
13:46:00 <ihope> fix :: (a -> a) -> NonTerm a
13:46:39 <kevind> ah, I see
13:48:14 <ihope> My original plan was to have Term and Fix be data constructors.
13:48:48 <ihope> That might still work, if I add more.
13:49:42 <ihope> Well, I gotta go. I'll think in the morning.
14:02:01 <palomer> man, I love you guys
14:23:29 <palomer> oh, turingtest pasted some code
14:23:32 <palomer> or something
14:23:48 <palomer> I'll check the logs
14:23:49 <palomer> @logs
14:23:49 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
14:24:06 <palomer> eh?
14:24:09 <palomer> @log
14:24:09 <lambdabot> Maybe you meant: lam msg yow
14:26:23 <palomer> nice, he made my code work
14:26:47 <palomer> the s argument in ST really bothers me
14:38:00 <Cale> palomer: it's what makes the whole thing work in the first place :)
15:00:28 <SamB> palomer: see, that s is why I suggested STRef earlier
15:00:41 <SamB> er, suggested replacing STRef with IORef, rather
15:23:09 * lispy_ tries out a new irc client
15:23:24 <palomer> using IORefs is a pain
15:23:49 <palomer> they should have 2 levels of syntax
15:24:03 <palomer> one for io and one for everything else
15:25:38 <lispy_> > take 5 [1..]
15:25:40 <lambdabot> [1,2,3,4,5]
15:25:58 <lispy_> this will take some getting used to
15:26:24 <palomer> just use xchat
15:26:37 <palomer> oh, the 2 levels of syntax?
15:26:44 <lispy> xchat doesn't work from the console
15:26:54 <palomer> why do you need something from the console?
15:26:59 <lispy> besides, xchat sucks compared to erc :)
15:26:59 <Cale> lispy: sure it does
15:27:15 <lispy> Cale: they have an ncurses type interface?
15:27:18 <Cale> yep
15:27:23 <lispy> heh, i wouldn't have guessed
17:38:22 --- topic: '["Haskell is still the language of choice for discriminating hackers","logs:","http://tunes.org/~nef/logs/haskell/","http://www.haskell.org/learning.html","http://www.haskell.org/tmrwiki/IssueFive","We put the Funk in Funktion","http://sequence.complete.org/hwn/20060123","HCAR 11/2005:","http://haskell.org/communities/"]'
17:38:22 --- topic: set by SimonRC on [Wed Jan 25 01:54:56 2006]
17:38:22 --- names: list (clog ProfTeggy araujo farre Itkovian kosmikus_ khaladan marencian wli dblhelix nothingmuch vincenz iblechbot mauke gour drbean helgim Akshaal lispy` slipstream musasabi cods jlouis orbitz Revision17 ed-209 nomeata Adamant ramkrsna sumire SamB elk moonlite_ joelk kevind Lokadin perspectival ex__nor Khisanth astrolabe Heffalump fatbrain magnus-- frederik Si\Uni chucky kpreid_ dcoutts shapr tic Muad_Dibber Cale kisu takuan eno-away phredpenguin)
17:38:22 --- names: list (Trixsey kpk user317 ozone Korollary wolverian audreyt Twigathy triplah zamez lisppaste2 pesco metaperl svens arguile p_frici flux__ dcoutts_ eyck Lunar^ mornfall noj lome Nomius Poeir lucs dv_ icbt lambdabot emu Philippa_ dany2k spamsch Nanar JKnecht norpan johs cmeme wilx resiak ulfdoz earthy Godeke SimonRC integral llappala Igloo jp-autark tmoertel Matt-W cognominal WillKW_ cpatrick ibid Speck aleator cjs alec marcellus pejo Lor qwr)
17:38:22 --- names: list (palomer glasser liyang cbus dons sethk TheHunter ex_nor tewk tumm mattam binary42 boegel sieni lennart jvw scw samx tromp_ djw borism Wallbraker alch` kolmodin shrimpx magagr tic|school gdsx eivuokko ksandstr gzl neologism AtnNn edwinb xerox Gniij tuomov Spark skylan ValarQ Jaen CLxyz rep C-Keen juhp JohnMeacham stesch)
17:38:58 <vincenz> aloha
17:39:55 <Cale> @type Contol.Monad.liftM head . sequence
17:39:56 <lambdabot> Couldn't find qualified module.
17:39:56 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
17:39:56 <lambdabot> \\)?
17:40:00 <shapr> konichiwa
17:40:05 <Cale> @type Control.Monad.liftM head . sequence
17:40:06 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m a
17:41:22 <vincenz> why the head?
17:41:38 <vincenz> @type sequence
17:41:39 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
17:42:08 <vincenz> doh
18:21:16 <gour> shapr: have your tried new ekiga (aka gnomemeeting - www.ekiga.org) for voip? it supports sip and there will be win32 port
18:22:02 <shapr> Not yet, I will soon.
18:24:16 <gour> shapr: it's much easier to setup (if you're behind firewall), superb sound-quality, open-source protocols..i'm running beta here...
18:37:37 <nibro> dons: any news for me? :-)
18:44:02 <vincenz> I was thinking yesterday about a beautiful analogy
18:44:40 <vincenz> "haskell data structures are like flowers...they slowly grow out with the energy, for flowers it's the sun, for haskell it's computation"
18:45:15 <xerox> @karma+ vincenz -- for poetry :-)
18:45:16 <lambdabot> vincenz's karma raised to 1.
18:45:41 <vincenz> :)
18:46:12 <vincenz> @karma xerox
18:46:12 <lambdabot> xerox has a karma of 10
18:46:21 <vincenz> @karma shapr
18:46:21 <lambdabot> shapr has a karma of 16
18:46:25 <vincenz> @karma vincenz
18:46:26 <lambdabot> You have a karma of 1
18:46:27 * vincenz hmms
18:46:45 <vincenz> @type iterate
18:46:46 <lambdabot> forall a. (a -> a) -> a -> [a]
18:47:05 <vincenz>  > sequence . iterate ["@karma+ vincenz"]
18:47:25 <vincenz> with a $ but you get the idea :)
18:49:46 <vincenz> anyways, I have to say I'm amazed at the maturity of the haskell tools.  If you look at any other cmopiler, getting GUI or other stuff to work without haskell and compiling c sources is a B*tch....for haskell there's even a default installer for ghc AND cairo for windows
18:49:56 <vincenz> (and cairo simply ... rocks)
18:50:24 * dcoutts grins
18:50:29 <vincenz> yep from haskell-newb to haskell=lover in one weekend
18:50:49 <vincenz> that ICFP2005 experiment with jethr0 was a great learning experience
18:51:07 * vincenz now knows how to use/make monad transformers and guis
18:51:22 <vincenz> if you want to take a look at the code
18:51:59 <vincenz> http://abstractoasis.dyndns.org:8080/repos/icfp/
18:52:24 <nibro> @seen dons
18:52:24 <lambdabot> dons is in #haskell-blah and #haskell. Last spoke 1 hour, 41 minutes and
18:52:24 <lambdabot> 53 seconds ago.
18:53:04 <vincenz> dcoutts: Visualization is the part that does gui
18:53:13 <xerox> \o/
18:54:19 <dcoutts> vincenz, thanks I'll take a look
18:54:25 <vincenz> am I right in assuming that foldr1 (>>) l == sequence_
18:55:13 <xerox> Yup.
18:55:14 <vincenz> dcoutts: it has some plumbing in there to do concurrency
18:55:30 <vincenz> xerox: but safer cause it can handel empty lists []
18:55:35 <vincenz> > sequence_ []
18:55:36 <lambdabot>  add an instance declaration for (Show (m ()))
18:55:43 <vincenz> > sequence_ [[]]
18:55:44 <lambdabot> []
18:55:56 <vincenz> > sequence_ [] :: Maybe Int
18:55:56 <lambdabot> Couldn't match `Int' against `()'
18:55:59 <vincenz> > sequence_ [] :: Maybe ()
18:56:01 <lambdabot> Just ()
18:56:06 <xerox> Yep.  That's like [mzero].
18:56:22 <vincenz> xerox: IO is not a MonadPlus tho
18:56:33 <xerox> '[[]]' tat is.
18:56:37 <xerox> that, even.
18:56:53 <vincenz> xerox: another question I had
18:56:56 <xerox> I need an usb keyboard, hmpf...
18:56:58 <vincenz> (f b) returns a function 
18:57:04 <vincenz> can I do f b a or is it (f b) a
18:57:44 <xerox> If (f b :: a -> a), then f b (a :: a) is legal.
18:57:44 <dcoutts> vincenz,  f b a and (f b) a are the same thing
18:58:08 <vincenz> ah cool
18:58:34 <vincenz> dcoutts: Engine is basically an engine to run a robber or cop...it contains the plumbing for keeping track of the current position in input as well as plumbing to make it work gui or guiless
18:58:52 * vincenz did most of the plumbing work, jethr0 worked on a smart Robber, Cop is as of yet unfinished
18:59:12 <vincenz> tho I did a lot of setup work for cop, like keeping information of where a robber can be or not be
18:59:21 <vincenz> (using evidences, smells and information from other players)
18:59:39 <dcoutts> vincenz, yes my rober used that technique
18:59:52 <vincenz> dcoutts: robber?
18:59:54 <vincenz> or cop
19:00:00 <dcoutts> robber
19:00:05 <vincenz> (what technique?)
19:00:21 <vincenz> the Engine bit?
19:00:23 <dcoutts> that is keeping a set of places where I knew the cops knew I could be
19:00:27 <vincenz> ah
19:00:35 <vincenz> but you nkow where the cops are!
19:00:38 <vincenz> robber gets that info
19:00:39 <dcoutts> no, for the behavour of the robber
19:00:52 <dcoutts> true I know where the cops are
19:01:00 <dcoutts> but I want to know where they think I am :-)
19:01:01 <vincenz> oh what you know they know
19:01:11 <dcoutts> so I know when to run away!
19:01:11 <vincenz> dcoutts: my zoning algo is exact
19:01:22 <vincenz> aka...it lists all thep oints where a robber can be
19:01:25 <vincenz> and only those points
19:01:31 <Saulzar> You can use reverse-reverse psychology on them
19:01:33 <vincenz> (i.e. it's minimal)
19:02:06 <vincenz> not only is this interesting, I can later use it to invalidate faulty information from other cops :P
19:02:34 <vincenz> dcoutts: jethr0 and I are thinking of forming a team for this year, given the great coop, maybe you could join too
19:02:47 <dcoutts> vincenz, I've alreagy got a team :-)
19:02:49 <vincenz> we're all in the same timezone apparently, which is great
19:02:53 <vincenz> dcoutts: oh..whom with?
19:02:57 * dcoutts was part of the winning 2004 team
19:03:05 <xerox> heh.
19:03:20 <dcoutts> this year we came 7th
19:03:55 <vincenz> dcoutts: how do you guys collaborate?
19:04:07 <dcoutts> vincenz, by sitting in the same room
19:04:13 <vincenz> oh...that works
19:04:23 <Saulzar> Best there is, if you don't strangle each other :)
19:04:40 <dcoutts> yeah, it can get tense :-)
19:05:21 <vincenz> we did darcs and irc
19:05:25 <kosmikus> dcoutts: oh, btw, is this year's contest date already known?
19:05:27 <Saulzar> What time of year are they held?
19:05:35 <vincenz> Saulzar: +/- june
19:05:38 <dcoutts> kosmikus, I've not checked
19:05:40 <vincenz> beginning I believe
19:05:56 <dcoutts> vincenz, we did darcs and talking
19:06:10 <dcoutts> darcs does help
19:06:14 <vincenz> yeah
19:06:26 <Saulzar> Ah, cool. Seems like a fun idea. The problems seem quite tough for the time given
19:06:55 <vincenz> Saulzar: which one did you look at?
19:07:13 <Saulzar> I haven't looked closely. Just glanced over... 
19:07:59 <vincenz> yeah but which year
19:08:06 <Saulzar> 2004/5
19:08:12 <vincenz> ah
19:08:24 <vincenz> anyways, I'd like a haskell group this year
19:08:43 <vincenz> last year we did it in c++ (but I personally ended up writing the core in ocaml) and the year before I did it with riastradh with scheme
19:09:10 <vincenz> (we being an informal groupnig term defining me and random people of that year
19:13:15 <kosmikus> dcoutts: it'd be nice if we could have the full team again this year, I think.
19:13:40 <dcoutts> kosmikus, yeah, that'd be great
19:14:44 <vincenz> dcoutts, kosmikus: you guys are colocated?
19:15:08 <dcoutts> sadly not, hence the problem for meeting up for the icfp contest
19:15:42 <vincenz> dcoutts: why not work via irc?
19:16:14 <dcoutts> there'd be 3 of us together and kosmikus on his onw, which would be a bit sad
19:16:24 <vincenz> and me/
19:16:26 <vincenz> ?
19:16:31 <vincenz> and jethr0?
19:16:33 <vincenz> :P
19:18:14 <Saulzar> Is there much benefit to having the huge team? Looking down the list there seem to be some with 10! people...
19:18:20 <vincenz> nah
19:18:37 <vincenz> I think you end up with a underutilization of people and a lack of synchronisation
19:18:49 <vincenz> Saulzar: consider running a small task on 10 cpus...the bottleneck is comm
19:18:53 <Saulzar> Yep..
19:19:12 <dcoutts> I think this year we could have done with a 4th team member, but 5 might start to get too many
19:19:31 <dblhelix> dcoutts, kosmikus: have you already chosen a programming language to work with? :P
19:19:33 <Saulzar> You could split into sub-teams, and enter the best of each :)
19:20:00 * vincenz would ilek to be in a serious team
19:20:11 <vincenz> 2 years ago in scheme we started with 4 but two people went off
19:20:16 <vincenz> last year same deal
19:20:17 <dcoutts> dblhelix, we were considering Haskell, Haskell, Haskell and Haskell
19:20:22 * vincenz sighs
19:20:35 <Saulzar> 3rd choice is clearly better 
19:20:53 <dblhelix> yeah, I'd go for that one
19:20:53 <dcoutts> dblhelix, our winning year we used Haskell for the code, the GUI and the source control. :-)
19:20:55 <vincenz> Saulzar: have quantifiable evidence?
19:20:56 <kosmikus> dblhelix: do you have a good language to offer? :)
19:21:04 <vincenz> dcoutts: cairo?
19:21:22 <dcoutts> vincenz, cairo is a bit newer than that
19:21:25 <earthy> kosmikus: what about GH? :P
19:21:28 <Saulzar> vincenz, It's the top one in alphabetical order
19:21:46 <earthy> (dogfood, eating :))
19:21:54 <vincenz> Saulzar: that's debatable
19:21:56 <kosmikus> earthy: but I want to win ;)
19:22:05 <dcoutts> hah!
19:22:12 <earthy> oh, right. :)
19:22:36 <kosmikus> earthy: no, seriously. if one of the problems had cried out for generic programming, I would have proposed it.
19:23:12 <dblhelix> kosmikus: ..., unless it could be done with some boilerplate scrapping?
19:23:54 <kosmikus> earthy: but at least the 2004 problem would not have become any easier.
19:24:11 * earthy nods
19:24:18 <earthy> nor would the 2005 problem, not really
19:24:33 * earthy is going to talk to his gf earlier this time
19:24:39 <kosmikus> dblhelix: SYB/GH depends on the problem really.
19:24:47 <earthy> 'oh, and btw, that weekend, right? I'm *not* available'. :)
19:24:51 <dblhelix> kosmikus: indeed
19:24:59 <kosmikus> dblhelix: but since I wrote SYB Reloaded, I like SYB much better :)
19:25:13 <kosmikus> (than before, not than GH)
19:25:14 <vincenz> earthy: more liek "oh, btw, can you cook and clean for me this weekend while I say no more than a word?"
19:25:28 <Saulzar> Seems to be a lot of AI-Game type problems, only the last 4 years
19:25:32 <dcoutts> vincenz, I think you can use "flush" rather than your "finish" eventsPending loop.
19:25:35 <dblhelix> kosmikus: I can't wait for SYB Revolutions :)
19:25:45 <kosmikus> dblhelix: one week
19:25:59 <dcoutts> vincenz, Visulations.hs line 278
19:26:03 <kosmikus> dblhelix: if you want, you can probably have a draft to look at tomorrow or so
19:26:05 <earthy> vincenz: we live together, and I'm perfectly capable of cooking while thinking about code. :)
19:26:21 <dblhelix> kosmikus: that's be nice
19:26:33 <dblhelix> /s's/'d
19:26:45 <SimonRC> ?
19:26:45 <vincenz> dcoutts: I just copied that from the cairo site ;)
19:26:51 <dcoutts> heh
19:27:02 <vincenz> earthy: that's not the question, it's a question of willing to leave your keyboard
19:27:14 <dcoutts> vincenz, perhaps they don't know gtk very well :-)
19:27:27 <vincenz> dcoutts: I meant fromthe gtk2hs site
19:27:34 <dcoutts> vincenz, oh :-)
19:27:53 <earthy> vincenz: I can reach the oven from the table I might be working at. :)
19:27:55 <vincenz> http://www.haskell.org/gtk2hs/  ...main entry says something about code snipped
19:27:58 <vincenz> http://darcs.haskell.org/gtk2hs/demo/cairo/CairoGhci.hs
19:28:00 <vincenz> snippet even
19:28:08 <earthy> the fridge is like 3 meters further. :)
19:28:16 <dcoutts> vincenz, ah yes
19:28:27 <earthy> anyway, no, no dates for icfp 2006 yet
19:28:39 <vincenz> earthy: yeah I checked
19:28:49 <vincenz> earthy: are you taemed?
19:28:49 <earthy> even though the ruby folks fucked up
19:28:54 <earthy> not yet
19:28:58 <vincenz> earthy: hehe .. .the feb 17 post?
19:29:03 <earthy> that one. :)
19:29:34 <vincenz> dcoutts: I'm a haskell newb... didn't code haskell before this weekend, so any comments about the code?
19:29:35 <earthy> 'Computer science is the womanizer, and math is the pure-hearted girl he won't call the next day.'
19:29:47 * earthy likes S. Behrens already
19:29:54 <dcoutts> vincenz, it looks pretty neat
19:30:14 <dcoutts> vincenz, it's common not have no indent for top level functions
19:30:32 <vincenz> hmm
19:30:39 <vincenz> ocaml remainder
19:30:44 <dcoutts> vincenz, ie people don't indent inside "module Blah where"
19:31:09 <dcoutts> it works of course, it's just not common style
19:31:11 <earthy> hm. that'd be annoying to edit, indeed.
19:31:18 <vincenz> earthy: how so/
19:31:58 * vincenz likes his onActive monad-transformer
19:32:09 <vincenz> well not really transformer but it takes an action and then does something with that action
19:32:41 <vincenz>   onActive guiState action = do
19:32:41 <vincenz>     active <- isEmptyMVar (guiCloser guiState)
19:32:41 <vincenz>     if active
19:32:41 <vincenz>       then do
19:32:41 <vincenz>         action
19:32:43 <vincenz>         yield
19:32:45 <vincenz>       else
19:32:48 <vincenz>         return ()
19:32:59 <vincenz> that way other threads can't do gui stuff if the gui has been closed
19:33:03 <earthy> owh, right. 2 spaces indent. that mitigates it a little. :) I'm used to 4 or 8 spaces
19:33:11 <earthy> and adding extra for neat lhs2TeX formatting
19:33:15 <earthy> (which reminds me)
19:33:30 <earthy> kosmikus, any chance of a new release of lhs2TeX soonish? :)
19:33:42 <shapr> @remember S.Behrens Computer science is the womanizer, and math is the pure-hearted girl he won't call the next day.
19:40:06 <pejo> shapr, oh, a late reply about that data description article - the implementation isn't done yet but he's "working on it". My guess is that it will be in better shape if you wait a week, he had discovered some problems. 
19:40:14 <dcoutts> vincenz, I've updated that cairo example: http://darcs.haskell.org/gtk2hs/demo/cairo/CairoGhci.hs
19:40:24 <dcoutts> vincenz, it makes it a bit simpler
19:42:52 <vincenz> dcoutts: your author of cairo?
19:43:25 <dcoutts> vincenz, no, xerox did it. I just helped a little.
19:43:52 <JKnecht> @remember S.Behrens or maybe she is the Queen of Sciences and he is the Mack Daddy.
19:44:04 <dcoutts> vincenz, xerox won google summer of code funding to do the project 
19:44:54 <kosmikus> earthy: yes, I'm only waiting for a Cabal release :)
19:47:05 <kosmikus> earthy: I thought that would happen quite soon (in December), but maybe I should make another unCabalized release.
19:48:38 * earthy thinks you should make an unCabalized release regardless
19:48:55 <shapr> pejo: sounds interesting
19:49:04 <earthy> but that may not be feasible. :)
19:49:56 <earthy> anyway, I ran into an interesting issue again yesterday... easily solved by not taking the .tgz on the lhs2TeX page but the version in svn @svn.cs.uu.nl, but still...
19:50:02 <earthy> a release would be useful. :)
19:50:44 <shapr> earthy: Is this the same behrens that wrote the monads article for linux journal?
19:52:06 <vincenz> dcoutts: nice
19:52:32 <skew> shapr: that was the subtitle/tagline/whatever at the top of the article
19:53:26 <kosmikus> earthy: what?
19:54:31 <kosmikus> earthy: and anyway, I agree that there currently is a sufficient amount of changes in svn to warrant a new release.
19:54:39 <earthy> kosmikus: incompatibility with latex-beamer
19:54:54 <kosmikus> earthy: that should be fixed in 1.10pre already
19:55:06 <earthy> not in the tgz online though
19:55:26 <kosmikus> oh, yes, I remember, it isn't really
19:55:33 <earthy> and it is insvn
19:56:05 <vincenz> dcoutts: that mozembed...does that work for firefox?
19:56:18 <kosmikus> there were two problems: one was a bug in polytable.sty, that's fixed already in 1.10pre, and one was a wrong default setting, and that's only fixed in polycode.fmt, I think, which isn't in 1.10pre
19:56:30 * earthy nods
20:07:05 <vincenz> @seen jethr0
20:07:06 <lambdabot> I saw jethr0 leaving #haskell 11 hours, 16 minutes and 48 seconds ago.
20:13:09 * SimonRC wonders if he read or imagined the paper "Why shorter programs are better."
20:18:32 <dcoutts> vincenz, yes it can be built for mozilla or firefox
20:20:16 <joelk> oh boy, a new mysterious ST error message.
20:20:26 <xerox> @ghc
20:20:26 <lambdabot>  All of the type variables in the constraint are already in scope (at
20:20:26 <lambdabot> least one must be universally quantified here)
20:21:43 <bosie> hello, i have this function:
20:22:03 <bosie> tripleTail ::[a] -> [a]
20:22:03 <bosie> tripleTail = tail . tail . tail
20:22:03 <bosie> what does those "." mean ?
20:22:19 <resiak> compose
20:22:26 <resiak> (f . g) x = f (g x)
20:22:38 <xerox> Howdy bosie :-)
20:22:45 <bosie> xerox you are back early ;)
20:22:54 <bosie> resiak right, that means:
20:23:09 <bosie> (head . triple Tail) ls
20:23:09 <bosie> equals
20:23:09 <bosie> head (tripleTail ls)
20:23:22 <xerox> It's due to the cold, they sent us back home because it was too cold in the school duh.
20:23:42 <bosie> xerox you gotta be kidding me
20:23:50 <xerox> bosie: right, except the whitespace between 'triple' and 'Tail'
20:23:53 <xerox> :-|
20:23:56 <bosie> isnt it damn confusing with the . and the misleading brackets
20:24:05 <xerox> Nah :-)
20:24:26 <bosie> right
20:24:28 <vincenz> dcoutts: does the windows version work with firefox (the standard version that is in the installer)
20:24:28 <xerox> this . that  simply means, do that on an argument, pass the result to this
20:24:32 <bosie> dont you have radiators? ;)
20:24:46 <xerox> bosie: one of the two in our class exploded
20:24:54 <bosie> lol
20:24:57 <bosie> btw
20:25:08 <bosie> i heard the olympic site is still not finisihed
20:25:21 <bosie> true?
20:25:24 <xerox> They made some party there, I think it's ok... but who cares?
20:25:29 <xerox> ;)
20:25:33 <bosie> i am austrian
20:25:33 <dcoutts> vincenz, ah, sadly it does not work with firefox/mozilla on win32 because the win32 builds of mozilla do not use gtk. Some people have got it working however, there is a bug open about it on the mozilla bugzilla.
20:25:41 <bosie> the only olympic gold medals we get is skiing :D
20:25:48 <vincenz> dcoutts: ah I see
20:26:05 <gour> bosie: wait for croatia 1st ;)
20:26:20 <bosie> gour in what discipline? ;)
20:26:38 <gour> bosie: well janica wins in all :-)
20:26:40 <bosie> btw, for whoever is doing visual studio 2005, resharper released a new version
20:26:44 <bosie> gour haha yea right
20:27:07 <vincenz> dcoutts: got a link to it>
20:27:27 <dcoutts> vincenz, google for gtkmozembed and win32
20:27:49 <vincenz> gtk is pretty mipressive
20:28:16 <xerox> What is the mozembed thing about?
20:28:43 <bosie> whats the name of the "."-feature ?
20:29:07 <vincenz> dcoutts: yo sure it doesn't work?  I see postmessages from 2004 with a patch to fix when Igoogle for that
20:29:16 <gour> dcoutts: i was overlooking yesterday's cahte between you and Cale regarding type classes..
20:29:33 <dcoutts> vincenz, well you can try it, see if you can make it work.
20:29:42 <dcoutts> vincenz, I've never tried.
20:29:54 <vincenz> dcoutts: see if I can make it work.... you mean just take a google program with mozembed and run it, or is there more involveD?
20:30:00 <vincenz> eugh...haskell program
20:30:55 <dcoutts> vincenz, you need to have mozilla working on win32 using gtk and then build gtk2hs from source on win32 and get the mozembed bindings to build. Then you can try running the gtk2hs mozembed test program.
20:31:14 <vincenz> oh... and by default mozilla ain;t based on gtk?
20:31:30 <dcoutts> vincenz, you'll need to have mozilla install the mozilla-gtkmozembed.pc file for gtk2hs to pickup.
20:31:41 <dcoutts> vincenz, on linux it is, on win32 it is not
20:31:47 <vincenz> darn
20:32:13 <dcoutts> vincenz, that's why it works "out of the box" on linux
20:32:15 <vincenz> dcoutts: gtk2hs needs that at compilation of gtk2hs sources?
20:32:25 <vincenz> that mozilla-.. file
20:32:33 <dcoutts> vincenz, yes, so it can find the gtkmozembed header files and libs
20:33:39 <dcoutts> vincenz, check out http://zacbowling.com/gtkembedmoz/
20:34:40 <dcoutts> vincenz, it seems that the mono gecko# people have got it working
20:35:43 <dcoutts> http://forge.novell.com/modules/xfcontent/downloads.php/monowin32/GRE%20for%20Gecko-Sharp/v1.7.3-0.1/
20:36:15 <vincenz> dcoutts: then I doubt it will ever work... cause gtk2hs is precompiled for windows
20:36:32 <dcoutts> vincenz, yeah, you'd need to build it from source
20:36:42 <dcoutts> I do that all the time :-)
20:36:50 <vincenz> dcoutts: cygwin?
20:36:54 <dcoutts> mingw
20:37:02 <vincenz> same difference :)
20:37:05 <dcoutts> no
20:37:16 <vincenz> how so
20:37:24 <dcoutts> mingw produces native windows apps
20:37:28 <dcoutts> no unix emulation
20:37:32 <vincenz> oh
20:37:37 <dcoutts> ghc uses it
20:37:55 <vincenz> ah I see
20:38:14 <vincenz> hmm .. even if I download mono gecko...I'd still have to recomiple gtk2hs 
20:38:19 <dcoutts> yep
20:38:23 <vincenz> :/
20:38:40 <dcoutts> ./configure; make
20:39:30 <vincenz> true
20:39:39 <vincenz> reason I always thought mingw was cygwin is this
20:39:44 <vincenz> http://caml.inria.fr/pub/distrib/ocaml-3.09/notes/README.win32
20:39:56 <vincenz> notice how the mingw version uses cygwin for native compilation of ocaml
20:41:04 <dcoutts> vincenz, well that's probalby just a pecularity of ocaml
20:41:13 <dcoutts> ghc comes with a copy of mingw's gcc
20:41:28 <dcoutts> it does not require any cygwin
20:43:44 * vincenz nods
20:44:11 <skew> Is there a debian package against ghc 6.4?
20:44:31 <vincenz> dcoutts: another option is not using windows :P
20:44:47 * vincenz tries to figure out how to install mingw
20:44:59 <skew> (of gtk2hs) I see libghc6-gtk2-dev, but it wants ghc6 < 6.2.1+
20:45:04 <gour> vincenz: that's a good one; don't forget msys
20:45:07 <dcoutts> vincenz, indeed, that's better if you can avoid it
20:45:29 <dcoutts> skew, prod the debian haskell packagers to package a recent version of gtk2hs
20:46:09 <dcoutts> skew, the current debian version of gtk2hs is more than a year and a half (and 4 releases) out of date.
20:46:18 <dcoutts> skew, you can build from source
20:46:41 <dcoutts> vincenz, so what do you need mozembed for?
20:46:51 <vincenz> dcoutts: just looked cool :)
20:46:53 <vincenz> the idea that is
20:47:00 <vincenz> putting haskell plugins into my browser
20:47:10 <vincenz> anyawys...lunchtime
20:47:12 * vincenz detaches
20:47:20 <skew> dcoutts: ok, I'll build it from source, and then prod them
21:29:46 <vincenz> re
21:30:55 <MarcWeber> Hi lispy!
21:33:13 <vincenz> >" a\
21:33:15 <vincenz> > " a\
21:33:16 <lambdabot>  lexical error in string/character literal
21:38:17 <vincenz> oy...first try of gtk2hs on windows and blamma it doesn't work
21:38:39 <dcoutts> vincenz, at which step?
21:38:46 <vincenz> http://darcs.haskell.org/gtk2hs/demo/actionMenu/ActionMenu.hs
21:38:53 <vincenz> I compiled it just fine...then ran it
21:39:16 <dcoutts> you installed and registerd it ok?
21:39:17 <vincenz> windows error box with "The procedure entry poinf XML_SetDoctypeDeclHandler" could not be located in the dynamic link library xmlparse.dll
21:39:24 <dcoutts> ah
21:39:36 <dcoutts> you've got another copy of xmlparse.dll on your syetem path
21:39:43 <vincenz> hmm
21:39:45 <vincenz> odd
21:40:03 <vincenz> yup
21:40:05 <dcoutts> either in the %PATH% or in the windows dir or system
21:40:26 <vincenz> googledesktop is great :)
21:40:31 <dcoutts> heh
21:40:57 <dcoutts> the dll search issue on win32 is a real pain
21:41:14 <vincenz> this is odd... I know I have another but it's not in my path
21:41:48 <dcoutts> windows searches in the dir the .exe comes from, the current dir, the windows and system dir and the %PATH%
21:43:08 <dcoutts> it makes it really hard for several apps to share an installation of gtk on win23
21:43:23 <vincenz> dcoutts_: nope
21:43:33 <vincenz> dcoutts_: I renamed the otehr one
21:43:38 <vincenz> it's the GTK one that's screwy
21:43:47 <dcoutts> vincenz, what gtk have you got?
21:43:55 <vincenz> newest
21:44:01 <dcoutts> and that's the only version installed?
21:44:22 <vincenz> yeah
21:44:50 <dcoutts> so what's the %PATH% ?
21:45:22 <vincenz> c:\GTK\bin ...
21:45:31 <dcoutts> try this...
21:45:53 <dcoutts> move the ActionMenu.exe to c:\GTK\bin and run it from there
21:45:58 <vincenz> k
21:46:01 <vincenz> blegh
21:46:04 <dcoutts> that'l tell us if it's a dll search path problem
21:46:14 <vincenz> don't you hate it that you can't delete stuff in windows even tho there's no app that has that file open
21:46:26 <ndm> vincenz: i bet you there is
21:46:31 <dcoutts> it's a prog that's holding open the directory
21:46:34 <ndm> an app with the file open that is
21:46:53 <vincenz> ah..gvim :O
21:46:54 <ndm> if you use some of the system internals tools, they can tell you which app
21:47:44 <vincenz> dcoutts: that seems to work
21:47:48 <vincenz> let me fire up processexp
21:48:00 <dcoutts> vincenz, there must be another xmlparse.dll somewhere
21:48:19 <vincenz> googledesktop didn't find it
21:48:45 <dcoutts> it probably doesn't look everywhere
21:48:55 <dcoutts> try windows & window/system
21:49:45 <ndm> vincenz: if you have something set as a system file, and certain explorer options, it will be hidden
21:50:56 <vincenz> process explorer showed me... yeah... there's an xmlparse.dll in system32
21:51:26 <dblhelix> kosmikus: ping?
22:02:03 <kosmikus> dblhelix: pong
22:02:49 <dblhelix> lhs2TeX panic... 
22:02:52 <dblhelix> ! Undefined control sequence.
22:02:52 <dblhelix> <inserted text> ...ellModule}\;\mathbf {where}{}\<
22:02:52 <dblhelix>                                                   [E] \ColumnHook 
22:02:52 <dblhelix> l.526 \end{hscode}
22:02:52 <dblhelix>                   \resethooks
22:03:14 <dblhelix> polycode stuff?
22:04:03 <earthy> \<[E]? 
22:04:09 <earthy> what're you doing, dblhelix?
22:04:30 <dblhelix> earthy: try and build the lecture notes FP
22:04:46 <earthy> oh, no, not you *too*!
22:04:58 <dblhelix> yep, me too
22:05:15 <bosie> you two are professors?
22:05:59 <earthy> fortunately, in this case, we are not :)
22:06:07 <bosie> tutors?
22:06:15 <earthy> PhD students.
22:06:19 <bosie> oh
22:06:20 <bosie> where?
22:06:43 <earthy> but our prof's been bitching, moaning, complaining and hacking for the best part of the past two weeks about these lecture notes
22:06:59 <earthy> cs.uu.nl
22:07:37 <bosie> cool
22:07:46 <bosie> i heard utrecht is quite good
22:07:48 <bosie> the univ there
22:07:59 <earthy> depends on what you plan to study, but overall, yea
22:08:09 <bosie> CS primarly ;)
22:09:36 <earthy> well, it's considered the best in .nl
22:09:41 <earthy> for cs
22:09:47 <bosie> ok
22:10:01 <bosie> its held in dutch or english ?
22:10:11 <earthy> bachelor's in dutch
22:10:13 <earthy> master's in english
22:10:16 <bosie> and msc?
22:10:17 <bosie> ok
22:11:16 <bosie> thanks for the information
22:11:39 <earthy> and ofcourse, if you like fp... :)
22:12:15 <bosie> more interested in oop tbh :/
22:13:55 <earthy> hm. we don't really do much oo here though
22:14:35 <bosie> omg you are even listed on their website
22:14:40 <frobenius_> boycott #lisp - they are aggressive and impolite ! particularly Dr. Christofer Rhodes who is evidently a researcher in London, but acts aggressively and rudely. 
22:14:50 <frobenius_> such is the world
22:16:04 <bosie> earthy the CS department in utrecht has a total of 18 ppl ?
22:16:20 <earthy> you mean Christophe Rhodes
22:16:28 <frobenius_> yes, you know him?
22:16:35 <earthy> google does. :)
22:16:35 <frobenius_> very rude
22:17:14 <kosmikus> dblhelix: too old version of polytable.sty for your version of lhs2TeX
22:17:17 <frobenius_> I was banned for no reason (I started a discussion and people actually followed it up with private messages afterwards)
22:17:50 <frobenius_> I am not an experienced irc user, but their behaviour would not work IRL 
22:17:53 <dblhelix> kosmikus: ah, okay, tnx
22:18:03 <JKnecht> A lot of smart people are lacking in emotional maturity, especially the younger ones. 
22:18:07 <kosmikus> dblhelix: or, well, for you version of lhs2TeX.fmt, actually
22:18:19 <bosie> JKnecht i wouldnt call christophe rhodes young tho ;)
22:18:25 <dblhelix> kosmikus: yes, that figures
22:18:47 <frobenius_> maybe I thought Christophe Rhodes for Christipher Rhodes ?
22:18:59 <kosmikus> dblhelix: you should either upgrade polytabel.sty to 0.8.2, or downgrade your lhs2TeX.fmt to the 1.10pre version
22:19:10 <frobenius_> well, for "calling", other words comes to mind...
22:19:10 <tuomov> frobenius_: #popular_program is aggressive and impolite most of the time
22:19:20 <dblhelix> kosmikus: I'll upgrade polytable
22:19:43 <JKnecht> bosie: that's too bad, immaturity in the mature is not pretty :)
22:20:22 <frobenius_> that explains... I would have expected more from an established reseacher. the guy is a loose lisp hacker. untyped, what can we expect? ;-)
22:20:58 <bosie> JKnecht depends if it was really immaturity, some ppl just need a straight, honest and brutal answer to wake up
22:21:12 <JKnecht> true that.
22:21:28 <gour> tuomov: what if haskell becomes more popular(#1 on shootout list) ?
22:21:52 <frobenius_> bosie, JKnecht, fair enough, but in the interest of an ongoing discussion "not listening" might be an option even for an op
22:22:03 <frobenius_> fight dictatorship
22:22:25 <JKnecht> but keep the channel noise to a minimum. Let's move on.
22:23:01 <tuomov> gour: so many clueless n00bs will appear that the old-timers either leave or become sour and impolite
22:23:34 <frobenius_> think if that would happen with university professors too, treating students bad etc is *not* an option
22:23:48 <gour> tuomov: huh...then better hurry up and leave noob area asap :-)
22:23:51 <bosie> frobenius_ happened to me twice with diff profs unfortunately
22:24:03 <frobenius_> same arguments then applies
22:24:12 <frobenius_> but irc seems to be a safe haven for some idiots
22:24:32 <bosie> frobenius_ internet not just irc
22:24:46 <xerox> Is there something else?  <grin>
22:25:01 <xerox> @wiki MonadsAsContainers
22:25:02 <lambdabot> http://www.haskell.org/hawiki/MonadsAsContainers
22:25:07 <bosie> thx ;)
22:25:34 <bosie> Cale wrote it ?
22:25:39 <xerox> Yep.
22:27:11 <bosie> ciao
22:58:07 <icbt> I figured it out!
22:58:15 <xerox> Figred out what?
22:58:17 <xerox> +u
22:58:23 <icbt> if anyone need help with SDL/OpenGL on the mac, ping me
23:00:22 <icbt> is there an easy way to extract the import-dirs and library-dirs line from ghc-pkg describe name?
23:09:11 <MarcWeber> icbl grep?
23:09:13 <MarcWeber> or sed?
23:09:23 <icbt> yah, that's what i did, 
23:09:38 <icbt> wish there is the equivalent of ghc-pkg-config --libs
23:09:47 <dblhelix> icbt: what have you changed since the last time you mailed me about it?
23:10:09 <icbt> hi, stefan
23:10:19 <dblhelix> icbt: hi, jake
23:10:29 <icbt> just emailed you the makefile
23:10:44 <icbt> -package SDL does nothing
23:10:45 <dblhelix> icbt: ah, I see
23:10:53 <icbt> i ended up doing -L and -l manually
23:11:33 <icbt> should -package work though?
23:20:59 <kosmikus> dblhelix: have you had success with lhs2tex now?
23:21:20 <dblhelix> kosmikus: yes, it works just fine now, thanks
23:21:59 <dblhelix> kosmikus: now I've only have to do some 200 pages of formatting :)
23:23:26 <kosmikus> dblhelix: yes, I have looked at it a few weeks ago when Doaitse had a problem formatting it. Seems like there's a lot of work ahead of you :)
23:24:01 <dblhelix> kosmikus: well, it has to be done by the end of the day... :(
23:24:13 <kosmikus> what ??
23:24:40 <dblhelix> yep
23:25:29 <kosmikus> let me guess: no one has told you until today that you have to do it, and it has to be printed in time for the course?
23:26:11 <dblhelix> kind of: doaitse had planned to do it himself, but yesterday at 11.30pm he asked me to do it
23:27:02 <kosmikus> and the deadline can't be moved?
23:27:19 <dblhelix> the deadline has already been moved :)
23:28:28 <kosmikus> haha
23:28:39 <dblhelix> but, well, we've moved it again... now the complete thing has to be done by Monday (course starts Wednesday)... but Doaitse really wants to have it done before tomorrow morning...
23:29:02 <kosmikus> good luck
23:29:26 <dblhelix> I'm only doing the formatting of the code... it's not that bad, but, you know, just boring
23:29:52 <dblhelix> but, hey, I was the one who wanted to obtain a PhD ;)
23:30:00 <kosmikus> right
23:32:13 * earthy laughs
23:32:30 <earthy> at least he asked me to confirm his suspicions on a paper he had to referee. ;)
23:33:34 <kosmikus> dblhelix: I get an error on page 22 when I try to build it from svn. (Command \itize already defined.) Is this normal?
23:34:22 <dblhelix> kosmikus: no, it isn't... that's magic that only works on doaitse's machine... locally I use \renewenvironment etc. for that piece
23:36:36 <dblhelix> kosmikus: so, eh, you getting the error *is* normal
23:36:51 <kosmikus> erm. ok.
23:36:54 <kosmikus> I see.
