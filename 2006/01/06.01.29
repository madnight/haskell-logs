00:02:07 <vincenz> is it possible to tell lambdabot to send osmeone a message when they come in here?
00:17:23 <vincenz> hmm, this is odd, I installed libghc6-hunit-dev and it can't find HIUnit
00:28:06 <vincenz> woo
00:28:15 <vincenz> alias commit='darcs record && darcs push $SCP_OASIS:`pwd`'
00:28:46 <vincenz> fixed the hunit issue, it was Test.HUnit
00:52:05 <jyp> @quote
00:52:06 <lambdabot> Heffalump says: docs aren't all that useful, generally
01:30:36 <jyp> @quote
01:30:36 <lambdabot> reddi says: and now i know: IT DOES NOT WORK ALWAYS ;-)
01:31:42 <tibbe> can anyone think of a reason for this to be a bad lambda calculus grammar? L ::= var  |   '\' var '.' L    |   '(' L L ')'
01:33:14 <tibbe> it's not left recursive right?
01:43:26 <Cale> it requires more parens than most people usually like to type
02:13:59 <Speck> does anyone feel like explaining the definition of loop in ArrowLoop?
02:26:49 <jyp> @quote
02:26:50 <lambdabot> SyntaxNinja says: I think that the compiler authors will fly here from
02:26:50 <lambdabot> England just to kill me if I did that
03:04:21 <frobenius> hello, darwinports gives me configure: error: GHC is required unless bootstrapping from .hc files. 
03:04:28 <frobenius> I am trying to install hat
03:04:36 <frobenius> and thus first ghc
03:09:24 <Husk> um - hi everybody - i got a problem with a haskell function - i cannot see what the problem is
03:09:45 <Husk> i'Ve the following data structure :data Map a b = EmptyMap | Store a b (Map a b) deriving Show and this function
03:09:59 <Husk> deleteMappings :: Eq a => a -> Map a b -> Map a b
03:09:59 <Husk> deleteMappings _ EmptyMap                                       = EmptyMap
03:09:59 <Husk> deleteMappings delkey (Store key value restmap) | (delkey==key) = deleteMappings delkey restmap
03:09:59 <Husk>                                                 | otherwise     = (Store key value (deleteMappings delkey restmap))
03:10:16 <Husk> oops - sry - wrong function
03:10:24 <Husk> getValues :: Eq a => a -> (Map a b) -> [b]
03:10:25 <Husk> getValues key map = getVals key map [] where
03:10:25 <Husk>   getVals _ EmptyMap result                                         = result
03:10:25 <Husk>   getVals listkey (Store key value restmap) result | (listkey==key) = getVals listkey restmap (value:result)
03:10:25 <Husk>                                                    | otherwise      = getVals listkey restmap result
03:10:49 <Husk> this is my input: getValues "foo" (Store "foo" "bar" (Store "foo" "bar2" (Store "blah" "blah" EmptyMap)))
03:11:07 <Husk> and it should print out ["bar","bar2"]
03:13:41 <Husk> args - problem solved - sorry :)
03:44:03 <tibbe> where can I find Language.Haskell.Syntax.hs source? Is it distributed together with GHC?
03:44:45 <xs> @libsrc Language.Haskell.Syntax
03:44:45 <lambdabot> http://darcs.complete.org/fptools/libraries/haskell-src/Language/Haskell/
03:44:45 <lambdabot> Syntax.hs
03:46:01 <tibbe> thanks
03:54:50 <frobenius> anyone with experience from using darwinports to install ghc here?
04:00:53 <noj> sure
04:16:45 <jethr0> moin moin
04:17:11 <jyp> @quote
04:17:12 <lambdabot> HavocPennington says: Haskell is the least-broken programming language
04:17:12 <lambdabot> available today.
04:20:58 <jyp> @vixen Haskell is the least-broken programming language available today.
04:20:59 <lambdabot> Ooh, functional programmers are so hot!
04:30:08 <frobenius> hmake says :  ghc-6.2: unknown package name: hat 
04:30:19 <frobenius> can I use ghc from fink with hat from darwinports???
04:32:12 <tibbe> @quote
04:32:12 <lambdabot> chromatic says: My productivity increased when Autrijus told me about
04:32:12 <lambdabot> Haskell's trace function. He called it a refreshing desert in the oasis
04:32:12 <lambdabot> of referential transparency.
04:34:16 <dcoutts> @help libsrc
04:34:17 <lambdabot>  @libsrc <lib>, lookup the url for the darcs source for a library
04:34:22 <dcoutts> @help libsrc+
04:34:23 <lambdabot>  @help <command> - ask for help for <command>
04:34:41 <dcoutts> @libsrc gtk2hs
04:34:41 <lambdabot> gtk2hs not available
04:34:58 <gour> dcoutts: :-(
04:35:19 <dcoutts> @libsrc+ gtk2hs darcs get --partial http://darcs.haskell.org/gtk2hs/
04:35:20 <lambdabot> gtk2hs darcs get --partial http://darcs.haskell.org/gtk2hs/ not available
04:35:26 <dcoutts> hmm
04:35:32 <dcoutts> what's the command
04:35:34 <dcoutts> @listcommands
04:35:35 <lambdabot> use listcommands [module|command]. Modules are:
04:35:35 <lambdabot> babel base code compose dice dict djinn dummy dynamic elite fact haddock
04:35:35 <lambdabot> help hoogle karma lShell localtime more pl plugs poll pretty quote search
04:35:35 <lambdabot> seen spell state system todo topic type version vixen where
04:35:42 <dcoutts> @listcommands libsrc
04:35:43 <lambdabot> dummy provides: dummy id get-shapr faq eurohaskell wiki paste docs libsrc
04:35:43 <lambdabot> fptools learn map shootout botsnack
04:35:59 <dcoutts> @listcommands where
04:35:59 <lambdabot> where provides: where what where+
04:36:20 <dcoutts> @listcommands code
04:36:20 <lambdabot> code provides: code
04:36:55 <dcoutts> @help libsrc-add
04:36:56 <lambdabot>  @help <command> - ask for help for <command>
04:37:18 <dcoutts> dons, what's the libsrc add command?
04:37:38 * gour is going to take a lunch..
04:38:28 <dcoutts> @listcommands dynamic
04:38:28 <lambdabot> dynamic provides:
04:46:47 <dcoutts> @libsrc Graphics.UI.Gtk
04:46:48 <lambdabot> Graphics.UI.Gtk not available
05:16:13 <dons> dcoutts, there's no way to add, afaik, other than 'darcs record'
05:16:39 <dcoutts> ok
05:17:57 <jyp> hey dons
05:18:11 <dons> hey jyp
05:18:26 <jyp> dons: how would you welcome a patch for yi that adds support for split windows (gtk ?)
05:18:36 <dons> yes
05:18:45 <dons> I mean, I would welcome any patches :)
05:18:52 <jyp> I'll see what I can do then :)
05:19:34 <jyp> I just want to make sure I'm not going in a direction opposite to planned.
05:19:38 <dcoutts> though I should note that I'm not sure if split window with different files would make sense when yi is embeded in hIDE
05:19:49 <dcoutts> but a split view of the same file would be fine
05:20:10 <jyp> That's right
05:20:34 <jyp> The thing I'm really interested in is a "minibuffer" window
05:21:02 <jyp> I thought implementing split windows would allow that;
05:21:21 <gour_> dcoutts: does it make sense writing 'console' app in gtk2hs, before going to full-fledged gui app?
05:21:29 <jyp> but; how do you forsee integration of minibuffers with hIde ?
05:21:39 <dcoutts> gour_, not sure
05:21:54 <dcoutts> jyp, I don't really know
05:22:14 <dcoutts> I don't use an editor with such a feature so I'm not sure how it's supposed to work
05:22:21 <dons> @seen musasabi
05:22:21 <lambdabot> musasabi is in #haskell-blah and #haskell. I don't know when musasabi
05:22:21 <lambdabot> last spoke.
05:22:38 <dons> musasabi, a faster partial sums: http://www.haskell.org/hawiki/PartialSumsEntry
05:22:43 <dons> can you commit it?
05:23:06 <gour> dcoutts: so, better to start immediately with gui or to do cli 1st?
05:23:31 <dcoutts> gour, it might be better to write the gui last
05:23:58 <frobenius> what do I do if hmake gives me ghc-6.4: unknown package: hat   after installing both ghc and hat?
05:24:05 <frobenius> I have set GHC_LIB DIR etc
05:24:14 <frobenius> but I have two versions of GHC around, one in /sw/bin/ and one in /opt/local/bin
05:24:21 <dcoutts> jyp, perhaps it'd work well as a tool tab, eg:
05:24:22 <dcoutts> http://haskell.org/~duncan/hIDE/hIDE%20main%20window.png
05:24:25 <frobenius> the former is 6.2, the the latter 6.4
05:24:34 <frobenius> please help me out! ;-)
05:24:57 <dcoutts> jyp, Lemmih has already implemented the parser/type checker error messages as that kind of tab panel thing
05:25:38 <dcoutts> jyp, the idea with those tabs is that they are either global or they are in the context of the currently displayed editor buffer
05:25:59 <jyp> dcoutts: I see
05:26:02 <dcoutts> eg Lemmih's error messages tab
05:26:14 <dcoutts> it gives the error messages for the current buffer
05:26:38 <frobenius> btw, is perhaps "hat" also in the ghc CVS?
05:26:49 <frobenius> so it may be easier to get it all to work together by checking it out in its totality?
05:30:31 <tibbe> handy function for make string separated by " " from [String] needed
05:31:19 <dcoutts> jyp, do you think that kind of UI would make sense for a minnibuffer?
05:31:20 <dons> > concat . intersperse " " $ ["a","b","c"]
05:31:21 <lambdabot> "a b c"
05:31:25 <frobenius> how can you have 10.4.5 ??
05:31:54 <jyp> dcoutts: It would make sense
05:32:04 <dons> tibee, is that what you wanted?
05:32:09 <dons> tibbe, sorry.
05:32:15 <jyp> dcoutts: Under the tab "user interaction" or something
05:32:29 <tibbe> dons, yes
05:32:49 <tibbe> @type intersperse
05:32:50 <lambdabot> Not in scope: `intersperse'
05:33:04 <jyp> dcoutts: Is that the UI you shown a screenshot or a mock-up design ?
05:33:04 <dcoutts> jyp, or "editor command" thingy :-)
05:33:22 <dcoutts> jyp, it's partially a mockup
05:33:29 <tibbe> @type intersperse
05:33:30 <lambdabot> Not in scope: `intersperse'
05:33:35 <tibbe> how can that not be in scope?
05:33:56 <dcoutts> jyp, it's a screenshot with the editor working and the file browser working but the tool tabs are just from the glade file
05:34:14 <dcoutts> jyp, but Lemmih demoed a working error message tab the other day
05:34:27 <dcoutts> jyp, so there is an API for adding them
05:34:45 <jyp> dcoutts: alright
05:35:17 <jyp> I assume this API is not in the standalone yi though...
05:36:02 <jyp> The thing is I'm unable to compile the full hIde (at least last time I checked)
05:36:04 <gour> dcoutts: yesterday i pulled from gtk2hs repo, but cairo clock cannot be resized
05:37:01 <dcoutts> gour, really? what happens?
05:38:06 <dcoutts> jyp, yeah it's not in the standalone yi, its a hIDE thing
05:38:09 <JohnMeacham> I remember reading somewhere about the issues with inlining unsafePerformIO and why GHC doesn't do it. does anyone know what that might be? I am thinking it was possibly a mail to one of the lists from one of the simons but am unsure.
05:38:53 <dcoutts> JohnMeacham, I recall it's to do with sharing, since you don't want to duplicate the side effects inside the IO action
05:39:11 <jyp> btw; before I announce this to the mailing lists: http://hackage.haskell.org/trac/ghc/wiki/CollectionClassFramework
05:39:35 <dcoutts> jyp, Lemmih has a ghc snapshot that he uses to build hIDE. That should work.
05:39:51 <dcoutts> jyp, if it doesn't, bug Lemmih :-)
05:40:36 <JohnMeacham> dcoutts: yeah, I figure it is something like that too. I am just looking for something more specific.
05:48:58 <gour> dcoutts: oops, it works but only when i resize via middle-mouse button. it thought it should react when grabbed at the edges
05:49:15 <dcoutts> gour, that's the intended behaviour
05:49:28 <dcoutts> gour, send a patch to change it if you like :-)
05:49:48 <tibbe> what's the correct words for function "arguments", argument or parameter or both?
05:49:56 <tibbe> or even formal parameters?
05:50:04 <tibbe> word*
05:51:36 <gour> dcoutts: what about those (laptop) users without middle-mouse button
05:53:01 <dcoutts> gour, use both buttons simultatiously 
05:53:05 * dcoutts &
05:56:53 <frobenius> is there an expert on hmake around?
06:00:29 <frobenius> I get : Failed to load interface for `Hat.PreludeBasic'
06:03:47 <davidw> dcoutts, do you know which ghc snapshot Lemmih is using?
06:05:54 <gour> davidw: have you pulled latest hIDE patches?
06:06:12 <davidw> uhm.. dunno, let me check :)
06:06:29 <gour> davidw: he lists deps as:
06:06:31 <gour> Recent GHC. darcs get --partial http://darcs.haskell.org/ghc.hide
06:06:31 <gour>   Recent gtk2hs. darcs get --partial http://darcs.haskell.org/gtk2hs.hide
06:06:31 <gour>   Recent hs-plugins. This repo is guarantied to work: http://scannedinavian.com/~lemmih/hs-plugins
06:06:31 <gour>   FilePath: darcs get http://scannedinavian.com/~lemmih/FilePath
06:06:33 <gour>   Yi: darcs get --partial http://scannedinavian.com/repos/yi
06:06:35 <gour>   FPS: darcs get --partial http://www.cse.unsw.edu.au/~dons/code/fps
06:06:45 <davidw> oh, NICE
06:06:50 <davidw> I just pulled 'em now
06:07:18 <gour> davidw: i don't have (atm) to play with it, but pls. let me know how it goes ;)
06:07:49 <davidw> gour, sure
06:08:24 <gour> davidw: err. s/have/have time/  ;thanks
06:21:31 <jethr0> anyone good with parsec around?
06:22:18 <jyp> jethr0: ask out :)
06:23:08 <jethr0> is there a way to "instance" a data type so it can parse itself? like with instancing "Read"?
06:23:24 <jyp> gour: one needs a darcs-all script a-la ghc for hIde :)
06:23:28 <jethr0> not sure if this makes sense :)
06:24:57 <jyp> jethr0: It's possible but probably not what you want
06:25:04 <jethr0> hmm
06:25:18 <jethr0> right now i'm writing data types and similarly called functions to parse them using parsec.
06:25:25 <jethr0> does that seem acceptable?
06:25:28 <jyp> because the type will determine what to parse, not the other way around
06:25:36 <jethr0> data MyType = ...
06:25:50 <jethr0> myType = do ...; ...; return MyType ...
06:26:00 <jyp> this looks ok
06:27:20 <jethr0> i guess i could make a typeclass which had a sole function "parseMe" and instance all my datatypes from that...
06:27:25 <jethr0> but it might not be worth it
06:28:13 <jyp> indeed; see my other remark.
06:30:00 <jethr0> hmm
06:44:45 <TuringTest> @seen dons
06:44:46 <lambdabot> dons is in #haskell-blah and #haskell. Last spoke 1 hour, 12 minutes and
06:44:46 <lambdabot> 37 seconds ago.
06:45:19 <TuringTest> Pardon me, I have a syntax question.
06:45:54 <TuringTest> Where is the (!) syntax used in the patterns guards in http://haskell.org/hawiki/PartialSumsEntry (the top one) documented?
06:46:00 <kombinator> hello all, is there a way to create variables local to a particular line in the do notation?
06:46:37 <TuringTest> do blah; let foo = bar in IcanSeeFoo; baz
06:46:41 <Saulzar> TuringTest, where (!) x y = ..
06:46:42 <kombinator> fo instance: do x <- sth; x <- complexExpr where complexExpr = ..
06:46:57 <TuringTest> kombinator: Use let
06:47:11 <Saulzar> TuringTest, I was looking for the same thing :)
06:47:14 <kombinator> but let's say i want mutually recursive variables
06:47:23 <kombinator> and many-cases pattern matching
06:47:24 <TuringTest> Saulzar: Bah
06:47:30 <jethr0> how can i "instance read"?
06:47:39 <TuringTest> Saulzar: He save a line and I could not read it.
06:48:17 <Saulzar> Well, it's not so bad... huge verbose lines wrapping around aren't nice either
06:48:29 <TuringTest> The shoutout counts lines of code
06:48:39 <TuringTest> And Haskell wins by a landslide
06:49:01 <TuringTest> But this one caught me
06:49:17 <mmc> http://pastebin.com/528754    "fibs = 0 : 1 : [ a + b | (a, b)" gives   parse error (possibly incorrect indentation)    help?
06:49:17 <Saulzar> Yep... well, most of the other entries seem compacted too, especially SML :)
06:49:20 <jethr0> even with the (*cough* ugly *cough*) optimizations :)
06:49:39 <TuringTest> kombinator: You can put tons of recursive definitions in the let statement
06:50:14 <TuringTest> fibs = 0 : 1 : [ a + b | (a, b) <- fibs ]
06:50:25 <TuringTest> but that also fails
06:51:08 <mmc> it's from http://www.haskell.org/~pairwise/intro/section1.html
06:51:56 <kombinator> TuringTest: you're right. I've been fooled by haskell's indentation rules
06:52:04 <TuringTest> fib = 1 : 1 : [ a+b | (a,b) <- zip fib (tail fib) ]
06:53:10 <mmc> err, sorry, that was my browser's fault :(
06:53:38 <Saulzar> Heh, it's funny the way the entries end up all as duplicates of each other. Somone figures out a fast hackish way to do it in C, then all the other entries copy that one
07:01:41 <TuringTest> Saulzar: I think it was the word "naive" in the instructions.  At first people just amalgamated the previous separate entries (e.g. Harmonic). Once it is clear you are permitted to be more clever, then everyone takes advantage.  At first it seemed that such tricks would not be "naive".
07:03:34 <TuringTest> I think the gcc entries times are hilarious: 5.12s, 5.11s, 5.10s.  
07:04:37 <TuringTest> Perhaps we should pass all 30 Doubles as loop parameters to the n-body problem benchmark.  Hideous, but I suspect fast.
07:15:27 <Saulzar> Could you use template haskell to automate that kind of transform somehow?
07:16:25 <Saulzar> Trouble would be doing it for arbitrary n - I guess you can do it for 64 say... then use multiples of that.
07:16:44 <Saulzar> Could be the basis for a haskell numerics lib :)
07:17:19 <Saulzar> data V64 = V64 !Double !Double ... 
07:27:00 <musasabi> dons: https://alioth.debian.org/forum/forum.php?thread_id=2011&forum_id=999 (about partial sums)
07:36:14 <jethr0> is there an alternative to "show" that respects escape chars?
07:36:56 <jyp> ?
07:37:17 <jethr0> > show "hello"
07:37:18 <lambdabot> "\"hello\""
07:37:29 <ndm> id ?
07:37:32 <jethr0> i only want to see a plain >hello<
07:37:40 <ndm> > id "hello"
07:37:41 <lambdabot> "hello"
07:37:43 <jyp> putStrLn string
07:37:47 <jyp> probably
07:37:58 <jethr0> ndm: yes, but i've instances show for some data types
07:38:08 <jethr0> *instanced
07:38:21 <ndm> jethr0: i've had that problem before - it is possible with overlapping instances
07:38:26 <jethr0> ?
07:38:40 <ndm> you create a class ShowRaw, give a special instance for String, and then give Show a => ShowRaw a for all others
07:38:42 <Saulzar> Can you wrap the string?
07:38:49 <jyp> How come you have escape characters in non-string types ?
07:39:07 <jethr0> jyp: never mind, i just have :) (newlines, tabs, etc)
07:39:19 <jethr0> Saulzar: how do you mean?
07:39:36 <blazold> hi my friends
07:39:59 <ndm> newtype MyString = MyString String
07:40:08 <ndm> then write an instance Show MyType
07:40:13 <jethr0> ah, i think i've got a solution in mind.
07:40:21 <jethr0> i should just now "show" my string components, i guess :)
07:40:58 <jethr0> s/now/not/
07:49:53 <blazoldX> where am i suppost to paste the code ?
07:51:09 <blazoldX> i need help with this error "Cannot justify constraints in explicitly typed binding"
07:51:11 <ndm> @paste
07:51:11 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
07:52:38 <blazoldX> how can i paste the code there ?
07:53:25 <icbt> @seen lemmih
07:53:25 <lambdabot> I saw lemmih leaving #haskell-blah and #haskell 2 days, 12 minutes and 19
07:53:25 <lambdabot> seconds ago, and I have missed 4 seconds since then.
08:01:00 <Saulzar> blazoldX, You'd have to register - it may be easier to use the lisppaste2 
08:01:15 <Saulzar> lisppaste2, paste
08:01:15 <blazoldX> @listpaste2
08:01:16 <lambdabot> Unknown command, try @listcommands.
08:02:18 <Saulzar> http://paste.lisp.org/
08:02:35 <blazoldX> k tx
08:07:57 <vincenz> re
08:08:08 <jethr0> hey vincenz
08:08:14 <vincenz> hi, sorry for the delay
08:08:18 <vincenz> I went to sleep slightly later
08:08:25 <jethr0> hehe
08:08:41 <vincenz> got my mail?
08:08:42 <jethr0> i hope you will forgive me. i always have a tendency for rushing into programming :)
08:08:46 <jethr0> vincenz, not yet
08:08:50 <vincenz> oh
08:08:52 <vincenz> my repos changed
08:08:59 <jethr0> i'm pretty much finished with the parser
08:09:02 <vincenz> http://abstractoasis.dyndns.org:8080/repos/icfp
08:09:12 <vincenz> I added some stuff to TODO
08:09:16 <jethr0> only my (presumably written-before) test-cases are lacking
08:09:39 <jethr0> vincenz: yep, got your mail
08:11:31 <vincenz> join me on #meta-science?
08:45:22 <araujo> Good morning.
08:55:08 <vincenz> anyone have a better pattern than this
08:55:14 <vincenz>     readsPrec d ('r':'o':'b':'b':'e':'r':s)         = [(Robber, s)]
08:58:27 <ADEpt> import Parsec
08:58:27 <ADEpt> do symbol "Robber"; n<-number; return (Robber n)
08:58:27 <ADEpt> ?
08:59:00 <vincenz> hmm
08:59:07 <vincenz> it's for a read Instance
08:59:50 <edwinb> readsPrec d xs | take 7 xs == "robbers" = [(Robber,s)]
08:59:52 <edwinb> perhaps?
08:59:59 <edwinb> are there lots of these?
09:00:04 <vincenz> yeah a few
09:00:07 <vincenz> and I also want to use lex
09:00:11 <vincenz> to work with whitespace
09:00:15 <edwinb> do they have a handy token delimeter, say a space?
09:00:32 <vincenz> yip
09:01:54 <edwinb> you could try something like...
09:02:17 <edwinb> readsPrec d cs = case break isSpace cs of
09:02:37 <edwinb>      ("robber",rest) -> [(Robber,rest)]
09:02:38 <edwinb> etc
09:03:02 <vincenz> ah nice
09:03:04 <vincenz> what about lex?
09:03:19 <vincenz> something like
09:03:25 <vincenz> readsPrec d cs = do
09:03:29 <vincenz>   (s,t) <- lex cs
09:03:32 <vincenz> ...
09:03:39 * edwinb knows little of this lex...
09:04:45 <edwinb> hmmm, looks handy though.
09:04:49 <vincenz> yeah
09:05:14 <edwinb> probably neater for what you're doing
09:09:30 <vincenz> hmm
09:09:36 <vincenz> edwinb: for the case synta
09:09:41 <vincenz> what if there's no option?
09:09:51 <edwinb> what do you mean by option?
09:10:15 <vincenz> mind 6 lines ?
09:10:30 <edwinb> I don't, and everyone else is quiet ;)
09:10:34 <vincenz>   instance Read PType where
09:10:34 <vincenz>     readsPrec d r = do
09:10:34 <vincenz>       (s,t) <- lex r
09:10:34 <vincenz>       case s of
09:10:34 <vincenz>         "robber" -> return (Robber, t)
09:10:37 <vincenz>         "cop-foot" -> return (CopFoot, t)
09:10:40 <vincenz>         "cop-car" -> return (CopCar, t)
09:10:42 <vincenz> case is non-exhaustive
09:11:12 <edwinb> What is the semantics of read when there is an error? I rarely use read...
09:11:19 <vincenz> don't know
09:11:21 <vincenz> but I take...given return
09:11:22 <vincenz> fail?
09:11:25 <vincenz> cause typically it returns
09:11:30 <edwinb> _ -> error "Invalid input"
09:11:32 <vincenz> [(type, remainingstring)]
09:11:33 <edwinb> I suppose
09:11:40 <vincenz> error or fail?/
09:11:53 <edwinb> oh, it's a monad; fail then.
09:12:10 <vincenz> @type fail
09:12:11 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
09:15:28 <Saulzar> Are you working on competing implementations or the same one?
09:16:14 <vincenz> Saulzar: same one?
09:16:44 <vincenz> hmm
09:16:50 <vincenz> read has problems with same prefix
09:16:51 <integral> @index readFile
09:16:52 <lambdabot> System.IO, Prelude
09:16:54 <vincenz> for cop-fofot, cop-car
09:16:56 <vincenz> suggestions?
09:17:09 <Saulzar> I mean are you competing against jethr0 or working together? :)
09:17:15 <vincenz> working together
09:17:20 <vincenz> as an excercise in proper haskell
09:17:36 <vincenz>   instance Read PType where
09:17:36 <vincenz>     readsPrec d r = do
09:17:36 <vincenz>       (s,t) <- lex r
09:17:36 <vincenz>       trace s $ case s of
09:17:39 <vincenz>         "robber" -> return (Robber, t)
09:17:42 <vincenz>         "cop-foot" -> return (CopFoot, t)
09:17:44 <vincenz>         "cop-car" -> return (CopCar, t)
09:17:46 <vincenz>         _ -> fail "Undefined PType"
09:17:50 <vincenz> apparently case does not work with same-prefix strings
09:18:09 <vincenz> oh
09:18:10 <vincenz> n
09:18:10 <vincenz> nm
09:18:16 <vincenz> lex apparently stops at "-"
09:20:25 <vincenz> don't mind me
09:29:43 <vincenz> is it me or did haskell.org change?
09:30:23 <palomer> any gtk hackers around?
09:33:19 <ndm> vincenz: yes, its now the wiki page, instead of the old haskell.org static page
09:34:30 <vincenz> cool
09:39:32 <palomer> hrm, it seems that gtk2hs is missing the parts of gtk that I really need:/
09:39:43 <dcoutts> palomer, which are?
09:40:14 <palomer> get_iter_at_location()
09:40:15 <palomer> and
09:40:42 <palomer> gtk_text_tag_even
09:40:50 <palomer> actually, make that an or
09:41:08 <palomer> dcoutts: oh, and it seems that there's a bug with onMotionNotify
09:41:46 <palomer> if applied to a textview, the signal gets caught and suppressed by the textview
09:41:51 * dcoutts looks for get_iter_at_location
09:42:29 <palomer> I just read it off a forum
09:43:36 <dcoutts> palomer, see textViewGetIterAtLocation
09:45:30 <dcoutts> palomer, gtk_text_tag_event() ? what is that necessary for? it looks a bit internal.
09:45:34 <palomer> dcoutts: oh, very cool
09:46:08 <palomer> dcoutts: isn't it for signaling an event for the tag_event?
09:47:27 <palomer> http://www.rafb.net/paste/results/CxUi4a58.html <--this code is supposed to print hello everytime I move my mouse, but if I move my mouse inside the textview nothing happens
09:47:39 <dcoutts> palomer, it's for generating an event right, but normally that happens automatically right? I've not seen any examples where it is used.
09:50:06 <palomer> dcoutts: I thought I could do gtk_text_tag_event(onmouse,...) (however, if I can get onmotion to work, then I won't need to use tag, which would have been an ugly hack)
09:50:14 <vincenz> is it better to use foldr1 or foldl1?
09:51:10 <palomer> > foldr1 (:) [1..]
09:51:11 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
09:51:11 <lambdabot>   Expected type: a -> a -> a
09:51:11 <lambdabot>   Inferred type: a -> [a] -> [a]
09:51:33 <vincenz> palomer: it's for a foldl1 (.)
09:51:36 <vincenz> or foldr1 (.)
09:51:45 <palomer> > foldr1 (\x y -> x : y) [1..]
09:51:46 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
09:51:46 <lambdabot>   Expected type: [a]
09:51:46 <lambdabot>   Inferred type: a
09:52:11 <palomer> > foldr (\x y -> x @ y) nil [1..]
09:52:12 <lambdabot>  Not in scope: `nil'
09:52:14 <palomer> dcoutts: any ideas?
09:52:18 <palomer> > foldr (\x y -> x @ y) [] [1..]
09:52:19 <lambdabot>  Pattern syntax in expression context: x@y
09:52:21 <xerox> '@' ?
09:52:28 <palomer> > foldr (\x y -> (x ++ y)) [] [1..]
09:52:29 <lambdabot>  add an instance declaration for (Num [a])
09:52:35 <palomer> > foldr (\y x -> (x ++ y)) [] [1..]
09:52:35 <lambdabot>  add an instance declaration for (Num [a])
09:52:57 <xerox> > foldr (ap (++) return) [] [1..10]
09:52:58 <lambdabot>   Expecting a function type, but found `[a]'
09:52:58 <lambdabot>   Expected type: [a] -> [a] -> b -> b
09:52:58 <lambdabot>   Inferred type: [a] -> [a] -> [a]
09:53:00 <xerox> ok.
09:53:23 <palomer> > head $ foldr (\x y -> ([x]++y)) [] [1..] 
09:53:24 <lambdabot> 1
09:53:30 <palomer> > head $ foldl (\x y -> ([x]++y)) [] [1..] 
09:53:32 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
09:53:32 <lambdabot>   Expected type: [a]
09:53:32 <lambdabot>   Inferred type: [[a]]
09:53:41 <palomer> > head $ foldl (\x y -> (x++[y])) [] [1..] 
09:53:46 <lambdabot> Terminated
09:53:48 <palomer> foldr1 is better
09:53:57 <vincenz> hmm
09:53:58 <vincenz> why?
09:54:05 <palomer> because it works on infinite lists
09:54:12 <vincenz> of (.)?
09:54:14 <palomer> dcoutts: any idea?
09:54:15 <vincenz> that seems uiseless
09:54:25 <vincenz> foldr1 (.) [somelist of (x->x)]
09:54:42 <palomer> err, woops, I already asked you if you had an idea
09:54:48 * palomer kicks lambdabot
09:54:55 <vincenz> sure, blame it on lambdabot
09:55:34 <palomer> you want to compose endomorphisms?
09:56:01 <palomer> use foldr1
09:56:10 <palomer> > foldr (.) [id,id,id]
09:56:11 <lambdabot> Couldn't match `a -> c' against `[a1]'
09:56:16 <palomer> > foldr1 (.) [id,id,id]
09:56:17 <lambdabot>  add an instance declaration for (Show (c -> c))
09:56:27 <palomer> > foldr1 (.) [id,id,id] 5
09:56:28 <lambdabot> 5
09:56:50 <palomer> note, however, that function composition does not associate
09:57:30 <palomer> oh wait, it does
09:57:32 <palomer> nevermind:o
09:58:16 <vincenz> > let x' = 2 in x'
09:58:16 <lambdabot> 2
09:58:29 <palomer> s/left recursive/tail recursive
09:59:09 <palomer> @pl \a b c -> (a . b) . c
09:59:09 <lambdabot> ((.) .) . (.)
09:59:27 <palomer> @pl \a b c -> a . (b . c)
09:59:27 <lambdabot> (. (.)) . (.) . (.)
09:59:53 <palomer> is it possible to ask lambdabot to normalize combinators?
10:10:46 <vincenz> hmm
10:10:48 * araujo back from lunch
10:11:09 * palomer bashes gtk2hs over the head
10:11:19 * araujo having fun with gtk2hs
10:11:47 <basti_> palomer: whats your gtk2hs doing?
10:15:26 <vincenz> why is this false
10:15:28 <vincenz> 'n' `elem` "a-z"
10:15:30 <vincenz> > 'n' `elem` "a-z"
10:15:31 <lambdabot> False
10:15:42 <palomer> basti_: if I put on onMotionNotify on a textView, it will not notify if I move around in the textview
10:15:46 <basti_> > 'n' `elem` ['a'..'z']
10:15:48 <lambdabot> True
10:15:54 <basti_> > ['a'..'z']
10:15:54 <lambdabot> "abcdefghijklmnopqrstuvwxyz"
10:16:02 <vincenz> doh
10:16:11 <basti_> palomer: we saw that yesterday evening yes
10:16:22 <palomer> basti_: oh, hey basti_ :P!
10:16:35 <palomer> yeah, so that's where I am
10:16:36 <vincenz> > 'n' `elem` ['a'..'z','-',';']
10:16:36 <lambdabot>  parse error on input `,'
10:16:38 <vincenz> hmm
10:16:41 <palomer> basti_: though I think I may have found the problem
10:16:49 <palomer> basti_: I may have to attach it to the children
10:17:00 <palomer> @hoogle [a] -> (a -> IO b) -> IO b
10:17:01 <lambdabot> No matches, try a more general search
10:17:07 <basti_> "attach"?
10:17:14 <basti_> vincenz: use ++
10:17:17 <palomer> the onMotionNotify
10:17:33 <palomer> is there a fold on monads?
10:17:37 <basti_> I don't think this is right palomer but don't let that stop you.
10:17:39 <palomer> @Mfold
10:17:39 <lambdabot> Unknown command, try @listcommands.
10:17:43 <basti_> @type foldM
10:17:44 <palomer> @hoogle mfold
10:17:44 <lambdabot> Not in scope: `foldM'
10:17:44 <lambdabot> No matches found
10:17:49 <palomer> @hoogle foldM
10:17:49 <lambdabot> Control.Monad.foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m
10:17:49 <lambdabot> a
10:17:49 <lambdabot> Control.Monad.foldM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()
10:17:49 <lambdabot> Data.Graph.Inductive.Monad.ufoldM :: GraphM m gr => (Context a b -> c ->
10:17:49 <lambdabot> c) -> c -> m (gr a b) -> m c
10:17:50 <basti_> whatsthename
10:17:51 <basti_> ah
10:18:25 <palomer> @type foldl
10:18:26 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
10:20:56 <dcoutts> palomer, I'm back. Where were we?
10:22:25 <dcoutts> palomer, ah, you want to handle when a tag recieves an event, rather than generating an event in a tag.
10:22:27 <palomer> http://www.rafb.net/paste/results/CxUi4a58.html <--this doesn't print hello when I move my mouse inside the textview
10:22:56 <palomer> dcoutts: the tag was simply a hack to get around the peculiar behaviour of the onMouseMotion
10:23:04 <dcoutts> palomer, that's probably by design and so there's not much we can do. So yes we should be using the tag events.
10:23:39 <dcoutts> so you don't want gtk_text_tag_event() which 'synthetically' generates an event in a tag
10:23:58 <dcoutts> you want to add a tag signal handler
10:24:14 <palomer> dcoutts: I'd like a signal to be emitted when I go over a particular tag
10:24:26 <dcoutts> palomer, that probably happens automatically
10:24:40 <dcoutts> so try:
10:24:57 <palomer> a mouse signal, that is
10:25:12 <dcoutts> onTextTagEvent myTag $ do
10:25:15 <dcoutts>   ...
10:25:26 <dcoutts> oh hmm
10:25:37 <dcoutts> onTextTagEvent myTag $ \event textIter -> do
10:26:53 <dcoutts> palomer, try that. It should at least work for clicking tags. It may be necessary to enable something else for just mouse over events or it may "just work".
10:28:06 <palomer> onTextTagEvent?
10:28:09 <palomer> that's not in my namespace
10:28:54 <ihope> Is using otherwise in case statements pretty much just a convention?
10:29:24 <ihope> > (\x -> case x of {3 -> 3; udderwyze -> 4}) 5
10:29:25 <lambdabot> 4
10:30:13 <dcoutts> palomer, it may only be in the current development version. I think someone else asked for it recently.
10:30:18 * dcoutts checks.
10:31:05 <dcoutts> http://haskell.org/gtk2hs/docs/devel/Graphics-UI-Gtk-Multiline-TextTag.html#v%3AonTextTagEvent
10:31:11 <franka> ihope: Yes, it's just a convention.
10:31:21 <franka> In guards.
10:31:28 <dcoutts> palomer, yeah, it's in the current darcs version but not in version 0.9.10
10:31:38 <ihope> Yeah. I was thinking it was used in the patterns themselves :-P
10:31:50 <ihope> It could be, of course.
10:31:52 <dcoutts> palomer, darcs get --partial http://darcs.haskell.org/gtk2hs/
10:32:12 <franka> otherwise is defined as False.
10:32:23 <ihope> As True, isn't it?
10:32:25 <ihope> > otherwise
10:32:25 <franka> er, True
10:32:26 <lambdabot> True
10:32:27 <palomer> dcoutts: so there is really no way to do this with onMotion? putting thousands of tags in my textview doesn't seem like the best idea
10:32:52 <ihope> @type \x -> (Left x : x)
10:32:53 <lambdabot>   Occurs check: cannot construct the infinite type: a = [Either a b]
10:32:53 <lambdabot>   Expected type: [Either a b]
10:33:21 <ihope> @type \x -> Right (Left x : x)
10:33:22 <lambdabot>   Occurs check: cannot construct the infinite type: a = [Either a b]
10:33:22 <lambdabot>   Expected type: [Either a b]
10:33:32 <dcoutts> palomer, let me take a look.
10:49:28 <dcoutts> palomer, it's actually not as ineffecient as it sounds. One One TextTag can be applied to any number of text ranges. This is convenient since the event is generated on the tag itself. So you only need one tag and one signal handler.
10:50:27 <dcoutts> palomer, there is a table that records which tags are where so it's quite possible to have a tag apply to loads of bits of text.
10:50:47 <dcoutts> or I guess you could have one tag covering the whole text.
10:51:09 <Cale> good morn- er... afternoon!
10:51:13 <palomer> dcoutts: yes, but I'm parsing text, and I want every word on my textview to give me a trace of the productions its part of
10:51:28 <palomer> dcoutts: so regardless, I'll need at least one tag per word
10:51:32 <Saulzar> good ev... er morning Cale :)
10:51:36 <palomer> and then one tag per production
10:51:37 <Cale> :)
10:51:40 <palomer> so there will be thousands of tags
10:52:59 <dcoutts> palomer, hmm it looks like the gtk-demo uses the motion notify event on a text view
10:53:09 <dcoutts> palomer, so it looks like it ought to work
10:53:22 <dcoutts> palomer, where was your example code that showed it didn't work?
10:53:29 <dcoutts> I'd like to test it
10:55:13 <palomer> http://www.rafb.net/paste/results/pXskqM85.html
10:57:27 <dcoutts> palomer, works for me
10:57:44 <palomer> dcoutts: when you move your mouse inside the textview?
10:57:51 <palomer> it prints hello many times?
10:57:56 <dcoutts> yep, but it only prints it once
10:58:00 <dcoutts> because...
10:58:49 <dcoutts> oh, hmm
10:59:38 <palomer>  If hint is False, a callback for every movement of the mouse is generated. To avoid a backlog of mouse messages, it is usually sufficient to sent hint to True, generating only one event. The application now has to state that it is ready for the next message by calling drawWindowGetPointer
11:01:34 <dcoutts> palomer, yep I though you'd got it the other way around, but you're quite right you've got it the correct way round.
11:01:36 <dcoutts> however...
11:02:11 <dcoutts> the textview on it's own has set this hint to only get motion events as quickly as it can process them
11:02:35 <dcoutts> so actually you have to do the stuff it says for when you pass True
11:02:48 <dcoutts> I modified your code like this to get it to work:
11:02:55 <dcoutts>   onMotionNotify textview False $ \_ -> do
11:02:55 <dcoutts>     putStrLn "hello"
11:02:55 <dcoutts>     Just win <- textViewGetWindow textview TextWindowText
11:02:55 <dcoutts>     drawWindowGetPointer win
11:02:55 <dcoutts>     return False
11:04:15 <palomer> you're a lifesaver
11:04:28 <dcoutts> palomer, it's because the TextView is a fairly complex widget that does quite a bit of it's own processing for mouse over events so it's using this rate limiting hint
11:05:03 <palomer> dcoutts: but shouldn't onMotionNotify overwrite anything textview does?
11:05:17 <palomer> s/overwrite/override
11:05:44 <dcoutts> palomer, perhaps, at the moment we only extend the number of hints.
11:05:45 <palomer> and what does getPointer do?
11:06:21 <dcoutts> "Obtains the current pointer position and modifier state."
11:06:24 <dcoutts> http://haskell.org/gtk2hs/docs/current/Graphics-UI-Gtk-Gdk-DrawWindow.html#v%3AdrawWindowGetPointer
11:06:30 <palomer> but then you don't do anything with it!
11:06:37 <dcoutts> yeah :-)
11:06:44 <palomer> how does that work?
11:06:47 <dcoutts> it's sort of overloaded
11:07:08 <dcoutts> it's side effect is to tell the window system that we're ready for the next mouse motion event
11:07:31 <palomer> you should put that in the docs:P
11:07:54 <palomer> (you should also put in the docs that the hint can be overwritten by the widget)
11:08:00 <dcoutts> the onMotionNotify docs do say that
11:08:17 <palomer> dcoutts: right, but that's only if the hint is True
11:08:25 <dcoutts> oh, yes well I didn't know that the hint gets set by some widgets
11:08:28 <dcoutts> I do now :-)
11:08:42 <palomer> btw, I want to draw a box over my cursor
11:08:51 <palomer> a coloured box
11:08:53 <palomer> with some text inside
11:09:08 <palomer> in fact, many coloured boxes with text inside, all different colours
11:09:19 <palomer> and it moves around with my cursor
11:09:31 <dcoutts> you can use tags to set the background colour
11:09:37 <vincenz> how would you do an eol
11:09:43 <vincenz> where eol :: ReadS ()
11:09:47 <vincenz> such that it skips eols
11:09:55 <frobenius> how can I use ! in datatypes for strictness when I have a record like   data Rec f = In { out : f (Rec f) } ?
11:10:07 <palomer> dcoutts: so what primitive do I use?
11:10:28 <dcoutts> palomer, I'm not quite sure what effect you're trying to achieve
11:10:57 <palomer> dcoutts: an identical effect as a tooltip
11:11:02 <dcoutts> palomer, for setting backgrond text colour you create a tag and set its background colour and then apply that tag to bits of the text
11:11:15 <dcoutts> ah, a tooltip
11:11:30 <palomer> well, many tooltips, stacked on to each other
11:11:35 <palomer> and each tooltip is of a different colour
11:11:37 <dcoutts> I've looked into that before, I fear it may be somewhat tricky
11:11:43 <dcoutts> tooltips I means
11:11:51 <palomer> can I just muck around with drawWindows?
11:12:07 <dcoutts> yeah you can just draw onto the textview's draw window
11:12:29 <dcoutts> however you'll have to be careful about how that interacts with the textviews own drawing
11:12:41 <palomer> dcoutts: can I draw boxes filled with text?
11:12:46 <dcoutts> sure
11:12:50 <palomer> how so?
11:13:09 <dcoutts> well if you're just drawing into a DrawWindow then you draw a box and then some text
11:13:17 <dcoutts> you use the Gdk drawing functions
11:13:37 <dcoutts> http://haskell.org/gtk2hs/docs/current/Graphics-UI-Gtk-Gdk-Drawable.html
11:14:02 <dcoutts> the proper way of doing tooltips is to use a seperate top level window with no border
11:14:30 <dcoutts> palomer, are these boxes going to be on top of the text or somehow part of it?
11:14:44 <palomer> dcoutts: well, they're actually going to be on top of the text
11:14:47 <palomer> and they will hide text
11:14:53 <dcoutts> right ok
11:14:58 <palomer> (whatever text would have been on top of it)
11:15:19 <dcoutts> and there will be several of these on top of each other?
11:15:23 <palomer> yeah
11:15:51 <palomer> and, ultimately, I'd like to make them clickable
11:16:10 <dcoutts> perhaps you want proper popup windows
11:16:11 <palomer> so, what you would do is put your mouse over a piece of text, the boxes would appear
11:16:26 <palomer> then you'd click the middle mouse button
11:16:28 <dcoutts> rather than just drawing onto the text view
11:16:38 <dcoutts> that way you can handle events in a sane manner
11:17:00 <palomer> dcoutts: sure, how can I stick a popup window in the xy-coordinate of a textview?
11:17:32 <palomer> and then destroy it when I want
11:17:45 <dcoutts> it'd be actually on top and you'd work out the coordinates using some textview functions
11:17:57 <dcoutts> to map text view coordinates to buffer coords
11:18:03 <dcoutts> and then to global screen coords
11:18:43 <palomer> oh, so it would be a top level window
11:19:00 <palomer> why not make it a child of the main window?
11:20:58 <dcoutts> that's not really how gtk+ works, it manages child windows via containers and layout.
11:21:08 <dcoutts> tooltips use top level windows
11:21:31 <dcoutts> tipWindow <- windowNew
11:21:45 <dcoutts> set tipWindow [ windowType := WindowPopup ]
11:22:33 <dcoutts> palomer, what you're tring to do is not all that easy I'm afraid
11:22:50 <dcoutts> and there are a number of different possabilities
11:22:59 <palomer> how do you convert textview coordinates to screen coordinates?
11:23:15 <SimonRC> if I build a thunk that calculates a huge datastructure, fork, and one of the threads fully evaluates the datastructure, will the datastructure have been evaluated in the other thread as well?
11:24:22 <SimonRC> I wish to be able to precalculate some large data while waiting for the user's keystrokes.
11:25:19 <dcoutts> palomer, textViewBufferToWindowCoords / textViewWindowToBufferCoords
11:26:03 <dcoutts> palomer, the other possability is textViewAddChildAtAnchor or textViewAddChildInWindow
11:26:13 <dcoutts> along with textViewMoveChild
11:26:16 <dcoutts> perhaps
11:26:27 <palomer> oh, that option seems tantalizing
11:26:31 <palomer> what are the disadvantages?
11:26:59 <dcoutts> I'm not 100% sure, let me think
11:27:15 <dcoutts> it could well be the simpler option
11:27:29 <dcoutts> you'd want to delete them when you scroll the window I guess
11:27:39 <edwinb> simonrc: where are you keeping this data?
11:27:45 <dcoutts> and delete them when the mouse moves outside the box right?
11:28:00 <palomer> dcoutts: it would probably dissapear when the mouse reaches the scroll button
11:28:08 <dcoutts> palomer, so these boxes are actually underneath the mouse pointer right?
11:28:21 <dcoutts> not like tooltips which are next to the mouse pointer?
11:28:23 <SimonRC> edwinb: in a Data.Map.Map (Integer, Integer) BigType
11:28:26 <palomer> dcoutts: oh no, I'd want them on top of the text pointed to by the mouse
11:28:40 <edwinb> simonrc: yes, but where are you keeping that? how are you sharing it between the threads?
11:28:45 <dcoutts> palomer, so when does the coloured box dissapear?
11:28:57 <SimonRC> edwinb: Not decided yet.
11:28:58 <palomer> dcoutts: when you're not pointing on the text anymore
11:29:16 <palomer> dcoutts: if you aren't pointing at any text, then it dissapears completely, else it appears on top of the word you're pointing at 
11:29:23 <dcoutts> ok
11:29:32 <SimonRC> Aha!  Maybe I can fork off a thread to precalculate just before I block for user input, then kill it once I get input.  """killThread terminates the given thread (GHC only). Any work already done by the thread isn't lost: the computation is suspended until required by another thread."""
11:29:41 <dcoutts> palomer, I'm just wondering how you could track that reliably
11:29:58 <palomer> dcoutts: so let's say you're pointing on the "c" of "cool", then a popup would appear on top of the c, (literally no top, not covering it)
11:30:07 <palomer> and if the word "bad" is on top of "cool", then bad would probably dissapear
11:30:26 <palomer> and if you're pointing to the "l" of "cool", the popup would still appear on top of the "c"
11:31:01 <dcoutts> I don't understand your second case there with bad & cool
11:31:06 <edwinb> simonrc: how you share it will have some bearing on the answer to your question, you see...
11:31:45 <palomer> dcoutts: ok, when I say "on top" I mean with a greater y coordinate (or is it smaller?)
11:32:24 <palomer> dcoutts: when I say "a covers b", I mean that the retangle describing a covers the rectangle covering b
11:32:59 <palomer> so let's say the totality of my text is "bad \n cool"
11:33:04 <dcoutts> palomer, so if I move the mouse over a word in the underlying text then a box appears a little higher up the page (obscusing part pf the line above)
11:33:20 <dcoutts> and if I move the mouse over that box then it should dissapear right?
11:33:21 <palomer> dcoutts: it would probably obfuscate many lines above
11:33:29 <palomer> dcoutts: yes
11:33:32 <dcoutts> ok, it's a big box
11:33:38 <dcoutts> ok that sounds doable
11:33:51 <SimonRC> edwinb: I was thinking of creating the data, then in one of the routines the manipulate it, fork, so both threads have a reference to the data.
11:33:52 <palomer> dcoutts: so I need to calculate the size of the popup window, right?
11:34:06 <palomer> since windows are positioned according to the top left
11:34:19 <zacch> hi - I'm trying to make use of memoization for the minimal edit distance example from here: http://en.wikipedia.org/wiki/Talk:Levenshtein_distance
11:34:25 <waern> dcoutts, maybe you know this - lemmih's ghc.ide repos just includes the ghc source.. but don't I need many of the packages that usually comes with ghc as well (base package for instance)?
11:34:32 <vincenz> out of curiousity
11:34:34 <palomer> dcoutts: oh, but if I click the middle mouse button then the boxes don't dissapear, and I can click on one of them
11:34:43 <vincenz> I would like to do something like this :
11:34:57 <palomer> (actually, move my mouse over one of them)
11:35:05 <vincenz> readTagged t f :: String -> ReadS a -> ReadsA
11:35:10 <dcoutts> palomer, you'd connect to the onEnterNotify of the popup window to get it to disapear if the mouse goes over it. Since otherwise that would prevent events from getting to the text view underneath.
11:35:24 <vincenz> readTagged t f = [(x,y) |
11:35:27 <palomer> dcoutts: oh, good point
11:35:32 <vincenz>    (t1,s') <- lex 
11:35:35 <dcoutts> palomer, oh, so the box doen't disapear if you move over it?
11:35:38 <vincenz> but I would like to check that t1 == t
11:35:39 <vincenz> else fail
11:35:41 <vincenz> how do I do this?
11:35:43 <dcoutts> palomer, since you can click on it?
11:35:56 <palomer> dcoutts: if I click the middle mouse button, then I enter "box never dissapears mode"
11:36:11 <vincenz> ?
11:36:19 <palomer> dcoutts: in which case I can move my mouse over the box
11:36:22 <dcoutts> palomer, so the box cannot immediately disapear when the mouse enters it
11:36:24 <dcoutts> ok
11:36:35 <dcoutts> so when does it disapear?
11:36:35 <palomer> dcoutts: it depends if I'm in normal mode or "box never dissapears" mode
11:36:45 <dcoutts> like if I want to see the text underneath
11:36:53 <vincenz> @type 1=
11:36:54 <lambdabot> parse error on input `='
11:36:55 <vincenz> @type !=
11:36:57 <lambdabot> parse error on input `!='
11:37:00 <palomer> dcoutts: well, you make sure you're in normal mode, then you move your mose over it
11:37:00 <vincenz> @type (!=)
11:37:00 <lambdabot> Not in scope: `!='
11:37:02 <palomer> @type (/=)
11:37:03 <lambdabot> forall a. (Eq a) => a -> a -> Bool
11:37:20 <lisppaste2> Phas pasted "msgclient.sh" at http://paste.lisp.org/display/16183
11:37:21 <dcoutts> waern, yes you do. They are in seperate per-package repos.
11:37:33 <palomer> s/mose/mouse
11:37:43 <lisppaste2> Phas annotated #16183 with "il mio errore :|" at http://paste.lisp.org/display/16183#1
11:37:44 <vincenz> I'm trying to do something like readParens
11:37:49 <vincenz> but with something more complex than a single character
11:37:52 <vincenz> how do I check if the tag is correct
11:37:54 <vincenz> otherwise fail?/
11:38:03 <waern> dcoutts, okay 
11:38:11 <dcoutts> palomer, ok fair enough, so middle click in the normal text view changes the box persist mode.
11:38:13 <phas> Someone could put an eye on the code i pasted? pls
11:38:52 <palomer> dcoutts: yeah, and in box persist mode, I can move my mouse over different boxes to highlight different parts of my text
11:39:05 <SimonRC> phas: ...
11:39:08 <dcoutts> waern, I've not actually built ghc from the new darcs repo system yet so I'm probably not the best person to ask.
11:39:30 <dcoutts> palomer, and you can have mutliple boxes all at once?
11:39:38 <jyp> waern: you need libraries
11:39:47 <palomer> dcoutts: no, only one
11:39:54 <dcoutts> palomer, ok that makes things easier.
11:39:55 <palomer> in box persist mode, no new boxes appear
11:40:14 <dcoutts> palomer, so you can just hide and show one widget
11:40:26 <dcoutts> palomer, rather the creating and destroying them all the time
11:40:38 <palomer> yeah
11:40:51 <dcoutts> palomer, yeah you'll need to let the box calculate its size before positioning it over the text view
11:41:05 <SimonRC> phas: the problem is with pattern-matching on the result of getArgs.
11:41:07 <jyp> waern: actually checkout this page: http://hackage.haskell.org/trac/ghc/wiki/GhcDarcs
11:41:19 <SimonRC> @type (:)
11:41:21 <palomer> dcoutts: can't I just fill the child window and then get the child window's size?
11:41:21 <lambdabot> forall a. a -> [a] -> [a]
11:41:27 <vincenz> ould someone hlep me with http://rafb.net/paste/results/lhYbJe17.html
11:41:59 <dcoutts> palomer, yes but you want to fill it in before showing it
11:42:15 <palomer> dcoutts: and then when the mouse moves, empty the child window then fill it up again, etc...
11:42:17 <dcoutts> palomer, and it only calculates its size just before being displayed
11:42:21 <SimonRC> vincenz: what's the problem?
11:42:33 <vincenz> SimonRC: won't compile
11:42:49 <dcoutts> palomer, I'm not quite sure of the details of that, just letting you know it'll be something to watch out for.
11:42:54 <phas> SimonRC, It seems ok to me, can you see the error?
11:43:03 <SimonRC> vincenz: So, what's the error message?
11:43:09 <SimonRC> phas: yes...
11:43:53 <dcoutts> palomer, you will have to use textViewAddChildInWindow rather than textViewAddChildAtAnchor. I think.
11:44:02 <SimonRC> phas: pattern matching a list against (a:b:c) makes a the first item, b the second, and c the rest of the list.
11:44:27 <SimonRC> phas: so the types are String, String, and [String]
11:44:56 <palomer> and the TextWindowType would be TextWindowWidgetL
11:44:57 <palomer> ?
11:45:08 <SimonRC> you need to remember what : actually *is*, and that it is right-associative.
11:47:13 <dcoutts> palomer, TextWindowText I think
11:47:33 <phas> SimonRC, D'UH! thx, i totally forgot it
11:47:49 <jethr0> parsec, anyone ? :)
11:47:55 <phas> SimonRC, an "unwords" after, it works :)
11:48:28 <SimonRC> jethr0: I know a bit, yes
11:48:31 <dcoutts> palomer, I'll be interested to keep up with how you get on with this since I think hIDE will need something similar for managing "calltips"
11:48:54 <dcoutts> palomer, ie function name completions and inline type or documentation popups
11:49:05 <jethr0> SimonRC: i was wondering how to continue the parser once it has found some tokens
11:49:08 <palomer> dcoutts: sure, I'll be releasing the result when it's done (probably in a couple of hours)
11:49:29 <dcoutts> palomer, what project is this for? sounds like a language analysis tool.
11:49:37 <jethr0> SimonRC: let's say i'm working on stdin and want to match "hello". then do sth else and later match "world" in stdin
11:49:57 <SimonRC> hmm
11:50:16 <jethr0> SimonRC: for example, i read sth on stdin, write an answer on stdou and wait for a reply
11:51:20 <SimonRC> Is it possible to write an expression that parses all of it, then rely in lazyness to do things in bits?
11:51:46 <jethr0> yes, i just had that idea. would that be the way to do it?
11:52:37 <SimonRC> I assume so.
11:52:50 <SimonRC> Why do you want to parse things in bits?
11:52:56 <edwinb> I guess if your parser returns a list of responses, you could handle each response lazily.
11:53:01 <palomer> dcoutts: it's actually for displaying infered types
11:53:30 <jethr0> SimonRC: well, it's for a communications protocoll.
11:54:06 <dcoutts> palomer, right, cool. hIDE will want that feature too. :-)
11:54:11 <SimonRC> jethr0: You could parse and store all the data, then use the bits you need as you need them.
11:54:24 <jethr0> hmm, i guess i'll have to try :)
11:55:14 <vincenz> How do I simplifiy htis
11:55:15 <vincenz>       else do
11:55:15 <vincenz>         (x,u)    <- readTerminated f $ s
11:55:15 <vincenz>         return (x,u)
11:55:17 <dcoutts> palomer, actually I've got a analysis that is much like type inference where that kind of thing would be really handy.
11:55:44 <dcoutts> palomer, is that a post-grad project then?
11:56:13 <SimonRC> vincenz: waitamo
11:56:28 <vincenz> oki
11:56:30 <vincenz> but got it :)
11:56:36 <SimonRC> vincenz: you should know your monad laws: "do { a <- f; return a; }" is equivalent to "f"
11:56:39 <palomer> @hoogle Double -> Int
11:56:40 <lambdabot> Text.Regex.Posix.regExtended :: Int
11:56:40 <lambdabot> Text.Regex.Posix.regIgnoreCase :: Int
11:56:40 <lambdabot> Text.Regex.Posix.regNewline :: Int
11:56:43 <palomer> dcoutts: err, kind of
11:56:45 <vincenz> thx
11:59:30 <vincenz> @pl x (a b) c
11:59:31 <lambdabot> x (a b) c
11:59:34 * palomer wishes he could get lambdabot to message him full hoogle results
11:59:59 <palomer> eh, there are no functions from Double to Int?
12:00:17 <palomer> oh, floatDigits works
12:00:54 <phas> I've to read some data from a configuration file
12:01:06 <musasabi> palomer: like round ?
12:01:14 <musasabi> > round 2.2
12:01:15 <tibbe> is ghci implemented in haskell?
12:01:16 <lambdabot> 2
12:01:16 <phas> there is some specific library that i could use, or i've to do all with the IO
12:01:24 <phas> ?
12:01:27 <musasabi> tibbe: yes.
12:01:42 <tibbe> musasabi, is the source available? perhaps even online?
12:01:46 <musasabi> small parts of the rts are in C.
12:01:55 <musasabi> tibbe: darcs.haskell.org/ghc ?
12:02:18 <vincenz> @hoogle ReadS a -> ReadS [a]
12:02:19 <lambdabot> No matches, try a more general search
12:02:21 <musasabi> tibbe: or if you prefer a tarball then http://haskell.org/ghc -> download
12:02:40 <vincenz> @hoogle (Monad m) => m a -> m [a]
12:02:42 <lambdabot> No matches, try a more general search
12:02:42 <tibbe> musasabi, the darcs repo will do nicely
12:02:48 <palomer> ok, there's something I don't understand
12:02:50 <palomer> musasabi: oh, righto
12:02:55 <vincenz> any suggestions to read multiple thingies?
12:03:02 <vincenz> such that I can do
12:03:03 <vincenz> readMultiple reads
12:03:16 <palomer> textViewGetWindow returns a drawWindow, so I'm adding a widget to a drawWindow when I call textViewAddChildInWindow
12:03:24 <palomer> ?
12:03:27 * palomer pokes dcoutts 
12:03:53 <musasabi> tibbe: --partial to darcs will probably make sense for you.
12:03:54 <musasabi> (c
12:03:59 <vincenz> ?
12:04:00 <dcoutts> palomer, mm, not quite
12:04:06 <vincenz>   readMultiple :: ReadS a -> ReadS [a]
12:04:10 <vincenz> suggestions?
12:04:47 <dcoutts> palomer, well sort of I guess. It's just that a textview is made up of several parts, so you're selecting which part you're adding your child widget to.
12:05:16 <palomer> http://www.rafb.net/paste/results/swTZSK66.html
12:05:16 <tuomov> sigh.
12:05:35 <dcoutts> palomer, eg it's got the text part and also a gutter down the side which can have lin number and you can draw your own things like icons to indicate hilighted lines etc.
12:05:36 <tuomov> I'm really getting pissed off with ghc6.4
12:05:57 <tuomov> it's a constant library-reinstallation and unhiding and etc. cycle
12:06:09 <dcoutts> palomer, so you'll just select the main text area of the widget.
12:06:12 <vincenz> anyone know how to impl
12:06:17 <vincenz>   readMultiple :: ReadS a -> ReadS [a]
12:06:58 <palomer> dcoutts: I should be able to create a new window, set it as the child of the textview and then call textViewAddChildrenInWindow, right?
12:07:15 <tuomov> it's impossible to do any realword programs with ghc6.4
12:07:22 <tuomov> programs that depend on fancy libraries
12:07:26 <dcoutts> palomer, well calling textViewAddChildrenInWindow makes it a chile of the textview
12:08:01 <palomer> right
12:08:10 <dcoutts> palomer, and probably you don't want to make a new window, just a simple widget like a DrawingArea.
12:09:03 <dcoutts> palomer, since this box is going to be a child window of the textview, not a top level window.
12:09:26 <palomer> dcoutts: http://www.rafb.net/paste/results/Mq2Q8K98.html
12:09:42 <kevind_> hmm, have they considered getting rid of _|_ in future versions of Haskell?
12:09:49 <palomer> dcoutts: I thought of using a popup menu
12:10:05 <kevind_> sticking non-termination and non-exhaustive case matching in a monad or something
12:10:30 <edwinb> kevind: people have thought of it, but not in Haskell afaik.
12:10:32 <palomer> > _|_
12:10:32 <lambdabot>  parse error on input `|'
12:10:39 <edwinb> it does completely change the style of programming in many ways
12:10:45 <SimonRC> Oh no!  Haskell is turning into Epigram! :-)
12:11:06 <SimonRC> palomer: nonono...
12:11:08 <edwinb> There was David Turner's Strong Functional Programming paper which proposes that kind of thing.
12:11:10 <palomer> kevind_: remove recursion?
12:11:21 <SimonRC> > let (a:_) <- [] in a
12:11:22 <lambdabot>  parse error on input `<-'
12:11:25 <kevind_> remove fix
12:11:26 <SimonRC> > let (a:_) = [] in a
12:11:27 <lambdabot> Add a type signature
12:11:33 <kevind_> perhaps keep structural recursion
12:11:38 <SimonRC> > let (a:_) = [] in (a::Int)
12:11:40 <lambdabot>  Irrefutable pattern failed for pattern (a : _)
12:11:40 <kevind_> but put general recursion in a monad
12:11:52 <SimonRC> palomer: that's _|_
12:11:56 <robdockins> the limitation to structural recursion is a REAL pain
12:12:08 <tibbe> ghci generates byte code?
12:12:09 <palomer> how would you write the factorial function without recursion? monadic factorial?
12:12:11 <dcoutts> palomer, re the gtk error, like I said, you can't use "tipWindow <- windowNew"
12:12:13 <kevind_> that why a monad would be good
12:12:20 <dcoutts> palomer, since that makes a top level window
12:12:22 <edwinb> You don't remove recursion
12:12:25 <SimonRC> palomer: recursion on one of the arguments
12:12:27 <edwinb> you remove general recursion
12:12:31 <palomer> dcoutts: oh, I missed that
12:12:32 <kevind_> just use the monad for programs and you are free to write total functions outside the monad
12:12:34 <dcoutts> palomer, you want a simple widget
12:12:40 <dcoutts> palomer, eg DrawingArea
12:12:48 <edwinb> and you gain a lot; both the ability to guarantee properties of your programs, and potential optimisations.
12:12:51 <palomer> ah, righto
12:12:51 <kevind_> that way Tim Sheard stuff could actually work
12:13:13 <SimonRC> The ability to prove tha things *always* work would certainly help.
12:13:16 <kevind_> with real proofs, rather than "proofs"
12:13:52 <SimonRC> Though you'd have to think quite hard to express some forms of recursion.
12:14:10 <edwinb> most general recursive stuff can be made structurally recursive without too much work.
12:14:16 <dcoutts> palomer, yeah with "tipWindow <- drawingAreaNew" it works for me
12:14:16 <palomer> yeah, a menu looks fine
12:14:25 <robdockins> "most" being operative
12:14:27 <dcoutts> palomer, what's that then?
12:14:28 <SimonRC> And you have to have generalised recusion *somewhere*, or you aren't Turing-complete.
12:14:35 <edwinb> there are examples where it's a bit of a pain, but I think if you want (or need)  to prove things about your programs, it's worth the pain.
12:14:41 <kevind_> So just use a monad, haskell programmers are used to sticking everything in IO
12:14:42 * SimonRC silences edwinb for a moent.
12:14:51 <edwinb> simonrc: why?
12:15:02 <kevind_> just push non-termination into IO, and make non-IO truly pure
12:15:03 <robdockins> If you want or need to prove things about programs, use a theorem prover
12:15:07 <edwinb> No.
12:15:14 <edwinb> it's not quite that clear cut
12:15:16 <SimonRC> so you don't say "Turing completeness is overrated."
12:15:24 <palomer> dcoutts: I made it into a Menu and it gives me: (a.out:10863): Gtk-CRITICAL **: gtk_text_view_add_child_in_window: assertion `child->parent == NULL' failed
12:15:40 <palomer> dcoutts: ie, tipWindow <- menuNew
12:15:47 <edwinb> if you have programs that use _|_ in some way, proving theorems about them doesn't necessarily help...
12:15:47 <dcoutts> palomer, again, popup menues are actually top level windows
12:15:52 <dcoutts> that float over other things
12:15:57 <palomer> oh, crap
12:15:58 <edwinb> you get stronger guarantees if you remove _|_
12:16:10 <palomer> dcoutts: so I have to use a drawingarea?
12:16:18 <SimonRC> edwinb: how does one describe a new sort of recusion to a compiler?
12:16:19 <dcoutts> palomer, not you don't have to
12:16:53 <dcoutts> palomer, the requirements are: not top level, must have it's own DrawWindow (ie not a label, but could be a label inside an event box)
12:16:56 <kevind_> fix :: (a -> a) -> NonTermination a
12:17:02 <edwinb> simonrc: the way Epigram does it, for example, is to eliminate *all* forms of recursion, but implement recursion operators.
12:17:05 <palomer> dcoutts: are there any non top level menu like widgets?
12:17:35 <dcoutts> palomer, an hbox full of other widgets like buttons
12:17:42 <SimonRC> edwinb: how do you show that a recursion operator terminates, then?  You don't want to go writing Y.
12:17:54 <dcoutts> palomer, what goes in this box again?
12:17:55 <palomer> kevind_: we could have a three level type system: basic types, non terminating types and monadic types
12:18:14 <kevind_> partiality is a monad
12:18:15 <palomer> dcoutts: right now, simply text
12:18:22 <edwinb> simonrc: certain kinds of recursion are known to terminate; primitive recursion on inductive types, for example.
12:18:34 <jethr0> i won't get this parsec thing to work (even mentally)
12:18:45 <edwinb> kevind_: I think Thorsten Altenkirch has worked on this kind of stuff.
12:18:47 <dcoutts> palomer, I'd use an EventBox with a Label inside it.
12:18:49 <dcoutts> http://haskell.org/gtk2hs/docs/current/Graphics-UI-Gtk-Misc-EventBox.html
12:19:10 <dcoutts> http://haskell.org/gtk2hs/docs/current/Graphics-UI-Gtk-Display-Label.html
12:19:16 <tuomov> hmm.. hscurses seems to work, though.
12:19:23 <ihope> Hmm, Haskell without recursion.
12:19:26 <ihope> Sounds odd.
12:19:28 <tuomov> dons: I'm still having problems with hs-plugins
12:19:32 <tuomov> it gets lost all the time.
12:19:37 <SimonRC> ihope: without *generalised* recursion
12:19:48 <palomer> dcoutts: oh, but there could be many lobels, each with a different colour
12:19:52 <ihope> What about without recursion at all? >:-)
12:19:52 <tuomov> Either GHC6.4 is a totally fucked up mess, or hs-plugins installation is broken.
12:20:01 <ihope> Except for inside the monad, of course.
12:20:07 <tibbe> writing an interpreter is harder than I thought
12:20:10 <palomer> dcoutts: so a VBox with EventBoxes with labels, right?
12:20:11 <kevind_> yeah, get rid of all recursion
12:20:22 <kevind_> make people implement it with references
12:20:29 <robdockins> somewhat apropos the recursion discussion: http://lambda-the-ultimate.org/node/1248
12:20:30 <ihope> Have fix be a primitive...
12:20:41 <ihope> And the monad be abstract.
12:20:42 <dcoutts> palomer, that's ok. You can either use a label with several lines and use markup to get the colours, or use a VBox to pack in several labels or other widgets.
12:20:55 <robdockins> but only somewhat...
12:20:56 <ndm> edwinb: primitive recursion only terminates in a strict language
12:20:56 <jethr0> SimonRC: i tried it. but to print to stdout, i have to interleave IO with parsec and that doesn't seem possible :(
12:21:01 <dcoutts> palomer, one EventBox containing a VBox of labels should be ok.
12:21:32 <dcoutts> palomer, but you can probably just use one label with embeded '\n' chars and use pango markup for the colours.
12:21:37 <ihope> Something that terminates only in strict lanugages? How is that possible?
12:21:39 <edwinb> ndm: I said primtiive recursion on inductive types.
12:21:48 <jethr0> SimonRC: i could try it multithreaded *brr*
12:21:51 <edwinb> strictly positive, all recursion is on structurally smaller values.
12:21:57 <dcoutts> palomer, using labelSetMarkup
12:22:07 <ndm> ihope, in a strict language you have finite data structures
12:22:19 <ihope> Um.
12:22:34 <dcoutts> palomer, see the Pango text markup language: http://developer.gnome.org/doc/API/2.0/pango/PangoMarkupFormat.html
12:22:36 <palomer> dcoutts: but I want a different event for every label
12:22:48 <kevind_> ndm: not necessarily
12:22:53 <dcoutts> palomer, ah ok, then use an event box per label
12:23:13 <ndm> kevind_: in a strict language you can assume the argument you are being passed in is fully evaluated
12:23:24 <kevind_> yes, but datatypes can still be infinite
12:23:28 <ndm> so while it might not be terminating, it would be non-terminating before hand
12:23:32 <kevind_> if they are not required to be positive
12:23:34 <dcoutts> palomer, but you'll still use the pango markup for the formatting & colours.
12:23:45 <edwinb> There is an important distinction between inductive types and coinductive types.
12:23:47 <dcoutts> palomer, it's like simple html.
12:23:49 <ndm> kevind_: infinite datatypes ? please explain
12:23:54 <edwinb> coinductive => can be infinite
12:23:55 <edwinb> eg streams
12:24:06 <palomer> dcoutts: yeah, but it would be a VBox of EventBoxes of labels
12:24:15 <dcoutts> palomer, I guess so.
12:24:23 <palomer> dcoutts: oh, you already acquiesced
12:24:36 <dcoutts> yep since you need different events for each label
12:24:49 <palomer> so the label would contain this markup language
12:24:53 <dcoutts> yes
12:25:00 <dcoutts> to get the colour
12:25:08 <edwinb> read http://sblp2004.ic.uff.br/papers/turner.pdf for a nice discussion ...
12:25:08 <dcoutts> and any other formatting you want
12:25:23 <kevind_> data loopy = Loopy (loopy -> a); loop (Loopy(f)) = f(Loopy(f)); loop (Loopy loop)
12:25:32 <ihope> Whoa.
12:25:33 <kevind_> you can hide recursion in non-positive datatypes
12:26:01 <ndm> edwinb: i have a copy of that paper on my bedside table :)
12:26:05 <edwinb> everyone should :)
12:26:29 <kevind_> they are basically infinite because they can contain themselves
12:26:47 <ihope> The set of Haskell values is countably infinite, right?
12:26:59 <ndm> ihope, yes
12:27:05 <ihope> Okay.
12:27:30 <robdockins> you know, the only languages I know of that don't allow general recursion (or iteration) are dependently typed.  Anybody know a counterexample?
12:27:44 <ndm> (assuming float is countable, but that probably not worth worrying about)
12:27:46 <kevind_> simply typed lambda calculus
12:27:48 <kevind_> :)
12:27:57 <robdockins> *d'oh*
12:28:06 <palomer> hihi, the basics work
12:28:09 <edwinb> SQL :)
12:28:14 <palomer> dcoutts: thx!
12:28:17 <ihope> ndm: that's actually finite, isn't it?
12:28:34 <palomer> dcoutts: last thing, what's the best way to get the size of a widget?
12:28:35 <ihope> Stored in a set number of bits?
12:28:36 <dcoutts> palomer, you're welcome.
12:28:55 <ndm> floats? as far as real numbers go, they are uncountably infinite - as far as haskell i guess they are countably finite
12:29:02 <palomer> dcoutts: widgetGetSizeRequest doesn't seem to be what I want
12:29:10 <robdockins> so my imagined definition of "language" wasn't so good
12:29:11 <dcoutts> palomer, yeah
12:29:11 <palomer> @hoogle round
12:29:12 <lambdabot> Prelude.round :: (RealFrac a, Integral b) => a -> b
12:29:12 <lambdabot> Text.Html.background :: String -> HtmlAttr
12:29:13 <ndm> if you use Ratio then I guess you might get back to countably infinite
12:29:15 <ihope> Is there anything that's uncountably finite? ;-)
12:29:25 <ndm> ihope - no
12:29:44 <palomer> dcoutts: yeah it doesn't seem to be what I want?
12:29:58 <ndm> assume its finite - that means you can enumerate the elements, and that there are n - hence assign 1 to n to each element - and its now countable
12:30:01 <dcoutts> palomer, it's probably not what you want.
12:30:16 <dcoutts> palomer, it may be that what you want was only added two days ago. :-)
12:31:18 <palomer> dcoutts: oh, and it seems that the darcs gtk2hs is missing ./configure
12:31:20 <robdockins> ihope: what exactily do you mean by "haskell value"?
12:31:28 <dcoutts> palomer, use autoreconf
12:32:24 <palomer> configure.ac: required file `./mkinstalldirs' not found
12:32:48 <robdockins> does piDigits :: [Bool] count?
12:33:11 <palomer> dcoutts: never mind
12:33:21 <palomer> autereconf/autoconf works
12:33:22 <ihope> robdockins: yes
12:33:34 <robdockins> then haskell values are not countable
12:33:39 <palomer> dcoutts: actually, it doesn't :/
12:33:47 <ihope> Eh?
12:33:51 <ndm> robdockins: they are still countable
12:34:04 <robdockins> there are denumerably many infinite streams of binary digits
12:34:23 <robdockins> if a stream of the digits of pi counts, then we admit infinite streams of binary digits
12:34:31 <dcoutts> palomer, http://developer.gnome.org/doc/API/2.0/gtk/GtkContainer.html#size-allocation
12:34:33 <ihope> But the number of functions is countable, isn't it?
12:34:56 <glasser> robdockins: by "denumerably" many do you mean countable?
12:35:03 <dcoutts> palomer, are you on debian? what version of autoreconf have you got?
12:35:11 <robdockins> no -- denumerable == uncountable
12:35:26 <robdockins> (unless my head is screwed on wrong)
12:35:28 <palomer> autoreconf (GNU Autoconf) 2.59
12:35:32 <ihope> Well, the number of Haskell programs is countable, as the number of possible source files is countable.
12:35:42 <palomer> dcoutts: it also complains that I have version 1.79 of automake, and not 1.8
12:35:44 <ihope> Since every value must be definable this way...
12:35:46 <robdockins> er, that's a good point
12:35:56 <palomer> dcoutts: but when I try to apt, it tries to give me 1.4
12:36:04 <ndm> robdockins: and i would have said infinite streams of binary values were countable
12:36:22 <glasser> no, I think denumerable usually means countably infinite
12:36:32 <robdockins> nope -- infinite binary streams are bijective with the reals
12:36:38 <glasser> but there are uncountably many infinite streams of binary values
12:36:43 <robdockins> glasser: OK
12:36:57 <dcoutts> palomer, yeah, debian has alistly broken versioning of the autotools. Despite our Makefile.am requesting a particular version, debian's version of autoreconf uses an old version.
12:37:03 <cinema> dcoutts, 1) you forgot to add the compilation of Clocks.hs in the Makefile of Cairo demo
12:37:08 <glasser> since the number of haskell programs is countable, there are streams of binary values that can't be created by a haskell program, is all.
12:37:16 <cinema> dcoutts, 2) How do I stop it now ?
12:37:24 <dcoutts> cinema, press escape
12:37:37 <cinema> dcoutts, thanks !
12:37:37 <palomer> dcoutts: so can anything be done?
12:37:38 <dcoutts> palomer, you will need to install automake 1.8 or 1.9
12:37:41 <robdockins> glasser, check -- got to learn to think before I speak ;)
12:37:48 <glasser> 'sall good
12:37:55 <dcoutts> palomer, and then invoke that version specifically, rather than using autoreconf
12:38:12 <palomer> dcoutts: but that won't fix the configure.ac: required file `./mkinstalldirs' not found problem
12:38:28 <dcoutts> palomer, try autoreconf -i
12:38:50 <dcoutts> palomer, or that should go away if you use the right automake/autoconf versions
12:39:01 <palomer> ok
12:39:10 <palomer> so I'll have to run autoreconf, have it fail, then automake
12:39:58 <dcoutts> palomer, probably yes, and use automake-1.9 to select the specific version
12:40:09 <dcoutts> otherwise it'll use 1.4 which doens't work
12:40:16 <zacch> hi, I've got a question regarding memoization / dynamic programming. how do I make for instance the naive "minimal edit distance" program make implicitly use of memoization in Haskell?
12:40:25 <dcoutts> palomer, that's the bit that is a debian-specific bug
12:41:09 <palomer> dcoutts: have you guys considered inserting a ./debian-configure file?
12:41:13 <dcoutts> palomer, that it invokes the wrong version rather than complaining that the right version is not available as it does on all other platforms.
12:41:25 <dcoutts> palomer, you mean to work around the debian bug?
12:41:27 <robdockins> humm, what if i do 'hGetContents infiniteSourceOfEntropy'?
12:41:31 <palomer> dcoutts: yeah
12:41:47 <palomer> dcoutts: are you running debian? (you could just pass me your ./configure)
12:41:58 <dcoutts> palomer, if you can find something that works then send it in. I don't use debian so I couldn't test it.
12:42:03 <robdockins> wouldn't that admit each of the possible infinite binary streams?
12:42:15 <palomer> ah, gotcha
12:42:31 <dcoutts> palomer, I only vaugely know about this problem because it bits all the debian folk who build gtk2hs
12:43:47 <palomer> www.magnesium.net/~palomer/configure
12:43:57 <palomer> 1 sec
12:43:57 <vincenz>   checkRead :: (Show a, Read a, Eq a) => a -> Bool
12:43:57 <vincenz>   checkRead x = either (const False) (x ==) $  (read (show x) :: a)
12:44:02 <vincenz> this is giving me typing issues
12:44:16 <palomer> there
12:44:26 <edwinb> what is the error?
12:44:28 <vincenz> cause the read does not know it should return the same type as x
12:44:33 <palomer> dcoutts: so what's the new function that just got added?
12:45:20 <ndm> vincenz: i think the :: a in the function refers to a different a from the one in checkRead
12:45:23 <edwinb> @type either
12:45:24 <lambdabot> forall c b a. (a -> c) -> (b -> c) -> Either a b -> c
12:45:24 <dcoutts> palomer, widgetGetSize
12:45:34 <palomer> dcoutts: actually, don't get that file, doesn't work
12:45:45 <vincenz> ndm: yeah, so how would I fix this?
12:45:45 <edwinb> vincenz: a is not either... that can't help...
12:46:05 <vincenz> ndm: I need to restrain the return type of read to the same type as x
12:46:18 <ndm> @type read
12:46:19 <lambdabot> forall a. (Read a) => String -> a
12:46:30 <ndm> read does not return an Either, yet either will expect one
12:46:31 <dcoutts> palomer, so what automake version are you using now?
12:46:36 <ndm> so its not well typed already...
12:46:36 <palomer> 1.8
12:46:40 <vincenz> ndm: obviously
12:46:42 <palomer> if this doesn't work I'll try with 1.9
12:46:53 <ndm> vincenz: so what are you trying to acheive with that code?
12:46:56 <vincenz> ndm: well
12:46:59 <vincenz> try a read
12:47:00 <vincenz> if I get a parse failure
12:47:02 <vincenz> return false
12:47:04 <vincenz> that's what either does
12:47:16 <ndm> read does not return an Either
12:47:21 <ndm> it fails on a failure
12:47:21 <vincenz> ..
12:47:23 <vincenz> yes
12:47:25 <ndm> you might want reads
12:47:27 <ndm> @reads
12:47:28 <lambdabot> Unknown command, try @listcommands.
12:47:31 <vincenz> @type reads
12:47:32 <lambdabot> forall a. (Read a) => ReadS a
12:47:32 <ndm> @type reads
12:47:34 <lambdabot> forall a. (Read a) => ReadS a
12:47:39 <ndm> @type ReadS
12:47:40 <lambdabot> Not in scope: data constructor `ReadS'
12:47:52 <ndm> @hoogle ReadS
12:47:53 <lambdabot> Prelude.ReadS :: String -> [(a, String)]
12:47:53 <lambdabot> Prelude.reads :: Read a => ReadS a
12:47:53 <lambdabot> Text.ParserCombinators.ReadP.ReadS :: String -> [(a, String)]
12:48:04 <palomer> there, the newest one should work
12:48:26 <vincenz> @hoogle try
12:48:27 <lambdabot> Control.Exception.try :: IO a -> IO (Either Exception a)
12:48:27 <lambdabot> System.IO.Error.try :: IO a -> IO (Either IOError a)
12:48:27 <lambdabot> Text.ParserCombinators.Parsec.Prim.try :: GenParser tok st a -> GenParser
12:48:27 <lambdabot> tok st a
12:48:29 <ndm> case reads x of {[(a,"")] -> True; _ -> False}
12:48:49 <ndm> that sound return True if x parses, False if it doesn't
12:51:27 <ndm> vincenz:
12:51:29 <ndm> checkRead x = case f x (read (show x))
12:51:31 <ndm> 		[(a,"")] -> True
12:51:32 <ndm> 		_ -> False
12:51:33 <ndm> 	where
12:51:35 <ndm> 		f :: a -> a -> a
12:51:36 <ndm> 		f a b = b
12:52:43 <ndm> replace True with (a == x), and then you won't need the type converting f either
12:53:23 <dcoutts> palomer, result? 1.9 works or not?
12:55:19 <phas> Someone knows how to create a service for windows in haskell?
12:56:30 <palomer> dcoutts: so far so good
12:56:34 <palomer> dcoutts: 1.8
12:56:53 <palomer> dcoutts: is there a difference between labelSetLabel and labelSetMarku, here are the docs
12:57:01 <palomer> Sets the text of the label. The label is interpreted as including embedded underlines and/or Pango markup depending on the markup and underline properties.
12:57:11 <palomer> Parses str which is marked up with the Pango text markup language, setting the label's text and attribute list based on the parse results. If the str is external data, you may need to escape it.
12:57:21 <palomer> first one is for labelSetLabel, second is for labelSetMarkup
12:58:26 <nuffer> so if I have a handle
12:58:32 <nuffer> which is a network connection handle
12:58:35 <dcoutts> palomer, right, so one uses simple text and the other uses pango markup
12:58:45 <nuffer> can one thread be reading from it, and another thread writing to it simultaneously?
12:59:04 <palomer> dcoutts: The label is interpreted as including embedded underlines and/or Pango markup
13:00:03 * araujo hopes this works
13:01:23 <dcoutts> palomer, so there is labelSetText and labelSetMarkup which do the obvious things
13:01:56 <dcoutts> palomer, then labelSetLabel behaves as on or the other depending on the labelUseMarkup attribute
13:02:25 <dcoutts> (and the labelUseUnderline attribute)
13:02:26 <palomer> dcoutts: it seems textBufferNew has changed
13:02:48 <palomer> dcoutts: oh, the properties of the label, gotcha
13:03:54 <palomer> http://www.rafb.net/paste/results/isFHUJ31.html
13:04:11 <dcoutts> palomer, oh yeah, that's a bit anoying. It was generalised to work with any TextTagTableClass instance rather than just a TextTagTable
13:04:29 <dcoutts> palomer, since there is also this SourceView subclass of TextView
13:04:50 <palomer> oh, are you guys going to change it back?
13:04:59 <dcoutts> palomer, but actually thinking about it the generalisation is wrong so I'll change it back. Especially since it causes that type ambiguity you noticed.
13:05:25 <palomer> so how do I annotate to fix this?
13:05:55 <dcoutts> textbuffer <- textBufferNew (Nothing :: Maybe TextTagTable)
13:06:01 <palomer> oh, righto, forgot to save
13:09:47 <nuffer> if I have a handle to a network connection, can one thread be reading from it, and another thread writing to it simultaneously?
13:10:38 <basti_> nuffer: you have to duplicate it, then you can
13:10:44 <nuffer> duplicate?
13:10:55 <basti_> that is, it depends on if you use haskell threads or OS threads, i think
13:11:02 <nuffer> haskell threads, I believe
13:11:05 <nuffer> I'm just using forkIO
13:11:27 <basti_> yes thats haskell threads. It should be possible to use the same handle twice then
13:11:51 <basti_> well, at two places at the same time
13:12:22 <nuffer> cool
13:13:02 <palomer> dcoutts: works like a charm
13:13:07 <basti_> it scares me somehow, but it should be possible
13:14:10 <dcoutts> palomer, I've changed the type back so if you like you can darcs pull to get the change
13:14:25 <palomer> dcoutts: http://www.rafb.net/paste/results/7o2JBb48.html    <--here's the code (this is probably closer to what you need for hIDE)
13:14:28 * jethr0 's going crazy with this parsec issue
13:16:34 <dcoutts> palomer, heh, nice! I just ran it.
13:17:19 <dcoutts> palomer, that code is not too long or complex in the end I guess
13:17:32 <palomer> yeah, it's great
13:18:42 <dcoutts> palomer, another possability might be to display the box relative to the text rather than the mouse
13:18:50 <palomer> the only bummer is that it dissapears under the titlebar
13:19:11 <palomer> dcoutts: yeah, that's what I'm about to do, but I thought you'd like to see the tooltip version
13:19:20 <dcoutts> palomer, yes thanks
13:19:41 <dcoutts> palomer, that's because it's a child window rather than a top level tooltip/popup window
13:19:52 <dcoutts> that's why tooltips use top level windows
13:19:59 <dcoutts> so they float above other windows
13:20:09 <palomer> hrmph
13:20:14 <palomer> this means I have to switch to toplevel
13:20:21 <dcoutts> palomer, you might be able to do the same thing with a top level window
13:20:29 <dcoutts> bt you'll have an extra coordinate cnversion step
13:20:32 <palomer> oh well, the only added complexity is the coordinate conversion
13:20:38 <dcoutts> to get global screen coords
13:20:43 <dcoutts> yes, right
13:21:21 <dcoutts> windowGetPosition
13:22:23 <palomer> but how do you move a window?
13:22:48 * SimonRC goes
13:22:52 <dcoutts> http://haskell.org/gtk2hs/docs/current/Graphics-UI-Gtk-Windows-Window.html#v%3AwindowMove
13:22:59 <palomer> ah, so there are no automatic functions for converting between window coordinates and world coordinates?
13:23:03 <palomer> (they would be quite useful)
13:23:26 <palomer> make that widget coordinates
13:23:37 <palomer> (like a generic function)
13:24:08 <dcoutts> palomer, there might be, i'd have to check.
13:24:19 <dcoutts> palomer, you do get global coords in an event
13:24:28 <dcoutts> eventRootX, eventRootY
13:25:36 <dcoutts> palomer, I'd look and see how the built-in gtk tooltips do it.
13:26:01 <dcoutts> palomer, btw you can't use the built-in tooltips for this purpose since they are not sufficiently flexible
13:26:32 <palomer> events seem to give me local coords
13:26:36 <palomer> oh, eventRoot
13:28:29 <dcoutts> palomer, hmm the gtk/gtktooltip.c uses some slightly complex code for the positioning
13:28:48 <dcoutts> palomer, mind you it's dealing with a general case involving multiple screens etc
13:29:05 <palomer> dcoutts: what's the simplest window one can hope for? no titlebar or anything
13:29:06 <dcoutts> and making sure the tooltip doesn't go off the edge of a screen
13:29:19 <dcoutts> palomer, yes use a window and set it as a popup
13:29:46 <dcoutts> set win [ windowType := WindowPopup ]
13:30:54 <dcoutts> palomer, it looks like what we want is gdk_window_get_origin
13:31:05 <palomer> (a.out:6282): GLib-GObject-WARNING **: IA__g_object_set_property: construct property "type" for object `GtkWindow' can't be set after construction
13:31:16 <dcoutts> palomer, ah, bugger
13:31:22 <dcoutts> palomer, we need a different constructor
13:31:31 <dcoutts> palomer, windowNewPopop
13:31:36 <palomer> dcoutts: actually, given eventXRoot and eventX, I don't see why we would need anything else
13:31:59 <dcoutts> I don't understand
13:32:26 <palomer> dcoutts: eventXRoot gives us world coordinates, that's all we need, really
13:32:53 <palomer> windowNewPopup doesn't exist
13:32:58 <phas> dcoutts, xerox says to ask to you, i've to install and use gtk2hs on a windows pc for testing
13:32:59 <dcoutts> I know :-)
13:33:19 <dcoutts> palomer, I can add it in 2 min if you need it
13:33:20 <phas> dcoutts, i installed GTK+, then GHC and then GTK2hs
13:33:51 <phas> dcoutts, but when i try to compile something GHC says that he can't find gtk2hs
13:34:08 <dcoutts> palomer, but even though you have world coords that doesn't mean you get the box on top, unless you're using a popup window.
13:34:11 <palomer> dcoutts: sure
13:34:36 <dcoutts> palomer, if it's a child window of the textview then it's always inside the textview's window
13:34:41 <palomer> dcoutts: get the box on top? I just draw to world coordinates
13:35:05 <dcoutts> palomer, you just draw what to world corrdinates?
13:35:25 <palomer> windowMove tipWindow eventXRoot eventYRoot 
13:35:35 <palomer> (pseudocode)
13:35:39 <dcoutts> and tipWindow is of what type?
13:35:45 <palomer> window
13:36:03 <palomer> (I constructed it with windowNew)
13:36:04 <dcoutts> ok, then you need windowNewPopup
13:36:22 <dcoutts> othersie it gets a window border etc
13:36:33 <dcoutts> phas, I'll get back to you shortly
13:36:49 <phas> dcoutts, thank you very much
13:36:51 <dcoutts> phas, and check what ghc-pkg list says
13:37:42 <vincenz> @type either
13:37:43 <lambdabot> forall c b a. (a -> c) -> (b -> c) -> Either a b -> c
13:38:17 <palomer> dcoutts: don't forget to add my configure script
13:38:33 <palomer> (unless, of course, you don't want to)
13:38:40 <dcoutts> palomer, what was your config script?
13:38:50 <dcoutts> just what you generated with autoreconf?
13:39:04 <palomer> yeah
13:40:06 <dcoutts> that shouldn't go in the source control system since it's generated
13:40:32 <palomer> dcoutts: but it's broken for debian
13:40:49 <palomer> dcoutts: or mention the steps to take if you're using debian in the INSTALL
13:41:12 <phas> dcoutts, what package i have to search with gtk-pkg list?
13:41:28 <dcoutts> palomer, so what do we think the steps are exactly?
13:42:04 <dcoutts> phas, glib & gtk
13:42:06 <palomer> autoreconf && automake-1.8 is what worked for me
13:42:46 <phas> dcoutts, gtk doesn't figure out
13:43:01 <phas> dcoutts, neither glib
13:43:10 <dcoutts> palomer, several projects use an autoconf.sh script that does various fixes
13:43:19 <dcoutts> palomer, I guess we could steal on of those
13:43:26 <dcoutts> from another project
13:44:19 <dcoutts> phas, you're on win32 right?
13:45:15 <vincenz> @type exit
13:45:16 <lambdabot> Not in scope: `exit'
13:45:19 <vincenz> @type quit
13:45:20 <lambdabot> Not in scope: `quit'
13:45:35 <palomer> @hoogle assert
13:45:36 <lambdabot> Control.Exception.assert :: Bool -> a -> a
13:45:36 <lambdabot> Test.HUnit.Base.assert :: Assertable t => t -> Assertion
13:45:36 <lambdabot> Control.Exception.AssertionFailed :: String -> Exception
13:45:41 <palomer> @hoogle abort
13:45:42 <lambdabot> Foreign.C.Error.eCONNABORTED :: Errno
13:45:42 <lambdabot> Test.QuickCheck.Batch.TestAborted :: Exception -> TestResult
13:47:20 <palomer> I'm I'm constantly highlighting different pieces of text, but only highlighting one at a time, is a tag really the best way?
13:47:50 <dcoutts> phas, so you ran the gtk2hs-0.9.10.exe installer and it says everything worked right?
13:48:00 <phas> well
13:48:15 <phas> dcoutts, i didn't ran personally, but i assume yes
13:48:21 <phas> dcoutts, i can redo it
13:48:37 <dcoutts> ok try this:
13:48:45 <dcoutts> gtk2hs-0.9.10.exe /LOG="gtk2hs.log"
13:48:54 <dcoutts> from a command line box
13:49:09 <dcoutts> ie not from the file browser
13:49:56 <phas> dcoutts, ARGH windows from command line -> pain in the ass
13:50:40 <dcoutts> phas, sorry but it'll be really useful to get a log file of the installation
13:50:48 <dcoutts> so we can see in detail what is going wrong
13:51:39 <phas> dcoutts, yeah, of course, i'm doing it
13:52:06 <dcoutts> phas, and then if possible can you post the log file somewhere or if not email it to me
13:54:21 <dcoutts> palomer, darcs pull to get the windowNewPopup I've added
13:54:40 <phas> dcoutts, i will upload it somewhere
13:56:57 <phas> dcoutts, uhm ftp problems, can you give me your email?
13:57:15 <xerox> phas: paste it on lisppaste
13:57:16 <xerox> lisppaste2: url
13:57:16 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
13:57:44 <dcoutts> xerox, it's quite a large file but that might work
13:58:00 <xerox> phas: scp it to me :-)
13:58:07 <dcoutts> phas, it;s worth a go I guess, the paste thing
13:59:37 <phas> dcoutts, done
14:00:03 <dcoutts> phas, which?
14:00:14 <phas> dcoutts, nothing, it was to large :P
14:00:22 <phas> dcoutts, wait a min
14:01:59 <jethr0> xerox: you worked with parsec?
14:02:34 <phas> dcoutts, i sent the log by email
14:02:57 <araujo> dcoutts!
14:03:29 <araujo> dcoutts, is it possible to get a returned value after pressing a button?
14:03:39 <dcoutts> phas, got it
14:03:45 <xerox> jethr0: yeah
14:03:45 <dcoutts> araujo, what do you mean?
14:04:02 <dcoutts> phas, go to a command line and type: ghc --version
14:04:05 <jethr0> i was trying to interleave parsing on stdin with writing output on stdout.
14:04:08 <dcoutts> phas, what do you get?
14:04:12 <jethr0> have you ever tried sth like that?
14:04:23 <xerox> jethr0: nope, hmmm.
14:04:34 <jethr0> i couldn't get it to work
14:04:41 <xerox> jethr0: interleaveParsecIO... mumble.
14:04:50 <jethr0> mixing parsec and IO didn't work.
14:04:57 <jethr0> does that exist?
14:05:06 <phas> dcoutts, is 6.4.1
14:05:08 <xerox> jethr0: nope, but I think one can define something like that.
14:05:15 <araujo> dcoutts, i am looking for something like `onClicked` but that returns a value.
14:05:20 <phas> dcoutts, i've just installed it
14:05:21 <jethr0> xerox: i tried :(
14:05:37 <dcoutts> phas, well from the log it looks like it worked perfectly
14:05:43 <dcoutts> phas, is it still not working?
14:05:51 <jethr0> only solution i came up with was multithreading, but that's an evil solution to a basically linear problem
14:06:01 <dcoutts> phas, what does "ghc-pkg.exe list gtk" say?
14:06:38 <dcoutts> araujo, I've no idea what you mean about onClicked returning a value
14:06:59 <vincenz> @type getContents
14:07:00 <lambdabot> IO String
14:07:09 <Cale> hi
14:07:13 <vincenz> hiya
14:07:17 <jethr0> hi cale
14:07:35 <jethr0> Cale: i'm sure you (the guru) can illuminate a parsec problem of mine :)
14:07:49 <Cale> sure
14:07:51 <phas> dcoutts, nothing
14:07:55 <Cale> I can have a look :)
14:08:04 <araujo> dcoutts, well.. what im actually looking for, is a way for the user to press a button, and that it returns a value, which will be processed by other functions.
14:08:06 <xerox> jethr0: I think you can do something like do { res <- lift $ doParsing; print res; res2 <- lift $ doParsing; print res2 } ...
14:08:13 <jethr0> Cale: i'm trying to interleave parsec reading on stdin with printint on stdout
14:08:28 <jethr0> Cale: like a communications protocol where i react to messages on stdin
14:08:29 <dcoutts> araujo, so you can do the processing in the button clicked event handler
14:08:42 <vincenz> Cale: question:  if I'm using getContents
14:08:43 <dcoutts> araujo, or call the functions which do the processing
14:08:47 <vincenz> do I still need a StateT
14:08:56 <vincenz> or can I just keep that String "stdin" in a State monad?
14:09:01 <Cale> jethr0: this can be awkward, and is one of the reasons that I wish Parsec was a monad transformer
14:09:02 <xerox> vincenz: getContents needs IO, if that's the quesiton
14:09:03 <araujo> dcoutts, Ok.
14:09:14 <jethr0> Cale: so you've run into that problem too.
14:09:22 <dcoutts> phas, ok, try: ghc.exe --print-libdir
14:09:25 <vincenz> Cale: actually we're not using parsec but Read
14:09:29 <Cale> vincenz: what are you using the state monad for?
14:09:31 <vincenz> all our types can read
14:09:34 <jethr0> cale: any good solutions? one solution would be threading, but it's not a nice one :(
14:09:43 <Cale> Well, what's your language?
14:09:51 <vincenz> Cale: basically......
14:10:01 <vincenz> Cale: we read the current exppected message from stdin
14:10:03 <phas> dcoutts, c:/ghc/ghc-6.4.1
14:10:04 <vincenz> with reads
14:10:05 <Cale> Can you break it into chunks which need to be replied to?
14:10:09 <vincenz> and then put the remaining string into a Sate
14:12:40 <Cale> If you're using reads, you should always be able to get the remainder of stdin
14:12:51 <Cale> so it shouldn't be a problem there
14:12:55 <dcoutts> phas, are you getting my priv messages?
14:13:00 <vincenz> jethr0: ok then I got it
14:13:06 <jethr0> hehe
14:13:15 <jethr0> cale: any good solutions? one solution would be threading, but it's not a nice one :(
14:14:33 <Cale> what's your language like? Is there a lot of context involved in parsing such that you want to be able to do IO but not lose your place?
14:14:42 <araujo> dcoutts, ok... also.. don't you know if there exist a function similar to `treeSelectionGetSelectedRows` , but that returns the contents of the row instead of the number of row.
14:14:56 <Cale> Parsec doesn't appear to provide a way to get the remainder of the input back 
14:15:05 <Cale> though other parser combinator libraries do
14:15:14 <musasabi> Cale: it offers that I think.
14:15:16 <jethr0> Cale: it's basically the 2005 icfp problem (robbers, ...)
14:15:35 <jethr0> and i communicate over stdin/stdout. when ever i get sth on stdin i want to respond on stdout and vice versa
14:15:38 <Cale> musasabi: what's the function you use?
14:15:44 <vincenz> jethr0: I have an idea!
14:15:48 <musasabi> Cale: getInput
14:16:06 <jethr0> cale: so, either i do it lazily (getContents, parse the whole thing and interleave parsec with IO)
14:16:29 <Cale> ah, okay
14:16:30 <jethr0> Cale: or i get some state out of parsec about how much it has consumed to be able to continue there later
14:16:42 <jethr0> vincenz: do tell
14:16:50 <vincenz> jethr0: nearly there
14:16:54 <Cale> yeah, then you can return getInput's result, tupled with your usual result
14:17:07 <vincenz> Cale: that's why I'm using a StateT
14:17:09 <musasabi> Cale: yes that is what I use.
14:17:15 <Cale> getInput returns the unconsumed portion of the input
14:17:16 <vincenz> where in the state I keep the current remainning input
14:17:23 <musasabi> crlf    = between (char '\r') (char '\n') getInput
14:17:30 <musasabi> message = newMsg prefix command params crlf
14:17:32 <musasabi> etc
14:17:40 <jethr0> ah, interesting
14:18:22 <robdockins> does anyone know of a good library for doing arbitrarily-fixed precision arithmetic?  Like say I want to do calculations with 6 bit binary numbers.
14:18:24 <jethr0> @hoogle getInput
14:18:25 <lambdabot> Text.ParserCombinators.Parsec.Prim.getInput :: GenParser tok st [tok]
14:19:15 <dcoutts> araujo, use the TreeSelection object
14:19:25 <dcoutts> araujo, oh, wait, you are.
14:19:49 <jethr0> Cale: how would i use that?
14:20:22 <dcoutts> araujo, so you'd use treeSelectionGetSelectedRows and then use treeModelGetValue to get the value in each row.
14:20:25 <vincenz> Cale: I'm an IO monad, and I want to go to a AIStateT IO monad... how do I do that
14:20:30 <vincenz> @hoogle liftM
14:20:31 <lambdabot> Control.Monad.liftM :: Monad m => (a1 -> r) -> m a1 -> m r
14:20:31 <lambdabot> Control.Monad.liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m
14:20:31 <lambdabot> r
14:20:31 <lambdabot> Control.Monad.liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -
14:20:31 <lambdabot> > m a3 -> m r
14:20:49 <palomer> dcoutts: thx
14:20:51 <Cale> Prelude Text.ParserCombinators.Parsec> parseTest (do u <- char 'a'; x <- getInput; return (u,x)) "ahello"
14:20:51 <Cale> ('a',"hello")
14:20:55 <jethr0> musasabi: got any simple example code for that (getInput)?
14:20:58 <araujo> dcoutts, haha, yeah, just found it!!!
14:21:10 <jethr0> *nice*
14:21:12 <musasabi> jethr0: http://www.cs.helsinki.fi/u/ekarttun/hs-fltk/hs-fltk/example/hirc_fltk.hs
14:21:17 <jethr0> thx a lot
14:21:24 <dcoutts> araujo, and treeModelGetIter. This stuff is rather complex which is why we're working on a new improved treeview api that uses native haskell types and doesn't use so many treeiters.
14:21:28 <Cale> so you do your normal parser, then you do a getInput to read the rest of the string at the end
14:21:28 <araujo> dcoutts, i hate myself... all day looking for it, and i found it a few minutes after i asked you :-]
14:21:41 <dcoutts> araujo, heh :-) that api is rather complex
14:21:44 <vincenz> Cale: main :: IO () = do .... (calls a function of type StateT .. IO)
14:21:46 <vincenz> how do I do this?
14:21:49 <araujo> dcoutts, yeah, kind of messy indeed.
14:21:50 <dcoutts> araujo, did you read the treeview overview?
14:22:05 <araujo> dcoutts, yes, but... ive read so many trees by now :-P
14:22:09 <dcoutts> araujo, it's quite fleible which makes the api large and confusing
14:22:29 <dcoutts> araujo, http://developer.gnome.org/doc/API/2.0/gtk/TreeWidget.html
14:22:37 <araujo> Let's see....
14:22:42 <Cale> vincenz: You have to use runStateT, evalStateT, or execStateT along on your (StateT s IO a) along with an initial state
14:22:49 <dcoutts> phas, ping
14:22:55 <Cale> @type Control.Monad.State.runStateT
14:22:55 <lambdabot> forall s a (m :: * -> *).
14:22:55 <lambdabot> Control.Monad.State.StateT s m a -> s -> m (a, s)
14:22:59 <dcoutts> palomer, so is that working now?
14:23:09 <Cale> so if  m = IO
14:23:22 <vincenz> Cale: yeah
14:23:29 <araujo> dcoutts, how many people develop gtk2hs?
14:23:53 <wolverian> dcoutts, the perl gtk2 bindings at least have a simpletree class - not sure if it's actually backed up by a C implementation or if it just wraps the annoying MVC away in perl.
14:23:59 <palomer> dcoutts: yeah, works great
14:24:04 <palomer> dcoutts: but it's not nearly as smooth
14:24:05 <dcoutts> araujo, 2 core developers and gour helps with our website 
14:24:12 * araujo has liked gtk2hs pretty much actually
14:24:26 <araujo> Cool.
14:24:31 <palomer> dcoutts: oh, that's my fault
14:24:36 <dcoutts> palomer, that's interesting, that it's not smooth
14:24:44 <dcoutts> palomer, oh really? what was wrong?
14:24:56 <palomer> dcoutts: I'm dragging my mouse over the popup window
14:25:00 <palomer> we discussed this earlier
14:25:05 <dcoutts> palomer, ah yes
14:25:06 <palomer> what was our proposed solution?
14:28:13 <vincenz> Cale: how do I get the state inside a function of type
14:28:19 <vincenz> StateT s m a
14:28:30 <palomer> hrm, looks like I'll have to put on onMotion on the popupWindow, then convert the world coordinates back to textview coordinates
14:28:47 <palomer> s/world/screen
14:29:28 <Philippa_> vincenz: runStateT?
14:29:38 <Philippa_> (which'll give you an m (s,a) or something similar, IIRC)
14:30:18 <palomer> dcoutts: unless there's a way for me to tell gtk to simply ignore the popupWindow
14:30:20 <Cale> vincenz: get
14:30:27 <vincenz>     No instance for (MonadState String IO)
14:30:27 <vincenz>       arising from use of `get' at Robber.hs:40:9-11
14:30:44 <Cale> vincenz: then you're not in StateT
14:31:09 <vincenz> ah got it :)
14:31:25 <palomer> are there channel logs lurking anywhere?
14:31:40 <Cale> palomer: see the topic
14:32:13 <dcoutts> palomer, the solution with most tooltips is to have them dissapear when the mouse moves over them but yeah, you could just make it move again.
14:32:51 <dcoutts> palomer, of course you don't need to convert local window to screen coords since the mouse move on the popup window gives you screen coords (as well as local corrds)
14:33:31 <vincenz> WOO!
14:33:44 <palomer> dcoutts: the problem with making them dissapear is that they could dissapear and not update, right?
14:33:48 <dcoutts> wolverian, we're making a new haskely api for the text view stuff so that even comlex tree views shouldn't be too hard to setup.
14:34:19 <dcoutts> palomer, yeah, you probably want the solution you suggested of having them just move out of the way
14:34:25 <wolverian> dcoutts, nice. it's important to have something simple yet be able to fall back to the complex interface if you need it :) or are you planning to expose the mvc interface but make it easy to use?
14:34:50 <dcoutts> wolverian, we're planning to make the mvc interface easy to use
14:34:51 <palomer> dcoutts: so how does one convert to textview coordinates?
14:34:58 <wolverian> dcoutts, ah. that'll be interesting
14:35:17 <dcoutts> palomer, oh, I thought you only needed global coords
14:35:24 <wolverian> dcoutts, maybe I can steal ideas to port over to perl :) (most likely not, though, unless I wait for perl6) 
14:35:38 <dcoutts> palomer, I guess you need the text underneath if there is any
14:35:40 <palomer> dcoutts: oh no, I also need local coords, which were happily supplied by th events
14:35:46 <palomer> dcoutts: exactly
14:36:07 <dcoutts> palomer, you'll can get an iter in global coords I think
14:36:17 <TuringTest> @pl \x -> x * x
14:36:18 <lambdabot> join (*)
14:36:39 <dcoutts> wolverian, for starters we're making it possible to implement models in Haskell
14:36:43 <vincenz> Cale: how do I print inside a an StateT s IO a
14:37:03 <palomer> dcoutts: yes, but if I'm moving on the popup, then I'll only have popup coords
14:37:22 <dcoutts> wolverian, so the model side of the API will use hskell types, in fact the model will be parameterised by the row type (which can be any haskell type)
14:37:37 <dcoutts> palomer, no the move event gives local & global coords
14:37:41 <wolverian> dcoutts, right. sounds good
14:38:18 <palomer> dcoutts: right, so in my implementation, when I move over the popup window, I'll convert to global coords, then convert back to textview coords
14:38:41 <dcoutts> palomer, sounds right
14:38:43 <Cale> vincenz: liftIO $ print foo
14:38:50 <Cale> bbiab, dinner
14:38:51 <vincenz> thx
14:39:18 <vincenz> @hoogle liftIO
14:39:19 <lambdabot> Control.Monad.Trans.liftIO :: MonadIO m => IO a -> m a
14:39:19 <lambdabot> Graphics.UI.ObjectIO.StdIOBasic.liftIO :: IOMonad m => IO a -> m a
14:39:19 <palomer> dcoutts: so how do I convert back to textview coordinates?
14:41:23 <palomer> a cheap fix is to record the local coords of the tooltip window everytime I move it
14:44:47 <vincenz> @hoogle while
14:44:47 <lambdabot> Data.List.takeWhile :: (a -> Bool) -> [a] -> [a]
14:44:47 <lambdabot> Data.List.dropWhile :: (a -> Bool) -> [a] -> [a]
14:44:47 <lambdabot> Prelude.takeWhile :: (a -> Bool) -> [a] -> [a]
14:45:36 <palomer> there's something...mysterious about bringing computation into the realm of value
14:47:07 * vincenz has something that infinitely recurses
14:47:55 <vincenz> I expected, read, write, read, write
14:47:58 <vincenz> but apparently it does
14:48:00 <vincenz> read, write, write, write
14:48:35 <dcoutts> palomer, this FAQ suggests some stuff: http://gtk.org/faq/#AEN643
14:48:55 <dcoutts> palomer, to do it conventiently we might need to bind an extra function or two in gtk2hs
14:52:38 <palomer> dcoutts: yeah, to find the widget origin, I need to find it's origin w.r.t. its parent, its parent's origin w.r.t. its parent, ....
14:53:05 <dcoutts> palomer, gdk_window_get_origin will give the origin in root coords
14:53:31 <palomer> of the window
14:53:41 <dcoutts> right
14:53:45 <palomer> but the widget is a child of the window
14:58:11 <dcoutts> ah, there are two kinds of windows here :-)
14:58:11 <palomer> hmm?
14:58:11 <dcoutts> palomer, there is GdkWindow whcih in Gtk2Hs we call DrawWindow and there is GtkWindow which we call Window
14:58:11 <palomer> oh, windowGetOrigin gives the coordinates with decorations
14:58:11 <palomer> yeah, windowGetOrigin is for the GdkWindow
14:58:11 <dcoutts> palomer, so gdk_window_get_origin should do what you want
14:58:11 <dcoutts> when applied to the text DrawWindow of the text view widget
14:58:11 <palomer> dcoutts: but I need it for the textview widget!
14:58:11 <palomer> ahh, I see
14:58:11 <palomer> which DrawWindow?
14:58:11 <dcoutts> yeah you're probably right, it wants to be relative to the main DrawWindow of the text view, not the one for the text area within the widget
14:58:11 <dcoutts> so use widgetGetDrawWindow on the text view widget
14:58:11 <dcoutts> and then drawWindowGetOrigin (which is not bound yet)
14:58:11 <dcoutts> palomer, does that make sense? do you think that would do the right thing?
14:58:11 <palomer> possibly
14:58:11 <palomer> so event coordinates are relative drawWindows?
14:58:11 <dcoutts> palomer, that should allow you to convert global coords to widget coords
14:58:18 <palomer> s/relative/relative to
14:58:29 <dcoutts> yeah
14:58:37 <palomer> oh, then it works perfectly
14:58:47 <dcoutts> most widgets have a DrawWindow, textviews certainly do
14:59:22 <dcoutts> unless there is a function I've missed that's spcially for onverting global cords to windget coords
14:59:40 <dcoutts> hah
14:59:42 <dcoutts> gtk_widget_translate_coordinates
14:59:46 <palomer> did you mean widgetGetParentWindow?
15:00:02 <palomer> pffft
15:00:07 <dcoutts> ah but that's not global, that's one widget to another
15:00:57 <palomer> one widget to another is fine
15:00:57 <palomer> since events can give me local coordinates
15:00:57 <dcoutts> but the widgets must be in the same top level window for that to work
15:00:57 <dcoutts> they must have a common parent
15:01:04 <palomer> oh, crumbs
15:01:32 <palomer> widgetGetDrawWindow doesn't exist yet either
15:02:27 <palomer> I'll have to use textViewGetWindow TextWindowWidget probably
15:02:48 <palomer> and I don't know what I'll do with the eventboxes
15:03:31 <palomer> since there doesn't seem to be any functions to get their drawWindows
15:04:00 <dcoutts> palomer, widgetGetDrawWindow would do for an event box, but yeah it was only bound recently too
15:04:09 <dcoutts> palomer, I've gotta go now really
15:04:20 <palomer> dcoutts: thx for all the help
15:04:24 <dcoutts> palomer, found that the gtktooltip code does this:
15:04:29 <dcoutts>   gdk_window_get_origin (widget->window, &x, &y);
15:04:29 <dcoutts>   if (GTK_WIDGET_NO_WINDOW (widget))
15:04:29 <dcoutts>     {
15:04:29 <dcoutts>       x += widget->allocation.x;
15:04:29 <dcoutts>       y += widget->allocation.y;
15:04:30 <dcoutts>     }
15:04:41 <dcoutts> for converting window coords to global coords
15:04:50 <dcoutts> you want to do the reverse
15:04:54 <palomer> yeah
15:05:03 <dcoutts> you probaably don't need the GTK_WIDGET_NO_WINDOW case
15:05:17 <dcoutts> since a tex view does have a draw window
15:05:47 <dcoutts> so I can bind gdk_window_get_origin tomorrow or some time if you want it
15:05:58 <palomer> so widgetGetDrawWindow and drawWindowGetOrigin will be done by tomorrow?
15:06:04 <palomer> that would be _great_
15:06:15 <dcoutts> widgetGetDrawWindow is in the dev version already
15:06:26 <palomer> oh, righto
15:06:45 <dcoutts> or you could send in a patch :-)
15:06:51 <dcoutts> see gtk/Graphics/UI/Gtk/Abstract/Widget.chs.pp
15:06:54 <palomer> I don't know any C
15:06:56 <dcoutts> and use darcs send
15:07:00 <dcoutts> you don't need any C
15:07:04 <dcoutts> it's all Haskel
15:07:14 <dcoutts> just follow the pattern of the other bindings
15:07:36 <palomer> yeah, I'll do it if I can understand the code
15:07:49 <palomer> anyways, gotta run myself!
15:07:50 <palomer> cya!
15:07:54 <dcoutts> bye
15:09:07 <dcoutts> palomer, take a look at widgetGetSizeRequest and follow the same pattern. That func has the same signature as gdk_window_get_origin
15:09:16 * dcoutts &
15:52:23 <ihope> So what's the status on this non-recursive Haskell stuff?
15:52:57 <edwinb> there is no non-recursive Haskell... that'd be odd...
15:53:54 <ihope> Well, what if the compiler didn't allow things to be recursive?
15:54:04 <ihope> Stuck all the recursion in a monad?
15:54:56 <edwinb> why restrict all recursion? a monad for general recursion/partiality might make sense though.
15:55:31 <Spark> why do functional languages always have to restrict something that is perfectly well understood? :)
15:55:51 <ihope> Heh.
15:56:06 <ihope> Non-recursive Haskell would be FUN!
15:56:26 <edwinb> in the case of recursion, it would be to be able to get actual believable proofs...
15:56:43 <edwinb> although I suspect the majority don't care so much about that.
16:20:17 <ihope> @djinn (a -> IO b) -> IO (a -> b)
16:20:17 <lambdabot> -- f cannot be realized.
16:20:23 <ihope> Brzt.
16:20:47 <ihope> ...Hey, wait a minute...
16:21:32 <TheHunter> that function would be unsafe.
16:21:37 <ihope> Would it?
16:21:51 <ihope> @djinn (a -> [b]) -> [a -> b]
16:21:52 <lambdabot> -- f cannot be realized.
16:21:58 <ihope> I see.
16:22:14 <ihope> @djinn IO (a -> b) -> a -> IO b
16:22:14 <lambdabot> -- f cannot be realized.
16:22:23 <anotherdaniel> I'm using MonadError, how do I catch an error, map it to a new type of error and rethrow it?
16:23:21 <ihope> @type \f p -> f >>= \a -> return (a p)
16:23:22 <lambdabot> forall (m :: * -> *) a t. (Monad m) => m (t -> a) -> t -> m a
16:23:48 <TheHunter> @pl\f p -> f >>= \a -> return (a p)
16:23:48 <lambdabot> (line 1, column 3):
16:23:48 <lambdabot> unexpected ">" or "-"
16:23:48 <lambdabot> expecting variable, "(", operator or end of input
16:24:02 <TheHunter> @pl  \f p -> f >>= \a -> return (a p)
16:24:02 <lambdabot> flip (fmap . flip id)
16:24:08 <ihope> Whoo.
16:24:17 <ihope> @type flip (fmap . flip id)
16:24:18 <lambdabot> forall (f :: * -> *) c a. (Functor f) => f (a -> c) -> a -> f c
16:24:28 <TheHunter> @pl  \p f -> f >>= \a -> return (a p)
16:24:28 <lambdabot> fmap . flip id
16:24:37 <ihope> Somebody tell lambdabot that Functor /= Monad.
16:24:58 <ihope> @type flip (liftM . flip id)
16:24:59 <lambdabot> Not in scope: `liftM'
16:25:07 <ihope> @type flip (Control.Monad.liftM . flip id)
16:25:07 <lambdabot> forall (m :: * -> *) c a. (Monad m) => m (a -> c) -> a -> m c
16:26:26 <TheHunter> Every monad is a functor.
16:27:37 <TheHunter> @djinn (a -> Reader r b) -> Reader r (a -> b)
16:27:37 <lambdabot> f a b c = a c b
16:27:50 <TheHunter> @djinn (a -> State s b) -> State s (a -> b)
16:27:51 <lambdabot> f a b =
16:27:51 <lambdabot>   (b,
16:27:51 <lambdabot>   \ c ->
16:27:51 <lambdabot>   case a c b of
16:27:51 <lambdabot>   (_, d) -> d)
16:28:18 <TheHunter> oh, wait, that was the direction that always works...
16:28:54 <TheHunter> no, it wasn't...
16:29:36 <TheHunter> @pl f a b = (b, \c -> snd (a c b))
16:29:36 <lambdabot> f = ap (,) . ((snd .) .) . flip
16:30:45 <anotherdaniel> Any ideas how to map error types with MonadError monads?
16:31:27 <TheHunter> Are you using Either or ErrorT?
16:31:39 <anotherdaniel> I'm using ErrorT
16:32:18 <anotherdaniel> eg f :: (MonadError Int m) => m String
16:32:19 <TheHunter> @type Control.Monad.Error.mapErrorT
16:32:20 <lambdabot> forall b (n :: * -> *) e' a (m :: * -> *) e.
16:32:20 <lambdabot> (m (Either e a) -> n (Either e' b))
16:32:20 <lambdabot> -> Control.Monad.Error.ErrorT e m a
16:32:20 <lambdabot> -> Control.Monad.Error.ErrorT e' n b
16:33:22 <TheHunter> @type \f -> Control.Monad.Error.mapErrorT (liftM $ Control.Monad.Arrow.left f)
16:33:23 <lambdabot> Couldn't find qualified module.
16:33:23 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
16:33:23 <lambdabot> \\)?
16:33:30 <TheHunter> @type \f -> Control.Monad.Error.mapErrorT (liftM $ Control.Arrow.left f)
16:33:31 <lambdabot> Not in scope: `liftM'
16:33:37 <TheHunter> @type \f -> Control.Monad.Error.mapErrorT (fmap $ Control.Arrow.left f)
16:33:38 <lambdabot> forall c (m :: * -> *) e a.
16:33:38 <lambdabot> (Functor m) =>
16:33:38 <lambdabot> (e -> c)
16:33:38 <lambdabot> -> Control.Monad.Error.ErrorT e m a
16:33:38 <lambdabot> -> Control.Monad.Error.ErrorT c m a
16:37:10 <carp> blast too late to talk about recursion
16:37:23 * carp skulks off
16:38:22 * carp crawls back under his information gathering rock
16:38:22 <Cale> hm?
16:38:36 <Cale> too late?
16:38:43 <carp> just reading todays logs
16:39:49 <carp> '
16:48:55 <dons> musasabi, re. your forum entry. that's fair enough, I think. I was surprised with the direction the entries were heading too
16:49:16 <dons> (though this partial sums trick is nice, if i ever get a chance to use it)
16:51:49 <jethr0_> is there an equivalent to "print" which doesn't add a newline?
16:53:01 * jethr0_ 's looking at System.IO :)
16:53:19 <dons> musasabi, but it looks like Isaac doesn't mind this (see his reply).
16:54:12 <phas> PARSEC > *
16:54:27 <phas> I'm in programming extasy
16:54:34 <dons> musasabi, hmm, I notice that all entries faster than ours use this trick, so we probably should to. 
16:55:40 <dons> musasabi, any update on how to get mandelbrot rerun now that you changed the Makefile, or how to pass -fexcess-precision to the new nbody?
16:59:34 <jethr0_> phas: parsec is the NICEST!
17:00:13 * dons invents new fun syntax for strictness annotations on functions:
17:00:19 <dons>     | () !k !n !alt !a1 !a2 !a3 !a4 !a5 !a6 !a7 !a8 !a9 !False = undefined
17:00:19 <dons>     ...
17:00:19 <dons>     where x ! y = x `seq` y
17:00:34 <ihope> jethr0_: (putStr . show)?
17:01:33 <jethr0_> ihope: thx
17:01:39 <dons> Cale, whaddya reckon ^^^ :)
17:08:47 <anotherdaniel> Given f :: (MonadError Int m, MonadIO m) => Int -> m String and g :: (MonadError String m, MonadIO m) => Int -> m String 
17:09:06 <anotherdaniel> can I call f from g, converting Int errors to String errors?
17:09:50 <anotherdaniel> It seems mapErrorT would force me to use ErrorT in the type of f and g, rather than MonadError.  Is that right?
17:12:45 <Cale> dons: :) did you see the proposal for ! patterns?
17:17:29 <dons> of course ;)
17:17:58 <dons> i just wanted them now!
17:28:00 <vincenz> is it possible to combine two reads
17:28:09 <vincenz> such that it returns an Either
17:28:13 <vincenz> assuming both can't fire
17:29:42 <musasabi> dons: yes, seems like Isaac prefers that way. Means that the partial-sums goes in.
17:31:35 <dons> yes, i have a faster version i'm about to post, if you can hold off comitting for a few minutes
17:31:55 <musasabi> ok, no problem.
17:34:37 * dons is getting good at optimising Core :)
17:35:18 <musasabi> dons: mandelbrot should rerun.
17:35:43 <musasabi> dons: nbody has -fexcess-precision in the Makefile
17:43:54 <TuringTest> dons : About the new | .. ! .. ! False syntax: Can you make it "... ! True =" if there is only one rhs, or is " False = undefined" more special than that?
17:45:22 <TuringTest> Also, general question: Is there any handy snippet of code which reifies and reflections functions to do symbolic differentiation?
17:49:03 <musasabi> I think there were at least GHC rules to do that ;)
17:50:20 <int-e> TuringTest: you can use True if there is only one RHS.
17:52:23 <TuringTest> int-e: Thanks
17:52:30 <Cale> The trick of using a guard which never succeeds in order to stick in a bunch of strictness of parameters is an old trick though. Using ! to make it look something like the ! patterns proposal is the new part :)
17:53:58 <TuringTest> musasabi: The wiki pointed to an old symbolic diff module, which emulated GADTS.  I wrote one this weekend using a gadt for the learning curve.  I was just wondering if there was a canonical version somewhere.
17:54:20 <dons> yeah, in this case i get an unboxed loop from ghc, instead of a space leak.
17:54:27 <TuringTest> Cale: I stole (!) = seq for making the symbol differentiation strict.
17:55:02 <TuringTest> dons: do you mean by using False instead of True ?  Interesting
17:56:08 <dons>  no no, by using seq in the first place.
17:56:12 <TuringTest> ah
17:57:13 <TuringTest> dons:  If it is 30% faster for partial-sums, then you will have beaten OCaml #2.
17:57:14 * SamB wonders how to use CmmFrontend to write a C-- compiler
17:57:26 <dons> musasabi, fastest partial-sums is ready to commit
17:57:47 * TuringTest has a small evil grin
17:57:47 <dons> yeah, we often beat OCAml, so it seems doable.
17:58:08 * TuringTest tries to not think about K-nucleotide
17:58:34 <dons> wait till fast packed strings are in the base libraries...
17:58:36 <vincenz> this won't work :(
17:58:38 <dons> then we'll be set ;)
17:58:49 <vincenz> http://rafb.net/paste/results/pFOE4X88.html
17:59:00 <TuringTest> dons: K-nucleotide is Hastable bound, not input bound.  FPS won't help a bit.
17:59:50 <dons> ah, true. but we're getting a new hash table too
17:59:50 <SamB> what makes you think FPS is only for input?
18:00:00 <dons> and that's another good point.
18:00:18 <dons> fps has fast hasing of strings, for example.
18:00:22 <TuringTest> SamB: Nothing.  But that is all we would need it for.
18:01:16 <SamB> someone else mentioned using some special insanely fast kind of trees packing four nucleotides in a byte...
18:01:54 <TuringTest> SamB: We probably would be prevented from assuming there were only 4 characters .  But I think I say that too.
18:01:58 <TuringTest> say->saw
18:02:09 <SamB> um.
18:02:36 <TuringTest> But mabe they would let us optimize that.  Hmmm....
18:02:39 <musasabi> dons: committed.
18:02:46 <SamB> since when are there more than four kinds in a single molecule?
18:03:50 <TuringTest> SamB:  http://haskell.org/hawiki/FastaEntra generates the input data.  Some of the section uses more interesting characters.
18:04:41 <TuringTest> SamB:  I read the whole data set into a single byte array (not Char) in 3\% of the runtime.  The I use pointers to refer to substrings.   All substrings are a fixed length, so this is very easy.
18:05:05 <musasabi> TuringTest: do other languages use things like that?
18:05:17 <TuringTest> musasabi: Like what?
18:05:28 <musasabi> the optimization you described?
18:06:00 <TuringTest> musasabi: I have no idea.
18:06:30 <musasabi> Basically I think that new algorithmic optimizations to established entries are not very nice if they force every single language to rewrtite things (because people didn't think of that as an allowed way to solve the problem)
18:07:01 <TuringTest> musasabi: The sequence is read only, so I can just use Ptr's to reference without copying.  I think gcc was making copies of each substring.
18:07:21 <musasabi> Of course we can just enter it and see whether it is accepted and see which languages have active contributors so they will follow in suit.
18:07:25 <TuringTest> The internals of strings in every language's hashtable ... I don't know.
18:07:56 <dons> my entry does that, btw. non-copy substrings.
18:08:20 <TuringTest> musasabi: It has been entered! http://shootout.alioth.debian.org/gp4/benchmark.php?test=knucleotide&lang=ghc&id=3
18:08:50 <TuringTest> And yes, don worked on the same entry.
18:08:55 <musasabi> TuringTest: yes, that is fine.
18:09:07 <dons> turingtest, re. ! annotations. without them the GHC Core (-ddump-simpl) generates a loop that looks like:  Str: DmdType S(L)S(L)LLLLLLLLLL]
18:09:11 <dons> Main.loop1 = \ (k_a19b :: GHC.Float.Double)
18:09:14 <dons>                (n_a19c :: GHC.Float.Double)
18:09:16 <dons>                (alt_a19d :: GHC.Float.Double)
18:09:20 <musasabi> TuringTest: however when we get the proper HashTable and FastStrings I think using them will be the fair choice.
18:10:04 <TuringTest> musasabi: We definately want to use the new HashTable.  And most string entries will want FastString for ascii processing without the Unicode overhead.
18:10:11 <dons> if we put `seqs` on the arguments, GHC instead generates: $sloop_r2Y4 = \ (a6_s2LE :: GHC.Prim.Double#)
18:10:14 <dons>                 (sc_s2WU :: GHC.Prim.Double#)
18:10:16 <dons>                 (sc1_s2WV :: GHC.Prim.Double#)
18:10:23 <TuringTest> Using Ptr is still typesafe...but not pointer arithmatic safe.
18:10:27 <dons> i.e.  fast, raw machine doubles.
18:11:16 <TuringTest> dons: That makes me happy.  Haskell is a little light on unboxing annotations that are ... predictable.
18:11:39 <musasabi> Basically in the long term I think the entries should move away from Foreign.* and GHC.*, winning by normal Haskell.
18:11:58 <dons> so i alwys read the Core of the entries to ensure that loops are unboxed. it's almost only a matter of reading the types ghc infers. only sometimes do i check which particular ops are generated.
18:12:08 <musasabi> Of course they are fine when the edge is needed.
18:12:12 <TuringTest> dons: I have a thought: There ought to be a Core parsing tool which informs you of all that strictness in a nicer way
18:12:59 <dons> musasabi, yes. agreed.
18:13:39 <TuringTest> musasabi: That may work in GHC 6.6 for several entries, but not all.
18:14:07 <TuringTest> General angst: Why can't the n-body code go faster?  Darn Darn Darn.  /angst
18:14:58 <TuringTest> partial-sums is numeric and fast. Grrrr...
18:16:21 <dons> also, i notice that ghc's CSE isn't great? maybe it should be cranked up manually somehow.
18:16:57 <dons> (i had to do my own CSE on today's partial-sums entry)
18:17:14 <vincenz> how do I do this
18:17:20 <vincenz> (a, f b)
18:17:28 <vincenz> @pl \(a,b) -> (a, fb)
18:17:28 <lambdabot> flip (,) fb . fst
18:17:29 <vincenz> @pl \(a,b) -> (a, f b)
18:17:30 <lambdabot> second f
18:17:43 <vincenz> @type second f
18:17:44 <lambdabot> Not in scope: `second'
18:17:44 <lambdabot>  
18:17:44 <lambdabot> <interactive>:1:7: Not in scope: `f'
18:17:50 <vincenz> @type second (+1)
18:17:51 <lambdabot> Not in scope: `second'
18:18:06 <vincenz> > second (+1) (1,2)
18:18:07 <lambdabot> (1,3)
18:18:11 <musasabi> TuringTest: because efficient mutable unboxed array operations are not very optimized in GHC?
18:18:25 <musasabi> TuringTest: neither on the API or the implementation level.
18:18:30 <TuringTest> musasabi: That is the logical conclusion.
18:18:48 <TuringTest> musasabi: But that code is also the fastest design on the wiki
18:19:11 <TuringTest> musasabi: I tried hard to use some other design.
18:19:34 <TuringTest> dons: Is the new partial-sums entry on the wiki?
18:20:53 <TuringTest> musasabi: I won't pass all 30 doubles to a 30-arity function for the n-body problem.  Too ugly.
18:21:10 <TuringTest> (and too much typing)
18:21:16 <musasabi> yes, much too ugly.
18:21:36 <musasabi> An alternative would be to get nicer benchmarks accepted into the shootout.
18:23:10 <musasabi> TuringTest: maybe use data declarations with strict fields + -funbox-strict-fields ?
18:23:38 <musasabi> Anyways, time for sleep ->
18:23:43 <TuringTest> ditto
18:24:03 * TuringTest puts computer to sleep as well
18:24:08 <int-e> > (\x y -> iterate x y !! 5) (\x y -> iterate x y !! 3) succ 0
18:24:09 <lambdabot> 243
18:32:36 <araujo> I love $
18:46:34 <syntaxfree> hey, gang.
18:57:28 <vincenz> how do you export a typename without it's implementation?
18:57:30 <vincenz> from a module
18:59:36 <vincenz> @hoogle liftIO
18:59:37 <lambdabot> Control.Monad.Trans.liftIO :: MonadIO m => IO a -> m a
18:59:37 <lambdabot> Graphics.UI.ObjectIO.StdIOBasic.liftIO :: IOMonad m => IO a -> m a
19:01:11 <int-e> vincenz: module Foo (Type (Con1)) where data Type = Con1 | Con2 -- exports only Con1, but not Con2. note that that list can be empty.
19:02:04 <vincenz> hmm
19:05:32 <int-e> actually, just module Foo (Type) where  does it - it exports the type name but no associated constructors
19:05:38 <int-e> or accessors (if you have any)
19:46:22 * araujo just solved a problem in 'sort' of an elegant way
19:53:07 <araujo> mmm...
19:53:30 <araujo> I wonder what are the chances for a haskell program to give segmentation faults......
19:55:36 <gzl> low
19:55:41 <rep> what's your opinion on asian chix?
19:56:12 <araujo> gzl, thought so.....
19:56:16 <araujo> just got one here :-(
19:56:32 <araujo> I imagine something very really bad is happening here.
19:59:24 <int-e> good, with FFI ;)
19:59:56 <araujo> yeah... dealing with FFI.....
20:00:08 <araujo> Though not directly.
20:00:09 <vincenz> int-e: you assumed a data
20:00:21 * araujo gets some yogurt
20:00:22 <vincenz> int-e: what if it's just type MyBlabla x y = StateT x IO y
20:01:51 <araujo> dcoutts, ping pong!
20:02:26 <int-e> vincenz: type aliases can't be hidden - I'd expect newtype to work though. (newtype MyBlabla x y = MyBlabla { unBlabla :: StateT x IO y } deriving (Monad, MonadState), say - I hope I got the syntax correct)
20:02:45 <vincenz> thx
20:03:36 <int-e> vincenz: note that this is a bit harder to work with than a type alias.
20:03:44 <vincenz> yeah
20:03:56 * araujo tries something crazy
20:04:14 * int-e tries to stop araujo 
20:04:23 <int-e> araujo: don't :)
20:04:36 * int-e expects to fail though.
20:12:10 <araujo> int-e, haha, just tried.. but well... it was something crazy 
20:12:15 <palomer> are there #haskell logs?
20:12:17 <araujo> it wasn't supposed to work at all :-]
20:12:33 <araujo> @where logs
20:12:34 <lambdabot> http://tunes.org/~nef/logs/haskell/
20:19:03 <palomer> woot
20:19:09 <palomer> implemented my first function in gtk2hs
20:19:16 <palomer> how do I update the repository?
20:21:01 <lispy> heh, ghc is slow to compile, but 3+ days on a P4 at 2.4Ghz seems like a bit much....
20:21:15 <lispy> palomer: darcs record, darcs send?
20:22:07 <palomer> from the root directory?
20:22:16 <int-e> 3+ days?!
20:22:32 <lispy> palomer: as long as your inside the repo, darcs will find the root
20:22:51 <lispy> int-e: yeah, time to file a bug report i think
20:23:08 <int-e> lispy: are you bootstrapping without an existing ghc?
20:23:24 <lispy> no, i have ghc-6.4.1 installed from apt
20:23:49 <int-e> lispy: then that's too much unless things have changed dramatically since 6.4.1 :)
20:25:53 <palomer> lispy: will it record all changes?
20:26:05 <lispy> palomer: it's interactive by default
20:26:19 <lispy> palomer: it should ask you about each "hunk" of changes
20:27:27 <lispy> palomer: you use darcs record to create a patch that is then stored in therepo, and use darcs send or darcs push to share the patch
20:28:11 <palomer> because I added files I don't want recorded
20:29:22 <lispy> you have to explicitly 'darcs add' everyfile you want to include in the repo
20:29:25 <palomer> and darcs send knows I got the source from?
20:29:32 <lispy> yeah
20:29:33 <palomer> lispy: ahh, gotcha
20:29:52 <lispy> darcs send requires that you have senmail or similar configured
20:30:12 <lispy> if that is not the case, use darcs send -o mypatch
20:30:26 <lispy> and then it will create "mypatch" that you can attach to an email
20:31:02 <lispy> note, darcs can't tell if your system delivers the email so even a misconfigured system will look like it sent the email
20:34:33 <palomer> oh my
20:34:36 <palomer> I don't have anything configured
20:35:35 <lispy> no problem, just use the -o version of send and then manually email the resulting file
20:39:19 <palomer> to whom?
20:40:05 <lispy> palomer: maybe i didn't understand. 
20:40:18 <lispy> darcs record updated your local repository
20:40:27 <palomer> sure
20:40:30 <lispy> i thought you wanted to share your patch with someone
20:40:55 <palomer> yeah, I was simply going to send it
20:41:03 <palomer> like, darcs send
20:41:15 <lispy> well, send it to that address :)
20:41:23 <lispy> it should tell you the address when you run that command
20:41:27 <palomer> but I was just going to type "darcs send"!
20:41:32 <palomer> oh, righto
20:41:54 <palomer> wee, it works
21:35:15 * palomer loves typeclasses
21:35:34 <palomer> what do you guys think of making the first argument of typeclass members implicit?
21:35:37 <palomer> then we can use dot notation
21:36:13 <LimeKMag> palomer: what does O'Haskell do?
21:37:27 <palomer> probably the same thing
21:37:32 <palomer> but it makes sense
21:37:45 <sieni> what would macgyver do?
21:39:29 <palomer> pffft
21:39:36 <palomer> I just defined a monad without realising it
21:39:39 <palomer> but there's no fail
21:41:43 <LimeKMag> Are there standard GUI widget sets for Haskell?
21:42:01 <palomer> LimeKMag: yeah, gtk2hs
21:42:06 <palomer> you can even use glade with it
21:42:08 <sieni> and wxhaskell
21:42:14 <palomer> gtk2hs is sweet:O!
21:42:41 * LimeKMag thinks of a project to motivate the Haskell learning
21:42:42 <sieni> wxwidgets is nice if you need native look on windows and mac os x
21:43:02 * palomer wishes he could do a@(C a b) d e
21:43:54 <LimeKMag> GTK is much more standard across languages, no?
21:44:54 <palomer> gtk is modern, fast and easy to use
21:45:53 <palomer> oh wait, it's not a monad...it doesn't have return
21:46:21 <sieni> yes gtk is nice, but still doesn't help, if you need native looking mac os x applications
21:46:32 <palomer> gtk has native themes, no?
21:46:43 * palomer would be very surprised if it didn't
21:47:21 <sellout> GTK looks worse on OS X than the Java OS X plaf.
21:47:54 <palomer> java also has native looking mac themes!
21:48:23 <sieni> palomer: there are problems, like the fact that application menu on mac os x is on the top of screen
21:48:26 <sellout> palomer: Nah ... they're pretty obvious not native.
21:48:34 <sellout> s/obvious/obviously/
21:48:51 <sieni> palomer: apple supports its own java runtime with native look
21:49:07 <dons> you'd use the cocoa binding on the mac, I guess.
21:49:12 <sellout> I mean, they look recognizably like OS X, but still noticeably different.
21:49:13 <palomer> hullo dons
21:49:21 <dons> mocha, or whatever it is called now.
21:49:28 <dons> hey palomer
21:50:18 <sieni> well... qt bindings would be nice ^_^
21:51:00 * palomer wishes there was an english word for "second coordinate"
21:51:19 <Cale> ordinate and abscissa
21:51:21 <palomer> what's the prefix for 2?
21:51:34 <palomer> what do you guys think of bycoord?
21:51:50 <Cale> bycoord?
21:51:59 <palomer> err bicoord
21:52:13 <Cale> I'd think of something having two coordinates
21:52:52 <palomer> ficoord,secoord,thicoord,fourcoord,fifcoord
21:53:05 <palomer> though 1 and 5 are too close to each other
21:53:08 <palomer> grrr
21:53:20 <Cale> what's the goal?
21:53:35 <palomer> shorter variable names
21:53:37 <sieni> palomer: as cale said, aren't "abscissa" and "ordinate" enough?
21:53:39 <palomer> getFirstCoordinate
21:53:50 <dons> numeric suffixes?
21:53:53 <palomer> sieni: what about third and fourth coordinate?
21:54:08 <Cale> getCoord1 ?
21:54:13 <palomer> onecoord, twocoord,threecoord,fourcoord,fivecoord
21:54:17 <dons> a1 a2 a3 a4 a5?
21:55:03 <Cale> getCoord :: Int -> something
21:55:19 <palomer> Cale: I'm using tuples
21:55:20 <Cale> assuming they're the same type
21:55:36 <palomer> coordone,coordtwo,coordthree it is!
21:55:40 <Cale> what kind of tuples? 5-tuples aren't so fun
21:55:52 <palomer> Cale: right, but this is also to have a generic word/function in my head
21:55:59 <dons> it's unusual to use non-numeric numbers. they're harder to read, that's why Kurt Vonnegut always used numeric literals in his novels
21:56:32 <Cale> well, they're not always harder to read.
21:56:41 <Cale> I suppose it depends on the situation
21:57:02 <dons> in the above, I think they are. but i'm sure there are exceptions, yep.
21:57:18 <Cale> yeah, in the above, sure
21:57:34 <palomer> s/    word/function     /       word/function mapping
22:01:32 <palomer> man, we need dependent types only for tuples
22:01:54 <palomer> seriously
22:09:51 <palomer> http://www.rafb.net/paste/results/fUjQQE57.html <--I really can't see what I'm doing wrong
22:12:06 <palomer> anyone have a clue?
22:16:26 <Cale> palomer: looks like your implementation of setTag for the QualifiedParameter case is broken -- in particular, QualifiedParameter only takes two params
22:16:34 <Cale> er
22:16:36 <Cale> no
22:16:38 <Cale> sorry
22:16:41 <Cale> however
22:16:56 <Cale> the first param has that same tag type, doesn't it?
22:17:06 <Cale> so you have to update that tag too
22:17:34 <palomer>     setTag :: c a -> b -> c b 
22:17:38 <palomer> gives me the same error
22:17:51 <Cale> setTag (QualifiedParameter x y tag) newTag = QualifiedParameter (setTag x newTag) y newTag
22:18:14 <palomer> oh, righto
22:18:15 <Cale> see why that's necessary?
22:18:59 <palomer> oh my
22:19:01 <palomer> yes
22:19:10 <palomer> but then I'll be changing everyones tag
22:19:11 <palomer> hmmm
22:19:15 <palomer> this isn't what I want
22:19:40 <palomer> I guess c v -> v -> c v is what I need
22:19:46 <Cale> yeah
22:19:58 <palomer> but this is quite restrictive
22:20:12 <palomer> we should have something called the "transcendental tuple type"
22:20:27 <palomer> oh, wait, it would suffer from the same pitfalls
22:20:32 <palomer> any novel ideas?
22:21:07 <Cale> hm?
22:21:15 <Cale> Perhaps you want an existential type?
22:21:24 <palomer> how so?
22:21:59 <Cale> you seem to want this structure where a variety of types are allowed throughout it
22:22:31 <palomer> I want a generic way of tagging this datatype
22:22:35 <palomer> this way seems too restrictive
22:23:16 <Cale> in order to ever be able to act on those values, you need to either record explicitly in the type system what those types are, or you use an existential type, which throws away some of the type information, leaving only the guarantee that you can apply the members of some typeclass
22:25:03 <Cale> you can use nested pairs, in some sense,
22:25:14 <Cale> to get a list of various types
22:25:30 <palomer> wait!
22:25:35 <palomer> generalised algebraic datatypes
22:25:41 <palomer> oh boy
22:26:28 <palomer> App :: Term u -> Term v -> Term (u,v)
22:26:39 <palomer> what do you think?
22:27:44 <Cale> you can do that
22:27:51 <Cale> yeah
22:28:34 <palomer> then I could do setTag:: Term u -> v -> Term v
22:29:07 <Snowden> how do i do an emote?
22:29:19 <palomer> actually, App :: Term u -> Term v -> w -> Term ((u,v),w)
22:29:27 <palomer> Snowden: /me
22:29:36 <palomer> Snowden: read catch 22?
22:29:41 * Snowden thanks palomer
22:29:45 <Snowden> yup yup
22:29:49 <Snowden> great book
22:29:49 <palomer> good book.
22:29:59 <Snowden> ;)
22:30:20 <palomer> grr
22:30:41 <palomer> I don't want to annotate my functions if I use GADTs
22:30:43 <palomer> I really shouldn't have to
22:39:07 <palomer> oh boy
22:39:10 <palomer> I hate ST type errors
22:39:48 <palomer> hate hate hate them!
22:40:42 <palomer> http://www.rafb.net/paste/results/gMUeka68.html
22:40:58 <Snowden> is there a style guide for haskell somewhere? like mundane recomendations for commenting and other small details
22:41:23 <palomer> Cale: any ideas?
22:42:50 <palomer> Cale: y is a Term (not monadic)
22:44:37 <dons> @learn
22:44:38 <lambdabot> http://www.haskell.org/learning.html
22:45:13 <dons> Snowden, and check the wiki. also on haskell.org
22:46:10 <JohnMeacham> Hmm.. I wonder if I can make jhc target the yhc virtual machine easily. that might be interesting because it would let me fairly compare the front ends.
22:57:13 <dcoutts> LimeKMag, Gtk+ looks about as native on win32 as wxWidgets. At the moment wxWidgets looks better than Gtk+ on MacOSX but a Gtk+ native port is currently under development (ie not using X11).
22:57:42 <palomer> found my error
22:57:49 <dcoutts> araujo, pong
22:57:51 <palomer> debugging it is _hard_
22:59:46 <araujo> dcoutts, hello!!
23:00:02 <palomer> dcoutts: I implemented the function in the file you mentioned
23:00:03 <adu> hi araujo
23:00:09 <palomer> dcoutts: I don't think it's where it's supposed to go
23:00:12 <dcoutts> palomer, so did you darcs send it?
23:00:25 <dcoutts> hia araujo 
23:00:25 <araujo> Hello adu 
23:01:05 <palomer> dcoutts: I don't have sendmail configured, and it should really go into the drawWindow source
23:01:12 <araujo> dcoutts, are segmentation faults common with TreeViews? :-]
23:01:26 <dcoutts> araujo, hopefully not :-)
23:01:28 <adu> > putStr "Testing"
23:01:29 <lambdabot> No IO allowed
23:01:35 <adu> > "Testing"
23:01:36 <lambdabot> "Testing"
23:01:41 <araujo> dcoutts, im getting one here *agh*
23:02:19 <dcoutts> palomer, you can use darcs send -o drawWinGetOrigin.patch and then email that file as an attachment
23:02:35 <dcoutts> palomer, yeah, it should really go into the drawWindow source file
23:03:49 <palomer> dcoutts: I'll go source digging tomorrow (I hope I remember) and restructure everything so its fine and dandy
23:04:11 <dcoutts> palomer, ok just send the oatch as is
23:04:25 <dcoutts> I'll put it in the right place
23:06:17 <palomer> dcoutts: http://www.rafb.net/paste/results/uBBZ3080.html   
23:06:21 <palomer> simpler to pastebin it
23:06:23 <dcoutts> ok
23:06:37 <nibro> @seen dons
23:06:38 <lambdabot> dons is in #haskell-blah and #haskell. Last spoke 21 minutes and 24
23:06:38 <lambdabot> seconds ago.
23:07:05 <palomer> change root window to windowing system
23:07:12 <palomer> (I find the term root window confusing)
23:07:58 <palomer> btw, how do I empty a window of all its widgets (so they get destroyed) ?
23:08:01 <dcoutts> how about "global windowing system" coordinates?
23:08:29 <dcoutts> or jsut screen coordinates
23:08:45 <dons> nibro, sorry. no further on it yet. but it's haunting my sleep, so expect progress in the next couple of days.
23:09:11 <palomer> dcoutts: sure
23:09:49 <palomer> dcoutts: http://www.rafb.net/paste/results/VmV6JU86.html      <--to convert widget coordinates
23:13:05 <palomer> dcoutts: it seems that I'll have to destroy my tipwindows every time they change
23:13:18 <dcoutts> why?
23:13:18 <palomer> since vboxes are set at a certain height
23:13:35 <dcoutts> huh?
23:13:39 <palomer> I can change the height of a vbox?
23:13:47 <dcoutts> you can change the number of child widgets in a vbox
23:14:15 <palomer> but a vbox has a specific height (specified in the constructor)
23:14:42 <palomer> which can't change (I think)
23:15:26 <dcoutts> palomer, no that's not a height
23:15:38 <dcoutts> thats a padding/spacing
23:16:09 <dcoutts> http://haskell.org/gtk2hs/docs/current/Graphics-UI-Gtk-Layout-VBox.html#v%3AvBoxNew
23:16:23 <dcoutts> Bool	homogeneous - True if all children are to be given equal space allotments.
23:16:29 <dcoutts> Int	spacing - the number of pixels to place by default between children.
23:16:54 <dcoutts> palomer, the number of widgets depends on the number you actually add
23:17:45 <dcoutts> palomer, you can use containerRemove
23:18:04 <dcoutts> containerRemove vbox label
23:18:17 <palomer> oh
23:18:22 <palomer> nice
23:18:48 <dcoutts> containerGetChildren vbox >>= mapM_ (containerRemove vbox)
23:19:23 <dcoutts> containerClear c = containerGetChildren c >>= mapM_ (containerRemove c)
23:19:32 <nibro> dons: oki, and my appologies for making you sleep bad :-)
23:25:56 <dons> :)
23:48:45 <palomer> very strange: if you don't put anything in a vbox, it's really big
23:50:39 <sieni> LaTeX?
23:52:20 <dcoutts> palomer, btw darcs pull
23:52:44 <dcoutts> palomer, is it 200x200 ?
23:53:09 <dcoutts> unconstrained windows are 200x200 by default
23:53:39 <dcoutts> sieni, no, Gtk+ :-)
23:53:42 <palomer> looks that big
23:53:46 <palomer> darks pull what?
23:53:48 <palomer> oh, you updated it
23:53:51 <dcoutts> yep
23:53:56 <palomer> wow I'm tired
23:54:11 <palomer> @hoogle [a] -> Bool
23:54:11 <lambdabot> Data.List.null :: [a] -> Bool
23:54:11 <lambdabot> Prelude.null :: [a] -> Bool
23:54:11 <lambdabot> Graphics.UI.ObjectIO.CommonDef.isSingleton :: [x] -> Bool
23:54:16 <dcoutts> go to bed then -)
23:55:06 <palomer> but I'm so close!
23:56:05 <palomer> (mycalc:22970): Gtk-WARNING **: Attempting to add a widget with type GtkLabel to a GtkWindow, but as a GtkBin subclass a GtkWindow can only contain one widget at a time; it already contains a widget of type GtkLabel
23:56:33 <palomer> this is for a vbox
23:57:13 <dcoutts> are you sure?
23:57:21 <palomer> how can I check?
23:57:23 <dcoutts> sounds like you're adding things to a window
23:57:31 <dcoutts> take a look at the code
23:57:36 <palomer> oh wait, you're right
