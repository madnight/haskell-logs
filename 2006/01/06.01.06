00:01:31 <cmcq> can i declare a number to be between 1 and 12?
00:02:10 <gaal> meta bug report: http://hackage.haskell.org/trac/ghc/newticket?type=bug is broken
00:02:32 <dons> cmcq?
00:02:56 <dons> you want a random number between 1 and 12?
00:03:10 <boegel> dons: cmcq probably means a type that only allows a number between 1 and 12 ?
00:03:10 <cmcq> no, I want a subtype of Integer
00:03:15 <boegel> see :)
00:04:52 <cmcq> it looks like there isn't such a thing, but it would seem useful, like CL's (integer 1 12)
00:05:30 <dons> well, one way is to declare a new data type, hide the constructor, and instead export a smart constructor that checks the range first.
00:05:37 <boegel> I believe there is such a thing, but only for GHC... can't remember the ame though
00:05:43 <boegel> nice solution
00:05:44 <boegel> :)
00:08:52 <ADEpt> @seen Lemmih
00:08:53 <lambdabot> Lemmih is in #haskell-blah and #haskell. Last spoke 6 hours, 3 minutes
00:08:53 <lambdabot> and 8 seconds ago.
00:09:11 <dons> module A (A, newA) where
00:09:11 <dons> newtype A = A Int deriving Show
00:09:11 <dons> newA i | i < 0 || i > 12 = error "Runtime error constructing newA"
00:09:20 <dons>        | otherwise       = A i
00:09:52 <dons> Prelude A> A 7    
00:09:52 <dons> <interactive>:1:0: Not in scope: data constructor `A'
00:09:52 <dons> Prelude A> newA 7
00:09:52 <dons> A 7
00:09:52 <dons> Prelude A> newA 13
00:09:54 <dons> A *** Exception: Runtime error constructing newA
00:10:16 <cmcq> hmmm
00:10:23 <dons> an alternavtive would be to define your own Nats
00:10:26 <cmcq> really I was just hoping for more specific types on my arrays
00:10:39 <dons> have an array of A
00:11:02 <dons> (it's a newtype, so there's no runtime cost to the 'A')
00:11:16 <cmcq> and say A deriving Ord ?
00:11:24 <cmcq> oh, newtype
00:11:31 <cmcq> still
00:12:01 <araujo> dons, hey there
00:14:37 <dons> you can't define subsets of other types. but you can create newtypes that are isomorphic to other types, if you wish. data Nat12 = One | Two | Three ... .. instance Num Nat12 .. and so on.
00:14:50 <dons> "new types", not newtypes :)
00:16:20 <dons> you could try: data Nat12  = N1 | N2 | N3 | N4 | N5 | N6 | N7 | N8 | N9 | N10  | N11 | N12
00:16:47 <dons> if you really really need to enforce statically that a number is always within bounds
00:17:29 <orbitz> araujo: mew!
00:17:55 <dons> morning araujo.
00:58:08 <joelk> dons, I've gone another direction with optimizing my nbody. It's now my fastest version. Still slower, but more elegant (:-), than the imperative-like one currently listed.
01:15:23 <araujo> orbitz, stop chasing me! 
01:15:24 <araujo> :-P
01:15:29 <araujo> Hello dons 
01:19:50 <Bobstopper> Hi all. I've been reading about monads. Do monads actually eliminate side-effects and assignment in haskell or do they just encase them in such a way that they're isolated from the truly functional stuff?
01:21:49 <ADEpt> Bobstopper: they do former via the latter
01:22:04 <integral> they move the actual side effects from being in the Haskell to being in the thing forcing the monad to evaluate...
01:23:06 <Bobstopper> Hmm... ok. Thanks.
01:23:13 <ADEpt> Bobstopper: they eliminate dangers of side-effects and capture the concept of mutable state by encasing the computations that need them in a way that make them isolated and pure functional on the outside. Something like that.
01:47:59 <ADEpt> i do "contents <- readFile fname; when (contents/=something) (do { h <- openFile rname WriteMode; ...}), at which point i get "openFile: resource busy (file is locked)". How Ican close it after readFile, if this is indeed the cause for error?
01:58:20 <araujo> ADEpt, But... they are not the same files?
01:59:49 <ADEpt> araujo: they are
02:00:12 <ADEpt> araujo: what i want is to read the file, do some checks on content, and on some condition replace the contents
02:03:52 <araujo> ADEpt, Can you show the code?
02:04:02 <araujo> Good morning.
02:04:51 <ski> ADEpt : 'h <- openFile fname ReadMode; contents <- hGetContents h; when (contents/=something) (do { hClose h; h <- openFile rname WriteMode; ...})' ?
02:05:13 <ADEpt> ski: thnx. did almost that, it works
02:05:52 <ski> (another solution would maybe be to force the whole 'contents' string .. maybe calling some GC would help too, not sure)
02:05:58 <ski> interesting problem, anyway :)
02:07:12 <araujo> mm.. weird, why it doesn't work with readFile?
02:07:14 <int-e> hmm. what does happen if you force more of 'contents' after closing h?
02:07:47 <ADEpt> int-e: everything supposed to be OK (via 'semi-closed' magick)
02:08:26 <ski> hmm
02:08:32 * ski is not sure
02:10:31 <int-e> @index hClose
02:10:32 <lambdabot> System.IO
02:14:42 <ADEpt> ski: btw, if you do (hClose h) after (hGetContents h), you'll end up without any input at all. All due that 'semi-closed' magick
02:14:43 <int-e> there's no error but the contents will be truncated, says my test program
02:17:07 <lisppaste2> boro pasted "Whats wrong ?" at http://paste.lisp.org/display/15417
02:21:16 <boro> anyone ? :S
02:21:32 <ski> boro : is there a type error ?
02:21:48 <ski> (didn't see an error in the code, on first glance)
02:22:09 <boro>  Prelude.!!: index too large but how ?? i never got that big :S
02:22:11 <int-e> list!!i --> (list !! i) I guess
02:22:17 <int-e> hmm
02:22:42 <boro> int-e
02:22:44 <boro> thats it
02:22:48 <boro> Fuck :P
02:22:50 <ski> hrmm
02:22:52 <ski> yes
02:22:57 <boro> That was my exam question
02:23:11 <boro> and i missed another () also :S
02:23:14 <ski> :/
02:23:28 <boro> Hope not to lose so much points
02:23:33 <int-e> funny example - usually you get type errors for that kind of mistake
02:24:48 <boro> Does this script uses list only once ?
02:25:06 <boro> You knw what i mean :P
02:25:29 <ski> (you have two redundant pairs of parens, too .. and you're accumulating by appending to a list, which can be done better (this is O(n^2) instead of O(n))
02:26:13 <ski> it should extract each element from the list once, yes
02:26:30 <boro> btw, ski
02:26:38 <boro> those exapmles you gave me this morning
02:26:45 <boro> few hours ago
02:26:52 <boro> they helped me much :D
02:26:56 <boro> So thank you
02:29:20 <int-e> > let paljunda l = concat $ zipWith (map . const) l (tails l) in paljunda [1,2,3]
02:29:22 <lambdabot> [1,1,1,2,2,3]
02:30:48 <boro> :D
02:37:30 <lisppaste2> boro pasted "Whats wrong here ?" at http://paste.lisp.org/display/15418
02:37:36 <lisppaste2> boro pasted "Whats wrong here ?" at http://paste.lisp.org/display/15419
02:37:36 <lisppaste2> boro pasted "Whats wrong here ?" at http://paste.lisp.org/display/15420
02:37:40 <boro> Oups
02:37:42 <boro> :D
02:38:03 <boro> What about this code
02:38:09 <boro> whats wrong 
02:39:17 <boro> ERROR - Cannot infer instance
02:39:17 <boro> *** Instance   : Num [(a -> a -> a) -> b -> b]
02:39:17 <boro> *** Expression : mapfold (flip (+) 1) (+) 1 [2,3,4]
02:39:58 <int-e> same thing?
02:40:07 <int-e> [f1 list!!i]
02:41:49 <ski> maybe you meant 'mapfold (a ++ [f1 (list !! i)]) ((reverse list !! i) `f2` c) (i+1)' ?
02:42:55 <ski> (also, you're getting the equivalent of a 'foldl',not a 'foldr', here .. also, because of this, the function is strict and not lazy, so will not work on infinite lists (as 'map' and 'foldr' will))
02:43:45 <ski> (also, note that '(reverse list !! i) `f2` c' is the same as 'f2 (reverse list !! i) c')
02:43:53 <int-e> well, with this recursion pattern, any function will be strict.
02:44:18 <ski> m
02:44:24 <int-e> (i < length list  forces the whole list)
02:44:41 <boro> Well. there my poits goes :S What you think, my code is so wrong that i'm not able to get atleast 15/20 points
02:45:12 <int-e> why did you put f2 between it's arguments? that's weird.
02:45:18 <ski> well, two typos, and one alg structure problem
02:45:24 <int-e> (unless you meant `f2` as ski guessed)
02:45:43 <boro> i meant `f2` :(
02:46:29 <boro> Guess i have to make this exam 3rd time also :D
02:46:35 <boro> Or next year :D
02:46:49 <ski> the alg problem is the largest, imo
02:47:20 <araujo> @index fileExist
02:47:20 <lambdabot> System.Posix.Files, System.Posix
02:47:36 <ski> the typo problems is much easier to notice,usually,if sitting in front of a real system
02:48:18 <int-e> you should really use list recursion :/ - and not accumulate the result for foldr   mapfold f1 f2 b [] = ([], b); mapfold f1 f2 b (x:xs) = let (r1, r2) = mapfold f1 f2 b xs in (f1 x : r1, f2 x r2)
02:50:59 <ski> @type let mapfold f1 f2 b xs = foldr (\x (r1,r2) -> (f1 x : r1,f2 x r2)) ([],b) xs in mapfold
02:51:00 <lambdabot> forall a a1 b. (a -> a1) -> (a -> b -> b) -> b -> [a] -> ([a1], b)
02:58:47 <twb> ADEpt: ping?
02:59:24 <twb> ADEpt: I just wanted to say thanks for encouraging me to try Parsec.Token.  It's working quite well.
03:00:37 <Heffalump> anyone know why *!*@*.mweb.co.za is banned?
03:01:00 <Heffalump> > 1312967 `div` (60*60*24)
03:01:02 <lambdabot> 15
03:02:45 <defcon8> twb, what brings you to this realm?
03:03:13 <twb> defcon8: I come here regularly.
03:03:45 <defcon8> ok
03:04:16 <Heffalump> or could someone unban it, if there's no known reason? It's preventing jewel from joining.
03:09:06 <ADEpt> twb: that's great :)
03:09:53 <ADEpt> twb: good for my carma. Less chances for me being stuck with Parsec troubles next time I write parser :)
03:26:53 --- mode: ChanServ set +o shapr
03:27:14 --- mode: shapr set -b *!*@*.mweb.co.za
03:27:36 --- mode: shapr set -o shapr
03:34:22 <neologism> A[A[B[A
03:34:45 <shapr> Yeah, that's what I was thinking.
03:50:09 <maitscha41> hmm... again: I have nz = snd $ head $ filter (\x -> fst x == b) (fst3 a)
03:50:23 <maitscha41> what is the best method to avoid runtime errors when filter has a result of [] ??
03:50:35 <joelk> I started a computer shootout nbody entry on the wiki by posting my own slow but cute (in my opinion) version.
03:50:44 <joelk> @wiki NbodyEntry
03:50:45 <lambdabot> http://www.haskell.org/hawiki/NbodyEntry
03:50:54 <basti_> maitscha41: what do you want instead of errors?
03:51:37 <maitscha41> hmmm.... in that case nz should be []
03:51:47 <basti_> but why? is it a list, normally?
03:51:57 <maitscha41> yes. it is a list.
03:52:25 <basti_> then fst a is list too?
03:52:36 <twb> joelk: why did you decide to use cubic vectors rather than n-ary vectors?  Speed?
03:53:03 * earthy curses
03:53:19 <maitscha41> fst3 is of form [(1,[(2,'a'),(5,'d')]),(2,[(3,'b')])]
03:53:27 <maitscha41> fst3 a ...
03:53:28 <joelk> Well, our solar system is currently in a 3 dimensional universe... :)
03:53:42 <twb> joelk: If you believe Newton... :-)
03:53:49 <basti_> maitscha41: i'm asking, because, normally, head :: [a] -> a
03:53:55 <basti_> so usually you would get a single element
03:54:43 <basti_> if that single element were a list, then returning an empty list would have different semantics from returning no list
03:55:01 <earthy> why oh why can't I find a law that given a catamorphism (| phi |) I can split phi into a form phi_1 \/ phi_2 \/ phi_3 where the phi_'s are linked to the constructors of the datatype...
03:55:18 <earthy> (read downwards triangles for the \/ :))
03:55:22 <basti_> maitscha41: maybe you want fromMaybe?
03:55:36 <basti_> but, still, this doesnt seem to make a lot of sense
03:55:37 <joelk> twb, ok, well if you're gonna be picky :) The nbody problem exists in a 3d universe with a gravitational Hamiltonian slightly perturbed from that predicted by Newtonian Mechanics. 
03:55:45 <ulfdoz> .oO( Train station )
03:56:05 <basti_> ulfdoz: lol.
03:56:20 <maitscha41> basti_: no, when filter (\x -> fst x == b) (fst3 a) == [], nz should be []
03:56:42 <Heffalump> arjanb: what does that have to do with it being a catamorphism?
03:56:48 <Heffalump> s/arjanb/earthy/ # sorry
03:57:00 <maitscha41> is there somenthink like nz = | filter (\x -> fst x == b) (fst3 a) == [] | otherwise = [1,2,3] ???
03:57:03 <basti_> maitscha41: so you're sure that an empty list in that case is the correct semantics
03:57:18 <basti_> first, you could construct that by hand
03:57:24 <maitscha41> basti_  yes i am sure
03:57:31 <basti_> like: matching (x:_) or []
03:58:22 <basti_> (x:_)->x; [] -> []
03:58:32 <basti_> that would be similar to the definition of head
03:58:38 <basti_> and serve the same purpose
03:58:52 <twb> basti_: I would write "head' bleh where head ..." and then that function.
03:58:55 <basti_> it just would have the type [[a]]->[a]
03:59:09 <basti_> twb: yes.
03:59:22 <twb> Or maybe (x:_) -> SOME x; [] -> NONE
03:59:30 <earthy> heffalump: it doesn't, not really
03:59:35 <twb> For haskell values of SOME and NONE, which I always forget.
03:59:42 <basti_> Just/Maybe
03:59:52 <basti_> uhm
03:59:55 <basti_> Just/Nothing
04:00:05 <twb> @info Maybe
04:00:06 <lambdabot> Unknown command, try @listcommands.
04:00:09 <maitscha41> hmmm... 
04:00:13 <twb> odd.
04:00:37 <basti_> @info Data.Maybe
04:00:38 <lambdabot> Unknown command, try @listcommands.
04:00:39 <maitscha41> isn't there something like a binary operator in c ...    condition ? true : false
04:00:41 <basti_> @info Data.Maybe.Maybe
04:00:41 <lambdabot> Unknown command, try @listcommands.
04:00:44 <resiak> @index Maybe
04:00:45 <lambdabot> Data.Maybe, Prelude
04:00:51 <basti_> very odd
04:00:55 <resiak> @type Data.Maybe
04:00:57 <lambdabot> Couldn't find qualified module.
04:00:57 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
04:00:57 <lambdabot> \\)?
04:00:57 <basti_> maitscha41: yes, it's called if...then...else
04:00:58 <twb> basti_: the problem is the info, not the data identifier.
04:01:07 * resiak gives up.
04:01:10 <basti_> twb: yes you're right.
04:01:22 <basti_> thats broken
04:01:24 <JKnecht> catamorphism = morphism on categories?
04:01:44 <basti_> JKnecht: no, a catamorphism is a function that "destructs" datatypes. Like, fold.
04:01:48 <Heffalump> earthy: so can't you find some law that isn't about them?
04:01:55 <basti_> (List -> maybe something non-list)
04:02:03 <Heffalump> @type Data.Maybe.Just
04:02:05 <lambdabot> forall a. a -> Maybe a
04:02:14 <Heffalump> resiak: Maybe is a type, it doesn't have a type
04:02:26 <Heffalump> and Data.Maybe is a module, not a type. Data.Maybe.Maybe is a type.
04:02:26 <earthy> but I'd be greatly helped by it. :) Now I'm going to have to prove what I want a different way... unfusing the cata I have and the function that is ruining the connection between phi and its constituents
04:02:27 <basti_> Heffalump: but it has a kind.
04:02:35 <Heffalump> basti_: yes, but he was using @type, not @kind :-)
04:02:38 <Heffalump> @kind Data.Maybe.Maybe
04:02:39 <basti_> :D
04:02:40 <lambdabot> * -> *
04:02:42 <basti_> i see.
04:02:43 <basti_> and info?
04:02:50 <Heffalump> that's sort of catch-all, isn't it?
04:03:04 <basti_> @info Data.Maybe.Maybe
04:03:05 <lambdabot> Unknown command, try @listcommands.
04:03:10 <basti_> ah
04:03:21 <basti_> i think someone put something in my tea this morning
04:03:55 <resiak> Heffalump: Is there a way to make lambdabot show me the type Data.Maybe.Maybe's definition?
04:08:09 <jips> morning
04:09:29 <jips> anyone good with yampa?
04:09:46 <basti_> heh
04:09:53 <basti_> we -need- a yampa rework! :(
04:10:43 <jips> what's a rework?
04:10:52 <basti_> well yampa is like antique
04:11:03 <basti_> nobody gets anything meaningful to run on it.
04:11:31 <jips> well what's wrong with it? :)
04:11:57 <basti_> it was written for an older haskell version, and nobody had the courage to rework it
04:12:20 <jips> it seems to work ok with latest ghc
04:13:13 <basti_> did you get the arcade to run?
04:13:55 <Saulzar> Just have to fix a few HGL imports and you can get it to go
04:14:00 <jips> no, but i started to port it to my SDL yampa "framework"
04:14:28 <jips> i gave up though after getting the simpleGun to work := now i'm trying to make a tetris game
04:14:35 <Saulzar> I know a little about it - far from "good" in fact I'm having my share of issues :)
04:14:59 <jips> i'm trying to make tetris and i have no idea how to do it
04:15:43 <Saulzar> Yeah, I think that's a problem with using Yampa to structure a game... it's just hard to see where to start
04:16:16 <Saulzar> The space invaders paper has a reasonable framework for some basic management of some game entities 
04:16:22 <basti_> well, obviously, at with a wokring primitive input -> output thing
04:16:36 <jips> with tetris i don't think i need any switching
04:16:54 <Saulzar> Hmm, you have bricks .. and of course the brick stack
04:17:05 <Saulzar> You can turn bricks (state), and bricks accumulate on the stack (state)
04:17:30 <jips> yeah, i think i only need one main recursive signal function that loops back the value of the stack
04:17:39 <Saulzar> Bricks connect with the stack (events)... which trigger reductions and manipulate the state
04:18:02 <Saulzar> Hmm
04:19:10 <Saulzar> I've had real issues with doing collisions in Yampa, the delay mechanism seemed to make it really hard to get stable
04:20:40 <jips> well, i will use repeatedly to make "fall" events. when the brick signal function gets a fall event it will immediately check for a collision in the next row. if there is one then it adds the brick to the value of the brick stack and sends an event back to itself to drop a new brick
04:20:48 <Saulzar> Not sure if it's just my misunderstanding, but I'm going to make a seperate collision resolver
04:22:06 <jips> do you think that what i said will work?
04:22:11 <Saulzar> Hmm
04:22:42 <Saulzar> Might be a problem for the brick signal function to do that, unless it also holds the stack state...
04:23:32 <jips> yeah, that's the idea
04:23:51 <Saulzar> Hmm..
04:24:13 <jips> problem is, i'm not even sure yet i know how to simply make a brick fall at a fixed interval :O
04:24:14 <Saulzar> Ah - there is only ever one brick, I guess that works
04:24:37 <Saulzar> You can do it with holdAccum
04:24:47 <Saulzar> Er, rather accumHold - one of those :)
04:27:34 <Saulzar> I think tetris should work really well
04:29:08 <jips> one part of the system i am happy with myself about is the "fall" event. i will do it by having to signalFunctions, "fallSF" and "turboFallSF", then i will have a signalFunction that checks if the turbo input key is pressed and routes the appropriate event source to the brick signal funtion :D
04:30:42 * shapr boings cheerfully
04:30:45 <Saulzar> Hehe. The periodic events look nice
04:31:16 * shapr wants Yampa Mindstorms
04:31:46 <earthy> hm. now... if I were to have  f . (| phi \/ psi |) = (| (f . phi) \/ (f . psi) |)...
04:32:14 <earthy> that seems innocent enough
04:33:23 <Saulzar> Despite the physics they put in their papers I get the feeling Yampa works best for discrete stuff
04:42:36 <shapr> Saulzar: John Hughes experimented with the other half recently, whichever one Yampa doesn't do.
04:42:50 <shapr> I forget his results, but I have some demo code he sent me.
04:46:09 * shapr can't find it immediately though.
04:46:33 <tromp_> i wrote a tetris in C once...
04:46:34 <Saulzar> Hmm, Yampa is meant for continuous stuff
04:46:42 <tromp_> kinda obfuscated;)
04:47:17 * shapr is afraid
04:50:18 <Saulzar> I used to write games in C without knowing what pointers were :)
04:51:30 <jips> everyone wrote a tetris in C once :P
04:51:41 <Saulzar> In some ways it made a lot of things easier, just to "get the damn thing done" .. without fussing about how :)
04:51:49 <basti_> i wrote tetris in basic.
04:51:51 <basti_> >-<
04:52:03 <Saulzar> I've never written tetris in C
04:52:20 * stesch wrote a BBS in C. Those were the days ...
04:52:25 <JKnecht> has a Yampa mindstorm in mind. 
04:52:51 <Saulzar> Games are the greatest thing for motivation
04:57:12 * JKnecht hmmm (thumbs yellow paperback copy of Paperts original) Logo in Haskell ...
05:01:37 <tromp_> http://www.cwi.nl/~tromp/tetris.html
05:02:17 <JKnecht> well it is was colored yellow, but s/yellow/yellowed/
05:11:51 <Lemmih> ADEpt: pong.
05:14:04 <jips> whoah that shit actually works
05:15:42 <Saulzar> jips, Success?
05:15:52 <jips> Saulzar: no, i mean that obfusicated tetris
05:17:41 <Saulzar> It has a bug, I made a hole in the floor ;)
05:23:42 <Iome> . . . . ö..ö.. .--
05:23:47 <Iome> . . . . ö..ö.. .--t: 8,10,11,14,15,16,17]
05:23:48 <Iome> [#haskell] . . . . ö..ö.. .--
05:26:57 <Lemmih> Iome: eh?
05:27:07 <Iome> sorry, my kid
05:27:34 <tromp_> ah, got to get them started young...
05:29:25 <ADEpt> Lemmih: so, what was decided about repo?
05:31:01 <Lemmih> ADEpt: We go with a central one on scannedinavian.
05:35:28 <ADEpt> will you checkpoint it pleeese, because patches take 46K of history each? :)
05:41:25 <boegel> your kid knows how to type Ã¶ ? impressive :)
05:41:43 <cm> Ã¶Ã¶
05:41:45 <cm> i know, too!
05:44:54 <Lemmih> ADEpt: done.
05:51:04 <Lemmih> ADEpt: What parts are you hacking on, OOI?
05:54:06 <ADEpt> Lemmih: first, I want to remove old docs and code. Then, it depends on what you and SamB are hacking on. I though that adding a "serving" part would be a nice (and small) addition.
05:59:28 <Lemmih> Serving as in uploading?
05:59:44 <ADEpt> Lemmih: yes, exactly
05:59:50 <ADEpt> Lemmih: do we send patches to the list?
06:01:24 <Lemmih> Is that better than sending them to me?
06:02:15 <ADEpt> Lemmih: not if you apply fast :) Jlouis was known for not applying for 4-5 days sometimes ...
06:04:09 <pesco> Hey there.
06:05:12 <ADEpt> Lemmih: oh. fat messages do not go to the list immediately. I'd rather send to you.
06:05:20 <pesco> I'm wondering, what is the exact advantage of IntMap a over Map Int a?
06:06:38 <Lemmih> SamB: I'm a list moderator? If so, what's my password?
06:06:59 <Lemmih> pesco: Speed.
06:07:08 <pesco> Lemmih: How?
07:21:04 <jips> anyone know how i can disable depth testing in haskell opengl?
07:22:46 <Saulzar> depthFunc $= Nothing
07:24:10 <jips> danke
07:24:19 <chucky> gah, why does Cabal tell me my package isn't buildable even though my package.buildinfo is full of lines saying "Buildable: True" about different executables?
07:27:20 <jips> how do i make an infinite list with a value for all elements?
07:27:37 <davidw> jips, repeat x
07:27:43 <jips> danke sehr
07:27:47 <jips> @repeat Nothing
07:27:48 <lambdabot> Unknown command, try @listcommands.
07:27:54 <jips> > repeat Nothing
07:27:56 <lambdabot> Add a type signature
07:28:12 <jips> > (repeat Nothing) :: ([Maybe Int])
07:28:14 <lambdabot> [Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,
07:28:14 <lambdabot> Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,
07:28:14 <lambdabot> Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,
07:28:14 <lambdabot> Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,
07:28:14 <lambdabot> Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,
07:28:17 <lambdabot> [24 @more lines]
07:29:01 <sproingie> whole lotta Nothing going on
07:29:28 <chucky> :)
07:31:54 <jips> anyone know how i'm supposed to use accumHold function in yampa?
07:32:04 <joelr1> howdy
07:32:11 <Jaen> O I got plenty o' nuttin' an' nuttin's plenty for me...
07:32:18 * Jaen sings
07:32:45 <joelr1> SamB: do you still want erlang tutorials :-)
07:33:01 <Saulzar> jips, It takes an intial value and events with a transition ...
07:33:56 <Saulzar> There's a good document around detailing all the switches and whatnot
07:34:48 <Saulzar> "Arrows, Robots, and Functional Reactive Programming"
07:35:04 <joelr1> Saulzar: that's the lecture notes, right? 
07:35:04 <sproingie> does that teach arrows reasonably well?
07:35:09 <Saulzar> joelr1, Yeah
07:35:13 <joelr1> Saulzar: another good one is The Yampa Arcade
07:35:19 <Saulzar> Yep
07:35:51 <Saulzar> sproingie, I think it is less about arrows and more about Yampa
07:35:53 <joelr1> yampa does not seem to be maintained anymore
07:36:15 <sproingie> are there any arrow tutorials?
07:36:29 <Saulzar> There's a bunch listed on the haskell wiki..
07:36:29 <sproingie> the arrows page on haskell.org is shamefully opaque
07:37:52 <Saulzar> Hmm, I had a look on the Yampa mailing list posts of this year - not sure it's entirely unmaintained, certainly not actively developed
07:38:12 <joelr1> right
07:38:18 <jips> yeah! my tetris brick falls!
07:38:24 <Saulzar> Cool :)
07:38:26 <joelr1> the list is another thing altogether. 1 post a month if you are lucky :(
07:38:55 <joelr1> jips: what are you using for display? opengl?
07:39:00 <jips> joelr1: yeah
07:39:21 <Saulzar> I guess there are more users around here than anything... and we're certainly not experts :)
07:39:45 <joelr1> Saulzar: have you done anything complex with yampa?
07:40:24 <Saulzar> Not really. I'm writing a little AI game with the robots controlled using Yampa, but most of the code is non-Yampa as yet
07:40:53 <joelr1> Saulzar: i want to do something like that but my feeling is that yampa is too complex
07:41:24 <joelr1> Saulzar: and i wonder if that's the reason why development of it stopped. a nice research project that proved impractical in real-life
07:42:13 <jips> i think it's just that the world isn't yet ready for yampa :P
07:42:15 <sproingie> worked for frag
07:42:27 <sproingie> of course i can't puzzle out line one of frag's code
07:42:29 <Saulzar> Yeah, maybe... 
07:43:24 <sproingie> game code in general with stuff like quaternions hurts my head
07:43:46 <Saulzar> I've had some troubles with it - collision detection doesn't seem fun with a delay
07:43:57 <Saulzar> Rather, collision response
07:44:28 <sieni> what's wrong with quaternions?
07:44:58 <Saulzar> Was thinking maybe embed or something is the way to do it, but I've just gone with the seperate non Yampa solution..
07:45:03 <sproingie> nothing except for my math-illiteracy
07:45:28 <boro_> Anyone have mirc script, that scans users hosts ? Someone can scan for .ee ?
07:45:48 <sproingie> i could probably grok quaternions if i just knuckled down and wrote some opengl tutorial code with 'em
07:46:22 <jips> the trick to quaternions is knowing that you don't have to understand them to use them :)
07:46:28 <Saulzar> sproingie, You don't have to understand them to make use of them either
07:46:29 <sproingie> an interactive applet i could use to play with 'em would probably be helpful
07:46:56 <sproingie> jips: i'm finding that's the case with a lot of haskell too.  unfortunately i never managed to learn top-down
07:47:44 <jips> argh i can't seem to get the brick to move left and right
07:48:08 <sproingie> i have this wacky idea of creating a mud or roguelike in haskell, but i keep fearing i'd end up just recasting OO code into a functional dialect
07:48:24 <sproingie> and just get frustrated by it.  so i wonder what a functional mud would look like
07:49:37 <jips> alright got it working!
07:49:38 <sieni> the point was something like that the unit quaternions are isomorphic to the universal covering group of SO(3), the 3 dimensional rotations
07:49:59 * sproingie .o( replicateM_ 5 (mon bites) >> die )
07:51:59 <Saulzar> Hmm, I think a haskell mud could be quite elegant
07:52:23 <sproingie> i suspect when creating simulations that you can extend with virtual objects modelled after real-world objects (swords, doors, rocks, etc) that some degree of OOP is pretty natural and unavoidable?
07:53:01 <sproingie> i'm not an anti-OOP guy by any means, but i don't want to do the same old thing in a new language
07:53:04 <sieni> it's a similar thing as the fact that you can represent a planar rotation with an angle
07:53:44 <sproingie> sieni: so what's the fourth?  magnitude of all the rotations?
07:53:47 <Saulzar> sproingie, Perhaps... but I guess you'd find different ways to structure it
07:54:30 <Saulzar> You could even use Yampa for AI :P
07:54:37 <sproingie> ow my brane
07:54:56 <sproingie> i'll stick with simpler things for the time being
07:55:24 <sieni> sproingie: there isn't any other point that you have a natural mapping from quaternions to 3d rotations, like there is a natural mapping from real numbers to 2d-rotations (i.e. rotation by the angle specified by the real number)
07:56:19 <Saulzar> joelr1, Ah, I see you posted to the mailing list and received huge response!
07:56:42 <sieni> (the covering is also known as SU(2), i.e. 2-dimensional special unitary group)
07:57:06 <sproingie> Saulzar: i suppose at the level of the simulation, it'd all be OO, but i could perhaps express complex interactions (say, all the effects of a fireball going off and torching monsters, doors, inventory, player) more elegantly
07:57:40 <Saulzar> sproingie, How you structure it is probably more up to you and the requirements rather than language constraints
07:57:44 <joelr1> :)
07:57:52 <joelr1> Saulzar: the yampa mailing list surely
07:58:16 <joelr1> i was bashing yampa here last night
07:58:23 <sproingie> well the idea is to play with what the language does best
07:59:02 <sproingie> being turing complete and all, everything's possible, just some things may be more fun
07:59:07 <joelr1> i think that the stuff that yampa does can be much simpler done with an event-driven architecture. but since haskell is so unfriendly when large numbers of events are concerned i resolved to do it in something other than haskell/yampa
07:59:33 <joelr1> it being making really intelligent monsters and outfitting them with sound/movement/light sensors
07:59:43 <Saulzar> Hmm.
08:00:00 <sieni> sproingie: read the wikipedia article, it looks nice: http://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation
08:02:42 <sproingie> sieni: looks good, bookmarked in my future reading list
08:03:23 * sproingie is on a long break from "learn 3d graphics" mode and back into "learn haskell" mode (again)
08:04:45 <sproingie> i guess i should just kill two birds with one stone and learn HOpenGL 
08:05:18 * jips is a graphics master and is interested in doing serious games in yampa
08:05:39 <joelr1> jips: why yampa? are you a haskell master yet?
08:05:47 <jips> joelr1: no, i'm a haskell super newbie
08:06:04 <joelr1> jips: how are you doing with yampa so far?
08:06:04 <jips> yampa appears to be the only way to do animation in haskell
08:06:20 <joelr1> jips: how many events do you have?
08:06:26 <jips> joelr1: so far so good.... slow progress but i'm moving along
08:06:31 <Saulzar> Hmm.. the only?!
08:06:45 <joelr1> jips: how many events do you have, though?
08:06:52 <jips> joelr1: one
08:07:08 <jips> joelr1: i'm only just beyond the stage of having shapes follow the mouse cursor :)
08:07:09 <joelr1> jips: hmm... no left-right button events yet? or up/down? ok
08:07:11 <jips> working on tetris now
08:07:42 <jips> joelr1: well for my tetris my input signal is: event for left,right,rotate buttons, and a bool signal for down button
08:08:10 <davidw> have you guys seen the new scripting system in the latest Unreal engine? it's a graphical dataflow language
08:08:15 <jips> Saulzar: what else is there?
08:08:58 <jips> davidw: i've missed it :( i've been off the grid for 9 months
08:09:00 <Lemmih> Can't you do animations why any graphics library?
08:09:04 <joelr1> Saulzar: how would you add sensors to a bot in yampa?
08:09:08 <Saulzar> Well, I guess there is plain haskell. I guess you mean the only attempt at structuring animation..
08:09:26 <joelr1> davidw: is it publicly available?
08:09:26 <jips> you guys talking about an animation loop in IO monad?
08:09:31 <joelr1> davidw: can i use it now?
08:09:54 <davidw> joelr1, I don't know.. but I guess it will become publicly available if it isn't already
08:10:30 <Lemmih> jips: Ah, so you meant Yampa is the only EDSL for doing animations in Haskell.
08:10:37 <Saulzar> joelr1, Hmm, well I'm passing in a record for inputs - and having 'getters' which provide events from that
08:10:54 <jips> Lemmih: yeah i guess so
08:10:55 <Saulzar> But I'm not sure what you mean by "Adding"
08:11:11 <joelr1> Saulzar: when do you query the inputs, though? in the signal function?
08:11:32 <joelr1> Saulzar: well, i want to have a bot that can see and hear, right? and do things 
08:11:36 <Saulzar> I provide signal functions from inputs to an event
08:11:54 <davidw> joelr1, it is called "Kismet"
08:12:12 <joelr1> Saulzar: the thing is that i find the yampa model too complex. i think the same thing can be easier modelled if each sensor was an event source that emitted events 
08:12:26 <joelr1> davidw: what do you mean? i thought that was something from war driving?
08:12:40 <joelr1> davidw: having to do with wifi that is
08:13:08 <davidw> joelr1, aha.. well that's the name of the scripting system I was talking about
08:13:40 <Saulzar> joelr1, Hmm, I don't think it's too bad - how many event sources do you need?
08:13:44 <joelr1> Saulzar: i.e. the sensors are event sources that emit events, something grabs those events and updates the world map. the brain registers interest in certain events to act when someone gets close or footsteps are heard nearby
08:13:52 <joelr1> Saulzar: now, how would you do this in yampa
08:14:08 <Saulzar> Hmm..
08:14:21 <joelr1> Saulzar: i think you would need scores of events for a game. the events from the sensors are a a small part. i think.
08:14:41 <joelr1> Saulzar: sort of like defending a ship from missiles
08:15:28 <davidw> http://www.unrealtechnology.com/screens/kismet_1.jpg <- looks kinda cool.. I wonder how it compares to yampa
08:15:36 <joelr1> Saulzar: sensors scan the horizon for missiles and the missile control asks to be notified when missiles are within range. you certainly want to update the displays when missiles are detected out of range but you won't do anything about them until they come within range. so no need to notify the firing center until a missile is in range
08:16:11 <joelr1> davidw: looks  like a loosing propositions :D
08:16:12 <Saulzar> joelr1, Well I guess you can use things like accumHold to update state (refering to your "updates the world map" thing)
08:16:15 <jips> http://www.gamesindustry.biz/content_page.php?aid=7189
08:16:20 <joelr1> davidw: proposition :)
08:16:43 <davidw> joelr1 ;)
08:16:53 <joelr1> Saulzar: but how do you model the notification when missiles come within range?
08:16:58 <davidw> anyway, they might be on to something
08:17:07 <joelr1> Saulzar: you would need to map a signal into another signal probably, right?
08:17:23 <joelr1> Saulzar: where a signal here's a missile becomes a missile-within-range signal 
08:17:40 <Saulzar> Right, I suppose so...
08:18:15 <joelr1> Saulzar: i think that example might be too simple. consider another
08:18:37 <joelr1> Saulzar: you have a monster that hears someone behind and sees someone ahead 
08:18:56 <joelr1> he also has a wall on the 3d side
08:19:07 <joelr1> and there's only one way out which is sideways 
08:19:10 <Saulzar> The other thing to note is that although Yampa can be used to hold state, it's perfectly feasable to combine parts of "pure" code with Yampa code
08:19:37 <joelr1> but you cannot determine that you need to go sideways until you figure out that someone is behind and close and someone is ahead and close and there'a wall on in the 3d direction
08:20:07 <Saulzar> Right well clearly you can't make simple decisions based on switching there
08:20:12 <Saulzar> You need some kind of pathfinding
08:20:31 <joelr1> Saulzar: so i'm wondering if the yampa model breaks down here
08:20:51 <joelr1> Saulzar: obviously in the signal that determines what events to emit (i.e. where to go) you can analyze the world map
08:21:00 <Saulzar> But you can switch to a new target destination for example...
08:21:14 <Saulzar> Hmm
08:21:38 <joelr1> Saulzar: but do you think it's too complex to do with yampa? would it be simpler to model the brain, sensors, etc. as event producers and consumers?
08:22:14 <jips> joelr1: try playing around with yampa for a bit to get a feel for it
08:22:45 <joelr1> jips: certainly
08:22:48 <Saulzar> I'm not completely convinced myself (about the merits of Yampa), but I do see that the state is useful - but of course you get state for free in some other languages :)
08:22:58 <joelr1> jips: the best way to do that is to look at frag :D
08:23:07 <jips> no, that would probably be the worst way :P
08:23:07 <joelr1> jips: i did that and i could barely make anything out
08:23:43 <Saulzar> I don't think Frag is nesescarily the epitome of good coding style
08:23:57 <joelr1> jips: why the worst way? it represents a real-life app
08:24:18 <davidw> i hope you are looking at the .as files and not the desugared files in frag :)
08:24:55 <Saulzar> Just looking at "ObjectBehaviour.hs" there is something like 20 levels of nesting
08:24:57 <joelr1> davidw: hmm... no, i was looking at the *hs files. i think you don't need to desugar anything of you pass -farrows to ghc
08:25:04 <jips> Saulzar: ok i'm using accumHold to make the brick fall and move left and right, but i have no idea now how to do horizontal collision detection with the walls and the stack
08:25:05 <Saulzar> Ohhh
08:25:11 <Saulzar> He's using .as 
08:25:20 <Saulzar> No wonder
08:25:29 <davidw> I made that mistake myself at first
08:25:48 <joelr1> hmm
08:25:51 <joelr1> how interesting
08:25:57 <joelr1> so who produces *hs from *as?
08:26:19 <Saulzar> arrowp used to, apparently - but now it's built into ghc
08:26:40 <joelr1> let me search for *as in other files
08:26:50 <joelr1> because you compile the whole thing with --make and that's it
08:27:18 <joelr1> aren't you supposed to just copy the as to hs?
08:27:23 <joelr1> and compile with -farrows?
08:27:40 <Saulzar> Yeah
08:27:41 <lennart> Howdy from 37000 feet :)
08:27:56 <Saulzar> But apparently he has provided un-arrow'ed hs files already
08:28:01 <joelr1> let me do a quick experiment by checking out another repo and blowing away hs where there is as
08:28:05 <joelr1> lennart: how so?
08:28:13 <joelr1> lennart: flying virgin with internet on board?
08:28:15 <chucky> lennart: Cool, which air carrier?
08:28:23 <lennart> Lufthansa
08:28:34 <joelr1> lennart: isn't that expensive? :) i mean the internet
08:28:45 <jips> he can afford it
08:28:58 <lennart> normally it's $25 for the whole flight
08:28:58 <chucky> lufthansa are pretty expensive to begin with
08:29:08 <joelr1> is lennart a haskell millionaire? :D
08:29:13 <lennart> but i've used it enough that I have a free one
08:29:17 <joelr1> lennart: oh, that's awesome!
08:29:30 <joelr1> lennart: how is the speed?
08:30:09 <lennart> hang on, battery problem
08:30:26 <jips> i'm guessing around 700 mph
08:30:51 * joelr1 is almost done checking out another frag repo
08:31:01 <joelr1> dang, i should have just copied the directory :D
08:31:17 <kolmodin> jips: :D
08:31:35 <joelr1> so he does supply the as and the hs
08:31:42 <joelr1> lets blow away the hs and rename as to hs
08:33:13 <davidw> hi kolmodin, what's up?
08:33:28 <kolmodin> davidw: hi
08:33:33 <kolmodin> davidw: nothing much
08:33:50 <kolmodin> configuring darcsweb
08:34:04 <davidw> aha
08:34:15 <davidw> kolmodin, got some cool project to put there? :)
08:34:35 <kolmodin> heh, no, only projects of others :)
08:34:51 <davidw> hm, ok
08:34:58 <davidw> who?
08:35:20 <kolmodin> conjure, gentoo-haskell... etc, only for local use
08:35:27 <davidw> aha, ok
08:35:29 <Saulzar> joelr1, The day after I looked at Yampa I came on here and slagged it off also :)
08:35:46 <joelr1> Saulzar: and then?
08:36:41 <jips> argh, this yamp tetris is pretty tough :\
08:36:42 <Saulzar> It made a tiny amount of sense, so I stuck at it. Of course I'm not doing anything deadly serious.
08:36:57 <jips> maybe i'll skip it and jump straight to sci-fi mmorpg
08:37:03 <joelr1> Saulzar: did you have many events yet?
08:37:03 <Saulzar> :P
08:37:08 <kolmodin> davidw: any interesting projects going on?
08:37:40 <davidw> kolmodin, not really. I wrote an HM type inferencer for my compiler
08:38:35 <kolmodin> davidw: ah, ok
08:38:56 <Saulzar> joelr1, No, I really haven't got into that much. Very simple of now. My robots can do virtually nothing, sense current heading, position and that's it.
08:39:59 <SamB> Saulzar: why can it sense heading?
08:41:00 <Saulzar> a) It's not realistic b) It's not even close to final... just something to test with, otherwise they can't sense _anything_
08:41:01 <lennart> joelr: so the best speed I've managed on the downlink is about 256kb/s
08:41:04 <SamB> Saulzar: that isn't terribly common in hobbyist 'bots, afiact
08:41:21 <joelr1> lennart: still pretty fast
08:41:27 <joelr1> for a plane
08:41:36 <kombinator> hello, CosmicRay
08:41:50 <lennart> i can sometimes listen to streaming mp3s from my server at home :)
08:41:57 <CosmicRay> good morning
08:41:59 <Saulzar> SamB, I have no idea about what real robots do - but these robots need to be fairly accurate too... if they're going to shoot other robots!
08:42:02 <kombinator> I'm studying HDBC API
08:42:10 <lennart> which is rather amazing, really
08:42:15 <joelr1> SamB: since you were interested in erlang tutorials check out the latest post in my blog. http://wagerlabs.com
08:42:22 <kombinator> and I've got 2 questions/points
08:42:28 <CosmicRay> kombinator: I'd be happy to help
08:42:41 <Saulzar> I only intend to have a very few sensors in the end - as simple as possible, enough to sense other robots, sense the walls (rotatable sonar or something) and ability to shoot torpedoes at other robots
08:42:51 <SamB> shooting other robots requires a compass since when?
08:42:56 * joelr1 is glad to announces that moving Game.as to Game.hs and adding -farrows works!
08:42:59 <joelr1> like a charm
08:43:25 <SamB> Saulzar: how do you reload the missles?
08:43:25 <Saulzar> Well, would need relative positions at least
08:43:32 <Saulzar> It's free :)
08:43:54 <SamB> (missle being a generic term for things that are hurled through the air at things)
08:44:09 <kombinator> it's a little asymmetric that fetch* don't get positional parameters like other query actions
08:44:22 <kombinator> or is it intentional?
08:44:42 <CosmicRay> kombinator: well, by the time to get to fetchRow, the query has already been executed.
08:44:50 <Saulzar> Any 'chore' task I think unnesescarily complicates things
08:44:54 <CosmicRay> kombinator: let's step back and look at the flow a bit...
08:45:01 <jips> hm... i can't seem to get the falling tetris brick to do collision detection with the left and right walls
08:45:04 <CosmicRay> kombinator: say you want to run 'SELECT * from foo where bar = ?'
08:45:22 <CosmicRay> kombinator: you'll first prepare conn "SELECT * from foo where bar = ?" [toSql "hi"]
08:45:25 <CosmicRay> err
08:45:25 <kombinator> my bad, it seems that I didn't understand it
08:45:30 <CosmicRay> kombinator: you'll first prepare conn "SELECT * from foo where bar =?"
08:45:41 <CosmicRay> kombinator: then you'll execute sth [toSql "hi"]
08:45:58 <CosmicRay> kombinator: then you fetchRow a bunch of times.  Each call to fetchRow retrieves one row of tesult back from the database.
08:46:09 <CosmicRay> because there may be 5 rows where bar = "hi".
08:46:12 <CosmicRay> does that make sense?
08:47:07 <Saulzar> jips, You'll need to do some kind of switcher on the left/right Events I guess. Or some kind of generic  "constrained move" function,  brick -> move -> brick
08:47:49 <kombinator> I thought that statement means just a query
08:47:52 <jips> yeah, that's sort of what i was thinking but this stuff just makes my head heart and i think i'll go watch some tv
08:48:20 <kombinator> but it seems that it's a cursor (in other dbc terminology)
08:48:52 <CosmicRay> kombinator: it is similar to a cursor, but not exactly.  it's more a prepared query.
08:48:55 <CosmicRay> let me show you two examples.
08:49:02 <CosmicRay> blah2 = do sth <- prepare dbh "INSERT INTO foo VALUES (?)"
08:49:02 <CosmicRay>            execute sth [toSql 5]
08:49:02 <CosmicRay>            execute sth [toSql 6]
08:49:11 <jips> man... when i was 6 years old i was able to make a breakout game in basic and now i can't even make tetris :'(
08:49:11 <CosmicRay> this one shows the real power of positional parameters.
08:49:16 <kombinator> so I can fetch rows from 2 different queries at the same time using one connection?
08:49:31 <CosmicRay> many databases can optimize this to a great extent, making it much faster than issuing a whole bunch of queries individually.
08:49:37 <CosmicRay> blah = do dbh <- connectSomething
08:49:37 <CosmicRay>           sth <- prepare dbh "SELECT * from foo where bar = ?"
08:49:37 <CosmicRay>           execute sth [toSql "hi"]
08:49:37 <CosmicRay>           r1 <- fetchRow sth
08:49:37 <CosmicRay>           r2 <- fetchRow sth  -- ....
08:49:39 <joelr1> jips: that's cause you are trying to do it in yampa :D
08:49:42 <Saulzar> jips, I know the feeling!
08:50:01 <Saulzar> When you were 6 you weren't too fussy about style I bet
08:50:06 <CosmicRay> kombinator: that depends on the underlying database library.  Some support that.
08:50:11 <CosmicRay> I know PosgreSQL does.
08:50:20 <CosmicRay> the safe thing is to establish multiple connections.
08:50:48 <SamB> jips: try using an MArray instead?
08:50:55 <jips> hm...
08:50:55 <CosmicRay> kombinator: note also the quickQuery function.
08:51:05 <jips> @where MArray
08:51:06 <lambdabot> I know nothing about marray.
08:51:09 <SamB> more like BASIC that way ;-)
08:51:13 <Saulzar> MArray in Yampa ? I'm guessing it's not going to work :)
08:51:18 <CosmicRay> kombinator: if you are just going out and running one select, this function handles all the internal details of prepare, execute, fetchAllRows.
08:51:34 <CosmicRay> kombinator: also note that the result from quickQuery is a lazy list, so it is not slurping everything into RAM all at once.
08:51:44 <SamB> Saulzar: not in Yampa!
08:52:06 <kombinator> CosmicRay: but I should read everything before I start the next query?
08:52:26 <CosmicRay> kombinator: yes, that would be best, or you could establish two different connections.
08:52:32 <basti_> wow
08:52:37 <basti_> i got space invaders to run :D
08:52:42 <SamB> what happens if you don't read the whole list?
08:52:58 <CosmicRay> the statement will be finalized whenever the list is garbage collected
08:53:00 <Saulzar> SamB, So we go for keyboard events and moving the bricks down in Yampa, and MArray out in the IO loop for the game logic? ;)
08:53:13 <Saulzar> SamB, Frankenstein tetris...
08:53:21 <SamB> Saulzar: no, I meant to use an MArray but no Yampa
08:53:26 <kombinator> CosmicRay: and the second question: do you consider using hdbc in an interactive program>
08:53:28 <Saulzar> I'm just kidding
08:53:37 <jips> SamB: the point is that i want to use yampa :)
08:53:43 <CosmicRay> kombinator: sure, that should be no problem
08:53:56 <SamB> jips: perhaps you should try Asteroids instead
08:54:01 <SamB> that uses vector graphics ;-)
08:54:09 <kombinator> but having nonblocking operations would be nice then
08:54:28 <jips> i think asteroids will be harder then tetris
08:54:34 <SamB> oh?
08:54:39 <SamB> I don't think so!
08:54:56 <CosmicRay> kombinator: you don't need separate nonblocking calls in Haskell; you can juse use forkIO!
08:54:57 <kombinator> or, maybe I could simulate nonblocking operations using GHC's multithreading primitives?
08:55:02 <kombinator> yes, right
08:55:07 <CosmicRay> s/juse/just/
08:55:15 <SamB> CosmicRay: do you mean forkOS?
08:55:15 <Saulzar> Maybe about the same...
08:55:27 <CosmicRay> note that I learned yesterday that I need to make a tweak to the FFI calls to make this work
08:55:36 <joelr1> Saulzar: question
08:55:40 <CosmicRay> SamB: if I understand simon correctly, no, but I may not be understanding him correctly.
08:55:45 <SamB> oh, that kind
08:55:58 <CosmicRay> though of course forkOS would do it too.
08:56:10 <SamB> the kind that for some reason get their own thread...
08:56:19 <joelr1> Saulzar: in Objects.hs, is it true that you can create ObjInput with _all_ the fields populated?
08:56:39 <Saulzar> Frag?
08:56:47 <joelr1> Saulzar: of course
08:57:55 <Saulzar> Why not?
08:58:18 <joelr1> Saulzar: dunno, it just seems that i would have separated those into individual constructors
08:58:43 <kombinator> CosmicRay: so GHC runtime will be able to preempt HDBC's call to C lib any time?
08:58:51 <Saulzar> Not sure I understand your question?
08:59:04 <CosmicRay> kombinator: my understanding is that it will.
08:59:13 <CosmicRay> well, not necessarily preempt it, but run it in its own thread
08:59:38 <joelr1> Saulzar: i was just wondering why he made input events fields in a record as opposes to records themselves
08:59:48 <SamB> presumably the OS will do the pre-empting...
08:59:58 <CosmicRay> kombinator: you don't generally see nonblocking calls in Haskell since that detail is handled internally after you use forkIO or forkOS
09:00:17 <Saulzar> Hmm
09:00:53 <Saulzar> I see, I guess there's no need unless the event has particular data associated with it - he's just passing the object state as a whole by the looks of it
09:01:50 <Saulzar> One thing I found really annoying about that though, is that all the data structures end up inter-dependant
09:02:01 <Saulzar> So it's probably much better to create some abstraction...
09:02:36 <joelr1> Saulzar: i'm reading through the yampa lecture notes and it just seems to me that you need to be VERY careful with the way you approach the design. that is if you want things to stay neat
09:02:56 <joelr1> the way they describe the temperature alarm, the alarm count, that's all extremely neat
09:03:18 <Saulzar> I don't like the huge Union structure
09:03:33 <joelr1> Saulzar: i think HList is the only way around it
09:03:46 <joelr1> Saulzar: it's haskell, it doesn't have to do with yampa
09:03:59 <SamB> do you mean HSum?
09:04:04 <joelr1> HList
09:04:06 <Saulzar> Well, each object can keep it's own state without the Union ... 
09:04:08 <joelr1> the package
09:04:14 <joelr1> Saulzar: really? how so?
09:04:27 <Saulzar> Though if you need them to interact I guess you need output the state
09:04:39 <Saulzar> Signal functions can be stateful
09:04:41 <joelr1> Saulzar: right
09:04:45 <SamB> what if the objects were represented by functions?
09:05:03 <joelr1> Saulzar: but if you design them properly i suppose you don't need to output the whole state, maybe just a portion
09:05:11 <Saulzar> Yeah..
09:05:56 <bringert> anyone know of an existing Haskell implementation of the Knuth-Morris-Pratt string searching algorithm
09:05:57 <Saulzar> I have my program output some stuff about physics, stuff to draw etc. No details
09:06:10 <bringert> there was a long thread talking about it a while back, but I can't seem to find the code
09:06:25 <SamB> bringert: whats special about that algorithm?
09:06:31 <Saulzar> Stuff which is specific (which needs to go to the robot controller - for sensors) I shove in a Dynamic... I thought it was the cleanest way
09:06:49 <SamB> bringert: it would probably not work on Strings
09:07:03 <joelr1> Saulzar: hmm
09:07:05 <bringert> I want to use it on FastStrings
09:07:20 <SamB> ah
09:07:23 <Saulzar> As I have to have a layer of IO to police the controllers..
09:08:16 <SamB> wouldn't it be better to output Pictures ?
09:08:24 <SamB> or something like them?
09:09:29 <SamB> of course, you'd need to know what stuff would colide and what would not...
09:09:51 <SamB> and if you have doppler you'll need velocity vectors...
09:09:55 <Saulzar> Hmm, I do - well outputs a list of some graphical primitives
09:11:00 <SamB> oh, and you'd need to also make it possible to tell what would be seen from the side and what would be seen from above...
09:11:34 <Saulzar> I have ended up making all the physics external anyway...
09:12:02 <SamB> hmm.
09:12:21 <Saulzar> Collisions with a delay seems nasty
09:12:31 <Saulzar> Not sure how to make it stable
09:12:39 <SamB> delay, huh?
09:14:05 <Saulzar> When using a recursive signal function it needs an "infintesimal delay" otherwise it <<loop>>'s
09:15:31 <Saulzar> and recursion is the way you keep state, in any case to do it properly I think collisions need resolving at a finer level than the default timestep
09:15:51 <Saulzar> But I'm not doing it the most simple way... 
09:15:52 <basti_> are Yampa SF's to be resolved by proc?
09:16:08 <Saulzar> How'd you mean?
09:16:15 <basti_> there is this proc construct for arrows
09:16:25 <Saulzar> Yeah, Yampa SF's are arrows
09:16:35 <basti_> do i need this to process yampa sf's, or does yampa bring its own
09:18:10 <Saulzar> I think it is the easiest way, you can use the primitives >>> etc. but it's not great for bigger functions
09:18:14 <greenrd> What are the most useful applications of arrows, outside of parsing?
09:18:38 <basti_> arrows are more general than both Monads and Comonads
09:18:49 <basti_> that might be important, since Comonads are streams
09:29:00 <Cale> streams are comonads, but I don't know if I'd be quite willing to put it the other way around
09:29:27 <Cale> I suppose that to every comonadic value, one can associate a stream
09:29:33 <Cale> but you might be losing information there
09:29:44 <basti_> uhmm
09:29:55 <basti_> yes you got me right ^^
09:31:45 <franka> Hey, look, my good friend Cale is here!
09:31:55 <franka> Cale, teach me some Haskell!
09:32:09 <Cale> franka: hehe :)
09:32:24 <Cale> I'm not sure if I could, quite frankly :)
09:33:18 <franka> Cale, what sort of ingredients do you need to put in Haskell's curry?
09:33:34 <Cale> heh
09:33:42 <Saulzar> Tuples?
09:33:43 <Cale> lamb, and raisins
09:33:59 <int-e> rice
09:34:08 * int-e wants rice.
09:34:16 <int-e> > curry rice
09:34:17 <lambdabot>  Not in scope: `rice'
09:34:18 <int-e> :(
09:36:16 <Cale> oh, yeah, you gotta have rice
09:36:51 <chucky> stew = curry . rice . chicken
09:38:32 <basti_> how do I "run" an arrow again?
09:39:15 <Saulzar> That is specific to the arrow
09:39:19 <basti_> ah
09:39:22 <tromp_> doesn't that require a bow?
09:39:28 <basti_> that might be the reason why i didnt find out
09:39:39 <franka> And I never understood those Doodad thingies.  I mean, is every Sphincter a Doodad, or is every Doodad a Sphincter?
09:41:33 <jips> this is sweet: http://bastilleweb.techhouse.org/photos/4.1_mf_nintendo_controller.jpg
09:47:17 <dcoutts> xerox, ping!
09:47:47 <jips> what's the point of the tag function in yampa?
09:54:37 <dcoutts> @seen JaffaCake
09:54:38 <lambdabot> I saw JaffaCake leaving #haskell 15 hours, 28 minutes and 27 seconds ago.
09:58:25 <dcoutts> dons, do you know anything about ghc an non-executable stacks?
09:58:56 <dcoutts> dons, am I right in thinking that OpenBSD uses a non-executable stack for progs by default?
09:59:06 <dcoutts> and does ghc work in such an environment?
09:59:43 <dcoutts> Gentoo is apparently tring to make everything work with a non-executable stack, hence we're looking into it
10:00:00 <dcoutts> dons, I just thought you might know something about the issue.
10:02:04 <PupenoL> [OT] Is there some font that you know that provide the western musical symbols (unicode range 1D100-1D1FF: http://www.unicode.org/charts/PDF/U1D100.pdf) ?
10:19:43 <SamB> feta?
10:20:53 <SamB> it doesn't have lines, afiak, but heads and stuff like that yeah... what this stuff is even in Unicode for is beyond me...
10:22:53 <SamB> Pupeno: that was for you, btw.
10:23:01 <SamB> PupenoL, even.
10:23:47 <SamB> does anyone actually use 128th notes/rests?
10:23:48 <PupenoL> SamB: I don't know the initial motivation, but if a font implemente it, then it would solve me some problems.
10:24:29 <PupenoL> it seems I'll go the svg way.
10:24:32 <SamB> Pupeno: well, it does not implement that...
10:24:49 <SamB> but it does have the shapes you'd want
10:26:07 <PupenoL> SamB: I don't understand what do you mean.
10:26:33 <SamB> it is used by LilyPond
10:29:27 <SamB> oh wait, maybe it does!
10:30:34 <SamB> apparantly it is converted frome mf to a type1 by some roundabout process, and has the unicode codepoints and everything!
10:31:04 <SamB> anyway, if you install LilyPond, you'll get Feta also.
10:31:30 <SamB> the files are in /usr/share/lilypond/2.1.0/fonts/type1/ here.
10:32:32 <SamB> hmm, or maybe it just has names...
10:33:15 <PupenoL> SamB: thanks! that's a lead!
10:34:58 <SamB> it doesn't seem to really implement unicode, but it (with rules) is enough for reasonably good engraving
10:35:11 <PupenoL> I can't get them from charmap, maybe I need to restart X.
10:35:14 <SamB> (rules == black rectangles, usually long or thin)
10:35:49 <SamB> Pupeno: well, they probably aren't registered for that kind of thing...
10:36:10 <SamB> what are you trying to do anyway?
10:36:26 <PupenoL> SamB: http://scret.sf.net
10:37:17 <SamB> mmm
10:37:29 <SamB> what are you trying to do to it?
10:38:27 * joelr1 waves
10:38:37 <PupenoL> SamB: I am tring to stop using those horribles pngs (I am the author of that application).
10:39:07 <SamB> anyway, all this Unicode music stuff looks absolutely insane
10:39:25 <SamB> they don't deal with metrics issues at all!
10:41:11 <SamB> I suppose it might be useful to have the codepoints, though...
10:41:20 <PupenoL> I'll try to use lilypond's fonts somehow, and if not, I'll proceed to create my own svgs.
10:41:34 <PupenoL> SamB: of the unicode musical symbols ?
10:41:52 <SamB> Pupeno: heard of fontforge?
10:42:49 <PupenoL> SamB: nope, installing now (the last time I've tried to edit a font, I failed).
10:43:25 <SamB> I think it can output SVG fonts... can definately load pfa files.
10:43:41 <SamB> It will *at least* let you see what is in the font!
10:44:00 <PupenoL> yes.
10:44:02 <PupenoL> thanks.
10:44:39 <SamB> what in the world is a semiflat?
10:48:57 <PupenoL> no idea... SamB: if you are trully interested, I might look for it on my music dictionary whet I take it from my parents' house.
10:49:56 <SamB> don't go to any trouble
10:50:30 <PupenoL> I'd need it anyway... being a spanish speaker it is hard to find the english names of things in music.
10:51:24 <SamB> I mean, if you think of it, go ahead and look it up, but don't go to any trouble...
10:52:27 <SamB> lilypond defaults to dutch notation for note names ;-)
10:53:38 <SamB> hmm, looks like a semiflat is essentially half a flat...
10:53:43 <SamB> whatever *that* means.
10:55:39 <Philippa> SamB: half a semitone lower?
10:56:13 <SamB> Philippa: I suppose it must be logarithmic just like everything else
10:57:14 <PupenoL> probably to be played with some exotic ancient instrument
10:57:16 <basti_> a semiflat is the frequency of a full tone multiplied by the inverse of 24th root of 2.
10:57:25 <SamB> interesting. Apparantly lilypond adheres to 18th century accidentals by default...
10:57:41 <basti_> SamB: i think thats just the display style
10:58:02 <SamB> basti_: oh?
10:58:13 <SamB> actually, it looks like a backwards flat to me...
10:58:56 <astrolabe> Is Python functional or imperative?
10:59:29 <basti_> SamB: musical theory hasn't changed all that much since 18th century....
10:59:36 <Philippa> I'd call it primarily imperative with somewhat crappy support for functional programming
10:59:57 <astrolabe> thanks Philippa
11:00:09 <Philippa> basti_: did they know what a phantom hit is back then? :-)
11:00:14 <chucky> astrolabe: pythonists usually like to call it a "multi-paradigm language" I think
11:00:38 <Philippa> probably in response to C++ being described as the same
11:00:50 <chucky> likely, yes
11:00:59 <basti_> Philippa: >.<
11:01:09 <astrolabe> You can do functional programming in C can't you?  It doesn't make it a functional language.
11:01:30 <Philippa> you can only do FP in C with a lot of nasty (and imperative-looking) emulation work
11:01:54 <basti_> like, compiling haskell to C?
11:02:06 <Philippa> not that bad if you're happy with strictness :-)
11:02:21 <Philippa> but potentially on a par with implementing the STG machine...
11:02:24 <basti_> doesnt ghc do exactly that?
11:02:32 <chucky> astrolabe: true, but Python has syntax for doing functional programming, which C doesn't. (I'm not making a comment on whether or not you can write good functional code in Python, because I haven't tried)
11:02:37 <neologism> Philippa: do you have some nice description of stg machine?
11:02:45 <Philippa> neologism: nope. Read the paper
11:02:50 <neologism> what paper?
11:02:52 <neologism> I found none
11:02:54 <flux__> keeping track of memory allocations is the tricky part in writing functional code with C?
11:03:29 <astrolabe> I think there is an online book by SPJ that describes STG
11:03:34 <astrolabe> but I may be wrong
11:03:47 <Philippa> there's one linked to from the GHC documentation page
11:03:50 <neologism> spj is?
11:04:02 <Philippa> Simon Peyton Jones
11:04:22 <Philippa> STG = Spineless Tagless G-machine
11:04:32 <neologism> I know what stg is
11:04:39 <astrolabe> http://research.microsoft.com/Users/simonpj/Papers/slpj-book-1987/index.htm
11:05:00 <Philippa> astrolabe: I think that book predates the STG machine?
11:05:21 <astrolabe> Ah ok.  Sorry everyone :)
11:05:39 <chucky> there are some STG papers linked from here: http://www.haskell.org/ghc/documentation.html but I don't know how relevant they are.
11:09:12 <CosmicRay> chucky: I would say it's a stretch to claim that Python has a syntax for FP
11:09:26 <CosmicRay> chucky: moreover, Guido is trying to get what little FP-like features Python has removed (See PEP3000)
11:10:14 <chucky> yeah I've heard that
11:11:03 <Philippa> I'd add that most of the excuses about readability amount to "we stole it from lisp, of course it's unreadable!". I may or may not be being snarky here.
11:12:09 <astrolabe> could someone give an example of some haskell code that exemplifies functional programming awkward to translate directly to C?
11:12:34 <basti_> "directly" is a rubber term there
11:12:39 <astrolabe> sure
11:12:53 <Philippa> partial application coupled with an unusual resource pattern for the resulting closure (or closure-like thing)
11:13:09 <SamB> CosmicRay: I'm not sure I really believe Python 3000 will happen
11:13:44 <SamB> astrolabe: anything involving closures
11:14:31 <flux__> wasn't the lambda-function support in python somehow limited anyway?
11:15:03 <CosmicRay> flux__: well it works only for expressions, and in python, many things are not expressions.
11:15:20 <CosmicRay> you could say lambda x: x + 1 but not lambda x: print x
11:15:24 <flux__> I remember there was a site that demonstrated all the workarounds for expressing things inside python's lambda expressions
11:16:18 <flux__> sort of turned me off from ever thinking of looking python much further ;)
11:16:54 <astrolabe> oh no, not them again.  Full closures seemed difficult in haskell.
11:17:16 <astrolabe> They are supposed to contain information about their 'environment'
11:20:30 <MarcWeber> do={a<- [1,2,3]; True<-return (odd a); return a}
11:21:17 <MarcWeber> Can you tell me where to find the rule that True <- return True/False decides wether a is appended to the list or not? Can I find this in the list monad?
11:22:28 <Philippa> it's pattern-match failure, and fail in the list monad is []?
11:22:32 <int-e> MarcWeber: look for 'fail' - in the list monad, fail backtracks (there's a recent haskell-cafe discussion about it)
11:23:15 <MarcWeber> Thanks!
11:23:58 <MarcWeber> But I don't understand why True matches a list.. But I'll read source once again
11:24:06 <Lemmih> > do { a <- [1,2,3]; guard (odd a); return a }
11:24:08 <lambdabot> [1,3]
11:24:26 <int-e> @type guard
11:24:27 <lambdabot> Not in scope: `guard'
11:24:32 <xerox> @type Control.Monad.guard
11:24:34 <lambdabot> forall (m :: * -> *). (Control.Monad.MonadPlus m) => Bool -> m ()
11:25:05 <xerox> How's it implemented?  How can it only work on the 'explicit side effect'?
11:25:10 <int-e> > do { a <- [1,2,3]; when (even a) (fail "even!"); return a }
11:25:12 <lambdabot> [1,3]
11:25:57 <int-e> xerox: it works outside of the monad, using the monad's internal representation.
11:26:10 <xerox> > let guard p = when p (fail []) in do { a <- [1,2,3]; guard (odd a); return a }
11:26:12 <lambdabot> [2]
11:26:18 <xerox> Hm?
11:26:44 <int-e> > do { a <- [1,2,3]; when (even a) []; return a }
11:26:46 <lambdabot> [1,3]
11:27:16 <xerox> > let guard p = when (not p) [] in do { a <- [1,2,3]; guard (odd a); return a }
11:27:17 <lambdabot> [1,3]
11:27:27 <xerox> > let guard p = when (not p) mzero in do { a <- [1,2,3]; guard (odd a); return a }
11:27:28 <lambdabot> [1,3]
11:27:32 <xerox> Right?
11:27:41 <xerox> @libsrc Control.Monad
11:27:42 <lambdabot> http://darcs.complete.org/fptools/libraries/base/Control/Monad.hs
11:28:17 <xerox> guard True      =  return ()
11:28:18 <xerox> guard False     =  mzero
11:28:20 <xerox> Foo.
11:28:32 <int-e> close enough :)
11:28:43 <xerox> Well, yes :)
11:30:10 <int-e> instance MonadPlus [] where mzero = []
11:30:48 <xerox> I think in terms of when it's cool nevertheless.
11:31:02 <int-e> @libsrc GHC.Base
11:31:03 <lambdabot> GHC.Base not available
11:31:21 <xerox> It's TOP-SECRET code.
11:31:43 <int-e> it's tex-style literal haskell
11:31:57 <xerox> @code
11:31:58 <lambdabot> code module failed: Text.Regex.Posix.regcomp: error in pattern
11:32:01 <xerox> @code
11:32:02 <lambdabot> code module failed: Text.Regex.Posix.regcomp: error in pattern
11:32:17 <int-e> instance Monad [] where fail _ = []
11:32:20 <xerox> codeModule = const "code module failed: Text.Regex.Posix.regcomp: error in pattern" -- eh.
11:32:28 <palomer> @code reverse
11:32:30 <lambdabot> code module failed: Text.Regex.Posix.regcomp: error in pattern
11:32:48 <palomer> man, lambdabot should be able to give me the code!
11:33:15 <xerox> Track down the bug?
11:33:31 <int-e> @version
11:33:32 <palomer> @help code
11:33:32 <lambdabot> lambdabot 3p266, GHC 6.5.20050806 (Linux i686)
11:33:32 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
11:33:33 <lambdabot>  @code, print random line of code from $fptools
11:33:44 <palomer> fptools?
11:33:51 <xerox> Yup.
11:39:39 <orbitz> morning
11:40:03 <palomer> grr
11:40:44 <orbitz> mrr
11:41:41 <SamB> @code
11:41:42 <lambdabot> code module failed: Text.Regex.Posix.regcomp: error in pattern
11:52:06 <palomer> ok, someone explain why we need existential types for sml style modules
11:52:20 <Igloo> SyntaxNinja: What's up with darcs 1.0.5 and Debian, BTW?
11:54:11 <MarcWeber> Will go into the city now.. *have some fun* bye and ThaNKS  !
11:57:45 <CosmicRay> my land, ODBC SUCKS.
11:58:00 <CosmicRay> it is quite literally giving me a headache.  this is the most annoying C API I have ever seen.
11:59:18 <Philippa> it's worse than the win32 API?
11:59:18 <Cale> what makes it so irritating?
11:59:57 <Cale> heh, the windows GDI api in particular is pretty terrible
12:00:09 * palomer has always wondered if C is the best language to interface with hardware
12:00:24 <CosmicRay> Cale: it takes about 10 function calls to do the same thing as 1 call does just about anywhere else
12:00:46 <Cale> CosmicRay: sounds like a microsoft API :)
12:01:23 <CosmicRay> Cale: I guess I do remember some C programming to the Windows3.1 API that was even worse
12:01:26 <CosmicRay> Cale: yup ;-)
12:01:48 <CosmicRay> Cale: oh, and get this, the "connect to a remote database" function takes a Windows window handle as a parameter ;-)
12:02:07 <Cale> haha
12:02:16 <Cale> why?
12:02:24 <Cale> can you pass null?
12:02:35 <CosmicRay> yes, the unixODBC docs say "just pass null"
12:02:44 <CosmicRay> apparently in case the datbase wants to prompt for additional information
12:02:52 <Cale> haha
12:02:59 <Cale> it'll draw on that window or something?
12:03:06 <CosmicRay> it'll be a child of that window
12:03:15 <CosmicRay> that window would be the parent of the dialog box, iow
12:03:52 <jips> *slurp*
12:04:01 <Cale> MS APIs don't seem to be designed. It's more like they're grown and then standardised that way.
12:04:22 <Philippa> it's more that they're grown and standardised at random points during that growth (thus cementing it in)
12:04:23 <jips> Cale: some of the stuff in .net isn't too bad
12:04:34 <Philippa> that's because .net was a chance for a clean break
12:04:41 <CosmicRay> fetching a row of result data is approximately a 12-step process
12:04:41 <jips> yeah
12:04:47 <Philippa> give it five years and it'll be cruftier'n'RMS's underwear
12:04:58 <CosmicRay> heh
12:05:38 <jips> c# does seem to be getting more and more functional features though
12:05:50 <CosmicRay> it took me 2 days to learn the sqlite3 c api and write the hdbc driver for it.  1 day to do the same with postgres.  I'm approaching 4 for ODBC.
12:06:10 <Philippa> yeah, eventually C#'ll be a functional language only without the ability to prove anything because it'll be full of back doors
12:06:30 <CosmicRay> Philippa: wouldnt' that make it a dysfunctional language ;-
12:06:35 <CosmicRay> oh wait, that's Java...
12:06:47 <Philippa> ...from which C# was derived ;-)
12:06:56 <CosmicRay> heh
12:08:04 <Cale> In the beginning, C# and Java looked so similar that you could just rename a couple of keywords, and most Java code would become C# code :)
12:08:38 <Cale> I haven't bothered to look at either in a while though.
12:10:46 <xerox> > let philippha = fix (') in () -- giggle.
12:10:47 <lambdabot>  lexical error in string/character literal
12:15:14 <jips> well, it seems that c# 3 is gonna have good lambda expressions and type inference
12:15:26 <jips> but still no tuples :\
12:21:32 <kosmikus> jips: what about anonymous types? I thought they'd be good enough to simulate tuples
12:22:45 <jips> kosmikus: can you give an example of a staticly typed language that has anonymous types?
12:23:23 <kosmikus> jips: I thought c# 3 would have a feature called "anonymous types"
12:23:46 <jips> kosmikus: never heard about that, i haven't really been following c#, just heard some things about it
12:26:53 * jips reads about c# 3 anonymous types
12:27:28 <Philippa> can anyone in here name a technique (other than using monads) that's been borrowed for functional programming purposes from denotational semantics?
12:27:38 <Philippa> (for article purposes)
12:28:31 <Jaen> jips: O'Caml record types, perhaps?
12:30:02 <jips> hm...
12:30:50 <Jaen> or hmm, maybe they weren't called exactly that
12:32:42 <Jaen> just records, it seems
12:36:44 <Jaen> or no, I'm having trouble finding that feature again :)
12:40:19 <Heffalump> Philippa: arrows :-)
12:40:51 <Heffalump> were continuations first invented in denotational semantics?
12:42:28 <Jaen> jips: immediate objects, I guess, http://caml.inria.fr/pub/docs/manual-ocaml/manual005.html section 3.2
12:54:18 * palomer is still clueless about unification
13:03:28 <Philippa> Heffalump: ooh, good suggestion - I'll check that one
13:03:40 <Philippa> palomer: it's not too hard...
13:04:16 <Philippa> we're talking about a Hindley-Milner context here?
13:04:53 <Heffalump> also, wasn't the original point of ML precisely to do denotational semantics?
13:05:39 <Philippa> quite possibly, but that's not the kind of link I'm after per se
13:06:09 <Philippa> I just want some examples to show "raiding denotational semantics for FP techniques works"
13:06:24 <Heffalump> oh, not really.
13:06:27 <Heffalump> right
13:06:57 <Philippa> I'm also trying to be /reasonably/ polite about the "oh, monads're from category theory. <silence>" explanations, as part of me wants to say something snarky about category theory being abstract enough to model disappearing up its own arsehole ;-)
13:07:04 * Heffalump lol at the wikipedia page about ML.
13:07:10 <Heffalump> "[20:52] * Zeus agrees with andy
13:07:12 <Heffalump> oops
13:07:23 <Heffalump> "Examples of ML (Nicked from Haskell)"
13:08:09 <Philippa> oh *dear*
13:11:40 <Philippa> you're right about continuations btw
13:12:05 <Philippa> thanks for that, will work nicely
13:19:36 <ADEpt> @seen Lemmih
13:19:37 <lambdabot> Lemmih is in #haskell-blah and #haskell. Last spoke 1 hour, 55 minutes
13:19:37 <lambdabot> and 33 seconds ago.
13:20:49 * palomer wonders what polytipic unification is
13:20:59 <palomer> Philippa: yeah, HM
13:21:27 <Heffalump> polytypic unification is an example of the kind of cool thing you can do with PolyP or Generic Haskell
13:21:37 <Heffalump> it's a unification implementation that works on any datatype
13:22:02 <Philippa> palomer: OK. If you're given two type (applied) constructors, do you understand how to unify those?
13:22:15 <Philippa> For example, what's the result of unifying Maybe and Either Int Float?
13:22:37 <Heffalump> a kind error.
13:22:49 <Philippa> bah. Assume you've not kind-checked :-)
13:22:50 * Heffalump gd&r
13:23:06 <Philippa> and yeah, Maybe Int and Either Int Float, then
13:23:10 <Heffalump> but what self-respecting functional programmer wouldn't kind check before trying to use types? ;-)
13:23:22 <Philippa> one who doesn't have a kind checker to hand :-)
13:23:38 <Heffalump> ...because they didn't write a kind unifier :-)
13:23:48 <palomer> Philippa: yeah C v_1,...,v_n = C' v'_1,...,v'_n reduces to C = C' and v_i = v'_i
13:24:12 <Philippa> yup. And what happens when you unify a) Float and Float or b) Float and Int?
13:24:24 <palomer> Float = Float => ;
13:24:34 <palomer> Float = Int => error "cannot unify float and int"
13:24:42 <Philippa> in the first case, you get Float
13:25:09 <Philippa> because the only thing that is equal to both Float and Float is Float :-)
13:25:26 <Heffalump> are you just explaining unification, or are you explaining HM type inference including generalisation steps etc?
13:25:30 <palomer> what if you have alpha = beta, beta = Float?
13:25:36 <Philippa> OK. So it's type variables that're confusing you for now?
13:25:39 <Philippa> sounds it :-)
13:25:44 <Philippa> Heffalump: just unification for now
13:25:46 <Heffalump> palomer: you just keep a substitution as you go
13:25:50 <palomer> Heffalump: don't you mean instantiation?
13:25:58 <Heffalump> and always apply new things to the RHS of old things
13:26:06 <Heffalump> so you'd never keep alpha := beta, beta := Float
13:26:13 <Heffalump> you'd store it as alpha := Float, beta := Float
13:26:15 <Philippa> yep. You keep a big map of type variable to TyVar | Constructor
13:26:32 <Philippa> that's mostly a "not being slow" thing though...
13:26:35 <palomer> so beta = Float = Float and unificator(beta) = Float and replace beta by float in every instance?
13:26:40 <Heffalump> palomer: huh? (re "don't you mean instantiation")
13:26:48 <Heffalump> they're called unifiers :-)
13:26:55 <Heffalump> yes
13:26:59 <Philippa> palomer: yup
13:26:59 <palomer> Heffalump: for HM, I have to instantiate type schemes
13:27:09 <Heffalump> palomer: you also have to generalise to *make* type schemes
13:27:27 <palomer> what if I encounter alpha = beta?
13:27:29 <Heffalump> knowing when to generalise seems harder, to me, than instantiating :-)
13:27:39 <Heffalump> palomer: you just store that in your substitution
13:27:55 <Heffalump> obviously you should take some care not to ever have alpha := beta and beta := alpha
13:28:07 <Heffalump> but probably the obvious way of implementing it will be ok
13:28:08 <palomer> yeah, how do I deal with that?
13:28:17 <ADEpt> if i have a source which include FFI-ed sources, which command-line options will i need to load them into ghci? Currently Iget:
13:28:17 <ADEpt> During interactive linking, GHCi couldn't find the following symbol:
13:28:17 <ADEpt>   SHA1
13:28:17 <ADEpt> This may be due to you not asking GHCi to load extra object files,
13:28:17 <ADEpt> ....
13:28:35 <palomer> I only substitute on the rhs?
13:28:46 <Heffalump> palomer: if you always apply the existing substitution to things before generating new bindings, you should be fine
13:29:43 <palomer> so I have to substitute in every equation?
13:29:49 <palomer> not just the rhs?
13:30:06 <palomer> <Heffalump> and always apply new things to the RHS of old things
13:30:08 <Heffalump> unification problems are symmetric
13:30:12 <Heffalump> that's for the substitutions
13:30:19 <Heffalump> those are mappings from variables to terms
13:30:27 <Heffalump> obviously you shouldn't go substituting on the *left* of those :-)
13:30:36 <palomer> oh, for my final unifier
13:30:46 <Heffalump> note my use of := syntax for those not =
13:30:48 <palomer> so I start with this environment where env(a) = a for all a
13:30:54 <Heffalump> because it's more descriptive of the asymmetry
13:30:55 <Heffalump> right
13:31:05 <palomer> and then when I meet a = b, I change that for env(a) = b
13:31:16 <Heffalump> right, or env(b) = a
13:31:18 <Heffalump> but not both :-)
13:31:21 <palomer> and forall c. env(c)=a -> env(c) = b
13:31:31 <Heffalump> and if you meet a = Float, then you change it to env(a) = Float
13:31:33 <Heffalump> right.
13:31:42 <Heffalump> and env(c) = Foo a -> env(c) = Foo b
13:31:45 <Heffalump> you must recurse
13:31:48 <palomer> isn't that forall c. env... bit complex?
13:32:02 <palomer> which is why you'd use pointers!
13:32:14 <Heffalump> well, whatever.
13:32:23 <Heffalump> I'm not really debating what the efficient implementation is.
13:32:35 <Heffalump> Just suggesting one possibility that should have the correct behaviour and not be too bad.
13:32:43 <palomer> ok, I'll do the naive implementation
13:32:51 <palomer> simply because, well, I don't care:O!
13:33:01 <palomer> which monad do I use for this?
13:33:18 <palomer> State env env ?
13:33:20 <Heffalump> you probably at least need one with a supply of fresh names
13:33:31 <Heffalump> I wouldn't put the environment in the monad, myself.
13:33:37 <Heffalump> though you probably could
13:33:44 <palomer> you'd pass it around everywhere?
13:34:02 <Heffalump> yes. It is, after all, the visible result of unification.
13:34:07 <Heffalump> So hiding it doesn't seem all that useful to me.
13:34:10 <palomer> why do I need fresh names?
13:34:27 <Heffalump> err, maybe you don't
13:34:34 <Heffalump> you do when unifying lambda terms
13:34:44 <palomer> yeah
13:34:47 <palomer> that's for generating the constraints
13:34:50 <palomer> not for solving them
13:34:58 <Heffalump> but that's probably only for recursing through Lambda
13:35:04 <palomer> ok, now what's this about generalising for HM?
13:35:15 <Heffalump> that's not part of unification
13:35:24 <Heffalump> it's what you do when you type check a binding group
13:35:32 <palomer> let a = b in c
13:35:36 <palomer> I would first type a
13:35:40 <palomer> put that in my environment
13:35:50 <palomer> then type c with the new environment
13:36:00 <Heffalump> at some point, which I'm not exactly sure of when, you take all the types you've inferred, for each free type variable you stick in forall quantifiers around the outside
13:36:36 <palomer> Heffalump: and then you just unify the old types with the new types, generating new type variables for all universally quantified variables, right
13:36:38 <palomer> ?
13:36:44 <Heffalump> that's generalisation, because it turns a type with a free variable that could only be instantiated in one way to a type scheme that you can repeatedly instantiate at old types
13:36:56 <Heffalump> I'm not quite sure what you mean by that.
13:37:31 <palomer> say I want to type fix:b, then I would do forall a. (a->a)->a = b
13:37:51 <palomer> so I would pick new meta variables c and instantiate fix with that
13:37:56 <palomer> (c->c)->c = b
13:38:16 <palomer> is this correct?
13:38:22 <Heffalump> I think you're being a bit cavalier with your equalities.
13:38:25 <Heffalump> But that's the general idea.
13:38:42 <palomer> am I being cavalier?
13:39:09 <Heffalump> well, if I take your two equalities for b and put them together the result looks a bit weird
13:39:11 <Igloo> In "let f = \x -> x in f" you infer "a -> a" for f, generalise to "forall a . a -> a" and then instantiate that for the use of f in the body to get "b -> b"
13:39:27 <Heffalump> but I suspect it's just different understanding of the semantics of '='.
13:39:28 <Igloo> Does that help?
13:39:42 <Heffalump> help me, or palomer? :-)
13:39:54 <Igloo> palomer  :-)
13:40:49 <palomer> Heffalump: what looks weird?
13:41:20 <palomer> ok, I need to generate a constraint when encountering: |- fix : b
13:41:53 <palomer> that constraint would be b = (c->c)->c for some new c
13:42:48 <Heffalump> yes
13:43:03 <palomer> if it was foo: forall a.forall b. (a->b)
13:43:13 <palomer> and I wanted to generate a constraint for |- foo : b
13:43:14 <Heffalump> but saying earlier that b = forall a . (a->a) -> a, and then turning it into b = (c->c)->c, seems a bit weird. But I don't think it actually matters.
13:43:20 <palomer> it would be b = c->d for new c and new d
13:43:59 <palomer> and that pretty much summarizes hindley-miller
13:43:59 <palomer> :O
13:44:36 <Heffalump> unification, generalisation and instantiation, yeah.
13:44:51 <Heffalump> anyway, noone's told you about the difficult bits of unification yet :_)
13:44:55 <Heffalump> do you know about occurs checks?
13:45:02 <palomer> what's that?
13:45:19 <Heffalump> why is the definition "x = [x]" a type error?
13:45:58 <palomer> because x occurs in [x] ?
13:45:59 <Heffalump> from the point of view of unification, the reason is that you can't unify alpha = [alpha] 
13:46:08 <Spark> is there such a thing as "mutual" induction
13:46:11 <Spark> like mutual recursion
13:46:13 <Heffalump> but if you were naive, you'd just add the alpha = [alpha] substitution and all hell would break loose later.
13:46:47 <Heffalump> Spark: not named as such, really. But you could think of it as what you'd do to prove things about mutually recursive things.
13:47:06 <Spark> yeah, i can understand that its valid but i cant think of what its called :)
13:47:11 <Heffalump> palomer: so you have to do an occurs check whenever you are about to make a binding, to check that alpha doesn't occur anywhere in the right hand side.
13:47:19 <Heffalump> Spark: I think it's just called induction.
13:47:50 <Heffalump> palomer: and that strategy I suggested with applying your subsitution so far to everything, should ensure that you only have to check for alpha
13:48:17 <Heffalump> and you don't have to worry about alpha = [beta], beta = [alpha], because that'll turn into alpha = [[alpha]] at some point and you'll find the problem then
13:52:35 <palomer> Heffalump: one sec, brb
13:58:13 <monochrom> Just say induction.
14:00:23 <monochrom> If you have a pair of mutually recursively defined functions f,g (say f (n+1) = g n + 1, g (n+1) = f n + 1), and you are asked to prove something about f (the statement doesn't mention g, say "f n = n"), your induction hypothesis will have to be something stronger (say "f n = n and g n = n").
14:09:59 <araujo> Hello.
14:10:45 <palomer> back
14:11:49 <palomer> alpha=[beta], beta= [alpha] ...
14:12:06 <palomer> env(alpha)=[beta]
14:12:16 <palomer> then env(beta)=[alpha]
14:12:31 <palomer> and env(alpha)=[[alpha]] <--it fails here
14:12:35 <palomer> Heffalump: right?
14:13:18 <ADEpt> @index finally
14:13:18 <lambdabot> Control.Exception, Distribution.Compat.Exception
14:13:32 <palomer> but for a = b, b = a I get  env(a) = b and then env(b) = a and env(a) = a, right?
14:14:10 <Heffalump> palomer: err, roughly, it depends on your exact strategy
14:14:17 <Heffalump> in my view of the world, env(alpha) = [beta]
14:14:31 <Heffalump> then we apply that to beta = [alpha] giving beta = [[beta]
14:14:48 <Heffalump> and then we try to introduce env(beta) = [[beta]] and stop immediately
14:15:18 <palomer> <Heffalump> palomer: if you always apply the existing substitution to things before generating new bindings, you should be fine <--what does this mean?
14:16:41 <palomer> oh, I see, you substitute in the equation first
14:16:43 <palomer> and then you bind
14:16:49 <Squall`> In Yet Another Haskell Tutorial, It tells me to write "num <- randomRIO (1::Int, 100)" but doing that gives me a type error. The tutorial hasn't covered types yet, so I would assume that the tutorial doesn't expect me to know how to fix this. Is this a problem in the tutorial?
14:16:55 <Heffalump> palomer: right
14:17:10 <palomer> so beta = [alpha] becomes beta = [[beta]]
14:17:14 <palomer> yeah, that's much faster
14:18:10 * palomer needs to figure out how to write a monad to generate new names
14:18:19 <palomer> this should be really be included in the standard library
14:18:23 <palomer> since it's done everywhere
14:18:44 <monochrom> Squall`: you have to put it inside the do notation.  What you get is an IO monad.
14:19:06 <Heffalump> palomer: Reader [Name]
14:19:22 <Heffalump> pass it an infinite list of new names at the beginning
14:19:28 <Squall`> It was inside a do.
14:19:33 <Heffalump> then just take the head each time you need one
14:19:36 <monochrom> Here is an example.  (I'm using single-line notation rather than 2D layout.)  main = do { num <- randomRIO (1::Int, 100); print num }
14:19:42 <Squall`> I should have have specified that on here, sorry.
14:20:28 <monochrom> Does my example work?
14:20:53 <Squall`> It says something about an inferred type a-> IO t. I'm also using ghc, which I should have specified.
14:21:41 <palomer> Heffalump: remind me why I substitute before I bind?
14:22:03 <Cale> Heffalump: he'll also need to use local to locally modify the list of names too if he does that. State might be more convenient, depending on how they're to be consumed
14:22:14 <Heffalump> Cale: oh, yes, sorry
14:22:15 <Heffalump> I did mean State.
14:22:21 <Squall`> I'll print the exact error message if you need it.
14:22:32 <Heffalump> I thought State, then mentally convinced myself Reader was ok and said that.
14:22:35 <Heffalump> And it clearly isn't.
14:22:51 <monochrom> I don't get any error with my example.  Whose code are you referring to?
14:22:57 <Heffalump> palomer: because it guarantees that the RHS of your new binding won't have any variables that are already mapped by your substitution
14:23:04 <Cale> http://www.haskell.org/hawiki/MonadSupply
14:23:12 <monochrom> I hate it when people just say "it" all the time.
14:23:17 <Cale> my obvious monad for that kind of thing :)
14:23:22 <palomer> Heffalump: got an example?
14:23:59 <palomer> Cale: was that the Monad which you described the other day?
14:24:06 <monochrom> I would pretty much love the pronouns "he she it they this that" removed from the damned English language.
14:24:08 <Heffalump> env(alpha) = Int, equation beta = alpha
14:24:11 <Cale> monochrom: usually when people say 'it' they are referring to something in particular :)
14:24:35 <Cale> palomer: not quite the same as Unique, but it would be somewhat equivalent
14:25:35 <Cale> Unique is basically the same as this, only evalUnique x is more like evalSupply x [1..]
14:25:49 <Cale> so it's less flexible
14:26:05 <palomer> Heffalump: so my rhs will never have variables which are already mapped?
14:26:18 <palomer> (if I substitute)
14:26:52 <Heffalump> palomer: right
14:27:07 <palomer> Heffalump: so my env will never have any cyclic dependencies?
14:27:10 <Heffalump> right
14:27:13 <Cale> oh, also, this is wrapped in Maybe due to the need to handle the empty supply condition
14:27:14 <Heffalump> that's the goal
14:27:29 <Heffalump> and if there would be a cyclic dependency that introduces an infinite type, your occurs check should catch it
14:27:48 <palomer> does this hold: forall a. env(a) = b  -> all variables in b are not mapped in the environment
14:27:50 <Squall`> I'm referring to the code on Yet Another Haskell Tutorial, I understand what you're saying about do, that's not the problem, I just omitted it for brevity. The problem is that it says it expects type IO t and it's inferring a-> IO t
14:27:51 <Heffalump> Cale: this is why I use infinite lists for my supplies :-)
14:27:58 <Heffalump> palomer: yes
14:28:16 <Cale> Heffalump: yeah, you'd need to define an additional type there.
14:28:19 <Heffalump> it's not essential that you enforce that invariant, but I think it's helpful for understanding purposes.
14:28:36 <palomer> Heffalump: you mean explicitly enforce that invariant?
14:28:36 <Heffalump> probably the most efficient scheme would involve pointers, and then that property wouldn't be maintained
14:28:55 <Heffalump> palomer: well, the method of implementation I've suggested should implicitly enforce it.
14:29:03 <Heffalump> But if you're feeling paranoid, you could check it every so often.
14:29:08 <ihope> Aha! Lisp is quasi-functional!
14:29:10 * ihope feels smart
14:29:25 <Heffalump> And I'm a bit rusty on doing all this stuff anyway, so treat my advice with a pinch of salt :-)
14:29:40 <Philippa> ihope: we pronounce that "funced up" :-)
14:29:55 <palomer> quickcheck here I come!
14:29:59 <palomer> hrm
14:30:05 <palomer> now I have to generate these constraints
14:30:06 <franka> palomer, did you ever look at those dependent types references I gave you?
14:30:20 <ihope> philippa: you mean "func'ed"?
14:30:44 <monochrom> ok I've opened YAHT.  Are we on the same page?
14:30:46 <Philippa> ihope: I *mean* something considerably less polite, but hey ;-)
14:30:51 <palomer> franka: which ones?
14:31:03 <ihope> Ah :-)
14:31:11 <franka> My friend used to say, "Functor? I barely even know her!"
14:31:29 <Philippa> biblically speaking, that is
14:31:42 <franka> palomer: When you were talking to Lennart.
14:31:48 * Heffalump spies a circular conversation approaching
14:32:59 <monochrom> Gosh YAHT has 193 pages.  If I randomly pick a page, there is 99.5% chance it is the page in question.
14:33:25 <palomer> franka: you'll have to remind me of the title
14:33:38 <palomer> monochrom: your subconscience has already memorized it
14:33:41 <franka> For example, the one on categorical logic by Andrew Pitts.
14:33:47 <palomer> oh, now I remember
14:33:51 <palomer> no, not yet
14:33:57 <palomer> though I got one of the books you recommended
14:34:01 <palomer> by Jacob
14:34:06 <palomer> (haven't started reading yet)
14:34:08 <franka> Ah, good.
14:34:10 <palomer> what's the other book you recommended?
14:34:20 <franka> Taylor's Practical Foundations.
14:34:38 <franka> It's my bible.
14:35:23 <gaal> hey. I seem to remember there was a syntactic trick where a "let" expression could be used to do pattern matching. But I don't know what it was.
14:35:53 <palomer> franka: yeah, I asked for an ILL, so they ordered it
14:35:58 <franka> There's no trick; you just use a pattern on the lhs.
14:36:02 <gaal> e.g. if I have a Maybe, but I *know* it's Just x, I want an expression (not fromJust :-) that'd get me x
14:36:04 <monochrom> let x:xs = [1,2] in x
14:36:09 <palomer> (I think they order every book i ask for) (ILL = inter university loan)
14:36:22 <palomer> inter library loan
14:36:26 <franka> Ah.
14:36:27 <monochrom> Another example.  let (x,y) = (1+2, 3+4) in x+y
14:36:40 <monochrom> let Just x = Just 10 in x+1
14:36:46 <araujo> gaal, let f (Just x) = x ?
14:37:00 <palomer> gaal: is your function returning a Maybe?
14:37:11 <gaal> no, Maybe was just an example.
14:37:16 <SamB> palomer: ILLs do tend to work that way assuming some other library actually has the book...
14:37:16 <monochrom> You can also have let Just x = Nothing in x+1 too.  Don't do it at home though.
14:37:31 <monochrom> > let Just x = Just 10 in x+1::Int
14:37:33 <lambdabot> 11
14:37:41 <palomer> gaal: do {x <- IKnowItsJust; return [x]}
14:37:43 <franka> SamB: I think he means they bought it.
14:37:43 <gaal> monochrom: that errors, I hope?
14:37:53 <monochrom> > let Just x = Nothing in x+1::Int
14:37:55 <lambdabot>  Irrefutable pattern failed for pattern Data.Maybe.Just x
14:38:05 <SamB> oh?
14:38:08 <monochrom> Anyway, you get the point.
14:38:15 <Heffalump> > let ~(Just x) = Nothing in x+1::Int
14:38:17 <lambdabot>  Irrefutable pattern failed for pattern (Data.Maybe.Just x)
14:38:26 <gaal> palomer: that's cheating :)
14:38:35 <palomer> how is it cheating:o it did exactly what you wanted
14:38:38 <monochrom> More interesting example:
14:38:43 <SamB> fromJust?
14:38:57 <monochrom> > let Just x = if True then Just 10 else Nothing in x+1::Int
14:38:59 <lambdabot> 11
14:39:07 <gaal> Maybe was just an example here, I was out for the general case.
14:39:22 <gaal> monochrom's examples seem to do what I want, thanks.
14:39:23 <Heffalump> let <pattern> = <expression> in ...
14:39:23 <monochrom> Well I'm sure you know how to generalize.
14:39:27 <Heffalump> is the general case
14:39:50 <gaal> okay, thanks.
14:41:42 <gaal> "My brain just exploded. I can't handle pattern bindings for existentially-quantified constructors."
14:41:45 <Cale> http://www.haskell.org/hawiki/MonadUnique -- there's the silly special case :)
14:41:59 <gaal> I think I'll stay with the case I had there :-)
14:42:09 <Cale> hm?
14:42:18 <Cale> That's more for palomer 
14:42:28 <gaal> Cale: I was quoting GHC :)
14:42:41 <Cale> I know, I've gotten that one before :)
14:43:29 <gaal> Nice to know our relationship is becoming balanced. After all, GHC has been causing my brain to explode for a while now.
14:43:39 <Cale> hehe
14:44:32 <Heffalump> gaal: you might be able to replace your existentially quantified constructors with GADTs
14:44:50 <monochrom> haha GHC has brain? :)
14:45:00 <Heffalump> monochrom: bigger brain that most Java programmers..
14:45:48 <Igloo> You get the same error with GADTs
14:47:49 <Heffalump> ah. I had the general impression from those experiments we did with darcs that GADTs were a bit better behaved.
14:53:54 <ncalexan> In a lot of OO languages, if I want to make small modifications to an object A,  yielding A', there is some support for inheritance, or mixins, or changing methods/message receivers.  Is there a good discussion of this delegation pattern in a Haskell context?
14:54:46 <ncalexan> I envision having a type class, and a newtype that wraps the original object/type, and a lot of lifting that needs to be done by hand.
14:54:50 <ncalexan> Is there anything nicer?
14:55:15 <Heffalump> datatypes with record syntax, perhaps
14:55:40 <Heffalump> that's pretty close to being an object, but you can't extend it easily.
14:55:47 <Heffalump> but overrides are very simple
14:55:58 <SamB> I think ncalexan is confused about what "modifications" are
14:56:01 <ncalexan> I think that turns all method calls into deref data structure for func and then call method calls...
14:56:15 <ncalexan> SamB: no, but there are two parses.
14:56:15 <Heffalump> whereas with a type class overrides are hard (newtype+lots of boilerplate needed) but extension is quite easy
14:56:42 <ncalexan> SamB: when I mean modify, I really mean change behaviour, not change internal state.
14:56:54 <ncalexan> Well, I suppose state and behaviour are the same things in dynamic languages.
14:57:03 <monochrom> If you have a typeclass, you can make a sub-typeclass.  For example MonadPlus is a sub-typeclass of Monad.
14:57:23 <franka> All you need is to add a type parameter to the datatype.
14:57:26 <ncalexan> monochrom: that extends behaviour.
14:57:39 <ncalexan> franka: I saw that on the Wiki; it works, but obviously scales badly.
14:57:56 <ncalexan> So I could have class Object behaviourType where ...
14:58:01 <franka> type ColoredPoint a = Point (Int -> Int) or whatever
14:58:03 <ncalexan> and parameterise over behaviourtype.
14:58:31 <franka> er, type ColoredPoint a = (Point (Int -> Int), a), I mean.
14:59:24 <monochrom> The question is rather vague actually.
14:59:44 <ncalexan> Yes, it is.  I can elaborate.
15:00:37 <ncalexan> Let's assume I have some class: class Object where method :: String ; ... lots and lots of other methods elided ...
15:01:00 <ncalexan> Suppose I have an instance: instance Object Blah where method = "blah" ; ... elided ...
15:01:11 <Heffalump> data Object = Object { method :: String, ..... }
15:01:23 <Heffalump> blah = Object{ method = "blah", .... }
15:01:41 <Heffalump> blah' = blah {method = "blah'" }
15:01:47 <Heffalump> that's what I meant by easy overriding above.
15:01:49 <franka> Why do you think you need objects in the first place?
15:02:06 <ncalexan> Now suppose I want an instance: instance Object Blah2 where method = "blah 2" ; ... the rest the same as Blah ... 
15:02:40 <ncalexan> Heffalump: I know that will work... but by doing so, you box and unbox every method call every time, and you lose all of the other nice type class provided features.
15:02:44 <Cale> ncalexan: did you see the feature in 6.5 regarding existentially quantified record constructors?
15:02:58 <ncalexan> Cale: no.  Reference?
15:03:01 <Cale> http://www.haskell.org/hawiki/Existentially_20quantified_20record_20constructors
15:03:06 <franka> What is 6.5?
15:03:21 <Cale> GHC 6.5
15:03:23 <franka> Ah, GHC
15:03:42 <Heffalump> ncalexan: is boxing and unboxing any worse than a type class dictionary lookup?
15:04:11 <Heffalump> surely just unbox, anyway
15:04:25 <Heffalump> the boxing only happens once when it's constructed
15:04:30 <ncalexan> Cale: that's what I'm after.  Pity it's so far in the future...
15:05:16 <ncalexan> Heffalump: I understand and appreciate your solution.  It does not seem appropriate to me, so I am interested in finding other solutions and understanding what can be done idiomatically in Haskell.
15:05:56 <Heffalump> ncalexan: ok, fair enough
15:05:58 <franka> I repeat:
15:06:06 <franka> Why do you think you need objects in the first place?
15:06:23 <franka> The "idiomatic" thing to do is to avoid them.
15:06:32 <franka> Though there are situations where you cannot do that.
15:06:49 <ncalexan> franka: I use object in the non-OO sense.  Just a collection of information, be it functions or data.
15:07:00 <ncalexan> Call it a record, class instance, whatever feels right.
15:07:30 <Philippa> do you need /mutable/ things?
15:07:42 <Philippa> do you need some analogue of a class hierarchy?
15:07:56 <franka> Every value is a "collection of information".
15:08:20 <franka> I guess what you are interested in is more to do with delegation.
15:08:25 <franka> Or inheritance.
15:08:44 <ncalexan> Phillipa: no, mutation is incidental; no, there is no hierarchy.  I just want to delegate some details to different behaviour while not bludgeoning my way through yards of lifting code.
15:08:59 <ncalexan> Inheritance is, in this theoretical situation, overkill.
15:09:11 <Heffalump> ncalexan: though I don't understand why you think existentially quantified record constructors are what you're after, if my suggesion isn't a useful partial solution
15:09:24 <Philippa> ncalexan: is parameterising on the thing delegated to acceptable?
15:10:21 <franka> I think your problem is perhaps a bit too theoretical; does it come up in practice?
15:10:25 <ncalexan> Heffalump: fair enough, I think they're equivalent.  One is smooth and I think it will integrate well into the language.  The other appears to require constant (findFunction object) call function.
15:10:39 <ncalexan> Phillipa: yes, I think.
15:11:01 <SamB> theoretical problems need to be given in a less-vague way
15:11:14 <ncalexan> s/to require .../to require continually calling (findFunction object) then calling function.../
15:11:20 <Cale> ncalexan: despite the fact that the record syntax isn't there, there are already existential types
15:11:21 <franka> Good point, SamB. :)
15:12:35 <palomer> ok
15:12:37 <ncalexan> Heffalump: what happens to your solution if you have, say, 20 different objects?
15:12:43 <palomer> someone explain why existential types are needed for sml modules
15:12:46 <Philippa> ncalexan: so just parameterise your things on other things, be it on the type level or by using pseudo-constructor functions?
15:12:46 <Heffalump> ncalexan: happens in what sense?
15:13:19 <Heffalump> palomer: because of the functor system, I believe
15:13:24 <palomer> exists X. T = (forall X. (X-> T)) -> T
15:13:48 <ncalexan> Philippa: does such a discussion of these things exist?  Maybe somewhere I'm not looking on the Wiki?
15:13:56 <palomer> yeah, that makes sense
15:14:17 <palomer> I have to first pass an element of (forall X. X->T)
15:14:25 <franka> palomer: SML uses dependent sums to hide the types of module implementations.
15:14:35 <palomer> franka: for example?
15:15:10 <Philippa> ncalexan: haven't seen much as such. Just bits of code that attack it one way or another
15:15:17 <ncalexan> Heffalump: it appears that your record encodes what Java folks call an interface.
15:15:20 <Philippa> if you want something AOP-like, I've a couple of hacks I've used
15:15:33 <Heffalump> ncalexan: no, it has implementations too
15:16:03 <SamB> ncalexan: well the record type sort of does encode an interface, doesn't it?
15:16:08 <franka> struct type int val f : int -> int end : sig type t val f : t -> t end
15:16:21 <Heffalump> the benefit that existentially quantified stuff has over the simple record solution is encapsulation - you can hide implementation details from clients
15:16:43 <ncalexan> Philippa: I've seen lots of bits of code, too, and I know several different ways of doing it.  I was wondering if there was some Haskell-ish GOF/Design Patterns community knowledge I could tap into.
15:16:47 <ncalexan> S'pose not :)
15:17:10 <Heffalump> but you could write that inc function defined on the wiki page for the normal records too
15:17:19 <Heffalump> it's just that the self type couldn't be hidden from clients
15:17:25 <palomer> franka: that would be of type {exists T. T->T} ?
15:17:49 <ncalexan> Heffalump: my point exactly.  Carrying around self... it just smells all wrong.
15:18:05 <franka> palomer: Justasec.
15:18:10 <ncalexan> Like carrying around world... and I suppose it could all be encapsulated in a monad, but then your lifting code just got scarier still.
15:18:13 <Heffalump> ncalexan: well, it's only "carried around" in the types
15:18:21 <Philippa> ncalexan: no one collection. On another level, a bunch of type signiatures is practically a pattern unto itself
15:18:23 <Heffalump> you don't see it in the code
15:20:13 <ncalexan> Heffalump: it worries me when I rewrite language features (type classes) in application code (record of methods)
15:20:24 <ncalexan> That usually means I don't know enough...
15:24:54 <franka> palomer: First page of the paper: http://citeseer.csail.mit.edu/jones96using.html
15:25:53 <palomer> is that peyton's sml modules in haskell paper?
15:25:57 <ncalexan> Heffalump, franka: thanks for the suggestions.
15:26:02 <ncalexan> Philippa: cheers.
15:26:12 <ncalexan> (And thanks for the TMR articles, v. interesting)
15:26:20 <franka> No, it's Mark Jones' paper on parameterized signatures.
15:26:53 <franka> I don't think I helped much, ncalexan, but no problem.
15:28:05 <Philippa> ncalexan: sometimes, record of methods is appropriate still. The AOPish things I've done have used something like that, because the records are values and that lets you build stacks of them at runtime...
15:28:13 <ncalexan> franka: well, it clarified things for me...
15:28:44 <ncalexan> Philippa: where's the tipping point?  Lots of different instances?  Different interfaces?
15:28:55 <ncalexan> But that might be very hard to quantify.
15:29:05 <ncalexan> A "your case needs to be handled" situation.
15:30:03 <Philippa> ncalexan: "not linked to types"
15:30:37 <Philippa> with the AOPish stuff, there's no accompanying type per piece of advice because it wouldn't do anything useful...
15:30:49 <ncalexan> Phillipa: sorry, RoM... oh, I see.
15:30:57 <Philippa> (it's different if you're doing AOP-via-monad-transformer-stack, admittedly)
15:32:46 <palomer> AOP = aspect oriented programming?
15:33:26 <Philippa> yup
15:33:56 <Philippa> admittedly I'm using it in a sense that admits methods that don't let you insert stuff any and everywhere at random
15:37:24 * palomer wonders about the type theoretic implications of AOP
15:38:07 <Philippa> either it patches into everything willy-nilly and you have to work on the woven code, or all the possible join points're declared up front and you can do all the usual stuff
15:40:26 <Heffalump> I always feel that bringing the words "theory" and "AOP" too close to each other is likely to create an oxymoron.
15:40:53 <Philippa> the theory amounts to "until you weave, you can't do anything sane", no?
15:41:19 <Heffalump> although quite a lot of people try to talk about the theory, and foundations and so on, fundamentally the driving force behind AOP is "do what's convenient and throw principle out the window".
15:41:43 * Philippa nods
15:41:51 <Philippa> it's "OMG, we need dyntyped easily-fuckupable Java!"
15:41:54 <Heffalump> rather like NuLabour, in fact.
15:41:57 <monochrom> Isn't that the driving force behind all popular programming methods.
15:42:07 <palomer> getting things done?
15:42:09 <palomer> it's a shame:o
15:42:29 <Heffalump> no, Java, C etc all grew out of quite principled designs.
15:42:49 <Heffalump> even C++ is at least a well thought out steaming heap of shit
15:42:57 <SamB> but Java's is badly typed...
15:43:10 <Squall`> What do you mean Java is badly typed?
15:43:20 <Philippa> but only by our standards. By the standards of the target audience, OTOH...
15:43:26 <Squall`> I'm not refuting you, I'm just asking you to clarify what "badly typed" means?
15:43:36 <Philippa> Squall`: inexpressive type system prior to generics, broken type system once you add them
15:44:10 <SamB> also, the array types are messed up
15:45:24 <Squall`> I'm not really a big fan of strong typing anyway.
15:45:36 <JohnMeacham> java has enough strong typing to anoy you, but not enough to express the interesting things you want. no wonder it turns people off to strong typing.
15:45:45 <SamB> well, Javas is probably the worst...
15:45:47 <JohnMeacham> If that is what people think it is.
15:45:53 <Heffalump> https://bugs.eclipse.org/bugs/show_bug.cgi?id=68603#c4 is a good example of what I mean by my comment above, btw.
15:46:07 <SamB> it is just enough to be a total pain in the neck, without actually giving you any really nice features
15:46:19 <Squall`> JohnMeacham, heh, that's probably why I hate it. I just started Haskell so I'm hoping it will enlighten me.
15:46:29 <jips> java appears to be c++ minus about two dozen features plus reflection
15:46:38 <SamB> and it isn't even soundly typed!
15:46:40 <jips> and plus garbage collection
15:46:40 <JohnMeacham> pretty much all the imperitive languages have almost the same type system. with a sprinkling of dynamic typing when  dealing with objects and maybe a generics mechanism.
15:46:54 <Philippa> jips: that's a bit misleading. Java borrows C syntax and that's about it
15:47:17 <Philippa> oh okay, that and stack-allocated stuff which it really shouldn't have - but hey
15:47:34 <jips> c++ has stack allocated stuff
15:47:38 <Heffalump> why shouldn't it have stack allocated stuff?
15:47:51 <Philippa> because it adds conceptual mess for no real gain
15:48:03 <jips> so don't use it if you don't like it :)
15:48:03 <Heffalump> it's quite a major efficiency gain
15:48:15 <Heffalump> C# is more consistent, by allowing anything to be unboxed, not just primitive types
15:48:22 <JohnMeacham> there shouldn't need to be a concept of stack allocated vs. heap allocated stuff. stack stuff is exactly those things for which finite regions can be infered via region inference. no need for the programmer to specify them.
15:48:32 <palomer> java is soundly typed, if you agree that exceptions are part of soundness
15:48:41 <Heffalump> JohnMeacham: assuming a perfect region inference algorithm
15:49:01 <Heffalump> in practice, programmers like to be able to write code with some level of performance guarantee
15:49:02 <Philippa> palomer: including a RunTimeTypeErrorOMFGSoMuchForStaticTyping exception :-)
15:49:13 <jips> exceptions in oop languages seem to be black magic
15:49:18 <JohnMeacham> no such thing. and no need, the GC is already conservative, so adding region inference can only help, even if it is conservative.
15:49:42 <Heffalump> Philippa: to be fair that is a problem that is hard to solve, and is only solved in ML by hard-to-understand type system restrictions
15:50:05 <Philippa> yeah, I know
15:50:18 <palomer> Heffalump: the type restrictions in ml aren't hard to understand
15:50:22 <Philippa> OTOH, it does give you a level of 'soundly typed' equivalent to lisp...
15:50:23 <Heffalump> JohnMeacham: if heap allocated objects aren't put on the stack when they could have been, the program will be less efficient.
15:50:28 <JohnMeacham> but actually, you only need escape analysis to figure out what can be stack allocated, which is actually quite a straightforward analysis and a sort-of region inference. in that regioninference gives you that info plus all sorts of other info.
15:50:28 <Heffalump> palomer: really? What's the restriction, then?
15:50:34 <palomer> only values have polymorphic types. end of story
15:50:45 <palomer> anything else can have schematically polymorphic type
15:50:48 <Heffalump> JohnMeacham: and it requires the whole program
15:51:08 <SamB> Heffalump: jhc demands that anyways ;-)
15:51:32 <JohnMeacham> Heffalump. indeed. but escape analysis for a first order language like java is pretty easy, in fact, I think it would actually do much better than programmer specified ones, picking things up the programmer didn't specify. 
15:51:47 <Heffalump> JohnMeacham: there's no reason not to do that _as well_
15:51:53 <SamB> what use would that be for Java?
15:51:59 <JohnMeacham> no, it can be done locally. to decide if something escapes you only need the info for each function it calls, not what is calling it.
15:52:00 <SamB> or do you think you could work it into the JIT?
15:52:06 <Heffalump> but you can't offer a simple guarantee to the programmer "if you do this, your object will be stack allocated"
15:52:18 <Heffalump> and that kind of guarantee will be important to some people
15:52:37 <Heffalump> JohnMeacham: but you may not know everything about each function it calls
15:52:38 <Philippa> and you don't know all the functions being called
15:52:41 <Philippa> snap!
15:52:48 <Philippa> it could've been a method from a dynloaded class
15:53:04 <JohnMeacham> not when their programs start running faster because they realize the computer is better at optimizing than they are. the JIT already imposes so much overhead, the difference is eaten up anyway. 
15:53:05 <Philippa> (or even just a new subclass, possibly anonymous)
15:53:07 <Heffalump> SamB: potentially, at the cost of more compilation overhead
15:53:11 <palomer> (first time I hear "snap" on #haskell)
15:53:24 <Heffalump> JohnMeacham: it's just not true that computers are uniformly better at optimizing than humans
15:53:27 <JohnMeacham> ah, true. it is not quite first order. but it can still be done.
15:53:41 <JohnMeacham> Heffalump: jhc is my constructive proof that that is not true :)
15:53:48 <Heffalump> :-)
15:53:55 <SamB> JHC has JIT?
15:54:09 <Heffalump> you're claiming that jhc is uniformly better than a human at optimizing?
15:54:16 <Heffalump> or that it isn't?
15:54:17 <JohnMeacham> Heffalump: the proof isn't done yet.
15:54:28 <SamB> JohnMeacham: you, sir, are wrong!
15:54:33 <Heffalump> will it be finished before I die?
15:54:34 <Philippa> it's easy to prove. You pick a 5 day old child to compare with
15:54:40 <SamB> jhc doesn't know how to cheat
15:54:41 <Philippa> or did you mean that to be universally quantified? :-)
15:54:43 <Heffalump> (I'm not planning on dying particularly soon, if that helps..)
15:54:57 <Heffalump> I meant for it to be universally quantified :-p
15:55:15 <Philippa> I strongly suspect jhc is better than I can be bothered to be
15:55:27 <JohnMeacham> Heffalump: that is my "goal", but, like science, falsifying a theory can produce much more interesting results and have more ramifications than proving it. 
15:55:44 <Heffalump> I doubt it has as good a strictness analyser as I have.
15:55:44 <SamB> does jhc know how to use extremely naughty ASM tricks?
15:55:58 <Philippa> jhc delegates that part :-)
15:56:14 <Heffalump> would it be willing to make a Map strict in its elements?
15:56:18 <JohnMeacham> Heffalump: then take any case you are better at it, and add it to jhc as a general optimization. wash, rinse, repeat.
15:56:48 <Heffalump> JohnMeacham: suits me :-) But I still dispute you can provide as strong a guarantee as an explicit language feature can.
15:56:48 <SamB> JohnMeacham: its not fair to assume that the human will be cooperative
15:56:49 <JohnMeacham> map is usually deforested away actually. 
15:56:54 <Heffalump> no, Map, not map.
15:57:04 <Heffalump> as in Data.Map
15:57:08 <monochrom> Map, the container.
15:57:31 <palomer> Map II, Map's revenge
15:57:37 <Heffalump> I have a program that builds up a bunch of Map Something Integer, and the Integers all end up being lazily constructed, which kills available memory.
15:57:42 <JohnMeacham> that can be too, with appropriate RULES pragmas. there is an example in the deforestation via RULES paper on how to add deforestation rules to your own types. It would be interesting to do that for Map and Set.
15:57:48 <palomer> Heffalump: make it strict
15:57:51 <Heffalump> it's not a deforestation problem
15:57:54 <Heffalump> palomer: it's not that simple
15:58:07 <Heffalump> how do you make a Map that is strict in its elements, short of applying deepSeq after each update?
15:58:28 <Heffalump> (This is the third time I've asked this question on here, and I didn't get any replies the first two times :-)
15:58:39 <Philippa> by making Map' which has bangs in its constructors?
15:58:49 <Heffalump> (The other extreme solution is to copy the source of ^W...^W what Philippa said
15:59:01 <Heffalump> it's not exactly nice.
15:59:05 <JohnMeacham> by baking a Map.insert that is strict in the element?
15:59:08 <SamB> I can deforest sets
15:59:13 <Heffalump> and in principle a compiler ought to do it for me
15:59:19 <Philippa> JohnMeacham: was about to suggest that, too
15:59:22 <Heffalump> JohnMeacham: and Map.update and Map. blah blah blah
15:59:24 <SamB> just replace them with "sort"
15:59:27 <palomer> Heffalump: why not make it strict when inserting?
15:59:30 <SamB> and "nub"
15:59:33 <Philippa> I dunno, a compiler isn't sure you might not need the laziness for termination?
15:59:35 <SamB> or is it just nub?
15:59:56 <palomer> if one was to write haskell code where everything is strict, would it be as fast as equivalent mlton compiled code?
16:00:02 <Heffalump> palomer: precisely. But in this case I'm sure I don't.
16:00:20 <Heffalump> and given undecidability and all, there will always be situations where I know this and the compiler doesn't.
16:00:30 <JohnMeacham> One  might argue  that you are expressing a different program. in any case, it doesn't matter if the compiler can't catch every optimization you can think of, if it can catch enough that you wouldn't to make up the difference.
16:00:44 <Heffalump> palomer: I doubt it, because GHC isn't optimised for that, sadly. Maybe when JHC is complete.
16:00:45 <palomer> Heffalump: create your own Map module, where insertion is strict
16:01:10 <palomer> oh, nice, jhc = mlton for haskell
16:01:10 <JohnMeacham> Heffalump: I disagree. there is no proof humans are more powerful than turing machines. 
16:01:39 <Heffalump> of course there is, it's inherent in the proof of Godel's incompleteness theorems
16:01:42 <monochrom> We need to get rid of humans.
16:01:54 <Heffalump> within a system you can't prove something, but you can by stepping outside it
16:01:56 <Philippa> there is, however, proof that humans're willing to jump around illogically in hope of something that works out better, and that humans may know more about the code than a turing machine
16:02:03 <Heffalump> and humans are the ultimate in being able to take a step back
16:02:15 <JohnMeacham> Heffalump: indeed. and computers are perfectly as capable of stepping outside a system as humans are.
16:02:23 <Philippa> so show me someone who can solve the halting problem in general?
16:02:30 <JohnMeacham> see the 'goedel machine' or the 'supercompilation' paper.
16:02:35 <JohnMeacham> papers.
16:02:45 <monochrom> Philippa: however, there is no proof that that human process terminates and yields correct results.
16:02:51 <palomer> whoa, jhc doesn't have a GC
16:02:53 <palomer> what the???
16:02:59 <Heffalump> I don't know about the godel machine, but I disagree that supercompilation is taking a fundamental step outside.
16:03:02 <JohnMeacham> palomer: it can use the boehm GC.
16:03:07 * astrolabe agrees with JohnMeacham
16:03:13 <SamB> Philippa: the beauty of humans doing things is that they don't need to be decidable things
16:03:17 <Heffalump> humans also have the option of sacrificing correctness, which compilers don't.
16:03:32 <SamB> Heffalump: sure they do!
16:03:41 <SamB> its just not incorrect for them to do so
16:03:43 <Philippa> SamB: give or take. Most of us have some kind of timeout
16:03:47 <SamB> s/not //
16:04:01 <SamB> boredom...
16:04:11 <Heffalump> Philippa: I don't need to show you someone that can solve the halting problem in general.
16:04:34 <astrolabe> It is hard to imagine a system we couldn't step outside of, but it is hard to imagine something provable that a computer couldn't prove.
16:04:38 <monochrom> Who can solve the halting problem in general?  We need to hire that guy.
16:04:39 <Heffalump> I just need you to give me a partial solution to the halting problem, and then to exhibit a program that I can prove halts that your solution can't.
16:04:55 <Heffalump> perhaps my argument about humans being able to take a step outside is a red herring.
16:05:00 <Philippa> yup
16:05:11 <Philippa> it's more that people will be running a different program, as it were
16:05:18 <Heffalump> The point is that undecidability implies that anything that a given computer program can do, a given programmer can find a problem with.
16:05:19 <palomer> hrm, how does E get around Girard's paradox?
16:05:35 <JohnMeacham> programmers are not any more powerful than programs.
16:05:47 <JohnMeacham> just faster.
16:05:57 <Heffalump> no, but in any given programming situation, the compiler is fixed, but the program being written is variable.
16:06:00 <palomer> I think the difference between a program and a human is that it's possible to say "this algorithm will never solve this particular case", whereas it is impossible to say this with humans
16:06:16 <Heffalump> If the program runs into some case the compiler can't handle, it will be some time before the compiler is fixed to do so.
16:06:17 <JohnMeacham> Heffalump: and you swap brains for every program you write :)
16:06:21 <Philippa> palomer: bingo
16:06:44 <Philippa> Heffalump: ever watched a 5 year old try to do calculus? ;-)
16:06:48 <Heffalump> A compiler can never give an optimisation guarantee for an undecidable problem.
16:06:50 <palomer> so, erm, undecidability proofs for humans are not constructive:P
16:07:07 <Heffalump> Philippa: errm, possibly, why?
16:07:14 <JohnMeacham> polomer: not true. it is simple to write a program that will eventually prove all provable statements. 
16:07:49 <Philippa> Heffalump: it may be some time before the kid's physically capable of it
16:07:53 <SamB> JohnMeacham: not if the power goes out!
16:07:54 <JohnMeacham> A goedel machine is a particular example of one with the interesting property that it has the ability to improve its own algorithms as well.
16:07:55 <palomer> JohnMeacham: erm, I don't see how that contradicts my statement
16:08:09 <Philippa> (though I would've been able to do simple differentiation when I was 7 no problem)
16:08:35 <SamB> and also, they can't make up postulates
16:08:48 <Heffalump> I can't remember when I would have been able to do calculus. Let's just settle on a 1-year old and you'll have made your point :-)
16:09:15 <Philippa> I'd rather not sit on a 1 year old if that's alright by you :-)
16:09:26 <JohnMeacham> palomer: I can say that a dead human will never solve a particular case. just like I can say a particular algorithm will never solve a particular case. but this can't be done across all algorithms just like it can't be done across all humans.
16:09:26 <mjl69__> If a chicken can win at tic-tac-toe, it can probably do a little calculus too.
16:09:34 <Heffalump> I'm sure he or she wouldn't squeak too loudly.
16:10:01 <Philippa> it's more the squi-crack-sh than the squeak I'd worry about
16:10:27 <palomer> JohnMeacham: My statement was:  any proof of "no human can solve this particular problem" cannot be constructive
16:10:30 <JohnMeacham> as in, your assertion that you can say a particular algorithm can't solve something does not imply there does not exist an algorithm that can solve it.
16:11:02 <palomer> JohnMeacham: unless you're contradicting another one of my statements
16:11:17 <SamB> yeah, but can you prove it about a live human?
16:11:19 <JohnMeacham> palomer: sure it can, just show humans can be simulated by a turing machine.
16:11:30 <palomer> JohnMeacham: but, they can't
16:11:34 <JohnMeacham> or that the universe can be.
16:11:49 <SamB> I'd like to see a turing machine that could learn to walk
16:11:50 <JohnMeacham> palomer: it is my (and many peoples) belief that they can.
16:12:05 <SamB> it is my belief that they cannot
16:12:11 <SamB> on account of having so much tape
16:12:13 <JohnMeacham> in fact, all physical laws are likely ture.
16:12:23 <JohnMeacham> but it is certainly a provable assertion.
16:12:27 <JohnMeacham> one way or the other.
16:12:33 <Philippa> SamB: there're projects working on the walking thing, unsurprisingly
16:12:46 <palomer> ok,a turing machine is a program that takes two inputs (program, input) and returns true, false, or loops. There are certain problems that this program will never be able to solve. this statement does not hold for humans
16:12:51 <monochrom> I think human flexibility and creativity are overrated.  You can surely point at individual great minds who are superior to the best algorithms known.  But bare in mind they represent no more than 1% of humans.  The other 99%, the people on the street, they are just as inflexible and unimaginative as Eliza.
16:13:19 <SamB> Philippa: but it isn't a turing machine, is it?
16:13:21 <JohnMeacham> palomer: nope. humans cannot solve the same things.
16:13:29 <Philippa> palomer: use "initial brain state" for program and the obvious for input?
16:13:44 <Philippa> SamB: they're computer-based ones
16:14:02 <Philippa> a turing machine itself can't, no. A turing machine has neither legs nor the means to communicate with them
16:14:17 <SamB> turing machines don't even have I/O
16:14:42 <astrolabe> palomer: do you beleive there is something in the physics of the brain that is in theory impossible to simulate on a computer?
16:14:49 <palomer> Philippa: ok, then I can prove that for some input i, (turing initialBrainState) will not return the correct result. I cannot make this assertion for humans
16:14:57 <palomer> astrolabe: yeah, randomness
16:14:58 <Heffalump> so on more concrete matters? how complete is JHC these days? I tried to compile it a week or two ago but something went wrong.
16:15:03 <SamB> astrolabe: *what theory*?
16:15:18 <Heffalump> s/matters?/matters,/
16:15:27 <Philippa> palomer: if that's all, that's really not very interesting at all
16:15:34 <astrolabe> SamB: 'in theory' to mean given enough knowledge and computing power.
16:15:36 <Philippa> if nothing else, TMs can emulate non-deterministic TMs...
16:15:38 <JohnMeacham> Heffalump: I am in the process of rewriting the typechecker, it is still in a transitory stage however.
16:15:43 <Philippa> (just not in terms of speed)
16:15:55 <JohnMeacham> Heffalump: to allow rank-n polymorphism and impredicative types.
16:16:28 <palomer> Philippa: there's a distinction between randomness and non determinism
16:16:42 <palomer> Philippa: my previous statement exemplifies this statement
16:16:55 <astrolabe> palomer: you think a finite set of random bits + turing machine could solve a problem that no finite set of pseudo-random bits + turing machine could solve?
16:17:06 <Philippa> palomer: non-det can get you the entire solution space...
16:17:07 <palomer> imagine I had a program that outputs something random, I'll never be able to say "this program cannot solve "blah""
16:17:15 <monochrom> I think many of you have confused "cannot" with "cannot yet".  You have correctly stated that there is no known impossibility results for the human brain.  But that's just not yet.  I am sure when we know enough we'll find out the limits.
16:17:17 <Heffalump> so is the current version (or some recent one) likely to compile significantly more programs than it did a few months ago?
16:17:53 <astrolabe> interesting
16:17:54 <palomer> astrolabe: if when you say solve, you mean solve consistently, then no
16:17:59 <Philippa> palomer: you can, however, say that it can't do with any meaningful frequency
16:18:20 <palomer> monochrom: oh, I'm just saying that the brain cannot be simulated by a turing machine
16:18:33 <monochrom> Have you proved that statement?
16:18:42 <palomer> monochrom: I just gave an argument
16:18:45 <Philippa> OTOH, if the only difference is lack of a random number feed that's really not interesting at all
16:18:56 <palomer> (a very strong argument)
16:19:09 <palomer> but I haven't stated my axioms, or defined my model, so I can't say I've proven it
16:19:12 <JohnMeacham> palomer: I don't see a strong argument actually. what is the argument?
16:19:19 <Philippa> "hey guys, your infinite pile of random numbers is on the left hand side of the starting position, dump your data on the RHS"
16:19:23 <monochrom> Ok I see.
16:19:51 <palomer> type TM = Program -> Input -> Bool
16:19:55 <Philippa> JohnMeacham: QM! Randomness! Lack of thought! Woo!
16:20:06 <palomer> type Human = Input -> Bool
16:20:18 <Philippa> that's just leaving the 'program' implicit
16:20:22 <Philippa> human brains are not all equal
16:20:42 <palomer> ok
16:20:44 <JohnMeacham> palomer: ? no, a universal TM is just Input -> Bool.
16:20:49 <monochrom> What does randomness buy you anyway?
16:21:00 <palomer> ok, fine
16:21:18 <monochrom> Turing machines are not all equal either.
16:21:23 <Philippa> JohnMeacham: BFD, universal TMs are just TMs that emulate other TMs
16:21:27 <palomer> TM = Input -> Bool, JimmysBrain = Input -> Bool
16:21:41 <Philippa> and now you've lost any distinction
16:21:42 <JohnMeacham> monochrom: in terms of computability? nothing, if the machine halts, it can only use a finite number of random numbers which can just be encoded as part of the input state. the complexity theory implications are more interesting.
16:21:48 <astrolabe> 'turing machines + random number generators' do not have non-computable functions.  But I'm not sure that this is an interesting point with respect to theorem proving.
16:21:51 <Philippa> hint: arguing from inside a turing-limited metalanguage won't get you far ;-)
16:22:18 <palomer> Input is some specification language such that TM a = b => b meets the specification
16:22:58 <palomer> there is a specification language strong enough such that there exists i such that TM i will either loop to infinity or return a wrong answer
16:23:15 <palomer> I can prove this
16:23:26 <palomer> I can't prove it for Jimmy's brain
16:23:36 <monochrom> You can't yet.
16:23:48 <palomer> I can't prove it for Jimmy's brain
16:23:55 <palomer> Jimmy might return a random value
16:24:01 <monochrom> But the real question is: can you disprove it?
16:24:06 <Philippa> Jimmy might be dead, too...
16:24:32 <Philippa> you can, however, prove that Jimmy will very very *likely* give the wrong answer
16:24:40 <astrolabe> Do you beleive it might be useful to have access to true randomness?
16:24:54 <Philippa> for some things, yes
16:24:57 <palomer> astrolabe: sure, in cryptography
16:25:04 <Philippa> for others, I'm not sure it makes much difference compared to a reasonable PRNG
16:25:39 <JohnMeacham> palomer: just because you can't prove it, it doesn't mean it isn't provable. it is certaily possible to prove the turing reducability of the human brain. and it is possible to disprove. I can't prove goldbach's that doesn't mean it isn't true.
16:25:59 <JohnMeacham> I should say "I can't prove goldbach's _yet_", I'm still working on that one...
16:26:23 <monochrom> I see palomer's point, and it is right.  But it is insignificant.  Should be comparing randomized TMs with brains.
16:26:32 <palomer> ok, looking at Jimmys brain I cannot find an i such that (JimmysBrain i) loops to infinity or returns the wrong result
16:26:45 <palomer> oh, randomized TMs are another story
16:26:55 <Philippa> monochrom: bingo
16:27:05 <palomer> there is no constructive proof  (which is my original statement!)
16:27:08 <Philippa> palomer: you don't know a damn thing about JimmysBrain, that's why
16:27:15 <Philippa> "construct infinity" is an easy i
16:27:21 <JohnMeacham> I should say, my belief isn't so much about humans, as about physical laws. if we can show the laws of physics are simulatable by a TM then we prove humans are, with the (not too far fetched) assumption that we are physical creatures.
16:27:28 <Philippa> you'll probably get the "wrong" result "fuck that, I'm bored"
16:27:37 <palomer> Philippa: even if I could find out all I wanted about the atoms in JimmyBrain
16:27:54 <Philippa> even then
16:27:56 <palomer> JohnMeacham: but, erm, that goes against quantum mechanics
16:28:13 <Philippa> Jimmy will either say fuck that or die, assuming lack of immortality (failing that, non-termination)
16:28:34 <palomer> Philippa: or he might raise his hands in exasperation and scream "42"
16:28:45 <palomer> I actually think human brains are equivalent to randomized TMs
16:28:54 <astrolabe> quantum mechanics is simulateable.  It is just a linear wave equation and a projection.
16:28:56 <Philippa> palomer: "42" <: "fuck that" :-)
16:29:47 <SyntaxNinja> w00t
16:29:54 <Philippa> what you won't get is something equivalent to Succ (Succ (Succ...))
16:29:57 <monochrom> We can implement randomized TMs.  My laptop with linux already has /dev/random
16:30:30 <palomer> ok, there exists a turing machine that can simulate the universe, but given a TM, we cannot ever show that it's simulating the universe
16:30:46 <palomer> actually wait, I retract that last statement
16:30:56 <palomer> is it possible to simulate the universe with a TM?
16:31:21 <palomer> monochrom: it needs the help of humans!
16:31:58 <Heffalump> monochrom: however your laptop with linux is not a TM
16:32:01 <monochrom> Yes a computer needs to be built.  The interesting question is whether a computer as powerful as a human can be built.
16:32:02 <palomer> astrolabe: I thought that given an atom, it's future positions are based on probability
16:32:07 <palomer> astrolabe: thus randomness
16:32:30 <palomer> monochrom: sure: a human with his hands glued to a keyboard
16:32:34 <JohnMeacham> palomer: there is nothing about quantum mechanics that is inherently non-TM.
16:32:41 <palomer> JohnMeacham: randomness?
16:32:44 <astrolabe> palomer: sure, but you can simulate it, you get probabilities for the different results.
16:32:45 <JohnMeacham> palomer: and quantum mechanics is known to be incomplete.
16:33:12 <monochrom> I don't think we (our civilization) knows enough about the physics of the universe to say how it fares with TMs.  We don't even know whether time and space are continuous.
16:33:34 <palomer> astrolabe: but, erm, if I was going to ask you the state in the future, I don't want an infinite answer
16:34:07 <JohnMeacham> palomer: randomness doesn't add any new capabilities to computability. and QM 'random' is a failure of our observational capabilities, not of the underlying process.
16:34:18 <Twigathy> palomer astrolabe: I thought that given an atom, it's future positions are based on probability <--- Hitchikers Guide to the Galaxy refrence, anyone?
16:34:55 <Philippa> Twigathy: DNA got the idea from the physics, more likely
16:34:56 <palomer> JohnMeacham: randomness at least gives us the ability not to be simulated by a TM
16:34:59 <palomer> which is fine by me.
16:35:11 <JohnMeacham> palomer: but QM is not necesarily random.
16:35:16 <Philippa> or so you think. How do you know you're not in one now?
16:35:31 <JohnMeacham> palomer: and QM is known to not be complete and not correct.
16:35:33 <Philippa> I mean, aside from not having a Neo or a Morpheus in here?
16:35:59 <astrolabe> I'm fascinated by QM and many-worlds
16:36:01 <palomer> JohnMeacham: if we agree that future atom positions cannot be predicted with 100% accuracy, then we get the result we want
16:36:03 <JohnMeacham> palomer: and we are horribly overloading the term 'random'.
16:36:47 <JohnMeacham> palomer: not true at all, we can't predict the result of certain algorithms before they terminate, that doesn't mean the algorithm doesn't exist and is simulated on a TM.
16:37:51 <palomer> what's not true at all?
16:38:45 <JohnMeacham> our lack of ability to observe something does not mean that something doesn't exist.
16:39:03 <palomer> paste the statement you're contradicting
16:39:17 <JohnMeacham> palomer: that if we don't have the ability to predict something then it must not be TM.
16:39:29 <palomer> given an atom, it is impossible to predict its position. given an algorithm, it may be possible to predict its output
16:39:52 <JohnMeacham> and given the right algorithm, one can predict an atoms position.
16:40:06 <JohnMeacham> we cannot _observe_ an atoms position, QM says nothing about predicting it.
16:40:16 <palomer> are you sure about that?
16:40:28 <JohnMeacham> http://en.wikipedia.org/wiki/Interpretation_of_quantum_mechanics  - has a very interesting chart on the subject. 
16:40:37 <palomer> hrmph
16:40:39 <palomer> I'm getting tired 
16:40:40 <JohnMeacham> palomer: quite. 
16:40:41 <palomer> nap time
16:41:02 <palomer> anyways, we really should be discussing haskell related things in here
16:41:04 <JohnMeacham> I mean, QM doesn't give a method of predicting it, but it doesn't rule out the posibility.
16:41:09 <JohnMeacham> haskell is a TM>
16:41:11 <JohnMeacham> :)
16:41:14 <Heffalump> JohnMeacham: in that case would any TM simulation of physics be falsifiable?
16:41:22 <palomer> well, if the state of the universe can be predicted with an earlier state, then everything is turing simulatable
16:41:24 <palomer> but I doubt it.
16:44:17 <JohnMeacham> I should say that I actually don't know whether the universe is TM. my intuition says 'yes', but since it is a provable statement, there is no need to form an opinion on it, we will eventually know one way or the other.
16:45:02 <astrolabe> How is is provable?
16:45:53 <JohnMeacham> astrolabe: show humans can compute something incomputable or show humans can be simulated by a turing machine.
16:46:10 <JohnMeacham> come up with a TOE that is turing computable.
16:46:39 <JohnMeacham> or one that provably isn't
16:46:42 <astrolabe> But physics theories can't be proved to describe the world.
16:47:11 <JohnMeacham> astrolabe: well, now we get into philosophy. proved as much as we can prove anything.
16:47:47 <astrolabe> I'm going to have that past without an argument.  It's my bed time :)
16:47:47 <JohnMeacham> this will quickly degrade into descartes and solipsism if we follow this path :)
16:47:52 <Heffalump> but we can prove mathematical statements in a much better way than we can prove physical theories
16:48:28 <Heffalump> because with mathematical statements we're allowed to first specify the axioms
16:49:59 <JohnMeacham> personally, I am a big fan of the holographic principle at the moment. 
16:51:19 <JohnMeacham> In any case, even if we can't prove things about the physical universe, I think we can prove things with enough degree to figure out the limitations of a programmer to optimize their haskell programs.
16:52:39 <Heffalump> I still maintain that the real issue is that \forall compiler . \exists program . compiler cannot optimise program appropriately
16:53:22 <JohnMeacham> certainly, that is a consequence of the halting problem. but it is not necesarily true that a human can do better.
16:53:35 <Philippa> humans're easier to find than compilers though
16:53:54 <JohnMeacham> I think we should switch to base 12 and plank units.. I will bring this up if anyone suggests we move to the metric system...
16:54:13 <Heffalump> I still maintain that the real issue is that \forall compiler . \exists human . human can write program that compiler cannot optimise appropriately
16:54:32 <Heffalump> s/I still maintain that the real issue is that //
16:54:56 <JohnMeacham> Heffalump: but what about the converse? compilers already can find a lot of things human's can't. run ghc with -fext-core and see what it figures out that you didn't. a lot.
16:55:31 <Philippa> JohnMeacham: but are your pints the right size?
16:55:36 <Heffalump> yes, but that's not relevant to my point, which is that programmers will sometimes demand optimisation guarantees.
16:56:02 <Heffalump> and removing everything from the language and leaving it to the compiler to solve undecidable problems means they don't get them.
16:57:10 <JohnMeacham> Heffalump: oh, I never disagreed with that. but allocating something on the stack/heap is not one that is worth the programmers time was my assertion.
16:57:38 <JohnMeacham> Heffalump: I should asy, I don't disagree with it on a practical scale. on a philosophical one, my opinions differ.
16:57:51 <Heffalump> it could make an immense difference in the tight inner loop of a program
16:58:13 <Heffalump> though admittedly you probably wouldn't be using Java if you wanted fast tight inner loops.
16:58:25 <Philippa> TCO'd be more relevant there, no?
16:58:30 <Heffalump> for some programs, heap turnover is a performance killer
16:58:31 <Heffalump> TCO?
16:58:36 <Philippa> tail call optimisation
16:58:49 <JohnMeacham> Heffalump: indeed. and compilers are very good at figuring that sort of thing out. especially in tight inner loops. except for ghc, which seems to have trouble with tight inner mathematical loops as I mentioned on a recent mail to the list..
17:00:31 <Heffalump> well, in practice Java implementations do no escape analysis at all, even on things that the programmer cannot specify to go on the stack
17:02:19 <JohnMeacham> oh. my pint is 1.1211217e+101 big.
17:02:36 <Heffalump> anyway, /me takes himself to bed
17:02:42 <SamB> 1.1211217e+101 what big?
17:02:59 <JohnMeacham> units. planck units have no dimension.
17:03:00 <Heffalump> 1.211217e+101 icklepints
17:03:04 <Philippa> one of the deficient US pints?
17:03:18 <JohnMeacham> http://en.wikipedia.org/wiki/Planck_units
17:03:35 <Heffalump> where an icklepint is 0.8256159e-101 pints
17:04:30 <JohnMeacham> heh. I like this quote "...We see that the question [posed] is not, "Why is gravity so feeble?" but rather, "Why is the proton's mass so small?" For in Natural (Planck) Units, the strength of gravity simply is what it is, a primary quantity, while the proton's mass is the tiny number [1/(13 quintillion)]"
17:05:45 <dons> Moin
17:06:49 <Heffalump> bloody hell, the temperature 1 is huge
17:07:08 <JohnMeacham> hmm.. we should summarize this entire discussion as an algebraic data type so we are back on topic.
17:07:56 * Heffalump really goes to bed
17:07:59 <JohnMeacham> since these are God's units then heaven must be very hot indeed. I wonder what hell is like then...
17:08:21 <SamB> JohnMeacham: on topic, off topic, its all OT
17:09:11 <chucky> JohnMeacham: If they are God's units but are called Planck units, who does that make Planck? :)
17:10:23 <JohnMeacham> observant.
17:10:39 <monochrom> haha
17:11:14 <chucky> quantum physics is a lot more fun when you don't have to actually perform any calculations
17:32:14 <araujo> dons, ping
17:32:26 <dons> yo
17:32:34 <araujo> heya dons 
17:33:01 <araujo> dons, priv?
17:33:58 <dons> go for it
17:34:04 <araujo> :-)
17:38:39 * jips ponders about yampa
18:27:44 <gizban> is there a function that generates something like    func [0,0,0,0,0] [1,2,3]   results in   [1,2,3,0,0] ?
18:30:38 <palomer> sure, let func x = [1,2,3,0,0]
18:31:18 <gzl> > let f xs ys = xs ++ drop (length xs) ys in f [1,2,3] [0,0,0,0,0]
18:31:20 <lambdabot> [1,2,3,0,0]
18:31:22 <gzl> like that?
18:31:40 <gizban> yeah, thanks
18:31:49 <gzl> np
18:32:11 * palomer can't wait to implement unification tomorrow
18:34:00 <palomer> how would you guys generate an infinite list of unique strings?
18:34:43 <palomer> @hoogle get
18:34:45 <lambdabot> Text.ParserCombinators.ReadP.get :: ReadP Char
18:34:45 <lambdabot> Text.ParserCombinators.ReadPrec.get :: ReadPrec Char
18:34:45 <lambdabot> Control.Monad.State.get :: MonadState s m => m s
18:37:23 <dons> @type map show [1..]
18:37:25 <lambdabot> [String]
18:37:29 <dons> like that :)0
18:37:57 <palomer> why the blazes does Data.Map export map?
18:38:20 <palomer> oh wait, it doesn't
18:39:53 <SamB> @type Data.Map.map
18:39:54 <lambdabot> forall b k a. (a -> b) -> Data.Map.Map k a -> Data.Map.Map k b
18:39:59 <SamB> sure it does ;-)
18:40:10 <palomer> grrr
18:40:14 <palomer> why doesn't everyone just use fmap
18:40:17 <palomer> @type fmap
18:40:18 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
18:40:25 <SamB> import qualified Data.Map as M
18:40:45 <araujo> @index seq
18:40:46 <lambdabot> Prelude, Control.Parallel
18:40:52 <palomer> @kind Control.Monad.MonadState
18:40:54 <lambdabot>   Not in scope: type constructor or class `Control.Monad.MonadState'
18:41:03 <palomer> @hoogle MonadState
18:41:05 <lambdabot> Control.Monad.State.MonadState :: Monad m => MonadState s m
18:41:12 <palomer> @kind Control.Monad.State.MonadState
18:41:14 <lambdabot> Class `Control.Monad.State.MonadState' used as a type
18:41:55 <SamB> yeah, that *is* annoying
18:42:03 <SamB> we should totally report it to ghc-bugs
18:42:43 <palomer> ghc claims it doesn't export it
18:42:51 <palomer> I don't believe it though
18:43:40 <palomer> nevermind
18:43:41 <palomer> :o
18:44:04 <palomer> ok, I want to write a function getNextVar such that x <- getNextVar gets the next variable and changes the state
18:44:07 <palomer> all in one shot
18:44:09 <palomer> can this be done?
18:45:29 <SamB> for certain definitions of "in one shot", probably ;-)
18:45:56 <Lemmih> Sure it can.
18:46:22 <palomer> myGet k = do {y <- get;             set (tail y);             k y}
18:46:52 <palomer> however, for some reason , set is not in scope
18:47:07 <Lemmih> That's because it's called 'put'.
18:47:11 <palomer> :P
18:50:15 <araujo> @index error
18:50:15 <lambdabot> Prelude
18:50:35 <SamB> what is this thing with needing wires installed to get internet?
18:50:43 <araujo> error will automatically abort the programm ?
18:52:01 * araujo apparently found the dark bug
18:53:39 <palomer> araujo: nope
18:54:01 <palomer> > Just (error "hello")
18:54:02 <lambdabot> Add a type signature
18:54:09 <palomer> why?
18:54:12 <palomer> you stupid bot
18:54:27 <palomer> > Just (error "hello") :: Maybe Int
18:54:29 <lambdabot> Exception: hello
18:54:30 <SamB> well.
18:54:36 <araujo> mmm.....
18:54:36 <palomer> oh my
18:54:49 <SamB> > [erorr "hello"] :: String
18:54:50 <lambdabot>  Not in scope: `erorr'
18:54:55 <SamB> > [error "hello"] :: String
18:54:56 <lambdabot> Exception: hello
18:55:22 <palomer> SamB: I thought that K undefined -> K undefined
18:55:22 <SamB> > [error "hello"] :: [Int]
18:55:23 <lambdabot> Exception: hello
18:55:25 <palomer> where K is a constructor
18:55:37 <palomer> [undefined]::String
18:55:41 <palomer> > [undefined]::String
18:55:43 <lambdabot> Undefined
18:56:10 <SamB> I think the eval thingy is being wonky or something...
18:56:20 <palomer> the myGet function I defined up there doesn't work:o
18:56:44 <dons> SamB?
18:57:02 <palomer> it's probably show that's screwing everything up
18:57:18 <dons> show will force things.. so expect undefs.
18:57:24 <dons> > fst (1,undefined)
18:57:25 <lambdabot> 1
18:57:27 <dons> > (1,undefined)
18:57:29 <lambdabot> Add a type signature
18:57:34 <dons> > (1,undefined) :: (Int,())
18:57:35 <lambdabot> Undefined
18:58:57 <monochrom> > ['c', 'd', undefined]
18:58:59 <lambdabot> Undefined
18:59:22 <monochrom> heh
18:59:34 <palomer> anyways, (1,undefined) is a value
18:59:39 <monochrom> yes
18:59:49 <palomer> wait, that means that read is not a left inverse!
18:59:52 <palomer> ho ho ho
19:01:01 <monochrom> as in read(show _|_) is not _|_ ?
19:01:25 <palomer> read (show (1,_|_)) = _|_
19:01:39 <palomer> @hoogle print
19:01:40 <lambdabot> Prelude.print :: Show a => a -> IO ()
19:01:40 <lambdabot> System.IO.print :: Show a => a -> IO ()
19:01:40 <lambdabot> Text.Printf.Print :: Print
19:01:45 <monochrom> I see. ou're right.
19:01:59 <araujo> palomer, you sure?
19:02:06 <araujo> It looks like error aborts the programm here.
19:02:18 <monochrom> You are right too.
19:02:55 <palomer> well, erm, if you try to evaluate or apply _|_ you get _|_ back
19:03:21 <palomer> so it may seem to abort the program
19:03:38 <palomer> grr
19:03:40 <palomer> how do you print strings?
19:03:45 <monochrom> show (1,_|_) is going to be ['(', '1', ',', _|_)] I think?
19:03:57 <palomer> @hoogle String -> IO ()
19:03:59 <lambdabot> Debug.Trace.putTraceMsg :: String -> IO ()
19:03:59 <lambdabot> Prelude.putStr :: String -> IO ()
19:03:59 <lambdabot> Prelude.putStrLn :: String -> IO ()
19:04:52 <palomer>  show (1,undefined)
19:04:52 <palomer> "(1,*** Exception: Prelude.undefined
19:07:09 <palomer> yeah
19:07:17 <palomer> gotta run
19:07:23 <monochrom> > let (x,y) = read $ show (True,undefined) :: (Bool,Bool) in x
19:07:25 <lambdabot> Add a type signature
19:07:40 <monochrom> > let (x,y) = read $ show (True,undefined::Bool) :: (Bool,Bool) in x
19:07:42 <lambdabot> Undefined
19:07:52 <monochrom> Now that is oh well.
19:08:47 <monochrom> > let x:_ = read $ show [True,False,undefined] :: [Bool] in x
19:08:48 <lambdabot> Undefined
19:08:54 <monochrom> That's also gay.
19:09:43 <monochrom> Oh right, read wants to see the ending ) or ] before it returns.
19:09:49 <araujo> @index IOError
19:09:50 <lambdabot> System.IO.Error, Prelude
19:10:01 <araujo> @type Prelude.IOError
19:10:02 <lambdabot> Not in scope: data constructor `Prelude.IOError'
19:10:40 <monochrom> > let x:_ = read $ show ['c','d',undefined] :: String in x
19:10:42 <lambdabot> Undefined
19:11:09 <monochrom> This one wants to see the ending "
20:36:13 <newsham> hi
20:37:04 <newsham> Can anyone think of a simpler way to do this?  http://lava.net/~newsham/x/wrapzip.lhs
20:37:19 <newsham> basically take items from two lists in order until all combinations are taken
20:43:50 <Korollary> newsham: 'align' is a strange name for that. 
20:44:28 <Cale> > liftM2 (,) [1,2,3] [4,5,6]
20:44:29 <lambdabot> [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
20:44:59 <Cale> sorry, I didn't look at what it did :)
20:45:12 <Cale> repeatList is called cycle
20:49:00 <Cale> er, yeah, liftM2 does the same thing up to permutation of the lists
20:49:03 <Cale> listM2 (,)
20:49:07 <Cale> liftM2 (,)
20:52:17 <Korollary> @type liftM2
20:52:19 <lambdabot> Not in scope: `liftM2'
20:52:25 <Korollary> @type Control.Monad.liftM2
20:52:26 <lambdabot> forall r (m :: * -> *) a2 a1.
20:52:26 <lambdabot> (Monad m) =>
20:52:26 <lambdabot> (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
20:53:09 <Korollary> > liftM2 (+) (Just 1) (Just 2)
20:53:11 <lambdabot> Just 3
20:53:58 <newsham> korollary: whats a better name?
20:54:05 <newsham> coprimePadding?
20:54:06 <Korollary> I wonder how these type variable names are chosen. "a1", "a2", "r".
20:55:15 <Korollary> newsham: yeah, it should somehow include the notion of primes. Just by align I think of somehow shifting the elements in the lists that at the same index you have the same values.
20:55:45 <Cale> Korollary: from what I can tell, they're constructed roughly from type variable names used in the type signatures of things, but numbers are added sometimes when things get repeated
20:56:53 <newsham> renamed to coprimePadCnt
20:57:36 <newsham> besides little things (ie. using cycle), are there any smarter ways to approach the whole problem?
20:58:34 <Korollary> Cale: I think ghc should do a simplification at the final step and rename them to a, b, c's.
21:08:04 <Saulzar> Hmm, chances are a human can name them better than a, b, c 
21:12:23 <fnord123> the topic is still 'the language choice for descriminating hackers'
21:12:45 <fnord123> im interested in why dylan, praised in the same contest where the quote came from, is supposedly slow
21:12:54 <fnord123> or at least, implementations thereof are
21:13:21 <SamB> fnord123: what, did we lose an ICFP or something?
21:13:48 <fnord123> we = ?; ICFP = ?
21:14:39 <Korollary> dylan is a lisp dialect with non-lisp syntax, iirc.
21:14:50 <fnord123> thats what i thought
21:15:20 <fnord123> i found a site that seems to imply dylan was compiled by MCL. maybe the macro'ing was why it was slow
21:15:26 <fnord123> i wonder how today's versions fare
21:16:55 <newsham> *sigh*
21:17:21 <Korollary> also, iirc, the dylan entries have been submitted by the same group of hackers year after year. It's a bit biased in that sense.
21:18:57 <Korollary> I'd bet that if you withdrew one haskell entry every year, it would still fare well.
21:19:24 <dons> yeah, the free dylan compiler maintainers are the guys who win each time
21:19:46 <dons> i don't know if any other dylan entries actually get submitted
21:21:25 <Korollary> I looked at the post-contest presentation slides, and I think there were several haskell entries, and a lot fewer dylan entries, possibly just one.
21:23:12 <Korollary> and it was a lot of code to write. I was surprised how big the task was.
21:24:58 <Korollary> woah. k-nucleotide...
21:33:01 <Korollary> when the input size grows by 10x, the c entry cpu usage grows by 4x, and the memory usage grows by 2x. GHC#1 cpu & mem usages grow by 10x.
21:59:14 <araujo> What is the '[' used in haskell of?
22:29:38 <dons> ?
22:31:10 <fnord123> begins a list
22:31:22 <fnord123> or tuple or something. im off to bed
22:31:59 <araujo> Apart from that...
22:32:52 <araujo> dons, btw, found the bug
22:32:59 <araujo> definetly, seq is not the same than evaluate
22:33:19 <dons> yep.
22:33:49 <dons> -- >   evaluate undefined `seq` return ()  ==> return ()
22:33:49 <dons> -- >   catch (evaluate undefined) (\e -> return ())  ==> return ()
22:33:49 <dons> --
22:33:49 <dons> -- NOTE: @(evaluate a)@ is /not/ the same as @(a \`seq\` return a)@.
22:33:55 <dons> :)
22:39:50 <lisppaste2> Korollary pasted "Quick IO?" at http://paste.lisp.org/display/15452
22:40:21 <Korollary> Would the hack I just posted work?
22:41:55 * Saulzar wonders why it would do anything similar to putChar
22:42:02 <Korollary> it's not supposed to
22:42:35 <Saulzar> What is it supposed to do?
22:42:48 <Korollary> It's supposed to fake printing a char without printing.
22:43:35 <Saulzar> Why the System.getProg ... buisiness?
22:43:59 <Korollary> I couldn't think of another action that looked like it did i/o, but in fact didn't.
22:44:45 <Korollary> I mean not involving i/o channels. I suppose I could have used an IOArray as well.
22:45:10 <Korollary> that could be even quicker
22:45:11 <araujo> return 1 :: IO Int ?
22:47:51 <Korollary> araujo: I thought something like just "return ()" would be optimized away
22:48:16 <Korollary> let's see
22:48:37 <Saulzar> Seems not quite instantaneous with "return ()"
22:49:00 <Korollary> it's not
22:49:07 <Korollary> that's simpler at least
22:51:58 <Korollary> ok, in this case I don't understand why the mandelbrot entry is still 10x slower than the C entry. It's almost 100% cpu.
23:45:09 <dons> K, you looking at my suggested mandlebrot on the wiki?
23:45:32 <dons> I couldn't work out why it was still slower than SML. :/
23:46:51 <palomer> there must be an easier accumulator than foldl
23:47:02 <palomer> if you're not using your accumulator in the folding
23:47:05 <palomer> @hoogle accumulate
23:47:06 <lambdabot> No matches found
23:51:46 <dons> if you're not using the accumulator? what's the type?
23:51:53 <dons> @pl \(q,r,s,t) x -> (f q * f r + f x) `div` (f s * f t + f x)
23:51:54 <lambdabot> (line 1, column 6):
23:51:54 <lambdabot> unexpected ","
23:51:54 <lambdabot> expecting letter or digit, operator or ")"
23:51:54 <lambdabot> ambiguous use of a non associative operator
23:52:01 <Korollary> dons: Yeah. Everything is strict. No lists. Nothing to slow it down. Weird.
23:52:43 <dons> @pl \x -> (f q * f r + f x) `div` (f s * f t + f x)
23:52:44 <lambdabot> ap (div . (f q * f r +) . f) ((f s * f t +) . f)
23:57:12 <palomer> likehttp://www.rafb.net/paste/results/r5losv75.html
23:57:35 <palomer> http://www.rafb.net/paste/results/XifdRO81.html
23:57:42 <palomer> I get a weird type error
23:57:45 <palomer> don't get it
23:58:38 <Cale> what's the type sig for getNext?
23:58:54 <palomer> lemme find out
23:59:39 <palomer> err, well I can't
23:59:42 <palomer> since it won't compile
23:59:50 <palomer> it was working fine before
