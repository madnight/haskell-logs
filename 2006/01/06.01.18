00:51:38 <ProfTeggy> Moin
00:56:10 <musasabi> morning
01:23:39 <AllenJB> arg - spaces between URLs in the topic would be nice!
01:25:40 <lome> hi! is there a ready function to cut a subarray from array using range:
01:25:40 <lome> Ix a => Array a b -> [a] -> Array a b
01:25:40 <lome> or I have to use something like:
01:25:40 <lome> array (m,n) $ filter (inRange rng . fst) $ assocs $ arr
01:25:40 <lome> ?
01:38:07 <bringert> dons: I've added a new slower k-nucleotide entry :-) at http://haskell.org/hawiki/KnucleotideEntry
01:38:37 --- topic: set to '["Haskell is still the language of choice for discriminating hackers", "logs: http://tunes.org/~nef/logs/haskell/", "http://www.haskell.org/learning.html", "http://www.haskell.org/tmrwiki/IssueFive", "We put the Funk in Funktion", "http://sequence.complete.org/hwn/20051129", "HCAR 11/2005: http://haskell.org/communities/"]' by gour
01:41:25 --- topic: set to '"Haskell is still the language of choice for discriminating hackers" | "logs: http://tunes.org/~nef/logs/haskell/" | "http://www.haskell.org/learning.html" |, "http://www.haskell.org/tmrwiki/IssueFive" | "We put the Funk in Funktion" | "http://sequence.complete.org/hwn/20051129" |"HCAR 11/2005: http://haskell.org/communities/"' by gour
01:41:35 <Lemmih> gour: urk.
01:41:51 <gour> Lemmih: why it does not work?
01:42:08 <Lemmih> I don't think lambdabot can parse that.
01:42:22 <gour> Lemmih: :-(
01:42:30 <gour> Lemmih: it's so simple
01:42:44 <Lemmih> Send a patch (:
01:43:18 <gour> Lemmih: i'll try to trick her 1st :-)
01:44:07 <Lemmih> @topic-snoc #haskell test
01:44:08 <lambdabot> Topic does not parse. Should be of the form ["...",...,"..."]
01:44:26 <Lemmih> gour: She doesn't like it.
01:47:09 <musasabi> An oer like topic-plugin would be nice.
01:49:21 <gour> Lemmih: she is too much. does not like topic and neither makes urls properly separated
01:49:35 <gour> Lemmih: let me try again..
01:50:52 <Lemmih> gour: How about sending a patch that'll make her use something else than read/show?
01:51:36 --- topic: set to '["Haskell is still the language of choice for discriminating hackers", "logs:", "http://tunes.org/~nef/logs/haskell/", "http://www.haskell.org/learning.html", "http://www.haskell.org/tmrwiki/IssueFive", "We put the Funk in Funktion", "http://sequence.complete.org/hwn/20051129", "HCAR 11/2005:", "http://haskell.org/communities/"]' by gour
01:52:09 <Lemmih> @topic-snoc #haskell test
01:52:10 --- topic: set to '["Haskell is still the language of choice for discriminating hackers","logs:","http://tunes.org/~nef/logs/haskell/","http://www.haskell.org/learning.html","http://www.haskell.org/tmrwiki/IssueFive","We put the Funk in Funktion","http://sequence.complete.org/hwn/20051129","HCAR 11/2005:","http://haskell.org/communities/","test"]' by lambdabot
01:52:18 <Lemmih> @topic-init #haskell
01:52:19 --- topic: set to '["Haskell is still the language of choice for discriminating hackers","logs:","http://tunes.org/~nef/logs/haskell/","http://www.haskell.org/learning.html","http://www.haskell.org/tmrwiki/IssueFive","We put the Funk in Funktion","http://sequence.complete.org/hwn/20051129","HCAR 11/2005:","http://haskell.org/communities/"]' by lambdabot
01:52:32 <gour> huh, now it's even better
01:52:46 <Lemmih> Back to normal (:
01:52:54 <neologism> I would use lambdabot to store that urls
01:53:00 <neologism> and have short topic
01:53:01 <gour> Lemmih: isn't it shame for Hakell community to have such a parser?
01:53:25 <Lemmih> gour: It is?
01:55:28 <gour> Lemmih: well, one  cannot (at least my irc client" select particular url from the topic. how about you?
01:55:38 <gour> Lemmih: and this is welcome to newcomers :-(
01:56:51 <gour> Lemmih: if i'd have your (don't think just about yourself) skills, i'd make it speak & fly :-)
01:56:56 <Lemmih> Yeah. That we don't have spaces in our topic list will definitely make all newcomers think Haskell sucks.
01:57:34 <gour> can you select individual topic and launch in browser?
01:58:22 <Lemmih> Yeah, actually.
01:58:45 <gour> i cannot select logs url :-( :-/
01:58:52 <Lemmih> The point of lambdabot is that it's not perfect. It's meant to be a fun thing for newbies to hack on.
01:59:16 <Lemmih> gour: Neither can I but that's because it has a '~' in it.
01:59:24 <gour> look e.g. evolution topic:
01:59:25 <gour>  Topic for #evolution is Stable: Evolution 2.4.2.1, e-d-s 1.4.2.1 | Unstable: Evolution 2.5.5| http://go-evolution.org/Evo2.6 | http://gnome.org/projects/evolution/
01:59:41 <Lemmih> gour: Go hack it. It's not hard.
02:00:34 <gour> Lemmih: maybe attention of haskell community should be brought from shootout to the lambda, at least for a fraction of second
02:01:01 <gour> cause people seeing ghc ranking will jump straight to #haskell :-)
02:02:41 <Lemmih> I think you're missing the point of lambdabot.
02:03:52 <gour> Lemmih: yeah, maybe. can you enlighten me a bit ;)
02:12:49 <Lemmih> lambdabot is flawed to encourage patches from Haskellers who seek a small, easy and (most importantly) real-world task.
02:15:43 <gour> lambdabot: you're a very smart guy. however i'm at 15th chapter of thompson's book and didn't encounter I/O so far :-)
02:17:32 <gour> ahh...
02:17:42 <gour> Lemmih: you're a very smart guy. however i'm at 15th chapter of thompson's book and didn't encounter I/O so far :-)
02:17:49 <Lemmih> lambdabot: You better wear something more feminine; gour just mistook your for a guy.
02:17:57 * gour made an offense towards lambdabot
02:18:18 <Lemmih> heh (:
02:18:19 * gour sincerely apologize
02:18:36 <araujo> Good morning.
02:18:42 <Lemmih> Hiya araujo.
02:18:50 <araujo> Hello Lemmih 
02:18:55 <araujo> What's up?
02:20:46 <Lemmih> Got rejected from college, pondering whether to hack conjure or something else and replying to some emails. You?
02:24:28 <gour> Lemmih: recently rejected?
02:25:23 <Lemmih> Yep. Got the rejection letter yesterday.
02:25:49 <Lemmih> Anyhow, I'm off to find food and/or video entertainment.
02:26:21 <pesco> What's with the isolated "logs:" entry in the topic? That makes no sense!
02:26:38 <Saulzar> Goes with the next url...
02:27:29 <araujo> Lemmih, rejected?!?
02:27:35 <pesco> Hm. I see...
02:27:39 <araujo> Lemmih, why dude?
02:27:51 <pesco> gour: You changed it to help your IRC client select the urls?
02:28:46 <gour> pesco: Lemmih brought it back to initial
02:28:59 <gour> Lemmih: what happened?
02:29:00 <araujo> "I realized during
02:29:00 <araujo> this activity that side effects are important, because you cannot
02:29:00 <araujo> really do graph operations without side effects"
02:29:04 <Lemmih> araujo: I'm a high school drop out.
02:29:16 <araujo> http://www.sgi.com/tech/stl/drdobbs-interview.html
02:29:17 <pesco> gour: Hm, oh, ah well, whatever.
02:29:35 <araujo> Lemmih, That's why i hate institutionalized education.
02:29:41 <gour> pesco: can you select e.g. logs url from the topic?
02:30:00 <pesco> gour: Yes, gnome-terminal does a good job. It even copes with line-breaks.
02:30:20 <araujo> They usually care more about papers not about knowledge.
02:30:30 <gour> pesco: i'm using xchat-gnome and it is confused
02:31:05 <pesco> gour: *shrug* try irssi! ;-)
02:31:24 * gour likes vedic system which only takes care about qualities of the student and the fee is required for education
02:31:26 <pesco> I'm very happy since my IRC window doesn't take up all that space any more.
02:32:15 <gour> pesco: well, i like xchat-gnome, it has some handy features like osd, spell...
02:33:19 <pesco> I just read about the Bauhaus philosophy yesterday and found that it matches my views pretty well. Only they didn't yet apply it to Informatics back then. ;)
02:33:46 <pesco> gour: Oh, I never used those. What does osd do?
02:35:05 <gour> pesco: pops-up a small window when something interesting happens on the channel, so you can have your irc client minimized
02:35:46 <gour> pesco: see e.g. how it works in konversation (kde) http://konversation.berlios.de/docs/cfg-osd.html
02:36:07 <pesco> gour: Hm, not sure I would like that. I mostly don't like things made popping into my face...
02:36:35 <gour> pesco: here is xchat-gnome site http://xchat-gnome.navi.cx/
02:36:56 <gour> pesco: well, you don't have to, it is option
02:37:27 <gour> pesco: i like it when i'm away and come back, can quickly see someone responded to my 'ping' or so
02:37:45 <gour> Lemmih: what is conjure?
02:38:35 <pesco> gour: irssi does it by showing you a list of windows that have had activity. If any have a message for me, their number is displayed in a bright color.
02:39:12 <Lemmih> gour: A bittorrent client written in Haskell.
02:39:39 <pesco> I need to get into the UI-business and design programs that all behave as sanely (to my standards) as irssi.
02:40:02 <pesco> The only thing irssi is insane about is UTF-8 handling. Oh, and it could use noticing when the terminal background is white instead of black.
02:42:20 <gour> pesco: i need utf-8 and like tree view
02:43:04 <pesco> gour: don't misunderstand, irssi can handle utf-8 perfectly. It just doesn't look at your locale to find out whether to use it, so you have to change a setting manually.
02:44:19 <gour> Lemmih: why don't you code hIDE and ask for sponsorship (e.g. like vim)?
02:45:11 <gour> pesco: ok, i like gnome (switched some time ago after using kde since '99) and its terminal, but will (probably) stay with xchat-gnome. it does all i need
02:45:56 <pesco> gour: Suit yourself. :)
02:46:19 <gour> pesco: but, thanks for telling me your client can catch all the urls from the topic. now i can bug xchat-gnome devs :-)
02:47:07 <pesco> gour: Yeah! Give #haskell as a test-case. ;)
02:53:47 <gour> pesco: sure
02:54:17 <eivuokko> Is GHC's Foreign.Storable Char unicode enabled?
03:00:04 <eivuokko> Ah...it is.  How...suprising how peekArray "works" ;)
03:13:07 <Lemmih> gour: sponsorship?
03:13:40 <gour> Lemmih: yep. i have to go to take a lunch. they're waiting me. bbl. pls. excuse me
03:14:17 <Lemmih> No problem.
03:15:37 <pesco> Depressing, even a completely imperatively-written routine, looping through vector addition a couple of thousand times, where the vectors are IOUArrays, still runs about 20x as long as the C equivalent. :(
03:16:24 <pesco> Can somebody here run a benchmark of this on an x86 machine for me?
03:17:52 <Saulzar> Sure
03:18:05 <pesco> Saulzar: I'll send you the code, email?
03:22:37 <pesco> Saulzar: Thanks! Sent.
03:26:11 <pesco> Oh, hah! I'm proving myself stupid again. The problem was just that the debian ghc packages are built unregisterised (as I recently learned).
03:26:44 <pesco> With a self-built ghc, I'm down to about 3x.
03:29:36 <Saulzar> Hmm, I see the 20x figure, or more like 40x..
03:29:54 <Saulzar> With  2000000 iterations 10  - what were you using?
03:32:23 <pesco> 1000 iterations 100
03:33:00 <Saulzar> Hmm, that finishes almost immediately for me
03:33:50 <Saulzar> 0.002 seconds +- 0.002 :)
03:34:19 <Saulzar> and 0.030 for ghc
03:37:53 <Saulzar> Hmm
03:41:32 <pesco> Saulzar: Okay, gcc takes about 5 seconds for 10000 elements 10000 on this machine.
03:41:52 <pesco> Saulzar: ghc uses 35 seconds.
03:42:41 <Saulzar> Hmm, gcc 0.5 seconds, ghc 15 seconds
03:43:49 <gour> Lemmih: i'm back..
03:44:06 <gour> Lemmih: have you got my pm?
03:44:16 <Saulzar> That's pretty poor, the GHC shootout entries seem to be not-significantly worse than C...
03:44:49 <Lemmih> gour: Yeah.
03:44:56 <Saulzar> But it seems like the direct equivalent, I wonder if all the monad overhead is the issue
03:45:06 <pesco> Saulzar: Hm. This is admittedly an extreme case, but still, I thought GHC was able to produce really good code with such an imperative style.
03:45:08 <Saulzar> (If indeed there is any)
03:45:21 <Saulzar> You'd have to ask somone who knew something about it :)
03:45:38 <pesco> Saulzar: Do you have jhc by any chance? (Or somebody?)
03:45:57 <pesco> My ghc chokes on it during linking, I'm suspecting it's a platform issue also.
03:46:34 <pesco> Saulzar: Your numbers are indeed poor. Did you compile with optimizations?
03:47:12 <pesco> Saulzar: Since I'm measuring only a 7x tiff.
03:47:25 <pesco> s/tiff/diff/
03:47:30 <Saulzar> Yeah, plain -O3 for gcc and -O2 -fvia-C -optc-O3 
03:48:12 <pesco> Saulzar: Ah, hm, I forgot -O3 for gcc, I thought it did it by default.
03:48:15 <Saulzar> -fasm gives 13 seconds...
03:48:30 <Saulzar> Ah, nope
03:49:39 <pesco> Okay, now with -O3 I'm at ~11x.
03:49:41 <gour> Lemmih: ok
03:51:08 <pesco> Saulzar: Not bad, -fasm is 13 seconds faster?
03:51:54 <Saulzar> No, 13 seconds absolute
03:52:01 <Saulzar> So, 2 seconds faster :)
03:52:37 <pesco> Ah, right. :) 
03:53:51 <pesco> Okay, -fasm gives only one second for me.
03:54:13 <pesco> one second better, that is.
03:54:49 <pesco> So okay, thanks a lot for measuring!
03:57:47 <pesco> Hah, just the right person to ask. Maybe?
03:59:47 <pesco> JaffaCake: I'm running GHC and GCC head-to-head, adding a bunch of IOUArray-Vectors really fast. GHC takes about 11x as long for 1000 iterations with 100000 element-vectors. How does that compare to your experience/expectations?
04:00:15 <JaffaCake> it shouldn't be that bad, I think
04:00:21 <pesco> JaffaCake: I think I've written the Haskell code as imperative and bare-metal as it gets...
04:00:29 <JaffaCake> I'd expect less than a factor of 2, when everything is tuned right
04:00:47 <JaffaCake> it's possible the monadic code isn't getting optimised properly
04:00:57 <JaffaCake> one common problem is not making the array strict
04:01:03 <pesco> JaffaCake: This is on Linux-ppc, mind you, but Saulzar ran it too and got even worse numbers.
04:01:33 <pesco> JaffaCake: Hm, but IOUArrays are always strict, no?
04:01:43 <JaffaCake> I mean making the array itself strict
04:02:06 <JaffaCake> quite often you end up with a recursive function that evaluates the array each time around
04:02:43 <pesco> JaffaCake: Hm... I allocate two arrays in the beginning, fill one with zeroes and the other with random numbers and add the latter to the former repeatedly.
04:02:46 <JaffaCake> looking at the Core is the only way to tell whether you're getting what you expect
04:03:08 <JaffaCake> feel free to post the code somewhere and I'll take a look
04:03:21 <JaffaCake> (email to a list, preferably)
04:03:49 <pesco> JaffaCake: Okay, I'll should I mail it to ghc-users@haskell.org?
04:04:09 <JaffaCake> yes, perfect
04:06:46 <psnl> wow, the haskell panic has really set in here
04:06:59 <pesco> psnl: What's that?
04:07:32 <psnl> deadline on the haskell assignment is 6:15 tonight
04:09:14 <sieni> !localtime psnl
04:09:19 <sieni> eiku
04:09:23 <sieni> @localtime psnl
04:09:24 <psnl> sieni: 1207
04:09:27 <lambdabot> Local time for psnl is Wed Jan 18 12:07:24 2006
04:11:31 <pesco> @localtime pesco
04:11:36 <lambdabot> Local time for pesco is Wed Jan 18 13:05:55 2006
04:11:56 <pesco> Not bad.
04:12:50 <psnl> pesco: france?
04:13:12 <pesco> psnl: Me? Czech Republic.
04:16:30 <psnl> I was trying to guess from the time zone, but clearly I sucked
04:25:18 <dons> pesco, also Foreign.mallocArray can be very fast. (using peek/poke semantics)
04:25:40 <Saulzar> pesco, I just tried rearranging it with a strict field data Vector = Vector !(IOU ...) but it made absolutely no difference :)
04:25:54 <dons> we've used that in a couple of the shootout entries  to get fast Word8 arrays
04:26:18 <pesco> dons: Hm...
04:29:37 <bringert> dons: using fastpackedstring makes the k-nucleotide entry run faster and use less memory, but FPS isn't available on the benchmark machines I guess
04:30:23 <bringert> dons: I've added a new slower k-nucleotide entry :-) at http://haskell.org/hawiki/KnucleotideEntry (if you weren't around when I said that last time)
04:30:41 <bringert> but it uses less memory (even without FPS)
04:30:44 <gour> dons: on AMD Sempron, haskell is on the fourth place, but the differences are less than on pentium
04:30:57 <bringert> and I think the current entry is cheating
04:31:33 <dons> bringert, yes. depending on how much you need, (maybe you need a packed getLine?) , you could adapt code from the reverse-complement, or soon-to-appear regex-dna code.
04:31:36 <dons> yes, i've been reading your entries bringert.
04:32:02 <dons> gour, they've broken some of the sripts on the debian boox.
04:32:21 <bringert> am I wrong that the current entry is cheating, or did I misunderstand something?
04:32:47 <dons> no, I think you're probably right.
04:32:58 <gour> dons: ahh, ok
04:33:17 <bringert> I've been trying to figure out what to use instead of Data.Map. Data.HashTable doesn't seem to help
04:33:44 <bringert> it seems a wast to use an immutable datastructure for something that is written to load of times, but only read a few
04:34:36 <dons> hmm. a Ptr a ?
04:34:38 <Saulzar> Maybe just sort it all at once..
04:35:06 <bringert> Ptr to what?
04:35:19 <dons> write an imperative hashtable, based on the C entry?
04:35:45 <bringert> I thought Data.hashTable was to supposed to be an imperative HashTable
04:36:01 <bringert> but looking at the code, it sems to use UArray, not IOUArray
04:36:21 <dons> (i.e. a custom structure for the job). would that be reasonable, i was thinking along those lines today.
04:36:32 <bringert> we could use a trie
04:36:51 <bringert> but a hashtable might be better
04:37:23 <bringert> hmm, maybe we can make us of the fact that all entries in the table will have the same length
04:37:45 <bringert> also, we only really need two bits / character, since it's DNA
04:37:58 <dons> i was thinking that a specialised hashtable could take advantage of domain specific properties. and end up faster than the generic HashTable. just guessing though.
04:38:15 <dons> ah. hmm. interesting.
04:38:20 <bringert> we could use 64-bit numbers to represent the nucleotides
04:38:32 <bringert> since the longest we need is 18 letters
04:38:50 <Saulzar> Would something like 4-radix-sort work well?
04:39:03 <bringert> I guess so
04:39:20 <bringert> radix sort can be seen as a trie for fixed-length strings, right?
04:39:41 <Saulzar> I guess so, but you don't need the structure
04:40:05 <bringert> you need to keep the counts somewhere
04:41:06 <pesco> JaffaCake: Okay, Mail sent.
04:41:25 <JaffaCake> cheers
04:41:51 <Saulzar> Hmm
04:42:20 <Saulzar> Counts? 
04:42:35 <tromp_> i find 64 bit ints poorly optimized in ghc
04:42:50 <bringert> Saulzar: we want to count occurences of all substrings of a certain length
04:42:55 <Saulzar> Ahh, hmm
04:43:01 <bringert> or are we talking about different entries?
04:43:07 <tromp_> i was doing some simple shifts and masks with them and it was 20-50 slower than c
04:43:15 <bringert> oh
04:43:23 <Saulzar> No, I just hadn't looked closely at the problem...
04:43:57 <bringert> if we had a radix-sort (trie) like structure, we wouldn't need any 64-bit numbers
04:44:06 <bringert> just 2-bit ones
04:45:00 <bringert> what about type NucTable = IOArray Word8 (Either NucTable Int) or something like that
04:45:48 <bringert> where only 2 bits of the Word8 are used
04:46:12 <bringert> or we could just use mallocArray to create an array of pointers
04:52:16 <dfhaii> pp
04:53:44 <tromp_> how many nucleotides do u need to store?
04:54:54 <gour> (away
04:55:10 <tromp_> and do you write them almost as often as you read them?
05:06:59 <tennin> شلاؤيثبلاهتنمةىخحضقسفعرصຊຍກກ
05:39:18 <bringert> tromp_: we count lots of nucleotides we we never read the counts for
05:40:43 <bringert> basically we need a function to count all substrings of length ks (where k is a function parameter) in a given string of A,T,G,Cs. 
05:41:00 <bringert> the input string has 1250000 letters for the largest input size
05:41:34 <bringert> k is at most 18 in this case
05:42:01 <bringert> and we only print the counts for all 1- and 2-nucleotides
05:43:08 <SamB> bringert: so who's to say you actually managed to count them all?
05:43:20 <bringert> and then the counts for one given nucleotide of each of the lengths 3, 4, 6, 12, and 18
05:43:31 <bringert> SamB: noone, and that's how the current entry cheats
05:43:47 <tromp_> you mean one given k-mer?
05:44:00 <SamB> bringert: it would be more work to make them be counted ;-)
05:44:01 <bringert> I don't think we should take advantage of that though, the other solutions don't
05:44:05 <bringert> sure
05:44:14 <bringert> tromp_, right, sorry
05:44:20 <tromp_> well, you obviously cannot make a table with 4^18 entries
05:44:26 <bringert> right
05:44:44 <bringert> so we where thinking of using a trie or something like that
05:44:59 <bringert> maybe we could group the letter into groups of 4
05:45:13 <tromp_> in C, i'd just use Judy arrays:)
05:45:14 <bringert> so that each letter can be represented with a Word8
05:45:29 <SamB> s/letter/group/
05:45:39 <tromp_> which are tries with 256-way branching
05:45:43 <SamB> ?
05:45:52 <bringert> SamB: right
05:46:15 <tromp_> but in this case, 4-way branching makes more sense
05:46:56 <bringert> tromp_ wouldn't that cause lots of pointer dereferences?
05:47:23 <tromp_> sure
05:47:26 <bringert> using 256-way would give a quarter as many, but it would waste more space
05:48:20 <tromp_> with 256-way branching you need LOTS of special-case code to keep memory use down
05:48:50 <tromp_> you'd need to switch from 256 size arrays to smaller lists near the leaves
05:49:04 <SamB> does this have anything to do with patricia trees?
05:49:05 <tromp_> judy does all that stuff
05:49:15 <tromp_> but it's 1000s of lines of code
05:49:28 <tromp_> if only it was in a haskell library:)
05:49:34 <SamB> thousands of lines in what language?
05:49:43 <tromp_> it's also optimized for caches
05:49:49 <tromp_> it's written in C
05:49:55 <tromp_> google for judy arrays
05:50:11 <SamB> I thought that sounded like a bit much for Haskell
05:50:57 <bringert> it should be possible to make a simplistic implementation in not too many lines of haskell
05:55:32 <SamB> hmm, how do you mark a wikipedia article as a stub?
05:55:41 <ibid> {{stub}}, iirc
05:55:50 <SamB> where do you put it?
05:56:05 <ibid> anywhere
05:56:09 <ibid> i usually put it at the bottom
05:56:34 <ibid> note that there are nowadays a lot specialized stub-markers for particular broad topics
05:56:46 <ibid> that's the generic marker
05:56:55 <SamB> ibid: well, this is for the Judy Array article
06:02:48 <SamB> hmm, I thought they had turned off anonymous editing of wikipedia?
06:07:47 <jonkri> hello all. i'm trying to find information about the Ratio Integer type, but i don't know where to look. my book says nothing of it and my google results doesn't appear to be relevant
06:08:30 <SamB> jonkri: ah
06:08:30 <SamB> @indix Rational
06:08:31 <lambdabot> Prelude, Data.Ratio
06:08:49 * SamB is happy that lambdabot has spellchecking
06:08:58 <jonkri> haha, that's nice
06:09:00 <SamB> @docs Data.Ratio
06:09:02 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Ratio.
06:09:02 <lambdabot> html
06:09:12 <SamB> jonkri: there you go ;-)
06:09:40 <jonkri> nice, thanks a lot
06:09:45 <SamB> yes, it is nice ;-)
06:10:03 <SamB> you are very welcome
06:10:21 <SamB> @index Ratio
06:10:22 <lambdabot> Data.Ratio
06:10:51 <SamB> ... would also have worked
06:11:08 * ADEpt needs a TH advice. Any takers?
06:12:02 <SamB> ADEpt: you know the drill -- ask the question first
06:12:11 <ADEpt> SamB: hi, btw
06:13:35 <Lemmih> Still not for Conjure?
06:13:42 <SamB> ADEpt: hi
06:14:27 <SamB> oh, btw, Conjure seems to be having a few issues with disconnection...
06:14:46 <ADEpt> so, the question is - i'm trying to use TH for instance derivation. To understand how it could be done, i took code from http://www.haskell.org/pipermail/template-haskell/2005-October/000488.html. Now I try to define "deriveShowWith f name" which will take function (id or show, for example), and define instance for the given 'data Name = Name A B C' name as "instance Show Name where show (Name a b c) = f a ++ f b ++ f c. Problem is, i cant understand what typ
06:14:55 <ADEpt> Lemmih: unfortunately, not :(((
06:15:27 <SamB> sometimes it seems to leave the socket open, and piece activity escalated...
06:15:34 * lypanov notes that he saw nothing after "Problem is, i cant understand what typ"
06:15:50 <ADEpt>  Problem is, i cant understand what type this 'f' should have. 
06:15:51 <SamB> lypanov: I was just going to mention that
06:15:54 <JKnecht> ditto
06:16:11 <ADEpt> lisppaste2: help
06:16:19 <ADEpt> @where lisppaste2
06:16:20 <lambdabot> I know nothing about lisppaste2.
06:16:26 <lypanov> they are all dead
06:16:28 <lypanov> a few days already
06:16:31 <lypanov> rafb.net/paste
06:16:35 <ADEpt> thnx
06:16:37 <Lemmih> ADEpt: It should probably be a Name.
06:16:46 <SamB> they tried to come up yesterday
06:17:13 <Lemmih> ADEpt: Reify the data declaration and generate a sutablen instance declaration.
06:17:26 <ADEpt> http://rafb.net/paste/results/JCrBq045.html
06:17:48 <SamB> Lemmih: how can the function be a Name?
06:18:27 <Lemmih> @type 'id
06:18:29 <lambdabot> lexical error in string/character literal
06:18:37 <Lemmih> Prelude> :t 'id
06:18:37 <Lemmih> 'id :: Language.Haskell.TH.Syntax.Name
06:19:00 <SamB> oh, right...
06:19:20 <SamB> I didn't understand that without the $
06:20:29 <jonkri> so is ratio a data type where i can store like 5/7 or what?
06:20:38 <ADEpt> oh, wrong paste. please see this one: http://rafb.net/paste/results/vKuX8U49.html
06:22:02 <SamB> jonkri: exactly
06:22:13 <jonkri> SamB, but what about "Integral"? what is that doing there?
06:22:28 <SamB> jonkri: that is a type class
06:22:58 <SamB> jonkri: it means that you can have Ratios of things besides Integers, basically 
06:23:07 <jonkri> ah, ok
06:23:10 <jonkri> @index integral
06:23:11 <lambdabot> bzzt
06:23:17 <ADEpt> Lemmih: ah. I seem to put me on track.
06:23:24 <jonkri> lambdabot, you don't like me? :-)
06:23:34 <SamB> but they have to be some sort of integer
06:23:45 <SamB> jonkri: capitalization is key
06:23:57 <jonkri> SamB, i thought it had spellchecking? ;-)
06:24:00 <jonkri> @index Integral
06:24:01 <lambdabot> Prelude
06:24:09 <jonkri> @doc Integral
06:24:10 <lambdabot> Integral not available
06:24:15 <jonkri> @doc Prelude
06:24:16 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
06:24:34 <SamB> jonkri: only for commands ;-)
06:25:01 <ADEpt> could you see if something could be improved? http://rafb.net/paste/results/5q7jPz23.html
06:25:18 <jonkri> what's the definition of a integral number? i'm not a native english speaker
06:25:43 <JKnecht> whole number, not a fraction
06:26:08 <SamB> but it can be negative or zero
06:26:13 <jonkri> ok
06:26:25 <jonkri> oh, ok. i thought it had something to do with calculus integrals at first :-)
06:26:48 <SamB> hehe
06:27:00 <jonkri> thanks for your help
06:27:07 <jonkri> got to go now, see you!
06:27:33 <SamB> the word is the same, but the meaning is different. I expect a lot of native speakers get confused about it too ;-)
06:27:45 <jonkri> hehe, ok :-)
06:27:54 <jonkri> well, take care!
06:29:31 <SamB> also, in calculus the adjective is nouned ;-)
06:33:53 <jonkri> hi again :-)
06:35:41 <SamB> hello
06:37:15 <jonkri> i was being chased out of a computer lab
06:37:19 <jonkri> another class was coming
06:38:03 <SamB> ah
06:40:25 <jonkri> now i'll continue with the haskell stuff :-) i'm looking forward to learn this
06:44:11 * SamB has to go to class now...
06:44:42 <jonkri> SamB, have fun :)
06:45:37 <SamB> I'll try
06:54:41 <^kdonn^> hrm
07:47:36 <dcoutts_> JaffaCake, so should I send more haddock wiki patches, or are you going to look at adding the "little row of icons at the far right 
07:47:36 <dcoutts_> of each entity's definition" ?
07:48:07 <JaffaCake> dcoutts_: feel free.. I probably won't get to it any time soon
07:48:11 <dcoutts_> ok
07:48:25 <JaffaCake> how are your icon drawing skillz? :)
07:48:31 <dcoutts_> heh
07:48:55 <dcoutts_> you think they should actually be icons rather than text links like the ones at the top of each page
07:49:10 <dcoutts_> | User comments | Source code | ... |
07:49:18 <JaffaCake> text links would be ok, in a small font
07:49:28 <dcoutts_> I'll start with that ;-)
07:49:54 <dcoutts_> if people complain it's too big they can supply icons
07:50:12 <JaffaCake> that's the attitude :)
07:50:21 * dcoutts_ grins
07:56:08 <pesco> JaffaCake: Okay, yours and Bulat's tips brought the vector addition program down to about 3-4x.
07:56:38 <JaffaCake> did you change the RNG?
07:56:53 <pesco> JaffaCake: Oh yeah, I removed it.
07:57:11 <JaffaCake> right... I wonder where the 3-4x slowdown is coming from
07:57:28 <JaffaCake> it could just be low-level stuff, GHC isn't good at optimising small loops
07:57:57 <pesco> JaffaCake: Hm, yeah, this is not so bad.
07:58:26 <pesco> JaffaCake: Hm, I'm not sure on how to use my new knowledge for the actual program I want to write, though.
08:00:02 <pesco> The thing is, I want to make a program that draws a big graph.
08:00:24 <pesco> It gets regular updates (new edges) on stdin and should immediately incorporate them into the drawing.
08:01:01 <pesco> While it's doing this it should constantly improve the layout edges by an incremental algorithm.
08:01:05 <pesco> s/edges//
08:01:19 <JaffaCake> ok...
08:01:26 <psnl> pesco: will be impressed if you can do it
08:01:39 <pesco> psnl: So will I. ;)
08:01:57 <pesco> But it's a simple thing conceptually. It should be possible.
08:02:03 <JaffaCake> pesco: sounds like you want a background thread improving the graph
08:02:31 <pesco> Exactly, I thought I'd use STM to seperate the drawer, updater, and layouter.
08:02:47 <JaffaCake> sounds good
08:02:56 <pesco> But then the logical way is to store the graph and layout data in a shared TVar.
08:03:11 <JaffaCake> depends, you don't want long-running transactions
08:03:30 <pesco> What's long-running?
08:04:11 <JaffaCake> ie. if you do atomically $ do x <- readTVar t; x' <- compute_new x; writeTVar t x
08:04:26 <JaffaCake> and compute_new takes a long time, then this transaction is likely to get aborted
08:04:46 <pesco> I was thinking about "insert edge", "improve layout", and well, reading for output is only "readTVar".
08:05:09 <JaffaCake> right, the question mark is on improve layout
08:05:33 <JaffaCake> if you're busy improving the layout while insert edge comes in, then you don't want to throw away that work
08:05:41 <pesco> That's one iteration of a conjugate gradient equation solver.
08:05:57 <pesco> JaffaCake: Hm, yes...
08:06:18 <JaffaCake> so I'd put it in TVar (Maybe Graph)
08:06:33 <JaffaCake> in other words,. a TMVar
08:06:37 <pesco> Hm, so the layouter can take it out?
08:06:40 <pesco> Ah, yes.
08:06:42 <JaffaCake> yes
08:08:00 <JaffaCake> you can queue up the edge insertions until the improver has finished an iteration, as long as the latency isn't a problem
08:09:17 <pesco> JaffaCake: I hope not, but this algo is supposed to be quite fast. I'm only worried about "Haskell overhead" biting me.
08:09:54 <pesco> But if I use a mutable IOUArray to store the graph, it shouldn't matter.
08:10:02 <JaffaCake> if you need concurrency, then Haskell is the tool of choice - the overhead will be much less than most other languages
08:10:17 <pesco> BTW, I didnt' find the unsafeRead/Write functions in my GHC docs, are they "non-standard"?
08:10:56 <JaffaCake> yes, we should probably make them available from a standard place
08:11:06 <JaffaCake> currently you have to get them from Data.Array.Base, which isn't documented
08:11:23 <pesco> JaffaCake: Yes, I mean for the graph stuff. I alway shy away from resorting to IOUArrays at first, because I want to see if it's doable without mutable data structures.
08:11:40 <pesco> (that was in response to overhead)
08:12:00 <pesco> But I guess this qualifies as a case of "optimize the inner loop"...
08:12:01 <JaffaCake> right
08:12:22 <JaffaCake> probably... write it first and then see where the problems are, if any
08:15:29 <pesco> Yes. Thanks alot for your help, anyway.
08:16:26 <pesco> Oh, do you know if one of the supplied 2d-libs will be suitable for this, efficiency-wise?
08:17:13 <Saulzar> Cairo might be well suited
08:17:15 <dcoutts_> pesco, what supplied 2D llibs?
08:17:43 <pesco> HGL.
08:18:00 <dcoutts_> pesco, cairo produces nice results. It can be a bit slower than low level X11 stuff.
08:18:05 <pesco> Saulzar: Yes, Cairo would, but I'd like to avoid external deps.
08:18:18 <Saulzar> HOpenGL?
08:18:22 <Saulzar> How fast do you need? 
08:18:39 <Saulzar> I'm sure for drawing graphs just about any will do
08:18:54 <Saulzar> Unless you have a million vertices :)
08:19:26 <pesco> Well, maybe not a million, but a couple of thousands should be expected.
08:20:04 <pesco> One very practical problem with OpenGL is that GLUT is notoriously assy whenever it comes to concurrency.
08:20:31 <Saulzar> Well, you can't use GL in more than 1 thread anyway, at least you're not meant to be able to
08:20:58 <pesco> Yes, yes, but I need to pass the data, or actually, the fact that the data has changed.
08:21:12 <Saulzar> That should be irrelavant to glut though...
08:21:17 <pesco> I.e. I need to signal the drawer to update the picture.
08:21:41 <Saulzar> Oh, you're talking about glut taking control
08:21:48 <pesco> No, the signalling isn't, because GLUT works by you passing control to its mainloop-function.
08:21:56 <pesco> Yes.
08:21:57 <Saulzar> Well there are plenty of others, gtk2hs or SDL ... but :P
08:22:22 <pesco> Yes yes, but I want to avoid external dependencies.
08:22:51 <pesco> Because I'd like to be able to send this program to somebody who (unfortunately) is unlikely to have a haskell build environment ready.
08:23:00 <jonkri> cya
08:23:05 <pesco> Hm, but I could probably send a binary.
08:24:09 <pesco> Okay, thanks everyone for playing cardboard wookie...
08:30:25 <pesco> Does gtk2hs already contain the Cairo binding?
08:30:30 <dcoutts> yes
08:30:52 <dcoutts> it's nice & easy to use
08:31:06 <pesco> Okay, I'll give it a try.
08:32:35 <pesco> Mahah, thread on the Plan 9 fans mailing list, subject: "GNU binutils: you can't make this shit up"
08:33:00 <pesco> Joyful ranting about various GNU-isms.
08:33:27 <C-Keen> pesco: you got an url for this? :)
08:34:13 <pesco> C-Keen: No, it's in my mailbox. You have to google for the archives...
08:34:48 <C-Keen> pesco: ok thanks
08:35:42 <integral> ( http://lists.cse.psu.edu/archives/9fans/2006-January/044571.html )
08:37:57 <pesco> JaffaCake: BTW, Taking out the RNG gives me a speedup of one second for those 100000 elements. With RNG ~13 seconds, without ~12.
08:38:31 <JaffaCake> I suspect you still have some boxing/unboxing going on then, want to send me the code?
08:39:20 <pesco> JaffaCake: Sure, to the list again, or private mail?
08:39:37 <JaffaCake> might as well send to the list, in case anyone else is interested
08:40:22 <pesco> JaffaCake: Ah, that's interesting: I just put the RNG back in but realized I can leave out the array init then. => ~10 seconds.
08:40:58 <pesco> I.e. newArray_ instead of newArray.
08:41:22 <JaffaCake> hmm, newArray is quite expensive then
08:41:51 <pesco> Hah! Yes appearently, without RNG but newArray_ followed by manual init loop => ~9.5 seconds.
08:42:27 <JaffaCake> so using newArray is much worse than initialising manually? that's bad
08:42:50 <JaffaCake> I do vaguely remember notcing that before, actually
08:43:37 <pesco> Yep. :)
08:44:04 <JaffaCake> pesco: would you like to submit a bug report to that effect?
08:49:32 <pesco> JaffaCake: Okay.
08:49:48 <JaffaCake> great, thanks
08:51:53 <pesco> Wow, why does the seq'ing of the two arrays make such a difference?
08:52:05 <pesco> Running time jumped to 15 seconds when I removed it.
08:57:27 <gour> dcoutts: what do you think about having example for 'usage' ?
09:10:04 <dcoutts_> gour, it'd be great. But someone has to write it! :-)
09:11:31 <gour> dcoutts: fine, don't forget to add one for each new function you bind
09:11:35 * gour grins
09:11:40 <dcoutts_> yeah yeah :-)
09:11:50 <dcoutts_> so if we had a wiki...
09:11:57 <dcoutts_> then anyone could add their notes
09:12:43 <gour> sure
09:13:01 <gour> i still think it is a good practice to help noobies start using libs
09:13:23 * gour remember old days when compiler were coming with several book and code examples...
09:14:01 <dcoutts_> gour, yeah, I think it's good practice too
09:14:08 <dcoutts_> but we've got limited developer time
09:14:16 <dcoutts_> it's a question of priorities
09:14:26 <dcoutts_> we could do with more user contributions
09:15:00 <gour> dcoutts: it's part of documentation, let's follow good practice of sw engineering, please :-)
09:15:31 <dcoutts_> so which of the 1000+ apis should we provide exampels for first?
09:15:50 <dcoutts_> I think the more important task is an introductory tutorial
09:16:07 <dcoutts_> and more demos that show the use of various functions & features
09:16:29 <Speck> I wonder if a monadic intermediate language like exists in jhc could be augmented to provide region-based memory management
09:17:12 <dcoutts_> Speck, I beleive that the plan is for jhc to use region analysis
09:17:15 <gour> ok, i don't expect you to go back and fill up the gap, but let's introduce it as practice and then those who are getting familiar with the bindings can out something in to fill up the holes
09:17:57 <dcoutts_> gour, well I do provide demos for the new apis I've been adding recently
09:18:00 <Speck> dcoutts_: is this documented anywhere?
09:18:12 <dcoutts_> gour, like the opengl, the cairo-svg
09:18:20 <dcoutts_> Speck, on the jhc pages somewhere
09:18:33 <gour> dcoutts_: well, i didn't dive into them (yet)
09:18:42 <dcoutts_> Speck, it's only documented as a desire. I don't know of any documented plan.
09:18:51 <Speck> thanks
09:21:02 <gour> dcoutts_: seeing the latest optimizations done for shootout is impressive (i sent a link to my c++ friend)
09:21:12 <dcoutts_> indeex it is
09:21:18 <dcoutts_> indeex/indeed
09:21:27 <gour> however, it is obvious that the code is not really the natural one (i assume so)
09:21:36 <dcoutts_> true
09:21:45 <dcoutts_> but neither is it for the C/C++ entries
09:21:52 <dcoutts_> they are very long and low level too
09:21:54 <gour> what is the chance of improving compiler to do (part of) the process?
09:22:14 <gour> you're researching soem of those things, true?
09:22:15 <dcoutts_> automatically spotting chances for low level optimisations is hard
09:22:52 <dcoutts_> sometimes what one can do is provide hints/instructions about what transformations to apply
09:23:28 <gour> what would you say what is the haskell/c index for general application in performance?
09:23:31 <palomer> how does one usually refer to the member foo of instance bar of typeclass blah ?
09:26:18 <Saulzar> dcoutts, I don't know, long and low level is fairly standard for C/C++. I've seen much worse!
09:26:40 <dcoutts_> heh
09:28:08 <gour> the present shootout ranking is (probably) not a realistic one for 'normal' coding in haskell, i.e. for non-phd & non-guru
09:29:18 <palomer> LtU has been busy busy busy
09:30:06 <Saulzar> There is no conistent style between the C++ entries anyway,
09:30:33 * gour just saw a rss feed about gtkada and visited http://www.adacore.com/ada_2005.php
09:31:58 <Saulzar> This one they've implemented their own string class and hashtable, clearly it's not "idomatic" C++, since they've completely ignored the standard libs
09:32:44 <Saulzar> er, idiomatic
09:33:20 <tromp_> they'd write it in assembler if they could...
09:33:21 <int-e> Idiomatic C++?
09:33:57 <int-e> sounds like an oxymoron to me ...
09:33:59 <Speck> s/matic/tic
09:34:19 <palomer> Saulzar: you should email the maintainers to point this out
09:34:53 <Saulzar> Well, they're probably losing out massively on line count by doing so :)
09:35:04 <palomer> whoa, haskell beat java
09:36:33 <palomer> what are the # symbols in harmonic.hs?
09:37:00 <palomer> harmonic.hs is unreadable:O!
09:39:08 * palomer has a suspicion that the haskell submissions are unreadable
09:39:29 <int-e> well, you can ignore the # for the most part if you're trying to understand the program
09:39:51 <Saulzar> # is used for primitive types
09:40:05 <int-e> except I# and D#: data Int = I# Int#, data Double = D# Double# (basically.)
09:41:10 <palomer> but, erm, shouldn't the compiler optimize to primitive types for you?
09:41:37 <palomer> and is there really a need for boxing?
09:41:53 <int-e> hmm, compare Proposed 1 and Proposed 2 at http://haskell.org/hawiki/HarmonicEntry ...
09:42:44 <int-e> I don't know whether it makes a difference in the generated code, but I hope the explicitely unboxed version would not exist if it didn't.
09:42:55 <Heffalump> # changes semantics..
09:43:06 <Heffalump> in some cases you can treat it like a !
09:43:24 <palomer> ahh, thought so, so it's strict
09:43:30 <palomer> this doesn't seem very idimotic!
09:44:00 <int-e> I believe the shootout is not about idiomatic code - in practice - whatever the intent was.
09:44:18 <palomer> s/idimotic/idiomatic
09:45:03 <Saulzar> More people look at the numbers than anything else...
09:45:21 <palomer> there should be judges who judge when code is not idiomatic
09:45:31 <palomer> and refuse the submissions
09:46:07 <Saulzar> Hard to judge that really.. and it's a lot of work
09:46:19 <int-e> palomer: hmm, you'd need several who really know the languages in question. idiomatic programs are not necessarily easy to read for a beginner.
09:48:08 <Heffalump> sticking to Haskell 98 would be a good start :-)
09:48:22 <Cale> also, to some extent, idioms grow around what works well, so maybe even if the well-performing code doesn't start out as idiomatic, perhaps people reading it will adopt some of its conventions
09:48:51 <Cale> I don't think that sticking to Haskell 98 is realistic.
09:49:37 <Cale> There are a lot of decent extensions.
09:50:03 <Cale> (which are very common in real code)
09:51:56 <tromp_> such as let evens l = [x|x<-l|True<-map even [0..]]
09:52:06 <Saulzar> Anyway, the language is Haskell GHC - it's not a language shooutout it's an implementation shootout :)
09:53:16 <ihope> @type let b x y z = x (y z); w x y = x y y; k x y = x in b w k
09:53:18 <lambdabot> forall t t1. (t1 -> t) -> t1 -> t
09:53:34 <ihope> @type let w x y = x y y; k x y = x in w k
09:53:36 <lambdabot> forall t. t -> t
09:54:01 <int-e> in the case of harmonic, the unboxing is not really necessary - adding a fromIntegral for d is enough.
09:54:06 <ihope> @type [Nothing,3]
09:54:07 <lambdabot> forall a. (Num (Maybe a)) => [Maybe a]
09:54:29 <ihope> @type [Nothing,'a']
09:54:31 <lambdabot>   Couldn't match `Maybe a' against `Char'
09:54:31 <lambdabot>   Expected type: Maybe a
09:55:50 <Cale> @type [Nothing,Just 3]
09:55:51 <int-e> oh and a type signature forcing d to Int
09:55:51 <lambdabot> forall a. (Num a) => [Maybe a]
09:56:03 <Cale> @type [Nothing,Just 'a']
09:56:05 <lambdabot> [Maybe Char]
09:57:32 <ihope> @type [(>>),(>>>)]
09:57:34 <lambdabot> Not in scope: `>>>'
09:57:47 <ihope> @type [(>>),(Control.Arrow.>>>)]
09:57:48 <lambdabot> forall b (a :: * -> * -> *) b1.
09:57:48 <lambdabot> (Monad (a b1), Control.Arrow.Arrow a) =>
09:57:48 <lambdabot> [a b1 b1 -> a b1 b -> a b1 b]
09:58:43 <Speck> oro...
10:00:39 <palomer> > [Nothing, 3]
10:00:41 <lambdabot>  add an instance declaration for (Num (Maybe a))
10:00:41 <lambdabot>   In the list element: 3
10:00:41 <lambdabot>   In the definition of `zzo': zzo = [Nothing, 3]
10:00:49 <palomer> @type [Nothing, 3]
10:00:51 <lambdabot> forall a. (Num (Maybe a)) => [Maybe a]
10:00:57 <palomer> how is that typeable?
10:01:12 <palomer> zzo?
10:02:19 <ihope> If Maybe a is a number...
10:02:40 <palomer> is Maybe a a number?
10:02:53 <Speck> > (Just 4) + (Just 5)
10:02:54 <lambdabot>  add an instance declaration for (Num (Maybe a))
10:02:54 <lambdabot>   In the definition of `gnh': gnh = (Just 4) + (Just 5)
10:02:54 <lambdabot>   In the definition of `v':
10:02:57 <ihope> Depends on what a is.
10:03:18 <ihope> > do {a <- Just 4; b <- Just 5, return (a+b)}
10:03:20 <lambdabot>  parse error on input `,'
10:03:25 <ihope> > do {a <- Just 4; b <- Just 5; return (a+b)}
10:03:25 <palomer> show me a case where Maybe a is a Num
10:03:26 <lambdabot> Just 9
10:03:55 <ihope> There are none, but there's nothing stopping someone from creating one.
10:04:04 <palomer> oh, I see
10:04:11 <ihope> Just like (undefined :: ((a -> b) -> a) -> a) is valid.
10:06:15 <tromp_> > let plus = liftM2 (+) in Just 4 `plus` Just 5
10:06:17 <lambdabot> Just 9
10:07:25 <tromp_> > let plus = liftM2 (+) in Just 4 `plus` Nothing
10:07:27 <lambdabot> Nothing
10:07:29 <tromp_> :)
10:08:22 <vincenz> > let (=) = liftM2 (+) in Just 4 + Just 5
10:08:23 <lambdabot>  parse error on input `='
10:08:29 <vincenz> > let (+) = liftM2 (+) in Just 4 + Just 5
10:08:30 <lambdabot>   Occurs check: cannot construct the infinite type: a1 = m a1
10:08:30 <lambdabot>   Expected type: a1 -> a2 -> r
10:08:30 <lambdabot>   Inferred type: m a1 -> m a2 -> m r
10:08:44 <Cale> hehe, that would be recursive
10:08:47 <vincenz> so how do you locally override?
10:09:02 <vincenz> > letnonrec (+) = liftM2 (+) in Just 4 + Just 5
10:09:02 <lambdabot>  parse error on input `='
10:09:06 <Cale> > let (+) = liftM2 (Prelude.+) in Just 4 + Just 5
10:09:08 <lambdabot> Just 9
10:09:19 <tromp_> instance Num (Maybe Int) ...
10:09:39 <Cale> yeah, really you'd define an instance of Num
10:09:57 <int-e> instance (Num a, Monad m) => Num (m a) where ...
10:10:30 <ihope> > let add = liftM2 (+) in let (+) = add in Just 4 + Just 5
10:10:32 <lambdabot> Just 9
10:10:40 <ihope> :-)
10:13:35 <ihope> I wanna learn Lisp ag--I mean, I want to learn continuation passing style in Haskell.
10:13:40 <tromp_> so how do you complete instance (Num a, Monad m) => Num (m a) where ?
10:13:45 <int-e> yuck. Num requires a Show instance?
10:13:55 <ihope> It does?
10:14:04 <int-e> class (Eq a, Show a) => Num a where ...
10:14:13 <int-e> @info Num
10:14:13 <lambdabot> Unknown command, try @listcommands.
10:14:23 <int-e> it does.
10:14:38 <Saulzar> Hm, strange.
10:15:06 <int-e> there goes that idea. other than that, I'd complete it with (+) = liftM2 (+), same for *, -, and negate, abs, signum and fromInteger with liftM.
10:15:06 <Saulzar> Convenience for something else?
10:15:15 <palomer> cps isn't hard, just reverse application:OP
10:15:19 <ihope> It'd be, erm, something if (show . putStr) were equal to id...
10:15:36 <palomer> @type show . putStr
10:15:37 <lambdabot>   No instance for (Show (IO ()))
10:15:37 <lambdabot>   arising from use of `show' at <interactive>:1:0-3
10:16:11 <int-e> it also depends on Eq but arguably I could live with that - although it'd stretch the semantics of Eq quite a bit.
10:16:12 <palomer> show . putStr isn't even legal
10:16:26 <ihope> I know.
10:16:26 <Cale> It's a wart. It's convenient in that it cuts down on class contexts, but I'm not convinced it should actually be there, since a meaningful Show instance is often questionable.
10:16:32 <palomer> someone give me a sane Num instance for Maybe a
10:16:54 <int-e> actually, no. Eq is a problem, too.
10:16:56 <ihope> @type liftM2
10:16:57 <lambdabot> Not in scope: `liftM2'
10:17:01 <Cale> int-e: yeah
10:17:05 <tromp_> you can't say  (+) = liftM2 (+)
10:17:05 <ihope> @index liftM2
10:17:07 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.
10:17:07 <lambdabot> State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont,
10:17:07 <lambdabot> Control.Monad.Error, Control.Monad.List
10:17:19 <Cale> int-e: in some sense, Eq is even more of a problem than Show
10:17:21 <ihope> tromp_: can't you?
10:17:30 <int-e> @type Control.Monad.liftM2 (+)
10:17:31 <lambdabot> forall a2 (m :: * -> *). (Monad m, Num a2) => m a2 -> m a2 -> m a2
10:17:39 <int-e> looks fine to me, type-wise.
10:17:44 <tromp_> isn't that recursive?
10:17:47 <int-e> no
10:17:54 <int-e> it's a different (+), due to the type
10:18:05 <ihope> It's all up to the Report dudes to handle it.
10:18:16 <int-e> it's the same (+) in that it belongs to the same type class.
10:18:26 <tromp_> ok, cool
10:18:40 <chucky> @djinn (a -> b -> c) -> ((a,b) -> c)
10:18:41 <lambdabot> f a (b, c) = a b c
10:19:30 <ihope> @type uncurry
10:19:31 <lambdabot> forall c b a. (a -> b -> c) -> (a, b) -> c
10:19:52 <ihope> Hmm.
10:20:33 <ihope> > let undefined :: ((a -> b) -> a) -> a in 3
10:20:35 <lambdabot>  Not in scope: `undefined'
10:20:44 <ihope> ...!
10:20:45 <tromp_> hmmm, how complex a program can you write by giving type-defs only:-?
10:21:00 <ihope> ...What?
10:21:41 <chucky> tromp_: lennart wrote djinn, so he could likely answer that
10:21:47 <chucky> but he's not here now. :(
10:21:57 <tromp_> i suppose you can never make djinn use the tail function for instance
10:22:16 <ihope> Does anybody have a "what the heck are continuations" handy?
10:22:42 <ihope> ...Wow.
10:23:00 <ihope> "What the heck is: Continuation Passing Style (CPS)"
10:23:23 <tromp_> a continuation is a function producing a final result from an intermediate result
10:24:16 <int-e> function call: 'fill out this survey and give it back to me'. CPS: 'fill out this survey, then give it to Max. instructions for Max are in the folder.'
10:25:06 <palomer> in CPS, functions do not return. This forces every lambda to start with a variable of type alpha -> beta
10:25:25 <ihope> head (x:xs) max = max x
10:25:28 <ihope> Aye?
10:25:34 <palomer> \x :: alpha -> beta -> x t
10:25:41 <Cale> palomer: I wouldn't quite say that
10:25:48 <tromp_> if a normal computation x produces a result a
10:25:51 <palomer> Cale: why not?
10:26:03 <tromp_> then in CPS computation x results in \cont -> cont a
10:26:12 <Cale> palomer: You're eventually going to apply a continuation of id, at which point it will return
10:26:33 <palomer> Cale: that's if you want to interact with non continuation passing code
10:26:36 * ihope hides
10:26:59 <palomer> however, if you wrote everything in CPS, and people have, then you would never need to return
10:27:13 <Saulzar> Hmm, well you're going to have to do that unless you're using side effects, yes?
10:27:18 <Cale> well, that also assumes that you're allowed side effects
10:27:26 <Cale> since functions which don't return are useless
10:27:28 <palomer> Saulzar: in the end, programming is about side effects
10:27:43 <Cale> but I wouldn't call them functions
10:27:50 <tromp_> so, computations in CPS expect an argument "future" which they are supposed to apply to their result
10:27:58 <newsham> instance (Num a) => Num (Maybe a) where
10:27:59 <newsham>       (+) = liftM2 (+)
10:28:04 <Cale> If it has a side effect, it's not really a function anymore
10:28:07 <newsham> [... for -, * and fromInteger ...]
10:28:23 <palomer> Cale: right, terms no longer represent functions
10:28:32 <palomer> big however: it is possible to extract functions from the terms
10:28:34 <newsham> I was able to make that work, but I wasnt able to use the more general Num (m a)  for all monads
10:28:46 <palomer> with unCPS, amongst other things
10:29:15 <palomer> CPS makes control explicit, and control certainly cannot be denoted with functions
10:29:25 <Cale> sure, if there were no side effects so far, you could apply a continuation of id, and get something which was a function
10:29:30 <int-e> newsham: it requires -fglasgow-exts in GHC to parse ... and then you run into the problem that it wants Show and Eq instances for m a.
10:29:58 <palomer> Cale: yeah, that's one way of extracting functions
10:30:48 <palomer> anyways, with CPS you can keep referential transparency
10:30:58 <Saulzar> int-e, Could always just provide a dummy instance to keep it happy and ignore it...
10:30:58 <palomer> (since nothing is ever returned, you get it for free!)
10:31:30 <Cale> palomer: only in a silly way
10:32:34 <Cale> If your intention is that terms never quite finish evaluating, you kind of have to redefine your notion of referential transparency.
10:32:53 <palomer> but you get some of the benefits of referential transparency
10:33:02 <int-e> Saulzar: I can do instance (Num a, Monad m, Show (m a), Eq (m a)) => Num (m a) where if I add -fallow-undecidable-instances ...
10:33:06 <ihope> I can learn CPS tomorrow.
10:33:22 <newsham> never do today what you can put off till tomorow
10:33:41 <palomer> ihope: get ready to bang your head against the wall a few times
10:33:44 <int-e> Saulzar: I don't want to add a crappy default Show instance because some Monads have perfectly good ones to use.
10:34:17 <ihope> Now I'll tell everyone why the "normal" way to break referential transparency doesn't work.
10:34:24 <ihope> Side effects, I mean.
10:35:25 <ihope> Suppose you have a special kind of 3 that does something when evaluated. You defang it and pass it to a function.
10:35:59 <ihope> The result of the function is 3. There's no way to know whether that 3 was the 3 you passed to it or a different 3.
10:36:03 * ihope bows and leaves
10:36:17 * palomer leaves too
10:36:40 <newsham> *gets a learning continuation from ihope*
10:37:13 <tibbe> what would be the main difference in implementing an interpreter for a strict vs a non-strict functional language in haskell?
10:37:34 <Saulzar> int-e, Hmm, true. That's ugly :(
10:38:03 <Cale> tibbe: the order in which your evaluator evaluates the terms
10:38:31 <tibbe> Cale, of course, should have thought of that myself
10:39:01 <Cale> If it does things innermost first, you'll end up with strict semantics, and with outermost first, you'll end up with non-strict semantics.
10:39:02 <tibbe> but are we talking about using monads for the sequencing of evaluating?
10:39:14 <tibbe> evaluation*
10:39:21 <Cale> Oh, you could use them
10:40:31 <tibbe> Cale, if you have a look at this (minimal) lambda calculus interpreter, could you sugest how to modify it? http://www.itstud.chalmers.se/~larssont/Main.hs
10:41:00 <Cale> http://homepages.inf.ed.ac.uk/wadler/papers/essence/essence.ps
10:41:51 <tibbe> Cale, I read that paper at the gym today
10:42:02 <Cale> :)
10:42:07 <tibbe> but I'm not sure if I got it all
10:42:15 <tibbe> it's hard to work out and think at the same time!
10:42:20 <Cale> hehe
10:42:28 <tibbe> but it's time efficient
10:42:33 <ihope> Oh, right. There's also no way to know whether that function really cared that it was a 3 you passed to it or not.
10:42:37 <Cale> I was going to say that's a bit of an odd place to be reading papers
10:43:20 <tibbe> actual i was on one of those elipse running machine thingies and they even have a small "holder" for (news)papers
10:44:01 <tibbe> before you know it your work-out is done and you didn't even notice that it started :)
10:45:23 <Cale> I like how a google search for "Wadler" returns Phil Wadler's homepage as the first hit :)
10:46:42 <tromp_> as opposed to a search for Gibbard:-?
10:47:07 <Cale> hehe
10:47:24 <edwinb> I don't even get top hit for my full name...
10:47:24 <Speck> I imagine the Ben variety is pretty high up
10:48:10 <tromp_> at least you get all top hits for cale gibbard
10:48:17 <Igloo> Knuth was saying he was top for "Don", although he seems to have been overtaken by www.don.com (according to google.co.uk at least)~
10:48:47 <Cale> tromp_: and I have no idea why the top things are on the top
10:49:02 <tromp_> don is still on top
10:49:09 <tromp_> or back on top maybe:)
10:49:57 <tromp_> luckily i'm on top for tromp. no such luck with my first name;(
10:50:29 <ihope> @type [[3],3]
10:50:30 <lambdabot> forall a. (Num a, Num [a]) => [[a]]
10:50:38 <ihope> Hah!
10:50:51 <ihope> @type ["a",'a']
10:50:52 <lambdabot>   Couldn't match `[Char]' against `Char'
10:50:52 <lambdabot>   Expected type: [Char]
10:51:33 <tromp_> [[3],3] can be valid
10:51:53 <tromp_> just got to define fromIntegral for [Int]
10:52:01 <ihope> Hee.
10:52:22 <ihope> fromIntegral = const undefined
10:53:32 <ihope> Oh, right right.
10:53:37 <ihope> fromIntegral = return
10:54:28 <ihope> (+) = zipWith (+)
10:55:08 <ihope> @pl \x y -> do {a <- x; b <- y; return (x*y)}
10:55:09 <lambdabot> (line 1, column 12):
10:55:09 <lambdabot> unexpected "{"
10:55:09 <lambdabot> expecting variable, "(", operator or end of input
10:55:42 <ihope> @pl \x y -> x >>= \a -> y >>= \b -> return (a*b)
10:55:43 <lambdabot> liftM2 (*)
10:55:49 <ihope> Oh.
10:55:58 <ihope> (*) = liftM2 (*)
10:56:31 <tibbe> > (\x -> (x,x)) (\y -> (y,y))
10:56:33 <lambdabot>  add an instance declaration for (Show (a -> (a, a)))
10:57:10 <ihope> negate = map negate
10:57:27 <ihope> abs = map abs
10:57:32 <ihope> @type signum
10:57:34 <lambdabot> forall a. (Num a) => a -> a
10:57:47 <ihope> signum = map signum
10:59:10 <Saulzar> Heh, unfortunately google of my name turns up entries on mailing lists when I was 16...
10:59:21 <ihope> Heh.
10:59:51 <chucky> google images on my name turns up pictures of me dressed as a woman (don't ask)
11:00:17 <chucky> or well, one picture anyway
11:00:32 <ihope> Eep.
11:00:40 <ihope> "The second problem with CPS is that it involves continuations."
11:00:57 <ihope> zomg continuations in continuation passng stile!!!!one
11:01:22 <Saulzar> and some code of one file from a C++ project in 2000... goodness knows how and why it is posted, it is completely useless :)
11:01:45 <edwinb> ihope: eep. where is that quote from?
11:01:55 <ihope> http://www.sidhe.org/~dan/blog/archives/000185.html
11:02:46 * edwinb reads to pass the time
11:04:26 <ihope> I suppose I ought to do some continuationing.
11:05:44 <ihope> @type let cont f p c = c (f p) in cont cont
11:05:45 <lambdabot> forall t t1 t2 t3.
11:05:45 <lambdabot> (t -> t1) -> ((t -> (t1 -> t2) -> t2) -> t3) -> t3
11:06:23 <ADEpt> is it possible to obtain ab "editor" account on hawiki?
11:07:25 <ADEpt> s/ab\w+/"an editor"/
11:07:47 <ihope> This is weird enough. (fix error) and (error (fix error)) have different types.
11:08:04 <palomer> disunification is fun
11:08:10 * palomer wonders where ski is
11:08:36 <ihope> Coptic disunification...
11:09:47 * palomer kicks google
11:10:14 <ihope> Disunification within the Black community?
11:11:07 <psnl> is there something like the system function that gives you the output of the command?
11:11:35 <ihope> Uh... what?
11:11:43 <ihope> Like IO a -> String?
11:11:59 <eivuokko> Check System.Process
11:12:16 <psnl> eivuokko: thanks
11:12:17 <ihope> Say, where was that performUnsafeIO thing?
11:12:36 <eivuokko> System.IO.Unsafe
11:12:41 <int-e> @index unsafePerformIO
11:12:42 <lambdabot> System.IO.Unsafe, Foreign
11:12:45 <ihope> :-)
11:12:57 <int-e> lambdabot knows :)
11:13:03 <ihope> @type System.IO.Unsafe.unsafePerformIO
11:13:04 <lambdabot> forall a. IO a -> a
11:13:08 <ihope> >:-)
11:14:11 <ihope> > unsafePerformIO getLine
11:14:13 <lambdabot>  Not in scope: `unsafePerformIO'
11:14:22 <ihope> > System.IO.Unsafe.unsafePerformIO getLine
11:14:24 <lambdabot>  Not in scope: `System.IO.Unsafe.unsafePerformIO'
11:14:33 <ihope> ...Hee hee?
11:17:13 <Cale> http://www.mcplusplus.com/downloads/ -- man this is hilarious.
11:17:55 <o_Rocky> hi Cale
11:17:58 <Cale> hi
11:18:58 <ihope> @index bracket
11:18:59 <lambdabot> Control.Exception, Distribution.Compat.Exception, Graphics.HGL.Draw.Monad,
11:18:59 <lambdabot> Graphics.HGL.Draw, Graphics.HGL.Core, Graphics.HGL
11:20:41 <palomer> pfft
11:21:13 <palomer> pass the dutch?
11:21:20 <palomer> it's not half bad
11:22:31 <ihope> Mmh, dutch
11:24:02 <o_Rocky> Cale: my english is not so good to understat fast words...
11:24:05 <o_Rocky> understand
11:24:50 <pesco> Cale: Where did I hear about this guy before!?
11:24:53 <o_Rocky> it sure looks interesting
11:25:10 <Cale> pesco: do you read Monzy.com?
11:25:22 <Cale> That's where I got linked to him
11:25:27 <Saulzar> Can you really describe it as interesting! It's awful!! :)
11:25:30 <pesco> Cale: Nope...
11:25:55 <pesco> Probably someone else on #haskell mentioned him before.
11:26:13 <Speck> haha "I write symphonies on apple II es in assembly"
11:26:28 <Cale> haha
11:27:00 <ihope> Oh, I just remembered that I was going to write some music in BF-PDA...
11:30:00 <Cale> haha, http://monzy.com/intro/drama_lyrics.html
11:30:29 <ihope> @index newIORef
11:30:30 <lambdabot> Data.IORef
11:31:51 <Cale> terrible, but funny
11:34:43 <ihope> > error "Foobar"
11:34:45 <lambdabot> Add a type signature
11:35:08 <ihope> > error "Foobar" :: Int
11:35:09 <lambdabot> Exception: Foobar
11:35:19 <ihope> > (error . error) "Foobar" :: Int
11:35:20 <lambdabot> Foobar
11:35:47 <Cale> that's interesting
11:36:18 <Cale> > (error . error) (repeat 'a') :: Int
11:36:23 <lambdabot> Terminated
11:36:42 <palomer> @type error
11:36:43 <lambdabot> forall a. [Char] -> a
11:36:54 <palomer> how does that work?
11:37:22 <ihope> Think of it as const (fix id).
11:37:52 <ihope> The rest is just an old Indian trick, done with mirrors.
11:37:55 <Cale> palomer: it terminates the program immediately.
11:37:57 <ihope> Or something like that.
11:38:07 <Cale> (unless the exception is caught in IO)
11:40:50 <ihope> How's that catchy stuff done?
11:41:25 <ihope> @index catch
11:41:26 <lambdabot> Control.Exception, System.IO.Error, Prelude
11:41:33 <ihope> @type catch
11:41:34 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
11:42:25 <Cale> Prelude Control.Exception> Control.Exception.catch (evaluate (error "Hello")) (\e -> return 5) >>= print
11:42:25 <Cale> 5
11:42:57 <Cale> Prelude Control.Exception> Control.Exception.catch (evaluate (error "Hello")) (\e -> return e) >>= print
11:42:57 <Cale> Hello
11:47:09 <ihope> Is there any good way to check for end-of-file?
11:48:06 <ibid> yes
11:50:06 <ihope> ...And what's that?
11:51:04 <ibid> there are several
11:51:13 <ibid> which is the best one depends on what you're doing
11:51:30 <tony2> hIsEOF probably most common.
11:51:43 <ihope> Is that an IO Bool?
11:51:53 <ibid> @type hIsEOF
11:51:54 <lambdabot> Not in scope: `hIsEOF'
11:51:58 <tony2> hIsEOF :: Handle -> IO Bool
11:52:00 <ibid> @type IO.hIsEOF
11:52:01 <lambdabot> GHC.IOBase.Handle -> IO Bool
11:52:03 <ihope> Oh, right.
11:52:33 <ihope> Is there any good way to get the handle for stdin?
11:52:47 <tony2> you can use isEOF instead
11:53:08 <tony2> @type IO.isEOF
11:53:10 <lambdabot> IO Bool
11:53:34 <ibid> @type IO.stdin
11:53:35 <lambdabot> GHC.IOBase.Handle
11:54:19 <ibid> (another way is to check if the stream you got out of getContents is at end or not:)
11:54:59 <JKnecht> wonder what that job that just spammed haskell.org pays?
11:55:21 <ihope> What happened?
11:56:04 <JKnecht> " [Haskell] Bluespec, Inc. is seeking full-time software engineers "
11:56:56 <ihope> @elite b
11:56:57 <lambdabot> 8
11:57:35 <Cale> Oh, that apparently wasn't considered spam or else it wouldn't have appeared :) The list is moderated
11:58:16 <Cale> but yeah, it does seem that there's a good deal of "academic spam" on the mailing lists
12:00:47 <JKnecht> academic is one thing, profit seeking standard employer another I should think.
12:02:19 <Cale> Yeah, I suppose that is different from most of it.
12:02:40 <davidw> isn't lennart augustsson involved in that company?
12:03:17 <davidw> I think that if they are using functional programming to a large degree, it's unusual enough to warrant some spamming :)
12:04:02 <astrolabe> I think what makes spam objectionable is not that it is commercial, but that it is sent indiscriminantly.  I don't think that applies here.
12:07:00 <ulfdoz> The last days I wondered, if there are any pure functional Structures which allow direct access to elements, as for example arrays would do. Does anyone know more than me?
12:07:28 <Cale> How about arrays?
12:07:30 <Cale> heh
12:08:58 <Cale> If you want O(1) lookup, then ordinary Haskell arrays will give you that
12:09:34 <ulfdoz> I'm not sure if it's purely functional. If you change an entry, than you'd need to copy the old array to a new place, before modifying, because bindings to the old array could exist, which aren't allowed to change in content. This is obviously inefficient and I could use lists with same complexity and variable size.
12:09:57 <Cale> Ordinary Haskell arrays don't have O(1) update though
12:10:20 <Cale> If you also want O(1) update, DiffArrays will give you an immutable interface with O(1) update and O(1) access when used in a single threaded fashion.
12:10:33 <Cale> Older copies will get slower over time.
12:10:40 <dcoutts> accumArray gives a restriced form of O(1) updates
12:11:00 <dcoutts> or rather a restricted form *with* O(1) updates
12:11:10 <ulfdoz> interesting. I need to have a look at.
12:11:24 <dcoutts> @type Data.Array.accumArray
12:11:25 <Cale> http://www.haskell.org/haskellwiki/Arrays
12:11:25 <lambdabot> forall e i a.
12:11:25 <lambdabot> (GHC.Arr.Ix i) =>
12:11:25 <lambdabot> (e -> a -> e) -> e -> (i, i) -> [(i, a)] -> GHC.Arr.Array i e
12:11:59 <astrolabe> Is there an identity monad somewhere?  Or do I have to write my own?
12:12:08 <Cale> Control.Monad.Identity
12:12:10 <gour> dcoutts: hi,  yesterday when i was out i (surprisingly) found cormen's book in a local bookstore and become convinced it's not for me, i.e. it looks it will be better to get okasaki's book :-)
12:12:20 <astrolabe> Cale: Thanks.
12:12:30 <dcoutts> accumArray builds a new array by consuming a list of entries and a function for combining an existing entry with new entries.
12:13:00 <dcoutts> gour, CLR you mean? Okasaki's is certainly good.
12:14:01 <gour> dcoutts: CLR? don't know. cormen is one of authors, book is about algorithms, similar to knuth's art..
12:14:26 <Trevion> gour, L and R are the other authors.
12:14:40 <gour> Trevion: ok, thanks
12:14:56 <Trevion> I'm more familiar with the second edition, which added Stein to become CLRS.
12:15:16 <ulfdoz> gour: You mean MIX-asm?
12:15:25 <gour> Trevion: it was 2nd ed.
12:15:31 <dcoutts> CLR(S) is good, but it's geared towards imperative languages of course
12:16:07 <Trevion> dcoutts, I've found CLRS to be much more useful as a reference than actually learning much about algorithms in the first place...
12:19:57 <dcoutts> Trevion, yeah
12:19:58 * ibid learned algorithms and data structures from knuth. CLR never worked for me
12:19:58 <ulfdoz> I think, some typeclass "Collection" would be nice. Similar to the quite useful java-interface.
12:20:04 <astrolabe> Is it practical to use imperitive algorithms in haskell?
12:20:52 <gour> dcoutts: yep, okasaki looks just right
12:21:20 <gour> astrolabe: interesting question...
12:21:43 <Trevion> astrolabe, yes, as long as you don't mind having lots of IO type signatures.
12:22:23 <gour> ibid: how is knuth & his algorithms applicable to fp, ie. haskell
12:22:45 <gour> ibid: i mean, his uses his own 'pseudocode' ;)
12:23:01 <ibid> gour: he uses his own assembly language, not pseudocode
12:23:30 <ibid> gour: but knuth is relevant to general programming, like fp is
12:23:35 <ibid> that's my answer :)
12:23:58 <gour> ibid: yes, i'm just joking about his 'machine'
12:24:09 <ibid> the MIX is an interesting thing
12:24:27 <ibid> and actually if i could, i'd buy a MMIX desktop/laptop
12:24:59 <gour> lol
12:25:06 <ibid> seriously
12:25:12 <ibid> (not the doubled M)
12:25:29 <gour> have you got through all volumes (1-3)
12:25:30 <ulfdoz> gour: THere is some emulator for mix out there. Am gmixvm iirc.
12:25:54 <ibid> gour: i've read all of them, but not everything in them
12:26:03 <ibid> i've skimmed the analysis,, mostly
12:26:17 <gour> ibid: of course (reg. not all)
12:26:37 <gour> ibid: and you are familiar with CLRS book?
12:26:45 <ibid> and i didn't find seminumerical stuff interesting - but i've been reading them later)
12:26:54 <Trevion> ulfdoz, there have been a couple of proposals along those lines.  You might be able to turn them up with Google.
12:27:04 <ibid> gour: i have it
12:27:10 <ibid> gour: well, the -S version
12:27:11 <ihope> Ooh. Fast list of prime numbers...
12:27:22 <gour> ibid: and you prefer knuth?
12:27:24 <ibid> gour: above, i meant "not_e_ the doubled M"
12:27:26 <ibid> yes
12:27:29 <ihope> The Sieve of Atkin seems nightmarish enough for my purposes.
12:28:44 <gour> ibid: thanks, have you read okasaki's book?
12:29:54 <gour> ibid: it looks more suited for fp (i mean, data structures)
12:30:48 -ChanServ(ChanServ@services.)- shapr!n=user@2002:51e0:9345:0:0:0:0:2 ACCESS [#haskell] ADD dons 39
12:31:08 <ibid> i've read it
12:31:21 -ChanServ(ChanServ@services.)- shapr!n=user@2002:51e0:9345:0:0:0:0:2 ACCESS [#haskell] DEL dons!*@*
12:31:21 <ibid> as well as the fp algorithms textbook
12:31:50 <gour> well, well, i was looking for someone reg. the 3rd book
12:31:58 <gour> let me check the title
12:33:16 <gour> ibid: is this the one http://www.iro.umontreal.ca/~lapalme/Algorithms-functional.html
12:33:52 <ibid> yes
12:34:22 <gour> how do you like that one?
12:34:47 <ibid> it's a good textbook, as far as i can tell
12:35:43 <gour> atm, i learn from thompson's craft of fp
12:36:09 <gour> does it make sense after that one, or what do you recommend after thompson's book?
12:36:20 <gour> (except doing some practical coding, of course)
12:36:22 <ibid> is haskell your first language?
12:36:38 <ibid> do you know data structures and algorithms?
12:36:42 <ibid> in general, that is
12:37:00 <gour> nope, years ago i did fortran, pascal, c, c++..
12:37:27 <gour> but haskell is my 'come-back' to programming after doing nothing for years..
12:38:01 <gour> so i'm re-learning the stuff, but didn't want to go into imperative arena again, that's why i picked haskell
12:38:30 <ibid> i mean, i'd recommend it as a textbook in a program that teaches cs stuff using haskell
12:38:55 <ibid> but if you know ds&a from elsewhere, okasaki may be a better choice
12:39:08 <gour> that is somehow covered with thompson's book, right'
12:39:48 <shapr> Is Tom Shackell or Neil Mitchell around? I'm wondering if YHC is ready for prime time.
12:39:56 <ibid> gour: "that" being?
12:39:58 <gour> for re-learning algorithms, knuth would be ok (plus okasaki for ds)?
12:40:20 <ibid> i don't know if knuth works for everyone
12:40:46 <gour> ibid: that=thompson's craft
12:41:14 <ibid> that makes no sense. "thompson's craft is somehow covered with thompson's book, right'"?
12:41:42 <gour> ibid: err. fp algorithms textbook == thompson's craft
12:42:03 <shapr> I guess I'll stick to nhc98 for the moment.
12:42:20 <gour> shapr: ??
12:42:37 <ibid> gour: i'm not following
12:43:32 <gour> ibid: does fp algorithms textbook & craft of fp cover similar things, ie. overalapping, so that one does not need both?
12:43:50 <ibid> they don't overlap very much
12:44:39 <gour> so, do you recommend fp algorithms as the one after craft, or better to go with okasaki?
12:45:16 <ulfdoz> Is there a nicer implemenatation (more optimal) for: listSplits xs = let l = length xs in [ splitAt n xs | n <- [1..l]]
12:45:26 <ibid> gour: as i said, if you alredy know data structures and algorithms, okasaki is better. if not, the textbook is better
12:45:54 <ulfdoz> I'm not sure, but could an aquivalent thing work in O(n)?
12:46:20 <dcoutts> ulfdoz, doubt it.
12:46:41 <dcoutts> ulfdoz, you end up with n lists which are on the order of n length each
12:47:03 <gour> ibid: ok. it's clear now. thanks
12:47:24 <ulfdoz> dcoutts: Sounds reasonable as everyone of them has to be constructed.
12:47:49 <ADEpt> evening
12:47:59 <Cale> > uncurry zip . (inits &&& tails) $ [1,2,3,4,5]
12:48:01 <lambdabot> [([],[1,2,3,4,5]),([1],[2,3,4,5]),([1,2],[3,4,5]),([1,2,3],[4,5]),([1,2,3,
12:48:01 <lambdabot> 4],[5]),([1,2,3,4,5],[])]
12:48:03 <ADEpt> i'll try again: how is it possible to get edit rights for hawiki?
12:48:10 <Cale> ADEpt: log in
12:48:31 <ADEpt> Cale: i dont have a login
12:48:37 <Cale> create one :)
12:48:43 <ulfdoz> Cale: nice.
12:49:32 <dcoutts> @seen ndm
12:49:32 <lambdabot> I saw ndm leaving #haskell-overflow, #haskell-blah and #haskell 1 month,
12:49:32 <lambdabot> 2 days, 2 hours, 55 minutes and 28 seconds ago, and I have missed 25 days,
12:49:32 <lambdabot> 6 hours, 32 minutes and 19 seconds since then.
12:50:44 <ulfdoz> @info (&&&)
12:50:44 <lambdabot> Unknown command, try @listcommands.
12:50:53 <ADEpt> Cale: ooops. silly me. found it in user prefs. thnx
12:51:18 <Cale> @index (&&&)
12:51:32 <Cale> @type (Control.Arrow.&&&)
12:52:25 <lambdabot> Control.Arrow
12:52:27 <lambdabot> forall (a :: * -> * -> *) c' c b.
12:52:29 <lambdabot> (Control.Arrow.Arrow a) =>
12:52:31 <lambdabot> a b c -> a b c' -> a b (c, c')
12:52:33 <kosmokramer> must go today 2 alienware laptops price 550 each including shippin case and wireless router, or 1 alienware desktop at 550 including shipping, monitor, speakers, keyboard and mouse and of course the tower. message me on aim at mikcomputing, msn at mcsltd3@hotmail.com or yahoo at mcsltd2 if interested and want to buy
12:53:10 <Cale> kosmokramer: give up. It didn't go yesterday, apparently.
12:53:42 <Cale> http://www.monzy.org/eui/edible-bits.pdf -- this paper is awesome :)
12:54:14 <ulfdoz> umpf, that's hard.
12:54:32 <Cale> ulfdoz: replace a with (->)
12:55:02 <Cale> so it's just  (&&&) :: (b -> c) -> (b -> c') -> b -> (c,c')
12:55:28 <ulfdoz> I see. slowly i get enlighted.
12:55:32 <Drakioned> there's alienware spam here now?
12:55:56 <Cale> Drakioned: this guy's been spamming half of freenode for days
12:56:07 <Drakioned> nice.
12:57:13 <Drakioned> why do I not trust the guy to tell me a laptop..?
12:59:47 <jonkri> hey people
12:59:54 <Cale> hey
13:00:03 <Cale> how goes the Haskell-learning?
13:00:07 <Drakioned> Cale: don't suppose you know anything about hard disks for laptops?
13:00:33 <Cale> Drakioned: nope, nothing in particular -- I've never actually owned a laptop
13:00:54 <Drakioned> ah.. nvm then
13:01:12 <Drakioned> mine died yesterday, need to find a disk to replace it, not sure what would be the best
13:02:37 <jonkri> Cale, quite good thank you. i'm working on the first lesson - http://www.cs.chalmers.se/Cs/Grundutb/Kurser/funvt/intro-assignment/intro.cgi
13:03:40 <kosmokramer> must go today 2 alienware laptops price 550 each including shippin case and wireless router, or 1 alienware desktop at 550 including shipping, monitor, speakers, keyboard and mouse and of course the tower. message me on aim at mikcomputing, msn at mcsltd3@hotmail.com or yahoo at mcsltd2 if interested and want to buy
13:36:35 --- topic: '["Haskell is still the language of choice for discriminating hackers","logs:","http://tunes.org/~nef/logs/haskell/","http://www.haskell.org/learning.html","http://www.haskell.org/tmrwiki/IssueFive","We put the Funk in Funktion","http://sequence.complete.org/hwn/20051129","HCAR 11/2005:","http://haskell.org/communities/"]'
13:36:35 --- topic: set by lambdabot on [Wed Jan 18 01:50:15 2006]
13:36:35 --- names: list (clog_ chucky beelsebob_ davvo cparrott eyck husohuso mauke jonkri cinema Itkovian Drakioned wchogg carp nothingmuch ADEpt neurogeek datenmaulwurf tony2 mista_ Khisanth Twigathy andrew_p Nomius dcoutts_ tibbe exsisonek jberg SyntaxNinja ezraburgh martink Trevion sproingie xinming masm Pupeno o_Rocky jak jorik Muad_Dibber lisppaste2 kpreid_ lypanov Speck binary42 Igloo arjanb Nioate iblechbot ikegami-- kombinator_ cptchaos kolmodin tic lome)
13:36:35 --- names: list (Beelsebob TheHunter newsham Philippa_ wilx Cale fatbrain Lemmih zamez icbt kaol svens dany2k integral kisu scw ulfdoz Saulzar hellish Touqen sieni cjs jimapple lambdabot cmeme johs shrimpx bigbabyjesusfoo ex_nor frederik_ yaarg magagr tumm tic|school pejo stefanw rblackwe vincenz dfhaii djw boegel tmoertel samx ptolomy gdsx thedward clog sethk glasser nomeata genneth mahogny liyang eno-away moonlite eivuokko lispy carp_ iratsu sylvan ksandstr)
13:36:35 --- names: list (gzl dons psnl neologism ramkrsna Poeir borism Trixsey|Laptop ozone cognominal pesco mornfall norpan AtnNn Heffalump cods kosmikus Nanar edwinb tromp_ cpatrick xerox jiing dcoutts arguile tuomov Spark WillKW skylan emu metaperl wli PerlJam stesch spamsch araujo audreyt JohnMeacham juhp wolverian drbean_ musasabi orbitz alch` C-Keen kzm palomer Korollary rep noj Lunar^ cbus jp-autark Matt-W jlouis Wallbraker tewk mattam seafood ricebowl flux__)
13:36:35 --- names: list (earthy ibid ValarQ aleator kpk Jaen JKnecht CLxyz nathan_ resiak)
13:40:08 <NoobLuck> can i combine c++ anhd haskell?
13:41:06 <Muad_Dibber> FFI
13:41:10 <jethr0> moin moin
13:41:17 <Cale> NoobLuck: yeah, though it can be a little awkward because of the way that C++ names its exports
13:41:28 <Cale> (which isn't standardised)
13:41:41 <NoobLuck> i mean .o
13:41:53 <o_Rocky> @search haskell API
13:41:54 <lambdabot> Unknown command, try @listcommands.
13:41:57 <NoobLuck> and calling haskell function 
13:42:06 <NoobLuck> from imperative C
13:42:06 <xerox> IIRC there some ABI churns even between actual C++ compilers...
13:42:15 <eivuokko> You can link haskell and C++ object functions, and call each other through c-interface.
13:42:30 <NoobLuck> :)
13:42:31 <eivuokko> object functions = object files
13:42:35 <NoobLuck> ok
13:42:35 <Cale> o_Rocky: http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
13:42:39 <NoobLuck> thanks
13:42:49 <xerox> Howdy Cale :)
13:42:52 <Cale> xerox: hi
13:42:53 <NoobLuck> now i amlearning
13:43:04 <NoobLuck> but we don't use a compiler
13:43:12 <NoobLuck> only interpeter
13:43:21 <o_Rocky> Cale: let bookmark it ;)
13:43:28 <o_Rocky> let's
13:44:37 <o_Rocky> my english is not very good, but my finguers doesent help :P
13:44:42 <o_Rocky> fingers
13:44:48 <eivuokko> Does latest ghc head have -smp that doesn't require all libraries to be compiled with -smp on?
13:44:54 <NoobLuck> use dvorak
13:45:00 <NoobLuck> dvorak rules
13:45:30 <jonkri> see you all
13:45:54 <Cale> jonkri: see you
13:50:54 <icbt> is quux.org down?
13:51:12 <palomer> how would you guys remove duplicates from a list of strings and sort by frequency?
13:51:45 <xerox> palomer: either one or the other I'd say.
13:51:57 <xerox> > nub [1,1,2,3,3,3,4,4]
13:51:59 <lambdabot> [1,2,3,4]
13:52:11 <xerox> > sort . group $ [1,1,2,3,3,3,4,4]
13:52:13 <lambdabot> [[1,1],[2],[3,3,3],[4,4]]
13:52:31 <o_Rocky> Any one knows something about Arrows?
13:52:34 <xerox> > sort . (length &&& id) . group $ [1,1,2,3,3,3,4,4]
13:52:36 <lambdabot> Couldn't match `[a]' against `(Int, [[a1]])'
13:52:43 <icbt> zup, rocky
13:52:49 <o_Rocky> could give me a short brief?
13:53:10 <icbt> what are you trying to do
13:53:15 <o_Rocky> nothing...
13:53:25 <o_Rocky> i just want to know what it is
13:53:29 <xerox> > sort . map (length &&& id) . group $ [1,1,2,3,3,3,4,4]
13:53:31 <lambdabot> [(1,[2]),(2,[1,1]),(2,[4,4]),(3,[3,3,3])]
13:53:49 <icbt> it is a construct more general than monad
13:53:59 <o_Rocky> uhmmm
13:54:07 <palomer> > map fst ( sort . map (length &&& id) . group $ [1,1,2,3,3,3,4,4])
13:54:09 <lambdabot> [1,2,2,3]
13:54:28 <palomer> > map (fst.snd) ( sort . map (length &&& id) . group $ [1,1,2,3,3,3,4,4])
13:54:29 <lambdabot> Couldn't match `(a, b)' against `[a1]'
13:54:39 <xerox> > sort . map length . group $ [1,1,2,3,3,3,4,4]
13:54:39 <icbt> read the, hug00 paper http://www.cs.chalmers.se/~rjmh/Papers/arrows.pdf
13:54:40 <gzl> fst.snd??
13:54:41 <lambdabot> [1,2,2,3]
13:55:00 <palomer> > map snd ( sort . map (length &&& id) . group $ [1,1,2,3,3,3,4,4])
13:55:01 <lambdabot> [[2],[1,1],[4,4],[3,3,3]]
13:55:13 <xerox> > sort . group $ [1,1,2,3,3,3,4,4]
13:55:15 <lambdabot> [[1,1],[2],[3,3,3],[4,4]]
13:55:18 <o_Rocky> icbt: is it simple to use?
13:55:19 <xerox> > sort . map length . group $ [1,1,2,3,3,3,4,4]
13:55:20 <palomer> > map (snd.fst) ( sort . map (length &&& id) . group $ [1,1,2,3,3,3,4,4])
13:55:21 <lambdabot> [1,2,2,3]
13:55:21 <lambdabot> Couldn't match `(a, b)' against `Int'
13:55:24 <gzl> ...what are you trying to do?
13:55:24 <xerox> palomer: read that.
13:55:36 <palomer> xerox: not sorting the frequencies, sorting the elements
13:55:42 <icbt> rocky, it is a mess to use, it is better with the sugar
13:55:48 <palomer> by their frequency
13:55:49 <xerox> > sort . map (id &&& length) . group $ [1,1,2,3,3,3,4,4]
13:55:51 <lambdabot> [([1,1],2),([2],1),([3,3,3],3),([4,4],2)]
13:55:55 <Trevion> > map head (sort . map (length &&& id) . group $ [1,1,2,3,3,3,4,4])
13:55:56 <lambdabot> Couldn't match `[a]' against `(Int, [a1])'
13:56:01 <xerox> This is sorted by the elements.
13:56:08 <Trevion> > map (head . snd) (sort . map (length &&& id) . group $ [1,1,2,3,3,3,4,4])
13:56:10 <lambdabot> [2,1,4,3]
13:56:14 <xerox> > sort . map (length &&& head) . group $ [1,1,2,3,3,3,4,4]
13:56:16 <lambdabot> [(1,2),(2,1),(2,4),(3,3)]
13:56:24 <xerox> This is sorted by their frequency.
13:56:30 <Itkovian> hmm, my haskell code is like 10 times slower than similar python which seems a bit odd to me
13:57:05 <palomer> xerox: but I don't neetd the frequencies
13:57:10 <xerox> palomer: what do you need?
13:57:15 <Trevion> palomer, was mine what you wanted?
13:57:16 <palomer> the elements only
13:57:19 <palomer> Trevion: yeah
13:57:34 <xerox> > map snd . sort . map (length &&& head) . group $ [1,1,2,3,3,3,4,4]
13:57:36 <lambdabot> [2,1,4,3]
13:58:18 <palomer> great, thx
13:58:19 <xerox> > [x | (_,x) <- sort . map (length &&& head) . group $ xs] where xs = [1,1,1,1,2,2,3,3,3,4]
13:58:21 <lambdabot> [4,2,3,1]
13:58:38 <Itkovian> @hoogle &&&
13:58:39 <lambdabot> Control.Arrow.(&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
13:59:17 <xerox> Itkovian: (f &&& g) x = (f x, g x) (for the Arrow (->) instance)
13:59:31 <palomer>  > map snd . sort . map (length &&& head) . group [1,1,2,3,3,3,4,4]
13:59:34 <palomer> > map snd . sort . map (length &&& head) . group [1,1,2,3,3,3,4,4]
13:59:36 <lambdabot>   Expecting a function type, but found `[[a]]'
13:59:36 <lambdabot>   Expected type: a1 -> [[a]]
13:59:36 <lambdabot>   Inferred type: [[a2]]
13:59:42 <xerox> palomer: '$'
13:59:45 <xerox> Itkovian: then you have (f *** g) (x,y) = (f x,g y)
13:59:46 <palomer> why do we need the $?
13:59:58 <palomer> because . is weaker than application?
14:00:14 <xerox> @type \f g x -> f . g x
14:00:16 <lambdabot> forall b c a t. (b -> c) -> (t -> a -> b) -> t -> a -> c
14:00:19 <xerox> @type \f g x -> f . g $ x
14:00:21 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
14:00:49 <xerox> Itkovian: also, first f (x,y) = (f x,y) and second f (x,y) = (x,f y).
14:01:10 <Itkovian> uhu.
14:01:13 <Itkovian> I'm off to bed
14:01:16 <xerox> Itkovian: g'night!
14:01:26 <Itkovian> I'll figure out the slowness of my Haskell code tomorrow
14:02:04 <xerox> palomer: \f g x -> f . g x =~= \f g x -> f . (g x) =~= \f g x y -> f (g x y)
14:02:22 <xerox> palomer: \f g x -> f . g $ x =~= \f g x -> f (g x)
14:02:45 <palomer> EH?
14:03:06 <Itkovian> lol
14:03:10 <xerox> uh.
14:03:31 <Itkovian> palomer: he's right
14:03:38 <Itkovian> he always is
14:03:41 * Itkovian bows
14:03:42 <xerox> UH.
14:03:50 <xerox> Not really.  :-)
14:04:00 <xerox> But this time I'm pretty sure it is right.
14:04:01 <palomer> right about what?
14:04:11 <Itkovian> the necessity of $
14:04:29 <palomer> oh, right, because . is quite a weak operator
14:05:05 <palomer> oh wait, maybe not
14:05:07 <palomer> hrmph
14:05:09 <palomer> I'll masticate this
14:05:10 <palomer> bbl
14:06:24 <gzl> you could also define one function that grabs number of occurrences and then sortBy occurrences xs
14:06:26 <Itkovian> I would love arrows, if I could grok them
14:06:33 <Itkovian> And now I;m really off to sleep
14:06:36 <gzl> er, more or less
14:26:46 <ADEpt> Say, what do you think about this piece of code (and text): http://www.haskell.org/hawiki/QuickCheckAsTestSetGenerator ?
14:29:04 <ihope> > maybe
14:29:05 <lambdabot>   add an instance declaration for (Show (b -> (a -> b) -> Maybe a -> b))
14:30:21 <ihope> > maybe Nothing Just
14:30:23 <lambdabot>  add an instance declaration for (Show (Maybe a -> Maybe a))
14:30:43 <ibid> @type maybe
14:30:44 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
14:30:46 <chucky> adept: very interesting
14:31:42 <ADEpt> chucky: cool
14:31:45 <xerox> > let ihope = maybe 0 (==2) in (ihope (Just 1), ihope Nothing)
14:31:46 <lambdabot>  add an instance declaration for (Num Bool)
14:31:50 <xerox> Foo :-)
14:32:20 <ihope> Heh
14:32:33 <xerox> > let ihope = maybe 0 (+1) in (ihope (Just 1), ihope Nothing)
14:32:35 <lambdabot> (2,0)
14:33:36 <chucky> adept: I've thought about the use of QuickCheck as a test set generator before, though your implementation seems a lot more thought out than anything I've built
14:36:11 <ADEpt> chucky: i've refactored it three times along the way in order not to be buried by code :) In the end I had 40 datatyps (along with "instance Variant ..." for each of them), so I had to economize
14:39:57 <chucky> a slight comment on your writing: You're writing it from a first person perspective, but there's no mention of who actually wrote the text
14:40:24 <chucky> (although it can of course be inferred from the changelog)
14:43:43 <ADEpt> chucky: hmm. I wonder how to fix that :)
14:44:06 <chucky> Well you could sign it? :)
14:45:34 <ADEpt> ah
14:46:26 <ADEpt> chucky: i also added section on using template haskell for automatic instance derivation, which greatly simplified the job
14:48:19 <chucky> hmm I ought to learn template haskell some day. :) Well, I'm off to bed, thanks for the interesting reading
14:48:26 <xerox> Goodnight!
14:48:38 <chucky> good night everyon
14:48:40 <chucky> e
14:59:36 <newsham> anyone here good with template haskell?  I'm having problems understanding how you would put together a complex   [d| ... |]   that is built by iteration
15:00:19 <jethr0> newsham: not sure i can help, but if you could explain what you mean... :)
15:04:35 <newsham> the moral equivalent of:   print "new$name = $name {"; for f,v in fields { print "    $f = $v," } ;  print "}"
15:05:00 <newsham> ie. one declaration built up by iterating over a list of things
15:05:35 <newsham> make sense?
15:06:47 <Cale> newsham: you probably wouldn't use [d| ... |], I think
15:07:18 <Cale> I'm not all that familiar with TH, but I think you'd probably build the syntax tree directly.
15:07:48 <newsham> sounds like fun :)
15:08:03 <jethr0> shouldn't be that bad.
15:08:39 <newsham> would be easier if i could find documentation.  know where the types QExp and Q [Dec] are declared?
15:08:55 <jethr0> http://www.haskell.org/hawiki/TemplateHaskellTutorial
15:08:58 <jethr0> shameless plug :)
15:10:00 <newsham> thanks.
15:10:01 <jethr0> $([d| b = pi |] >>= lift . show)
15:10:16 <jethr0> this will show you how the AST should look like...
15:10:26 <ADEpt> newsham: ah. take a look at: http://www.haskell.org/pipermail/template-haskell/2005-October/000488.html
15:13:56 <newsham> $(reify 'even >>= lift . pprint)  <- whats the single quote do?
15:18:13 <jethr0> newsham: it's for name resolution... similar to (dynE "even") or (varE (mkName "even"))
15:18:19 <jethr0> $([d| o = T {a = 2, b = 3}|] >>= lift . show)
15:18:27 <jethr0> "[ValD (VarP o) (NormalB (RecConE Test.T [(Test.a,LitE (IntegerL 2)),(Test.b,LitE (IntegerL 3))])) []]"
15:18:57 <jethr0> where "T" was declared in module "Test"
15:19:45 <jethr0> newsham: so, you can simple take the first part, build up the list inside "RecConE" and you should be done :)
15:19:50 <newsham> its all flying over my head like a beautiful meteor shower
15:20:14 <jethr0> well, i'm sure there a much cleaner way of doing this...
15:20:16 <newsham> Prelude Language.Haskell.TH Monad> reify 'Int
15:20:16 <newsham> <interactive>:1:6: Not in scope: data constructor `Int'
15:20:35 <jethr0> for types it should be two quotes, sry
15:20:39 <jethr0> reify ''Int
15:20:51 <newsham> that worked (although not Showable)
15:20:55 <jethr0> i should rework some parts of my tutorial for clarity
15:21:15 <jethr0> $(reify ''Int >>= lift . pprint)
15:21:16 <newsham> where is the "lift" operator you're using in the hawiki
15:21:31 <jethr0> Language.Haskell.TH.Syntax
15:23:27 <newsham> Prelude Language.Haskell.TH Monad Language.Haskell.TH.Syntax> reify ''Int >>= lift . pprint
15:23:27 <newsham> Top level:
15:23:27 <newsham>     No instance for (Show (Q Exp))
15:23:27 <newsham>       arising from use of `print' at Top level
15:23:28 <newsham>     Probable fix: add an instance declara
15:23:49 <newsham> oh, pprint returns a Q Exp?
15:24:29 <jethr0> pprint
15:24:40 <jethr0> @hoogle pprint
15:24:40 <lambdabot> Language.Haskell.TH.Ppr.pprint :: Ppr a => a -> String
15:24:40 <lambdabot> Language.Haskell.TH.pprint :: Ppr a => a -> String
15:25:09 <jethr0> no, but i have to lift the string so that it becomes a "Q Exp" again :)
15:25:51 <jethr0> @hoogle  Language.Haskell.TH.Syntax.lift
15:25:52 <lambdabot> Prelude.undefined :: a
15:25:52 <lambdabot> Test.QuickCheck.Batch.bottom :: a
15:25:59 <jethr0> huh?
15:27:19 <ihope> Hmm, did I just do something?
15:27:37 <jethr0> ihope: welcome aboard *g*
15:29:09 <newsham> *still reading tutorial, then I'll return to your earlier examples*
15:30:13 <jethr0> newsham: well, what you are trying to do is pretty advanced already. it took me ages to wrap my head around TH's little awkwardnesses...
15:31:06 <newsham> the program does not know that it is hard, just that it must be written.
15:31:53 <jethr0> i (maybe) missed the start of your thread. why can't you use drift for this?
15:32:22 <newsham> because drift is broken.  i sent mail to the author, he said so.
15:33:30 <jethr0> oh
15:33:44 <jethr0> i'll see if i can get my idea of a solution for you to work...
15:33:51 <ihope> I want Haskell to have more parentheses. Lisp looks nice with all its parentheses.
15:34:45 <newsham> you can write lisp-looking code.  see #2 at http://www.willamette.edu/~fruehr/haskell/evolution.html
15:35:24 <Lor> I wrote like that when I just learned Haskell. :)
15:35:43 <ihope> :-)
15:35:58 <ihope> I could write a spec for Haskell Lisp...
15:37:37 <newsham> jethr0> $([d| o = T {a = 2, b = 3}|] >>= lift . show)
15:37:37 <newsham> <jethr0> "[ValD (VarP o) (NormalB (RecConE Test.T [(Test.a,LitE (IntegerL
15:37:37 <newsham> +2)),(Test.b,LitE (IntegerL 3))])) []]"
15:38:00 <newsham> so you're basically saying use the big expression, except build my own RecConE bit.
15:38:23 <jethr0> newsham: i'll fix the little uglinesses and paste it in a few minutes
15:38:37 <jethr0> $(return $ RecConE (mkName "Test.T") [(mkName "Test.a",LitE (IntegerL 2)),(mkName "Test.b",LitE (IntegerL 3))])
15:38:40 <newsham> is there any way to combine $()'s or $[]'s ?
15:38:55 <jethr0> what is "$[]"?
15:39:12 <newsham> err. [|...|]  and [d|...|]
15:39:53 <newsham> would be nice if I could   [d| o = { |] .. some stuff ... [| } |]
15:40:16 <jethr0> newsham: only when you splice inside. [d| a = $([| 5 |]) |]
15:40:20 <ihope> > length "_ara_eta_o___ruse_endroneo___in"
15:40:22 <lambdabot> 31
15:41:59 <jethr0> newsham: BTW: do you want to construct a record or update it?
15:42:15 <jethr0> away, will be back in a sec
15:43:11 <newsham> I want to turn:  http://lava.net/~newsham/x/jethr0a.txt   into http://lava.net/~newsham/x/jethr0b.txt
15:43:20 <newsham> the example I gave is just a simplification of my real goal
15:43:47 <newsham> I have a small python program which reads in a spec and generates that..  obvious using TH to generate Haskell would be preferable
15:46:06 <Pseudonym> G'day.
15:46:12 <newsham> hi
15:48:37 <Pseudonym> Whoops.
15:48:43 <Pseudonym> Wrong channel. :-)
15:48:49 <Pseudonym> Hello nonetheless.
15:48:57 <newsham> i would like to take my greeting back.
15:49:10 * xerox hugs Pseudonym
15:49:30 <jethr0> newsham: a good way to go about it is to type the target code and let TH print its AST "$([| <code> |] >>= lift . show)"
15:49:48 <jethr0> then you'll just have to add a few "mkName"s and "return"s...
15:50:10 <Pseudonym> Awww, thanks xerox.
15:50:32 <Pseudonym> Well I'd like to greet everyone wholeheartedly, even if I've been in the channel for an hour or so already.
15:50:42 <Pseudonym> That includes newsham even if it's not reciprocated.
15:50:53 <newsham> jethr0: seems like a fairly easy way to get something working, but it will be god aweful ugly and hard to maintain :(
15:51:02 <xerox> ....and I'll depart to read some book and sleep a while :-)  Goodnight fellows.
15:51:35 <Pseudonym> Night.
15:51:54 <Pseudonym> Well, I'm not going to greet you again if you're just going to leave straight away.
15:52:20 <newsham> the greet-gate scandal of 2006
15:52:53 <jethr0> newsham: kinda
15:53:25 <jethr0> but if you make function to create certain structures, the ugly code is small and localized
15:56:10 <newsham> so I should be able to use quasi quotes to generate each individual component of the overal declaration, and then just the ugliness to splice the pieces together, no?
15:56:49 <newsham> ie. each of the getByteAt declarations in jethr0b.txt
15:57:17 <dcoutts> AAArg!
15:57:18 * dcoutts throws Html/CSS away in disgust!
15:57:41 <dcoutts> I'm only tring to do something simple
15:57:52 <dcoutts> in the haddock-generated docs
15:58:20 <dcoutts> I just want to stick a bit of text at the right-hand side of the page
15:59:01 <jethr0> newsham: i'm not sure i understood that
15:59:21 <newsham> did you see the jethr0a.txt and jethr0b.txt I pasted?
15:59:35 <jethr0> yes
15:59:54 <newsham> basically jethr0b.txt has a bunch of "getByteAt" declarations.   I was wondering if I can just use a quasi-quoted decl to generate the AST for each decl
16:00:07 <newsham> and then have some function (which would be doing ugly AST construction) to connect those into the proper scope
16:00:41 <jethr0> i'm not sure whether "where" declarations count as decls!
16:00:53 <newsham> heh.. that would be too easy! :)
16:01:06 <newsham> ok, I need to print out the reification of these puppies
16:01:41 <jethr0> yes, good idea
16:02:41 <ihope> Omgwtfbbq.
16:02:54 <newsham> hmm.. how do I reify the instance statement?
16:02:59 <newsham> (how do I reference it?)
16:04:06 <Lemmih> newsham: You don't.
16:04:12 <jethr0> should be a declaration. so "$([d| instance ... |] >>= lift . show)" should do the trick
16:04:49 <ihope> Haskell doesn't have fix const! *cries*
16:05:39 <jethr0> ihope: fix const?
16:05:52 <ihope> Takes an argument and returns itself.
16:06:23 <jethr0> const
16:06:25 <jethr0> > const 4
16:06:26 <lambdabot>  add an instance declaration for (Show (b -> a))
16:06:29 <ihope> > fix const
16:06:30 <Heffalump> you can simulate it with a type class
16:06:30 <lambdabot>   Occurs check: cannot construct the infinite type: t = b -> t
16:06:30 <lambdabot>   Expected type: (b -> t) -> b -> t
16:06:30 <lambdabot>   Inferred type: (b -> t) -> b -> b -> t
16:06:49 <jethr0> ah, returns "itself"...
16:07:07 <Heffalump> oh, maybe not, sorry
16:07:14 <ihope> How about fix fix?
16:07:30 <ihope> Well, we *do* have fix id...
16:07:58 <ihope> > fix error
16:08:04 <lambdabot> Terminated
16:08:39 <ihope> And, of course, there's the fact that (fix error) and (error (fix error)) have different types.
16:14:18 <Heffalump> @type fix error
16:14:19 <lambdabot> Not in scope: `fix'
16:14:26 <Heffalump> @type Control.Monad.Fix.fix error
16:14:28 <lambdabot> [Char]
16:15:00 <Heffalump> @type error (Control.Monad.Fix.fix error)
16:15:01 <lambdabot> forall a. a
16:15:10 <Heffalump> that's really cool
16:15:29 * Heffalump tries to understand why.
16:16:10 <lisppaste2> jethr0 pasted "TH magic" at http://paste.lisp.org/display/15794
16:16:32 <jethr0> newsham: still there?
16:16:48 <Lemmih> The error given to 'fix' has type '[Char] -> [Char]' where the error applied to 'fix' has type '[Char] -> a'.
16:16:58 <newsham> yes, got another question :)
16:17:22 <newsham> http://lava.net/~newsham/x/jethr0c.txt
16:17:48 <newsham> the file compiles without the big $( .. )   but I get an error if I put in the $( ... )
16:17:55 <Heffalump> Lemmih: yes, I understand that
16:18:12 <Heffalump> I'm just trying to figure out why it is that beta-reduction causes the type to become more general
16:18:13 <jethr0> newsham: have a look at my lisppaste above
16:18:27 <Heffalump> @type let fix f = f (fix f) in fix error
16:18:29 <lambdabot> [Char]
16:18:34 <Heffalump> @type let fix f = f (fix f) in error (fix error)
16:18:35 <lambdabot> forall a. a
16:18:47 <Igloo> Because the outer error has type String -> a
16:18:51 <jethr0> newsham: my guess is identation!
16:19:13 <jethr0> getByteAt should be indented far more to the right!
16:19:16 <Heffalump> can you give an example not involving error or non-termination where beta-reduction can cause the type to become generalised?
16:19:30 <newsham> hmm.. yup, I added more indents and I get different errors :)
16:19:49 <ihope> > fix (const Nothing)
16:19:51 <lambdabot> Add a type signature
16:19:58 <ihope> > fix (const Nothing) :: Maybe a
16:19:59 <lambdabot> Add a type signature
16:20:02 <ihope> > fix (const Nothing) :: Maybe Int
16:20:04 <lambdabot> Nothing
16:20:15 <Heffalump> @type let fix f = f (fix f) in fix (const Nothing)
16:20:16 <lambdabot> forall a. Maybe a
16:20:24 <Heffalump> @type let fix f = f (fix f) in const Nothing (fix (const Nothing))
16:20:25 <lambdabot> forall a. Maybe a
16:20:31 <ihope> Heh...
16:21:05 <Igloo> toEnum
16:21:49 <Igloo> Oh, you want one that's not an infinite loop?
16:21:53 <ihope> @type toEnum
16:21:54 <lambdabot> forall a. (Enum a) => Int -> a
16:22:09 <NoobLuck> > "aaa" ++ "bbb"
16:22:10 <lambdabot> "aaabbb"
16:22:14 <NoobLuck> ohh
16:22:19 <NoobLuck> i feel the power
16:22:21 <NoobLuck> XDD
16:22:24 <ihope> :-)
16:22:54 <ihope> What's lhs?
16:23:20 <NoobLuck> > pot2 a
16:23:22 <lambdabot>  Not in scope: `a'
16:23:24 <NoobLuck> >a*a
16:23:59 <ihope> Whoa. So lambdabot's pretty much a literate comment deal?
16:24:07 <ihope> ...Plus @ stuff?
16:24:52 <NoobLuck> aa ok
16:25:07 <ihope> > \a -> a*a
16:25:08 <lambdabot>  add an instance declaration for (Show (a -> a))
16:25:16 <ihope> > (\a -> a*a) 5
16:25:17 <lambdabot> 25
16:25:28 <NoobLuck> okkkk
16:25:30 <NoobLuck> XDD
16:25:41 <NoobLuck> what is \a?
16:25:50 <newsham> jehtr0: its not liking [d| instance ... |]
16:25:50 <ihope> That's a lambda.
16:25:55 <newsham> yy.lhs:19:4:
16:25:55 <newsham>     Couldn't match `[Dec]' against `Exp'
16:25:55 <newsham>       Expected type: Q [Dec]
16:25:55 <newsham>       Inferred type: Q Exp
16:25:55 <newsham>     In the expression:
16:25:56 <newsham>         [d| []
16:25:58 <newsham>             instance {ByteContainer IP} where
16:26:00 <newsham> ...
16:26:03 <ihope> \a -> stuff is a function that takes a and returns stuff.
16:26:10 <Igloo> @type let g xs = undefined:map undefined (xs :: [Int]) in let fix f = f (fix f) in (g (fix g), fix g)
16:26:12 <lambdabot> forall b. ([b], [Int])
16:26:25 <NoobLuck> is a type declaration?
16:26:39 <Igloo> Heffalump: That'll give you an infinite list of undefineds. Is that good enough?
16:27:35 <NoobLuck> > 5*5 
16:27:37 <lambdabot> 25
16:27:45 <ihope> NoobLuck: the a there represents the value itself, not its type.
16:27:53 <NoobLuck> ok
16:28:00 <newsham> > map fromEnum "hi noob!"
16:28:02 <lambdabot> [104,105,32,110,111,111,98,33]
16:28:17 <newsham> > map toEnum [104,105,32,110,111,111,98,33] :: String
16:28:17 <ihope> So (\x -> "Hello" ++ x) appends "Hello" to the front of a string...
16:28:18 <lambdabot> "hi noob!"
16:28:31 <NoobLuck> lol
16:28:31 <ihope> > (\x -> "Hello" ++ x) ", world!"
16:28:33 <lambdabot> "Hello, world!"
16:28:49 <NoobLuck> this is like an interpeter?
16:28:53 <ihope> Yep.
16:28:56 <jethr0> newsham: have you tried putting a single declaration inside [d| |] instead of multiple?
16:29:10 <NoobLuck> ok i know how to use modules
16:29:13 <NoobLuck> to write
16:30:12 <NoobLuck> 'a' < 'z'
16:30:16 <NoobLuck> > 'a' < 'z'
16:30:18 <lambdabot> True
16:30:25 <jethr0> newsham: "$([d| instance Num T |])" works for me!
16:30:46 <NoobLuck> > pi
16:30:48 <lambdabot> 3.141592653589793
16:31:27 <jethr0> newsham: i gotta go for a while. i'll be back in half an hour or so
16:31:28 <newsham> hmm.. yah, its working if I take some of the decls out of the instance
16:31:53 <ihope> > fix show
16:31:55 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\
16:31:55 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\
16:31:55 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
16:31:55 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
16:31:55 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
16:31:57 <lambdabot> [23 @more lines]
16:32:02 <ihope> I shouldn't have done that.
16:32:36 <NoobLuck> @where cabal
16:32:38 <lambdabot> http://www.haskell.org/cabal
16:32:42 <NoobLuck> @where reference
16:32:43 <lambdabot> I know nothing about reference.
16:32:50 <newsham> oh, hmm.. its not like the   >>= lift .show bit
16:32:53 <NoobLuck> @where quickreference
16:32:54 <lambdabot> I know nothing about quickreference.
16:32:57 <NoobLuck> @where quick-reference
16:32:58 <lambdabot> I know nothing about quick-reference.
16:33:01 <NoobLuck> lol
16:33:16 <NoobLuck> @where manual
16:33:17 <lambdabot> I know nothing about manual.
16:33:42 <NoobLuck> yau can always chat with the bot
16:33:47 <NoobLuck> ^_^
16:34:06 <ihope> Hello, lambdabot!
16:34:46 <ihope> You know, I find it frustrating that doing a little letter-shift of "lambdabot" produces "lamdabbot", which is pronounced exactly the same.
16:35:48 <NoobLuck> so
16:35:50 <NoobLuck> ...
16:36:01 <Heffalump> igloo: hmm. I don't think so.
16:36:07 <jethr0> newsham: what isn't like "lift . show"?
16:36:16 <NoobLuck> i dont undersntand im not english speeaker
16:36:27 <Heffalump> I think it's just the same trick as before, magicing a polymorphic type out of nowhere using undefined.
16:36:39 <NoobLuck> okk
16:36:53 <NoobLuck> it i not the same pronunciation
16:37:04 <NoobLuck> you change the accent
16:37:11 <NoobLuck> lambdaBOT
16:37:21 <NoobLuck> lambDAbot
16:37:26 <NoobLuck> lambDAbbot
16:37:33 <ncalexan> @type repeatM_
16:37:35 <lambdabot> Not in scope: `repeatM_'
16:37:42 <NoobLuck> no?
16:37:45 <ncalexan> @type Control.Monad.repeatM_
16:37:46 <lambdabot> Not in scope: `Control.Monad.repeatM_'
16:37:54 <ncalexan> @index repeatM
16:37:55 <lambdabot> bzzt
16:37:55 <NoobLuck> @type ++
16:37:57 <lambdabot> parse error on input `++'
16:37:58 <Cale> unfortunately it's not in Control.Monad at all
16:37:58 <Igloo> Heffalump: let g xs = toEnum 1:map toEnum (xs :: [Int]) in let fix f = f (fix f) in (fix g, g (fix g))   then
16:38:02 <NoobLuck> @type "++"
16:38:04 <lambdabot> [Char]
16:38:07 <ihope> @type (++)
16:38:08 <lambdabot> forall a. [a] -> [a] -> [a]
16:38:10 <Cale> but it *really* should be
16:38:10 <ncalexan> Cale: Mmm, is it somewhere standard?
16:38:13 <Cale> no
16:38:13 <NoobLuck> @type (++)
16:38:15 <lambdabot> forall a. [a] -> [a] -> [a]
16:38:17 <NoobLuck> ok
16:38:30 <NoobLuck> curry
16:38:31 <NoobLuck> !!
16:38:42 <Cale> repeatM = sequence . repeat
16:38:53 <Cale> repeatM_ = sequence_ . repeat
16:38:54 <Igloo> Heffalump: Then I can take 5 ... :: [Bool] in the expanded case to get [True,True,True,True,True]
16:39:08 <ncalexan> Yes, the streamlining of the hierarchical libraries really needs a boost... community ownership is planned, right?
16:39:31 <Cale> I think we're in the midst of a gradual transition to darcs
16:40:00 <Heffalump> Igloo: I don't follow
16:40:04 <ncalexan> Yeah, that seems to be the idea... hard to tell what that will really mean, though.
16:40:11 <Cale> Which will make patches a good deal easier. I don't really know how to use CVS properly anyway, even if I had an account.
16:40:18 <Igloo> > take 5 $ let g xs = toEnum 1:map toEnum (xs :: [Int]) in let fix f = f (fix f) in g (fix g) :: [Bool]
16:40:20 <lambdabot> [True,True,True,True,True]
16:40:21 <Cale> (I suppose I could learn)
16:40:23 <ncalexan> I'd hate to be patch-master :)
16:40:36 <Igloo> @type let g xs = toEnum 1:map toEnum (xs :: [Int]) in let fix f = f (fix f) in (fix g, g (fix g))
16:40:38 <lambdabot> forall a. (Enum a) => ([Int], [a])
16:41:00 <Cale> ncalexan: at worst, libraries@haskell.org can become the patch master :)
16:41:03 <ncalexan> Cale: darcs is, on the outside, very similar to CVS -- it's in what it does on the inside that' squite different.
16:41:33 <Heffalump> ok, I think I see. Thanks.
16:41:56 <Heffalump> you could play that game with any injection function.
16:42:08 <Heffalump> though of course, the type class introduces a hidden parameter, effectively
16:42:51 <ihope> Hmm, continuation passing style
16:44:00 <newsham> cant figure out how to print a Q [Dec]
16:45:46 <Heffalump> newsham: pull out the [Dec] and print that?
16:58:47 <jethr0> newsham: hmm, maybe with "x >>= lift . fmap print"? just an idea...
16:59:26 <newsham> yy.lhs:18:4:
16:59:26 <newsham>     Couldn't match `[Dec]' against `Exp'
16:59:26 <newsham>       Expected type: Q [Dec]
16:59:26 <newsham>       Inferred type: Q Exp
16:59:35 <newsham> lift is for Exp
16:59:38 <newsham> err. Q Exp
16:59:50 <jethr0> no, that was wrong.
17:00:04 <jethr0> what i said
17:00:13 <jethr0> when haskell'se's complaining
17:00:35 <newsham> lift :: t -> Q Exp
17:01:04 <jethr0> when haskell's complaining about "[Dec]" vs "Exp" it's most often a problem about where the splice stands. "x = $(...)" vs "$(...)"
17:01:23 <jethr0> in the second TH expects declarations to be inside the splice
17:01:37 <newsham> [d| ... |]   returns a Q [Dec].   lift is   t -> Q Exp
17:01:57 <jethr0> yes, but where are you using lift?
17:02:23 <newsham> http://lava.net/~newsham/x/yy.lhs
17:02:44 <newsham> if I get rid of the ">>= lift . fmap print"  it compiles 
17:03:16 <newsham> XX.lhs at the same place if you want it
17:03:27 <jethr0> yes, that's because printing returns an expression whereas [d||] returns a declaration
17:03:55 <jethr0> so, when you want to print, you'll have to assign the expression to something "x = $(...)"
17:03:59 <newsham> so how do I print it and then return a decl?
17:04:17 <jethr0> why do you need both?
17:04:45 <newsham> if its inside an x = $( ... ) it also doesnt work
17:04:53 <newsham> yy.lhs:51:41:
17:04:53 <newsham>     No instance for (Lift (IO ()))
17:04:53 <newsham>       arising from use of `lift' at yy.lhs:51:41-44
17:05:38 <jethr0> yes, the fmap wasn't exactly right... what exactly are you trying to do? printing it for debugging purposes?
17:05:57 <newsham> yes. print out what the big [Dec] looks like for that thing
17:06:04 <newsham> as you suggested :)
17:06:44 <jethr0> the [d||] returns a "Q [Dec]". ">>=" strips the "Q". so if you want to have a string you have to print each "Dec", concatenate them and then lift them again
17:07:35 <jethr0> @hoogle concat
17:07:36 <lambdabot> Data.List.concat :: [[a]] -> [a]
17:07:36 <lambdabot> Prelude.concat :: [[a]] -> [a]
17:07:36 <lambdabot> Data.List.concatMap :: (a -> [b]) -> [a] -> [b]
17:08:27 <jethr0> so, sth like: "$([d|...|] >>= lift . concat . map pprint/show)"
17:09:02 <newsham> wont print return ()'s ?
17:09:43 <jethr0> ??
17:09:46 <jethr0> @hoogle print
17:09:47 <lambdabot> Prelude.print :: Show a => a -> IO ()
17:09:47 <lambdabot> System.IO.print :: Show a => a -> IO ()
17:09:47 <lambdabot> Text.Printf.Print :: Print
17:10:12 <jethr0> ah, ok. rarely have used print myself
17:10:22 <newsham> @ hoogle pprint
17:10:23 <lambdabot> Maybe you meant: . all-dicts arr babel botsnack choice-add code compose
17:10:23 <lambdabot> devils dice dict dict-help djinn djinn-add djinn-clr djinn-del djinn-env
17:10:23 <lambdabot> djinn-ver docs dummy dynamic-load dynamic-reload dynamic-unload easton
17:10:23 <lambdabot> echo elements elite eurohaskell eval fact fact-cons fact-delete fact-set
17:10:23 <lambdabot> fact-snoc fact-update foldoc fortune fptools gazetteer get-shapr ghc
17:10:25 <lambdabot> [8 @more lines]
17:10:29 <newsham> @hoogle pprint
17:10:30 <lambdabot> Language.Haskell.TH.Ppr.pprint :: Ppr a => a -> String
17:10:30 <lambdabot> Language.Haskell.TH.pprint :: Ppr a => a -> String
17:10:51 <jethr0> but using IO only makes it more complicated
17:11:03 <jethr0> i'd stick to pprint and show
17:11:38 <NoobLuck> bye people
17:12:47 <jethr0> ok, i gotta go to bed. i hope you'll solve this soon and without too much of a hassle
17:12:59 <newsham> ['i', 'n', 's', 't', 'a', 'n', 'c', 'e',  ...
17:13:05 <newsham> ugh.. partially worked, but hard to read
17:13:20 <jethr0> hehe, yes, that's what show does.
17:13:37 <newsham> why is it showing a list of chars instead of in "..." format?
17:14:06 <jethr0> hmm, still weird... well, they are the same in haskell so sometimes strings get "exploded"
17:14:29 <jethr0> no idea why. but for strictly debug output this is tolerable, i guess
17:14:37 <jethr0> ok, good nite everyone
17:15:30 <jethr0> newsham: is that with concatenation?
17:15:44 <jethr0> > concat ["hello", "world"]
17:15:45 <lambdabot> "helloworld"
17:15:50 <jethr0> > show $ concat ["hello", "world"]
17:15:52 <lambdabot> "\"helloworld\""
17:16:10 <jethr0> hmm, well it's past 2am already. gotta go, bye
18:11:37 <ncalexan> @hoogle runReaderT
18:11:38 <lambdabot> Control.Monad.Reader.runReaderT :: ReaderT r m a -> r -> m a
18:40:04 <dons> moin
18:40:26 <Korollary> good @localtime
18:41:12 <dons> ?
18:41:46 <Korollary> time-of-day agnostic greeting
18:42:22 <dons> ah, :)
18:43:08 <sproingie> hm.  how do i hide an existing data constructor?
18:43:25 <dons> don't export it?
18:43:30 <sproingie> trying to do a towers of hanoi, and i'm getting errors on this line:
18:43:35 <sproingie> data Peg = Left | Middle | Right  deriving Show
18:44:00 <sproingie> since it conflicts with Main.Left and Data.Either.Left
18:44:05 <sproingie> same with Right
18:44:42 <Cale> sproingie: import Prelude hiding (Left, Right)
18:44:56 <Korollary> or import the conflicting ones qualified
18:45:10 <dons> hmm. shouldn't do. you can shadow such things.
18:45:14 <dons> or do you use them in the same module?
18:45:56 <sproingie> nope, i don't use them both.  i forgot about hiding
18:45:59 <sproingie> Cale: thanks :)
18:46:38 <Cale> you could also just use other names of course :)
18:47:01 <sproingie> this is just a trivial example
18:47:20 <sproingie> an exercise, basically
18:50:41 <SamB> oh cool, I didn't actually have to restart X...
18:51:06 <SamB> When I told WindowMaker to exit it segfaulted and asked if I wanted to restart it ;-)
18:51:39 <dons> maybe you should use ion ;)
18:52:37 <Cale> I don't know how people get by without overlapping windows.
18:53:29 <SamB> the trouble is I wasn't getting proper input focus
18:53:31 <Cale> I suppose it seems feasible if you have enough workspaces
18:55:23 <dons> without overlapping windows?
18:55:36 <dons> you mean, two windows on the screen whose contents are visible concurrently?
18:55:44 <dons> or really overlapping?
18:56:09 <dons> int-e, I note your fromIntegral patch to harmonic! very nice :) thanks
18:56:21 <dons> @seen int-e
18:56:22 <lambdabot> I saw int-e leaving #haskell-overflow and #haskell 7 hours, 29 minutes
18:56:22 <lambdabot> and 25 seconds ago.
18:56:24 <dons> ah
18:57:36 <dons> hmm. this regex-dna benchmark is really hard. i think we need a binding to perl's regex code
18:57:46 <Korollary> heheh
18:57:58 <dons> no, I'm serious. why not?
18:58:01 <Korollary> ?
18:58:17 <dons> just using regex(3) isn't good enough
18:58:22 <Korollary> oh
18:58:35 <dons> we need a higher level (optimised) interface for substitutions, for one
18:58:36 <Korollary> I didnt know that was how it was done now
18:58:54 <dons> yeah, Text.Regex is just a binding to regexec, regcomp and regfree
18:59:19 <Korollary> we need our own regex impl
18:59:23 <dons> and even replacing that with a (Ptr Word8) binding is still an order of magnitude worse than perl (though memory is good)
19:00:21 <dons> the new entry will complete in about 100x the winning entry, instead of 1200x. but still...
19:00:33 <dons> the C entry is also about 1000x bad
19:00:37 <Korollary> wow
19:00:50 <dons> so, /me wants to get hold of some tasty regex libs and bind bind bind!
19:00:51 <Korollary> I must have never seen that benchmark
19:01:16 <dons> http://shootout.alioth.debian.org/gp4/benchmark.php?test=regexdna&lang=all
19:01:35 <dons> (note that hGetBuf busted my entry last night. i've fixed it for this night though)
19:01:46 <Korollary> this one is new
19:01:51 <dons> in fact, failing regex-dna only cost us 0.04pnts, since the current entry is so bad
19:02:20 <dons> maybe we could steal OCamls code
19:03:27 <Korollary> well, without FPS we're hosed anyway because of these huge fasta lines.
19:03:55 <dons> oh, that's not so bad.
19:04:01 <dons> have a look at our current fasta entry
19:04:07 <dons> or reverse-complemenet
19:04:21 <dons> they all eat these huge fasta-generated files quite happily into Ptr Word8 arrays
19:04:30 <dons> so I wouldn't say `hosed'
19:04:36 <dons> just `not optimal'
19:05:08 <Korollary> oh, I forgot about the Ptr stuff
19:05:09 <dons> here for example: http://shootout.alioth.debian.org/gp4/benchmark.php?test=revcomp&lang=all
19:05:17 <dons> no FPS, but it still is in the middle of the pack
19:05:26 <dons> eating, I don't know, 50M of dna?
19:05:49 <dons> 5th in terms of memory usage too, even with a boxed getLine
19:07:01 <Igloo> I'm confused; how do I work out which tests are giving C the biggest advantage over Haskell?
19:07:14 <Igloo> (in terms of default points)
19:08:15 <Korollary> I don't really care about the point system heh
19:08:37 <dons> it's hard to know, Igloo. You'd have to trace the algorithm they use
19:09:15 <dons> it's described here at the bottom of http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
19:09:47 <dons> though I suspect if we squish the space leak in knucleotide, and fix regex-dna to run a bit faster, that might be enough (for now)
19:10:09 * Igloo picks the one ghc is 12 times slower at and wimpers at the code
19:10:27 <dons> once 6.6 is out, we'll have a good packed string in base, so we steal back many lines of code, further extending our lead there
19:10:38 <dons> Igloo, which program is that?
19:10:54 <Igloo> I haven't looked in detail, but at first glance if GHC isn't doing that unboxing then it smells like a bug
19:10:57 <Igloo> http://shootout.alioth.debian.org/gp4/benchmark.php?test=revcomp&lang=ghc&id=3
19:11:20 <dons> ah. hack away :)
19:11:42 <Igloo> hack away?
19:12:00 <dons> yes, that's surprisingly poor. i should profile some more.
19:12:09 <dons> I would have thought it would be much better ranked
19:12:23 * dons fights temptation to import foreign fgets
19:12:51 <Igloo> I'm not looking at ways to improve its performance, I just don't think reverseit should need to be using unboxed primitives all over the place
19:12:54 <sproingie> wow, that looks like C in haskell.  that was accepted as idiomatic?
19:13:43 <Igloo> sproingie: By someone who doesn't know Haskell, presumably  :-)
19:14:27 <dons> sproingie, have a look in the standard libs sometime ;)
19:14:51 <Korollary> standard libs are not meant to be idiomatic heh
19:15:07 <dons> it's a war out there, and we want to win   ;)
19:15:48 <dons> considering that the ghc user's guide even mentions this as a way to squeeze performance, then I don't think it's anything to worry about.
19:16:11 <dons> the unboxed kind is in the language for a reason..
19:16:19 <Korollary> it doesn't matter if library code looks like ass. However, if app developers need to resort to this, then it is a minus.
19:16:57 <dons> you usually wouldn't need to do this
19:17:09 <Igloo> dons: My worry is not that it's being used per say, but that it makes a difference in this case
19:17:45 <Igloo> It looks like the iodiomatic Haskell should be optimised to that anyway
19:17:52 <Korollary> dons: Well, didn't DavidR write packedstrings because of his need?
19:18:03 <dons> packed strings aren't the same as unboxed foo
19:18:39 <Korollary> unboxed foo I am more ok with, even though ghc should unbox them all ideally
19:18:48 <Korollary> Ptr stuff is uglier
19:21:27 <lispy> have you guys ever used -fno-cse and impacted memory usage?
19:26:47 <dons> ah well, remember what SPJ said: Haskell's the world's greatest imperative language
19:26:58 <dons> even if many in the community like to pretend that's not the case ;)
19:27:52 <dons> it's funny how the SML and OCaml guys are happy to say their languages combine the elegance of FP with the efficiency of imperative languages, but we don't like to mention this. it's like its a dirty secret or something.
19:28:04 <Korollary> well, we're not that efficient, tho
19:28:19 <dons> sometimes we are
19:28:29 <Korollary> it doesnt mean we can't be, either.
19:28:39 <SamB> perhaps because we don't have the efficiency, but rather a greater elegance in many imperative matters?
19:28:52 <dons> yeah, I love foldM, for example
19:29:43 <SamB> its surprising how cool referential transparency is in imperative programs ;-)
19:29:54 <Korollary> for instance the mandelbrot entry translated from sml. It was purely cpu oriented, but it was quite a bit slower. It didnt make sense.
19:30:26 <dons> yeah, I don't know what happened there. maybe we should look at the Core. it's probably just some dumb issue
19:31:21 <newsham> any TH wizzes?
19:32:01 <Lemmih> newsham: You can't avoid messing with the AST.
19:32:22 <dons> I'm just happy after putting up with so much crap from the other FP communities about Haskell having fundamental issues with memory and speed, we can show that it was all just trash talk :)
19:33:44 <dons> musasabi, I've fixed regex-dna's hGetBuf issue. The corrected version is on the wiki. Can you submit it when you get time?
19:33:50 <Korollary> if a company put 10% of the effort than went into JVM, ghc could be at a totally different place.
19:34:22 <dons> Korollary, good point. how many billion dollars has been wasted on that junk?
19:34:31 <dons> and mean while we hack for free
19:34:48 <newsham> dons: the mandelbrot thing might be fast, but it seems to obscure the meanning of what it performs
19:35:04 <newsham> at least, I dont look at it and say "ahh!  a mandelbrot set generator!"
19:35:24 <dons> unfortunately the numbers don't include elegance. it's a compromise
19:35:32 <dons> I think pidigits does very well at this though
19:36:24 <newsham> one metric that interests me a lot is how long to write it (or perhaps how long to read it and understand it)
19:36:31 <dons> we can lose badly, and have bad press for another 5 years, or we can show what ghc can do and just shrug and accept that it's not a contest for elegance
19:36:32 <newsham> thats one of the draws of using a high level language.
19:37:07 <Korollary> yeah, I understand the PR effect
19:37:14 <newsham> (thats why I write more python today than I write C)
19:37:55 <dons> already we've had people on this channel surprised, counteracting several years of bad press from OCaml.
19:38:06 <Korollary> newsham: that's a better metric, but it relies on humans, so it's a social study as well.
19:38:22 <newsham> computer problems are social science problems! :)
19:38:46 <newsham> http://research.microsoft.com/users/jpincus/cs%20SocSci.html
19:38:52 <dons> there's a reason the SML and OCaml programs aren't elegant either... C corrupts us all
19:39:31 <Korollary> newsham: yeah, but then it would have to be a statistical study, too (ok it took you 30 secs to understand it, it took me 35, etc. etc.)
19:39:50 <newsham> yup.  and? :)
19:40:13 <Korollary> and we're not representative of the general population, etc.
19:40:38 <Korollary> it's as BS as the lines-of-code metric, which is at least not subjective.
19:42:40 <newsham> four out of five mathemeticians agree!
19:44:05 <Korollary> is the 5th one Goedel?
19:45:10 <newsham> some poker junky, didnt catch his name.
19:45:21 <Korollary> von Neumann
19:49:47 <newsham> gotta go.
20:18:06 <lispy> i started reading the pragmatic programmer
20:18:15 <lispy> it's got some good stuff
20:19:08 <gzl> yeah, it's not bad
20:19:17 <gzl> they synthesize the stuff well
20:23:02 <SamB> hmm, Conjure is definately having some issues with some kind of buffer or something like that...
20:23:26 <SamB> I'm seeing a good deal of an HTML page prepended to its tracing messages...
20:24:06 <SamB> well, either that or it is producing very odd terminal control sequences
20:30:58 <dons> @yow
20:30:59 <lambdabot> I smell like a wet reducing clinic on Columbus Day!
20:36:36 <dons> @google 1 + 2
20:36:38 <lambdabot> 1 + 2 = 3
20:36:50 <Korollary> @google fib 18
20:36:53 <lambdabot> http://www.eggcartons.com/cat30_1.htm
20:37:16 <dons> not quite that smart
20:37:19 <ncalexan> @keal
20:37:20 <lambdabot> nsa prevent me from returning to math on efnet
20:37:24 <ncalexan> @keal
20:37:24 <lambdabot> with KealDigit quantum crackproof encryption possible
20:37:31 <ncalexan> ah...
20:37:36 <dons> it's all gold, i tell you! :)
20:37:44 <Cale> @keal
20:37:45 <lambdabot> i just got banned from math because i not have good ability to convey
20:37:45 <lambdabot> thoughts
20:38:12 <dons> morning Cale
20:38:21 <Cale> morning dons
20:38:51 <joelk> Heh, I tried @google 1+2 a few minutes ago in a private chat and it wasn't working yet. :-)
20:39:00 <dons> just applied it
20:39:08 <joelk> cool
20:39:24 <dons> finally got the shootout itch off, and needed to do something else ;)
20:39:38 <dons> maybe I'll get some sleep now
20:39:43 <Cale> @google 18 factorial
20:39:44 <lambdabot> 18 factorial = 6.40237371 x 10^15
20:39:49 <dons> ah!
20:39:54 <dons> so much better than running on my box.
20:39:59 <dons> let google's cpus take the heat
20:40:00 <Pseudonym> @google c in furlongs per forgnight
20:40:01 <joelk> Yeah, I finally got back to work... <shifts eyes slyly>
20:40:02 <lambdabot> No Result Found.
20:40:08 <Pseudonym> @google the speed of light in furlongs per forgnight
20:40:10 <lambdabot> No Result Found.
20:40:19 <Korollary> misspelled fortnight anyways
20:40:22 <Pseudonym> @google the speed of light in furlongs per fortnight
20:40:23 <Pseudonym> Right.
20:40:23 <lambdabot> the speed of light = 1.8026175 x 10^12 furlongs per fortnight
20:40:26 <Pseudonym> There we are.
20:40:28 <dons> oh very nice
20:40:29 <joelk> ha!
20:40:39 <Pseudonym> @google the speed of light in fathoms per millicentury
20:40:40 <lambdabot> No Result Found.
20:40:44 <Pseudonym> Damn.
20:40:46 <Cale> @google one half factorial
20:40:47 <lambdabot> http://www.staff.amu.edu.pl/~maciejr/computations/hf_sets_WWW/psi1.
20:40:47 <lambdabot> html
20:41:07 <Cale> @google (1/2) factorial
20:41:08 <lambdabot> (1 / 2) factorial = 0.886226925
20:41:18 <Cale> hmm, real google has no problem with the first one
20:41:42 <joelk> @google one half factorial + 0
20:41:44 <lambdabot> http://www.staff.amu.edu.pl/~maciejr/computations/hf_sets_WWW/psi1.
20:41:44 <lambdabot> html
20:41:52 <Korollary> @google The best irc channel bot ever
20:41:54 <joelk> damn, that works for constants...
20:41:54 <lambdabot> http://www.mircscripts.com/scripts/5.9/
20:42:14 <Pseudonym> @google 0.5 factorial
20:42:16 <lambdabot> 0.5 factorial = 0.886226925
20:42:36 <dons> @google the speed of light in cubits per week
20:42:37 <lambdabot> the speed of light = 3.9657585 x 10^14 cubits per week
20:42:37 <Cale> @google i factorial
20:42:39 <lambdabot> i factorial = 0.498015668 - 0.154949828 i
20:42:43 <dons> serious fun 
20:42:50 <Pseudonym> @google i sqrt
20:42:51 <lambdabot> http://www.mathworks.com/access/helpdesk/help/techdoc/ref/sqrt.html
20:42:58 <Pseudonym> @google sqrt 2
20:42:59 <Cale> @google square root of i
20:43:00 <lambdabot> sqrt(2) = 1.41421356
20:43:00 <lambdabot> square root(i) = 0.707106781 + 0.707106781 i
20:43:03 <Korollary> @google AAPL
20:43:05 <lambdabot> http://finance.yahoo.com/q?s=AAPL&d=t
20:43:14 <dons> @google the speed of light in shaftments per hour
20:43:17 <lambdabot> http://www.factbites.com/topics/Foot-(unit-of-length)
20:43:20 <dons> ah well
20:44:03 <Cale> @google the speed of light in furlongs per fortnight
20:44:05 <lambdabot> the speed of light = 1.8026175 x 10^12 furlongs per fortnight
20:44:15 <joelk> my favorite is still:
20:44:16 <ncalexan> LOL!
20:44:25 <joelk> @google mass of uranus in carats
20:44:26 <lambdabot> mass of Uranus = 4.34245 x 10^29 carats
20:45:16 <Korollary> @google fibonacci 18
20:45:18 <lambdabot> http://www.mcs.surrey.ac.uk/Personal/R.Knott/Fibonacci/fibpi.html
20:45:22 <Korollary> bah
20:45:29 <Cale> @google mass of sun in drams
20:45:30 <lambdabot> mass of the sun = 1.12251341 x 10^33 drams
20:45:47 <dons> @google area of solar system in sheds
20:45:49 <Pseudonym> @google speed of light in bushels per attoparsec per hand per jiffy
20:45:49 <lambdabot> http://origins.jpl.nasa.gov/universe/ra2.html
20:45:51 <lambdabot> http://www.ms.washington.edu/stat390b/spring01/matlab/gutenberg/data/
20:45:51 <lambdabot> wordlist1
20:46:02 <Pseudonym> @google speed of light in bushels per acre per jiffy
20:46:03 <lambdabot> http://www.answers.com/topic/conversion-of-units
20:46:44 <Pseudonym> @google speed of light in bushels per acre per warhol
20:46:47 <lambdabot> http://brainyplanet.com/index.php/DitloidProblems
20:46:48 <Korollary> hmm, what if I ask for the wrong units?
20:46:50 <Pseudonym> Hmmm.
20:46:56 <Korollary> @google speed of light in seconds per meter
20:46:57 <Pseudonym> Don't think it likes jiffies or warhols.
20:46:58 <lambdabot> http://theory.uwinnipeg.ca/mod_tech/node112.html
20:47:40 <Pseudonym> @google speed of light in bushels per acre per microweek
20:47:41 <lispy> i want to write a google wack plugin....it would accept only two words, it would cross check them against dict and then it would tell you how many hits it gets
20:47:42 <lambdabot> No Result Found.
20:47:58 <lispy> but...i have more ideas for projects then time or know how :)
20:48:00 <Pseudonym> @google speed of light in parsecs per microweek
20:48:02 <lambdabot> No Result Found.
20:48:12 <lispy> nice unit
20:51:29 <JohnMeacham> Speck: that is indeed the plan. but it is on the backburner for a while.
20:51:47 <Speck> JohnMeacham: cool, I'd like to learn more about it :-)
20:52:52 <lispy> JohnMeacham: did you write darcs trackdown?
20:53:38 <JohnMeacham> lispy: I will as soon as I have another heisenbug of moderate magnitude. if you want to speed it along you could construct a clever set of patches for jhc and submit them such that they will introduce such a bug.
20:54:15 <lispy> JohnMeacham: er...darcs has a trackdown that i used, i wondered if youhad written it :)
20:54:37 <JohnMeacham> lispy: oh no, but I had posted on the list about my plans to re-implement it.
20:55:02 <JohnMeacham> lispy: such that it tries all subsets of patches rather than just a straight linear backtrace.
20:55:16 <lispy> ah, right
20:55:41 <lispy> i used it recenetly for the first time
20:55:55 <lispy> it's very handy, but the interface could be simpler
20:56:38 <JohnMeacham> lispy: the main problem with it currently is that often it will unpull a patch you need for your program to work before it finds the bug so it just fails back to the beginning. like you might have a recent patch to fix your build system, once that is gone, nothing will work.
20:57:36 <lispy> right, i noticed that too
20:58:05 <lispy> i was also thinking that given the current linear path it could use a binary search
20:58:45 <Pseudonym> Killing yourself is a one-liner in Perl.
20:59:49 <lispy> JohnMeacham: oh, i just remembered.  Do you have any weirdness with your email server?  about 60% of the emails you send trigger my spam filter and i can't figure out why
21:00:11 <lispy> JohnMeacham: these are emails you send to haskell-cafe and such
21:04:13 <JohnMeacham> lispy: I don't think so. I just use the pacbell outgoing server. perhaps mails from DSL connections are dropped?
21:05:59 <lispy> JohnMeacham: if the server has a dynamic ip or the reverse dns lookup gives a slightly questionable response that could cause it
21:06:19 <lispy> JohnMeacham: i get your messages, but they go into my spam folder
21:06:43 <lispy> but not always either...some of them go into my haskell-cafe folder
21:06:52 <JohnMeacham> lispy: no, I route them all through the pacbell server. 
21:07:09 <JohnMeacham> lispy: and they are all sent from my home machine. no idea what could be wrong.
21:08:18 <lispy> X-Spam-Status: No, score=3.5 required=5.0 tests=FORGED_RCVD_HELO,
21:08:19 <lispy> RCVD_IN_BL_SPAMCOP_NET,RCVD_IN_NJABL_DUL autolearn=disabled 
21:08:19 <lispy> version=3.0.0
21:08:21 <lispy> X-Spam-Level: ***
21:08:47 <lispy> i have my spam filter set to filter anything with at least 3 stars
21:08:58 <triplah> could it be a client problem?
21:09:26 <lispy> apparently pacbell is in a spamcop block
21:09:53 <lispy> so maybe they float on and off of spamcop lists
21:10:22 <lispy> triplah: i don't think so, i get a lot of emails without much problem
21:10:34 <triplah> lispy: nah i meant for JohnMeacham 
21:10:41 <lispy> ah
21:10:57 <lispy> well, the FORGED_RCVD_HELO could indicate some misconfiguration in the chain
21:11:07 <JohnMeacham> FORGED_RCVD_HELO?
21:11:55 <triplah> yeah thats what made me think he might be using some exotic mail client :P
21:12:16 <JohnMeacham> just mutt.
21:12:20 <JohnMeacham> and postfix.
21:13:27 <JohnMeacham> ah http://linuxfromscratch.org/pipermail/lfs-chat/2005-July/026693.html
21:14:58 <JohnMeacham> I will fix it later. I am about to head out.
21:15:12 <lispy> JohnMeacham: okay, i just wanted to pass on that info :)
21:20:29 <dons> Lemmih, very tricky!
21:20:31 <dons> > error "yes" :: ()
21:20:32 <lambdabot> Exception: yes
21:20:33 <dons> > error("(:"++error(reverse"):"))::()
21:20:35 <lambdabot> :)
21:22:00 <dons> I don't think I could be bothered handling this error . error case
21:40:12 <musasabi> dons: bugfix committed to regexdna.
21:41:56 <dons> cheers.
21:42:44 <dons> ah, I see the shorter nsieve-bits is marginally slower. i'll have a look.
21:51:47 <musasabi> ok
21:52:29 <dons> oh, unsafeRead/Write doubles the speed. silly me
21:56:51 <dons> musasabi, I've updated nsieve-bits on the wiki: http://www.haskell.org/hawiki/NsievebitsEntry
21:56:59 <dons> it's around 30% faster
21:58:09 <dons> that should be more competitive, I hope.
22:03:08 <dons> bah, we should have done the same thing for `nsieve' too.
22:04:05 <dons> ah, we did, I just didn't update my repo
22:05:53 <dons> would you like to commit the new nsieve-bits?
22:07:34 <dons> argh, chameneos uses {- -} comments. boo
22:19:21 <dons> musasabi, I have now a new version of chameneos too on the wiki. Could you commit chameneos and nsieve-bits? (I promise to stop bugging you once we beat C ;)
22:20:22 * lispy uses an emacs macro and recalls why emacs is so handy
22:22:00 <lispy> dons: when you get done, if you could take some time to write a really details "book" on how to optimize for speed and space (using shootout examples) that would be awesome
22:22:38 <dons> hmm. that's a good idea.
22:24:52 <lispy> dons: might be appropriate for TMR
22:24:56 <lispy> dons: i know i'd read it
22:25:09 <dons> hmm. it would be worthwhile. i'll put it on my list
22:25:22 <lispy> thanks
22:25:51 <lispy> i've been profiling darcs with this library that Igloo wrote
22:26:19 <lispy> it's handy for finding out how much memory is actually being used by malloc and subtracts out mmap
22:28:04 <lispy> looks like darcs has a space leak when it reads patches
22:28:53 <dons> ah good work!
22:28:55 <lispy> it was reading a gzipped patch which is only 360mb uncompressed (only about 1.7mb compressed) and it malloc'd about 600MB
22:29:15 <dons> cool. now hunt that leak!
22:29:16 <lispy> not sure if being gzipped played a role
22:29:37 <lispy> i hope to :)
22:29:46 <lispy> it's better than writing fortran which is what i did at work this week :)
22:29:53 <Korollary> ow
22:30:17 <lispy> i was trying to make fortran talk to our simulation software via COM
22:30:23 <lispy> talk about painful :)
22:30:57 <lispy> it's not even fully documented in the compiler's reference material and isn't official supported...
22:34:32 <Korollary> it's probably easier to have fortran talk to C first, then to com
22:35:11 <lispy> Korollary: yeah, if this doesn't work soon we were thinking of using pyfort to make python talk to fortran and letting python do the com
22:52:38 <musasabi> dons: ok, looking and committing now.
22:56:12 <vincenz> lambdabot: sources
22:56:21 <vincenz> @google lambdabot
22:56:23 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
23:01:23 <musasabi> dons: both committed.
23:06:32 <ibid> any finns have a recommendation as to how to translate "kind" to finnish?
23:06:37 <ibid> (in the type system sense)
23:10:33 <Lokadin> ask torvalds! :D
23:10:45 <Lokadin> as in linus torvalds
23:10:46 <ibid> why?
23:10:53 <Lokadin> cause he is a finn
23:11:00 <Lokadin> and good with computers
23:11:05 <ibid> there are several finns on this channnel
23:11:11 <Lokadin> no i dono i was just joking
23:11:13 <ibid> and linus is not a type system person
23:11:20 <ibid> yes, and it was a strange joke
23:11:20 <Lokadin> only finn i know
23:11:25 <Lokadin> i agree
23:11:27 <ibid> well, i'm another now :)
23:11:37 <Lokadin> it wasn't particularly funny
23:11:38 <Lokadin> :)
23:11:44 <ibid> agreed :)
23:12:15 <Lokadin> but penguins however are really great
23:12:28 <Lokadin> so are sloths now sloths are funny
23:12:30 <Lokadin> lol
23:13:11 <Lokadin> oi, i feel so embarrassed
23:13:15 <gour> ibid: hi, after some online research, it looks like Functional Programming Approach book could be the best as 2nd one after thompson, i.e more light reading than okasaki
23:13:24 <Lokadin> i really shouldn't talk with this little sleep
23:21:14 <vincenz> Hello
23:22:17 <vincenz> Under which part of lambdabot does the ">" fall?.
23:22:31 <lispy> iirc, @eval
23:24:27 <vincenz> hmm
23:24:35 <vincenz> it seems it just runs a separate shell
23:24:36 <vincenz> damn
23:24:53 <joelk> if you mean here is the code that looks for ">" in input look in Plugins/Base.hs
23:25:00 <joelk> s/here/where/
23:25:16 <vincenz> yeah, it just replaces it with eval however
23:25:23 <joelk> yes
23:25:25 <vincenz> just trying to look at some code to learn haskell
