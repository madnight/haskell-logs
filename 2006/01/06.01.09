00:06:51 <musasabi> What is the whole wiki situation like?
00:07:12 <musasabi> We have hawiki, trac wikis, and haskellwiki.
00:07:25 <gour> good question
00:07:56 <gour> my proposal was(is) to have cms (e.g. drupal) for the whole site
00:08:15 <gour> while trac can be used for individual projects
00:09:02 <gour> dcoutts: ping
00:12:56 <xah> amazing discovery: http://validator.w3.org/check?uri=http://www.msn.com/   MSN.com validates! I'd be hard pressed to find another major site that validates.
00:15:29 <dons> thanks for submitting the entries musasabi.
00:20:17 <dons> huh. the unboxed haskell fannkuch is only 1.1x slower than C on my box :D
00:20:35 <Korollary_> but, it's almost pure C :)
00:21:10 <Korollary_> haskell as a meta-language on top of C heh
00:21:51 <musasabi> dons: np, it is faster for me with CVS than going through the web thingy.
00:22:16 <dons> ok. you mean the shootout submission procedure?
00:22:31 <musasabi> yes.
00:22:38 <aleator> Anyone tried these with jhc? or what was it?
00:22:44 <Korollary_> xah: www.microsoft.com validates, too. Wow. Nobody else does.
00:22:58 <musasabi> dons: just tell me when you think the fannkuch is stable and I will put it in.
00:23:21 <dons> ok. i'm done for today, but i may attack it again tomorrow. to see if I can get under gcc.
00:23:27 <musasabi> aleator: most of the optimized solutions contain GHC specific things.
00:23:27 <dons> there's a couple of other things to do yet.
00:23:47 <musasabi> ok
00:23:58 <xah> Microsoft is the progress of humanity
00:24:11 <xah> fuck lying thru their teeth OpenSourcing fuckheads
00:24:31 <xah> and fuck FireFox fandom
00:24:57 <xah> i believe, when it comes to standards, IE also beats other browsers
00:25:13 <xah> never actually tried to test it though
00:25:13 <aleator> xah: would you be xah lee the usenet fame?
00:25:41 <xah> aleator: well yeah. May i kiss your hand? :)
00:26:48 <xah> but as far as ~1999 era goes, IE is the best browser in terms of every aspect, including standard conformance, memory, crashiness, speed, features.
00:27:47 <xah> i'll probably be writing an essay reporting this...
00:27:54 <xah> about how Microsoft sites validates...
00:28:00 <Korollary_> I can't wait to read it.
00:28:01 <xah> will have to do more research
00:30:23 <zamez> I've sometimes thought of writing a browser in Haskell
00:31:04 <zamez> not sure if it would be practical
00:31:37 <gour> zamez: maybe some other piece of haskell code can be written instead..
00:32:18 <zamez> you mean that you think it would be a waste of time?
00:32:53 <gour> nope, but, imho, haskell community can be improved in many other ways
00:33:38 <zamez> guess so
00:34:26 <gour> e.g. improving gui libs, writing hIDE, improving compilers...
00:35:00 <gour> and preparing some roadmap for the language itself, haskell-2.x
02:25:11 <dcoutts> gour, pong
02:25:11 <mardy> Hi all. Any wx hackers out there? 
02:25:31 * dcoutts is a Gtk2Hs hacker
02:25:44 <araujo> Good morning.
02:25:48 <dcoutts> hia araujo 
02:25:56 <araujo> Hello dcoutts 
02:25:58 <araujo> :-)
02:26:26 <mardy> We are having problems with imageGetPixelArray.  "No handler found for this image type" on a .bmp ?
02:31:34 <gour> dcoutts: i'm thinking about upgrading wp & even gallery those days...
02:32:13 <gour> dcoutts: since mysql is one of the issues for spam-plugin, what do you think about http://akismet.com/faq/ solution?
02:36:27 <dcoutts> gour, so akismet is not open-source but free for non-comercial use right?
02:36:47 <dcoutts> gour, as for upgrading wp, that's fine with me
02:37:09 <gour> dcoutts:yep, free for non-commercial
02:37:30 <gour> dcoutts: and it eliminates need for spam-karma
02:37:41 <dcoutts> right
02:38:04 <gour> it frees haskel.org server a bit :-)
02:38:05 <dcoutts> I see that it's included in wp 2.0
02:38:21 <dcoutts> oh you mean it offloads the checking to another server?
02:38:37 <gour> we only need to open account on wordpress.com to get api key
02:39:02 <gour> yes, see faq
02:39:24 <dcoutts> ok, fine with me
02:40:22 <gour> ok, today i won't make it, but in the next few days...what about gallery2?
02:41:35 <gour> (it could be that in march i'll go for a few months out of croatia and won't be able to to web-stuff)
02:42:26 <gour> Soliah_, while i'm still here...
02:42:59 <gour> Soliah_: excuse me. i wanted just to write 'so', but my irc client is 'too' smart :-(
02:44:46 <dcoutts> gour, s'ok there's no deadline to upgrade :-)
02:45:47 <dcoutts> gour, feel free to take your time
02:46:36 <gour> dcoutts: i'll use 'gtk2hs' as username for gettin' akismet key?
02:46:43 <dcoutts> gour, ok
02:47:25 <gour> dcoutts: what about email? (see http://wordpress.com/signup/)
02:48:11 <dcoutts> hmm, you can use mine if you like
02:48:14 <dcoutts> or yours
02:49:11 <gour> dcoutts: maybe yours is better, you have to work on your thesis, so no time to escape far :-)
02:49:30 <dcoutts> heh :-)
02:49:50 <gour> actually, then you can complete the signup and email me the key ;)
02:51:05 <gour> dcoutts: is everything ok with darcs repo?
02:51:20 <dcoutts> gour, seems so at the moment
02:51:31 <gour> great
02:51:34 <dcoutts> gour, we should take down the old darcs mirror, since it doesn't work
02:51:53 <gour> is it still on?
02:52:30 <dcoutts> well it's still available
02:52:49 <gour> ok, i can do 'rm -rf' :-)
02:52:52 <dcoutts> perhaps we should setup a redirect
02:53:33 <gour> i prefer to put, ie. replace note on web site
03:01:40 <dcoutts> gour, sure, we'll update the link on the website, but for people who still have links to the old repo...
03:01:54 * dcoutts updates the links on the gtk2hs website
03:02:43 <gour> dcoutts: how to setup redirect?
03:03:22 <dcoutts> gour, well we can do an http redirect or a html redirect
03:03:32 <dcoutts> gour, which did we do for the sf.net page?
03:04:10 <gour> dcoutts: hmm, i believe it was html
03:04:11 <dcoutts> gour, if the web server reads the .ht[thingy] files then it's possible to do full http redirects for a whole subtree
03:05:21 <dcoutts> gour, the sf.net index page is a phph page that sends an http header:
03:05:25 <dcoutts> <?php header("Location: http://haskell.org/gtk2hs/"); exit; ?>
03:05:45 <dcoutts> so it's an http-redirect rather than a html redirect
03:05:56 <gour> ok
03:05:59 <dcoutts> but it doesn't do the full subtree redirect
03:06:19 <gour> i never played with such stuff
03:06:42 <gour> but mirror repo can be rm-ed?
03:08:13 <gour> dcoutts: if the people pull from re-direct, what will end up in their _darcs/../repos ?
03:09:02 <dcoutts> the new repo I hope
03:09:13 <dcoutts> so the next pull will come from the right place!
03:09:18 * dcoutts hopes
03:09:32 <dcoutts> but it'd need the full subtree redirect
03:09:33 * gour too
03:10:13 <gour> it is additional pain to setup :-(
03:21:06 <dcoutts> gour, can you make the old gtk2hs darcs mirror group writable please
03:21:17 <dcoutts> I'm trying to setup a redirect in a .htacess file
03:21:32 <dcoutts> but I can't create the .htacess since the dir is now writable
03:21:37 <dcoutts> now/not
03:25:16 <gour> is it ok now?
03:26:35 <gour> dcouuts: is ok?
03:26:38 <dcoutts> yep
03:26:40 <dcoutts> done
03:27:02 <gour> thanks
03:34:35 <dcoutts> gour, actually the redirect doesn't work well with darcs
03:34:51 <dcoutts> gour, so I just set the motd to a message that tells people about the new address
03:35:02 <dcoutts> so when people pull next they'll see the message
03:36:10 <gour> dcoutts: i was thinking about the same (motd) but didn't dare to suggest
03:36:17 <dcoutts> :-)
03:36:36 <gour> dcoutts: however, you know, "great minds think ..."
03:36:56 <dcoutts> "and fools seldom differ" :-)
03:37:02 <gour> :-)
03:42:01 <gour> dcoutts: we should also think about moving mailing lists to haskell.org..
03:42:10 <dcoutts> yeah
03:43:30 <gour> if can create them on haskell.org & create archives, i can try to play with migration of archives 
03:43:43 <gour> s/if /if you/
03:43:56 <dcoutts> ok
04:02:15 <frevidar> does anyone know whether wxhaskell allows you to use all the wxwidgets?
04:02:22 <frevidar> things like wxmediactrl?
04:02:43 <frevidar> and what version of wxwidgets its based on?
04:22:22 <Cale> frevidar: the best way to tell if it supports what you want is to just look in the documentation. It's not based on any particular version of wxWidgets, in that you compile it against whichever is available on your system. I'm sure there's an earliest version it works with, but I'm not sure off-hand what that is.
04:26:39 <dcoutts> frevidar, it works with at least wx 2.4 and 2.6
04:27:11 <dcoutts> at least wxGTK that is, dunno about other platforms
04:36:56 <dcoutts> xerox, ping
04:37:08 <dcoutts> xerox, Gtk2Hs is now converted to darcs :-)
04:37:31 <dcoutts> darcs get --partial http://darcs.haskell.org/gtk2hs/
04:38:28 <sylvan> wikiefied: http://haskell.org/haskellwiki/WhyHaskell
04:38:28 <sylvan> Make better please!
04:40:55 <aleator> sylvan: pretty many things tend to spend lot of time sorting things.. (1.9)
04:56:33 <sylvan> aleator, well not in comparison to how many apps that don't spend a lot of time sorting things =) Even so, if you think something's wrong with it, change it. I haven't touched that article for years, so there's probably plenty of things that could be better or needs to be updated
04:58:01 <JKnecht> did I understand correctly there's supposed to be a new MediaWiki based wiki? if so where?
05:01:31 <gour> JKnecht:  http://haskell.org/haskellwiki/Haskell
05:08:59 <JKnecht> gour: OK, just confused me that it was same as the domain front page, which I presumed wasn't MediaWiki (i.e. the php package) based.
05:10:57 <dcoutts> @seen JaffaCake
05:10:58 <lambdabot> I saw JaffaCake leaving #haskell 3 days, 10 hours, 46 minutes and 36
05:10:58 <lambdabot> seconds ago.
06:01:20 <dcoutts> Pupeno, http://haskell.org/gtk2hs/archives/2006/01/09/svg-cairo-goodness/
06:06:57 <dcoutts> xerox, check out the pics ^^^ :-)
06:08:28 <xerox> Hi dcoutts, I just came back home, woo!
06:09:03 <dcoutts> xerox, so yeah, I've got it working. I still need to test all the variants, String,File,Handle etc
06:09:18 <dcoutts> 30 lines of code for a scaling svg viewer :-)
06:09:36 <xerox> @karma+ dcoutts :-D
06:09:36 <lambdabot> dcoutts's karma raised to 7.
06:09:52 <dcoutts> xerox, I also added some other constructors for svg that use ForeignPtrs rather that with* style block scoped ones
06:09:54 <xerox> I got the certificate and the tshirt!
06:09:59 <dcoutts> yay!
06:10:05 <xerox> heh, good one, too.
06:10:21 <dcoutts> xerox, so we get:
06:10:22 <dcoutts> withSVGFromFile :: FilePath -> (SVG -> Render a) -> Render a
06:10:30 <dcoutts> newSVGFromFile :: FilePath -> IO SVG
06:10:54 <dcoutts> so people can use it either with guaranteed managed resource use
06:10:54 <xerox> ForeignPtrs, I see.
06:10:58 <dcoutts> or GC style
06:11:13 <dcoutts> which is more flexable, but less guarantee about when resources are released
06:11:31 <dcoutts> I think actualyl we should do the same for the surfaces in the main cairo api
06:11:43 <dcoutts> to allow people to allocate long-lived GC-managed surfaces
06:11:55 <xerox> Cale was suggesting it too, I believe
06:12:07 <dcoutts> as well as temporary surfaces which are guarenteed to be released at the end of the block
06:12:16 <dcoutts> it's not too hard to do both
06:12:28 <dcoutts> we jsut change it to use a ForeignPtr
06:12:42 <dcoutts> and for the block scoped one we just don't add a finaliser
06:13:25 <dcoutts> @type newForeignPtr
06:13:27 <lambdabot> Not in scope: `newForeignPtr'
06:13:33 <dcoutts> @type Foreign.foreignPtr.newForeignPtr
06:13:35 <lambdabot> Not in scope: `Foreign.foreignPtr'
06:13:35 <lambdabot>  
06:13:35 <lambdabot> <interactive>:1:19: Not in scope: `newForeignPtr'
06:13:37 <dcoutts> @type Foreign.ForeignPtr.newForeignPtr
06:13:38 <lambdabot> forall a.
06:13:38 <lambdabot> GHC.ForeignPtr.FinalizerPtr a
06:13:38 <lambdabot> -> GHC.Ptr.Ptr a
06:13:39 <lambdabot> -> IO (GHC.ForeignPtr.ForeignPtr a)
06:13:41 <dcoutts> @type Foreign.ForeignPtr.newForeignPtr_
06:13:42 <lambdabot> forall a. GHC.Ptr.Ptr a -> IO (GHC.ForeignPtr.ForeignPtr a)
06:13:45 <dcoutts> like so
06:13:47 <xerox> I see!
06:14:06 <dcoutts> the long lived versions are convenient
06:14:14 <dcoutts> eg consider Pupeno's music app
06:14:30 <xerox> Agreed on all the line
06:14:31 <dcoutts> he could load up the svg's once at the beginning of the program
06:14:39 <xerox> Right.
06:14:46 <dcoutts> and re-use them throghout the running of the prog
06:15:02 <dcoutts> block-scoped would be a pain in that situation
06:15:31 <dcoutts> I think it'd also be good (and not too hard) to add Handle variants
06:15:31 <xerox> Absolutely
06:15:55 <xerox> Handles, hmm.  About the 4k/blocks reads?
06:15:59 <dcoutts> right
06:16:16 <dcoutts> xerox, I already do that (4k blocks) for the String version
06:16:33 <dcoutts> xerox, one issue: what to call the module? Since it might clash with a future SVG backend
06:16:49 <dcoutts> eg the PS backend is Graphics.Rendering.Cairo.PS
06:16:58 <dcoutts> so the SVG backend would be Graphics.Rendering.Cairo.SVG
06:17:11 <dcoutts> so what do I call this SVG api ?
06:17:29 <dcoutts> or perhaps they should be Graphics.Rendering.Cairo.Surface.PS
06:18:05 <dcoutts> (since we havn't actually exposed any of the backends yet we can still change their module names)
06:18:27 <dcoutts> that'd let us use Graphics.Rendering.Cairo.SVG for this module
06:19:39 <xerox> Hmmm..
06:20:43 <xerox> Yeah, I wonder how does it sounds Graphics.Rendering.SVG, even if it uses cairo for rendering
06:22:44 <dcoutts> oh I see, hmm
06:23:20 <dcoutts> hmm, well it's only a small extension onto cairo
06:23:25 <dcoutts> it's not standalone at all
06:23:42 <dcoutts> it can't be used without Graphics.Rendering.Cairo
06:23:45 <xerox> Yeah
06:31:21 <Saulzar> That's very cool
06:31:30 <xerox> :D
06:31:36 * xerox shows off the tshirt
06:32:27 <Saulzar> tshirt? gtk2hs? 
06:33:02 <xerox> The Google t-shirt!  For the Summer of Code :-)
06:33:11 <xerox> ....and the certificate of accomplishment, heh.
06:33:18 <Saulzar> Ahh - you took part in that?
06:33:29 <xerox> Yup!  An Haskell project.
06:33:38 <Saulzar> What'd you work on? :)
06:33:50 <xerox> I wrote the cairo bindings now in Gtk2Hs :-)
06:34:07 <xerox> (With the valuable help and support of dcoutts :D)
06:34:08 <Saulzar> Ohhh, cool :)
06:34:18 <xerox> Yup, it's fun :-)
06:34:21 * dcoutts grins
06:36:58 * xerox runs 'time try nice make' in the gtk2hs tree
06:37:22 <xerox> You deserve a hug for the darcsellization or whatever is called of gtk2hs :-)
06:37:45 <dcoutts> it took over 12 hours!
06:39:30 <Saulzar> There was one thing I was wondering - is it possible to get the data out of a Pixmap? (Or any other Drawable)
06:40:49 <dcoutts> yes
06:41:02 <dcoutts> you can copy it to a client side PixBuf
06:41:15 <dcoutts> Pixmap (and other drawables) are server-side
06:41:54 <dcoutts> see pixbufGetFromDrawable
06:42:01 <Saulzar> I'd gathered that from searching google, but couldn't find the connection 
06:42:10 <Saulzar> Ahh, great :)
06:43:17 <Saulzar> I've been loading images using Pixbuf and using them as textures in a GL window, and was thinking it would be great if I could get gtk to render text
06:45:58 <dcoutts> Saulzar, you can render text with pango or load standard fonts as GL fonts
06:46:11 <dcoutts> Saulzar, are you using the Gtk2Hs OpenGL support?
06:46:19 <Saulzar> Yep :)
06:46:37 <dcoutts> so you're using OpenGL to render the text then?
06:47:09 <Saulzar> Yeah, I was looking at the pango stuff. Didn't know anything about GL fonts
06:47:13 <dcoutts> glFontUsePangoFont
06:47:48 <dcoutts> or you can mix 2D pango text rendering with OpenGL on the same GL drawable
06:48:05 <dcoutts> however you need to put in barrier operations when mixing 2D & 3D operations
06:48:58 <dcoutts> using glDrawableWaitGL glDrawableWaitGDK
06:49:15 <dcoutts> glFontUsePangoFont might be easier however
06:49:24 <Saulzar> Hmm. That's cool, though I guess it is still probably best to use GL textures for rapid update?
06:49:49 <dcoutts> Saulzar, not sure what you mean exactly
06:50:30 <dcoutts> you're rendering text into a texture?
06:50:55 <dcoutts> or you're drawing text using the OpenGL text api (which uses the currently selected font)
06:50:58 <Saulzar> I don't really know, but I presume gtk rendering isn't suited for rapid update (or double buffered?)
06:51:24 <dcoutts> it'd probably be easier to use glFontUsePangoFont
06:51:35 <dcoutts> since that uses the 3D operations
06:51:45 <dcoutts> mixing 2D and 3D is a bit of a pain
06:52:03 <dcoutts> and requires flushing which probably slows things down
06:53:11 <Saulzar> How does glFontUsePangoFont do it? glBitmap?
06:53:22 <dcoutts> no it's vector
06:53:30 <Saulzar> Ahhh
06:53:38 <dcoutts> I think a GL font is a set of verticies for each glyph
06:54:05 <Saulzar> Neat
06:54:05 <dcoutts> which can be constructed from a standard font by extrusion
06:54:34 <Saulzar> I'm just using OpenGL for 2D in any case :)
06:54:44 <dcoutts> even easier then
06:54:53 * dcoutts would suggest cairo for 2D :-)
06:55:24 <Saulzar> Hehe, how would cairo handle animation?
06:55:28 <dcoutts> Saulzar, how have you found the Gtk2Hs OpenGL api generally? Any suggestions?
06:55:39 <dcoutts> Saulzar, it can do animation fine
06:56:37 <dcoutts> you'd do it in much the same way as with other systems like OpenGL or GDK
06:56:39 <Saulzar> I've actually not used anything other than withGLDrawingArea as seen in the demo, that seems nice to use.
06:57:31 <dcoutts> ok, the GLUT has a different style
06:57:44 <Saulzar> Hmm, will have to try it. (cairo that is)
06:58:06 <dcoutts> it has a notion of a current GL drawable, rather than using withGLDrawingArea to bracket GL ops
06:58:25 <dcoutts> Saulzar, yeah cairo is great and much easier to use than OpenGL
06:58:36 <dcoutts> and has better anti-aliasing
06:59:12 <Saulzar> I'm only using a few sprites, though I guess it could be more fancy if cairo was used :)
06:59:25 <dcoutts> more eye candy!
06:59:30 <dcoutts> :-)
06:59:31 <Saulzar> Though I've done a fair amount in GL, well - it's nothing fancy but it works
06:59:50 <dcoutts> definately time to try something new then :-)
07:00:14 <dcoutts> actually it should be fairly easy to understand if you've done OpenGL
07:00:20 <dcoutts> it's a simpler API
07:00:34 <dcoutts> much like PS/PDF model
07:01:24 <Saulzar> Hmm, what about overhead, would 25 fps in cairo hurt?
07:04:20 <Saulzar> Can't hurt to try it anyway, I'll give it a go :)
07:37:18 <mfgl> Hi, would someone care answering a fast, elementary question?
07:37:38 <Cale> sure
07:38:00 <mfgl> Thanks! I wanted to cast an Int to a Float.
07:38:05 <Cale> fromIntegral
07:38:13 <Cale> @type fromIntegral
07:38:15 <lambdabot> forall b a. (Num b, Integral a) => a -> b
07:38:39 <mfgl> Why not fromInt ?
07:38:44 <Cale> Turns an integral number (Int, Integer, Word8, Int16, etc.) into any kind of number.
07:38:53 <Cale> fromInt no longer exists
07:39:17 <mfgl> Ok. Thankyou very much for the help.
07:39:22 <Cale> no problem
07:39:35 <PerlJam> Cale: That's interesting.  Why does fromInt no longer exist exactly?
07:39:45 <PerlJam> (I'm assuming it did exist at some point)
07:39:46 <Cale> It's not needed
07:39:56 <PerlJam> So what?
07:39:59 <Cale> fromIntegral does that job generically
07:40:49 <PerlJam> Cale: I understand, but someone who knows they have an Int and want to turn it into a Num, also needs to remember that it's "fromIntegral" and not "fromInt" when "fromInt" would seem right
07:41:14 <sylvan> Then you'd need fromInteger, fromWord8 etc.
07:41:18 <PerlJam> I guess the programmer should keep track of the classes anyway, but still.
07:41:22 <PerlJam> sylvan: That's beside the poitn.
07:41:29 <Cale> well, you learn about fromIntegral, and then you know how to convert Int, Integer, etc. to any kind of number
07:41:44 <sylvan> I don't think it is.. it's better to have a general function than many specialised functions
07:42:13 <Cale> It's stupid that we currently have map, fmap, and liftM, which could all be the same function.
07:42:18 <sylvan> indeed
07:42:22 <PerlJam> sylvan: I agree completely on the former but I don't see those two things as mutually exclusive.
07:42:41 <sylvan> you mean fromInt _and_ fromIntegral?
07:43:03 <PerlJam> Programming is a *human* endeavor.  The language should make it easy for the human where it can.
07:43:06 <Cale> PerlJam: nobody would use the specialised version after finding out about the general one
07:43:41 <PerlJam> Cale: experienced users wouldn't use it, but there's many levels of proficiency before "experienced"
07:43:50 <sylvan> in general it's better to simplify things by making them more general.. it just makes it easier to learn the language.. 
07:43:56 <Cale> meh, we can teach new users to use fromIntegral
07:44:40 <flux__> perljam, just as likely a new user would be confused by fromInt and fromIntegral, seemingly doing the same thing, except not always?
07:44:43 <Cale> Having a single fromIntegral to learn about is easier than having fromInt, fromInteger, fromWord8, fromWord16, fromWord32, fromInt8, fromInt16, fromInt32
07:44:47 <sylvan> PerlJam, IMO if something isn't needed, it shouldn't be in the language. Features and standard functions aren't "free", they have a (big) cost in terms of increasing the language's compelxity
07:44:48 <Saulzar> Less stuff to remeber is good - programming is a human endeavour ;)
07:45:28 <sylvan> (so all features better be very useful for them to be worth sacrificing simplicity for)
07:45:35 <Cale> also, you end up with better type signatures
07:45:40 <mfgl> I was trying to avoid overloading. Is it right to define my own fromInt, specializing fromInteger to Int -> Float ?
07:45:52 <Cale> mfgl: you can, yeah
07:45:58 <Cale> mfgl: why, though?
07:46:08 <PerlJam> sylvan: so you agree, that map, fmap, and liftM should be consolidated into one function and the others removed?
07:46:09 <Saulzar> One could specialise one step further, floatToInt,  and have a matrix of 100x100 xToY  
07:46:16 <sylvan> mfgl, just 
07:46:16 <sylvan> PerlJam, yes
07:46:25 <PerlJam> interesting.
07:46:29 <Cale> PerlJam: that would be great
07:46:31 <mfgl> I come from C and I'm a little paranoid about efficiency.
07:46:37 <Cale> mfgl: don't
07:46:41 <PerlJam> today is the first time haskell has felt more like python than perl  :)
07:46:52 <sylvan> mfgl, sorry, just make sure the function which uses it has an Int type and it will be Int (not "Integral a")
07:47:00 <PerlJam> er, put # in front of haskell,python,and perl
07:47:35 <Cale> mfgl: Overloading doesn't usually cost very much.
07:47:47 <sylvan> "Integral a" means "any type which is integral", which includes int. So you can use it on Ints, you don't have to have a general function type just because you use general functions in it (but it's probably a good idea!)
07:48:30 <mfgl> Ok.
07:48:48 <sylvan> that description got convoluted, but hopefully you get what I'm trying to say =)
07:48:49 <Saulzar> The optimiser may specialise you Int if you provide a concrete Int
07:49:01 <mfgl> Yes, that's the case.
07:49:16 <PerlJam> mfgl: If you're going to use a highly dynamic language like haskell, you'd better get rid of that efficiency hangup   ;-)
07:49:25 <Saulzar> I'm very glad to get away from languages which allow me to be paranoid about overloading
07:50:00 <PerlJam> Saulzar: "allow"?  I think you mean "forse"
07:50:04 <PerlJam> er, "force"
07:50:07 <mfgl> It's hard to get rid of bad habits :-/
07:50:37 <Saulzar> I don't think any language really forces you to, but it's the culture more than anything I suspect
07:51:07 <PerlJam> mfgl: indeed. But you wouldn't be using haskell if you didn't want to learn some new habits.  Maybe some of the new habits will replace some of the old habits.
07:51:10 <PerlJam> :-)
07:52:36 <mfgl> Well, I have a lot of learning ahead :) . I'm really liking Haskell.
07:54:46 <mfgl> Thank you all for the info. I'll go and try to get my program done with fromIntegral.
08:32:45 <araujo> Hello.
08:59:31 <Monteiro> which is the difference between a finite and parcial function , anyone knows ?
09:00:20 <neologism> parcial function is a function which is not defined on every input
09:00:30 <neologism> have never heard about finite functions
09:00:49 <musasabi> Usually one speaks about total and partial functions.
09:00:49 <Monteiro> hmmm
09:01:02 <Monteiro> can u give me an example of parcial function ?
09:01:46 <edwinb> head (x:xs) = x
09:01:47 <musasabi> e.g. "fromJust (Just x) = x" is a partial function, while "maybe v f m = case m of Just x -> f x; Nothing -> v" is a total function.
09:02:42 <tic> musasabi, i.e., it doesn't map the entire domain
09:02:54 <Monteiro> tks
09:03:01 <musasabi> tic: exactly.
09:03:34 <Monteiro> now i understand
09:03:35 <Monteiro> :)
09:03:38 <Monteiro> tks 2 all
09:03:42 <tic> would you say that it's not surjective or is it injective? Don't quite remember which one's which. :)
09:03:47 <tic> s/don't quite/never
09:04:11 <tic> hrm, can't really say anything about that, actually. 
09:04:13 * tic leaves
09:15:46 * _Codex tries to implement a sphere.
09:16:43 <xerox> _Codex: how?
09:17:00 <_Codex> first attempt was Vector -> Bool function.
09:17:13 <Cale> what is the sphere for?
09:17:27 <_Codex> then next one was, (angle1, angle2) -> Vector 
09:18:25 <Cale> How about Point -> Vector -> Maybe Distance
09:19:22 <_Codex> cale: trying to make different rendering algorithms.
09:19:56 <Cale> In a raytracer, that last one I mentioned is the one you probably want (or similar to it)
09:20:43 <_Codex> cale: hmm, how does that function work ? :)
09:21:42 <Cale> that is, given a point, and a vector offset from that point, defining a ray, it determines if that ray intersects the sphere, and if so, how far along.
09:22:57 <_Codex> hmm, need to look into that soon. I currently dont have raytracing done yet.
09:28:03 <_Codex> worst problem so far is how to get all pixels filled (either by using polygons or filling some other way).
09:30:14 <Saulzar> Writing a rasterizer?
09:30:38 <_Codex> been trying few different kinds of rasterisers now.
09:31:36 <_Codex> including polygons, just plain 3d_dots, volume rendering (via integration), etc.
09:33:18 <Saulzar> Hmm, well you could do a circle with Point -> Bool  (and scan a rectangle),  I guess that's pretty slow though
09:35:38 <_Codex> saulzar: I have Point -> Bool + random picking 30000 3d points(if doesnt hit the object, then picking again), and then plotting a point
09:38:00 <Saulzar> Wow, that's going to be slow :)
09:39:22 <Cale> then just take the convex hull ;)
09:39:29 <Saulzar> If you're doing rasterization then you'll want to project the sphere to a circle first
09:39:59 <Cale> not necessarily if you want to take lighting into consideration
09:42:29 <Saulzar> Hmm, maybe you can save that in some way
09:42:54 <Saulzar> Most rasterizers don't even bother with primitives other than triangles anyway :)
09:43:02 <Monteiro> when i make f m . g n = f (m+n) how the function works ?
09:44:18 <_Codex> I try to implement all different ways of rendering complex objects I can think of.
09:44:30 <_Codex> each having different pros and cons.
09:44:33 <Saulzar> Monteiro, I don't understand the question
09:45:39 <Monteiro> Saulzar : drop m . drop n = drop ( m + n ) ,how it works the function because of that (.)
09:46:48 <edwinb> do you mean how does (.) work?
09:47:00 <Saulzar> drop m . drop n = \x -> drop m (drop n x)  
09:47:29 <Monteiro> edwinb : yes
09:47:52 <edwinb> if you have (f.g) x it's just equivalent to f (g x)
09:47:57 <_Codex> saulzar: here's example http://sivut.koti.soon.fi/terop/dots.png
09:48:11 <edwinb> so you basically get what Saulzar said in your case...
09:48:27 <Saulzar> Why it's equal to drop (m + n) is only because of the mechanics of drop
09:48:45 <Monteiro> edwinb Saulzar : tks
09:49:19 <Saulzar> _Codex, Heh, cool :)
09:49:51 <_Codex> see the problem in that approach? :)
09:49:59 <Saulzar> Yes... small issue :)
09:50:46 <_Codex> that allows nice objects though, things like boolean operations on objects.
09:51:04 <Saulzar> You can do boolean operations with raytracing fairly easily too
09:59:01 <_Codex> http://sivut.koti.soon.fi/terop/dots2.png has some more complex object/using boolean ops / cylinders etc. :)
09:59:55 <_Codex> guess I need to figure out better way to render them.
10:04:32 <orbitz> commander riker, you smooth operator
10:35:46 <chucky> hello syntaxninja. Tell me, is there a Cabal 1.1.4 coming out any time soon?
10:46:33 <icbt> does frag have sound?
10:47:10 <Cale> icbt: I don't think it did last time I tried it
10:47:46 <icbt> thanks, cale, i wonder how easy is it to incorporate reactive sound in the system
10:50:05 <SyntaxNinja> chucky: yes. my "plan" is to release 1.1.4 this week, and 1.2 next week.
10:51:16 <chucky> sweet! :)
10:52:58 <chucky> now that I've spent much of the weekend writing an unnecessarily advanced build system, I want to be able to use all of it. ;)
10:54:02 <SyntaxNinja> chucky: huh?
10:54:12 <SyntaxNinja> are you working w/ 1.1.3 or something?
10:54:25 <SyntaxNinja> has anyone checked out cabal-install?
10:54:39 <chucky> we're using 1.1.3 right now, yes
10:55:16 <SyntaxNinja> why is your build ysstem complex? what's it for?
10:55:42 <chucky> it gets a bit complex because we want to use Cabal for building both haskell stuff and for calling make to build C and C-- code
10:55:56 <chucky> it's for mine and farre's thesis project, a Ruby to C-- compiler
10:57:02 <SyntaxNinja> sweeeeeeeet
10:57:16 <SyntaxNinja> send me patches if you need more features:) ijones@debian.org
10:57:37 <SyntaxNinja> find any bugs? we have a ticket tracker now :)
10:58:01 <chucky> yeah I filed a bug the other day, but then I tried using HEAD and realized it worked there
10:58:07 <chucky> that's why I want 1.1.4
10:59:16 <SyntaxNinja> ah cool.
11:00:23 <chucky> thanks for Cabal btw. I'm not sure I would still have my sanity if I had to continue using the make-based system I created before. :)
11:02:56 <SyntaxNinja> :) you're welcome.  Make sucks for building abstractions.
11:03:06 <SyntaxNinja> (ie, programming)
11:03:43 <Heffalump> sadly, Cabal sucks for being one-language.
11:04:08 <Igloo> Fortunately, it's the right language  :-)
11:04:20 <SyntaxNinja> yes indeed.  it has a lot of tricks up its sleeve, but they're all Haskell tricks.
11:05:50 <SyntaxNinja> @voodoo-doll Heffalump
11:05:51 <lambdabot> Unknown command, try @listcommands.
11:10:52 <SyntaxNinja> I think Igloo should write an edsl for writing "make-like" programs in Haskell.
11:11:10 <chucky> I've been thinking: It would be useful to be able to combine the output of ./Setup configure --help and ./configure --help, but just executing one after the other seems a bit too ugly (it'll be too much text for anyone to read).
11:12:42 <Heffalump> SyntaxNinja: good plan.
11:13:34 <SyntaxNinja> Heffalump: you forgot an emoticon
11:14:28 <Heffalump> no, I do think Igloo should write an EDSL :-)
11:14:35 <Heffalump> whether he will or not, of course..
11:14:57 <Heffalump> naturally, I don't think the voodoo-doll is a good idea.
11:15:00 <Igloo> I'd love to. What salary were you thinking of paying me?  :-)
11:15:14 <Igloo> I'd love to. What salary were you thinking of paying me?  :-)
11:15:16 <Igloo> Ooops
11:15:22 <SyntaxNinja> Igloo: your'e very subtle
11:15:34 <Heffalump> I'll double your current salary.
11:18:55 <SyntaxNinja> I'm just holding out to sell Cabal to the highest bidder... I can't wait.
11:20:35 <Igloo> If you give me $5 I'll take it. Does that make me the highest bidder?
11:20:47 <SyntaxNinja> Igloo: so far.
11:21:06 <Heffalump> however, he could presumably bid 0 to himself.
11:21:19 <Igloo> That would just be rude
11:21:37 <SyntaxNinja> you guys are being mean to me
11:22:36 <Heffalump> it's that evil British mentality of ours.
12:15:59 <goron> Anyone with http://www.csa.com subscription? My university has tons of places with access, but not this one. 
12:18:27 <goron> Never mind. I used the search library function for the first time to find a paper and it actually finds something Google doesn't :D
12:36:09 * CosmicRay prepares the release of hdbc-odbc!
12:37:46 <Lemmih> Whee!
12:38:13 <CosmicRay> yes.
12:38:27 <CosmicRay> I am really quite DONE working with the crappy ODBC API.
12:39:53 <ulfdoz> CosmicRay: Would be nice, if it's not so crappy. This could save me lines of C. :)
12:40:03 <CosmicRay> hehe
12:40:17 <CosmicRay> well, nowadays you cuold use hdbc-odbc, which handles all the annoying C for you
12:53:53 <gour> dcoutts: ping
12:57:22 <SyntaxNinja> hi CosmicRay
13:00:28 <Heffalump> anyone around with experience of GHC porting?
13:02:20 <SyntaxNinja> sigbjorn is 2 desks away if you want me to ask him something
13:02:32 <SyntaxNinja> or I might be able to talk him into getting on IRC
13:03:07 <gour> @seen dcoutts
13:03:08 <lambdabot> dcoutts is in #haskell and #gentoo-haskell. Last spoke 3 hours and 29
13:03:08 <lambdabot> seconds ago.
13:04:28 <gour> dcoutts: hi, i just replied to your post in gtk2hs-devel, but it is not available in the archives yet. here you can see what i quoted (regarding changelog..): http://www.abridgegame.org/pipermail/darcs-users/2005-July/008056.html
13:04:42 <gour> dcoutts: see you tomorrow (i'm going to sleep)
13:05:58 <Heffalump> SyntaxNinja: I was just after any general tips, I'll try it and see what happens.
13:06:09 <Heffalump> if I get majorly stuck I might call on you, thanks :-)
13:06:28 <SyntaxNinja> Heffalump: cool.
13:08:15 <CosmicRay> hey SyntaxNinja 
13:10:45 <SyntaxNinja> CosmicRay: how's it going?
13:12:38 <CosmicRay> pretty good.  been busy with ODBC stuff.
13:12:43 <CosmicRay> finally done ;-)
13:14:24 <SyntaxNinja> sweet
13:14:43 <SyntaxNinja> cabalized, debianized, wikized, uploaded?
13:14:44 <SyntaxNinja> ;)
13:14:53 <CosmicRay> three out of those four ;-)
13:14:57 <CosmicRay> (no wikized)
13:15:07 <SyntaxNinja> sweet
13:16:55 <SyntaxNinja> maybe the definition of being done w/ a project is that the debian maintainer gets a bug report that's actually someone else's fault
13:17:25 <CosmicRay> heh
13:17:36 <CosmicRay> sorta hard when debian maintainer == upstream maintainer
13:18:02 <SyntaxNinja> no, that just means that some package you depend on (like ghc) actually has a bug that you've exposed.
13:18:10 <CosmicRay> ah
13:20:09 * SyntaxNinja shrugs
13:20:19 <SyntaxNinja> shapr is hiding
13:21:34 <Heffalump> are there any known problems with ghc and gcc 5?
13:21:36 <Heffalump> s/5/4/
13:23:38 <Heffalump> also, what's FO, and/or what debian package(s) provide an FO => {DVI,PDF} convertor?
13:26:51 <monochrom> I am adventurous and I use ghc 6.4.1 over gcc 4.0.2
13:27:00 <Heffalump> and no problems?
13:27:09 <Heffalump> have you actually built ghc itself that way?
13:27:59 <monochrom> I am not using it heavily.  I have only tried a few small Parsec parsers.  I don't build anything.
13:29:04 <Heffalump> if you don't build anything, you're not using gcc at all :-)
13:29:26 <Heffalump> hmm. This could take several years at the present rate.
13:29:27 <ihope> @index (-<)
13:29:28 <lambdabot> bzzt
13:30:02 <Heffalump> ihope: that's part of arrow notation, isn't it?
13:30:12 <monochrom> I use gcc for my little hello-world examples.
13:30:43 <ihope> heffalump: aye.
13:42:02 <ihope> @bot
13:42:03 <lambdabot> :)
13:43:32 <ihope> Some badly-written plugin made Firefox eat up all my CPU time.
13:43:51 <ihope> It's odd watching GHCi output stuff so slowly...
13:45:09 <ihope> Hmm. Didn't realize that terminating Firefox would terminate Chatzilla as well...
13:45:42 <ihope> @index LiftM
13:45:43 <lambdabot> bzzt
13:45:52 <ihope> @hoogle LiftM
13:45:53 <lambdabot> Control.Monad.liftM :: Monad m => (a1 -> r) -> m a1 -> m r
13:45:53 <lambdabot> Control.Monad.liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m
13:45:53 <lambdabot> r
13:45:53 <lambdabot> Control.Monad.liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -
13:45:53 <lambdabot> > m a3 -> m r
13:46:03 <ihope> @hoogle -<
13:46:05 <lambdabot> hoogle: unrecognized option `-<'
13:46:05 <lambdabot> HOOGLE - Haskell API Search
13:46:05 <lambdabot> (C) Neil Mitchell 2004-2005, York University, UK
13:46:05 <lambdabot>  
13:46:05 <lambdabot> Usage: hoogle [OPTION...] search
13:46:06 <lambdabot> [14 @more lines]
13:46:52 <mauke> @hoogle `yes`
13:46:53 <lambdabot> hoogle: Unexpected character when parsing: `yes`
13:46:53 <lambdabot>  
13:50:50 <ihope> So what happens when you give a value to an arrow?
13:50:55 <ihope> Or can't you?
14:00:48 <davidw> ihope, -< is just special syntax
14:00:57 <davidw> it is not an operator
14:01:13 <ihope> Ehm, wait, lemme...
14:01:53 <davidw> or hm.. that's just what I think, I don't know anything about arrows =)
14:02:04 <ihope> So it "sort of but not really" turns an arrow into a monad?
14:02:56 <davidw> I thought that -< is just part of some special arrow-notation which is just syntactic sugar, just like the do-notation
14:03:17 <davidw> I might be wrong though
14:03:24 <Heffalump> davidw: correct
14:03:28 <ihope> It is syntactic sugar, but with the appropriate definitions, I think it can be made into an infix operator,
14:03:35 <Heffalump> I doubt it
14:03:45 <Heffalump> or Ross Paterson (who designed arrow syntax) would have done so
14:03:54 <Heffalump> the translation from arrow syntax is a bit complicated
14:04:47 <ihope> Just define Arrow a => a b to be a monad... or something...
14:05:14 <ihope> @hoogle Arrow
14:05:16 <lambdabot> Control.Arrow.Arrow :: Arrow a
14:05:16 <lambdabot> Control.Arrow.ArrowZero :: Arrow a => ArrowZero a
14:05:16 <lambdabot> Control.Arrow.ArrowPlus :: ArrowZero a => ArrowPlus a
14:05:22 <Heffalump> ihope: that doesn't work either.
14:05:27 <Heffalump> Check out ArrowApply
14:05:32 <Heffalump> that's isomorphic to Monad.
14:08:33 <ihope> Whoa. I get a "not enough arguments" error when checking for kind?
14:10:42 <ihope> Ookay. Now why can't I import Control.Arrow?
14:12:35 * Igloo mutters at profiling changing space behaviour of programs I'm trying to space profile
14:14:13 <Igloo> Heffalump: Dor FO you have the choice of xmltex(broken) and fop(contrib).Modern ghc should be fine with gcc 4
14:14:59 <Heffalump> presumably it doesn't matter if I don't build the docs, anyway.
14:15:28 <Igloo> Indeed
14:15:40 <Igloo> How does the speed of armful compare to urchin, OOI?
14:15:45 <Heffalump> this line from the porting instructions: "$ touch mkDerivedConstantsHdr mkDerivedConstants.o mkGHCConstants mkGHCConstants.o"
14:15:54 <Heffalump> none of those files existed
14:15:59 <Heffalump> dog slow
14:16:08 <Heffalump> at least a factor of 10 worse, probably more
14:16:35 <Igloo> Were you touching them in ghc/includes?
14:16:41 <Heffalump> yes
14:16:43 <Heffalump> the line above worked
14:17:05 <Igloo> It's possible they're not meant to exist, then. I haven't ported it since that line appeared
14:17:07 <ihope> How about *how* do I import Control.Arrow?
14:17:21 <Heffalump> ihope: what happens when you try?
14:17:45 <ihope> module `Control.Arrow' is a package module
14:18:12 <Igloo> :m + Control.Arrow
14:18:35 <Heffalump> oh, bollocks. I've put the wrong strings in config.mk on the host. Should I kill what it's doing and fix them?
14:18:40 <ihope> Aha, it worked!
14:18:54 <Heffalump> ihope: the same way you import any other package modules, that is :-)
14:19:31 <Heffalump> (presumably the TARGET lines in config.mk on the host should look just like those on the target?)
14:20:08 <Cale> ihope: you have an import in your source file, and you're loading it with GHCi? I'd really think it should figure out what it needs to load. (at least, I've never had a problem with it)
14:21:46 <Igloo> I think you should already have run configure on the target machine and got a config.mk to copy the TARGET variables from
14:21:51 <Heffalump> yeah.
14:22:05 <Heffalump> the editing steps don't suggest copying them from that.
14:22:12 <Heffalump> But that would be the obvious thing to do, in retrospect.
14:22:23 * Igloo doesn't know off-hand how early it's important they're right
14:22:25 <Heffalump> (I was doing it while waiting for configure to finish on the target, first time round, so I didn't)
14:22:33 <Heffalump> I've killed it and cleaned, to be on the safe side.
14:23:17 <Heffalump> I haven't made any attempt to fix the actual problem yet. How much am I likely to have to redo once I get to that point?
14:24:54 <Igloo> Hmm, everything on the host ought to be fine. I'm not sure if you can just rerun ./distrib/hc-build --enable-hc-boot-unregisterised or not
14:25:20 <Igloo> which is the bit where all the time is spent, of course
14:26:02 <Igloo> Can you use distcc and possibly a cross-compiler to have urchin do the hardwork?
14:26:24 <Heffalump> in theory, but in practice therein lies more me-time, I suspect.
14:26:51 <Heffalump> I'm getting various macro redefinition warnings on the host, are they serious?
14:27:06 <Igloo> What warnings?
14:27:38 <Heffalump> /usr/lib/ghc-6.2.2/include/config.h:16: warning: "TARGET_ARCH" redefined
14:27:39 <Heffalump> In file included from HsVersions.h:17,
14:27:39 <Heffalump>                  from utils/Binary.hs:49:
14:27:47 <Heffalump> (for example, several similar ones)
14:28:38 <Igloo> Sounds suspicious to me, but I don't have a log to see if I got it in the past
14:28:40 <ihope> @hoogle Reader
14:28:41 <lambdabot> Control.Monad.Reader.Reader :: Reader r a
14:28:41 <lambdabot> Control.Monad.Reader.Reader :: r -> a -> Reader r a
14:28:41 <lambdabot> Control.Monad.Reader.ReaderT :: ReaderT r m a
14:28:57 <Heffalump> oh well.
14:31:05 <Igloo> For unregisterised arm linux vs unregisterised x86 linux it probably won't matter anyway
14:32:34 <ihope> ...So is (->) a really a monad or what?
14:33:41 <Heffalump> no, (->) a is a monad
14:33:53 <ihope> That's what I said.
14:33:59 <ihope> Where's the instance declaration?
14:34:06 <Heffalump> doh, sorry.
14:34:23 <Lemmih> (:
14:34:23 <Heffalump> I think it's around somewhere, cos people were playing games with lambdabot the other day
14:34:40 <tony2> is anyone familiar with generics?
14:36:02 <Igloo> In Control.Monad.Reader I think
14:42:52 <Trevion> Quick Q: I have a function with the type signature: (Error e, MonadError e m, MonadIO m) => <etc..> -> m a.  Within the function, I call throwError
14:43:26 <Trevion> Later, I use this function with type S a.  However, the error is not being thrown in S, but in IO (which makes it trapping it much more annoying).  Is this what's supposed to happen?
14:44:59 <Heffalump> what's S?
14:45:07 <monochrom> yeah, me too
14:45:29 <Trevion> ErrorT Err (StateT SnowdriftState IO)
14:45:54 <Trevion> Where Err is an enumeration of error types and SnowdriftState is a record of useful things.
14:46:21 <Heffalump> @type Control.Monad.Error.throwError
14:46:22 <lambdabot> forall e (m :: * -> *) a.
14:46:22 <lambdabot> (Control.Monad.Error.MonadError e m) =>
14:46:22 <lambdabot> e -> m a
14:46:39 * Heffalump thinks it through
14:47:11 <Cale> hmm, it should be using the instance of MonadError for ErrorT
14:47:16 <Cale> (Monad m, Error e) => MonadError e (ErrorT e m)
14:47:18 <Cale> that one
14:47:29 <Heffalump> yeah.
14:47:50 <Heffalump> what argument do you give to throwError?
14:48:06 <Cale> (hopefully an Err)
14:48:19 <Trevion> strMsg "heap underflow"
14:48:30 <Heffalump> are there instances that lift MonadError through every transformer?
14:48:36 <Heffalump> Trevion: and what's the type of that?
14:48:45 <Heffalump> (which was what I meant, just badly phrased)
14:48:45 <Cale> Trevion: did you write an instance of Error for Err?
14:48:46 <Trevion> @type strMsg
14:48:47 <lambdabot> Not in scope: `strMsg'
14:48:54 <Trevion> @type Control.Monad.Error.strMsg
14:48:56 <lambdabot> forall a. (Control.Monad.Error.Error a) => String -> a
14:49:03 <Trevion> Cale, yeah.
14:49:16 <Cale> okay, odd.
14:49:21 <psnl> can you have two type classes in the same type deleraction?
14:49:31 <monochrom> Is Err an instance of the Error class?  (Just to make sure.)
14:49:40 <Trevion> monochrom, yeah.
14:49:50 <Heffalump> can you verify if throwError (strMsg "...") typechecks as ErrorT Err (...) ?
14:50:01 <Heffalump> sorry, I didn't mean that
14:50:28 <Heffalump> does this expression: 'throwError (strMsg "...") :: S ()' typecheck? (no single quotes)
14:50:38 <Trevion> yup
14:51:04 <Heffalump> are you sure it's being thrown in IO?
14:51:28 <ihope> @index throwError
14:51:29 <lambdabot> Control.Monad.Error
14:51:50 <Cale> Trevion: So you apply runErrorT to your code, and then run the resulting action and you get an IO exception rather than a (Left e)?
14:52:04 <Trevion> Cale, yes.
14:52:25 <Cale> hmm, can I see the code?
14:52:27 <Heffalump> and nothing in the way is catching the error and rethrowing an IO exception?
14:53:18 <Trevion> Heffalump, if something is, I didn't write it.
14:54:05 <Trevion> And Cale, it's proprietary.  I can try to create a repro case, but I was hoping it was something obvious (to everyone but me).  ;-)
14:54:45 <Cale> Trevion: give me a minute and I'll play around with it
14:55:46 <Heffalump> GAH!
14:55:57 * Heffalump reappears from his display rotation software randomly kicking in
14:56:01 <Cale> Heffalump: ?
14:56:05 <Heffalump> it's really quite hard to move the mouse sideways.
14:56:10 <Cale> hehe
14:56:14 <Heffalump> IM when your screen is rotated by 90 degrees.
14:56:39 <Heffalump> and my X session got reset for complicated reasons, so now I have to recreate my window state.
14:57:26 <monochrom> ha
14:58:04 <Heffalump> *and* my qemu session which I don't remember the precise commandline for.
15:00:31 <ulfdoz> Does someone know a latex package for tables which is some "bastard" made from multicol and longtable package?
15:05:26 <monochrom> In Trevion's problem, the type signature (Error e, MonadError e m, MonadIO m) => ... -> m a  is puzzling me.  Why the MonadIO m constraint?
15:06:26 <Heffalump> hmm, good point.
15:06:38 <Heffalump> well, presumably it does some IO operation
15:07:21 <Trevion> monochrom, yes, it keeps its data in an IOArray
15:07:58 <monochrom> Presently I'm doing: type S a = ErrorT String (StateT Int IO) a.  Then I define: hello = throwError "hello".  I'm wondering what type signature I should specify.
15:08:10 <monochrom> Perhaps a too-general signature is a bad idea.
15:09:25 <monochrom> I'm inclined to type my hello as hello::S ().  This is guaranteed to work and avoid all troubles.  I'm thinking if you should do a similar thing too.
15:10:24 <Heffalump> is IO an instance of MonadError?
15:10:29 <Trevion> Yes, it is.
15:10:33 <Heffalump> oh, here's a hypothesis
15:10:44 <Heffalump> you call this function of yours from some other function, and you liftError it
15:10:48 <Heffalump> or some other kind of lift
15:10:52 <monochrom> If m satisfies MonadError e m, this gives one version of throwError.
15:11:22 <Heffalump> so your function is actually being called as IO a even though you think it's being called as S a
15:11:31 <Heffalump> you can verify this by using monochrom's suggestion
15:14:05 <Trevion> There's actually another instance in there that should prevent that from happening.
15:14:17 <Trevion> But I can't reproduce it, so it may be an artifact of my code.  Let me check again.
15:17:14 <Mitar> how can i make assertion in haskell/
15:17:16 <Mitar> ?
15:17:30 <Trevion> error
15:17:35 <Mitar> (some checks for conditions which should never occur)
15:17:48 <Heffalump> @type assert
15:17:50 <lambdabot> Not in scope: `assert'
15:17:57 <Heffalump> @index assert
15:17:58 <lambdabot> Control.Exception, Test.HUnit.Base, Test.HUnit
15:18:07 <Heffalump> @type Control.Exception.assert
15:18:09 <lambdabot> forall a. Bool -> a -> a
15:18:19 <Trevion> Or that.
15:18:23 <Heffalump> assert (x==y) (x+y)
15:18:23 <Trevion> @type error
15:18:25 <lambdabot> forall a. [Char] -> a
15:18:29 <Heffalump> (for example)
15:19:15 <Heffalump> igloo: you around? I seem to be missing some rts files when making the hc-file-bundle
15:19:39 <Heffalump> the instructions earlier say that we don't need the RTS yet, but it's not clear if they apply to this point too
15:19:55 <monochrom> > let {hello :: Control.Monad.StateT Int IO a; hello = undefined} in 10
15:19:57 <lambdabot>  Not in scope: type constructor or class `Control.Monad.StateT'
15:20:06 <ulfdoz> arg, aber ein Beispiel wie das gehen soll ist in der Doku auch nicht. *grml*
15:20:11 <ulfdoz> ECHAN, sorry
15:20:22 <Igloo> I think the comment you're thinking of means we don't need it to be compiled yet
15:20:23 <monochrom> Is there any lambdabot command that knows StateT?
15:20:37 <Igloo> But the RTS sources are all C, and so already in the tarball, no?
15:20:47 <Heffalump> ghc-6.4.1/ghc/rts/AutoApply_thr.hc
15:20:55 <Heffalump> is one of the three missing files, the other two have similar names
15:21:04 <monochrom> @paste
15:21:05 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
15:21:18 <monochrom> I don't like that.
15:21:22 <monochrom> @lisppaste
15:21:23 <lambdabot> Unknown command, try @listcommands.
15:21:39 <Igloo> Hmm, OK, no idea
15:21:48 <Heffalump> ok, I'll see if this works.
15:22:26 <Trevion> Heffalump, you were right about the lifting.
15:22:31 <Cale> Trevion: how are you running the monad? (there's an obvious way, but I want to make sure we're on the same page0
15:22:42 <Heffalump> Trevion: thank monochrom for the idea, then :-)
15:22:56 <Trevion> And thanks monochrom, and Cale.
15:23:00 <Cale> Trevion: oh
15:23:10 <Cale> okay, I was away for a bit there
15:23:24 <Heffalump> it does go to show that stacks of monad transformers in some way compromise type safety
15:23:38 <Heffalump> or rather, overusing type classes as they do, does
15:24:46 <monochrom> I don't think type safety is compromised.  I think tracability is.  But then you wouldn't be any better off in an OOP class hierarchy.
15:24:48 <Trevion> I wouldn't say it compromises type safety.  I think it does potentially lead to highly unexpected behavior.
15:24:57 <Trevion> (and error messages)
15:24:59 <Beelsebob> @seen shapr
15:25:00 <lambdabot> shapr is in #ScannedInAvian. Last spoke 50 minutes and 56 seconds ago.
15:25:01 <Heffalump> it depends what you mean by safety, I guess.
15:25:08 <Heffalump> I like types to help me get expected behaviour.
15:25:35 <Trevion> I had no end of fun some time ago with the fact that (a) Map.lookup :: Monad m => k -> Map k a -> m a, and (b) Data.Set is a monad.
15:25:49 <Heffalump> @type Control.Monad.Error.liftError . Control.Monad.Error.throwError
15:25:50 <lambdabot> Not in scope: `Control.Monad.Error.liftError'
15:25:58 <Heffalump> what was the actual lift operation you were using?
15:26:00 <psnl> is tabl :: (toHtml a, Ord a)=>[a]->Html legal?
15:26:05 <Trevion> Heffalump, liftIO.
15:26:18 <Heffalump> oh, no wonder it went wrong :-)
15:26:29 <Trevion> I'd just lifted a block (that included a throwError), in the hopes of not having to type liftIO quite as many times.
15:27:07 <Heffalump> but still, the very fact that it was possible to confuse IO and ErrorT makes me feel there's a fundamental weakness in the design.
15:27:17 <Heffalump> Especially given how long it took our collected minds to figure it out
15:29:21 <Trevion> You could accomplish the same kind of problem with ErrorT a (ErrorT b blah)
15:29:44 <monochrom> But I never run into that kind of problems.
15:31:50 <Heffalump> I guess monochrom's discipline of being careful with type signatures is the way to go.
15:32:26 <monochrom> My unit tests include testing my understanding of the types of my units.
15:32:30 <Heffalump> @index liftError
15:32:31 <lambdabot> bzzt
15:32:34 <Heffalump> hmph.
15:32:35 <Heffalump> @index liftErrorT
15:32:36 <lambdabot> bzzt
15:33:47 <monochrom> I think my habit and awareness of unit testing pre-dates the rise of the unit testing school of thought.  To me, it was like, "isn't everyone doing it already?"
15:38:17 <Mitar> does laziness of haskell means that it is doing auto-memoizing too (so if the function is called with same parameters it is not evaluated again)?
15:38:49 <monochrom> I have merged Parsec with IO into a state & IO monad.  The parser state furnishes the state, and the IO furnishes the IO.  http://www.vex.net/~trebla/tmp/ParsecIO.hs  Enjoy!
15:39:07 <CrewdenX> Mitar: i dunno what it will store the answer, but it probably will.
15:39:36 <monochrom> Hmm, I should consider throwing in an error monad there to thicken the pot!
15:40:07 <monochrom> Some memoizing is done.
15:40:26 <monochrom> > let x=5*2 in x+x
15:40:28 <lambdabot> 20
15:41:21 <monochrom> In there, 5*2 is evaluated when the first x is needed, then stored up, so the second time x is needed there is no re-evaluation of 5*2.
15:41:52 <monochrom> > let f x = x*x in (f 0, f 1, f 0)
15:41:54 <lambdabot> (0,1,0)
15:42:07 <palomer> hello haskell!
15:42:29 <monochrom> In there, f 0 may be evaluated twice from scratch.  The first f 0 does not cause its result to be stored.
15:42:31 <Trevion> > print [1,2,3]
15:42:32 <lambdabot> No IO allowed
15:43:01 <Mitar> and what if i want that it stores all that?
15:43:25 <mauke> write your own compiler
15:43:27 <goron> Mitar: use a datastructure to be sure, but first try without.
15:43:30 <monochrom> However, that is for a dumb compiler.  An optimizing compiler (like ghc) may perform common subexpression elimination and change my code to:
15:43:45 <monochrom> > let f x = x*x in let c = f 0 in (c, f 1, c)
15:43:47 <lambdabot> (0,1,0)
15:44:43 <monochrom> Then f 0 is evaluated once.  However, if some other part of my code needs f 0 as well, it may still not use the stored result here.
15:54:25 <Heffalump> make[1]: *** No rule to make target `System/CPUTime_hsc.c', needed by `depend'.
15:58:27 <Heffalump> oh well, time to apply some intelligence rather than just blindly following the instructions, I guess.
16:02:54 <Heffalump> anyone know what Debian package provides /usr/bin/hsc2hs?
16:05:45 <Cale> ghc6?
16:06:03 <Heffalump> IM the redirect, not the actual program
16:06:07 <Heffalump> doesn't matter, anyway
16:06:32 <Cale> apt-file could probably tell you :)
16:06:38 <Heffalump> it doesn't, I tried
16:14:28 <dons> moin
16:14:36 <dons> @uptime
16:14:37 <lambdabot> uptime: 10 days, 19 hours, 47 minutes and 29 seconds
16:17:27 <Heffalump> hmm. Should Control.Arrow be needed for GhcBootLibs ?
16:18:13 <twb> b
16:39:46 <Igloo> Why does http://urchin.earth.li/~ian/Test.hs give a stack overflow?
16:40:36 <Heffalump> the obvious answer would be the recursion in foo.
16:40:49 <Igloo> Oh, hmm, point
16:41:26 <Heffalump> do you know about Control.Arrow and GhcBootLibs btw?
16:41:37 <Igloo> No
16:42:24 <ihope> > beginsWith
16:42:26 <lambdabot>  Not in scope: `beginsWith'
16:42:37 <ncalexan> @type isPrefixOf
16:42:38 <lambdabot> Not in scope: `isPrefixOf'
16:42:49 <ncalexan> @type Data.List.isPrefixOf
16:42:51 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
16:43:55 * Heffalump discovers he put the tarball in the wrong place
16:43:56 <ihope> Can ++ be pattern-matched at all?
16:44:03 <ihope> n++k patterns? ;-)
16:44:09 <Heffalump> ihope: no, it's not a constructor :-)
16:44:22 <Heffalump> but (x:y:z:_) gives you some of what you might want
16:45:07 <ihope> Sure, but I don't want to have to type stuff like '<':'!':'r':'e':'c':'o':'r':'d':'>':xs...
16:45:20 <Heffalump> isPrefixOf isn't too bad
16:45:32 <Heffalump> if you used pattern guards you could get something quite nice
16:45:57 <Heffalump> foo xs | rest <- findPrefix "<!record>" = ...
16:46:11 <ihope> foo bar | "<!record:" `isPrefixOf` baz
16:46:24 <ihope> *`isPrefixOf`
16:46:29 <ihope> ...Bah!
16:46:33 <ihope> `isPrefixOf`
16:46:40 <ihope> ...Wait a minute...
16:47:12 <ihope> `test`
16:47:26 <Heffalump> sorry, forgot a Just in there.
16:47:37 <Heffalump> but that's the general idea
16:47:53 <ncalexan> @type Data.List.findPrefix
16:47:54 <lambdabot> Not in scope: `Data.List.findPrefix'
16:47:59 <ncalexan> @type findPrefix
16:48:00 <lambdabot> Not in scope: `findPrefix'
16:48:12 <ihope> @hoogle findPrefix
16:48:13 <lambdabot> No matches found
16:48:43 <Trevion> @type Data.List.isPrefixOf
16:48:45 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
16:49:26 <Heffalump> I made up findPrefix, you'd have to write it
16:49:27 <carp> you can pattern match with ++ using (Wadler's) views though right?
16:49:39 <Heffalump> findPrefix [] xs = Just xs
16:50:08 <Heffalump> findPrefix (y:ys) (x:xs) | x == y = findPrefix ys xs
16:50:16 <Heffalump> findPrefix _ _ = Nothing
16:50:28 <Heffalump> carp: presumably, but those aren't implemented
16:53:52 <ihope> Remove n+k patterns and replace them with k++n++l patterns! :-)
16:54:27 <carp> ihope: sounds like you might have to use Epigram for that then ;)
16:57:20 <ihope> ...?
16:58:44 <ihope> Oh, here it is. A programming language.
17:20:34 <ihope> I'd like some lambdabot I/O in the form of its own @ commands...
17:31:17 <palomer>  epigram doesn't distinguish between types and terms, right?
17:44:44 <ihope> Hmm, sounds somewhat scaryish.
17:47:31 <ihope> Then you couldn't distinguish between kinds and types, could you?
17:47:52 <ihope> What about a function that takes a type and returns something of that type?
17:48:06 <ihope> I guess that'd be (undefined ::).
17:48:32 <ihope> What type would that be? *a -> a?
17:50:57 <ihope> Type-checking at runtime would be required. Just add impure functions and you have the "perfect" language!
17:52:15 <ihope> Then... why have types at all? Why not just interpret the raw bytes as if they were of a certain type?
17:58:20 <Igloo> epigram is statically typed
18:00:52 <dons> ihope, lambdabot IO?
18:46:37 <sproingie> blah.  what's wrong with missingH's cabal file?
18:46:44 <sproingie> Setup.lhs: MissingH.cabal:82: Parse of field 'extensions' failed:
18:57:39 <twb> Oh no.
19:00:27 <twb> But I had a question, too.  let in end appears to bind sequentially instead of in parallel.  Is there a good reason for this (other than nested lets looking ugly)?
19:01:29 <twb> I suppose it doesn't make a lot of difference, because forms are referentially transparent.
19:02:39 <Igloo> sequentially?
19:03:10 <twb> > let x = 2; y = succ x in y end
19:03:11 <lambdabot>  Not in scope: `end'
19:03:17 <Cale> end?
19:03:18 <twb> > let x = 2; y = succ x in y
19:03:20 <lambdabot> 3
19:03:24 <twb> Cale: end is an SMLism.
19:03:36 <Cale> > let y = succ x; x = 2 in y
19:03:37 <lambdabot> 3
19:03:44 <twb> If let were parallel, "let x = 2; y = succ x in y" would fail because x isn't bound in "succ x".
19:03:53 <Cale> what?
19:03:54 <Cale> no
19:04:25 <twb> no?
19:04:32 <Igloo> It's neither sequential nor parallel
19:04:32 <Cale> they all come into scope at the same time
19:04:42 <Igloo> In the senses you seem to be using the words, at least
19:04:56 <Cale> > let x = 1 : y; y = 2 : x in take 10 x
19:04:58 <lambdabot> [1,2,1,2,1,2,1,2,1,2]
19:05:11 <Cale> they can be mutually recursive even
19:05:19 <twb> Oh, I see.
19:11:12 <araujo> Hello.
19:12:03 <twb`> I'm used to thinking of that let as expanding to something like (\x y -> take 10 x) (1:y) (2:x), but clearly Haskell's let is more powerful.
19:12:28 <Cale> yeah, it's not the same as that
19:12:44 <Cale> (obviously :)
19:13:01 <lispy> my favorite set is the empty set
19:13:08 <lispy> it's such a hany and essential set
19:13:18 <lispy> s/hany/handy
19:13:20 <twb`> Can Haskell's let be expanded to function definition and application?
19:13:33 <lispy> twb`: what do you mean?
19:14:01 <Cale> twb`: the top level of every module is one big 'let'
19:14:09 <lispy> twb`: the haskell98 report has a section that explains how to transform let into something more primitev
19:14:14 <Cale> in some sense :)
19:14:22 <twb`> lispy: in Lisp, "let x = y in z" is congruent to "(\x -> z) y"
19:14:35 <twb`> lispy: Ah, OK, I'll have a look.
19:14:40 <Cale> (not quite, as you can't make class/instance/data declarations and such)
19:14:45 <lispy> twb`: i think it was in chapter 3
19:14:57 <Cale> oh, in that sense
19:15:05 <Cale> no, you can't expand it like that
19:15:25 <Cale> it's primitive due to the way that it interacts with the type system
19:15:37 <Cale> It introduces polymorphic binding.
19:15:51 <Cale> > let i x = x in (i 5, i "Hello")
19:15:52 <lambdabot> (5,"Hello")
19:16:15 <Cale> > (\i -> (i 5, i "Hello")) (\x -> x)
19:16:16 <lambdabot>  add an instance declaration for (Num [Char])
19:17:31 <AtnNn> > (\(+) -> (2+3)) (*)
19:17:33 <lambdabot> 6
19:17:47 <twb`> > (\i -> i 5, i 'x') id
19:17:48 <lambdabot>  Not in scope: `i'
19:18:00 <Cale> > (\i -> (i 5, i 'x')) id
19:18:01 <twb`> > (\i -> (i 5, i 'x')) id
19:18:02 <lambdabot>  add an instance declaration for (Num Char)
19:18:02 <lambdabot>  add an instance declaration for (Num Char)
19:18:15 <Cale> > (\i -> (i (5 :: Int), i 'x')) id
19:18:17 <lambdabot> Couldn't match `Int' against `Char'
19:18:33 <twb`> Ah, that error is more intelligible.
19:19:03 <Cale> well, 5 really means (fromInteger 5)
19:19:13 <twb`> Nod.
19:19:38 <orbitz> bananaaas
19:22:49 <palomer> let polymorphism anyone?
19:22:56 <twb`> Is the report available in latex format?
19:23:40 <Cale> you want the source?
19:23:45 <twb`> Cale: yes.
19:23:48 <Cale> http://cvs.haskell.org/cgi-bin/cvsweb.cgi/haskell-report/report/
19:24:48 <lispy> twb`: i highly recommend running off a copy and getting it cheaply bound at some place like kinkos
19:24:54 <twb`> I'm impressed.  The report is basically the language specification, right?
19:25:00 <lispy> yes
19:25:09 <twb`> And you've got it version controlled.
19:25:11 <lispy> and it's much better than any other language spec i've looked at
19:25:21 <twb`> lispy: I like R5RS.
19:25:57 <lispy> i've looked at C99, lisp hyperspec, an ibm language known as Adieu and haskell
19:26:10 <twb`> hyperspec sucks ass.
19:26:16 <lispy> twb`: yeah
19:26:20 <twb`> And C99 is utterly horrid.
19:26:21 <lispy> twb`: so does C99 spec
19:26:25 <lispy> heh
19:26:28 <twb`> ISO9899, I assume you mean.
19:26:36 <SamB> Hyperspec is only bad because the CL spec is also bad...
19:26:48 <twb`> SamB: and also the format (HTML) is not nice.
19:26:49 <SamB> waaaaaaaay tooooo biiiiiig
19:27:02 <twb`> SamB: no, waaaaay to intertwingled.
19:27:12 <SamB> that too, I guess.
19:27:25 <SamB> but it couldn't be so tangled if it were smaller!
19:27:30 <twb`> Heh.
19:27:37 <lispy> IMHO the biggest problem with the hyperspec as written is that it doesn't define enough and the use "implementation defined" many times
19:27:47 <twb`> lispy: RnRS is a lot more like the haskell report.
19:27:54 <SamB> thats from the CL spec, is it not?
19:28:05 <lispy> BUT, the other  biggest problem with the language design is that they didn't take advantage of clos in the language design.
19:28:08 <twb`> SamB: hyperspec = cl spec + some notes.
19:28:15 <SamB> yes
19:28:23 <SamB> and hyperlinks...
19:28:29 <SamB> and -normative
19:28:31 <twb`> lispy: CLOS didn't exist when CL was first specified.
19:28:43 <twb`> lispy: CLOS was originally a macro package for CL.
19:28:53 <SamB> twb`: isn't it still?
19:28:56 <twb`> That is, a package of mostly macros.
19:29:00 <lispy> twb`: yeah, and as i understand it, the CL spec was a herculean effort because the vendors could not agree
19:29:00 <SamB> implementation-wise?
19:29:06 <twb`> SamB: dunno.  But now it's part of the standard.
19:29:51 <lispy> and i think any modern spec of lisp would need to include HM type system monads and both lazy and strict evaluation models
19:29:54 <palomer> someone create a Hack monad which makes your code work but makes in incomprehensible
19:30:26 <lispy> palomer: that shouldn't be hard with monads since you can redefine how the actions are combined
19:30:28 <SamB> palomer: check sanity again, will you?
19:30:58 <lispy> "when (Sanity `notElem` palomer) ...."
19:31:07 <palomer> the modern spec of lisp would contain a single word "deprecated"
19:31:13 <palomer> s/in/it
19:31:23 <lispy> or maybe i reversed the args to `notElem`
19:31:47 <palomer> I'm a list of types?
19:32:06 <lispy> i dunno, the macro language and the extremely simple syntax makes lisp nice for learning and using for scripting 
19:32:22 <lispy> palomer: yeah, a list of all the things that compose you
19:32:45 <palomer> I'm sorry sir, but I am not valid haskell
19:32:52 <lispy> :(
19:33:07 <palomer> epigram is incomprehensible
19:33:15 <palomer> I think I'll learn japanese instead
19:38:18 <lispy> oh, another reason i like lisp is that it is multiparadigm
19:38:41 <lispy> you can do procedural, OO and FP all in one program
19:39:34 <palomer> and have the program crash at a 20-nested line of code
19:40:34 <lispy> conal: hi, how goes?
19:42:24 <conal> hi lispy.  goes great.  you?
19:44:22 <lispy> conal: not bad, trying to write a grant proposal and working part time
19:45:00 <conal> oh.  what's the proposal about?
19:48:05 <twb> Anyone interested in fixes needed to make haskell-report compile?
19:48:40 <lispy> conal: ah, sorry i wandered off
19:48:44 <Igloo> Send them to Malcolm Wallace
19:48:49 <Igloo> Or one of the lists
19:49:22 <lispy> conal: um..we're looking into languages and models for animation.  Specifically for creating presentations of data models (vague enough? ;)
19:49:26 <twb> Igloo: I'm don't know any lists, which should I use?
19:49:35 <twb> Igloo: I suppose I could post to comp.lang.haskell?
19:49:53 <lispy> twb: haskell-cafe is maybe the list he meant
19:50:04 <conal> lispy: nifty.  good luck with that.  i'm guessing you know i have some possibly relevant work.
19:50:19 <lispy> conal: certainly
19:50:23 <twb> Any problem with using clh?  I can do that easily (assuming it exists).
19:50:34 <conal> lispy: just checking :).
19:50:51 <lispy> conal: i was reading about fran just the other day
19:51:50 <lispy> conal: our work will probably appear quite different, but your work has inspired at least 3/4 of our group.
19:52:04 <conal> oh.  which group is that?
19:52:47 <lispy> conal: there are four of us at OSU working on the grant, Dr. Erwig is one of them, two students counting me and an animation professor
19:53:12 <conal> lispy: oh yeah.  i'd forgotten!
19:53:52 <conal> lispy: are you going for a declarative approach?  
19:54:08 <lispy> we have some ideas that are starting to crystalize, but nothing concrete
19:54:48 <lispy> we're thinking maybe a system where you have a meta model for data based on time, and you have a query language and those work together to generate animations as needed
19:55:09 <lispy> the application domain is probably intelligent information systems
19:56:06 <lispy> conal: that's why i say it will probably look quite different than your work.  But your work was very inspiring and got us thinking.
19:56:21 <conal> lispy: glad to hear it.  thanks for letting me know.
19:56:37 <lispy> you're welcome ;)
19:57:19 <lispy> conal: in the mean time i'm taking some time off from being enrolled.  I'm doing an internship till we can secure funding for me
19:57:44 <lispy> i didn't want to pay $4125/term :)
19:59:31 <conal> yow!  then i will you very well in getting funding.
19:59:46 <conal> and an internship can open doors & stimulate ideas.
20:00:54 <lispy> conal: yeah, i like the company i work at, and i always appreciate getting to hone the practical skills
20:01:41 * twb has another go at using tailor.
20:04:48 <JKnecht> hmmm, Malta supposedly most innovated country in Europe.
20:04:58 <JKnecht> s/innovated/innovative/
20:05:23 <twb> JKnecht: by what metric?
20:06:22 <JKnecht> proportion of income from IT among others I guess: http://www.infoworld.com/article/06/01/06/73665_HNmostinnovative_1.html
20:07:23 <twb> You mean in Malta IT people earn a lot and everyone else earns not much?
20:08:22 <JKnecht> proportion of GDP.
20:08:43 <twb> I dispute that income = innovation.
20:09:30 <JKnecht> other metrics are mentioned in the article. I dispute that notion that innovation could be nation-state centric period at this point.
20:09:42 <JKnecht> s/that/the/
20:09:43 <twb> Good point.
20:10:36 * araujo doesn't hear too much about malta
20:12:04 <twb> Is there a way to get tailor to use -z9 as a CVS option?
20:14:57 <Korollary> I dispute Malta is small enough to skew all kinds of statistics.
20:15:10 <twb> No, you assert that :-)
20:15:26 <twb> You can't dispute something new.
20:16:35 <Korollary> I just meant that I'd be irritating
20:16:44 * araujo thinks that future is heading to small countries societies 
20:16:59 <araujo> At least i think that'd be better.
20:17:28 <Korollary> too many flags error
20:18:18 <twb> I reject the idea of nationalism entirely.
20:18:48 <lispy> i have no clue
20:18:51 <twb> I don't want to be associated with people who play football and beat up innocent lebanese kids.
20:19:08 <twb> ...or wrestle crocodiles.
20:19:08 <araujo> I do too, and i think that smaller countries might help to get there.
20:20:07 <palomer> hrm
20:20:14 <palomer> what's the typing rule for datatypes?
20:20:25 <lispy> what do you mean?
20:20:25 <palomer> (or, rather, what's the typing rule for case)
20:20:36 <palomer> how do you infer the type of a case statement
20:20:58 <Pseudonym> Woah, I've never heard of racist-violence-crocodile-wrestling-football.
20:21:04 <Pseudonym> And I'm Australian.
20:21:10 <Pseudonym> Is this a new code I haven't heard of?
20:21:18 <lispy> Pseudonym: heh
20:21:35 * Pseudonym is only half kidding
20:21:35 <lispy> Pseudonym: BTW, I think you're on my google talk list, but i've never sent you a message :)
20:21:46 <Pseudonym> In Australia there are three or four things called "football".
20:21:47 <Korollary> I think those two were intended to be  separate stereotypes
20:22:19 <lispy> Pseudonym: okay, now i've sent you a message :)
20:23:03 <palomer> in canada, football is a ball with a foot in it
20:23:27 <lispy> and that's why i don't trust canadians
20:23:38 <Pseudonym> OK, hang on, I'm logging on.
20:23:49 <lispy> Pseudonym: weird, it showed you as logged in
20:23:56 <Pseudonym> That is weird.
20:23:59 <Korollary> google sucks
20:24:06 <Pseudonym> I'm not Pseudonym there...
20:24:14 <Pseudonym> Some bastard took that.
20:24:20 <lispy> Pseudonym: Oh
20:24:29 <Pseudonym> So I had to be deguerre.
20:24:32 <lispy> Pseudonym: heh, okay i don't know who is on my listthen
20:24:39 <Pseudonym> What's your handle there?
20:24:50 <lispy> dagitj
20:25:10 <lispy> i was bummed that dagit was too short
20:25:43 <lispy> man, the darcs test suite takes longer than a compile :)
20:26:33 <Pseudonym> OK, I've requested an authorisation.
20:27:05 <lispy> Pseudonym: hmm...
20:27:16 <lispy> Pseudonym: i don't see anything on this end, but i'm also using iChat
20:29:17 <lispy> heh, the faux Pseudonym on google talk has now unauthorized me :)
20:33:06 <Pseudonym> :-)
20:33:16 <Pseudonym> I like "faux Pseudonym".
20:33:20 <Pseudonym> Recursive fun.
20:33:28 <lispy> ;)
20:42:17 <joelk> @seen guor
20:42:18 <lambdabot> I haven't seen guor.
20:42:22 <joelk> @seen gour
20:42:23 <lambdabot> I saw gour leaving #haskell 7 hours, 34 minutes and 52 seconds ago.
20:56:57 <twb> What are these .hs-boot files in flippi's source?
20:59:30 <joelk> something to do with recursive modules I believe. bootstrapping the compile process?
21:00:16 <twb> They can't be auto-generated?
21:01:16 <joelk> I think they can-be/are... don't really know much about it.
21:04:10 <joelk> oh no, http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html section 4.6.9
21:04:56 <twb> joelk: That sucks.
21:05:24 <joelk> yeah! seriously.
21:07:59 <joelk> Seems like it could be automated fairly easily. There must be a good reason it isn't. 
21:20:16 <palomer> > foldr (-) [1..100]
21:20:17 <lambdabot>  add an instance declaration for (Show ([[a]] -> [a]))
21:20:28 <palomer> > foldr1 (-) [1..100]
21:20:30 <lambdabot> -50
21:20:33 <palomer> > foldr1 (-) [1..1000]
21:20:35 <lambdabot> -500
21:20:42 <palomer> > foldl1 (-) [1..1000]
21:20:44 <lambdabot> -500498
21:20:51 <palomer> > foldl1 (-) [1..10000]
21:20:53 <lambdabot> -50004998
21:20:56 <palomer> discuss.
21:21:07 <palomer> can anyone guess the next term?
21:21:22 <lispy> nope
21:21:30 <palomer> oh, come on people
21:22:02 <palomer> > 255*501
21:22:04 <lambdabot> 127755
21:22:29 <palomer> > 500*501
21:22:31 <lambdabot> 250500
21:22:40 <palomer> > 500*501-2
21:22:42 <lambdabot> 250498
21:22:46 <palomer> > 5000*5001-2
21:22:48 <lambdabot> 25004998
21:23:11 <palomer> > 500*1001-1
21:23:12 <lambdabot> 500499
21:23:15 <palomer> > 500*1001-2
21:23:16 <lambdabot> 500498
21:23:25 <palomer> > 5000*10001-2
21:23:26 <lambdabot> 50004998
21:23:33 <palomer> > 50000*100001-2
21:23:34 <lambdabot> 5000049998
21:23:41 <palomer> > foldl1 (-) [1..100000]
21:23:43 <lambdabot> -5000049998
21:23:48 <palomer> bingo.
21:23:55 <palomer> I don't know where the 2 comes in though
21:24:03 <palomer> oh, righto
21:24:04 <palomer> nevermind
21:24:47 <lispy> > foldr1 (-) [1..100000]
21:24:48 <lambdabot> -50000
21:25:19 * palomer has never used list comprehensions since he started using haskell
21:25:23 <palomer> are they really that useful?
21:25:49 <lispy> yes
21:25:59 <lispy> i use them a lot when working with algorithms
21:32:45 * lispy submits another darcs patch
21:32:48 <lispy> go darcs!
21:34:55 <JohnMeacham> darcs is amazing.
21:38:38 <dons> palomer, they're pretty useful. at least good to have in the armoury
21:39:49 <lispy> JohnMeacham: yeah, and i'm doing my best to improve it.
21:40:06 <lispy> as are many others...
21:40:19 <lispy> but, i'm just proud of myself for contributing :)
21:44:02 <JohnMeacham> I am waiting for jhc to spring another horrible heisenbug so I have an excuse to rewrite darcs trackdown.
21:45:18 <lispy> heh
21:56:18 <twb`> Is x >>= y congruent to x =<< y ?
21:56:29 <lispy> congruent?
21:56:36 <lispy> they do different things
21:56:43 <lispy> @type (>>=)
21:56:44 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
21:56:47 <twb`> Oops, swap the x and y on the second one.
21:56:52 <twb`> Is x >>= y congruent to y =<< x ?
21:56:53 <lispy> @type flip >>=
21:56:54 <lambdabot> parse error (possibly incorrect indentation)
21:57:15 <lispy> twb`: yeah, in that case
21:57:20 <twb`> Cool.
21:57:20 <lispy> @type flip
21:57:22 <lambdabot> forall c a b. (a -> b -> c) -> b -> a -> c
21:57:51 <lispy> same with >> and <<
21:58:07 <twb`> Y'know how earlier I thought "let x = y in z" ==> "(\x->z)y"?
21:58:16 <lispy> okay
21:58:22 <dons> << ? haven't seen that before.
21:58:31 <twb`> Well I noticed that "do x <- y; z" ==> "(\x->z)=<<y"
21:58:31 <dons> @type (Control.Monad.<<)
21:58:33 <lambdabot> Not in scope: `Control.Monad.<<'
21:58:34 <lispy> dons: oh, did i just make that up...oops
21:58:37 <dons> I don't think there is a <<
21:58:45 <dons> @index  <<
21:58:45 <lambdabot> Text.Html
21:58:52 <dons> @index =<<
21:58:53 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer,
21:58:53 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.
21:58:53 <lambdabot> Monad.Cont, Control.Monad.Error, Control.Monad.List
21:59:11 * lispy tries to remember why you'd want to use =<<
21:59:14 <twb`> I thought the similarity was interesting.
21:59:35 <lispy> oh right
21:59:35 <dons> for niceness.
21:59:46 <dons> f . x . y =<< some ugly io
21:59:51 <lispy> yeah
21:59:55 <lispy> i just realized that :)
22:00:02 <dons> f . x . y =<< getContents     -- is a common one
22:00:10 <twb`> dons: So you can put the shorter operand first, yes?
22:00:29 <dons> or the one that actually does the work, so getContents doesn't distract
22:00:41 <twb`> I see.
22:00:49 <lispy> yeah, i think of consumer/producer
22:01:02 <dons> some examples:
22:01:03 <dons> mapM_ ((putStr . show . (+1) =<<) . peekElemOff perm1) [0..n-1]
22:01:08 <dons> putStr . show . (+1) =<< peek (p `advancePtr` i)
22:01:15 <dons> dnaThree = process =<< getContents
22:01:18 <twb`> lispy: you mean like that flow model from canada?
22:01:20 <dons> main = print . new (I 0) =<< getContents
22:01:27 <dons> main = putStrLn . show . (\n -> tak (3*n) (2*n) n) . read . head =<< getArgs
22:01:34 <dons> they're examples from the shootout
22:01:36 <lispy> twb`: dunno, i don't trust canadians :)
22:01:44 <twb`> lispy: Unix pipes, then?
22:01:52 <lispy> oh, yeah
22:02:05 <lispy> dons: i tihnk it's time to show twb` h4sh
22:02:13 <dons> yeah, like in h4sh
22:02:16 <twb`> I did some really interesting things with pipes in the forth style.
22:02:26 <dons> iterate 'show.(+1).read' 0 | take 10
22:02:28 <twb`> Well, not *really* interesting.  Mildly interesting.
22:02:36 <dons> words one two three | map reverse | unwords
22:02:38 <twb`> http://cyber.com.au/product/accudoc/rst-writer.sh
22:02:45 <dons> here | is equivalent to >>=
22:03:48 <ski> (twb` : some papers use a notation like 'mlet x <- y in z' iirc)
22:04:48 <ski> (palomer : typing of case ?)
22:07:29 <palomer> ski: oh yes
22:07:44 <palomer> where can I find the typing rule for case?
22:08:41 * palomer is quite happy with the work done today
22:09:02 <ski> hm, i could sketch down one for you ..
22:09:30 * palomer wonders why people don't publish this stuff
22:09:58 <palomer> like, typing case C1 x => e1 | C2 x => e2
22:10:19 <palomer> oh, right, well the constructor determines the type of x
22:10:38 <palomer> and then you have to type e1 assuming that x is of type parameter(C1)
22:12:17 <palomer> and then you have to check that e1 and e2 have the same type
22:13:05 <lispy> there is a somewhat intuitive "it has to unify" version of type checking
22:13:07 <palomer> which is the type of the term
22:13:11 <ski> Gamma |-e e0 : sigma   ( Gamma' |-p p : sigma   Gamma,Gamma' |-e e : tau ) ...
22:13:11 <ski> ------------------------------------------------------------------------------
22:13:11 <ski> Gamma |-e case e0 of {p -> e; ...} : tau
22:13:50 <palomer> p p: sigma ?
22:14:05 <palomer> why doesn't the gamma prime propagate to the conclusion?
22:14:30 <ski> hm, maybe should have s/|-e/|-_e/ and s/|-p/|-_p/
22:14:54 <ski> '|-e' and '|-p' mark two different forms of judgements
22:14:57 <palomer> and p doesn't appear in any context
22:17:41 <ski> hm
22:18:12 <ski> Gamma is typings for free vars, of course
22:18:37 <ski> we type 'e0' possibly using those, getting type 'sigma'
22:19:17 <palomer> you can't have free vars on the right hand side and not on the left hand side
22:19:23 <ski> the 'p -> e; ...' notation i used really means that we have a sequence of such branches, each with one 'p' (pattern) and one 'e'
22:19:36 <ski> hm, where do you mean ?
22:19:46 <palomer> oh, p is a pattern
22:19:54 <palomer> what's _e ?
22:20:12 <palomer> and what's _p p ?
22:20:12 <sethk> all, a couple of weeks ago I got a reference for a project that produced some stand alone (no o/s) programs from haskell.  I lost my notes; anyone remember ?
22:20:39 <palomer> haskell OS project?
22:21:09 <ski> '|-e' is the entails symbol used for one kind of judgement
22:21:17 <ski> '|-p' is the entails symbol used for another kind of judgement
22:21:52 <palomer> oh, what's the second kind of judgement called?
22:21:58 <ski> first is used for typing an expression, given variable typings, giving back a type (can be sued for checking against a given type also, of course)
22:22:43 <ski> second is used for checking a pattern against a type, and getting back a variable typing environment, which just contains the vars that this pattern binds
22:22:52 <ski> oh, not sure about names
22:23:00 <palomer> oh, I see
22:23:11 <palomer> so the "type" of the second judgement is actually an environment
22:23:18 <ski> er ?
22:23:40 <palomer> sigma is an environment
22:23:43 <ski> the output of second judgement is an env (usually, at least)
22:23:48 <ski> er, no
22:24:03 <palomer> so where's the environment?
22:24:04 <ski> 'sigma' is the type of the inspected expression
22:24:20 <ski> i'll show an example instantation of this rule
22:30:32 <ski> xs : [Int] |-e reverse xs : [Int]
22:30:32 <ski> |-p [] : [Int]   xs : [Int] |-e Nothing : Maybe Int
22:30:32 <ski> y : Int,ys : [Int] |-p y:ys : [Int]   xs : [Int],y : Int,ys : [Int] |-e Just y : Maybe Int
22:30:32 <ski> ------------------------------------------------------------------------------------------
22:30:32 <ski> xs : [Int] |-e case reverse xs of {[] -> Nothing; y:ys -> Just y} : Maybe Int
22:30:47 <ski> (put premises on several lines)
22:31:06 <sethk> palomer, no, making programs to run without an O/S, as in an embedded environment
22:31:42 <ski> @where house
22:31:43 <lambdabot> http://www.cse.ogi.edu/~hallgren/House/
22:31:44 <sethk> palomer, I'm building test software
22:31:48 <ski> (sethk : that ?)
22:31:55 <sethk> ski, let me look.  thanks.
22:32:11 <sethk> ski, yep.
22:32:12 <palomer> ski: got any references?
22:32:30 <sethk> ski, thanks again.
22:32:42 <palomer> |- p [] : [Int] returns an environment, right?
22:38:05 <ski> s/|- p/|-p/
22:38:08 <ski> yes. an empty environment, in this case
22:38:11 <ski> hm
22:38:37 <ski> (it's sortof obvious to me that a typing rule for case must be something like this ..)
22:38:48 <palomer> yeah, I'm seeing it
22:39:03 <palomer> hrmph
22:39:06 * palomer will have to ponder it
22:39:07 <palomer> bbl!
22:39:12 <palomer> (and thx)
22:40:47 <ski> (hm, i seem to recall some paper (there are almost certainly lots of them) which talked about typing patterns ..)
22:41:54 <ski> (palomer : sometimes the syntax used for the judgement for typing patterns is different, with the output env to the right .. but that's only syntax)
23:30:23 <araujo> Hello.
23:30:28 * araujo thinkin' to get some cakes
23:47:50 <ski> good morning, #haskell
23:49:09 <lispy> morning
23:50:15 <araujo> morning
