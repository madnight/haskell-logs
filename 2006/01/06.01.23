00:43:40 <dons> @y0w
00:43:40 <lambdabot> Used staples are good with SOY SAUCE!
00:45:05 <Lemmih> dons: Are you able to build hs-plugins with ghc-6.5?
00:47:15 <dons> hmm. at least with the August '05 version
00:47:27 <lispy> @keal
00:47:27 <lambdabot> i want to invent white dye
00:48:02 <dons> I think randomly capitalised @keal lines would make a good @yow :)
00:48:39 <lispy> @. leet keal
00:48:39 <lambdabot> compose module failed: Parse error: "leet"
00:48:50 <dons> elite
00:48:54 <lispy> @. elite keal
00:48:54 <lambdabot> zO/\/\0nE W0UlD 3Xp3(7 Th4T TR3ez 500g8 hddz oF 3Xpre5sI0nz a$ if th3y \/\
00:48:54 <lambdabot> /eRe FLoppY DIxx5
00:49:26 <lispy> heh, bit over the top
00:49:36 <lispy> lambdabot: you so l33t
00:49:59 <dons> @. elite bot
00:49:59 <lambdabot> compose module failed: Parse error: "bot"
00:50:27 <lispy> @. elite vixen
00:50:28 <lambdabot> You'rE tuRNIN9 m3 0N :)
00:50:29 <dons> @. elite botsnack
00:50:30 <lambdabot> :)
00:51:19 <lispy> @. vixen keal
00:51:19 <lambdabot> church is my favourite computer scientist.
00:51:35 <lispy> lambdabot: <3
00:51:54 <Lemmih> dons: That AltData needs a header file from GHC has bitten me (and other people) a couple of times.
00:52:04 <dons> ah. hmm yes.
00:52:27 <dons> simonM said he was thinking about solving it once and for all, so we can get rid of AltData.
00:52:36 <dons> there's an open ticket. 
00:53:08 <dons> or we just distribute the full header  (since it rarely changes)
00:53:21 <Lemmih> yak.
00:53:27 <dons> @. vixen vixen
00:53:28 <lambdabot> really!?
00:53:39 <dons> @. vixen vixen
00:53:39 <lambdabot> I can't of anything nice to say about myself
00:55:31 <srle> lambdabot : 5*5
00:55:44 <Lemmih> > 5*5
00:55:44 <srle> lambdabot: 5*5
00:55:45 <lambdabot> 25
00:56:11 <srle> lambdabot: (\x -> x * x) 5
00:56:12 <musasabi> JohnMeacham: did you see the "main = print (sum [1..10] :: Int)" problem with jhc ?
00:56:16 <musasabi> dons: pong
00:57:31 <dons> musasabi, interested in comitting the knucleotide entry: http://www.haskell.org/hawiki/KnucleotideEntry
00:58:30 <dons> also, I don't think the best sumcol has been committed yet: http://www.haskell.org/hawiki/SumFile
01:00:26 <dons> thirdly, Bertram proposed a more beautiful Harmonic  (no unboxing): http://www.haskell.org/hawiki/HarmonicEntry
01:00:33 <olliej> does anyone know where a format specification for the .hi files might be? or is it time for me to trawl through the ghc source?
01:01:02 <Lemmih> olliej: There's no formal specification.
01:01:15 <olliej> @#%#$
01:01:15 <lambdabot> Unknown command, try @listcommands.
01:01:18 <olliej> hehe
01:01:19 <dons> elliej, it's a binary format, read fptools/ghc/compiler/iface
01:01:27 <srle> @listcommands
01:01:28 <lambdabot> use listcommands [module|command]. Modules are:
01:01:28 <lambdabot> babel base code compose dice dict djinn dummy dynamic elite fact haddock
01:01:28 <lambdabot> help hoogle karma lShell localtime more pl plugs poll pretty quote search
01:01:28 <lambdabot> seen spell state system todo topic type version vixen where
01:01:31 <olliej> elliej?? :p
01:01:36 <dons> it changes rarely though, so you can write tools to grok it
01:01:40 <dons> sorry, typo
01:01:42 <srle> @help
01:01:43 <lambdabot>  @help <command> - ask for help for <command>
01:01:43 <olliej> :)
01:01:54 <musasabi> dons: ok, looking at them.
01:02:01 * olliej wonders if .hi files contain function arity info
01:03:00 <dons> use --show-iface
01:03:02 <dons> to find out
01:06:54 <musasabi> harmonic committed.
01:08:06 <musasabi> From knucleotide "An efficient HashTable" or "Proposed entry" ?
01:09:16 <olliej> dons: doesn't seem to be an option (at least in ghc for windows (v 6.4))
01:14:40 <JohnMeacham> musasabi: no. where was it (hit-n-run, mail me)
01:15:50 <dcoutts> gour, pong
01:18:30 <musasabi> mailed.
01:29:28 <gour> dcoutts: hi, saw your call yesterday whne i returned after the seminar, but then you were not around :-(
01:30:01 <dcoutts> gour, oh yeah, so I was thinking about the structure of a Gtk2Hs tutorial
01:30:29 <gour> dcoutts: few days ago i got a new laptop, but so far i managed to wipe win xp only :-)
01:30:36 <dcoutts> heh
01:30:54 * gour is installing gentoo on his amd64 laptop
01:31:36 <gour> dcoutts: have you put something on the wiki? (i saw only about hiDE, but that's wonderfull too)
01:31:48 <dcoutts> http://haskell.org/haskellwiki/Gtk2Hs/Tutorials/Intro
01:32:45 <gour> great, will take a look and think about it, let me just finishing playing with a new baby ;)
01:54:20 <JaffaCake> Igloo: ping?
01:54:38 <Lemmih> Hiya JaffaCake.
01:54:44 <JaffaCake> hi Lemmih
01:59:16 <dcoutts> JaffaCake, you got my flurry of patches over the weekend? :-)
01:59:29 <JaffaCake> I've seen the Haddock one
01:59:39 <JaffaCake> are there more? haven't checked the lists yet
01:59:42 <dcoutts> and a trivial one for hsc2hs
01:59:51 <JaffaCake> ok
02:00:13 <dcoutts> I'll send a doc patch for haddock soonish
02:00:26 <JaffaCake> Haddock stuff looks great, nice work
02:00:30 <dcoutts> thanks
02:00:47 <dcoutts> do you think the URL substitution syntax is too gross?
02:01:03 <JaffaCake> you mean the %F %N stuff?
02:01:14 <dcoutts> it's more than that :-)
02:01:19 <JaffaCake> oh
02:01:38 <JaffaCake> ah, just reading your other patch
02:03:42 * dcoutts tries to think of the most ugly substituion possible
02:03:44 <dcoutts> --source=http://foo.bar/docs%{MODULE/./-|/%}%{KIND|#%:}%{NAME}
02:04:29 <dcoutts> however having optional bits is important, but if we can do that an simplify the syntax then great.
02:05:21 <JaffaCake> I don't quite understand the %{VAR|...} syntax... when would you use it?
02:05:36 <dcoutts> JaffaCake, take the wiki example...
02:05:54 <dcoutts> the base url is:
02:05:55 <dcoutts> http://haskell.org/haskellwiki/Gtk2Hs
02:05:59 <JaffaCake> oh, I get it
02:06:00 <dcoutts> not http://haskell.org/haskellwiki/Gtk2Hs/
02:06:28 <JaffaCake> we could just have separate base URLs and entity URLs
02:06:39 <dcoutts> that's another alternative
02:06:44 <dcoutts> we'd need 3
02:06:58 <JaffaCake> yes - contents page, top of module page, and entity link
02:07:00 <dcoutts> --source-base, --source-module --source-entity
02:07:24 <dcoutts> if that'd be easier to explain then fine with me
02:07:41 <dcoutts> if they're not specified they can get defaults
02:07:43 <JaffaCake> I'd go with that, unless you really want to avoid the duplication, but I don't think it's a big deal
02:08:09 <dcoutts> ok I'll do that, I was having a bit of difficulty explaining it in the docs :-)
02:08:20 <JaffaCake> that's always a bad sign :)
02:08:27 <dcoutts> same for the --wiki option
02:08:40 <dcoutts> JaffaCake, indeed :-)
02:09:00 <JaffaCake> your first patch still stands?
02:09:19 <dcoutts> JaffaCake, can I make them cumulative?
02:09:35 <dcoutts> hmm, I could unrecord
02:09:54 <JaffaCake> it's up to you
02:10:00 <dcoutts> JaffaCake, don't apply them yet, I'll resend
02:10:12 <JaffaCake> ok
02:10:17 <dcoutts> JaffaCake, so did you get the hsc2hs patch? I think it should go into 6.4.2 as well if you think it's ok.
02:10:41 <JaffaCake> where did you send it
02:10:43 <JaffaCake> ?
02:10:55 <dcoutts> Simon Marlow <simonmar@microsoft.com>
02:11:35 <JaffaCake> hmm
02:11:43 * JaffaCake checks spam folder
02:11:59 <dcoutts> hsc2hs was emitting {-# LINE Foo.hsc #-} pragmas even if it was done as bar/Foo.hsc
02:12:19 * JaffaCake finds a darcs patch in his spam folder :(
02:12:59 <JaffaCake> sounds like a good bug, thanks
02:13:08 <dcoutts> hsc2hs was explicitly taking the file path appart and emitting only the file name and not the path. I just removed that so it emits the full original file name.
02:13:32 <JaffaCake> I wonder why it was doing that
02:13:40 <dcoutts> so I deleted 10 chars or so and that was it! :-)
02:14:04 <dcoutts> with that, haddock can produce accurate source links for .hsc files
02:14:32 <dcoutts> or rather .hs file which started as .hsc files originally
02:20:17 <dcoutts> JaffaCake, so what do you think the --source-??? flags should be?
02:20:36 <dcoutts> do we get rid of the existing -s & --source flags?
02:21:18 <dcoutts> or maybe we can have some clever defaulting thing and keep --source as the primary one
02:21:22 <JaffaCake> your suggestions were fine: --source-base, -module and -entity
02:21:37 <JaffaCake> we could keep --source as a synonym for --source-module for backwards compat
02:21:43 <dcoutts> ok
02:22:01 <araujo> Good morning.
02:32:21 <vincenz> re
02:34:50 <Lemmih> JaffaCake: I can't edit or create new tickets when I'm logged in as Lemmih at the Trac for GHC.
02:35:03 <JaffaCake> hmm
02:36:26 <JaffaCake> is it case sensitive... I registered you as "lemmih"
02:37:14 <JaffaCake> ah, you used "Lemmih"
02:37:39 <JaffaCake> do you want to use the capitalized version? I don't mind
02:38:44 <Lemmih> I prefer Lemmih with a capital L.
02:39:35 <JaffaCake> ok
02:40:11 <JaffaCake> Lemmih: ok, try now
02:42:01 <Lemmih> JaffaCake: It works. Thanks.
02:49:59 <eivuokko> JaffaCake, have you tried forkOS in darcs ghc (in Windows)?  On some quick testing I did, it crashes at least in Windows.
02:50:25 <JaffaCake> eivuokko: thanks for the report, I'll give itt a try
02:51:42 <eivuokko> And the build thingy about unicode stuff in Windows is wierd, I disabled unicode keywords and the compiler I got was able to compile them.
02:55:02 <eivuokko> Uhm, I mean I compiled ghc without unicode keywords, and that ghc was able to compile pristine ghc sources.
03:57:08 <vincenz> Is there any lib that allows the display of graphs
03:58:05 <Saulzar> Lots of graphics libs. Cairo, HOpenGL, HGL...
03:58:37 <dcoutts> but notging specifically for protting graphs of data if that's what you mean
03:58:39 <vincenz> yeah but I mean contianing the code to do graph idisplaying
03:58:52 <vincenz> ala touchgraph
03:58:56 <dcoutts> protting/plotting
03:59:11 <dcoutts> I'd reccomend calling out to gnuplot
03:59:24 <vincenz> o.
03:59:26 <vincenz> for graphs?
03:59:32 <vincenz> I don't mean y =f(x)
03:59:34 <vincenz> I mean graphs
03:59:36 <vincenz> as in DGs
04:01:39 <earthy> call out to graphviz. ;)
04:08:54 <dcoutts> vincenz, yeah, I use graphviz with a couple Haskell progs. It's great.
04:09:36 <dcoutts> generating the graphviz input file format is easy, and graphviz can produce loads of different output formats.
04:14:11 <vincenz> yeah but it's not very gui-oriented
04:14:50 <vincenz> http://www.touchgraph.com/index.html
04:18:32 <dcoutts> vincenz, see Blobs
04:18:35 <dcoutts> @where blobs
04:18:35 <lambdabot> http://haskell.org/Blobs
04:20:49 <vincenz> ooh
04:23:32 <vincenz> is haskell 2 a new thing?
04:25:19 <geneticp> has haskell something more tan beauty?
04:25:47 <ibid> i've seen references to haskell 2 in list archives dating from the haskell 1.2 days :)
04:26:51 <ibid> it seems to be the ideal haskell we never reach. "we'll do it all right in haskell 2. in the mean time, let's fix these issues in a point release" :)
04:34:10 <vincenz> > minimum
04:34:11 <lambdabot>  add an instance declaration for (Show ([a] -> a))
04:34:19 <vincenz> @type minimum
04:34:20 <lambdabot> forall a. (Ord a) => [a] -> a
04:34:42 <vincenz> > minimum [[1,1,2],[1,2,1],[1,1,2,1]]
04:34:43 <lambdabot> [1,1,2]
04:35:44 <vincenz> @type foldr
04:35:45 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
04:40:30 <flux__> ibid, well, atleast there haven't been many haskell 3 references, have there?
04:40:31 <tromp_> > minimum ["Ocaml", "Java", "Perl", "Haskell", "Ruby"]
04:40:32 <lambdabot> "Haskell"
04:40:37 <ibid> flux__: :)
04:41:21 <ibid> > maximum ["Ocaml", "Java", "Perl", "Haskell", "Ruby"]
04:41:22 <lambdabot> "Ruby"
04:41:27 <ibid> pöh :)
04:41:36 <tromp_> > minimum ["one", "two", "three"]
04:41:37 <lambdabot> "one"
04:41:50 <flux__> wow, haskell knows english :)
04:41:56 <dons> though, instead of haskell 3, we usually just say Haskell 3000 ;)
04:42:34 <Zerttt> lambdabot: version
04:42:38 <Zerttt> lambdabot: !version
04:42:40 <ibid> > minimum ["one","two","three","four"]
04:42:41 <lambdabot> "four"
04:42:47 <ibid> @version
04:42:47 <lambdabot> lambdabot 3p283, GHC 6.5.20050806 (Linux i686)
04:42:47 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
04:42:53 <Zerttt> thanks
04:44:25 <ibid> dons: so, haskell 3000 is the "uncountably inifinite" haskell, as even haskell 2 is unreachable and hence (presumably denumerable) infinite? :)
04:53:49 <tromp_> what will they call the next version after python 3000?
04:58:02 <jip> i think python 3000 will really be called python 3.0
04:58:17 <jip> and the next version will probably be python 3.0.1 :)
05:12:39 <shapr> @yow !
05:12:40 <lambdabot> When you said "HEAVILY FORESTED" it reminded me of an overdue CLEANING
05:12:40 <lambdabot> BILL ... Don't you SEE?  O'Grogan SWALLOWED a VALUABLE COIN COLLECTION
05:12:40 <lambdabot> and HAD to murder the ONLY MAN who KNEW!!
05:18:34 <tromp_> @pl bla f x y z = y (f x z)
05:18:34 <lambdabot> bla = (flip (.) .)
05:19:13 <tromp_> @pl \x y -> x y x
05:19:13 <lambdabot> join flip
05:19:24 <frevidar> how did lambdabot do that?
05:19:47 <tromp_> @t join
05:19:47 <lambdabot> Maybe you meant: todo todo-add todo-delete topic-cons topic-init topic-
05:19:47 <lambdabot> null topic-snoc topic-tail topic-tell type .
05:19:53 <tromp_> @type join
05:19:54 <lambdabot> Not in scope: `join'
05:20:09 <tromp_> @index join
05:20:10 <dblhelix> @type Control.Monad.join
05:20:10 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.
05:20:10 <lambdabot> State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont,
05:20:10 <lambdabot> Control.Monad.Error, Control.Monad.List
05:20:10 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
05:20:48 <tromp_> use the source, frevidar:P
05:21:34 <xerox> frevidar: it has a plugin which dos the translation by substitution rules
05:21:38 <xerox> (Howdy)
05:21:45 <tromp_> @type Control.Monad.Reader.join
05:21:46 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
05:22:11 <frevidar> xerox: it does lambda reduction or whatever its called?
05:23:31 <xerox> Beats me now,
05:25:20 <tromp_> @pl \x -> x x
05:25:21 <lambdabot> join id
05:26:20 <tromp_> @pl \x -> x x x
05:26:21 <lambdabot> join (join id)
05:30:19 <vincenz> @hoogle integrate
05:30:19 <lambdabot> No matches found
05:30:24 <vincenz> > integreate
05:30:25 <lambdabot>  Not in scope: `integreate'
05:30:27 <vincenz> > integrate
05:30:28 <lambdabot>  Not in scope: `integrate'
05:30:55 <xerox> hmm? :)
05:31:03 * vincenz was readiing whyfp
05:31:09 <vincenz> neat document :)
05:31:14 <vincenz> I especially like the super function defined there
05:31:26 <xerox> What is it?
05:31:29 <vincenz> well
05:31:41 <vincenz> the idea is that you can define a function to improve the error
05:31:50 <vincenz> by reducing the error in two approximations
05:31:55 <vincenz> (between)
05:32:34 <vincenz> so instead of using finer and finer sampling points
05:32:48 <vincenz> it basically sees this improved function as an approximation, and then improves upon it again
05:33:03 <vincenz> super basically makes an infinite list of improvements (isntead of more closely ranged sampling points)
05:34:36 <xerox> Sounds nice.
05:34:41 <vincenz> I was thinking it would be neat to use this in a deformable 3d mesh simulator
05:34:53 <vincenz> basically define an infiniite list of refinements for each integration step
05:35:01 <vincenz> and then do it according to time/error constraints
05:43:13 <shapr> vincenz: Would be neat to have a generic 'refine approximation for zooming' ... fractals, 3D rendering, lots more could benefit from that.
05:45:21 <vincenz> true
05:45:52 <vincenz> blegh, googledesktop webclips can not support the hwn feed
05:52:48 * vincenz hmms
06:15:23 <dcoutts> JaffaCake, I'm sending you those haddock patches. I've made them cumulative, but I've included all of them so you only need to apply this patch bundle.
06:15:39 <JaffaCake> great, ta
06:15:52 <dcoutts> oh and I included documentation!
06:16:04 <jak> Hi guys, i see that Typeable a => Data, but that doesn't mean that if you have a Data object it is also Typeable
06:16:23 <jak> i mean if all you know about it is that it is Data, then you can't use the Typeable calls on it
06:16:31 <dcoutts> jak, sure you can
06:16:39 <dcoutts> that's the point of class inheritance
06:16:55 <jak> dcoutts, yeah I'm getting a little confused!
06:17:05 <dcoutts> s'ok
06:17:24 <dcoutts> it can be confusing at first
06:17:25 <jak> So does that mean all Data types are also Typeable ?
06:17:33 <dcoutts> if a class declares:
06:17:42 <dcoutts> class A a => B b where ...
06:18:06 <dcoutts> then it means that for a type to be an instance of class B it must also be an instance of class A
06:18:34 <dcoutts> the compiler will complain if you try to make a type an instance of B if you havn't already made it an instance of A
06:18:44 <jak> dcoutts, are you familiar with dataCast1 and dataCast2 http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Generics-Basics.html#t%3AData
06:18:52 <dcoutts> not really
06:19:13 <jak> Do you think that would allow you to cast from a Data type back to an ordinary constructor that you are more familiar with
06:19:21 <dcoutts> and so, conversely, if you've got a type in class B you can be assured that it's also in class A and so you can use methods from class A.
06:19:33 <jak> dcoutts, right
06:20:03 <dcoutts> dataCast1 :: Typeable1 t => (forall a . Data a => c (t a)) -> Maybe (c a)
06:20:07 <dcoutts> hmm that's a bit hairy
06:20:11 <jak> heh, indeed!
06:20:22 <dcoutts> I'd read the documentation about how it's supposed to be used
06:20:33 <dcoutts> it's not obvious to me from the type
06:20:53 <dcoutts> the local forall is what confuses me
06:21:27 <jak> I've just downloaded http://web.comlab.ox.ac.uk/oucl/research/pdt/ap/dgp/workshop2004/peytonjones.ppt
06:21:34 <jak> which *might* explain it
06:22:01 <dcoutts> :-)
06:25:00 <JaffaCake> dcoutts: applied, thanks!
06:25:09 <dcoutts> JaffaCake, yay. Cool.
06:25:38 <dcoutts> JaffaCake, I didn't actually build the haddock docs since I don't have the tools installed. So I hope I sent you well formed docbook. :-)
06:26:52 <Lemmih> JaffaCake: How did you manage to apply my patch?
06:27:08 <JaffaCake> Lemmih: the repo was corrupt
06:27:19 <JaffaCake> I swapped it for an uncorrupt copy
06:28:47 <JaffaCake> Lemmih: http://www.abridgegame.org/pipermail/darcs-users/2006-January/009362.html
06:33:20 <dcoutts> xerox, you about?
06:33:52 <dcoutts> xerox, I found another cool cairo demo someone could port to Haskell.
06:33:52 <dcoutts> http://macslow.mine.nu/shots/cairo-clock-2.png
06:34:01 <dcoutts> the C code is less than 500 lines.
06:34:13 <dcoutts> it's GPL
06:35:00 <dcoutts> http://www.gnomefiles.org/app.php?soft_id=1259
06:39:13 <Igloo> JaffaCake: Is "darcs send" to the repos meant to work?
06:39:35 <JaffaCake> darcs send goes to the mailing list
06:39:42 <Igloo> Hmm
06:39:48 <JaffaCake> we're using push w/ SSH
06:40:08 <Igloo> Unless I'm confused the mailing address needs to be in http://darcs.haskell.org/ghc/_darcs/prefs/email then
06:41:27 <dcoutts> yeah, I had to add the target email address manually on my end
06:41:41 <dcoutts> it should be set on the server side
06:50:41 <JaffaCake> Igloo: strange, I though I set that.  oh well, it's done now
06:50:57 <Igloo> Thanks
06:50:58 <JaffaCake> Igloo: I think I have more clues about the corrupt repo
06:51:04 <JaffaCake> it has just happened again
06:51:31 <JaffaCake> simonpj tried to push a patch and it failed due to a permission problem in _darcs/inventories
06:51:43 <Igloo> Aha
06:52:21 <JaffaCake> is there anything you'd like me to investigate?  I have the bits sitting here
06:53:10 <jonkri> hey people :-)
06:53:22 <Igloo> It's probably either the directories not being g+x or your umasks being 755ish rather than 775ish
06:53:40 <Igloo> Err, g+s I mean
06:54:02 <JaffaCake> yes - I've now done the g+s thing, I guess we need umask 002 too?
06:54:17 <JaffaCake> is there a recommended way to do this that doesn't involve everyone changing their umasks?
06:55:06 <dcoutts> JaffaCake, it can be done globally, then people don't have to do it themselves
06:55:10 <Igloo> I think you'd have to replace darcs with a wrapper (or put one in /usr/local earlier in the path)
06:55:13 <dcoutts> but it's still unpleasent
06:55:29 <Igloo> dcoutts: People still might override it in their .bashrc's etc, though
06:55:47 <dcoutts> oh actually, you can put a post-hook in that does chmod g+rw -R
06:56:01 <JaffaCake> yes, I was thinking that
06:56:06 <dcoutts> I know that darcs's darcs repo does that
06:56:16 <dcoutts> there's an FAQ about it somewhere
06:56:20 <JaffaCake> aha
06:56:46 <JaffaCake> Igloo: should I submit a bug about the corruption?
06:56:51 <Igloo> Yes please
07:42:07 <astrolabe> Why doesn't this work?
07:42:24 <astrolabe> @eval (\(a,b) -> a+b) 3 4
07:42:24 <lambdabot>  add an instance declaration for (Num (t -> a, t -> a))
07:42:49 <musasabi> > (\(a,b) -> a+b) 3 4
07:42:50 <lambdabot>  add an instance declaration for (Num (t -> a, t -> a))
07:42:57 <Lemmih> > (\a b -> a+b) 3 4
07:42:58 <lambdabot> 7
07:43:02 <musasabi> you have the tuple there.
07:43:09 <musasabi> (a,b) vs a b
07:43:16 <Cale>  > (\(a,b) -> a+b) (3,4)
07:43:16 <dcoutts> JaffaCake, is it possible to get the name of somethign in the Typeable class? I'm wondering if we can do better than "a.out: unknown exception" when something throws a dynamic exception that is never caught.
07:43:19 <Cale> > (\(a,b) -> a+b) (3,4)
07:43:20 <lambdabot> 7
07:43:33 <astrolabe> Ah, of course.  Thanks all.
07:44:22 <Lemmih> dcoutts: Can't you use the show instance for Dynamic?
07:44:31 <dcoutts> Lemmih, can we?
07:44:37 <Heffalump> yeah, I'm sure I've used that before.
07:44:38 <JaffaCake> dcoutts: I think we can
07:44:58 <Lemmih> > toDyn "My exception"
07:44:59 <lambdabot> <<[Char]>>
07:45:16 <Heffalump> it at least gives you the type so you can change your code to catch that specific type and print out more information
07:46:05 <dcoutts> JaffaCake, yes, would it be possible to change the default global error handler to at least mention that it's dynamic exception of type ...
07:47:21 <JaffaCake> I'll look into it
07:47:23 <dcoutts> JaffaCake, we've had people complain about their Gtk2Hs progs dieing with "unknown exceptions". Where of course what's really going on is that we're throwing a structured exception type rather than just a string.
07:47:51 <dcoutts> but it's tempting to going back to just throwing strings because for the casual use it is easier on the user
07:48:08 <Heffalump> if you know the type of the exception, can't you just catch it?
07:48:11 <dcoutts> but catchign and dealing with string errors is not really possible
07:48:19 <Heffalump> (at the top level)
07:48:33 <dcoutts> Heffalump, I know the type of the excpetion, our users don't, because they don't read the docs.
07:48:47 <dcoutts> Heffalump, sadly we have no top level.
07:49:03 <Heffalump> ah, I thought you controlled that in GTK.
07:49:30 <dcoutts> we don't require a top level doAllYourGraphicsInsideThis :: IO a -> IO a
07:49:51 <dcoutts> we run the main loop, but that doesn't cover everything
07:50:05 <dcoutts> and callbacks & exceptions don't mix well.
08:01:20 <musasabi> it would be nice to include a string with the dynamic exceptions.
08:08:00 <Heffalump> or just have the Show instance for Dynamic be cleverer
08:08:24 <Heffalump> oh, maybe that's not feasible without wrapping up the Show dictionary in the type.
08:08:30 <Heffalump> s/type/value/
08:18:26 <musasabi> Heffalump: well one can print the name of the type.
08:19:05 <musasabi> Heffalump: but having an error message so that a generic "Control.Exception.catch print" will work well might make sense.
08:27:36 <Heffalump> musasabi: printing the name of the type is just a fix to the top-level RTS handler
08:27:48 <Heffalump> for the latter I guess you'd want to add a field to DynException
08:28:02 <Heffalump> which is presumably what you were suggesting
08:30:38 <musasabi> yes, I am suggesting that.
08:30:55 <musasabi> printing the typename is fixing the show instance.
08:31:22 <SimonRC> hi
08:37:26 <roconnor> @dijn ((((A->B)->A)->A)->B)->B
08:37:26 <lambdabot> Maybe you meant: dice dict djinn
08:37:33 <roconnor> @djinn ((((A->B)->A)->A)->B)->B
08:37:33 <lambdabot> f a = a (\ b -> b (\ c -> a (\ _ -> c)))
08:37:47 <roconnor> @pl f a = a (\ b -> b (\ c -> a (\ _ -> c)))
08:37:48 <lambdabot> f = ap id (flip id . (. const))
08:38:06 <SimonRC> @help djinn
08:38:06 <lambdabot> Generates Haskell code from a type.
08:38:06 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
08:39:03 <tennin> what does that function do?
08:39:05 <roconnor> @type ap
08:39:06 <lambdabot> Not in scope: `ap'
08:39:10 <roconnor> @type Monad.ap
08:39:11 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
08:39:34 <SimonRC> @djinn (Monad m1, MonadPlus m2) => m2 [m1 a] -> m1 (m2 a)
08:39:34 <lambdabot> Cannot parse command
08:39:50 <SimonRC> hmm
08:40:08 <roconnor> I think djinn mainly works on polymorphic types
08:40:28 <roconnor> using -> tuples Either, perhaps Maybe
08:40:52 <roconnor> but I'm not sure
08:41:19 <SimonRC> @djinn m2 [m1 a] -> m1 (m2 a)
08:41:20 <lambdabot> -- f cannot be realized.
08:41:42 <roconnor> @djinn a -> Either a b
08:41:43 <lambdabot> f = Left
08:45:25 * dcoutts notices that Lemmih has landed 13 patches in the hIDE repo!
08:46:54 <Lemmih> eh?
08:48:31 <Lemmih> david@debian:~/coding/haskell/hIDE$ darcs changes --xml-output | grep "author='lemmih@gmail.com'" | wc -l
08:48:34 <Lemmih> 34
08:49:08 <icbt> hi, lemmih
08:54:24 <gour> icbt: capital 'L'
08:54:58 <Cale> nicks aren't case sensitive :)
08:55:17 <gour> Cale: but Lemmih is :-)
08:55:22 <Cale> hehe
08:55:33 <SimonRC> Are you too lazy to use tab completion?
08:56:01 <SimonRC> All I have to do to get Lemmih i to hit L<Tab>.
08:56:15 <Saulzar> Typing a name out in full is probably less lazy :)
08:57:58 <Shinji_san> hello, i have some homework to do.. and need a little help.. :( can someboy help me? (sorry for my bad english)
08:58:01 <vincenz> Saulzar: it's mentally lazy
08:58:38 <Cale> Shinji_san: sure
08:58:45 <Cale> what do you need help with?
09:01:18 <Shinji_san> thanx! :) i have to programm a funktion fpr cube-Encryption.. i have already the codecube funktion.. but i can't programm the funktion to decode..
09:01:27 <Shinji_san> > codeCube :: String -> Int -> String
09:01:27 <Shinji_san> > codeCube txt i = [txt!!i' | k <- [0..i-1], i' <- [k, k+i..((length(txt))-1)]]
09:01:28 <lambdabot>  Not in scope: `codeCube'
09:01:28 <lambdabot>  parse error on input `='
09:02:02 <Shinji_san> codeCube :: String -> Int -> String
09:02:02 <Shinji_san> codeCube txt i = [txt!!i' | k <- [0..i-1], i' <- [k, k+i..((length(txt))-1)]]
09:02:35 <vincenz> let codeCube  txt i = [txt!!i' | k <- [0..i-1], i' <- [k,k+i..((length(txt))-1)]]
09:02:35 <SimonRC> Shinji_san: what's the problem?
09:02:38 <vincenz> > let codeCube  txt i = [txt!!i' | k <- [0..i-1], i' <- [k,k+i..((length(txt))-1)]]
09:02:39 <lambdabot>  parse error on input `}'
09:02:53 <SimonRC> vincenz: nonono, that was what lambdabot said
09:03:04 <dcoutts> xerox, http://haskell.org/~duncan/cairo/clock.png
09:03:08 <vincenz> > let codeCube txt i = [txt!!i' | k <- [0..i-1], i' <- [k,k+i..(length(txt)-1)]]
09:03:08 <lambdabot>  parse error on input `}'
09:03:15 <vincenz> yick
09:05:45 <Shinji_san> the function codeCube codes a String.. but now i have to wrote a funktion which decode the string.. to the original string.. 
09:06:43 <Shinji_san> codeCube "abcdef" 2 => "acebdf"
09:07:07 <Shinji_san> decodeCube  "acebdf" 2 => "abcdef"
09:07:16 <SimonRC> hmm
09:07:29 <astrolabe> Ah
09:08:07 <Lemmih> > let codeCube txt i = [txt!!i' | k <- [0..i-1], i' <- [k,k+i..(length(txt)-1)]] in codeCube "abcdef" 2
09:08:08 <lambdabot> "acebdf"
09:08:48 <SimonRC> > let codeCube txt i = [txt!!i' | k <- [0..i-1], i' <- [k,k+i..(length(txt)-1)]] in codeCube (codeCube "abcdef" 2) 3
09:08:49 <lambdabot> "abcdef"
09:08:52 <SimonRC> tada!
09:09:26 <araujo> Hello!!
09:09:44 <SimonRC> Of course, this only works if i and (length txt)/i have no common factor. :-(
09:09:59 <musasabi> Is there a way to test out a modified base-package with GHC ?
09:10:36 <Shinji_san> yeah.. sadly.. :(
09:16:09 <astrolabe> let codeCube txt i = [txt!!i' | k <- [0..i-1], i' <- [k,k+i..(length(txt)-1)]] in codeCube (codeCube "abcd" 2) 2
09:16:23 <astrolabe> > let codeCube txt i = [txt!!i' | k <- [0..i-1], i' <- [k,k+i..(length(txt)-1)]] in codeCube (codeCube "abcd" 2) 2
09:16:24 <lambdabot> "abcd"
09:16:26 <eivuokko> musasabi, Doesn't it work like every other package?
09:16:35 <Lemmih> > let comparing fn a b = compare (fn a) (fn b); decodeCube txt i = [ txt!!n | (n,_) <- sortBy (comparing snd) (zip [0..] [ i' | k <- [0..i-1], i' <- [k,k+i..(length(txt)-1)]])] in decodeCube "acebdf" 2
09:16:36 <lambdabot> "abcdef"
09:17:22 <astrolabe> It works as long as (length txt) % i <- [0,1]
09:18:19 <musasabi> eivuokko: ghci panics on me when trying to do that.
09:18:45 <eivuokko> musasabi, Hmm, ok.  Curious.
09:18:53 <musasabi> http://youzen.b2.fi/~musasabi/panic.txt
09:19:02 <dcoutts> Lemmih, your project management code looks sensible
09:19:40 <Lemmih> musasabi: GHCi can't work without a base.
09:20:52 <xerox> dcoutts: wow
09:20:58 <xerox> I just came back home
09:21:00 <Lemmih> dcoutts: I'll ignore the GUI issues for now and just make it work well with haskell-sense.
09:21:09 <dcoutts> Lemmih, that's fine
09:21:31 <xerox> dcoutts: how many lines is it? :)
09:22:09 <dcoutts> xerox, so far it's less than 150
09:22:20 <xerox> dcoutts: the shadow is part of the cairo rendering?
09:22:26 <dcoutts> xerox, yes
09:22:46 <dcoutts> if you've got xcompmgr running then it's a transparent window
09:23:19 <dcoutts> just like the original screenshot: http://macslow.mine.nu/shots/cairo-clock-2.png
09:24:17 <musasabi> Lemmih: ok, I'll try with plain ghc.
09:24:21 <dcoutts> xerox, and in that case the shadow is cast on the background windows. :-)
09:24:36 <xerox> yeah :)
09:25:01 <xerox> well, nice work dcoutts, I was thinking of trying ;)  bbl
09:25:43 <dcoutts> xerox, I needed a couple extra gtk functions bound
09:26:07 <dcoutts> it's drawing directly onto the window, rather than a canvas widget
09:26:19 <dcoutts> gtk2hs needed an extra function to be able to do that
09:27:31 <musasabi> Lemmih: GHC panics too (but with different reason): http://youzen.b2.fi/~musasabi/panic.txt
09:29:40 <musasabi> is this something worth reporting ?
09:39:15 <SyntaxNinja> There's a #haskell' channel, btw :)
09:39:34 <astrolabe> What does "Inferred type is less polymorphic than expected" mean?
09:46:09 <SimonRC> hi
09:47:00 <tromp_> it expected a->a but you gave it Int->Int
09:47:21 <SyntaxNinja> astrolabe: I think it means that you claimed that the function (or whatever) had a rather polymorphic type, but when the type system looked it it, it found that it's actually less polymorphic, as in tromp_'s example.
09:50:38 <astrolabe> hmmm thanks
09:51:50 <jip> hm... out of curiosity, what function, except id, is a->a?
09:53:32 <neologism> succ?
09:53:36 <eivuokko> Last part of seq is.
09:54:19 <jip> @type succ
09:54:20 <lambdabot> forall a. (Enum a) => a -> a
09:54:38 <wilx> @hoogle a->a
09:54:39 <lambdabot> Prelude.id :: a -> a
09:54:39 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
09:54:39 <lambdabot> Control.Parallel.par :: a -> b -> b
09:57:06 <astrolabe> @where lisppaste2
09:57:06 <lambdabot> I know nothing about lisppaste2.
09:57:33 <astrolabe> lisppaste2
09:57:40 <astrolabe> nope
09:57:51 <astrolabe> @paste
09:57:52 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
09:57:53 <eivuokko> lisppaste2: help
09:57:54 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
09:58:00 <astrolabe> thanks
10:02:39 <roconnor> @type (\_ -> error "Boom)::(a->a)
10:02:39 <lambdabot> lexical error in string/character literal
10:02:43 <roconnor> @type (\_ -> error "Boom")::(a->a)
10:02:44 <lambdabot> forall a. a -> a
10:03:12 <roconnor> it's a little forced I admit.
10:03:17 <roconnor> @type (error "Boom")::(a->a)
10:03:18 <lambdabot> forall a. a -> a
10:04:30 <lisppaste2> astrolabe pasted "Inferred type is less polymorphic than expected" at http://paste.lisp.org/display/15937
10:10:22 <kevind> @type block
10:10:23 <lambdabot> Not in scope: `block'
10:10:59 <astrolabe> @hoogle block
10:10:59 <lambdabot> Control.Exception.block :: IO a -> IO a
10:10:59 <lambdabot> Control.Exception.BlockedOnDeadMVar :: Exception
10:10:59 <lambdabot> Control.Exception.BlockedIndefinitely :: Exception
10:12:51 <jip> argh this is really annoying
10:12:52 <palomer> less polymorphic than expected sounds like a compiler bug
10:14:27 <jonkri> hi all
10:14:45 <Shinji_san> THY a lot astrolabe :D
10:14:48 <icbt> hi, jon
10:14:52 <jonkri> icbt, :o)
10:14:54 <Shinji_san> THX
10:15:39 <astrolabe> Shinji_san: I didn't help
10:16:01 <astrolabe> Looks at what Lemmih said.
10:16:39 <Shinji_san> sorry .. thx to Lemmih! ;)
10:17:02 <astrolabe> @karma+ Lemmih
10:17:02 <lambdabot> Lemmih's karma raised to 8.
10:20:13 <jonkri> hey! i want some karma as well! :-)
10:24:33 <astrolabe> jonkri: All you need to do is solve my problem http://paste.lisp.org/display/15937  :)
10:25:04 <roconnor> @hoggle [a]->[[a]]
10:25:05 <lambdabot> Data.List.inits :: [a] -> [[a]]
10:25:05 <lambdabot> Data.List.tails :: [a] -> [[a]]
10:25:05 <lambdabot> Data.List.group :: Eq a => [a] -> [[a]]
10:26:21 <jonkri> astrolabe, well... ok :-) i've only had to lessons
10:27:01 <astrolabe> You'd better not look then.  I'm sure it's a bad example.
10:27:14 <palomer> @type (:[])
10:27:15 <lambdabot> forall a. a -> [a]
10:27:56 <kevind> hrm, how do you diagnose a seg fault in haskell
10:28:02 * SimonRC goes
10:28:20 <shapr> kevind: with the FFI?
10:28:49 <kevind> not using FFI
10:29:40 <kevind> I get a bunch of linking errors when I try to compile and a seg fault when i try using ghci
10:30:00 <roconnor> astrolabe: what happens if you use Either ParseError ParseOut -> m (Maybe(Maybe Int,GTPResponse)) as the type for getResponse?
10:30:31 <jip> yes!
10:30:40 <shapr> kevind: I don't think that should happen.
10:31:02 <shapr> kevind: Did you install a binary ghc package? and maybe forgot some supporting libs?
10:31:06 <shapr> Any more error details?
10:31:40 <kevind> i compiled it a few days ago, I am new to haskell so I could be missing something obvious
10:31:54 <kevind> when I compile I get linking errors, mostly to do with STM
10:31:57 <roconnor> kevind: scatter Debug.Debug.trace throughout your code?
10:31:59 <kevind> I am using ghc 6.4.1
10:32:04 <roconnor> @type Debug.Debug.trace
10:32:04 <lambdabot> Couldn't find qualified module.
10:32:04 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
10:32:04 <lambdabot> \\)?
10:32:12 <roconnor> @hoogle trace
10:32:12 <lambdabot> Debug.Trace.trace :: String -> a -> a
10:32:12 <lambdabot> Debug.Trace.putTraceMsg :: String -> IO ()
10:33:38 <astrolabe> roconner: "Ambiguous constraint 'Monad n'     At least one of the forall'd type variables mentioned by the constraint must be reachable from the type after the '=>'  "
10:33:52 <shapr> kevind: What platform and version?
10:34:28 <kevind> ghc 6.4.1 on linux 2.6.10
10:34:40 <roconnor> remove the 'Monad n =>' too
10:35:45 <jonkri> astrolabe, hehe
10:37:18 <astrolabe> roconner: Inferred type is less polymorphic than expected    Quantified type variable 'm' is unified with 'm1' which is mentioned in the environment:....  Very like the first error.
10:37:30 <jethr0> shapr: when did you say you wanted to release the next TMR?
10:38:30 <roconnor> oh interesting.
10:38:55 <roconnor> There are some cases in haskell 98 where you cannot give a type by hand. ... I wonder if this is one of those cases.
10:39:30 <astrolabe> That is interesting.  And strange
10:39:43 <astrolabe> Is it mentioned in the report?
10:39:57 <roconnor> I vaguely recall reading it somewhere, but I don't remember where.
10:41:21 <shapr> jethr0: first of the next month
10:41:31 <shapr> kevind: which distro?
10:41:34 <kevind> gentoo
10:41:49 <shapr> kevind: Asked on #gentoo-haskell?
10:41:57 <kevind> nope
10:42:02 <jethr0> thx
10:42:09 <shapr> #gentoo-haskell can probably help you most.
10:42:23 <kevind> k thx
10:44:30 <icbt> anyone else here using the SDL binding?
10:45:11 <jip> icbt: yeah
10:45:39 <icbt> jip, which version are you using?
10:46:01 <jip> icbt: Lemmih's
10:46:07 <jonkri> in "(*) :: Num a => a -> a -> a", what does "Num a" mean?
10:46:17 <icbt> which lemmih's version are you using
10:46:35 <jip> icbt: darcs from about 3 weeks ago
10:46:53 <roconnor> jonkri: It means that the type a is restricted to a type that implements the Num interface
10:47:12 <jonkri> roconnor, oh, ok
10:47:19 <jonkri> how do i query the bot for docs about num?
10:47:20 <icbt> jip, did you have any problem building it?
10:47:49 <jip> icbt: nope. there was only a small glitch where i had to fix the package after it was installed
10:48:14 <roconnor> in GHCi you can type :info Num
10:48:19 <roconnor> > :info Num
10:48:19 <lambdabot>  parse error on input `:'
10:48:24 <roconnor> ah well
10:48:37 <icbt> i am getting failures on hsc2hs, are you using 6.4 or 6.4.1?
10:48:59 <jip> icbt: 6.4.1
10:49:21 <icbt> hmmm, i am using the binary 6.4.1 distro off the ghc page
10:49:28 <jonkri> roconnor, ah, that's nice
10:49:45 <jonkri> sek (-10) works but not sek -10, cannot infer instance. what's going on?
10:50:19 <wilx> Doesn't it parse as sek (-) 10?
10:50:43 <jonkri> wilx, ah, ok, what type is "-" then?
10:50:58 <wilx> @type (-)
10:50:59 <lambdabot> forall a. (Num a) => a -> a -> a
10:51:27 <palomer> > - 10
10:51:28 <lambdabot> -10
10:51:33 <palomer> how does that work?
10:51:47 <roconnor> you can, of course, also do :type (-) in ghci
10:52:04 <wilx> @type -10
10:52:05 <lambdabot> forall a. (Num a) => a
10:52:06 <kevind> @hoogle newTVarIO
10:52:06 <lambdabot> No matches found
10:52:07 <icbt> and you are using 1.2.9, jip?
10:52:07 <wilx> @type - 10
10:52:08 <lambdabot> forall a. (Num a) => a
10:52:09 <roconnor> sek -10 parses as (sek)-(10)
10:52:21 <jip> icbt: yep, what operating system?
10:52:25 <jonkri> thanks
10:52:33 <roconnor> I think everyone hates this.
10:52:34 <icbt> mac 10.4.3
10:52:35 <palomer> how is -10 grammatical?
10:52:58 <icbt> i was almost positive that i have gotten sdl to work back in 6.22 days
10:54:09 <jip> sorry i don't know shit about macs
10:54:11 <shapr> palomer: Hey, ever since you mentioned it to me, I've been totally infatuated with proof programming. Thanks for introducing me to a new idea!
10:54:15 <jip> except that mac os is shit :P
10:54:21 <shapr> Hey, be nice.
10:54:28 <shapr> Remember E-Prime
10:54:34 <jip> o-o
10:55:06 <jip> let us all give a minute of silence to E-Prime
10:55:09 <shapr> http://c2.com/cgi-bin/wiki?EprimeLanguage
10:56:18 <astrolabe> What is proof programming?
10:56:26 <shapr> astrolabe: Generating code from a proof.
10:56:53 <shapr> Afaict, it's not viable yet, and probably won't be up to Haskell's level of real worldness for a few more years.
10:58:00 <shapr> roconnor: Did I already ask you about anonymous distributed processing substrates?
11:01:25 <roconnor> I don't think so
11:03:22 <edwinb> Do you mean Coq-style extraction of programs from proofs, or something else?
11:03:44 <shapr> edwinb: Yeah, NuPRL and Coq are the only tools I'm aware of that can do that.
11:03:57 <shapr> Do you know of more?
11:04:04 <palomer> ml implies not not ml
11:04:08 <edwinb> No, I just wondered if it was something I hadn't heard of...
11:04:23 <edwinb> I believe there are 'real world' uses of the Coq tool, but you wouldn't want to write an entire system that way.
11:04:28 <edwinb> Unless you're Xavier Leroy ;)
11:04:44 <palomer> I see Coq as extracting proofs from programs
11:05:00 <edwinb> "extracting" implies automation though.
11:05:02 <kevind> but it doesnt, it extracts programs from proofs
11:05:33 <astrolabe> This stuff is quite cool http://www.math.pitt.edu/~thales/flyspeck/index.html
11:05:57 <shapr> I want a system that produces decent code from a proof. Like, I fiddle with the assistant to find the proof, and it produces code that's faster than that of the average Python newbie.
11:06:02 <palomer> kevind: not from my perspective
11:06:09 <roconnor> astrolabe: this is my field of research.
11:06:23 <kevind> proofs are total, programs are not necessarily
11:06:32 <astrolabe> roconnor: wow!  What exactly?
11:06:33 <palomer> programs in Coq are total
11:06:34 <edwinb> I'd hope that Epigram programs could be that good eventually.
11:06:35 <kevind> proofs \subset programs
11:07:02 <roconnor> Specifically I'm working on an implementation of exact real arithmetic inside the Coq proof assistent.
11:07:05 <palomer> shapr: that's purely a compiler optimization problem, no?
11:07:31 <roconnor> @type Fix
11:07:32 <lambdabot> Not in scope: data constructor `Fix'
11:07:35 <roconnor> @type fix
11:07:36 <lambdabot> Not in scope: `fix'
11:07:43 <roconnor> @hoogle fix
11:07:44 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
11:07:44 <lambdabot> Graphics.UI.ObjectIO.StdIOCommon.Fix :: ItemLoc
11:07:44 <lambdabot> Control.Monad.ST.Lazy.fixST :: (a -> ST s a) -> ST s a
11:07:45 <palomer> roconnor: does your system have equality and a few functions?
11:07:58 <astrolabe> roconnor: frustrating.  I have questions, but I'm going out now :(
11:08:10 <roconnor> palomer: you mean Coq?
11:08:23 <roconnor> astrolabe: I'm around regularly
11:08:31 <palomer> roconnor: well, your implementation of exact real arithmetic
11:09:20 <roconnor> palomer: My goal is to implement the functions in Haskell's Floating class.
11:09:48 <palomer> oh, that shouldn't be a problem
11:09:50 <palomer> it's decidable:o
11:10:24 <roconnor> palomer: excluding Eq and Show
11:10:35 <palomer> no equality?
11:10:39 <roconnor> palomer: and division will require a proof of non-zeroness
11:10:53 <palomer> but it's decidable with equality
11:10:56 <roconnor> palomer: no eq: real -> real -> bool
11:11:14 <roconnor> palomer: but an eq: real -> real -> Type
11:11:23 <palomer> roconnor: eh?
11:11:45 <roconnor> palomer: equality is not decidable if you can take limits of convegent sequences.
11:12:18 <roconnor> real -> real -> Type is a dependent Type.
11:12:21 <astrolabe> But is >= decidable?
11:12:41 <roconnor> astrolabe: >= is also undecidable.
11:12:53 <palomer> roconnor: you have limits of convergent sequences?
11:13:13 <astrolabe> Cauchy sequences?
11:13:22 <roconnor> palomer: I will define transindental functions using limits
11:13:34 <palomer> ahh, so you will have limits
11:13:38 <astrolabe> Arrrgh gotta go.
11:13:38 <roconnor> `fast-converging' cauchy sequences.
11:13:47 <palomer> and what does your eq function represent?
11:13:48 <roconnor> http://r6.ca/FewDigits/
11:13:53 <roconnor> my Haskell prototype
11:14:21 <roconnor> palomer: eq x y is a type that is inhabitited if x=y, otherwise it is an empty type.
11:15:04 <palomer> and how do you use eq in your code?
11:16:03 <palomer> eq boggles my mind
11:16:30 <edwinb> it's really quite useful if you have dependent types...
11:16:38 <jonkri> i read the following definition: data Rank = Numeric Integer | Jack | Queen | King | Ace deriving Show"... what's "Numeric Integer"?
11:17:06 <jip> which style is preferred for names of functions: nounVerb or verbNoun?
11:17:15 <roconnor> palomer: it is used to enforce preconditions, and derive postconditions
11:17:45 <palomer> roconnor: oh, so Type is the condition that these two reals are equal?
11:17:52 <roconnor> for example, div a b p will require that p have the type (eq a b)->Empty
11:18:06 <edwinb> Type is just the type of types. eg Int :: Type.
11:18:11 <roconnor> palomer: I think that is right.
11:18:11 <jonkri> or: where can i read about "Numeric Integer"
11:18:17 <palomer> what's the type of div?
11:18:56 <kevind> don't you mean (eq 0 b) -> Empty
11:19:19 <roconnor> div : forall (a b:real), ((eq 0 b)->Empty) -> real
11:19:27 <roconnor> kevind: yes you are right
11:19:54 <roconnor> div : real -> forall (b:real), ((eq 0 b)->Empty) -> real
11:20:09 <palomer> don't you mean p will have the type (eq b 0) -> Empty
11:20:14 <roconnor> basically (a -> b) is syntatic sugar for (forall x:a, b)
11:20:27 <roconnor> palomer: yes you are right
11:20:53 <palomer> oh, I see, I like this approach very much
11:21:14 <kevind> its a big pain to program with such proofs though
11:21:41 <palomer> so eq takes 2 elements and returns all proofs of their equality
11:21:51 <edwinb> you do end up having to pass proofs around, but usually the initial proof is quite simple
11:21:56 <palomer> but this isn't decidable
11:22:13 <shapr> roconnor: Anyway, I was going to ask you about this, http://www.scannedinavian.com/2005-12-05.html
11:22:33 <kevind> theres lots of cases that will need lemmas to make things easier, like: ((eq 0 b) -> Empty) -> ((eq a 0) -> Empty) -> Times a b c -> ((eq 0 c) -> Empty)
11:22:56 <roconnor> shapr: I'm not sure I know much
11:23:34 <kevind> and there always new slightly different cases that you wish you had lemmas for
11:23:41 <roconnor> palomer: eq take 2 elements and returns a type of all proofs of their equality.  That is a very good way to read this.
11:23:48 <edwinb> in the case of div, you can always have some wrapper real -> real -> maybe real that handles the divide by zero error for you
11:24:15 <roconnor> edwinb: equality is undecidable, including testing if equal to 0
11:24:32 <edwinb> that makes the conversion check between two reals undecidable then doesn't it?
11:24:36 <kevind> that could also add unnecessary runtime overhead
11:24:48 <edwinb> you can't say eq b 0 if it's undecidable...
11:25:02 <palomer> roconnor: right, but finding that type is undecidable
11:25:03 <roconnor> in my Haskell prototype dividing by 0 results in non-termination
11:25:09 <edwinb> kevind: so does checking for divide by zero in a normal language...
11:25:22 <kevind> yes, but if you have proofs there is no runtime overhead
11:25:28 <roconnor> edwinb: eq b 0 is not a Bool, rather a Type
11:25:28 <kevind> just static checking
11:25:44 <edwinb> yes, I know. How do you check that the value for b is instantiated by 0?
11:25:55 <edwinb> if equality is undecidable, so is conversion, surely...
11:26:04 <kevind> you define proofs inductively
11:26:09 <palomer> edwinb: whenever a function needs (eq b 0), you need to pass a proof that b is equal to 0
11:26:10 <kevind> the programmer is required to supply them
11:26:51 <palomer> kevind: though I'm sure you can ask coq to do it for you
11:26:55 <edwinb> and how does the typechecker check that, say, \b:float. \a:float. (refl a b) 0 0 is okay?\
11:27:06 <edwinb> the zeroes may have come from a complex computation...
11:27:10 <edwinb> sorry, refl a.
11:27:19 <roconnor> eq a b = forall n, abs (approx (a-b) (1/n)) <= (1/n)
11:27:39 <roconnor> that is the definition of equality for real numbers
11:27:44 <edwinb> okay, I see.
11:28:24 <palomer> roconnor: I'm guessing that <= is of type real -> real -> Type, right?
11:28:44 <roconnor> in this case <= is of type rational -> rational -> Type
11:28:52 <edwinb> I still don't get how it can be undecidable at run time but decidable at compile time though...
11:28:53 <roconnor> sorry for overloading my operators
11:29:08 <roconnor> approx : real -> rational -> rational
11:29:17 <kevind> so can you actually code up such things in Haskell, using GADTs or somesuch, or do you need real dependent types?
11:29:20 <roconnor> n:nat
11:29:27 <palomer> roconnor: ok, and how would <= be defined? why not have <= be of type rational -> rational -> bool ?
11:29:55 <palomer> kevind: no, GADTs don't give you that much, really
11:30:32 <roconnor> a <= b = is_LE (compare a b)
11:30:42 <pesco> palomer: Because a the Type represents a proof.
11:30:46 <roconnor> compare : rational -> rational -> Comparision
11:30:52 <pesco> (I guess?) ;)
11:31:09 <roconnor> Comparison has three elements LT, EQ, GT (like in Haskell)
11:31:26 <roconnor> is_LE LT = ()
11:31:33 <roconnor> is_LE EQ = ()
11:31:40 <roconnor> is_LE GT = Empty
11:31:56 <palomer> () is True and Empty is False ?
11:32:00 <roconnor> ... maybe this explaination is needlessly complex
11:32:13 <roconnor> palomer: yes, I was trying to use Haskell names
11:32:26 <roconnor> palomer: Coq would actualy use True and False.
11:32:50 <palomer> is_LE : Comparison -> Type ?
11:32:55 <roconnor> yes
11:33:02 <palomer> woo, this is fun
11:33:06 <palomer> the lack of recursion bothers me though
11:33:14 <palomer> couldn't you get around this by a proof of termination?
11:33:19 <roconnor> it has structural recursion
11:33:25 <palomer> which would be automatically supplied if you only use structural recursion
11:33:26 <roconnor> and structural co-recursion
11:34:06 <roconnor> If you can create a well-founded relation that proves your function terminates, then you can write the function in Coq.
11:34:19 <roconnor> ... granted not every well-founded relation can be defined in Coq
11:34:19 <kevind> hmm, so can you extract non-terminating programs from a coq proof?
11:34:30 <palomer> kevind: no
11:34:44 <palomer> roconnor: so you'll be missing out!
11:34:46 <roconnor> kevind: extracted co-recursive functions may never terminate
11:34:48 <edwinb> extraction is just removal of stuff which isn'[t used at run-time, really.
11:35:20 <roconnor> I should just plainly say co-recursive functions may never terminate.
11:35:32 <palomer> eh?
11:35:57 <palomer> coq functions may never terminate?
11:35:59 <edwinb> Coq-extracted co-recursive functions would at least produce a new constructor. Which is the point, of course.
11:36:15 <roconnor> palomer: co-recursive functions generate co-inductive types
11:36:25 <roconnor> for instance, streams are a co-inductive type
11:36:48 <roconnor> coq functions are always productive.
11:37:12 <roconnor> but may not terminate if you try an normalize a co-inductive type.
11:37:22 <kevind> hmm, so you you extract an equality function on reals which may not terminate?
11:37:44 <roconnor> kevind:  it would terminate if the numbers are unequal
11:37:53 <roconnor> keveind: and never termiante if they are equal
11:38:11 <kevind> ok, I did not know you could do such things with coq
11:38:18 <kevind> i thought all extracted functions were terminating
11:38:57 <roconnor> if you never use co-recursion, all functions will terminate.
11:39:32 <roconnor> if the function signature doesn't have coinductive types in it, the function will always terminate.
11:39:43 <roconnor> even if it uses coinductive types in the middle of processing.
11:39:58 <kevind> ahh
11:40:07 <xerox> Why are you so fond on Coq, if I may ask?  :-)
11:40:15 <roconnor> I'm not sure the exact cases when functions may not terminate.
11:40:24 <kevind> okay, kinda like a pertiality monad?
11:40:28 <roconnor> xerox: it is my research.
11:40:43 <kevind> err, partiality
11:41:05 <roconnor> kevind: I'm not familiar with that monad.
11:42:22 <kevind> its basically just a monad to encapsulate general recursion
11:42:51 <roconnor> co-recursion is not general recursion
11:42:52 <xerox> That one with Mu in the newtype?
11:43:03 <roconnor> co-recursive function must always be productive
11:48:51 <jip> does sin function call the c library math.h sin function?
11:51:48 <roconnor> @type find
11:51:49 <lambdabot> Not in scope: `find'
11:51:53 <roconnor> @type List.find
11:51:54 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
12:06:54 <_Codex> What are the most common properties of functions?
12:07:33 <wilx> What functions?
12:07:50 <_Codex> functions in general. I mean things like "funcion call".
12:08:28 <wilx> Functions usually return? Have parameters? 
12:08:44 <PerlJam> functions function.
12:08:57 <PerlJam> Just like at conjunction junction.
12:09:08 <Muad_Dibber> functions abstract over something else.
12:10:06 <Muad_Dibber> and for every property in here you most likely can program a counterexample.
12:11:43 <roconnor> functions are eliminated by applying them to arguments
12:11:52 <roconnor> functions are created by lambda abstraction
12:12:06 <Muad_Dibber> so
12:12:15 <Muad_Dibber> a function without arguments inst a function?
12:12:20 <Lor> This Haskell isn't ML thingy is bloody ingenious.
12:12:41 <gzl> what Haskell isn't ML?
12:12:47 <Lor> See ltu.
12:13:00 <roconnor> A function that won't accept arguments isn't a function.
12:13:32 <xerox> It would be a value
12:14:12 <Lor> It's so obvious in hindsight, really: you can treat a strict heap-allocated object as a non-strict one by making its tag be the code pointer that a non-strict caller would jump to.
12:14:32 <Lor> So the data acts as plain data and as an environment simultaneously, depending on whether you call it from strict or non-strict code.
12:15:28 <Heffalump> wdym "as an environment"?
12:15:29 <Lor> Of course the strict tag dispatch becomes a bit harder since you can't have simple compile-time constants any more as the value is actually a code pointer, but I think linkers can handle this.
12:16:00 <Lor> An ordinary heap, allocated object, e.g. a pair is: (tag,val1,val2) okay?
12:16:15 <Lor> An ordinary closure is (code,var1,var2...).
12:16:26 <Heffalump> I don't quite follow why you can't just treat the thing as an evaluated think, and have the strict side point to the data, and the lazy side point to the bit that says "this has been forced"
12:16:45 <Heffalump> ah, I see.
12:16:47 <Lor> Now just define the tag for a pair to be the code that would pass val1 and val2 to the caller.
12:17:39 <Lor> You get strict-lazy interoperability at zero cost.
12:18:31 <Lor> Well, all right, it doesn't work for unboxed values.
12:18:40 <Heffalump> but those have to be strict anyway
12:18:49 <Heffalump> (I was about to point that out, then I realised that)
12:19:01 <_Codex> for example, "instance Arrow (->)" means that >>> :: a b c -> a c d -> a b d is property of functions :)
12:19:06 <Heffalump> however, why does the tag for a strict language have to be the size of a code pointer?
12:20:04 <Lor> In general it wouldn't need to be, but here it's needed for this to work.
12:20:13 <Heffalump> so it's not zero cost
12:20:14 <Lor> I'm not sure I understood the question.
12:20:24 <Lor> Ah, there's a space overhead, yeah.
12:20:47 <Lor> (Although it's not too uncommon to have tags the size of a full word)
12:21:13 <Heffalump> alignment and stuff, yeah
12:21:15 <Lor> But the space overhead is no bigger than what objects cost at the non-strict side, anyway.
12:21:46 <Heffalump> can't you implement lazy objects as 1 bit followed by either data or code pointer?
12:22:39 <Lor> Sure, but then you need to dispatch on that, which incurs a run-time cost.
12:26:22 <Lor> Golly, it seems like I'm finally starting to get a bit interested in CS again.
12:26:47 <dcoutts> xerox, this cairo clock rocks!
12:26:48 <Lor> After ICFP I have just been studying linguistics, literature and philosophy...
12:27:03 * araujo would like to take philosophy
12:27:05 <dcoutts> xerox, and unlike the version written in C this one should be easy to make more effecient
12:27:06 <araujo> dcoutts, hiya!
12:27:10 <dcoutts> hi araujo 
12:27:15 <xerox> dcoutts: it indeed does :-)
12:27:26 <dcoutts> xerox, the C version is really sloooo
12:27:37 * araujo preparing enough caffeine to learn gtk2hs
12:27:51 <xerox> dcoutts: uh!
12:27:53 <dcoutts> xerox, because it redraws everything every second. And it's using some rather heavy techniques to do the picture
12:28:02 <dcoutts> lots of gradients & transparency etc
12:28:09 <dcoutts> xerox, what it should do...
12:28:39 <Lor> Oh, bloody hell! It works the other way too: when a lazy thunk gets evaluated and it updates itself to memoize the value, it simply _becomes_ a representation of a strict value.
12:29:05 <dcoutts> xerox, it should render the background and forground (which are static) to intermediate surfaces. It should then composite the background then draw the clock hands and then composite in the forground.
12:29:08 <Lor> So you get lazy->strict translation simply by forcing the entire thunk. There's no need to copy anything.
12:29:16 <dcoutts> xerox, I bet it'll be much faster then.
12:29:29 <xerox> dcoutts: indeed.
12:29:29 <Lor> This is ut-ter-ly cool.
12:30:56 <Lor> Ah, no, it may need to copy when in-place updating isn't possible. But still it's as cheap as it can conceivably be.
12:31:40 <Heffalump> doesn't it becoming a representation of the strict value follow from what you said initially?
12:33:07 <Lor> Well, if you think it was obvious then good for you. I didn't figure out that the representation for strict values would be exactly the same as the representation for evaluated thunks until the text pointed it out.
12:34:08 <pesco> Any Gtk2Hs experts here? How do I send an external signal to the event loop (to tell it to redraw something)?
12:34:44 <dcoutts> pesco, widgetQueueRedraw
12:34:54 <Heffalump> fair enough
12:35:07 <Heffalump> I spotted the paper last night but only had time to read the end of it, none of the details.
12:35:21 <pesco> dcoutts: Thanks.
12:35:26 <dcoutts> http://haskell.org/gtk2hs/docs/current/Graphics-UI-Gtk-Abstract-Widget.html#v%3AwidgetQueueDraw
12:35:44 <pesco> Yeah, found it.
12:36:12 <dcoutts> pesco, what are you working on? animation?
12:36:34 <pesco> dcoutts: Graph visualization, still.
12:36:54 <dcoutts> pesco, oh yeah, interactive?
12:37:27 <pesco> dcoutts: Only as in "send new edges to stdin and they get integrated immediately".
12:37:49 <dcoutts> pesco, ah ok
12:38:22 * dcoutts is porting a clock app to Gtk2Hs+cairo
12:38:26 <dcoutts> http://haskell.org/~duncan/cairo/clock.png
12:38:38 <araujo> dcoutts, yay!
12:38:47 <pesco> Hey cool.
12:41:24 <fatbrain> dcoutts: nice clock
12:42:32 <fatbrain> dcoutts: will you share when you'r done? :)
12:43:15 <dcoutts> fatbrain, I'll add it to the Gtk2Hs demo collection. It's GPL. I ported it from an existing cairo app written in C.
12:43:39 <sieni> dcoutts: nice picture of you: http://www.sadowsky.com/media/artists/coutts/coutts.jpg
12:44:01 <dcoutts> sieni, hah. That's not me. :-)
12:44:02 <fatbrain> dcoutts: ok
12:44:14 <sieni> Oh :-)
12:44:19 <dcoutts> sieni, he's the "other" Duncan Coutts on the internet. :-)
12:44:32 <dcoutts> sieni, but I beat him on google now :-)
12:44:56 <dcoutts> he's a canadian base player or something like that. He's got fan sites.
12:45:01 <Cale> dcoutts: do you play an instrument? Perhaps you could join his band :)
12:45:08 <dcoutts> hah ha
12:45:13 <Heffalump> doesn't look that different, really ;-)
12:45:23 <pesco> dcoutts: widgetQueueDraw generates an expose event?
12:45:25 * dcoutts scowles at Heffalump 
12:45:31 <dcoutts> pesco, yeah
12:45:45 <araujo> dcoutts, so you've got more fans than him now!!!
12:45:51 <Heffalump> are scowles like oules?
12:45:54 <pesco> Good. :)
12:46:11 <dcoutts> Heffalump, heh, anyway, I've got more hair than him
12:48:17 <Heffalump> http://urchin.earth.li/photopub/display?photo=/users/ganesh/banana/3419&thumb=640x640 # the real dcoutts
12:48:36 <dcoutts> heh
12:49:15 <slava> what does it mean when people say that a type system with negation supports continuations?
12:49:15 * dcoutts tries to find pic of Heffalump 
12:49:36 <Heffalump> there's still one on my Comlab page, I think.
12:50:00 <dcoutts> Heffalump, I'm looking for a specific one.... :-)
12:50:09 <Heffalump> does it have anything to do with trains?
12:52:43 <dcoutts> got it
12:52:45 <dcoutts> http://dhcp0533.gradacc.ox.ac.uk:8080/~duncan/Heffalump.jpg
12:53:09 <Heffalump> goodgood, no trains in sight.
12:53:28 * dcoutts wonders if Heffalump is a closet train spotter
12:53:40 <Heffalump> yes, but that's not the point.
12:56:22 <Lor> Hm, slava wasn't patient enough. I would have answered.
13:11:12 <dcoutts> xerox, Cale, araujo, pesco, fatbrain: updated clock pic: http://haskell.org/~duncan/cairo/clock.png
13:11:22 <dcoutts> now to make it faster than the C version...
13:11:57 <araujo> wow!
13:12:04 <roconnor> ... could use some dithering. ... or maybe my screen sucks
13:12:59 <fatbrain> nice
13:13:07 <araujo> @karma+ dcoutts 
13:13:08 <lambdabot> dcoutts's karma raised to 8.
13:18:14 <jonkri> take care guys
13:31:08 <pesco> Aw great, my do-nothing Gtk2Hs program uses full CPU power!
13:31:27 <dcoutts> pesco, that's less than great :-)
13:31:31 <dcoutts> what's going on?
13:31:41 <dcoutts> are you queueing redraw events all the time?
13:31:42 <pesco> dcoutts: If only I knew!
13:32:14 <dcoutts> that'd be my first guess
13:33:12 <pesco> dcoutts: Oh, ah, heh, no, I think something else is looping...
13:34:02 <pesco> Ah right, the layouter isn't checking for optimality of the layout (because it's not layouting anything yet *g*).
13:49:19 <ulfdoz> giniIndexPartition t = (liftM (*p1) $ giniIndex (fst t)) `liftM2 (+)` (liftM (*p2) $ giniIndex (snd t))
13:49:54 <pesco> dcoutts: Oh my god, it's WORKING!
13:50:00 <ulfdoz> Despite the fact, that it is ugly. Where is the syntax error. ghc complains about '(' at the string "liftM2 (+)"
13:50:14 <dcoutts> pesco, well done
13:50:43 * pesco bathes in the amazement over his first GTK program since at least three years ago.
13:50:57 <pesco> dcoutts: Thanks. ;)
13:51:17 <dcoutts> pesco, what does it look like? :-)
13:51:35 <pesco> dcoutts: It's like the Drawing.hs example, just without drawing! :)
13:51:49 <dcoutts> pesco, heh
13:52:11 <pesco> dcoutts: I still have to fill in those ugly routines that are supposed to do the ACTUAL WORK.
13:52:29 <pesco> But at least it won't go to the bit-bucket now. :)
13:54:11 <pesco> Heh "assertion G_IS_OBJeCT(object) failed". Chrrr.
13:55:00 <pesco> Oh well, enough work for today. Time to eat something.
13:55:17 <ulfdoz> resorting it from infix-notation to postfix, it seems to work.
13:55:31 <ulfdoz> err, prefix-notation.
14:08:15 <dcoutts> xerox, success!
14:08:41 <dcoutts> xerox, the original C version of the cairo clock took 36% CPU on my machine
14:08:50 <dcoutts> xerox, my new Haskell port takes 1%
14:08:58 <dcoutts> with no visual degredation
14:09:15 <musasabi> how is the loc?
14:09:31 <Heffalump> can you explain the difference?
14:10:03 <dcoutts> musasabi, about 300 for me at the moment, 450 for C
14:10:24 <jyp> you seem to be working very hard these days dcoutts ... keep it up :)
14:10:42 <dcoutts> Heffalump, it's not a C/Haskell thing obviously, it just being cleverer about which parts of the image are static/dynamic
14:10:54 <lifesdkver0_1> anyone using darcs on dreamhost?
14:10:59 <Heffalump> ah, right.
14:11:13 <Heffalump> are you using your partial evaluator?
14:11:16 <dcoutts> Heffalump, instead of redrawing the entire thing each frame I split it into three layers which get composited together
14:11:19 <dcoutts> Heffalump, na
14:11:32 <dcoutts> that'd be a bit too tricky
14:12:04 <dcoutts> we're changing the operations of the program, it's only meaning preserving at a very high level
14:12:35 <jyp> that's the kind of optimizing I regard the most highly
14:12:45 <dcoutts> it turns out that 2 of the layers are static, and so we only need to redraw one layer each time
14:13:13 <dcoutts> we draw the other two layers into intermediate surfaces and composite them all together at the end
14:13:25 <dcoutts> compositing is relatively cheap
14:13:55 <jethr0> i like to have unit tests and "code" in different files. is there a way of doing this with hunit without making exporting everything in your whole module?
14:13:59 <Heffalump> once you've structured it like that, wouldn't automatic partial evaluation be feasible?
14:14:21 <jyp> btw, anyone has compiled ghc from darcs recently?
14:14:31 <Heffalump> albeit not easy
14:14:43 <eivuokko> jyp, I have
14:14:45 <dcoutts> Heffalump, the transformation that introduces an intermediate static layer is not trivial
14:14:53 <jyp> I get conflict: module `System.Directory.Internals'
14:14:53 <jyp>     belongs to the current program/library and also to package base-1.0
14:14:57 <Heffalump> fair enough
14:15:59 <dcoutts> Heffalump, I see what you're getting at, but I think the system would need to know quite a lot of the algebra of image compositing.
14:16:02 <jethr0> dcoutts: what partial evaluator is heffalump talking about? is it specialized to your project or a general one?
14:16:13 <dcoutts> jethr0, a general Haskell one
14:16:23 <dcoutts> it's my PhD project
14:16:27 <jethr0> can i get that somewhere :)
14:16:31 <dcoutts> not yet :-)
14:17:13 <eivuokko> jyp, well..wierd, dunno :)
14:17:13 <jethr0> i'd love to fool around with some partial evaluation in haskell at some point. it seems like such a cool optimization possibility
14:17:43 <jethr0> anyone doing unit testing in haskell frequently?
14:17:46 <Heffalump> dcoutts: hmm, never heard of anyone doing algebra of image compositing in Haskell.
14:18:01 <Heffalump> I'm sure it's far too hard.
14:18:07 <dcoutts> Heffalump, pan!
14:18:08 <shapr> jethr0: I do.
14:18:15 <jyp> eivuokko: I know I got that one quite a few times; and it usually fixes itself;
14:18:15 <jethr0> i like to have unit tests and "code" in different files. is there a way of doing this with hunit without making exporting everything in your whole module?
14:18:30 <jethr0> s/making//
14:18:33 <Heffalump> dcoutts: next you'll be telling me someone at MSR did it.
14:18:58 <dcoutts> Heffalump, and it's still under an M$ license!
14:19:01 <jyp> eivuokko: though I'm far from satisfied of this situation
14:19:04 <shapr> jethr0: Not really. Plus it's better for refactoring if you only test your exposed interfaces.
14:19:11 <eivuokko> jyp, Uhhuh, might be worth investigating.
14:19:16 <Heffalump> yeah :-(
14:19:17 <shapr> @seen conal
14:19:18 <lambdabot> I saw conal leaving #haskell 25 days, 19 hours, 18 minutes and 27 seconds
14:19:18 <lambdabot> ago, and I have missed 17 days, 22 hours, 22 minutes and 26 seconds since
14:19:18 <lambdabot> then.
14:19:24 <Heffalump> though the general idea is still feasible, of course.
14:19:27 <shapr> Conal said he's working on a new Pan.
14:19:28 <jethr0> shapr: yes, but i like to test internal functions too (white box testing). so that's not really supported by hunit, is it?
14:19:36 <dcoutts> shapr, cool
14:20:46 <jethr0> shapr: so how do you unit test? have all the test at the bottom of your module?
14:25:43 <shapr> jethr0: Nah, I use test driven development where my tests are my specification as well.
14:26:45 <jethr0> shapr: so do i, but how do you code and tests look in your file? i like to separate them somehow and was wondering how you deal with this?
14:26:59 <shapr> I have done white box testing with QuickCheck, but unit testing internals doesn't profit much in my experience.
14:27:35 <shapr> Step zero of the TDD cycle is refactor mercilessly with your next bit of functionality in mind.
14:28:02 <shapr> I do separate them...
14:28:04 * shapr gets demo code
14:28:07 <jethr0> thx
14:28:37 <jethr0> i'm actually a great fan of the test-first methodology...
14:29:37 <edwinb> I wish I could be that disciplined... it sounds completely sensible.
14:29:48 <jethr0> especially with OOD i was never content with my design, sweated over it for weeks and never ever started to program. OR i became so annoyed with OOD that i hacked together some devilish hack
14:30:09 <shapr> Me too, it's a great way to put pressure on your interfaces beforehand. TDD gets me more YAGNI, and more design at exactly the right time.
14:30:15 <jethr0> but TDT seems to accomodate my thinking and development better, somehow
14:30:33 <jyp> @wtf YAGNI
14:30:35 <lambdabot> No match for "YAGNI".
14:30:42 <jethr0> you ain't gonna need it
14:31:02 <jethr0> programming some feature that fits in your design but will most likely never be used
14:31:26 <jethr0> @wtf
14:31:29 <jyp> @wtf+ YAGNI  you ain't gonna need it
14:31:29 <lambdabot> Unknown command, try @listcommands.
14:31:36 <jyp> @wtf-add YAGNI  you ain't gonna need it
14:31:36 <lambdabot> Unknown command, try @listcommands.
14:31:40 <jyp> gnn
14:36:02 <SamB> @help wtf
14:36:03 <lambdabot>  @help <command> - ask for help for <command>
14:36:36 <jyp> Apparently it doesn't exist... lambdabot picks up some other command
14:36:47 <jyp> by error-correction
14:38:55 <shapr> jethr0: Here you go, you can get the benefit of my emacs color theme - http://www.scannedinavian.com/~shae/Test_TutorRing.hs.html
14:39:08 <shapr> jethr0: Though if that's too painful I can give you the plain text version =)
14:39:35 <jyp> LSD abuse?
14:39:38 <jyp> ;p
14:39:45 * shapr grins
14:39:49 <jethr0> na, that fine, thx a lot. just wondering how you do things *g*
14:40:33 <shapr> Notice the Local Variables at the bottom... means I can hit F12 to build & run my unit tests.
14:41:00 <JohnMeacham> musasabi: ah, yeah that is a known problem. I have a 'type-analysis' pass which cleans up those unusued instances, but it is disabled by default for some reason or other I can't remember.
14:41:38 <jethr0> nice
14:41:48 <shapr> JohnMeacham: Any thoughts on JHC on ARM?
14:41:58 <edwinb> ooh, what did you use to get the syntax highlighted html?
14:42:15 <Heffalump> doesn't JHC produce portable C?
14:42:32 <shapr> edwinb: htmlize-buffer
14:42:41 <Heffalump> so in theory it should just work (TM)
14:42:44 <shapr> edwinb: But hscolour is niftier
14:42:55 <JohnMeacham> shapr: it should just work assuming you have gcc.
14:43:03 <JohnMeacham> shapr: and a more-or-less unixy environment.
14:43:41 <shapr> edwinb: hscolour looks like  http://www.scannedinavian.com/2005-12-21.html
14:43:47 <edwinb> righto. Just want to generate some less boring webbed up code...
14:44:02 <edwinb> oh, that's nice
14:44:04 <edwinb> cheers!
14:47:21 <musasabi> JohnMeacham: that does not seem to help. (tried with -f type-analysis)
14:48:05 <shapr> JohnMeacham: Thanks for the info
14:50:16 <JohnMeacham> musasabi: yeah, i meant 'really disabled' :) as in I commented out the bit of code that actually used it.
14:50:29 <musasabi> ah
14:50:53 <jyp> Since the expert is around... I can't seem to get jhc to compile the even the factorial function... Is it a known thing or am I out of sync ?
14:51:13 <JohnMeacham> musasabi: but I should be able to reenable it relativly easily after work.
14:51:26 <musasabi> mmok
14:51:30 <JohnMeacham> jyp: did you grab the newest patches that switch back to the old typechecker?
14:51:48 <jyp> yes
14:51:56 <JohnMeacham> jyp: how does it fail?
14:52:28 <jyp> JohnMeacham: just a minute while I recompile
14:52:43 <jyp> ... fact.hs, not jhc :)
14:53:28 <jyp> JohnMeacham: App: arguments do not match: (App {expFunction = @eval, expArgs = [1], expType = N},[&N],N)
14:53:43 <jyp> follows what seems to be low-level GRIN or something
14:53:57 <jyp> and then ... user error (There were type errors!)
14:54:36 <JohnMeacham> jyp: interesting. that means a grin->grin transformation failed. can you email me your test case. I certainly have compiled things more complicated before, but I might have introduced a new bug recently.
14:54:55 <JohnMeacham> or a grin->grin transformation did not preserve typing more accuratly.
14:56:08 <jyp> fact 0 = 1
14:56:08 <jyp> fact n = n * fact (n-1)
14:56:08 <jyp> main = print $ fact 6
14:56:49 * jyp can't seem to be able to use his irc client.
14:56:59 <jyp> Though I guess the message passed.
14:57:07 <JohnMeacham> jyp: hmm.. well, that should work. I will test it out later. I am sure it has something to do with my unboxing code. it looks like it is trying to evaluate an unboxed number.
14:58:44 <JohnMeacham> jyp: okay, I have copied it into my test cases.
14:59:40 <jyp> JohnMeacham: thanks :)
14:59:57 <JohnMeacham> jyp: if you have a large amount of time, you can try a compiler with --ignore-ho, but the only reason that might change things is if you built your ho-files with an earlier buggy version.
15:00:48 <jyp> I'm pretty sure I have done make clean-ho after pulling latest patches
15:01:03 <jyp> though it might be some other sort of weirdness
15:01:03 <ulfdoz> *InfoMeasures> giniIndex [11..100] >>= show
15:01:04 <ulfdoz> "-Infinity"
15:01:24 <ulfdoz> arg, I begin to doubt in myself
15:01:45 <ulfdoz> Ok, it's my mothers birthday, which explains a lot.....
15:02:20 <dcoutts> xerox, I've only got one missing feature of my clock now, and I need your help.
15:02:58 <dcoutts> xerox, I've got it to drag & resize, but not resizing the static layers yet.
15:03:34 <dcoutts> you can drag is around the screen with the left mouse button and resize it with the middle button
15:04:18 <dcoutts> xerox, but I need to draw the background & forground into persistent intermediate surfaces
15:04:35 <dcoutts> xerox, at the moment I just allocate a fixed size surface for the life of the program
15:04:55 <dcoutts> xerox, but obviously that will not do, I need something more flexible
15:05:22 <dcoutts> and allocating them temporarily with withImageSurface/withSimilarSurface etc is not ok either.
15:05:40 <dcoutts> xerox, what we need is GC managed surfaces
15:07:23 <musasabi> ForeignPtr ?
15:08:08 <dcoutts> musasabi, yeah probably
15:08:21 <Trixsey|Laptop> http://nanosync.org/open1/view.php?id=19
15:13:02 <dcoutts> xerox, actually it looks like it'd be ok to have a GC managed image surface since one can manually release the image data associated with the surface using surfaceFinnish
15:13:16 <dcoutts> so it allows one to do manual memory management, but safely
15:14:10 <dcoutts> the only bit that would hang around for a while waiting for the GC to free it would be the surface struct itself but that is very small in comparison to the image data it holds. so it'd be ok.
15:18:23 <nuffer> okay
15:18:32 <nuffer> so I get the error: multiple declarations of some function
15:18:38 <nuffer> and I have multiple definitions
15:18:41 <nuffer> but each for a different pattern
15:18:44 <nuffer> what's the deal with that?
15:19:16 <tromp_> pls show a paste
15:19:28 <nuffer> sure, one sec
15:20:44 <nuffer> http://rafb.net/paste/results/G5OLpD22.html
15:22:33 <nuffer> (anyone?)
15:24:19 <Heffalump> you mispelt the name once
15:24:34 <Heffalump> and you have to keep all the clauses of a definition together
15:24:35 <lennart> on line 6
15:25:46 <kevind> Is there anyway to get a backtrace when stack overflow happens?
15:25:50 <nuffer> ahhh
15:25:52 <nuffer> that explains a lot
15:25:54 <nuffer> thanks
15:26:34 <Heffalump> kevind: sadly not.
15:26:52 <kevind> hrm, crap
15:27:01 <Cale> kevind: we can take a look at the code though
15:28:08 <kevind> heh, I think ill give it a hard look first, I'm sure its something stupid and I don't want to embarrass myself
15:28:20 <Cale> Stack overflows happen when evaluation of some expression is delayed for long enough while it's built up so that it becomes incredibly large before it's ever needed.
15:28:26 <Cale> for example
15:28:34 <Cale> > iterate (+1) 0 !! 1000000
15:28:35 <lambdabot> Exception: stack overflow
15:29:05 <Cale> what that's doing is building a huge expression like ((((...(0 + 1) + 1) + 1) ... ) + 1)
15:29:20 <Heffalump> isn't that just !! recursing repeatedly?
15:29:21 <Cale> with 1000000 ones, and then trying to evaluate it
15:29:29 <Cale> no, the problem isn't with !!
15:30:01 <Cale> the stack overflow happens right after !! is done
15:30:40 <Cale> when it has to push those million or so entries onto the stack all at once
15:30:43 <Heffalump> I don't believe that, because you have to traverse to some large indexed element before you will get any blowup at all
15:31:04 <Heffalump> you have to start evaluating !! to have any problem at all
15:31:06 <Cale> > take 10 $ iterate (1:) [] !! 1000000
15:31:07 <lambdabot> [1,1,1,1,1,1,1,1,1,1]
15:31:11 <Heffalump> IM get some way with evaluating it
15:31:27 <Cale> > length $  iterate (1:) [] !! 1000000
15:31:29 <lambdabot> 1000000
15:31:42 <Heffalump> ok, fair enough
15:32:30 <Cale> the way to fix it is to rewrite iterate to seq the application of f
15:33:52 <Heffalump> > let iterate' f x = (\v -> x:iterate f v) $! f x in iterate' (+1) 0 !! 1000000
15:33:52 <Cale> > let iterate' f x = let y = f x in y `seq` x : iterate' f y in iterate' (+1) 0 !! 1000000
15:33:53 <lambdabot> Exception: stack overflow
15:33:54 <lambdabot> 1000000
15:34:02 <Heffalump> doh
15:34:06 <Heffalump> no, not doh.
15:34:15 <Cale> > let iterate' f x = let y = f x in y `seq` x : iterate' f y in iterate' (+1) 0 !! 1000000
15:34:16 <lambdabot> 1000000
15:34:16 <Heffalump> oh, doh.
15:34:19 <Heffalump> I didn't recurse.
15:34:25 <Heffalump> > let iterate' f x = (\v -> x:iterate' f v) $! f x in iterate' (+1) 0 !! 1000000
15:34:26 <lambdabot> 1000000
15:34:28 <Cale> yeah
15:34:30 <Heffalump> ok :-)
15:34:59 <Cale> of course, with more structured data types, you'll need deeper sequencing
15:36:00 <kevind> ghci tells me to use -K<size> to increase the stack, then when I do it says its an unrecognized option
15:36:11 <Cale> (since seq will only force the top level constructor, and you'll get a stack overflow when evaluating one of the components)
15:36:21 <Cale> +RTS -K<size>
15:36:27 <Cale> It's an RTS option
15:37:12 <Cale> (+RTS turns on parsing of RTS options after that point in the parameter list)
15:38:45 <Cale> you can try increasing the stack, but the likelihood is that you can make your program more efficient by either adding some strictness annotations, redesigning the data flow a bit, or perhaps by simply compiling with optimisations.
15:40:15 <cakoose> I have a program that parses a file into a list of "Entry" objects.  I'm doing the openFile/parse in a "bracket" call.  When I print out the length of the [Entry] list inside the bracket call, I get 222.  When I use the value returned from bracket, I get 0.  Any idea why this could be happening?
15:40:39 <kevind> I'm sure its a bug
15:40:42 <Heffalump> are you using hGetContents?
15:40:45 <Heffalump> or similar
15:40:51 <Cale> You're using lazy IO
15:41:06 <cakoose> Yes, hGetContents
15:41:15 <Heffalump> don't close the file yourself, then
15:41:15 <Cale> You're not intended to close the file yourself
15:41:24 <cakoose> oh, ok
15:41:25 <Cale> it'll be closed when you're done with it
15:41:25 <SyntaxNinja> <-- star / thorn-in-the-side of HWN this week ;) thanks dons
15:47:22 <Lemmih> @seen icbt
15:47:22 <lambdabot> icbt is in #haskell. Last spoke 4 hours, 54 minutes and 23 seconds ago.
16:04:56 <kevind> hmm, I seem to be getting a stack overflow when I foldWithKey over a map with just 1 entry.  Any idea what could cause that?
16:05:13 <kevind> A Data.Map
16:05:37 <kevind> Its folding a non-recursive function too
16:06:32 <SamB> @type Data.Map.foldWithKey
16:06:33 <lambdabot> forall b a k. (k -> a -> b -> b) -> b -> Data.Map.Map k a -> b
16:08:18 <SamB> > M.foldWithKey (\k v l -> (k, v):l) [] (M.fromList [("x", 1)])
16:08:19 <lambdabot> [("x",1)]
16:08:32 <SamB> nope, no idea!
16:08:38 <SamB> whats the function?
16:09:24 <kevind> it performs an STM action that alters a Map under a TVar
16:09:45 <SamB> what does it look like, though?
16:10:40 <kevind> (foldWithKey (\t -> \x@(p,(thid,fin,wait)) -> \res ->
16:10:40 <kevind> 				res >> removeDone t p 
16:10:40 <kevind> 			       ) (return ()) cset)
16:11:03 <SamB> that looks horrid!
16:11:08 <SamB> no wonder it doesn't work.
16:11:16 <kevind> why
16:11:46 <SamB> well, things that look horrid tend to be difficult to understand ;-)
16:12:31 <kevind> well, I'm kinda new to Haskell, so that doesnt look so bad to me
16:12:40 <kevind> I think I understand it :)
16:12:46 <SamB> the indentation might be messed up
16:13:39 <kevind> ahh, well the paste does not reflect the true indentation, I think the indentation is right
16:14:00 <SamB> yeah, thats what I meant ;-)
16:14:42 <SamB> lets see.
16:14:48 <SamB> so, this is like:
16:16:01 <SamB> foldWithKey (\t x@(p,_) res -> res >> removeDone t p) (return ()) cset
16:17:16 <kevind> yes
16:18:04 <SamB> I have to ask why you aren't doing something more like
16:18:26 <eivuokko> Hehe, I made some small bindings to Windows debug-api, ghci as debugger :)
16:19:27 <palomer> well, it turns out that type inference with algebraic datatypes is decidable
16:19:37 <SamB> mapM (\(t, (p, _)) -> removeDone t p) (M.fromList cset)
16:19:38 <palomer> but the haskell developers still want to force us to use annotations
16:20:15 <SamB> palomer: which kind of datatypes again?
16:20:38 <cakoose> palomer: GADTs?
16:20:41 <SamB> Algebraic datatypes are already infererd fine... do you mena GADTs?
16:20:42 <palomer> yeah
16:21:00 <palomer> I say we lead a mutiny
16:21:07 <cakoose> Is there a new paper?
16:21:15 <palomer> no, this has always been known
16:21:23 <cakoose> Oh...
16:21:30 <SamB> they should put in inference but still have GHC refuse to compile the program without annotations ;-)
16:21:46 <palomer> SamB: that would be silly
16:21:54 <palomer> people claim that type inference is intractable
16:21:56 <palomer> hogwash
16:22:13 <SamB> palomer: no it wouldn't! that way you'd know what to put in the annotations!
16:22:35 <palomer> oh, so it would say "please annotate with blah blah"
16:22:38 <palomer> well, yeah
16:22:49 <palomer> top level annotations, at least
16:22:52 <dons> palomer, write a paper. even better... an implementation..
16:23:00 <kevind> um, doesnt the use of GADT's generally involve polymorphic recursion?
16:23:06 <SamB> of course just top-level...
16:23:18 <SamB> kevind: yeah!
16:23:26 <kevind> thats undecidable tho
16:23:35 <palomer> yeah, force annotations for recursive polymorphic bindings
16:24:15 <SamB> someone even thought that one of okasaki's uses of polymorphic recursion in a data-type definition *was* a GADT...
16:24:41 <SamB> though of course it was just an ordinary ADT which works even in ML
16:25:16 <Philippa> kevind: we've long since taken the 'niftier types through annotation' path
16:25:17 <kevind> well, you can write such datatypes in ML, but you cant actually use them since there is no polymorphic recursion
16:25:27 <Philippa> which's led to things like the proposal I just made on the haskell' list
16:25:45 <kevind> yes, yes, I was just questioning the assertion that type inference with GADT's is decidable
16:25:58 <SamB> kevind: I'm betting that you can ;-)
16:26:07 <Philippa> full inference, no. Inferring the usual H-M things in their presence, yes
16:26:26 <SamB> there was nothing phantom about these types, mind you
16:26:46 <kevind> well you can't in SML, I can tell you that for sure
16:26:48 <Philippa> bah, no ghost in the shell
16:27:38 <SamB> kevind: I'm not sure which ML it was, but okasaki was definately using ML for it.
16:27:44 <kevind> recursing over the datatypes he defined requires polymorphic recursion
16:27:56 <kevind> yeah, but he explicitly said that his example wont type-check or compile
16:28:00 <kevind> err, examples
16:28:08 <SamB> oh? where?
16:28:22 <kevind> in the chapter where he talks about the funky datatypes
16:28:35 <kevind> near the end of the book
16:28:46 <kevind> plus, I've tried it
16:29:06 <kevind> SML wont complain when you define the datatype, but you can't write any functions that recurse over them
16:29:14 * SamB looks
16:29:20 <palomer> seriously, inference with GADTs reduces to unification under mixed prefix with implication and having the existential quantifiers head first
16:30:16 <palomer> this is no big deal
16:30:50 <palomer> http://cristal.inria.fr/~regisgia/mini.shtml
16:31:25 <kevind> yeah, but you still probably need anotations for most of the interesting uses
16:31:34 <palomer> nope
16:31:56 <palomer> just annotate your polymorphically recursive functions
16:32:00 <palomer> and that's it
16:32:23 <Philippa> which are most of the interesting uses, no?
16:32:41 <kevind> GHC kinda cheats by putting existentials only in datatypes
16:32:43 <palomer> yeah, but that's no big deal
16:33:02 <kevind> so you really have annotations for packing and unpacking existentials
16:33:24 <kevind> which would be nice to have inferred
16:34:00 <musasabi> Philippa: about the type metavariable thing, allowing "_a" could cause problems with existing programs.
16:34:22 <musasabi> Philippa: as "_a" is a valid type variable name, but "_" is not - thus "_" is safe.
16:34:27 <palomer> you'd annotate the really interesting functions, and leave the other functions alone (the ones that still need to be annotated)
16:34:49 <palomer> that would still need
16:35:05 <musasabi> > let x :: _a ; x = x in ()
16:35:06 <lambdabot> ()
16:35:14 <Philippa> musasabi: how is it a valid type variable name currently?
16:35:21 <musasabi> like that.
16:35:23 <Philippa> feel free to float a better syntax for that btw
16:35:35 <Philippa> er, I didn't think _ was currently allowed in them?
16:35:47 <Philippa> oh well, $a anyone? :-)
16:35:51 <palomer> meta variables?
16:35:54 <musasabi> plain _ is not allowed.
16:36:10 <Philippa> are there any real uses in the wild?
16:36:14 <palomer> Philippa: where's your proposal?
16:36:15 <musasabi> Philippa: the naming issue can be circumvented with suitable type declarations.
16:36:17 <SamB> would anyone use _a as a type variable name?
16:36:21 <SamB> I wouldn't!
16:36:29 <SamB> it is absolutely disgusting!
16:36:31 <palomer> sml uses 'a and ''a and friends
16:36:45 * musasabi uses it in a few places for a type variable that is meant to be ignored.
16:36:56 <Philippa> yeah, but sml's doing ordinary variables rather than metavariables so that'd confuse SMLers
16:37:21 <Philippa> ("meta" in that it's not part of the type system per se, it refers to "some type here")
16:37:46 <Philippa> it's probably a misnomer once it's actually in the type system, but it's essentially the same concept as the metavariables you see in type system specs
16:38:00 <Philippa> musasabi: 'k. That'll be why you spotted it then. Post on the list?
16:38:38 <musasabi> Philippa: I don't feel that strongly about it, just wanted to point it out.
16:38:46 <palomer> meta variable = bound variable?
16:38:48 <Philippa> do so on the list too :-)
16:39:07 <musasabi> (and I am so tired that I would probably make another embarassing blunder like the polymorphic record update )
16:39:13 <Philippa> palomer: one we hope'll get bound to something. Currently they'd be unquantified (even implicitly)
16:39:33 <Philippa> just post "_a is currently a legitimate name for a type variable" then
16:40:10 <palomer> yeah, I think we should make the type system super expressible, but have the type inference algorithm just give up
16:40:22 <palomer> when it can't infer
16:42:01 <kevind> but then you lose meaningful error messages
16:42:29 <palomer> righto, you'd have to have the compiler tell you what types it has infered
16:42:45 <palomer> for top level functions at least
16:42:50 <Philippa> potentially you get incredibly meaningful one if you have the option for the compiler to dump out all its typings and a good viewer...
16:43:22 <palomer> yeah, my point exactly
16:43:23 <Philippa> as in, enough detail to work out what it inferred where, what it knew at the point it fell over and thus what it needed to know
16:43:39 <kevind> sounds like a lot of work
16:43:44 <Philippa> if you want to take typeful programming seriously, ultimately that's a tool that needs to exist
16:43:54 <Philippa> I've certainly had a few situations where I could've used it
16:44:18 <Philippa> sure, but when you've got a type the size of a novella you're in for a lot of work anyway
16:44:20 <eivuokko> The problem is that inference doesn't fail at one place, so that information has possibly a lot of presentations.
16:44:24 <kosmikus> Philippa: just looked at your answer. I think that in a predicative system, we shouldn't instantiate free variables to polytypes. That's asking for problems in situations such as "_a -> _a". If you have only pure underscores, it might work.
16:44:58 <kevind> I dont like the idea of incomplete type inference as a core part, it might be a helpful part of an IDE to help you find the right annotations though
16:45:47 <kosmikus> no, that wouldn't help.
16:46:25 <palomer> but haskell already requires annotations in certain places
16:46:27 <Philippa> kosmikus: sounds like a plan
16:46:40 * Philippa would prefer to mostly discuss stuff on-list as she thinks more before typing that way
16:46:57 <Philippa> also, it stops a #haskell cabal taking over the standard :-)
16:47:27 <jethr0_> @seen shapr
16:47:28 <lambdabot> shapr is in #ScannedInAvian and #haskell. Last spoke 1 hour, 8 minutes
16:47:28 <lambdabot> and 33 seconds ago.
16:48:07 <kosmikus> many haskell' people are on #haskell anyway, but I agree that anything substantial should be posted to the ml.
16:49:02 <musasabi> kosmikus: aren't the "pure _ + type" and "metavars" just different syntax?
16:49:03 <jethr0_> Philippa: are you aware of a migration from hawiki to haskellwiki?
16:50:15 <musasabi> (if metavars are not allowed to scope over multiple type declarations)
16:51:49 <kosmikus> musasabi: in principle, you're right. but that only holds if metavars can only be instantiated to monotypes, because the same restriction applies to parameters of type synonyms.
16:52:01 <musasabi> point
16:52:36 <SamB> so why doesn't ML support polymorphic recursion?
16:53:07 <palomer> because it makes type inference undecidable
16:53:18 <palomer> check out  the milner-mycroft calculus
16:53:19 <SamB> that is a very silly reason ;-)
16:53:26 <Philippa> jethr0_: er, vaguely
16:54:03 <Philippa> kosmikus: any "there's a problem" stuff definitely should, I'd rather not be expected to relay it
16:54:08 <jethr0_> hmm
16:54:29 * Philippa hasn't done much on hawiki
16:54:38 <Philippa> I'm more of a TMR type
16:54:57 <musasabi> at least GHC allows this:
16:54:58 <musasabi> type T x = x -> x
16:54:58 <musasabi> type T2  = T (forall a. a)
16:55:23 <musasabi> with -fglasgow-exts
16:55:30 <kosmikus> Philippa: I still think the proposal is a good idea. I wanted this for a long time, and it doesn't break much. We just need to make it more explicit. Even if it doesn't make it into Haskell', I think it has a good chance to get into GHC sooner or later.
16:55:45 <jethr0_> Philippa: i am just trying to find out which of the many wikis is currently "head" :)
16:56:32 <musasabi> yes, the general idea is very nice.
16:56:57 <musasabi> many times I need to write something about the type sig and the whole thing is tedious.
16:56:58 <kosmikus> SamB: I think that both ML and Haskell had a philosophy in the beginning that it should be possible to do complete type inference. Haskell has gradually abandoned this philosophy, ML less so.
16:57:31 <SamB> hasn't ML gone kinda stagnant lately?
16:57:35 <shapr> jethr0_: you called?
16:58:07 <jethr0_> shapr: not really. spj asked if i could/wanted to migrate my tutorial to /haskellwiki/. and i am now wondering if/how to do that
16:58:17 <palomer> SamB: which ML?
16:58:22 <jethr0_> i.e. whether this was a short-term or a medium-term issue :)
16:58:23 <kosmikus> I don't know much about the ML community.
16:58:29 <SamB> well, which ML hasn't?
16:58:31 <kosmikus> anyway, good night.
16:58:46 <palomer> ocaml hasn't been stagnant
16:58:50 <jethr0_> and i thought you might know :)
16:58:53 <palomer> sml has
16:58:58 <SamB> what have they been doing?
16:59:03 <Heffalump> isn't that kind of the point of SML? :-)
16:59:13 <SamB> its a pretty stupid point, then
16:59:30 <Philippa> not really. Standard => Stagnating :-)
16:59:42 <shapr> jethr0_: copy it over I guess
16:59:51 <Heffalump> Standard => Stable
17:00:09 <Philippa> but ocaml's the only other ML with enough mindshare to be a 'standard'
17:00:09 <jethr0_> shapr: k
17:00:12 <SamB> haven't they been on the SAME standard for like ever?
17:00:25 <palomer> 1997 
17:00:26 <shapr> I'll lock hawiki pretty soon.
17:00:32 <Heffalump> so, on the subject of that libraries post to haskell', what sort of size will the standardised libraries be? Kitchen sink or lean and mean?
17:00:43 <lollan> hello nobody have a website to learn Haskell ? i found many but quite weird i think
17:00:45 <SamB> shapr: haskellwiki has a different format, though, right?
17:01:06 <shapr> I think so, I'm not sure.
17:01:28 <Heffalump> where is it?
17:01:28 <nuffer> so um
17:01:30 <Philippa> Heffalump: discuss on list? Hopefully not anywhere near as lean as Haskell 98
17:01:34 <lollan> sorry i just read the topic lol
17:01:36 <nuffer> how do I convert an Integer to an Int?
17:01:38 <jethr0_> shapr: what do you mean "lock"? hopefully not this week :)
17:01:39 <Heffalump> I just wanted a general idea of what people thought.
17:01:48 <Heffalump> @type fromIntegral
17:01:49 <lambdabot> forall b a. (Num b, Integral a) => a -> b
17:02:28 <shapr> jethr0_: I mean that I'll set it read only soon.
17:02:30 <SamB> hmm. standard libs?
17:02:33 <nuffer> thanks
17:02:37 <nuffer> Heffalump: 
17:02:42 <SamB> we have to have standard libs now?
17:03:02 <Heffalump> well, you have to have a small standard lib, because it's needed to make the language work
17:03:09 <Heffalump> e.g. how can you have do notation without a Monad lib
17:03:17 <Heffalump> but Haskell 98 has quite a bit more than that.
17:03:19 <jethr0_> shapr: ah, but not _really_ soon, right?
17:03:24 <SamB> yeah.
17:03:32 <Philippa> Heffalump: go find Isaac's announce somewhere. It's on clf, haskell and haskell-cafe lists etc etc, and includes URLs
17:03:46 <SamB> hmm... but should the libs be in the same standard?
17:03:54 <Philippa> I will be v.annoyed if the ST monad isn't in there. I think standardised monad transformers should be, too
17:03:54 <shapr> jethr0_: I dunno, next week or so? You'll still be able to see the source of the page of course.
17:04:02 <SamB> ST is annoying anyway.
17:04:04 <Heffalump> I did follow all the links, I didn't spot anything that made it clear what the answer to that question was, but I might have missed something.
17:04:09 <Heffalump> SamB: probably not.
17:04:14 <Philippa> SamB: good question. Haskell' needs to define /some/ standard library though, and possibly not Haskell 98's
17:04:16 <Heffalump> I was just asking, not saying there had to be a big one :-)
17:04:29 <ihope> I have some CPS code that doesn't work.
17:04:35 <jethr0_> shapr: ok, 'coz i'm doing some big changes right now and wouldn't want to leave the THtutorial page in shambles when you lock *g*
17:04:56 <Philippa> I'm in two minds about things like parsing and prettyprinting, some standardisation on networking, binary IO and stuff like that is IMO essential
17:05:03 <SamB> hmm, so you could have the minimal core in the Language report...
17:05:30 <palomer> we should have incremental standards
17:05:33 <SamB> and than a companion Library report/tarball thingy or something
17:05:33 <Heffalump> so what are the benefits of standardising libraries?
17:05:36 <ihope> main = (getLine >>=) (\x -> ($ head x)) (\x -> (putChar x >>=)) return
17:05:39 <SamB> maybe a darcs repo
17:05:45 <ihope> What's wrong with this is obvious enough.
17:05:46 <Heffalump> SamB: Haskell98 report has two sections, a language and a libraries report.
17:05:58 <shapr> jethr0_: don't worry, you can always ask me to unlock it :-)
17:06:25 <ihope> Make it work! *pouts*
17:06:33 <SamB> well, I'm saying that the library report could be updated seperately from (i.e., more often than) the language report ;-)
17:06:59 <jethr0_> :)
17:07:55 <Heffalump> ihope: sorry, what do you mean?
17:08:14 <Heffalump> SamB: depends on what the purpose of standardised libraries is
17:08:35 <Heffalump> if it's to make programs be long-lived, then changing the libraries often screws you over
17:08:51 <Heffalump> if it's to be "every implementation should provide these", then changing it often may be helpful
17:08:59 <Philippa> unless you have a rule that inter-language-standard reports only extend libs
17:09:00 <ihope> Heffalump: that's supposed to be a program in CPS that takes a string from the user and returns its head.
17:09:15 <Philippa> (and can't break invariants in doing so, I guess)
17:10:12 * SamB wonders how you make digital sequence thingies
17:10:35 <Heffalump> ihope: shouldn't that head in the middle have a return somewhere?
17:10:37 <Philippa> you need more parens
17:10:50 <nuffer> anyone got any good links for netcode in haskell?
17:10:59 <Philippa> IOW, the application order doesn't work how you want it to
17:11:05 <Philippa> nuffer: what do you mean?
17:11:11 <Philippa> it sounds like you're trying to do gamedev
17:11:15 <nuffer> like... I want to write a client/server app
17:11:18 <nuffer> I am indeed
17:11:23 <Philippa> the term 'netcode' doesn't have much meaning outside that community IME :-)
17:11:34 <nuffer> okay, I want access to TCP/IP functionality
17:11:44 <SamB> @docs Network
17:11:45 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/network/Network.
17:11:45 <lambdabot> html
17:11:50 <SamB> gah
17:11:57 <SamB> stupid wrapping
17:12:01 <shapr> missingh has some simple tcp/ip servers last I heard.
17:12:03 <nuffer> err, guess I found it, thanks
17:12:09 <Heffalump> so, have I missed something in the announcement/trac stuff about the scope of the libraries work?
17:12:17 <SamB> hmm?
17:12:25 <Heffalump> I'll post to the list asking what is planned, otherwise.
17:12:33 <SamB> I haven't been paying much attention ;-)
17:13:15 <Philippa> Isaac just forwarded in something in favour of big libs
17:13:23 <Heffalump> yes, that was what triggered my question
17:14:00 <SamB> big libs are nice, except for the part where people become overly reluctant to improve them...
17:14:03 <ihope> ...Oh, right.
17:14:05 <Philippa> I'm in favour up to a point - enough to do basic net and web apps (and that includes all your IO be it binary, homebrew text-based format or XML, I guess), GUIs are more of an issue
17:15:12 <Heffalump> in Uppsala (HW 03?) there was a general suggestion we should adopt wxHaskell as "the" GUI library for Haskell.
17:15:15 <SamB> I think IArray and MArray, and Date.Array using the IArray interface, are important...
17:15:22 <Heffalump> But most people seem to be using gtk2hs
17:16:20 <ihope> Anyone care to fix my broken CPS thing him/herself?
17:17:15 <Philippa> SamB: containers generally, but yeah, arrays in particular
17:18:05 <Philippa> both have problems IMO. In practice most implementations will want to provide at least links to other useful libs
17:18:26 <jethr0_> ihope: if you refer to your code from 12 minutes ago... i find that _very_ hard to read!
17:18:29 <jethr0_> :)
17:20:15 <ihope> It's CPS. It's supposed to look like imperative code.
17:21:11 <ihope> It'll take a while to figure it out, I guess.
17:21:15 <jethr0_> hmm, well it sure as hell doesn't look like any "sane" imperative code i know.
17:21:32 <jethr0_> ihope: what are you doing this for? just for fun?
17:21:47 <ihope> I'm trying to write an introduction to CPS for Wikibooks.
17:22:17 <Heffalump> where is the discussion of specific trac tickets supposed to go?
17:22:30 <jethr0_> hmm, i wouldn't take the above as a first example :)
17:22:43 <SamB> Philippa: well, Arrays need rather more compiler support than other types
17:22:57 <SamB> I mean, other collection types
17:23:25 <ihope> Well, I'd like *some* sort of example...
17:23:42 <jethr0_> ihope: could you translate the above into sth sane? maybe i can figure out sth *g8
17:23:45 <jethr0_> *
17:24:45 <ihope> main = getLine >>= putChar . head
17:24:50 <jethr0_> ahh
17:25:03 <Philippa> ihope: if you want to do CPS, don't use monads as well
17:25:13 <Philippa> monads're sort of wrapped CPS. You'll headfuck people senseless
17:25:21 <jethr0_> exactly my thoughts
17:25:43 <ihope> Well, I wanted to demonstrate how well CPS worked with the IO monad.
17:25:46 <Philippa> (and if you've /got/ to do it, FFS use do notation!)
17:25:52 <ihope> Apparently it doesn't.
17:26:04 <Philippa> it works wonderfully, FCVO CPS
17:26:06 <jethr0_> well, how much sense does CPS make with do-notation?
17:26:22 <Philippa> the whole point is that all you do is pass IO actions around, and bingo! CPS happens
17:26:46 <Philippa> (OK, OK, functions yielding IO actions, same damn difference :-)
17:26:54 <Philippa> use do notation. Really.
17:27:12 <Philippa> 'explicit' monadic style is always begging to headfuck people anyway
17:27:19 <jethr0_> ihope: i think CP is hard enough to grasp at it is. and i would advise to not do it on one line. but declare helper function which take the continuation explicitely instead
17:27:47 <ihope> Well, that wasn't a one-liner. IRC just doesn't like multiline stuff.
17:28:39 <Philippa> pastebins are your friend
17:29:29 <Philippa> pointless style in tutorials is not your friend :-)
17:30:12 * SamB takes notes
17:30:17 <SamB> (okay, so maybe not really)
17:54:23 --- topic: '["Haskell is still the language of choice for discriminating hackers","logs:","http://tunes.org/~nef/logs/haskell/","http://www.haskell.org/learning.html","http://www.haskell.org/tmrwiki/IssueFive","We put the Funk in Funktion","http://sequence.complete.org/hwn/20051129","HCAR 11/2005:","http://haskell.org/communities/"]'
17:54:23 --- topic: set by lambdabot on [Wed Jan 18 01:50:15 2006]
17:54:23 --- names: list (clog Nioate tumm ricebowl lambdabot jlouis monochrom tennin noclouds ihope nuffer lollan cpatrick Pupeno_ joelk Lokadin astrolabe kevind jethr0_ drbean SamB golos mkhl masm svens Matt-W thedward Khisanth Taliesin tmoertel pesco chucky kisu kmagdsick mattam icbt sproingie fatbrain binary42 cjs__ dv kpreid_ geneticp srle JaffaCake jip AaronP boegel lome eno-away slipstream sieni bigbabyjesusfoo lennart triplah Twigathy eyck qwr Nomius Poeir)
17:54:24 --- names: list (jvw flux__ earthy ValarQ kpk Jaen JKnecht CLxyz nathan_ resiak noj rep kzm C-Keen orbitz musasabi wolverian juhp JohnMeacham audreyt araujo spamsch stesch PerlJam wli emu skylan WillKW Spark tuomov dcoutts jiing xerox edwinb kosmikus cods Heffalump AtnNn norpan mornfall neologism psnl gzl ksandstr sylvan eivuokko genneth nomeata glasser gdsx rblackwe stefanw pejo tic|school magagr shrimpx cjs Touqen hellish ulfdoz integral dany2k kolmodin)
17:54:24 --- names: list (dcoutts_ Lor ozone alch` SimonRC Wallbraker Trixsey|Laptop Cale borism djw Si\Uni tromp_ shapr cmeme dechunker samx Korollary scw cognominal ramkrsna Lemmih johs ibid tic)
17:55:13 <ihope> Many quits and many joins.
17:56:39 <dons> lilo rebooted something
18:29:08 <palomer> this unification problem is driving me nuts
18:29:17 <palomer> unification with disjunction and disequalities
18:29:40 <palomer> oh wait, that can be done with theorem proving
18:29:44 <palomer> well, that's all folks
18:30:23 <sproingie> anyone have the OOHaskell .zip distribution?
18:30:30 <sproingie> the page for it seems to be down
18:32:23 <lollan> euh sorry sproingie 
18:32:27 <lollan> not on this computer
18:33:34 <shapr> sproingie: http://www.scannedinavian.com/~shae/OOHaskell.zip and OOHaskell_cabal.tar.gz
18:33:58 <sproingie> shapr: 403
18:34:34 <sproingie> >> You don't have permission to access /~shae/OOHaskell.zip on this server.
18:35:07 <shapr> try again
18:35:35 <sproingie> got 'em.  thanks :)
18:36:14 <shapr> :-)
18:51:06 <palomer> > (\(x::a -> b) -> x) (\x -> x)
18:51:07 <lambdabot>   Illegal signature in pattern: a -> b
18:51:07 <lambdabot>    Use -fglasgow-exts to permit it
18:51:25 <palomer> how is that an illegal type signature?
18:52:23 <monochrom> If you use -fglasgow-exts it's legal.
18:52:41 <palomer> but it's legal in sml
18:52:55 <palomer> how in the blazes could something be legal in sml but not h'98
18:54:31 <monochrom> "fun f [] = [] | (x::xs) = xs" is also illegal in haskell.
18:55:26 <palomer> > f [] = [] ; f (x::xs) = xs
18:55:27 <lambdabot>  parse error on input `='
18:55:59 <palomer> > f [] = [] ; f (x:xs) = xs
18:56:00 <lambdabot>  parse error on input `='
18:56:08 <palomer> > let f [] = [] ; f (x:xs) = xs in f
18:56:08 <lambdabot>  add an instance declaration for (Show ([a] -> [a]))
18:56:15 <palomer> > let f [] = [] ; f (x:xs) = xs in f []
18:56:15 <lambdabot> Add a type signature
18:56:20 <palomer> > let f [] = [] ; f (x:xs) = xs in f [1]
18:56:21 <lambdabot> []
18:56:24 <palomer> it's legal
18:57:14 <monochrom> The exact syntax "fun f [] = [] | (x::xs) = xs" is illegal.
18:57:20 <palomer> anyways, sml gives a type error whereas haskell turns it down outright!
18:57:27 <palomer> monochrom: oh, so you were being obtuse
18:57:35 <monochrom> Yes indeed.
18:57:43 <palomer> monochrom: do you know anything about unification in theorem proving?
18:57:47 <monochrom> I am being no less obtuse than you are.
18:58:34 <palomer> my question is: how is one supposed to unify all the branches at once?
18:58:49 <monochrom> I don't know unification.
19:00:12 <eivuokko> Usually, I think, you go and unify two and get intermediate list of type mappings, and use that to replace types and then unify two and get more type mappings etc.
19:00:23 <eivuokko> But I don't know how that suits your problem.
19:01:35 <palomer> ok, so I have        alpha = int |- beta = bool         and            alpha = bool |- beta = int
19:01:49 <palomer> so, I have at least two choices:
19:01:50 <monochrom> > (\x -> x :: a->b) (\x -> x)
19:01:51 <lambdabot>  x :: a -> b
19:01:51 <lambdabot>   In a lambda abstraction: \ x -> x :: a -> b
19:01:51 <lambdabot>   In the definition of `yln': yln = (\ x -> x :: a -> b) (\ x -> x)
19:02:15 <palomer> {alpha=int, beta=bool}, {alpha=bool,beta=int}
19:02:25 <palomer> eivuokko: how does one generate these automatically?
19:06:42 <eivuokko> Hmh.  I don't know how to apply.. 
19:07:28 <jethr0_> apply?
19:07:55 <eivuokko> ..unifcation to that
19:34:54 <palomer>  hrmph
19:34:57 <palomer> who wrote djinn?
19:37:04 <dons> lennart
19:37:14 <dons> @help djinn
19:37:15 <lambdabot> Generates Haskell code from a type.
19:37:15 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
19:39:09 <palomer> lennart: you around?
20:44:26 <lispy> hihihi
22:08:14 <dons> @yow
22:08:15 <lambdabot> I like the way ONLY their mouths move ...  They look like DYING OYSTERS
22:08:51 <dons> lispy, yeah I think my fps is probably fairly standard atm, it's used in pugs, for example
22:09:11 <dons> Bulat is a funny guy
22:09:22 <dons> @which
22:09:23 <lambdabot> Unknown command, try @listcommands.
22:09:25 <dons> @which fps
22:09:25 <lambdabot> Unknown command, try @listcommands.
22:09:32 <dons> @where fps
22:09:33 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
22:09:47 <dons> it must be the most comprehensive interface, at least
23:06:40 <lispy> dons: was i wrong in saying that you created it?
23:08:39 <lispy> my email client annoyed me today (unforgivable sin).  it wouldn't send the email this morning when I hit send (no reason either), when I got home from work it was still sitting there waiting in my outbox.  I had to manually resend that email to haskell-cafe.
23:09:57 <lispy> perhaps it is time to use something open source for email so that i can spend a week debugging it when it does an unforgivable...
23:11:15 <lispy> dons: i was also confused by his comment that he'd rather work on something concrete.  I was vague in my message, but the problem i'm trying to solve is one very concrete case in darcs :)
23:26:00 <lispy> well, night all
