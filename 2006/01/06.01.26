00:00:12 <Korollary> astrolabe: I subvocalize too
00:00:17 <shapr> That's amazing.
00:00:26 <shapr> How do you process symbols you can't speak?
00:00:43 <astrolabe> I can speak them all I think
00:00:44 <Korollary> shapr: I somehow managed to learn to skip over them
00:00:57 <sieni> Korollary: may I do both? :-)
00:01:17 <shapr> This discussion is just like - http://www.scannedinavian.com/2005-02-04.html
00:01:21 <sieni> Btw, are there nice books about denotational semantics, domain theory and all that?
00:01:26 <Korollary> sieni: Yi is a lost cause I am afraid (chuckles)
00:01:35 <shapr> nooo, yi is great!
00:01:50 <sieni> Korollary: well, it's not emacs and that's a great start
00:01:54 * shapr agrees
00:02:47 <Korollary> sieni: screw all that. Study topology.
00:02:54 <astrolabe> Anyway, my concern is that the effect of allowing general unicode might be like a tower of babel.  It will lead people who at the moment can understand and edit each others programs to have much more difficulty to do so.
00:03:27 <dons> it''s like using bad identifiers, people just won't do it. too much peer pressure not to
00:03:33 <sieni> Korollary: I've done my fair share of studying topology
00:03:36 <Korollary> astrolabe: we're going to have that price eventually.
00:03:42 <shapr> I don't think it'll be any different from the way we define operators now. People from languages that cannot define new operators complain about that ability in Haskell.
00:04:14 <shapr> Or at least, are surprised when they learn Haskell.
00:04:24 <dons> ah yes.
00:04:38 <Korollary> I believe java has been unicode from the start. Have you ever seen any java code with unicode chars?
00:04:53 <dons> I remember a noobie here who said something like: there's nothing to hang on to in haskell. it's all just words
00:05:00 <shapr> haha
00:05:07 <shapr> That's a FEATURE!
00:05:07 <Korollary> well put
00:05:08 <nnunley> I don't believe you can use unicode in identifiers in java.
00:05:17 <dons> he wanted semi colons and braces and brackets and and and
00:05:25 <Korollary> nnunley: is it limited to string literals?
00:05:30 <astrolabe> But at least I can say "less-then less-than equals" to myself if I don't know a better name.  I'll be in trouble if there are lots of characters that I don't recognise.
00:05:52 <shapr> But can't you figure out the parts you can understand, and infer the rest?
00:05:57 <astrolabe> Korollay: Is that a point for using unicode or against it ?  :)
00:06:09 <nnunley> Korollary:  I believe so.
00:06:19 <dons> won't it be like people using :*: or some such. you have to go and find the defn.
00:06:27 <Korollary> nnunley: I just looked it up. You can use them in identifiers.
00:06:59 <shapr> I think my process is different for me because I *always* forget details, so my whole life I've been forced to infer from what I can remember at this particular moment.
00:07:12 <astrolabe> dons: yes, but you potentially have nothing to tie the defn to if you can't recognise the characters in the string
00:07:15 <Korollary> shapr: do as the guy in Memento
00:07:16 <nnunley> Korollary: Hrm.  Thanks.  I didn't know.  I guess I should review the spec.
00:07:36 <astrolabe> shapr: But that's exactly like me!
00:07:44 <shapr> Korollary: I've done so my whole life, that's why I said Memento was a film about ADD, AI, and so much more.
00:07:44 <dons> hmm, yeah. I see. if it was always chinese chars, I have trouble distinguishing them quickly. at least the complex ones.
00:08:08 <astrolabe> How many characters are there in unicode?
00:08:15 <Korollary> dons: you also need to type those chinese chars as well. copy-paste fest.
00:08:27 <Korollary> astrolabe: it's actually unlimited. Currently a little over 64k.
00:08:33 <astrolabe> OMG
00:08:38 <dons> yup. hence I think it will be socially unacceptable to do this. ascii will still rule
00:09:02 <shapr> At any given moment, I can only access about 70% of the stuff I've learned. But the window is always sliding and changing, so most of the time I can function acceptably.
00:09:11 <dons> and maybe the type theorists or physics guys will be a little more happy, since they can use eta and omega
00:09:11 <shapr> And I only have to wait five minutes to get a whole new viewpoint!
00:09:29 <Korollary> shapr: That sounds like the goldfish joke.
00:09:48 <shapr> I think it is like the goldfish joke. I often refer to myself as child labor.
00:10:02 <shapr> Oh hey!
00:10:02 <Korollary> heh
00:10:07 <astrolabe> Greek letters would be ok for me.  But for others, they would seem like chinese.
00:10:07 <shapr> I played this great joke on myself once..
00:10:15 <shapr> I put a sticker over the face of my watch.
00:10:30 <shapr> And I have this mental flag that says "You don't know what time it is, check a clock or watch"
00:10:52 <shapr> So when the flag goes up, (about every twenty minutes) I look at my watch.
00:11:03 <dons> oh no. this won't end well..
00:11:17 <shapr> So I went to work after putting the sticker on my watch and every twenty minutes I'd look at my watch and laugh quietly, because I'd successfully played a joke on myself.
00:11:28 <Korollary> more than once?
00:11:32 <shapr> After about three hours, my coworkers came to me and said "WHY ARE YOU LAUGHING??"
00:11:45 <shapr> Korollary: goldfish, remember?
00:11:54 * Korollary is speechless
00:12:24 <Korollary> hey, you can just write down one good joke and read it every 20 mins, too.
00:12:36 <Korollary> continuous entertainment.
00:12:37 <shapr> So the joke worked just fine for about three days, it took three showers to wash the sticker off. (I can't remember to take off my watch, so I have to buy waterproof watches). By the end of it, my coworkers were ready to murderize me.
00:13:16 <Korollary> somebody quote that
00:14:25 <shapr> I also brushed my hair a lot, and when people would ask me about it I'd say "My hair is my second favorite toy."
00:14:40 <Korollary> ew
00:14:43 <dons> oh no
00:14:44 <shapr> I kept thinking I'd figure out what my favorite toy was the instant someone asked me... but they never did!
00:14:53 <dons> i guess he means his rubics cube
00:14:57 <Korollary> I hope
00:15:01 <shapr> When I was leaving, I asked them why they never asked me. They said they were far too scared of the answer.
00:16:20 <shapr> Somedays it does suck to be a stranger in a strange land.
00:16:36 <Korollary> It does
00:16:48 <Korollary> especially the first months/years
00:18:06 <shapr> Yeah, I have a good excuse when I live in a foreign country. When I grew up with people and they still think I'm an alien, that's more difficult.
00:19:04 <Korollary> I think the events are a bit correlated. You may have alienated enough people so that moving away is no big deal.
00:19:43 <shapr> I don't think I alienate in the sense of driving them away, but most people say I'm one of the strangest people they've ever met.
00:19:58 <shapr> I surely don't do it on purpose, as some people claim.
00:20:08 <Korollary> They could be right. Somebody's gotta be that strangest person. It could be you!
00:20:42 <Korollary> You have to be a masochist to do it on purpose.
00:21:14 <shapr> heh
00:21:32 * shapr lobs a ball weird at Korollary 
00:22:52 * Korollary roundhouse kicks the ball 
00:26:05 <sieni> We are all strange here
00:26:24 <Saulzar> No, it's everyone else who is strange :)
00:26:27 <shapr> heh
00:26:28 <Korollary> sieni: in what way are you strange?
00:27:21 <sieni> http://images.art.com/images/PRODUCTS/large/10104000/10104011.jpg
00:38:39 <shapr> salut Lunar^ 
00:55:23 <shapr> @remember ChrisKuklewicz Are there little known Haskell idioms for doing math? Is there an undocumented -funleash-fortran parameter?
00:56:15 <astrolabe> cry havoc and let slip the dogs of fortran!
00:56:19 <dcoutts> gour, pong
00:56:49 <gour> dcoutts: just a note that i posted reply to axel's post
00:56:57 <shapr> Cry haddock and let slip the frogs of war!
00:57:00 * dcoutts looks
00:58:34 <astrolabe> Fortran is the continuation of programming by other means.
01:01:21 <gour> i'd like to have some gobby session with my win32 friend, but it looks that 0.3 installer misses some libs. anyone?
01:08:45 <shapr> Can you run ldd or so?
01:17:37 <gour> shapr: it runs on linux, but it looks that win32 installer does not pack everything
01:39:43 <nibro> @seen dons
01:39:44 <lambdabot> dons is in #haskell-blah and #haskell. Last spoke 1 hour, 24 minutes and
01:39:44 <lambdabot> 51 seconds ago.
02:02:07 <shapr> gour: You could unzip the win32 installer on your linux box, and compare the dll listing to your listing from "ldd `which gobby`"
02:08:47 <gour> shapr: thanks. unsupported archive, but according to linux version, it reqs gtkmm
02:19:49 <dons> musasabi, the `mandelbrot' benchmark should be compiled with -fexcess-precision. It's not present, and I get 2 or 3x speedup when I add it (this probably explains mandelbrot's currently poor performance). Can you add it?
02:20:32 <nibro> dons: oi :-)
02:20:54 <dons> oi oi
02:20:55 <nibro> got a question for you
02:21:00 <dons> shoot
02:21:27 <nibro> seems I get some weird results lately with the hsp server, and I can't help but think that they are due to hs-plugins
02:21:38 <dons> hmm :/
02:21:39 <nibro> the problem is that stuff never gets reloaded
02:22:08 <dons> that's weird. can you send me a test case?
02:22:12 <nibro> I do 'load' immediately followed by 'reload' just to check, but still nothing
02:22:30 <nibro> I could try to distill a small case to send you
02:22:39 <nibro> there's more as well
02:22:44 <dons> yep, that'd be really good (and basically the only way to debug it)
02:23:13 <nibro> when I do 'load' immediately followed by 'unload', I get 'unloadObj failed: no such file
02:23:54 <nibro> although the load worked fine
02:23:55 <dons> hmm. another weird one. that should be caught by the testsuite. if you can get it reproduced, send me the test case
02:24:36 <nibro> hmm, so maybe I should run the test suite then. :-)
02:24:49 <dons> could be a good idea :)
02:25:44 * dons tip of the day: always use -fexcess-precision when doing Double math
02:25:57 <dons> for extra fun, add -optc-ffast-math
02:26:50 <joelk> Indeed, Even my nbody is almost as fast as Einar's when compiled with -fexcess-precision.
02:27:12 <joelk> ... and -funbox-strictf-fields
02:27:25 <nibro> the testsuite went through fine
02:28:06 <nibro> at least I think so - it didn't say 'ok' after the unload test, but it didn't give an error msg either. :-)
02:28:17 <dons> hmm.
02:28:36 * dons runs the testsuite
02:28:46 * nibro thinks the error printouts could really use some linebreaks...
02:29:09 <dons> but there should be no errors ;)
02:29:25 <nibro> aha, so if there are no errors then there are linebreaks all over?
02:29:43 <nibro> then there wasn't much that worked... ;-)
02:29:58 <dons> it should just print: 
02:30:00 <dons> === testing testsuite/conf/simple                              ... ok.
02:30:02 <dons> === testing testsuite/dynload/io                               ... ok.
02:30:02 <dons> === testing testsuite/dynload/poly                             ... ok.
02:30:10 <dons> ...  
02:30:37 <nibro> no ok's on this side
02:30:53 <nibro> the only ok's I get are for the plugs and runplugs tests
02:31:29 <dons> ok. so it's broken somehow. maybe ghc changed? try rebuilding and installing from scratch.
02:31:39 <nibro> === testing testsuite/conf/simple                              ... === testing testsuite/dynload/io                               ... === testing testsuite/dynload/poly                             ... === testing testsuite/dynload/should_fail    
02:31:42 <nibro> and so on
02:31:47 <dons> yeah, thaat's silently failing
02:31:52 <dons> maybe a segfault?
02:31:59 <nibro> I hope you don't mean reinstalling ghc? :-)
02:32:06 <dons> nope.
02:32:14 <gour> dcoutts: axel replied..
02:32:17 <dons> if you change ghhc or Cabal, then hs-plugins could break, I suppose.
02:32:29 <dcoutts> gour, yes, i'm writing something.
02:32:37 <nibro> aha, but I did install Cabal 1.1.4 afterwards
02:32:48 <nibro> I'll reinstall plugins and see what happens
02:33:04 <dons> and rebuild it.
02:33:10 <nibro> aye
02:33:25 <dons> (it runs through with no errors here on my box)
02:35:29 <nibro> now I can't install it, I get
02:35:34 <nibro> Could not find module `Distribution.Package':
02:35:34 <nibro>   use -v to see a list of the files searched for
02:35:34 <nibro>   (imported from src/System/Plugins/PackageAPI.hs)
02:35:50 <nibro> something that changed with the latest cabal?
02:36:11 <dons> hmm. I have 1.1.4 installed. from a couple of months ago
02:36:32 <dons> is Cabal visible in ghc-pkg list?
02:36:45 <nibro> hidden
02:37:06 <nibro> I do 'runhaskell "-ignore-package Cabal-1.0" "-package Cabal-1.1.4" Setup.lhs build'
02:37:13 <dons> it should be unhidden
02:37:24 <nibro> 1.0 is installed as root, I can't override it
02:37:26 <dons> oh. does that work?
02:38:03 <nibro> seems not to, it means Setup.lhs uses the right Cabal but the flags are not forwarded
02:38:19 <dons> ah, ok.
02:39:03 <nibro> tried exposing it, same problem
02:39:26 <nibro> but exposing it means as --user, still Cabal-1.0 in the central repo
02:40:04 <dons> i can't think of anything. somehow you need to get coherent access to 1.1.4. can you think of any tricks?
02:40:17 <nibro> seems the cabal installation architecture doesn't really take the --user case into account...
02:40:34 <dons> oh, I guess you could hardcode those flags in the Cabal ghc-options field?
02:40:41 <dons> the package options
02:40:44 <nibro> I could see if I could get bringert to install 1.1.4 centrally
02:40:53 <nibro> in plugins.cabal?
02:41:09 <dons> yeah, so it's passed the right cmd line flags
02:41:47 <joelk> hmmm.... nbody is getting an error on the shootout  page now. #3 is producing the wrong answer and #2 is segfaulting according to the website
02:42:08 <joelk> and for some reason they have -fno-excess-precision!
02:42:11 <dons> joelk, on the _debian_ page, not the gp4 page?
02:42:18 <dons> joelk, yeah. weird. 
02:42:20 <joelk> on deb
02:42:28 <joelk> sabotage!
02:43:35 <nibro> hmm, wouldn't it be enough to specify dependency Cabal-1.1.4 in Build-Depends?
02:45:20 <nibro> to answer my own question, yes it worked :-)
02:45:30 <nibro> or rather, I had to say Cabal>=1.1.4
02:45:43 <dons> joelk, runs twice as fast on my box if we add -optc-ffast-math and -fexcess-precisoin
02:45:47 <dons> another one to  fix!
02:45:48 <eivuokko> You can't expose packages in ghc-options field anyway, because cabal puts hide-all-packages options after those options on commandline.
02:46:04 <dons> ah, good point
02:46:22 <nibro> ok, rebuilt and reinstall, running testsuite
02:47:04 <nibro> heh, now the testcases are failing non-silently :-)
02:47:17 <dons> musasabi, nbody should be compiled with: -fexcess-precision -optc-ffast-math. the current one uses -fno-excess-precision (!) and is twice as slow as it should be in testing
02:47:39 <dons> nibro, ok. that's an improvement. but non-failing non-silently would be better
02:48:32 <dons> joelk, are there any other Double-math benchmarks which we should add -fexcess-precision to?
02:49:05 <joelk> I don't know...
02:49:09 <nibro> preliminary results (still running), lots of 'resolveObjs failed: unknown symbol Altdatazi...'
02:49:46 <nibro> hmm, the load, unload and reload tests went through with ok.
02:50:16 <dons> joelk, ok. i'll look then ;)
02:50:50 <dons> nibro, hmm. ok.
02:52:43 <nibro> I guess the Altdata stuff is to be expected, since I don't have it installed... should it be?
02:53:31 <joelk> dons, I decided my "supremely functional" nbody (read, doesn't look like C) is the cutest and to abandon my further attempts.
02:53:34 <dcoutts> gour, I've responded to axel's note. What do you reckon about my suggestions? I think it'd mean we could en up using WP the way it was designed for, and not need so much customisation/plugins.
02:54:14 <gour> dcoutts: let me take a look..
02:54:31 <dons> joelk, fine :)  nibro, hmm. AltData should be installed with plugins. it's part of src/AltData/.*
02:55:44 <nibro> well, it isn't :-)
02:55:53 <nibro> only plugins-1.0
02:56:36 <nibro> ah, so AltData.X is now part of plugins, didn't see that
02:56:52 <nibro> then they should be installed yes, nm my ramblings :-)
02:57:47 <dons> yep, it's one single packaage now
02:58:43 <nibro> so they are installed, I can load them up in ghci just fine
02:58:55 <nibro> want me to mail you the testsuite output I got?
02:59:04 * nibro is getting ready for lunch
03:00:02 <dons> yep, mail it
03:01:58 <nibro> mail sent
03:02:46 <dons> got it. thanks
03:04:09 <nibro> going for lunch now, hope you're still here when I get back :-)
03:07:23 * joelk waves goodbye
03:07:39 * shapr waves back
03:08:15 <joelk> see y'all
03:08:43 <gour> dcoutts: replied (going to take a lunch :-)
03:08:52 <dcoutts> gour, ok
03:09:45 <dcoutts> does anyone know anything about irc.haskell.org that is mentioned on the haskell.org wiki?
03:10:03 * shapr hasn't heard of that
03:10:05 <dcoutts> it's mentioned here:
03:10:06 <dcoutts> http://haskell.org/haskellwiki/Links_to_People_and_Further_Pages
03:10:09 * shapr connects
03:10:17 <dcoutts> and the web page exists:
03:10:18 <dcoutts> http://irc.haskell.org/
03:10:36 <dcoutts> but the normal irc port doesn't work
03:10:42 <shapr> Yeah, it doesn't...
03:11:16 <eivuokko> iirc it was a freenode alias
03:11:23 <dcoutts> right
03:11:28 <dcoutts> should we change the wiki then?
03:12:00 * shapr assumes yes
03:12:28 <dcoutts> is the #haskell page on the new wiki?
03:12:38 <shapr> Or we could move the whole #haskell community to SILCnet and run a SILC to IRC gateway for legacy users.
03:12:41 <dcoutts> it looks like it needs mooving
03:12:47 <shapr> moov it!
03:12:55 * shapr groovs
03:13:04 <shapr> mmm, daftpunk
03:13:26 <shapr> What's the status on yi?
03:14:16 <dcoutts> shapr, the gtk side or the cureses side?
03:14:51 <shapr> znephf: Greetings, learning Haskell?
03:15:03 <shapr> Which side is the most active?
03:15:05 <dcoutts> hmm, there's quite a bit of stuff on http://haskell.org/hawiki/HaskellIrcChannel and related pages
03:15:18 <dcoutts> I'm not sure I'm qualifed to move it and reorganise it
03:15:56 <shapr> I think anyone is qualified.
03:16:48 <shapr> If you move it and reorganize the parts you immediately know how to fix, others will reorganise the parts they know how to fix.
03:16:53 <shapr> At least, that's how I expect a wiki to work.
03:17:21 <shapr> Sort of like UDP, best effort editing :-)
03:20:40 <dcoutts> well I've moved the basic info: http://haskell.org/haskellwiki/Haskell_IRC_Channel
03:47:52 <znephf> hi shapr - erm yes
03:51:42 <shapr> znephf: Have any questions?
03:52:16 <znephf> shapr, not yet.. ;) ina bout three weeks my exams are over, i'll start it right then :) - currently just playing with the basics
03:59:03 <shapr> znephf: Ok, if you have any questions, feel free to ask them.
03:59:20 <znephf> sure, that's why i'm here :) - btw, thx for that info
04:01:17 <pesco> JohnMeacham: I had the latest yesterday; pulling again now...
04:01:51 <pesco> Morning shapr!
04:02:01 * pesco waves around elaborately.
04:10:05 <shapr> hiya pesco 
04:13:46 <pesco> shapr: Grmbl mbml, getting scratchbox to run on powerpc will, as expected, require a bunch of fiddling.
04:16:15 <gour> dcoutts: reply posted
04:17:13 <dcoutts> gour, yep, fair points
04:17:26 <dcoutts> we'll see what Axel thinks
04:17:52 <shapr> pesco: Did you buy a 770?
04:18:32 <pesco> shapr: Not yet, not available yet. Might get it in a month.
04:18:49 <pesco> shapr: But I went over the instructions for the SDK and downloaded the scratchbox sources.
04:18:50 <dcoutts> shapr, where's the best place to buy?
04:20:20 <shapr> dcoutts: I got mine from nokia.com
04:20:27 <dcoutts> ok
04:20:35 <dons> musasabi, an entry for partial-sums is on the wiki: http://www.haskell.org/hawiki/PartialSumsEntry, note the careful use of ghc flags, we want to optimise these numeric loops. Can you submit it?
04:20:38 <gour> dcoutts:thanks
04:23:52 <jethr0> moin moin
04:24:02 <shapr> grussgott
04:24:06 <jethr0> hehe
04:24:24 * shapr works for Erlangen folks.
04:24:29 <dcoutts> shapr, so have you got yhc running yet?
04:24:32 <shapr> Not yet
04:24:38 <dcoutts> ndm said it'd be 5min :-)
04:24:46 <shapr> I haven't tried it yet.
04:24:49 <dcoutts> ok
04:25:39 <shapr> I am definitely looking forward to it.
04:27:12 <shapr> bye andrew...
04:30:31 <pesco> :)
04:34:41 <dons> it took 5 mins when I tried it :)
04:40:49 <nibro> dons: back now, any news?
04:44:07 <nibro> @seen dons
04:44:08 <lambdabot> dons is in #haskell-blah and #haskell. Last spoke 9 minutes and 26
04:44:08 <lambdabot> seconds ago.
04:46:01 <shapr> pesco: The 770 is in stock on nokia.se. I guess I got lucky.
04:46:20 <shapr> Funny thing is that it shipped to me from Belgium.
04:46:21 <pesco> shapr: Yeah, I think nokia.cz hasn't even heard of it, yet. :)
04:46:24 <shapr> haha
04:47:42 * shapr boings cheerfully
04:48:44 <gour> what's that 770 anyway? i always thought 707 is chic :-)
04:50:39 <shapr> 007?
04:51:30 <gour> yep, true, 007 :-(
04:51:42 <dons> nibro, it's midnight here, so no more news tonight :)
04:51:47 <gour> 707 is a jet - also chic :;)
04:52:10 <nibro> dons: I knew it was late, but I didn't know what hours you kept :-p
04:54:33 <nibro> btw, I'm running the testsuite on another machine, standard i386 Linux (the other is x86_64), same errors
04:55:06 <dons> i try to keep `reasonable' ones. my girlfriend doesn't like it when i get all hackery
04:55:12 <dons> hmm. ok, that's interesting.
04:55:17 <dons> i'll inspect linux in the morning
04:55:48 <nibro> but I'm starting to think it has to do with the --user stuff - i.e. that it doesn't know where my user package.conf is, and thus can't look in it
04:56:24 <nibro> I'm going to run a test case on my laptop, installing as root, to see if it helps
04:56:34 <nibro> expect a mail in the morning :-)
04:56:40 <Lemmih> nibro, dons: Talking about hs-plugins?
04:56:48 <nibro> Lemmih: indeed
04:57:45 <Lemmih> nibro: We got some code in HIDE which finds and loads the users package conf.
05:00:45 <nibro> I have code that does that too, if I explicitly give the path to the package.conf as an argument to load
05:01:04 <nibro> but I have a feeling that the testsuite doesn't konw how to do that
05:01:50 <Lemmih> In HIDE we use code that does that automatically.
05:07:20 <nibro> Lemmih: does it just work, or is it something you do?
05:17:30 <Lemmih> It finds the package.conf file in the same way GHC does so it should work out of the box.
05:18:41 <znephf> got a question! ;) - suppose i have a list and just want the first element, that is take 1 but not in a list... just a pointer where i can read this might be halpful
05:19:53 <lennart> head
05:20:13 <TFK> Use the head function, from the standard prelude (where many useful functions reside. they're like built-ins)
05:20:26 <znephf> ok, that's cool :)
05:20:41 <dcoutts> > head "foo"
05:20:41 <znephf> i already browsed losts of modules but i oversee it... ;)
05:20:43 <lambdabot> 'f'
05:20:43 <sieni> Or even:
05:20:48 <znephf> thx :)
05:20:58 <sieni> > (\(x:xs)->x)"foo"
05:20:59 <lambdabot> 'f'
05:21:04 <znephf> ah.. sure
05:21:34 <dcoutts> > let head (x:_) = x in head "foo"
05:21:35 <lambdabot> 'f'
05:21:35 <sieni> @pl (\(x:xs)->x)
05:21:36 <lambdabot> head
05:21:46 <sieni> <3
05:21:57 <dcoutts> znephf, so many ways of writing the same thing :-)
05:22:09 <nibro> > foldr const undefined
05:22:11 <lambdabot>  add an instance declaration for (Show ([a] -> a))
05:22:14 * SimonRC goes.
05:22:17 <nibro> > foldr const undefined "foo"
05:22:19 <lambdabot> 'f'
05:22:45 <dcoutts> now nibro is just showing off :-)
05:22:53 <nibro> pah :-p
05:23:17 <dcoutts> obfscucated head contest
05:23:56 <sieni> "did you get any obfuscated head on your trip to Thailand?"
05:24:12 <znephf> dcoutts, it makes haskell even more interesting :)
05:24:31 <dcoutts> hope so
05:24:34 <znephf> :)
05:25:18 <gour> dcoutts: TMTOWTDI :-)
05:25:48 * dcoutts tries to coprehend that
05:26:00 <gour> lol
05:26:03 <dcoutts> nope, I guve up
05:26:18 <gour> dcoutts: think Perl
05:26:24 <dcoutts> no!
05:26:35 <dcoutts> that's heracy!
05:26:42 <gour> :-)
05:27:20 <gour> dcoutts: "so many ways of writing the same thing" == TMTOWTDI :-)
05:27:37 * gour thinks dcoutts is preaching perl here
05:27:56 <nibro> WTDI should be Ways To Do It
05:28:03 <nibro> TMTO = ?
05:28:08 <dcoutts> gour, have you seen the obfsucated Haskell contest?
05:28:24 <gour> nibro: there is more than one way..
05:28:35 <nibro> ah :-)
05:28:46 <gour> dcoutts: saw, although didn't try to understand, don's contribution
05:29:02 * dcoutts notes that the ocaml gtk bindings just got support for Gtk+ 2.6 while the Haskell bindings have had support for Gtk+ 2.8 for many months.
05:29:03 <sieni> And Scheme has TIMTOBLTTWTDI 
05:29:41 * gour jsut visited lablgtk site :-)
05:29:46 <nibro> BLTT ?
05:32:28 <nibro> Lemmih: does your code *lode* modules depending on --user, or just use it?
05:33:56 <gour> dcoutts: comment for moderation - for you
05:34:04 <nibro> Lemmih: obviously the testsuite can't handle it, I've run tests with plugins as root and as user, first works but not the second
05:35:20 <dcoutts> gour, huh?
05:35:45 <gour> dcoutts: log to the site
05:36:29 <dcoutts> gour, ah yes, he emailed the haskell list too, I was just replying :-)
05:37:02 <dcoutts> JaffaCake, did I send in that patch to support a extra-ghci-libraries field in ghc package files?
05:37:09 <gour> dcoutts: hmm..strange, moderation email received, but not from the haskell list
05:37:18 <JaffaCake> dcoutts: yes you did, it's still sitting in my inbox
05:37:27 <dcoutts> gour, no he also emailed the haskell list
05:37:30 <JaffaCake> I'll get to it at some point, don't worry
05:37:35 <dcoutts> JaffaCake, ok, cool.
05:37:50 <dcoutts> JaffaCake, ideally I'd like you to consider it for 6.4.2 as well.
05:37:59 <gour> dcoutts: i understand, but i didn't receive msg from the list, only from our site
05:38:01 <JaffaCake> we'll see ;)
05:38:07 <dcoutts> JaffaCake, ok :-)
05:38:22 <JaffaCake> it's backwards compatible, isn't it?
05:38:37 <dcoutts> JaffaCake, it's an extra field in the package file so it should be
05:38:43 <dcoutts> it doesn't change anything else
05:38:54 <JaffaCake> then it's probably fine for 6.4.2
05:39:10 <dcoutts> if that field is present it overrides extra-libraries for the GHCi case
05:39:41 <dcoutts> so one can have different libs for GHC vs GHCi to work around various anoying linker issues
05:40:35 <dcoutts> the only non-backwards compatability angle is that presumably earlier versions of ghc will choke if they see the extra field in the package file
05:41:47 <JaffaCake> we only guarantee that "if it worked with 6.4.1, it works with 6.4.2", going the other direction isn't guaranteed
05:41:53 <dcoutts> ok
05:42:39 <dcoutts> anyway, it's only a couple packages that will take advantage of it I think and their build systems are sophisticated enough to cope
05:42:42 <jophar_> hello there
05:51:48 <shapr> greetings jophar_
05:52:23 <Lemmih> nibro: Yes, we load plugins registered in the users package.conf file.
05:54:39 <nibro> Lemmih: then it's really weird. What's the link to the hIDE repo?
05:56:53 <Lemmih> http://scannedinavian.org/repos/hIDE
05:58:24 <JKnecht> is it end-usable or strictly for developers of hIDE at this point?
05:58:24 <Lemmih> nibro: Hide.SystemEnv.userPkgConf :: IO FilePath is the important function.
05:59:43 <Lemmih> JKnecht: Well, it can't save files yet so I guess it's not end-usable for now (:
06:00:52 <JKnecht> is there a statement of function sumplace?
06:01:00 <nibro> Lemmih: ah, but then you *do* specify the user package conf explicitly!
06:01:49 <nibro> that's a great function in any case, mind if I steal it? :-)
06:01:52 <Lemmih> nibro: Well, yes of course. But we don't specify the path to it.
06:02:17 <nibro> indeed. That one should be push back into plugins IMO
06:02:43 <nibro> after all you get sysPkgConf from plugins, why not userPkgConf as well?
06:04:01 * JKnecht assumes hIDE is to be much more than (just) Yi. In particular wondering about symbolic debugging.
06:04:17 <Lemmih> Symbolic debugging?
06:06:16 <Lemmih> HIDE is already more than just Yi: It can underline errors while you type and provides Cabal integration.
06:06:48 <JKnecht> yeah, you know so you could put breakpoints in Yi, trace execution, that sort of thing.
06:07:13 <ADEpt> JKnecht: trace execution of what? :)
06:07:54 <Lemmih> JKnecht: That's /way/ beyond the scope of HIDE. Debugging lazy languages like that is very difficult.
06:08:06 <JKnecht> Ah, now we're at my actual ultimate question: 'does symbolic debugging in Haskell make sense'
06:08:33 <Philippa> "some"
06:08:43 <JKnecht> or non-imperative languages in general. Seems to me it would have to.
06:08:52 <Philippa> more so if you can cause an evaluation without update
06:09:08 <Philippa> it's an evaluation order issue rather than an imperative/declarative one
06:09:46 <JKnecht> it such a boon to development, I would only give up on it if were impossible in principle or wholly infeasible in practice.
06:10:02 <JKnecht> s/it/it's/
06:11:51 <Saulzar> Hmm, you could still do breakpoints right? Just tracing execution would not be so sane
06:12:14 <jethr0> @hoogle maybe
06:12:15 <lambdabot> Data.Maybe.Maybe :: Maybe a
06:12:15 <lambdabot> Data.Maybe.maybe :: b -> (a -> b) -> Maybe a -> b
06:12:15 <lambdabot> Prelude.Maybe :: Maybe a
06:12:47 <jophar_> humm ppl, how can I define and function as a foldr ?
06:12:49 <Saulzar> Or at least breakpoints on expressions, break when this is evaluated
06:13:41 <Saulzar> @type (&&)
06:13:42 <lambdabot> Bool -> Bool -> Bool
06:14:24 <basti_> jophar_: recursively.
06:14:24 <ADEpt> Crazy question. Let's consider bijective function f:: a->b. If "f" is written using some restricted subset of the haskell functions, may it be that under some other additional restrictions it will be possible to automatically generate the reverse function?
06:14:50 <basti_> jophar_: or do you mean, how to implement -any- function as a call to foldr?
06:15:18 <jophar_> I need like, 
06:15:25 <jophar_> any' l = foldr ....
06:16:01 <jophar_> omg not any :X and
06:16:13 <Saulzar> Well, and is similar, just a different operation
06:16:13 <jophar_> and' l = foldr...
06:16:31 <basti_> ah that
06:16:52 <basti_> > foldr (&&) True [True,True,True]
06:16:53 <lambdabot> True
06:17:00 <basti_> or just
06:17:05 <basti_> > and [True,True,True]
06:17:06 <lambdabot> True
06:17:07 <basti_> @type and
06:17:08 <lambdabot> [Bool] -> Bool
06:17:18 <jophar_> > foldr (&&) True [True,True,False]
06:17:20 <lambdabot> False
06:17:44 <dcoutts> JaffaCake, what would this mean: "Loading package gtk-0.9.10.1 ... linking ... WARNING: Overflown relocation field (# relocs found: 131589)"
06:17:46 <jophar_> can you explain it? :\
06:18:05 <JaffaCake> dcoutts: on windows?
06:18:10 <dcoutts> JaffaCake, yes
06:18:26 <dcoutts> JaffaCake, I was just experimenting with Gtk2Hs and GHCi
06:18:37 <JaffaCake> I think it means the object file has too many symbols... there's a FAQ IIRC
06:18:55 <dcoutts> it does work, but I get that warning when the gtk package is loaded.
06:19:02 * dcoutts looks for the FAQ
06:20:24 <SimonRC> rehi
06:20:31 <dcoutts> JaffaCake, I don't see any FAQ entry
06:20:45 <JaffaCake> me either, I'm sure I've seen it somewhere
06:21:31 <dcoutts> JaffaCake, would using split-objs help that?
06:21:51 <dcoutts> oh, I guess not since it's one .o file for GHCi built from the .a file
06:21:54 <JaffaCake> http://www.haskell.org/pipermail/glasgow-haskell-bugs/2003-October/003694.html
06:22:04 <dcoutts> ah, thanks
06:22:28 <SimonRC> hi
06:22:42 <JaffaCake> ah, it's in the known bugs section of the manual
06:22:59 <dcoutts> ah ok
06:23:10 <JaffaCake> http://www.haskell.org/ghc/docs/latest/html/users_guide/bugs.html#bugs-ghci
06:23:38 <JaffaCake> ISTR there was some movement on this recently though, because we've stopped splitting up the base package on Windows
06:24:39 <JaffaCake> dcoutts: patch "2005-10-27 01:39:40" in libraries/base
06:24:46 * dcoutts looks JaffaCake, what do you suggest then? I split gtk.o or see what this recent progress is?
06:24:49 <dcoutts> oops
06:25:07 * dcoutts looks at that patch
06:43:35 <dcoutts> JaffaCake, hmm, that patch says "This commit imposes a restriction on the 'ld' you use to compile up GHC with; it now has to be ld-2.15.x or later" ghc 6.4.1 comes with gnu ld 2.15.91 and I still get the problem. 
06:44:00 <dcoutts> I made sure I was using ghc's ld when doing the .a -> .o conversion
06:44:47 <araujo> Good morning.
06:44:51 <dcoutts> or do I need to make sure that all the original .o files that went into the libHSgtk.a used ghc's ld ?
06:46:02 <dcoutts> the mingw ld I have is an old version, but I don't think it would have been used for anything.
07:55:56 <ptolomy> #/join #ruby
07:56:03 <ptolomy> d'oh.
07:56:30 <SimonRC> Heretic!  You use a dynamically-typed language!
07:56:31 <SimonRC> :-)
07:56:32 <Philippa> traitor! :-)
07:56:36 <Philippa> snap!
07:56:36 <SamB> hmm, anyone have a clue how to scan C-- numeric literals?
07:57:04 <ptolomy> I swear! I'm only going to mock them and their type uncertainty!
07:57:08 <SamB> particularly, how to do it with Parsec?
07:57:14 <robdockins> the c-- spec has a BNF for the constants...
07:57:44 <SamB> robdockins: the trouble is, it has two different BNFs...
07:58:07 <SamB> one for floating-point literals and one for integer literals
07:59:25 <robdockins> samb -- I'm not sure I understand the trouble; floating point numbers always contain a '.' so they can be distinguished
08:00:03 <robdockins> samb -- BTW, I'm working on a c-- front end and I've written a whole scanner in Alex
08:00:21 <SamB> robdockins: yeah. mainly I'm wondering how to deal with floating point literals beginning with 0...
08:00:40 <SamB> robdockins: oh, maybe I should join you ;-)
08:00:52 <SamB> how far along are you?
08:01:32 <SamB> I was going to try Alex but it is kind of overwhelming...
08:01:40 <robdockins> samb -- A pretty good ways; I've gotten through semantic cheking.  I haven't released yet because I want to beef up the unit tests
08:02:17 <SamB> robdockins: have a darcs repo anywhere?
08:03:37 <robdockins> samb -- yup.  Its a little out of date though.  I can update tonight if you'd like.
08:03:43 <robdockins> http://www.eecs.tufts.edu/~rdocki01/cmm/
08:05:13 <robdockins> samb -- also it currently hasn't got all the right license cruft. I'll add that as well
08:06:29 <SamB> cool
08:10:02 <SamB> I hear that qc-- is hard to build, though I personally haven't tried (lacking the space in / to install the ocaml compiler)
08:12:39 <chucky> samb: there are .deb-files on the c-- homepage for qc-- which makes it a lot easier to install
08:13:55 <SamB> chucky: hmm
08:14:23 <chucky> installing qc-- from source is, as you say, hard
08:14:58 <ValarQ> q?
08:16:07 <SamB> ValarQ: it might stand for quick.
08:16:13 <SamB> then again, it might stand for quirky.
08:16:26 <ValarQ> :/
08:16:45 <ValarQ> like the q in my nick then
08:17:59 <SamB> it probably does stand for quick, though ;-)
08:18:15 <pejo> I built qc-- just fine on solaris, the instructions were excellent. But that was probably almost a year ago.
08:18:29 <chucky> the homepage says quick, but notes that it's "not quick enough" :)
08:19:06 <chucky> pejo: The problem, as I see it, is not building qc--, but finding/installing all the weird dependencies
08:26:27 <farre> hej nibro
08:31:27 <dcoutts> JaffaCake, I updated my mingwin to a version with ld 2.15.91 and rebuilt gtk2hs-0.9.10. I now only have 88,363 overflown relocs rather than 131,589.
08:31:41 <JaffaCake> oh :(
08:31:50 <dcoutts> JaffaCake, I fear I'll have to do the split .o file thing. :-(
08:31:58 <JaffaCake> maybe so
08:31:59 <dcoutts> ay pointers on how that works?
08:32:43 <JaffaCake> hmm, I think we used to just do it with explicit Makefile rules to link specific objects into each .o
08:33:04 <dcoutts> does it matter how they're distributed?
08:33:19 <dcoutts> can I just link the first 50 in one and the other 50 in another?
08:33:35 <JaffaCake> probably
08:33:44 <dcoutts> ok, i'll try. :-)
08:34:07 <Igloo> Oh, I didn't realise they were grouped. That makes it harder for cabal to do it easily
08:36:16 <JaffaCake> someone should ask Sigbjorn about this, I think he's under the impression that it's just a bug in the GNU linker, rather than a long-term problem we have to find a workaround for
08:45:20 <nibro> hi farre :)
08:47:46 <SamB> robdockins: my GHC doesn't seem to like such long ""# literals as are in CmmLex.hs...
08:48:44 <SamB> it claimed there was a lexical error somewhere around 30:626
08:49:09 <SamB> actaully, there might have been lexical error there, now that I think about it...
08:52:25 <robdockins> samb -- humm.  What GHC and alex version are you using?
08:52:46 <SamB> robdockins: well I hadn't yet run alex, but was using the file in the repo
08:53:22 <SamB> wait, that wasn't in the repo...
08:53:44 <robdockins> oh.  You probably shouldn't.  That file isn't actually in the repo.  It must have been snarfed up by accident when I did the rsync...
08:54:21 <SamB> I must have done something wrong when I tried to check if it was or not, sorry!
08:54:28 <SamB> okay, so anyway...
08:54:43 <SamB> I'm using GHC 6.4
08:55:03 <SamB> and Alex 2.0
08:56:27 <robdockins> try deleting CmmLex.hs and CmmParser.hs and regenerate.
08:56:30 <JohnMeacham> yay. it took me half the day, but I finally wrote a new code generator for jhc. it is ~500 lines of haskell, which as y'all know is a huge amount of haskell for how powerful each line is :)
08:56:31 <booger> hello
08:56:51 <booger> has anyone built a databse interface to haskell yet?
08:56:59 <SamB> actaully, I think my Alex is crazy.
08:57:06 <robdockins> JohnMecham: how are you doing code gen? BURS?
08:57:06 <pesco> JohnMeacham: Woot, maybe that'll solve my problem which was persisting.
08:57:31 <SamB> it seems to think '\xg0' is a valid escape code...
08:57:34 <tromp_> wow, John, 500 lines in only half a day? I barely manage 50 lines a day
08:57:35 <robdockins> oh wait... you do compile to C.  nevermind
08:57:40 <JohnMeacham> pesco: not right away, but it will finally allow me to write the optimizations that will solve that problem.
08:57:53 <pesco> JohnMeacham: Ah, very good. :)
08:57:56 <booger> APL supposedly had fewest lines of any language
08:57:59 <booger> ;)
08:58:20 <ndm> booger, indeed - but thats because they huffman encoded words
08:58:26 <SamB> robdockins: what version of alex are using?
08:58:39 <ndm> i.e. common words became a single character, with an obscure symbol
08:59:01 <robdockins> samb -- humm.  I need to revisit the escape codes,  I just got some clarification from Norman Ramsey about something.  I can fix that while I'm at it
08:59:23 <robdockins> samb: Alex 2.0.1 
08:59:24 <SamB> robdockins: no, Alex is generating those ""# literals with stuff like that in
08:59:36 <SamB> I guess they fixed that in 2.0.1?
08:59:59 <robdockins> samb: not sure
09:00:42 <SamB> either that, or 2.0.1 generates slightly less states or whatever those tables are...
09:03:35 <SamB> its going up to \xh7..
09:04:01 <robdockins> I suspect that is an Alex bug.
09:04:15 <booger> huffman encoded?
09:04:18 <shapr> dcoutts: Ok, I got yhc running on debian/unstable. It really does take five minutes from no clue to binary.
09:04:23 <booger> you mean like iverson?
09:04:27 <dcoutts> shapr, woot!
09:04:33 <booger> whats woot!
09:04:41 <booger> liek 'i got blowsn!'
09:04:47 <booger> 'i got blown!'
09:05:11 <SamB> robdockins: no kidding!
09:05:15 <shapr> Next question is, will it compile as smoothly in the scratchbox environment?
09:05:19 <dcoutts> JaffaCake, hah, I repacked the libHSgtk.a into 4 gtk${n}.o files except that I've got duplicate .o files in my libHSgtk.a file so when I unpack it they overwrite each other! Doh!
09:05:29 * dcoutts goes off to try something more sophisitcated
09:06:48 <JaffaCake> dcoutts: in GHC we have one libHSbase.a, but multiple HSbase.o files, and there's a grotesque hack in GHC itself (!!) to link the right things
09:07:07 <JaffaCake> take a look in ghc/compiler/Packages.lhs in 6.4.1
09:07:12 <dcoutts> ok, ta
09:07:22 <JaffaCake> I don't think you need to go that far
09:07:35 <JohnMeacham> pesco: it is also written with adding region inference in mind, so I can finally get on that.
09:07:48 <SamB> Igloo: why are there no debs for alex 2.0.1 in testing?
09:07:49 <JaffaCake> maybe you could just have multiple libHSgtk.a files
09:08:18 * JaffaCake has to go, bye folks
09:13:44 <pesco> JohnMeacham: Getting better and better.
09:13:47 <dmiles_afk> is Christoph Benzmueller ever in here?
09:14:49 <dmiles_afk> i just looking for connections between infernce provers (expert systems) and haskell programs
09:18:23 <Philippa> at the term or value levels?
09:18:30 <Philippa> haskell programs are constructive proofs of their types, for example
09:19:31 <robdockins> ohhh... except that bottom means the corresponding logic is inconsistent
09:20:39 <dmiles_afk> hrrm i think its nice to get yhe language and the prof theory cloe as possible
09:21:23 <dmiles_afk> .. language and the proof theory close as possible.. but probly the haskel in this case is the skelitall of the logic.. but not dirrect salving
09:22:06 <dmiles_afk> i say on the term level
09:23:01 <dmiles_afk> mainly i am trying to let resolultion work agaist functions that are descriptinve terms it can unify
09:23:39 <dmiles_afk> motherOf(bill) = dautherof(grandma(billl))
09:24:37 <dmiles_afk> well i looked at interhational CADE conferneces and theorem prvers written in haskell did alot betterthe their C counterparts
09:24:51 <dmiles_afk> yet there was lots of lazienss
09:31:22 <dmiles_afk> nice: First-Order Logic Resolution Theorem Prover In Haskell
09:38:44 <lispy> "On the other hand, buddha is not useful for diagnosing why your program runs too slowly or uses too much memory. "
09:39:02 <lispy> hmm...so that means how i intended to use buddha is not supported :)
09:50:19 <dcoutts> yay! I got gtk2hs to work on win32 with ghci without "symbol relocations overflows"
09:51:19 <lispy> heh, nice
09:51:29 <lispy> making things work on win32 is always such a pain
09:51:35 <lispy> i'm growing to really hate COM
09:52:16 <lispy> it's extremely inefficient if you need to do a lot calls, and passing data between languages is hell (whichis ironic...) unless you're using VB and communicating with something MS wrote
09:52:21 <ndm> dcoutts, have been bugging tom about FFI repeatedly :)
09:52:34 <dcoutts> ndm, good good!
09:52:52 <dmiles_afk> i think one language needs to fully broker the data
09:53:14 <dcoutts> lispy, when I used to do win32 com stuff comercially I came to the same opinion.
09:53:54 <dmiles_afk> i think thou haskell would run just as efficintly if it used all com object though right?
09:54:08 <dmiles_afk> maybe just not on construcion so much.. but minus that.. about the same?
09:55:08 <ndm> dmiles_afk: not a chance, every haskell object is really small and tight - since thats what most haskell programs do all the time
09:55:21 <ndm> and every COM object has interfaces etc, which tkae up more memory, more time ...
09:56:09 <dmiles_afk> well i can think up examples that getting any memeber is expensive while its in the the object
09:56:21 <dcoutts> COM objects have to have coarse interfaces to keep the calling overhead down
09:56:29 <Igloo> SamB: Probably no good reason
09:56:48 <dcoutts> especially for out-of-process COM
09:58:25 <dmiles_afk> i am trying to write a resolutuion/unification based system combining parts of 3-4 differt programming languages .. haskell has fit it's way in
09:58:41 <SamB> Igloo: so, get to work!
09:58:42 <dmiles_afk> trying to use the greatest comon denometor of the datatype currently
09:58:48 <SamB> unless it is just sitting in unstable for no reason?
09:59:04 <ndm> dcoutts, i took a look at Damien Sereni's work about termination, i couldn't see anything that was to do with laziness - did i miss something or is it entirely strict?
09:59:30 <Igloo> SamB: I'm planning to go through the packages from the toolchain up once http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=346248 is fixed
09:59:51 <dcoutts> ndm, he's been presenting stuff to us about lasiness via an encoding as closures
09:59:54 <SamB> Igloo: but... 2.0.1 is a bugfix!
10:00:12 <ndm> dcoutts, do you know if he has anything published on that bit yet?
10:00:23 <Igloo> But working on alex before ghc works properly everywhere is a pain
10:00:25 <dcoutts> ndm, maybe he's not written about that yet, it's not his main focus
10:00:28 <dmiles_afk> this laziness is not totally the same defination of laziness most people use
10:00:38 * Igloo AFKs
10:01:09 <ndm> dcoutts, ok - there was a small laziness as a closure example in one of his papers, i'll probably email him once i've got through that and the tech report
10:01:28 <dcoutts> ndm, right
10:01:34 <dmiles_afk> what i think means is the data represents the program that is used for the last side effect before it can be used
10:01:45 <dmiles_afk> (thats lazy)
10:02:10 <dmiles_afk> as you guys are saying a closure
10:02:41 <SamB> so it doesn't finish compiling always?
10:02:46 <dmiles_afk> myself want to use them on skolems excusively ;P
10:03:37 <SamB> Igloo: so it can't be built with a GHC that is already built?
10:04:51 <dmiles_afk> domt mind me.. i am learnign your guys' language
10:07:34 <dmiles_afk> i am hoping to take the engine called Vampire and creating prolog and haskell and lisp FFI to it instead of the other way arround
10:08:04 <dmiles_afk> and making sure those laguatges can call back to the KB so the very best modules for proving can be written in those labguages
10:08:52 <dmiles_afk> making the toplevel inference harness the consumer
10:09:03 <dmiles_afk> but everyht
10:22:34 <glasser> anyone have any (simple) examples of using STM?
10:25:27 <glasser> basically just a demo
10:25:29 <Lemmih> glasser: atomically $ do tvar <- newTVar 10; readTVar tvar
10:25:42 <SamB> simple examples don't show you the point though
10:25:49 <glasser> well, it should probably do a bit of forking :)
10:26:26 <glasser> yeah, this is for a class -- I'm doing a bit where I show off a bunch of different monads and I want a quick demo of "STM is cool"
10:26:56 <glasser> eh, I guess nothing simpleenough to be quickly legible will show the point
10:27:00 <xerox> solve some classical problem with threads?
10:27:05 * SamB wonders how to make a cabal package depend on Alex 2.0.1
10:27:29 <Lemmih> SamB: Cabal doesn't track binary dependencies at the moment.
10:27:46 <SamB> Lemmih: for building
10:28:08 <SamB> it won't build right with 2.0
10:28:55 <Lemmih> Configure with --with-alex=path-to-alex-2.0.1
10:29:37 <SamB> Lemmih: well, yes, but there should be a way to say "refuse to even try building with earlier versions of Alex"
10:29:40 <Igloo> SamB: Not on sparc
10:29:59 <Lemmih> SamB: Well, there isn't. Not yet.
10:30:15 <SamB> Lemmih: well okay then
10:31:03 <SyntaxNinja> SamB: cabal doesn't, in general, have any way of knowing what versions of binaries you have installed.
10:31:38 <SamB> SyntaxNinja: does it have a general build-tool mechanism then?
10:32:08 <SyntaxNinja> SamB: what do you mean?
10:33:09 <SimonRC> you people are so slow.
10:33:28 <SamB> well, I mean it tells me what haddock, happy, alex, hsc2hs, cpphs, and greencard it is going to be using
10:33:43 <xerox> SimonRC: don't worry, be happy.
10:33:48 <SamB> I'm assuming that it is hardcoded to handle all of these?
10:34:08 <edwinb> simon: that's because we're lazy
10:34:21 <SamB> so how hard is it to hardcode how to find what versions they are?
10:34:37 <SamB> don't they all support --version?
10:35:19 <SyntaxNinja> SamB: yeah, it's kinda hard-coded to use these, I don't know if they support version. it would be nice to add something like a version field to the Program type; or make a function like Program -> IO Version
10:35:31 <SimonRC> oops, wrong window
10:35:40 * SimonRC will have to get used to this...
10:35:40 <SyntaxNinja> but obviously, it's going to be specific to the tool.
10:35:50 <SyntaxNinja> SimonRC: a bit slow, 'eh?
10:35:55 <SamB> yeah...
10:36:26 <jophar_> hello again
10:36:52 <dcoutts> SyntaxNinja, eek! people are talking about removing: foo 0 = ...
10:36:57 <SamB> is this the return of jophar?
10:37:00 * SamB cowers
10:37:03 <jophar_> :O
10:37:10 <SimonRC> well, I make this inuenndo, and you lot take 7 minutes to respond.
10:37:12 <jophar_> what did I do?
10:37:15 <SimonRC> arg
10:37:22 <jophar_> ^^
10:37:25 <SimonRC> ww again
10:37:36 <dcoutts> SyntaxNinja, eliminating numeric constants as patterns seems a bit extreem to me.
10:38:01 <SamB> jophar_: I'm not sure, I don't remember you saying anythng before ;-)
10:38:07 <dcoutts> they're so innocent and useful, and convenient
10:38:10 * dcoutts grumbles
10:39:50 <xerox> dcoutts' secret love for numeric named bindings.
10:40:11 <Igloo> SyntaxNinja: Any idea why my attempt to subscribe to the haskell' mailing list failed?
10:40:22 <SyntaxNinja> Igloo: in what way did it fail
10:40:40 <Igloo> I'm not getting any mail from the list
10:40:41 <SyntaxNinja> dcoutts: tell the list :)
10:40:51 <jophar_> samb ^^ hehe
10:41:04 <xerox> Oi jophar_ :-_)
10:41:23 <jophar_> ahahah he learned to speak portuguese ^^
10:41:27 <SyntaxNinja> Igloo: did you get a confimration email?
10:41:36 <jophar_> :D
10:41:44 <jophar_> ciao  xerox 
10:41:46 <jophar_> =)
10:41:49 <xerox> Yay!
10:41:57 <Igloo> I got the standard "Request received, the list admin may have to approve this" mail
10:42:18 <SimonRC> The problem with integers is that they do not have a nice recursion mechanism.
10:42:19 <SimonRC> I was having problems trying to find the minimum of lists of integers, some of which were infinite.
10:42:19 <SimonRC> I need to invent "data Nat = Zero | Succ Nat"
10:42:19 <SimonRC> *re-invent
10:42:41 <xerox> Integers?
10:44:13 <edwinb> I'm not surprised you were having problems trying to find the minimum element in an infinite list...
10:44:19 <edwinb> or have I misunderstood?
10:44:47 <SyntaxNinja> Igloo: the list doesn't require approval for subscription, and I don't see any pending request that looks like that. can you forward me the email?
10:45:42 <Igloo> No; I'll try again and keep it this time
10:46:29 <Igloo> Ah, possibly I didn't get a mail, just that standard text on the web submission, actually
10:47:36 <Igloo> OK, looks like it worked this time
10:48:37 <SyntaxNinja> goooood
10:48:45 <SamB> robdockins: okay, it built fine now
10:48:46 <dcoutts> SyntaxNinja, two people have emailed in response to the numeric literals question, me and Aaron.
10:51:33 <SamB> why does ./Setup.hs haddock only run haddock on exposed modules?
10:52:22 <SamB> I mean, haddock would still like to see other modules, even if it isn't generating documentation pages for them
10:53:08 * SyntaxNinja turns of "forward me all spam" from haskell' mailing list
10:53:51 <SamB> SyntaxNinja: yeah, that thing is annoying
10:53:53 <SyntaxNinja> dcoutts: OK. is there anything you need me to do?
10:54:12 <SyntaxNinja> SamB: I think that the latest cabal doesnt' do that anymore, can't remember 1.1.3 behavior.
10:54:49 <dcoutts> SyntaxNinja, no, unless it looks like people are going to make that change, in which case we'll have to start a "save the numeric literals" campaign!
10:56:06 <SyntaxNinja> dcoutts: hehe. well, do so if you feel it's necessary.
10:56:26 <dcoutts> SyntaxNinja, I'll follow the discussion closely :-)
10:56:31 <SamB> SyntaxNinja: I'm not sure which version that is, really
10:57:07 <SamB> because I think that it was using the version installed for hugs...
10:57:12 <SamB> or not
10:57:34 <SyntaxNinja> SamB: the latest is 1.1.3, can't remember what that does, but if you say it only does exposed modules, I believe you.  1.1.4 (darcs version) does hte right thing.
10:57:50 <SamB> okay, it does that with 1.1.3
10:58:07 <eivuokko> You mean the "k patterns" thing on haskell-prime ml?  I didn't really understand why they are bad.  (I do dislike n+k and ~ patterns tho)
10:58:24 <SamB> I think I was using 1.1.3 all along
11:00:38 <SamB> SyntaxNinja: nice
11:00:51 <SamB> well, I mean, its nice that some version does the right thing.
11:03:37 <SamB> hmm, does "./Setup.hs haddock" also not run alex with -g ?
11:07:07 <dcoutts> SyntaxNinja, should we be sending in our suggestions around now then? ndm and I were thinking about some FFI extension to let yhc have genuinely portable FFI without needing #ifdefs.
11:07:24 <dcoutts> yhc might need to do it anyway, so it'd be better to have it standardised
11:07:45 <SamB> dcoutts: can you have that with no ifdefs?
11:07:49 <dcoutts> or at least recognised so it doesn't get reimplemented differently later
11:08:01 <SamB> I don't know if you can write portable C programs without ifdefs...
11:10:15 <dcoutts> SamB, right, not C because its compiled
11:10:21 <dcoutts> SamB, but yhc uses bytecode
11:10:38 <dcoutts> it ought to be possible to do it there
11:10:38 <SamB> oh
11:11:02 <SamB> I really doubt that helps much...
11:11:18 <dcoutts> for example,
11:11:34 <dcoutts> many c libs are basically the same on all arches
11:11:36 <SamB> ... when the C-level types might not be the same everywhere
11:11:47 <dcoutts> eg gtk
11:12:22 <dcoutts> some c libs use a different calling convention on win32 vs unix
11:12:32 <dcoutts> some have slightly differnt symbol names
11:12:40 <dcoutts> but otherwise it's the same
11:13:04 * SamB walks the dog
11:14:12 <dcoutts> SamB, so in yhc it might be just a little lookup table to say which symbol name to lookup and which calling convention to use for this FFI decl.
11:14:42 <dcoutts> that way a bytecode prog can be built on one paltform and still work on another, at least for portable C libs
11:15:17 <dcoutts> so it's a bit like #ifdefs but at the language level rather than at the preprocessor level
11:15:39 <dcoutts> since with yhc you can't do arch-specific ifdefs and get portable bytecode
11:16:04 <dcoutts> but the bytecode could contain all the bits for each arch so it could run on any of them
11:16:43 <dcoutts> in practice there should only be a few platform specific differences necessary
11:17:17 <dcoutts> eg I reckon for gtk2hs there would be 20 ish out of 1500 C functions.
11:18:19 <SamB> hmm
11:18:48 <dcoutts> build on x86 linux, deploy on a pda, win32, etc
11:18:54 * SamB hasn't started yet because he remembered he had to put on lots of clothes cause it is bitter cold outside
11:18:59 <SamB> ah, yeah.
11:19:12 <SamB> okay, then, I guess you really do need crazy things like that!
11:19:23 <SamB> good luck figuring out how to define "platform"
11:21:17 <eivuokko> I wonder if it could be solved by making ffi bindings lazy.
11:22:36 <dcoutts> eivuokko, that'd be tricky for a complier that produces object code
11:22:56 <dcoutts> eivuokko, though for jhc for example it could emit C code with #ifdefs
11:23:13 <dcoutts> but for ghc it'd be pretty much impossible I think
11:23:43 <eivuokko> dcoutts, Yeah, I meant that it'd be implementation detail for yhc.  Only resolve ffi binding on first call to it.
11:24:19 <dcoutts> eivuokko, but that still leaves the problem that on unix it's called "foo_bar" and on win32 its "foo_bar_utf8"
11:24:51 <dcoutts> they are the same function on both arches, with the same calling convention, but a different symbol name
11:24:57 <eivuokko> Surely not: my_foo_ar = if windows then foo_bar_utf8 else foo_bar?
11:25:10 <dcoutts> eivuokko, oh. Yes. Ok. :-)
11:25:21 <eivuokko> Naturally, your solution is better if you got plenty of funcs
11:25:43 <eivuokko> But I was interested if it was possible by just being lazy. :)
11:26:00 <dcoutts> eivuokko, actually you may be right that it can all be done that way.
11:26:22 <dcoutts> though such code would not be portable between ghc & yhc
11:26:30 <eivuokko> Bugger..
11:26:41 <eivuokko> Good point :-(
11:26:43 <dcoutts> ghc has to resolve the call statically and yhc has to do it dynamically
11:27:23 <dcoutts> so we were thinking of something which amounts to ifdefs for ffi decls but as part of the language rather than above it
11:28:09 <dcoutts> then ghc could resolve it statically, jhc could emit C with ifdefs and yhc could keep a table of each possibility and resolve it when it knows which arch it is running on.
11:28:17 <eivuokko> Btw, I have wished for dynamic loading of ffi bindings.  There's funcs in win32 api that require NT or w2k and won't exist on older Windowses
11:28:53 <dcoutts> eivuokko, right, one has to use nasty function pointer stuff & query the linker for symbols
11:29:03 <monochrom> heh, let's force the phasing out of other windowses
11:29:24 <dcoutts> it should be possible, but it may be platform specific
11:30:06 <dcoutts> http://haskell.org/ghc/docs/latest/html/libraries/unix/System-Posix-DynamicLinker.html
11:30:20 <dcoutts> you'd need soemthing else on win32
11:30:48 <eivuokko> I have something like that written for win32, it's not hard, but funptrs are ugly in ffi
11:31:03 <dcoutts> yeah
11:31:21 <dcoutts> perhaps all you need is another ffi preprocessor :-)
11:31:49 <eivuokko> It is, imo, best to write c-wrappers that do initialisation once.
11:32:11 <eivuokko> But it is huge drawback from haskell-only solution
11:32:27 <eivuokko> (aesthetically, atleast :)
11:34:52 <dcoutts> it could be done in Haskell with unsafePerformIO :-)
11:35:15 <dcoutts> that'd give you lazy binding to foreign function pointers
11:36:02 <dcoutts> thingFunPtr = unsafePerformIO $ dlopen >>= dlsym
11:44:43 <kevind> Cale: you here?
11:45:12 <eivuokko> Oh, the issue with k-patterns is that they make type signature Num a => a, and hence general case requires dynamic comparing?
11:45:27 <SamB> monochrom: wait until ReactOS works ;-)
11:45:46 <eivuokko> ReactOS looks pretty good.
11:46:37 <SamB> of course, there still isn't a free 9x
11:47:29 <SamB> I wonder if it is possible to do a bit more memory protection in a 9x?
11:48:03 <SamB> to keep the shared DLLs from getting corrupted by any old thing, I mean....
11:48:05 <eivuokko> You'd need to introduce security control in kernel..
11:48:08 <monochrom> Yes, if you don't mind it rejecting some poorly written programs.
11:48:21 <eivuokko> ..which is pretty big deal probably
11:48:27 <SamB> not for security, just for less crashing
11:49:16 <SamB> the difference being that for less crashing you just have to keep common crash causes from occuring, not worry about priveledge escalation...
11:50:30 <SamB> of course, a free 9x would probably have a 32-bit kernel
11:51:54 <SamB> I'm not really sure what the point would be, now that the soundblaster is dead...
11:51:59 <eivuokko> Uhm, do you mean non-mixed-16bit kernel?  It is 32bit in a sense it requires "32bit".  It is no in a sense that 16-bit device drivers run free in kernel. iirc.
11:52:30 <SamB> well, I mean most of the code would be 32-bit, it would probably still support 16-bit drivers...
11:53:18 <SamB> I mean, I don't suppose you could call it 9x if it didn't
11:53:24 <SimonRC> In most langs, "let foo = map show [1..]" or equivalent is an infinite loop.  But in Haskell, this infinite loop runs in a millisecond.
11:53:24 <monochrom> 9x has a 32-bit kernel, but its policy is lax, so as to run 16-bit programs as-is.
11:53:26 <SimonRC> :-)
11:54:18 <SamB> monochrom: how much of the kernel is actually 32-bit?
11:54:26 <monochrom> Yeah, a benefit of lazy evaluation is that imperative programmers are puzzled. :)
11:54:33 <eivuokko> What did you do to make it take that long, SimonRC? ;)
11:54:48 <monochrom> Ok, I don't actually know the guts of 9x :)
11:55:30 <SamB> the DOS boxes are apparantly paper-thin
11:55:34 <eivuokko> We know for sure it uses features that require 32bits/386, and we do know that 16-bit drivers can kill kernel.
11:55:54 <monochrom> Actually, I can infer.  The kernel has to access the full address space, so it has to be 32-bit in nature.
11:56:01 <SamB> well, yes, it uses 32-bit features for everything
11:56:13 <SamB> but, how much of the code is aware of this"?
11:56:17 <SamB> s/"//
11:57:01 <monochrom> The kernel runs in protected mode, ring 0.
11:57:24 <SamB> so?
11:57:51 <SamB> can't you run DOS code in protected mode?
12:01:39 <eivuokko> I might remember wrong, but in that particular mode vs "real mode" there's diffrent prefixes for 16-bit and 32-bit registers that are required.
12:02:15 <eivuokko> Ehm, diffrent opcode prefixes for actions that use 16/32bit registers
12:02:15 <SamB> you can set up 16-bit code segments or something like that
12:02:33 <SamB> I'm not arguing that 16-bit = 32-bit here
12:02:43 <monochrom> 1. Pointers in the kernel are definitely 32-bit.
12:02:50 <eivuokko> DOS code = 16-bit, no?
12:03:06 <SamB> monochrom: every single pointer?
12:03:54 <monochrom> 2. The kernel sets up different page tables for different processes.  The page table controls how much of the memory space the process can see.  9x kernel sets it up so that every process sees all, so as to accomodate old programs.
12:04:16 <SamB> certainly 9x has 32-bit userspace
12:04:25 <monochrom> The latter is the real difference between 9x and NT,Linux.
12:04:49 <SamB> and only half or so of the address space is shared between processes
12:13:48 * SamB wonders why win.com is so big
12:15:08 <monochrom> heh, people like lotteries.
12:16:14 <SamB> hmm, apparantly windows 98 doesn't want to start under freedos because it doesn't implement a certain internal DOS call
12:18:43 * SamB uses the PrintScreen key to see the message long enough to do something about it
12:19:12 * jethr0 's not sure that you can get win 9x to run inside freedos.
12:19:56 <SamB> of course you can!
12:20:09 <SamB> maybe you need to recompile the kernel, though
12:20:25 <jethr0> hmm, ok. i would have thought that behind the scenes MS would have used tons of undocumented features to get win 9x to run "on top" of dos
12:20:57 <jethr0> how would you solve the above 32-bit issues "under" dos? with a 16bit dos?
12:21:00 <SamB> why would they bother when they could use just one or two to get it loaded past dos?
12:21:09 <SamB> or beside DOS?
12:21:26 <SamB> or over DOS, which is to say overwriting DOS in memory...
12:21:34 <jethr0> *aahh*, you mean you want to _start_ win 9x from freedos. i thought you wanted to execute it like win3.1 :)
12:22:27 <SamB> hmm, I wonder what this extra data at the end of vmm32.vxd is...
12:23:39 <jethr0> "evil data", it's something like dark matter :)
12:23:48 * SimonRC goes
12:24:31 <jethr0> bye
12:30:18 <shapr> jiihaa
12:30:33 * shapr throws lambdas at jethr0 
12:30:59 <shapr> salut cinema 
12:31:11 <cinema> shapr, salut
12:31:37 <cinema> shapr, we approaching the 200 users regularly !
12:31:59 <tromp> well, 2 of them are me:)
12:32:26 <cinema> ok, wait till newt week, we will be 201
12:32:33 * jethr0 catches all the lambdas and playfully attacks shapr with PIs
12:35:24 * jethr0 's PIs all missed their target, which magically disappeared
12:38:38 <franka> Hello.
12:38:40 <SamB> huh, the function is INT2F/1231, which according to RBIL (Ralph Brown's Interrupt List) is: Windows95 - SET/CLEAR "REPORT WINDOWS TO DOS PROGRAMS" FLAG
12:38:59 <SamB> franka: hello
12:39:07 <franka> Hi, SamB 
12:39:09 <jethr0> SamB: what the h*ll are you working on? are you doodling with reactos or just playing around with win 95?
12:39:15 <jethr0> hello
12:39:30 <franka> Hi, jethr0 
12:39:58 <SamB> jethr0: monochrom thinks 9x is thirty-two bit
12:40:00 <SamB> I don't
12:40:23 * franka reads logs.
12:41:08 <jethr0> google says a lot about 32bit in conjunction with win95
12:41:26 <jethr0> but win95 could address more than 2^16 byte of mem, right?
12:41:27 <shapr> jethr0: PIs?
12:41:39 <jethr0> shapr: ya, like lambda/pi calculus.
12:41:43 <shapr> oh!
12:41:48 <SamB> jethr0: well, I mean, I think that much of the kernel is 16-bit code
12:41:54 <jethr0> i know, it was pretty lame. but you didn't even flinch :)
12:42:34 <shapr> y0 franka, how's life?
12:42:36 * SamB throws processing instructions at jethr0 
12:42:39 <jethr0> SamB: that could well be. but VMM would have to support 32bit and some drivers too, if you want to map your devices into memory > 2^16
12:42:46 <franka> Hi, shapr
12:42:54 * jethr0 counters with a triple NOP
12:43:00 <franka> Life is depressing.
12:43:00 <SamB> jethr0: <?process-me-thouroughly?>
12:43:11 <shapr> franka: I'm right there with ya.
12:43:15 <jethr0> ??
12:43:21 * SamB probably throws ill-formed processing instructions at jethr0 
12:43:23 <franka> You have my condolences.
12:43:24 <SamB> XML stuff
12:43:31 <shapr> franka: and you have mine...
12:43:49 <SamB> jethr0: well, yeah, it would have to use 32-bit stuff
12:43:56 * jethr0 is confused and dazzled by samb's attack
12:44:14 <franka> Life is, apparently, not one of those things you get better at with experience.
12:44:48 <jethr0> SamB: did you look at that DLL as hex-code?? what did you expect to find?
12:47:28 <jethr0> whenever the channel goes dark suddenly, i've always just said sth
12:47:31 <jethr0> this really freaks me out
12:52:45 <jethr0> ECHO
12:53:29 <eivuokko> Uhm
12:53:48 <jethr0> SamB: did you look at that DLL as hex-code?? what did you expect to find?
12:53:53 <eivuokko> It wasn't that, jethr0, just that nobody was saying anything.
12:54:50 <jethr0> hehe
12:54:57 <SamB> jethr0: next time it happens, /ping yourself, mmkay?
12:55:08 <jethr0> this stupid IRC. i never know when i've been disconnected
12:55:18 <jethr0> why can't we use some sane protocol :)
12:55:18 <SamB> yeah, I know what you mean
12:55:59 <SamB> my sister is having trouble watching my pirated anime on the computer she uses, which runs Windows 98...
12:56:13 <SamB> seems to be some kind of codec problem
12:56:31 <jethr0> i guess calling support is out of the question *g*
12:56:56 <Cale> jethr0: what client do you use? If you're using X-Chat, you can turn on a little ping-meter, which usually helps me to notice when I've likely been disconnected at least.
12:57:03 <Cale> SamB: mplayer runs on windows
12:57:49 <jethr0> Cale: i know. i'm using irssi which until recently showed my latency, but now it doesn't anymore :(
12:58:35 <jethr0> ya well. if i wanted to fix everything that was misconfigured on my system, i wouldn't get any haskell coding done...
12:58:45 <Cale> hehe
12:59:13 <Cale> I think Control.Parallel.Strategies needs a more strategic location in the libraries. :)
12:59:41 <jethr0> :)
13:00:17 <jethr0> i'm studying for my 1 hour oral crypto exam, and will start implementing some cryptanalysis code in haskell soon
13:00:43 <jethr0> certainly nothing new, but learning is so much more fun in haskell!
13:01:15 <jethr0> i also wanted to see how fast haskell's long numbers are when benchmarked against a state-of-the-art long number library for c
13:03:40 <tromp> doesn't ghc use those same gmp libraries?
13:03:46 <eivuokko> Yeah
13:04:13 <jethr0> didn't know that
13:04:38 <SamB> the thing is, it worked fine before!
13:04:41 <SamB> but now it doesn't.
13:04:57 <eivuokko> I wouldn't be suprised if ghc was a bit faster than naive use of gmp, because ghc also uses normal ints for small numbers and garbage collection for memory.
13:06:07 <jethr0> for a university project i programmed with their own bignum lib. it was only medium difficult assignments, but using that library _really_ sucked.
13:06:17 <eivuokko> But due to license issues (and there are also issues how ghc rts replaced gmp memory allocation), I am trying to replace gmp in ghc.
13:06:37 <jethr0> i guess doing the whole thing in haskell would've been much more fun, and might even have been faster (due to better optimisations, maybe, *wishful thinking*)
13:06:51 <jethr0> yes, i saw the post when i googled for it :)
13:07:08 <jethr0> does gmp also do non-integer arithmetic?
13:07:11 <roconnor> what's the problem with gmp?
13:07:17 <jethr0> lgpl
13:07:21 <eivuokko> Unfortunately, there is no optimisations for stuff like a+b*c or a+b*2 etc that gmp provides special functions for
13:07:30 <sieni> jethr0: why would lgpl be a problem?
13:07:30 <eivuokko> (in ghc)
13:07:48 <eivuokko> sieni, it is annoying in commercial projects.
13:08:08 <roconnor> it is?
13:08:14 <eivuokko> It is.
13:08:19 <jethr0> http://hackage.haskell.org/trac/ghc/ticket/601
13:08:20 <roconnor> in what way?
13:08:33 <eivuokko> Providing object code for relinking isn't big deal?
13:08:45 <sieni> eivuokko: well, depends... usually you have to dynamically link against the library or provide means to relink your binary against modified version of the library, but I fail to see how that would be a poblem
13:08:47 <eivuokko> It's major pain.  And it continues, what, three years.
13:08:49 <sieni> problem
13:09:01 <eivuokko> sieni, dunamically linking doesn't work with for example COM, too well
13:09:11 <roconnor> you can't statically link with an lgpl library?
13:09:17 <eivuokko> Because GHC replaces GMP allocation functions no two ghc rts can be loaded in one executable
13:09:30 <eivuokko> roconnor, Yes, but as I said, you need to provide obejct code for relinking
13:10:00 <dcoutts> roconnor, well you can but then you have to provide some other way of letting people replace your prog's use of a lib with a modified version
13:10:15 <dcoutts> the easiest way to do that is dynamic linking
13:10:16 <SyntaxNinja> lgpl is a problem for Haskell code,  many people release software as lgpl-minus-that-lame-relinking-clause, as the OCaml license.
13:10:21 <pesco> Is it just me, or is there something wrong with freenode?
13:10:22 <sieni> eivuokko: maybe COM is the problem and not LGPL
13:10:30 <roconnor> Wow, the lgpl is totally broken.
13:10:32 <dcoutts> or you could supply all the other .a/.o files needed to build the app
13:10:43 <eivuokko> sieni, you are allowed your opinion.
13:10:46 <dcoutts> roconnor, there is a retionale for that requirement
13:10:58 <dcoutts> rationale
13:11:00 <roconnor> oh?
13:11:09 <sieni> SyntaxNinja: ocaml has a very crappy license for their compiler (QPL)
13:11:20 <dcoutts> if it's lgpl then the user ought to be able to modify it
13:11:29 <eivuokko> That is the gist of lgpl.
13:11:40 <roconnor> hmmm
13:11:48 <dcoutts> but if it's hard wired into your program then that's rather hard
13:11:55 <roconnor> kinda makes the lgpl useless
13:12:08 <sieni> roconnor: why?
13:12:11 <dcoutts> well one can simply add an exception
13:12:13 <eivuokko> No, it is good idea.  It's just that ghc rts takes gmp memory allocation for itself.
13:12:23 <dcoutts> if you want to make an lgpl Haskell lib
13:12:27 <sieni> roconnor: you can provide the lgpl library as a dynamic library and load that
13:13:01 <roconnor> the purpose of the lgpl is to promote widespread use of the library, but if people can't use lgpl librarys, then it is useless
13:13:29 <sieni> like: it's not so hard to call dlopen() and dlsym() in your proprietary binary 
13:13:31 <SyntaxNinja> doesn't ghc do cross-module inlining and stuff that makes relinking impossible?
13:13:44 <sieni> and windows provides a similar interface
13:13:51 <pesco> Not even to speak about jhc...
13:14:20 <flux__> inlining should be implemented in the linker, no?-)
13:15:06 <eivuokko> I am fairly certain you can always relink binaries to diffrent gmp, given they have same binary interface.
13:15:49 <eivuokko> And *anyway* there are situations when dynamic linking isn't a good option, for example building installers or standalone progs.
13:16:10 <eivuokko> (even if that solved the problem usually, but it doesn't due the memory management issues)
13:17:05 <sieni> eivuokko: nothing prevents you from providing the dynamic libraries yourself and dynamically linking against them
13:17:51 <sieni> Windows has LoadLibrary and GetProcAddress
13:18:16 <eivuokko> sieni, how do I solve memory management issue with ghc rts, even if I had working version of multi-precision integer library with exact same interface as gmp?
13:18:45 <eivuokko> ghc rts replaces gmp memory allocation so that gmp allocated memory gets garbage collected.
13:19:17 <palomer> hrm
13:19:20 <palomer> I want to draw text
13:19:24 <palomer> and then graphics over the text
13:19:29 <palomer> what's the best toolkit for doing this?
13:19:31 <SyntaxNinja> here's malcolm wallace's mod to lgpl to make it practical: As a relaxation of clause 6 of the LGPL, the copyright holders of this library give permission to use, copy, link, modify, and distribute, binary-only object-code versions of an executable linked with the original unmodified Library, without requiring the supply of any mechanism to modify or replace the Library and relink (clauses 6a, 6b, 6c, 6d, 6e), provided that all the other terms of clau
13:19:38 <sieni> how would you fix that with a statically linked library?
13:19:42 <SyntaxNinja> http://www.cs.york.ac.uk/fp/HaXml/COPYRIGHT
13:19:50 <palomer> the graphics will include shaded boxes with text inside
13:20:03 <dcoutts> palomer, cairo
13:20:10 <dcoutts> @where cairo
13:20:11 <lambdabot> I know nothing about cairo.
13:20:13 <dcoutts> hah
13:20:16 <dcoutts> @where gtk2hs
13:20:17 <lambdabot> http://haskell.org/gtk2hs/
13:20:17 <eivuokko> sieni, Ah, ok, it's windows specific, I think the relevant flag in unixy system is the local flag.
13:20:46 <palomer> note that I care nothing about performance
13:20:46 <dcoutts> @where+ cairo http://haskell.org/gtk2hs/
13:20:47 <lambdabot> Done.
13:21:47 <dcoutts> palomer, cairo can do all that and output it on screen or to a file
13:22:35 <palomer> what's the easiest to use?
13:23:20 <dcoutts> palomer, cairo. :-)
13:23:28 <dcoutts> it has a nice api
13:24:05 <palomer> ok, I'm sold
13:24:19 <dcoutts> :-)
13:24:44 <palomer> is there a haskell parser available anywhere?
13:24:57 <palomer> I want to implement a type checker for haskell code
13:25:02 <palomer> but I don't feel like writing the grammar out
13:25:07 <eivuokko> Is it hard to make page breaks etc with cairo, if one wanted to generate reports to be printed etc?
13:25:46 <dcoutts> eivuokko, it's something they're adding, but it isn't in the 1.0 api.
13:26:03 <dcoutts> eivuokko, it'd be added as a function for the pdf & ps backends
13:26:26 <dcoutts> so, not yet, but probably eventually
13:26:34 <palomer> omg, gtk2hs isn't part of debian
13:26:45 <eivuokko> dcoutts, Yeah.  I was just thinking if I could replace some old crystallreport stuff with haskell, at work.
13:26:45 <dcoutts> palomer, I know, tell me about it!
13:27:05 <dcoutts> eivuokko, check the cairo mailing lists, it's been discussed
13:27:14 <dcoutts> eivuokko, we'll bind it as soon as it's out
13:27:18 <eivuokko> dcoutts, Thanks.
13:27:23 <eivuokko> dcoutts, Nice! :)
13:27:25 <palomer> bah, there's a debian haskell repository
13:27:56 <dcoutts> palomer, supposedly gtk2hs-0.9.10 is in a debian pipeline somewhere
13:28:26 <palomer> but where?
13:28:39 <dcoutts> it was done ages ago now and I've still not heard anything about it actually getting into experimental/unstable or whatever
13:29:07 <dcoutts> palomer, ping one of the debian packing folk here on #haskell
13:29:10 <palomer> libghc6-mogul-dev  <--is this what I want?
13:29:32 <tibbe> how could one formulate the rhs of <expr> part in, id [vars] '=' <expr> , (i.e. function declaration) in a BNF for a functional language
13:29:37 <tibbe> ?
13:29:47 <dcoutts> palomer, that should depend on libghc6-gtk-dev (or similar) which is what you want.
13:30:04 <dcoutts> palomer, but you really do need version 0.9.10 as that's the version with cairo.
13:30:10 <lispy> tibbe: check the haskell98 report :)
13:30:14 <palomer> libghc6-gtk2-dev: Depends: ghc6 (< 6.2.1+) but 6.4.1-1 is to be installed
13:30:31 <tibbe> lispy, I have, it's kinda hard to extract the part I'm interested in ;)
13:30:37 <dcoutts> palomer, which version of libghc6-gtk2-dev is it?
13:31:12 <lispy> tibbe: well, i didn't understand your question fully.  Maybe if you spend time ellaborating to me what you want to know you'll figure it out?
13:31:16 <palomer> Version: 0.9.6-0pre1
13:31:24 <dcoutts> palomer, that's ages old
13:31:35 <dcoutts> like a year and a half old
13:31:52 <dcoutts> palomer, it's not hard to build from source
13:32:32 <dcoutts> palomer, I don't know why the debian package takes so long to get in. Every other distro that has gtk2hs is quicker.
13:33:05 <palomer> and I would have thought that debian would be the distribution of choice for haskell hackers
13:33:08 <dcoutts> Igloo, ping
13:33:31 <palomer> building from source has loads of disadvantages
13:33:34 <palomer> like upgrading
13:33:35 <palomer> oh well
13:33:45 <dcoutts> Igloo, how do we find out what has happened to the gtk2hs package that marcot made?
13:34:06 <Igloo> Ask marcot?
13:34:16 <dcoutts> @seen marcot
13:34:17 <lambdabot> I saw marcot leaving #haskell 1 month, 1 hour, 5 minutes and 41 seconds
13:34:17 <lambdabot> ago, and I have missed 17 days, 22 hours, 22 minutes and 26 seconds since
13:34:17 <lambdabot> then.
13:34:23 <dcoutts> humpf
13:34:34 * Igloo doesn't remember having seen gtk2hs debs from him
13:34:55 <dcoutts> Igloo, he said about a month ago that it'd appear soon on packages.debian.org
13:35:20 <dcoutts> it was in a queue or something
13:35:45 <dcoutts> Igloo, is marcot still active?
13:35:52 <Igloo> Ah, hang on a mo
13:36:03 <tibbe> lispy, um, so if you declare a function like so: map f xs = <expr>, I need to write the BNF productions for the <expr> part, I guess it could be a function application, lambda experssion perhaps but what else?
13:36:57 <tibbe> lispy, so the BNF for a function declaration probably would look like: <fundecl> ---> id <vars> '=' <expr>
13:37:06 <lispy> tibbe: it could be a constant/literal, it could be an identifier, i could be a let, it could be .... so many things
13:37:11 <palomer> damnit, I want a parser for a small functional language
13:37:14 <palomer> everything but datatypes
13:37:23 <palomer> heck ,I'll even take datatypes
13:37:23 <palomer> :O
13:38:01 <dcoutts> @docs Language.Haskell.Parser
13:38:02 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/haskell-src/Language-
13:38:02 <lambdabot> Haskell-Parser.html
13:38:23 <dcoutts> palomer, is that what you were looking for?
13:38:32 <tibbe> palomer, I second that
13:39:08 <palomer> dcoutts: could be, lemme check
13:39:10 <Igloo> dcoutts: I can't see it anywhere obvious. marcot or whoever uploaded it should know what happened
13:39:39 <palomer> what do I do with a parsResult?
13:39:46 <palomer> hrm, this grammar seems to involved
13:40:01 <palomer> I want to parse a series of toplevel bindings
13:40:18 <lispy> i haven't looked at that implementaton, but chances are parsResult is a DAG that you can traverse
13:40:54 <dcoutts> Igloo, ok, i'll email marcot
13:41:02 <dcoutts> Igloo, thanks for looking
13:42:43 <tibbe> lispy, anything followed by another expressions must be an application right? so: id <vars> = <expr1> <expr2>
13:43:01 <lispy> tibbe: no
13:43:09 <lispy> > foo = 1
13:43:09 <lambdabot>  parse error on input `='
13:43:20 <lispy> > let foo = 1 in foo
13:43:21 <lambdabot> 1
13:43:50 <lispy> > let foo = map in foo (+1) [1,2,3]
13:43:52 <lambdabot> [2,3,4]
13:44:05 <lispy> tibbe: do those examples help?
13:44:15 <palomer> where are the example grammars located?
13:44:56 <palomer> for parsec
13:45:22 <lispy> tibbe: maybe this would help.  Look at everything you can do without defininga function, and then figure out a BNF rule to express all that
13:45:43 <tibbe> lispy,  (let foo = map in foo (+1) [1,2,3]) 1, would that even make sense?
13:45:45 <lispy> tibbe: things like constants, function application, lambda abstractions, case statements, lets and so on
13:46:13 <tibbe> lispy, actually I'm not having lets, cases, wheres and such now
13:46:31 <tibbe> lispy, basically pure lambda calculus and arithmetic expressions
13:47:00 <lispy> tibbe: oh, i was thinking of haskell...hmm..
13:47:07 <tibbe> lispy, forget the let question, I was not thinking, it would make sense although it was "overapplication"
13:47:24 <lispy> well, (let foo = map in foo (+1) [1,2,3]) 1 doesn't really make sense, because what will you do with that 1?
13:47:27 <lispy> okay
13:47:57 <lispy> you probably meant to ask: (map (1+)) [1]
13:48:04 <lispy> which does make sense
13:48:18 <palomer> map id [map]
13:48:37 <palomer> > map (\x -> x (+1) [2,3]) (map id [map])
13:48:38 <lambdabot> [[3,4]]
13:48:47 <tromp> map map [map]
13:49:06 <tibbe> lispy, how about: <expr> ---> <lam> | <expr> <expr> | <expr> <op> <expr>
13:49:27 <lispy> tibbe: you want to express <op> as named lambdas
13:49:34 <lispy> tibbe: it will simplify life
13:50:03 <SimonRC> lispy: I have somthing you might find useful
13:50:04 <tibbe> yes
13:50:14 <tibbe> although I'm not sure if it's easier to make say a (Add e1 e2) data constructor in the Expr data type and then convert that to a lambda
13:50:21 <tibbe> or convert i right away
13:50:28 <lispy> SimonRC: yes?  debugger? code coverage?  what?
13:50:37 <palomer> that's it, I'm using my small lambda language
13:50:38 <palomer> so blah!
13:50:59 <tibbe> lispy, a good solution is of course to have general infix "functions", but I'm looking for an easy solution to start with
13:51:37 <lispy> tibbe: yeah, so don't support infix for now
13:51:40 <SimonRC> oh, wait, not you..
13:51:41 <SimonRC> I recently wrote a \calc evaluator
13:51:43 <SimonRC> http://compsoc.dur.ac.uk/~sc/Shakell/
13:51:53 <lispy> SimonRC: :(
13:51:59 <lispy> SimonRC: get my hopes up :)
13:52:04 <SimonRC> Unfortunately, it;s designed to be a bit odd
13:52:28 <SimonRC> sorry, typed into the wrong window for a bit
13:52:34 <tromp> i wrote one for binary lambda calculus and binary combinatory logic
13:52:34 <Lemmih> dcoutts, dons, other overly interested souls: http://scannedinavian.org/~lemmih/HIDE-screenie.png
13:52:55 <dcoutts> cool
13:53:18 <lispy> hmm...not loading on my end
13:53:22 <dcoutts> for people who can't get thrugh to scannedinavian.org, try the .com version
13:53:22 <dcoutts> http://scannedinavian.com/~lemmih/HIDE-screenie.png
13:53:26 <lispy> still says "connecting..."
13:53:30 <davidw> lemmih, nice
13:53:49 <dcoutts> it's dns is buggered in some parts of the net, but the .com one is accessable
13:53:58 <lispy> Lemmih: nice!
13:55:15 <dcoutts> Lemmih, eventually I guess we'll want those messages to be in a list box so that one can select them and jump to the line. One can have multi-line list entries.
13:55:23 <davidw> btw, from where can I get System.FilePath?
13:55:25 <SimonRC> ooh highlighting type errors!
13:55:27 <dcoutts> each one gets as much space as it needs
13:55:41 <dcoutts> Lemmih, but not now. there's better things to do :-)
13:55:53 <dcoutts> Lemmih, and I'm replacing the list box api anyway :-)
13:55:54 <SimonRC> davidw: have you tried loading it like any other module?
13:56:17 <Lemmih> @where FilePath
13:56:18 <lambdabot> http://scannedinavian.org/~lemmih/FilePath
13:56:26 <davidw> thanks
13:56:29 <dcoutts> davidw, see the FilePath cabal package from hackage
13:56:38 <SimonRC> ah, not standard Library
13:56:38 <dcoutts> @where hackage
13:56:39 <lambdabot> I know nothing about hackage.
13:57:12 <dcoutts> @where+ hackage http://hackage.haskell.org/trac/hackage
13:57:12 <lambdabot> Done.
13:57:28 <dcoutts> @where hackagedb
13:57:29 <lambdabot> I know nothing about hackagedb.
13:57:41 <dcoutts> @where+ hackagedb http://hackage.haskell.org/ModHackage/Hackage.hs?action=home
13:57:42 <lambdabot> Done.
13:58:49 * palomer wonders why, even after 40 years of research, parsing is still a pain in the ass
13:58:53 <palomer> seriously
13:59:25 <SamB> the researchers weren't researching "pleasant" parsing?
13:59:34 <dcoutts> palomer, that's because actually parsing is magic :-)
13:59:34 <SamB> Parsing is downright complicated?
13:59:43 <jonkri> what's wrong with this: prop_numDivs_0 n = n /= 0 ==> numDivs n > 0
13:59:47 <SamB> dcoutts: I wish!
14:02:09 <robdockins> palomer: check out http://www.cs.chalmers.se/~markus/BNFC/
14:02:18 <dbremner> palomar - there's GLR or Earley
14:03:03 <palomer> robdockins: that looks like sablecc
14:03:19 <shapr> hiya dbremner 
14:03:31 <dbremner> shapr - hello
14:03:40 <SamB> robdockins: hmm, happy parse errors make me sad :-(
14:03:53 <lispy> shapr: hi, thanks for recommending "the pragmatic programmer" it's a good book!
14:04:31 <shapr> lispy: Glad you like it!
14:04:40 <lispy> so many good ideas....
14:04:45 <shapr> Want some other recommendations? :-)
14:04:49 <lispy> sure
14:04:53 <shapr> Or, have recommendations for me?
14:05:10 <lispy> shapr: hmm...i don't think i have an recommendations to trade :(
14:05:27 <shapr> Have you read SICP and TaPL?
14:05:30 <SimonRC> palomer: have you tried parsec?  It has great error handling!
14:05:58 <lispy> shapr: TaPL is sitting right next to me, unread and SICP i started once, but didn't read much
14:05:59 * shapr bought kumquats today
14:06:02 <SimonRC> http://compsoc.dur.ac.uk/~sc/Shakell/ was put together with Parsec
14:06:07 <lispy> shapr: i should work on TaPL more
14:06:08 <shapr> lispy: You should try both of them.
14:06:13 <SamB> robdockins: I'm not much liking the parse errors from this C-- frontend
14:06:26 <lispy> shapr: cool, thanks
14:06:27 <shapr> lispy: I'd like to do a TaPL reading group with Haskell implementations.
14:06:32 <dcoutts> shapr, don't step on my kumquats!
14:06:46 <palomer> BNFC rocks!
14:06:49 <palomer> everyone should use this!
14:06:51 <robdockins> samb: well.... bottom up parsing makes error reporting difficult
14:06:52 <lispy> shapr: my research group is working through the basics of type theory up to Curry-Howard, that has been really helpful
14:07:06 <dcoutts> shapr, hmm, sorry, random line from a random play.
14:07:09 <SamB> robdockins: so why do you do it?
14:07:14 <dcoutts> @google don't step on my kumquats
14:07:15 <lambdabot> http://www.ocala.com/apps/pbcs.dll/article?AID=/20060120/NEWS/201200305/
14:07:15 <lambdabot> 1016/entertainment
14:07:21 <shapr> lispy: research group?
14:07:30 <robdockins> samb:  besides, c-- is supposed to be a portable assembler -- error reporting isn't a priority
14:07:40 <lispy> shapr: i've been meeting once a week with a group of functional programming researchers
14:07:45 <robdockins> because LL(1) parsing (ie, top down) is weaker
14:08:05 <SamB> robdockins: how are you supposed to debug it (or compilers targetting it) without decent error messages
14:08:06 <SamB> ?
14:08:10 <shapr> lispy: wow neat!
14:08:50 <lispy> yeah, i'm new to things like C-H so i make them go really slow :)
14:08:50 <dbremner> robdockins - it's
14:09:07 <lispy> me: Now wait, what is homomorphic about that?
14:09:43 <palomer> how is early any different from any other parser?
14:10:13 <Codex> lispy: what kind of topics are discussed? i.e. what's hot in C-H currently?
14:10:35 <dbremner> robdockins - possible to get better error recovery than yacc, are you familiar with jikespg?
14:10:58 <SamB> who cares about recovery?
14:10:59 <lispy> i have a question about parsec, the haskell98 report says to take the longest lexical token that matches, so for example, "cases" is not interpreted as "case" followed by "s", how do you write that as a parsec parser?
14:11:04 <SamB> messages are where it is at!
14:11:12 <robdockins> dbremmner: no I'm not samb:  its how you get better error messages
14:11:27 <lispy> Codex: well, we were just trying to understand the theory better, i don't thkn we brought any new ideas to the table
14:12:14 <SamB> lispy: typically you would use a tokenizer
14:12:31 <SamB> aka lexer/scanner
14:12:35 <lispy> SamB: sure, let's say i'm writing the tokenizer in parsec using the parsing combinators
14:13:01 <shapr> lispy: C-H has a recent extension into philosophy, did you know?
14:13:03 <SamB> okay, if you are writing the lexer
14:13:20 <lispy> shapr: no i didn't, that's interesting tho
14:13:32 <monochrom> "many letter" takes the longest possible string of letters.  It will get you "cases".
14:13:38 <SamB> well, in the case to handle an identifier, you'd just check to see if the identifier was a keyword
14:13:51 <eivuokko> lispy, you are confusing matchig string "case" <|> ..  and f <- many1 identifierChar;  case f of...
14:13:56 <monochrom> You can also use "many1 letters" if you intend "must be at least one"
14:13:58 <SamB> if it is, you return a keyword token, otherwise, an identifier token
14:13:58 <shapr> It seems that philosophy has its own calculus of proofs, and Michael Dummet's work brought the C-H isomorphism together with their own calculus.
14:14:09 <shapr> I can give you more info if you want.
14:14:41 <tibbe> SamB, what C-- generator?
14:14:42 <lispy> shapr: i'm not a philosopher so it would be lost on me, but interesting that they "ported" it
14:14:48 <lispy> eivuokko: hmm...
14:14:59 <robdockins> samb: re how to target C--, use a pretty printer that doesn't make syntax mistakes ;)
14:15:07 <lispy> eivuokko: not sure what you're getting at
14:15:08 <SamB> robdockins: that is a lame answer
14:15:16 <SamB> because somebody has to write the pretty printer!
14:15:27 <robdockins> samb: sure me!  One is provided
14:15:35 <SamB> okay
14:15:45 <SamB> where?
14:15:46 <shapr> lispy: I don't think it's important to be a philosopher, but I am interested in stealing their existing proofs for use as mathematical proofs and executable programs :-) Think of it, more libraries for the grist mill!
14:15:51 <eivuokko> lispy, the distinction is that you first longest match possible with characters, and after you matched you compare it.  Not that you first match keyword, then random identifiers.
14:15:51 <SamB> I don't see it in these here Haddock docs
14:16:01 <araujo> yeay!
14:16:02 <araujo> @yaw!
14:16:03 <lambdabot> You can't hurt me!!  I have an ASSUMABLE MORTGAGE!!
14:16:05 <lispy> SamB: i don't think that would parse what i want to parse.  I was currious how to express in parsec combinators that the lexer (writen as a parser) should keep reading.  I guess you need to decide thta non-identifier characters terminate the identifier and parse till you hit one.
14:16:29 <robdockins> samb: in Language.Cmm.Parser (oddly enough)
14:16:44 <robdockins> samb: In the version I intend to push tonight the docs are better
14:16:57 <lispy> eivuokko: yeah, i think it's the notion of a follow set for the lexical tokens that i was tripping up on
14:17:25 <lispy> eivuokko: the parser for identifiers needs to stop only when it hits a non-identifier character
14:17:38 <SamB> also, it is traditional to put the AST types to accompany Foo.Parser in Foo.Syntax
14:17:39 <tibbe> robdockins, you're working on Cmm pretty printer?
14:18:04 <SamB> robdockins: and that still doesn't help me to figure out why this example doesn't parse
14:18:10 <robdockins> tibbe: yup. as part of a total C-- frontend
14:18:15 <SamB> robdockins: you could at least add column number reporting...
14:18:31 <tibbe> robdockins, I was planning to target C-- with my compiler
14:18:59 <tibbe> robdockins, should I use the Language.Cmm something that's in GHC?
14:19:18 <lispy> tibbe: have you seen this book: http://research.microsoft.com/Users/simonpj/Papers/pj-lester-book/
14:19:38 <SamB> lispy: alls you got to do is parse identifier characters
14:19:56 <robdockins> tibbe: is that in HEAD?  If it is, it's not the one I'm working on
14:20:10 <robdockins> tibbe: mine is at http://www.eecs.tufts.edu/~rdocki01/cmm/
14:20:18 <lispy> SamB: right, that's the part i was blocking on
14:20:23 <SamB> that is, liftM (:) idStart (many idLetter)
14:20:32 <SamB> that will match as much as it can
14:20:38 <robdockins> tibbe: I plan a major push later today, so you might want to wait
14:20:40 <palomer> what's the prededence of the application operator " " ?
14:20:56 <SamB> palomer: it binds tighter than anything
14:21:06 <lispy> > map(1+)[1,2,3]
14:21:07 <lambdabot> [2,3,4]
14:21:10 <robdockins> samb: is it short enough to post?
14:21:17 <lispy> palomer: are you sure " " is the application character :)
14:21:39 <tibbe> lispy, yes, I've read bits and pieceses of it, I'm doing a strict language though and without much of the complexities he goes through
14:21:39 <lispy> er application operator...
14:21:49 <lispy> tibbe: ah
14:22:00 <SamB> lisppaste2: there is another one, called "$"
14:22:10 <SimonRC> am I imagining it, or are fudgets rather like arrows?
14:22:12 <SamB> that one binds as loose as can be
14:22:17 <robdockins> tibbe: GHC speaks a slightly strange dialect of C--.  I intend to follow the spec exactily (as possible)
14:22:48 <lisppaste2> SamB pasted "C-- that apparantly won't parse" at http://paste.lisp.org/display/16082
14:22:48 <lispy> SamB: my point is that normal application  is given by juxstaposing, not by a special operator
14:23:04 <SamB> lispy: I know
14:23:51 <lispy> SamB: okay, not sure why you told me about $ then :)
14:24:02 <tibbe> robdockins, that's not the one I've seen before. There's one somewhere at chalmers.se also.
14:24:28 <SamB> clearly, palomer was asking about juxtaposition
14:24:50 <SimonRC> lispy: $ is good for avoiding brackets
14:25:19 <tibbe> robdockins, I seem to have misplaced my bookmark for it though
14:25:30 <lispy> hehe, i know about $ it's the bane of my haskell programming (along with layout rule) why do you people have to keep reminding me it exists :)
14:25:44 <palomer> http://www.rafb.net/paste/results/UYvxNC15.html <--I get a syntax error at "do"
14:25:50 <palomer> what's up?
14:26:11 <Lemmih> palomer: try $ do ...
14:26:26 <SamB> lispy: it can't be the bane of your writing -- must be the bane of your reading...
14:26:46 <SamB> usually I parenthesize the do...
14:27:00 <monochrom> I'm thinking whether it helps to align "x<-typeP" with "do".
14:27:02 <jonkri> i have "prop_numDivs_0 :: Integer -> Property" and "prop_numDivs_0 n = n /= 0 ==> numDivs n > 0", why do i get a "cannot find "show" function for" error when i call "prop_numDivs_0 1"? thanks
14:27:07 <lispy> SamB: yeah, i find it hard to read code with $ in it
14:27:26 <SimonRC> jonkri: what is "==>"?
14:27:30 <eivuokko> Do you dislike . as well then?
14:27:39 <lispy> eivuokko: no i quite like .
14:27:50 <SamB> lispy: I usually only use it when the parentheses make it harder match the parens
14:27:55 <SamB> er.
14:28:00 <eivuokko> Heh
14:28:03 <SamB> when I have too many parens in one pile
14:28:07 <SimonRC> jonkri: I don't know where you got it from.
14:28:09 <monochrom> Heh, won't help.
14:28:26 <lispy> i will use $ occasionally, but usually one one $ per function or pattern
14:28:34 <lispy> if i need more than one $ i use parens instead
14:28:40 <SamB> or when I want to wrap something between lines, or when I'm returning something...
14:28:41 <jonkri> SimonRC, well, the thing that makes the quickcheck input be /= 0?
14:29:02 <SimonRC> jonkri: ==> isn't Haskell syntax
14:29:27 <SamB> > let (==>) = (+) in 1 ==> 1
14:29:27 <SimonRC> jonkri: maybe you mean "prop_numDivs_0 n | n /= 0 = numDivs n > 0
14:29:28 <lambdabot> 2
14:29:46 <lispy> SimonRC: i think QuickCheck defines (==>)
14:29:53 <SimonRC> SamB: I meant not built-in or in the prelude
14:29:58 <SamB> SimonRC: I'm with lispy ;-)
14:29:59 <shapr> yeat, filter
14:30:06 <SamB> @hoogle ==>
14:30:06 <lambdabot> Test.QuickCheck.(==>) :: Testable a => Bool -> a -> Property
14:30:09 <SamB> yeah
14:30:44 <SamB> robdockins: see that paste?
14:30:48 <robdockins> samb: yup
14:31:11 <robdockins> samb: put whitespace in "n-1"
14:31:14 <jonkri> yeah, exacly
14:31:17 <jonkri> so what am i doing wrong?
14:31:20 <SamB> why?
14:31:44 <jonkri> SimonRC, thanks, but i want to use ==>
14:31:52 <robdockins> samb:  I think its the lexical rule for negative numbers interacting badly -- I'll have to check out the spec to see what the correct behavior is supposed to be
14:32:01 <SimonRC> jonkri: you're using QuickCheck, then
14:32:10 <robdockins> samb: I'ts probably a bug, but I'm not sure
14:32:16 <SamB> robdockins: yeah, probably
14:32:21 <jonkri> SimonRC, yeah
14:32:30 <SamB> I don't think the spec says what to do
14:32:42 * palomer is about to delve deep into the bowels of haskell...
14:32:44 <robdockins> samb: the c-- spec is a little strange, because its not designed with humans in mind
14:32:53 <palomer> STRef baby!
14:33:08 <palomer> or maybe IORef
14:33:11 <SamB> robdockins: what version do you have?
14:33:15 <palomer> ugh, IORef is going to make my types ugly
14:33:20 <robdockins> samb: 1.128
14:33:23 <SamB> mine calls itself 1.128
14:33:23 <monochrom> @pl \b m n -> b m n
14:33:24 <lambdabot> id
14:33:27 <SimonRC> jonkri: It must be trying to print out a function or something.
14:33:31 <monochrom> Neat!
14:33:42 <SamB> and it doesn't seem to say much about those things, as far as I can see
14:33:55 <SamB> the symboly things
14:34:07 <jonkri> SimonRC, yeah, but why? i have defined it
14:34:20 <SamB> that code is from Figure 1, I think
14:34:23 <jonkri> i have "prop_numDivs_0 :: Integer -> Property" and "prop_numDivs_0 n = n /= 0 ==> numDivs n > 0"
14:34:31 <robdockins> samb: BTW, you might want to check out the list archives for cminusminus@cminusminus.org.  I just recently got some clarifications about a few issues
14:34:32 <SamB> so it obviously ought to work ;-)
14:34:53 <jonkri> "prop_numDivs_0 1" now says ERROR - Undefined variable prop_numDivs_0, and i have reloaded
14:35:01 <SamB> is that gmane.comp.lang.c--?
14:35:16 <robdockins> samb: I think so
14:35:28 <tibbe> I'm so stupid sometimes, I got a link here on the #haskell that I missplaced and it took me 30 min to think of the logs...
14:35:31 * SamB pulls headers
14:35:34 <tibbe> @where logs
14:35:34 <lambdabot> http://tunes.org/~nef/logs/haskell/
14:35:38 <SamB> 1812, wow
14:36:00 <shapr> 1812?
14:36:29 <SamB> shapr: new headers in that group
14:37:14 <SamB> not sure when I started Pan, but it was within 1/3 year
14:37:45 * SimonRC grrs.
14:37:52 <SamB> and I think I have it set to get new headers in subscribed groups at startup
14:38:14 <SimonRC> Fudgets are too darn *easy*.  They're almost as bad is Parsec!
14:38:49 <shapr> I've had trouble building Fudgets everytime.
14:38:59 <shapr> I want to try the InternetLib.
14:39:08 * SimonRC hasn't actually tried using them yet.
14:39:14 <robdockins> samb: got to go.  email if you have more questions.  (my email should be in the darcs repo)
14:39:27 <SamB> I should hope so!
14:39:39 <SamB> though I might not think to look ;-)
14:39:43 <SimonRC> jonkri: I can't really help, I don't know --
14:39:47 <SimonRC> erm, bye
14:40:34 <jonkri> SimonRC, thanks anyway
14:40:49 <jonkri> what's wierd is that even if i just have "prop_numDivs_0 n = undefined -- n /= 0 ==> numDivs n > 0" i can't prop_numDivs_0 1
14:40:53 <jonkri> i have made some trivial error
14:51:30 * SimonRC goes
14:55:37 <palomer> say I have two modules, and there's a clash in their constructor names, how do I fix this?
14:56:06 <tromp> dont import both unqualified
14:56:29 <palomer> gotcha
14:56:41 <palomer> how do I fix the left recursive production: type = type -> type ?
14:56:52 <palomer> for parsec
14:57:14 <tromp> introduce typechain ?
14:57:29 <tromp> typechain = type -> typechain
14:57:39 <tromp> or typechain = type
14:58:27 <tromp> you need that anyway to avoid wrong parses
14:58:40 <palomer> good point
14:58:47 <palomer> isn't there already a combinator for this kind of thing?
14:58:53 <palomer> (like many2 :o!)
14:58:58 <tromp> cld be. never studied it
14:58:59 <Philippa> chainl1?
15:00:25 <palomer> type = chainl1 type "->" <--this is still left recursive though, right?
15:01:29 <palomer> tromp: but then I would do type = typechain <|> ...
15:01:34 <palomer> and then it would be left recursive again!
15:02:37 <tromp> well, you'd use typechain = nochaintype -> typechain ...
15:03:37 <Lemmih> dcoutts: If you want something done in HIDE then write it down on the wiki and I'll hack it.
15:04:03 <dcoutts> Lemmih, I want to find some time to work on the GUI infrastructure :-)
15:04:17 <dcoutts> Lemmih, what are you planning on soon/next?
15:04:58 <dcoutts> Lemmih, I think that jump to definition or to haddock documentation might be a good one to try.
15:05:35 <Philippa> palomer: that's not how you do it, you define a type-minus-the-recursive-case production and then type = chainl1 typeSansRecursion (string "->") or something
15:06:06 <palomer> oh, I see
15:06:18 <Lemmih> dcoutts: I thought about extending the file browser.
15:06:38 <dcoutts> Lemmih, that's really what I need to do, at least the GUI bits of that.
15:06:52 <dcoutts> Lemmih, it needs to be done as a custom tree model
15:07:18 <dcoutts> Lemmih, but the related infrastructure could be extended
15:07:30 <dcoutts> eg filters
15:07:56 <dcoutts> extend the system that allows plugins to explain what file types they can display
15:08:15 <dcoutts> and allows the user to choose a default or a differnt one on a per-file basis
15:08:32 <palomer> wait, don't I want chainr1 for -> ?
15:08:43 <dcoutts> eg editing an .html file in the text editor plugin or viewing it with the html plugin
15:09:13 <dcoutts> Lemmih, or for example a darcs plugin could provide an alternative view of a file
15:09:30 <dcoutts> Lemmih, eg right click on a file and select another view from a popup menu
15:09:45 <dcoutts> Lemmih, the current system for registering that stuff is rather simple
15:15:22 <palomer> oh my, parsec needs rank-2 for its types
15:15:42 <Philippa_> where?
15:16:07 <SamB> palomer: thats only .Token and .Language
15:16:21 <palomer> chainl::GenParser tok st a -> GenParser tok st (a->a->a) -> a -> GenParser tok st a <--shouldn't this be  chainl::GenParser tok st a -> forall b.(GenParser tok st (a->b->a)) -> a -> GenParser tok st a  ?
15:16:36 <Philippa_> no
15:16:50 <palomer> I'd like to chain an operator which is of type a -> b -> a
15:17:15 <palomer> a priori, I don't see why I shouldn't be allowed to do this
15:17:17 <dcoutts> xerox, Cale, cairo eye candy in Haskell!
15:17:18 <dcoutts> http://haskell.org/gtk2hs/archives/2006/01/26/cairo-eye-candy/
15:17:53 <Philippa_> palomer: give us an example instantiation
15:18:14 * Philippa_ thinks a mo
15:18:14 <palomer> you want me to write out chainl?
15:18:23 <Philippa_> no, I want you to tell us what you'd chain
15:18:33 <SamB> palomer: you could, but you'd need to pass a parser for things of type b as well
15:18:46 <palomer> oh, well I have formal parameters, which are qualified names
15:18:53 <astrolabe> It would be nice if Parsec exported the float parser without requiring the rigmarole of parameterising parsec token.
15:19:03 <palomer> and I have constructor QualifiedParameter which takes a Parameter and a type and returns a Parameter
15:19:17 <palomer> formalParameter = chainr1 formalParameterNorec (do{doubleSemi;return QualifiedParameter}) <--I'd like to write this
15:19:43 <SamB> astrolabe: it would be nicer if there was a float-parser-generator
15:19:54 <SamB> maybe written in TH
15:20:01 <palomer> so, like (a::int::int) is a valid parameter
15:20:06 <Philippa_> palomer: sounds like sepBy?
15:20:27 <Philippa_> that's a doubleColon rather than a doubleSemiColon, btw :-)
15:20:33 <palomer> oh, good point
15:20:41 <SamB> > 1 :: Int :: Int
15:20:42 <lambdabot>  parse error on input `::'
15:20:48 <SamB> hehe
15:20:58 <palomer> yeah, I don't know why haskell doesn't accept it
15:21:08 <palomer> it thinks :: is right assocative, I think
15:21:10 <Philippa_> associativity
15:21:15 <dcoutts> Lemmih, how about a hIDE analog clock plugin?
15:21:15 <dcoutts> http://haskell.org/gtk2hs/archives/2006/01/26/cairo-eye-candy/
15:21:18 <Philippa_> > (1::Int)::Int
15:21:19 <lambdabot> 1
15:21:26 <palomer> why would :: be right associative?
15:21:28 <SamB> I don't think it thinks :: associates at all
15:21:29 <palomer> it makes no sense!
15:21:39 <Philippa_> SamB: me either
15:21:49 <SamB> I think it believes :: to be nonassoc, as it were
15:22:05 <SamB> anyway, whow would write 1 :: Int :: Int?
15:22:15 <SamB> certainly not a pretty printer!
15:22:25 <palomer> whow?
15:22:28 <palomer> oh, who
15:22:32 <palomer> well, I would:P
15:22:35 <Lemmih> dcoutts: Of course! No IDE would ever be complete without an analog clock. (:
15:22:36 <SamB> why?
15:22:53 <palomer> to test out the type inferencing mechanism
15:23:02 <SamB> don't forget an integrated FPS?
15:23:11 <SamB> S/?/!?
15:23:14 <SamB> arg
15:23:22 * SamB can't type past a calc book
15:23:25 <palomer> FPS?
15:23:33 <SamB> s/?/!/
15:23:34 <Philippa_> First Person Shooter
15:23:58 <dcoutts> Lemmih, maybe I'll add it some time just because I can. :-) It'd help for deadlines and programming contests! :-)
15:24:02 <palomer> grr, how would the production for :: work?
15:24:19 <SamB> actually, I think I'd prefer a flying game or a platformer
15:24:21 <palomer> it sounds bloody ugly
15:24:23 <dcoutts> Lemmih, I think it'd be a tool notebook plugin thingy
15:24:52 <palomer> integrated FP?
15:24:54 <Philippa_> palomer: get your sequence in, then apply the functions afterwards
15:25:17 <palomer> yeah, but that would involve a seperate production for chains of ::
15:25:27 * palomer throws away :: associativity
15:26:13 <Philippa_> doesn't matter so long as you achieve the same result
15:27:05 <Philippa_> I mean, you could just build a list and then fold the constructor over it afterwards? You've got your base case there for you already
15:27:50 <palomer> yeah, but I"ve decided that folding would be silly with ::
15:28:18 <palomer> ie, a::int::int is disallowed
15:28:33 <SamB> ah
15:28:43 <SamB> so just (a::int)::int now?
15:28:46 <palomer> yeah
15:28:51 <Lemmih> dcoutts: Will the list box API hit the gtk2hs repo anytime soon? I'm planning to make a stable branch for hIDE.
15:29:14 <dcoutts> Lemmih, the low level part is in there already
15:29:32 <dcoutts> Lemmih, and that's probably the bit we'd want to use
15:29:52 <dcoutts> but it is rather low level and a little tricky to use
15:30:08 <dcoutts> we're still writing high level versions based on it
15:30:38 <dcoutts> Lemmih, I really want an inotify binding :-)
15:30:52 <dcoutts> I want the file view to automatcally update
15:30:53 <Lemmih> @google inotify
15:30:55 <lambdabot> http://www.edoceo.com/creo/inotify/
15:31:00 <SamB> so, it isn't ready for hIDE yet?
15:31:05 <dcoutts> @google linux inotify
15:31:07 <lambdabot> http://www.edoceo.com/creo/inotify/perl-inotify.php
15:31:41 <dcoutts> Lemmih, it's a new kernel file notification system with a sensible api
15:31:57 <dcoutts> Lemmih, as opposed to dnotify which had an insane api
15:32:15 <dcoutts> it'd have to be optional however
15:32:18 * jethr0_ wants a DWIM interface
15:32:45 <dcoutts> since not all platforms have something like it and it's quite new in linux, only in very recent kernels
15:33:03 <dcoutts> win32 has had such an interface for ever
15:33:13 <dcoutts> FreeBSD has something similar I think
15:33:14 <jethr0_> who was it that wrote the tetris with yampa?
15:34:09 <SamB> jethr0_: mind control!
15:34:49 <jethr0_> yeah that too. moving the curser with your eye's focus would be a first step
15:35:27 <jethr0_> and typing out your inner voice would be the next. but for me, mostly jumbled garbage would come out!
15:40:06 <SamB> which is why DWIM isn't really such a good idea after all
15:41:02 <jethr0_> SamB: well, dwim already counteracts this effect and finds out what you _really_ mean!
15:41:11 <jethr0_> that's the whole point
15:41:16 <palomer> http://www.rafb.net/paste/results/NZfDiC79.html <--could anyone help me debug this 2 production grammar? it dosn't want to parse (x::int)
15:41:22 <palomer> but it parses x::int
15:42:24 <jethr0_> doesn't this "try formalParameterUnqualified <|> do x<-formalParameterUnqualified" always succeed on the first "try"?
15:42:54 <jethr0_> wouldn't you want to reverse the order in the <|>?
15:43:24 <SamB> jethr0_: well it won't succeed the second time if it failed the first time, that is for sure!
15:43:36 <jethr0_> that's what i meant
15:43:41 <palomer> oh, righto
15:43:47 <jethr0_> palomer: and in the upper case you don't need "try" at all
15:44:00 <SamB> sometimes it might fail them both
15:44:03 <jethr0_> because the productions start with different symbols
15:44:17 <palomer> is this the way you guys would do it?
15:44:19 <jethr0_> unless "name" can start with a "leftParen"
15:44:45 <jethr0_> as far as i understood it, one should use "try" very sparingly!
15:44:46 <palomer> but wait, the second alternative might pass and the first fail, no?
15:44:53 <palomer> I don't see how reversing the production order changes anything?
15:45:15 <jethr0_> if the then-first fails, the then-second might still succeed
15:45:32 <jethr0_> right now, if the first fails, the second will fail too!
15:45:38 <palomer> why?
15:45:56 <jethr0_> because the first is a subset of the second
15:46:14 <palomer> no way
15:46:18 <palomer> the second has more stuff added
15:46:30 <jethr0_> yes, that's why the first is the _sub_set
15:46:57 <palomer> oh, righto
15:47:00 <palomer> brb
15:51:07 <znephf_> is there an easy way of converting Integer -> Double and back?
15:51:30 <jethr0_> @seen jip
15:51:31 <lambdabot> I saw jip leaving #haskell 2 days, 15 hours, 11 minutes and 53 seconds
15:51:31 <lambdabot> ago.
15:51:50 <jethr0_> znephf_: fromInteger will convert from integer
15:52:06 <jethr0_> to get back from double, you'd have to round/floor/ceil first
15:52:11 <jethr0_> @hoogle round
15:52:12 <lambdabot> Prelude.round :: (RealFrac a, Integral b) => a -> b
15:52:12 <lambdabot> Text.Html.background :: String -> HtmlAttr
15:52:32 <jethr0_> @hoogle (Double a, Integral b) => a -> b
15:52:33 <lambdabot> No matches, try a more general search
15:52:39 <jethr0_> @hoogle (Double a, Integer b) => a -> b
15:52:40 <lambdabot> No matches, try a more general search
15:52:52 <jethr0_> @hoogle (RealFrac a, Integral b) => a -> b
15:52:53 <lambdabot> Prelude.truncate :: (RealFrac a, Integral b) => a -> b
15:52:53 <lambdabot> Prelude.round :: (RealFrac a, Integral b) => a -> b
15:52:53 <lambdabot> Prelude.ceiling :: (RealFrac a, Integral b) => a -> b
15:53:09 <znephf_> wow - i'm kind of impressed ;)
15:53:11 <znephf_> thx
15:53:19 <jethr0_> well, it's still not doubles :(
15:53:48 <znephf_> Floating i think
15:53:56 <jethr0_> yes
15:53:57 <znephf_> otherway: I think i need Floating
15:53:59 <jethr0_> fractions
15:54:27 <znephf_> round was it...
15:54:32 <znephf_> i used toInteger
15:54:39 <jethr0_> @hoogle toInteger
15:54:40 <lambdabot> Prelude.toInteger :: Integral a => a -> Integer
15:54:46 <znephf_> hmm...
15:54:47 <znephf_> ok
15:54:55 <znephf_> .oO(need to learn...)
15:55:01 <jethr0_> that converts things that are already integral. like Int
15:55:21 <znephf_> thx :)
15:55:26 <jethr0_> np
15:56:20 <SamB> it can't be in Floating, because, well...
15:56:30 <SamB> Complex things are ;-)
15:56:37 <znephf_> :)
15:56:44 <znephf_> <-- not sure about things i say ;)
15:56:47 <jethr0_> SamB: how do get anything back from Double?
15:56:56 <SamB> > 1 :: Complex Double
15:56:57 <lambdabot>  Not in scope: type constructor or class `Complex'
15:56:59 <SamB> hmm.
15:57:04 <SamB> > 1 :: Complex.Complex Double
15:57:05 <lambdabot>  Not in scope: type constructor or class `Complex.Complex'
15:57:08 <SamB> argh
15:57:13 <jethr0_> i mean Double -> RealFrac or sth
15:57:24 <SamB> let me guess -- nobody uses Complex, ever?
15:57:25 <jethr0_> with rounding or loss of precision
15:57:34 <jethr0_> not yet :)
15:57:50 <jethr0_> i can't learn everything on one day :)
15:58:00 <znephf_> guessing: complex are complex numbers?
15:58:12 <SamB> yah!
15:58:15 <znephf_> :)
15:58:48 <SamB> anyway, Complex Double are in Floating, but not RealFrac
15:59:01 <SamB> because, well, they aren't real, obviously
15:59:29 <jethr0_> ah
15:59:45 <jethr0_> @hoogle (Floating a, Integral b) => a -> b
15:59:46 <lambdabot> No matches, try a more general search
16:01:55 <znephf_> :)
16:10:43 * SamB wonders how they sort kanji dictionaries
16:11:41 <jethr0_> SamB: they've got a system with a raster. and the order of lines is taken into account as well
16:12:01 <jethr0_> @seen saulzar
16:12:02 <lambdabot> saulzar is in #haskell. Last spoke 7 hours, 51 minutes and 55 seconds ago.
16:13:46 <SamB> order of lines?
16:13:54 <jethr0_> strokes
16:14:21 <jethr0_> they have to be done in a fixed order. and you can look it up in which raster cell each stroke starts and ends or sth like that
16:14:37 <SamB> s I would have to have a very good image of a character to look it up?
16:14:39 <jethr0_> i don't know exactly, but it gave me the creeps not to continue learning japanese :)
16:14:46 <jethr0_> yes
16:15:02 <jethr0_> or you could look it up by its transliteration, if you know how it's pronounced
16:15:09 <lennart> > 1 :+ 1
16:15:10 <lambdabot>  Not in scope: data constructor `:+'
16:15:15 <lennart> So sad
16:15:25 <eivuokko> I've only done that for chinese, and it's suprisingly easy.
16:15:47 <jethr0_> eivuokko: what is?
16:15:52 <eivuokko> Looking up characters
16:15:58 <SamB> I should learn japanese...
16:15:59 <jethr0_> chinese and japanese are very similar
16:16:05 <jethr0_> *symbols
16:16:39 <lennart> Except that the chinese have more
16:16:43 <jethr0_> eivuokko: do you speak chinese?
16:17:04 <jethr0_> lennart: you sure? i thing they pretty much have the same set of some 50000 symbols. but i'm no expert :)
16:17:17 <eivuokko> Nope.  I just have few basic introductory books and I read them for fun one time
16:17:54 <jethr0_> hmm, i want to learn it and the basics are surprisingly managable, but it simply takes up time and motivation
16:17:59 <lennart> Yes, I'm pretty sure.  Japanese has fewer.  They don't make new kanji, whereas the Chinese do.
16:18:15 <SamB> I guess the chinese don't have Ruby, either?
16:19:03 <SamB> lennart: and they don't steal more from chinese?
16:19:25 <jethr0_> lennart: and how do they do without new symbols?
16:19:42 <tuomov> use kana instead?
16:19:51 <SamB> they would rather steal *our* words?
16:20:13 <eivuokko> Japanese steal a lot of words from western languages.
16:20:35 <lennart> the japanese have katakana
16:20:36 <jethr0_> i know. i've started learning japanese and was surprised how many english words they've _adopted_
16:21:05 <jethr0_> in this series "neon genesis evangelion" they even say: "push-u the button-u". _very_ funny stuff
16:21:43 <jethr0_> yes, but then they'd have to write words like "engine" in kanji, and words like "airplane" in katagana. seems kinda odd
16:21:46 <SamB> jethr0_: they don't have many lone consonents ;-)
16:22:15 <jethr0_> yes, but that was supposed to be _japanese_, not a bad version of english!
16:22:34 <SamB> not really
16:23:17 <SamB> jethr0_: you know english steals ever so many words from other languages
16:23:50 <jethr0_> i hate the term blackmail. i prefer extortion. the X in it makes it sound cool
16:24:11 <jethr0_> i never said "steal". english is just an amalgam of many languages.
16:25:00 <tuomov> all languages are..
16:25:24 <SamB> oh, sorry, I just always use "steal"
16:26:01 <jethr0_> yes, but english has cultivated it. many french, german, yiddish words are in standard use in english. other languages have "adopted" fewer words from other languages
16:26:19 <SamB> just because we don't write them in a phonetic alphabet.. wait, we *do*
16:26:55 <tuomov> you write like it would've been written in the source language :)
16:27:16 <SamB> true, we don't use the same phonix
16:27:35 <jethr0_> oh, i forgot latin and greek
16:27:55 <jethr0_> look at the words they throw at spelling-bee contestants and you'll see what i mean
16:28:07 <ihope> @djinn Integer -> (a -> a) -> a -> a
16:28:07 <lambdabot> Cannot parse command
16:28:07 <lambdabot> f :: Integer -> (a -> a) -> a -> a
16:28:07 <lambdabot> f _ a b = a b
16:28:12 <ihope> Blih.
16:28:45 <SamB> @wikipedia gundam
16:28:46 <lambdabot> http://en.wikipedia.org/wiki/Gundam
16:30:03 <jethr0_> panegyric - an oration or writing expressing praise
16:30:13 <ihope> big 0 n = n+1
16:30:18 <jethr0_> maquette - preliminary model of something designed
16:30:21 <jethr0_> *brr*
16:30:27 <ihope> big m n = compose n (big (m-1)) n
16:30:44 <ihope> It's rather like the Ackermann function.
16:30:50 <kevind> @type compose
16:30:51 <lambdabot> Not in scope: `compose'
16:31:09 <eivuokko> @hoogle compose
16:31:10 <lambdabot> No matches found
16:31:10 <ihope> Compose turns a number into a Church numeral.
16:31:34 <ihope> Not actually defined anywhere, but useful when defining huge numbers.
16:32:23 <SamB> huh, I didn't know they called Gundam timelines by what they call the years...
16:32:50 <palomer> ok, I'm back
16:33:13 <jethr0_> OMG, reactos has suspended development. :'(
16:33:17 <palomer> http://www.rafb.net/paste/results/87SqV098.html <--updated grammar
16:33:32 <palomer> still fails
16:33:40 <SamB> <ScoTTie> how much tainted code is there roughly ?
16:33:41 <SamB> <mf> that meeting got waaay longer than i had hoped for
16:33:41 <SamB> <EmuandCo> Yes. 1:27am
16:33:41 <SamB> <mf> silverblade: 90% of the kernel
16:33:52 <SamB> wait...
16:33:56 <jethr0_> palomer: you don't need the second try in formalParameter
16:34:09 <jethr0_> you only need "try" if an alternative follows it
16:34:12 <kevind> Cale: you here?
16:34:27 <SamB> ah, that *was* directed at ScoTTie
16:34:30 <palomer> yeah, removed it
16:34:40 <SamB> (thats from #reactos)
16:34:41 <jethr0_> looks good. but does it work?
16:34:52 <palomer> nope
16:34:54 <palomer> :(
16:35:18 <jethr0_> i can't believe that!
16:35:28 <palomer> "parse error"
16:35:39 <jethr0_> palomer: where
16:36:05 <jethr0_> SamB: and now all the developers have come into contact with tainted code, so they are all tainted to!?!?
16:36:09 <palomer> (x::int)
16:36:11 <jethr0_> too
16:36:16 <kevind> tainted with what
16:36:31 <SamB> jethr0_: I don't think it works quite that way
16:36:44 <SamB> kevind: ReactOS devs
16:36:48 <ihope> Mmh, tainted code.
16:36:49 <SamB> with Windows code
16:36:54 <ihope> You mean imperative code?
16:37:33 <jethr0_> palomer: you could also you "between" for the parens! other than that i don't know why it might fail. what does typeP do?
16:37:47 <SamB> no, like maybe-originally-copied-from disassemblies of MS code
16:38:06 <ihope> Ooh! Ooh! COBOL code!
16:38:09 <jethr0_> or, even worse, from someone who had access to NDA'd source code
16:38:30 <jethr0_> disassembled MS code isn't even illegal in many countries, although maybe frowned upon
16:38:35 <palomer> jethr0_: it parses the type
16:38:38 <palomer> that might be it
16:38:39 <palomer> one sec
16:38:45 <SamB> I certainly hope such people aren't so stupid...
16:39:00 <palomer> ah yes, that's the problem
16:39:04 <eivuokko> SamB, you'd be suprised...
16:39:17 <jethr0_> SamB: ya, well, "legal council" might go for ages and not have a definitive result. this might stop the whole project
16:39:28 <kevind> sounds like a good way to MS to shutdown open source projects it doesnt like
16:39:39 <kevind> get a mole to "taint" the project
16:39:57 <jethr0_> i'm not a guy for conspiracy theories, but shutting down reactos would be very helpful for MS
16:40:15 <jethr0_> kevind: my thoughts exactly, but that's the conspiracy guy speaking in me :)
16:40:22 <SamB> kevind: that would really only work if it was a clone of an MS product, mostly...
16:40:35 <ihope> Conspiracy theories are fun.
16:40:37 <SamB> otherwise it would be really easy to figure out what could possibly be tainted, methinks
16:40:40 <palomer> chainr1 needs at least one seperator, right?
16:40:57 <jethr0_> SamB: people working on it that had come into contact with NDA'd material were asked not to participate for legal reasons
16:41:20 <jethr0_> palomer: i guess that's what the 1 stands for
16:42:29 <SamB> I don't see what MS is so worried about. its not like ReactOS is ever going to support the latest D3D or anything...
16:42:46 <TuringTest> Is anyone here good with fast mutable arrays?
16:43:07 <SamB> it would give customers a good platform for running old software that doesn't like new versions of windows
16:43:07 <dons> what's your question?
16:43:12 <jethr0_> no, but it would be a great stepping stone for supporting old windows applications in an open source environment. because getting reactos to run inside xen would be easy
16:43:34 <SamB> TuringTest: I will be good, if only you give me a fast mutable array!
16:43:34 <SamB> I promise!
16:43:42 <TuringTest> Well, I have been poking at the N-Body shootout entry.
16:43:55 <dons> ah!
16:43:57 <TuringTest> Which uses around 30 mutable doubles
16:44:00 <jethr0_> @where shootout
16:44:00 <lambdabot> I know nothing about shootout.
16:44:13 * TuringTest points at http://haskell.org/hawiki/NbodyEntry
16:44:13 <dons> @shootout
16:44:14 <lambdabot> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=
16:44:14 <lambdabot> all
16:44:33 <TuringTest> I just put the best code up at the top of the wiki
16:44:44 <TuringTest> It is finially faster than the old code
16:45:15 <kevind> the
16:45:39 <dons> hmm, very interessting TuringTest. well done.
16:45:47 <TuringTest> I think it is still 5 or 6 times slower than the other entries, e.g. OCaml
16:45:49 <palomer> http://www.rafb.net/paste/results/LQL87x29.html <--anyone have any clues?
16:46:33 <dons> Turing Test, does it run faster than the "Old attempt by ChrisKuklewicz"?
16:46:39 <TuringTest> Yup
16:46:46 <TuringTest> (I am Chris)
16:46:54 <TuringTest> About 2.5 times faster
16:46:56 <jethr0_> TuringTest: you've made haskell code faster by bit fiddling? i wouldn't have thought so...
16:47:06 <TuringTest> I made it faster by changing the array model
16:47:25 <TuringTest> I still know that it is too slow
16:47:28 <jethr0_> TuringTest: but you aren't kuklewicz, are you
16:47:40 <TuringTest> I am
16:48:03 <dons> ah! hehe :) hi there
16:48:12 <TuringTest> Hi Don
16:48:19 <znephf_> hmm... i had the trouble with RealFrac -> Integral... so i wrote an integer sqrt ;)
16:48:30 <jethr0_> ah sorry, i only looked at the "christoph bauer" :)
16:48:51 <dons> you know, I've never seen: "default(Int)" used before. were'd you get that idea?
16:48:57 <TuringTest> "Chris.*" are legion
16:49:15 <TuringTest> I got tired of ::Int
16:49:32 <TuringTest> It is not ready to submit to the shootout, which is why it got left in.
16:49:45 <dons> ok. cool. do you want me to look at it?
16:49:54 <TuringTest> Yes.
16:50:12 <dons> good to finally make some progress here.
16:50:22 <dons> @seen musasabi
16:50:22 <lambdabot> I saw musasabi leaving #haskell-overflow, #haskell-blah and #haskell 12
16:50:22 <lambdabot> hours, 37 minutes and 18 seconds ago.
16:50:23 <TuringTest> Yes.  Indeed
16:50:30 <jethr0_> why isn't the code in a module?
16:50:38 <dons> jethr0_ ?
16:50:52 <dons> module Main where is optional.
16:50:57 <TuringTest> jethr0_: It is intended for the shootout : http://shootout.alioth.debian.org/gp4/benchmark.php?test=nbody&lang=all
16:51:00 <jethr0_> hmm, didn't know that
16:51:37 <TuringTest> Haskell GHC is ranked #2 now, on the gentoo/P4 system: http://shootout.alioth.debian.org/gp4/benchmark.php?test=nbody&lang=all
16:51:52 <jethr0_> TuringTest: not is scope 163:"output", 163:"left", 165:"i"
16:51:58 <jethr0_> or have i copy-pasted badly?
16:52:04 <jethr0_> 166:"updateVel"
16:52:08 <TuringTest> Wiki code mesed up
16:52:09 <dons> jethr0, that's the syntax highlighting.
16:52:14 <jethr0_> grr
16:52:17 <TuringTest> Go get the raw wiki code 
16:52:20 <dons> TuringTest, maybe don't bother with #!syntax haskell
16:52:25 <jethr0_> np, i'll repaste from source
16:52:38 <dons> TuringTest, what do you mean, ranked #2?
16:52:48 * TuringTest just fixed the wiki
16:53:01 <Cale> kevind: hello
16:53:03 <dons> I know it is overall #2, but not on the nbody test (which you just linked to)
16:53:05 <TuringTest> dons: On the shootout summary, with the default weights
16:53:12 <dons> yeah:
16:53:14 * TuringTest oops
16:53:17 <dons> @shooout is for this reason
16:53:17 <lambdabot> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=
16:53:17 <lambdabot> all
16:53:25 <dons> :)
16:53:47 <jethr0_> although there's been some pretty black magic tuning going on, hasn't there
16:53:53 <palomer> ugh, there's a problem with the lexer
16:53:54 * TuringTest nods
16:53:56 <Cale> kevind: I got it not to hang on your testcase -- I'm not sure of the exact semantics you want though
16:54:02 <dons> we've been tweaking all week to try to get to number 1. musasabi usually commits changes once I'm done. much faster than submitting via the web interface.
16:54:06 <TuringTest> jethr0_: The blackest magic 
16:54:11 <jethr0_> hehe
16:54:25 <jethr0_> bit fiddling isn't very idiomatic haskell, i guess :)
16:54:28 <TuringTest> dons: Ah...that is why your code does not go through the tracking system!
16:54:29 <dons> some entries are very unmagic though
16:54:37 <jethr0_> yes, i saw
16:54:39 * Igloo wonders when ghc will get -fallow-inline-asm
16:54:49 <dons> Igloo, it already does!
16:54:53 <jethr0_> but one of the entries is littered with noinlines *brr*
16:54:54 * dons looks for the code...
16:55:19 <dons> markStrat n s x = unsafePerformPrimIO (
16:55:20 <dons>      _casm_ ``%r = set_sparkname(CurrentTSO, %0);'' n `thenPrimIO` \ z ->
16:55:20 * Igloo wants   map (__asm__ mov ... __end_asm__) xs
16:55:20 <dons>      returnPrimIO (s x))
16:55:27 <jethr0_> TuringTest: have you maxed out the profiling or does it make sense for me to try around?
16:55:55 <TuringTest> jethr0_:  I just got this version working, I have not run -prof on it
16:55:57 <jethr0_> knowing that i have never seriously profiled haskell before :)
16:56:03 <Igloo> Mmm, lovely  :-)
16:56:04 <dons> this _casm_ thingy is in Parallel.Strategies.hs
16:56:14 <TuringTest> All the time is spent in the "advance" routine at the bottom of the file
16:56:19 <palomer> Cale: there's a problem with your lexer: http://www.rafb.net/paste/results/R9FFSx70.html
16:56:25 <TuringTest> dons: That is ... unspeakable
16:56:30 <eivuokko> dons, does that allow primop-speed ops or does it build some protections around?
16:56:32 <dons> ah, no prof. good. that means there's room to move 
16:56:48 <dons> i have no idea. i've not used it, and not sure that it's even compilable  :)
16:56:54 <eivuokko> dons, lol :)
16:57:05 <dons> it could be legacy code from some weird parallel version ghc
16:57:21 <eivuokko> dons, I was just today wondering why primops are primops, why can't there be new calling convention in ffi or something.
16:57:42 <kevind> Cale: cool, what was the problem?
16:58:01 <TuringTest> As a physicist I hoped that the N-body solar system program would have reasonable performance.  At the moment it is still poor compared to OCaml.
16:58:03 <palomer> Cale: I think it's because it reads in and returns a TokenIn, and then moves on
16:58:23 <Igloo> TuringTest: Do you know why it is slow?
16:58:32 <Cale> kevind: something odd in buildCommit
16:58:33 <TuringTest> Igloo: No idea.
16:58:53 <Cale> kevind: the recursion there is fairly strange and I'm not completely sure what the intent is :)
16:59:17 <Cale> but I think it was often returning Nothing when it shouldn't (?) have been
16:59:17 <dons> TuringTest, there's no reason we can't beat OCaml, unless they use magic libraries. we just have to be careful..
16:59:44 <TuringTest> dons: That is what I thought.  Which is why I kept plugging away at it.
16:59:46 <dons> this is a nasty test though. mutable everything _and_ double-based math. together at last!
16:59:56 <Cale> I'll put my copies of the files up
17:00:11 <kevind> hmm, buildcommit was not terminating?
17:00:13 <dons> @karma+ TuringTest
17:00:14 <lambdabot> TuringTest's karma raised to 1.
17:00:18 <TuringTest> As I said, I am a physicist.  Numerical integration comes naturally, just not to Haskell
17:00:30 <dons> i'll have a look now
17:00:33 <Philippa_> I'd still like the specialisations for floats. I get annoyed when told I shouldn't want them unless I've a special case anyway, because I know what I'm doing
17:00:33 * TuringTest wonder what the hell karma is good for
17:00:40 <TuringTest> dons: Thanks
17:00:52 <Cale> kevind: that's possile
17:00:55 <Cale> possible*
17:01:09 <Cale> I'd gotten a number of stack overflows as I experimented with it
17:01:45 * TuringTest sees it is 1 am
17:01:48 <Cale> http://vx.hn.org/autoshare/GR.hs http://vx.hn.org/autoshare/TS.hs
17:01:55 <TuringTest> My work tonight is done.  Good night all.
17:04:50 <Cale> actually, updated those just now :)
17:11:01 <jethr0_> cale, how do you profile code that has so many optimizations? with all optimizations on i get "Prologue junk?:" and some assembly code as an error with "-prof"
17:11:26 <Cale> hmm
17:11:40 <Cale> turn off some optimisations? :)
17:12:50 <Cale> I'm not sure
17:12:59 <Cale> that sounds like a possible GHC bug
17:13:06 <jethr0_> could this be cause by the optimizations, i.e. has this happened to you before?
17:13:11 <jethr0_> :(
17:13:15 <Cale> I've never seen that
17:13:53 <dons> jethr0, compile via -fasm
17:14:17 <dons> it means ghc is spitting out C code that gcc turns into weird C that the mangler can't grok
17:14:23 <dons> so, use the native code generator instead
17:14:25 <kevind> If I have a recursive function, f, that makes a Maybe a and in it I have a list, l, of possible things to recurse on and I want to try each until the first non-Nothing, what is the proper way to do that?
17:14:41 <jethr0_> "-opc-O3" and "-prof" don't seem to get along too well
17:15:05 <Cale> takeWhile isJust (map f l) ?
17:15:20 <Cale> oh
17:15:37 <Cale> head $ dropWhile isNothing (map f l)
17:16:15 <kevind> wow, nice and concise
17:16:15 <dons> jethr0_, usually they do. sometimes they don't (very rarely, like once a year).
17:16:22 <dons> it all depends on the haskell code you've got
17:16:24 <dons> and the gcc version
17:17:52 <jethr0_> ok
17:18:39 <dons> but, can you submit a repro case?
17:18:47 <dons> then Simon can fix the mangler
17:19:00 <dons> and it won't happen again. it's a constant battle trying to get gcc to do what we want
17:19:17 <lisppaste2> jethr0 pasted "nbody profile" at http://paste.lisp.org/display/16087
17:19:32 <jethr0_> well, that profile will certainly not help :(
17:19:51 <jethr0_> dons: i'm not using the head version *sry*
17:33:32 <kevind> why does my emacs haskell-mode do such bad indenting?  and with tabs too
17:33:56 <Cale> kevind: do you have it set on smart or simple indenting?
17:34:02 <Cale> I'd set it on simple
17:34:17 <Cale> the smart indenter is too smart for its own good :)
17:34:26 <Cale> also, remove all tabs from your file
17:34:43 <Cale> they should always be replaced with spaces
17:35:07 <Cale> (indeed, one of the Haskell' proposals is to disallow tabs in source files altogether)
17:35:11 <kevind> it seems to automatically use tabs
17:35:22 <Philippa_> I hope that one goes through, FWIW
17:35:36 <Philippa_> which reminds me, I should probably spend more time on my proto-proposal tomorrow
17:35:45 <Cale> what's your proposal?
17:35:54 <Cale> I should resubmit a few of my proposals
17:36:00 <Philippa_> it seems to've been dubbed PartialTypeAnnotations
17:36:04 <Cale> why is nobody complaining about Monad/Functor?
17:36:06 <Philippa_> though mostly it's on the list
17:36:17 <Cale> oh, that one :)
17:36:19 <Philippa_> not top of the list, I imagine. You submitted something on it?
17:36:32 <Cale> I haven't submitted anything to Haskell'
17:36:50 <Cale> I went on at length on Haskell and Haskell-cafe at various points
17:37:05 <Cale> We should really bring back MonadZero
17:37:11 <Cale> and fix do-notation
17:37:13 <Philippa_> yeah, I don't think that's appropriate for the full scale of what it could be - once you have _variables, there's point in doing lexical scoping and having top-level ones
17:37:39 <dons> TuringTest, great work. runs twice as fast as existing entry on my box.
17:37:54 <dons> and 4x as fast as the shootout entry (which doesn't use -fexcess-precision)
17:38:27 <Cale> what do people think of generalising k-patterns to arbitrary members of Eq?
17:39:04 <dons> TuringTest, oh, really close to the C entry on my box :)
17:39:10 <Cale> We could even make previous variables bound by patterns in a parameter list available, so that for example, one could write:
17:39:20 <Cale> let f x x = x; f _ _ = 0
17:39:49 <Philippa_> Cale: hrmm...
17:39:55 <Philippa_> I'd quite like transformational patterns, I think
17:40:27 <Philippa_> though knowing my luck the next twenty times I'd like to use them'll have monadic operations for transformations so I won't be able to use them anyway
17:41:57 <palomer> k-patterns?
17:42:04 <Philippa_> numeric constants
17:42:23 <palomer> don't forget string patterns
17:42:26 <dons> did anyone else know about: default(Int) ?
17:42:31 <palomer> Cale: I'm all for it
17:42:36 <Igloo> dons: I did
17:42:37 <Cale> palomer: right, this would allow that
17:42:46 <palomer> but you already have string patterns
17:42:47 <Igloo> Cale: Can you give an example other than repeated variables?
17:43:01 <dons> @karma+ Igloo   -- somehow I'd gone 8 years without knowing about that
17:43:02 <lambdabot> Igloo's karma raised to 7.
17:43:13 <palomer> > (\("hello")->5) "hello"
17:43:14 <lambdabot> 5
17:43:14 <Philippa_> string patterns aren't overloaded though, hence the proposal to remove k-patterns
17:43:18 <Cale> I knew about defaulting too :)
17:43:24 <Igloo> I did write a parser, though, so I've gone over every inch of the syntax  :-)
17:43:30 <palomer> > (\("hello")->5) "bye"
17:43:31 <lambdabot>  Non-exhaustive patterns in lambda
17:43:35 <dons> ah, whereas I just stole a parser
17:43:42 <Cale> so this would generalise string patterns and k-patterns at the same time.
17:43:44 <jethr0_> dons: i pasted my profile of turingtest's entry at "http://paste.lisp.org/display/16087", but it says almost nothing :( any suggestions?
17:43:47 <palomer> Philippa_: aren't overloaded? I don't see the difference between string pattens and k-patterns
17:43:59 <Cale> I just read the report at one point :)
17:44:08 <dons> jethr0_, oh, I'm hacking away at it now.
17:44:21 <Cale> palomer: string patterns don't generate Eq constraints
17:44:32 <dons> oh, your profile is borked jethr0_
17:44:32 <Cale> since String is obviously already in q
17:44:32 <palomer> k-patterns do?
17:44:34 <Cale> Eq
17:44:34 <jethr0_> hehe, just wanted to develop my profiling skills on this one, but i guess it's not the ideal entry level
17:44:37 <Cale> palomer: yep
17:45:00 <dons> jethr0_, try to get a working profile first. turn of -optc-O3 if that's what's breaking the mangler
17:45:01 <palomer> wait wait wait...rewind, k-patterns are patterns on numbers, like 5 and 6
17:45:04 <Cale> well, actually, k-patterns are the reason for the Eq constraint on class Num
17:45:07 <palomer> how does that generate eq constraints?
17:45:10 <jethr0_> dons: did that.
17:45:18 <Cale> 5 and 6 are numbers of an arbitrary type
17:45:22 <jethr0_> dons: but i guess i might turn off some other optimizations too
17:45:36 <Cale> not all Num types would otherwise be comparable
17:45:38 <dons> your profile looks nothing like mine :/
17:45:43 <palomer> ahh, I see
17:45:59 <palomer> so why do we want to remove k-patterns ? (that would suck)
17:46:05 <jethr0_> weird
17:46:11 <Cale> palomer: I was saying we should generalise them
17:46:19 * araujo looks around
17:46:41 <dons> forall a  Cale wants to generalise a
17:46:49 <Cale> dons: yeah, pretty much.
17:46:53 <Cale> hehe
17:47:50 <Cale> If there's places with room for generalisation, it makes the language seem less natural.
17:47:54 <dons> jethr0_: http://www.cse.unsw.edu.au/~dons/c.prof
17:48:01 <jethr0_> thx
17:48:08 <palomer> <Philippa_> string patterns aren't overloaded though, hence the proposal to remove k-patterns <--remove k-patterns?
17:48:11 <jethr0_> i might have forgotten some params *ups*
17:48:17 <Cale> palomer: oh, that's Olaf
17:48:24 <dons> jethr0_, -prof -auto-all ?
17:48:32 <Cale> Olaf is proposing to remove all sorts of patterns.
17:48:39 <palomer> so olaf and you both agree: remove inconsistencies
17:48:44 <Cale> Including ~ patterns, which I think is nuts
17:49:04 <Cale> Yeah, we just have different ways of dealing with it
17:49:48 <Philippa_> he wants no ! patterns too
17:49:55 <jethr0_> dons: never mind, i'll use your profile for now
17:49:57 <Cale> When I see some special case, I want to generalise it until it doesn't seem like a special case rather than remove it.
17:49:59 <Philippa_> I don't have anything polite to say for his reasoning there
17:50:07 <SamB> what are ! patterns?
17:50:19 <Cale> ! patterns are a new proposal
17:50:24 <Philippa_> in this case, they're proposed as strict patterns
17:50:26 <Cale> They're somewhat dual to ~ patterns
17:50:30 <dons> yeah, I want ! patterns.
17:50:35 <Cale> I like it too
17:50:39 <SamB> sounds nice too me
17:50:42 <SamB> er, to
17:50:43 <Philippa_> though ! was also used for transformational patterns in the paper that gave us pattern guards
17:50:44 <Cale> it makes ~ patterns seem more natural as well
17:50:57 <dons> yes. that's a good point
17:52:40 <Philippa_> it seems to me that laziness is an "it could be either" point between call-by-value and call-by-name
17:52:58 <palomer> I want lambda terms to take STRefs as paramaters, how do I do this? Lam (STref Term Term) Term ?
17:53:20 <Philippa_> you need to parametise your Term type on the STRef's s
17:53:27 <Igloo> Cale: Do you use ~ patterns a lot?
17:53:32 * Igloo has never used them that I can remember
17:53:43 <palomer> but what is STRef's s, exactly?
17:53:57 <Philippa_> palomer: the tyvar associated with an STRef that's usually named s
17:54:08 <Cale> Igloo: they're not too common, but when you do want them, they're important
17:54:12 <Philippa_> the one that's normally instantiated by the forall in runST
17:54:32 <Cale> Igloo: I suppose that you can translate if you have enough extractor functions for your type
17:54:50 <Igloo> You don't need extractor functions, you just let bind it
17:55:12 <Igloo> foo ~p   ===>   foo x = let p = x in
17:55:29 <Cale> That's only because let implicitly sticks ~ on pattern bindings
17:55:31 <palomer> Philippa_: but what does it represent, intuitively?
17:56:03 <Philippa_> palomer: the heap the reference's cell's in
17:56:18 <palomer> oh, so it simply needs to be dragged along all the time?
17:56:21 <Philippa_> yeah
17:56:24 <palomer> and ignored?
17:56:26 <Philippa_> yup
17:56:30 <Philippa_> never try to force it
17:56:38 <palomer> does it serve a purpose?
17:56:41 <Philippa_> (unless you make it RealWorld, but you'll know when to do that)
17:56:41 <Philippa_> yes
17:56:46 <Cale> palomer: you just need to ensure that it remains polymorphic, or you can't runST
17:56:57 <Philippa_> it makes sure you don't try to use it with another heap (as created and deallocated by runST)
17:57:05 <Philippa_> the actual implementation isn't quite like that, but it's close enough
17:57:09 <palomer> gotcha
17:57:20 <palomer> someone give me an operator that's close to -> that I can use as a constructor
17:57:26 <Philippa_> anyway, I'm being requested bedwards
17:57:28 <Cale> @type Control.Monad.ST.runST
17:57:29 <lambdabot> forall a. (forall s. GHC.ST.ST s a) -> a
17:57:32 <Philippa_> :-> is common
17:57:39 <palomer> any others?
17:57:43 <Cale> ~>
17:57:48 <Cale> with the right font :)
17:57:58 <Philippa_> -->, ~>...
17:58:09 <Philippa_> anyway, 'moff
17:58:28 <Cale> oh, as a constructor, you have to have it start with :
17:58:28 <carp> but you need to it to start with : if you want it to be infix right?
17:58:35 <carp> (too slow)
17:58:54 <Cale> You can define infix operators which start with other symbols of course :)
17:59:12 <Cale> but if you want to be able to pattern match with it, it must start with :
18:00:25 <palomer> ~> doesn't work
18:00:30 <palomer> cya Philippa_ 
18:00:36 <Cale> not as a constructor, but as an infix operator
18:00:47 <palomer> got it
18:00:48 <Cale> you could use :~> as a constructor
18:01:50 <carp> it's all wrong : should be for typing
18:02:10 <palomer> oh boy, now I'm going to have two sets of type constructors: Tyvar, :->, STyvar, :~>
18:02:11 <Cale> I rather like : as cons
18:02:28 <Cale> You don't type :: nearly as much
18:02:44 <carp> I do
18:02:53 <Cale> as cons?
18:02:56 <palomer> ah hah, that's why they had constructors start with :
18:02:58 <palomer> very cleaver
18:03:15 <Cale> :)
18:03:39 <palomer> all ghc needs to do is allow us to define our own derivation
18:03:41 <carp> i type :: more often i mean
18:04:25 <carp> : is the original infix constructor :)
18:06:56 * palomer is using STRefs as a way to create unique names
18:06:58 <palomer> is this evil?
18:07:39 <Cale> not necessarily, no
18:08:02 <palomer> they'll be STRef s ()
18:08:03 <Cale> how many streams of unique names do you need though?
18:08:12 <Cale> oh?
18:08:23 <carp> palomer: are you implementing a lambda calculus?
18:08:29 <palomer> carp: yes
18:08:34 <palomer> actually, only type inference
18:08:36 <carp> cool
18:08:43 <palomer> though eval is _much_ easier to write with STRefs
18:08:47 <palomer> you avoid substitutions completely
18:08:58 <palomer> and you don't need to create new names
18:09:52 * palomer wonders why STRef isn't an instance of Ord
18:09:54 <palomer> seriously
18:10:23 <Cale> um
18:10:33 <Cale> can you write the instance?
18:10:49 <palomer> I can't
18:11:01 <palomer> but STRef does use some magic under the hood, no?
18:11:09 <palomer> they could do it with magic
18:11:21 <Cale> yeah, it's unclear to me that the magic is ordered :)
18:11:27 <eivuokko> Hmm
18:11:33 <palomer> STRefs represent memory location
18:11:36 <palomer> s
18:11:38 <Cale> sort of
18:11:41 <palomer> which are ordered
18:11:45 <Cale> maybe
18:12:11 <carp> is it possible to override : ?
18:12:27 <palomer> > let : = 5 in (:)
18:12:28 <lambdabot>  parse error on input `:'
18:12:34 <palomer> > let (:) = 5 in (:)
18:12:34 <lambdabot>   Constructor `:' should have 2 arguments, but has been given 0
18:12:34 <lambdabot>   When checking the pattern: :
18:12:34 <lambdabot>   In a pattern binding: : = 5
18:13:31 <Cale> nope
18:13:40 <sproingie> if it starts with : it has to be infix and binary, no?
18:13:42 <Cale> even if you hide (:) from the prelude
18:13:43 <palomer> newUniversal = Universal (newSTRef ()) <--how can I do something like this?
18:14:01 <sproingie> > let (:) _ _ = 5 in 123 : 456
18:14:02 <lambdabot>  add an instance declaration for (Num [a])
18:14:18 <Cale> newUniversal = do x <- newSTRef (); return (Universal x) ?
18:14:47 <palomer> good point:o
18:15:00 <Cale> that's a boring type
18:15:04 <carp> I'd just like to use it as a infix constructor for something else
18:15:18 <Cale> STRef's can't be empty, so STRef () is really boring
18:15:25 <Cale> er
18:15:28 <Cale> STRef s ()
18:15:29 <palomer> how is it a boring type?
18:15:50 <Cale> you know what you're going to get from the STRef before you even read it
18:16:03 <Cale> you can only put bottom and () into the STRef
18:16:15 <Cale> and it's kind of bad to put bottom there
18:16:25 <palomer> but I need (==)
18:16:32 <palomer> (and it would be nice to have Ord)
18:16:32 <sproingie> i love how bottom looks like ascii art if you parenthesize it
18:16:35 <Cale> hm?
18:16:35 <sproingie> (_|_)
18:17:12 <Cale> oh
18:17:17 <Cale> they are comparable
18:17:20 <palomer> Cale: I'll need to compare STRefs, a Universal is only equal to itself, and I need to create a new Universal once in a while
18:17:22 <Cale> that's interesting
18:17:45 <Cale> I didn't realise that STRef was an instance of Eq
18:17:58 <palomer> yeah, this is why I wanted Ord too!
18:18:19 * jethr0_ just look at the java source of nbodies, and find the respective haskell code quite unattractive :)
18:18:24 <jethr0_> *finds
18:18:53 <Cale> palomer: you know you don't need full ST to get those
18:19:35 <Cale> http://www.haskell.org/hawiki/MonadUnique
18:19:54 <Cale> those will be comparable via Ord, if you use Integer
18:20:00 <palomer> hah, cool
18:20:03 <Cale> er, it does
18:20:27 <palomer> but... I also need ST for other things, and I don't like (or even know) how to mix my monads
18:20:50 <palomer> is it possible to write local functions without a let binding?
18:20:56 <palomer> (like the local keyword in sml)
18:20:56 <Cale> where :)
18:21:23 <Cale> depending on what you mean by local...
18:21:48 <Cale> The only difference between let and where is that where is part of declaration syntax and scopes over guards.
18:21:50 <jethr0_> is there a naive translation of the java example code for NBody around?
18:22:02 <palomer> local a = 5 in foo x = a end <--a is only viewable in that scope
18:22:33 <palomer> oh, I didn't know where was a declaration
18:22:39 <palomer> this means it can only appear at the toplevel, right?
18:22:41 <sproingie> > a where a = 5
18:22:42 <lambdabot> 5
18:23:01 <palomer> but where indents all my code:o
18:23:54 <gzl> it ... should.
18:24:27 <int-e> >`let a = 6  in (let a = 5 in a) + a
18:24:43 <int-e> > let a = 6  in (let a = 5 in a) + a
18:24:44 <lambdabot> 11
18:26:39 <Cale> I'm surprised by John Hughes suggestion regarding the Monomorphism restriction.
18:26:48 <SamB> what is it?
18:26:54 <SamB> where is it?
18:27:05 <Cale> on haskell-prime
18:27:24 <Cale> I'm surprised that it's not labelled with a title like "A Modest Proposal"
18:27:32 <gzl> haha
18:27:36 <gzl> good reference
18:27:52 <araujo> @index rawCommand
18:27:52 <lambdabot> bzzt
18:28:05 <araujo> @index rawProcess
18:28:06 <lambdabot> bzzt
18:29:07 <Cale> the idea is that monomorphic and polymorphic binding are different enough to use separate symbols
18:30:18 <Cale> = would be bind-by-name (overloaded) and := would be bind-by-need (monomorphic)
18:31:45 <araujo> ?
18:31:51 <Cale> exactly
18:33:15 <palomer> ?
18:34:59 <Cale> (read the actual proposal for details)
18:35:35 <Cale> http://www.haskell.org//pipermail/haskell-prime/2006-January/000038.html
18:36:11 <yain> hi.
18:36:14 <Cale> hi
18:36:51 <yain> if I want to remove libglut and install freeglut, do I need to recompile GHC so it can use new library? or rather how do I get away with little recompiling?
18:37:09 <Cale> hmm
18:37:11 <palomer> what monad should you use when you just want to pass an implicit element (a map) which you once in a while update and at the end return?
18:37:26 <yain> and by the way, why freebsd port of GHC depends on libglut and not on freeglut?
18:37:39 <palomer> darcs depends on libglut in freebsd
18:37:41 <Cale> yain: I don't know anything about freeglut, but most GL stuff always uses the same names for libraries so as to be drop-in replaceable
18:38:01 <lispy> palomer: hmmm, you want to update variable bindings in your interpreter?
18:38:01 <Cale> palomer: State
18:38:17 <monochrom> I would try the State monad.
18:38:40 <lispy> isn't there a monad that does environments?
18:38:47 <lispy> it's like the reader or writer monad?
18:38:49 <Cale> lispy: Reader
18:38:58 <Cale> but those environments aren't mutable
18:39:26 <Cale> (unless you're using something like a ReaderT (MVar T) IO
18:39:28 <Cale> )
18:39:56 <lispy> what about ReaderT (MVar T) ST ?
18:40:05 <lispy> i'm trying to ask if you can use the state monad with it
18:40:19 <yain> Cale: you mean it will 'just work'?
18:41:01 <lispy> yain: those replacement libraries often 'just work', but who knows without trying it :)
18:41:51 <Cale> yain: hopefully
18:42:20 <Cale> lispy: well, you wouldn't be able to modify the MVar in ST
18:42:26 <palomer> how does reader do environments?
18:42:29 <Cale> (or even read it)
18:42:46 <palomer> lisppaste2: no, I'm going through a tree like datatype, and to each string im incrementing a count
18:42:53 <palomer> err, that was meant for lispy
18:42:54 <Cale> palomer: The Reader monad is just a fancy name for functions from a specified type
18:43:10 <Cale> your computations "read" the value of that type
18:43:12 <palomer> so I'm counting the number of unique names in a tree
18:43:25 <yain> Cale: well, GHC uses dlsym()?
18:43:37 <yain> Cale: there is one function which is missing from libglut.
18:45:00 <Cale> yain: I'm not really sure. Have you tried it?
18:45:17 <yain> I will, it's building atm.
18:46:40 <monochrom> I would try the State monad.
18:47:04 <lispy> Cale: well, doesn't ST have some equivalent to MVar?
18:48:27 <palomer> yeah, just realized that I had to work in ST anywho
18:50:03 <palomer> hrm, I want to create a map from Strings to STRefs
18:50:09 <palomer> this, of course, can't be done
18:52:04 <palomer> hrmph.
18:52:10 <palomer> how do I get around this?
18:52:57 <int-e> @index trace
18:52:58 <lambdabot> Debug.Trace
18:54:32 <lispy> > cycle []
18:54:33 <lambdabot> Add a type signature
18:54:41 <lispy> > cycle [] :: [Int]
18:54:42 <lambdabot> Exception: Prelude.cycle: empty list
18:55:05 <lispy> palomer: why do you need the map?
18:55:36 <palomer> well, I'm it's a map literal
18:55:48 <palomer> I'll pass it around to other things, and their jobs are going to be to make it bigger
18:56:15 <lispy> you're trying to thread some datastructure around that keeps getting bigger?
18:56:43 <palomer> well, no, not exactly
18:56:47 <lispy> well, the naive solution is to store the whole datastructure using one STRef, or each element could be an STRef.
18:57:07 <palomer> this map is going to be the starting point of many other functions
18:57:17 <palomer> like image that I have functions that return maps
18:57:38 <palomer> (geographic maps)
18:57:51 <palomer> and I absolutely want detroit to be on every single one of those maps
18:58:01 <palomer> so I'll always pass a starting map which has montreal
18:58:37 * lispy notes this is getting weird ;)
18:59:08 <monochrom> palomer's requirements are always weird.
18:59:24 * lispy wonders why they didn't define cycle [] = []
18:59:25 <yain> Cale: it doesn't work, but haskell libs somehow were built with this symbol included.
18:59:46 <lispy> yain: are you trying to build or install binaries?
18:59:52 <yain> if I understand the problem correctly something is linking against the wrong libglut.so
19:00:02 <yain> lispy: I'm try to not build.
19:00:10 <yain> lispy: that is I don't want to rebuild ghc.
19:00:15 <monochrom> heh, yeah, cycle [] = [] that would be uniform.
19:00:32 <lispy> yain: i think there are commands for inspecting what a binary will try to link with, maybe those would help?  sometimes you can cheat and use symlinks
19:00:57 <palomer> do you guys know what would be cool? if you could tag some extra information on every node of a datatype
19:01:39 <palomer> I think they call this "generic programming"
19:01:53 <monochrom> Yes.  Some Template Haskell tricks may do it.
19:03:16 <palomer> like, I have some terms, and I want every subterm to be typed
19:03:22 <palomer> this is tagging information
19:03:46 <yain> lispy: well, yes, but that's not a haskell question :)
19:04:29 <yain> lispy: I can symlink libgluts libglut.so to one which freeglut provides.
19:04:38 <yain> but this can't be right way!
19:04:41 <Cale> palomer: you can't?
19:05:00 <lispy> yain: that's why it's cheating :)
19:05:06 <Cale> Map String (STRef s a) should be a perfectly okay type
19:06:12 <araujo> There exist a function to run two processes in parallel?
19:06:27 <palomer> Cale: it's a perfectly ok type, but try creating a value
19:06:48 <palomer> which contains newrefs
19:07:00 <Cale> why shouldn't you be able to?
19:07:14 <Cale> Only String needs the Ord constraint
19:07:35 <Cale> (which it satisfies)
19:07:42 <palomer> do {u <- newSTRef 0; return (insert "foo" u empty)}
19:07:49 <palomer> it doesn't have the right type
19:07:55 <palomer> this has the ST type
19:08:37 <Cale> you can't return that map
19:08:45 <Cale> but you can certainly use it
19:08:59 <palomer> yeah, inside the ST monad
19:09:02 <Cale> yeah
19:09:12 <palomer> which is a bummer:o!
19:09:16 <palomer> but, is to be expected
19:09:26 <palomer> hrm, this not being able to tag is a total bummer
19:09:33 <palomer> it means I have to recopy the datatype
19:09:36 <Cale> well, use integers :)
19:10:01 <palomer> integers for what?
19:10:17 <lispy> heh, and use #define
19:10:18 <Cale> in place of the STRef ()'s
19:10:35 <palomer> Cale: oh no, that would be defeating the purpose
19:10:49 <palomer> ok, I'm going to do something totally unsafe: n-ary trees to simulate datatypes
19:10:52 <palomer> on the agony!
19:10:55 <lispy> #define TAG1 0x0001, #define TAG2 0x0002, #define TAG3 0x0004 ...
19:11:37 <Cale> the purpose?
19:11:39 <palomer> s/on/oh
19:11:45 <palomer> Cale: of the map
19:11:51 <Cale> oh
19:12:01 <Cale> well, that's maybe good? :)
19:12:05 <lispy> Cale: i was teasing about using integers as tags, that makes it like using C :)
19:12:37 <monochrom> Why must you return a map of references?  Are you just using Haskell as though you're using SML?
19:12:38 <Cale> lispy: sort of, but it's appropriate -- really, if you cared, you could newtype Integer and not derive Num
19:12:43 <lispy> defined correctly you have one bit set for each tag and then you can "or" them together :)
19:13:00 <Cale> lispy: oh
19:13:03 <Cale> in that sense
19:13:11 <monochrom> I would use a map of references before I return, but I will translate that map to a map of counts for returning.
19:13:31 * lispy would use mapReduce ala Google ;)
19:13:43 <palomer> data TaggedTerm s = AppTerm Term (SType s) (TaggedTerm s) (TaggedTerm s) |                     LamTerm Term (Stype s) (TaggedTerm s) | ... <--oh the agony!
19:13:58 <monochrom> So, I'm saying, I'm going out on a limb and guess that your overall design has problems to begin with.
19:14:22 <palomer> how so?
19:14:29 <Cale> there seems to be something unnatural here
19:14:36 <palomer> the design is quite clean
19:14:42 <palomer> I'm doing type inference
19:14:56 <palomer> and I want to tag infered types to every one of my nodes
19:15:05 <Cale> using STRef ()'s as uniques is a little odd, when Integers will do.
19:15:29 <palomer> Cale: I have to do this in ST anyways, since I'll be using other kinds of STRefs for other things
19:15:46 <Cale> yeah, but you can do the same thing in ST as I did in State
19:16:22 <Cale> hang on a moment and I'll illustrate with code :)
19:17:02 <palomer> univarsals might be STRef s ()
19:17:18 <palomer> but there are other kinds of pointers
19:19:31 * palomer is finding the type system restrictive for the first time in his life
19:19:38 * palomer feels like shutting it off for a while
19:19:49 <Cale> hang on one sec :)
19:20:13 <palomer> Cale: you're going to fix my tagging problem ? 
19:20:15 * palomer jumps for joy
19:20:36 <palomer> data TaggedTerm s = Nullary Term (SType s) |                    Unary Term (Stype s) (TaggedTerm s) |                    Binary Term (SType s) (TaggedTerm s) (TaggedTerm s) <--latest solution
19:21:00 <palomer> it, unfortunetly, doesn't work
19:21:17 <araujo> What is the best way to run two processes in parallel?
19:22:13 <Cale> *Main> runST (do { fresh <- createSupply; x <- fresh; y <- fresh; return (x,y) })
19:22:13 <Cale> (0,1)
19:22:17 <Cale> how does that look?
19:22:39 <palomer> Cale: but I need much more than a fresh supply of variables
19:22:43 <Cale> hm?
19:22:45 <Cale> what else?
19:22:52 <palomer> newExistential = do x<- (newSTRef Nothing)
19:22:52 <palomer>                     return (Existential x)
19:23:03 <Cale> sorry, what?
19:23:08 <palomer> data SType s = Universal (STRef s ()) | Existential (STRef s (Maybe (SType s))) | (SType s) :~> (SType s)
19:23:27 <lispy> araujo: no clue
19:23:44 <palomer> this is why I can't just use the State Monad
19:23:45 <lispy> araujo: i have heard of unsafeInterleaveIO or some such, i wonder if that is related
19:23:48 <monochrom> I think you should let us know why you must return references and you think there is no good alternative.
19:23:51 <palomer> and besides, I find STRef s () cleaner
19:23:58 <Cale> palomer: um
19:24:12 <Cale> I don't see the difference between that and an integer together with a map
19:24:15 <palomer> monochrom: hmm? I don't think I should return references
19:24:27 <palomer> Cale: for existentials?
19:24:29 <Cale> yeah
19:24:39 <Cale> perhaps I'm misunderstanding
19:24:50 <Cale> why is it STRef'd here?
19:24:57 <palomer> what is?
19:25:00 <monochrom> Yeah, precisely my question.
19:25:04 <Cale> Existential
19:25:14 <araujo> lispy, mm.. ok, i'll check that one, Thanks
19:25:20 <palomer> because I'll want to instantiate it at some point
19:25:24 <Cale> you're using STRefs as unknowns in the typing
19:25:26 <Cale> ?
19:25:46 <palomer> hmm?
19:25:52 <palomer> Cale: yeah
19:26:07 <palomer> I thought this was how everyone does type inference
19:26:21 <lispy> could you use an algebraic datatype as your "type" tags?
19:26:30 <Cale> I just used a map from Integers to types.
19:26:33 <Cale> hehe
19:26:41 <lispy> data Type = Unknown | Type Int
19:26:50 <lispy> except, type is taken, so TypeT
19:26:54 <palomer> Cale: but isn't that what STRefs are precisely for?
19:27:01 <palomer> anyways, this way is probably faster (and seems cleaner)
19:27:04 <Cale> okay
19:27:07 <palomer> Type isn't taken
19:27:07 <Cale> yeah, it could be
19:27:13 <lispy> and since this type is isomorphic to Maybe, you'd just use Maybe Int
19:27:17 <Cale> so what's the map for?
19:27:30 <palomer> oh, that's for the universal variables
19:27:35 <Cale> (and why would you ever need to return it?)
19:27:50 <palomer> well, no, but it would be sometimes handy if I could
19:28:04 <lispy> palomer: i don't buy the faster, ghc does amazing optimization of seeming slow things and poor optimizations of other things
19:28:16 <Cale> you could construct a new map by reading all the STRefs in it
19:28:21 <Cale> and return that
19:28:22 <palomer> lispy: well this is O(1) lookup
19:28:32 <dons> jethro_, mmm. 4x 
19:28:36 <monochrom> Precisely what I suggested at first.
19:29:10 <Cale> but I'm not sure why you're ever going to need it outside of your algorithm :)
19:29:16 <palomer> I'll want to use the map in ST anyways, I was just yearning for the simplicity of my sml days
19:29:24 <palomer> but, like, it's no big deal
19:29:29 <palomer> tagging is, though, huge deal
19:29:43 <Cale> It's preventing you from doing things which are dangerous. :)
19:29:57 <palomer> maybe I could write a tagging monad
19:30:17 <dons> jethro_, hmm, I mean. mmm. 1.2x unoptimised C now! http://www.cse.unsw.edu.au/~dons/d.prof
19:30:33 <monochrom> You see my sentiment.  After observing this person's questions for a month, you kind of get an impression that he's deliberately designing programs to be unwritable in Haskell.
19:30:58 <palomer> I can assure you I'm not
19:31:10 <Cale> Sure, you could design a cute new monad to do this in. You could even newtype ST.
19:32:03 <Cale> the neat thing about monads is that if you don't like Haskell, it's easy to sort of write your own language to solve the problem in.
19:32:21 <palomer> yeah, I've come to the conclusion that that's the point of monads
19:32:24 <Cale> (of course, it's still Haskell :)
19:32:32 <Cale> That's one of the major points anyway
19:32:33 <palomer> DSL incorporated into a functional type system
19:33:15 <Cale> I think there's a lot to be said for the container perspective. Perhaps even some neat things which we haven't noticed yet. It's all the same in the end though.
19:34:23 <Cale> Purely from a programming perspective, constructing DSLs on the fly with only a small amount of code is a huge win.
19:35:32 <palomer> oh my, I have to write my first type class
19:35:48 <Cale> Monad transformers are an almost perfect way to pick and choose the raw features to support your DSL. I find it's best not to expose the transformed monad though -- you newtype the thing and only expose the specific actions which you want, which are often refinements of the general ones the transformers give you.
19:36:29 <Cale> (newtype deriving is the magic that makes that convenient)
19:36:33 * lispy needs to take a week or two just to play with monad transforms
19:36:49 <lispy> i don't quite get what the monad transformers do (yet)
19:36:53 <palomer> how do I define a new class containing a single member getTag ?
19:37:02 <Cale> I have this great little example -- did everyone see my Sudoku solver?
19:37:14 <Cale> class MyClass c where
19:37:16 <lispy> Cale: i didn't but it might blow my mind :)
19:37:20 <Cale>    getTag :: ...
19:37:57 <Cale> http://vx.hn.org/autoshare/MonadicSudoku.tar.bz2
19:38:23 <Cale> you can ignore the use of MonadNondet -- that's roughly isomorphic to the list monad, but faster
19:39:08 <lispy> Cale: hmm...how do you use darcs on a .bz2? ;)
19:39:09 <Cale> (in fact, you can replace the occurrence of 'Nondet' in Sudoku.hs with [], and it will still work
19:39:20 <palomer> how much slower?
19:39:24 <Cale> lispy: sorry, it's not a darcs repo
19:39:24 <yain> hm, why can't I 'import Packages'?
19:39:40 <Cale> palomer: Nondet is about twice as fast as [] iirc.
19:39:52 <Cale> [] has more features though :)
19:39:53 <lispy> Cale: well, it ought to be :)
19:40:21 <Cale> interestingly, it's only faster if you compile with optimisations
19:40:24 <palomer> the compiler should be able to detect when [] can be replaced with nondet
19:40:29 <Cale> It's actually slower without
19:40:43 <Cale> palomer: yeah, they're working towards that
19:40:49 <Cale> It's called deforestation
19:42:13 <lispy> Cale: that's really very little code, I'll read it later after i study some monad tranformers an an example of what you can do.  Looks neat tho
19:42:54 <Cale> lispy: especially fun is how naive the solver looks
19:43:05 <Cale> solve = forM [(i,j) | i <- [1..9], j <- [1..9]] $ \(i,j) -> do
19:43:06 <Cale>     v <- valAt (i,j)
19:43:06 <Cale>     when (v == 0) $ do
19:43:06 <Cale>         a <- option [1..9]
19:43:06 <Cale>         place (i,j) a
19:43:37 <Cale> basically "loop over the positions in the grid, and each one is one of the numbers 1 up to 9"
19:44:00 <lispy> heh, yeah
19:44:10 <lispy> what is the O?
19:44:17 <Cale> 0 means empty
19:44:27 <lispy> the asymptotic complexiting, smarty :)
19:44:45 <lispy> complexity*
19:44:54 <Cale> oh
19:45:03 <Cale> it's just a backtracking search
19:45:13 <Cale> so on some puzzles, it will fail miserably
19:45:14 <lispy> yeah and since the board size is fixed it's O(1)
19:45:18 <Cale> heh
19:45:20 <Cale> yeah
19:45:35 <lispy> hehe, nice you have an O(1) sudoku solver :)
19:46:03 <lispy> is it pretty quick tho?  like 10seconds or less on most input?
19:46:10 <Cale> yeah
19:46:20 <Cale> on all human-solvable ones, it's fast
19:46:28 <lispy> hmm...this should be a benchmark at the shootout
19:46:52 <Cale> If you want to do better, you'd use Knuth's dancing links algorithm
19:46:55 <lispy> well, assuming you don't want to benchmark raw speed
19:47:06 <Cale> I've yet to construct a monad specialised to that one :)
19:47:14 <palomer> http://www.rafb.net/paste/results/65ijrh68.html <--oh the humanity!
19:47:36 <Cale> palomer: maybe some type synonyms?
19:47:46 <lispy> yeah
19:47:54 <lispy> that's just gross
19:47:55 <palomer> like what?
19:48:01 <Cale> like, TypeRef s = STRef s (Maybe (SType s))
19:48:07 <palomer> oh, righto
19:48:58 <lispy> i'm reading about quickcheck, i thought their implemenation would be really hair, but 300 lines was their implementation in 2000
19:49:05 <lispy> hairy*
19:56:57 <Korollary> neat. a C-- frontend in haskell
19:59:06 <Cale> Korollary: yeah :)
20:02:03 <yain> finally.
20:02:24 <yain> the solution was to edit /usr/local/lib/ghc-6.4.1/package.conf
20:02:25 <dons> ? we've had parsers and lexers for a couple of years
20:02:29 <dons> since the Cmm rewrite in ghc
20:03:08 <dons> ah, or maybe yain wasn't responding to Korollary.
20:03:16 <yain> nope.
20:03:35 <yain> I was announcing the fact that I finally managed to make ghci load correct glut so.
20:04:11 <dons> ok :)
20:06:05 <yain> I still don't understand one thing.
20:06:30 <yain> <palomer> darcs depends on libglut in freebsd
20:06:34 <yain> how's that?
20:07:21 <palomer> I don't know
20:07:27 <palomer> but my sysadmin couldn't install darcs
20:07:32 <palomer> because it depended on libglut
20:07:38 * yain checks.
20:08:08 <Cale> it doesn't depend on it in any real way
20:08:17 <yain> well, yes, it makes little sense.
20:08:17 <dons> darcs doesn't need libglut?
20:08:20 <dons> that's crazy
20:08:21 <Korollary> oooh, bumpmapped patches?
20:08:48 <yain> so.. any reason to not change haskell port to depend on freeglut?
20:09:11 <yain> palomer: no, it doesn't.
20:09:23 <Cale> yain: are they 100% interface compatible?
20:09:41 <yain> well, I don't know. I haven't used either that much.
20:09:53 <palomer> oh my god Data.Map is annoying
20:09:59 <yain> the thing is, freeglut has some useful functions (which haskell module support).
20:10:21 <palomer> I'm just repeating what the sysadmin told me (and pasted)
20:10:22 <Cale> hmm
20:10:31 <Cale> palomer: how?
20:10:38 <yain> palomer: fire him.
20:10:40 <dons> palomer, you complain a lot.
20:10:45 <Cale> if it's the import business, you just do:
20:10:56 <Cale> import qualified Data.Map
20:11:01 <Cale> import Data.Map (Map)
20:11:05 <Cale> er
20:11:08 <Cale> import qualified Data.Map as Map
20:11:10 <palomer> dons: but it's not mean complaining
20:11:21 <palomer> it's not like I'm genuinely annoyed or anything
20:11:44 <Cale> what's the Data.Map issue?
20:12:13 <palomer> lookup
20:12:18 <palomer> actually, I'll hide it from prelude
20:12:32 <Cale> Data.Map is intended to be imported qualified
20:12:34 <palomer> how do you hide again?
20:12:35 <lisppaste2> yain pasted "darcs deps." at http://paste.lisp.org/display/16097
20:12:44 <Cale> import Prelude hiding (lookup)
20:13:39 <dons> import qualified Map as M -- is the other way
20:16:00 <yain> does simon marlow come here?
20:16:07 <Korollary> sometimes
20:16:31 <Cale> hmm
20:16:47 <Cale> glut isn't a direct dependency of darcs on debian
20:16:56 <yain> of course it's not.
20:17:02 <yain> that's just silly.
20:17:10 <Cale> and the libraries here don't look like they ought to require glut
20:18:26 <Cale> The ghc package may depend on glut though
20:18:33 <yain> I'll mail port maintainer then?
20:18:41 <palomer> http://www.rafb.net/paste/results/hnDbSB77.html <--anyone have any ideas?
20:19:14 <Cale> I know that the HOpenGL package has been separated in other distributions, it ought to be quite possible.
20:20:12 <palomer> oh my god I'm an idiot, I can use STRef to tag
20:21:18 <palomer> taggedTerm = (SType,STRef s Term)
20:22:33 <palomer> and then I can make a Tree of taggedTerms
20:22:47 <palomer> is there a Tree datastructure in haskell?
20:23:30 <Cale> there's Data.Tree, but there's not much to be gained over just defining one yourself
20:23:55 <yain> bye.
20:24:41 <palomer> Cale: any ideas about my little problem?
20:24:52 <Cale> hmm
20:25:38 <Cale> getTag :: c s -> SType s ?
20:26:13 <Cale> instance Tagged TParameter where
20:26:18 <Cale> that, or
20:26:28 <Cale> class Tagged c t | c -> t where
20:26:32 <palomer>     Kind error: Expecting kind `* -> *', but `TParameter s' has kind `*'
20:26:32 <palomer>     In the instance declaration for `Tagged (TParameter s)'
20:26:35 <Cale>    getTag :: c -> t
20:26:41 <Cale> right
20:26:50 <Cale> delete that s in the instance decl
20:27:18 <palomer> ah, gotcha
20:27:22 <palomer> though I don't understand any of this
20:27:25 <Cale> okay
20:27:31 <Cale> well, the problem is that the s isn't the same s
20:28:12 <Cale> It's like you're defining an instance of  Tagged (TParameter a) where getTag :: TParameter a -> SType s
20:28:49 <Cale> so either you abstract over the s, or you generalise a bit:
20:29:03 <Cale> class Tagged t c | c -> t where
20:29:08 <Cale>    getTag :: c -> t
20:29:26 <Cale> instance Tagged (SType s) (TParameter s)
20:29:29 <Cale> where ...
20:31:13 <palomer> yeah, thx
20:31:17 <Cale> that's a functional dependency meaning that the tag type can be determined uniquely from the type 'c'
20:33:30 <Cale> (It'll save you from annoyances later)
20:35:20 <palomer> so it has nothing to do with the arrow we all know and love?
20:37:26 <dons> yay, nbody now beats unoptimised C code.
20:38:06 <dons> that's usually my benchmark for when to stop.
20:40:13 * palomer read that as nobody
20:41:17 <palomer> oh, here's a case where I'd like to return a map of references: let getConstraints term = let universalMap = getMap term; gc Pattern = ... in gc term
20:42:03 <palomer> gc is a big mother of a function which will use universalMap in many places
20:48:05 <dons> jethro_, joelk, you may want to look at the new super-fast nbody: http://www.haskell.org/hawiki/NbodyEntry
20:48:42 <joelk> yeah, I wsa just thinking the same thing.
20:49:32 <Korollary> -fexcessprecision & -ffast-math shouldn't be used imho
20:54:51 <palomer> any plans for making STRef an instance of Ord?
20:55:36 <palomer> and is there a Map for keys which only implement Eq?
20:55:39 <dons> Korollary, why?
20:55:54 <dons> excess-precision is critical for Doubles in Haskell, 
20:59:19 <Korollary> excess precision violates ieee standards. if haskell uses it, others need to as well. Some languages can't.
21:00:51 <dons> shrug. some languages can't do tail calls.
21:01:06 <Korollary> it's not like that.
21:01:26 <Korollary> you can't have excess precision on some architectures at all.
21:01:53 <Korollary> for some reason, x86 has it, and it's faster.
21:02:14 <joelk> Korollary, but you have to give gcc -ffloat-store for it not to leave intermediate results in the fp registers, right?
21:03:01 <Korollary> joelk: I don't know for certain. But unless ffast-math is specified, gcc produces compliant code iirc.
21:04:19 <joelk> the gcc man page under -ffast-math, says, " This option should never be turned on by any -O option since it can result in incorrect output for programs which depend on an exact
21:04:19 <joelk>  implementation of IEEE or ISO rules/specifications for math functions."
21:11:23 <Korollary> joelk: you're right. -ffloat-store is also needed.
21:12:11 <Korollary> wow
21:12:13 <joelk> but -ffast-math is probably not so good. Perhaps that's what causes the errors with some of the programs
21:12:18 <Korollary> I just dropped this laptop on the floor
21:14:38 <joelk> Now that I think about it I remember a numerics course a few years back where I had to explain why my laptop gave more precision than the lab's expensive alphas...
21:20:30 <Cale> palomer: yeah, if you only have Eq, you might as well use [(a,b)]
21:21:16 <palomer> yeah, might as well
21:21:17 <palomer> :o
21:22:08 <Cale> I consider it a bit questionable that STRefs implement Eq in the first place, let alone Ord -- you might have to install some artificial machinery to get them in Ord. I suppose they could be ordered by creation or something.
21:22:58 <palomer> STRefs correspond to sml refs, from my understanding
21:23:02 <palomer> and those are stored in memory locations
21:23:08 <palomer> why not order them by memory location?
21:23:09 <Cale> well, they sort of do
21:23:28 <Cale> They're not necessarily implemented in a way which makes the memory location handy
21:23:44 <Cale> memory locations of heap-allocated objects aren't stable
21:24:11 <Cale> so that may not work, as your STRef might get moved by the garbage collector or something.
21:24:14 <palomer> oh?
21:24:24 <palomer> memory locations can move around?
21:24:39 <Cale> Well, I certainly wouldn't rely on them
21:24:43 <int-e> With copying garbage collection, sure.
21:24:55 <palomer> int-e: good point
21:24:59 <palomer> well, then by creation
21:25:00 <palomer> :o!
21:25:03 <Cale> right
21:25:24 <Cale> If you want an ST variant with that, I could do it :)
21:25:54 <palomer> thx for the offer, but performance isn't crucial (yet)
21:26:08 <palomer> would you newtype it?
21:26:25 <Cale> yep
21:27:05 <Cale> and define a lifter
21:28:13 <palomer> Ord does give us a whole lot
21:29:12 <dons> you need StablePtrs to make Ptrs stable ;)
21:30:23 <palomer> @hoogle StablePtrs
21:30:23 <lambdabot> No matches found
21:30:27 <palomer> no such thing!
21:30:33 <Cale> @index StablePtr
21:30:34 <lambdabot> Foreign.StablePtr, Foreign
21:31:13 <dons> palomer :p
21:34:26 <palomer> :o!
21:34:29 <palomer> I'm way tired
21:34:33 <palomer> been programming for about 5 hours
21:34:40 <palomer> another 5 hours tomorrow
21:34:41 <palomer> yay!
21:36:10 <dons> hmm. it would be sad to see `k' patterns go. our shootout entries would be more ugly ;)
21:36:45 <dons> k on Integral only would be very reasonable, though.
21:36:59 <palomer> @hoogle modifySTRef
21:36:59 <lambdabot> Data.STRef.Lazy.modifySTRef :: STRef s a -> (a -> a) -> ST s ()
21:36:59 <lambdabot> Data.STRef.modifySTRef :: STRef s a -> (a -> a) -> ST s ()
21:41:35 <palomer> @hoogle ST
21:41:36 <lambdabot> Control.Monad.ST.Lazy.ST :: ST s a
21:41:36 <lambdabot> Control.Monad.ST.ST :: ST s a
21:41:36 <lambdabot> Graphics.UI.ObjectIO.CommonDef.St :: s -> (a, s)
21:42:12 <palomer> solver.hs:6:25: Not in scope: type constructor or class `Control.Monad.ST.ST'
21:42:15 <palomer> eh?
21:43:10 <palomer> how would I annotate something like Int -> ST s () ?
21:45:31 <Cale> *STO> runSTO (do {r1 <- newSTORef "foo"; r2 <- newSTORef "bar"; return (r2 > r1)})
21:45:31 <Cale> True
21:46:51 <Cale> palomer: sure you imported Control.Monad.ST ?
21:47:16 <palomer> Data.Array.ST , I tried that too
21:47:22 <palomer> btw, what's the difference?
21:47:35 <Cale> You need to import Control.Monad.ST to get runST
21:47:44 <Cale> and the actual ST type
21:48:00 <palomer> ah
21:48:09 <palomer> runST sounds important:o
21:48:26 <SamB> why do you need the ST type?
21:48:37 <palomer> to annotate
21:49:04 <SamB> ah
21:50:37 <palomer> so...when is generic programming going to make it into ghc?
21:51:47 <Cale> wow -- anyone see Oleg's latest post?
21:52:26 <sieni> hmm...
21:52:45 <sieni> when did ghc jump to the almost top of the computer language shootout
21:52:55 <Cale> last couple of weeks
21:53:12 <Korollary> Cale: where?
21:53:27 <Cale> Haskell mailing list
21:53:40 <Cale> Incoherent instances can make ST monad unsound
21:54:15 <sieni> Ahh, Oleg <3
21:54:18 <Cale> He uses incoherent instances to write unsafePerformST
21:54:25 <jethr0_> dons: BTW, you don't have to update the velocities in "advance" in place, as they aren't used inside the double loop...
21:54:33 <Cale> and an instance of Typeable a
21:54:57 <Cale> which basically completely breaks referential transparency
21:54:59 <Korollary> hmm
21:55:54 <sieni> yeah, wrong settings
21:56:13 <sieni> now the shootout page gives weight to code lines and memory usage by default
21:56:52 <sieni> but it's still rather good
21:57:34 <Cale> It's second to top with equal weight
21:57:51 <Cale> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
21:57:59 <sieni> yes, but I'm only interested in speed :-)
21:58:21 <Cale> yeah, it's 3rd only considering speed
21:58:43 <Cale> D Digital Mars manages to squish in there
21:59:10 <jethr0_> -optc-O3 is totally shredding my results!
21:59:40 <sieni> Cale: depends on the setup
22:00:02 <Cale> I'm assuming 1,0,0
22:00:10 <sieni> http://shootout.alioth.debian.org/debian/benchmark.php?test=all&lang=all&calc=Calculate&xfullcpu=1&xmem=0&xloc=0
22:00:21 <sieni> seventh on debian+amd sempron
22:00:42 <Cale> yeah, the processor affects things a lot
22:01:04 <Cale> It does quite well on the P4 :)
22:02:12 <sieni> I guess the debian benchmarks are outdated, since there are more missing benchmarks there
22:02:48 <Cale> oh, that's possible
22:03:28 <palomer> Cale: you should make a uniqueMonad for the letters of the alphabet
22:03:40 <Cale> oh, I already have that
22:03:49 <Cale> MonadSupply on the wiki
22:04:08 <Cale> you give it a list of the things you want supplied in order
22:04:27 <palomer> ahh, I once wrote something like that too
22:04:31 <Cale> it's assumed to be infinite :)
22:07:17 <palomer> you should put example code on your webpage:P!
22:09:03 <Cale> let letters = [c | c <- ['a'..'z']] in [replicate k letters | k <- [1..]] >>= sequence
22:09:12 <Cale> that's a nice infinite sequence to use :)
22:09:36 <palomer> oh, nice
22:09:51 <palomer> very, very nice
22:11:04 <palomer> oh, crap, I have to mix that in with ST
22:11:19 <Cale> it's okay, it's a transformer
22:11:29 <palomer> so, erm, how do I do this?
22:12:14 <Cale> your monad is SupplyT String (ST s)
22:12:29 <Cale> you just have to apply runSupply before runST
22:12:40 <palomer> ahh, nice
22:12:43 <palomer> does this work all the time?
22:13:26 <Cale> oh, also, you'll have to apply lift to ST computations to get them into the larger monad
22:13:27 <Cale> yeah
22:15:00 <Cale> heh, okay, I think I've listened to "Representing the Mambo" 3 or 4 times now, time to load up a different album.
22:15:51 <palomer> http://www.rafb.net/paste/results/N3VjNi97.html <--how would I write this?
22:16:20 <Cale> lift $ readSTRef x
22:16:32 <Cale> that should be the only change
22:17:48 <palomer> @hoogle lift
22:17:48 <lambdabot> Text.ParserCombinators.ReadPrec.lift :: ReadP a -> ReadPrec a
22:17:48 <lambdabot> Control.Monad.Trans.lift :: (MonadTrans t, Monad m) => m a -> t m
22:17:48 <lambdabot> a
22:17:48 <lambdabot> Language.Haskell.TH.Syntax.Lift :: Lift t
22:18:07 <Cale> @type Control.Monad.Trans.lift
22:18:07 <lambdabot> forall (t :: (* -> *) -> * -> *) a (m :: * -> *).
22:18:07 <lambdabot> (Control.Monad.Trans.MonadTrans t, Monad m) =>
22:18:07 <lambdabot> m a -> t m a
22:18:25 <Cale> ah, incredible verbosity :)
22:18:50 <Cale> basically, it's taking the action in the inner monad, and lifting it into the transformed one
22:22:33 <palomer> http://www.rafb.net/paste/results/Xj89Ma83.html <--hrmph, I'm really really puzzled
22:23:41 <Cale> stt isn't getting applied to enough parameters there
22:23:44 <Cale> in the recursive call
22:24:35 <Cale> actually, I can't understand how that could possibly make sense -- do you have two things called stt?
22:25:34 <Cale> [replicate k ['a'..'z'] | k <- [1..]] >>= sequence
22:25:37 <Cale> hehe
22:25:57 <Cale> there was some historical verbosity in the other variant :)
22:26:15 <Cale> > [replicate k ['a'..'z'] | k <- [1..]] >>= sequence
22:26:16 <lambdabot> ["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","
22:26:16 <lambdabot> s","t","u","v","w","x","y","z","aa","ab","ac","ad","ae","af","ag","ah","
22:26:16 <lambdabot> ai","aj","ak","al","am","an","ao","ap","aq","ar","as","at","au","av","aw",
22:26:16 <lambdabot> "ax","ay","az","ba","bb","bc","bd","be","bf","bg","bh","bi","bj","bk","bl"
22:26:16 <lambdabot> ,"bm","bn","bo","bp","bq","br","bs","bt","bu","bv","bw","bx","by","bz","
22:26:18 <lambdabot> [24 @more lines]
22:27:47 <Cale> I don't understand what people mean when they say that Haskell doesn't provide enough list functions ;)
22:29:04 <palomer> @hoogle runST
22:29:04 <lambdabot> Control.Monad.ST.Lazy.runST :: ST s a -> a
22:29:04 <lambdabot> Control.Monad.ST.runST :: ST s a -> a
22:29:04 <lambdabot> Data.Array.ST.runSTArray :: Ix i => ST s (STArray s i e) -> Array i
22:29:04 <lambdabot> e
22:29:16 <Cale> wow, that's inaccurate
22:29:32 <Cale> runST :: (forall s. ST s a) -> a
22:29:40 <lispy> Cale: could you get the same result using inits instead of repeat?
22:29:55 <Cale> inits . repeat
22:30:26 <lispy> > (inits . repeat) ['a'..'z'] >>= sequence
22:30:27 <Cale> > (inits . repeat) ['a'..'z'] >>= sequence
22:30:27 <lambdabot> ["","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","
22:30:27 <lambdabot> r","s","t","u","v","w","x","y","z","aa","ab","ac","ad","ae","af","ag","ah"
22:30:27 <lambdabot> ,"ai","aj","ak","al","am","an","ao","ap","aq","ar","as","at","au","av","
22:30:27 <lambdabot> aw","ax","ay","az","ba","bb","bc","bd","be","bf","bg","bh","bi","bj","bk",
22:30:27 <lambdabot> "bl","bm","bn","bo","bp","bq","br","bs","bt","bu","bv","bw","bx","by","bz"
22:30:29 <lambdabot> [23 @more lines]
22:30:31 <lambdabot> ["","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","
22:30:33 <lambdabot> r","s","t","u","v","w","x","y","z","aa","ab","ac","ad","ae","af","ag","ah"
22:30:33 <lispy> oops
22:30:35 <lambdabot> ,"ai","aj","ak","al","am","an","ao","ap","aq","ar","as","at","au","av","
22:30:36 <Cale> > tail $ (inits . repeat) ['a'..'z'] >>= sequence
22:30:37 <lambdabot> aw","ax","ay","az","ba","bb","bc","bd","be","bf","bg","bh","bi","bj","bk",
22:30:39 <lambdabot> "bl","bm","bn","bo","bp","bq","br","bs","bt","bu","bv","bw","bx","by","bz"
22:30:41 <lambdabot> [23 @more lines]
22:30:43 <lambdabot> ["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","
22:30:45 <lambdabot> s","t","u","v","w","x","y","z","aa","ab","ac","ad","ae","af","ag","ah","
22:30:47 <lambdabot> ai","aj","ak","al","am","an","ao","ap","aq","ar","as","at","au","av","aw",
22:30:49 <lambdabot> "ax","ay","az","ba","bb","bc","bd","be","bf","bg","bh","bi","bj","bk","bl"
22:30:50 <Cale> hehe
22:30:51 <lambdabot> ,"bm","bn","bo","bp","bq","br","bs","bt","bu","bv","bw","bx","by","bz","
22:30:53 <lambdabot> [24 @more lines]
22:30:59 <Cale> too much :)
22:31:00 <lispy> oh man....
22:31:14 <palomer> http://www.rafb.net/paste/results/3SBrL171.html <--another puzzlement
22:31:21 <lispy> so i just read the paper on quickcheck, and it's just begging for follow up work on code coverage tools
22:31:32 <Cale> palomer: letters = ['a'..'z'] btw
22:31:52 <Cale> oh
22:31:58 <Cale> runSupplyT
22:32:16 <Cale> you're using the transformer variant
22:32:18 <palomer> @hoogle runST
22:32:19 <lambdabot> Control.Monad.ST.Lazy.runST :: ST s a -> a
22:32:19 <lambdabot> Control.Monad.ST.runST :: ST s a -> a
22:32:19 <lambdabot> Data.Array.ST.runSTArray :: Ix i => ST s (STArray s i e) -> Array i
22:32:19 <lambdabot> e
22:32:32 <Cale> @type Control.Monad.ST.runST
22:32:33 <lambdabot> forall a. (forall s. GHC.ST.ST s a) -> a
22:32:38 <Cale> that's the actual type
22:32:42 <Cale> ignore Hoogle :)
22:33:24 <palomer> http://www.rafb.net/paste/results/7QLkxB28.html
22:34:05 <lispy> i thought the same question about types was asked on haskell-cafe sometime this month
22:34:17 <lispy> iirc it had to do with exstential types
22:34:44 <cjs> HSoD is hurting my head.
22:35:08 <Cale> palomer: you're somehow managing to return a reference
22:35:21 <Cale> palomer: and the type system is catching you at it
22:35:42 <Korollary> hsod?
22:35:52 <Cale> what's the type of stt?
22:36:26 <palomer> I'm returning a reference? eh?
22:36:39 <Cale> what's stt's type?
22:36:59 <palomer> how do I find out?
22:37:13 <Cale> comment that line
22:37:18 <Cale> then ask ghci with
22:37:21 <Cale> :t stt
22:37:30 <palomer> how do I load the file with the imports?
22:37:43 <Cale> just ghci filename.hs
22:37:46 <Cale> it'll find the imports
22:37:51 <palomer> Could not find module `Type'
22:37:54 <Cale> oh
22:38:00 <Cale> then add it to the commandline
22:38:11 <Korollary> there's a ghc option to dump the types
22:38:50 <palomer> stt :: (MonadSupply [Char] (t (ST s)), MonadTrans t) =>
22:38:50 <palomer>        SType s
22:38:50 <palomer>        -> [(STRef s (), String)]
22:38:50 <palomer>        -> t (ST s) ([(STRef s (), String)], Type)
22:39:17 <Cale> t (ST s) ([(STRef ***s*** (), String)], Type)
22:39:32 <Cale> you're returning a list of STRefs
22:39:34 <palomer> this is chinese to me!
22:39:41 <Cale> hehe
22:39:49 <Cale> yeah, it's a bit complicated
22:39:52 * shapr yawns
22:40:06 <palomer> http://www.rafb.net/paste/results/hIEIYZ23.html <--check out the return
22:40:20 <palomer> oh yes, I am returning that
22:40:21 <palomer> silly me
22:41:48 <palomer> but, like, I don't need that list at the end
22:42:46 <Cale> well, don't runST so soon then
22:43:24 <palomer> test2 :: (MonadSupply [Char] (SupplyT [Char] (ST s))) =>
22:43:25 <palomer>          SType s -> ST s (Type, [[Char]])
22:43:29 <palomer> this type seems ok, right?
22:43:34 <Cale> yep
22:43:51 <palomer> test3 z = runST (test2 z) gives me
22:44:14 <palomer> http://www.rafb.net/paste/results/fz168X11.html
22:44:39 <Cale> oh, hmm
22:45:18 <Cale> hmm, you couldn't possibly have an SType s
22:45:27 <Cale> so that function could never be applied
22:45:30 <Cale> oh
22:45:46 <Cale> test2 :: (MonadSupply [Char] (SupplyT [Char] (ST s))) => (forall s. SType s) -> ST s (Type, [[Char]])
22:45:59 * palomer is puzzled by the [[Char]]
22:46:18 <palomer> that should be an ST s Type
22:46:56 <palomer> http://www.rafb.net/paste/results/OjJbsz70.html
22:46:56 <Cale> you had something like return (sofar, Tyvar ("'" ++ v)) somewhere
22:47:04 <palomer> yeah
22:47:08 <palomer> check out that code
22:47:18 <palomer> notice I remove the first element of the pair (the sofar) in test
22:47:48 <Cale> one thing
22:48:01 <Cale> how are you possibly going to get an SType s?
22:48:08 <Cale> from outside your monad?
22:48:21 <palomer> I'm inclined to ignore the s
22:48:26 <palomer> not knowing what it does
22:48:48 <Cale> It ensures that those values must be created and destroyed within ST
22:49:05 <palomer> I have to destroy stuff?
22:49:08 <Cale> no :)
22:49:23 <Cale> I shouldn't say destroy, but they can't be returned
22:49:35 <palomer> oh, they aren't
22:49:37 <palomer> test makes sure of that
22:49:55 <Cale> right, however, you're trying to pass one into the computation with the parameter z
22:50:01 <cjs> Haskell School of Design.
22:50:04 <Cale> but you couldn't possibly have one
22:50:17 <palomer> oh, righto
22:50:20 <Cale> which I think is the essence of what it's complaining about
22:50:20 <palomer> i might change the z
22:50:39 <palomer> so how do I write this?
22:51:00 <Cale> well, what's the input to your algorithm? It can't involve STRefs right away
22:51:13 <Cale> you'll have to construct the STRef tagged structure in the ST monad
22:51:16 <lispy> is it just historical that ghc uses happy instead of parsec or is the reason deeper?
22:51:22 <palomer> yeah
22:51:34 <Cale> lispy: happy produces somewhat faster parsers, I think
22:51:35 <palomer> I guess I can't go further than test2
22:51:46 <palomer> I find happy more readable
22:52:06 <lispy> Cale: i'd believe that, but doesn't parsec give better errors?
22:52:18 <Cale> however, it requires the use of Alex, which is annoying because Alex chokes on any unicode characters
22:52:31 <lispy> oh, lame
22:52:59 <lispy> i'm looking at modifying ghc to produce different cost-centers automatically
22:53:05 <palomer> :o
22:53:14 <palomer> whew, lotsa programming for a day
22:53:18 <palomer> over 400 lines, and I haven't run it once yet
22:53:20 <palomer> tihs is going to be funny
22:53:25 <palomer> night guys
22:53:29 <lispy> "config.status: error: cannot find input file: mk/config.h.in"
22:53:30 <shapr> test driven development?
22:53:35 <lispy> any idea why i'm missing that file?
22:53:40 <Cale> heh, as long as it types correctly, it'll probably work :)
22:54:16 <lispy> shapr: good that you mention TDD, (besides teaching palomer about it) that's the reason i want ghc to produce different cost-centers, for measuring code coverage!
22:54:35 <Cale> lispy: hmm, odd -- rerun autoreconf?
22:54:43 <lispy> i'll try that
22:54:44 <Cale> actually
22:55:11 <Cale> that doesn't particularly look like a generated file to me, but hopefully I'm wrong :)
22:55:23 <Cale> I have no real idea how the autotools work
22:55:24 <lispy> Cale: it works this time (configure works)
22:55:28 <Cale> cool
22:56:08 <Cale> lispy: so it'll run and rerun the app with extra cost centres?
22:56:40 <lispy> Cale: i want a unique cost-center at each use of any definition
22:56:51 <Cale> It would be neat to automate the "profile, look at the percentages, add cost centres, reprofile" loop
22:56:55 <lispy> then you could measure definition-use adequacy of the test suite
22:57:30 <lispy> Cale: that would be nice, but i think different than what i'm after at the moment
22:58:15 <Cale> well, sounds like you'll be overkilling the problem by adding cost centres everywhere
22:58:49 <lispy> overkilling which problem?  finding out what has been evaluated?
22:59:15 <Cale> yeah -- normally you add a few more cost centres as you locate the worst of the time/memory use
22:59:35 <lispy> yeah, but i'm not profiling for memory/time use
22:59:39 <Cale> oh
22:59:48 <lispy> i want to find out what parts of the program have been exercised
22:59:54 <Cale> ah
23:00:28 <Cale> well, if you're adding ordinary cost centres, you'll end up with that effect anyway, no?
23:00:49 <lispy> auto-all only adds them to exported, top level functions right?
23:00:52 <shapr> lispy: How does cost centers benefit TDD?
23:01:12 <lispy> shapr: by testing the testsuite
23:01:13 <shapr> oh, code coverage
23:01:18 <Cale> lispy: yeah, I think so
23:01:43 <lispy> Cale: there is -caf-all which would cover all top-level definitions, but i want more
23:01:53 <lispy> maybe more isn't needed, hard to say
23:02:15 <Cale> well, even with -caf-all, you can't tell which guards have been exercised
23:02:18 <lispy> in fact, it could turn out that definition-use isn't the best, but it's a start :)
23:02:40 <lispy> yeah, i'd want to be able to coverage of the guards
23:02:42 <Cale> it would be cool to integrate the use of this thing with hIDE, so you could colour the source with usage counts
23:03:02 <lispy> yeah, visualizations are the icing on the cake :)
23:29:01 <shapr> JohnMeacham: the 'banana bracket' syntax is already used by -farrows
23:34:45 <shapr> What's the url to the new repo?
23:37:21 <shapr> JohnMeacham:  http://darcs.haskell.org/darcsweb/darcsweb.cgi?r=testsuite;a=headblob;f=/tests/ghc-regress/arrows/should_run/arrowrun004.hs
23:38:30 <nibro> dons: ping
23:38:45 <nibro> @seen dons
23:38:46 <lambdabot> dons is in #haskell-blah and #haskell. Last spoke 1 hour, 20 minutes and
23:38:46 <lambdabot> 30 seconds ago.
23:38:50 <dons> yo, didn't get to work on it today.
23:38:57 <dons> is it high priority?
23:39:05 <shapr> Man, I hate posting lines longer than 80 chars, but I don't know a safe way to split urls :-(
23:39:11 <nibro> somewhat
23:39:27 <shapr> I wish there were a standard "url ends here, look for next escape to restart url"
23:39:37 <nibro> we have an undergrad project running regarding hsp, and I want to give them something that works
23:39:37 <shapr> Then @google could give urls in a format that xchat and emacs would understand.
23:39:39 <Korollary> 80 chars per line is for suckers
23:39:42 <shapr> and not exceed 80 chars.
23:39:57 <dons> ok. let priority' = succ priority
23:40:06 <Cale> I think that text displays should be smart enough to break lines intelligently.
23:40:12 <dons> i'll look at it tomorrow then.
23:40:25 <nibro> did you look at the files I sent you?
23:40:36 <nibro> just want to know that I'm not doing something really stupid :-)
23:40:39 <dons> yep, only briefly though.
23:40:56 <dons> i didn't see anything wrong. i'm pretty sure that it's the package.conf --user issue
23:41:20 <nibro> but the tests I sent you go wrong regardless
23:41:33 <nibro> same problem when everything installed as root
23:41:37 <dons> oh, i missed that. hmm
23:41:46 <nibro> the testsuite stuff is --user surely
23:42:12 <jonkri> how do i ask the bot for documentation about random?
23:42:17 <jonkri> system.random even
23:42:40 <dons> nibro, dinner time. but i'll look at it first thing tomorrow.
23:42:56 <nibro> sure thing :-)
23:43:06 <Korollary> @doc system.random
23:43:07 <lambdabot> system.random not available
23:43:15 <nibro> I'll dig into it some more, compare with your testsuite files
23:43:20 <jonkri> ok, thanks
23:43:25 <dons> @docs System.Random
23:43:25 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Random.
23:43:25 <lambdabot> html
23:43:29 <jonkri> :-)
23:51:36 <shapr> hoi Itkovian 
23:53:05 <Itkovian> hi shapr
23:59:27 <shapr> How's code today?
