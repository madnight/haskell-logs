00:06:33 <integral> @hoogle fix
00:06:34 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
00:06:34 <lambdabot> Control.Monad.Fix :: module
00:06:34 <lambdabot> System.IO.fixIO :: (a -> IO a) -> IO a
00:14:08 <dons> well, we haven't quite cracked the 1M lines of text mark, 995,471 so far this year :)
00:14:53 <dons> ?users
00:14:53 <lambdabot> Maximum users seen in #haskell: 305, currently: 272 (89.2%), active: 27 (9.9%)
00:17:05 <chr1s> I saw your email, \o/ for the 305 users!
00:18:04 <dons> woo!
00:18:34 <Itkovian> The active percentage is a bit low, no?
00:18:49 <rahikkala> Nah, just normal participation inequality
00:18:49 <Itkovian> I'm on here most of the time, but I usually let the discussion slide by
00:18:55 <rahikkala> Besides, it's fun to idle on #haskell
00:20:03 <Korollary> It's new people via reddit I gather
00:22:57 <vegaiW> Hey. I've noticed that some debian package of hs-plugins includes a patch for ghc-6.6
00:23:08 <chr1s> so, is there a packaging system that allows me to do something like "install hxml", which will download, build and install hxml?
00:23:22 <vegaiW> Will this be included into hs-plugins soon, or should I just build my packages using that patch?
00:23:34 * integral had wondered why hs-plugins "didn't compile on 6.6" but debian had a pkg :-P
00:23:42 <Korollary> 3
00:24:38 <dons> we have to call up Paul Potts and get him to use HsColour on his blog
00:24:43 <dons> this grey on grey thing ain't no good
00:24:44 <vegaiW> integral: either that or the pkg was compiled against 6.4
00:24:46 <dons> http://praisecurseandrecurse.blogspot.com/2006/12/from-bits-to-cells-simple-cellular.html
00:24:49 <lambdabot> Title: Praise, Curse, and Recurse: From Bits to Cells: Simple Cellular Automata in Hask ..., http://tinyurl.com/y4zydv
00:25:16 <vegaiW> also, I don't seem to find that patch, only references to it. Anyone have it back there somewhere?
00:25:52 <integral> vegaiW: from http://packages.debian.org/unstable/libs/libghc6-plugins-dev, there's links to http://ftp.debian.org/debian/pool/main/h/hs-plugins/hs-plugins_0.9.10-3.4.diff.gz
00:25:53 <lambdabot> Title: Debian -- libghc6-plugins-dev
00:26:20 <vegaiW> integral: thank you.
00:27:03 <vegaiW> ah, that's why I didn't find it. They've renamed it weirdly
00:37:07 <malebria> > let fib 0 = 1; fib 1 = 1; fib n = fib (n - 1) + fib (n - 2)
00:37:07 <lambdabot>  Parse error
00:37:34 <malebria> > let fib 0 = 1; fib 1 = 1; fib n = fib (n - 1) + fib (n - 2) in fib 30
00:37:36 <lambdabot>  1346269
00:37:49 <malebria> > let fib 0 = 1; fib 1 = 1; fib n = fib (n - 1) + fib (n - 2) in fib 50
00:37:53 <lambdabot> Terminated
00:40:58 <malebria> > let fib 0 = 1; fib 1 = 1; fib n = fib (n - 1) + fib (n - 2) in fib 54
00:41:02 <lambdabot> Terminated
00:41:06 <malebria> > let fib 0 = 1; fib 1 = 1; fib n = fib (n - 1) + fib (n - 2) in fib 40
00:41:10 <lambdabot> Terminated
00:41:21 <Syzygy-> malebria: If you cannot calculate fib 50, what makes you think fib 54 will go better?
00:42:13 <aFlag> 5 and 4 are closer than 5 and 0
00:42:19 <aFlag> :P
00:42:41 <malebria> It was a typo.
00:42:48 <malebria> obviously.
00:42:58 <malebria> Or whatever this is spelled.
00:42:58 <aFlag> hum, i like my explanation better
00:43:18 <Lemmih> Classic example of Haskell being too slow. Let's rewrite it in C instead of rethinking the algorithm. (I'm not directing this at you, malebria, but at the "real world" crowd)
00:43:41 <malebria> Lemmih: actually this is what I'm doing.
00:43:46 <malebria> In a very bad C implementation.
00:44:04 <malebria> @paste
00:44:04 <lambdabot> http://paste.lisp.org/new/haskell
00:44:25 <lisppaste2> malebria pasted "C implementation" at http://paste.lisp.org/display/32897
00:44:30 <dons> Lemmih: hehe
00:44:33 <Syzygy-> > let fib = 1 : 1 : (zipWith (+) fib (drop 1 fib)) in fib !! 50
00:44:35 <lambdabot>  20365011074
00:44:37 <aFlag> you can rethink the algorithm in haskell and get something faster
00:44:41 <Syzygy-> > let fib = 1 : 1 : (zipWith (+) fib (drop 1 fib)) in fib !! 55
00:44:43 <lambdabot>  225851433717
00:44:45 <dons> Syzygy-: you're not supposed to do that!
00:44:51 <Syzygy-> dons: I'm not?
00:44:54 <dons> you're breaking the RULES of PHYSICS!
00:45:00 <Syzygy-> I am?
00:45:08 <dons> ok. maybe i'm overreacting
00:45:10 <malebria> Syzygy-: this isn't the most readable code.
00:45:12 <Syzygy-> You are?
00:45:26 <dons> ?wiki The_Fibonacci_sequence
00:45:27 <lambdabot> http://www.haskell.org/haskellwiki/The_Fibonacci_sequence
00:45:33 <Syzygy-> malebria: But it's not really MUCH less readable than your code.
00:45:33 <dons> malebria: ^^
00:45:34 <malebria> aFlag: I would like to write just like that.
00:45:51 <aFlag> > let fib = 1 : 1 : (zipWith (+) fib (drop 1 fib)) in fib !! 40
00:45:53 <lambdabot>  165580141
00:45:56 <Syzygy-> > let fib = 1 : 1 : (zipWith (+) fib (drop 1 fib)) in fib !! 100
00:45:57 <Lemmih> > let fib = 1 : 1 : zipWith (+) fib (tail fib) in fib !! 200
00:45:58 <lambdabot>  573147844013817084101
00:45:59 <lambdabot>  453973694165307953197296969697410619233826
00:46:07 <Syzygy-> > let fib = 1 : 1 : (zipWith (+) fib (drop 1 fib)) in fib !! 500
00:46:09 <lambdabot>  2255915161619363308725126950360720720460113249137581905886388664184746277386...
00:46:17 <Syzygy-> > let fib = 1 : 1 : (zipWith (+) fib (drop 1 fib)) in fib !! 1000
00:46:17 <malebria> Syzygy-: I'm not saying your code is unreadable, but it's uncomparebly less readable than mine.
00:46:18 <lambdabot>  7033036771142281582183525487718354977018126983635873274260490508715453711819...
00:46:18 <integral> It's perfectly readable code because it's mentioned so often in here that we all know what it does.
00:46:28 <monochrom> Please don't use "int" for fib(40)...
00:46:33 <aFlag> i think it's unreadable
00:46:42 <malebria> aFlag: =D
00:46:44 <dons> I prefer:   fib = 1 : 1 : zipWith (+) fib (tail fib)
00:46:46 <aFlag> > let fib = 1 : 1 : (zipWith (+) fib (drop 1 fib)) in fib !! 39
00:46:48 <lambdabot>  102334155
00:46:49 <Lemmih> malebria: Actually it's quite readable.
00:46:57 <monochrom> i think English is unreadable
00:47:04 <Syzygy-> dons: That is, however, a good point, and I willingly display my n00biness.
00:47:10 <monochrom> because i'm uneducated
00:47:32 <Syzygy-> > let fib = 1 : 1 : zipWith (+) fib (tail fib) in fib !! 5000
00:47:34 <lambdabot>  6276302800488957086035253108349684055478528702736457439025824448927937256811...
00:47:40 <malebria> Lemmih: I agree it's readable. But it can't compare with mine still.
00:47:51 <Syzygy-> dons: Is there a point where this stops working?
00:47:54 <Syzygy-> > let fib = 1 : 1 : zipWith (+) fib (tail fib) in fib !! 500000
00:48:00 <dons> > let fib = 1 : 1 : zipWith (+) fib (tail fib) in fib !! (10^6)
00:48:09 <lambdabot> Terminated
00:48:12 <monochrom> It has stopped working :)
00:48:16 <Syzygy-> Right.
00:48:16 <lambdabot> Terminated
00:48:19 <dons> > let fib = 1 : 1 : zipWith (+) fib (tail fib) in fib !! (10^5)
00:48:23 <malebria> It hasn't.
00:48:24 <lambdabot>  Terminated
00:48:32 <dons> > let fib = 1 : 1 : zipWith (+) fib (tail fib) in fib !! (5 * 10^4)
00:48:32 <malebria> lambdabot kills it because it's taking too long.
00:48:35 <lambdabot>  1743874137872778683038855433072699016394461156878238973263982336478604120893...
00:48:42 <monochrom> There is some non-strictness there.
00:48:45 <Syzygy-> But it stops at way beyond 5e1, at least.
00:48:47 <dons> > let fib = 1 : 1 : zipWith (+) fib (tail fib) in fib !! (7 * 10^4)
00:48:51 <lambdabot>  Terminated
00:48:56 <dons> > let fib = 1 : 1 : zipWith (+) fib (tail fib) in fib !! (6 * 10^4)
00:48:59 <monochrom> binary search?
00:48:59 <lambdabot>  Terminated
00:49:11 <dons> its a test of what can be computed in 3 seconds on an older P4, really :)
00:49:22 <Syzygy-> > let fib = 1 : 1 : zipWith (+) fib (tail fib) in fib !! (55*10^3)
00:49:25 <lambdabot>  Terminated
00:49:27 <Syzygy-> Hehe
00:49:45 <Syzygy-> > let fib = 1 : 1 : zipWith (+) fib (tail fib) in fib !! (53*10^3)
00:49:48 <lambdabot>  1601164257834481770445846182914858567375577123007662806755432966550551640398...
00:49:51 <Lemmih> malebria: Right, yours is textbook. But that 'fib' is 'fib + tail fib' is still amazingly clear.
00:49:58 <dons> ?pl \xs -> return (mv:xs)
00:49:59 <lambdabot> return . (mv :)
00:50:02 <malebria> Lemmih: sure.
00:50:38 <malebria> But why ghc gets so slow?
00:50:52 <malebria> Even slower than that recursion C?
00:50:58 <Lemmih> malebria: Because Haskell is slow and you need to write it in C.
00:51:09 <vegaiW> easy way to become very famous
00:51:31 <vegaiW> implement a general compiler that transforms that earlier, inefficient version to the zipWith version
00:51:37 <vegaiW> (for some values of 'easy')
00:51:55 <monochrom> I'm working on it.
00:52:19 <vegaiW> It's a bit scary, in fact
00:52:32 <aFlag> malebria: why would recursion in C be slower than on haskell in that case?
00:52:54 <monochrom> who will need programmers after such a thing is invented?
00:53:15 <vegaiW> yes, exactly
00:53:29 <vegaiW> or indeed humans!
00:53:42 <norpan> I'll take an O(nÂ²) algorithm over an O(n) any day!
00:53:47 <monochrom> still need humans to write specifications.
00:53:48 <norpan> i need heat in my house
00:53:53 <dons> hehe
00:53:55 <malebria> aFlag: I thought haskell implementation of recursion was optimized.
00:54:07 <monochrom> but only smart humans are needed to write specifications
00:54:19 <dons> malebria, tail recursion is optimised :)
00:54:20 <vegaiW> malebria: only tail-recursion, which that fib didn't have
00:54:25 <dons> non-tail recursion solutions still use the stack
00:54:40 <aFlag> gcc also does tail recursion optimization anyways
00:55:00 <malebria> hum...
00:55:01 <dons> yeah, so the non tail recursive version in C will have the same complexity, but conk out when ints overflow :)
00:55:26 <aFlag> unless you use gmp :P
00:55:29 <vegaiW> was it so that the language Factor manages that version rather nicely?
00:55:53 <vegaiW> I might be remembering a dream now...
00:56:25 <vegaiW> anyone know any language in which  fib n = fib (n-1) + (n-2) would be efficient?
00:56:46 <monochrom> the language of mathematics
00:57:37 <dons> vegaiW: ghc + rewrite rules? :)
00:57:59 <malebria> And shouldn't lazyness improve haskell performance.
00:58:00 <malebria> ?
00:58:19 <vegaiW> not always. It's not magic
00:58:21 <malebria> Doesn't  C calculate the same fib (x) a lot of times?
00:58:26 <monochrom> Laziness doesn't save work if you ask the work to be done anyway.
00:58:32 <vegaiW> malebria: yes, and Haskell does the same
00:58:54 <dons> {-# RULES
00:58:54 <dons> "fib/fib" forall n .
00:58:54 <dons>     fib (n-1) + fib (n-2) = <efficient version>
00:58:54 <dons> #-}
00:58:57 <malebria> vegaiW: I thought it would calculate fib 39 in fib 40 just once.
00:59:02 <vegaiW> dons: ah :)
00:59:04 <notsmack> couldn't haskell, in theory, memoize it?  is that the right word?
00:59:26 <malebria> In fact fib 39, I meant fib 38.
00:59:30 <dons> notsmack: if you could teach the compiler that it was ok to transform the bad fib to a memoising/zipWith one
00:59:35 <dons> i.e. with a library-based rewrite rule
00:59:37 <Syzygy-> Isn't memoization just what the zipWith does?
00:59:43 <dons> yeah
00:59:51 <malebria> hum...
00:59:59 <malebria> this is why it's faster then...
01:00:03 <vegaiW> you could tell it to memoize *everything*, that'd be simple enough :)
01:00:06 <monochrom> ghc is slower in this case because data and code are boxed.  C is faster in this case because nothing is boxed.
01:00:07 <malebria> But why does haskell calculate it two times?
01:00:13 <malebria> I still don't get it.
01:00:38 <dons> you're not sharing the results
01:00:54 <malebria> fib 3 = fib 2 + fib 1
01:00:55 <notsmack> malebria: nor do i.  i thought one big point of the IO tidyness was that you could cache results like crazy
01:00:56 <dons> so writing a version that actually generates the intermediate list, i.e. zipWith, bang you're sharing.
01:01:14 <malebria> notsmack: that's what I thought.
01:01:19 <malebria> fib 4 = fib 3 + fib 2
01:01:49 <malebria> fib 4 = (fib 2 + fib 1) + fib 2
01:02:02 <malebria> Why don't it get the same fib 2 result for both?
01:02:17 <monochrom> because it doesn't know at compile time
01:02:41 <aFlag> it's a compiler, it's not david blane
01:03:01 <malebria> But then what's lazyness about?
01:03:18 <Itkovian> malebria: it's about not evaluating something that will not be needed
01:03:19 <vegaiW> well, lazyness allows doing the zipWith implementation
01:03:20 <notsmack> malebria: lazyness just means it only evaluates arguments to functions if it actually needs them
01:03:26 <monochrom> laziness is about const 1 (0/0) = 1.
01:03:43 <malebria> hum...
01:03:53 <malebria> I thought it would cache results also.
01:04:02 <dobblego> ?hoogle Int -> [a] -> Maybe [a]
01:04:03 <lambdabot> No matches, try a more general search
01:04:23 <vegaiW> supposedly it could. If you had infinite memory, you could just cache every result of every function you called
01:04:24 <malebria> Would that be hard to implement?
01:04:37 <vegaiW> or then come up with a more elaborate thing that works better in practice
01:04:42 <Lemmih> malebria: It wouldn't be practical.
01:04:42 <monochrom> If you write "let x = fib 40 in x+x" x is cached for just that small duration to complete x+x.
01:05:24 <Itkovian> malebria: if you write let y = fib 100 in let x = fib 2 in x + x, the y will not be evaluated
01:05:28 <monochrom> 99% of the programs won't benefit from it.
01:05:38 <Itkovian> neither will the x if you don;t really use it later on
01:06:16 <malebria> > let fib 0 = 1; fib 1 = 1; fib n = fib (n - 1) + fib (n - 2) in fib 30
01:06:18 <lambdabot>  1346269
01:06:24 <malebria> > let fib 0 = 1; fib 1 = 1; fib n = fib (n - 1) + fib (n - 2) in fib 30 + fib 30
01:06:26 <lambdabot>  2692538
01:06:38 <malebria> > let fib 0 = 1; fib 1 = 1; fib n = fib (n - 1) + fib (n - 2) in fib 30 + fib 30 + fib 30
01:06:40 <lambdabot>  4038807
01:06:54 <malebria> here it takes a very long time to calculate fib 30 + fib 30
01:09:02 <vegaiW> might be that the interpreter is too dumb to even share that
01:09:41 <malebria> vegaiW: yes, I guess...
01:09:59 <malebria> I always thought this was true in haskell.. =(
01:10:46 <therp> it seems that common subexpression eleminitation is not always easy.. http://hackage.haskell.org/trac/ghc/ticket/947
01:10:48 <lambdabot> Title: #947 (ghc -O space leak: CSE between different CAFs) - GHC - Trac
01:11:22 <therp> s/../elemination/
01:11:34 <vegaiW> malebria: yeah, with ghc -O, fib 30 and fib 30+fib 30+...+fib 30 takes about the same time as just one fib 30
01:11:45 <vegaiW> s/as just one fib 30//
01:11:51 <malebria> hum..
01:11:55 <vegaiW> not without -O, though.
01:17:12 <malebria> O2 produces slower code than O
01:17:35 <Lemmih> malebria: Try -O2 -fasm
01:17:45 <vegaiW> what kind of a crazy box is lambdabot on?
01:17:52 <dons> crazy box?
01:18:05 <malebria> Lemmih: -O is still better.
01:18:25 <vegaiW> dons: 16-proc? :P
01:18:36 <malebria> -O is better than -O -fasm
01:18:36 <Lemmih> malebria: Oh well, that happens.
01:19:05 <aFlag> here they are the same
01:19:18 <Lemmih> malebria: -O is that as as -O -fasm, are you sure it's not within the margin of error?
01:19:49 <dons> vegaiW: nope :)
01:19:49 <dons> manzano$ dmesg | grep cpu0 | sed 1q
01:19:50 <dons> cpu0: Intel(R) Pentium(R) 4 CPU 2.53GHz ("GenuineIntel" 686-class) 2.55 GHz
01:19:50 <dons> manzano$ uptime
01:19:50 <dons>  8:18PM  up 119 days,  4:11, 1 user, load averages: 0.39, 0.16, 0.11
01:19:52 <dons> manzano$ uname -s
01:19:55 <dons> OpenBSD
01:20:11 <dons> /not/ the 16 core box (it hasn't arrived yet)
01:20:19 <dons> (held up in customs :/)
01:20:29 <dons> its military grade, or something...
01:20:34 <vegaiW> Wow.
01:20:35 <dons> (no, I joke ;)
01:20:37 <malebria> -O is the same of -O2 -fams
01:20:37 <malebria> I get very better results with just -O
01:20:45 <malebria> @paste
01:20:45 <lambdabot> http://paste.lisp.org/new/haskell
01:20:47 <dons> its in customs, for some weird tax they want to charge
01:20:47 <vegaiW> Ah :)
01:21:03 <monochrom> military tax? :)
01:21:04 <therp> what's military about  processing power?
01:21:25 <vegaiW> will this then be a dedicated lambdabot platform?
01:21:25 <integral> ask the NSA that :)
01:21:25 <dons> with 16 cores lambdabot becomes a threat to national security
01:21:31 <monochrom> could use supercomputers to design and control rockets
01:21:51 <monochrom> of course "super" just means "now".
01:22:20 <vegaiW> Are you doing all this so that people could evaluate the naive version of fib with parameter 10000000000000 and have a result in a second? :)
01:22:22 <dons> vegaiW: we'll see. i hope to run lambdabot on it at least sometimes
01:22:40 <dons> hehe
01:22:41 <vegaiW> Ok, perhaps that won't happen before quantum computers
01:23:21 <lisppaste2> malebria pasted "times" at http://paste.lisp.org/display/32900
01:23:40 <aFlag> i bet lambdabot can calculate fibonacci really fast on those quantum computers
01:25:00 <Lemmih> malebria: There's an error margin of .073s. Nothing too conclusive can be said.
01:25:13 <vegaiW> hmm, the debian ghc-6.6/hsplugins patch is confusing.
01:25:28 <vegaiW> looks like I have to pull in some other debian patches as well
01:26:54 <notsmack> hsplugins works on 6.6 now?
01:28:18 <mauke> aww, I want generic infix operators
01:28:24 <mauke> liftM2 (liftM2 (++)) take (drop . succ) looks weird
01:29:03 <malebria> Lemmih: hum... why 0.73?
01:29:06 <monochrom> you can write it pointfully
01:29:48 <mauke> then I have to type variables twice :(
01:30:06 <Lemmih> malebria: One measurement says 0.215s, another says 0.288s.
01:30:10 <monochrom> but you don't have to lift twice hahaha
01:30:46 <mauke> @pl \i xs -> take i xs ++ drop (succ i) xs
01:30:47 <lambdabot> ap (ap . ((++) .) . take) (drop . succ)
01:31:07 <malebria> Lemmih: but anyway, every time I ran they stay in the same 208-216 for -O and 228-232 for -O -fasm
01:31:46 <malebria> Lemmih: I was looking user time, not real.
01:31:54 <vegaiW> notsmack: the unstable debian package seems to be patched to work against it
01:32:14 <vegaiW> or so I've read. I don't use Debian myself
01:32:30 <xpika> is there a function which takes two arguments and turns them into a tuple
01:33:12 <mauke> yes, (,)
01:33:18 <monochrom> Like (,) 4 True = (4,True)?
01:33:50 <mauke> @pl f a b = (a, b)
01:33:51 <lambdabot> f = (,)
01:34:05 <xpika> thanks awesome
01:35:43 <sieni> or even
01:35:48 <sieni> > curry id 4 True
01:35:50 <lambdabot>  (4,True)
01:35:51 <Lemmih> malebria: Hm, it looks like -fvia-c gets turned on with -O, not just -O2. That probably explains it.
01:36:55 <integral> @hoogle Rational -> Double
01:36:56 <lambdabot> No matches, try a more general search
01:37:13 <integral> is there really nothing to do this?
01:38:35 <Lemmih> > fromRational 10 :: Double
01:38:36 <lambdabot>  10.0
01:38:38 <Masklinn> 'morning everybody
01:38:44 <integral> oh, I see
01:38:54 <Itkovian> bulat is on a roll it seems
01:39:14 * integral is lost in a twisty maze of conversions all alike
01:40:42 * Lemmih doesn't like him saying that idiomatic Haskell < imperative haskell < C.
01:40:53 <Itkovian> Lemmih: he means speed
01:41:03 <Itkovian> execution speeds, that is
01:41:15 <Itkovian> the question is: does it really matter that much?
01:41:50 <Itkovian> as we move to much more complex applications, correctness is gaining more importance.
01:42:14 <Itkovian> If speed woudl really matter, people would not buy recent Office apps, but stick with what worked back in 1998
01:42:16 <Lemmih> Itkovian: I know. I still disagree.
01:42:33 <Itkovian> I dislike his IORef style in the examples he gave
01:42:43 <Itkovian> it seems that doing that adds complexity
01:42:50 <pejo> Itkovian, they might need features, or a supported version of their application.
01:42:57 <Itkovian> to read and understand it does
01:43:28 <Itkovian> pejo: machines have more than doubled performance. but still, the apps people commonly use have the same (subjective) interaction speed
01:43:40 <dons> its just a pity he's so noisy. it creates an impression there's a big problem, when afaik there isn't a problem
01:43:45 <Itkovian> this means that the speed is somehow ok for the user
01:44:06 <Itkovian> dons: well, he certainly invites discussion, that's good, no?
01:44:22 <dons> he replies to everything in the thread though, which is poor form
01:44:37 <Itkovian> it makes it hard to follow, that's true
01:44:55 <Itkovian> are you going to tell him? ;-)
01:45:09 <dons> its classic behaviour from the 'poison people' book: you can create the sense of a problem as being more severe than it is, by creating a lot of noise about it
01:45:17 <dons> but i'm not going to tell him that :}
01:45:49 <pejo> Itkovian, I'd say the lack of choice affects what customers choose. Lock-in, and such things.
01:45:49 <Itkovian> sounds like an interesting book?
01:45:58 <Itkovian> pejo true also
01:46:16 <pejo> (I do agree that speed isn't the single most important property of applications, but they have measured increased heart rate/blood pressure when people have to wait for "too long").
01:48:15 <Itkovian> pejo: I thought that it's more the fact that sometimes it goes fast them slow that makes people boil. If the delay was alwasy the same, it would be far more ok.
01:48:41 <kfish> pejo, and UI concurrency and responsiveness is often a different matter to calculation speed :-)
01:48:44 <dons> and everyone keeps writing ruby, python and php code nonetheless
01:49:29 <kfish> so has anyone looked into the problems with GPG? it sounds interesting
01:49:36 <dons> Itkovian: oh, that reference earlier is to be found in one of the articles here, http://haskell.org/haskellwiki/Protect_the_community
01:49:37 <lambdabot> Title: Protect the community - HaskellWiki
01:49:39 <pejo> Itkovian, hm. I can't say. But for communication (satelite phone, for example) with large delyas, it's quite hard to have a "normal" conversation.
01:49:40 <abz64__> I'm actually in the process of writting a site in haskell
01:49:53 <kfish> there's a lot of distributed keyring checking etc. involved in gpg ...
01:50:11 <pejo> kfish, yes. Batch jobs that aren't interactive are slightly different. Those that will take a week to crunch you can just get a cup of coffee and start working on something else with instead.
01:50:24 <dons> abz64__: how's that going?
01:50:42 <abz64__> a prototype is up a the moment
01:50:54 <dons> nice. can we see? :)
01:50:59 <abz64__> http://braintreehemp.com.au
01:51:08 <abz64__> that is version 1.5
01:51:32 <abz64__> I'm currently working 10 hours a day to try and get v2 up before christmas
01:51:37 <notsmack> abz64_: WASH i gather?
01:51:46 <abz64__> yeah, wash
01:51:57 <abz64__> and haskelldb
01:52:02 <dons> very nice
01:52:05 * notsmack is hacking together a blog in HAppS
01:52:28 <abz64__> right.
01:52:49 <dons> abz64__: you in Sydney? or that just a coincidence?
01:52:52 <abz64__> we are going to try and integrate Ajax into wash for the next site we are doing
01:53:19 <dons> mmm. that would be useful. you're aware of the other couple of ajax libs out there in haskell?
01:53:19 <abz64__> no, I'm not in Sydney, I'm in San Francisco
01:53:28 <kfish> abz64__, is there any technical reason the links are to javascript:WASHSubmit(...) instead of normal urls?
01:54:20 <abz64__> I am aware... but none do what we want... we are going to take a look at them all the same.
01:54:43 <abz64__> v2 (not out) uses normal URL's
01:54:46 <Itkovian> pejo: true, I wqas more referring to common destop apps for ordinary administrative work
01:54:58 <dons> abz64__: if you'd like to mention that you're using haskell commercially on our 'industry' wiki page, I think people would be interested. http://www.haskell.org/haskellwiki/Haskell_in_industry
01:54:58 <kfish> abz64__, ok cool, just wondering if WASH imposed that or something
01:54:59 <lambdabot> Title: Haskell in industry - HaskellWiki
01:55:04 <earthy> dons: have you seen my vimball with the nicer typegathering keymap?
01:55:10 <dons> abz64__: have you told Peter Thiemann you're using wash in the real world? :)
01:55:14 <dons> earthy: yes!
01:55:19 <dons> haven't tried it out yet though
01:55:43 * earthy has gleaned a few more ideas from Claus Reinke
01:55:46 <earthy> :)
01:55:48 <abz64__> I'm going to start credit card transactions later this week... that should be fun
01:55:50 <Itkovian> dons: thx
01:56:05 <mauke> is that like credit card transformations?
01:56:19 <abz64__> I haven't told him. I'd like to have if finished before I show everyone.
01:56:36 <dons> abz64__: ok. looks good though. nice work!
01:56:39 <abz64__> but any advice or comments are greatly appreciated.
01:57:05 <xpika> @hoogle empty
01:57:05 <lambdabot> Data.IntMap.empty :: IntMap a
01:57:06 <lambdabot> Data.IntSet.empty :: IntSet
01:57:06 <lambdabot> Data.Map.empty :: Map k a
01:57:20 <xpika> @hoogle Empty
01:57:20 <lambdabot> Data.Graph.Inductive.Internal.FiniteMap.Empty :: FiniteMap a b
01:57:20 <abz64__> credit card transactions as in buy online
01:57:20 <lambdabot> Data.Graph.Inductive.Internal.Heap.Empty :: Heap a b
01:57:20 <lambdabot> Data.IntMap.empty :: IntMap a
01:57:33 <mauke> xpika: what are you looking for?
01:58:03 <abz64__> the is a full CMS behind the Administration line
01:58:04 <abz64__> link
01:58:08 <earthy> abz64__: even telling him 'I'm working with WASH on such-and-so realworld project' is powerful
01:58:16 <dons> abz64__: hey, btw, i live about 5 mins from the braintreehemp shop in sydney :)
01:58:32 <abz64__> lol, good work.
01:58:54 <earthy> if only to give some munition to persuade people that it can be used in the real world
01:59:12 <abz64__> I sent him and email a while a go, and got no reply. So I guess he's just busy...
01:59:25 <abz64__> so I haven't bothered since
01:59:32 <notsmack> abz64__: so what are your impressions of wash?
01:59:32 <Lemmih> @karma+ abz64__ -- Using Haskell in the real world.
01:59:33 <lambdabot> abz64__'s karma raised to 1.
01:59:34 <earthy> probably true. doesn't mean the mails won't be appreciated. ;)
01:59:40 <dons> dropping by on the haskell-cafe@ would be useful too
01:59:56 <abz64__> no, please don't
02:00:06 <abz64__> version 2 will be out soon.
02:00:18 <abz64__> and we haven't got our server setup correctly yet.
02:00:26 <dons> yeah, be sure to announce to the community when its ready :)
02:00:42 <abz64__> yeah, I will
02:01:09 <abz64__> we are actuall doing a startup for Haskell websites. But at the moment we are just prototyping.
02:01:26 <abz64__> and we need to improve wash a bit.
02:02:40 <abz64__>  impressions of wash: good, but could use some work on the journals
02:02:48 <dons> that's understandable
02:02:59 <dons> did you look into HAppS too? any comments on its use?
02:03:59 <chessguy> 'morning haskellers
02:04:02 <abz64__> I looked into HAppS a bit. And we are going to do a serious evluation next year of all the technology at hand wrt to haskell and websites.
02:04:09 <abz64__> this is just a prototype.
02:04:29 <abz64__> But I haven't used it.
02:05:03 <dons> the authors hang out here, if you ever need to talk to them, shapr and alexj
02:05:23 * dons notes there's no (<<)
02:05:26 <abz64__> Ok, I'll write that down.
02:06:41 <abz64__> I'd like to a cut into wash similar to the cut in logic programming.
02:06:52 <abz64__> for the journals
02:11:14 <notsmack> journals?
02:11:17 <chessguy> 'morning dons. i created a new wiki page last night, for a project i've been kicking around for a long time
02:11:32 <chessguy> @wiki Evolutionary_Chess
02:11:33 <lambdabot> http://www.haskell.org/haskellwiki/Evolutionary_Chess
02:13:05 <abz64__> journals: if you go around the aforementioned site, and continue to look at the source for each page, at the bottom there is a bit long journal that builds up. I'd like to be able to cut that we I want to
02:13:54 <opqdonut> chessguy: i just made a paper on applying genetic algorithms in combat modelling
02:14:04 <opqdonut> chessguy: sadly it's in finnish
02:14:17 <chessguy> what kind of combat?
02:14:22 <opqdonut> chessguy: infantry
02:14:28 <opqdonut> very simple probabilistic model
02:14:50 <opqdonut> but anyways, i used a event-reaction based AI which was then breeded genetically
02:14:58 <chessguy> interesting. was it purely a genetic algorithm or genetic programming?
02:15:25 <opqdonut> the genetic algorithm evolved an optimal tactic based on the model
02:15:27 <opqdonut> so both, i guess
02:15:49 <chessguy> what language were you working in?
02:15:59 <opqdonut> haskell :)
02:16:20 <opqdonut> i can give you the source if you want it
02:16:23 <chessguy> oh cool. did you use an existing genetic library or what?
02:16:31 <opqdonut> no, coded my own simplistic one
02:16:42 <opqdonut> 267 lines
02:16:43 <chessguy> i'd love to see that
02:16:53 <opqdonut> ok, just a sec
02:17:35 <opqdonut> http://opqdonut.users.paivola.fi/gene.hs
02:17:38 <opqdonut> there ya go
02:18:16 <opqdonut> msg me with any questions or comments
02:18:58 <chessguy> great! thanks a lot! opqdonut++
02:19:09 <opqdonut> np, nice to get feedback :))
02:19:39 <edi> randomTactics n = liftM3 ( ((:).).(,) ) randomIO randomIO (randomTactics (n-1)) -- haha
02:19:53 <opqdonut> :)
02:20:43 <opqdonut> sorry for the trippy oneliners, but the function signatures and comments should be enough for understanding the code
02:20:44 <mauke> hahargh
02:22:12 <edi> You passed every definition exceeding two lines through @pl ?
02:23:04 <Pete_I> cool, but very bad idea....
02:23:13 <mauke> randomTactics = liftM3 ( ((:).).(,) ) randomIO randomIO . randomTactics . pred n
02:23:56 <chessguy> @unpl randomTactics n = liftM3 ( ((:).).(,) ) randomIO randomIO (randomTactics (n-1))
02:23:57 <lambdabot> randomTactics n = liftM3 (\ d g -> ((:)) (((,)) d g)) randomIO randomIO (randomTactics (n - 1))
02:24:15 <opqdonut> actually just that one def looked so horrible i decided to pf it
02:24:32 <opqdonut> but this was my first larger haskell program so the code might not be very beautiful
02:24:35 <mauke> someone needs to teach unpl about operator sections
02:24:46 <opqdonut> mauke: yep
02:25:52 <chessguy> so you had separate attackers and defenders on each team?
02:26:35 <opqdonut> chessguy: i had an attacking team and a defending team
02:26:58 <opqdonut> and each team has it's men divided between ones advancing, shooting and taking cover
02:27:03 <opqdonut> (and evacing and wounded)
02:27:16 <opqdonut> the model itself was not my own, i just reimplemented it
02:27:28 <opqdonut> a shame really i didn't write the paper in english
02:27:46 <chessguy> i don't suppose there's english information out there about the model
02:28:05 <opqdonut> chessguy: i'll have a look later today
02:28:10 <opqdonut> but gtg now -->
02:28:13 <chessguy> ok. thanks again
02:28:19 <opqdonut> np again :)
02:35:04 <monochrom> 007 titles for haskellers.  fromForeignPtr withCString.  You Only lift Twice.  Bottoms Are Forever.  The Monad with the Pure Function.  For Your Types Only.  A view to A seq.  Licence to killThread.  iterate Never Dies.  unsafePerformIO Is Not Enough.
02:35:45 <bacek> casino royale ==
02:36:05 <lisppaste2> boegel pasted "child process" at http://paste.lisp.org/display/32904
02:36:11 <monochrom> @remember monochrom 007 titles for haskellers.  fromForeignPtr withCString.  You Only lift Twice.  Bottoms Are Forever.  The Monad with the Pure Function.  For Your Types Only.  A view to A seq.  Licence to killThread.  iterate Never Dies.  unsafePerformIO Is Not Enough.
02:36:31 <mwc> KingT StdGen IO ()
02:37:09 <monochrom> Oh hahaha
02:38:00 <monochrom> @remember mwc casino royale == KingT StdGen IO ()
02:38:16 <edi> :O
02:38:30 * edi is wordless
02:38:44 <mwc> I was trying to come up with a better inner monad, but IO is the most dangerous :)
02:42:09 <lisppaste2> Itkovian annotated #32904 with "normal usage" at http://paste.lisp.org/display/32904#1
02:42:20 <Itkovian> argh
02:43:21 <chessguy> heh. doesn't look like haskell :)
03:01:09 <dons> ?yow
03:01:10 <lambdabot> I have many CHARTS and DIAGRAMS..
03:01:22 <chessguy> :)
03:02:08 <chessguy> @tell opqdonut i made a couple of notes about your code on my wiki page. http://www.haskell.org/haskellwiki/Evolutionary_Chess
03:02:08 <lambdabot> Consider it noted.
03:03:28 <chessguy> @users
03:03:29 <lambdabot> Maximum users seen in #haskell: 305, currently: 281 (92.1%), active: 32 (11.4%)
03:26:09 <yaxu> excellent, my copy of hutton's "programming in haskell" has arrived
03:26:27 <yaxu> with a publish date of jan 18th :)
03:27:22 <yaxu> i really enjoyed the online sample chapters, can't wait to read the rest
03:27:53 <edi> Hiya yaxu (xerox here)
03:28:07 <yaxu> hello edi (xerox)
03:29:04 <Bourbaki> moin
03:29:12 <Bourbaki> whos the haskell sound man :)?
03:29:15 <edi> You were looking for yaxu
03:29:25 <Bourbaki> hidiho yaxu
03:30:09 <yaxu> hi Bourbaki
03:30:35 <Bourbaki> would you mind to have a quick look at this paper and tell me if you think its doable with haskell?
03:30:46 <Bourbaki> maybe also you can help me on the iffy filters
03:30:46 <yaxu> i'm making sound with c and supercollider, and music with haskell
03:30:49 <yaxu> :)
03:30:54 <Bourbaki> http://www.csis.ul.ie/dafx01/proceedings/papers/kahrs.pdf
03:31:12 <Bourbaki> you dont happen to know if there is a sound simulation for haskell do you?
03:31:23 <Bourbaki> wave equation that is
03:31:56 <dons> ?where+ urlcheck darcs get http://www.cse.unsw.edu.au/~dons/code/urlcheck
03:31:56 <lambdabot> Done.
03:31:57 <dons> :)
03:32:06 <yaxu> not that I know of, to tell the truth I'm still a beginner haskell programmer
03:32:12 <yaxu> it looks an interesting paper
03:32:13 <Bourbaki> hey dons did you forget something :)?
03:32:15 <dons> anyone who wants to try out my new parallel haskell url checker.. :)
03:32:21 <dons> Bourbaki: heya Bourbaki!
03:32:33 <Bourbaki> yaxu yes quite so
03:32:52 <edi> And it has got an Italian author :)
03:33:04 <Bourbaki> :)
03:33:56 <yaxu> Bourbaki: i'm not too hot on synthesis yet, i mainly just trigger samples at the moment
03:34:08 <yaxu> Bourbaki: i'm sure it is possible with haskell though
03:34:27 <Bourbaki> i had a lot of problems with these filters
03:34:36 <Bourbaki> eg 3-way filter
03:34:50 <Bourbaki> i guess i need to write them a mail
03:35:09 <Bourbaki> he doesnt seem to continue this course so he might be willing to help a little
03:35:32 <kfish> dons: nice :-) parallel :-)
03:35:54 <Bourbaki> dons did you have a look at the stuff on the wiki yet?
03:37:47 <dons> kfish: yeah. if you want to try it out/ poke around in the code a bit, i'd appreciate any feedback (I don't write a lot of network apps)
03:37:47 <xpika> Check.hs:198:8: The last statement in a 'do' construct must be an expression
03:37:48 <xpika> :(
03:37:58 <dons> xpika: hmm. darcs pull again
03:38:06 <xpika> is there any flags i need?
03:38:14 <dons> xpika: you using cabal to build?
03:38:18 <xpika> i just downloaded the text file
03:38:51 <xpika> ghc-6.4.2 -o link Check.hs
03:40:42 <dons> xpika: try:  ghc --make -O -fasm -fglasgow-exts -threaded Check.hs
03:40:46 <dons> (you need both .hs files)
03:41:38 <dons> (just pushed a patch, you'll want the latest version)
03:42:34 <dons> Bourbaki: I did, a while ago.
03:42:53 <Bourbaki> dons did you still like the idea?
03:43:01 <dons> I can't remember :)
03:43:05 <Bourbaki> hehe
03:43:57 <dons> kfish: yeah, I reckon I should just write everything parallel these days
03:45:53 <dons> ?users
03:45:54 <lambdabot> Maximum users seen in #haskell: 305, currently: 290 (95.1%), active: 32 (11.0%)
03:47:52 <mauke> @pl \(_,x,_)->x
03:47:52 <lambdabot> (line 1, column 6):
03:47:52 <lambdabot> unexpected ","
03:47:52 <lambdabot> expecting letter or digit, operator or ")"
03:47:52 <lambdabot> ambiguous use of a non associative operator
04:02:09 <Syzygy-> @pl (a,b,c)->b
04:02:10 <lambdabot> (line 1, column 8):
04:02:10 <lambdabot> unexpected ">" or "-"
04:02:10 <lambdabot> expecting variable, "(", operator or end of input
04:02:18 <Syzygy-> @pl \(a,b,c)->b
04:02:18 <lambdabot> (line 1, column 6):
04:02:19 <lambdabot> unexpected ","
04:02:19 <lambdabot> expecting letter or digit, operator or ")"
04:02:19 <lambdabot> ambiguous use of a non associative operator
04:02:24 <mauke> ENOTUPLES
04:11:51 <kfish> dons: nice work
04:12:14 <kfish> i assume messages (in Main) is geared towards pretty printing status messages or something? (currently unused)
04:12:34 <dons> yeah
04:12:38 <dons> rather than 404
04:12:45 <dons> also, i need to add a progress bar thread
04:12:54 <kfish> it could be useful to give separate reports for urls which return error 5xx, as opposed to those which simply 404
04:13:07 <kfish> and those for which the host doesn't exist / respond
04:13:13 <dons> ah yes.
04:13:20 <lisppaste2> fabiim pasted "IO against []  ( createCharacter) " at http://paste.lisp.org/display/32913
04:13:32 <kfish> ie. as a tool for checking known urls in your own website, to see what is broken
04:13:45 <dons> yep
04:14:08 <kfish> it could also be useful to report permanent redirects, as that is a hint that the referring web page should be rewritten with the new url
04:14:16 <fabiim> can someone please give a look at that please, it should be something simple that i'm missing .
04:14:29 <dons> i think after today its actually usable enough (and lighter weight) than the linkchecker.py i currently use for the hwn, so i'll polish it up as you say
04:14:57 <kfish> dons: and it might be useful to check robots.txt to see if you're allowed to go scanning urls, as technically this might be a bot (if it's run from a cronjob)
04:15:04 <kfish> s/useful/polite/
04:15:45 <ski_> fabiim : several things ..
04:15:54 <ski_> agente :: [Int]
04:15:56 <fabiim> loll
04:16:11 <ski_> but 'repoeInformacao' wants '[Agente]'
04:16:16 <kfish> dons: which gives you another fun file to parse -- see http;//robotstxt.org
04:16:37 <ski_> hm
04:16:52 <fabiim> ski_:  repoeInformacao wants [Int]
04:16:54 <ski_> fabiim : sorry, i'm reading badly
04:17:00 <ski_> yes, apology
04:17:02 <dons> kfish: :)
04:17:03 <ski_> anyway
04:17:05 <fabiim> oh ok
04:17:54 <fabiim> so agente :: [Int] , right?
04:18:01 <lisppaste2> ski annotated #32913 with "better indentation" at http://paste.lisp.org/display/32913#1
04:18:07 <kfish> dons: that's all from me for now, let me know if the patches i sent worked, as i don't have 6.6 here so couldn't actually compile it ;-)
04:18:46 <fabiim> ski_: where did the in go?
04:18:50 <ski_> fabiim : the 'let' command needs to be indented exactly the same as the other commands in the 'do'-block .. also the 'in' is superfluous in 'do'
04:19:02 <fabiim> oh ok
04:19:06 <fabiim> thanks =)
04:19:42 <ski_> additionally, 'repoeInformacao' returns an 'Agente', but you need an 'IO'-action there (since you use 'rollDice' which is in the 'IO'-monad), and hence the 'return'
04:20:23 <dons> kfish: ah yes. the 6.6-isms could probably go too
04:20:26 <ski_> (fabiim ; also, the ';' after 'rollDice 400 500' is superfluous, when indenting properly .. i missed removing it)
04:20:48 <kfish> dons: ok, want me to make it build on 6.4.1?
04:20:59 <kfish> dons: i'm looking for ways to procrastinate from studying for a kanji test
04:21:14 <fabiim> ski_:  but i the last statement of do  is return repoeInformacao .
04:21:52 <ski_> fabiim : sorry ?
04:23:12 <fabiim> i tough that only the last line in a do could be write without  the ';'
04:23:21 <kfish> ?hoogle forM_
04:23:22 <lambdabot> No matches found
04:24:01 <dons> kfish: yeah, forM_ = flip mapM_
04:24:08 <dons> so just flip the args and use mapM_ :)
04:24:15 <xpika> Could not find module `Data.ByteString.Lazy.Char8':
04:24:44 <ski_> (fabiim : no, every line ..)
04:24:46 <kfish> dons: cheers
04:25:47 <kfish> dons: hmm, the second arg is 4 lines long :-) what's a nice way to lay that out?
04:25:48 <mauke> @pl \f x -> (f x, x)
04:25:49 <lambdabot> ((,) =<<)
04:26:01 <mauke> @pl \f x -> (x, f x)
04:26:02 <lambdabot> ap (,)
04:26:32 <ski_> forM_ xs $ \x -> do
04:26:34 <ski_>   ...
04:26:42 <dons> flip mapM_ () $ do ...
04:26:53 <dons> (`mapM_` a) $ do ..
04:27:17 <dons> xpika: if you're using ghc 6.4.2., you'll need the fps library
04:27:19 <dons> ?where fps
04:27:19 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
04:27:36 <dons> xpika, thank for persisting, but currently its untested on ghc 6.4.2 :) and only a few hours old anyway ;)
04:28:22 <xpika> actually, i just went away to the supermarket
04:28:47 <fabiim> ski_: so if we ident correctly  the code , we could "skip" writing the ; and { } in do , right?
04:28:59 <ski_> right
04:29:00 <xpika> yup
04:29:45 <ski_> (and similarly with 'let','case','where','module')
04:29:55 <xpika> indent forward = "{", indent backward = "}" and newline = ";" if im correct
04:30:16 <gour_> dons: thank you very much for your 'programming haskell' serial. do you plan to continue? if yes, may i suggest to plan to put articles in sort of ebook (pdf). there are lot of jewels in haskell wiki, but, imho, they need some more structure and ability to make a book out of it would solve many of complaints from 'aim of haskell' thread
04:30:18 <ski_> indent same = ";"
04:31:23 <mauke> :t \f g -> join (liftM2 f) g
04:31:25 <lambdabot> forall (m :: * -> *) a1 r. (Monad m) => (a1 -> a1 -> r) -> m a1 -> m r
04:31:58 <ski_> :i Maybe
04:32:09 <ski_> .. bah!
04:32:43 <mauke> :t (\f g -> join (liftM2 f) g) compare fst
04:32:44 <lambdabot> forall a b. (Ord a) => (a, b) -> Ordering
04:33:36 <kfish> dons: done, sent, builds with 6.4.1
04:33:43 <kfish> and seems to work
04:35:07 <seba> kfish: studying kanji?
04:35:12 <chessguy> @bot
04:35:13 <lambdabot> :)
04:35:30 <kfish> seba, yeah
04:35:58 <seba> those bastard messed up my memory :)
04:36:32 <kfish> seba, yeah, 12 monkeys style, every day is like that here
04:37:39 <ventonegro> it seems that GHC itself is a library in version 6.6
04:37:42 <seba> kfish, do you use a particular method?
04:37:55 <ventonegro> will it make possible for code compilation on-the-fly?
04:38:06 <kfish> seba, yeah, writing out pages and pages of characters by hand seems to work pretty well
04:38:07 <chessguy> ventonegro, what makes you say that?
04:38:37 <ventonegro> chessguy, i asked once the Igloo guy why GHC 6.6 for debian was so much bigger
04:38:37 <kfish> seba, also the option of starving if i can't read the menu in restaurants is pretty good motivation
04:38:59 <ventonegro> he said that was because GHC itself was packaged as a library
04:39:03 <seba> kfsih, do you know Heisig's book?
04:39:16 <dons> kfish: no patches arriving yet
04:39:19 <kfish> seba, i don't have that, i have a copy of henshall's here
04:39:25 <dons> did i put the mail in the darcs repo?
04:39:35 <kfish> dons: crap, i had to install postfix, i might have screwed that up
04:39:36 <chessguy> hmmm. did he say what module it was in?
04:39:44 <kfish> dons: yeah, it had your email address in it
04:40:17 <ventonegro> chessguy, i didn't ask :-(
04:40:43 <kfish> can i create a patch bundle as a file and then mail that to you otherwise?
04:40:44 <chessguy> dons, do you know anything about this? library-level access to ghc itself in ghc 6.6?
04:40:45 <edi> ?version
04:40:45 <lambdabot> lambdabot 4p302, GHC 6.5 (OpenBSD i386)
04:40:46 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
04:42:40 <dons> chessguy: yeah, ghc-api
04:42:43 <dons> its in -package ghc
04:42:50 <dons> kfish: yeah
04:42:56 <dons> darcs send -o /tmp/patch.bunde
04:43:28 <ventonegro> dons, so, do you know if it will be possible to compile code on-the-fly?
04:43:53 <ventonegro> like extending an application with user functions
04:43:55 <dons> ventonegro: Lemmih has tried it
04:44:07 <dons> but its experimental, and hasn't be used in any applications yet that i know of
04:44:17 <dons> so you'd be breaking new ground. but its possible
04:44:19 <ventonegro> i see
04:44:26 <ventonegro> so at least is theoretically possible
04:44:30 <chessguy> what about just interpreting code?
04:44:36 <kfish> dons: actually, just pull from http://snapper.kfish.org/~conrad/software/urlcheck/
04:44:37 <lambdabot> Title: Index of /~conrad/software/urlcheck
04:44:59 <kfish> (and let me know when you have, i'll get rid of it so i don't confuse myself)
04:45:43 <dons> got it. cheers
04:45:52 <dons> peer to peer forever!
04:46:03 <ventonegro> chessguy, would be more portable extension-wise
04:46:14 <chessguy> ventonegro, hmm?
04:46:57 <mauke>  Equations for `spand' have different numbers of arguments  <- why is that an error?
04:47:11 <ventonegro> chessguy, if using user functions to extend a program, like a scripting language, interpreting would be more portable
04:47:28 <chessguy> ah
04:47:52 <chessguy> mauke, because every function has to have an exact type signature
04:48:06 <mauke> so?
04:48:13 <chessguy> you can't have foo :: Int -> Int   and also foo :: Int -> Int -> Int
04:48:30 <mauke> that's not what that error refers to
04:48:38 <ski_> mauke, because it needs to patternmatch on all the arguments to the left of the '='s, to know which equation to commit to
04:49:07 <mauke> can't it just autocommit if there's no variable/pattern?
04:49:26 <mauke> e.g. foo 0 = 1; foo = id
04:49:35 <ski_> if some equations have less arguments, that would mean it couldn't patternmatch on those arguments .. but it may still need to do so for other equations
04:49:37 <chessguy> foo _ = id
04:49:38 <edi> lambdabot does require separate fps package installation with ghc 6.6 ?
04:49:47 <mauke> chessguy: that's totally different
04:49:53 <edi> chessguy: yes you can!
04:50:15 <ski_> mauke : yes .. one could argue that it is too pessimistic .. i think part of the reason is regularity / simple rule
04:50:17 <chessguy> edi, can what?
04:51:08 <chessguy> mauke, how is that different?
04:51:27 <dons> edi, no it doesn't. you use the lambdabot.cabal-6.6 file
04:51:38 <mauke> chessguy: it should be foo x = id x
04:51:51 <dons> edi, mv the 6.6 cabal file to lambdabot.cabal, and configure ; build
04:52:16 <fabiim> how can i declare instances of Show [somDataType]  to miss the '[' and ',' ?
04:52:35 <ski_> instance Show SomDataType
04:52:37 <ski_>   where
04:52:43 <ski_>   showList x = ...
04:53:02 <ski_> @type showList
04:53:03 <chessguy> hmm. strange. if you can do foo = id (without the first case), and it knows to apply id to the parameter, why can't you do foo _ = id, and it figure out that id should be applied to the parameter
04:53:04 <lambdabot> forall a. (Show a) => [a] -> ShowS
04:53:25 <fabiim> cool , thanks
04:53:26 <ski_> chessguy : that means another thing
04:53:33 <mauke> chessguy: because you swallowed the argument with _
04:53:52 <chessguy> seems strange to me
04:53:57 <ski_> chessguy : 'foo _ = id' means same as 'foo x = id' which is same as 'foo x = \y -> y'
04:54:14 <ski_> chessguy : while 'foo = id' means same as 'foo = \y -> y'
04:54:30 <mauke> foo _ = id means foo x y = y
04:54:37 <edi> chessguy
04:54:38 <edi> *ChessGuy> foo (1::Int) :: Int
04:54:38 <edi> 1
04:54:38 <edi> *ChessGuy> foo (1::Int) (2::Int) :: Int
04:54:41 <edi> 3
04:54:47 <ski_> '\x -> \y -> y' is not same as '\y -> y' (not even same type)
04:55:06 <ski_> edi : fundeps ?
04:55:11 * edi nods
04:55:54 <dons> ?users
04:55:54 <chessguy> hm. weird
04:55:54 <lambdabot> Maximum users seen in #haskell: 305, currently: 293 (96.1%), active: 33 (11.3%)
04:55:58 <edi> lol
04:56:03 <edi> oops, wrong window
04:56:33 <chessguy> it's ok, you can laugh at my cluelessness :)
04:57:15 <chessguy> i can take it
04:57:30 <lisppaste2> edi pasted "ChessGuy" at http://paste.lisp.org/display/32917
04:57:55 <edi> homework: make it work with whatever (finite) number of args
04:58:43 <chessguy> if i had a working interpreter
04:58:46 <chessguy> i would
04:59:07 <dylan> if I had a hammer...
04:59:24 <chessguy> for some reason when i try to run GHCi, it says it can't find base.hs
04:59:53 <chessguy> and i haven't gotten around to figuring out why yet
05:00:35 <ventonegro> chessguy, pretend it's windows and reinstall it
05:00:42 <therp> wah. compiling ghc is taking ages.
05:01:10 <chessguy> ventonegro, well, i just installed openBSD the other day, so i'm still trying to get my bearings
05:01:25 <ventonegro> chessguy, ah, i see
05:02:27 <chessguy> one of these days i'll beg for help in the channel and some genius will help me fix it
05:02:54 <chessguy> probably after finals :)
05:04:17 <dons> kfish: did you see Cale's rss aggregator? http://cale.yi.org/index.php/HRSS
05:04:19 <lambdabot> Title: HRSS - CaleWiki
05:04:38 <dons> its purrty
05:06:45 <edi> ah!
05:09:01 <mwc> Is that a picture of Cale? He's way more hippy than I expected
05:10:08 <edi> I've pasted the link to a friend and he told me: "is Cale a pseudonym of yours? that picture looks exactly like you"
05:10:17 <dons> heh
05:10:29 <gour_> lol
05:10:36 <edi> ...!
05:10:48 <dylan> Cale looks something like me too. except I have more of a beard . . .
05:11:00 <mwc> I am exactly as whitebread as everyone here expects
05:11:33 <ventonegro> so... you all look the same?
05:11:38 * gour_ recalls the 'theory' where beard is sign of success
05:11:59 <gour_> ..for a programming langauge
05:12:02 <dylan> gour_: especially for language designers.
05:12:07 <mauke> we are haskell. resistance is futile.
05:12:09 <dons> dylan: ah, but your both in .ca? maybe its genetic?
05:12:11 <gour_> dylan: right
05:12:24 <dylan> dons: err, no. I'm not in CA. :)
05:12:32 <gour_> mauke: forget it. even dons is advertising 300 users here
05:12:48 <dylan> though my classmates once asked which part of Canada I was from, I'm a native floridian.
05:12:57 <dons> ah my mistake hehe
05:13:24 <gour_> dons: you can regret as much you like but there is no way back
05:13:58 <dons> ?users
05:13:59 <lambdabot> Maximum users seen in #haskell: 305, currently: 294 (96.4%), active: 34 (11.6%)
05:14:14 <mauke> det [] = 1, right?
05:14:47 <gour_> dons: have you noticed my 'ebook' message?
05:15:08 <dons> gour_: oh, where?
05:15:31 <gour_> dons: 40mins ago
05:15:34 <fabiim> in showList  x ac =   ... ; ac stands for a lista that's concatenated  with every show of my element x ?
05:15:53 <dons> where? or when? :)
05:16:04 <fabiim> (at least that's the ideia of ShowS , right? )
05:16:12 <gour_> dons: 45mins actually
05:16:25 <edi> mauke: 0
05:17:07 <ski_> fabiim : yes
05:17:20 <mauke> edi: hmm, then det [[x]] == x * det [] doesn't hold
05:17:42 <mwc> We should set up a Haskell pantheon
05:17:57 <edi> mauke: I thought det A was a summation, hence summing on 0 terms is 0
05:18:26 <mwc> We'll have an IO demon, with unsafePerformIO a myth about a hero who ventured into hell. Lamda will play the part of Prometheus
05:18:35 <mwc> s/Lamda/Lambda
05:19:25 <edi> mauke: you're right.
05:19:51 <edi> for A nxn matrix, |a A| = a^n |A|
05:20:54 <nomeata> edi: But why does that show that a 0x0 matrix has a det of 0?
05:21:12 <mwc> On a more serious note, I was thinking of writing some articles on the wiki. What do you think of exploring the semantic meaning of type design in Haskell. I'm driving at the design decisions that you make when you put a parameter in a typeclass or not, what a fundep applies. The articles would be meant for beginners/intermediate
05:21:39 <edi> nomeata: yeah, 0x0 being a square matrix of order 0 is a bit... singular.
05:23:09 <edi> nomeata: is the 0x0 matrix invertible?
05:23:13 <nomeata> so can you really talk about det [], does it make sense?
05:23:29 <mauke> nomeata: it has to, my function generates it :-)
05:24:36 <nomeata> mauke: well, that argument is hard to reject :-). But what function is that that generates a 0x0 matrix?
05:25:44 <kfish> dons: yo that hrss is very nice and compact :-)
05:25:51 <nomeata> We can see an empty matrix as a member of the R^(0x0) = R^0 space, which is the set of functions from the empty set into R. Does such a function exist?
05:26:22 <chessguy> wouldn't the empty matrix be [[]]
05:26:22 <kfish> (Cale looks just like me, except without the glasses, beard and hair)
05:26:24 <nomeata> Yes, but only one
05:27:00 <nomeata> edi: so in a sense, the 0x0 matrix is the identity function, and as such is invertible
05:27:54 <mauke> heh, I must be tired
05:28:23 <edi> then the determinant can't be 0
05:28:34 <edi> because it is 0 iff the matrix is singular
05:29:27 <mauke> I just noticed that ... catMaybes check ... where check (A, _) = Nothing; check x = Just x; is better written with filter
05:29:49 <nomeata> edi: yes, therefore it has to be 1, because det (0*0) = det 0 * det 0
05:30:43 <nomeata> although this feels like thin ice :-
05:31:48 <dons> ?users
05:31:49 <lambdabot> Maximum users seen in #haskell: 305, currently: 292 (95.7%), active: 33 (11.3%)
05:32:13 <mwc> Here's another argument. Let's assume that the set of zero/zero matrices is not empty, and that the element therein is []. Suppose that A = [], the zero matrix. It's inverse must be a zero by zero matrix, which is also []. Now, [][] = I, and det([][]) = det[] det [] = 1
05:32:30 <mwc> matrices are a group, and there has to be an identity :)
05:32:45 <mwc> so that means that [] is also the identity for zero-square matrices
05:32:57 <mwc> and its det should be 1.
05:33:16 <mwc> I'm with whoever said that the set of zero/zero matrices over any field is empty.
05:34:29 <nomeata> I donât think it is empty, if you see set set of matrixes K^(aÃb) as the set of functions {1...(aÂ·b)} â K.
05:34:40 <ulph> actually it's not that difficult
05:34:42 <nomeata> As that set contains the empty function: http://en.wikipedia.org/wiki/Empty_function
05:36:19 <ulph> there is only one linear transformation from R^0 to R^0, that is the identity, and D(I) is always 1 by definition
05:36:24 <mwc> Hmm, they say the domain of the constant function is the empty set? I'd argue it's the union of every set.
05:37:17 <mwc> @type \_ -> (5 :: Int)
05:37:19 <lambdabot> forall t. t -> Int
05:37:22 <mwc> see :)
05:37:38 <ulph> more precisely the difinition of D:Mat_n(R)->R is that D is multilinear and altering, such that D(I)=1
05:48:27 <JaffaCake> kzm: any progress on the GHC build?
05:48:28 <lambdabot> JaffaCake: You have 1 new message. '/msg lambdabot @messages' to read it.
05:49:59 <kzm> one moment...
05:51:03 <ski_> mwc : of course the identity matrix over the zero-dimensional vector space is the same as the zero matrix over that
05:53:35 <mwc> I'm still not happy with the idea of a function from the empty set
05:53:41 <mwc> to me that means it makes no mappings.
05:55:24 <retybok> how can I define an infinite list of values [0,-1,1,-1,1,-1,1,....]?
05:55:44 <ski_> > 0 : cycle [-1,1]
05:55:46 <lambdabot>  [0,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,...
05:56:03 <kzm> JaffaCake, I never got around to finish the build.
05:56:08 <kzm> (sorry)
05:56:27 <JaffaCake> no problem, I'd just like to close the bug :)
05:56:29 <kzm> I could update the build info on the wiki, if you'd like :-) (but I couldn't log in with guest/guest)
05:56:37 <retybok> ski_: thanks a lot!
05:56:39 <JaffaCake> I've fixed the guest/guest thing now
05:56:45 <kzm> Hokay.
05:56:50 <JaffaCake> what's up with the build?
05:57:07 <kzm> You need to get alex and ..
05:57:17 <ski_> retybok : np
05:58:04 <JaffaCake> the required tools are described here: http://hackage.haskell.org/trac/ghc/wiki/Building/Prerequisites
05:58:06 <lambdabot> Title: Building/Prerequisites - GHC - Trac
05:58:19 <kzm> ...and happy, of course.
05:58:28 <JaffaCake> yep
05:58:41 <kzm> And it isn't sufficient to get the ones pointed to from the web pages, you need happy from darcs.
05:58:51 <kzm> To which there is no pointer at all.
05:59:04 <JaffaCake> yes, I need to release a new Happy
05:59:13 <JaffaCake> and Alex
05:59:30 <kzm> I should have known that, but building using a 'cvs'-version of ghc ended with a floating point exception, or something like that.
05:59:50 <kzm> building with a propper version, 6.4.1, needed a cabal upgrade first.
05:59:53 <JaffaCake> ah yes, that's a bug we've since fixed
06:00:17 <kzm> I don't think the sh darcs-get thing is mentioned anywhere either - but the makefile (or something) helpfully suggested it.
06:00:28 <retybok> now how do i define a new list based on the first one, ex newlist!!n = old!!n - old!!(n-1)?
06:00:29 <kzm> And that's how far I got :-)
06:00:46 <kzm> Too much other things that simply needs fixing before xmas.
06:00:49 <JaffaCake> darcs-all is mentioned here: http://hackage.haskell.org/trac/ghc/wiki/Building/GettingTheSources
06:00:51 <lambdabot> Title: Building/GettingTheSources - GHC - Trac, http://tinyurl.com/y3nvjj
06:01:10 <mauke> retybok: depends on what you want it to contain
06:01:30 <retybok> well, how can i do the example i gave for example?
06:01:49 <mauke> > let old = [0 .. 9] in zipWith (-) old (tail old)
06:01:51 <lambdabot>  [-1,-1,-1,-1,-1,-1,-1,-1,-1]
06:01:58 <ski_> newlist!!0 = old!!0 - old!!(-1)  -- ???
06:02:09 <kzm> I should probably have spent some more time browsing the wiki, but I just looked at the QuickStart page.
06:02:29 <retybok> ski_: there is some boundary condition, like newlist!!0 = 0
06:02:40 <mauke> > let old = [0 .. 9] in zipWith (-) (tail old) old
06:02:40 <JaffaCake> ah, the quick start depends on  GettingTheSources and Prerequisites
06:02:42 <lambdabot>  [1,1,1,1,1,1,1,1,1]
06:02:54 <JaffaCake> it should probably say that right at the top
06:02:57 <mwc> boo, cyclic is better :)
06:02:59 <kzm> Right.
06:03:22 <mwc> > let old = [1,4,3,6,3,5,6,2] in zipWith (-) (tail . cycle $ old) old
06:03:24 <lambdabot>  [3,-1,3,-3,2,1,-4,-1]
06:03:40 <kzm> Here's a proposal: you build me rbr with -optl-static with and without the fix, and I'll run it.  In the meantime, I can add some pointers etc to the wiki pages?
06:03:47 <kzm> :-)
06:04:19 <retybok> mwc, mauke : thanks, i see the idea. Not sure if this is general enough, though
06:05:01 <Masklinn> let test = 3
06:05:19 <Masklinn> > let test = 3
06:05:20 <lambdabot>  Parse error
06:05:48 <ski_> > let old = [0..9] in  0:zipWith (-) (tail old) old
06:05:50 <lambdabot>  [0,1,1,1,1,1,1,1,1,1]
06:05:50 <Masklinn> Why does lambdabot hate me?
06:06:04 <Masklinn> > let old = [0..9] in  0:zipWith (-) (tail old) old
06:06:06 <lambdabot>  [0,1,1,1,1,1,1,1,1,1]
06:06:08 <mauke> Masklinn: you can't have "let" without "in"
06:06:13 <Masklinn> aaah true that
06:06:20 <ski_> > let test = 3 in test
06:06:21 <lambdabot>  3
06:06:29 <finkOS> wow http://partners.iqb.ru/#17814
06:06:31 <finkOS> wow http://partners.iqb.ru/#17814
06:06:33 <lambdabot> Title: Ïàðòí¸ðñêàÿ ïðîãðàììà IQB Group &#8212; ðàáîòà â èíòåðíåòå ñ íàä¸æíîé êîìïàíèåé: ...
06:06:36 <lambdabot> Title: Ïàðòí¸ðñêàÿ ïðîãðàììà IQB Group &#8212; ðàáîòà â èíòåðíåòå ñ íàä¸æíîé êîìïàíèåé: ...
06:07:15 <Masklinn> mmm
06:07:18 <Masklinn> let l = 0:1:map (* (-1)) (tail l) in l
06:07:23 <Masklinn> > let l = 0:1:map (* (-1)) (tail l) in l
06:07:25 <lambdabot>  [0,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-...
06:07:47 <Masklinn> > let l = 0:-1:map (* (-1)) (tail l) in l
06:07:48 <lambdabot>  Not in scope: data constructor `:-'
06:07:58 <Masklinn> > let l = 0:(-1):map (* (-1)) (tail l) in l
06:07:59 <lambdabot>  [0,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,...
06:12:05 <ski_> > let [] /\/ ys = ys; (x:xs) /\/ ys = x : (ys /\/ xs); give x = (x :) . tail in take 32 . fix $ \foo -> give 0 $ foo /\/ map (1 +) foo
06:12:07 <lambdabot>  [0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5]
06:12:58 <retybok> i wasn't asking for so much :) but, yeah, it's fun :)
06:15:25 <ski_> that 'give' idiom can be useful, sometimes
06:15:46 <ski_> (reminds on 'blueprinting', i think ..)
06:17:46 <kzm> JaffaCake, hmm.. I see you're way ahead of me on the wiki...
06:31:38 <chessguy> @type let
06:31:50 <lambdabot> not an expression: `let'
06:32:04 <Masklinn> > let where = 3 in where
06:32:05 <lambdabot>  Parse error
06:32:08 <Masklinn> bah
06:32:10 <Masklinn> humbug
06:32:17 <Masklinn> let let = 3 in let
06:32:20 <Masklinn> > let let = 3 in let
06:32:21 <lambdabot>  Parse error
06:32:28 <Masklinn> > let in = 3 in let
06:32:29 <lambdabot>  Parse error
06:32:41 <chessguy> > let in = 3 in in
06:32:42 <lambdabot>  Parse error
06:33:09 <ski_> > let qualified = () in qualified
06:33:16 <lambdabot>  ()
06:33:25 <ski_> > let hiding = () in hiding
06:33:26 <lambdabot>  ()
06:33:39 <ski_> > let as = () in as
06:33:40 <lambdabot>  ()
06:33:41 <Masklinn> let module = () in module
06:33:51 <Masklinn> > let module = () in module
06:33:51 <lambdabot>  Parse error
06:33:58 * Masklinn cries
06:34:01 <Masklinn> foiled again
06:34:41 <ski_> > let deriving = () in deriving
06:34:42 <lambdabot>  Parse error
06:34:46 <ski_> (:
06:36:45 <kzm> JaffaCake?
06:39:59 <kzm> (never mind)
06:40:26 <kyevan> OK, I'm insane, but...
06:40:33 <kyevan> ghc can produce c--, right?
06:40:53 <kyevan> Couldn't it then take that, and compile to <weird platform>?
06:40:58 * kyevan runs away
06:41:20 <dylan> I think compiling to C is the first step in bootstrapping GHC for a new platform.
06:41:33 <kzm> kyevan, would that be easier than compiling via (GNU) C?
06:41:38 <norpan> in principle you are right
06:42:43 <Masklinn> but does GHC output pure clean ascii C or does it output some kind of GCC-specific C?
06:43:09 <Masklinn> (well it's not like there are many platforms without gcc)
06:43:17 <ski_> (s/ascii/ansi/)
06:43:23 <Masklinn> yeah that too
06:43:48 <chr1s> well, you can always compile to javascript, use gcc to build a javascript compiler, ...
06:44:28 <Masklinn> then you print the source code, put it on a wooden table, photography it, scan the picture, OCR it, ..
06:45:13 <chessguy> haha
06:47:14 <chr1s> that should work out
06:47:54 <dylan> the real question is -- can ghc run on the nintendo DS?
06:47:57 <chr1s> as we say in Holland,
06:47:59 <dylan> ;)
06:48:12 <chr1s> "it keeps you off the street" ;)
06:48:14 <kzm> Masklinn, gcc C, I think.
06:58:05 <lisppaste2> dionoea_work pasted "Compilation error" at http://paste.lisp.org/display/32923
06:58:09 <dionoea_work> hi
06:58:38 <dionoea_work> Anyone know what's wrong with the small test case i posted
06:58:58 <dionoea_work> (i'm kind of new to haskell so i guess it's a fairly stupid/common mistake)
06:59:30 <dionoea_work> ooops
06:59:51 <dionoea_work> ok, that was stupid
06:59:53 <chr1s> I'd use ~> instead of ?>
06:59:55 <araujo> you using two different function names
06:59:58 <dionoea_work> just forget that i pasted anything ;)
07:00:03 <chr1s> hehe, happens too all of us
07:00:09 <chr1s> s/too/to
07:02:41 <dionoea_work> i wonder why you always need to paste stuff like that on some IRC channel before you see the obvious typo
07:02:55 <dionoea_work> or at least show it to someone else
07:03:48 <araujo> it's part of the fun :-)
07:04:10 <chr1s> I regularly find the solution by explaining to other people what my problem is
07:05:43 <therp> chr1s: that's the trick of psychiatrists
07:06:03 <therp> in general, you could also talk to a brick
07:06:27 <Masklinn> dylan > probably, since some guys managed to put DSLinux on it. It may lack the ram necessary to run anything though
07:08:19 <dionoea_work> while i'm here: is it possible to have an infix function which takes more than 1 argument ? (ie: 1 on the left hand side, 2 on the right hand side)
07:08:30 <dionoea_work> *more than 2
07:10:23 <hyrax42> > let a + b = \c -> c*(a+b) in 1 + 2 3
07:10:24 <lambdabot>    Occurs check: cannot construct the infinite type: a = a -> t
07:10:24 <lambdabot>    Expec...
07:10:38 <hyrax42> > let a + b = \c -> c*(a+b) in 1 + 2 $ 3
07:10:39 <lambdabot>    Occurs check: cannot construct the infinite type: a = a -> t
07:10:39 <lambdabot>    Expec...
07:11:09 <hyrax42> > let a + b = \c -> c*(a+b) in (1 + 2)  3
07:11:10 <lambdabot>    Occurs check: cannot construct the infinite type: a = a -> t
07:11:10 <lambdabot>    Expec...
07:11:16 <hyrax42> ohhh
07:11:20 <ski_> recursion
07:11:25 <hyrax42> yea missed it
07:11:49 <hyrax42> > let a @ b = \c -> c*(a+b) in 1 @ 2 3
07:11:50 <lambdabot>  Parse error
07:12:11 <hyrax42> > let a ! b = \c -> c*(a+b) in 1 ! 2 3
07:12:12 <lambdabot>  add an instance declaration for (Num (t -> a))
07:12:27 <hyrax42> > let a ! b = \c -> c*(a+b) in 1 ! 2 $ 3
07:12:29 <lambdabot>  9
07:12:32 <ph8> hi all
07:12:38 <hyrax42> dionoea_work: not really
07:12:46 <dionoea_work> hyrax42: hehe :)
07:12:50 <hyrax42> unless maybe with some infix declaration
07:12:59 <dionoea_work> didn't seem to help here
07:13:03 <hyrax42> might make it a bit better
07:13:05 <ph8> in your average list mapping, foo :: [String] -> Boolean; foo (a:x)...
07:13:12 <ph8> fst x should return the first element of x, and snd the second right?
07:13:24 <hyrax42> ph8 no
07:13:30 <ph8> ah.
07:13:32 <hyrax42> fst and snd apply to tuples
07:13:41 <hyrax42> not lists
07:14:19 <ph8> it's actually part of a much larger problem, as you might have gathered the assignment involves n-grams
07:14:26 <hyrax42> > head . words "hello world"
07:14:27 <lambdabot>    Expecting a function type, but found `[String]'
07:14:27 <lambdabot>    Expected type: a1 ...
07:14:39 <hyrax42> > head . words $ "hello world"
07:14:40 <lambdabot>  "hello"
07:15:02 <hyrax42> are you trying to get the first letter of a owrd
07:15:05 <ph8> so, if i'm building a 3-gram or tri-gram, i would need to convert a line like "foo bar field glasses bar" to [[foo, bar] field], [[bar, field] glasses] etc
07:15:07 <hyrax42> or the first word of a list of words?
07:15:32 <hyrax42> not
07:15:38 <ph8> so i'm struggling with the n aspect, so i was trying for a fixed 3-gram, at least to begin with, with this: > mapGramsInFile (a:x) = insertWith incrementNum ([[a, fst x], snd x]) 1 (mapGramsInFile x)
07:15:45 <ph8> which is obviously wrong
07:15:51 <hyrax42> [(foo, bar, field), (bar, field, glasses), (field, glasses, ...),...]
07:15:51 <hyrax42> ?
07:16:29 <ph8> the stuff the professor gave us had an example trigram as [[String], String]
07:16:57 <hyrax42> > let trigrams l = zip3 l (tail l) (tail $ tail l) in trigrams "the quick brown fox jumped over the fence"
07:16:59 <lambdabot>  [('t','h','e'),('h','e',' '),('e',' ','q'),(' ','q','u'),('q','u','i'),('u',...
07:17:03 <hyrax42> oh woops!@
07:18:07 <hyrax42> > let trigrams l = let ws = words l in zip3 ws (tail ws) (tail $ tail ws) in trigrams "the quick brown fox jumped over the fence"
07:18:08 <lambdabot>  [("the","quick","brown"),("quick","brown","fox"),("brown","fox","jumped"),("...
07:18:55 * hyrax42 isn't sure if that what you wanted
07:19:47 <hyrax42> ph8: a) [[String], String] is not a valid type, I asssume you mean ([String], String)
07:20:01 <hyrax42> b) if they are suppsed to be trigrams, then enforce that int he type by usign a triple
07:20:34 <hyrax42> ?type (["there", "once", "was", "a", "man", "from"], "nantucket")
07:20:36 <lambdabot> ([[Char]], [Char])
07:20:58 <hyrax42> that is a value of type ([String], String) that is not a trigram...
07:21:10 <hyrax42> let the compiler help you :)
07:21:24 <hyrax42> ?type ("there", "once", "was")
07:21:25 <lambdabot> ([Char], [Char], [Char])
07:21:32 <nomeata> Haskell shoult automatically write [SomeThing] as Somethings. So we could have map ord :: Chars -> Ints. And things like Maybessssss.
07:21:40 <hyrax42> ?type ("there", "once", "was", "a")
07:21:42 <lambdabot> ([Char], [Char], [Char], [Char])
07:21:52 <hyrax42> ph8: ^^^ differet types
07:22:36 <dionoea_work> ?help
07:22:37 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
07:22:44 <dionoea_work> ?list
07:22:45 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
07:23:43 <hyrax42> ph8: was that any help?
07:24:30 <CosmicRay> Igloo: are you asking debian-release to push cpphs 0.7-4 into etch?
07:24:42 <CosmicRay> Igloo: 0.7-4 apparently fixes #403083
07:24:54 <paolino> http://rafb.net/paste/results/KmQA2t74.html
07:24:54 <paolino> test4 is asking an instance of (MonadState GraphP m) while testR is ok, why ?
07:25:12 <paolino> ehm monadreader
07:25:27 <Igloo> CosmicRay: I haven't yet, but I plan to
07:26:04 <dionoea_work> isn't etch already frozen ?
07:26:08 <hyrax42> paolino: when you use runReader you tell haskell it's a Reader type
07:26:22 <hyrax42> while if you just use asks, it could be anythign that implements MonadReader
07:26:28 <hyrax42> *any instance of MonadReader
07:26:35 <hyrax42> and there is not enough context to choose
07:26:49 <CosmicRay> Igloo: what should I do to #403083?
07:26:51 <Igloo> dionoea_work: If that meant it couldn't be changed then it would be released already...
07:26:58 <ph8> sorry hyrax-  phone
07:27:02 <hyrax42> an explicit type test4 :: Reader GraphP will fix it
07:27:26 <hyrax42> * Reader GraphP Int
07:27:35 <dionoea_work> Igloo: well at least something like: we only accept bugfixes, no new releases
07:27:44 <paolino> ok
07:27:52 <hyrax42> ?type asks min'' >>=  return
07:27:53 <lambdabot> Not in scope: `min'''
07:28:00 <glguy> ?type let f = asks succ; g = runReader f in g
07:28:03 <lambdabot> forall r. (Enum r) => r -> r
07:28:05 <glguy> ?type let f = asks succ; g = runReader f in f
07:28:07 <lambdabot> forall r. (Enum r) => Reader r r
07:28:27 <Igloo> dionoea_work: Right, which is what this is
07:28:39 <dionoea_work> humm ... ok :)
07:28:46 <glguy> hyrax42: >>= return    doesn't mean anything
07:28:54 <ph8> it helps in that it's exactly what i'm after
07:28:57 <ph8> just trying to understand it
07:29:03 <glguy> well, it means id
07:29:09 <hyrax42> glguy: yeah, I realise
07:29:18 <ph8> let trigrams l = let ws = words l in zip3 ws (tail ws) (tail $ tail ws) in trigrams "the quick brown fox jumped over the fence"
07:29:22 <ph8> sorry just repasting
07:29:31 <ph8> zip3?
07:29:36 <hyrax42> ?type zip3
07:29:38 <lambdabot> forall c b a. [a] -> [b] -> [c] -> [(a, b, c)]
07:29:42 <hyrax42> ?type zip
07:29:44 <lambdabot> forall b a. [a] -> [b] -> [(a, b)]
07:29:45 <ph8> ok
07:30:04 <paolino> I thought min'' should suggest something to the compiler , but I'm not able to monad haskell or haskell at all
07:30:19 <fasta> to monad haskell?
07:30:20 <hyrax42> using tail and tail . tail offsets the other lists to get the "trigram" structure you want
07:30:23 <ph8> so for each word ws, in words l
07:30:32 <ph8> zip ws, the tail of ws, and the tail of the tail of ws together?
07:30:34 <hyrax42> paolino: it's not the GraphP part, it picks that up
07:30:36 <fasta> How does one do that?
07:30:42 <hyrax42> ?instances MonadReader
07:30:44 <lambdabot> r ((->) r), r (ErrorT e m), r (RWS r w s), r (RWST r w s m), r (Reader r), r (ReaderT r m), r (StateT s m), r (WriterT w m), r' (ContT r m)
07:30:59 <Igloo> CosmicRay: I don't know what the semantics of 'blocking' are, but either block it on that bug or do nothing I think
07:31:01 <hyrax42> there are many instances of MonadReader, and using "asks" just says you are using one of them
07:31:12 <glguy> > let phrase = words "the quick brown fox jumped over the fence" in transpose $ take 3 $ iterate tail phrase
07:31:14 <lambdabot>  [["the","quick","brown"],["quick","brown","fox"],["brown","fox","jumped"],["...
07:31:36 <hyrax42> but ghc can't tell which without more context
07:31:42 <hyrax42> ph8: yeah, exactly
07:31:53 <hyrax42> oh wait no
07:32:18 <hyrax42> well "for each word ws, in words l" is strangely phrased and I'm not sure what you mean
07:32:49 <glguy> > let phrase = words "the quick brown fox jumped over the fence" in [take 3 x | x <- tails phrase]
07:32:51 <lambdabot>  [["the","quick","brown"],["quick","brown","fox"],["brown","fox","jumped"],["...
07:32:55 <hyrax42> glguy: I knew the instant I saw the problem that someone would come up with something invovlign iterate or fix or something
07:33:13 <glguy> hyrax42: you can count on me (-;
07:33:27 <CosmicRay> Igloo: ok
07:33:29 <Syzygy-> > last [take 3 x | x <- tails phrase] where phrase = words "the quick brown fox jumped over the fence"
07:33:30 <lambdabot>  Parse error
07:33:36 <hyrax42> I still prefer the tuple as it enforces "3-ness"
07:33:44 <glguy> Syzygy-: []
07:33:52 <hyrax42> but you could just map \[x, y, z] -> (x, y z) over it
07:33:55 <Syzygy-> glguy: Ok.
07:34:01 <hyrax42> (x, y, z) rather
07:34:06 <Syzygy-> hyrax42: How does that deal with the last few cases?
07:34:18 <Syzygy-> ["the,"fence"], ["fence"], and []
07:34:20 <hyrax42> pattern match faiure
07:34:22 <glguy> > let phrase = words "the quick brown fox jumped over the fence" in [(a,b,c) | (a:b:c:_) <- tails phrase]
07:34:24 <lambdabot>  [("the","quick","brown"),("quick","brown","fox"),("brown","fox","jumped"),("...
07:34:26 <hyrax42> :)
07:34:41 * glguy blocks
07:34:55 <glguy> > let phrase = words "the quick brown fox jumped over the fence" in last [(a,b,c) | (a:b:c:_) <- tails phrase]
07:34:56 <lambdabot>  ("over","the","fence")
07:35:35 <hyrax42> I don't use list comprehensions as often as I should
07:35:47 <hyrax42> always end up writing ugly map/filter things
07:36:16 <glguy> I like list comprehension for the same reason I like where clauses
07:36:22 <glguy> you get to announce the intended result first
07:36:26 <hyrax42> yeah
07:36:32 <hyrax42> I dont' use let at all in haskell
07:36:34 <glguy> and then follow it with an explaination
07:36:38 <hyrax42> except in #haskell
07:37:29 <ph8> hmm
07:37:31 <ph8> nice.
07:37:39 <hyrax42> paolino: try runReader test4 statoProva
07:37:42 <hyrax42> I expcet it will work
07:37:51 <ph8> let phrase = words "the quick brown fox jumped over the fence" in [take 3 x | x <- tails phrase] <-- accounts for a varying ngram size
07:38:18 <ph8> how does the 'in' keyword work?
07:38:20 <hyrax42> yeah, you could have ngrams n prhase = ...
07:38:35 <hyrax42> ph8: it's part of the let construct
07:38:50 <hyrax42> let [bindings] in expr
07:39:26 <ph8> oic
07:39:28 <ph8> like do where
07:39:41 <hyrax42> do is separate from where
07:39:54 <hyrax42> but
07:39:58 <hyrax42> expr where [bindings]
07:40:02 <hyrax42> and let [bindigns] in expr
07:40:05 <hyrax42> do they same thing
07:40:13 <ph8> i can use in without let though?
07:40:20 <hyrax42> nope
07:40:24 <ski_> only inside 'do'
07:40:27 <lithyum> hi ppl
07:40:27 <hyrax42> > let x = 3 in x + x
07:40:29 <lambdabot>  6
07:40:33 <lithyum> g00d morning gentooza
07:40:37 <ph8> obviously not :/
07:40:48 <ph8> > ngramize :: String -> ([String], [String], [String])
07:40:48 <ph8> > ngramize phrase = words phrase in [take gramSize x | x <- tails phrase]1
07:40:49 <lambdabot>  Not in scope: `ngramize'
07:40:49 <lambdabot>  Parse error
07:40:51 <ph8> not like that then
07:40:56 <ski_> (er.. that should be that you can yse 'let' without 'in', inside 'do)
07:41:00 <ph8> do i have to put it in a do and return something?
07:41:09 <hyrax42> ph8: take it slowly
07:41:28 <ph8> thought i was :p
07:41:31 <hyrax42> your type is wrong
07:41:39 <Igloo> You can't ever use in without let
07:41:57 <ph8> so ngramize phrase = do let result = words.... return result?
07:42:00 <ph8> seems an odd restriction
07:42:06 <ph8> actually forget i said that
07:42:09 <hyrax42> ph8: no
07:42:58 <hyrax42> there are lots of things wrong with your snippet
07:43:20 <ph8> indeed
07:43:23 <hyrax42> gramSize is not in scope, for example
07:43:23 <ph8> just spotted a major one
07:43:35 <ph8> gramSize = 3
07:43:36 <ph8> :p
07:44:09 <hyrax42> but your type for ngramize is wrong...
07:44:21 <glguy> expr doesn't have a where clause
07:44:22 <hyrax42> and still ignoring syntax error with the "in"
07:44:39 * glguy is catching up with the backlog
07:44:53 <hyrax42> glguy: oh it's only for var = expr?
07:44:58 <glguy> yeah
07:45:02 <hyrax42> hrmm
07:45:06 <hyrax42> so subtly different
07:45:11 <ph8> should it be [[String]] ?
07:45:21 <glguy> and where is in scope over all the guards
07:45:25 <hyrax42> ph8: yes
07:45:33 <hyrax42> for the code that follows it anyway
07:45:45 <glguy> (let ... in ...) is an expression
07:46:01 <hyrax42> glguy: ah, yeah the scoping over guards is super useful
07:46:09 <ski_> glguy : actually, your 'foo -< bar' perhaps isn't so bad ..
07:46:55 <glguy> ski_: I'm sure I'm not the first to think of it (-:
07:47:04 <hyrax42> ok so now they fixed the laundry machines
07:47:08 <hyrax42> I better do my laundry
07:47:13 <hyrax42> back in a bit
07:47:28 <ph8> ?paste
07:47:28 <lambdabot> http://paste.lisp.org/new/haskell
07:47:37 <ski_> (glguy : no time now to discuss it, though)
07:48:00 <lisppaste2> ph8 pasted "The best it can be?" at http://paste.lisp.org/display/32927
07:48:17 <ph8> obviously with gramSize actually substituted in :p
07:48:19 <Modius> What's the best solution for having a (windows dotnet) program to make calls into lisp?  Can the host program inject code in direct for execution?
07:48:26 <Modius> Sorry, I mean Haskell
07:48:38 <Modius> Dotnet --> Haskell
07:48:49 <glguy> ph8: last [take 3 x | x <- tails (words "this is a test")]
07:48:55 <glguy> > last [take 3 x | x <- tails (words "this is a test")]
07:48:56 <lambdabot>  []
07:49:03 <glguy> is that what you intended?
07:49:10 <ph8> no
07:49:13 <glguy> > [take 3 x | x <- tails (words "a b c d")]
07:49:14 <lambdabot>  [["a","b","c"],["b","c","d"],["c","d"],["d"],[]]
07:49:23 <ph8> that is
07:49:26 <ph8> but with words :p
07:49:35 <glguy> so you expect it to trail off at the end?
07:49:40 <ph8> hmm
07:49:41 <ph8> no actually
07:50:09 <ph8> bugger.
07:50:39 <ph8> that line you just pasted, wouldn't work as a one line function definition would it?
07:50:41 <ph8> i tried it first?
07:50:54 <ph8> i couldn't just write ngramize phrase =  [take 3 x | x <- tails (words phrase)] ?
07:51:03 <glguy> why not?
07:51:10 <ph8> dunno :p thought  the compiler spat at me
07:51:14 <ph8> hence the do
07:51:20 <ph8> lets try again
07:51:37 <ph8> oh works
07:51:39 <ph8> quality
07:51:52 <glguy> > takeWhile (\x -> length x == 3) [take 3 x | x <- tails (words "a b c d")]
07:51:54 <lambdabot>  [["a","b","c"],["b","c","d"]]
07:52:23 <ph8> kinky
07:52:27 <ph8> i'm just wondering what it should be doing at the end
07:52:34 <ph8> presumably it shouldn't be adding weird spaces in
07:52:37 <ph8> since there aren't any left in the doc
07:52:48 <glguy> > let phrase = words "a b c d" in [take 3 x | x <- take (length phrase - 3) $ tails phrase]
07:52:49 <lambdabot>  [["a","b","c"]]
07:52:55 <ski_> > take 2 . map (take 3) . tails $ words "a b c d"
07:52:56 <lambdabot>  [["a","b","c"],["b","c","d"]]
07:52:57 <glguy> > let phrase = words "a b c d" in [take 3 x | x <- take (length phrase - 2) $ tails phrase]
07:52:58 <lambdabot>  [["a","b","c"],["b","c","d"]]
07:55:05 <ph8> it seems that being good at haskell is all about knowing these obscure function names
07:55:14 <ph8> well the names themselves aren't obscure, but knowing they exist
07:55:20 <lispy> like intercalate!
07:55:34 <lispy> ph8: but the same is true of all the languages i know
07:55:42 <ph8> fair point i suppose
07:55:43 <hyrax42> ph8: yeah
07:55:47 <ph8> is there decent documentation anywhere for haskell though?
07:55:51 <hyrax42> otherwise you end up implementing library funcitons all the type
07:55:54 <hyrax42> ?docs Prelude
07:55:54 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
07:56:01 <ph8> awesome!
07:56:03 <hyrax42> ?index zip3
07:56:04 <lambdabot> Data.List, Prelude
07:56:10 <hyrax42> ?index take
07:56:11 <lambdabot> Data.List, Prelude
07:56:20 <hyrax42> ?docs Data.List
07:56:20 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
07:56:28 <hyrax42> ph8: etc. you get the idea ;)
07:56:31 <lispy> ph8: and if you know what type the function you need has, then you can use hoogle to find it
07:56:42 <lispy> ?hoogle (a -> b) -> [a] -> [b]
07:56:43 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
07:56:44 <lambdabot> Control.Parallel.Strategies.parMap :: Strategy b -> (a -> b) -> [a] -> [b]
07:56:44 <lambdabot> Prelude.scanr :: (a -> b -> b) -> b -> [a] -> [b]
07:57:20 <dionoea_work> why did the third one match ?
07:57:46 <hyrax42> dionoea_work: it does a "fuzzy" search
07:57:59 <dionoea_work> k
07:58:09 <hyrax42> ?hoogle [a] -> (a -> b) -> [b]
07:58:10 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
07:58:10 <lambdabot> Control.Parallel.Strategies.parMap :: Strategy b -> (a -> b) -> [a] -> [b]
07:58:10 <lambdabot> Prelude.scanr :: (a -> b -> b) -> b -> [a] -> [b]
07:58:30 <hyrax42> ^^^ e.g. argument reordering
08:01:42 <ph8> nice1
08:01:46 <ph8> what a headache ;)
08:03:56 <ptolomy> Is it weird that I think Oleg is Batman?
08:04:27 <ptolomy> Not literally, but whenever I read his name, I imagine him in a batcave somewhere doing unthinkable typemagic.
08:05:01 <emu> where does the Joker come in?
08:05:21 <ptolomy> I assume that'd be Bjarne.
08:05:26 <velco> hehe
08:06:06 <ptolomy> Trying to imagine Bjarne posing C++-friendly type-riddles just makes me want to drink.
08:07:45 <emu> here's an amusing piece of code I just scrolled over: error "This does not work, we'll go in an infinite loop.  FIX!!!"
08:08:10 <benmos> Hi all. Can anyone tell me if there's any advantages to using (Reader r) given that ((->) r) seems to be a tidier way of doing the same thing?
08:08:30 <glguy> ?type local
08:08:31 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
08:08:48 <glguy> benmos: ((->)r) doesn't have local, for one
08:08:54 * earthy grins
08:09:10 <benmos> instance MonadReader r ((->) r) where
08:09:19 <benmos> local f m = m . f
08:09:24 <benmos> ...I think it does?
08:09:37 <glguy> oh, well... then maybe there are equivalent
08:09:42 <glguy> they*
08:09:56 <benmos> ok. I was just checking I wasn't missing something...
08:10:07 <benmos> ...guess I'll opt for ((->) r) in the future ...
08:10:15 <allbery_b> I thought ((->) a) *was* the reader monad
08:10:16 <benmos> ..obviously can't do transformer stuff with it though.
08:10:40 <glguy> allbery_b: it's just an instance of MonadReader, it's not the actualy *Reader*
08:10:43 <benmos> I've heard that said too... but it's definitely a different thing from Reader.
08:11:20 <glguy> > (local succ (*2)) 4
08:11:21 <lambdabot>  10
08:11:38 <ski_> sometimes less confusion ensues, when 'Reader r' is used instead of '(r ->)'
08:11:58 <glguy> yeah... it's more obvious what you are doing when you have the runReader xyz value
08:11:58 <benmos> Ah, ok - from the documentation / readability point of view?
08:12:07 <benmos> right.
08:12:16 <glguy> I usually use ((->)r) in small isolated cases
08:12:16 <benmos> thanks.
08:12:24 <benmos> ok - makes sense.
08:13:31 <glguy> like: rollDice = liftM2 (+) (getRandomR (1,6)) (getRandomR (1,6)) -- as a contrived case
08:16:16 <benmos> where's getRandomR defined?
08:16:45 <glguy> It's not a standard function. it's part of MonadRandom on the wiki
08:17:03 <glguy> I wrote my own version of that exact function before I found the implementation on teh wiki
08:17:04 <benmos> ah, ok. Will take a look.
08:17:05 <lispy> ?where MonadRandom
08:17:05 <lambdabot> I know nothing about monadrandom.
08:17:07 <glguy> now I just use the wiki version
08:17:11 <lispy> ?wiki MonadRandom
08:17:11 <lambdabot> http://www.haskell.org/haskellwiki/MonadRandom
08:17:15 <benmos> thx
08:17:28 <glguy> it's just a wrapped StateT
08:17:38 <ptolomy> Is there a wiki page explaining what (->) is?
08:17:45 <glguy> maybe?
08:18:21 <benmos> It's mentioned in http://www.haskell.org/haskellwiki/Monads_as_Containers
08:18:24 <lambdabot> Title: Monads as containers - HaskellWiki
08:22:50 <opqdonut> lo
08:22:50 <lambdabot> opqdonut: You have 1 new message. '/msg lambdabot @messages' to read it.
08:23:11 <opqdonut> nice system ^^
08:23:47 <lispy> lambdabot is like your personal irc assistant!
08:23:50 <glguy> ptolomy: do you understand Reader?
08:24:11 <yaxu> i don't have any new messages :(
08:24:13 <opqdonut> lispy: true
08:24:31 <ptolomy> glguy:  mm... maybe? In theory. Never used it.
08:24:31 <ph8> ok
08:24:35 <ph8> pastes up
08:24:37 * ph8 eyes the paste bot
08:24:53 <ph8> http://paste.lisp.org/display/32929
08:24:56 <ph8> that's my ngram code, as it stands
08:25:02 <ph8> and it's producing an error that i can't seem to get rid of
08:25:15 <glguy> ?type do { s <- asks sum; n <- asks genericLength; return (s / n) }
08:25:18 <ph8> are there (m)any ways I can make it better?
08:25:18 <lambdabot> forall i (m :: * -> *). (Fractional i, MonadReader [i] m) => m i
08:25:24 <lisppaste2> metaperl pasted "modifying a mergeSort to use (<=)... how?" at http://paste.lisp.org/display/32930
08:25:43 <glguy> > runReader (do { s <- asks sum; n <- asks genericLength; return (s / n) }) [1,5,7,10]
08:25:45 <lambdabot>  5.75
08:26:10 <glguy> ptolomy: in the Reader monad, "ask" is an action that returns the value contained in teh reader
08:26:17 <chessguy> @version
08:26:18 <lambdabot> lambdabot 4p302, GHC 6.5 (OpenBSD i386)
08:26:18 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
08:26:21 <glguy> ptolomy: asks is a function that applies a functoin to the contained value
08:26:25 <ndm> @botsnack
08:26:27 <lambdabot> :)
08:26:27 <glguy> and gives you the result
08:26:47 <ptolomy> I'm with you so far.
08:26:53 <chessguy> hmm
08:26:58 <glguy> the value contained is the common parameter, like a lambda expression with one argument
08:27:09 <chessguy> 1332 patches, wow
08:27:19 <glguy> the difference in ((->)r) and Reader is that Reader needs the runReader
08:27:43 <glguy> ((->)r) also allows you to omit the asks
08:27:45 <glguy> liek this:
08:27:59 <Cale> well, ask = id :)
08:28:15 <glguy> > (do { s <- asks sum; n <- asks genericLength; return (s / n) }) [1,5,7,10] -- first I'll show with asks, but no runReader, now we are using ((->)r)
08:28:16 <lambdabot>  5.75
08:28:36 <ptolomy> ph8: Using 'String' instead of '[Char]' makes it much easier for me to read your code.
08:28:37 <glguy> > (do { s <- sum; n <- genericLength; return (s / n) }) [1,5,7,10] -- ((->)r) doesn't need the asks, they are implicit
08:28:38 <lambdabot>  5.75
08:28:57 <ptolomy> Swhy I don't use lisp, I lose track of bracket/parens after 2.
08:29:00 <Cale> > liftM2 (/) sum genericLength [1,5,7,10]
08:29:02 <lambdabot>  5.75
08:29:21 <opqdonut> @tell chessguy yeah i know my code is a bit hackish, but i'm glad it helped. the Random class is really nice for stuff like this. some people criticized me of putting everything inside the IO monad but i think it is the simplest solution... and yes, the paper was done in somewhat of a hurry so generalness of the code was not focused on. ping me when you come back online ok?
08:29:21 <lambdabot> Consider it noted.
08:29:21 <ph8> i thought [String] == [Char]
08:29:22 <ptolomy> glguy: That is pretty neat.
08:29:24 <ph8> not String = [Char]
08:29:26 <ph8> noted though
08:29:33 <Cale> ph8: that would be a mistake :)
08:29:34 <ph8> i'll make those changes
08:29:44 <lispy> :t "aoeu"
08:29:46 <lambdabot> [Char]
08:29:46 <chessguy> opqdonut, ping
08:29:47 <lambdabot> chessguy: You have 1 new message. '/msg lambdabot @messages' to read it.
08:29:47 <ph8> it does make more sense this way :p
08:29:48 <chessguy> :)
08:29:50 <Cale> It makes sense that String = [Char] if you think about it :)
08:30:01 <opqdonut> chessguy: oh, hi
08:30:10 <chessguy> wow, i have a new message!
08:30:14 <chessguy> hang on, let me check it
08:30:14 <opqdonut> chessguy: i tried to tab complete you but it didn't catch
08:30:16 <Cale> another thing which the Reader monad is really good at is local binding of variables
08:30:22 <ph8> cheers ptolomy
08:30:24 <glguy> ptolomy: this is why you can use join f x = f x x
08:30:25 <ph8> any idea why that error occurs?
08:30:27 <opqdonut> oh, you joined after i started writing ^^
08:30:29 <ph8> i've made some alterations:
08:30:46 <ph8> i've put in glguy's > ngramize phrase = takeWhile (\x -> length x == gramSize) [take gramSize x | x <- tails (words phrase)]? <-- takeWhile addition
08:30:59 <ph8> but still the same error, i thought the things at the end might be a [String] instead of a [[String]]
08:31:12 <Cale> You can keep dictionary of variable bindings in the environment parameter, and use the local function to make local changes to that dictionary which go away when the scope of the local finishes.
08:31:18 <glguy> > let join' f = (do { a <- f; b <- a; return b}) in join' (*) $ 4
08:31:20 <lambdabot>  16
08:31:31 <nomeata> > liftM2 (/) sum length [1,5,7,10]
08:31:33 <lambdabot>  add an instance declaration for (Fractional Int)
08:31:41 <glguy> nomeata: length has type Int
08:31:46 <glguy> or returns type Int at least
08:31:48 <nomeata> > liftM2 (/) sum (fromIntegral.length) [1,5,7,10]
08:31:49 <lambdabot>  5.75
08:31:52 <chessguy> opqdonut, for the record, what you were doing was a lot closer to a genetic algorithm than genetic programming, i think
08:31:57 <Cale> For many uses, this is simpler and easier to get right than using a state monad.
08:32:21 <chessguy> though i'm starting to learn that the line between the two can be pretty blurry
08:32:23 <opqdonut> chessguy: yeah, true, as the tactic isn't really a even close to turing-complete program
08:32:42 <chessguy> well, it doesn't have to be turing complete
08:32:42 <nominolo> hm, does anyone know a trick how to make this work: instance Monad Foo where p >>= fq = SomeConstructor p (fq ())  ?
08:32:43 <Cale> (If you find yourself always making some change to state before calling something and then changing it back afterward, chances are, you want the Reader monad and local
08:32:46 <Cale> )
08:32:58 <nominolo> i.e. i want to declare only (>>)
08:33:00 <chessguy> how was the performance of the evolution? did you converge on a solution?
08:33:09 <opqdonut> chessguy: yeah, really fast
08:33:18 <chessguy> wow, cool
08:33:20 <opqdonut> 80 teams, 10 steps, good solution
08:33:20 <nomeata> @pl let average list = sum list / (fromIntegral (length list)) in average
08:33:21 <lambdabot> liftM2 (/) sum (fromIntegral . length)
08:33:22 <opqdonut> i was amazed
08:33:27 <Cale> nominolo: hmm, if you only have >>, then it's not a monad
08:33:37 <opqdonut> it discovered advancing under covering fire and stuff
08:33:40 <opqdonut> blew my mind
08:33:42 <nominolo> Cale: yes, but i'd like to have do-notation
08:33:45 <chessguy> you mean your population was 80 teams, and it only took 10 generations?
08:33:48 <opqdonut> but gtg again i'm afraid
08:33:50 <opqdonut> chessguy: yes!
08:33:53 <chessguy> wow!
08:33:56 <chessguy> great results
08:34:00 <chessguy> ok, i'll catch you later
08:34:10 <opqdonut> i'll make an english summary of the paper and mail it or something ok?
08:34:11 <ptolomy> ph8: insertGamsToMap seems like it should use fold instead of explicit recursion.
08:34:11 <opqdonut> bye!
08:34:19 <chessguy> that would be great!
08:35:00 <ptolomy> ph8: .. and incrementNum can just as easily be (+)
08:35:07 <Cale> nominolo: what's your type, perhaps we can define it as a proper monad somehow?
08:35:18 <ph8> mmm folding
08:35:24 <ph8> i suppose i couldn't ignore it forever
08:35:37 <ptolomy> ph8: It's good for you. :)
08:35:52 <ph8> > insertGramsToMap (a:x) = insertWith (fold (+)) a 1 (insertGramsToMap x)
08:35:53 <lambdabot>  Parse error
08:35:57 <ph8> for incrementNum
08:36:00 <ph8> ?
08:36:18 <nominolo> Cale: well, it's the type of assembly programs. But since scoping rules are different I cannot use "x <- ..." stuff but have to use my own (<--) operator.
08:36:32 <ph8> or do i have to always use foldl/foldr
08:36:48 <Cale> ph8: you always have to pick, if in doubt, use foldr
08:36:49 <nominolo> Cale: the type is data AsmProg a = Inst ... | AsmProg a :>> AsmProg a
08:37:10 <ph8> foldr seems right here
08:37:14 <ph8> since b is the existing value
08:37:14 <ph8> i think :
08:37:16 <ph8> :p
08:37:31 <Cale> ph8: I made some diagrams to help sort it out :)
08:37:48 <Cale> http://cale.yi.org/index.php/Fold_Diagrams
08:37:50 <lambdabot> Title: Fold Diagrams - CaleWiki
08:38:14 <ptolomy> ph8: Out of curiosity, what does ngramize do? Rather, does it do what you want it to?
08:39:19 <ndm> Cale: was discussing folds a few days ago with a student, using your notes and comments somewhere to help, just to say thanks :)
08:39:23 <ndm> @karma+ Cale
08:39:24 <lambdabot> Cale's karma raised to 37.
08:39:31 <Cale> :)
08:39:46 <Cale> http://en.wikipedia.org/wiki/Fold_%28higher-order_function%29
08:39:50 <ndm> was trying to figure out why SYB is gfoldl and not gfoldr, its mind bending stuff :)
08:40:03 <ndm> (but we got it in the end, although don't ever want to know again)
08:40:14 <nominolo> Cale: oh, hm.  (At least currently) it's complaining that the second arg to :>> has an "a" instead of the "b" as required by (>>=)
08:40:53 <Cale> nominolo: You might come to the conclusion that it just isn't a monad, so do-notation won't work.
08:40:59 <ptolomy> ph8: It breaks a text fragment into groupings of each three consecutive words (or less if there aren't enough for a 3 word grouping), right?
08:41:28 <ph8> [.: 15:31:22 :.] <glguy> > let phrase = words "the quick brown fox jumped over the fence" in [(a,b,c) | (a:b:c:_) <- tails phrase]
08:41:28 <ph8> [.: 15:31:23 :.] <lambdabot>  [("the","quick","brown"),("quick","brown","fox"),("brown","fox","jumped"),("...
08:41:29 <ph8> yup
08:41:31 <Cale> nominolo: what is the type parameter used for?
08:41:31 <ph8> ngrams
08:41:45 <ptolomy> Ah.
08:41:51 <nominolo> Cale: just to allow instance Monad AsmProg where ...
08:41:52 * ptolomy just looked it up.
08:42:13 <nominolo> Cale: since a monad has to be of kind * -> *
08:42:25 <chessguy> is there a library that will let me evaluate haskell expressions dynamically?
08:42:35 <CosmicRay> hs-plugins iirc
08:42:38 <Syzygy-> hs-plugins?
08:42:42 <Syzygy-> yah.
08:42:49 <Cale> nominolo: Okay, I think it's probably not a monad then, so you just can't use do-notation sensibly.
08:43:07 <glguy> nominolo: why not just write an operator in the style of >> and then have your code: this >>\nthat >>\tntheother
08:43:30 <nominolo> glguy: looks ugly ;)
08:43:42 <Cale> (In addition to being an instance of Monad, your definitions of >>= and return also have to satisfy the monad laws in order for do-notation to make any sense)
08:43:55 <glguy> nominolo: so is adding a parameter and pretending to be a monad :-p
08:44:06 <ph8> ptolomy: it's a weird type error though no?
08:44:13 <chessguy> oh, i thought that was just for doing compiling
08:44:18 <ptolomy> ph8: Your type signature for insertGramsToMap is wrong.
08:44:21 <ptolomy> rather, for the Map.
08:44:21 <Cale> yes, I think it's far more sensible just to define an infix operator, and lay things out in columns
08:44:56 <nominolo> Cale: ok, that'll sure work.  maybe i'll find some way to make it a monad later on
08:45:07 <ptolomy> it should be a 'Map [[Char]] Int' right?
08:45:09 <ph8> hmm
08:45:24 <ph8> or a [String] Int?
08:45:29 <ptolomy> Right. :)
08:45:44 <ptolomy> because it is getting a list of list of strings and inserting them one-by-one.
08:47:20 <glguy> ?type Data.Map.fromListWith
08:47:21 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> [(k, a)] -> Data.Map.Map k a
08:47:27 * ph8 ponders
08:48:43 <glguy> > M.fromListWith (+) $ [((a,b,c),1) | (a:b:c:_) <- tails $ words "a b c d c d c d"]
08:48:45 <lambdabot>  {("a","b","c"):=1,("b","c","d"):=1,("c","d","c"):=2,("d","c","d"):=2}
08:49:02 <ph8> that's exactly what i'm after
08:49:06 <glguy> (to borrow from Cale's example yesterday)
08:49:15 <ph8> is that from Data.Map though?
08:49:23 <ph8> i get the distinct impression i'm not allowed to use that
08:49:25 <glguy> yeah, but it could be done without Data.Map
08:50:22 <ph8> ptolomy: it doesn't work even with that change
08:50:27 <ph8> that's a bit above me right now glguy :p
08:50:34 <ph8> so many questions about that line
08:51:07 <Vq^> ph8: tough demands
08:51:19 <ptolomy> ph8: What is the error now?
08:51:33 <glguy> > map (liftM2 (,) head length) $ group $ sort $ [(a,b,c) | (a:b:c:_) <- tails $ words "a b c d c d c d"]
08:51:35 <lambdabot>  [(("a","b","c"),1),(("b","c","d"),1),(("c","d","c"),2),(("d","c","d"),2)]
08:52:13 <ph8> actually it's a newwer weird one
08:53:14 <ph8> http://paste.lisp.org/display/32929#2
08:53:16 <ph8> oddness
08:54:00 <glguy> ?type insertWith
08:54:02 <lambdabot> Not in scope: `insertWith'
08:54:21 <glguy> ?type Data.Map.insertWith
08:54:23 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> k -> a -> Data.Map.Map k a -> Data.Map.Map k a
08:54:38 <glguy> ph8: you aren't allowed to use fromListWith, but you are allowed to use insert with?
08:55:02 <ptolomy> ?type foldr
08:55:04 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
08:55:32 <ptolomy> ph8: With the joys of foldr, you don't need to have the explicit recursion.
08:55:35 <glguy> you don't want to insertWith a fold, you want to just use the (+)
08:55:53 <glguy> and you dont' want to write your own folds, the ones in Prelude work
08:55:54 <ph8> well i don't know if i'm not allowed
08:55:56 <ph8> i might email him actually
08:56:02 <glguy> if you can use Data.Map
08:56:05 <glguy> you can use the Prelude...
08:56:42 <ph8> ah i see!
08:56:43 <glguy> are you allowed to use the 'u' key?
08:56:45 <ph8> that brings us back to:
08:56:45 <ph8> ERROR "Main.lhs":31 - Type error in explicitly typed binding
08:56:46 <ph8> *** Term           : mapGramsInFile
08:56:46 <ph8> *** Type           : String -> Map [String] Int
08:56:46 <ph8> *** Does not match : String -> Map [[String]] Int
08:56:48 <ptolomy> I would like folds more if I could remember the argument order.
08:56:49 <ph8> shit, sorry about pastage
08:57:04 <ptolomy> ph8: So your type annotation is wrong?
08:57:47 <ptolomy> ph8: I'd suggest making a type alias for your Map type so you are sure it is consistent.
08:58:03 <ptolomy> type NgramMap = Map [String] Int  or something more correct.
08:58:50 <ph8> well, this is a point
09:00:00 <ph8> from the instructions: "Hint: a representation of ([String],String) is adequate for N-grams, eg (["the", "small"], "cat") for a 3-gram"
09:00:22 <ph8> i'm trying to decide why i'd want to represent them that way, the question after that of course would be how
09:00:39 <glguy> ph8: do you have a link to the assignment?
09:01:01 <glguy> because from that line... I'd say that either you don't understand the assignment, or the assigner doesn't
09:01:04 <ph8> ah, it's not actually on a restircted intranet, like i thought
09:01:06 <ph8> http://www.dur.ac.uk/p.c.callaghan/ngrams06.html
09:02:26 <ptolomy> ah.
09:02:46 <nominolo> > let a:b:c:_ = [1..] in (a,b,c)
09:02:47 <lambdabot>  (1,2,3)
09:03:00 <nominolo> is there a more readable notation for this?
09:03:05 <ph8> i'm currently attempting stage 1? ;)
09:03:16 <ph8> [1..3] ?
09:03:32 <nominolo> no, on the other side of the "="
09:03:32 <ph8> > let a:b:c_ = [1..3] in (a,b,c)
09:03:34 <lambdabot>  Not in scope: `c'
09:03:34 * ptolomy resists the urge to do the homework instead of $job.
09:03:36 <ph8> my bad :/
09:03:40 <ph8> lol ptolomy
09:04:05 <nominolo> in prolog you have [a,b,c|_]
09:04:06 <ndm> ptolomy: do you get the job $, even if you do the homework? (i.e. paid per hour?)
09:04:23 <ph8> that's an excellent question ;) i still can't see what's wrong
09:04:24 <ptolomy> salary.
09:06:24 <glguy> > foldr (\x -> M.insertWith (+) x 1) M.empty "the small cat sat near the small dog."
09:06:25 <lambdabot>  {' ':=7,'.':=1,'a':=5,'c':=1,'d':=1,'e':=3,'g':=1,'h':=2,'l':=4,'m':=2,'n':=...
09:06:44 <ph8> http://paste.lisp.org/display/32934
09:06:46 <ph8> the current brilliance
09:06:50 <ph8> ptolomy: nothing to worry about then ;)
09:07:06 <ph8> i can anticipate another 5 people like me descending on this poor channel in a couple of weeks with similar questions
09:07:11 <ph8> unless i'm especially idiotic
09:07:17 <ph8> i'm just doing this quite early so i can go skiing
09:07:19 <ph8> ;)
09:07:44 <glguy> the reason for (["a","b"],"c") is that for ngram=3, you are supposed to have keys of two strings or elss, and values of 1 string
09:09:32 <glguy> > M.fromListWith const $ [(take 2 x, take 1 (drop 2 x)) | x <- tails $ words "the small cat sat near the small dog."]
09:09:34 <lambdabot>  {[]:=[],["cat","sat"]:=["near"],["dog."]:=[],["near","the"]:=["small"],["sat...
09:09:34 <ptolomy> ph8: the result type of insertGramsToMap and mapNgramsInFile should be the same.
09:10:12 <ph8> but am i not meant to know frequencies of ngrams as well?
09:10:42 <ph8> yes it should
09:10:55 <ph8> i'm not sure where i got the frequencies idea from
09:10:58 <ph8> but i am, right?
09:14:24 <glguy> No, you don't know the frequencies
09:15:07 <glguy> > M.fromListWith (++) $ [(take 2 x, take 1 (drop 2 x)) | x <- tails $ words "the small cat sat near the small dog."] -- correction for (++)
09:15:09 <lambdabot>  {[]:=[],["cat","sat"]:=["near"],["dog."]:=[],["near","the"]:=["small"],["sat...
09:15:44 <ph8> eh?
09:15:48 <ph8> what's that last one do?
09:15:57 <glguy> builds your table
09:16:15 <glguy> using a function that you don't get to use
09:17:17 <ph8> i might be able to use it, lets assume i can
09:17:24 <ph8> what's all the []:=[]?
09:17:38 <ph8> oh, key/value pairs
09:17:41 <glguy> yeah
09:17:50 <metaperl> dons - this Data.Map thing is what I have needed since day 1. Thanks for the tutorial! http://cgi.cse.unsw.edu.au/~dons/blog/2006/12/16#programming-haskell-intro
09:17:52 <lambdabot> Title: Haskell hacking, http://tinyurl.com/yz4kdc
09:18:03 <ph8> is that what he meant though?
09:18:50 <ph8> on a brief sidenote, i'm trying to make an isSpace function, currently i have:
09:19:05 <ph8> > isSpace :: String -> bool; isSpace " " = True; isSpace _ = False
09:19:05 <lambdabot>  Parse error
09:19:08 <glguy> ?type Data.Char.isSpace
09:19:09 <lambdabot> Char -> Bool
09:19:12 <ph8> kinky
09:19:20 <glguy> no, not kinky...
09:19:45 <glguy> > (isSpace ' ' , isSpace '_')
09:19:46 <lambdabot>  (True,False)
09:19:58 <glguy> > (isSpace ' ' , isSpace '\t')
09:19:59 <LPhas> hi@all
09:19:59 <lambdabot>  (True,True)
09:20:07 <LPhas> maybe soumeone could help
09:20:08 <scodil> hey what does it mean when hPutBuf fails with "bad address"? I'm using withStorableArray so the address should be ok. is that it what it says when you read off the end?
09:20:08 <glguy> > (isSpace '\n' , isSpace '\t')
09:20:10 <lambdabot>  (True,True)
09:20:11 <LPhas> i have C functione
09:20:15 <LPhas> named Foo
09:20:21 <LPhas> with uppercase at the beginning
09:20:25 <LPhas> if i make
09:20:36 <LPhas> foreign import ccall Foo :: a -> b
09:20:53 <LPhas> i get a parse error
09:20:58 <LPhas> for the uppercase i think
09:21:06 <LPhas> suggestions?
09:21:27 <scodil> foreign import "header.h Foo" c_foo :: a -> b ?  or something like that
09:21:47 <metaperl> @tye findWithDefault
09:21:49 <lambdabot> Not in scope: `findWithDefault'
09:21:57 <LPhas> scdil: i try
09:22:00 <metaperl> @type findWithDefault
09:22:02 <lambdabot> Not in scope: `findWithDefault'
09:22:04 <glguy> besides, C naming convention isn't capitalized function names q-:
09:22:26 <scodil> foreign import ccall "Tiff_c.h openTiff" openTiff_c :: CString -> IO TiffHandle
09:22:54 <scodil> for a function called openTiff, defined in c-header Tiff_c.h, which binds to haskell function openTiff_c
09:22:59 <ph8> hmm i'm getting into way too much trouble here
09:23:03 <ph8> thanks for your help glguy
09:23:06 <ph8> i'll probably come back to it in a few hours
09:23:07 <glguy> yw
09:23:18 <ph8> this language is so aggravating
09:23:29 <glguy> *thats* no way to get help
09:23:32 <ph8> heh
09:23:39 <ph8> i meant it in the nicest possible way
09:24:33 <LPhas> scodil: worked, smack
09:24:42 <scodil> smack?
09:24:48 <LPhas> :P
09:24:55 <scodil> what is that like a high five?
09:25:10 <moonlite> are there any standard function with type a -> Integer ->  (a -> b) -> [b] that gives [f a, f (f a), f (f (f a))).. f applied n times to a]?
09:25:12 <scodil> downlow... *smack*
09:25:48 <sorear> \z n f -> take n (tail (iterate f z))
09:26:02 <LPhas> scodil: oh, no, is an onomatopoeia for a kiss
09:26:12 <nomeata> @type \z n f -> take n (tail (iterate f z))
09:26:13 <lambdabot> forall a. a -> Int -> (a -> a) -> [a]
09:26:16 <LPhas> but i'm NOT gay eheh
09:26:33 <nomeata> moonlite: your type is a bit to general for the desired use
09:26:40 <moonlite> nomeata: hm, might be
09:27:04 <moonlite> a -> a it should be of course
09:27:11 <thelsdj> you can't really apply it more than once if its a -> b
09:27:18 <moonlite> yep saw that now :)
09:27:25 <sorear> Note that since f a and f(f a)  must be the same type, your type is restricted to (a -> a) ; much like church-integers 2 and higher all have most general type (a -> a) -> a -> a
09:27:51 <glguy> lol at moonlite getting told by 3 people about his mistake ;)
09:28:02 <glguy> moonlite: you need to use a function (a->a) if you want to iterate with it
09:28:10 <moonlite> thx glguy :D
09:29:06 <metaperl> which version of split http://haskell.org/hoogle/?q=split  was dons using in pairs   = map (split.words) (lines src)
09:29:08 <lambdabot> Title: split - Hoogle
09:29:10 <sorear> Anyway, one usually in haskell doesn't  need to limit the number of results.  You usually use iterate and then only use n of the results
09:29:28 <glguy> > fix ((2:) . take 5 . map (*2))
09:29:30 <lambdabot>  [2,4,8,16,32,64]
09:29:38 <metaperl> @type fix
09:29:40 <lambdabot> forall a. (a -> a) -> a
09:30:01 <moonlite> sorear: well, either i can use a "take n" when i call the function or i can do it at definition
09:30:19 <glguy> moonlite: right, so do it outside of the function to make your function more useful
09:30:43 <metaperl> glguy - how does that work? you never gave it any input data!
09:31:22 <glguy> fix f:  f ( f ( f ( f ( f ( f ( f (... -- there is no actual inner argument
09:32:02 <glguy> fix (1:) -> 1: (1: (1: (1: (1: ...
09:32:11 <glguy> -> [1,1..
09:32:48 <nomeata> > fix ((1:) . head)
09:32:49 <lambdabot>    Occurs check: cannot construct the infinite type: a = [a]
09:32:49 <lambdabot>    Expected...
09:32:54 <nomeata> > fix ((1:) . take 2)
09:32:55 <lambdabot>  [1,1,1]
09:33:21 <glguy> > take 3 (fix (1:)) -- aka
09:33:22 <lambdabot>  [1,1,1]
09:34:08 <opqdonut> > fix id -- kekek
09:34:09 <lambdabot>  Add a type signature
09:34:16 <glguy> > fix id :: ()
09:34:17 <opqdonut> > fix id :: Integer -- kekek
09:34:18 <lambdabot>  Exception: <<loop>>
09:34:19 <lambdabot>  Exception: <<loop>>
09:34:24 <glguy> :)
09:34:25 <opqdonut> :)
09:34:30 <emu> > iterate (*2)
09:34:31 <lambdabot>  Add a type signature
09:34:33 <emu> > iterate (*2) 1
09:34:34 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
09:34:42 <sorear> also note:
09:34:49 <sorear> > fix (*2) :: Integer
09:34:49 <lambdabot>  Exception: <<loop>>
09:34:54 <glguy> > fix ((1:).map(*2))
09:34:55 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
09:34:58 <nomeata> fix ((1:) . take 2) =  1:  take 2 (fix ((1:).take 2) ) = 1:  take 2 (1:  take 2 (fix ((1:).take 2) )) = 1:1: take 1  (fix ((1:).take 2) ) = 1:1: take 1(1: take 2 (fix ((1:).take 2) )) = 1:1:1:[]
09:35:05 <scodil> is there an easier way to read a binary value off of a handle, easier than: v <- alloca $ \ptr -> hGetBuf hdl ptr (sizeOf v) >> peek ptr .... the problem is that v isn't in scope yet
09:35:46 <opqdonut> > fix $ const 1
09:35:47 <lambdabot>  1
09:35:49 <sorear> write a polymorphic function!
09:35:50 <opqdonut> surprising
09:36:11 <nomeata> so,  fix . const == id ?
09:36:14 <nomeata> @type fix . const
09:36:16 <lambdabot> forall a. a -> a
09:36:19 <opqdonut> yep
09:36:29 <opqdonut> ?unpl fix . const
09:36:29 <lambdabot> (\ d -> fix (\ _ -> d))
09:36:32 <nomeata> @type  const . fix
09:36:33 <lambdabot> forall b a. (a -> a) -> b -> a
09:36:39 <nomeata> :-)
09:36:47 <opqdonut> hehe, pointless functions ftw
09:37:12 <sorear> ?free id
09:37:14 <lambdabot> f . id = id . f
09:37:22 <sorear> ?ft id
09:37:24 <lambdabot>  forall T1,T2 in TYPES. forall h1 :: T1 -> T2, h1 strict.
09:37:24 <lambdabot>   forall x1 :: T1.
09:37:24 <lambdabot>    h1 (t1 x1) = t1 (h1 x1)
09:37:46 <nomeata> ?ft (fix.const)
09:37:48 <lambdabot>  forall T1,T2 in TYPES. forall h1 :: T1 -> T2, h1 strict.
09:37:49 <lambdabot>   forall x1 :: T1.
09:37:49 <lambdabot>    h1 (t1 x1) = t1 (h1 x1)
09:38:15 <sorear> the theorums are generated based only on the types
09:38:22 <sorear> but beware:
09:38:22 <opqdonut> ?help free
09:38:23 <emu> > (\f x -> fix ((x:) . (:[]) . f . head)) (*2) 1
09:38:23 <lambdabot> free <ident>. Generate theorems for free
09:38:24 <lambdabot>  [1,2]
09:38:30 <sorear> ?ft seq
09:38:32 <lambdabot>  forall T1,T2 in TYPES. forall h1 :: T1 -> T2, h1 strict.
09:38:32 <lambdabot>   forall T3,T4 in TYPES. forall h2 :: T3 -> T4, h2 strict.
09:38:32 <lambdabot>    forall x1 :: T3.
09:38:32 <lambdabot>     forall x2 :: T1.
09:38:32 <lambdabot>      h1 (t1 x1 x2) = t1 (h2 x1) (h1 x2)
09:38:38 <nomeata> >free const.fix
09:38:41 <sorear> ?free seq
09:38:43 <lambdabot> f . seq x = seq (g x) . f
09:38:49 <nomeata> ?free const.fix
09:38:49 <lambdabot> Extra stuff at end of line
09:38:55 <nomeata> ?free (const.fix)
09:38:55 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
09:38:56 <emu> > (\f x -> fix ((x:) . (:[]) . map f)) (*2) 1
09:38:57 <lambdabot>    Occurs check: cannot construct the infinite type: b = [b]
09:38:57 <lambdabot>    Expected...
09:39:03 <opqdonut> ?free const . fix
09:39:03 <lambdabot> Extra stuff at end of line
09:39:05 <opqdonut> ok
09:39:33 <emu> iterate f x = fix ((x:) . map f))
09:39:39 <sorear> (+1) . seq undefined is const undefined ; seq (1 : undefined) (+1) is (+1)
09:39:54 <metaperl> take 2 (fix (1:)) -- makes sense to me... but fix (1:) . take 2 -- make no sense
09:39:57 <sorear> thus the free theorums are false for seq and anything defined using it
09:40:19 <sorear> s/anything/somethings/  #fix quantifier
09:40:23 <nomeata> is there a lambdabot feature that takes any expression and re-formatâs it using a lot of fixâes :-)
09:40:42 <sorear> ?pl let x = 1 : x in x
09:40:43 <lambdabot> fix (1 :)
09:41:15 <sorear> ?pl let iterate f z = z : iterate f (f z) in iterate
09:41:17 <lambdabot> fix ((ap (:) .) . ((.) =<<))
09:41:21 <nomeata> ?pl "hi"
09:41:22 <lambdabot> "hi"
09:41:33 <jeremy_c> The Haskell wiki has many tutorials. Can anyone suggest which would be best for someone with 15 years programming experience, but very little (a month or two w/Ocaml) functional language experience?
09:41:44 <nomeata> ?pl \x -> "hi" ++ "huh"
09:41:45 <lambdabot> const "hihuh"
09:41:58 <metaperl> jeremy_c - what is your goal? a lot of people recommend YAHT
09:42:01 <metaperl> ?yaht
09:42:01 <lambdabot> Maybe you meant: fact part yarr
09:42:06 <metaperl> @url yaht
09:42:07 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
09:42:42 <glguy> ?yarr
09:42:43 <lambdabot> Prepare to be boarded!
09:42:51 <glguy> ?yow
09:42:52 <jeremy_c> metaperl: my goal is to learn Haskell to the point of being comfortable writing applications in it, command line tools maybe venture into some web apps via scgi or fcgi.
09:42:52 <lambdabot> My life is a patio of fun!
09:43:23 <metaperl> jeremy_c - i'm studying with SJT's book, but I think "Algorithms" would've been more to the point
09:43:33 <metaperl> jeremy_c - but most people recommend YAHT
09:43:56 <jeremy_c> metaperl: thanks.
09:57:25 <vegai> UTCTime's instance of FormatTime confuses me a bit. Perhaps someone can assist
09:57:37 <vegai> on my prompt, I have utc :: UTCTime
09:58:31 <vegai> Oh! I noticed my mistake already :) missed an argument from my formatTime call
09:58:46 <scodil> getElems will serialize a list of elements to memory, right? but if I (do a <- unsafeFreeze a ; let e = elems a ...) then I can lazily traverse the array? assuming unsafeFreeze is O(1)
09:58:50 <scodil> correct?
10:01:05 <scodil> and does getIndices serialize the list of indices? back when array bounds were immutable, it could have, but now that getBounds has replaced bounds, wouldn't you have to serialize the indices? incase the bounds changed?
10:02:54 <vegai> bringert: Hey. Are you around to talk about Hope?
10:03:30 <bringert> vegai: not for very long unfortunately
10:04:36 <nomeata> hi. Does haskell have a library that, given an image (jpeg, png, gif) gives me the dimensions?
10:05:16 <alexj__> is there a monadic version of the . operator?
10:05:17 <bringert> nomeata: you can use the GD bindings
10:05:39 <bringert> nomeata: you might have to extend them a bit, but that's straightforward
10:05:48 <bringert> @google haskell gd
10:05:51 <lambdabot> http://www.cs.chalmers.se/~bringert/darcs/haskell-gd/doc/
10:05:53 <alexj__> i.e. foo `op` bar = bar <arbitrary number of args> >>= foo
10:06:06 <monochrom> Damn, getElems is very strict indeed.
10:06:10 <nomeata> hmm. notin debian
10:06:11 <vegai> bringert: Ok, then fast. Do you mind if I ste^H^H^Hborrow your Trie from Hope?
10:06:31 <bringert> vegai: not at all. it's BSD licensed.
10:06:31 <vegai> or do you have another suggestion for a blog datatype?
10:06:39 <vegai> right, great
10:06:46 <bringert> what's a blog data type?
10:07:04 <vegai> ehh, ...
10:07:20 * vegai tries to find a way to express something
10:07:32 <monochrom> what is a blog?
10:07:43 <vegai> oy, ...
10:07:55 <vegai> one at a time!
10:08:21 <vegai> Could I call it a Calendar, perhaps?
10:08:47 <vegai> something for storing things (perhaps lots and lots of things) by date
10:09:40 <bringert> vegai: yeah, that's what I used the trie for iirc
10:09:47 <vegai> 'iirc', heh.
10:10:02 <vegai> You haven't touched Hope for awhile?
10:10:10 <monochrom> a map from dates to things?
10:10:18 <bringert> 6 months-ish
10:10:27 <bringert> well, a bit less
10:10:42 <vegai> monochrom: Yes, that could work, but Trie intrigues me
10:11:07 <vegai> I never intend puns, by the way.
10:11:31 <monochrom> Interesting. A blog is a map from dates to things. I wouldn't have thought it up myself.
10:11:43 <vegai> really?
10:11:58 <monochrom> Yes. I have always thought blogs are those fuzzy things.
10:12:28 <rahikkala> I've described an IRC channel as a function from dates to strings once. Well, actually, dates to maybe strings, because we idle a lot there :p
10:12:47 <monochrom> You know, real-world-it's-very-complicated obfuscation.
10:15:26 <ptolomy> Anyone know what the status of the gentoo ghc ebuild for 6.6 is?
10:16:17 <ptolomy> i always recall them being quite quick about getting stuff out unless a horrid conflict exists.
10:18:08 <bringert> ptolomy: I've heard it's messy, but you should ask dcoutts, kosmikus or kolmodin
10:18:21 <rahikkala> Or #gentoo-haskell
10:19:59 <MarcWeber> How can I tell c2hs when inmarhalling to locate memory, write the value to that memory and pass this to the function? (Something like this: alloca $ \mem -> do poke mem 3; print_int_ptr_value mem
10:20:09 <MarcWeber> )
10:33:29 <MarcWeber> data M = M { a :: String , b :: Int }
10:33:31 <MarcWeber> (\m v -> m {b = v})
10:34:35 <MarcWeber> Is there a shorter way defining the second function?
10:36:24 <opqdonut> none come to mind
10:46:01 <Axioplase> Hi !
10:46:12 <tibbe> > let intercalate x = join . intersperse x in intercalate ["good", "evening", "#haskell!"]
10:46:14 <lambdabot>  <[[[Char]]] -> [[Char]]>
10:46:18 <tibbe> eh
10:46:29 <tibbe> > let intercalate x = concat . intersperse x in intercalate " " ["good", "evening", "#haskell!"]
10:46:31 <lambdabot>  "good evening #haskell!"
10:46:41 <tibbe> Axioplase, hi
10:47:01 <Axioplase> I think there's something weird with my ghci... let compress = map head . List.group     :t compress  returns : compress :: [Integer] -> [Integer]
10:47:22 <tibbe> :t List.group
10:47:24 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
10:47:41 <tibbe> :t map head . List.group
10:47:42 <lambdabot> forall a. (Eq a) => [a] -> [a]
10:47:58 <tibbe> hmm yes
10:48:31 <Axioplase> >  let compress = map head . List.group
10:48:32 <lambdabot>  Parse error
10:48:43 <tibbe> hmm, my ghci too
10:49:13 <tibbe> that's odd!
10:49:16 <Axioplase> > let compress = map head . List.group
10:49:17 <lambdabot>  Parse error
10:49:21 <Axioplase> ain't it ?
10:49:32 <tibbe> > let compress = map head . List.group
10:49:33 <lambdabot>  Parse error
10:49:35 <Axioplase> > let compress = map head . group
10:49:36 <lambdabot>  Parse error
10:49:36 <tibbe> yes
10:49:48 <tibbe> and why won't lambdabot except it?
10:49:50 <tibbe> dons, ping
10:50:18 <kpreid> tibbe: because it's an incomplete let expression
10:50:21 <Axioplase> > let compress x = map head . group $x
10:50:22 <lambdabot>  Parse error
10:50:31 <kpreid> @let compress = map head . group
10:50:32 <lambdabot> <local>:2:22:     Ambiguous type variable `a' in the constraint:       `Eq a'...
10:50:36 <alextee> hi
10:50:47 <Axioplase> erf
10:51:01 <Axioplase> kpreid: but the ghci's weird behaviour remains.
10:51:35 <Axioplase> or does my ghci solves the constraint by infering Integer ?
10:52:15 <tibbe> kpreid, but i think it's possible to define functions (like in IO) with lambdabot nowadays
10:52:18 <tibbe> >let a = 1
10:52:18 <kpreid> my ghci 6.4.2 says: head . List.group :: (Eq a) => [a] -> [a]
10:52:25 <tibbe> 6.6 here
10:52:28 <tibbe> > a = 1
10:52:29 <kpreid> tibbe: with @let
10:52:29 <lambdabot>  Parse error
10:52:30 <tibbe> on windows
10:52:31 <kpreid> tibbe: not that way
10:52:33 <tibbe> a
10:52:39 <tibbe> ah
10:52:56 <kpreid> @let x = 1.6231478596795834782364237864
10:52:57 <lambdabot> Defined.
10:53:05 <kpreid> > L.x * pi
10:53:07 <lambdabot>  5.099269391659376
10:53:20 <tibbe> :)
10:53:29 <tibbe> I wonder if this is a 6.6 issue
10:53:50 <Axioplase> 6.4.2 here
10:53:53 <opqdonut> > sin 11
10:53:54 <lambdabot>  -0.9999902065507035
10:54:22 <opqdonut> exp pi - pi
10:54:32 <opqdonut> > exp pi - pi
10:54:33 <lambdabot>  19.999099979189474
10:55:01 <Axioplase> kpreid: that "bug" only happens if I do a let compress = map head .group.  it doens't with let compress x = map head . group $x, not when I type only the body.
10:55:07 <opqdonut> > iterate cos 5
10:55:09 <lambdabot>  [5.0,0.28366218546322625,0.9600369302946615,0.5734897326953653,0.84001268095...
10:55:23 <kpreid> Axioplase: hmmm
10:55:32 <kpreid> Axioplase: that reminds me of the monomorphism restriction
10:55:42 <kpreid> in fact, i bet it is
10:55:52 <kpreid> monomorphism + ghci's enthusiastic defaulting
10:56:11 <kpreid> since compress has no parameters, MMR applies, and it gets defaulted to something
10:56:27 <kpreid> :set -fno-monomorphism-restriction then enter the definition again
10:56:32 <tibbe> kpreid, could you explaing the MMR to me? :)
10:56:37 <opqdonut> > fix cos
10:56:39 <lambdabot>  Exception: <<loop>>
10:56:41 <opqdonut> narh
10:56:56 <kpreid> tibbe: anything defined with no explicit parameters is given a monomorphic type
10:57:04 <kpreid> anything like "x = ..."
10:57:30 <opqdonut> > iterate cos 0.74
10:57:31 <lambdabot>  [0.74,0.7384685587295879,0.7395003246924028,0.7388053915465002,0.73927354164...
10:57:41 <tibbe> kpreid, how come?
10:58:16 <opqdonut> > (iterate cos 0.74!!20) * (160/pi) ^^ (1/13)
10:58:17 <lambdabot>  Add a type signature
10:58:25 <opqdonut> > (iterate cos 0.74!!20) * (160/pi) ^^ (1/13) :: Float
10:58:26 <lambdabot>  Add a type signature
10:58:36 <kpreid> tibbe: the original intent, I understand, was to ensure that when you write 'let x = <big computation> in ... x ... x ...' x will be computed only once
10:58:51 <opqdonut> > (iterate cos 0.74!!20) * (160/pi) ** (1/13) :: Float
10:58:52 <lambdabot>  1.0000001
10:58:55 <opqdonut> \o/
10:59:01 <opqdonut> > (iterate cos 0.74!!20) * (160/pi) ** (1/13) :: Double
10:59:02 <lambdabot>  1.000000134745871
10:59:08 <tibbe> kpreid, hmm, ok
11:00:08 <Axioplase> kpreid: isn't the monomorphic stuff rathre a typing stuff ? so taht one an write let id x = x in (id 1, id (2,3)) ?
11:00:28 <opqdonut> > sin (2017 * (2)**(1/5))
11:00:29 <kpreid> Axioplase: I don't understand what you're asking
11:00:29 <lambdabot>  -1.0
11:00:32 <opqdonut> :D
11:00:34 <opqdonut> > sin (2017 * (2)**(1/5)) :: Double
11:00:35 <lambdabot>  -1.0
11:00:37 <opqdonut> \o/
11:00:43 <kpreid> in that case the restriction does not apply since there is a parameter, x
11:00:43 <opqdonut> ruelage
11:01:25 <Axioplase> kpreid: forget it...
11:01:55 <tibbe> is "modeling" american english and "modelling" british english?
11:02:07 <Cale> > fst . head . dropWhile ((> 1e-9) . abs . snd) . ap zip (ap (zipWith (-)) tail) . iterate cos $ 1
11:02:09 <lambdabot>  0.7390851327392538
11:02:24 <Cale> :)
11:02:29 <Axioplase> kpreid: I'd say it's a matter of generalizing and instatiating rules in the type system, that make that monomorphic bug
11:02:52 <kpreid> I wouldn't
11:03:00 <kpreid> it's an explicit case, not a consequence
11:03:08 <Cale> ap is so handy
11:03:30 <vincenz> Hello
11:03:34 <Cale> hey
11:03:36 <Axioplase> Cale: what module is it in ?
11:03:44 <vincenz> Just came to say happy xmas, flying home tomorrow
11:03:51 <vincenz> Not sure if I'll have access often there
11:03:58 <Cale> Control.Monad, I'm using the instance of monad for ((->) e) which is in Control.Monad.Reader
11:04:49 <Axioplase> I'll read again later about that (->) monad :)
11:04:53 * Cale is asking for Richard Dawkins' new book "The God Delusion" ;)
11:05:13 <vincenz> Cale: good book?
11:05:22 <Cale> seems like it ought to be quite good
11:05:31 <chr1s> Dawkins is pretty rigourous
11:05:54 <Cale> There's a nice video of Dawkins giving some readings from it at a university in Lynchburg, VA.
11:05:56 <cjeris> @karma+ (darwin's rottweiler)
11:05:56 <lambdabot> (darwin's's karma raised to 1.
11:05:58 <chr1s> he not only is against religion, he actively wants to rule it out
11:06:12 <vincenz> that's bad
11:06:13 <cjeris> grrr
11:06:35 <vincenz> ?
11:07:00 <Cale> While that view doesn't completely align with mine, I can see lots of good reasons for ruling out most of the really popular religions.
11:07:04 <vincenz> I use to be quite strongly slanted against religion but I have learned that religion has its value and purpose and that being very strongly against religion is religious in itself
11:07:19 <vincenz> That said, I'm very much antitheistic :)
11:07:31 <chr1s> yes, I agree
11:07:54 <vincenz> But religion gives people hope, and a reason to be moral and ethical
11:07:56 <Cale> Saying that there absolutely could not be a god is religious, but saying that it's ridiculously improbable is okay with me :)
11:08:06 <Cale> vincenz: oh?
11:08:11 <Cale> vincenz: read the Bible lately?
11:08:19 <vincenz> Cale: You're concretising too much
11:08:30 <chr1s> I agree with you Cale.
11:08:38 <vincenz> There's more to religion that the dogmas, the writings and the theism
11:08:59 <vincenz> It brings people together
11:09:05 <vincenz> And instills moral values
11:09:18 <Cale> vincenz: why not strip away all the useless stuff an leave only the reasonable stuff then? Bringing people together is good, telling them that genocide is okay is not.
11:09:26 <chr1s> yes, the basic idea behind religion is very good
11:09:28 <vincenz> Cale: Cause most people are too ignorant to swallow it
11:09:33 <complacent> anyone installed lhs2TeX on macosx?
11:09:38 <vincenz> They need all the sugar around it
11:09:41 <Cale> I don't think that religions really instill any moral values which aren't already there.
11:09:55 <Cale> after all, most atheists are pretty moral people.
11:09:58 <vincenz> Cale: I used to think liek you but have very much tempered my thoughts
11:10:12 <vincenz> I will read your book, however :)
11:10:13 <Philippa_> I think they can strongly reinforce values that might have shifted in a different direction
11:10:26 <mbishop> I think this has nothing to do with haskell
11:10:27 * mbishop runs
11:10:37 <Philippa_> bear in mind that 'moral values' tends to mean more than "don't kill people, try not to hurt people"
11:10:38 <chr1s> the bishop is gone?
11:10:47 <velco> what do moral values have to do with religion?
11:10:59 <velco> religion is a people management approach.
11:11:04 <chr1s> well, they should have to do a lot with religion
11:11:30 <chr1s> I think if you don't take the bible too literally, it's a good book on how to live
11:11:38 <vincenz> Not only that, I think that religion a) inspiries people to do nobler things (and trust me, I am very much slanted against the church as you re), b) tend to bring people together so they can perform bigger deeds, c) help reinforce values of humanity
11:11:45 <Cale> complacent: I think I did a long time ago, but I couldn't tell you much about it now.
11:12:23 <tibbe> please take it to #haskell-blah :)
11:12:45 <vincenz> Move to #oasis :)
11:13:27 * araujo doesn't believe at religions
11:13:28 <complacent> Cale : in other unix os's u got problems with ghc-6.6 ? -> ghc-6.6: unknown package: lang
11:14:26 <complacent> when i exec configura it gives me a err msg complaining about "ghc-6.6: unknown package: lang"
11:14:30 <Cale> complacent: this was long before ghc6.6, I'm afraid
11:14:35 <Cale> complacent: oh, hmm
11:14:46 <Cale> complacent: is there a cabal file?
11:15:10 <complacent> "cabal file" ?
11:15:30 <Cale> *.cabal
11:15:31 <kosmikus> complacent: I know people who have it installed on MacOSX
11:15:44 <complacent> yes Cale there is
11:15:45 <kosmikus> Cale: 1.11 has a .cabal file, but it doesn't work ...
11:15:56 <kosmikus> complacent: so what's the problem?
11:16:10 <complacent> i'll paste
11:16:11 <Cale> complacent: look in there and try removing the lang package from the list
11:16:25 <Cale> (there will probably be a list of packages)
11:16:30 <kosmikus> yes, if it's just the -package lang, you should remove it from the Makefile
11:16:41 <complacent> /opt/local/bin/ghc -O -package lang --make -o lhs2TeX Main.lhs TeXCommands.lhs TeXParser.lhs Typewriter.lhs Math.lhs MathPoly.lhs MathCommon.lhs NewCode.lhs Directives.lhs HsLexer.lhs FileNameUtils.lhs Parser.lhs FiniteMap.lhs Auxiliaries.lhs StateT.lhs Document.lhs Verbatim.lhs Value.lhs Version.lhs
11:16:41 <complacent> ghc-6.6: unknown package: lang
11:16:41 <complacent> make: *** [lhs2TeX] Error 1
11:17:21 <kosmikus> as I said, find "-package lang" in the Makefile and remove it
11:17:46 <kosmikus> complacent: it's actually in config.mk
11:17:58 <kosmikus> look for GHCFLAGS
11:18:42 <complacent> comments are # right ?
11:18:59 <PupenoR> [OT] How would you call a module that adds users and groups (capabilities to handle them) to a system ?
11:19:35 <vegai> What's all this then... the docs show that Data.Time.Clock.UTCTime is an instance of Show, but when I try to derive Show in my datatype that uses it, I get...
11:19:47 <vegai> "No instance for (Show UTCTime)"
11:20:36 <complacent> kosmikus : in config.mk i've commented the line of GHCFLAGS & still don't work
11:21:08 <kosmikus> complacent: have you run configure again?
11:21:16 <kosmikus> if yes, it overwrites config.mk
11:21:25 <vegai> outdated docs, I guess
11:22:09 <complacent> \o/ ty
11:22:14 <complacent> kosmikus : yes i did that
11:22:32 <kosmikus> complacent: so better change config.mk.in if you plan to rerun configure
11:24:46 <complacent> kosmikus : yes i want. tnks 4 u help
11:24:57 <complacent> it's working
11:24:59 <kosmikus> great
11:25:02 <kosmikus> sorry for the trouble
11:25:22 <Igloo> vegai: The instance is in Data.Time.LocalTime
11:27:15 <glguy> I wrote the text generator that ptolomy was assigned for homework, and ran it on Dante's Divine Trilogy... it comes up with some interesting sentences
11:27:24 <[d-_-b]> in haskell code what '$' does??
11:27:48 <glguy> $ has the lowest precedence, so it evaluates the right side and left side first
11:27:52 <integral> f $ x = f x,  but $ has a lower precedence than juxtaposition.
11:28:01 <glguy> and the uses the right side as an argument to the left
11:28:29 <glguy> f $ g x -> f (g x),       f g x -> (f g) x
11:29:00 <glguy> a b $ c d -> (a b) (c d)
11:29:08 <vegai> Igloo: Ohh, thanks.
11:29:09 <monochrom> glguy: any fun examples?
11:29:26 <vegai> Igloo: I suppose there's no Read instance around there?
11:29:36 <vegai> well, the docs don't even promise that, so...
11:29:40 <glguy> flood with crimson stain. o thou who art wise better my meaning knowst than i am bertrand he of born who gave the pharisees counsel that it no pause obtaind and following came another from whose cheek the beard sweeps oer his shoulders broa
11:29:45 <glguy> d already vested with that planets beam who leads all wanderers safe through eve
11:29:48 <glguy> ry way. then was a little stretching forth my hand inclining answerd sir brunett
11:29:51 <glguy> o and inquire who are partners in his feet. canto xvii lo the fell as one undaun
11:29:59 <opqdonut> :S
11:30:49 * monochrom wonders what would happen if the algorithm were applied to YAHT
11:31:14 <glguy> it's a pretty simple algorithm... so I doubt that it would make any more sense than that did
11:31:18 <glguy> :)
11:32:18 <cjeris> glguy: http://thedailywtf.com/forums/thread/104727.aspx -- in the 'amusing text generator' department
11:32:20 <lambdabot> Title: The Daily WTF - No, We Need a Neural Network
11:32:45 <glguy> Oh yeah :) I stumbled across that one earlier
11:33:16 <glguy> I liked the dailywtf when the postings were short code snippets... I don't care for reading through the long stories
11:33:49 <glguy> like the VB function that took arguments a-z, aa-zz, aaa-zzz and summed them all up
11:34:04 <glguy> programmers would put 0s in the fields they didn't want to use
11:34:08 * cjeris wanted to find the person responsible for that one and kill them
11:35:55 <glguy> > let addem a b c d e f g h i j k l m n o p q r s t u v w x y z = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q + r + s + t + u + v + w + x + y + z in addem 1 3 7 10 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
11:35:56 <lambdabot>  21
11:38:18 <glguy> ?type let addem a b c d e f g h i j k l m n o p q r s t u v w x y z = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q + r + s + t + u + v + w + x + y + z in addem
11:38:19 <lambdabot> forall a. (Num a) => -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a
11:39:29 <cjeris> oink?
11:39:34 <cjeris> what's that lone -> doing out front?
11:39:54 <dylan> hmm, how can I make a forkIO thread sleep for a bit?
11:41:21 <Cale> cjeris: probably a bug in lambdabot's parsing of ghci's output.
11:42:21 <glguy> ?pl \ a b c d e f g h i j k l m n o p q r s t u v w x y z -> a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q + r + s + t + u + v + w + x + y + z
11:42:27 <lambdabot> (((((((((((((((((((((((((+) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) . ((((((((((((((((((((((((+) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .
11:42:28 <lambdabot>  (((((((((((((((((((((((+) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) . ((((((((((((((((((((((+) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) . ((((((((((((((
11:42:28 <lambdabot> (((((((+) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) . ((((((((((((((((((((+) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) . (((((((((((((((((((+) .) .) .) .) .) .) .) .)
11:42:28 <lambdabot>  .) .) .) .) .) .) .) .) .) .) . ((((((((((((((((((+) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) . (((((((((((((((((+) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) . ((((((((((((((((+) .)
11:42:30 <lambdabot> .) .) .) .) .) .) .) .) .) .) .) .) .) .) . (((((((((((((((+) .) .) .) .) .) .) .) .) .) .) .) .) .) .) . ((((((((((((((+) .) .) .) .) .) .) .) .) .) .) .) .) .) . (((((((((((((+) .) .) .) .) .) .) .
11:42:33 <lambdabot> ) .) .) .) .) .) . ((((((((((((+) .) .) .) .) .) .) .) .) .) .) .) . (((((((((((+) .) .) .) .) .) .) .) .) .) .) . ((((((((((+) .) .) .) .) .) .) .) .) .) . (((((((((+) .) .) .) .) .) .) .) .) . ((((
11:42:36 <lambdabot> ((((+) .) .) .) .) .) .) .) . (((((((+) .) .) .) .) .) .) . ((((((+) .) .) .) .) .) . (((((+) .) .) .) .) . ((((+) .) .) .) . (((+) .) .) . ((+) .) . (+)
11:42:38 <Cale> ahah
11:42:40 <glguy> Umm, ?
11:42:40 <lambdabot> optimization suspended, use @pl-resume to continue.
11:42:48 <glguy> Why did it print so much before suspending?
11:43:44 * monochrom eyes come out
11:45:35 <vincenz> SPAMMERS!
11:45:43 <vegai> Would it be bad if a Map or a Trie had largishs strings as keys?
11:45:54 <vincenz> glguy: use privmsg?
11:45:59 <vegai> or is it rather irrelevant?
11:46:11 <glguy> vincenz: that wasn't my fault, actually
11:46:13 <dylan> @hoogle Handle -> IO Fd
11:46:14 <lambdabot> No matches, try a more general search
11:46:16 <dylan> @hoogle Handle -> IO Int
11:46:17 <lambdabot> System.IO.hGetBuf :: Handle -> Ptr a -> Int -> IO Int
11:46:18 <lambdabot> System.IO.hGetBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int
11:46:18 <lambdabot> System.IO.hPutBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int
11:46:26 <dylan> hmm.
11:48:52 <vegai> I'm a bit worried about data migrations and HAppS
11:49:00 * wolverian rewires his brain to tackle inductive graphs
11:49:24 <vegai> in that with its serialization style, every time I make a change to my State, all my old data becomes obsolete
11:49:27 <vegai> (right?)
11:50:01 <glguy> vegai: if you write your state object without versioning, yes
11:50:26 <glguy> or your serializer without versioning, rather
11:50:40 <vegai> Ah, indeed.
11:52:24 <vegai> ohh, bringert to the rescue again (regarding Read instances for many things Data.Time.*): http://article.gmane.org/gmane.comp.lang.haskell.libraries/5706
11:52:26 <lambdabot> Title: Gmane -- Mail To News And Back Again
11:58:29 <glguy> ?seen Cale
11:58:31 <lambdabot> Cale is in #ghc, #oasis, #haskell and #haskell-blah. I last heard Cale speak 17s ago.
11:58:41 <vincenz> >>= #oasis
11:58:44 <glguy> Cale: ?seen http://programming.reddit.com/info/vebh/comments?
11:58:46 <lambdabot> Title: A rewrite in Scheme of a simple 50-line Haskell RSS aggregator (reddit.com)
11:59:56 <dylan> so, I should use forkOS to create a thread that is going to call a bunch of possibly-blocking C functions, right?
12:07:36 <wolverian> if I want to look up nodes by labels without changing completely to a map instead of a graph, do I need to maintain my own map if I want to be efficient, or am I missing something in D.G.Inductive? what would the best method be here?
12:08:46 <wolverian> to put it another way: I need to look up relationships by keys, and find such paths between keys.
12:12:20 <nomeata> Iâm trying to parse all <img> urls from html. I have this parser for part of the actual tag:
12:12:22 <nomeata> src = string "<img src=\"" >> manyTill anyChar (char '"')
12:12:44 <nomeata> But what parser, based upon this, just returns a list of all possible matche of this?
12:13:22 <nomeata> There seems to be no skipTill, which might help me here.
12:13:28 <nomeata> (Thi is with Parsec)
12:13:55 <glguy> nomeata: you ought to read Cale's RSS aggregator example, and see if you can't do what you want more cleanly in HXT
12:14:22 <Saizan> well not all html is xml
12:14:32 <glguy> Saizan: fortunately, that doesnt' matter with HXT :)
12:14:33 <glguy> http://cale.yi.org/index.php/HRSS
12:14:35 <lambdabot> Title: HRSS - CaleWiki
12:15:05 <nomeata> Iâll look at that, but Iâd also like to hear how to do that with parsec.
12:15:13 <Saizan> really? it parses even malformed documents?
12:15:35 <glguy> one of the lines from cale's program: Ca
12:15:47 <glguy>     runX $ root [] [catA . map (readDocument [(a_validate, v_0)]) $ srcs]
12:16:05 <glguy> (a_validate, v_0) is a flag turning off validation
12:16:38 <Saizan> nice
12:18:09 <nomeata> I think I got it:
12:18:15 <nomeata> image = src <|> (anyChar >> image)
12:18:15 <nomeata> images = many1 image
12:19:18 <nomeata> that gets all of them, but fails if the input does not end with a complete "src"
12:19:32 <Saizan> @hoogle skipMany
12:19:33 <lambdabot> Text.ParserCombinators.ReadP.skipMany :: ReadP a -> ReadP ()
12:19:33 <lambdabot> Text.ParserCombinators.Parsec.Prim.skipMany :: GenParser tok st a -> GenParser tok st ()
12:19:33 <lambdabot> Text.ParserCombinators.ReadP.skipMany1 :: ReadP a -> ReadP ()
12:21:19 <nomeata> the problem is: what should I skip?
12:21:50 <nomeata> (I could skip everything but a <, and then see if that is a start of a <img, but that seems to be unelegant)
12:22:05 <glguy> I think that the problem is that you are pulling src's directly out of the elements, instead of parsing the elements and then askign for the src attributes
12:22:30 <nomeata> sure, but shoudnât that make the problem easier, instead of harder?
12:22:44 <glguy> trying to take a shortcut?
12:22:47 <nomeata> yes
12:24:01 <glguy> the quick and dirty way can get pretty dirty I think
12:24:45 <nomeata> :-(
12:25:04 * nomeata feels a bit disappointed by parsec then.
12:25:38 <glguy> it's not parsec's fault that the grammar is complicated
12:25:45 <notsmack> eh, the problem isn't parsec, it's that you don't know exactly what to tell it to parse
12:26:38 <nomeata> ^.*?(<img src="[^"]+".*?).*?$
12:26:45 <nomeata> ^.*?(<img src="[^"]+".*?)*.*?$ actually
12:27:14 <nomeata> I have a clear picture of what I wont, but I just started using parsec.
12:27:54 <nomeata> And I hardly would call the grammer compilcated. Maybe not structured enough.
12:28:36 <notsmack> seems like it'd be easier with hxt, /and/ you'd hit all the cases you'll miss with that regex
12:29:07 <Saizan> won't images = many1 image <|> skipMany anyChar be enough?
12:29:36 <Saizan> not <|>
12:29:41 <Saizan> >>
12:30:23 <nomeata> that eats all the input when image fails once
12:30:48 <Saizan> images = many1 image >> skipMany anyChar <-- why?
12:32:24 <nomeata> images = do {i <- src; is <- images; return (i:is)} <|> (anyChar >> images) <|> (eof >> return [])
12:33:24 * nomeata g2g, sorry
12:33:31 <nomeata> and thanks for the hints!
12:40:57 <glguy> > let intercalate = (concat .) . intersperse in intercalate ' ' ['a'..'z']
12:40:58 <lambdabot>  Couldn't match `[a]' against `Char'
12:41:08 <glguy> > let intercalate = (concat .) . intersperse in intersperse ' ' ['a'..'z']
12:41:09 <lambdabot>  "a b c d e f g h i j k l m n o p q r s t u v w x y z"
12:41:32 <Spark> @type .
12:41:34 <lambdabot> parse error on input `.'
12:41:47 <glguy> > let intercalate = (concat .) . intersperse in intercalate " + " ['a'..'z']
12:41:48 <lambdabot>  Couldn't match `[Char]' against `Char'
12:42:02 <glguy> > let intercalate = (concat .) . intersperse in intercalate " + " $ map return ['a'..'z']
12:42:03 <lambdabot>  "a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q + r + s +...
12:42:36 <glguy> :t (.)
12:42:36 <Spark> > zip [' '..] ['a'..'z']
12:42:37 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
12:42:38 <lambdabot>  [(' ','a'),('!','b'),('"','c'),('#','d'),('$','e'),('%','f'),('&','g'),('\''...
12:42:43 <Spark> heh
12:42:53 <Spark> > zip [' ',' ',..] ['a'..'z']
12:42:53 <lambdabot>  Parse error
12:42:57 <Spark> > zip [' ',' '..] ['a'..'z']
12:42:59 <lambdabot>  [(' ','a'),(' ','b'),(' ','c'),(' ','d'),(' ','e'),(' ','f'),(' ','g'),(' ',...
12:43:14 <jeremy_c> Why does Emacs indent module Main \n where \n\n import IO .... so that import IO is indented 8 spaces? That doesn't compile. Am I missing something?
12:43:15 <glguy> > map ((,)' ') ['a'..'f']
12:43:16 <lambdabot>  [(' ','a'),(' ','b'),(' ','c'),(' ','d'),(' ','e'),(' ','f')]
12:43:41 <glguy> jeremy_c: emacs is wrong, main should be set against the left margin
12:43:50 <glguy> same with import
12:44:13 <glguy> (import can be spaced if you want, but typically it's not)
12:44:52 <jeremy_c> module Main is flush left. where is indented 4 spaces, then a blank line, then import IO is indented 8 spaces.
12:45:06 <glguy> import is first
12:45:08 <glguy> then main
12:45:15 <glguy> OH
12:45:16 <glguy> duh
12:45:25 <jeremy_c> hm, the Yet Another Haskell Tutorial didn't do it in that order.
12:45:29 <glguy> sorry, misread
12:45:40 <glguy> jeremy_c: link to where you are?
12:46:04 <lisppaste2> jeremy_c pasted "Indentation for emacs" at http://paste.lisp.org/display/32952
12:46:32 <jeremy_c> glguy: http://darcs.haskell.org/yaht/yaht.pdf  ... page 32
12:46:47 <glguy> jeremy_c: import isn't supposed to be indented like that
12:47:12 <jeremy_c> using tab key, or reformat buffer, that's where emacs always indents it. I'm wondering why emacs is doing that to me.
12:47:25 * glguy doesn't believe in "emacs" (=
12:47:37 <jeremy_c> glguy: what do you believe in?
12:47:38 <glguy> jeremy_c: try not including the module Main where
12:47:44 <glguy> jeremy_c: that is optional on modern compilers
12:47:52 <glguy> and see if that fixes your emacs isue
12:47:54 <glguy> issue*
12:48:06 <glguy> jeremy_c: I use ViM and Visual Haskell, but that doesn't mean you need to
12:48:25 <jeremy_c> glguy: nope, import still indents 8 spaces.
12:48:58 <glguy> I don't know enough about emacs to know if that's an emacs bug , or if you are somehow doing something wrong in emacs...
12:49:33 <jeremy_c> glguy: I love vim's navigation, and composition of keystrokes, like dt, c$ but really like emacs indentation.
12:53:27 <abz> glguy: wrt emacs, I've come arocss things like for its indentation before.
12:54:15 <Excedrin> does the paper, "An Approach to Fast Arrays in Haskell" still apply to GHC 6.6?
12:54:28 <glguy> What approach does it present? (=
12:55:17 <lightstep> http://haskell.org/haskellwiki/Modern_array_libraries
12:55:18 <lambdabot> Title: Modern array libraries - HaskellWiki
12:55:42 <abz> I think you should look at the M-x untabify
12:55:53 <jeremy_c> abz: there are no tabs anywhere.
12:56:40 <jeremy_c> hm, however, that fixed it. weird.
12:57:40 <Excedrin> lightstep: thanks
12:57:56 <lightstep> i think it doesn't speak of parr and 6.6
12:58:09 <abz> if you do a less on a .hs file written in xemacs, you'll see the funny xemacs indentation.
12:58:22 <abz> wrt spaces and tabs
12:58:33 <Excedrin> Bulat's emails confuse me
13:11:35 <dmead> yay
13:11:37 <dmead> 300
13:11:38 <dmead> is me
13:11:39 <dmead> !
13:11:59 <glguy> English can be a tough language...
13:12:46 <glguy> "the winner, it's you"
13:12:53 <bd_> @hoogle threadWaitRead
13:12:54 <lambdabot> Control.Concurrent.threadWaitRead :: Fd -> IO ()
13:13:17 <dmead> i am the winnar!
13:13:19 <dmead> !
13:13:41 * glguy takes dmead's '!' key away.
13:14:57 <dmead> :<
13:15:11 <glguy> I think your nose is touching your eye...
13:15:25 <thelsdj> that looks like cthulu
13:15:37 <glguy> (:[])
13:16:24 <dmead> hmm haskell emotes
13:16:32 <dmead> > o:[]
13:16:33 <lambdabot>  Not in scope: `o'
13:16:44 <dmead> > <:[]
13:16:45 <lambdabot>  Parse error
13:17:14 <Tanuk-> glguy: Please, make the comment-eating robot eat a comment again!
13:17:19 <glguy> lol
13:17:22 <glguy> ?quote SamB_XP
13:17:23 <lambdabot>  oh. does A/S/L mean Age/Sex/Programming Language?
13:17:24 <glguy> ?quote SamB_XP
13:17:25 <lambdabot>  oh. does A/S/L mean Age/Sex/Programming Language?
13:17:26 <glguy> ?quote SamB_XP
13:17:27 <lambdabot>  oh. does A/S/L mean Age/Sex/Programming Language?
13:17:29 <glguy> :(
13:17:34 <bacek> :))
13:17:35 <glguy> it's in there somewhere :)
13:17:47 <SamB_XP> heh
13:17:55 <glguy> ?quote SamB_XP
13:17:55 <lambdabot>  oh. does A/S/L mean Age/Sex/Programming Language?
13:17:57 <glguy> last time ^
13:18:00 <glguy> hmm
13:18:37 <glguy> 15:15 glguy> ?quote SamB_XP
13:18:38 <glguy> 15:15 lambdabot>  I once saw it eat a comment (:[{- Help! -}])[1~
13:18:56 <glguy> of course the first time that I ask lambdabot in PM, ti works
13:19:20 <Tanuk-> Thank you!
13:19:56 <glguy> emoticons that type-check
13:22:20 <bd_> @hoogle Ptr a -> IO a
13:22:21 <lambdabot> No matches, try a more general search
13:23:07 <lightstep> ?hoogle peek
13:23:08 <lambdabot> Foreign.Storable.peek :: Storable a => Ptr a -> IO a
13:23:08 <lambdabot> Foreign.Storable.peekByteOff :: Storable a => Ptr b -> Int -> IO a
13:23:08 <lambdabot> Foreign.Storable.peekElemOff :: Storable a => Ptr a -> Int -> IO a
13:23:31 <lightstep> hmm, does hoogle even look at the types?
13:24:05 <bd_> @hoogle Storable a => Ptr a -> IO a
13:24:06 <lambdabot> Foreign.Storable.peek :: Storable a => Ptr a -> IO a
13:24:06 <lambdabot> Foreign.Storable.peekElemOff :: Storable a => Ptr a -> Int -> IO a
13:24:06 <lambdabot> Foreign.Storable.peekByteOff :: Storable a => Ptr b -> Int -> IO a
13:24:10 <bd_> there we go :)
13:25:11 <lightstep> maybe we can combine djinn and hoodle
13:35:59 <jeremy_c> I'm not a big fan of this emacs indenting for haskell. Is there only one mode for haskell and emacs?
13:37:41 <allbery_b> afaik but there are several versions of it (I haven't tried to load the current one into my xemacs at work, which has an ancient buggy one)
13:38:14 <cjeris> jeremy_c: have you tried reducing haskell-indent-offset ?
13:38:25 <Taral> jeremy_c: You can switch to vim :)
13:38:50 * allbery_b also thinks haskell-mode should (setq indent-tabs-mode nil) unless told otherwise...
13:39:12 <jeremy_c> Taral: I use too much of emacs to do that. Things I do in emacs I cannot do in Vim, that I know of.
13:39:18 <Taral> Heh.
13:39:52 <allbery_b> you'd be surprised, I think.  (that said I find I prefer mostly-modeless editors for programming)
13:39:57 <kosmikus> any lhs2tex users around?
13:40:49 <jeremy_c> Taral: allbery_b: For instance, I manage my entire life, tasks, schedule in Emacs Org mode which has calendaring, reminders, agenda, etc...
13:41:35 <Taral> jeremy_c: *nod*
13:41:39 <jeremy_c> Taral: in an instant, I can tell what tasks are outstanding for client a, b, or more importantly, my boss. I can see what's on today's, tomorrow, next weeks schedule, I check into tasks to record time on them, etc...
13:41:43 <Taral> I was only kind of serious.
13:41:51 <Taral> I know some people actually use emacs for all of its power.
13:41:53 <cjeris> allbery_b: actually you should have (setq-default indent-tabs-mode nil) in your .emacs :)
13:41:58 * allbery_b uses a Tungsten T3 for that; don't have anything that I can carry in my pocket that runs emacs (or vim) :)
13:42:31 <jeremy_c> Taral: I love vim's command mode. I really wish emacs had the same. I've managed to make quite a few of my favorite commands on vim into elisp functions, but it's still not the same.
13:42:38 <Taral> :D
13:42:45 <SamB_XP> its kind of hard to use emacs on a palmtop anyway
13:42:46 <jeremy_c> cjeris: I have that as well.
13:42:55 <Taral> SamB: It's hard to use vim on a palmtop too.
13:43:26 <cjeris> jeremy_c: what exactly does it indent wrong?
13:43:33 <jeremy_c> I got rid of  my palmtop, I use a combination of 3x5 index cards, and my cell phone via bluetooth for reminders and address book.
13:43:46 <SamB_XP> I mean, those tiny buttons... there is no way to hold down C-, M- and/or shift...
13:44:10 <jeremy_c> cjeris: seems like everything I try :-)  http://darcs.haskell.org/yaht/yaht.pdf ... pg 33. I cannot get my copy of it to look anything like that.
13:44:19 <Taral> @hoogle ReadMode
13:44:20 <lambdabot> System.IO.ReadMode :: IOMode
13:44:50 <jeremy_c> cjeris: then seems like when I hit enter, I have to "outdent" 90% of my code, it indents 4 chars every enter.
13:46:30 <jeremy_c> if guessNum < num\nthen ... I cannot get then to indent 4 chars below the if. When I compile, I get errors: "possibly incorrect indentation".
13:46:47 <glguy> jeremy_c: paste what you have here
13:46:48 <glguy> ?paste
13:46:56 <lambdabot> http://paste.lisp.org/new/haskell
13:48:02 <glguy> jeremy_c: if emacs is using tabs that could break things
13:48:27 <lisppaste2> jeremy_c pasted "More indenting probs" at http://paste.lisp.org/display/32958
13:49:04 <glguy> jeremy_c: you can't line then and else up with if
13:49:09 <glguy> you have to indent the then and else
13:49:19 <jeremy_c> glguy: I know. But emacs will not do it.
13:49:29 <glguy> jeremy_c: then don't use emacs
13:49:41 <kosmikus> why not? just press the space bar will surely work.
13:49:45 * SamB_XP thinks a better idea is to fix Haskell
13:49:46 <jeremy_c> My problem right now is not with haskell, but with the emacs mode.
13:50:08 <glguy> (if ... then .. else ...) is one expression ... no sense in special casing it in :(
13:50:09 <kosmikus> SamB_XP: it'll probably be fixed in Haskell'
13:50:13 <jeremy_c> kosmikus: sure, I can do that, but it would be best to make emacs work right, then I dont have to worry about things like that.
13:50:28 <kosmikus> jeremy_c: feel free to update the Haskell mode
13:50:56 <jeremy_c> kosmikus: I'm brand new to Haskell, just trying to learn, I don't even totally understand then indentation scheme myself yet. I'm just trying to learn it.
13:51:10 <kosmikus> jeremy_c: :)
13:51:30 <kosmikus> jeremy_c: but maybe you're a better emacs-lisp programmer than most Haskellers ...
13:51:31 <allbery_b> and how are you at elisp? :)
13:51:59 * allbery_b is not too shabby at elisp but had trouble getting darcs haskell-mode to work with xemacs... until he upgraded it
13:52:03 <jeremy_c> allbery_b: ok, no pro. Lots of people in #emacs run circles around me with their eyes closed.
13:52:06 <Excedrin> http://fawcett.blogspot.com/2006/12/haskell-rss-aggregator-chicken-haskell.html
13:52:09 <lambdabot> Title: more blog than sense: Haskell + RSS Aggregator + Chicken &minus; Haskell..., http://tinyurl.com/y3mfut
13:52:19 <allbery_b> (and it still falls over with emacs-desktop but I'm not sure that's easily fixable)
13:52:47 <glguy> Excedrin: find that on prog.reddit?
13:55:19 <Excedrin> glguy: yea, just read your comments
13:55:52 <glguy> did you remmember to mod me up? ;)
13:56:10 <Taral> AHA!
13:56:20 * allbery_b wonmders if he should re-add reddit
13:56:21 <Taral> I know why XML combinators use arrows.
13:56:29 <glguy> do tell
13:56:31 <monochrom> why?
13:56:44 <Taral> because arrows can handle the concept of parallel computations
13:57:01 <Taral> monads want to sequence everything
13:57:22 <Taral> in other words, monads enforce a total order of computations, arrows permit a directed graph of computations.
13:57:23 <glguy> so you are sold now?
13:57:26 <Taral> yes.
13:57:30 <monochrom> That's news, because stateful XML combinators cannot be too parallel.
13:58:00 <glguy> you could do these two things in parallel: find 'a' elements, find 'b' elements
13:58:38 <monochrom> could, but the actual library doesn't do that yet.  it still sequences, i.e., &&& and *** are still sequential, not very symmetric.
13:58:41 <Taral> you can do it all with monads, but you have to build a bunch of arrow-like combinators.
13:58:58 <Taral> monochrom: Yes, that's true. But the overlying code exposes the parallelism.
13:59:10 <Taral> You could, for example, use `par` in your definition of (***)
13:59:47 <monochrom> OK, I love arrows, even if they are arrowapps, so why am I arguing? :)
14:00:48 <monochrom> I prefer arrows because they are a dataflow language.
14:01:30 <fabiim> foo (x::Int) = div (x-10) 2  ; How can i get this to be of type : Float ?
14:01:41 <glguy> fromIntegral
14:01:56 <Taral> = div (fromIntegral $ x - 10) 2
14:02:01 <fabiim> oh , i was trying fromInteger ...
14:02:11 <glguy> Taral: no?
14:02:15 <monochrom> or fromIntegral (div (x-10) 2)
14:02:18 <Taral> fromIntegral = fromInteger . toInteger
14:02:28 <Taral> glguy: Yes.
14:02:44 <glguy> Taral: that's not what he wanted, is what I mean
14:03:00 <glguy> x is an Int, the result needs to be a float
14:03:02 <monochrom> fromIntegral is preferred as the catch-all Integral-to-Num coercer.
14:03:22 <Taral> glguy: But do you want Int's div or Float's div?
14:03:23 <glguy> foo (x::Int) = fromIntegral (div (x-10) 2)
14:03:27 <glguy> ?type div
14:03:29 <Taral> oh, wait
14:03:29 <lambdabot> forall a. (Integral a) => a -> a -> a
14:03:36 <Taral> ok, you're right.
14:03:42 <Taral> ?type (/)
14:03:43 <lambdabot> forall a. (Fractional a) => a -> a -> a
14:03:56 <monochrom> Most compilers include code optimizations to translate each individual fromIntegral to the most direct code.
14:04:22 <glguy> ?type let foo :: Int -> Float; foo x = fromIntegral $ (x-10) `div` 2 in foo
14:04:23 <lambdabot> Int -> Float; foo x = fromIntegral $ (x-10) `div` 2 in foo :: Int -> Float
14:04:44 <SamB_XP> of course, GHC also spews about ties when it does this
14:04:48 <glguy> (yeah, I know I said it explicitly, but I let lambdabot verify it)
14:05:03 <Taral> doesn't ghc support parallel build yet?
14:05:17 <SamB_XP> somebody got it to work
14:05:24 <Taral> but it's not standard
14:05:28 <SamB_XP> but maybe they didn't think it was good enough for users yet?
14:05:32 <dons> moin
14:05:35 <dons> ?users
14:05:35 <lambdabot> Maximum users seen in #haskell: 309, currently: 299 (96.8%), active: 52 (17.4%)
14:05:38 <SamB_XP> or maybe it was a real mess
14:05:40 <dons> hehe nice
14:06:48 <kosmikus> dons: would you mind testing lhs2tex-1.12pre1 for me?
14:08:05 <glguy> fabiim: unless you didn't want integer division, then: (fromIntegral x - 10) / 2
14:09:00 <monochrom> yeah dons built ghc in 10 minutes by multiple hardcore.
14:09:18 <glguy> how many processors did that take?
14:09:25 <monochrom> 8
14:09:35 <glguy> and it only took 10 minutes??
14:09:36 <glguy> wow
14:09:41 <hyrax42> 10 minutes
14:09:43 <hyrax42> :(
14:09:45 <hyrax42> takes me 6 hours
14:10:01 <fabiim> that's what i wanted , thanks
14:10:03 <monochrom> recall it takes 80 minutes for most people, single core
14:10:25 <fabiim> are you guy's serious? it takes 6 hours to compile?
14:10:40 <monochrom> speaking of which, I need to waste my computer building HOL.
14:10:42 <dons> kosmikus: sure. url?
14:10:59 <hyrax42> fabiim: on a G4 iBook, using darwinports
14:11:06 <kosmikus> @where lhs2tex
14:11:06 <hyrax42> ghc is an overnighter for *sure*
14:11:06 <lambdabot> http://www.cs.uu.nl/~andres/lhs2tex
14:11:11 <dons> fabiim: it takes 7 minutes :)
14:11:16 <dons> but you might need modern hardware
14:11:34 <monochrom> well ibook is a bit slow.
14:11:35 <dons> kosmikus: ok. cheers
14:11:39 <glguy> *a lot* of modern hardware ;)
14:11:42 <fabiim> lol
14:11:43 <hyrax42> ibook is more than a bit slow
14:11:49 <nmessenger> "for sufficiently crazy values of 'modern'"
14:11:56 <dons> it was a 4 core, hyper threaded linux box
14:11:58 <dons> so not too magic
14:12:30 <monochrom> You need large cache and the latest hard disk interface.  it's both memory and I/O bound.
14:12:54 <dons> yeah. i'm sure that hep
14:12:55 <kosmikus> dons: it's particularly interesting if Cabal installation works for you
14:12:56 <dons> lps
14:12:59 <dons> kosmikus: ok
14:13:03 <monochrom> A desktop computer bought in 2006 should be ok.
14:13:28 * glguy only has his old 3ghz single core p4
14:13:41 <monochrom> laptops will look slow for building ghc because of compromises in cache and bus.
14:13:47 <glguy> (and a slow g4 powerbook)
14:14:00 * hyrax42 has one (1) iBook G4 1.33 GHz and one (1) 2.2 GHz Athlon XP (single core)
14:14:15 <glguy> the computer I'm on now techincally isn't mine anymore
14:14:17 <glguy> so I don't count it
14:14:28 <glguy> I sold it (but still use it :) )
14:14:31 <hyrax42> I want to get a macbook but no monies
14:14:47 <monochrom> Your Athlon should be ok.  Will look way more than twice as fast as your laptop because of the reasons I have explained.
14:14:56 <hyrax42> dual core would be nice
14:15:10 <hyrax42> monochrom: yeah, but I'm too lazy to run a unix/like on it
14:15:15 <hyrax42> so all my haskell is under os x
14:15:25 <monochrom> use a live-cd :)
14:15:38 <hyrax42> it's teh constant rebooting that kills me
14:15:44 <hyrax42> all my data are on ntfs partitions
14:15:56 <glguy> dons: was that with 2 dualcore'd HT'd procs?
14:16:00 <hyrax42> so I can't add new stuff from linux
14:16:09 <glguy> dons: or 4 singlecore'd HT'd rpocs
14:16:11 <dons> glguy: yeah
14:16:16 <dons> 2 x 2
14:16:16 <glguy> former
14:16:41 <dons> the new box is 8 x 2, which should be more fun
14:17:15 <glguy> are you considering counting the compile time in cursor blinks on that one?
14:17:19 <glguy> intel?
14:18:04 <dons> amd64
14:18:54 <glguy> what does a 8x2 box run for all said and done?
14:19:06 <dons> run for in $ terms?
14:19:13 <glguy> lol, no , hours
14:19:18 <glguy> yeah monies :)
14:19:30 <dons> $24k .au pesos
14:19:44 <dons> so something ike $US 20k
14:20:49 <Excedrin> it would be interesting if there was something like distcc for Haskell
14:21:44 <dons> i did manage to get most of a ghc build once using pvm-gmake
14:21:59 <dons> which runs make on a cluster, sharing an nfs
14:22:57 <Excedrin> it seems like there's not much focus on distributed computing in Haskell, but I'd be happy to learn about things that change my impression
14:24:03 <dons> Excedrin: yeah, there's a few people who've looked very hard at it
14:24:26 <dons> gdh for example, is a distributed haskell
14:24:39 <Saizan> hyrax42: there's this thing called ntfs-3g that let you write on ntfs from linux
14:24:54 <dons> here, http://www.haskell.org/haskellwiki/Research_papers/Parallelism_and_concurrency#Parallel_Haskell
14:24:58 <lambdabot> Title: Research papers/Parallelism and concurrency - HaskellWiki, http://tinyurl.com/yybhes
14:24:58 <pejo> Excedrin, are you talking about current efforts, or all efforts over time?
14:25:00 <hyrax42> Saizan: stably?  I'll look it up
14:25:03 <dons> some of those papers refer to distributed/mobile haskell
14:25:06 <pejo> Oh, dons summed it up nicely.
14:25:32 <Saizan> hyrax42: yes
14:25:40 <hyrax42> interesting
14:25:48 <hyrax42> seems a rather new development
14:26:29 <Saizan> released this summer iirc
14:26:41 <hyrax42> thanks for pointer
14:26:52 <hyrax42> I'll investigate when it's tiem for me to format the windows machine again
14:27:01 <Saizan> np
14:27:36 <glguy> Lol, first it's "Haskell sucks because it doesn't have the libraries that Java does" and now its "Haskell sucks because all you are doing is writing glue between your sweet libraries" ;)
14:28:10 * glguy 's take on the responses to the RSS aggragators (-;
14:28:46 <allbery_b> typical
14:29:05 <SamB_XP> isn't that the ideal of programming?
14:29:21 <SamB_XP> well, I suppose the ideal doesn't actually involve glue, juts Lego bricks, but ;-P
14:33:18 <Taral> gah!
14:33:23 <Excedrin> pejo: I was talking about current stuff
14:33:26 <Taral> why isn't there a standard base64 module in haskell yet?
14:33:54 <allbery_b> hm, I thoguht someone said there was
14:33:59 <allbery_b> it jusrt wasn't being used
14:34:05 <SamB_XP> we don't have any standard modules for codecs of any kind, do we?
14:35:04 <allbery_b> guess not, or at least I didn'
14:35:07 <allbery_b> t save it
14:38:36 <glguy> also, I'd like to see a separate comments box for complaining about the parentheses in Lisps
14:38:47 <glguy> so that all of those comments can be found in 1 and only 1 place
14:40:29 <glguy> I should make an Ask Reddit: Would you all please put your () complaints on this thread so you don't have to put them on any others
14:40:37 <Taral> ok, having trouble with HXT
14:40:45 <Taral> I do this:
14:41:18 <Taral> c <- readDocument [(a_validate, "0")] fn >>> getChildren >>> hasName "root" >>> getChildren <- x
14:41:29 <Taral> a <- hasName "a" >>> getChildren >>> getText <- c
14:41:35 <Taral> b <- hasName "b" >>> getChildren >>> getText <- c
14:41:37 <dons> glguy: yeah, I saw that :) (re. libraries)
14:41:38 <glguy> Taral: I think that the right arrow is> -<
14:41:38 <Taral> returnA <- (a, b)
14:41:40 <Taral> and get nothing
14:41:42 <allbery_b> @paste
14:41:42 <lambdabot> http://paste.lisp.org/new/haskell
14:41:47 <Taral> glguy: Oops, I meant -<
14:41:56 <Taral> it compiled, and returns []
14:42:05 <Taral> but if I only do one of a or b, I get an answer
14:42:14 * glguy hasn't actually used HXT
14:42:21 <glguy> :)
14:43:30 <nomeata> Hi again.
14:43:34 <lisppaste2> Taral pasted "HXT problem" at http://paste.lisp.org/display/32962
14:43:39 <nomeata> Now this is what I have working with parsec:
14:43:41 <nomeata> src = string "<img src=\"" >> manyTill anyChar (char '"')
14:43:42 <nomeata> images = try (liftM2 (:) src images) <|> (anyChar >> images) <|> (eof >> return [])
14:44:10 <glguy> does HXT work with 6.6?
14:44:17 <nomeata> But I assume this could be done better.
14:44:28 <Taral> glguy: It compiles and runs.
14:44:40 <Taral> and will work if I don't have both a and b
14:44:50 <glguy> (I was just asking because I'm installing it now)
14:45:21 <Taral> does hat work with arrows?
14:47:00 <Taral> hmake doesn't support arrows
14:47:14 <Taral> no, hat doesn't.
14:47:16 <Taral> damn :(
14:47:31 <RemiTurk> hi everybody
14:48:01 <Taral> nomeata: I suggest using a real HTML parser.
14:48:02 <Randroid> What's the <|> operator?
14:48:31 <glguy> it's a parsec operator that tries running the left argument parser
14:48:36 <glguy> and if that doesn't work, runs the right side one
14:48:46 <Randroid> I see, hence it's "derivation" from |
14:48:49 <Taral> ok, not happy with hxt :(
14:49:06 <Taral> do my own arrows with haxml.
14:49:20 <dons> ?pl \x y -> all isSpace [x,y]
14:49:21 <lambdabot> (all isSpace .) . (. return) . (:)
14:49:52 <glguy> ?pl \x y -> isSpace x && isSpace y
14:49:52 <lambdabot> (. isSpace) . (&&) . isSpace
14:50:01 <Excedrin> dons: this heterogenity in grid parallel haskell paper is just what I was looking for
14:50:07 <glguy> swing (&&) isSpace isSpace
14:50:13 <nomeata> Ok, now assuming my input would not be HTML, but just some random noise where I want to extract whatâs between the meaningless strings <img src=" and ", is there a neat parsec trick to make it look nicer?
14:50:22 <glguy> join (swing (&&)) isSpace
14:50:37 <Taral> swing?
14:51:20 <glguy> i forget now, is swing = f g x y = g x `f` g y
14:51:29 <glguy> or = f g h x y = g x `f` h y
14:51:31 <glguy> anyone?
14:51:38 <SamB_XP> ???
14:51:45 <monochrom> Cale's swing.
14:51:48 <glguy> yeah
14:51:53 <Taral> oh, that one
14:51:54 <Taral> it's f g x y
14:51:56 <SamB_XP> you mean swing = \f g x y -> g x `f` g y --?
14:52:00 <liquidengineer> Hello
14:52:00 <glguy> yeah, that
14:52:10 <glguy> dons: swing (&&) isSpace  (=
14:52:11 <Excedrin> dons: are any of these actually usable?
14:52:14 <liquidengineer> I'm using TextMate on a Mac, and I have the haskell language bundle installed.
14:52:15 <SamB_XP> I mean, that stuff you said isn't syntactically valid
14:52:21 <liquidengineer> The Literate mode doesn't work
14:52:26 <liquidengineer> Do I have to have LaTeX installed?
14:52:45 <glguy> SamB_XP: obviously I was adding an extra =, but the meaning was clear
14:52:57 <SamB_XP> not so clear :-(
14:55:01 <monochrom> ???  I don't understand Taral's problem.  What does the xml file fragment look like?
14:55:56 <lisppaste2> Taral annotated #32962 with "Input" at http://paste.lisp.org/display/32962#1
14:56:05 <Taral> it outputs []
14:56:09 <monochrom> Oh I see, use <+>
14:56:15 <Taral> where?
14:56:36 <monochrom> one moment
14:57:31 <monochrom> meanwhile, if you have <a>...</a> or <b>...</b> but not both, what should you return?  (You can't return (a,b) then.)
14:57:41 <Taral> []
14:57:56 <Taral> that's irrelevant though
14:58:01 <Taral> the problem is that I have both, but I'm getting []
14:58:05 <dons> Igloo: do you want to commit the Data.List documentation patch too?
14:58:12 <dons> I mightn't get around to it otherwise
14:58:14 <Taral> instead of [("1", "2")]
14:58:30 <monochrom> Oh sorry, you have both.
14:58:33 <glguy> ?type (<+>)
14:58:34 <lambdabot> forall (a :: * -> * -> *) c b. (ArrowPlus a) => a b c -> a b c -> a b c
14:58:41 <dons> Excedrin: I don't know the state of them. they might be needing some older ghcs
15:02:12 <lisppaste2> monochrom annotated #32962 with "fix" at http://paste.lisp.org/display/32962#2
15:03:23 <monochrom> container"c" already gets to one of the children of <c>.  In other words container"c" returns either the <a> element or the <b> element.  The original code dives one level too deep and then looks for <a> and <b>.
15:04:28 <monochrom> Please don't impeach HXT until you have run it through me, Cale, or edi/xerox. :)
15:04:32 <glguy> getChildren only goes down one level, right?
15:04:48 <Cale> glguy: indeed
15:05:00 <glguy> "run through" sounds like something you do with a sword
15:05:30 <Cale> deep is for searching deeply for nodes that match a particular description, but doesn't search inside matching nodes
15:05:40 <Cale> multi will search even inside nodes which matched
15:05:45 <monochrom> YEAH!  If you want to impeach HXT, OVER MY DEAD BODY!
15:05:47 <glguy> interesting :)
15:07:22 <araujo> http://fmap.us/
15:07:48 * araujo now needs to find something to upload :-)
15:08:06 <glguy> araujo: do it in the spirit of foldr.com and foldl.com
15:08:26 <glguy> (-;
15:08:38 <stepcut> How do run a unix command (e.g. cat) and write something to it's stdin?
15:08:46 <araujo> glguy, hah, fun
15:09:01 <glguy> stepcut: with a pipe
15:09:05 <stepcut> oh wait, maybe I should try runInteractiveProcess instead of runProcess :)
15:09:10 <glguy> ahh
15:09:11 <glguy> :)
15:09:16 <glguy> *in Haskell*
15:09:35 <Igloo> dons: Which is that?
15:09:38 <stepcut> glguy: I tried that, but when I use fdToHandle, it sets O_NONBLOCK, and then cat fails if all the data is not already ready
15:09:42 <Axioplase> stupid question... map == liftM for lists ?
15:09:43 * therp still wants a pick up line that contains the words foldr and lambda.
15:09:48 <glguy> Axioplase: yeah
15:10:01 <therp> but I think I will go to sleep before that. good night everyone
15:10:05 <Taral> what is the difference between \(a, b) -> and \~(a, b) ->?
15:10:12 <Axioplase> glguy: it should be written in bold somewhere... that's soo easy to catch, now I know this :)
15:10:13 <glguy> lazy pattern matching?
15:11:20 <nomeata> I got a list of rectangles, and a given screen width, and Iâd like to put the rectangles on the screen so that they do not overlap, but use the least vertical space possible. Any pointers to a good algorithm for that?
15:11:26 <glguy> ~(a,b) doesn't check for the (,) until you try to use a or b I think
15:11:44 <dons> Igloo: the patch sitting in the library queue: http://hackage.haskell.org/trac/ghc/ticket/1034
15:11:46 <lambdabot> Title: #1034 (Added examples, more detailed documentation to Data.List functions of &#3 ...
15:11:59 <glguy> > (\(a,b) -> 1) undefined
15:12:01 <lambdabot>  Undefined
15:12:05 <glguy> > (\~(a,b) -> 1) undefined
15:12:06 <lambdabot>  Parse error
15:12:21 <glguy> > let f ~(a,b) = 1 in f  undefined
15:12:23 <lambdabot>  1
15:12:29 <glguy> > let f (a,b) = 1 in f  undefined
15:12:30 <lambdabot>  Undefined
15:12:36 <Igloo> dons: OK, ta
15:12:41 <Taral> > (\(a, b) -> undefined)
15:12:42 <lambdabot>  Add a type signature
15:12:46 <Taral> > (\(a, b) -> 1)
15:12:47 <lambdabot>  Add a type signature
15:12:57 <Taral> > (\~(a, b) -> undefined)
15:12:58 <lambdabot>  Parse error
15:12:59 <Taral> weird
15:13:03 <dons> > (\(~(a,b)) -> 1) (undefined :: (Int,Int)
15:13:04 <lambdabot>  Parse error
15:13:05 <Taral> why is it a parse error?
15:13:10 <dons> maybe its a Language.Haskell-ism
15:13:28 <Taral> Let me check the report, I guess.
15:13:41 <dons> > (\(~(a, b)) -> 1) undefined -- works in ghci
15:13:43 <lambdabot>  1
15:13:47 <dons> and lambdabot :)
15:13:49 <int-e> > (\ ~a -> a) :: Int -> Int
15:13:50 <lambdabot>  <Int -> Int>
15:13:58 <dons> ah good
15:14:03 <allbery_b> lambdabot is using the haskell parser library routines in the Language.Haskell module, which is neither complete nor fully correct
15:14:16 <SamB_XP> how would it make sense for a lambda to pattern match lazilly?
15:14:25 <monochrom> Need space between \ and ~
15:14:32 <SamB_XP> allbery_b: and it doesn't even use the parse tree!
15:14:34 <dons> > (\(~(a, b)) -> 1) undefined
15:14:35 <lambdabot>  1
15:14:40 <dons> > (\((a, b)) -> 1) undefined
15:14:42 <lambdabot>  Undefined
15:14:46 <dons> SamB_XP: ?
15:14:56 <glguy> ahh
15:15:19 <dons> > (\ ~(a, b) -> 1) undefined
15:15:21 <lambdabot>  1
15:15:28 <SamB_XP> well. does the lambda even get applied before the bound variables are wanted?
15:15:40 <SamB_XP> hmm.
15:15:47 <SamB_XP> okay, okay.
15:15:51 <int-e> > fix (\ ~(a:as) -> 1:(1+a):as)
15:15:52 <lambdabot>  [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2...
15:16:02 <SamB_XP> answering questions before I finish asking them, eh?
15:16:19 <int-e> > fix (\(a:as) -> 1:(1+a):as)
15:16:20 <lambdabot>  Exception: <<loop>>
15:16:40 <Taral> why?
15:17:00 <Taral> > let (a:as) = 1:(1+a):as in a:as
15:17:02 <lambdabot>  [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2...
15:17:11 <Taral> ok, so let is lazier than \?
15:17:25 <int-e> yes. let pattern matches are lazy
15:17:28 <Cale> pattern bindings act as if they had a ~ in front
15:17:37 <int-e> hmm. pattern bindings. yes.
15:17:52 <Cale> It's just so common that you want that they made it the default.
15:18:06 <Taral> I see.
15:18:11 <Taral> so why isn't \ lazy?
15:18:13 <SamB_XP> Cale: I think there is more to it than that
15:18:24 <Cale> SamB_XP: what?
15:18:50 <SamB_XP> Cale: well. what about recursive bindings?
15:18:53 <Taral> ah
15:19:13 <Taral> \~(a, b) -> f a ==> f (fst a)
15:19:24 <Taral> \(a, b) -> f a = \z -> case z of (a, b) -> f a
15:19:27 <int-e> Taral: because lazy bindings carry an additional cost (they create thunks for the bound variables)
15:19:38 <Cale> Well, yeah, strict pattern bindings would make value recursion harder to use.
15:19:40 <Taral> \~(a, b) -> f a ==> f . fst
15:20:05 <Taral> ok
15:20:24 <int-e> > let f ~(a:as) = 1 + f as; f ~[] = 0 in f [1,2,3]
15:20:25 <lambdabot>  Irrefutable pattern failed for pattern (a : as)
15:20:44 <Taral> lol that's different
15:20:58 <Taral> ~ there prevents fall-through
15:21:02 <Cale> yeah, it tries to match ~(a:as) against [], and succeeds :)
15:21:16 <Cale> and then promptly fails when as gets used
15:21:21 <Taral> Ah.
15:21:23 <Taral> So it's the same, really
15:21:24 <int-e> hmm. I wonder why that didn't result in a loop.
15:21:30 <nomeata> Hmm. Where is the ((,) a) Functor defined?
15:21:32 <Taral> we defer the match if ~ is used.
15:21:52 <Taral> int-e: Why would it?
15:21:58 <Cale> int-e: because 1 + f as was evaluated with ~(a:as) being matched against the empty lis
15:21:58 <Cale> t
15:22:20 <Taral> let f z = 1 + (case z of {(a:as) -> f as; [] -> fail "blahblah"})
15:22:20 <int-e> Cale: but what forces the value of as?
15:22:30 <int-e> > let f ~(a:as) = 1 + f as; f ~[] = 0 in f undefined
15:22:32 <lambdabot>  Undefined
15:22:37 <Cale> +
15:22:43 <int-e> what makes f strict?
15:22:49 <Taral> interesting question.
15:23:00 <Taral> > let f ~(a:as) = 1 + f as in f [1,2,3]
15:23:01 <lambdabot>  Irrefutable pattern failed for pattern (a : as)
15:23:19 <Cale> oh, I see what you're saying
15:23:29 <Cale> f as is obviously forced
15:23:31 <nomeata> I find it in Control.Monad.Instances, but it seems I canât load that
15:24:22 <Cale> but it's less clear that as is
15:24:24 <nomeata> ok, not defined in 6.4 yet.
15:25:55 <glguy> whoa, Text.XML.HXT.Arrow imports a *ton*
15:26:06 <Cale> yes
15:26:15 <Cale> almost everything :)
15:28:19 <int-e> 6.4.2 does that, when compiling with -O. hmm.
15:42:30 <[d-_-b]> it is possible a haskell program creat a temporary .dat file and in the end delete the file???
15:42:57 <monochrom> Yes.
15:42:58 <dibblego> ?hoogle exitWith
15:42:58 <lambdabot> System.exitWith :: ExitCode -> IO a
15:44:51 <[d-_-b]> monochrom, do you know how?
15:44:59 <Taral> is there any way to use hat without translating everything in the libraries my code uses?
15:45:54 <monochrom> damn, I don't know hat.
15:46:20 <bd_> [d-_-b]: use http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html#22 with bracket ?
15:46:22 <lambdabot> http://tinyurl.com/sbkmj
15:47:19 <[d-_-b]> thanks bd_
15:48:09 <monochrom> System.IO.openTempFile can create temp file.
15:50:07 <monochrom> System.Directory has commands for deleting.
15:52:30 <dons> monochrom: ah thats it.
15:52:36 <dons> I couldn't find that function the other day in my tutorial
15:52:42 <dons> and ended up using the mkstemps stuff
15:53:09 <monochrom> We need a Trivia Pursuit for the hierarchical libraries.
15:53:32 <dons> withTempFile f = do x <- openTimeFile ; f x ; removeFile x
15:53:36 <dons> [d-_-b]: something like that
15:53:49 <dons> then you can say: withTempFile $\tmp -> do .... mess with tmp ...
15:55:58 <monochrom> need to catch exceptions etc.  in the end you still bracket.
15:56:06 <dons> yep
15:56:38 <dons> but you'd use that inside the withTempFile definition, since you want the flexible with* style (usually)
15:56:51 <monochrom> yeah
15:58:15 <Taral> grr
15:58:16 <Taral> hat is broken
15:58:20 <Taral> hat-trail: attempt to read beyond end of file
16:01:46 <kyevan> Hmm..., that would be an interesting chalange. One I'm no where NEAR up to, but interesting.
16:02:13 <kyevan> Has anyone ever tried to write an emulator in Haskell?
16:03:08 <monochrom> Someone wrote some NES emulator.
16:03:21 <SamB_XP> someone wrote a gameboy emulator
16:03:25 <kyevan> Huh.
16:03:28 <SamB_XP> I've got a partial Z-machine interpreter
16:03:32 <dons> kyevan: yeah, and there's been a few UM machines :)
16:03:45 <kyevan> And I know that somone... I was about to mention the z-machine terp :P
16:03:46 <[d-_-b]> dons, what is the 'f' and 'x' ?
16:03:47 <dons> there's also a microkernel 'emulator'
16:03:51 <monochrom> Darn. I meant gameboy.  We're talking about the same emulator.
16:04:15 <SamB_XP> monochrom: heh
16:04:31 <SamB_XP> an NES emulator would probably be a bit too much
16:04:54 <SamB_XP> those are horrible messes however you slice it, and Haskell would just reveal the true horror
16:04:58 <kyevan> It would be an interesting project, though. How would you handle the fact that you're trying to do an inherently imperetive task?
16:05:02 <allbery_b> [d-_-b]: f is a function you pass in, x is a temporary filehandle returned by openTempFile
16:05:03 <monochrom> I have wrote an SECD machine in Haskell.
16:05:11 <SamB_XP> kyevan: monad-building, probably
16:05:14 <SamB_XP> thats what I do
16:05:17 <kyevan> SamB_XP: True.
16:05:20 <SamB_XP> for my z-machine thing
16:05:34 <SamB_XP> but, of course, that doesn't really answer the question very well.
16:05:38 <monochrom> Very few things are inherently imperative.
16:05:44 * SamB_XP actually uses a mostly pure monads
16:05:47 <SamB_XP> er.
16:05:50 <SamB_XP> mostly pure monad
16:05:55 <Axioplase> hum.. is  [1,2] >> f or x <- [1,2]; f x  the same as fmap f [1,2]  ?
16:05:56 <allbery_b> so you'd write a function using the filehandle instead of an explicit filename, and run it with withTempFile $ \h -> do {-whatever-}
16:06:10 <kyevan> monochrom: Well... I can think of... two things.
16:06:42 <SamB_XP> basically the only thing I use IO for is trace output and communicating with the UI (which is on the recieving end of a Chan)
16:07:31 <kyevan> Writeing a script for a sequential display of some sort (cutscenes and such)
16:07:55 <dons> [d-_-b]: something like this:
16:07:56 <dons> import System.IO
16:07:57 <dons> import Control.Exception
16:07:57 <dons> import System.Directory
16:07:57 <dons> withTempFile :: (FilePath -> Handle -> IO ()) -> IO ()
16:07:59 <dons> withTempFile a = do
16:08:02 <dons>     bracket
16:08:04 <dons>         (openTempFile "haskell" "XXXX")
16:08:07 <dons>         (\(f,h) -> do hClose h ; removeFile f)
16:08:09 <dons>         (\(f,h) -> a f h)
16:08:24 <monochrom> One way to rephrase my sentence is: very few lines of code need to be in the naked IO monad.  Most often you build another monad on it, abstracting and restricting the I/O you do.  For example STM.
16:08:26 <kyevan> and... I forgot the other one.
16:08:31 <dons> which will take a function as an argument, automatically creating and removing the temp file when you're done
16:08:35 <Excedrin> kyevan: have you ever heard of SMIL?
16:08:53 <kyevan> Excedrin: Can't say I have.
16:09:07 <monochrom> Another example.  There is already an arrow library for GUI.
16:09:25 <[d-_-b]> dons, thanks! thats it
16:09:50 <monochrom> Another example.  There is a monad for SQL queries.
16:10:06 <Axioplase> hum..same question after its correction... why [1,2] >> [3,4] is equal to concat $ fmap (\x->[3,4]) [1,2] ?  I just don't get the concat...
16:10:09 <sorear> dons's LB, fex.
16:10:19 <dons> mm, I haven't noticed this before:
16:10:20 <dons> Wed Dec 13 08:45:38 PST 2006  simonpj <at> microsoft.com
16:10:20 <dons>   * You can now have an MVar with a polymorphic contents
16:10:42 <monochrom> That's scary, dones.
16:11:04 <sorear> rank-1 polymorphic mvars are dangerous.
16:11:29 <sorear> mvars with polymorphic contents (rank-2 polymorphic mvars) seem likely to be safe.
16:11:37 <Excedrin> a script for animation is a poor example of something that's "inherently imperative", I think it's a better example of something that's inherently declarative
16:11:50 <sorear> like MVar (forall a. (a -> a) -> a -> a) -- holds church integers
16:11:52 <dons> sorear: so was it not possible at all before to do the IORef/segfault trick with MVars?
16:12:25 <sorear> forall a. MVar a -- you can probably do the IORef/segfault trick with this
16:12:40 <sorear> I've never tried.
16:12:53 <allbery_b> axioplace: for the list monad, fmap is map and (>>=) is concatMap
16:13:04 <allbery_b> (IIRC on that last, my brain is fuzzy)
16:13:43 <monochrom> It depends on whether SPJ has written a soundness proof or not. :)
16:13:44 <kyevan> Mreh.
16:13:55 <kyevan> I wish darcs handled binary files a bit better.
16:13:57 <emu> it is concatMap
16:14:26 <allbery_b> the concat is because you don't want >>= turning a list intoa  list of lists, which is what you'd get from a bare map
16:14:33 <monochrom> binary files benefit from the rsync algorithm.
16:15:51 <kyevan> monochrom: I thought they were just shoved in the repo and copied around?
16:16:17 <kyevan> (And changeing a single bit forced a whole new file in)
16:17:47 <monochrom> the rsync algorithm alleviates that.
16:17:48 <sorear> The problem is that Unix filesystems are untyped
16:18:03 <monochrom> unfortunately I don't know the details enough.
16:18:07 <sorear> You can merge [String] files easily.
16:18:23 <SamB_XP> monochrom: but darcs *uses* the rsync algorithm?
16:18:45 <sorear> But since there is no useful type data, Darcs assumes ASCII files are [String] and non-ASCII files are opaque Integers
16:18:53 <monochrom> I don't know what darcs uses.  I am suggesting to incorporate the rsync algorithm.
16:19:33 <SamB_XP> sorear: Integers?
16:19:48 <SamB_XP> sorear: for real?
16:20:12 <sorear> I suppose internally it is some kind of ByteString
16:20:40 <sorear> I just had to quickly think of an infinite atomic type.
16:21:08 <sorear> (ByteStrings can be merged in many ways that are invalid on most binary files)
16:21:48 <wolverian> hs-plugins still needs Typeable.h, right?
16:22:08 <sorear> droundy: Maybe darcs could have a binary-hunk patch that doesn't commute with any other patch on the same file? (thus all changes to the same binary files conflict as desired, but only differences need be stored in the repository)
16:22:54 <wolverian> (also, how useful is the ghc-api as a replacement for hs-plugins?)
16:22:54 <SamB_XP> there is no droundy here, is there?
16:23:27 <SamB_XP> wolverian: am thinking ghc-api not replace hs-plugins, maybe sometime hs-plugins *use* ghc-api
16:23:31 <SamB_XP> sometime in future...
16:23:39 <sorear> nm, (read faq)
16:24:17 <wolverian> SamB_XP, oh, okay, thanks. in the meantime I guess I'll hunt down a Typeable.h :)
16:24:59 <SamB_XP> I mean, eventually won't hs-plugins want to support multiple compilers?
16:25:00 <sorear> ?docs Data.Typeable
16:25:00 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Typeable.html
16:25:37 <sorear> hs-plugins could in theory be implemented as pure-Haskell Haskell interpreter.  (minus the dynamic typecasting support)
16:26:21 <SamB_XP> uh huh
16:26:37 * SamB_XP not think so...
16:26:53 <SamB_XP> doesn't it need to actually pull values across the boundary?
16:27:03 <sorear> There exists a program to evaluate a haskell program of type Int (easy)
16:27:37 <sorear> There exists ... Int -> Int (eval str = \ arg -> real_eval_with arg str)
16:27:54 <sorear> I'm not sure about polymorphism, but ...
16:28:52 <Taral> okay, I filed a bunch of bugs against hat and hmake
16:28:52 <kyevan> If strict typeing is one of haskell's advantages, why did someone create Data.dynamic?
16:28:54 <Taral> I'm going home now.
16:29:32 <dons> ?versoin
16:29:33 <lambdabot> lambdabot 4p306, GHC 6.5 (OpenBSD i386)
16:29:33 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
16:30:21 <kyevan> lambdabot needs a last digit of pi commmand :P
16:30:40 <kyevan> or pi to the last digit
16:30:43 <kyevan> Whichever.
16:30:49 <SamB_XP> sorear: *I am*
16:30:55 <sorear> > toRational pi
16:30:58 <lambdabot>  884279719003555%281474976710656
16:31:04 <SamB_XP> polymorphism won't work
16:31:12 <kyevan> >pi
16:31:19 <kyevan> > pi
16:31:20 <lambdabot>  3.141592653589793
16:31:35 <sorear> > fromRational (884279719003555%281474976710656) == pi
16:31:36 <lambdabot>  True
16:31:44 <sorear> see!
16:32:13 <kyevan> > let pi = 3 in pi
16:32:15 <lambdabot>  3
16:32:23 <kyevan> ^ Engenieer's version
16:32:58 <emu> there is an infamous case of some state legislature attempting to make the value of pi be 3 by law
16:33:17 <nornagon> i think that's an urban myth
16:33:42 <emu> it's too stupid not to be true
16:33:48 <nornagon> heh
16:33:50 <allbery_b> check snopes
16:33:54 <allbery_b> it's half true
16:34:25 <dons> yeah, half true
16:34:31 <dons> I don't think the legislation got up
16:37:31 <wolverian> sanity check: after compiling lambdabot with runplugs, I'm supposed to run ./lambdabot, not ./lambdabot-dynamic, right?
16:37:52 <dons> wolverian: sounds like you've got an old lambdabot anyway :)
16:37:58 <dons> try grabbing the darcs version
16:38:04 <wolverian> I did a darcs pull like five minutes ago!
16:38:05 <dons> but yeah, ./lambdabot should be ok
16:38:11 <dons> what's this -dynamic thingy then?
16:38:23 <wolverian> hm.
16:38:27 <wolverian> I'm not sure.
16:38:41 <wolverian> it's in the .cabal file I clobbered together to make one that works on ghc-6.6 _and_ compiles runplugs
16:38:58 <dons> ah ok. but there's no hs-plugins for 6.6
16:39:09 <dons> hence i haven't bothered with the cabal script yet
16:39:16 <wolverian> oh. so this can't work?
16:39:22 <dons> so i'd be surprised if runplugs would work...
16:39:29 <wolverian> right. I'm getting that Ix error
16:39:37 <wolverian> Ix{Int}.index: Index (1024) out of range ((0,29))
16:39:39 <dons> yep, that's it
16:39:43 <dons> the .hi file doesn't parse
16:39:46 <wolverian> okay. I'll give up then :)
16:40:31 <topaz_> dons: have you found any employers looking for people with haskell skills?
16:41:14 <dons> topaz_: yes, there's a few. check the 'Industry' page on haskell.org
16:41:29 <dons> i'm employed to write haskell, for example :)
16:41:31 <Excedrin> it's really neat how pi :: BigFloat sits there spewing out digits (it's not that fast, but it's fascinating) and how it can be interrupted with ctrl-c, then pi :: BigFloat again spews the previously calculated part quickly and picks up where it left off
16:41:51 <topaz_> dons: by who?
16:41:57 <nornagon> > pi :: BigFloat
16:41:58 <lambdabot>  Not in scope: type constructor or class `BigFloat'
16:42:14 <dons> i'm employed at a university
16:42:36 <nornagon> ?hoogle BigFloat
16:42:37 <lambdabot> No matches found
16:42:37 <MarcWebe1> Where is the major difference between Data.Map and Data.FiniteMap ?
16:42:45 <dons> MarcWebe1: same thing, Map is faster
16:42:53 <Excedrin> nornagon: http://sourceforge.net/project/showfiles.php?group_id=149387
16:42:54 <lambdabot> Title: SourceForge.net: Files
16:43:36 <dons> apparently there's even a new startup in SF doing web site dev in haskell
16:43:40 <dons> looks quite promising
16:44:46 * dons tries out his new parallel url checker for work, for the first time..
16:45:26 <dons> and we find:
16:45:29 <dons> sorear: http://members.cox.net/stefanor/genericserialize 404?
16:45:38 <dons> Found 3 broken links. Checked 61 links (61 unique) in 1 file.
16:45:38 <dons> Search time: 25 secs
16:45:49 <dons> sorear: http://members.cox.net/stefanor/vty: 404
16:45:57 <dons> Pupeno: http://pupeno.com/blog-en/the-lambda-revolution-episode-v-the-deb-strikes-back: 404
16:46:00 <lambdabot> http://tinyurl.com/vw9ws
16:48:12 * kyevan attempts to use emacs to write his paper.
16:48:23 <Pupeno> dons: http://pupeno.com/blog/the-lambda-revolution-episode-v-the-deb-strikes-back
16:48:24 <kyevan> That... was ment for Sine.
16:48:26 <lambdabot> Title: The lambda revolution, Episode V, the deb strikes back &mdash; Pupeno's web site, http://tinyurl.com/y5crsr
16:48:32 <dons> versus linkchecker.py 10M residency,
16:48:32 <dons> That's it. 74 links checked. 5 errors found.
16:48:33 <dons> Stopped checking at 2006-12-20 11:44:19+011 ( 1.408 minutes)
16:48:42 <metaperl> dons - Re: "which program" I mean the program in which you open the file and average the grades and output them... the last program in this - http://cgi.cse.unsw.edu.au/~dons/blog/2006/12/16#programming-haskell-intro
16:48:43 <lambdabot> Title: Haskell hacking, http://tinyurl.com/yz4kdc
16:48:44 <dons> Pupeno: cheers
16:48:52 <metaperl> no RSS feed for your blog dons?
16:49:01 <dons> metaperl: sure. check the bottom of the page
16:49:03 <stepcut> @pl \r -> ("a" : "b" : r)
16:49:03 <lambdabot> (["a", "b"] ++)
16:49:11 <stepcut> hrm
16:49:48 <dons> ?seen sorear
16:49:48 <lambdabot> sorear is in #haskell. I last heard sorear speak 18m 4s ago.
16:50:30 <dons> Found 3 broken links. Checked 73 links (72 unique) in 1 file.
16:50:30 <dons> Search time: 53 secs
16:50:43 <metaperl> dons - and yes, that same program is the one that I think would be easier to follow if each part were a function we could play with from the command lne
16:51:09 <dons> yeah, metaperl, I agree.
16:51:13 <metaperl> mapM_ for a beginner program... whoa
16:51:15 <metaperl> heh
16:51:32 <dons> well, its not that weird...
16:52:15 <SamB_XP> what?
16:52:33 <SamB_XP> you think beginners should not be writing imperative programs or something?
16:52:55 <SamB_XP> writing an imperative program without either mapM or mapM_ ... now that would be wierd
16:54:00 <dons> metaperl: i'm going to write another article today on this new urlcheck program, any comments on it:
16:54:03 <dons> ?where urlcheck
16:54:03 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/urlcheck
16:54:17 <dons> it uses the network and the concurrency api
16:54:31 <dons> it'll get cleaned up a bit more
16:54:48 <Axioplase> what happens when one writes True <- foo  ?
16:54:56 <Axioplase> How writing this affects the rest of the computation ?
16:55:11 * sorear notices the ?seen
16:55:28 <dons> sorear: your urls are 404ing
16:55:32 <metaperl> I think the argument handling part will be very instructive dons. SJT doesnt cover practical things like that
16:55:50 <dons> metaperl: well, I did that earlier this week though.
16:55:55 <metaperl> oh :)
16:56:01 <dons> i'm more interested in showing the concurrency, exceptions nad bytestrings stuff
16:56:05 <metaperl> I got the RSS feed, so I will be catching up
16:56:07 <dons> (see cat.hs)
16:56:18 <dons> its a full cat implementation, with its command line flags
16:56:24 <dons> sorear:
16:56:24 <dons> $ urlcheck content.wiki
16:56:25 <dons> http://members.cox.net/stefanor/genericserialize: 404
16:56:25 <dons> http://members.cox.net/stefanor/vty: 404
16:56:25 <dons> Found 2 broken links. Checked 61 links (61 unique) in 1 file.
16:56:27 <dons> Search time: 24 secs
16:56:29 <dons> :)
16:56:59 <Excedrin> dons: will the next one convert cat to bytestring?
16:57:03 <sorear> dons: the links aren't actually broken
16:57:12 <dons> ?where+ caths http://www.cse.unsw.edu.au/~dons/code/caths/
16:57:12 <lambdabot> Done.
16:57:26 <dons> sorear: hmm
16:57:28 <dons> Not Found
16:57:28 <dons> The requested URL /stefanor/genericserialize/ was not found on this server.Not Found
16:57:31 <dons> The requested URL /stefanor/genericserialize/ was not found on this server.
16:57:41 <dons> (is what my browser also says, and looks like lambdabot can't find it either?)
16:57:59 <sorear> what it means is : ... /stefanor/genericserialize/index.html is not found
16:58:15 <sorear> my ISP's server isn't smart enough to generate directory listings
16:58:22 <sorear> darcs get should work
16:58:24 <dons> what's the proper url then?
16:58:26 <SamB_XP> so many pathetic HTTP servers
16:58:31 <SamB_XP> dons: that is the url
16:58:31 <dons> ah ok.
16:58:33 <SamB_XP> its a darcs url
16:58:36 <SamB_XP> and has no index.html
16:58:39 <dons> yep
16:58:40 <dons> I see
16:58:44 <dons> darcs only
16:58:46 <SamB_XP> and web server is idiot
16:59:12 <sorear> I think I'll write a recursive pre-upload index.html generator.
16:59:52 * dons is really happy with urlcheck. one day's work, and already lighter and faster than linkchecker.py, and handles interrupts properly
17:07:22 <sorear> ?where FilePath
17:07:22 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/projects/libraries.php#filepath
17:07:32 <topaz_> ?where yourlife
17:07:32 <lambdabot> I know nothing about yourlife.
17:07:41 <topaz_> couldn't find your life apparently
17:10:30 <sorear> ?where anything
17:10:31 <lambdabot> I know nothing about anything.
17:11:54 <Tanuk-> She's just a good guesser.
17:17:07 <dibblego> how do I get "5" into a Word8 as 00000101 ?
17:17:29 <emu> > read "5" :: Word8
17:17:29 <dibblego> '5' I mean
17:17:30 <lambdabot>  5
17:17:35 <SamB_XP> ?where myself
17:17:35 <lambdabot> I know nothing about myself.
17:17:40 <dons> sorear: you might want to put some index.html's in those directories then
17:17:45 <dons> since they appear in the HWN
17:17:47 <dons> and on haskell.org
17:17:56 <SamB_XP> ?where you
17:17:56 <lambdabot> I know nothing about you.
17:23:37 <dons> this week's HWN out now: http://programming.reddit.com/info/vft0/comments
17:23:38 <lambdabot> Title: Haskell Weekly News: purely functional Edison, termio, serialisation (reddit.com ...
17:25:57 <dibblego> > read '5' :: Word8
17:25:58 <lambdabot>  Couldn't match `String' against `Char'
17:26:20 <bd_> > read "5" :: Word8
17:26:21 <lambdabot>  5
17:26:56 <jcreigh_> let c = '5' in read [c] :: Word8
17:27:07 <jcreigh_> > let c = '5' in read [c] :: Word8
17:27:08 <lambdabot>  5
17:29:41 <dibblego> > read (chr 5) :: Word8
17:29:42 <lambdabot>  Couldn't match `String' against `Char'
17:29:51 <dibblego> > read [chr 5] :: Word8
17:29:53 <lambdabot>  Exception: Prelude.read: no parse
17:30:05 <dibblego> there we go
17:30:43 <nornagon> > read [(chr 5)] :: Word8
17:30:44 <lambdabot>  Exception: Prelude.read: no parse
17:30:53 <dibblego> > read [chr (5 + (ord 0)] :: Word8
17:30:53 <lambdabot>  Parse error
17:30:58 <dibblego> > read [chr (5 + (ord 0))] :: Word8
17:30:58 <lambdabot>  add an instance declaration for (Num Char)
17:31:09 <sjanssen> dibblego: so you want '\5' -> (5 :: Word8)?
17:31:14 <dibblego> sjanssen, yes
17:31:33 <nornagon> you don't want read, then
17:31:39 <sjanssen> > fromIntegral . ord $ '\5' :: Word8
17:31:40 <lambdabot>  5
17:31:48 <dibblego> ah thanks
17:32:00 <sjanssen> fromIntegral++
17:32:59 <sorear> dons: I've hacked together a 30 line index.html generator, run it, and uploaded the results
17:38:06 <dons> sorear++ thanks
17:39:39 <Excedrin> is there a :% operator?
17:39:46 <sorear> yes
17:39:54 <SamB_XP> but... it is a secret
17:39:58 <sorear> actually it is an infix data constructor
17:39:59 <SamB_XP> don't tell anyone about it!
17:40:04 <Lemmih> @hoogle (:%)
17:40:04 <Excedrin> what/where is it?
17:40:05 <lambdabot> Did you mean: (:%)
17:40:05 <lambdabot> Prelude.undefined :: a
17:40:05 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
17:40:23 <dons> wwo. 16 core server has arrived!
17:40:57 * dons heads into uni for some multicore action
17:41:08 <sorear> http://darcs.haskell.org/ghc-6.6/packages/base/GHC/Real.lhs
17:41:20 <Excedrin> thanks
17:41:32 <sorear> (it's not exported)
17:41:44 <sorear> (use % instead)
17:42:28 * Lemmih would love to run Conjure on dons' box.
17:43:06 <lispy> dons: nice
17:43:09 <Excedrin> I'm trying to use someone else's code that uses (a :% b) = ...
17:43:22 <lispy> dons: can i run visual studio 2005 on your cluster?
17:43:39 <lispy> because my 3.4 Ghz machine with 1gb of ram is definitely not enough horse power :(
17:43:40 <Excedrin> % doesn't work there, is there another data constructor that is exported?
17:43:49 <lispy> i can get very far ahead of the editor just by typing code
17:43:51 <dons> mm, possibly haskell job: http://www.nnseek.com/e/comp.lang.python/lisp_python_programmers_among_others_wanted_20059193t.html
17:43:53 <lambdabot> Title: Lisp Python programmers among others wanted :: NNSeek, http://tinyurl.com/yxtavt
17:43:58 <dons> "If you are the sort of person who
17:43:59 <dons> has always wanted an opportunity to prove that Haskell or OCaml is the
17:43:59 <dons> Best Way to write software, this could be your chance. But CL is
17:43:59 <dons> currently our first choice."
17:44:10 <lispy> heh
17:44:20 <dons> "Our advanced applications work is
17:44:20 <dons> currently being done in Common Lisp, but that could change depending on
17:44:20 <dons> who we find to fill this position."
17:44:28 <lispy> i'm about 1.5-2 years ahead of them :)
17:46:59 <dibblego> dons, where did you get that text from? it is not on that page
17:47:10 <dibblego> oh never mind
17:47:44 <dons> full message
17:48:27 <dibblego> yeah got it :)
17:48:54 <dibblego> If your main expertise is Java you are probably not a good fit.
17:48:58 <dibblego> that's my favourite :)
17:51:17 <mbishop> http://www.cs.nott.ac.uk/~gmh/book.html
17:51:19 <lambdabot> Title: Programming in Haskell
17:51:40 <dibblego> where was that released?
17:51:56 <mbishop> in the UK apparently
17:52:04 <mbishop> LATEST INFO: Now in stock and available to purchase from Cambridge UK.
17:52:05 <dibblego> er, when (sorry)
17:52:17 <mbishop> dunno, but amazon doesn't have it yet (only preorder)
17:52:20 <mbishop> US amazon anyway
17:53:32 <dibblego> UK one either
17:57:07 <LordBrain> is HList distributed with GHC or Hugs?
17:57:25 <dons> its a 3rd party package
17:57:30 <dons> ?where hlist
17:57:30 <lambdabot> http://homepages.cwi.nl/~ralf/HList
18:13:47 <heatsink> exit
18:13:50 <heatsink> d'oh
18:15:56 <Excedrin> is there a way to check if something is evaluating a list?
18:21:42 <allbery_b> explain?
18:22:13 <Excedrin> uhh, what's the term for causing a lazy list to be evaluated?
18:22:23 <Igloo> forcing?
18:22:28 <Excedrin> yes, that
18:22:36 * monochrom sees dons's "have reached 300" announcement and tosses some sugar lambdas!
18:23:39 <monochrom> Would some tracing mechanism help?
18:24:04 <Excedrin> I suppose, but I'm curious about general cases
18:24:32 <Excedrin> in general, does 'drop 100 l' force the evaluation of the first 100 elements of l?
18:24:47 <monochrom> There are two things.
18:24:59 <Philippa_> not of the items themselves...
18:25:08 <Philippa_> OTOH, the cons cells have to be evaluated
18:25:13 <monochrom> The "structure" of the list is forced.  I.e., the cons cells.  The element values aren't.
18:25:46 <monochrom> drop 100 (replicate 100 undefined ++ [True])   try this.
18:26:16 <Excedrin> neat
18:27:24 <monochrom> The price you pay is lots of boxing.  cons are boxed.  bools are boxed.  everythings are boxed.  that's how you can gain a fine-grain control of what is forced and what is left alone.
18:27:55 * dufflebunk plays outside the box
18:28:26 <sorear> as opposed to for instance : Data.ByteString.Lazy boxes every several Kbytes, but forces many characters at a time
18:32:24 <monochrom> Oh w00t!  So that's the secret of lazy bytestrings!
18:33:02 * monochrom plays a boxing game.
18:33:07 <Cale> The FFI has low-level allocation stuff.
18:33:27 <monochrom> Hahaha!  The Boxing Day is near!
18:35:09 <monochrom> Hahahaha YES!  My 007 titles for haskellers make it to the weekly news!
18:49:30 <dylan> monochrom: yes, but when is unboxing day?
18:50:00 <monochrom> Haha, of course Boxing Day is really about unboxing...
18:50:19 <newsham> hi
18:51:32 <sbenitezb> Hi. I'm getting "Not in scope: `ord'" when trying to use it from hugs or ghci. Do I have to import something?
18:51:41 <TSC> Data.Char?
18:52:03 <TSC> Or, in ghci:
18:52:04 <TSC> Prelude> :t Char.ord
18:52:05 <TSC> Char.ord :: Char -> Int
18:52:48 <sbenitezb> Ok, thanks. I thought it was already present and I was missing something :)
18:52:59 <sorear> Also try: Prelude> fromEnum 'z'
18:54:06 <sbenitezb> Thanks, sorear.
19:03:26 <fishkandy> damn, edison should be in base!
19:03:46 <fishkandy> http://www.eecs.tufts.edu/~rdocki01/docs/edison/index.html
19:04:40 <SamB_XP> noooo
19:04:42 <SamB_XP> it should not
19:04:50 <SamB_XP> not until people actually like it in practice
19:05:15 <SamB_XP> we might still be a few typesystem extensions away, you know!
19:08:24 <kyevan> > let x = (1:x) in show x
19:08:25 <lambdabot>  "[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
19:08:40 <sorear> Ack, my index.html generator put one in _darcs/pristine...
19:09:05 <monochrom> ack :)
19:09:21 <kyevan> Sorry bout that, we're running a paranoia game and someone put some weird code on Friend Computer :P
19:09:28 <monochrom> this is a good time to advertise a versioning file system... :)
19:11:50 <cptn> hello, how do i create a base binary for the new version of ghc
19:12:27 <sorear> darcs get $GHC
19:12:33 <sorear> mkdir ghc-build
19:12:36 <sorear> cd ghc-build
19:12:40 <sorear> lndir ../$GHC
19:12:48 <sorear> ./configure
19:12:49 <sorear> make
19:12:58 <sorear> wait 90 mins (2GHz P4)
19:13:05 <sorear> make install
19:13:07 <sorear> enjoy
19:13:19 <monochrom> # go have a steak dinner, watch a movie, get a date.  err in the reverse order.
19:13:36 <sorear> uh, sorry, /\.\/configure/i
19:13:50 <sorear> ./darcs-all --extra get
19:13:51 <sorear> .
19:14:13 <shoffsta> a question: I have a 'class A a where f :: a -> String'...
19:14:22 <shoffsta> and 'instance A Integer'
19:15:04 <shoffsta> but when I run 'f 3', ghc will give me an error, which is solved by specifying the type for 3, ie 'f (3::Integer)'
19:15:20 <shoffsta> is there any way to get around having to specify the ::Integer?
19:15:28 <sorear> default( Integer ) ?
19:15:30 <Pseudonym> What's the type of f?
19:15:34 <cptn> thanks sorear, will this get me the boot dist?
19:15:37 <monochrom> That is normal.
19:15:43 <shoffsta> f :: a -> String
19:15:55 <sorear> cptn: probably (worked for me)
19:16:03 <Pseudonym> shoffsta, there's no nontrivial function with that type.
19:16:15 <cptn> since i want to make a boot dist for my oos
19:16:17 <monochrom> f :: (A a) => a -> String
19:16:18 <cptn> *os
19:16:18 <sorear> P-n: it's in a class
19:16:26 <Pseudonym> Right, that's important. :-)
19:16:27 <shoffsta> sorear: default( Integer) doesn't work
19:16:32 <sorear> what's a 'boot dist'?
19:17:00 <monochrom> But that will still not guide haskell to use Integer, even with defaulting, I guess.
19:17:13 <Pseudonym> No, because default() only applies to Num.
19:17:19 <monochrom> Yeah.
19:17:29 <SamB_XP> also some other numeric classes
19:17:40 <cptn> a boot dist is a basic ghc bin that can be fetched so ghc may recompile itself
19:18:01 <SamB_XP> unfortunately Bits is *not* one of them
19:18:05 <SamB_XP> one of my pet peeves
19:18:31 <shoffsta> so that means that there is no way to get around the ::Integer part?
19:18:39 <monochrom> Right.
19:18:51 <shoffsta> ah, too bad
19:18:54 <SamB_XP> not except through a standardization committee, no
19:18:54 <dibblego> > let file = "my.file.extension"; i = elemIndices '.' file; split' = Just (splitAt (last $ i) file); split | null i = Nothing | otherwise = Just (fst $ fromJust split', tail $ snd $ fromJust split') in split -- can that be written better with do?
19:18:56 <lambdabot>  Just ("my.file","extension")
19:20:08 <monochrom> ad hoc polymorphism such as type classes makes this necessary.  pure hindley-milner wouldn't need this.  but then again pure hindley-milner doesn't solve the equality problem.
19:21:04 <SamB_XP> and, more importantly, wouldn't have typeclasses!
19:21:42 <Lemmih> dibblego: It can probably be written better with System.FilePath.
19:21:48 <allbery_b> dibblego: http://darcs.haskell.org/~lemmih/FilePath looks better to me :)
19:21:50 <lambdabot> Title: Index of /~lemmih/FilePath
19:21:51 <allbery_b> oh, there he is :)
19:22:07 <Lemmih> This this filepath instead:
19:22:09 <Lemmih> @where filepath
19:22:09 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/projects/libraries.php#filepath
19:22:16 <allbery_b> ah
19:22:37 * allbery_b used google, yours came up first6
19:22:56 <xpika> @where bytestring
19:22:56 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
19:23:54 <heatsink> Apparently I need gcc to install ghc for mac os x (ppc)... Anyone know where I can get a mac os x ppc gcc binary?
19:24:42 <allbery_b> download xcode
19:24:53 <allbery_b> free registration on apple's web site
19:25:00 <SamB_XP> does he need older version or not?
19:25:04 * SamB_XP thinks maybe yes
19:25:13 <allbery_b> hm
19:25:28 <allbery_b> I just installed the latest one (2.4.1) and ghc still seems to work
19:26:04 <heatsink> ok, I'll try that
19:26:15 <SamB_XP> well, I guess it depends on whether you want to distribute the binaries?
19:26:44 <heatsink> Nah
19:26:52 <heatsink> I have linux on my desktop, can use that.
19:27:21 <heatsink> I mean... I don't need to distribute and I can recompile when I need to, so...
19:27:21 <allbery_b> oh, licensing issue.  feh
19:27:49 * heatsink sees a button that says "Purchase an ADC membership"
19:28:10 <allbery_b> hm, no, that's not it
19:28:13 <monochrom> Apple Debugger Club? :)
19:28:26 <heatsink> okay, it's an ADC Online Membership I think
19:28:41 <dons> ?yo
19:28:42 <lambdabot> Actually, what I'd like is a little toy spaceship!!
19:28:44 <dons> ?yow
19:28:44 <lambdabot> Zippy's brain cells are straining to bridge synapses ...
19:29:01 <allbery_b> developer.apple.com/tools/xcode
19:29:09 <heatsink> Move every zip!
19:29:43 <SamB_XP> ?yo!
19:29:44 <lambdabot> I smell a RANCID CORN DOG!
19:30:02 <dons> sorear: yeah, exactly (re. boxing). lazy bytestrings force cache-sized chunks of bytes at a time to be unboxed, boxing the results up
19:30:12 <dons> so less boxes, with bigger presents inside :)
19:30:17 <dons> aka eager evaluation .... ;)
19:30:20 <dons> as a library!
19:30:35 <SamB_XP> yay! don't you just love christmas-themed libraries?
19:31:28 <dons> mmm. I think I'll turn this urlcheck program into a Monad.Reader article
19:31:38 <dons> so we can really think hard about the parallelism
19:31:44 <dons> s/we/gives me time/
19:31:59 <dons> hey levitation_
19:32:03 <dons> welcome!
19:32:18 <SamB_XP> ?users
19:32:18 <lambdabot> Maximum users seen in #haskell: 309, currently: 264 (85.4%), active: 40 (15.2%)
19:32:28 * SamB_XP wonders where they all go
19:33:14 <dons> levitation_: I think you're the first person in #haskell with a .ee domain.
19:33:32 <SamB_XP> ooh! electrical engineering?
19:33:38 <sorear> dons: idea for your statistical-analysis script: count the distinct class C subnets that are concurrenty active.  (lets not count JohnMeacham(_*) N times)
19:33:59 <dons> sorear: ah right.
19:34:07 <sorear> (or maybe IP
19:34:07 <dons> you want to have a look at the @seen module and fiddle with it?
19:34:22 <sorear> 's granularity is open to tweaking)
19:34:26 <dons> i don't have a problem with the *_ foo nicks (neither does freenode's stats counter, actually)
19:34:35 * heatsink is 1/4 of the way through the xcode licensing agreement
19:34:58 <sorear> what, they can't just link to fsf.org/copyright/gpl.html?
19:35:01 <SamB_XP> what if we were to have multiple users in the same college dorm or something?
19:35:31 <SamB_XP> sorear: it has a GUI too you know
19:35:33 <sorear> Don't tempt me to implement a markov chain writing style analyser :)
19:35:34 <heatsink> sorear, their frontends are copyrighted I think
19:36:22 <heatsink> @megahal
19:36:23 <lambdabot> Unknown command, try @list
19:38:43 <sorear> How hard would it be to get lb working on 6.6 (without hs-plugins)?  (or would it be better to download+install a THIRD version of GHC)
19:39:07 <monochrom> wow, third, haha
19:39:29 <SamB_XP> the first being HEAD?
19:39:40 <sorear> 6.6, HEAD, maybe 6.4.2
19:40:48 <monochrom> do you need HEAD?
19:40:48 <dons> sorear: just use the lambdabot.cabal-6.6 file
19:40:52 <dons> should just build
19:41:47 <sorear> monochrom: of course!  (I wanted to play with AT's, currently I'm just 'beta testing')
19:42:08 <sorear> (but bleeding edge is always better :) )
19:43:08 <SamB_XP> because ATsyns aren't implemented?
19:43:18 <SamB_XP> sorear: do you enjoy bleeding?
19:44:20 <sorear> A*data*T's are implemented
19:44:51 <xpika> for "./Setup.hs configure --prefix=/f/g" for bytestring is there any thing i require to configure to install?
19:48:19 <xpika> should i make it /usr/lib/ghc/6.4.2/?
19:48:32 <xpika> ie prefix=/usr/lib/ghc/6.4.2/?
19:56:26 <dibblego> are there any plans to put System.FilePath into GHC base?
19:57:55 <dons> yeah, I believe neil wants to do that
19:58:06 <dons> or at least into a core filepath lib
19:58:28 * sorear just set 'compile-command to "./Setup.lhs build"
19:58:47 <Excedrin> Base lib includes everything, from 'const' to starship control
19:59:16 <dons> there you go, php stands for 'Personal Home Page'
19:59:17 <dons> scary
19:59:18 <sorear> I am so going to write ?rquote...
19:59:43 <sorear> doesn't it stand for PHP: Hypertext Preprocessor now?
19:59:50 <dons> yeah
20:00:42 <Excedrin> to some of us, it will always be Perpetually Hacked Program
20:01:25 <dons> i worry that a programming language emerged from a set of perl scripts for writing home pages...
20:01:32 <dons> that's the cvs model of design
20:01:55 <Excedrin> are you talking about perl6 now?
20:03:03 <sorear> reminds me:
20:03:25 <sorear> Is anyone else interested in my 30-line darcs-corrupting index.html generator?
20:03:37 <dons> darcs corrupting?
20:03:51 <sorear> (It does so little I don't plan on packaging it unless someone wants it)
20:04:04 <dons> just make the script available online :)
20:04:12 <sorear> yeah, it filled my _darcs/pristine's with index.htmls
20:04:25 <dons> ah heh
20:04:56 <sorear> (I've changed it to not descend into dirs (`elem` [".", "..", "_darcs"])
20:09:46 <sorear> Parser.hs in LB doesn't compile...
20:11:41 <sorear> {as,qualified,hiding,pling,pling,one other}_name not in scope
20:13:27 <mutjida> ?users
20:13:28 <lambdabot> Maximum users seen in #haskell: 309, currently: 267 (86.4%), active: 40 (15.0%)
20:15:57 <notsmack> are there no haddock docs for parsec?
20:16:51 <ulph> my function takes a number of Word32 as arguments, can i somehow make them strict and get rid of all the "case ww_s4iE of ww8_X4jc { GHC.Word.W32# ww9_s4hH -> ... }" in the dump.txt?
20:18:54 <int-e> @quote ski
20:18:55 <lambdabot>  please talk to your son or daughter about parametric polymorphism
20:19:08 <int-e> @quote ski
20:19:08 <lambdabot>   "please talk to your son or daughter about parametric polymorphism"
20:19:55 <sorear> ?docs Text.ParserCombinators.Parsec.Prim
20:19:56 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/parsec/Text-ParserCombinators-Parsec-Prim.html
20:20:10 <sorear> notsmack: ^^^
20:21:28 <int-e> sorear: try making the arguments strict (using seq or using bang-patterns if your ghc is recent enough); the compiler should unbox the arguments then, I think.
20:21:38 <notsmack> sorear: thanks!
20:21:59 <int-e> ulph: err. you asked that.
20:28:54 <fishkandy> hmm, and all this time I was pronouncing (x:xs) as "x to excess"
20:32:57 <sorear> @tell dons LB doesn't build with HEAD
20:32:58 <lambdabot> Consider it noted.
20:34:04 <Adamant> @quote dons
20:34:05 <lambdabot>  keroppi: i was thinking of a similar thing recently, on a bus travelling between the hotel and the google summer of code summit, sitting next to guys from apache, python, freebsd, netbsd, perl,
20:34:05 <lambdabot> gentoo... the end of open source was a drunk driver away, with only php goons left to run the show
20:38:15 <xpika> what is the lambdabot command for expanding haskell code?
20:38:58 <sorear> ?pl \bar -> (foo .) . ((. (. bar)) .) (bar .)
20:38:59 <lambdabot> ((foo .) .) . ap ((.) . flip (.) . flip (.)) (.)
20:39:05 <sorear> ?pl \foo bar -> (foo .) . ((. (. bar)) .) (bar .)
20:39:05 <lambdabot> (. ap ((.) . flip (.) . flip (.)) (.)) . (.) . (.)
20:39:21 <sorear> ?unpl (. ap ((.) . flip (.) . flip (.)) (.)) . (.) . (.)
20:39:21 <lambdabot> (\ ab au v y -> ab (((\ an b c i -> b c (\ o -> i (an o))) >>= \ ag -> (\ p q r -> p (q r)) >>= \ af -> return (ag af)) au v y))
20:39:41 <sorear> ?type (. ap ((.) . flip (.) . flip (.)) (.)) . (.) . (.)
20:39:42 <lambdabot> forall c b b1 c1. (b1 -> c1) -> (b -> b1) -> ((b -> c) -> b) -> (b1 -> c) -> c1
20:43:19 <ulph> oh yes! my UM is now fast enough to actually do the first sandmark number! :)
20:43:55 <fishkandy> xpika, apparently pl also doubles as the command for producing an unintelligible flip-stream :-)
20:45:24 <sorear> ?remember+ fishkandy xpika, apparently pl also doubles as the command for producing an unintelligible flip-stream :-)
20:45:44 <sorear> ?remember fishkandy xpika, apparently pl also doubles as the command for producing an unintelligible flip-stream :-)
20:45:48 <sorear> ?bot
20:45:49 <lambdabot> :)
20:45:54 <sorear> ?help remember
20:45:55 <lambdabot> quote <nick>
20:45:55 <lambdabot> remember <nick> <quote>
20:45:55 <lambdabot> Quote somebody, a random person, or save a memorable quote
20:46:02 <sorear> ?quit fishkandy
20:46:03 <lambdabot> Not enough privileges
20:46:07 <sorear> ?quote fishkandy
20:46:07 <lambdabot>  xpika, apparently pl also doubles as the command for producing an unintelligible flip-stream :-)
20:46:25 <sorear> oh, so it *doesn't* give feedback...
20:46:32 <sorear> ?help quit
20:46:32 <lambdabot> quit [msg], have the bot exit with msg
20:49:19 <sorear> ?unlambda `..`.g`.n`.i`.t`.o`.u`.q`. `.g`.n`.i`.t`.s`.e`.Ti
20:49:20 <lambdabot>  Testing quoting.
20:51:17 * sorear *just* figured out where the super-secret ?dons command was implemented
20:51:46 <mwc> Is unlambda the one with the call/cc operator?
20:51:54 <mwc> or is that something else I'm thinking of
20:52:25 <sorear> ?go +site:madore.org unlambda
20:52:28 <lambdabot> http://www.madore.org/~david/programs/unlambda/
20:52:29 <lambdabot> Title: The Unlambda Programming Language
20:53:00 <sorear> unlambda is a strict impure programming language
20:54:25 <mwc> Yeah, the c operator is their call/cc. I recall reading that unlambda added it specifically because so many people have trouble with continuations
21:01:32 <sorear> looking at state files - I have 3x spj's karma !?
21:01:52 <vegai> he's probably not here that much
21:02:23 <int-e> he should submit a few lambdabot patches ;)
21:03:28 <dons> ulph: a bit of strictness with bang patterns might help?
21:03:28 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
21:03:33 <dons> i.e. f !w = ....
21:03:36 <dons> where w :: Word32
21:03:43 <dons> then check the -ddump-simpl output
21:04:31 <dons> sorear: how does it fail?
21:04:45 <ulph> oh i didn't know about -fbang-patterns, thanks :)
21:05:13 <sorear> 'qualified_name' is not in scope in Lib/Parser.hs (a happy-generated file)
21:05:37 <sorear> (but I got it to compile using 6.6)
21:05:55 <sorear> (now I just need to understand the code)
21:06:34 <dons> maybe we're missing an import?
21:06:35 <sorear> also 'as_name' , '
21:06:48 <dons> or one of those files in the haskell-src library is no longer visible?
21:06:49 <sorear> hiding_name', two instances of 'pling_name', and one other
21:07:05 <dons> so check where they are found in the haskell-src library
21:07:07 <sorear> there is no mention of a non-importable module
21:07:43 <dons> there was some hidden module though, that broke lambdabot a while ago, with similar kinds of errors
21:15:08 <augustss> howdy
21:16:22 <dons> heya augustss
21:17:22 <sorear> btw dons, a few minutes ago: *** thetallguy ... has joined
21:17:55 <sorear> (you made major note a while ago, so I thought you'd want notification this time)
21:17:59 <dons> hehe
21:18:22 <ulph> hm. i'm putting an IOUArray into an IOArray and when i do that it seems to convert the IOUArray into an STUArray since it has to worry about the bounds
21:18:59 <ulph> uhm. let me restate.
21:19:05 <dons> ulph: btw, have you seen the other UM implementations in haskell?
21:19:07 <dons> ?where um
21:19:08 <lambdabot> I know nothing about um.
21:19:25 <dons> ?where+ um http://www.cse.unsw.edu.au/~dons/um.html
21:19:25 <ulph> dons: yes, i know that it has been done
21:19:25 <lambdabot> Done.
21:19:35 <sorear> dons: I found the patch in haskell-src that breaks LB
21:19:40 <ulph> thanks though :)
21:19:41 <dons> ulph: oh, just that there's some uarray code in those ones, if you want to peek around
21:19:55 <dons> sorear: ah yes?
21:20:40 <sorear> dons: how different is Lambdabot's Parser.ly from upstream?
21:21:06 <dons> should be the same, but with an entry point for the expr data type
21:21:14 <dons> (i.e. we could port that back wards too :)
21:22:04 <dons> we really should pester nibro about getting his HSX extended language.haskell parser into the core libs
21:22:10 <glguy> After just installing it today, Vista is pretty slick from the appearance POV
21:22:22 <jbalint> heh. i got sick of it fast
21:23:22 <glguy> I like having my programming.reddit rss feed right on the side bar (I'm aware there are probably programs for XP that do the same)
21:23:25 <mbishop> eye candy causes cavities :)
21:23:45 <emu> have any trouble with the Shutdown menu?
21:23:58 <glguy> like what?
21:24:46 <emu> uh, like http://www.joelonsoftware.com/items/2006/11/21.html
21:24:47 <lambdabot> Title: Choices = Headaches - Joel on Software
21:24:56 <glguy> Oh, all the bitching about how complicated it was?
21:25:02 <emu> ehe
21:25:03 <glguy> no, I'm a smart boy
21:25:28 <emu> yea that was all over reddit for a week or so
21:25:35 <glguy> I read a couple of them
21:25:38 <emu> speaking of which, how can you get work done with an RSS feed on your sidebar?
21:25:49 <glguy> emu: home computer :)
21:26:01 <glguy> emu: besides, this putty window distracts me more than rss does at work :)
21:26:09 <emu> tell me about it
21:26:16 <sorear> dons: unfortunately, the patch makes changes to L.H.Parser that depend on changes to L.H.Lexer
21:26:25 <jbalint> you have utf8 in putty?
21:26:38 <emu> i think IRC distraction has probably caused more lost grades and work for me than anything else
21:27:13 <dons> sorear: can we fix it?
21:28:03 <sorear> if we are willing to depend on the latest haskell-src - easily.
21:28:34 <dons> #if __GLASGOW_HASKELL__ >= 606
21:28:35 <dons> ?
21:28:45 <sorear> d'oh
21:29:15 <dons> send me a patch for mega bonus karma fun!
21:32:51 <dmwit> Yay!
21:32:57 <dmwit> I finally recognized a place to use a monad.
21:33:04 <dmwit> (I think. =)
21:33:53 <sorear> dons: __GLASGOW_HASKELL__ ? (not some kind of __HASKELL_SRC__ ?)
21:36:09 <sorear> I suppose there is no use for LB to parse FFI decls :)
21:36:29 <ulph> OK, so my problem is that i have an IOArray of IOUArrays. or actually it is an IOArray of (IORef IOUArray), and I want to unallocate a slot in the first IOArray. can i revert the value to undefined somehow and free up the IORef?
21:36:30 <dibblego> ?hoogle FilePath -> IO [FilePath]
21:36:31 <lambdabot> Directory.getDirectoryContents :: FilePath -> IO [FilePath]
21:38:13 <sorear> just overwrite it with undefined
21:38:33 <sorear> the GC will seek out and destroy your IOUArray
21:38:55 <sorear> but if the slots are regularly appearing and disappearing, you may wish to use Maybe
21:39:01 <ulph> oh. i didn't know about "undefined" :)
21:39:45 <ulph> thanks
21:40:19 <sorear> any value will do, but since you didn't use maybe or anysuch, only _|_ remains to fill unused slots
21:40:37 <ulph> well, i didn't want to create a new value. that would be a performance issue ;)
21:41:04 <sorear> but _|_ cannot be detected (ok, ok, it can, but evil hacks are required), so you want maybe if you want to find empty slots.
21:41:28 <sorear> ?quote C.A.R.Hoare
21:41:28 <lambdabot> C.A.R.Hoare hasn't said anything memorable
21:41:31 <sorear> ?quote CARHoare
21:41:32 <lambdabot> CARHoare hasn't said anything memorable
21:41:35 <sorear> ?quote Hoare
21:41:35 <lambdabot> Hoare hasn't said anything memorable
21:42:30 <ulph> sorear: yeah. i keep the empty slot numbers on a stack. i can't traverse the array to find them. that would be bad.
21:42:43 <sorear> C. A. R. Hoare: "Premature optimization is the root of all evil."  (emphasis on premature)
21:42:45 <nornagon> ?quote lambdabot
21:42:45 <lambdabot>  Occurs check: cannot construct the infinite type: a
21:44:49 <nornagon> ?quote lambdabot
21:44:49 <lambdabot>  I know nothing about comprehending.
21:45:40 <thou> hi, i've got a simple question that i can't seem to find on google.  using a utf-8-encoded source file, i have: module Main where main = putStrLn "abÃ§";  when i compile it with ghc 6.4.2, it prints the output in utf-8 (i.e., 61 62 c3 a7 0a)  but when i compile with ghc 6.6, it prints out in latin1 (61 62 e7 0a).  what should i be doing, to print out utf-8 text with ghc-6.6?
21:48:21 <sorear> in ghc-6.4
21:48:26 <int-e> ironically the reason for that is that ghc 6.6 understands utf 8 ;)
21:49:15 <sorear> in 6.4 the text is interpreted as latin-1 and output as latin-1, which serendipitously fails to damage the text.
21:49:44 <sorear> in 6.6 the text is interpreted as utf-8 and output as latin-1
21:49:56 <thou> i thought it might be something like that; just not sure what option to pass, or whatever, to get it to stop converting
21:49:56 <int-e> But I can't answer your question. I don't know if utf 8 decoding is in the base libs or not.
21:50:02 <int-e> and encoding
21:50:06 <thou> or do i have to use iconv or something
21:50:09 <sorear> does anyone know how to set the output encoding ?
21:51:01 <int-e> sorear: I'd look for a function  utf8encode :: String -> String (or something to that effect), but I don't know of one off hand. (maybe someone else does, dons perhaps?)
21:51:40 <sorear> the standard IO libs take Chars, so they must do encoding themselves.
21:51:44 <ulph> I have
21:52:05 <int-e> sorear: not really. they just truncate the chars to 8 bits I think
21:52:23 <sorear> that is a dumb misfeature.
21:54:58 <ulph> I have a type UM ({-# UNPACK #-} !(IOArray (IORef PlatArray)) ... ) and whenever a function takes f (UM a ...) it keeps passing the bounds of the array although they're NEVER used, I use unsafeRead/unsafeWrite all the time. I checked and there are no references to them in the function, but they're passed down anyways!
21:55:29 <int-e> maybe this ... http://www.haskell.org/pipermail/haskell/2005-January/015205.html
21:55:30 <lambdabot> Title: [Haskell] [ANNOUNCE] New version of unicode CWString library with extras
21:56:19 <Lemmih> Or this: http://repetae.net/john/repos/jhc/UTF8.hs
21:56:46 <thou> thanks, y'all
21:56:47 <ulph> Isn't that kind inefficient?
21:57:05 <int-e> ulph: hmm. they are part of the IOArray data type though ...
21:57:22 <ulph> int-e: I don't have that problem with the IOUArray it seems
21:57:45 <sorear> Are you sure you need to optimize this much?  IIRC the ICFP is over.
21:57:49 <ulph> or let me double check hm.
21:58:39 <ulph> sorear: i'm sorry if i'm nagging you ;)
21:59:25 <ulph> trying to optimize the UM implementation seems to be a great way for me to figure out the inner workings of GHC though.
22:00:08 <sorear> ok, that's a legitimate reason :)
22:00:35 <sorear> you should use ghc -ddump-iface
22:00:57 <sorear> IIRC ghc will unbox data objects and not pass unused components
22:01:03 <xpika> does anyone here know what strongly_connected_component's are?
22:01:05 <sorear> like, oh, your bounds :)
22:01:08 <sorear> yes
22:01:16 <ulph> I'm using -ddump-simpl
22:01:38 <sorear> in a directed graph, a strongly connected subset is one where every node is reachable from every other node
22:02:01 <sorear> in a directed graph, a strongly connected component is a maximal strongly connected subset
22:02:08 <ulph> sorear: hm, but i have checked the dump.txt throughly and they are unused, but still passed.
22:02:15 <ulph> *thoroughly
22:02:23 <xpika> thanks i get it now
22:03:05 <sorear> I'm referring to ?wiki GHC/Performance/Strictness, there is a ref to ... object is unneeded (VERY good) ...
22:03:05 <xpika> thats kinda what i thought it would be
22:03:13 <xpika> do you know if there is any algorithm for that in haskell?
22:03:20 <sorear> ?hoogle scc
22:03:21 <lambdabot> Data.Graph.scc :: Graph -> Forest Vertex
22:03:21 <lambdabot> Data.Graph.Inductive.Query.DFS.scc :: Graph gr => gr a b -> [[Node]]
22:03:21 <lambdabot> Data.Graph.SCC :: data SCC vertex
22:03:42 <xpika> :S
22:04:08 <ulph> ?wiki GHC/Performance/Strictnes
22:04:08 <lambdabot> http://www.haskell.org/haskellwiki/GHC/Performance/Strictnes
22:04:29 <ulph> hm, that's wasn't very helpful ;)
22:04:37 <sorear> ?gwiki Performance/Strictness
22:04:38 <lambdabot> No Result Found.
22:04:41 <sorear> ?gwiki Strictness
22:04:42 <lambdabot> No Result Found.
22:04:46 <sorear> ?gwiki GHC
22:04:47 <lambdabot> No Result Found.
22:04:52 <sorear> ?help gwiki
22:04:52 <lambdabot> wiki <expr>. Search (new) haskell.org wiki for <expr> using google.
22:05:02 <sorear> ?gwiki unboxable
22:05:03 <lambdabot> No Result Found.
22:05:11 <ulph> http://www.haskell.org/haskellwiki/Performance/Strictness
22:05:13 <ulph> maybe ;)
22:05:14 <lambdabot> Title: Performance/Strictness - HaskellWiki
22:05:16 <sorear> ?go unboxable +site haskell.org
22:05:19 <lambdabot> http://tunes.org/~nef/logs/haskell/04.02.03
22:05:25 <sorear> ?go unboxable +site:haskell.org
22:05:27 <lambdabot> http://cvs.haskell.org/trac/ghc/attachment/ticket/786/Unboxable.hs
22:05:28 <lambdabot> Title: #786: Unboxable.hs - GHC - Trac
22:05:37 <sorear> i'll stop now :)
22:09:54 <sorear> dons: YES! Lib.Parser now compiles on both 6.6 and HEAD
22:18:11 <sorear> Wow.  Guess what google#6 for happy is.
22:18:48 <sorear> "Happy - the parser generator for Haskell"
22:19:29 * sorear needs to DOWNGRADE happy
22:20:52 <lambdabot> NEWARK has been REZONED!!  DES MOINES has been REZONED!!
22:21:50 <allbery_b> spontaneyows?
22:29:01 <LordBrain> what triggored lambdabot to say NEWARK has been REZONED etc..
22:29:02 <LordBrain> ?
22:30:18 <sjanssen> @yow?
22:30:19 <lambdabot> Will it improve my CASH FLOW?
22:30:40 <sorear> @. (msg #haskell) yow
22:30:40 <lambdabot> compose module failed: IRCRaised Parse error: "(msg"
22:30:46 <sorear> @. msg #haskell yow
22:30:46 <lambdabot> compose module failed: IRCRaised Privledged commands cannot be composed
22:30:49 <sorear> @. haskell yow
22:30:50 <lambdabot> compose module failed: IRCRaised Parse error: "haskell"
22:30:56 <sorear> @. echo yow
22:30:56 <lambdabot> echo; msg:IrcMessage {msgPrefix = "sorear!n=stefan@ip68-7-248-101.sd.sd.cox.net", msgCommand = "PRIVMSG", msgParams = ["#Haskell",":@. echo yow"]} rest:"Clear the laundromat!!  This whirl-o-matic
22:30:57 <lambdabot> just had a nuclear meltdown!!\n\n"
22:33:15 <dibblego> ?foldoc function
22:33:17 <lambdabot> *** "function" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
22:33:17 <lambdabot> function
22:33:17 <lambdabot>  
22:33:17 <lambdabot>     1. <mathematics> (Or "map", "mapping") If D and C are sets
22:33:17 <lambdabot>     (the domain and codomain) then a function f from D to C,
22:33:19 <lambdabot> [25 @more lines]
22:34:28 <sorear> I'm actually having minor trouble compiling happy (1.15) under 6.6
22:39:26 <sorear_> test
22:39:26 <lambdabot> sorear_: You have 1 new message. '/msg lambdabot @messages' to read it.
22:47:42 <nornagon> test
22:47:58 <nornagon> zany ol' lambdabot
22:48:27 <sorear> @tell nornagon happy now? :)
22:48:28 <lambdabot> Consider it noted.
22:48:39 <dmwit> @pl flip >>=
22:48:40 <lambdabot> (line 1, column 9):
22:48:40 <lambdabot> unexpected end of input
22:48:40 <lambdabot> expecting white space or simple term
22:48:48 <dmwit> @pl f = flip >>=
22:48:49 <lambdabot> (line 1, column 3):
22:48:49 <lambdabot> unexpected "="
22:48:49 <lambdabot> expecting variable, "(", operator or end of input
22:48:59 <sorear> @pl flip (>>=)
22:48:59 <lambdabot> (=<<)
22:49:07 <dmwit> ...
22:49:09 <sorear> haskell operators must be paren'd.
22:49:09 <dmwit> haha
22:49:21 <dmwit> Thanks.
22:49:29 <sorear> ?pl flip (+)
22:49:29 <lambdabot> (+)
22:49:32 <sorear> ?pl flip (.)
22:49:32 <lambdabot> flip (.)
22:49:34 <sorear> ?pl flip ($)
22:49:34 <lambdabot> flip id
22:49:43 <sorear> ?pl flip flip
22:49:44 <lambdabot> flip flip
22:49:51 <sorear> ?pl flip.flip
22:49:51 <lambdabot> id
22:50:02 <sieni> :t flip flip
22:50:03 <lambdabot> forall a c b. b -> (a -> b -> c) -> a -> c
22:50:12 <sorear> ?free flip flip
22:50:12 <lambdabot> Extra stuff at end of line
22:50:16 <sorear> ?free (flip flip)
22:50:16 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
22:50:29 <sorear> ?ft (flip flip)
22:50:30 <lambdabot>  forall T1,T2 in TYPES. forall h1 :: T1 -> T2, h1 strict.
22:50:31 <lambdabot>   forall T3,T4 in TYPES. forall h2 :: T3 -> T4, h2 strict.
22:50:31 <lambdabot>    forall T5,T6 in TYPES. forall h3 :: T5 -> T6, h3 strict.
22:50:31 <lambdabot>     forall x1 :: T5.
22:50:31 <lambdabot>      forall f1 :: T1 -> T5 -> T3.
22:50:33 <lambdabot> [6 @more lines]
22:50:41 <sorear> ?more
22:50:42 <lambdabot>       forall g1 :: T2 -> T6 -> T4.
22:50:42 <lambdabot>        (forall x3 :: T1.
22:50:42 <lambdabot>         forall x4 :: T5.
22:50:42 <lambdabot>          h2 (f1 x3 x4) = g1 (h1 x3) (h3 x4))
22:50:42 <lambdabot>        ==> forall x2 :: T1.
22:50:45 <lambdabot>           h2 (t1 x1 f1 x2) = t1 (h3 x1) g1 (h1 x2)
22:52:43 * glguy wonders if he's watching sorear's /msg lambdabot session ;)
22:54:02 <pjd> hey, is (+)'s commutivity special-cased?
22:54:10 <pjd> or how does ?pl know?
22:57:26 <glguy> ?pl \ a b -> b + a
22:57:27 <lambdabot> (+)
22:58:07 <sieni> ?pl \a b -> b * a
22:58:07 <lambdabot> (*)
22:58:10 <sieni> ?pl \a b -> a * b
22:58:11 <lambdabot> (*)
22:58:34 <sieni> ?pl flip (*)
22:58:34 <lambdabot> (*)
22:58:37 <sieni> vool
22:58:39 <glguy> there is probably a ?pl rewrite rule , flip (+) -> (+)
22:58:41 <sieni> s/v/c
22:58:56 <dons> ?users
22:58:56 <lambdabot> Maximum users seen in #haskell: 309, currently: 268 (86.7%), active: 30 (11.2%)
22:59:14 <sorear> that's odd
22:59:20 <glguy> what?
22:59:21 <sorear> (and bug-fixable)
22:59:37 <sorear> dons: ?users isn't considered saying anything
22:59:44 <dons> yep
22:59:45 <dons> :)
23:00:08 <dons> funny artifact of having commands processed separately to 'context' commands
23:00:10 <sorear> oh, wait, I was mis-remembering having @tell'd, sorry
23:00:15 <sorear> thought so
23:00:26 <dons> (i might have fixed that, i'm not sure...)
23:00:32 <dons> at least it wsa the case till recently
23:00:45 <sorear> anyway, I was able to get Lib/Parser.hs to compile
23:01:02 <glguy> Does anyone know if it's possible to install libraries so that VH can use them?
23:01:06 <dons> sorear: great!
23:01:10 <sorear> however, I wasn't able to exactly regenerate Lib/Parser.hs from .ly
23:01:30 <sorear> so the patch will have a few dozen lines of bogus change
23:01:57 <sorear> (Before I downgraded happy + played w/ the options, it was ~13 klines of bogus change)
23:02:26 <sorear> also, 6.7 warns on a construction 6.6 didn't
23:03:50 <dons> ok. interesting
23:03:54 <sorear> W/o the change, head fails on file 23
23:04:04 <sorear> w it, head fails on file 40
23:04:16 <sorear> I think that's an improvement :)
23:04:28 <sorear> (out of 90-something...)
23:05:14 <dons> good
23:06:55 <sorear> should I send it now?
23:09:26 <glguy> lol at dumb infomercial "anyone that eats is going to want to watch this next segment"
23:09:59 <dons> sorear: does it work with old and new ghcs?
23:10:08 <dons> have you tested the parser?
23:10:21 <sorear> it work*ed* on 6.6 and HEAD
23:10:39 <sorear> but now that I've regenerated the parser with -g, it doesn't
23:10:59 <dons> well, make sure it works with 6.4.2 as well...
23:11:09 <sorear> compatibility defns 'old_name = new_name' can't come before import
23:11:09 <dons> if you think the patch is a bit dicey
23:11:40 <sorear> I remove nothing, and everything I add is in #if __GLASGOW_HASKELL__ > 606
23:11:59 <sorear> ergo if it doesn't break 6.6 it shouldn't break 6.4...
23:12:26 <sorear> since 'old_name = new_name' fails before an import, do you think it would be cleaner to use #define ?
23:12:51 <sorear> (how do you tell happy to add user-provided defn's *after* the import GHC.Exts?)
23:14:09 <dons> hmm. you can insert some code after everything
23:14:15 <dons> inside the { } stuff
23:14:20 <dons> and before the grammar too
23:14:42 <sorear> ahh, ok
23:17:00 <dons> btw guys, i'm going to be on semi-holiday for a week, starting tomorrow
23:17:10 <dons> intermittent net blah blah xmas beer
23:17:24 * Korollary panix
23:17:25 <sorear> awww ;)
23:17:30 <dons> DONT PANIC!
23:17:33 <dons> lambdabot is in control
23:17:47 <dons> :D
23:17:48 <Korollary> but...but who's going to spam reddit with stuff?
23:17:59 <glguy> but what happens if lambdabot goes offline??
23:18:01 <dons> Korollary: ah good point. hadn't thought of that
23:18:02 <sorear> btw, lambdabot sponteously ?yow'd earlier - documented feature
23:18:03 <glguy> can we page you??
23:18:04 <dons> Cale I suppose :)
23:18:12 <Korollary> dons: set up automated reddit submissions
23:18:24 <dons> sorear: yeah, saw that. guess it was Pseudonym or someone playing a game :)
23:18:26 <dons> maybe sjanssen
23:18:34 <dons> there's a few peoplw with the ops to do that
23:18:59 <dons> Korollary: right. so as we pull stuff from planet haskell and reddit to sequence, so we should push stuff from sequence back over to reddit
23:18:59 <sjanssen> I don't have lambdabot ops
23:19:02 <dons> easy
23:19:04 <sorear> I've rearranged the patch, and it compiles on 6.6 now
23:19:08 <dons> sjanssen: oh. i'll give you some then :)
23:19:10 <sorear> s/6.6/HEAD/
23:19:25 <sorear> ah, here's the aforementioned error:
23:19:26 <dons> sorear: you want some lambdabot ops too?
23:19:31 <sorear> Lambdabot.hs:14:8:
23:19:31 <sorear>     Warning: The export item `module Msg' exports nothing
23:19:43 <dons> ah ok
23:19:53 <dons> you could just turn off warnigns in that modules with {-# ... -w #-}
23:20:32 <Korollary> ocamltutorial.org goes down more often than a Miss USA.
23:21:55 <dons> doing some ocaml hacking?
23:22:35 <Korollary> getting ready to. I've got the book by Okasaki. Examples are in ML and Haskell.
23:22:46 <glguy> aside from secretly sending messages to the channel, what do lambdabot ops do?
23:22:47 <dons> ah nice.
23:22:59 <notsmack> Korollary: purely functional data structures?
23:23:01 <dons> glguy: they can unload modules , and join and part channels
23:23:07 <glguy> ah, OK
23:23:08 <Korollary> notsmack: yes
23:23:18 <vegaiW> Korollary: Isn't that SML?
23:23:26 <notsmack> Korollary: it's sitting right next to my monitor, haven't had the guts to tackle it yet :-)
23:23:32 <vegaiW> The ML examples in Okasaki's book, I mean
23:23:36 <Korollary> vegaiW: Yes. I'll use Ocaml instead though.
23:23:41 <vegaiW> Ah :)
23:24:09 <sorear> I'd offer to run lambdabot, but my computer is on 16/7.
23:24:26 <dons> should be fine. she stays up for months unattended these days
23:24:35 <dons> 18:21  dons> ?uptime
23:24:36 <dons> 18:21  lambdabot> uptime: 1m 19d 5h 51m 51s
23:25:15 <sorear> I was sure I saw *** Signoff: lambdabot today...
23:25:37 <dons> yeah, i resync *this* one to get quotes , and update patches, once a week
23:25:37 <sorear> oh, wait, that's a log chunk :)
23:25:43 <beschmi> @paste
23:25:43 <lambdabot> http://paste.lisp.org/new/haskell
23:25:52 <dons> hey  beschmi
23:26:01 * beschmi waves
23:26:40 <lisppaste2> beschmi pasted "ghc error: darcs" at http://paste.lisp.org/display/32996
23:27:39 <Lemmih> beschmi: That's an ld error.
23:27:46 <beschmi> same error message with ghc 6.4.2 and 6.6, seems to be either a problem with darcs or my system
23:28:32 <int-e> beschmi: did you compile that or are you using some binary package?
23:28:47 <int-e> beschmi: ghc that is
23:29:07 <beschmi> 6.4.2 is the ubuntu package, 6.6 is self-compiled
23:29:33 <sorear> (now trying again to build lb on head)
23:35:53 <sorear> dons: I added -w to the options pragma and it still fails
23:36:25 <dons> http://programming.reddit.com/info/vgqo/comments
23:36:26 <lambdabot> Title: Evaluating cellular automata is co-monadic (reddit.com)
23:36:32 <dons> sorear: hmm. is it in the generated file?
23:36:42 <Adamant> "Although you might get sidetracked in the Perl vs. Python vs. Ruby vs. flavor of the month debate. It's worth noting the cool kids are using Haskell." - _The Art of Software Security Assessment_
23:36:56 <sorear> Lambdabot.hs is a generated file? didn't notice that!
23:37:10 <pjd> dons: awesome!
23:38:03 <sorear> dons: how secure is the LB oper-checking?
23:38:24 <sorear> I can't get nickserv to kill me, and I'm not on 24/7...
23:39:23 <dons> *shrug* it relies on nickserv, yes
23:39:25 <int-e> sorear: not very secure I think, but the harm that can be done with that isn't very big either
23:39:35 <dons> so you should use a passwd/identify, if possible
23:39:44 <dons> right, and there's not much harm anyway
23:40:07 <sorear> I *haven't* identified, I *have* set secure kill !automask
23:40:17 <vegaiW> dons: Hey, was it still possible to build a lambdabot without hs-plugins?
23:40:19 <int-e> freenode disabled that
23:40:24 <int-e> for whatever reason
23:40:29 <glguy> from reading /msg nickserv help i noticed that was disabled
23:40:30 <sorear> vegaiW: yes!
23:40:31 <dons> vegaiW: yes, of course
23:40:39 <sorear> I just did it
23:40:49 <vegaiW> Ah, great :)
23:40:54 <sorear> I'm trying to fix it for HEAD, but it works fine on 6.6
23:41:35 <vegaiW> easily? :)
23:41:48 <sorear> fairly
23:42:08 <vegaiW> should I also use HEAD or should 4.0.1 suffice?
23:42:30 <sorear> darcs get ; cd ; rm lambdabot.cabal ; mv lambdabot.cabal-ghc6.6 lambdabot.cabal ; cabal-build
23:42:47 <dons> vegaiW: using the darcs version is a good idea
23:43:16 <vegaiW> ah, yes. 4.0.1 doesn't have that extra cabal file.
23:43:19 * vegaiW tries it right away
23:44:19 <sorear> dons: where is the generated file for Lambdabot.hs?
23:44:39 <tibbe> anyone here running 6.6 on gentoo, in ghci running ":m + Control.Monad.Reader" gives me a module not found error
23:44:56 <glguy> tibbe: Gentoo has other packages for the libraries
23:45:04 <tibbe> glguy: doh
23:45:06 <glguy> Control.Monad.Reader is in the MTL
23:45:06 <dons> mm. so we should probably get the comonad package into the extra libs at some point
23:45:35 <sorear> dons: how would I find the generated file for Lambdabot.hs
23:45:54 <dons> sorear: hmm? there is none
23:45:58 <dons> it is what it is
23:46:07 <dons> you want the cpp output?
23:46:44 <sorear> line 1 of Lambdabot.hs: {-# OPTIONS -cpp -w #-}
23:47:04 <sorear>     Warning: The export item `module Msg' exports nothing
23:47:08 <sorear> ^^ the error
23:47:45 <glguy> booo, VH doesn't install in vista
23:49:28 <fishkandy> dons: (fyi) i just checked in some changes to ogg123's remote interface from a guy who's working on another mpg123 wrapper -- the current trunk works well for him now
23:49:48 <fishkandy> dons: svn co http://svn.xiph.org/trunk/vorbis-tools/ :-)
23:49:50 <lambdabot> Title: Revision 12230: /trunk/vorbis-tools
23:50:29 <sorear> trying -v5
23:50:35 <dons> fishkandy: sweet
23:50:41 <dons> i'll see if i can hack in the patch over xmas then
23:51:07 <dons> then i can switch over to ogg everything :)
23:51:23 <fishkandy> dons, yay (but beer and partying takes priority :-)
23:51:55 <dons> yeah, i always have intentions to get work done over the christmas break, but somehow never manage it
23:52:05 <fishkandy> (as for me, i think they have scheduled me to present at a meeting on monday dec 25 ...)
23:52:08 <dons> esp. once the boxing day test starts
23:52:12 <dons> heh
23:52:39 <fishkandy> yeah, it'll be good to have a break
23:52:40 <dons> so its not a vacation up there?
23:52:48 <fishkandy> i just booked my flights back to .au this morning, for january
23:53:00 <dons> cool. how long you back for?
23:53:08 <fishkandy> nah, christmas is just another day, you might put up an artificial tree for 24 hours
23:53:19 <fishkandy> and the shop assistants wear santa hats for a week or so
23:53:40 <fishkandy> and every store plays either jingle bells or jingle bell rock for about a month beforehand
23:53:46 <dons> heh
23:53:47 <goltrpoat> (thereby making easier targets)
23:54:12 <fishkandy> dons: i'm back for two weeks for lca, jan 9 - 22
23:56:05 <sorear> I found the cpp output (required ^Z), but even that has {-# OPTIONS -cpp -w #-}
23:58:28 <dons> fishkandy: oh man, i'm gone 9-23rd
23:58:56 <dons> sorear: isn't there -ddump-pp or some such?
