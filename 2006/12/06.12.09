00:14:05 <monochrom> OO implementations do dictionary passing too.
00:18:59 <Cale> http://www.youtube.com/watch?v=Gp0HyxQv97Q&eurl= -- wow, this is just incredible.
00:19:13 <monochrom> What does it do?
00:22:40 <ningu> so, erm, I have very much a newbie question here, but I'm just trying to fool around a bit with haskell. I found this article: http://www.linuxjournal.com/article/9242
00:22:41 <lambdabot> Title: Translate Haskell into English Manually, Part II | Linux Journal
00:22:59 <Cale> okay
00:23:12 <ningu> and running the program I get:
00:23:22 <ningu> ERROR foo.hs:1 - Syntax error in import declaration (unexpected symbol "Control.Monad")
00:23:30 <ningu> using hugs -98
00:23:58 <ningu> it works a little better in ghc, but only in ghci, ghc won't compile it to an executable, so I can't feed it stdin
00:24:04 <Cale> okay, how are you trying to run it?
00:24:07 <Cale> er
00:24:13 <Cale> oh
00:24:14 <ningu> sorry, runhugs -98, not hugs -98
00:24:57 <Cale> okay, let me try it
00:25:11 <ningu> if I try to compile in ghc (6.6) it says:/usr/bin/ld: Undefined symbols: _mtlzm1zi0_ControlziMonadziState_execState_closure _mtlzm1zi0_ControlziMonadziState_zdf12_closure
00:25:12 <Cale> the translate C type decls into English program?
00:25:28 <Cale> compile it with --make
00:25:55 <ningu> well not the full one, just the first one in the article, that is supposed to return "X is cool" when you give it X for stdin
00:26:30 <ningu> aha, that works, using --make. I just figured it would produce an executable on its own with gcc.
00:26:38 <ningu> and the manpage implied you wouldn't need --make for a single file
00:26:56 <Cale> it's because it's using Control.Monad.State which is in the mtl library
00:27:00 <Cale> which is usually a default library
00:27:04 <ningu> I guess using import means "multi-module" even if you haven't written more than one module
00:27:10 <Cale> but those link errors suggest that it's not in your installation
00:27:17 <ningu> using --make it works
00:27:20 <Cale> okay
00:27:45 <ningu> dunno why it doesn't work in hugs, but at least it works with ghc
00:28:40 <monochrom> Does hugs support hierarchical modules?
00:28:54 <Cale> That's kind of a strangely written program
00:28:59 <Cale> monochrom: yes
00:29:45 <ski> @tell sorear Your 'MetaLift' sounds like 'FunctorFunctor', i.e. a functor over the category of functors over haskell types (see e.g. http://tunes.org/~nef/logs/haskell/05.08.28)
00:29:45 <lambdabot> Consider it noted.
00:30:47 <Cale> also, that's a really strange way to do things -- that program acts like cat but adds " is cool!" after EOF.
00:31:27 <Cale> I suppose that's not too unreasonable
00:32:08 <Cale> also, they're doing things the hard way instead of just using parsec
00:32:12 <ningu> well, I was reading it since it goes step by step through code instead of just giving lots of theory
00:32:33 <ningu> he says he's doing that on purpose to demonstrate the language *shrug*
00:32:38 <Cale> I suppose
00:32:57 <Cale> but he could at least have written a decent parsing library instead of doing it like this
00:33:26 <Cale> I think it's much more informative to see how to write a simple parser combinator library
00:33:40 <ningu> erm, shouldn't you start with a simple program before writing a library?
00:33:52 <ningu> you have to start somewhere
00:33:56 <Cale> It doesn't need to be separate :)
00:34:11 <Cale> By library, I mean a collection of datatypes and functions :)
00:34:32 <Cale> but if this makes sense to you, go for it :)
00:34:56 <ningu> heh, "If you really want to know the nitty-gritty details of how the State monad works, there's a really fun explanation on Wikipedia"
00:35:18 <ningu> well, I'm not saying it really makes sense yet, just that it makes enough sense that I can go on to seeing what is really going on after
00:38:09 <monochrom> If I have an imperative program with just one variable x:int, I can probably turn it into a functional program by translating each assignment statement into a function int->int.
00:39:26 <monochrom> If the original program also has statements/functions with "return values", say there is one that updates x and "returns a bool", I probably have to use int->(int,bool) instead of int->int.
00:40:09 <monochrom> Now, it is going to be a pain to compose two such functions, but it can be done once and for all.
00:40:36 <monochrom> And if you code up that composition and call it ">>=", well you get your state monad.
00:43:08 <Excedrin> the idea that assignment can be represented as a function is pretty neat, I hadn't considered that. The rest makes sense too..
00:43:48 <Excedrin> if you have a imperative program with two variables that are of different types, how does that translate to the state monad?
00:45:17 <bd_> You can make a state monad with a tuple as a state - just bind together your two variables, or use a data constructor. Though if you're going to have an unbounded number of variables, ST wouldl ikely be a better match.
00:45:26 <bd_> Though ST isn't really useful all that often, to be honest
00:46:37 <Excedrin> if the state is a tuple, does each of the arguments to get and put also need to be a tuple? (I think this is obviously yes...)
00:47:02 <Cale> Excedrin: yes, but not if you write some wrappers around get and put
00:47:30 <Cale> actually, for anything really complicated, you don't want a tuple, but a real datatype
00:47:35 <Cale> possibly a record type
00:48:38 <EvilRanter> are those explained in full anywhere?
00:48:41 <monochrom> If you have many variables, consider STRef. :)
00:49:02 <EvilRanter> i've been scraping together bits and pieces from articles that assumed you already knew record syntax
00:49:53 <monochrom> Like http://haskell.org/onlinereport/ ?
00:49:55 <lambdabot> Title: The Haskell 98 Language Report
00:51:15 <EvilRanter> http://haskell.org/onlinereport/exps.html#sect3.15 looks good
00:51:16 <lambdabot> Title: The Haskell 98 Report: Expressions
00:52:02 <monochrom> I wonder how many kids have not known that there is an official, complete source.
00:52:13 <Excedrin> EvilRanter: data What = Foo { foo :: Int, bar :: String } -- like this? Foo is a constructor (Foo 1 "huh"), foo and bar are accessor functions that take a What and return that field
00:52:38 <monochrom> can also write Foo{foo=1, bar="huh"}
00:52:58 <therp> dons: lol@playing with the devil's bullets :)
00:53:22 <EvilRanter> I think the matter of "eek = Foo { foo=1, bar="huh" }; eek {foo=2}"
00:53:27 <EvilRanter> and so on
00:53:32 <EvilRanter> are what I didn't get
00:53:48 <EvilRanter> (excuse the extraneous \n's there, i'm on a laptop keyboard ><)
00:56:03 <Excedrin> I really like the Haskell record stuff, it's much nicer than "functional record update" in SML because the compiler generates it for you
01:02:49 <ski> Excedrin : generates what ?
01:05:22 <Excedrin> a function to select a field and code to update records (it would be nice if {foo=2} was a function too, but I suppose it's easy to \x -> x {foo=2})
01:06:25 <EvilRanter> it'd make more sense if {foo=2} was a function, actually
01:06:29 <ski> so your point is that you prefer the field selection to be a function ?
01:06:57 <Excedrin> no, look at http://mlton.org/FunctionalRecordUpdate
01:07:08 <lambdabot> Title: FunctionalRecordUpdate - MLton Standard ML Compiler (SML Compiler)
01:07:12 <EvilRanter> as it is, foo{baz="eek"} after foo = Bar{...}
01:07:30 <EvilRanter> ...seems to be an additional bit of syntax, if i understand it right
01:08:11 <ski> i believe OCaml has something like the mentioned 'e with {a = 16, b = 17}'
01:08:38 <Excedrin> yea, in OCaml it's built into the language
01:08:49 <ski> (which is roughly the same as the 'eek {foo=2}' syntax in haskell)
01:08:53 <EvilRanter> ''{baz="eek"} foo'' _seems_ more consistent to _me_, anyway... =P
01:09:09 <ski> yeah, having it be a function itself would be nice
01:09:25 * ski has pondered for a section syntax for that
01:09:43 <EvilRanter> ({foo=2}) :: Foo -> Foo ?
01:10:07 <ski> iirc with trex-style records, one wrote '{ foo = 2 | eek }' for record copy-update
01:10:14 <ski> so i imagined
01:10:39 <EvilRanter> i thought it was { eek | foo = 2 }...
01:11:08 <ski> hm, mayhaps i misremember .. bit afaik it was with the record itself after
01:11:21 <ski> { foo = 2 | }
01:11:33 <ski> that would be the "section"
01:11:40 <ski> hm
01:12:24 <ski> { foo = 2 | } :: (r \ foo) => Rec r -> Rec { foo :: Int | r }
01:12:26 <ski> actually
01:12:39 <ski> so, i guess for update, as oppossed to adding a field it could be
01:12:59 <ski> { foo := 2 | } :: (r \ foo) => Rec { foo :: a | r } -> Rec { foo :: Int | r }
01:13:33 <EvilRanter> O.o
01:13:39 <ski> anyway, such sections could be used to "curry" functions which took their arguments named in a record
01:13:51 * EvilRanter googled up http://research.microsoft.com/~simonpj/Haskell/records.html in an attempt to find details of TRex
01:14:43 <ski> bar :: Rec {x :: Int , y :: Int , n :: Double , s :: String} -> Bar
01:15:04 <ski> bar . {x = 3 , s = "bar"} :: Rec {y :: Int , n :: Double} -> Bar
01:15:18 <ski> that would be an example of such "currying"
01:16:34 <ski> see what i mean ?
01:17:02 <EvilRanter> er
01:17:12 <ski> erm
01:17:14 <EvilRanter> yes
01:17:28 <ski> actually, i'm using somewhat bad terminology here ..
01:17:56 <ski> i'm partially applying the function to some of the argument record fields
01:18:08 <ski> currying would be something like
01:18:30 <EvilRanter> I'm thinking record systems've already been fairly well analysed, and i should probably read the existing stuff before i comment on anything you're writing
01:18:30 <ski> bar . {x = , s = } :: Int -> String -> Rec {y :: Int , n :: Double} -> Bar
01:18:40 <Cale> dons: which mp3 player was it that you bought again?
01:18:47 <ski> or maybe something like
01:19:02 <ski> bar ?? :: Rec {x :: Int , s :: String} -> Rec {y :: Int , n :: Double} -> Bar
01:19:04 <EvilRanter> so as to avoid massive open-mouth-insert-both-feet
01:19:14 <ski> heh
01:19:16 <ski> anyway
01:19:29 <ski> regarding haskells current "record" system
01:19:43 <EvilRanter> it's a little bit rubbish?
01:19:47 <ski> i recently found it quite awkward to update nested records
01:20:50 <ski> r {a = (a r) {b = (b $ a r) {c = ...}}}
01:20:55 <ski> gets a little tiresome
01:21:01 <EvilRanter> foo = Foo { bar={baz=1}}; foo {bar = bar {baz = 2}}
01:21:07 <EvilRanter> er
01:21:15 <EvilRanter> foo = Foo { bar={baz=1}}; foo {bar = (bar foo) {baz = 2}}
01:21:18 <ski> right
01:21:24 <EvilRanter> yuck
01:21:47 <ski> especially if 'foo' there is a (moderately) big expression you're not fond of lifting out and naming
01:22:07 <ski> i did it for lists in a laboration
01:22:11 <EvilRanter> hows about some dot syntax to make things prettier?
01:22:27 <ski> now sure if 'dot syntax' is needed
01:22:33 <ski> but something is needed, imp
01:22:40 <ski> s/imp/imo/
01:22:42 <EvilRanter> foo.bar.baz := 2
01:22:53 <ski> mercury has a syntax like that
01:23:25 * EvilRanter spouts the first syntax that came to mind
01:23:38 <ski> 'Foo.bar.baz := 2' expands to 'Foo.bar := (Foo.bar.baz := 2)' in mercury
01:23:54 <EvilRanter> makes sense
01:23:56 <Excedrin> Cale: M-Cody M-20
01:24:00 <ski> er
01:24:20 <ski> 'Foo.bar.baz := 2' expands to 'Foo.bar := ((Foo.bar).baz := 2)' in mercury
01:24:21 <EvilRanter> well, with appropriate casing and whatnot.
01:24:25 <EvilRanter> parentheses.
01:24:37 <ski> (or using an intermediate variable)
01:24:56 <EvilRanter> quite.
01:25:05 <ski> (!=) :: [a] -> (Int,a) -> [a]
01:25:25 <ski> the laboration wanted us to use this to update a cell in a list of lists
01:25:44 <ski> xss != (i,
01:26:04 <ski> xss !! i != (j,
01:26:08 <ski> y))
01:26:14 <ski> instead i did
01:26:29 <ski> (!<-) :: [a] -> Int -> (a -> a) -> [a]
01:26:57 <Excedrin> why did you put the list first?
01:27:04 <Excedrin> oh, infix?
01:27:05 <EvilRanter> i've always found it slightly odd that haskell's existing record syntax requires records to be in "data" declerations
01:27:15 <ski> (xss !<- i) $ \xs ->
01:27:22 <ski> (xs !<- j) $ \x ->
01:27:23 <ski> y
01:27:26 * EvilRanter likes StdML's way of doing it
01:27:32 <ski> much more readable, imo
01:27:47 <ski> but, alas, this trick couldn't be played with records
01:28:09 <EvilRanter> ski, sorry, you're replacing xss!!i!!j with f(xss!!i!!j)?
01:28:16 <ski> EvilRanter : indeed .. it's unnatural
01:28:19 <EvilRanter> yes
01:28:33 <ski> EvilRanter : yes
01:29:09 <ski> so
01:29:34 <ski> it seems more general to have a *modify* operation, instead of *assign*
01:29:47 <ski> so how would something like that on records fare ?
01:29:47 <EvilRanter> i suppose, seeing as that's what it is
01:30:44 <ski> maybe
01:30:46 <ski> r {a -> a0 = a0 {b -> b0 = b0 {c = ...}}}
01:31:09 <ski> where the 'a0' and 'b0' becomes the old values of those fields
01:31:53 <ski> or .. i guess one could instead allow just a lambda as body
01:32:10 <ski> r {a <- \a0 -> a0 {b <- \b0 -> b0 {c = ...}}}
01:32:41 <ski> so, one doesn't need to name the old value
01:32:53 <ski> foo {x <- (* 10)}
01:33:07 <EvilRanter> how about r { key0 = EXPR0, key1 = EXPR1, ... }, where the old values of keyN are visible as values within EXPRN?
01:33:13 <ski> i believe attributes/options/config in WXHaskell uses something like this, actually
01:33:44 <ski> EvilRanter : the main question is then .. under *which*names* should those be visible
01:33:55 <EvilRanter> the names of the keys?
01:34:05 <EvilRanter> ...but then that clobbers the accessors =/
01:34:06 <ski> we can't just shadow the selector functions .. then we can't use the locally which we could want to do
01:34:10 <ski> right
01:34:30 <EvilRanter> let's have some "'"s.
01:34:57 <ski> there's another small problem, too .. namely the case where new fields depends on values of several old fields
01:35:14 <ski> the "lambda body" variant doesn't handle that well, i think
01:35:32 <ski> but the "name old field values" variant possibly could hanfle that
01:35:35 <EvilRanter> I was thinking something along the lines of r=Foo{a=1,b=2};r{a=a'+b'}
01:36:20 <EvilRanter> or ...r{a=a0+b0} as you put it
01:36:56 <ski> maybe
01:37:01 <ski> r {a -> a0 = a0 + b0,b -> b0}
01:37:19 <EvilRanter> huh?
01:37:32 <ski> why should it magically use the name 'a0' ??
01:37:43 <ski> we ought be be able to choose name
01:37:45 <EvilRanter> 'cos you can't use just a
01:38:17 <ski> if selector fields lived in a different name space (like iirc, they do in TREX), one could use the "same name" as variable name
01:38:24 <EvilRanter> prepend "get" onto the accessors and "mod" onto the modifiers if you prefer...
01:38:32 <ski> (that is called "punning" btw)
01:38:37 <EvilRanter> or whatever
01:38:40 <EvilRanter> punning?
01:38:47 <ski> writing
01:38:51 <EvilRanter> oh... double meanings. very witty.
01:38:53 <ski> foo {x,y} = ..x..y..
01:38:57 <ski> instead of
01:39:01 <ski> foo {x=x,y=y} = ..x..y..
01:39:32 <ski> another example of new field values referring to several old field values
01:39:33 <ski> rot theta p = p {x -> x0 = x0 * cos theta - y0 * sin theta,y -> y0 = x0 * sin theta + y0 * cos theta}
01:40:00 <ski> another way to write that would be
01:40:26 <ski> (in TREX-like syntax, i.e.)
01:40:37 <ski> rot theta {x = x0,y = y0 | p} = {x = x0 * cos theta - y0 * sin theta,y = x0 * sin theta + y0 * cos theta | p}
01:40:42 <ski> or even
01:40:55 <ski> rot theta {x,y | p} = {x = x * cos theta - y * sin theta,y = x * sin theta + y * cos theta | p}
01:41:37 <EvilRanter> the comprehension-esque syntax does make me slightly uncomfortable
01:42:19 <ski> (i'd like having such a syntax, even if we settle for heavvy-weight records, as opposed to leight-weight ones like TREX)
01:42:35 <ski> well, i think one of the MLs uses something more alike
01:42:43 <EvilRanter> I like ML's, as I mentioned
01:42:46 <ski> rot theta {x,y,p = ...} = {x = x * cos theta - y * sin theta,y = x * sin theta + y * cos theta,p = ...}
01:43:04 <ski> (s/leight/light/)
01:44:08 <EvilRanter> ML's got an interesting thing going on, where tuples're just records with their fields called #0, #1, etc
01:44:41 <EvilRanter> I remember being annoyed that it didn't support extensible records, tho
01:44:42 <ski> m, yes
01:44:45 <ski> m
01:45:01 <ski> hm, doesn't OCaml do that now ?
01:45:01 <EvilRanter> not that that sorta thing's really necessary
01:45:12 <EvilRanter> i've only seen stdML
01:45:16 <ski> it can be handy
01:45:20 <ski> ok
01:45:40 <EvilRanter> i've been meaning to investigate its funkier, fresher relatives ;]
01:46:01 <ski> fresher ? :)
01:46:26 <dons> Cale, http://www.cse.unsw.edu.au/~dons/blog/2006/08/26#m20 (mp3 player)
01:46:26 <lambdabot> Title: Haskell, hacking and other stuff
01:46:49 <Cale> dons: right, Excedrin mentioned :)
01:46:51 <EvilRanter> standard ML: 1990; OCaml: 1996 (I think...)
01:47:43 <ski> EvilRanter : m, yes .. i was just thinking of the concrete syntax
01:47:57 <EvilRanter> ;;
01:48:44 <ski> (i.e. OCaml being closer to original ML, than SML being close to that, in this regard)
01:58:23 <roconnor> does "one's" mean a possive, or "one is"?
01:58:58 <tennin> usually it's a possessive
01:59:34 <EvilRanter> you can usually figure from context
02:00:01 <tennin> it could also work as a contraction though
02:00:06 <EvilRanter> "one's irate" vs "one's irritation"
02:00:16 <EvilRanter> or would the posessive be "ones"?
02:00:44 <tennin> no, the possessive is definitely "one's"
02:01:30 <tennin> "its" is the only weird one
02:01:54 <EvilRanter> and hers
02:02:22 <tennin> oh, right
02:02:29 <sieni> EvilRanter: I don't think it's any more weird than "mine" or "yours"
02:02:47 <EvilRanter> i suppose
02:03:00 <EvilRanter> theirs?
02:03:11 <tennin> I guess you could say "one's"ã€€is actually the odd one out since the other possessive pronouns all lack apostrophes (right?)
02:03:16 <EvilRanter> "its" is only weird because it's _almost_ normal, anyway
02:04:36 <roconnor> 2^32
02:04:41 <roconnor> > 2^32
02:04:42 <lambdabot>  4294967296
02:09:47 <johnnowak> EvilRanter: its isn't abnormal â€“ it is the same as his, hers, et cetera.
02:10:38 <EvilRanter> I mean people only get confused because "its" is almost like "<non-pronoun>'s"
02:11:14 <johnnowak> This is true. It's useful as a test to see if people are paying attention when they write you an email.
02:14:57 <road_> Hello
02:16:04 <road_> I'm trying to install JRegex, but get this error:
02:16:11 <road_> root@runner:/tmp/JRegex# runhaskell Setup.hs build
02:16:12 <road_> Preprocessing library JRegex-1.0...
02:16:12 <road_> Building JRegex-1.0...
02:16:12 <road_> Chasing modules from: Text.JRegex,Text.JRegex.Posix,Text.JRegex.PCRE,Text.JRegex.Impl
02:16:15 <road_> Could not find module `Monad': use -v to see a list of the files searched for (imported from ./Text/JRegex.hs)
02:17:03 <road_> Why doesn't it find the Monad module?
02:17:57 <Excedrin> building from the tarball?
02:18:20 <road_> yes
02:21:14 <Excedrin> the cabal file needs to be updated, the one in darcs works fine for me
02:22:10 <Excedrin> you can simply add haskell98 to the Build-Depends: line, and add another line: Extra-Libraries: pcre
02:22:40 <Excedrin> for the first: Build-Depends: base, haskell98
02:25:09 <road_> Thanks. The version from darcs is working fine.
02:33:19 <joelr1> good morning
02:38:00 <joelr1> dons: ping
02:38:37 <dons> yo (barely here though)
02:42:38 <joelr1> dons: any suggestions on the INSTANCE_TYPEABLE1 error in src/AltData/Typeable.hs?
02:43:22 <dons> you can't use hs-plugins with ghc 6.6 yet!
02:43:38 <dons> it just won't work. even if you get it to compile: the hi file format has changed
02:43:58 <joelr1> dons: i know, you told me. i'm trying to fix
02:44:00 <dons> basically, all the AltData/Typeable can be tossed out now
02:44:04 <joelr1> dons: or see if i can fix anyway
02:44:11 <dons> since Typeable.hs in Data works fine with dyn linked code these days
02:44:16 <dons> so you can start by tossing it out
02:44:25 <dons> then fix the .hi file parser to match the current .hi data type in ghc
02:44:30 <dons> and then we'll basically be done
02:44:37 <dons> modulo a couple of wibbles
02:44:42 <joelr1> dons: how simple and straightforward!
02:44:55 <dons> yep
02:45:08 <dons> talk to Lemmih, he's had a go, and almost done, I think
02:45:11 <dons> Lemmih, around?
02:48:21 <dons> joelr1: feel free to mail me questions and any progress you make
02:48:29 <joelr1> dons: sure
02:48:51 <joelr1> dons: so i should be importing Data.Typeable everywhere instead, right?
02:50:14 <dons> yep
02:51:14 <joelr1> dons: last question... where should i look for the hi data type in dhc?
02:51:59 <dons> ghc/compiler/iface/BinIface.hs
02:52:07 <joelr1> dons: thanks!
02:52:10 <dons> basically we have a copy of that data type in Language.*
02:52:17 <dons> and we need to match it exactly to parse it :)
02:52:30 <joelr1> dons: i get it
03:08:22 <kolmodin> anyone like to update me on the status of hIDE?
03:10:30 <gour> kolmodin: Lemmih is probably the one
03:12:35 <kolmodin> Lemmih: hello.... :)
03:19:28 <ivanm> dons: can you give me a hand getting lambdabot and GOA to work? gour said I should try bugging you about it ;)
03:19:42 <dons> ivanm: what doesn't work?
03:20:02 <ivanm> Well, I managed to get lambdabot to work (I think...), and I installed GOA
03:20:09 <joelr1> dons: Language/Hi/Parser.hs doesn't seem to use a lot of structures from BinIface.hs, most of the file is commented out
03:20:10 <dons> you've built and installed goa, and copied the .ghci file into your home dir?
03:20:27 <ivanm> yeah, but none of the lambdabot commands seem to do anything
03:20:40 <gour> here lambdabot just crashes
03:21:01 <ivanm> When I run ghci, I get: [1 of 1] Compiling GOA              ( /home/ivan/lambdabot/goa/src/GOA.hs, interpreted )
03:21:01 <ivanm> Ok, modules loaded: GOA.
03:21:11 <ivanm> that should have been in the one message :s
03:21:15 <gour> when executed under as ../lambdabot/lambdabot
03:22:22 <dons> joelr1: right. we only need a very mall part of it (the first 10 or so fields)
03:22:26 <ivanm> I just noticed: lambdabot only works for me if I run it from the directory I compiled it in
03:23:08 <gour> here it works only under /build
03:23:10 <dons> ivanm: yes, that's right
03:23:31 <ivanm> So what can/should I do?
03:23:52 <dons> $ cd lambdabot
03:23:52 <dons> $ ./lambdabot
03:23:52 <dons> Initialising plugins ................................................... done.
03:23:52 <dons> lambdabot> pl \x f y -> f y
03:23:52 <dons> const id
03:23:54 <dons> lambdabot> Exception: <eof>
03:24:00 <dons> ivanm: did you build goa?
03:24:09 <dons> did you install it and copy the .ghci file into your home dir?
03:24:14 <dons> and update it to point to your lambdabot install?
03:24:55 <ivanm> I didn't build it, just used darcs to pull the GOA folder, updated the dot-ghci file, copied it to ~/.ghci and then modified the GOA.hs file to point to the lambdabot binary
03:25:03 <dons> you have to build it
03:25:06 <dons> please follow the readme!
03:25:47 <gour> dons: if i do above, lambdabot jsut exits. if i start lambdabot  as ../lambdabot/dist/build/lambdabot/lambdabot, then i get: Initialising plugins ..........Plugin.Djinn: couldn't find djinn binary
03:25:47 <gour> ......................................... done.
03:25:59 <ivanm> I followed the readme for GOA: it doesn't mention building it anywhere!
03:26:04 <gour> dons: i built both, but still nothing
03:26:11 <dons> -- Build
03:26:12 <dons>     $ chmod +x Setup.hs
03:26:12 <dons>     $ ./Setup.hs configure --prefix=/home/dons
03:26:13 <ivanm> the TODO file mentions CABAL, but says it doesn't work yet
03:26:14 <dons> ...
03:26:48 <dons> ivanm: do you have the right version of goa?
03:26:51 <ivanm> what should the prefix point to?
03:26:58 <gour> dons: why lambda does not execute in build dir, but jsut exits?
03:27:12 <dons> ivanm: there's no TODO file in goa...
03:27:19 <ivanm> whoops, I seem to have gotten someone elses copy :s
03:27:20 <dons> gour: not sure. try removing State/seen
03:27:38 <ivanm> I was looking on the net to find the command required to pull it (haven't used darcs before) and got the wrong one
03:27:46 <ivanm> I'll fix that up now and try it
03:27:47 <gour> dons: thanks. it helps
03:28:39 <gour> dons: that's fixes everything! thanks a lot.
03:28:55 <gour> ivanm: your bugging fixed my problem :-)
03:30:24 <ivanm> dons: where in GOA.hs should I set the path to lambdabot?
03:30:34 <gour> ivanm: in dot-ghci
03:30:52 <ivanm> the README says I should do it in GOA.hs :s
03:31:25 <ivanm> and is that the path to the binary or to the folder containing the binary?
03:31:35 <gour> ivanm: to the darcs repo folder
03:31:50 <ivanm> OK, thought so
03:32:12 <ivanm> then I should replace /home/dons for the prefix to my own home directory I presume? ;)
03:32:26 <gour> right
03:32:41 <kep> dons: hi, I have read hIDE design, could you help to add some sources of ideas to the hIDE UI ?
03:33:40 <ivanm> gour: I got an error when installing GOA, should I be doing that as root (or sudo-ing)?
03:33:59 <gour> ivanm: yes, i installed via su
03:34:47 <ivanm> gour: ghci says "No lambdabot process"
03:34:56 <ivanm> what could I have done wrong?
03:35:25 <dons> you can install without root using --user
03:35:27 <gour> ivanm: no idea...and now i'm into video editing, try with dons, please
03:36:02 <ivanm> gour: OK, thanks
03:36:09 <gour> ivanm: bbl
03:36:25 <ivanm> dons: should I be running lambdabot before I run ghci?
03:36:35 <dons> nope
03:36:35 <ivanm> it says "No lambdabot process" :s
03:37:09 <dons> all that is needed is your .ghci file is the same as the dot-ghci file, but with setLambdabotHome "/home/dons/lambdabot" replace to point to your lambdabot repo
03:37:13 <ivanm> Hang on, I worked it out
03:37:25 <dons> great
03:37:36 <ivanm> it's becuase I was using it to run a haskell file I'm working on, it must have overwritten the GOA  commands :s
03:37:44 <ivanm> thanks for all your help dons!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1 :D
03:38:07 <dons> $ ghci
03:38:08 <dons> GOA> :pl \x f -> f x
03:38:08 <dons> flip id
03:38:12 <ivanm> Except now I can't run both GOA and my own haskell file :(
03:38:13 <dons> is how it should behave
03:38:30 <dons> ivanm: yeah, that seems to be a new bug in ghc 6.6 and goa. noticed it yesterday
03:38:34 <dons> haven't got a fix yet
03:38:40 <ivanm> OK, thanks for that!
03:38:47 <ivanm> GOA seems to be running right now!!!
03:39:26 <ivanm> Just one thing: if I do ":hoogle map", the first line of output is indented by a space, whilst the next two aren't: is this deliberate?
03:41:41 <ivanm> Also, when using ":list", is it meant to point to your website?
03:43:38 <chr1s_> I'm working on a parser
03:43:51 <dons> probably
03:43:57 <chr1s_> but it looks to me as if Parsec.Token is broken
03:44:54 <chr1s_> when I do a "parse (Token.identifier lexer) "" "abc(((" " it returns Right "abc"
03:45:00 <dons> ivanm: probably just an artifact of the irc bot :)
03:45:06 <chr1s_> where it should return a parse error
03:45:09 <dons> (sorry, network's a bit flakey today)
03:45:25 <Cale> chr1s_: parsers parse the initial part of the input, and are not required to eat it all
03:45:34 <ivanm> dons: thanks! also, what is :pl meant to do?
03:45:47 <chr1s_> Cale: yes, but when I run parse it should eat it all, right?
03:45:51 <Cale> no
03:45:56 <Cale> parse (Token.identifier lexer >> eof)
03:46:09 <chr1s_> ah ok
03:46:12 <chr1s_> thanx
03:47:01 <Cale> no problem
03:47:42 <Cale> eof = notFollowedBy anyToken <?> "end of input"
03:47:46 <dons> ivanm, pointfree refactoring
03:47:48 <Cale> such a nice definition :)
03:47:48 <dons> ?wiki Pointfree
03:47:49 <lambdabot> http://www.haskell.org/haskellwiki/Pointfree
03:48:12 <shankys> I have a quick question. Does anyone know how given "data Foo = Foo {bar :: String, baz :: String}" one might convert something of type Foo to the following list: "[bar, baz]"? I want to be able to do it not just on Foo but any arbitrary type I define in that way.
03:48:41 <Cale> shankys: in general, it'll be impossible, as your fields will have different types
03:48:46 <ivanm> dons: so its used to help you simplify your code by finding cleaner definitions?
03:49:03 <Cale> shankys: but you could write a typeclass for it, and instances of that class
03:49:11 <Cale> for example
03:49:15 <shankys> what if I can guarantee that they all have the same type?
03:49:25 <Cale> class Stringlistable a where
03:49:29 <shankys> that I will have all strings
03:49:36 <Cale>    strList :: a -> [String]
03:49:51 <Cale> instance Stringlistable Foo where
03:50:14 <Cale>    strList f = [bar f, baz f]
03:50:29 <dons> ivanm, yep
03:50:44 -AmEnOphiS(n=SoulShin@AVelizy-153-1-56-37.w86-205.abo.wanadoo.fr)- ** Notice ** : Allez voir mon petit animal de compagnie sur http://www.animals-superstars.com/photo-26052.html , merci pour lui :)
03:50:45 -AmEnOphiS(n=SoulShin@AVelizy-153-1-56-37.w86-205.abo.wanadoo.fr)- ** Notice ** : Allez voir mon petit animal de compagnie sur http://www.animals-superstars.com/photo-26052.html , merci pour lui :)
03:50:47 <AmEnOphiS>  Allez voir mon petit animal de compagnie sur http://www.animals-superstars.com/photo-26052.html , merci pour lui :)
03:50:48 <AmEnOphiS>  Allez voir mon petit animal de compagnie sur http://www.animals-superstars.com/photo-26052.html , merci pour lui :)
03:50:50 <lambdabot> Title: Rendez un animal superstar, un dr&ocirc;le de jeu gratuit pour enfants et adulte ...
03:50:50 <lambdabot> Title: Rendez un animal superstar, un dr&ocirc;le de jeu gratuit pour enfants et adulte ...
03:51:12 --- mode: ChanServ set +o Cale
03:51:17 <dons> grr
03:51:19 <ivanm> dons: does it work with list comprehensions as well?
03:51:26 <dons> ivanm, don't think so
03:51:39 <dons> you'll have to translate the list comprehension to a map
03:51:41 --- mode: Cale set +b *!*SoulShin@*.wanadoo.fr
03:51:49 --- mode: Cale set -o Cale
03:52:07 <ivanm> dons: well, it gave me an error when I tried to do so, so I guess it didn't
03:52:08 <Cale> shankys: does that approach make sense?
03:52:19 <ivanm> and I can't think of a way to turn the list comprehension into a map :s
03:52:26 <shankys> kind of
03:52:35 <shankys> I think I'll get it if I think about it a little more
03:53:13 <|Fo|Ns> hi all
03:54:37 <vincenz> Aloha
03:59:04 <dons> ivanm, well, [f x | x <- xs ] == map f xs
03:59:32 <ivanm> I'm trying to do [xs \\ x | x <- xs]
03:59:54 <ivanm> i.e. I want to create a list of sublists, where each sublist is missing one of the elements
04:00:07 <ivanm> actually, that should be [xs \\ [x] | x <- xs]
04:01:10 <ivanm> So, I suppose I could do it as: map (\ x -> (\\) xs [x]) xs
04:01:26 <ivanm> or map (\ x -> xs \\ [x]) xs
04:02:13 <ivanm> but :pl doesn't like "\\", so it isn't helpful in finding a pointfree version
04:02:30 <guerra> could someone tell me how can i learn what are monads and how to use them?
04:03:36 <ivanm> guerra: http://www.haskell.org/tutorial/monads.html?
04:03:37 <lambdabot> Title: A Gentle Introduction to Haskell: About Monads
04:03:51 <ivanm> or just google tutorial and monads?
04:04:08 <dons> ?pl map (\ x -> xs f [x]) xs
04:04:08 <lambdabot> map (xs f . return) xs
04:04:13 <guerra> thanks
04:04:37 <Heffalump> that can't be type correct
04:04:58 <ivanm> dons: duh, I didn't think of doing it generically :s
04:05:07 <Heffalump> @type  map (\ x -> xs f [x]) xs
04:05:08 <lambdabot> Not in scope: `xs'
04:05:08 <lambdabot>  
04:05:08 <lambdabot> <interactive>:1:15: Not in scope: `f'
04:05:15 <Vq^> Heffalump: well, the second version is more general
04:05:26 <ivanm> what does "return" do?
04:05:29 <Heffalump> @type \xs f -> map (\ x -> xs f [x]) xs
04:05:29 <Vq^> Heffalump: so there shouldn't be a conflict
04:05:30 <lambdabot>   Couldn't match `[a]' against `t -> [a] -> b'
04:05:30 <lambdabot>    Expected type: [a]
04:05:39 <dons> ?pl map (\ x -> f xs [x]) xs
04:05:40 <lambdabot> map (f xs . return) xs
04:05:46 <Heffalump> oh, right :-)
04:05:49 <dons> i.e. map ((\\) xs . return ) xs
04:06:01 * Heffalump wasn't paying attention above
04:06:52 <ivanm> what does "return" do?
04:07:31 <dons> it wraps a value in a monadic container
04:07:34 <dons> in this case, the list monad
04:07:36 <dons> i.e. (:[])
04:07:44 <ivanm> Ahhhh, OK
04:08:14 <ivanm> so, which form would be more efficient? list comprehension, pointfree or pointful?
04:08:32 <vincenz> profile it :)
04:09:17 <vincenz> in theory, however, since they can be automatically translated from one to the other
04:09:20 <vincenz> they should have similar performances
04:09:33 <vincenz> of course in practice, theory never holds up
04:09:44 <ivanm> well, I was hoping that people would know which one would have the most efficient implementation (in particular, mapping and  list comprehensions)
04:10:21 <vincenz> probably identical
04:10:34 <Heffalump> list comprehensions are always desugared to list operations like map, AFAIK
04:11:18 <dons> should be pretty much identical. if in doubt, profile
04:11:23 <ivanm> fair enough, but I presume its generally preferred to have it pointfree so that you don't have to worry about variable names when writing your function?
04:11:26 <dons> (or inspect the Core )
04:11:53 <Heffalump> use whatever style you find comfortable
04:12:58 <ivanm> OK, thanks.  I'm not particularly fussy which version I use, but the pointfree style (now that I know what it's called) looks cleaner
04:13:13 <ivanm> and keeps the lines shorter ;)
04:15:25 <dons> ?users
04:15:25 <lambdabot> Maximum users seen in #haskell: 278, currently: 236 (84.9%), active: 21 (8.9%)
04:20:49 <vincenz> ivanm: pointfree gets uglier with more complex code
04:21:05 <ivanm> Yeah, I suppose so :(
04:21:16 <vincenz> > replicate 236 "lambda-cookie"
04:21:18 <lambdabot>  ["lambda-cookie","lambda-cookie","lambda-cookie","lambda-cookie","lambda-coo...
04:21:59 <ivanm> which demonstrates what?
04:22:28 <vincenz> Nothing, 236 users, I'm giving them all a lambda-cookie
04:22:29 <vincenz> "take 1"
04:23:02 * ivanm gets embarrased
04:23:21 <ivanm> So, what does "$" do? I tried using the examples given at http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v%3A%24, but the first one didn't seem to work :s
04:23:23 <lambdabot> http://tinyurl.com/ovjef
04:23:31 <vincenz> ivanm: applies a function to an argument
04:23:34 <vincenz> f $ 1 == f 1
04:23:39 <vincenz> however $ has low priority
04:23:39 <vincenz> so
04:23:48 <vincenz> g . f $ 1 = g (f 1)
04:23:51 <vincenz> and
04:23:56 <vincenz> g . f 1 = g . (f 1)
04:24:27 <ivanm> well, the wiki has as an example: map ($ 0) xs
04:24:37 <ivanm> > map ($ 0) [1..5]
04:24:37 <lambdabot>  add an instance declaration for (Num (a -> b))
04:24:38 <lambdabot>   In an arithmetic sequenc...
04:24:38 <vincenz> xs should be a list of functions
04:24:52 <vincenz> > map ($ 0) [* 1, + 1, / 1]
04:24:53 <lambdabot>  Parse error
04:25:02 <vincenz> > map ($ 0) [(* 1), (+ 1), (/ 1)]
04:25:03 <lambdabot>  [0.0,1.0,0.0]
04:25:06 <ivanm> Oh, maybe I should have checked the type before trying to run it :s
04:25:27 <vincenz> > map ($ 1) [(* 2), (+ 2), (/ 2)]
04:25:28 <lambdabot>  [2.0,3.0,0.5]
04:25:38 <ivanm> so, is it used much?
04:25:48 <vincenz> not much like that
04:25:49 <vincenz> more like
04:25:52 <vincenz>  f . g . h $ x
04:25:57 <vincenz> apply (f . g . h) to x
04:26:13 <vincenz> otherwise you need to parenthesize the functions
04:26:20 <vincenz> (f . g . h) x
04:26:36 <ivanm> to simplify the application of function composition?
04:26:42 <vincenz> yep
04:26:52 <ivanm> I suppose that makes sense
04:27:22 <ivanm> its just that I'd seen several examples using "$", and I couldn't really understand what it was for, and why use it
04:27:56 <ivanm> and it didn't help when some tutorials/books also use "$$" for hugs ;)
04:28:08 <ivanm> though I managed to work out what _that_ meant
04:31:21 <nornagon> $ is like a ( that you don't have to close
04:31:27 <nornagon> that's how i usually think of it
04:32:23 <dons> > map ord . map toUpper $ "haskell"
04:32:24 <lambdabot>  [72,65,83,75,69,76,76]
04:33:24 <ivanm> OK, OK, I get it now, people can stop giving me examples :D
04:33:42 <ivanm> thanks everyone!
04:36:27 <nornagon> clean's arrays sure seem a lot nicer syntax-wise than haskell's
04:40:25 <dons> nornagon: do they have special syntax?
04:40:29 <dons> i don't think i've seen the arrays
04:40:54 <dons> we've got some plans for a new array base though, with a bytestring-like interface. should be nicer :)
04:43:41 <nornagon> they do, they use {}, iirc
04:43:45 <nornagon> maybe it isn't nicer
04:43:47 <nornagon> i forget
04:44:01 <nornagon> i look forward to the new array stuff, though :)
04:44:25 <dons> me too!
04:46:42 <astrolabe> dons: will it be a library or a change to the language?
04:46:54 <dons> new array library
04:47:00 <dons> with a decent interface, and fusible arrays
04:47:12 <dons> with bytestring and data parallel arrays on top
04:47:17 <astrolabe> static and mutable?
04:47:39 <dons> yeah, you'll need mutable ones as well
04:47:46 <dons> but with a rich enough interface, pure arrays will be fine
04:47:57 <astrolabe> I really like diffArrays
04:48:03 <dons> (i.e. like bytestrings on arbtitrary types)
04:49:13 <astrolabe> So, is there any chance of a DiffArray equivalent in your new stuff?
04:50:14 <Cale> the problem with mutable arrays is that you'd actually end up losing a lot of parallelisability
04:51:43 <astrolabe> Cale: That makes sense, but in a serious parallel application, you are likely to want multiple read/write access to an array I guess.
04:53:51 <Saizan> @paste
04:53:51 <lambdabot> http://paste.lisp.org/new/haskell
04:54:36 <lisppaste2> Saizan pasted "Cellular Automata, Life impl." at http://paste.lisp.org/display/31771
04:56:36 <astrolabe> ping dons
04:57:37 <dons> well, the old arrays probably won't disappear, so you'll keep DiffArray
04:57:47 <astrolabe> dons: ta
04:58:52 <Saizan> mmh, with DiffArray the diffs to the older versions are garbage collected if i don't have a reference to them?
04:59:08 <astrolabe> The reason I was pinging you is that it occured to me that it would be nice if I could use a special wild card in @seen, so '@seen ndm&' would do a union of ndm, ndm_ and ndm__
05:09:02 <manas> hello, cannot seem to get my first haskell program goin
05:09:13 <manas> Hugs.Base> inc n = n + 1 give me ERROR - Syntax error in input (unexpected `=')
05:10:04 <Botje> manas: you have to put your definitions in a file
05:10:17 <Botje> and the load the file with :l (subsequent reloads can be done with :r)
05:10:58 <manas> oh ... is there any interpreter I can use on interactively ?
05:11:07 <astrolabe> Saizan: yes
05:11:10 <manas> perhaps some emacs mode ?
05:11:28 <astrolabe> mana: you can use hugs interactively
05:11:42 <astrolabe> but you have to put definitions in files
05:11:54 <astrolabe> you can type expressions at the prompt
05:12:13 <Saizan> or use let .... in but it's not so convenient
05:12:20 <manas> astrolabe, oh, so I need to have a inc :: Int->Int in the file ?
05:12:39 <astrolabe> let works with ghci, it doesn't seem to with hugs
05:12:45 <astrolabe> maybe I made a mistake
05:13:04 <astrolabe> mana: the type signature is optional but a good idea
05:13:18 <Saizan> manas: you cand define functions in the interpreter you can only call them
05:14:07 <fasta> Where can free _type_ variables be introduced during type inference, and thus why can't the type ST s (STRef s a) (which I think is really forall a.ST s (STRef s a) be generalized to forall a.forall s.ST s (STRef s a)?
05:14:08 <manas> oh. ok.
05:14:19 <manas> I messed up definitions and declarations.
05:14:39 <manas> astrolabe, Botje, Saizan thanks a lot
05:14:50 <dons> astrolabe: ah cool idea.
05:14:56 <dons> you could submit a patch to use regexes in fact
05:14:59 <dons> would be pretty simple
05:15:01 <astrolabe> manas: tell us if it works
05:15:21 <dons> manas you can use ghci to declare new functions interactively
05:15:24 <dons> i.e. let f x = x
05:15:29 <manas> astrolabe, yes. Putting it in a file works
05:15:34 <astrolabe> dons: to understand lambdabot code, which .hs should I start with?
05:15:40 <astrolabe> manas: cool :)
05:16:13 <dons> Plugin/Seen.hs
05:16:32 <manas> well, out of hugs and ghci which can I expect to turn up least surprises ?
05:16:50 <dons> ghci :)
05:16:53 <dons> since you'll be able to compile things as well
05:17:49 <manas> dons, ok, I will move to ghci from hugs then
05:33:24 <dons> ?yow
05:33:24 <lambdabot> One FISHWICH coming up!!
06:17:46 <dcoutts__> @yarr!
06:17:47 <lambdabot> Eat maggoty hardtack, ye unkempt, jenny frequentin', son of a gun.
06:17:52 * dcoutts__ is in Oslo train station
06:18:23 * dcoutts__ is just pushing some patches he recorded on the train
06:18:28 * dcoutts__ loves darcs
06:18:43 <augustss> Oslo, eh?
06:19:24 <dcoutts__> aye, just waiting for the next train to Geilo
06:25:31 <kyevan> Mreh
07:05:37 <dons> ?users
07:05:37 <lambdabot> Maximum users seen in #haskell: 278, currently: 246 (88.5%), active: 19 (7.7%)
07:07:04 <dons> Cale: why do I have an automatic reflex to mod down anything titled ' Corporate Cadence - Using Agile to deliver massive functionality' ?  Am I a bad person?
07:07:31 <augustss> @users
07:07:31 <lambdabot> Maximum users seen in #haskell: 278, currently: 246 (88.5%), active: 19 (7.7%)
07:09:17 <SamB_XP> @all-dict cadence
07:09:20 <lambdabot> *** "Cadence" gcide "The Collaborative International Dictionary of English v.0.48"
07:09:20 <lambdabot> Cadence \Ca"dence\, v. t.
07:09:20 <lambdabot>   To regulate by musical measure.
07:09:20 <lambdabot>   [1913 Webster]
07:09:20 <lambdabot>  
07:09:22 <lambdabot> [105 @more lines]
07:09:34 <SamB_XP> that sounds extremely unlikely!
07:11:19 * eviltwin_b initially thought f the chip design software (gee, wonder why?) --- even less likely :>
07:12:05 <SamB_XP> that makes sense for chip design software, though, I think ;-)
07:12:19 <dmead> :>
07:12:52 <SamB_XP> a musical measure being like unto a clock cycle
07:13:50 * eviltwin_b was thinking more along the lines of agile web environments developed in Cadence
07:13:56 <eviltwin_b> (head splodey...)
07:14:19 <dmead> :<
07:14:22 <SamB_XP> well, I meant that the name Cadence for chip design software makes a lot more sense than the name of that article ;-)
07:15:37 <kyevan> tuple1 :: Tuple t3 t t1 t2 -> t3
07:15:42 <kyevan> That... makes no sense.
07:16:01 <SamB_XP> kyevan: you mean the numbering?
07:16:08 <kyevan> Well, I can read it, but why on earth is it t3 t t1 t2? wouldn't t t1 t2 t3 make more sense ot a human?
07:16:11 <kyevan> SamB_XP: Yah.
07:16:28 <SamB_XP> you expect too much from the poor typechecker!
07:16:29 <kyevan> Of course, the numbering is pretty much arbitrary, and has no meaning.
07:16:36 <SamB_XP> exactly
07:16:40 <dons> kyevan: you mean an artifact of the type checker produce that tyvar order?
07:16:45 <kyevan> SamB_XP: Typecheckers should learn to count, though :P
07:16:48 <dons> feel free to alpha rename :)
07:16:53 <SamB_XP> it does know how to count
07:17:09 <SamB_XP> it just doesn't know how to name them in left-to-right order, apparantly!
07:17:15 <eviltwin_b> it's counting... in order of type reductions or inferences, no doubt
07:17:27 <SamB_XP> (that is, it doesn't know how to *rename* them that way)
07:17:42 <eviltwin_b> be interesting to see if you could reverse engineer its algorithm from the ordering of tyvars
07:17:43 <Saizan> some hint on how to convert 13mb of ASCII in a graphic equivalent png?
07:17:58 <Baughn> Saizan: OCR?
07:17:59 <SamB_XP> Saizan: carefully!
07:18:13 <SamB_XP> I'd suggest multiple PNGs
07:18:34 <jacobian__> ocrad is workable if the text is relatively clean
07:18:35 <Saizan> Baughn: OCR? wasn't that for the inverse?
07:18:41 <SamB_XP> perhaps paginate the material before making PNGs of them
07:18:54 <SamB_XP> er. them being pages.
07:18:55 <Baughn> Saizan: Perhaps I misunderstood. Do you have ascii and want pngs?
07:18:57 <Saizan> err, i don't want it paginated
07:18:58 <eviltwin_b> FFI for AAlib?
07:19:08 <Saizan> Baughn: yes
07:19:17 <SamB_XP> Saizan: well, it wouldn't be really paginated....
07:19:44 <Baughn> Saizan: That should be pretty simple.. you could make an FFI to freetype for us, yes? :)
07:19:49 <SamB_XP> unless you honoured page-feeds
07:20:31 <SamB_XP> anyway, I would really suggest you not try to fit all of it in one PNG
07:20:37 <Saizan> Baughn: when i see FFI i run very fast in the opposite direction
07:20:41 <SamB_XP> probably most programs are not designed to read mile-high PNGs
07:21:17 <Baughn> Saizan: Time to learn. SamB_XP's probably right, though: 12 MB of text would make a truly giant PNG.
07:21:33 <SamB_XP> Saizan: did you want it typewriter style, or did you want a proportional font?
07:21:49 <Saizan> mmh, it really is a cellular automata optput, so there are only spaces and '*', so the better would be a 2x2 pixel square for each char, and it would be huge but not so huge
07:22:02 <SamB_XP> ah
07:22:11 <SamB_XP> thats a lot different from what you proposed initially ;-)
07:22:36 <jacobian__> It would probably be very easy to convert to a pgm file
07:22:44 <SamB_XP> why pgm?
07:22:49 <Saizan> pgm?
07:22:51 <Baughn> xpm?
07:22:52 <SamB_XP> wouldn't ppm be better
07:22:54 <SamB_XP> ?
07:23:13 <Saizan> err, what are them?
07:23:20 <Baughn> Saizan: Image formats
07:23:28 <eviltwin_b> why would ppm be better?  sounds like pbm to me, just 2 colors
07:23:32 <jacobian__> Yeah sure or a ppm
07:23:36 <jacobian__> yeah pbm :)
07:23:37 <Baughn> Saizan: Mind you, you /could/ interface to libpng directly
07:23:41 <Saizan> easy to write?
07:23:41 <eviltwin_b> portable {bit,gray,pix}map
07:23:50 <SamB> which work will with the pnmtools
07:24:16 <jacobian__> then you could just use command line tools to turn it into a png
07:24:32 <Baughn> Saizan: ppm is a /really/ simple file format. It'd work well, I think.
07:24:36 <SamB> their only point is being easy to read/write and having a lot of tools to operate on them/convert them to more complicated formats
07:25:09 <Saizan> ook, that would be nice
07:25:10 <jacobian__> http://netpbm.sourceforge.net/doc/pbm.html
07:25:12 <lambdabot> Title: The PBM Format
07:25:18 * Baughn ponders the insanity of a line-based ASCII image format
07:25:24 <SamB> also ppm(5)
07:25:30 <SamB> Baughn: it isn't insane
07:25:37 <SamB> it just isn't meant for storage
07:25:45 <Baughn> SamB: Everything's insane. This is merely slightly more so.
07:25:47 <eviltwin_b> actually, if it's space or * for 0 and 1 pixels, it should be trivial to convert to pbm
07:25:48 <SamB> you'd *definately* want to write it to stdout
07:26:06 <SamB> and pipe directly to pnmtopng
07:26:43 <Saizan> mmh i'm on windows :D
07:26:47 <Baughn> eviltwin_b: You could do it with tr, I guess
07:26:51 <SamB> hmm.
07:26:56 <jacobian__> cygwin?
07:27:22 <SamB> jacobian__: you think cygwin makes pipes work better?
07:27:26 <SamB> well, lets see...
07:27:42 * EvilRanter wrote a perl not-very-many-liner for translating "#."-style monochrome bitmaps to PBMs
07:27:51 <jacobian__> it makes it easy to get programs like pnm2png etc.
07:27:52 <Baughn> eviltwin_b: One-liner, you mean
07:27:55 <EvilRanter> i think i passed them straight to Tcl
07:27:59 <SamB> > 12 * 4 * 3
07:28:07 <lambdabot>  144
07:28:12 <Baughn> EvilRanter: ...one-liner, you mean
07:28:13 <EvilRanter> Baughn, no, i'm afraid it had more than one line
07:28:21 <eviltwin_b> heh
07:28:37 <SamB> okay, so it would take 144 MB to store a ppm with 2x2 blocks...
07:28:52 <jacobian__> there is a binary format for pbm
07:28:59 <jacobian__> which is also easy to work with
07:29:00 <SamB> jacobian__: yes, thats true
07:29:10 <dons> sounds like a job for bytestrings!
07:29:13 <EvilRanter> the guts of it was one line, but it had a heredoc for the header and curlies
07:29:33 <SamB> > 12 * 3
07:29:34 <lambdabot>  36
07:30:05 <SamB> about 36 MB for a non-scaled-up ppm
07:30:38 <Saizan> do you know if spaces at the start or at the end of a line in pbm are problematic?
07:31:11 <SamB> dunno!
07:31:25 <jacobian__> from the docs:
07:31:31 <jacobian__> "Programs that read this format should be as lenient as possible, accepting anything that looks remotely like a bitmap."
07:31:52 <jacobian__> :)
07:32:24 <Saizan> ok, so i just have to replace the "show" function :D
07:34:56 <kyevan> Argh! How do I handle a function that gives back something of one of four types? (Either a value, or a pair, or a triple, or a quadruple)
07:35:35 <SamB> Saizan: those figures were for the *binary* variant!
07:35:45 <dons> data T a b c d = T1 a | T2 a b | T3 a b c | T4 a b c d
07:36:01 <kyevan> dons: ... That's what I'm comeing from
07:36:16 <SamB> kyevan: those aren't types
07:36:34 <kyevan> SamB: ?
07:36:34 <dons> kyevan: a trick using phantom types, then: http://www.cse.unsw.edu.au/~dons/tmp/Phantom.hs
07:36:56 <kyevan> But, uh...
07:37:01 <kyevan> wha?
07:37:08 <dons> actually, they're not true phantoms I think
07:37:12 <SamB> case f x y of T1 z -> g z; ...
07:37:16 <dons> just keys to index the right instance
07:37:17 <kyevan> I'm just tring to do YAHT 4.7!
07:37:29 <dons> kyevan: then see above :) you need a sum type
07:37:36 <kyevan> Insert an "exercise" there
07:37:46 <kyevan> dons:  the data T a b c d... line?
07:37:59 <kyevan> That's what this function is being passed.
07:38:08 <SamB> pattern matching!
07:38:11 <kyevan> Only with the name "Tuple", and "Tuple1" etc.
07:38:14 <Saizan> i resolved that with nested Either at the time
07:38:15 <dons> Q. "How do I handle a function that gives back something of one of four types?"
07:38:18 <dons> A. with case
07:38:35 <dons> its not giving back 4 types, its giving back one
07:38:38 <dons> with 4 constructors :)
07:38:49 <SamB> f (Tuple1 x) = x
07:38:56 <SamB> f (Tuple2 x _) = x
07:39:03 <SamB> f (Tuple3 x _ _) = x
07:39:07 <kyevan> dons: It's either a value, or a haskell-pair, or a haskell-triple, or a haskell-quadruple
07:39:12 <SamB> f (Tuple4 x _ _ _) = x
07:39:13 <kyevan> That's 4 types, right?
07:39:18 <SamB> no!
07:39:45 * kyevan is lost
07:39:55 <SamB> data constructors aren't types
07:40:16 <EvilRanter> "unexpected signal" ?!
07:40:30 <kyevan> SamB: but, wha?
07:40:36 <dons> ?paste
07:40:36 <lambdabot> http://paste.lisp.org/new/haskell
07:40:50 <kyevan> Isn't (a,b) a different type than a or (a,b,c)?
07:40:58 <rindolf> kyevan: it is.
07:41:01 <dons> it is. but not once you wrap it in a T2
07:42:11 <kyevan> Aiy, what it seems you want me to do is to take my value passed in, and pass the same thing out with an IDENTICAL TYPE with IDENTICAL CONSTRUCTORS with a different name.
07:42:40 <lisppaste2> dons pasted "help out a lambda man" at http://paste.lisp.org/display/31780
07:43:00 <lisppaste2> kyevan pasted "untuple doesn't work..." at http://paste.lisp.org/display/31781
07:43:28 <kyevan> I tried it without the left and right, and that didn't work either
07:43:41 <dons> kyevan: nested Eithers were suggested
07:43:50 <dons> remember that Either a b = Left a | Right b
07:43:59 <dons> so how are you going to use that to wrap 4 possible options?
07:44:06 <kyevan> dons: so...
07:44:19 <dons> Right (a,b,c) and Right (a,b,c,d) have different types. not good!
07:44:26 <Igloo> Is anyone with ghc 6.6 and PPC/MacOS around?
07:44:44 <eviltwin_b> yeh
07:44:58 <dons> kyevan: you need to nest Eithers such that you have a type constructor of kind * -> * -> * -> * ->* :)
07:45:09 <SamB> Igloo: isn't MacOS old?
07:45:31 <lisppaste2> Kyevan annotated #31781 with "Maybe this?" at http://paste.lisp.org/display/31781#1
07:45:41 <EvilRanter> huh. "rectangleRegion (x,y) (x+w,y+h) `subtractRegion` rectangleRegion (x+1,y+1) (x+w-1,y+h-1)" causes "Unexpected signal".
07:45:43 <Igloo> eviltwin_b: If that was to me, can you tell me if   echo 'main = return ()' > q.hs; ghc -threaded q.hs -o q; ./q +RTS -N2   works please?
07:45:52 <dons> :k Either a (Either b (Either c d)) -- perhaps hint hint
07:45:54 <lambdabot> Not in scope: type variable `a'
07:45:54 <lambdabot>  
07:45:54 <lambdabot> <interactive>:1:17: Not in scope: type variable `b'
07:46:06 <kyevan> That doesn't work either...
07:46:20 <dons> kyevan: sure it does. use the force!
07:46:29 <EvilRanter> any thoughts?
07:46:47 <kyevan> dons: FORCE a hammer into my mobo? >>_<
07:47:16 <dons> kyevan: try writing down the type of untuple first
07:48:46 <kyevan> dons: Um... "untuple :: Tuple a b c d -> Either a (Either (a,b) (Either (a,b,c) (a,b,c,d))"
07:49:00 <eviltwin_b> Igloo: RTS doesn't like -N2
07:49:09 <Igloo> eviltwin_b: OK, thanks
07:49:44 <Cale> dons: no, that's exactly the sort of thing we have to keep down :)
07:49:46 <eviltwin_b> (this is installed from the binary distribution, fwiw)
07:49:48 <ex0r> bit of a beginner question but if I have multiple things to call in one guard section, do I seperate them with a semicolon?
07:50:16 <ex0r> | something == 0 = s1; s1 p1; s2 p3; etc?
07:50:47 <kyevan> ex0r: You're much farther than me. I'm stull strugleing to make types not be hate.
07:50:49 <EvilRanter> ex0r, do these things have side-effects that you need?
07:51:00 <EvilRanter> or do you want their results in a list?
07:51:06 <EvilRanter> or what?
07:51:28 <dons> kyevan: no peeking though, until you have the answer: http://paste.lisp.org/display/31783
07:51:45 <dons> kyevan: you've quite close (the type is right!)
07:51:53 <ex0r> well In this particular cas I need to join two strings then call the function again recursively
07:52:10 <EvilRanter> er?
07:52:26 <EvilRanter> how would you write this, assuming your semi-colon thing was right?
07:53:18 <kyevan> AH HAH! I had an extra Left on the part for handleing the last case ^_^
07:53:24 <ex0r> actually on second thoughts I can probably just use where
07:53:42 <ex0r> would look neater anyway
07:53:49 <dons> kyevan++ using the force of types! :)
07:54:05 <EvilRanter> ex0r, it sounds like you may've been thinking of "let a = b++c in f a" or somesuch
07:55:06 <ex0r> yes, I think I was
07:55:06 <kyevan> I still have it wraped in the Eithers... hmm...
07:55:10 <EvilRanter> ex0r, see http://haskell.org/tutorial/patterns.html#sect4.5
07:55:12 <lambdabot> Title: A Gentle Introduction to Haskell: Patterns
07:55:45 <kyevan> Meh. I'll deal with that when I'm better with haskell and can figure out what I'm doing :P
07:58:31 <kyevan> Mweh. I'm never going to forget the scheme list definition. Ever. And Haskell's is identical, except the elements all have to be the same type
07:59:42 <ex0r> another completely unrelated question, would this work? ...where x = sm a b cd; cd = head c
07:59:57 <ex0r> where cd is defined after its used in a where statement
07:59:59 <lisppaste2> nominolo pasted "wxHaskell build error message" at http://paste.lisp.org/display/31784
08:00:03 <Saizan> i suppose so
08:00:05 <rindolf> ex0r: I think it will.
08:00:10 <ex0r> not sure how haskell works with those
08:00:12 <ex0r> hmm ok
08:00:28 <nominolo> can someone give some tips how to debug the above error message?
08:00:39 <Baughn> kyevan: The scheme list definition? "Either nil or a pair of <something> and a list"?
08:00:48 <rindolf> ex0r: yes, it does.
08:00:58 <rindolf> ex0r: I opened one of my programs and it contained it.
08:01:03 <kyevan> Baughn: We call nil empty, but yep
08:01:21 <Saizan> i think it's rather universal as a definition
08:01:44 <Baughn> I don't see how else you could define it, really
08:01:54 <Baughn> Not if you want to keep the same semantics
08:02:17 <ex0r> rindolf: thanks
08:02:33 <lisppaste2> pbx pasted "typo?" at http://paste.lisp.org/display/31785
08:02:34 <kyevan> Baughn: Yes, but I was seeing it in my dreams and such >_<
08:02:36 <pbx> Is this an error in the Haskell tutorial or is there something crazily subtle about sequences that I'm missing?
08:03:14 <Baughn> pbx: Something crazily subtle. ;)
08:03:18 <Saizan> pbx: it simply works like that
08:03:19 <Baughn> pbx: Try it in ghci
08:04:15 <pbx> Interesting, thanks. What's the rationale?
08:04:27 <Baughn> pbx: It's useful at times
08:05:51 <rindolf> pbx: it also works with variables.
08:06:06 <Saizan> > [2,3..7]
08:06:08 <lambdabot>  [2,3,4,5,6,7]
08:06:11 <Saizan> > [4,3..7]
08:06:12 <lambdabot>  []
08:06:52 <pbx> Saizan: According to the tutorial example, your first one should result in [2,3,4,5,6]
08:07:06 <eviltwin_b> nope :)
08:07:13 <eviltwin_b> you misunderstood the example
08:07:21 <Saizan> ooh, so THAT was a typo
08:07:27 <pbx> > [1,3..10]
08:07:28 <lambdabot>  [1,3,5,7,9]
08:07:46 <Saizan> err no
08:07:48 <pbx> OK, now I get it.
08:07:52 <EvilRanter> pbx, i think the rationale is that mathematicians sometimes write long lists like [x0, x1 .. xN]
08:08:25 <EvilRanter> when it's obvious what the progression is from the first two elements
08:08:42 <Lemmih> kolmodin: pong.
08:09:38 <pbx> EvilRanter, Saizan: Got it now, sorry!  You Haskell people sure are nice to idiots.
08:09:44 <EvilRanter> pbx, they're translated to these under the hood, if this helps things: http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v%3AenumFrom
08:09:46 <lambdabot> http://tinyurl.com/ovjef
08:10:06 <pbx> EvilRanter: Nice, thanks
08:10:23 <EvilRanter> > enumFromThenTo 1 3 10
08:10:25 <lambdabot>  [1,3,5,7,9]
08:12:21 <EvilRanter> @seen dcoutts
08:12:21 <lambdabot> dcoutts is in #haskell.hac07, #haskell-overflow, #haskell, #ghc and #gentoo-haskell. I don't know when dcoutts last spoke.
08:14:05 <pbx> > [1,3..9]
08:14:07 <lambdabot>  [1,3,5,7,9]
08:14:21 <kyevan> Why aer haskell people so nice to unsmart people like me?
08:14:28 <Heffalump> EvilRanter: he last appeared from Oslo station
08:14:40 <kyevan> I mean, you could just be like STFU NUB GO RTFM
08:14:46 <Heffalump> oh, ok, then
08:14:54 <Heffalump> kyevan: STFU NUB GO RTFM LOL.
08:15:03 <kyevan> But you aren't! Actuall, helpful people seem to exist here!
08:15:05 <dons> kyevan: half the channel are employed as tutors at universities :) you get fired for saying that kind of thing in class ;)
08:15:37 <dons> I'll be taking roll call at the end of the period, and you can hand in your assignments at the front desk. Thanks.
08:15:38 <EvilRanter> ...and the rest of us are the students of those tutors, and, being students, know how irritating "RTFM" is
08:15:44 <Heffalump> I do quite like having the freedom to be rude here. I only exercise it in extreme cases, though.
08:16:15 <dons> beware the disturbed Heffalump
08:17:22 <Heffalump> anyway, students are all stupid. Should be taken out and shot or something.
08:17:25 * vincenz wtfs dons and then fu2's Heffalump 
08:17:51 <Cale> kyevan: everyone started at some point
08:18:05 <dylan> a *lot* of people on freenode (and elsewhere) are unhelpful towards new comers...
08:18:05 <vincenz> Except for dons, he was born with it
08:18:14 <vincenz> dylan: No, most channels just breed trolls
08:18:16 <Heffalump> #haskell seems to me on average more helpful than most other channels
08:18:20 <vincenz> ##c and ##C++ being big examples
08:18:32 <eviltwin_b> well, that mnd most online geeks have terrible social skills
08:18:44 <EvilRanter> #perl is vicious
08:18:48 <sieni> perhaps haskellers are less frustrated that c or c++ coders ;-)
08:19:05 <EvilRanter> mathematicians evidently have better social skills tham programmers
08:19:11 <vincenz> no, ##c and ##C++ just have more general newbs and std-thumpers
08:19:11 <kyevan> eviltwin_b: social... skills? What are those, you big idiot?
08:19:25 <Cale> Having everyone be nice to you when you're learning also tends to turn you into someone who is nice to beginners.
08:19:39 <Heffalump> EvilRanter: that's ok, no self-respecting denizen of #haskell should be seen dead on #perl ;-)
08:19:42 <kyevan> (Sorry... I had to! It's the pants talking, not me!)
08:19:42 <vincenz> But even #ocaml which has a comparable language to haskell is rather bad
08:19:46 <vincenz> But that's mostly due to one person
08:19:49 <Cale> hmm
08:19:51 <vincenz> kyevan: take them off then
08:19:51 <pejo> dons, we have a bunch of assignemnts that students are supposed to hand in during compiler construction. One guy handed in all the answers and "kthxbye".
08:19:53 * EvilRanter is JAPH
08:19:56 <Heffalump> vincenz: who?
08:19:59 <dylan> vincenz: no, it's not just one person.
08:20:02 <vincenz> Heffalump: smerdy
08:20:04 <Heffalump> EvilRanter: my sympathies.
08:20:13 <Heffalump> vincenz: ah. He's still at it, then?
08:20:21 <vincenz> Heffalump: Dunno, been out of the loop for a while, but presumable
08:20:22 <vincenz> +y
08:20:29 <dylan> I was in #ocaml for a year or more, and I was about the only person that *ever* gave a straight answer.
08:20:35 <vincenz> dylan: same here
08:20:42 <EvilRanter> Heffalump, good luck reformatting a few thousand lines of log files easily in Haskell...
08:20:47 <defcon8> if one cannot change values of things in haskell, how do databases work?
08:20:50 <Heffalump> you were *BOTH* the only people that ever gave straight answers?
08:20:56 <vincenz> Heffalump: we're a singularity
08:21:10 <Heffalump> I guess the time periods could have been disjoint
08:21:10 <EvilRanter> haskell's my flavour of the month, but I use perl when I need to get things done :P
08:21:15 <vincenz> Heffalump: you an ms or a phd student?
08:21:21 <dons> i have a theory that having a type checker and evaluator in channel helps resolves disputes, and improves the progression of beginners
08:21:23 <dylan> I think vincenz left before I came, or was not talking when I was.
08:21:23 <kyevan> Heffalump: Well, presumably, Dylan and Vincenz have to sleep some time
08:21:30 <vincenz> kyevan: big presumption
08:21:30 <dons> we don't waste as much time trying to explain things -- we can just show them
08:21:33 <kyevan> I've never seen dylan sleep, though
08:21:36 <dons> and you can't argue with the type checker
08:21:42 <vincenz> kyevan: look at my #haskell stats.... I have equal output on all hours
08:22:00 * vincenz unsafeCoerce#'s dons 
08:22:10 <vincenz> dylan: 2004?
08:22:18 <Heffalump> vincenz: no
08:22:21 <dons> defcon8: you can change values. :)
08:22:26 <defcon8> wtf :|
08:22:32 <Heffalump> (haven't we talked before about what I do?)
08:22:33 <vincenz> I actually started hanging out in #haskell about a year if not more before I actually learned haskell, just was sick of #ocaml
08:22:35 <defcon8> isn't that a side effect, then?
08:22:45 <vincenz> Heffalump: have we talked before about my bad memory?
08:22:50 <dons> > let reformat s = "<" ++ s ++ ">" in reformat "its ok really"
08:22:51 <lambdabot>  "<its ok really>"
08:22:52 <Heffalump> vincenz: :-)
08:23:03 <pejo> vincenz, he can't remember. :P
08:23:08 * Heffalump did a DPhil(PhD) at Oxford several years ago
08:23:14 <vincenz> Ah right
08:23:19 <defcon8> Heffalump, bloody hell
08:23:25 <defcon8> Heffalump, where did you do your undergrad/
08:23:27 <dons> defcon8: if you mean: mutate a log file in place, you use a monad to encapsulate the side effect of mutating the file
08:23:32 <Heffalump> and is now employed at ARM, for the next three weeks, after which I shall be employed at Credit Suisse
08:23:35 * vincenz heard from his advisor on friday that he's supposed to end june 2008 *Swallow*
08:23:40 <vincenz> Heffalump: so you know my company
08:23:45 <Heffalump> defcon8: University of Surrey
08:23:46 <defcon8> dons, naah, just changing a variable
08:23:46 <vincenz> Heffalump: IMEC
08:23:50 <ex0r> does anyone have a link that goes through all the logic syntax for haskell?
08:23:53 <Heffalump> vincenz: we talked about that too :-)
08:23:55 <defcon8> Heffalump, what a-levels did you have to get there?
08:23:57 * vincenz ponders
08:24:05 <vincenz> Heffalump: refer back to my earlier point :)
08:24:08 <defcon8> and the grades
08:24:19 <araujo> hello
08:24:23 <Heffalump> defcon8: A-levels aren't important for PhD admission..
08:24:26 <defcon8> noo
08:24:28 <defcon8> undergrad
08:24:39 <pbx> Recommended build of GHC (binaries would be nice) for OS X?   Top Google hit is: http://www.cse.unsw.edu.au/~sseefried/files/ghc-nightly/
08:24:39 <lambdabot> Title: Index of /~sseefried/files/ghc-nightly
08:24:50 <vincenz> Heffalump: what will you be developing in at CS?
08:24:53 <Heffalump> oh, 2 As at double maths, but that was probably significantly overqualified for Surrey
08:24:58 <Heffalump> vincenz: not entirely sure yet
08:25:00 <dons> pbx: check the haskell.org/ghc page
08:25:05 <vincenz> Heffalump: an fp?
08:25:06 <defcon8> what is double maths?
08:25:12 <Heffalump> Maths+Further Maths
08:25:18 <defcon8> cool
08:25:22 <pejo> pbx, or use the macports package.
08:25:31 <vincenz> Heffalump: and you probably answered this bit too, do they use FPs at ARM?
08:25:50 <dons> defcon8: is the "changing a variable" thing still a mysy?
08:25:53 <Heffalump> FP in what sense?
08:25:56 <dons> mystery.
08:26:00 <defcon8> I plan to go to cambridge with advanced highers. What is very bad is that advanced highers are equivalent to a-levels and you need 4 A's in highers (AS level) and a As and a B in advanced
08:26:04 * vincenz coughs "FPl"
08:26:07 <defcon8> dons, x = 4 then x = 5
08:26:09 <Heffalump> oh, right
08:26:10 <Heffalump> not really
08:26:16 <Heffalump> that's one of the reasons I'm leaving :-)
08:26:23 <Heffalump> CS will be using Haskell.
08:26:25 <dons> (if so, just forget about mutable-by-default, its not required, and complicates programs)
08:26:27 <vincenz> h, neat :)
08:26:31 <defcon8> this sucks :(
08:26:36 <Heffalump> oh, you said developing "in" earlier, I missed that
08:26:38 <vincenz> Heffalump: in UK or in switzerland?
08:26:39 <dons> defcon8: why?
08:26:41 <Nafai> If y'all could recommend one Haskell / Functional Programming book, which one would it be?  I'm trying to give my gift wish list to my wife :)
08:26:45 <defcon8> dons, advanced highers
08:26:47 <Heffalump> vincenz: London
08:26:53 <Heffalump> defcon8: have you been interviewed yet?
08:27:00 <defcon8> no
08:27:01 <pejo> Nafai, beginners level?
08:27:04 <defcon8> haven't applied yet
08:27:08 * vincenz wouldn't mind working for CS in switzerland :)
08:27:10 <defcon8> applying next year. I'm sixteen
08:27:15 <vincenz> Especially if they do haskell devel
08:27:27 <benmos> I thought CS were just using Haskell in NewYork... they're using it in London too?
08:27:30 <Heffalump> I don't think their derivatives modelling group has any stuff there.
08:27:30 <kyevan> defcon8: I'm not the only 16 year-old here?
08:27:37 <defcon8> nope
08:27:38 <Heffalump> benmos: they want to have people in both places
08:27:49 <benmos> Interesting
08:27:58 <Nafai> pejo: Beginner to Haskell / FP, but experienced programmer
08:28:07 <Cale> man, I wish I knew about Haskell when I was 16 :)
08:28:18 <vincenz> Cale: same here :/
08:28:34 <vincenz> my kid will know haskell at the age of 8
08:28:35 <defcon8> Cale, when did you start getting very interested in mathematics?
08:28:39 <vincenz> First gotta walk em through scheme
08:28:41 <defcon8> and can you advise me of some good books to read
08:28:51 <Heffalump> defcon8: re the grade requirements, it's fairly standard for Oxbridge to want lots of As
08:28:52 <defcon8> I kind of envy your knowledge :$
08:29:16 * Heffalump realises he's been using Haskell for a third of his life
08:29:32 <defcon8> Heffalump, 30?
08:29:34 * vincenz has learned haskell 1 year ago
08:29:44 <Cale> defcon8: somewhere in the middle of highschool, I actually sucked at the "mathematics" which they taught up until then, I was good at highschool mathematics, but it wasn't really too inspiring, but then I got into reading some things on my own
08:29:50 <dons> i've been using it for 30.76%
08:29:52 <Saizan> is category theory helpful for haskell?
08:29:56 <nominolo> is wxHaskell dead?
08:29:57 <defcon8> Cale, what like?
08:29:59 <Cale> GÃ¶del, Escher, Bach changed my life :)
08:30:06 <dons> nominolo: nope. just been revivved
08:30:08 <pejo> Nafai, I used "The craft of functional programming" by Thompson, seemed pretty good. I've glanced through some pdf with the first chapters of Graham Huttons book, and those chapters seems good too. A bunch of other recommendations on books on haskell.org.
08:30:15 <Heffalump> defcon8: no, 30 years is not a third of my life :-p
08:30:16 <nominolo> dons: when?
08:30:26 <vincenz> Heffalump: sure it is, don't lie
08:30:27 <Nafai> pejo: Thanks, I saw that list and wasn't sure which to pick :)
08:30:34 <kyevan> listLength :: (Num b) => List a -> b
08:30:39 <dons> nominolo: http://thread.gmane.org/gmane.comp.lang.haskell.cafe/16364/focus=16364
08:30:40 <defcon8>  Qualifications are required in:
08:30:40 <defcon8>     * English
08:30:40 <defcon8>     * a language other than English
08:30:40 <Heffalump> and even if it was I couldn't have been using Haskell for that long
08:30:41 <defcon8> WTF!
08:30:42 <lambdabot> Title: Gmane Loom, http://tinyurl.com/y65n3z
08:30:44 <Cale> and mathworld, and random mathematics encyclopedias, and I started to get the sense that mathematics had far more to it than I was getting through highschool
08:30:46 <kyevan> Grah, stupid copying the newline
08:30:48 <nominolo> dons: it doesn't compile (out of the box) on GHC 6.6
08:30:51 <defcon8> I need a qualification in a language other than english?
08:30:55 <vincenz> Cale: which part interests you mostly, algebras?
08:31:00 <defcon8> I don't even have one in english :(
08:31:03 <Heffalump> defcon8: errm, no
08:31:09 <Heffalump> where did you find that?
08:31:11 <nominolo> dons: but i have this same problem: http://sequence.complete.org/node/214
08:31:14 <lambdabot> Title: to build wxHaskell, or what is the best GUI library on Haskell? | The Haskell Se ...
08:31:14 <defcon8> cambridge entry requirements
08:31:20 <Heffalump> got a URL?
08:31:20 <Cale> algebra mixed with something geometrical or combinatorial
08:31:28 <dons> nominolo: ping the maintainers mentioned in the above thread then
08:31:38 <dons> nominolo: or check the website, the darcs repo probably builds
08:31:39 <kyevan> "listLength :: (Num b) => List a -> b" would mean, listLenth takes a List of type a (where List is a reimplimented list... yay) and returns b, which is some sort of number?
08:31:43 <dons> (or use gtk2hs)
08:31:49 <Cale> I really like it when I have something really abstract, and something really concrete and they're nicely tied together.
08:32:15 <Cale> kyevan: yep
08:32:28 <dons> Heffalump: coming to the hackthon? (did I ask already?)
08:32:40 <Heffalump> dons: no, and yes :-)
08:32:42 <Cale> of course, it was still an incredible shock to me when I came to waterloo and got myself into the advanced section math there
08:32:46 <dons> ah ok :)
08:32:48 <vincenz> kyevan: formally "b must satisfy the methods that the Num-class demands (namely addition, multiplication and a few others)
08:32:52 <dons> just checking I didn't forget anyone
08:33:04 <vincenz> dons: donde ?
08:33:09 <vincenz> y quando?
08:33:17 <nominolo> dons: thanks.  i am on macosx, so gtk is second choice
08:33:18 <Cale> It was like I'd been mostly deaf my whole life and I could suddenly hear music :)
08:33:21 <dons> ?wiki Hac_2007
08:33:22 <lambdabot> http://www.haskell.org/haskellwiki/Hac_2007
08:33:33 <Heffalump> dons: how many people are coming?
08:33:41 <dons> 15 or so so far
08:33:53 <dons> looks good
08:33:59 <dons> the attendee list is up
08:34:17 <vincenz> hmm
08:34:18 <vincenz> damn
08:34:25 * vincenz has to get his tooth drilled the 10th
08:34:38 * Heffalump will only just have started at CS
08:36:54 <Cale> I forget, who was asking about parsing XML the other day?
08:37:05 <dons> yesterday, was it fnord123?
08:37:09 <Cale> ah, yeah
08:37:18 <dons> how'd you go with that?
08:37:22 <defcon8> Cale, what do you use haskell for?
08:37:23 <pbx> Thanks for the help everyone -- I hope to be back!
08:37:24 <Cale> well enough
08:37:43 <dons> Cale: i'd like to stick that stuff on the wiki
08:37:51 <Cale> defcon8: random stuff, I've only been involved in a few large projects
08:37:56 <dons> seems we get a lot of 'i want to use a regex' ... 'please use parsec instead'
08:37:58 <dons> questions
08:37:58 <defcon8> which was the largest?
08:38:22 <Cale> I'd say it would be the pipeline scheduler I wrote for PPC+Altivec
08:38:33 <Heffalump> eviltwin_b: I'm sure it ought to be possible to make text-processing as nice with Haskell as it is with Perl. I keep thinking I should try.
08:38:34 <kyevan> COuld someone point me to a good, SIMPLE discription of foldl and foldl
08:38:41 <Heffalump> sorry, s/eviltwin_b/EvilRanter/
08:38:43 <Cale> kyevan: yep
08:38:48 <kyevan> s/foldl and foldl/foldl and foldr/
08:38:57 <defcon8> do you think haskell is plausible for use in large-scale business applications?
08:38:58 * eviltwin_b hopes #openafs stays quiet for a bit...
08:39:03 <dylan> foldl.com / foldr.com?
08:39:08 <Cale> http://en.wikipedia.org/wiki/Foldr
08:39:13 <Cale> I wrote that :)
08:39:28 <dons> defcon8: apparently Credit Suisse thinks so :)
08:39:36 <defcon8> right, that's enough for me
08:39:36 <dylan> foldr.com/foldl.com are useful too
08:39:40 <defcon8> :D
08:40:01 <dons> (large scale isn't going to be the issue -- we know it works at scale)
08:40:28 <Cale> http://cale.yi.org/index.php/Fold_Diagrams
08:40:33 <lambdabot> Title: Fold Diagrams - CaleWiki
08:40:34 <Cale> for more nice diagrams
08:40:55 <defcon8> are there any haskell books worth getting that aren't free online and are "better" than yaht?
08:41:00 <pejo> Heffalump, please do. :-)
08:41:15 <Cale> The way to think about foldr f z is that it replaces each (:) with f and the [] at the end with z
08:41:25 <dons> defcon8: TaPL
08:41:34 <dons> though there's bob harper's book too, which *is* online
08:41:37 <dons> ?where plbook
08:41:37 <lambdabot> http://www-2.cs.cmu.edu/~rwh/plbook/
08:41:59 <dons> SoE and Craft of FP are great beginner's books though
08:42:12 <Cale> > foldr (\x xs -> concat ["(", show x, ":", xs, ")"]) "[]" [1..5]
08:42:14 <lambdabot>  "(1:(2:(3:(4:(5:[])))))"
08:42:14 <dons> still, I suspect you can learn haskell without ever buying a textbook
08:42:17 <defcon8> okay
08:42:26 <dons> there's just so much online material these days, of such quality
08:42:26 <Heffalump> dons: so how long are you spending in the UK?
08:42:27 <pejo> dons, I agree everybody should have a copy of tapl, but saying it's about Haskell isn't really fair.
08:42:44 <dons> Heffalump: a week in the UK , a week in France
08:42:52 <Cale> > foldr (\x xs -> concat ["(f ", show x, " ", xs, ")"]) "[]" [1..5]
08:42:54 <lambdabot>  "(f 1 (f 2 (f 3 (f 4 (f 5 [])))))"
08:42:55 <Heffalump> staying in Oxford the whole time?
08:42:58 <Cale> > foldr (\x xs -> concat ["(f ", show x, " ", xs, ")"]) "z" [1..5]
08:42:59 <dons> pejo, right. its not about haskell. its about the foundations of haskell
08:43:00 <lambdabot>  "(f 1 (f 2 (f 3 (f 4 (f 5 z)))))"
08:43:11 <Nafai> pejo: tapl?
08:43:14 <vincenz> dons: if you want to see belgium, you're welcome
08:43:18 <Heffalump> it's not even the foundations of Haskell in particular
08:43:28 <pejo> Nafai, Types and Programming Languages by Pierce.
08:43:34 <dons> Heffalump: yep
08:44:11 <Cale> > foldl (\xs x -> concat ["(f ", xs, " ", show x, ")"]) "z" [1..5]
08:44:12 <Nafai> Interesting
08:44:13 <lambdabot>  "(f (f (f (f (f z 1) 2) 3) 4) 5)"
08:44:16 <vincenz> dons: ^
08:44:41 <dons> vincenz: ah :) thanks. my tickets are booked though so I don't think I'll get much time away from hacking/conferences :}
08:44:52 <defcon8> dons, where are you in the UK atm?
08:44:57 <dons> as usual, these trips aren't so much holiday as intense crazy work periods
08:45:03 <defcon8> guess where I am (hint: haskell)
08:45:07 <dons> defcon8: Sydney-on-the-Harbour
08:45:17 <Heffalump> defcon8: Glasgow
08:45:40 <defcon8> Heffalump, yeah
08:45:46 <pejo> Anyone here started with attapl as source for HM?
08:45:46 <Cale> > scanl (\xs x -> concat ["(f ", xs, " ", show x, ")"]) "z" [1..5]
08:45:48 <lambdabot>  ["z","(f z 1)","(f (f z 1) 2)","(f (f (f z 1) 2) 3)","(f (f (f (f z 1) 2) 3)...
08:45:49 <vincenz> dons: oh already ini UK and in january you're coming back???
08:45:57 <vincenz> Cale++
08:46:03 <dons> no no. I'm in Sydney-on-the-Harbour ;)
08:46:04 <Cale> > scanr (\xs x -> concat ["(f ", show x, " ", xs, ")"]) "z" [1..5]
08:46:05 <lambdabot>  add an instance declaration for (Num [Char])
08:46:05 <lambdabot>   In an arithmetic sequence:...
08:46:13 <Cale> > scanr (\x xs -> concat ["(f ", show x, " ", xs, ")"]) "z" [1..5]
08:46:15 <lambdabot>  ["(f 1 (f 2 (f 3 (f 4 (f 5 z)))))","(f 2 (f 3 (f 4 (f 5 z))))","(f 3 (f 4 (f...
08:46:30 <Heffalump> it's a slightly detached part of the UK.
08:46:34 <dons> nice Cale
08:46:36 <Heffalump> In both space and time.
08:46:42 <vincenz> Heffalump: Yeah, the prison-part
08:46:58 <dons> yes, but we still have the queen on the money, and english cricketers on the tv :)
08:47:09 <Heffalump> and in your country
08:47:39 * vincenz keeps playing "Smack that, All on the floor.  Smack that, Give me some more. Smack that, till you get sore. Smack that, oooh oooh"
08:48:10 <dons> wrong channel vincenz? you want #types-and-bondage?
08:48:16 <vincenz> Lol, it's a song
08:48:41 <vincenz> Besides I thought that was #haskell-blah
08:49:36 * Cale listens to some Wayne Krantz :)
08:51:30 * allbery_b contemplates >>= as the bondage operator, then decides to let someone else, er, flesh it out :)
08:51:55 <kolmodin> Lemmih: hi. I'm wondering if you're still working on hIDE?
08:53:24 <Cale> heh, my dad and I are going to have to get all of this guy's albums for Christmas
08:54:15 <defcon8> what's wrong with fib 2 = 0
08:54:16 <defcon8> fib 1 = 0
08:54:16 <defcon8> fib x = fib (x - 2) + fib (x - 1) ?
08:54:35 <vincenz> defcon8: nothing
08:54:37 <Heffalump> nothing obvious, what goes wrong?
08:54:42 <augustss_> Wayne Newton?
08:54:43 <defcon8> always getting 0
08:54:50 <vincenz> defcon8: ah yes :)
08:54:52 <Cale> defcon8: you're adding a bunch of 0's
08:54:55 <vincenz> well the root values are 0 as Cale says
08:55:12 <Cale> defcon8: you have to have some nonzero base cases to make it interesting :)
08:55:17 <defcon8> oh yeah
08:55:18 <defcon8> has to be 1
08:55:42 <vincenz> Cale: define "interesting" I think this function is rather interesting :)
08:55:58 <Cale> const 0 isn't that interesting
08:56:21 <vincenz> Cale: it is wiht varying runtime
08:57:03 <vincenz> (not to mention an interesting case for testing constant propagation and optimization :))
08:57:29 <Igloo> It's not const 0 unless you give it a more restrictive type signature
08:57:30 <Cale> It's an interesting computation, but it's not an interesting function.
08:58:01 <vincenz> Igloo: negative numbers?
08:58:09 <Igloo> Exactly
08:58:22 <vincenz> const 0 implies bottom
08:58:29 <Heffalump> it's refined by const 0
08:58:37 <Lemmih> kolmodin: I'm not. The project has been stalled for quite some time now.
08:58:37 <Heffalump> oh, as vincenz says
08:59:57 <defcon8> my_map f [] = []
08:59:57 <defcon8> my_map f (x:xs) =
08:59:57 <defcon8>     (f x) : my_map f xs
08:59:59 <defcon8> and with that?
09:00:12 <vincenz> nothing apparent
09:00:19 <defcon8> there never is :(
09:00:45 <vincenz> > let {mymap f [] = []; mymap f (x:xs) = (f x): mymap f xs} in mymap (+1) [1..]
09:00:46 <lambdabot>  [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
09:00:49 <vincenz> seems fine
09:01:00 <defcon8>  No instance for (Show (t -> t))
09:01:00 <defcon8>    arising from use of `print' at <interactive>:1:0-19
09:01:00 <defcon8>  Possible fix: add an instance declaration for (Show (t -> t))
09:01:15 <vincenz> defcon8: perhaps show us the line you use to invoke it?
09:01:34 <defcon8>  my_map (+) [1,2,3,4]
09:01:48 <Heffalump> are you trying to add up a list?
09:01:52 <defcon8> yes
09:01:56 <Heffalump> that's not what map does
09:01:58 <vincenz> defcon8: that's a fold not a map
09:02:01 <defcon8> oh yeah
09:02:03 <defcon8> sorry!@
09:02:03 <kyevan> Hmm
09:02:07 <defcon8> sorry sorry
09:02:08 <Cale> map will always give a list of the same length as the list you give it
09:02:13 <vincenz> defcon8: more sorry! grovel
09:02:24 <allbery_b> heh
09:02:31 * defcon8 performs a side-effect on vincenz \
09:02:33 <vincenz> > let grovel = repeat "sorry"
09:02:34 <lambdabot>  Parse error
09:02:38 <vincenz> > let grovel = repeat "sorry" in grovel
09:02:40 <lambdabot>  ["sorry","sorry","sorry","sorry","sorry","sorry","sorry","sorry","sorry","so...
09:03:21 <kyevan> Is haveing students reimpliment something a valid way to insure they understand it, or is it just annoying?
09:03:31 <vincenz> Both :)
09:03:56 <roconnor> kyevan: ``ensure''
09:03:59 <vincenz> my students get to implement assembly in pseudocode :)
09:04:06 <vincenz> erm, microcode
09:04:15 * vincenz grumbles at his semantical typo
09:04:29 <Saizan> that's just sadic
09:05:21 <kyevan> vincenz: semantico?
09:05:42 <vincenz> thinko
09:05:47 <Cale> > let grovel = map (concat . intersperse " ") $ scanl (\(x:xs) y -> x:y:xs) ["I'm", "sorry"] (repeat "so") in grovel
09:05:47 <Saizan> s/sadic/sadistic
09:05:49 <lambdabot>  ["I'm sorry","I'm so sorry","I'm so so sorry","I'm so so so sorry","I'm so s...
09:06:01 <vincenz> Cale: now last it :)
09:06:41 <kyevan> Oh no! Not he! How you can accuse him is a mystery!
09:07:29 <Cale> > let grovel = map unwords $ scanl (\(x:xs) y -> x:y:xs) ["I'm", "sorry"] (repeat "so") in grovel
09:07:30 <lambdabot>  ["I'm sorry","I'm so sorry","I'm so so sorry","I'm so so so sorry","I'm so s...
09:07:43 <defcon8> After all, suppose you have a function that reads a string from the keyboard. If
09:07:44 <defcon8> you call this function twice, and the user types something the first time and something
09:07:44 <defcon8> else the second time, then you no longer have a function, since it would return two
09:07:44 <defcon8> different values  <-- wtf?
09:07:50 <Cale> @pl \(x:xs) y -> x:y:xs
09:07:51 <lambdabot> ap ((. flip (:)) . (.) . (:) . head) tail
09:07:54 <Cale> hehe
09:08:15 * kyevan is listening to: Brothers - Benjamin Calypso on "Joseph and the Amazing Technicolor Dreamcoat" [1:01/2:57]
09:08:16 <Heffalump> defcon8: mathematical functions are by definition single-valued
09:08:20 <allbery_b> defcon8: by the mathematical definition of "function"
09:08:24 <kyevan> :P
09:08:26 <allbery_b> heh
09:08:44 <defcon8> yes but it is like saying that (*) 1 2 == (*) 1000000000 239058238045
09:08:50 <defcon8> "two different values"
09:09:08 <arcatan> two different values with the same parameters
09:09:12 <arcatan> (are they called parameters?)
09:09:18 <vincenz> > let 1 * 2 = 10000000000 * 239058238045 in 1 * 2
09:09:19 <lambdabot>  Add a type signature
09:09:25 <vincenz> > let 1 * 2 = 10000000000 * 239058238045 in 1 * 2 :: Int
09:09:27 <lambdabot>  Non-exhaustive patterns in function *
09:09:31 <Cale> defcon8: a function f: A -> B is formally a set of pairs (a,b) with a in A and b in B, such that for all a in A, there is exactly one b in B for which (a,b) is in f.
09:09:43 <defcon8> one to one?
09:09:48 <allbery_b> defcon8: this is what happens when you have side effects --- a notion that mathematics doesn't have.
09:10:14 <kyevan> I should have learned a little COBOL yesterday.
09:10:15 <kyevan> Oh well
09:10:18 <Cale> We write f(a) = b when (a,b) is in f. A function f is one to one if whenever f(a) = f(a') then a = a'
09:10:58 <Cale> A function f: A -> B is onto if for every b in B, there is some a in A such that f(a) = b
09:11:06 <Saizan> one to one is a property of functions, when if a1/=a1 then f(a1)/=f(a2)
09:11:22 <vincenz> Saizan: that follows from one-to-one
09:11:40 <vincenz> it's the ... forgot the mathematical term
09:11:42 <vincenz> negated reverse
09:11:45 <Cale> Either way, you can take the contrapositive if you'd like
09:11:49 <vincenz> rightio, what Cale said
09:11:56 <Saizan> well, it's equivalent
09:12:12 <Cale> and of course you meant a1 /= a2
09:12:21 <Saizan> uh, yes, typo
09:12:23 <vincenz> Cale: nono, I found his math more interesting
09:12:55 <Cale> Well, "if a1 /= a1 then f(a1) /= f(a2)" is always true.
09:13:53 <Cale> at least, if we're not working with IEEE floats ;)
09:14:13 <vincenz> Cale: or java numbers
09:15:05 <Cale> defcon8: It's important to notice that the way I defined "function" does not make every function one to one
09:15:24 <defcon8> what is randomRIO not a proper function?
09:15:35 <defcon8> because it relies on system information to gather entropy?
09:15:52 <Cale> Oh, it's a proper function, so long as it has its nicely monadic type
09:16:16 <Cale> But suppose we had randomRIO :: (Random a) -> (a,a) -> a
09:16:20 <defcon8> why do they use <- in the yaht, then?
09:16:29 <vincenz> defcon8: do-notation
09:16:32 <Cale> v <- x
09:16:32 <defcon8> okay
09:16:45 <Cale> runs computation x in the given monad and binds its result to v
09:16:45 <kolmodin> Lemmih: ok, I thought it had started again, but ok
09:17:07 <Cale> But it's always part of a do-block which is just a description of another computation
09:17:09 <vincenz> heh definiing monads for C is ugly, as you have non-local ctrl-flow
09:17:13 <xerox> *ZipNtree> (fst . up . right . right . right . down $ (t,Top)) == t
09:17:15 <xerox> ops
09:18:00 <Cale> randomRIO :: (Random a) -> (a,a) -> a -- if randomRIO had this type, it would give the same result for the same bounds every time
09:18:23 <Cale> Like, if you passed it (1 :: Int, 10) and it gave you 5
09:18:34 <xerox> anybody in the mood of defining a travel monad uponhttp://darcs.haskell.org/~paolo/darcs/tao/ZipNtree.hs ?  i'm too tired now
09:18:38 <Cale> then it would have to give you 5 every time
09:19:04 <Cale> because there is a *unique* value of type a for any given value of type (a,a)
09:19:36 <Cale> and of course, that's not terribly random
09:20:05 <Cale> One way to solve the problem is to pass a value representing a pseudorandom number generator state
09:20:10 <Cale> and we have that:
09:20:15 <Cale> @type randomR
09:20:16 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
09:20:23 <defcon8> rest <- askForWords
09:20:23 <defcon8> return (word : rest)
09:20:28 <defcon8> does that work because of lazy evaluation?
09:20:44 <Cale> it takes a RandomGen and returns a new one to be used to get the next "random" value
09:20:54 <vincenz> xerox: seems buggy
09:21:03 <Cale> defcon8: It's probably strict
09:21:13 <defcon8> sorry?
09:21:14 <vincenz> but I'm prolly mistaken
09:21:21 <Cale> askForWords is going to ask the user for words
09:21:31 <defcon8> yes, it does things with do
09:21:53 <Cale> and so you won't have to worry about rest being defined by the time you get to returning (word : rest)
09:22:18 <Cale> beware though, there are a few lazy IO functions lying around
09:22:36 <Cale> the main ones to be aware of are getContents/hGetContents and readFile
09:22:53 <Cale> these return a string immediately which only reads the file as it's evaluated
09:23:17 <Cale> This is slightly dangerous, but very convenient.
09:23:36 <Cale> (and not so bad as long as you're aware that it's going on)
09:23:43 <vincenz> Aardwolf: een medekuller
09:23:44 <arcatan> Wikipedia's arctile for functional reactive programming is extremely useful.
09:23:53 <arcatan> *article
09:24:03 <astrolabe> Cale: what do you do if you want to open a file, read it's contents, and close the file.  If you want to stop the program going off and doing other stuff while the file is open?
09:24:09 <Cale> you should never hClose a handle which has had hGetContents applied to it, because it will be closed when you get to the end of the file anyway
09:24:20 <Aardwolf> vincenz, hallo
09:24:30 <vincenz> Aardwolf: student?
09:24:45 <Aardwolf> vincenz, ex-student
09:24:49 <Cale> (evaluating the [] at the end has a sideeffect attached which closes the file)
09:24:52 <vincenz> Aardwolf: Wat doe je dan nu?  En welke richting?
09:25:15 <Aardwolf> vincenz, ik heb burgie elektrotechniek gedaan, nu werk ik bij een spinoffbedrijf als coder
09:25:19 <Cale> as I said, it's evil :)
09:25:40 <vincenz> Aardwolf: Ah, welk jaar?
09:25:47 <Cale> but quite often extremely convenient -- in particular for stream processing
09:25:59 <Aardwolf> vincenz, vorig jaar afgestudeerd. Wat studeer jij?
09:26:18 <Cale> and since you're getting it from IO anyway, it's not quite so bad
09:26:28 <vincenz> Aardwolf: Ik ben in 2002 afgestudeerd als hetzelfde, momenteel bezig met mijn doctoraat.  Bij welk bedrijf zit je dan, en gebruiken jullie per toeval Haskell?
09:26:52 <Aardwolf> vincenz, ik werk bij Materialise, en ik heb van Haskell gehoord via iemand anders die daar werkt, we gebruiken daar echter C++
09:27:06 <vincenz> Aardwolf: Ah ja, die 3d-extrusions :)
09:27:12 <SamB> Cale: indeed, there is no way to claim it violates referential transparency, since it comes from IO.
09:27:13 <Aardwolf> ja :)
09:27:44 <Aardwolf> vincenz, waarover gaat je doctoraat?
09:27:45 * vincenz zit zelf op IMEC en gebruikt Haskell wel eens voor tools/compilers
09:27:47 <SamB> unless, of course, you use the same one twice and it has different values each time!
09:27:48 <roconnor> Is er een #haskell.nl ?
09:28:01 <vincenz> Aardwolf: software transformaties for optimizatie van multimedia toepassingen
09:28:08 <Aardwolf> vincenz, ken je Lerkeveld?
09:28:08 <vincenz> (op embedded systems)
09:28:14 <vincenz> Aardwolf: Daar heb ik gezeten
09:28:19 <Aardwolf> haha daar zit ik nu nog steeds
09:28:23 <Aardwolf> al 6 jaar
09:28:30 <vincenz> Dan heb je me wschlk gekend
09:28:40 <Aardwolf> zat je op zuid of noord?
09:28:45 <vincenz> laatste jaren op zuid
09:28:51 <Aardwolf> welke gang?
09:28:56 <vincenz> Z..1 denk ik
09:29:00 <Aardwolf> hmm, ik 0
09:29:01 <vincenz> of misschien 2, is al een poosje
09:29:07 <SamB> (which I can imagine happening with the same unsafePerformIO being entered in two threads at once)
09:29:10 <vincenz> Poucet
09:29:22 <Aardwolf> aha, ja ik ken je niet persoonlijk enkel van zien dan :)
09:29:28 <vincenz> Ah, right
09:29:31 <SamB> (which would kind of be a bug)
09:29:40 <vincenz> Aardwolf: Maar dan heb ik je 2 jaar geleden lesgegeven
09:29:46 <vincenz> Aardwolf: Het vak van rudy
09:30:06 <Aardwolf> wat is de achternaam van rudy? :)
09:30:10 <vincenz> Lauwereins
09:30:16 <vincenz> Computer Architecturen
09:30:18 <Aardwolf> aha, yep heb ik gehad
09:30:31 <Aardwolf> ik ben Lode btw
09:30:51 <vincenz> Nice ta meetcha (let's switch back to english, I feel like I've captivated the channel with our drivel)
09:31:05 <Aardwolf> nice to meet ya
09:31:13 <vincenz> But you could definitely use Haskell if you are coding on new algorithms.  It is great for working on algorithmic code
09:31:34 <Aardwolf> I'd learn it to learn some new programming concepts :)
09:31:38 <vincenz> I'm considering giving a mini-course on it at IMEC, but I haven't done the effort yet
09:32:24 <vincenz> Aardwolf: Programming Language Geek as well?
09:33:08 <Aardwolf> hmm, I program extremely much, all day at work, and when I'm home I just keep coding unless there are other people :)
09:33:27 <vincenz> I know the feeling :)
09:33:53 <vincenz> Sadly we don't get much at KUL, especially as ee'rs (and Java... not exactly a vat full of semantics)
09:33:59 <Aardwolf> now implementing unit tests in my newest project :)
09:34:07 <vincenz> Aardwolf: check this out
09:34:20 <vincenz> @check \a b -> a ==b ==> a - b == 0
09:34:21 <lambdabot>  Add a type signature
09:34:28 <vincenz> @check \a b -> (a::Int) ==b ==> a - b == 0
09:34:30 <lambdabot>  Arguments exhausted after 109 tests.
09:34:33 <Aardwolf> *phone
09:34:38 <vincenz> Automatic unit test generation
09:35:21 <vincenz> (well data generation for unit tests through type-analysis)
09:37:48 <SamB> arguments exhausted?
09:37:53 <vincenz> SamB: yes
09:38:02 <vincenz> can't find any more arguments to satisfy the precondition
09:38:11 <vincenz> (the stuff between the ==> )
09:38:29 <SamB> @check \a b -> (a::Int) ==b ==> a + b == 0
09:38:31 <lambdabot>  Falsifiable, after 6 tests: -3, -3
09:38:34 <SamB> hmm.
09:38:59 <SamB> @check \a b -> (a::Int) ==b ==> a + b -6 == 0
09:39:01 <lambdabot>  Falsifiable, after 0 tests: 0, 0
09:39:16 <vincenz> @check SamB's brain
09:39:17 <lambdabot>  Not in scope: `brain'
09:39:31 <allbery_b> heh
09:39:32 <dons> hah
09:39:56 <dons> ?users
09:39:57 <lambdabot> Maximum users seen in #haskell: 278, currently: 260 (93.5%), active: 33 (12.7%)
09:39:58 <SamB> vincenz: I was just trying to see what kind of test coverage was involved
09:40:06 <xerox> ?pl \y -> you y off
09:40:07 <lambdabot> flip you off
09:40:29 <SamB> @check \a b -> (a::Int) ==b ==> (a `elem` [-3,0] || False)
09:40:30 <lambdabot>  Falsifiable, after 1 tests: 1, 1
09:40:50 <SamB> @help check
09:40:51 <lambdabot> check <expr>
09:40:51 <lambdabot> You have QuickCheck and 3 seconds. Prove something.
09:41:08 <vincenz> dons: checks are never proofs!
09:41:11 <SamB> @check \a b -> (a::Int) ==b ==> (a `elem` [-3,0,1] || False)
09:41:12 <lambdabot>  Falsifiable, after 4 tests: 4, 4
09:41:21 <vincenz> @check \x y -> x ==> y
09:41:22 <lambdabot>  Add a type signature
09:41:28 <vincenz> @check \x y -> x ==> (y :: Bool)
09:41:30 <lambdabot>  Falsifiable, after 1 tests: True, False
09:41:38 <vincenz> @check \x -> x ==> x
09:41:39 <lambdabot>  OK, passed 500 tests.
09:41:48 <vincenz> woot, 500 tests for 2 input possibilities
09:41:59 <SamB> @scheck \a b -> not (a && b) == (not a || not b)
09:42:01 <lambdabot>   Completed 4 test(s) without failure.
09:42:07 <SamB> that is not a proof?
09:42:16 <SamB> tell me that that is not a proof, with a straight face!
09:42:27 <vincenz> that is not a proof
09:42:32 <vincenz> </straight face>
09:42:47 <SamB> send me a live stream of your face, then say it again!
09:42:48 <allbery_b> throwing values at it looking for a counterexample is not a proof
09:42:59 <int-e> SamB: you have a proof obligation here that lambdabot's scheck module is functioning correctly
09:43:01 <SamB> allbery_b: not even if you throw *all* of the values at it?
09:43:14 <EvilRanter> proofs have no face, so saying it's a proof with a straight face'd be false
09:43:36 <SamB> EvilRanter: you silly!
09:43:44 <EvilRanter> that's right!
09:43:44 <dons> vincenz: proof by exhaustion is a proof
09:43:44 <vincenz> EvilRanter: so what about SamB being the proof of insanity
09:43:52 <allbery_b> no, since a proof is defined as a logical derivation
09:43:54 <dons> ?scheck True
09:43:55 <lambdabot>   Completed 1 test(s) without failure.
09:43:56 <vincenz> dons: interesting, you learn something new every day
09:43:59 <EvilRanter> he is? i thought that was Prof.
09:44:07 <int-e> SamB: but taking that for granted it's a proof :)
09:44:15 <vincenz> EvilRanter: that's a pre-req
09:44:21 <SamB> int-e: hmm? taking which for granted?
09:44:28 <dons> ?scheck True ==> True
09:44:29 <lambdabot>   Completed 1 test(s) without failure.
09:44:31 <int-e> SamB: that scheck is functioning correctly
09:44:38 <vincenz> anyawys, the original discussion started with @check, not @scheck
09:44:43 <SamB> quite so
09:44:46 <dons> ?scheck x ==> not (not x)
09:44:47 <lambdabot>  Not in scope: `x'
09:44:52 <dons> ?scheck \x ==> not (not x)
09:44:52 <lambdabot>  Parse error
09:44:55 <SamB> but you said "checks are never proofs"
09:45:02 <dons> ?scheck \x -> x ==> not (not x)
09:45:03 <lambdabot>   Completed 2 test(s) without failure.  But 1 did not meet ==> condition.
09:45:13 <SamB> you never specified *quick* checks!
09:45:29 <SamB> @check True
09:45:30 <lambdabot>  OK, passed 500 tests.
09:45:33 <dons> ?scheck \x -> x ==> not x
09:45:33 <int-e> ?scheck liftM2 (==>) id (not . not) -- doesn't work, I think.
09:45:34 <lambdabot>   Failed test no. 1. Test values follow.: True
09:45:35 <lambdabot>   Completed 2 test(s) without failure.  But 1 did not meet ==> condition.
09:45:53 <int-e> oh it does
09:45:54 <dons> nice, int-e
09:46:02 <dons> (must be the new scheck 02)
09:46:46 <SamB> @type liftM2 Test.QuickCheck.(==>) id (not . not)
09:46:48 <lambdabot> Couldn't find qualified module.
09:46:54 <SamB> hmm.
09:47:07 <dons> syntax
09:47:24 <dons> :t liftM2 (Test.QuickCheck.==>) id (not . not)
09:47:26 <lambdabot> Bool -> Test.QuickCheck.Property
09:47:40 <SamB> ah.
09:49:04 <int-e> ?scheck \x y -> ((y ==> x) ==> x) ==> y
09:49:04 <lambdabot>  Couldn't match `Bool' against `Property'
09:49:15 <Cale> I wonder if it could be generalised a bit to allow it to take properties on the left as well.
09:49:15 <SamB> @scheck \f x -> f x == (not . f) x
09:49:17 <lambdabot>  Add a type signature
09:49:33 <Cale> int-e: I totally just tried that in /msg :)
09:49:34 <SamB> @scheck \f x -> f x == (not . f . not) x
09:49:36 <lambdabot>   Failed test no. 1. Test values follow.: {True->True;False->True}, True
09:50:43 <Cale> ?scheck let x ==> y = y || not x in \x y -> ((y ==> x) ==> x) ==> y
09:50:44 <lambdabot>   Failed test no. 2. Test values follow.: True, False
09:50:56 <Cale> ?scheck let x ==> y = y || not x in \x y -> ((x ==> y) ==> x) ==> x
09:50:58 <lambdabot>   Completed 4 test(s) without failure.
09:51:23 <vincenz> Cale: ==> != your definition
09:51:26 <vincenz> Cale: it's special
09:51:29 <Cale> I know
09:51:39 <Cale> I'm specifically shadowing it :)
09:52:24 <vincenz> stalking is illegal
10:05:51 <ex0r> whats the haskell function for testing for list membership?
10:06:05 <pejo> elem?
10:06:06 <Saizan> :t elem
10:06:08 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
10:06:14 <ex0r> thanks
10:11:35 <shahn_> i try to compile hsffig and it needs the module System.FilePath
10:11:53 <shahn_> the one from Neil Mitchell doesn't work
10:12:11 <shahn_> which one is needed?
10:14:38 <xerox> is this behavior consistent?
10:15:35 <shahn_> ???
10:15:36 <xerox> > liftM2 (,) init last [1,2,3]
10:15:37 <lambdabot>  ([1,2],3)
10:15:38 <xerox> > liftM2 (,) init last [1,2]
10:15:39 <lambdabot>  ([1],2)
10:15:40 <xerox> > liftM2 (,) init last [1]
10:15:42 <lambdabot>  ([],1)
10:15:47 <vincenz> yes
10:15:49 <xerox> uhm.
10:15:56 <xerox> the last one is strange
10:15:58 <vincenz> no
10:16:11 <vincenz> [1] = [] ++ [1]
10:16:17 <vincenz> [1] ++ [2] = [1,2]
10:16:26 <vincenz> [1,2] ++ [3] = [1,2,3]
10:16:32 <xerox> uhm.
10:16:36 <xerox> okay.
10:22:11 <vincenz> @quote pkhuong
10:22:12 <lambdabot>  [vincenz] life is all in the randomness [pkhuong] says the concurrent programmer
10:22:14 <vincenz> @quote pkhuong
10:22:15 <lambdabot>  [vincenz] life is all in the randomness [pkhuong] says the concurrent programmer
10:22:17 <vincenz> grr
10:22:47 <vincenz> @quote pkhuong
10:22:47 <lambdabot>  [vincenz] life is all in the randomness [pkhuong] says the concurrent programmer
10:22:51 * vincenz sighs at lambdabot 
10:22:59 <vincenz> lambdabot: 2 quotes, 2! pick the other one
10:23:03 <vincenz> @quote pkhuong
10:23:04 <lambdabot>  [vincenz] life is all in the randomness [pkhuong] says the concurrent programmer
10:23:07 * vincenz mutters
10:23:08 <allbery_b> heh
10:23:18 <vincenz> randomness bites my ass
10:23:25 <allbery_b> @quote pkhuong
10:23:26 <lambdabot>  you'll probably still want unsafeEquality or whatever, though
10:23:39 <xerox> vincenz - I've evolved a bit the zipper if you want to see (same url)
10:24:08 <vincenz> remind me?
10:24:40 <xerox> http://darcs.haskell.org/~paolo/darcs/tao/ZipNtree.hs
10:24:47 <vincenz> thx
10:25:47 <vincenz> xerox: bling = rev-append?
10:25:49 <monochrom> <3
10:26:01 <vincenz> xerox: you can do that with a fold
10:26:14 <vincenz> > foldl (:) [1..10] [11..20]
10:26:15 <lambdabot>    Occurs check: cannot construct the infinite type: a = [a]
10:26:15 <lambdabot>    Expected...
10:26:22 <vincenz> @type foldl
10:26:24 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
10:26:34 <vincenz> > foldl (flip (:)) [1..10] [11..20]
10:26:36 <lambdabot>  [20,19,18,17,16,15,14,13,12,11,1,2,3,4,5,6,7,8,9,10]
10:27:04 <vincenz> xerox: but I don't think bling types?
10:27:07 <xerox> vincenz: I was thinking of the sound of typewriters... chrchrchrhch-bling! when you roll the thing up to the first char
10:27:19 <vincenz> oh
10:27:38 <vincenz> > let l = foldl (flip (:)) [1..10] [11..20] in (head l, tail l)
10:27:39 <lambdabot>  (20,[19,18,17,16,15,14,13,12,11,1,2,3,4,5,6,7,8,9,10])
10:27:55 <vincenz> @pl \a b -> letl = foldl (flip (:)) a b in (head l, tail l)
10:27:56 <lambdabot> (line 1, column 14):
10:27:56 <lambdabot> unexpected "="
10:27:56 <lambdabot> expecting variable, "(", operator or end of input
10:28:01 <vincenz> @pl \a b -> let l  = foldl (flip (:)) a b in (head l, tail l)
10:28:02 <lambdabot> (liftM2 (,) head tail .) . foldl (flip (:))
10:28:10 <vincenz> :)
10:28:36 <xerox> (head &&& tail) . foldl (flip (:))
10:28:47 <xerox> xerox 1 - lambdabot 0
10:28:49 <xerox> woohoo.
10:29:38 <vincenz> xerox: you mean xerox 0.5, vincenz 0.5
10:31:50 <kyevan> Someone needs to define a 3d moveing dialect of haskell that's always shown as green-on-black
10:32:01 <kyevan> And has no spaces or returns
10:32:13 <arcatan> like a hollywood version?
10:32:16 <kyevan> and is edited in a program that beeps every time you push a button, and has no mouse support
10:32:22 <kyevan> arcatan: Exactly!
10:32:43 <vincenz> and requires "head"?
10:32:46 <SamB> does it come with lessons on how to type a mile a minute?
10:32:59 <vincenz> SamB: in which font-size?
10:33:09 <kyevan> I can type a mile a minute!
10:33:22 * kyevan sets his font size to be REALLY REALLY BIG
10:33:24 <SamB> how about a megabyte a minute?
10:33:24 <vincenz> "a mile"
10:33:32 <vincenz> "a megabyte"
10:33:40 <kyevan> SamB: Use Microsoft Office.
10:33:42 <kyevan> Done :P
10:33:46 <SamB> kyevan: hah
10:33:58 <SamB> okay, a million characters
10:34:23 <kyevan> SamB: Do they have to mean anything?
10:34:24 <vincenz> easy
10:34:27 <vincenz> SamB: very easy
10:34:44 <vincenz> qai1^Escq1000000@a
10:34:58 <SamB> a million characters, which do something that maybe isn't even possible
10:35:12 <kyevan> SamB: Hmm...
10:35:18 <kyevan> Get a job as an actor.
10:35:31 <kyevan> Hollywood will help, there
10:35:45 <vincenz> SamB: and crack 1024 bit in a minute
10:36:15 <vincenz> (on a machine that is not yours)
10:36:32 <kyevan> vincenz: But take 5-10 minutes to trace a phone!
10:37:02 <SamB> kyevan: it takes that long to do the paperwork!
10:40:35 <Baughn> kyevan: What is caller id, again?
10:40:58 <chessguy> you don't know what caller id is?
10:41:18 * Baughn beats chessguy around with a large herring
10:41:32 <chessguy> you need to get out more
10:41:36 <chessguy> or maybe less, i'm not sure
10:41:38 <LoganCapaldo> Its the unique identifier attached to every stack frame of course! (Isn't it?)
10:42:02 <Baughn> chessguy: This herring has already been to quite enough parties. It's starting to stink.
10:42:28 <Baughn> LoganCapaldo: Hmm. That sounds useful for backtraces?
10:42:44 <LoganCapaldo> Maybe, however I did make it up :)
10:43:37 <monochrom> "get out more" means you go to a quiet outdoor garden and wait for someone to ring your cell phone
10:44:23 <monochrom> @remember LoganCapaldo [caller id is] the unique identifier attached to every stack frame of course! (Isn't it?)
10:45:05 <monochrom> When someone phones you up, your phone may be able to show the incoming phone number.
10:45:36 <ski> xerox : strange error message you've got there :)
10:45:39 <SamB> unless it says "PRIVATE PRIVATE" instead
10:45:54 <kyevan> SamB: Or UNKNOWN NAME/UNKNOWN NUMBER.
10:45:58 <LoganCapaldo> My personale favorite is "Unavailble ID"
10:46:12 <Baughn> Here, we just get "00000000"
10:46:16 <LoganCapaldo> I'd like to know the difference between Private and Unavailable
10:46:23 <LoganCapaldo> Since I've seen both on my phone
10:46:36 <kyevan> LoganCapaldo: PRIVATE is they payed so it doesn't show
10:46:49 <SamB> PRIVATE is for single lines that have unlisted numbers
10:46:55 <SamB> like doctors and stuff
10:47:04 <LoganCapaldo> And they got it for free with Unavailable ? :)
10:47:04 <kyevan> Unavailable meens they're WAY out in the middle of nowhere and their lines aren't capable of caller ID
10:47:08 <kyevan> I think
10:47:15 <Baughn> "Private" sounds like "It's available, but you lack privileges to see it"
10:47:18 <SamB> kyevan: I don't think that can be it
10:47:20 <LoganCapaldo> That can't be it
10:47:46 <LoganCapaldo> I've gotten calls from people w/ Unavailable ID that I know aren't in the middle of nowhere
10:48:02 <SamB> kyevan: I think it might mean that the call comes from a company with a switchboard of their own, which doesn't give caller ID?
10:48:17 <kyevan> SamB: That would do it, too
10:48:32 <kyevan> Basicly, something between you and them doesn't handle it
10:48:35 <kyevan> I think
10:48:39 <kyevan> I'm no expert
10:49:31 <kyevan> If you take that as true JUST because I said it. I have some nice ocean-view property to sell you :)
10:49:43 <SamB> but, when I see PRIVATE I generally know who is calling. although occasionally it is actually one of his parents...
10:50:02 <kyevan> SamB: Telemarketers
10:50:15 <SamB> (he is always calling to ask me for help with linux)
10:50:44 <kyevan> "Wisconsin Call" is the Dane County Sheriffs Department. (I know someone who works for them)
10:52:11 <SamB> is it just me or is that probably truncated?
10:52:22 <wy> What's the test function for empty lists? It seems a/=[] is not quite right ?
10:52:26 <vincenz> null
10:52:31 <vincenz> > null []
10:52:33 <lambdabot>  True
10:52:36 <vincenz> > null [1..1]
10:52:38 <lambdabot>  False
10:52:44 <Maia_> Hi
10:52:47 <vincenz> null = O(1)
10:52:51 <vincenz> equality for lists is O(n)
10:53:02 <Maia_> Some one use wxHaskell ?
10:53:23 <LoganCapaldo> empty list, n = 0. Therefore a /= [] should take no time :)
10:53:26 <SamB> also, Eq [a] <=> Eq a
10:53:28 <wy> vincenz: What's more, equality has different type.
10:53:36 <sjanssen> O(min(n, m))
10:53:45 <SamB> so you need the list to contain things that can be tested for equality
10:53:51 <lisppaste2> glguy pasted "because sometimes your bf interpreter starts getting a little too long..." at http://paste.lisp.org/display/31795
10:53:54 <SamB> even though they never *will* be
10:54:24 <Maia_> Hi
10:54:26 <Maia_> Some one use wxHaskell ?
10:54:42 <wy> let f l = l/=[]
10:54:45 <SamB> hmm. I dunno. But I heard it has a new maintainer!
10:54:50 <wy> > let f l = l/=[]
10:54:50 <lambdabot>  Parse error
10:55:07 <sjanssen> wy: let .. in ..
10:55:11 <wy> ?type f l = l/=[]
10:55:12 <lambdabot> parse error on input `='
10:55:21 <wy> ?type (f l = l/=[])
10:55:22 <SamB> @type let f l = l/=[] in f
10:55:23 <lambdabot> parse error on input `='
10:55:24 <lambdabot> forall a. (Eq [a]) => [a] -> Bool
10:55:34 <LoganCapaldo> Or if you want to pollute lambddabot you can do @let
10:56:22 <wy> ?type (f2 l = null l)
10:56:24 <lambdabot> parse error on input `='
10:56:39 <wy> ?type (\l -> null l)
10:56:41 <lambdabot> forall a. [a] -> Bool
10:56:41 <Maia_> How can I crate a Control dynamic ?
10:56:53 <wy> ?type (\l -> l/=[])
10:56:55 <lambdabot> forall a. (Eq [a]) => [a] -> Bool
10:57:07 <wy> You see. The second definition has different type
10:57:32 <kyevan> Is there a "type" that includes every type available?
10:57:36 <vincenz> a
10:57:41 <vincenz> forall a.a
10:57:44 <glguy> ?hoogle squares
10:57:45 <lambdabot> Text.ParserCombinators.Parsec.Token.squares :: TokenParser st -> CharParser st a -> CharParser st a
10:58:52 <kyevan> You couldn't do a list-like data type with a and be able to have dynamicly typed lists though, could yoU?
10:59:04 <vincenz> @hoogle Dynamic
10:59:05 <lambdabot> Data.Dynamic :: module
10:59:06 <lambdabot> Data.Dynamic.Dynamic :: data Dynamic
10:59:06 <lambdabot> Data.Dynamic.fromDynamic :: Typeable a => Dynamic -> Maybe a
10:59:11 * vincenz winks
10:59:30 <Maia_> lambdabot
10:59:48 <Maia_> someone ?
11:00:25 <Maia_> I have a function that f :: [Prop] -> IO (ButtonBitmap ())
11:00:44 <Maia_> I want to create buttons dinamically
11:01:49 <vincenz> f props = do ...
11:02:22 <ElMaia> I have a function that f :: [Prop] -> IO (ButtonBitmap ())
11:02:25 <ElMaia> I want to create buttons dinamically
11:10:07 * SamB announces his Z-machine interpreter
11:10:33 <wilx> Z?
11:10:55 <SamB> Z as in Zork
11:11:28 <SamB> was invented before they called VMs VMs
11:12:42 <wilx> Ah...ok :)
11:13:54 <SamB> back in the day, implementations had to do their own virtual memory ;-)
11:14:35 <monochrom> Oh, overlays, yeah.
11:14:38 <SamB> anyway, I announced it on the haskell@haskell.org mailing list
11:14:41 <SamB> monochrom: nope!
11:14:50 <SamB> at least, I don't think thats how it worked
11:15:31 <monochrom> "virtual machine" appeared in Parnas's papers in the 70s.
11:16:57 <monochrom> And even then, he might learned that term from Dijkstra in the 60s.
11:17:11 <SamB> I think it was mostly the same as virtual memory is now. except that it only applied to the code running in the ZIP.
11:17:40 <SamB> and even then, it only applied to the read-only regions of memory
11:18:17 <monochrom> If it only applied to code and read-only, ie just need to swap in, no need to mark pages dirty and write back, that was overlay.
11:18:40 <SamB> I mean, todays virtual memory applies to the code running on the actual CPU
11:18:55 <SamB> and the data available to it
11:19:29 <SamB> a ZIP's virtual memory only applied to the read only Z-machine memory
11:19:59 <monochrom> Or perhaps overlay learned from ZIP.
11:20:09 <SamB> and I thouht overlay was where you had to swap out a big region and replace it with another, placing it at a predetermined point in memory!
11:20:25 <monochrom> No swap out because it's read-only code.
11:20:40 <SamB> er.
11:20:56 <SamB> I call it "swapping out" whether you have to do work or not!
11:21:27 <monochrom> OK. But then it's exactly ZIP.
11:21:43 <SamB> hmm?
11:22:03 <monochrom> I'm saying overlay = ZIP virtual memory
11:22:09 <SamB> the ZIPs, afaik, used paging. overlays, afaik, did not?
11:22:29 <monochrom> that might be implementation details.
11:22:34 <SamB> nope
11:22:43 <SamB> I think overlays placed undue constraints on code
11:22:46 <SamB> or.
11:22:54 <SamB> at least, placed constraints on code.
11:23:12 <monochrom> OK
11:23:52 <allbery_b> typically overlays were prelinked into fixed address spaces, and there was no mechanism to handle cross-calling between overlays in the same address space
11:24:55 <allbery_b> ...different overlays in the same address space
11:25:22 <SamB> allbery_b: yeah, cross-calling does sort of imply different overlays ;-)
11:25:36 <allbery_b> yeh
11:42:28 <PaulAJ> Hi there.
11:43:01 <SamB> hmm
11:43:31 <SamB> who are you greeting?
11:43:39 <PaulAJ> Anyone who is here.
11:43:43 <SamB> ah.
11:43:50 <ulfdoz> But that's not there. ;)
11:44:03 <PaulAJ> Whether they are here or there.
11:44:21 <SamB> do you want to say something about something?
11:44:41 <monochrom> Yes. Hi there.
11:44:59 <PaulAJ> Nothing in particular.  I don't hang around on IRC much, so I don't know the nettiquette.
11:45:08 * SamB finds it unnerving when people say "hi" when nothing particular has apparantly happened lately
11:45:16 <PaulAJ> Ahh.
11:45:25 <monochrom> I think it's ok.
11:45:29 * PaulAJ is slightly embarrased.
11:45:45 <monochrom> In #haskell it is imperative to say something.
11:45:49 <ulfdoz> But I think, that is special to freenode, in ircnet it is a bit different in the channels I know.
11:45:58 <PaulAJ> I'd have thought you should declare something.
11:46:13 <monochrom> This is because that is how lambdabot determines whether to tell you "you've got mail"
11:46:43 <monochrom> So I try to say "<3 haskell" or something.
11:46:46 <sieni> something
11:46:51 <SamB> but if you say "hello everyone"
11:46:52 <ulfdoz> SamB: I think, it was meant polite, nothing more. ;)
11:47:03 <SamB> that would not leave me wondering what was meant ;-)
11:47:09 <SamB> ulfdoz: yeah
11:47:10 <PaulAJ> Could I bang my own drum a bit, and say "Have you read Paul's Pontifications" on Haskell as a Silver bullet?
11:47:21 <monochrom> Hi, some of you.
11:47:40 <monochrom> Yes, shameless plugs work too.
11:47:43 <SamB> hello, people with prime-length nicks!
11:48:00 * PaulAJ feels excluded.
11:48:22 <monochrom> Hi, my friends.
11:48:22 <SamB> hello, people with composite-length nicks!
11:48:30 * PaulAJ feels included.
11:48:42 <SamB> monochrom: oooh, ambiguousness!
11:49:00 <PaulAJ> No, just a mutable state.
11:49:01 <monochrom> No less ambiguous than "some of you".
11:49:15 <SamB> maybe a little bit
11:49:36 <monochrom> Both refer to a secret list of mine.
11:49:51 <SamB> yes, but one list is secreter!
11:49:53 <chessguy> hmm, i can prove i'm not here. does that mean PaulAJ wasn't greeting me?
11:50:00 <PaulAJ> I've got a little list, of those who would be missed...
11:50:37 <monochrom> Hi, those and only those of you who don't greet yourself
11:50:49 <PaulAJ> I greet all those who do not greet themselves.
11:51:03 <SamB> hello, users of classical set theory!
11:51:11 <chessguy> lol, you guys are even weirder than me, which is pretty darn weird
11:51:32 <monochrom> The people you greet are (equal) the people greeted by all those who greet all those whom you greet.
11:51:32 <sorear> ?seen Russel
11:51:33 <lambdabot> I haven't seen Russel.
11:51:50 <SamB> (if you've recovered from the barber's greeting)
11:51:50 <monochrom> try Russell
11:52:09 <PaulAJ> ?seen Russell
11:52:09 <lambdabot> I haven't seen Russell.
11:52:14 <PaulAJ> ?seen Whitehead
11:52:14 <lambdabot> I haven't seen Whitehead.
11:52:57 <chessguy> who wants to hear a proof that i'm not really here?
11:53:00 <SamB> hmm, the guy I took Calculus 1 with liked whitehead, I think ;-)
11:53:21 <PaulAJ> OK, I'll bite.  Prove you are not here.
11:53:24 <vincenz> chessguy: define "here"
11:53:39 <PaulAJ> Gotta go.  Time to read to my son.
11:53:40 <chessguy> PaulAJ, ok. am i standing next to you?
11:53:41 <PaulAJ> Bye.
11:53:49 <chessguy> pff
11:54:04 <chessguy> vincenz, here in the channel, whatever
11:56:08 <robajs> hi
11:56:09 <chessguy> proving that you're not present in the room is a fun party trick :)
11:56:45 <monochrom> How do you do it?
11:57:01 <chessguy> monochrom, am i standing next to you?
11:57:06 <monochrom> No.
11:57:17 <chessguy> well, if i'm not standing next to you, i must be somewhere else, right?
11:57:19 <vincenz> chessguy: it makes no sense
11:57:29 <vincenz> chessguy: cause since he's not here either...
11:57:31 <chessguy> vincenz, you haven't heard it yet
11:57:35 <vincenz> oh
11:57:36 <chessguy> let me finish
11:57:37 <vincenz> it continues
11:57:38 <monochrom> Right, somewhere else, such as standing next to next to next to me.
11:57:49 <chessguy> ok, so i must be somewhere else
11:57:59 <chessguy> but i can't possibly be both here and somewhere else at the same time
11:58:02 <chessguy> QED.
11:58:19 * vincenz palmslaps and gives chessguy a paper bag to hide his face in 
11:58:25 <vincenz> here, for the embarassment
11:58:26 <monochrom> OK, I need a few shots of whiskey to fathom it.
11:58:42 <vincenz> monochrom: or possibly weed
11:58:54 <monochrom> weed is disgusting
11:59:02 <thermoplyae> I get it, and I agree with the paper bag
11:59:05 <thermoplyae> :P
11:59:14 <monochrom> whiskey is elegant
11:59:23 <robajs> does haskell takes advatage of multiple cpus/cores?
11:59:30 <sorear> yes.
11:59:30 <LoganCapaldo> they both taste horrible
11:59:31 <lambdabot> sorear: You have 1 new message. '/msg lambdabot @messages' to read it.
11:59:34 <monochrom> weed:whiskey :: java:haskell
11:59:37 * monochrom ducks
11:59:59 <monochrom> Do you now see the benefit of greeting when you show up in the channel?
12:00:14 <chessguy> it works better when you're standing around with a bunch of people
12:00:32 <vincenz> monochrom: I disagree
12:00:34 <chessguy> because you can say, e.g., am i in new york? am i in california? no? then, i must be somewhere else
12:00:38 <vincenz> monochrom: whiskey:weed :: java::haskell
12:00:43 <monochrom> yeah, and that happens precisely when they have all had a shot of whiskey or something
12:00:48 <sorear> Why didn't LB announce that when I first talked an hour ago? (the message was 11h old)
12:00:55 <LoganCapaldo> whiskey:weed :: crap:crap
12:01:16 <vincenz> ah, but that means nothing
12:01:16 <chessguy> it doesn't announce it until you say something
12:01:20 <vincenz> crap relates perfectly to crap
12:01:29 <LoganCapaldo> Yep
12:01:39 <LoganCapaldo> and therefore java relates perfectly to Haskell
12:01:39 <vincenz> that does not imply that whiskey and weed are crap
12:01:44 <LoganCapaldo> look what you've both done
12:01:50 <monochrom> whiskey:weed :: 0:0 ??   Nullity???
12:02:31 <vincenz> monochrom:chessguy :: -1
12:03:27 <LoganCapaldo> I must point out that I'm speaking from experience. Not only have a drunk whiskey and smoked weed. I've smoked a bong using whiskey as the liquid
12:04:11 <vincenz> LoganCapaldo: it shows
12:04:35 <LoganCapaldo> I hope so
12:04:38 <vincenz> :P
12:04:42 <vincenz> LoganCapaldo++
12:07:01 <vincenz> > unwords $ zipWith (++) (repeat "Smack that, ") ["all on the floor.", "give me some more.", "till you get sore.", "ooooh"]
12:07:02 <lambdabot>  "Smack that, all on the floor. Smack that, give me some more. Smack that, ti...
12:07:03 <SamB> crap need not relate to crap very well at all.
12:09:22 <lispy> bulat has a sufficiently unique writing style than i can now guess when i'm reading one of his emails fairly reliably
12:09:48 <vincenz> lispy: easy :) If it feels like a google translate from russian...
12:10:05 <lispy> vincenz: heh
12:10:15 <vincenz> honestly, I once did that on Adept's papge
12:10:19 <vincenz> and it felt just like bulat talk
12:11:32 <lispy> SamB: cool zmachine!
12:11:59 <kyevan> does zmachine even work?
12:12:06 <SamB> kyevan: what, mine?
12:12:18 <SamB> we aren't talking about the one with all the sparks
12:12:37 <kyevan> SamB:
12:12:58 <kyevan> SamB: You're talking about the haskell Zork Virtual Machine interpreter, right?
12:13:28 <SamB> yeah.
12:13:34 <SamB> it works, a little bit.
12:13:58 <kyevan> "A little bit"?
12:14:06 <SamB> well. It runs things!
12:14:11 <kyevan> Can I play through Zork with it yet?
12:14:14 <SamB> as long as they are version 5 story files
12:14:19 <kyevan> Oh
12:14:27 <kyevan> No V1 stories?
12:14:39 <SamB> does anyone *have* any of those anymore?
12:14:52 <kyevan> SamB: I think the copy of Zork I have....
12:16:37 <SamB> oh. they do list that here!
12:16:47 <SamB> a single version, with no release number
12:16:58 <SamB> er.
12:17:01 <SamB> no serial.
12:17:22 <Baughn> Might it be possible to translate older versions to the newest one?
12:17:41 <SamB> Doubt it.
12:17:59 <SamB> I mean, a lot of tables are different.
12:18:05 <kyevan> Hmm...
12:18:11 * kyevan checks his zork file
12:18:34 <vincenz> dons left?
12:18:38 <vincenz> @localtime dons
12:18:40 <lambdabot> Local time for dons is Sun Dec 10 07:11:30 2006
12:18:54 <kyevan> Gyg
12:19:01 <kyevan> Frotz reports it as
12:19:02 <kyevan> Revision 88 / Serial number 840726
12:19:10 <SamB> apparantly they put out the first three versions pretty quickly ;-)
12:19:49 <SamB> that is a version three file
12:21:32 <SamB> they only released 9 games for v5?
12:25:26 <wy> What's the function for converting strings to intergers?
12:25:43 <SamB> read?
12:25:44 <ski> > read "123" :: Int
12:25:45 <lambdabot>  123
12:25:45 <LoganCapaldo> @hoogle (Num a) => String -> a
12:25:46 <lambdabot> Prelude.error :: String -> a
12:25:47 <lambdabot> Debug.Trace.trace :: String -> a -> a
12:25:47 <lambdabot> Prelude.fail :: Monad m => String -> m a
12:25:59 <LoganCapaldo> well
12:26:02 <LoganCapaldo> I feel silly
12:26:15 <wy> Oh my!
12:26:27 <ski> > read "123" * 2
12:26:28 <lambdabot>  246
12:26:47 <LoganCapaldo> @hoogle (Read a) => String -> a
12:26:47 <lambdabot> Prelude.read :: Read a => String -> a
12:26:48 <lambdabot> Prelude.error :: String -> a
12:26:48 <lambdabot> Debug.Trace.trace :: String -> a -> a
12:26:56 <LoganCapaldo> @instances Read
12:26:58 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, [a]
12:27:08 <sorear> @subclasses Read
12:27:09 <lambdabot> Unknown command, try @list
12:27:33 <LoganCapaldo> @deriving Read
12:27:33 <lambdabot> Unknown command, try @list
12:27:37 <LoganCapaldo> maybe?
12:27:39 <LoganCapaldo> heh
12:28:17 <wy> I see. It's omnipotent!
12:28:48 <sorear> > read "Just \"foo\""
12:28:49 <lambdabot>  Add a type signature
12:28:53 <sorear> > read "Just \"foo\"" :: Maybe [Char]
12:28:55 <lambdabot>  Just "foo"
12:29:03 <sorear> > read "27" :: Maybe [Char]
12:29:05 <lambdabot>  Exception: Prelude.read: no parse
12:29:28 <LoganCapaldo> let ghci = print . eval . read ;)
12:30:17 <sorear> let ghci = repeatM (print `fmap` eval `fmap` read `fmap` readline)
12:30:21 <wy> LoganCapaldo: But there is no "eval" ?
12:30:33 <LoganCapaldo> I don't think so
12:30:39 <sorear> wy: Yes there is, it's in the GHC-API and has a different name
12:30:40 <wy> where is eval?
12:30:50 <LoganCapaldo> Or I could be wrong :)
12:31:12 <wy> I'd like to try it. I'm been looking for eval for a long time
12:31:14 <sorear> It is used, for instance, by lambdabot.
12:31:26 <glguy> sorear: Are you sure you shouldn't be using =<< in place of some of those fmaps?
12:31:32 <wy> sorear: Should I import something?
12:31:44 <glguy> sorear: since readline and print are both IO
12:32:49 <sorear> let ghci = repeatM (print =<< eval `fmap` read `fmap` readline)
12:33:05 <glguy> (and yes, I realize that it doesn't matter (-; )
12:33:18 <SamB> sorear: is it now?
12:33:39 <ski> sorear : saw my message .. ?
12:33:52 <sorear> http://www.cse.unsw.edu.au/~dons/hs-plugins/hs-plugings-Z-H-4.html
12:33:55 <lambdabot> http://tinyurl.com/ycpr6h
12:34:00 <sorear> ski: yes.
12:34:03 <defcon8> is return only for do operations?
12:34:12 <ski> no
12:34:17 <sorear> return is a monad operation
12:34:22 <defcon8> ok
12:34:26 <sorear> > return 3 :: [Int]
12:34:27 <lambdabot>  [3]
12:34:35 <sorear> > return 3 :: Maybe Int
12:34:37 <lambdabot>  Just 3
12:34:38 <ski> > return (*) `ap` [1,2,3] `ap` [20,30]
12:34:40 <lambdabot>  [20,30,40,60,60,90]
12:35:10 <ski> sorear : any comment ?
12:36:21 <sorear> not yet..
12:36:38 <wy> anyone using Yi here?
12:37:58 <SamB> lispy: so have you played with ZMachine
12:38:02 <SamB> ?
12:39:21 <Rasmus_> if anyone wants to comment on my brute force sudoku solver, be my guest: http://rafb.net/paste/results/eGLTvO21.html
12:39:26 <LoganCapaldo> wy: I've played with it for short periods of time
12:39:40 <LoganCapaldo> _very short_ periods of time :)
12:40:13 <chr1s_> Rasmus_: what longuage is that?
12:40:51 <defcon8> chr1s_, what longuage is that?
12:40:52 <chr1s_> s/longuage/language
12:40:53 <wy> LoganCapaldo: How do you feel about it?
12:41:13 <LoganCapaldo> So far I feel like its a vi clone in haskell :)
12:41:26 <wy> I feel emacs's haskell-mode not convenient. It can't jump to the location of the error.
12:41:33 <Rasmus_> tried to make it haskell
12:41:36 <sorear> ack, just typed ]]]]]] into ircii - the elinks scroll-right character.
12:41:48 <LoganCapaldo> lol
12:42:02 <defcon8> yeah, is there a decent editor for haskell?
12:42:04 <LoganCapaldo> sorear I'm forever typing jjjkkk, etc into irc :)
12:42:06 * sorear is beginning to see the virtues of an editor that thinks it is an OS..
12:42:18 <chr1s_> Rasmus_: I mean Trae and Knude :)
12:42:19 <sorear> ERC, w3-mode, etc...
12:42:28 <Rasmus_> danish :)
12:42:33 <sorear> wy : M-g M-g
12:42:49 <sorear> wy : does the job quite well.  (not perfectly, though)
12:43:00 <sorear> wy : GHC is compatible with M-x compile
12:43:19 <wy> sorear: So you have to parse the error information yourself
12:43:21 <sorear> wy : Try flymake-mode
12:43:22 <emu> wy: C-x `
12:43:35 <emu> wy: that will take you to the location of the error. it's a compilation-minor-mode thing
12:44:16 <defcon8> anyone?
12:44:26 <LoganCapaldo> Not that I'm mr. Haskell or anything, but in any language with a repl I tend to persist to disk at the every end, so I get the errors as soon as I type them in anyway :)
12:44:36 <LoganCapaldo> s/every/very/
12:45:54 <wy> emu: Uhh... I guess I need a step by step thing
12:45:56 <Lemmih> defcon8: emacs?
12:46:06 <emu> wy: step by step for what
12:46:18 <wy> emu: Where should I enable compilation-minor-mode ?
12:46:49 <sorear> wy: Type M-x compile
12:47:28 <emu> wy: it's already enabled
12:47:31 <emu> no.
12:47:33 <wy> Compile command: ?
12:47:36 <emu> it works with inf-haskell
12:47:38 <emu> ignoer that
12:48:00 <emu> use inf-haskell normally. load your file with C-c C-l.  haskell-mode has setup the compilation-minor-mode with the necessary information to jump to the next error.
12:48:02 <sorear> ./Setup.lhs compile <|> make <|> ghci Foo.hs -e System.Exit.exitWith System.Exit.ExitSuccess
12:48:16 <sorear> inf-haskell doesn't work for me.
12:48:17 <emu> all you have to do is type C-x ` and it will jump to the error
12:48:25 <emu> sorear: why not?
12:48:48 <sorear> Symbol's function definition is void: inferior-haskell-load-file
12:48:56 <emu> you don't have it?
12:49:05 <sorear> I'm guessing that's Elisp for "no such function"
12:49:08 <emu> yea
12:49:16 <emu> um, what version of haskell-mode?
12:49:28 * sorear is using 'aptitude install haskell-mode'
12:49:37 <emu> i installed it from CVS, it's a lot newer
12:49:50 <fnord123> Cale, are you around?
12:49:55 <sorear> dpkg says: Version: 2.1-1
12:50:06 <emu> yea 2.1 is over a year old
12:50:22 <emu> inf-haskell still should work though.
12:50:29 <wy> I think it's so easy to parse the ghci output like "/home/wy/prog/core/parse.hs:128:34:", but why it's not done automatically? I'm not good at elisp. But if you cut these error messages from the output and paste them in again. You can click on them.
12:50:34 <emu> wy: it is done
12:50:38 <emu> that's precisely what it does
12:50:43 <psi> sorear: do you get that when you do C-c C-l?
12:50:50 <sorear> psi : yes.
12:50:54 <sorear> and a beep.
12:51:11 <emu> sorear: how did you setup haskell-mode? did you load haskell-site-file?
12:51:20 <emu> or just relied on the debian isntall?
12:51:28 <psi> hm, I though I recognized the error, but I was mistaken, sorry.
12:51:38 <psi> sometimes you just have to do C-c C-l twice.
12:51:52 <emu> can you execute M-x run-haskell?
12:52:55 <emu> sounds like the debian package is screwy
12:53:11 <sorear> emu: I just did the debian install. (you're telling me debian packages *aren't* supposed to just work?)
12:53:15 <xerox> ski: which error message?
12:53:19 <emu> oh they're "supposed" to
12:53:28 <xerox> ski: ah, it's just for fun, it is for a friend
12:53:34 <wy> I have no "run-haskell"
12:53:35 <sorear> M-x run-haskell [No match]
12:53:35 <LoganCapaldo> debian packages make some interesting choices sometimes :)
12:53:50 <emu> yea. i would uninstall that shitty package, and grab it for yourself.
12:54:03 <wy> Everytime I just hit C-c C-r from haskell-mode and a window automatically appears
12:55:02 <emu> b
12:55:16 <xerox> ski: no idea of the actual significance :)
12:56:49 <wy> emu: Thanks. compilation minor mode works
12:56:52 <lisppaste2> emu pasted "haskell-mode" at http://paste.lisp.org/display/31802
12:57:04 <sorear> IT WORKS!!! only autoload is broken
12:57:09 <emu> yea
12:57:10 <sorear> (or at least no error)
12:57:12 <emu> figures
12:58:07 <wy> But it sometimes can't recognize the error line
12:58:14 * sorear didn't know he had hugs installed
12:58:23 <emu> it does "next-error" so if you do it once, then it removes it from the list
12:58:39 <sorear> ERROR ...... Can't find imported module "System.Console.Readline"
12:58:41 <emu> sorear: you can do C-u M-x run-haskell to choose, or, (setq haskell-program-name "ghci") somewhere
12:59:07 <sorear> (I take it Hugs doesn't support the Haskell Hierarichal Libraries?)
12:59:34 <emu> might be an old version
12:59:46 <sorear> how about a ?spelling-nazi plugin :)
12:59:47 <wy> http://paste.lisp.org/display/31803
13:00:09 <sorear> :version --> 20050308
13:00:33 <emu> that rebinds some stuff
13:00:35 <mbishop> god even programming.reddit.com is starting to suck heh
13:00:45 <wy> my version is 2.1
13:00:53 <vincenz> mbishop: "starting to"?
13:00:54 <emu> i have some hoogle.el code which invokes the command line hoogle
13:01:05 <emu> wy: yes. v2.1 is from Nov2005
13:01:13 <wy> emu can you find if there is something wrong with my config? http://paste.lisp.org/display/31803
13:01:18 <wy> Is it old?
13:01:34 <mbishop> vincenz: well, even more noticable heh, a post I made went down to like -1 yesterday, and now it's back up to 4...It's like slashdot all over again
13:02:01 <emu> you shouldnt have to enable compilation-minor-mode explicitly. if you like those keybindings, it looks ok.  don't turn on simple-indent AND indent. just one.
13:02:16 <vincenz> mbishop: LtU
13:02:17 <emu> also don't turn on haskell-ghci
13:02:25 <emu> Stephan says it's deprecated.
13:02:37 <mbishop> vincenz: It's never updated enough
13:02:48 <vincenz> mbishop: chicken-egg
13:03:53 <wy> emu: I see. So I start from a minimal config...
13:04:03 <emu> http://paste.lisp.org/display/31802
13:04:42 <wy> emu: I guess I should get a CVS version
13:05:00 <emu> yea. i don't know why he hasn't released more recently.
13:08:08 <wy> emu: Is 2.1 the lastest version?
13:08:18 <emu> it is the last released one.. but old.
13:08:53 <wy> emu: Can you give me a cvs command line. I just can't remember its syntax...
13:09:35 <emu> you could get my version with additional patches, too
13:12:37 <emu> else its something like: cvs -d :pserver:anoncvs@cvs.haskell.org:/cvs login  # password 'cvs' ; cvs -d :pserver:anoncvs@cvs.haskell.org:/cvs co fptools/CONTRIB/haskell-modes/emacs
13:14:54 <wy> emu: Ah! It works!!
13:15:43 <wy> emu: Of course I want that. Where can I find your patch?
13:16:46 * sorear expresses interest
13:19:26 <wy> emu: good! the indentation almost work well!
13:19:40 <emu> the indentation is interesting, with haskell-indent-mode
13:19:57 <emu> it cycles through possible selections, regarding Layout, by hitting TAB multiple times
13:21:15 <wy> emu: I think Miranda hasn't this type of indentation ?
13:21:20 <Nafai> emu: I would also be interested in your patched version of haskell-mode
13:21:29 <wy> emu: me too!
13:21:38 <mathewm> I need an example of how to implement a counter - I want to count how many times my code performs a specific action
13:21:50 <emu> well i have it in a darcs repo, but i have a tarball which is compact if you want that instead
13:21:51 <mathewm> right now my counter leaks like crazy
13:22:38 <Nafai> darcs if fine for me, if you don't mind
13:22:47 <vincenz> mathewm: counter of what?
13:22:52 <vincenz> mathewm: a monadic action?
13:22:53 <emu> its http://mapcar.org/~mrd/emacs/
13:22:54 <lambdabot> Title: Emacs Info
13:22:59 <petter_> mathewm: performs an action?
13:23:00 <vincenz> mathewm: code might hepl
13:23:05 <mathewm> ok
13:23:06 <vincenz> or at least a demo
13:23:09 <mathewm> @paste
13:23:10 <lambdabot> http://paste.lisp.org/new/haskell
13:23:32 <chessguy> oooh, i know a good example
13:23:37 <chessguy> lemme see if i can find it
13:24:07 <wy> emu: Which one is your patched version?
13:24:18 <emu> Nafai: that's really a repo with a lot of emacs configuration stuff, including several whole modes that i use.  under it is haskell-mode/ and also the file haskell-config.el to load it
13:24:26 <chessguy> mathewm, http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf
13:24:28 <emu> the haskell-mode/ dir
13:24:29 <lambdabot> http://tinyurl.com/zhxow
13:24:38 <Nafai> emu: Cool, thanks.
13:24:41 <emu> -CVS is current cvs and -2.1 is the released ver
13:24:43 <lisppaste2> mathewm pasted "fix space-leak w/ (+ 1)?" at http://paste.lisp.org/display/31806
13:24:58 <mathewm> chessguy: thanks
13:25:05 <wy> http://mapcar.org/~mrd/emacs/haskell-mode/haskell-mode-2.0.tar.gz ?
13:25:42 <emu> hmm?
13:26:10 <wy> emu: Uhh... Just give me the command line. I've got time to learn darcs now
13:26:29 <emu> darcs get http://mapcar.org/~mrd/emacs/
13:26:29 <lambdabot> Title: Emacs Info
13:26:31 <SamB> "darcs get " ++ url
13:26:49 <emu> under that is a sub-dir named haskell-mode/ which is my latest
13:28:11 <wy> emu: I got it ! thanks a lot!
13:29:46 <wy> I like darcs. It's so much simpler than cvs and subversion
13:31:07 <wy> emu: Have you a way to send an expression for evaluation to the haskell interpreter?
13:31:29 <emu> you mean by hand? or programmatically?
13:32:25 <sorear> I love darcs.
13:32:53 <mathewm> hmmm, I am still clueless on how to fix my (+ 1) space-leak :(
13:33:04 <sorear> Once upon a time, I knew that version-control was supposed to be a good thing.  So, I installed CVS and tried using it.
13:33:07 <road> Hello
13:33:10 <emu> my version adds a few commands: C-c t (get type of expression), C-c i (get info of expression), C-c . (try to find-definition)
13:33:30 <emu> C-u C-c t (insert type of expression on line above)
13:33:44 <emu> and it caches the type in haskell-doc
13:33:54 <sorear> Ever fatfingered a cvs command?  Ever imported the parent directory of your $CVSROOT?  Ever seen a linux box with a completely full disk?  It ain't pretty.
13:34:07 <emu> these all require a running inf-haskell
13:34:27 <sorear> (OTOH, I've also managed to pull off rm -rf $HOME...)
13:34:35 <road> I'm a bit confused about Text.Regex. Why doesn't the following return a match:
13:34:37 <road> Main> matchRegex (mkRegex "([:digit:])") "9"
13:34:37 <road> Nothing
13:34:39 <emu> i came close to doing rm -rf ~ thanks to cabal oO
13:34:40 <SamB> sorear: you can do that?
13:34:51 <SamB> emu: oh really?
13:34:52 <SamB> how!
13:35:04 <emu> well i typed runghc Setup.hs configure --prefix=~/local
13:35:04 <sorear> do what? delete your homedir?
13:35:15 <vincenz> mathewm: where??
13:35:17 <emu> then i realized that did not in fact, expand to my home dir
13:35:19 <vincenz> mathewm: which line
13:35:26 <emu> it created a dir in the cur dir called "~"
13:35:32 <vincenz> oh
13:35:38 <mathewm> in rop
13:35:40 <SamB> ouch!
13:35:56 <vincenz> it leaks?
13:36:05 <emu> i had typed rm -rf when i remembered that it was probably not a good idea to just type ~
13:36:16 <mathewm> yeah, according to the heap profile I have
13:36:19 <mathewm> let me run it again
13:36:28 <SamB> emu: how fortunate
13:36:29 <SamB> hmm.
13:36:37 <vincenz> mathewm: 6.6?
13:36:41 <sorear> I tried to delete a directory with rm -r * after bumping the mouse (click-to-type? bah!)
13:36:49 <mathewm> vincenz: 6.6, yup
13:36:58 <vincenz> mathewm: you know that 6.6 has strictness annotations directly?
13:37:01 <sorear> Fortunately it only got to 'g' by the time I pulled the plug.
13:37:05 <SamB> I think zsh has safeguards for rm... probably it would ask me if I really wanted to delete my home directory?
13:37:09 <vincenz> strictinc !inp = ..
13:37:10 <vincenz> I believe
13:37:22 <wy> emu: So I think you can define a send-region-to-haskell
13:37:33 <sorear> Those are called BangPatterns.
13:37:51 <vincenz> mathewm: could be that modifyIORef leaks itself in that it does not eval the function it gets passed?
13:37:54 <sorear> (ain't WikiWords great)
13:38:12 <sorear> IORefs hold lazy boxed values
13:38:19 <mathewm> vinvenz: I will try the strict pattern, last time I tried it I got syntax errors
13:38:31 <vincenz> oh
13:38:34 <mathewm> is there a better alternative to the IORef?
13:38:37 <vincenz> sadly I don't have 6.6 yet so :/
13:38:39 <petter_> Is there something like Scheme's "eval" or "load" in Haskell?
13:38:45 <vincenz> mathewm: stateT?
13:38:48 <vincenz> StateT IO
13:39:09 <vincenz> an io ref seems a bit over the top
13:39:10 * mathewm goes to learn about the StateT
13:39:17 <vincenz> or just plain State if you have no underlying monad
13:39:25 <sorear> ST! ST! ST!
13:39:46 * vincenz smacks sorear 
13:39:49 <vincenz> Learn to use lambdabot!
13:39:54 <vincenz> > unwords $ repeat "ST!"
13:39:55 <emu> wy: perhaps. i don't find much call for it because i usually just C-c C-r
13:39:56 <lambdabot>  "ST! ST! ST! ST! ST! ST! ST! ST! ST! ST! ST! ST! ST! ST! ST! ST! ST! ST! ST!...
13:40:15 <emu> wy: the thing is, with the static type system, you often have to reload the other definitions
13:40:26 <SamB> hmm
13:40:29 <SamB> hydrogen% rm -rf ~
13:40:29 <SamB> rm: cannot remove directory `/home/foo': Permission denied
13:40:36 <nornagon> ?type unwords
13:40:37 <lambdabot> [String] -> String
13:40:39 <wy> emu: I can write my test expressions in a file and send them into the buffer
13:40:58 <emu> lemme see
13:41:03 <SamB> yes, I just created a user so I could see what happened when I tried to delete its homedir ;-)
13:41:07 <sorear> SamB: My rm deletes subdirectories before checking permissions on the parent
13:41:15 <SamB> sorear: ah
13:41:20 <wy> emu: If I don't have this function I would have to search back in the inferior buffer to find things and copy them back and modify...
13:41:31 <SamB> it turns out mine does too
13:41:42 <wy> emu: It would be easy for you
13:41:50 <emu> wy: I use M-r a lot in the inferior buffer too
13:41:55 <emu> it's a comint thing
13:42:01 <vincenz> anyways
13:42:04 * vincenz >>= bed
13:42:07 <emu> would it be useful to have it display the result in the minibuffer?
13:42:30 * SamB removes the user again
13:42:36 <dylan> % rm -f tmp/*
13:42:38 <dylan> zsh: sure you want to delete all the files in /home/dylan/tmp? (waiting ten seconds)
13:42:59 <nornagon> zsh is pretty great
13:43:04 <vincenz> rm -rf :)
13:43:05 <nornagon> but does that work for ~?
13:43:27 <SamB> nornagon: nope!
13:43:30 <SamB> I just tried!
13:43:32 <wy> emu: I think C-c C-r will give us more control
13:43:37 <SamB> thats what I made the user for
13:44:05 <nornagon> SamB: ah, that was zsh? 'k.
13:45:01 <emu> wy: just playing around with a small function to send the region to the haskell process
13:45:12 <wy> emu: Or you can do something like sml-mode is doing. If C-c C-r find it's a definition, convert the definitions into let- and send them to inferior. This way we can do more interactive things.
13:46:39 <sorear> if only: rm -rf ~ / darcs revert / delfile "important" / Do you want to revert this change [yNeieio]? / y / reverted.
13:47:00 <emu> i'll take a look at that
13:47:56 <wy> emu: Thanks a lot! That will make us much more happy coding :-)
14:02:53 * mathewm is confused about mixing IO and ST
14:03:28 <glguy> ST is like IO without all the IO
14:04:05 <mathewm> so how can I pass along an STRef to and (x -> IO a) and increment the STRef ?
14:07:29 <Lemmih> mathewm: Turn the IO action to an ST action?
14:07:30 <glguy> You don't do any IO inside ST
14:07:47 <mathewm> can I interleave ST between IO ?
14:07:59 <glguy> the point of ST is that you can get out of it
14:08:04 <mathewm> I just want a strict global event counter
14:08:07 <glguy> you can't get out of the IO monad
14:08:28 <Lemmih> Use an IORef?
14:08:33 <mathewm> IORef seems to be lazy and gives me a space-leak
14:08:38 <emu> wy: do a: darcs pull
14:08:55 <kyevan> Monads seem like the Mt. Doom of haskell. Looming in the distance and scareing the shit out of me.
14:09:03 <wy> Thanks!
14:09:13 <Lemmih> mathewm: 'writeIORef ref $!' doesn't fix it?
14:09:28 <glguy> kyevan: they are more like that creepy guy in the park, who, once you get to know him, turns out to be quite friendly
14:09:59 <emu> that's right. runSTArray is very friendly. just prickley at first.
14:10:17 <kyevan> glguy: Oh. The only creepy guy I've ever knownt to be in the parks near here, is in jail for rapeing one of my friends.
14:10:18 <integral> The nasty bit of ST is getting the (forall s. s) right
14:10:36 <glguy> kyevan: oh, then you might not like Monads...
14:10:57 <mathewm> Lemmih: I use modifyIORef, but no, $! doesn't seem to help there
14:11:00 * glguy always tries to let the type inferencer deal with the forall
14:11:14 <kyevan> Although I suppose that might be because I'M the creepy-but-nice guy in the park...
14:11:46 <wy> emu: What's the function name?
14:12:00 <emu> wy: inferior-haskell-send-region. it's bound to C-c r atm, though.
14:12:02 <mathewm> My paste is here: http://paste.lisp.org/display/31806, the leak is in rop
14:13:05 <Korollary> hey mathewm. how's Kirkland?
14:13:20 <mathewm> Heya Koro
14:13:31 <mathewm> I haven't been in kirkland much yet, still in CA
14:14:54 <kyevan> :/
14:14:59 <jcreigh> @remember kyevan Monads seem like the Mt. Doom of haskell. Looming in the distance and scareing the shit out of me.
14:15:29 <chessguy> and yet you know you have to go there
14:15:55 <monochrom> Why do you think monads are evil like Mt. Doom?
14:16:07 <kyevan> ghc complains about... something that's wrong. I just saw my err
14:16:08 <wy> emu: Good!
14:16:21 <monochrom> I think monads are like the elf cities.
14:16:35 <kyevan> I had a spair character. I forgot which mode I was in, I guess.
14:16:36 <wy> emu: There is something wrong when I tried to send something like "pSc (mlex "a b c d = e")"
14:16:39 <mathewm> laziness is Mordor
14:16:41 <monochrom> The represent the highest learnings and ideals.
14:16:45 <wy> interactive>:1:28: parse error (possibly incorrect indentation)
14:17:11 <kyevan> monochrom: Because they have a scary name, and all the talk I've heard of them has fallen firmly in Scary Math land
14:17:20 <kyevan> They probably aren't EVIL or anything
14:17:22 <emu> wy: oh. it's the dumb regex i put in.
14:17:23 <kyevan> but.. yeh.
14:17:33 <emu> wy: it thinks that is a declaration.  i'll come up with a better one soon =)
14:17:56 <monochrom> The dark side are scared of the elves too.
14:18:13 <wy> emu: You are so fast!
14:18:46 <monochrom> Just like the imperative programmers fear functional programming.
14:19:17 <kyevan> monochrom: I never had that problem.
14:19:22 <integral> The nice thing about a pure functional program is that it can be entirely optimised away
14:19:39 <Lemmih> mathewm: You can write your own strict modifyIORef, I believe.
14:20:41 <mathewm> I will give that a shot
14:21:16 <emu> wy: there is this neat tool called M-x re-builder ;)
14:21:20 <emu> b
14:21:55 <wy> emu: What's that?
14:22:12 <Lemmih> mathewm: 'modifyIORef c $! strictInc' and 'strictInc inp = inp `seq` (inp + 1)' doesn't change the strictness.
14:22:39 <emu> wy: it's an interactive regular expression builder.  just run that command to see ;)
14:22:59 <mathewm> modifyIORef c $! (+ 1) didn't work
14:23:13 <emu> wy: darcs pull again, though it's just a temporary soln
14:23:16 <Lemmih> mathewm: Of course not.
14:23:19 <mathewm> :(
14:23:59 <wy> emu: I see! That's great. Hope I have this when I tried to write some perl. Ummm.. It seems this is not perl regexp?
14:24:09 <emu> na it predates perl regexp
14:24:34 <emu> basically the differences are: () are treated literally, as well as some other stuff, because they felt you would be matching parens more often than grouping
14:25:32 <wy> emu: yeah! it works!!
14:26:07 <lispy> emu: i think emacs regexp are also missing some really handy character classes from PCRE
14:26:23 <emu> really, though, it should use a more sophisticated "parser" to determine whether the next item is a decl or expr.
14:26:26 <emu> lispy: no doubt
14:26:53 <emu> wy: in addition, you can't mix declarations and expressions in the same region, atm
14:27:16 <wy> emu: I'm used to write some expressions as tests for my definitions. Just put them as comments after the definition. Later if something went wrong I can C-c C-r them into the buffer to see the results.
14:27:19 <Lemmih> mathewm: Using a strict modifyIORef makes your program work.
14:27:56 <emu> wy: indeed.  i never got accustomed to using send-region in general in these modes.  but i do use M-r, and whatever evaluate-expression is, a lot
14:28:01 <wy> emu: The same with sml-mode. I'm happy enough with this :-)
14:28:21 <emu> wy: though, you might want to take up the practice of learning to write QuickCheck properties as you go
14:28:33 <emu> it's pretty slick
14:28:38 <wy> emu: What does that mean?
14:28:39 <mathewm> sweet!
14:28:46 <emu> @where quickcheck
14:28:47 <lambdabot> http://www.cs.chalmers.se/~rjmh/QuickCheck/
14:28:48 <mathewm> Lemmih: thanks!  It seems much clearer now
14:28:56 <emu> wy: it's standard now too, import Test.QuickCheck
14:29:20 <emu> wy: in summary: "automated randomly generated test cases applied to declarative properties you define"
14:30:10 <emu> i'm using it currently to "demonstrate" that my 3 implementations of this algorithm (progressively faster) are in fact, doing the same thing
14:30:13 <wy> emu: Cool! I'll try it
14:30:40 <SamB> @scheck \x -> x * 2 `div` 2 == (x :: Int)
14:30:42 <lambdabot>   Completed 13 test(s) without failure.
14:30:48 <SamB> hmm!
14:31:11 <wy> Ahhhhh!
14:31:22 <SamB> that isn't quite right.
14:31:24 <SamB> @check \x -> x * 2 `div` 2 == (x :: Int)
14:31:26 <lambdabot>  OK, passed 500 tests.
14:31:46 <wy> SamB: Why this time is 500 times?
14:32:01 <notsmack> is the ":: Int" necessary there?
14:32:09 <SamB> wy: SmallCheck and QuickCheck have different strategies for generating test data
14:32:23 <emu> notsmack: yes. it needs to choose from several type-class instances, presumably.
14:32:37 <wy> scheck is SmallCheck and check is QuickCheck
14:32:54 <notsmack> emu: of course, i see.  thanks
14:33:00 <SamB> but, that property isn't true
14:33:01 <newsham> ?check \xs -> (reverse.sort) (xs :: [Int]) == sortBy (swap.compare) xs
14:33:02 <lambdabot>  Not in scope: `swap'
14:33:13 <newsham> ?check \xs -> (reverse.sort) (xs :: [Int]) == sortBy (flip.compare) xs
14:33:14 <lambdabot>  Couldn't match `b -> c' against `Ordering'
14:33:27 <emu> SamB: it's only picking small Ints?
14:33:28 <newsham> ?check \xs -> (reverse.sort) (xs :: [Int]) == sortBy (flip compare) xs
14:33:29 <lambdabot>  OK, passed 500 tests.
14:33:37 <SamB> @scheck \x -> x >= (2^31) ==> x * 2 `div` 2 == (x :: Int)
14:33:39 <lambdabot>   Completed 13 test(s) without failure.
14:33:59 <emu> heh
14:34:02 <SamB> huh
14:34:06 <SamB> @scheck \x -> x >= (2^30) ==> x * 2 `div` 2 == (x :: Int)
14:34:07 <lambdabot>   Completed 13 test(s) without failure.  But 13 did not meet ==> condition.
14:34:19 * SamB silly
14:34:23 <SamB> > 2^31 :: Int
14:34:24 <lambdabot>  -2147483648
14:34:28 <emu> yow
14:34:31 <newsham> ?check \x y -> let s = (x::Int) + y in s >= x && s >= y
14:34:32 <lambdabot>  Falsifiable, after 0 tests: 0, -1
14:34:40 <emu> how bout maxBound - 100? =)
14:35:05 <newsham> ?check \x y -> let s = (abs x::Int) + (abs y) in s >= x && s >= y
14:35:06 <lambdabot>  OK, passed 500 tests.
14:36:10 <kyevan> Hmm....
14:36:29 <newsham> ?check \x y -> let s = (abs x::Int) * (abs y) in s >= x && s >= y
14:36:30 <lambdabot>  Falsifiable, after 8 tests: 2, 0
14:36:47 <kyevan> Why does "elements (Branch left x right) = (elements left) : x : (elements right) : []" fail? (I have a terminator for Leafs that works.
14:36:50 <kyevan> )
14:36:59 <SamB> @scheck \x -> fromIntegral (x :: Int) == fromIntegral (sqrt (x*x))
14:37:00 <lambdabot>  add an instance declaration for (Floating Int)
14:37:07 <SamB> silly
14:37:21 <Cale> kyevan: x is not the same type as (elements left)
14:37:28 <SamB> @scheck \x -> fromIntegral (x :: Int) == sqrt (fromIntegral x^2)
14:37:29 <lambdabot>   Failed test no. 1. Test values follow.: -1
14:37:33 <SamB> okay.
14:37:41 <SamB> so it at least does check negative values.
14:37:41 <kyevan> oh, you're right.
14:37:44 <SamB> actually I could have done...
14:37:45 <Cale> you want something like elements left ++ x : elements right
14:37:48 <kyevan> Thank you, Cale.
14:37:53 <SamB> @scheck (<0)
14:37:54 <lambdabot>  Add a type signature
14:38:00 <SamB> @scheck (<0 :: Int -> Bool)
14:38:01 <lambdabot>  Parse error
14:38:05 <SamB> @scheck (<0) :: Int -> Bool
14:38:06 <lambdabot>   Failed test no. 1. Test values follow.: 0
14:38:18 <SamB> ah
14:38:22 <SamB> @scheck (>=0) :: Int -> Bool
14:38:24 <lambdabot>   Failed test no. 1. Test values follow.: -1
14:38:41 * SamB forgot that if he wants to test whether something is sometimes true, he should test the opposite ;-)
14:38:58 <Cale> though let me show you a trick for making that run a whole lot faster -- the clever thing is to not operate directly with lists, but with functions which add elements to the start of a list
14:39:06 <SamB> okay, but. why is that test number 1?
14:39:11 <SamB> both times?
14:39:31 <Cale> kyevan: what does your Leaf look like?
14:39:42 <kyevan> Cale: elements (Leaf x)              = [x]
14:39:48 <Cale> okay
14:39:58 <Cale> elements' (Leaf x) = (x:)
14:40:22 <Cale> elements' (Branch left x right) = elements' left . (x:) . elements' right
14:40:38 <Cale> elements t = elements' t []
14:41:50 <Cale> The problem which is being avoided here is that xs ++ ys takes O(length xs) steps to evaluate
14:42:16 <jcreigh> Cale: oh, because the only operation lists support is "prepend"
14:42:23 <Cale> yes
14:42:28 <Cale> (in a sense)
14:42:42 <Cale> [] ++ ys = ys
14:42:52 <Cale> (x:xs) ++ ys = x : (xs ++ ys)
14:43:01 <Cale> that's the definition of (++)
14:43:28 <sorear> what you have done is replace lists with trees
14:43:37 <sorear> . creates a node
14:43:53 <sorear> evaluation does an inorder traversal
14:44:11 <kyevan> whoever made http://uncyclopedia.org/wiki/Google needs an award.
14:44:13 <lambdabot> Title: Google - Uncyclopedia
14:44:26 <sorear> also, (++) :: [Char] -> ([Char] -> [Char]) is a monoid isomorphism.
14:44:30 <Cale> Or you could say that I've performed a tree fold, replacing the constructors of the tree type with list-building functions
14:44:54 <Cale> treeFold l b (Leaf x) = l x
14:45:13 <Cale> treeFold l b (Branch left x right) = b (treeFold l b left) x (treeFold l b right)
14:45:23 <monochrom> This is the same technique encouraged by the Show class via the shows and showsPrec methods.
14:45:43 <Cale> elements' = treeFold (:) (\l x r -> l . (x:) . r)
14:45:54 <Cale> right
14:47:04 <Cale> of course, that's concise enough now that we almost don't need the separate definition
14:47:05 <sorear> it transforms the tree; (.) x y creates a pap-two-something, (:) creates a pap-one-something
14:47:17 <Cale> elements t = treeFold (:) (\l x r -> l . (x:) . r) t []
14:47:19 <sorear> elements'' (Leaf x) rst = x:rst
14:47:47 <sorear> elements'' (Branch l x r) rst = elements'' l (x : (elements'' r rst))
14:47:51 <mathewm> Is there any accessible work on controlling exploration through a lazy graph structure?
14:47:54 <sorear> look, no partial apps!
14:51:01 <newsham> most my applications are partial
14:51:04 <emu> > runSTArray $ do arr <- newArray (1,10) 1; return arr
14:51:05 <lambdabot>  Not in scope: `newArray'
14:53:12 <emu> should this be a valid expression?: runSTArray $ (do arr <- newArray (1,10) 1; return arr)
14:53:18 <emu> removing the '$' makes it ok
14:53:26 <emu> (in ghc 6.6)
14:54:17 <sorear> :t runSTArray
14:54:18 <lambdabot> Not in scope: `runSTArray'
14:54:34 <newsham> > import runSTArray
14:54:35 <lambdabot>  Parse error
14:55:25 <newsham> > what error!@#?$
14:55:25 <lambdabot>  Parse error
14:57:30 <nornagon> dons: hey, does unsw have anything like http://www.it.usyd.edu.au/future_students/undergrad/applying/exp_programmers.shtml ?
14:57:32 <lambdabot> Title: Experienced programmers portfolio application - Future UG - The University of Sy ..., http://tinyurl.com/st2hc
14:57:42 <sorear> what's the deal with $ and polymorphism?
14:57:56 <emu> @type ($)
14:57:57 <lambdabot> forall b a. (a -> b) -> a -> b
14:58:22 <Cale> @type Control.Monad.ST.runST
14:58:24 <lambdabot> forall a. (forall s. GHC.ST.ST s a) -> a
14:58:38 <emu> i initially ran into the "bug" using runST
14:58:44 <emu> i tried to write: runST $ do ...
14:58:54 <mwc> emu, I did the same thing
14:58:54 <emu> and got a really weird looking funky type error
14:58:55 <Cale> @type \x -> runST $ x
14:58:57 <lambdabot> Not in scope: `runST'
14:59:07 <Cale> @type \x -> Control.Monad.ST.runST $ x
14:59:09 <lambdabot>   Inferred type is less polymorphic than expected
14:59:09 <lambdabot>    Quantified type variable `s' escapes
15:00:19 <mathewm> ST is serious about keeping its phantom type to itself!
15:00:30 <emu> @type Data.Array.ST.runSTArray
15:00:31 <lambdabot> forall e i. (Ix i) => (forall s. GHC.ST.ST s (GHC.Arr.STArray s i e)) -> Array i e
15:00:36 <emu> mathewm: that wasnt the problem though
15:00:45 <emu> @type Data.Array.MArray.newArray
15:00:46 <lambdabot> forall e (a :: * -> * -> *) (m :: * -> *) i. (Data.Array.Base.MArray a e m, Ix i) => (i, i) -> e -> m (a i e)
15:01:03 <fnord123> has anyone had trouble with the compilation of the Arrow interface in HXT?
15:01:09 <fnord123> ?paste
15:01:10 <lambdabot> http://paste.lisp.org/new/haskell
15:01:11 <emu> > Data.Array.ST.runSTArray $ do arr <- Data.Array.MArray.newArray (1,10) 1; return arr
15:01:11 <lambdabot>  Not in scope: `Data.Array.MArray.newArray'
15:01:21 <emu> @hoogle newArray
15:01:21 <lambdabot> Data.Array.MArray.newArray :: (MArray a e m, Ix i) => (i, i) -> e -> m (a i e)
15:01:21 <lambdabot> Data.Array.MArray.newArray :: (MArray a e m, Ix i) => (i, i) -> e -> m (a i e)
15:01:21 <lambdabot> Foreign.Marshal.Array.newArray :: Storable a => [a] -> IO (Ptr a)
15:01:23 <sorear> :t Data.STRef.newSTRef 4 >> Data.STRef.ReadSTRef
15:01:24 <lambdabot> Not in scope: data constructor `Data.STRef.ReadSTRef'
15:01:27 <emu> fooey
15:01:28 <sorear> :t Data.STRef.newSTRef 4 >> Data.STRef.readSTRef
15:01:29 <lambdabot>   Expecting a function type, but found `m b'
15:01:30 <lambdabot>    Expected type: GHC.ST.ST s b
15:01:34 <sorear> :t Data.STRef.newSTRef 4 >>= Data.STRef.readSTRef
15:01:36 <lambdabot> forall s a. (Num a) => GHC.ST.ST s a
15:01:41 <lisppaste2> fnord123 pasted "HXT compilation error" at http://paste.lisp.org/display/31815
15:01:52 <sorear> :t ($ (Data.STRef.newSTRef 4 >>= Data.STRef.readSTRef))
15:01:54 <lambdabot> forall s a b. (Num a) => (GHC.ST.ST s a -> b) -> b
15:02:09 <sorear> :t ($ (Data.STRef.newSTRef 4 >>= Data.STRef.readSTRef)) Control.Monad.ST.runST
15:02:11 <lambdabot>   Inferred type is less polymorphic than expected
15:02:11 <lambdabot>    Quantified type variable `s' escapes
15:02:20 <sorear> :t (\x -> x (Data.STRef.newSTRef 4 >>= Data.STRef.readSTRef)) Control.Monad.ST.runST
15:02:22 <lambdabot>   Inferred type is less polymorphic than expected
15:02:22 <lambdabot>    Quantified type variable `s' escapes
15:02:41 <Cale> fnord123: you're getting that when compiling HXT itself?
15:02:47 <sorear> :let runST = Control.Monad.ST.runST
15:02:48 <fnord123> Cale, I am
15:02:55 <Cale> which GHC version?
15:03:01 <fnord123> 6.4
15:03:06 <mwc> > runST
15:03:07 <lambdabot>  Not in scope: `runST'
15:03:11 <Cale> I just compiled it fine on 6.4.2 the other night
15:03:16 <sorear> ?let newSTRef = Data.STRef.newSTRef
15:03:16 <mwc> > let runST = Control.Monad.ST.runST
15:03:17 <lambdabot>  Parse error
15:03:17 <lambdabot> <local>:10:11: Not in scope: `Data.STRef.newSTRef'
15:03:19 <fnord123> im using 6.4.1
15:03:22 <Cale> hmm
15:03:27 <mwc> > runST
15:03:28 <lambdabot>  Not in scope: `runST'
15:03:31 <mwc> frack.
15:03:32 <Jessehk> I'm having trouble with a basic shuffling function. I've posted the code and the errors and any help would be appreciated. http://paste.lisp.org/display/31817
15:03:38 <sorear> :t Control.Monad.ST.runST
15:03:39 <lambdabot> forall a. (forall s. GHC.ST.ST s a) -> a
15:03:41 <sorear> :t ($) Control.Monad.ST.runST
15:03:42 <lambdabot>   Inferred type is less polymorphic than expected
15:03:43 <lambdabot>    Quantified type variable `s' escapes
15:03:47 <sorear> :t id Control.Monad.ST.runST
15:03:49 <lambdabot>   Inferred type is less polymorphic than expected
15:03:49 <lambdabot>    Quantified type variable `s' escapes
15:04:06 <sorear> :t (id :: (forall x. x -> x)) Control.Monad.ST.runST
15:04:08 <lambdabot>   Inferred type is less polymorphic than expected
15:04:08 <lambdabot>    Quantified type variable `s' escapes
15:04:23 <Cale> Jessehk: (shuffle $ tail cards) is going to be an IO action, not a list
15:04:49 <Cale> Jessehk: you probably want to run that action and put its result in that spot there.
15:05:07 <sorear> :t (id :: ((forall a. (forall s. GHC.ST.ST s a) -> a) -> (forall a. (forall s. GHC.ST.ST s a) -> a))
15:05:08 <lambdabot> parse error (possibly incorrect indentation)
15:05:10 <Jessehk> Cale, ah, that makes sense.
15:05:20 <sorear> :t (id :: ((forall a. (forall s. GHC.ST.ST s a) -> a) -> (forall a. (forall s. GHC.ST.ST s a) -> a)))
15:05:22 <lambdabot>   Inferred type is less polymorphic than expected
15:05:22 <lambdabot>    Quantified type variable `s' escapes
15:05:24 <Cale> Jessehk: also, the additional return isn't needed for any reason
15:05:36 <Cale> (the one after the (:))
15:05:51 <sorear> Clearly my type is an instance of (a -> a), what gives?
15:05:58 <mgsloan> sorear - you should stick that geom stuff in a darcs
15:06:00 <fnord123> wow, make clean kills the .cabal file
15:06:04 <mathewm> what is a "Linear Graph Algorithm"?
15:06:13 <mgsloan> eg, online :)
15:06:46 <Cale> fnord123: you're following along with the steps on the website?
15:07:12 <astrolabe> Cale: I just read your open letter about 1/0.  I agree with you (where I understand you).  Maybe you were too kind though.
15:07:15 <fnord123> i installed http module only after ./setup build failed. so im cleaning it down and trying again
15:07:35 <Cale> fnord123: ah
15:09:26 <augustss_> open letter about I/O?  sounds interesting
15:09:39 <augustss_> or was that 1/0
15:09:47 <astrolabe> augustss_: the second :)
15:10:28 <SamB> @google open letter about "1/0"
15:10:31 <lambdabot> http://www.w3.org/TR/REC-xml/
15:10:31 <lambdabot> Title: Extensible Markup Language (XML) 1.0 (Fourth Edition)
15:10:38 <SamB> @google "open letter" "1/0"
15:10:42 <lambdabot> http://silly.if.uj.edu.pl/~karol/pdf/OpenLetter.pdf
15:10:45 <augustss_> Cale: is it about the guy who has figured out how to give "meaning" to 1/0
15:10:50 <Cale> http://cale.yi.org/index.php/Open_letter_to_James_Anderson
15:10:52 <lambdabot> Title: Open letter to James Anderson - CaleWiki
15:10:58 <astrolabe> No 22 here http://programming.reddit.com/
15:11:00 <lambdabot> Title: reddit.com: programming - what&#39;s new online
15:11:23 <augustss_> yes, that's what i thought.  i'll have to read it
15:14:36 <Cale> I was getting tired of all the entirely incorrect criticisms of his system
15:14:55 <Cale> (claims of things like inconsistency and so on)
15:15:44 <mgsloan> yeah, once you have mastered doublethink an inconsistant system isn't even a problem :)
15:16:02 <Cale> Well, this system isn't inconsistent
15:16:04 <chessguy> i thought that open letter was extremely well-written
15:16:12 <mgsloan> yeah, i know
15:16:23 <Cale> but yeah
15:16:47 <Cale> There's no real problem with inconsistent systems except that they're kind of boring once you find the inconsistency.
15:16:48 <mgsloan> I didn't look at the original paper, but it sounds like the system could be useful for some problems
15:16:58 <Cale> It's possible
15:17:09 <chessguy> i'd love to see a response from Anderson to Cale's letter
15:17:23 <Cale> It's a reasonable way to handle arithmetic exceptions.
15:17:30 <mgsloan> like how imaginary numbers are useful in the intermediary steps to a real result
15:17:38 <Cale> oh, he did respond, but I didn't post it
15:17:52 <chessguy> oh really?
15:17:54 <Cale> and I replied after that, and he hasn't got back to me
15:17:55 <mgsloan> yeah, making math more like computer stuff
15:18:00 <mathewm> shame he didn't make it public
15:18:09 <chessguy> can you post those two letters?
15:18:15 <Cale> I don't know
15:18:23 <augustss_> I think James Anderson is a crackpot that got too much publicity
15:18:32 <mathewm> that wouldn't seem right w/o permission
15:18:49 <chessguy> or at least give us some idea what he sai?
15:18:51 <chessguy> +D
15:19:04 <Cale> He's a little bit crackpottish, but he actually does know what he's talking about to quite a large extent, and he did actually bother to construct a model of his system in HOL/Isabelle
15:19:16 <fnord123> ok, I've cleaned down my build and tried again and I get the same HXT compilation error
15:19:23 <Cale> fnord123: bizarre
15:19:26 <Cale> hmm
15:19:29 <augustss_> But it's the smart crackpots that are the dangerous ones. ;)
15:20:24 <Cale> I don't really mind them -- you need people looking at stuff like this
15:20:48 <mgsloan> yep. the real problem is when they press it on people... like those kids
15:21:22 <fnord123> You guys are just jealous that he published the solution to 0/0 and you weren't clever enough
15:21:31 <Cale> One thing I did include from his reply to me there is that was a one-time thing.
15:21:33 <chessguy> i think the discussion is very health
15:21:35 <chessguy> y
15:21:38 <fnord123> Gauss, Newton, Anderson. Remember the name
15:21:44 <Cale> hehe
15:21:57 <chessguy> one-time how?
15:22:14 <Cale> chessguy: the teaching-it-to-kids thing
15:22:45 <mgsloan> I think 0/0 should be 1, because then when a=b, a/b = 1 holds for all
15:23:24 <mgsloan> for similar reasons as 0^0 = 1
15:23:27 <Cale> I think we should just take 0 = 1, then 0 is invertible.
15:23:37 <chessguy> haha
15:24:02 <jlouis> Cale, cool. Z/2Z would only have a single element then
15:24:09 <Cale> Sure, it does limit our options when it comes to numbers, but it sure makes things easy.
15:24:34 <Cale> I can easily tell whether two numbers are equal because the answer is always yes.
15:24:46 <jlouis> haha
15:24:48 <twanvl> we need an instance Num ()
15:24:49 <jlouis> it gets better
15:25:01 <jlouis> 3 = 1 + 1 + 1 = 0 + 0 + 0 = 0
15:25:19 <jlouis> So in fact Z only has a single element
15:25:29 <augustss_> You are, of course, free to add such a type to the Haskell Num class :)
15:25:35 <Cale> any ring with 0 = 1 has only one element
15:25:45 <emu> we'd go from binary computers to unary computers
15:25:52 <jlouis> Cale, I guess that is the consequence, yes ;)
15:26:08 <augustss_> All arithmetic operations become very efficient
15:26:10 <emu> much easier to use!
15:26:12 <Cale> We'd save on computer memory because numbers are so much easier to store.
15:26:17 <augustss_> this system has a lot going for it
15:26:23 <Cale> In fact, they take 0 bits.
15:26:34 <emu> yes, with such a computer, even business people could write programs easily
15:26:40 <Cale> You can't get more efficient than that!
15:26:41 <augustss_> so we can store an infinite number of them!!  scary
15:26:49 <chessguy2> ?remember Cale I think we should take 0=1. Then 0 is invertible
15:27:06 <emu> no more tricky business of deciding when to use 0 and when to use 1
15:27:32 <augustss_> I can see some arguments over the Show instance.  Should it prin 0, or 1, or 6357632563254
15:27:35 <wy> What's the name of the pretty print function?
15:27:47 <sorear> augustss_: there is no problem
15:27:55 <mgsloan> just print nothing
15:28:01 <sorear> since there is one state, all programs do the same thing
15:28:14 <sorear> the computer can be build using 0 atoms
15:28:33 <sorear> or 6.023x10^23 atoms, etc
15:28:49 <augustss_> oh, but this was just the numbers, not all types
15:28:52 <Cale> those are the same number anyway, right?
15:28:52 <emu> a computer mole?
15:28:55 <mgsloan> so basically, anything qualifies as this computer
15:29:08 <augustss_> i'm less sure all lists should be empty
15:29:14 <jlouis> Cale, what is it that ideal formed by 1N in a ring is called?
15:29:47 <Cale> hm? If an ideal contains 1, then every element of the ring is in it
15:29:58 <jlouis> oh, I am silly
15:29:59 <jlouis> sorry
15:30:23 <jlouis> I mean that thing (can't remember if its an ideal) formed by 1, 1 + 1, 1 + 1 + 1, ...
15:30:45 * mgsloan calls those church numerals
15:30:45 <Cale> Perhaps you're thinking about how there's a natural homomorphism Z -> R for any ring R
15:31:03 <mgsloan> they might be called peano or something, but i don't know about that.
15:31:14 <Cale> Which sends 0 to 0 and 1 to 1 and otherwise satisfies the properties to be a homomorphism
15:31:38 <Cale> You don't usually consider mapping from the naturals, because they're not quite a ring
15:32:02 <mgsloan> yeah, like what's 3 - 5
15:32:15 * fnord123 upgrades ye olde ghc and tries to make hxt again
15:32:41 <Cale> fnord123: good luck with that -- HXT is really quite nice, I tried it the other night
15:32:56 <fnord123> yeah I was your inspiration for trying it. :P
15:33:07 <Cale> I was expecting an arrow combinator library for that sort of thing to be a bit confusing, but it's actually pretty elegant
15:33:12 <jlouis> Cale, oh I think thats it
15:33:22 * gds takes some time to relax and catch up on HWN after a week of madness....
15:33:29 <Cale> lisppaste2: url
15:33:30 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
15:34:37 <gds> There's a pi calculus monad? Cool....
15:38:30 <chessguy2> what's a Z-machine?
15:38:44 <lisppaste2> Cale pasted "example" at http://paste.lisp.org/display/31821
15:38:55 <Cale> chessguy2: do you know the game Zork?
15:39:09 <augustss_> I read chapter X of James Anderson stuff.  This must be a hoax.  I love it. :)
15:39:09 <chessguy2> vaguely
15:39:39 <Cale> augustss_: It's not really a hoax, it's just not terribly interesting.
15:40:05 <augustss_> Oh, but the Perspex machine...  I think it is a hoax.  If not, it's just sad.
15:40:08 <Cale> fnord123: have a look :)
15:40:27 <Cale> augustss_: oh, I hadn't bothered to really look very hard at that
15:40:42 <augustss_> Oh, that paragraph is such wonderful gobbledygook
15:40:45 <newsham> why dont the standard libs have string splitting functions except "lines" and "words"?
15:40:55 <Cale> fnord123: that program prints ["41"]
15:41:02 <fnord123> hm
15:41:31 <fnord123> and runX is a HXT thing?
15:41:33 <Cale> Of course, I didn't do a really great job of ensuring that I was in the right place in the XML file :)
15:41:34 <Cale> yeah
15:41:36 <augustss_> newsham: span?
15:41:53 <Cale> runX :: IOSArrow XmlTree c -> IO [c]
15:42:06 <fnord123> i guess the next step is to generate these funcs from a .wsdl file :P
15:42:11 <newsham> > span (== '.') "this.is.a.test"
15:42:12 <lambdabot>  ("","this.is.a.test")
15:42:20 <jlouis> Cale, I cheated and took my old algebra book down from the shelf. Prime Ring was what I was thinking of
15:42:30 <newsham> > span (/= '.') "this.is.a.test"
15:42:32 <lambdabot>  ("this",".is.a.test")
15:42:34 <Cale> jlouis: yes, prime subring
15:42:38 <newsham> not all that useful
15:42:40 <jlouis> my ring - theory is rusty
15:42:44 <jlouis> too rusty
15:43:39 <astrolabe> mine too.  I couldn't remember the name.
15:43:46 <Cale> fnord123: if you like that sort of thing, then go for it, I'm sure the HXT people would love it
15:43:46 <astrolabe> sad
15:44:04 <gds> @hoogle (a -> a -> Bool) -> [a] -> [[a]]
15:44:05 <lambdabot> List.groupBy :: (a -> a -> Bool) -> [a] -> [[a]]
15:44:11 <augustss_> newsham: no, you need a little more
15:45:17 <newsham> no I dont..  I was asking why the standard lib doesnt have such a function, not how to build such a function.
15:46:01 <Cale> newsham: people were too busy building parser combinator libraries?
15:46:34 <jlouis> unfortunately, parser combinators are often overkill for simpler string-destructuring
15:46:56 <newsham> i think a string split and a string join would make a good addition.  they come in handy often.
15:47:03 <mgsloan> whoah. NearlyFreeSpeech.net hosting looks really nice.  You can run haskell apparently, and the rates are really good
15:47:09 <newsham> strjoin sep xs = concat $ intersperse sep xs
15:47:28 <jlouis> A fair score of projects I've read defines a function split :: Char -> String -> [String] or split :: String -> String -> [String]
15:47:33 <chessguy> what do you mean by 'run haskell'?
15:47:37 <gds> > groupBy (\x y -> x /= '.' && y /= '.') "these.are.words"
15:47:38 <lambdabot>  ["these",".","are",".","words"]
15:47:45 <mgsloan> chessguy - cgi, i guess
15:47:58 <jcreigh> http://example.nfshost.com/versions.php
15:48:02 <lambdabot> Title: Versions of CGI Languages
15:48:04 <newsham> >>> "this.is.a.test".split(".")
15:48:05 <newsham> ['this', 'is', 'a', 'test']
15:48:47 <jlouis> newsham, that seems very pythonic to me. Far too pythonic ;)
15:48:51 <newsham> >>> "this--is--another".split("--")
15:48:51 <newsham> ['this', 'is', 'another']
15:48:52 <mgsloan> I define split as split :: (String -> SplitAction) -> String -> [String]
15:49:17 <jlouis> mgsloan, aha. Whats the type of SplitAction?
15:49:18 <augustss_> newsham: sure, there are functions missing.  But there are many functions that I'd find more useful than those that are missing.
15:49:23 <jlouis> or its definition even
15:49:52 <mgsloan> data SplitAction = None | Keep | Delete
15:49:58 <newsham> aug: that doesn't detract from my point.
15:50:12 <mgsloan> basically defines if the string starts with a splitter, and if so whether to keep it in the result or leave it out
15:50:30 <mgsloan> maybe data SplitAction = None | Keep | Leave would be better
15:50:30 <jlouis> mgsloan, ah, interesting.
15:50:55 <mgsloan> you can of course define your type of split in terms of this one
15:51:16 <augustss_> newsham: Oh, you want the real answer why they are not in there?  Because Joe based the Prelude largely on the functions in Bird&Wadler, and I don't think they had any other string splitter.
15:51:41 <mgsloan> hmm, the Delete/Leave would also have to have int data within, to define how many chars to remove
15:52:24 <mgsloan> (or skip, rather) - yeah, Skip would be a good name
15:55:42 <mgsloan> It's possible that my complex definition is just to allow it to subsume more responsibilities better relegated to actual parsers, but this is the kind of split i usually use
15:55:50 <mgsloan> it's sort of like a minimal tokenizer driver
15:58:35 <Cale> lisppaste2: url
15:58:36 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
15:59:21 <aFlag> hello. This is kind offtopic, but copying garbage collector is a "stop-the-world" collector, right?
16:00:22 <lisppaste2> Cale pasted "slashdot rss reader" at http://paste.lisp.org/display/31823
16:00:41 <Cale> How's that for trivial? :)
16:00:42 <Excedrin> no, you can have an incremental copying garbage collector
16:02:46 <aFlag> hum
16:03:52 * beelsebob pokes people repeatedly
16:04:03 <Lemmih> Oi!
16:04:36 <wy> Is there a way to trace the functions. Getting information about every input arguments?
16:05:12 <Excedrin> wy: http://www.cs.york.ac.uk/fp/hat/
16:05:14 <lambdabot> Title: Hat - the Haskell Tracer
16:05:16 <Philippa> beelsebob: you're supposed to ask first
16:05:41 <beelsebob> Philippa: not that kind of poking :P
16:05:52 <beelsebob> wy: specifically, you seem to want hat-observe
16:05:53 <LoganCapaldo> @where hat
16:05:53 <lambdabot> http://www.haskell.org/hat/
16:06:04 <LoganCapaldo> heh
16:06:09 <LoganCapaldo> @where glasses
16:06:10 <lambdabot> I know nothing about glasses.
16:06:21 <jcreigh> wy: Not sure exactly what you want, but Debug.Trace might help: http://www.haskell.org/ghc/docs/6.4.2/html/libraries/base/Debug-Trace.html
16:06:21 <beelsebob> alternatively you might want to try hood
16:06:23 <lambdabot> http://tinyurl.com/y2nhcy
16:06:25 <wy> thanks! Do I need to install hat myself or is it in the standard ?
16:06:25 <beelsebob> @where hood
16:06:26 <lambdabot> www.haskell.org/hood/
16:06:36 <beelsebob> it requires you to edit your source
16:06:41 <beelsebob> but it works with more programs
16:06:54 <beelsebob> hat does not require a source edit
16:07:05 <beelsebob> but is limited to Haskell 98 (plus a few additions)
16:08:12 <rc-1> has anyone done chess or go ai in haskell?
16:08:42 <wy> beelsebob: Thanks. So maybe I want hat. Because I don't want to modify my code
16:09:24 <beelsebob> wy: maybe... if you need help with getting hat working, I help develop it, so prod me or malcolm wallace (at least in this channel)
16:09:24 <Cale> @hoogle [a b c] -> a b [c]
16:09:25 <lambdabot> Prelude.head :: [a] -> a
16:09:25 <lambdabot> Prelude.last :: [a] -> a
16:09:25 <lambdabot> List.maximumBy :: (a -> a -> a) -> [a] -> a
16:09:33 <Cale> ugh, no :)
16:09:59 <beelsebob> @hoogle [a b] -> a [b]
16:10:00 <lambdabot> Prelude.head :: [a] -> a
16:10:00 <lambdabot> Prelude.last :: [a] -> a
16:10:00 <lambdabot> List.maximumBy :: (a -> a -> a) -> [a] -> a
16:10:04 <beelsebob> no indeed
16:10:12 <wy> beelsebob: What's hmake? It seems I haven't it
16:10:23 <beelsebob> @where hmake
16:10:24 <lambdabot> http://haskell.org/hmake
16:10:35 <beelsebob> wy: it's a build tool
16:10:43 <beelsebob> it calculates dependancies
16:10:45 <LoganCapaldo> Cale: You mind explaing what [a b c] means?
16:10:47 <beelsebob> compiles files
16:10:49 <beelsebob> and links them
16:11:01 <Cale> I intended it to match an arrow from b to c
16:11:08 <Cale> well, a list of them
16:11:19 <wy> beelsebob: Ah... Is there a all-in-one package for these tools?
16:11:36 <LoganCapaldo> Ah that clears things up completely
16:11:41 <beelsebob> wy: no, but hmake I *think* is the only dependancy for hat (other than a haskell compiler)
16:11:43 <LoganCapaldo> :)
16:11:59 <wy> beelsebob: compiling hmake
16:12:01 <beelsebob> wy: I'll suggest that to the guy who does the packaging, that an all in one package might be a good idea
16:12:12 <Cale> @type first
16:12:14 <lambdabot> forall (a :: * -> * -> *) d c b. (Arrow a) => a b c -> a (b, d) (c, d)
16:12:32 <beelsebob> wy: for the moment, I'd reccomend you use the darcs version of hat - it's been updated to work with things like ghc 6.6
16:12:38 <beelsebob> a new release is being worked on
16:12:50 <wy> beelsebob: uhh.... I'm using ghc6.6
16:13:00 <beelsebob> okay
16:13:07 <beelsebob> then you deffinately need the darcs vesion
16:13:07 <LoganCapaldo> Hmm, Arrows seem to be um, functions
16:13:22 <beelsebob> the current release wont work properly
16:13:27 <jlouis> LoganCapaldo, they are very close to functions
16:13:39 <wy> beelsebob: What the address of its darcs?
16:14:01 <beelsebob> wy: darcs get --partial http://darcs.haskell.org/hat
16:14:03 <lambdabot> Title: Index of /hat
16:14:52 <wy> beelsebob:  What does --partial mean?
16:15:18 <beelsebob> wy: it stops you getting every single patch
16:15:28 <beelsebob> only the ones that are required to get a working repository
16:15:39 <beelsebob> it gives essentially the same result, but much faster
16:16:01 <wy> beelsebob: good. I've got it!
16:16:06 <beelsebob> :)
16:16:38 <wy> beelsebob: Well, it seems I need to do more because there is no "configure"
16:16:54 <beelsebob> wy: yes there is
16:16:59 <beelsebob> but it's not got the x bit set
16:17:27 <beelsebob> you need to run "sh start"
16:17:51 <Cale> sequenceA (x:xs) = proc v -> do
16:17:51 <Cale>     xr <- x -< v
16:17:51 <Cale>     xsr <- sequenceA xs -< v
16:17:51 <Cale>     returnA -< (xr : xsr)
16:18:43 <wy> beelsebob:
16:18:49 <beelsebob> lo
16:18:51 <wy> beelsebob: Ok. it works
16:18:53 <beelsebob> :)
16:18:56 <beelsebob> building?
16:19:09 <wy> yep :0)
16:19:17 <Cale> that's the function I was looking for -- does anyone know if there's an existing version of it around? I'm thinking perhaps I could use the Traversable library if I used a newer GHC.
16:19:18 <beelsebob> yell if you have any more problems
16:19:52 <Cale> (which already has a function sequenceA which is way more general)
16:20:07 <wy> beelsebob: Thanks a lot!
16:20:12 <beelsebob> wy: np
16:23:52 <mbishop> I think everyone on reddit should start upmodding qwe1234's posts
16:24:08 <mbishop> then he won't get his jollies from being the usual troll
16:24:12 <wy> beelsebob: Do I have to use hmake in order to use hat?
16:24:31 <beelsebob> wy: you don't have to, but it makes life a lot easier
16:24:46 <beelsebob> if you don't want to use hmake then you have to invoke hat-trans manually
16:25:08 <beelsebob> (hat-trans does a source code transformation on your code that makes it self-tracing)
16:26:10 <wy> beelsebob: It seems there is no way to do it inside the interpreter? like :trace f ?
16:27:02 <beelsebob> wy: no, hat traces your code by doing an automatic transformation on the source code, and then compiling and running that instead, so you would have to load the tracing code into the interpretter... which would be very hard
16:31:14 <wy> beelsebob: I see... But I've found the bug before hat finished compiling. So I'll keep it for harder bugs later :-)
16:31:21 <beelsebob> hehe
16:31:22 <beelsebob> :D
16:31:33 <beelsebob> glad to see hat was so successful :P
16:31:44 <wy> beelsebob: ;-)
16:34:00 <jlouis> heh, the mere mentioning on even rolling-your-own-debugger make haskell bugs go away
16:35:28 * beelsebob just wishes that people would actually use Haskell instead of some weird variant on it that the two simons implement
16:37:01 <Cale> What, Haskell98?
16:37:19 <Cale> You mean we're not supposed to use multiparameter typeclasses?
16:37:24 <beelsebob> well, plus adendums - like actual, real, documented haskell
16:37:27 <beelsebob> tbh... no
16:37:35 <beelsebob> I've been writing all my code in Haskell for 3 years now
16:37:50 <beelsebob> and not found a single time when I've needed more that Haskell's normal type system
16:37:59 <Cale> You can only reasonably standardise on something if you've had lots of time to try it out
16:38:08 <jlouis> mp typeclasses, fundeps, rankN, GADT, etc
16:38:10 <beelsebob> yes... and Haskell had
16:38:22 <Cale> You haven't used monad transformers?
16:38:23 <beelsebob> haskell had existed for a long time before Haskell 98 came about
16:38:36 <beelsebob> no, I haven't, I've found no use for monads other than IO
16:38:39 <Cale> Sure, but MPTCs hadn't
16:38:55 <beelsebob> to me, monads just give you a way of writing in imperative style
16:38:57 <Cale> and you've been using Haskell for 3 years?
16:39:00 <beelsebob> and got knows why I'd want to do that
16:39:09 <beelsebob> no... I've been writing *all* my code in Haskell for 3 years
16:39:16 <Cale> You've missed the boat on monads :)
16:39:19 <beelsebob> I've been using haskell for a lot longer than that
16:39:40 <Cale> Monads are a really nice way to structure combinator libraries so that control code can be shared between them.
16:39:50 <beelsebob> how so?
16:40:56 <Cale> By coming up with a standard set of simple combinators, you can take advantage of typeclasses to write code that works in a multitude of combinator libraries
16:40:59 <Cale> like mapM for instance
16:41:03 <Cale> @type mapM
16:41:05 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
16:41:12 <beelsebob> and what was wrong with map?
16:41:16 <Cale> it doesn't care if I'm doing IO, or if I'm parsing
16:41:25 <Cale> It's a completely different thing from map
16:41:40 <Cale> mapM f = sequence . map f
16:41:46 <Cale> (they are related of course)
16:41:48 <beelsebob> yes... mapM does each in sequense, map does them when required
16:42:09 <beelsebob> as I stated earlier... just a way of writing in imperative style
16:42:12 <beelsebob> of enforcing order
16:42:24 <Cale> Depends on what you mean by "order"
16:42:24 <beelsebob> I don't want to enforce what order my code is evaluated in
16:42:36 <Cale> In some sense, composition is a means of enforcing order
16:42:45 <beelsebob> yes, but not evaluation order
16:42:49 <jlouis> hacking code purely functional is cool
16:43:01 <Cale> Nothing about monads forces evaluation order
16:43:04 <beelsebob> two functions being composed does not mean that the evaluation will happen that way
16:43:09 <Cale> Even the state monad is lazy
16:43:20 <Cale> and what about the list monad?
16:43:28 <Cale> You use list comprehensions, no?
16:43:47 <Cale> What about parsec?
16:43:58 <beelsebob> I actually have my own parser combinator library
16:44:01 <beelsebob> that is non-monadic
16:44:12 <Cale> Well, there's no reason *not* to make it monadic.
16:44:23 <beelsebob> there's no reason *to* make it monadic
16:44:24 <Cale> (well, not much reason)
16:44:32 <beelsebob> putting it in a monad just makes it more complicated to read
16:44:33 <jlouis> Cale, whats the advantage of making it monadic?
16:44:37 <Cale> There's plenty of reasons
16:44:46 <Cale> You get all the stuff in Control.Monad for free
16:44:49 <beelsebob> like obfuscation for example
16:44:54 <Cale> plus, monad transformers work for free
16:45:10 <beelsebob> monad transformers are irrelevant unless you have monads
16:45:15 <Cale> Monad transformers are a very fast way to build EDSLs
16:45:17 <beelsebob> they are only needed when you decide you need monads
16:45:40 <beelsebob> monads are only an abstraction... that happens to be vastly over used by the haskell comunity
16:45:46 <beelsebob> (IMHO)
16:45:46 <Cale> You can construct an EDSL which is appropriate to your problem in a fraction of the lines of code and thought which it would normally require
16:45:57 <Cale> I don't think it's over-used at all
16:45:57 <jcreigh> Cale: EDSL? <something> Domain Specific Language?
16:46:01 <Cale> Embedded
16:46:09 <Cale> As in embedded in Haskell.
16:46:30 <jlouis> beelsebob, whats your take on the STM monad then? Surely, you must have heard of it
16:46:49 <jlouis> (of course its tied closely with IO :)
16:46:49 <beelsebob> jlouis: sure, but I've never found cause to use it
16:46:50 <Cale> It's just a way to get some uniformity across all the combinator libraries we write. Chances are, even if your combinator library is not a monad, it's an arrow or an applicative functor.
16:47:02 <beelsebob> tho only monad I've ever actually used is the IO monad
16:47:14 <beelsebob> becasue you really do need ordering so the abstarction of ordering makes sense
16:47:23 <Cale> You've missed the point if you don't understand why this is a good thing, and you really should have another close look at it.
16:47:40 <Cale> Monads do not enforce ordering any more than function composition does.
16:48:05 <beelsebob> Cale: no, they don't enforce it, but the whole point of the abstraction is to make ordering obvious
16:48:09 <beelsebob> hence the "then" operator
16:48:14 <Cale> not really
16:48:15 <beelsebob> (or bind)
16:48:23 <beelsebob> do this, then this then this
16:48:24 <beelsebob> ....
16:48:39 <Cale> It does give you a mental conception of ordering, but that might not align with what's really happening at all.
16:48:51 <Cale> (similarly to composition)
16:48:53 <beelsebob> exactly
16:49:08 <beelsebob> I'd rather have a mental concept of the maths
16:49:13 <beelsebob> rather than of an arbitary ordering
16:49:14 <Cale> It's no more imperative than function composition is.
16:49:32 <emu> i'm grappling with a QuickCheck property where it reports a falsifiable case, but when I check it by hand, it comes out True!
16:49:35 <emu> what fun
16:49:39 <Cale> In fact, >>= is usually just a fancy form of function application
16:49:42 <beelsebob> yes... but then function composition is not applicable to every problem
16:49:51 <beelsebob> in fact... 99% of the time you are not using function composition
16:50:02 <beelsebob> and yet Haskell programmers all seem to use monads 99% of the time
16:50:03 <Cale> and >>> in arrow combinator libraries is a fancy form of composition
16:50:16 <Cale> yes, that's because they're a *really* good abstraction
16:50:28 <beelsebob> they're a really good abstraction... of ordering
16:50:31 <Cale> no
16:50:33 <beelsebob> not all problems are ordered
16:50:38 <beelsebob> in fact... most arent
16:50:38 <Cale> that's not what they're about at all
16:50:43 <Cale> you're missing the point
16:50:45 <beelsebob> it really is
16:50:47 <Cale> no
16:50:51 <Cale> it really isn't
16:50:56 <Cale> the IO monad is about ordering
16:50:57 <beelsebob> that's why they are made up of a "do something" and a "then do something else" operator
16:51:09 <Cale> what?
16:51:18 <beelsebob> bind and return correspond exactly with "then do this" and "do this"
16:51:26 <emu> only in one interpretation
16:51:27 <Cale> no they don't
16:51:54 <beelsebob> so that's even more useless then
16:51:57 <Cale> I get the feeling that you just don't understand monads to begin with
16:52:02 <emu> that is not the interpretation for the Maybe monad
16:52:11 <beelsebob> the entire point of an abstraction is to allow the programer to know what the operations mean
16:52:16 <Cale> yes
16:52:17 <beelsebob> because they all have a common property
16:52:22 <Cale> and that's not what they mean :)
16:52:40 <beelsebob> the fact that the Maybe monad is entirely different from the IO monad just shows how bad an abstraction it is
16:52:45 <emu> beelsebob: do you have experience with formal logic systems?
16:52:50 <beelsebob> yes
16:52:59 <beelsebob> some limited experience with B
16:53:05 <beelsebob> and a little less with Z
16:53:14 <dons> moin
16:53:21 <beelsebob> moin moin
16:53:28 <kfish> moin dons
16:53:32 <emu> the notions "bind" and "return" are operators which obey mechanical rules to which any interpretation may be applied
16:53:56 <emu> the interpretation must be consistent with the Monadic laws for it to be valid of course
16:54:01 <jlouis> The maybe monad has its uses
16:54:05 <beelsebob> emu: so you're saying that "monads can be anything you like them to be"... it's like string theory... all we need to do to make it fit is tweak it a bit
16:54:10 <jlouis> as does Either
16:54:13 <beelsebob> it's an absolutely useless abstraction
16:54:18 <Cale> beelsebob: no it's not
16:54:28 <beelsebob> it fits everything because it does nothing
16:54:32 <dons> beelsebob: are you trolling? ;)
16:54:34 <Cale> It's at least as useful an abstraction as a monoid
16:54:40 <Cale> yes he is
16:54:46 <emu> beelsebob: no not really.  you see, if you really believe that, then you also believe that arithmetic is an absolutely useless abstraction.
16:54:47 <beelsebob> dons: well... I am now... I wasn't at the start of the argument
16:54:56 <jlouis> beelsebob, I disagree. I'd hate to write code which does case foo of Nothing ... Just bar -> case bar of ... Nothing ... Just baz -> case baz of ...
16:54:59 <Cale> I can't believe that someone could spend 3 years writing Haskell without understanding monads properly
16:55:03 <beelsebob> what it comes down to is that I don't like monads because in my brain all they do is complicate my understanding
16:55:06 <kfish> dons i was wondering when you were going to show up, are your boots polished?
16:55:06 <jlouis> The do-notation is much cleaner to read
16:55:09 <Cale> (more, even)
16:55:34 <beelsebob> jlouis: iff you *know* that the do notation for the maybe monad hides the fact that you're always dealing with Nothing appearing
16:55:35 <Cale> beelsebob: they simplify understanding of combinator libraries by obeying standard laws
16:56:06 <beelsebob> but they aren't standard laws
16:56:17 <jlouis> beelsebob, true, you need to know that. But I have seen my share of SML code with the above pattern.
16:56:20 <Cale> so that this wide class of combinator libraries have their basic operations satisfy a bunch of rules which you only have to learn once
16:56:22 <Cale> yes they are
16:56:23 <beelsebob> the law for Maybe is different to the law for IO which is different to the law for state
16:56:30 <beelsebob> they are all different
16:56:36 <beelsebob> which makes the abstraction useless
16:56:36 <Cale> no, the *monad laws* hold for all of them
16:56:37 <emu> no, they all follow the same laws: the monad laws
16:56:57 <emu> it is what they have in common, and is why they have been defined as monads
16:57:00 <dons> beelsebob: are you serious? you're scaring me.
16:57:19 <beelsebob> dons: yes - monads make it 10000000 times harder for me to understand what code is trying to do
16:57:34 <beelsebob> every single line I'm sitting there thinking " what the hell is the monad doing this time round"
16:57:40 <Cale> Invest some time learning about monads
16:57:41 <beelsebob> instead of just reading the code and understanding it
16:57:48 <dons> ok. good. I encourage you to write your backtracking code using manually inlined list monads then
16:57:50 <Cale> and you'll be fine
16:58:23 <beelsebob> dons: I already have a backtracking parser combinator library that comes out lovely and clean thanks :)
16:58:24 <jcreigh> although I gather it's perfectly possible to write a "non-conforming" monad. I don't know what the standard monad functions would do in that case...probably generate weird, incorrect results...
16:58:31 <araujo> beelsebob, that's because monads are a very abstract concept.
16:58:45 <Cale> yeah, and good luck managing something equivalent to StateT s Nondet a
16:59:02 <allbery_b> <beelsebob> dons: I already have a backtracking parser combinator library that comes out lovely and clean thanks :)
16:59:02 <beelsebob> Cale: okay - I'll thread my state in a record thanks :)
16:59:03 <araujo> beelsebob, as soon as you understand it ; everything will fit well.
16:59:06 <allbery_b> ...which, oddly enough, is a monad
16:59:15 <Cale> by hand, through the list operations
16:59:21 <allbery_b> guess you can't use it because it's complicating things
16:59:27 <Cale> which is a major pain in the ass
16:59:53 <Cale> You can write some combinators to do it for you, but then guess what, you're writing a monad instance
17:00:20 <araujo> beelsebob, The best way to understand monads is to know that monads do nothing by themselves.
17:00:37 <araujo> beelsebob, A monad is just a 'way' to combine computations.
17:00:59 <araujo> Computations take care of the 'what' .. monads will give you the 'how'
17:01:08 <araujo> That's why monads are a way to emulate imperative coding.
17:01:10 <beelsebob> araujo: I already have the how
17:01:13 <beelsebob> it's called writing a function
17:01:20 <araujo> wrong
17:01:24 <dons> araujo: beelsebob knows what they are, come on ;) he's just winding us up for some bizarre misanthropic reason
17:01:27 <Cale> newtype Sudoku a = Sudoku (StateT (DiffUArray (Int,Int) Int) Nondet a)
17:01:27 <Cale>     deriving (Functor, Monad, MonadPlus)
17:01:30 <araujo> A function is the 'what'
17:01:38 <Cale> that saves writing about 50 lines of code.
17:01:40 <araujo> dons, aaah
17:01:41 <araujo> ;-)
17:01:42 <Cale> those two lines
17:01:54 <Cale> and that's a conservative estimate
17:01:59 <jlouis> Cale, oh, thats a cool trick for making sodukos.
17:02:03 <beelsebob> Cale: why on earth would I want my Sodoku to have state
17:02:09 <Cale> the amount of code it saves increases with the complexity of the surrounding program
17:02:27 <Cale> beelsebob: It's not really state :)
17:02:33 <beelsebob> exactly
17:02:35 <beelsebob> it's a falacy
17:02:44 <Cale> It's really labels for a backtracking tree.
17:03:19 <beelsebob> so why did you call it a state
17:03:21 <beelsebob> when it wasn't
17:03:33 <Cale> Well, it can be thought of as state as well
17:04:16 <Cale> You can think of this part of the set-up of a small imperative language where things magically backtrack when you make an incorrect move in the puzzle.
17:04:23 <beelsebob> but I don't want to think of it as state
17:04:30 <beelsebob> I want to think of it as a backtracking tree
17:04:34 * allbery_b rolls his eyes
17:04:39 <Cale> and you don't have to
17:04:46 <Cale> because it really is that tree
17:04:50 <beelsebob> the point of an abstraction is to let me think of it how I want to think of it
17:04:58 <beelsebob> monads did the oposite
17:04:58 <Cale> yes, and you're still free to do that
17:05:04 <mgsloan> yeah. a DSL with negative sleep would be fun
17:05:18 <beelsebob> I want my code to say "this is a backtracking tree" not "this is state"
17:05:30 <Cale> No, you're absolutely wrong, there are two ways to look at every monad
17:05:31 <mgsloan> sorta offtopic, since that's a different, less useful form of backtracking
17:05:44 <Cale> As a type of computation, and as a type of container.
17:06:01 <emu> i know
17:06:12 <Cale> Every monad can be thought of simultaneously in these two very different ways.
17:06:14 <emu> write: data ThisIsABacktrackingTreeT
17:06:19 <emu> no more Stat
17:06:26 <Cale> LabelT
17:06:51 <beelsebob> no... look... your code explicitly says "this is state" - as a reader I have no idea that state means "backtracking tree" - your code should make it explicit what you are doing and why - it shouldn't hide behind some magical "state" object
17:06:53 <Cale> and well, Nondet is already isomorphic to the list monad
17:07:03 <Cale> It's not magical
17:07:09 <Cale> just learn the library
17:07:11 <beelsebob> anyway, I'm off to bed
17:07:15 <Cale> It's not even that hard
17:07:20 * allbery_b wanders off to play a game where the trolls are more deadly and less boring
17:07:22 <Cale> I have no idea why you've avoided it
17:08:12 <Cale> beelsebob: do you understand the following?
17:08:17 <Cale> > join (*) 5
17:08:19 <lambdabot>  25
17:09:24 <jlouis> Cale, what join is that?
17:09:31 <Cale> the one for ((->) e)
17:09:47 <jlouis> where is that defined? Which module?
17:09:52 <Cale> Control.Monad.Reader
17:10:05 <Cale> or in newer GHCs, Control.Monad.Instances
17:10:19 <dons> Cale: I'm almost certain beelsebob actually understands what's going on, but late on a Saturday he felt a bit mischievous...
17:10:26 <jlouis> never seen it. What does it do?
17:10:44 <mathewm> strips off a layer of monad
17:10:57 <dons> Cale, i.e. this is who's asking the questions, http://www.cs.kent.ac.uk/people/rpg/tatd2/pubs.html  :)
17:10:59 <lambdabot> Title: Computer Science: Publications by Thomas Davie
17:11:02 <Cale> join :: (Monad m) => m (m a) -> m a
17:11:14 <Cale> dons: I'm aware, I can't really believe it either
17:11:17 <jcreigh> hmm, this discussion has renewed my interest in drinking the monad Kool-Aid. Are there any good tutorials in addition to YAHT and "All About Monads" I should be looking into? Most of the other tutorial-style material online seems to be of the stupid analogy type ("Monads are just like Barney the Dinosaur!") which just doesn't do it for me.
17:11:43 <Cale> jcreigh: Have you read my Monads as Containers article?
17:11:48 <dons> the new 'monad transformers step-by-step' is quite good
17:12:05 * lispy agrees with both Cale and dons on this one
17:12:07 <Cale> also, reading and understanding my Sudoku solver is a good idea
17:12:09 <jcreigh> Cale: no, I haven't. I'll ask google about it.
17:12:22 <jlouis> mathewm, ah.
17:12:25 <glguy> monads as sequenced computation whose intermediate results are visible to said computation
17:12:25 <lispy> jcreigh: it's on the wiki...should be easy to find
17:12:27 <dons> why is the "drinking the * Kool-Aid" meme cropping up some much at the moment?
17:12:33 <dons> i see it almsot daily
17:12:37 <jlouis> I still don't really see whats going on in 'join (*) 5' though
17:12:40 <lispy> oh yeah!
17:12:49 <Cale> http://haskell.org/haskellwiki/Monads_as_containers
17:12:50 <lambdabot> Title: Monads as containers - HaskellWiki
17:12:52 <Cale> okay
17:13:00 <Excedrin> Cale: does your sudoku solver do breadth first search?
17:13:00 <Cale> well, you know what join is in do-notation?
17:13:02 <jcreigh> dons: sounds like it's time to drink the "drinking the Kool-aid meme" Kool-aid. :)
17:13:14 <dons> hehe
17:13:16 <jlouis> the result seems to be to apply 5 * 5
17:13:25 <Cale> Excedrin: depth first, and it's very naive, but that's not the point :)
17:13:28 <jcreigh> Cale: thanks for the link.
17:13:35 <glguy> applicatice as sequenced computation whose intermediate results are not visible to said ccomputation
17:13:37 <mathewm> join as in meet?
17:13:44 <jlouis> Cale, not totally sure about that
17:13:49 <Cale> join xss = { do xs <- xss; xs }
17:13:53 <Cale> oops
17:13:54 <lispy> > join [[1]]
17:13:55 <lambdabot>  [1]
17:13:56 <Cale> join xss = do {xs <- xss; xs }
17:14:02 <dons> Cale: I'd like a plugin that inlines bind and return instances for a particular monad , and then reduces that expression
17:14:04 <lispy> > join [[1..3],[4]
17:14:05 <lambdabot>  Parse error
17:14:06 <lispy> > join [[1..3],[4]]
17:14:07 <Cale> or, if it helps,
17:14:07 <lambdabot>  [1,2,3,4]
17:14:09 <dons> actually, hat would be good for that1
17:14:13 <Cale> join xss = do {xs <- xss; x <- xs; return x}
17:14:13 <jlouis> Cale, ah yes. Then it strips a layer
17:14:20 <Cale> okay
17:14:22 <dons> we should ask beelsebob if he'll plug hat in :)
17:14:36 <Cale> in the ((->) e) monad, computations are just functions which still take a parameter
17:14:48 <Excedrin> Cale: in terms of speed, encoding lots of sudoku solving rules doesn't improve things afaik... bfs+simplest rules=best speed
17:14:53 <jlouis> is ((-> e) the reader?
17:15:04 <jlouis> Reader monad even?
17:15:04 <Cale> yeah, it's totally isomorphic to the reader monad
17:15:07 <jlouis> ok
17:15:14 <Cale> and there's essentially an implicit parameter which is passed to all of the computations
17:15:23 <glguy> join (asks (*))
17:15:34 <Cale> > do { x <- (+5); y <- (*2); return (x * y) } 5
17:15:35 <lambdabot>  Parse error
17:15:38 <Cale> oops
17:15:40 <Cale> > (do { x <- (+5); y <- (*2); return (x * y) }) 5
17:15:42 <lambdabot>  100
17:15:48 <Cale> neat, eh?
17:16:01 <jesusphreak> quick question: is there difference between 'data' and 'type' is that data is used for polymorphic types?
17:16:04 <jesusphreak> the*
17:16:10 <dons> nope
17:16:13 <Cale> that computes x * y where x = 5 + 5, y = 5 * 2
17:16:35 <dons> type lets you name type synonyms, that are behaviourally identical to the original type
17:16:42 <jesusphreak> ah
17:16:46 <dons> data defines new types (and corresponding data structure)
17:16:50 <jlouis> Cale, ah, I see that
17:16:52 <Cale> and in fact treated as the same type by the compiler
17:16:55 <jesusphreak> okay, that makes sense
17:17:05 <Cale> so what does join do?
17:17:16 <Cale> join f = do { g <- f; g }
17:17:19 <jlouis> haha
17:17:37 <jlouis> join (*) = do { g <- (*); g } ?
17:17:41 <Cale> right
17:17:52 <dons> mmmm, haskell hosting! http://example.nfshost.com/versions.php
17:17:58 <lambdabot> Title: Versions of CGI Languages
17:18:07 <jlouis> hrm, passing 5 to that does what?
17:18:09 <Cale> and so (*) is applied to the parameter once, and then the result is applied to the parameter again
17:18:15 <Cale> so join (*) x = x * x
17:18:42 <jlouis> bingo! got it
17:18:56 <mathewm> I am going to need to bake on that some more
17:19:01 <mathewm> very cool, though
17:19:34 <Cale> another interesting thing to consider is that (.) = fmap
17:19:37 <glguy> > runReader (do f <- asks (*); a <- asks f; return a) 5
17:19:38 <lambdabot>  25
17:19:42 <Cale> (with that functor instance)
17:20:03 <jlouis> 5 is applied to both (*) and g. (*) fires as soon as it has 2 arguments
17:20:22 <Cale> and so we could, if we cared, replace (.), map, fmap, liftM, liftA all with the same polymorphic function
17:20:46 <glguy> Cale: what would be the type of such a function?
17:20:54 <Cale> the same as fmap's type
17:21:01 <jlouis> ?type liftA
17:21:02 <lambdabot> Not in scope: `liftA'
17:21:07 <Cale> > fmap (+1) (*2) 5
17:21:09 <lambdabot>  11
17:21:13 <jlouis> something Applicative?
17:21:43 <Cale> yeah
17:21:54 <Cale> @type Control.Applicative.liftA
17:21:56 <lambdabot> Couldn't find qualified module.
17:22:01 <Cale> oh, not a new enough GHC
17:22:26 <jlouis> is there something on Applicative anywhere? It seems to be something which could be fun to study
17:22:35 <glguy> there's a paper
17:22:52 <Cale> http://www.cs.nott.ac.uk/~ctm/IdiomLite.pdf
17:23:02 <glguy> the one that introduces: mean = iI (/) sum genericLength Ii
17:23:38 <jlouis> http://www.soi.city.ac.uk/~ross/papers/Applicative.html
17:23:40 <lambdabot> Title: Applicative Programming with Effects
17:23:41 <chessguy> who are you calling an idi....oh, never mind
17:23:59 <mbishop> God chessguy, you're such an idiom
17:24:19 <mathewm> ((->)a) is crazy talk
17:24:22 <chessguy> :)
17:24:48 <mbishop> :P
17:24:53 <mq_mattr> morning all
17:24:55 <Cale> mathewm: remember, putting it in parens makes (->) prefix, so that's really more like (e ->)
17:24:59 <chessguy> you're all just a bunch of freaking idoms. Gosh!
17:25:25 <Cale> and of course, functions from a fixed type are an awful lot like containers indexed by that type
17:25:26 <mathewm> (->a) is even crazier
17:25:36 <Cale> and so you can use the container analogy fairly well :)
17:25:56 <Cale> what does fmap f g do?
17:26:07 <Cale> It applies f to every element of the "container" g
17:26:31 <mathewm> sure, that makes sense
17:26:38 <mathewm> fmap x (*2)
17:26:45 <Cale> which of course is composition in this case -- to look up a value in the result, you apply g to the index, then f to that
17:26:48 <mathewm> that is just crazy cool
17:26:50 <chessguy> hmm, nobody got my napoleon dynamite imitation
17:27:01 <glguy> mathewm: I think you have that backwards...
17:27:01 <Cale> haha
17:27:09 <mathewm> heh
17:27:13 <Cale> > fmap (+4) (*2) 10
17:27:14 <lambdabot>  24
17:27:22 <jesusphreak> hmm, the difference between data contructors and type constructors is a bit murky to me
17:27:33 <mq_mattr> ahh - now I get it
17:27:34 <jesusphreak> the tutorial I'm looking at doesn't cover them very well
17:27:38 <Cale> jesusphreak: data constructors build values
17:27:45 <Cale> type constructors build types
17:28:11 <Cale> data declarations define a type constructor on the left side of the =, and a bunch of data constructors on the right side
17:28:26 <mq_mattr> List a = Nil | Cons a (List a)
17:28:29 <Cale> you're allowed to have data constructors with the same name as type constructors, since they live in different worlds
17:28:30 <mq_mattr> List is type constructor
17:28:38 <mq_mattr> give it a type Int and you get a type List Int
17:28:48 <mq_mattr> Nil is a data constructor (with no args)
17:29:07 <mq_mattr> cons is a data constructor (give is a list and an 'a' and you get a List of 'a')
17:29:30 <Cale> another way to write that data declaration (in newer GHCs) is this:
17:29:35 <Cale> data List a where
17:29:42 <Cale>    Nil :: List a
17:29:48 <mq_mattr> GADTs right?
17:29:49 <Cale>    Cons :: a -> List a -> List a
17:30:00 <jesusphreak> okay, that does actually make some sense
17:30:09 <Cale> Well, this isn't really a GADT, but it's using the syntax which was introduced for them
17:30:20 <mq_mattr> right you are
17:30:22 <kyevan> Is there a Haskell that runs on (Free)DOS?
17:30:41 <mathewm> doubt it
17:30:42 <Cale> Maybe you could get hugs to run
17:30:44 <mq_mattr> is the gadt syntax preferred even for ADT defns now?
17:31:03 <Nafai> gadt == generic abstract data type?
17:31:08 <jcreigh> kyevan: why on earth do you need to run Haskell on DOS?
17:31:13 <Cale> mq_mattr: I actually prefer it, but it's not really widespread enough yet.
17:31:17 <mq_mattr> generalised algegraic data type
17:31:27 <mq_mattr> algebraic
17:31:32 <Nafai> mq_mattr: thanks
17:31:35 <Excedrin> kyevan: yes, there's a 16 bit Hugs
17:31:36 <Cale> If you only care that your programs run on recent GHCs, then it's great.
17:31:56 <LoganCapaldo> @where GADT
17:31:56 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/gadt.html
17:32:09 <kyevan> jcreigh: Bordem, mostly.
17:32:17 <kyevan> And, DOS is, well, DOS.
17:32:26 <kyevan> How can you not like DOS?
17:32:36 <mathewm> too bloated, DOS is
17:32:46 <mq_mattr> that's a loaded question
17:33:05 <kyevan> mathewm: Bullshit
17:33:11 <mathewm> :)
17:33:24 <kyevan> A stripped down DOS can be run from a floppy, for gods sake!
17:33:29 <mq_mattr> I never liked the look of the DOS boxes (I mean the cardboard boxes that they came in) - is that a good enough reason
17:33:31 <jcreigh> kyevan: Because Unix is the worse-is-better of OSes, and DOS is the worse-is-better of Unix.
17:33:37 <chessguy> hermm, is that GADT a monad?
17:33:50 <mq_mattr> chessguy: of course
17:33:58 <Excedrin> A stripped down $OS can be run from a floppy, for gods sake!
17:34:02 <kyevan> I've yet to see an even mostly-usable unix boot from a floppy.
17:34:11 <mq_mattr> for all X: is there an X Monad = Yes
17:34:12 <Cale> chessguy: it's not a GADT
17:34:18 <Cale> er, which one?
17:34:22 <Excedrin> not looking hard enough then
17:34:33 <mq_mattr> but I can't describe it for you
17:34:36 <Cale> oh, are you referring to Term?
17:34:55 <mq_mattr> kyevan: MINIX
17:35:07 <mq_mattr> MINIX 3 is actually quite nice
17:35:08 <chessguy> ues
17:35:10 <chessguy> Ter,
17:35:11 <Cale> The Term example GADT isn't a monad
17:35:12 <chessguy> Term
17:35:17 <Cale> you can't implement return
17:35:33 <fnord123> man o man, i miss compiling on mainframes. building ghc on my home machine is taking forever!
17:35:34 <mbishop> Oberon can boot from a floppy :)
17:35:48 <mq_mattr> fnord: dons can help you out
17:36:06 <mq_mattr> you just need a massive multi proc opteron machine
17:36:14 <Cale> fnord123: Wait, why are you compiling ghc?
17:36:30 <kyevan> mq_mattr: Boot floppys don't count
17:36:33 <mq_mattr> try compiling it on a 800Mhz g4
17:36:35 <mbishop> so he can complain about the speed compilation, DUH!
17:36:39 <fnord123> compiling 6.6... you don't expect me ot install a bin do you? :P
17:36:43 <Cale> yes I do
17:36:54 <mbishop> speed of*
17:36:57 <Cale> Don't compile GHC unless you're going to hack on it
17:37:28 <LoganCapaldo> but how am I supposed to -funroll-loops if I don't compile it myself?
17:37:37 <mbishop> heh
17:37:45 <kyevan> Cale: I know a few people who outright refuse to run anything they didn't complie themselves.
17:37:57 <sorear> It only took 90 mins on my system... I wanted to play with associated types.
17:38:07 <allbery_b> they must have real problems with self-bootstrapping systems
17:38:22 <Cale> yeah, that's an idiotic perspective which is probably contributing in a not insignificant way to global warming
17:38:22 <kyevan> One of them has written the starts of a book on hand-compileing C.
17:38:33 <mq_mattr> gentoo
17:38:41 <mq_mattr> I met a gentoo user once
17:38:54 <chessguy> kyevan, with pencil and paper? :)
17:38:55 <sorear> Do these ppl consent to use any of the closed CPUs?
17:38:57 <jcreigh> kyevan: does "hand-compiling" mean what I think it means?
17:38:58 <mq_mattr> he had to ssh into his box at home to get the compile started before he left work
17:39:14 <mq_mattr> otherwise it wouldn't be ready in time for him
17:39:23 <Cale> Sharing computation across machines, especially with expensive things like compilation, is a great idea, and it should be carried out as much as possible.
17:39:29 <Excedrin> sorear: yea, manually typing gcc -c file.c for each file on the system...
17:39:31 <sorear> distcc.
17:39:40 <Excedrin> Makefiles are bad!!
17:40:02 <wy> Is there a standard function for taking the first element out of a pair?
17:40:05 <sorear> fst
17:40:06 <mq_mattr> fst
17:40:11 <mq_mattr> just beat me
17:40:14 <kyevan> jcreigh: takeing a hardcopy of source and compileing to asm then machine code by hand?
17:40:17 <LoganCapaldo> @hoogle (a, b) -> a
17:40:17 <kyevan> Yes.
17:40:18 <lambdabot> Prelude.fst :: (a, b) -> a
17:40:18 <lambdabot> Prelude.uncurry :: (a -> b -> c) -> (a, b) -> c
17:40:18 <lambdabot> Prelude.snd :: (a, b) -> b
17:40:21 <fnord123> so bandwidth has exceeded computation for sources, then
17:40:31 <Cale> Gentoo has essentially evolved around what have to be considered design flaws in programs. If you could possibly want to change some option, then it shouldn't be a compile-time flag.
17:40:35 <mq_mattr> damn that lambda bot is a legend
17:40:40 <rc-1> good god you actually USE dos?
17:40:55 <kyevan> rc-1: It's safely inside qemu!
17:40:58 <rc-1> massicist?
17:40:59 <sorear> I've hand-assembled code before... for want of an assembler.
17:41:05 <rc-1> whats qemu
17:41:09 <sorear> it's spelled masochist
17:41:15 <mq_mattr> playing with oses is all kinds of fun
17:41:25 <sorear> qemu is one of the PC emulators
17:41:31 <LoganCapaldo> DOS isn't an operating system
17:41:36 <rc-1> point of language is communication and obviously you understood what i said :)
17:41:38 <mq_mattr> I spent far too much time last week getting haiku running on my mac
17:41:40 <mq_mattr> why?
17:41:44 <LoganCapaldo> Its a coulple of disk drivers and a very bad shell :)
17:41:45 <mq_mattr> I don't know ........
17:42:05 <mq_mattr> Logan: sounds like an OS to me
17:42:07 <rc-1> can dos even run multiple programs at once?
17:42:14 <allbery_b> qemu is a generic emulator, not just PC --- there are sparc, mips, etc. emulations supported
17:42:15 <LoganCapaldo> nope
17:42:19 <kyevan> rc-1: Theoreticly, yes.
17:42:21 <Excedrin> rc-1: no, it's single tasking
17:42:24 <LoganCapaldo> not by itself anyway
17:42:32 <kyevan> See windows 3.1
17:42:36 <sorear> the existance of the term 'multiprogramming' implies an alternative...
17:43:12 <mq_mattr> ahh - back to haskell - I was reading "making a fast curry" last week and I want to implement it
17:43:19 <sorear> The Palm can only run one program too
17:43:22 <allbery_b> arm, armeb, mips, mipsel, ppc, sparc, x86, x86_64
17:43:23 <mq_mattr> but I can't find example STG programs.
17:43:28 <mq_mattr> any pointers?
17:43:32 <Excedrin> using dos as a bootloader to load Linux doesn't mean that dos is a multitasking OS, s/Linux/Win3.1/ and the rest is still true
17:43:36 <sorear> ghc -fdump-stg ?
17:43:52 <mq_mattr> yeah - but that is full of cruft and really hard to decipher
17:44:06 <mq_mattr> plus it is a different StG to the one described in the paper
17:44:10 <kyevan> See also a couple of hacks with GEM
17:44:15 <rc-1> i thought windows 3.1 was ONLY gui for dos
17:44:19 <allbery_b> qemm386!
17:44:30 <mq_mattr> I thought SLPJ might have put some examples out there that I just hadn't found
17:44:53 <sorear> didn't the STG-machine paper have expository examples?
17:44:58 <allbery_b> actually that'd be desqview, qemm was the underlayer
17:45:07 <mq_mattr> sorear: just one or two
17:45:12 <allbery_b> and there was dv/x for a while, as far as DOS GUIs go
17:45:30 <mq_mattr> sorear: in fact, perhaps just one, I can't recall off the top of my head
17:45:55 <Excedrin> rc-1: no, win3.1 runs in 386 protected mode, with a flat address space, and it has a concept of processes that's seperate from dos processes...
17:46:22 <mq_mattr> the empirical results came from putting no-fib through a modified GHC
17:46:39 <sorear> The Palm has something just as good 95% of the time as true multiprogramming.  When you select a program, the current program is exited, and saves its state on the ram-disk.  So even though there is no multitasking at all, you don't have to write things down.
17:46:51 <mq_mattr> The STG described in the papter is simple enough to implement myself, but I guess they actually used something more complicated
17:47:01 <fnord123> according to the ghc website, ghc on os x is done through ports. The current ports version i have is 6.4.1. I don't see an upgrade available.
17:47:16 <allbery_b> macports, not darwinports
17:47:20 <mq_mattr> fnord123: go get the binary from ghc page
17:47:25 <Excedrin> the implementation of pipes in command.com on dos is kinda interesting...
17:47:29 <allbery_b> darwinports is moribund, apparently
17:47:41 <mq_mattr> I think the macports one is out of date since a binary is available there now.
17:47:52 <sorear> you might also want to look into GRIN - JohnMeacham__'s website has a link to Boquist's thesis, which is several hundred pages long and full of examples.
17:48:00 <fnord123> I thought darwinports was renamed macports
17:48:13 <mq_mattr> fnord123: yep
17:48:15 <sorear> (it's not STG-machine but it's relatively close)
17:48:28 <fnord123> http://www.haskell.org/ghc/download_ghc_66.html#macosxppc
17:48:28 <mq_mattr> sorear: thanks, your a champ
17:48:29 <lambdabot> Title: GHC: Download version 6.6
17:48:44 <allbery_b> huh
17:48:59 * allbery_b thinks there are several different stories floating around now
17:49:11 <fnord123> dar theres a link right below
17:49:17 <mq_mattr> allbery_b: of course
17:49:37 <allbery_b> (even here, last time I asked abotu it I was told to get it from macports instead of darwinports...)
17:50:25 * beelsebob giggles at the "I can't understand this simple monadic example" conversation that followed, and runs away giggling again
17:50:49 <mq_mattr> allbery_b: yep, darwinports changed its name to macports, it used to be the best way to get GHC (if you could woait for it to compile), but now the binary is available and it works for me, so don't bother with macports anymore
17:51:02 <mq_mattr> ghc takes a very long time to compiler on PPC hardware
17:51:08 <mathewm> darn fire drills
17:51:20 <beelsebob> IIRC the darwinports version doesn't work on intel anyway
17:51:21 * allbery_b wonders if he needs to changeanything to switch over, or if it was just frozen and is finally being updated again and will figure things out itself
17:51:31 <mq_mattr> not ghc's fault, just that ppc always trailed intel on integer stuff
17:51:34 <beelsebob> the binary seems to work fine for me
17:51:41 <mathewm> it took me days to build ghc on my G4 the first time - kept failing hours into the build
17:51:45 <mq_mattr> not much use for altivec when compiling
17:51:56 <mq_mattr> mathewm: I feel your pain
17:51:58 <beelsebob> mq_mattr: no, ppc was very fast on integer - it was branching it was slow on
17:52:07 <mathewm> I have darwinports ghc working just fine
17:52:08 <mathewm> now
17:52:11 <mq_mattr> ibeelsebob: I stand corrected
17:52:27 <fnord123> mq_mattr: do you know how to invoke a macports upgrade? i know apt-get uses upgrade or update; but i dont see how to do it using macports :-/
17:52:33 <beelsebob> it's maths units were in general fucking briliant
17:52:42 <beelsebob> it juts sucked for non-maths
17:52:44 <mq_mattr> fnord123: selfupdate?
17:52:53 <allbery_b> port selfupdate; port upgrade -a
17:52:56 <allbery_b> or something similar
17:52:59 <mathewm> man port is great
17:53:15 <fnord123> man port doesn't exist
17:53:25 <fnord123> unless you mean "man, port sure is great"
17:53:28 <mathewm> sure does
17:53:31 <mathewm> 'man port'
17:53:32 <mq_mattr> beelsebob: I love my mac, but it was very humbling to see it thrashed in a large compilation task by a very old sub 1Ghz PIII one day
17:53:54 <beelsebob> mq_mattr: yes, quite true
17:53:57 <allbery_b> er, port upgrade outdated -Ru
17:54:10 <beelsebob> interestingly though... my iBook G4 1.33 still thrashed a 3.6Ghz P4 at encoding music
17:54:34 <mq_mattr> beelsebob: indeed, but I compile all day, and rip once in a blue moon :(
17:54:35 <beelsebob> although... my MacBook seems to completely pwn
17:54:36 <allbery_b> hrmph.  it knows it's MacPorts now, but still doesn't seem to be updated
17:54:44 <beelsebob> indeed
17:54:44 <Excedrin> which encoder?
17:54:54 <beelsebob> Excedrin: quicktime
17:55:04 <beelsebob> iBook maintained the CD drives read speed
17:55:13 <beelsebob> P4 couldn't keep up
17:55:14 <mathewm> trying to update ghc?
17:55:16 <fnord123> no portoutdate found
17:56:26 <allbery_b> hm?
17:57:13 <mq_mattr> allbery_b: wish I could help you out, but I have not needed macport/darwin port for a while.
17:57:37 <mq_mattr> although last time I used it, I had problems because it wanted me to upgrade to the latest version of xcode
17:58:06 <mathewm> just download the newest pkg, if it has been a while
17:58:28 <mathewm> I installed darwin/mac ports recently on a new intel mbp and installed ghc
17:59:24 <jlouis> ?hoogle (a -> b) -> Either a c -> Either b c
17:59:25 <lambdabot> No matches, try a more general search
17:59:57 <allbery_b> mrph.
18:00:33 <jlouis> I could of course build it on Data.Either.either
18:00:58 <allbery_b> first it says no updates.  then port outdated shows a small list of outdated ports.  then I port update outdated and it starts upgrading ports not listed as outdated.
18:01:15 <mathewm> port sync?
18:01:23 * allbery_b would really prefer they'd stayed with freebsd ports, it at least was self-consistent
18:02:05 <allbery_b> suspiciously fast and quiet
18:02:14 <fnord123> oh its working. and it wants to start fresh building ghc. ;)
18:03:21 <mathewm> either (Left . length) (Right . id)
18:04:58 <mathewm> ?pl \f -> either (Left . f) (Right . id)
18:04:59 <lambdabot> flip either Right . (Left .)
18:05:08 <mq_mattr> macfolk: what are you using for IRC?
18:05:24 <mathewm> ircle, usually
18:05:24 <beelsebob> Colloquy
18:05:26 <mathewm> $$
18:06:01 <kyevan> Yahknow
18:06:13 <kyevan> There's a reason one of the ctcp messages is VERSION
18:06:13 <mq_mattr> cheers
18:07:27 <kyevan> Hmm... Should I /ctcp #haskell version? I mean, no one but me would take much of a hit... Hmmm
18:07:28 <dons> man ometimes the cognitive dissonance from random reddit commenters is shocking
18:07:39 <kyevan> What is reddit, anyway?
18:08:05 <dons> http://programming.reddit.com/
18:08:06 <lambdabot> Title: reddit.com: programming - what&#39;s new online
18:08:26 <mathewm> that is a use of the word "new" that I am not familiar with ;)
18:09:12 <mq_mattr> dons: are you referring to to "pay for what you use"?
18:09:40 <dons> mq_mattr: nah, grauenwolf being consistently baffled by function composition and side effects
18:09:58 <mq_mattr> dons: OK, you lost me
18:10:00 <dons> kyevan: reddit is a poor alternative for http://sequence.complete.org/    ;)
18:10:02 <lambdabot> Title: The Haskell Sequence | News about Haskell
18:10:10 <fnord123> he must be some kind of mad genius. he implemented erlang in vba
18:10:32 <mathewm> erlang isn't that hard to impl, I suspect
18:10:44 <dons> mq_mattr: oh sorry. a contributor to the reddit language page, who consistently makes bizarre or misleading statements about language he doesn't understand :)
18:11:19 <fnord123> er, actually it was a shmem system with locking and everything. he was sayign it was great and erlang is a waste of time since you can do the same thing in vba
18:11:47 <mathewm> ouch
18:11:50 <mq_mattr> dons: aha!  Is reddit worth keeping an eye on anyway?
18:12:03 <dons> mq_mattr: the programming subreddit is a useful source of haskell news
18:12:09 <dons> and erlang and lisp news
18:12:23 <sdjp> And factor, for some bizarre reason.
18:12:32 <dons> sdjp: because the factor author promotes it there
18:12:39 <mq_mattr> So far, my daily reading is ltu, plnews, planet haskell, haskell sequence
18:12:57 <dons> mq_mattr: yeah, most interesting things from reddit make it into the weekly haskell news
18:13:14 <dons> and the haskell headlines from reddit are syndicated to haskell sequence anyway
18:13:32 <Nafai> mq_mattr: plnews?
18:14:07 <mq_mattr> http://plnews.org
18:14:09 <lambdabot> Title: PLNews: Programming Language News
18:14:20 <mq_mattr> thankyou lamby
18:14:27 <mq_mattr> lambo
18:14:34 <mq_mattr> ???
18:14:36 <LoganCapaldo> @where plnews
18:14:37 <lambdabot> I know nothing about plnews.
18:14:40 <LoganCapaldo> darn
18:14:45 <mq_mattr> lambdabot needs a ncikname
18:15:16 <allbery_b> plnews.org
18:16:12 <mq_mattr> plnews is lots of *less interesting* stuff. but it doesn't take long to skim the rss and I like to think I am not missing *everything* happening outside the functional programming world
18:17:23 <mattr2> ah, I have command line irc working now
18:17:39 <fnord123> oh that's where plnews.org went. I had the bookmark linking to something like "plnews.tacofan.com" or something
18:18:04 <fnord123> tacojuice
18:19:42 <erider> araujo: ping
18:22:01 <kyevan> hmmm
18:22:40 <kyevan> Have there been any attempts at getting Haskell to compile to .NET/Mono binaries?
18:22:57 <sorear> yes
18:23:05 <Excedrin> yes, there's H#
18:23:11 <Excedrin> http://php.cin.ufpe.br/~haskell/haskelldotnet/hsharp.php?m=home
18:23:14 <lambdabot> Title: H#: The Haskell.net Project
18:23:23 <Excedrin> also, Hugs98 for .net
18:24:29 <jlouis> Debugging pesky STM thread problems is not fun ;)
18:24:39 <jlouis> or maybe it is ;)
18:28:43 <Lemmih> jlouis: You have STM problems?
18:29:12 <jlouis> Lemmih, not anymore.
18:29:19 <Lemmih> jlouis: Hacking conjure?
18:29:24 <jlouis> yeah
18:29:30 <Lemmih> Neat, so am I (:
18:29:50 <sieni> hmm... does `darcs push' work without darcs in the receiving end?
18:29:51 <jlouis> kewl
18:30:20 <Lemmih> sieni: I don't think so.
18:30:37 <Excedrin> sieni: no
18:30:41 <sieni> damn
18:30:52 <sieni> argh
18:31:21 <sorear> it *should*...
18:31:40 <sorear> darcs push uses a dumb server (filesystem or scp(?))
18:31:59 <sorear> darcs send needs a recieving darcs
18:32:09 <kyevan> Greh. Stupid stupid... why doesn't this work!?
18:32:11 <mwc> sorear, it does?!
18:32:24 <kyevan> sorear: Send also requires human intervention on the other end
18:32:41 <mwc> I thought it needed sshd running on the either side and could call up a darcs to talk to that way
18:32:42 <sorear> I haven't tried it, but the documentation says it should work
18:33:13 <sieni> sorear: Any version limitations?
18:33:27 <sorear> I think it uses a child darcs iff it cannot directly access the repository.
18:33:30 <mq_mattr> sorry bout all that
18:34:28 <mwc> just found the cromulent section of the darcs manual
18:34:28 <mwc> In order to apply with ssh, darcs must also be installed on the remote computer. The command invoked to run ssh may be configured by the DARCS_SSH environment variable (see subsection [*]). The command invoked via ssh is always darcs, i.e. the darcs executable must be in the default path on the remote machine.
18:35:20 <mwc> certainly seems more lightweight than svn (apache + webdav)
18:36:19 <mq_mattr> darcs people: are we convinced of the "theory of patches"?
18:36:22 <mq_mattr> I do love darcs
18:36:32 <mq_mattr> I use it exclusively
18:36:51 <mq_mattr> but looking deeper into the theory of patches, I was really not convinced
18:37:08 <mq_mattr> of course, I could just have missed the point
18:37:14 <mq_mattr> it happens :)
18:37:21 <dons> mq_mattr: there's a new paper by kosmikus and swiert which clarifies and simplifies things a lot
18:37:25 <beelsebob> I did see a paper recently actually that describes a different theory of patches
18:37:33 <kyevan> I'm convinced it hasn't lost anything for me, yet :P
18:37:36 <mq_mattr> sweet, thanks
18:37:38 <beelsebob> that they claimed encompased darcs, svn and cvs
18:37:55 <dons> mq_mattr: this one, http://programming.reddit.com/goto?id=nvvt
18:37:58 <lambdabot> Title: A Principled Approach to Version Control
18:38:05 <sorear> I use darcs as a Better RCS, and don't care much for patch theory... It's just an implementation detail.
18:38:13 <beelsebob> indeed
18:38:14 <mwc> darcs finally convinced me to start using RCS... now I use it for everything
18:38:24 <beelsebob> I know a lot of people that the "theory of patches" puts off actually
18:38:40 <beelsebob> they see that on the front page and go "argh, that looks complicated, I'm not gonna try it"
18:38:44 <kyevan> Of course, I've never had major conflicting edits, or anything.
18:38:49 <sorear> oh, I was using RCS as in the software suite containing the ci(1) and co(1) binaries.
18:38:53 <dons> beelsebob: are interesting!
18:39:10 <beelsebob> dons: hnuh?
18:39:11 <mq_mattr> beelsebob: my problem is that the mathematician in my world think it is wrong and that puts them off
18:39:19 <beelsebob> hehe
18:39:20 <dons> beelsebob: I think they've reworded the front page recently to remove the 'quantum physics' bits anyway
18:39:22 <mq_mattr> this new paper could alleviate that
18:39:43 <dons> and replace 'theory' with 'darcs is smart' :)
18:39:48 <kyevan> I've only worked on small repos with a few people max, and everyone has a tendancy to pull patches before edits there :P
18:39:49 <mq_mattr> darcs has made rcs easy enough for me to use every day
18:39:50 <dons> (always a good idea ;)
18:40:04 <mwc> the QM allusions kind of bothered me since I know how arbitrary the foundations are
18:40:11 <dons> mq_mattr: mmm, yes. I agree. my home dir is in rcs now -- thanks to darcs
18:40:28 <mwc> dons, wow
18:40:32 <mq_mattr> is homedir as rcs a substitute for incremental backups
18:40:32 <mwc> That's drastivc
18:40:33 <mq_mattr> ?
18:40:33 <beelsebob> dons: personally, I think that it should be worded "darcs is a version control system, it's better than svn and cvs because <insert simple reasons that every day problems become easier>, old repositories can be moved easily, so try it"
18:40:34 <Excedrin> my /etc is managed by darcs
18:40:41 <beelsebob> (or something to that effect)
18:41:03 <kyevan> I have too many binary files in my home for that to be practical
18:41:15 <beelsebob> mq_mattr: personally I just put my home dir into time machine
18:41:29 <mq_mattr> dons: thanks for the cabal projects wiki page - *you* made cabal easy enough for me to use on every project :)
18:41:34 <kyevan> Lots of images, not to mention an entire drive shared by windows for such things as my scheme cache:P
18:41:45 <sorear> Backups are still very important.  A head crask will *not* spare /home/mq_mattr/_darcs/
18:41:54 <kyevan> s/scheme/Steam
18:42:20 <mq_mattr> beelsebob: I use chronosync and superduper, but I have always thought rcs could be a more principaled incremental backup
18:42:35 <araujo> erider, pong
18:42:53 <mq_mattr> sorear: I was imagining putting everything in rcs and then having a daily mirror (off site)
18:42:57 <erider> araujo: how are things
18:43:00 <kyevan> Well, theoreticly you could just push patches since last backup to a disk or somesuch
18:43:07 <araujo> erider, sort of good ...
18:43:14 <araujo> yourself?
18:43:22 <erider> looking up
18:43:26 <kyevan> I just don't do backups :P
18:43:29 <mq_mattr> colloquy is tops btw
18:43:33 <kyevan> I don't have anything /that/ important
18:43:58 <beelsebob> mq_mattr: yes, yes it is... although it irritates me only having 300 lines of scroll back
18:44:00 <erider> araujo: no issue where you are
18:44:16 <kyevan> mq_mattr: Meh, I like irssi better
18:44:19 <araujo> erider, hah , no, everything was _ok_ at the end .....
18:44:27 <mq_mattr> beelsebob: but the archive for the channel is always up to date
18:44:32 <kyevan> of course, that's a pain on the mac
18:44:41 <mq_mattr> kveyan: I was using Opera before !?!?!
18:44:45 <erider> cool!
18:45:08 <beelsebob> mq_mattr: true, but that's not true of other channels I inhabbit
18:45:15 <mq_mattr> ah
18:45:23 <beelsebob> kyevan: Colloquy *is* irssi with a nice front end
18:45:47 <beelsebob> only reason I prefer irssi is I can run it in screen, but then running irssi in proxy mode in screen solves that one
18:47:17 * beelsebob tries to sleep again
18:47:18 <beelsebob> nini all
18:47:48 <araujo> beelsebob, monads rulez
18:47:53 * araujo hides
18:49:47 <kyevan> beelsebob: Meh, the "nice: front end isn't so nice, imo
18:50:08 <kyevan> I'm just a crochety old man, I guess. At 16. Oh well.
18:50:30 <kyevan> :P
18:52:31 <mq_mattr> :P
18:52:34 <mq_mattr> :D
18:53:46 <kyevan> I should set wget on a mirror of the ifarchive infocom-format dir
18:54:07 <kyevan> Since that's what the interpreter on my palm handles
18:54:18 <mq_mattr> beelsebob: the 300 line scrollback limit can be changed in preferences
18:54:33 <kyevan> And, why ame I in the haskell tab? I ment to be in sw#lobby, not fn#haskell!
18:54:50 <dons> mq_mattr: homedir-in-darcs is a subsitute for incremental bacups, yep. since my script just does 'darcs push' once a night to my backup server :)
18:55:03 <dons> (with the benefit that i can revert anything i do in my homedir)
18:55:11 <mq_mattr> dons: see, that is cool
18:55:15 <dons> its like living in a big undoable world
18:55:36 <sorear> :t liftM2 id
18:55:38 <lambdabot> forall a2 r (m :: * -> *). (Monad m) => m (a2 -> r) -> m a2 -> m r
18:56:06 <sorear> (x -> a -> b -> c) -> (x -> a)
18:56:30 <dons> mq_mattr: ah, about cabal, you mean using the 'how to write a haskell project' page?
18:56:34 <dons> or something else?
18:56:43 <dons> i'm looking for more feedback on improving things, and make it simpler
18:56:47 <mq_mattr> dons: that's the one
18:56:53 <sorear> I use textfields as scratch space ... then I reach for C-k and a finger I forgot I had bumps into the Enter key.
18:57:14 <sorear> (that's where the tysig came from)
18:57:30 <allbery_b> heh
18:58:01 <dons> SamB: markup for < arrows is famously broken in reddit, btw.
18:59:03 <dons> ?users
18:59:03 <lambdabot> Maximum users seen in #haskell: 278, currently: 257 (92.4%), active: 34 (13.2%)
19:00:21 * kyevan digs through his bookshelf
19:00:53 <kyevan> A couple OLD java books, frontpage stuff I never used... a guide to a game I don't have, my old webelos book...
19:01:05 <kyevan> Plenty of stuff to frop on people :)
19:02:22 <sorear> Probably the "best" book I have is "Programming Languages: Design and Implementation"
19:02:36 <sorear> Copyright 1975 Terrence W. Pratt
19:02:45 <kyevan> Best to read, or best to put in a trebuchet?
19:03:11 <sorear> Chapter 18: [case study] SNOBOL
19:04:03 <dons> kyevan: hehe
19:04:45 <sorear> I've learned a lot from that book - but the subject was "history", not "computer science"
19:11:10 <mq_mattr> dons:  sorry 'bout the delay, but I don't have any suggestions at the moment, I really liked it.  I might have another look at it when I get some free time and see if anything springs to mind.
19:12:15 <dons> cheers
19:12:31 <dons> it seems like cabal was just missing a good tutorial on getting started
19:13:38 <fnord123> yay HXT is installed
19:14:15 <dons> cool
19:14:18 <dons> fnord123: did you talk to Cale?
19:14:20 <kyevan> Someone should prot cabal to COBOL *ducks incomeing tomatos*
19:14:21 <sorear> *thud* *thud* *thud*
19:14:24 <dons> apparently he coded up some kind of solution?
19:14:32 <fnord123> yeah he showed it to me.
19:14:40 <fnord123> i had some problem with my http module install
19:14:44 <sorear> I just spent several minutes trying to debug a Parsec-based REPL.
19:15:00 <sorear> No matter what I typed, I got a wierd parse error.
19:15:15 <dons> nornagon: re. about usyd, there might be some credit program for good programmers, yes.
19:15:33 <dons> sorear: example code please ? :)
19:15:33 <sorear> Turned out there was an exception, and I was typing my perfectly valid expressionions into the GHCi repl.
19:15:34 <dons> ?paste
19:15:34 <lambdabot> http://paste.lisp.org/new/haskell
19:15:37 <dons> or did you sort it out
19:15:38 <dons> ah!
19:15:42 <dons> hehe
19:16:31 <dufflebunk> I'm trying to compile lhs2TeX and it complains: 'ghc-6.6: unknown package: lang'  I don't really know much about the module system yet... is there an easy way to fix the problem?
19:17:25 <dons> dufflebunk: sounds like you've an old version of the lhs2TeX source?
19:17:30 <dons> I think its been updated for 6.6
19:17:35 <dons> ?where lhs2tex
19:17:35 <lambdabot> http://www.cs.uu.nl/~andres/lhs2tex
19:17:40 <dufflebunk> 1.11, latest on the site...
19:17:43 <dons> perhaps check the darcs repo?
19:17:45 <dufflebunk> Oh, that's a different site
19:17:46 <dons> (if there is one)
19:17:59 <dons> hmm, not sure that's even the right site...
19:18:08 <dufflebunk> same site, different url
19:18:56 <dons> try removing 'lang' from the build system (does it use cabal?)
19:19:14 <nornagon> dons: i've looked at a few comp sci courses before and thought, 'hm, the 3rd year stuff looks interesting...'
19:19:26 <dons> nornagon: agreed :)
19:19:32 <dons> maybe you want to do a masters instead?
19:19:47 <dons> dufflebunk: here's the release announcement, fwiw, http://article.gmane.org/gmane.comp.lang.haskell.general/13414
19:19:49 <lambdabot> Title: Gmane -- Mail To News And Back Again
19:20:02 <dufflebunk> dons: the command line has -package lang, it does work if I take that out, thanks
19:20:17 <dons> great
19:20:42 <nornagon> dons: but can i do that without having to slog through all the boring stuff?
19:23:00 <dons> nornagon: do you have a degree already?
19:23:48 <dons> i'm pretty sure there's flexibility, but i'm not familiar with the precise details. best to email the school office (or relevant academic in the area you want to study)
19:24:55 <dons> ah I forgot our previous conversation about usyd :)
19:25:28 <dons> first year at cse isn't boring though, I found. it was very hard. there's an advanced stream too
19:25:30 <jcreigh> @paste
19:25:30 <lambdabot> http://paste.lisp.org/new/haskell
19:26:04 * dons remembers fondly the first assignment: haskell battle bots fighting in a grid world
19:26:20 <dons> your code had to fight agains the other student's haskell bots, for assignment points
19:26:50 <lisppaste2> jcreigh pasted "Simple instance of Monad for Tree" at http://paste.lisp.org/display/31839
19:28:11 <nornagon> dons: no, high school :)
19:28:18 <nornagon> haven't finished my HSC yet.
19:28:30 <jcreigh> Is that a proper instance of Monad?
19:28:46 <dons> nornagon: yes, I remember :)
19:28:59 <nornagon> right
19:29:09 <nornagon> so yeah, that usyd thing is looking very attractive
19:29:11 <dons> nornagon: I reommend going through the normal first year process though -- you'll just get accelerated if you're good
19:29:24 <dons> there's lots of good students usually (hence there are advanced streams and so on)
19:29:32 <nornagon> i see
19:30:01 <dons> i still don't get the usyd thing. no haskell, no os kernel hackers, ...
19:30:30 <dons> you could go to maquaried and have mq_mattr teach you haskell :)
19:30:33 <dons> s/d//
19:30:58 <setuid_w00t> I'm looking for something to add to my Christmas list.  Can anyone suggest a good Haskell book for someone who knows how to program, but has limited exposure to functional programming?
19:31:38 <thermoplyae> YAHT is what I'm reading; it's alright
19:31:48 <thermoplyae> http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf
19:31:59 <dons> setuid_w00t: in textbooks, 'Craf of FP' is good, or for more theory 'Types and Programming Languages'
19:32:03 <Cale> (but it doesn't cost money :)
19:32:03 <setuid_w00t> thermoplyae: I started reading that while I was bored at work last week
19:32:13 <dons> setuid_w00t: the full list is on haskell.org's 'books and tutorials page'
19:32:13 <mq_mattr> nornagon: maquarie is not a bad option for haskellers
19:32:22 <nornagon> i'm not really a haskeller :)
19:32:27 <dons> Cale: we need a 'christmas list' ... this question keeps coming up!
19:32:34 <nornagon> and mq is way too far away
19:32:38 <kfish> nornagon, yet :-) g'morning
19:32:45 <nornagon> sup kfish :)
19:32:47 <mq_mattr> nornagon: oh well :)
19:33:04 <dons> kfish: he still wants to go to usyd! what can we do about this.
19:33:10 <Cale> Yeah, I'd like to know too ;) I was a bit more impressed by the material available online than in the library.
19:33:16 <mq_mattr> dons: I am still trying to wrangle a job teaching haskell :)
19:33:26 <nornagon> dons: you could pay for a flat for me near unsw ;)
19:33:35 <sorear> maybe we should just bind a book out of tunes.org/~nef/logs/haskell :)
19:33:41 <dons> mq_mattr: ah cool. :)
19:33:52 <mq_mattr> mq_mattr: we may have a unit on critical systems that could be taught in Haskell (or even Coq :))
19:34:19 <dons> mq_mattr: oh that's interesting. our theorem proving/high assurance course is in haskell / Isabelle
19:34:32 <kyevan> sorear: Actually, that would be kinda neat.
19:34:45 <mq_mattr> dons: if the unit goes ahead I will check yours out first then
19:34:47 <fnord123> Hey Cale, question about your HXT sample you posted... did you need to slap anything special for as a link argument?
19:34:48 <mq_mattr> :)
19:34:50 <kyevan> I'd rather have a hardcopy of the Linux source, though.
19:34:51 <kfish> dons: how about a haskell breakaway hackfest during the week of linux.conf.au? you could even introduce people like nornagon to pls ;-)
19:35:09 <dons> kfish: hmm! when's l.c.au?
19:35:13 <kyevan> (I wouldn't know how to read it, but it would look impresive!)
19:35:27 <nornagon> dons: !
19:35:33 <nornagon> lca2007.linux.org.au
19:35:38 <nornagon> register!
19:35:51 <sorear> kyevan: at a bookstore in my neighborhood I saw that.
19:35:52 <dons> kfish: I've been pondering AuHaskell (after the EuroHaskell went well a couple of years back)
19:35:52 <kfish> dons: jan 15-20
19:35:58 <setuid_w00t> dons: I have seen that list, but it doesn't say anything about the quality of each book.
19:36:02 <kyevan> Hmm. When my  schools compsci class switches to Java later this year, I'm going to be in for a world of pain, aren't I?
19:36:04 <dons> ah , right. when everyone's at POPL...
19:36:07 <kfish> dons: and it's about a lot of generaly free software stuff, not just linux
19:36:09 <dons> me included.
19:36:17 <Cale> fnord123: it works seamlessly
19:36:17 <dons> kfish: yeah I know. :)
19:36:26 <sorear> It was a *big* book: "The Annotated Linux TCP/IP Stack"
19:36:30 <mq_mattr> kyevan: I can show you how to pass functions in Java :)
19:36:50 <lisppaste2> fnord123 annotated #31821 with "link errors" at http://paste.lisp.org/display/31821#1
19:36:53 <mq_mattr> dons: are you off to popl?
19:37:02 <nornagon> popl?
19:37:08 <dons> mq_mattr: yeah, and PADL, just after the hackathon we're running in oxford
19:37:11 <sorear> ?pl \i n -> n !! fromEnum i
19:37:11 <lambdabot> flip (!!) . fromEnum
19:37:19 <dons> (the stream fusion paper is to be presented at PADL)
19:37:20 <Cale> fnord123: compile with --make
19:37:36 <mq_mattr> dons: that's right, I saw the hackaton.  i am intensely jealous
19:37:41 <kfish> dons: the monday and tuesday (jan 15,16) would be a good time for hacking haskell -- thats when the lca miniconfs are on
19:37:52 <fnord123> shazam! ["41"]
19:37:58 <dons> kfish: I won't be in the country though!
19:38:07 <mq_mattr> I do like the idea of a haskel breakout session though
19:38:14 <mq_mattr> I will be around....
19:38:21 <kfish> dons: ah, damn
19:38:24 <dons> mq_mattr: yeah, there should be quite a few. ozone too I imagine
19:38:25 <mq_mattr> i am no dons, but ...
19:38:33 <dons> and patrykz too, kfish?
19:39:08 <kfish> dons, sure, he's got a talk at lca: http://lca2007.linux.org.au/talk/215
19:39:09 <lambdabot> Title: Computers, Programs and Logic: What Does Linux Prove? - linux.conf.au 2007
19:39:42 <dons> right, so there's a good core there to do a haskell session
19:40:13 <kyevan> I wonder
19:40:32 <kyevan> How much of what I know about computers has been self-taught, and how much came from teachers?
19:40:33 <sorear> ?pl \a b -> a >>= \x -> b >> return x
19:40:33 <mq_mattr> "Computers, Programs and Logic: What Does Linux Prove?" - damn, I think I have underestimates linuxconf
19:40:34 <lambdabot> (. ((. return) . (>>))) . (>>=)
19:42:34 <dons> mq_mattr: the disy/ertos kernel hackers have long had a presence at linuxconf, and I guess now that they doing a lot of theorem proving+kernel work, they're going to spread the love around a bit :)
19:42:35 <jcreigh> how is sequence defined? I'm trying to figure out what sequence [tree, tree] does. (given the definition of tree that I pasted)
19:42:56 <dons> ?source Control.Monad
19:42:57 <lambdabot> http://darcs.haskell.org/packages/base/Control/Monad.hs
19:42:58 <dons> use the source!
19:43:13 <LoganCapaldo> I thought sequence was like folding (>>=)
19:43:53 <dons> sequence ms = foldr k (return []) ms
19:43:54 <dons>         where
19:43:54 <dons>           k m m' = do { x <- m; xs <- m'; return (x:xs) }
19:44:47 <dons> ?undo do { x <- m; xs <- m'; return (x:xs) }
19:44:48 <lambdabot> m >>= \ x -> m' >>= \ xs -> return (x : xs)
19:44:53 <dons> ?pl m >>= \ x -> m' >>= \ xs -> return (x : xs)
19:44:54 <lambdabot> (`fmap` m') . (:) =<< m
19:45:01 <dons> mmm
19:45:11 <LoganCapaldo> so more like mapping then folding eh
19:45:30 <jcreigh> Sometimes I resent that fact that lambdabot seems to be smarter than me. :)
19:45:43 <augustss> liftM2 (:)
19:45:59 <dons> :t Control.Monad.liftM2 (:)
19:46:00 <lambdabot> forall a1 (m :: * -> *). (Monad m) => m a1 -> m [a1] -> m [a1]
19:46:21 <dons> :t \m m' -> (`fmap` m') . (:) =<< m
19:46:23 <lambdabot> forall (f :: * -> *) a. (Monad f, Functor f) => f a -> f [a] -> f [a]
19:46:46 <dons> I really should look at improving the rewrite rule engine in @pl
19:46:53 <augustss> sequence = foldr (liftM2 (:)) (return [])
19:46:55 <dons> we lean on it a lot these days, and it could do better
19:47:28 <augustss> or maybe sequnce does the effect the other way :)
19:47:28 <LoganCapaldo> dons: I'd rather djinn get more psychic :)
19:47:35 <dons> unless augustss wants to hack up a proper @pl .... as a child of Djinn
19:47:44 <fincher> can someone explain what first-class polymorphism is?
19:47:46 <sorear> :t traverse
19:47:46 <mathewm> +1 vote for a more capable djinn
19:47:47 <lambdabot> Not in scope: `traverse'
19:47:55 <sorear> :t Control.Applicative.traverse
19:47:56 <lambdabot> Couldn't find qualified module.
19:48:00 <augustss> I started FP with @pl, kinda
19:48:08 <augustss> combinator abstraction
19:48:35 <mathewm> pl is really cool I am about to go look at its impl
19:48:51 <sorear> if you want the basics, google unlambda
19:48:56 <augustss> mathewm: djinn is right on the border of what's decidable.  you can make a smarter one, but it won't necessarily be complete
19:49:15 <sorear> section 3 IIRC in the tutorial is how to turn lambda calculus into SKI calculus.
19:49:25 <mathewm> incomplete and occasionally useful is fine with me
19:49:30 <sorear> warning: unlambda is impure
19:49:46 <augustss> unclean!  unclean!
19:49:53 <mathewm> impure would make it harder, wouldnt it?
19:50:17 <sorear> the ?pl-alike ignores side effects, and is *very* simple
19:50:55 <sorear> \x -> y ==> K y   \x -> (a c) ==> S (\x -> a) (\x -> c)    \x -> x ==> I
19:51:03 <sorear> those are all the rules you need
19:51:15 <Dr_Pi> I would like to install to haddock in Tiger (Mac OS X 10.4), but I can't find the install file in the source. I don't know what I'm doing wrong.
19:51:16 <augustss> dons: how are the rewrite rules for @pl specified?  Haskell code?
19:51:26 <sorear> I ==> S K K  is useful sometimes.
19:51:29 <dons> yeah, there's a list of rule pairs, if I recall
19:51:45 <dons> the problem is that Thomas Jaeger wrote the whole thing, then left to do a math degree
19:51:53 <augustss> heh
19:51:55 <dons>  so no one really understands the code well enough :)
19:52:01 <dons> but its not too hard to extend (I think)
19:52:54 <dons> there rules are here, http://www.cse.unsw.edu.au/~dons/code/lambdabot/Plugin/Pl/Rules.hs
19:52:55 <lambdabot> http://tinyurl.com/ynezgg
19:53:08 <dons> one limitation is that Thomas didn't know about Language.Haskell, so he wrote his own HsSyn parser
19:53:20 <dons> that should be ripped out.
19:53:55 <augustss> Ah, I see
19:54:06 <dons> I think there's a decent paper in a good implementation of this thing
19:54:18 <augustss> Does Language.Haskell do proper fixity processing these days?
19:54:21 <jcreigh> hmm, are those C pre-processor directives I see in Monad.hs?
19:54:22 <dons> nope
19:54:44 <dons> jcreigh: #ifdef __GLASGOW_HASKELL__   --- yes
19:54:45 <LoganCapaldo> @pl f a b
19:54:45 <lambdabot> f a b
19:54:50 <LoganCapaldo> Hey!
19:54:53 <SamB_XP> augustss: it never will!
19:54:54 <SamB_XP> it can't!
19:55:04 <LoganCapaldo> that code has points! ;)
19:55:08 <SamB_XP> it doesn't have access to fixity information -- that is in other modules!
19:55:13 <augustss> well, it would need to do the imports
19:55:33 <dons> @pl \f a b -> f a b
19:55:33 <lambdabot> id
19:55:57 <augustss> SamB_XP: I'd like to have that as an option
19:56:40 <SamB_XP> augustss: maybe if you passed it a module resolver
19:57:00 <mathewm> now, why isn't unlambda used more commonly in the industry?
19:57:02 <LoganCapaldo> @pl \x -> 1 --- const 1
19:57:03 <lambdabot> const 1
19:57:05 <augustss> Sure, you'd need some way for it to find other modules
19:57:13 <SamB_XP> mathewm: because nobody can read it
19:57:15 <dons> mathewm: I did see a job the other day that asked for unlambda programmers
19:57:24 <SamB_XP> dons: oh really!
19:57:26 <mathewm> dons: no!
19:57:37 <mathewm> job security...
19:57:40 <SamB_XP> someone must have done something truly awfull to preserve his/her job security!
19:57:45 <bd_> mathewm: People shy away from weakly typed languages I guess
19:57:53 <dons> let me find that ...
19:57:58 <SamB_XP> it cannot be that the actual program was written in unlambda
19:58:02 <SamB_XP> it must have been object code
19:59:25 <dons> i think it was a joke...
19:59:27 <dons> http://seeker.dice.com/jobsearch/servlet/JobSearch?op=101&dockey=xml/5/e/5e36b457ce16106c02ced0981fb6878f@endecaindex&source=18
19:59:30 <lambdabot> Title: Find Software Developer jobs at Dice.com, http://tinyurl.com/cza2x
19:59:36 <dons> (note the tiny-url doesn't work for some reason)
20:00:49 <mathewm> joke, or they just copied a list of "functional programming languages" into the add
20:03:03 <jcreigh> kinda sad in the latter case
20:04:16 <dons> Cale: around?
20:04:27 <Cale> yeah
20:04:47 <dons> do we have a ready made LogT (logging to file) monad?
20:05:23 <dons> ideally  I'd like something that traced steps magically, so    f x would print some kind of "f x" string into a [String] state, but that'd need TH
20:05:49 <dons> Cale: oh, btw, we can work around with reddit < bug with unicode!
20:05:59 <dons> i.e. http://programming.reddit.com/info/u2pb/comments/cu760
20:06:01 <lambdabot> Title: Commercial Users of Functional Programming (reddit.com)
20:06:10 <Cale> haha
20:06:21 <dons> i don't know which char it is though..
20:06:26 <dons> (otherwise I'd write a preprocessor)
20:07:10 <Cale> looks like U+227A
20:12:00 <nornagon> kfish: food for thought, i taught myself pretty much everything I know
20:12:16 <nornagon> with bits of help here and there from IRC on language-specific things
20:12:46 <nornagon> but all my programming theory, etc, i learned from books (in e- form or otherwise :))
20:14:27 <sorear> I just love learning.  I've been doing it just about continuously since I was 3.  My knowledge roughly tripled a year ago when I discovered Wikipedia.
20:16:05 <augustss> sorear: you must have managed to cram wikipedia into your brain :)
20:16:10 <dons> mmm, seems to be a bit of a spike in darcs dev the last few weeks.
20:16:12 <dons> very good.
20:16:20 * dons is happy simonM is hacking on darcs
20:16:47 <augustss> oh, is he?  very good
20:17:06 <fnord123> was darcs ever moved to cabal or is it still an ancient pre-cabal build system?
20:17:54 <sorear> why doesn't GHC use cabal?  (bootstrapping concerns ?)
20:19:38 <mq_mattr> what is the status of hackage?
20:20:00 <mq_mattr> when will I be able to do hackage install lambdabot?
20:20:03 <dons> its in beta, there's no anonymous upload facility yet
20:20:08 <dons> you can download though
20:20:25 <dons> i expect we'll get this done and usable duing the hackathon -- that's the big goal
20:20:34 <mq_mattr> hey - good news
20:20:37 <dons> cpan for our lambda warez, finally
20:20:56 <sorear> Mad Idea: proxy server.  Upstream it's a hackage client.  Downstream it's an APT repository.
20:21:40 <chessguy> the hackathon is way out in the northwest, right?
20:22:00 <sorear> Automatically translate dependencies.  (Install into /usr/opt/apt-hackage or /usr ?)
20:22:34 <sorear> /usr/opt/ is debian-invalid, but ... for protecting users from hackage unniceness.
20:22:54 * sorear grumbles at the source of: *** Unknown command: USR/OPT/
20:23:03 <dons> chessguy: its at oxford.
20:23:13 <dons> ?wiki Hac_2007
20:23:13 <lambdabot> http://www.haskell.org/haskellwiki/Hac_2007
20:23:31 <chessguy> oh, i thought it was in the northwestern US for some reason
20:24:19 <chessguy> maybe SamB and i should organize our own hackathon :)
20:24:23 <dons> the GHC hackathon in Sep. was in Portland
20:24:58 <SamB_XP> um, two people /= hackathon
20:25:11 <chessguy> that's why i said "organize"
20:25:26 <chessguy> surely there's other haskellers within travelling distance of PA
20:25:36 <chessguy> where's that map thingy that shows where people are
20:26:11 <dons> sjanssen maybe?
20:26:18 <dons> (he was considering getting to oxford even)
20:26:30 <dons> hey, anyone know what the quote syntax for blockquotes on the wiki is?
20:26:48 <Daveman> hi chessguy :)
20:26:53 <emu> where in PA?
20:27:09 <chessguy> well, i'm just outside harrisburg, sam is around philly
20:27:18 <chessguy> dons, do you know where that map is?
20:27:22 <dons> ?map
20:27:23 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
20:27:25 <dons> that one?
20:27:33 * Daveman waves at chessguy
20:27:36 <chessguy> hi daveman
20:27:37 <dons> (several months out of date, remember)
20:27:45 <Daveman> I'm within travelling distance :p
20:27:48 <chessguy> dons, you could have at least pretended to have to think about it :)
20:27:57 <sorear> Unfortunately, sans Internet, the world is a very big place.  I for one live in San Diego and would be hard pressed to walk to either Oxford or PA.  (and the University of New South Wales sounds like it's probably in the southern hemisphere)
20:27:57 <resiak> Hrm, if only I were a competent Haskeller :(
20:28:07 <Daveman> hehe
20:28:07 <wy> emu: I'm very happy with your haskell-mode :-)
20:28:21 <Daveman> sorear, haha
20:28:35 <chessguy> hmm, Cale's back in CA isn't he
20:28:40 <dons> yep
20:28:41 <emu> wy: really, the only things different from cvs are the type,info,defn query fns and send-region thing
20:28:41 <Daveman> socal--
20:28:57 <Cale> chessguy: "back"?
20:29:02 <chessguy> well, we could get a few anyway
20:29:14 <chessguy> Cale, i mean, not in waterloo any more
20:30:19 <emu> wy: came up with any other suggestions for send-region?
20:30:55 <wy> emu: Hmmm... That's already better than sml-mode
20:31:14 <chessguy> we could have a...mini-hackathon
20:31:23 <Daveman> heehee, silly canucks :p
20:32:19 <Cale> chessguy: The Waterloo where I went to uni is in Ontario
20:32:23 <LoganCapaldo> I'm gonna have a one man hackathon right here! Whose not with me!?!?!?
20:32:53 <chessguy> Cale, isn't that what's marked on http://www.haskell.org/hawiki/HaskellUserLocations for you?
20:32:55 <lambdabot> Title: HaskellUserLocations - The Haskell Wiki
20:32:55 <Daveman> I, for one, am not with you.
20:33:30 <dons> Cale, do you offhand remember the blockquote syntax for MediaWiki ?
20:33:35 <Cale> chessguy: The coordinates for me are actually the coordinates of my house here in Brantford
20:33:44 <dons> ah got it.
20:33:50 <dons> <blockquote>  :}
20:34:04 <chessguy> Cale, but you're in california now, right?
20:34:10 <Daveman> O_o
20:34:13 <Cale> chessguy: California?
20:34:15 <Daveman> silly chessguy
20:34:19 <Cale> where'd you get that idea?
20:34:25 <chessguy> hmm
20:34:29 <chessguy> i don't know
20:34:30 <Daveman> Cale !=sorear :P
20:34:38 <Cale> I'm a terrorist, they'd never let me into the US ;)
20:34:42 <Daveman> huhu
20:34:53 <Daveman> you and your canadian currency :P
20:34:53 <chessguy> i coulda sworn you were in California somewhere
20:35:04 <Cale> and healthcare
20:35:11 <Daveman> hey, shush now :P
20:35:14 <LoganCapaldo> yeah we don't cotton to people writing we reasoned letters about nullity here in the states
20:35:15 * Daveman throws a toonie at Cale
20:35:21 <Daveman> :D
20:35:51 <chessguy> well, then maybe if we had it somewhere here in the NE US, you could even make it
20:36:03 <Daveman> dude, in the city, duh?
20:36:07 <Daveman> \o/
20:36:24 <Daveman> he just has to raft over niagra and take a brief drive :D
20:36:36 * jcreigh wonders if there's some way to fudge approximate lat/long coords from IP addresses, and generate that map dynamically based on whoever's in-channel.
20:37:25 <chessguy> oh! you probably said CA at some point, and i probably assumed that was california
20:37:31 <Daveman> fudge?
20:37:33 <chessguy> or someone else said it
20:37:34 <SamB_XP> jcreigh: it doesn't work with screen(1)
20:37:39 <Daveman> it works fine, as it is..
20:37:52 <Daveman> why would you want to mess up the perfectly mapped data? :p
20:38:12 <chessguy> Daveman, because it's very out of date
20:38:22 <emu> from the looks of it, northern europe is in a state of almost constant hackaton
20:39:13 <sorear> what is CA if not california? canada?
20:39:24 <chessguy> sorear, yes, in Cale's case
20:40:05 <Excedrin> I have some IP -> lat/lon stuff
20:40:22 <Daveman> hahaha
20:40:26 <Daveman> sorear, oh man.
20:40:54 <Daveman> emu, but europe doesn't get a vote.
20:41:26 <dons> if people want to add their details to that wiki page, i'll look into getting it updated automagically again
20:41:37 <fnord123> ?hackathon
20:41:37 <dons> (and ported to the new wiki)
20:41:37 <lambdabot> Unknown command, try @list
20:41:46 <dons> ?where hac07
20:41:46 <lambdabot> http://haskell.org/haskellwiki/Hac_2007
20:41:51 <LoganCapaldo> @where hackathon
20:41:52 <lambdabot> I know nothing about hackathon.
20:41:57 <Daveman> OH
20:42:05 * chessguy pulls up google earth
20:42:13 <Daveman> dons, I'll have to get you my scripts/module I wrote a year ago for soc
20:42:16 <dons> yes, even better would be an embedded google maps thingy
20:42:29 <dons> (not sure how to embed javascript in haskell.org's media wiki though....)
20:42:31 <dons> is that even possible?
20:42:43 <Daveman> a couple of us basically put together a small software interface which does exactly what you wanted (and conforms to the legal extent of the law)
20:42:52 <SamB_XP> dons: maybe you just want frappr?
20:43:47 <dons> too spammy :/
20:43:52 <dons> (at least I find it that way)
20:44:11 <dons> should be fairly easy to layer over the google maps these days. they have an api for doing just that
20:44:32 <sorear> Daveman: your country has special law for IP location ?!
20:44:43 <dons> some people might be interested, I added blurbs from CUFP to, http://haskell.org/haskellwiki/Haskell_in_industry#Haskell_in_Industry
20:44:45 <lambdabot> Title: Haskell in industry - HaskellWiki, http://tinyurl.com/ylh86r
20:44:46 * chessguy zooms in on his driveway
20:45:10 <Daveman> sorear, MY country? I'm no unbeliever!
20:45:32 <Daveman> and yes there surely are, when you have alternative methods for devising a pc's location >;)
20:45:42 <chessguy> oh wait, this is degrees, minutes, and seconds. i'll have to figure out how to convert this
20:45:46 <Daveman> also read the legal disclaimers for your web stuff, et al
20:45:58 <Daveman> I underwent scrutiny
20:46:12 <Daveman> chessguy, haha
20:49:37 <chessguy> oh, hmm. can i even edit that page?
20:50:40 <fnord123> my fave comp scientist
20:50:42 <dons> chessguy: which page? the map page?
20:50:42 <fnord123> http://www.kierberg.com/videos/advice-for-phd-students-from-tony-hoare
20:50:45 <lambdabot> Title: Advice for Ph.D. students from Tony Hoare at kierberg.com, http://tinyurl.com/yxtg46
20:50:47 <chessguy> dons, yes
20:50:55 <dons> you can still edit it I believe
20:51:01 <dons> but we should move the content to the new wiki
20:51:21 <chessguy> it says Immutable page (last edited 2006-09-28 10:56:52 by AndriyMakukha)
20:51:22 <dons> Udo rocks:
20:51:25 <dons>   > would the use of unsafeCoerce be dangerous?
20:51:26 <dons> If you have to ask, then yes.
20:51:29 <dons> :}
20:51:35 <dons> chessguy: oh, you haven't logged in
20:53:28 <Eidolos> Huh, my ghci is reporting that digitToInt isn't in scope.
20:53:36 <chessguy> aha
20:53:48 <allbery_b> Data.Char?
20:54:02 <dons> ?hoogle digitToInt
20:54:03 <lambdabot> Char.digitToInt :: Char -> Int
20:54:15 <Eidolos> thanks :)
20:55:24 <chessguy> uh-oh, it barfed
20:56:36 <chessguy> ok, i think it's ok now
20:56:42 <chessguy> and updated :)
20:59:12 * chessguy zooms in on SamB's driveway
20:59:22 <SamB_XP> chessguy: what?
20:59:28 <SamB_XP> I don't have a driveway!
20:59:33 <SamB_XP> show me!
21:00:08 <chessguy> oops
21:02:24 <mathewm> the guard function is wired into the List monad, right?  It isn't a generic construct?
21:02:39 <mathewm> ?type guard
21:02:41 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
21:02:45 <mathewm> oh
21:02:46 <dons> close, ;)
21:02:55 <dons> FP gem of the day: http://programming.reddit.com/info/uaqq/comments
21:02:56 <lambdabot> Title: Haskell mailing list gem: variables are not mutable boxes! (reddit.com)
21:03:03 <SamB_XP> hmm, that arrow is pointing at the wrong house! that arrow is pointing at 106 glencoe road!
21:03:43 <chessguy> which of those cars is yours? :)
21:04:00 <mathewm> ah!  guard False = mzero, I bet
21:04:06 <mathewm> mzero = []
21:04:06 * chessguy sticks a pin through SamB's roof
21:04:23 * SamB_XP actually lives at 104 glencoe road
21:04:52 <geckosen1tor> how do I bootstrap ghc?
21:04:58 <sorear> make
21:05:08 <dons> geckosen1tor: on a new machine?
21:05:11 <sieni> geckosen1tor: naked
21:05:15 <sorear> ./configure && make
21:05:15 <geckosen1tor> I don't have ghc
21:05:18 <dons> or you just want to build it on linux or some such?
21:05:27 <geckosen1tor> I tried configure, and it said I need ghc to build ghc unless I bootstrap
21:05:32 <sorear> download the ghc binaries && ./configure && make
21:05:35 <dons> geckosen1tor: grab a binary version from your package system first. then use that to build the compiler
21:05:37 <mathewm> so guard True = (++) ??
21:05:43 <geckosen1tor> how do I do it without the binaries?
21:05:48 <emu> i wonder, could it be built from hugs?
21:05:48 <sorear> you don't
21:05:55 <dons> the hard way: compile to C files on a system with GHC already on it, copy those C files to your machine, compile them with gcc
21:06:07 <sorear> ghc is written in haskell + ghc extensions.
21:06:10 <geckosen1tor> how did ghc get compiled in the first place then?
21:06:16 <dons> from a Miranda compiler
21:06:22 <emu> ah, the eternal question of compiler writers
21:06:23 <geckosen1tor> can miranda compile it?
21:06:24 <dons> (same problem gcc has on ever system)
21:06:26 <sorear> GHC 6.6 can be compiled using GHC 5.04
21:06:31 <dons> geckosen1tor: not any more
21:06:37 <sorear> GHC 5.04 can be compiled using ...
21:06:43 <mathewm> It still seems a shame to me that you cannot bootstrap GHC from HUGS or other Haskell interp/comp
21:06:43 <SamB_XP> chessguy: I cant recognize cars from even the closest range on Google Maps
21:06:50 <chessguy> so what do you think, would it work to have a mini-NEUS hackathon?
21:06:59 <dons> geckosen1tor: so grab a binary version of ghc from your package system, or from http://haskell.org/ghc
21:07:00 <lambdabot> Title: The Glasgow Haskell Compiler
21:07:04 <dons> and use that to build the src from scratch
21:07:06 <SamB_XP> I wonder when they decided to call it that, just like everyone else was doing ;-)
21:07:07 <geckosen1tor> crap, I don't like the idea of running a binary :-P
21:07:10 <chessguy> SamB_XP, oh you should use google earth
21:07:13 <jcreigh> but you only have to bootstrap once. After that, you can just copy binaries around.
21:07:18 <dons> geckosen1tor: welcome to compiler bootstrapping
21:07:21 <sorear> go back far enough and you'll probably find a guy with frontpanel switches and a knowledge of machine language
21:07:23 <SamB_XP> chessguy: wouldn't I need, say, a graphics card to do that?
21:07:31 <chessguy> umm
21:07:34 <chessguy> perhaps
21:07:41 <SamB_XP> which actually worked?
21:07:48 <geckosen1tor> so how far back do I have to go to get ghc working without another system from source?
21:07:54 <sieni> geckosen1tor: http://cm.bell-labs.com/who/ken/trust.html
21:07:56 <lambdabot> Title: ACM Classic: Reflections on Trusting Trust
21:07:58 <geckosen1tor> if I get 2 or 3 versions of ghc will they build eachother?
21:08:03 <dons> geckosen1tor: yes
21:08:12 <geckosen1tor> sweet!
21:08:15 <chessguy> i could screenshot it for you. oh wait.... :)
21:08:19 <dons> i.e. ghc 4 builds ghc 5, ghc 5 builds ghc 6.0, ghc 6.0 builds ghc 6.6
21:08:27 <geckosen1tor> so I won't need any binaries?  something bootstraps off gcc at some point?
21:08:35 <emu> "it's ghcs all the way down"
21:08:40 <sieni> geckosen1tor: I just thought you'd appreciate that link to be able to sleep your nights better
21:08:44 <dons> geckosen1tor: you'll be the only person on the planet to do this, if you try it. I *strongly* do not recommend it
21:08:45 <sorear> dons: have the earliest versions been lost yet?
21:08:54 <dons> ghc 0.29 is still around
21:09:02 <dons>  you'd be able to compile that with hugs probably
21:09:04 <chessguy> heh
21:09:05 <dons> (run it)
21:09:13 <geckosen1tor> sieni: that's a lot to read :-P
21:09:19 <geckosen1tor> and how do I get hugs?
21:09:24 <dons> it would probably be a months work or more to do the entire bootstrap from an originall C source
21:09:28 <sorear> it's a C program
21:09:30 <dons> and you'll need to trust gcc ultimately
21:09:33 <emu> it would be best if you could lazily recursively bootstrap ghc
21:09:44 <geckosen1tor> someone should write a script
21:09:50 <dons> geckosen1tor: please do not try to bootstrap this way! you're asking for pain..
21:09:52 <geckosen1tor> to make all the versions compile eachother
21:10:06 <sorear> in any event, you're using a sourceless CPU
21:10:13 <geckosen1tor> dons: do you think I would end up with the same binary?
21:10:20 <dons> ultimately, yes.
21:10:23 <dons> with a lot of work
21:10:24 <mathewm> what platforms did .29 support, I wonder :)
21:10:29 <chessguy> it would take like a month though
21:10:36 <geckosen1tor> mathewm: uh oh
21:10:40 <dons> since you're redoing the entire bootstrapping process from C to GHC 6.6
21:10:43 <geckosen1tor> mathewm: I will have some cross compiling steps
21:10:49 <dons> and you *still* have to trust gcc in the end
21:10:51 <sorear> even on dons's 4-core uber-compiler?
21:10:56 <dons> so just grab a ghc binary and start with that.
21:10:57 <geckosen1tor> but I have the source to gcc
21:11:00 <SamB_XP> ignoring timestamps
21:11:01 <mathewm> use the older gcc versions too ;)
21:11:05 <sorear> can't you trust the Unix cc instead?
21:11:05 <geckosen1tor> I can just bootstrap gcc the same way
21:11:06 <dons> you have the source to ghc too :)
21:11:08 <sieni> geckosen1tor: if you decide to do that, please blog your experiences ;-)
21:11:14 <sorear> then trust the B compiler?
21:11:15 <emu> you've also audited gcc?
21:11:26 <sorear> then trust BCPL
21:11:29 <geckosen1tor> emu: no, just bootstrap it from when it was assembly
21:11:37 <SamB_XP> sorear: as if you could run that!
21:11:40 <geckosen1tor> or whatever the first version was.. hmm
21:11:47 <bd_> geckosen1tor: I believe gcc was originally made in C, and compiled using other C compilers :)
21:11:49 <dons> mmm. recursion
21:12:02 <sorear> Just download the binaries, audit those, and bootstrap GHC :)
21:12:03 <SamB_XP> geckosen1tor: how do you know that GCC doesn't contain any backdoors in its source *right now*?
21:12:25 <chessguy> ahh, the classic dilemma. which came first, gcc or c
21:12:27 <geckosen1tor> SamB_XP: nice
21:12:34 <geckosen1tor> bd_: uh oh
21:12:38 <SamB_XP> chessguy: um.
21:12:39 <SamB_XP> duh.
21:12:40 <dons> it certainly has bugs in its source
21:12:44 <SamB_XP> cc came first!
21:12:49 <geckosen1tor> i know of some bugs in gcc
21:12:53 <sorear> bc came first!
21:12:53 <SamB_XP> dons: bugs in compilers aren't backdoors, though
21:12:56 <chessguy> SamB_XP, it was a joke
21:13:02 <xinming> lol... emu, you can bootstrap the asm using machine language, and bootstrap the c using asm, and then, bootstrap the hugs using c, bootstrap ghc 1.0 using ghc 0.x version, and at last, you bootstrap ghc 6.6... :-)
21:13:05 <geckosen1tor> this bug just makes gcc crash
21:13:06 <chessguy> as in "laugh now"
21:13:19 <emu> didn't wirth have a story about writing the first Oberon compiler on paper and then hand translating it to asm?
21:13:23 <geckosen1tor> does the binary for ghc come with source?
21:13:33 <SamB_XP> to be backdoors, they would have to compile certain code such that it would give undue privileges sometimes...
21:13:45 <emu> xinming: assuming you can get the intermediate versions to compile on that system
21:13:52 <|MA|Prototype> COCKFAGS
21:13:56 <base_16> ughh wouldn't it just be easier to just bootstrap to a basic haskell set from asm, then build ghc, and skip C entirely?
21:13:57 <mathewm> ghc-bin, darcs; then darcs get alex, happy, ghc
21:13:58 --- mode: ChanServ set +o dons
21:14:00 <|MA|Prototype> NIGGERS SHOULD DIEEEEEE
21:14:03 --- mode: dons set +b *!*=oldmanpr@*.lsanca.dsl-w.verizon.net
21:14:03 --- kick: |MA|Prototype was kicked by dons (dons)
21:14:04 <SamB_XP> like ken's backdoor
21:14:10 <sorear> pathetic...
21:14:11 <base_16> there's no reason you HAVE to bootstrap through C
21:14:13 <xinming> base_16: It's a ot of work.
21:14:24 <mathewm> I really tried to bootstrap from C
21:14:27 <xinming> lot
21:14:30 <mathewm> It is a purity thing
21:14:33 <geckosen1tor> crap, I don't know haskell at all
21:14:34 <chessguy> dons, nice work. that was really fast
21:14:39 <dons> :)
21:14:39 <sorear> wouldn't it be easier just to download the binaries from haskell.org?
21:14:48 <geckosen1tor> it's pretty useless to me now even though it runs :-P
21:14:51 <mathewm> trust me - for GHC, you must bootstrap with binaries :(
21:14:53 <emu> geckosen1tor: that puts you in a good position to do complicated bootstrap procedures on haskell compilers ;)
21:15:02 <xinming> mathewm: I don't think so.
21:15:08 <chessguy> seriously, in a lot of channels it takes the ops forever just to notice something like that even happening
21:15:12 <geckosen1tor> emu: why would i need to know haskell to do that..
21:15:13 <xinming> mathewm: If i understand correctly..
21:15:14 <xinming> oops
21:15:15 <sorear> IIRC there is a web interface for YHC, you could study haskell w/o installing binaries.
21:15:18 <xinming> mathewm: you are right.
21:15:19 <geckosen1tor> emu: i'm sure it will never fail in compiling
21:15:28 <mathewm> xinming: about what?
21:15:29 <emu> hehe
21:15:30 <xinming> mathewm: I found we need older version to bootstrap ghc
21:15:41 <Shimei> Found out something exciting today. There's a webhost that has Haskell CGI support: http://example.nfshost.com/versions.php :)
21:15:43 <xinming> mathewm: my mistake. ;-)
21:15:45 <lambdabot> Title: Versions of CGI Languages
21:16:52 <jcreigh> hmm, that's at least the third time that link has been pasted here today. Haskell webhosting must be popular.
21:16:56 <xinming> mathewm: BTW, if we don't have any binary for that architecture, do we have to bootstrap it through C?, and lower -> higher version order
21:17:06 <base_16> so, has the haskell community basically adopted reddit as far as link sites go? i'm surprised at how popular it is there
21:17:07 <SamB_XP> Shimei: yeah, I modded that up on reddit
21:18:25 --- mode: ChanServ set -o dons
21:18:31 <jcreigh> oh, it hit reddit. That's why.
21:18:59 <allbery_b> IIRC there's a way to compile it to C using generic (slow) portable routines, which you then copy to your target system and compile, then write fast native versions of the routines and build a new compiler with the old
21:19:12 <dons> allbery_b: yep, thta's how we bootstrap to new archs
21:19:21 <allbery_b> te hard part is of course coming up with optimized foo for a new arch
21:19:28 <Shimei> base_16: reddit's always been popular for FP discussion because it was previously implemented in Lisp. IIRC.
21:19:38 <dons> you compile haskell to ansi C, copy those across to the new machine, and build with gcc
21:19:44 <base_16> Shimei: ah, good call. i forgot that it was implemented in lisp
21:21:39 <mathewm> that bootstrap should be a webservice, for the lazy purists
21:21:47 <geckosen1tor> how do you compile to c?
21:22:31 <geckosen1tor> can you compile haskell to lisp?
21:22:39 <emu> yes, bootstrap via sbcl!!
21:22:56 <allbery_b> ghc mostly generates C intermediate code although there's direct-to-native support for some platforms
21:22:57 <LoganCapaldo> why sbcl?
21:23:05 <emu> because he can bootstrap sbcl
21:23:09 <emu> from clisp
21:23:16 <SamB_XP> hahahah
21:23:19 <emu> (you don't wanna bootstrap cmucl)
21:23:23 <allbery_b> so you configure it to generate the C intermediates only, then copy those intermediates over
21:23:32 <LoganCapaldo> I feel like this going to go all turtles on me
21:23:35 <geckosen1tor> emu: you might be overestimating my patience
21:23:43 <LoganCapaldo> and clisp is boot-strapble from?
21:23:47 <emu> if you want a real challenge, cmucl is it
21:23:53 <SamB_XP> "its turtles all the way down!"
21:24:04 <emu> i believe each version has to be compiled from the previous + certain additional crafted images
21:24:08 <LoganCapaldo> (I'm just waiting for someone to throw in Squeak)
21:24:14 <geckosen1tor> that will never work
21:24:26 <emu> LoganCapaldo: C
21:24:36 <LoganCapaldo> Oh, that's boring
21:24:46 <emu> it has comments written in German though.
21:24:50 <LoganCapaldo> I was hoping it was writing in fortran or something
21:24:55 <LoganCapaldo> ahhh much better :)
21:24:59 <SamB_XP> which you can run on Baughn's C implementation in Haskell
21:25:48 <geckosen1tor> he wrote a c interpreter in haskell?
21:26:59 <SamB_XP> I believe that was what he said he wrote it in...
21:27:18 <mathewm> Anyone know, in GHC, which file implements the Monad [] instance ?
21:27:23 <SamB_XP> it was specifically designed to break platform assumptions by randomizing certain platform attributes from run to run ;-)
21:27:31 <geckosen1tor> SamB_XP: awsome
21:27:31 <mathewm> I don't know what syntax was used, so my greps are failing me
21:27:34 <geckosen1tor> SamB_XP: does it work?
21:27:49 <geckosen1tor> so it can make ints 13 bytes
21:28:04 <SamB_XP> ask Baughn
21:28:11 <geckosen1tor> I will
21:28:21 <LoganCapaldo> mathewm: instance Monad [a] where ... I would guess would be what to grep for
21:28:21 <emu> does it perform to C standard behavior when you dereference an out of bound pointer?
21:28:32 <geckosen1tor> so what are the best docs to learn haskell?
21:28:34 <LoganCapaldo> I imagine it's in the prelude though
21:28:37 <sjanssen> matthewm: do you need to see the exact instance, or would the one from the Haskell report work?
21:28:48 <mathewm> oh, I will check the report
21:29:16 <LoganCapaldo> v >>= f = concatMap f v; return a = [a] ;)
21:29:22 <sjanssen> or, many people in the channel could tell you the defn.
21:29:47 * araujo kindof bored
21:29:57 <sjanssen> LoganCapaldo, for example ;)
21:30:15 <mathewm> interesting - I expected to see an fmap in there
21:30:37 <sjanssen> matthewm: you could write it that way
21:30:52 <sjanssen> v >>= f = concat (fmap f v)
21:31:00 <mathewm> and the concat threw me off - but I get it, duh
21:31:08 <josephrivers> has anyone used emacs with the "haskell-indent" mode?
21:31:17 <emu> josephrivers: sure
21:31:21 <sjanssen> and notice that concat is join for the list monad
21:31:23 <emu> geckosen1tor: haskell.org is a good spot to start
21:31:31 <geckosen1tor> emu: which tutorial?
21:31:37 <josephrivers> emu: did you get it to work well?--I'm having trouble with it
21:31:45 <emu> josephrivers: i use it regularly. what's up?
21:32:14 <emu> geckosen1tor: i duno. the one that worked for me probably wouldn't work for you.  browse through them.
21:32:34 <geckosen1tor> emu: so there isn't one accepted tutorial?
21:32:49 <LoganCapaldo> guard is the cooolest: guard True = [()]; guard False = []
21:33:07 <josephrivers> emu: well when I write something like: f x = let <enter> <tab> u = 3 <enter> <tab> t = 4
21:33:16 <emu> it puts t = 4 tabbed over
21:33:17 <josephrivers> The u and the t aren't lined up
21:33:20 <emu> hit tab again
21:34:24 <dons> josephrivers: there's  new page for haskell-mode
21:34:27 <dons> maybe it has some hints
21:34:34 <josephrivers> emu: I see how it works. Thanks.
21:35:09 <chessguy> is emacs the most common ide for haskell?
21:35:09 <josephrivers> dons: a help page?
21:35:18 <dons> ?where+ haskell-mode http://haskell.org/haskellwiki/Haskell_mode_for_Emacs
21:35:19 <lambdabot> Done.
21:35:53 <josephrivers> dons: thank you. I'll take a look at it.
21:36:40 <SamB_XP> well, is vim an IDE?
21:36:59 <LoganCapaldo> Is emacs an IDE?
21:37:10 <chessguy> maybe i should rephrase
21:37:22 <chessguy> what editor is most commonly used when developing in haskell
21:37:25 <SamB_XP> for my purposes, yes ;-)
21:37:58 <SamB_XP> chessguy: probably emacs or vim
21:38:05 <sjanssen> chessguy: I'd wager emacs
21:38:36 <SamB_XP> I'd say emacs, but I have no statistics
21:39:49 <base_16> they're probably both pretty comfortable for haskell
21:40:12 <base_16> vim's got good syntax highlighting for it
21:40:54 <geckosen1tor> which is better for haskell? vim or emacs?
21:41:08 <allbery_b> which do you know better?
21:41:14 <geckosen1tor> emacs
21:41:24 <mathewm> then vim is better ;)
21:41:28 <base_16> :)
21:41:31 <mbishop> haha
21:41:32 <svref> Debianers: do you go with the apt packages for ghc or compile your own?
21:41:32 * allbery_b rolls his eyes
21:41:44 <sjanssen> base_16: ever try to edit TeX style literate Haskell in vim?
21:41:51 <emu> svref: i compile my own
21:41:57 <dibblego> how do you get the list of files/directories within a directory?
21:42:10 <base_16> sjanssen: can't say i have-- is it problematic?
21:42:10 <dibblego> ?hoogle FilePath -> IO [FilePath]
21:42:11 <lambdabot> Directory.getDirectoryContents :: FilePath -> IO [FilePath]
21:42:14 <geckosen1tor> yes I compile it from source
21:42:16 <dibblego> never mind :)
21:42:21 <emu> svref: mostly because i am impatient and wanted ghc 6.6 NOW
21:42:22 * base_16 doesn't buy the whole "Literate Programming" bit
21:42:37 <sjanssen> @hoogle getDirectoryContents
21:42:38 <lambdabot> Directory.getDirectoryContents :: FilePath -> IO [FilePath]
21:42:51 <svref> I think I'm seeing api shift between the debs and what's doc'd on the Haskell.org site.
21:43:16 <emu> base_16: i'm curious to give it a shot.  the TeX style literate output is pretty slick.
21:43:17 <sjanssen> base_16: yeah, the synhl is a bit broken there
21:43:30 <base_16> sjanssen: :( that's sad.
21:43:54 <base_16> emu: i guess, as a curiosity, it's interesting, but it's nothing i'd ever toy around with in production code
21:44:11 <emu> base_16: interestingly, a large portion of ghc seems to be .lhs
21:44:20 <emu> not sure how "literate" it is, though
21:45:56 <base_16> well, i mean, Knuth talked a bit about literate programming, so i paid attention...
21:46:07 <base_16> but i guess i don't see any real advantages to it
21:46:26 <dibblego> you can pass YAHT to a compiler - that's an advantage
21:46:32 <dibblego> surely?
21:46:41 <base_16> dibblego: why?
21:46:50 <dibblego> so that all the code examples are type checked
21:47:21 <mathewm> I love bird lhs
21:47:28 <mathewm> LaTeX, not so much
21:47:45 <emu> i'm curious to try to inter..uh..calate a program with a hand-written proof that it conforms to specifications
21:47:49 <base_16> i like latex, and i like haskell, but i don't like them all mixed up
21:48:17 <dibblego> I saw a HTML document the other day that compiled with GHC
21:48:47 <mathewm> we should add a lit preproc for HTML
21:49:14 <mathewm> oooh, it should eval Javascript too!  like the cpp
21:49:47 <mwc> the listings package that's distributed in tetex claims haskell support
21:50:10 <mwc> should do a decent job... so you could redefine the code environment to do anything
21:50:23 <mwc> to me that's the strength of the \begin{code} style over >
21:50:51 <mathewm> mwc: good point
21:51:04 <mathewm> mwc: it is just harder on my eyes than >
21:51:23 <mathewm> mwc: had I learned LaTeX first, though
21:51:58 <wolverian> is there an efficient method of writing portions of an array to different files (handles)? i.e. the first ten bytes to file1, the next to file2, etc. all I can figure out is accessing each element separately.
21:52:39 <mwc> wolverian, suggest mapM or mapM_
21:53:11 <mwc> you can get an array to produce a list of (idx,val)
21:53:24 <mwc> @hoogle array list
21:53:25 <lambdabot> Did you mean: Array List
21:53:25 <lambdabot> Prelude.undefined :: a
21:53:25 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
21:53:31 <mwc> @hoogle Array List
21:53:32 <lambdabot> No matches, try a more general search
21:53:34 <mwc> @hoogle Array
21:53:34 <lambdabot> Array :: module
21:53:35 <lambdabot> Data.Array :: module
21:53:35 <lambdabot> Foreign.Marshal.Array :: module
21:53:35 <wolverian> mwc, I wanted something more efficient (i.e. a direct memory-to-handle write)
21:53:38 <rongenre> I have a question about how lazy evaluation works
21:53:53 <mwc> well, take the index's, look up the value, and write it
21:54:17 <wolverian> mwc, but that's horribly inefficient :)
21:54:20 <mwc> oh, sorry, I misread you... it sounded like you couldn't determine which handle to use until examining the element
21:54:25 <wolverian> ah. no.
21:54:31 <wolverian> the portions are predetermined.
21:55:27 <mwc> hmmm... well, depending on how efficiently toList is implemented
21:55:32 <mwc> @hoogle toList
21:55:32 <lambdabot> Data.HashTable.toList :: HashTable key val -> IO [(key, val)]
21:55:32 <lambdabot> Data.IntMap.toList :: IntMap a -> [(Key, a)]
21:55:32 <lambdabot> Data.IntSet.toList :: IntSet -> [Int]
21:55:36 <SamB_XP> mwc: no!
21:55:39 <mwc> hmm, well, it's something like that
21:55:39 <SamB_XP> just, no!
21:55:42 <wolverian> I wanted to avoid using a list, since that is necessarily slow.
21:55:45 <SamB_XP> that isn't what he wants
21:55:50 <rongenre> so foldr (:) [] [1..] is totally lazy, executes immediately, right?
21:55:53 <wolverian> compared to directly writing the memory block.
21:55:58 <mwc> I thought the list would be generated lazy
21:56:09 <mwc> +ly
21:56:11 <jcreigh> > take 5 (foldr (:) [] [1..])
21:56:12 <lambdabot>  [1,2,3,4,5]
21:56:14 <SamB_XP> mwc: write(2) that ain't!
21:56:24 <allbery_b> I don't think writing blocks of memory will work
21:56:30 <rongenre> yup
21:56:36 <SamB_XP> it could, if you have some!
21:56:48 <SamB_XP> see Data.ByteString
21:57:21 <allbery_b> well, sure, if you marshal the list values appropriately.  but you can't write an in-memory representation of a data structure because it's not guaranteed to *be* a contiguous chunk
21:57:24 <mwc> well, a UArray is supposed to be a block of memory, right? maybe he could use the FFI
21:57:35 <rongenre> doing this though:  >foo x (l,payload) = ((x:l), payload)
21:57:36 <rongenre> >(x,_) = foldr foo ([], Nothing) [1..]
21:57:38 <rongenre> >(take 10) x
21:57:39 <rongenre> Not lazy at all
21:57:46 <SamB_XP> at this time, Data.ByteString is probably the best bet...
21:58:18 <SamB_XP> now, if you will excuse me, I have to go to bed... about 20 minutes ago!
21:58:22 <rongenre> are lists just special?
21:58:40 <allbery_b> rongenre: hm?  how is that not lazy?
21:58:41 <wolverian> SamB_XP, thanks!
21:59:03 <rongenre> allbery_b: it should be, but that code doesn't terminate
22:01:53 * allbery_b thinks someone more awake and more expert in haskell needs to look at that
22:01:56 <chessguy> is it just me or is this notation really strange?
22:01:58 <chessguy> breed :: Population -> Prob Population
22:02:00 <chessguy>   breed pop
22:02:02 <chessguy>     = selectAll pop           >>= \pool     ->
22:02:04 <chessguy>       (applyMate (mate) pool) >>= \children ->
22:02:06 <chessguy>       combine pop children
22:02:31 <dibblego> chessguy, that's not strange at all
22:02:36 <dibblego> chessguy, pass it to @do
22:02:45 <dibblego> it's the monadic bind operation
22:02:48 <allbery_b> (all I'm seeing right now is that there's no let in there to make it sensible)
22:02:51 <chessguy> ok, so it's just missing the usual do sugar
22:03:08 <dibblego> well, it's not "missing"; it's just desugared
22:03:12 <dibblego> they are equivalent
22:03:22 <rongenre> doesn't do translate to the >>= stuff?
22:03:26 <dons> yes
22:03:28 <dibblego> yes
22:03:43 <dibblego> hey dons
22:03:44 <allbery_b> @redo selectAll pop           >>= \pool     ->  (applyMate (mate) pool) >>= \children ->  combine pop children
22:03:45 <lambdabot> do { pool <- selectAll pop; children <- (applyMate (mate) pool); combine pop children}
22:03:55 <dons> ?undo do pool <- selectAll pop ; children <- (applyMate (mate) pool); combine pop children
22:03:56 <lambdabot> selectAll pop >>= \ pool -> (applyMate (mate) pool) >>= \ children -> combine pop children
22:04:07 <chessguy> cute
22:04:17 <chessguy> why would someone write it that way though?
22:04:40 <dons> no reason
22:04:41 <rongenre> >>= makes sense sometimes, like you're injecting values
22:04:42 <dibblego> to demonstrate what lies beneath do?
22:04:49 <dons> ?. pl undo do pool <- selectAll pop ; children <- (applyMate (mate) pool); combine pop children
22:04:50 <lambdabot> combine pop =<< applyMate mate =<< selectAll pop
22:04:55 <dons> to refactor :)
22:05:00 <allbery_b> some people find the do notation to be obfuscation
22:05:19 <mathewm> some people consider Monads to be obfuscation
22:05:21 <mathewm> :)
22:05:27 <chessguy> heh
22:05:42 * allbery_b found monads to make more sense once he started working with the >>= notation instead
22:05:43 <dibblego> it is at least misleading
22:05:49 <rongenre> me too allbery_b
22:06:08 <dons> allbery_b: yeah, that makes sense.
22:06:12 <mathewm> yeah, it helps to be able to translate back and forth
22:06:14 <dons> understanding the foundation makes it a lot clearer
22:06:23 <dibblego> yep I agree
22:06:24 <dons>  @undo and @redo must be useful for this, I think
22:06:37 <dibblego> and renaming >>= to be postfix for demonstration to get started
22:06:38 <dons> ?undo do x <- getChar ; putChar (toUpper x)
22:06:39 <lambdabot> getChar >>= \ x -> putChar (toUpper x)
22:06:44 <dons> ?. redo undo do x <- getChar ; putChar (toUpper x)
22:06:44 <lambdabot> do { x <- getChar; putChar (toUpper x)}
22:06:50 <dons> ?. undo . redo undo do x <- getChar ; putChar (toUpper x)
22:06:51 <lambdabot> getChar >>= \ x -> putChar (toUpper x)
22:06:58 <dons> ?. pl . undo . redo undo do x <- getChar ; putChar (toUpper x)
22:06:58 <emu> i usually have to remember that do-notation is syntactic sugar for something specific when I get confused
22:06:58 <lambdabot> putChar . toUpper =<< getChar
22:09:12 <dibblego> can I put a IO Bool in a guard somehow?
22:09:21 <dons> ?type guard
22:09:23 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
22:09:43 <chessguy> i found an interesting paper on designing a genetic framework in haskell
22:10:11 <dibblego> Couldn't match `Bool' against `IO Bool'
22:10:41 <dibblego> I'll just use do
22:11:04 <chessguy> it's pretty vague though
22:13:50 <base_16> dibblego: ?type lift
22:13:53 <base_16> oops
22:13:56 <base_16> ?type lift
22:13:58 <lambdabot> forall (t :: (* -> *) -> * -> *) a (m :: * -> *). (MonadTrans t, Monad m) => m a -> t m a
22:14:29 <dibblego> how is that going to give me a Bool?
22:14:58 <base_16> dibblego: i accidentally nailed tab on  the keyboard, sorry-- that wasn't for you
22:15:04 <dibblego> ok
22:15:41 <jcreigh> rongenre: hmm...that's interesting. for some reason "foo" appears to be strict in its second argument. (ie, "head $ fst $ foo 1 undefined" doesn't work.)
22:24:07 <rongenre> jcreigh: is there another way to thread state when you're folding over a list?
22:25:20 <jcreigh> rongenre: I don't know. My "hmm...interesting" was a ploy to get someone more knowledgable than me to jump in. :)
22:33:28 <LoganCapaldo> This foo? foo x (l,payload) = ((x:l), payload)
22:33:36 <rongenre> yeah?
22:33:54 <LoganCapaldo> well foo 1 undefined can't work because it pattern matches
22:34:25 <LoganCapaldo> as far as why the foldr bit doesn't work, I have no idea :)
22:35:22 <sorear> try using lazy pattern matching
22:35:33 <sorear> ?let foo (x,y) = 2
22:35:35 <lambdabot> Defined.
22:35:37 <sorear> > L.foo undefined
22:35:39 <lambdabot>  Undefined
22:35:41 <sorear> ?let foo ~(x,y) = 2
22:35:42 <lambdabot> <local>:11:0:     Warning: Pattern match(es) are overlapped              In t...
22:35:43 <sorear> > L.foo undefined
22:35:44 <lambdabot>  Undefined
22:35:53 <sorear> ?undef foo
22:35:54 <lambdabot> Undefined.
22:35:58 <sorear> ?let foo ~(x,y) = 2
22:35:59 <lambdabot> Defined.
22:36:05 <sorear> > L.foo undefined
22:36:06 <lambdabot>  2
22:36:30 <LoganCapaldo> sorear: even so, I don't think fst $ foo 1 undefined will work
22:36:32 <sorear> as you can see, without ~ the pattern match on the pair breaks laziness
22:36:46 <sorear> ?undef foo
22:36:47 <lambdabot> Undefined.
22:36:54 <LoganCapaldo> cause it conses 1 to the fst of undefined
22:37:05 <sorear> ?let foo x (l,payload) = ((x:l),payload)
22:37:07 <lambdabot> Defined.
22:37:12 <LoganCapaldo> I could be wrong of course
22:37:17 <sorear> > fst $ L.foo 1 undefined
22:37:19 <lambdabot>  Undefined
22:37:23 <sorear> ?let foo x ~(l,payload) = ((x:l),payload)
22:37:24 <lambdabot> <local>:1:0:     Warning: Pattern match(es) are overlapped              In th...
22:37:24 <rongenre> no that's what I"m thinking, the tuple's the problem
22:37:31 <sorear> ?undef foo
22:37:32 <lambdabot> Undefined.
22:37:34 <sorear> ?let foo x ~(l,payload) = ((x:l),payload)
22:37:35 <lambdabot> Defined.
22:37:37 <sorear> > fst $ L.foo 1 undefined
22:37:39 <lambdabot>  Undefined
22:37:52 <sorear> lambdabot exists for testing, and I see you are right.
22:38:03 <sorear> ?undef foo
22:38:04 <lambdabot> Undefined.
22:38:31 <LoganCapaldo> OTOH, this lazy match business may be what you need to get your foldr to behave
22:38:47 <rongenre> there I go, it's working
22:38:48 <sorear> I'd recommend using monads.
22:39:02 <rongenre> thanks!  I had no clue about lazy matching
22:39:20 <sorear> > mapM_ (\v e -> (v,e)) [2..] 17
22:39:24 <lambdabot> Terminated
22:39:35 <rongenre> sorear: it seemed like a state monad thing, I'm just not sure how
22:39:43 <sorear> > mapM (\v e -> (v,e)) [2..] 17
22:39:45 <lambdabot>  [(2,17),(3,17),(4,17),(5,17),(6,17),(7,17),(8,17),(9,17),(10,17),(11,17),(12...
22:39:51 <jcreigh> > head $ fst (1:undefined, undefined)
22:39:52 <sorear> it is a state monad.
22:39:53 <lambdabot>  1
22:40:09 <lisppaste2> dibblego pasted "why does this loop forever?" at http://paste.lisp.org/display/31846
22:40:11 <sorear> right there, I used the reader monad...
22:41:07 <dons> dibblego: that formatting could be a bit better..
22:41:16 <dibblego> yeah I'll bet it can
22:41:17 <LoganCapaldo> dibblego: You're not following '.' and '..' by anychane?
22:41:19 <allbery_b> my guess is the first entry is '.'
22:41:35 <dibblego> nope, I pass "/tmp"
22:41:45 <dibblego> let f = do s <- directorySize "/tmp/t"; putStrLn $ show s in f
22:41:53 <allbery_b> doesn't matter; the first two entries in unix directories are '.' and '..'
22:41:55 <dons> dibblego: the .. and . will need to be filtered
22:42:00 <dibblego> oh
22:42:04 <allbery_b> you may need to skip them
22:42:10 <dibblego> ok
22:42:15 <dons> $ ls -a /tmp/t
22:42:15 <dons> .  ..
22:42:18 <dons> recursion!
22:42:18 <dibblego> and what's a better way to format those if/then/else?
22:42:28 <dons> the 'then' and 'else' keywords should line up
22:42:31 <sorear> ?let get = Control.Monad.State.get
22:42:32 <lambdabot> <local>:1:6:     Ambiguous type variables `m', `s' in the constraint:       `...
22:42:53 <sorear> ?let (get) = Control.Monad.State.get
22:42:54 <lambdabot> <local>:1:8:     Ambiguous type variables `m', `s' in the constraint:       `...
22:43:04 <dons> dibblego: I wrote some similar code here, http://www.cse.unsw.edu.au/~dons/code/hmp3/Tree.hs
22:43:14 <sorear> ?set -fno-monomorphism-restriction
22:43:15 <lambdabot> Not enough privileges
22:43:28 <dons> sorear: hehe. just add a type annotation
22:43:35 <dons> :t Control.Monad.State.get
22:43:36 <lambdabot> forall s (m :: * -> *). (MonadState s m) => m s
22:43:54 <dons> ?let get :: (MonadState s m) => m s ; get = Control.Monad.State.get
22:43:55 <lambdabot> Defined.
22:44:00 <sorear> dons: I just want to fake-import CMS.  Is there a better way?
22:44:16 <dibblego> I can't get the then/else lined up with a happy interpreter
22:44:35 <sorear> ?let put :: (MonadState s m) => s -> m () ; put = Control.Monad.State.put
22:44:36 <lambdabot> Defined.
22:45:07 <sorear> ?let evalState :: State s v -> s -> v ; evalState = Control.Monad.State.evalState
22:45:09 <lambdabot> Defined.
22:45:59 <dons> dibblego: should directorySize' (x:xs)   = do actually walk the xs too?
22:46:13 <sorear> > L.evalState (mapM (\y -> get >>= \x -> put (x+y) >> return (x*x)) [0..]) 0
22:46:14 <dibblego> dons, yes, it does
22:46:15 <lambdabot>  [0,0,1,9,36,100,225,441,784,1296,2025,3025,4356,6084,8281,11025,14400,18496,...
22:46:25 <dons> ah yes, sorry, didn't see that
22:46:33 <sorear> rongenro: I just used a state monad
22:47:03 <sorear> put (x+y) is the update, mapM does the iteration
22:47:09 <rongenre> sorear: ok, cool -- I need to grok it for a while
22:47:40 <rongenre> what's L?
22:47:44 <dibblego> @pl \x -> x /= "." && x /= ".."
22:47:44 <lambdabot> liftM2 (&&) ("." /=) (".." /=)
22:48:04 <allbery_b> it's the namespace lambdabot uses for ?let
22:48:10 <rongenre> got it
22:48:16 <sorear> a random prefix... dons doesn't want us redefining system functions, so he makes us put L. before
22:50:56 <rongenre> wow, mapM (\v e -> (v,e)) [2..] 17 is surprising me, how come the type system isn't complaining?
22:51:11 <rongenre> mapM :: (Monad m) => (a -> m b) -> [a] -> m [b]
22:51:20 <rongenre> that's one arg..
22:51:33 <sorear> Functions are a type of monad.
22:51:39 <sorear> :t join
22:51:40 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
22:51:47 <sorear> > join (*) 16
22:51:49 <lambdabot>  256
22:51:53 <dons> dibblego: y `notElem` [".",".."]
22:52:16 <sorear> > negate `fmap` (+23)
22:52:16 <dibblego> of course
22:52:17 <lambdabot>  Add a type signature
22:52:29 <sorear> > (liftM negate (+23)) 3
22:52:31 <lambdabot>  -26
22:52:36 * allbery_b was thinking patternmatch would also work to skip them
22:52:56 <sorear> basically, the function monad is for threading read-only state.
22:53:13 <lisppaste2> dons annotated #31846 with "help out dibblego" at http://paste.lisp.org/display/31846#1
22:53:16 <dons> dibblego: some hints ^^ (not tested)
22:53:18 <sorear> an action is a function from the state to the returned value
22:53:19 <dibblego> getDirectoryContents returns only the file name - not an absolute name - so it appears I have to do directoryName ++ "/" ++ x
22:53:29 <dibblego> ta
22:53:33 <allbery_b> yeh, I suspected that without looking at docs
22:53:53 <sorear> dibblego: what about Macs (:) , VMS (%), DOS(\\), etc?
22:54:02 <dibblego> sorear, that's my point
22:54:07 <dons> sorear: you have to use the FilePath library to be portable
22:54:09 <allbery_b> and thus patternmatch:  directorysize' pfx (".":xs") = directorySize' pfx xs -- and same for ".."
22:54:25 <allbery_b> er, lose the stray " after xs
22:54:29 <dibblego> is there a getDirectorySeparator?
22:54:37 <dibblego> ?hoogle IO Char
22:54:38 <lambdabot> Prelude.getChar :: IO Char
22:54:38 <lambdabot> System.Console.Readline.readKey :: IO Char
22:54:38 <lambdabot> IO.hGetChar :: Handle -> IO Char
22:54:41 <sorear> who said it was a string?
22:54:46 <rongenre> sorear: ok, got it
22:54:47 <allbery_b> use FilePath library
22:55:00 <rongenre> how about for threading writable state, like a Map
22:55:09 <dibblego> the FilePath library is System.IO afaik
22:55:27 <dons> ?where FilePath
22:55:27 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/projects/libraries.php#filepath
22:55:34 <dibblego> oh
22:55:43 <dons> that one
22:56:18 <dibblego> well crap I have to start again
22:56:56 <sorear> rongenre: you'd need to use a different monad, like Control.Monad.State.State
22:57:33 <sorear> each monad extends computation in a different way... fortunately there aren't many
22:57:39 <dibblego> dons, wtf is map (dir </>)?
22:57:42 <rongenre> sorear: Ok, back into the frying pan.   Is Data.Map a decent hash table?
22:57:44 <dibblego> ?type (</>)
22:57:45 <lambdabot> Not in scope: `</>'
22:58:31 <sorear> rongenre: no.
22:58:46 <sorear> Data.Map is a decent balanced binary tree.
22:58:47 <jcreigh> dibblego: x </> y = x ++ "/" ++ y
22:59:04 <dons> ?define x </> y = x ++ "/" ++ y
22:59:04 <lambdabot> (line 1, column 2):
22:59:05 <lambdabot> unexpected "<"
22:59:05 <lambdabot> expecting space or simple term
22:59:07 <dibblego> jcreigh, thanks, never seen it before
22:59:15 <dons> ?let x </> y = x ++ "/" ++ y
22:59:16 <jcreigh> dibblego: it's defined in the paste.
22:59:16 <lambdabot> Defined.
22:59:28 <dibblego> oh sorry
22:59:33 <dons> > map ("/tmp" </>) ["a","b"]
22:59:34 <lambdabot>  Not in scope: `</>'
22:59:42 <dons> > map ("/tmp" (L.</>)) ["a","b"]
22:59:43 <lambdabot>    The function `"/tmp"' is applied to one arguments,
22:59:43 <lambdabot>   but its type `[Ch...
22:59:53 <dons> > map ("/tmp" `(L.</>)`) ["a","b"]
22:59:54 <lambdabot>  Parse error
22:59:56 <rongenre> sorear: thanks for the pointers, i appreciate it
23:00:00 * dons doesn't care now :)
23:00:11 <dibblego> I got it
23:00:27 <jcreigh> > map ("/tmp" `L.</>`) ["a", "b"]
23:00:28 <lambdabot>  Parse error
23:01:07 <jcreigh> > map (L.</> "/tmp") ["a", "b"]
23:01:08 <lambdabot>  ["a//tmp","b//tmp"]
23:01:17 <jcreigh> oh, right
23:04:50 <dibblego> ?type const
23:04:52 <lambdabot> forall a b. a -> b -> a
23:06:24 <mathewm> is there any way to get an IORef at the top level?
23:06:34 <mathewm> I want a global map of counters
23:07:50 <dons> yes, but a State monad of Map Sym Int would be more appropriate
23:07:59 <LoganCapaldo> can't you just do globalValue = newIORef value
23:08:10 <dons> nope
23:08:31 <dons> that creates a function that returns a new IORef itialised to value each time
23:08:42 <dibblego> is the FilePath library the same as Distribution.Compat.FilePath in GHC?
23:08:44 <LoganCapaldo> heh
23:08:52 <dons> you can create global mutable variables with unsafePerformIO
23:09:03 <mathewm> do tell
23:09:07 <dons> but you have to ask yourself: i'm using haskell, i have state monads. do I really want to do this..
23:09:08 <dibblego> and how does pathSeparator return Char and not IO Char?
23:09:19 <LoganCapaldo> let (_,globalValue) = (0, newIORef value) ??
23:09:38 <mathewm> my code does IO and I want to use counters in various places for debugging
23:09:41 <LoganCapaldo> (I mean if I'm gonna play this game...)
23:10:16 <dons> mathewm: ok. code is on its way .... (gimme a sec)
23:10:41 <sorear> this is a known weakness of haskell.
23:11:36 <mathewm> I already started using unsafePerformIO to increment my counters in non-IO contexts
23:11:44 <sorear> (Or maybe it is a strength - how often is global state a design flaw?)
23:12:04 <mathewm> I would agree to the latter
23:12:16 <mathewm> this is a meta-issue, really
23:12:31 <sorear> mathewm : for debugging that's fine, but beware that the optimizer is entitled to assume uPIO doesn't exist, and acts accordingly
23:13:00 <mathewm> sure, but for incrementing counters, order won't matter
23:13:32 <mathewm> If it never calls the upio, then I missplaced the increment call or it works as intended :)
23:13:33 <sorear> uPIO is allowed to call it's argument zero or more times, not just once.
23:14:12 <sorear> i.e when the optimizer decides to recalculate something rather than store it, your counter is incremented twice
23:14:25 <dibblego> is System.FilePath included in GHC 6.6?
23:14:28 <mathewm> which is exactly what I would want
23:14:31 <sorear> actually that sounds good - it's measuring real work
23:14:57 <sorear> you probably already knew this, but GHC has a built-in sourcelevel profiler
23:15:06 <mathewm> granted, I am more interested in the efficiency of my algo's than I am of GHCs
23:15:42 <mathewm> I haven't used the built-in profiler before
23:17:16 <mathewm> part of what I want to do is use the counters for in-flight tweaking of behavior
23:17:44 <lisppaste2> dons pasted "global counters and IO with StateT" at http://paste.lisp.org/display/31850
23:18:04 <mathewm> that was fast, dons
23:18:22 <dons> true global variables can be achieved with: something like:
23:18:23 <dons> state :: MVar Editor
23:18:23 <dons> state = unsafePerformIO $ newMVar emptyEditor
23:18:23 <dons> {-# NOINLINE state #-}
23:18:31 <dons> (that's a thread safe global state value in IO)
23:18:45 <dons> but you *dont* need it. the state monad will be better for your health
23:19:02 <mathewm> thanks for info on both!
23:19:33 <mathewm> code 10, huh :)
23:20:04 <dons> just a loop to set different counters
23:20:06 <mathewm> inside joke...
23:20:15 <mathewm> for the people in my head
23:21:19 <dibblego> dons, what is the handle function that you have used?
23:21:27 <dons> ?hoogle handle
23:21:27 <lambdabot> Control.Exception.handle :: (Exception -> IO a) -> IO a -> IO a
23:21:28 <lambdabot> System.IO.Handle :: data Handle
23:21:28 <lambdabot> System.Win32.Types.HANDLE :: type HANDLE
23:21:36 <dibblego> oh, I was thinking file handle
23:22:07 <mathewm> dons: that also answers my earlier q's about mixing IO and ST - cool
23:23:00 <dons> yeah, its using the StateT monad transformer, which combines global state with some other monad
23:23:03 <dons> in this case, IO
23:23:34 <sorear> haskell is amazing. I'm still working on my infinite-types unifier, and in a day I've added sums, products, and lambda abstractions, refactored the code until there was a net *decrease* in LOC, and helped man #haskell all at the same time.  this'd take me a week in C, no doubt.
23:23:49 <dons> sorear: :)
23:24:07 <dons> corleno doing something strange...
23:25:03 <dibblego> ?type ($!)
23:25:05 <lambdabot> forall b a. (a -> b) -> a -> b
23:25:33 <dons> (strictness)
23:28:42 <dibblego> did you intend for your code to return 0 and stop going over other files if an exception is encountered?
23:28:53 <dons> ah no :)
23:28:57 <dons> (untested code ;)
23:29:06 <dibblego> righto
23:29:16 <dons> did I drop the recursive step?
23:29:29 <dibblego> I think so (I am still trying to interpret it myself)
23:32:52 <dibblego> I dropped it too accidentally
23:33:01 <dibblego> if isDir
23:33:02 <dibblego>         then directorySize x
23:33:28 <dons> hmm, dropping the recursion by accident makes me think it should use a higher order function to do the recursion for us
23:33:40 <dons> some kind of tree traversal fold/map
23:34:22 <dons> maybe there's a fixIO in there
23:37:35 <dibblego> probably, I've had to duplicate some code already
23:38:31 <dons> we should have a nice combinator library specifically for walking directory trees
23:38:41 <dons> modelled on the Data.Tree traverals
23:38:45 <lisppaste2> dibblego annotated #31846 with "I'm at here - but gotta go for a bit" at http://paste.lisp.org/display/31846#2
23:38:46 <dons> but in IO
23:38:57 <dibblego> yep
23:39:04 <dibblego> that sounds like a fun challenge
23:39:27 <mathewm> Switching my existing code to use the StateT still means I need to go through and change all my 'IO a' to the 'StateT s m a' all the way down to where I use any counter, right?
23:39:37 <dons> mathewm: yep
23:39:45 <dons> its useful to define:   print = io . Prelude.print
23:39:48 <dons> for example
23:39:53 <dons> where io = liftIO
23:39:58 <mathewm> sure
23:40:02 <dons> that way you don't have to add liftIO everywhere
23:40:19 <Cale> did you say counter?
23:40:22 <dons> (it is for this reason I often just start in StateT IO, since its more flexible, if I know i'm going to do IO)
23:40:36 <mathewm> yeah, I can see that
23:40:52 <mathewm> all those params scared me off of StateT, but I think I get it now
23:40:54 <mathewm> thanks
23:40:54 <dons> Cale, mathewm wanted a global counter table for some IO code
23:41:02 <dons> so I suggested http://paste.lisp.org/display/31850
23:41:14 <dons> which of course means lifting the existing IO code into StateT
23:41:26 <dons> (we should have some best practice hints for doing this stuff)
23:41:31 <Cale> It might we worthwhile newtyping that and wrapping up the operations
23:41:43 <Cale> So you never interact with the map directly
23:41:50 <dons> good idea
23:41:55 <dons> its tedious as it is
23:42:06 <dons> update "foo" -- for example
23:42:18 <dons> printit "foo" --
23:42:28 <Cale> especially if you're always incrementing them by 1
23:42:48 <dons> tedium is the enemy of haskell programmers everywhere. it must be slane with our abstractions!
23:43:06 <mathewm> :)
23:43:11 <dons> Cale: so a CounterT ?
23:43:31 <LoganCapaldo> slane doesn't type check :)
23:43:42 <dons> ?spell slewn
23:43:44 <lambdabot> sewn slew Selena Selene slews
23:43:49 <dons> ?spell slane
23:43:50 <lambdabot> Sloane Sloan slain saline Alane
23:43:53 <dons> heh
23:44:03 <Cale> http://haskell.org/haskellwiki/New_monads/MonadUnique -- it would be a lot like this
23:44:05 <lambdabot> Title: New monads/MonadUnique - HaskellWiki
23:44:13 <Cale> (only with a map instead of a single integer)
23:44:21 <dons> it must be saline with our reactions!
23:44:31 <LoganCapaldo> lol
23:44:41 <Cale> http://haskell.org/haskellwiki/New_monads/MonadSupply -- or like this
23:44:42 <lambdabot> Title: New monads/MonadSupply - HaskellWiki
23:44:50 <dons> ?spell todium
23:44:51 <lambdabot> tedium odium podium sodium rhodium
23:45:04 <dons> sodium is the enemy of haskell programmers everywhere.
23:45:31 <Cale> ?spell benzoeight
23:45:32 <lambdabot> Benoit besought benefit Benoite Benet
23:45:38 <sorear> sodium - sounds like some kind of logic-FP language...
23:45:40 <Cale> not quite that clever :)
23:45:44 <dons> ?spell benzoate
23:45:45 <lambdabot> Benoite Bendite benzine Benoit Benita
23:46:01 <dons> sodium would be a cool name for a language
23:46:10 <dons> actually, polonium
23:46:13 <dons> get that into ya!
23:47:02 * dons resolves that the ruby-on-rails killer in haskell will be called Polonium10
23:47:11 <dons> 210
23:47:24 <Cale> 7-methyl-4,6,6a,7,8,9-hexahydro-indolo[4,3-fg]-quinoline-9-carboxylic acid
23:48:02 <sorear> ok, sound like some evil plant alkaloid... reserpine?
23:48:34 <Cale> It's a particularly awkward name for LSD
23:52:20 <mathewm> IORef's are not thread-safe, I take it
23:52:45 <wolverian> hrm, I can't get oleg's implicit configurations to compile
23:52:57 <Eidolos> Doing Project Euler problems is really helping me get the Haskell syntax down.
23:53:07 <Eidolos> the basic stuff anyway
23:53:43 <dons> mathewm: MVars area simmple replacement,
23:53:46 <dons> or -- |Atomically modifies the contents of an 'IORef'.
23:53:46 <dons> --
23:53:46 <dons> -- This function is useful for using 'IORef' in a safe way in a multithreaded
23:53:46 <dons> -- program.  If you only have one 'IORef', then using 'atomicModifyIORef' to
23:53:46 <dons> -- access and modify it will prevent race conditions.
23:53:58 <dons> atomicModifyIORef
23:54:19 <dons> -- Extending the atomicity to multiple 'IORef's is problematic, so it
23:54:20 <dons> -- is recommended that if you need to do anything more complicated
23:54:20 <shankys_> I have a quick question about whether what I'm trying to do is possible in Haskell. I have two functions both called select. One has type [String] -> String -> (String, SqlValue) -> IO [[SqlValue]] and the other has type [String] -> String -> IO [[SqlValue]]. Is there some way to do this without GHC complaining that I have the same function defined twice? I know currying is the reason GHC complains, but is there any way to get around 
23:54:23 <dons> -- then using 'Control.Concurrent.MVar.MVar' instead
23:55:02 <dibblego> shankys_, only import one of them?
23:55:12 <wolverian> seems to be it doesn't compile on 6.6
23:55:23 <wolverian> compiles on 6.2 (!)
23:55:38 <shankys_> dibblego: I hadn't thought of that, although usually I'll be needing to use both in the same file.
23:55:58 <dibblego> shankys_, I think import qualified will work otherwise
23:56:34 <wolverian> what the heck is the Coverage Condition, as complained by GHC?
23:56:51 <shankys_> dibblego: The thing is that I want to have both select functions defined in the same file because it makes the most logical sense... Is that possible?
23:59:35 <wolverian> oh, well. it doesn't exactly surprise me that oleg's code would break a new GHC version :)
