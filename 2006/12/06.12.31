00:00:16 <metaperl> @type arr
00:00:17 <lambdabot> forall (a :: * -> * -> *) c b. (Arrow a) => (b -> c) -> a b c
00:00:26 <glguy> :t pure
00:00:26 <arcatan> Cale clearly likes drawing pictures of Haskell
00:00:27 <lambdabot> forall (a :: * -> * -> *) c b. (Arrow a) => (b -> c) -> a b c
00:00:47 <dibblego> I have one of Cale's pictures as my Linux desktop background
00:01:55 <metaperl> inquiring minds want to know... what is the difference between a function from b to c and an arrow of type a from b to c?
00:03:03 <falconair> any examples of these 'haskell pictures' on the web?
00:04:10 <glguy> pure functions are a specific instance of an arrow
00:04:15 <metaperl> i see
00:04:57 <glguy> Cale will correct me, but Monads are sequenced computation with a parameterized result type
00:05:12 <glguy> Arrows are a computation parameterized over both the input and result types
00:05:23 <metaperl> I'm studying http://haskell.org/arrows/syntax.html  .. and I understand arr (\x -> (x,x) ) -- it demuxes x so it can one x >>> f   and another x >>> g
00:05:23 <lambdabot> Title: Arrow syntax
00:06:23 <metaperl> @type (&&&)
00:06:24 <lambdabot> forall (a :: * -> * -> *) c' c b. (Arrow a) => a b c -> a b c' -> a b (c, c')
00:07:56 <metaperl> wow, the simpler version is a piece of cake to follow -     addA f g = f &&& g >>> arr (\ (y, z) -> y + z)
00:12:38 <Cale> http://cale.yi.org/autoshare/addA.png
00:12:41 <Cale> there you go
00:12:56 <Cale> a nice picture of exactly how that arrow is put together
00:12:58 * metaperl visits
00:13:00 <glguy> made with dia?
00:13:04 <Cale> inkscape
00:13:13 <glguy> what's that run on?
00:13:38 <Cale> Linux, mac, windows
00:13:47 <glguy> oh
00:13:49 <Cale> and it's free
00:13:53 * glguy hadn't heard of it
00:14:31 <metaperl> Cale - could second g have been used and \(y,x) -> (x,y) been removed?
00:14:37 <Cale> metaperl: absolutely
00:15:07 <glguy> one of the arrow papers explains why second is defined in terms of first
00:15:07 <Cale> It also could have used a combinator like &&&
00:15:30 <metaperl> That is an excellent diagram... we need to fix that syntax error on the arrows webpage and upload this picture as well... who controls haskell.org?
00:15:39 <glguy> the wiki?
00:16:08 <_frederik_> autoshare?
00:16:12 <Cale> this is unfortunately a page not on the wiki
00:16:14 <metaperl> nah - http://haskell.org/arrows/syntax.html
00:16:15 <lambdabot> Title: Arrow syntax
00:16:28 <metaperl> who owns haskell.org? who can change it?
00:16:33 <Cale> _frederik_: yeah, it's just a directory I have set up which I save things to in order for my webserver to share them
00:16:56 <Cale> Ross Paterson apparently is the maintainer of that page
00:17:16 <_frederik_> ok
00:17:33 <_frederik_> Cale: how did you make the arrow diagram?
00:17:41 <Cale> _frederik_: inkscape
00:18:38 <Cale> metaperl: so hopefully you can see how the proc notation avoids any of that mess, especially when the wiring diagrams get complicated
00:19:00 <metaperl> proc notation is not useable in haskell though right?
00:19:01 <_frederik_> cool
00:19:03 <Cale> even though in this case, there's a much cleaner way to write it with combinators
00:19:15 <Cale> metaperl: yes, if you use the switch -farrows
00:19:18 <Cale> in GHC
00:19:52 <Cale> but in HXT, you rarely need it, because most of the stuff you do with HXT is just a long chain of >>>
00:20:40 <glguy> (proc x; z <- pure (*2) -< x; returnA z}) 3 -- something like this?
00:21:21 <Cale> proc x -> do z <- pure (*2) -< x; return A -< z
00:21:41 <Cale> > (proc x -> do z <- pure (*2) -< x; return A -< z) 3
00:21:41 <lambdabot>  Parse error
00:21:42 <glguy> does lambdabot understand proc notation?
00:21:46 <Cale> apparently not
00:21:51 <metaperl> does Shae own haskell.org?
00:22:02 <dons> hehe. no
00:22:03 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
00:22:04 <Cale> er, returnA
00:22:06 <dons> its owned by the community
00:22:16 <Cale> but the error would have been different anyway
00:22:16 <metaperl> oh, we need that page fixed. I'm emailing Ross Patterson
00:22:32 <Cale> Prelude Control.Arrow> (proc x -> do z <- pure (*2) -< x; returnA -< z) 5
00:22:32 <Cale> 10
00:22:38 <metaperl> So far, arrows are much easier to understand than monads
00:22:41 <dons> the people who run haskell.org are listed on a link from the front page
00:22:49 <Cale> metaperl: there's a lot less to them
00:23:08 <metaperl> Cale - so they are not as powerful/useful?
00:23:09 <Cale> metaperl: but that means that you can do much zanier things with them, they're not as restrictive :)
00:23:20 <metaperl> There is no parsec equivalent in arrows yet right?
00:23:26 <glguy> wrong?
00:23:30 <Cale> There is, sort of
00:23:37 <Cale> Not quite as polished
00:23:50 <metaperl> for rock-solid code, monads are the way to go it sounds.. arrows can create more bugs it sounds like
00:24:18 <glguy> What does an Arrow implementation of a parser have to offer over a monadic one? efficiency?
00:24:37 <Cale> Arrows have both advantages and disadvantages over monads as an abstraction. The monad laws are stronger laws than the arrow laws, and might help a little more in reasoning.
00:25:00 <Cale> But arrows have this big advantage in that they abstract over the mechanism of input
00:25:38 <Cale> With monads, you're working with functions of type  a -> m b  all the time, and it's always impossible to inspect those
00:26:33 <Cale> Whereas with a value of type  a b c  it might be a specific data constructor which you know something about -- you can make certain optimisations this way, rewriting code for efficiency.
00:27:13 <Cale> http://www.cs.helsinki.fi/u/ekarttun/PArrows/
00:27:15 <lambdabot> Title: PArrows
00:28:41 <Cale> As a more impressive example than parsing, libraries like yampa use an arrow which processes streams of events. You can do neat tricks like delaying events, or integrating (summing) signals.
00:29:11 <Cale> You basically get this additional freedom of representation of functions that you didn't have before.
00:29:20 <metaperl> @type (***)
00:29:22 <lambdabot> forall (a :: * -> * -> *) c' c b' b. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
00:30:10 <metaperl> @type arr
00:30:11 <lambdabot> forall (a :: * -> * -> *) c b. (Arrow a) => (b -> c) -> a b c
00:30:22 <Cale> you can imagine (***) as just sticking the two arrows side by side
00:31:20 <Cale> then there's &&& which could be defined as  f &&& g = arr (\x -> (x,x)) >>> (f *** g)
00:31:30 <Cale> @type (&&&)
00:31:31 <lambdabot> forall (a :: * -> * -> *) c' c b. (Arrow a) => a b c -> a b c' -> a b (c, c')
00:32:18 <Cale> basically forking the input wire and plugging it into both of them
00:32:28 <metaperl> yes, demuxing
00:32:43 <metaperl> I dont quite get *** . give a quick example
00:32:50 <metaperl> dons did one earlier today
00:32:57 <metaperl> but I was in weenie mode so I ignored it :)
00:33:18 <Cale> > ((*2) *** (+5)) (10, 20)
00:33:19 <lambdabot>  (20,25)
00:33:36 <metaperl> oh weird
00:33:43 <metaperl> now what about dealing with a 3-tuple?
00:33:55 <Cale> first f = f *** arr id
00:34:05 <Cale> second f = arr id *** f
00:34:14 <Cale> 3 tuples are more of a pain
00:34:16 <glguy> \(a,b,c) -> ((a,b),c)
00:34:21 <Cale> there's no special support for them
00:34:40 <Cale> so you'd need to use arr with lambdas to pick out components, or make your own combinators
00:34:53 <Cale> but the arrow notation basically solves that
00:35:04 <Cale> (proc)
00:36:01 <Cale> but yeah, it's not so bad working with types like ((a,b),c)
00:36:24 <Cale> > ((+1) *** (+2) *** (+3)) ((1,2),3)
00:36:25 <lambdabot>  add an instance declaration for (Num (b, b'))
00:36:31 <Cale> > ((+1) *** (+2) *** (+3)) (1,(2,3))
00:36:32 <lambdabot>  (2,(4,6))
00:36:36 <Cale> er, right
00:36:39 <Cale> (a,(b,c))
00:36:59 <Cale> > ((+1) &&& (+2) &&& (+3)) 5
00:37:00 <lambdabot>  (6,(7,8))
00:37:13 <dons> interesting, I had assumed this would be a valid pattern: null pat && Just qs <- mquotes
00:37:16 <Cale> > ((+1) &&& (+2) &&& (+3) &&& (*12)) 5
00:37:17 <lambdabot>  (6,(7,(8,60)))
00:37:28 <dons> but its not, it seems. only: null pat, Just qs <- mquotes
00:37:57 <dgoldsmith> ?tell Binkley You actually can get 10.4 on CDs: http://images.apple.com/macosx/pdf/TigerMXOrderForm.pdf
00:37:57 <lambdabot> Consider it noted.
00:37:57 <Cale> dons: er...
00:38:11 * dgoldsmith has to go to bed...
00:38:12 <Cale> what would the first one mean?
00:38:26 <dons> maybe i shouldn't code while drinking champagne :)
00:38:30 <Cale> some kind of combination of a guard and pattern?
00:38:54 <dons> yeah, in a guard. True && (pattern that matches)   ;)
00:39:21 <Cale> Well, we already have pattern guards, but I'm not sure how you'd disambiguate the syntax
00:39:24 <dons> i was just staring at it for a few minutes wondering where the parse error was
00:47:31 <Cale> g'night all
00:47:40 <Cale> metaperl: good luck with arrows
00:47:52 <metaperl> Cale - good night and thanks
00:48:01 <Cale> I think you're probably basically ready to learn HXT :)
00:48:14 <Cale> The documentation is a bit scary
00:48:18 <dons> hehe
00:48:24 <Cale> but if you look through the tutorial
00:48:29 <dons> yes, we should have documentation-athons this year, I think
00:48:37 <dons> its all in the docs
00:48:42 <Cale> and then search the documentation for the things you want, you'll probably have decent luck
00:49:11 <Cale> HXT sort of has too much documentation, but really it's just not well-organised
00:49:45 <Cale> It'd probably be pretty easy to stratify all of HXT into levels of how much you're likely to care about each thing.
00:50:43 <dibblego> I am on #java on another network arguing with a guy who believes that 'refute' is a 'big word' because it is not used by the general population
00:51:06 <Cale> Currently all of those levels are kind of mixed up, and you have to go digging through a bunch of pentagonal-head screwdrivers and strange hammers with swiveling heads to find the ordinary tools.
00:51:27 <Cale> refute is an absolutely ordinary word
00:51:37 <Cale> I refute that claim ;)
00:51:44 <mr_tenor> dibblego: get him in here ;)
00:51:50 <glguy> The "Java" general population?
00:52:13 <glguy> > length "refute" -- that might be considered large...
00:52:14 <lambdabot>  6
00:52:26 <dibblego> glguy, no, length is not the definition of 'big' (apparently)
00:52:58 <mr_tenor> ah, the man lack sufficient vocabulary to express his thoughts in newspeak
00:52:59 <dibblego> I asked my 5 year old what refute means and he had a reasonable clue
00:53:11 <dibblego> I think I have to rest my case
00:53:16 <mr_tenor> "big word! bad! no like!"
00:53:29 <glguy> that fellow might die if he saw how often obviate was used in this channel
00:53:46 <dibblego> lol, this is hilarious
00:53:50 <Cale> the man not have words say think in newspeak
00:53:52 <dibblego> dibblego> I do not wish to pursue this issue unless it is of dire importance to you
00:53:59 <dibblego> I got in trouble for using 'dire'!!
00:54:13 <mauke> http://img.4chan.org/b/src/1167554233772.jpg (pic unrelated)
00:54:21 <dibblego> apparently, 'dire' is a big word too
00:54:26 <dibblego> and so is 'concurrency'
00:54:47 <glguy> where is this?
00:54:53 <dibblego> #java dalnet
00:55:58 <Cale> is his first language English?
00:56:05 <dibblego> yes
00:56:13 <Cale> that's sad then
00:56:16 <dibblego> he is genuinely arguing that I am using big words
00:56:27 <Cale> I recommend not talking to him
00:56:39 <dibblego> I'm trying, but then I got in trouble for saying 'dire' :)
00:57:03 <Cale> I wonder if there are any 3-letter words which he considers too large
00:57:24 <mauke> "vex"?
00:57:27 <dufflebunk> Apparently "big" is not too big
00:57:32 <dibblego> apparently, 'largeness' and length are in no way related (I think I have established this anyway)
00:57:34 <Xgc> Please stop using big words... like using large instead of big.
00:58:09 <glguy> wtf is juice, I want some grape *drink*
00:59:03 <glguy> dibblego: it looks more like the * dibblego monologues * there than an interesting converstation q-:
00:59:46 <dibblego> he stopped as soon you entered
01:00:34 <glguy> wtf, you are a #java op?
01:00:36 <glguy> java--
01:00:59 <bd_> ?karma java
01:00:59 <lambdabot> java has a karma of -16
01:01:05 <dibblego> http://rafb.net/p/uUQNXS17.html for the bored
01:01:06 <bd_> ?karma haskell
01:01:07 <lambdabot> Title: Nopaste - No description
01:01:07 <lambdabot> haskell has a karma of 15
01:01:27 <dibblego> yes, but I am an evangelist in disguise :)
01:01:34 <dibblego> I already have one convert and one on the way
01:02:26 * dufflebunk wonders why dibblego is converting people to JAva
01:02:31 <mr_tenor> http://img.photobucket.com/albums/v483/gabbagabba/warningsign_bigwords.jpg
01:02:33 <lambdabot> http://tinyurl.com/u8e97
01:02:33 <dons> > length "haskell" -- oh no!
01:02:35 <lambdabot>  7
01:02:59 <dons> hehe $ grep obviate * | wc -l
01:02:59 <dons> 15
01:03:05 <dons> (in the logs for this year )
01:03:24 <glguy> > "haskell" > "java" -- lambdabot needs to be beaten!
01:03:26 <lambdabot>  False
01:03:30 <dons> hehe
01:03:40 <dons> instance Num String where
01:03:44 <dibblego> > "haskell" > "Java"
01:03:46 <lambdabot>  True
01:03:49 <dibblego> yay!
01:03:52 <dons> > fromEnum "haskell"
01:03:53 <lambdabot>  add an instance declaration for (Enum [Char])
01:03:54 <lambdabot>   In the definition of `xtm...
01:03:58 <dons> bah
01:04:13 <dons> I want my haskerl ;)
01:05:31 <mr_tenor> is that like Haskell + Erlang ?
01:05:58 <dons> no, its a famous (well...) April 1 joke from '92 or so, the Perl + Haskell language, Haskerl
01:06:18 <mr_tenor> ah. cos haskell+erlang would rock :)
01:06:39 <dons> hehe, isn't haskell already haskell+erlang? ;)
01:06:46 <dons> almost..
01:07:07 <mr_tenor> i haven't checked out the concurrency extensions etc
01:07:11 <bd_> You could probably write a monad which could work a bit like erlang's messaging system, using fail...
01:07:16 <dons> http://www.cse.unsw.edu.au/~dons/haskell-1990-2000/msg01001.html
01:07:16 <lambdabot> Title: a note on the Haskerl extension to Haskell [long]
01:08:18 <dons> doesn't haskell have a wider range of concurrency and parallelism systems?
01:08:43 <dons> TVars, MVars, Chans/messages, forkIO/par/parMap, DPH,...
01:09:16 <dons> erlang does distribution better, I think
01:09:32 <dons> (all the distributed haskells have only been on research branches of ghc, et al)
01:15:41 <bakert> Haskell newbie (2 days) with some experience of Lisp/Scheme and Erlang.  Trying to write a program to shuffle a deck of cards.
01:16:16 <bakert> Nicked a great representation of the cards, wrote the dealing function, but having a hell of a time with shuffle.
01:16:35 <dons> ok. nice.
01:16:40 <dons> ?paste <- want to paste the code?
01:16:40 <lambdabot> http://paste.lisp.org/new/haskell
01:16:48 <dons> or just want to discuss the design?
01:16:59 <bakert> i'm not doing well enough to discuss the design!
01:17:07 <bakert> i need syntax level newbie help i'm afraid!
01:17:10 <dons> i guess you want to randomly permute a list oc f cards?
01:17:11 <mauke> @google haskell perfect shuffle
01:17:12 <lambdabot> http://okmij.org/ftp/Haskell/perfect-shuffle.txt
01:17:13 <bakert> i'll paste it
01:17:26 <dons> syntax, ah easy. yes
01:17:28 <dons> ?paste away
01:17:29 <lambdabot> http://paste.lisp.org/new/haskell
01:17:48 <dons> interesting link, mauke
01:18:30 <lisppaste2> bakert pasted "Trying to shuffle cards in haskell" at http://paste.lisp.org/display/33760
01:18:58 <bakert> the crucial stuff is happening in main and "blib"
01:19:05 <dibblego> glguy, well that was fun :)
01:19:19 <bakert> (blib is where i am trying to generate a list of 51 random numbers for the shuffle routine i've nicked and is near the bottom)
01:19:23 <glguy> I suppose... would have been more fun if he said more than 2 sentences ;)
01:19:52 <bakert> (blib is not a great name, i accept that -- until i thought of coming on irc i thought it was for me only!)
01:20:22 <dibblego> he'll be back
01:20:28 <dons> would someone like to have a look at the shuffling code? I'm a bit caught up in new years eve lambdabot code atm..
01:20:43 * dons looks at mauke 
01:21:02 <mauke> don't look at me, I'm too tired
01:21:24 <bakert> The provably perfect shuffle routine that I assume works that I nabbed takes a sequence (r1,...r[n-1]) of numbers such that r[i] is an independent sample from a uniform random distribution [0..n-i]
01:21:33 <velco> > take 3 (randoms $ mkStdGen 1)
01:21:34 <lambdabot>  Add a type signature
01:22:04 <glguy> bakert: blib is a complicated way to get a list of random numbers, right??
01:22:06 <mr_tenor> blib smells funny, wrt its type :/
01:22:16 <bakert> blib is completely screwed!
01:22:23 <bakert> I just have no idea how to fix it!
01:22:35 <bakert> It should take a number and produce a list of that many random numbers
01:22:45 <bd_> bakert: blib' needs to be a monadic action in IO, since it uses newStdGen, however the base case of bli returns just 'acc'. You need to bring acc into the monad with 'return acc'
01:23:26 <mauke> wait, newStdGen? isn't this what randomIO is for?
01:23:37 <mr_tenor> can't you pull that thin out into main?
01:23:40 <mr_tenor> thing
01:23:47 <bakert> bd_, that sounds great
01:24:16 <bakert> bd_, so monadic-ness kind of leaks across into all parts of a function with the same name, even if they are separately written out.  I see.
01:24:24 <glguy> forM [52,51..1] $ \ n -> randomRIO (1,n)
01:24:28 <bakert> bd_, that is pretty obvious i suppose
01:24:29 <bd_> bakert: All values of the same name need to have the same type
01:24:31 <glguy> or am I missing something
01:24:33 <bd_> so...
01:24:56 <bd_> the second case of blib' constrains the tpye like so:
01:25:02 <bakert> glguy, so can I call randomRIO and somehow not be in Monad-world?
01:25:25 <bakert> glguy, or if not, how can I can consume the list once I've made it in a non-Monad bit of code?
01:25:36 <bd_> blib' :: Num n => n -> [n] -> IO a
01:25:40 <bd_> the first constrains it to
01:25:41 <bakert> I'm sorry about this guys - as you can tell I have really not grokked the Monad thing yet
01:25:46 <bd_> blig' :: Num n => n -> a -> a
01:25:47 <glguy> bakert: the same way you consume the string returned by getLine
01:26:07 <bakert> Eek, and how do I do that?  with the "<-" arrow thing?
01:26:11 <glguy> bakert: yeah
01:26:32 <bakert> so i have a do block and I say something like
01:26:41 <bakert> x <- blib' blah blah
01:26:51 <bakert> and then i have a usable list in x?
01:27:01 <glguy> yeah
01:27:11 <glguy> and consider writing blib like I mentioned above
01:27:17 <glguy> if you want it to be more obvious what it does
01:27:25 <bd_> bakert: You can also write the recursive part without using IO, by using newStdGen once, in IO, then using randomR to advance the RNG
01:27:39 <glguy> (explicit recursion usually isn't what you want)
01:27:53 <bakert> So this line - forM [52,51..1] $ \ n -> randomRIO (1,n) - is actually the whole of blib'?
01:28:22 <glguy> except your blib took an arbitrary n
01:28:25 <glguy> and this one assumes 52
01:28:41 <bd_> :t forM
01:28:42 <lambdabot> Not in scope: `forM'
01:28:47 <dons> you can call randomRs and not be in IO world..
01:28:47 <bd_> :t mapM
01:28:49 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
01:28:51 <glguy> Control.Monad.forM
01:28:56 <bd_> :t Control.Monad.forM
01:28:57 <lambdabot> Not in scope: `Control.Monad.forM'
01:29:00 <bd_> heh
01:29:03 <bd_> forM = flip mapM?
01:29:07 <glguy> yeah
01:29:10 <bd_> @hoogle forM
01:29:10 <lambdabot> Text.Html.form :: Html -> Html
01:29:11 <lambdabot> Time.formatCalendarTime :: TimeLocale -> String -> CalendarTime -> String
01:29:11 <lambdabot> System.Time.formatTimeDiff :: TimeLocale -> String -> TimeDiff -> String
01:29:31 <bd_> hm, web-hoogle can't find it
01:29:32 <dons> > randomRs (0,51) (mkStdGen 42)
01:29:34 <lambdabot>  [39,3,5,30,40,11,50,43,6,39,21,3,4,2,12,13,15,23,29,0,42,12,16,6,44,50,2,18,...
01:29:40 <dons> :t randomRs (0,51) (mkStdGen 42)
01:29:41 <lambdabot> forall a. (Random a, Num a) => [a]
01:29:49 <dons> :t randomRs (0,51) (mkStdGen 42) :: [Int]
01:29:50 <lambdabot> [Int] :: [Int]
01:30:02 <bd_> > forM [52..1] $ \ n -> randomRIO (1,n) - is
01:30:03 <lambdabot>  Not in scope: `is'
01:30:07 <bd_> err
01:30:19 <dons> no IO anyway... ;) you'll have to use mkStdGen
01:30:24 <bd_> well, I guess randomRIO isn't going to be in lambdabot anyway XD
01:30:35 <dons> > randomRIO
01:30:36 <lambdabot>  Add a type signature
01:30:55 <dons> > randomRIO (0,51::Int)
01:30:56 <lambdabot>  <IO Int>
01:31:12 <bakert> What do I need to import to get forM?  Or is that what you're trying to work out (sorry, lots of this is over my head!)
01:31:22 <glguy> bakert: import Control.Monad
01:31:40 <dons> forM is in Control.Monad in ghc 6.6
01:31:55 <bakert> Ah, I have 6.4.1 -- is that bad?
01:31:58 <dons> its just mapM flipped though.  forM = flip mapM
01:32:02 <glguy> if you want to avoid monads altogether, you'd need to use mapAccumL to carry the generator along
01:32:12 <dons> 6.4.1 is fine, you can use mapM (just swap the arguments)
01:32:19 <dons> or write your own forM = flip mapM  :)
01:32:24 <bakert> (ahh, thanks Dons)
01:32:47 <bakert> I don't mind using Monads -- although I clearly haven't got to terms with them very well!  But I have to learn it sometime.
01:33:15 <glguy> blib g = mapAccumL f g [52,51..1] where f g n = let (x,g') = randomR (1,n) g in (g',x)
01:33:25 <bakert> This is just a bit mind-blowing for a mostly ruby-python-java programmer.  Makes erlang seem like a minor shift!
01:33:37 <glguy> oh, and then use "snd" to get the list
01:33:41 <dons> glguy: that looks pure too, will it run in lambdabot?
01:34:01 <dons> bakert: oh, how so?
01:34:06 <glguy> > let blib g = snd $ mapAccumL f g [52,51..1] where f g n = let (x,g') = randomR (1,n) g in (g',x) in blib (mkStdGen 42)
01:34:08 <lambdabot>  [40,40,18,19,45,27,5,27,27,9,22,35,37,3,19,37,24,12,34,13,31,29,13,29,9,5,3,...
01:34:11 <dons> I'd have thought erlang was fairly close to haskell, on the scale of things
01:34:16 <glguy> dons: ^^
01:34:22 <dons> nice
01:34:42 <glguy> bakert: there's one to mull over
01:35:05 <bakert> yeah, i'm just trying to work out where to start making sense of that!
01:35:22 <bakert> i think i need to indent it first
01:35:26 <dons> yeah
01:35:33 <dons> and then write the types down (or infer them in ghci)
01:36:58 <bakert> probably jumping in at the wrong end here, but does that hardcoded 42 mean I will get the same sequence each time?
01:37:04 <glguy> bakert: yeah
01:37:08 <glguy> bakert: lambdabot doesn't allow IO
01:37:13 <bakert> and if so am I back to Monad land if I need a different sequence each time?
01:37:20 <dons> yeah, so it uses the same random seed
01:37:21 <glguy> so we have to use psuedorandom numbers
01:37:21 <bakert> or can i use it pretty much as it is?
01:37:22 <bakert> or both?
01:37:27 <dons> you could just increment the random seed if you want
01:37:27 <bd_> > let { randomRM range = do { g <- get; let (a, g') = randomR range g in do { put g'; return a } } } in reverse $ evalState (flip mapM [1..52] $ \n -> randomRM (1, n)) (mkStdGen 42)
01:37:29 <lambdabot>  [29,3,35,30,19,35,13,45,39,2,7,5,6,39,5,20,28,12,21,7,28,29,25,5,11,19,25,12...
01:37:47 <bakert> goddamn i can't wait until this stuff starts making more sense!
01:37:52 <dons> bakert: i.e. have the function return the next seed to use
01:37:55 <glguy> bd_: I intentionally avoided MonadState because of the Monad aversion
01:38:07 <dons> (which is almost a monad anyway, once you start threading the seed around as a bit of state)
01:38:15 <glguy> bakert: just have your main function do: g <- getStdGen
01:38:17 <bd_> glguy: ah
01:38:20 <glguy> bakert: and pass that in to blib
01:38:23 <glguy> which will stay pure
01:38:25 <dons> yeah
01:38:34 <bd_> glguy: actually, I was messing with the syntax there while you wrote that XD
01:38:38 <bakert> glguy, right -- I like that.  i can just about fit that in my brain
01:38:48 <bakert> keep the madness in one place
01:38:48 <bakert> !
01:38:55 <Vq^> heh
01:39:10 <glguy> :t Data.List.mapAccumL
01:39:11 <lambdabot> forall y acc x. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
01:39:38 <glguy> in this case, the random number generator is the acc, the upperbound is x, and the resulting random number is y
01:40:23 <glguy> so given an initial random number generator, a list of upper bounds, you get the modified number generator and a list of random numbers
01:41:04 <bakert> ok
01:41:40 <bakert> so if i want to have different numbers each time i can't just use snd on blib -- I have to take the first part of the returned pair and store it and use it again next time I need random numbers?
01:41:56 <glguy> bakert: or get a new generator
01:41:58 <bakert> that all seemed difficult to me which is why i started generating an infinite list and using "take" on it.
01:42:04 <bakert> but perhaps that is badly wrong
01:42:19 <bakert> i am very much new to all this and i was just trying to get something working
01:42:21 <dons> an infinite list seems like a good idea, since you can just take as much as you need each time
01:42:35 <glguy> but then you'd need ot return the unused part
01:42:39 <glguy> for use later :-p
01:42:39 <bd_> bakert: that's certainly a possible approach. Be careful though, you need to make sure things keep in the range you want
01:42:45 <bakert> yes
01:42:54 <bakert> i think perhaps i overcomplicated things trying to make them simple!
01:42:55 <dons> glguy: would you like to show how to record and reuse a seed/infinite list, or to get a new generator?
01:42:57 <bd_> :t iterate
01:42:58 <lambdabot> forall a. (a -> a) -> a -> [a]
01:43:09 <dons> it might help bakert to see an example
01:43:24 <glguy> dons: getStdGen returns a new one each time... right?
01:43:33 <dons> yeah
01:43:42 <bakert> I think perhaps my problem is that I want to tie up shuffle so that it doesn't interfere with anything else.  But I guess that is not quite possible.
01:43:42 <bd_> you mean newStdGen?
01:43:45 <dons> or you could split the one you have
01:43:48 <bd_> http://www.zvon.org/other/haskell/Outputrandom/getStdGen_f.html
01:43:50 <lambdabot> Title: Haskell : getStdGen
01:43:51 <bd_> how about: infiniteListOfGenerators = do { g <- newStdGen; iterate split g } -- this is an infinite list of generators
01:43:57 <bd_> and then you can do something like
01:44:16 <dons> bd_: nice idea
01:44:17 <opqdonut> bd_: but split isn't very robust
01:44:24 <bd_> zipWith (\g n -> fst $ randomR (1, n) g) infiniteListOfGenerators
01:44:48 <bd_> er, that's be return $ iterate split g above XD
01:45:21 <opqdonut> frankly, the way things are the easiest way to generate lists or other structures of random is randomIO
01:45:26 <bakert> Ideally I'd like to do "deal 3 7 (shuffle newDeck)" which would deal 3 players 7 cards each from a shuffled pack of cards.  I've got all the parts apart from shuffle.  But I guess the way haskell works this line of code is not possible?
01:45:26 <bd_> opqdonut: it's probably not a very good idea in terms of entropy I guess...
01:45:26 <glguy> bakert: the trick is that function in Haskell on its own always returns the same result for the same input parameters
01:45:44 <glguy> bakert: so if you want to base that suffling on something like IO, you have to link it to that Monad
01:45:57 <opqdonut> bakert: i suggest IO too
01:46:07 <glguy> Monads like you have implicit parameters
01:46:07 <bd_> bakert: for a simple example program you can just pass in a generator and have it use that. In a more complex program, you'd have to use monads (fear!) and maybe make a MonadRandom class or something
01:46:13 <bd_> or use IO directly
01:46:19 <glguy> let you *
01:46:48 <bakert> right, so could my eventual code be "deal 3 7 (shuffle newDeck randomThing)" but otherwise the same?
01:47:04 <bd_> not quite, but close
01:47:04 <opqdonut> bakert: that'd be one option, yes
01:47:21 <bd_> wait, yes, randomThing
01:47:33 <bakert> ok that sounds plenty good enough for my first haskell program.
01:48:00 <bakert> i think i'll probably swear off creating my own monad or any madness like that and just use the random number generator stuff.
01:48:09 <bakert> i have various snippets from this ist
01:48:16 <bakert> ... from this discussion
01:48:31 <bakert> i like this one because it is short:
01:48:34 <glguy> bakert: you generally don't need to create your own Monad
01:48:35 <bakert> x <- forM [52,51..1] $ \ n -> randomRIO (1,n)
01:49:13 <bd_> > [52..1]
01:49:14 <lambdabot>  []
01:49:17 <bd_> > [52,51..1]
01:49:18 <lambdabot>  [52,51,50,49,48,47,46,45,44,43,42,41,40,39,38,37,36,35,34,33,32,31,30,29,28,...
01:49:22 <bd_> ...why? oO
01:49:39 <glguy> [52..1] means enumFromTo 52 1
01:49:40 <bakert> good question bd_ !
01:49:45 <glguy> enumFromTo always goes up :)
01:49:50 <velco> > [52, 50, .. 0]
01:49:51 <lambdabot>  Parse error
01:49:55 <velco> > [52, 50 .. 0]
01:49:55 <bd_> what's the second one then?
01:49:56 <lambdabot>  [52,50,48,46,44,42,40,38,36,34,32,30,28,26,24,22,20,18,16,14,12,10,8,6,4,2,0]
01:50:06 <glguy> > enumFromThenTo 52 51 1
01:50:07 <lambdabot>  [52,51,50,49,48,47,46,45,44,43,42,41,40,39,38,37,36,35,34,33,32,31,30,29,28,...
01:50:07 <velco> to get the decrement
01:50:12 <bd_> ic
01:51:11 <bakert> So if I do something like:
01:51:12 <bakert> main = do
01:51:16 <bakert>     g <- newStdGen
01:51:21 <bakert>     x <- forM [52,51..1] $ \ n -> randomRIO (1,n)
01:51:26 <bakert>     putStrLn (show x)
01:51:29 <bakert> ...
01:51:29 <glguy> > [1,2 .. 1] B^D
01:51:30 <lambdabot>  Not in scope: data constructor `D'
01:51:33 <glguy> > [1,2 .. 1] -- \B^D
01:51:34 <bakert> does that make any sense at all?
01:51:35 <lambdabot>  [1]
01:51:43 <bakert> Eek, I haven't even used g
01:51:44 <opqdonut> bakert: seems ok
01:51:57 <bakert> Do I need that first line?
01:52:01 <opqdonut> bakert: yeah, cause you don't need it with randomIO
01:52:05 <glguy> bakert: the randomRIO version (emphasis on IO)
01:52:10 <glguy> bakert: doesn't need the generator
01:52:15 <bakert> ah ok
01:52:23 <bakert> so randomRIO is supplying it's own generator.
01:52:28 <bakert> inside somewhere
01:52:29 <bakert> cool.
01:52:52 <glguy> bakert: randomRIO is in the IO monad, and has access to the state of the computer (which allows it to store a generator or create a generator using the state of the computer)
01:52:57 <bakert> brilliant
01:53:03 <bakert> so that gives me my list of random numbres
01:53:06 <bakert> numbers
01:53:25 <glguy> in a perfectly type-safe way ;)
01:53:38 <bakert> now i need to pass them, and my deck of cards, into shuffle
01:54:11 <glguy> add a line to main: let shuffledCards = shuffle x cards
01:55:00 <bakert> is the let necessary?  or is that just so i can refer to them later on?  i mean, does it have magic powers or is it just to give a name to something?
01:55:25 <glguy> x <- something -- means: do something and bind the result to x
01:55:39 <glguy> let x = something -- means: assign the value of something to x
01:55:47 <bakert> ok
01:55:48 <bakert> gotcha
01:56:05 <glguy> difference in monadic and pure functions
01:56:06 <benja_> so yes, it's just to give a name
01:56:08 * allbery_b sighs --- Bulat has wtf?ed me yet again...
01:56:12 <dons> since its a lazy language though, it really just assigns a name to an unevaluated expression
01:56:24 <dons> allbery_b: hehe
01:56:29 <bakert> so normal functions with no side effects use "let blah = " and side effects ones you must explicitly say "do the thing now" with a "<-"???
01:56:35 <dons> yep
01:56:35 <glguy> yeah
01:56:37 <vegai> new year's promise: I *will* complete a non-trivial application with HAppS
01:56:45 <vegai> promise/resolution
01:56:51 <dons> since you want to ensure an ordering of effects
01:56:56 <dons> do c <- getChar ; putChar c
01:57:11 <glguy> it would be *much* cooler
01:57:17 <glguy> if Haskell knew what char you would input
01:57:20 <glguy> and printed it first
01:57:22 <glguy> and then waited
01:57:24 <dons> in the monadic world, <- unwraps a value from the monadic action
01:57:28 <robreim> is HAppS or WASH the preferred software to use for haskell web apps?
01:57:40 <benja_> bakert: yes, or to put it differently: if the rhs has type (m a) -- e.g. m=IO -- and you want the variable on the lhs to have type a, use <-
01:57:43 <dons> glguy: heh
01:57:45 <vegai> WASH is older, more mature. HAppS is merely interesting.
01:57:56 <benja_> so the lhs and rhs of <- have different types
01:58:00 <dons> robreim: I hear we have a startup in SF using WASH
01:58:12 <bakert> benja_, ah yes thanks that's a nice way for a newbie to think about it!
01:58:13 <dons> HAppS is the new kid on the blog, but is very promising too
01:58:14 <glguy> lhs has type 'a', rhs has type: 'm a'
01:58:24 <benja_> :)
01:58:28 <dons> there's also the chalmers HSP and related libs
01:58:29 <robreim> I see
01:58:42 <vegai> "New kid on the blog". Perhaps that's the name for my blog software
01:58:49 <dons> heh
01:59:04 * dons adds regex support to @quote
01:59:12 <glguy> ?quote sudo
01:59:12 <lambdabot>  You speak an infinite deal of nothing
01:59:15 <glguy> woot ;)
01:59:48 <dons> heh
02:00:00 <dons> does the linux sudo have the amusing messages too?
02:00:09 <bakert> Thanks so much for all your help guys.  At the risk of outstaying my welcome can you help me with my new error?!  I'll paste a smaller version that gives the same error ...
02:00:18 <dons> bakert: of course!
02:00:58 <glguy> dons: I don't think so... (there are a lot of things linux is missing like that (-;  )
02:01:03 <allbery_b> huuuh.  "checking whether ghc has readline package... : Permission denied"
02:01:08 <glguy> OS X's sudo doesn't
02:01:29 <lisppaste2> bakert pasted "Shuffling cards ... after the random number stuff" at http://paste.lisp.org/display/33762
02:01:41 <bakert> The error is:
02:01:46 * allbery_b suspects he's discovered why freebsd ports's ghc lacks readline...
02:01:54 <bakert> *Main> main
02:01:54 <bakert> [9S,6C,4S,*** Exception: /home/bakert//haskell/smaller.hs:(58,8)-(59,50): Non-exhaustive patterns in function loop
02:02:06 <bakert> Oh hang on i think i might be being really thick
02:02:14 <dons> glguy: hehe, checking the src:      * CSOps insults (may be site dependent).
02:02:25 <dons> glguy: mmm, maybe lambdabot should use these quotes...
02:02:35 <glguy> lol
02:02:40 <glguy> i like it
02:02:46 <bakert> Sorry guys ... should have been 51 random numbers not 50.
02:02:51 <bakert> !!
02:02:58 <glguy> the last number is always 1 anways
02:03:01 <glguy> so it works out just fine
02:03:05 <bakert> Looks like it works perfectly.  Thank you so so much!
02:03:07 <benja_> ooh, '[(Card Clubs Ace) .. (Card Spades King)]' -- I hadn't ever considered that =)
02:03:25 <bakert> benja_, yeah i looooooved that.  i stole it, i didn't think of it!
02:03:31 <benja_> bakert: =)
02:03:33 <bakert> genius
02:03:54 <glguy> bakert: shuffle is a perfect candidate for mapAccumL
02:05:04 <benja_> has anyone done a structured graphics library (in the sense of representing shapes etc. as objects) on top of cairo/gtk2hs?
02:05:09 <bakert> The "simple" examples for mapAccumL boggle my mind.
02:05:12 <glguy> shuffle deck xs = mapAccumL f deck xs where f deck x = let (a,b:bs) = splitAt (x-1) in (a ++ bs , b)
02:05:23 <benja_> I'm presuming not, but I'm thinking about rolling my own, so it seems prudent to ask =)
02:05:50 <glguy> bakert: oh, and you'd need another snd
02:06:26 * glguy has had his first two oportunities ever for using mapAccumL tonight
02:06:29 <bakert> glguy, not being rude, genuinely interested, why is that better than the "x <- forM [51,50..1] $ \ n -> randomRIO (1,n)" answer?
02:06:45 <glguy> bakert: which
02:06:54 <glguy> bakert: the thing I just told you now compliments that
02:07:01 <bakert> ah
02:07:16 <bakert> sorry, i don't get it!  what is it for?
02:07:25 <glguy> to replace the "shuffle" function you wrote
02:07:30 <glguy> and the extract function you wrote
02:07:33 <bakert> Ahhhh!
02:07:36 <bakert> sorry!
02:07:43 <bakert> i get it now!
02:08:06 <glguy> explicit recursion is for generalized functions, not specific algorithms, when it can be helped ;)
02:08:09 <bakert> (it is quite exciting being this much of a newbie at a programming thing again after all this time but i can't wait for this stage to be over so more of this makes sense!)
02:08:39 <glguy> soon you'll be qualified like I am, just enough to hand out code snippets to new #haskell people ;)
02:09:10 <bakert> !!!
02:09:23 <benja_> =)
02:09:28 <glguy> it only takes 1 year
02:09:34 <glguy> q-:
02:10:16 <bakert> If I can annoy you lot a little longer I'd like to try and make sense of my now working version.  I take it that flip just reverses the arguments to a function?
02:10:30 <glguy> yeah: flip f x y = f y x
02:10:31 <bakert> So forM and mapM are basically the same function.
02:10:37 <glguy> yeah
02:10:41 <bakert> So what does that function do?
02:10:45 <glguy> which
02:10:49 <bakert> mapM
02:10:53 <bakert> (or forM)
02:11:23 <glguy> forM xs f -- for each x in xs, run the action (f x) in sequence
02:11:40 <dons> mapM f as       =  sequence (map f as)
02:11:51 <glguy> and then return the results of each action as a list
02:11:51 <bakert> so it is just a map that ensures things happen in a certain order?
02:12:00 <benja_> bakert: do you understand sequence?
02:12:01 <dons> it maps a (monadic) function over a list, and then sequences that list
02:12:04 <dons> evaluating it in order
02:12:19 <bakert> benja_, i thought i did.  let me look it up again ...
02:12:20 <dons> sequence ms = foldr k (return []) ms
02:12:21 <dons>         where
02:12:21 <dons>           k m m' = do { x <- m; xs <- m'; return (x:xs) }
02:12:22 <glguy> sequence takes a list of actions, runs them in order and gives you a list of the results
02:12:37 <benja_> that's a good description imho
02:12:39 <bakert> is "actions" a word with a special meaning here?
02:12:47 <dons> yeah
02:12:49 <glguy> Monadic values
02:12:49 <benja_> bakert: values of (m a)
02:12:50 <bakert> action = something with a side effect?
02:12:51 <benja_> where m is a monad
02:13:08 <benja_> everything that can go on the rhs of a <-
02:13:10 <benja_> :-)
02:13:22 <dons> yeah, a monadic value. which may perform a side effect when evaluated
02:13:30 <dons> i.e. not a function (in the math sense)
02:13:30 <benja_> so list <- sequence [foo, bar, baz] is equivalent to
02:13:46 <benja_> el1 <- foo; el2 <- bar; el3 <- baz; let list = [el1, el2, el3]
02:14:03 <benja_> does that make sense?
02:14:07 <allbery_b> ha.  freebsd /bin/sh bug (or incompatibility) affecting ghc/configure
02:14:47 <allbery_b> hm, wait, except it found an installed ghc-pkg this time so maybe not a valid test
02:15:22 <bakert> ok, so forM [51,50..1] blah applies blah to each of those numbers, in order 51 down, and gives me the result as a list.  the reason it is forM not map is because their are monadic action effect thingys going on and because we wanted to flip the order of the arguments
02:15:49 <bakert> Next daft question.  What does the $ sign do (hard to Google!)
02:15:50 <benja_> bakert: yup
02:15:56 <glguy> > let blib g = snd $ mapAccumL f g [52,51..1] where f g n = let (x,g') = randomR (1,n) g in (g',x) in let shuffle = (snd .) . mapAccumL f where f deck x = let (a,b:bs) = splitAt (x-1) deck in (a++bs,b)  in shuffle [1..52] $ blib (mkStdGen 42) -- shuffled numbers 1 to 52
02:15:57 <lambdabot>  [40,41,18,20,49,29,5,31,32,10,26,45,48,3,24,52,34,15,51,17,47,44,19,50,12,7,...
02:16:07 <benja_> bakert: foo $ f x y = foo (f x y)
02:16:22 <benja_> so it does nothing, it's for saving parantheses :)
02:16:29 <allbery_b> in any case, looks like doing a build and install, then redoing the build/install with -DFORCE_PKG_REGISTER should result in a working ghc with readline on freebsd
02:16:38 <bakert> benja_, ah, i was trying to use "." for that yesterday -- i misremembered the tutorial!
02:16:39 <glguy> > map ($ 5) [succ, pred]
02:16:41 <lambdabot>  [6,4]
02:16:42 <benja_> associates to the right: foo $ f x $ g y = foo (f x (g y))
02:16:42 <dons> its a low precedence shorthand function, to avoid parenthesis
02:16:50 <dons> it just applies its arguments
02:16:54 <bakert> it's the anti-lisp
02:16:55 <bakert> !
02:17:01 <dons> > let f # x = f x in toUpper # 'x'
02:17:02 <lambdabot>  'X'
02:17:07 <dons> that's the idea :)
02:17:14 <glguy> > map ($ 5) [succ, pred] -- it also allows you to specify an argument that takes a function ;)
02:17:15 <lambdabot>  [6,4]
02:17:27 <dons> yeah, its an anti-lisp move
02:18:20 <glguy> > sequence [succ,pred] 5 -- but there are other ways to do that
02:18:21 <lambdabot>  [6,4]
02:20:50 <bakert> OK, so if you're still with me, I now understand everything apart from the lambda on the end of x <- forM [51,50..1] $ \ n -> randomRIO (1,n)
02:21:00 <bakert> that's \n -> randomRIO (1, n)
02:21:19 <bakert> so it says generate your own seed from the system clock or wherever and give me a number from 1 to n
02:21:31 <glguy> yeah
02:21:34 <bakert> cool
02:21:40 <bakert> So now I understand the whole thing!
02:21:43 <bakert> Brilliant!
02:22:13 <glguy> > flip runReader 5 $ mapM asks [(+1),(subtract 1)]
02:22:13 <dons> :)
02:22:14 <lambdabot>  [6,4]
02:22:21 <bakert> Took me a day or two, mind, but at least I got there!  Thanks so much dons, benja_, glguy
02:22:27 <glguy> yw
02:23:50 <bakert> OK, bonus question!  Why doesn't hugs like this code, only ghci?
02:24:16 <bakert> hugs says: ERROR "/home/bakert/haskell/smaller.hs":21 - Unresolved top-level overloading
02:24:24 <bakert> *** Binding             : forM
02:24:29 <bakert> *** Outstanding context : Monad b
02:24:37 <bakert> should i just skip hugs?
02:24:43 <bakert> is it "behind" ghci?
02:24:49 <dons> oh, that's interesting
02:24:55 <dons> it might be behind ghci, yeah
02:25:09 <allbery_b> hrrrm.  rebuilt / reinstalled ghc still lacks readline and still runs in raw mode.  yug
02:25:10 <glguy> > foldM (\a b -> ((a+b) +)) 0 [1,2,3,4] 3
02:25:12 <lambdabot>  22
02:25:13 <dons> i'd just straight to ghc if I were you, since you can compile code as well, and get more libraries
02:25:26 <bakert> yeah but hugs has a cuter name!
02:25:27 <benja_> does adding a type signature change anything
02:25:28 <benja_> ?
02:25:35 <dons> allbery_b: mm. someone else was complaining about readline on freebsd the other day
02:25:42 <glguy> > sum [1,2,3,4] + length [1,2,3,4] * 3
02:25:44 <lambdabot>  22
02:25:45 <allbery_b> yes, that's what I'm poking at
02:25:52 <glguy> > foldM (\a b -> ((a+b) +)) 0 [1,2,3,4] 5
02:25:53 <lambdabot>  30
02:25:58 <glguy> > sum [1,2,3,4] + length [1,2,3,4] * 5
02:25:59 <allbery_b> found a configure issue which may be a freebsd /bin/sh bug / compatibility
02:25:59 <lambdabot>  30
02:26:07 <allbery_b> but it doesn't seem to have changed anything
02:26:34 <bakert> benja_, were you talking to me about type signature?
02:27:49 <benja_> bakert: yes
02:27:57 <bakert> benja_, yes!  hugs understands it if i add a type signature.  but i cheated and did ":t forM" in ghci to get it!
02:27:57 <glguy> wow... it's way too late
02:28:00 <glguy> good night all
02:28:18 <bakert> glguy, good night.  thanks so much for your help really got me moving again.
02:28:27 <glguy> yw, again :)
02:28:30 * glguy &
02:28:34 <benja_> how about if you remove the signature, but change the line to,
02:28:41 <benja_> forM xs f = mapM f xs
02:28:42 <benja_> ?
02:29:50 <bakert> benja_, yeah that works too, though it's all greek to me!
02:29:58 <benja_> if that also works, then it looks to me like it's the monomorphism restriction at work
02:30:22 <benja_> which was explained to me yesterday :) like this:
02:30:42 <bakert> benja_, are type signatures to be avoided where possible?
02:30:51 <benja_> if a binding doesn't look like a function syntactically, then it's by default not polymorphic
02:31:08 <benja_> bakert: no, generally putting type signatures at least on the top level is good style :)
02:31:11 <allbery_b> if it has a type signature then the monomorphism resatriction shouln't apply
02:31:48 <benja_> putting in type signatures helps the compiler give more intelligible type errors
02:31:58 <benja_> as long as you get the type signature right, at least =)
02:32:18 * benja_ has occasionally been thrown for a bit by type errors caused by giving the wrong signature
02:32:44 <dons> yeah, me too
02:32:53 <dons> the compiler assumes you know what you're doing :)
02:33:05 <dons> when it should say: "hey, maybe youre type signature is wrong?"
02:33:31 <benja_> yeah =)
02:36:56 <allbery_b> hm.
02:37:17 * allbery_b wonders if the ports build plays games with the stage variable
02:39:06 <allbery_b> no, appears to be a stage1 build
02:39:11 <dons> ?uptime
02:39:37 <lambdabot> uptime: 16s, longest uptime: 9d 2h 23m 6s
02:39:52 <dons> ?quote kind
02:39:53 <lambdabot> lambdabot says: Couldn't match kind `?? -> ? -> *' against `(* -> *) -> * -> *'
02:40:21 <allbery_b> hm.  how does it distinguish user from pattern?
02:40:25 <dons> ?quote shapr Haskell
02:40:26 <lambdabot> shapr says: I think the Haskell approach works fine. That is, stick with research and do the best you can. Then after fifteen years of gestation, take over the world.
02:40:47 <dons> the syntax is: @quote nick | @quote pat | @quote nick pat | @quote
02:41:02 <dons> it'll try the nick first, then fall back to trying the string as a pattern, if you give it a single arg
02:41:14 <dons> if this turns out to be no good, i'll modify the syntax to disambiguate them
02:41:41 <dons> ?quote haskell
02:41:41 <lambdabot> gmh33 says: Haskell makes so much more sense now and all I did was figure out the typing thing
02:41:49 <dons> ?quote haskell.*makes
02:41:49 <lambdabot> JohnMeacham says: I liken learning haskell to tipping over a vending machine. you can't just push it, you gotta rock it back and forth a few times building up momentum until bam! suddenly the flash
02:41:50 <lambdabot> of insight hits and it all makes sense.
02:42:00 <dons> ah, but bad regexes will fail. should catch that:
02:42:03 <dons> ?quote *.*
02:42:03 <lambdabot> quote module failed: IRCRaised user error (Error in pattern: "*.*")
02:42:06 <dons> yeah
02:42:24 <dons> ?quote bam
02:42:24 <lambdabot> JohnMeacham says: I liken learning haskell to tipping over a vending machine. you can't just push it, you gotta rock it back and forth a few times building up momentum until bam! suddenly the flash
02:42:24 <lambdabot> of insight hits and it all makes sense.
02:42:24 <allbery_b> think I'd also have something like @quote - pattern
02:42:25 <benja_> @quote shapr lambda
02:42:26 <lambdabot> shapr says: I've toked on so many lambdas I'm getting dependent types
02:42:42 <dons> allbery_b: meaning it matches pattern for any user?
02:42:53 <dons> @quote shapr toke
02:42:53 <lambdabot> shapr says: I've toked on so many lambdas I'm getting dependent types
02:42:54 <allbery_b> yeh
02:43:01 <dons> which is just @quote pattern
02:43:07 <allbery_b> to override if you want a quote about something which is also a user
02:43:11 <benja_> @quote shapr man
02:43:12 <lambdabot> shapr says: I've toked on so many lambdas I'm getting dependent types
02:43:17 <dons> where pattern isn't a nick (we'll see how often that clashes)
02:43:29 <dons> you get to use extended regexes, ignoring case
02:43:37 <dons> @quote types$
02:43:37 <lambdabot> ghc says: In a RHS constructor application, con type doesn't match arg types
02:43:44 <dons> @quote ^In
02:43:45 <lambdabot> Failure02 says: in haskell you can have korean smilies as variables! like (^-^)
02:44:18 <dons> ?quote zzzzzzzzzzzzzzzz and an easter egg if yo ufail
02:44:18 <lambdabot> No quotes for this person. stty: unknown mode: doofus
02:44:19 <allbery_b> ghc was the case I waa thinking of, in fact :)
02:44:23 <jrockway> of course in perl6, that's a builtin operator :)
02:44:30 <dons> allbery_b: good idea
02:44:46 <dons> maybe I should just implement my first idea for /pat/ to delimit patterns
02:45:05 <dons> ?quote more easter eggs
02:45:05 <lambdabot> No quotes for this person. You type like i drive.
02:45:06 <dons> glguy: ^^
02:45:16 <allbery_b> heh
02:45:50 <dons> coding in haskell can be so satisfying
02:46:17 <dons> here's the core of this regex matching code:
02:46:18 <dons>     | P.null pat, Just qs <- mquotes = box . display key  =<< random qs
02:46:18 <dons>     | P.null pat                     = match key allquotes
02:46:18 <dons>     | Just qs <- mquotes             = match pat (zip (repeat key) qs)
02:46:18 <dons>     | otherwise                      = random insult
02:47:16 <dons> of course, considering its new years, and i'm eating chocolate and wine while coding haskell, those 4 lines took an hour to write :)
02:47:17 <norpan> random insult!
02:48:02 <jrockway> same random insults as openbsd spits out when you type your password wrong
02:48:08 <dons> yeah
02:48:10 <dons> ?version
02:48:11 <lambdabot> lambdabot 4p316, GHC 6.5 (OpenBSD i386)
02:48:11 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
02:48:15 <dons> ;)
02:48:25 <jrockway> i'm ircing from my openbsd machine :)
02:48:43 <dons> nice. me too!
02:48:49 <norpan> not me
02:49:27 <benja_> I'm ircing from an ubuntu machine or a debian machine, depending on your definition of 'ircing from' :)
02:49:51 * allbery_b is ircing from linux, indirectly from OSX, but hacking on fbsd :)
02:52:00 <norpan> windows/putty/linux/screen/irssi
02:55:23 <wolverian> ubuntu&debian here too. :) I wonder what kind of machines usually run on.
02:55:25 <benja_> (amb (ubuntu/ssh) (symbian/putty))/debian/screen/irssi
02:55:55 <benja_> ubuntu symbian ubuntu symbian ubuntu
02:56:06 <wolverian> er
02:56:19 <benja_> [^^ each of these words typed on the system it denotes =)]
02:56:24 <wolverian> s/usually/ircds usually/
02:56:24 <vegai> archlinux, archlinux, archlinux, os x:)
02:56:36 <vegai> one of those arches is a thin client to one of the others
02:56:45 <benja_> =)
02:59:10 <wolverian> benja_, now that's a party trick :)
03:00:09 <bakert> Stupid newbie question: how can I convert "32" to 32?  I did try google, honest!
03:00:40 <vegai> > read "32"::Int
03:00:43 <lambdabot>  32
03:01:02 <bakert> thanks
03:02:10 <dons> bakert: google or hoogle?
03:02:16 <dons> ?hoogle String -> a
03:02:17 <lambdabot> Prelude.error :: String -> a
03:02:17 <lambdabot> Debug.Trace.trace :: String -> a -> a
03:02:17 <lambdabot> Prelude.fail :: Monad m => String -> m a
03:02:22 <dons> ?hoogle+
03:02:22 <lambdabot> Prelude.read :: Read a => String -> a
03:02:22 <lambdabot> Text.Printf.printf :: PrintfType r => String -> r
03:02:22 <lambdabot> Control.Monad.Error.strMsg :: Error a => String -> a
03:02:30 <dons> ?where hoogle
03:02:31 <lambdabot> http://www.haskell.org/hoogle
03:02:33 <dons> :)
03:07:18 <bakert> Hoogle looks good.  Although I would have tried:
03:07:26 <bakert> ?hoggle String -> Int
03:07:26 <lambdabot> No matches, try a more general search
03:07:30 <bakert> ?hoogle String -> Int
03:07:30 <lambdabot> No matches, try a more general search
03:07:35 <bakert> ?hoogle String -> Num
03:07:35 <lambdabot> No matches, try a more general search
03:07:42 <allbery_b> heh
03:07:42 <bakert> So that shows you where I am at!
03:07:45 <dons> yeah, you need a more general search :)
03:07:56 <dons> replace some of the monomorphic types with type variables
03:08:08 <dons> ?hoogle Num a => String -> a
03:08:09 <lambdabot> Prelude.error :: String -> a
03:08:09 <lambdabot> Debug.Trace.trace :: String -> a -> a
03:08:09 <lambdabot> Prelude.fail :: Monad m => String -> m a
03:08:14 <dons> ?hoogle+
03:08:15 <lambdabot> Prelude.read :: Read a => String -> a
03:08:15 <lambdabot> Text.Printf.printf :: PrintfType r => String -> r
03:08:15 <lambdabot> Control.Monad.Error.strMsg :: Error a => String -> a
03:08:38 <allbery_b> the problem with hoogling read is that it's very polymorphic
03:08:41 <bakert> Yeah, I haven't really got my head around the type system yet as you can probably tell.
03:08:42 <allbery_b> ?ty read
03:08:44 <lambdabot> forall a. (Read a) => String -> a
03:09:03 <benja_> wish list for a future hoogle: understand type clases! be able to find 'show :: Read a => String -> a' for '@hoogle String -> Int'!
03:09:21 <allbery_b> I think something along those lines is planned for the next major release
03:09:27 <dons> I think hoogle 4 can do that, yeah
03:09:35 <bakert> Sounds good.
03:09:48 <bakert> For people who are floundering around like me, anyway!
03:10:53 <bakert> I've got another card-game-program related question if you're not exhausted.  I want to change my "main" into being a function I can call FROM main.  But the whole IO () monad stuff is confusing me.
03:11:37 <dons> just change main to 'code' or something, and then add main = code  :)
03:11:44 <bakert> !!!
03:12:30 <bakert> I don't want all of main, just most of it.
03:12:36 <bakert> I really want to be able to say:
03:12:47 <bakert> cards = newDeal 4
03:12:59 <bakert> So that 4 players get the right number of cards (in this case, 7)
03:13:11 <bakert> So newDeal will be most of my existing "main" code
03:13:32 <bakert> main = do
03:13:37 <benja_> you need newDeal :: Int -> IO [Cards]
03:13:39 <bakert>     x <- forM [51,50..1] $ \n -> randomRIO (1,n)
03:13:44 <bakert>     let shuffledCards = shuffle newDeck x
03:13:49 <benja_> if 'cards' is supposed to be a list
03:13:51 <bakert>     putStrLn $ show $ deal shuffledCards players 7
03:14:04 <bakert> so perhaps:
03:14:09 <bakert> newDeal players = do
03:14:15 <bakert>     x <- blah random stuff
03:14:24 <bakert>     let shuffledCards = shuffle newDeck x
03:14:35 <bakert>     deal shuffledCards players 7
03:14:39 <bakert> ...
03:14:55 <benja_> mhm
03:15:21 <Axioplase> does someone have a short example of coroutines with callCC ?
03:15:22 <benja_> and end with 'return shuffledCards' (or whatever you want the function to return :))
03:16:08 <bakert> return being a keyword used only to return from do sections?
03:16:40 <allbery_b> return is a function, actually
03:16:45 <benja_> nope, it's a function, but you don't need to worry about that before you start learning the internals of monads :)
03:16:48 <allbery_b> it means "wrap this value int he monad"
03:16:49 <benja_> @type return
03:16:50 <lambdabot> forall (m :: * -> *) a. (Monad m) => a -> m a
03:17:09 <bakert> ok
03:17:10 <allbery_b> if your result is already in the monad, it's unnecessary.
03:17:17 <bakert> i'm not sure!
03:18:31 <bakert> So if newDeal is:
03:18:32 <bakert> newDeal players = do
03:18:32 <bakert>     x <-  forM [51,50..1] $ \n -> randomRIO (1,n)
03:18:32 <bakert>     let shuffledCards = shuffle newDeck x
03:18:32 <bakert>     return (deal shuffledCards players 7)
03:18:56 <allbery_b> if the thing you're returning has type IO (something) then you don't need return
03:19:18 <bakert> i'm sorry to be thick, but how do i know that?
03:19:19 <allbery_b> (assuming (something) matches what your function is supposed to return)
03:19:31 <mr_tenor> i'm not big on the whole "using monads without understanding them" thing...  sounds like coding without undersatnding the semantics
03:19:34 <allbery_b> at worst, load itinto ghci and ask it the type (:t somefunction)
03:19:48 <bakert> the result of deal (which is what i am returning) is a list
03:19:57 <bakert> not an IO list or anything like that
03:20:00 * allbery_b tends to prefer typing everything beforehand, it's safer that way
03:20:03 <allbery_b> then you need return
03:20:08 <bakert> ok
03:20:29 <bakert> so the type of newDeal is: Int -> IO [a]
03:21:06 <bakert> which gives me:     "Couldn't match the rigid variable `a' against `[a1]'"
03:21:12 <bakert> so i guess it is wrong
03:21:16 <vegai> you could also make the shuffler a pure function, by giving the list of randoms as an infinite list
03:21:21 <allbery_b> @paste
03:21:21 <lambdabot> http://paste.lisp.org/new/haskell
03:21:51 <bakert> i think paste.lisp.org is having some kind of problem
03:22:02 <bakert> i tried it a minute ago too with the same result
03:22:15 <dons> ?where rafb-paste
03:22:16 <lambdabot> I know nothing about rafb-paste.
03:22:20 <dons> ?where rafb
03:22:21 <lambdabot> http://rafb.net/paste
03:22:38 <bakert> pastebin doesn't do haskell
03:22:40 <bakert> oh
03:22:41 <bakert> rafb
03:22:42 <bakert> ok
03:22:52 <allbery_b> rafb.net/paste, or sial.org/pbot, or pastebin.ca
03:23:13 <bakert> http://rafb.net/p/WSS4Kj97.html
03:23:15 <lambdabot> Title: Nopaste - Trying to make newDeal a separate routine not main
03:23:17 <allbery_b> use plain text if it doesn't do haskell; we'll survive without fancy color coding :)
03:23:38 <bakert> i can't live without syntax highlighting!  but just this once ...
03:23:54 <bakert> the "important" bit is the newDeal function and it's interaction with main
03:24:18 <allbery_b> deal returns [[a]], so newDeal needs to return the same thing or you need to otherwise make the types match
03:24:24 <bakert> i'd like it to be a function that returns a list like [[AC, JH, 9S, 2C], [AD, JD, KH, 4C]]
03:24:27 <allbery_b> [[a]] won't match [a]
03:24:31 <bakert> ah
03:24:33 <bakert> right
03:25:00 <allbery_b> (well, it could I guess, but not usefully for you)
03:25:17 <bakert> I think actually the type signature should be: newDeal :: Int -> IO [[Card]]
03:25:19 <bakert> does that make sense?
03:25:30 <allbery_b> yes
03:25:39 <bakert> ha ha!
03:25:40 <bakert> yes!
03:25:44 <bakert> then i need to do
03:25:53 <allbery_b> the unspecified type variable is probably being filled in automatically, but it's a bad practice
03:25:55 <bakert> x <- newDeal 4 to "unmonadize" the value
03:26:04 <allbery_b> and in some cases will lead to strangeness
03:26:07 <bakert> and then I can use it to my heart's content!
03:26:09 <allbery_b> right
03:26:12 <bakert> superb!
03:26:29 <bakert> although i am disturbed by my use of the word unmonadize ;)
03:26:41 * allbery_b usually says "unwrap"
03:26:51 <bakert> that is much better!
03:28:08 <bakert> i'm reallllly unclear as to why this wrapping and unwrapping is good.  i suppose the idea is to keep monad-related routines to a minimum and do most things in a pure way?  does it actually work like that in practice?
03:28:37 <allbery_b> in the case of IO, yes.  in the case of other monads, not necessarily
03:28:54 <allbery_b> for now that's probably the easiest way to think about it
03:28:59 <bakert> ok!
03:29:39 <bakert> is there a haskell "style guide"?
03:29:48 <benja_> imho, 'unwrapping' is a little confusing, actually, even though I've explained things like that too :)
03:30:05 <allbery_b> in the case of something like MonadError you use it to abstract away the automatic error handling code, so you can write more or less "normal" looking code and the monad framework deals with the error stuff
03:30:17 <bakert> i like unwrapping ... but i'll bear in mind that the analogy may break down.
03:30:18 <mr_tenor> happy new year all... i'm off
03:30:21 <bakert> bye
03:30:24 <bakert> hny
03:30:36 <allbery_b> there is no single good description that covers all monads; they're too general
03:31:29 <allbery_b> monads can be containers (like IO); they can be control structures (MonadError, ContT); they can be all sorts of things
03:31:41 <nornagon> dylan had a good explanation
03:31:49 <benja_> from the way monads are defined, it's a bit more precise to say that in (do x <- foo; ...), 'foo' controls the evaluation of '...' in a way that depends on the monad
03:31:57 <nornagon> http://hardison.net/warez/monads.txt
03:32:19 <benja_> for the IO monad, it's simply "foo does something and returns a value and then ... is executed using that value"
03:32:21 <bakert> i'm going to have a bath and think about how to do the actual playing of the game.  thanks for your help everybody.
03:32:33 <xerox> In that example <- binds the return value of the foo action to x.
03:32:48 <benja_> for the list monad, it's "... is evaluated for every element of foo"
03:33:37 <benja_> for the state monad, it's "foo is evaluated using the current state (possibly changing that state), then ... is evaluated with the result of foo (named x)"
03:34:12 <benja_> for the maybe monad, it's "foo is evaluated and if it's (Just something), then ... is evaluated (with x = the something)"
03:34:30 <benja_> ...and so on... :)
03:34:47 <allbery_b> for error monads it's "foo is evaluated with error handling, successful results are bound and then ... is evaluated, failures are passed up the chain"
03:35:05 <allbery_b> (Maybe is a trivial case thereof)
03:35:08 <benja_> yes
03:36:35 <benja_> > "A23456789TJQK" ! 5
03:36:37 <lambdabot>  Couldn't match `Array i e' against `[Char]'
03:36:44 <benja_> > "A23456789TJQK" !! 5
03:36:46 <lambdabot>  '6'
03:37:07 <benja_> bakert: (!!) provides a nicer way to write showRank
03:37:14 <allbery_b> a more useful error monad is Either String (something); failures can include error messages returned as Left, success is returned with Right result
03:37:34 <allbery_b> all handles more or less transparently
03:37:35 <vegai> hmm, couldn't there be a typeclass for !, which would provide an index-based getter for sequences?
03:37:39 <allbery_b> handled
03:37:49 <benja_> what's more useful depends on the kind of error in question =)
03:37:49 <vegai> indeed, perhaps the typeclass should be "Sequence"
03:37:52 <dons> > let x = "A23456789TJQK" ; arr = array (0,length x - 1) x in arr ! 5
03:37:54 <lambdabot>  Couldn't match `(Int, e)' against `Char'
03:38:01 <allbery_b> Sequence already exists with a meaning
03:38:09 <benja_> @hoogle Sequence
03:38:10 <lambdabot> Prelude.sequence :: Monad m => [m a] -> m [a]
03:38:10 <lambdabot> Prelude.sequence_ :: Monad m => [m a] -> m ()
03:38:10 <lambdabot> Language.Haskell.TH.Syntax.sequenceQ :: [Q a] -> Q [a]
03:38:19 <vegai> ohh..
03:38:23 <benja_> @index Sequence
03:38:24 <lambdabot> bzzt
03:38:39 <xerox> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Sequence.html
03:38:39 <benja_> allbery_b: where? :)
03:38:41 <lambdabot> http://tinyurl.com/yz86s7
03:38:46 <benja_> thanks!
03:38:49 <allbery_b> lambdabot's too old to know about Data.Sequence, perhaps
03:38:51 <xerox> You're welcome.
03:38:56 <xerox> ?docs Data.Sequence
03:38:56 <lambdabot> Data.Sequence not available
03:39:22 <benja_> (actually, only the package is called Sequence, the type is Seq)
03:39:27 <dons> ?bot
03:39:54 <lambdabot> :)
03:41:02 <allbery_b> hm, yes, would be nice if there were a superset of Ix and list/sequence
03:41:34 <allbery_b> (or List and Seq could be made to use Ix somehow, but I can see that bing difficult or slow)
03:43:08 <dons> ?quote amazi
03:43:08 <lambdabot> sorear says: Haskell is amazing. I'm still working on my infinite-types unifier, and in a day I've added sums, products, and lambda abstractions, refactored the code until there was a net *decrease*
03:43:08 <lambdabot> in LOC, and helped man #haskell all at the same time. This'd take me a week in C, no doubt.
03:47:26 <xerox> dons ah, ?quote greps the text?
03:47:39 <Templar2> is it possible to make an help function who "readFile" without using IO ()?
03:47:47 <dons> xerox: yeah
03:47:48 <xerox> Also, does ?remember work? I've seen it in the disabled commands.
03:48:00 <dons> ?quote ^Hask
03:48:00 <lambdabot> SamB says: Haskell is the only language I know with first-class support for imperative programming
03:48:09 <dons> remembe rworks
03:48:17 <xerox> OK cool :)
03:48:21 <allbery_b> the darcs tree has a number of things disabled thatthe live one has turned on
03:48:49 <allbery_b> presumably as protection against someone accidentally pointing their own lambabot at #haskell
03:49:18 <dons> that, and that it can be used as a lambdabot web interface (so unsafe things are disabled by default)
03:49:52 <allbery_b> hm, point
03:50:34 <allbery_b> templar2: no.
03:50:51 <dons> you know the openbsd song: Crackin' ze boardroom, Crackin' ze vault Rippin' ze bat, HEY! Secure by default
03:50:55 <dons> that's the idea anyway :)
03:50:55 <allbery_b> (well, "yes, but that's very risky and should not be attempted")
03:52:26 <benja_> hmm, finger trees (Data.Sequence) seem nice
03:53:04 <benja_> even though I'm not good enough with these things to find the paper easy to read :-)
03:54:18 <allbery_b> well, it could be IO String or etc., but you want to stay in IO
03:55:28 <allbery_b> otherwise we can take no responsibility if your computer decides to rape the printer or start binge-consing or something :)
03:56:24 <augustss> benja_: finger trees is a good data structure if you need those kind of operations
03:59:06 <opqdonut> binge consing :DDD
03:59:24 <benja_> well, I've reversed a few lists in my time because I wanted to snoc on the end :)
04:01:12 <benja_> of course, Haskell still won't let me say f ("<http://" ++ xs ++ ">") = xs
04:01:53 <allbery_b> it's you vs. the folks who think n+k patterns are evil incarnate
04:02:01 <benja_> :)
04:02:27 <Syzygy-> ?hoogle snoc
04:02:28 <lambdabot> No matches found
04:02:41 <allbery_b> ?index snoc
04:02:42 <lambdabot> bzzt
04:02:44 <allbery_b> hm
04:03:07 <allbery_b> oh wait, right, hoogle doesn't know Seq
04:03:47 <allbery_b> (Data.Sequence.snoc "conses" onto the right of a Seq, IIRC)
04:04:30 <Syzygy-> Ah.
04:05:17 <Syzygy-> grmbl. Can't find snoc even after doing :m + Data.Sequence
04:05:58 <allbery_b> no, Seq can do that but it;s called (|>)
04:06:45 <benja_> hm, the paper seems to consider only bottom-up properties (computed from the leaves), no top-down properties other than order (i.e., properties which can be applied in logarithmic time to a whole subtree)
04:08:03 <dons> benja_: just for you (and to see how verbose it would be) :
04:08:06 <dons> extract s | Just [xs] <- match (regex "^<http://([^>].*)>$") s = xs
04:08:20 <dons> *Main> extract "<http://www.google.com>"
04:08:20 <dons> "www.google.com"
04:08:21 <xerox> Syzygy-: cons: (<|), snoc: (|>)
04:08:37 <benja_> dons: :)
04:09:23 * allbery_b could actually see a subset of that syntax for pattern matching:  f ("http://":xs) as a shorthand for f ('h':'t'':...)
04:09:41 <dons> yeah, there is a proper pattern /regex preprocessor for haskell, HARP
04:09:43 <allbery_b> (++) is right out, though :)
04:09:53 <dons> where you can use full regexes in patterns, on arbitrary lists
04:10:06 <benja_> allbery_b: that won't work, ("http://":xs) already has meaning
04:10:14 <dons> see nibro's paper on harp
04:10:15 <benja_> it matches something of type [String]
04:10:23 <allbery_b> oh, already does what I'd like?  wish I'd known that...
04:10:46 <allbery_b> (shoulda known)
04:10:48 <dons> its a preprocessor, so if you use the regex syntax, you need to add -pgmP harp, iirc
04:11:02 <dons> aka macros for haskell ;)
04:28:34 <allbery_b> still poking at fbsd build.  it does look like the right stuff is being found but somehow isn't actually being added to SRC_HC_OPTS
04:30:48 <hyrax42> what is that syntax
04:31:01 <allbery_b> which syntax?
04:31:06 <hyrax42> extract s | Just [xs] <- ...
04:31:13 <hyrax42> how is that guard working
04:31:13 <dons> ah, that's a pattern guard
04:31:28 <hyrax42> if it matches, it's like True?
04:31:35 <dons> so like a normal guard, but <- is sugar for a case on the rhs, which matches
04:31:36 <allbery_b> <- in pattern guards threw me, but I think I grok it
04:31:48 <dons> i use them all the time for testing maybe values
04:32:22 <hyrax42> so semantics are
04:32:23 <allbery_b> has an unfortunate resemblance to do notation, especially when used with a monadic type :)
04:32:45 <hyrax42> extract s = case <blah blah matgch blah> of Just [xs] -> xs
04:32:46 <hyrax42> ?
04:32:50 <dons> yeah
04:32:57 <dons> Nothing -> fail
04:33:00 <allbery_b> although I suppose Just woudln't occur there in do on Maybe
04:33:05 <hyrax42> can you have multiple patter guards?
04:33:11 <dons> yeah, and combine them with ,
04:33:29 <dons> f x | Just z <- g, (True,False) <- bar = True
04:33:54 <dons> so we can almost do views on bytestrings this way
04:33:55 <hyrax42> is this h98?
04:33:59 <dons> using the string literal patch for bytestrings to ghc
04:34:33 <dons> isPrefixOf s | "foo"<- take 3 s = True
04:34:51 <dons> hyrax42: nope, ghc extensions (to be in haskell')
04:35:00 <hyrax42> wait what is the sematics of that ?
04:35:05 <hyrax42> the f x | one
04:35:17 <hyrax42> both must match?
04:35:22 <dons> yeah, like &&
04:36:28 <dons> here, http://research.microsoft.com/Users/simonpj/Haskell/guards.html
04:36:41 <dons> also, http://research.microsoft.com/~simonpj/Papers/pat.htm
04:36:42 <lambdabot> Title: Simon Peyton Jones: papers
05:02:38 <allbery_b> hrm.  I was correct the first time, it appears.  the bogus failure of the ghc/configure readline test is causing GhcHasReadline to be set false
05:02:55 <dons> ah good
05:02:57 <allbery_b> and it didn't regenerate the appropriate files when I manually reran :(
05:03:34 <allbery_b> the problem remains that the test itself looked slightly wonky, as if you had to have a ghc with readline support already installed for it to pass, resulting in a bootstrapping issue
05:04:10 <allbery_b> (which would only affect ports or ports-like infrastructures, I think --- but then one should also see it with gentoo and macports)
05:04:54 * allbery_b would not be surprised if it were fixed in 6.6, but 6.6 isn't in fbsd ports...
05:05:44 <dons> ah yes, i seem to remember at least one recent patch to affect readline
05:06:54 <dons> ?time dons
05:06:57 <lambdabot> Local time for dons is Mon Jan  1 00:00:14 2007
05:07:00 <dons> happy new year, #haskell!
05:07:03 <opqdonut> hehe
05:07:09 <allbery_b> the test in ghc/configure runs ghc-pkg to find out if readline is supported.  if there's no installed ghc-pkg yet, it runs the empty string, which is an error (either explicitly reported as such, or tries to feed the current directory to sh as a script)
05:07:11 <opqdonut> ?time opqdonut
05:07:15 <lambdabot> Local time for opqdonut is Sun Dec 31 14:59:43 2006
05:07:16 <opqdonut> not here yet :(
05:07:22 <allbery_b> ?time allbery_b
05:07:24 <lambdabot> Local time for allbery_b is Sun Dec 31 08:00:42
05:07:27 * dons sees the fireworks going off
05:07:51 <dons> mm, apparently sydney is the 'emerald city' this year, (capital of Oz, I guess :)
05:07:57 <Syzygy-> Happy new year, dons!
05:08:39 * dons cracks open a bottle of bubbly lambdas
05:10:14 <allbery_b> aha!
05:10:38 <allbery_b> the *bootstrap* ghc lacks ghc-pkg.
05:10:52 <norpan> already?
05:10:53 <allbery_b> I bet portage and macports bootstraps both have it
05:10:54 <norpan> wow
05:11:11 <therp> can someone please kick dons so that he has to go out and have new year fun :) ?
05:11:17 <allbery_b> heh
05:11:46 <norpan> i was in sydney once on new year's eve
05:12:08 <norpan> 1994
05:15:16 <therp> I guess I will code haskell until 6pm, have a shower and then go to some strange really big goa party in .at :)
05:16:02 * allbery_b creates hacky patch to override ghc/configure and tests
05:17:32 <dons> mmm. big fireworks this year. still going ...
05:18:41 <nornagon> aren't
05:18:43 <nornagon> ;P
05:18:51 <nornagon> happy new year, dons
05:19:05 <therp> downsizing is no option in a world with a growth-rate fetish :)
05:19:12 <_matthew_> now, about hs-plugins... ;)
05:19:18 <dons> hah!
05:19:21 <allbery_b> :p
05:19:46 <dons> hey, i was pretty happy to get in a lambdabot patch after half a bottle of wine tonight. that'll do I think ;)
05:20:00 <_matthew_> what, with the drinking or the coding?!
05:20:02 <_matthew_> ;p
05:20:07 <nornagon> oh, a second volley.
05:20:12 * dmhouse writes his first ever Makefile :)
05:20:51 <dons> happy new year's nornagon :)
05:21:01 <dons> ?time nornagon
05:21:02 <lambdabot> Local time for nornagon is Mon Jan  1 00:14:20 2007
05:21:05 * allbery_b won't know for a while if this fixes it
05:21:21 <nornagon> dons: i am a good five minutes' walk from you ;P
05:21:31 <dons> :)
05:22:23 <hyrax42> dons, sorry about that... had to go, and have to go agian
05:25:20 <allbery_b> yay, -package readline -DUSE_READLINE
05:25:22 <Igloo> http://gravityboy.livejournal.com/31930.html
05:25:23 <lambdabot> Title: gravityboy: Communities
05:26:15 <dons> Igloo: yeah, interesting.
05:29:11 <dons> also, by the same guy (I think), "I spent several weeks playing with haskell recently. I enjoyed it a lot, and the community is fantastic (#haskell is the dream channel) but I definitely struggled when it came to monads"
05:29:15 <dons> http://programming.reddit.com/info/wg2y/comments/cwgrc
05:29:17 <lambdabot> Title: Monads (reddit.com)
05:29:27 <dons> heay bakert
05:31:27 <andrew_p> hi! happy new year!
05:32:09 <bakert> happy new year all.  i've got a vaguely stylistic kind of a question.
05:32:30 <robreim> Happy new year to those in it!
05:32:43 <bakert> in the two or three erlang programs i've written i create a -record and pass around the state as a parameter to most every function
05:32:52 <bakert> is that the haskell way of doing things, too?
05:33:04 <dons> we'd use a monad if the state was being passed a lot
05:33:06 <andrew_p> removeFst m (x:xs) | m == x = xs
05:33:06 <andrew_p>                    | otherwise = (x) : (removeFst m xs)
05:33:10 <opqdonut> that can usually be averted with the state monad
05:33:43 <bakert> damnit ... why does everything i want to do end up being about monads?  (another question is it monad like mono or monad like moan-add?)
05:33:52 <andrew_p> i'm yet another haskell beginner (c) and can't get one thing. imagine such function removeFst as above
05:33:54 <bakert> i guess i am going to have to take these babies on
05:34:07 <dons> > flip runState 7 {- run some code with an implicit state -} $ do x <- get ; let y = x ^ 3 ; put (y*2) ; return "done"
05:34:08 <lambdabot>  Parse error
05:34:17 <dons> > flip runState 7 {- run some code with an implicit state -} $ do x <- get ; let y = x ^ 3 in put (y*2) ; return "done"
05:34:19 <lambdabot>  ("done",686)
05:34:33 <dons> you can of course put your state in a record, and thread it
05:34:48 <dons> but if you do that often enough, a nice pure State monad is a bit easier
05:34:53 <andrew_p> it compiles well, but if i try to execure it like "removeFst 1 1 2 3 4", ghc argues on the number of arguments.. how should i make it treat 1 2 3 4 as a list?
05:35:10 <dons> just using runState to fork off the stateful code, and get(s)/modify/put to access the state
05:35:20 <opqdonut> andrew_p: easy answer: removeFst 1 [1,2,3,4]
05:35:39 <andrew_p> opqdonut: ah, many thanks!
05:35:43 <opqdonut> np :)
05:35:45 <allbery_b> "monad" like "nomad"
05:35:57 <dons> > let removeFst m (x:xs) | m == x = xs | otherwise = x : removeFst m xs in removeFirst 2 [1..10]
05:35:58 <lambdabot>  Not in scope: `removeFirst'
05:36:03 <dons> > let removeFst m (x:xs) | m == x = xs | otherwise = x : removeFst m xs in removeFst 2 [1..10]
05:36:05 <lambdabot>  [1,3,4,5,6,7,8,9,10]
05:36:33 <allbery_b> mail sent
05:37:23 <dmhouse> allbery_b: that's such a better name than 'comonads'.
05:37:33 <dons> heh
05:38:09 <andrew_p> great, i has another attempt to learn haskell half an year ago, but adandoned that :( now, you see, even list syntax confused me :)
05:38:14 <dons> allbery_b: its a ghc patch? shoudl that not go to glasgow-haskell-bugs@haskell.org?
05:38:23 <dons> andrew_p: its ok :) welcome back!
05:38:33 <dons> > map (^2) [1,3,4,5,6,7,8,9,10]
05:38:35 <lambdabot>  [1,9,16,25,36,49,64,81,100]
05:38:36 <allbery_b> it patches ghc, but not properly
05:38:56 <allbery_b> it's just a quick hack to work around freebsd using an incomplete bootstrap ghc
05:39:09 <allbery_b> arguably this is not a ghc issue, but a freebsd issue
05:39:38 <dmhouse> > map (join (*)) [1..10] -- Sorry, couldn't resist.
05:39:39 <lambdabot>  [1,4,9,16,25,36,49,64,81,100]
05:39:52 <allbery_b> (specifically, the bootstrap ghc package is missing ghc-pkg, so ghc/configure bombs the readline check)
05:40:33 <allbery_b> and since it only builds stage1, it doesn't self-correct (the stage2/stage3 builds use the library configuration)
05:40:43 <Igloo> She was a bit confused about having a collar measurement but no shirt ordered, or something
05:40:46 <Igloo> Ooops
05:41:23 <wolverian> please tell us more about the collar and the girl..
05:41:32 <andrew_p> "The Haskell Road To Logic, Math And Programming" book is great, he-he...
05:41:33 <allbery_b> heh
05:43:54 <dons> hehe, "New York + PHP = No Talent?" on reddit
05:45:37 <bakert> isn't the issue with PHP + Talent that people with talent have moved on from PHP?
05:45:45 <bakert> if they were ever there.
05:46:11 <dons> yeah, I think that's the issue :)
05:46:17 <bakert> overstating the case somewhat, PHP is legacy
05:46:41 <dons> its like the bizzaro world to haskell, where the phds outnumber the jobs 10:1 ;)
05:47:29 <bakert> i told my boss i was going to write my next program in haskell.  he seemed fairly enthusiatic.  need to get good at it by the day after tomorrow!
05:47:38 <dons> cool!
05:47:47 <bakert> (he spent most of the last week before christmas writing a javascript parser in haskell, so he's a fan)
05:48:04 <dons> be sure to lean on the irc channel and the haskell-cafe@ if you need help
05:48:10 <dons> that' good to know
05:48:14 <dons> using parsec or something?
05:48:48 <bakert> i don't know what he used.  i looked over his shoulder and it all looked like jibberish ... apart from the javascript keywords ... so i decided to learn haskell!
05:49:51 <bakert> it is boggling my mind a little.  i thought erlang error messages were hard to decipher ...
05:50:37 <bakert> i have to go buy some Sunday papers to get the "quiz of the year" and that kind of stuff.  but i will be back to ask you all your design ideas for my card game program shortly ... !
05:58:46 <andrew_p> how would write a function that gives the maximum of a list of integers efficiently? this one:
05:58:46 <andrew_p> maxInt [x] = x
05:58:46 <andrew_p> maxInt (x:xs) = max x (maxInt xs)
05:58:46 <andrew_p> called as maxInt [0..] does not work because of a stack overflow :) however, maxInt [2147483640..] yields a result - 2147483647
06:00:21 <integral> why not use Prelude.maximum?
06:01:00 <allbery_b> > foldr1 (\l r -> if l > r then l else r) [1..10000]
06:01:01 <lambdabot>  10000
06:01:13 <Igloo> What are you using that gives -2147483647 as the result?
06:01:37 <allbery_b> the space makes me thing the - is just a separator (I'd use a colon but YMMV)
06:01:55 <Igloo> Ah, OK  :-)
06:02:24 <andrew_p> ibid: yes :)
06:02:43 <Igloo> You want foldl', not foldr, anyway. foldr will also have a stack overflow
06:03:02 <andrew_p> it does
06:03:12 <Igloo> Or, if you want to write it explicitly,  maxInt (x:y:xs) = maxInt ((x `max` y):xs) instead of the second line above
06:03:16 <allbery_b> is there a strict foldl1?  I was trying to avoid using the largest negative int as a seed
06:03:19 <Igloo> i.e. start at the left rather than the right
06:03:22 <andrew_p> ok, thanks a lot! i did not learn folding yet, though
06:03:56 <joelr1> good day
06:04:18 <Igloo> There's a Data.List.foldl1', yes
06:04:40 <allbery_b> > foldl1' (\l r -> if l > r then l else r) [1..100000]
06:04:41 <lambdabot>  100000
06:05:11 <Igloo> > foldl1' max [1..100000]
06:05:12 <lambdabot>  100000
06:05:38 <allbery_b> sure, but I figured it was tutelary, should avoid using too many prelude functions
06:06:00 <nornagon> > foldl1' max [10,9,..]
06:06:00 <lambdabot>  Parse error
06:06:05 <allbery_b> (if the point is to write max, you shouldn't assume it)
06:06:06 <Igloo> Well, he used max in the original function, so I figure that one's OK  :-)
06:06:13 <nornagon> > foldl1' max [10,9..]
06:06:17 <lambdabot> Terminated
06:06:26 <Igloo> But showing the lambda as well might make it clearer how it works
06:06:29 <nornagon> dang.
06:06:43 <nornagon> not lazy enough >.>
06:07:16 <_matthew_> nornagon: well, that or it doesn't understand least upper bounds
06:07:26 * allbery_b suspects it takes a while to run through the whole (or even half :> ) range of Ints :> (and worse if it inferred Integer...)
06:07:56 <Saizan> how can it terminate if it doesn't know that the list is in decresing order?
06:08:04 <allbery_b> it does
06:08:25 <Saizan> foldl1' and max doesn't :)
06:08:38 <allbery_b> oh, sorry
06:08:39 <Saizan> s/doesn't/don't
06:08:52 <norpan> maximum = head?
06:09:01 <_matthew_> is there a class defining .. ? can you define other instances of it?
06:09:12 <allbery_b> Enum
06:09:28 <andrew_p> foldl1 eats all system resources when called on infinite increasing lists :) even foldl1 (\l r -> if l > r then l else r) [2000000000..] is too resource-hungry
06:09:30 <_matthew_> ahh.
06:09:44 <allbery_b> actually, .. itself is syntactic sugar built into the compiler, but it expands to enumFromThen or enumFromThenTo as appropriate
06:10:51 <allbery_b> or enumFrom or enumFromTo
06:10:57 <_matthew_> right.
06:11:25 <_matthew_> I wonder whether in finite fields, you would expect .. to cycle round.
06:11:32 <_matthew_> I don't know the maths well enough...
06:11:55 <Igloo> andrew_p: You need foldl1' (note the ')
06:12:25 <andrew_p> Igloo: ah, ok.. will try
06:12:27 <andrew_p> can i try something like maxInt (x:xs) = map max [x | x <- [0,2..], y | y <- [1,3..]] ? what is the correct syntax?
06:12:36 <allbery_b> the ' versions of folds are strict, i.e. immediately reduce everything instead of stacking it
06:16:10 <nornagon> andrew_p: map max [(x,y) | x <- [0,2..], y <- [1,3..]]
06:16:16 <nornagon> but that won't work
06:16:22 <nornagon> because max doesn't take tuples
06:16:25 <nornagon> afaik
06:16:44 <integral> nornagon: but (uncurry max) does :-)
06:16:54 <nornagon> :)
06:17:00 <integral> but [ max x y | ... ] would be simpler :-)
06:17:08 <integral> no need to map when you've already got a list comprehension
06:17:14 <joelr1> has anyone looked at Glasgow Distributed Haskell?
06:17:25 <nornagon> i'm a haskell newbie :)
06:20:36 <andrew_p> integral, normagon: thanks...
06:29:06 <Vq^> hej psi
06:31:09 <bakert> So, I'm writing this card game in haskell.  It's called "Kings to Aces" and it's basically Rummy.  So I could define a state record comprised of discard pile, remaining pack, hand (for each player) and cards on table (for each player).  And then pass that around.  How would I do that?  Is there something similar to erlang's record?
06:31:15 <benja_> can somebody explain how to use gtk2hs file dialogs?
06:31:46 <benja_> bakert: depends on the kind of ui you're planning to use, probably
06:32:03 <Botje> bakert: yes, haskell has records too
06:32:20 <benja_> one way would be to use iorefs
06:32:21 <allbery_b> data Record = R { fieldA :: Int, fieldB :: String }
06:32:37 <benja_> -- oh, were you asking about how to make a record? I though about how to pass it around
06:32:37 <bakert> Just a command line program (at the moment, anyway).  I want to implement little game playing bots to work out the best strategy so i can beat my mother-in-law.
06:32:54 <allbery_b> then you can use gets fieldA to pull fieldA from the record in the state
06:33:04 <allbery_b> (updating is a bit harder, sadly)
06:33:04 <bakert> Is that Record there just any arbitrary name?
06:33:08 <norpan> i wrote a card game in haskell once: http://norpan.org/fluxx/
06:33:13 <lambdabot> Title: Index of /fluxx
06:33:13 <allbery_b> yes, any valid typename
06:33:21 <bakert> norpan, great - code to nick!
06:33:22 <benja_> bakert: if you have only one state which you modify imperatively, you could use the state monad
06:33:33 <AStorm> Why are mailers still stupid about sending tabs? :P
06:33:34 <benja_> in any case, you can always just pass around the state explicitly
06:33:45 <AStorm> (and terminals about copying them)
06:33:46 <benja_> (the state monad makes that implicit)
06:34:33 <bakert> So the State Monad is the One True Way(tm) that I'd do if I knew all there was to know about Haskell, or just an option?  I don't want to detour into yet more learning unless it is core learning, if you know what I mean!
06:34:51 <benja_> just an option
06:34:54 <bakert> ok
06:35:07 <norpan> look at Fluxx.hs
06:35:14 <benja_> basically, if passing around the state explicitly would be ugly :)
06:35:14 <allbery_b> State is the simplest way.  StateT is the same thing but layerable; Reader is a more complex (and featureful) way; etc.
06:35:15 <norpan> type GameM a = ErrorT E (StateT GameState IO) a
06:35:21 <benja_> where you are the judge of what is ugly :)
06:36:09 <andrew_p> my little success: http://paste.lisp.org/display/33769 :)
06:36:14 <norpan> the doTurn function is one messed up function
06:36:30 <allbery_b> fluxx is one messed up card game :p
06:36:36 <bakert> i was just looking at doTurn
06:37:02 <bakert> i don't think i can understand that much haskell at once at the moment though!  i am still spoon feeding.
06:37:13 <norpan> yeah, don't overdose it
06:37:25 <opqdonut> OD
06:38:34 <norpan> x=x+1 makes the code twice the size or something :)
06:38:56 <Baughn> First hit for "haskell overdose" is... "haskell drug rehab". I'm shocked, shocked.
06:39:03 <opqdonut> :D
06:39:42 <psi> Vq^, tjena
06:42:21 <bakert> ok ... code is getting too big I have to learn about Modules.
06:42:58 <bakert> Are there any naming/directory conventions?
06:43:07 <bakert> plurals or singular for card/cards?
06:43:11 <bakert> (for example).
06:43:47 <allbery_b> usually singular, since [Card] implies plural
06:44:01 <bakert> I mean for my module name
06:44:27 <bakert> have named the types/type classes/whatever they ares as singular
06:44:30 <allbery_b> usually you name the module after the primary type defined in it
06:44:35 <bakert> cool
06:44:54 <allbery_b> (see for example the ghc library hierarchy)
06:44:56 <bakert> so Card.hs containing module Card which defines type Card and it's supporting types and functions.
06:45:03 <allbery_b> yep
06:45:44 <allbery_b> ...if you wanted to split out the operation on lists of cards (or Seqs if using ghc6.6) you might have a Cards.hs
06:45:47 <bakert> allbery_b, where's the best place to see the ghc library hierarchy.  my google searches keep taking me to that ZVON site that i can't quite get to grips with
06:45:59 <bakert> allbery_b, ah i see ... good thinking
06:46:20 <allbery_b> http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
06:46:44 <bakert> thanks
06:46:53 <bakert> that's cool
06:47:04 <allbery_b> (more simply, www.haskell.org, then Standard Libraries
06:47:11 <xerox> Even more simply...
06:47:15 <xerox> ?docs Data.Tree
06:47:15 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Tree.html
06:47:19 <xerox> ?source Data.Tree
06:47:19 <lambdabot> http://darcs.haskell.org/packages/base/Data/Tree.hs
06:47:31 <allbery_b> sure, but that doesn't work so well for browsing
06:47:43 <allbery_b> i.e. starting at the top level to see what exists
06:47:52 <allbery_b> hm, or does it?
06:47:53 <allbery_b> ?docs
06:47:54 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
06:47:57 <allbery_b> ha
06:47:58 <xerox> Check the links in the upper right.
06:48:14 <xerox> Yeah, I've added that index link somewhere in the past :)
06:48:40 <allbery_b> ?source
06:48:40 <lambdabot>  not available
06:48:43 <allbery_b> heh
06:49:14 <xerox> Add it! (:
06:49:44 * allbery_b was saddened to note while going through the ghc source that sparc is apparently not really supported ("bitrotted")
06:50:13 <allbery_b> of course that was 6.4.2, maybe 6.6 brought it back
06:50:24 <bakert> Should the filename for a module be capitalised like the module name itself, or lowercase?
06:50:36 <allbery_b> the convention is capitalized
06:50:42 <bakert> ta
06:50:58 <Igloo> Case needs to match for the compiler to be able to find it
06:51:50 <allbery_b> hm, right, if you do import Foo it looks for Foo.hi
06:52:09 <allbery_b> (although it'd probably work with any case on windows or default OSX)
07:04:01 <bakert> Cool.  I am all modularised - Main, Card, Utils, Shuffle.
07:04:20 <xerox> Now make a darcs repo! (:
07:04:20 <bakert> Now back to the records.
07:04:28 <bakert> not a bad idea
07:04:40 <xerox> There's a page on the wiki that explains the process, is quite easy.
07:04:43 <bakert> darcs i can cope with because i already use that at work -- no new work!
07:05:02 <xerox> ?gwiki how to write an haskell program
07:05:03 <lambdabot> No Result Found.
07:05:10 <xerox> ?wiki How to write an haskell program
07:05:11 <lambdabot> http://www.haskell.org/haskellwiki/How to write an haskell program
07:05:18 <xerox> ?wiki How_to_write_an_haskell_program
07:05:18 <lambdabot> http://www.haskell.org/haskellwiki/How_to_write_an_haskell_program
07:05:26 <xerox> hmmm
07:05:31 <xerox> ?go how to write an haskell program
07:05:33 <lambdabot> http://haskell.org/haskellwiki/How_to_write_a_Haskell_program
07:05:33 <lambdabot> Title: How to write a Haskell program - HaskellWiki
07:05:43 <xerox> Here it is.
07:05:47 <bakert> Should it be "an" Haskell?  Isn't that supercompensation or whatever they call it.
07:06:55 <bakert> ah yes ... i read this doc the other day ... very helpful.  of course i had forgotten about it already so while my test program of about 6 lines has a build system, my actual program doesn't!
07:07:02 <bakert> i shall remedy the situation!
07:07:38 <bakert> (only thing i find about darcs is that it is just slightly trickier than i'd like to diff with old versions -- i'd like changesets to have a number as well as a name)
07:08:35 <bakert> What's a .hi file?
07:08:39 <Botje> @pl \x -> (show x) == (reverse $ show x)
07:08:40 <lambdabot> liftM2 (==) show (reverse . show)
07:08:47 <bakert> I seem to have created one at some point.
07:08:56 <Botje> wow.
07:09:16 <Botje> bakert: it's a compiled .hs file, afaik
07:09:21 <Botje> you can remove it without harm
07:10:31 <andrew_p> does prelude have a function that takes a char ch and an integer n and returns a string which is ch repeated n times?
07:11:34 <Botje> @type repeat
07:11:35 <lambdabot> forall a. a -> [a]
07:11:39 <Botje> @type replicate
07:11:40 <lambdabot> forall a. Int -> a -> [a]
07:11:42 <Botje> that one
07:11:43 <Botje> replicate
07:11:49 <andrew_p> thanks, Botje!
07:11:59 <pejo> allbery_b, there's still no (fixed) support for sparc in the NCG as of 6.6 afaik. Unfortunately.
07:13:07 <xerox> bakert: don't they have a unique id?
07:14:10 <Botje> j
07:14:23 <Botje> which module do I have to load to use the ((->) e) monad?
07:14:37 <Botje> @instance (Monad ((->) e)
07:14:38 <lambdabot> Maybe you meant: instances instances-importing
07:14:40 <norpan> Control.Monad.Reader
07:14:40 <xerox> Control.Monad.Reader
07:14:43 <Botje> ah
07:14:43 <Botje> thanks
07:15:03 <norpan> that's one freaky monad
07:15:28 <Botje> I finally grokked the concept behind it :)
07:17:29 <norpan> well it's not hard really
07:22:00 <bakert> xerox, i don't think so ... you have to regex search on the name if i remember correctly.
07:22:04 <bakert> a bit painful
07:22:15 <xerox> Sorry?
07:22:24 <xerox> Ah.
07:25:29 <xerox> bakert - try darcs changes --xml-output
07:27:11 <dmhouse> Hrm. How does one create a ByteString from a String?
07:27:20 <dmhouse> I thought it was pack but that appears to want a [Word8] as its input.
07:28:11 <dmhouse> ?hoogle String -> ByteString
07:28:11 <lambdabot> No matches, try a more general search
07:28:45 <velco>  > ByteString.pack . map (fromIntegral . fromEnum)
07:29:32 <bakert> That page:
07:29:33 <bakert> http://haskell.org/haskellwiki/How_to_write_a_Haskell_program
07:29:34 <lambdabot> Title: How to write a Haskell program - HaskellWiki
07:29:36 <bakert> Is really good
07:29:50 <syntaxfree> oh boy. programming.reddit.com is getting Linux fanboys stories.
07:30:17 <syntaxfree> Linux fanboy =  Microsoft-bashing. *sigh*
07:30:38 <velco> so undeserved ...
07:30:50 <xerox> bakert - You see that every patch has an hash signature?
07:30:55 <johnnowak> we need a rereddit to cherry pick the best cherry picks...
07:31:24 <syntaxfree> we need to retreat to a new site without the lame people.
07:31:33 <syntaxfree> and then retreat again when they get there.
07:31:46 <johnnowak> maybe just erect a proper wall next time?
07:32:08 <syntaxfree> Like a CS test before you can get a login?
07:32:10 <dmhouse> Perhaps I want Data.ByteString.Char8.
07:32:13 <syntaxfree> Hahaha.
07:32:59 <johnnowak> syntaxfree: skip the user login system... just use captchas with questions about monads.
07:33:10 <syntaxfree> :)
07:33:16 <syntaxfree> Blogger disgusted by Digg--blocks traffic! (tomayko.com) <-- not programming.
07:33:20 <bakert> xerox, you mean that "0a1,50" thing?  that's worse than having to refer to it by name!
07:33:30 <syntaxfree> Our Interview with Jeremy Allison - On Novell. Microsoft, and GPLv2 (boycottnovell.com) <-- not programming
07:33:32 <syntaxfree> etc. etc.
07:33:32 <xerox> bakert: nope.
07:33:34 <johnnowak> syntaxfree: what other sites do you recommend?
07:33:58 <syntaxfree> dunno. LtU is a bit heavier on the academic side, and it should remain like that.
07:33:59 <johnnowak> as many times as i click refresh, lambda the ultimate hasn't gotten a new article in what seems like weeks
07:34:07 <syntaxfree> I wouldn't like to see the Reddit exodus flooding out LtU.
07:34:37 <syntaxfree> maybe people just need to be very militant about voting bad stories down.
07:34:49 <syntaxfree> But jesus, 314 points to "Blogger disgusted rah rah rah"
07:35:12 <psnl> haskell only version, maybe?
07:35:23 <johnnowak> short of instilling a sense of shame, it's hard to fix human nature problems like this.
07:35:44 <syntaxfree> not haskell-only version.
07:35:57 <johnnowak> maybe add an off-topic flagging system.
07:35:58 <syntaxfree> I'm semi-okay with python/ruby stories, though I'd like to see them less often.
07:36:17 <syntaxfree> But "Linux is cool, M$ is for fags" stores definitely don't belong there.
07:36:35 <Syzygy-> I'd like a haskell.reddit.com :P
07:36:36 <syntaxfree> "Novell is selling out to Microsoft". That's open source politics, not programming.
07:36:50 <syntaxfree> a haskell.reddit.com would probably repeat planet.haskell.org
07:36:52 <Syzygy-> Then again I'd like mathematics.reddit.com too.
07:36:57 <Syzygy-> syntaxfree: Good point
07:37:40 <pejo> johnnowak, the "recent posts" on LtU gives me quite a lot of red stars, but definitely not as active as those other sites seem to be.
07:38:11 <syntaxfree> red stars?
07:38:31 <dmhouse> Anyone know of functions for parsing the query part of a URI? I.e. everything after the '?'.
07:38:35 * johnnowak is also confused by red stars
07:38:41 <dmhouse> It'd be easy enough to knock one up but I thought I'd ask.
07:38:45 <syntaxfree> maybe we need a catch-all term. Like militant atheists who call themselves "brights".
07:39:05 <johnnowak> syntaxfree: I'm never heard of that before.
07:39:29 <syntaxfree> oh, Dennett and Dawkins and such are into that stuff.
07:41:03 <bakert> hello folks.  just working through http://haskell.org/haskellwiki/How_to_write_a_Haskell_program
07:41:04 <lambdabot> Title: How to write a Haskell program - HaskellWiki
07:41:10 <syntaxfree> anyway, there's no popular term distinguishing the mathier CSier geeks from the Linux kiddie folk.
07:41:11 <bakert> and $ runhaskell Setup.lhs haddock
07:41:27 <bakert> doesn't generate any docs for me.  do i need special comments in or something before it will do that?
07:41:30 <johnnowak> ah. well i'll take militant atheists over militant linux users (or worse yet, militant firefox users) any day
07:41:40 <dmhouse> bakert: yep.
07:41:42 <xerox> dmhouse: Network.URI.parseURI.
07:42:04 <dmhouse> xerox: I want it split into (name, value) pairs, though. That will give me a URI, and the best I can get out of that is a String.
07:42:05 <syntaxfree> militant firefox users serve a purpose. People actually switch to Firefox and improve their lot in life.
07:42:28 <dmhouse> ?where haddock
07:42:28 <lambdabot> http://www.haskell.org/haddock/
07:42:34 <dmhouse> bakert: try at that URL.
07:42:34 <xerox> ?type uriQuery . parseURI
07:42:36 <lambdabot> Not in scope: `uriQuery'
07:42:36 <lambdabot>  
07:42:36 <lambdabot> <interactive>:1:11: Not in scope: `parseURI'
07:42:40 <bakert> dmhouse, thanks
07:42:54 <dmhouse> ?type Network.URI.uriQuery . Network.URI.uriQuery
07:42:56 <lambdabot>   Couldn't match `Network.URI.URI' against `String'
07:42:56 <lambdabot>    Expected type: Network.URI.URI -> Network.URI.URI
07:42:57 <xerox> Hm.
07:43:02 <dmhouse> ?hoogle uriQuery
07:43:03 <lambdabot> Network.URI.uriQuery :: URI -> String
07:43:13 <dmhouse> ?type Network.URI.uriQuery . Network.URI.parseURI -- oops :)
07:43:15 <lambdabot>   Couldn't match `Network.URI.URI' against `Maybe Network.URI.URI'
07:43:15 <lambdabot>    Expected type: String -> Network.URI.URI
07:43:38 <johnnowak> syntaxfree: let's stop complaining and be happy. tis a new year and all that (well, almost for me anyway)
07:43:50 <syntaxfree> it's just a date.
07:43:54 <xerox> :t (Network.URI.uriQuery `fmap`) . Network.URI.parseURI
07:43:54 <syntaxfree> Or so I'm trying to convince myself.
07:43:55 <lambdabot> String -> Maybe String
07:43:59 <dmhouse> bakert: http://www.haskell.org/haddock/haddock-html-0.8/markup.html is mostly what you need to know.
07:44:01 <lambdabot> Title: Chapter 3. Documentation and Markup
07:44:07 <xerox> ...and then split on '&' ?
07:44:09 <johnnowak> syntaxfree: i'm sure there will be an article about it on the top of programming.reddit.com in 12 hours or so.
07:44:09 <dmhouse> xerox: still a String, though.
07:44:14 <dmhouse> Yeah, I think I'll just write one myself.
07:44:23 <syntaxfree> Last years' new year's eve was wonderful; this one is just sucking.
07:44:36 <dmhouse> What's the standard way of splitting a string on a given char nowadays?
07:44:37 <araujo> mmm...
07:44:42 <dmhouse> splitAt combined with unfoldr?
07:44:48 <araujo> interesting ... it looks like it is worldwide
07:45:08 <dmhouse> ?hoogle unfoldr
07:45:09 <lambdabot> List.unfoldr :: (a -> Maybe (b, a)) -> a -> [b]
07:45:09 <lambdabot> Data.List.unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
07:45:23 <syntaxfree> araujo: the standard way of splitting a string on a given char?
07:45:24 <dmhouse> ?hoogle splitAt
07:45:25 <lambdabot> Prelude.splitAt :: Int -> [a] -> ([a], [a])
07:45:26 <lambdabot> Data.PackedString.splitAtPS :: Int -> PackedString -> (PackedString, PackedString)
07:45:26 <lambdabot> List.genericSplitAt :: Integral a => a -> [b] -> ([b], [b])
07:45:48 <xerox> ?type splitBy
07:45:50 <lambdabot> Not in scope: `splitBy'
07:45:58 <araujo> syntaxfree, hah, no, the christmas eve worse
07:46:08 <dmhouse> Hrm, what's this called again.
07:46:09 <syntaxfree> not xmas, new years'.
07:46:14 <syntaxfree> Xmas was okay-ish here.
07:46:16 <dmhouse> You could do span (/= char), I suppose.
07:46:18 <bakert> hmm i'm obviously doing something dumb.  even with a --| type comment in there i get nothing out of $ runhaskell Setup.lhs haddock
07:46:20 <araujo> syntaxfree, well, both here
07:46:23 <benc__> I see some haddocks for Data.Time.Calendar
07:46:27 <benc__> but my GHC install doesn't have it
07:46:35 <benc__> should I expect it to?
07:46:39 <araujo> both new year and christmas eve were very different ... like more 'bored'
07:46:40 <dmhouse> benc__: what version of GHC?
07:46:59 <dmhouse> > span (/= '&') "hello&foo"
07:47:01 <benc__> |The Glorious Glasgow Haskell Compilation System, version 6.4.1
07:47:02 <xerox> ?tyep span
07:47:03 <lambdabot>  ("hello","&foo")
07:47:04 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
07:47:05 <benc__> which i think came from darwinports
07:47:12 <araujo> mm... well , we still don't get the new year here ... but it was kind of different last year
07:47:29 <syntaxfree> araujo: part of the problem here is the contrast. Last NYE was really really great.
07:47:42 <benja_> ?seen vegai
07:47:42 <lambdabot> vegai is in #haskell. I don't know when vegai last spoke.
07:47:45 <dmhouse> > unfoldr (Just . second tail . span (/= '&')) "hello&foo&bar&baz"
07:47:46 <lambdabot>  Exception: Prelude.tail: empty list
07:48:04 <dmhouse> > unfoldr (Just . second (drop 1) . span (/= '&')) "hello&foo&bar&baz"
07:48:05 <lambdabot>  ["hello","foo","bar","baz","","","","","","","","","","","","","","","","","...
07:48:14 <dmhouse> > takeWhile (not . null) $ unfoldr (Just . second (drop 1) . span (/= '&')) "hello&foo&bar&baz"
07:48:15 <lambdabot>  ["hello","foo","bar","baz"]
07:48:19 <dmhouse> That'll do.
07:50:13 <xerox> hmmm
07:50:59 <dmhouse> > takeWhile (not . null) $ unfoldr (Just . second (drop 1) . break (== '&')) "hello&foo&bar&baz" -- bit neater
07:51:00 <lambdabot>  ["hello","foo","bar","baz"]
07:51:38 <dmhouse> > unfoldr (listToMaybe . second (drop 1) . break (== '&')) "hello&foo&bar&baz" -- bit neater
07:51:38 <lambdabot>  Couldn't match `[a]' against `([Char], [Char])'
07:53:07 <dmhouse> > unfoldr (\s -> case break (== '&') s of ([], _) -> Nothing; (x, y) -> Just (x, y)) "hello&foo&bar&baz" -- perhaps
07:53:08 <lambdabot>  ["hello"]
07:53:25 <dmhouse> > unfoldr (\s -> case break (== '&') s of ([], _) -> Nothing; (x, y) -> Just (x, drop 1 y)) "hello&foo&bar&baz" -- perhaps
07:53:26 <lambdabot>  ["hello","foo","bar","baz"]
07:59:01 <paolino> hi, can anyone help me running this code, or better understand the ST monad and its state parameter ?
07:59:01 <paolino> anArr = return $ newArray (1,10) 37
07:59:01 <paolino> main = print $ runST anArr
08:02:15 <Lemmih> paolino: s/runST/runSTArray/
08:02:28 <dmhouse> ?hoogle newArray
08:02:28 <lambdabot> Data.Array.MArray.newArray :: (MArray a e m, Ix i) => (i, i) -> e -> m (a i e)
08:02:29 <lambdabot> Data.Array.MArray.newArray :: (MArray a e m, Ix i) => (i, i) -> e -> m (a i e)
08:02:29 <lambdabot> Foreign.Marshal.Array.newArray :: Storable a => [a] -> IO (Ptr a)
08:02:37 <Lemmih> paolino: And remove the 'return'.
08:02:42 <dmhouse> ?hoogle runST
08:02:42 <lambdabot> Control.Monad.ST.runST :: ST s a -> a
08:02:43 <lambdabot> Data.Array.ST.runSTArray :: Ix i => ST s (STArray s i e) -> Array i e
08:02:43 <lambdabot> Data.Array.ST.runSTUArray :: Ix i => ST s (STUArray s i e) -> UArray i e
08:03:23 <dmhouse> So runSTArray is like convertSTArrayToNormalArray . runST?
08:04:31 <paolino> always the less polymorphic error on the s type variable
08:04:31 <Lemmih> dmhouse: runSTArray st = runST (st >>= unsafeFreezeSTArray), yes.
08:05:37 <Lemmih> paolino: That's because of the monomorphism restriction.
08:06:05 <Lemmih> paolino: Give 'anArr' a type signature or inline it.
08:06:46 <paolino> mhh, which type should I put in s ?
08:07:01 <Lemmih> paolino: How about using GHCi/hugs for playing around with ST?
08:07:20 <Lemmih> paolino: No type.
08:07:53 <paolino> ghci has no line editing in freebsd. I try hugs
08:09:15 <paolino> Hugs> :module Control.Monad.ST
08:09:16 <paolino> ERROR - Cannot find module "Control.Monad.ST"
08:09:53 <Lemmih> paolino: Use :load
08:11:32 <paolino> Hugs> :load prova11.hs
08:11:32 <paolino> ERROR "/usr/local/lib/hugs/packages/hugsbase/Hugs/ST.hs":51 - Syntax error in type expression (unexpected `.')
08:11:32 <Lemmih> And you probably need to start hugs with -98.
08:11:53 <dino-> Speaking of state, has Control.Monad.State moved? I don't see haddock for it in my ghc6 docs.
08:11:54 <paolino> ok
08:12:23 <Lemmih> dino-: It has moved to the mtl package.
08:13:23 <dino-> Lemmih: Ah, thank you.
08:16:11 <Axioplase> Has someone ever written an AAP module to handle haskell ?
08:18:52 <paolino> Lemmih
08:18:53 <paolino> arra = newArray (0,10) 0
08:18:53 <paolino> doesn't load in hugs -98 with
08:18:53 <paolino> Unresolved top-level overloading
08:19:47 <LoganCapaldo> should there not be a let in front of arra?
08:20:43 <paolino> it's written in a file I'm trying to load
08:20:55 <LoganCapaldo> o
08:21:07 <LoganCapaldo> silly me
08:21:13 <paolino> the only thing written after the import
08:21:45 <Lemmih> paolino: Try writing 'runSTArray (newArray (0,10) 0)' in hugs.
08:22:09 <paolino> it works
08:22:14 <paolino> :D
08:23:19 <paolino> let arr = newArray (0,10) 0 in runSTArray arr
08:23:26 <paolino> this doesn't
08:23:44 <dmhouse> paolino: what's the error?
08:23:50 <dmhouse> _Full_ error.
08:23:56 <paolino> Data.Array.ST> let arr = newArray (0,10) 0 in runSTArray arr
08:23:57 <paolino> ERROR - Inferred type is not general enough
08:23:57 <paolino> *** Expression    : arr
08:23:57 <paolino> *** Expected type : ST a (STArray a _20 _21)
08:23:57 <paolino> *** Inferred type : ST _22 (STArray _22 _20 _21)
08:25:16 <jgrimes> whenever declaring an instance an applying type arguments, If I apply it to something of kind (*) ghc tells me it needs to be (* -> *), and if it is *->* ghc tells me it needs to be (*)
08:25:27 <jgrimes> I take it this means there is some other problem? ;p
08:25:49 <xerox> An instance of what class, of what type?
08:26:08 <paolino> dmhouse: also ghci fails with same error
08:26:20 <jgrimes> my own class: class Functor f => Algebra f a, my own type Sum a b
08:26:26 <Lemmih> paolino: You're hitting the monorphism restriction.
08:26:35 <andrew_p> i was trying to write a function that transforms strings in the followign way: each character ch should be repeated x times, where x is a position of ch in the string; that is, bang should become baannngggg. here is what i've written: http://paste.lisp.org/display/33775
08:26:58 <dmhouse> paolino: try launching ghci with -fno-monomorphism-restriction
08:27:07 <andrew_p> i can't get why ghc argues on Couldn't match `[Char]' against `Char' in `blowup_ (tail str) fullstr', line 37
08:27:19 <dmhouse> Or do something like let arr () = newArray (0, 10) 0 in runSTArray (arr ())
08:27:28 <jgrimes> Sum a b is basically Either, but I have my own Functor instance for it
08:27:42 <paolino> Lemmih, that thing is hitting me also
08:28:41 * paolino can't get out of ghci without killing it
08:29:01 <dmhouse> andrew_p: the first bracket in blowup_ returns a [Char], not a Char, so you can't use (:). Try (++) instead
08:29:19 <dmhouse> andrew_p: by the way, atomPosition is better known as findIndex.
08:29:24 <dmhouse> ?hoogle findIndex
08:29:25 <lambdabot> List.findIndex :: (a -> Bool) -> [a] -> Maybe Int
08:29:25 <lambdabot> Data.Map.findIndex :: Ord k => k -> Map k a -> Int
08:29:51 <paolino> with that it works
08:30:38 <dmhouse> jgrimes: paste your code
08:30:46 <jgrimes> dmhouse, ok
08:31:15 <paolino> is there a similar option for hugs (no-monomoprhism? )
08:31:41 <dmhouse> paolino: dunno, but perhaps try the second suggestion I had if you can't get that to work.
08:31:48 <Lemmih> > L.blow "hiya"
08:31:49 <lambdabot>  "hiiyyyaaaa"
08:31:51 <dmhouse> It's an ugly hack, but it should do the trick.
08:33:32 <Lemmih> > L.blow "megabyte sequence"
08:33:33 <lambdabot>  "meegggaaaabbbbbyyyyyyttttttteeeeeeee         sssssssssseeeeeeeeeeeqqqqqqqqq...
08:34:32 <paolino> dmhouse: why it's ugly?.It wants a type there to index the state or what ?
08:34:59 <Templar2> is there any word for the function \\     ?
08:35:16 <LoganCapaldo> duel swords? ;)
08:35:29 <Lemmih> slash slash?
08:35:32 <xerox> differnece?
08:35:38 <xerox> difference.
08:35:46 <dmhouse> paolino: it's turning that isn't really a function into a (trivial) function to hack around the monomorphism restriction, which only applies to things that aren't 'functions'.
08:35:47 <Templar2> for removal of elements
08:35:58 <dmhouse> I use the quotes because the notion of function vs. data is extremely blurred in Haskell.
08:36:18 <dmhouse> Templar2: technically it's set difference, or set minus, or whatever.
08:36:30 <xerox> > [1..10] \\ [2..5]
08:36:32 <lambdabot>  [1,6,7,8,9,10]
08:36:37 <metaperl> beware, oh user of languages, symbols are nice, but interpretation is the key: echo Amy Smart >> people
08:36:55 <metaperl> I was reading a web page and saw that and you know what I was thinking other than shell scripting :)
08:37:22 <dino-> I'm having trouble locating haddock doc for mtl anywhere. Does anyone know offhand where it may be?
08:38:14 <Templar2> dmhouse is there a word i can type insted of \\?
08:38:24 <dmhouse> Templar2: why would you want to?
08:38:33 <lisppaste2> jgrimes pasted "kind errors" at http://paste.lisp.org/display/33778
08:39:55 <paolino> dmhouse: Anyway, if I want to pass around STArray 's I must index them with a type so I can get out of the ST monad ?
08:39:58 <Templar2> dmhouse whant to prove for my friend that the \\ it working like all the others( `elem and elem and div and div are writen in drifrent places if you understand
08:40:40 <dmhouse> jgrimes: if you declare a tycon to be an instance of Algebra, it has to be parametrised over two types.
08:40:54 <dino-> Ah, found it in the doc here: http://haskell.org/ghc/docs/latest/html/libraries/  includes mtl
08:40:55 <dmhouse> I.e. you'd have to make Sum the instance, not Sum (something) (something else).
08:41:12 <xerox> Algebra (Sum (E1 a) (E2 a)) a ?
08:41:45 <dmhouse> It's as nonsensical as saying instance Functor [Int] or something. [Int] is not a functor. [] is though. The Functor class requires that you can put any type you like into its instances.
08:41:47 <Daveman> Happy holidays, paolo, and the rest of Haskell :)
08:42:02 <xerox> dmhouse: instance Functor (Sum Foo) no?
08:42:17 <dmhouse> xerox: that'd work, sure, because Functor only takes one parameter.
08:42:22 <xerox> To you too Daveman.
08:42:40 <Daveman> :D
08:42:44 <dmhouse> Basically instances of, say, Monoid have to have kind *, instances of, say, Functor need kind * -> * and instances of your Algebra, jgrimes, need kind * -> * -> *.
08:42:47 <xerox> dmhouse: then it's instance Algebra (Sum Foo) Bar
08:43:09 <Templar2> okok
08:43:11 <Botje> @pl \f -> f 1
08:43:12 <lambdabot> ($ 1)
08:43:14 <dmhouse> xerox, jgrimes: oh, wait, sorry, I've got this sideways.
08:43:15 <Botje> of course
08:43:20 <Botje> I was trying with (.)
08:43:22 <dmhouse> Yeah.
08:43:40 <dmhouse> If you have instance Algebra a b, then a needs kind * -> *, b *.
08:43:51 <jgrimes> ah.
08:44:03 <xerox> I don't think so
08:44:17 <dmhouse> xerox: why not?
08:44:31 <xerox> `a' must be of kind * -> * not because it is a tyvar of the class, but because of the Functor constraint on it
08:44:40 <dmhouse> instance Algebra a b means a is a functor, and b is something that can be placed in a functor by the type of phi, so a :: * -> *, b :: *
08:44:42 <xerox> a is not applied to b in "class Algebra a b"
08:44:59 <dmhouse> xerox: oh, sorry, my sentence wasn't meant to involve implication,
08:45:13 <dmhouse> In fact, a :: * -> * because in the type of phi, you apply a tyvar to it.
08:45:19 <Daveman> Botje :)
08:45:30 <Botje> hello, daveman
08:45:33 <Botje> i'm no longer sick!
08:45:51 <Daveman> yay \o/
08:46:00 <andrew_p> dmhouse: thanks a lot! i was distracted in real world and will try now what you adviced
08:46:12 <dmhouse> xerox, Even without the Functor constraint it'd be * -> *.
08:46:29 <dmhouse> There exist things with kind * -> * that aren't Functors, as Functors require a couple of extra rules.
08:46:59 <xerox> |class Algebra a b| doesn't impose any kind on a or b.
08:47:03 <dmhouse> No.
08:47:07 <dmhouse> I didn't mean to infer that.
08:47:28 <dmhouse> |class Algebra a b where phi :: a b -> b| imposes kinds on both, though.
08:47:34 <JKnecht> (nervously) this isn't the real world?
08:47:55 <dmhouse> As in the type for phi, 1) b is the result of a function, so must be kind *, 2) b is applied to a, so a must be kind * -> *.
08:48:13 <xerox> Why is it called Algebra if I could ask, jgrimes?
08:48:26 <jgrimes> xerox, because thats what the call it in the paper :)
08:49:17 <jgrimes> and it deals with catamorphisms, which as I understand it have something to do with initial algebras
08:49:25 <jgrimes> but I am very cloudy on that
08:50:02 <xerox> Does instance Algebra (Sum (E1 a) (E2 a)) a work?
08:50:28 <xerox> It doesn't look like it should, but I can't see the right instance with that type.
08:51:08 <xerox> I should try myself.
08:51:08 <jgrimes> "Expected kind `* -> *', but `Sum (E1 a) (E2 a)' has kind `*'"
08:51:10 <dmhouse> I don't think there is one.
08:51:32 <bakert> Damn.  Someone very helpfully explained how to set up a record earlier but it's scrolled off the top of my screen and I didn't take a copy.
08:51:37 <bakert> It was something like:
08:51:49 <bakert> data Record = R { blah :: Int }
08:51:51 <bakert> is that right?
08:51:55 <benja_> y
08:52:10 <benja_> fields are comma-separated
08:52:14 <bakert> thanks
08:52:15 <xerox> dmhouse: yeah, I see that E1 and E2 obviously are instances.
08:52:18 <dmhouse> |instance Algebra (Sum (E2 Int)) (E1 Int) where phi = Num . (phi2 <+> phi1)| would work, but it's not what you want.
08:52:35 <bakert> I thought it was convention to call the constructor the same as the type (he said, probably using the wrong words)?
08:52:36 <bakert> Like
08:52:47 <dmhouse> bakert: sometimes.
08:52:54 <bakert> data Record = Record { foo :: Int, bar :: String }
08:52:57 <dmhouse> bakert: that's semi-common when you only have one constructor.
08:53:04 <dmhouse> But is by no means required nor universal.
08:53:09 <dmhouse> It would work, though.
08:53:13 <benja_> bakert: it sometimes confuses newbies which might account for why it wasn't used above =)
08:53:24 <bakert> if ever there was a newbie i am he!
08:53:40 <bakert> i am stuck in an OO mindset.
08:54:01 <bakert> should i create a type called Player for the players, containing their hand, score, etc?
08:54:20 <bakert> do i do that kind of thing as if they were objects almost?
08:54:31 <dmhouse> Yeah.
08:54:35 <bakert> (if there is a good website or book about this do point me at it).
08:55:10 <bakert> (especially website)
08:55:33 <xerox> newtype E x = E Sum (E1 x) (E2 x)  instance Algebra E Int where phi (E s) = (phi1 <+> phi2) s
08:56:00 <bakert> jesus xerox what the hell is that?
08:56:17 <bakert> <+> ?
08:57:07 <dmhouse> xerox: E (Sum (E1 x) (E2 x)), but otherwise it looks good.
08:57:43 <xerox> bakert: it is explained in the paper on which jgrimes is working.
08:57:49 <dmhouse> Interestingly, you could write phi <+> phi if you want. :)
08:58:05 <bakert> i think i'll leave that crazy stuff to you guys til i can write a working program ;_
08:58:08 <bakert> ;) even
08:58:18 <dmhouse> jgrimes: still interested? :)
08:58:22 <jgrimes> dmhouse, yeah
08:58:31 <xerox> bakert: actually it is pretty straightforward if you read the explanation.
08:58:35 <jgrimes> I think the newtype will work
08:58:57 <dmhouse> bakert: and can grok multi-parameter type classes.
08:59:24 <xerox> A two-parameter typeclass is just a relation.
08:59:59 <dmhouse> Just as a one-parameter typeclass is a unary relation (aka., a predicate).
09:00:41 <dmhouse> If you have instance Monoid t, say, then you know some predicate about t is true (in this case, the predicate is that t supports a binary operation `mappend` with unit mempty).
09:00:52 <dmhouse> If you don't have that instance, then the predicate is false.
09:01:11 <dmhouse> Now, a two-parameter MPTC (multi-parameter type class) is a relation.
09:01:49 <jgrimes> dmhouse, xerox: thanks for the help
09:01:54 <xerox> You're welcome.
09:02:01 <dmhouse> If you know, say, MonadReader e m for some e and m, then you know that e is related to m in some way (in this case, e can serve as the environment for a Reader-like monad m).
09:04:53 <xerox> If you add a functional dependency to a two parameter typeclass you get a function. And with those things you do type level computation!
09:07:32 <dmhouse> Is there any way to get GHC to tell me when I make an import without using any of the functions from that module?
09:07:48 <dmhouse> Or when I explicitly import a function, i.e. import M (f) and don't use it?
09:08:51 <xerox> You should check the manpage, I think it lists all the crazy command-line options.
09:08:57 <bakert> So, say I have this record type:
09:08:58 <bakert> data Record = Record { foo :: Int, bar :: String }
09:09:05 <bakert> How do I access a sub-value
09:09:17 <bakert> let x = Record 7 "hello"
09:09:23 <bakert> how do I get value foo for x?
09:09:24 <dmhouse> xerox: reminds me of one of the ?quotes, 'GHC has more flags than the UN' :)
09:09:24 <xerox> foo :: Record -> Int
09:09:32 <dmhouse> bakert: foo x
09:09:35 <xerox> bar :: Record -> String
09:09:47 <xerox> ...those functions are automagically defined by the compiler.
09:10:06 <dmhouse> bakert: by the way, you can say let x = Record { foo = 7, bar = "hello" }
09:10:14 <bakert> ah brill!
09:10:24 <bakert> double brill.
09:10:26 <bakert> thanks
09:10:35 <bakert> getting there ... verrry slowly but getting there!
09:10:55 <dino-> I at first found it confusing that you write it like ... { foo :: Int }, but then if you check its type it's foo :: Record -> Int
09:11:05 <shapr> @quote kill
09:11:05 <lambdabot> monochrom says: 007 titles for haskellers.  fromForeignPtr withCString.  You Only lift Twice.  Bottoms Are Forever.  The Monad with the Pure Function.  For Your Types Only.  A view to A seq.
09:11:06 <lambdabot> Licence to killThread.  iterate Never Dies.  unsafePerformIO Is Not Enough.
09:11:51 <xerox> Then you can update the slot values of an existing (x :: Record) with y = x { bar = "that's new" }, y will inherit x's foo slot.
09:12:25 <bakert> xerox, ah yes going to need that in two ticks.  thanks.
09:12:57 <dino-> xerox: Huh, I didn't know you can do that. I have code where I match everything just to construct a new one.
09:13:13 <dmhouse> shapr: we can search the quote database? Wicked-cool.
09:13:16 <xerox> I think there's a page on the (old) wiki that explains thoroughly how to use records.
09:13:17 <dmhouse> ?quote flags
09:13:17 <lambdabot> shapr says: GHC has more flags than the UN
09:13:22 <shapr> dmhouse: Yeah, that's nifty.
09:13:24 <xerox> dmhouse: with regexp :)
09:13:25 <dmhouse> :) there we gol
09:13:32 <dmhouse> s/l$/./
09:13:39 <shapr> @quote pugs
09:13:40 <lambdabot> JohnMeacham says: Last night I was at this dive bar listening to live music and there was this cute girl I was talking too while this guy was there, we started ribbing each other in the appropriate
09:13:40 <lambdabot> way when confronted with the situation of two guys talking to the same girl, and our jeers eventually turned technical until we were arguing about haskell, perl, and pugs development. it turning out
09:13:40 <lambdabot> he was one of the pugs de
09:13:44 <xerox> ?quote a\.$
09:13:45 <lambdabot> Pseudonym says: A meeting will kill almost any good idea.
09:14:01 <shapr> @quote house
09:14:02 <lambdabot> No quotes match. Just what do you think you're doing Dave?
09:14:05 <shapr> hah
09:14:14 <shapr> @quote dmhouse
09:14:14 <lambdabot> No quotes match. This mission is too important for me to allow you to jeopardize it.
09:14:19 <xerox> O_o
09:14:24 <shapr> I like the cute error messages.
09:14:28 <xerox> Yeah.
09:14:31 <dmhouse> I prefered the old 'dmhouse hasn't said anything memorable'.
09:14:42 <LoganCapaldo> @quote open the pod bay doors lambdabot
09:14:43 <lambdabot> No quotes for this person. Your mind just hasn't been the same since the electro-shock, has it?
09:14:48 <xerox> I always wanted lambdabot to be less shy.
09:14:50 <LoganCapaldo> figures
09:14:57 <shapr> @quote pod
09:14:58 <lambdabot> tizoc says: * tizoc tiene poderes de verga regenerativa y se sigue garchando a emonk
09:15:09 <xerox> :0
09:15:09 <shapr> @quote stewart
09:15:10 <lambdabot> dons says: Don "If it ain't pure, it ain't functional" Stewart
09:15:19 <xerox> hahaha
09:15:31 <shapr> @quote erisson
09:15:31 <lambdabot> No quotes match. Sorry about this, I know it's a bit silly.
09:15:53 <LoganCapaldo> @quote erlang
09:15:53 <lambdabot> dons says: [In reference to <joelr1> did you guys know that #ocaml has 37 members and #erlang has 34 vs. 202 on #haskell?] I think part of the #haskell success comes from the approach that we all
09:15:54 <lambdabot> know each other, it's not a homework channel like #java. We created a community of peers, working on the overall goals of the community. That's why people keep coming back
09:16:11 <shapr> hiya astrolabe
09:16:15 <shapr> @quote astrolabe
09:16:16 <lambdabot> astrolabe says: calling variables things like ll,kk,tt and dd is a bit cryptic
09:16:40 <velco> and needlessly verbose
09:16:45 <astrolabe> Hi Shapr, I've been away for a couple of weeks.  How's things?
09:16:50 <shapr> Things are good!
09:17:01 <shapr> Did you have a fun vacation?
09:17:08 <astrolabe> I'm pleased to hear it.
09:17:23 <astrolabe> It was very relaxing, which is good.
09:17:37 <astrolabe> I read a couple of chapters of TAPL, which is also good.
09:17:43 <dmhouse> Perhaps I should steal quotes from bash.org and feed them to lambdabot in /queries in a vain attempt to make people believe I occasionally say ?quote-worthy things.
09:17:53 <astrolabe> I thought some more about my go program, but made no progress :(
09:18:09 * xerox shakes his fist
09:18:12 <pejo> Reading tapl is considered vacation and relaxing? :P
09:18:14 <psnl> dmhouse: or you could just start drinking and ircing
09:18:24 <shapr> pejo: sure!
09:18:25 <astrolabe> hia xerox, changed your name back?
09:18:34 <psnl> pejo: I did it ;-)
09:18:37 <xerox> astrolabe: aw :)
09:18:45 <astrolabe> pejo: depends on your job.
09:19:21 <astrolabe> I've been called for jury service, which might be interesting.
09:20:37 <xerox> Yeah, it sounds pretty interesting.
09:23:18 <LoganCapaldo> heh
09:23:22 <LoganCapaldo> I postponed mine
09:23:33 <LoganCapaldo> it would have effectively been in the middle of finals
09:24:24 <astrolabe> not ideal
09:27:13 <paolino> bah , I leave my understanding of how to use STArray to next year. Have a nice night, inoxidables
09:33:40 <bakert> Stylistic question for you clever people.  If I want an optional commandline arg, what's the right way of expressing that and supplying a default?
09:33:48 <bakert>     args <- getArgs
09:33:57 <bakert> (read (head args) :: Int)
09:34:07 <bakert> but if args is an empty list, make it 2
09:34:19 <dmhouse> args <- getArgs
09:34:21 <norpan> if null args then 2 else head args?
09:34:34 <norpan> read
09:34:35 <dmhouse> case args of [] -> 2; (a:_) -> read a
09:34:40 <dmhouse> Or norpan's.
09:35:16 <xerox> I personally like the case too. Boo ifs :)
09:35:24 <norpan> yay ifs
09:35:38 <bakert> ok, something that immediately makes sense to me.  i like that!  i keep looking for new ways to do everything, unnecessarily.  i always use case in erlang, not if, the if syntax is not so pleasant somehow
09:35:50 <dmhouse> :)
09:36:56 <bakert> thanks folks
09:37:07 <dmhouse> > case [2] of a:_ -> a -- /me wonders if you can elide the parentheses
09:37:08 <lambdabot>  2
09:37:12 <dmhouse> Cool.
09:37:39 <bakert> is (a:_) more normal than (a : _) ?
09:37:45 <norpan> would a null method make sense in MonadPlus
09:37:50 <norpan> you wonder
09:38:17 <norpan> bakert: normality is a state of mind :)
09:38:38 <bakert> true, i'm just trying to do things right from the beginning ... whatever right is ...
09:38:55 <dmhouse> bakert: yeah, for whatever reason people seem to miss out the spaces for the (x:xs) pattern.
09:38:57 <norpan> it's a matter of style
09:39:16 <dmhouse> norpan: it would place an Eq restraint on the instances of MonadPlus.
09:39:21 <dmhouse> ?instances MonadPlus
09:39:22 <bakert> i see a lot of (x:xs) not (h:t) or anything else, right?
09:39:22 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
09:39:23 <norpan> if you're spaced out or tight bottomed
09:39:33 <norpan> dmhouse: an eq restraint? hardly
09:39:34 <bakert> i find (x:xs) a bit weird but quite likeable
09:40:04 <dmhouse> bakert: the 'xs' bit is pronounced like the plural of 'x'.
09:40:07 <norpan> hard to do null for IO though
09:40:24 <norpan> or maybe not
09:40:26 <bakert> i'm definitely spaced out, but i'd rather follow a convention than stick to my instincts else i'll end up writing stuff no one else can bear!
09:40:38 <dmhouse> norpan: that's my point, you might be able to generate mempty, but checking to see if something is mempty or not requires Eq, or something like Eq.
09:40:50 <norpan> no, you use pattern matching
09:40:57 <dmhouse> On IO values?
09:41:07 <norpan> on IO you do something like catch
09:41:16 <dmhouse> What is mempty for IO? return ()?
09:41:26 <dmhouse> And what is mplus?
09:41:30 * dmhouse goes off researching
09:41:35 <norpan> you do that :)
09:42:41 <bakert> variable naming convention (in a let) -- camelCase?  or something else?
09:42:42 <dmhouse> Oh, weird.
09:42:52 <dmhouse> bakert: variable naming convention everywhere is camelCase.
09:42:57 <bakert> coolio
09:43:03 <bakert> same as functions right?
09:43:27 <xerox> mzero = return (); mplus = (>>)
09:43:35 <dmhouse> xerox: apparently not.
09:43:41 <dmhouse> instance MonadPlus IO where
09:43:42 <dmhouse> 	mzero       = ioError (userError "mzero")
09:43:42 <dmhouse> 	m `mplus` n = m `catch` \_ -> n
09:43:47 <xerox> :O
09:44:07 <xerox> Evil.
09:44:42 <dmhouse> So m `mplus` n is m if m doesn't throw any errors, and if it does, it's n?
09:44:56 <norpan> if m is not null :)
09:45:10 <norpan> null is hard as it takes you out of the monad
09:45:18 <dmhouse> norpan: well, not quite.
09:45:30 <dmhouse> (In response to your first comment.)
09:45:44 <dmhouse> m could throw some other error other than userError "mzero".
09:45:52 <norpan> i'd count that as null
09:45:55 <norpan> any error
09:46:23 <dmhouse> Right, okay, but then you could have p and q such that null p && null q, but p and q aren't the same program.
09:46:35 <norpan> yeah, so?
09:46:56 <dmhouse> It bucks the trend.
09:47:13 <dmhouse> That works for Maybe, [], pretty much any other MonadPlus.
09:47:23 <norpan> not for Either
09:47:23 <dmhouse> I suppose MonadPlus IO has always been a little funky.
09:47:32 <dmhouse> True.
09:47:42 <dmhouse> Okay, yeah, that's not a problem then.
09:48:04 <dmhouse> You could have null :: m a -> m Bool
09:48:12 <norpan> yeah, mnull
09:48:32 <dmhouse> For IO it'd be null x = (x >> return False) `catch` const True
09:48:44 <bakert> Can you supply defaults in a type constructor thingy?  Something like
09:48:57 <bakert> data Player = Player { Score :: Int default 0 }
09:48:59 <bakert> ???
09:49:03 <dmhouse> bakert: nope.
09:49:08 <norpan> no, make a default value instead
09:49:14 <dmhouse> bakert: but you could make defaultPlayer = Player { score = 0 }
09:49:19 <bakert> ah
09:49:20 <bakert> yes
09:49:21 <bakert> good idea
09:49:25 <dmhouse> (It has to be score and not Score, by the way.)
09:49:42 * LoganCapaldo doesn't like record syntax
09:49:42 <bakert> eek yes sorry case confusion
09:49:54 <dmhouse> bakert: then if you had a lot of fields, like data R = R { a :: Bool, b :: String, c :: Int }
09:50:06 <dmhouse> And defaultR = R { a = True, b = "hello world", c = 56 }
09:50:18 <dmhouse> You can do almostDefaultR = defaultR { a = False }.
09:50:32 <dmhouse> Then almostDefaultR == R { a = False, b = "hello world", c = 56 }
09:50:33 <bakert> Oh right.  Clever.
09:50:55 <bakert> defaultR is a function here, right?
09:51:03 <dmhouse> Not really.
09:51:04 <dmhouse> defaultR :: R
09:51:10 <bakert> Oh
09:51:28 <bakert> and I can just define that in my source file somewhere and all will be hunky dory?  With no "data" or "type" or whatever?
09:51:36 <dmhouse> But there's the "Record update" syntax that I showed you, defaultR { a = False }, that allows you to update individual fields in a record.
09:51:38 <bakert> Or I have to define it in a function in a let?
09:51:48 <dmhouse> No, just define it like you'd define a function.
09:52:07 <dmhouse> You can actually do that for anything. You could have a file like:
09:52:10 <dmhouse> module Test where
09:52:12 <dmhouse> a = 3
09:52:14 <dmhouse> b = 76
09:52:19 <dmhouse> f x = not x
09:52:19 <bakert> what?  this is shocking!
09:52:24 <dmhouse> main = print 12
09:52:27 <bakert> ;)
09:52:40 <dmhouse> a and b are 'functions with no arguments', if you like.
09:52:58 <dmhouse> Functions and data are intrinsically linked in Haskell (due to partial application), unlike, say, Lisp.
09:53:07 <dmhouse> You could even do:
09:53:08 <bakert> so it is a kind of a function to say defaultR = R { a = False }
09:53:16 <dmhouse> a = some great big computation
09:53:28 <dmhouse> The RHS doesn't have to be a simple value.
09:53:38 <LoganCapaldo> and its lazy!
09:53:42 <LoganCapaldo> lazy lazy lazy
09:53:45 <dmhouse> bakert: yeah, apart from the word 'function' normally means something with at least one argument.
09:53:51 <bakert> oh i see
09:53:52 <bakert> right
09:53:57 <LoganCapaldo> sitting in a rocking chair on the porch sipping some lemonade lazy
09:54:02 <bakert> yes, it would, from mathematics and all that
09:54:04 <dmhouse> And in your example, you didn't initialise the other elements of R.
09:54:13 <bakert> oop yes bad example
09:54:25 <dmhouse> Which is legal, but something like b defaultR will crash your program.
09:54:33 <dmhouse> It's essentially equivalent to a pattern-match failure.
09:54:53 <bakert> OK, so I have: defaultPlayer = Player { hand = [], meld = [], score = 0 }
09:54:58 <bakert> and then somewhere completely else:
09:55:03 <bakert>     let player = defaultPlayer { hand = head hands }
09:55:10 <bakert> cool
09:55:11 <dmhouse> That'll work, yep.
09:55:12 <bakert> i like that
09:55:42 <dmhouse> By the way, it's generally a bad idea to use head unless you're _completely sure_ that hands will never be empty.
09:55:49 <dmhouse> > head []
09:55:50 <lambdabot>  Add a type signature
09:55:57 <dmhouse> Because head of an empty list is a crash.
09:56:05 <dmhouse> > head ([] :: [Int])
09:56:06 <lambdabot>  Exception: Prelude.head: empty list
09:56:09 <bakert> ah yes i see
09:56:31 <dmhouse> You could use a case on hands and do something sensible in the empty case.
09:56:32 <bakert> that would only happen in a game with zero players but i can see that i don't handle that case very elegantly
09:56:40 <LoganCapaldo> Not if you use a GADT list. Then it won't compile
09:56:43 <LoganCapaldo> hehhe
09:56:45 <LoganCapaldo> so cool
09:56:48 <bakert> GADT?
09:57:03 <dmhouse> Sure, even something like case hands of (h:hs) -> ...; [] -> error "No players! Aargh" is better.
09:57:05 <bakert> G_ Abstract Data Type?
09:57:19 <dmhouse> As you'll get an "No players! Aargh" error rather than an "Prelude.head: empty list" error.
09:57:23 <bakert> actually i have: initPlayers' [] acc = acc
09:57:25 <dmhouse> Generalised.
09:57:25 <LoganCapaldo> @where GADT
09:57:26 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/gadt.html
09:57:42 <bakert> above so it will return an empty list in that case so that works out quite well (but not intentionally!)
09:57:53 <LoganCapaldo> and its Algebraic not Abstract
09:58:06 <dmhouse> bakert: oh, then you could do initPlayers' (h:hs) acc = ..., and avoid using head (assuming you currently have initPlayer' hands acc = ...)
09:58:08 <bakert> LoganCapaldo, that's for later I think!
09:58:30 <bakert> dmhouse, ah yes -- no need for head and tail when you can pattern match ... lots to pick up on!
09:58:37 <dmhouse> LoganCapaldo: and you can't use one of those lists if the number of elements in the list will be decided at runtime ;)
09:59:01 <LoganCapaldo> dmhouse: well you can as long as its at least one element
09:59:03 <LoganCapaldo> :)
09:59:05 <bakert> every time i finally work something out the code has shrunk to one line!  i hope this keeps happening!
09:59:09 <LoganCapaldo> or exactly zero
09:59:12 <dmhouse> LoganCapaldo: well, you know what I mean :)
10:00:13 <bakert> thinking about it, initPlayers is a bit of "stateful" name, isn't it?  i wonder if that shows i'm doing something wrong ...
10:00:24 <bakert> probably jumping at shadows ...
10:00:42 <LoganCapaldo> of course there could be a maybeHead too
10:00:58 <bakert> that sounds like an experimental technoi group
10:01:01 <dmhouse> LoganCapaldo: that would be seriously annoying.
10:01:05 <bakert> s/technoi/techno/
10:01:07 <dmhouse> LoganCapaldo: case analysis would be far easier.
10:01:13 <LoganCapaldo> dmhouse: yes
10:01:18 <LoganCapaldo> I'm just saying :)
10:01:31 <dmhouse> But an unlist :: b -> ([a] -> b) -> [a] would be nice sometimes, to parallel maybe.
10:01:43 <LoganCapaldo> pattern matching > maybeHead
10:01:49 <dmhouse> Err, sorry, unlist :: b -> ([a] -> b) -> [a] -> b
10:02:01 <dmhouse> unlist z _ [] = z; unlist _ f xs = f xs
10:02:17 <LoganCapaldo> @djinn b -> ([a] -> b) -> [a] -> b
10:02:18 <lambdabot> f _ a b = a b
10:02:23 <LoganCapaldo> hmm
10:02:29 <bakert> So how do you guys live without printing stuff to the screen when writing a program?  Or do you use "deriving Show" all over the place so you can see what is happening?
10:02:34 <LoganCapaldo> djinn not as bright as I'd hope
10:02:35 <dmhouse> Or maybe,
10:02:43 <dmhouse> unlist :: b -> (NonEmptyList a -> b) -> [a] -> b
10:02:49 * LoganCapaldo personally uses deriving Show all over the place
10:02:51 <dmhouse> bakert: yeah, the latter.
10:03:11 <dmhouse> But I still wouldn't say I print stuff 'all over the place'.
10:03:21 <bakert> What do I need to do to make deriving Show work for my Record type?  Do I need to write special functions to tell it how to print stuff out?
10:03:35 <LoganCapaldo> bakert: no thats the point of using deriving
10:03:36 <bakert> google search gives me "deriving Show, impossible happened" which sounds bad!
10:03:41 <bakert> ah
10:03:49 <dmhouse> Nope, just add deriving Show at the end. As long as all of its components instantiate Show, it'll work.
10:03:58 <dmhouse> And that works for any derivable type, of course.
10:04:10 <LoganCapaldo> you can do it yourself with instance Show Player where show = ...
10:04:18 <LoganCapaldo> But thats just extra work
10:04:26 <dmhouse> Annoyingly you can't derive non-derivable types on records.
10:04:45 <dmhouse> I'd expect something like data R a = R { unR :: [a] } deriving Monad to work.
10:05:02 <bakert> I see.  So if you need to you put in a "where show = " then a function that returns a string?  And if they are all deriving Show components then the compiler does that for you?
10:05:08 <dmhouse> (And yes, I know I can use a newtype and newtype-deriving, but it should still work.)
10:05:22 <dmhouse> bakert: no, if you need to you write a Show instance.
10:05:25 <dmhouse> instance Show Player where
10:05:39 <bakert> ah
10:05:51 <bakert> instances are new to me.  i had some before but they didn't work and i got rid of them.
10:05:55 <dmhouse>   show p = ...
10:05:56 <bakert> i will research.
10:06:20 <norpan> a nullary function, i know we argue this :)
10:06:24 <dmhouse> You probably will end up writing a Show instance if you want to be able to print your record in your final product, as the built-in show isn't very end-user-friendly.
10:06:48 <bakert> i see
10:06:55 <bakert> thanks
10:07:56 <LoganCapaldo> type classes are the coooolest
10:08:26 <xerox> bakert - classes are sets of types (together with some operations on them.) Instantiating means making the type a member of that set (together with defining the minimum set of operations required.)
10:09:16 <LoganCapaldo> I love how lazy you can be with things like Ord
10:09:28 <LoganCapaldo> since the defaults are defined in terms of each other
10:09:30 <LoganCapaldo> heh
10:09:39 <dmhouse> Right. So Show is the set of types whose values can be converted into a String.
10:10:00 <bakert> ok
10:10:16 <bakert> so instance X Y says make Y part of the X group.
10:10:22 <dmhouse> Making an instance (instantiating) Show for a given type T adds T to that set. You need to say how you can convert things of type T into Strings, though, and that's what writing the Show function does.
10:10:32 <dmhouse> bakert: precisely.
10:10:46 <dmhouse> Err, that should have been 'show function' at the end there.
10:11:15 <xerox> bakert: nothing says that the operation is associative, I wouldn't call X a group in general.
10:11:43 <bakert> oooh xerox i thought i had it then and now you've thrown the cat in there
10:11:48 <bakert> (amongst the pigeons)
10:11:51 <bakert> what on earth do you mean?!
10:12:00 <bakert> ;)
10:12:08 <dmhouse> The word 'group' means something special in mathematics.
10:12:09 <LoganCapaldo> bakert: yes the danger of hanging out in #haskell is all the smart people speak "Math" ;)
10:12:10 <norpan> he is using group in the mathematcial sense
10:12:13 <bakert> ah
10:12:20 <xerox> Oh, sorry.  Nevermind.
10:12:26 <bakert> i am the maths dullard at my job ... they laugh at me.
10:12:27 <bakert> ;(
10:12:32 <norpan> but that does not apply here so ssh
10:12:34 <norpan> shh
10:13:09 <dmhouse> A group is a tuple (G, *) where * is a binary function defined totally on the elements of G such that * is associative, has an identity in G and every element in G has an *-inverse also in G. :)
10:13:18 <dmhouse> In short, 'Don't worry about it'.
10:15:18 <norpan> well, i'm off, you have a great new year's
10:17:31 <gmh33> I spent all that effort looking for what someone said to me while I was gone last night, and it was lambdabot quoting me :/
10:19:08 <koala_man> haha
10:19:10 <Jaak> > let marco = polo where polo = marco in marco
10:19:11 <lambdabot>  Add a type signature
10:19:17 <Jaak> blast
10:19:48 <integral> @type let marco = polo where polo = marco in marco
10:19:49 <lambdabot> forall t. t
10:19:50 <Jaak> > let marco = polo where polo = marco in marco :: undefined
10:19:50 <lambdabot>  Add a type signature
10:20:03 <Jaak> > let marco = polo where polo = marco in marco :: ()
10:20:04 <lambdabot>  Exception: <<loop>>
10:20:08 <Jaak> there
10:27:10 <LoganCapaldo> Did lambdaboot solve the halting problem? <g>
10:28:20 <norpan> for a given input of a given input it may be possible to solve it
10:28:25 <norpan> given program i mean
10:30:05 <Jaak> kind of roundabout way for writing "undefined"...
10:33:27 <dmhouse> Jaak: well, it's not quite the same.
10:33:52 <dmhouse> Inside of Haskell it's impossible to distinguish, and they both have the same denotational semantics, but they produce different outputs when you run them.
10:33:55 <dmhouse> > undefined
10:33:56 <lambdabot>  Add a type signature
10:34:03 <dmhouse> > let x :: () = x in x
10:34:03 <lambdabot>  Parse error
10:34:15 <dmhouse> > let x = x in x :: ()
10:34:17 <lambdabot>  Exception: <<loop>>
10:34:21 <dmhouse> > undefined :: ()
10:34:22 <lambdabot>  Undefined
10:34:30 <Jaak> hmm
10:49:24 <ski> bork !
10:50:37 <wilx> Hmpf.
10:51:09 <wilx> I hate it when people put the space before exclamation mark and before question mark in written text :/
10:51:42 <klapmuetz> it's the same problem with period ;-)
10:52:14 <wilx> I have not seen people put space before period, yet.
10:52:29 <klapmuetz> ##java
10:52:30 <klapmuetz> ;-)
10:52:48 * wilx shivers
10:52:58 <dmhouse> wilx: it's a European thing, I believe.
10:53:12 <wilx> O_O
10:53:14 <wilx> Huh?
10:53:24 <klapmuetz> not german though, we have a written rule that you are not allowed to put a space in front of it.
10:53:26 <wilx> What do you mean European thing?
10:53:32 <dmhouse> Putting whitespace in before exclamation marks and question marks.
10:53:38 <dmhouse> Oh, perhaps it's just French then.
10:53:42 <wilx> Same in Czech and about any language I have ever heard about.
10:53:43 <klapmuetz> they are crazy
10:53:51 <klapmuetz> wilx: well, but we get abducted if we do it.
10:54:01 <dmhouse> It'll either be French or German, those are the only two foreign language texts I would have read.
10:54:02 <mahogny_> putting a space in front of the last symbol. eeew
10:54:14 <mahogny_> not german to my knowledge. I should have noticed
10:55:20 <dmhouse> Okay, getting back on topic, with my Cabalised application, when should I reconfigure?
10:55:59 * dmhouse is away but will pick up any responses later.
10:56:57 <ski> wilx : :)
10:59:59 <bos> @pl \x y -> x + 1
10:59:59 <lambdabot> const . (1 +)
11:00:08 <bos> @pl \x y -> y + 1
11:00:08 <lambdabot> const (1 +)
11:00:14 <bos> doh.
11:03:09 <FZ> is the coming of new year a change in state?
11:03:19 <FZ> or do we have something like "year" monad or what? :)
11:04:12 <Nafai> Heh
11:04:46 * FZ gets ready for the last 3 hours of 2006 in Istanbul, Turkey
11:06:29 <Saizan> ?users
11:06:30 <lambdabot> Maximum users seen in #haskell: 309, currently: 267 (86.4%), active: 40 (15.0%)
11:10:17 <LoganCapaldo> ?. elite users
11:10:17 <lambdabot> /\/\4xiMum U5ErS 5e3n in #H4zKel|: 309, CurReN+1y: 267 (86.4%), AcTive: 40 (15.0%)
11:11:03 <LoganCapaldo> ?. vixen users
11:11:03 <lambdabot> church is my favourite computer scientist.
11:11:19 <Saizan> ?vixen
11:11:20 <lambdabot> i really hate arabs!
11:11:27 <LoganCapaldo> woah
11:11:33 <LoganCapaldo> thats a racist lambdabot
11:12:14 <Saizan> ?help vixen
11:12:14 <lambdabot> vixen <phrase>. Sergeant Curry's lonely hearts club
11:12:21 <vegai> is arab a race?
11:12:40 * vegai shrugs
11:13:14 <LoganCapaldo> Well its definitely a something -ist lambdabot ;)
11:13:35 <LoganCapaldo> (Ist x) => thats a x lambdabot
11:13:55 <vegai> Zionist? :P
11:15:13 <LoganCapaldo> ?vixen <phrase>
11:15:13 <lambdabot> help help!
11:27:45 * syntaxfree shakes wildly to the sound of Tom Waits' "Telephone Call from Istanbul", live.
11:27:50 <syntaxfree> this is a wicked sax solo.
11:27:58 * allbery_b is somewhat bemused by SPJ's reply
11:29:10 <dmhouse> allbery_b: to what?
11:29:39 <allbery_b> my post to haskell@ about the ghc build problem on freebsd
11:30:13 <dmhouse> allbery_b: was it a personal response? I don't seem to have it.
11:31:16 <allbery_b> hm, yes, personal reply with copies to a few other folks (which I AssUMe-d cced the list, whoops...)
11:31:24 <allbery_b> rather effusive thanks
11:32:00 <dmhouse> What did it say?
11:32:10 <dmhouse> Or what was the gist, as he didn't CC the list.
11:33:15 <allbery_b> "thanks for finding this, it's really great when people pitch in and help, I'm sure someone will review and incorporate your patch" (uh, no but it's the thought that counts)
11:33:47 <allbery_b> (my patch is a minimal evil hack to work around a bug in the freebsd build process, which is correctly fixed by fixing the bootstrap ghc tarball)
11:34:11 <dmhouse> How do you know someone won't read and incorporate your patch?
11:34:26 <dmhouse> Perhaps he was too busy to read it but wanted to let you know someone was alive at GHC HQ.
11:34:37 <allbery_b> I'm sure someone will read it.  commenting out the configure test and rerplacing with "if true; then" is not a committable patch :)
11:34:38 <dmhouse> Maybe the people he CC'd are people that might be willing to put in such a review.
11:34:46 <allbery_b> and, it's nto a ghc problem.  it's a port problem
11:35:28 <allbery_b> ports provides a minmal botstrap ghc to build the real ghc with.  it lacks ghc-pkg.  this breaks ghc/configure's assumptions about the state of the world
11:35:35 <allbery_b> "minimal bootstrap"
11:36:02 <pejo> allbery_b, did you file a pr for the package?
11:36:09 <allbery_b> put ghc-pkg back and it'll work properly like it does on gentoo portage or macports
11:36:12 <allbery_b> not yet
11:36:14 <dmhouse> Right, so what exactly do you want to happen?
11:36:29 <allbery_b> I'm checking the bug db right now to see what's there and what's pending
11:36:41 <pejo> allbery_b, if the problem is with the port, and it needs to be fixed there, wouldn't it be easier to mail those people instead?
11:36:44 <allbery_b> unfortunately, my assumption that 6.6 was in the queue was apparently unfounded
11:37:14 <allbery_b> my working assumption was that ghc-6.6 was waiting in the ports queue, so filing a patch against 6.4 wouldn't accomplish much
11:38:24 <allbery_b> I'm in the process of verifying that --- it seems to be false --- so will probably file a double PR, reporting the *actual* problem and requesting an upgrade to 6.6 (and probably a repocopy of 6.4.2 because of compatibility issues)
11:39:01 <allbery_b> meanwhile I posted to haskell@ a quick patch that gets things working, since over the past week people have been tripping over it and this lets them get things working
11:39:43 <allbery_b> (and since fbsd is in the middle of a release cycle any bug report will probably ntpo be processed in a timely matter; last I heard ports was still in release slush)
11:40:14 <bakert> hi folks.  i want to write a function called "turn" that takes a State record as a parameter, moves a few things about and returns an altered State parameter.  That works just fine.  Until I use a let in the function.  Is there something special about let and how it works?  can i not use it in a normal function?
11:40:40 <allbery_b> the syntaxz for let in a pure function is different from that in do-expressions
11:40:47 <allbery_b> do:  let foo = expr
11:40:54 <allbery_b> pure: let foo = expr in expr
11:41:02 <bakert> ah
11:41:20 <bakert> yes it is the "in" that i am missing.  that comes after the let declarations?
11:41:26 <allbery_b> yes
11:41:33 <bakert> brill.  thanks
11:41:55 <allbery_b> typically you do something like:  f x = let foo = ...; bar = ... in expr_using_foo_and_bar
11:42:03 <augustss> allbery_b: don't complain about responses to bug reports until you've supported a program with a large number of users and you get several bug reports per day.  and you don't even get paid for doing it :)
11:42:11 <allbery_b> (except you use layout instead of the semicolon)
11:42:24 <allbery_b> augustss:  I'm not complaining, I'm explaining
11:42:39 <augustss> ok :)
11:43:28 <allbery_b> I've *been* a ports maintainer, although not a very good one.  in this case I sent out a quick fix to the folks who want/need it now, and am following with proper bug reports that will be handled at the proper time (i.e. not during release slush)
11:43:52 <allbery_b> it's far too  late in the release cycle for it to have any chance of making 6.2-RELEASE
11:44:17 <allbery_b> (they're probably building the final packages for the release right now, in fact)
11:44:57 <allbery_b> hm, in fact, I'd been wondering about that, I think I was handling one of your programs :)  birda?
11:45:22 <allbery_b> (that or there are two of you :)
11:47:44 <augustss> birda is not really my code.  I just pacakged something Tommy Bohlin wrote.
11:48:01 <benja_> is yampa maintained?
11:49:03 <augustss> allbery_b: but you are probably using code I wrote right now :)
11:50:04 <mgsloan> hmm, I know null and _|_ are quite different, but is there some relationship, eg, _|_ is the more theoretically accurate null?  Hmm, maybe not since you can't even match it...
11:50:04 <lambdabot> mgsloan: You have 1 new message. '/msg lambdabot @messages' to read it.
11:50:36 <allbery_b> _|_ is not so much "null" as "error", I think
11:50:44 <mgsloan> yeah, and non-termination
11:50:52 <allbery_b> that's a form of error
11:50:56 <mgsloan> they seem to be a bit similar though
11:51:06 <augustss> mgsloan: null in what language?  Java?
11:51:09 <integral> "null" seems a bit like Nothing to me
11:51:14 <benja_> ?type null
11:51:14 <mgsloan> null is also often used as an error, just not very standardized
11:51:16 <lambdabot> forall a. [a] -> Bool
11:51:16 <benja_> :)
11:51:16 <allbery_b> ==integral
11:51:38 <augustss> null is very much like Nothing
11:51:39 <mgsloan> augustss: dunno, most languages treat null as a null pointer
11:51:44 <mgsloan> alright
11:52:09 <augustss> mgsloan: it's not like _|_ at all.  null is another well defined value
11:52:12 <allbery_b> in ths context "null" is an out-of-band value, and "error" is an exceptional condition representing program failure
11:52:22 <mgsloan> the difference is that by the very way Maybe is handled you don't really get into null troubles
11:52:52 <mgsloan> right, ok
11:52:53 <benja_> I suppose C, not having exceptions, might use 'null' in some cases where haskell might use 'error "foo"'
11:53:18 <benja_> and the haskell report thinks of 'error "foo"' as _|_
11:53:31 <benja_> but that's the closest relationship I can think of :)
11:53:38 <augustss> 'error "foo"' is more like abort() in C
11:53:54 <LoganCapaldo> null vs. Nothing is like in othe rlanguages everything is a Maybe a but Just values automatically get unboxed when theyare used
11:53:55 <benja_> ok
11:54:00 <benja_> (me doesn't really know C =))
11:54:03 * allbery_b is talking about concepts, not values
11:54:24 <augustss> C has _|_ too.  It's non-termination.
11:54:33 <mgsloan> dunno, there's a fairly large relationship - any pointered values include the possible values of their type + null, kinda like how _|_ is slapped on all data types
11:54:35 <LoganCapaldo> (At least in langs that have a java-esque null)
11:55:42 <augustss> mgsloan: there's a big difference between null and _|_.  if you look at the domain _|_ is attached below all regular values, whereas null is just another regular value (but with special properties, of course)
11:56:40 <Korollary> I see null references as Maybe NonnullRef. Nothing must be allowed for practicality reasons, but its existence may be a burden to check at times.
11:56:59 <mgsloan> yeah, I'm not saying they're one and the same.  I'd argue that null isn't a regular value though, it's 'attached below' because it's a special value of the pointer
11:57:19 <benja_> mgsloan: augustss means 'attached below' with the special meaning of denotational semantics
11:57:26 <mgsloan> ah, ok
11:57:37 <mgsloan> Yeah, I read that wikibooks page, I think I need to read it again ;p
11:58:41 <benja_> if 'a < b' and 'a < c' and (f a) returns something, then both (f b) and (f c) must return "the same thing or more"
11:59:41 <mgsloan> assuming the functions are monotone, and that < operator is that denotational semantics ordering thing
11:59:44 <benja_> e.g. _|_ < "foo" and _|_ < "bar", so if (f _|_ = 7 : 8 : _|_), then (f "foo") must be (7 : 8 : something) and (f "bar") must be (7 : 8 : possibly something else)
11:59:54 <benja_> mgsloan: yes
12:00:10 <augustss> mgsloan: in a standard denotational semantics null is not < nor > than any regular pointer.  whereas _|_ is less than all of them
12:00:44 <mgsloan> heh, well, in regular programming languages, null is indeed less than all regular pointers :)
12:01:01 <augustss> mgsloan: but not in the domain ordering
12:01:01 <mgsloan> assuming uint/ulong here :)
12:01:12 <benja_> which is the same thing as mgsloan said when saying that you can match null, but not _|_
12:01:23 <mgsloan> ah, alright
12:01:27 <benja_> that's the same thing as augustss said, I mean
12:02:37 <mgsloan> well, interesting
12:03:16 <benja_> :)
12:07:00 <bakert> Stylistic question for you guys
12:07:31 <glguy> : foldM
12:07:37 <bakert> Say you are writing a recursive function and you have a kind of "entry point" function which takes say 1 arg and then a function with an accumulator (that takes 2), what do you call the second one?
12:07:40 <glguy> :t foldM
12:07:41 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
12:07:50 * allbery_b refines the problem report some more (turns out ghc-pkg *is* there but they're patching things to use the bootstrap ghc uninstalled, and not doing the same with the call to ghc-pkg) and sends it off to the freebsd folks
12:08:24 <bakert> so in my card game i have a "end" function that takes the State record and tells me if the game is over or not.
12:08:43 <benja_> I usually either add ' or call the second one f
12:08:44 <bakert> but it needs to do some unpackaging of the various hands in the game and pass them to a routine that looks if any are empty lists
12:08:54 <benja_> but I'm not sure whether that's good style =)
12:09:05 <bakert> ah good.  i've called it end' -- but i wasn't really sure where i picked that up from
12:09:15 <benja_> I always put the second one in the first one's 'where' clause if possible
12:09:20 <bakert> oh
12:09:27 <bakert> i haven't really got to grips with where clauses
12:09:34 <bakert> that is a very useful hint
12:09:41 <benja_> :)
12:09:53 <bakert> so do they still need a name in a where clause?
12:09:58 <benja_> everything that is needed by only one function can go into the where clause of that function
12:09:58 <bakert> i guess so
12:10:02 <benja_> bakert: yes
12:10:24 <bakert> so i can say
12:10:27 <benja_> additionally, in a where clause you can refer to the parameters of the enclosing function
12:10:39 <bakert> end state = end' $ players state
12:10:52 <bakert>     where end' = blah
12:10:58 <bakert> ??
12:11:05 <bakert> is that indentation right?
12:11:07 <benja_> the way you described it, you want
12:11:13 <benja_>     where end' x y = blah
12:11:16 <benja_> but yes :)
12:11:21 <benja_> the indentation is ok
12:11:25 <benja_> so is,
12:11:25 <bakert> oh yeah
12:11:34 <benja_> end state = end' $ players state where
12:11:38 <benja_>     end' x y = blah
12:11:42 <bakert> is that more normal?
12:12:01 <bakert> to have the where on the end?
12:12:03 <benja_> bakert: I don't think there's a clear winner, I'd just pick what you like better
12:12:33 <bakert> i like that better.  using the where definitely neatens things up a good deal in my source file, too.
12:12:46 <bakert> it just keeps getting shorter!
12:13:07 <benja_> =)
12:13:26 <bakert> hmmm ... so where do "let" and "where" come apart?  they seem to be very similar ???
12:13:39 <bakert> are they equivalent in any way or am i getting tired?
12:13:40 <bakert> !
12:15:02 <benja_> they aren't quite equivalent syntactically, but you don't have to worry about the difference much
12:15:15 <benja_> where can only go at the end of function definitions, not in any expression
12:15:24 <benja_> and stuff declared in a where can be used in guards
12:15:35 <benja_> f x | x > y = True
12:15:39 <glguy> bakert: let .. in ...   is an expression
12:15:44 <glguy> where applies to declarations
12:15:49 <benja_>     | x == y = False
12:15:56 <benja_>   where y = blah
12:16:02 <glguy> where works over all the guards in a declaration
12:17:49 <bakert> Thanks for your help - I'll try out some examples and see if I've got it right.  I also have a namespace-y question if you're not all sick of me.  I have a type called State with an "attribute" (not sure of the actual word) called "players".  This brings a function called players into existence that I can use on a State record to get a list of players.  But when I get that out in a let I want to call the resulting value players!  Can
12:17:49 <bakert> I get away with this or will the compiler get confused?  And will I?  What's normally done?
12:18:08 <bakert> So I end up with
12:18:17 <bakert> let players = players state
12:18:27 <bakert> which is definitely a bit icky.
12:18:40 <benja_> bakert: IRC cut off your long line at "..value players! Can"
12:18:58 <benja_> you don't need to worry to upset people here by asking questions about Haskell, really you don't :)
12:19:07 <benja_> even by asking many questions :)
12:19:07 <pejo> Suppose you have a compiler with an untyped lambda-calculus as intermediate format, in a call-by-value setting. Does desugaring translate if cond then e1 else e2 to cond (\z.e1) (\z'.e2) (\x.x), to make sure that the legs aren't evaluated prematurely?
12:19:19 <bakert> benja_, that's a sign of something.  last bit was: Can  I get away with this or will the compiler get confused?  And will I?  What's normally done?
12:19:59 <benja_> bakert: let players = players state should not work
12:20:04 <bakert> benja_, thanks.  i just worry that my questions are VERY basic.  Haskell not so Googleable as some things though - I think largely because I don't know the search terms I should use.
12:20:08 <benja_> since lets are recursive
12:20:17 <bakert> ah
12:20:18 <bakert> ok
12:20:22 * allbery_b sends a response to SPJ et al. since he seems to have copied GHC folks on the assumption it's a GHC bug, not a FreeBSD ports bug
12:20:29 <benja_> e.g. you can have let ones = 1 : ones in ...
12:20:40 <benja_> and get an infinite list
12:20:47 <bakert> so i have to find a new name.  either for the attribute (what is the right word?) or for the temporary variable thingy.
12:20:53 <Korollary> pejo: Yes, although I am not sure what the \x.x at the end is for.
12:20:54 <bakert> (goddamn i need to get up on some terminology!)
12:21:27 <pejo> Korollary, a dummy value to get rid of the newly introduced lambdas?
12:21:41 <benja_> bakert: I guess you do need to find a new name for one of them, yes :)
12:21:51 <bakert> what about in other circumstances.  can i use the name players, or is it forever linked to the function for getting the players list out of my record and will namespace clash with any other use?
12:22:12 <benja_> (of course removing the temporary variable and giving the record variable a really short name may also be an option)
12:22:23 <bakert> i guess i can probably google "haskell namespaces" and get some answer to this.
12:22:38 <bakert> no, i'm wrong!
12:22:53 <benja_> bakert: definitions inside a 'let'/'where' clause and function parameter names and bindings inside 'do' can shadow definitions in outer scopes
12:23:11 <benja_> it may be confusing to make use of this, though :)(
12:23:19 <benja_> ghc warns about it when you turn on warnings
12:23:35 <Korollary> pejo: It depends on what cond really is. So it may be right.
12:23:38 <benja_> @where report
12:23:39 <lambdabot> http://www.haskell.org/onlinereport/
12:23:45 <bakert> ah well that's good. i think.  actually perhaps what i should do is put my type/record stuff in another module.  hmm i don't know.  or change my attribute names to something a bit longer/shorter.
12:24:01 <Korollary> bakert: we call them labelled fields.
12:24:40 <pejo> Korollary, doh, sorry. A boolean, \t.\f.t or \t.\f.f.
12:25:23 <Korollary> pejo: then you need no more than the two lambda-lifted branches. the id at the end seems unnecessary.
12:26:01 <Korollary> umm
12:26:02 <Korollary> no
12:26:03 <Korollary> I got it
12:26:07 <benja_> bakert: the word you mean is actually 'scope' not 'namespace' in haskell (although googling 'haskell scope' gives no dice)
12:26:15 <benja_> http://www.haskell.org/onlinereport/intro.html#sect1.4
12:26:16 <lambdabot> Title: The Haskell 98 Report: Introduction
12:26:25 <benja_> tells about 'namespaces'
12:27:07 <pejo> Korollary, thanks.
12:27:12 <benja_> unfortunately I don't know what to read to learn about haskell scope :-/
12:27:21 <benja_> I just sort of picked it up organically =)
12:30:36 <benja_> oooh I hadn't realized (or had forgotten) that different constructors of the same record type can share fields
12:30:41 <benja_> that's *neat*!
12:31:38 <bakert> i don't understand!  then again that's what i feel like every time anyone types anything on here or posts to the mailing list so no surprises!
12:31:43 <mbishop> ?seen alpheccar
12:31:43 <lambdabot> I saw alpheccar leaving #haskell 8h 9m 7s ago, and .
12:31:49 <bakert> ?seen bakert
12:31:49 <lambdabot> You are in #haskell. I last heard you speak just now.
12:31:52 <benja_> bakert: =)
12:32:09 <bakert> man i like those ? commands.  they are cool.
12:32:39 <benja_> you can have, data R = Foo { a :: String, b :: Int } | Bar { a :: String, c :: Float }
12:32:52 <benja_> so both 'variants' have a field 'a'
12:33:18 <bakert> crazy horses
12:33:22 <bakert> that is quite cool
12:33:28 <bakert> and potentially horrifically confusing!
12:34:24 <spiffy> thats when pattern matching helps keep everything sane =)
12:35:01 <benja_> :)
12:36:53 <spiffy> you can do some OO-like stuff with it
12:36:54 <bakert> i *do* like pattern matching.
12:37:13 <bakert> I've got "Non-exhaustive patterns in function end'"
12:37:25 <bakert> it IS nonexhaustive but i don't want it to cope with an empty list
12:37:37 <benja_> bakert: when you compile or when you run?
12:37:41 <bakert> does the fact that I get that error mean it IS being sent an empty list or is it just worrying in case it MIGHT
12:37:47 <bakert> (with runhaskell)
12:37:51 <benja_> oops =)
12:37:56 <benja_> I think it's runtime
12:38:07 <spiffy> func [] = error "Shutup complier"  ?
12:38:19 <bakert> spiffy, yes that works but I don't like it!
12:38:34 <spiffy> im curious to why?
12:38:39 <bakert> i'm still at the stage of hoping Haskell is going to be perfection so I can't allow stuff like that!
12:38:54 <benja_> i.e. I think it's that it is actually sent an empty list
12:38:54 <vegai> Hackage is broken, by the way: http://hackage.haskell.org/ModHackage/Hackage.hs?action=home
12:39:10 <bakert> yes i think it probably is benja_
12:39:19 <bakert> let me try and remove any such possibility and i'll see if it goes away.
12:39:25 <NichardRixon> oh man, I love haskell
12:39:29 <benja_> I think the compiler thing I remember is that it warns on overdefinitions
12:39:36 <benja_> like this:
12:39:39 <NichardRixon> I just got my head around how you can have a list that uses itself to generate itself
12:39:39 <benja_> f True = "foo"
12:39:43 <benja_> f False = "bar"
12:39:47 <benja_> f _ = "Baz"
12:39:48 <vegai> ...or they moved the real thing somewhere else and forgot to update the link from Cabal's home
12:39:49 <spiffy> you could try (temporarly) func [] = error "I got called"
12:39:59 <benja_> that makes the compiler warn because you can never get "Baz"
12:40:25 <bakert> yes.  it does get called.  i am a doofus.
12:40:28 <bakert> let me fix that!
12:40:37 <benja_> bakert: so you can still hope that haskell is perfection ;)
12:40:56 <benja_> that's because you don't understand the monomorphism restriction yet *hides*
12:41:23 <spiffy> hmmm not sure ive heard of that
12:41:26 <bakert> not only do i not understand the monomorphism restriction i don't even know what monomorphism means!
12:41:33 <benja_> =)
12:41:36 <pejo> -fno-monomorphism-restriction
12:42:08 <benja_> monomorphism is the opposite of polymorphism: every expression has exactly one type
12:42:32 <spiffy> i think i might have hit this one in defining a type class once.
12:42:40 <spiffy> it was a very broken type class.
12:42:41 <spiffy> lol
12:42:45 <bakert> but we have polymorphism of great goodness (according to the tutorials i've done).  they said (paraphrasing) "oooooh we're so much better than C++ ha ha ha!"
12:42:49 <benja_> in haskell, for example (+) has many types: Int -> Int -> Int, Double -> Double -> Double, Float -> Float -> Float
12:43:15 <benja_> if you write this:
12:43:19 <benja_> f x y = x + y
12:43:26 <benja_> then 'f' has all the same types as (+)
12:43:31 <benja_> but if you write this:
12:43:33 <benja_> f = (+)
12:43:42 <benja_> then 'f' has only a single type
12:43:49 <spiffy> ahhh
12:43:51 <benja_> because it doesn't look, syntactially, like a function
12:43:57 <benja_> (unless you give it a type signature)
12:44:09 <benja_> that's what I understand of the monomorphism restriction :)
12:44:12 <spiffy> f :: Num a doesnt do it?
12:44:23 <benja_> spiffy: that's not valid haskell :)
12:44:27 <benja_> but the idea is right
12:44:30 <bakert> so does the monomorphism restriction apply if you give everything a nice liberal type signature?
12:44:35 <benja_> f :: Num a => a -> a -> a is the ticket
12:44:40 <spiffy> thats the one
12:44:41 <bakert> or are you just talking about problems in type inference?
12:44:48 <Jaak> uh
12:45:09 <benja_> bakert: my understanding is that it doesn't affect you if you give everything a type signature
12:45:18 <bakert> then it's still perfect!  huzzah!
12:45:20 <benja_> but it's common not to give type signatures to stuff in 'where' clauses
12:45:24 <bakert> don't shatter my illusions this early!
12:45:28 <benja_> bakert: =)
12:45:39 <Jaak> i've always thought f x y = x + y and f = (+) are same in every way...
12:45:49 <pejo> bakert, the monomorphism restriction is a design choice, calling it  a problem is a bit harsh I'd say.
12:45:55 <benja_> Jaak: me too
12:46:01 <benja_> but they aren't :)
12:46:33 <Jaak> how?
12:46:54 <benja_> Jaak: in the way I explained above, f = (+) makes f non-polymorphic by default
12:47:10 <augustss> the MR is a wart, but there were some reasonable compelling reasons to introduce it
12:47:13 <benja_> for example, this will give a compiler error:
12:47:23 <Jaak> @type let f = (+) in f
12:47:24 <lambdabot> forall a. (Num a) => a -> a -> a
12:47:29 <benja_> (hmm)
12:47:48 <augustss> @let f = (+)
12:47:50 <lambdabot> Defined.
12:47:53 <augustss> @type L.f
12:47:54 <lambdabot> Couldn't find qualified module.
12:48:05 <augustss> bah
12:48:13 <benja_> foo = (f 1 2, f 1.0 2.0) where f = (+)
12:48:37 <benja_> (at least I *think* that it doesn't automatically convert the 1's to 1.0's or something =)
12:48:45 <Jaak> > let foo = (f 1 2, f 1.0 2.0) where f = (+) in foo
12:48:46 <lambdabot>  (3.0,3.0)
12:48:51 <Jaak> oh
12:49:05 <Jaak> strange
12:49:06 <benja_> > (1+2, 1.0+2.0)
12:49:07 <lambdabot>  (3,3.0)
12:49:13 <benja_> ok, so there you see the difference =)
12:49:20 <Jaak> yes, indeed
12:49:37 <benja_> > let foo = (f 1 2, f 1.0 2.0) where f x y = x + y in foo
12:49:38 <lambdabot>  (3,3.0)
12:49:58 <benja_> I got a compiler error because of something like this a few days ago and couldn't understand it
12:50:10 <bakert> Is this more than a theoretical problem?  Does it have any practical ramifications?  In my card game program, I now feel like I'm doing something wrong in the "turn" function.  EVERYTHING seems to be happening in the let clause and then there's just one line after the "in" where I package up a new state variable and send it back.  Is that common or am I subverting the true nature of Haskell doing it like that?
12:50:12 <Jaak> got to remember that
12:50:16 <augustss> > let foo = (f 1 2, f 1.0 2.0) where f = (+); f :: (Num a) => a -> a -> a in foo
12:50:18 <lambdabot>  (3,3.0)
12:50:31 <benja_> so a nice soul explained the monomorphism restriction to me and now I can pass the knowledge on =)
12:50:56 <bakert> ah yes ... you got an error from it a few days ago.  i long for the days when i am doing stuff like "f = (+)" -- that's cool.
12:51:41 <bakert> actually, I do have "forM xs f = mapM f xs" in my code
12:51:53 <bakert> which is sort of similar!
12:52:11 <bakert> ... so about my let thing ... can I get away with that?  or is that bad style/outright nonsense?
12:52:25 <bakert> (not that i'm just sucking your brains dry or anything!)
12:52:28 <benja_> bakert: yes, and you used to have "forM = flip mapM"
12:52:35 <bakert> sure did
12:52:44 <benja_> I told you to change it because of this =)
12:52:47 <allbery_b> if that's how it naturally falls out, go with it
12:52:50 <bakert> but some kind soul (you?) fixed it so it worked in hugs
12:53:02 <benja_> see, it's not just theoretical =)
12:53:14 * allbery_b hopes he hasn't just confused the issue more :)
12:53:49 <bakert> i'm going to try it with the mega-let then and let the dice fall where they may (actually they can't without a monad)
12:54:08 <benja_> bakert: long let with short in doesn't sound uncommon
12:54:13 <bakert> (i think i just made a haskell joke, but it might be wrong)
12:54:16 <bakert> ;)
12:54:23 <benja_> =)
12:54:43 <allbery_b> they can fall, you just can't observe them :)
12:54:52 <bakert> ;)
12:55:25 <bakert> pronunciation: monnn-add or moan-add?  i am at one-all so far.  seems to be from some greek implying monnnn but someone else said like nomad
12:55:30 <benja_> does a tree make a sound when it falls with no monad to make it observable?
12:56:33 <nostrademons> depends whether it evaluates to _|_ or not...
12:57:03 <nostrademons> or make that "hits _|_", for more of a pun
12:57:25 <Jaak> > let n = 1 in (n, n :: Double)
12:57:26 <lambdabot>  (1.0,1.0)
12:57:37 <allbery_b> my understanding is "monad" is pronounced like "nomad", i.e. long "o"
12:57:54 <Jaak> good that i tend to give everything a type dignature
12:58:04 <benja_> Jaak: :)
12:58:14 <Jaak> s/di/si
12:58:19 <bakert> thanks allbery_b that's 2-1!
12:58:19 <allbery_b> "dignature" seems to be calling for another _|_ joke :p
12:58:21 <benja_> you mean you dignify everything with them :)
12:58:37 <bakert> long let, short in ... definitely ...
12:58:39 <bakert> turn state =
12:58:40 <bakert>     let (currentPlayer:otherPlayers) = players state
12:58:40 <bakert>         currentHand = hand currentPlayer
12:58:40 <bakert>         discardPile = discard state
12:58:40 <bakert>         remainingPile = remaining state
12:58:42 <bakert>         (handAfterPickup, discardAfterPickup, remainingAfterPickup) = pickup XXX
12:58:43 <Jaak> :)
12:58:44 <bakert>         (handAfterPutDown, putDown) = putDown XXX
12:58:46 <bakert>         (handAfterDiscard, discardAfterDiscard) = discard XXX
12:58:48 <bakert>         newPlayer = currentPlayer { hand = handAfterDiscard }
12:58:49 <Jaak> whoa
12:58:50 <bakert>     in
12:58:52 <Jaak> @paste
12:58:52 <bakert>     state { players = otherPlayers ++ [newPlayer] }
12:58:53 <allbery_b> erm.  pastebin., please
12:58:56 <lambdabot> http://paste.lisp.org/new/haskell
12:59:24 <lisppaste2> bakert pasted "Long "let", short "in"" at http://paste.lisp.org/display/33790
13:00:11 <bakert> i guess that's pretty horrible looking code???
13:00:24 <pejo> bakert, wouldn't "turn state = state { players = otherPlayers ++ [newPlayer] }" RET where <...> be a lot clearer?
13:01:00 <bakert> well i'm having real difficulty working out how what when who about "where" and "let".  pointers gladly accepted
13:01:25 <benja_> bakert: you should usually use where when you can
13:01:27 <allbery_b> no, it's just impolite (and often confusing due to interleaving) to paste more than 3 lines directly into IRC
13:01:33 <allbery_b> that's what pastebins are for
13:02:07 <benja_> or, I mean, I think that's a good stylistic rule of thumb =)
13:02:20 <benja_> if you don't know whether to use where or let, use where if you can
13:04:15 <benja_> you might also consider using 'discard state' directly rather than giving it a new name
13:04:33 <bakert> benja_, thanks i'll try where-ifying this.
13:04:36 <benja_> but it's not horrible or anything =)
13:04:39 <bakert> what's discard state?
13:05:09 <benja_> bakert: that's what you put on the right-hand side of "discardPile = discard state" :-)
13:07:15 <bakert> oh sorry i see!
13:07:29 <bakert> i thought discard was some crazy new keyword/function!!!  it's one of mine!
13:08:05 <nostrademons> are discard/remaining/players fields of a record?
13:08:27 <psi> anyone doing euler project? it's pretty funny
13:09:24 <Jaak> great, gnome/x/whatever crashed
13:09:31 <psi> just solved 113. supposedly not very hard, but it took me nearly a day to see why my solution was wrong :)
13:09:43 <Jaak> 113.?
13:10:16 <psi> project euler, mathematical programming challenges
13:10:19 <psi> http://projecteuler.net
13:10:21 <lambdabot> Title: Project Euler
13:10:48 <Jaak> ooh nice
13:16:34 <bakert> nostrademons, yes fields of a record ("fields", not "attributes", always good to learn the right terminology!) great.
13:20:15 <bakert> hmm
13:20:34 <bakert> no ... unhmm ... worked it out!
13:32:40 <NichardRixon> psi, I love it :)
13:32:55 <NichardRixon> I've done 8 problems so far
13:33:10 <NichardRixon> it's an excellent way to teach myself haskell :)
13:33:48 <psi> yeah
13:34:25 <psi> are you currently doing a problem?
13:35:08 <NichardRixon> I'm starting on 17
13:35:23 <psi> my worst solution yet was #122. it took over 10 minutes to run.
13:35:50 <NichardRixon> ha
13:37:01 <psi> i think #17 would be trivial in common lisp
13:37:24 <psi> it has a standard function that gives a number in english
13:39:05 <psi> but of course it's not much of an exercise then
13:40:56 <LoganCapaldo> Do I just not know what "multiples" means?
13:41:11 <LoganCapaldo> Oh duh
13:41:49 <LoganCapaldo> "below" is a key word there
13:56:08 <glguy> psi: you have to modify it though, because CL uses the American convention for writting numbers
13:56:13 <glguy> and the problem uses the British one
13:58:46 <glguy> > let solve n = let next ys@(h:_) = [b:ys | a <- ys, let b=a+h, b <= n] in fromJust . find ((==n) . head) . concat . iterate (>>= next) in solve 15 [[2,1]]
13:58:48 <lambdabot>  [15,10,5,4,2,1]
13:59:52 <glguy> > let solve n = let next ys@(h:_) = [b:ys | a <- ys, let b=a+h, b <= n] in fromJust . find ((==n) . head) . concat . iterate (>>= next) in solve 99 [[2,1]]
13:59:54 <lambdabot>  [99,66,33,32,16,8,4,2,1]
14:03:02 <mauke> @remember xxd but 90% of programming is semantics
14:03:11 <glguy> ?quote sudo
14:03:12 <lambdabot> sudo says: You speak an infinite deal of nothing
14:03:23 <glguy> looks like ?quote has been modified
14:04:01 <glguy> ?quote
14:04:02 <lambdabot> skew says: I think blackdog is right
14:04:29 * glguy wonders what context makes that memorable
14:16:49 <jcreigh> @quote simon
14:16:49 <lambdabot> syntaxfree says: Many people think the core ideas behind Haskell came from academic luminaries such as Philip Wadler and Simon Peyton-Jones. What actually happened is that during a functional
14:16:50 <lambdabot> programming conference, some key academics were teleported to the Deep Complex Universe. In the Deep Complex Universe some Gnomes were having Tangling problems. Wadler & friends solved their
14:16:50 <lambdabot> problems and as a reward the Tangled Gnomes gave them the S
14:17:05 <jcreigh> rats. No "simon says:" :)
14:19:12 <astrolabe> @more
14:19:49 <sorear> I think it got cut off by the 512-char limit right before @remember.
14:21:56 <pejo> Do the distinguished dissertations in computer science-series force the authors to promise not to give out their thesis online?
14:22:18 <ibid> hyv uutta vuotta
14:22:18 <pejo> Or is it a mere coincidence that my google-fu is weak?
14:35:43 <sorear> @users
14:35:43 <lambdabot> Maximum users seen in #haskell: 309, currently: 273 (88.3%), active: 36 (13.2%)
14:41:19 <ksandstr> ibid: kiitos samoin.
15:01:01 <benja_> is the art of abstraction to bring two unconnected ideas together in a new way such as to make one of them seem completely boring? =-)
15:01:24 * benja_ 's new idea is "functional reactive programming in the state monad"
15:02:03 <benja_> which makes functional reactive programming look ... sorta ... like a big word for a small idea =)
15:02:12 <pejo> benja, have you seen Nordlander's thesis?
15:02:24 <benja_> nope
15:02:49 <benja_> any googlable words? =)
15:03:37 <pejo> benja, http://www.csee.ltu.se/~nordland/Thesis.pdf'
15:03:45 <pejo> Skip the ' there, slipped on the keyboard.
15:04:14 <benja_> thanks
15:05:04 <pejo> benja, http://www.csee.ltu.se/~nordland/ISORC.pdf is shorter, and more recent.
15:22:07 <benja_> hmm, what I'm thinking of is a lot closer to yampa at all than this seems to be
15:22:59 <pejo> benja, aha. Yeah, the approach is different.
15:24:27 <benja_> I should study this, but not today =)
15:24:44 <benja_> thanks for the pointer, anyway :)
15:25:09 * allbery_b tries to evolve from State s a to StateT s IO a
15:27:22 <augustss> adding IO should be considered devolving ;)
15:27:25 <benja_> you mean change code using the first to use the second?
15:27:31 <benja_> what's the difficulty?
15:29:27 <sorear> So you have a State s a and you need to use it in a StateT s IO a context?
15:30:26 <sorear> Natural transformations <bemoan fact they are not standard> can pretty easily get you from StateT s Identity a to StateT s IO a.
15:30:32 <mauke> @hoogle maximum
15:30:33 <lambdabot> Prelude.maximum :: Ord a => [a] -> a
15:30:33 <lambdabot> List.maximumBy :: (a -> a -> a) -> [a] -> a
15:30:33 <lambdabot> Data.List.maximumBy :: (a -> a -> Ordering) -> [a] -> a
15:30:37 <allbery_b> I have code using State s a, which is fine in one module which is pure code
15:30:58 <allbery_b> in another module that wants to use it, it needs to thread the state through IO.  it's currently done manually, so I lose all the advantages of State
15:31:44 <benja_> so change the type signatures to StateMonad m => m s a?
15:31:47 <allbery_b> (i.e. I end up passing the state around and doingrunState all over ple place)
15:31:54 <allbery_b> erp
15:31:55 <benja_> s/StateMonad/MonadState/
15:32:05 <allbery_b> (i.e. I end up passing the state around and doing runState all over the place)
15:32:21 <allbery_b> it's clearly the Wrong Way to do it
15:32:21 <sorear> that (MonadState) is the Standard Way...
15:33:34 <allbery_b> I think maybe I'm nt being clear.  the current code can't just be chanegd by changing types; it's doing manual state threading, in effect not using the State monad at all
15:33:50 <benja_> allbery_b: oh, like how?
15:33:53 <allbery_b> it needs to be rewritten to actually use the monad
15:34:35 <sorear> Module A has type 'State Foo Bar', Module B has type StateT Foo IO Bar'  -- correct?
15:34:45 <sorear> Module A has type 'State Foo Bar', Module B has type 'StateT Foo IO Bar'  -- correct?
15:35:02 <allbery_b> showZH :: RealFloat a => ZemanState a -> a -> a -> (String, ZemanState a)
15:35:16 <sorear> ouch
15:35:18 <benja_> ok
15:35:23 <allbery_b> it's tossing the raw state aroubnd instead of using a state monad to do it, because it's mixing with IO actions
15:35:39 <sorear> use the State/StateT constructor
15:35:43 <sorear> :type State
15:35:48 <sorear> ?type State
15:35:48 <allbery_b> the fix is to use StateT s IO a instead and actually *use* the monad
15:35:49 <ski> :t State
15:35:49 <lambdabot> forall a s. (s -> (a, s)) -> State s a
15:35:50 <lambdabot> forall a s. (s -> (a, s)) -> State s a
15:35:51 <allbery_b> yes, I know
15:36:18 <allbery_b> did hit a complication though, I have functions which want to return a String and the StateT's "base type" is RealFloat a => a
15:36:27 <sorear> so you can package a state transformer in an action painlessly using the exported constructor
15:36:41 <allbery_b> and others that want to return IO String same way
15:36:51 <ski> showZH :: RealFloat a => a -> a -> State (ZemanState a) String
15:37:05 <ski> yes ?
15:37:33 <allbery_b> presumably.  except I was trying to hide the ZemanState in the new design. guess that won't work :(
15:37:35 <sorear> ?type fmap (fmap State)
15:37:36 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) s a. (Functor f, Functor f1) => f (f1 (s -> (a, s))) -> f (f1 (State s a))
15:38:09 <sorear> ?type fmap (fmap State) :: (a -> b -> s -> (c, s)) -> a -> b -> State s c
15:38:10 <lambdabot> (a -> b -> s -> (c, s)) -> a -> b -> State s c :: forall a b s c. (a -> b -> s -> (c, s)) -> a -> b -> State s c
15:38:18 <sorear> ah good
15:38:27 <ski> newtype Foo a b = F (State (ZemanState a) b) deriving Monad  -- ?
15:38:42 <sorear> fmap's are in the (->) a monad here
15:39:08 <allbery_b> (was using an exported type synonym ZemanS a = StateT (ZemanState a) IO a so I could hide the ZemanState --- on second thought maybe I can just use ZemanS String)
15:39:23 <allbery_b> ssince they type doesn't have the RealFLoat constraint on it
15:39:48 <allbery_b> hrm, but the ZemanState does, never mind.  oh well
15:42:06 <dino-> Can someone help me, how do you read this (particulary the | m -> s part)?  class Monad m => MonadState s m | m -> s where
15:42:19 <sorear> that's a fundep
15:42:24 <hyrax42> :t Data.Map.fromList
15:42:25 <sorear> functional dependency
15:42:26 <lambdabot> forall a k. (Ord k) => [(k, a)] -> Data.Map.Map k a
15:42:35 <sorear> it means that m determines s
15:42:53 <sorear> the type of the Monad determines the type of the State
15:43:08 <hyrax42> > Data.Map.fromList [(x,y) | x <- [1..], y <- [2..]]
15:43:09 <lambdabot>  Not in scope: `Data.Map.fromList'
15:43:13 <sorear> every stateful monad has one type of state
15:43:17 <ski> it means that 'instance MonadState S0 M' and 'instance MonadState S1 M' is not allowed (since 'S=' is not the same as 'S1')
15:43:27 <ski> (s/=//)
15:43:42 <ski> (er s/=/0/)
15:43:49 <sorear> ?hoogle Ord a => [(a,b)] -> Map a b
15:43:50 <lambdabot> Data.Map.fromList :: Ord k => [(k, a)] -> Map k a
15:43:50 <lambdabot> Data.Map.fromListWith :: Ord k => (a -> a -> a) -> [(k, a)] -> Map k a
15:43:50 <lambdabot> Data.Map.fromListWithKey :: Ord k => (k -> a -> a -> a) -> [(k, a)] -> Map k a
15:44:05 <hyrax42> > M.fromList
15:44:06 <lambdabot>  Add a type signature
15:44:08 <sorear> hyrax: it's imported as M
15:44:13 <ski> for any particular 'm' in that class, there should be eaxctly one such 's'
15:44:25 <sorear> not 0, not 2
15:44:29 <hyrax42> > M.fromList [(x,y) | x <- [1..], y <- [2..]]
15:44:33 <lambdabot> Terminated
15:44:36 <ski> dino- : understand ?
15:45:04 <hyrax42> > take 10 $ M.elems $ M.fromList [(x,y) | x <- [1..], y <- [2..]]
15:45:08 <lambdabot> Terminated
15:45:11 <allbery_b> the types are uglier with the state wrtten out :(  oh well
15:45:27 <dino-> sorear, ski: Well, not exactly why it's like that. But I can get that it's just that way, what you said above, that 'for any particular m'
15:45:32 <augustss> hyrax42: your map is doubly infinite
15:45:43 <hyrax42> augustss: yeah, I know
15:46:12 <augustss> hyrax42: it won't work
15:46:22 <hyrax42> augustss: I realise now :)
15:46:33 <augustss> the map needs to be finite
15:47:16 <dino-> I will hang onto what you guys just said about it and keep studying.
15:47:28 <hyrax42> > take 10 $ M.elems $ foldr M.insert M.empty [(x,y) | x <- [1..], y <- [2..]]
15:47:29 <lambdabot>    Expecting a function type, but found `b'
15:47:29 <lambdabot>    Expected type: a1 -> Data...
15:47:56 <hyrax42> :t Data.Map.insert
15:47:58 <lambdabot> forall a k. (Ord k) => k -> a -> Data.Map.Map k a -> Data.Map.Map k a
15:48:28 <mauke>  Warning: mysql_connect(): Lost connection to MySQL server during query in /mounted-storage/home15b/sub001/sc17392-BXBG/projecteuler.net/index.php on line 65
15:48:31 <mauke> great
15:48:36 <dino-> Thank you.
15:49:13 <hyrax42> > take 10 $ M.elems $ foldr (\x y m -> M.insert x y m) M.empty [(x,y) | x <- [1..], y <- [2..]]
15:49:14 <lambdabot>    The lambda expression `\ x y m -> ...' has three argumentss,
15:49:15 <lambdabot>   but its...
15:49:19 <sorear> yw.
15:49:44 <hyrax42> > take 10 $ M.elems $ foldr (\(x, y) m -> M.insert x y m) M.empty [(x,y) | x <- [1..], y <- [2..]]
15:49:47 <lambdabot>  Exception: stack overflow
15:49:58 <hyrax42> boo
15:51:16 <psi> glguy, what's the difference?
15:59:11 <ski> dino- : one reason is to avoid ambiguity .. see http://www.haskell.org/hawiki/FunDeps
15:59:12 <lambdabot> Title: FunDeps - The Haskell Wiki
15:59:36 <ski> another reason is that some class method signatures is not allowed otherwise
15:59:42 <ski> if you have
15:59:46 <ski> class Foo a b c
15:59:48 <ski>   where
15:59:52 <ski>   foo :: ...
15:59:53 <allbery_b> now I gotta reengineer the whole main loop.  ah well, it'll be cleaner
16:00:02 <allbery_b> was abusing a fold to thread the state around manually
16:00:15 <ski> then the '...' type must mention all of the 'a','b','c' type variables
16:02:14 * ski tries to think of a concrete example
16:02:41 <ski> well, take a class of collections :)
16:02:48 <ski> class Coll coll elem
16:02:51 <ski>   where
16:02:57 <ski>   empty :: coll
16:03:07 <ski>   insert :: elem -> coll -> coll
16:03:22 <ski>   merge :: coll -> coll -> coll
16:03:29 <ski>   ...
16:04:30 <ski> if you say 'empty' in your code somewhere, the surrounding code can tell what particular 'coll' type you have in mind
16:04:45 <ski> but it can't guess what 'elem' type you have in mind
16:04:53 <ski> you could e.g. have
16:05:14 <ski> instance Coll [Integer] Integer
16:05:17 <ski> as well as
16:05:37 <ski> instance Coll [Integer] Int  -- for convenience, say
16:06:17 <hyrax42> dino-: fundeps made no sense to me
16:06:22 <ski> if you say 'empty :: [Integer]' there's no way for it to determine which instance it should use .. i.e. what 'elem' should be
16:06:28 <hyrax42> until I came across a situation where they were the solutin
16:06:33 <hyrax42> *~ion
16:06:40 <ski> so, solution is to say
16:06:54 <ski> class Coll coll elem | coll -> elem
16:06:55 <ski>   where
16:06:56 <ski>   ...
16:07:27 <ski> the 'coll -> elem' means that if you happen to know 'coll', there should be only one possible 'elem' .. i.e. 'coll' determines 'elem'
16:07:41 <ski> dino- : not sure if this helps ..
16:12:23 <calvins_> I notice that the haskell irc wiki page points says to paste to a wiki page. Is the old paste location no longer used?
16:13:39 <sorear> you paste to
16:13:40 <calvins_> oh, actually, i guess that was an old version of the wiki, which pointed to the new page
16:13:42 <sorear> @paste
16:13:43 <lambdabot> http://paste.lisp.org/new/haskell
16:13:53 <calvins_> sorear: thanks, that's what i was looking for
16:13:55 <sorear> the old wiki is invalid and obsolete
16:14:04 <sorear> and should really be deleted soon
16:14:45 <sorear> oh, and thanks for the phrasing - HaskellIrc is a dead givaway
16:18:08 <sorear> why don't the people who spam lisppaste ever hit /new/haskell ?
16:18:48 <lisppaste2> calvins pasted "Sporadic Redrawing Problems" at http://paste.lisp.org/display/33795
16:19:16 <calvins_> I just pasted an exercise solution from Hudak's Haskell School of Expression.
16:19:35 <calvins_> main4 displays an image of a snowflake fractal.
16:19:43 <calvins_> It requires HGL.
16:20:22 <calvins_> My issue is that I sometimes see some strange drawing issues, where part of the image will be displayed, and then it pauses indefinitely until I press any key or move the mouse around.
16:21:04 <calvins_> Any ideas what causes this behavior? Sometimes it works perfectly fine and renders the complete image with no issues, and sometimes it stops after every few stars are drawn.
16:22:33 <calvins_> sorear: the old wiki page was the first google result for haskell irc, so that's how I found that old page.
16:23:20 <sorear> yikes!
16:24:46 <Cale> calvins_: hmm
16:24:53 <Cale> how often does it happen?
16:24:59 <calvins_> Oh, a little more info about the drawing issue: if I change the minSize to a higher value (so it recurs less), then it doesn't happen.
16:25:33 <calvins_> Cale: when I start a new ghci, it usually works perfectly a few times..
16:26:04 <calvins_> Cale: but then it will start to pause sometimes (anywhere from a couple of times to 20 or so times in the course of rendering the entire image).
16:26:24 <Cale> oh, yeah, I'm getting that too
16:26:43 <Cale> focusing the window seems to make it continue though
16:26:59 <Cale> hmm, and I get a message "thread blocked indefinitely"
16:27:09 <calvins_> yeah, i get that message sometimes too
16:27:36 <calvins_> and same focusing behavior -- that's what i meant by moving the mouse, but typing any key but space does the same thing too
16:27:45 <mauke> @hoogle [a] -> [[a]]
16:27:46 <lambdabot> List.inits :: [a] -> [[a]]
16:27:47 <lambdabot> List.tails :: [a] -> [[a]]
16:27:47 <lambdabot> List.group :: Eq a => [a] -> [[a]]
16:28:11 <calvins_> maybe i'll try to track down a hgl bugtracker and post a bug to see if they know what causes it...
16:29:40 <allbery_b> w00t
16:29:56 <allbery_b> I'm sure the code could be cleaner, but it's already enormously nicer than it was
16:30:08 <psi> is "508" "five hundred eight" or "five hundred and eight"
16:30:22 <Cale> both
16:30:37 <Cale> I usually say it the second way
16:31:41 <psi> okay, and i'm pretty sure the second way is correct here.
16:32:22 <lisppaste2> jcreigh annotated #33401 with "final version" at http://paste.lisp.org/display/33401#3
16:32:51 * jcreigh just posted his toy regex engine @ http://jcreigh.blogspot.com/2006/12/simple-regex-engine-in-haskell.html
16:32:53 <lambdabot> Title: Jason Creighton's Blog: A simple regex engine in Haskell, http://tinyurl.com/y6jylk
16:33:18 <jcreigh> any suggestions or comments?
16:38:00 <calvins_> Cale: that redraw bug occurs in ghc only (both interpreted and compiled). hugs handles it perfectly every time. Do you think I should report this to ghc as a bug?
16:45:02 <dons> morning all
16:45:08 <dons> ?uptime
16:45:08 <lambdabot> uptime: 13h 5m 53s, longest uptime: 9d 2h 23m 6s
16:45:46 <sorear> morning
16:47:07 <Cale> calvins_: Perhaps post to the libraries or haskell-cafe mailing list about it, maybe someone more familiar with the libraries will be able to work it out.
16:49:08 <Cale> metaperl: have a look at the arrows website :)
16:49:36 * metaperl visits
16:52:36 <dons> ?remember apfelmus Haskell is the first programming language that really offers the possibility to specify data dependencies exactly as they are because Haskell is pure, higher order and has a powerful type system.
16:52:48 <calvins_> Cale: thanks, I sent something to Alastair Reid (HGL procedure for possible bugs), and will send to haskell-cafe too.
16:55:01 <hyrax42> :index unsafePerformIO
16:55:15 <hyrax42> ?index unsafePerformIO
16:55:15 <lambdabot> System.IO.Unsafe, Foreign
16:57:26 <dons> you up to something, hyrax42 ?  ;)
16:58:21 <sorear> you really ought to use rot13 on things like that
16:58:29 <dons> so, what exciting code are people hacking on today?
17:00:07 <hyrax42> lol
17:00:17 <hyrax42> as unlikely a thing as you'd need unsafePerformIO for
17:00:21 <hyrax42> project Euler
17:00:23 <hyrax42> in bed
17:00:25 <hyrax42> at 5am
17:00:28 <hyrax42> :/
17:00:33 <Botje> I solved 20 or 30 of project euler's today
17:00:49 <hyrax42> I have a 1000-digit number in a textfile...
17:01:01 <mauke> is it bad that I just code a naive brute-force algorithm and let it run for a few hours?
17:01:12 <Botje> i also learned that haskell sucks at generating prime numbers
17:01:26 <Botje> hyrax42: is it the one with 5-digit products? tails is your friend :)
17:01:34 <hyrax42> I'm a bit miffed that my list comprehension solution to no. 2 is bery bad
17:01:36 <hyrax42> Botje: yup
17:01:38 <mauke> what's the problem id?
17:01:41 <hyrax42> zip5 and tails
17:01:42 <emu> so, how is Haskell lookin in 2007
17:02:14 <hyrax42> mauke: which?
17:02:24 <sorear> ?localtime dons
17:02:25 <mauke> for the problem you're discussing
17:02:26 <lambdabot> Local time for dons is Mon Jan  1 11:55:34 2007
17:02:31 <dons> emu, pretty exciting, in my view
17:02:39 <hyrax42> well I mentioned two...
17:02:50 <emu> maybe possibility of H'07? =)
17:02:53 <hyrax42> the 5-digit products is 8
17:02:57 <dons> mm, reminds me there's a 16 core haskell server waiting at my office to be unpacked...
17:03:18 <hyrax42> the one where I had to do explicit accumulator recursion when i don't think I should have is 2
17:03:30 <hyrax42> oh maybe because hugs doesn't fuse
17:03:52 <hyrax42> is Prelude.sum = foldr (+) 0?
17:04:02 <psi> #2 is instant for me
17:04:13 <mauke> my solution for 2 is http://rafb.net/p/9EaK7996.html
17:04:14 <lambdabot> Title: Nopaste - No description
17:04:24 <hyrax42> psi: accumulator or list comprehension?
17:04:36 <emu> hyrax42: i'd think foldl'
17:04:47 <dons> hmm, I think its foldr. let me see...
17:04:57 <dons> since we want it to fuse
17:05:04 <emu> but maybe it doesn't matter since (+) is strict
17:05:15 <psi> hyrax42, same a mauke
17:05:24 <hyrax42> anyway, hugs and ghci/interpreted don't fuse
17:05:31 <mauke> 8: http://rafb.net/p/zQ5KLz47.html
17:05:32 <lambdabot> Title: Nopaste - No description
17:05:32 <hyrax42> I think that's why it was slow
17:05:47 <dons> sum                     =  foldl (+) 0
17:05:48 <dons> product                 =  foldl (*) 1
17:06:19 <dons> (ghc uses an unfolded definition of this)
17:06:38 <psi> #14 is giving me stack overflow
17:06:45 <psi> haven't solved it yet
17:07:49 <mauke> print $ maximumBy (\(_, a) (_, b) -> compare a b) $ map (\n -> (n, coll n)) [1 .. 999999]
17:07:57 <metaperl> Cale - http://haskell.org/arrows/syntax.html - sa-weet!
17:07:58 <lambdabot> Title: Arrow syntax
17:08:42 <hyrax42> psi, mauke: do you compile yours with -O?
17:09:08 <psi> hyrax42, usually i run in ghci
17:09:23 <psi> mauke, what's that?
17:09:26 <hyrax42> and no.2 is instant?
17:09:32 <psi> yes
17:09:34 <mauke> hyrax42: -O2
17:10:28 <mauke> psi: 14
17:10:47 <dons> I'd definitely use -O for these maths problems, if they take more than a few seconds
17:11:23 <psi> mauke, coll is?
17:11:39 <mauke> coll 1 = 1; coll n = 1 + coll (if even n then n `div` 2 else 3 * n + 1)
17:11:41 <hyrax42> hm
17:11:51 <hyrax42> that is weird
17:11:57 <hyrax42> the list comprehension version
17:12:11 <hyrax42> sum [x | x <- fibs, x < 1000000, even x] takes forever
17:12:14 <hyrax42> at least in hugs
17:12:27 <hyrax42> but the filter/takewhile is snappy
17:12:34 <hyrax42> would have thought they'd be the same
17:12:48 <mbishop> heh, haskell is used by the #5 guy on project euler
17:12:52 <Botje> hyrax42: how is haskell supposed to know fibs is an ascending list?
17:13:02 <dons> is Mr. #5 glguy?
17:13:12 <hyrax42> Botje: arrrtrgghg
17:13:17 <psi> glguy is called glguy i think
17:13:22 <dons> or someone else here (we've had a few people make serious attempts at tit)
17:13:29 <dons> /it/
17:13:34 <psi> :)
17:13:44 <hyrax42> I'm calling it a night....
17:13:52 <mbishop> glguy is #57 :P
17:14:01 <sorear> oh, I'd call it a list :)
17:14:02 <dons> oh, who's #5 then?
17:14:10 <mbishop> "daniel.is.fischer"
17:14:25 <dons> hmm, the name sounds familiar
17:14:56 <hyrax42> Botje: thanks, complete failure of logic on my part
17:14:58 <mauke>  Your current rating is 22% genius and you are ranked 396 out of 1757 active users
17:15:29 <hyrax42> the set-builder-like notation makes things like that a little too easy, I suppose
17:15:42 <hyrax42> "You are now running on reserve battery power"
17:15:49 <hyrax42> something is trying to tell me something
17:16:01 <hyrax42> night
17:16:19 <mbishop> Oh wow, no one using Lisp at all? weird
17:16:21 <dons> ah yes, I've seen daniel fischer on haskell-cafe
17:17:44 <mbishop> lots of people using haskell heh
17:18:39 <mbishop> Ah, it's "LISP" on the site, and apparently it's any lisp heh
17:19:14 <hyrax42> well they're not no. 5 whoeve they are
17:19:16 <hyrax42> but tied no. 1
17:19:21 <hyrax42> having solved all problems
17:19:37 <sorear> LISP is capitalized on my PL book too
17:23:04 <psi> ?paste
17:23:04 <lambdabot> http://paste.lisp.org/new/haskell
17:24:19 <lisppaste2> psi pasted "PO: #13 -- incorrect and really slow!" at http://paste.lisp.org/display/33796
17:25:19 <psi> mauke, i said #14 by mistake, i meant #13
17:25:44 <psi> i don't know why my solution is incorrect. slow i can understand.
17:26:24 <mauke> 13 is  Work out the first ten digits of the sum of the following one-hundred 50-digit numbers.
17:26:46 <mauke> 14 is  Which starting number, under one million, produces the longest chain?
17:27:00 <mauke> not "what is the maximum length of any chain?"
17:27:14 <psi> ack!
17:27:36 <mauke> so, maximumBy
17:29:07 <sorear> see also comparing
17:29:13 <sorear> ?type comparing
17:29:15 <lambdabot> Not in scope: `comparing'
17:29:28 <sorear> <checks 6.6 docs>
17:30:22 <rahikkala> comparing f x y = compare (f x) (f y) -- iirc
17:30:32 <sorear> Data.Ord.comparing :: Ord a => (b -> a) -> b -> b -> Ordering
17:33:11 <newsham> dual core offers speedup because one core can run all the adware on your machine
17:33:34 <mauke> snd . maximumBy (comparing fst) . (lol >>= (,))
17:35:40 <jcreigh> hmm, Project Euler is kind of interesting. I'm now "1% genius".
17:36:26 <dons> newsham: heh
17:37:23 <lisppaste2> sorear pasted "my take on smaller-regex-engine" at http://paste.lisp.org/display/33797
17:38:14 <dons> sorear: did you see the mini regex engine we wrote for the shootout last year?
17:38:23 <jcreigh> sorear: Thanks. I thought about using that approach.
17:38:47 <psi> i wonder why so many swedish people have signed up for project euler
17:39:29 <sorear> dons: no
17:39:54 <jcreigh> I'm just about to link to sorear
17:40:05 <jcreigh> ...'s paste from my blog. Did anybody else take a stab at it?
17:40:13 <dons> ?pl timesN n = map (*n)
17:40:14 <lambdabot> timesN = map . (*)
17:40:50 <sorear> especially note what I did to range - pattern matches give us multiple assignment for free.
17:41:26 <jcreigh> ohh, shiny
17:41:31 <dons> so what lambdabot features do people want to see today?
17:41:45 <dons> i'm in a bit of a bot hacking mood
17:41:54 <nornagon> magical solving of any problem presented!
17:42:04 <sorear> observation: loggrep subsumes quote
17:42:23 <dons> sorear: almost
17:42:28 <sorear> just search for @remember
17:42:33 <dons> what if they're blog quotes that are @rememberd
17:42:44 <dons> ah that's right, i was going to add @view
17:42:54 <dons> which shows the src for selected functions
17:43:00 <dons> (if they're < 4 lines or so)
17:43:15 <newsham> ?elite hack me
17:43:15 <lambdabot> h4(k /\/\E
17:43:16 <sorear> @view GHC.Handle.hSetBuffering
17:43:17 <lambdabot> Math is hard. Let's go shopping.
17:43:31 <newsham> all about math being hard:  http://youtube.com/watch?v=MiMWJ1xBo8w
17:43:46 <dons> maybe not that one, sorear   ;)
17:43:55 <sorear> the source of hSetBuffering is ~50 lines, shame
17:43:57 <dons> I was thinking more prelude/list/monad/
17:43:58 <dfranke> is that Finite Simple Group of Order 2?
17:44:01 <jcreigh> It would be nice to have a @findstandard (or whatever) that took a function and magically determined whether or not there was a builtin function that did the same thing. (ie, find builtin functions with same type signature, and do something magic (quickcheck?) to see if they're the same.)
17:44:08 <sorear> dons: any other reason why not?
17:44:31 <dons> jcreigh: yeah, we've thought a bit about this
17:44:55 <sorear> @pl should have a cleverness option
17:44:55 <lambdabot> should have a cleverness option
17:44:58 <dons> or at the minimum, give some iput/output pairs, and use quickcheck to find something that matches
17:45:08 <jcreigh> eg:
17:45:14 <jcreigh> @findstandard mymap f l = foldr (\x xs -> f x : xs) [] l
17:45:14 <lambdabot> Unknown command, try @list
17:45:24 <sorear> Use H98 funcs, use GHC-HEAD funcs, use all funcs, use SKI only, etc
17:45:36 <dons> yeah, that'd be nice
17:45:53 <dons> i.e. no-(-> a) monad optoin
17:46:45 <sorear> likewise, @unpl should to type inference and recognize the (->) a monad.  <evil grin>
17:47:01 <mauke> @. pl . djinn type \f l -> foldr (\x xs -> f x : xs) [] l
17:47:03 <lambdabot> (line 1, column 1):
17:47:03 <lambdabot> unexpected "-"
17:47:03 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
17:47:18 <sorear> djinn doesn't do [a].
17:47:26 <mauke> oh, right
17:48:21 <dmhouse> Are there any structures that support O(1) member checking? I care about barely anything else.
17:48:42 <mauke> hash, trie (kind of)
17:48:55 <dmhouse> Hash as in Map?
17:49:04 <sorear> as in Data.HashTable
17:49:28 <dylan> I wonder if an O(1) set is possible.
17:49:56 <dmhouse> HashTable is impure, eww.
17:50:25 <sorear> yes, a pure hashtable is like a pure array - o(1) access, o(n) updates
17:50:58 <mauke> @hoogle [[a]] -> [a]
17:50:59 <lambdabot> Prelude.concat :: [[a]] -> [a]
17:50:59 <sorear> you *could* write a pure hashtable, and send it to the base maintainers for many karma points
17:51:26 <nornagon> ?djinn [[a]] -> [a]
17:51:26 <lambdabot> -- f cannot be realized.
17:51:27 <nornagon> oh
17:51:29 <dmhouse> Data.Set and Data.Map both have O(log n) member checking, which seems to be as good as it'll get.
17:51:31 <nornagon> d'oh. :)
17:51:41 <dmhouse> sorear: what kind of structure is a hashtable?
17:51:53 <mauke> an array (of lists)
17:52:28 <jcreigh> sorear: hmm... is the type of "matches" correct in your version? And do you define "alt" anywhere?
17:52:54 <dylan> > concat [[1,2,3]]
17:52:54 <newsham> array of bits O(1)
17:52:55 <lambdabot>  [1,2,3]
17:52:56 <sorear> alt = choice
17:53:09 <newsham> can you represent your set members with bits?
17:53:36 <mauke> > (concat . transpose) ["foo","bar","baz"]
17:53:37 <lambdabot>  "fbboaaorz"
17:53:47 <sorear> you're right, my type of  matches is bogus
17:54:51 <rds> @help
17:54:51 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:56:32 <sorear> dons: now that the @list output is so short, how about folding it into @help help?
17:56:54 <nornagon> ?list
17:56:54 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
17:57:04 <sorear> dons++ mkcabal rocks
17:57:30 <nornagon> ?where cabal
17:57:30 <lambdabot> http://www.haskell.org/cabal
17:57:55 <sorear> @where mkcabal
17:57:55 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/mkcabal
17:57:59 <dons> sorear: we should finish it off though
17:58:07 <bd_> sorear: <late> what about a pure hashtable based on DiffArray?
17:58:17 <dons> i.e. dump licenses into the 'LICENSE' file where appropriate, and fix quoting issues
17:58:38 <dons> http://programming.reddit.com/info/wlcl/comments
17:58:40 <lambdabot> Title: Thoughtful distributed version control (reddit.com)
18:00:25 <sorear> How portable is debconf?
18:01:24 <sorear> I've got this feeling like it probably won't work on windows, but it does seem like The Solution to mkcabal's input problems...
18:01:47 <dons> what are mkcabal's input problems?
18:01:56 <dons> quoting? (easy to fix...)
18:02:15 <sorear> inconsistant quoting, unable to go back, can't prespecify things, etc.
18:02:16 <dons> also, have you looked at JoinCabal?
18:02:22 <dons> maybe we could merge the two
18:02:32 <sorear> maybe a Haskell clone of debconf would be good
18:02:36 <dons> yeah, i've got a plan for command line flags to specify things
18:02:42 <sorear> @where JoinCabal
18:02:43 <lambdabot> I know nothing about joincabal.
18:02:44 <dons> and a consistent quoting mechanism
18:03:00 <dons> its really only 50 loc to finish it off nicely...
18:03:23 <sorear> I've got a brand new ghc, trying to test debugger:
18:03:29 <sorear> Prelude> let x = x   Prelude> @print x
18:03:36 <sorear> parse error!
18:03:58 <sorear> oooh, closure viewer works - neat
18:03:58 <Jaak> @print?
18:03:59 <lambdabot> pointful module failed: IRCRaised Lib/Pointful.hs:38:24-51: Non-exhaustive patterns in lambda
18:04:28 <sorear> it should be :print
18:04:29 <dons> sorear: there's a case to fail a bit more gracefully ^^
18:04:41 <psnl> happy new year, guys
18:04:54 <psnl> and girls, and lambdabot
18:05:11 <sorear> I'd also like to mention, that starting the day after tomorrow, I have high school obligations...
18:05:29 <newsham> lambdabot lives in the future.. its been new years there for a while
18:05:37 <dons> ah hehe ok.
18:06:01 <emu> why do so many blogs leave huge margins... like 60% of the screen is margin
18:06:09 <emu> over-CSSed crud :/
18:06:12 <dons> sorear: well, i guess your summer of grad school programming should set you up nicely for high school ;)
18:06:53 <dons> sorear: you looking at universities yet?
18:07:55 <sorear> haven't managed to force myself to do it yet :(
18:08:34 <dons> sorear: you looking to do CS, I suppose?
18:09:01 <sorear> quite possible, that | math
18:09:53 <dons> you should be able to get good advice on the best CS schools in this channel, when you start looking.
18:09:54 <psnl> cs is the way forward
18:09:57 <nornagon> emu: why do you read blogs in their own formatting?
18:10:05 <nornagon> Just snag their feed and be done with it.
18:11:04 <emu> hehe, i never got into that whole thing
18:11:10 <olliej> emu: because blogs are designed to look different in every browser while using exactly the same markup.  This is why CSS exists :D
18:11:35 <dons> sorear, if I was in the US, i'd seriously try to get into CMU, I think.
18:11:37 * xerox wins the new year's first game of monopoly!
18:11:49 <olliej> xerox: hehe
18:11:53 <dons> if prog.lang design was what I was interested in
18:11:54 <emu> cmu cs is ok... i guess
18:12:10 <allbery_b> the grass is always greener...
18:12:22 <xerox> 1.037.100 (yes.. still Italian lira.)
18:12:37 <mauke> yay, #59 is solved
18:12:56 <emu> they really lowered their standards in the last few years
18:12:57 <dons> you could do some haskell at Portland too, iirc. with lispy and droundy :)
18:13:12 <dons> or work with normal ramsey at harvard
18:13:17 <dons> norman :}
18:13:23 <emu> isnt he laeving harvard?
18:13:33 <dons> haven't heard.
18:13:42 <emu> he wrote on the C-- list that he did not get tenure
18:14:03 <dons> where's weirich working at these days?
18:15:16 <dons> ah, upenn
18:15:20 <jcreigh> sorear: I can't get your version to work. "charclass = char '[' >> (alt `fmap` many1 ((try range) <|> parsechar)) =>> char ']'" This is invalid, because alt isn't in that file. Maybe I'm just dense, but I can't figure out what the correct definition would be.
18:15:38 <xerox> @localtime dons
18:15:40 <lambdabot> Local time for dons is Mon Jan  1 13:08:48 2007
18:16:09 <sorear> alt = choice
18:16:23 * sorear really should have tested it before pasting
18:16:32 <dons> any other FP/Haskell schools in the US?
18:16:46 <dons> besides the ones that switch from scheme to python..
18:16:49 <emu> berkeley
18:17:04 <emu> that's where smerdy is now, working for Necula ;)
18:17:08 <dons> ah yes.
18:17:29 <dons> both CMU refugees though (smerdy too?)
18:17:33 <emu> yep
18:17:40 <newsham> mmm python
18:17:41 <emu> PCC
18:17:41 <mr_tenor> dons: very unhappy about CSE usingC for comp1a now... are there plans to insert any proper FP later on in the degree programs?
18:18:11 <dons> mr_tenor: yeah, ah well. there's still COMP 3161 (which I tutor)
18:18:26 <dons> http://www.cse.unsw.edu.au/~cs3161
18:18:27 <lambdabot> Title: Notices : COMP3161/9161 Concepts of Progamming Languages 2006/S1
18:19:08 <dons> the eng101 or whatever course uses haskell still
18:19:45 <mr_tenor> dons: from what i can tell, most people who went through comp1a with me didn't "get" FP anyway and think haskell is "useless", but in any case i just hope unsw doesn't turn into a codemonkey bootcamp :/
18:20:11 <jcreigh> sorear: oh, sorry, I didn't realize you mean that literally. (I was trying things along the lines of "return $ choice $ many1 ((try range) <|> parsechar)") So now there's only 1 type error...
18:20:35 <sorear> jcreigh: (=>>) = liftM2 const
18:20:41 <sorear> jcreigh: import Control.Monad
18:20:45 <emu> java is used for all the introductory courses at cmu, save a systems course
18:20:45 <dons> mr_tenor: yeah, it helped once we switched to ghc and used gtk2hs/wxHaskell - the students wrote some real code
18:20:54 <dons> but they just want to hack C and do the OS kernel course
18:20:54 <mr_tenor> :)
18:20:55 <sorear> jcreigh: matches :: String -> String -> Bool
18:20:58 <dons> undergrads don't know what's good for them
18:21:20 <dons> and then in 3rd/4th year 50-80 of them rediscover FP, and 3 go on and do an honours degree in it ;)
18:21:38 <mr_tenor> i thoughtthe trend was to code C#/java and try to avoid learning anything much at all ;) </cynicism>
18:21:47 <emu> and get "industry" jobs
18:22:06 <sorear> Kids, I've 7 years of C experience, and I'm abandoning it.  (never mind the "kids" are 2-5 yrs older than me)
18:22:09 <jcreigh> sorear: many1 thanks
18:22:27 <emu> sorear: i did the same at 18
18:22:54 <dons> mr_tenor: keep an eye for the formal methods course too, they're more and more haskellish now that our formal methods resrch group uses haskell
18:23:17 <mr_tenor> you've got meyden, kenr and all using haskell??
18:23:24 <jcreigh> sorear: did you really paste that without having tested it at all? If so, seriously impressive to do that with only minor errors.
18:23:34 <dons> nah, kleing and the other theorem prover guys
18:23:49 <mr_tenor> what's chak up to nowadays?
18:30:04 --- mode: irc.freenode.net set +o ChanServ
18:30:44 <sorear> ?irc-connect fn chat.freenode.net sorear-lambdabo2
18:30:44 <sorear-lambdabot> Not enough privileges
18:30:44 <mr_tenor> @users
18:30:44 <sorear-lambdabot> Unknown command, try @list
18:30:45 <sorear> ?irc-connect fn chat.freenode.net sorear-lambdabo2
18:30:47 <calvins_> did lambdabot just go psycho and kick a ton of people out or something?
18:30:49 <mauke> @bat
18:30:53 <calvins_> ;)
18:31:02 <sorear> oh wait
18:31:14 <sorear> I just joined two servers with the same tag :(
18:31:18 <sorear> ?irc-quit fn
18:31:25 <sorear> ?irc-connect fn2 chat.freenode.net sorear-lambdabo2
18:31:28 <jcreigh> calvins_: It's like that movie "war games"...lambdabot doesn't know it's real. :)
18:31:33 <sorear> ?irc-join fn2:#haskell
18:31:43 <sorear> see, super-multi-server
18:31:47 <calvins_> heh
18:31:50 <jcreigh> @play global thermonuclear war
18:31:51 <sorear-lambdabo2> Maybe you meant: pl slap
18:31:54 <jcreigh> heh
18:32:01 <emu> @slap
18:32:02 <sorear-lambdabo2> Not enough privileges
18:32:10 <dons> ?bot
18:32:11 <sorear-lambdabo2> :)
18:32:27 <dons> lambdabot doesn't like netsplits very much ..
18:32:45 <sorear> this is the super-multi-server lambdabot
18:32:58 <mauke> http://www.lightbluetouchpaper.org/2006/12/24/chip-pin-terminal-playing-tetris/
18:32:59 <NichardRixon> let's get lambdabot calculating pi
18:33:01 <sorear-lambdabo2> Title: Light Blue Touchpaper  Chip &#038; PIN terminal playing Tetris, http://tinyurl.com/y4e8ub
18:33:05 <sorear> ?admin fn2:dons
18:33:05 <sorear-lambdabo2> Not enough privileges
18:33:23 <sorear> ?admin fn2:dons
18:33:23 <sorear-lambdabo2> User fn2:dons de-admin-ed.
18:33:50 <lambdabot> Unknown command, try @list
18:33:51 <dons> is sorear-lambdabo2 going to switch itself off now?
18:34:01 <sorear> ?irc-quit fn
18:34:02 <sorear-lambdabo2> irc module failed: IRCRaised user error (attempt to send message to bogus server!)
18:34:02 <lambdabot> Unknown command, try @list
18:34:04 <sorear> ?irc-quit fn2
18:34:04 <lambdabot> Unknown command, try @list
18:34:22 * dons ponders what patches sorear-lambdabot was running
18:34:24 <lisppaste2> jcreigh annotated #33797 with "corrected minor type errors with sorear's guidance" at http://paste.lisp.org/display/33797#1
18:35:07 <jcreigh> sorear++ Again, thanks for the feedback.
18:39:07 <emu> > [ sum (map (1/) fs) | fs <- inits [ product ns | ns <- inits [1..] ] ]
18:39:08 <lambdabot>  [0.0,1.0,2.0,2.5,2.6666666666666665,2.708333333333333,2.7166666666666663,2.7...
18:39:46 <xerox> e?
18:39:59 <emu> > drop 10 [ sum (map (1/) fs) | fs <- inits [ product ns | ns <- inits [1..] ] ]
18:40:01 <lambdabot>  [2.7182815255731922,2.7182818011463845,2.718281826198493,2.7182818282861687,...
18:40:07 <xerox> yep.
18:40:23 <olliej> >  inits [ product ns | ns <- inits [1..] ]
18:40:24 <lambdabot>  [[],[1],[1,1],[1,1,2],[1,1,2,6],[1,1,2,6,24],[1,1,2,6,24,120],[1,1,2,6,24,12...
18:40:29 <olliej> ah :D
18:40:41 <sorear> > scanl1 (*) [1..]
18:40:42 <lambdabot>  [1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,87...
18:40:48 <sorear> > map recip $ scanl1 (*) [1..]
18:40:50 <lambdabot>  [1.0,0.5,0.16666666666666666,4.1666666666666664e-2,8.333333333333333e-3,1.38...
18:40:56 <emu> sum of series of reciprocal of factorials
18:40:58 <sorear> > scanl1 (+) $ map recip $ scanl1 (*) [1..]
18:40:59 <lambdabot>  [1.0,1.5,1.6666666666666667,1.7083333333333335,1.7166666666666668,1.71805555...
18:41:23 <xerox> > (scanl1 (+) $ map recip $ scanl1 (*) [1..]) !! 100000
18:41:24 <sorear> > scanl1 (+) $ (1:) $ map recip $ scanl1 (*) [1..]
18:41:25 <lambdabot>  1.7182818284590455
18:41:26 <lambdabot>  [1.0,2.0,2.5,2.6666666666666665,2.708333333333333,2.7166666666666663,2.71805...
18:41:31 <xerox> that's pretty accurate
18:41:32 <xerox> > exp 1
18:41:34 <lambdabot>  2.718281828459045
18:41:38 <olliej> >  inits [ fib ] where fib = 1:1:zipWith(+) fib (tail fib)
18:41:38 <lambdabot>  Parse error
18:41:53 <olliej> >  inits [ fib ] ; where fib = 1:1:zipWith (+) fib (tail fib)
18:41:53 <lambdabot>  Parse error
18:41:58 <olliej> :-/
18:42:02 <xerox> you ought to use let
18:42:13 <emu> well,
18:42:14 <sorear> > head $ dropWhile (null . tail) $ group $ scanl1 (+) $ (1:) $ map recip $ scanl1 (*) [1..]
18:42:15 <emu> > inits [1]
18:42:15 <xerox> "... where ..." is not an expression :(
18:42:16 <lambdabot>  [2.7182818284590455,2.7182818284590455,2.7182818284590455,2.7182818284590455...
18:42:17 <lambdabot>  [[],[1]]
18:42:21 <olliej> >  let fib = 1:1:zipWith (+) fib (tail fib) in inits fib
18:42:22 <lambdabot>  [[],[1],[1,1],[1,1,2],[1,1,2,3],[1,1,2,3,5],[1,1,2,3,5,8],[1,1,2,3,5,8,13],[...
18:42:22 <sorear> > head $ head $ dropWhile (null . tail) $ group $ scanl1 (+) $ (1:) $ map recip $ scanl1 (*) [1..]
18:42:24 <lambdabot>  2.7182818284590455
18:42:28 <sorear> > exp 1
18:42:30 <lambdabot>  2.718281828459045
18:42:51 <sorear> my last pipe automatically stops the iteration on equality
18:43:05 <xerox> makes sense :)
18:45:44 <olliej> > let primes (x:xs) = (x: primes [y | y <- xs,  (y `mod` x) /= 0]) in take 20 $ primes [2..]
18:45:46 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71]
18:46:33 <olliej> > let primes (x:xs) = (x: primes [y | y <- xs,  (y `mod` x) /= 0]) in drop 20 $ primes [2..]
18:46:34 <lambdabot>  [73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,...
18:47:18 <olliej> > let primes (x:xs) = (x: primes [y | y <- xs,  (y `mod` x) /= 0]) in drop 20 $ primes (2:[3,5..])
18:47:20 <lambdabot>  [73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,...
18:47:50 <olliej> obviously i have now improved the efficiency dramtaically :D
18:49:06 <NichardRixon> how would one go about grouping every 3 elements in a list together into sublists?
18:50:05 <xerox> > let primes = 2 : 3 : [n | n <- [5,7..], all ((/= 0) . (n `mod`)) (takeWhile (\p -> p*p <= n) primes)] in primes
18:50:07 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
18:50:15 <NichardRixon> how would one go about grouping every 3 elements in a list together into sublists?
18:50:30 <Syzygy-> xerox: That'd be a sieve of erastothenes lazily, eh?
18:50:51 <sorear> > (\l -> map (map (l!!)) [[0,3..],[1,4..],[2,5..]]) [0,10...]
18:50:51 <lambdabot>  Parse error
18:51:01 <NichardRixon> oh nice :D
18:51:06 <xerox> Syzygy-: well, yeah.
18:51:38 <sorear> > (\l -> transpose $ map (map (l!!)) [[0,3..],[1,4..],[2,5..]]) [0,10..]
18:51:39 <lambdabot>  [[0,10,20],[30,40,50],[60,70,80],[90,100,110],[120,130,140],[150,160,170],[1...
18:51:55 <sorear> *massively* inefficient, but cute.
18:53:00 <mr_tenor> :)
18:53:22 <NichardRixon> wow, it blows my mind
18:53:24 <NichardRixon> thanks
18:54:49 <NichardRixon> Program error: Prelude.!!: index too large
18:54:51 <NichardRixon> uh oh!
18:55:00 <xerox> > (\n -> unfoldr (\xs -> case xs of [] -> Nothing; xs -> Just (take n xs, drop n xs))) 3 [1..21]
18:55:01 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15],[16,17,18],[19,20,21]]
18:55:46 <sorear> my method only works on infinite lists :(
18:55:50 <olliej> xerox: wha?
18:55:53 <xerox> My method does not.
18:55:55 * olliej tries to follow
18:56:29 <sorear> xerox's is also much faster, and probably clearer.
18:57:00 <olliej> well yes, !! == teh badness
18:57:11 <sorear> > (\n -> unfoldr (\xs -> case xs of [] -> Nothing; xs -> Just $ splitAt n xs)) 3 [1..21]
18:57:13 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15],[16,17,18],[19,20,21]]
18:57:23 <xerox> Good idea.
18:57:42 <xerox> Finally, a use for splitAt.
18:58:16 <xerox> Go anamorphisms!
18:58:18 <olliej> my compiler had a manual implementation of !! to improve the speed.. though when i think about it i think i had hand written impls for quite a few of the list functions
19:00:17 <xerox> olliej - unfoldr f b = case f b of Just (a,new_b) -> a : unfoldr f new_b; Nothing -> []
19:01:12 <olliej> > let isEven n = if n<0 then isEven (-n) else if n>1 then isEven (n-2) else if n==1 then False else True in isEven 5
19:01:13 <lambdabot>  False
19:01:17 <olliej> hehehe
19:02:04 <olliej> xerox: ow
19:02:16 <olliej> now my head hurts :p
19:03:32 <xerox> > unfoldr (\x -> if x < 10 then Just (x,x+1) else Nothing) 0
19:03:34 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
19:04:14 <olliej> hehe
19:12:03 <xerox> ?users
19:12:03 <lambdabot> Maximum users seen in #haskell: 309, currently: 261 (84.5%), active: 12 (4.6%)
19:12:06 <xerox> Yeah, pretty high.
19:12:24 <temujin> heh
19:12:36 <xerox> Haskell is a pure functional strongly typed general purpose programming language.
19:13:05 <xerox> http://haskell.org/ is a good start, temujin :)
19:13:06 <lambdabot> Title: Haskell - HaskellWiki
19:13:11 <temujin> purely functional
19:13:19 <temujin> why does that make me a bit fidgety?
19:13:31 <xerox> You were in #math, it shouldn't!
19:13:31 <sorear> hello
19:13:42 <temujin> hehe
19:13:44 <temujin> true
19:13:54 <sorear> don't worry, we don't bite
19:14:10 <xerox> Well, functions are first-class citizens in Haskell. This means you can pass them around as parameters and return them as values.
19:14:20 <xerox> > map (*2) [1..10]
19:14:21 <lambdabot>  [2,4,6,8,10,12,14,16,18,20]
19:14:30 <xerox> It's pretty powerful.
19:14:34 <temujin> heh... keywords?
19:14:41 <temujin> or predefined functions?
19:14:42 <xerox> No keywords in that line of code.
19:14:44 <temujin> lots and lots of em?
19:14:50 <xerox> Just the standard Haskell libraries.
19:14:50 <mbishop> > map (+) [1..10]
19:14:51 <lambdabot>  Add a type signature
19:14:53 <xerox> ?docs
19:14:54 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
19:15:00 <sorear> > let primes (x:xs) = (x: primes [y | y <- xs,  (y `mod` x) /= 0]) in take 20 $ primes [2..]
19:15:02 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71]
19:15:18 <temujin> jesus
19:15:22 <temujin> thats sick
19:15:42 <xerox> > fix (\fibs -> 0 : 1 : zipWith (+) fibs (tail fibs))
19:15:43 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
19:16:02 <xerox> You can do lots of neat things in very few lines of code.
19:16:15 <xerox> </spot>
19:17:21 <sorear> I'm excessively proud of a 590-character theorem prover.  (Of course I left out whitespace and used single character names, but still)
19:17:32 <temujin> hokai... after a nice smoke thinking about things I can do with haskell ... I am gonna dload version 6.6 ...
19:17:54 <temujin> hopefully my slack likes it
19:18:21 <xerox> Yeah.  Everybody loves it, right?
19:18:30 <temujin> err slackware...
19:21:27 <NichardRixon[clo> sorear, where can I find this theorem prover?
19:22:03 <sorear> ?wiki Short_theorem_prover
19:22:04 <lambdabot> http://www.haskell.org/haskellwiki/Short_theorem_prover
19:22:43 <sorear> fairly simple, uses the Curry-Howard isomorphism to construct a list of all provably true statements
19:23:36 <NichardRixon[clo> neat
19:25:13 <sorear> it is very slow, but unlike normal prepositional provers (@djinn etc) it has very few design limitations
19:25:45 <sorear>  @djinn doesn't support rank-2 types, and can't.
19:26:13 <sorear> that'd probably be a few hours work on a curry-howard-enumeration prover
19:34:26 <Saizan> i' drunk
19:34:40 <sorear> ok, all the infrastructure required for fixing Seen in sorear-lambdabot is in place...
19:34:41 * xerox hugs Saizan 
19:34:46 <xerox> happy new year mate.
19:36:05 <dons> sorear: so how does it fix it?
19:37:42 <sorear> Seen is still broken ...  IRC signal callbacks are no more, so I've added a new Module field for recieving Other Messages.  Typeable is used to distinguish IrcMessages from everything else
19:38:11 <temujin> ok back
19:38:15 <temujin> time to install haskell
19:38:53 <dons> hmm. ok. is it clean, sorear ?
19:39:10 * dons just removed VixenState in favour of binary serialised vixen reggexes :)
19:39:15 <sorear> I hope it is clean enough
19:39:18 <dons> suddenly compilation time is cut by a couple of minutes ;)
19:39:33 <sorear> yay
19:39:47 <sorear> can regexes be decompiled losslessly?
19:39:51 <temujin> are the extralibs required to compile the 6.6 src?
19:40:04 <dons> sorear: they're dumped as bytestrings to disk, and lazily compiled on moduleInit
19:40:14 <dons> temujin: nope
19:40:18 <temujin> ahh
19:40:20 <dons> but they're needed for many projects
19:40:31 <temujin> ahh so its wise to compile them both
19:40:36 <sorear> I mean have we lost the source?
19:40:51 <sorear> I suppose it's in darcs
19:40:54 <dons> ah no. its recoverable by calling Binary.get on "State/vixen"
19:41:08 <temujin> ===>] 4,345,587    770.53K/s    <-- wow ... thats a fast server
19:41:24 <sorear> temujin: GHC requires GHC to compile.  If you don't have GHC, you need a binary to start with.
19:41:36 <dons> sorear: i'm doing a time/space/style clean up of the bot today
19:41:37 <temujin> aye... saw that
19:41:43 <temujin> after I started the dload
19:41:43 <sorear> GHC is written in Haskell w/ GHC extentions
19:41:45 <dons> so you'll want to keep up with patches that land, possibly
19:42:48 <sorear> Fortunately, most of the plugins aren't touched by my changes, and only ~3 needed more than a 1-line fix.
19:43:13 <temujin> wha? rpm?
19:43:23 <sorear> (so there shouldn't be *too* many conflicts)
19:43:37 <sorear> RPM is the RedHat Package Manager.
19:43:53 <dylan> No, RPM is the RedHat Pain Maker.
19:44:03 <temujin> agree with dylan
19:44:14 <allbery_b> really pathetic mess-maker
19:44:22 <temujin> less pain than deb packages though..
19:44:25 * dylan admins ... 6 fedora boxes, and 2 RHELL boxes.
19:44:39 <dylan> Not at all. dpkg is a lot easier to handle.
19:44:50 <sorear> dylan: how would you expand DEB or DPKG?
19:45:03 <dylan> it's an ar archive
19:45:04 <sorear> (and don't say dpkg-deb or ar)
19:45:14 <dylan> what's wrong with ar?
19:45:24 <allbery_b> he means expands like your comment about rpm
19:45:39 <sorear> I wanted you to expand the acronym, not the files :)
19:45:49 <dylan> Doesn't Exactly Bite.
19:45:58 <temujin> I sadly have never had success with maintaining a debian system... its pkg management messes up dependancies... or more precisely... I mess it up
19:46:16 <temujin> I remember playing with woody enough that I got tired angry and threw the 20gig hd across the room
19:46:17 * allbery_b has only seen debian hose deps when you try to follow unstable
19:46:28 <bd_> http://www.fushizen.net/purehash/ <-- In response to some discussion from earlier, I've hacked together an implementation of pure hash tables based on IArray (including DiffArray). Comments welcome :)
19:46:29 <lambdabot> Title: Index of /purehash
19:46:38 <Nafai> I followed unstable for 4 years or so until I switched to Ubuntu
19:46:38 <allbery_b> (but if you do that,e xpect it to periodically want to delete the whole system to upgrade some tiny component :)
19:46:50 <temujin> hehe
19:46:52 <bd_> need to figure out quickcheck next I guess
19:46:54 <dylan> bd_: when did you get fushizen?
19:47:03 <bd_> dylan: a few days ago >.>
19:47:13 <dylan> cool name. :)
19:47:22 <allbery_b> "oh no, it wants to remove libc again" :)
19:47:30 <dylan> I try to not track sid.
19:47:38 <bd_> dylan: cool names are hard to come by in DNS these days :p
19:47:40 <dylan> I "surf" debian.
19:47:48 <sorear> Dpkg makes it impossible for you to shoot feet.  Conversely, it dangles your foot in front of everything else, thus making it impossible for you to shoot anything.
19:48:03 <dylan> upgrade to sid, wait until testing catches up, switch to testing until unstable is stable-ish again
19:48:12 <temujin> the tar xjf ghc-6.7-i386-unknown-linux.tar.bz2 is taking longer than the download did
19:48:26 <allbery_b> bzip2 is slow
19:48:29 <sorear> is your CPU at 100%
19:48:30 <sorear> ?
19:48:49 <temujin> sorear yep
19:48:54 <allbery_b> how much RAM do you have?  bzip2 uses big blocks...
19:48:55 <temujin> ahh finally done
19:49:13 <temujin> cmeme:          1514       1479         34          0        307        670
19:49:17 <allbery_b> (but if you don';t have enough RAM to keep it happy, ghc wll be .. problematic)
19:49:22 <temujin> thats in megs
19:49:38 <sorear> bzip2 uses <20MB
19:49:47 <sorear> GHC by default uses a 32MB heap
19:49:51 <temujin> its an old server... running on the one processor it has left... (the other one burned out)
19:49:59 <temujin> there is 1.5gigs on this system
19:50:07 <temujin> should be fine right?
19:50:07 <sorear> how old is the processor?
19:50:09 <allbery_b> you're set
19:50:15 <sorear> 1.5G is overkill.
19:50:19 <temujin> model name      : AMD Athlon(tm) MP 2400+
19:50:27 <sorear> I'm doing fine on 384M.
19:50:36 <sorear> P4, 2.000GHz
19:50:53 <sorear> had 512, one died & took FS with it.
19:51:00 <temujin> well this box also does the routing, the natting, the ssh server, apache, mysql, named, samba shares etc...
19:51:07 <temujin> ooo suckage
19:51:14 <sorear> does it make coffee? *ducks*
19:51:26 <temujin> :)
19:51:43 <xerox> @localtime xerox
19:51:45 <lambdabot> Local time for xerox is Mon Jan  1 04:45:52 2007
19:51:49 <xerox> To sleep or not to sleep?
19:52:04 <temujin> @localtime temujin
19:52:06 <lambdabot> Local time for temujin is Sun Dec 31 21:44:59 2006
19:52:08 <sorear> Sleep.  You can always chat tommorrow.
19:55:05 <xerox> @localtime sorear
19:55:06 <lambdabot> Local time for sorear is Sun Dec 31 19:48:11 2006
19:56:39 <temujin> Loading package base ... linking ... done.
19:56:40 <temujin> Prelude>
19:56:42 <temujin> oooo
19:56:56 <sorear> GHCi! GHCi! <choral chanting>
19:57:16 <sorear> looks working...
19:57:18 <temujin> amen children... please be seated to hear the words of the great ghc
19:57:18 <allbery_b> GHCigorian chants?
19:57:20 <xerox> I'll leave you with the gentle #haskell folks :)  Have fun!
19:57:20 * xerox >>= bed
19:57:28 <temujin> gnite xerox
19:57:52 <temujin> putStrLn "Hello World"
19:57:52 <temujin> Hello World
19:58:03 <temujin> haskell has spoken
19:58:10 <sorear> now to find a tutorial... supposedly they all suck.  I've always been rather gifted at learning, so I can't say.
19:58:22 <sorear> ?wiki MetaTutorial
19:58:22 <lambdabot> http://www.haskell.org/haskellwiki/MetaTutorial
19:58:25 <temujin> I have not really studied anything
19:58:31 <sorear> ^^^ the newest project, might help
19:58:35 <temujin> hehe
19:58:49 <temujin> I am reading the haskell in 5 steps
20:12:52 <temujin> wow... parenthesis hell
20:13:27 <sorear> elaborate?
20:13:39 <sorear> you reading LISP code again? :)
20:14:04 <temujin> hehe no... one of the first exercises... extract the char a out of ((1,'a'),"foo")
20:15:25 <temujin> yeah... while it says functions don't explicitly require parenthesis...
20:15:46 <temujin> snd(fst((1,'a'),"foo"))  <-- try doing that without parenthesis around the whole fst
20:16:04 <jlouis> snd . fst
20:16:05 <allbery_b> tuples exist, but they often seem like an alien appendage on haskell
20:16:06 <sorear> snd fst ((1,'a'),"foo")
20:16:11 <sorear> doesn't work
20:16:26 <sorear> it's parsed as  ((snd fst) ((1,'a'),"foo"))
20:16:40 <sorear> you try finding the second component of a function
20:16:54 <temujin> *pages forward to look for operator precedence*
20:17:19 <sorear> juxtaposition has precedence 10, left assoc
20:17:32 <sorear> there are other cute tricks
20:17:40 <sorear> > snd $ fst $ ((1,'a'),"foo")
20:17:41 <lambdabot>  'a'
20:18:10 <temujin> ahh the $... what is the . above that jlouis gave?
20:18:14 <sorear> $ also does function application, but it has very low, right-associative fixity
20:18:15 <olliej> sorear: where $ is actually a function :D
20:18:21 <allbery_b> . is composition
20:18:31 <temujin>  snd . fst((1,'a'),"foo")
20:18:35 <temujin> does not compile
20:18:35 <allbery_b> (f . g) x is f (g x))
20:18:40 <olliej> :t $
20:18:42 <lambdabot> parse error on input `$'
20:18:45 <olliej> psh
20:18:48 <allbery_b> :t ($)
20:18:49 <lambdabot> forall b a. (a -> b) -> a -> b
20:18:50 <sorear> (snd . fst) ((1,'a'),"foo")
20:18:50 <olliej> :t ($)
20:18:51 <lambdabot> forall b a. (a -> b) -> a -> b
20:18:52 <sorear> > (snd . fst) ((1,'a'),"foo")
20:18:53 <olliej> hehe
20:18:54 <lambdabot>  'a'
20:19:11 <temujin> ahh
20:19:28 <sorear> haskell has many infix operators, and you can define your own easily
20:19:41 <temujin> this is going to be quite a fun little language to learn
20:19:56 <olliej> let a |||| b = a + b in 3 |||| 4
20:20:01 <olliej> > let a |||| b = a + b in 3 |||| 4
20:20:02 <lambdabot>  7
20:20:05 <olliej> :D
20:20:19 <temujin> hehe
20:20:24 <sorear> > let a  b = [a + b, a - b] in 2  3
20:20:25 <lambdabot>  Illegal character ''\177''
20:20:27 <temujin> wow... thats disguisting
20:20:33 <sorear> > let a +- b = [a + b, a - b] in 2 +- 3
20:20:34 <lambdabot>  [5,-1]
20:21:06 <temujin> so you can have even multiple chars as a single operator
20:21:11 <olliej> > let a  b = (a+b, a-b) in 3  4
20:21:12 <lambdabot>  Illegal character ''\177''
20:21:13 <sorear> <bemoans lack of UTF-8 support in lambdabot>
20:21:15 <olliej> dmmit
20:21:21 <temujin> hehe
20:21:48 <xpika> @get-definition seq
20:21:48 <olliej> sorear: can we define instances in lambdabot
20:21:49 <lambdabot> seq not defined
20:21:49 <olliej> ?
20:22:02 <sorear> no
20:22:04 <olliej> :t (>>=)
20:22:05 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
20:22:10 <olliej> sorear: :(
20:22:21 <xpika> so >>= is the same as seq
20:22:24 <xpika> ok then
20:22:32 <allbery_b> sometimes
20:22:37 <allbery_b> (I think)
20:22:42 <sorear> I don't know if we ever could, but with EvilIx it's not likely dons will add them
20:22:53 <sorear> why would >>= be seq?
20:23:03 <allbery_b> :t seq
20:23:04 <lambdabot> forall b a. a -> b -> b
20:23:14 <sorear> > 2 `seq` 3
20:23:15 <lambdabot>  3
20:23:16 * allbery_b tries to wake upo
20:23:17 <sorear> > 2 >>= 3
20:23:18 <lambdabot>  add an instance declaration for (Show (m b))
20:23:53 * allbery_b wonders what it was using for m there
20:24:04 <syntaxfree> it's 2007 here already!
20:24:18 <syntaxfree> what year are y'all living in?
20:24:31 <sorear> @localtime sorear
20:24:32 <lambdabot> Local time for sorear is Sun Dec 31 20:17:37 2006
20:24:32 <allbery_b> 2006 for the next 42 minutes
20:25:00 <syntaxfree> I was first pretty fucking mad that this was going to be a bad new year's eve.
20:25:01 <Cale> @localtime Cale
20:25:02 <lambdabot> Local time for Cale is Sun Dec 31 23:18:10
20:25:05 <temujin> @localtime temujin
20:25:06 <lambdabot> Local time for temujin is Sun Dec 31 22:17:59 2006
20:25:13 <syntaxfree> Last year it was just awesome, with my then-girlfriend and all.
20:25:16 <temujin> aparantly I am left behind
20:25:19 <dibblego> are data constructors exported wby default without an explicit export list?
20:25:25 <allbery_b> no
20:25:31 <syntaxfree> This year I couldn't even find a friend's place to go -- everyone was just spending it with their families.
20:25:37 <allbery_b> use (..) as the export list to export all constructors
20:25:39 <syntaxfree> So I stayed home.
20:25:52 <syntaxfree> It was a good thing. I've had the best conversation with my parents since I was 16 or so.
20:25:53 <sorear> you don't have one?
20:26:07 <sorear> (family, oh)
20:26:10 <temujin> hehe syntaxfree welcome to the club... I said no to a girl, to two groups of friends to have some time alone...
20:26:18 <temujin> oh wait family...
20:26:19 <temujin> nm
20:26:50 <syntaxfree> I really wasn't in the mood to party, but I wanted to do something fun so it didn't feel like such a downer compared to last years' wild time with the then-gf.
20:27:03 <syntaxfree> I had a great time with my parents, though.
20:41:37 <metaperl> any arrow lovers watching... please search for arr2A on this HTML-ized version of the thesis on arrows: http://209.85.165.104/search?q=cache:BarNbLjZc84J:www.fh-wedel.de/~si/HXmlToolbox/cookbook/doc/thesis.pdf+haskell+xml+toolbox+rdf+cookbook+HTML&hl=en&gl=us&ct=clnk&cd=2
20:41:39 <lambdabot> http://tinyurl.com/yl7fh7
20:42:05 <metaperl> Actually, I can paste the type signature here - arr2A :: (b -> a c d) -> a (b, c) d   ...
20:42:52 <metaperl> my question is about the input to arr2A ... the input to arr2A is a function ... this function takes b and return an _arrow_ of type a from c to d ... correct?
20:43:07 <sorear> metaperl: arr2A is fully equivalent to app
20:43:15 <sorear> you need an ArrowApply
20:43:21 <metaperl> I think its for list arrows though
20:43:26 <metaperl> @type app
20:43:27 <lambdabot> forall (a :: * -> * -> *) c b. (ArrowApply a) => a (a b c, b) c
20:44:14 <sorear> no, wait, maybe I'm wrong... didn't catch the ->
20:44:25 <metaperl> yeah, it's unusual
20:44:47 <sorear> mp: you're type idea is correct
20:45:19 <metaperl> but the description says "Another constructor is arr2A which creates a two-argument arrow from a single-argument
20:45:40 <sorear> the *output* is a two-argument arrow
20:45:42 <metaperl> anyway, I gusss I just need to get the feel of things. HaXT is not going to be this demanding
20:45:47 <metaperl> yes, I know
20:45:48 <sorear> arrows must be uncuried
20:46:12 <metaperl> but the input is _not_ a single-argument one. The input is a function which takes a datum of type b and returns single-argument arrow
20:46:28 <metaperl> This Germanized English is cute, but pitiful at the same time :)
20:46:50 <metaperl> I guess I should be glad they didnt write this thesis in German, or I'd really be fuX0red :)
20:47:06 <olliej> can someone explain what an arrow is?
20:47:21 <geckosenator> yeah i need that explanation also
20:47:39 <metaperl> olliej - http://haskell.org/arrows/index.html
20:47:40 <lambdabot> Title: Arrows: A General Interface to Computation
20:47:52 <olliej> metaperl: cheers
20:47:59 <sorear> it's an abstract object
20:47:59 <metaperl> they are more flexible in terms of the input they accept than monads. they are a generalized view of computation
20:48:07 <metaperl> they are pluggable and extendable
20:48:10 <sorear> like a group, more like a mondad
20:48:13 <monochrom> An arrow is a generalization of a function.
20:48:27 <metaperl> there is a new xml processing module based on arrows that is better documented than haxml
20:49:05 <DebolazX> Ugh, xml :/
20:50:17 <sorear> metaperl: arr2A is equivalent to app for real, arr2A id is app
20:51:06 <sorear> metaperl: arr2A can be defined as arr2A f = (first (arr f)) >>> app
20:51:12 <metaperl> where are List arrows in GHC... not here: http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Arrow.html#v%3Afirst
20:51:14 <lambdabot> http://tinyurl.com/y6yt3s
20:51:38 <sorear> :t let arr2A f = (first (arr f)) >>> app in arr2A
20:51:40 <lambdabot> forall b (a :: * -> * -> *) b1 c. (ArrowApply a) => (b -> a b1 c) -> a (b, b1) c
20:52:16 <monochrom> ArrowList is part of HXT.
20:53:05 <metaperl> oh
20:55:19 <metaperl> @type arr
20:55:20 <lambdabot> forall (a :: * -> * -> *) c b. (Arrow a) => (b -> c) -> a b c
21:09:08 <dibblego> a guy on dalnet C# thinks he can write a type-safe sort in C#
21:09:37 <dons> dibblego: you out there trolling the imperative guys again? ;)
21:09:44 <dibblego> yep :)
21:09:50 <dibblego> I really should stop
21:11:34 <olliej> dibblego: what makes it impossible?
21:12:01 <dons> yeah, it might cause more trouble than its worth.
21:12:15 <dons> you don't want to turn into an angry lisper^h^h^h fp guy
21:12:16 <olliej> dibblego: off the top of my head i can't see anything (besides a few decidedly dodgy .net vm hacks) that would cause that
21:12:17 <dylan> Happy new year, east-cost US #haskell!
21:12:38 <dons> happy new year dylan !
21:12:47 * allbery_b waves
21:13:00 <dylan> % find 2006 -type f -print0 | xargs -0 cat | wc -l
21:13:01 <dylan> 2043547
21:13:10 <dylan> ^ irc logs.
21:18:31 <metaperl> HNY dylan
21:18:57 <dylan> hmm, last year makes up about half of my total number of chatlog lines since 2002.
21:19:12 <dylan> (4 million and so in total)
21:19:16 <olliej> dylan: eg. you're becoming slacker with age?
21:19:17 <olliej> :D
21:19:30 <dylan> no, I'm in more channels now.
21:19:40 <olliej> a likely story :D
21:19:43 <dylan> or I chat more.
21:20:01 <dylan> I think I chat more while at work then when doing non-crappy coding.
21:23:00 <emu> nothin like spending new years on IRC
21:23:08 <temujin> indeed
21:25:10 <metaperl> @type exp
21:25:11 <lambdabot> forall a. (Floating a) => a -> a
21:25:33 <metaperl> I dont think that HXT is using that HXT here is it:
21:25:35 <metaperl> f	:: XmlTree -> XmlTree
21:25:48 <metaperl> f t	=  exp(t)
21:28:06 <NichardRixon> hey it's 2007
21:28:09 <NichardRixon> that's kind of cool
21:35:10 <augustss> happy 2007!
21:35:42 <metaperl> bonne 2007
21:37:16 <geckosenator> no, its 2006 here
21:37:23 <mauke> ?localtime geckosenator
21:37:25 <lambdabot> Local time for geckosenator is Sun Dec 31 22:09:48 2006
21:37:29 <glguy> ?localtime glguy
21:37:32 <lambdabot> Local time for glguy is Sun Dec 31 23:30:35 2006
21:37:41 <geckosenator> how does it get my timezone? from ip?
21:37:53 <glguy> geckosenator: what timezone are you in that is 21 minutes off?
21:37:53 <geckosenator> ?localtime metaperl
21:38:06 <glguy> geckosenator: it asks your IRC client
21:38:08 <metaperl> geckosenator - I'm in Tampa, FL USA
21:38:09 <geckosenator> oh, cool
21:38:16 <geckosenator> well my clock is wrong
21:38:24 <emu> his own personal time zone
21:38:26 <metaperl> it was new year 30 minutes ago here
21:38:55 <geckosenator> that's funny
21:39:22 <glguy> Looks like the link to the Epigram site was a bit too much for the common reddit user
21:39:36 <temujin> in 30 mins it will be new years here
21:40:34 <Adamant> ?localtime Adamant
21:42:27 <dons> glguy: yeah, weird. oh well
21:42:37 <dibblego> reddit is denigrating
21:42:51 <dons> it can be what we want it to be tough
21:42:51 <dibblego> someone should whack together a new one with HAppS or something
21:42:55 <dons> though
21:42:58 <dons> hehe
21:43:17 <dons> but if the haskell crowd did that, it'd end up like LtU ;)
21:43:33 <dibblego> how did that end up?
21:43:47 <glguy> dibblego: I don't think denigrating means what you think it does, or I misunderstood your meaning ;)
21:44:31 <dibblego> how did you misunderstand it?
21:45:26 <glguy> I figured you mean "is getting worse" for example
21:45:28 <glguy> meant*
21:45:50 <dons> ah hehe. you mean its undergoing degredation?
21:45:55 <dibblego> yes
21:46:07 <glguy> reddit is degrading
21:46:38 <dibblego> denigrate means 'to tarnish'
21:46:48 <dibblego> perhaps 'self-denigrating'
21:47:09 <robreim> reddit is degrading? as in it's degrading to read it?
21:47:13 <glguy> I wouldn't have made an issue of it if not for last night :)
21:47:40 <glguy> robreim: no:
21:47:43 <glguy> verb (used without object)
21:47:43 <glguy> 7.	to become degraded; weaken or worsen; deteriorate.
21:48:13 <robreim> I'm just kidding.
21:48:20 <glguy> I'm totally serious!
21:48:21 <glguy> q-:
21:49:54 <glguy> I'm only pestering dibblego over the issue because of his encounter with Skarecrow yesterday in #java where Skarecrow thought that some word was "too big"
21:50:07 <glguy> "refute"
21:50:15 <glguy> I remember now
21:50:19 * dibblego deprecates glguy 
21:50:26 <dibblego> and "dire"
21:50:38 * glguy obviates dibblego 
21:50:54 * dibblego mastur... ok nuff now
21:51:22 <dibblego> I wonder if SkareCrow knows what that word means
21:52:09 <metaperl> so an advantage of arrows over monads is you cant do this in monads? do { a <- someM ; b <- useA a ; c <- useA2 a }
21:52:22 <glguy> the problem is just that #java doesn't have a lambdabot for him to ask
21:52:47 <glguy> metaperl: why couldn't you do that with a monad?
21:52:57 <metaperl> I dont know
21:53:06 <glguy> oh, ok. in that case, you can do that with monads
21:53:09 <metaperl> I'm  still trying to find out what arrows have over monads, concretely
21:54:22 <glguy> I believe that they are more general because they are parameterized over input in addition to output and do not enforce sequential evalutation
21:55:41 <metaperl> parameterized over input... concretely that means what?
21:56:15 <glguy> ?type arr
21:56:16 <lambdabot> forall (a :: * -> * -> *) c b. (Arrow a) => (b -> c) -> a b c
21:56:30 <glguy> ?type return
21:56:31 <lambdabot> forall (m :: * -> *) a. (Monad m) => a -> m a
21:56:41 <glguy> the a in the arrow has two type variables
21:56:45 <glguy> the m in monad has one
21:57:15 <metaperl> oh
21:57:45 <metaperl> parameterizing over input refers to the b in a b c
21:58:05 <glguy> yeah
21:58:57 <glguy> I'm not comfortable enough with them to tell you why that is important
22:02:48 <metaperl> have you ever used Coq for anything glguy? what do you do for a living and where?
22:03:30 <dons> ?bot
22:03:54 <emu> bottom's up
22:03:58 <lambdabot> :)
22:04:07 <dons> ?vixen test
22:04:07 <lambdabot> <undefined>
22:04:13 <dons> mm. ah yes
22:04:29 <emu> ?version
22:04:29 <lambdabot> lambdabot 4p335, GHC 6.5 (OpenBSD i386)
22:04:29 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
22:04:45 <dons> ?quote isp
22:04:46 <lambdabot> psykotic says: Let me get this straight: in your tireless Lisp-bashing efforts you have now dragged out Prolog as an exemplar of practicality? *Prolog*? My goodness, you must be desperate!
22:04:53 <thelsdj> http://paste.lisp.org/display/33802 thoughts?
22:05:20 <metaperl> who wrote http://www.haskell.org/haskellwiki/HXT
22:05:21 <lambdabot> Title: HXT - HaskellWiki
22:05:42 <dons> check the history for that page
22:07:12 <metaperl> ok thanks... the discussion of deep is wrong IMHO: <quote>When a predicate filter is applied to deep, a top down search is done and all subtrees satisfying the predicate are collected. The descent into the tree stops, when a subtree is found because of the use of orElse</quote> ... how can it stop at the first successful match yet collect all subtrees?
22:19:14 <Cale> metaperl: laziness
22:19:45 <metaperl> i'm afraid I can't decrypt that with 100% non-ambiguity :)
22:20:05 <Cale> okay, I think I can explain
22:21:08 <Cale> You can imagine it producing a list of subtrees of the XML tree, and applying a filter to that list
22:21:11 <dylan> metaperl: same way you can split an infinite [Char].
22:21:26 <Cale> it might not actually build the whole list of subtrees when it actually runs
22:21:47 <metaperl> ok, lets stop for a second... explain no more please
22:22:12 <Cale> oh, looking at the actual document
22:23:16 <Cale> it means that it goes through the subtrees, starting with the root, and doesn't bother to continue searching through the children of subtrees which match
22:23:30 <Cale> So it's not like a list in that respect
22:24:23 <lisppaste2> thelsdj pasted "Collatz's conjecture" at http://paste.lisp.org/display/33804
22:24:41 <metaperl> I see two different type signatures for deep and am confused: http://rafb.net/p/BLTu2w64.html
22:24:43 <lambdabot> Title: Nopaste - can these two type signatures for deep be reconcil
22:25:17 <Cale> metaperl: that's because of the arrow and non-arrow interfaces
22:25:40 <metaperl> oh, the first one is the non-arrow interface?
22:25:42 <Cale> yeah
22:25:47 <metaperl> XmlFilter -> XmlFilter -> XmlFilter
22:26:03 <Cale> right
22:26:17 <dons> ?bot
22:26:31 <Cale> er, also, I think the type of deep may be wrong there
22:26:32 <thelsdj> any thoughts on improving that Collatz's conjecture code? thoughts on how to make it lazy?
22:26:40 <Cale> I'd expect XmlFilter -> XmlFilter
22:26:44 <lambdabot> :)
22:26:45 <syntaxfree> question: are manifolds and varieties the same thing?
22:27:15 <syntaxfree> "manifolds" are often translated to "variedades" in portuguese/spanish.
22:27:27 <dons> ?vixen test
22:27:27 <lambdabot> we get along well, you know?
22:27:31 <syntaxfree> The natural translation of "varieties" seems to be "variedades" too.
22:27:33 <syntaxfree> Help? :~
22:27:46 <dons> ?quote lisp
22:27:47 <lambdabot> qwe1234 says: lisp is a wannabe python from the seventies.
22:28:23 <metaperl> emacs *lisp* is best as lisp and no non-parenthetical language would serve as well
22:28:43 <dons> don't worry, qwe1234 is a troll ;)
22:28:51 <Cale> metaperl: yeah, that seems to be an error in that tutorial
22:29:02 <metaperl> what is?
22:29:27 <Cale> deep should have type  XmlFilter -> XmlFilter
22:29:31 <metaperl> I must be the janitor for haskell.org - everyone else reads over the errors, I keep getting stuck with emailing people to fix things :)
22:30:05 <Cale> to be honest, I barely even read that tutorial, I just skimmed it and then started trying to use the library
22:30:39 <sorear> @seen
22:30:40 <lambdabot> Lately, I have seen cale, dons, metaperl, sorear, svnbot6, syntaxfree and thelsdj.
22:30:44 <metaperl> Cale - I think orElse is an XmlFilter and f is also one
22:30:48 <metaperl> so the type might be right
22:30:58 <Cale> metaperl: orElse's type is right
22:31:12 <Cale> orElse :: XmlFilter -> XmlFilter -> XmlFilter
22:31:20 <metaperl> no, orElse took two XmlFilters ... f and (getChildren >>> deep f)
22:31:26 <metaperl> so the sig is right
22:32:03 <metaperl> agreed?
22:32:22 <Cale> XmlFilter -> XmlFilter is the right sig for deep and multi
22:32:37 <metaperl> why?
22:33:05 <metaperl> oh
22:33:08 <metaperl> never mind
22:33:13 <Cale> because they take a filter (which usually acts on a single node), and turn it into one which acts on all subtrees
22:39:51 <sorear> @hylo
22:39:51 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
22:40:08 <sorear> hm, really gone, wonder why
22:44:21 <dons> sorear: no one used it. it was too verbose.
22:44:36 <dons> i purge old plugins once a year or so
22:44:53 <dons> > 1 + 2 -- check
22:44:56 <lambdabot>  3
22:45:26 <sorear> ok, that makes sense
22:45:47 <sorear> I used it once, but that doesn't count because I was trying to figure out what it was for
22:47:33 <sorear> One problem in multi-server is that lambdabot may have multiple names ... and since the server set is variaiable the names can't be a pure variable, which means I've had to delete all the cute special case guards.   (better ideas?)
22:49:38 <sorear> let channel = lowerCaseString lcnick ... where ... lcnick = lowerCaseString nick'  -- just saw this in lambdabot
22:51:10 <metaperl> How do I read this ... deep :: Tree t => a (t b) (t b) -> a (t b) (t b)    ... given t as a Tree , deep takes as input an arrow of type a from a (t b) to a (t b) and returns an arrow of the same type... what does (t b) mean?
22:52:03 <sorear> t is a kind of tree, so it just represents structure. t b is a tree of b's, where b is another type variable.
22:53:37 <metaperl> ok, that is what I suspected. Now, I'm not sure if it makes sense that deep takes an arrow and returns an arrow instead of data
22:56:13 <metaperl> actually I guess it does... then the resultant arrow can be used in a chain with (>>>)
22:56:34 <sorear> (note: I have zero knowledge of HXT)
22:57:26 <mbishop> hmm, even with haskell I can't get problem 2 from project euler to complete in under a minute :\
22:59:16 <mauke> mbishop: whoa. how did you do that?
23:01:38 <syntaxfree> how do I make all elements from a class elements from another class?
23:01:49 <syntaxfree> (I'm writing a Ring class, and I'd like to instance all Integrals)
23:02:27 <mauke> you enable extensions, then write instance (Integral a) => Ring a where ...
23:03:06 <syntaxfree> oh. Glasgow extensions required.
23:05:15 <syntaxfree> @hoogle (<+>)
23:05:17 <lambdabot> Did you mean: (<+>)
23:05:17 <lambdabot> Prelude.undefined :: a
23:05:17 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
23:06:45 <mbishop> mauke: probably because I'm an idiot :P
23:07:19 <mauke> can I see your program?
23:08:13 <mbishop> well it doesn't build right now because it's mad about some IO stuff, but yeah
23:10:17 <lisppaste2> mbishop pasted "even fibs" at http://paste.lisp.org/display/33806
23:10:41 <Cale> > foldl' (+) 0 . takeWhile (< 1000000) . filter even $ fix ((0:) . scanl (+) 1)
23:10:42 <lambdabot>  1089154
23:10:49 <lisppaste2> syntaxfree pasted "Is it bad form / likely to raise problems if I hardcode some properties like this?" at http://paste.lisp.org/display/33807
23:10:52 <mauke> I think you want takeWhile (< 1000000), not take
23:11:14 <mauke> Cale: what's wrong with sum?
23:11:31 <Cale> not much
23:11:34 <Cale> > sum . takeWhile (< 1000000) . filter even $ fix ((0:) . scanl (+) 1)
23:11:36 <lambdabot>  1089154
23:11:44 <syntaxfree> sum is strict?
23:11:54 <Cale> It's not implemented with foldl', so for some big sums, it gives a stack overflow
23:12:09 <mauke> why?
23:12:13 <mbishop> it still doesn't build with ghc...and I don't understand IO type stuff enough to fix it heh
23:12:22 <emu> heh this came up earlier. i'd assume it was foldl' but its just foldl
23:12:33 <Cale> Because that's how it was defined
23:12:40 <mauke> mbishop: missing print
23:13:12 <Cale> There's not a particularly great reason for it. I suppose that in some strange enough number systems, you could know the sum without perfectly knowing all the summands.
23:13:15 <mbishop> mauke: ah yes...I've been using scheme too long :P
23:13:27 <Cale> Or part of the sum without forcing all the summands.
23:13:50 <emu> church numerals?
23:13:58 <Cale> perhaps
23:14:24 <Cale> though if you really wanted good effects with laziness, you'd define it with foldr
23:14:34 <Cale> so the present definition is a little awkward
23:14:40 <emu> yup
23:15:29 <thelsdj> ooh euler project is cool, problem 1 done
23:15:35 <syntaxfree> there was a way to enable glasgow extensions in the code source, with pragmas or something, right?
23:15:41 <syntaxfree> euler project is cool, yes :)
23:15:51 <Cale> personally, I find most of the Euler project's problems kind of boring
23:15:52 <syntaxfree> It seems quite biased towards Haskell, too.
23:15:58 <Cale> the answers are not interesting
23:16:12 <syntaxfree> Cale: you're supposed to do them fast. Instant gratification is what makes them cool.
23:16:16 <Cale> but I suppose finding them efficiently is interesting enough
23:16:33 <emu> not _too_ fast though
23:16:43 <mauke> {-# OPTIONS_GHC -fglasgow-exts #-}
23:17:00 <thelsdj> Cale: have you ever heard of Collatz's conjecture? thats an interesting problem I just read about today (i pasted code a little while ago)
23:17:13 <Cale> thelsdj: yeah, would you like some papers about it?
23:17:18 <thelsdj> sure
23:17:33 <Cale> http://www.math.grinnell.edu/~chamberl/conference/proceedings.html
23:17:36 <lambdabot> Title: Proceedings of 3x+1 Conference, http://tinyurl.com/ydvzqb
23:17:51 <syntaxfree> wow. There was a 3n+1 conference.
23:18:06 <thelsdj> ha thats cool
23:18:19 <Cale> the last one there gives some infinite collections of integers for which the conjecture certainly holds
23:18:39 <Cale> In general, it's a problem which mathematics is not quite ready for.
23:19:19 <Cale> But some people have interesting ideas for attacking it. :)
23:19:32 * syntaxfree wonders if Cale constantly paraphrases mathematicians without quoting'em ;)
23:19:37 <geckosenator> it's still 2006
23:19:44 <geckosenator> ?localtime geckosenator
23:19:47 <lambdabot> Local time for geckosenator is Sun Dec 31 23:52:08 2006
23:19:56 <geckosenator> ooh 8 minutes left
23:20:05 <Cale> syntaxfree: yeah, I believe Erdos said something along those lines too. I agree with him.
23:20:16 <thelsdj> thats a weird time, or my clock is way off
23:20:25 <geckosenator> my clock could be wrong
23:20:42 <thelsdj> your clock is most likely wrong
23:20:46 <benja_> my clock says 09:13 +01:00
23:20:51 <geckosenator> well that's the time i go by
23:20:58 <benja_> no, +02:00 :)
23:21:15 <geckosenator> so whenever it's 2007 that's when i drop the big one
23:21:21 <Cale> Another example of an unsolved problem in mathematics is whether there exist positive integers a,b,c,d with c,d >= 2 such that a^c - b^d = 6
23:21:46 <Cale> But it's much closer to being solved.
23:23:14 <benja_> what would be a good name for a new state monad that remembers whether the state has been modified?
23:23:20 <Cale> A fun thing to do is to write a program which finds a sequence of numbers which don't appear to be differences of perfect powers.
23:23:21 <benja_> (or does such a beast exist already?)
23:23:37 <Cale> benja_: I did a state monad with undo and redo
23:24:00 <Cale> http://www.haskell.org/haskellwiki/NewMonads/MonadUndo
23:24:02 <lambdabot> Title: New monads/MonadUndo - HaskellWiki
23:24:07 <wolverian> StateState? :)
23:26:18 <benja_> 'deriving Monad'! :-)
23:26:38 <Cale> benja_: yeah, I can do that because it's a newtype
23:26:44 <Cale> of something which is already a monad
23:27:08 <benja_> I see
23:27:23 <benja_> can you do that for all type classes and newtypes?
23:27:37 <Cale> yeah, with the newtype-deriving extension in GHC
23:27:46 <benja_> interesting :)
23:29:56 <syntaxfree> "  Constraint is no smaller than the instance head"  ?
23:30:38 <syntaxfree> what does that mean? :~
23:33:31 <Cale> er, could you give a little context?
23:33:59 * sorear pokes the seen-plugin
23:35:34 <syntaxfree> oh,osure.
23:36:07 <syntaxfree> I  thought I'd'first undetstand the problem in abstract terms, and then try to fix it on the code on my own.
23:36:18 <syntaxfree> But anyway, here it goes.
23:37:24 <Cale> I'm not sure exactly what that error is referring to, but with a little context, I could probably guess :)
23:37:25 <dons> sorear: btw, i pushed a bunch of changes a little while ago
23:37:35 <dons> maybe you got them already
23:38:11 <glguy> How much overhead does using a monad transformer with the identity monad incur over using a non monad transformer version?
23:38:50 <lisppaste2> syntaxfree pasted "the problem is at Instance (Num a) => Ring a" at http://paste.lisp.org/display/33808
23:39:03 <dons> Identity itself should add no extra cost, since its a newtype
23:40:02 <Cale> syntaxfree: ah, use -fallow-undecidable-instances if you want to do things like that
23:40:22 <mauke> > let zero <+> x = x in 2 <+> 3
23:40:23 <lambdabot>  3
23:40:28 <mauke> in other words, that doesn't work
23:40:53 <Cale> usually you need to define instances in terms of at least one actual type constructor
23:41:47 <syntaxfree> mauke: um, of course.
23:41:53 <syntaxfree> not a pattern-match.
23:42:01 <syntaxfree> ok, that was stupid.
23:42:04 <syntaxfree> :'(
23:42:15 <sorear> dons: do you have a good idea wrt dealing with a monadic lambdabotName?  I don't want to just drop all the special cases...
23:43:36 <thelsdj> mbishop: you fix your problem 2? (mine runs in 0.01 seconds)
23:44:30 <thelsdj> oh i know why yours is taking so long, you need to take another look at the specifications (if you didn't already notice your problem)
23:44:34 <dons> sorear: I don't understand what you're trying to do?
23:45:48 <dons> dibblego: some interesting ideas. http://programming.reddit.com/info/wlw4/comments
23:45:50 <lambdabot> Title: On strong type systems (reddit.com)
23:45:59 <sorear> lambdabot's name can change, when you add and remove servers.
23:46:16 <dons> note i haven't seen this code yet.... :)
23:46:27 <sorear> the lambdabot code has a lot of guards | nick == configNick myConfig  or something like that.
23:46:35 <dons> if that's the case, then i suppose you'll need a per-serer name Map in the global state
23:46:42 <dons> per-server.
23:46:56 <dons> which is tweaked on update/join/part
23:47:07 <sorear> I already do, *but*, you can't match a String against an IO String in a guard.
23:47:10 <dons> and the static guards become monadic lookups
23:47:18 <dons> need it be in IO?
23:47:28 <sorear> ok, LB String
23:47:45 <dons> right. so you can use a monadic guard construct
23:47:52 <dons> how much code have you written?
23:47:56 <sorear> actually right now I have a Map String ServerInfo and ServerInfo contains siLambdabotName :: LB String
23:48:03 <dons> i like to get small regular patches, versus big chunks I don't understand :)
23:48:04 <sorear> ~2000 lines totat
23:48:08 <dons> hmm...
23:48:19 <dons> do you want to merge it in to the main branch?
23:48:24 <dons> 2k is like 10% of lambdabot..
23:48:49 <sorear> I've got smallish patches, I've been darcs record-ing regularly
23:49:01 <sorear> just not darcs send-ing
23:49:05 <dons> ok. i'd appreciate daily batch bundles, if you're doing this.
23:49:11 <dons> as long as you reach a stable point each day
23:49:16 <dons> that way i can give you feedback too
23:49:42 <dons> its a basic open source thing: communicate your changes regularly, seek consensus and so on
23:49:45 <sorear> right now I'm almost done, everything works except a couple of the plugins (Seen, Topic, Log)
23:50:05 <dons> ok. at this point then you probably should finish, and make sure it all works
23:50:12 <dons> in future, send me small patches regularly :)
23:50:16 <sorear> ok :)
23:51:30 <sorear> what's a monadic guard construct?
23:51:42 <bd_> guard False = mzero; guard True = return ()
23:51:58 <mauke> haha
23:52:07 <bd_> right?
23:54:35 <dons> sorear: just some guard in a monad, no?
23:54:35 <dons> guard p a b = do
23:54:35 <dons>     v <- p
23:54:36 <dons>     if v then a else b
23:54:50 <dons> refactor as you see fit
23:58:49 <sorear> I'm starting to get a feeling like it would be better to stop, get a new repository, and redo all the changes in the opposite direction :(
23:59:10 <dons> its possible
23:59:30 <dons> now you've written so much, it might be worth pulling a fresh tree, and redoing it, now you know what you're dong :)
23:59:33 <dons> doing.
