00:02:51 <kzm> From Data/Stringable.hs (somewhere on the web):
00:02:54 <kzm> -- This module is intended to be imported @qualified@, to avoid name
00:02:54 <kzm> -- clashes with "Prelude" functions.  eg.
00:03:11 <kzm> I'd think the whole point was to rather import Prelude qualified?
00:03:46 <sjanssen> kzm: I believe I wrote the module you're referring to
00:03:50 <kzm> i.e. the point of the Stringable class is to eliminate name clashes?
00:04:08 <sjanssen> kzm: Stringable is only sequences of Char
00:04:21 <sjanssen> so Stringable's head wouldn't work on [Int]
00:04:30 <kzm> Oh, right.
00:04:46 <kzm> Any reason not to split it into ..er.. "Sequenceable" and "Stringable"?
00:05:00 <sjanssen> I have pondered this
00:05:26 <sjanssen> but Sequenceable would require MPTC to do it right
00:05:52 <kzm> It would?
00:06:15 <sjanssen> kzm: yes, if you want to allow things that have kind *
00:06:21 <sjanssen> like ByteString, for example
00:06:37 <kzm> Right.  And I guess you do want that. :-)
00:07:24 <sjanssen> and this MPTC is going to be unusable without a fundep
00:08:46 <kzm> I never quite understood the concerns against MPTCs.  Or fundeps.  Seem perfectly intuitive to me. Wiser people than I object to them, though, so there's probably good reason they're not included (yet).
00:09:16 <sjanssen> my aim at the moment was to stay within H '98
00:09:46 <kzm> Perhaps for H', then.
00:10:22 <sjanssen> fundeps aren't on solid ground for H' either, not sure how I feel about that
00:12:19 <kzm> I think it's a shame we don't have a good framework for collections, though.
00:12:46 <kzm> Loosely copying interfaces around isn't quite the same. :-/
00:12:51 <sjanssen> kzm: have you looked at Edison?
00:13:16 <kzm> Yes.  Long time ago, though.
00:14:50 <kzm> Hmm.. just a (silly?) thought - could you give ByteString a dummy type parameter?
00:14:53 <sjanssen> since Rob Dockins took it over?
00:15:14 <kzm> data ByteString char = PS (Ptr x) ..blah blah
00:15:29 <kzm> To give it the right kind?
00:15:38 <kzm> sjanssen, no, just from the book. :-)
00:15:48 <kzm> I should probably check it out.
00:15:54 <sjanssen> kzm: all the operations are too general
00:16:11 <kzm> Hmm...silly, then.
00:16:13 <sjanssen> say "cons :: a -> t a -> t a" -- how do we get a Word8 out of an a
00:17:19 <kzm> MPTCs, then.
00:39:04 <vincenz> dons: ping
00:39:25 <dons> yo
00:39:35 <vincenz> dons: For some reason it seems #oasis logs got cut yesterday
00:39:42 <dons> ah ok i'll see...
00:39:51 <dons> did the bot disconnect?
00:40:04 <vincenz> Not that I can tell from the logs
00:40:08 <vincenz> She was around
00:40:58 <dons> fixed
00:41:09 <dons> (looks like the network was down briefly when the crontab tried to run)
00:41:27 <vincenz> What had happened, if I may ask?
00:41:38 <vincenz> And thank you :)
00:41:40 <vincenz> dons++
00:41:54 <sieni> @karma dons
00:41:54 <lambdabot> dons has a karma of 95
00:41:58 <sieni> O_O
00:42:04 <sieni> @karma sieni
00:42:04 <lambdabot> You have a karma of 3
00:42:08 <dons> something on the unsw network, between the lambdabot box and the network file server
00:42:17 <dons> such that the scp to copy the logs across didn't run
00:42:17 <sieni> @karma java
00:42:18 <lambdabot> java has a karma of -15
00:42:19 <dons> anyway, fixed now
00:42:20 <sieni> @karma Java
00:42:20 <vincenz> ah right :)
00:42:21 <lambdabot> Java has a karma of -2
00:42:51 <Excedrin> @karma You
00:42:52 <lambdabot> You has a karma of 0
00:43:24 <mgsloan> @karma me
00:43:24 <lambdabot> me has a karma of 0
00:43:51 <mgsloan> @karma YourMom
00:43:52 <lambdabot> YourMom has a karma of 0
00:54:02 <vincenz> dons: Right :)
00:54:33 <newsham> ?pl \x -> 0-x
00:54:34 <lambdabot> (-) 0
00:58:33 * vincenz goes to a course
00:58:40 <Jaak> (0 -)
00:58:46 <kzm> @karma+ QuickCheck
00:58:46 <lambdabot> QuickCheck's karma raised to 11.
00:58:55 * kzm is not the only one :-)
00:58:57 <Jaak> looks like crazy alien smiley
01:14:44 <dons> ?users
01:14:44 <lambdabot> Maximum users seen in #haskell: 278, currently: 250 (89.9%), active: 29 (11.6%)
01:15:03 <lispy> ?lusers
01:15:04 <lambdabot> Maximum users seen in #haskell: 278, currently: 250 (89.9%), active: 29 (11.6%)
01:15:09 <lispy> (sorry, bad joke)
01:15:50 <Vq^> hiya dons
01:15:56 <dons> ?lambdas
01:15:56 <lambdabot> (line 1, column 1):
01:15:56 <lambdabot> unexpected end of input
01:15:56 <lambdabot> expecting white space or simple term
01:16:00 <dons> heh
01:16:23 <Vq^> dons: does lambdabot support ssl irc-connections?
01:16:30 <dons> Vq == valarq?
01:16:38 <dons> Vq^, nope.
01:16:39 <Vq^> yeah
01:16:42 <dons> (though wouldn't be hard)
01:16:46 * Vq^ is volvoq
01:17:12 <Vq^> ok, what would be the easiest way to implement it?
01:17:45 <dons> take lambdabot, see how it connects to the network (it already has some support for multiple connectoins modes), add an ssl layer
01:18:05 <dons> using one of the existing ssl binding libs, I guess
01:18:08 <lispy> even easier is to slip in stunnel between lambdabot and irc
01:18:31 <dons> ah yes
01:18:36 <dons> yeah, a script for that would be nice
01:19:04 <lispy> stunnel or gnutls
01:19:06 <lispy> it's up to you
01:19:14 <Vq^> lispy: is that possible when the server only accepts ssl connections?
01:19:15 <dons> good idea
01:20:49 <lispy> Vq^: i don't know all the details, but i know i've used stunnel and the like to turn plain text things into ones that speak ssl.  I've done it with emacs and with some propretary software at work
01:21:35 <lispy> Vq^: if the ssl version has a different protocol than non-ssl you may run into trouble, but if ssl is just used to make it secure then you should be golden
01:21:46 <Vq^> ok, i'll have a look at it
01:22:01 <Vq^> it is irc so i believe it's just used as a wrapper
01:22:10 <Vq^> @karma+ lispy
01:22:11 <lambdabot> lispy's karma raised to 21.
01:22:15 <m-hussein> i am your favourite newbie
01:22:30 <Vq^> m-hussein: hello favourite :)
01:23:09 <lispy> Vq^: cheers, i'll be interested to hear how it turns out
01:23:23 <dons> m-hussein: learning haskell?
01:23:56 <dons> > fix ((1:) . scanl (+) 1) -- have a fixpoint!
01:23:57 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
01:24:06 <m-hussein> well it looks interesting! i haven't tried it yet!
01:24:30 <dons> grab ghc then (from http://haskell.org) and get hacking! :)
01:24:32 <lambdabot> Title: Haskell - HaskellWiki
01:26:20 <dons> swiert: hey, coming to the hackathon?
01:26:24 <mbishop> hmm
01:27:37 <mbishop> >fib = 0:scanl (+) 1 fib
01:27:45 <mbishop> > fib = 0:scanl (+) 1 fib
01:27:45 <lambdabot>  Parse error
01:27:55 <mbishop> heh
01:28:15 <dons> > let fib = 0:scanl (+) 1 fib in fib
01:28:16 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
01:28:29 <mbishop> ah, heh
01:28:55 <swiert> dons: nope - I'm afraid not.
01:29:17 <dons> ok, pity :)
01:29:37 <swiert> I think I'll be in the Netherlands..
01:29:40 <swiert> Let me check.,
01:30:07 <dblhelix> dons: how many participants already for Hac?
01:30:14 <mbishop> > let fib = 0:scanl (+) 1 fib in fib !! 200
01:30:15 <dons> everyone: the details for the hackathon are here: http://www.haskell.org/pipermail/haskell-cafe/2006-December/020101.html
01:30:15 <lambdabot>  280571172992510140037611932413038677189525
01:30:17 <lambdabot> Title: [Haskell-cafe] Hac 2007 : Haskell Hackathon - extended registration, http://tinyurl.com/vbnda
01:30:19 <dons> dblhelix: 12 so far
01:30:30 <dons> so there's room for 8-10 more
01:30:33 <dblhelix> dons: that's not so bad
01:31:00 <dons> yeah, 12 will be fine. we'll prob. get a few more still
01:33:51 <dons> hello dcoutts.se
01:34:01 <dcoutts__> hia :-)
01:34:04 <dons> dcoutts.se: learning haskell?
01:34:10 <dcoutts__> hah hah hah
01:34:15 <dons> > fix ((1:) . scanl (+) 1) -- have a fixpoint!
01:34:17 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
01:34:19 * dcoutts__ should go join #haskell.se
01:34:22 <dons> and be sure to visit haskell.org
01:34:40 * dcoutts__ tries to think of a newbie Q
01:34:47 <dons> 20:29 dons> ?users #haskell.se
01:34:47 <dons> 20:29 lambdabot2> Maximum users seen in #haskell.se: 13, currently: 9 (69.2%), active: 0 (0.0%)
01:34:58 <dons> still going strong
01:35:14 <dons> dcoutts__: i put out the hac07 confirms and reminder to -cafe
01:35:24 <dcoutts__> dons: great
01:35:28 <dons> dcoutts__: also, did you really catch a ferry to .se?
01:35:33 <dcoutts__> yep
01:35:38 <Syzygy-> dcoutts__: From UK?
01:35:38 <dons> how long does that take?
01:35:45 <Syzygy-> Or from where?
01:35:49 <dcoutts__> Harwich to Esjberg
01:36:12 <Syzygy-> Ehm.... Esjberg does very much NOT sound like a swedish place. :)
01:36:20 <swiert> dcoutts__: have you heard anything from CUP btw?
01:36:36 <dcoutts__> swiert: not since leaving the UK
01:37:00 <dcoutts__> Syzygy-: aye, then the train to Copenhagen and Stockholm
01:37:22 <dcoutts__> I would have sailed directly to Sweden but they sold the ferry I was booked on
01:37:23 <Syzygy-> Right. So ferry to Denmark and then by train onwards. That sounds more sane. :)
01:38:28 <dcoutts__> in the summer I got the ferry direct to GÃ¶teborg
01:38:50 <swiert> dcoutts__: That's a bit worrying.
01:39:09 <swiert> What are you up to in Sweden?
01:39:16 <dcoutts__> swiert: it may have arrived this week, I'll get someone to check my pidgeon hole in the comlab
01:39:26 <Syzygy-> IIRC, his fiancee is at a research program in Stockholm.
01:39:33 <Syzygy-> (or something like that)
01:39:39 <dons> fiancee?
01:39:44 <Syzygy-> Or gf...
01:39:45 <dons> is that news, dcoutts__ ?
01:39:47 <dcoutts__> something like that (not fiancee, gf)
01:39:54 * Igloo wonders what is arriving from CUP
01:39:56 <dcoutts__> no news
01:40:02 <Syzygy-> dons: it's a case of me very much not remembering details. Sorry. *.*
01:40:42 <dcoutts__> Igloo: a 16 ton weight, in christmas wrapping paper
01:41:16 <dons> mmm:
01:41:17 <dons> "Its difficult to explain how Haskell manages complexity, or in fact how it manages to be a programming language at all (no assignment statements) without just teaching the language.  This is a classic example of the Blub Paradox ( http://www.paulgraham.com/avg.html ).  All I can really say is that once you have learned the language you will understand.  But not until.  Sorry about that, its just in the nature of things."
01:41:18 <lambdabot> Title: Beating the Averages
01:42:12 <dcoutts__> dons: so this is a case of the language you use limiting the things you can think
01:42:50 <dons> yep
01:44:46 <kzm> Apropos: I talked to Lars Magne Ingebriktsen, of gmane and gnus fame.  He actually writes Lisp code at work, but implemented his hobby project (gmane) in (mostly) C.
01:44:56 <m-hussein> i can't understand how can i implement location memory and stack into a recursion!
01:45:07 <kzm> (Rather opposite of what you'd expect)
01:46:02 <dons> m-hussein: hmm. that doesn't make much sense. you're working on the wrong level of abstraction
01:46:06 <dons> m-hussein: do you have a tutorial?
01:46:20 <dons> ?where yaht
01:46:20 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
01:46:23 <dons> is a good one ^^
01:49:48 <m-hussein> can someone explain how can i put a tail to my recursion
01:50:37 <dcoutts__> dons: I like your grey layout lines btw, would be great in a haskell editor
01:50:54 <dcoutts__> when/if I ever get back to hacking on hIDE
01:50:56 <kzm> m-hussein, I don't understand what you are asking.
01:50:58 <dons> :)
01:51:08 <dons> m-hussein: what did  you mean by this: 20:16  m-hussein> i am your favourite newbie
01:51:15 <kzm> btw, haddock doesn't grok .lhs -- or is my version just outdated?
01:51:30 <m-hussein> dons i wanted to declare that i am a newbie
01:51:30 <kzm> (and what's the ghc option to just unlit?)
01:51:42 <m-hussein> well is it tail or non tailed recursion which was using stack
01:51:44 <m-hussein> uh
01:52:00 <dons> ok. do  you have the code somwhere?
01:52:18 <dcoutts__> kzm, ghc -E I think
01:52:26 <therp> m-hussein: tail recursion is a certain condition on the recursive function invokation, see http://en.wikipedia.org/wiki/Tail_recursion
01:52:27 <dcoutts__> kzm, and yes, it doesn't grok .lhs
01:52:33 <dcoutts__> it = haddock
01:52:35 <kzm> dcoutts, thanks!
01:53:16 <therp> strange english, why is it "invocation" but "invoke"?  hmm.
01:53:49 * kzm tried to use 'it' on the Unix cmdline.  GHCi has apparently damaged my brain.
01:53:50 <dons> english is broke
01:53:56 <dons> kzm hehe
01:54:21 <Vq^>  /join #Haskell.lojban
01:54:25 <Vq^> :o)
01:54:41 <kzm> Hmm... haddock didn't like the #line thing inserted by ghc -E either.
01:54:53 <dons> kzm, are you building with cabal?
01:55:00 <dons> it should handle the preprocessing for you
01:55:39 <kzm> dons, no I wasn't --- I guess I am now :-)
01:55:48 <kzm> (just wanted to check the syntax of my annotations)
01:56:02 <kzm> (the file isn't part of the cabal setup yet)
01:56:33 <m-hussein> i really can't understand anything
01:58:39 <kzm> m-hussein, what is *really* your problem?  Do you get a stack overflow in a recursive function?
01:59:06 <m-hussein> kzm no i am planning to make a recursive function
01:59:15 <m-hussein> but i don't understand recursion properly
01:59:45 <Syzygy-> kzm: I think the problem is very much more fundamental - m-hussein got the suggestion to go here when the inhabitants of #math grew tired of trying to explain recursion in there.
01:59:53 <m-hussein> i am trying to make depth first search thingy but i can't understand how can i make it to remember the nodes where it already visited!
01:59:54 <dons> Syzygy-: ah.
02:00:05 <dons> m-hussein: ok. please stop asking about recursion. go and write something.
02:00:05 <kzm> m-hussein, well, just go ahead and try it out.  If you get stuck or confused, paste the function to lisppaste, and ask again.
02:00:19 <m-hussein> ok ok ok'
02:01:46 <kzm> m-hussein, start with something non-cyclic, where you don't have to remember visited nodes.
02:01:55 <dons> kzm, too much info :)
02:02:48 <m-hussein> hmh my algorithm doesn't have anything cyclic!
02:03:03 <dons> m-hussein: less talk, more code
02:03:12 * m-hussein sobs quietly
02:03:56 <dons> i'm sorry. its impossible to teach fundamentals of computer science via irc. you've been given resources, use them. being noisy will only annoy people.
02:04:10 <dons> (which apparently already happened in #math)
02:04:33 <m-hussein> i was too lazy to go to lectures!
02:04:37 <dons> sssh
02:04:45 <mbishop> heh
02:04:47 <m-hussein> actually i have missed all cs lectures so far!
02:04:56 <TSC> Are you one of my students?
02:05:02 <TSC> Because you do a good impression (:
02:05:15 * m-hussein panics
02:05:27 --- mode: ChanServ set +o dons
02:05:33 <mbishop> so anyone here used "Halfs?
02:05:36 --- mode: dons set +b *!*i=hussein@*.kpylaajakaista.net
02:05:37 --- kick: m-hussein was kicked by dons (known troll)
02:05:45 --- mode: ChanServ set -o dons
02:06:08 <therp> wouldn't a kick be enough?
02:06:28 <dons> i'll knock it off later. he's been banned in 2 other channels for this newbie-simulation stuff
02:06:34 <dons> (as well as racism and trolling)
02:06:39 <therp> oh ok. forget my comment
02:06:44 <dons> so i don't think we're going to see a major haskell convert here :)
02:07:12 <dons> mbishop: well, SyntaxNinja wrote it
02:07:16 <dons> some here have played around with it
02:07:47 <dons> mnislaih_: hey, thanks for adding your details to the hac wiki
02:07:59 <mnislaih_> hey dons.
02:08:07 <mnislaih_> Just came back from Google Dublin,
02:08:14 <dons> cool, how was that?
02:08:21 <mnislaih_> The ghci debugger talk was a success!
02:08:32 <mnislaih_> some google engineer mentioned they had a little project with Haskell there
02:08:32 <dons> you gave that talk to google?
02:08:37 <dons> huh!
02:08:45 <mnislaih_> a small lightning talk
02:08:46 <dons> mnislaih++ yay!
02:09:11 <mnislaih_> and there was a student from Utrecht there who wanted to download the debugger immediately so
02:09:14 <dons> yeah, in mountain view google, they said that had a few small side things, nothing official
02:09:15 <mnislaih_> !! yay !!
02:09:22 <dons> cool
02:09:28 <dons> let's get it into ghci for the hackathon then, eh?
02:09:30 <dons> and released!
02:09:43 <mnislaih_> yes I hope to be sending the patches before that
02:09:47 <dons> great
02:09:58 <Cale> Man, that 0/0 article is scary. I can't believe they're letting him teach that to children.
02:10:11 <mbishop> 0/0?
02:10:12 <dons> Cale: yes. :/
02:10:30 <Cale> http://www.bbc.co.uk/berkshire/content/articles/2006/12/06/divide_zero_feature.shtml -- as seen on programming reddit
02:10:33 <lambdabot> Title: BBC - Berkshire - Features - 1200-year-old problem 'easy', http://tinyurl.com/yl47tq
02:10:48 <Cale> He claims that it's a 1200 year old problem.
02:11:06 <Cale> It's not "easy" which should be in scare quotes there, but "problem".
02:11:08 <dons> i just hope its being very badly reported
02:11:13 <opqdonut> the guys just come up with a new and inconsistent version of NaN
02:11:17 <Cale> No, watch the video
02:11:34 <kzm> ...the conventional number line (stretching from negative infinity, through zero, to positive infinity).
02:12:05 <Cale> He stands there and describes the rules, he's adding infinity and -infinity, and then nullity, and he ends up with something which isn't even remotely a ring, and a division which doesn't satisfy properties which are anything like division.
02:12:23 <dons> why are so many cranks attracted to math?
02:12:30 <dons> (and physics)
02:12:33 <kzm> Sounds like he should term it 'sillity' instead.
02:12:33 <mbishop> heh I like the example, "if your auto pilot divides by zero!"
02:12:43 <kzm> dons, and Haskell!
02:12:52 * dons is reminded of http://programming.reddit.com/goto?id=txya
02:12:55 <lambdabot> Title: Crackpot index
02:13:11 <Cale> The only way in which his construction is even remotely relevant is topologically, where it's just the 2-point compactification of the reals, union a single point.
02:15:17 <mbishop> Must be why this "Doctor" is teaching schoolkids :)
02:15:38 <kzm> I have a great suggestion for a symbol for nullity: _|_
02:16:06 <dons> :)
02:16:18 <dons> I think Nothing also works
02:16:57 <kzm> Hmm...yes.  I guess any monad, using 'fail'?
02:17:14 <Cale> I like how his symbol for nullity is basically a poorly drawn capital Phi.
02:17:34 <kzm> Fish in a barrel.  Oh, well, next crackpot please!
02:17:55 <Cale> Yeah, shame on Haskell for fail, hehe
02:18:28 <opqdonut> :)
02:18:51 <Vq^> lispy & dons: stunnel worked like a charm
02:19:13 * kzm blinks.  Check the caption for the first photo (the poorly drawn Phi one)
02:19:32 <kzm> "The symbol for nullity (bottom)"
02:19:39 <kzm> Hey - it *is* _|_!
02:20:00 <dons> Vq^: great!
02:20:09 <dons> Vq^: could you write down the details, for setting it up?
02:20:15 <dons> and submit a patch to the README?
02:21:01 <Vq^> dons: sure, thought it would become very gentoo specific with the current solution
02:21:15 <dons> ok. that's fine.
02:21:21 <dons> i guess the tools are fairly widespread though
02:21:37 <opqdonut> what's stunnel?
02:21:53 <Vq^> maybe i should try invoking stunnel with a separate configfile first
02:22:02 <dons> ssl tunnel wrapper (just used to tunnel lambdabot into irc via ssl)
02:22:02 <mbishop> "secure tunnel"
02:23:04 <kzm> Oh, btw - is there an updated haskell-mode around?  The one shipped with Ubuntu seems to be a bit dysfunctional.
02:23:05 <opqdonut> oh, nice
02:23:18 <dons> kzm, for emacs?
02:23:37 <kzm> sorry, yes, for emacs.  Xemacs to be precise.
02:23:42 <dons> other than the one on haskell.org?
02:23:58 <dons> http://www.haskell.org/haskell-mode/
02:23:59 <lambdabot> Title: Haskell Mode for Emacs
02:24:00 <kzm> Hmm.. I guess I'll have to check.
02:24:02 <dons> ?where+ haskell-mode http://www.haskell.org/haskell-mode/
02:24:03 <lambdabot> Done.
02:24:26 <kzm> Are you subtly hinting that I should ask a computer before I ask on IRC? :-)
02:24:32 <dons> no no :)
02:24:42 <dons> I just assumed you already asked the computer
02:25:48 <therp> the more advanced compilers submit their optimization problems to #haskell disguised as newbie questions.
02:26:09 <dons> heh, I hit dons (500) karma on reddit :)
02:26:16 <dons> the haskell victory is complete
02:26:25 <dons> therp: hehe
02:26:31 <kzm> Ah.  Right.  Anyway - the haskell.org one is dated Nov 2005, and appears to be the same version number.
02:26:36 <dons> ah ok
02:26:43 <dons> i think there's been a newer version though
02:27:09 <dons> mm, maybe bot, http://thread.gmane.org/gmane.comp.lang.haskell.general/12044
02:27:11 <dons> s/not/
02:27:11 <lambdabot> Title: Gmane Loom
02:27:15 <kzm> I'll check if there is some old cruft lying about confusing my system.
02:28:23 <Syzygy-> dons: How do you get karma on reddit at all?
02:29:52 <dons> submitting and commenting, I think
02:30:00 <dons> basically some percent of the up mods on articles
02:34:50 <Cale> 13 of the newest 100 articles on programming reddit are ones which are haven't modded down
02:35:12 <dons> is that some kind of new high score? :)
02:35:15 <Cale> I haven't :)
02:35:18 <Cale> yeah
02:35:24 <Cale> Usually it's around 19
02:39:21 <Cale> hehe, did you catch the comment I added to that "Framework comparisons" article?
02:39:27 <Cale> http://www.djangoproject.com/weblog/2006/dec/06/comparisons/
02:39:29 <lambdabot> Title: Django | Weblog | Framework comparisons
02:39:42 <Cale> Perhaps a little overboard for what it was :)
02:39:52 <roconnor> Gmane is surprisingly hard to use
02:40:54 <therp> roconnor: really? I love gmane. mailing list subscriptions/participation has never been so easy
02:41:35 <roconnor> How do I find a thread?
02:41:39 <dons> roconnor: yeah, I find it a bit awkward
02:41:48 <dons> i just search it via a cmd line tool these days
02:42:14 <dons> Cale: hehe :)
02:42:20 <dons> Cale++ school them good
02:42:30 <roconnor> Re: The Data.Array.* hierarchy is unsafe doesn't appear in http://news.gmane.org/gmane.comp.lang.haskell.libraries at all
02:42:32 <lambdabot> Title: Gmane Loom
02:43:07 <dons> "Cale: Whoa! Thanks for the awesome explanation/correction. I've fixed the entry."
02:43:10 <dons> hahah
02:43:12 <Cale> hehe
02:43:22 <Cale> I hope everyone brought a well-sharpened number Truth pencil.
02:44:19 <dons> we need tshirts "I've been corrected by Cale"
02:44:26 <Cale> haha
02:46:13 <Vq^> dons: you got mail (it's not spam)
02:48:37 <roconnor> the problems with Data.Array.* just goes to show that we need to program with dependent types.
02:53:07 <metaperl> the the degree of a tree can be specified with the Haskell type system right?
02:55:45 <metaperl> Cale - he said dynamic vs. static not dynamic vs. compiled
03:05:57 <ski> metaperl : i believe it possibly said "dynamic vs. compiled" before he fixed it ..
03:06:00 <dons> Vq^: thanks
03:06:08 <metaperl> ski - i see
03:06:16 <ski> (he being 'Adrian Holovaty')
03:07:50 <Cale> metaperl: yeah, he's corrected it since
03:07:58 <metaperl> i see
03:18:41 <rc-1> does lazy eval make for more or less speed?
03:19:45 <rc-1> only has to do what it needs,  which would make faster, but it has to do constant pattern matching/find which makes slower
03:20:05 <rc-1> so about same?
03:23:42 <mwc> rc-1, I'd say that it increases constant factors, but can decrease the asymptotic class
03:24:06 <mwc> > head $ map (+1) [0..]
03:24:07 <lambdabot>  1
03:24:43 <mwc> that's done in constant time. In an eager language, the right side of $ would be executed taking O(n) time and never finishing
03:24:58 <mwc> s/finishing/finish
03:26:51 <rc-1> well thats not eqivalent of other languages though, they would just set a stopping point....
03:32:45 <ms_> ?where tutorial for learning about concurrency in Haskell? ;-)
03:32:45 <lambdabot> http://www.haskell.org/tutorial/
03:33:02 <ms_> mmmm. any human-based answers?
03:33:32 <ToRA> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html
03:33:34 <ToRA> ?
03:33:34 <lambdabot> http://tinyurl.com/y2q5k2
03:39:18 <dons> ms_ 'Tackling the Awkward Squad'
03:39:20 <lray80de> Hi. I think, I have a problem of understandment: when doing
03:39:21 <lray80de> time :: IO t -> IO t
03:39:21 <lray80de> time a = do
03:39:21 <lray80de>     start <- getCPUTime
03:39:21 <lray80de>     v <- a
03:39:21 <lray80de>     end   <- getCPUTime
03:39:23 <lray80de>     let diff = (fromIntegral (end - start)) / (10^12)
03:39:25 <lray80de>     putStrLn "Computation time:"
03:39:27 <lray80de>     print (diff :: Double)
03:39:29 <lray80de>     return v
03:39:31 <lray80de> test = do
03:39:33 <lray80de>          putStrLn "Starting..."
03:39:35 <lray80de>          time $ product [1..10000] `seq` return ()
03:39:37 <lray80de>          putStrLn "Done."
03:39:39 <lray80de> the result is a nice value.
03:39:45 <profmakx> what the?
03:40:15 <lray80de> when doing the same (by equal time-method) with
03:40:17 <lray80de> test = do
03:40:17 <lray80de>          putStrLn "Starting..."
03:40:17 <lray80de>          time $ test2 `seq` return ()
03:40:17 <lray80de>          putStrLn "Done."
03:40:17 <lray80de> test2 = doTest testMethod wordList2 wordList2
03:40:17 <lray80de> doTest :: String -> [String] -> [String] -> [ Double ]
03:40:19 <lray80de> doTest _ [] _ = []
03:40:21 <lray80de> doTest z (x:xs) [] = doTest z xs xs
03:40:23 <lray80de> doTest z (x:xs) (y:ys) = result : (doTest z (x:xs) (ys))
03:40:25 <lray80de>                          where (TFloat result) | z == "editDistance"  =  editDistance (Text x) (Text y)
03:40:27 <lray80de>                          | z == "jaroMetrics"   =  jaroMetrics (Text x) (Text y)
03:40:29 <lray80de>           | z == "qGramMetrics"  = qGramMetrics (Text x) (Text y)
03:40:31 <lray80de> ..the result is always zero. why?
03:40:43 <dons> because you only evaluate the [Double] to weak head normal form
03:40:49 <lray80de> sorry, a lot of code, but I'm desperate.
03:40:53 <dons> try: time $ length test2 `seq` return ()
03:41:02 <rc-1> heard of paste bin?
03:41:05 <dons> (whihc will evaluate the list along its entire length)
03:41:12 <dons> lray80de: yes, and much better to use ?paste
03:41:14 <dons> ?paste
03:41:14 <lambdabot> http://paste.lisp.org/new/haskell
03:41:48 <dons> > [1..] `seq` ()
03:41:49 <lambdabot>  ()
03:41:51 <lray80de> aehm, sorry, yepp, will use it next time.
03:41:56 <dons> > length [1..] `seq` ()
03:42:00 <lambdabot> Terminated
03:42:05 <dons> that's the difference
03:46:03 <ms_> dons: thanks; and thank goodness for department wide free printing! ;-)
03:47:00 <dons> basically you'll want to understand forkIO and the MVar interfac
03:47:03 <dons> should be pretty simple
03:50:19 <lray80de> when using  time $ length test2 `seq` return (), it still returns 0.0
03:51:21 <dons> lray80de: have you already computed the result somehow?
03:52:02 <dons> (maybe the result is cached?)
03:52:20 <lray80de> no, that would be too easy.
03:52:48 <dons> length should work. something else is going on in the code.
03:53:06 <dons> try pasting (via lisppaste) the full code, and a transcript of how you're running it
03:53:08 <dons> ?paste
03:53:09 <lambdabot> http://paste.lisp.org/new/haskell
03:53:12 <ms_> quantum computer?
03:53:20 <opqdonut> :)
03:54:39 <lisppaste2> rc-1 pasted "just a test" at http://paste.lisp.org/display/31488
03:56:29 <lisppaste2> lray80de pasted "computational time" at http://paste.lisp.org/display/31489
03:57:50 <lray80de> okay, done.
03:58:57 <dons> and how are you running this?
03:59:00 <dons> in ghci? compiled?
03:59:02 <dons> what data?
03:59:10 <Baughn> rc-1: That's one of the faster-growing (shrinking?) functions I've seen in a while
03:59:13 <lray80de> ghci 6.6 with -fffi
03:59:35 <dons> you're using the ffi?
03:59:42 <lray80de> yes.
04:00:11 <Cale> Baughn: I liked the one from the other day, iterate (\x -> x^x) 2
04:00:11 <dons> it helps to include the full src in the pastes. including import statements
04:00:37 <dons> lray80de: since the code you pasted doesn't help me: i can't run it
04:00:38 <sieni> > iterate (\x -> x^x) 2
04:00:42 <lambdabot> Terminated
04:01:18 <rc-1> > let test = 10 : 1 : scanl (*) 2 (zipWith (/) test (tail test)) in test
04:01:19 <lambdabot>  [10.0,1.0,2.0,20.0,10.0,1.0,2.0,20.0,10.0,1.0,2.0,20.0,10.0,1.0,2.0,20.0,10....
04:01:24 <Cale> > take 3 $ iterate (\x -> x^x) 2
04:01:25 <lambdabot>  [2,4,256]
04:01:28 <rc-1> ah pattern L:)
04:01:32 <Cale> > take 4 $ iterate (\x -> x^x) 2
04:01:33 <lambdabot>  [2,4,256,3231700607131100730071487668866995196044410266971548403213034542752...
04:01:44 <ms_> lambdabot should say "I could tell you but only once you've died from old age..."
04:01:54 <dons> Cale: nice.
04:02:01 <Cale> > length . show $ iterate (\x -> x^x) 2 !! 4
04:02:05 <lambdabot> Terminated
04:02:06 <Baughn> Crashed ghci, too. :/
04:02:10 <dons> ?pl \x -> x^x
04:02:11 <lambdabot> join (^)
04:02:11 <Cale> > length . show $ iterate (\x -> x^x) 2 !! 3
04:02:13 <lambdabot>  617
04:02:23 <lray80de> dons: okay, I try to get everything in a good-looking state...
04:02:29 <dons> > length . show $ iterate (\x -> x^x) 2 !! 4
04:02:32 <dons> :)
04:02:33 <lambdabot> Terminated
04:02:54 <dons> lray80de: i'm off to bed. length list`seq` return () should be fine though. think hard about what's going.
04:03:17 <mbishop> I'm going to bed too...6am :)
04:03:28 <ms_> it's 12pm!
04:03:29 <rc-1> whats that function that grows REALLY fast that didnt take full turing machiene? started with an a....
04:03:44 <lray80de> wow, where are you? It's 1 p.m. over here... :-)
04:03:53 <rc-1> seven am here
04:03:59 <Baughn> rc-1: Ackerman's?
04:04:03 <Cale> dons: think about how many digits it'd have
04:04:04 <rc-1> yeah
04:04:15 <mbishop> I'm in the states...louisiana to be exact :P
04:05:05 <ms_> do you get a value if you leave of the / (10^12) ?
04:05:10 <Baughn> > (show $ iterate (\x -> x^x) !! 4) !! 0
04:05:11 <lambdabot>    Expecting a function type, but found `[a]'
04:05:11 <lambdabot>    Expected type: [a]
04:05:11 <lambdabot>   ...
04:05:29 <Baughn> > (show $ iterate (\x -> x^x) 2 !! 4) !! 0
04:05:33 <lambdabot> Terminated
04:05:58 <lray80de> mbishop kind regards from eastern-germany. :-)
04:09:13 <lisppaste2> rc-1 pasted "akermans" at http://paste.lisp.org/display/31490
04:09:29 <rc-1> oops didtn mean to hit send yet
04:10:07 <Baughn> rc-1: You're right, though. It won't work.
04:10:15 <rc-1> lol
04:12:58 <lray80de> ms_ no, unfortunately not.
04:13:54 <lisppaste2> thoms80de annotated #31489 with "computational time, whole source..." at http://paste.lisp.org/display/31489#1
04:16:42 <lisppaste2> rc-1 pasted "akermans" at http://paste.lisp.org/display/31491
04:17:15 <rc-1> does that do it?
04:17:58 <Baughn> rc-1: Nope, wrong syntax
04:18:57 <Baughn> rc-1: Also, you could just say "ackermans 0 n = n + 1" and so on
04:19:06 <Baughn> rc-1: But the order of the definitions matters
04:21:31 <rc-1> ah ok thanks
04:22:06 <lisppaste2> Baughn annotated #31491 with "Mine" at http://paste.lisp.org/display/31491#1
04:22:46 <dons> lray80de: try this:  time $ (foldl' (\_ b -> b `seq` 0) 0 (test2)) `seq` return ()
04:23:47 <dons> (basically, the seq still isn't deep enough, it only checks the spine of the list)
04:23:50 <dons> (we really need deepSeq to be thorough)
04:23:58 <earthy> dons, regarding your request for those gray vertical bars in vim
04:24:04 <dons> oh, yes?
04:24:06 <earthy> would an automatic indenter help?
04:24:22 <dons> well, maybe.
04:24:32 <earthy> you do know there is one, right? :)
04:24:38 <dons> i'm fairly ok with the indenting, but I think the bars would help beginners
04:24:46 <dons> (its not really for me :)
04:24:49 <earthy> ah.
04:24:52 <earthy> right. :)
04:24:58 <dons> earthy: oh, is there a standalone tool?
04:25:02 <earthy> um.
04:25:04 <earthy> no. :)
04:25:04 <dons> ?wiki Indent
04:25:05 <lambdabot> http://www.haskell.org/haskellwiki/Indent
04:25:08 <dons> are those I know about
04:25:25 <dons> and the vim mode
04:25:27 <dons> (and emacs mode)
04:25:47 <earthy> there is a special indenter to make vim's indenting work better with haskell
04:25:56 <dons> the new one?
04:26:05 * earthy nods
04:26:13 <dons> ok, i'll have to get vim 7 and try it out
04:27:04 <earthy> actually, it also works with 6.2
04:27:20 <lray80de> dons: changed the foldl' to foldl (or which module is foldl' in)... but didn't make any efforts,
04:27:44 <dons> lray80de: the seq on the elements is the important thing
04:27:44 <lray80de> ,=.
04:28:01 <dons> > length $ [1..10] ++ [undefined]
04:28:02 <lambdabot>  11
04:28:16 <dons> > foldl' (\_ b -> b `seq` 0) 0 $ [1..10] ++ [undefined]
04:28:18 <lambdabot>  Undefined
04:28:46 <lray80de> dons: where do I get the foldl' from?
04:28:46 <earthy> http://tokyoenvious.xrea.jp/vim/indent/haskell.vim
04:28:52 <dons> lray80de: if that really doesn't work, then I'm not sure what's going on. Try the mailing list.
04:29:02 <dons> earthy: yeah, that one. I couldn't get it working in vim 6.3
04:29:07 <dons> but you've had it working in 6.2?
04:29:32 <dons> hehe, here's a challenge for anyone bored, http://www.haskell.org/pipermail/haskell-cafe/2006-December/020102.html
04:29:34 <lambdabot> Title: [Haskell-cafe] Designing an object model in Haskell, http://tinyurl.com/y9cqnh
04:29:52 <lray80de> > foldl (\_ b -> b `seq` 0) 0 $ [1..10] ++ [undefined]
04:29:53 <lambdabot>  Undefined
04:30:06 <lray80de> strange.
04:30:23 <dons> lray80de: could the problem be you're actually solving it fast?
04:30:36 <earthy> hm. weird. it doesn't seem to want to work with 6.2
04:30:40 <dons> or have you timed it using an external tool, like time
04:31:35 <lray80de> have experimented with other algorithms and got it working once... I'll retry it with another Algo.
04:31:59 <dons> lray80de: also, if you're stuck on the timing issues, ask on haskell-cafe@
04:32:10 <dons> but be sure to provide enough material to reproduce the issue
04:32:23 <earthy> right. I knew it was sucky. :)
04:32:29 <dons> heh
04:32:47 <lray80de> haskell-cafe is another irc-chat, or the mailing-list?
04:32:53 <dons> the mailing list
04:32:56 <dons> ?where mailing-list
04:32:57 <lambdabot> I know nothing about mailing-list.
04:33:00 <dons> ?where mailinglist
04:33:00 <lambdabot> http://haskell.org/haskellwiki/Mailing_lists
04:33:29 <lray80de> dons okay. thnx very, very much, I'll keep on trying around.
04:34:04 <dons> do you understand why things appear to take no time to evaluate?
04:35:09 <gaal> what's the best way to upgrade my Cabal on a debian unstable system? I'm getting the error:
04:35:13 <gaal> Parse of field 'build-depends' failed
04:35:15 <gaal> when building pugs
04:35:27 <gaal> and I suspect it's an old cabal.
04:35:44 <gaal> ghc 6.6 from debian.
04:37:02 <Igloo> It shouldn't be an old cabal problem
04:37:23 <dons> Igloo: do you have a head installed?
04:37:35 <Igloo> Possibly, why?
04:37:37 <dons> does this parse:
04:37:38 <dons> main = do
04:37:38 <dons>     !c <- return ()
04:37:38 <dons>     return ()
04:37:51 <dons> you'll need -fbang-patterns
04:37:59 <notsmack> is my understanding right that ghc translates .hs to c and then uses gcc?
04:38:02 <dons> (the ~ pattern version does)
04:38:12 <earthy> notsmack: it can if you compile -fvia-C
04:38:16 <gaal> Igloo: hmm, i just noticed that libghc6-cabal-dev is uninstallable
04:38:20 <dons> notsmack: it also compiles directly to assembly (with -fasm), and to bytecode, if you use ghci
04:38:23 <gaal> maybe that's part of the problem?
04:38:35 <Igloo> dons: "Empty 'do' construct", same as ghc 6.6
04:38:39 <dons> ok
04:38:42 <dons> i'll report it
04:38:57 <notsmack> interesting... is the same true for ARM?
04:38:58 <Igloo> gaal: It's older than the one in ghc6
04:39:06 <dons> ?undo c <- return (); return ()
04:39:06 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 3}) "Parse error"
04:39:12 <dons> ?undo do c <- return (); return ()
04:39:13 <lambdabot> return () >>= \ c -> return ()
04:39:19 <gaal> Igloo: oh. so any idea how to make sense of this error?
04:39:53 <dons> so this works: main'' = return () >>= \ (!c) -> return ()
04:40:16 <dons> Igloo: ah:
04:40:17 <dons> main = do
04:40:17 <dons>     (!c) <- return ()
04:40:17 <dons>     return ()
04:40:20 <gaal> oh wait, i think i figured it out. I was generating the cabal file but messed it up.
04:40:20 <dons> is needed
04:40:23 <gaal> oops :)
04:40:30 <dons> (bit ugly...)
04:40:41 <Igloo> Still sounds like a bug to me, dons
04:40:46 <dons> ok
04:40:56 <dons> doesn't work in lambdas either, so its a bit more general
04:41:51 <lray80de> dons yepp, because haskell is working backchaining, so it doesn't actually calculate the thing, or have it already anywhere cached.
04:44:45 <lray80de> When starting ghci without "-ffi"-Parameter, I get a time-measure.
04:44:46 <lray80de> But because of other modules, the -ffi is needed for "foreign Import".
04:44:51 <lray80de> am out of ideas.
04:46:27 <dons> what happens if you import Debug.Trace, and do: time $ trace test2
04:46:41 <dons> (i.e. another way to force evaluation)
04:54:46 <lray80de> time $ trace (show test2) does give me a calculation time of 0.0 ... but once I got a time... after ":q" and restarting ghci, all the caches should be clean, isn't it?
04:55:26 <dons> right, but does it actually print the result?
04:56:36 <lray80de> aehm, right question... no, it doesn't...
04:57:04 <dons> hmm. that shouldn't even compile, come to think of it
04:57:12 <dons> :t Data.Debug.trace
04:57:13 <lambdabot> Couldn't find qualified module.
04:57:17 <dons> :t Data.Debug.Trace.trace
04:57:18 <lambdabot> Couldn't find qualified module.
04:57:22 <dons> ?hoogle trace
04:57:23 <lambdabot> Debug.Trace.trace :: String -> a -> a
04:57:23 <lambdabot> Debug.Trace :: module
04:57:23 <lambdabot> Debug.Trace.putTraceMsg :: String -> IO ()
04:57:40 <dons> so it would have to be: time $ trace (show test2)
04:57:54 <dons> or: time $ trace (show test2) `seq` ()
04:58:03 <dons> now, this makes me wonder if you're running the right code...
04:58:11 <dons> if it didn't complain about the wrong ype
04:58:19 <lray80de> *Main> show test2
04:58:20 <lray80de> "[1.0,0.6 ... and so on ... ]"
04:58:20 <lray80de> *Main>
04:58:21 <dons> type. double check you're working on the right file
04:58:53 <lray80de> it complained, when I was trying " trace test2", that It can't work with [Double] instead of [Char]
04:59:05 <dons> right. so you need trace (show test2)
04:59:11 <pierre-> hello
05:01:17 <lray80de> Xcerpt/Methods/qgramme.hs:50:16:
05:01:19 <lray80de>     Couldn't match expected type `IO t' against inferred type `a -> a'
05:01:19 <lray80de>     In the second argument of `($)', namely `trace (show test2)'
05:01:19 <lray80de>     In the expression: time $ (trace (show test2))
05:01:19 <lray80de>     In a 'do' expression: time $ (trace (show test2))
05:01:19 <lray80de> Failed, modules loaded: none.
05:02:08 <Lemmih> lray80de: time $ print test2?
05:02:10 <dons> ah yes
05:02:27 <dons> same problem. still, I'm really not sure why the foldl' seq wasn't working.
05:02:30 <dons> very suspicious
05:02:40 * dons gets some sleep
05:04:14 <lray80de> *Main> test
05:04:15 <lray80de> Loading package haskell98 ... linking ... done.
05:04:15 <lray80de> Starting...
05:04:15 <lray80de> Computation time:
05:04:15 <lray80de> 0.0
05:04:15 <lray80de> Done.
05:04:16 <lray80de> for trace and print with `seq` return ()
05:04:38 <lray80de> I'll paste the source again and give it a try on another machine...
05:05:52 <lisppaste2> lray80de annotated #31489 with "same old problem" at http://paste.lisp.org/display/31489#2
05:06:58 <joelr1> good afternoon
05:07:23 <joelr1> can someone please remind me if there's a way to have quickcheck run all the tests defined everywhere in the code?
05:08:18 <Cale> lray80de: try this: let loop = getCPUTime >>= print >> loop in loop
05:09:42 <Cale> joelr1: there's a program called quickCheck which does that for tests starting with prop_
05:09:44 <Cale> http://www.md.chalmers.se/~rjmh/QuickCheck/quickcheck
05:10:36 <lisppaste2> thoms80 annotated #31489 with "the CPUTime-Thing..." at http://paste.lisp.org/display/31489#3
05:10:51 <joelr1> Cale: thanks!
05:10:54 <lray80de> okay, thoms80 is me (sorry)
05:12:15 <lray80de> Cale pasted it as thoms80. maybe the CPUTime-Change is to coarse-grained?
05:22:40 <lray80de> raised the wordNumber up to 7000 and took a heavier algorithm. The Measurement doesn't use the algorithm. tried an concat [test2] as well, no result.
05:23:13 <lray80de> started test2 manually needs something like endless.
05:23:56 <russo> does anyone know a good php/mysql photo album thats easy to install on webspace... as is wordpress for example?
05:24:18 <russo> free preferably also
05:24:47 <Lemmih> russo: #Haskell is probably not the best place for such questions.
05:25:30 <russo> :P ok... good point but i know people here are knowldegable about things other than haskell also
05:25:31 <SamB_XP_> Lemmih: at least we know about such tools as patch(1) !
05:26:05 <russo> didn't mean to ruin the lambda vibe in here :)
05:29:27 <lray80de> gallery2
05:30:35 <lray80de> http://gallery.menalto.com/
05:30:37 <lambdabot> Title: Gallery | Your photos on your website
05:30:54 <lray80de> russo gallery2
05:33:18 <russo> :P yeah i just found that thanks lray80de :)
05:34:02 <roconnor> \join texmacs
05:34:05 <roconnor> oops
05:36:01 <SamB_XP_> two problems!
06:08:18 <lray80de> /leave
06:16:01 * SamB wishes gtk2hs docs linked to the associated gtk docs
06:27:31 <Pupeno> Wow, I've found myself needing Monads in Erlang, I wish I was using Haskell here.
06:35:23 * mux learns how to divide by zero and is a bit unconvinced
06:35:31 <mux> http://www.bbc.co.uk/berkshire/content/articles/2006/12/06/divide_zero_feature.shtml
06:35:34 <lambdabot> Title: BBC - Berkshire - Features - 1200-year-old problem 'easy', http://tinyurl.com/yl47tq
06:35:34 <kfish> Pupeno, that's the problem with haskell
06:35:56 <kfish> you program in any other language, it feels ... lacking
06:36:58 <integral> I hope ((5/0)^-1)^-1  == 5/0 and (5/0)^-1 == 0 :-)
06:39:04 <Pupeno> kfish: I just wish Haskell was as ready as Erlang to do distributed, fault tolerant, network programming.
06:39:17 <kfish> soon dude, soon
06:40:23 <Pupeno> kfish: :)
06:45:11 <ms_> meh, there's a type system checker for Erlang, and let's face it, that's all you'd be getting... ;-)
06:45:14 * ms_ ducks rapidly
06:51:28 <kzm> Pupeno, distributed STM will be the killer functionality in that regard :-)
06:53:37 <Pupeno> kzm: I'd also need Streams to become mainstream to have a nice way to deal with binary data and unicode strings.
06:54:13 <kfish> Pupeno, ByteStrings?
06:54:27 <kzm> Yes, that isn't unreasonable.
06:54:39 * kzm must run.
06:55:12 * kfish must sleep.
06:55:54 * Pupeno must code.
07:01:46 <glguy> Romeo must die!
07:03:15 <robreim> mux: that divide by zero link looks almost like he's turned divide into a function which returns a Maybe type :)
07:04:29 * robreim sleeps
07:04:47 <ropine> \me must have a faster database
07:05:04 * ropine has slash dyslexia
07:06:09 <therp> ropine :))
07:25:50 <araujo> morning
07:31:35 <grac> hi! What IDEs are available(mature enough) for developing in Haskell?  Emacs, Eclipse,...?
07:32:26 <Baughn> Mostly emacs/vim
07:32:47 <emu> grac: i use emacs w/haskell-mode.  some people prefer vim and just having ghci open.
07:33:48 <Baughn> I find the indentation of haskell-mode, while functional, somewhat annoying. Sadly, the elisp is quite thoroughly obfuscated. -_-
07:34:01 <emu> does a "DiffUArray Int Bool" make sense for a bit-sequence, or should I just go for "IArray Int Bool" and let the compiler deal with it?
07:34:08 <grac> thanks!
07:34:14 <emu> Baughn: well, it is doing a heuristic
07:34:32 <emu> Baughn: it's more than any other editor that I know of; none of which even try to understand layout
07:34:51 <Baughn> emu: I know, and it /is/ much better than anything else. I'm pondering something more slime-like, though.
07:35:08 <emu> Baughn: oh i agree. but for indentation? hmm
07:35:13 <Baughn> As for the heuristics..
07:35:17 <emu> maybe some kind of dynamic parsing and querying
07:35:46 <Baughn> It should be possible to use Haskell's parser in enumeration mode (which someone would have to implement) to generate all the /valid/ ways to indent
07:35:47 <emu> i've added changes to my version which allow me to query type/info/loc with keystrokes, and caches the type in haskell-doc
07:36:06 <emu> Baughn: i explored ghc-api a bit to see if i could make it perform some tricks like this
07:36:28 <Baughn> emu: I haven't found anything like it, but it /would/ make a lot more sense to use the same code for parsing and indentation
07:36:42 <emu> the problem is, you need a special kind of parser which can handle malformed code gracefully
07:37:12 <Baughn> Yes. That sort of special parser would also benefit ghc, however.
07:38:00 <Baughn> The main problem, I think, is that it would be a lot of work. :P
07:38:07 <emu> hehe indeed
07:38:15 <emu> parsing haskell doesn't look like fun oO
07:38:21 <emu> or maybe it is fun... too much fun
07:38:38 <emu> you could stick to Liskell!
07:38:47 <Baughn> I might just write a sexp-to-haskell thing and retrofit slime itself to handle it
07:39:00 <Baughn> ...or I could use "Liskell", whatever that is. *google*
07:39:25 <Baughn> therp?
07:39:50 <cjeris> at least haskell-mode's indenter gives you some choices... sml-mode's indenter is simply wrong much of the time. :p
07:39:55 <emu> http://clemens.endorphin.org/LskVsLisp.html
07:39:57 <lambdabot> Title: Liskell versus Lisp
07:39:58 <therp> baughn: yes?
07:40:26 <therp> ah yes. I'm just right at the moment coding defmacro for Liskell
07:40:27 <Baughn> therp: Have you released Liskell yet? :}
07:40:33 <therp> no, but the paper is almost finished
07:40:46 <Baughn> No incremental, alpha-ish source tree online?
07:41:12 <therp> it has a lot of nifty things like backquoting implemented as "macro" (actually the more general concept I employ aka parse tree transformers)
07:41:23 <therp> baughn: no not yet, this is really too experimental
07:41:47 <therp> but it is coming along nicely. so in a weak is the deadline for ILC07.. except to see something after that.
07:42:10 <Baughn> therp: Oh, goodie. I still have to learn Haskell properly before I try something like this anyway..
07:42:41 <therp> baughn: that's right, 100% Haskell semantics except for meta-programming. (I guess this will freak out, both camps.. lisp and haskell)
07:42:48 <Baughn> I think.. I'm quite likely to have at Slime with a hacksaw in the future. I'm already familiar with the codebase.
07:42:59 * Baughn is distinctly not freaked out.
07:43:24 <therp> baughn: but you might prove read my paper if you volunteer :)
07:43:51 <Baughn> therp: After the exam tomorrow, maybe.
07:44:25 <emu> i think you really need hs-plugins to make slime-for-haskell really shine
07:44:42 <Baughn> That's where "learning haskell first" comes in. Does it work with 6.6 yet?
07:44:48 <emu> i don't think so
07:45:48 <Baughn> Well, I could always use an older version of ghc
07:46:52 <emu> yea... unfortunately i'm too busy atm to mess around with it
07:47:01 <emu> maybe next semester
07:47:11 <Baughn> Is it likely to take a lot of work to fix it?
07:48:28 <glguy> Is the Oleg(114) from LtU the Oleg that people talk about in #haskell?
07:49:11 <emu> Baughn: for 6.6? dons is working on it, i'm sure he'll get it done when he has time
07:49:34 <Baughn> Okay
07:49:55 <lisppaste2> retybok pasted "What's wrong?" at http://paste.lisp.org/display/31509
07:51:56 <mauke> x * y has the type Int, not (Num b) => b
07:52:22 <retybok> mauke: sure but i'd like the definition of the class to be as general as possible
07:52:34 <retybok> Int is an instance of Num, isn't it?
07:53:04 <mauke> yes
07:53:31 <retybok> So in the case of ints, I want dotproduct to return an Int, in other cases, other types
07:54:07 <retybok> actually, what I'd really like to write is "instance (Num a) => Vector a where ...
07:54:14 <retybok> but i can't get that to work either
07:55:03 <ski> instance Num a => Num (Vector a)
07:55:04 <ski> ?
07:55:17 <retybok> no
07:55:32 <retybok> I mean, every instance of Num is also an instance of vector
07:56:04 <retybok> but maybe i'm doing everything wrong
07:56:29 <retybok> I just want to be able to define dotproduct over scalars and lists
08:00:30 <Lemmih> dotproduct x y = fromIntegral $ x * y ?
08:02:07 <retybok> Lemmih: yes, that works, thanks
08:02:33 <retybok> Lemmih: how could I define dotproduct to be a regular multiplication for all scalars (Nums)
08:02:45 <Baughn> retybok: Take this with a grain of salt, but I /think/ the problem is that your Vector class types dotproduct to be defined for every return value in Num. Haskell is polymorphic on return types, so.. according to the class, it must be legal to use dotproduct x y anywhere you want a Num, which it isn't with your original version
08:03:06 <Baughn> @type fromIntegral
08:03:08 <lambdabot> forall b a. (Num b, Integral a) => a -> b
08:03:38 <retybok> Baughn: right, I understand better now
08:03:41 <Baughn> And fromIntegral, then, converts the Int to whatever type it wants to be
08:03:51 <Baughn> mauke: Did I get that right?
08:04:04 <mauke> I think so
08:05:21 <Baughn> It's yet another unusual feature. Is the type system turing-complete?
08:05:45 <mauke> AFAIK no
08:06:07 <mauke> you usually want the type checker to terminate for all inputs :-)
08:06:09 <dons> Baughn: yes, http://article.gmane.org/gmane.comp.lang.haskell.general/14088
08:06:11 <lambdabot> Title: Gmane -- Mail To News And Back Again
08:06:26 <mauke> o shi
08:06:31 <integral> mauke: Actually I got an infinite loop the other day with GHC's type system.
08:06:39 <Baughn> Eep
08:06:51 <integral> But you have to be Trying to get it to happen :-)
08:07:01 <mauke> ok, that's with extensions
08:07:07 <dons> yep
08:07:10 <fasta> Who registered comp.lang.haskell?
08:07:20 <integral> hmm, I wonder which one. iirc it wasn't overlapping instances
08:07:39 <dons> FDs are needed, along with undecidable instances
08:07:49 <integral> ah.
08:07:51 <dons> (but its all in the FDs, I think -- that's prolog in the type system right there)
08:07:59 <integral> yeah
08:08:22 * integral was writing a silly wee primality tester for type level numbers and got into a tangle.
08:09:09 <Baughn> Infinite loops and turing-completeness. Any moment now someone will write a gÃ¶delian program
08:09:51 <retybok> mmm, that doesn't help me a lot with my problem :)
08:09:56 <integral> too often I find myself adding silly axioms like (a->b)->a :-(
08:10:18 <retybok> so, how would you define the scalar product as a general multiplication for either vectors or scalars?
08:10:59 <integral> hmm, surely every vector space can't be extended to an inner product space
08:11:14 <retybok> integral: finite dimension :)
08:11:19 <retybok> just trying to learn here
08:11:22 <integral> oh, that's boring :-)
08:11:45 <retybok> lol
08:11:52 <cjeris> integral: sure you can, if you don't insist on positive definiteness...
08:12:08 <integral> hmm
08:14:02 <Baughn> http://www.lochan.org/keith/publications/undec.html has a turing-machine implementation that I think doesn't use extensions
08:14:04 <lambdabot> Title: Instance Declarations are Universal
08:14:32 <mauke>  A Turing machine configuration is represented by an instance of a multiple-parameter type class TM
08:14:54 <mauke> multi-param type classes aren't haskell98 AFAIK
08:15:01 <Baughn> Aww..
08:15:04 <cjeris> integral: of course not every TVS has an inner product because not every TVS is metrizable.  i don't know offhand whether there exists any metrizable topology on a vector space of any given basis cardinality.
08:15:10 <cjeris> over R or C.
08:15:24 <integral> "T"VS?
08:15:29 <cjeris> topological vector space.
08:15:34 <integral> ah
08:16:46 <cjeris> where in "not every TVS has an inner product" i mean "not every TVS has a positive definite inner product" -- contradictory sloppiness in two separate lines :p
08:17:23 <integral> :-D
08:17:32 <integral> I need to just give in a learn Coq I think
08:18:37 <cjeris> sigh.  i love it when cygwin emacs freezes dead as i'm trying to test my compiler.
08:18:58 <cjeris> cygwin x server is lame lame lame.
08:19:52 <retybok> that's why most of us just use linux :)
08:21:18 <integral> (or macs, but its X server also has fun problems)
08:22:03 <cjeris> believe me, i'd be using linux if i could get it on this machine, but it's not supported :p
08:24:50 <emu> @type array
08:24:51 <lambdabot> forall e i. (Ix i) => (i, i) -> [(i, e)] -> Array i e
08:31:32 <emu> does anyone know how ghc implements "UArray Int Bool"?
08:31:50 <sjanssen> one bit per bool
08:32:42 <emu> cool
08:32:56 <emu> so it should be fairly quick, even with the immutable interface?
08:33:19 <emu> do you know whether it handles 2d such arrays? UArray (Int,Int) Bool
08:34:00 <sjanssen> it's always one bit per Bool, regardless of the index type
08:34:21 <emu> ok =)
08:34:29 <sjanssen> converting from the index to the real index of the bool can be expensive, though
08:36:04 <sjanssen> its tough to write an efficient bitwise negate with the UArray interface, for example
08:36:04 <emu> hmm, it's a rectangle though
08:36:24 <emu> i*width+j or something
08:36:56 <sjanssen> the array libraries use Ix to turn flatten the indices into 0 based Int ranges
08:36:56 <emu> well ok; i'm using this to set flags on an adjacency matrix
08:37:55 <emu> so i'm mostly going to be updating 1 bit at a time, or checking it
08:39:28 <fasta> emu: For a graph structure?
08:39:41 <emu> yes
08:40:02 <fasta> emu: simple graph?
08:40:34 <emu> it's fairly simple.  not sparse, directed edges
08:40:51 <emu> i implemented the algorithm with fgl but it's too slow
08:41:36 <emu> i'm going to try with an adjacency matrix style rep and compare
08:41:56 <fasta> emu: I meant the structure called "simple graph" in graph theory.
08:42:58 <emu> ok, it has no graph loops, or multiple edges, it is directed,
08:43:08 <emu> and weighte
08:43:24 <fasta> emu: ok
08:43:37 <sjanssen> emu: with each update operation UArray i Bool memcpy's the underlying byte array, and then does an inplace update on the copied array
08:44:20 <emu> sjanssen: unfortunately, there was no DiffUArray a Bool :/
08:44:36 <sjanssen> alas
08:44:45 <fasta> That doesn't sound like a good structure for a graph then.
08:44:52 <sjanssen> there is STUArray, too
08:44:57 <emu> i suppose i could toss ST into my monad
08:45:25 <emu> mm, type annotation hell
08:47:14 <emu> i'm storing the arrays in a StateT constructed state type
08:47:49 <emu> fasta: do you mean "not a good structure" because of UArrays, or i'm just being screwy?
08:50:05 <fasta> emu: If UArrays copy then they are not suited to hold arrays for imperative graph algorithms.
08:51:24 <emu> yea im fiddling with ST now
08:56:04 <lisppaste2> emu pasted "trouble with ST" at http://paste.lisp.org/display/31517
08:59:14 <glguy> runST :: (forall b. ST b a) -> a
09:00:55 <glguy> I usually fix the rigid variable type errors by removing explicit type signatures
09:01:16 <emu> hmm
09:01:35 <emu> so the forall b. from runST isn't being matched to the s in Propagator
09:04:51 <glguy> :k StateT
09:04:53 <lambdabot> * -> (* -> *) -> * -> *
09:05:34 <glguy> :k ST
09:05:35 <lambdabot> Not in scope: type constructor or class `ST'
09:05:44 <glguy> :k Control.Monad.ST.ST
09:05:45 <emu> this is what it thinks stp is inferred to be:   stp :: ErrorT e (StateT s1 (ST s)) a
09:05:46 <lambdabot> * -> * -> *
09:06:58 <ventonegro> as Gtk2hs is LGPL, is there a way to use it dynamically?
09:07:42 <emu> ST always drives me nuts :/
09:07:48 <glguy> emu, maybe you need evalStateT
09:08:40 <emu> @type evalStateT
09:08:42 <lambdabot> forall a (m :: * -> *) s. (Monad m) => StateT s m a -> s -> m a
09:08:45 <emu> @type runST
09:08:47 <lambdabot> Not in scope: `runST'
09:08:56 <glguy> :t Control.Monad.ST.runST
09:08:57 <lambdabot> forall a. (forall s. GHC.ST.ST s a) -> a
09:09:58 <emu> @type runStateT
09:10:00 <lambdabot> forall s a (m :: * -> *). StateT s m a -> s -> m (a, s)
09:15:58 <emu> found this on google: http://paste.lisp.org/display/25854
09:16:56 <emu> pastes from you, glguy =)
09:18:57 <glguy> emu: I did one with ST also
09:19:02 <glguy> emu: I was just looking for it
09:19:21 <glguy> OH, it's below that one
09:19:21 <emu> there's one in the annotations
09:19:31 <emu> though it's using STRef's somehow
09:19:41 <glguy> yeah, I remember writing that :)
09:20:59 <glguy> simTurn's type is pretty "intense" ;)
09:21:35 <glguy> in sim, a :: StateT Int (StateT s (ST s)) ()
09:22:14 <emu> hehe
09:22:26 <emu> whoa
09:22:27 <glguy> but simTurn is too logn to type
09:24:38 <emu> well i gotta bbl, gonna take another crack at ST
09:28:45 <glguy> emu: I was using STRefs because I didnt' know what I was doing :)
09:29:37 <SyntaxNinja> y0
09:40:20 <paolino> http://rafb.net/paste/results/AHbtXO93.nln.html
09:40:21 <paolino> can someone help me with syntax error on this file?
09:40:52 <sjanssen> paolino: please paste the error message
09:41:10 <paolino> cell.hs:66:27: The last statement in a 'do' construct must be an expression
09:41:11 <paolino> Exit 1
09:41:58 <sjanssen> and which line is 66?
09:41:58 <mauke> well, what do you not understand about that message?
09:43:13 <paolino> ehm http://rafb.net/paste/results/AHbtXO93.html  has numbers
09:43:42 <paolino> muake mostly nothing, the message is clear, but I disagree :/
09:43:58 <mauke> what do you mean, "you disagree"?
09:44:22 <mauke> the last statement in a 'do' construct must be an expression, that's how the language works
09:44:44 <paolino> well I think I have a statement there
09:44:54 <paolino> maybe I'm wrong
09:45:00 <kpreid> "a <- b" is not an *expression*
09:45:04 <int-e> paolino: I think you want   sons <- case base of ...
09:45:19 <paolino> ah
09:47:31 <ptolomy> Monads : Purely functional languages :: Evolution : Secularism
09:48:02 <paolino> mmhh my code is crap then, I can't use "case" as an action flow control operator ?
09:49:17 <mauke> sure you can, you just can't have half a function
09:49:36 <Excedrin> your (Just value) case needs to return something
09:49:59 <mauke> note that <- is not an assignment operator
09:52:46 <glguy> ?tell emu I cleaned up the ST version of my monopoly code if you need a better example: http://paste.lisp.org/display/25854#3
09:52:47 <lambdabot> Consider it noted.
09:55:09 <glguy> The old version was the first thing that I had ever used ST for, so it was quite a mix
09:56:04 <paolino> ok , now I have same error on line 45 , before the 'let'
09:57:47 <paolino> the function is not finished there
09:58:07 <paolino> it's not the last statement
09:59:08 <paolino>       put value' case base of
09:59:09 <paolino>                       (Just value) -> value
09:59:09 <paolino>                       otherwise -> zero
09:59:20 <paolino> are these correct ?
10:00:36 <glguy> you want: case base of
10:00:43 <glguy>  Just val -> val
10:00:47 <glguy>  _ -> zero
10:01:21 <paolino> uh I invented otherwise sorry
10:01:28 <mauke> no, that also works
10:01:57 <lispy> > otherwise
10:01:59 <lambdabot>  True
10:02:10 <lispy> :t otherwise
10:02:12 <lambdabot> Bool
10:02:12 <glguy> > fromMaybe zero
10:02:13 <lambdabot>  Not in scope: `zero'
10:02:25 <glguy> > fromMaybe 0 Nothing
10:02:27 <lambdabot>  0
10:02:30 <glguy> > fromMaybe 0 (Just 2)
10:02:31 <lambdabot>  2
10:02:51 <lispy> oh, cool is fromMaybe new?
10:03:04 * paolino should use haskell more than once a year
10:03:05 <lispy> i don't ever remember bumping into it
10:03:29 <paolino> anyway the problem on line 45 doesn't vanish
10:03:57 <glguy> fromMaybe has been around in data.Maybe since I started using Haskell, at least
10:04:52 * eviltwin_b would like to use haskell more, but (a) does little coding at work (b) what he does has to be comprehensible by $boss, $grandboss, and $coworkers
10:05:18 <Botje> eviltwin_b: so whenever you crack a tough problem using $WORK_LANGUAGE
10:05:39 <Botje> add a comment with "this can be solved in haskell in $SMALLNUM lines)
10:06:03 <ropine> better yet, try *solving* the problem in haskell
10:06:53 <eviltwin_b> Botje: doesn't matter, "can be solved better xxx" is not acceptable if only one person in the dept. conprehends that solution
10:07:02 <dylan> hmm, how to handle SIGWINCH in haskell
10:07:16 <eviltwin_b> (and, frankly, that's the correct attitude)
10:07:20 <Botje> eviltwin_b: most haskell is very readable, even to non-haskellians.
10:07:22 <glguy> time to hire smarter people to compliment eviltwin_b in his department ;)
10:07:25 <ropine> and if the haskell version is in fact smaller, faster, or otherwise more desirable, you have a case for telling $boss, "hey, this deserves closer study"
10:07:58 * eviltwin_b shouldd have kept his mouth shut
10:08:00 <glguy> I'm going to start calling my boss, "$boss"
10:08:02 <glguy> lol
10:08:12 <eviltwin_b> geeks, per usual, Don't Get The Real World
10:09:09 <glguy> eviltwin_b: statements like that just demonstrate that you are unable to joke along with everyone
10:09:51 <glguy> many of us (assuming others feel like I do) are all to tired of this "real world" (-;
10:10:00 <ropine> my own $boss was willing to let me spend a few days trying to get a certain hairy part of our codebase reimplemented in haskell; unfortunately I made a bad choice of what data structure to use and the performance was truly embarrassing
10:10:04 <glguy> but that doesnt' mean we don't get plenty of exposure
10:10:38 <glguy> unless you were talking about your favorite MTV show... then you are probably right
10:10:52 <glguy> I don't get that show :)
10:10:59 <savanni> ropine: what can we acolytes do to learn how to avoid that kind of mistake?
10:11:10 * therp waits for Real World 2.0  
10:11:16 <glguy> beta?
10:11:30 <ropine> since I am an acolyte myself, I'm not sure what general strategy to advise
10:11:37 <therp> final please, I don't like things coming crashing down the sky :)
10:14:22 <ropine> what I'm doing now is trying to come up with a better solution in my free time; if I can make something that works well, then I hope I can convince $boss to let me spend some small proportion of my work hours experimenting with Haskell for other things
10:14:36 <savanni> k.
10:15:00 <savanni> I am still too busy trying to learn to work in the language, and not yet really paying attention to performance in The Real World (TM)
10:15:08 <paolino> :t fromMaybe
10:15:10 <lambdabot> forall a. a -> Maybe a -> a
10:15:27 <glguy> fromMaybe default = maybe default id
10:15:44 <mauke> :t flip maybe id
10:15:46 <lambdabot> forall a. a -> Maybe a -> a
10:17:31 <savanni> My bosses will never accept the language, but that is not relevant to projects that I do when I am not at work.
10:20:29 <Baughn> > fromMaybe (Maybe 2)
10:20:30 <lambdabot>  Not in scope: data constructor `Maybe'
10:20:38 <Baughn> > fromMaybe Nothing
10:20:39 <lambdabot>  Add a type signature
10:20:48 <Baughn> > (fromMaybe Nothing) :: Int
10:20:49 <lambdabot>    Expecting a function type, but found `Int'
10:20:49 <lambdabot>    Expected type: Int
10:20:49 <lambdabot>   ...
10:21:02 <mauke> > fromMaybe undefined (Just 2)
10:21:04 <lambdabot>  2
10:21:04 <Baughn> ..h, right.
10:21:12 <Baughn> *wince*
10:26:07 <shapr> \yow
10:26:17 <shapr> hmm
10:26:50 <shapr> Good morning #haskell!
10:27:28 <integral> hello
10:27:51 <shapr> How's life in the big city?
10:28:00 <shapr> Life meaning code, of course..
10:28:11 <jlouis> yow shapr
10:28:35 <shapr> yow jlouis!
10:29:29 <jlouis> STM is too cool to hack
10:29:49 <jlouis> concurrency is suddenly a fun thing
10:29:52 * shapr agrees
10:36:04 <liyang> Aren't you worrying about this data invariants thing? I am. :(
10:36:29 <jlouis> data invariants thing?
10:36:31 <jlouis> do tell
10:38:26 <shapr> I think data invariants will allow design by contract in the true Eiffel style.
10:38:37 <grac> hi! what book to buy if I want to get a feeling for pure functional programming using Haskell?  I see many books being mentioned on haskellwiki, but I'm looking for recommendation on which one to buy first.  I have previous programming experience in C/Java, and the last year or so I've been studying Common Lisp.
10:38:41 <liyang> they recently added this always :: STM Bool -> STM () , which let you assert invariants and choose not to commit if they're not satisfied.
10:38:58 <shapr> I've already wished I had that when I was trying to debug the choking algorithm in conjure.
10:39:20 <shapr> The datastructures would break their invariants and I couldn't figure out why after hours of debugging.
10:39:29 <liyang> grac: there's a new textbook out called `Programming in Haskell'. :)
10:39:38 <shapr> So I gave up and used rtorrent written in C++
10:40:41 <jlouis> shapr, choking algorithm? I can't remember us having such a thing. Is there some repository I don't know of?
10:41:12 <shapr> I dunno, I've been using Lemmih's repo.
10:41:20 <shapr> It downloads quickly at least.
10:41:37 <shapr> Or it uploads quickly. but I couldn't get it to do both.
10:42:07 <liyang> shapr: it's the adding it into the STM implementation that I'm worrying about... There's no explanation of how it works in terms of existing functionality. (like, you could wrap a WriterT around the STM monad and just let that keep track of the invariants, say.)
10:42:46 <jlouis> http://darcs.haskell.org/~lemmih/conjure/ ?
10:42:48 <lambdabot> Title: Index of /~lemmih/conjure
10:43:04 <shapr> jlouis: That sounds right.
10:43:39 <jlouis> I better look ;)
10:43:40 <shapr> liyang: btw, thanks for driving me to London
10:43:48 <liyang> shapr: I still have your photo. :)
10:43:51 <grac> liyang: Thanks, I'll check it out.
10:43:53 <shapr> oh?
10:43:55 * Lemmih thinks about hacking conjure at the hackathon.
10:44:13 <liyang> shapr: eventually... it's sitting in Aperture now, at least. :)
10:44:19 <shapr> Aperture?
10:44:38 <liyang> http://www.apple.com/aperture/
10:44:39 <lambdabot> Title: Apple - Aperture
10:45:19 <liyang> (I bought a Canon EOS 400D over months ago. :)
10:45:50 <jlouis> shapr, oh, there are many cool things inside that
10:45:58 <jlouis> Lemmih, still working on conjure?
10:46:01 <kyevan> aw, "let 1 = 2" doesn't work in haskell?
10:46:06 <Lemmih> jlouis: Not really.
10:46:20 <shapr> liyang: ah I see
10:46:32 <liyang> grac: I grew up on `The Haskell School of Expression' and the Bird and Wadler book. You should be able to find the latter in a decent library...
10:46:43 <jlouis> Lemmih, I have some ideas. Mainly playing around with plugging happs into the core
10:46:54 <jlouis> and giving it a web-frontend
10:47:11 <shapr> liyang: So when do I get to see it?
10:47:13 <jlouis> no code of (showable) quality yet though
10:47:37 <liyang> shapr: heh, I''l l upload it when I get home
10:47:40 <Lemmih> jlouis: I want to design it as a library and not deal with UIs at all.
10:48:17 <beschmi> Lemmih: i'm working on some P2P stuff and planning to use conjure. i started extracting the TCP-stack from House for Nat-traversal (TCP-over-UDP).
10:48:25 <jlouis> Lemmih, yeah, there will be a nice split anyway between the UI parts and backend parts
10:49:45 <Lemmih> beschmi: Conjure is currently like a bike with no wheels. It needs a fair bit of work before it's usable.
10:49:52 <shapr> liyang: thanks!
10:50:47 <beschmi> Lemmih, i noticed that. but at least the code that's there looks nice, eg bencode
10:50:57 <grac> liyang: I've checked the reviews at Amazon, and there doesn't seem to be a consensus on what a definite classic in this area is.  I was hoping to find the equivalent of SICP.
10:51:25 <shapr> bok grac
10:51:28 <shapr> Are you in Zagreb?
10:51:37 <grac> shapr: bok!  indeed I am.
10:51:55 <shapr> Spiffy, I'm going to visit there sometime in the next year.
10:52:02 <liyang> grac: I regard the Bird and Wadler as the classic FP book, but maybe not for Haskell...
10:52:19 <shapr> Are there many FP users in Zagreb?
10:52:51 <shapr> I'm also going to Stockholm in April, any Stockholmare here want to meet up?
10:52:56 <grac> shapr: cool about your visit!  no, I don't think there are many FP users in Zagreb, unfortunately.
10:53:08 <shapr> gour_: Hey, are you in Zagreb also?
10:53:42 <shapr> grac: Do you think there are enough programming language theory people in Zagreb to get together a weekend hangout & hack meeting?
10:54:36 <grac> shapr: to be honest, I don't know.  I'd say, no. But I would like to be surprised on this.
10:55:09 <grac> shapr: are you coming here for a conference or just visiting?
10:55:31 <shapr> I'm just visiting, but I don't mind disorganizing a 'conference' as well.
10:55:31 <therp> how would I append a single element at the end of a list, except with lst ++ [elem]?
10:55:40 <shapr> Hrvatskell?
10:55:48 * shapr grins
10:56:06 <grac> shapr: oh, I see you speak Croatian. :-)
10:56:11 <shapr> Nah, not really.
10:56:19 <therp> grac: do you know "Mama", some sort of hacker location in zagreb?
10:56:29 <Lemmih> therp: reverse (x:reverse lst)? (:
10:56:30 <shapr> I just learned a little bit from some Croatian friends of mine.
10:56:50 <shapr> One of my friends just moved to Zagreb from Birmingham, AL.
10:56:53 <therp> lemmih: hm :) maybe another one? hoogling for append fails
10:57:13 * therp planned to go to Zagreb in next 2-3 months
10:57:18 <Lemmih> therp: lst ++ [elem] is the right way.
10:57:19 <grac> thebug: nope, I think I've heard of Mama, but I didn't know it was where hackers hang about.
10:57:44 <grac> how come you people know so much about Zagreb? :-)
10:57:54 <grac> more than I do, obviously.
10:58:19 <shapr> The people on #haskell are knowledgable about many surprising subjects.
10:58:45 <shapr> For example, I have secondary specializations in unicycling and nuclear power safety.
10:58:56 <grac> shapr: where does your friend work?
10:59:07 <grac> in which company, I mena.
10:59:09 <grac> mean
10:59:27 <shapr> My friend runs her own graphic design business and she does work for people in .hr .us and other places.
10:59:42 <araujo> @yarr!
10:59:43 <lambdabot> What be a priate's favourite cheese?
10:59:43 <lambdabot> Yarrlsburg!
11:00:06 <shapr> grac: What do you do? Are you learning FP for business or pleasure?
11:00:24 <shapr> grac: Hi, I'm Shae Erisson, I'm a professional Haskell contract programmer, yay!
11:00:27 * shapr boings
11:00:29 <araujo> how do you guys go?
11:00:30 <liyang> Isn't it always a pleasure?
11:00:35 * araujo flips back and forth
11:00:43 <shapr> Â¡hola araujo!
11:00:47 <therp> grac: http://www.mi2.hr/
11:00:52 <araujo> hi shapr!!!
11:00:54 <araujo> :-)
11:00:55 <lambdabot> Title: mama.mi2.hr
11:01:00 <shapr> Â¿como est as?
11:01:06 * araujo is finally on vacations!!!
11:01:14 <araujo> shapr, estoy muy bien, y tu? ;-)
11:01:32 <shapr> grac: Anyway, #haskell is a great place to hang out if you have any interest in programming language theory, math, proofs, or other rigorous subjects.
11:01:34 * araujo piensa que shapr debiera de pasarse por #haskell.es :-}
11:01:45 <shapr> muy bien, gracias
11:02:13 <shapr> And just like most languages, I don't really speak more than the few words I absorbed while listening to others speak Spanish.
11:02:23 * shapr is just a good sponge.
11:02:41 <araujo> shapr, you only need a few words to survive :-)
11:02:41 <grac> shapr: My interest for FP is mostly pleasure, but since I work at University, it will eventually have effect on my Ph.D. thesis.
11:02:54 <shapr> grac: Oh cool, what's your PhD subject?
11:03:16 <shapr> araujo: yeah, now if only I knew how to say "one beer, please" in Spanish.
11:03:26 <ropine> shapr, araujo: you know Feynman's story about how he impressed Brazilians with his knowledge of Portuguese?
11:03:27 <araujo> grac, you can even talk about unicycles here!
11:03:32 <grac> therp: thanks for the link.  I didn't know about it.  I have to check it out to see what's it about.
11:03:41 <araujo> shapr, Una cerveza por favor
11:03:45 <araujo> :-)
11:03:46 <shapr> ropine: no?
11:03:50 <shapr> araujo: gracias!
11:04:00 <araujo> ropine, nop
11:04:05 <araujo> what is it about?
11:04:07 <ropine> the punch line was when one of the natives remarked: "he knows such *big* words--like CONSEQUENTEMENTE!"
11:04:19 <therp> grac: there is at least one pretty good haskell hacker at Mama :)
11:04:30 <shapr> grac: Do you also read http://lambda-the-ultimate.org/ and http://programming.reddit.com/ and http://del.icio.us/tag/haskell and http://planet.haskell.org/ ?
11:04:31 <lambdabot> Title: Lambda the Ultimate | Programming Languages Weblog
11:04:45 * shapr grins
11:04:55 <grac> shapr: I'm reading most of those, thanks.
11:05:15 <grac> therp: which one would that be?
11:05:17 <shapr> grac: Ok, do you have any specific questions?
11:05:37 <araujo> grac, the best thing, is that the haskell community is always willing to help.
11:05:51 <therp> grac: his name is "Alan", sorry no surname. met him in hamburg and vienna
11:06:00 <grac> shapr: nope, I'm just looking for a book to read as an introduction to pure FP and Haskell.
11:06:08 <grac> therp: Alan Pavicic?
11:06:13 <shapr> Have you tried Yet Another Haskell Tutorial?
11:06:17 <araujo> grac, Introduction to Functional Programming , Bird.
11:06:46 <grac> araujo: thanks, that's second recommendation for that book.
11:06:56 <therp> grac: maybe :) that's his blog http://svrg.net/metafeed
11:07:16 <araujo> grac, it is a classic ; sort of like the C programming language but for Haskell.
11:07:50 <therp> grac: most certainly alan pavicic. I know he does scheme, and google lists scheme hits for this name
11:08:15 <grac> araujo: cool, then that's what I've been looking for.
11:08:32 <araujo> yeah, nice book.
11:08:50 <grac> therp: I actually don't know him personally, but I've heard of him from a friend, Hrvoje Niksic, maybe you know of him.
11:09:27 <shapr> You know Hrvoje?
11:09:34 <shapr> I use lots of his code in my .xemacs!
11:09:35 <therp> grac: might be, about 1 1/2 month ago, an austria geek location invited a couple of folks over from zagreb for some sort of knowledge exchange. maybe he was with alan
11:09:51 <shapr> heippa hei rahikkala
11:10:06 <rahikkala> shapr: .
11:10:07 <grac> shapr: yes
11:10:11 <shapr> ,
11:10:17 <Saizan> is creating a monad the way to go if i want to create a little DSL ad part of the API for a library i'm writing?
11:10:17 <shapr> rahikkala: Really big semicolons?
11:10:34 <shapr> Saizan: Monads do make for easily composable interpreters.
11:10:41 <shapr> Have you seen Hudak's papers on that subject?
11:10:49 <Saizan> mmh no
11:10:49 <rahikkala> shapr: Nah... just a habit picked up from another network: To greet someone, you say . to them
11:10:57 <shapr> rahikkala: Oh, I see. Would that be IRCNet?
11:11:23 <rahikkala> shapr: Civirc, actually... I don't think you've heard of it, it's a bit of a small one
11:11:25 <Saizan> i'll search, thanks
11:11:31 <grac> therp: don't think so.  I think they met a couple of months ago.  Hrvoje came to a company when Alan was about to leave.
11:11:31 <shapr> See, I learned that I should say hyvÃ¤Ã¤ huomenta!
11:11:56 <therp> grac: what a small world
11:12:10 <grac> therp: indeed!  and fun world! :-)
11:12:11 <shapr> grac: Next time you see Hrvoje you can tell him "Thanks for lots of xemacs work, shapr appreciates it!"
11:12:38 <xerox> Hiya shapr
11:12:48 <shapr> The open source world is surprisingly well connected. Same for the academic world.
11:12:52 <shapr> hiya xerox! how's code?
11:13:00 <grac> shapr: will do.  Unfortunatelly, he doesn't work on XEmacs anymore.
11:13:00 <xerox> shapr: -> -oo
11:13:11 <therp> grac: actually I planned to visit Alan with a friend of him who lives in vienna too. zagreb is only 6hrs away so not a big deal with a car :)
11:13:17 <shapr> grac: That's okay, the code he wrote still does good things for me.
11:13:28 <therp> shapr: do you use xft in xemacs?
11:13:41 <grac> guys, gotta go, be back in 5 minutes.
11:13:46 <shapr> I don't think so. Is there some simple way to do that?
11:13:53 * shapr asks google
11:14:30 <shapr> Aha, I'm using 21.4, and 21.5 is the first version that has Xft
11:14:32 <xerox> shapr: many lectures, people and conferences = no code :)  it's so much fun, anyway....
11:14:40 <therp> shapr: simple? no, but that's what my weblog post is for http://clemens.endorphin.org/weblog/archives/2006-02.shtml#e2006-02-17T08_56_05.txt :)
11:14:42 <lambdabot> Title: clemens.endorphin.org/weblog - February 2006 Archives - clemens.endorphin.org, http://tinyurl.com/hy9nr
11:14:53 <Modius> Dobar Dan!  Ne Razumem Srpski - Daimi Rec'nik
11:15:21 <xerox> too many shapr-requests-per-second, he'll snarl-up.
11:15:24 <Modius> Oops - Hrvatski
11:15:33 <shapr> xerox: which conferences?
11:15:39 * shapr reads therp's post
11:15:53 <shapr> xerox: It takes more requests than that :-)
11:16:03 <shapr> gour__: Are you in Zagreb? I know I've asked you that before...
11:16:31 <gour__> shapr: hi
11:16:37 <lisppaste2> pitecus pasted "Slow program" at http://paste.lisp.org/display/31529
11:16:37 <xerox> shapr: that's the funniest part.  every tuesday (like today) they have technical-but-followable conferences on mathematics in out lecture room!  last time and today it was about infinity.  great stuff.
11:16:46 <gour__> shapr: i just arrived back home
11:17:00 <shapr> xerox: wow, sounds like fun.
11:17:27 <pitecus> The stuff i pasted seems really slow. Any idea whether it can be made faster without too much fuss?
11:17:32 <xerox> yeah, it's awesome.
11:17:37 <shapr> gour: How's work?
11:17:45 <gour> shapr: you've found some hackers from croatia?
11:17:55 <shapr> therp: Do you know if/when xemacs 21.5 will be in debian/unstable?
11:18:17 <therp> shapr: no sorry. gentoo user
11:18:18 <shapr> gour: Yup, just wondering when to schedule Hrvatskell
11:18:21 <gour> shapr: work is ok - i just had counseling session with the client, but not much time for haskell :-(
11:18:42 <therp> shapr: but you gotta compile it by hand anyway when you want xft
11:18:44 <xerox> shapr: I've got a list, but it is in italian....
11:18:58 <gour> sharp: you'll be around here or you are recruiting new people?
11:19:10 <shapr> xerox: I don't read much italian, but exposure is the best way to learn.
11:19:21 <xerox> http://www2.polito.it/didattica/polymath/htmlS/info/CONVEGNI/ITALIA.HTM
11:19:21 <shapr> gour: I'll be in Zagreb in the next few months.
11:19:24 <lambdabot> Title: Progetto Polymath - Convegni - Italia, http://tinyurl.com/yhhfu8
11:19:25 <shapr> No set date yet.
11:19:29 <xerox> shapr, see under Calendario 2006
11:19:52 <gour> shapr: i'll probably write some program in userRPL for my hp49g+ calc using functional ideas
11:20:02 <shapr> wow
11:20:11 <gour> shapr: how long you'll stay?
11:20:20 <shapr> I'm not sure, probably one or two weeks.
11:20:28 <gour> great
11:20:43 <shapr> xerox: that sounds like lots of fun
11:20:49 <gour> what will you do, ie. primary reason why you are coming?
11:20:58 <shapr> I wonder if the university next to me would let me sit in on classes...
11:21:01 <xerox> shapr: in fact I was searching for "penna geometrica" because I wanted to show you what the man from two weeks ago showed us... (he actually built it); and I found this calendar I wasn't aware of.  good good....
11:21:19 <gour> shapr: which uni?
11:21:31 <xerox> every university does here in .it
11:21:35 <xerox> afaik.
11:21:45 <shapr> I'm visiting my friends who moved to Zagreb, but I thought I'd try to meet nearby programming language theory and/or open source people.
11:21:55 <shapr> gour: uab.edu
11:22:08 <gour> shapr: i'm going to eat something.bbl
11:22:16 * shapr should eat too
11:22:17 <xerox> is it a tld? :P
11:22:25 <xerox> laters then
11:24:15 <shapr> xerox: edu is a tld, but uab.edu is just the university next to me.
11:25:36 <paolino> xerox is boikotting haskell.IT
11:26:05 <shapr> aww
11:26:07 <xerox> ooooops.
11:26:13 <xerox> I've just came back home, sorry paolino!
11:26:14 <grac> gour: maybe we could organize some gathering in Zagreb; sort of a welcome party for shapr :-)
11:26:22 * xerox joins
11:32:25 <grac> hello, is this thing on?  suddenly everybody is silent
11:33:00 * eviltwin_b is working, and trying not to fall asleep
11:33:26 * shapr is hacking on his wiki for happs
11:33:35 <shapr> grac: When it goes quiet, that usually means that people are coding.
11:33:49 <glguy> napping?
11:34:03 <emu> it's the quiet before the STorm
11:34:03 <astrolabe> yeah napping
11:34:03 <lambdabot> emu: You have 1 new message. '/msg lambdabot @messages' to read it.
11:34:07 <shapr> grac: How far have you gotten with Haskell? Have you written any code?
11:34:12 <grac> shapr: that's cool.  I was just surprised with sudden urge to go coding.
11:34:37 <Nafai> I need to get back to learning Haskell.  I've been distracted by writing working code in other languages
11:34:50 <shapr> Nafai: You could try to rewrite some of that code in Haskell.
11:34:57 <grac> shapr: nope, I've mostly been in Common Lisp lately, and after a year or so, I have decided that it would be smart to check what pure FP is all about.
11:35:12 <shapr> grac: http://www.haskell.org/hawiki/HaskellDemo
11:35:13 <lambdabot> Title: HaskellDemo - The Haskell Wiki
11:35:43 <shapr> Igloo: btw, HaskellDemo is getting a lot of hits after Pugs READTHEM hit reddit and del.icio.us yesterday. I'm torn...
11:35:57 <Nafai> shapr: Not all of what I need is wrapped (AFAIK) in gtk2hs....I'm writing a notification system in Python using libnotify, d-bus, and TrayIcon
11:36:29 <shapr> I know there are Haskell wrappings for inotify and d-bus.
11:36:36 <savanni> Oh, I've got a question.  And it's probably the wrong one, but I'll ask, anyway.
11:36:53 <lisppaste2> glguy pasted "yet another simple Cont exercise" at http://paste.lisp.org/display/31534
11:36:55 <shapr> Wait, I'm not sure if there's a d-bus wrapper, and I have no idea about TrayIcon.
11:36:56 <savanni> How do I go about diagnosing an Exception that a setup script is throwing?
11:37:32 <shapr> savanni: What's the exception? You could paste the error and then ask us to look at it.
11:37:52 <shapr> Nafai: Even attempting to rewrite the code will likely teach you more about Haskell :-)
11:37:55 <savanni> k, this is from the Setup.hs script for cgi-compat:
11:38:06 <savanni> "*** Exception: Line 11: Parse of field 'extensions' failed"
11:38:16 <shapr> You could even extend the gtk2hs wrapper to do the parts you're missing. That would teach you even more!
11:38:16 <Nafai> shapr: True.
11:38:25 <savanni> Thing is, this could be a misconfiguration on my system.  I just don't know how to look any deeper.
11:38:48 <shapr> savanni: Sounds like either you have an old version of Cabal installed, or the .cabal file has errors in it.
11:39:13 <shapr> Are you using the latest cgi-compat from bringert's darcs repo?
11:39:14 <emu> has anyone ever written code combining StateT with ST?
11:39:41 <savanni> No, I'm using the 2006.9.6 tar.
11:39:47 <savanni> So... probably an old cabal.
11:40:14 <shapr> savanni: I'd suggest doing "darcs get http://www.cs.chalmers.se/~bringert/darcs/cgi-compat/"
11:40:15 <lambdabot> Title: Index of /~bringert/darcs/cgi-compat
11:41:39 <Igloo> shapr: Move it to the new wiki and put an apache redirect in?
11:42:22 <shapr> Igloo: Yeah, probably the best solution.
11:42:35 <Nafai> shapr: Okay, I'm interested in trying this with Haskell.  Particularly my client interface because it could use Parser stuff.  I guess I need to figure out how to model what I have as objects in the "Haskell way"
11:43:04 <Nafai> shapr: darcs get http://www.travishartwell.net/projects/chatnotify/code/chatnotify/ in case you are interested
11:43:06 <lambdabot> Title: Directory listing for /projects/chatnotify/code/chatnotify/, http://tinyurl.com/ybmsdd
11:43:36 <Nafai> shapr: I use it and some elisp to play a sound and do a notification pop up when I get messages in ERC
11:43:48 <shapr> hm, cool
11:43:57 <shapr> How do you hook ERC?
11:45:00 <shapr> A simple Haskell approach might use the OpenAL bindings to play a sound. That wouldn't give the TrayIcon stuff though.
11:45:02 <Saizan> shapr: err, sorry i can't find the paper you telled me about earlier, have you a link? on hudak's page (http://www.cs.yale.edu/homes/hudak.html) they are all broken
11:45:04 <lambdabot> Title: Professor Paul Hudak's Home Page
11:45:19 <julianx> hello
11:45:27 <shapr> hoi julianx
11:45:48 <lisppaste2> glguy annotated #31534 with "unfortunately simpler without Cont" at http://paste.lisp.org/display/31534#1
11:45:55 <Nafai> shapr: My .el code is there, it's a modification of http://www.emacswiki.org/cgi-bin/emacs-en/ErcPageMe ; I have a client that accepts commands on stdin that I open as a process in emacs and write to it; the client then calls the appropriate thing on the server via d-bus to play the sound, perform the pop-up, etc
11:45:57 <lambdabot> Title: EmacsWiki: ErcPageMe
11:47:15 <shapr> Saizan: Hm, that sucks. I'll email Hudak and tell him the links are broken. In the meantime - http://www.cs.yale.edu/homes/hudak-paul/hudak-dir/ACM-WS/position.html - http://citeseer.ist.psu.edu/liang95monad.html
11:47:17 <lambdabot> Title: Hudak: Building Domain-Specific Embedded Languages, http://tinyurl.com/y6no6s
11:47:43 <shapr> Saizan: On the other hand, I'm sure there are more recent modular interpreter papers, I just can't think of them off the top of my head.
11:47:48 <shapr> I know I've seen something in the last coupla years.
11:48:31 <Saizan> i'll start with these, thanks :)
11:49:14 <Nafai> shapr: Actually, I could start by just writing my client interface in Haskell, if I can get these D-Bus bindings to work http://neugierig.org/software/hdbus/doc/
11:49:59 <chr1s> hey guys!
11:50:23 <chr1s> I'm working on an expression evaluator
11:50:52 <chr1s> it works for simple expressions like 1+1, 5*(3+3), etc.
11:51:03 <chr1s> now I want to build in variables
11:51:37 <chr1s> the basic workflow is like this: user types in a line, the line gets evaluated, and that gets repeated
11:51:58 <chr1s> I have a function eval :: Expr -> Int which did that
11:52:25 <chr1s> but now, I want to be able to evaluate expressions like "a = 5"
11:52:57 <chr1s> which will not be Expr -> Int but Expr -> StateT Env IO Float
11:53:02 <shapr> What about a reader monad?
11:53:12 <shapr> or that :-)
11:53:17 <chr1s> hehe
11:53:55 <chr1s> so, that's where I got stuck. For example, I'm evaluating one of the constructors, Plus Expr Expr
11:54:44 <chr1s> so, what I need to do is do something like eval (Plus x1 x2) = f (eval x1) (eval x2)
11:54:56 <emu> in general, if you have defined a monad based on StateT, etc, in the IO or Identity monads, is there a straightforward way to convert it to the ST monad?
11:55:03 <chr1s> but I can't figure out how to combine those StateT's
11:55:17 <chr1s> emu: I wouldn't know
11:55:26 <emu> chr1s: first do one, then the other
11:56:06 <emu> do v1 <- eval x1; v2 <- eval x2; return $ f v1 v2
11:56:21 <chr1s> well, I have defined a generic fold over my expr, which is a tupel with a function for every constructor
11:56:33 <emu> is it a monadic fold?
11:56:36 <emu> ie. foldM
11:56:56 <emu> chr1s: i was askin if anyone knew =)
11:57:14 <chr1s> for example, if Expr = Const | Plus Expr Expr, my foldTupel would be (a, a -> a -> a)
11:57:43 <emu> @type foldM
11:57:45 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
11:57:47 <chr1s> I also have a function foldExpr, which applies those functions
11:58:44 <chr1s> for example, foldExpr (f1,f2) (Plus x1 x2) = f2 (foldExpr x1) (foldExpr x2)
11:59:18 <chr1s> based on this, I want to define f2
11:59:47 <savanni> shapr: So, grabbed the latest cgi-compat.  no luck. Grabbed and install the latest cabal.  cgi-compat is now much happier.
11:59:50 <savanni> Thank you.
12:00:56 <shapr> savanni: Glad I can help!
12:01:04 <chr1s> so, back to my original question, I have the following function
12:01:32 <chr1s> f2 :: ExprResult -> ExprResult -> ExprResult
12:01:57 <chr1s> basically, I want to combine the contents of the first and the second argument
12:02:14 <emu> write it monadically in a do block
12:02:28 <chr1s> where ExprResult :: StateT Env IO Float
12:02:53 <emu> given the expression: "do x <- f; return $ g x" it is not valid to write it as g (f)
12:03:15 <emu> there are ways to write it without the "do", but for now, stick to it
12:03:44 <chr1s> yes, I know about (>>=) and return, but that wouldn't help me I think
12:03:48 <emu> yes, it would
12:04:02 <chr1s> for example, the StateT monad has a get function
12:04:02 <emu> you're skipping the whole "getting the value out of the monad with <-" part
12:04:33 <chr1s> yes, but if I do a "do x <- get", it will get the state out of the current monad
12:04:34 <emu> btw, there's a great tutorial for you
12:04:54 <chr1s> what I want to do, is get the state out of one of the argument (which are state monads too)
12:05:12 <emu> sounds like you're misusing the state monad
12:05:24 <shapr> You want a reader, I think.
12:05:30 <emu> http://uebb.cs.tu-berlin.de/~magr/pub/Transformers.en.html
12:05:31 <lambdabot> Title: Monad Transformers Step by Step
12:05:40 <emu> that tutorial covers everything you want to know, precisely on your test case
12:05:50 <chr1s> cool! thanks
12:06:06 <chr1s> but I want the reader monad, ok, I'll dive into that one too
12:06:10 <emu> now to figure out if I'm misusing the StateT monad
12:06:23 <emu> chr1s: that paper covers ReaderT for "environments" and StateT for "profiling"
12:06:44 <chr1s> ah, ok!
12:07:24 * chr1s is off reading
12:11:19 <kyevan> So, does Haskell support 'nullity' <eyeroll/>
12:12:21 <glguy> emu: did you seem my ?tell?
12:12:35 <emu> yes, im still struglging with this though
12:12:44 <emu> i'm guessing that combining StateT and ST is a mistake?
12:12:51 <emu> i don't know why, it seems I have to use STRefs
12:12:52 <glguy> seems liek it
12:12:57 <glguy> you can do it either way
12:13:39 <emu> i can't seem to get the type write to do it with StateT
12:13:42 <emu> right!
12:18:30 <emu> glguy: i can formulate it with IOArrays or in Identity, is there a mechanical transformation from that to ST?
12:19:57 <glguy> I'm not sure, I think that if you just wrap all of the code that worked in IO with a runST
12:20:06 <glguy> or if the final result was an array
12:20:08 <glguy> runSTArray
12:20:21 <glguy> and changed stuff to use the ST array functiosn
12:20:23 <glguy> you'd be ok
12:20:28 <mwc> I think you need to change the types of the references, and if you've used IO(U)Array anywhere, ST(U)Array
12:20:33 <emu> the final result would be a tuple of (Either String a, PropState)
12:20:39 <glguy> only if you manually specified types
12:20:41 <mwc> glguy is on the money.
12:20:46 <emu> one problem is that PropState has STUArrays in it
12:20:54 <emu> is that even allowed?
12:21:09 <glguy> emu: not if you expect to get it out
12:21:13 <glguy> of the runST block
12:21:16 <mwc> glguy, I've always found myself using explicit type signatures in array code, the current system requires it I thought
12:21:29 <emu> hm. i don't need to get it out.
12:21:48 <glguy> mwc: example: http://paste.lisp.org/display/25854#3
12:21:59 <glguy> mwc: in that example I don't use any explicit signatures
12:22:03 <emu> well i dont need to get the STUArrays out, just the other things
12:22:17 <mwc> Hmm, maybe I screwed up by importing MArray?
12:22:34 <glguy> mwc: may very well be... I'm nto sure
12:22:49 <glguy> emu: you probably don't need to pass the STUArrays around like that
12:22:56 <glguy> since they update in place
12:23:06 <glguy> you just need to know about their locations
12:23:22 <glguy> for example, how I used the arrays and refs in simTurm
12:23:31 <glguy> simTurn*
12:24:16 <emu> so using STRefs would be best then
12:24:37 <glguy> instead of a StateT?
12:24:48 <emu> or maybe both
12:24:55 <emu> but take the STUArrays out of the PropState
12:25:22 <lisppaste2> emu pasted "IOUArray version" at http://paste.lisp.org/display/31548
12:25:42 <glguy> emu:  to use STRefs like StateT, you'll need to make sure that the STRef var is in scope everywhere
12:25:51 <emu> yea i can pass it
12:26:01 <glguy> emu: in my example, all teh functiosn that used the stdGen, needed to be in the scope of the simTurn function
12:26:03 <mwc> Heh, the obvious way to do that is put the STRef as the payload of the StateT
12:26:06 <emu> or make it part of the StateT i guess
12:27:05 <glguy> if you are going to carry the ref along , I'd think you would would a Reader instead
12:27:13 <glguy> would want*
12:27:16 <emu> sure, why not add another transformer=)
12:27:58 <glguy> emu: as long as the PropState never exits the ST, you are fine
12:28:04 <glguy> just have the ST code return a solution'
12:28:17 <glguy> and not the whole PropState
12:28:31 <emu> yep, the Solution bit is what it needs  to return
12:28:59 <glguy> when you want to return one of the arrays, however, you have runSTArray
12:29:37 <glguy> or you can use "freeze" I believe
12:29:46 <glguy> to turn an STArray into an array that is allowed to leave
12:29:55 <emu> Solution has DiffUArrays in it, but those are pure
12:30:21 <emu> @info ReaderT
12:30:22 <lambdabot> ReaderT
12:30:33 <bd_> heh
12:30:37 <bd_> :t runReaderT
12:30:39 <lambdabot> forall a (m :: * -> *) r. ReaderT r m a -> r -> m a
12:38:05 <aFlag> hum, searches to hoogle doesn't seem to include hopengl in it?
12:38:06 <lambdabot> aFlag: You have 1 new message. '/msg lambdabot @messages' to read it.
12:40:17 <aFlag> lambdabot: help
12:46:56 <bd_> @hoogle mapM
12:46:57 <lambdabot> Prelude.mapM :: Monad m => (a -> m b) -> [a] -> m [b]
12:46:57 <lambdabot> Maybe.mapMaybe :: (a -> Maybe b) -> [a] -> [b]
12:46:57 <lambdabot> Prelude.mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
12:47:18 <aFlag> @help
12:47:19 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
12:49:17 <bacek> > "hi"
12:49:18 <lambdabot>  "hi"
12:49:24 <bacek> :)
12:50:27 <emu> ugh
12:51:28 <lisppaste2> emu annotated #31548 with "latest ST attempt" at http://paste.lisp.org/display/31548#1
12:52:18 <emu> oo, actually those first 2 data structures are superfluous in this example
12:52:24 <emu> im just trying to make it work with an STRef s Int
12:53:10 <bd_> runStateT (runReaderT stp ref) st
12:53:10 <bd_> I think
12:53:24 <bd_> or just
12:53:29 <bd_> let a = runReaderT stp ref
12:53:32 <bd_> instead of a <- ...
12:53:45 <emu> whoa
12:54:44 <emu> ok=) now to try with arrays
12:55:01 <emu> btw, the forall is necessary, isnt it?
12:55:19 <bd_> not sure XD
12:55:23 <bd_> probably
12:56:14 <emu> ok i think im making some progress now
12:57:22 <glguy> You don't need to actually write "forall"
12:57:29 <glguy> type Whatever a = ST s a
12:58:01 <glguy> I thought...
12:58:07 <glguy> hmm, something like that at least :-p
12:58:21 <bd_> s isn't in scope there...
12:58:28 <bd_> right?
12:58:47 <glguy> right, I just know that I've done it without typing "forall"
12:59:01 <glguy> I just use ST quite rarely
12:59:13 <bd_> Test.hs:3:16: Not in scope: type variable `s'
12:59:16 * bd_ shrugs
12:59:20 <bd_> maybe there's some pragma for it
13:01:49 <glguy> newBoardRef :: ST s (STRef s (STUArray s Int Int))
13:01:52 <glguy> I've used that code
13:01:59 <glguy> you just can't put the "s" in a "type"
13:03:43 <glguy> f :: ST s (STRef s Int)
13:03:43 <glguy> f = newSTRef 0
13:03:48 <glguy> ^ valid code
13:08:58 <glguy> bd_: I didn't need to specify my array type because I was using "runSTArray"
13:10:31 <chr1s> emu: thanks a lot for the Transformers.pdf, that definitely cleared up a lot!
13:10:59 <chr1s> by
13:11:20 <chr1s> btw, if I use a writer monad for logging
13:12:21 <chr1s> and I have tell's all around my code, but I never ask for the contents of the writer monad, will the tells be evaluated? Or will they not be evaluated due to lazyness?
13:12:47 <glguy> I think you need to lookup the LazyWriter
13:14:00 <roconnor> @google 146008B in KB
13:14:02 <lambdabot> No Result Found.
13:14:07 <roconnor> @google 146008 B in KB
13:14:10 <lambdabot> http://www.pubmedcentral.nih.gov/articlerender.fcgi?artid=146008
13:14:10 <lambdabot> Title: De novo generation of simple sequence during gene amplification.
13:14:19 <roconnor> 146008 / 1024
13:14:20 <chr1s> wow, cool
13:14:23 <roconnor> > 146008 / 1024
13:14:24 <lambdabot>  142.5859375
13:14:50 <glguy> > fst $ runWriter (tell (undefined :: String) >> return 1)
13:14:51 <lambdabot>  1
13:15:06 <glguy> this seems to suggest that unused tell data isn't evaluated
13:15:15 <glguy> but I think that the Monad itself is still strict
13:15:42 <chr1s> what does that mean, strict?
13:16:07 <bd_> glguy: Well, it could have an array of [undefined] without exploding.
13:16:50 <glguy> true
13:18:04 <roconnor> chr1s: the standard writer monad is writen in pure lazy Haskell
13:18:22 <chr1s> wow, that's even cooler than I thought
13:18:27 <roconnor> thus data is not evaluated unless requested
13:18:34 <chr1s> that is so cool :)
13:18:35 <glguy> AH
13:18:36 <glguy> i found it
13:18:43 <glguy> A LazyWriterT was made
13:18:49 <chr1s> I really *really* like Haskell
13:18:52 <glguy> http://haskell.org/haskellwiki/New_monads/LazyWriterT
13:18:53 <lambdabot> Title: New monads/LazyWriterT - HaskellWiki
13:19:34 <roconnor> Well, at least assuming the standard writer using the List Monoid
13:20:24 <lisppaste2> emu annotated #31548 with "my pitiful eventual version" at http://paste.lisp.org/display/31548#2
13:21:35 <glguy> emu: why use a STRef to hold the PropEnv?
13:21:58 <glguy> emu: do you expect to have to create new arrays instead of the ones you already created?
13:22:10 <emu> hmm, thought i had to
13:22:18 <emu> i guess not, with the Reader
13:22:36 <glguy> emu: right
13:22:45 <glguy> emu: and then you won't have to do a bunch of extra readSTRef
13:22:52 <mbishop> looks like lisppaste is getting hit pretty hard by spammers
13:22:59 <glguy> oh?
13:23:12 <mbishop> look at paste.lisp.org's "recent pastes"
13:23:27 <mbishop> unless "generic zoloft" is some new code project... :x
13:23:32 <glguy> =/
13:24:00 <glguy> you think it is just some automated program that finds forms and puts ads in them?
13:24:19 <lisppaste2> emu annotated #31548 with "+ ErrorT - STRef" at http://paste.lisp.org/display/31548#3
13:24:28 <glguy> There should be a segment on the nightly news
13:24:39 <glguy> where they announce people that bought stuff from ads like these
13:24:49 <glguy> and humiliate them for beign so stupid
13:25:02 <glguy> so that people will stop, and then the ads won't be profitable...
13:25:39 <bd_> So all we have to do is send additional spams to identify the people who respond to them...
13:25:54 <glguy> I don't really care how they do it
13:26:19 <glguy> they could just have ISPs send a list of 10 people of the day
13:26:30 <bd_> ISPs don't know who respond to them...
13:26:34 <bd_> only the spammers really know :/
13:26:45 <glguy> ISPs know who clicks what links
13:27:06 <bd_> Not really. Only if they have a transparent proxy; and I'd be more worried about the ISP than the people who respond to spam in that case;.
13:27:50 <glguy> ISPs definitely know what your packets are doing, they already log activity
13:27:59 <glguy> they might not know what URL you went to
13:28:12 <glguy> but they know you went to the address of one of these spam links
13:28:21 <bd_> what level of detail is it logged at, though?
13:28:53 <glguy> I know that my university, for example, logged all individual packet traffic
13:29:05 <glguy> they just didn't keep the logs indefinitely
13:29:45 <glguy> when they accused someone of having a virus or an irc bot, etc, they would show you the packet logs as proof
13:30:06 <glguy> and I've seen the originals before they trim out the stuff specific to each case
13:31:42 <bd_> well, they could just log it when the IDS is detected
13:31:43 <bd_> er
13:31:45 <bd_> triggered
13:31:58 <bd_> I mean, 45mbit/s or more logged fully? I don't think so...
13:32:24 <bd_> but, to have an IDS on the line, and capture a trace from one host for a few minutes when it's triggered, is feasable...
13:32:55 <bd_> or more likely
13:33:00 <bd_> to have an IDS on the line emailing an admin
13:33:07 <bd_> who goes out to sniff the network when an issue occurs
13:33:29 <glguy> that would have probably been a better solution
13:33:38 <bd_> but to be logging about 100mbit/s (at least on my school's network) 24/7
13:33:38 <bd_> well
13:33:45 <bd_> your logs probably won't go back very far :p
13:33:47 <blaastaar> what is the best absolute beginner utorial for haskell
13:33:48 <blaastaar> ?
13:33:49 <glguy> they didn't just log the external traffic
13:33:53 <blaastaar> tutorial
13:33:56 <glguy> they logged at the router level
13:34:01 <mbishop> ?where YAHT
13:34:02 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
13:34:16 <bd_> glguy: I would imagine they just attached a sniffer at one of the switches internal to the network, where it was convenient
13:34:21 <bd_> and sampled off a few minutes worth of data
13:34:25 <bd_> that's what I would to
13:34:26 <bd_> do*
13:34:45 <bd_> but
13:34:47 <bd_> 100 mbit/s
13:34:48 <bd_> for a day
13:34:52 <bd_> is about a terabyte
13:35:14 <glguy> of header data?
13:35:15 <bd_> while it's possible, I guess, it'd be a nightmare to have to filter that chunk of data for useful information
13:35:30 <bd_> well, headers I guess would only be a hundred gb or so
13:35:35 <bd_> still a pain to index and track
13:35:50 <bd_> no university's going to do that unless they're required to
13:36:06 <bd_> and a commercial ISP would have even higher traffic volume
13:36:10 <roconnor> > exp(-1)
13:36:11 <lambdabot>  0.36787944117144233
13:36:28 <bd_> which is why they're almost certain to only be sniffing particular hosts when an IDS throws up an alery
13:36:28 <shapr> roconnor: hey that gives me an idea.
13:36:31 <bd_> alert*
13:36:42 <roconnor> > exp(-1)/2
13:36:44 <lambdabot>  0.18393972058572117
13:39:28 <george> > :t 1
13:39:28 <lambdabot>  Parse error
13:39:42 <george> > :t "string"
13:39:42 <lambdabot>  Parse error
13:41:15 <bd_> :t 1
13:41:16 <lambdabot> forall t. (Num t) => t
13:41:17 <bd_> :
13:41:18 <bd_> :)*
13:41:35 <bd_> :t "I wonder if polymorphic strings work here?"
13:41:36 <lambdabot> [Char]
13:41:40 <bd_> guess not
13:43:04 <george> :t (2,2)
13:43:05 <lambdabot> forall a b. (Num a, Num b) => (a, b)
13:44:50 <emu> > array (1,1) []
13:44:50 <lambdabot>  Add a type signature
13:44:59 <emu> > array (1,1) [] :: IArray Int Int
13:44:59 <lambdabot>  Not in scope: type constructor or class `IArray'
13:45:05 <emu> > array (1,1) [] :: DiffArray Int Int
13:45:05 <lambdabot>  Not in scope: type constructor or class `DiffArray'
13:45:34 <bd_> > array (1, 2) [] :: Array Int Int
13:45:36 <lambdabot>  Exception: (Array.!): undefined array element
13:45:39 <bd_> heh
13:45:44 <bd_> > array (1, 2) [(1, 1), (2, 2)] :: Array Int Int
13:45:46 <lambdabot>  array (1,2) [(1,1),(2,2)]
13:45:50 <mbishop> > 3 `div` 0
13:45:51 <lambdabot>  Exception: divide by zero
13:45:55 <mbishop> oh noooooooo
13:45:56 <emu> does an empty array make sense in haskell?
13:46:00 <emu> 0-length
13:46:05 <mbishop> now my autopilot will fail!
13:46:11 <george> emu yeah: []
13:46:14 <metaperl> whoa. all due respect to Mun Hon Cheong - http://www.haskell.org/haskellwiki/Frag
13:46:15 <lambdabot> Title: Frag - HaskellWiki
13:46:19 <emu> > array (1,1) [] :: Array Int Int
13:46:21 <lambdabot>  Exception: (Array.!): undefined array element
13:46:30 <george> :t []
13:46:32 <lambdabot> forall a. [a]
13:46:38 <emu> (1,0)?
13:47:35 <emu> hm that works!
13:56:11 <chessguy> well, phase 1 is complete.
13:56:26 <chessguy> i just got my first programming job offer
13:56:41 <chessguy> phase 2, of course, is rewriting all their stuff in haskell and showing them how much better prefers
13:56:53 <chessguy> s/prefers/performs/
13:58:15 <malebria> > :t zipWith
13:58:16 <lambdabot>  Parse error
13:58:20 <malebria> @type zipWith
13:58:22 <lambdabot> forall c b a. (a -> b -> c) -> [a] -> [b] -> [c]
13:59:41 <emu> sigh
13:59:50 <emu> it's not recognizing my STUArray as an MArray
14:03:50 <lisppaste2> glguy pasted "MArray ST instances" at http://paste.lisp.org/display/31567
14:04:25 <emu> i mean they are declared as bool ones
14:04:30 <emu> and writeArray is fine.. in the ohter function
14:04:45 <emu> but i "ask" it out of the Reader and then try to readArray, and the type system goes bonkers
14:05:02 <emu> there's no way i can give a type annotation, because of the existential type s
14:06:58 <emu> "no instance for (MArray (STUArray s) Bool (ReaderT (PropEnv s) (ErrorT String (StateT PropState (ST s)))))
14:06:59 <dylan> http://video.google.com/videoplay?docid=-3432013567298818193&q=halting+problem
14:07:01 <lambdabot> Title: Genetic programming and halting problem by Riccardo Poli and Bill Langdon - Goog ..., http://tinyurl.com/uet87
14:07:16 <emu> arising from use of 'readArray'"
14:07:34 <emu> admittedly its a bit odd
14:07:46 <emu> does it need to be lifted or something?
14:10:58 <emu> rofl
14:11:02 <emu> yes, it did. 3 times.
14:11:07 <emu> lift . lift . lift $ readArray ...
14:12:36 <aFlag> there really isn't any documentation on hopengl?
14:12:53 <emu> besides haddock generated? there's tutorials...
14:12:59 <emu> i was reading michi's, which is o.k.
14:13:03 <emu> and there's some older out of date ones
14:14:10 <chr1s> I'm almost there!
14:14:30 <chr1s> I've got a function which returns IO EvalResult
14:15:15 <chr1s> which tries to parse something, and if all goes well, calls itself
14:15:21 <chr1s> err
14:15:47 <chr1s> but if the user types "quit", I want to exit the function
14:16:21 <chr1s> or, not go in to recursion. What do I need to return in that case?
14:16:29 <chr1s> I can't just do a return ()
14:16:30 <dylan> @hoogle when
14:16:31 <lambdabot> Monad.when :: Monad a => Bool -> a () -> a ()
14:16:31 <lambdabot> Control.Monad.when :: Monad m => Bool -> m () -> m ()
14:18:18 <dylan> when (not userQuit) myRecursiveAction
14:19:11 <chr1s> dylan, that's the part I'm getting
14:19:12 <bd_> or ContT ;)
14:19:33 <bd_> :t callCC
14:19:34 <lambdabot> Not in scope: `callCC'
14:19:36 <bd_> aw
14:19:42 <bd_> :t Control.Monad.Cont.callCC
14:19:44 <lambdabot> forall (m :: * -> *) a b. (Control.Monad.Cont.MonadCont m) => ((a -> m b) -> m a) -> m a
14:19:56 <dylan> chr1s: what?
14:20:15 * dylan slaps bd_ 
14:20:22 <chr1s> just a sec
14:20:28 <bd_> dylan: ow
14:20:35 <dylan> bd_, I sometimes wonder if you were born with a gene for thinking of the most complicated way of solving a problem. XD
14:20:38 <bd_> whaat? :P
14:20:42 <bd_> XD
14:20:52 <bd_> 00:05 < bd_> (\c m -> fmapM id (guard c >> return m)) :: (Monad m) => Bool -> m f -> m (Maybe f) :: (Monad m) => Bool -> m f -> m (Maybe f)
14:20:56 <bd_> >.>
14:21:36 <bd_> dylan: Hey, it'd work to escape from a deeply recursive system ;)
14:22:14 <bd_> chr1s: basically htough if you're not going to use ContT ;) you can just condition the recursion on the user not quitting
14:23:02 <chr1s> hm, I don't get it dylan
14:23:24 <chr1s> can you give me a small code example?
14:25:04 <dylan> loop = do putStrLn "foo"; s <- getLine; when (not (s == "quit")) loop
14:25:37 <Lemmih> when (not x) === unless x
14:25:39 <emu> ixmap is for getting sub-arrays?
14:25:54 <aFlag> emu: what's that haddock thing? I can't seem to find it
14:25:56 <dylan> oh, unless. nifty
14:26:16 <aFlag> this was all that I found: http://www.haskell.org/HOpenGL/documentation/GLUT/index.html
14:26:22 <glguy> ixmap is for changing the array index type
14:26:50 <chr1s> ok...
14:27:21 <Lemmih> aFlag:  http://www.haskell.org/ghc/docs/latest/html/libraries/index.html ?
14:27:28 <emu> aFlag: its in the standard libraries i meant
14:28:47 <bd_> :t ixmap
14:28:49 <lambdabot> forall e i j. (Ix j, Ix i) => (i, i) -> (i -> j) -> Array j e -> Array i e
14:29:58 <emu> then what's the first argument specifying, if not, the size of the new array?
14:30:02 <emu> er, bounds
14:30:12 <chr1s> so, I want to go from IO a -> IO ()
14:30:19 <chr1s> is that possible?
14:30:26 <bd_> chr1s: yep
14:30:28 <Lemmih> chr1s: action >> return ()?
14:30:45 <emu> @type mapM_
14:30:46 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> [a] -> m ()
14:30:48 <bd_> .. what Lemmih said
14:30:51 <Lemmih> @hoogle void
14:30:51 <chr1s> ahh
14:30:52 <lambdabot> Foreign.Marshal.Error.void :: IO a -> IO ()
14:30:52 <lambdabot> System.Win32.Types.LPVOID :: type LPVOID
14:30:52 <lambdabot> System.Win32.Types.MbLPVOID :: type MbLPVOID
14:30:54 <emu> M_ functions tend to return m ()
14:30:56 <bd_> or (>> return ()), or fmap (const ()) or ...
14:31:11 <chr1s> yeah, I got scared by the Foreign.Marshall part
14:31:26 <glguy> > ixmap (1,2) id $ listArray (0,4) ['a'..'z']
14:31:28 <lambdabot>  array (1,2) [(1,'b'),(2,'c')]
14:31:42 <glguy> > ixmap (1,2) (+1) $ listArray (0,4) ['a'..'z']
14:31:44 <lambdabot>  array (1,2) [(1,'c'),(2,'d')]
14:33:25 <dcoutts__> SamB, you were wishing something about the gtk2hs docs?
14:33:31 <emu> this is what i meant about ixmap:
14:33:32 <emu> > ixmap (1,10) (\i -> (2,i)) $ listArray ((1,1),(2,10)) [1..]
14:33:34 <lambdabot>  array (1,10) [(1,11),(2,12),(3,13),(4,14),(5,15),(6,16),(7,17),(8,18),(9,19)...
14:34:28 <glguy> I understand ixmap better now. so you define the bounds of the new array, and you specify a function that is applied to each of the new indexes
14:34:41 <glguy> to figure out which old element to use in that position
14:35:03 <emu> yea
14:35:04 <glguy> so you were originally correct that i can be used to take a subarray
14:35:09 <emu> thats what i figured it must be from the type
14:35:18 <agocorona> I have problem on building hs-plugins for windows (multiple target patterns)
14:35:29 <chr1s> so, also, I have a function f :: IO Result
14:35:31 <emu> i wanted to slice a 2d array and get a 1d array, so this works
14:35:35 <agocorona> someone has the binaries of hs-plugins for windows?
14:35:52 <SamB> dcoutts: yes, links to the relevant pages in the gtk docs
14:36:25 <dcoutts__> SamB, why?
14:36:27 <chr1s> and I want to do recursion, but when I do this: "do f" it says that that is the wrong type...
14:36:47 <dcoutts__> SamB, not that I think it's a bad idea, just wondering why you'd want it
14:36:48 <SamB> dcoutts: so I can *read* them
14:37:16 <dcoutts__> SamB, you'll note that we already steal most of the docs from the C docs
14:37:32 <dcoutts__> so what extra is it that you're looking for ?
14:38:16 <SamB> well, it better explains some things to do with TextMarks and TextIters and TextBuffers and TextViews...
14:38:42 <SamB> and probably little bits all over
14:40:09 <dcoutts__> SamB, we're accepting patches :-)
14:40:58 <dcoutts__> we've got a code gen that turns the C docs into haddock docs, perhaps we just need to merge again from those if the C docs have been improved since we last merged
14:41:00 <jlouis> Concurrency eats me
14:41:15 <chessguy> so give it indigestion
14:41:42 * SamB wonders how to get Page Up/Page Down to scroll a TextView when a particular Entry is focused
14:42:30 <dcoutts__> SamB, no idea, I'd have to read the docs :-)
14:43:19 <Saizan> btw, is there something like Qt2hs?
14:43:55 <dcoutts__> Saizan: no, because Qt is written in C++ and not designed for language bindings
14:44:12 <dcoutts__> Gtk+ was explicitly designed to be bound by GCed languages
14:44:37 <jlouis> Gtk+ ++
14:45:02 <jlouis> (Is mono the helping hand here?)
14:45:26 <dcoutts__> jlouis: no, it was long before mono
14:45:34 <norpan> hey
14:45:42 <agocorona> Any charitable guy has the Windows binaries of hs-plugins  for this Makefile victim?
14:45:43 <dcoutts__> Gtk+ has had bindings for ages, since 1.2 era
14:45:59 <dcoutts__> ie well before C#/.net
14:46:25 <jlouis> dcoutts, interesting.
14:46:58 <dcoutts__> Gtk+ has a bit of cruft, but in general I think it's very well designed
14:46:59 <Saizan> agocorona: i have them compiled with ghc 6.6 so they won't work :D
14:47:42 <Saizan> the downside is that on windows is a bit ugly from what i've seen
14:47:55 <SamB> I thought Qt was written in Q++!
14:48:35 <SamB> dcoutts: did they use them for script-fu?
14:48:54 <agocorona> Saizan: aha, I know the problem. What unix utilities did you use to compile it?
14:49:31 <Saizan> agocorona: compiled on windows with minGW
14:49:35 <agocorona> Saizan: why?
14:49:50 <agocorona> (ugly)?
14:49:54 <Saizan> requisite to compile lambdabot
14:50:06 <Saizan> (talking of gtk there)
14:50:33 <agocorona> miGW has a unix shell ?
14:50:43 <Saizan> there's msys
14:50:58 <Saizan> but i use cmd.exe anyway
14:51:22 <agocorona> How? there are no BAT in the source...
14:51:53 <agocorona> i mean: no windows batches.
14:51:55 <Saizan> with the port of make
14:52:04 <Saizan> and sh for configure scripts
14:52:42 <agocorona> that is my point I dont find any sh implementation for Windows except cygwin
14:53:01 <agocorona> I didnt notice that minGW has sh
14:54:32 <Saizan> it has
14:54:41 <Saizan> maybe it's in the msys package
14:54:51 <Saizan> yes, it's there
14:55:27 <agocorona> ok , i will re-check
14:55:55 <agocorona> I cant live without eval
14:58:27 * SimonRC wonders where the heck the permutations function is in the libraries
14:59:53 <norpan> it's not there because you want to make homework assignments working it out
14:59:55 <dcoutts__> SamB, script-fu ?
15:05:52 <Lemmih> jlouis: You're the original conjure developer, right?
15:14:28 <edwardk> is there any sort of weak pointer library for haskell?
15:16:04 <sorear> ?where Stretching the storage manager
15:16:05 <lambdabot> I know nothing about stretching.
15:16:13 <edwardk> ah found it
15:16:45 <edwardk> @hoogle Weak
15:16:46 <lambdabot> System.Mem.Weak :: module
15:16:46 <lambdabot> System.Mem.Weak.Weak :: data Weak v
15:16:46 <lambdabot> System.Mem.Weak.deRefWeak :: Weak v -> IO (Maybe v)
15:16:53 <edwardk> thats what i wanted =)
15:23:58 <dons> moin
15:24:08 <edwardk> moin dons
15:28:35 <dons> ?users
15:28:35 <lambdabot> Maximum users seen in #haskell: 278, currently: 266 (95.7%), active: 34 (12.8%)
15:28:41 <dons> ?yow!
15:28:41 <lambdabot> Hmmm ... an arrogant bouquet with a subtle suggestion of POLYVINYL
15:28:42 <lambdabot> CHLORIDE ...
15:29:22 <zptao> ?chloroform
15:29:22 <lambdabot> Unknown command, try @list
15:29:27 <blaastaar> well
15:29:54 <blaastaar> Im wondering if there are uncharted business waters that haskell can enable, even if it is simply by not accepting norms
15:30:07 <blaastaar> I think myspace is sad
15:30:14 <blaastaar> facebook too
15:30:24 <blaastaar> google grups is pitiful newgroup GUI
15:30:30 <blaastaar> yahoo groups not much better
15:30:42 <blaastaar> and yahoo finance pisses me off once a day and its the least painful
15:32:00 <sorear> what is the usual way to give library A optional support for library B?
15:33:12 <shapr> plugin package?
15:33:43 <SamB> badly!
15:33:50 <dcoutts__> g'night
15:34:23 <sorear> eg: RIO provides monadic refs.  a library (name temp. forgotten) has a typeclass for monadic refs.  I'd like to provide an instance for it.
15:36:09 <SamB> sorear: as I said -- badly! that is the usual way!
15:36:38 <sorear> I don't want to just provide an instance, because then I'd have to depend on the other lib
15:36:53 <sorear> I'd also like to support streams...
15:37:34 <SamB> well, I suppose the way that would work best would be to make an additional package just for each of those things...
15:41:40 <dons> sorear: using cpp and a separate cabal file?
15:42:08 <kyevan> > ['a'] == "a"
15:42:10 <lambdabot>  True
15:42:44 <kyevan> Huh. That's odd. In a neat sorta way.
15:42:47 <sorear> dons: could you please elaborate?
15:42:59 <sorear> kyevan: A string is a list of characters.
15:43:02 <sorear> ?hoogle String
15:43:03 <lambdabot> Foreign.C.String :: module
15:43:04 <lambdabot> Prelude.String :: type String
15:43:04 <lambdabot> Text.Read.String :: String -> Lexeme
15:43:12 <sorear> ?hoogle Prelude.String
15:43:14 <lambdabot> No matches, try a more general search
15:43:19 <sorear> ?type Prelude.String
15:43:21 <lambdabot> Not in scope: data constructor `Prelude.String'
15:43:43 <dons> sorear: you can use cpp to conditionall import something
15:43:53 <dons> and a separate cabal file to specify the extra dependency
15:44:02 <dons> the user chooses which cabal file before they build
15:45:12 <sorear> hmm - seems like a problem if they have the same name.  If Program C uses RIO and ref instances, how does it depend on refclass-enabled RIO?
15:46:39 <dons> if its really different, you should structure the packages different
15:46:55 <dons> since forks like this are build issues waiting to happen
15:47:09 <SamB> dons: yeah, that is icky!
15:47:22 <SamB> I think sorear sees the issue
15:47:32 <SamB> but was looking for some nice way of dealin with it
15:47:48 <SamB> like maybe parameters to packages?
15:48:06 <dons> right, so in openbsd, you can depend on, say: ghc-6.2.2-prof
15:48:10 <dons> (subpackage strings)
15:48:18 <dons> we'd probably want that eventually in cabal
15:48:33 <dons> so the -ref way would be a tag on the rio package
15:48:35 <SamB> I was thinking they would go in parens
15:48:41 <SamB> so you could have more than one
15:48:43 <dons> and you could depend on rio (ref) >1.0-
15:48:46 <dons> or something
15:48:52 <SamB> and they wouldn't look like part of the package name proper
15:48:54 <dons> best to raise this issue on the cabal list
15:48:59 <sorear> AFAICT the best solution is to create small separate Cabal packages in the same darcs repo named "RIO-mref" e.g depending on RIO and <other-lib>.
15:49:00 <dons> sorear: would you like to do that?
15:49:09 <dons> sorear: yeah, that'd be a decent soln
15:49:17 <SamB> sorear: at the moment!
15:49:40 <SamB> maybe always
15:49:56 <SamB> but it should be made more convenient in any case
15:50:06 <sorear> dons: it sounds like a better solution for big differences (eg. prof), but it's just wasten disk for mostly-identical packages like RIO and RIO-with-ref-support.
15:50:50 <dons> yep
15:50:56 <dons> make a little wrapper package
15:51:01 * SamB was thinking that you would only have one installed
15:51:39 <sorear> SamB: you can never have just one.
15:52:28 <sorear> Dependencies often wind up dragging far too much onto your system.
15:52:51 <SamB> hmm.
15:53:12 <SamB> I don't think dons was suggesting what you think he was suggesting.
15:56:45 <dons> dcoutts: any news on ghc 6.6 in gentoo?
15:58:31 <kyevan> Has Haskell ever been used on low-speed, low-memory embedded systems? (Game Boy Advance level or lower?)
15:59:12 <kyevan> Or is that, as yet, still the realm of the C family and ASM?
15:59:23 <sorear> there's a Palm port, (Motorola Dragonball, 96kb usable ram)
15:59:41 <sorear> grep for palm in the HCAR
15:59:46 <sorear> ?where HCAR
15:59:47 <lambdabot> http://www.haskell.org/communities/
15:59:51 <kyevan> sorear: Orly? That about perfectly discribes the palm I have!
16:00:17 <kyevan> (I was just curious if anyone had done anything with it on low-power systems, but, cool!)
16:00:23 <sorear> the Palm has lots of RAM but malloc can only use 96k - the rest is reserved for ramdisk.
16:00:36 <kyevan> sorear: Yep.
16:00:41 <dons> yeah, nhc was designed for very small systems
16:00:43 <dons> (and yhc)
16:00:55 <kyevan> (Although I recall a few hacks to use some of the ramdisk)
16:01:10 <kyevan> ... Virtual memory on a ramdisk. What is the world coming to?
16:01:11 <kyevan> :P
16:02:07 <sorear> kyevan: Actually linux has delibarate support for that. Turns out some b0rken mobos don't cache RAM above 64MB, so it's too slow to me used for anything other than swap.
16:02:52 <kyevan> sorear: It's still kinda insane.
16:03:14 <SamB> when your main storage is ramdisk, it isn't so insane
16:03:24 <SamB> though *that* still seems rather odd
16:04:35 <sorear> kyevan: you should read about tmpfs.
16:05:10 <aFlag> hi, using hopengl. I get a Position that have 2 GLints as parameters, supposely the pixel position. How do I transform it into the matrix coordinates?
16:05:42 <sorear> tmpfs has no backing store at all, not even ram - it pulls tricks so that tmpfs files are never evicted from the disk cache.  Then it pulls more tricks so the disk cache can be swapped out.
16:06:44 <sorear> many "ultramodern / toy" OS's (EROS et al) pull similar tricks.
16:07:47 <SamB> ... and that is more efficient than ext3?
16:08:49 <bd_> only when it's not actually swapped out :)
16:09:15 <SamB> its more efficient than ext3 when it is cached?
16:09:32 <sorear> no all fs's are the same in cache
16:09:38 <blaastaar> so is haskell going to redo x windows and make it better?
16:09:49 <blaastaar> is haskell going to rewite linux and make it better?
16:09:55 <SamB> no
16:09:59 <SamB> why would we do those things?
16:10:01 <bd_> http://groups.google.com/group/linux.kernel/browse_thread/thread/7c99cde314483da4/3bc88a4dbfd9b188 relevant
16:10:03 <lambdabot> Title: Google Groups: linux.kernel, http://tinyurl.com/yf8eg2
16:10:04 <blaastaar> is there going to be a better dns server in haskell?
16:10:10 <SamB> we would write a different window system...
16:10:14 <bd_> blaastaar: Are you going to write one? :)
16:10:19 <blaastaar> me?
16:10:22 <blaastaar> no
16:10:30 <blaastaar> i can barely config one we have
16:10:31 <blaastaar> !
16:10:38 <sorear> Actually I thought of doing that as an OO-tutorial :)
16:10:45 <SamB> it might be easier than configuring the one you already have!
16:11:12 <blaastaar> hm
16:11:14 <blaastaar> really?
16:11:23 <blaastaar> what about drivers to all the graphics cards?
16:11:26 <blaastaar> n stuff
16:12:19 --- mode: ChanServ set +o dons
16:12:25 --- mode: dons set +b *!*=gschuett@4.38.41.*
16:12:25 --- kick: blaastaar was kicked by dons (gschuett)
16:12:33 <dons> why does he bother? :/
16:12:37 --- mode: ChanServ set -o dons
16:12:49 <zptao> fuck you negroid
16:13:04 <dons> zptao: what are you trying to do?
16:13:16 <zptao> nothing
16:13:18 <bd_> dons: Does blaastaar come often?
16:13:27 <dons> bd_ unfortunately
16:13:32 <bd_> ic :/
16:13:45 <dons> ?protontorpedo has his own plugin
16:13:45 <lambdabot> I dont know any programming yet at 33 dream of learning ti and gettign rich
16:14:09 <zptao> me too
16:15:07 <zptao> http://youtube.com/watch?v=na0mYSFPoCU
16:15:14 --- mode: ChanServ set +o dons
16:15:18 --- mode: dons set +b *!*i=topaz@*.dsl.pltn13.pacbell.net
16:15:18 --- kick: zptao was kicked by dons (sigh)
16:15:31 <dons> he's been banned before, and in perl6. why do these people bother?
16:15:34 --- mode: ChanServ set -o dons
16:15:48 <dons> its almost like he was inspired by gschuett :/
16:18:34 --- mode: ChanServ set +o dons
16:18:38 --- mode: dons set -b *!*i=hussein@*.kpylaajakaista.net
16:18:41 --- mode: ChanServ set -o dons
16:18:52 <dons> ?users
16:18:53 <lambdabot> Maximum users seen in #haskell: 278, currently: 259 (93.2%), active: 28 (10.8%)
16:19:08 <dons> I think we do surprisingly well, considering the size of the channel
16:19:19 <astrolabe> dons: what does 'active' measure?
16:19:49 <_Stinger_> ppl who talk I guess
16:19:51 <_Stinger_> ?users
16:19:52 <lambdabot> Maximum users seen in #haskell: 278, currently: 259 (93.2%), active: 30 (11.6%)
16:19:52 <dons> spoken in the last 4 hours
16:20:04 <astrolabe> ta
16:20:44 <sorear> oooh - just figured out how to list bans - how'd we get a three-stars block on magnesium.net?
16:21:17 <dons> palomer :/
16:21:50 <bd_> @palomer
16:21:50 <lambdabot> I think you're all nuts
16:22:39 <sorear> are those big numbers time_ts?
16:22:55 <dons> mm?
16:23:21 <bd_> sorear: what client are you using?
16:23:35 <sorear> ircii
16:23:40 <bd_> oh, don't know then :/
16:23:44 <bd_> probably time_ts...
16:23:57 <sorear> /mode #haskell -b
16:24:27 <sorear> *** #Haskell  *!*@*.magnesium.net ... 1164889832
16:24:35 <dons> SamB: you didn't notice that was gschuett?
16:25:21 <SamB> dons: I don't even think I know who that is!
16:27:18 <dons> keep an eye out next time: (see bottom of this page): http://www.cse.unsw.edu.au/~dons/code/lambdabot/Plugin/Quote/Text.hs
16:27:20 <lambdabot> http://tinyurl.com/mkqad
16:27:40 <dons> though he's stuck to the same ip address for the last few months, and that's blocked now.
16:29:37 <jlouis> oh, joy. I just "got" comonads
16:29:48 <dons> heh
16:29:48 <SamB> jlouis: oh no!
16:29:58 <SamB> I hope I never do!
16:30:20 <_Stinger_> put some ointment on it
16:31:19 <_Stinger_> sometimes Haskell seems like an arms race between weird mathematical constructs and my brain :(
16:32:33 <dons> beautiful
16:32:45 <dons> ?remeber _Stinger_ sometimes Haskell seems like an arms race between weird mathematical constructs and my brain
16:32:53 <dons> ?quote _Stinger_
16:32:53 <lambdabot>  sometimes Haskell seems like an arms race between weird mathematical constructs and my brain
16:33:33 <sorear> hmm - RIO and IOArrays wrt Malicious Ix instances. (a) ignore the problem and expect it to be fixed before RIO goes mainstream (b) workaround the problem by reimplenting (slower!) access
16:33:37 <Philippa> yeah. Now consider what that does to your net ability to code :-)
16:33:56 <sorear> arms races are a boon for the economy.
16:34:51 <dons> sorear: you're really worried about this Ix instance thing?
16:34:59 <SamB> sorear: (c) require people to quickcheck their junk!
16:35:05 <dons> the user has to go out of their way to write a broken Ix instance: how often does that happen?
16:35:13 <dons> and the result will be they'll break their own code.
16:35:23 <Philippa> but also any client of their own code
16:35:36 <SamB> nobody implements Ix!
16:35:37 <sorear> RIO's percieved niche is security - my users are malicious
16:35:39 <Philippa> in fairness, I'm trying to remember when I last saw a custom Ix instance in a library, but hey :-)
16:35:41 <SamB> its just magic!
16:35:45 <dons> derive Ix
16:36:18 <dons> sorear: I think there's other things to worry about, honestly, once you've given the user the ability to write their own instances, you may as well give up
16:36:23 <SamB> btw, I have ZMachine not crashing on Lists and Lists for me anymore
16:36:40 <Philippa> certainly if they can write their own instance /and/ use unsafePerformIO
16:36:51 <SamB> though you can't actually *read* the book or see the status line
16:37:46 <dons> anyway, the strong consenus seems to be this needs to be fixed. so its not keeping me awake at night
16:38:08 <SamB> what needs to be fixed now?
16:38:13 <SamB> the spec?
16:38:22 <dons> the spec
16:38:36 <SamB> the off-by-one error, or more than that?
16:38:38 <dons> you've not been following the thread/
16:38:44 <dons> hmm?
16:38:58 <sorear> on the mailing lists I've seen three performance-preserving solutions (granted, one is mine), so there're plenty of options
16:39:27 <dons> http://thread.gmane.org/gmane.comp.lang.haskell.cafe/17025/focus=17025
16:39:30 <lambdabot> Title: Gmane Loom, http://tinyurl.com/wpcyz
16:40:21 <sorear> also noticed: I cannot in full generality implement MArray, since I use different monadic contexts for reading and writing, and MArray uses the same monad for both operations.  I don't expect this to be a big deal.
16:41:08 <dons> basing your stuff over streams is a bit iffy -- all those undecidable instances don't make for portable code.
16:41:24 <dons> can it run outside of ghc? or is that not the intention
16:43:19 <dons> ?seen Cale
16:43:20 <lambdabot> I saw Cale leaving #oasis, #ghc and #haskell 5h 16m 37s ago, and .
16:43:22 <dons> huh
16:43:27 <dons> ?tell Cale http://scienceblogs.com/goodmath/2006/12/nullity_the_nonsense_number_1.php
16:43:27 <lambdabot> Consider it noted.
16:43:40 <sorear> is it safe to read from an MArray after unsafeFreeze ?
16:44:36 <mwc> Heh dons, lispy and I were discussing that last night
16:44:48 <dons> heh
16:45:16 <sorear> how about keeping a ref, and *not* using it?
16:45:59 <sorear> the region-calculus aspects of RIO allow me to provide a safeFreeze that statically prevents access to the MArray, but can't stop ref leakage.
16:50:24 <wy> Hello. I'm wondering what does "need" in call-by-need mean? When does Haskell need the value?
16:51:09 <sorear> when a depending value is needed.
16:51:11 <mwc> wy, if foo == 1 then bar else baz
16:51:21 <sorear> in x + x , x is needed if x + x is
16:51:22 <mwc> if you want the value of the if expression, then foo is needed
16:51:52 <mwc> on the otherhand, if foo is one, then baz is never needed
16:52:00 <cjeris> dur dur dur why does my farking optimizer deduce wrong truth values
16:52:01 <sorear> the Ultimate Cause is IO - when you say main = x, the value produced by executing x is needed.
16:52:30 <wy> sorear: You hit the point. I'm actually wondering about the ultimate need
16:56:17 <wy> I'm considering a weird language that has both call-by-need and reference cells.  let f = ref 3 in let z = (x:=1+ !x) in (x:=1+!x)+!x.
16:56:41 * SamB wonders if powerpoint can import eps files?
16:56:52 <wy> I guess the value should be x=ref 8
16:57:13 <astrolabe> dons: Oh no!  That nutter lectures at my old university :(
16:57:16 <SamB> oh, but wait
16:58:16 <SamB> these are from metapost, so they won't work without TeX fonts anyway...
16:58:21 <sorear> wy: Monads!
16:58:34 <wy> I think since z is never needed. So x:=1+!x is never evaluated in the second let?
16:58:40 <sorear> ?hoogle Data.IORef
16:58:41 <lambdabot> No matches, try a more general search
16:58:56 <sorear> ?hoogle Data.IORef.newIORef
16:58:58 <lambdabot> No matches, try a more general search
16:59:01 <astrolabe> As does this nutter http://en.wikipedia.org/wiki/Kevin_Warwick  It seems to have become a magnet.
16:59:19 <wy> sorear: Ah. So it's not really weird ;-)
16:59:52 <sorear> ?hoogle a -> IO (IORef a)
16:59:54 <lambdabot> Data.IORef.newIORef :: a -> IO (IORef a)
16:59:58 <jlouis> Algol was call-by-name without protected side effects...
17:00:13 <sorear> <shudder>
17:00:18 <jlouis> indeed
17:00:50 <wy> sorear: Do you think the result is 8 in my example?
17:01:25 <wy> sorear: Or better, you could help me to translate the example into Haskell
17:03:34 <sorear> C.A.R.Hoare: "Algol 60 was a great improvement on most of its successors"
17:03:40 * sorear loves wikiquote
17:03:59 <emu> ok, after sorting out the stupid mistakes, i think i may have successfully translated my fgl implementation into an adjacency matrix one
17:04:05 <emu> at least, according to quickcheck
17:04:59 <sorear> wy: what is 'x'?
17:05:34 <wy> sorear: sorry. I mistyped. the first let is let x=ref 3
17:07:02 <gravity> I'm trying to reimplement the map function (an exercise in a tutorial) and ghci is complaining that there's no instance for (Show (a -> a)) arising from use of `print'. Why is this happening?
17:07:09 <dons> emu: great!
17:07:25 <dons> gravity: sounds like you're not applying your function to one argument
17:07:33 <Excedrin> gravity: a -> a is a function, so you're probably not giving something enough args
17:07:35 <dons> i.e. the result is a function of type a -> a
17:07:50 <dons> gravity: which ghci then tries to show, but there's no instance of Show for functions
17:07:50 <gravity> hrm
17:07:56 <dons> so, where's the code?
17:08:05 <dons> ?paste
17:08:05 <lambdabot> http://paste.lisp.org/new/haskell
17:08:09 <gravity> Thank you :-)
17:08:17 <Excedrin> @type show id
17:08:19 <lambdabot>   No instance for (Show (a -> a))
17:08:19 <lambdabot>    arising from use of `show' at <interactive>:1:0-3
17:08:25 <Excedrin> > show id
17:08:26 <lambdabot>  Add a type signature
17:08:32 <sorear> > show not
17:08:33 <Excedrin> oh, wasn't there an instance for that?
17:08:34 <lambdabot>  "<Bool -> Bool>"
17:08:38 <lisppaste2> gravity pasted "My Little Map" at http://paste.lisp.org/display/31595
17:08:40 <wy> sorear:  let x = ref 3 in let z = (x:=1+ !x) in (x:=1+!x)+!x
17:08:49 <Excedrin> there we go
17:09:22 <Excedrin> wy: just make your language strict by default and you've reinvented SML (or AliceML)
17:10:07 <sorear> > runST $ do { x <- newSTRef 3 ; let z = do modifySTRef (+1) x ; modifySTRef (+1) x ; y <- readSTRef x ; return x+x }
17:10:07 <lambdabot>  Parse error
17:10:34 <sorear> > runST $ do { x <- newSTRef 3 ; let z = modifySTRef (+1) x ; modifySTRef (+1) x ; y <- readSTRef x ; return (y+y) }
17:10:37 <lambdabot>  Parse error
17:10:51 <sorear> > runST (do { x <- newSTRef 3 ; let z = modifySTRef (+1) x ; modifySTRef (+1) x ; y <- readSTRef x ; return (y+y) })
17:10:52 <lambdabot>  Parse error
17:11:25 <sorear> ok - why doesn't do-notation work in lambdabot?
17:11:42 <twanvl> The let might be the problem
17:12:03 <sorear> > runST (do { x <- newSTRef 3 ; let { z = modifySTRef (+1) x } ; modifySTRef (+1) x ; y <- readSTRef x ; return (y+y) })
17:12:04 <lambdabot>  Not in scope: `readSTRef'
17:12:16 <Excedrin> gravity: looks fine to me... my_map id [1,2,3] -- [1,2,3]
17:12:40 <bd_> I thought runST was disabled?
17:12:40 <sorear> > Control.Monad.ST.runST (do { x <- Data.STRef.newSTRef 3 ; let { z = Data.STRef.modifySTRef (+1) x } ; Data.STRef.modifySTRef (+1) x ; y <- Data.STRef.readSTRef x ; return (y+y) })
17:12:41 <lambdabot>  Not in scope: `Data.STRef.readSTRef'
17:12:42 <bd_> > runST
17:12:43 <lambdabot>  Not in scope: `runST'
17:12:47 <gravity> Excedrin: I'm passing it (+). Could that be a problem?
17:12:49 <bd_> > Control.Monad.runST
17:12:50 <lambdabot>  Not in scope: `Control.Monad.runST'
17:12:51 <bd_> yeah
17:12:55 <sorear> > Control.Monad.ST.runST
17:12:57 <lambdabot>  Not in scope: `Control.Monad.ST.runST'
17:12:59 <bd_> it's disabled because of unsafeSTtoIO I thought
17:13:30 <sorear> > Data.STRef.newSTRef
17:13:31 <lambdabot>  Not in scope: `Data.STRef.newSTRef'
17:13:36 <sorear> > Data.List.sort
17:13:38 <lambdabot>  Add a type signature
17:13:54 <gravity> Oh duh
17:13:55 <Excedrin> gravity: passing (+) will apply (+) to each item in whatever list you pass in, so you'll have [(+1),(+2),(+3)] which is of type [(a -> a)]
17:14:02 <sorear> (thought hier-mods might be the prob)
17:14:03 <gravity> I see
17:14:10 <bd_> 22:41 < dons> ST isn't availabe. due to unsafeSTtoIO
17:14:18 <emu> blaaaaaah
17:14:28 <gravity> Excedrin: I see now.
17:14:29 <emu> ran just as slow
17:14:32 <gravity> Excedrin: Thank you for the help.
17:14:34 <gravity> Thanks everyone
17:16:52 <dons> gravity: problem solved?
17:18:13 <aFlag> anyone here uses hopengl?
17:18:39 <gravity> dons: Yep, just me being dumb and passing it (+)
17:18:52 <Lemmih> aFlag: I played around with it once.
17:19:17 <gravity> I'm a total functional newbie, so I guess I'll be making these mistakes for a little while to come
17:19:20 <aFlag> I'm having a hard time getting the mouse position and translating it into the matrix coordinates
17:19:50 <aFlag> do you know how to do it Lemmih?
17:20:17 <Lemmih> No, that's a bit over my head. Sorry.
17:20:32 <aFlag> alright :(
17:20:35 <dons> interesting, http://praisecurseandrecurse.blogspot.com/
17:20:37 <lambdabot> Title: Praise, Curse, and Recurse
17:21:09 <dons> anyone have a win32 ghci handy?
17:21:18 <dons> ok, freaky:
17:21:19 <dons> Prelude> (-2147483648::Int) `div` (-1::Int)
17:21:19 <dons> zsh: floating point exception (core dumped)  ghci -v0
17:21:25 <dons> > (-2147483648::Int) `div` (-1::Int)
17:21:26 <lambdabot> Terminated
17:21:54 <Excedrin> zsh: floating point exception  ghci -v0 -fglasgow-exts
17:22:04 <Stinger_> > - (-2147483648::Int)
17:22:05 <lambdabot>  -2147483648
17:22:14 <Stinger_> wait what?
17:22:19 <Stinger_> oh no thats right, carry on
17:22:20 <dons> hugs says, Unexpected signal
17:22:36 <Stinger_> well, thats "right"
17:22:39 <jlouis> dons, uh, oh. Problem report into trac ;)
17:22:54 <dons> jlouis: I think so.
17:23:11 <jlouis> hmm, why are we hit with an FP-exn?
17:23:16 <Excedrin> +++ killed by SIGFPE +++
17:23:38 <sorear> jlouis: see the IA32 manual
17:23:41 <dons> what does the equivalent C program do?
17:23:52 <sorear> interrupt 0 signals DIVIDE ERROR, #DE
17:24:02 <dons> @seen lennart
17:24:03 <lambdabot> I saw lennart leaving #haskell 12d 2h 22m 46s ago, and .
17:24:26 <sorear> that occurs when (a) attempt to divide by 0 (b) attempt to produce a result that does not fit in the destination type
17:24:31 <sorear> you're seeing (b)
17:24:42 <sorear> it is mapped to SIGFPE by linux
17:24:48 <Excedrin> ./div
17:24:49 <Excedrin> 0
17:25:30 <jlouis> sorear, Ah, I've never dabbled much into IA32
17:25:42 <dons> anyone got an amd64?
17:25:48 <dons> lispy: around?
17:26:49 <sorear> IA32 division is not friendly - only one register (EBX) can be used as the divisor.
17:26:53 <emu> well, on the bright side, i've reduced GC overhead to 1%
17:27:06 <sorear> AMD64 has the same quirky behaivor in its spec
17:27:18 <sorear> anyone here have a non-Intel mac?
17:27:41 <emu> i have an older Powerbook
17:27:51 <sorear> emu: does it run ghci?
17:28:02 <emu> i only have ghci 6.2 for it, i think
17:28:05 <jlouis> sorear, what is the (b) specifically, that a r1 <- r1 div r2 command was issued and r1 is too small to store the value?
17:28:22 <sorear> that's it, I believe
17:29:04 <sorear> the ia32's DIV instruction (unsigned divide) is 64x32 -> 32, so overflow is a much bigger problem.
17:29:07 <dons> emu: can you launch ghci on the powerpc mac?
17:29:18 <emu> yes
17:29:27 <sorear> IDIV (signed divide) is 64x32->32 or 32x32->32.
17:29:27 <jlouis> sorear, ouch
17:29:31 <emu> i'm pretty sure i've dabbled on it. lemme go get it running
17:30:13 <emu> ghci 6.2.1
17:30:13 <sorear> ?google Intel System Programmer's Manual
17:30:15 <lambdabot> http://www.intel.com/design/pentiumii/manuals/243192.htm
17:30:16 <lambdabot> Title: Intel Architecture Software Developers Manual Volume 3: System Programming
17:30:16 <emu> Prelude > 1 + 1
17:30:16 <emu> 2
17:30:22 <dons> cool
17:30:29 <dons> try (-2147483648::Int) `div` (-1::Int)
17:30:37 <sorear> ah good, remembered enough of the name :)
17:30:37 <emu> OS X 10.3.9
17:30:40 <jlouis> is it a regression? ie, does 6.4 sport the problem?
17:30:55 <jlouis> sorear, oh, cool. I should read it ;)
17:31:11 <emu> 0
17:31:26 <emu> that's minBound right?
17:31:32 <Excedrin> the C program works fine on amd64 too
17:31:53 <jdev> sorear: Huh?  I thought it was  edx:eax `divmod` (r/m32) -> (eax,edx)...
17:32:05 <emu> i haven't been able to install a newer ghc because binaries for my older OS X don't exist
17:32:23 <dons> Excedrin: can you paste the C program?
17:32:23 <jlouis> Excedrin, do you have a GHC on the amdy
17:32:27 <dons> ?paste
17:32:28 <lambdabot> http://paste.lisp.org/new/haskell
17:32:31 <jlouis> would be nice to narrow the bastard down
17:32:34 <sorear> jdev: yes, but nobody uses divmod anymore, so edx is almost always discarded
17:32:53 <dibblego> haddock doesn't like my function (#) - tells me "Parse Error" - am I stuffed?
17:34:03 <Excedrin> oh interesting, -O changes the results
17:34:26 <Jessehk> I'm not a troll, I just want to make an educated decision: What do Haskell people think of O'Caml?
17:34:35 <jlouis> check -ffast-math also ;)
17:34:48 <lisppaste2> Excedrin pasted "C floating point exception" at http://paste.lisp.org/display/31598
17:35:07 <jlouis> Jessehk, having programmed a bit in it before: Cool language.
17:35:10 <Excedrin> it fails without -O, with -O I think it's resolved at compile time
17:35:34 <shankys> Does anyone here know of freely available code online that makes use of the Database.HDBC library online? I've looked around for a while on Google, and can't find anything.
17:35:41 <jlouis> Excedrin, one would think a constant folding was appropriate
17:35:43 <dons> Jessehk: OCaml is like an older, strict version of Haskell, with a goode native codegen, bad smp support, and small community. You should learn both
17:36:44 <dons> its missing many of the innovations added to haskell in the last 10 years
17:37:06 <jlouis> succubus% ./test
17:37:06 <jlouis> zsh: floating point exception  ./test
17:37:06 <emu> so, ixmap, pretty slow hmm
17:37:09 <dons> typeclasses, monads, generalised ADTS, smp runtime, software transactoinal memory
17:37:12 <jlouis> thats Excedrins program
17:37:13 * emu rewrites without ixmap
17:37:14 <jdev> One "exciting" thing about Intel MacOS for would-be language implementers, BTW, is the mandatory 16-byte stack pointer alignment.
17:37:22 <jlouis> gcc version 4.1.2 20061115 (prerelease) (Debian 4.1.1-20)
17:37:37 <sorear> ?!?!
17:37:38 <lambdabot> Unknown command, try @list
17:37:39 <jlouis> (no optimizations)
17:37:47 <Jessehk> dons: Thanks for the tips. Is that "Yet another Haskell tutorial" a good reference? I've been experimenting for a while with O'Caml.
17:37:56 <dons> yeah, YAHT is good
17:37:58 <dons> ?where yaht
17:37:58 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
17:38:19 <dons> Jessehk: you'll want ghc installed
17:38:24 <Jessehk> got it
17:38:26 <Jessehk> and hugs
17:38:29 <dons> I think its quite a reasonable path to learn Haskell after OCaml, in fact.
17:38:36 <jdev> Because, apparentky, there's stuff in libc and friends that uses vector instructions that have alignment requirements.
17:38:38 <dons> since you see how OCaml issues get cleaned up
17:38:46 <dons> (i.e. syntax, typeclasses, side effects)
17:39:14 <mdmkolbe|work> I'm trying to compile pugs and it's giving me this Haskell error "ghc-6.6: unknown package: mtl\n*** Could not load the "mtl" package in your GHC installation.".  I don't have admin access on this machine and and the GHC I'm using was installed by the admins.  So is there some easy way to fix this without having to rebuild GHC?
17:39:28 <sorear> jdev: I thought Intel had (by default) 'soft' alignment (ie performance problems but no errors)?
17:39:35 <dons> mdmkolbe|work: you don't have the ghc extralibs package
17:39:37 <SamB> mdmkolbe|work: tell them to install more packages!
17:39:48 <dons> SamB: try to be helpful :)
17:39:56 <lisppaste2> jlouis annotated #31598 with "assembler trace (4.1.2 20061115 (prerelease) (Debian 4.1.1-20)" at http://paste.lisp.org/display/31598#1
17:40:09 <SamB> mdmkolbe|work: what kind of admins are we talking about?
17:40:17 <dons> mdmkolbe|work: the extralibs package is available from the ghc page, and from your package system
17:40:29 <SamB> dons: he just said he hasn't admin access
17:40:43 <jdev> sorear: It does for the normal stuff, but apparently some of the vector extensions don't do that... I'm not entirely clear on the details.
17:41:20 <dons> mdmkolbe|work: you'll need to install the extralibs packages locally as a user
17:41:26 <dons> (which is ok)
17:41:39 <wolverian> I didn't see an obvious way to compile extralibs separately from ghc.
17:41:59 <mdmkolbe|work> dons: ok, I'm looking at that now (I don't have the sources that the GHC was built from).
17:42:02 <SamB> wolverian: go into the directories and use the ./Setup.hs files?
17:42:19 <jlouis> oh, what a register strained CPU. Major stack galore in that trace
17:42:25 <wolverian> SamB, thanks. :)
17:42:31 <mdmkolbe|work> SamB: This is on a school linux machine which I don't have a root account on.
17:43:00 <jdev> Something interesting for demonstrating subtle differences between Haskell and OCaml: let foo = List.map (fun x -> x) in (foo [2],foo ["bar"]);;
17:44:04 <jdev> > let foo = map (\x -> x) in (foo [2],foo ["bar]") -- this should work, and the OCaml one should fail
17:44:05 <lambdabot>  Parse error
17:44:19 <bd_> map works on pairs? oO
17:44:22 <jdev> Or, you know, if I could type correctly.
17:44:30 <sorear> STUArray's newArray_ breaks referential transparency
17:44:36 <jlouis> bd_, no, notice the in
17:44:46 <Excedrin> it's interesting that it raises that error from idiv
17:44:50 <bd_> oh
17:44:57 <bd_> right
17:45:01 <jdev> > let foo = map (\x -> x) in (foo [2],foo ["bar"])
17:45:02 <lambdabot>  ([2],["bar"])
17:45:56 <mdmkolbe|work> How do I run ./Setup.hs? "ghci Setup.hs"?
17:46:09 <psnl> runhaskell
17:46:10 <Excedrin> runhaskell Setup.hs
17:46:17 <Excedrin> or runghc or runhugs or whatever
17:46:40 * Lemmih votes for 'cabal-setup'
17:48:00 <mdmkolbe|work> Lemmih: I don't see any cabal-setup in my path or in the extralibs.
17:48:16 <dons> mdmkolbe|work: do you have runhaskell in your path?
17:48:20 <jcreigh> jdev: why doesn't the O'Caml version of that work?
17:48:26 <dons> if so, runhaskell Setup.hs configure
17:48:32 <mdmkolbe|work> dons: yes
17:49:29 <jdev> jcreigh: Basically, because the type system doesn't have a way to indicate that partially applying List.map won't be side-effecting.
17:50:47 <jdev> jcreigh: And thus foo can't be polymorphic.  This is called the "value restriction", and that's not really the best example of it.
17:50:55 <mdmkolbe|work> Do I need to specify any flags to "runhaskell Setup.hs configure" to specify that I wan't a user install? prefix? --user?
17:51:03 <dons> yes, --user
17:51:18 <dons> $ runhaskell Setup.lhs configure --help
17:51:32 <dons> you want --user and --prefix=$HOME
17:54:28 <mdmkolbe|work> dons: Cool, it works.  Thanks.
17:55:07 <jdev> jcreigh: Consider, for example,  let fakemap f = let state = ref [] in fun l -> state := (List.map f l) @ !state; !state;; (* note that its type is the same as List.map *)
17:56:36 * jlouis senses the boom! coming from jdev 
17:57:06 <dons> mdmkolbe|work: pugs builds now?
17:57:33 <jlouis> ie, if you use fakemap in the above appliance of (foo [2], foo ["bar"]), what type does the ref-cell inside fakemap have?
18:00:41 <mdmkolbe|work> dons: Well it builds farther than before.  There's now a "Setup: error reading ./.setup-config; run "setup configure" command?" error, but I'm not sure yet whether that is Pugs or Haskell that is the problem.
18:00:44 <cjeris> can anybody remind me how to nudge a serverop?  we have a troll in #math and no chanop handy
18:01:03 <cjeris> troll's the wrong word.  anti-semitic spammer.
18:01:35 <m-hussein> http://www.bbc.co.uk/berkshire/content/articles/2006/12/06/divide_zero_feature.shtml
18:01:36 <lambdabot> Title: BBC - Berkshire - Features - 1200-year-old problem 'easy', http://tinyurl.com/yl47tq
18:01:40 <m-hussein> new groundbreaking theory
18:02:00 <m-hussein> new theory will change everything
18:02:17 <dons> m-hussein: not here thanks.
18:02:20 <Excedrin> cjeris: /stats p
18:02:46 <dons> cjeris: ping nalioth
18:02:57 <cjeris> yeah, this guy.
18:02:58 <mbishop> I thought m-hussein was supposed to be banned still...
18:03:03 --- mode: ChanServ set +o dons
18:03:08 --- mode: dons set +b *!*i=hussein@*.kpylaajakaista.net
18:03:09 --- kick: m-hussein was kicked by dons (stay gone)
18:03:13 --- mode: ChanServ set -o dons
18:03:17 <dons> I unbanned him after 12 hours
18:03:26 <dons> but I probably shouldn't have, since he jumped straight back in
18:03:38 <tom__> hello
18:03:43 * mbishop pets dons
18:03:43 <dons> hey tom__
18:03:47 <dons> learning haskell?
18:03:58 <tom__> well relearning actually :)
18:04:02 <dons> cool :)
18:04:13 <dons> welcome!
18:04:20 <tom__> i wondered how i can define 2 functions in where
18:04:33 <dons> where f x = x
18:04:38 <dons>        g y = y  +1
18:04:45 <tom__> mm ok i got an error
18:04:46 <dons> the 'f' and 'g' shoud line up
18:04:51 <dons> can you paste the code?
18:04:52 <dons> ?paste
18:04:53 <lambdabot> http://paste.lisp.org/new/haskell
18:05:17 <dons> cjeris: problem solved yet?
18:05:34 <tom__> 					 where f [(x,c)] = x
18:05:34 <tom__> 					 	   f y = y
18:05:39 <tom__> like that
18:05:43 <dons> are those tabs I see? :)
18:05:45 <tom__> says parse error on =
18:05:51 <tom__> eh i guess
18:05:56 <dons> looks like the whitespace isn't lining up.
18:06:20 <Stinger_> yeah what are your editor tabs set to? :)
18:06:49 <tom__> ah k
18:06:55 <dons> note that that's a type error too:
18:06:56 <dons>     where f [(x,c)] = x
18:06:56 <dons>           f y       = y
18:06:57 <tom__> i use the eclipse thingy
18:06:58 <tom__> ye
18:07:03 <tom__> i fixed it now
18:07:08 <dons> since it looks like it has type [(a,b)] -> a
18:07:09 <tom__> it was the tab indeed
18:07:22 <dons> by the first line, and on the second line f ::[(a,b)] -> [(a,b)]
18:07:27 <tom__> i have to make a real function of the last line
18:07:31 <tom__> was just for testing
18:07:33 <dons> ah ok
18:07:50 <dons> tabs are signficant whitespace, and assumed to be 8 spaces
18:08:00 <dons> so its better to either only use 8 space tabs, or :set expandtab
18:08:30 <sorear> how badly does haskell break in response to changing pure values?  STUArray and newArray_ do this.
18:09:13 <dons> 'sok if they're not shared. can you be more specific about what you're doing..
18:09:17 <dons> (what's a pure value?)
18:09:23 <jlouis> dons obviously did not mean to type :set expandtab. He rather meant to type (setq indent-tabs-mode nil)
18:09:28 <dons> heh
18:09:38 <tom__> ok
18:09:49 <tom__> damn haskell is hard when you have not touched it in 2 years
18:09:53 <sorear> I've already fired off a message to -cafe@; like tickle::Int
18:10:04 <dons> sorear: you can tickled Ints, that's fine
18:10:09 <dons> well, you shouldn't
18:10:12 <dons> but it can be done
18:10:29 <conal> O
18:10:46 <conal> (oops)
18:10:54 <dons> sorear: but you may run into strange optimisation issues if you start faking side effects as being pure
18:11:02 <dons> (with duplicated effects and so on)
18:11:23 <dons> tom__: we're here to help :)
18:12:36 <conal> i'd like some getting-started help in putting a project on darcs.haskell.org.  i have an account and some darcs experience.   anyone game to help?
18:12:50 <dons> Lemmih: around?
18:12:53 <conal> (i.e., to answer some questions)
18:13:01 <dons> Lemmih's done this a few times. He should be able to hep
18:13:10 <tom__> thats cool dons :)
18:13:14 <tom__> but its homework ;/
18:13:21 <dons> ah good. :)
18:13:32 <tom__> im writing a parser combinator
18:14:31 <Lemmih> I'm here and ready to hep! hep hep hurrah!
18:14:48 <dons> Lemmih is a hep-cat
18:14:49 <jlouis> heh
18:14:51 <LoganCapaldo> hep, hep hurrah
18:15:04 <LoganCapaldo> Hepping people hep themselves
18:15:05 <dons> Cale: I think cjeris was looking for an op in #math
18:15:05 <conal> do people ftp their repos to darcs.haskell.org, or "darcs push" them, or what?  also, does the server have darcsweb?
18:15:27 <Lemmih> conal: I use 'darcs put'.
18:15:42 <Lemmih> (pushing via ssh)
18:16:32 <conal> lemmih: oho.  and do you first 'darcs init' on the server?
18:17:34 <tom__> only a tiny thingy to go and im done for today
18:17:35 <Lemmih> conal: No need. Create the repo locally, 'darcs put' it and then update it with 'darcs push'.
18:18:29 <conal> lemmih: very simple.  i'll give it a try.  thanks much.  :)
18:18:58 <dons> Lemmih++ I always forget darcs put
18:19:18 <conal> lemmih: 'darcs push' is daan's darcs-server, right?
18:19:25 <dons> kfish: heya, any new project releases today?
18:19:35 <dons> conal: don't think so
18:19:46 <dons> $ darcs push --help
18:19:46 <dons> Usage: darcs push [OPTION]... [REPOSITORY]
18:19:51 <kfish> dons:  maybe tonight ;-)
18:19:54 <dons> Push is the opposite of pull.
18:19:57 <dons> kfish: good good.
18:20:57 <SamB> dons: what do I need to do to do a release?
18:21:03 <tom__> is there a trim function in haskell?
18:21:19 <dons> SamB: you surely know by now.
18:21:21 <dons> tom__: for whitespace?
18:21:24 <tom__> ye
18:21:36 <conal> lemih: one more question: does darcs.haskell.org have darcsweb?  nice for perusing darcs histories.
18:21:39 <SamB> dons: why the hell would I know a fool thing like that?
18:21:50 <dons> > let trim = let g = reverse . dropWhile isSpace in g . g in trim "    some    string   "
18:21:51 <SamB> I always use darcs
18:21:52 <lambdabot>  "some    string"
18:21:59 <jlouis> dons, ah, the classic
18:22:00 <Lemmih> conal: Not to my knowledge, no.
18:22:06 <tom__> i see ok~
18:22:19 <dons> ?let trim = let g = reverse . dropWhile isSpace in g . g
18:22:19 <SamB> well, I suppose the first thing is to get someone to betatest my program!
18:22:20 <lambdabot> Defined.
18:22:22 <Lemmih> conal: We could probably get them to install it, though.
18:22:27 <SamB> or alpha!
18:22:29 <tom__> i only need the first spaces
18:22:30 <dons> > L.trim "    some    string    "
18:22:32 <lambdabot>  "some    string"
18:22:36 <tom__> so i can do dropWhile isSpace
18:22:39 <tom__> i think
18:22:40 <dons> yup
18:22:44 <Lemmih> @seen SyntaxNinja
18:22:45 <lambdabot> SyntaxNinja is in #haskell, #darcs and #haskell-blah. I last heard SyntaxNinja speak 8h 52m 53s ago.
18:22:48 <tom__> ok thanks
18:22:57 <conal> lemmih: it's simple.  i may ask for it or volunteer to give it a whack myself.  i've set it up on my own server.
18:23:37 <dons> SamB: follow the 'How to write a Haskell program' guide...
18:23:49 <SamB> but I already have a program
18:23:57 <dons> sometimes I think SamB plays silly games
18:24:03 <SamB> @google "How to write a Haskell program"
18:24:06 <lambdabot> http://haskell.org/haskellwiki/How_to_write_a_Haskell_program
18:24:06 <lambdabot> Title: How to write a Haskell program - HaskellWiki
18:24:24 <SamB> sometimes I forget things, you know
18:24:42 <SamB> and sometimes I don't hear about them at all!
18:24:44 <dons> that's not allowed!
18:24:55 <SamB> WTH do you think @where is for
18:24:57 <dons> I demand HWN injections into the spine!
18:25:14 <SamB> ... I doubt it would owrk
18:25:16 <SamB> work
18:26:06 <jlouis> all haskell programmers are spineless
18:26:12 <jlouis> at least the GHC ones
18:26:17 <dons> except for nhc
18:26:46 <sorear> ?google Putting the Spine back in the Spineless Tagless G-Machine
18:26:49 <lambdabot> http://citeseer.ist.psu.edu/reid98putting.html
18:26:50 <lambdabot> Title: Putting the Spine back in the Spineless Tagless G-Machine: An Implementation of  ...
18:27:04 <sorear> forgot why they did it, but they did.
18:27:35 <mattrepl> is there a way to use the Bool in (IO Bool) in a guard?   and/or is that bad style?
18:27:39 <jlouis> on the "to read" list with that
18:27:57 <kfish> dons: what does the word "tag" refer to in the Releases section of How_to_write_a_Haskell_program? tagging a tarball (project-x.y.z.tar.gz) or "darcs tag" or both? it seems to be used in two different ways
18:28:16 <dons> ah, so tag is to take the branch in the repository
18:28:17 <SamB> why would I have a license file?
18:28:29 <dons> and then you create a tarball to sell
18:28:34 <tom__> mm haskell is being stupid
18:28:36 <SamB> can't cabal just look up the license in its records?
18:28:38 <tom__> my type definition fails
18:28:39 <kfish> dons: so "darcs tag"
18:28:47 <tom__> while it infact is correct i thinkl
18:28:50 <tom__> *think
18:28:54 <dons> darcs tag will tag the current state as a branch, yep
18:29:01 <dons> ?paste tom__
18:29:01 <lambdabot> http://paste.lisp.org/new/haskell
18:29:26 <dons> kfish: and then people can darcs pull --partial, to get just the tagged version (and not the entire history)
18:29:50 <sorear> dons: don't you need darcs optimize checkpoint for that?
18:29:53 * Lemmih has written eight conjure patches today and is quite proud (:
18:29:59 <dons> sorear: after the tag :)
18:30:02 <Lemmih> Good night, #haskell.
18:30:10 <dons> Lemmih++ patch-a-riffic!
18:30:34 --- mode: ChanServ set +o dons
18:30:37 --- mode: dons set -b *!*n=bill@4.38.41.*
18:30:39 --- mode: ChanServ set -o dons
18:30:47 <dons> (cleaning up the block list)
18:30:57 <jcreigh> dons: when you do "foo++ something here", does lambdabot record "something here" somewhere?
18:31:00 <lisppaste2> t pasted "t" at http://paste.lisp.org/display/31604
18:31:06 <dons> jcreigh: nope
18:31:10 <dons> make a nice patch though
18:31:11 <jlouis> mattrepl, that would probably be a bad thing to allow: f = do { putStrLn "Foo" ; return False }. Now assume we could have g x | f. The side-effect of printing would be evil
18:31:19 <tom__> dons: t would be mine :)
18:31:25 <dons> looking...
18:31:38 <dons> tom__: what's the error though?
18:31:41 <dons> you should include that
18:32:13 <mattrepl> jlouis, makes sense.
18:32:32 <lisppaste2> tom__ pasted "error" at http://paste.lisp.org/display/31605
18:32:42 <tom__> there dons
18:32:56 <jlouis> mattrepl, in general, the problem is that as soon you have something inside IO, all kinds of sideffects are allowed before returning
18:33:22 <dons> tom__: the recursive call to  lexicalScanner (dropWhile isSpace c) returns a Parser Char [Token]
18:33:28 <jlouis> whereas in a do t_val <- f, you explicitly force the evaluation
18:33:28 <lisppaste2> mattrepl pasted "Monads in guards" at http://paste.lisp.org/display/31606
18:33:31 <dons> but you use it like a list, :(g (parseToken (dropWhile isSpace a)))
18:33:32 <kfish> dons: ah, you use "darcs dist" not "./Setup.hs dist" -- I was going to ask how to include TODO etc. in the tarball, I guess that's how ;-)
18:33:42 <dons> kfish: yeah, either is ok
18:33:45 <mattrepl> that's what I was going for, checking for file existence in a guard
18:33:47 <tom__> dons: ye cause on the end it will be a list :)
18:33:48 <dons> ./Setup.hs sdist -- I think
18:34:01 <dons> tom__: don't you need to extract the list from the parser first?
18:34:12 <tom__> mm i guess i can do that
18:34:24 <dons> i.e. do ls <- g (parseToken (dropWhile isSpace a)) ; return ... : ls
18:34:31 <dons> (is it in a monad?)
18:34:39 <kfish> dons: yeah, that's what I've been using, but I don't think Cabal has a way to specify extra files to include in the distribution
18:34:50 <dons> yeah, extra-files: Foo ( I think )
18:34:54 <dons> but darcs dist is probably easier
18:35:19 <dons> for hackage though, we'll need to ensure Setup.hs dist works
18:35:30 <tom__> mm
18:35:34 <tom__> thats to hard for me ;p
18:35:51 <tom__> and my teachers only like pure haskell recursive shit
18:35:54 <dons> tom__: I don't see why it has type Parser char Token
18:36:05 <dons> it looks like its just [Token]
18:36:11 <dons> (and you code like it is)
18:36:24 <dons> could your type be wrong?
18:36:34 <dons> ah, I see. parseToken :: Parser char Token
18:36:57 <tom__> ye
18:37:29 <dons> you see the problem now, right?
18:37:34 <dons> the use of : g ...
18:37:40 <dons> looks like g :: [Token]
18:37:58 <tom__> g is a [Token] ye
18:38:01 <tom__> should be
18:38:06 <dons> heya mnislaih
18:38:13 <dons> afternoon greentea
18:38:32 <tom__> shouldnt haskell detect it that on the end it will be an empty list?
18:38:57 <greentea> Hey dons.
18:38:59 <SamB> @doc Control.Monad.State
18:39:00 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-State.html
18:39:04 <SamB> hmm.
18:39:16 <dons> tom__: nope. that's no tthe issue. you're using (:) on something that isn't a list
18:39:20 <dons> ?type (:)
18:39:22 <lambdabot> forall a. a -> [a] -> [a]
18:39:29 <SamB> so why doesn't a Cabal build find it? oh, right, gotta reconfigure...
18:39:31 <dons> takes a token, and a [token], and produces a new list
18:39:47 <tom__> ye but if i remove the type definition my code works
18:39:51 <tom__> so i dont see why it fails
18:39:58 <dons> good. so your old type def is wrong :)
18:40:11 <tom__> it should be that type definition :)
18:40:20 <SamB> @doc System
18:40:21 <lambdabot> System not available
18:40:29 <dons> its probably something like [Parser char Token] now though..
18:40:32 <SamB> oh?
18:40:35 <SamB> @hoogle System
18:40:36 <lambdabot> System :: module
18:40:36 <lambdabot> System.system :: String -> IO ExitCode
18:40:36 <lambdabot> System.Win32.Info.SystemColor :: type SystemColor
18:40:46 <SamB> that doesn't look too unavailable to me!
18:40:59 <tom__> mm
18:41:23 <tom__> g should be a list right?
18:41:27 <tom__> or is it no list?
18:41:48 <dons> tom__: it should be a list I think, but you call lexer* there, which doesn't have a list type.
18:42:00 <dons> (at least, when you say it has type Parser char [Token])
18:42:32 <tom__> the result of it is a [token] right
18:42:47 <tom__> so that should work
18:43:17 * SamB really ought to pull the Gtk stuff out of ZMachine.Startup
18:44:55 <dons> @tell sorear newArray_ is supposed to not initalise things...
18:44:55 <lambdabot> Consider it noted.
18:45:46 * jlouis jumps to bed
18:46:07 <tom__> well time to sleep
18:46:16 <tom__> its late as hell
18:46:22 <tom__> thanks for the help
18:46:24 <tom__> later
18:46:57 <cjeris> grr why i so stupid
18:47:14 <dons> cjeris: you solved your troll issue?
18:47:28 <cjeris> dons: yes, Cale kindly intervened.
18:47:38 <dons> good
18:47:40 <cjeris> thanks for sending him my way.
18:49:17 <SamB> oh, nuts. Cabal doesn't support different executables having different dependencies.
18:49:21 <SamB> :-(.
18:49:51 <SamB> dons: can you make a nice curses frontend for ZMachine?
18:49:57 <dons> nope.
18:50:05 <dons> its pretty easy though: take hmp3's and go nuts
18:50:12 <shapr> troll?
18:50:17 <SamB> well, the trouble is I'm already nuts.
18:50:21 <shapr> oh
18:50:25 <dons> shapr: guys in #math and here
18:50:30 <dons> s/s//
18:51:41 <shapr> dons: How long till the SMP-out machine is ready? :-)
18:51:48 <emu> ok, much better off with an array-of-IntMaps than the matrix :/
18:52:24 <dons> shapr: its ordered. hope it arrives before xmas. they have to build it though
18:52:39 <shapr> I like building machines myself.
18:52:59 * SamB feels so happy having, like, only about one module at the top and one module at the bottom of his program where the specific UI and the rest of the program actually come in contact
18:53:23 <chessguy> ok, guys i have a master plan
18:53:47 <kfish> dons, sorear: [I'm editing the wiki] -- after tagging, is "darcs optimize checkpoint" required for "darcs pull --partial" to work?
18:53:53 <shapr> Is there some sort of datastructe in Data.Time.Calendar that I could use to make a web calendar?
18:53:53 <chessguy> i got a job offer as a peon in a fast-growing perl shop today.
18:53:58 <SamB> see, the one module does nothing but define a datatype for instructions to the UI
18:54:07 <SamB> the other one just starts the program ;-)
18:54:09 <chessguy> now i just have to rewrite all their stuff in haskell and prove to them how much superior it is.
18:54:15 <shapr> heh
18:54:49 <dons> kfish: after tagging, darcs optimize --checkpoint
18:55:05 <kfish> dons: yes, if you don't do that, does "darcs pull --partial" still work?
18:55:08 <dons> shapr: hmm. there's CalendarTime
18:55:12 <chessguy> then they'll grow even faster and dominate the industry, and people will have to acknowledge the greatness of haskell
18:55:14 <dons> kfish: it should
18:55:22 <kfish> dons: cheers
18:55:29 <SamB> kfish: there is some debate about whether or not darcs get --partial works *at all*
18:56:32 <kfish> SamB, ah ok, I'll leave that for the astrophysicists
18:56:55 <SamB> I meant, it has a lot of obscure bugs
18:57:16 <SamB> which are rather nasty if you run into them
18:57:34 <SamB> I haven't quite lost patches to it, though
18:59:41 <Excedrin> chessguy: can you typically write short programs in Haskell as quickly as you could in Perl? I cleaned up a co-worker's Perl script today by removing 50 lines and improving the runtime from 3 seconds to 0.13s, but I don't think I'd be able to write it in Haskell as easily (it's a simple program, I'm just not that comfortable with Haskell yet)
18:59:47 <dons> so i'm not sure there are a lot of bugs. one or two anywya. on windows
19:00:16 <dons> Excedrin: depends. I often end up with very short scripts in haskell, using interact
19:00:22 <dons> ?google simple unix tools
19:00:24 <lambdabot> http://haskell.org/haskellwiki/Simple_unix_tools
19:00:25 <lambdabot> Title: Simple unix tools - HaskellWiki
19:00:31 <dons> hehe nice hit
19:00:56 <dons> Excedrin: just practice and knowing your Data.List and System.IO
19:01:02 <dons> (and GetOpt)
19:01:34 <Excedrin> dons: I was curious about chessguy's Perl/Haskell experience wrt his potential job... I'm sure that an equivalent Haskell program could be similar length and probably faster
19:02:03 <dons> I think that's reasonable yes. Similar length, but probably faster and more robust
19:02:12 <dons> since you'll tend to use less partial functions
19:05:25 <SamB> okay, I need someone to try out ZMachine and tell me that I need a newer version of gtk2hs...
19:05:46 <dons> SamB: one good way is to announce it, with steps for running it
19:05:50 <dons> then you'll get feedback
19:06:30 <SamB> @where ZMachine
19:06:31 <lambdabot> http://naesten.dyndns.org:8080/repos/ZMachine
19:06:35 <SamB> darcs get that
19:07:06 <dons> wow
19:07:15 <dons> ?remember NormanRamsey Type annotations in OCaml are completely broken and always have been.
19:07:30 <dons> "They use 'unifies with' instead of 'is an instance of' and it renders
19:07:31 <dons> type annotations nearly useless.  If you want to ensure that a
19:07:31 <dons> function is polymorphic, you have to play horrible games with
19:07:31 <dons> uninhabited types.  I am extremely bitter about this.
19:07:31 <dons> "
19:07:32 <SamB> then chmod +x Cabal.lhs && ./Cabal.lhs configure && ./Cabal.lhs build && ./Cabal.lhs install
19:08:45 <SamB> oh, then zmachine some-work-of-IF.z5
19:09:02 <conal> lemmih: does this look right to you: "darcs put conal@darcs.haskell.org:/home/darcs/phooey"?  i'm getting nasty error messages on my end.  i am able to "ssh conal@darcs.haskell.org" fine.
19:09:19 <dons> conal: what error?
19:09:53 <dons> darcs put conal@darcs.haskell.org:/home/darcs/phooey --- looks right
19:10:06 <conal> i get:
19:10:06 <conal> $ darcs put conal@darcs.haskell.org:/home/darcs/phooey
19:10:06 <conal> Invalid multiplex command.
19:10:06 <conal> ssh_control_listener bind(): Bad file descriptor
19:10:06 <conal> ssh_control_listener bind(): Bad file descriptor
19:10:06 <conal> ssh: connect to host darcs.haskell.org port 22: Operation not permitted
19:10:08 <conal> Control socket connect(/tmp//darcs-ssh/conal@darcs.haskell.org): No such file or directory
19:10:10 <conal> Control socket connect(/tmp//darcs-ssh/conal@darcs.haskell.org): No such file or directory
19:10:22 <dons> huh
19:11:19 <aFlag> How do I write something on the screen with Hopengl? Simple using renderString doesn't seem to work
19:11:27 <dons> is darcs calling ssh with the wrong flags here, conal?
19:11:38 <dons> aFlag: you might need to ask on haskell-cafe@
19:11:45 <dons> since not many here seem to use hopengl
19:12:01 <protoscript> hello gentlemen
19:12:14 <conal> dons: i sure don't know.  maybe there's a verbosity flag i can use
19:12:16 <aFlag> yeah, but I'm always hoping someone will save me :P
19:12:17 <protoscript> Does anyone know of a practical use for the id function?
19:12:25 <dons> protoscript: yee!
19:12:33 <dons> :t Data.Maybe.maybe
19:12:35 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
19:12:35 <bd_> sequence = mapM id
19:12:56 <dons> > maybe 7 id (Just 2)
19:12:57 <lambdabot>  2
19:13:00 <dons> > maybe 7 id Nothing
19:13:02 <lambdabot>  7
19:13:17 <dons> --
19:13:17 <dons> -- The 'cat' program
19:13:17 <dons> --
19:13:18 <dons> cat     = interact id
19:13:36 <bd_> :t interact
19:13:37 <lambdabot> (String -> String) -> IO ()
19:13:42 <bd_> nice!
19:13:42 <dons> protoscript: lots of uses. its the function equivalent of 0 :)
19:14:02 <dons> bd_, most of the unix shell tools are one liners with interact, http://haskell.org/haskellwiki/Simple_unix_tools
19:14:03 <lambdabot> Title: Simple unix tools - HaskellWiki
19:14:08 <protoscript> I knew there must be many.. Just having trouble seeing why
19:14:15 <dons> wc_c    = interact (showln . length)
19:14:24 <bd_> :t nub
19:14:25 <lambdabot> forall a. (Eq a) => [a] -> [a]
19:14:29 <bd_> hmm
19:14:32 <dons> protoscript: learn to love id. its very handy
19:14:36 <bd_> :t io
19:14:37 <lambdabot> Not in scope: `io'
19:14:45 <bd_> @hoogle io
19:14:46 <lambdabot> Data.Array.IO :: module
19:14:46 <lambdabot> IO :: module
19:14:46 <lambdabot> System.IO :: module
19:14:50 <bd_> hmm
19:14:53 <dons> protoscript: for a default function to pass to higher order functions, ultimately
19:14:57 <bd_> uniq    = io nub <-- what module is this in?
19:15:02 <bd_> System.IO?
19:15:03 <dons> bd_: io f    = interact (unlines . f . lines)
19:15:06 <conal> lemmih/dons: with --verbose, i get this message also.  btw, my local machine is winxp.
19:15:06 <conal> darcs failed:  Patch bundle failed hash!
19:15:06 <conal> This probably means that the patch has been corrupted by a mailer.
19:15:06 <conal> The most likely culprit is CRLF newlines.
19:15:10 <bd_> d'oh >.<
19:15:15 <dons> conal: ok .freaky
19:15:19 <protoscript> that's what I wAs thinking... i guess  you have to pass something
19:15:26 <protoscript> but have nothing useful for a map
19:15:26 <dons> conal: i'm guessing win32/darcs/ssh/ interaction of some evil kind
19:15:44 <dons> conal: you might want to try scp'ing the repo, or darcs pulling?
19:16:02 <Cale> "the mechanism that allows this quality is not referential transparency itself, but the lack of dependencies of a function from the outside world"
19:16:02 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
19:16:34 <dons> Cale: oh man
19:16:43 <dons> :t all
19:16:44 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
19:16:49 <dons> protoscript: how's this:
19:16:55 <dons> > all id [True,False, True,False]
19:16:57 <lambdabot>  False
19:17:04 <dons> > all id [True,True, True,True]
19:17:06 <lambdabot>  True
19:17:18 <dons> (again, as a default arg for higher order functions)
19:17:38 <dons> $ cd lambdabot
19:17:38 <dons> $ grep ' id ' * */* | wc  -l
19:17:38 <dons>       21
19:17:39 <conal> dons: i'll try some experiments.  thanks.
19:19:24 <dons> ther's an interesting stat, one article with overal up mods of 246 pts on reddit, is woth 100 karma pts
19:19:35 <dons> and typo typo typo
19:21:11 <Excedrin> how much karma is an article with 0 points worth? :( http://programming.reddit.com/info/tqjy/comments
19:21:13 <lambdabot> Title: OpenPKG Russian Roulette (reddit.com)
19:21:38 <dons> I think you get 1 point for submitting for the first time.
19:22:19 <Excedrin> maybe I should have titled that article, "Santa's got a gun and it's written in sh!"
19:22:29 <dons> hehe
19:22:46 <SamB> put that thing down!
19:22:49 <Excedrin> maybe more exclamation points translates to higher upvotes
19:22:54 <SamB> you might hurt somebody with that thing!
19:22:54 * monochrom puts that thing down
19:22:55 <dons> nah.
19:23:10 <dons> Excedrin: its not very programming related
19:23:26 <dons> (none of these calendar posts did well)
19:23:58 <Excedrin> calendar posts?
19:24:09 <SamB> yes
19:24:09 <dons> now, who wants to write a tutorial on smp parallel, STM-based web servers in haskell?
19:24:13 <dons> that'd get a few upmods
19:24:15 <SamB> it is a new way to track time
19:24:34 <SamB> you pound them into the ground and scratch things on the side with a knife!
19:25:14 <shapr> dons: Sounds like fun to me. Won't be interesting unless there's a way to profile it on a system with four or more cores total.
19:25:21 <monochrom> If I forkIO, will it map to an independent processor?
19:25:36 <shapr> That's the sort of questions the tutorial should answer.
19:25:38 <bd_> monochrom: depends on if you're using the SMP runtime and have given it multiple OS threads
19:25:53 <monochrom> Ah.
19:26:05 <bd_> ghc has a many-to-many mapping of haskell to OS threads
19:26:29 <bd_> so you can have, say, 2 OS threads and 7 Haskell threads
19:26:31 <SamB> well, many-to-one at any given time
19:26:40 <monochrom> I don't need to forkOS?
19:26:43 <bd_> monochrom: http://haskell.org/ghc/docs/latest/html/users_guide/sec-using-smp.html
19:26:45 <lambdabot> Title: 4.12. Using SMP parallelism, http://tinyurl.com/yxshax
19:26:49 <bd_> SamB: true, but they can migrate
19:26:57 <SamB> bd_: of course ;-)
19:27:17 <bd_> monochrom: I think you still need to forkOS...
19:27:47 <bd_> since otherwise you may migrate between processors
19:29:27 <dons> shapr: yeah, so I think I'll write a demo for the monad.reader over xmas
19:29:42 <dons> i've not written a webserver, but i guess it isn't too hard :)
19:29:54 <dons> monochrom: you don't need forkOS
19:30:01 * SamB tries testing with a newer gtk2hs himself
19:30:06 <dons> you can just use forkIO, or `par` , or DPH arrays now
19:30:09 <monochrom> Nice.
19:30:14 <dons> and the smp runtime will schedule them on as many cores as you want
19:30:20 <dons> ./a.out +RTS -N 4
19:30:22 <bd_> dons: even if a foreign call blocks?
19:30:22 <dons> for example
19:30:26 <dons> will use 4 cores
19:30:36 <shapr> dons: w00!
19:30:36 <dons> bd_, yep, since you have the IO manager thread for foreign blocking calls
19:30:48 <dons> shapr: so maybe i'll take SimonM's original web server
19:30:54 <dons> and tune it up for smp + STM + bytestrings
19:31:04 <bd_> dons: wouldn't that mean that if you run a foreign blocking call, you'll be unable to receive any other IO wakeups in the meantime?
19:31:23 <emu> pretty impressed how well it's doing with DiffArrays and ST
19:31:38 <dons> bd_, I'm pretty sure that's not the case. check the details in the FFI spec
19:32:14 <emu> i dont think a C implementation could do much better
19:32:16 <bd_> ah
19:32:17 <bd_> http://www.nabble.com/Unbound-threads-and-FFI-t741787.html
19:32:19 <lambdabot> Title: Nabble - Unbound threads and FFI
19:33:33 <dons> shapr: people have dual core mac laptops
19:33:37 <dons> hands up if you've got one!
19:33:46 <dons> shapr: so that's an interresting start...
19:34:10 * monochrom conceives the image of roaming laptop web servers
19:34:11 <bd_> I've got a dual-core non-mac laptop >.>
19:34:18 <dons> bd_ oh?
19:34:32 <bd_> yeah, Presario V6000z, turion x2
19:34:37 <bd_> wireless interface is crap though :/
19:34:45 <shapr> dons: true
19:34:46 <dons> still, 2 cores is good
19:34:49 * bd_ nods
19:35:00 <dons> you throw `par` around in your haskell code then?
19:35:04 <dons> (if not, you should!)
19:35:12 <dons> ?hoogle par
19:35:12 <lambdabot> Control.Parallel.par :: a -> b -> b
19:35:13 <lambdabot> List.partition :: (a -> Bool) -> [a] -> ([a], [a])
19:35:13 <lambdabot> Data.IntMap.partition :: (a -> Bool) -> IntMap a -> (IntMap a, IntMap a)
19:35:14 <bd_> I ... mostly do haskell stuff on my other single-core machine -_-
19:35:29 <bd_> I haven't quite managed to get my drivers working properly under linux yet on the laptop :/
19:35:41 <bd_> so I ssh in to my linux box to get real work done
19:36:29 <emu> if you use `par` and, what was it, -threaded? it will start making use of other cores? ghc 6.6
19:36:44 <SamB> you might have to pass in an RTS flag too
19:36:49 <lisppaste2> dibblego pasted "Can this be written betterer?" at http://paste.lisp.org/display/31615
19:36:50 <bd_> emu: yeah, it puts the first argument on a queue for reduction when there's an idle OS thread
19:36:57 <bd_> er yes
19:36:59 <bd_> compile with -smp
19:37:05 <bd_> and run with +RTS -N<number of threads>
19:37:22 <emu> hmm, gonna try that on a xeon dual core
19:37:27 <dons> emu, yes. -threaded + par
19:37:29 <emu> i guess -N is best at number of cores?
19:37:36 <bd_> yep
19:37:40 <dons> or -thread + forkIO
19:37:44 <dons> -threaded
19:37:51 <dons> -smp is subsumed by -threaded now
19:37:54 <SamB> so `par` doesn't use forkIO?
19:37:57 <emu> forkIO now does system threads?
19:38:05 <SamB> emu: no!
19:38:07 <emu> (w/switch)
19:38:11 <SamB> but the schedular DOES
19:38:14 <bd_> dons: you need to pass +RTS -N<x> still, right?
19:38:15 <dons> emu, it maps haskell threads to -N OS threads
19:38:21 <dons> bd_ yep
19:38:25 <emu> i see
19:38:33 <dons> here, I paralellised quickcheck last week: http://www.cse.unsw.edu.au/~dons/pqc.html
19:38:33 <lambdabot> Title: PQC : (SMP) Parallel QuickCheck
19:38:38 <dons> so it runs on multiple cores
19:38:38 <bd_> any affinity?
19:38:44 <emu> yea i wanted to check that out and forgot
19:39:12 <SamB> bd_: are you afraid it will tear the heap to pieces?
19:39:26 <bd_> SamB: nah, more wondering how well it does with cpu cache, etc
19:39:34 <bd_> though with dual-core I suppose it's not such a big deal
19:39:36 <SamB> bd_: that is what I meant
19:39:50 <dons> for details: http://www.haskell.org/~simonmar/papers/multiproc.pdf
19:39:50 <dons> Haskell on a Shared-Memory Multiprocessor
19:39:51 <dons>     Tim Harris, Simon Marlow, Simon Peyton Jones)
19:40:02 <SamB> you know, playing tug of war with caching of heap pages ;-)
19:40:09 <dons> for the smp on really big machines (2M $ 40-core sparcs ---
19:40:10 <dons> Data Parallel Haskell: a status report
19:40:11 <dons>     Manuel M. T. Chakravarty, Roman Leshchinskiy, Simon Peyton Jones, Gabriele Keller, and Simon Marlow, 2006.
19:40:13 <bd_> yeah, I read that yesterday, was interesting :)
19:40:15 <dons> http://www.cse.unsw.edu.au/~chak/papers/CLPKM06.html
19:40:16 <lambdabot> Title: Research Papers of Manuel Chakravarty
19:40:19 <SamB> includin stack page as a special case
19:40:47 <SamB> how are dependant types -- er, I mean associated types -- coming along?
19:40:54 <dons> its kinda weird how 40 core hardly seems that big now...
19:41:02 <dons> SamB: I see patches going in today
19:41:16 <SamB> dons: considering I still have a PII 450, that sounds a bit big to me
19:41:29 <SamB> but not exactly surprising
19:41:30 <dons> well, there's probably 10 people in here with dual core laptops
19:41:41 <dons> and another 50 with access to quad core servers
19:41:57 <SamB> I have access to a 2 CPU server. does that count for anything?
19:41:58 <dons> and you can get a 16 core mips for 3k, a 16 core amd64 for 30k
19:42:01 <dons> hooray!
19:42:17 <lisppaste2> monochrom annotated #31615 with "consider this" at http://paste.lisp.org/display/31615#1
19:42:43 <SamB> I've had it ever since I complained about how long it took to build GHC when I was actually working on those patches for the inliner
19:42:54 <SamB> I still haven't gotten them working nicely
19:43:25 <dons> SamB: http://cgi.cse.unsw.edu.au/~dons/blog/2006/12/05#build_ghc_faster
19:43:25 <lambdabot> Title: Haskell, hacking and other stuff
19:43:40 <SamB> dons: I really think it helps to have a nice CPU!
19:43:46 <dons> yeah :)
19:43:59 <SamB> a PII 450 doesn't build GHC fast no matter how you slice it
19:44:20 <dons> tell santa you want more cores for christmas
19:44:33 <SamB> @seen santa
19:44:34 <lambdabot> I haven't seen santa.
19:44:44 <SamB> well, see, lambdabot hasn't seen santa
19:44:48 <emu> if you did something like: map (\x -> let v = f x in v `par` v), would it think about running f x on different threads?
19:45:05 <SamB> @tell santa I want a better computer (with more CPU!)
19:45:06 <lambdabot> Consider it noted.
19:45:16 <bd_> emu: x `par` x isn't useful, since it'll immediately evaluate x in the same thread anyway
19:45:22 <bd_> there's a module for what you want though
19:45:32 <dons> Control.Parallel.Strategies
19:45:39 <dons> (or use proper data parallel arrays)
19:45:44 <dons> ?where dph
19:45:44 <bd_> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Parallel-Strategies.html#v%3AparMap
19:45:44 <lambdabot> http://haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
19:45:46 <lambdabot> http://tinyurl.com/y5omnd
19:46:14 <SamB> emu: try foldr1 par!
19:46:17 <emu> yea i saw that, pretty cool stuf
19:46:21 <emu> hehe
19:46:30 <SamB> I bet it works better than that map
19:46:36 <Cale> http://cale.yi.org/index.php/Open_letter_to_James_Anderson
19:46:38 <lambdabot> Title: Open letter to James Anderson - CaleWiki
19:46:45 <SamB> though of course it only works if there is something in the list
19:47:02 <emu> won't that just return the first item, and schedule everything else?
19:47:04 <monochrom> Cale has a wiki?!
19:47:11 <Cale> yes
19:47:14 <SamB> emu: well, isn't that better than doing nothing?
19:47:18 <dons> Cale: without reading that, is James Anderson who I think he is?
19:47:19 <bd_> emu: folrd1 par l `seq` l
19:47:21 <dons> ah yes. :)
19:47:22 <bd_> :)
19:47:28 * monochrom heads over to edit Cale's wiki
19:47:32 <bd_> or even foldr1 par l `par` l
19:47:46 <SamB> but [] is its bane, of course
19:47:58 <dons> Cale: reddit'd it? or would you like me to?
19:48:18 <dons> (why should Mark Carrol have all the fun?)
19:48:19 <Cale> Actually, that's a good idea, I'll do it.
19:48:21 <emu> []: apply directly to the head
19:48:29 <dons> Cale: notice the top link on reddit.com atm
19:48:40 <dons> Cale: and use nullity and math in the title
19:48:48 <dons> since people won't remember who James Anderson is :)
19:50:27 <Excedrin> the wikipedia link about 0^0 doesn't mention that 0^n = 0 for n>0
19:50:49 <Excedrin> I replied on reddit
19:50:53 <Cale> yeah, well, that's true, but 0^0 = 1 regardless :)
19:51:16 <Cale> replied where?
19:51:17 <Excedrin> that's not correct
19:51:21 <chessguy> hey Cale, have you heard my master plan?
19:51:23 <SamB> Cale: who sez?
19:51:31 <SamB> some say 0^0 = your mother
19:51:33 <Cale> SamB: almost everyone :)
19:51:38 <Cale> > 0^0
19:51:39 <lambdabot>  1
19:51:42 <SamB> i.e. is undefined
19:51:44 <Excedrin> 0^0 = undefined
19:51:44 <Cale> Thus spake Haskell
19:51:52 <SamB> Haskell is naive
19:51:54 <SamB> maybe
19:52:01 <Cale> undefined isn't a value in mathematics
19:52:05 <Cale> You can't say that 0
19:52:06 <SamB> true!
19:52:13 <Cale> that 0^0 = undefined
19:52:20 <dons> http://programming.reddit.com/info/u2jy/comments
19:52:22 <lambdabot> Title: An open letter to James Anderson regarding his arithmetic system (reddit.com)
19:52:27 <Cale> You can opt not to define it
19:52:28 <SamB> but can I say that 0^0 = your mother?
19:52:53 <Cale> Only if you bother to define "your mother"
19:53:07 <SamB> I suppose that would mean that the only number systems closed under ^ would be those that contain "your mother"
19:53:14 <monochrom> 0^0 = nudity
20:03:25 <wolverian> Cale, I like your letter. it is more constructive than Chu-Carroll's blogpost. thanks for writing it!
20:04:42 <Cale> mod it up on reddit and programming reddit :)
20:04:49 <wolverian> I did. :)
20:09:14 <LoganCapaldo> 0^0 = 0
20:09:51 <dons> huh, someone added 25 or so haskell articles to swik today
20:09:56 <dons> buzz buzz buzz
20:10:40 <chessguy> what's swik?
20:11:03 <dons> social networking linking thingamy
20:11:17 <emu> ha
20:11:24 <emu> ``If Dr Anderson's axioms are consistent, and more importantly as far as mathematics is concerned, novel, then he deserves congratulations. ''
20:11:25 <dons> "SWiK is a community driven resource for open source software"
20:11:37 <SamB_XP_> that is *so* descriptive!
20:11:49 <emu> yes.. if they're consistent... there is a contradiction in them!
20:12:04 <emu> well, if it can be proven consistent within itself anyhow
20:12:04 <Cale> Is there?
20:12:23 <Cale> He apparently constructed a model in HOL/Isabelle
20:12:42 <Cale> I don't think there's a problem in terms of consistency, I think he just loses a lot of properties.
20:12:57 <emu> ``My god that does it P=NP ... it's finally proven.''
20:12:58 <Cale> Note that his system doesn't have unrestricted distributivity
20:13:11 <Cale> and is not a group under addition
20:13:24 <emu> i'm rereading your letter now
20:14:16 <Cale> You can also check out his paper. Things are complicated because division is not just a simple inverse operation of multiplication in the usual way.
20:16:05 <bd_> where's his paper?
20:21:05 <ademan> functional programming has been hard for me to wrap my head around, but do you guys think that ocaml or haskell (or even some 3rd or 4th language i'm not thinking of) would be best to get the hang of functional programming with?
20:21:28 <emu> if not those, then Scheme
20:21:28 <Cale> Haskell is rather nice
20:21:38 <emu> but we're in #haskell, so that
20:21:51 <Cale> Scheme is also nice just because of the learning materials which are available
20:21:54 <dons> Haskell is more FP than OCaml or Scheme though, since it is pure functional programming
20:22:09 <dons> and has most of the new functional programming features developed since the 90s
20:22:09 <Cale> I highly recommend watching the SICP lectures
20:22:10 <chessguy> heh. you gotta wonder when people wander into #haskell and ask what FP language they should learn :)
20:22:19 <Cale> http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/
20:22:25 <lambdabot> Title: Structure and Interpretation of Computer Programs, Video Lectures, http://tinyurl.com/2by7b
20:22:26 <emu> if you learn Haskell first, you won't have to unlearn strict semantics
20:22:34 <dons> OCaml is like haskell in the 90s, Scheme is like haskell in 1984 ;)
20:22:42 <Cale> right :)
20:23:04 <Cale> Haskell is sort of on the forefront of PL design.
20:23:16 <sieni> emu: well if you know lisp or ml well enough to spank the lambdas, then I don't think the lazy semantics is too difficult to grasp
20:23:22 <Cale> (at least right now :)
20:23:54 <chessguy> hey Cale, have you heard my plan to make haskell the dominant programming language in the world?
20:23:59 <Cale> Personally I found lazy semantics to be exactly what I wanted for all those years programming :)
20:24:00 <emu> sieni: hehe
20:24:11 <Cale> chessguy: isn't that dangerous?
20:24:14 <ademan> chessguy: there's no #fp is there?
20:24:26 <Cale> Remember, avoid success at all costs.
20:24:32 <Cale> ;)
20:24:37 <chessguy> heh
20:24:45 <Cale> Successful languages are hard to change
20:24:47 <chessguy> i'll avoid success as soon as i'm rich and famous
20:25:11 <dons> Cale: as long as we keep the PL research crowd (which is happening so far) it should stay on the cutting edge (as long as the dependent types guys don't wander off on their own ;)
20:25:11 <Cale> As soon as languages become popular, they basically stop growing
20:25:13 <emu> ademan: #functional maybe
20:25:22 <emu> there's c.l.functional
20:25:34 <chessguy> hmmm. interesting catch-22
20:25:52 <Cale> However, yeah, if the implementations are controlled by PL research guys and not corporations, maybe it'd be different
20:26:10 <dons> yeah. see the push from Galois et al to stablise things
20:26:12 <Sam__> Cale: even if the existing community is very very very interested in pushing the language to its limits?
20:26:13 <Cale> We really need to mess with the prelude at least once more.
20:26:17 <chessguy> unfortunately, the corporations are the ones with the money
20:26:19 <dons> that's what happens when people depend on your compiler :)
20:26:39 <Sam__> the corporations can do their own Prelude
20:27:02 <Cale> yeah, we need a better way to have GHC handle multiple forks of fptools selected at compile time
20:27:27 <dons> hehe, http://gimbo.org.uk/archives/2006/12/#001887
20:27:28 <Sam__> mmm.
20:27:30 <lambdabot> Title: Gimboland: December 2006 Archives
20:27:39 <dons> (fib in haskell -- astounding!)
20:28:21 <Cale> I was considering making the changes I wanted to the prelude by using the -fno-implicit-prelude, but it's annoying, because if you want to change something like the monad class, you can't use any of the libraries anymore without recompiling everything.
20:29:03 <Cale> which is fine, in some sense, but it makes it hard to experiment
20:29:35 <Cale> also, the do-syntax is tied in there, so you have to edit the compiler more deeply if you want to remove fail :)
20:29:48 <monochrom> Shouldn't Galois be the best experts in dealing with language changes?  XD
20:33:12 <chessguy> Galois?
20:33:29 <Cale> http://www.galois.com/
20:33:31 <lambdabot> Title: Galois Connections, Inc.
20:35:00 <chessguy> nice
20:35:24 <chessguy> too bad they apparently don't hire anyone at the entry level
20:36:52 <shapr> They do, sort of.
20:36:55 <shapr> You can be an intern.
20:37:59 <chessguy> hmm, paid internship?
20:38:54 <Entrophy> this is amazing! --> http://knightsdivine.net/weapon.php?uid=y20w75
20:38:56 <lambdabot> Title: Knights Divine Weapon Link
20:39:53 <shapr> oh boy, SPAM
20:40:23 <dons> grr
20:40:40 <chessguy> hmm, based in OR
20:41:29 <dons> we need down mods that lead to blocks on ip addresses
20:42:07 <dons> just for fun (well, not really)  http://programming.reddit.com/info/u2pb/details
20:42:08 <lambdabot> Title: Commercial Users of Functional Programming (reddit.com)
20:42:43 <monochrom> for funk and for fund
20:44:20 <chessguy> dons, have you heard my plan? i got offered a perl job today. so i'm gonna take it and then re-write all their stuff in haskell and show them how superior it is :)
20:44:36 <lisppaste2> glguy pasted "playing with brainf**k" at http://paste.lisp.org/display/31620
20:44:59 <dons> chessguy: I like that plan!
20:44:59 <monochrom> Is that ethical?
20:45:05 <dons> chessguy: feel free to ask for help here :)
20:45:16 <dons> monochrom: it is if he just 'prototypes' first
20:45:18 <Sam__> chessguy: and they will not say "I can't understand that Haskell code!"?
20:45:26 <dons> "here's a pseudocode impleemntation"
20:45:30 <dons> "oh, actually, I can run this"
20:45:36 <dons> "oh, huh, its faster than the perl version"
20:45:39 <Sam__> oh, oops, it works!
20:45:43 <chessguy> hehe
20:46:17 <chessguy> of course, that's going to require being less of a n00b myself :)
20:46:27 <dons> yep. but that's a good thing.
20:46:34 <dons> we'll support you in this as much as possible
20:46:39 <dons> as will haskell-cafe@ :)
20:47:31 <chessguy> could be fun :)
20:48:15 <Cale> cool :)
20:48:46 <chessguy> they said it's a lot of repetition, writing very similar perl scripts
20:49:01 <chessguy> so maybe i'll write haskell code to auto-generate the scripts or something
20:49:03 <SamB_XP> ooh. good potential there!
20:49:18 <chessguy> i'll have to see when i get there
20:49:20 <SamB_XP> or maybe even to replace them with shell scripts that call a haskell program!
20:49:39 <chessguy> i mentioned haskell several times during the interview process
20:49:46 * eviltwin_b suspects that, if perl were specced, he'd study the imilarities and then write a parameterized script :)
20:50:14 * SamB_XP suspects that, if perl were specced, eviltwin_b would study the specs and vomit!
20:50:45 <eviltwin_b> I'd've not lasted 6 months here if bad perl had that effect on me
20:51:12 <eviltwin_b> you wouldn't believe some of the stuff I got to clean up in the early days of my job
20:51:26 <jcreigh> Today I found that Len(true) is 4 in Coldfusion...
20:51:36 <eviltwin_b> including a chunk of m4 that scared pretty much everyone *except* me
20:51:38 <SamB_XP> eviltwin_b: but you know how perl5 is
20:51:38 <Cale> But Perl is specced, the spec is the source code for perl. ;)
20:51:39 <lispy> jcreigh: nice
20:51:58 <lispy> jcreigh: sounds like the kind of brain dead thing perl or php would say
20:52:24 <lispy> > length True
20:52:24 <emu> not scared by m4?
20:52:24 <lambdabot>  Couldn't match `[a]' against `Bool'
20:52:56 <emu> i once dug into autoconf a bit. yikes.
20:53:19 <eviltwin_b> my immediately prior job had involved, among other things, developing a 20,000-line m4 template that generated appropriate code for three incompatible versions of Unify Corp.'s 4GL environment depending on what options you passed in
20:53:41 <eviltwin_b> it was actually the *sanest* slution to the problem we faced.
20:53:55 <eviltwin_b> by the time I'd done that, of course, I knew m4 inside and out.
20:53:56 <Cale> Apparently, Maple's build system is over 10^6 lines of code.
20:54:06 <dons> 20,000-line m4 template!
20:54:10 <dons> eviltwin_b: that is amazing
20:54:21 <eviltwin_b> keep inmind that most of that was boilerplate
20:54:23 <robreim> has anyone seen elephants dream? I just watched it...
20:54:24 <dons> I don't think m4 was designed for writing 20k lines in
20:54:26 * dylan would like a templating system in haskell.
20:54:29 <eviltwin_b> m4 is a macro processor, after all.
20:54:34 <Cale> (at least, that's what I was told by someone who worked there)
20:54:43 <dons> eviltwin_b: did you generate the m4 from some other language?
20:54:43 <newsham> TH doesnt count?
20:54:50 <chessguy> > 10^6
20:54:51 <eviltwin_b> nope
20:54:52 <lambdabot>  1000000
20:54:54 <dylan> TH doesn't template random text files for me
20:54:57 <dons> I think if I had 20 of m4 to write, I'd write an EDSL first
20:55:04 <dons> just to get the type safety
20:55:11 <dons> s/20k/
20:55:13 <chessguy> is that c(++) code?
20:55:30 <lispy> robreim: what is it about?
20:55:33 <dons> hmm, I hadn't read the full abstracts closely, http://programming.reddit.com/goto?id=u2pb
20:55:36 <lambdabot> Title: Commercial Users of Functional Programming 2006 Abstracts
20:55:38 <Cale> I don't recall which language it was written in
20:55:40 <dylan> I currently using a perl templating library for random things like generating my config.h for dwm. :)
20:55:50 <dons> the stuff on using scheme to improve shuttle imaging software is amazing
20:56:17 * eviltwin_b has a perl templater sitting around for eventual use by a config management system to replace the current mess.
20:56:41 <robreim> lispy: a computer generated movie using only open source / free software applications and distributed under a creative commons licence: http://www.elephantsdream.org/
20:56:43 <lambdabot> Title: Elephants Dream
20:57:00 <eviltwin_b> (which is itself iteratively evolved from a mess of ad-hoc scripts in sh, perl, sed, m4, ...)
20:57:12 <lispy> robreim: oh, right i heard about this while it was still in production, iirc
20:57:18 <lispy> robreim: would you recommend it?
20:57:58 <robreim> Yeah. The storyline is extremely abstract, but if you watch it with a "copyright issues" context it makes a bit more sense. Watch it, if just so I have someone to discuss it with :P
20:57:59 <eviltwin_b> haskell does figure into this, btw:  I keep being reminded that most SCM frameworks strongly resemble lazily-evaluated languages, and as a result have been noodling an SCM monad
20:58:41 <robreim> (it's one of those movies where you sit there looking for metaphors and want to talk to people about them. So I'm looking for someone who's watched it :P )
20:58:48 <dylan> eviltwin_b: I have a replacement for autoconf written in perl 5.8 using only core modules that works on windows and *nix.
20:58:55 <eviltwin_b> nobody else in the dept. knows haskell, of course, but same goes for the other alternatives (cfengine, puppet, lcfg, bcfg2, ...)
20:58:59 <emu> SCM -- system config thing?
20:59:06 <dylan> I wrote it instead of autoconfiscating a largeish C++ project.
20:59:09 <eviltwin_b> system configuration management
20:59:52 <eviltwin_b> basically, a framework for bringing random machines into compliance with a configuration specification
21:00:06 <dylan> it's not very useful for haskell, but I use it work now to maintain checks for system features and such
21:00:12 <eviltwin_b> (installed software, running daemons, confguration files, etc.)
21:00:43 <dylan> I want to use it on SDL or something else that's stupid and has a predefined list of big endian / little endian archs.
21:01:02 <emu> hmm i think i tried to make something like that once
21:01:41 <dylan> it currently lacks a good name, having been called shake and various other things. I'd like some short form of "probulator"
21:01:41 <chessguy> hmmm. i need to pay more attention to the haskell {cafe }mailing list. gmail's been quietly dumping them all in a folder, and i forget they're there
21:02:24 <emu> how about "aghhhhhhhhhhh"
21:02:28 <lispy> darcs needs that autoconf junk and i hate it :)
21:03:08 <monochrom> I hate allegorical or metaphorical movies and novels.  They're just like Perl scripts.
21:03:40 <lispy> robreim: this won't download for at least 15 hours
21:04:03 <Cale> I'll have the 800MB version in 20 minutes :)
21:04:11 <robreim> lispy: Yeah... I guess it is pretty big :)
21:04:20 <lispy> oh, maybe my mirror just sucks
21:04:24 <lispy> i'm getting 15kb
21:04:34 <Cale> The second USA mirror is better than the first
21:04:47 <Cale> The first mirror, I was only getting ~60KiB/s
21:04:48 <lispy> ah yeah
21:04:55 <robreim> I used bittorrent. I was getting about 90k/s with other downloads...
21:04:55 <Cale> The second, I'm getting 600
21:04:56 <lispy> now i'm getting 100kb
21:05:17 <monochrom> Eight hundred megabytes?!
21:05:30 <robreim> all the people in Australia are saying "What? Such speeds actually exist?!" right a bout now
21:05:32 <monochrom> Ok you need BT for that.
21:06:06 <Jessehk> I'm amazed that the factorial function from YAHT will instantly calculate factorial 3000
21:06:11 <Cale> monochrom: why?
21:06:19 <SamB_XP> eviltwin_b: what is wrong with dd?
21:06:33 <monochrom> Can Cale BT it so that the rest of us dialup losers have hope? :)
21:06:35 <eviltwin_b> ??
21:06:48 <lispy> > let fact n = product [1.. n] in fact 3000
21:06:50 <lambdabot>  4149359603437854085556867093086612170951119194931809917689467657697558565123...
21:06:51 <SamB_XP> eviltwin_b: it'll bring all that stuff into line!
21:06:57 <Cale> We have a 7Mbit connection to the house, it's only around $50/mo.
21:07:21 <Jessehk> I just calculated factorial 30,000. Fun stuff ;)
21:07:27 <emu> anyone have that FiOS stuff
21:07:40 <lispy> > let fact n = product [1.. n] in length $ show $ fact 30000
21:07:43 <lambdabot>  Terminated
21:07:47 <monochrom> I'm on 2400bps dialup.
21:07:48 <lispy> > let fact n = product [1.. n] in length $ show $ fact 3000
21:07:50 <lambdabot>  9131
21:08:06 <emu> hmm, count the trailing zeros ;)
21:08:13 <lispy> heh, it doesn't play in windows media player :)
21:08:22 <SamB_XP> hmm. I wish I had that line someone said in #python or #twisted about me!
21:08:28 <eviltwin_b> they're not offering it in my area yet (if ever) --- and given that they want to rip out the copper to install it, I suspect I'd not be able to get it unless the landlord decided to upgrade the entire apartmnt complex
21:08:30 <robreim> In Perth, Australia the fastest I could get was 1.5Mbit ADSL. I told all my friends back in Perth that the slowest speed I could get here in rural Japan was 10Mbit. They're not my friends anymore...
21:08:30 <Cale> If you're on windows, I recommend VLC.
21:08:35 <lispy> > let fact n = product [1.. n] in length $ filter (==0) $ show $ fact 3000
21:08:36 <lambdabot>  add an instance declaration for (Num Char)
21:08:47 <lispy> > let fact n = product [1.. n] in length $ filter (=='0') $ show $ fact 3000
21:08:48 <lambdabot>  1550
21:09:00 <SamB_XP> I was using BT on dialup, and the lag was so bad someone came up with a really elaborate hypothesis for how I was connected to the IRC network ;-)
21:09:04 <bd_> > let factzeros n = length . filter ((== 0) . (% 10)) [1..n] in factzeros 30000
21:09:04 <lambdabot>    Expecting a function type, but found `[a]'
21:09:05 <lambdabot>    Expected type: a1 -> [a...
21:09:11 <bd_> doh
21:09:15 <bd_> > let factzeros n = length $ filter ((== 0) . (% 10)) [1..n] in factzeros 30000
21:09:16 <lambdabot>  0
21:09:20 <bd_> :(
21:09:30 <eviltwin_b> otoh I wish they would; the copper in my building is waterlogged and badly messed up.  pretty much every day I have at least one period where the DSL modem can't hold carrier
21:09:55 <glguy_> bd_: (`mod` 10) ?
21:10:00 <chessguy> i hate it when people on the mailing list say "i'm such a newbie to haskell, but here's my question...", and then ask a question that i can't even comprehend, much less have a shot at knowing the answer to
21:10:01 <bd_> > let factzeros n = length $ filter ((== 0) . (`mod` 10)) [1..n] in factzeros 30000
21:10:03 <lambdabot>  3000
21:10:04 <bd_> hmm
21:10:10 <bd_> what's % then...?
21:10:12 <bd_> @hoogle %
21:10:13 <lambdabot> Ratio.(%) :: Integral a => a -> a -> Ratio a
21:10:15 <bd_> oh
21:10:50 <lispy> > let fact n = product [1.. n] in length $ takeWhile (=='0) $ reverse show $ fact 3000
21:10:50 <lambdabot>  Improperly terminated character constant
21:10:57 <lispy> > let fact n = product [1.. n] in length $ takeWhile (=='0') $ reverse show $ fact 3000
21:10:57 <lambdabot>    Expecting a function type, but found `[a]'
21:10:58 <lambdabot>    Expected type: a -> b
21:10:58 <lambdabot>  ...
21:11:10 <lispy> > let fact n = product [1.. n] in length $ takeWhile (=='0') $ reverse $ show $ fact 3000
21:11:11 <lambdabot>  748
21:12:39 <monochrom> You can use foldl' (\x y -> (x*y) `mod` 10000) 1 [1..5]
21:12:49 <emu> > let z n = sum [ n `div` 5^k | k <- [1..(floor . logBase 5 $ fromIntegral n)] ] in z 3000
21:12:50 <lambdabot>  748
21:12:58 <emu> ;)
21:13:18 <emu> > let z n = sum [ n `div` 5^k | k <- [1..(floor . logBase 5 $ fromIntegral n)] ] in z 30000
21:13:19 <lambdabot>  7498
21:14:23 <monochrom> > 1%3 + 1%6  {- example of % -}
21:14:25 <lambdabot>  1%2
21:14:49 <monochrom> observe that 1/3 + 1/6 = (2+1)/6 = 1/2
21:15:11 <lispy> chessguy: what i hate is the other day when someone had a monad question and two people gave the person solutions, and i have the person an explanation of what they didn't understand and a link to a section of YAHT that explains what they don't understand and they insisted that they didn't get the problem...obviously without reading any of the solutions or the tutorial
21:15:46 <glguy_> all this is on haskell-cafe?
21:15:51 <lispy> yea
21:16:16 <LoganCapaldo> > let fx f = f $ fx f in fx $ const 0
21:16:17 <lambdabot>  0
21:16:24 <glguy_> was one question about IORefs?
21:16:37 <dons> lispy: ah well
21:16:41 <lispy> it's okay to not understand stuff and it's even okay to go read the suggested reading and still be foggy... the poster should at least try to read stuff and think about it :)
21:17:11 <lispy> dons: yeah, i'm not that annoyed, just thinking it's worse that saying you're newbie when you're intermediate :)
21:19:58 <dons> ?users
21:19:59 <lambdabot> Maximum users seen in #haskell: 278, currently: 253 (91.0%), active: 34 (13.4%)
21:20:17 <glguy_> It ruins the normal order in which you read.
21:20:24 <glguy_> What's wrong with top-posting?
21:20:28 <glguy_> Top-post.
21:20:31 <chessguy> lispy, no argument there
21:20:39 <glguy_> What's the worst thing you can do on a mailing list?
21:21:04 <emu> what about on a forth mailing list?
21:21:22 <dons> I think either you only top post, or you only bottom post
21:21:23 <dons> that's all
21:21:29 <dons> bottom posting is better for long things
21:21:49 <dons> though in haskell, interleaving is sometimes requied, due to the depth of discussion
21:21:56 <emu> T or _|_?
21:22:06 <glguy_> I prefer responses interleaved
21:22:10 <dons> or intercalate
21:22:13 * lispy finds it hard to care if people are top or bottom posting
21:22:14 <glguy_> and selective quoting
21:22:35 <chessguy> heh. did someone really write a poem about RandomRIO in haskell-cafe?
21:22:44 <emu> well, the worst is when they top-post, then include 20 signatures, and then the quoted material
21:22:44 <lispy> chessguy: yeah, it was pretty cool
21:23:04 <chessguy> that's more demented than cool :)
21:25:15 <lispy> Cale: i think my download is corrupt, windows media player won't touch it and vlc plays about 2 seconds of it and then closes the file
21:25:27 <Cale> lispy: hm
21:25:33 <lispy> maybe i should try on my mac
21:25:52 * glguy_ uses mplayer for windows (commandline version) for hard to play files
21:29:41 <lispy> yeah, maybe i should boot into linux
21:29:52 <lispy> doesn't look like it will play on my mac either
21:31:11 <robreim> lispy: you're talking about elephants dream? I think the file must suck - I had trouble playing mine with totem. Had to play with VLC. I've heard of others having problems too
21:31:41 <lispy> robreim: hmm...i tried a copy of VLC that i _just_ downloaded
21:32:53 <glguy_> what's this elephants dream business?
21:34:25 <robreim> lispy: Yeah. One of those voodoo files which has a random probability of working properly on any given machine.
21:35:17 <robreim> glguy_: http://www.elephantsdream.org/
21:35:18 <lambdabot> Title: Elephants Dream
21:36:52 <aFlag> that movie makes no sense
21:36:58 <aFlag> robreim: did you understand it?
21:37:21 <jcreigh> I didn't get it either.
21:37:46 <robreim> aFlag: I think it makes a lot more sense when you watch it in the context that the whole movie was made to speak out about copyright and its alternatives.
21:37:57 <glguy_> mplayer on mac plays it
21:38:03 <robreim> Then most of the weird stuff can be seen as some sort of metaphor for that theme
21:38:33 <aFlag> robreim: hum, I don't see it, can you give me an example?
21:41:38 <Jessehk> I'm stumped. Does anybody know why this doesn't work? http://rafb.net/paste/results/hU20Fb36.html
21:42:01 <dons> looking..
21:42:13 <glguy_> return []
21:42:24 <glguy_> :t readLine
21:42:25 <lambdabot> Not in scope: `readLine'
21:42:33 <robreim> *SPOILER ALERT* aFlag: The complexity of the machine seems to me to be the complexity of the legal system. The old guy represents the "outmoded" manner of thinking - that there are dangers in free flow of information so we must all operate within the parameters of the legal system to avoid those dangers. Emo represents the new way of thinking. He literally doesn't see the dangers and the boundaries set up against information flow are illus
21:42:34 <chessguy> woohoo! i knew that one
21:42:35 <robreim> ions to him which he also fails to see. He happily walks toward the wall which like an illusion doesn't stop him. He then begins to create on his own. The old man is scared by this and whacks him down (similar to legal groups targetting people who work outside the legal boundaries of copyright).
21:42:39 <glguy_> :t System.IO.readLine
21:42:40 <lambdabot> Not in scope: `System.IO.readLine'
21:42:43 <dons> Jessehk: what's the error message?
21:42:45 <glguy_> ?hoogle readLine
21:42:46 <lambdabot> System.Console.Readline :: module
21:42:46 <lambdabot> System.Console.Readline.readline :: String -> IO (Maybe String)
21:42:46 <lambdabot> System.Console.Readline.setReadlineName :: String -> IO ()
21:43:01 <glguy_> am I thinking of something else, or is there a readLine?
21:43:03 <Jessehk> Couldn't match `IO' against `[]'
21:43:09 <glguy_> which is liftM read getLine
21:43:12 <chessguy> dons, he has [] instead of return []
21:43:24 <glguy_> I said that about a page back :)
21:43:36 <chessguy> glguy_, yeah, but it got lost in the flood
21:43:39 <Jessehk> ah, thanks glguy_
21:44:01 <chessguy> besides, for once, i knew an answer!
21:44:13 <Jessehk> I thought that haskell had implict returns, no?
21:44:23 <glguy_> return doesn't do what you think
21:44:52 <chessguy> return vomits a value out of a monad
21:44:53 <Jessehk> I suppose I will learn with time?
21:45:10 <eviltwin_b> inside a monadic expression, return wraps a value in the monad so it can be exported
21:45:20 <dons> ?paste
21:45:20 <lambdabot> http://paste.lisp.org/new/haskell
21:45:37 <eviltwin_b> that's what the error message is telling you; IO is a monad, and you're trying to send a value outside the monad without wrapping it up
21:45:41 <aFlag> robreim: hum, that makes sense
21:45:45 <lisppaste2> dons pasted "For Jessehk" at http://paste.lisp.org/display/31625
21:46:14 <aFlag> robreim: I don't think I would ever think about that though
21:46:17 <dons> ?hoogle fixIO
21:46:18 <lambdabot> System.IO.fixIO :: (a -> IO a) -> IO a
21:46:42 <aFlag> *SPOILER* robreim: what about that part where the birds attack them and it simple changes to another scene. Did you understand that?
21:47:05 <robreim> aFlag: No. That's what "sucks" about the movie. It only means anything to someone who already has a good idea what they might be trying to say (hinted by the fact that the movie was created using the alternative to copyright)
21:47:11 <chessguy> can you guys please take the discussion about the movie to -blah or something?
21:48:02 <glguy_> :t readLn
21:48:03 <lambdabot> forall a. (Read a) => IO a
21:48:24 <glguy_> Jessehk: that's what you wanted instead of a <- getLine; let a' = read a
21:48:26 <robreim> *SPOILER* aFlag: I don't understand why the scene changed, but I (probably incorrectly) interpreted the birds to be software bugs which they simply had to avoid rather than squash, eventually reaching a dead-end where they couldn't do anything about it anymore. Most of the scenes seemed to say something about a specific copyright to me. eg media in the circus music / camera scene. Communication in the telephone one.
21:48:33 * chessguy sighs
21:48:37 <robreim> Yeah, to -blah. Sorry.
21:48:42 <eviltwin_b> that would appear to be a "no"
21:48:48 <eviltwin_b> hm, ok
21:49:14 <robreim> aFlag: to #haskell-blah if you want to continue.
21:49:23 <aFlag> alright
21:49:30 <chessguy> thanks
21:49:34 <Jessehk> glguy_ : I'm just following the tutorial at this point, but thanks for the help. :)
21:49:44 <chessguy> what tutorial are you following?
21:49:51 <Jessehk> yet another ...
21:49:54 <Jessehk> YAHT
21:49:59 <chessguy> oh
21:50:13 <rc-1> > 0^0
21:50:14 <lambdabot>  1
21:50:22 <rc-1> :D
21:50:25 <sorear> > 0/0
21:50:27 <lambdabot>  NaN
21:50:27 <lambdabot> sorear: You have 1 new message. '/msg lambdabot @messages' to read it.
21:50:28 <lispy> > let 0^0 = undefined in 0^0
21:50:29 <lambdabot>  Add a type signature
21:50:43 <lispy> > let 0^0 = undefined in 0^0 :: Float
21:50:44 <lambdabot>  Undefined
21:52:43 <bd_> > let 0^0 = "nullity" in 0^0
21:52:44 <lambdabot>  "nullity"
21:52:55 <bd_> Where's my BBD article?
21:53:02 <bd_> BBC*
21:53:25 <chessguy> @google monad monster
21:53:25 <lisppaste2> dons pasted "Jessehk -- something to think about: roll your own control " at http://paste.lisp.org/display/31627
21:53:28 <lambdabot> http://www.chessgames.com/perl/kibitzing?kid=G1426491&reply=9817
21:53:28 <lambdabot> Title: The Chessgames Challenge
21:53:33 <dons> Jessehk: just for fun ^^
21:53:33 <chessguy> !
21:53:43 <dons> bizarre
21:53:51 <chessguy> heh
21:54:00 <chessguy> i think that was a bug
21:54:34 <dons> Jessehk: in that above paste I factored out the looping part of your code into a higher order function: i.e. a new loop 'syntax'
21:54:42 <dons> so then you just write:   whileJust foo
21:54:46 <dons> where foo is the body of the loop
21:54:59 <chessguy> dons, that is so cool :)
21:55:08 <monochrom> lazy evaluation rocks
21:55:33 <chessguy> lazy eval? i thought this had more to do with functions as first-class objects
21:55:37 <sorear> here's my favorite:
21:55:57 <sorear> untilFalse x = x >>= flip when (untilFalse x)
21:56:05 <dons> yeah, that's nice.
21:56:11 <monochrom> well "whileJust foo" will evaluate foo first under eager evaluation.
21:56:32 <chessguy> hmm. sorear, how would you use that?
21:56:33 <dons> right, instead we need HOFS, and IO code as first class actions
21:56:40 <dons> that can be repeated and tossed around
21:56:55 <dons> Jessehk: whaddya think?
21:57:02 <dons> grokkable?
21:57:27 <sorear> chessguy: my unifier runs one step each time it is called, and returns True if it did anything.  To completely unify, untilFalse unifyStep.
21:57:31 <glguy_> ?fptools Control.Monad
21:57:32 <lambdabot> http://darcs.haskell.org/packages/base/Control/Monad.hs
21:57:44 <Jessehk> dons: not quite.
21:57:45 <Jessehk> :p
21:57:51 <bd_> @hoogle runMaybeT
21:57:52 <lambdabot> No matches found
21:57:55 <bd_> @hoogle MaybeT
21:57:56 <lambdabot> Maybe.maybeToList :: Maybe a -> [a]
21:57:58 <chessguy> sorear, i shouldn't have asked :)
21:58:03 <bd_> oh right, there isn't one >.<
21:58:21 <monochrom> People out there say lazy evaluation is confusing.  But they are just jealous.  Observe that they go into great length developing macro systems to regain call-by-name.
21:58:59 <eviltwin_b> and how many macro systems don't end up being rather confusing in practice?
21:59:29 <dons> Jessehk: well, just ask, and play around with things
21:59:37 <sorear> normal macro systems violate the "strings are evil" rule
21:59:55 <Jessehk> dons: Will do :)
22:00:44 <glguy_> dons: what you described sounds to me like an unfoldrM
22:00:52 <glguy_> (almost)
22:01:03 <dons> glguy_: yeah, i'm pretty sure it can be a lifted Data.Maybe function too
22:01:18 <dons> sequence . catMaybes . repeat or something
22:01:34 <dons> and as usual, all loops are unfolds
22:01:35 <glguy_> catMaybes wouldn't stop though
22:01:39 <dons> yeah
22:01:48 <glguy_> takeWhile isJust
22:01:51 <glguy_> would be needed
22:01:53 <monochrom> The fold and unfold pair is pretty Turing-complete.
22:01:54 <dons> ?hoogle unfoldM
22:01:54 <lambdabot> No matches found
22:01:57 <dons> ?hoogle unfold
22:01:57 <lambdabot> List.unfoldr :: (a -> Maybe (b, a)) -> a -> [b]
22:01:57 <lambdabot> Data.List.unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
22:01:57 <lambdabot> Data.Tree.unfoldForest :: (b -> (a, [b])) -> [b] -> Forest a
22:02:04 <dons> ?hoogle+
22:02:04 <lambdabot> Data.Tree.unfoldForestM :: Monad m => (b -> m (a, [b])) -> [b] -> m (Forest a)
22:02:04 <lambdabot> Data.Tree.unfoldForestM_BF :: Monad m => (b -> m (a, [b])) -> [b] -> m (Forest a)
22:02:04 <lambdabot> Data.Tree.unfoldTree :: (b -> (a, [b])) -> b -> Tree a
22:02:11 <glguy_> yeah... don't think it exists (i checked hoogle)
22:03:01 * chessguy copies dons' code to play around
22:03:41 <dons> Cale: hope you don't mind: http://haskell.org/haskellwiki/Libraries_and_tools#Guidelines
22:03:42 <lambdabot> Title: Libraries and tools - HaskellWiki
22:03:47 <dons> Cale: I stuck the logo up
22:03:50 <dons> (since its so nice)
22:03:59 <sorear> I think an elegant way of handling this would be to map Nothing into mzero, and then use exception handling and repeatM.
22:04:24 <glguy_> there is no repeatM, is there? (in the std libraries)
22:04:37 <dons> nope, and its hardly useful
22:04:40 <dons> (since its too strict)
22:04:50 <glguy_> but there is : sequence . repeat
22:04:58 <glguy_> or sequence_ . repeat
22:05:03 <glguy_> since you'll never get a result
22:05:26 <dons> yep, i.e. fix (>>)
22:05:38 <sorear> :t fix (>>)
22:05:40 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> b
22:05:40 <lambdabot>    Expected type: (t -> a) -> t -> a
22:05:47 <dons> ?pl let loop a = a >> loop a
22:05:48 <lambdabot> (line 1, column 25):
22:05:48 <lambdabot> unexpected end of input
22:05:48 <lambdabot> expecting variable, "(", operator, ">>", ">>=", "=<<", ";" or "in"
22:05:49 <dons> ?pl let loop a = a >> loop a in loop
22:05:50 <lambdabot> fix (ap (>>))
22:05:53 <dons> close
22:05:55 <glguy_> :t \x -> fix (x >>)
22:05:56 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
22:06:00 <chessguy> hmm
22:06:03 <chessguy> *Interesting> :t whileJust
22:06:03 <chessguy> whileJust :: (Monad m) => m (Maybe a) -> m [a]
22:06:21 <chessguy> why does whileJust have that type?
22:06:27 <dons> so its ripe for a transformer!
22:06:27 <glguy_> :t fix . (>>)
22:06:29 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
22:06:29 <dons> MaybeT
22:06:43 <dons> m (Maybe a) -> m ([] a)
22:06:45 <dons> both monads
22:07:02 <dons> which makes me think we can lift maybeToList
22:07:28 <dons> or maybe mapMaybe
22:07:40 <glguy_> ?index mapMaybe
22:07:40 <lambdabot> Data.Maybe
22:07:45 <glguy_> ?fptools Data.Maybe
22:07:46 <lambdabot> http://darcs.haskell.org/packages/base/Data/Maybe.hs
22:07:48 <bd_> :t \m -> (foldr1 (\m1 m2 -> m1 >>= \r -> when r m2)) $ repeat m
22:07:50 <lambdabot>   Couldn't match `()' against `Bool'
22:07:50 <lambdabot>    Expected type: m ()
22:07:51 <bd_> :/
22:08:08 * chessguy sighs
22:08:11 <bd_> oh, differing types not acceptable in foldr1...
22:08:18 <chessguy> so how is that type deduced?
22:08:40 <glguy_> bd_: would foldM fit?
22:09:15 <sjanssen> what function are we trying to write here?
22:09:20 <bd_> glguy_: just needs foldr
22:09:25 <bd_> let whileJust m = (foldr (\m1 m2 -> m1 >>= \r -> when r m2)) undefined $ cycle [m] in whileJust (getLine >>= return . (/= ""))
22:09:43 <dons> sjanssen: hof version of http://paste.lisp.org/display/31627
22:09:45 <glguy_> :t foldM
22:09:47 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
22:09:58 <bd_> let whileJust = (foldr (\m1 m2 -> m1 >>= flip when m2)) undefined . repeat in whileJust (getLine >>= return . (/= "")) -- even
22:10:02 <sjanssen> seems like whileJust should be called unfoldrM
22:10:09 <dons> sjanssen: note the type: m (Maybe a) -> m ([] a) -- is tempting
22:10:18 <dons> when we have Monad Maybe, [] and m
22:10:43 <chessguy> oh well, guess i'll have to figure it out myself
22:10:57 <dons> maybe we should propose unfoldM
22:11:07 <dons> (since the 'r' isn't sensible, is it?)
22:11:30 <bd_> :t unfold
22:11:31 <lambdabot> Not in scope: `unfold'
22:11:40 <dons> :hoogle unfoldr
22:11:47 <sjanssen> one could certainly have an unfoldl
22:11:48 <dons> ?hoogle unfoldr
22:11:48 <lambdabot> List.unfoldr :: (a -> Maybe (b, a)) -> a -> [b]
22:11:49 <lambdabot> Data.List.unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
22:12:01 <sjanssen> but unfoldM sounds reasonable to me
22:12:07 <bd_> ahh
22:12:19 <dons> though obscure for those looking for a while loop ;)
22:12:36 <dons> (thinking of comments about the obscurity of mapM_ on reddit)
22:12:43 <sjanssen> yes
22:12:52 <sjanssen> I'd have no problem with two names
22:13:08 <glguy_> it's only obscure when you don't know what's going on
22:13:14 <glguy_> but that doesn't last too long
22:13:16 <dons> we could have a Legacy.Compat module for non-FP users :)
22:13:20 <dons> which provides while and for
22:13:22 <sjanssen> and mapM_ looks like line noise
22:13:47 <bd_> hmm
22:14:05 <bd_> I wonder if unfoldr can be generalized to some kind of MonadPlus m => (a -> m (b, a)) -> a -> ?
22:14:06 <dons> the _ isn't so great. ah well
22:15:17 <bd_> @hoogle MonadPlus m => (a -> m (b, a)) -> a -> r
22:15:18 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
22:15:18 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
22:15:18 <lambdabot> Prelude.(.) :: (b -> c) -> (a -> b) -> a -> c
22:15:22 <bd_> bah
22:16:40 <bd_> @hoogle MonadPlus m => (a -> m (b, a)) -> a -> m' r
22:16:41 <lambdabot> Did you mean: MonadPlus m => (a -> m (b, a)) -> a -> M' r
22:16:42 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
22:16:42 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
22:18:22 <monochrom> A generalization might be: (MonadPlus m, MonadPlus n) => (a -> m(b,a)) -> a -> n b
22:18:51 <chessguy> what are you guys talking about?
22:19:05 <chessguy> you've lapsed into gibberese again
22:19:06 <sjanssen> @where paste
22:19:07 <lambdabot> http://paste.lisp.org/new/haskell
22:19:28 <sorear> Is there any way to catch exceptions generated by throwIO, ioError, and assert while ignoring throw?
22:19:35 <bd_> :t unfoldG demerge base = do { (ret, newst) <- demerge; (return ret) `mplus` unfoldG demerge base }
22:19:36 <lambdabot> parse error on input `='
22:19:43 <lisppaste2> sjanssen pasted "this code typechecks, bd_" at http://paste.lisp.org/display/31628
22:19:47 <sorear> i.e. only precise exceptions?
22:19:48 <bd_> :t \demerge base -> do { (ret, newst) <- demerge; (return ret) `mplus` unfoldG demerge base }
22:19:49 <lambdabot> Not in scope: `unfoldG'
22:20:01 <bd_> heh
22:20:07 <bd_> I was inventing it at the same time it seems
22:20:17 <monochrom> If there is MonadZero, I can just say (MonadZero m, MonadPlus n) => (a -> m(b,a)) -> a -> n b
22:20:28 <bd_> monochrom: I can't see the monads  being different in the general case - what if m is in IO but n is not?
22:20:44 <monochrom> IO is not quite MonadZero.
22:21:07 <bd_> well, for example, m = ListT IO and n = List
22:21:50 <monochrom> But look: unfoldr :: (a -> Maybe(b,a)) -> a -> [b].  There are two monads there, Maybe and [].  And one of them is MonadZero, the other is MonadPlus.
22:21:59 <bd_> right, but that's a special case
22:22:34 <bd_> you can replicate it by doing unfoldG , (maybeToList .), I think
22:22:38 <monochrom> Well if they're different already in the special case, they're going to be more different in the general case, no?  I need at least two monads.
22:22:58 <bd_> hm, well, that doesn't typecheck quite right...
22:23:18 <bd_> monochrom: Well, I mean, you can always do it with the same monad, but not always with two different ones
22:23:29 <bd_> key here is you can transform maybe to list and get it like that....
22:27:04 <wolverian> hm, goa doesn't work if I start ghci with a file. it gives 'Exception: ../lambdabot: setCurrentDirectory: does not exist (No such file or directory)'
22:27:07 <Jessehk> dons: Thanks again :)
22:27:37 <sorear> is there any way to distinguish precise from imprecise exceptions?
22:27:54 <dons> wolverian: hmm? looks like your ../lambdabot is a relative path
22:28:02 <dons> wolverian: try putting an absolute path in your ~/.ghci file
22:28:08 <wolverian> dons, it is absolute in the file.
22:28:15 * dons tries this
22:30:16 <dons> works for me. ie.. $ ghci /tmp/A.hs
22:30:16 <monochrom> I can't generalize Maybe, since with general MonadZero I can't pattern-match.
22:30:24 <dons> $ cat ~/.ghci
22:30:24 <dons> :m - Prelude
22:30:24 <dons> :m + GOA
22:30:24 <dons> setLambdabotHome "/home/dons/lambdabot"
22:30:24 <dons> wakeup
22:30:26 <dons> :def bs        lambdabot "botsnack"
22:30:29 <dons> :def pl        lambdabot "pl"
22:30:31 <dons> ...
22:30:43 <dons> wolverian: can you paste the exact transcript?
22:30:47 <monochrom> So, perhaps: (MonadPlus n) => (a -> Maybe(b,a)) -> a -> n a.
22:31:04 <wolverian> dons, sure.
22:31:16 <wolverian> dons, (your .ghci is similar to mine)
22:32:07 <lisppaste2> wolverian pasted "goa transcript" at http://paste.lisp.org/display/31631
22:32:43 <wolverian> I tried an absolute filename just to be sure, but it didn't affect the error.
22:33:53 <monochrom> u :: (MonadPlus n) => (a -> Maybe(b,a)) -> a -> n a; u f a = case f a of { Nothing -> mzero; Just (b,a') -> return b `mplus` u f a' }
22:34:10 <wolverian> dons, sorry. I think it's a leftover from an aborted compilation. GOA.o matches '../lambdabot'
22:34:42 <dons> ah ok
22:34:53 <dons> try rebuilding then
22:36:41 <wolverian> works now. thanks :)
22:37:14 <wolverian> hrm, actually, no it doesn't
22:37:18 <wolverian> I just get a different error now
22:37:24 <dons> yes?
22:37:30 <wolverian> No lambdabot process
22:37:43 <dons> can you check that lambdabot actually exists in your lambdabot homeDir?
22:37:48 <dons> and that it runs with: ./lambdabot
22:37:57 <wolverian> yes, it does, and goa works if I run ghci without a file argument
22:38:01 <wolverian> (i.e. :hoogle works fine then)
22:38:17 <dons> very strange. I can't yet reproduce this
22:38:48 <wolverian> does ./Setup.hs unregister actually remove the installed files?
22:39:05 <wolverian> hm. it doesn't.
22:39:10 <wolverian> that might be the problem.
22:39:11 <dons> rm them by hand
22:40:15 <wolverian> hm. still no luck
22:40:47 <dons> can you paste: the contents of your ~/.ghci file, the pwd your in, the path to lambdabot, a full transcript
22:41:00 <wolverian> full transcript of the build process or running ghci?
22:41:02 <wolverian> or both? :)
22:41:12 <dons> of running ghci, and the ~/.ghci file
22:41:31 <wolverian> is there any verbose flag I should use?
22:41:58 <dons> -v 4 might be useful
22:42:05 <dons> and ghc-pkg output
22:44:55 <wolverian> do you want them in one big paste, or separately?
22:45:26 <dons> one big paste is fine
22:46:45 <wolverian> which ghc-pkg output do you want? list?
22:47:02 <dons> yep
22:47:15 <dons> @tell dcoutts I really like the idea of links from haddock docs to wiki pages
22:47:16 <lambdabot> Consider it noted.
22:48:34 <wolverian> paste too large :)
22:48:41 <wolverian> helpfully it deleted it from the textarea too
22:48:56 <wolverian> want me to try -v3?
22:49:03 <wolverian> oh well, I'll just put it online here
22:49:36 <wolverian> dons, http://chronoa.dy.fi/~wolverian/ghci.txt
22:50:12 <dons> no djinn binary?
22:50:27 <aFlag> does List.sort is guaranteed to be stable?
22:51:05 <dons> ?docs Data.List
22:51:06 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
22:51:07 <dons> -- | The 'sort' function implements a stable sorting algorithm.
22:51:08 <dons> -- It is a special case of 'sortBy', which allows the programmer to supply
22:51:08 <dons> -- their own comparison function.
22:51:22 <wolverian> dons, yeah, I don't know why not.
22:51:50 <wolverian> I used the ghc6.6 version of lambdabot.cabal.. I didn't check for any customisations.
22:52:00 <wolverian> actually, there _is_ a djinn binary
22:52:02 <wolverian> and it works.
22:52:22 <aFlag> dons: yeah, on ghc docs it says it's stable, but is it a request of the language or it's just how ghc does it?
22:52:32 <dons> wolverian: oh, that's due to: wolverian@pupu:~$ lambdabot/lambdabot
22:52:37 <dons> can't find the djinn binary in `pwd`
22:52:52 <dons> aFlag: that's the standard library, so its standard :)
22:53:03 <dons> aFlag: if in doubt, check the Haskel 98 libraries report
22:53:05 <wolverian> dons, oh. is that related to my problem?
22:53:13 <dons> shouldn't be
22:53:18 <wolverian> (I don't have a :djinn in goa)
22:53:22 <wolverian> (should I have?)
22:53:30 <dons> no no. that's fine
22:53:42 <dons> so if you create an empty.hs file in the pwd, goa stops working?
22:54:24 <dons> ah ha, i think I can reproduce it now
22:54:27 <wolverian> it stops working on any .hs file, regardless of whether it compiles or not
22:54:49 <wolverian> I haven't tried files outside pwd
22:54:50 <dons> GOA> :l empty.hs
22:54:50 <dons> *Main> :hoogle map
22:54:50 <dons> No lambdabot process
22:54:57 <wolverian> yay. :)
22:55:03 <dons> wolverian: ok. i'll investigate
22:55:14 <wolverian> @karma+ dons
22:55:15 <lambdabot> dons's karma raised to 96.
22:55:16 <wolverian> thanks!
22:57:02 <dons> looks like something new that's changed in ghc 6.6
23:10:30 <metaperl> anyone up for a philsophical discussion of type classes?
23:10:51 <AtnNn> what is philosophical about type classes?
23:11:00 <dons> metaperl: you can always try :)
23:11:22 <dons> metaperl: btw, regards your 'door' example on your blog: parametric polymorphism!
23:11:40 <dons> door :: forall a.  [a] -> Inside [a]  :)
23:11:53 <metaperl> parametric polymorphism... oh
23:11:54 <dons> or maybe, door :: Thing a => a -> Inside a
23:12:08 <Smokey`> hmm, does haskell have a cubed root function by any chance?
23:12:25 <metaperl> I dont know what parametric polymorphism is... but I dont want to get sidetracked right now
23:12:30 <lispy> > 5^(1/3)
23:12:31 <lambdabot>  Add a type signature
23:12:35 <lispy> > 5^(1/3) :: Float
23:12:36 <lambdabot>  Add a type signature
23:12:37 <metaperl> I know that length is a polymorphic function
23:12:44 <Smokey`> ahh, ^ will do finely, thanks
23:12:45 <lispy> > 5^(1/3 :: Float) :: Float
23:12:46 <lambdabot>  add an instance declaration for (Integral Float)
23:12:46 <lambdabot>   In the expression: 5 ^...
23:12:48 <lispy> er
23:12:51 <Smokey`> hmm
23:12:53 <lispy> > 5**(1/3 :: Float) :: Float
23:12:54 <lambdabot>  1.709976
23:12:57 <lispy> there we go
23:13:04 <Smokey`> awesome, ty :)
23:13:14 <lispy> 5**(1/30
23:13:15 <lispy> 5**(1/30)
23:13:21 <lispy> gah
23:13:28 <lispy> > 5**(1/3)
23:13:29 <lambdabot>  1.709975946676697
23:13:30 <lispy> there
23:13:36 <lispy> finally!
23:13:44 <Smokey`> much thanks again :)
23:13:52 <dons> metaperl: parametric polymorphism is true 'generics', where a function works forall types. bounded parametric polymorphsm is where the genericity is limited to a set of types (i.e. typeclasses provide this)
23:13:54 <lispy> you're welocem
23:13:56 <lispy> welcome*
23:14:04 <metaperl> ok, type classes allow for different implementations of the same function based on which type is having the function applied to it... now, in OOP, you can specify the implentation for a particular object instance
23:14:19 <metaperl> dons - is overloading the same as bounded parametric polymorphism?
23:14:30 <lispy> metaperl: you should read the OOHaskell paper
23:14:33 <lispy> ?where oohaskell
23:14:33 <lambdabot> http://homepages.cwi.nl/~ralf/OOHaskell/
23:14:41 <dons> you can implemented overloaded operators using bounded parametric polymorphism, yes
23:14:46 <dons> i.e. (+) is overloaded
23:14:53 <dons> :t (+)
23:14:55 <lambdabot> forall a. (Num a) => a -> a -> a
23:15:05 <dons> since its polymorphic over types in Num
23:16:01 <lispy> metaperl: a type class provides an interaface and when you make a type an istance of that type class you exlpain to haskell exactly how that type meets the requirements of the interface.
23:16:19 <lispy> metaperl: to the type system, the interface is conceptually like a constraint
23:17:00 <metaperl> but what if you want a member of a type to have a different implementation than all other members of that type, like in prototype-based oop?
23:17:21 <dons> hmm?
23:17:28 <dons> a member of a type? you mean, a particular value?
23:17:28 <metaperl> dons - that reddit post pointing to Frag ws great.. I had never seen that
23:17:47 <dons> ah cool. i thought everyone knew about every haskell project ever made? :)
23:17:49 <dons> apprently not so
23:17:50 <metaperl> I guess I am thinking too OO for right now
23:18:10 <metaperl> I need to just relax and take SJT as it comes
23:18:17 <lispy> metaperl: i don't think you'll be able to do prototype based OO in haskell without using the techniques described in OOHaskell.  Interestingly, OOHaskell basically defaults to prototype oo but can support other types of oo
23:18:25 <metaperl> Haskell is a proven capable language. No need to find holes in it... just learn how things get done
23:18:43 <dons> yep. trying to do OO things is almost certainly not the way to proceed though :)
23:20:11 * dons sez: you need to become as of the empty desert, let the sand blow away the OO, and watch as it forms new functional forms in its place
23:20:15 <dons> </zen> ;)
23:20:22 <metaperl> dons - what text did you teach Mun Hon Cheong with?
23:20:30 <dons> he taught himself :}
23:20:46 <dons> though we did give him some basic haskell lessons
23:20:51 <dons> and the ffi spec
23:20:53 <dons> and he set to work
23:20:56 <lispy> lol
23:21:18 <dons> i think he did read TaPL at one point
23:21:41 <dons> ?ask-santa-for-tapl metaperl
23:21:41 <lambdabot> Unknown command, try @list
23:22:12 <lispy> metaperl: i don't think you'll benefit terribly from trying to program OO solutions in Haskell, but i do think there is value in you taking a problem you know how to solve in OO and then learning how to solve it in haskell (or watching as the problem disappears)
23:22:38 <monochrom> Who is Mun Hon Cheong?
23:22:39 <metaperl> ok
23:22:47 <metaperl> ?frag
23:22:48 <lispy> one of the reasons oo is so good at solving problems is because it's so good at creating them :)
23:22:48 <lambdabot> Maybe you meant: faq free
23:22:54 <metaperl> ?where frag
23:22:55 <lambdabot> http://www.haskell.org/haskellwiki/Frag
23:23:06 <metaperl> monochrom - he wrote Frag
23:23:37 <metaperl> lispy: one of the reasons oo is so good at solving problems is because it's so good at creating them :)
23:23:38 <metaperl>     --- LOL
23:24:30 <dons> Frag is basically newbie haskell code
23:24:35 <dons> its very interesting in that sense
23:24:42 <dons> though he does use the ffi quite well
23:24:57 <lispy> dons: it's unorthodox and unconventional at times?
23:25:02 <lispy> perhaps, clever in new ways?
23:25:16 <dons> well, it often could be rewritten to use library functions
23:25:21 <lispy> but hopefully not in a pleac way :)
23:32:02 <metaperl> a type is a collection of values. a type class is a collection of types
23:32:45 <metaperl> a value is a collection of...?
23:32:50 <metaperl> semantic attributes?
23:34:22 <monochrom> a value is not a collection of anything
23:34:46 <metaperl> 5 is a collection of 0s and 1s
23:34:48 <monochrom> I mean there ought to be a well-foundedness.  this decomposition can't go on forever.
23:35:04 <metaperl> yes, I was just pontificating
23:35:49 <monochrom> 5 is a collection of 0s, 1s, and 2s.  We are using a three-valued logic and tenary number system.
23:36:44 <metaperl> 5 is succ . succ. succ. succ . succ $ 0
23:37:54 <dons> its all Z or S Z :)
23:39:06 <monochrom> This OO thing has really poisoned many minds.
23:45:12 <Cale> a type class is really more than just a collection of types though
23:45:46 <Cale> It's also an implementation of an interface for each of the types in it (or tuples of types, in the case of MPTCs)
23:45:59 <metaperl>  yes
23:48:23 <opqdonut> \omega = S(\mathbb{N})
23:48:52 <Cale> no, \omega = \mathbb{N}
23:49:02 <opqdonut> Cale: no
23:49:15 <Cale> no?
23:49:45 <opqdonut> \matbb{N} is finite since all of it's members are finite
23:49:57 <Cale> no it's not
23:50:12 <Cale> it's in bijection with a subset of itself even
23:50:12 <lispy> countable, but not finite
23:50:17 <Cale> An ordinal is the set of ordinals less than it
23:50:45 <sieni> and the total mass of earth is less than a kilogram, since all its atoms weigh less than a kilogram
23:51:04 <Cale> just because all of your members are finite sets, doesn't mean that there are finitely many members
23:51:05 <opqdonut> hmm, yes i'm sorry \omega +1 = S(\mathbb{N})
23:51:13 <Cale> right
23:51:42 <opqdonut> which isn't a cardinal and so on
23:56:17 <metaperl> shouldnt the signature for the Enum type class have incr and decr operations?
23:56:38 <metaperl> incr 'c' -- yields 'd'
23:56:49 <metaperl> > 'c' .. 'e'
23:56:50 <lambdabot>  Parse error
23:57:06 <metaperl> Char is not an instance of Enum? is anyone awake? :)
23:57:22 <wolverian> > ['c'..'e']
23:57:23 <lambdabot>  "cde"
23:57:27 <dons> ?instances Enum
23:57:28 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
23:57:29 <metaperl> ah, thanks wolverian
23:57:36 <metaperl> ah thanks dons
23:57:56 <metaperl> > enumFromTo 'c' 'e'
23:57:58 <lambdabot>  "cde"
23:58:03 <metaperl> c000l
23:58:08 <sieni> metaperl: what should incr 4.27 retunr?
23:58:09 <sieni> rn
23:58:26 <metaperl> sieni why 5.27 of course
23:58:30 <metaperl> oh good point
23:58:33 <metaperl> 4.28
23:58:38 <metaperl> heh
23:58:54 <metaperl> Float shouldnt be part of Enum perhaps?
23:59:05 <metaperl> > enumFromTo 4.27 5.00
23:59:07 <lambdabot>  [4.27,5.27]
23:59:23 <metaperl> > enumFromTo 4.27 10.28
23:59:25 <lambdabot>  [4.27,5.27,6.27,7.27,8.27,9.27,10.27]
23:59:42 <metaperl> sieni - there's your answer... or rather _an_ answer :)
23:59:44 <sieni> > [4.27,4.28,..,4.40]
23:59:44 <lambdabot>  Parse error
23:59:50 <sieni> > [4.27,4.28..4.40]
23:59:51 <lambdabot>  [4.27,4.28,4.290000000000001,4.300000000000002,4.310000000000002,4.320000000...
23:59:52 <sieni> oopsie
