00:00:01 <bd_> er
00:00:03 <bd_> c
00:00:07 <Syrin> Oh
00:00:09 <Syrin> Yyyyes
00:00:11 <bd_> the matrix of values we want to frob to zero
00:00:14 <Syrin> No wait.
00:00:20 <Syrin> No, it shouldn't
00:00:23 <Syrin> Because
00:00:33 <Syrin> You're adding linear combinations of the different techniques in the t list
00:00:34 <bd_> but in the paste you gave, we're adding our value in x, then passing it to y again... which would mess up the path
00:00:38 <Syrin> If it passed c as well
00:00:43 <Syrin> Then all the checkpaths would ever get
00:00:44 <Syrin> is c
00:00:51 <Syrin> So it would never ever reach [0,0,0,0,0] and return ""
00:00:55 <Syrin> Which would then return the path
00:00:55 <bd_> I'm confused XD
00:01:05 <Syrin> lol..
00:01:09 <Syrin> Okay, so, example
00:01:32 <Syrin> checkpath [0,0,0,1,0,0,0,0] [0,0,0,0,1] 7 7
00:01:41 <Syrin> It would skip all the 0s until it hit 1
00:01:47 <bd_> okay
00:01:49 <bd_> so
00:01:50 <bd_> what about
00:01:53 <Syrin> Then
00:02:00 <Syrin> First
00:02:04 <bd_> checkpath [2] [0.0.0.0.1] 1 1
00:02:07 <bd_> or something
00:02:11 <Syrin> That would actually be
00:02:13 <bd_> I might have those last numbers wrong
00:02:15 <Syrin> checkpath [2] [0,0,0,0,1] 0 0
00:02:16 <bd_> but point is
00:02:17 <Syrin> Yea
00:02:19 <Syrin> it's length -1
00:02:31 <bd_> x will contain [0,0,0,0,1] + strategy 2
00:02:31 <Syrin> point is, that would immediately return false :p
00:02:37 <Syrin> Strategy 0
00:02:42 <Syrin> That's the confusing part, yes
00:02:49 <bd_> y will be checkpath [1] ([0,0,0,0,1] + strategy 1) 1 1
00:02:49 <Syrin> The location in the (p:ps)
00:02:50 <bd_> ?
00:02:56 <Syrin> Is the location to use in t
00:03:01 <Syrin> So if it's [0,0,0,2]
00:03:05 <Syrin> then it would use strategy 4 2 times
00:03:09 <bd_> nono
00:03:13 <Syrin> That's how it works, yes
00:03:14 <bd_> (p:ps) = [1]
00:03:19 <bd_> c = [0,0,0,0,1]
00:03:24 <bd_> how doesit recurse?
00:03:26 <Syrin> Then
00:03:30 <bd_> we end up calling
00:03:39 <bd_> checkpath [0] [4,4,4,0,-3] 1 1
00:03:40 <Syrin> in  if (not (cyphcheck x) ||y == "false") then checkpath ps c (i-1) l else
00:03:43 <Syrin> The checkpath right there
00:03:46 <bd_> and setting y to that
00:03:58 <Syrin> Yyyes
00:04:00 <Syrin> except
00:04:11 <Syrin> it would be checkpath [0] [4,4,4,0,-3] 0 0
00:04:12 <Syrin> :P
00:04:29 <bd_> well, okay, but, if my understanding is correct
00:04:30 <Syrin> And then
00:04:36 <bd_> and the [0] represents the path to get there frmo the start
00:04:37 <bd_> then
00:04:42 <Syrin> no, no
00:04:44 <bd_> we have an incomplete path
00:04:49 <Syrin> Yes, an incomplete path
00:04:52 <Syrin> so it returns "false"
00:04:54 <Syrin> well
00:04:56 <bd_> because it should either be [1,0] or c = [0,0,0,0,-4]
00:05:18 <bd_> since you're trying to branch out to other possibilities at this depth
00:05:21 <Syrin> I think I'm confused as to just how YOU are confused
00:05:25 <bd_> XD
00:05:27 <bd_> okay
00:05:35 <bd_> let me outline what I /think/ your logic is
00:05:39 <Syrin> Have you tried running it in GHCi or anything?
00:05:42 <Syrin> Oh, dear, logic
00:05:49 <Syrin> I had to work like an hour trying to fit my logic in to this :(
00:05:56 <bd_> I'm trying to think my way through it. It'll be a nice exercise :P
00:06:53 <bd_> checkpath takes four arguments: The first is the strategy to take, the second the current partial puzzle, the second is how deep we are in the puzzle (how many strategies we've applied) and the last is the total strategy depth
00:07:14 <Cale> [[1,0,1,0,1],[-1,-2,0,1,0],[-1,-2,0,1,0],[0,0,0,1,1]] -- is this a solution to [-1,-4,1,3,2], or am I misunderstanding something?
00:07:27 <JohnnyL> what part of the world is speaking now?
00:07:30 <Syrin> That...
00:07:31 <bd_> checkpath starts by computing the puzzle plus  the value of the first strategy in the list. It then tries to apply the strategy one /less/ than that - upon the partially solved puzzle!
00:07:33 <Syrin> would not be a solution
00:07:42 <Syrin> Add them together and you don't get [0,0,0,0,0]
00:07:53 <Syrin> Yes
00:07:54 <Syrin> Correct
00:08:02 <Syrin> And if that puzzle goes out of bounds in any way
00:08:13 <Syrin> I.E, if one of the cyphers goes above 4 or below -4
00:08:15 <bd_> wait
00:08:16 <bd_> but
00:08:19 <Cale> er, sorry, I must be misunderstanding something, it's pretty late :)
00:08:20 <bd_> one thing I don't understand
00:08:28 <bd_> is why say
00:08:29 <Syrin> then that path to take is wrong, so don't follow it, and change indices to the next one
00:08:30 <bd_> with a path of [20]
00:08:31 <Syrin> and start over again
00:08:37 <bd_> we'll add up all 20 strategies into y
00:08:42 <Syrin> ...no
00:08:51 <Syrin> You would add up t !! 0, 20 times
00:09:00 <bd_> oh
00:09:02 <bd_> ic
00:09:06 <bd_> ohh
00:09:12 <Syrin> If it's a path of [1,1,1,1,1], you would add t 0 through 4
00:09:13 <bd_> okay, that makes sense now
00:09:13 <Syrin> 1 time each
00:09:15 <Syrin> Yes
00:09:18 <Syrin> I thought you were confused there
00:09:23 <Syrin> But then you were talking about other stuff :(
00:09:26 <bd_> all right.
00:09:33 <bd_> yeah, I was thinking p was the strategy
00:09:36 <bd_> but it's actually (l-i)
00:09:42 <Syrin> Yes.
00:09:44 <Syrin> :P
00:09:50 <Syrin> That's why I have to have the l and i in there
00:10:43 <bd_> wouldn't this be most efficiently solved by treating it as a system of linear equations and solving it?
00:10:53 <Syrin> Problem is
00:10:58 <Syrin> It has to be non-negative integer solutions
00:11:03 <Cale> What's the original problem?
00:11:15 <Syrin> because it's not like you can apply 0.1982731 of strategy 1
00:11:22 <Syrin> along with -1.2983719 of strategy 6
00:11:31 <bd_> Syrin: Do it modulo (largenumber)?
00:11:34 <Cale> Find a positive integer combination of the t's which gives a given 5-tuple?
00:11:41 <Cale> Is that it?
00:11:58 <Syrin> Well
00:12:05 <Syrin> Which gives a NEGATIVE given 5-tuple, rather
00:12:12 <Cale> ah, okay
00:12:22 <Syrin> Because you want the end result to be [0,0,0,0,0] when you add up all the ts with the 5-tuple bit
00:12:31 <Syrin> Even though it's not a tuple, it's a list
00:12:38 <Cale> well, yes
00:12:47 <Cale> I'm thinking about it purely mathematically at this point
00:12:50 <Syrin> :p
00:12:56 <dons> ?where+ newpopen darcs get http://www.cse.unsw.edu.au/~dons/code/newpopen
00:12:57 <lambdabot> Done.
00:12:58 <dons> :)
00:13:50 <Syrin> Man, I can't wait until I actually understand more than 1/8th of the funky words in this channel
00:14:10 <Cale> So [[4,4,4,0,-4],[1,0,1,0,1],[1,0,1,0,1],[0,1,-1,0,-1],[0,1,-1,0,-1],[-2,-2,0,0,1]] is a solution to [-4,-4,-4,0,3]
00:14:25 <Syrin> Depends
00:14:33 <Syrin> One of the original stipulations was that
00:14:39 <Syrin> At any given time, after adding one strategy
00:14:52 <Syrin> none of the 'cypher' bits (each of the five values of the list) can be greater than 4 or less than -4
00:14:57 <Cale> right
00:15:07 <Cale> and you start out with the thing you're solving
00:15:17 <Syrin> Yes
00:15:18 <bd_> Syrin: can you, for example, apply strategy 1, then 2, then 1?
00:15:24 <Syrin> Uhm, yes
00:15:26 <bd_> or must they be applied in order?
00:15:31 <Syrin> No, they don't have to be
00:15:33 <Syrin> Oh, dear
00:15:40 <Cale> > scanl (zipWith (+)) [-4,-4,-4,0,3] [[4,4,4,0,-4],[1,0,1,0,1],[1,0,1,0,1],[0,1,-1,0,-1],[0,1,-1,0,-1],[-2,-2,0,0,1]]
00:15:41 <Syrin> I think I realised how the script failed
00:15:42 <lambdabot>  [[-4,-4,-4,0,3],[0,0,0,0,-1],[1,0,1,0,0],[2,0,2,0,1],[2,1,1,0,0],[2,2,0,0,-1...
00:15:49 <Cale> grr
00:15:55 <Syrin> Har de har har
00:15:56 <Cale> > drop 5 $ scanl (zipWith (+)) [-4,-4,-4,0,3] [[4,4,4,0,-4],[1,0,1,0,1],[1,0,1,0,1],[0,1,-1,0,-1],[0,1,-1,0,-1],[-2,-2,0,0,1]]
00:15:58 <lambdabot>  [[2,2,0,0,-1],[0,0,0,0,0]]
00:16:13 <Syrin> They don't have to be applied in order
00:16:13 <Cale> looks like a solution :)
00:16:18 <Syrin> But that's how my script solves it
00:16:20 <Syrin> Is in order
00:16:26 <bd_> > 4^20
00:16:27 <lambdabot>  1099511627776
00:16:29 <Syrin> so -1,-4,1,3,2 has a solution, but it's out of order :(
00:16:30 <Cale> Well, the order matters with that bound condition
00:16:37 <Syrin> Yes, it does
00:16:41 <Syrin> But I mean like
00:16:55 <Syrin> My solution only goes across the indices, and never goes back
00:17:00 <Cale> ah, right
00:17:02 <Syrin> So it checks strategy 1, then 2, then 3
00:17:05 <Cale> You might miss solutions then
00:17:06 <Syrin> but never 1 then 2 then 1
00:17:08 <Syrin> Yes.
00:17:20 <Syrin> Hmm
00:17:21 <Cale> What's that one you can't solve again?
00:17:25 <Syrin> -1,-4,1,3,2
00:17:36 <Syrin> It's easy if you apply t !! 12
00:17:42 <Syrin> It runs fine in the script then
00:17:56 <Syrin> hmm
00:17:58 <Cale> I'll look for full solutions in 7 steps.
00:18:24 <bd_> > 4 ^ 7
00:18:25 <lambdabot>  16384
00:18:27 <Syrin> It seems I'll have to change it so that it goes back to index 0 with a different path :(
00:18:30 <bd_> feasible
00:18:39 <lisppaste2> Cale annotated #32573 with "full brute force" at http://paste.lisp.org/display/32573#1
00:18:58 <bd_> Syrin: well, you can just ignore the bounds limits, find possible solutions, then figure out if there's a sane ordering...
00:19:04 <Syrin> I tried that
00:19:11 <Syrin> I did do that, I had a 'permutations' function
00:19:14 <Syrin> It took so horribly, horribly long
00:19:21 <Syrin> about 5 minutes to get the first solution
00:20:12 <bd_> mmm nondeterminism
00:20:20 <Syrin> uh
00:20:22 <Syrin> Does that work?
00:20:25 <Syrin> that script..
00:20:28 <Cale> yes
00:20:41 <Syrin> How does zipWith() work then? >_>
00:20:41 <Cale> It's slow, because it tries *all* possibilities
00:20:44 <Cale> but it works
00:21:08 <Cale> t is an element chosen from tech (in all possible ways)
00:21:11 <Syrin> Because you're applying it to a nested list and just a regular list
00:21:15 <Cale> no
00:21:18 <Syrin> No..
00:21:18 <Cale> t isn't tech
00:21:19 <shankys> I was wondering if anyone could tell me how to print a string like "foo\nbar\nbaz" as "foo" then "bar" then "baz" all on different lines in the interpretter (I'm trying to get readable xhtml in ghci using the xhtml combinator library).
00:21:21 <Syrin> Okay :(
00:21:27 <Cale> (note that I've renamed t)
00:21:31 <Syrin> yes
00:21:36 <bd_> shankys: putStr (string)
00:21:41 <Syrin> I guess I'm just confused on the t <- tech bit?
00:21:42 <bd_> or putStrLn
00:21:49 <bd_> Syrin: it's using the list monad
00:21:54 <shankys> bd_: Oh duh! Thanks.
00:21:56 <Cale> Syrin: yeah, that says that t is one of the elements of tech
00:22:04 <Syrin> Ooookay.
00:22:09 <Cale> Syrin: and it's going to try all of them
00:22:09 <shankys> OMG, I'm an idiot...
00:22:11 <Syrin> :S
00:22:13 <Syrin> Oh
00:22:18 <Syrin> That's cool, I think
00:22:33 <Cale> and the guard there causes it to backtrack if the condition is false
00:22:35 <Syrin> And suddenly the way the set notation thing works...
00:22:37 <Syrin> becomes clear. :o
00:22:58 <bd_> list comprehensions, you mean? :)
00:23:00 <Syrin> Really! Another neat notation
00:23:04 <Cale> okay, there are no solutions of length 7 of [-1,-4,1,3,2]
00:23:12 <Syrin> Yea, those [f x | x <- xs] things
00:23:18 <Cale> right, list comprehensions
00:23:34 <Cale> that's basically the same as this, but for the time being, do notation is more general
00:23:48 <Cale> (it can be used with things that aren't lists)
00:23:53 <Syrin> I look at what you did...
00:24:01 <Syrin> and I realise it took you like 2 minutes tops
00:24:05 <Cale> yep
00:24:10 <Syrin> And it makes me sad that it would take me about 20 :(
00:24:19 <Cale> don't worry :)
00:24:27 <Cale> It's just something that you get used to
00:24:54 <Syrin> Goddamnit, now windows is pestering me to restart my computer for some updates that I most definitely did NOT install. H8 :(
00:25:01 <bd_> Syrin: net stop wuauserv
00:25:08 <Cale> I spent a whole summer being paid to write a nondeterministic search program like this, in the list monad in Haskell :)
00:25:09 <bd_> will make it shut up until reboot
00:25:14 <Syrin> net stop?
00:25:20 <bd_> Syrin: yeah, in start->run
00:25:27 <bd_> it'll kill the service responsible for those alerts
00:25:41 <Syrin> net stop wuauserv
00:25:42 <Syrin> alright
00:25:53 <Cale> whee, lots of solutions of length 8
00:25:58 <Syrin> Wow, that kicks ass, thanks
00:25:59 <Cale> [[1,0,1,0,1],[1,0,1,0,1],[1,1,0,-1,0],[0,1,-1,-1,0],[0,1,-2,0,-1],[-1,1,-1,-1,1],[3,-3,-3,0,0],[-4,3,4,0,-4]]
00:26:11 <Syrin> You did that from the bruteforce thing?
00:26:14 <Cale> yeah
00:26:32 <Syrin> How long, approximately, did it take?
00:26:34 <dons> ?remember Cale I spent a whole summer being paid to write a nondeterministic search program like this, in the list monad in Haskell
00:26:40 <Cale> heh
00:27:07 <Cale> Syrin: about 1/10 of a second, once I had the right length
00:27:16 <Syrin> >_>
00:27:28 <Cale> er, not quite
00:27:31 <Cale> about a second
00:27:44 <Syrin> hmm
00:27:50 <Cale> I was confused by the fact that it gets about 100 of them right away
00:27:53 <Syrin> okay, first off, sorry, but:
00:27:59 <Syrin> the cyphcheck function
00:28:01 <Syrin> How does that work? >_<
00:28:07 <Cale> mapM_ print $ solve 8 [-1,-4,1,3,2]
00:28:15 <Cale> (that's what I'm typing in ghci)
00:28:25 <Cale> cyphcheck just says
00:28:33 <bd_> Syrin: the all function takes some predicate, and checks if it's true for all elements of a list
00:28:43 <Syrin> Ah
00:28:44 <Cale> check that all the values in the list have absolute values less than or equal to 4
00:28:49 <bd_> so with cyphcheck, we say, for all n in some list, check that the abs value is <= 4
00:28:56 <Cale> > all even [2,4,0,6,8]
00:28:58 <lambdabot>  True
00:29:00 <Cale> > all even [2,4,0,7,8]
00:29:01 <lambdabot>  False
00:29:09 <Syrin> Iiinteresting
00:29:10 <bd_> > none even [1,3,5,7]
00:29:10 <lambdabot>  Not in scope: `none'
00:29:13 <bd_> aw
00:29:17 <Syrin> Hehe
00:29:22 <bd_> > let none = all . not in none even [1,3,5,7]
00:29:23 <lambdabot>  Couldn't match `a -> Bool' against `Bool'
00:29:23 <Cale> > any even [1,3,5,7]
00:29:25 <lambdabot>  False
00:29:34 <Cale> > any even [1,3,4,7]
00:29:35 <bd_> > let none = all . (not ,) in none even [1,3,5,7]
00:29:35 <lambdabot>  True
00:29:36 <lambdabot>  Parse error
00:29:43 <Syrin> So none would be not any
00:30:07 <bd_> > let none = all . (not .) in none even [1,3,5,7]
00:30:08 <lambdabot>  True
00:30:12 <Cale> > let none p = not . any p in none even [1,3,5,7]
00:30:13 <lambdabot>  True
00:30:18 <bd_> there we go. and, yeah, I guess, not . any works too :p
00:30:18 <Syrin> Who cares :(
00:30:40 <Syrin> Hmm
00:30:40 <dons> ?users
00:30:41 <lambdabot> Maximum users seen in #haskell: 291, currently: 229 (78.7%), active: 23 (10.0%)
00:31:07 <Syrin> So this solve function
00:31:16 <Syrin> Is basically equivalent to cyphcheck
00:31:24 <Cale> er
00:31:28 <Syrin> Well
00:31:30 <Syrin> I mean, in that
00:31:51 <Syrin> It returns paths whereby that path will be within the bounds of the puzzle
00:31:55 <Cale> First it checks to see if the thing is already solved, in which case it returns one solution, which is empty
00:31:59 <Syrin> Yes
00:32:04 <Syrin> No, I understand the logic
00:32:20 <Cale> yeah
00:32:23 <Syrin> hmm
00:32:30 <Cale> It always returns valid paths
00:32:48 <Cale> you can check a path with
00:33:02 <Syrin> What iiiif
00:33:20 <Cale> cyphcheck . concat . foldr (zipWith (+)) thingtosolve $ path
00:33:27 <Cale> er
00:33:29 <Syrin> I wanted it to return a string of numbers, like with the current checkpath function? :p
00:33:31 <Cale> cyphcheck . concat . scanl (zipWith (+)) thingtosolve $ path
00:33:38 <Cale> oh
00:33:46 <Cale> sure
00:34:21 <Syrin> Erm, what does the $ thing do?
00:34:44 <Cale> f $ x = f x, but $ has really low precedence
00:34:56 <Cale> so it's sort of like wrapping either side of it in parens
00:34:57 <Syrin> oh
00:35:13 <Syrin> wrapping either side of x in parens?
00:35:21 <Cale> either side of the $
00:35:29 <Cale> so that's the same as
00:35:32 <Syrin> What?
00:35:35 <Cale> (cyphcheck . concat . scanl (zipWith (+)) thingtosolve) path
00:35:45 <Syrin> Oh
00:36:31 <Syrin> Aaand
00:36:36 <Syrin> logically, that does...
00:36:52 <Syrin> Okay, I'm not quite sure.
00:36:56 <Syrin> :(
00:37:05 <bd_> :t scanl
00:37:07 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
00:37:17 <Cale> scanl (+) 0 [1,2,3,4,5]
00:37:20 <Cale> > scanl (+) 0 [1,2,3,4,5]
00:37:22 <lambdabot>  [0,1,3,6,10,15]
00:37:26 <Syrin> that doesn't help at all, lol
00:37:31 <Cale> okay :)
00:37:34 <Syrin> Yea, I know what scanl does
00:37:38 <Cale> oh
00:37:41 <Syrin> the forall bit is confusing as all crap
00:37:45 <Cale> do you know what (.) does?
00:37:52 <Cale> oh, ignore the forall
00:37:56 <Syrin> that (a -> b -> a) -> a -> [b] -> [a] makes not a lick of sense
00:38:25 <Cale> okay, but you know what scanl does?
00:38:28 <Syrin> Yes
00:38:30 <Cale> okay :)
00:38:32 <Syrin> And I know that . is composition
00:38:40 <Cale> right
00:38:47 <Syrin> so f . g x = f (g x )
00:38:47 <cerculetz> Cale: you're letting that slide by ? :D
00:39:01 <Cale> (f . g) x = f (g x), yes
00:39:27 <Syrin> I think the way Haskell does association messes me up though
00:40:01 <lisppaste2> Cale annotated #32573 with "with indices" at http://paste.lisp.org/display/32573#2
00:40:01 <bd_> wouldn't f . g x = f . (g x) ?
00:40:07 <Syrin> yea
00:40:07 <Cale> bd_: yes
00:40:13 <Syrin> that stupid association stuff :(
00:40:29 <Cale> The thing to remember is that function application is *always* first
00:40:35 <Cale> before any operator
00:41:09 <Cale> and function application associates to the left, so  f x y z = ((f x) y) z
00:41:35 <Cale> btw, that paste shows how to do it with indices
00:41:54 <Cale> One thing to note about the way that I wrote it is that I've completely avoided using !!
00:41:58 <Syrin> I'm sure it shows somebody something, yes :(
00:42:09 <Cale> Having trouble?
00:42:19 <Syrin> the zip [0..] tech bit
00:42:23 <Cale> okay
00:42:29 <Cale> > zip [0..] "Hello"
00:42:31 <lambdabot>  [(0,'H'),(1,'e'),(2,'l'),(3,'l'),(4,'o')]
00:42:38 <Syrin> Oh
00:42:58 <Syrin> So
00:42:59 <Syrin> oh
00:43:01 <Syrin> makes sense
00:43:04 <Cale> :)
00:43:06 <pjd> Syrin: in function type signatures, you can think of everything before the last (rightmost) -> as parameters, and the thing after it as the result
00:43:16 <Syrin> Yea
00:43:21 <Syrin> oh.
00:43:32 <Syrin> But what about those data signature things? :(
00:43:39 <Syrin> Where it's just a bunch of arrows eeeeverywhere
00:43:43 <Cale> type signatures?
00:43:49 <Cale> @type length
00:43:50 <lambdabot> forall a. [a] -> Int
00:43:52 <Syrin> I dunno, I guess.
00:43:59 <Cale> ignore the "forall a." for a moment
00:44:00 <Syrin> For when you define your own data types
00:44:03 <Syrin> like
00:44:06 <Cale> oh, that's different
00:44:13 <pjd> so that signature above is a function that takes three parameters, "(a -> b -> a)", "a", and "[b]", and returns "[a]"
00:44:24 <Syrin> and
00:44:24 <Syrin> ah
00:44:25 <Cale> data List a = Nil | Cons a (List a)
00:44:30 <Cale> those?
00:44:35 <Syrin> (a->b->a) is a function, then?
00:44:39 <Syrin> Yea, things like that
00:44:41 <pjd> yeah, exactly :)
00:44:43 <Cale> a -> b -> a is a type of functions
00:44:50 <bd_> @djinn a -> b -> a
00:44:51 <lambdabot> f a _ = a
00:45:02 <dons> ?. pl djinn a -> b -> a
00:45:03 <lambdabot> f = const
00:45:03 <bd_> @. pl djinn a -> b -> a
00:45:04 <lambdabot> f = const
00:45:12 <bd_> he
00:45:15 <bd_> h
00:45:20 <pjd> so the first parameter is a function that takes an "a" and a "b" and returns an "a"
00:45:27 <Syrin> yea
00:45:31 <Syrin> yea, I understand all that now
00:45:48 <Syrin> I was just trying to mesh together the custom data type signature arrow things
00:45:51 <Syrin> with the function arrow things
00:46:20 <Syrin> I probably shouldn't be using 'thing', as it's a little ambiguous
00:46:37 <Syrin> But it's about the extent of my haskell vocabulary :(
00:46:47 <Syrin> So
00:46:52 <Syrin> I...
00:46:56 <sjanssen> @pl \x -> p x && q x
00:46:56 <lambdabot> liftM2 (&&) p q
00:46:58 <Syrin> am going to try out this function you've made
00:47:04 <sjanssen> ah yes
00:47:18 <Syrin> How do you do the multi-line comment, again?
00:47:20 <Syrin> {- -}?
00:47:24 <dons> Cale: so you going to cabalise and release hrss?
00:47:26 <sjanssen> this week's Ruby Quiz is easy-peasy
00:47:28 <bd_> Syrin: yep
00:47:33 <Cale> dons: tomorrow, I'm about to sleep
00:47:40 <dons> sjanssen: solutoin up on the hasekll Qiuz page yet? :)
00:47:59 <Syrin> I should probably sleep some time soon
00:48:06 <Syrin> it's 3:45 am
00:48:11 <dons> sjanssen: did you see http://cale.yi.org/index.php/HRSS ?
00:48:14 <lambdabot> Title: HRSS - CaleWiki
00:48:15 <Cale> How many other practical programming languages are there where you have libraries where the documentation is some guy's M.Sc. thesis? :)
00:48:21 <dons> hehe
00:48:34 <dons> we have the technology!
00:49:01 <sjanssen> dons: there's supposed to be a 48 hr. no spoiler period for Ruby solutions.  Trying to decide whether that applies to Haskell
00:49:51 <dons> sjanssen: if you're pondering some code to write, I'd like to nut out a really nice elegant process interface (one that I woulldn't  be embarrased to put online in a tutorial), http://www.cse.unsw.edu.au/~dons/code/newpopen/
00:49:52 <lambdabot> Title: Index of /~dons/code/newpopen
00:50:03 <dons> if you'd like to look into say, python/ocaml/erlang process interfaces
00:50:11 <dons> to see if there's some nice ideas to steal....
00:50:20 <dons> or perhaps a few test programs for the kind of things we'd like to write
00:50:32 <dons> even, look at the open "| date" or open "date |" in perl...
00:50:36 <dons> and how we could do that
00:51:35 <Syrin> well
00:51:39 <Syrin> night
00:51:46 <Syrin> Thanks for all your help
00:52:14 <Cale> Who is Jason Dagit on IRC?
00:52:27 <dons> sjanssen: and, can we do it portably without so much Control* (Mvar)et al ) stuff
00:52:29 <Cale> lispy?
00:52:30 <dons> Cale, lispy
00:52:33 <Cale> okay
00:52:48 <Cale> I'll have to ask him for his syntax colouring stuff for MediaWiki
00:53:01 <Cale> 'night all
00:53:33 <dons> is that what we use on h.o ?
00:53:35 <dons> night Cale
00:53:40 <Cale> yeah, apparently
00:53:58 <Cale> Something called geshi, together with some stuff he did
01:02:47 <dons> ?yow!
01:02:48 <lambdabot> BELA LUGOSI is my co-pilot ...
01:05:16 <Pastorn> haha, cool
01:13:10 <robreim> What were the reasons monad comprehensions were removed from haskell?
01:14:54 <dons> it made teaching h98 hard, since list comprehenions would return errors about monads
01:15:02 <dons> back when teaching haskell was the main activity :)
01:15:15 <dons> we can add them back now, with a -fmonad-comprehensions flag
01:20:39 <jdroid-> hi. i'm looking to try haskell for the first time. which implementation should i try first?
01:20:47 <dons> ghc
01:20:52 <dons> http://haskell.org/ghc
01:20:53 <lambdabot> Title: The Glasgow Haskell Compiler
01:21:02 <jdroid-> ok. neat.
01:21:13 <jdroid-> is emacs good with haskell on it's own ?
01:21:23 <dons> yep
01:21:25 <jdroid-> lisp has slime and erlang has some fancy stuff too.
01:22:27 <robreim> I don't see -fmonad-comprehensions. Is there plans to add it?
01:22:49 <dons> there's a nice haskell-mode, http://haskell.org/haskellwiki/Haskell_mode_for_Emacs
01:22:51 <lambdabot> Title: Haskell mode for Emacs - HaskellWiki
01:23:03 <dons> jdroid-: also, you'll want a good tutorial, I suspect. there's some good ones linked from haskell.org
01:23:08 <dons> in particular
01:23:09 <dons> ?where yaht
01:23:10 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
01:23:26 <dons> robreim: its been said that the patch will be accepted if someone writes it :)
01:23:41 <jdroid-> I just found a tutorial for haskell on reddit, actually
01:23:51 <jdroid-> http://cgi.cse.unsw.edu.au/~dons/blog/2006/12/16#programming-haskell-intro
01:23:53 <lambdabot> Title: Haskell hacking, http://tinyurl.com/yz4kdc
01:23:55 <dons> oh hehe
01:24:04 * dons <--
01:24:04 <robreim> haskell-mode's nice, but don't expect anything quite as featureful as slime :)
01:24:22 <jdroid-> slime might be the coolest programming mode i've ever seen
01:25:14 <jdroid-> thank you ubuntu. gci + haskell-mode now installed. :)
01:25:18 <dons> cool
01:25:23 <dons> let us know how you go
01:25:59 <jdroid-> ok
01:28:04 <jdroid-> neat. compiled and interpretted.
01:40:18 <joelr1> good morning
01:40:21 <jdroid-> In this code: main = putStrLn "G'day, world!" : is it correct to say main points to a function that prints a line and ghc evaluates whatever mani points to?
01:41:05 <jdroid-> that's an interesting way of writing it
01:43:28 <pjd> ...points to a function that describes the action that prints a line that's wrapped in a monad that's pointed to by main that's unwrapped by ghc?
01:44:07 <dons> jdroid-: yes, main is the entry point.
01:44:10 <dons> heya joelr1
01:44:27 <ph8> ?type findWithDefault
01:44:28 <lambdabot> Not in scope: `findWithDefault'
01:45:02 <jdroid-> pjd: i'm brand new to haskell... mind explaining how a monad is involved there?
01:45:11 <araujo> hah
01:45:17 <tessier_> monads...the newbies bane...
01:45:27 * araujo recommends jdroid- doing some previous lecture before :-)
01:45:36 <jdroid-> :)
01:45:37 <joelr1> dons: grabbing HAppS
01:45:50 <araujo> @where monads
01:45:51 <lambdabot> http://www.nomaware.com/monads/html/index.html
01:45:57 <araujo> jdroid-, ^^
01:46:07 <pjd> jdroid-: don't mind me, just thinking aloud :)
01:46:28 <ph8> ?type Data.findWithDefault
01:46:29 <lambdabot> Couldn't find qualified module.
01:46:34 <ph8> ?type Data.Map.findWithDefault
01:46:35 <pjd> jdroid-: the IO monad is what's involved, though
01:46:36 <lambdabot> forall a k. (Ord k) => a -> k -> Data.Map.Map k a -> a
01:46:39 <ph8> third time lucky ;)
01:46:42 <joelr1> dons: it looks like i finally satisfied requirements for opening a trading account at http://interactivebrokers.com, so i need to write some quote-capturing software.
01:46:51 <jdroid-> pjd: oh, ok. that makes sense.
01:47:04 <jdroid-> pjd: is the monad ensuring the output is in the correct order?
01:47:15 <pjd> yep
01:47:31 <jdroid-> neat.
01:47:31 <joelr1> dons: you mentioned that musasabi had something as part of HAppS and Stefan O'Rear announced an interesting serialization library using SYB
01:48:02 <joelr1> dons: so i'm hoping to put all that together to capture real-time stock/futures quotes and store them
01:48:07 <dons> yeah (sorry, coming and going -- cooking dinner)
01:48:09 <dons> ah ok.
01:48:34 <dons> i'd look for tried-and-trusted serialisation, after your previous experience in this area. i.e. NewBinary or the HAppS code
01:48:58 <pjd> jdroid-: if you're interested, http://haskell.org/haskellwiki/IO_inside is a great demystification of the IO monad
01:48:59 <lambdabot> Title: IO inside - HaskellWiki
01:49:05 <jdroid-> _It is not advisable to attempt to absorb all of the material in a single reading_ from the monad link :)
01:49:06 <joelr1> dons: ok
01:49:51 <jdroid-> pjd. thanks. i'm grateful for any links you think are good for a newbie.
01:51:03 <dons> jdroid-: btw, if you're working though today's 'Programming Haskell' tut, i'd welcome any feedback you hvae
01:51:05 <tessier_> After the last newbies head exploded trying to read everything on that monad link there was a lot of paperwork. We'd like to avoid doing that again.
01:51:08 <dons> since that might improve tomorrow's chapter :)
01:51:14 <jdroid-> dons: the one from reddit?
01:51:15 <dons> te	hehe
01:51:27 <dons> jdroid-: yeah (I'm the author)
01:51:30 <jdroid-> oh neat!
01:51:34 <dons> if you look carefully at the url .... ;)
01:51:39 <jdroid-> didn't notice!
01:52:06 <dons> ?remember tessier After the last newbies head exploded trying to read everything on that monad link there was a lot of paperwork. We'd like to avoid doing that again.
01:52:47 <jdroid-> what are concepts people struggle with in terms of monads?
01:53:29 <dons> well, they abstract over the evaluation order, which is a pretty weird idea if you're not used ot it
01:54:05 <dons> so you can control how evaluation takes place. so it could be sequential/imperative, or backtracking/prolog-style, or continutation-based....
01:54:40 <dons> now, that's too much abstraction for those coming from some backed in imperative background (sometimes)
01:54:53 <dons> that's the idea, anyway
01:55:08 <jdroid-> ok. that doesn't seem too bizarre, but we'll see as i work with them.
01:55:21 <dons> yeah, if you've done ocaml or erlang, you should be fine :)
01:55:43 <dons> its more the rusted on imperative guys who freak out
01:56:00 <jdroid-> the "lisp is an academic" guys... :)
01:56:32 <dons> since all of imperative programming is just one small instance of a monad. when you see that what you thought was the whole universe is just a little fish bowl, it can be disorienting :)
01:56:36 <jdroid-> do you guys work professionally with haskell?
01:56:56 <dons> yeah, many here do. I do. joelr does.
01:57:08 <dons> (amongst other things, I think)
01:57:32 <jdroid-> what kind of work is available for haskell programmers? i work in financial services and java runs the show there..
01:57:56 <oliver__> None, unless you're an academic or self employed :)
01:58:18 <oliver__> (Apparently one or two companies use it)
01:58:47 <_matthew-> so err, how's hs-plugins these days with ghc 6.6?
01:59:32 <dons> jdroid-: well, Credit Suisse is employing haskell people now for variou things. also, Jane Street is hiring any functional programmers
01:59:37 <dons> so you could look in to what they're doing
01:59:46 <dons> (they're findable from the haskell.org industry page)
02:00:04 <jdroid-> dons: neat. i'd love to hear what they're using it for.
02:00:30 <dons> ?google cufp
02:00:32 <lambdabot> http://www.galois.com/cufp/
02:00:33 <lambdabot> Title: Commercial Users of Functional Programming Workshop 2006
02:00:44 <jdroid-> does haskell use monads for list order or is that totally different?
02:01:00 <ph8> quick newbie question, how do i put two commands on one line? e.g. myInsert = insertWith x x x x && inserWith y y y y?
02:01:03 <pjd> jdroid-: list order?
02:01:09 <ph8> obviously i've used && there but that's wrong?
02:01:13 <pjd> probably a different thing
02:01:33 <oliver__> ph8, insert to what?
02:02:36 <pjd> it probably doesn't help that lists also happen to be monads, though
02:02:47 <jdroid-> pjd:     home  = ["couch", "chair", "table", "stove"]
02:02:59 <jdroid-> home !! 2 gets table
02:03:09 <jdroid-> pjd: ok. that's what i suspected might be true.
02:03:18 <pjd> jdroid-: yep, no monads involved there
02:03:30 <jdroid-> oh, ok. so how is a list a monad then?
02:03:55 <ph8> Saulzar: a map
02:04:06 <ph8> does that make a difference?
02:04:39 <Saulzar> Yep, .. insertWith returns you a "new" map, yes?
02:04:54 <ph8> ah yes
02:04:58 <ph8> erm
02:04:59 <Saulzar> So you can simply pass your "new" map into another insertWith
02:05:00 <ph8> hmm yes
02:06:18 <jdroid-> dons: ghci seems to not like this line:     home  = ["couch", "chair", "table", "stove"]
02:06:18 <jdroid->  
02:06:35 <pjd> jdroid-: put a "let" before that
02:07:07 <Saulzar> ghci doesn't quite act as if it was reading from source files
02:07:12 <jdroid-> oh, ok.
02:07:42 <jdroid-> dons perhaps that would be worth noting ? the difference between ghci and ghc, that is
02:09:38 <dons> jdroid-: ah right. you're supposed to be writing it to a file.
02:09:44 <dons> yes, i should clarify that
02:09:45 <dons> thanks
02:10:07 <dons> you can add top level bindings to ghci, with, e.g.,  let home  = ["couch", "chair", "table"]
02:10:43 <jdroid-> ok
02:11:19 <jdroid-> i guess it's one of those rare occasions where you get feedback from a newbie with NO experience yet :)
02:11:34 <Korollary> not that rare
02:11:47 <jdroid-> i guess that's true for the haskell world
02:12:02 <Korollary> everybody is a newbie eternally
02:12:34 <Korollary> it is postulated that the amount of papers one needs to read is a diverging series
02:12:48 <jdroid-> clever
02:13:45 <pjd> Korollary: everyone's island of knowledge has a shore of ignorance
02:14:18 <Excedrin> any opinions on the wikibooks Haskell stuff?
02:14:49 <dons> Excedrin: you mean, a community effort to write a couple of books online?
02:14:59 <Korollary> pjd: I've build condos on my beach of ignorance
02:15:05 <dons> hehe
02:15:19 <jdroid-> Korollary: so has most of the entire financial services tech industry
02:15:24 <Excedrin> dons: I'm curious what people think about http://en.wikibooks.org/wiki/Haskell
02:15:34 <Korollary> jdroid-: not the entire industry
02:15:41 <jdroid-> most doesn't mean all
02:15:46 <dons> Excedrin: oh, i think its fairly good, no?
02:15:56 <Korollary> why would one say "most of the entire" anyway
02:16:12 <pjd> jdroid-: re. earlier, the list monad basically implements exhaustive searching
02:16:12 <jdroid-> fair enough
02:16:26 <Korollary> ?time jdroid-
02:16:28 <lambdabot> Local time for jdroid- is Sat Dec 16 05:11:42 2006
02:16:34 <Korollary> yeah it's excusable
02:16:56 <dons> heh
02:17:00 <jdroid-> pjd: oh i see.
02:17:07 <dons> good time to dive into the lambda soup!
02:17:36 <jdroid-> Korollary: yep. it's late. or early. i choose late as i haven't gone to bed yet.
02:17:57 <Excedrin> dons: I hadn't looked at it before, it looks good so far
02:18:03 <pjd> jdroid-: you bind functions to it that map each element to a sublist, and it repeatedly collects those lists together
02:18:21 <jdroid-> ?time Korollary
02:18:23 <lambdabot> Local time for Korollary is Sat Dec 16 02:12:55 2006
02:19:10 <Korollary> ?vixen will you hold me while I sleep?
02:19:10 <lambdabot> isn't it obvious?
02:19:14 <Korollary> no baby
02:19:37 <jdroid-> pjd: ok. can you elaborate? i can see how a monad would allow it to know what it's already checked...
02:20:46 <Excedrin> pjd: that's different from "fmap = map, return x = [x], join = concat" list-as-monad right?
02:21:10 <pjd> Excedrin: i have no idea, sorry :)
02:21:37 <pjd> i'm also still relative newbie too
02:22:19 <Excedrin> instance Monad [] where return x = [x]; join = concat; l >>= f = concat (map f l)
02:23:12 <Excedrin> it's different from Control.Monad.List (which is the search (generate all possibilities) one)
02:24:02 <pjd> jdroid-: this is probably a silly example, but
02:24:05 <pjd> > [1..4] >>= \n -> replicate n n
02:24:06 <lambdabot>  [1,2,2,3,3,3,4,4,4,4]
02:24:27 <dons> jdroid-: any comments on the presentation? the fonts/colours look ok ? :) if i'm going to write another 10 of these, i'd like to get it right now :)
02:24:48 <ph8> ?paste
02:24:48 <lambdabot> http://paste.lisp.org/new/haskell
02:24:50 <dons> (for those following, i'm referring to this tut, http://cgi.cse.unsw.edu.au/~dons/blog/2006/12/16#programming-haskell-intro)
02:24:53 <lambdabot> Title: Haskell hacking, http://tinyurl.com/yz4kdc
02:24:57 <jdroid-> dons: it's all good so far. maybe courier new or something more terminalish for code
02:25:15 <lisppaste2> ph8 pasted "Stuck on mapping functionality" at http://paste.lisp.org/display/32577
02:25:23 <dons> mm. ok.
02:25:28 <ph8> would anyone be able to give me a hint as to how to get over that problem?
02:25:34 <ph8> steep learning curve :s
02:25:40 <jdroid-> dons: but i'm reaching with that one. it's all fine with me so far.
02:25:42 <dons> having a look, ph8..
02:25:45 <ph8> cheers
02:25:47 <dons> jdroid-: ok. great
02:25:58 <ph8> the comment marks what i'm thinking about in mapFile
02:26:05 <ph8> it might be the totally wrong direction of course
02:26:23 <jdroid-> pjd: > [1..4] >>= \n -> replicate n n   what syntax indicates this is a monad?
02:26:25 <dons> ph8, so are you reading that same tutorial?
02:26:35 <ph8> which one's that?
02:26:45 <Korollary> ?type (>>=)
02:26:47 <dons> http://cgi.cse.unsw.edu.au/~dons/blog/2006/12/16#programming-haskell-intro
02:26:47 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
02:26:48 <lambdabot> Title: Haskell hacking, http://tinyurl.com/yz4kdc
02:26:50 <pjd> jdroid-: there's not special syntax, really;  >>= is the monadic bind operator
02:26:52 <dons> it has some readFile / map stuff :)
02:27:01 <ph8> ah cheers i'll have a read
02:27:01 <jdroid-> oh, ok
02:27:22 <pjd> you'll learn about it later when you look at the monad laws and such :)
02:27:32 <jdroid-> dons: what is the significance of parens in a map?
02:27:47 <jdroid-> [("key", "value")]
02:27:52 <jdroid-> is that just syntax for a map?
02:27:55 <dons> ah, thta's a list of pairs
02:27:56 <Korollary> pair constructor
02:27:59 <dons> > (1, 2)
02:28:00 <Excedrin> ph8: insertWith from Data.Map ?
02:28:00 <lambdabot>  (1,2)
02:28:01 <jdroid-> ah, ok
02:28:06 <ph8> yes
02:28:08 <dons> > [1,2,3]
02:28:10 <lambdabot>  [1,2,3]
02:28:17 <dons> > [('a',1),  ('b',2) ]
02:28:18 <lambdabot>  [('a',1),('b',2)]
02:28:23 <Korollary> > (,) 1 2
02:28:24 <lambdabot>  (1,2)
02:28:25 <jdroid-> (1,2,3)
02:28:30 <dons> yep
02:28:31 <Korollary> for added perversion
02:28:33 <Excedrin> > [(1,2,3),(4,2,1)]
02:28:35 <lambdabot>  [(1,2,3),(4,2,1)]
02:28:46 <jdroid-> > (1,2,3)
02:28:47 <lambdabot>  (1,2,3)
02:28:55 <jdroid-> so a pair isn't necessarily 2 items?
02:29:01 <Korollary> > fst (7,3)
02:29:02 <lambdabot>  7
02:29:08 <pjd> jdroid-: tuples aren't
02:29:20 <Excedrin> pair more like tuple
02:29:21 <jdroid-> oh, didn't know it was a tuple.
02:29:37 <Excedrin> > (1,2,3,4)
02:29:39 <lambdabot>  (1,2,3,4)
02:29:51 <dons> ph8: so you want to count the occurence of every char in the file?
02:31:24 <Korollary> ?karma java
02:31:24 <lambdabot> java has a karma of -15
02:31:56 <Korollary> ?keal
02:31:56 <lambdabot> i cant think anymore
02:32:03 <Korollary> ?keal
02:32:03 <lambdabot> i need math friendly compiler to compile for jvm or flash
02:32:21 <Korollary> that's not too bad
02:32:51 <jdroid-> what is keal?
02:33:09 <pjd> jdroid-: sorry, my last message was accidental
02:33:13 <Excedrin> ph8: the "mapFile _ _ = 0" line can't work... 0 is not a Map c d
02:33:23 <Korollary> random quotes of an interesting persona on irc
02:33:44 <Korollary> ?quote glguy
02:33:45 <lambdabot>  that's odd, mine is this big : |-----------------------------|
02:34:13 <jdroid-> pjd: no problem.
02:35:26 <lisppaste2> dons annotated #32577 with "ph8 , fixed" at http://paste.lisp.org/display/32577#1
02:35:28 <dons> ph8: ^^
02:36:37 <dons> ?pl \o _ -> o+1
02:36:37 <lambdabot> const . (1 +)
02:37:54 <jdroid-> dons: putStr :: String -> IO () if this returned a value, would the value be in the parens?
02:38:22 <ph8> cheers dons!
02:38:25 <ph8> your tutorial's pretty goo
02:38:26 <ph8> * good
02:38:57 <pjd> jdroid-: that () indicates no value
02:39:26 <pjd> the empty tuple, i think
02:39:29 <ph8> ?docs foldr
02:39:29 <lambdabot> foldr not available
02:39:32 <ph8> ?help
02:39:33 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
02:39:36 <ph8> ?help list
02:39:37 <lambdabot> list [module|command]
02:39:39 <lambdabot> show all commands or command for [module]. http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
02:39:45 <ph8> ?list
02:39:47 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
02:40:03 <pjd> jdroid-: the IO bit is the IO monad it's wrapped in
02:40:13 <ph8> ?type foldr
02:40:14 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
02:40:26 <dons> jdroid-: nope
02:40:29 <ph8> hmm, is there a way for me to get more info on foldr?
02:40:31 <dons> > () -- is a special value
02:40:33 <lambdabot>  ()
02:40:34 <dons> the 0 tuple
02:40:38 <dons> > (1)
02:40:39 <lambdabot>  1
02:40:41 <dons> > (1,2,3)
02:40:43 <lambdabot>  (1,2,3)
02:40:52 <dons> so if it returned a value, it would be, say:
02:40:56 <dons> :t readFile
02:40:58 <lambdabot> FilePath -> IO String
02:41:08 <jdroid-> i see. neat
02:41:12 <dons> as it is, it returns the 0-tuple, ()
02:41:15 <dons> whose type is ()
02:41:19 <dons> :t ()
02:41:21 <lambdabot> ()
02:41:27 <dons> i.e. () :: ()
02:41:28 <pjd> how do you write a 1-tuple?
02:41:33 <jdroid-> dons: i am enjoying the tutorial, but i need to put my head down and call it a night. so far it's been good and i plan to finish it torrow
02:41:39 <dons> ok. great
02:41:44 <dons> > (1) -- pjd ;)
02:41:45 <lambdabot>  1
02:43:32 <pjd> dons: that makes a kind of sense
02:45:54 <lisppaste2> goltrpoat pasted "am i missing any obvious optimizations here?" at http://paste.lisp.org/display/32579
02:48:51 <goltrpoat> everything does need to be Integer, since there are pretty large numbers being operated on
02:51:03 <goltrpoat> (case anyone cares, the algorithm is at http://www.mathpropress.com/stan/bibliography/spigot.pdf)
02:54:14 <Excedrin> you could use Data.ByteString instead of [char]? ;)
02:54:32 <goltrpoat> i was in the middle of typing that i should probably clarify that i meant optimizations in the list-based version
02:54:33 <goltrpoat> hehe
02:57:13 <goltrpoat> it doesn't seem like that'd give a dramatic performance increase either way -- all access is sequential, save for a handful of reverse calls, and getting rid of 'adjust' doesn't seem to do a whole lot
02:57:20 <goltrpoat> be a bit nicer on the cache though
02:57:27 <Excedrin> aside from that, is using more than one digit per Int feasable?
02:57:57 <goltrpoat> yeah.. it's in base 10, and the paper suggests generating more than 1 digit at a time by switching to base, say, 10000
02:59:02 <goltrpoat> the algorithm isn't really meant to be a speed demon, i guess
02:59:02 <goltrpoat> hehe
03:01:47 <goltrpoat> one thing that surprised me was.. the original version had nextRow returning the new digit as the last element of the list.  computeRow would then extract it with splitAt
03:02:01 <goltrpoat> i thought the pair version would be a lot faster, but it seems to be about the same
03:03:12 <goltrpoat> so then i figured, maybe it's spending all of its time in div and mod
03:03:20 <goltrpoat> but replacing the mod with a multiply and subtract didn't do much either :)
03:04:12 <goltrpoat> this is all with optimizations turned off, so you'd think these types of things would have a noticeable impact
03:05:05 <Excedrin> have you looked at the BigFloat pi? it's defined as 4 * atan(1)
03:05:45 <goltrpoat> yeah.. this has a somewhat different purpose
03:06:02 <goltrpoat> well.. it doesn't have any discernable purpose, but the idea is that computePi 1000 computes the first 1000 digits
03:06:41 <Excedrin> it would be interesting if you could leave n out completely, and use take to get as many digits as you like
03:06:47 <goltrpoat> it's a spigot algorithm, so each digit is computed independently.  the algorithm itself is pretty cool, when you read the initial description, it kind of looks like magic
03:07:08 <goltrpoat> unfortunately, n determines the table size
03:08:02 <goltrpoat> and the table is traversed right to left, so you have to have portions of the entire stream evaluated.  i don't think there's a way to write it as an infinite stream
03:09:12 <goltrpoat> (without cheating and catting elements of map computePi [1..])
03:11:15 <ph8> dons: what's foldr do?
03:11:33 <gour> earthy: morning. have you been able to cook something (ftplugin for vim) and/ or tried pida?
03:11:34 <lambdabot> gour: You have 1 new message. '/msg lambdabot @messages' to read it.
03:11:53 <pjd> ph8: do you know reduce?
03:12:30 <pjd> goltrpoat: i haven't read through the whole paper yet, but is the digit calculation truly independent, then?
03:13:43 <goltrpoat> pjd:  it's independent in the sense that earlier digits aren't used to compute later digits
03:14:11 <pjd> but later digits are used for earlier ones?
03:14:16 <goltrpoat> nah
03:14:37 <goltrpoat> the idea is that irrationals become periodic with a particular choice of number system
03:14:46 <goltrpoat> er
03:14:49 <goltrpoat> certain irrationals
03:15:07 <goltrpoat> so, he picks one in which pi's expansion is 0.222...
03:15:30 <goltrpoat> and the workhorse is allocating some chunk of that expansion, and converting it, basically by long division
03:15:38 <ph8> sorry pjd no :/
03:16:09 <pjd> do you know map?
03:16:16 <ph8> vaguely
03:16:58 <pjd> well, it's sort of like map, in that it calls your function for each entry in the list
03:17:36 <pjd> but instead of collecting your function's results in a list, it passes the result in as an extra argument
03:17:36 <ph8> so,  let m = foldr insert M.empty ls <-- calls insert for each ls?
03:18:02 <ph8> with M.empty as... the argument to insert to provide an initial reference point
03:18:30 <pjd> yep
03:18:48 <ph8> kinky
03:18:52 <ph8> what does foldr stand for?
03:18:55 <goltrpoat> and the obligatory.. http://foldr.com http://foldl.com
03:18:58 <lambdabot> Title: foldr.com
03:18:59 <pjd> the simplest example of the idea is sum = foldl (+) 0
03:18:59 <ph8> cheers
03:19:20 <pjd> foldl and foldr are the same, but work from the left and right of the list, respectively
03:19:37 <ph8> ah fold left, fold right
03:19:38 <Excedrin> foldr = fold right
03:19:39 <ph8> makes more sense
03:21:30 <pjd> there's also foldl1 and foldr1, which don't need an initializer, but need a list of at least one element
03:23:25 <Excedrin> foldr f init [x1,x2,x3] = f x1 (f x2 (f x3 init))
03:24:12 <goltrpoat> anyway, there's no particular purpose for this, i was just randomly clicking links, came across the paper and figured i'd implement it, since the algorithm is rather spiffy
03:24:38 <goltrpoat> then ran into the whole issue of 5000 digits taking a few minutes to compute, and realized that i have no clue how to optimize it at a low level
03:25:45 <goltrpoat> switching the base should result in a linear speedup (especially if you know that the n digits that you care about don't contain, say, 5 zeroes in a row and you're in base 10^5 -- then 'adjust' goes away)
03:26:03 <goltrpoat> was curious if there's any way to improve on the current implementation though
03:26:54 <pjd> goltrpoat: from the look of it, it's generating the digits in sequence, though
03:26:57 <vegai> "Haskell is just too similar to Pascal."
03:27:05 <pjd> (up to the table size limit)
03:27:29 <goltrpoat> pjd:  nextRow e (len-1, len*2-1) requires that you know n up front
03:28:00 <goltrpoat> it's scanning each len-sized row from right to left (left to right in my case, i'm flipping them to allow for sequential access)
03:32:05 <goltrpoat> maybe i'm missing something
03:34:06 <goltrpoat> but it appears that the table has to be finite, since you're working from one end of the table to the other end, the leftmost element is what produces the digit, and the table size is directly determined by the number of digits you care about
03:34:51 <pjd> i get a vague feeling that it might be possible to extend the table incrementally
03:36:40 <Excedrin> it's definitely possible to calculate pi incrementally, BigFloat does it... whether that algorithm is useful for that is uncertain
03:37:10 <goltrpoat> well.. things carry from one row to the next, so i'm not sure how you'd reconstruct that information.  might be possible, not sure
03:37:31 <pjd> each time you do, you'd need to retroactively perform the same sequence of multiply/carry operations that the column would have generated were it there from the start
03:38:04 <pjd> goltrpoat: yeah, exactly
03:40:12 <ph8> insert c m = M.insertWith (\o _ -> o+1) c 1 m
03:40:16 <ph8> what does the \o do?
03:40:21 <ph8> some sort of evil quick function mapping?
03:40:43 <Excedrin> \ is a lambda
03:41:07 <Excedrin> if I write a function: f x = x * 2
03:41:11 <Excedrin> that can be rewritten as: \x -> x * 2
03:41:26 <Excedrin> in the 2nd case, it's not named anything
03:41:42 <Excedrin> lambda is an anonymous (unnamed) function
03:42:01 <Excedrin> f = \x -> x * 2 -- exactly equivalent to the f x = x * 2 version
03:42:50 <Excedrin> so (\o _ -> o+1) is like: f o _ = o + 1
03:42:57 <Excedrin> _ means "I don't care about this parameter"
03:43:31 <integral> @pl \o _ -> o + 1
03:43:32 <lambdabot> const . (1 +)
03:43:35 <pjd> goltrpoat: i think it's possible
03:44:22 <pjd> goltrpoat: instead of starting the newly-added column at 2, you shift the decimal point right, the same number of times as the rounds it missed
03:44:50 <pjd> shift the point left, even
03:45:42 <goltrpoat> i think reconstructing the columns is possible, yeah.. trying to work through going from n=3 to n=4 by hand
03:45:45 <pjd> (you'd actually keep track of the shift as a scaling factor, probably)
03:47:49 <ph8> does insertWith actually return a map value?
03:47:49 <ph8> >	let m = foldr insertWith incrementNum a 1 myMap
03:47:52 <ph8> is my line at the moment
03:48:00 <ph8> then i return m, but it errors because myMap is unknown
03:48:02 <[d-_-b]> before I use an Instance...... I have to use a Class.... or a Data..... ????
03:48:53 <dons> ph8, should that be M.empty ?
03:48:59 <dons> since you want to start with the empty map
03:49:13 <dons> [d-_-b]: you need a class to define instances for, yes.
03:49:14 <ph8> but then won't it use M.empty every time?
03:49:18 <ph8> and hence only write one map?
03:49:26 <dons> not in a fold. the empty is the starting value
03:49:29 <Excedrin> ph8: yes, insertWith returns a map value..  Data.Map provides an immutable map, so each operation that changes the map in question returns a new one
03:49:31 <[d-_-b]> thanks dons
03:49:35 <dons> and after each step, the result is fed back in to the enxt step
03:50:03 <pjd> goltrpoat: hmm, figuring out the right modulus and carry retroactively is hard
03:51:09 <pjd> it could require running the entire table back and forwards again...
03:52:33 <Excedrin> dons: nice tutorial, I think you should mention what "split.words" does somewhere
03:52:52 <Excedrin> (or at least add whitespace around the . )
03:53:21 <ph8> grr i can't seem to get my head around it, even with your example dons
03:53:27 <ph8> > mapFile :: [t] -> Map a b
03:53:27 <ph8> > mapFile (a:x) = foldr insertWith incrementNum a 1 Data.Map.empty
03:53:28 <lambdabot>  Not in scope: type constructor or class `Map'
03:53:28 <lambdabot>  Parse error
03:53:32 <ph8> it's that at the moment but that's obviously wrong :/
03:55:23 <Excedrin> it's Data.Map.insertWith as far as lambdabot knows... it has a specific set of imports
03:55:35 <ph8> i've imported it
03:55:42 <ph8>  ->  import Data.Map(Map, toList, empty, insertWith, findWithDefault, showTree)
03:56:27 <Excedrin> ph8: I think that expression needs some parens..
03:59:58 <goltrpoat> > foldr (\m ms -> (insertWith (*) 5 10 (head ms)) : ms) [empty] [1..5]
03:59:59 <lambdabot>  Not in scope: `empty'
03:59:59 <ph8> what, the import??
04:00:01 <ph8> ahh
04:00:05 <goltrpoat> > foldr (\m ms -> (insertWith (*) 5 10 (head ms)) : ms) [M.empty] [1..5]
04:00:06 <lambdabot>  Not in scope: `insertWith'
04:00:12 <goltrpoat> > foldr (\m ms -> (M.insertWith (*) 5 10 (head ms)) : ms) [M.empty] [1..5]
04:00:13 <lambdabot>  [{5:=100000},{5:=10000},{5:=1000},{5:=100},{5:=10},{}]
04:00:15 <ph8> eep, that's completely lost me
04:00:39 <ph8> maybe i'll read some more tutorials :/
04:00:42 <goltrpoat> actually.. what are you trying to do? :)
04:05:22 <ph8> it's dead simple, in theory
04:05:31 <ph8> read each character of a file, into an array of character frequencies
04:05:41 <ph8> i've got dons working example, but apparently i can do it with just insertWith
04:05:51 <ph8> it's part an assignment
04:11:36 <goltrpoat> > foldr (\p ms -> [M.insertWith (+) (fst p) (snd p) (head ms)]) [M.empty] [("one", 1), ("four", 2), ("three", 3), ("four", 2)]
04:11:39 <lambdabot>  [{"four":=4,"one":=1,"three":=3}]
04:11:43 <goltrpoat> not sure if foldr is the best way to go about it though
04:12:29 <goltrpoat> not the way i did it, in any case :)
04:12:48 <goltrpoat> oh
04:12:50 <goltrpoat> sorry, brainfart
04:13:30 <goltrpoat> > foldr (\p m -> M.insertWith (+) (fst p) (snd p) m) M.empty [("one", 1), ("four", 2), ("three", 3), ("four", 2)]
04:13:32 <lambdabot>  {"four":=4,"one":=1,"three":=3}
04:13:58 <ph8> what's \p doing?
04:14:04 <goltrpoat> or, assuming we just have a bunch of words and we want to count their frequencies..
04:14:09 <ph8> it's the only term i don't know
04:15:00 <goltrpoat> > let words = ["one", "two", "four", "four", "four", "two"] in foldr (\p m -> M.insertWith (+) (fst p) (snd p) m) M.empty (zip words (repeat 1))
04:15:01 <lambdabot>  {"four":=3,"one":=1,"two":=2}
04:15:34 <goltrpoat> ph8:  let's say we had a helper function for foldr..  helper p m = M.insertWith (+) (fst p) (snd p) m
04:15:40 <goltrpoat> then we could write
04:15:56 <goltrpoat> > let helper p m = M.insertWith (+) (fst p) (snd p) m in foldr helper M.empty [("one", 1), ("four", 2), ("three", 3), ("four", 2)]
04:15:58 <lambdabot>  {"four":=4,"one":=1,"three":=3}
04:16:32 <goltrpoat> helper could also be written as helper p = \m -> M.insertWith (+) (fst p) (snd p) m
04:17:15 <goltrpoat> \m -> [...] is a function that takes one argument, m, and evaluates to something that may or may not be using that argument
04:17:22 <goltrpoat> > (\x -> x + 1) 5
04:17:23 <lambdabot>  6
04:17:41 <goltrpoat> or we can have it take more than one argument:
04:17:47 <goltrpoat> > (\x y -> x + y) 5 10
04:17:48 <lambdabot>  15
04:18:21 <goltrpoat> so finally..
04:18:31 <goltrpoat> > let helper = \p m -> M.insertWith (+) (fst p) (snd p) m in foldr helper M.empty [("one", 1), ("four", 2), ("three", 3), ("four", 2)]
04:18:33 <lambdabot>  {"four":=4,"one":=1,"three":=3}
04:18:45 <goltrpoat> and then we can just replace helper in foldr helper [...] with the body of helper
04:18:56 <goltrpoat> ie foldr (\p m -> ...) ...
04:21:16 <goltrpoat> here's another tack.  f x y = x + y is a function of two parameters.  we can apply it to two parameters:  f 5 10 evaluates to 15.  we can apply it to one parameter:  f 5 evaluates to a function that takes one argument and produces the sum of it with 5
04:21:40 <goltrpoat> finally, f, by itself, evaluates to a function that takes two arguments and produces their sum
04:22:02 <goltrpoat> the version we wrote had two parameters:  f x y = x + y
04:22:39 <goltrpoat> we should be able to write it with a single argument:  f x = (x +)
04:22:50 <goltrpoat> another way of writing the same thing would be f x = \y -> x + y
04:23:17 <goltrpoat> similarly, we should be able to write it with zero arguments:  f = (+)
04:23:24 <goltrpoat> another way of writing the same thing would be f = \x y -> x + y
04:25:54 <goltrpoat> let me know if that makes any sense, otherwise we can try another angle
04:28:49 <ph8>  hmm, i'm sort of with you :)
04:28:50 <ph8> cheers
04:28:56 <goltrpoat> coolness
04:29:40 <goltrpoat> (technically, the last two versions of f aren't equivalent to the rest, but that's another story)
04:32:48 <goltrpoat> gah
04:32:58 <goltrpoat> sorry, i made that example a lot uglier than it should be
04:33:02 <goltrpoat> > let words = ["one", "two", "four", "four", "four", "two"] in foldr (\p m -> M.insertWith (+) p 1 m) M.empty words
04:33:04 <lambdabot>  {"four":=3,"one":=1,"two":=2}
04:34:09 <psykotic> goltrpoat, did you see that nsa proof of the fundamental theorem of calculus i posted as a comment to the reddit submission for your blog post?
04:34:21 <goltrpoat> psyk:  yeah, pretty cool
04:34:47 <therp> hm, how is NSA involved with calculus?
04:34:56 <psykotic> the epsilon-delta proof is pretty technical. you need to bring out some relatively big guns like cauchy's version of the mean value theorem
04:35:04 <goltrpoat> right
04:35:11 <dons> heya psykotic
04:35:44 <goltrpoat> the reason i brought in that many examples was that proofs would just fall out randomly
04:35:48 <psykotic> therp, non-standard analysis, not the national security agency :)
04:35:49 <goltrpoat> so it was hard to stop
04:35:49 <goltrpoat> hehe
04:36:05 <therp> psykotic: oh :) ok
04:36:13 <dons> ?keal
04:36:14 <lambdabot> how bout i say ick no unicorn and daisy loving girl mathematician will ever enjoy this
04:36:22 <dons> ah was hoping for an nsa quote
04:37:04 <dons> ?keal
04:37:04 <lambdabot> doubles and floats cause b*(Floor[v/b^p]/b-Floor[Floor[v/b^p]/b) to fuck up
04:37:30 <psykotic> goltrpoat, btw you should read an old AMS letter by knuth on a pedagogical approach to undergrad calculus he calls "O Calculus" which is based around big oh notation. a lot of the calculations come out the same as in NSA, but you need a lot less technical machinery, e.g. you don't need anything as hardcore as the transfer principle, ultrafiltres, etc to justify your doings.
04:37:40 <Masklinn> Hello everybody
04:37:56 <goltrpoat> ah interesting
04:38:28 <goltrpoat> well.. the uniqueness of d makes what i was talking about pretty dinstinct from robinson's stuff, which is where the transfer principle comes in (iirc)
04:38:53 <psykotic> basically he defines a "strong derivative" as a function f' such that f(x+d) = f(x) + d * f'(x) + O(d^2)
04:39:10 <goltrpoat> oh, i see where that's going
04:39:37 <psykotic> and you can see how the laws for O's is a lot like the nilpotence laws for infinitesimals
04:40:05 <goltrpoat> right
04:40:09 <psykotic> the main calculational disadvantage is that you have to carry them through the calculation, whereas with nilpotent infinitesimals you can cancel them sooner
04:40:48 <araujo> morning!!
04:40:58 <psykotic> goltrpoat, if you're curious, www.ams.org/notices/199806/commentary.pdf
04:41:04 <goltrpoat> ah cool, thanks
04:41:21 <psykotic> that's also where i got that FTC proof from, he just does it with O-notation :)
04:41:40 <goltrpoat> -nod-
04:46:47 <goltrpoat> psyk:  as far as the implementation goes, i suspect i'll be using it a lot in the future
04:46:54 <goltrpoat> it's pretty crazy how cheap it is, in terms of effort
04:47:37 <psykotic> goltrpoat, btw have you seen oleg's implementation of the same task?
04:47:53 <goltrpoat> no, ive read the announcement
04:47:59 <psykotic> i think he does it by introducing a kind of formal power series, thereby doing everything symbolically
04:48:24 <goltrpoat> dons sent me the link the day before crunchtime hit, i think.. been meaning to check it out in more detail
04:50:26 <gour> dons: your today's blog entry is very nice. when seeing that "aim of haskell" thread in the ml, i thought about Fulton's "The Ruby Way" book (never took look at Camel) as fine example of putting lot of useful stuff in book showing how to use many (ruby) libs
04:50:47 <psykotic> another of those cool calculational hacks that turn out to have a mathematical justification... have you read about heaviside's umbral calculus? i think sigfpe had a blog entry on it.
04:51:41 <psykotic> (what haven't sigfpe blogged about?)
04:51:45 <goltrpoat> briefly.. ive read about it in the past, but haven't retained much info, and ive read sigfpe's entry on it
04:52:17 <goltrpoat> yeah, i'm going to start coming up with a list of topics that sigfpe hasn't blogged about
04:52:38 <goltrpoat> put one in a sealed envelope and mail it to myself, and send the other one to him
04:53:10 <psykotic> i remember coming across his short paper on visualizing differential forms years and years ago
04:53:11 <goltrpoat> that way when he does blog about the remaining topic, i could pull it out of the mailbox and say ha!
04:53:19 <ph8> does ls <- readFile f, where f is a FilePath make ls the entire contents of f? or is it some clever looping thing which sets ls to one character at a time?
04:53:47 <goltrpoat> psyk:  oh, i may have read that
04:53:54 <psykotic> if you haven't read that, you should check it out. it develops the common interpretation of 1-forms outlined in "physicist's differential geometry" books like thorne, wheeler, et al's book on general relativity to something more general.
04:54:19 <goltrpoat> that sounds familiar
04:55:11 <goltrpoat> got a link?
04:55:33 <psykotic> yeah, sec
04:55:57 <psykotic> http://homepage.mac.com/sigfpe/Mathematics/forms.pdf
04:56:51 <goltrpoat> it appears that i was thinking of .. "a geometric approach to differential forms" by bachman
04:57:29 <goltrpoat> if, that is, i wasn't just inventing the whole thing altogether.  that appears to be the only expository-looking paper i have that talks specifically about differential forms though
04:57:45 <goltrpoat> k, i haven't seen that one :)  thanks
04:58:37 <Syzygy-> @type readFile
04:58:39 <lambdabot> FilePath -> IO String
04:59:11 <Syzygy-> ph8: Judging from the type signature I'd guess that it reads all of it.
04:59:29 <Syzygy-> Or, judging from laziness, it should read just as much as it needs.
05:00:28 <Syzygy-> And playing around with reading from /dev/zero, it seems as if it reads just what it needs to do what you want it to.
05:04:37 <goltrpoat> oh.  it appears that bachman's book is published now, and gone from arxiv
05:05:29 <goltrpoat> oh.  no it's not
05:06:43 <goltrpoat> k, bedtime.
05:06:43 <goltrpoat> adios
05:33:23 <edi> test
05:35:11 <dons> ?users
05:35:12 <lambdabot> Maximum users seen in #haskell: 291, currently: 238 (81.8%), active: 19 (8.0%)
05:37:12 <lightstep> if there was a histogram connecting amount of users to time, we could see the expectancy and the variance, and know when to expect 300
05:49:50 <dons> yeah, i could generate that from the logs...
05:49:51 <dons> mmm.
05:49:56 <dons> ?stats
05:49:56 <lambdabot> Unknown command, try @list
05:50:00 <dons> ?where stats
05:50:01 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
05:56:03 <arcatan> hey folks, I'd like to embed Haskell code in text, like with PHP
05:56:52 <arcatan> hmm, on second thought, I don't actually want to do that
05:56:58 <Syzygy-> arcatan: Do you mean something like Literate Haskell?
05:57:06 <arcatan> no
05:57:37 <arcatan> more like templating engine for blog entries
05:59:08 <psykotic> you want the snippets to be executed and replaced with their values?
05:59:25 <arcatan> yeah
05:59:27 <dons> mmm. that would be nice. like HSP does.
05:59:29 <dons> ?where hsp
05:59:30 <lambdabot> http://www.cs.chalmers.se/~d00nibro/hsp
05:59:36 <dons> (the web pages are .hs documents, iirc)
05:59:49 <dons> but with a literate haskell convention you could do this pretty easily, too.
06:00:29 <psykotic> it would definitely be nice for any kind of written document with embedded sample code. keeping sample interactions/executions up to date with the code can be a pain.
06:01:25 <lightstep> hmm, 0.0% cursing was the max this year
06:20:01 <aristoteles> got a question: can you tell me how to construct a .hs that replaces any _ in any filename in a directory with a whitespace character?
06:21:34 <Lemmih> > let replace '_' = ' '; replace x = x in map replace "hello_world"
06:21:35 <lambdabot>  "hello world"
06:22:13 <dons> for f in * ; do g=`echo $f | sed 's/_/ /g'`; mv $f $g ; done
06:22:16 <Syzygy-> aristoteles: You have System.Posix.Files.rename, System.Posix.Directory.openDirStream in addition to that.
06:22:24 <_matthew-> ahhh! *that's* how you do different cases in the same line!
06:22:27 <Syzygy-> Or you could just do what dons suggests. :)
06:22:38 <aristoteles> ok great, thanks
06:22:41 <aristoteles> wow
06:23:03 <_matthew-> err, careful with that mv
06:23:19 <_matthew-> won't the space in $g confuse mv and get reinterpreted?
06:23:22 <Syzygy-> Good point.
06:23:27 <_matthew-> you might want to quote it
06:23:29 <dons> mm, seems to work on my box
06:23:32 <Lemmih> Syzygy-: Would be better to use System.Directory.
06:23:36 <dons> but "$g" might be safer
06:23:39 <Syzygy-> You may want to so 's/_/\\ /g'
06:23:45 <Syzygy-> Lemmih: May well.
06:24:04 <dons> Lemmih: we need a nice filesystem traversal api :)
06:24:08 <dons> something functor/tree like
06:24:17 <bacek> rename "s/_/ /" *
06:24:17 <segosa> why does map (+4) [1,2,3] work and not map (+4) 1:2:3:[] ?
06:24:30 <dons> parens
06:24:44 <dons> > map (+4) (1:2:3:[])
06:24:46 <lambdabot>  [5,6,7]
06:24:49 <segosa> oh
06:24:52 <segosa> hm
06:25:16 <segosa> alright
06:25:37 <segosa> i'll get the hang of it someday :P
06:25:53 <lightstep> why does a "C a a" instance require undecidable instances?
06:26:24 <Lemmih> dons: How do you generate a graph over darcs commits?
06:26:29 <_matthew-> ok, so what good tools are there for visualising tree based adts?
06:27:19 <dons> Lemmih: you mean using darcs-graph?
06:27:25 <dons> ?where darcs-graph
06:27:26 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/darcs-graph/
06:27:32 <Lemmih> Ah.
06:27:37 <dons> (check the src, it just graphs the patches/ dir)
06:32:58 <Lemmih> Neat, http://darcs.haskell.org/~lemmih/conjure/conjure-commits.png
06:33:37 <dons> cool. 40 is pretty high
06:37:20 <Lemmih> bittornado really pissed me off by using 180mb of ram so I've hacked like a maniac on conjure.
06:37:33 <Syzygy-> Conjure?
06:37:51 <Lemmih> Syzygy-: A bittorrent client written in Haskell.
06:38:03 <Syzygy-> Ooooooooooh! What is the state of it?
06:38:17 <Syzygy-> (i.e. can I dump my bittorrent-curses and start using conjure instead?)
06:38:48 <yip> hello Lemmih
06:39:54 <Lemmih> Syzygy-: Not yet, it still hasn't got a user interface.
06:40:21 <Lemmih> But everything else is done.
06:40:26 <Lemmih> Hiya yip.
06:41:13 <yip> Lemmih: how is hIDE going?
06:44:02 <Lemmih> yip: I poked it with a stick some time ago. Didn't move... might be comatosed or even dead /-:
06:44:26 <yip> noooooo :'(
06:45:40 <deadbeef> hi there
06:45:48 <deadbeef> anyonee has a subscription on acm.org ?
06:45:57 <_matthew-> deadbeef: yes, via uni
06:46:02 <deadbeef> there's an article on it and i'd really like to read it
06:46:11 <deadbeef> _matthew-: my uni is pretty distant from here
06:46:12 <jacobian_> can you pattern match records in haskell?
06:46:17 <deadbeef> i should take the train etc.
06:46:23 <_matthew-> deadbeef: ssh?
06:46:36 <_matthew-> deadbeef: ssh port forward to your uni's www proxy?
06:47:31 <deadbeef> we haven't access from remote
06:47:32 <deadbeef> :(
06:47:42 <_matthew-> mmm. that sucks.
06:47:43 <Lemmih> jacobian_: Yes.
06:47:44 <deadbeef> and my dept is closed today
06:48:00 <_matthew-> ok, what's the url?
06:48:16 <deadbeef> http://portal.acm.org/citation.cfm?id=907800&dl=acm&coll=&CFID=15151515&CFTOKEN=6184618
06:48:19 <lambdabot> Title: The complexity of unification., http://tinyurl.com/yy8mpb
06:48:22 <jacobian_> Lemmih: Just found it... thanks :)
06:48:45 <jacobian_> yarg, it isn't free
06:48:50 <jacobian_> is that a good paper deadbeef?
06:48:57 <jacobian_> I'm curious about the complexity of disunification
06:49:08 <deadbeef> i don't know
06:49:20 <deadbeef> it's cited here
06:49:21 <deadbeef> http://www.amazon.com/Computers-Intractability-NP-Completeness-Mathematical-Sciences/dp/0716710455
06:49:24 <jacobian_> disequational stores
06:49:25 <lambdabot> http://tinyurl.com/yalncy
06:49:41 <deadbeef> and i'm working on theta-subsumption for the thesis
06:50:10 <deadbeef> the book says that on the paper there's a proof that the problem is np-complete etc.
06:50:30 <deadbeef> those things should be free btw
06:50:31 <deadbeef> imho
06:50:39 <_matthew-> err, I can't get it
06:50:44 <_matthew-> acm don't have the pdf
06:50:54 <_matthew-> and the links from acm go no where useful
06:51:08 <pejo> deadbeef, isn't that a thesis you have to order?
06:52:19 <deadbeef> yes
06:52:45 <deadbeef> _matthew-: yes, i just tryed purchasing it
06:53:20 <_matthew-> well I can't find any download link, sorry
06:54:03 <deadbeef> np, thanks a lot
06:54:37 <pejo> jacobian, one of the first hits on google, is this what you're looking for? http://citeseer.csail.mit.edu/148514.html
06:54:40 <jacobian_> why are you working on theta-subsumption
06:54:41 <lambdabot> Title: On the Complexity of Unification and Disunification in Commutative Idempotent Se ...
06:55:46 <jacobian_> actually that is a little more refined than what I'm looking for
06:55:52 <deadbeef> jacobian_: it's for a thesis
06:56:20 <jacobian_> But why are you interested in theta-subsumption
06:56:34 <deadbeef> i'm trying to reduce subsumption to SAT and then use an efficient SAT solver like miniSAT
06:56:44 <jacobian_> ah
06:57:57 <_matthew-> I'm I confused or is "an efficient SAT solver" a contradiction in terms - given the complexity of the problem?
06:58:07 <_matthew-> err s/I'm/Am/
06:58:18 <deadbeef> yes
06:58:23 <deadbeef> efficient compared to others
06:58:55 <ph8> ?yaht
06:58:55 <lambdabot> Maybe you meant: fact part yarr
06:59:02 <_matthew-> oh I see. It's still in NPC then... I've not missed a rather important recent result then!
06:59:05 <ph8> ah, does anyone have the YAHT link?
06:59:21 <Saizan> ?where yaht
06:59:22 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
06:59:22 <pjd> ?where yaht
06:59:23 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
06:59:34 <ph8> ty
07:00:12 <jacobian_> hehe
07:00:47 <jacobian_> worst case and average case can be completely different
07:01:04 <jacobian_> so it depends on how you characterise "efficient"
07:01:15 <_matthew-> mmm. sure.
07:01:33 <jacobian_> I think it was used here to mean "practical"
07:02:20 <pejo> (And with some "luck" the instances you throw at the solver are some sort of special case that it manages to recognize).
07:02:58 * _matthew- chuckles at the idea of an NPC problem being "practical" ;)
07:03:20 <_matthew-> but yes, I take your point
07:03:39 <deadbeef> i was looking for the mail of that guy
07:03:43 <deadbeef> to ask him his thesis
07:03:53 <edi> that's a good idea actually
07:04:39 <pejo> matthew, there are papers investigating optimal register allocation and instruction scheduling for compilers, and they seem to find it 'practical'.
07:05:05 <psykotic> one of the differences is that those are optimization problems
07:05:21 <psykotic> or do you mean there are efficient algorithms with guaranteed optimal allocations?
07:05:30 <_matthew-> pejo: fair enough. It's just something that the courses I've done on complexity haven't really treated, so is new to me.
07:06:11 <pejo> psykotic, yes, they map it to an integer linear programming problem and let CPLEX solve it.
07:06:26 <psykotic> interesting
07:06:29 <pejo> (Wilken is the only author I remember offhand, but he's a part of all the papers).
07:07:31 <psykotic> i was in a competition in school to make the best bandwidth minimizer. you can do a lot by pruning, which usually lets you solve problems of increasingly larger size, but from that experience i got the idea that there also tends to be a "exponential" cliff you fall off of sooner rather than later :)
07:08:25 <psykotic> (no heuristics or approximations involved)
07:09:24 <pejo> Sure, I don't deny that arbitrary large instances of np-hard problems are impossible to solve today. But just 15 years ago I don't think anyone thought that one could perform optimal register allocation for "ordinary" programs either.
07:09:31 <huschi_> is there any tool that transforms an xml-schema in haskell types (like dtdtohaskell)?
07:09:31 <psykotic> yeah true
07:10:16 <psykotic> but even with not-guaranteed-optimal graph coloring allocators you see people inserting "full spills" at certain boundaries in problems with too much reg interference...
07:10:45 <psykotic> i guess a reasonable strategy is to switch between allocators by interference amount
07:11:47 <pejo> I think with a recent version of CPLEX and some unix machine (PA-RISC cpu?) they could do register allocation for each function in less than 1 second each.
07:12:03 <psykotic> that's still terrible though :)
07:12:03 <pejo> I guess we're talking about C code here.
07:12:31 <psykotic> i mean, it's impressive but still not very practical for everyday workflow
07:12:45 <pejo> Shrug, use your heuristic approach for non-optimizing case, and do the optimal register allocation for your release - you only compile it once.
07:13:05 <psykotic> yep
07:13:30 <pejo> Heh, and it would "encourage" programmers to stay away from those damn 200k line source files. ;)
07:13:36 <psykotic> and pray to fsm that the implementers didn't do that themselves when testing it :)
07:14:01 <pejo> Something tells me fsm didn't mean finite state machine there?
07:14:21 <psykotic> he of the noodly appendage
07:38:17 <segosa> what does "Instance of Num [Char] required for definition of test" mean?
07:38:58 <allbery_b> you tried to do an arithmetic operation on a string
07:39:02 <segosa> hm :/(
07:39:09 <segosa> but I thought ++ was for concatenation of stringsd
07:39:17 <allbery_b> it is.
07:39:21 <allbery_b> @paste
07:39:21 <lambdabot> http://paste.lisp.org/new/haskell
07:40:06 <segosa> I've only just started learning this language (my first 'functional' language, too) so I'm just screwing around trying to learn from trial and error, while reading a couple of tuts.. anyway *pastes*
07:40:43 <lisppaste2> segosa pasted "blah blah" at http://paste.lisp.org/display/32591
07:41:10 <Jaak> (show $ x+1) i guess
07:41:14 <allbery_b> haskell requires you to convert numbers to strings explicitly
07:41:18 <Jaak> oh
07:41:32 <segosa> i thought show did that?
07:41:49 <segosa> read from int->str and show from int->str
07:41:49 <Jaak> else x + 2 is wrong too
07:42:01 <allbery_b> jaak is correct, but you also want to convert the other leg the same way, or convert back to a Num after the concatenation
07:42:05 <segosa> oh
07:42:11 <allbery_b> otherwise one leg returns a Num and the ther a String
07:42:21 <allbery_b> *other
07:42:23 <hyrax42> dons, nice example of Not Just Maybe in your latest blog entry
07:42:47 <hyrax42> I had not considered it would fail in the IO monad wiht an IO error
07:42:53 <allbery_b> hm,how did I miss show was there already.  precedence
07:43:01 <hyrax42> only ever thought of Not Just Maybe as beign useful for Maybe and []
07:43:11 * allbery_b is not quite awake yet
07:43:54 <segosa> Jaak / allbery_b: I changed else x+2 to else show x+2 and it did the same thing. I also tried changing show x+1 ++ "4" to read (show x+1 ++ "4") and it still does the same thing
07:44:03 <allbery_b> so yes, parens.  but you still need to match types afterward, deciding whether you want test to return a String or (Num a) => a
07:44:19 <allbery_b> (show (x + 1)) ++ 4
07:44:24 <segosa> oh
07:44:35 <allbery_b> otherwise show eats too much
07:44:36 <segosa> oh of course
07:44:44 <segosa> functions bind more tightly
07:44:53 <segosa> so it becomes show (x) + 1 doesn't it
07:45:17 <segosa> that works
07:45:33 <segosa> thanks
07:46:11 <allbery_b> yep.  using ghc6.6 the error message I get shows how it parenthesized it:  ((show x) + 1) ++ "4"
07:46:12 <segosa> I have to admit error messages make little sense to me
07:46:25 <segosa> but I'm getting there
07:46:36 <segosa> hm
07:47:43 <segosa> functional languages are nice, a good change from procedural.
07:47:52 <allbery_b> the error messages do take some getting used to, yes.  haskell is flexible enough that it tends to assume you're doing something you may not be, hence the "no instance for Num [Char]" instead of "you tried to do math on a string"
07:49:09 <segosa> ah
07:49:11 <lisppaste2> allbery_b annotated #32591 with "here's how GHCi 6.6 reports the problem" at http://paste.lisp.org/display/32591#1
07:49:14 <gour> segosa: for beginning, helium could be nice providing more help with the error messages
07:49:25 <segosa> helium is an interpreter?
07:49:44 <gour> @where helium
07:49:45 <lambdabot> http://www.cs.uu.nl/research/projects/helium/
07:49:52 <segosa> ah
07:50:02 <segosa> but that's like cheating! :P
07:50:07 <segosa> I should dive into the deep end
07:50:23 <allbery_b> so, ignoring the first line, you can see it got confused at the 1, and the last line shows you how it interpeted your expression --- whichin this case shows you the actual problem
07:50:43 <sorear> wow, I just typed this into bash:
07:50:44 <gour> segosa: why cheating?
07:50:46 <sorear> grep -v '^--' | grep -v '::' | Data/Generics/Serialization/SExp.hs
07:51:47 <segosa> gour: wasn't serious
07:52:03 <pejo> segosa, error messages need to be better (ie more work), and Helium has limited the language somewhat in order to give useful ones.
07:52:24 <gour> segosa: i consider it helpful for the very beginning's sessions
07:52:48 <gour> segosa: which OS or distro you are running?
07:52:52 <segosa> windows
07:52:54 <pejo> Isn't it exactly what the DrScheme people do, btw?
07:53:04 <segosa> I use winhugs currently
07:53:14 <segosa> I tried / have ghc/i but i prefer winhugs for some reason
07:53:38 <gour> segosa: try it out. there is *.exe available
07:53:55 <segosa> heh, okay
07:54:47 <segosa> ew it's java :(
07:56:05 <gour> segosa: "To use Hint you need a recent version (>= 1.4) of Java installed." :-)
07:56:27 <segosa> yes, I thought hint wasn't helium though
07:57:21 * gour is downloading helium to try latest verison udner vmware
08:01:45 <segosa> brb
08:01:48 <chessguy> 'morning, haskellers
08:02:24 <hyrax42> ?type split
08:02:29 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
08:03:49 <allbery_b> "this is not the split you are looking for" :)
08:06:07 <sorear> ?type splitAt
08:06:08 <lambdabot> forall a. Int -> [a] -> ([a], [a])
08:06:09 <sorear> ?type span
08:06:11 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
08:06:27 <sorear> either of those wanted?
08:10:25 <hyrax42> sorear: it was a mistake
08:10:47 <hyrax42> I just read dons' latest blog entry, and the split was defined in a where clause two lines below
08:11:01 <hyrax42> split [a, b] = (a, b)
08:11:06 * allbery_b rather suspected as much
08:23:52 <_matthew-> ?hoogle [[a]] -> [a]
08:23:53 <lambdabot> Prelude.concat :: [[a]] -> [a]
08:25:13 <ndm> @seen dcoutts__
08:25:14 <lambdabot> I saw dcoutts__ leaving #ghc, #haskell-overflow, #haskell-blah, #haskell and #gentoo-haskell 17h 52m 55s ago, and .
08:25:28 <ndm> @seen dcoutts
08:25:29 <lambdabot> dcoutts is in #ghc, #gentoo-haskell, #haskell.hac07, #haskell-overflow and #haskell. I don't know when dcoutts last spoke.
08:25:43 <ndm> @seen dcoutts_
08:25:43 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell, #ghc, #haskell-overflow and #haskell.hac07. I don't know when dcoutts_ last spoke.
08:26:28 <ndm> anyone know much about deforestation?
08:26:43 <ndm> (quite a bit about deforestation, really)
08:26:56 <SamB> somebody must
08:27:09 <ndm> basically the question is can foldl be deforested as a producer?
08:27:10 <SamB> but I bet you know more about it than most people here
08:27:26 <SamB> um... isn't foldl a consumer?
08:27:33 <ndm> and if so, how often, is it common
08:27:40 <ndm> yes, it is a consumer, but map is both
08:27:46 <ndm> for example
08:27:53 <SamB> what do you want to deforest it with?
08:28:01 <ndm> the thing that calls it
08:28:13 <SamB> yes but what is that!
08:28:15 <ndm> i.e. consumer . foldl
08:28:29 <ndm> say map is the consumer in this case, but in general, it doesn't matter - and consumer
08:28:32 <SamB> also, what is passed to foldl!
08:28:42 <sorear> map IIRC uses build, which is the produces
08:28:42 <ndm> see i suspect that makes a difference
08:28:59 <ndm> sorear: foldr and build, which makes it both producer and consumer
08:29:29 <ndm> i suspect in some instances foldl can be a producer, but i half suspect that to do that you are using foldl as something else (perhaps a foldr), so its not that important
08:29:34 <sorear> something like : map f x = build (\c z -> foldr (c . f) z x)
08:29:40 <SamB> ndm: I thought your code already deforested everything
08:29:45 <SamB> why don't you just ask it!
08:30:25 <ndm> SamB, it could currently deforest it if it found an appropriate instance - although i'm not sure if it ever actually has. i want to change the termination condition, which would disallow deforesting foldl as a producer
08:30:33 <ndm> makes the code much simpler
08:30:46 <ndm> but don't want to do that if i'm actually throwing away something
08:31:23 <SamB> @hoogle build
08:31:24 <lambdabot> GHC.Exts.build :: ((a -> b -> b) -> b -> b) -> [a]
08:31:25 <lambdabot> Distribution.Simple.Build.build :: PackageDescription -> LocalBuildInfo -> Int -> [PPSuffixHandler] -> IO ()
08:31:25 <lambdabot> Data.Graph.Inductive.Internal.Heap.build :: Ord a => [(a, b)] -> Heap a b
08:31:33 <SamB> oh well...
08:31:39 <SamB> can'y use that...
08:31:48 <ndm> yeah, hoogle  drops the forall's on build :)
08:31:58 <pejo> ndm, atleast foldr needs to have a let inserted to make it into treeless form (Marlows work, pp 33 in his thesis).
08:31:58 <ndm> GHC can't deforest foldl's at all
08:32:00 <SamB> that ain't what I meant
08:32:11 <SamB> I just mean it ain't in scope for @run ;-)
08:32:29 <ndm> pejo: i am not doing marlow etc. style deforestation
08:32:48 <SamB> > foldl (flip (:)) [] "Hi!"
08:32:49 <lambdabot>  "!iH"
08:33:18 <ndm> i'm not sure you can deforest a reverse...
08:33:24 <ndm> since its tail strict
08:33:46 <SamB> I bet you could deforest its output...
08:33:48 <ndm> you could technically deforest it with a mapping as the consumer, but not a general consumer
08:34:03 <ndm> actually, not even then
08:34:18 <SamB> mmm.
08:34:24 <ndm> you can't because it only produces the first element last, so you have to buffer the rest until then
08:34:54 <SamB> well. say we have an rot13 function...
08:35:12 <SamB> @type toUpper
08:35:13 <_matthew-> @paste
08:35:13 <lambdabot> Char -> Char
08:35:13 <lambdabot> http://paste.lisp.org/new/haskell
08:35:46 <SamB> @type isUpper
08:35:48 <lambdabot> Char -> Bool
08:35:53 <lisppaste2> _matthew- pasted "I broke ghci!" at http://paste.lisp.org/display/32595
08:35:54 <ndm> SamB, deforesting isn't about taking out the element things, it's about taking out the list that's created...
08:36:16 <SamB> ndm: hmm?
08:36:17 <ndm> _matthew-: go report a bug :)
08:36:19 <SamB> oh. actually...
08:36:35 <ndm> SamB, try writing a deforested version of map rot13 . reverse
08:37:03 <ndm> if you did a foldr with an associative and commutative operator you could deforest it
08:37:15 <ndm> but by that stage the reverse was entirely pointless!
08:37:36 <SamB> hmm...
08:37:45 * SamB thinks
08:38:00 * SamB tries to draw a picture
08:38:22 <ndm> i think i can actually proove it now, thanks to this discussion, that foldl can't be deforested as a producer
08:38:37 <pejo> ndm, I believe people will think of the work done by Wadler/Marlow/Hamilton/Seidl/Sorensen if you say it's "plain" deforestation. The "problem" with that kind of deforestation for foldr/foldl is that the application has a non-variable argument, which makes it in non-treeless form. The rewriting to a let-form makes the result have a intermediate structure (what you were trying to prevent).
08:39:31 <pejo> ndm, but if you're not doing that, how is your deforestation different from their work? :-)
08:39:43 <ndm> pejo: yes, i realise the Wadler/Marlow stuff is "the norm"
08:40:03 <ndm> pejo: i'm just writing it up now actually, i have a general optimiser which has 2 rules, and an emergent property is deforestation
08:40:13 <ndm> along with various other optimisations
08:41:24 <SamB> @check \f z xs -> foldr f z (reverse xs) = foldl f z
08:41:25 <lambdabot>  Parse error
08:41:32 <SamB> @check \f z xs -> foldr f z (reverse xs) == foldl f z
08:41:34 <lambdabot>    Occurs check: cannot construct the infinite type: b = [b] -> a       Exp...
08:41:36 <SamB> @check \f z xs -> foldr f z (reverse xs) == foldl f z xs
08:41:37 <lambdabot>  Add a type signature
08:41:56 <SamB> @check \f z xs -> foldr f z (reverse xs :: [I]) == foldl f z xs
08:41:57 <lambdabot>  Falsifiable, after 5 tests: <Int -> Int -> Int>, -3, [-1,-1,2]
08:42:07 <SamB> @check \f z xs -> foldr f z (reverse xs :: [I]) == foldl (flip f) z xs
08:42:08 <lambdabot>  Add a type signature
08:42:38 <SamB> @check \f z xs -> foldr f (z :: I) (reverse xs :: [I]) == foldl (flip f) z xs
08:42:42 <lambdabot>  OK, passed 500 tests.
08:43:23 <SamB> ndm: are you sure about all this?
08:43:41 <ndm> SamB, really not
08:43:59 <SamB> does that not count as deforestation?
08:44:23 <gour> @seen earthy
08:44:24 <lambdabot> earthy is in #haskell. I don't know when earthy last spoke.
08:45:29 <ndm> SamB, the foldr is deforested, but the reverse isn't, so you still have one intermediate list in both cases
08:46:15 <SamB> oh, so you mean you can't deforest foldl with its argument list?
08:47:34 <ndm> you can deforest it as a consumer, with its arguments, but not as a producer
08:48:07 <SamB> ndm: but. I just got rid of the list between that foldr and the foldl hidden inside of reverse!
08:48:23 <mbishop> deforest, consumer, producer? is this #marketing? :)
08:48:41 <SamB> mbishop: no. you see, the consumers here won't pay for anything.
08:49:01 <SamB> at least, not unless you are trying to find their computational complexity...
08:49:27 <SamB> and even then, I think maybe the caller of both has to pay...
08:49:28 <ndm> the foldr variant you gave with reverse is a consumer (reverse is a consumer), and a producer, but has an internal list from reverse that is not fused
08:49:51 <SamB> ndm: the one on the right was supposed to be the deforested version
08:50:17 <ndm> but you can't deforest a foldl
08:50:46 <SamB> oh, okay, so yeah
08:50:50 <SamB> you are probably right.
08:51:00 <SamB> I just didn't know quite what you meant ;-)
08:51:39 <ndm> i never know what i mean :)
08:51:45 <SamB> except that I suppose if you have foldl and reverse, you can maybe make that into a foldr?
08:52:06 <SamB> at the risk of turning _|_ into a value
08:52:35 <_matthew-> ndm: I would (go report a bug) if I could log into the ghc trac...
08:52:41 <SamB> (i.e. it is only safe if you know that the argument list ends ;-)
08:52:56 <ndm> _matthew-: try guest/guest as the username/password
08:53:11 <ndm> yes, thats like defining reverse . reverse = id
08:53:18 <ndm> not really safe, but might be a good idea anyway
08:53:24 <SamB> it might
08:53:31 <_matthew-> ndm: am doing. just endlessly keep getting prompted
08:53:39 <SamB> but it would be a bad idea to do it all the time
08:53:56 <SamB> it would be important to test code with that transformation not done
08:55:11 <ndm> true, and if you are working using reverse . reverse for buffering stuff, that will break
08:55:28 <SamB> ???
08:56:43 <ndm> interact (reverse . reverse)
08:56:54 <SamB> okay...
08:57:02 <ndm> or rather interact (unlines . map (reverse . reverse) . lines)
08:57:31 <SamB> mmm.
08:58:08 <SamB> anyway, probably people rarely do that anyway.
08:58:19 <SamB> so maybe just don't bother?
08:59:06 <ndm> Colin, my supervisor, does it - if i say "don't bother" to that it guarantees i get a whipping when i hand in my thesis
08:59:41 <SamB> no, I meant probably people don't tend to have reverse.reverse in their code for no reason...
08:59:52 <ndm> indeed
09:00:26 <SamB> or foldl . reverse
09:00:35 <SamB> so, like, don't bother messing with it!
09:00:50 <_matthew-> mmm. well if I could login to trac then I would be able to report that it's due to strictness modifiers
09:01:38 <edi> dcoutts dcoutts_ ping
09:01:42 <ndm> _matthew-: send it to <glasgow-haskell-bugs haskell.org>,
09:01:54 <_matthew-> yep, will do. tnx
09:03:50 <Igloo> SamB: Things like reverse.reverse could easily come about by inlining
09:04:49 <Igloo> e.g. something like f = reverse . f' . reverse; g = reverse . g' . reverse in f . g
09:06:33 <SamB> yeah.
09:06:55 * SamB doesn't know what to say about that buffering stuff
09:07:26 * SamB thinks that is a pretty silly way to buffer, though
09:09:53 <ndm> i agree, but people do it
09:11:18 <SamB> they could just use (liftM2 seq length)
09:13:44 <deadbeef> anyone here knows dominic duggan ?
09:16:23 <shankys> Has anyone here ever gotten Bjorn Bringert's dyn-cgi setup with Lighttpd before? I'm trying to integrate dyn-cgi with the Haskell framework I'm writing, and running into a brick wall (you there Bjorn?).
09:16:38 <shankys> *am running
09:16:44 <bringert> shankys: hi
09:17:04 <bringert> probably not. I haven't announced dyn-cgi widely
09:17:28 <bringert> I know that lemmih has worked with Network.FastCgi and lighttp
09:17:43 <shankys> bringert: Could you possibly give me some pointers on how I might integrate dyn-cgi with Lighttpd?
09:17:57 <shankys> bringert: I've got Lighttpd working with Network.FastCGI already
09:18:09 <bringert> ok, what's the problem?
09:18:36 <shankys> bringert: I see that there's an htaccess in your dyn-cgi directory
09:18:51 <shankys> bringert: But I'm not exactly sure how everything is tied together
09:18:54 <bringert> ah
09:18:55 <bringert> right
09:18:58 <bringert> of course
09:19:22 <bringert> it's used to get nicer URLs
09:19:29 <bringert> but it requires mod_rewrite
09:19:30 <edi> bringert: yow!
09:19:47 <bringert> edi: hi
09:19:48 <edi> Did you ever try Gtk2 +quartz && gtk2hs ?
09:20:08 <bringert> no, I've hardly done any Haskell GUI stuff
09:20:23 <edi> gtk2hs/demo/buttonbox paolo$ ./buttonbox
09:20:23 <edi> buttonbox: Cannot initialize GUI.
09:20:23 <edi> I'll bug duncan...
09:20:55 <shankys> bringert: So if I already have Network.FastCGI setup with Lighttpd what do I have to do to get dyn-cgi going?
09:21:12 <bringert> *checking*
09:21:24 <araujo> edi, what's wrong?
09:21:48 <bringert> shankys: does lighttpd have anything like mod_rewrite?
09:21:55 <edi> araujo: I can't run any demo :-(
09:22:14 <shankys> bringert: Yeah, actually it does have mod_rewrite as a module
09:22:34 <bringert> so, maybe you could try that first
09:23:01 <araujo> edi, how did you compile the examples?
09:23:08 <edi> araujo: "make"
09:23:35 <bringert> shankys: basically, handleRequest in dynhs.hs gets the program to run from the PATH_INFO env variable
09:23:40 <araujo> oh .. mm.. you are using quartz
09:23:59 * araujo hasn't worked with it
09:24:20 <bringert> shankys: if you delete the rewrite stuff from htaccess, a url like dynhs_root/dynhs.fcgi/your_program.hs should work
09:24:25 <nominolo> edi: you are trying to run a gui app on osX?
09:24:31 <edi> nominolo: right.
09:25:01 <shankys> bringert: So I'm also going to need to change stuff in Config.hs
09:25:11 <bringert> yeah, probably
09:25:14 <nominolo> edi: maybe you have to "updrade" your application to a quartz application. like for wxHaskell?
09:25:25 <bringert> shankys: I don't remember exactly how it works
09:25:33 <edi> nominolo: what kind of "upgrade" you have in mind?
09:25:46 <shankys> bringert: Ok, I'll give it a shot. Thanks.
09:26:07 <bringert> shankys: if you can simplify the path messiness, that'd be great
09:26:14 <nominolo> edi: http://wxhaskell.sourceforge.net/building-macosx.html
09:26:16 <lambdabot> Title: wxHaskell - Building - MacOS X
09:26:30 <shankys> bringert: If I get it working, I probably will and send patches ;)
09:26:35 <bringert> great
09:27:13 <edi> open...
09:27:53 <nominolo> edi: open is just a generic wrapper.  see "man open"
09:28:07 <edi> nominolo: yeah, it doesn't run the app though
09:28:17 <nominolo> the tricky part is the script "macosx-app"
09:28:22 <edi> "open ./buttonbox" opens the file in the text editor :)
09:28:32 <edi> right, I don't think gtk2hs has it yet...
09:28:48 <nominolo> it's problably generic
09:29:13 * edi downloads wxhaskell's source
09:30:28 <nominolo> edi: ok, it's not completely generic.
09:30:50 <edi> what does it do?  is it a script that you can paste somewhere?
09:31:04 <nominolo> sure
09:32:13 <lisppaste2> nominolo pasted "macosx-app" at http://paste.lisp.org/display/32598
09:34:19 <edi> hm.
09:34:58 <nominolo> i think it also needs some template file
09:39:23 <edi> nominolo: the one embedded in the script seem general enough
09:40:42 <nominolo> edi: I haven't tried running an app from the prompt, but there's this EnableGUI module too.  it's described on the same page, above
09:40:42 * bringert searches ebay for a "shapr zaurus sl-5600"
09:40:50 * bringert found nothing
09:41:28 <nominolo> the linux pda?
09:41:31 <edi> nominolo: I'm not sure.
09:41:55 <nominolo> edi: i mean from the ghci prompt
09:42:16 <bringert> nominolo: yeah, if I had typed sharp and not shapr
09:42:50 <nominolo> bringert: ah .. finally .. i .. got .. it .. d'oh
09:42:55 <bringert> surprisingly, there is no shapr for sale on ebay
09:43:18 <edi> During interactive linking, GHCi couldn't find the following symbol:
09:43:18 <edi>   GetCurrentProcess
09:43:26 <bringert> except for this one: http://www.ebay.se/viItem?ItemId=300059055920
09:43:28 <lambdabot> Title: eBay Objekt: 300059055920 (Avslutas 2006-12-17 00:56:01 CET) - NEW*34B blck Smoo ...
09:43:34 <edi> nominolo: it doesn't tell what to -link
09:44:05 <bringert> whoa, a shapr with "2 rows of 3 hooks for crotch closure"
09:44:31 <bringert> anyone wanna buy that for shapr?
09:44:59 <mbishop> heh
09:45:19 * bringert is way off topic
09:45:32 <newsham> hi
09:46:03 <newsham> "Although you might get sidetracked in the Perl versus Python versus Ruby versus flavor-of-the-month debate. It's worth pointing out that the cool kids are using Haskell."
09:46:03 <edi> nominolo: can you load EnableGUI.hs in ghci successfully?
09:46:18 <nominolo> edi: i'll try
09:46:20 <newsham> i'm told that quote is in this book: http://www.amazon.com/Art-Software-Security-Assessment-Vulnerabilities/dp/0321444426/sr=8-1/qid=1166256901/ref=pd_bbs_sr_1/102-0714270-4468968?ie=UTF8&s=books
09:46:24 <lambdabot> http://tinyurl.com/yzzpgm
09:46:30 <newsham> (although the book doesnt cover haskell)
09:46:50 * SamB thinks DataRep should have some kind of support for arrays
09:46:52 <edi> newsham: ooh.
09:49:23 <shankys> bringert: I get an error when I run "make" for dyn-cgi. It says "Module `Network.CGI.Monad' does not export `CGIRequest(..)''. I have GHC6.6 installed on Mac OS X. Any ideas?
09:49:56 <bringert> shankys: I think you might need the current darcs version of the cgi package
09:50:12 <bringert> not sure though
09:50:30 <shankys> bringert: Alright, I'll see if that works.
09:54:30 <paolino> injectp :: [a -> a] -> a -> [a]
09:54:31 <paolino> injectp [] _ = []
09:54:31 <paolino> injectp (f:fs) a = f a : injectp fs (f a)
09:54:31 <paolino> Has this a more natural description ?
09:55:02 <Heffalump> @type flip map (\a f -> f a)
09:55:03 <lambdabot>   The lambda expression `\ a f -> ...' has two argumentss,
09:55:03 <lambdabot>   but its type `b' has none
09:55:20 <nmessenger> "argumentss"?
09:55:20 <Heffalump> @type \a -> map (\f -> f a)
09:55:22 <lambdabot> forall b t. t -> [t -> b] -> [b]
09:55:34 <Heffalump> @type flip (\a -> map (\f -> f a))
09:55:35 <lambdabot> forall a b. [a -> b] -> a -> [b]
09:55:43 <Heffalump> @pl flip (\a -> map (\f -> f a))
09:55:43 <lambdabot> flip (map . flip id)
09:56:14 <Heffalump> oh, sorry, that's wrong
09:56:22 <Heffalump> it's some kind of scan, not a map
09:56:40 <Heffalump> and I'm too lazy to work out precisely what.
09:57:49 <_matthew-> @hoogle (a -> b -> m a) -> a -> [b] -> m a
09:57:50 <lambdabot> Prelude.foldl :: (a -> b -> a) -> a -> [b] -> a
09:57:51 <lambdabot> Data.List.foldl' :: (a -> b -> a) -> a -> [b] -> a
09:58:06 <_matthew-> yeah, I want a monadic foldl
09:58:07 <nominolo> edi: oh, "foreign import ccall .." no longer works? hm ...
09:58:16 <nmessenger> :t foldM
09:58:17 <edi> nominolo: -fffi
09:58:18 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
09:58:24 <_matthew-> tnx
09:59:52 <nmessenger> _matthew-: I think it has foldr semantics, though.
10:00:08 <nominolo> edi: hm, i get a linker error
10:00:19 <edi> :-/
10:00:31 <newsham> hmm.. why dont file handles and sockets derive from a common typeclass?
10:00:42 <newsham> (s/derive/use/)
10:00:48 <lisppaste2> nominolo pasted "enableGUI" at http://paste.lisp.org/display/32602
10:01:02 <edi> :t scanr ($) -- Heffalump
10:01:04 <lambdabot> forall b. b -> [b -> b] -> [b]
10:01:26 <newsham> would be useful, for example, to be able to "interact" on a socket.
10:01:37 <Heffalump> edi: fair enough
10:01:40 <edi> :t scanl (flip ($))
10:01:41 <lambdabot> forall b. b -> [b -> b] -> [b]
10:02:45 <_matthew-> :r
10:02:47 <_matthew-> ww
10:03:24 <Heffalump> newsham: couldn't you just implement one yourself?
10:03:39 <newsham> i'm sure i could.  but i couldnt make it work with "interact"
10:03:48 <newsham> or many of the other existing tools
10:05:30 <newsham> ?hoogle installHandler
10:05:30 <lambdabot> GHC.ConsoleHandler.installHandler :: Handler -> IO Handler
10:10:04 <allbery_b> so, it looks to me like by the time you want to do file-like things with a socket, it's a Handle instead of a Socket
10:10:35 <newsham> be careful.  in unix a socket fd is a file fd.  in windows a socket handle is not a file handle.
10:11:03 <allbery_b> that os, accept and connectTo both produce a Handle
10:11:07 <allbery_b> *is
10:11:26 <newsham> oh, hmm.. so perhaps you can "interact" on it.
10:12:06 <glguy> "If your programming language requires you to use functors, you're not getting all the benefits of a modern programming environment. See if you can get some of your money back."
10:14:58 <emu> i'd counter with "if your university didn't teach you anything, see if you can get your money back"
10:15:58 <newsham> hrmm.. why did I think there was an hInteract?
10:17:22 <newsham> sure enough though, hPutStrLn worked on a handle from connectTo
10:17:42 <glguy> emu: I'm not sure why you'd respond like that, but OK :)
10:20:11 <dr_strangelove> I get a warning:       Warning: Pattern match(es) are overlapped
10:20:16 <dr_strangelove> but they are not
10:20:24 <emu> probably have a _ case?
10:20:42 <dr_strangelove> I don't have a _ case
10:20:45 <emu> if you have a catch-all case, but you already handled all the cases, it will issue that warning. safe to ignore.
10:21:07 <dr_strangelove> problem is, the pattern matches don't work
10:21:18 <dr_strangelove> it always chooses the first
10:21:20 <emu> lisppaste2: url
10:21:20 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
10:21:33 <glguy> dr_strangelove: that's what pattern matching does
10:21:44 <emu> make sure you are going in order from most specific to least
10:22:22 <edi> nominolo: I spotted a port problem and I'm fixing things, so I will not be able to try gtk things again until a lot of packages are built... sorry
10:23:16 <nominolo> edi: i don't make much progress here, either
10:24:05 <nominolo> and i have two more exams and a project presentation in the next three days. so priorities are on these
10:28:19 <SimonRC> Is there a function pick (Eq a) => (a -> Bool) -> [a] -> (a,[a]) which picks out the first elemnt that satisfies the predicate and returns it and the rest?
10:29:23 <nominolo> SimonRC: you can wrap partition
10:29:29 <SimonRC> yuk
10:29:43 <Heffalump> :t (\f xs -> (\xs -> (head xs, tail xs)) . dropWhile (not . f))
10:29:45 <lambdabot> forall a t. (a -> Bool) -> t -> [a] -> (a, [a])
10:30:13 <Heffalump> :t \f xs -> (\xs -> (head xs, tail xs)) . dropWhile (not . f)
10:30:14 <lambdabot> forall a t. (a -> Bool) -> t -> [a] -> (a, [a])
10:30:28 <Heffalump> :t \f xs -> (\xs -> (head xs, tail xs)) (dropWhile (not . f) xs)
10:30:29 <lambdabot> forall a. (a -> Bool) -> [a] -> (a, [a])
10:30:36 <Heffalump> @pl \f xs -> (\xs -> (head xs, tail xs)) (dropWhile (not . f) xs)
10:30:37 <lambdabot> (liftM2 (,) head tail .) . dropWhile . (not .)
10:31:10 <SimonRC> hmm
10:31:32 <lisppaste2> dr_strangelove pasted "Pattern Matching" at http://paste.lisp.org/display/32605
10:31:37 <nmessenger> I still cannot grok composing composition sections.
10:31:56 <SimonRC> great aren't they
10:32:02 <dr_strangelove> emu, I pasted a test case
10:32:08 <glguy> > let f p xs = let ((a:as),b) = partition p xs in as++b in f even [1,3,5,2,4,6]
10:32:09 <lambdabot>  [4,6,1,3,5]
10:32:17 <glguy> > let f p xs = let ((a:as),b) = partition p xs in (a,as++b) in f even [1,3,5,2,4,6]
10:32:18 <lambdabot>  (2,[4,6,1,3,5])
10:32:40 <emu> dr_strangelove: um, you have two catch-all cases
10:32:56 <emu> the "d1" is being bound
10:32:59 <emu> not being used
10:33:06 <nmessenger> dr_strangelove: change test d1 into test x | x == d1
10:33:09 <nominolo> glguy: I think partition does another thing than SimonRC wants.
10:33:55 <emu> guards are what you want: test x | x == d1 = 23 | x == d2 = 42
10:34:32 <dcoutts__> dons: your popen looks reasonable. Have you tested it much? Does closing errh like that work? what happens when the process writes to the pipe that you just closed?
10:34:52 <dr_strangelove> nmessenger, ok, but I thought this what pattern matching does by default. And only if I want other comparisions than == I have to use guards
10:34:53 <glguy> > let f p xs = aux [] xs where aux ys (x:xs) | p x = (x,ys++xs) | otherwise = aux (x:ys) xs in f even [1,2,3,4,5]
10:34:54 <lambdabot>  (2,[1,3,4,5])
10:35:09 <dcoutts__> dons: I think we'd rather connect the stderr to /dev/null or something
10:35:57 <nmessenger> dr_strangelove: pattern-matching deconstructs type constructors and binds new names, it can't match against arbitrary expressions.
10:37:08 <nmessenger> dr_strangelove: specifically, test d1 introduces a new name, d1, that matches any pattern.
10:37:39 <glguy> > let f p xs = aux xs where aux (x:xs) | p x = (x,xs) | otherwise = second (x:) $ aux xs in f even [1,2,3,4,5]
10:37:40 <lambdabot>  (2,[1,3,4,5])
10:37:47 <hyrax42> question: how can I easily track down the package a module is in?
10:38:02 <hyrax42> this for Build-Depends in my cabal file
10:38:24 <dr_strangelove> nmessenger: when I substitute d1 by   MyData2 ([(MyData 1)])   and d2 by    MyData2 ([(MyData 2)])    it's still the same
10:38:46 <hyrax42> ?docs quickcheck
10:38:46 <lambdabot> quickcheck not available
10:38:53 <hyrax42> ?docs Test.QuickCheck
10:38:54 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/QuickCheck/Test-QuickCheck.html
10:39:35 <dr_strangelove> nmessenger, no, you were right
10:40:27 <nmessenger> dr_strangelove: well that's good.  I was seriously confused there for a second. :)
10:43:19 <kzm_> > let prop_revrev xs = xs == reverse (reverse xs) in quickCheck prop_revrev
10:43:20 <lambdabot>  Not in scope: `quickCheck'
10:43:24 <kzm_> Heh
10:43:50 <hyrax42> nobody knows how to find package given module?
10:44:08 <Sgeo> Hi all
10:44:23 <Sgeo> I just redefined dylan as an Uncyclopedia-style parody..
10:44:25 <nmessenger> @check \xs -> (xs::[Int]) == reverse (reverse xs)
10:44:26 <lambdabot>  OK, passed 500 tests.
10:45:53 <nmessenger> hyrax42: I sure don't  :)
10:46:03 <hyrax42> :(
10:46:19 <hyrax42> well I found the ones I needed, but it'd be nice to know how to do it a bit more easily
10:46:34 <[d-_-b]> can I use a 'do' notation inside a 'do' notation???
10:46:38 <monochrom> Yes!
10:46:51 <nmessenger> Absolutely!
10:47:01 <sjanssen> do-do
10:47:06 <nmessenger> Heh
10:47:08 <monochrom> deep_dodo = do { x <- do { ...
10:47:29 <nmessenger> ROFL indeed
10:47:52 <hyrax42> lol
10:48:44 <nmessenger> [d-_-b]: what context is it needed in?
10:50:38 <SimonRC> nmessenger: You often need a do inside a do if you are writing imperative-style code with ifs.
10:51:16 <SimonRC> or cases, of coure
10:52:36 <nmessenger> SimonRC: I meant, what code did [d-_-b] need dodo's in. Examples would help to explain if (s)he needed help.
10:52:40 <monochrom> do { x <- case do { y <- Just True; Nothing; return (not y) } of { Just b -> [b,b,b]; Nothing -> [] }; z <- [b, not b]; return (not b) }
10:52:54 <[d-_-b]> nmessenger, like monochrom said " do { x <- do { ..."
10:52:58 <monochrom> So you can even have different monads.
10:53:31 <nmessenger> Yes, I understand.  Nevermind >.>
10:56:22 <nmessenger> SOMEBODY SAY SOMETHING CRAZY!
10:56:43 <Botje> YOU JUST DID
10:57:03 <monochrom> [d-_-b] is a symmetric name.
10:57:25 <dcoutts__> @yarr!
10:57:26 <lambdabot> I heard andersca is a pirate
10:57:26 <monochrom> The symmetry group is C_2.
10:57:44 <SamB> why does it look like a face?
10:58:05 <monochrom> because your pattern recognition software is faulty
10:58:19 <nmessenger> Though, sadly, it's not palindromic
10:58:36 <monochrom> palidromes are for wimps
10:58:46 <[d-_-b]> monochrom hehe
11:00:07 <kyevan> Mreh
11:00:31 <nmessenger> kyevan: THAT'S CRAZY!
11:01:03 <kyevan> It's starting to look like I'm going to have to learn a bunch of other crazy maths to make Haskell's monads make any sense.
11:01:21 <SamB> eh.
11:01:24 <SamB> I doubt it.
11:01:58 <dcoutts__> kyevan: na, I don't know the crazy category theory behind monads and I've been using them for years now
11:02:06 <allbery_b> @go you could have invented monads
11:02:08 <lambdabot> http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
11:02:08 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ...
11:02:22 <kyevan> I've read that
11:02:25 <kyevan> Or, tried
11:02:34 <dylan> kyevan: what don't you understand?
11:02:35 <kyevan> and it keeps throwing me into crazy-maths land
11:02:50 * Lemmih is starting to get really tired of the "real world" vs. Haskell discussions.
11:02:54 <SamB> kyevan: you understand the concept of a mathematical structure, right?
11:02:58 <allbery_b> hm, I didn't have that problem, and I have a fairly weak math background
11:03:00 <kyevan> SamB: Uh, wha?
11:03:07 <edi> dcoutts__: hey! (:
11:03:09 <kyevan> allbery_b: How weak?
11:03:21 <dcoutts__> edi: hello
11:03:26 <kyevan> Say, mid-second year of US high school weak?
11:03:26 <chessguy> kyevan, the key to monads is to simply realize they are an abstract model of a computation.
11:03:32 <SamB> kyevan: do you understand the Peano numbers?
11:03:35 <allbery_b> nothing beyond high school to speak of
11:03:42 <kyevan> SamB: Wha?
11:03:47 <integral> (they don't teach peano in school...)
11:03:52 <SamB> yeah really
11:04:07 <SamB> you shouldn't wait until someone will teach you this stuff
11:04:12 <SamB> that could take forever!
11:04:12 * dylan doesn't know peano numbers from beano, but has no problems with monads. :-/
11:04:14 <allbery_b> in particular, no CS-related maths (or, indeed, much of any theoretical CS for that matter)
11:04:19 <nmessenger> Yay for Peano and untyped lambda calculi!
11:04:42 <dcoutts__> I think if you can understand function composition then you can understand monads
11:04:51 <earthy> um
11:04:57 <SamB> kyevan: maybe you should go read chapter one (maybe chapter two also) of an abstract algebra book...
11:05:05 <earthy> maybe.
11:05:07 <chessguy> ?remember dylan [I] don't know peano numbers from beano
11:05:08 <kyevan> SamB: Can you recommend one?
11:05:12 <SamB> if you want the formal definition...
11:05:17 <earthy> monads are not hard
11:05:20 <nmessenger> let bind = (>>=) in bind doSomething takeTheResultAndDoSomethingElse
11:05:29 <SamB> if you would like an informal definition...
11:05:34 <earthy> but I think for monads the same holds as for the Schroedinger equations
11:05:40 * kyevan reminds you the most complex math he's done is probably simple quadratics.
11:05:46 <earthy> you don't get to understand them, you simply get used to them
11:05:52 <kyevan> Oh, well, I read Flatterland. That's pretty crazy.
11:05:59 <kyevan> earthy: That doesn't work for me.
11:06:07 <SamB> earthy: you do! but when you understand them, you say "oh, is that *all*?"
11:06:09 <pejo> SamB, expecting people to understand the peano axioms is unreasonable, and shouldn't be necessary. And to most people without math background, a book in abstract algebra is just incomprihensible.
11:06:14 <dylan> Lemmih: what do you mean?
11:06:21 <SamB> pejo: hmm.
11:06:22 <kyevan> The same reason I can't enjoy a magic shows.
11:06:22 <earthy> SamB: that's what I mean. you get used to them.
11:06:27 <chessguy> you don't have to know any complex math to get monads
11:06:31 <kyevan> I try and figure it all out
11:06:40 <earthy> they're not hard, but you never really get the feeling you fully understand them
11:06:45 <chessguy> kyevan, start with this: what is a computation?
11:07:04 <earthy> at least I have a mental block that yells 'I have the strong feeling there's more to this'
11:07:33 <dylan> the "why" of monads for do { a; b } or a >> b makes as much sense to me as asking why a + b...
11:07:54 <SamB> basically a monad is just a couple of functions and a way to find a set given another set
11:07:57 <chessguy> hi int-e
11:08:09 <kyevan> chessguy: Um, takeing a value (or more than one) and doing something with it/them?
11:08:17 <int-e> hi
11:08:20 <allbery_b> "it's all very simple; you're just used to everythinbg being complicated"
11:08:26 <allbery_b> (I think that's the quote)
11:08:29 <chessguy> kyevan, that's a good start!
11:08:48 <chessguy> kyevan, does every computation succed?
11:08:50 <chessguy> ahem
11:08:52 <chessguy> succeed
11:09:17 <SamB> but. what most monads are like and what a monad is are very different things...
11:09:40 <chessguy> SamB, um...who are you talking to
11:09:45 <kyevan> chessguy: Well, depends on how you define 'succeed', doesn't it?
11:09:59 <SamB> chessguy: probably myself.
11:10:16 <kyevan> I mean, division by zero could be seen as 'falure' because it doesn't return a sensible, useful answer
11:10:21 <SamB> does melting the CPU count as success?
11:10:23 <chessguy> right
11:10:41 <SamB> > 1 `div` 0
11:10:43 <lambdabot>  Exception: divide by zero
11:10:44 <kyevan> Or you could say it's successful, because it does exactly what it's supposed to do.
11:10:48 <chessguy> kyevan, so a computation may return a sensible value or not
11:10:54 <SamB> I'd say thats kind of a failure
11:11:12 <chessguy> that's half of the definition of a monad right there
11:11:13 <SamB> it didn't give me a usable Int!
11:11:19 <emu> nullity!
11:11:25 <kyevan> SamB: Ah, but it did exactly what you expected, no?
11:11:30 <dcoutts__> Lemmih: ping
11:11:33 <kyevan> Anyway, that's just nitpicking :P
11:11:34 <SamB> chessguy: nobody said a monad may return a useless answer
11:11:43 <nmessenger> emu: You read that too, eh?  'Tis funny.
11:11:49 <emu> it caused a stir
11:11:54 <kyevan> (by me, anyway
11:11:56 <chessguy> kyevan, the other half has to do with containing side effects
11:11:57 <Lemmih> dcoutts__: pong.
11:11:58 <int-e> > 0/0 -- for emu
11:12:00 <dylan> moronity...
11:12:00 <lambdabot>  NaN
11:12:15 <emu> cale wrote a very stirring response
11:12:16 <SamB> chessguy: you are feeding him a bunch of nonsense about specific monads!
11:12:22 <dylan> > (0/0) + 2
11:12:24 <lambdabot>  NaN
11:12:29 <chessguy> SamB, huh?
11:12:33 <SamB> okay, so it is really not nonsense ;-)
11:12:41 <monochrom> "computation" is nonsense.
11:12:42 <nmessenger> emu: Is cale the math blog guy?  'Cause I did read that.
11:12:46 <SamB> but if you talk about it like all monads can do that...
11:12:48 <dcoutts__> Lemmih: did you sort out accommodation for Hac07 yet ?
11:12:52 <kyevan> Did anyone ever figure out what nullity even was supposed to mean?
11:12:59 <emu> one of several
11:13:02 <Lemmih> dylan: I think the discussions are just going around in circles without saying or doing anything concrete.
11:13:09 <chessguy> SamB, i just defined return and fail
11:13:12 <SamB> I think nullity means being []
11:13:14 <chessguy> what's wrong with that?
11:13:24 <SamB> chessguy: oh. fail isn't really part of it...
11:13:29 <SamB> thats just a wart
11:13:37 <chessguy> is it a part of the typeclass or not?
11:13:50 <SamB> it is part of the typeclass, but it really ought to be in MonadZero
11:13:53 <SamB> not Monad
11:13:58 <chessguy> does an instance of monad have to provide it or not?
11:14:00 <gour> earthy: any progress on vim plugin? have you tried pida?
11:14:09 <SamB> the default implementation calls error
11:14:33 <dylan> Lemmih: which ones?
11:14:41 <scodil> has anyone compiled Bulat Ziganshin's ArrayRef library with ghc 6.6?
11:15:06 <chessguy> kyevan, anyway. the other half of monads has to do with how you sequence two computations
11:15:33 <Lemmih> dylan: "Aim of Haskell"
11:15:53 <chessguy> kyevan, notice that without monads, haskell doesn't really have the notion of a sequence of operations
11:16:30 <chessguy> (e.g., main = do { blah; blah} wouldn't exist without monads)
11:16:48 <allbery_b> hrm.  it occurs to me that composition is a kind of sequencing
11:17:01 <chessguy> allbery_b, yes, but not in the same sense i'm talking about
11:17:05 <allbery_b> (also that monads are a kind of composition)
11:17:29 <allbery_b> rather, >>= is a kind of composition
11:17:38 <chessguy> yes
11:17:59 <chessguy> kyevan, does this make any sense?
11:18:30 <kyevan> chessguy: Um, notreally.
11:18:46 <chessguy> what doesn't make sense?
11:18:50 <nmessenger> I've found discussion of Monads in the general to be less fruitful than writing code that uses Monads, and several.
11:19:31 <nmessenger> I recently wrote my first Parsec grammar, which was a learning experience, as I'd only dealt with IO before.
11:19:46 <kyevan> nmessenger: I can't even figure out IO
11:19:47 <monochrom> I have spent much time on the category theory concerning monads.  In the end I never use that knowledge in programming monads.  OK, apart from those three laws, but they are common sense anyway once you write them in the do-notation.
11:20:16 <kyevan> I'm stuck on trying to figure out what the do thing really does!
11:20:24 <chessguy> monochrom, yes, Cale's new article about that is really good
11:20:38 <int-e> @undo do x <- y; return (2*x)
11:20:39 <lambdabot> y >>= \ x -> return (2 * x)
11:20:40 <kyevan> (people say it's a shortcut for >> and >>=  (or was it << and <<=?) but that makes no sense either.)
11:20:40 <chessguy> kyevan, all it does is sequence a bunch of computations
11:21:13 <monochrom> http://www.haskell.org/haskellwiki/Monad_laws
11:21:14 <lambdabot> Title: Monad laws - HaskellWiki
11:21:18 <chessguy> yes, it's a shortcut for >> and >>=
11:21:21 <monochrom> That's all you ever need to know.
11:21:30 <nmessenger> Yeah, writing the binds and lambdas myself was important for me making any progress.
11:21:34 <kyevan> chessguy: So, it's like a little imperitive language, in haskell?
11:21:49 <Tanuk-> kyevan: I started All about monads today, and things are becoming clearer. I guess one just needs to read enough tutorials, eventually one will make sense.
11:21:51 <chessguy> kyevan, in this case it is!
11:21:53 <hyrax42> kyevan: for the IO/ST monads yes
11:21:55 <int-e> kyevan: not really. a sequential language, maybe.
11:21:58 <chessguy> but you're being much more explicit about it
11:22:35 <chessguy> whereas in imperative programming, you must follow step-by-step through the code, in haskell, you don't have to do that unless it's explicitly stated as such
11:22:41 <int-e> kyevan: the 'imperative' comes with the Monad really. IO actually performs the chain of action in sequence. The list monad is more involved as it involves backtracking.
11:22:50 <kyevan> Whoever pointed me at the monad laws page, by the way
11:22:52 <kyevan> ghlio; trjpseroihjgpseroignjpaweroinfpao irfjoarpehgfiasdjgf iawuonfioau whe
11:22:55 <kyevan> fauiwefh iouasdnfiouawerh fvoiarnp giubaw           weuifaklsbfayuebfjka   wf
11:22:56 <kyevan> asdfg ugau
11:23:02 <int-e> kyevan: huh?
11:23:02 <dylan> kyevan!
11:23:02 <chessguy> and when you do, you have to say how to handle the state involved
11:23:12 <monochrom> Are you saying you don't understand it?
11:23:13 <nmessenger> CAT-LIKE TYPING ALERT!
11:23:18 <kyevan> That's just as sense0making as that page.
11:23:31 <_matthew-> lol. that's just not true ;-)
11:23:34 <SamB> kyevan: heh
11:23:43 <SamB> kyevan: maybe for you, right now
11:23:48 <SamB> but you will probably learn
11:23:52 <_matthew-> drink more and it'll make more sense
11:24:01 <chessguy> kyevan, i hear ya man. it's just starting to make sense to me now, slowly
11:24:09 * SamB doesn't think _matthew-'s method is very good
11:24:09 <gour> _matthew-: what is one recommended to drink?
11:24:26 <_matthew-> anything above 40% ?!
11:24:27 <monochrom> I don't understand why you don't understand.
11:24:31 <kyevan> _matthew-: I'll assume you ment water, since I'm underage :P
11:24:39 <gour> lol
11:24:47 <SamB> kyevan: what about coffee
11:24:53 <_matthew-> irish coffee?
11:24:54 <SamB> maybe he meant coffee that is 40% mud
11:25:09 <gour> dcoutts__ would recomend tea, probably
11:25:13 <dylan> mmm, irish coffee.
11:25:34 <dcoutts__> tea cures everything (except syphilis)
11:25:41 <gour> ha ha
11:25:58 <gour> what about snow shortage?
11:26:09 <dcoutts__> gour: ah, no not that either
11:26:18 <gour> ;)
11:26:21 <dcoutts__> however I'm not pining for the fjords today
11:26:25 <kyevan> dcoutts__: I haven't been able to cure decapitation or world hunger...
11:26:43 <chessguy> kyevan, the problem is, in most languages you've ever learned about, you MUST follow the code step-by-step, changing the state as you go. in haskell, that control has been abstracted, so that you can do that if you wish, or not
11:27:18 <nmessenger> Um, slightly more on-topic: kyevan, I'd recommend learning to write the binds and lambdas directly without using the do-notation; at least until you understand how do connects everything together.
11:27:34 <kyevan> chessguy: The only language I've ever really learned (save english :P) is scheme, and only a tiny bit of that
11:27:51 <_matthew-> mmm. the snow shortage should be high on the todo list of things to cure
11:27:52 <chessguy> oh, interesting
11:27:56 <gour> kyevan: then you're in good shape for haskell
11:28:02 <monochrom> How about this?  http://www.haskell.org/haskellwiki/A_brief_introduction_to_Haskell#Imperative_Programming
11:28:05 <lambdabot> Title: A brief introduction to Haskell - HaskellWiki, http://tinyurl.com/y6cbnf
11:28:29 <kyevan> I've tried BASIC, Ruby, C++, C#, Java, and others, but, never really got anywhere in any of them.
11:28:42 <chessguy> ah, but you're still polluted by that mindset
11:28:46 <monochrom> Perhaps kyevan lacked the background.
11:29:03 <gour> kyevan: then you're not so much spoiled by the imperia ;)
11:29:30 <monochrom> Writing in Scheme is like writing in the "ContT r IO a" monad of Haskell.
11:29:48 * nmessenger laughs heartily, before realizing just how true gour's statement is.
11:30:54 <nmessenger>  <- remembers the pain of un-learning procedural dictums in order to code Haskell.
11:32:13 <gour> me too is still struggling with it
11:32:37 <monochrom> Well I highly recommend my last url because I wrote that part. :)
11:32:42 <nmessenger> ... er, yeah.  That's not to say that I've *mastered* it, by a long shot.
11:33:37 <nmessenger> My dabblings include a few smallish toys.
11:35:23 <nmessenger> I've written two little games, a slider puzzle and the thing at <http://e-scribe.com/news/193>, as well as a False interpreter <http://wouter.fov120.com/false/>
11:36:26 <monochrom> Last night we had the False module, the False prophet, and the False god.  Now we also have the False interpreter?
11:36:42 <Sgeo> hm?
11:37:46 <monochrom> Last night someone was investigating [False..].  It turned out False.. was parsed as the False module's operator (.)
11:38:10 <chessguy> monochrom, that article is quite nice
11:38:17 <nmessenger> Ooh, that sounds painful.
11:38:24 <monochrom> Thanks.
11:39:08 <monochrom> I just wrote section 7, mind you.  The rest is dons and other people.
11:39:27 <monochrom> But I'll gladly take it that section 7 is the hardest part. :)
11:40:05 <chessguy> oh, i don't think i'm at that section yet, lol
11:40:28 <monochrom> Actually I also wrote section 9, but that one was easy.
11:43:30 <chessguy> ah yes, section 7 was the hard part, but it was well-done
11:43:59 <chessguy> monochrom++
11:44:25 <monochrom> thanks
11:44:44 <pafcu> Hi. I'm a complete beginner with Haskell. Could someone point to some good examples on how to use HaXML? I'm trying to parse a stream using xmlParseWith, but I'm unsure how to use it.
11:45:49 <nmessenger> @karma+ monochrom
11:45:49 <lambdabot> monochrom's karma raised to 14.
11:47:36 <nmessenger> Well, I've not used HaXML, sorry.
11:47:42 <nmessenger> @google HaXML tutorial
11:47:46 <lambdabot> http://happs.org/HAppS/doc/tutorial.html
11:47:47 <lambdabot> Title: HAppS Tutorial
11:49:07 <pafcu> I've tried googling, but havn't really found anything good
11:49:34 <shankys> bringert: I tried getting the latest version of Network.CGI from your darcs repository and installing it, but I still get "Module `Network.CGI.Monad' does not export `CGIRequest(..)'" when I run "make" for dyn-cgi. Do you have any other ideas?
11:49:52 <edi> ?wiki HXT
11:49:53 <lambdabot> http://www.haskell.org/haskellwiki/HXT
11:49:58 <edi> pafcu: try that one -^
11:50:09 <edi> It is not exactly HaXML, but it's really nice.
11:50:40 <pafcu> edi: Does it allow SAX style parsing?
11:50:52 <edi> What does that mean?
11:51:09 <monochrom> haha edi is hot on HXT :)
11:51:17 * edi nods
11:51:17 <pafcu> I'm parsing a HUGE XML file, so loading the entire file into memory is not an option
11:51:26 <bringert> shankys: which repo was that?
11:51:33 <bringert> use the darcs.haskell.org one
11:51:37 <shankys> bringert: http://www.cs.chalmers.se/~bringert/darcs/cgi/
11:51:40 <lambdabot> Title: Index of /~bringert/darcs/cgi
11:51:41 <bringert> I really should clear that up
11:51:46 <emu> @hoogle scanM
11:51:47 <lambdabot> No matches found
11:51:47 <shankys> bringert: Ok, will do.
11:51:51 <edi> pafcu: I'm not sure. But I hope it does, because it is *really* convenient to use.
11:52:03 * edi sneezes
11:52:19 <pafcu> edi: I'll check it out then. Thanks
11:52:30 <_matthew-> ?karma
11:52:30 <lambdabot> You have a karma of 0
11:52:39 <_matthew-> mmm.
11:54:04 <monochrom> HaXml loads the entire file into memory too.
11:54:36 <pafcu> monochrom: Not the development version
11:54:36 <monochrom> To date no one has written a call-by-need xml parser.
11:54:46 <pafcu> It has SAX support
11:55:15 <pafcu> And support for parsing streams which clearly would not need the entire tree loaded
11:55:24 <pafcu> Or am I missing something?
11:55:49 <monochrom> I suspect you are missing something.  I suspect the contrary too.  I have to check.
11:56:46 <monochrom> where can I browse the development version?
11:56:54 <monochrom> ah, found
11:58:40 <monochrom> You are right.
11:59:08 <pafcu> xmlParseWith in the ParseLazy module seems to do what I want, but I'm unsure how to get the initial (Posn,TokenT) required
11:59:36 <pafcu> As I said I'm a complete beginner with Haskell so I'm having some trouble understanding the documentation
11:59:49 <monochrom> Don't use xmlParseWith.  use xmlParse or saxParse.
12:02:47 <pafcu> monochrom But xmlParse seems to require a complete document wheras xmlParseWith can operate on streams
12:03:21 <monochrom> No, if it is from the ParseLazy module, it's ok.
12:04:07 <monochrom> the type "String" does not signify a whole string sitting in memory.
12:04:38 <pafcu> monochrom: The problem is that I can't resume parsing from where I left
12:04:58 <pafcu> I'm parsing a stream, so the data might end at some point
12:05:09 <pafcu> And the I want to continue parsing once I get more data
12:05:13 <shankys> ?paste
12:05:14 <lambdabot> http://paste.lisp.org/new/haskell
12:05:35 <lisppaste2> shankys pasted "dyn-cgi error" at http://paste.lisp.org/display/32610
12:05:40 <monochrom> there is no such problem
12:06:10 <shankys> bringert: I got the darcs.haskell.org version of Network.CGI, but now I get new errors when I run "make" for dyn-cgi.
12:06:30 <pafcu> Why does the documentation have the remark "To parse a partial document, e.g. from an XML-based stream protocol," under xmlParseWith then?
12:06:41 <pafcu> It seems to be made for just this purpose
12:06:51 <bringert> shankys: grr
12:07:04 <monochrom> Yuck.  How about saxParse?
12:07:08 <shankys> bringert: lol
12:07:09 <bringert> shankys: what are they?
12:07:22 <shankys> bringert: check out my "dyn-cgi error" paste
12:07:27 <augustss> @users
12:07:27 <lambdabot> Maximum users seen in #haskell: 291, currently: 270 (92.8%), active: 49 (18.1%)
12:08:28 <pafcu>  saxParse is an option, but then I'd have to keep track of which "tag I'm in" which seems a bit complicated
12:08:36 <bringert> shankys: did you recompile fastcgi after upgrading cgi?
12:08:37 <pafcu> But I guess I have to settle for that
12:08:46 <bringert> it looks like it is using the old cgi
12:08:58 <shankys> bringert: No, I didn't. That'll probably fix it then.
12:09:07 <bringert> see how it says:  Couldn't match expected type `Network.CGI.Protocol.CGIResult'
12:09:07 <bringert>            against inferred type `CGIResult'
12:09:09 * dylan just unexplained monads to kyevan, he thinks. :)
12:09:10 <shankys> bringert: I'll go try that.
12:09:33 <bringert> they are the same type, but probably from different packages. GHC should report that actually
12:09:57 <monochrom> Text.XML.HaXml.Lex has stuff to feed xmlParseWith
12:10:50 <dylan> chessguy, SamB_XP: http://hardison.net/warez/monads.txt <-- not entirely accurate, but fairly effective way of introducing monads? :)
12:13:30 <monochrom> xmlParseWith element (xmlLex filename string_stream)  sounds like what you want, pafcu
12:14:03 <edi> dcoutts__: does it make sense that "ghci demo/ButtonBox.hs" and then "main" barfs "Please relink your program without -threaded" if I never used -threaded anywhere?
12:14:28 <yip> is dcoutts__ around?
12:14:37 <shankys> bringert: Ok, yeah that fixed it :-)
12:14:42 <SamB> @hoogle a -> DataType
12:14:43 <lambdabot> Data.Generics.Basics.dataTypeOf :: Data a => a -> DataType
12:14:54 <SamB> @hoogle DataType -> DataRep
12:14:55 <lambdabot> Data.Generics.Basics.dataTypeRep :: DataType -> DataRep
12:15:03 <SamB> @hoogle a -> DataRep
12:15:04 <lambdabot> No matches, try a more general search
12:20:23 <pafcu> monochrom: Thanks, just what I wanted. As I said it's quite hard to read the docs as a beginner when you don't even know where to look.
12:20:38 <nmessenger2> dylan: read through it.  'Tis awesome.
12:21:04 <opqdonut> nmessenger2: 'tis and awesome in the same sentence?
12:21:07 <opqdonut> :)
12:21:08 <monochrom> hee hee, yeah I understand.
12:21:11 <drblanco> anyone using ghc 6.6 on os x?  with opengl?
12:21:33 <edi> drblanco: yeah.
12:22:15 <nmessenger> opqdonut: Join your local LAFFS (Latinate allocutions for faux sophistication) chapter today!
12:22:32 <opqdonut> nmessenger: knw ;)
12:23:25 <monochrom> what is faux sophistication?
12:23:38 <nmessenger> false fanciness
12:24:00 <monochrom> I know too little Latin to qualify
12:24:04 <opqdonut> monochrom: you ignoramus
12:24:31 <drblanco> edi: can you explain the install of hopengl or compile?  ghc "failed to load interface for 'GLUT'"  ghc-pkg list has GLUT-2.0
12:24:36 <monochrom> I only know haskell.
12:24:40 <nmessenger> "latinate" in this context meaning derived from a Romance language.  I know no Latin myself.
12:25:08 <monochrom> I know too little French, Spanish, Italian, ... to qualify.
12:25:14 <edi> drblanco: add either -package GLUT or --make to your compilation commandline
12:26:33 <dylan> I prefer natural germanic words in english than latinish ones.
12:27:09 <dylan> to boldly split infinitives! :)
12:27:10 <Korollary> what makes them natural?
12:27:15 <monochrom> The most sophisticated language I know is a calculus that combines mu-calculus and pi-calculus.
12:27:22 <dylan> English is a germanic language, not a latinish one. :)
12:27:49 <Korollary> and we are apes naturally
12:27:59 <nmessenger> Korollary: consider that "hearty welcome" is equivalent to "cordial invitiation" and think of the differences in connotation.
12:28:03 <monochrom> we are machines naturally.
12:28:06 <dylan> Yes. I am also proud of being a primate rather than an elk.
12:28:40 <Korollary> cordial invitation just means that someone is lying
12:29:07 <dylan> I wrote my second-ever composition essay using a large amount of middle english because my teacher wasn't fond of such "vulgar" words. ;)
12:29:12 <nmessenger> Actually it means "hearty welcome" but is derived from French, so it sounds stuffy.
12:29:55 <nmessenger> Germanic == vulgar, Latinate == sophisticated because of the Norman conquest
12:30:02 <nmessenger> @wikipedia Norman conquest
12:30:04 <lambdabot> No Result Found.
12:30:16 <dylan> it's just an accident of roman (and later norman) conquest that latinish words seem more official in english.
12:30:22 <nmessenger> http://en.wikipedia.org/wiki/Norman_conquest
12:30:56 <nmessenger> dylan: ;)
12:31:27 <Korollary> You're not going to argue with all the people as to what should seem official to them. It is what it is.
12:31:35 * dylan is more american aboriginal than he is English, and that's a very small amount.
12:32:18 <dylan> But germanic is a much more ... interesting indo-european branch.
12:32:33 <dylan> (than latinate)
12:33:41 <Korollary> to a lot of people languages are not interesting at all, let alone branches.
12:34:00 <dylan> http://en.wikipedia.org/wiki/Germanic_substrate_hypothesis
12:34:31 <drblanco> edi: --make finds GLUT (-package GLUT didn't), but now can't find module 'GL'
12:34:46 <nmessenger> I'm a fan of Japanese myself.  :D
12:34:55 <SamB> @hoogle a -> ConstrRep
12:34:56 <lambdabot> No matches, try a more general search
12:35:04 <SamB> @hoogle Constr -> ConstrRep
12:35:04 <lambdabot> Data.Generics.Basics.constrRep :: Constr -> ConstrRep
12:35:36 <dylan> Not on a conscious level, but for instance, non-urban english-speaking populations seem to have dialects that deviate from latinish words. (example -- a typical 'redneck' accent)
12:37:03 <enerv> Hi, I need some help if possible. ghc --make -package FilePath -package mtl -package HUnit -fallow-overlapping-instances -fallow-undecidable-instances -fglasgow-exts -cpp -o runtests  -i../dist/build:../src runtests.hs
12:37:10 <enerv> ghc-6.6: unknown package: FilePath
12:37:16 <enerv> ake[1]: *** [testsrc/runtests] Error 1
12:37:27 <enerv> How to solve this problem?
12:38:19 <Korollary> Do you have FilePath? What does ghc-pkg -l say?
12:38:26 <Lemmih> @where filepath
12:38:27 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/projects/libraries.php#filepath
12:39:18 <Lemmih> enerv: What are you building, OOI?
12:39:36 <enerv> Lemmih, hslogger
12:42:03 <brad__> hello, i have a question i have thought about for a while but cannot come up with an intelligent solution
12:42:23 <brad__> can anyone assist>
12:42:59 <Korollary> lambdabot will do its best
12:43:05 <brad__> awesome
12:43:12 <brad__> so lets say i have a list of pairs
12:43:32 <yip> [(a, b)]
12:43:33 <brad__> [("foo","http://www.yahoo.com/"),("bar","baduri")]
12:44:02 <brad__> i want to get a resulting list of pairs that has the uris passed through Network.URI.parseURI
12:44:06 <brad__> which returns Maybe URI
12:44:42 <brad__> i know i can do it by writing a function which takes each element, gets the fst and snd, and either chucks it or keeps it in the list based on Just URI or Nothing
12:44:48 <brad__> but i want a one liner!
12:44:55 <brad__> sadly closest i get is:
12:45:14 <brad__> [u | u <- filter(Data.Maybe.isJust . Network.URI.parseURI . snd) us]
12:45:41 <brad__> but that does not transform the valis snd element into a URI, just passes through the string representation
12:45:53 <nmessenger> So you want a [(String,String)] -> [URI] ?
12:46:13 <brad__> i want [(String,String)] -> [(String,URI)]
12:46:18 <dcoutts__> @yarr
12:46:19 <lambdabot> Prepare to be boarded!
12:46:28 <yip> hello dcoutts__
12:46:30 <int-e> brad__: [(a, b) | (a, b') <- list; Just b <- parseURI b']
12:46:38 <opqdonut> ?type first
12:46:40 <lambdabot> forall (a :: * -> * -> *) d c b. (Arrow a) => a b c -> a (b, d) (c, d)
12:46:50 <dcoutts__> edi: ghci uses -threaded
12:46:53 <dcoutts__> yip: hi
12:46:56 <Lemmih> [ (name, url) | (name, urlStr) <- lst, Just url <- [parseURI urlStr] ]
12:46:58 <nmessenger> Arrows are scary!
12:47:09 <monochrom> Arrows are intuitive.
12:47:15 <int-e> Lemmih: thanks.
12:47:27 <brad__> thanks int-e!
12:47:31 <yip> dcoutts__: i'm not sure i understand why hopengl can work with -threaded and gtk2hs cannot
12:47:31 <brad__> i will try that out
12:47:54 <brad__> thanks Lemmih!
12:47:55 <dcoutts__> yip: opengl is designed to use multiple OS threads, all other GUI libs are not
12:47:59 <int-e> brad__: you need to use a list here, as Lemmih did: Just b <- [parseURI b']
12:48:17 <yip> dcoutts__: no, opengl can only be used from one thread
12:48:26 <dcoutts__> yip: that is not true
12:48:39 <brad__> thanks int-e, i will have to look up lst
12:48:44 <brad__> sure it is in hoogle!
12:48:53 <int-e> brad__: that's your original list of pairs
12:48:54 <brad__> oops, "last"
12:49:03 <dcoutts__> yip: opengl uses state local thread and the api can be used from multiple threads
12:49:04 <brad__> ah, thanks int-e
12:49:15 <dcoutts__> erm thread local state
12:49:20 <brad__> once again this group is very helpful
12:49:27 <brad__> thanks to Lemmih and int-e
12:49:34 <brad__> take care!
12:50:23 <int-e> @type catMaybes
12:50:24 <lambdabot> forall a. [Maybe a] -> [a]
12:51:17 <yip> dcoutts__: it might be possible to have different opengl contexts in seperate threads, but each context can only be used from a single thread
12:51:22 <nmessenger> int-e: can you derive a [(a, Maybe b)] -> [(a,b)] ?
12:51:27 <dcoutts__> yip: yes, exactly.
12:52:04 <Lemmih> @djinn (a, Maybe b) -> Maybe (a,b)
12:52:05 <lambdabot> f (a, b) =
12:52:05 <lambdabot>   case b of
12:52:06 <lambdabot>   Nothing -> Nothing
12:52:07 <dcoutts__> yip: and hopengl solves that with bound threads
12:52:08 <lambdabot>   Just c -> Just (a, c)
12:52:15 * dcoutts__ ->off to watch a film
12:52:28 <yip> dcoutts__: why can't gtk2hs solve it with bound threads?
12:52:35 <int-e> @type (uncurry $ liftM2 (,)) . (Just *** id)
12:52:36 <lambdabot> forall a2 b. (b, Maybe a2) -> Maybe (b, a2)
12:52:56 <dcoutts__> yip: gtk+ cannot be used from multiple threads
12:53:07 <dcoutts__> yip: same as win32, and everything else
12:53:18 <int-e> nmessenger: nothing pretty I think
12:53:20 <yip> dcoutts__: hm... not sure i understand, oh well enjoy your movie i guess :|
12:53:47 <Lemmih> @type mapMaybe ((uncurry $ liftM2 (,)) . (Just *** id))
12:53:48 <droundy> @djinn Monad m => [m a] -> m [a]
12:53:49 <lambdabot> forall a2 b. [(b, Maybe a2)] -> [(b, a2)]
12:53:49 <lambdabot> Cannot parse command
12:54:11 <droundy> @djinn [IO a] -> IO [a]
12:54:12 <lambdabot> -- f cannot be realized.
12:54:13 <nmessenger> :t (***)
12:54:14 <lambdabot> forall (a :: * -> * -> *) c' c b' b. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
12:54:55 <int-e> nmessenger: a is (->) here; so you have (b -> c) -> (b' -> c') -> (b, b') -> (c, c')
12:55:10 * beelsebob wonders if the various unicycling Haskellers will be attending BJC in nottingham this year
12:55:11 <nmessenger> int-e: I think I got that.
12:55:20 <int-e> oh. f *** id = left id
12:55:26 <int-e> left f  even.
12:55:42 <int-e> @type mapMaybe ((uncurry $ liftM2 (,)) . left Just)
12:55:43 <lambdabot>   Couldn't match `(m a1, m a2)' against `Either c d'
12:55:44 <lambdabot>    Expected type: Either b d -> (m a1, m a2)
12:55:49 <int-e> @type mapMaybe ((uncurry $ liftM2 (,)) . first Just)
12:55:51 <lambdabot> forall a2 b. [(b, Maybe a2)] -> [(b, a2)]
12:56:13 <int-e> first then. I keep mixing these up somehow.
12:56:14 * nmessenger bows down in reverence.
12:56:28 <beelsebob> @getshapr
12:56:29 <lambdabot> shapr!!
12:56:44 <int-e> nmessenger: but I think the list comprehension is easier to understand.
12:56:59 <nmessenger> int-e: totally
12:57:53 <monochrom> Very odd.  Is there a way to have only one fixed OS thread make all the gtk+ calls, and other threads do what they like but just never touch gtk+?
13:02:04 <yip> monochrom: apparently not
13:02:14 <yip> it seems to be a very bizarre design of the threading system
13:03:58 <beelsebob> sounds like the way cocoa works
13:04:55 <int-e> @type uncurry ((>>) . (,))
13:04:57 <lambdabot> forall b b1 a. (a, b1 -> b) -> b1 -> b
13:05:32 <int-e> @type uncurry ((>>) . Just . (,))
13:05:34 <lambdabot> forall b a. (a, Maybe b) -> Maybe b
13:06:19 <int-e> @pl \(x,y) -> y >>= return . (,) x
13:06:20 <lambdabot> uncurry (fmap . (,))
13:07:28 <nmessenger> How do you DO that?!
13:07:52 <glguy> ?
13:08:41 <nmessenger> I'm just venting my lack of experience and intuition regarding some of this stuff.
13:09:05 <glguy> What was the original goal?
13:09:18 <nmessenger> Oh, I don't even remember.  ;)
13:09:59 <int-e> oh, a functor is enough. why didn't I see that :)
13:10:11 <int-e> glguy: implement the obvious (x, Maybe y) -> Maybe (x, y)
13:10:50 <glguy> what was djinn's idea?
13:10:51 <nmessenger> glguy: Someone came in earlier asking for a [(String,String)] -> [(String,URI)] and I asked for a generalization.  I was subsequently dumbfounded by the results.
13:11:07 <int-e> @karma+ @pl
13:11:08 <lambdabot>  @pl's karma raised to 0.
13:11:29 <nmessenger> @karma+ lambdabot
13:11:30 <lambdabot> lambdabot's karma raised to 38.
13:11:42 <glguy> ?djinn (x, Maybe y) -> Maybe (x, y)
13:11:42 <lambdabot> f (a, b) =
13:11:42 <lambdabot>   case b of
13:11:42 <lambdabot>   Nothing -> Nothing
13:11:44 <lambdabot>   Just c -> Just (a, c)
13:17:02 <hyrax42> ?djinn a -> b
13:17:02 <lambdabot> -- f cannot be realized.
13:17:17 <hyrax42> ?djinn a -> a -> a
13:17:17 <lambdabot> f _ a = a
13:18:32 <nmessenger> Are @ and ? equivalent?
13:19:07 <int-e> as prefixes, yes
13:19:27 <nmessenger> int-e: there are other cases?
13:19:27 <bd_> ?. pl djinn a -> a -> a
13:19:28 <lambdabot> f = const id
13:19:41 <nmessenger> o.O
13:20:32 <bd_> ?. pl djinn (a -> b) -> m a -> m b
13:20:32 <lambdabot> (line 1, column 1):
13:20:33 <lambdabot> unexpected "-"
13:20:33 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
13:20:42 <bd_> ?djinn (a -> b) -> m a -> m b
13:20:43 <lambdabot> -- f cannot be realized.
13:20:46 <bd_> bleh
13:21:02 <bd_> ?djinn Monad m => (a -> b) -> m a -> m b
13:21:02 <lambdabot> Cannot parse command
13:21:16 <nmessenger> Wow.  Is there a page somewhere that lists the neato stuff one can do with lambdabot?  I've been @list-ing and @help-ing a lot.
13:21:33 <bd_> Well, there's the source XD
13:21:40 <bd_> ?where lambdabot
13:21:40 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
13:21:46 <int-e> @list
13:21:47 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
13:21:54 <bd_> @freshname
13:21:54 <lambdabot> Haeb
13:22:07 <mbishop> @botsnack
13:22:07 <lambdabot> :)
13:22:52 <nmessenger> @help botsnack
13:22:53 <lambdabot> botsnack. Feeds the bot a snack
13:22:59 * nmessenger laughs
13:23:25 <mbishop> heh
13:23:32 <mbishop> @botsmack
13:23:33 <lambdabot> :)
13:23:47 <mbishop> she likes it rough
13:23:53 <nmessenger> Don't spoil her dinner, now!
13:24:08 <nmessenger> Oh, M not N.
13:25:06 <int-e> @brain
13:25:06 <lambdabot> Well, I think so, Brain, but I can't memorize a whole opera in Yiddish.
13:25:59 * nmessenger is not actually rolling on the floor, but is having trouble catching his breath.
13:27:50 <nmessenger> @help yhjulwwiefzojcbxybbruweejw
13:27:51 <lambdabot> V RETURNS!
13:28:10 <nmessenger> ?
13:28:31 <int-e> @help v
13:28:31 <lambdabot> let v = show v in v
13:28:32 <nominolo> probably related to V in V for Vendetta?
13:29:10 <nmessenger> @yhjulwwiefzojcbxybbruweejw
13:29:11 <lambdabot> "\"#$%&'()*+,\""
13:30:13 <int-e> @quote ghc
13:30:14 <lambdabot>  Illegal unlifted type argument
13:30:51 <emu> is there a class of monads with a "split" operator, such that, for example in the list monad: it would return (head list, tail list)?
13:34:30 <SamB> @hoogle unQ
13:34:31 <lambdabot> Language.Haskell.Syntax.UnQual :: HsName -> HsQName
13:34:31 <lambdabot> Language.Haskell.TH.runQ :: Quasi m => Q a -> m a
13:34:35 <SamB> hmm.
13:35:02 <emu> sorta the opposite of MonadPlus
13:45:40 <scodil> what's unsafeArray?
13:46:05 <yip> @hoogle unsafeArray
13:46:06 <lambdabot> No matches found
13:46:10 <yip> @hoogle unsafeRead
13:46:11 <lambdabot> No matches found
13:46:15 <yip> @hoogle unsafeReadArray
13:46:16 <lambdabot> No matches found
13:47:58 <twanvl> There are (afaik) two unsafe things related to arrays: 1. unsafeRead/write: indexing without bounds checking, 2. unsafeFreeze/Thaw: Allowing a mutable and immutable array to share memory, meaning the immutable array could be changed.
13:49:01 <scodil> and apparently a third, unsafeArray, which I can only assume creates an array, but from what i don't know
13:49:44 <scodil> ghc is warning me that I haven't given a method definition for unsafeArray, when defining an instance of IArray
13:50:03 <twanvl> from the source:  unsafeArray :: Ix i => (i,i) -> [(Int, e)] -> Array i e
13:51:07 <scodil> whats so unsafe about that?
13:51:11 <twanvl> my guess: it leaves indices for which you don't specify a value as uninitialized memory
13:51:14 <scodil> ah
13:51:38 <twanvl> No wait
13:51:44 <twanvl> It is similair to unsafeWrite
13:51:52 <twanvl> In that it does no bounds checking
13:53:55 <scodil> is Array a type or a class? cause it looks like the (!) operator is only polymorphic in the index type, not the array type. How do all these different types of arrays (Array, UArray, DiffArray) overload (!)?
13:54:39 <twanvl> There are two (!)s, one in Data.Array and a polymorphic one in Data.Array.IArray
13:55:18 <scodil> I don't see any (!) method in Data.Array.IArray
13:55:21 <twanvl> Although they might infact be the same
13:55:23 <scodil> is this not in hoogle?
13:55:36 <scodil> IArray has one method, bounds
13:57:01 <twanvl> IArray also has 5 unsafe methods, but they are not exported
13:57:34 <twanvl> Or they have no haddock documentation
13:59:01 <JFT> Hello are there any GHC mac user on?
13:59:33 <scodil> oh ok so there's a default implementation of (!).  I'd like to see that.
14:00:03 <twanvl> (!) is not a class method, it seems. You should take a look at the Data.Array.Base source code
14:00:17 <SamB> @hoogle IArray
14:00:18 <lambdabot> Data.Array.IArray :: module
14:00:25 <SamB> @doc Data.Array.IArray
14:00:26 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array-IArray.html
14:00:32 <SamB> maybe that will be of use?
14:00:48 <SamB> it has a source link...
14:01:08 <SamB> @doc Data.Array.Base
14:01:08 <lambdabot> Data.Array.Base not available
14:01:11 <SamB> hmm.
14:01:13 <twanvl> IArray just reexports stuff from Data.Array.Base, http://darcs.haskell.org/ghc-6.6/packages/base/Data/Array/Base.hs
14:01:23 <SamB> oh.
14:01:36 * SamB goes back to poking Data.Generics
14:01:56 <scodil> if (!) is not a class method, how is it polymorphic?
14:02:33 <hyrax42> ?type max
14:02:34 <lambdabot> forall a. (Ord a) => a -> a -> a
14:02:38 <hyrax42> ?type maximum
14:02:40 <lambdabot> forall a. (Ord a) => [a] -> a
14:02:46 <scodil> yeah, the Ord part there
14:02:51 <scodil> what does (!) depend on
14:02:58 <hyrax42> nothing
14:03:01 <hyrax42> wait
14:03:05 <hyrax42> ! on array
14:03:12 <scodil> what's array?
14:03:14 <hyrax42> IArray
14:03:19 <hyrax42> ?type (!)
14:03:20 <lambdabot> forall e i. (Ix i) => Array i e -> i -> e
14:03:21 <twanvl> arr ! i = case bounds arr of (l,u) -> unsafeAt arr (index (l,u) i)
14:03:33 <scodil> there its not polymorphic
14:03:52 <hyrax42> how is it not polymorphic?
14:04:06 <scodil> er, its not polymorphic in the array type
14:04:08 <hyrax42> i and e are both unspecified types
14:04:18 <hyrax42> oh
14:04:20 <scodil> but the Array representation is concrete: boxed, immutable
14:04:27 <scodil> no UArray, no DiffArray
14:04:33 <hyrax42> it should be polymorhpic
14:04:36 <hyrax42> in array type
14:04:41 <scodil> twanvl answered my questions, though
14:04:44 <[d-_-b]> I want a function that give me "force: a" so i creat:	
14:04:44 <[d-_-b]> test = do {a <- gera1;
14:04:44 <[d-_-b]> 	putStr "force: "; print a
14:04:44 <[d-_-b]> 	}
14:04:44 <[d-_-b]> but this will give me: Tenta> test
14:04:45 <[d-_-b]> 10
14:04:47 <[d-_-b]> force: ()
14:04:49 <hyrax42> ?docs Data.Array.IArray
14:04:51 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array-IArray.html
14:05:00 <scodil> it has undocumented methods
14:05:03 <hyrax42> ?index (!)
14:05:03 <lambdabot> Data.Array.IArray, Data.Array.Unboxed, Data.Array.Diff, Data.IntMap, Data.Map, Data.Array, Text.Html
14:05:07 <scodil> unsafeAt, being the one in question
14:05:26 <hyrax42> strange that lambdabot gives the wrong type for (!)
14:05:27 <[d-_-b]> gera1 = randomRIO (x,y)
14:05:37 <hyrax42> it should have an IArray a e constraint also
14:05:48 <hyrax42> and then instaed of Array, say a
14:05:53 <scodil> I think its cause IArray is not h98
14:06:07 <hyrax42> ?type (!)
14:06:08 <lambdabot> forall e i. (Ix i) => Array i e -> i -> e
14:06:13 <hyrax42> neither are existentials
14:06:26 <hyrax42> lambdabot is most decidedly not h98
14:06:35 <scodil> i dunno
14:07:07 * hyrax42 thinks it's a bug?
14:07:20 <scodil> there's two Arrays I think
14:07:24 <scodil> Array and Data.Array
14:07:29 <hyrax42> true
14:07:32 <twanvl> It depends on whether you import Data.Array or Data.Array.IArray
14:07:36 <hyrax42> ?type Data.Array.IArray.(!)
14:07:37 <lambdabot> Not in scope: data constructor `Data.Array.IArray'
14:07:45 <hyrax42> ?type Data.Array.IArray.!
14:07:47 <lambdabot> parse error on input `Data.Array.IArray.!'
14:07:57 <hyrax42> :/
14:09:52 <allbery_b> [d-_-b]: works for me; are you sure you have gera1 defined correctly?  I suspect it's actually doing putStrLn (thus returning IO () after printing the random number)
14:11:48 <[d-_-b]> allbery_b
14:11:50 <[d-_-b]> gera1 = do {a <- randomRIO (1,6); b <- randomRIO (1,6); c <- randomRIO (1,6); d <- randomRIO (1,6);
14:11:50 <[d-_-b]> 	print (sum (tail (sort [a,b,c,d])))
14:11:50 <[d-_-b]> 	}
14:13:10 <allbery_b> yep.  print returns IO (), after printing the rand'om number.
14:13:47 <[d-_-b]> I want to define a variable like: a <- (random number) , that anytime inside de 'do' i could use it
14:14:02 <allbery_b> you don't want print, you want return
14:14:08 <[d-_-b]> hummmmmm
14:14:39 <[d-_-b]> yaa! thats it
14:14:43 <[d-_-b]> thanks :)
14:14:58 <[d-_-b]> I'm new in haskell... hehe
14:16:29 <allbery_b> return doesn't actually retur anything, it just wraps the value in the monad so it *can* be returned.  then you unwrap it again with the do {a <- gera1; ... so you can work with it, again inside the IO monad
14:16:56 <Korollary> you can use a let inside a do block
14:18:52 <twanvl> yes
14:19:16 <twanvl> a<-return ... is pretty useless
14:22:25 * roconnor tries to remember the strict/lazy pattern matching in the statement a <- return ...
14:26:39 <[d-_-b]> humm i see
14:26:41 <[d-_-b]> :)
14:28:33 <chessguy> hmm, quiet in here
14:30:38 <jcreigh> > (sequence $ replicate 4 (randomRIO (1,6))) >>= (return . sum)
14:30:39 <lambdabot>  Add a type signature
14:30:47 <jcreigh> > (sequence $ replicate 4 (randomRIO (1,6))) >>= (return . sum) :: Int
14:30:48 <lambdabot>  Couldn't match `Int' against `IO a'
14:31:00 <jcreigh> hmm...
14:31:36 <jcreigh> > sequence $ replicate 4 (randomRIO (1,6))
14:31:37 <lambdabot>  Add a type signature
14:32:06 <jcreigh> > sequence $ replicate 4 (randomRIO (1,6)) :: IO [Int]
14:32:08 <lambdabot>  <IO [Int]>
14:32:16 <jcreigh> oh, right, no IO allowed.
14:33:00 <mr_tenor> instead of type aliasing lists,is it usual to define a newtype and then use to/from functions whenever you need to do any list operations? It gets ugly :(
14:33:40 <chessguy> you mean instead of [] notation?
14:33:57 <SamB> mr_tenor: for what purpose?
14:34:51 <mr_tenor> the purpose of the new type being stricter type checking when lost of lists with different semantics are floating around, the purpose of to/from being so one can pattern match, cons, use list comprehensions etc
14:35:20 <SamB> I meant what are you using the lists for?
14:35:43 <edi> dcoutts_: do you know how to run gtk2hs programs with gtk2+quartz on osx?
14:35:56 <mr_tenor> SanB: in my current problem, rows of image samples
14:36:51 <SamB> anyway, if you think it would be a good idea, go ahead and try it
14:38:20 <mr_tenor> obviously i want my typechecking, but using to/from functions everywhere feels wrong. I imagine it's a common problem (eg. http://www.haskell.org/haskellwiki/Non-trivial_type_synonyms)
14:38:22 <lambdabot> Title: Non-trivial type synonyms - HaskellWiki
14:38:43 <SamB> mr_tenor: well, if you need to use it as a list everwhere...
14:39:04 <SamB> the alternative is to make a newtype to put in the list
14:39:23 <hyrax42> if you do (minimum nums):(omit (minimum nums) rest), will ghc "magic" the (minimum nums) to be computed just the one time?
14:39:35 <Korollary> yes
14:39:55 <SamB> its called CSE
14:40:03 <SamB> not magic
14:40:08 <Botje> common subexpression elimination?
14:40:11 <Botje> what do i win! :p
14:40:18 <hyrax42> it's not some kind of graph reduction?
14:40:23 <hyrax42> oh ok
14:40:26 <hyrax42> I didn't know the name
14:40:38 <SamB> it might be a kind of graph reduction. sort of.
14:40:52 <int-e> hyrax42: CSE is what recognizes that  minimum nums  and  minimum nums  are the same
14:41:17 <hyrax42> how much will it expand to realise things are common?
14:41:31 <hyrax42> or never mind, that's really not something I need to be worrying about right nwo
14:41:33 <int-e> let minN = minimum nums in minN : omit minN rest
14:41:41 <int-e> that makes it explicit
14:41:46 <Botje> has anyone implemented a haskell compiler in haskell yet?
14:41:56 <hyrax42> Botje: huh?
14:41:59 <SamB> Botje: what do you mean by "Haskell"?
14:42:06 <sorear> [GYJ]HC
14:42:13 <hyrax42> N?
14:42:19 <Botje> I thought those were written in C?
14:42:22 <hyrax42> E?
14:42:26 <sorear> [GYJNE]HC
14:42:36 <mr_tenor> what i you can't recognise identical expressions til runtime, when the paramaters are substituted?
14:42:50 <SamB> sorear: are any of those in ordinary Haskell?
14:42:51 <sorear> that is called automatic memoization.
14:43:28 <sorear> Most of the time, automatic memoization is bad for performance, so no compiler does it unconditionally.
14:43:29 <int-e> hyrax42: ghc won't look very hard. mostly it just optimizes let x = e in ... e ...
14:43:47 <hyrax42> hmk
14:43:56 <sorear> SamB: I've heard [NY]hc is Haskell-98, but not checked it myself.
14:44:26 <hyrax42> EHC is too, but ti's not really a compiler for h98
14:44:27 * SamB is having trouble trying to write some code to "represent" Data.Map.Maps for YAML...
14:44:28 <hyrax42> I don't think
14:44:39 <int-e> hyrax42: there's a reason for this - CSE can introduce space leaks. (by making data kept alive that would otherwise be computed several times but consumed as it is produced)
14:44:57 <kyevan> OK, Dylan explained a bunch of monady stuff to me. (<< and <<=)
14:45:10 <Botje> kyevan: no. >> and >>=
14:45:15 <kyevan> Er, yeh
14:45:16 <SamB> sorear: hmm, I suppose it is
14:45:17 <kyevan> >> and >>=
14:45:25 <lightstep> >=> is also nice
14:45:32 <nmessenger> :t (>=>)
14:45:34 <lambdabot> Not in scope: `>=>'
14:45:39 <SamB> if you include the shoe-in extensions
14:45:47 <sorear> On examination, yhc uses at least hierarichal modules.
14:45:50 <sorear> shoe-in?
14:45:55 <kyevan> Anyway, he mentioned another thing for monads, return
14:45:56 <lightstep> (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)
14:46:00 <kyevan> What does that do?
14:46:06 <sorear> Kliesi composition.
14:46:09 <Botje> kyevan: it wraps the value in the monad.
14:46:17 <Botje> :t return
14:46:18 <kyevan> Botje: Oh,
14:46:19 <lambdabot> forall (m :: * -> *) a. (Monad m) => a -> m a
14:46:21 <sorear> it's like >>> for Kliesi arrows of a monad.
14:46:28 <SamB> the ones that you'd have to be an idiot not to include in the next standard?
14:46:29 <kyevan> sorear: ... WHA?
14:46:40 <allbery_b> "shoo-in" fwiw
14:46:49 <SamB> you know, hierarchichal modules and FFI
14:46:50 <Botje> arrows are evil. but only because I don't understand them fully yet
14:47:03 <[d-_-b]> if I define a variable inside a 'do' block, like "a <- randomRIO (2,3)", exist any way to I go get that variable to other 'do' block?
14:47:08 <sorear> a >=> b x = do y <- a x ; b y
14:47:23 <lightstep> arrows're nice: they allow things like phooey to look really pretty
14:47:31 <sorear> it'll automatically go to nested expressions:
14:47:37 <sorear> do x <- foo
14:47:43 <sorear>    do y <- bar foo
14:47:47 <sorear>       z y
14:47:53 <sorear> would work
14:47:57 <kyevan> Um, maybe I'll just ask Dylan when I see him again. He manages to explain stuff to me in a way I understand :P
14:48:41 <Botje> kyevan: try to understand monads first. arrows are a generalisation of monads.
14:48:52 <lightstep> [d-_-b], if you call a function with this value, it will be available in its body
14:49:02 <SamB> f >=> g = \x -> f x >>= g -- right?
14:50:18 <lightstep> yes
14:50:49 <nmessenger> :t \f g -> \x -> f x >>= g
14:50:51 <lambdabot> forall (m :: * -> *) a t b. (Monad m) => (t -> m a) -> (a -> m b) -> t -> m b
14:51:03 <nmessenger> cool
14:51:40 <kyevan> But, but, WHA?
14:51:42 <emu> @instances MonadPlus
14:51:43 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
14:52:07 <SamB> sorear: I need a working ext2Q
14:52:10 <allbery_b> kyevan: just smile and nod, like I am :)
14:52:12 <SamB> can you find and/or make me one?
14:52:43 <joelr1> good evening
14:52:46 <SamB> oh, wait.
14:52:49 <SamB> I think mine works.
14:52:55 <joelr1> @seen musasabi
14:52:55 <lambdabot> I saw musasabi leaving #ghc, #haskell-overflow, #haskell-blah, #haskell and #Haskell 19d 8h 5m 47s ago, and .
14:53:13 <joelr1> wow! einar hasn't been online for 19 days?!
14:53:23 <SamB> but my actual copy of Data.Map probably doesn't implement dataCast2 correctly...
14:54:14 <agocorona> hi. If I compile a program that uses eval from hs-plugins, then, do I need to have GHC installed on every machine where I want to run it?
14:54:46 <SamB> I don't think I like YAML, anyway...
14:54:52 <agocorona> hs-plugins uses ghc for runtome compilation?
14:55:05 <agocorona> runtime , sorry
14:55:12 <SamB> yes
14:55:23 <joelr1> agocorona: i think there are plans to change that
14:55:34 <SamB> but, soon it may use GHC the library
14:55:52 <agocorona> thats not good
14:56:10 <agocorona> when is planned not to depend on GHC?
14:56:28 <allbery_b> er, how are you expecting it to support eval without a compiler around?
14:56:45 <SamB> well, I'm pretty sure you only need GHC around if you actually ask it to compile code at runtime...
14:56:47 <allbery_b> or do you mean "when will it use the library?"
14:56:48 <agocorona> with another embedded compiler
14:56:59 <SamB> well, that compiler would still be GHC
14:57:20 <SamB> unless you mean "when will hs-plugins work with other Haskell compilers?"
14:57:24 <SamB> in which case I have no clue
14:57:32 <joelr1> agocorona: i think it will have ghc embedded, so to speak
14:57:48 <sorear> Imagine, say, hs-plugins for hugs - eval is easy...
14:57:56 <agocorona> I mean some kind of embedding , yes
14:58:16 <SamB> sorear: well, you'd compiler support...
14:58:17 <joelr1> agocorona: which to me means that people won't have to install ghc separately. plus, it will likely be a smaller subset of ghc... or something. at least in the runtime
14:58:34 <agocorona> I need a way to delivery the application as easy as possible
14:59:03 <agocorona> joerlr1: that right
14:59:43 <joelr1> agocorona: i think the idea would be that you distribute your app with the compiler library built-in and with just enough libraries for your app to work with hs-plugins. to compile the plugins that you work with
14:59:44 <sorear> what, you can't just put 'Depends: ghc6.6' in debian/control :)
15:00:20 <joelr1> agocorona: i actually need that myself if i'm to do my trading platform using haskell. i would load trading systems into the "kernel" using hs-plugins
15:00:32 <nmessenger> I know nothing of hs-plugins; couldn't pluggable bits be compiled beforehand, and the compiled files loaded at runtime somehow?
15:00:50 <SamB> sorear: can you tell me if you can use that YAML code I just sent you on Maps?
15:01:56 <Mitar> what "Non-exhaustive patterns in function" runtime error means? or rather: how can I get rid of all those runtime errors? like in OCaml?
15:01:57 <joelr1> nmessenger: that would not make much sense. you could then just compile the bits into your app, no dynamic loading needed
15:02:09 <beschmi> i don't think you need a separate ghc binary if you use ghc-api, but your binary won't be small (17MB here).
15:02:19 <mauke> Mitar: enable warnings when compiling
15:02:22 <agocorona> It is also a question of speed. If the compilation is not done in memory (sort of). then the compilation speed make in unsuitable for some applications
15:02:30 <yip> holy shitballs, 17MB????? :O :o :O
15:03:15 <joelr1> yip: what's that?
15:03:17 * sorear is taking the opportunity to learn about darcs conflict handling :)
15:03:27 <fabiim> how could i see that all elements in a list are equal ?
15:03:32 <yip> joelr1: shitballs?
15:04:19 <twanvl> fabiim: (all (== head list)) list?
15:04:22 <sorear> all . map (==) . ap zip tail ?
15:04:24 <nmessenger> \xs -> and (zipWith (==) xs (tail xs))
15:04:47 <mauke> yay, nmessenger's mind works like mine
15:05:08 <joelr1> yip: what's 17mb?
15:05:09 <twanvl> I feel left out :(
15:05:13 <beschmi> yip: 9.8 MB after strip, just like ghc
15:05:21 <kyevan> OK, so, um, a >> b returns b, but makes sure that a is done first.
15:05:37 <beschmi> joelr1: an application using ghc-api that includes most (all?) of the compiler
15:05:40 <mauke> yeah, kind of like , in C
15:05:44 <nmessenger> mauke, I actually have adjacentsSatisfy p xs = and (zipWith p xs (tail xs)), that way I can define isSorted = adjacentsSatisfy (<=)
15:05:44 <mauke> or ; in OCaml
15:05:52 <int-e> > null . tail . group $ [1,1,1]
15:05:52 <yip> beschmi: what about after upx?
15:05:54 <lambdabot>  True
15:06:04 <fabiim> by the way
15:06:06 <yip> joelr1: beschmi's haskell program
15:06:12 <fabiim> all elements are different
15:06:28 <joelr1> yip: hmm... what does it do? i must be late to the party
15:06:34 <SamB> sorear: did I mess up something you did in Standard.hs?
15:06:39 <kyevan> And, a >>= b is like ., but it takes the value out of the monad first?
15:06:59 <yip> joelr1: it reportedly uses ghc-api
15:07:05 <kyevan> So, it does a, then calls b with the value of a.
15:07:06 <joelr1> yip: ok
15:07:07 <kyevan> Right?
15:07:10 <beschmi> joelr1: http://beschmi.de/shim/
15:07:12 <lambdabot> Title: Index of /shim
15:07:17 <SamB> sorear: boy, you have been busy...
15:07:25 <nmessenger> kyevan: kinda sorta.  It works.
15:07:31 <mauke> kyevan: right
15:07:47 <joelr1> beschmi: what does shim do? is there an announcement someplace
15:08:40 <beschmi> joelr1: it's an extension for the standard haskell emacs mode
15:08:56 <joelr1> beschmi: right, i figured as much. what does it do, though? how does it help?
15:09:02 <shapr> dang, I had a question.. I wonder what it was.
15:09:02 <kyevan> Then, monads have a third function, return?
15:09:08 <kyevan> What does that do?
15:09:13 <Mitar> and why this is not default? strict checking
15:09:17 <mauke> kyevan: it puts a value in the monad
15:09:20 <nmessenger> :t return
15:09:21 <lambdabot> forall (m :: * -> *) a. (Monad m) => a -> m a
15:09:43 <nmessenger> given any x, return x lifts it into the Monad.
15:09:44 <kyevan> nmessenger: ... That's not helpful.
15:09:50 <mauke> note that >> isn't primitive: a >> b = a >>= const b
15:10:08 <lightstep> Mitar, it's customary in compilers not to enable all warnings by default
15:10:14 <beschmi> joelr1: it does function/module name completion and it can show/insert the inferred type for a toplevel declaration
15:10:18 <kyevan> nmessenger: Soo, It puts a value into a monad?
15:10:24 <Mitar> hmm, but in OCaml this is error! not just warning :-)
15:10:28 <beschmi> joelr1: no announcement yet
15:10:32 <nmessenger> That's what a -> m a means, and yes.
15:10:36 <lightstep> kyevan, it allows you to use a simple value where the type would demand a monadic value
15:10:37 <Mitar> is not this an idea of a strict language?
15:10:44 <Mitar> that it check and enforces all this things?
15:11:13 <mauke> Mitar: Warning P: this pattern-matching is not exhaustive.
15:11:19 <mauke> looks like a warning to me
15:11:19 <nmessenger> in Maybe, for example, return = Just
15:11:37 <lightstep> Mitar, you could alias ghc to "ghc -Wall -Werror"
15:11:45 <Mitar> hmm, than i have remebered this wrong
15:11:49 <joelr1> beschmi: can you use it like slime? eval chunks of code into it?
15:11:53 <beschmi> joelr1: works a bit like slime with a haskell server process that communicates with emacs over unix-domain sockets
15:12:05 <beschmi> joelr1: no yet
15:12:10 <beschmi> joelr1: not yet
15:12:36 <sorear> SamB: the conflicts are trivially resolvable
15:12:39 <joelr1> beschmi: is that the plan, though? sort of like a super haskell REPL?
15:13:09 * sorear is glad to see that the rumors of darcs being incompatible with conflicts have at least a grain of falsehood
15:13:55 <beschmi> joelr1: yes
15:14:13 <joelr1> beschmi: cool!
15:14:50 <kyevan> sorear: It's no more incompatable with conflicts than svn or cvs... I think
15:16:23 <nmessenger> > return 5 :: Maybe Int
15:16:25 <lambdabot>  Just 5
15:16:31 <nmessenger> > return 5 :: IO Int
15:16:32 <lambdabot>  <IO Int>
15:16:47 <nmessenger> > return 5 :: [Int]
15:16:49 <lambdabot>  [5]
15:17:32 <beschmi> joelr1: but i'm not how much of that is possible in haskell, e.g. hacking on a server application with restarting it like in erlang/lisp
15:17:55 <beschmi> joelr1: but i'm not _sure_ how much ...
15:18:24 <beschmi> joelr1: _without_ restarting it like in erlang/lisp
15:18:28 <joelr1> beschmi: yes, i would love to have the answer. i think hs-plugins has part of it. they have a way to restore/merge state
15:20:22 <sorear> SamB: YAML code works here
15:22:55 <joelr1> data IV index item elt = Val elt | Fn (index item elt->Set.Set item)
15:23:04 <chessguy2> TEST
15:23:14 <joelr1> is the last bit here a function taking elt and returning Set.Set item?
15:23:23 <dmead> > let 2001 = "good stuff"
15:23:24 <lambdabot>  Parse error
15:23:26 <dmead> :>
15:23:34 <joelr1> how do you parse that expression?
15:25:43 <love> hello,everybody
15:25:54 <chessguy> hi love
15:25:58 <_magus_> love, hi
15:26:47 <nmessenger> <3
15:27:21 <monochrom> <3 #haskell
15:27:28 <SamB> sorear: even for Maps?
15:27:53 <sorear> represent (M.fromList [("foo","bar"),("baz","quux")])
15:28:02 <sorear> ^^^ that what you mean -- works fine here
15:28:24 <sjanssen> joelr1: the last bit takes an "index item elt" and produces a Set item
15:28:26 <joelr1> SamB: how do you parse this? data IV index item elt = Val elt | Fn (index item elt->Set.Set item)
15:28:36 <joelr1> it's been a while
15:28:49 <sjanssen> joelr1: so index must be some higher kinded type constructor
15:29:04 <joelr1> i guess i need to read up on the syntax of "data" again
15:29:09 <SamB> joelr1: are you talking to me?
15:29:25 <joelr1> SamB: yes but sjanssen already answered, thanks
15:29:38 <joelr1> sjanssen: is that some sort of a GADT syntax
15:29:48 <sjanssen> joelr1: nope, it's standard Haskell
15:30:02 <joelr1> sjanssen: ok, thanks /it's been a while/
15:30:05 <int-e> joelr1: index is a (variable) two argument type constructor there.
15:30:06 <SamB> heh
15:30:12 <SamB> GADT syntax is probably easier
15:30:20 <SamB> seriously
15:30:32 <SamB> except it doesn't support derivings :-(
15:30:33 <sjanssen> SamB: I see no advantage in this example
15:30:42 <SamB> sjanssen: in general, it is easier
15:30:46 <joelr1> SamB: what would be the GADT syntax here?
15:30:53 <sjanssen> GADTs are overrated in my opinion
15:30:58 <SamB> sjanssen: it makes the types of the constructors more obvious
15:31:05 <SamB> I'm not talking about a GADT itself
15:31:16 <joelr1> int-e: and IV is the type then, right?
15:31:17 <SamB> just the syntax that GHC provides for declaring them
15:31:26 <sjanssen> right, the syntax
15:31:40 <SamB> yes, I think that syntax is much easier to understand
15:31:44 <sjanssen> I think it's a bit verbose
15:31:48 <SamB> yes
15:31:52 <love> Thank you .
15:32:11 <int-e> joelr1: I don't know if that helps you, but IV has kind (* -> * -> *) -> * -> * -> *
15:32:12 <SamB> but I would have had an easier time with "data" declarations if they had looked like that, nevertheless
15:32:39 <sjanssen> and it's very easy to accidentally write a GADT (and I really mean G) with the syntax
15:32:50 <int-e> joelr1: IV Map Int Int  is a type.
15:32:52 <SamB> probably
15:33:33 <joelr1> int-e: get it, thanks!
15:33:35 <SamB> but, on the other hand, if Haskell 98 had used that syntax but not allowed GADTs, then it would likely be a flag...
15:34:05 <SamB> the only reason we think that syntax is intuitive is because we are used to it
15:34:25 <SamB> (er, "that syntax" being the standard syntax)
15:34:28 <sorear> SamB: does Map serialization not work for you?
15:34:33 <SamB> sorear: it does not
15:34:53 <SamB> I think my Data.Map must be broken
15:35:46 <sjanssen> has Map always been an instance of Data?
15:35:56 <SamB> sjanssen: not sure
15:35:59 <SamB> but mine is
15:36:00 <sjanssen> could be you've got an older version
15:36:30 <SamB> as far as I can tell, the problem is that it doesn't implement the dataCast2 method
15:37:53 * SamB isn't sure he wants to finish YAML support
15:38:04 <ndm> SamB, YAML?
15:38:23 <fabiim> how can i do patter matching on a list of Strings to get the first elements and the last two ?
15:38:27 <SamB> ndm: for genericserialize
15:38:37 <sorear> I should note that generic serialization will not work with Data.Map because Data.Map does not implement Data.toConstr; a note in the source says "We sacrifice utility for the sake of abstraction", or something equivilent.
15:38:41 <SamB> YAML Ain't a Markup Language
15:38:58 <joelr1> SamB: how do you find genericserialize? fast enough? easy to use
15:39:06 <SamB> use?
15:39:06 <ndm> fabiim: you can't do that with pattern matching, you can only match at the start
15:39:14 <SamB> it doesn't support using yet, afaict
15:39:15 <sorear> Any generic serializer that supports Data.Map must do it using a type-specific case
15:39:15 <mauke> fabiim: you can't directly get the last elements with pattern matching
15:39:26 <SamB> sorear: this is icky
15:39:37 <fabiim> ok thanks
15:40:01 <sorear> in which aspect?
15:40:01 <sjanssen> > let lastTwo [x, y] = (x, y); lastTwo (x:xs) = lastTwo xs in lastTwo [1..10] -- fabiim, maybe this helps?
15:40:03 <chessguy> icky....is that a technical term?
15:40:03 <lambdabot>  (9,10)
15:40:09 <mauke> @hoogle Int -> [a] -> [a]
15:40:10 <lambdabot> Prelude.drop :: Int -> [a] -> [a]
15:40:11 <lambdabot> Prelude.take :: Int -> [a] -> [a]
15:40:11 <lambdabot> Control.Parallel.Strategies.parBuffer :: Int -> Strategy a -> [a] -> [a]
15:40:26 <sjanssen> take 2 . reverse would work too
15:41:29 <SamB> we should start a discussion of DataRep/ConstrRep on the list...
15:42:12 <SamB> I think they should include support for Data.Map, Data.Set, and Data.IArray-like things
15:42:49 <SamB> (which would include Data.IntMap and Data.IntSet)
15:43:29 <sjanssen> could they provide fake implementations that wrap lists?
15:44:07 <SamB> chessguy: that is what you use to describe something that offends your sensibilities ;-)
15:44:34 <dons> moin
15:44:55 <joelr1> dons: good morning
15:44:56 <joelr1> ?
15:45:12 <chessguy> SamB, :)
15:45:13 <SamB> dons: don't you think that Data.Generics should work with arrays, maps, sets, and so forth?
15:45:18 <chessguy> @localtime dons
15:45:20 <lambdabot> Local time for dons is Sun Dec 17 10:40:55 2006
15:45:30 <shankys> bringert: I can't get the examples in dyn-cgi to work. I'll put in "localhost/dyn-cgi/dynhs.fcgi/examples/error.hs" and get a 404 Not Found - The requested resource was not found: examples/error.hs". I feel like I'm doing something obviously wrong that I'm not seeing.
15:45:57 <chessguy> 'morning dons
15:46:09 <bringert> shankys: it's probably something with the paths
15:46:21 <SamB> I can think of two approaches
15:46:26 <bringert> shankys: try addin logging which prints the paths
15:47:29 <shankys> bringert: Do I have to manually add that to the code or do you already have something in there that does that (like a debug mode or something)?
15:47:44 <SamB> one involves conversion to/from another type (probably some kind of list type), the other involves support for the Map-like, the Set-like, and the Array-like individually...
15:48:09 <bringert> shankys: you have to add it, sorry
15:48:42 <bringert> shankys: I've never gotten around to polishing dyn-cgi for release, it's pretty much my internal hack
15:49:10 <bringert> I used it to write a small course evaluation app
15:50:58 <shankys> bringert: I have another question. Is dynHSDir in Config.hs supposed to be a relative path of the full path to something?
15:51:09 <shankys> *or the full path
15:51:39 <shankys> bringert: Also, I really don't know what packageDir is for...
15:52:06 <shankys> bringert: I keep wondering if maybe I have the wrong value set for those...
15:52:09 <bringert> shankys: dynHSDir is supposed to be relative to the root of the hierarchy served by dyn-cgi
15:52:40 <SamB> dons: hmm, your Data instances aren't very nice.
15:52:48 <SamB> Prelude Data.Generics Data.Map Data.ByteString.Char8 Data.Word> gmapQ typeOf (pack "hi!")
15:52:48 <SamB> [ForeignPtr Word8,Int,Int]
15:52:53 <bringert> shankys: packageDir is the GHC package dir (there's a step in the README to make it a symlink to you GHC package dir)
15:53:13 <bringert> or you can change packageDir to point to the real location
15:53:27 <SamB> if I'm using Data.Generics, do you think I wanted to know that a ByteString consists of a ForeignPtr to Word8, an Int, and an Int?
15:53:54 <_matthew-> ?hoogle (a -> Bool) -> ([a],[a])
15:53:55 <lambdabot> List.partition :: (a -> Bool) -> [a] -> ([a], [a])
15:53:56 <lambdabot> Prelude.break :: (a -> Bool) -> [a] -> ([a], [a])
15:53:56 <lambdabot> Prelude.span :: (a -> Bool) -> [a] -> ([a], [a])
15:54:19 <SamB> or that it has a constructor called "PS"?
15:54:57 <nominolo> dons: "moin" is international?
15:55:22 <bringert> shankys: I'm looking though the code. maybe you can log the current directory and paths it's looking for in findFile and findPathInfo in DynHS/File.hs
15:55:37 <bringert> that should show you where it is looking
15:55:41 <SamB> anyway, I like genericserialize
15:55:56 <bringert> that path handling in dyn-cgi needs to be simplified. it should be doable
15:56:14 <SamB> it will reveal much that is wrong with Data.Generics and with many Data instances...
15:56:19 <shankys> bringert: Ok, alright I'll try that and see where I get. I'm determined to make this all work. When I finally do get it to work, I'm writing a tutorial for this :)
15:57:01 <bringert> shakys: great! maybe you can document the code if you find anything hard to understand :-)
15:58:25 <shankys> bringert: When I actually get this going, I'll have 3 other people besides me that are working a fair amount over the next month on this Haskell web framework. This is a pretty key part of the framework in terms of just making things nice to use so I'm sure we'll have patches for you ;)
15:58:46 <bringert> sweet
15:59:17 <bringert> shankys: need a consultant? ;-)
15:59:52 <shankys> bringert: Hehe, if we get VC level funding then yeah.
16:01:12 <bringert> I'm glad that you are using it. I haven't had time to work on dyn-cgi for a while, but it worked really well for the small apps I've used it for. It would be nice to get it polished enough to release.
16:01:29 <[d-_-b]> guys... I have this function:
16:01:31 <[d-_-b]> func = do {n <- getLine;
16:01:32 <[d-_-b]> 	print 1
16:01:32 <[d-_-b]> 	}
16:01:58 <[d-_-b]> and I want to use that variable 'n' in other 'do'
16:01:58 <shapr> yarr!
16:02:09 <_matthew-> return n
16:02:37 <shankys> bringert: For the Haskell web framework we're doing, we're using just about every web related library that you maintain... I think for a Haskell framework to succeed, something like dyn-cgi is pretty important just in terms of convenience.
16:03:19 <chessguy> [d-_-b], you'll need to provide a few more details, i think
16:03:29 <bringert> shapr: want a christmas present? http://cgi.ebay.com/NEW-34B-blck-Smoothie-Seductively-slim-undwr-shapr-V215_W0QQitemZ300059055920QQihZ020QQcategoryZ45275QQssPageNameZWDVWQQrdZ1QQcmdZViewItem?hash=item300059055920
16:03:32 <lambdabot> Title: eBay: NEW*34B blck Smoothie Seductively slim undwr shapr V215 (item 300059055920 ..., http://tinyurl.com/udbwe
16:03:34 <nmessenger> [d-_-b]: where does the 'l' in 'print l' come from?
16:03:47 <shapr> wahr?
16:03:48 <allbery_b> I see a 1, not an l
16:04:04 <nmessenger> Oh, my client suxxorz
16:04:13 <allbery_b> perhaps I shoudl say 1 :: (Num a) => a :)
16:04:28 <bringert> shankys: Yeah, I agree. Recompiling and uploading for every change is a pain. One problem with dyn-cgi is that you need the whole GHC package dir on the server.
16:04:47 <bringert> but at least you don't need the GHC binary, just the ghc package
16:05:26 <lisppaste2> dons pasted "code" at http://paste.lisp.org/display/32627
16:05:35 <[d-_-b]> I receive a 'n' in the function func, and I want to use that 'n' in another function
16:05:41 <shankys> bringert: For our startup that won't really be a problem since we have full control over our servers and will colo from the very beginning... It's probably a pain for most people though.
16:05:43 <bringert> shankys: I did some benchmarks btw, interpreted GHC code seems pretty fast. Should beat the pants of ruby, php et al at least
16:05:54 <nmessenger> [d-_-b]: you could 'do1 = do {n <- getLine; print 1; return n}; do2 = do {n <- do1; doSomethingWith n}'
16:06:01 <dons> [d-_-b]: ^^
16:06:09 <dons> -- http://paste.lisp.org/display/32627
16:06:10 <chessguy> leave it to dons to cut straight to the heart of it
16:06:25 <bringert> shankys: memory use for dynhs.fcgi can also be a problem, but if you have a colo box and not too many concurrent fastcgi processes you should be ok
16:06:49 <SamB> dons: have you heard my complaints yet?
16:06:50 <shapr> bringert: To be honest, the only custom underwear I use is to keep my unicycle seat from chafing on long rides.
16:06:58 <bringert> shankys: you may want to play with the GHC RTS parameters to get customize the memory behavior
16:06:59 <dons> SamB: no? but I'm sure I'm about to.
16:07:05 <chessguy> ok, WAY to much info
16:07:06 <shapr> A seductive black smoothie is not my style.
16:07:07 <kNt> hi have someone used HsDecl or HsFunBind ?
16:07:21 <SamB> dons: your Data instances for Data.ByteString are silly
16:07:34 <kNt> i'm having troubles understanding the definition of it
16:07:54 <dons> SamB: talk to audreyt :) she wrote them for pugs
16:08:10 <shapr> Ok, I have a complaint about C.
16:08:15 <[d-_-b]> nmessenger, but I want to use the value that was save in the 'n', not the variable 'n'
16:08:16 <SamB> oh.
16:08:18 <SamB> audreyt:
16:08:29 <SamB> those Data instances for Data.ByteString are silly
16:08:40 <shapr> It takes too long to fix bugs in C.
16:08:42 <bringert> shankys: I used this in Hope: http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html#rts-hooks
16:08:43 <dons> [d-_-b]: same thing
16:08:44 <lambdabot> Title: 4.14. Running a compiled program, http://tinyurl.com/d7dj4
16:08:53 <SamB> dons: but wouldn't you like them to be nice Data instances too?
16:09:11 <bringert> for controlling the memory use of my fastcgi processes
16:09:15 <dons> sure. if that makes sense.
16:09:20 <dons> [d-_-b]: did you see the code I posted?
16:09:22 <SamB> I bet audreyt just wanted there to *be* Data instances, so she could derive Data instances for things that might contain Data.ByteStrings
16:09:26 <shankys> bringert: Interesting...
16:09:28 <SamB> er. ByteStrings...
16:09:33 <shapr> I found some simple bugs in freedroid RPG, but they won't be fixed until the devs have more time. Haskell bugs don't take much time to fix.
16:09:33 <dons> SamB: ah could be
16:09:35 <SamB> Prelude Data.Generics Data.Map Data.ByteString.Char8 Data.Word> gmapQ typeOf (pack "hi!")
16:09:35 <SamB> [ForeignPtr Word8,Int,Int]
16:09:35 <SamB> Prelude Data.Generics Data.Map Data.ByteString.Char8 Data.Word> toConstr (pack "hi!")
16:09:35 <SamB> PS
16:09:37 <dons> well, you know how to darcs send
16:09:44 <SamB> dons: yeah.
16:09:48 <nmessenger> [d-_-b]: Yeah, dons' code is effectively identical.
16:10:03 <SamB> I should probably just send an email to libraries@ though, because I bet its not quite that easy
16:10:12 <[d-_-b]> yaa... i see :) thanks
16:10:55 <kNt> hi have someone used HsDecl or HsFunBind ? i'm having troubles understanding the definition of it
16:14:24 <kNt> hi have someone used HsDecl or HsFunBind ? i to apply it to parse a datatype & pretty print it..
16:14:52 <dons> don't repeat yourself. if no one answers, it means the question is either too vague, or too hard :)
16:15:08 <dons> kNt: you could paste to the lisp site what could you've current got, what it does wrong
16:15:13 <dons> and then people might see how to fix it
16:15:21 <chessguy> dons, or both :)
16:15:30 <dons> but the golden rule is: provide enough information in the question
16:15:35 <kNt> i don't have anything yet :\ i'm only researching about it
16:15:37 <dons> ?paste <-- here
16:15:37 <lambdabot> http://paste.lisp.org/new/haskell
16:15:59 <dons> well, yes, plenty of people have used the Language.Haskell parser and pretty printer
16:16:09 <kNt> but the defenition of it it's kind of hard to understand http://haskell.org/ghc/docs/latest/html/libraries/haskell-src/Language-Haskell-Syntax.html#t%3AHsDecl
16:16:11 <lambdabot> http://tinyurl.com/y7g5rc
16:17:14 <kNt> someone have a example of a pretty printing of a datatype using that functions and parsing
16:17:37 <dons> you use the 'redner' function to pretty print
16:17:41 <dons> render
16:17:48 <SamB> sorear: I assume Data.{,Int}{Map,Set} are all in the same boat wrt Data.Generics?
16:17:58 <nmessenger> redner sounds cooler
16:20:27 <dons> great news. the GHCi debugger appears to be in the head!
16:21:11 <mr_tenor> sif debugger
16:21:39 <sorear> I think so
16:22:18 * sorear runs darcs-all pull
16:22:33 <mr_tenor> hmm...sounds cool:)
16:23:10 <kNt> dons : what import do i need to use that function?
16:24:19 <dons> kNt: its in the Language.Haskell documentation
16:24:22 <dons> ?docs Language.Haskell
16:24:23 <lambdabot> Language.Haskell not available
16:24:33 <dons> ?docs Language.Haskell.Syntax
16:24:33 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/haskell-src/Language-Haskell-Syntax.html
16:24:47 <agocorona> what means "in the head" for the GHCi debugger?
16:25:00 <dons> ah, its in the ghc unstable branch
16:31:01 <[d-_-b]> guys... how can I store this um a variable 'p':
16:31:04 <[d-_-b]>  PF0607> showPersonagem p
16:31:04 <[d-_-b]> Forca: 7
16:31:04 <[d-_-b]> Destreza: 13
16:31:04 <[d-_-b]> Inteligencia: 15
16:31:04 <[d-_-b]> Carisma: 15
16:31:20 <[d-_-b]> in a variable p
16:31:54 <[d-_-b]> what's the type of 'p'?
16:32:07 <dons> you want to store the string?
16:32:32 <[d-_-b]> I want to store:
16:32:32 <kNt> ?paste
16:32:33 <lambdabot> http://paste.lisp.org/new/haskell
16:32:35 <[d-_-b]> Forca: 7
16:32:35 <[d-_-b]> Destreza: 13
16:32:35 <[d-_-b]> Inteligencia: 15
16:32:35 <[d-_-b]> Carisma: 15
16:32:44 <dons> yeah, don't paste output here
16:32:44 <[d-_-b]> in the variable 'p'
16:32:47 <dons> put it on the wiki
16:33:05 <lisppaste2> kNt pasted "render" at http://paste.lisp.org/display/32632
16:33:06 <dons> [d-_-b]: ok, so  p = "Forca: 7 ...."
16:33:11 <[d-_-b]> yeah
16:33:49 <jdroid-> hey dons
16:33:52 <jdroid-> did you make a new article?
16:33:53 <dons> hey jdroid-
16:34:04 <dons> just woke up it'll be done in an hour or two :)
16:34:09 <dons> ?time dons
16:34:10 <SamB> sorear: are you on the libraries@ list?
16:34:12 <lambdabot> Local time for dons is Sun Dec 17 11:29:47 2006
16:34:13 <lisppaste2> kNt annotated #32632 with "error" at http://paste.lisp.org/display/32632#1
16:34:21 <dons> sunday morning :)
16:34:44 <jdroid-> australia, right?
16:34:45 <allbery_b> [d-_-b]: if this is related to your earlier queries, then instead of using putStrLn and print, you want to use show and concatenation
16:35:01 <jdroid-> you're in the future. here in the states, we're way back in time. :)
16:35:15 <_matthew-> oh my, are england all out yet then?
16:35:53 <allbery_b> that is, instead of `putStr "Forca: "; print 7' you want "Forca: " ++ show 7
16:36:00 <sorear> SamB: yes
16:36:55 <allbery_b> ...and since you were working in IO with random numbers probably you want:  do { n <- gera1; return ("Forca: " ++ show n) }
16:37:15 <allbery_b> (type is IO String)
16:39:13 <SamB> sorear: okay, I sent my message to the list
16:40:02 <kNt> how do i write something of the type Doc? ->  http://paste.lisp.org/display/32632#1
16:43:47 <kyevan> hm...
16:44:06 <kyevan> > a = [1:a]
16:44:06 <lambdabot>  Parse error
16:44:10 <kyevan> :/
16:44:20 <kNt> (1:a)
16:44:27 <kNt> > a = (1:a)
16:44:28 <lambdabot>  Parse error
16:44:44 <kNt> (\a -> (1:a)) 2
16:44:49 <kNt> > (\a -> (1:a)) 2
16:44:50 <lambdabot>  add an instance declaration for (Num [a])
16:44:55 <kyevan> Og, you're right
16:45:23 <kyevan> Not that a list of 1s is that useful, but it is interesting.
16:45:27 <twanvl> > let a = 1:a in a
16:45:28 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
16:45:39 <kNt> lol
16:45:44 <kNt> > replicate 100 2
16:45:45 <lambdabot>  [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2...
16:45:55 <kNt> ;)
16:46:02 <kyevan> kNt: But, but, that ends!
16:46:05 <kyevan> FAIL!
16:46:07 <kyevan> :P
16:46:09 <twanvl> > repeat 3
16:46:09 <jcreigh> > repeat 2
16:46:10 <lambdabot>  [3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3...
16:46:11 <lambdabot>  [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2...
16:46:11 <kNt> > repeat
16:46:12 <lambdabot>  Add a type signature
16:46:13 <jcreigh> heh
16:46:17 <kNt> @type repeat
16:46:18 <lambdabot> forall a. a -> [a]
16:47:10 <jcreigh> > map ($1) (repeat repeat)
16:47:12 <lambdabot>  [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
16:47:54 <_matthew-> so how expensive is *lots* of readIORefs ?
16:48:20 <hyrax42> _matthew-: I think not more than *lots* of variable reads otherwise :?
16:48:31 <hyrax42> but I've never used IORefs
16:48:44 <hyrax42> was thinking I might try them today for somethign I'm doing
16:50:27 <_matthew-> right, about time I went to bed.
16:50:40 <_matthew-> sleep >>= matthew
16:51:00 <kyevan> Y
16:51:04 <kyevan> You're a function?
16:51:32 <Botje> @pl \x -> (x,x)
16:51:32 <lambdabot> join (,)
16:51:46 <nmessenger> :t join
16:51:48 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
16:51:57 <nmessenger> Ooh.
16:52:20 <kyevan> Hmm, so, how does do notation translate to >> and >>=?
16:52:22 <sorear> :t (join :: (a -> a -> b) -> (a -> b))
16:52:24 <lambdabot> forall a b. (a -> a -> b) -> a -> b
16:53:02 <nmessenger> kyevan: do x; y becomes x >> y and do a <- x; y a becomes x >>= \a -> y a
16:53:14 <lisppaste2> kNt annotated #32632 with "Doc datatype" at http://paste.lisp.org/display/32632#2
16:58:03 <dons> ?undo do x <- getChar ; putChar (toupper x)
16:58:04 <lambdabot> getChar >>= \ x -> putChar (toupper x)
16:58:13 <dons> ?redo getChar >>= \ x -> putChar (toupper x
16:58:13 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 2, srcColumn = 1}) "Parse error"
16:58:23 <dons> ?redo getChar >>= \ x -> putChar (toupper x)
16:58:24 <lambdabot> do { x <- getChar; putChar (toupper x)}
16:58:47 <dons> the wheel of life, so it goes.
16:59:31 <ray> dons: "programming haskell" was pretty fun
16:59:57 <dons> ray, cheers.
17:00:00 <dons> i'm just planning today's follow up
17:00:02 <dons> any suggestions?
17:00:03 <chessguy> dons, i like the IO article you and monochrom did
17:00:14 <dons> keep working through the camel book?
17:00:14 <sorear> dons: I've found a solution to the last major annoyance in vty; the lowlevel library should be available Real Soon Now
17:00:19 <dons> chessguy: oh, the ocaml tut?
17:00:23 <ray> yeah
17:00:23 <dons> sorear: cool!
17:00:35 <monochrom> chessguy is referring to A Brief Introduction to Haskell (the one modelled on the ocaml one)
17:00:55 <chessguy> yes
17:01:10 <chessguy> for those coming from an imperative background, if i remember right
17:01:52 <dons> yeah
17:04:29 <dons> 	
17:05:11 <nmessenger> That was some deep insight, dons.
17:05:19 <kNt> ?redo getChar >>= \ x -> putChar (toupper x)
17:05:19 <lambdabot> do { x <- getChar; putChar (toupper x)}
17:05:31 <kNt> ?redo getChar >>= \ x -> putChar (toupper x
17:05:32 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 2, srcColumn = 1}) "Parse error"
17:06:03 <kNt> @i HsDecl
17:06:04 <lambdabot> Maybe you meant: id index instances instances-importing . v
17:06:14 <kNt> @i Languange.Haskell.Syntax.HsDecl
17:06:15 <lambdabot> Maybe you meant: id index instances instances-importing . v
17:06:21 <kNt> @type Languange.Haskell.Syntax.HsDecl
17:06:22 <lambdabot> Couldn't find qualified module.
17:06:41 <allbery_b> "Language"
17:06:53 <kNt> @type Language.Haskell.Syntax.HsDecl
17:06:54 <lambdabot>   Not in scope: data constructor `Language.Haskell.Syntax.HsDecl'
17:07:12 <kNt> how do i do a :info with lambdabot?
17:07:39 <dons> kNt: if you're exploring , you might want to /msg the bot privately
17:07:48 <dons> lambdabot doesn't provide :info
17:07:49 <dons> since its a bit too noisy
17:08:11 <nmessenger> kNt: also try @list and @help <command>
17:08:12 <kNt> ok.dons.sry
17:08:29 <sjanssen> @pl ok.dons.sry
17:08:29 <lambdabot> ok . dons . sry
17:08:39 <nmessenger> lol
17:08:52 <nmessenger> :t dons
17:08:54 <lambdabot> Not in scope: `dons'
17:09:49 <greentea> Hi all.
17:10:01 <hyrax42> pattern matching on a data-defiend datatype is about as expensive as matching on a tuple right?
17:10:26 <hyrax42> greentea: hi
17:10:31 <nmessenger> hyrax42: considering a tuple is just a datatype, I'd say yes.
17:10:38 <hyrax42> nmessenger: thanks
17:10:49 <hyrax42> I really need to stop using tuples when a datatype is called for
17:11:04 <hyrax42> I have to go through and change a lot of code now for that reason
17:11:06 <hyrax42> *sigh*
17:11:52 <sjanssen> there are even cases where using a data type can make your program faster
17:11:53 <dons> hyrax42: exactly. pattern matching is actually just inspecting byte tags at runtime
17:12:01 <dons> so a switch statement, in the C backend
17:12:43 <hyrax42> I figured
17:12:46 <hyrax42> that will teach me
17:12:47 <jcreigh> kNt: also, remember that ghci rocks. It has tab-completion, and supports using do-notation interactively. But you probably knew those already; I mention them only because it took me a long to find out. :)
17:12:48 <sjanssen> when using a data type, you can add strictness annotations and UNPACK pragmas, which can be a very big win
17:13:03 <hyrax42> pretty much every important function in this needs to be changed now
17:13:08 <hyrax42> as the tuple is no good
17:13:14 <nmessenger> Windows == no tab-completion :(
17:13:56 <jcreigh> Well, using Windows is like walking around with a big sign that says "kick me". :)
17:14:24 * nmessenger hangs head low and fades into the background.
17:14:26 <kfish> dons: i merged a patch for remote control into ogg123 this morning, if you wanna test it with hmp3 ...
17:14:40 <kfish> dons: http://svn.xiph.org/trunk/vorbis-tools
17:14:42 <lambdabot> Title: Revision 12218: /trunk/vorbis-tools
17:15:02 <psi> yay
17:15:27 <nmessenger> hyrax42: I wouldn't call them no good exactly, that'd hurt their feelings.
17:15:40 <nmessenger> Tuples Are People Too
17:15:52 <jcreigh> nmessenger: but really no tab-completion on Windows? That kind of sucks. Maybe with cygwin...?
17:15:55 <hyrax42> nmessenger: implied "in this case"
17:16:18 <hyrax42> and going to a 3-tuple instead of a pair, I might as well just switch everythign to record syntax
17:16:21 <nmessenger> hyrax42: righty-oh
17:16:25 <hyrax42> and save myself the hassle of changing it later
17:17:05 <dons> kfish: oh super nice!
17:17:38 <dons> kfish++
17:18:11 <nmessenger> dons: what's the deal with incrementing people in this channel?
17:18:25 <hyrax42> they become a random other person
17:18:38 <hyrax42> depending on layout of nicks in IRC
17:18:42 <hyrax42> possibly junk
17:18:55 <nmessenger> Random?!  So incrementation is non-deterministic?!
17:18:56 <sorear> ?karma hyrax42
17:18:57 <lambdabot> hyrax42 has a karma of 4
17:19:03 <sorear> hyrax42++
17:19:03 <sorear> ?karma hyrax42
17:19:04 <lambdabot> hyrax42 has a karma of 5
17:19:07 <sorear> hyrax42--
17:19:07 <sorear> ?karma hyrax42
17:19:08 <lambdabot> hyrax42 has a karma of 4
17:19:11 <nmessenger> I see
17:19:12 <kfish> dons: heh, i just got kudos on #haskell for writing C code ;-)
17:19:16 <hyrax42> lol
17:19:41 <hyrax42> nmessenger: incrementing a nickname has possibly non-deterministic effect
17:20:14 <nmessenger> hyrax42: but I thought this channel was a strictly effects-free zone.
17:20:38 <nmessenger> or should that be a *lazily* effects-free zone?
17:20:45 <reppie> kfish there's nothing wrong with wrting c code
17:20:47 <ray> nah, it returns a new person whose karma is greater by one
17:20:56 <hyrax42> well incrementing makes sense only with side-effects, and this is IRC, so I think that's no good as an assumption
17:21:26 <hyrax42> *the C-style incrementation operator
17:21:46 <hyrax42> dons: does hmp3 make use of record syntax?
17:22:16 <dons> nmessenger: this channel runs in the Karma monad, a StateT (Map String Int) monad transformer
17:22:20 <hyrax42> ?where hmp3
17:22:21 <lambdabot> http://www.cse.unsw.edu.au/~dons/hmp3.html
17:22:29 <dons> hyrax42: it does use some records, yeah
17:22:38 <nmessenger> *rolls eyes*
17:22:46 <dons> actually, the source is pretty clean, if you want to look into writing curses tools in haskell, with concurrency
17:22:47 <hyrax42> dons: ok, just want to see some "accepted use" names for the record fields
17:23:08 <sorear> don't forget that just 'kfish' has the side effect of sending 01101011 01100110 01101001 01110011 01101000 to all parties
17:23:23 <dons> kfish: i'll hvae a look at ogg123 later today
17:23:34 <hyrax42> what exactly does --partial do
17:23:44 <dons> pull the darcs patches since the last tag
17:23:45 <ray> doesn't fetch 32952398562398 patches
17:23:58 <sjanssen> hyrax42: only grabs the patches up to the most recent tag
17:23:59 <sorear> s/tag/checkpoint/
17:24:07 <dons> rather than all the patches
17:24:12 <sorear> darcs help optimize checkpoint
17:24:14 <sjanssen> so you save space and bandwidth
17:24:19 <sorear> and time
17:24:20 <kfish> dons, cheers
17:24:26 <sorear> ?karma kfish
17:24:27 <lambdabot> kfish has a karma of 4
17:25:04 <kfish> yay!
17:25:25 <hyrax42> sjanssen: hmm ok
17:25:34 <hyrax42> but the hisotry is missing
17:25:52 <sjanssen> right, --partial is a trade off
17:29:05 <hyrax42> ?index MVar
17:29:06 <lambdabot> GHC.Conc, Control.Concurrent.MVar, Control.Concurrent
17:29:45 <dibblego> dons, where are your benchmarks for doing parallel stuff?
17:29:54 <dons> once we all have a terabytenet pipes, we can ditch --partial :) i rarely use it anyway
17:32:22 <dons> dibblego: we have some matrix and tree algorithms we use. dot products, barnes-hut
17:32:36 <dibblego> dons, that'd be handy
17:33:13 <dons> they're in the ndp darcs branch
17:33:18 <dons> check the dph page for details
17:33:21 <dibblego> ok cheers
17:33:23 <dons> ?where dph
17:33:23 <lambdabot> http://haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
17:34:10 <kNt> jcreigh : i knew that it auto-completed but i didn't knew that do-notation was possible
17:34:38 * sorear is discovering race-free concurrent programming isn't as easy as it sounds.
17:34:47 <newsham> cale's not been around today?
17:36:01 <int-e> @seen cale
17:36:02 <lambdabot> cale is in #oasis, #ghc and #haskell. I last heard cale speak 16h 42m 30s ago.
17:37:47 <kNt> someone can give me here a help.. i'll try to explain what i want to do cos the code isn't in this pc. i want to make something like this.. i do a sequence of things applyed with my monad state & i print it on the screen.. but anytime i want to printit i want to print also the function i used in.. is that possible?
17:39:52 <kNt> but anytime i want to printit i want to print also the function i used in.. is that possible? --> each time i print the result i want to print the name of the function i used
17:40:36 <allbery_b> take a look at Control.Monad.Writer
17:44:20 <kNt> wtf is a monoid?
17:44:23 <kNt> lol :P
17:44:30 <chessguy> kNt, i don't understand. can't you just do putStrLn "this is function foobar and my result is " ++ result
17:44:54 <dmead> chessguy: yes
17:45:16 <dibblego> how does clean have side-effects if not with monads?
17:45:19 <kNt> chessguy no cos i don't know what function i use
17:45:33 <kNt> i use several
17:45:39 <sorear> ?hoogle block
17:45:40 <lambdabot> Control.Exception.block :: IO a -> IO a
17:45:40 <lambdabot> Text.Html.blockquote :: Html -> Html
17:45:40 <lambdabot> Text.Html.BlockTable :: module
17:45:41 <chessguy> kNt, so put that line in each function
17:45:44 <kNt> ?paste
17:45:44 <lambdabot> http://paste.lisp.org/new/haskell
17:46:10 <dmead> kNt: i don't think you can just spit out the name of a function like in java's .getClass()
17:46:52 <chessguy> yeah i haven't seen anything in haskell with that degree of reflection
17:46:52 <dmead> i guess if you use classes you could have a print member?
17:46:59 <dmead> word
17:47:03 <chessguy> (though it would be cool)
17:47:04 <dmead> you'd have to build it into a class
17:47:05 <kNt> yes.. dmead
17:47:06 <dmead> aye
17:47:25 <nmessenger> dibblego: My vague understanding is that Clean has something called "uniqueness types", that can only be used once, so RealWorld's can be passed around explicitly
17:47:34 <kNt> i'll post the code
17:47:35 <kNt> a sec
17:48:29 <nmessenger> dibblego: Or something like that.  I've not actually used Clean at all.
17:48:35 <dibblego> nmessenger, thanks
17:48:55 <lisppaste2> knt pasted "pwpf" at http://paste.lisp.org/display/32636
17:48:55 <kNt> look
17:49:23 <kNt> where i write "LAW" is the name of the law i'm applying
17:49:40 <kNt> but if i could make a function that writes me the name of it
17:49:48 <kNt> i had one.. but it doesn't work
17:51:20 <kNt> if i had a class signature like "class Law x ..." how could i instance a show declaration to this class to perform the result as i expect it?
17:52:04 <kNt> i don't know if i'm being understandable
17:56:34 <glguy> kNt: your "aux" function is just mapM_
17:59:25 <dmead> kNt: maybe if you made a law class instead?
18:00:31 <dmead> oh
18:00:32 <dmead> umm
18:00:37 <dmead> kNt
18:00:40 <dmead> if you had a law class
18:00:57 <kNt> i tryed to do it.. but i wasn't able to do it
18:00:57 <dmead> you could then wrap that to a data = a law | b law
18:01:02 <dmead> then
18:01:05 <lisppaste2> glguy annotated #32636 with "example of clearer code" at http://paste.lisp.org/display/32636#1
18:01:13 <dmead> overrite the show statement for the data
18:01:14 <dmead> er
18:01:19 <dmead> you could then wrap that to a data lawtype = a law | b law
18:01:25 <dmead> overwrite show
18:01:31 <dmead> so it calls the correct member
18:01:41 <dmead> i'm just guessing though :)
18:01:57 <dmead> err
18:02:20 <dmead> you could then wrap that to a data lawtype = a law1 | b law2
18:02:22 <dmead> *typo
18:02:39 <kNt> i don't get it..
18:02:55 <dmead> law1 and law2 would be classes
18:03:26 <lisppaste2> glguy annotated #32636 with "one further revision for kNt" at http://paste.lisp.org/display/32636#2
18:04:39 <syntaxfree> this is an interesting, if odd, blog post.
18:04:41 <syntaxfree> http://www.defmacro.org/ramblings/haskell-productivity.html
18:04:44 <lambdabot> Title: defmacro - On Haskell, Intuition And Expressive Power
18:05:09 <lisppaste2> dmead annotated #32636 with "like this maybe?" at http://paste.lisp.org/display/32636#3
18:05:29 <newsham> i've been asked to guest-blog something about software security.  i'm gonna try to do something on haskell.
18:05:32 <glguy> if that post, I wondered why he wrote:   | "Widget" `isSuffixOf` a = True
18:05:38 <glguy> seemed redundant
18:05:44 <syntaxfree> I need to get back to blogging.
18:05:52 <dmead> i'm saying to achieve the reflective stuff your talking about you could do it the C++ way
18:05:53 <syntaxfree> Getting dumped by the girlfriend really killed all my creative juices.
18:05:58 <syntaxfree> But, feh, I need to wake up.
18:05:59 <dons> ?docs System.IO
18:06:00 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html
18:06:02 <dmead> ploymorphism + classes
18:06:16 <newsham> syntaxfree: i thought blogs were exactly for people who want to mope about their ex-gf
18:06:42 <syntaxfree> I have two blogs. One is my econopundit pulpit. The other one is about Haskell.
18:07:08 <kNt> dmead : yeah. that's the best option i(we) have. we were trying to implement something like that..
18:07:13 <kNt> but it crashed
18:07:20 <dmead> really?
18:07:24 <newsham> you an economist?  i'm studying economics as a hobby.
18:07:25 <dmead> hmm
18:07:25 <glguy> syntaxfree: where you discuss things like "does minimum wage affect unemployment?"
18:07:27 <kNt> yup
18:07:38 <syntaxfree> newsham: I'm a grad student.
18:07:53 <syntaxfree> glguy: my econopundit blog is in portuguese, and is mostly about brazilian affairs.
18:08:00 <newsham> grad student in economics?  comp sci?
18:08:02 <dmead> kNt: i'd post on the mailing list then
18:08:05 <syntaxfree> economics.
18:08:11 <newsham> cool.
18:08:16 <syntaxfree> I've been writing a lot of deep theoretical stuff, actually.
18:08:17 <kNt> i don't have mailing list -_-
18:08:31 <syntaxfree> A lot about the relationship between high theory and policy-making.
18:08:35 <glguy> syntaxfree: e.g.?
18:08:51 <sorear> "Now, is my program lagging because of some insideous concurrency bug, or because I'm compiling GHC?"
18:08:57 <newsham> glguy: of course a wage minimum is going to affect employment.  however, the effect of current and previous min wages have been negligible
18:08:59 <dmead> kNt: http://haskell.org/haskellwiki/Mailing_lists
18:09:01 <lambdabot> Title: Mailing lists - HaskellWiki
18:09:08 <syntaxfree> not deep-theoretical as in journal-publishable, but reflecting on the status of theory and how it informs policy-making.
18:09:30 <dmead> kNt: ask on there
18:09:32 <newsham> a friend showed me a cool graph of US unemployment rates vs time with tics for eahc min-wage hike.
18:09:34 <dmead> kNt: someone will know
18:09:41 <newsham> there was no noticeable affect on the graph.
18:09:57 <newsham> if min wage was $50, there would definitely be an effect.
18:10:00 <kNt> dmead how do i add myself to it
18:10:07 <syntaxfree> newsham: you need more econometric analysis than simple staring at graphs to make even preliminary statistical inferences.
18:10:09 <dmead> sign up!
18:10:23 <glguy> I'd be interested to see inflation graphed with minimum wage
18:10:36 <dmead> kNt: http://haskell.org/mailman/listinfo/haskell-cafe
18:10:37 <newsham> syntax: sure, but its a good start (and econometrics is quesitonable science anyway)
18:10:38 <lambdabot> Title: Haskell-Cafe Info Page
18:10:42 <syntaxfree> even the standard apparatus of econometrics (linear regression + classical inference) is quite inadequate for solving out those kinds of puzzles.
18:10:42 <dmead> the signup is on there
18:11:15 <syntaxfree> Econometrics is hard science. It's just that reality rarely conforms the hypothesis behind econometric inference.
18:11:25 <hyrax42> if there is a CAF, is it evaluated at compile-time?
18:11:31 <dmead> brb
18:11:45 <newsham> not to mention interpretations of the parameters that "fit" the model.
18:11:46 <syntaxfree> s/conforms the/conforms to the
18:11:52 <newsham> causality and all that
18:12:06 <glguy> hyrax42: I would guess that it is evaluted at run time, but only evaluated once
18:12:07 <syntaxfree> that can actually be sorted out quite well in dynamic, multi-equation models.
18:12:23 <glguy> hyrax42: evaluation at compile time assumes that the computation would end
18:12:28 <syntaxfree> (As long as the multi-equation models can be "identified", i.e., you can reconstruct the multiple equation system from the estimated equation)
18:12:31 <kNt> dmead tnks
18:12:35 <hyrax42> glguy: good point
18:12:53 <hyrax42> maybe I'll evaluate it, and print it and paste it into code (it's an array)
18:13:07 <kyevan> Hmm... how much of the average program in Haskell can be optimised away by the compiler?
18:13:15 <newsham> post hoc ergo propter hoc
18:13:29 <syntaxfree> ever heard of the Fritsch-Waugh-Lovell theorem?
18:13:39 <newsham> nope, i'm not that deep.
18:13:57 <syntaxfree> Basically, in properly-specified multiple regression models, parameters have a "ceteris paribus" interpretation.
18:14:06 <araujo> haha
18:14:13 <araujo> he is even proposing a challenge
18:14:16 <syntaxfree> Each parameter is the effect given all the other variables constant.
18:14:34 <kyevan> araujo: Who is?
18:14:40 <syntaxfree> (You can look up the actual theorem on the web. It's a long story about projection matrices)
18:14:52 <araujo> kyevan, http://www.defmacro.org/ramblings/haskell-productivity.html
18:14:53 <lambdabot> Title: defmacro - On Haskell, Intuition And Expressive Power
18:14:55 <hyrax42> ?docs Data.Array.IArray
18:14:56 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array-IArray.html
18:15:21 <syntaxfree> anyway, that basically means that if a model is correctly specified, you can control for the effect of a specific variable changing.
18:15:22 <newsham> syntax: *nod* thanks.  I dont think i'm quite ready for that though.
18:15:43 <syntaxfree> (As long as parameters are constant, and all. A lot of what goes wrong with macroeconometrics is that behavioural parameters change in response to events)
18:15:54 <glguy> araujo: that challenge seems silly, since he is using other functions
18:15:56 <newsham> sounds like you're measuring and interpretting your model.
18:16:00 <newsham> not necessarily reality
18:16:12 <syntaxfree> hence, "correctly specified".
18:16:16 <newsham> *nod*
18:16:28 <newsham> hence questionable science :)
18:16:35 <newsham> i dont doubt the power of the analysis techniques.
18:16:42 <syntaxfree> well, all statistical inference is questionable in that sense.
18:16:48 <newsham> *nod*
18:17:00 <araujo> glguy, i think he is asking for a java method/class with the same algorithmic idea of that function.
18:17:06 <newsham> and questionable science can be very useful
18:17:26 <syntaxfree> It's both a science and an art. Years of experience staring at econometric models help you develop a sense for statistical blunders and theoretical mistakes.
18:17:32 <syntaxfree> (theoretical as in econometric theory)
18:18:17 <syntaxfree> I have a half-written post with a tutorial on how to read regression results. But that'll be in portuguese, anyway, so.
18:18:42 <newsham> heh, i can barely grok simple spanish and french, let alone technical portuguese
18:19:03 <syntaxfree> I know people who can grok mathematics in russian, but nothing else.
18:19:19 <syntaxfree> they basically read a book that taught most of the common "passage" expressions.
18:19:25 <syntaxfree> "From here it follow trivially that", etc. etc.
18:19:30 <syntaxfree> s/follow/follows.
18:19:43 <SamB_XP> heh
18:19:54 <syntaxfree> "Now, what in the name of all holy is nub? Here's where Haskell shines - not only does it teach you functional programming, but also some vocabulary! Dictionary.com defines nub as "the point, gist"."
18:19:58 <syntaxfree> !
18:20:22 <newsham> i speak english and I dont know what "nub" is supposed to mean
18:20:32 <mr_tenor> it's like n00b, innit?
18:20:34 <mr_tenor> ;)
18:20:40 <syntaxfree> "The function returns the gist of the list, which amounts to the list with duplicates removed so every item appears on the list only once."
18:20:44 <newsham> > nub [3,1,4,1,5,9,2,7]
18:20:46 <lambdabot>  [3,1,4,5,9,2,7]
18:20:51 * SamB_XP has thought about creating a programming language such that the algorithms Knuth gives in TAOCP would be programs that would implement, well, themselves ;-)
18:21:18 <syntaxfree> SamB_XP: you'd thought of making TAOCP-pseudocode into an actual language?
18:21:27 <newsham> > nub "removes all the duplicates, which can make reading hard"
18:21:29 <lambdabot>  "removs althdupic,wnkg"
18:21:30 <SamB_XP> syntaxfree: yes!
18:21:48 <syntaxfree> SamB_XP: http://syntaxfree.wordpress.com/2006/12/13/reddit-discussion-considered-productive/
18:21:51 <lambdabot> Title: Reddit discussion considered productive « Data.Syntaxfree, http://tinyurl.com/yxd7sj
18:22:01 <SamB_XP> it would take some declarations of data formats
18:23:54 <sorear> GHC-head compilation succeeded : real    81m36.231s / user    58m31.547s / sys     19m40.074s
18:24:10 <sorear> now to play with the debugger!
18:24:16 <dmead> hmm
18:24:22 <dmead> i read an article on the gentoo wiki
18:24:29 <dmead> about how to use ramdisks to emerge stuff
18:24:38 <dmead> i wonder how fast you could do ghc with a ramdisk
18:24:43 <dmead> xorg takes about 10 minutes
18:25:04 <sorear> wouldn't tmpfs be faster still ?
18:25:31 <sjanssen> you can pick up a lot of time by tweaking the build settings for GHC
18:25:32 <dmead> thats what it is
18:25:33 <dmead> tmpfs
18:25:35 <allbery_b> I was under the impression ghc could better use memory as memory, not as fast disk
18:25:38 <sjanssen> turning off optimization and such
18:25:46 * notsmack seems to have just lost a backlight bulb on his 30" dell monitor
18:26:05 <dmead> useing tmpfs as the disk during a compilation makes it extremly fast
18:26:06 <syntaxfree> backlight bulb?
18:26:09 <syntaxfree> 30" MONITOR!
18:26:22 * syntaxfree has a measly 17".
18:26:27 <sorear> I don't need no steenking backlight!  I have a SELF-ILLUMINATING cathode ray tube!
18:26:29 <notsmack> a chunk of the screen went darker
18:26:40 * allbery_b has a 20", if we're comparing geek schlongs
18:26:42 <syntaxfree> I wonder if my monitor has backlights.
18:27:40 <dmead> http://gentoo-wiki.com/TIP_Speeding_up_portage_with_tmpfs
18:27:43 <lambdabot> Title: TIP Speeding up portage with tmpfs - Gentoo Linux Wiki
18:28:16 <sorear> My *other* monitor is forty-something inches.  Granted, it only scans at 480 lines, but...
18:29:00 <dmead> thats ginourmous
18:29:02 <syntaxfree> 640 x 480?
18:29:22 <dons> ?docs Data.List
18:29:23 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
18:29:38 <mr_tenor> sorear: where'd you get that from?
18:30:13 <notsmack> sounds like a tv?
18:30:18 <mr_tenor> heh
18:30:19 <sorear> Hint: it was sold as a "television"
18:31:06 <syntaxfree> I know it's a TV.
18:31:15 <syntaxfree> I'm questioning the horizontal resolution of tvs.
18:31:38 <ray> i have a cathode sorear tube
18:31:55 <allbery_b> tvs are pretty close to 640x480 IIRC
18:32:50 <ray> i've got 2x17" that *should* both be running at 1280x1024, but the x server totally sucks
18:33:31 <syntaxfree> Haskellers using a Mac? Show of hands!
18:33:45 <audreyt> me.
18:33:46 * allbery_b raises hand
18:33:57 <ray> i own a mac
18:34:00 * syntaxfree raises hand.
18:34:10 <syntaxfree> Oh, cool. audreyt = autrijus/audrey tang from Pugs?
18:34:11 * ray raises three fingers
18:34:22 <audreyt> audrey tang. yes.
18:34:36 <sorear> I've used a mac with a 9" monitor
18:34:54 <syntaxfree> autrijus was a nickname, I presume. Anyway, Pugs is really cool.
18:35:05 <syntaxfree> Congratulations for your work!
18:35:13 <audreyt> I still wonder why my macbook doesn't support 1680x1050 resolution for my new screen :/
18:35:31 <dmead> =<
18:35:44 * allbery_b has his G4 mini doing that res
18:35:46 <audreyt> syntaxfree: thank-you. what's your email address? may I send you a commit bit so you can hack pugs?
18:36:10 <Haskell_Clippy> dmead: I think you're trying to write a bind-notation monadic function. Do you mean "=<<" ?
18:36:18 <audreyt> lol
18:36:31 <syntaxfree> audreyt: I don't have the skills yet, I'm afraid.
18:36:40 <dmead> lol
18:36:50 <dmead> emoticon?
18:36:51 <dmead> o0
18:36:52 <dmead> =<
18:36:55 <dmead> <
18:36:57 <dmead> :<
18:36:59 <audreyt> not possible. I see you speak English; we have lots of docs and READMEs and READTHEMs and READTOOs that could use English hackers
18:37:09 <chessguy> @unpl (=<)
18:37:10 <lambdabot> (=<)
18:37:11 <audreyt> (those are real files in the repo.)
18:37:12 <syntaxfree> Bizarrely enough, "Haskell_Clippy" is a registered nickname.
18:37:15 <sorear> audreyt : SamB wanted to complain about the Data instance for Data.ByteString
18:37:17 <chessguy> boo
18:37:30 <audreyt> sorear: SamB is correct. I just want there to be _a_ instance
18:37:30 <syntaxfree> oh no it isn't.
18:37:32 <syntaxfree> forget about it.
18:37:41 <audreyt> I don't much care about how.
18:37:44 <dmead> theres a sorority here called beta iota iota beta zeta
18:37:47 <dmead> or boobz
18:38:04 <syntaxfree> audreyt: english is not my first language either. though I'm managing to scrape by enough to write a blog. Or something.
18:38:05 <glguy> chessguy: (=<<) is \a b -> do { x <- b; a x }
18:38:11 <audreyt> syntaxfree: url?
18:38:17 <chessguy> glguy, tell lb that :)
18:38:18 <syntaxfree> (=<<) is flip (>>=)
18:38:24 <syntaxfree> audreyt: http://syntaxfree.wordpress.com
18:38:26 <lambdabot> Title: Data.Syntaxfree
18:38:35 <syntaxfree> audreyt: that should give you an idea of my Haskell experience, as well.
18:38:40 <syntaxfree> (the "about" page and all)
18:38:48 * audreyt goes reading about syntax-free context
18:39:09 <chessguy> as opposed to context-free syntax?
18:39:49 <audreyt> you got it :)
18:40:29 <chessguy> s
18:41:09 <kyevan> Heheh.
18:41:12 * syntaxfree 's nickname comes from a Sonic Youth song.
18:41:22 <kyevan> So, what if something is both syntax-free AND context-free
18:41:24 <monochrom> the best syntax is free
18:41:25 <syntaxfree> "You can't catch me / I'm syntax free / I'm preconceived / preternaturally"
18:41:35 <audreyt> syntaxfree: ah, you're also @ .br?
18:41:45 <monochrom> random number sequences are free
18:41:48 <syntaxfree> yup.
18:42:02 <syntaxfree> someone wrote a monocycle book about Haskell here one of these days.
18:42:13 <audreyt> .br, .il and .tw hackers dominates Pugs population these days
18:42:17 <monochrom> @remember syntaxfree "You can't catch me / I'm syntax free / I'm preconceived / preternaturally"
18:42:17 <syntaxfree> I had never even heard of the guy. Or no one else involved with Haskell in Brazil.
18:42:35 <audreyt> syntaxfree: cmarcelo is also from .br, I believe
18:42:35 <syntaxfree> I do know a lot of ML hackers, though.
18:42:52 <audreyt> my minion^Wstudent in the Haskell summer of code program
18:42:53 <syntaxfree> there's a bit of ML research being done at the place where I got my undergrad degree.
18:43:08 <syntaxfree> (That's also from where Lua came from)
18:43:44 <sorear> what proportion of Portugese speakers are NOT from br?
18:44:03 <glguy> isn't Portugese supposed to be the most common language on the planet?
18:44:09 <glguy> I was told that recently
18:44:12 <syntaxfree> there's Portugal, Moçambique, Angola and some other assorted small places.
18:44:14 <glguy> wasn't sure whether to believe it or not
18:44:17 <syntaxfree> glguy: portuguese must be fifth or sixth.
18:44:21 <glguy> ah
18:44:44 <kyevan> All I know is that it's below English and above Esperanto.
18:44:46 <glguy> #5
18:44:47 <syntaxfree> english and chinese must be close up in first, spanish a close third.
18:44:47 <glguy> http://geography.about.com/od/culturalgeography/a/10languages.htm
18:44:50 <lambdabot> Title: Most Popular Languages
18:44:58 <glguy> 1. Mandarin Chinese - 882,475,389
18:44:58 <glguy> 2. Spanish - 325,529,636
18:44:58 <glguy> 3. English - 311,992,760
18:44:58 <glguy> 4. Hindi - 181,780,905
18:45:00 <glguy> 5. Portuguese - 178,557,840
18:45:18 <araujo> yup, spanish goes above english by a slight difference
18:45:19 <syntaxfree> Brazil's population is 160,000,000
18:45:37 <syntaxfree> so, um, yes, Goa and Angola don't account for much ;)
18:46:01 <araujo> i think nobody will be able to reach the chinese :-P
18:46:04 <kyevan> syntaxfree: Well, there will be a few people who can't, for whatever reason, speak the language.
18:46:08 <kyevan> so...
18:46:35 <syntaxfree> I think that english figure is only **native** speakers.
18:46:46 <syntaxfree> The US population alone is, what, 200 million?
18:46:51 <sorear> 300m
18:46:51 <glguy> 300
18:47:02 <syntaxfree> Hundreds of millions worldwide speak english as a second language.
18:47:23 <kyevan> syntaxfree: And hundreds of millions speak Spanish as a second.
18:47:38 <emu> i'm surprised at hindi
18:47:41 <monochrom> You can't beat the mother tongue of a country that is responsible for 1/4 of world population :)
18:47:47 <syntaxfree> more people speak english as a second language than spanish.
18:47:48 <sorear> OTOH, millions here (US) speak English second
18:47:51 <kyevan> monochrom: Sure you can.
18:47:52 <emu> i realize india has zillions of languages, but surely the gov't has a common one
18:48:00 <syntaxfree> emu: India's population is close to China's.
18:48:05 <emu> exactly
18:48:08 <emu> why isn't hindi further up?
18:48:12 <kyevan> Just, get the other 3/4 speaking one language :P
18:48:18 <kyevan> emu: Zillions of languages.
18:48:18 <syntaxfree> Because the common language in India is english.
18:48:25 <monochrom> Darn
18:48:49 <glguy> india has like 14 different languages
18:48:51 <kynes> idea : eventually a language that's more regular than alternatives will survive best
18:49:01 <emu> what do they speak in parliament?
18:49:22 <syntaxfree> idea: british, and then american, economic supremacy have done more to push english as an international language than its regularity.
18:49:23 <yip> are there any HAppS people here?
18:49:24 <sorear> Sorry.  See English
18:49:45 <glguy> Languages:
18:49:45 <glguy>  English enjoys associate status but is the most important language for national, political, and cmmercial communication; Hindi is the national language and primary tongue of 30% of the people; there are 14 other official languages: Bengali, Telugu, Marathi, Tamil, Urdu, Gujarati, Malayalam, Kannada, Oriya, Punjabi, Assamese, Kashmiri, Sindhi, and Sanskrit; Hindustani is a popular variaant of Hindi/Urdu spoken widely throughout northern India but is not a
18:49:47 <syntaxfree> I ain't happy. I used to be happy.
18:49:53 <sorear> (I'm told it is extremely irregular and hard to learn as a second lang)
18:50:04 <syntaxfree> glguy: what site is that?
18:50:16 <syntaxfree> I once saw a site that mentioned german as a language spoken in Bolivia.
18:50:18 <glguy> CIA Fact book : http://geography.about.com/library/cia/blcindia.htm
18:50:20 <lambdabot> Title: Geography and Map of India
18:50:25 <syntaxfree> German must be spoken by about 17 mennonites.
18:50:30 <syntaxfree> Mennonites being this amish-like community.
18:50:36 <audreyt> syntaxfree: a commit bit is on its way to you anyway :)
18:50:47 <syntaxfree> audreyt: okie. Thanks :)
18:50:51 <dibblego> @quote dibblego
18:50:52 <lambdabot>  [in ##c] <dibblego> ?type map <SamB> no lambdabot in ##c, silly! <dibblego> I'm so used to lambdabot following me around
18:51:17 <audreyt> syntaxfree: see http://search.cpan.org/dist/Perl6-Pugs/docs/Pugs/Doc/Hack.pod for hacking quickstart
18:51:19 <lambdabot> Title: Pugs::Doc::Hack - How to hack on Pugs - search.cpan.org
18:51:19 <kynes> idea : a language looks neat if it does not have "masculine/feminine" distinction for every word.. just "it" suffices in most cases
18:51:32 <audreyt> also our Haskell identifier naming style is http://search.cpan.org/dist/Perl6-Pugs/docs/Pugs/Doc/Hack/Style.pod which may be of some interest
18:51:35 <lambdabot> Title: Pugs::Doc::Hack::Style - Style guidelines for Pugs code - search.cpan.org, http://tinyurl.com/y42s3u
18:52:23 <glguy> Haskell needs masculine and feminine variables
18:52:43 <yip> what do you guys think the weakest part of haskell is?
18:52:55 <audreyt> the "ll"
18:53:08 <audreyt> especially the last "l"; you don't pronounce it at all
18:53:10 <allbery_b> existing libraries
18:53:13 <yip> i'm gonna have to say the module system :/
18:53:20 <kynes> uh, that's hard to say... it's pretty elegant as a language itself
18:53:39 <dibblego> the module system is brilliant
18:53:39 <audreyt> yip: but seriously, library discovery and management system is really week.
18:53:42 <audreyt> *weak
18:53:43 <sorear> the advocates
18:53:48 <yip> modules are not first class :/
18:53:57 <audreyt> haskell has advocates?
18:54:44 <kynes> *irritating = learning curve of monads
18:54:50 <shapr> SHAZAM!
18:55:05 <kynes> just at first
18:55:06 <sorear> The time library is probably the weekest part of haskell.
18:55:12 <shapr> weak*
18:55:30 <yip> well, monads are monads, nothing you can do really to change that i suppose. just write more/better documentation
18:55:32 * audreyt ponders what's monthest and yearst for haskell
18:55:43 <emu> i haven't been around pre-cabal, so, i haven't had any problems installing libraries and using them
18:55:53 <audreyt> emu: discovery.
18:55:55 <shapr> kynes: I prefer languages with item gender. Finnish doesn't have item gender and it feels weird.
18:56:00 <audreyt> also, maintaining multiple versions of the same library
18:56:06 <sorear> I hate plural.
18:56:14 <emu> discovery?
18:56:24 <glguy> Japanese doesn't have plural, does it?
18:56:29 <emu> not in the same way
18:56:33 <emu> it has "counting" words
18:56:35 <glguy> but it does have different counting systems
18:56:36 <monochrom> I think the steep learning curve of monads is due to overblowing its significance.
18:56:43 <shapr> yip: I know something about HAppS, what's your question?
18:56:43 <audreyt> emu: when you have a need for such-and-such library, currently the most effective way to discover it is through #haskell or google
18:56:47 <mr_tenor> I hate having to parenthesise data types so much to hint to the parser which tokens belong to which data object
18:56:51 <allbery_b> don't learn Hebrew or Arabic, then:  you have two different kinds of plural :)
18:56:54 <emu> audreyt: um, haskell.org
18:56:55 <syntaxfree> kynes: monads are not that hard, once you resolve to face them.
18:57:16 <audreyt> emu: sure. but there is no programmatically convenient way to do that
18:57:18 <shapr> allbery_b: There's a flavor in india that has tenses for one, two, three, many.
18:57:26 <audreyt> so you have to spend human-time, which is difficult
18:57:29 <allbery_b> ah, so one up on the Semites :)
18:57:31 <sorear> monads are not hard, once you resolve to only expose haskell to geniuses.
18:57:35 * emu programs his mouse to scroll to Applications and Libraries and click ;)
18:57:39 <allbery_b> (single, dual, plural)
18:57:45 <syntaxfree> monads are made confusing by do notation.
18:57:48 <kynes> shapr : all implementations are may not be good, but I really don't want to remember (know) if a "ball" / "pen"/ "circle" is m or f :)
18:57:50 <shapr> audreyt: cabal-get should do that...
18:57:52 <monochrom> Already in C++ one can overload the "+" operators for things that look like addable.  Monads are just overloading >>=
18:58:00 <syntaxfree> do notation is useful for experienced programmings, but a brainf*ck for beginners.
18:58:01 <audreyt> shapr: it should :) I'm just describing status quo
18:58:05 <shapr> yeah, true.
18:58:25 <emu> monochrom: they're supposed to obey certain laws regarding the semantics of the operator
18:58:26 <kynes> shapr : any language that has too many exceptions makes me feel strange..
18:58:29 <sorear> aptitude ^J l~Glanguage::haskell~Gfooing ^J +gg
18:58:37 <emu> which is more than .. uh .. the way operator overloading is used in C++
18:58:37 <audreyt> for there can be meaningful web services (lower cased "ws") only when the base metadata is in place for libraries
18:58:45 <monochrom> Yes, just like + also comes with certain expectations.
18:58:50 <emu> matrix multiplication comes to mind
18:59:06 <yip> shapr: is it possible to disable ACID if it's not needed?
18:59:30 <sorear> Matrices form a ring - what's so bad about overloading (*)?
18:59:44 <sorear> s/^M/Square m/
18:59:53 <syntaxfree> overloading should follow clear rules. hence type classes.
19:00:44 <emu> it's not commutative
19:00:55 <sorear> Actually, in haskell you could declare Num (Matrix), except for signum, abs - (*), (+), follow all laws
19:01:06 <sorear> so?  neither are quaternions
19:01:14 <syntaxfree> Num is such a big, fat, greedy class.
19:01:32 <shapr> yip: I don't know that.
19:01:46 <emu> you know where haskell is weak ... every time i have to insert "fromIntegral" or similar in my code, i cringe
19:01:58 <yip> shapr: have there been any big changes in happs in the last 2 months?
19:02:00 <audreyt> fi = fromIntegral
19:02:04 <audreyt> there you go :)
19:02:07 <monochrom> That is weak and strong.
19:02:14 <emu> but .. it's not doing .. anything
19:02:15 <glguy> emu: you'd rather Haskell just have weak typing?
19:02:22 <emu> except frobbing the type system
19:02:22 <allbery_b> so?  figuring out what typeclasses I wanted for various kinds of floating point ops was fun enough as is without having to do even more of it
19:02:43 <emu> is it impossible to construct a type system for a "natural" expression of arithmetic
19:02:47 <sorear> I'd rather have programmable infix operators and an APL keybord.  Numeric-case yay!
19:02:53 <sorear> s/case/cast/
19:02:59 <sorear> s/infix/prefix/
19:03:10 <mr_tenor> if Num is a class, why shouldn't List be?
19:03:10 <sorear> emu: no!
19:03:27 <emu> i'm not talking some principia mathematica thing here
19:03:28 <monochrom> I would just say I do not know of a simple and consistent way of eliminating fromIntegral
19:03:40 <sorear> emu: C has automatic coercions, effective typing, and type inference
19:03:48 <sorear> just not enough of the latter :(
19:04:00 <monochrom> C's automatic coercions are consistent but not simple.
19:04:01 <yip> monochrom: automatic calling of fromIntegral, maybe using a new syntax (like do syntax)
19:04:04 <emu> yea, automatic coercian to a machine word. for everything.
19:04:14 <sorear> Long live B!
19:04:38 <emu> is it a B language?
19:04:39 * audreyt hugs D
19:05:15 <Excedrin> C's type inference is simple, undeclared types default to int...
19:05:52 <syntaxfree> C needs garbage collection.
19:05:59 <emu> "32-bits ought to be enough for anyone"
19:06:04 <monochrom> yip: if someone can give such a scheme that would be nice.  right now it all looks speculative to me.
19:06:06 <sorear> I was referring to: int main() { int x,y,z; return x+(y+z); }
19:06:15 <sorear> you notice no type on y+z
19:06:25 <shapr> yip: Not any big changes, no.
19:08:11 <Xgc> sorear: That's not quite true.  int x, y, z; declares int as the type of each, just as float x, y, z; declares these all as floats, in C.
19:08:56 <SamB_XP> syntaxfree: btw, I mentioned that idea about a TAOCP Algorithms language in connection with the people who were able to read russian maths because they had read a russian maths phrasebook...
19:09:00 <Korollary> how did you see that
19:09:10 <monochrom> C defaults to int in this sense.  You write "f() { ... }", f's return type is int.
19:09:20 <Xgc> sorear: Originally, you could have no type at all for certain declarations.  main() { return 0;}
19:10:18 <Xgc> You could also just have, ... z=5; main() {return z;}
19:10:32 <monochrom> There is too much misinformation.  dons asks the question "how do we politely tell people that it is misinformation without hurting their dignity?"  I am not sure how to.  I am not even sure if it's the right question to ask.
19:11:37 <Xgc> s/no type/undeclared type/
19:11:54 <chessguy> what do you mean by 'disinformation'?
19:12:42 <SamB_XP> chessguy: incorrect ideas
19:12:49 <SamB_XP> presented as if they were correct ideas
19:12:51 <chessguy> i mean if someone says factorial should be of type String -> ([Float, Bool]), you should just tell them they're nuts
19:12:56 <monochrom> for example "in x+(y+z) the y+z defaults to int"
19:13:17 <monochrom> for example "to learn IO you need to know category theory"
19:13:17 <emu> Xgc: the intermediate result
19:13:18 <SamB_XP> monochrom: and this is about Haskell?
19:13:24 <sorear> double x,y,z; what type is y+z ?
19:13:32 <Xgc> sorear: float.
19:13:35 <dibblego> what's the best way to have one great big dirty String literal, including new line characters?
19:13:42 <Xgc> sorear: Ooops. double
19:13:47 <Xgc> You changed the type.
19:13:53 <emu> Xgc: you inferred that
19:14:03 <glguy> dibblego: "that\nthat"
19:14:05 <glguy> is that what you want?
19:14:07 <emu> technically, it's wrong, since y+z could be outside of double range
19:14:15 <Xgc> emu: I assumed based on his first example, without reading completely.
19:14:16 <emu> but C hand-waves that
19:14:17 <dibblego> glguy, yeah something like that
19:14:36 <dibblego> glguy, imagine a source file as a String literal; how would you write it?
19:14:41 <chessguy> > lines "that\nthat"
19:14:41 <Xgc> emu: Sure.  C does have undefined behavior.
19:14:42 <lambdabot>  ["that","that"]
19:14:50 <emu> (well so does haskell.  c'mon arbitrary precision floats!)
19:14:53 <chessguy> > unlines "that\nthat"
19:14:54 <lambdabot>  Couldn't match `String' against `Char'
19:15:04 <dibblego> > unlines ["that","that"]
19:15:06 <lambdabot>  "that\nthat\n"
19:15:12 <chessguy> that too :)
19:15:36 <chessguy> @type unlines
19:15:38 <lambdabot> [String] -> String
19:16:07 <Xgc> emu: But the effective type of the expression is still double, even if the runtime behavior is undefined, in C.
19:16:15 <chessguy> > unlines ["that\nthat\n"]
19:16:16 <lambdabot>  "that\nthat\n\n"
19:16:21 <emu> of course. and that was inferred.
19:16:49 <monochrom> "technically, it's wrong, since y+z could be outside of double range, but C hand-waves that"  another example of misinformation.
19:17:02 <emu> the compiler says of (+), well, if both of its arguments are double, then the result is a double.  and it has some rules regarding mixed types.
19:17:06 <deadbeef> is there any tutorial about reducing a problem to SAT ?
19:17:43 <Xgc> monochrom: *nod* The C specification is full of holes.
19:17:53 <jcreigh> > let fac n = map (\x -> (x, True)) $ scanl (*) 1 [1..(read n)] in fac "5" :: [(Float, Bool)]
19:17:54 <lambdabot>  [(1.0,True),(1.0,True),(2.0,True),(6.0,True),(24.0,True),(120.0,True)]
19:18:02 <jcreigh> chessguy: there. :P
19:18:10 <chessguy> haha
19:18:28 <emu> > maxBound::Int + 1
19:18:28 <lambdabot>  Parse error
19:18:32 <jcreigh> I couldn't think of something semi-reasonable for the Bool value...
19:18:36 <emu> > (maxBound::Int) + 1
19:18:38 <lambdabot>  -2147483648
19:19:58 <chessguy> ?remember jcreigh <chessguy> i mean if someone says factorial should be of type String -> [(Float, Bool)], you should just tell them they're nuts  <jcreigh> > let fac n = map (\x -> (x, True)) $ scanl (*) 1 [1..(read n)] in fac "5" :: [(Float, Bool)]
19:20:20 <chessguy> @type let fac n = map (\x -> (x, True)) $ scanl (*) 1 [1..(read n)] in fac "5" :: [(Float, Bool)]
19:20:22 <lambdabot> [(Float, Bool)] :: [(Float, Bool)]
19:20:37 <monochrom> Bool has 3 values (denotationally anyway): True, False, undefined.
19:20:50 <chessguy> @type map (\x -> (x, True)) $ scanl (*) 1 [1..(read n)]
19:20:51 <lambdabot> Not in scope: `n'
19:21:08 <chessguy> @type map (\x n -> (x, True)) $ scanl (*) 1 [1..(read n)]
19:21:09 <lambdabot> Not in scope: `n'
19:21:27 <emu> > map product (inits [1..])
19:21:28 <allbery_b> @type \n -> map (\x -> (x, True)) $ scanl (*) 1 [1..(read n)]
19:21:29 <lambdabot>  [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,...
19:21:30 <lambdabot> forall a. (Num a, Read a, Enum a) => String -> [(a, Bool)]
19:21:43 <chessguy> aha!
19:21:48 <chessguy> it's too general!
19:22:31 <dmead> > 6/0
19:22:32 <lambdabot>  Infinity
19:22:34 <dmead> !
19:22:44 <chessguy> it should return nullity, not infinity:)
19:22:48 <jcreigh> yeah. That's why I had to say :: [(Float, Bool)]
19:22:51 <dmead> or undefined
19:22:52 <chessguy> silly bot
19:22:55 <dmead> =p
19:23:07 <emu> > let 6/0 = "Nullity" in 6/0
19:23:09 <lambdabot>  "Nullity"
19:23:09 <monochrom> The bot was written before the invention of nullity.
19:23:14 <dmead> > 6/0
19:23:15 <lambdabot>  Infinity
19:23:18 <dmead> =p
19:23:24 <chessguy> > let Infinity = "Nullity" in 6/0
19:23:25 <lambdabot>  Not in scope: data constructor `Infinity'
19:23:29 <chessguy> bah
19:23:39 <dmead> whats nullity?
19:23:39 <dmead> o0
19:23:40 <jcreigh> > let _/0 = 42 in 6/0
19:23:42 <lambdabot>  42
19:23:47 <dmead> rofl
19:23:52 <dmead> 5/0
19:23:53 <emu> dmead: think of the wonders of Java null and combine it with abstract algebra
19:23:54 <chessguy> dmead, believe me, you don't want to know
19:23:56 <dmead> > 5/0
19:23:57 <monochrom> someone in Britain coined "nullity" for 0/0
19:23:57 <lambdabot>  Infinity
19:24:13 <chessguy> @go calewiki james anderson
19:24:15 <lambdabot> http://del.icio.us/jimm
19:24:15 <lambdabot> Title: jimm's bookmarks on del.icio.us
19:24:19 <chessguy> ack
19:24:22 <dmead> :o
19:24:34 <chessguy> @go "open letter to james anderson"
19:24:37 <lambdabot> http://programming.reddit.com/info/u2jy/comments
19:24:37 <lambdabot> Title: An open letter to James Anderson regarding his arithmetic system (reddit.com)
19:24:41 <dmead> oh that
19:24:43 <dmead> yea
19:24:45 <chessguy> close enough
19:24:49 <dmead> i had a pal of mine whos a math proff read it
19:24:56 <dmead> he said it's not totally bullshit
19:25:00 <dmead> so i guess thats good ;o
19:25:09 <chessguy> no, but cale makes some very good points about it
19:25:10 <monochrom> On this matter I agree with Richard Feymann.  You learn nothing by giving names to things.  But the general mass thinks otherwise.
19:25:19 <hyrax42> where is a good quick reference for the ins and outs of record syntax
19:25:25 <emu> oh come now, what would they teach in biology class
19:25:28 <hyrax42> extensions and so on
19:25:47 <dmead> so uhh
19:25:50 <hyrax42> and defaults
19:25:57 <dmead> lambdabot really needs to return 42 ^ elephant
19:26:05 <dmead> :>
19:26:09 <chessguy> elephant?
19:26:12 <monochrom> ?h98
19:26:12 <lambdabot> Unknown command, try @list
19:26:38 <monochrom> Oh quick reference.  Dunno.
19:26:45 <emu> i learned a ton just by hearing the name "monad":
19:26:53 <kyevan> ...
19:26:56 <dmead> isn't that what is actually in HGTTG?
19:27:01 <dmead> or just 42
19:27:03 <dmead> i forget :<
19:27:22 <kyevan> Everyone said it, but I didn't really beleve them...
19:27:23 <chessguy> hmm, i thought it was just 42
19:27:23 <jcreigh> > Just 42
19:27:24 <dmead> > 96/2 => 42/0
19:27:25 <lambdabot>  Just 42
19:27:25 <lambdabot>  Parse error
19:27:26 <monochrom> I could give one now.  data R = R{ x::Int, y::String } | other constructors if you have them
19:27:34 <kyevan> That's all there is to monads?
19:27:46 <kyevan> > let 6 * 9 = 42 in 6 * 9
19:27:47 <allbery_b> 42, then 6*9 :)
19:27:47 <lambdabot>  42
19:27:48 <emu> > let 6*9 = 42 in 6*9
19:27:49 <lambdabot>  42
19:27:53 <emu> jinx
19:28:00 <kyevan> emu: I said it first!
19:28:07 <dmead> > 6*9
19:28:08 <lambdabot>  54
19:28:11 <dmead> =<
19:28:12 <chessguy> @Let theAnswerToTheLifeTheUniverseAndEverything = 42
19:28:14 <lambdabot> Defined.
19:28:15 <monochrom> record update (non-destructive, new record created): r{x=10}
19:28:26 <dmead> > theAnswerToTheLifeTheUniverseAndEverything
19:28:27 <lambdabot>  Not in scope: `theAnswerToTheLifeTheUniverseAndEverything'
19:28:29 <dmead> wtf
19:28:30 <monochrom> get a field of a record: x r
19:28:40 <chessguy> > L.theAnswerToTheLifeTheUniverseAndEverything
19:28:42 <lambdabot>  42
19:28:46 <dmead> o
19:28:58 <kyevan> chessguy: Shouldn't that be theUltimateAnswerToTheUltimateQuestionOfLifeTheUniverseAndEverything?
19:28:58 <dmead> =
19:29:00 <dmead> =)
19:29:06 <jcreigh> how long to @let bindings last?
19:29:08 <dmead> !
19:29:08 <jcreigh> *do
19:29:12 <monochrom> pattern matching: case r of R{x=myx} -> ...myx...
19:29:13 <dmead> brb
19:29:14 <kyevan> (that was my password on the school csci server for a while...)
19:29:20 <chessguy> @undefine theAnswerToTheLifeTheUniverseAndEverything
19:29:21 <lambdabot> Undefined.
19:29:32 <chessguy> kyevan, what can i say, i'm lazy
19:29:51 <monochrom> That is my quick reference of record syntax.  Sadly all these jokers just spam and scroll away my important stuff.
19:29:58 <kyevan> TUATTUQOLTUAE
19:30:12 <chessguy> heh. all 3 lines of it
19:30:27 <monochrom> Do you think it's time to repeat "people use /msg lambdabot"
19:30:41 <HugoG> Hello. I have a basic question. I have data of type "Either Maybe (f,s)" and I want to return "Either f". Can I do this with existant functions? What are the options I have?
19:30:57 <yip> does HAppS use STM?
19:31:06 <emu> Either needs two types
19:31:18 <monochrom> "Either Maybe (f,s)" looks wrong.  typo?
19:31:22 <emu> or are you just omitting the second
19:31:49 <HugoG> Omitting. In fact, only f has different type.
19:32:17 <emu> Left (Just (f,_)) -> Left f
19:33:00 <HugoG> I know, but I must build a function to do that. Isn't there an easier way?
19:33:09 <monochrom> Must you?
19:33:09 <emu> admittedly, it's an odd type
19:34:00 <emu> it probably took you longer to check IRC than to write the function oO
19:34:00 <monochrom> Sorry, I think I don't understand the question.
19:34:28 <emu> ?pl \e -> case e of Left (Just (f,_)) -> Left f
19:34:28 <lambdabot> (line 1, column 30):
19:34:29 <lambdabot> unexpected ","
19:34:29 <lambdabot> expecting letter or digit, variable, "(", operator or ")"
19:34:37 <emu> ?pl \Left (Just (f,_)) -> Left f
19:34:37 <lambdabot> (line 1, column 13):
19:34:38 <lambdabot> unexpected "("
19:34:38 <lambdabot> expecting operator or ")"
19:36:20 <HugoG> Humph... Writting the function is not a problem. I'd like to use either (a->c) (b->c) (Either (Maybe (a,t)) (Maybe (b,t))))
19:38:12 <HugoG> Like: my_function :: Either a -> Either (Maybe (Exp,String)) (Maybe (Def,String)) -> Def
19:38:46 <emu> might be time to invest in your own datatype
19:38:47 <Excedrin> yip: yes, MACID does
19:39:35 <monochrom> No, there is no such thing as "Either a".  You may like to re-consider your design.
19:39:51 <HugoG> Either a b, sorry
19:40:00 <monochrom> Ah ok. Let me look again.
19:40:02 <HugoG> Either Def Exp actually
19:40:29 <HugoG> my_function :: Either Def Exp -> Either (Maybe (Def,String)) (Maybe (Exp,String)) -> Def
19:43:56 <monochrom> The return type Def is a bit odd.
19:44:14 <monochrom> What should my_function do?
19:45:06 <HugoG> my_function should convert point wise functions to point free.
19:45:49 <monochrom> Have you written a version of it?
19:45:52 <HugoG> Def is the definition of the function. Exp is the expression to the right. (Def = Exp :=: Exp)
19:48:10 <chessguy> @type print
19:48:10 <dibblego> ?type (>>=)
19:48:11 <lambdabot> forall a. (Show a) => a -> IO ()
19:48:12 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
19:48:15 <monochrom> ?paste
19:48:16 <lambdabot> http://paste.lisp.org/new/haskell
19:49:32 <HugoG> Then, two functions simplify the definition: one simplifies variables and uses Def type, while the other simplifies the expression to the right and uses Exp type. They return, respectively, Maybe (Def,String) and Maybe (Exp,String); where String is, in both cases, the description of the law used to simplify the expression. If Nothing is return, it means that either one of the mentioned...
19:49:35 <HugoG> ...functions could not simplify the expression any further.
19:49:37 <P4W3R> mmm
19:49:44 <P4W3R> some day i will learn haskell
19:49:45 <P4W3R> ..
19:49:51 <P4W3R> full haskell
19:50:42 <SamB_XP> hmm, go to is down to #2 in the list of things considered harmful?
19:50:57 <HugoG> I don't know Haskell, and I'm trying to help a friend who knows even less than I do, but needs his point wise to point free converter ready for Programming Methods class.
19:51:23 <monochrom> an intimidating project :)
19:51:25 <chessguy> SamB_XP, what's #1?
19:51:34 <SamB_XP> "considered harmful" essays
19:51:43 <chessguy> ...
19:51:51 <SamB_XP> http://www.google.com/search?q=considered%20harmful
19:51:52 <lambdabot> Title: considered harmful - Google Search
19:52:03 <SamB_XP> @google considered harmful
19:52:05 <lambdabot> http://meyerweb.com/eric/comment/chech.html
19:52:05 <lambdabot> Title: "Considered Harmful" Essays Considered Harmful
19:52:31 <monochrom> The first parameter of my_function, of type Either Def Exp, what is it?
19:52:34 <emu> ``yields falsity when preceeded by its quotation'' yields falsity when preceeded by its quotation
19:53:19 <SamB_XP> I think not
19:53:39 <SamB_XP> I think it yields that damn paradox
19:54:03 <emu> actually, that post brings up Dijkstra's essay, but that was damn effective, don't you think?
19:54:27 * emu looks around for GOTOs in programs today
19:54:28 <SamB_XP> the "go to" one?
19:54:42 <SamB_XP> it has people scared of using goto in C, even when they should!
19:54:47 <monochrom> You'll find lots of call/cc, emu
19:55:00 <emu> i wish i'd see more call/cc
19:55:00 <SamB_XP> monochrom: eh?
19:55:37 <emu> there's still TAGBODY / GO, in common lisp!
19:55:40 <SamB_XP> For example, a piece titled "'Considered Harmful' Essays Considered Harmful" would very likely be a case of using the "considered harmful" format to draw attention for its own sake. We will ignore such essays in this commentary.
19:55:46 <monochrom> If you look for goto in today's programs, you find call/cc
19:56:14 <emu> except that it is not goto any more than calling a function is
19:56:47 <SamB_XP> emu: thank god for that
19:56:48 <monochrom> That is a matter of perspective.
19:56:50 <Excedrin> monochrom: except for the gotos in Linux
19:56:57 <SamB_XP> I can finally goto again without getting in trouble
19:57:06 <SamB_XP> and without confusing myself, to boot!
19:57:35 <SamB_XP> (Thanks to "tail recursion as goto")
19:57:53 <lisppaste2> monochrom pasted "my_function" at http://paste.lisp.org/display/32651
19:58:19 <monochrom> HugoG: Is that a good first approximation to your quest?
19:58:27 <emu> google makes this statement: Considered Harmful - Wikipedia
19:58:49 <bd_> > () == ()
19:58:50 <lambdabot>  True
19:58:51 <bd_> > () == undefined
19:58:53 <lambdabot>  Undefined
19:59:04 <emu> > 0 < length [1..]
19:59:09 <lambdabot> Terminated
19:59:21 <HugoG> monochrom: well,  Def = Exp :=: Exp | Def :&: Def. Basicaly Right Exp is an expression simplified from applying general laws, while Left Def is a definition simplified (some or all variables removed) from applying variable removal laws. my_function has two arguments: the previous simplification and the current simplification. If the current simplification is nothing, then it tries the other...
19:59:23 <HugoG> ...simplification method.
19:59:52 <ray> samb_xp: `yields that damn paradox (also falsity) when preceded by its quotation'' yields that damn paradon (also falsity) when preceded by its quotation
20:00:03 <SamB_XP> damn paragon?
20:00:12 <ray> i cant spel.
20:00:14 <HugoG> No, monchrom, that's not what I'm looking after. I can do that.
20:00:33 <HugoG> monochrom, I want to simplify the following programme: (going to paste)
20:00:34 <SamB_XP> that ... isn't a statement
20:00:44 <SamB_XP> oh, well, actually it is one in english
20:00:56 <SamB_XP> but it isn't either true or false (unless perhaps it is both?)
20:01:20 <SamB_XP> maybe in naive set theory or something
20:02:21 <HugoG> monochrom: http://paste.lisp.org/display/32652
20:02:25 <dmead> > 6/0
20:02:26 <monochrom> You probably can't express that in FOL.  You'll need a modal logic.  In short, a logic with quoting and unquoting.
20:02:27 <lambdabot>  Infinity
20:02:29 <dmead> :>
20:02:46 <dmead> hugo: you need logic stuff?
20:02:46 <dylan> hmm, random thought about explaining monads: Don't say that "Maybe is a monad, List is a monad", etc. Tell the learner that "List has the monad operations", etc.
20:02:46 <dmead> o0
20:03:00 <dibblego> @undo do f1 f2 f3
20:03:00 <lambdabot> f1 f2 f3
20:03:10 <dibblego> @undo do f1(f2(f3))
20:03:11 <lambdabot> f1 (f2 (f3))
20:03:28 <allbery_b> "List can monad!"
20:03:32 <monochrom> dmead: no, hugo doesn't need logic stuff.
20:03:49 <HugoG> monchrom: simp _ eord = simp (extractEitherFirst) (either (simplifyDef $ extractEitherFirst) (simplifyExp ) eord) SHOULDN'T be there. It's just something that I was testing and left unfinished.
20:03:53 <emu> i always thought saying stuff like "operating in a monad" was confusing.  makes me think of leibniz
20:03:59 <dibblego> @undo do x <- f1; y <- f2 x; return (f3 y)
20:04:00 <lambdabot> f1 >>= \ x -> f2 x >>= \ y -> return (f3 y)
20:04:44 <ray> monad can verb
20:04:45 <emu> lists are monadtastic
20:04:54 <ray> monadlicious, perhaps
20:05:18 <dylan> I started out by saying that numeric operators were a thing called a Bob, and that >>= and return are Monad operators, thus that Bob and Monad are both meaningless terms (for the learner, anyway.)
20:05:44 <chessguy> dylan, i like saying "Foo is a monad". it's a reminder that monads are nothing but a typeclass
20:06:19 <dylan> chessguy: yeah, I end up saying that too, but it doesn't help explain it to someone.
20:06:23 <emu> i want to learn more category theory but am too lazy to take a class
20:07:08 <dylan> I think teaching anything has to involve a fine art of not telling certain things.
20:07:24 <monochrom> HugoG: First I have a question.  Lines 8,9 seem to be unused, because lines 5,6 already catch the same cases.
20:07:30 <dibblego> f1 >>= \ x -> f2 x >>= \ y -> return (f3 y) is the same as
20:07:34 <dylan> (I know personally, that if given tons of information on anything, I will never figure it out)
20:07:37 <dibblego> f1 >>= \ x -> f2 (x >>= \ y -> return (f3 y)) -- correct?
20:07:41 <monochrom> Oh nevermind, not the same cases.
20:08:12 <dibblego> er
20:08:16 <emu> f2 x
20:08:17 <dibblego> f1 >>= \ x -> (f2 x >>= \ y -> return (f3 y)) -- correct?
20:08:44 <emu> defensive parenthesive
20:09:24 <dibblego> but it is equivalent yes?
20:09:42 <dibblego> I thought I had all this internalised
20:09:48 <emu> ?pl f1 >>= \ x -> f2 x >>= \ y -> return (f3 y)
20:09:49 <lambdabot> f3 `fmap` (f2 =<< f1)
20:09:56 <emu> ?pl  f1 >>= \ x -> (f2 x >>= \ y -> return (f3 y))
20:09:57 <lambdabot> f3 `fmap` (f2 =<< f1)
20:10:19 <chessguy> @do f1 >>= \ x -> f2 x >>= \ y -> return (f3 y) is the same as
20:10:20 <lambdabot> f1 >>= \ x -> f2 x >>= \ y -> return (f3 y) is the same as not available
20:10:32 <chessguy> @do f1 >>= \ x -> f2 x >>= \ y -> return (f3 y)
20:10:33 <lambdabot> f1 >>= \ x -> f2 x >>= \ y -> return (f3 y) not available
20:10:46 <chessguy> hmm
20:11:55 <chessguy> @undo do { x<-f1; y<-f2 x; return (f3 y)}
20:11:56 <lambdabot> f1 >>= \ x -> f2 x >>= \ y -> return (f3 y)
20:12:03 <chessguy> :)
20:13:18 <chessguy> anyway, i think the two forms you gave should be equivalent, yes
20:14:27 <dibblego> yeah they are; I just had a scare moment where my internalisation seemed to fall apart
20:14:47 <chessguy> i know the feeling
20:15:17 <chessguy> i'm impressed with myself that i was able to convert that to do-notation. a week ago i probably couldn't have
20:15:19 <dibblego> could be worse; I could have imperative programming internalised as the only form of programming!
20:15:22 <dylan> dibblego: That happens as you get older. Perhaps you need more fiber? (sorry, had to!)
20:15:27 <Excedrin> 41946 instances of goto in linux-2.6.19.1
20:16:13 <chessguy> wow, goto in a linux kernel?
20:16:43 <allbery_b> "goto considered harmful; proof: linux"
20:18:03 <monochrom> HugoG: sorry to report this, but after much time spent on getting you to explain your problem and more time on thinking about it, I think the present code is simple enough.  There is a way to replace it by three calls to "either", but it doesn't make things simpler, because whatever functions you give to "either" will be just as lengthy.
20:18:35 <emu> that may be a bit much goto.. but there are definitely cases for it
20:19:00 <boulez> I think there's a lot of goto for early exits from functions, but where a clean-up is necessary before returning
20:20:06 <boulez> I have 'class C a' and a is of kind * -> * -> *; T is an instance of class C; is there any chance of getting [T] to be an instance of C?
20:20:18 <Excedrin> it's slightly high, since it includes instances in multiple architectures (arch/h8300/kernel/signal.c is counted, as well as arch/arm26/kernel/signal.c etc)
20:20:34 <boulez> I tried 'type MyList x y = [T x y]' and 'instance C MyList', but it seems I can't partially apply a type synonym
20:21:08 <emu> can't write instances for "type" synonyms
20:21:20 <boulez> emu: there's an extension for that
20:22:03 <HugoG> Thank you for trying, monochrom. ;)
20:22:12 <boulez> I have elsewhere 'class D b' and 'instance D S' and 'instance D [S]', which works because S and [S] have kind *
20:23:54 <monochrom> the ghc docs says, even with ghc extension, even "type P a = [[a]]; instance Monad P where" is not allowed. But it is admitted that this is an arbitrary decision, there is no consistency or implementation problem.
20:24:50 <monochrom> "type synonyms must be fully applied" is the decision made.
20:25:08 <SamB_XP> monochrom: mmm...
20:25:20 <SamB_XP> monochrom: you can't do that!
20:25:35 <monochrom> I can't do what?
20:25:35 <SamB_XP> that would be like...
20:25:46 <SamB_XP> instance Monad ([] . [])
20:26:02 <boulez> ... and 'instance C [T]' won't work because if T's kind is * -> * -> *, and C is expecting kinds of * -> * -> *, then [T]'s kind is, uh...
20:26:17 <boulez> I wanted to use a type synonym to get something of kind * -> * -> *
20:26:27 <SamB_XP> boulez: um, yeah, don't.
20:26:33 <SamB_XP> maybe newtypes instead?
20:26:58 <chessguy> [] . [] ?
20:27:00 <boulez> but then it's not really a list
20:27:07 <chessguy> what the heck is that
20:27:10 <SamB_XP> chessguy: if you could do composition of type constructors
20:27:21 <chessguy> mmhmm
20:27:31 <SamB_XP> i.e. (/\a -> [[a]]), where /\ is a type lambda
20:27:39 <boulez> yeah
20:27:45 <chessguy> riiiiight
20:27:54 <boulez> I want dat
20:28:35 <SamB_XP> boulez: well, it would really really complicate things, not to mention making my brain explode
20:28:57 <boulez> guess I lose this battle
20:29:05 <SamB_XP> so, try a newtype instead ;-)
20:29:16 <xpika> > let a = 3
20:29:17 <lambdabot>  Parse error
20:29:20 <xpika> :(
20:29:31 <SamB_XP> > let a = 3 in a
20:29:32 <lambdabot>  3
20:29:44 <Excedrin> @let a = 3
20:29:45 <lambdabot> Defined.
20:29:47 <Excedrin> > L.a
20:29:49 <lambdabot>  3
20:29:55 <xpika> > a
20:29:56 <lambdabot>  Not in scope: `a'
20:30:25 <Excedrin> @undefine a
20:30:27 <lambdabot> Undefined.
20:37:49 <SamB_XP> @ quit
20:38:07 <SamB_XP> @quit
20:38:07 <lambdabot> Not enough privileges
20:38:49 <monochrom> You mean /quit
20:38:54 <SamB_XP> no
20:38:58 <monochrom> /quit
20:39:00 <monochrom> Like that
20:39:02 <SamB_XP> not really
20:39:26 <SamB_XP> I was just seeing whether lambdabot would take commands with a space after the @
20:53:59 <hyrax42> what is "standard" style for big pattern matches on a record?
20:54:11 <hyrax42> split across lines?
20:54:22 <hyrax42> or just move the pattern match down from function name
20:55:09 <Cale> I suppose it depends on how big the pattern match is. I usually found myself avoiding pattern matches against records.
20:55:29 <hyrax42> in favour of?
20:55:39 <wy> I'm still confused by some recursive usage about laziness. Is there some kind of rules of a thumb that can easily determine that?
20:55:42 <hyrax42> (I'd rather avoid it myself, but seems necessary)
20:56:03 <hyrax42> wy: explain/elucidate
20:56:28 <hyrax42> Cale: this amtch will be either 4 or 6 fields, probably 6
20:56:41 <wy> hyrax42: sometimes we can use the thing we are defining, but sometimes can't
20:57:17 <hyrax42> my: illustrate?
20:57:27 <Cale> wy: The important thing in recursively defining a value is to provide some information about that value even before you need the recursive case to determine the rest.
20:58:04 <Cale> This means that for instance, you have to be able to determine the top level data constructor before needing the recursive case, or you'll never get anywhere.
20:58:43 <chessguy> Cale!
20:59:06 <Cale> For example, if I define  xs = xs ++ xs, this is just going to bottom out, because there's no way to tell whether xs = [] or xs = (y:ys), for some y and ys
20:59:27 <chessguy> i'm *finally* starting to grok monads. i converted something to and from do notation earlier in answer to a question about two de-sugared do blocks were equivalent
20:59:36 <Cale> cool
20:59:45 <hyrax42> chessguy: it's a great feeling, isn't it?
20:59:51 <chessguy> i feel so alive!
20:59:58 <hyrax42> it was a pretty sharp transition for me
21:00:13 <chessguy> i wish i knew what finally pushed me over the edge
21:00:16 <hyrax42> I went from being afraid of (>>=) to using it "intuitively" very quickly
21:00:21 <lisppaste2> wy pasted "Why can I use bindings here?" at http://paste.lisp.org/display/32657
21:00:39 <hyrax42> but the period of fear lasted a very long time
21:00:57 <chessguy> hyrax42, i've been studying haskell for months now
21:00:58 <Cale> yeah, there seems to be a lot of talk which scares beginners
21:01:01 <wy> Cale: I pasted a case which is somewhat boggling my mind.
21:01:21 <Cale> mapAccumL <-- capital L?
21:01:33 <hyrax42> Cale: yeah, I think the abundance of tutorials for them is detrimental
21:02:00 <hyrax42> they should all be abolished, leaving only Monads as Containers and All About Monads
21:02:04 <Cale> hyrax42: well, a couple of years ago, it was lack of tutorials which was the problem :)
21:02:14 <Cale> Well, thankyou :)
21:02:15 <wy> Cale: It's a function defined in another file. Do you think there is a standard function called mapAccumL?
21:02:20 <Cale> yes, there is
21:02:24 <Cale> @type mapAccumL
21:02:26 <lambdabot> forall y acc x. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
21:02:33 <wy> Cale: Oh I didn't know!
21:02:56 <hyrax42> Cale: well it is quite sincere.  Your little article is what got me grokking at least Maybe and List
21:03:04 <hyrax42> actually only recenlty I got a feel for Monads as Computation
21:03:13 <wy> Cale: It's the same
21:03:17 <chessguy> i think there were three parts to it that i really had to beat into my skull. 1.) monads are just a type class  2.) monads are just an abstract model of a computation and 3.) the sugaring/desugaring of do-notation
21:03:42 <Cale> chessguy: have you done the "make Tree a monad" exercise yet?
21:03:43 <hyrax42> towards teh end of my theory of computation class, we were showing various things are recursively enumerable
21:03:52 <Cale> wy: okay
21:03:55 <jcreigh> hyrax42: yes, those two are the only tutorials I've gotten anything out of as well. (well, those and YAHT)
21:03:57 <hyrax42> and coming up wiht a semi-decision procedure usually ends up being very much like something in the Maybe monad
21:03:57 <chessguy> Cale, hmmm. i don't think so
21:04:04 <brad__> does anyone know how to get around this cabal error:Could not find module `Text.Regex':it is a member of package regex-compat-0.71, which is hidden
21:04:12 <hyrax42> which was an "aha" for me
21:04:27 <hyrax42> jcreigh: YAHT I found useful mostly only the first 4 chapters or so
21:04:29 <wy> Cale: Maybe you can give me some general hint why this works
21:04:47 <hyrax42> the monad section I didn't read, the IO and modules is sort of a learn-as-you-need thing
21:04:49 <dylan> brad__: add regex-compat to your Build-Depends: line
21:04:56 <brad__> thanks dylan!
21:05:01 <Cale> wy: which is the confusing part?
21:05:06 <chessguy> Cale, is it written up somewhere, or is that all there is to it?
21:05:17 <hyrax42> advanced type system features you get later, also sort of as needed
21:06:27 <hyrax42> chessguy: it's sort of mentioned in Monads as Containers IIRC
21:06:27 <Cale> chessguy: I'm saying, write an instance of Monad for that :)
21:06:53 <hyrax42> I wrote the instance while still in the pre-grokking state
21:07:08 <hyrax42> I remember getting Cale to check it, and being a bit nonplussed over how I could write it
21:07:15 <hyrax42> and still not understand what it "meant"
21:07:31 <chessguy> hmm, i would assume it has some similarities to the list monad
21:07:39 <chessguy> ?where monads as containers
21:07:39 <lambdabot> http://www.nomaware.com/monads/html/index.html
21:07:44 <Cale> It does, it's very similar
21:07:47 <wy> Cale: Why can I use (bindings++env)? before bindings is even defined in let?
21:07:50 <chessguy> @go monads as containers
21:07:51 <hyrax42> that's all about monads
21:07:53 <lambdabot> http://www.haskell.org/haskellwiki/Monads_as_Containers
21:07:53 <lambdabot> Title: Monads as containers - HaskellWiki
21:09:40 <jcreigh> Hmm, I wrote an instance of Monad for Tree, but I don't know if it's the "right" one. (Seems to obey the monadic laws, but I'm not 100% sure.)
21:09:55 <Cale> wy: well, to determine why that's okay, I suppose you'd have to look more closely at how instantiate actually uses its parameters.
21:10:56 <Cale> jcreigh: I'm fairly sure the obvious one will be the right one -- of course, if you'd like you can find yourself the list of monad laws, and try proving them :)
21:11:11 <monochrom> wy: you mean like let {x = y; y = 10} ?
21:11:14 <wy> Cale: It'll do lookup in the env parameter
21:11:14 <Cale> Or paste it somewhere and I'll let you know if it's the one I had in mind
21:12:12 <chessguy> hmm, i'll definitely have to work through that exercise.
21:12:24 <chessguy> i have an idea what it should look like
21:12:40 <wy> monochrom: In my case they are more complex structures, but maybe in essence they are the same
21:13:17 <Cale> > let evens = 0 : map succ odds; odds = map succ evens in take 10 evens
21:13:18 <monochrom> It allows mutual recursion.
21:13:19 <lambdabot>  [0,2,4,6,8,10,12,14,16,18]
21:13:26 <glguy> is the obvious case data type: data Tree a = Leaf | Branch (Tree a) a (Tree a)?
21:13:39 <Cale> glguy: that one works too
21:13:56 <Cale> er, well, that's trickier to make a monad
21:13:59 <glguy> yeah
21:14:12 <Cale> leaf-labelled trees are much easier
21:14:35 <Cale> wy: does that code cause you the same difficulty?
21:14:42 <glguy> data Tree a = Leaf a | Branch [Tree a]
21:15:05 <monochrom> To support mutual recursion you must allow let { x = ...y... ; {- later -} y = ... }.
21:15:08 <chessguy> the structure Cale gave was just data Tree a = Leaf | Branch (Tree a) (Tree a)
21:15:09 <Cale> wy: I think the problem is just that instantiateLet and mapAccumL are not obvious functions, so it's not so easy to see that the demand is satisfied.
21:15:33 <monochrom> In Pascal one has to add the keyword "forward" for x.
21:15:35 <Cale> data Tree a = Leaf a | Branch [Tree a], or data Tree a = Leaf a | Branch (Tree a) (Tree a)
21:15:47 <brad__> irc help: how do i send messages to lambdabot?
21:16:00 <monochrom> Err in Pascal one has to write like let { forward y; x = ...y... ; y = ... }
21:16:12 <Cale> brad__: /query lambdabot should bring up a tab or window for talking to it privately
21:16:22 <monochrom> I am not sure whether I am relevant :)
21:16:27 <Cale> brad__: or else "/msg lambdabot ..." will send it one message
21:16:39 <Cale> hmm
21:16:43 <wy> Cale: I knew why this even-odd example works. But I might need some kind of rules about that
21:16:45 <chessguy> lol
21:16:58 <monochrom> His firewall has a rule for dropping connections upon seeing "/msg"
21:17:28 <Cale> wy: well, okay, I think the easiest thing might be to get some example data which makes use of this mutual recursion and evaluate it yourself by hand
21:17:31 <jcreigh> Okay, I'm going to paste my implementation, and I think it might be right, so if you're still working on the Tree example, my paste might be somewhat of a "spoiler"
21:17:46 <Cale> wy: and see if you can work out, say, what the first element of bindings will be
21:17:56 <wy> Cale: So can I say because evens is defined at the head, and odds only need the head of evens in order to produce the first element. And we only need the elements one by one?
21:18:05 <Cale> wy: right
21:18:09 <chessguy> jcreigh, it's ok, i have a pretty good idea how it should go
21:18:19 <lisppaste2> jcreigh pasted "Is this what Cale had in mind?" at http://paste.lisp.org/display/32658
21:18:28 <glguy> so the /msg text triggers the firewall? or actually sendinga PRIVMSG does it?
21:18:39 <Cale> jcreigh: exactly
21:18:58 <jcreigh> Cale: excellent, thank you
21:19:00 <wy> Cale: OK. I'll try to deduce the reason for my program then
21:19:35 <Cale> wy: The sort of thing to ask yourself is "what if I want to know the kth element of bindings?"
21:19:48 <chessguy> hmmm
21:20:10 <chessguy> wouldn't it be preferable to write a treeMap function?
21:20:25 <chessguy> and then define >>= in terms of that
21:20:33 <monochrom> I was just kidding about /msg booting off people.
21:20:46 <monochrom> You also need a join for trees.
21:20:47 <glguy> no, there is a firewall that does something like that though
21:20:48 <Cale> chessguy: you can go one way or the other
21:21:05 <chessguy> and what's this fmap = liftM business?
21:21:08 <glguy> s/no/
21:21:13 <sorear> beside, you use PRIVMSG #haskell with no ill effects
21:21:17 <Cale> chessguy: monochrom is right though, you'll want to write join too if you want to write bind in terms of fmap
21:21:20 <monochrom> The firewall bug I heard of was a DCC thing.
21:21:42 <Cale> chessguy: liftM is the same thing as fmap, but it applies to any monad
21:22:14 <chessguy> mmm, i don't really know what fmap is
21:22:18 <Cale> Once you have an instance of Monad, you get an instance of Functor automatically using liftM
21:22:25 <glguy> From the article: ‘Turns out that if someone types “startkeylogger” or “stopkeylogger” in an IRC channel, anyone on the channel using the affected Norton products will be immediately kicked off without warning.
21:22:51 <Cale> That's a good thing to work on -- Functor is an easier class to understand than Monad is, and I usually recommend understanding it first.
21:23:13 <chessguy> figures. i have a habit of doing things the hard way
21:23:23 <sorear> Ah good, I see no Signoff: XYZ (Connection reset... :)
21:23:50 <Cale> sorear: yeah, that's really old news
21:23:55 <wy> Cale: Do you think bindings is initially empty? I guess so, but I can't find why.
21:24:13 <monochrom> Oh, I now why the firewall does that.  It is to work around malware that goes to irc and waits for commands.
21:24:20 <glguy> yeah
21:24:24 <Excedrin> there's a couple other strings that trigger the same thing
21:24:35 <Cale> wy: bindings is constant, isn't it?
21:24:40 <Cale> :)
21:24:52 <jcreigh> I don't really understand Functor either. I understand that fmap behaves basically the same as map on lists, except generalized for other datatypes. What I don't understand is what a Functor is good for. ie, what is the typical use case for a Functor?
21:24:54 <monochrom> I guess while it is not a complete or nice solution, at least it does reduce a few spamming hosts :)
21:25:00 <chessguy> ?doc fmap
21:25:01 <lambdabot> fmap not available
21:25:06 <Cale> @type fmap
21:25:07 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
21:25:24 <chessguy> @hoogle Functor
21:25:24 <Cale> jcreigh: Well, it just generalises the idea of a container type.
21:25:25 <lambdabot> Prelude.Functor :: class Functor f
21:25:25 <lambdabot> Data.FunctorM :: module
21:25:25 <lambdabot> Data.FunctorM.FunctorM :: class FunctorM f
21:25:32 <glguy> main = fmap read getLine
21:25:41 <jcreigh> Norton's products intercept arbitrary network protocols a lot. (SMTP, POP3, probably IMAP)
21:25:42 <dibblego> ?where point-free
21:25:42 <Cale> jcreigh: In a much weaker way than the Monad class does
21:25:43 <lambdabot> I know nothing about point-free.
21:25:45 <dibblego> ?where pointfree
21:25:46 <lambdabot> I know nothing about pointfree.
21:25:49 <dibblego> ?where pointless
21:25:50 <lambdabot> I know nothing about pointless.
21:25:50 <chessguy> ?doc Prelude.Functor
21:25:51 <lambdabot> Prelude.Functor not available
21:26:10 <Cale> Basically, the least thing which you'd hope to be able to do with a container is apply a function to the elements.
21:26:28 <wy> Cale: bindings is something the function is trying to construct.
21:26:48 <wy> Cale: It should be an association list
21:26:57 <Cale> wy: bindings is defined as the second part of the pair that mapAccumL is returning
21:27:09 <chessguy> oh here we go
21:27:12 <chessguy> @wiki Functor
21:27:13 <lambdabot> http://www.haskell.org/haskellwiki/Functor
21:27:22 <hyrax42> ?type fromMaybe
21:27:23 <jcreigh> okay, but all the interesting Functors also seem to be Monads.
21:27:24 <lambdabot> forall a. a -> Maybe a -> a
21:27:33 <hyrax42> ?type maybe
21:27:35 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
21:27:36 <chessguy> oh, fmap is the only requirement for Functor?
21:27:39 <Cale> jcreigh: not quite true :)
21:27:45 <Cale> chessguy: yeah
21:27:51 <jcreigh> Cale: hence "seem to be". :)
21:28:06 <Cale> We just use a lot of monads, so it seems that way
21:28:10 <glguy> but, since all Monads are Functors... and Monads are typically more complex...
21:28:19 <wy> Cale: When we need the first element of bindings, ...
21:28:46 <Cale> all comonads are functors as well
21:29:00 <Cale> and there's that funky applicative class
21:29:22 <Cale> but you can also get datatypes where it's not obvious how to make the thing a monad, but a functor instance is easy
21:29:47 <Cale> wy: your mapAccumL is the same as the standard one, right?
21:30:10 <SamB_XP> Philippa: so you have the urge to tell me to STFU a lot?
21:30:14 <wy> Cale: When we need the first element of bindings, mapAccumL will call the function allocateBind on heap and the first element of defs
21:30:32 <Cale> wy: right
21:30:33 <wy> Cale: According to the type you showed me, they are the same
21:30:37 <Cale> okay
21:31:23 <Cale> mapAccumL f s []        =  (s, [])
21:31:23 <Cale> mapAccumL f s (x:xs)    =  (s'',y:ys)
21:31:23 <Cale>                            where (s', y ) = f s x
21:31:23 <Cale>                                  (s'',ys) = mapAccumL f s' xs
21:31:34 <Cale> just thought it might be handy to have that here
21:31:37 <wy> Cale: When allocateBind is called, it needs (bindings++env). So what should be the value of bindings now?
21:31:55 <Cale> wy: but does it need that whole list?
21:32:36 <wy> Cale: So it depends on how instantiate use the env parameter
21:32:54 <Cale> don't worry about evaluating bindings ++ env yet
21:33:22 <Cale> You're not pattern matching against it
21:33:34 <Cale> at least, not yet anyway
21:34:29 <Cale> At some low level, the only things which cause evaluation to start happening are pattern matching and IO.
21:35:11 <Cale> So let's see, we're calling allocateBind with the heap, and the first element of defs
21:35:37 <Cale> and the first element of bindings is then (var, addr)
21:35:51 <hyrax42> I love it when things typecheck
21:35:53 <Cale> where var is taken from the fst of that first element of defs
21:36:30 <Cale> and addr is the second part of what's returned from  instantiate val heap (if isrec then bindings ++ env else env)
21:36:51 <Cale> now, what does instantiate do?
21:37:03 <Cale> I don't have that code
21:37:05 <chessguy> Cale,  hey, you have an idea where i'm at in comprehending haskell...got any suggestions for a book to get? i'd like to spend some of my Christmas money on a haskell book
21:37:23 <wy> instantiate (EVar v) heap env
21:37:23 <wy>     = (heap, aLookup env v (error ("Undefined name " ++ show v)))
21:37:26 <Cale> but all you need to do is work out what the second part of what's returned from instantiate is, and you'll have it
21:38:06 <wy> That's the related part of instantiate. Other patterns don't use env
21:38:30 <wy> It will do a lookup in the env list
21:38:40 <Cale> chessguy: Unfortunately I never really found any Haskell book that I was crazy about -- other people probably have other opinions on it :)
21:39:04 <Cale> wy: okay
21:39:32 <Cale> wy: does this code actually work? :)
21:39:40 <wy> Cale: Yes it works
21:39:42 <Cale> okay
21:40:06 <Cale> so let's suppose that isrec is True
21:40:14 <monochrom> I never found any Haskell book crazy.
21:40:25 <wy> yes we can suppose it's true
21:41:03 <Cale> instantiate (EVar v) heap (bindings ++ env)
21:41:05 <chessguy> Cale, you don't even like the Bird and Wadler book?
21:41:27 <Cale> chessguy: I don't recall
21:41:32 <wy> yes
21:41:42 <Cale> = (heap, aLookup (bindings ++ env) v (error ("Undefined name " ++ show v)))
21:41:45 <dibblego> ?type fail
21:41:47 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
21:41:58 <Cale> and we're specifically interested in  aLookup (bindings ++ env) v (error ("Undefined name " ++ show v))
21:42:06 <Cale> because it's the first element of bindings.
21:42:30 <deadbeef> hey Cale, you at uwaterloo ?
21:42:32 <Cale> somehow this looks scary to me, but let's have a look at the definition of aLookup
21:42:39 <Cale> deadbeef: I was
21:42:59 <deadbeef> because i was looking for a paper written in the '70
21:43:11 <deadbeef> and the only place i've found it is at uwaterloo's biblio
21:43:16 <Cale> yeah, I'm not there now
21:43:24 <deadbeef> omg, really ?
21:43:24 <wy> aLookup []         k' def = def
21:43:24 <wy> aLookup ((k,v):bs) k' def | k==k' = v
21:43:24 <wy>                           | otherwise = aLookup bs k' def
21:43:28 <Taral> anyone have some code for deriving Show with TH?
21:43:30 <monochrom> Like Landin's papers?
21:43:30 <deadbeef> can i ask you a favour ?
21:43:38 <Cale> deadbeef: huh?
21:45:07 <deadbeef> np
21:45:20 <wy> So aLookup will do the pattern matching on bindings++env
21:45:31 <shapr> Taral: From archives of the Template Haskell mailing list - http://www.scannedinavian.com/~shae/thderive/
21:45:33 <lambdabot> Title: Index of /~shae/thderive
21:45:37 <Cale> wy: right
21:45:40 <Taral> shapr: thanks
21:45:58 <shapr> Taral: I don't think it does Show, but it is an example of how to derive instances with TH.
21:46:03 <wy> Cale: but the first element of bindings is yet to know
21:46:04 <Taral> hm
21:46:06 <Cale> wy: which is a little sneaky, because it's also devining the first element of bindings
21:46:10 <Cale> defining*
21:46:40 <litb> hi!
21:46:46 <chessguy> hi litb
21:47:00 <shapr> grußgott litb
21:47:03 <litb> i was redirected to here when i asked for a algorithm to calc a natural cubic spline
21:47:08 <Taral> I know how, I just don't want to do it right now.
21:47:11 <litb> oh, it's a german chan?
21:47:19 <wy> Cale: I can send you all the code if you like
21:47:22 <shapr> no, english
21:47:28 <shapr> But I like to greet people in interesting ways!
21:47:38 <litb> a good explanation for such an algo would also do it
21:47:42 <shapr> litb: I know, I shouldn't use "greet god" if you're not from .at :-)
21:47:47 <litb> shapr: :D
21:48:28 <shapr> Who redirected you to #haskell?
21:48:31 <litb> oh, i'm from .de
21:48:38 <Cale> wy: that would probably be helpful, you could just paste it at lisppaste
21:48:39 <litb> shapr: ppl in ##java
21:48:44 <dibblego> shapr, I did
21:49:09 <litb> oh, yes he was it O.O
21:49:23 <dibblego> some mathematical problem that sounded like #haskell would love
21:49:32 * sorear laughs evilly
21:49:45 <shapr> dibblego: Yeah, #haskell loves math problems.
21:50:06 <shapr> But I've never solved a natural cubic spline myself...
21:50:43 <chessguy> litb, maybe you could give a brief explanation of what it is?
21:51:03 <shapr> How does natural cubic extend http://en.wikipedia.org/wiki/Cubic_spline ?
21:51:05 <sorear> by 'calculate', do you want to (a) find a spline given control points (b) find a point given parameters
21:51:12 <Cale> http://mathworld.wolfram.com/CubicSpline.html gives a means of computing the coefficients.
21:51:14 <lambdabot> Title: Cubic Spline -- from Wolfram MathWorld
21:51:19 <lisppaste2> wy pasted "main program file" at http://paste.lisp.org/display/32661
21:51:41 <Cale> Probably the wikipedia entry does too, given that it looks way more detailed :)
21:51:52 <lisppaste2> wy annotated #32661 with "utitilitiess" at http://paste.lisp.org/display/32661#1
21:52:03 <litb> i have programmed a plotter which can display (x,y) pairs. and now, because connecting them using straight lines looks ugly, i want them to be connectd using a smooth curve. and some ppl in #kde-dev said that i want a natural spline
21:52:12 <litb> so, that is because i'm here :)
21:52:34 <lisppaste2> wy annotated #32661 with "Language part" at http://paste.lisp.org/display/32661#2
21:53:06 <lisppaste2> wy annotated #32661 with "Paser" at http://paste.lisp.org/display/32661#3
21:53:17 <sorear> step a lst = zipWith (\x y -> x * a + y * (1 - a)) lst (tail lst) ; decosto a lst = iterate (step a) lst !! (length lst - 1)
21:54:10 <Cale> wy: okay, so I think the higher-level reasoning part of why there ought not to be a problem is that you're dealing with a let block in your language, presumably
21:54:43 <wy> Cale: Yes. That's the let(rec) part
21:55:11 <wy> Cale: I have to go to sleep. You can annotate the hints on it. Thanks. Good night!
21:55:20 <Cale> oh, okay
21:56:57 <Cale> litb: so presumably, you probably want to do both of the things which sorear mentioned
21:58:17 <litb> Cale: : you mean this? "step a lst = zipWith (\x y -> x * a + y * (1 - a)) lst (tail lst) ; decosto a lst = iterate (step a) lst !! (length lst - 1)"
21:58:37 <Cale> litb: I mean "<sorear> by 'calculate', do you want to (a) find a spline given control points (b) find a point given parameters"
21:58:55 <Cale> You want to do both of those things.
21:59:22 <Cale> You're starting out having a list of points which are on the spline.
21:59:59 <litb> i have a function which draws a Spline, but the spline it draw doesn't pass the datapoints i give that function
22:00:00 <Cale> The basic idea here is to extend those points to a smooth curve which passes through all of them. What do we mean by smooth?
22:00:16 <sorear> The garbage line was my attempt to write a one-liner bezier spline evaluator.
22:00:43 <goltrpoat> (wasn't here for the beginning of the conversation, but keep in mind that bezier splines and friends do not pass through the control points;  hermite splines and friends do)
22:00:59 <goltrpoat> i remember doing a writeup on those, lemme see if i can find it
22:01:12 <litb> oh, i can't even read haskell code and lisp thingies. i see it the first time now :)
22:01:38 <Cale> goltrpoat: it depends on what you're considering to be control points :)
22:01:40 <goltrpoat> http://www.flipcode.dxbug.com/wiki/index.php?title=Splines
22:01:42 <lambdabot> Title: Splines - Flipcode
22:02:02 <sorear> Like most languages, haskell oneliner tricks tend to be rather obfuscatory.
22:02:17 <litb> yeah, so the question is in what way i should extend those points so that that DrawSpline draws a curve which passes all control points
22:02:40 <litb> sorear: hehe that's soo right
22:02:55 <Cale> In this case, all we have to start with is a set of points which are definitely on the curve, and we want to work out cubic polynomial pieces which interpolate between those points, and whose derivatives line up at the nodes.
22:02:57 <sorear> IME parabolic blending is very easy to get right
22:03:15 <goltrpoat> oh hmm.  that article is a lot shorter than i remembered
22:03:24 <goltrpoat> i don't think i ever got around to putting up the final version
22:03:35 <Cale> As the MathWorld entry shows, you can quickly turn this problem into solving a linear system of equations
22:03:51 <Cale> (with a particularly nice format)
22:04:42 <Cale> litb: Is what I'm saying making sense, or is there a bunch of mathematics which you've not yet heard about in it? :)
22:05:06 <sorear> parBlend v list = let l' = drop (floor v - 1) list ; v' = v - floor v in ...
22:05:08 <Cale> (Have you had Calculus and Linear Algebra?)
22:05:32 <litb> Cale: yeah, it makes sense a bit :D
22:05:47 <litb> i have done deriverates in my study
22:06:06 <Cale> On http://mathworld.wolfram.com/CubicSpline.html you'll find the explicit matrix equation which you'll need to solve.
22:06:07 <lambdabot> Title: Cubic Spline -- from Wolfram MathWorld
22:06:56 <litb> Cale: but i never worked with matrices :)
22:07:03 <Cale> ah, okay
22:07:26 <litb> we did all our work with terms and formulars. eleminating veriables and transform the terms manually...
22:07:28 <Cale> So you'll probably want Gaussian elimination in order to solve that system
22:07:33 <Cale> oh, okay
22:08:18 <Cale> yeah, Gaussian elimination is sort of the same thing, only you're just writing down the coefficients of the equations, and there's a very rote way of solving things
22:09:17 <litb> Cale: yeah, i learned the "gaussian algorithm"
22:09:21 <sorear> rote is important.  Haskell is not a theorum prover.
22:09:35 <Cale> sorear: He's probably not writing it in Haskell
22:09:45 <Cale> In fact, I think I heard Java?
22:09:52 <litb> Cale: i'm writing in in c++ :O
22:09:55 <Cale> ah, okay
22:11:23 <ctkrohn> hey, I'm having trouble building the xhtml combinator library.  ghc says it can't find the module Distribution.Simple.  How would I go about getting it, or foinding the right location?
22:11:48 <Cale> litb: There's probably a decent implementation of Gaussian elimination for C++ in some library :)
22:11:52 <litb> so, i firstly has to find out a polynom which passes three points and then transform it in that the first derivate of this and the neighbour curve mathes at point 1 of the second curve and point 3 of the first curve?
22:11:58 <Cale> (I would probably expect boost to have one)
22:13:36 <Cale> Well, let's do it in one dimension at a time
22:13:39 <bd_> @hoogle getArgs
22:13:40 <lambdabot> System.getArgs :: IO [String]
22:14:05 <Cale> You can do it in two dimensions simply by doing this once with the x-coordinates, and once with the y-coordinates.
22:14:20 <goltrpoat> actually.. one of the first things i did when i started learning haskell was write a gauss-jordan solver
22:14:30 <goltrpoat> i can paste it if that'll help
22:14:32 <Cale> So you have some points y_0, y_1, ..., y_n
22:18:02 <Cale> goltrpoat: probably not, as he's a C++ programmer :)
22:18:03 <Cale> What you're going to do is work out some polynomials Y_i(t) = a_i + b_i t + c_i t^2 + d_i t^3, so that Y_i(0) = y_i, Y_i(1) = y_(i+1)
22:18:03 <Cale> But that's not all, you also want the first and second derivatives to match at the endpoints of each interval.
22:18:05 <Cale> stupid netsplits
22:18:31 <Cale> litb: bah, stupid netsplits. Are you following that?
22:19:32 <dons> today's tutorial: http://cgi.cse.unsw.edu.au/~dons/blog/2006/12/17#programming-haskell-part-2
22:19:38 <goltrpoat> looking at the gauss-jordan solver now, it's pivotless, so borderline useless anyway
22:19:39 <goltrpoat> hehe
22:19:54 <litb> Cale: yes. konvi saved that text :)
22:20:03 <Cale> litb: good :)
22:20:06 <lambdabot> Title: Haskell hacking, http://tinyurl.com/y852um
22:20:07 <sorear> ?bot
22:20:16 <dons> its actually not that hard to write 2500 words a day. hmm. maybe I should write this phd thesis ...
22:20:20 <lambdabot> :)
22:20:50 <pzpz> would a better method exist for marshalling a datatype other than deriving show and converting from a list?
22:21:11 <dons> using Binary, from the NewBinary library/
22:21:20 <Cale> http://programming.reddit.com/info/v34f/comments
22:21:21 <lambdabot> Title: Programming Haskell - Part 2 (reddit.com)
22:21:23 <dons> define: better?
22:21:30 <dons> chers, Cale.
22:21:51 <hyrax42> code compiled with profiling flags, but not run with profiling enabled: slower than otherwise?
22:22:10 <dons> yes
22:22:16 <hyrax42> :/
22:22:17 <hyrax42> ah well
22:22:32 <pzpz> dons: less ugly. for example:    data MyType = MyType { a :: Int32, B :: Int32 }
22:22:40 <hyrax42> I'll just leave profiling enabled for now, as full compile is annoyingly slow
22:22:52 <dons> and you want to marshall that to what, pzpz? nd for what purpose?
22:23:45 <pzpz> dons: in logical order so I can send it over a socket
22:23:52 <Cale> litb: but what I've said so far won't uniquely determine things - however, in order to get the thing to look smooth, we can add conditions that the first and second derivatives match up at the endpoints between adjacent pairs of polynomials, and finally, that the second derivatives are zero at the start of the first piece, and the end of the last
22:23:55 <dons> ah, maybe use Storable then?
22:24:02 <dons> or write your own Binary class?
22:24:37 <pzpz> dons: reading.
22:24:38 <Cale> litb: The MathWorld article shows how to solve those equations, and somewhat cleverly make it not a huge mess to solve :)
22:25:13 <litb> Cale: yeah, you explained it good :)
22:25:26 <litb> lets see if i can set up something working
22:25:28 <Cale> It turns the problem into one of solving for these D_i's, and shows how to get back to a_i, b_i, c_i and d_i from there.
22:27:26 <goltrpoat> it should probably be pointed out at this point that there's no real reason to know how to derive the coefficients if all you want to do is draw the spline :)
22:29:33 <dibblego> can you have a .lhs file that also renders somehow as HTML?
22:30:27 <sorear> dibblego: use LaTeX-style lhs ?
22:30:55 <sorear> \begin{code} foo bar baz \end{code} <p> This code does something very useful. </p>
22:32:49 <dibblego> hmm I guess
22:33:27 <dibblego> I thought I'd seen it done with Bird style before
22:34:14 <hyrax42> is there a comment character for cabal files?
22:34:39 <dibblego> only line comments iirc
22:34:46 <dibblego> -- comment
22:34:59 <hyrax42> isn't that a bad choice?
22:35:03 <jcreigh> dibblego: I think I've seen something of the form: <pre>\n > some\n > haskell\n > code here\n </pre> (But I don't that's valid HTML, because the >'s aren't escaped.)
22:35:07 <hyrax42> given that you give flags on there?
22:35:40 <hyrax42> yeah that isn't it
22:35:51 <hyrax42> ?where cabal
22:35:51 <lambdabot> http://www.haskell.org/cabal
22:35:55 <dibblego> hyrax42, other way around
22:36:04 <dibblego> block comments only
22:36:28 <hyrax42> hyrax42: actually it seems only full line -- comments
22:36:52 <hyrax42> I wanted to comment out some compiler flags
22:36:57 <hyrax42> ah well
22:37:02 <hyrax42> I'll just have two versions of the line then
22:37:04 <dibblego> ah that's it
22:38:40 <hyrax42> seems like this optimisation won't get me much :/
22:38:50 <hyrax42> well it makes things a deal faster, but not a deal faster enough
22:39:11 <ctkrohn> hey, has anyone successfully installed ghc 6.6 on macos panther who would be willing to help me out?
22:39:20 <dons> ctkrohn: pretty sure audreyt has
22:39:25 <dons> there's a wiki page on it on haskell.org/ghc
22:39:31 <dons> search for 'macosx' or something like that
22:39:33 <ctkrohn> hm, let me check it out
22:39:34 <dibblego> ?hoogle FilePath -> IO Bool
22:39:35 <lambdabot> Directory.doesDirectoryExist :: FilePath -> IO Bool
22:39:35 <lambdabot> Directory.doesFileExist :: FilePath -> IO Bool
22:39:48 <dibblego> wtf is doesFileExist in Directory?
22:40:16 <dons> some file thing live in there. ah well
22:40:29 <dibblego> I looked everywhere but there first is all
22:40:30 <ctkrohn> dons: thanks... I'm having some compilation errors so I'll see what I can figure out
22:40:53 <dons> i'm thinking thinking its alst time for a nice abstract file system traversal library
22:41:06 <dons> so i can just map over a file system, as if it wsa a haskell tree type
22:41:11 <dons> (or graph)
22:41:21 <hyrax42> alst?
22:41:24 <hyrax42> also?
22:41:25 <dibblego> wouldn't that be awesome
22:41:37 <hyrax42> and that would be brilliant
22:42:32 <dons> mmm. so maybe in IO or something close to it (A FS monad?)
22:42:42 <dibblego> yes a FS monad
22:43:00 <dibblego> I was having a similar conversation today with Slava Pestov
22:43:17 <hyrax42> I missed seeing him a couple weeks ago :/
22:43:24 <hyrax42> or month
22:43:32 <hyrax42> talkign about factor... would have been interesting
22:43:32 <dibblego> he was here?
22:43:37 <hyrax42> here = montreal
22:43:42 <dibblego> oh right
22:43:48 <hyrax42> he talked at mslug
22:43:58 <hyrax42> scheme/lisp user group
22:44:26 <dibblego> him and I have a point of disagreement that we have had for years
22:44:41 <hyrax42> you know him personally?
22:44:43 <dibblego> no, just IRC
22:44:55 <hyrax42> what is his handle
22:44:59 <hyrax42> of curiosity
22:45:00 <dibblego> slava
22:45:22 <sorear> dons: have you seen HVFS (from MissinH IIRC)
22:46:06 <Excedrin> what's the disagreement?
22:46:34 <dons> sorear: hmm. no.
22:46:39 <dons> we should break up MissingH!
22:46:42 <dibblego> that the property of referential transparency is inherent in the definition of software held by the entire world
22:47:07 <dons> too much fun stuff in there
22:47:17 <dibblego> also, on typing
22:47:59 <hyrax42> ?hoogle Bool -> Bool -> Bool
22:48:00 <lambdabot> Prelude.(&&) :: Bool -> Bool -> Bool
22:48:00 <lambdabot> Prelude.(||) :: Bool -> Bool -> Bool
22:48:11 <hyrax42> no xor :/
22:48:16 <hyrax42> or nor rather
22:49:18 <xpika> > True || False
22:49:19 <lambdabot>  True
22:49:40 <dibblego> Disjunctive Amplification
22:51:23 <dons> :t not.or
22:51:24 <lambdabot> [Bool] -> Bool
22:51:32 <dons> heh
22:53:20 <goltrpoat> > let xor x y = if x then not y else y in map (uncurry xor) [(a,b) | a <- [True, False], b <- [True, False]]
22:53:22 <lambdabot>  [False,True,True,False]
22:56:50 <dons> ?remember DavidRoundy ... the fun of haskell-cafe is that it's where all the cool people hang out
22:58:42 <lisppaste2> dibblego pasted "What am I doing wrong with the type check?" at http://paste.lisp.org/display/32668
22:59:16 <goltrpoat> im getting really good at writing down haskell code and then realizing five minutes later than it's about twice as long as it should be
22:59:32 <dons> heh
22:59:35 <dons> same here
22:59:44 <magnus-> Hi... how come I can't import Control.Monad.Writer?
22:59:50 <dons> refactoring down to one line is 50% of the development cost ;)
22:59:55 <goltrpoat> hehe
22:59:59 <dons> magnus-: are you compiling with --make ?
23:00:09 <magnus-> dons: I am using ghci 6.6
23:00:18 <dons> yes good. and with the --make flag?
23:00:28 <dons> do you also have the 'mtl' library installed?
23:00:37 <dons> (its in the extra-libs library bundle now)
23:00:37 <magnus-> Not with --make flag
23:01:18 <magnus-> ghci doesn't accept --make
23:01:25 <magnus-> I'll install mtl
23:01:49 <dons> you need it. that's where Control.Monad.Writer lives :)
23:02:38 <magnus-> then it'll probably work after I get it :)
23:04:51 <deadbeef> http://video.google.it/videoplay?docid=-247678787152630030
23:04:54 <lambdabot> Title: Kristina - Google Video
23:09:49 <goltrpoat> i like how when you hit alt-d in a mediawiki, it tries to delete the page
23:10:02 <goltrpoat> when it's the shortcut to the url bar in both ie and firefox
23:12:05 <Cale> deadbeef: what does that have to do with Haskell?
23:12:15 <deadbeef> it has, trust me
23:13:38 <Cale> Please remain at least approximately on topic here.
23:16:33 <lisppaste2> boulez annotated #32657 with "(none)" at http://paste.lisp.org/display/32657#1
23:17:32 <dibblego> ?type existWith
23:17:34 <lambdabot> Not in scope: `existWith'
23:17:34 <dibblego> ?type exitWith
23:17:36 <lambdabot> Not in scope: `exitWith'
23:18:10 <dons> ?hoogle exitWith
23:18:11 <lambdabot> System.exitWith :: ExitCode -> IO a
23:18:18 <dibblego> ah thanks
23:21:31 <pzpz> What's the deal with hidden modules? (Binary)
23:28:00 <pzpz> http://hackage.haskell.org/trac/haskell-prime/wiki/BinaryIO
23:28:02 <lambdabot> Title: BinaryIO - Haskell Prime - Trac
23:33:53 <dons> ?users
23:33:54 <lambdabot> Maximum users seen in #haskell: 291, currently: 242 (83.2%), active: 25 (10.3%)
23:40:55 <hyrax42> ?index mkstemp
23:40:56 <lambdabot> System.Posix.Temp, System.Posix
23:41:07 <hyrax42> ?docs System.Posix
23:41:07 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/unix/System-Posix.html
23:42:42 <dons> i was sure there was a portable System.Temp or some such, but I couldn't find it
23:42:46 <dons> maybe I was dreaming
23:44:09 <pzpz> http://www.patentstorm.us/patents/7028023.html
23:44:12 <lambdabot> Title: Linked list - US Patent 7028023
23:44:45 <mwc> oh good, haskell wraps mkstemp
23:45:05 <mwc> though as far as I know the vulnerability in mktemp is more theoretical than practical
23:45:31 <dons> i've written a portable reimplementation of mkstemp* as well, if you ever need it on windows
23:45:37 <dons> just a translation of the original C source
23:57:18 <dibblego> someone in ##java bet me USD50 that a 32 bit type can hold only 2^32-1 representations!
23:57:23 <dibblego> yippeee!!
23:58:17 <dibblego> <whats_in_a_name> if i go to #math, and ask someone like cale
23:58:18 <dibblego> whats_in_a_name> will it be settled?
23:58:47 <Cale> heh
23:59:03 <dibblego> whats_in_a_name> its 2^32, and i knew that, i just realized i was saying representations when i meant max value
23:59:42 <bd_> ?where unix tools
23:59:43 <lambdabot> I know nothing about unix.
23:59:46 <bd_> ?where unixtools
23:59:47 <lambdabot> I know nothing about unixtools.
23:59:58 <dons> bd_?
