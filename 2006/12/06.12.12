00:00:16 <ski> hm .. some of these problems need to be adapted, i think
00:00:32 <base_16> ski: well, you post one of yours for 15 :)
00:01:24 <Excedrin> http://paste.lisp.org/display/32113
00:01:28 <Excedrin> reasonable?
00:01:34 <ski> what are we optimizing for ? simple-mindedness ? conciseness ? efficiency ? abstractness ?
00:01:48 * base_16 shrugs
00:02:01 <dons> ski, beauty
00:02:07 <dons> idiomacy (sp?)
00:02:25 <dons> multiple solutions should be fine
00:02:26 <ski> @spell idiomacy
00:02:28 <lambdabot> idioms idiocy idiom's idiom intimacy
00:02:31 <sjanssen> optimize for idiocy
00:02:46 <dons> i think I just made up a new word :)
00:02:58 <sjanssen> idiomaticness?
00:03:08 <ski> @spell idiomatic
00:03:08 <lambdabot> idiomatic
00:03:16 <dons> "having the property of being idiomatic"
00:03:56 <sjanssen> they should be solved idiomatically
00:05:26 <chessguy> i liked dons' word "canonical"
00:07:30 <syntaxfree> http://syntaxfree.wordpress.com/2006/12/12/do-notation-considered-harmful/
00:07:36 <lambdabot> Title: Do-notation considered harmful Â« Data.Syntaxfree, http://tinyurl.com/tlmrl
00:07:50 <syntaxfree> now I lay me down to sleep.
00:07:58 <base_16> yeah, it sems like haskell makes some of these way too easy
00:08:09 <base_16> since there are functions to do exactly what they ask for
00:08:23 <sjanssen> haskell++
00:08:28 <dons> :)
00:08:41 <kzm> What's these 99 listp things.  Am I supposed to fill them in?
00:08:45 <base_16> well, it might be good to reimplement those functions is what i'm saying, i'm guess
00:08:50 <base_16> *i guess
00:08:50 <chessguy> there's actually only 25 of these that have been solved in lisp
00:08:59 <base_16> or at least provide both
00:09:24 <kzm> Are there any that aren't already in the Prelude?  And/or non-trivial?
00:09:44 <chessguy> there are plenty that are non-trivial
00:10:20 <chessguy> some of the ones at the end are quite hard
00:10:38 <dons> Haskell Weekly News is out! http://programming.reddit.com/info/ujip/details
00:10:40 <lambdabot> Title: Haskell Weekly News: new libraries for ogg, ftp, logs, gui, databases (reddit.co ...
00:10:52 <dons> very busy week! great work everyone :)
00:11:17 <base_16> wow
00:13:58 <kzm> chessguy, hmm.. I did #9 (reimplement group)
00:14:07 <dons> kzm++ thanks!
00:14:16 <notsmack> dons: i believe the z-machine announcement link is wrong?
00:14:25 <chessguy> cool
00:15:05 <shoffsta> problems 16, 17 and 18 are done
00:15:19 <dons> notsmack++ thanks
00:16:42 <chessguy> ok, i think the scoreboard's up to date
00:17:32 <chessguy> i think once we have solutions for all of them, i'm going to make it my personal mission to either break and fix, or improve every entry :)
00:17:43 <base_16> chessguy: where's the scoreboard?
00:17:54 <chessguy> http://haskell.org/haskellwiki/99_Haskell_exercise
00:17:55 <lambdabot> Title: 99 Haskell exercise - HaskellWiki
00:17:59 <dons> notsmack: fixed.
00:18:08 <notsmack> :)
00:18:19 <Excedrin> 20 too
00:18:41 <base_16> chessguy: why is there one for exercise and one for exercises?
00:18:43 <chessguy> do me a favor, as you finish a problem, update the scoreboard too
00:19:14 <chessguy> base_16, hmm. typo somewhere
00:19:30 <chessguy> dons, how do i delete a page?
00:19:32 <dons> the scoreboard should go on a subpage
00:19:35 <dons> chessguy: you can't :)
00:19:40 <dons> just don't refer to it gain
00:19:43 <dons> again
00:20:04 <kzm> done #10
00:20:19 <chessguy> ugh, the link in haskell-cafe is the wrong one
00:20:36 <dons> in HWN?
00:20:50 <chessguy> the one i sent to the haskell-cafe mailing list
00:20:53 <dons> ah ok
00:21:01 <chessguy> kzm, did you update the scoreboard?
00:21:12 <kzm> no
00:21:17 <dons> could people mod this up, http://programming.reddit.com/info/ujip/details
00:21:18 <lambdabot> Title: Haskell Weekly News: new libraries for ogg, ftp, logs, gui, databases (reddit.co ...
00:21:21 <kzm> I can do it, though.
00:21:28 <dons> its an exciting week, so i don't like to see the news report go down
00:21:29 <chessguy> kzm, thanks
00:22:57 <chessguy> i think i'll just copy/paste the code from exercise to exercises
00:23:02 <ski> 15
00:23:04 <dons> huh, i see mklink has already read the weekly news, and started harvesting its blog entries into reddit
00:23:14 <dons> i.e. http://programming.reddit.com/info/ujje/comments <--
00:23:15 <lambdabot> Title: 99 Haskell exercises - These are Haskell translations of Ninety Nine Lisp Proble ...
00:23:38 <dons> chessguy: so now expect to see 2000 hits in the next couple of hours...
00:24:19 <chessguy> heh. seriously?
00:24:21 <dons> is there a link to the scoreboard on the 99_Haskell_exercises page now?
00:24:36 <dons> chessguy: yeah, at least if mklink was smart and submitted it to the reddit front pgae too
00:24:39 <chessguy> yes, we should youse exercises exclusively now
00:24:41 <dons> (in which case you might get up to 10k)
00:24:51 <base_16> dons: no link, it just shows up in the page
00:25:09 <chessguy> oh, yes, it's just on that front page
00:25:14 <chessguy> below the links
00:25:37 <dons> its funny watching mklink harvesting links out of HWN for submitting
00:25:58 <dons> basically, he's gaining reddit karma by reusing my rss feed skillz ;)
00:26:00 <dons> ah well
00:27:27 <dons> ok, so at 7.20 pm, there's 132 hits on that page
00:27:32 <dons> let's see what that's like in 12 hours
00:27:36 <chessguy> hehe
00:27:48 * chessguy does a bunch of refreshes :)
00:28:09 <dons> heh
00:29:46 <dons> now mklink's submitted 5 haskell stories in 5 minutes. i wonder where he got those links from
00:30:35 <chessguy> can't imagine
00:32:19 <chessguy> @quote emu
00:32:20 <lambdabot>  design patterns are what you choose for wallpaper and carpets
00:32:24 <chessguy> i like that one :)
00:32:33 <Svrog> haha
00:33:21 <dons> ?users
00:33:21 <lambdabot> Maximum users seen in #haskell: 288, currently: 249 (86.5%), active: 28 (11.2%)
00:34:22 <chessguy> dons, how can you see the number of hits on a page?
00:35:06 <dons> ?wiki Special:Popularpages
00:35:06 <lambdabot> http://www.haskell.org/haskellwiki/Special:Popularpages
00:36:42 * dons `on` home
00:37:01 <chessguy> hmm?
00:40:49 <chessguy> @pl \x y -> [x..y]
00:40:50 <lambdabot> enumFromTo
00:41:04 <chessguy> @type enumFromTo
00:41:05 <lambdabot> forall a. (Enum a) => a -> a -> [a]
00:41:15 <chessguy> terrible name
00:41:33 <notsmack> any reason not to make problem 10 pointfree?
00:42:23 <chessguy> @pl map \x -> (length x,head x) (group xs)
00:42:23 <lambdabot> (line 1, column 5):
00:42:24 <lambdabot> unexpected "\\"
00:42:24 <lambdabot> expecting variable, "(", operator or end of input
00:42:46 <chessguy> @pl \x -> (length x,head x) (group xs)
00:42:46 <lambdabot> flip (liftM2 (,) length head) (group xs)
00:42:55 <chessguy> mmm, that's pretty ugly
00:43:03 <Svrog> i think it's pretty cool
00:43:04 <notsmack> encode = map (\x -> (length x, head x)) . group  -- ?
00:43:30 <chessguy> oh, you just mean to remove the xs
00:43:43 <notsmack> am i using that word wrong?
00:44:02 <chessguy> no, you're just removing a different point than i expected :)
00:44:11 <chessguy> that should be fine, as long as it works
00:44:44 <ski> done problem 26, using list monad
00:45:14 <notsmack> > let p10 = map (\x -> (length x, head x)) . group in p10 ["aaaabca"]
00:45:16 <lambdabot>  [(1,"aaaabca")]
00:45:21 <notsmack> oop
00:45:25 <notsmack> > let p10 = map (\x -> (length x, head x)) . group in p10 "aaaabca"
00:45:27 <lambdabot>  [(4,'a'),(1,'b'),(1,'c'),(1,'a')]
00:45:50 <Svrog> yeah - you're kinda making it half-pointfree as you still have the \x :) - although the other one still has xs so same thing - flip (liftM2 (,) length head) . group would be completely pointfree
00:46:11 <notsmack> Svrog: ahh
00:46:27 <chessguy> ski, could you add a little more detail to your implementation explanation? remember, this is a demonstration for non-haskellers who have probably never seen list comprehension
00:46:42 <ski> @type length (Control.Arrow.&&&) head
00:46:44 <lambdabot>   The function `length' is applied to two arguments,
00:46:44 <lambdabot>   but its type `[a] -> Int' has only one
00:46:59 <ski> @type length Control.Arrow.(&&&) head
00:47:01 <lambdabot> Couldn't find qualified module.
00:47:04 <ski> er
00:47:08 <ski> @type length Control.Arrow.&&& head
00:47:09 <lambdabot> forall a. [a] -> (Int, a)
00:47:30 <Svrog> oops - actually that was missing a map so it's still wrong haha - but getting closer
00:47:33 <ski> chessguy : sure .. just don't know level of detail expected
00:48:05 <chessguy> Svrog, for the same reason as what i just said to ski, i'd rather not use liftM2 in these
00:48:28 <chessguy> nobody who hasn't programmed in haskell is gonna have a clue what that is
00:49:01 <Svrog> thats understandable - introductory totorials shouldn't really have that stuff
00:49:17 <chessguy> right, and we want this to be at that level
00:49:36 <Svrog> yes - im just saying i dont think the pointfree version looks ugly
00:50:28 <Svrog> i think it's pretty cool and not in an obfuscated sort of way - i think it's quite readable once you get used to code like that
00:51:53 <Itkovian> dons: excellent HWN compilation this week.
00:51:57 <chessguy> obfuscation is in the eye of the coder
00:51:58 <chessguy> :)
00:52:10 <chessguy> Itkovian, hear, hear
00:53:51 <Svrog> i dont know about that - unusual/uncommon syntax always looks obfuscated until you get used to it
00:55:32 <chessguy> err, yeah, i should've kept it as "obfuscation is in the eye of the beholder"
00:56:12 <notsmack> or in the eye of the maintainer
00:56:39 <chessguy> there ya go
00:58:15 <Svrog> well there is a difference between code that is badly written and code that is just written using uncommon syntax - its really no different to writing programs in a non-mainstream language that most people are not familiar with
00:59:43 <Svrog> pointfree haskell is almost like a completely different language from normal haskell
00:59:48 <Svrog> only not :)
01:00:41 <ski> chessguy : is that better (26) ?
01:03:26 <chessguy> ski, somewhat
01:04:43 <ski> how could it be improved ?
01:05:08 <chessguy> i'm not sure. i'll have to look at it when it's not 4 in the morning to tell that :)
01:05:42 <ski> ok
01:06:01 <chessguy> i'm probably gonna go back through all these and try to improve them myself anyway
01:08:28 <chessguy> but a solution is a solution!
01:08:32 * chessguy updates the scoreboard
01:08:52 <ski> m
01:09:34 <ski> @type foldM
01:09:35 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
01:11:04 <ski> @let foldrM cons nil [] = nil; foldrM cons nil (a:as) = cons a =<< foldrM cons nil as
01:11:05 <lambdabot> Defined.
01:11:10 <ski> @type L.foldrM
01:11:11 <lambdabot> Couldn't find qualified module.
01:11:20 <ski> @type foldrM
01:11:21 <lambdabot> Not in scope: `foldrM'
01:11:41 <ski> @type let foldrM cons nil [] = nil; foldrM cons nil (a:as) = cons a =<< foldrM cons nil as in foldrM
01:11:43 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m b) -> m b -> [a] -> m b
01:14:18 <ski> hm
01:14:45 <Svrog> would anyone know if there are any functional shading languages?
01:15:04 <Svrog> or rather shading languages with syntax more like haskell or scheme or something like that
01:22:09 <ski> @let unfoldrM step s = step s >>= maybe (return []) (\(a,s) -> (a:) `liftM` unfoldrM step s)
01:22:10 <lambdabot> Defined.
01:23:33 <ski> > let combinations = curry $ L.unfoldrM (\(n,as) -> if n <= 0 then return Nothing else do a:as <- tails as; return $ Just (a,(n-1,as))) in combinations 3 "abcde"
01:23:35 <lambdabot>  ["abc","abd","abe","acd","ace","ade","bcd","bce","bde","cde"]
01:25:43 <ski> 'unfoldr' always looks slightly ugly :/
01:44:38 <bringert> where is the hdbc oracle package?
01:51:35 <bringert> hmm, maybe there isn't one
01:55:12 <dons> Itkovian: thanks!
02:07:36 <dons> ?users
02:07:36 <lambdabot> Maximum users seen in #haskell: 288, currently: 256 (88.9%), active: 32 (12.5%)
02:09:07 * amiddelk bumps the active-counter by just saying hi
02:09:14 * Vq^ too
02:09:42 * cameron waves.
02:10:01 <genneth> world domination can't be that far now...
02:10:39 <dons> hehe
02:10:55 <dons> ?users
02:10:55 <lambdabot> Maximum users seen in #haskell: 288, currently: 256 (88.9%), active: 35 (13.7%)
02:10:56 <cameron> genneth: actually we already have it, but you don't know yet ;-)
02:22:45 <therp> dons: I suspect you put my "beauty of haskell" blog into programming.reddit.com, right? :)
02:24:53 <Saulzar_> Hmm, trying to use c2hs .. I have my Functions.chs and Functions.h, I run c2hs Functions.chs and it overwrites Functions.h with one line #include "Functions.h", and spits a preprocessor error that includes are nested too deeply...
02:26:27 <therp> ah sorry, reddit.com actually says who posted the link..
02:26:30 <Saulzar_> I don't know why it would be writing to Functions.h to begin with
02:26:41 <Masklinn> Hello everybody
02:27:46 <Saulzar_> Hi.
02:28:26 <Vq^> hello Masklinn
02:36:24 <kzm> http://www.linux.com/article.pl?sid=06/12/08/1655211 -- sounds like Mozilla needs darcs :-)
02:36:26 <lambdabot> Title: Linux.com | Mozilla commits to collaborating with Linux distros
02:48:12 <Masklinn> ooh, lambdabot has revived?
02:48:56 <dons> yeah, just a server reboot on freenode or something, kciked it
02:49:22 <profmakx> @version
02:49:22 <lambdabot> lambdabot 4p302, GHC 6.5 (OpenBSD i386)
02:49:22 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
02:54:01 <shankys> I was wondering if someone could take a look at a function I wrote and give me suggestions on refactoring. The function works just fine, but I think it could be refactored to look better using a case statement -- I'm not sure what the most concise way to write it would be. I'm trying to improve my Haskell style.
02:54:03 <shankys> ?paste
02:54:03 <lambdabot> http://paste.lisp.org/new/haskell
02:54:21 <lisppaste2> shankys pasted "Refactor?" at http://paste.lisp.org/display/32128
02:56:33 <dons> looking...
02:56:43 <mq_mattr> for....
02:59:03 <pejo> shankys, is the first "Your passwords don't match" the right text?
02:59:18 <shankys> pejo: Yeah it is.
02:59:49 <shankys> pejo: It only get to that if the user has filled out the first password field but hasn't filled out the confirm password field.
03:00:58 <shankys> *gets
03:01:09 <pejo> shankys, so you do want different messages for validate_exists p and validate_exists p'?
03:02:01 <shankys> pefjo: Yeah, I think so.
03:02:03 <pejo> (If they haven't filled in the second field, but did fill in the first one the passwords don't match).
03:02:08 <lisppaste2> dons annotated #32128 with "Refactor!" at http://paste.lisp.org/display/32128#1
03:02:25 <dons> shankys: ^^
03:02:56 <shankys> dons: Oh, nice. I hadn't thought about using "case () of"
03:04:07 <shankys> dons: What is the underscore after the first "{" near "case () of" for?
03:04:28 <dons> that's the match variable, :) everything else is the guard
03:04:35 <dons> > case () of _ | True -> 1
03:04:36 <lambdabot>  1
03:04:45 <dons> > case () of _ -> 1
03:04:46 <lambdabot>  1
03:05:14 <Masklinn> dons, are the {} required?
03:05:23 <dons> mmm, possibly not
03:05:27 <shankys> That's exactly the next thing I was going to ask...
03:05:34 <Masklinn> beat ya :)
03:05:35 <mq_mattr> ? how do I build you?
03:05:46 <Masklinn> you can't build dons
03:05:49 <mq_mattr> lambdabot?
03:05:51 <Masklinn> only lambdabot can build dons
03:05:51 <mq_mattr> ?
03:06:00 <dons> mq_mattr: you're using ghc 6.6?
03:06:07 <mq_mattr> yep
03:06:07 <dons> or 6.4.2?
03:06:16 <mq_mattr> 6.6
03:06:18 <mq_mattr> on mac
03:06:29 <dons> 6.6, easy. mv lambdabot.cabal.ghc-6.6 to lambdabot.cabal
03:06:32 <dons> then run ./build
03:06:42 <mq_mattr> aha!
03:06:45 <dons> _dont_ install fps (its in base now)
03:06:59 <mq_mattr> yeah - I made that mistake this morning :)
03:07:06 <dons> ah ok
03:07:41 <mq_mattr> ok - we made it past the fps dependecy error.....
03:07:47 <mq_mattr> compiling..
03:07:50 <dons> good
03:07:59 <dons> lets hope you have the extra libs
03:08:00 <dons> mtl and so on
03:08:46 <mq_mattr> mtl?
03:09:15 <malebria> God morning.
03:09:21 <mq_mattr> configure: Dependency mtl-any: using mtl-1.0
03:09:27 <mq_mattr> is that good?
03:09:30 <Masklinn> yeah
03:09:36 <mq_mattr> yay!
03:09:42 <Masklinn> as long as it doesn't err and tell you that a lib is missing, you're good
03:10:00 <mq_mattr> 25 of 94
03:10:04 <Masklinn> you'll notice if it's no good, because the build will suddenly stop
03:10:06 <mq_mattr> go little 'puter, go!!!!
03:10:30 <kfish> i think i can, i think i can
03:10:35 <kfish> i prove i can, i prove i can
03:10:40 <mq_mattr> it is a bit like that with this box
03:10:56 <scriptdevil>  Prelude.read: no parse
03:11:02 <scriptdevil> what the devil does that mean?
03:11:10 <kfish> and then the little 'puter proved it's way to the top of the hill
03:11:13 <Masklinn> either that you've given it something it can't convert to a Num instance
03:11:19 <dons> mq_mattr: ok, you need the extra-libs library bundle
03:11:20 <scriptdevil> i gave 12
03:11:24 <scriptdevil> 12 is num
03:11:26 <Masklinn> or that it can't determine the type of Num you want
03:11:33 <Masklinn> > read "12"
03:11:34 <lambdabot>  Add a type signature
03:11:39 <dons> (a bunch of extra, standard lis don't come with ghc on its own now, you grab them from haskell.org/ghc
03:11:41 <Masklinn> > read 12
03:11:42 <lambdabot>  add an instance declaration for (Num String)
03:11:43 <dons> or maybe in your package system
03:11:54 <Masklinn> > (read "12") :: Int
03:11:56 <lambdabot>  12
03:12:00 <dons> > read "foo" :: Int
03:12:01 <lambdabot>  Exception: Prelude.read: no parse
03:12:55 <Masklinn> > read "12foo" :: Int
03:12:56 <lambdabot>  Exception: Prelude.read: no parse
03:13:06 <mq_mattr> dons: so this compile will die at some point, and that is my problem?
03:13:21 <mq_mattr> 'cos I have made it to Hoogle now
03:13:26 <Masklinn> your compile *may* die at some point
03:14:47 <scriptdevil>  so do i have to enter "12" or "14"??
03:15:09 <Masklinn> what do you mean?
03:15:32 <Masklinn> read can only parse num-as-string, and you need to give him an output type (unless the context allows Haskell to infer it)
03:15:50 <scriptdevil> Masklinn: do you have yaht handy??
03:16:18 <Masklinn> yeah
03:16:34 <scriptdevil> page 34'
03:16:48 <scriptdevil> or 44( if u use acrobat reader
03:16:50 <dons> mq_mattr: sounds good if you've made it to hoogle...
03:16:56 <dons> since that means lambdabot's already built
03:17:14 <scriptdevil> "Guess.hs"
03:17:42 <Masklinn> I don't use Reader, and my guess.hs is on page 43 ;)
03:17:48 <scriptdevil> ok
03:18:02 <Masklinn> what do you need
03:18:07 <scriptdevil> now... i did the same program
03:18:13 <scriptdevil> and it says no parse
03:18:47 <Masklinn> when you run it?
03:18:53 <scriptdevil> yeah
03:18:58 <scriptdevil> after compiling with ghc
03:19:01 <Masklinn> did you give it something like "foo"?
03:19:07 <scriptdevil> no
03:19:10 <scriptdevil> i gave it like 12
03:19:12 <scriptdevil> 15
03:19:14 <scriptdevil> etc
03:19:20 <Masklinn> that's extremely bizarre
03:19:47 <shapr> sjanssen: Yeah, wiki.hs is the whole thing... that repo will be a HAppS tutorial at some point.
03:20:05 <scriptdevil> [scriptdevil@Hell HaskellDevil]$ ./RandomGame
03:20:06 <scriptdevil> Guess a number between 1 and 100
03:20:06 <scriptdevil> Enter your Guess
03:20:16 <scriptdevil> 1
03:20:17 <scriptdevil> 1
03:20:17 <scriptdevil> RandomGame: Prelude.read: no parse
03:20:22 <scriptdevil> i mean only 1 1
03:20:26 <scriptdevil> not twice
03:20:28 <dons> ?paste please :)
03:20:29 <lambdabot> http://paste.lisp.org/new/haskell
03:20:41 * dons gueses you're reading the wrong type , perhaps
03:20:47 <Masklinn> there must be an error in your code, because it works here
03:20:55 <Masklinn> could you paste your code in paste?
03:20:56 <Masklinn> all of it
03:21:24 <lisppaste2> ScriptDevil pasted "no parse??" at http://paste.lisp.org/display/32130
03:21:30 <scriptdevil> yeah
03:21:37 <scriptdevil> :D
03:21:46 <scriptdevil> nice bots
03:21:48 <kfish> hmm, guess.hs builds and runs ok here
03:22:09 <scriptdevil> kfish: u mean mine?
03:23:10 <Masklinn> oh lord
03:23:21 <Masklinn> scriptdevil, line 12
03:23:24 <scriptdevil> another thing i dislike is emacs' haskell mode indentation.. kills me
03:23:51 <Masklinn> you're comparing the string you got from getLine with what you try to parse from it
03:23:51 <scriptdevil>  Masklinn u mean main.do?
03:23:57 <scriptdevil> ok
03:24:01 <Masklinn> line 18 sorry
03:24:02 <Masklinn> not 12
03:24:11 <Masklinn> should be "guessNum > num"
03:24:20 <scriptdevil> oh bad.. thanks
03:24:27 <Masklinn> because here you have guess::String
03:24:33 <Masklinn> so read loses its head
03:24:42 <Masklinn> don't forget to change line 21 too
03:24:48 <scriptdevil> i am damned
03:24:53 <Masklinn> the error message sucks though
03:24:57 <scriptdevil> yeah
03:25:05 <scriptdevil> the lang rocks though
03:25:33 <Masklinn> lang?
03:25:51 <scriptdevil> language
03:25:52 <dons> Masklinn: he means haskell :)
03:25:55 <Masklinn> oh
03:26:19 <scriptdevil> a wlcome break from c++ they are boring me with at college
03:26:24 <scriptdevil> *wel
03:26:24 <Masklinn> well I disagree, I think haskell sucks and i'm only using it to hurt myself :D
03:26:44 <scriptdevil> Masklinn: i love making my head hurt
03:27:25 <kfish> Masklinn, after your broken tendons reheal you'll be a better ninja
03:27:44 <scriptdevil> one more thing.. which editor is better?? emacs indenting sucks
03:27:54 <scriptdevil> haskell-mode
03:27:54 <Masklinn> ? I like emacs' indenting
03:28:09 <scriptdevil> Masklinn: it indents too much
03:28:10 <Masklinn> plus you just tab to cycle through the various positions
03:28:26 <Masklinn> you may have the wrong indenting settings
03:28:32 <scriptdevil> Masklinn: i may
03:28:54 <scriptdevil> but it works well in ocaml-mode and cc-mode
03:29:23 <lisppaste2> dons annotated #32130 with "refactor" at http://paste.lisp.org/display/32130#1
03:29:34 <dons> scriptdevil: ^^
03:29:43 <Masklinn> lol
03:30:40 <Masklinn> anyway scriptdevil, have you tried tabbing several times, or reindenting after you've written stuff?
03:30:46 <Masklinn> emacs really does't indent that much for me
03:31:05 <scriptdevil> like emacs indented my line 12 to almost near stdin
03:31:14 <scriptdevil> i used spaces finally
03:31:39 <Masklinn> what's your line 12?
03:31:50 <Masklinn> (and where's your stdin)
03:31:56 <scriptdevil> in my code
03:32:04 <scriptdevil> http://paste.lisp.org/display/32130
03:32:15 <Masklinn> yeah but it's an empty line for me
03:32:19 <Masklinn> between the let and the read
03:32:52 <scriptdevil> hey.... use line numbers in the paste site line number 14
03:33:29 <Masklinn> ah I didn't have line numbers on paste
03:34:10 <scriptdevil> ok... oh.. it does indent well.. my indent key was stuck
03:34:15 <scriptdevil> tab key
03:34:16 <Masklinn> ok, go to line 13, then return to create a next line, then you can cycle between the indentation levels
03:34:28 <Masklinn> just tab twice, and you'll get where the next line should be ;)
03:34:43 <scriptdevil> my foot... kill my key board... it had a stuck indent key...
03:34:48 <scriptdevil> no wonder i couldnt cycle
03:34:49 <Masklinn> lol
03:35:10 <scriptdevil> why does everything go wrong when you learn a new language??
03:35:16 <scriptdevil> but that is what i love..
03:35:23 <Masklinn> So that you won't be surprise when it goes wrong later
03:35:23 <scriptdevil> << geeky :P
03:35:26 <Masklinn> because it will :D
03:35:33 <Masklinn> s/surprise/surprised/
03:35:34 <scriptdevil> Masklinn: goo thing
03:35:43 <scriptdevil> *good
03:35:55 <dons> scriptdevil: did you see my annotation
03:36:00 <dons> cleans up a few things (i.e. use compare)
03:36:05 <scriptdevil> dons: i did
03:36:16 <scriptdevil> but yaht hasnt introduced compare yet
03:36:23 <scriptdevil> anyway.. thanks
03:36:27 <scriptdevil> neater too
03:36:46 <scriptdevil> are GT and LT like True and False??
03:37:26 <scriptdevil> i guess they are
03:38:34 <dons> GT, LT, EQ
03:38:42 <dons> > [LT..]
03:38:42 <lambdabot>  Parse error
03:38:48 <dons> > [LT ..]
03:38:49 <lambdabot>  [LT,EQ,GT]
03:39:10 <dons> (rather than -1, 0 , 1 .... ;)
03:39:30 <scriptdevil> :D
03:39:37 <kzm> Oh my god.  It's real.  "Exercises, 2.5 Show that the number of ways of intercalating two sequences..."
03:39:51 <kzm> There actually is such a word, after all. :-)
03:40:43 <Masklinn> data  Ordering  =  LT | EQ | GT
03:40:43 <Masklinn> data  Ordering  =  LT | EQ | GT deriving (Eq, Ord, Enum, Read, Show, Bounded)
03:40:52 <Masklinn> dammit, the prelude's beautiful
03:40:58 <Masklinn> it's not even funny
03:41:19 <dons> :)
03:41:40 <dons> > LT `compare` GT
03:41:41 <lambdabot>  LT
03:41:46 <dons> mmm interesting
03:41:59 <Masklinn> stop it, you're going to make my brain hurt even more
03:42:55 * jlouis presents hammer to Masklinn 
03:43:09 * Masklinn repeatedly hammers himself on the head
03:43:16 <Masklinn> ok dons, now you can go on
03:43:30 <dons> well, its interesting that Ordering derives Ord, no?
03:44:24 <Masklinn> I guess it is, but I don't quite get why you'd do it
03:44:24 <earthy> the ordering is present in the order in which the constructors are given
03:44:30 <ms_> plain weird
03:44:39 <earthy> it's an enumerated type
03:44:46 <dons> earthy: yeah :) The declared order
03:44:46 <dons> -- of the constructors in the data declaration determines the ordering
03:44:46 <dons> -- in derived 'Ord' instances.
03:44:58 <ms_> data Ordering = GT | LT | EQ  deriving (Eq, Ord, Enum, Read, Show, Bounded)
03:45:05 <earthy> why wouldn't you want 'Ord' on an enumerated type?
03:45:05 <ms_> how much would that break?
03:45:12 <earthy> ms_: not much, I'd wager
03:46:05 <ms_> it seems "weak" in some way for the semantics of comparators to be at least partially defined by the order of declaration
03:46:57 * ms_ has probably been writing too much epigram lately...
03:56:41 * shapr gives in and posts his long reply to http://warp9point99.blogspot.com/
03:56:42 <lambdabot> Title: warp 9.99!
03:59:22 <mq_mattr> if I want to use lambdbot (local version) to run just one command and then exit, can I do it?
03:59:38 <mq_mattr> like `> lambdabot hoogle id
03:59:56 <mq_mattr> instead of starting it, running the command and then exiting
04:00:07 <dons> you could use the ghci interface
04:00:27 <dons> echo hoogle id | ./lambdabot
04:00:29 <dons> would work too
04:00:43 <mq_mattr> dons: cheers
04:00:58 <mq_mattr> I actually want to hook it into quicksilver on the mac
04:01:11 <dons> ok. cool!
04:01:12 <mq_mattr> I would also like to hook it into textmate
04:01:32 <mq_mattr> I think there are some interesting "code completion"-type things that could be done
04:02:23 <mq_mattr> quit
04:02:30 <mq_mattr> sorry
04:02:36 <mq_mattr> wrong program
04:02:37 <mq_mattr> :)
04:04:26 <dons> he
04:06:00 <earthy>  > sortBy ((. uncurry compare) . compare . (uncurry compare)) $ [(1,2),(2,1),(3,3)]
04:06:14 <earthy> > sortBy ((. uncurry compare) . compare . (uncurry compare)) $ [(1,2),(2,1),(3,3)]
04:06:15 <lambdabot>  [(1,2),(3,3),(2,1)]
04:07:02 <earthy> hm. hoogle in qs... that's a cool idea
04:07:25 <mq_mattr> two "cool"s, I better get to it
04:07:31 <mq_mattr> more procrastination!
04:07:44 <mq_mattr> back, pesky PhD, I have other things to do :)
04:07:47 <earthy> actually, full lambdabot in qs would be even better
04:08:26 <Masklinn> how about a full lambdabot with a qs-like interface?
04:08:46 <earthy> nah, that'd be useless. :P
04:08:47 <mq_mattr> just use qs - that is what it is there for
04:08:57 <mq_mattr> bugger the non-mac people :)
04:09:05 <Masklinn> i don't know, I don't quite understand what i can do with it yet
04:09:17 <mq_mattr> qs you mean?
04:09:17 <Masklinn> mostly using it as a spotlight on 'roids for the moment
04:09:20 <Masklinn> yeah qs
04:09:28 <mq_mattr> open apps
04:09:33 <earthy> basically, it is a commandline that's instantly available
04:09:36 <mq_mattr> open commonly used files
04:09:38 <earthy> and that knows about data types
04:09:42 <mq_mattr> run any command
04:09:56 <Masklinn> run any command?
04:09:59 <earthy> yup
04:10:09 <mq_mattr> basically, get it to index *just* what you commonly use and then it is fast spotlight
04:10:21 <mq_mattr> from there you can get into the more "advanced things"
04:10:26 <mq_mattr> once you are hooked :)
04:10:40 <mq_mattr> invoke qs, then hit period.
04:10:50 <dons> shapr: I don't think you need to respond to that guy, its been pointed out a few times that he trolls on LtU, the article is incoherent at best, and doesn't deserve the attention
04:10:59 * earthy likes to think about qs as 'instantly available commandline with smart matching of the things I type'
04:11:19 <Masklinn> mq_mattr > typing period only gives me shortcuts to .mac and stuff
04:11:27 <Masklinn> anything i'm missing?
04:11:38 <earthy> masklinn: extensions for 'search google' and the like, maybe?
04:11:45 <earthy> and for 'append to text file'?
04:11:45 <Masklinn> probably
04:12:11 <mq_mattr> why would anyone troll on ltu?
04:13:43 <Masklinn> mq_mattr > for the sake of trolling?
04:14:16 <mq_mattr> but, ltu is not a place where people rant back and forth, there would be many better places to troll
04:14:39 <mq_mattr> I guess I shouldn't try to understnd people who's outlook on life is so different to mine
04:29:30 <ozone> hmmm, can you make Ptr an instance of Monad?
04:29:53 <xerox> ?kind Ptr
04:29:54 <lambdabot> Not in scope: type constructor or class `Ptr'
04:30:02 <ozone> ?kind Foreign.Ptr
04:30:03 <lambdabot> * -> *
04:30:42 <xerox> (>>=) :: Ptr a -> (a -> Ptr b) -> Ptr b
04:30:52 <dons> ozone: nasty idea ;)
04:30:53 <xerox> return :: a -> Ptr a
04:30:58 <xerox> I don't think so :)
04:31:06 <ozone> dons: well, i'm writing a small blog article about using monads for error handling
04:31:18 <ozone> one of the examples i'm using is how the maybe type is analagous to a pointer in C
04:31:27 <ozone> Nothing == NULL; Just x = non-NULL
04:31:36 <ozone> and then i thought, hmmm, pointers are likely just monads...
04:31:37 <dons> ah, you've discovered that mentioning 'haskell' is a guaranteed 100 reddit up mods? ;)
04:31:49 <ozone> laugh
04:31:56 <dons> well, a Ptr is a container, so maybe under the container view..
04:31:57 <ozone> i couldn't give a crap about the reddit crowd :)
04:32:21 <ozone> i'm mostly sick of telling people that monads are actually quite practical
04:32:24 <dons> but they have some weird semantics... so  you better check the 3 laws of rob^h^h^hmonads
04:32:50 * dons watches Day of the Triffids on ABC
04:33:06 <mq_mattr> dons: seriously, now?
04:33:10 <dons> RIGHT NOW!
04:33:18 <mq_mattr> i'm off, see ya
04:33:19 <dons> the killer plants are about to arrive!
04:33:43 <dons> heh
04:33:46 <ms_> here's a semantics question: is "type" an operator or a category? I.e, the "type" of True is Boolean. Is the "type" of Boolean kind? Or, is "type" just a category: so Boolean IsA type ; analagous to True IsA Boolean
04:34:18 <ms_> similarly, if "type" is a operator, is "value" the inverse?
04:34:40 <shapr> dons: Well, that same guy is posting links to his blog posting on the joelonsoftware thread.
04:37:54 <dons> shapr: :/
04:38:01 <dons> blogs should require a license
04:38:58 <shapr> I think arguments, at least in the CS world, should require code. Anything else is handwaving.
04:39:50 <ozone> ah, i guess ptrs aren't monads
04:40:12 <ozone> the type of >>= would be
04:40:13 <ozone> (>>=) :: Ptr a -> (Ptr a -> Ptr b) -> Ptr b
04:40:14 <ozone> rather than
04:40:17 <ozone> (>>=) :: Ptr a -> (a -> Ptr b) -> Ptr b
04:40:21 <ozone> bugger
04:40:35 <ozone> would've been a beautiful didactic example
04:40:39 <Syzygy-> Handwaving is a good, tested, tried and traditional proof method! I don't see what you can possibly have against handwaving!
04:41:00 <xerox> I think the problem is return, not (>>=), which should be a -> IO (Ptr a)
04:41:10 <int-e> ozone: just define data Box a = Box a, readBox :: Box a -> a, and then the obvious monad on top of that ;)
04:41:21 <int-e> ozone: or just use Reader.
04:41:28 <dons> :)
04:41:36 <ozone> int-e: hmm, thanks, that might work
04:41:51 <ozone> i'm looking to use it as a small example in a blog entry, so it might be a bit too complex for that
04:41:54 <ozone> we'll see!
04:42:01 <int-e> uh. not reader.
04:42:02 <xerox> what about the list monad?
04:42:05 <int-e> that's Id, sorry.
04:42:45 <xerox> join :: Ptr (Ptr a) -> Ptr a -- is still a funny idea.
04:43:12 <int-e> xerox: but unsafe.
04:43:13 <dons> ozone: you should ping ibid to syndicate your hsakell stuff to planet.haskell.org
04:43:16 <dons> join in the fun!
04:43:56 <ozone> xerox: nah, this is a post about using monads for error handling
04:44:18 <ozone> (for the C/C++/Java crowd)
04:44:24 <xerox> errors are boring, write on nondeterminism!
04:44:47 <kfish> ozone: yo :-) saying Maybe is like a better-specified NULL-or-value is interesting, but how will you demonstrate the monadic usage?
04:45:17 <ozone> kfish: you were going to be part of the beta crowd for this blog entry ;)
04:45:24 <ozone> critique it before i actually put it online for the public and all that
04:45:36 <kfish> ozone, i look forward to it :-)
04:45:37 <dons> ?where yaht
04:45:37 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
04:46:31 <ozone> kfish: anyone else you know who likes discussing crap like exceptions vs error return codes, and _doesn't_ know haskell?
04:46:46 <ozone> (i.e. not erik, rob collins, shans)
04:46:51 <kfish> gah
04:46:58 <ozone> :}
04:47:22 <ozone> would raster be interested in stuff like this, or would he place it in his don't-care box?
04:47:47 <kfish> raster's code doesn't have errors dude!
04:47:49 <dons> ozone: btw, did you see the ErrorT transformer stuff in the 'Lisp interpreter in HAskell' article by coffeemug?
04:47:57 <dons> kfish: hehe.
04:48:09 <ozone> kfish: oyeah!
04:48:13 <ozone> dons: nope, got a link?
04:48:17 <dons> kfish: he roundhouse kicks the errors out?
04:48:26 <dons> ozone: you need to read the HWN dude... ;)
04:48:32 <ozone> i do
04:48:35 <ozone> which HWN was it in?
04:48:50 <kfish> dons: no, he just has APIs full of C functions declared void ...
04:48:55 <ozone> dons: you're confusing raster with anton blanchard
04:48:56 <dons> http://www.defmacro.org/ramblings/lisp-in-haskell.html
04:48:57 <lambdabot> Title: defmacro - Writing A Lisp Interpreter In Haskell
04:49:01 <ozone> dons: http://antonblanchardfacts.com/
04:49:02 <lambdabot> Title: Anton Blanchard Facts
04:49:10 <dons> ozone: oh, I thought it was Chuck Norris
04:49:25 <dons> actually, we have OlegFacts
04:49:29 <dons> ?quote OlegFacts
04:49:29 <lambdabot>  Oleg solves NP-hard problems in N log N time... in the type system
04:49:44 <ozone> ah, that one
04:49:47 <ozone> lemme re-read it
04:49:54 <dons> there's some ErrorT stuff at the end
04:50:32 <ozone> yep, i remember reading this
04:58:15 <SamB_XP> @quote OlegFacts
04:58:15 <lambdabot>  Oleg solves NP-hard problems in N log N time... in the type system
04:58:22 <SamB_XP> @quote OlegFacts
04:58:22 <lambdabot>  Oleg solves NP-hard problems in N log N time... in the type system
04:58:24 <psykotic> haha
04:58:32 <dons> that's the only fact we have :)
04:58:32 <SamB_XP> aren't there any *others*?
04:58:40 <dons> (actually, there's a couple of others in the hwn archives)
04:58:56 <dons> swiert: i'm working on an smp/stm irc bot tutorial for TMR, by the way
04:59:01 <dons> (since you asked to be told)
04:59:02 <profmakx> ah o-notation is oleg-notation then?`
04:59:44 <dons> yeah, Oleg's code has the complexity encoded in the type
05:11:29 <roconnor> according to HWN we have a new Haskell GUI system
05:13:39 <fasta> roconnor: it's already at version 0.0
05:13:48 <pejo> Heh, Oleg is Haskells own Chuck Norris.
05:14:02 <dons> roconnor: damn straight!
05:14:14 <dons> ?where+ phooey http://programming.reddit.com/goto?id=ujr0
05:14:15 <lambdabot> Done.
05:14:17 <dons> grr
05:14:28 <dons> ?where+ phooey http://conal.net/phooey/
05:14:28 <lambdabot> Done.
05:14:41 <fasta> and the documentation links are linked to a local address... C:/<something>
05:14:41 <dons> I really like this arrow/gui link
05:14:43 <dons>     ui1 = title "Shopping List" $
05:14:43 <dons>           proc () -> do
05:14:43 <dons>             a <- title "apples"  (islider 3) -< (0,10)
05:14:43 <dons>             b <- title "bananas" (islider 7) -< (0,10)
05:14:45 <dons>             title "total" showDisplay        -< a+b
05:15:03 <ozone> dons: yay, fudgets is back :)
05:15:03 <dons> fasta: ping conal about that then
05:15:08 <dons> ?seen conal
05:15:08 <lambdabot> I saw conal leaving #haskell 1d 11h 57m 54s ago, and .
05:15:12 <dons> ozone: heh
05:15:13 <Itkovian> I admit that looks cool dons
05:15:27 <fasta> dons: I have never seen conal before
05:15:32 <SamB_XP> phooey!
05:15:33 <ozone> only been, what, 10 years since somebody finally brought it into the 21st century!
05:15:55 <dons> ozone: did Conal originally work on Fudgets for his PhD thesis?
05:15:55 <roconnor> So how is phooey?
05:15:57 * dons tries to remember
05:16:01 <genneth> re: phooey : it seems that there are some low-level issues to be worked out; some of the later examples of recursion dies
05:16:07 <SamB_XP> ozone: impossible! the 21st century only started 5-7 years ago!
05:16:29 <ozone> dons: fudgets were done by some swedes, iirc
05:16:48 <ozone> yeah, thomas hallgren & magnus carlsson; chalmers folks
05:16:59 <dons> ah yes, he worked on Fran , now I recall
05:17:08 <ozone> their thesis still kicks ass today
05:17:14 <dons> e.g. Two-handed Image Navigation in Fran
05:17:49 <pejo> dons, wasn't it Magnus Carlsson and Thomas Hallgren who did Fudgets?
05:17:49 <SamB_XP> two-handed?
05:17:51 <dons> mm, is this use of arrows for a gui dsl new?
05:18:04 <pejo> Doh, too late.
05:18:05 <SamB_XP> like, with an extra mouse?
05:18:10 <genneth> dons: didn't fudgets do it?
05:18:19 <ozone> dons: no
05:18:22 <dons> i thought arrows were later than fudgets
05:18:25 <dons> maybe i'm wrong.
05:18:28 <ozone> they are
05:18:33 <ozone> arrows evolved from the parsing space
05:18:42 <ozone> but fudgets were conceptually arrows
05:18:47 <dons> ah
05:19:00 <dons> (it makes sense though, once you try to do monadic guis, you end up needing something arrowish )
05:19:01 <SamB_XP> ur-arrows?
05:19:03 <ozone> ?google fudgets arrows
05:19:04 <fasta> Hmm, it appears that Doubly Linked List are only not possible with a pure interface because of pointers to the end and start.
05:19:05 <lambdabot> http://www.cse.ogi.edu/~magnus/ProdArrows/
05:19:05 <lambdabot> Title: ProdArrows -- Arrows for Fudgets
05:19:09 <dons> hehe
05:19:10 <ozone> there's a ton of links :)
05:19:19 <fasta> But all the other operations can happen in constant time.
05:19:24 <genneth> oh yeah; i remember now: the fudgets people actually said that a syntactic sugar level would make the code easier to read
05:19:29 <fasta> So, I can drop ST at least in one place :)
05:20:43 <dons> ozone: its good to see a modern gui library using the formalism
05:20:47 <dons> (and timely too!)
05:21:05 <ozone> dons: totally agreed
05:21:09 <SamB_XP> yeah
05:21:11 <genneth> it has to be pointed out, however, that a lot of a "modern" gui library (gtk, qt, etc.) is to do with doing things efficiently
05:21:19 <ozone> dons: it was something else i wanted to do when i was doing haskelly stuff
05:21:21 <SamB_XP> maybe phooey will manage to solve the maintainence problem!
05:21:34 <ozone> now i just wish somebody would make an arrow-based multimedia framework ;)
05:21:34 <SamB_XP> that seems to be the chief problem with functional GUIs to date...
05:21:43 <dons> hehe
05:21:46 <ozone> SamB_XP: also agreed
05:21:47 <dons> ozone: great idea!
05:21:53 <dons> ozone: sounds like a good phd topic
05:21:58 <ozone> dons: hmmmmmm!
05:22:13 <genneth> the gstreamer people might have already hit that one without calling it...
05:22:16 <dons> ozone: you could stream sound, video, ... all together with a nice EDSL
05:22:19 <ozone> dons: hey, i have a 100% track record for "things i started in haskell and other people implemented" so far ;)
05:22:44 <dons> ozone: cause we *define* agile ;)
05:22:45 <genneth> actually -- that's a good point; gstreamer works with pipeline stages, etc.
05:22:53 <ozone> dons: yeah, imagine that.  i reckon i could talk to kfish about that...
05:22:59 <Binkley> ozone: so, how do you get people do that? bribes? :-)
05:23:03 <SamB_XP> kfish?
05:23:04 <genneth> you could wrap it up into haskell and build the pipelines with some arrows
05:23:13 <ozone> Binkley: i have found a good technique
05:23:20 * SamB_XP wonders why that sounds like a little fish that swims around in a tank on your desktop...
05:23:24 * Binkley is listening
05:23:26 <roconnor> ozone: isn't reactive functional programming a multimedia framework based on arrows?
05:23:27 <ozone> what you do is join a programming language research group
05:23:32 <Binkley> tried that, didn't work
05:23:44 <Binkley> I mean, I tried that 3-5 years ago and it didn't work
05:23:45 <Binkley> rather
05:23:45 <chessguy> 'morning
05:23:51 <ozone> then you start telling everybody in the group that they're wrong and why they're wrong, and explain how things work in the C/C++/Objective-C worlds
05:23:56 <SamB_XP> Binkley: what do you start?
05:23:57 <dons> heya Binkley
05:24:00 <Binkley> hi dons
05:24:04 <ozone> then eventually they come around and implement everything you've been harping on about
05:24:11 <SamB_XP> ozone: wrong about what?
05:24:13 <Binkley> ozone: that didn't work well for me at all
05:24:18 <Binkley> I told the other people in my group they were wrong
05:24:24 <Binkley> and my officemate yelled at me for being an academic
05:24:28 <Binkley> and everyone else pretty much ignored me
05:24:30 <SamB_XP> haha
05:24:57 <Binkley> SamB: well, to be honest, I start things and then don't really even try to get people to finish them
05:25:05 <Binkley> usually I'm too embarassed about my code to do that
05:25:07 <ozone> oh yes, but you must have a good supervisor that can tolerate you well :)
05:25:15 <chessguy> we're up to 22 of the 99 haskell problems done. compared to the 25 that are done in lisp!
05:25:19 <Binkley> ozone: I had a good supervisor, but the tolerance wore thin after a while
05:25:20 <Binkley> on both sides
05:25:34 <Binkley> well, it's a very long story, and probably not one for a logged channel ;-)
05:25:39 <ozone> Binkley: random question, you're not named after BinkleyTerm are you?
05:25:40 <SamB> speaking of which, I should look at sorear's hlife code
05:25:51 <Binkley> ozone: no, I'm named after Mike Binkley, a character in the "Bloom County" comic strip
05:25:52 <Binkley> or rather
05:25:54 <Binkley> my nick is named after that
05:26:01 <Binkley> haven't legally changed my name to my IRC nick like shapr yet :-)
05:26:03 <ozone> oh, that'd be what BinkleyTerm's named after as well.  fancy that :)
05:26:05 <SamB> I don't imagine it will be of much use to me, considering it uses the wrong library...
05:26:13 <Binkley> ozone: I've seen BinkleyTerm but I did not know that. interesting!
05:26:31 <ozone> SamB_XP: wrong about stuff like the importance of dynamic loading and dynamic typing...
05:26:44 <SamB> there is no "p" in Shae Erisson
05:26:49 <SamB> ozone: what you mean?
05:26:56 <Binkley> SamB: no, but he explained it that way
05:27:00 <SamB> underestimating or overestimating?
05:27:01 <Binkley> once
05:27:02 <Binkley> in Uppsala
05:27:10 <ozone> SamB: underestimating
05:27:18 <SamB> oh
05:27:33 <ozone> dons: i remember giving a talk about parser combinators in AFP to patrykz, and he was like "uhh, yeah, they suck.  too slow, no real advantages, blah blah blah..."
05:27:43 <SamB> I didn't realize that ObjC had that problem
05:27:55 <kzm> @seen JaffaCake
05:27:55 <lambdabot> JaffaCake is in #haskell.hac07, #darcs and #ghc. I last heard JaffaCake speak 3h 17m 44s ago.
05:28:08 <SamB> haha
05:28:13 <ozone> SamB: oh, i was using Objective-C as an example of how important dynamic loading can be
05:28:17 <SamB> too slow?
05:28:23 <ozone> SamB: and was bemoaning about how haskell lacked it
05:28:27 <SamB> ozone: ah.
05:28:37 <SamB> C and C++ were examples too or not?
05:28:54 <fasta> Can I export foo as bar in the module system?
05:29:12 <SamB> fasta: say bar = foo first
05:29:18 <ozone> SamB: still yet to expouse on the good things about C++, since i've only come to grips with it recently
05:29:29 <ozone> i thinkthe  haskell community could learn a lot from C++
05:29:47 <SamB> yeah. maybe. but it is alternatively too boring and too interesting.
05:30:13 <ozone> the only two haskell hackers i know who are intimately familiar with C++ are Oleg and Pseudonym
05:30:26 <kzm> Uh..I have a linking problem here.  Trying to use ghc with -debug, but I get:
05:30:27 <kzm> Linking rbr_dbg ...
05:30:27 <kzm> /usr/bin/ld: cannot find -lbfd
05:30:27 <kzm> collect2: ld returned 1 exit status
05:30:27 <ozone> and they're both pretty highly respected
05:30:40 <SamB> Oleg would be
05:30:42 <kzm> but libbfd.so is in /usr/lib
05:30:47 <kzm> Any clues?
05:30:54 <SamB> type-system programmer as he is, he would want to know templates ;-)
05:31:07 <SamB> kzm: there is an .so?
05:31:51 <SamB> oh, I bet ghc wants the .a
05:32:05 <SamB> I didn't know there *was* an .so...
05:32:17 * SamB wouldn't swear by it, though
05:32:31 <kzm> Yes.  Hmm... I thought that would explain why it didn't work with -optl-static, but I removed that.  Oh well, will try to find the .a
05:33:16 <SamB> are you sure it is libbfd.so, and not libbfd.so.*?
05:33:39 <kzm> no, it's .so.x.y.z
05:33:51 <kzm> uh, sorry.
05:33:52 <pejo> ozone, if someone could distill the useful stuff from Strostrup's book, or wherever, and actually pointed out some real world usage of the features it wouldn't be surprising if the Haskell community listened.
05:33:56 <SamB> kzm: that does it
05:34:03 <kzm> -rw-r--r-- 1 root root 622256 2006-06-28 16:38 /usr/lib/libbfd-2.17.so
05:34:06 <SamB> install the -dev or -devel package for libbfd
05:34:13 <kzm> binutils-dev, I think.
05:34:20 <SamB> probably it
05:35:18 * SamB wonders how long until DLists make it into base
05:35:54 <SamB> dons: when are you releasing 0.2?
05:36:00 <dons> tomorrow?
05:36:04 <dons> after i apply your patches
05:36:24 <SamB> heh
05:36:35 <SamB> it would be kind of silly to do another release before that ;-)
05:36:48 <kfish> dons: got some examples to go with the DList docs?
05:36:57 <dons> kfish: good idea.
05:37:01 <dons> i don't, but I'll add them
05:37:13 <dons> (basically, nanywhere you accumulate strings, with ++)
05:37:20 <dons> so the logging/writer monad is one good use case
05:37:31 <dons> and i have a case from pretty printing that wors
05:38:30 <SamB> yeah, which is why I added a Monoid instance
05:38:44 <dons> kfish: i needed them in yi too
05:38:54 <SamB> for the Writer monad (and friends)
05:38:59 <fasta> What extension do I need to solve: 'Illegal instance declaration for `Monoid (Maybe (DLL a))'
05:39:16 <SamB> fasta: uh, extension?
05:39:22 <SamB> you probably need a newtype...
05:39:38 <SamB> what are you trying to do though?
05:39:52 <SamB> i.e. what does your mappend do?
05:40:25 <fasta> SamB: my append appends two bidirectional structures.
05:40:41 <SamB> fasta: why the Maybe?
05:40:49 <fasta> SamB: the structure might be empty
05:41:10 <fasta> SamB: I could either add an Empty constructor or just use Maybe
05:41:38 <SamB> you should recast your types so that your exposed type is either a data type or a newtype
05:42:14 <SamB> > mappend Nothing (Just 1)
05:42:14 <lambdabot>  add an instance declaration for (Monoid (Maybe a))
05:42:14 <lambdabot>   In the definition of...
05:42:17 <SamB> hmm.
05:42:37 <SamB> maybe Maybe doesn't make sense as a Monoid, but I wouldn't bet on it...
05:43:40 <xerox> A monoid is a set together with a binary associative operation that as an identity.
05:43:50 <SamB> "is an identity"?
05:44:06 <xerox> has
05:44:10 <SamB> oh
05:44:22 <SamB> misread your mispelled word ;-)
05:45:32 <SamB> fine, then, Maybe *is* a Monoid, but it doesn't sound like a particularly useful one...
05:46:16 <xerox> What operation makes it a monoid?
05:46:44 <dons> ++
05:46:46 <dons> and []
05:48:04 <fasta> appending a to b gives rise to a valid structure, as does appending b to a. They are different structures, internally, though.
05:48:51 <fasta> I don't like the forced newtype.
05:49:08 <SamB> dons: um
05:49:22 <SamB> we maybe hasn't those, dons!
05:49:43 <dons> Nothing -> []
05:49:57 <dons> :t mappend
05:49:58 <lambdabot> Not in scope: `mappend'
05:50:11 <dons> :t Data.Monoid.mappend
05:50:12 <lambdabot> forall a. (Data.Monoid.Monoid a) => a -> a -> a
05:50:28 <SamB> what have I told you about copying and pasting imports everywhere, dons?
05:50:39 <dons> that you'd submit me a patch?
05:50:42 <xerox> @check \x y z -> let Nothing + x = x; (Just x) + _ = (Just x) in ((x :: Maybe Int) + (y :: Maybe Int)) + (z :: Maybe Int) == x + (y + z)
05:50:43 <lambdabot>  OK, passed 500 tests.
05:50:46 <SamB> ... uh, no.
05:50:48 <xerox> uhu.
05:50:54 <SamB> thats not what I told you.
05:51:10 <pejo> SamB, it's what he wanted to hear though. :-)
05:51:11 <dons> :t maybeToList . (++) . listToMaybe  -- !
05:51:13 <lambdabot>   Couldn't match `[a]' against `Maybe a1'
05:51:13 <lambdabot>    Expected type: [a1] -> [a]
05:51:17 <dons> ah well, close
05:51:23 <xerox> :t maybeToList
05:51:24 <lambdabot> forall a. Maybe a -> [a]
05:51:38 <dons> :t listToMaybe . (++) . maybeToList
05:51:39 <lambdabot>   Couldn't match `[a]' against `[a1] -> [a1]'
05:51:39 <lambdabot>    Expected type: Maybe a1 -> [a]
05:51:45 <xerox> :t listToMaybe
05:51:46 <dons> oh, its `dot`
05:51:46 <lambdabot> forall a. [a] -> Maybe a
05:51:56 <SamB> :t dot
05:51:57 <lambdabot> Not in scope: `dot'
05:52:01 <xerox> :t maybeToList . listToMaybe
05:52:03 <lambdabot> forall a. [a] -> [a]
05:52:19 <dons> :t \x y -> listToMaybe ( (maybetoList x) ++ (maybeToList y))
05:52:20 <lambdabot> Not in scope: `maybetoList'
05:52:40 <dons> > (\x y -> listToMaybe ( (maybetoList x) ++ (maybeToList y))) Nothing (Just ())
05:52:41 <lambdabot>  Not in scope: `maybetoList'
05:52:49 <dons> > (\x y -> listToMaybe ( (maybeToList x) ++ (maybeToList y))) Nothing (Just ())
05:52:50 <lambdabot>  Just ()
05:52:52 <xerox> :t listToMaybe . ap ((++) . maybeToList) maybeToList
05:52:53 <lambdabot> forall a. Maybe a -> Maybe a
05:52:55 <xerox> (:
05:53:06 <dons> > (\x y -> listToMaybe ( (maybeToList x) ++ (maybeToList y))) (Just 'a') (Just 'b')
05:53:07 <lambdabot>  Just 'a'
05:53:17 <xerox> liftM2 maybe..
05:53:20 <xerox> ?type liftM2
05:53:22 <lambdabot> forall r (m :: * -> *) a2 a1. (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
05:53:25 <dons> ?pl (\x y -> listToMaybe ( (maybeToList x) ++ (maybeToList y)))
05:53:25 <lambdabot> (listToMaybe .) . (. maybeToList) . (++) . maybeToList
05:53:51 <xerox> ?type listToMaybe . join (liftM2 (++)) maybeToList
05:53:52 <lambdabot> forall a. Maybe a -> Maybe a
05:53:55 <xerox> yesh!
05:54:28 <dons> ?hoogle mappend
05:54:29 <lambdabot> Data.Monoid.mappend :: Monoid a => a -> a -> a
05:54:54 <dons> :t (\x y -> listToMaybe ( (maybeToList x) ++ (maybeToList y)))
05:54:55 <lambdabot> forall a. Maybe a -> Maybe a -> Maybe a
05:54:58 <xerox> ops
05:55:03 <xerox> I see what you mean :)
05:55:33 <xerox> then the section composition up there is the right one
05:55:35 <SamB> hmm, sorear uses an interesting technique in his UI.Console...
05:56:06 <dons> hehe, http://programming.reddit.com/info/ujjo/comments/cukf3
05:56:08 <lambdabot> Title: Haskell: Do-notation considered harmful (reddit.com)
05:56:13 <dons> who's going to implement that patch
05:56:19 <SamB> the Console datatype is just a record of methods, which are closures over the state they use...
05:56:33 <SamB> I mean, IORefs and such...
06:02:31 <Pupeno> What was the shortcut to run ghci/compile current buffer in Emacs with haskell-mode
06:03:56 <TSC> C-c C-l ?
06:04:08 <Pupeno> yes.
06:04:17 <TSC> (if ghci is already running)
06:05:08 <ozone> kfish, dons: http://www.algorithm.com.au/tmp/monads-preview.html
06:05:23 <ozone> (other people are also welcome to comment on it, of course)
06:05:33 * dons takes a peek
06:05:53 <dons> ozone: you going to ping ibid about getting your stuff on planet.haskell ?
06:05:59 <dons> just hand him the rss url
06:06:00 <ozone> dons: sure, will do!
06:06:25 <ozone> ibid: please add feed://www.algorithm.com.au/blog/files/rss.xml to planet haskell :)
06:06:38 <ozone> err, s/feed/http/
06:08:26 <dons> ozone, in the section 'There's one big difference' ...
06:08:32 <dons> you don't explain what the haskell version does
06:08:38 <dons> (i.e. fail with Nothing)
06:08:51 <ozone> good point
06:08:53 <ozone> i do explain that later on
06:09:02 <ozone> but something to fill in the reader there would be helpful, thanks
06:09:21 <dons> and isn't "though: there's no checking for NULLs (Nothings) in the monadic version" actually inaccurate?
06:09:29 <ozone> yes :)
06:09:29 <dons> it does check, and branches to fail, no?
06:09:43 <ozone> right
06:09:48 <ozone> i'll reword that section then
06:11:12 <fasta> Are class instances automatically exported?
06:11:36 <dons> ozone, you might consider using HsColour to syntax highlight?
06:11:42 <dons> example use here: http://cgi.cse.unsw.edu.au/~dons/blog/2006/09/10#colours
06:11:42 <lambdabot> Title: Haskell, hacking and other stuff
06:12:06 <ozone> heh, i'd need to integrate that with the blogging software and markup language
06:12:13 <dons> (it just just generaates a marked up <pre> block to stdout)
06:12:18 <ozone> ah, right
06:12:25 <ozone> i'll see if i can, yeah
06:12:55 <Binkley> Hey, speaking of blogs -- and this is sort of on-topic -- if theoretically somebody who was used to using LiveJournal was thinking about starting a public blog using their own web space (but where they aren't superuser), what would you recommend?
06:12:59 <Binkley> is there a Haskell-based blog engine yet? :-)
06:13:01 <dons> I 100% agree about this Maybe a thing works in Haskell, because it is light syntactically
06:13:15 <dons> Binkley: lambdaFeed?
06:13:20 <dons> ?where lambdaFeed
06:13:21 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/lambdaFeed/
06:13:25 <dons> maybe not an engine though
06:13:28 <xerox> Hope
06:13:34 <Cale> Binkley: hmm, there's Hope, I don't know what using that is like.
06:13:37 <Binkley> that looks like an aggregator
06:13:43 <Binkley> oh, that, I guess shapr is using that
06:13:45 <Binkley> I could ask him
06:13:59 <xerox> It's like any other blog engines, you write posts and post them
06:14:06 <dons> ozone: so on the topic of "monads" under the hood, I guess you just show the >>= desguared version?
06:14:13 <dons> then inline the definition of >>= for your monad
06:14:20 <ozone> dons: right
06:14:20 <dons> reducing it to a set of nested case statements
06:14:29 <dons> i.e. back at the start again :)
06:14:31 <fasta> xerox: hmm, so you still need to write posts... isn't that a disadvantage?
06:14:39 <ozone> dons: only problem is that the article's targeted at C/C++ folks, but it somewhat academic for them
06:14:44 <Binkley> I suppose I'm not sure where the right tradeoff for me is between wanting to use something stable, and wanting to help develop whatever Haskell-based blog tools exist
06:14:46 <ozone> (since they don't have the monadic syntactic sugar)
06:14:50 <Cale> ozone: these is one thing which Maybe lacks relative to exceptions, and that is actually reporting what went wrong. You can use the (Either e) monad for that.
06:15:04 <dons> ozone: you might mention that Maybe a is hard to define in OO languages that don't support sum types cleanly
06:15:06 <ozone> Cale: right, i mentioned the error monad at the start
06:15:21 <fasta> What's the point of writing articles when you can also write something like e.g. Amarok that doesn't crash _ever_.
06:15:28 <fasta> Or Azureus
06:15:28 <dons> ah yes, so I think there's a missing section after the Maybe stuff
06:15:33 <dons> on using Either/Error instead
06:15:39 <dons> to get better fail messages
06:15:52 <dons> since you're bound to be asked about this "Nothing" error, being kinda not helpful
06:15:57 <Cale> fasta: Azureus never crashes?
06:16:03 <ozone> dons: yep, i'll send the link to you again when the article's more complete
06:16:06 <ozone> there's plenty more to go
06:16:12 <ozone> i'm fearing it's going to turn into a 20-page long thing though
06:16:14 <fasta> Cale: it does
06:16:19 <dons> ozone: great start though!
06:16:21 <ozone> because from there, you can really get into explaining monads...
06:16:30 <dons> ozone: I see reddit up mods all over it :P
06:16:37 <fasta> Cale: so, if someone starts an Azureus clone in Haskell that never crashes that shows some practical use of Haskell
06:16:50 <ozone> dons: hehe
06:16:55 <dons> ozone: yes, "keep it real" man :) no waffly monad muck
06:17:06 <fasta> So far, the Haskell success stories happen at high profile companies.
06:17:07 <Cale> Well, there's Conjure, which I suspect may be a decent start on the lower-level side of that.
06:17:08 <ozone> dons: now you can see why i was asking about monadifying Ptr :)
06:17:23 <dons> fasta: pugs wasn't high profile, was it? nor darcs?
06:17:33 <fasta> dons: pugs counts, darcs, counts.
06:17:40 <ozone> Cale: i'll expand on the error monad later.  it's hard to keep the balance between keeping the article at a reasonable length, and trying to explain, well, monads :)
06:17:43 <fasta> dons: But those are developer tools.
06:17:47 <dons> ah I see
06:18:09 <dons> so something more like credit suisses trading stuff
06:18:17 <dons> totally non-dev, non-FP-research code
06:18:27 <xerox> like hmp3 (:
06:18:30 <dons> for making real pesos with
06:18:40 <dons> xerox: my favourite example :)
06:18:43 <ozone> dons: people are always impressed when you point out that haskell is at the core of the investment banking industry ;)
06:18:51 <dons> :)
06:18:57 <dons> Haskell and EXCEL!
06:19:15 <fasta> dons: I mean something that any layman can download and see.
06:19:19 <ozone> dons: wait until gabi comes back and tells you about the lovely revision control system they have for their excel spreadsheets :}
06:19:22 <Binkley> dons: they explained this to me in a rather interesting way, actually --
06:19:28 <Binkley> "Financial institutions have a lot of money"
06:19:36 <Binkley> so it turns out that the people with the most money are the ones most willing to take the risks
06:19:42 <Binkley> since they have a lot to gain
06:19:49 <fasta> dons: I don't particularly care, but arguing that Haskell is fantastic is easier when you have an application with tons of users.
06:19:56 <Binkley> whereas random companies don't have much to lose but also don't have much to gain, so they're not willing to try a new language
06:19:59 <dons> fasta: I 100% AGREE!
06:20:10 <roconnor> ``the user can select an expression and paste it elsewhere preserving its semantics (i.e. the partially specified term), possibly performing some semantic transformation over it (e.g. renamingvariables that could be captured or lambda-lifting free variables).''
06:20:17 <dons> Binkley: hmm!
06:20:29 <Binkley> I certainly found that true in my experience, at least
06:20:30 <Binkley> I mean
06:20:36 <Binkley> I worked at a hardware verification company for a while
06:20:43 <dons> Binkley: very interesting. this kinda explains HAppS too, possibly (?)
06:20:44 <Binkley> and I tried to tell them it would be better to use Haskell than C
06:20:48 <Binkley> and they said
06:20:52 <Binkley> "but we can run lint"
06:20:54 <dons> and erlang
06:20:56 <Binkley> when I tried to explain about the type system
06:21:00 <dons> hehe
06:21:03 <dons> don't go therer
06:21:08 <Binkley> and so, even people whose business was verification -- they didn't get the point of verifying their own software
06:21:17 <Binkley> I'm trying to be less arrogant
06:21:24 <dons> that's scary
06:21:25 <chessguy> dons, at last check, we're at 23/99, compared to the lisp solutions which have 25/99
06:21:27 <Binkley> so I don't think that this story should be interpreted as "those people were stupid"
06:21:38 <Binkley> I think it should be interpreted as "we have a failure to communicate"
06:21:39 <dons> chessguy: that's great. i've been watching the commits flying
06:21:56 <dons> Binkley: hmm. yes. how do we fix this?
06:22:06 <dons> run some ads during the superbowl?
06:22:10 <Binkley> dons: well, I am crazy enough to think I could maybe fix it by writing a book :-)
06:22:11 <dons> we have a bit of SoC money spare
06:22:12 <Binkley> heh, super bowl ads
06:22:14 <xerox> hahaha
06:22:27 <Binkley> with Simon throwing something at a statue of Bjarne Stroustrup
06:22:30 <pejo> Binkley, yes, more books!
06:22:30 <ozone> dons: yes, let's show erlang the movie as a superbowl ad
06:22:32 <Binkley> Or possibly at Bjarne Stroustrup
06:22:35 <Binkley> That would be much cooler
06:22:36 <chessguy> http://haskell.org/haskellwiki/99_Haskell_exercises have fun everyone!
06:22:37 <lambdabot> Title: 99 Haskell exercises - HaskellWiki
06:22:38 <Binkley> Who would win in a fight?
06:22:38 <ozone> that would rule
06:22:45 <dons> ozone: that's a great idea. you should get into marketing
06:22:52 <pejo> (We were trying to convince Lennart to write a compiler book about functional languages the other day ;)
06:23:12 <dons> yeah, lennart should write a book about haskell, and how we managed to win 3 IOCCC contests
06:23:16 <chessguy> Binkley, idd you see the discussion yesterday in haskell-cafe about a new book?
06:23:16 <Binkley> there's already a compiler book about functional languages if you don't mind that it's not entirely up to date :-)
06:23:17 <dons> s/he/
06:23:23 <Binkley> chessguy: yes, I started that discussion
06:23:32 <pejo> dons, heh, he revealed the secret. "Lots and lots of work.", basically.
06:23:35 <chessguy> aha
06:23:56 <Binkley> Maybe sometime I should actually use my real name as my IRC nick
06:23:57 <pejo> Binkley, and not in print, if it's the book by SPJ?
06:23:57 <Binkley> nah
06:24:01 <Binkley> pejo: it's online
06:24:06 <dons> chessguy: so I see we've had 500 hits no
06:24:15 <chessguy> dons, close.
06:24:17 <dons> w. so that's ok. but i think it means its not on the reddit frontpage
06:24:20 <Binkley> http://research.microsoft.com/%7Esimonpj/Papers/slpj-book-1987/index.htm
06:24:21 <pejo> Binkley, I know, but it's not in print.
06:24:22 <lambdabot> Title: The Implementation of Functional Programming Languages, http://tinyurl.com/y3p22n
06:24:25 <Binkley> sure
06:24:28 <Binkley> I know
06:24:31 <Binkley> I'm being a little bit silly
06:24:46 <chessguy> Binkley, i'm the one that kept fragmenting the thread with posts that didn't quite continue the existing conversation
06:24:53 <Binkley> chessguy: aha, that was you ;-)
06:25:05 <Binkley> Yeah, I turned off digest mode and I'm just going to handle it with gmail filters instead
06:25:06 <chessguy> guilty!
06:25:08 <Binkley> email is kind of broken, isn't it?
06:25:39 <chessguy> looks that way
06:26:02 * roconnor tries to figure out what is being discussed.
06:26:13 <roconnor> Are we trying to make Haskell more popular?
06:26:34 <chessguy> Binkley, anyway, i look forward to working on a new book with you. seems like a fun and important project
06:26:54 <pejo> roconner, or provoke people to write books. :-)
06:26:55 <earthy> we are trying to make haskell even easier to use for those that want to try it
06:26:59 <Binkley> chessguy: yes, I'm excited about it! and also somewhat afraid
06:27:14 <Binkley> afraid mainly because my undergrad advisor wrote a book
06:27:15 <Binkley> or rather
06:27:21 <Binkley> has been writing a book for about 12 years
06:27:28 <Binkley> that's what I'm afraid of
06:27:29 <chessguy> "you should be. you....should...be......"
06:27:47 <chessguy> lousy yoda impression
06:27:55 <Binkley> it's hard to do yoda in a text-based forum
06:28:28 <earthy> hm. writing books isn't hard per se
06:28:33 <fasta> Why do we even still use IRC and have not moved on to Jabber?
06:28:33 <earthy> deciding what to put in them is hard
06:28:49 <ibid> ozone: added
06:28:50 <dons> mmm. quote of the day:
06:28:53 <dons> "If not for do-notation, I would never have successfully learned Haskell. This was at a time just before all the tutorials started to come out ..."
06:29:20 <Binkley> earthy: right. *stopping* writing them is hard
06:29:23 <ozone> ibid: merci
06:29:23 <Binkley> editing is hard
06:29:29 <Binkley> dons: heh
06:29:32 <chessguy> there is something to the whole notion of do notation obscuring what's really going on though
06:29:36 <Binkley> at the time, it *really* wasn't funny
06:29:47 <Binkley> chessguy: for me, it *helped* to obscure what's really going on
06:29:51 <Binkley> I know that not everyone is like me
06:29:57 <roconnor> fasta: is there a jaber haskell channel?
06:29:58 <Binkley> but I think that assuming everyone is like you is the whole problem here
06:30:11 <Binkley> with the book, I'm hoping I can address that by having several people collaborate on it
06:30:11 <fasta> roconnor: one could be made trivially
06:30:23 <Binkley> so that we don't get this "my pet metaphor will save everyone" business
06:30:53 <earthy> my pet metaphor consistently dies in the face of students' questions
06:31:00 <Binkley> haha
06:31:12 <Binkley> yeah, students are so annoying that way sometimes :-)
06:31:17 <roconnor> fasta: you are right, that was easy
06:31:25 <Binkley> I once tried to have my students do an interpretive dance to illustrate LL(1) parsers
06:31:30 <earthy> so I've learned to try to simply explain the matter as it is
06:31:31 <Binkley> it didn't work
06:31:38 <earthy> without metaphors
06:31:47 <Binkley> earthy: I think there might be something to that
06:31:50 <Binkley> I love wankery analogies
06:31:55 <chessguy> Binkley, i bet it was entertaining, though :)
06:31:57 <Binkley> but I'm not sure they're good for anyone who doesn't already understand.
06:31:57 <earthy> interpretive dance.
06:32:02 <earthy> whoa. :P
06:32:13 <Binkley> earthy: I was trying to get people to move around to illustrate the positions of tokens in the stack
06:32:16 <dons> Binkley: yes, I'd love to see 'monads as nuclear waste' illustrated through dance, to something by Kate Bush
06:32:17 <Binkley> and in whatever else an LL(1) parser has
06:32:19 <Binkley> I can't remember
06:32:23 <earthy> binkley: actually, that is really the issue
06:32:24 <Binkley> dons: now *there's* the quote of the day
06:32:41 <earthy> people often *do* understand, once the entirety is shown
06:32:59 <Binkley> earthy: the more I think about it
06:33:07 <dons> mm. google logo a bit wacky today
06:33:14 <dons> that's about the most obscure i've ever seen it
06:33:14 <Binkley> the more I think that life is pain, and anyone who says anything else is trying to sell you a bad monad metaphor
06:33:19 <Binkley> with apologies to william goldman
06:33:27 <earthy> dons: Edvard Munch, the Scream.
06:33:38 <dons> yes :) I know.
06:33:49 <Binkley> learning is hard
06:33:54 <Binkley> programming, because it's a form of learning, is hard
06:34:00 <Binkley> there isn't a shortcut
06:34:11 <Binkley> unless you consume and produce lists in a uniform way, of course.
06:34:16 <earthy> it's not a pain though
06:34:17 <earthy> it's joy
06:34:19 <earthy> pure joy
06:34:24 <Binkley> earthy: I thought it was pain for a while
06:34:26 <Binkley> then I thought it was joy
06:34:28 * chessguy sighs
06:34:29 <Binkley> now I think it's pain again
06:34:32 <Binkley> but there's pain in the joy
06:34:36 <chessguy> i suppose i should go show up at my earth science class :(
06:34:37 <Binkley> like mixing chocolate in the peanut butter
06:34:53 <earthy> sweet sorrow, sorrowful sweetness.
06:34:54 <Binkley> maybe I mean that there's joy in the pain
06:35:04 <chessguy> back later
06:35:07 <Binkley> this is all threatening to resurrect the term "bondage and discipline language"
06:35:29 <earthy> where's philippa when you need her. :P
06:36:21 <earthy> actually, it's more like 'by restricting the bad choices you can make you are forced to make good ones'
06:36:25 * ozone highfives earthy
06:37:22 <fasta> Is there a generalization for elem?
06:37:31 <earthy> in what sense?
06:37:43 <Binkley> earthy: that's a bit of a touchy question at the moment
06:37:53 <Binkley> but, as for restricting the bad choices...
06:37:56 <Binkley> I think that's simplistic
06:38:00 <Binkley> yes, often you are forced to make good ones
06:38:06 <Binkley> but you'll find that there are many ways to make bad choices
06:38:13 <fasta> earthy: in the sense of that there is a type class that has a function that does the same of list as elem.
06:38:30 <ndm> fasta: elemBy
06:38:51 <earthy> 15:30 <earthy> @hoogle elemBy
06:38:51 <earthy> 15:30 <lambdabot> No matches found
06:38:59 <ndm> @hoogle elem
06:38:59 <lambdabot> Prelude.elem :: Eq a => a -> [a] -> Bool
06:38:59 <lambdabot> Array.elems :: Ix a => Array a b -> [b]
06:38:59 <lambdabot> List.elemIndex :: Eq => a -> [a] -> Maybe Int
06:39:05 <earthy> you'd think so, wouldn't you? :P
06:39:11 <fasta> s/of/for
06:39:16 <ndm> hmm, weird.
06:39:21 <ndm> also doesn't work on the web version
06:39:21 <earthy> fasta: no, there is no such class
06:39:40 <ndm> oh, there is no such thing
06:39:42 <ndm> how weird
06:39:44 <fasta> Ok, so I could either make up such a class or just export the type.
06:39:55 * fasta just exports the type 
06:39:55 <earthy> but you are always free to import Prelude hiding (elem) ;)
06:40:02 <swiert> dons: thanks for the TMR heads-up.
06:41:13 <Binkley> well, these yaks aren't going to shave themselves. later, all!
06:42:30 <lray80de> after the installation of ghc 6.6, it doesn't find the Packages text and util ... how can I get them (under debian/ubuntu)
06:42:53 <lray80de> ...read, that there were some changes in the architecture, but couldn't get through it.
06:43:16 <pejo> lray80, apt-cache search ghc6, you'll find them there I think.
06:44:26 <lray80de> just did with apt-cache pkgnames | grep "ghc6" -> nothing
06:44:47 <lray80de> ...okay, my msitake...
06:44:56 <pejo> I have no idea what pkgnames does, sorry.
06:45:25 <lray80de> ...need of course a "dev"-package... I am a "dev"eloper.  :-S
06:45:40 <dons> swiert: how are you going for authors?
06:45:53 <dons> many registered yet?
06:46:13 <Igloo> lray80de: text and util are gone. You might find the modules you need elsewhere
06:46:43 <lray80de> how do I find out that? Mean, I donÃt compile my own piece of software.
06:47:15 <dons> yes, text and util are from quite a while ago
06:47:16 <Igloo> For a first step, remove the -package flags and see what breaks
06:47:22 <dons> and use --make
06:47:43 <dons> lray80de: what code are you building?
06:48:23 <lray80de> a compiler called "xcerpt" ... experimental thing of munich university.
06:58:21 <swiert> dons: not too bad.
06:58:54 <kfish> ozone, interesting article, i think you should emphasize that that's not the only way to handle errors in haskell -- ie. i think the point you are working up to is that monads provide clear control structures, and you are using error-handling with Maybe to demonstrate that; whereas the article seems to focus more on paying out try/catch exception handling ...
06:59:04 <swiert> dcoutts will write a review on Graham Hutton's new book, roconnor has a nearly finished article, and there are a few other maybes.
07:00:02 <kfish> ozone, i could imagine someone who loves try/catch pointing out that the Maybe style loses information of what the particular error is
07:01:58 <kfish> ozone, whereas what could be interesting is to show how the same program flow could be run in Maybe, or similarly in a monad built on ErrorT
07:02:07 <nominolo> @where base 2.0
07:02:07 <lambdabot> http://darcs.haskell.org/packages/base/
07:02:56 <nominolo> hm, is this the real "base 2.0" ?
07:03:01 <nominolo> @where base-2.0
07:03:02 <lambdabot> I know nothing about base-2.0.
07:05:17 <Cale> kfish: yeah, he does mention the Error monad, but hasn't written much about it yet.
07:14:13 <fasta> Is concat [[1],[2], ..,[n]] O(n)?
07:14:25 <lisppaste2> nominolo pasted "monadLib build error" at http://paste.lisp.org/display/32144
07:14:39 <ndm> fasta: yes
07:14:51 <nominolo> anyone has an idea how to fix this?
07:15:07 <ndm> fasta: res = concat xs, is cost O(length res)
07:17:48 <lray80de> okay, got the package-description out my Makefile. Now I get the following ridicolous error:
07:17:48 <lray80de> Xcerpt/Methods/Similarity/EditDistance2.hs:32:25:
07:17:48 <lray80de>     parse error on input `='
07:17:48 <lray80de> make: *** [xcerpt] Error 1
07:17:48 <lray80de> Problem, without the "-cpp"-Parameter set, it works, with "-cpp"-Parameter, I get the error...
07:17:52 <lisppaste2> lray80de pasted "C Pre-Processor" at http://paste.lisp.org/display/32146
07:18:13 <lray80de> ...are there differences in parsing, depending on cpp?
07:22:04 <fasta> toList list = traverse (:) (.) id list []  <- that's pretty nice
07:22:51 <fasta> Too bad generic traversals don't work for cyclic structures, or do they?
07:25:39 <fincher> there's a way to see function definitions/types with lambdabot, right?
07:27:20 <Pastorn> @type x + f
07:27:21 <lambdabot> Not in scope: `x'
07:27:21 <lambdabot>  
07:27:21 <lambdabot> <interactive>:1:4: Not in scope: `f'
07:27:31 <Pastorn> @type 2*8
07:27:32 <lambdabot> forall a. (Num a) => a
07:27:40 <Pastorn> @type *8
07:27:41 <lambdabot> parse error on input `*'
07:27:42 <Pastorn> @type *
07:27:43 <lambdabot> parse error on input `*'
07:27:49 <Masklinn> @type (*)
07:27:49 <Pastorn> @type (*)
07:27:50 <lambdabot> forall a. (Num a) => a -> a -> a
07:27:51 <lambdabot> forall a. (Num a) => a -> a -> a
07:27:55 <Pastorn> yay!
07:27:56 <fincher> @type $
07:27:57 <lambdabot> parse error on input `$'
07:28:04 <fincher> @type ($)
07:28:05 <lambdabot> forall b a. (a -> b) -> a -> b
07:28:17 <Masklinn> need prefix syntax for operators, not infix, to query types
07:28:25 <Masklinn> so you have to wrap them in parens
07:28:28 <fincher> makes sense.
07:28:32 <Pastorn> @type (.)
07:28:34 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
07:29:22 <Cale> hehe, okay, everyone stop posting to the mailing lists for a minute so I can catch up :)
07:32:09 <Masklinn> oh, by the way, for the ones who recently arrived: when you need a lot of informations from lambdabot you can just get into private messaging with him
07:32:31 <Masklinn> he'll work just like he does on the channels
07:32:40 <Pastorn> :D
07:33:19 <nominolo> is noone here using monadLib?
07:33:50 <fasta> @where monadLib
07:33:51 <lambdabot> http://www.cse.ogi.edu/~diatchki/monadLib/
07:34:20 <nominolo> i have a build error: http://paste.lisp.org/display/32144
07:35:19 <fasta> nominolo: functional dependencies are somewhat immature in my experience.
07:35:40 <huschi_> @pl  \g -> map (g:) . group ns
07:35:41 <lambdabot> (. group ns) . map . (:)
07:35:46 <fasta> nominolo: if you use the same version as the author did, it will probably work.
07:36:09 <huschi_> @pl (uncurry $ \g -> map (g:) . group ns)
07:36:09 <lambdabot> uncurry ((. group ns) . map . (:))
07:36:14 <nominolo> fasta: :) sure.  but i probably want ghc 6.6 for other stuff
07:36:50 <fasta> nominolo: Just e-mail the author to get it fixed or fork. If you don't understand the error message, read the documentation.
07:37:14 <fasta> nominolo: or post a message to cafe and hope for someone like Oleg to answer :)
07:37:27 <huschi_> @pl \n:ns -> concatMap (uncurry $ \g -> map (g:) . group ns) . combination n
07:37:28 <lambdabot> ap (flip ((.) . (=<<) . uncurry . flip ((.) . map . (:)) . group) . combination . head) tail
07:37:56 <nominolo> i (think i) understand the error message, and i think it should not be an error .. but well .. that doesn't make it compile
07:38:47 <nominolo> fasta: i contacted the author, if that doesn't help, cafe would be a good idea, though
07:38:51 <lisppaste2> emu pasted "parallelism in action" at http://paste.lisp.org/display/32151
07:40:12 <emu> i find it interesting how the "user" time shoots up drastically with greater -N values, though clock time stays fairly even
07:40:13 <nominolo> emu: is it slower for higher N?
07:40:46 <fasta> nominolo: he doesn't have a computer with N>4
07:40:50 <Pastorn> how do i do ["111","222","333","444","555","666","777","888","999"] -> ["111222333","444555666","777888999"]?
07:40:52 <emu> yea it gets slower
07:41:08 <nominolo> emu: are you sure you're not measuring startup time, too?
07:41:14 <emu> with -N5 it returns back to 6 seconds :/ might be startup
07:41:25 <emu> but that's part of the cost
07:41:37 <nominolo> well, not for long-running programs
07:41:46 <emu> true, i'll get to see that soon enough
07:42:56 <emu> hmm -sstderr reports something weird:
07:43:09 <emu> It says I have spawned "Tasks 0 thru 4" when i specify -N3
07:43:52 <nominolo> might be some parent threads
07:44:12 <emu> i guess. ghc seems to spawn 2 additional threads to N
07:46:20 <Baughn> It's probably got one thread blocking on select, I suppose
07:46:37 <Baughn> As for the other one.. *shrug*
07:47:08 <Baughn> Does GHC use asynchronous I/O for reading from disk? (Since select doesn't really work thereabouts, I mean)
07:48:06 <emu> actually, i suspect this machine may be in fact, a dual core machine with hyperthreading
07:48:21 <emu> does that appear to linux as 4 processors?
07:49:02 <nominolo> emu: yup
07:49:04 <amiddelk> emu: yes
07:49:07 <Vq^> emu: check in /proc/cpuinfo
07:49:12 <Baughn> Linux the kernel.. no. Userspace, yes, unless userspace tries to check for itself.
07:49:26 <emu> well i am looking at that, but not sure how to tell if they're real or not. physical ids look suspicious
07:49:43 <Baughn> emu: Check for ht in the CPU feature list?
07:49:52 <emu> yep
07:50:10 <Baughn> If you've got that /and/ it's a P4, it's using hyperthreading
07:50:16 <emu> p4 xeon
07:50:24 <Baughn> Dual-core CPUs also have it, though. I don't know about Ppentium-dee.
07:50:26 <emu> so it's really 2 cores with ht to make it look like 4 cpus
07:50:48 <emu> so i should leave -N at 2 according to docs
07:51:33 <Baughn> Right, and it makes perfect sense that ghc spawns more threads than you ask for; -N counts up worker threads, whereas the others likely spend all their time waiting.
07:54:21 <nominolo> emu: what happens if you specify -N1
07:54:33 <Cale> phew, done
07:54:48 <Cale> lots of conversation on the lists lately
07:55:12 <emu> nominolo: takes twice as long as -N2 to run real time
07:55:33 <nominolo> emu: makes perfect sense, then
07:55:50 <emu> im running some longer tests now
07:56:33 <emu> i think you are right about start-up time being a bit significant on fast cases
07:57:19 <emu> hmm, here's a bit of a curious run: -N2 36sec, -N3 39sec, -N4 32 sec, -N5 1m12s
07:58:53 <emu> oh well, i'm gonna have to play with this a lot to figure out how to tune it well
07:59:38 <nominolo> hm, i guess you have the machine not exclusively ;), second, if memory latency is the dominant factor, than more (virtual) cpus won't speed up further.  and -N5 might trigger some weird switching or something.  but, dunno
07:59:59 <emu> na i'm the only one using it
08:00:03 <pejo> Isn't HT exactly for speeding up the case where you have things waiting on memory?
08:00:19 <nominolo> yup.  does ghc provide useful profiling support for this kind of stuff?
08:00:41 <nominolo> pejo: not if all are waiting
08:01:15 <nominolo> pejo: this only works if one is waiting and another has a tight loop
08:06:43 <emu> CPU: 3; EIP is at sample_to_timespec+0x19/0x3a.  heh, i've been getting this msg sometimes when running Cabal. doesn't seem to do anything bad though.
08:18:09 <emu> gonna be interesting to see how this works out when there is explicit message passing
08:20:52 <lray80de>  I get the following ridicolous error:
08:20:52 <lray80de> Xcerpt/Methods/Similarity/EditDistance2.hs:32:25:
08:20:52 <lray80de>     parse error on input `='
08:20:52 <lray80de> make: *** [xcerpt] Error 1
08:20:52 <lray80de> Problem, without the "-cpp"-Parameter set, it works, with "-cpp"-Parameter, I get the error...
08:21:12 <emu> maybe it's parsing something as a cpp directive
08:21:26 <emu> begin any lines with #? ;)
08:21:30 <Pastorn> i need help! how do i write something that does this:
08:21:50 <emu> > putStrLn ""
08:21:51 <lambdabot>  <IO ()>
08:21:55 <lray80de> not in that file. need the cpp-directive for another file. here is the source of the "problem-file": http://paste.lisp.org/display/32146
08:22:01 <nominolo> emu: what are you using? STM?
08:22:09 <emu> nominolo: yea
08:22:26 <Pastorn> ["1","2","3","4","5","6","7","8","9"] -> ["123","456","789"]?
08:22:55 <emu> might be parsing FOO() as a macro
08:23:09 <xerox> > takeWhile (not . null) . iterate (take 3) $ ["1","2","3","4","5","6","7","8","9"]
08:23:11 <lambdabot>  [["1","2","3","4","5","6","7","8","9"],["1","2","3"],["1","2","3"],["1","2",...
08:23:15 <nominolo> well, is there a message passing mechanism with a lockfree implementation underneath?  otherwise, i don't think it could be really fast.
08:23:31 <integral> cjeris++
08:23:33 <xerox> ops.
08:24:11 <emu> nominolo: uh, how is STM implemented in GHC?
08:24:22 <emu> lray80de: what line is that?
08:24:37 <lray80de> 32
08:24:42 <emu> (let me guess. its the one with the comment about algorithmic complexity)
08:24:46 <nominolo> emu: oh, er .. dunno .. but most likely lock-free
08:25:19 <emu> o forgot about line num formatting. hmm, it's around the DFA comment
08:25:29 <lray80de> yepp.
08:26:09 <givi> Hey guys! Can someone tell me how to register my nickname here?
08:26:13 <lray80de> emu: it's the "doDiag a [] nw n w" ...
08:26:16 <emu> um, im guessing the backslashes are throwing it for a fit
08:26:33 <xerox> > let munch n = unfoldr (\xs -> case xs of [] -> Nothing; xs -> Just (take n xs, drop n xs)) in munch 3 ["1","2","3","4","5","6","7","8","9"] -- Pastorn
08:26:34 <lambdabot>  [["1","2","3"],["4","5","6"],["7","8","9"]]
08:26:35 <glguy> givi: /msg nickserv help
08:26:54 <lray80de> emu: but, there are comments in front of...
08:27:03 <Pastorn> hmmm
08:27:06 <emu> lray80de: not C comments
08:27:17 <xerox> ops..
08:27:19 <lray80de> aarrgghhh.... okay...
08:27:23 <lray80de> I'll try...
08:27:28 <emu> could try putting // or something
08:27:31 <emu> --//
08:27:39 <xerox> > let munch n = unfoldr (\xs -> case xs of [] -> Nothing; xs -> Just (join (take n xs), drop n xs)) in munch 3 ["1","2","3","4","5","6","7","8","9"]
08:27:40 <lambdabot>  ["123","456","789"]
08:27:44 <glguy> > let munch n = unfoldr(liftM2(>>)(guard.not.null)(return.splitAt n)) in munch 3 ["1","2","3","4","5","6","7","8","9"]
08:27:45 <lambdabot>  [["1","2","3"],["4","5","6"],["7","8","9"]]
08:27:46 <Pastorn> !!
08:28:51 <Pastorn> thanks! now i just have to learn unfoldr
08:29:10 <xerox> You're welcome.
08:29:42 <lray80de> emu deleted the comments, is working now...
08:29:56 <lray80de> ...would never have thought of that! thnx.!
08:31:00 <emu> heh, they were neat looking comments though!
08:31:19 <emu> um, might be a ghc option to turn off -cpp you could put in that file alone
08:32:46 <emu> docs say something about backslashes like yours. if you always put a space after them, should be ok with gnu cpp
08:33:52 <Pastorn> > join Nothing
08:33:53 <lambdabot>  Add a type signature
08:34:02 <Pastorn> > join Nothing :: Char
08:34:03 <lambdabot>  Couldn't match `Char' against `m a'
08:34:23 <Pastorn> > join Nothing :: Maybe Char
08:34:24 <lambdabot>  Nothing
08:34:40 <Pastorn> > join Just '2' :: Maybe Char
08:34:41 <lambdabot>  Couldn't match `a -> Maybe Char' against `Maybe a'
08:34:46 <Pastorn> > join Just '2'
08:34:47 <lambdabot>  Couldn't match `a1 -> a' against `Maybe a1'
08:34:54 <Pastorn> kill me now
08:35:40 <dons> :t join
08:35:41 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
08:35:53 <dons> > join (Just (Just '2'))
08:35:54 <lambdabot>  Just '2'
08:36:01 <dons> > join (Just Nothing)
08:36:02 <Pastorn> > join $ join Just '2' :: Maybe Char
08:36:02 <lambdabot>  Add a type signature
08:36:02 <lambdabot>  Couldn't match `a1 -> m (m a)' against `Maybe a1'
08:36:07 <metaperl> man, phooey looks good : http://conal.net/phooey/
08:36:08 <lambdabot> Title: Phooey: A Functional UI Library
08:36:35 * dons wonders why there's been 500 hits on sequence.complete.org in the last hour
08:36:40 <emu> yea though the last bit was funny "this last part is old. it's broken now. please help!"
08:36:53 <metaperl> dons - i dont know. I just visited it just once just now
08:36:57 <dons> usually HWN articles get about 500 a week
08:36:57 <Vq^> dons: i'm guilty of one or two of them
08:37:08 <dons> is it on digg maybe?
08:37:15 <emu> can you see the logs
08:37:42 <emu> (specifically, referer)
08:37:42 <dons> its about 1 hit a second atm
08:37:47 * dons looks in the logs
08:37:55 * emu quits refreshing his browser
08:37:58 <dons> heh
08:38:00 <chessguy> we've surpassed the number of lisp solutions now
08:39:26 <dons> cool
08:40:19 <dons> ah, looks like the usual suspects, reddit, plnews, lwn. so just a good article I guess
08:42:38 <paolino> how I insert a newline in a literate code ?
08:48:54 <dons> ah, now it makes sense. all the sequence traffic is over rss, basically.
08:49:11 <dons> 22k hits on the feed this week. i guess clients refresh a lot :/
08:49:43 <chessguy> > length [1.0..2.0]
08:49:44 <lambdabot>  2
08:50:02 <chessguy> > [1.0..2.0]
08:50:04 <lambdabot>  [1.0,2.0]
08:50:47 <emu> heh
08:50:52 <Daveman> :p
08:50:57 <metaperl> dons - if you are doing a lot of file-system manipulation, doesnt using a value-oriented language like Haskell become cumbersome?
08:50:58 <emu> did you expect haskell to defeat the real numbers?
08:51:27 <ex0r> if I import another .hs file using import file, then load the file that statement is in, why does WinHugs tell me Main is already loaded?
08:51:31 <metaperl> dons - i mean things like copying files, renaming files, etc
08:51:32 <dons> metaperl: hmm, like darcs?
08:51:53 <dons> why? you're using a first-class action oriented language too, remember
08:52:03 * metaperl didn't think of darcs
08:52:07 <fasta> Would it be correct to say that the same algorithm on an STArray runs asymptotically as fast as an one with DiffArray? It seems that STArray by definition is single threaded, which would imply that it holds.
08:52:08 <dons> so you can string together your manipulting functions in interesting ways
08:52:32 <dons> i.e. haskell treats imperative statements as first class citizens
08:52:40 <dons> you can pass them to functions, put them in data structures
08:52:42 <dons> map over them
08:53:01 <metaperl> I see... now how about this use case of optional arguments to get things done on the fly: http://sequence.complete.org/node/248
08:53:02 <lambdabot> Title: Python optional args - great for evolving source code | The Haskell Sequence
08:53:04 <dons> > sequence_ $ reverse [readFile "/tmp/x", writeFile "/tmp/y"]
08:53:05 <lambdabot>    Expecting a function type, but found `a'
08:53:05 <lambdabot>    Expected type: IO String
08:53:05 <lambdabot> ...
08:53:22 <dons> i actually use this ability to treat imperative actions as data quite a bit for shell scripts
08:53:29 <metaperl> wow, that is some crisp code
08:53:51 <metaperl> and we cant forget ndm's unwords . reverse . words -- recently posted on HWN
08:55:13 <emu> fasta: well, DiffArrays need to preserve the diffs of changes
08:55:34 <emu> fasta: i would say that STArray will not only run asymptotically as fast, but with less overhead
08:55:52 <emu> (and i converted a DiffArray-using algorithm to STArray the other day, and it really helped)
08:56:25 <fasta> emu: I meant a symmetrical relationship
08:57:02 <emu> i'm not sure what the compiler is doing behind the scenes with the DiffArray. technically, if you don't have old copies, it should have pretty much identical performance characteristics to STArrays. or so i would think.
08:57:36 <fasta> emu: in an imperative language you also don't make use of the old copies, since there are none :)
08:57:40 <paolino> when I paste a piece of code in an html adding those '>' at the beginning of every code line ,browsers don't render the newlines in the code
08:57:41 <emu> indeed
08:58:02 <fasta> emu: which suggest that STArray is a hack
08:58:20 <emu> for the insufficiently smart compiler?
08:58:22 <fasta> emu: and could be optimized away
08:58:27 <glguy> isn't an STArray just an IOArray wrapped?
08:58:50 <glguy> ?fptools Data.Array.ST
08:58:51 <lambdabot> http://darcs.haskell.org/packages/base/Data/Array/ST.hs
08:58:55 <fasta> emu: yes, well, "in theory then" ;)
08:59:18 <emu> STArray is sequenced by the opaque type variable, in place of the notion of "real time" that IO has, I guess
08:59:26 <emu> er, ST is.
09:00:27 <dons> metaperl: consider the abstractions in mkcabal, whose entire purpose in life is to create cabal directories and files
09:00:49 <dons> i.e. what you'd use a shell script for normally: http://www.cse.unsw.edu.au/~dons/code/mkcabal/mkcabal.hs
09:00:53 <emu> dons: i saw that mkcabal in your transcript, wasn't aware of it before. looks useful.
09:00:58 <lurker76> paolino: You could wrap the code in a <pre> element.
09:01:11 <dons> metaperl: in particular, see how :
09:01:16 <dons>     flip runReaderT st $ sequence_ $ if mode == TheWorks
09:01:16 <dons>                                      then doEverything
09:01:16 <dons>                                      else doCabalOnly
09:01:31 <dons> executes either doEverything (a list of imperative actions)
09:01:34 <dons> or doCabalOnly
09:01:41 <dons> where doCabalOnly =
09:01:41 <dons>     [ createCabal
09:01:41 <dons>     , createSetup
09:01:41 <dons>     , cabalDone ]
09:02:01 <dons> so, the imperative script is stored as data, we can play with it and flip it around
09:02:08 <metaperl> dons - yes, that is quite clear... I like it a lot better than standard shell/perl scripting
09:02:32 <dons> so the key is having statements'
09:02:41 <dons> (in the imperative language sense)
09:02:43 <dons> as first class values
09:02:45 <xerox> actions
09:02:54 <dons> or actions as we call them
09:03:21 <dons> (but I say statements to emphasise how they're not first class in imperative languages -- the ordering is baked in, you can't flip and play with them)
09:04:04 <fasta> but this: a[variable][variable2][variable3] can be done much easier in C.
09:04:06 <dons> this really highlights the joy of using a combinator library (i.e. >>= and >>) to implement flow control
09:04:11 <metaperl> dons - that last stmt confuses me a bit. you mean they are first class/manipulable in Haskell , but not imperative languages?
09:04:19 <dons> fasta, what, 3-d arrays?
09:04:23 <fasta> dons: right
09:04:38 <nomeata> Is there a good simple alternative to HaXml if I want to use XML just as a data storage? The XML would be very simple (basically a value-key mapping), and I would use plain text but I do not want to worry about escaping strings.
09:04:38 <dons> fasta, what's that got to do with it though?
09:05:15 <fasta> dons: well, sometimes 3d arrays make sense, and expressing algorithms with them in Haskell has high overhead
09:05:21 <fasta> It's wordy
09:05:22 <dons> metaperl: i mean, how do you write: f . g (reverse [readFile "a", readFile "b"])
09:05:37 <dons> unless your language is able to treat actions as data?
09:05:56 <dons> fasta, just syntax. use the array preprocessor
09:05:57 <emu> fasta: there is a TH library to enable syntax like that in haskell
09:06:07 <fasta> emu: how interesting, where?
09:06:16 <dons> fasta, but what's that got to do with the flexibility of first classactions?
09:06:21 <dons> (or doesn't it -- just a random point?)
09:06:39 <emu> hmm i saw it on haskell.org last night too
09:06:52 <fasta> dons: I interpreted it in a general way: that Haskell is not fantastic for everything
09:06:58 <dons> ah no.
09:07:12 <emu> http://haskell.org/haskellwiki/Library/ArrayRef
09:07:14 <lambdabot> Title: Library/ArrayRef - HaskellWiki
09:07:17 <dons> i was just pointing out that shell scripting tasks are fairly good (and fun!)
09:07:20 <fasta> emu: that doesn't use TH
09:07:28 <Cale> fasta: it is?
09:07:31 <dons> since you have such freedom to manipulate actions
09:07:35 <emu> oh hmm that wasnt it
09:07:41 <emu> i saw another one soemewhere
09:07:43 <Cale> fasta: 3-d arrays are easy to deal with in Haskell.
09:07:59 <fasta> Cale: 3-d arrays in the ST monad, then
09:08:11 <dons> i.e. arr ! (4,2,3)   -- ;)
09:08:43 <emu> STPP its called
09:08:53 <fasta> emu: breaks
09:08:56 <fasta> emu: not maintained
09:09:05 <fasta> emu: uses a preprocessor
09:09:08 <Cale> Mutable arrays are slightly more wordy, but they're only a small constant factor more wordy (I'd say less than 2) than mutable arrays in most other languages.
09:09:22 <emu> writeArray arr (4,2,3) v
09:09:25 <Cale> Most of that wordiness comes from the choice of names for things.
09:09:34 <Cale> readArray/writeArray
09:09:36 <emu> you could probably turn that into an op easily
09:09:38 <Cale> yeah
09:09:51 <fasta> ! is "standard for reading"
09:09:56 <fasta> What's good for writing?
09:10:12 <Cale> People have set up things where they used =: for assignment even.
09:10:26 <emu> i use an STUArray to store values indexed by edges (node,node) and i just use tuples to represent edges everywhere, including the array refs
09:10:37 <dons> actually, using bulat's arrayRef  lib would be the way to go, no?
09:10:41 <dons> if you use mutable arrays a lot
09:10:45 <dons> since you get := and friends
09:10:54 <fasta> dons: Bulat isn't ghc 6-6 compatible
09:11:06 <fasta> Or Bulat's lib, even
09:11:27 <Cale> yeah, you can do that.
09:11:29 <dons> the other option is the new ndp arrays, which have a bytestring interface
09:11:43 <dons> i suspect they'll be the most successful in the end, since the interface is list-like
09:11:46 <dons> and rich
09:11:52 <fasta> dons: url?
09:11:59 <Cale> Arrays are terribly overused in the imperative world though.
09:12:02 <dons> ?where dph
09:12:03 <lambdabot> http://haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
09:12:09 <Cale> Map and Set are far more practical most of the time.
09:12:15 <dons> fasta, its brand new though. not offically released till jan
09:12:33 <dons> (we're waiting on some more optimisations spj wants to add to ghc)
09:12:34 <emu> yes, the only reason i'm using arrays is for a densely packed node-array
09:12:46 <Cale> That's not to say that there aren't places where you really need arrays, just that they're way less commonly needed in Haskell.
09:13:03 <Cale> Representing graphs is probably a decent use of them.
09:13:16 <dons> fasta, one nice thing is that the ndp arrays also happen to run on parallel cpus
09:13:19 <Cale> (though there are other tactics)
09:13:24 <dons> so that might even be a killer feature
09:13:32 <dons> i guess we'll see in the coming year
09:13:41 <emu> i originally represented it with a 2d adjacency map but that turned out to be too sparse, and i switched to a 1d array of Data.Maps
09:13:43 <paolino> CAle , which ?
09:13:48 <emu> IntMaps actually
09:13:54 <nomeata> What is a good way of passing key-value data in files from python to haskell: Plain text files with key:value pairs, XML or something else?
09:14:24 <dons> i.e. here, implementing the dot product over 2 unboxed arrays, in parallel;  dotp xs ys = sumU (zipWithU (*) xs ys)
09:14:30 <dons> is that shorter in *any* language? :)
09:14:44 <ToRA> plain text in the format with: [(key,value)] ?
09:14:53 <metaperl> nomeata - CosmicRay recently wrote a config module
09:15:12 <metaperl> nomeata - Flippi shows how to do that sort of thing too
09:15:12 <emu> dons: what kind of parallel strategy is it using?
09:15:17 <dons> you need -fparr for that array code to run on multiple cores though
09:15:26 <dons> emu, its using gang threads underneath
09:15:35 <nomeata> I just wonder whatâs more hassle: Getting the escaping (e.g. of newlines) right, or parsing and creating XML.
09:15:35 <dons> and the various combinators , ie.. sumU, zipWithU
09:15:41 <dons> do their own strategy
09:15:51 <dons> then fusion kicks in, stripping out intermediate arrays
09:16:56 <dons> i know, anyway, that i want a combinator interface to my arrays, before i'll use them widely
09:17:14 <paolino> the power of haskell, crazy things from clever people everywhere
09:17:16 <dons> if they happen to run in parallel, i might use arrays even more often
09:18:10 <cjeris> dons: gang threads? you mean like Raiders jackets?
09:18:17 <nmessenger> nomeata: A quick google turned up a JSON parser: http://www.lshift.net/blog/2006/07/13/writing-ajax-applications-in-haskell
09:18:20 <lambdabot> Title: LShift Ltd. Â» Writing AJAX applications in Haskell, http://tinyurl.com/yyfl2g
09:18:29 <dons> close, cjeris ;)
09:18:31 <emu> if you use haskell in the wrong neighborhood, you might get jumped
09:18:40 <metaperl> so when you define your own datatype, when do you use deriving (Show) and when do you implement it with showsPrec?
09:19:00 <dons> you derive Show when you want it to look like the data defn
09:19:12 <dons> and you implement an instance when you want some custom representation
09:19:37 <emu> i implemented Show for some cyclic data structures so uh, the printer wouldn't go nuts
09:19:38 <metaperl> I see
09:19:53 <dons> that one too :)
09:19:58 <ms_> nomeata: the json haskell stuff is fine - I've used it for a couple of applications now
09:19:59 <metaperl> like trees?
09:20:00 <dons> > ord -- is anothe example
09:20:00 <emu> also for some data where values could be undefined since they would never be touched -- except by default Show
09:20:01 <lambdabot>  <Char -> Int>
09:20:27 <dons> metaperl: yeah, actually
09:20:34 <metaperl> I see
09:20:35 <dons> the Data.Tree has a special show (I think)
09:21:07 <earthy> hm. this code I've written is praticularly slow...
09:21:09 <emu> i have uplinks and downlinks so, it gets bad
09:21:10 <dons> at least it has some special 'draw' functions, which would make a useful show instance
09:21:25 <nomeata> JSON looks interesting
09:21:40 <ms_> it's quite a nice lowest common denominator
09:21:42 * earthy looks at dons
09:21:46 <earthy> @localtime dons
09:21:47 <lambdabot> Local time for dons is Wed Dec 13 04:14:48 2006
09:21:50 <nmessenger> nomeata: I'm pretty sure Python has a JSON serializer
09:21:54 <earthy> *right*. :)
09:22:01 <Masklinn> nmessenger > most languages have one
09:22:02 <emu> he's an early riser
09:22:12 <dons> ah yes
09:22:15 <dons> hmm
09:22:16 <Masklinn> i'm pretty sure json.org has a list
09:22:23 * dons shouldn't drink coffee so late
09:22:30 <Masklinn> the thing is that Python datatypes map really well to json
09:22:37 <Masklinn> so serializing is easy
09:22:44 <earthy> okay. tab separated tuples filling 1 screen at 80x24 characters.
09:23:17 <emu> I used SerTH for serialization.  you can write $(deriveSerializable ...) for simple stuff
09:23:21 <nmessenger> Masklinn: Well, there are maps and lists.  Pretty universal I'd say.  ;)
09:23:27 <earthy> that's like... 200 elements wide.
09:23:42 <earthy> now let's see what dazzle likes about that. :)
09:23:46 <nomeata> Which JSON module should be used?
09:23:48 <emu> unfortunately there seems to be a bug where it cannot distinguish between "Nothing" of different Maybe types in your data structure
09:23:52 <Masklinn> the thing is that they're basic Python datatype. Plus try to map PHP arrays to JSON. Are they arrays? hashes? both? none?
09:24:14 <Masklinn> s/basic/core/
09:24:44 <ms_> nomeata: there's more than one?
09:25:02 <dons> ?users
09:25:02 <lambdabot> Maximum users seen in #haskell: 288, currently: 267 (92.7%), active: 42 (15.7%)
09:25:09 * dons attempts sleep - night all
09:25:10 <earthy> nice number. :)
09:25:16 <nmessenger> Masklinn: JSON == Javascript's core datatype as well.
09:25:31 <nmessenger> Masklinn:  ;)
09:25:35 <Masklinn> ms_ > json.org has two of them (JSON.hs and HaskellNet)
09:25:43 <ms_> JSON.hs is fine
09:26:05 <ms_> but take it from the lshift blog cos there's a missing type from the original one iirc
09:26:08 <Masklinn> nmessenger > well obviously, my point was that Python's core datatypes map directly to JS' core datatypes, including compounds, apart from tuples
09:26:18 <nomeata> ok, thanks
09:26:20 <emu> dons: nite
09:28:11 <nomeata> hmm. python has three json modules. sometimes I hate choice :-)
09:28:21 <Masklinn> use simplejson
09:28:30 <nmessenger> Eenie, meenie, minie
09:28:45 <norpan> yes, choice is bad
09:29:02 * ms_ proposes state control of json modules to eliminate annoying choice
09:29:04 <norpan> in the aspect of having to choose
09:29:45 <nomeata> There is a idiom in German: âQual der Wahlâ, which means âThe suffering of choiceâ
09:30:03 * nomeata is a unicode national double quote show off.
09:30:06 * earthy likes that proverb
09:31:05 <nomeata> But itâs always better than the âWahl der Qualâ. For example if you can freely decide what to program something in: vb, Java or C++ :-)
09:31:32 <nmessenger> GUARDS SEIZE HIM!
09:31:56 <sjanssen> is it me, or has haskell-cafe become outrageously busy the past few days?
09:31:58 <lisppaste2> metaperl pasted "dons - deriving show works for this recurisve data type" at http://paste.lisp.org/display/32156
09:32:00 <norpan> "vara i valet och kvalet" as we say in swedish
09:32:28 <nomeata> sjanssen: I noticed as well. Less Cafe, more Highway side fast food restaurant.
09:32:55 <sjanssen> heh
09:33:36 <metaperl> dons - I'm going to lunch. dont answer that question now :)
09:36:07 <earthy> metaperl: ofcourse that works
09:36:36 <metaperl> no dons said ... never mind... i will talk later
09:36:43 <alexj__> shapr: ping
09:37:21 <nmessenger> Reply from shapr: bytes=32 time<1ms TTL=128
09:37:22 <nomeata> hmpf. it seems the python-json-packages in debian come without documentation.
09:37:23 <nmessenger> Reply from shapr: bytes=32 time<1ms TTL=128
09:37:25 <nmessenger> Reply from shapr: bytes=32 time<1ms TTL=128
09:37:39 <nmessenger> Packets: Sent = 4, Received = 4, Lost = 0 (0% loss),
09:37:54 <alexj__> shapr: you here?
09:38:00 <nomeata> I think alexj__ has locally defined (:) = flip ($)
09:38:16 <nomeata> because I need to write "ping shapr" to get that output :-)
09:38:52 <chessguy> @seen shapr
09:38:52 <lambdabot> shapr is in #scannedinavian, #haskell-blah and #haskell. I last heard shapr speak 5h 1s ago.
09:39:08 <chessguy> heh. #scannedinavian?
09:39:10 <alexj__> nomeata: sometimes behavior here is suprising.
09:39:30 <nomeata> alexj__: as long as it has no side effects, thatâs ok with me.
09:39:37 <alexj__> :-)
09:41:32 * nomeata finds docs for simpejson on web.archive.org. Sounds like lazy hosting, before the garbage collection kicks in.
09:47:55 <lisppaste2> emu pasted "curious Concurrent behavior" at http://paste.lisp.org/display/32157
09:51:11 <lisppaste2> emu annotated #32157 with "that is, with -threaded" at http://paste.lisp.org/display/32157#1
10:03:08 <lisppaste2> Saizan pasted "Levenshtein distance" at http://paste.lisp.org/display/32161
10:06:39 <nmessenger> I wasn't sure so I checked, interesting: http://en.wikipedia.org/wiki/Levenshtein_distance
10:06:55 <norpan> yeah "similarity"
10:07:17 <norpan> or do you mean teh speling
10:08:05 <nmessenger> The meaning.
10:08:34 <Saizan> mmh i wonder if it can be written in a more haskellish-way
10:09:04 <nmessenger> I'm far too much of a newbie to understand the paste, though
10:10:16 <norpan> well, uncommented it's hard to grasp even for an expert
10:10:50 <Saizan> yeah, good point..
10:11:03 <norpan> it seems to use ' ' as some kind of special marker
10:11:09 <nmessenger> Oh and I'm pretty sure zipWith (,) == zip
10:11:17 <nmessenger> ;)
10:11:27 <norpan> indeed
10:12:43 <Saizan> true :D
10:13:04 <Saizan> ' ' is used only to shift the position of the chars
10:13:23 <Saizan> so that they are aligned starting from 1 and not from 0
10:13:26 <norpan> what's the complexity?
10:13:32 <Saizan> n^2
10:13:38 <Saizan> err, n*m
10:13:41 <wy> Hi, I can be here from my office now :-)
10:13:56 <Saizan> where n and m are the lengths
10:14:00 <norpan> yeah
10:14:56 <lisppaste2> emu pasted "simple type-class confusion" at http://paste.lisp.org/display/32163
10:15:47 <norpan> instance FooTypes, not FooThing
10:16:07 <lisppaste2> emu annotated #32163 with "browser butchered code" at http://paste.lisp.org/display/32163#1
10:16:33 <norpan> ah
10:16:34 <emu> hmm?
10:16:36 <emu> oh
10:16:54 <emu> yea that's easier to read
10:17:36 <emu> so i'm confused why i can't return BarThing(). it is an instance of FooThing
10:17:54 <norpan> yes, but you must be able to return any FooThing
10:18:36 <allbery_b> empty instance declaration?
10:19:37 <norpan> type variables are implicitly all-quantified, so a function (F s) => s must be able to return any member of the class F
10:19:47 <norpan> any instance
10:20:42 <emu> hm
10:21:01 <emu> well i wanted to have it such that foo can return anything of class FooThing
10:21:23 <norpan> functions that can return anything are not much use
10:21:31 <norpan> how would you possibly use the return value
10:21:43 <emu> via the class
10:22:00 <norpan> yes, but then how can it know which type to use
10:22:10 <norpan> types must be known at compile time
10:22:18 <emu> sure. it's explicit in the code.
10:22:41 <norpan> but not in the callers code
10:22:46 <emu> if i call foo (Bar ()) then it's choosing the Bar instancce and seeing what it does
10:23:01 <norpan> that'Â¨s not the way it works
10:23:13 <chessguy> @hoogle (->)
10:23:13 <lambdabot> Did you mean: (->)
10:23:14 <lambdabot> Prelude.undefined :: a
10:23:14 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
10:24:17 <norpan> the code calling the foo cuntion gets to choose which type in the class it wants
10:24:25 <norpan> the foo function
10:24:32 <emu> well ok; i was envisioning FooTypes as being the class of types which have an overloaded defn of foo that returns something of the class FooThing
10:24:56 <emu> right, and it makes that choice by doing Bar ()
10:25:17 <norpan> it works the other way around, make BarThing an instance of FooTypes instead
10:25:20 <emu> well i am seeing what you are saying
10:26:09 <norpan> that means that BarThing is one of the types foo can return (if you change the type of foo) and then the caller can choose
10:26:47 <emu> that doesn't make any sense. then i have to define a foo for BarThing
10:26:55 <norpan> yes
10:27:13 <emu> that's not what i'm aiming for
10:27:24 <emu> let me apply an interpretation to this and see if you think of a better way:
10:27:48 <emu> class FooThing is a class of states.  class FooTypes is a class of state machines.
10:27:51 <Saizan> making FooTypes a two parameter class?
10:28:05 <emu> foo is the initial state function
10:28:06 <norpan> if Bar and BarThing are connected, then make it a multi-parameter class
10:28:19 <emu> that requires an extension?
10:28:24 <norpan> yes
10:28:39 <emu> so there's no way to do this in H'98?
10:28:48 <norpan> no, that's why they made an extension :)
10:29:43 <norpan> class FooTypes a s | a -> s
10:29:56 <norpan> instance FooTypes Bar BarThing
10:30:11 <lisppaste2> emu annotated #32163 with "it compiles now" at http://paste.lisp.org/display/32163#2
10:30:55 <norpan> yeah, and add a -> s or s -> a otherwise it will be trouble when you try to use it
10:31:08 <norpan> but you'll notice :)
10:31:11 <emu> i see
10:31:19 <emu> that's the functional dep?
10:31:37 <norpan> yeah, that essentially means that there is only one instance for each a
10:31:50 <norpan> (or s)
10:32:02 <norpan> that there can only be one instance
10:32:14 <emu> i see.  i will ponder on this some more, then.
10:32:15 <norpan> so that the compiler can infer the other type
10:32:51 <emu> thanks for the explanation
10:33:36 <norpan> sure
10:36:58 <Saizan> norpan, if i understood correctly the problem was that the caller of foo could "request" any istance of FooThing?  ..instead it foo returned an arbitrary istance
10:37:16 <Saizan> s/it//
10:37:30 <norpan> yeah, if a funciton returns s, then it means it can return ANY s
10:37:40 <lisppaste2> nmessenger pasted "False Parsec grammar (one of my first useful dabblings!)" at http://paste.lisp.org/display/32167
10:37:44 <norpan> based on what the caller wants
10:38:27 <norpan> parsec is really the shit
10:38:51 <nmessenger> Fo' realz
10:39:24 <norpan> it's so nice not having to deal with code genators
10:40:32 <nmessenger> False is a nicely sadistic little language, too.  http://wouter.fov120.com/false/
10:40:35 <lambdabot> Title: Wouter's False page
10:42:49 <chessguy> man, it's amazing the difference between what happens when someone asks for help here, and what happens when they ask for help in another language channel
10:43:41 <chessguy> i wonder why that is
10:43:59 <lisppaste2> ptolomy pasted "So memory hungry.. why?" at http://paste.lisp.org/display/32169
10:44:30 <ptolomy> I'm making a simplistic text indexer for kicks, and it stack overflows on reasonably large data files.
10:44:52 <roconnor> stack overflow!
10:44:55 <ptolomy> the tokenize' function is allocating a good 95% of my memory.
10:45:20 <ptolomy> not sure why.. seems like it'd be tail recursible.
10:45:22 <ptolomy> That's not a word..
10:45:49 <roconnor> I'm always amazed when anything stack overflows in haskell, I thought only primops use the stack.
10:46:13 <roconnor> maybe you are counting the length of something using (+1)
10:46:34 <ptolomy> I wonder if it be some of the Data.Map operations..
10:46:39 <roconnor> if you aren't careful that is a good way of overflowing the stack.
10:47:27 <LoganCapaldo_> I have no idea, but maybe its the forced strictness
10:47:35 <roconnor> http://r6.livejournal.com/91508.html
10:47:36 <lambdabot> Title: r6: Lazy vs. Strict
10:47:46 <ptolomy> LoganCapaldo_: The forced strictness is a result of my trying to eliminate my overflow.
10:47:51 <LoganCapaldo_> heh
10:48:01 <LoganCapaldo_> well then its definitely not that :)
10:48:52 <Vq^> roconnor: is there some simple replacement for (+1) that doesn't cause this?
10:49:30 <roconnor> Vq^: note really.  Sprinkinging strictness anotations was the key to solving my problem.
10:49:38 <roconnor> not really
10:49:47 <Vq^> ok
10:50:42 <roconnor> ptolomy: what are your recursive functions?
10:50:51 <ptolomy> tokenize' is the one that is eating  up memory.
10:50:57 * chessguy would slap his router, but is not being violent today
10:50:58 <ptolomy> only non-library recursive function, really.
10:53:45 <roconnor> ptolomy: what type are you actually using for a
10:54:09 <ptolomy> roconnor: In that case, ByteLoc
10:54:11 <complaisant> >map (+) [1,2]
10:54:15 <complaisant> > map (+) [1,2]
10:54:16 <lambdabot>  Add a type signature
10:54:19 <ptolomy> but both ByteLoc and LineLoc behave teh same.
10:54:27 <complaisant> map (+) [1,2]
10:54:39 <ptolomy> f> foldl1 (+) [1,2]
10:54:42 <ptolomy> > foldl1 (+) [1,2]
10:54:44 <lambdabot>  3
10:54:50 <complaisant> > map (+) [1,2]
10:54:50 <lambdabot>  Add a type signature
10:55:07 <complaisant> > 1+2
10:55:08 <lambdabot>  3
10:55:19 <roconnor> ptolomy: hmm, does chaning ByteLoc to a newtype instead of a data do anything?
10:55:37 <roconnor> newtype ByteLoc = ByteLoc Int deriving (Eq, Show)
10:55:51 <complaisant> > paste
10:55:51 <roconnor> ... it probably shouldn't make a difference
10:55:52 <lambdabot>  Not in scope: `paste'
10:55:54 <complaisant> > paste?
10:55:54 <lambdabot>  Parse error
10:56:02 <roconnor> ?paste
10:56:03 <lambdabot> http://paste.lisp.org/new/haskell
10:56:32 <ptolomy> roconnor: Nope, not really.
10:56:33 <Taral> gah
10:56:37 <Taral> having trouble with callCC.
10:56:37 <rahikkala> I wonder why http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Reader.html claims to document the Monoid class
10:56:40 <lambdabot> http://tinyurl.com/y5j3az
10:56:43 <Taral> :<
10:56:56 <roconnor> Taral: but callCC is so easy :P
10:57:02 <Taral> rubbish
10:57:10 <Taral> in the expression:
10:57:13 <Taral> callCC $ \c -> ...
10:57:15 <Taral> what is the type of c?
10:57:19 * ptolomy avoids callCC whenever possible.
10:57:24 <Taral> it's apparently not (forall b. a -> m b)
10:57:27 <ptolomy> Which seems to be all the time.
10:57:41 <Taral> ptolomy: callCC is one of those things that when you need it, nothing can replace it.
10:57:54 <complaisant> hi
10:57:58 <Trevion> hello
10:58:02 <complaisant> i have this http://paste.lisp.org/display/32171#1
10:58:15 <complaisant> & i need to make a program that converts pointwise to pointfree
10:58:21 <complaisant> anyone can give me a help?
10:58:30 <complaisant> i don't know where to start
10:58:30 <Taral> is it homework?
10:58:36 <complaisant> yes
10:58:46 <roconnor> ptolomy: the problem with ! for strictness is that it only puts expressions into head normal form.   So I've only found them usefull for primitive types such as Int.
10:59:08 <roconnor> @pl \x -> x
10:59:08 <lambdabot> id
10:59:09 <ptolomy> So it isn't a replacement for $! then?
10:59:21 <roconnor> $! has the same problem
10:59:34 <roconnor> rumour has it there is a $!! that calls deepseq
10:59:38 <ptolomy> right.
10:59:45 <roconnor> that puts a term in normal form as far as I know
10:59:46 <ptolomy> Never had a need for that thus far.
10:59:57 <complaisant> i don't know howto apply the deduction laws to convert pw to pf
10:59:59 <roconnor> I don't know how to considert Bytestring
11:00:00 <zeeeee> why can't I write 'then' on the same indent level as the 'if' in a 'do', but i can do this outside a 'do'?
11:00:30 <LoganCapaldo_> zeeee do is evil?
11:00:35 <LoganCapaldo_> hehe just kidding
11:00:56 * ptolomy is opposed to putting 'then' at the same indent level as 'if' in general.
11:01:00 <complaisant> Taral : have u seen the code? . can u give me a hint on howto start ?
11:01:13 <Taral> complaisant: There's not much there. Just a data structure.
11:01:13 <zeeeee> well, it's just that my emacs indenter always puts them on the same level
11:01:20 <ptolomy> Hm.
11:01:29 <zeeeee> i'm using the haskell emacs package
11:01:33 <zeeeee> linked to from haskell.org
11:01:39 <LoganCapaldo_> do { .... if { .... then { is what it looks like to Haskell when you do that, if I understand correctly
11:01:58 <roconnor> ptolomy: sorry out of ideas :(
11:01:58 <LoganCapaldo_> err if { ... } then { ...
11:02:01 <LoganCapaldo_> rather
11:02:13 <LoganCapaldo_> it thinks your starting a new thingy
11:02:37 * ptolomy wishes for an omniscient editor.
11:02:50 <LoganCapaldo_> outside of the do, theres no nesting so it has to make it work
11:03:01 <LoganCapaldo_> or something along those lines
11:03:03 <zeeeee> mm, interesting
11:03:12 <complaisant> Taral i also have http://paste.lisp.org/display/32171#2 some funtions like these defined
11:03:20 <zeeeee> it shouldn't be ambiguous though
11:03:25 <complaisant> but i don't really know howto apply them to a Def
11:03:28 <zeeeee> anyway
11:03:42 <LoganCapaldo_> its not if you always push then over a little :)
11:04:28 <Taral> complaisant: Well, to do the transform you need to remove all Fun ... elements.
11:04:32 <Taral> That's where you start.
11:05:06 <zeeeee> "unless someCondition $ takeMVar ..." doesn't work bc takeMVar doesn't return IO ()... how do i just resolve the types (ie just ignore takeMVar's return value)?
11:05:13 <Taral> or at least remove the Var parts.
11:05:21 <zeeeee> takeMVar returns IO a
11:05:50 <LoganCapaldo_> >> return ()
11:05:59 <sjanssen> zeeeee: use unless someCondition $ takeMVar foo >> return ()
11:06:15 <complaisant> i'm not really understanding ur statement. u say i need to convert my datatype to haskell syntax?
11:06:20 <complaisant> o_O
11:06:22 <sjanssen> where >> is the monadic sequence operator
11:06:30 <LoganCapaldo_> Yes! I am the man! My answer was the same as sjanssen!
11:06:45 <LoganCapaldo_> sjanssen++
11:06:50 <complaisant> Taral
11:06:52 <nmessenger> There should be a: discard == (>> return ())
11:07:01 <nmessenger> s/==/=/
11:07:03 <Taral> no
11:07:10 <zeeeee> nmessenger: yeah, that's what i was hoping for
11:07:10 <Taral> I said you need to remove the Var elements
11:07:12 <sjanssen> LoganCapaldo_: you even beat me to the punch ;)
11:07:14 <ptolomy> roconnor: Thanks for taking a look at it for me. :)
11:07:15 <Taral> in the conversion
11:07:34 <nmessenger> I used a similar thing in a Parsec grammar I wrote
11:08:03 <sjanssen> actually, the best solution is for unless to have a more general type
11:08:16 <sjanssen> no good reason to force m () instead of m a
11:08:45 <nmessenger> What would it evaluate to if the condition were false?
11:08:57 <nmessenger> er, true?
11:09:04 <nmessenger> one of those.
11:10:00 <complaisant> Taral : & Num & Pair.. all of them? . i'm not getting it.. u 're say i first have to eliminate vars? like " assocr ((x, y), z) = (x, (y, z)) <elim-x> assocr (w, z) = (fst w, (snd w, z)) "
11:10:43 <Taral> complaisant: Do you know what "point-free" means?
11:11:02 <complaisant> yes i know
11:11:07 <Taral> Tell me what you know.
11:11:10 <complaisant> it's not yet in pointfree the expression
11:11:22 <complaisant> that's only the first deduction
11:11:34 <Taral> What does "point-free" mean, complaisant?
11:11:42 <complaisant> no variables
11:11:45 <Taral> Very good.
11:12:00 <Taral> So I said "you need to eliminate the Var parts". i.e. eliminate the variables
11:12:20 <lisppaste2> metaperl annotated #32156 with "dons - any comments?" at http://paste.lisp.org/display/32156#1
11:12:32 <complaisant> ok. i get it know.. i don't know how to define that laws -.-
11:12:35 <Taral> not all the Vars, just the Vars between :@: and :=:
11:12:35 <metaperl> @seen dons
11:12:35 <lambdabot> dons is in #ghc, #haskell.hac07, #haskell-overflow and #haskell. I last heard dons speak 1h 47m 29s ago.
11:12:46 <nomeata> hmm. There is no UTF8 codec library in the core libraries? That is hard to believe, what am I missing?
11:13:05 <sjanssen> nomeata: no there is not, and yes it is a bug
11:13:15 <Taral> complaisant: Why did you define the functions assocr and undistr?
11:13:16 <nomeata> sjanssen: and what is the workaround?
11:13:29 <complaisant> they'r only examples
11:13:50 <complaisant> so u're saying i need to make a function that applies this laws ---> f a = b , f a [(x, y) / z] = b [x / fst z, y / snd z]
11:13:55 <sjanssen> nomeata: steal one from another project.  I think there's one in jhc you can use
11:14:11 <complaisant>  f a = b <=> f a [(x, y) / z] = b [x / fst z, y / snd z]
11:14:18 <complaisant> ?
11:14:18 <nomeata> hmm. ok. But I hope this bug is one that will be fixed...
11:15:16 <sjanssen> nomeata: I'm sure it will be fixed eventually.  Haskell really doesn't have a good locale+IO story at the moment
11:15:46 <complaisant> Taral
11:15:56 <nomeata> sjanssen: but why? not enough workpower? no consensus on the âright wayâ?
11:16:06 <Taral> complaisant: You need more laws than that.
11:16:17 <complaisant> yes.. 4 split i have them all defined
11:16:50 <complaisant> Taral : i'm not able to put that law onto haskell
11:16:53 <Taral> what do you do with "f x = x"?
11:17:16 <nomeata> Itâs shame: We waste a lot of memory on having a Char that is not a Byte8, but then we canât really use it because the infrastructure is missing.
11:17:44 <complaisant> Taral : i eliminate x
11:17:49 <Taral> how?
11:17:53 <sjanssen> nomeata: I just don't think anybody has gotten around to tackling the problem
11:18:22 <sjanssen> nomeata: there are historical reasons also.  Until GHC 6.4, Char was a Word8
11:18:51 <complaisant> Taral . that's id law it's stays "f" only i think
11:18:56 * nomeata thinks that String = [Char] should be reserved for textual content in unicodes, and for anything binary, including as UTF8, something like  [Word8] should be used.
11:19:09 <complaisant> is it?
11:19:12 <Taral> so what is the output if the input is "f x = x"?
11:19:21 <sjanssen> and the current IO libraries are based around the libs in the Haskell '98 report, which says nothing about locales and encodings
11:19:37 <nomeata> And functions to read files as String should adhere to the locale setting, while functions that read binary data should be added.
11:19:49 <sjanssen> nomeata: I think the whole encoding issue should be transparent to the average user
11:19:50 <nomeata> But this will break code...
11:20:10 <sjanssen> nomeata: right, because Haskell had no binary IO for so long, people use Char as raw bytes
11:20:24 <Trevion> nomeata: yes.  There have some discussions about it on Haskell-Cafe, I believe.  One led to SimonM's new IO suggestion and Bulat's streams package, I believe.
11:20:29 <complaisant> Taral : i think the output is "f" .. but i'm not sure.. u'r helping me find more doubts
11:20:32 <Taral> no
11:20:35 <Taral> the answer is not f
11:20:43 <nomeata> Maybe even deprecate Char, keeping itâs semantics, and then offering Binary and UChar functions.
11:20:44 <Taral> f alone is not a definition.
11:20:48 <Taral> the answer is "f = id".
11:21:02 <Taral> Don't write any code until you can do some simple examples correctly on paper.
11:21:17 <sjanssen> nomeata: I would not support that proposal.  Char is in the Haskell report and should remain a Unicode code point
11:21:47 <nomeata> sjanssen: so rather go for sensibility than compatibility?
11:21:52 <sjanssen> I think we need to just bite the bullet and fix these old programs that make poor assumptions
11:21:56 <nomeata> Fine with me, as long as it is fixed in the near future.
11:22:02 <nomeata> :-)
11:22:10 <Trevion> nomeata: feel free to fix it!
11:22:39 <nomeata> Oh, I feel very free :-)
11:22:46 * Trevion laughs.
11:22:46 <complaisant> Taral : i already know some of it.. that example was a tricky question.. 4 me @ last. i'm not an expert on it but i think i understand some of it
11:22:59 <Taral> that's not tricky.
11:23:04 <MarcWeber> Which package on gentoo should contain libraries/base/Text/Html.hs when using portage system ? base does not (?)
11:23:05 <Taral> that's one of the basic transform laws you need to implement.
11:23:14 <nomeata> But certain tasks should be left to those who understand the issue more completely.
11:23:26 <complaisant> yes i know. i get that part ;)
11:23:34 <nomeata> I hope that it itches one of them strong enough :-)
11:23:55 <sjanssen> MarcWeber: the package is called either html or xhtml, if I remember correctly
11:24:14 <Taral> Does anyone here understand how the typechecker works with rank-n types?
11:24:18 <Trevion> nomeata: I feel that way about a number of Haskell issues, including internationalization, strings, the type signature of (+), etc.  Sadly, none of them have been fixed yet.  I'm starting to accept that I might have to write some code...
11:24:35 <complaisant> Taral : yet i don't know howto eliminate a pair for example
11:24:45 <sjanssen> Trevion: what is your beef with strings?
11:24:46 <nomeata> But to do it correctly means that readFile can fail, just because the file is broken UTF-8 in a UTF locale.
11:24:51 <Taral> complaisant: You have the laws for that already, using fst and snd.
11:25:05 <notsmack> what's wrong with (+)?
11:25:06 <nomeata> Which means more work for simple programs. Which makes haskell shine less.
11:25:06 <Taral> This is a simple matter of applying transform laws until the variables are eliminated.
11:25:46 <MarcWeber> sjanssen: Thanks. xhtml exists. hoogle says base, too.
11:26:10 <Indeyets> hi everyone :) I am trying to learn haskell using "School of Expression".
11:26:12 <Trevion> sjanssen: I guess I more dislike collections in general.  It bugs me that there aren't a set of classes for the various collection libraries.
11:26:26 <complaisant> using def_fst (Fst :@: (Pair (Var x) (Var _))) = Var x ? i don't think so ... here i don't eliminate anything
11:26:43 <notsmack> Indeyets: good book
11:26:44 <Trevion> e.g., Data.Traversable is great, but I can't make ByteString an instance of Traversable
11:26:47 <Indeyets> Looks, though, like it became a problem to build Graphics library these days
11:26:58 <Taral> complaisant: That's not a rule
11:27:00 <xDie> hello
11:27:01 <Taral> That's a definition.
11:27:03 <Indeyets> it depends on GreenCard, which is not GHC-6.6 compliant
11:27:03 <sjanssen> MarcWeber: Text.Html might have been a package that died with GHC 6.6
11:27:11 <sjanssen> s/package/module
11:27:20 <sjanssen> Trevion: yes, there is that problem
11:27:49 <Taral> complaisant: Rules are usually expressed in the form \x -> x => id
11:27:49 <sjanssen> there is a tension between general containers with kind * -> * and specialized containers like ByteString
11:28:06 <Taral> sjanssen: Obviously we need a typeclass! :D
11:28:19 <notsmack> Indeyets: i couldn't get the graphics library he uses to work even before 6.6
11:28:24 <Trevion> Taral: either associated types or fundeps would solve that particular problem, I think.
11:28:30 <Taral> I was being facetious.
11:29:00 <Trevion> Sorry, I've been working on admissions essays.  It's completely fried my humor detector.
11:29:04 <Indeyets> notsmack: oof.. so, this will be read-only book? I hoped to be able to do "excersises" :-/
11:29:14 * Trevion looks sheepish
11:29:15 <complaisant> Taral: i don't think i have the law to "solve" a pair .. have i?
11:29:33 <Taral> write down an expression that uses a pair
11:29:39 <Taral> then derive the point-free version on paper
11:29:41 <notsmack> Indeyets: you could try to adapt the examples to gtk2hs's cairo bindings, that's probably a more up-to-date way of doing things anyway....
11:29:46 <Taral> work out what rules you used to perform the transformation
11:30:09 <complaisant> ((Fun "assocr") :@: (Pair (Pair (Var "x") (Var "y")) (Var "z")))
11:30:09 <complaisant> :=:
11:30:09 <complaisant> (Pair (Var "x") (Pair (Var "y") (Var "z")))
11:30:21 <sjanssen> Trevion: yes, I think we need ATs to do general collections
11:30:25 <notsmack> Indeyets: or try to build the version of hugs and graphics library he mentions
11:30:34 <sjanssen> any solution with fundeps makes your typesignatures look like ass
11:30:46 <Taral> GAH I HATE RANK-N TYPES.
11:30:48 <complaisant> Taral : resulta --> (Fun "assocr") :=: ((Fst : : Fst) :M: (Snd :?: Id))
11:31:06 <Taral> I have no idea what that means.
11:31:08 <Trevion> I would almost accept ass-y type signatures in exchange for parsers that work on both [Word8] and ByteStrings
11:31:13 <complaisant> where :M: is a split
11:31:33 <complaisant> & : : is :.: composion
11:31:51 <Taral> complaisant: How did you get there?
11:31:51 <sjanssen> Trevion: ever checked out the classes in Edison?
11:32:19 <zeeeee> is there a standard function :: Eq a => a->[a]->[a] that drops all instances of the given element from the input list? (yeah i can pretty easily implement this with either Data.List.(\\) or partition, but i'm wondering if there's anything built-in...closest thing i found was Data.List.delete)
11:32:29 <Taral> zeeeee: filter
11:32:35 <Indeyets> notsmack: yep.. I guess I'll do it that way
11:32:45 <integral> @pl \x -> filter (/=x)
11:32:45 <lambdabot> filter . (/=)
11:32:49 <ozo> I just downloaded the Hugsversion on the SOE website and then moved the SOE libs to the latest Hugs
11:32:52 <ptolomy> Silly question: Can/how do I define a datatype to operate on a typeclass?  data Thing = Ord a => Thing a is what I mean to do..
11:32:59 <zeeeee> Taral: oh, duh...thanks
11:33:25 <Trevion> ptolomy: either data Thing = forall a. Ord a => Thing a or data Thing where Thing :: Ord a => a -> Thing
11:33:35 <Taral> ptolomy: No way in Haskell98. GHC provides extensions to support them, but what are you doing?
11:33:39 <newsham> ?remember dons Don "If it ain't pure, it ain't functional" Stewart
11:33:49 <Trevion> they both require extensions.  The latter requires GHC
11:34:07 <sjanssen> newsham: where did that little gem come from?
11:34:15 <newsham> Subject: Re: [Haskell-cafe] Aim Of Haskell
11:34:18 <newsham> Who wants to join the Lisp is not functional programming movement with me?
11:34:23 <Taral> newsham: Me!
11:34:23 <ex0r> if I import another .hs file using import file, then load the file that statement is in, why does WinHugs tell me Main is already loaded?
11:34:54 <newsham> why are there 200 new msgs on haskell-cafe today?
11:35:01 <ex0r> I just want to be able to use all the code in the other file without pasting it all into one super file
11:35:02 <Trevion> newsham: several awesome conversations.
11:35:03 <lisppaste2> Saizan annotated #32161 with "better names, and comments" at http://paste.lisp.org/display/32161#1
11:35:14 <Taral> ex0r: You can only have one module of each name loaded. If a file has no "module ..." declaration, it's assumed to be called Main.
11:35:22 <ex0r> ah
11:35:26 <ex0r> that would be it then!
11:35:47 <Taral> Trevion: For some value of 'awesome'.
11:36:12 <Taral> I'm about ready to move haskell and haskell-cafe to something like google reader.
11:36:20 <Taral> The traffic is too much for email.
11:36:22 <Trevion> Oh, come on.  The Aim of Haskell conversation is at least fun from a distance.
11:36:45 <Trevion> And roughly all of my former coworkers desparately need the result of the Haskell for Dummies book conversation.
11:37:01 <newsham> you dont have mailbox sorting?  procmail or email reader sorting rules?
11:37:08 <complaisant> Taral :
11:37:08 <complaisant> assocr ((x, y), z) = (x, (y, z)) <=> assocr (w, z) = (fst w, (snd w, z)) <=> assocr x = (fst (fst x), (snd (fst x), snd x)) <=> assocr x = ((fst . fst) x, ((snd . fst) x, snd x)) <=> assocr x = ((fst .  fst) x, (snd .  fst :/\: snd) x) <=> assocr x = (fst  . fst :/\: (snd . fst :/\: snd)) x <=> assocr = fst .  fst :/\: (snd .  fst :/\: snd) <=> assocr = fst .  fst :/\: (snd  . fst :/\: id  . snd) <=> assocr = fst  . fst :/\: (snd ?
11:37:08 <complaisant>  id)
11:37:31 <complaisant> i think i didn't misstyped anything
11:37:40 <complaisant> where :/\: is a split
11:37:56 <Taral> complaisant: Great. Each of those <=> is the implementation of a rule.
11:38:19 <complaisant> Taral : lol. nice conclusion.
11:38:26 <Taral> Write down those rules, then implement those rules as code.
11:38:34 <Taral> That is the most I can give you on homework help.
11:40:11 <newsham> hmm.. I dont get it.  I say "HASKul" and "pasCAL"  i dont see how the two could get confused.
11:40:21 <complaisant> i just can't implement the eliminate rule -_- the others are already defined in my file. i really don't know how to code this --> f a = b <=> f a [(x, y) / z] = b [x / fst z, y / snd z]
11:40:34 <Taral> newsham: Some people say "hasKELL" and "pasCAL". Others say "HASKul" and "PAScal".
11:40:49 <newsham> i've never heard of "PAScul"
11:41:13 <newsham> i havent talked to many people in person about haskell so i dont know what to expect on that front i guess
11:41:26 <zeeeee> is there any monadic equiv of span (something like spanM a la mapM)? liftM doesn't seem to do the trick
11:41:27 <Taral> complaisant: If a variable is a pattern match of the form (x, y), replace it with z and replace x with fst z and y with snd z in the value.
11:41:57 <Taral> complaisant: This is a difficult thing to code.
11:42:09 <newsham> foldM/forM_ ?
11:42:15 <Taral> You need to track replacement contexts as you traverse the expression.
11:42:34 <complaisant> Taral : in english please
11:42:35 <Taral> replacement contexts are those things in []
11:42:54 <zeeeee> newsham: so there's nothing built in?
11:42:54 <newsham> zeee: you want a loop with a loop-carried variable?  that's a fold.
11:42:59 <Taral> complaisant: It doesn't get more English. You've gotten into technical stuff.
11:43:02 <newsham> ?type foldM
11:43:03 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
11:43:25 <zeeeee> newsham: that's like answering "fold" to the question "is there a span" :)
11:43:42 <zeeeee> anyway, point taken
11:43:46 <zeeeee> it doesn't exist
11:43:52 <complaisant> Taral : ok. i get it i think.. & how do u do that? that's the ultimate/first/only(?)/concluding question
11:43:54 <newsham> cant you make a span out of a fold by dropping an arg?
11:43:57 <lisppaste2> glguy pasted "Enumerating the ways to spread out blocks of a given size" at http://paste.lisp.org/display/32176
11:44:14 <zeeeee> newsham: of course you can
11:44:18 <glguy> Anyone want to look at my function called "orders" and see i I'm making this harder than I should be?
11:44:25 <glguy> that paste isn't very complicated
11:44:53 <glguy> the point is to find out how you could order blocks of a given size in a row of a given size with the constraint that the blocks must not touch
11:45:34 <glguy> but i feel like there should be a better way to structure this
11:45:58 <complaisant> Taral : u said it is a difficult thing to code.. can u give me clue on howto do that? i'm really stuck here with it
11:47:51 <Taral> complaisant: Not really. It is sufficiently difficult that if you do not understand the technical aspects, I suggest you go to your teacher with your concerns.
11:48:05 <nomeata> hmm. the stream library looks like a nice way to handle utf8, but it is not in debian, it seems.
11:49:40 <Indeyets> notsmack: the funniest thing is, that gtk2hs is not ghc-6.6 compatible either ;)
11:49:52 <notsmack> Indeyets: correct :-)
11:50:03 * nmessenger grumbles about his useless ISP
11:50:35 <complaisant> Taral : ok. tnks anyway. i've learned somethings here.. ;) ty. i guess i might have to have a new datatype that provides me a Maybe Def as a result & start defining simple equation's to solve this elim problem
11:50:36 <Taral> ?paste
11:50:36 <lambdabot> http://paste.lisp.org/new/haskell
11:50:41 <complaisant> tnks 4 ur help
11:50:41 <nomeata> Igloo: yes, it is unfortunate that the ghc 6.6 relase fell in a time when gtk2hs were in the middle of an API change.
11:50:48 <lisppaste2> Taral pasted "I HATE RANK-N TYPES" at http://paste.lisp.org/display/32178
11:51:18 <Taral> I give up.
11:51:45 <Taral> Now I know why callCC's type isn't quite right.
11:51:53 <Taral> Making it right breaks so many things as to be stupid.
11:51:59 <Trevion> glguy: I think it can be done with the [] monad
11:52:13 <glguy> Trevion: that's what I'm doing right now in that paste..
11:53:07 <Excedrin> anyone still working on the 99 problems? can P54A be encoded into a type so there's no need for "istree"?
11:53:45 <Taral> Excedrin: the what?
11:53:58 <AStorm> Hey, is there some Set-like Monad?
11:54:00 <Excedrin> http://haskell.org/haskellwiki/99_Haskell_exercises
11:54:01 <lambdabot> Title: 99 Haskell exercises - HaskellWiki
11:54:36 <Igloo> nomeata: What's that a reply to?
11:54:38 <sjanssen> Excedrin: that problem assumes that lists can be heterogenous, which isn't true in Haskell
11:55:19 <nmessenger> So effectively, istree = True
11:55:20 <Igloo> nomeata: Oh, looks like just bad tab completion, n/m
11:55:24 <wy> emu: Could you add another error message recognition to the haskell-mode? I got "*** Exception: /home/wy/prog/core/template1.hs:105:0-51: Non-exhaustive patterns in function instantiate". But it can't jump to the location. It seems the current haskell-mode doesn't recognize this kind of location range.
11:55:32 <Taral> Excedrin: data Tree a = Node a (Tree a) (Tree a) | Empty
11:55:58 <nmessenger> or rather, istree = const True :: Tree -> Bool
11:56:04 <Taral> lol
11:56:18 <sjanssen> Excedrin: instead of solving that problem, I'd say "In Haskel, we would implement a Tree data type, here is what it would look like.  The type system ensures that all Tree's are binary trees"
11:56:58 <Excedrin> ok, but P55 can't be represented as a type afaik
11:57:47 <Taral> Excedrin: Well...
11:57:51 <Taral> It *can*.
11:57:52 <Excedrin> none of the rest actually
11:58:09 <qwas> does haskell have a equiv to Ocaml's CIL (C parser) ?
11:58:19 <Taral> qwas: c2hs has one in it.
11:58:24 <Taral> But it's not a library like CIL.
11:58:43 <nmessenger> How many millOlegs would it take to put it in the type system?
11:58:46 <nomeata> Igloo: eh, yes, sorry, was meant for Indeyets
11:58:56 <Taral> nmessenger: ???
11:59:05 <nomeata> Somehow my xchat must have changed from bash-like completion to vim-like completion.
11:59:11 <sjanssen> Excedrin: for P55, I'd use this list monad
11:59:23 <nmessenger> Taral: nevermind
11:59:47 <Excedrin> sjanssen: ya, I think that it would be useful for many of them... anything that mentions backtracking at least
11:59:49 <lisppaste2> glguy annotated #32176 with "more efficient ordering -- Trevion" at http://paste.lisp.org/display/32176#1
12:00:49 <nomeata> hmm. no. it was not xchat, it was just a typo
12:01:13 <glguy> Trevion: I updated that function to not waste so much time, but I still wonder if there is a better way to write the data type
12:02:00 <AStorm> For P55 you can just use a datatype with Left and Right
12:02:09 <AStorm> and implement a proper addition function.
12:02:39 <Taral> AStorm: Uh, what?
12:02:51 <AStorm> Yes, addition (not insertion :P )
12:03:21 <AStorm> That you add an item to the left and right subtree alternatively, not to the left one all the time.
12:04:01 <AStorm> Uh, misunderstood the problem :P
12:04:04 <AStorm> IT's much simpler.
12:05:33 <AStorm> Actually, P56 requires what I was thinking about :>
12:06:40 <Taral> :S
12:06:42 <Taral> :D
12:10:45 <Trevion> glguy: I like your last paste better than what I was working on.
12:11:37 <sjanssen> @where paste
12:11:37 <lambdabot> http://paste.lisp.org/new/haskell
12:11:46 <Trevion> Although I'm not sure what you gain from using your data type instead of just a list of Block Int and Space Int...
12:12:11 <lisppaste2> sjanssen pasted "my solution to P55" at http://paste.lisp.org/display/32182
12:13:26 <sjanssen> I'd like to see a lisp solution in 3 (could be shortened to two) LOC!
12:13:50 <zeeeee> newsham: wait...i think we're confusing scan with span
12:14:56 <dcoutts__> @yarr!
12:14:56 <lambdabot> I heard andersca is a pirate
12:15:02 * dcoutts__ is in Bergen
12:15:03 <sjanssen> Excedrin: did you have a solution already?
12:15:10 <zeeeee> how would you implement scanM from foldM? seems easier to just write a recursive scanM.
12:15:21 <emu> wy: keep in mind, you can compile with an option to catch those
12:15:24 <nomeata> I donât think this is possible in haskell, but maybe in Haskell': It would be nice to have âisâ and âfromâ variants of a constructor automatically, woudnât it?
12:15:34 <zeeeee> in general, do we pretty much just have to roll our own monadic-equivalents of things list scan, takeWhile, etc.?
12:16:00 <nomeata> (fromSomething would then have either type  -> (), -> a or -> (a,b...), depending on the number of arguments Something takes.
12:16:13 <sjanssen> zeeeee: yes, if it isn't already in Control.Monad
12:17:01 <zeeeee> sjanssen: is there any lib of such functions in existence?
12:17:52 <lisppaste2> glguy annotated #32176 with "sloppy way to convert rows to columns" at http://paste.lisp.org/display/32176#2
12:17:52 <sjanssen> zeeeee: not that I'm aware of
12:18:44 <wy> emu: I don't know. What's the option?
12:18:47 <Taral> zeeeee: They're not implemented because you usually don't need them...
12:18:48 <sjanssen> zeeeee: and, regarding your previous question, I'm fairly certain scanM can be implemented in terms of foldM
12:19:05 <emu> lessee
12:19:37 <zeeeee> sjanssen: i know it can, it just seems like a hassle
12:20:01 <zeeeee> sjanssen: you have to pass around an additional bit of information on whether you're building the first or second list
12:20:04 <zeeeee> and then drop that in the end
12:20:16 <emu> -fwarn-incomplete-patterns
12:20:19 <sjanssen> zeeeee: a hassle that you only have to suffer through once ;)
12:20:37 <sjanssen> I can't remember, is foldM a left or right fold?
12:20:40 <glguy> left
12:20:51 <zeeeee> sjanssen: but which others may have/will suffer through as well
12:20:56 <sjanssen> oh, that's ugly
12:20:59 <glguy> if you want to fold from the right, the comments in the code instruct you to reverse your list first
12:21:06 <zeeeee> oy
12:21:25 <nomeata> Might that be possile with template haskell? (adding is.. and from.. functions)?
12:21:41 <emu> nomeata: yes
12:21:45 <sjanssen> not sure whether you can write scanM in terms of a left fold
12:21:46 <emu> Serth has that
12:22:00 <nomeata> oh, interesting. where can I find thatÃ
12:22:02 * zeeeee googles template haskell
12:22:06 <emu> @where serth
12:22:08 <lambdabot> http://www.cs.helsinki.fi/u/ekarttun/SerTH/
12:22:25 <newsham> 99questions on haskell -- why are they using ['a','b','c','d'] instead of "abcd" ?
12:22:48 <zeeeee> emu: by 'that' what are you referring to?
12:23:16 <emu> generated is/from constructor related fns
12:24:02 <emu> er, might have been the other lib
12:24:03 <zeeeee> emu: what are those? (any pointers to introductory resources?)
12:24:03 <emu> one sec
12:24:07 <LoganCapaldo_> newsham, they're trying to make it look like '(a b c d) I would guess
12:24:11 <wy> emu: Can you tell me the option's name?
12:24:41 <emu> 15:13 < emu> -fwarn-incomplete-patterns
12:24:51 <zeeeee> when writing things like spanM, can/should i toss them into MissingH?
12:25:16 <emu> @where drift
12:25:17 <lambdabot> http://repetae.net/john/computer/haskell/DrIFT/
12:25:39 <Excedrin> sjanssen: no, I didn't
12:25:45 <wy> emu: Thanks. I wonder if there is a configuration file for ghci that I can write the options I want in?
12:25:58 <emu> ^ DrIFT is what you want
12:26:05 <nomeata> ok, thx
12:26:05 <sjanssen> Excedrin: feel free to use my solution, if you'd like
12:26:19 <emu> DrIFT provides non-standard "derivations" from constructors; not only typeclasses, but also things like "from" and "is"
12:26:24 <SamB> dcoutts__: so what kind of widget can I use to display a certain number of lines of text?
12:26:33 <SamB> or, um, dcoutts___ even
12:26:52 <paolin1> I'm looking for the function
12:26:53 <paolin1> f [a,b,c] d == a.b.c $ d
12:26:53 <paolin1> is this a standard one ?
12:27:16 <emu> fold on ($)?
12:27:35 <integral> nothing from Arrows?
12:27:37 <Taral> flip (foldr ($))
12:27:58 <emu> @type flip $ foldr ($)
12:28:00 <lambdabot> forall b. [b -> b] -> b -> b
12:28:01 <dcoutts___> SamB, do you want it to be editable ?
12:28:11 <SamB> no
12:28:19 <dcoutts___> SamB, it it's a short non-editable paragraph then use a label
12:28:25 <SamB> it isn't a paragraph
12:28:35 <SamB> it is actually more of a character matrix
12:28:40 <paolin1> ok, thanks, (will I ever get there ?)
12:28:47 <emu> wy: well, ~/.ghci i believe. or you can just supply it on the ghci command line. um, better look up what goes in ~/.ghci though.
12:29:15 <dcoutts___> SamB, well probably a TextView + TextModel. Then make it non-editable.
12:29:20 <Excedrin> sjanssen: you should add it to the wiki, I don't really understand it, so your description will be better
12:29:45 <newsham> "abcd" looks like '(a b c d) to me
12:29:56 <xerox> 'a':'b':'c':'d':[]
12:30:03 <SamB> dcoutts: wth is a TextModel?
12:30:16 <newsham> (a.(b.(c.(d.()))) ?
12:30:28 <nmessenger> emu: is there an analogous foldr for [T -> IO T] -> T -> IO T
12:30:29 <dcoutts___> SamB, it's the erm, sorry a TextBuffer
12:30:48 <xerox> paolin1 sequence :: Monad m => [m a] -> m a, take m = (e ->)
12:30:51 <SamB> dcoutts: okay, now how do I make it the correct height?
12:30:54 <emu> @type foldM
12:30:55 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
12:31:02 <LoganCapaldo_> data syms = a | b | c | d ; [a,b,c,d] would look like '(a b c d) to me
12:31:04 <xerox> argh -> m [a] not -> m a.
12:31:14 <dcoutts___> SamB, set the height of the view widget
12:31:19 <LoganCapaldo_> with appropiate cpatilizaion of course
12:31:35 <emu> @type flip (foldM ap)
12:31:36 <lambdabot>   Occurs check: cannot construct the infinite type: b = m (a -> b)
12:31:36 <lambdabot>    Expected type: m (a -> b) -> m a -> m (m (a -> b))
12:31:53 <emu> @type flip (foldM (flip ap))
12:31:54 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m (a -> m a)] -> m a -> m (m a)
12:32:15 <nmessenger> emu: thx, I'll try stuff
12:32:25 <dcoutts___> SamB, actually, I think it naturally takes enough space to show all the text, so if you have more text than you have space for then you pack it into a scrollwindow.
12:32:42 <emu> @type flip (foldM (flip ($)))
12:32:43 <lambdabot> forall a (m :: * -> *). (Monad m) => [a -> m a] -> a -> m a
12:32:50 <emu> that looks like it
12:32:52 <zeeeee> so, of template haskell, generic haskell, drift, ..., which one should i use if i only have time to learn one?
12:33:03 <emu> zeeeee: differnet things
12:33:10 <emu> zeeeee: drift is easy to use, it's just a library
12:33:11 <nmessenger> Remember kids, if it typechecks, it's probably correct
12:33:14 <SamB> dcoutts: ah
12:33:18 <kosmikus> zeeeee: good question. we're currently working on that problem.
12:33:36 <zeeeee> emu: the TH paper says they're all doing the same thing
12:33:47 <emu> wait, i thought you were the one who wanted to derive to/from
12:34:01 <xerox> emu: sequence is
12:34:04 <zeeeee> emu: i don't even know what that means "derive to/from"
12:34:12 <emu> yea nvm
12:34:19 <SamB> dcoutts: that would certainly make things easier, considering it doesn't seem to have a way to set the height in lines...
12:34:24 <zeeeee> kosmikus: what are you working on?
12:34:50 <kosmikus> zeeeee: comparing different approaches to generic programming, finding common ground, etc.
12:35:21 <zeeeee> kosmikus: sorry for my ignorance...who's 'we'?
12:36:07 <kosmikus> zeeeee: people responsible for the tools you cited above, and more
12:36:37 <kosmikus> but if you tell me what exactly you want to do, I can try to tell you what best suits your needs.
12:36:43 <zeeeee> emu: how would i use drift to get something like spanM?
12:37:04 <kpreid> Is there some typeclass which is to zipWith as Functor is to map?
12:37:11 <zeeeee> kosmikus: at the moment, all i sought was something very simple - a spanM
12:37:50 <kosmikus> zeeeee: why would you need any such tool for that?
12:37:57 <kosmikus> just write it :)
12:39:17 <glguy> Trevion: it worked
12:39:27 <Trevion> glguy: cool
12:39:39 <glguy> it's slow and inefficient though (=
12:39:51 <zeeeee> kosmikus: yeah, i could've, would've taken all of a minute :) ... it's just that there was just some discussion above that seemed to suggest there are 'nicer' ways to get such functions than writing them out by hand
12:40:04 <zeeeee> (via templates/drift)
12:42:31 <gour> Hirvinen, what do you think about Phooey?
12:42:39 * gour is sad it's not in gtk2hs
12:42:41 <kosmikus> zeeeee: I'm not sure. The monadic functions contain more information than the original ones (they contain the sequencing information). You can get the original back by instantiating to the identity monad, but I'm not sure that there's a unique way to get the monadic one from the original.
12:45:53 <fasta> kosmikus: are you also looking into program inversion?
12:46:21 <kosmikus> also?
12:47:05 <Hirvinen> gour: Umm... Are you talking to me or is your irc client's nick completion fucked up?
12:47:33 <gour> Hirvinen: my irc-client :-( excuse me
12:48:11 <fasta> kosmikus: also as in "next to your type activities"?
12:51:07 <notsmack> anybody want to recommend a good haskell book?
12:52:23 <notsmack> i liked "School of Expression" and "Road to Logic, Maths, and Programming", anything a bit more (but not too far) advanced?
12:52:47 * mbishop is gonna get "Haskell school of expression" in the mail any day now
12:54:29 <gour> notsmack: i've craft of fp and i like it, but it is probably on the level of soe
12:55:04 <notsmack> thanks, i'll check that out
12:56:44 <inv2004> hi all
12:56:57 <roconnor> Type Theory and Functional Programmmin
12:57:02 <inv2004> is there any step-by-step debugger for haskell (hugs) ?
12:57:06 <roconnor> it's free
12:57:13 <kosmikus> fasta: no, not really. my very first task my PhD supervisor set me had something to do with program inversion. but I gave up relatively quickly, and after that, I haven't really looked at it anymore.
12:58:52 <inv2004> its very hard to debug lazy language
13:01:51 <SamB> inv2004: have you tried Debug.trace?
13:02:01 <SamB> er.
13:02:05 <SamB> Debug.Trace
13:02:33 <inv2004> thx, 'll googlr for it
13:02:56 <SamB> @doc Debug.Trace
13:02:57 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Debug-Trace.html
13:03:49 <nmessenger> why is lambdabot so awesome?
13:04:38 <nmessenger> I mean, shouldn't there be a limit to such things?  It could get dangerous with the awesome.
13:04:42 <nomeata> nmessenger: I donât know, but have you tried to ask lambdabot?
13:04:48 <nomeata> ?karma lambdabot
13:04:48 <lambdabot> lambdabot has a karma of 34
13:04:57 <nomeata> I think others agree...
13:06:08 <Saizan> ?karma+ lambdabot
13:06:08 <lambdabot> lambdabot's karma raised to 35.
13:09:11 <SamB> dcoutts: hmm. it doesn't look like it works that way :-(.
13:10:57 <SamB> lambdabot++
13:11:07 <nomeata> Now that lambdabot can construct functions to a given type, maybe it could also, given a data type, greate derivations of common classes.
13:11:31 <SamB> you want to write a @drift command?
13:11:48 <nomeata> @derive Eq for data Bla = Bla String | Blubb Int
13:11:48 <lambdabot> (line 1, column 15):
13:11:49 <lambdabot> unexpected "="
13:11:49 <lambdabot> expecting var, "head", "tail", "null", bool, num, character, "[", string, "(", operator, simple term or end of input
13:12:11 <nomeata> SamB: no, I was hoping someone would do it from scratch, and then I could do
13:12:18 <nomeata> @derive Eq for (a -> b)
13:12:19 <lambdabot> (line 1, column 10):
13:12:19 <lambdabot> unexpected ">"
13:12:19 <lambdabot> expecting simple term
13:12:33 <nomeata> @help derive
13:12:34 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
13:12:36 <lisppaste2> metaperl annotated #32156 with "Haskell, what a beautiful language Thou Art." at http://paste.lisp.org/display/32156#2
13:12:50 <metaperl> and to think I have not even gotten to monads yet
13:15:05 <nmessenger> metaperl: Ooh, that is much with the neat.
13:15:32 <metaperl> elegance...
13:15:41 <Saizan> metaperl, by coincidence i've implemented today the Levenshtein distance
13:16:24 <Saizan> http://paste.lisp.org/display/32161#1
13:17:34 <AStorm> I think metaperl's solution is nicer and will be faster.
13:18:21 <metaperl> AStorm - "metaperl's solution" is just a paste from the Code that comes with SJT's book :)
13:18:54 <Saizan> metaperl solutions does something different, it traces the edits
13:18:58 <AStorm> LOL :>
13:19:25 <Saizan> but it's no way faster
13:19:42 <AStorm> Yes, more recursion it seems.
13:19:55 <Saizan> exactly
13:20:44 <AStorm> Though it can be tail-recursed nicely.
13:21:56 <Saizan> it has to choose the best from 3 alternatives, how do you tail recurse that?
13:22:45 <sjanssen> I don't think metaperl's solution is optimal
13:22:54 <AStorm> It isn't, and it isn't his :P
13:23:01 <metaperl> lol
13:23:11 <metaperl> thank you AStorm :)
13:23:32 <sjanssen> just need to add memoization
13:24:05 <Saizan> heh
13:24:33 <AStorm> Yes, but that would complicate the flow much and isn't all that fun to do in Haskell.
13:24:39 <metaperl> @type last
13:24:40 <lambdabot> forall a. [a] -> a
13:24:49 <metaperl> @type first
13:24:51 <lambdabot> forall (a :: * -> * -> *) d c b. (Arrow a) => a b c -> a (b, d) (c, d)
13:25:03 <metaperl> ah, so they are not antonyms :)
13:25:09 <AStorm> metaperl, take1
13:25:12 <AStorm> @type take1
13:25:13 <lambdabot> Not in scope: `take1'
13:25:16 <nomeata> @type first last
13:25:17 <lambdabot> forall a d. ([a], d) -> (a, d)
13:25:18 <AStorm> @type take
13:25:19 <lambdabot> forall a. Int -> [a] -> [a]
13:25:22 <Averell> @type head
13:25:23 <lambdabot> forall a. [a] -> a
13:25:29 <AStorm> Or head, anyway.
13:25:30 <AStorm> :>
13:25:34 <nomeata> @type last . first
13:25:35 <lambdabot>   Couldn't match `[]' against `a (b, d)'
13:25:35 <lambdabot>    Expected type: a b c -> [a1]
13:25:41 <AStorm> @type tail.
13:25:42 <lambdabot> parse error (possibly incorrect indentation)
13:25:44 <AStorm> @type tail
13:25:45 <lambdabot> forall a. [a] -> [a]
13:25:46 <nmessenger> > head []
13:25:47 <lambdabot>  Add a type signature
13:25:59 <AStorm> head [1,2,3,4]
13:26:08 <AStorm> Or something more well-defined.
13:26:14 <nmessenger> > head [] :: Int
13:26:15 <lambdabot>  Exception: Prelude.head: empty list
13:26:20 <nmessenger> > take 1 [] :: Int
13:26:21 <lambdabot>  Couldn't match `Int' against `[a]'
13:26:32 <nmessenger> > take 1 [] :: [Int]
13:26:33 <lambdabot>  []
13:26:52 <nmessenger> head nil is a runtime exception
13:32:27 <AStorm> head ([] :: [Int]) shouldn't be...
13:32:37 <AStorm> > head ([] :: [Int])
13:32:38 <lambdabot>  Exception: Prelude.head: empty list
13:32:41 <AStorm> Hmm.
13:32:52 <AStorm> The head of nothing should be... nothing :P
13:33:20 <nmessenger> head, by definition, is only valid over conses, not nils.
13:33:27 <AStorm> [] is a cons
13:33:32 <nmessenger> nopers
13:33:40 <AStorm> 1 : []
13:33:42 <AStorm> > 1 : []
13:33:43 <lambdabot>  [1]
13:34:05 <AStorm> @type [Int]
13:34:06 <lambdabot> Not in scope: data constructor `Int'
13:34:38 <AStorm> compare:
13:34:39 <nmessenger> (:) is a cons, [] is not a cons
13:34:41 <AStorm> > 1 : nil
13:34:41 <lambdabot>  Not in scope: `nil'
13:34:46 <AStorm> > 1 : ()
13:34:47 <lambdabot>  Couldn't match `[a]' against `()'
13:35:00 <Saizan> > 1:[]
13:35:01 <lambdabot>  [1]
13:35:58 <nmessenger> It's right there in the source code: head (x:xs) = x; head [] = error "BAD THINGS!"
13:36:30 <AStorm> Is that mandated? I find it stupid that head != take 1
13:36:49 <nmessenger> ?type head
13:36:52 <lambdabot> forall a. [a] -> a
13:36:54 <nmessenger> ?type take 1
13:36:55 <SamB> @check liftM2 (==) head (take 1)
13:36:56 <lambdabot> forall a. [a] -> [a]
13:36:56 <lambdabot>    Occurs check: cannot construct the infinite type: a = [a]       Expected...
13:37:13 <AStorm> Hmm, an array.
13:37:19 <AStorm> (uh, list)
13:37:39 <nmessenger> head is for breaking the type out of the list, take 1 gives you a list with (maybe) 1 element.
13:37:55 <AStorm> I see the difference, thank you.
13:38:08 <AStorm> But what keeps head from returning () in that case?
13:38:21 <AStorm> (nullpleton? ;-) )
13:38:25 <sjanssen> @type head ""
13:38:26 <lambdabot> Char
13:38:37 <AStorm> > head ""
13:38:38 <lambdabot>  Exception: Prelude.head: empty list
13:38:40 <AStorm> :P
13:38:41 <sjanssen> AStorm: () is not the same as Char
13:38:49 <AStorm> It isn't, well.
13:39:00 <AStorm> You've got a point.
13:39:03 <AStorm> :D
13:39:13 <nmessenger> wouldn't typecheck, head :: [a] -> a, so if I head ([] :: [Int]), () wouldn't make sense.
13:39:28 <nmessenger> () is not Int
13:39:38 <AStorm> @type ()
13:39:39 <lambdabot> ()
13:39:41 <AStorm> :>
13:39:44 <nmessenger> :D
13:40:03 <AStorm> Everybody loves nullples :>
13:40:14 <nmessenger> The type of unit is unit.  MAKES SENSE.
13:40:25 <AStorm> Ah, it's called a unit even.
13:40:48 <AStorm> @type (Int)
13:40:48 <nmessenger> I've heard it called the trivial type, empty tuples, unit, but not yet nullples.
13:40:49 <lambdabot> Not in scope: data constructor `Int'
13:40:53 <AStorm> @type (a)
13:40:55 <lambdabot> Not in scope: `a'
13:40:56 <nmessenger> also void
13:41:08 <AStorm> It's actually a tuple of zero elements.
13:41:52 <AStorm> You get nullples, singletons, tuples, triples...
13:41:54 <nmessenger> A one-tuple is the same as the Identity type.  It's as if the tuple isn't even there.
13:42:35 <AStorm> ;-)
13:42:49 <nmessenger> Oh and @type (Int) is asking for the type of a type, you have to use an expression:
13:42:54 <nmessenger> @type (1)
13:42:55 <lambdabot> forall t. (Num t) => t
13:43:00 <AStorm> Mhm.
13:43:09 <sjanssen> @type (1 `asTypeOf` 2)
13:43:10 <lambdabot> forall a. (Num a) => a
13:43:42 <sjanssen> @type 1 `asTypeOf` length undefined
13:43:44 <lambdabot> Int
13:43:44 <zeeeee> is there a more concise way (using monads?) of writing: let { x = [Nothing, Nothing, Just 0, Nothing]; f [] = Nothing; f (x:xs) = case x of {Just v -> return v; Nothing -> f xs } } in f x
13:43:56 <nmessenger> Well, yeah, unless you annotate the inferer can't go any more specific than Num a => a
13:44:26 <sjanssen> @hoogle [Maybe a] -> [a]
13:44:27 <lambdabot> Maybe.catMaybes :: [Maybe a] -> [a]
13:44:41 <nmessenger> that'd be it.
13:44:42 <sjanssen> zeeeee: there is that
13:45:04 <AStorm> What would that do with Nothing?
13:45:21 <AStorm> > catMaybes [Nothing, Just 1]
13:45:22 <lambdabot>  [1]
13:45:23 <nmessenger> > catMaybes [Nothing, Just 1, Nothing, Just 2, Just 3]
13:45:24 <lambdabot>  [1,2,3]
13:45:27 <zeeeee> @hoogle [Maybe a] -> a
13:45:28 <lambdabot> No matches, try a more general search
13:45:29 <nmessenger> :)
13:45:49 <AStorm> zeeeee, list to a single item? unlikely.
13:45:59 <LoganCapaldo_> @type (head . catMaybes)
13:45:59 <lambdabot> forall a. [Maybe a] -> a
13:46:09 <sjanssen> @check (\xs -> catMaybes xs == map fromJust (filter isJust xs)) :: [Maybe Int] -> Bool
13:46:10 <AStorm> More or less :P
13:46:10 <lambdabot>  OK, passed 500 tests.
13:46:23 <zeeeee> i wonder if there's anything that illustrates mplus
13:46:23 <notsmack> anybody read "Types and Programming Languages"?
13:46:42 <zeeeee> i tried mapM mplus [Nothing, Just 0]
13:46:47 <AStorm> A simple counter?
13:46:53 <sjanssen> @check (\xs -> catMaybes xs == [x | Just x <- xs]) :: [Maybe Int] -> Bool
13:46:54 <lambdabot>  OK, passed 500 tests.
13:46:55 <bd_> > mplus Nothing Just 0
13:46:56 <lambdabot>  Couldn't match `(->) t' against `Maybe'
13:47:00 <bd_> > mplus Nothing Just
13:47:01 <lambdabot>    Expecting a function type, but found `m a'
13:47:01 <lambdabot>    Expected type: Maybe a
13:47:01 <lambdabot> ...
13:47:04 <bd_> >.<
13:47:09 <bd_> > mplus Nothing (Just 0)
13:47:11 <lambdabot>  Just 0
13:47:12 <bd_> zeeeee: there you go
13:47:24 <bd_> msum is what I think you meant there with that map
13:47:45 <AStorm> > mapM mplus [Nothing, Just 1, Just 3, Nothing, Just (-1)]
13:47:46 <lambdabot>  Add a type signature
13:47:47 <zeeeee> bd_: i don't see why foldM mplus doesn't work
13:47:54 <AStorm> > foldM mplus [Nothing, Just 1, Just 3, Nothing, Just (-1)]
13:47:55 <lambdabot>    Occurs check: cannot construct the infinite type: a = m a
13:47:55 <lambdabot>    Expected...
13:48:12 <bd_> zeeeee: use foldr with a base case of mzero :)
13:48:19 <bd_> and you'll have msum
13:48:56 <nmessenger> > msum [Nothing, Just 1, Just 3, Nothing, Just (-1)]
13:48:57 <lambdabot>  Just 1
13:49:04 <nmessenger> :D
13:49:07 <ex0r> split_tokens_sys (x:xs) b = if fst x == 6 then b else split_tokens_sys xs b++[x] <-- any idea how I can rewrite this so that the output is reversed
13:49:15 <AStorm> nmessenger, wtf?
13:49:24 <AStorm> Should be Just 3
13:49:26 <ex0r> I tried reverse b instead of b, and changed the ++ order but it makes no difference
13:49:27 <bd_> > msum $ map maybeToList [Nothing, Just 1, Just 3, Nothing, Just (-1)]
13:49:28 <lambdabot>  [1,3,-1]
13:49:43 <zeeeee> > foldM msum [Nothing, Just 0]
13:49:44 <lambdabot>    Occurs check: cannot construct the infinite type: a = m [b -> a]
13:49:44 <lambdabot>    E...
13:49:47 <bd_> zeeeee:
13:50:05 <bd_> > foldr mplus mzero [Nothing, Just 0]
13:50:06 <lambdabot>  Just 0
13:50:16 <nmessenger> AStorm: Um, I dunno.  I don't grok much beyond IO.
13:50:30 <bd_> it's not foldM since we're doing a meta operation on monads here
13:52:36 <AStorm> > foldr mplus mzero [Nothing, Just 0, Just (-1), Just 1, Just 10, Nothing, Just 5]
13:52:37 <lambdabot>  Just 0
13:52:40 <nmessenger> > foldM (+) [Nothing, Just 1, Just 3, Nothing, Just (-1)]
13:52:41 <lambdabot>    Occurs check: cannot construct the infinite type: b = m b
13:52:41 <lambdabot>    Expected...
13:53:06 <sjanssen> ex0r: simplify to "split_tokens_sys xs = takeWhile (\(x, _) -> x /= 6) xs"
13:53:19 <bd_> :t foldM
13:53:20 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
13:53:33 <sjanssen> reverse (takeWhile (\(x, _) -> x /= 6) xs) to get reversed output
13:53:35 <nmessenger> bd_: darnit I was gonna do that
13:53:43 <bd_> heh
13:53:55 <nmessenger> > foldM (Just . (+)) [Nothing, Just 1, Just 3, Nothing, Just (-1)]
13:53:55 <lambdabot>    Expecting a function type, but found `c'
13:53:55 <lambdabot>    Expected type: a -> b -> ...
13:54:10 <bd_> nmessenger: + takes two args :)
13:54:16 <nmessenger> > foldM (Just . (+)) [Nothing, Just 1, Just 3, Nothing, Just (-1)] Just 0
13:54:17 <lambdabot>    Expecting a function type, but found `c'
13:54:17 <lambdabot>    Expected type: a -> b -> ...
13:54:20 <nmessenger> > foldM (Just . (+)) [Nothing, Just 1, Just 3, Nothing, Just (-1)] $ Just 0
13:54:21 <lambdabot>    Expecting a function type, but found `c'
13:54:21 <lambdabot>    Expected type: a -> b -> ...
13:54:54 <nmessenger> > foldM (\x y -> Just $ x + y) [Nothing, Just 1, Just 3, Nothing, Just (-1)] $ Just 0
13:54:55 <lambdabot>  Couldn't match `[[Maybe a]]' against `Maybe a1'
13:55:00 <bd_> there's /msg >.>
13:55:12 <nmessenger> *blush*
13:55:56 <zeeeee> > foldM mplus mzero [Nothing, Just 0]
13:55:57 <lambdabot>    Occurs check: cannot construct the infinite type: a = m a
13:55:57 <lambdabot>    Expected...
13:55:57 * nmessenger is an IRC noob
13:56:01 <zeeeee> > foldr mplus mzero [Nothing, Just 0]
13:56:03 <lambdabot>  Just 0
13:56:12 <zeeeee> @type foldM
13:56:13 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
13:56:15 <zeeeee> @type foldr
13:56:16 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
13:57:12 <MarcWeber> I want to cabalize greencard as the makefile doesn't work here. Can't be that much work, can it? I'm getting this error although specifying hs-source-dirs: http://www.rafb.net/paste/results/9Gn0kY66.html Whats still wrong?
13:57:34 <AStorm> zeeeee, that doesn't work.
13:57:40 <AStorm> :>
13:57:55 <zeeeee> argh
13:58:00 <AStorm> Hmm, and you can't use fromJust, because there are Nothings.
13:58:21 <AStorm> (unless you special-case that.
13:58:40 <zeeeee> i was just trying to understand what's going on
13:58:45 <zeeeee> > foldl mplus mzero [Nothing, Just 0]
13:58:47 <lambdabot>  Just 0
13:58:51 <vincenz> Anyone know where Binkley's gone to?
13:58:54 <zeeeee> > foldl mplus mzero [Nothing, Just 0, Just 1]
13:58:55 <lambdabot>  Just 0
13:58:58 <zeeeee> > foldr mplus mzero [Nothing, Just 0, Just 1]
13:58:59 <lambdabot>  Just 0
13:59:02 <vincenz> lambdabot: you're back!
13:59:04 <vincenz> @yow
13:59:04 <lambdabot> I know th'MAMBO!!  I have a TWO-TONE CHEMISTRY SET!!
13:59:05 <zeeeee> hmm
13:59:29 <AStorm> Hmm, implement some Just/Nothing summation and you're set.
13:59:38 <nmessenger> > sum $ catMaybes [Nothing, Just 1, Just 3, Nothing, Just (-1)]
13:59:39 <lambdabot>  3
13:59:40 <AStorm> Quite simple, 4 variants :>
13:59:42 <nmessenger> :)
13:59:57 <AStorm> > sum $ catMaybes [Nothing, Nothing, Nothing]
13:59:58 <lambdabot>  0
14:00:05 <AStorm> Hmm... it even does work :P
14:00:20 <zeeeee> > sum []
14:00:21 <lambdabot>  0
14:00:42 <AStorm> > sum ['a', 'b', 'c']
14:00:42 <lambdabot>  add an instance declaration for (Num Char)
14:00:42 <lambdabot>   In the definition of `lxt': ...
14:00:51 <zeeeee> @type mplus
14:00:52 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
14:01:08 <AStorm> > mplus Nothing Just 10
14:01:09 <lambdabot>  Couldn't match `(->) t' against `Maybe'
14:01:17 <AStorm> > mplus mzero Just 10
14:01:18 <lambdabot>  add an instance declaration for (MonadPlus ((->) a))
14:01:23 <nmessenger> > sum (map ord ['a', 'b', 'c'])
14:01:24 <lambdabot>  294
14:01:36 <AStorm> nmessenger, I know :P
14:01:42 <AStorm> Or even:
14:01:54 <AStorm> > sum . ord ['a','b','c']
14:01:54 <lambdabot>    Expecting a function type, but found `Int'
14:01:54 <lambdabot>    Expected type: a1 -> [a...
14:02:00 <zeeeee> foldM (+) 0 [Just 1, Nothing, Just 2]
14:02:05 <AStorm> > sum . ord $ ['a','b','c']
14:02:05 <lambdabot>  Couldn't match `[a]' against `Int'
14:02:06 <zeeeee> > foldM (+) 0 [Just 1, Nothing, Just 2]
14:02:07 <lambdabot>    Occurs check: cannot construct the infinite type: b = m b
14:02:07 <lambdabot>    Expected...
14:02:10 <vincenz> > sum . map ord $ ['a', 'b', 'c']
14:02:11 <lambdabot>  294
14:02:21 <AStorm> Blah.
14:02:52 <AStorm> > foldr ((+) . ord) ['a', 'b', 'c']
14:02:53 <lambdabot>  Couldn't match `Int' against `[a]'
14:03:03 <AStorm> > foldr (ord . (+)) ['a', 'b', 'c']
14:03:04 <lambdabot>    Expecting a function type, but found `b'
14:03:04 <lambdabot>    Expected type: a -> Char
14:03:04 <lambdabot> ...
14:03:23 <zeeeee> > foldr (+) . map ord $ ['a','b']
14:03:24 <lambdabot>  add an instance declaration for (Num [Int])
14:03:28 <zeeeee> > foldr (+) 0 . map ord $ ['a','b']
14:03:29 <lambdabot>  195
14:03:35 <zeeeee> > foldr (+) 0 . map ord $ ['a','b','c']
14:03:36 <lambdabot>  294
14:03:57 <AStorm> > foldr ((+) . ord) 0 ['a', 'b', 'c']
14:03:58 <lambdabot>  294
14:04:14 <nmessenger> @help check
14:04:14 <lambdabot> check <expr>
14:04:14 <lambdabot> You have QuickCheck and 3 seconds. Prove something.
14:04:36 <nmessenger> @help (\xs -> sum xs == foldr (+) 0 xs)
14:04:36 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:04:43 <nmessenger> @check (\xs -> sum xs == foldr (+) 0 xs)
14:04:44 <lambdabot>  Add a type signature
14:04:58 <nmessenger> @check (\xs -> sum xs == foldr (+) 0 xs) :: [Int] -> Bool
14:04:59 <lambdabot>  OK, passed 500 tests.
14:05:01 <zeeeee> > foldM mplus mzero [Just 1, Nothing, Just 2]
14:05:01 <lambdabot>    Occurs check: cannot construct the infinite type: a = m a
14:05:02 <lambdabot>    Expected...
14:05:19 <Saizan> foldr!
14:05:27 <nmessenger> yup, sum = foldr (+) 0
14:05:28 <beelsebob> > let apply [] x = 0; apply ((m,e):ys) x = m * (x^e) + apply ys x; diff [] = []; diff ((m,e):xs) = if e > 0 then (m * e, e-1):(diff xs) else diff xs; n f x = x:(n f (x - ((apply f x) / (apply (diff f) x)))) in take 6 $ n [(1,2),(-2,0)] 1
14:05:29 <lambdabot>  Add a type signature
14:05:34 <sjanssen> nmessenger: you probably want to use foldl' instead.  foldr will blow up the stack
14:05:37 <nmessenger> Gah!
14:05:47 <AStorm> beelsebob, wtf?
14:05:51 <nmessenger> well, they're semantically equivalent anyway
14:06:17 <AStorm> Not really.
14:06:19 <sjanssen> nmessenger: depends on the definition of (+)
14:06:23 <AStorm> @type foldl
14:06:24 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
14:06:30 <beelsebob> AStorm: trying to check what the hell's going on - I'm getting a weird error on my computer and no weird error on another... wanted to see which lambdabot agreed with
14:06:31 <AStorm> @type foldr
14:06:32 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
14:06:49 <nmessenger> -.-;;
14:07:07 <Excedrin> > foldr ((. fromEnum) . (+) . fromEnum) 0 "foobar"
14:07:08 <lambdabot>  633
14:07:15 <nmessenger> lol
14:07:27 <AStorm> Numerology?
14:07:44 <nmessenger> Nope, we're just re-implementing sum :D
14:07:47 <AStorm> > foldl (ord . (+)) 0 "blah"
14:07:47 <lambdabot>    Expecting a function type, but found `b'
14:07:47 <lambdabot>    Expected type: a -> Char
14:07:47 <lambdabot> ...
14:07:57 <beelsebob> > let apply :: [(Double,Int)] -> Double -> Double; apply [] x = 0; apply ((m,e):ys) x = m * (x^e) + apply ys x; diff [] = []; diff :: [(Double,Int)] -> [(Double,Int)]; diff ((m,e):xs) = if e > 0 then (m * e, e-1):(diff xs) else diff xs; n :: [(Double,Int)] -> Double -> [Double]; n f x = x:(n f (x - ((apply f x) / (apply (diff f) x)))) in take 6 $ n [(1,2),(-2,0)] 1
14:07:57 <lambdabot>    Conflicting definitions for `diff'
14:07:57 <lambdabot>   In the binding group for: apply, ...
14:08:04 <beelsebob> :/
14:08:13 <beelsebob> lambdabot just complains bitterly about too much garbage I see
14:08:18 <AStorm> > sum "sum"
14:08:19 <lambdabot>  add an instance declaration for (Num Char)
14:08:19 <lambdabot>   In the definition of `uqk': ...
14:08:33 <Excedrin> > foldl ((. ord) . (+) . ord) 0 "blah"
14:08:34 <lambdabot>  Couldn't match `Char' against `Int'
14:08:50 <AStorm> The other way around.
14:09:19 <AStorm> > foldl ((+) . (. ord)) 0 "blah"
14:09:20 <lambdabot>  Couldn't match `Int' against `Char'
14:09:29 <Excedrin> oh, I thought ord was the same as fromEnum
14:09:36 <Excedrin> @t ord
14:09:36 <lambdabot> Maybe you meant: tell time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
14:09:40 <AStorm> UHhhhh... I have to recheck the semantics.
14:09:44 <Excedrin> @type ord
14:09:46 <lambdabot> Char -> Int
14:09:55 <nmessenger> :t fromEnum
14:09:56 <lambdabot> forall a. (Enum a) => a -> Int
14:09:57 <AStorm> @type fromEnum
14:09:58 <lambdabot> forall a. (Enum a) => a -> Int
14:10:28 <AStorm> For Char they're same.
14:11:13 <nmessenger> ?info Char
14:11:13 <lambdabot> Char
14:11:21 <nmessenger> Well, that was unhelpful
14:11:23 <shapr> yarr
14:11:36 <AStorm> @hoogle Char
14:11:36 <lambdabot> Char :: module
14:11:36 <lambdabot> Data.Char :: module
14:11:36 <lambdabot> Text.ParserCombinators.Parsec.Char :: module
14:11:49 <AStorm> @docs Data.Char
14:11:50 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Char.html
14:12:09 <nmessenger> Can lambdabot give me the equivalent of ghci's :info?
14:13:24 <Excedrin> @instances Char
14:13:25 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
14:13:54 <AStorm> @instances Data.Char
14:13:54 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
14:14:04 <AStorm> :/
14:14:23 <AStorm> It really isn't a class, just a type.
14:14:47 <nmessenger> At-instances gives you types that instantiate a class, not classes a specific type instantiates.
14:15:39 <AStorm> @instances Enum
14:15:39 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
14:15:48 <AStorm> (flood me ;-) )
14:15:54 <SamB> @instances-for Char
14:15:54 <lambdabot> Unknown command, try @list
14:16:56 <AStorm> Maybe something like @implements?
14:17:55 <metaperl> AStorm - do I know you from #python
14:18:11 <AStorm> Yes, you do.
14:18:16 <SamB> ack, not #python!
14:18:20 <metaperl> ah
14:18:23 <SamB> or was this years back?
14:18:37 <metaperl> No, just recently
14:18:44 <metaperl> Python is much closer to haskell than perl
14:19:08 <metaperl> i'm lucky to have a day job doing python... after 6 years of perl, it is nirvana
14:19:16 <SamB> but, I think either #python is getting dumber or I am getting more arrogant...
14:19:17 <AStorm> And even closer to Lisp.
14:19:47 <AStorm> It depends.
14:20:53 <SamB> at least Python users aren't mostly self-serving arrogant elitist snobs...
14:21:09 <shankys> I've been developing a Haskell web framework that is coming along quite nicely, but I've hit a roadblock that I need to solve. I'm currently using Network.FastCGI to output a .fcgi file that Lighttpd runs. However, having to compile every time I make changes takes a long time now that I have a few thousand lines of code. Does anyone have any ideas as to how I could not have to compile code every time I make changes, and make this work 
14:21:30 <nmessenger> Python getting *closer* to lisp?  I present counter-evidence: http://www.artima.com/weblogs/viewpost.jsp?forum=106&thread=4550
14:21:32 <lambdabot> Title: News from Python UK
14:21:40 <SamB> shankys: maybe it wouldn't take so long if you used -fasm
14:21:42 <AStorm> Uh? Shouldn't FastCGI cache the .fcgi?
14:22:00 <AStorm> nmessenger, dynamically typed, but strongly
14:22:09 <AStorm> Somewhat inbetween :P
14:22:14 <shoffsta> shankys: shall I come over to work on this?
14:22:38 <SamB> shankys: or are you already using -fasm?
14:22:40 <shankys> AStorm: I mean every time I make changes to the website -- for I use Text.XHtml.Transitional to generate XHTML so when I change this, I have to recompile.
14:23:05 <SamB> oh.
14:23:08 <shankys> SamB: I'm not already using -fasm. How much of a difference does this make?
14:23:15 <Masklinn> hello again
14:23:17 <SamB> shankys: a lot
14:23:37 <shankys> shoffsta: Probably not today because I have 2 finals tomorrow, but definitely the day after tomorrow.
14:23:37 <SamB> gcc is *sloooow*
14:23:48 <SamB> but, why is your website itself written in Haskell?
14:23:49 <shoffsta> ok
14:23:52 <SamB> shouldn't it be data?
14:23:59 <inv2004> re
14:24:05 <Excedrin> shankys: could you use Hugs?
14:24:12 <SamB> heh
14:24:23 <inv2004> is it possible to eval expression immediately ?
14:24:35 <SamB> immediately when?
14:24:36 <AStorm> HSP = Haskell Server Pages? :>
14:24:37 <shankys> Excedrin: I'd really prefer to use GHC if possible, but might be willing to switch if it would really help.
14:24:45 <bringert> shankys: I've written some code which uses the GHC API to load haskell source and interpret it
14:24:49 <bringert> for web apps
14:24:58 <SamB> AStorm: oh. well. why do you use HSP like it was PHP?
14:25:13 <shankys> bringert: Really? I'd be interested in checking it out if you are willing to share.
14:25:13 <SamB> or, not you.
14:25:22 * bringert tries to find it
14:25:29 <nmessenger> inv2004: what do you mean?
14:25:43 <inv2004> hm, thinking how to say
14:26:14 <bringert> shankys: http://www.cs.chalmers.se/~bringert/darcs/dyn-cgi/
14:26:15 <lambdabot> Title: Index of /~bringert/darcs/dyn-cgi
14:26:37 <bringert> shankys: it works ok, but could be improved
14:27:07 <nmessenger> inv2004: do you mean strict?
14:27:13 <shankys> bringert: If it's useful to me, and I end up using and improving it I'll send you patches ;)
14:27:16 <inv2004> maybe yes
14:27:18 <bringert> it gives you nice syntax highlighted and error highlighted source code, and error pages with links to the errors in the source
14:28:34 <nmessenger> inv2004: what context do you need strictness in?
14:29:09 <inv2004> while debugging
14:29:19 <bringert> shankys: and it only reloads and recompiles when the file has changes
14:29:33 <nmessenger> inv2004: give some code
14:29:44 <nmessenger> ?paste
14:29:44 <lambdabot> http://paste.lisp.org/new/haskell
14:29:57 <bringert> shankys: here's what you get if you have errors in your code: http://csmisc14.cs.chalmers.se/~bjorn/dynhs/examples/error.hs
14:30:11 <inv2004> where'is too much code, trying to find example
14:30:27 <shankys> bringert:  Nice...
14:30:39 <bringert> shankys: here's a small wiki run by this system: http://csmisc14.cs.chalmers.se/~bjorn/dynhs/examples/wiki/wiki.hs
14:30:42 <lambdabot> Title: Main
14:30:59 <bringert> I should announce this at some point I guess
14:32:32 <shankys> bringert: Yeah, this looks pretty useful. Solving the not having to compile all the time problem and figuring out how to route requests elegantly are the only two things that currently annoy me when using the Haskell web framework I'm writing.
14:33:25 <bringert> shankys: great! let me know how it works out
14:35:23 <chessguy> 'evening
14:36:34 <shankys> bringert: Will do. I'll probably eventually release the framework I'm writing under the BSD or MIT license if anyone's interested in playing around with it. It's kind of Ruby on Rails like (except it's all Haskell). I plan on actually having good documentation so hopefully I can get other people interested in contributing.
14:36:34 <bringert> excellent! we need something like that.
14:36:34 <emu> have you seen happs btw?
14:36:38 <shankys> emu: I have seen happs, but it didn't "feel" right programming in it.
14:36:45 <shankys> emu: It's got a lot of great features though.
14:54:47 --- topic: '["Get yourself some cognitive dissonance!", "Haskell - the language of ICFP winners 3 years running", "Logs: http://tunes.org/~nef/logs/haskell/"]'
14:54:47 --- topic: set by dons on [Fri Dec 08 21:02:10 2006]
14:54:47 <bd_> CONFIG += qt debug
14:54:53 <bd_> err
14:54:57 <bd_> curse you, putty
14:55:08 <shapr> I looked at django, but I don't see what's so great about its templating .
14:55:11 <emu> mm right clicking
14:57:03 <IPI> Quick Question: what does this line really do? i don't undrestand what p is :
14:57:13 <bringert> shapr: hmm, I don't know. I've rewritten parsedate to use Data.Time and incorporated it into the time package. Then there is cgi-light, which is basically a simple cgi for teaching. I think you have seen my version of Haskell Web Server already, and the dyn-cgi stuff I showed shankys. Nothing very exiting.
14:57:15 <shapr> shankys: From what I've seen, RoR uses a lot of english-specific conventions that remind me of JavaBeans autogenerated code.
14:57:23 <IPI> lst = [x | x <- [1..9], (p x)]
14:57:33 <shapr> > [1..9]
14:57:38 <shapr> oh
14:57:57 <shapr> IPI: [1..9] is short for [1,2,3,4,5,6,7,8,9]
14:58:00 <sjanssen> IPI: p must be some function defined elsewhere in the example?
14:58:01 <bringert> RoR seems a bit too automatic sometimes, but I've never used it. I get the feeling that you could do better in Haskell.
14:58:12 <shankys> shapr: I really like RoR on the whole, but that's actually one thing I really dislike about it. There a little too much magic in RoR for my tastes.
14:58:31 <IPI> sjanssen, i don't know .. this is all i have
14:58:36 <shapr> Yeah, RoR reminds me of Plone, where it's great if you want to do it the way the framework is designed, and masochistic if you want to modify the framework to do something else.
14:58:59 <sjanssen> IPI: in that example it is being used as a "guard", it means that x is included in the result if "p x" evaluates to True
14:59:05 <IPI> the question asks us to rewrite this to prolog, but i need to undrestand what does this do in haskell first
14:59:21 <shankys> Exactly, but for what RoR is designed for, it's pretty much the best there is.
14:59:29 <SlowByte> RoR not really *a* framework though... it's a couple of frameworks bolted together :)
14:59:29 <shapr> bringert: oh hey, do you know of anything that has a lazy Calendar data structure? I want to hack up a wimpy google calendar clone in HAppS...
14:59:33 <IPI> oh... so sjanssen , p is function returning a bool and takes in an int right?
14:59:43 <IPI> p:: Int -> Bool ??
15:00:00 <sjanssen> IPI: yeah, some kind of number -> Bool
15:00:15 <bringert> shapr: what's a lazy calendar? a list of all the days from now to eternity?
15:00:17 <IPI> ok .. that makes sence .. :) Thanks
15:00:19 <SlowByte> eg. if you don't like ActiveRecord you don't have to use it but then you don't get all the plugins other people write...
15:00:25 <emu> IPI: it's filtering the list
15:00:35 <shapr> shankys: I'm fine with magic conventions as long as I have the option to ignore them and still use parts of the original functionality. Plone does not allow that with any reasonable amount of effort.
15:00:51 <emu> IPI: it's the same thing as: filter p [1..9]
15:00:52 <bringert> shapr: I think you could use the time package for that
15:00:53 <IPI> emu: yes .. now i need to rewrite this in prolog... but i guess this is not the right channel :)
15:01:08 <shapr> bringert: oh? how so? Was I looking at the wrong time package?
15:01:09 <shankys> shapr: I've never used Plone, but there were a lot of times where I felt that way about RoR
15:01:29 <IPI> one more thing: there is no loop in Haskell right?
15:01:33 <sjanssen> IPI: I could help you write it in the logic programming language embedded in Haskell's type system . . . but I bet that wouldn't help
15:01:37 <sjanssen> IPI: correct
15:01:44 <bringert> shapr: well, there is no function for exactly that, but you could iterate adding one day or something
15:01:45 <shapr> IPI: Or from another viewpoint, looping is a library in Haskell.
15:01:59 <emu> sjanssen: how many olegs would that consume?
15:02:05 <SlowByte> @hoogle loop
15:02:21 <TSC> lambdabot is asleep
15:02:22 <bringert> shapr: by time library I mean the time package in GHC extralibs
15:02:36 <sjanssen> emu: sub oleg levels, depends on how complicated the predicate is
15:02:54 <IPI> ok .. thanks guys ..
15:03:06 <astrolabe> @bot
15:03:13 <astrolabe> :(
15:03:38 <shapr> Anyway, I want a decent templating solution for HAppS.
15:03:50 <bringert> shapr: look at Data.Time.Calendar and Data.Time.Calendar.WeekDate
15:04:03 <bringert> I think there should be most of what you need for a calendar there
15:04:23 <shapr> And though I am aware of the good and bad points of several templating approaches, I've never tried to put together a comprehensive overview.
15:04:28 <shapr> So I'm probably missing something good somewher.
15:04:45 <Excedrin> what's wrong with the xsl stuff?
15:05:28 <emu> probably the X part
15:05:40 <shapr> Maybe nothing, actually.
15:05:58 <emu> i like it in theory
15:06:00 <shapr> I described my misgivings to alexj and he had an interesting solution.
15:06:49 <shapr> He suggested that we find a convention for turning any Haskell value into an XML value, and then use that in xml/xslt templating.
15:07:25 <shapr> My biggest misgiving with the way it's currently done in HAppS is that I have to explicitly define an instance of ToXml (or something like that, I forget the exact name).
15:08:23 <shapr> One of the good things about ZPT was that I could iterate over any Python datatype, and pull attributes out into text or whatever.
15:10:02 <shapr> HaXml 1.15+ already has the XmlContent typeclass, meaning the next step would be a way to autoderive XmlContent.
15:10:21 <Cale> It might also be possible to do something with Data.Generics?
15:10:24 <shapr> I investigated doing that with TH for awhile, but it's just too painful.
15:10:28 <shapr> Cale: yes, exactly.
15:10:41 <shapr> Alex suggested using SYB instead of TH for sheer comprehensibility.
15:10:51 <Cale> I also recently played around with HXT, and it's really very nice.
15:11:10 <Cale> though I don't know if it contains a solution to that problem at all
15:12:21 <shapr> I haven't looked at SYB in many moons, is there a tutorial somewhere? Or should I just read the papers?
15:13:17 <shapr> Even so, SYB would only answer one part of the templating question. I'd still to see a templating system that works equally well for sgml and text-only emails.
15:13:42 <Cale> I'm not sure actually. I think I just read the first couple of papers, and played around with it a short while. I can't claim to really completely understand how everything works.
15:15:56 <Cale> Well, one thing I just realised is nice about the HXT approach is that you're working with arrows which might take XMLTrees to other XMLTrees, but in general work with arbitrary types. That's not the same as being able to search through and select from Haskell datastructures though.
15:17:17 <Cale> If you were to write a generic instance of ArrowTree, you could use the same tools for searching Haskell data as XML though.
15:17:21 <dibblego> http://syntaxfree.wordpress.com/2006/12/12/do-notation-considered-harmful/ -- can anyone interpret monchrom's comment? it's not English
15:17:49 <shapr> Cale: XSLT for ADT traversal? :-)
15:18:06 <dibblego> oh, unless you put a comma in - is one possible interpretation
15:18:31 <vincenz> lambdabot dead?
15:19:24 <Cale> shapr: well, I think to do that, you'd still have to map it to XmlTrees first. I just mean that the arrow combinators which they've designed for working with trees directly in Haskell would work. I think the XSLT stuff is specifically tuned to working with XmlTrees
15:20:21 <Cale> dibblego: uh, where is monochrom's comment?
15:20:32 <dibblego> at the top
15:20:35 <shapr> It's in the blog post itself.
15:20:38 <dibblego> it's ok, I figured it out
15:20:57 <vincenz> dibblego: share
15:21:23 <dibblego> if there is a comma after "authors", it makes more sense
15:21:50 <vincenz> oh
15:21:51 <vincenz> I parsed it fine
15:21:54 <Cale> the 'who' can't refer to anyone but the authors
15:22:00 <vincenz> I'm stuck on the semantic-analysis level
15:22:09 <vincenz> parsing and typing is fine for me on that sentence
15:22:14 <vincenz> it's the denotational semantics which are lacking
15:23:06 <Cale> The answer to monochrom's question is that these authors want to explain the mathematical abstract concepts to large groups of people who have no experience working with the mathematical language used to express those abstractions.
15:23:19 <shapr> truly
15:24:08 <shapr> I tried to explain to my sister what was wonderfully useful about (a >>= b) >>= c === a >>= (b >>= c) but I don't think she really got it.
15:24:22 <Cale> That's not type correct
15:24:24 <vincenz> shapr: she probably said "so many arrows!"
15:24:49 <Cale> You possibly mean without the = signs
15:25:00 <Cale> (a >> b) >> c = a >> (b >> c)
15:25:03 <shapr> yeah, === should be the three bar equals
15:25:06 <emu> comma after authors would be commaitis
15:25:23 <shapr> What's it called, extensional equality?
15:25:35 <vincenz> shapr: his point is that your first one doesn't type
15:25:36 <Cale> (a >>= b) >>= c == a >>= (\x -> b x >>= c)
15:25:47 <shapr> ah, right
15:25:50 <emu> thats the 3rd monad law
15:26:14 <Cale> well, exactly one of the two sides of shapr's equation will type
15:26:18 <shapr> :-)
15:27:01 <Excedrin> four remote execution vulns in IE and two in wmp
15:28:28 <shapr> Security by Obscurity works oh so well.
15:31:26 <Guest25023> what's so wonderful about the third law?
15:35:03 <sorear> dons: lambdabot is dead again
15:35:20 <newsham> if you meet the monad on the road, kill him.
15:43:29 <boulez`> I'm looking for the appropriate idiom for: a function takes in a value of a datatype and returns a simpler value, i.e. a value guaranteed to contain only a subset of the datatype's constructors
15:46:50 <Pseudonym> It's a special case of a "view".
15:46:55 <Pseudonym> That's what it's called.
15:48:15 <boulez`> OK... but it seems like views were never implemented?
15:49:16 <Pseudonym> Automatic views, no.
15:49:28 <Pseudonym> But there's no reason why you can't implement them yourself.
15:50:17 <Pseudonym> http://www.haskell.org/hawiki/ConcreteView
15:56:02 <qwas> are there any dynamic code generation or assembler tools written in haskell? (for x86 assembly)
15:58:07 <sorear> yes... the GHC NCG?
15:58:48 <sorear> (native code generator, the backend component that generates x86, ppc, etc. assembly)
15:59:07 <Lemmih> qwas: Not readily available, afaik.
15:59:22 <sorear> If I second-guess your question correctly, you may wish to look into hs-plugins.
15:59:29 <qwas> hmm
16:00:23 <IPI> i am confused ... how does foldl work? anyone can explain this example please :
16:00:24 <IPI> Input: foldl (/) 64 [4,2,4]
16:00:24 <IPI> Output: 2.0
16:00:44 <newsham> > (((64 / 4)/2)/4)
16:01:02 <sorear> foldl f z [a,b,c] == (((z `f` a) `f` b) `f` c)
16:02:00 <newsham> imperative:   x = 64; for y in [4,2,4] : x = x / y; return x
16:02:18 <Masklinn> consider that foldl performs some kind of stack consumption from left to right:
16:02:20 <IPI> so it takes the second argument and first item from the list , then feeds it to the function , then takes the result and uses it and perform the function again on the result and second item on the list ... and etc ?
16:02:22 <newsham> (fold iterates over a list keeping a loop-carried variable accumulating the result)
16:02:30 <Masklinn> IPI > yeah
16:02:47 <Masklinn> it accumulates from left to right
16:02:52 <IPI> right ... nice ...
16:02:55 <Masklinn> (while foldr accumulates from right to left)
16:02:55 <Itkovian> http://buytaert.net/community-in-the-21st-century
16:03:10 <Itkovian> I don't have the youtube link, so ...
16:03:17 <IPI> Thanks :)
16:03:49 <Masklinn> BTW
16:03:54 <Masklinn> @type foldl
16:04:01 <Masklinn> damn he's still broken
16:04:15 <Masklinn> foldl :: (a -> b -> a) -> a -> [b] -> a
16:04:32 <Masklinn> you'll note that the types of the "initial value" and the sequence values are not the same
16:04:51 <Masklinn> which means that you can generate fairly complex operations using folds
16:05:44 <sorear> fold has a 'universal property' that you can represent any inductively-defined function on lists using folds
16:06:19 <IPI> Masklinn, i got one of those complex on here ... f x y = foldl (\k l -> (div k 2) + l) 0
16:06:19 <IPI> [a + b + c | a <- [2..x], b <- [y..a^2], c <- (reverse [a..b])]
16:06:28 <Masklinn> I don't know about IPI, but you just made my head explode sorear
16:06:50 <IPI> f x y = foldl (\k l -> (div k 2) + l) 0
16:06:50 <IPI> [a + b + c | a <- [2..x], b <- [y..a^2], c <- (reverse [a..b])]
16:06:52 <newsham> then our job here is done!
16:07:16 <IPI> so here, i would take 0 and what ever that list comprehension produces and perform that function to it
16:07:19 <IPI> basically
16:07:32 <Masklinn> yeah
16:07:56 <IPI> right ... then get the result and do the same thing with second item on the list until we reach the end of the list
16:08:01 <newsham> (\k l -> (div k 2) + l)   looks like building up a fractional binary number
16:08:18 <SlowByte> how universal are inductively-defined functions on lists?
16:08:20 <Masklinn> IPI > yeah
16:08:44 <newsham> hmm.. well, not qiute, cause div is over integers :)  nevermind :)
16:09:13 <IPI> well i think i undrestand foldl .. so what is the diffrence between foldl and foldr
16:10:04 <sorear> foldr (+) 0 [1,2,3] = 1 + (2 + (3 + 0))
16:10:16 <newsham> heh, i was typing exactly that.
16:10:17 <sorear> foldl (+) 0 [1,2,3] = ((0 + 1) + 2) + 3
16:10:48 <IPI> so sorear , basically beside performing the function on every element on the list, there is also a starter point
16:10:49 <Masklinn> the most important difference in haskell is that foldl always consumes the whole list, which means that it blows up for infinite lists
16:10:53 <sorear> foldr is generally a better fit for haskell data structures
16:11:13 <sorear> foldl interacts badly with infinite structures and laziness
16:11:23 <newsham> also foldr is appropriate for right-assoc operators.
16:11:29 <sorear> generally, if you have a choice, you shouldn't use foldl
16:11:34 <Masklinn> most other functional languages (with eager evaluation) use foldl because it's tail recursive
16:11:42 <Masklinn> and they don't care about lazyness
16:11:52 <sorear> emphasis on if you have a choice - e.g. reverse is a poor fit for foldr
16:12:08 <sorear> but with foldl reverse is easy : reverse = foldl (flip (:)) []
16:12:15 <Masklinn> oh, and if you want folds without initial values, there are foldl1 and foldr1
16:12:48 <boulez`> Pseudonym: I don't think that's going to quite cut it because I want the functions written for the old type to work with the new type; and all the functions for the new one would have to convert their inputs to the new, then convert intermediate values to the old to pass to functions that will themselves convert to the new, etc.
16:12:50 <Masklinn> (they only take a lambda and a sequence, and will start by applying the lambda to the first two values of the supplied sequence)
16:12:55 <sorear> ... but fold[lr]1 are partial functions, and if you pass an empty list by accident you'll get a runtime error
16:13:03 <newsham> hmm.. i smell a haskell slogan in there somewhere...  "do you fold right?"  or "you're not one of those left folders are you?"
16:13:24 <sorear> Haskell has very little support for debugging runtime errors - beware.
16:13:48 <IPI> good stuff ..  Thanks guys :)
16:14:43 <mwolak> does foldr cause stack overflows for very long lists?
16:15:44 <boulez`> Pseudonym: the only idea I have is to define the functions on the old type in terms of folds, then overload the fold function to work with both types
16:15:56 <Pseudonym> What you want is subtyping.
16:17:01 <Masklinn> mwolak> yes
16:17:55 <Masklinn> does for me anyway
16:17:56 <dibblego> Not in scope: type constructor or class 'Foo' -- what does that mean when it is in the same source file?
16:18:20 <dibblego> er nothing
16:18:27 <Masklinn> that you have defined a new type but not its type constructor?
16:18:29 <newsham> it means it isnt :)
16:18:36 <boulez`> Pseudonym: and that leaves me no choice but O'Haskell?
16:18:42 <dibblego> I had T => U around the wrong way
16:18:46 <mwolak> yeah, same here on ghci... I was wondering why people were so hard on foldl... I tend to use foldl' alot cause I've been burned by foldr's stack issues before
16:18:56 <Excedrin> you have data SomeType = Foo ... and get that error?
16:19:29 <Masklinn> mwolak > that's because of haskell lazyness: foldl requires the complete evaluation of the list, while foldr generates a lazy evaluation (it only evaluates as much as you need)
16:20:01 <Masklinn> so most functional languages use foldl, but haskell prefers foldr, because it's a much better fit for Haskell's ways
16:20:54 <Masklinn> check the wikipedia page on folds, it has a good explanation on the issue
16:21:12 <chessguy> @go wikipedia fold
16:21:15 <astrolabe> I don't understand why haskell's 'sum' isn't written with foldl'
16:21:28 <astrolabe> also maximum
16:21:28 <allbery_b> foldl' is strict and therefore doesn't have the stack issues, though, right?
16:21:28 <chessguy> augh, bot's gone again??
16:21:39 <astrolabe> chessguy: yeah
16:21:42 * chessguy mutters under his breath
16:21:48 <allbery_b> there was another netsplit apparently
16:23:38 <Excedrin> GHC's sum is based on: sum' (x:xs) a = sum' xs (a+x)
16:23:38 <ptolomy> does anyone use O'Haskell for anything other than research and play?
16:24:31 <Pseudonym> Sure!  I use it as an example when discussing programming languages.
16:24:43 <Pseudonym> Not what you meant, right?
16:25:40 <astrolabe> Excedrin: maybe, but it something that is inefficient with space.
16:26:15 <sorear> Why does lambdabot take so badly to netsplits?
16:26:26 <Masklinn> astrolabe > how's it inefficient with space?
16:26:39 <mbishop> sorear: he's lazy?
16:26:41 * mbishop runs
16:27:05 <allbery_b> my bitchx instance seems to not catch on to the server it's on going away either
16:27:12 <Masklinn> astrolabe > it only ever uses the room for an integer, and an ever-shriking list
16:27:15 <chessguy> mbishop, in here, that's a compliment
16:27:17 <Excedrin> astrolabe: I just tested foldl' vs GHC's sum, they appear to use the same space, but GHC's is slightly faster
16:27:19 <allbery_b> can take several hours to realize the server's not there and reconnect
16:28:38 <allbery_b> presumably if it doesn't do a heartbeat check of some kind (e.g. no messges reveived in past 5 minutes) it only finds out when the kernel's keepalive expires
16:29:19 <sorear> I thought splits were usually connection loss, not server crashes ?
16:29:56 <astrolabe> Masklinn:  sum' [1:2:3] 0 = sum' [2:3] (0+1) = sum' [3] ((0+1)+2) = sum' [] (((0+1)+2)+3) = ((0+1)+2)+3 = (1+2)+3 = 3 + 3 = 6
16:29:59 <sorear> (If it is server crashes, why do the freenode ops keep their hardware+OS+ircd?)
16:31:08 <wy> What's the best way to put one item into a list, say it's generated with a long expression? [ a-very-very-very-very-very-very-very-very-very-very-very-very-very-long-expression ]
16:31:28 <sorear> Maybe I should implement a feature in LB such that it runs some innocuous command (like WHO lambdabot ) every 5 minutes of inactivity...
16:31:32 <sorear> (:[]) ?
16:32:09 <glguy> > (:[]) "I should probably break this up into a couple different lines"
16:32:16 <astrolabe> heh
16:32:38 <lucca> sorear: or just use the PING command
16:32:44 <allbery_b> sorear: my backscrool shows the server going away and unable to connect until it rotated to a different server, fwiw
16:32:59 <Masklinn> astrolabe > so?
16:33:09 <Masklinn> foldl' won't run any differently
16:33:35 <Masklinn> (and I'm not sure ghc delays the evaluation of the addition, surely it's not that dumb is it?)
16:33:46 <Masklinn> (from Excedrin's report, it seems that it isn't)
16:33:59 <Masklinn> wy > What do you mean by "put one item into a list"?
16:34:28 <wy> Masklinn: I mean a->[a]
16:34:51 <wy> I'm just wondering if there is a standard function ?
16:34:53 <allbery_b> ...infinite length?  repeat a
16:35:38 <newsham> wy: "return x" -> [x]   if the return type is a list.
16:35:39 <Masklinn> wy -> you just want to box it in a list? as in foo v = [v] ?
16:36:02 <wy> Masklinn: yes
16:36:28 <allbery_b> oh, you runa  long expression and want to generate a one-item list form it.  [expr], or expr >>= return
16:36:58 * allbery_b tends to break long expressions down into parts via let / where, just for comprehensibility
16:37:09 <allbery_b> (granted, some expressions aren't amenable to that)
16:37:11 <Masklinn> well then I don't think there's any built-in function, either just box it with [] or by consing it to [], or do as newsham suggested
16:37:22 <SamB> Masklinn: yes, it is that dumb!
16:37:29 <newsham> return is (sort of) built in!
16:37:58 <SamB> it comes with the Prelude, yes
16:38:17 <Masklinn> newsham > so is (:[])
16:38:23 <Masklinn> the Value Eating Monster
16:38:45 <Masklinn> eats values and puts them in its deep bellie
16:38:54 <Masklinn> *belly
16:38:56 <SamB> (:[{- I love to eat your values-}])
16:39:18 <SamB> (:[{- I also eat comments -}])
16:39:26 <Masklinn> (:[{- all your values are belong to me-}])
16:39:55 <dons> hmm. lambdabot can't get on the network
16:40:06 <dons> "Unable to connect server irc.freenode.org port 6667 [Connection refused]"
16:40:07 <dons> strange..
16:40:12 <SamB> eek!
16:40:14 <Masklinn> also the VEM looks much cooler than "return"
16:40:15 <SamB> try again?
16:40:46 <SamB> Masklinn: well, you have to admit it also looks scarier
16:40:57 <dons> Cale: around?
16:40:59 <Masklinn> scary is cool
16:41:10 <Masklinn> I mean, dons is scary
16:41:12 <dons> Cale: can you connect a lambdabot? looks like my over-ip-quota issue is blocking things
16:41:21 <Masklinn> I never thought a bot could be that intelligent
16:41:35 <wy> Masklinn: Thanks. (:[]) is good enough.
16:42:15 <Masklinn> lambdabot is scary too, except that John Connor seems to have got it before it became Skynet
16:42:28 <newsham> also VEM doesnt require type annotation
16:42:55 <Masklinn> yeah, VEM is self-sustained, just surrender your values to him and he'll live forever
16:43:08 <Masklinn> he can even eat himself
16:43:16 <chessguy> dons, if needed, i can set up a lambdabot on thursday or friday, for as long as needed
16:43:26 <chessguy> sooner, if it can run on windows
16:43:30 <dons> should only be for a few hours today
16:43:34 <dons> then my quota is restored
16:43:47 <chessguy> ok
16:43:48 <dons> actually, i might be able to run another one....
16:43:50 * dons tries
16:43:58 <vincenz> Anyone use haskell with emacs?
16:44:00 <vincenz> dons: lambdabot :/
16:44:13 <Masklinn> vincenz > I wager most people do
16:44:21 <vincenz> Masklinn: I wouldn't do that if I were you
16:44:28 <vincenz> Masklinn: Most people use vim, me included, dons included, Cale prolly too
16:44:29 <chessguy> i use notepad, at the moment :)
16:44:47 <Masklinn> dons, you're using VI?
16:44:50 <vincenz> Anyways, trying out this emacs thing for a change, got haskell-mode, but I don't have any run-haskell
16:44:54 <vincenz> Masklinn: VIM
16:44:58 <vincenz> Masklinn: only masochists use vi
16:45:03 <newsham> perhaps the reason haskell was invented is that people didnt like using emacs?
16:45:13 <sorear> vincenz: I use emacs
16:45:19 <vincenz> sorear: how do I get run-haskell?
16:45:19 <SamB> newsham: that can't be it
16:45:25 <Masklinn> bah, VI and VIM are like Emacs and XEmacs except with a slightly greater difference
16:45:26 <vincenz> sorear: haskell-mode only installs well...haskell-mode
16:45:35 <vincenz> Masklinn: sure, and windows 3.1 == windows xp
16:45:39 <Masklinn> yeah
16:45:41 <SamB> um
16:45:43 <SamB> like
16:45:43 <Masklinn> I agree
16:45:44 * vincenz rolls his eyes
16:45:45 <SamB> vi is dead!
16:45:50 <Excedrin> http://paste.lisp.org/display/32196 -- I'm not sure why foldl' is slower
16:46:23 <dibblego> I use Intellij IDEA
16:46:48 <wferi> Hi! Should  I edit _darcs/patches/pendig to correct a wrong darcs mv, or will that lead to trouble?
16:46:56 <jlouis_> ?paste
16:47:03 <vincenz> sorear: anyways trying this emacs thng, what settings/extras do I need, and how do I get M-x run-haskell?
16:47:04 <SamB> wferi: probably will lead to trouble
16:47:08 <SamB> try darcs revert instead
16:47:10 <chessguy> lisppaste2, url
16:47:11 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/Haskell and enter your paste.
16:47:18 <chessguy> jlouis_, ^^^
16:47:22 <wferi> SamB: it's not recorded yet.
16:47:27 <SamB> wferi: well yeah
16:47:31 <SamB> you said it was a wrong mv
16:47:40 <SamB> so you want to revert it *before* recording, right?
16:48:08 <wferi> yes, a wrong 'darcs mv', before recording. Wront target name, actually.
16:48:11 <vincenz> SamB: honestly, 0.03 seconds can be due to random-startup of process, caching, whatnot
16:48:13 <jlouis_> vincenz: (require 'inf-haskell)
16:48:15 <vincenz> SamB: you need a bigger difference
16:48:22 <jlouis_> chessguy: thanks, but it was a one-liner ;)
16:48:24 <vincenz> jlouis_: thank you
16:48:34 <sorear> dons: http://members.cox.net/stefanor/lambdabot-failover
16:48:35 <SamB> vincenz: um?
16:48:47 <vincenz> oy, it's hugs!
16:48:47 <SamB> vincenz: I didn't mention any 0.03 second differences?
16:48:53 <vincenz> whoops
16:48:56 <vincenz> Excedrin: !
16:49:00 <vincenz> Excedrin: read what I said to Samb
16:49:02 <SamB> I mentioned that vi was dead
16:49:07 <Excedrin> it's consistent
16:49:17 <vincenz> Excedrin: it's too small to be meaningful
16:49:21 <vincenz> see if it scales up
16:50:10 <jlouis_> vincenz: M-x customize-group RET haskell RET find the beast and change it. Or set  '(haskell-program-name "ghci") in custom-set-variables in your emacsrc
16:50:19 <newsham> people will still be using vi derivatives long after i'm dead.
16:50:24 <wferi> SamB: yes, I want to undo a wrong 'darcs mv', before recording. Just fix the target name, actually.
16:50:44 <vincenz> jlouis_: thank you
16:50:50 <SamB> wferi: so "darcs revert" will let you undo the mv and then you can do it again!
16:51:01 <Masklinn> jlouis_ > can't he just tur-on-haskell-ghci in his .emacs?
16:51:08 <vincenz> jlouis_: explain "custo-set-variables?
16:51:09 <Masklinn> turn-on-haskell-ghci
16:51:13 * wferi goes to try
16:51:24 <jlouis_> vincenz: you've never used emacs before?
16:51:28 <vincenz> nope
16:51:34 <vincenz> <- vim user
16:51:44 <vincenz> trying to give emacs a fair go
16:52:03 <SamB> newsham: I meant that that is a significant difference between the vi/vim distinction and the Emacs/XEmacs distinction
16:52:26 <vincenz> newsham: yeah, Masklinn was claiming that vi ~= vim (in the sense of more or less equal
16:52:35 <jlouis_> doing a M-x customize-group RET foo RET opens that group for customization. If you set anything there and click save for future sessions, it'll push a form (custom-set-variables ... '(show-blablah t) ...) to your .emacs
16:52:51 <jlouis_> so it will be there on the next session
16:52:54 <wferi> SamB: thanks, it worked. All too easy, revert an unrecorded change... Thanks a lot!
16:53:03 <SamB> wferi: you are welcome ;-)
16:53:05 <newsham> we're still emulating teletype terminals.
16:53:12 <newsham> stty -a!
16:53:24 <SamB> newsham: probably because we didn't like the plan9 terminals
16:53:27 <jlouis_> vi /= vim in my world. VIM can do much more funny stuff than vi
16:53:36 <SamB> I really don't think BACKSPACE = bird is a very usefull feature
16:53:36 <newsham> samb: speak for yourself.  i like acme.
16:53:40 <jlouis_> multiple undo levels for starters ;)
16:53:50 <SamB> or was that delete?
16:53:54 <jlouis_> <-- old vim fart
16:54:10 <newsham> delete == terminate process
16:54:13 <sorear> as opposed to emacs, where undo can spontaneously become redo!
16:54:23 <allbery_b> heh.  vi is actually turing equivalent, IIRC --- but making it do useful stuff is rather painful
16:54:26 <vincenz> jlouis_: ah cool, but within emacs itself... I just do it manually, is that still needed then?
16:54:30 <vincenz> jlouis_: or can I just put it as a plain command
16:54:31 <mwolak> wait, there's people here who acutally use plan9?
16:54:36 * sorear "loves" the linux PrtScr
16:54:40 <mwolak> awesome
16:54:47 <newsham> mwolak: not recently.  but yes.
16:54:52 <jlouis_> vincenz: you can just put it as a plain thing
16:54:57 <jlouis_> in .emacs
16:54:58 <SamB> newsham: acme is okay
16:55:01 <jlouis_> and restart emacs...
16:55:03 * vincenz nods
16:55:14 <allbery_b> (assuming you have the @ command and :map, and possibly assumning that :map substitutions work in @-executions --- not all versions of vi do that)
16:55:26 <mwolak> now that I've amassed a small collection of machines, I should give it another try
16:55:31 <sorear> ?seen lambdabot
16:55:42 * sorear feels stupid
16:55:45 <allbery_b> heh
16:55:51 <Cale> @bot
16:55:51 <mbot> :)
16:55:53 <chessguy> lol
16:55:54 <Masklinn> jlouis_ > wouldn't it be simpler for him to just activate the hook for turn-on-haskell-ghci in his .emacs?
16:55:54 <vincenz> Hmm
16:56:05 <vincenz> how do I tell irssi to stop showing activity for every fricking line
16:56:07 <jlouis_> Masklinn: mayhaps
16:56:12 <shapr> Hey, I just realized that bug trackers should be  a distributed system in reality.
16:56:13 <newsham> thing is, vmware is so much more convenient than a small collection of machines these days.
16:56:13 <chessguy> ?seen lambdabot
16:56:14 <mbot> I haven't seen lambdabot.
16:56:15 <vincenz> screen keeps bothering me for each line, not just stuff meant for me
16:56:17 * chessguy doesn't feel stupid :)
16:56:20 <vincenz> @join #oasis
16:56:20 <mbot> Not enough privileges
16:56:24 <vincenz> Cale: !
16:56:32 <shapr> newsham: I dunno, my desktop doesn't fit into my pocket, and my nokia 770 does =)
16:56:44 <Cale> @join #oasis
16:56:52 <sorear> @tell dons http://members.cox.net/stefanor/lambdabot-failover
16:56:52 <mbot> Consider it noted.
16:56:54 <dons> thanks Cale. the bot should be back up later today
16:56:54 <chessguy> shapr, you must have small pockets
16:56:54 <mbot> dons: You have 1 new message. '/msg mbot @messages' to read it.
16:56:55 <newsham> true.  i know nothing of sub-laptop machines.  i'm not a gadget guy
16:57:18 <shapr> For some definition of small, yes.
16:57:51 <Masklinn> shapr > mmm darcs is a source control, how about barks for a bug tracker?
16:57:57 <dons> sorear: so what does this plan mean?
16:58:11 <shapr> newsham: My 770 is about the size of two checkbooks on top of each other. It has wifi, bluetooth, and runs an ARM flavor of debian linux. It is a pen-tester's dream.
16:58:11 <newsham> ?elite all your code belong to us
16:58:11 <mbot> 4|| YouR (oDE 831On9 7o uS
16:58:15 <Cale> http://cale.yi.org/index.php/The_Monad_Laws
16:58:16 <mbot> Title: The Monad Laws - CaleWiki
16:58:28 <Cale> I wrote that as a response to a reddit comment
16:58:30 <sorear> it's a proposal for a way to add redundancy to the lambdabot system
16:58:38 <shapr> Metasploit runs on the 770, for example..
16:58:50 <newsham> shapr: a pen testers dream == my client sending me a vmware with his whole environment.
16:59:00 <newsham> (including src)
16:59:13 <chessguy> Cale, oooh, is that a new article?
16:59:16 <shapr> Ok, if you do it for a living, yeah. I see what you mean.
16:59:27 <shapr> I was thinking more about independent work..
16:59:35 <Cale> almost. I should really clean it up and write a proper introduction
16:59:49 <Cale> Because it's really just a very long reply to a comment :)
17:01:29 <vincenz> sorear: there's an issue with that
17:01:34 <vincenz> sorear: all the stuff that requires state is lost
17:01:37 <vincenz> sorear: @quote, etc..
17:02:10 <vincenz> sorear: additionally, what you propose seems to be overkill, just don't respond if a higher priority bot is in channel
17:02:17 <vincenz> sorear: time-out is not too big
17:02:32 <vincenz> the whole thing with deactivate-time is overkill
17:03:16 <newsham> ?quote lambdabot
17:03:16 <mbot>  lambdabot hasn't said anything memorable
17:03:20 <newsham> ?quote dons
17:03:20 <mbot>  dons has quit ("improve @check")
17:03:38 <sorear> Yes the proposal could be greatly simplified if hung bots didn't exist...
17:03:46 <Excedrin> vincenz: yea, it scales, it's consistently 1%
17:04:00 <sorear> ... or if they could be kicked; are there any non-dons ops?
17:04:05 <vincenz> sorear: mea
17:04:06 <vincenz> me
17:04:08 <vincenz> shapr
17:04:10 <vincenz> cale
17:04:12 <shapr> eh?
17:04:12 <vincenz> and a few others
17:04:18 <vincenz> shapr: chan-ops
17:04:26 <shapr> oh
17:04:39 <shapr> Wouldn't it make more sense to have distributed state and multiple pipes to such?
17:04:48 <chessguy> Cale, nice article
17:04:53 <vincenz> that wouldn't work with crashed bots tho
17:04:55 <shapr> Then you could have a jabber bot and irc bot separately.
17:04:56 <vincenz> and that's hard to implement
17:05:10 <sorear> <madidea> store the state on the WIKI! </madidea>
17:06:38 <jlouis_> <madderidea> store the state in an XML document on the WIKI! </madderidea>
17:07:23 <newsham> ?remember dons Don "If it ain't pure, it ain't functional" Stewart
17:07:24 <mbot> Not enough privileges
17:07:30 <robreim> Does anyone have experience compiling hs-plugins for windows?
17:07:56 <newsham> robreim: it has "just worked" for me in the past (with ghc less than 6.6)
17:08:51 <robreim> oh ok. It may be my inexperience with mingw, but when I do "sh configure" from cmd, the gcc tests fail because gcc always responds with "no input files" no matter what its arguments are.
17:09:50 <newsham> runhaskell Setup.hs configure; runhaskell Setup.hs build  ?
17:09:56 <newsham> I didnt use "sh"
17:10:04 <newsham> (at least not explicitely)
17:10:11 <sorear> newsham: s/;/&&/ ?
17:10:25 <allbery_b> typically "Setup.hs configure" does some setup foo and then uns configure itself
17:10:33 <robreim> Hmm. The hs-plugins I have seems to use make rather than cabal... Is that the darcs version?
17:10:35 <newsham> sorear: if you prefer.
17:10:37 <chessguy> Cale, you should take on problem 97 at http://haskell.org/haskellwiki/99_Haskell_exercises
17:10:38 <mbot> Title: 99 Haskell exercises - HaskellWiki, http://tinyurl.com/yzzdkz
17:10:56 <newsham> robreim: the version i have here has a Setup.lhs in its dir.
17:11:04 <robreim> newsham: ok, thanks.
17:11:07 <newsham> there's configure and all that there too..
17:12:01 <Cale> chessguy: There's already a whole wiki page of solutions to Sudoku.
17:12:04 <robreim> Right. I'll get a darcs version instead.
17:12:26 <newsham> you're not using ghc6.6 right?
17:12:31 <chessguy> Cale, is the code explained?
17:12:36 <robreim> No, 6.4.2
17:12:40 <newsham> good.
17:12:51 <robreim> Still not working with 6.6 I take it?
17:12:52 <Cale> Depends on what you mean by explained :)
17:13:00 <newsham> last i heard.
17:13:29 <chessguy> Cale, we're trying to find canonical, idiomatic haskell solutions to these problems and explain them so that non-haskellers can understand them
17:13:58 <newsham> what is problem 97?  i just see template.
17:14:41 <newsham> i really like this sudoku solver: http://web.math.unifi.it/users/maggesi/haskell_sudoku_solver.html
17:14:42 <mbot> http://tinyurl.com/y6xepa
17:14:45 <Cale> Oh, that's significantly harder in that case. I was trying for having Haskell programmers who don't know much about monad transformers to be able to read my program, and afterward they should know a little more about monad transformers :)
17:15:05 * vincenz hould have put his sudoku solver online
17:15:08 <vincenz> I wrote it during a summer
17:15:12 <vincenz> and only during the ensuing winter
17:15:16 <vincenz> had it become a hit to put solvers online
17:15:18 <vincenz> in ruby nonetheless
17:15:59 <vincenz> ah well
17:16:16 <newsham> this one is short and sweet.  not the most efficient, but very readable.
17:16:18 <chessguy> newsham, to see the problem description, you have to go to problem 97 at http://www.ic.unicamp.br/~meidanis/courses/mc336/2006s2/funcional/L-99_Ninety-Nine_Lisp_Problems.html
17:16:19 <mbot> Title: L-99: Ninety-Nine Lisp Problems, http://tinyurl.com/tt9e7
17:17:02 <chessguy> newsham, is that your code?
17:17:19 <newsham> no.  its attributed on the webpage.  I did code a python one based on that haskell code though
17:17:26 <chessguy> oh, i see
17:17:48 <chessguy> maybe you could comment up that code using the given template?
17:18:01 <robreim> ?vixen
17:18:02 <mbot> Beer, it's so much more than just a breakfast drink!
17:18:09 <robreim> lambdabot's got a new name, eh?
17:18:33 <newsham> (also the input and output arent quite up to spec for the lisp problem specification)
17:19:00 <newsham> ?elite i'm not lambdabot
17:19:01 <mbot> i'/\/\ not |a/\/\BD4BoT
17:19:16 <chessguy> newsham, i bet it could be refactored pretty easily. <hint, hint> <nudge, nudge>
17:19:36 <newsham> chessguy: i'm sure it could <reflected wink, nudge>
17:19:43 <newsham> but i've got other things to do :\
17:19:49 <chessguy> you've already ported the code :)
17:20:07 <newsham> so i have little left to gain ;-)
17:20:14 <chessguy> we all have other things to do
17:20:57 <newsham> that is the curse.
17:21:06 * chessguy bookmarks the page for later. sigh
17:21:21 <Excedrin> it's weird how changing the order of arguments makes things faster
17:22:15 <chessguy> @type getContents
17:22:17 <mbot> IO String
17:24:41 <shapr> It's fun to have a conversation with the typechecker. Especially when I realize my conversation partner is in fact my own understanding.
17:25:02 <chessguy> shapr, wow, that's deep :)
17:25:03 <dons> chessguy: so looks like we've got way more solns than the lisp guys now?
17:25:14 <dylan> heh
17:25:22 <dylan> the author of missingh is the author of offlineimap
17:25:27 <chessguy> dons, we do indeed
17:25:30 <dylan> two things I use.
17:25:41 <shapr> sjanssen: btw, was the wiki code understandable? I wonder if it's getting too concise...
17:25:53 <Excedrin> dons: and way fewer than the Prolog guys... o wait
17:25:53 <chessguy> still a long ways to go though
17:25:56 <dons> "This page has been accessed 1,027 times."
17:26:03 <shapr> dylan: He's CosmicRay here on #haskell, and he does a lot more cool stuff.
17:26:09 <chessguy> hmm, in less than 24 hours
17:26:21 <dons> that's ok.
17:26:22 <vincenz> chessguy: for?
17:26:24 <vincenz> shapr: do what?
17:26:30 <dons> it didn't go to the reddit front page
17:26:39 <dons> so that's pretty much all mailing list and programming.reddit traffic
17:26:52 <chessguy> vincenz, http://haskell.org/haskellwiki/99_Haskell_exercises
17:26:53 <mbot> Title: 99 Haskell exercises - HaskellWiki, http://tinyurl.com/yzzdkz
17:26:59 <shapr> I wish I could contact someone at reddit and get my user account fixed!
17:27:11 <shapr> I had one, but it's broken, and I can't find any email address to ask for fixing.
17:27:22 <chessguy> dons, just about a user every minute
17:27:24 <vincenz> chessguy: ah
17:30:26 <chessguy> yeesh, how in the world am i going to comprehend this code?
17:30:43 <newsham> chess: sudoku?
17:30:48 <chessguy> ya
17:31:08 <Pseudonym> Sudoku is how I get coded messages from my communist masters.
17:31:08 <newsham> the board is represented by a function that maps coordinates to a list of possible values.
17:31:23 <newsham> ie. if there's a 3 at (0,0) its  \(x,y) -> [3]
17:31:54 <chessguy> if type T?
17:31:57 <chessguy> *of
17:32:04 <newsham> the mark function takes an existing board (a function) and returns a new board (function) that has one coordinate narrowed down and all of the conflicting values in other rows/columns/squares filtered out
17:32:09 <newsham> yah.  T represents a board.
17:32:22 <newsham> so the empty board is   \(x,y) -> [1..9]
17:32:45 <vincenz> newsham: where?
17:32:52 <mq_mattr> I am afraid I am having trouble discovering what lambdabot can do
17:32:54 <newsham> and   mark ((1,1),3) empty     is a board with 1,1 holding a 3.
17:33:02 <newsham> http://web.math.unifi.it/users/maggesi/haskell_sudoku_solver.html
17:33:03 <mbot> http://tinyurl.com/y6xepa
17:33:05 <mq_mattr> I see the command list, but I can't work out what each command does
17:33:27 <newsham> the "input" function builds up the problem from the empty board and the input data.
17:33:37 <newsham> the "solve" function searches for a solution by brute force.
17:33:52 <liquidengineer> Does haskell support function overloading?
17:33:54 <newsham> (by trying each of the possible values that are left for each cell)
17:33:57 <vincenz> Binkley: !
17:34:07 <Binkley> (!!)
17:34:16 <chessguy> hi Binkley
17:34:28 <Binkley> hi all
17:34:42 <newsham> empty = const [1..9]
17:34:59 <chessguy> hmm, you don't have that in there
17:35:11 <newsham> input s = foldr mark (const [1..9]) $
17:35:11 <newsham>   [(p,n) | (p,n) <- zip idx $ map read $ lines s >>= words, n>0]
17:35:14 <allbery_b> liquidengineer: sort of, via type classes
17:35:27 <newsham> the "const [1..9]"  repreesnts the empty board.
17:35:34 <Cale> liquidengineer: in a sense -- you can't just randomly define functions at different types, but there are these things called typeclasses which allow you to define a set of operations differently across types in the class
17:35:39 <newsham> the "fold mark empty ..."  represents the populated board (from user input)
17:35:47 <liquidengineer> aw
17:35:50 <liquidengineer> crud
17:35:55 <liquidengineer> that kinda blows
17:35:58 <Cale> why?
17:36:05 <Cale> It's actually rather elegant
17:36:16 <geckosen1tor> what is the recommended guide for learning haskell?
17:36:21 <liquidengineer> I've got two types that are identical
17:36:35 <SamB> liquidengineer: how so?
17:36:36 <liquidengineer> e.g.: they're both lists of a certain kind of element
17:36:40 <allbery_b> (then why are they two types?)
17:36:41 <newsham> liquid: you can make a new type based off of an existing type
17:36:45 <Binkley> gecksen1tor: we haven't written it yet ;-)
17:36:45 <Cale> geckosen1tor: depends on your background, but YAHT is a good start
17:36:49 <Cale> @where yaht
17:36:49 <mbot> http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf
17:36:52 <SamB> liquidengineer: show us!
17:37:04 <Cale> liquidengineer: [a]
17:37:09 <Cale> @type length
17:37:10 <mbot> forall a. [a] -> Int
17:37:13 <geckosen1tor> Cale: I have some background in c and scheme
17:37:16 <liquidengineer> allbery_b: because type A is for preprocessed elements
17:37:16 <Cale> > length "Hello"
17:37:17 <mbot>  5
17:37:20 <liquidengineer> one is for postprocessed
17:37:24 <Cale> > length [1,5,32,7,2]
17:37:25 <mbot>  5
17:37:34 <liquidengineer> I don't want to accidentially feed a function meant for processed lists unprocessed lists
17:37:38 <liquidengineer> so I'm using types as guards
17:37:45 <Cale> See how length works on things of different type there?
17:38:06 <newsham> data UnprocList = UnprocList [Int]
17:38:23 <Cale> Now, let's look at sort, in order to sort a list, the elements have to be ordered
17:38:27 <Cale> @type sort
17:38:28 <mbot> forall a. (Ord a) => [a] -> [a]
17:38:33 <liquidengineer> Hmm
17:38:34 <liquidengineer> okay
17:38:54 <Cale> Ord is a class which has as members things like (>) and compare
17:39:05 <allbery_b> so if you want some operations in common between thwe two, use typeclasses
17:39:13 <jlouis_> liquidengineer: What (function) overloading achieves in most other languages are not really that important in Haskell
17:40:00 <dons> :t Left
17:40:05 <dons> ?type Left
17:40:07 <mbot> forall b a. a -> Either a b
17:40:14 <liquidengineer> I think I got it now
17:40:16 <liquidengineer> thanks guys!
17:41:17 <jlouis_> Hmmm the binary tree parts of those 99 things seems easy. As do the 60's
17:41:23 <jlouis_> which are multiway trees
17:41:26 <Cale> geckosen1tor: I'd say go with YAHT, since it's fairly decent and should get you at least off the ground enough to start putting things together for yourself, and reading other tutorials.
17:42:05 <geckosen1tor> ok
17:42:09 <dibblego> given some function f, invoking a type constructor C as: C (fst $ f args) (snd $ f args) will call f twice where it is computationally expensive - is it safe (or good practice) to memoize f using 'where': C (fst f') (snd f') where f' = f args ?
17:42:20 <geckosen1tor> Cale: i'm reading it now, thanks
17:42:55 <Cale> Depending on just how familiar you are with scheme, you might get something out of the Gentle Introduction to Haskell, but I'd say go with that if you find YAHT boring. There are lots of other tutorials at http://haskell.org/haskellwiki/Books_and_tutorials
17:42:56 <mbot> Title: Books and tutorials - HaskellWiki, http://tinyurl.com/vqzky
17:43:09 <jlouis_> dibblego: in haskell yes. Because the language is pure you know that if f args = y then it is always so.
17:43:13 <allbery_b> if f is pure it should always be safe, and it is preferred
17:43:29 <allbery_b> because it's a nice hint to the compiler to compute it once
17:43:33 <dibblego> I know it is safe in that sense; I mean safe as in it will always memoize
17:43:40 <Cale> dibblego: that's a data constructor, not a type constructor
17:43:44 <dibblego> if not, what is a better practice?
17:43:53 <dibblego> Cale, right my mistake
17:44:01 <Cale> dibblego: it will always memoise so long as f' has a monomorphic type
17:44:08 <robreim> drat. Cabal under windows is giving me the same problems as running configure directly. Is anyone familiar with the problem where gcc responds with "no input files" regardless of its arguments?
17:44:31 <SamB> dibblego: that isn't memoization, thats CSE...
17:44:34 <jlouis_> dibblego: I'd write the 'where' variant.
17:44:39 <Cale> Yeah, it's really sharing
17:44:43 <dibblego> which if f' doesn't have a monomorphic type?
17:44:53 <dibblego> ?wtf CSE
17:44:53 <mbot> Maybe you meant: bf ft wn
17:45:01 <jlouis_> common subexpression elimination
17:45:01 <SamB> @all-dict CSE
17:45:02 <mbot> *** "CSE" wn "WordNet (r) 2.0"
17:45:02 <mbot> CSE
17:45:02 <mbot>    n : Canadian agency that gathers communications intelligence and
17:45:02 <mbot>      assist law enforcement and security agencies [syn: {Communications
17:45:03 <allbery_b> "common sub-expression elimination"
17:45:03 <mbot>      Security Establishment}]
17:45:05 <mbot> [5 @more lines]
17:45:06 <allbery_b> compiler term
17:45:07 <Cale> hahaha
17:45:12 <SamB> @vera CSE
17:45:15 <mbot> *** "cse" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
17:45:17 <mbot> CSE
17:45:19 <mbot>    Client-Server Environment
17:45:21 <mbot>  
17:45:22 <SamB> nope
17:45:24 <shapr> Hey, I just switched my WikiState type from :: M.Map String String to  :: M.Map PageName WikiPage with newtype PageName = PName String & newtype WikiPage = WPage String, and my question is whether there's some easy way shim all the former String accepting functions into the right types.
17:45:25 <Binkley> who knew that identifying common subexpressions helped law enforcement?
17:45:26 <jlouis_> LOL
17:45:30 <SamB> @hacker CSE
17:45:33 <mbot> Unknown command, try @list
17:45:37 <Binkley> you wrote the same expression twice, call the code police
17:45:39 <SamB> @jargon CSE
17:45:40 <mbot> No match for "CSE".
17:45:43 <Cale> @foldoc CSE
17:45:44 <mbot> No match for "CSE".
17:45:52 <Cale> @foldoc common subexpression elimination
17:45:55 <mbot> No match for "common".
17:45:57 <shapr> I just wrote fromPageName = (\ (PName n) -> n) ; fromPageNames = map fromPageName ;  fromWikiPage = (\ (WPage p) -> p) ; fromWikiPages = map fromWikiPage but that's not as useful as I was hoping.
17:45:57 <mbot> No match for "subexpression".
17:45:58 <Cale> bah
17:45:59 <mbot> No match for "elimination".
17:46:04 <shapr> Is there a better approach?
17:46:04 <SamB> @wikipedia CSE
17:46:07 <mbot> No Result Found.
17:46:19 <SamB> @google CSE
17:46:19 <chessguy> @go wikipedia common subexpression
17:46:20 <mbot> http://www.cseindia.org/
17:46:20 <mbot> Title: Centre for Science and Environment (CSE) Home Page
17:46:20 <mbot> http://en.wikipedia.org/wiki/Common_subexpression_elimination
17:46:29 <chessguy> yay! i win
17:46:36 <SamB> hehe
17:46:36 <jmob> http://acronymfinder.com/af-query.asp?acronym=cse&string=exact&s=r&page=1
17:46:43 <shapr> hiya jmob, how's code?
17:46:45 <SamB> why @go?
17:46:46 <jmob> not even until the second page
17:46:53 <shapr> Long time no see Mr Mobarak
17:46:54 <SamB> is that for Excite! or something?
17:46:54 <chessguy> SamB, @go = @google
17:46:56 <Cale> shapr: that seems reasonable
17:47:12 <liquidengineer> :r
17:47:14 <liquidengineer> whoops
17:47:15 <liquidengineer> sorry
17:47:19 <jmob> shapr: when you say my real name in irc, it makes be feel naked
17:47:22 <shapr> Cale: On the downside, it's cluttering up all my sources. There must be an easier way to refactor this.
17:47:38 <shapr> jmob: sorry, I'll leave you with your mental clothing in the future =)
17:47:38 <robreim> CSE is similar to graph reduction, yeah? I was under the impression Haskell performed graph reduction. Am I wrong?
17:47:44 <SamB> @help go
17:47:44 <mbot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:47:48 <SamB> @help goo
17:47:48 <mbot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:47:50 <SamB> @help goog
17:47:50 <mbot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:47:51 <newsham> shapr: like   "withStrings act" which extracts the string from the State, calls act with the state, and takes the result and puts it back into the state?
17:47:51 <robreim> s/Haskell/Haskell compilers/
17:47:52 <SamB> @help googl
17:47:52 <mbot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:47:55 <SamB> @help google
17:47:55 <mbot> google <expr>. Search google and show url of first hit
17:47:59 * vincenz undress Shae
17:48:00 <jlouis_> robreim: not to my knowledge
17:48:04 * SamB knew that last one, of course
17:48:05 <Cale> shapr: perhaps withPageName :: (String -> String) -> PageName -> PageName
17:48:12 * SamB wrote @google, after all
17:48:15 <newsham> shapr: should be a special case of the "withInner" in that thread you read.
17:48:17 <shapr> newsham, Cale: Thanks, I'll try that.
17:48:24 <jmob> shapr: I'm wondering if there's some form of the object capabilities model implemented in Haskell.
17:48:26 <dibblego> thanks
17:48:35 <chessguy> lol, and you didn't know you could shorten it to @go ?
17:48:38 <Cale> oh, I didn't even see that Newsham had suggested it :)
17:48:40 <shapr> newsham: Yeah, funny thing is that I was doing this refactoring in order to try out musasabi's TH accessors for the state type elsewhere.
17:49:57 <shapr> vincenz: The only thing interesting about a naked me is that everyone would realize that my legs are insanely thick from too much unicycling.
17:50:25 <vincenz> shapr: I fail to see how clothing can remove thickness
17:50:32 <Binkley> wait, when did this become #hottub?
17:50:37 <jlouis_> vincenz: magic!
17:50:37 <allbery_b> it can hide it, though\
17:50:47 * vincenz spoons with Binkley 
17:50:55 * Binkley steals vincenz's spoon
17:50:57 <newsham> shapr: the ones that auto-generate the "withXXX" functions?
17:51:01 * vincenz sniffs
17:51:04 * chessguy hands Binkley a fork
17:51:06 <allbery_b> ?remember Binkley wait, when did this become #hottub?
17:51:06 <mbot> Not enough privileges
17:51:08 * Binkley takes it
17:51:09 <allbery_b> feh
17:51:20 <Binkley> wait, where'd lambdabot go?
17:51:42 <chessguy> lambdabot's on vacation, so we got a temp worker
17:51:47 <TomMD> ?where paste
17:51:47 <mbot> http://paste.lisp.org/new/haskell
17:51:52 <shapr> vincenz: You'd be surprised. I've spent my life learning costuming tricks so people don't think I'm fat. In reality, I inherited my father's football player physique. For example, my thighs are 27cm in circumference.
17:51:54 <jlouis_> Binkley: she went out to have fun with vincenz
17:51:55 <chessguy> and i hate the fact that i can't tab-complete 'lambdabot' when it's not here
17:52:15 <vincenz> jlouis_: so how come I'm still here?
17:52:18 <shapr> newsham: Yeah, those are the ones I'm playing with.
17:52:18 <Binkley> if it's a temp then shouldn't it be t-mbot?
17:52:21 <Binkley> ;-)
17:52:23 <vincenz> chessguy: she
17:52:29 <jlouis_> vincenz: shes sitting next to you, but o' course
17:52:46 <allbery_b> only if t-mobile uses haskell?
17:53:10 <chessguy> shapr, i think i'm more disturbed by the fact that you know the exact circumference of your thighs than how big they are
17:53:20 <newsham> i've used those for record members.  havent used them for Map's though.
17:53:25 <shapr> chessguy: I was buying leg armor for unicycling recently =)
17:53:39 <newsham> (the example code I put up uses them)
17:53:40 <shapr> I had to buy XL :-/
17:53:45 <chessguy> allbery_b, only for their ericsson phones
17:53:56 <jmob> shapr: do you know how to juggle?
17:53:57 <Binkley> shapr: somehow, having to buy XL leg armor seems to be more unique among the possible problems a person could have
17:54:03 <shapr> jmob: A little bit.
17:54:14 * chessguy agrees with Binkley
17:54:25 <lisppaste2> TomMD pasted "Polymorphic Problems" at http://paste.lisp.org/display/32202
17:54:43 <allbery_b> ...hrm, now I wonder if ghci would run on my W600i :)
17:54:58 <chessguy> ok, time to go to a design document critique session
17:54:59 <allbery_b> (too little memory, actually, and not expandable)
17:55:03 <TomMD> So, the problem (pasted) is that I don't know how to access MVars in a polymorphic friendly way, anyone willing to take a stab at teaching me?
17:55:07 * chessguy will be back later
17:55:13 <geckosen1tor> do you guys run ghci in emacs?
17:55:22 <jmob> geckosen1tor: yes
17:55:24 <Binkley> geckosen1tor: sometimes
17:55:27 <sorear> yes
17:55:29 <newsham> <- never
17:55:33 <SamB> hugs runs faster though
17:55:36 <shapr> Binkley: Sadly, that problem extends to being unable to buy off the shelf button down shirts as well. My neck is about 18.5 inches.
17:55:50 <shapr> vincenz: Sorry, that was 27 inches for my thighs.
17:55:53 <sorear> C-u M-x run-haskell
17:56:05 <SamB> aww, no COTS shirts for shapr :-(
17:56:34 <Binkley> shapr: so how do you get your shirts? ebay?
17:57:37 <shapr> Binkley: I end up with two flavors of shirts, those that I cannot close for a tie, and those that I can tuck in to my ankles. Anything large enough for my neck and shoulders is way too long in the arms and torso.
17:57:47 <Binkley> shapr: how often do you have to wear a tie? :-)
17:57:50 <jmob> http://www.skyhunter.com/marcs/emily.pdf http://www.eros-os.org/pipermail/e-lang/2006-February/011086.html
17:58:08 <shapr> Not very often these days.
17:58:54 * robreim now realises why unicycling clowns often wear parachute pants
17:59:22 <shapr> jmob: There is a very simple solution for that - http://research.microsoft.com/os/singularity/ http://programatica.cs.pdx.edu/House/ http://www.cse.ogi.edu/~hallgren/ICFP2005/
17:59:48 <robreim> Cabal under windows is giving me the same problems as running configure directly. Is anyone familiar with the problem where gcc responds with "no input files" regardless of its arguments?
18:00:28 <shapr> jmob: In essence, build the safety into the typesystem and you won't need hardware process safety.
18:00:35 <kpreid> shapr, jmob: am I missing some context?
18:01:02 <shapr> kpreid: jmob wants all the spiffy of E with all the speed of C
18:01:08 <TomMD> Has anyone worked with Polymorphic MVars?  like in: http://paste.lisp.org/display/32202
18:01:10 <kpreid> ah.
18:01:19 <kpreid> type safety in the Haskell sense is not adequate
18:01:36 <shapr> What about type safety in the Epigram sense?
18:01:57 <SamB> ... wouldn't that require a proof of safety to be written by the programmer?
18:02:00 <kpreid> don't know it
18:02:03 <kpreid> but I'll comment on Haskell:
18:02:05 * vincenz doesn't see the novelty of Emily over Ocaml
18:02:10 <kpreid> you can run pure code safely, yes (ignoring unsafePerformIO)
18:02:10 <kpreid> but for more power you need to be able to subdivide IO
18:02:18 <kpreid> this is 'trivial' but I haven't done it yet:
18:02:27 <kpreid> you need to make, for example, readFile not a global variable
18:02:32 <shapr> kpreid: http://www.e-pig.org/ - Epigram
18:02:37 <mbot> Title: Epigram
18:02:49 <geckosen1tor> is it easy to write functions in haskell callable from c?
18:02:59 <Lemmih> geckosen1tor: Yes.
18:03:00 <kpreid> so you can have an IO action that was constructed with access to only some things (say, newIORef, for example)
18:03:11 <kpreid> then you know it can make IORefs, but not do file IO
18:03:38 <kpreid> instead of main :: IO (), you have something somewhat like:  main :: AllPrivileges -> IO ()
18:03:53 <shapr> This sounds like Oleg's ZipperFS system.
18:03:56 <kpreid> where AllPrivileges is a giant record containing newIORef, readFile, etc.
18:04:23 <kpreid> that's the design I have sketched in my head for a cap-Haskell, but I haven't done anything about it yet
18:04:24 <Lemmih> TomMD: It can be done with existentials. Just be careful, you can easily hit a segfault.
18:05:03 <jlouis_> mmmm SIGSEGV
18:05:14 <sorear> I've implemented restricted IO
18:05:15 <shapr> newsham: Ya know, the proliferation of withFoo accessors suggests to me that there's an easier way.
18:05:36 <sorear> (I actually made it into HWN-before-last)
18:05:44 <TomMD> Lemmih: existentials?  Is this more non-pure code that I must learn to get my first 'real' haskell program running?
18:05:49 <Lemmih> TomMD: data SomeData = forall a. Sd { ... }, should be safe.
18:05:56 <shapr> kpreid: Have you seen Oleg's ZipperFS where IO is never directly allowed, but instead left for a 'supervisor' thread to handle if it decides to do so?
18:06:13 <shapr> sorear: I only got quotes in HWN :-(
18:06:21 <kpreid> no, I haven't gotten around to that yet
18:06:33 <Lemmih> TomMD: You really don't wanna use global mutable state in real programs (:
18:06:35 <kpreid> but "allow this operation" is Not The Right Thing
18:06:36 <SamB> shapr: are those ConThreads (that is, threads built on nothing?)
18:06:36 <jmob> shapr: does singularity have some relationship with haskell?
18:07:00 <kpreid> it is far better to have a system in which undesired operations *cannot be expressed*
18:07:02 <TomMD> Lemmih: How else could I get data from an interrupt that has no inputs and an IO () return?
18:07:15 <kpreid> you can't read /etc/passwd if all you have is (readFile . ("/safe/location/" ++))
18:07:20 <shapr> jmob: Only in that type checking is used to ensure that the generated code cannot do anything that would trigger hardware protection.
18:07:34 <kpreid> (ignoring ".." for simplicity)
18:07:44 <SamB> kpreid: I was going to say...
18:07:51 <Lemmih> TomMD: do var <- newEmptyMVar; registerInterrupt (someFunc var); ..., perhaps.
18:08:01 <kpreid> SamB: yeah, to tame unix you have to explicitly prohibit that
18:08:09 <jmob> shapr: ...type checked execution of cpu instructions?
18:08:31 <TomMD> Lemmih: But I need data back.  For example... oh I'll post it.
18:08:31 <LoganCapaldo_> @hoogle m1 a -> m2 b
18:08:31 <mbot> A Hoogle error occured.
18:08:55 <shapr> jmob: I don't know exactly how Singularity does it.
18:08:59 <LoganCapaldo_> I meant @hoogle m1 a -> m2 a
18:09:25 <cjeris> grrr... reading poorly indented sml code is a pain in the butt.
18:09:29 <kpreid> LoganCapaldo_: no general such function can exist
18:09:42 <kpreid> @type listToMaybe
18:09:44 <mbot> forall a. [a] -> Maybe a
18:09:45 <kpreid> LoganCapaldo_: but specific ones do:
18:09:46 <kpreid> @type maybeToList
18:09:48 <mbot> forall a. Maybe a -> [a]
18:09:49 <LoganCapaldo_> kpreid, I'm kinda looking for the type class
18:10:06 <kpreid> @type msum
18:10:08 <mbot> forall a (m :: * -> *). (MonadPlus m) => [m a] -> m a
18:10:13 <kpreid> er
18:10:13 <LoganCapaldo_> that maybeToList would be an instance of
18:10:38 <SamB> hmm. I don't think it would be an instance of one.
18:10:43 <kpreid> @type msum . map return
18:10:44 <mbot> forall a (m :: * -> *). (MonadPlus m) => [a] -> m a
18:10:50 <SamB> maybe listToMonad would be an instance of one...
18:11:27 <lisppaste2> TomMD annotated #32202 with "Getting data from an interrupt" at http://paste.lisp.org/display/32202#1
18:11:35 <LoganCapaldo_> "The class of functions converting a container of as to a different kind of container of as"
18:12:08 <LoganCapaldo_> listToMaybe, listToTree, setToList, etc.
18:12:33 <SamB> set ain't no monad!
18:12:42 <SamB> unfortunate, that.
18:12:50 <LoganCapaldo_> I don't mean monads :)
18:12:59 <TomMD> Lemmih: Sorry, I didn't think clearly, it is the global part you are objecting to... now my head is on straight, thanks.
18:13:02 <LoganCapaldo_> Just containers in the old fashioned sense
18:13:13 <TomMD> But I still have an issue with getting the MVar in the first place.  Darn MVars.
18:13:34 <SamB> that reminds me of the "map" function from my old abortive attempt at some collections classes ;-)
18:13:41 <SamB> seriously!
18:14:37 <LoganCapaldo_> I'm not doing anything ill advised like trying to write a generic "map" :) Just wondering what the name for that class of functions might be, if it has a name
18:14:57 <Saulzar> TomMD: He's suggesting you can use currying eg. pass it as an argument, ie. handleAlarm is of type MVar -> IO ()
18:15:29 <Saulzar> TomMD: Since if you have a function of MVar -> IO () and pass it an MVar you now have a function of just IO ()
18:15:46 <Lemmih> TomMD: I think you can fix the type error with: data SomeData = forall s. SomeClass a => Sd { ... }
18:16:23 <newsham> "IO ()" is a value (holding an IO action), not really a "function" per-se, no?
18:16:48 <jlouis_> newsham: it can't be, since there is no -> in its type
18:17:03 <Saulzar> Yes well... you know what I mean :)
18:17:52 <SamB> LoganCapaldo_: well, what I mean was the way I had to write map ... map id looked a lot like that ;-)
18:18:00 <LoganCapaldo_> ah
18:18:10 <Lemmih> newsham: Isn't values are just nullary functions?
18:18:40 <SamB> I had no way to express that two different types were the same sort of collection type ;-)
18:18:45 <lisppaste2> TomMD annotated #32202 with "Ambiguity Prime" at http://paste.lisp.org/display/32202#2
18:19:00 <jlouis_> Lemmih: its definitely possible to interpret them as that
18:19:01 <TomMD> Saulzar: Thanks.  This is my latest - I get the same complaints.
18:19:05 <newsham> lemmin: i suppose.  but i'd prefer "value" to "function".
18:19:29 <newsham> (and in the case of (m a) "action")
18:20:20 <TomMD> I've tried giving the 'takeMVar' line a type signature and little things like that, but it seems to piss of GHC even more.
18:20:22 <lisppaste2> Lemmih annotated #32202 with "fixed" at http://paste.lisp.org/display/32202#3
18:20:25 <Saulzar> TomMD: If you're using currying on your function you can eliminate the global altogether
18:20:30 <jlouis_> in SML you can pass <unit> to a function f() when you want to invoke f with no arguments
18:20:55 <newsham> SML has side effects I take it
18:20:55 <jlouis_> so the function has a single argument, since it has type f : unit -> foo
18:21:02 <jlouis_> indeed it has
18:21:04 <TomMD> Saulzar: yes, I will work on that, this is an example snippet to a much larger file - I'll modify and oo and ahh at the product.
18:21:05 <Lemmih> TomMD: You slightly misunderstood the 'forall' part.
18:21:57 <newsham> w/o side effects is there a observable differnce between "invoking 3 and getting its value" and "the value 3" ?
18:22:11 <TomMD> Lemmih: You rock.  I'll have to learn more about the type system, I'm feeling a bit like a dunce.
18:22:30 <jlouis_> newsham: no.
18:23:49 <TomMD> ?where typesystem
18:23:50 <mbot> I know nothing about typesystem.
18:23:58 <TomMD> lol, I like hearing a bot say that.
18:25:36 * Lemmih wonders why conjure is leaking space.
18:25:54 <SamB> Lemmih: why don't you profile it?
18:25:58 <SamB> is easy, you can do!
18:26:26 <jlouis_> This is GHC. Allocation profiling is easy ;)
18:26:41 <SamB> I might consider helping you over break, if you don't have it done by next week ;-)
18:27:10 * Lemmih has been looking at heap profiles for the last couple of hours.
18:28:15 <jlouis_> You tickling a Bytestring bug mayhaps? Or some other stuff in hell-land?
18:28:32 <SamB> Lemmih: how about retainer profiles?
18:28:49 <SamB> have you been profiling by where allocated?
18:29:44 <Lemmih> SamB: That's what I meant, +RTS -hr.
18:30:31 * jlouis_ goes to bed
18:30:40 <Lemmih> 'Night, jlouis_.
18:32:29 <zeeeee> is there a standard operator shorthand for composing monadic functions? i.e. instead of writing "(>>= g) . f" i can write "f >.> g" or "g <.< f" or some such
18:33:22 <SamB> would be nice if you could get it to do it by retainers *and* by CCSs
18:34:08 <shapr> zeeeee: What are the types? Maybe you want Control.Monad.liftM or Control.Monad.ap ?
18:34:16 <SamB> Lemmih: maybe you can use -hx for that?
18:34:41 <SamB> write a little something in gtk2hs maybe?
18:35:05 <SamB> oh.
18:35:11 <SamB> try -xt
18:35:18 <SamB> Lemmih: you hear that?
18:35:40 <zeeeee> shapr: f and g are already monadic functions (eg getChar and putChar)
18:35:41 <SamB> @tell Lemmih to try +RTS -xt
18:35:41 <mbot> Consider it noted.
18:35:41 <dons> zeeeee: is that kleisli composition?
18:35:57 * zeeeee looks up kleisli composition :)
18:35:58 <Lemmih> SamB: I'll try.
18:35:59 <mbot> Lemmih: You have 1 new message. '/msg mbot @messages' to read it.
18:36:18 <SamB> Lemmih: maybe you are allocating too many threads
18:36:32 <SamB> threads are really comparatively big ;-)
18:36:47 <Pseudonym> So... who's up for renaming Haskell?
18:37:00 <SamB> we could call it Skahell!
18:37:17 <sorear> ?pl
18:37:17 <mbot> (line 1, column 1):
18:37:17 <mbot> unexpected end of input
18:37:17 <mbot> expecting white space, natural, identifier, lambda abstraction or expression
18:37:22 <SamB> Hellska
18:37:24 <Pseudonym> Maybe we should name it after Howard instead of Curry.
18:37:26 <SamB> @gensym
18:37:26 <mbot> Unknown command, try @list
18:37:28 <Pseudonym> "Alvin"?
18:37:41 <sorear> ?pl \f g x -> f x >>= g
18:37:41 <mbot> flip . ((>>=) .)
18:37:42 <SamB> @newvar
18:37:42 <mbot> Unknown command, try @list
18:37:47 <SamB> @apropos var
18:37:47 <mbot> Unknown command, try @list
18:37:54 <zeeeee> dons: yeap! so i'm guessing that hasn't made it in yet?
18:38:02 <shapr> @quote Cale
18:38:02 <mbot>  Beware of the function [a] -> a. For it may contain trappes and sprynges of great variety and harm.
18:38:05 <sorear> ?fsn
18:38:05 <mbot> Maybe you meant: ask faq ft msg run wn
18:38:13 <sorear> ?mfn
18:38:13 <mbot> Maybe you meant: bf ft map msg run wn
18:38:39 <Pseudonym> bf ft map msg run wn sounds like the standard Unix environment summarised.
18:38:48 <SamB> how does fsn look like ask?
18:38:56 <SamB> oh.
18:38:57 <SamB> s
18:39:01 <SamB> ?abc
18:39:01 <mbot> Maybe you meant: arr ask bf ghc
18:39:09 * zeeeee wonders if there's a lib of such operators
18:39:14 <SamB> ?bcd
18:39:15 <mbot> Maybe you meant: bf id
18:39:21 <sorear> :t >>>
18:39:21 <SamB> ?cde
18:39:23 <zeeeee> also is there a standard operator for reverse function composition? (: opposite of (.)...won't argue pros/cons, don't wish to start a debate :)
18:39:24 <sorear> :t (>>>)
18:39:32 <SamB> @type (>>>)
18:39:33 <mbot> forall (a :: * -> * -> *) d b c. (Arrow a) => a b c -> a c d -> a b d
18:39:41 <SamB> sorear: I guess mbot doesn't have :t yet
18:39:48 <dons> zeeeee: the kleisli stuff is in a patch to be added this week
18:39:55 <LoganCapaldo_> ?t (>>>)
18:39:55 <mbot> Maybe you meant: tell time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
18:39:56 <sorear> what is the difference between mbot and lambdabot?
18:39:57 <dons> let me find you the code
18:40:02 <sorear> ?n
18:40:03 <mbot> Maybe you meant: . v wn
18:40:08 <SamB> sorear: well, mbot supports mathematica!
18:40:11 <sorear> ?r
18:40:11 <mbot> Maybe you meant: read reconnect redo remember resume run . v
18:40:18 <sorear> ?g
18:40:18 <mbot> Maybe you meant: gazetteer get-definition get-shapr ghc girl19 google gsite gwiki . v
18:40:19 <Pseudonym> ?q
18:40:19 <mbot> Maybe you meant: quit quote . v
18:40:28 <Pseudonym> ?
18:40:38 <dons> zeeeee: http://hackage.haskell.org/trac/ghc/ticket/997
18:40:40 <mbot> Title: #997 (Add Kleisli composition to Control.Monad) - GHC - Trac, http://tinyurl.com/yaw8kh
18:43:28 <zeeeee> ?pl flip .
18:43:28 <mbot> (line 1, column 7):
18:43:28 <mbot> unexpected end of input
18:43:28 <mbot> expecting white space or simple term
18:43:32 <zeeeee> ?pl flip (.)
18:43:33 <mbot> flip (.)
18:44:20 <nornagon> mbot?
18:44:34 <nornagon> should be \bot
18:44:39 <dons> lambdabot is down till i get more ip quota
18:45:25 <sjanssen> lambdabot eats significant bandwidth?
18:45:25 <zeeeee> sorear: i didn't mean a reverse composition operator for arrows, i just mean flip (.)
18:48:56 <dons> here's a nice little problem, http://praisecurseandrecurse.blogspot.com/2006/12/dot-matrix-printhead-haskell-toy.html
18:48:57 <mbot> Title: Praise, Curse, and Recurse: The Dot-Matrix Printhead: a Haskell Toy, http://tinyurl.com/y5hdc8
18:49:04 <dons> he's asking for a more haskellish soln
18:51:01 <jcreigh> the_long_function_names_with_underscores_just_kill_me :)
18:52:01 <dons> me too
18:53:47 <shapr> I could host lambdabot on scannedinavian.com, but I also have a quota.
18:53:54 <sorear> ze*: (>>>) is Kliesi composotion for Kliesi arrows.
18:54:24 <shapr> dons: I wonder if we could persuade SyntaxNinja to let us run lambdabot on darcs.h.o?
18:54:30 <dons> shapr: its fine. the quota's been fixed, and should propagate to the firewall soon
18:54:31 <jcreigh> well, his gen_n_bit_nums(un)signed functions are of the form "foo n = [ m | m <- list ]" when he could just say "foo n = list"
18:54:40 <dons> but next year we might want to think about running it on a haskell.org server..
18:54:41 <shapr> ah, ok.
18:54:47 <dons> since i'll be leaving unsw I guess, at some point
18:54:58 <shapr> Good point.
18:55:23 <shapr> btw, who takes over lambdabot if you have a bus error?
18:56:07 <dons> ok. i've tried to ensure all src is available from the public darcs repo
18:56:10 <dons> so anyone could if they like :)
18:56:16 <sorear> dons: At a suggestion from vincenz, I've been able to dramatically simplify the fail-over proposal
18:56:24 <dons> ah yes?
18:56:33 <dons> (it was too complex, i agree ;)
18:56:42 <dons> (i'd be more interested in a patch to handle netsplits thoug ... ;)
18:56:49 <shapr> I wonder if there's anything that would be lost if I had a bus error?
18:56:52 <dons> sorear: so the idea is to keep several bots on hand?
18:57:02 <shapr> Actually, my personal collection of Haskell sources and papers includes quite a few things that have never been released.
18:57:02 <dons> shapr: the IOHCC results!
18:57:14 <shapr> oh right =)
18:57:17 <sorear> yes... (although auto-reconnect would handle 99% of the cases)
18:57:23 <dons> yes, think about : would people be able to reproduce your results if you had a bus error
18:58:08 <shapr> sjanssen: Hey, was the happswiki code comprehensible? Not too concise?
18:58:09 <sorear> what is a bus error in this context?  SIGBUS?  "If I get hit by a bus?"  other?
18:58:16 <dons> hit by a bus :)
18:59:33 <sorear> Why does lambdabot run into quotas so easily?
18:59:50 <dons> it doesn't. dons does :)
19:00:00 <dons> since its hosted at uni, and each session my ip quota is set to something too low
19:00:09 <dons> so twice a year I run out :)
19:00:15 <dons> and have to wait a day to get another gig
19:00:28 <shapr> sorear: http://c2.com/cgi-bin/wiki?BusNumber
19:00:30 <mbot> Title: Bus Number
19:01:22 <SamB> there should be a command for that
19:01:30 <SamB> @c2wiki or somesuch
19:01:30 <mbot> Maybe you meant: gwiki wiki
19:01:36 <SamB> @help gwiki
19:01:36 <mbot> wiki <expr>. Search (new) haskell.org wiki for <expr> using google.
19:01:43 <SamB> oooh
19:01:46 <jcreigh> @google c2 wiki bus number
19:01:48 <mbot> http://www.artima.com/forums/flat.jsp?forum=155&thread=121762
19:01:48 <mbot> Title: Agile Buzz Forum - Do you know your Bus Number?
19:01:58 <SamB> @gwikipedia
19:01:58 <mbot> Empty search.
19:01:59 <jcreigh> hmmm...not quite as nice as I'd hoped.
19:02:04 <SamB> @gwikipedia hello
19:02:05 <mbot> No Result Found.
19:02:14 <SamB> @help gwikipedia
19:02:14 <mbot> help <command>. Ask for help for <command>. Try 'list' for all commands
19:02:23 <SamB> nope, no gwikipedia command
19:03:07 <dons> there is , if you believe (and darcs patch) in one!
19:03:30 <SamB> well first I'd have to figure out the URL to wikipedia!
19:03:38 <SamB> well, I suppose I could find that in the module
19:03:45 <SamB> so, first I'd have to open emacs on the file!
19:03:56 <SamB> and I am *far* too lazy
19:04:03 <SamB> right now
19:04:05 <SamB> at 10 PM
19:04:30 <SamB> after not having breakfast really because of needing a 12-hour fast for my bloodwork...
19:04:41 <shapr> It's only 9 pm here.
19:05:45 <jcreigh> shapr: the earth *is* round, isn't it? :P
19:05:57 <SamB> shapr: only because you are living in an entirely unpopulated area
19:06:02 <sorear> SamB: Lazy? You think you are lazy?  I wrote a shell script: links en.wikipedia.org/wiki/$1
19:06:05 <SamB> you are probably the only person for miles!
19:06:05 * shapr thinks...
19:06:15 <shapr> Nah, it's more pear shaped.
19:06:43 <SamB> shapr: for this purpose pears are round
19:07:46 <shapr> This is actually interesting - http://c2.com/cgi-bin/wiki?LazyPattern
19:07:47 <mbot> Title: Lazy Pattern
19:08:02 <jcreigh> I don't know anything anymore, I just look it up in Wikipedia. I wonder how many times I hit ctrl-t wp <whatever> every day...
19:08:10 <sorear> ?instances Num
19:08:11 <mbot> Double, Float, Int, Integer
19:08:21 <jcreigh> ?instances Monad
19:08:23 <mbot> ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
19:09:15 <shapr> jcreigh: I use C-l
19:10:15 <sorear> I seem to have been trying to memorize wikipedia...
19:11:06 <jcreigh> shapr: well, I almost always want to do it in a new tab...
19:12:03 <shapr> ah right
19:28:01 <erider> > List.map (( * ) 2)
19:28:02 <mbot>  add an instance declaration for (Show ([a] -> [a]))
19:29:39 <jcreigh> > map (*2) [1,2,3]
19:29:41 <mbot>  [2,4,6]
19:30:41 <kpreid> > List.map (( * ) (2 :: Integer))
19:30:42 <mbot>  add an instance declaration for (Show ([Integer] -> [Integer]))
19:30:57 <kpreid> huh?
19:30:59 <kpreid> > ord
19:31:00 <mbot>  add an instance declaration for (Show (Char -> Int))
19:31:12 <kpreid> oh. mbot doesn't have the Show instance for ->
19:33:12 <dons> mbot: @part and thanks!
19:33:34 <allbery_b> @bot
19:33:35 <mbot> :)
19:33:37 <lambdabot> :)
19:33:43 <allbery_b> heh
19:33:48 <dons> mbot: @part #haskell
19:34:02 <dons> ?uptime
19:34:03 <lambdabot> uptime: 1m 23s, longest uptime: 9d 2h 23m 6s
19:34:07 <dons> ?users
19:34:07 <lambdabot> Maximum users seen in #haskell: 288, currently: 246 (85.4%), active: 2 (0.8%)
19:34:14 <Lemmih> > ord
19:34:22 <lambdabot>  <Char -> Int>
19:37:47 <LoganCapaldo_> > (+)
19:37:48 <lambdabot>  Add a type signature
19:38:22 <geckosen1tor> so when I do 2^50000 I get a big number, but 2^50000 + 0.0 I get infinity
19:38:40 <erider> > List.map (( * ) 2)
19:38:41 <lambdabot>  Add a type signature
19:38:46 <LoganCapaldo_> geckosen1tor, 2 ^ 50000 can be made into Integers
19:39:00 <LoganCapaldo_> 0.0 can only be a Double
19:39:02 <geckosen1tor> LoganCapaldo_: so it only has infinite integers?
19:39:14 <geckosen1tor> well there is no reason it can't have a floating point with lots of digits
19:39:14 <LoganCapaldo_> at least afaik
19:39:36 <LoganCapaldo_> Well there are reasons I imagine :)
19:39:55 <allbery_b> there's an infinite-precision floating implementation running around, but it's not standard
19:41:50 <LoganCapaldo_> 2^50000 + 0 works ;)
19:42:29 <geckosen1tor> haha
19:44:27 <zeeeee> is Data.Sequence basically a priority queue? i'm not sure how to use it like one; the docs are sparse, and googling always gives me sequence.org.
19:45:39 <dons> if you want a real priority queue, use the Edison data structure package
19:46:03 <geckosen1tor> ooh cool, so all functions take only one argument?
19:46:04 <dons> Data.Sequence is a generalised sequence (list) interface, really
19:46:46 <zeeeee> well, would Data.Sequence be sufficient for the following problem? i would like to have my numbered (concurrent haskell) threads do some actions (eg IO) in order of their numbers. since they can finish out of order, i want to queue up the actions of those who finish early (ie before the actions of all lesser-numbered threads happen).
19:46:58 <Excedrin> this infinite precision floating point thing is nifty
19:47:09 <Excedrin> pi :: BigFloat -- doesn't terminate
19:47:13 <geckosen1tor> Excedrin: what happens if you do sqrt of 2?
19:47:15 <geckosen1tor> oh cool
19:47:20 <dons> zeeeee: a list might work, no?
19:47:29 <dons> otherwise, you could use a proper queue
19:47:32 <zeeeee> this way, when the 'missing' (late) actions do finally happen, i can keep popping things off the queue in growing order
19:47:35 <dons> but I'd try to do it with lists I htink
19:47:38 <LoganCapaldo_> Excedrin, really? Craaaaaaaaaaazy
19:47:45 <zeeeee> dons: well, yeah, it'd work, but not as efficiently
19:47:52 <dons> ok
19:47:54 <LoganCapaldo_> And I thought [1..] was cool...
19:48:32 <Excedrin> it's just happily printing digits of pi
19:48:32 <Excedrin> sqrt 2 :: BigFloat is pretty fast
19:48:32 <Excedrin> much faster than calculating pi at least
19:48:46 <dons> Excedrin: hmm, is this lib cabalised?
19:48:56 <Excedrin> nope
19:49:02 <dons> you want to do that?
19:49:05 <dons> sounds *really* useful
19:49:11 <dons> (people often ask for this functionality)
19:49:37 <geckosen1tor> it sounds useful
19:50:02 <Excedrin> http://medialab.freaknet.org/bignum/source.html
19:50:05 <lambdabot> Title: Bignum source code
19:50:59 <Excedrin> Free bignum server in Internet: telnet medialab.freaknet.org 31415
19:51:16 <zeeeee> eg: the last finished thread is 0. i spawn threads 1 2 3 4. if they finish in order 2 4 3 1, then queue should look like [] [2] [2 4] [2 3 4] [] (and last-finished should now be updated to 4)
19:51:50 <Excedrin> eh, that calculator doesn't produce very long results
19:52:01 <geckosen1tor> Excedrin: it can't do sqrt 2
19:52:13 <geckosen1tor> well not as an infinite output
19:52:38 <Excedrin> it does in ghci
19:53:02 <SamB> Excedrin: well, its hard to get that to work with net stuff, isn't it?
19:53:13 <SamB> I mean you'd probably have to add newlines...
19:53:21 <LoganCapaldo_> lol
19:53:22 <SamB> oh, telnet, huh.
19:53:27 * SamB silly
19:53:35 * SamB go now
19:53:36 <LoganCapaldo_> infinite file!
19:54:01 <geckosen1tor> the telnet thing is pitiful, it took 5 mintes to do 2^413234
19:54:22 <Lemmih> > 2^413234
19:54:27 <lambdabot> Terminated
19:54:41 <SamB> > 2^^413234
19:54:42 <lambdabot>  Infinity
19:54:49 <SamB> > 2**413234
19:54:50 <geckosen1tor> what does ^^ do?
19:54:50 <lambdabot>  Infinity
19:54:56 <SamB> > 2^^413234 :: Rational
19:55:01 <lambdabot> Terminated
19:55:06 <kpreid> @type (^^)
19:55:07 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
19:55:10 <SamB> > 2^(-1)
19:55:11 <lambdabot>  Exception: Prelude.^: negative exponent
19:55:13 <LoganCapaldo_> (2 :: Int) ^ (413234 :: Int)
19:55:14 <kpreid> @type (^)
19:55:15 <SamB> > 2^^(-1)
19:55:16 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
19:55:17 <lambdabot>  0.5
19:55:22 <LoganCapaldo_> > (2 :: Int) ^ (413234 :: Int)
19:55:23 <lambdabot>  0
19:55:24 <SamB> see, slight difference there
19:55:59 <geckosen1tor> ok
19:56:18 <kpreid> geckosen1tor: ^ ^^ ** are all exponentiation with different types, roughly
19:56:54 <SamB> ^^ lets you use negative exponents, in return for being able to divide
19:56:58 <kpreid> ^ can be used on more kinds of numbers than ^^, but doesn't allow negative exponents, and so on
19:57:13 <LoganCapaldo_> ?type (**)
19:57:15 <lambdabot> forall a. (Floating a) => a -> a -> a
19:57:42 <SamB> ** lets you use fractional exponents, at the expense of having to either be explicitly implemented, or have logs implemented, and of having the exponent and the base be of the same type
19:58:44 <SamB> Type an expression and press return:
19:58:44 <SamB> 2^413234/3
19:58:44 <SamB> FLOATING POINT OVERFLOW
19:58:56 * SamB thinks this is funny for some reason
19:59:07 <geckosen1tor> > sqrt (-1)
19:59:09 <lambdabot>  NaN
19:59:17 <geckosen1tor> what's up with that? I want imaginary
19:59:22 <LoganCapaldo_> NaN NaN Na Na
19:59:34 <kpreid> > sqrt (-1) :: Complex
19:59:35 <SamB_XP_> > sqrt (-1) :: Complex Double
19:59:35 <lambdabot>    `Complex' is not applied to enough type arguments
19:59:35 <lambdabot>   Expected kind `?',...
19:59:36 <lambdabot>  -0.0 :+ 1.0
19:59:39 <LoganCapaldo_> sqrt( -1 :+: 0 )
19:59:47 <LoganCapaldo_> > sqrt( -1 :+: 0 )
19:59:48 <lambdabot>  Not in scope: data constructor `:+:'
20:01:42 <gravity> What's the difference between the ':' and '++' operators?
20:01:57 <SamB_XP> @type (:)
20:01:58 <lambdabot> forall a. a -> [a] -> [a]
20:02:00 <SamB_XP> @type (++)
20:02:01 <lambdabot> forall a. [a] -> [a] -> [a]
20:02:10 <gravity> Ah, I see! Thank you!
20:02:22 <SamB_XP> you are welcome ;-)
20:02:43 <gravity> I should get used to just looking at types for answers :-)
20:03:03 <geckosen1tor> I don't have "Complex" :(
20:03:04 * SamB_XP is smiling because he was expecting some explanation would be needed ;-)
20:03:13 <SamB_XP> @hoogle Complex
20:03:14 <lambdabot> Complex :: module
20:03:14 <lambdabot> Data.Complex :: module
20:03:14 <lambdabot> Data.Complex.Complex :: data Complex a
20:03:15 <LoganCapaldo_> import Data.Complex
20:03:55 <geckosen1tor> LoganCapaldo_: <interactive>:1:0: parse error on input `import'
20:03:57 <SamB_XP> gravity: now, if you find two functions of the same type and can't figure out the difference, then that makes things trickier ;-)
20:04:09 <josephrivers> Suppose I define an infix operator <+>. How do I set things up so that I can use expressions like "3 <+> 4 <+> 6" without getting an error like "warning cannot mix <+> with <+>"
20:04:19 <LoganCapaldo_> geckosen1tor, :m Data.Complex
20:04:24 <sorear> infixr 3 <+>
20:04:27 <LoganCapaldo_> I meant import the verb ;)
20:04:30 <zeeeee> dons: so do you know if Sequence or any other standard data structure would work more efficiently than lists for my problem? where can i find said edison lib?
20:04:31 <SamB_XP> infixr or infixl
20:04:42 <sorear> ?where edison
20:04:42 <lambdabot> http://www.eecs.tufts.edu/~rdocki01/edison.html
20:04:44 <josephrivers> Thank you
20:04:59 <SamB_XP> depends how you want it to associate
20:05:08 <sorear> the 3 is the precedence level ['0
20:05:12 <sorear> '..'9']
20:05:21 <sorear> ?infix +
20:05:21 <lambdabot> Prelude
20:05:27 <sorear> ?infix (+)
20:05:27 <lambdabot> Prelude
20:05:28 <SamB_XP> ?fixity (+)
20:05:29 <lambdabot> Unknown command, try @list
20:05:30 <LoganCapaldo_> > sqrt ( -1 :+ 0 )
20:05:31 <lambdabot>    precedence parsing error
20:05:31 <lambdabot>     cannot mix prefix `-' [infixl 6] and `(...
20:05:38 <sorear> ?help ?infix
20:05:39 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
20:05:41 <sorear> ?help infix
20:05:41 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
20:05:45 <sorear> ?help help
20:05:46 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
20:05:54 <sorear> ?help ?run
20:05:55 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
20:05:56 <SamB_XP> dons: is there some command for fixity?
20:05:57 <sorear> ?help ?google
20:05:58 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
20:06:00 <sorear> ?help @google
20:06:01 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
20:06:02 <jcreigh> gah! "your HTML cannot be accepted: Tag is not allowed: <pre>". Thanks, Blogger.
20:06:04 <SamB_XP> sorear: ?help google
20:06:08 <SamB_XP> etc.
20:06:09 <sorear> ?help google
20:06:09 <lambdabot> google <expr>. Search google and show url of first hit
20:06:15 <sorear> ?help infixity
20:06:16 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
20:06:18 <sorear> ?help infixi
20:06:19 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
20:06:24 <sorear> ?help infixx
20:06:24 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
20:06:27 <sorear> ?infixx
20:06:27 <lambdabot> Unknown command, try @list
20:06:28 <jcreigh> sorear: you know, you can /msg lambdabot...
20:06:31 <SamB_XP> jcreigh: try "<code>", maybe?
20:07:14 <jcreigh> SamB_XP: nope.
20:07:25 <jcreigh> I'll just have to post on my blog and link to it...
20:07:45 <LoganCapaldo_> ?f
20:07:45 <lambdabot> Maybe you meant: fact fact-cons fact-delete fact-set fact-snoc fact-update faq foldoc fortune fptools free freshname ft . bf v
20:07:51 <LoganCapaldo_> ?i
20:07:52 <lambdabot> Maybe you meant: id index instances instances-importing . v
20:07:58 <LoganCapaldo_> well thats that
20:11:10 <sorear> ?list
20:11:11 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
20:12:06 * shapr warbles
20:12:51 <LoganCapaldo_> instances Warbler
20:12:53 <LoganCapaldo_> shapr
20:21:10 <chessguy> so i'm finding out more details about this perl job that i was offered
20:22:07 <chessguy> it sounds like it would be basically taking bits and pieces of existing html/javascript documents, customizing them, and putting them together into a new document
20:22:14 <mathewm> chessguy2: congratz
20:22:28 <chessguy> sounds like a job for haskell to me
20:23:05 <TomMD> am I repeating something in Prelude when I (stop nodding and let me finish) make a 'deleteFirstBy' that will return a ([a],Bool) indicating if something was actually deleted?
20:23:12 <chessguy> i'm thinking i could write a little mini-language, implemented in perl
20:23:18 <dibblego> TomMD, dropWhile
20:23:20 <chessguy> er, implemented in haskell
20:23:32 <dibblego> TomMD, sorry, I take it back
20:23:45 <dons> chessguy: sounds reasonable. doing text munging in a couple of languages
20:23:49 <chessguy> dibblego, stop nodding and let him finish :)
20:23:58 <dons> you'd want an HTML and Javascript parser/pretty printer/data type
20:23:59 <TomMD> Perhaps the proper answer is: forall (a->b->c), exists x `elem` Prelude | x == (a->b->c)
20:24:07 <dibblego> as soon as I saw "stop nodding", I stopped reading too
20:24:08 <dons> so you could take the existing pretty printer libs, html and xml packages
20:24:26 <chessguy> dons, plus something to do the customizing
20:24:34 <TomMD> lol
20:25:20 <chessguy> i'm picturing "change every occurence of 'fooBar Sales' to 'bazFoo Sales'"
20:26:01 <chessguy> stuff like that, as the customization part
20:26:32 <jcreigh> hmm, that telnet bignum host is really flaky...can't even calculate 10 ^ (10 ^ 100)
20:26:44 <chessguy> is there a way to run perl code from haskell?
20:27:01 <dons> system "perl foo"
20:27:06 <mathewm> chessguy: only through system calls
20:27:24 <mathewm> chessguy: could be a great way to learn the FFI, though
20:27:30 * mathewm considers a little project
20:27:56 <chessguy> Prelude> 10^(10^100)
20:27:56 <chessguy> ghc.exe has encountered a problem and needs to close.  We are sorry for the inconvenience.
20:28:02 <chessguy> FFI?
20:28:15 <SamB_XP> jcreigh: you kidder!
20:28:18 <mathewm> chessguy: Haskell->C binding
20:28:24 <SamB_XP> googolplex indeed!
20:28:26 <chessguy> C?
20:28:51 <mathewm> chessguy: yeah, C - what Perl is implemented in
20:29:11 <chessguy> but i'd like to write perl code, i think
20:29:19 <mathewm> chessguy: if you want to embed a Perl interpreter, you will need to code it in a little C, and marry that to Haskell via the FFI
20:29:22 <jcreigh> SamB_XP: well, yeah, but it seemed to take several minutes to realize that it wasn't going to happen. I would expect a publicly facing host to have fairly low "maximum execution time" limits, but that one doesn't appear to have any.
20:29:37 <sorear> there is already a haskell python binding
20:29:38 <SamB_XP> jcreigh: oh, right
20:29:52 <chessguy> hmm. maybe i don't need the perl
20:30:03 <sorear> ?where missingpy
20:30:04 <lambdabot> http://quux.org:70/devel/missingpy
20:31:18 <chessguy> what does "A haskell binding for foo" mean? just a foo interpreter implemented in haskell?
20:31:44 <sorear> an interface to the existing interpreter
20:31:53 <chessguy> ah, ok
20:32:01 <sorear> PyUgs doesn't exist yet :)
20:33:16 <sorear> considering that one of the major impls of Perl 6 is written in Haskell, I wonder if it has a library interface?
20:33:38 <jcreigh> although if they just recursively RLE'd the answer, it would be easy to print: 10{1{100}} (if c{x} means c repeated x times)
20:33:39 <mathewm> I heard pugs does
20:33:44 <chessguy> sorear, i just had that exact thought
20:35:52 <chessguy> the downside of this is, this project would probably be on my own time, at least until i can convince them it can work
20:36:42 <geckosen1tor> haskell-mode in emacs doesn't highlight embedded comments correctly
20:42:49 <chessguy> so, i'm confused, pugs is an implementation of perl 5 is haskell? and they're working on a pugs v.6?
20:43:03 <allbery_b> pugs is perl6 in haskell
20:43:16 <chessguy> err, oh right
20:43:19 <allbery_b> they're working on a "miniperl6" for bootstrapping
20:43:58 <gravity> Isn't there something weird about pugs implementing perl6 but perl6 not being finished?
20:44:15 <bd_> I'm attempting to find a solution to StroQ puzzles, currently using the StateT + List monad. I'd like to pull out some heuristics to determine what points would be good to start at, but it's difficult to get these without evaluating some actions in the monad (at which point, with ListT, I can't back out). Is there some way to use arrows to pass this data back cleanly?
20:44:20 <sorear> ?seen audreyt
20:44:20 <lambdabot> audreyt is in #perl6, #ghc and #haskell. I don't know when audreyt last spoke.
20:44:20 <chessguy> that's what i was just thinking.
20:44:23 <SamB_XP> gravity: no
20:44:27 <bd_> and, moreover, a good doc on arrows would be good :)
20:44:31 <allbery_b> no more so than prrot doing the same thing (but it's in C, or maybe C++, hven't paid much attention)
20:44:33 <SamB_XP> how would *you* design a language with no implementations?
20:45:01 <sorear> just look at Haskell!
20:45:05 <TomMD> Will there ever be a cugs I wonder (c# in haskell), that would be scary.
20:45:36 <SamB_XP> C# user's gopher system?
20:45:48 <sorear> Wasn't implementation of Haskell not started until after standardization was finished?
20:45:52 <chessguy> so, is there a module that i can import that would let me just do foo = eval(somePerlCode)
20:46:06 <SamB_XP> sorear: well, Haskell is considerably less hairy than Perl6
20:46:26 <sorear> ?hoogle System.Cmd
20:46:27 <SamB_XP> also, standardization wasn't finished!
20:46:27 <lambdabot> No matches, try a more general search
20:46:43 <SamB_XP> because Haskell 98 is about Haskell 1.5
20:47:09 <sorear> :t System.Cmd.system . ("perl -e "++)
20:47:10 <lambdabot> [Char] -> IO GHC.IOBase.ExitCode
20:47:16 <sorear> that should work :)
20:47:19 <SamB_XP> you don't go incrementing version numbers of unimplemented languages...
20:47:58 <TomMD> Sure you do, I just invented a new language called lang.  I'm on version 1.0
20:48:04 <TomMD> Nope, now I'm on 1.1
20:48:21 <TomMD> Heck, I don't even know if it is imparitive yet.
20:48:41 <sorear> I'm already on revision 15 of the processor architecture I've been designing in bored moments
20:49:05 <monochrom> I don't like hackers. They have all sorts of prejudice.
20:49:09 <jcreigh> Come to think of, Haskell version numbers shouldn't be incremented. We should just bind the current version of Haskell to a function that returns a new version of Haskell. :)
20:49:40 <TomMD> sorear: What is the inspiration behind this architecture?  Is it available somewhere like opencores?
20:50:13 <bd_> jcreigh: let haskell = undefined:map advanceVersion haskell? :)
20:50:31 <sorear> let haskell = fix improve
20:50:52 <jcreigh> I was thinking more haskell >>= advanceVersion
20:50:52 <SamB_XP> that is Haskell n.0
20:51:04 <bd_> jcreigh: What monad would that be?
20:51:11 <monochrom> reader
20:51:33 <bd_> and, wouldn't haskell be a constant here? :)
20:51:53 <monochrom> I hate metaphors.
20:52:09 <SamB_XP> monochrom: what? You say this should be an article in the monad reader?
20:52:31 <monochrom> That is one interpretation.
20:52:49 <monochrom> But I hate interpretations.
20:53:25 <SamB_XP> you prefer compilations?
20:53:40 <monochrom> I prefer syntax as semantics.
20:54:43 <SamB_XP> in that case, I will recommend to you the esoteric programming language "cat"
20:54:44 <dgriffi3> does haskell have some mechanism for doing static license checking on modules?
20:55:00 <SamB_XP> license checking?
20:55:11 <bd_> > take 10 $ fix $ (1:) . (1:) . uncurry (zipWith (+)) . liftM2 (,) id tail
20:55:13 <lambdabot>  [1,1,2,3,5,8,13,21,34,55]
20:55:21 <SamB_XP> HINAL
20:55:22 <monochrom> No, but I'm sure Oleg can cook up a way.
20:56:00 <dgriffi3> for instance me wanting to release my code BSD and importing a GPLed module without thinking about it
20:56:22 <mathewm> how can I make Map.insert strict?  ((M.insert key $! val) map) ?
20:56:50 <monochrom> But the real solution is to shoot all the license extremists.  Then there needs no checking.
20:56:54 <dgriffi3> of course, there would probably need to be an accompaining -fIANAL option or something
20:56:57 <dgriffi3> fair enough
20:57:05 <monochrom> I am just kidding.
20:57:30 <LoganCapaldo_> Hmm Is BSD a subtype of GPL then? <g> Is PublicDomain untyped?
20:57:40 <jcreigh> dgriffi3: What's the problem with your code being BSD licences and importing someone else's GPL'd code?
20:58:20 <dgriffi3> hmm, isn't there a conflict there?
20:58:41 <jcreigh> dgriffi3: I don't think so. As long as you're not trying to re-license GPL code as BSD.
20:58:42 <dgriffi3> I suppose I don't know too much about compatibility between licences
20:58:45 <Pseudonym> LGPL is a subtype of GPL.
20:59:04 <sorear> licenses form a lattice
20:59:05 <SamB_XP> Pseudonym: oh boy
20:59:11 <SamB_XP> you are trying to confuse me?
20:59:25 <SamB_XP> sorear: oh really?
20:59:31 <LoganCapaldo_> import Lawyer
20:59:33 <jcreigh> LoganCapaldo_: PublicDomain is undefined (see http://linuxmafia.com/faq/Licensing_and_Law/public-domain.html)
20:59:34 <sorear> BSD `meet` GPL == GPL  BSD4 `meet` GPL == AllRightsReserved  etc
20:59:34 <lambdabot> Title: public-domain
20:59:49 <SamB_XP> what is GPL `meet` SharedSource ?
20:59:59 <sorear> ARR, probably.
21:00:14 <SamB_XP> is that the "you can't have it" license?
21:00:22 <sorear> _ `join` PublicDomain == PublicDomain
21:00:38 <sorear> yes, null license, no actions permitted
21:00:46 <sorear> oh, wait - it is a bounded lattice!
21:00:53 <SamB_XP> too bad there is no legal way to invoke the join operator!
21:01:19 <sorear> join creates dual licenses and may only be used by the copyright holder
21:01:32 <SamB_XP> yeah, see, thats the rub :-(
21:01:55 <LoganCapaldo_> > PublicDomain
21:01:56 <lambdabot>  Not in scope: data constructor `PublicDomain'
21:02:09 <SamB_XP> LoganCapaldo_: this is not really a Haskell datatype!
21:02:10 <zeeeee> are there any examples of using the data structures in edison (specifically MinHeap)? i'm currently struggling with type errors.
21:02:18 <zeeeee> *ambiguous type errors
21:02:48 <LoganCapaldo_> It's not?
21:02:52 <LoganCapaldo_> darn
21:02:56 <LoganCapaldo_> ;)
21:03:58 <SamB_XP> @quote astrolabe
21:03:58 <dons> do you have the haddock documetation handy?
21:03:59 <lambdabot>  Below a certain level of competence, coding is a destructive act.  Like playing the violin.
21:04:05 * SamB_XP likes that one a lot ;-)
21:04:50 <zeeeee> dons: yes
21:05:17 <dons> I suspect that's currently the only 'tutorial' then. Besides Okasaiki's textbook, of course
21:05:25 <SamB_XP> @quote Daveman
21:05:25 <lambdabot>  Cale, what if I don't want to obey the laws?  Do they throw me in jail with the other bad monads?
21:05:30 <dons> zeeeee: feel free to @paste the code (and any error)
21:05:32 <zeeeee> dons: but there are no examples therein... for instance, when i do 'empty', i get ambiguous types: h & a
21:05:36 * SamB_XP likes that one too
21:05:45 <dons> zeeeee: right, since you'll need to spciefy what 'empty' you want
21:05:49 <dons> > M.empty
21:05:50 <lambdabot>  Add a type signature
21:05:52 <zeeeee> dons: right, so
21:05:54 <dons> > M.empty :: M.Map Int ()
21:05:55 <lambdabot>  {}
21:05:58 <dons> for example
21:06:03 <zeeeee> dons: empty :: Min Int Int
21:06:05 <dons> if the type can't be inferred
21:06:14 <zeeeee> but that fails
21:06:28 <dons> you'll need to @psate the src. I don't know edison :)
21:06:33 <zeeeee> i can't tell what the heck the h & a are supposed to be
21:06:55 <zeeeee> dons: i'm just looking at http://www.eecs.tufts.edu/~rdocki01/docs/edison/Data-Edison-Coll-MinHeap.html
21:06:57 <lambdabot> http://tinyurl.com/wyno8
21:07:04 <bd_> ?where arrows
21:07:05 <lambdabot> http://www.haskell.org/arrows/
21:07:10 <zeeeee> there's no source, really...i'm trying to create an empty heap on ghci
21:08:19 <zeeeee> http://www.eecs.tufts.edu/~rdocki01/docs/edison/Data-Edison-Coll.html actually has english, but i don't know where to look for details on what the h & a are
21:08:21 <lambdabot> http://tinyurl.com/y6xgdk
21:09:01 <dons> empty :: Min Int Int
21:09:04 <dons> looks ok to me.
21:09:19 <monochrom> h is the collection type. a is the element (content) type.
21:09:46 <dons> ah, so h is of kind *->* or something?
21:09:54 * LoganCapaldo_ would guess the same as monochrom
21:10:17 <monochrom> For example h may be (Set Int), a may be Int.
21:10:20 <dons> something like Min [] a ?
21:10:55 <zeeeee> monochrom: as in Data.Set?
21:10:58 <dons> or Min [Int] Int
21:11:04 <zeeeee> this is quite confusing
21:11:11 <monochrom> No, as in Edison Set.
21:11:31 <monochrom> This is not confusing.
21:11:47 <monochrom> But I grant you that you are confused.
21:13:01 <LoganCapaldo_> zeeeee: Something like MinHeap SplayHeap Int
21:14:37 <zeeeee> hmm...i think i'm ready to fall back to []
21:15:20 <LoganCapaldo_> From what I can tell MinHeap is just a wrapper around the actual container that makes psecial provisions for the minimum element
21:15:26 * shapr is confused and falls back.
21:15:27 <monochrom> I'm afraid you mean MinHeap (SplayHeap Int) Int
21:15:46 <LoganCapaldo_> monochrom, Haskell should be more psychic than that ;)
21:16:09 <monochrom> For now, I will be the psychic.
21:17:32 <zeeeee> monochrom: what are this week's winning lottery numbers?
21:18:14 <jcreigh> I think it would be really funny if monochrom rattled off some numbers that turned out to be corrent.
21:18:24 <monochrom> Encore in Ontario is 1 3 5 9 today.  I just saw it in the subway.
21:18:36 <jcreigh> of course, I'd be kicking myself for not buying a ticket for the rest of my life...
21:18:38 <dons> we should try to get edison into extra libs
21:18:40 <dons> (maybe)
21:18:41 <monochrom> Err, that's Pick 4, not Encore.
21:20:51 <zeeeee> dons: that would be nice, or alternatively if that cpan for haskell is finished. i also wish there were better docs (more tutorial-ish).
21:20:55 <LoganCapaldo_> edison :: Maybe Lib
21:21:27 <Pseudonym> One of the things I want is Data.Set, Data.Map and Data.List rationalised.
21:21:34 <Pseudonym> I don't like having to write GHC.Base.map
21:21:54 <LoganCapaldo_> rationalised?
21:21:59 <Pseudonym> (Though my usual solution is to write "fmap" instead.)
21:22:11 <Pseudonym> Yes.
21:22:20 <Pseudonym> If you import more than one, you get LOTS of name overloading.
21:22:34 <zeeeee> oh, that
21:23:04 <LoganCapaldo_> ok let me rephrase, what does rationalised mean in this context? :)
21:23:43 <Pseudonym> Basically, get them working together.
21:23:55 <LoganCapaldo_> ah
21:24:35 <LoganCapaldo_> instances Mapable = List, Set, Map, etc.?
21:24:48 <bd_> Data.Traversable you mean? :)
21:25:06 <bd_> :t Data.Traversable.map
21:25:08 <lambdabot> Couldn't find qualified module.
21:25:11 <bd_> bah
21:25:19 <bd_> well
21:25:24 <bd_> it's mapM I guess
21:25:25 <LoganCapaldo_> I get the idea :)
21:25:36 <bd_> but you can import prelude hiding map and do map = fmap :)
21:25:57 <sorear> Is there a standard parser combinator library that can be *used* in a monad?
21:26:13 <bd_> sorear: in a monad? Not just calling into it from a monad?
21:26:26 <monochrom> Like ListT (StateT (ContT Parsec)))?
21:26:49 <bd_> sorear: Usually you don't want somethign like ParsecT Foo, since parsec might need to 'undo' work
21:26:59 <bd_> eg in a try-delimited parse
21:26:59 <sorear> I mean, I have:
21:27:03 <dons> zeeeee: yes, it'll go into hackage . that'll solve the problem
21:27:27 <dons> regarding tutorial documentation. I'll add some encouragement to the library-creation page to get authors to write tutorials alongside their haddocks
21:27:42 <sorear> class Monad m => MonadRStream m e | m -> e where getv :: m e ; lookv :: m (Maybe e)
21:27:57 <monochrom> Like "three cheers if you tutor!"?
21:28:03 <sorear> I want parser combinators that will work in a generic read-supporting monad.
21:28:06 <monochrom> Sorry I'm drunk.
21:28:22 <Pseudonym> -- drunk, fix later
21:28:29 <monochrom> hahaha
21:28:41 <bd_> sorear: Can you interleave or make lazy this monad?
21:28:53 <sorear> what do you mean?
21:29:10 <sorear> anyway I defined this monad, so I can extend it conveniently.
21:29:23 <monochrom> I think you'll use "set Parsec state" and "get Parsec state" very often.
21:29:27 <bd_> sorear: well, if it's lazy, you can just make it into a list
21:29:42 <sorear> I want to eventually make instances for IO, ByteString, [Char], etc.
21:29:57 <bd_> sorear: if you have something analogous to unsafeInterleaveIO, you can make it into a lazy list even if it's not really lazy
21:30:52 <bd_> but I don't think parsec directly supports anything beyond a list input...
21:31:28 <dons> ?where bytestringparsec
21:31:29 <lambdabot> I know nothing about bytestringparsec.
21:31:30 <sorear> I looked at parsec + readp
21:32:10 <dons> ?where+ fps-parsec http://hackage.haskell.org/~paolo/darcs/ByteStringParser
21:32:11 <lambdabot> Done.
21:32:17 <dons> xerox, cabalise and reease http://hackage.haskell.org/~paolo/darcs/ByteStringParser please!
21:32:20 <lambdabot> Title: Index of /~paolo/darcs/ByteStringParser
21:34:18 <monochrom> Does bytestring support unicode?
21:34:48 <sorear> UTF-8 only
21:34:54 <sorear> *byte*string
21:34:55 <monochrom> Good.
21:35:27 <sorear> I suppose you could use UTF-7, or quoted-printable, but UTF-8 is a good standard
21:36:35 <jcreigh> but Char is unicode, right?
21:36:48 <monochrom> Why is it bytestring?  Why did the people not do 32bitwordstring?
21:37:12 <sorear> but, I don't just want bytestring - I want to support anything that can be fit into my MonadRStream
21:37:30 <sorear> they are kowtowing before the false god of efficiency
21:38:59 <zeeeee> ?pl zip
21:39:00 <lambdabot> zip
21:39:50 <sorear> ?unpl zip
21:39:51 <lambdabot> zip
21:39:59 <zeeeee> @type (\x -> zip x (tail x))
21:40:01 <lambdabot> forall a. [a] -> [(a, a)]
21:40:27 <zeeeee> how do i use lambdabot to search for functions of a given sig?
21:40:32 <sorear> ?hoogle
21:40:32 <lambdabot> HOOGLE - Haskell API Search
21:40:33 <lambdabot> (C) Neil Mitchell 2004-2006, York University, UK
21:40:33 <lambdabot>  
21:40:50 <zeeeee> ?hoogle [a] -> [(a, a)]
21:40:51 <lambdabot> Prelude.zip :: [a] -> [b] -> [(a, b)]
21:41:01 <zeeeee> dangit
21:42:37 <monochrom> You can always say "zip haha haha".
21:42:45 <jcreigh> > zip [1,2,3] "abc"
21:42:46 <lambdabot>  [(1,'a'),(2,'b'),(3,'c')]
21:43:34 <LoganCapaldo_> @pl map (\x -> (,) x x) [1,2,3]
21:43:35 <lambdabot> map (join (,)) [1, 2, 3]
21:43:56 <LoganCapaldo_> I can never remember what join is called
21:44:09 <zeeeee> > :i join
21:44:10 <lambdabot>  Parse error
21:44:13 <zeeeee> :i join
21:44:31 <LoganCapaldo_> @type join
21:44:32 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
21:44:34 <zeeeee> :t (,)
21:44:36 <lambdabot> forall b a. a -> b -> (a, b)
21:45:26 <jcreigh> > (,) 1 2
21:45:27 <lambdabot>  (1,2)
21:45:36 <zeeeee> > 1 , 2
21:45:36 <lambdabot>  Parse error
21:45:40 <zeeeee> hrm
21:46:10 <zeeeee> > map (join (,)) [1,2,3]
21:46:12 <lambdabot>  [(1,1),(2,2),(3,3)]
21:46:28 <LoganCapaldo_> @type map (join (,))
21:46:29 <lambdabot> forall a. [a] -> [(a, a)]
21:46:50 <zeeeee> > map (join (, . tail)) [1,2,3]
21:46:50 <lambdabot>  Parse error
21:46:59 <zeeeee> > map (join ((,) . tail)) [1,2,3]
21:47:00 <lambdabot>  add an instance declaration for (Num [a])
21:47:00 <lambdabot>   In the list element: 3
21:49:31 <LoganCapaldo_> > (\(x:xs) -> [(x, xs)]) [1,2,3]
21:49:32 <lambdabot>  [(1,[2,3])]
21:50:22 <zeeeee> > takeWhile (\(x,y) -> x+1 == y) [1,2,3,5]
21:50:23 <lambdabot>  add an instance declaration for (Num (b, b))
21:50:23 <lambdabot>   In the list element: 5
21:51:00 <LoganCapaldo_> groupBy (\x y -> x + 1 == y) [1,2,3,5]
21:51:07 <LoganCapaldo_> > groupBy (\x y -> x + 1 == y) [1,2,3,5]
21:51:09 <lambdabot>  [[1,2],[3],[5]]
21:52:13 <zeeeee> LoganCapaldo_: thanks
21:52:29 <zeeeee> hrm, actually...i guess that's still not quite right is it
21:52:48 <LoganCapaldo_> Not exactly
21:52:49 <sorear> LC_: groupBy needs an equivalence relation. (I know this because it was described as a fixable wart :( )
21:52:56 <zeeeee> > let pairs x = zip x (tail x)
21:52:56 <lambdabot>  Parse error
21:53:04 <zeeeee> > let pairs x = zip x (tail x) in pairs [1,2,3]
21:53:06 <lambdabot>  [(1,2),(2,3)]
21:53:49 <LoganCapaldo_> @type groupBy
21:53:51 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
21:54:07 <LoganCapaldo_> sorear: What do you mean?
21:54:08 <zeeeee> > let pairs x = zip x (tail x); consecs = takeWhile (\(x,y) -> x+1==y) . pairs in consecs [1,2,3]
21:54:10 <lambdabot>  [(1,2),(2,3)]
21:54:25 <LoganCapaldo_> Oh wait
21:54:29 <LoganCapaldo_> never mind
21:54:36 <LoganCapaldo_> I think I know what you mean
21:56:05 <zeeeee> > let pairs x = zip x (tail x); consecs = let ps = unzip . takeWhile (\(x,y) -> x+1==y) . pairs in head (fst ps) : snd ps in consecs [1,2,3]
21:56:06 <lambdabot>    Expecting a function type, but found `(a, b)'
21:56:07 <lambdabot>    Expected type: ([a],...
21:56:25 <zeeeee> > let pairs x = zip x (tail x); consecs = ( let ps = unzip . takeWhile (\(x,y) -> x+1==y) . pairs in head (fst ps) : snd ps ) in consecs [1,2,3]
21:56:26 <lambdabot>    Expecting a function type, but found `(a, b)'
21:56:26 <lambdabot>    Expected type: ([a],...
21:58:09 <zeeeee> > let pairs x = zip x (tail x); consecs ls = let ps = unzip . takeWhile (\(x,y) -> x+1==y) . pairs $ ls in head (fst ps) : snd ps in consecs [1,2,3]
21:58:11 <lambdabot>  [1,2,3]
21:58:14 <zeeeee> > let pairs x = zip x (tail x); consecs ls = let ps = unzip . takeWhile (\(x,y) -> x+1==y) . pairs $ ls in head (fst ps) : snd ps in consecs [1,2,3,5]
21:58:16 <lambdabot>  [1,2,3]
22:01:06 <zeeeee> > let pairs x = zip x (tail x); takeConsecs ls = let ps = unzip . takeWhile (\(x,y) -> succ x==y) . pairs $ ls in head (fst ps) : snd ps in consecs [1,2,3,5]
22:01:07 <lambdabot>  Not in scope: `consecs'
22:01:19 <zeeeee> > let pairs x = zip x (tail x); takeConsecs ls = let ps = unzip . takeWhile (\(x,y) -> succ x==y) . pairs $ ls in head (fst ps) : snd ps in takeConsecs [1,2,3,5]
22:01:21 <lambdabot>  [1,2,3]
22:03:24 <geckosen1tor> is this a haskell shell?
22:03:33 <geckosen1tor> > ls
22:03:34 <lambdabot>  Not in scope: `ls'
22:04:01 <allbery_b> it's a ghci prompt with some things disabled (notably IO)
22:04:20 <LoganCapaldo_> Plus some extra fun toys and commands
22:04:37 <sorear> ?quote lambdabot
22:04:38 <lambdabot>  ghc-6.5: panic! (the `impossible' happened, GHC version 6.5):        checkPr...
22:04:38 <LoganCapaldo_> @pl (\x y -> (y + 1, x) )
22:04:38 <lambdabot> flip ((,) . (1 +))
22:04:46 <geckosen1tor> > putStrLn "test"
22:04:48 <lambdabot>  <IO ()>
22:04:52 <geckosen1tor> oh ok
22:05:01 <geckosen1tor> I don't see why io isn't allowed for at least output
22:05:17 <sorear> uh, writeFile "/etc/passwd" ?
22:05:35 <allbery_b> because it's difficult to allow only a small part of the IO monad, so the entire monad is spiked
22:05:35 <geckosen1tor> it's encrypted right... ?
22:05:42 <sorear> writeFile "/home/dons/.bashrc"
22:05:46 <LoganCapaldo_> It's easier to drop all of IO instead of just some of it. Plus w/o IO all code is PCC! whee
22:05:50 <sorear> hence I reset with write
22:06:24 <zeeeee> PCC?
22:06:33 <LoganCapaldo_> proof carrying code
22:07:00 <LoganCapaldo_> type checking input to lambdabot can prove that it doesn't do IO
22:07:05 <jcreigh> geckosen1tor: Usually, /etc/passwd just has the basic info like uid/username/homedir/etc, and /etc/shadow has the crypted passwords. (which isn't world-readable)
22:07:14 <LoganCapaldo_> so no worries about breaking anything
22:07:17 <LoganCapaldo_> its cool
22:07:23 <geckosen1tor> jcreigh: oh right.. well even if you can read it.. it isnt' easy to break
22:07:45 <notsmack> geckosen1tor: depends on the passwords
22:07:53 <geckosen1tor> you would have to crack salted md5 or whatever it is using
22:08:51 <allbery_b> you'd be amazed how well dictionary-based attacks work, especially on university machines :/
22:09:03 <geckosen1tor> is it university based?
22:09:31 <allbery_b> well, it's running on a machine in the unsw.edu.au domain
22:09:42 <allbery_b> (university of new south wales, IIRC)
22:09:43 <Excedrin> > putStrLn "wat"
22:09:43 <Excedrin> @pl \x y z -> if x then y else z
22:09:44 <Excedrin> oh, I'm lagged a lot
22:09:46 <geckosen1tor> i did rainbow tables on university machines.. and I would say at least 50% of the passwords were a word optionally followed by a number
22:09:46 <lambdabot>  <IO ()>
22:09:46 <lambdabot> if'
22:09:54 <Pseudonym> Dictionary attacks work well on university machines partly because there are so many accounts.
22:10:18 <Pseudonym> And yes, because passwords are insecure.
22:10:22 <allbery_b> ...and partly because students are lazy, and not in the nice Haskell way :>
22:10:59 <dibblego> how do you exclude the implicit import of Prelude functions?
22:11:07 <sorear> you may have noticed I used writeFile (thus changing everyone's password) rather than readFile.  Ergo, ther is no need to question my MD5-inverting ability.
22:11:11 <sorear> import Prelude ()
22:11:31 <dibblego> is there import Prelude excluding ... ?
22:11:41 <allbery_b> sure
22:11:43 <sorear> import Prelude hiding (map)
22:11:49 <allbery_b> like that
22:11:52 * sorear swears by pwgen
22:11:53 <dibblego> ah thanks
22:11:58 <allbery_b> or even import Prelude qualified ...
22:12:17 <sorear> shouldn't that be import qualified Prelude ?
22:12:22 <allbery_b> probably
22:12:27 <allbery_b> I don't do it much
22:12:40 * allbery_b should really be in bed, he suspects, brain is playing tricks
22:19:14 <Pseudonym> I wonder if there's a better way to implement exact cover solvers in Haskell than dancing links.
22:19:38 <glguy__> FLASH: learning Haskell can be difficult, news at 10
22:19:55 <glguy__> wtf with the "Do-notation considered harmful guy" (-:
22:21:46 <glguy__> if anyone was wondering what that article was about, I'll summarize it for you to save you the read "Monads don't make sense to people that don't understand them"
22:22:15 <dibblego> neither do chciken bones
22:22:22 <allbery_b> enh.  I actually agree with him to some extent; working with >>= directly helped me figure out how to work with monads
22:22:24 <Kahdloc> yeah....nothing does
22:22:39 <ray> jcreigh: not "usually", but on a lot of systems :)
22:22:46 <monochrom> I also introduce >>= first, then do.
22:23:33 <Pseudonym> Economics doesn't make sense to people who DO understand it.
22:23:42 <monochrom> haha
22:23:44 <glguy__> if the title was "I think it's hard to teach monads with do-notation" I'd go a little easier on it (-;
22:24:57 <dons> ?seen syntaxfree
22:24:57 <lambdabot> I saw syntaxfree leaving #haskell 22h 17m 39s ago, and .
22:25:40 <monochrom> "When you think you know everything, you can get a BSc."
22:25:45 <allbery_b> given that that was what he seemed to actually be saying, I'm willing to grant him the hyperbolic Dijkstra invocation :)
22:26:01 <monochrom> "When you find out you know nothing, you can get an MSc."
22:26:03 <dons> yeah, just a catchy title to provoke clicking on the link...
22:26:10 <monochrom> and the really neat one...
22:26:13 <allbery_b> th Ph.D being reserved for when you realize you don't know anything?
22:26:18 <allbery_b> ah
22:26:31 <monochrom> "When you find out your supervisor know nothing either, you can get a PhD."
22:26:39 <allbery_b> heh
22:26:45 <jcreigh> ray: oh, really? I thought most modern UNIXen used the shadow password system.
22:27:02 <monochrom> In my experience it's really true!
22:27:13 <ray> it's one of those very system-dependent things
22:27:33 <allbery_b> modern systems do tend to use some form of shadow passwords, but /etc/shadow is not the only one
22:27:42 <IPI> is it possibe to have a pattern such as [XS:X] ? having X as tail ?
22:27:50 <allbery_b> there's also a bunch of systems using /tcb/...
22:27:55 <ray> i tend not to use it, as it's pointless when all your passwords are starred out anyway
22:28:01 <dons> > let f (x:xs) = xs in f "haskell"
22:28:03 <lambdabot>  "askell"
22:28:07 <dons> IPI: ^^
22:28:20 <allbery_b> ipi: no, the cons operator is element:list, not list:element
22:28:51 <IPI> ok ... then how can i get a tail of a list?
22:28:57 <ray> that is the tail
22:29:10 <IPI> oh sorry .. i meant the last item in the list
22:29:11 <mq_mattr> can't you use views
22:29:18 <jcreigh> > last [1,2,3]
22:29:19 <lambdabot>  3
22:29:20 <mq_mattr> head (reverse lst)
22:29:37 <mq_mattr> >head (reverse [1,2,3])
22:29:39 <IPI> ok so last will give me last item... nice :)
22:29:49 <IPI> well i am not suppose to use reverse
22:29:54 <mq_mattr> correct
22:30:00 <mq_mattr> but what does last do?
22:30:12 <jcreigh> mq_mattr: it returns the last element of a list
22:30:19 <mq_mattr> you can *hope* whoever wrote it didn't use reverse
22:30:27 <dibblego> last returns the last element in O(n)
22:30:32 <mq_mattr> jc: I mean, does it use reverse to do its work
22:30:59 <dibblego> > last "abcd"
22:31:00 <lambdabot>  'd'
22:31:17 <jcreigh> last [x]         =  x last (_:xs)      =  last xs (from the Haskell report)
22:31:22 <allbery_b> > let last [] = undefined; last (x:[]) = x; last (x:xs)=last xs in last [1,2,3]
22:31:24 <lambdabot>  3
22:31:30 <glguy__> > let f [] = error "empty list"; f (x:xs) | null xs = x | otherwise = f xs in f "abcd"
22:31:32 <lambdabot>  'd'
22:31:38 <IPI> ok .. my question is how to print a list of item in reverse with out using reverse function?
22:31:52 <glguy__> Like , homework question 2?
22:31:56 <mq_mattr> views
22:31:58 <mq_mattr> ?
22:32:14 <dibblego> IPI, you don't want the last function
22:32:18 <dibblego> there's a hint
22:32:21 <mq_mattr> why no reverse function?
22:32:59 <IPI> well i am working on sample final... in first part of a question they given us a prolog function, and we have to figure out what it does ... then we have to write a equivalent haskell function ...
22:33:14 <dons> do you have ghci installed?
22:33:16 <IPI> now i figured that prolog function they have prints the list in reverse order
22:33:16 <dibblego> IPI, which university?
22:33:24 <IPI> University of Calgary
22:33:47 <mq_mattr> my exams never had interesting questions like that
22:34:07 <LoganCapaldo_> mine either
22:34:47 <IPI> also it must be recursive and should have only one arguemtn, the input L and return the value R
22:34:56 <IPI> abc:: [a] -> [a]
22:35:07 <IPI> abc [] = []
22:35:11 <dibblego> yes, but you'll be writing another function that takes an additional argument (call it 'accumulator')
22:35:27 <IPI> right .. dibblego  that is actually how the prolog one works
22:35:42 <dibblego> right, so you won't be needing the last function :) despite the temptation
22:36:24 <IPI> ok .. let me figure it out ... i'll let you guys know with what i came up so you can take it look at it for me :)
22:36:29 <dibblego> ok
22:37:22 <ray> sounds like a pretty good CS course
22:37:31 <ray> (one that uses haskell, that is)
22:37:41 <mq_mattr> anyone an expert on Text.PrettyPrint?
22:37:55 <mq_mattr> or at least proficient?
22:38:32 <dibblego> what delta compression algorithm(s) does darcs use?
22:38:57 <IPI> ray, it called Programming Paradigms , goes over 3 paradigms : imaritive language (such as java), Haskell & Prolog. the focus of the course is on Haskell & Prolog ..
22:39:24 <IPI> *imparitive
22:39:25 <ray> not bad
22:39:35 <ray> *imperative, actually
22:39:50 <IPI> LOL
22:39:57 <dons> mq_mattr: yeah, used it a fair bit
22:40:14 <IPI> my bad on that one :)
22:40:25 <mq_mattr> I am trying to nest to a depth I can't know until run-time
22:40:55 <mq_mattr> how far I am nesting depends on how the pretty print prints the thing on left
22:41:02 <mq_mattr> how long it ends up being
22:41:14 <dons> mmm. ok.
22:41:15 <mq_mattr> this must be a common problem
22:41:26 <mq_mattr> but I can't find a combinator to help me
22:42:01 <dons> I don't think there is a bounded-width 'hang', afaik.
22:42:39 <mq_mattr> The reason I am searching so hard is that Iseq (from "implementing functional langauges: a tutorial") has one
22:42:42 <mq_mattr> IIndent
22:43:17 <mq_mattr> not having it is not the worst problem, I can't think how to make my own
22:44:12 <dibblego> are there any delta compression algorithms in the standard libraries?
22:45:57 <dons> nope.there's some 3rd party compression  libs though, dcoutt's bzip2/gzip bytestring compression libs, and bulat's secret russian compression tool
22:46:36 <dibblego> I was thinking of LCS algorithms and block move
22:46:57 <dibblego> lcs :: Eq a => [a] -> [a] -> [Delta a]
22:48:16 <dibblego> I was trying to find some in the darcs source
23:00:31 <Excedrin> @pl \x y z -> if x then y else z
23:00:32 <lambdabot> if'
23:00:40 <Excedrin> where is if' defined?
23:00:48 <dibblego> ?info if'
23:00:49 <lambdabot> if'
23:01:38 <Excedrin> @hoogle Bool -> t -> t -> t
23:01:39 <lambdabot> No matches, try a more general search
23:01:54 <IPI> is this linke legal ? bcd [x:xs] [zs] = bcd(xs [x:zs]) ??
23:01:58 <sjanssen> Excedrin: it isn't defined anywhere
23:02:01 <IPI> *line
23:02:21 <Excedrin> sjanssen: it must be in Plugin/Pl/Common.hs or somewhere
23:02:24 <ray> ipi: try and see
23:02:42 <IPI> doing it now :)
23:02:58 <sjanssen> IPI that could not possibly typecheck
23:03:43 <ray> yeah, that's true
23:03:55 <sjanssen> syntactically, I think it's legal
23:03:55 <ray> kinda hard to apply the tail of a list to something
23:03:57 <ray> usually
23:04:01 <sjanssen> always
23:04:08 <IPI> it doesn't work :(
23:04:22 <IPI> zs is list it self
23:04:42 <LoganCapaldo_> let bcd (x:xs) zs = bcd xs (x:zs)
23:04:50 <LoganCapaldo_> I dunno what that does
23:04:56 <dibblego> IPI, reverse xs = reverse' [] xs where reverse' accum [] = accum ...
23:05:39 <IPI> hmm...
23:05:52 <LoganCapaldo_> reverse [] = []; reverse (x:xs) = (reverse xs) ++ [x]
23:06:36 <IPI> ooh..
23:06:46 <dibblego> IPI, don't use that solution
23:06:48 <Excedrin> oh, that's revappend
23:07:23 <IPI> well doesn't LoganCapaldo_  solution's work?
23:07:56 <dibblego> it will reverse the list at least
23:08:09 <dibblego> you said your prolog solution uses an accumulator
23:08:14 <dibblego> there is a reason for this
23:08:14 <IPI> yes
23:08:44 <dibblego> that solution is not optimal
23:09:00 <LoganCapaldo_> how does it go, foldl (flip (:)) [] xs
23:09:21 <Excedrin> appendRev = flip $ foldl (flip (:))
23:10:20 <IPI> i need something simple to undrstand though ... :) its an exam question ... not a real life .. but i need the acc though .. :)
23:10:38 <dibblego> there's a page somewhere about a painter that does a great job on the first day, but his painting slowly denigrates as he has to keep walking further back to the bucket
23:10:56 <LoganCapaldo_> hehehhe
23:11:05 <dibblego> I cannot find it because google appears to be down
23:11:22 <dibblego> or it is my end
23:11:41 <ray> what a nice analogy
23:11:42 <LoganCapaldo_> Then there's the other painter who has a trough of paint encirling the room
23:11:59 <LoganCapaldo_> and just walks backwards ;)
23:12:05 <dibblego> is google really down?
23:12:09 <dibblego> I can hit everywhere but google
23:12:10 <ray> nope
23:12:18 <ray> it's up in all it's munchian glory
23:12:26 <dibblego> google.com.au?
23:13:01 * dibblego gives up and goes home
23:13:22 <IPI> google.com.au works fine :)
23:14:02 <LoganCapaldo_> > let xs = [1,2,3] in zipWith (!!) xs [(length xs - 1)..0]
23:14:04 <lambdabot>  add an instance declaration for (Num [a])
23:14:04 <lambdabot>   In the list element: 1
23:14:04 <lambdabot>   In...
23:15:00 <LoganCapaldo_> > let xs = [1,2,3] in map (uncurry (!!)) $ zip xs [(length xs - 1)..0]
23:15:01 <lambdabot>  add an instance declaration for (Num [a])
23:15:01 <lambdabot>   In the list element: 1
23:15:01 <lambdabot>   In...
23:15:10 <LoganCapaldo_> > [3..1]
23:15:11 <lambdabot>  []
23:15:15 <LoganCapaldo_> oooo
23:15:21 <Lemmih> > [3, 2 .. 1]
23:15:23 <lambdabot>  [3,2,1]
23:15:38 <ray> silly lambdabot
23:15:44 <Lemmih> > [8, 7 .. 1]
23:15:46 <lambdabot>  [8,7,6,5,4,3,2,1]
23:15:48 <LoganCapaldo_> > let xs = [1,2,3] in map (uncurry (!!)) $ zip xs [(length xs - 1),(length xs - 2)..0]
23:15:49 <lambdabot>  add an instance declaration for (Num [a])
23:15:49 <lambdabot>   In the list element: 1
23:15:49 <lambdabot>   In...
23:16:37 <LoganCapaldo_> > let xs = [1,2,3] in map (uncurry (!!)) $ zip xs (iterate (\x -> x - 1) (length xs - 1))
23:16:38 <lambdabot>  add an instance declaration for (Num [a])
23:16:38 <lambdabot>   In the list element: 1
23:16:38 <lambdabot>   In...
23:17:10 <LoganCapaldo_> take 3 $ iterate (-1) 3
23:17:16 <LoganCapaldo_> > take 3 $ iterate (-1) 3
23:17:17 <lambdabot>  add an instance declaration for (Num (a -> a))
23:17:31 <LoganCapaldo_> what am I missing here?
23:17:51 <Lemmih> > take 3 $ iterate (subtract 1) 3
23:17:53 <lambdabot>  [3,2,1]
23:18:02 <LoganCapaldo_> doh
23:18:05 <Lemmih> > -1 == negate 1
23:18:06 <lambdabot>  True
23:18:19 <LoganCapaldo_> > take 3 $ iterate ((-)1) 3
23:18:20 <lambdabot>  [3,-2,3]
23:18:39 <Lemmih> @pl flip (-)
23:18:40 <lambdabot> subtract
23:18:40 <LoganCapaldo_> > take 3 $ iterate (subtract 1) 3
23:18:42 <lambdabot>  [3,2,1]
23:19:25 <LoganCapaldo_> > let xs = [1,2,3] in map (uncurry (!!)) $ zip xs $ iterate (subtract 1) length $ xs - 1
23:19:26 <lambdabot>    Expecting a function type, but found `[a]'
23:19:27 <lambdabot>    Expected type: a -> b
23:19:27 <lambdabot>  ...
23:19:42 <LoganCapaldo_> > let xs = [1,2,3] in map (uncurry (!!)) $ zip xs $ iterate (subtract 1) (length xs - 1)
23:19:43 <lambdabot>  add an instance declaration for (Num [a])
23:19:44 <lambdabot>   In the list element: 1
23:19:44 <lambdabot>   In...
23:19:58 <LoganCapaldo_> > let xs = [1,2,3] in map (uncurry (!!)) $ zip xs (iterate (subtract 1) (length xs - 1))
23:19:59 <lambdabot>  add an instance declaration for (Num [a])
23:19:59 <lambdabot>   In the list element: 1
23:19:59 <lambdabot>   In...
23:20:09 <LoganCapaldo_> > let xs = [1,2,3] in zip xs (iterate (subtract 1) (length xs - 1))
23:20:11 <lambdabot>  [(1,2),(2,1),(3,0)]
23:21:06 <LoganCapaldo_> > let xs = [1,2,3] in map (xs !!) (iterate (subtract 1) (length xs - 1))
23:21:07 <lambdabot>  Exception: Prelude.(!!): negative index
23:21:37 <LoganCapaldo_> > let xs = [1,2,3] in map (xs !!) $ take (length xs) (iterate (subtract 1) (length xs - 1))
23:21:38 <lambdabot>  [3,2,1]
23:21:42 <LoganCapaldo_> wheee!
23:22:35 <LoganCapaldo_> @pl let xs = [1,2,3] in map (xs !!) $ take (length xs) (iterate (subtract 1) (length xs - 1))
23:22:36 <lambdabot> map ([1, 2, 3] !!) (take 3 (iterate (subtract 1) 2))
23:23:02 <LoganCapaldo_> @pl (\xs -> map (xs !!) $ take (length xs) (iterate (subtract 1) (length xs - 1)))
23:23:03 <lambdabot> liftM2 map (!!) (liftM2 take length (iterate (subtract 1) . subtract 1 . length))
23:23:33 <LoganCapaldo_> I have a bug report to file. @pl is broken. That should have went to reverse ;)
23:26:23 <sjanssen> LoganCapaldo_: reverse and your function are two different things
23:26:47 <sjanssen> nevermind, my argument is flawed
23:27:21 <sjanssen> I was going to point out that length doesn't terminate on an infinite list, but neither does reverse ;)
23:28:21 <ray> what if it's an infinite list where you know the last element
23:28:42 <LoganCapaldo_> > reverse [1,1..]
23:28:46 <lambdabot> Terminated
23:28:56 <ray> i think i'll meditate on that in bed.
23:33:36 <dons> ?users
23:33:36 <lambdabot> Maximum users seen in #haskell: 288, currently: 239 (83.0%), active: 23 (9.6%)
23:48:33 * Lemmih squashed his last space leak.
23:48:42 <IPI> how does one sends a message starting with * in irc ?
23:48:58 <dons> Lemmih: nice.
23:49:00 <IPI> just like what Lemmih done?
23:49:02 <dmead> ray: [x] ++ someinfinitelistfunction ++ [y]
23:49:09 <dmead> =)
23:49:10 <dons>  /me plays games
23:49:13 * dons plays games
23:49:23 <IPI> oh .. thanks dons
23:49:33 * IPI tryin it to see if it works
23:50:03 * IPI thanks ..
23:50:24 <dmead> hey dons
23:51:42 <Cale> ray: by definition, infinite lists have no last element
23:53:48 <dons> dmead: yeah?
23:54:45 <dmead> dons: i'm thinking it might be a good idea to contribute something useful for my project in the spring
23:54:56 <dmead> is there a list or something that'll be posted after the hackathon?
23:55:09 <dmead> i saw that the focus will be mainly practical stuff
23:56:08 <dons> yeap exactly
23:56:25 <dons> there's a preliminary list of tasks to work on the hac page
23:56:54 <dmead> ahh
23:57:12 <dons> ?wiki Hac_2007
23:57:13 <lambdabot> http://www.haskell.org/haskellwiki/Hac_2007
23:59:09 <greentea> i'm trying to tidy up the production of docs for -package HTTP, and having some trouble because i don't the base.haddock file isn't included in my GHC package. What's my best move from here?
23:59:46 <greentea> er, s/i don't//
