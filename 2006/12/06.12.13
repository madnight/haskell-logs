00:00:51 <dons> what trouble does that cause?
00:01:01 <dons> (isn't it just a bogus haddock complaint you'll get?)
00:01:11 <dons> but the docs will till be generated
00:02:25 <greentea> Well, i get a warning about certain names not being resolved.
00:02:41 <dons> yeah, that's harmless
00:02:44 <Excedrin> why aren't finite and infinite lists seperate types? It seems that if they were different types, it would be possible to define functions that don't make sense on infinite lists as undefined to raise an exception instead of not terminating...
00:02:48 <dons> we should really patch haddock to not complain so much
00:03:04 <dons> Excedrin: flexibility
00:03:13 <sjanssen> Excedrin: sometimes we don't know whether a list is finite
00:03:14 <dmead> hmm
00:03:22 <dmead> I thought you were english dons?
00:03:28 <dons> no?
00:03:32 <dmead> =P
00:03:32 <greentea> Oh, okay. Or make it so that those complaints only appear as a result of -Wall or something. :-)
00:03:35 <dmead> weird
00:03:41 <dmead> my advisor is from melborne
00:04:07 <sieni> Excedrin: lazy evaluation kind of makes it impossible in general to determine algorithmically whether you have a finite or infinite list at hand
00:04:35 <greentea> dons: Thanks for the heads-up. :-)
00:04:43 <Cale> sjanssen has it right. You tend to not want to pin yourself down to only working with infinite lists, or only working with finite lists. It gives you an extra amount of flexibility later to be able to work with both simultaneously.
00:05:00 <zeeeee> ?pl (\x y -> fst x <= fst y)
00:05:01 <lambdabot> (. fst) . (<=) . fst
00:05:06 <Excedrin> right, but sometimes while you're writing a program, you know that some list will be one or the other, so shouldn't you be able to type things that way to avoid misuse?
00:05:48 <dmead> Excedrin: I ran into that issue myself
00:05:49 <Cale> Excedrin: also, there's little practical difference between an infinite list and one which is just extraordinarily long
00:06:01 <dmead> seems like you can always change to a finite one
00:06:17 <dmead> brb
00:06:18 <dmead> rawr
00:06:42 <Cale> You kind of have to be able to solve the halting problem to determine whether a list is finite, unless you just make the list type strict.
00:07:38 <Cale> Of course, even if you do make it strict, you'll be able to write the same code as for infinite lists, it'll just run forever right away.
00:07:46 <sjanssen> in which cases there are no infinite lists
00:07:52 <dons> :t \x y -> liftM2 fst x y
00:07:54 <lambdabot> forall b a2 r (m :: * -> *). (Monad m) => m (a2 -> r, b) -> m a2 -> m r
00:08:09 <Korollary> in a strict language there is not necessarily lists that you know are finite. For instance, you may have mylist = yourfunction. How do you know yourfunction terminates?
00:08:15 <Excedrin> I know that all lists created by [x..y] are finite, why shouldn't they be typed accordingly?
00:08:42 <Cale> Excedrin: Prove it in the typesystem.
00:08:54 <Cale> Yes, in languages like Epigram you can do that.
00:10:03 <Excedrin> along those lines, if there was a function length2 that returns Just length for finite lists and Nothing for lists that end with a thunk without evaluating it, I think it would be useful
00:10:11 <Cale> But the Damas-Milner typesystem is much less expressive than you'd want in order to be able to write down a proof that some function always gives a finite list. It might be doable with all the typesystem extensions in GHC, but it would be quite a pain.
00:10:39 <Cale> Excedrin: what about finite lists that end with a thunk?
00:10:43 <sjanssen> Excedrin: that function would break referential transparency
00:10:52 <Cale> right
00:11:22 <Korollary> Is such a function an oracle? How does it know whether it terminates without running?
00:11:51 <Excedrin> it wouldn't if a list that ended with a thunk was more visible to the programmer
00:12:12 <Cale> huh?
00:12:15 <sjanssen> let x = () : (makeThunkOutOf []) in length2 x `seq` tail x `seq` length2 x -- length2 will report different results
00:12:47 <astrolabe> I think sometimes you know a list is infinite, and it would be nice to have the type system enforce that.
00:13:03 <Cale> astrolabe: that on the other hand is easy
00:13:16 <Excedrin> sjanssen: right, but in that case you're mutating x between the two length2 calls
00:13:17 <Cale> data Stream a = Cons a (Stream a)
00:13:43 <sjanssen> Excedrin: values don't mutate in Haskell
00:14:29 <astrolabe> Cale: yeah, I agree, I just want it built in, and with (:) and (..) etc available.
00:15:18 <Excedrin> lazy lists obviously do mutate, in the first instance, it's a thunk (undef length) and in the second, it's [] since it's been evaluated
00:15:41 <sjanssen> Excedrin: thunk updates happen, but that is just an implementation detail
00:15:44 <Cale> astrolabe: (:) is the major problem with that as it stands.
00:15:55 <sjanssen> totally unacceptable to expose that to the user
00:16:07 <Cale> Excedrin: you're not supposed to be able to observe the implementation in that way
00:16:28 <Cale> Also, there's nothing in the spec which guarantees lazy evaluation. Only nonstrict semantics are guaranteed.
00:16:37 <Excedrin> why not? it seems like it would make it easier to reason about performance and space in some situations
00:17:01 <Cale> Excedrin: It breaks compiler optimisations all over the place.
00:17:31 <Cale> Also, it breaks referential transparency, which is something extremely valuable when reasoning about code.
00:17:48 <Cale> It's what lets you use the equational reasoning that you learned in mathematics classes.
00:18:21 <Cale> Wherever I see f x, I can substitute the definition of f or the definition of x and get something which is equal.
00:19:16 <_matthew-> seeing as Epigram just got mentioned, are any of you involved with Omega?
00:20:24 <Cale> not me, but I think it's cool
00:20:58 <_matthew-> mmm. I've spent the last month working in Epigram and I just find the Omega syntax so confusing
00:21:22 <_matthew-> Epigram you can just read. It just makes sense. I find it *so* much harder to read Omega
00:22:16 <_matthew-> OTOH, Epigram's interface is clunky and you really have to define everything yourself. At least with Omega you get decent basic libraries...
00:23:39 <Cale> I haven't had much experience with it to know, but Omega strikes me as being a little closer to Haskell in the design space than Epigram.
00:24:22 <_matthew-> oh definately. Epigram is more a theorem prover that happens to have some programming language features
00:24:28 <Cale> right
00:24:47 <Cale> Perhaps there's a point where the syntactical conventions become awkward as you move toward theorem prover from Haskell.
00:24:51 <_matthew-> Omega is haskell minus classes, plus(?) gadts and index types
00:26:27 <_matthew-> yeah, the natural deduction style of epigram is quite easy to read. And it has quite pictorial representation which helps too.
00:26:48 <_matthew-> Omega seems to use too much syntax, but then I probably think that of haskell anyway...
00:27:44 <Cale> hmm
00:28:39 <Cale> Is it that there's too much sugar that you haven't become adjusted to yet, or that the chosen syntax is overly explicit?
00:28:48 <_matthew-> sugar I think
00:30:43 <_matthew-> it's just little things. Like when writing functions that operate on values, the signature of the function uses ->. When writing functions that operate on any higher level, the signature uses ~>. Now I appreciate that they want a clean separation between the different levels...
00:30:49 <Cale> Usually I'm willing to forgive the use of sugar up until I become fairly comfortable in the language and I'm really able to see whether it's convenient or aids reading or not. It's true that it tends to raise the bar for beginners though.
00:31:06 <Cale> oh, right, that's sort of odd.
00:31:17 <Cale> That's an example of possibly being too explicit.
00:31:41 <Cale> That is, you're having to take care of a detail which you consider to be irrelevant.
00:31:53 <_matthew-> ...but in Epigram, where they don't care about the separation, it's just an easier mental map as you can treat all functions the same: they operate on "values" whether those values are _|_values_|_, types, kinds, sorts, whatever
00:32:14 <Cale> right
00:32:33 <Cale> In this case, I think they could even keep the levels separate while using -> on every level.
00:33:41 <_matthew-> mmm. Although, given that most of the time they're working at the lowest 2 levels, given they enjoy separate namespaces so they define Nat and Nat' to be at kind and type level respectively, but with the same constructors,
00:34:03 <_matthew-> it may look terrifying to see foo :: Nat' -> Nat' -> Nat' and foo' :: Nat -> Nat -> Nat
00:34:35 <_matthew-> and not know from seeing that foo takes values classified by Nat' and foo' takes types classified by the kind Nat
00:34:45 <_matthew-> syntax is *so* hard to get right though
00:37:00 <Cale> What's good syntax for one group of people might be terrible syntax for another, as well.
00:37:29 <_matthew-> sure. Inevitably you want to see stuff that's close to what you already are comfortable with
00:37:32 <mattam> what's the point of having two nats at different levels ?
00:38:15 <mattam> no sorts subtyping in epigram ?
00:38:16 <Cale> It's all about what you're hiding in the syntax, and what's being made explicit. The syntax becomes annoying if it hides something that you're concerned with, or if it makes explicit something that you're not concerned with.
00:38:47 <_matthew-> mattam: you can track the length of lists in the type of the list
00:39:11 <mattam> yeah i know that (i develop a Coq extension)
00:39:30 <_matthew-> mattam: Apologies. :) In Epi, this means one definition of Nat as you can use values to parameterise types
00:39:46 <_matthew-> you can't do that in Omega because of the index types rather than dependent types
00:39:49 <mattam> the nat in 'vector n' is the same i use to define plus
00:40:03 <_matthew-> right. Not in Omega though
00:40:23 <_matthew-> as you can only use stuff in the level above to parameterise stuff at the current level
00:40:25 <mattam> hmm, omega has a simpler type algebra for index types (presburger i guess) ?
00:40:55 <_matthew-> mattam: I'm not au fait with the theory yet, but yes, index types are simpler than dependant types, is about the extent of my understanding
00:41:03 <mattam> i've read a paper but I can't remember
00:41:21 <_matthew-> so you have to redefine Nat as a kind and then Zero and Succ as types
00:41:32 <_matthew-> which also means you have to redefine plus and so forth
00:41:52 <_matthew-> but it keeps things simpler and, keep machinery separate, at the cost of code duplication
00:42:37 <_matthew-> mattam: Omega papers at http://web.cecs.pdx.edu/~sheard/
00:42:38 <lambdabot> Title: Tim Sheard's home page
00:44:18 <mattam> right, i read Languages of the Future but it doesn't get into Omega details
00:44:44 <_matthew-> I'm currently reading the narrowing one
01:22:52 <dons> ?users
01:22:53 <lambdabot> Maximum users seen in #haskell: 288, currently: 240 (83.3%), active: 20 (8.3%)
01:23:55 <ski> @bork
01:32:53 <dons> ?pl concat . reverse . groupBy ((==) `on` isSpace)
01:32:54 <lambdabot> join . reverse . groupBy ((==) `on` isSpace)
01:33:44 <ski> @type on
01:33:45 <lambdabot> Not in scope: `on'
01:35:43 <dons> ghc 6.6
01:36:05 <dons> ?let (*) `on` f = \x y -> f x * f y
01:36:06 <lambdabot> <local>:8:4:     Multiple declarations of `L.on'     Declared at: <local>:2:3...
01:36:24 <ski> @type L.on
01:36:26 <lambdabot> Couldn't find qualified module.
01:36:52 <dons> I don't have a strategy for exposing L.hs qualifed in ghci
01:36:54 <dons> any ideas?
01:36:54 <ski> hm .. shouldn't 'type' see things in 'L' ?
01:37:12 <ski> mhm
01:37:39 <dons> it could, but I haven't worked out a nice way to do that
01:37:42 <dons> other than to expose them unqualified
01:37:49 <dons> (maybe that's ok though)
01:38:03 <dons> and maybe I don't need the L.* prefix stuff anyway
01:55:27 <huschi_> @pl (\mat n -> entries mat !! n)
01:55:28 <lambdabot> (!!) . entries
01:56:41 <dons> :)
01:56:55 <dons> oh, do you mean:
01:57:04 <dons> @pl (\mat n -> entries (mat !! n))
01:57:05 <lambdabot> (entries .) . (!!)
01:57:20 <huschi_> nono, i meant it that way.
01:57:38 <dons> @pl (\mat n -> (entries mat) !! n)
01:57:39 <lambdabot> (!!) . entries
01:58:06 <huschi_> @pl (\mat n -> map (!!n) $ entries mat)
01:58:07 <lambdabot> flip (map . flip (!!)) . entries
02:07:26 <huschi_> @pl (\mat n -> make $ entries mat !! n)
02:07:27 <lambdabot> (make .) . (!!) . entries
02:21:21 <robreim> Is it just me or is reddit down?
02:22:51 <dons> looks down to me
02:23:17 <robreim> ah k. Tah.
02:31:15 <robreim> Hmm... I suppose I need mingw / cygwin in order to use cabal on windows?
02:33:46 <dons> don't think so
02:33:50 <dons> (why would you?)
02:34:10 <dons> double check with ndm, but pretty certain you won't need it
02:48:46 <vincenz> Anyone know how to forward a request to site xxx automatically through a tunnel
02:49:33 <integral> If the "tunnel" is just a network interface, you could use kernel routing tables.
02:50:08 <vincenz> Sounds difficult
02:50:40 <integral> meh, it's non-theoretical computer stuff, it's overcomplicated by design.
02:51:18 <integral> (I mean, GHC manages to have an incredibly advanced type system successfully,  but the -dynamic link option still doesn't work...)
02:52:44 <dons> integral: works on the mac ;)
02:53:22 <pejo> Does it work on darwin/x86 too?
02:53:31 * integral wouldn't know after his ate its hard disk
03:01:44 <psnl> vincenz: just put in a route for the sites IP to the tunnel
03:06:52 <huschi_> @pl \x -> x*x
03:06:53 <lambdabot> join (*)
03:08:04 <integral> @pl \f x -> f x x
03:08:04 <lambdabot> join
03:08:42 <huschi_> to my mind this makes the code less readable :)
03:09:04 <huschi_> and furthermore i would need another import fpr the ((->) r) monad.
03:10:29 <dons> yes, and yes :) use the force wisely
03:11:02 <integral> Is there something with the ((->)r) monad?
03:11:23 <dons> mm?
03:11:33 <dons> "somethiing with"?
03:12:07 <integral> "i would need another import fpr the ((->) r) monad" -- Control.Monad.Reader only has the horrible one with a newtype around it
03:13:03 <dons> nono, its in Control.Monad.Instances (and Reader too)
03:13:19 <dons> instance Monad ((->) r) where
03:13:20 <dons>     return = const
03:13:20 <dons>     f >>= k = \ r -> k (f r) r
03:13:26 <dons> module Control.Monad.Instances ..
03:13:30 <integral> oooh, I hadn't spotted that, cool
03:32:18 <mq_mattr> I was just looking over the ddump flags in ghc and noticed that the pdf of the ghc users guide is a bit mucked up.  Text goes over the top of other bits and some text is missing.  The HTML version is great.  I guess it doesn't matter, but I thought I might see if others have the same experience or if it is a mac-only (or a matt-only) issue.
03:37:45 <mq_mattr> quiet
03:48:32 <greentea> mq_mattr: Latest version of GHC?
03:48:45 <mq_mattr> yeah - and the previous one.
03:48:58 <greentea> i'll have a look now.
03:49:27 <dons> mq_mattr: hmm, haven't seen that.
03:49:36 <dons> mq_mattr: file a report perhaps?
03:49:46 <dons> (the file is generated straight out of sgml
03:49:56 <mq_mattr> I have tried with Preview and the latest Acrobat
03:50:01 <dons> ?bug <-- would be one option
03:50:01 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
03:50:11 <mq_mattr> dons: I guessed it was autogenerated.
03:50:17 <mq_mattr> will do
03:53:34 <greentea> What page is the problem on?
03:54:30 <robreim> Sorry, my computer played up on me earlier. The reason I asked about mingw and cygwin with cabal on windows is that cabal seems to be complaining about not being able to find sh.exe.
03:56:15 <greentea> i'm looking at pages 50 and 51 of the latest guide with Evince, and it's fine.
04:04:22 <greentea> It's also fine on page 44 of the 6.4.2 user guide.
04:05:03 <SamB_XP> robreim: what package were you trying to build?
04:10:37 * SamB_XP wonders if Tvar (Maybe a) is analogous to MVar a
04:16:04 * SamB_XP thinks Haddock maybe ought to hide instances by default when there are a lot of them
04:18:14 <robreim> SamB_XP: hs-plugins
04:22:15 <profmakx> wth happened to reddit?
04:22:40 <SamB_XP> it, um, went down apparantly!
04:23:30 <profmakx> theres no dns-entry anymore even -.-
04:25:23 <SamB> for programming.reddit.com, or reddit in general?
04:26:03 <SamB> @where reddit
04:26:03 <lambdabot> I know nothing about reddit.
04:26:07 <robreim> reddit in general. Strange since it's not due to expire until 2008 and the last change to the registrar was 2 days ago.
04:26:11 <SamB> @google reddit
04:26:12 <lambdabot> http://reddit.com/
04:27:29 <psi_> wow, another psi, and he's also named simon, apparently.
04:40:28 <robreim> aha! found a work around: change defaultMainWithHooks to defaultMain in Setup.lhs to get hs-plugins to configure in windows :)
04:47:05 <robreim> But that breaks config.h... *continues hunting IRC logs*
05:01:17 <ElMaia> Hi
05:02:05 <ElMaia> I'm receiving a error from GHCi
05:02:11 <ElMaia> ?paste
05:02:11 <lambdabot> http://paste.lisp.org/new/haskell
05:03:29 <lisppaste2> ElMaia pasted "Error" at http://paste.lisp.org/display/32276
05:04:05 <ElMaia> Someone can help me ?
05:05:52 <ventonegro> will say what's the error? :-)
05:07:03 <ElMaia> parse error on input |
05:07:32 <ventonegro> ElMaia, maybe it's identation?
05:08:03 <ElMaia> [ ventonegro ]: I tried, but doesnt work
05:10:29 <ventonegro> 24:    | (goodness c) && (even (length c)) = 0!!(filter f c) where
05:10:42 <ventonegro> shouldn't it be (filter f c) !! 0?
05:11:16 <ventonegro> @type (!!)
05:11:18 <lambdabot> forall a. [a] -> Int -> a
05:11:26 <ElMaia> ops... let me tray
05:12:20 <ElMaia> ventonegro : No... same error
05:12:25 <ventonegro> you could also use head $ filter f c
05:12:30 <ventonegro> @type head
05:12:32 <lambdabot> forall a. [a] -> a
05:13:03 <ElMaia> ventonegro : Using head ... same error
05:13:10 <Syzygy-> @type !!
05:13:12 <lambdabot> parse error on input `!!'
05:13:15 <Syzygy-> @type (!!)
05:13:17 <lambdabot> forall a. [a] -> Int -> a
05:13:21 <Syzygy-> @type (!!5)
05:13:23 <lambdabot> forall a. [a] -> a
05:13:30 <ElMaia> Syzygy- same error
05:13:38 <Syzygy-> ElMaia: Wha?
05:13:53 <ElMaia> Syzygy- sorry
05:14:09 <Syzygy-> ElMaia: I haven't yet looked at your question. :P
05:14:34 <ElMaia> [ ventonegro ]: Do you want to see whole file ?
05:14:38 <ElMaia> ?paste
05:14:39 <lambdabot> http://paste.lisp.org/new/haskell
05:14:57 <ventonegro> ElMaia, are you sure ghci does not give you the line of the error?
05:15:22 <ElMaia> [ ventonegro ]: Yeah ... 77, but I cant see problem there
05:16:28 <lisppaste2> ElMaia pasted "NIM" at http://paste.lisp.org/display/32278
05:16:41 <ElMaia> [ ventonegro ], ready
05:16:44 <ElMaia> whole code
05:16:51 <ElMaia> cant you see for me ?
05:17:26 <ventonegro> heh
05:17:30 <ventonegro> ElMaia, Brazilian?
05:17:39 <ElMaia> [ ventonegro ]: Yeah
05:17:57 <Syzygy-> The error comes on the first | after a where clause.
05:18:14 <Syzygy-> When I comment out the first two lines with a where, the error pops up oon the next.
05:18:15 <ElMaia> Syzygy- , and how to fix ?
05:18:30 <Syzygy-> Hmmm. try to put one where clause after it all. It is the same anyway.
05:19:04 <ventonegro> but of course
05:19:23 <ventonegro> unlike let's, the scope of the where is the whole guarded expression
05:19:24 <lisppaste2> Syzygy- annotated #32276 with "Better" at http://paste.lisp.org/display/32276#1
05:19:36 <ElMaia> Syzygy- thanks
05:19:40 <fasta> I have the equivalent of f i a = g l i a in my program, but when I delete the i a parameters, it doesn't work anymore.
05:19:40 <ElMaia> work now
05:19:43 <Syzygy-> I got errors on not knowing Stars with that one.
05:19:53 <fasta> It should get a curried version of the function.
05:20:17 <fasta> I guess the currying only works in Haskell98?
05:20:45 <ElMaia> [ ventonegro ], thanks a lot too
05:20:57 <fasta> Hmm, I can curry it on one parameter:
05:21:07 <ventonegro> ElMaia, np
05:21:08 <fasta> f i = g l i
05:21:27 <fasta> Inconsistencies ...
05:22:41 <fasta> Hmm, when I add a type signature it does work..
05:25:39 <kosmikus> sounds like monomorphism restriction to me
05:33:13 <Cale> Yeah, that's the MR
05:33:52 <fasta> Cale: odd that it isn't reported then.
05:35:14 <fasta> It was the MR.
05:39:13 <fabiim> map (\x -> if isAlpha(x) then toUpper(x) )
05:39:27 <fabiim> what's the deal with if's inside lambda instructions?
05:39:58 <fabiim> it doesn't work ... : parse error on input ')'
05:40:20 <flux__> add an else-branch?
05:40:23 <dons> > map (\x -> if isAlpha x then toUpper x else x) "hask213ell"
05:40:24 <lambdabot>  "HASK213ELL"
05:41:23 <fabiim> >map (\x -> if isAlpha x then toUpper x) "hasda"
05:41:25 <ventonegro> not only inside lambdas
05:41:37 <dons> > map (\x -> if isAlpha (x) then ((toUpper))(x) else((x))) "hask213ell" -- the parens do nothing! :)
05:41:39 <lambdabot>  "HASK213ELL"
05:41:54 <dons> fabiim: you always need an else branch
05:42:07 <dons> (\x -> if isAlpha x then toUpper x else x) 'a'
05:42:11 <fabiim> oh !
05:42:12 <dons> > (\x -> if isAlpha x then toUpper x else x) 'a'
05:42:13 <lambdabot>  'A'
05:42:23 <dons> > (\x -> if isAlpha x then toUpper x else x) '0'
05:42:24 <lambdabot>  '0'
05:42:29 <fabiim> that was the problem ...
05:42:56 <fabiim> tks
05:43:23 <Pastorn> how do i do "abcd" -> "a b c d" ?
05:43:39 <ventonegro> fabiim, what would be the value of 'if (isAlpha c) then (toUpper c)' if c was not alphabetic?
05:43:40 <dons> > concat . intersperse " " $ "abcd"
05:43:41 <lambdabot>  Couldn't match `[Char]' against `Char'
05:43:47 <dons> > concat . intersperse ' ' $ "abcd"
05:43:48 <lambdabot>  Couldn't match `[a]' against `Char'
05:43:48 <Pastorn> i was thinking about map (x:' ')
05:43:53 <ventonegro> fabiim, every expression must have a valut
05:43:54 * dons is sleepy
05:43:59 <Pastorn> but that didn't work too well :/
05:44:11 <earthy> then go to sleep, dons
05:44:19 <Pastorn> no dons
05:44:19 <fabiim> ventonegro: None
05:44:22 <Pastorn> help me
05:44:24 <dons> > intersperse ' ' "abcd"
05:44:26 <lambdabot>  "a b c d"
05:44:32 <Pastorn> cool!
05:44:40 <Pastorn> thanks :D
05:44:47 <ventonegro> fabiim, you mean bottom? there is no such value "none"
05:44:48 <earthy> that was simple
05:44:52 <dons> i've got intercalate on the brain ;)
05:45:05 <earthy> yea, but that's not in the libs yet
05:45:34 <fabiim> ventonegro:  lol , i don't know what bottom means , i want to do this : foo "abcdd2938123 3$/()(/" = "ABCDD"
05:46:04 <ventonegro> fabiim, i was just trying to explain why every if needs an else branch
05:46:25 <dons> > filter isAlpha "abcdd2938123 3$/()(/" -- hint!
05:46:27 <lambdabot>  "abcdd"
05:46:30 <ventonegro> anyway, you should know what bottom is if you wanna use haskell :-)
05:46:35 <earthy> > let foo = map toUpper . filter isAlpha in foo "abcdd2938123 3$/()(/"
05:46:36 <earthy> maybe?
05:46:36 <lambdabot>  "ABCDD"
05:46:47 <dons> sound like a homework question ;)
05:46:52 <fabiim> ventonegro: ok , but the in these case else doesn't have to do anything
05:47:08 <earthy> this is the type of homework question I give the students the answer to for free. ;)
05:47:24 <ventonegro> fabiim, so the else branch should evaluate to the initial value
05:47:28 <earthy> and then I ask: now do it differently. :)
05:47:34 <ventonegro> anyway, the filter solution is much better
05:47:37 <fabiim> dons : i already did map toUpper after filter isAlpha
05:47:58 <fabiim> but i was thinking , why should i evaluate the same list twice?
05:48:20 <earthy> you aren't. :)
05:48:25 <fabiim> and i'm trying to do it at once
05:49:38 <norp> this is haskell, everything is done at once
05:49:48 <fabiim> what can i do with else then? map (\x -> if isAlpha x then toUpper x else ??? )
05:49:53 <ventonegro> norpan, at once?
05:50:07 <norpan> well, not at once, but simultaneously :)
05:50:12 <fabiim> ventonegro:  how can i evaluate to the initial value ?
05:50:14 <norpan> at least conceptually
05:50:14 <ventonegro> norpan, :-)
05:50:21 <fabiim> by the way , what's does that mean lol
05:50:23 <ventonegro> fabiim, itself?
05:50:32 <ventonegro> \x -> x
05:50:38 <ventonegro> anyway, use filter
05:50:48 <earthy> > let bar [] = []; bar (x:xs) = if isAlpha x then (toUpper x:bar xs) else bar xs in bar "abcdd2938123 3$/()(/"
05:50:49 <lambdabot>  "ABCDD"
05:50:54 <norpan> you can do concatMap (\x -> if isAlpha x then [toUpper x] else [])
05:51:26 <norpan> > concatMap (\x -> if isAlpha x then [toUpper x] else []) "abcdd2938123 3$/()(/"
05:51:27 <lambdabot>  "ABCDD"
05:51:44 <earthy> lol == laughs out loud
05:52:09 <norpan> or lots of laughs
05:52:45 <ventonegro> omg!!11!! Ponnies!
05:53:01 <ventonegro> (slashdot style)
05:53:11 <fabiim> ok tks .
05:53:12 <fabiim> =)
05:53:35 <dons> > map (\x -> if isAlpha x then Just (toUpper x) else Nothing) "abc123"
05:53:37 <lambdabot>  [Just 'A',Just 'B',Just 'C',Nothing,Nothing,Nothing]
05:53:55 <ventonegro> @type maybes
05:53:56 <lambdabot> Not in scope: `maybes'
05:53:57 <dons> >  catMaybes $ map (\x -> if isAlpha x then Just (toUpper x) else Nothing) "abc123"
05:53:58 <lambdabot>  "ABC"
05:54:38 <ventonegro> is there a generic cat for MonadPlus?
05:55:16 <dons> mconcat in Monoid?
05:55:34 <ventonegro> @type mconcat
05:55:36 <lambdabot> Not in scope: `mconcat'
05:55:43 <ventonegro> @type Monoid.mconcat
05:55:45 <lambdabot> Couldn't find qualified module.
05:55:55 <ventonegro> @hoogle mconcat
05:55:56 <lambdabot> Data.Monoid.mconcat :: Monoid a => [a] -> a
05:56:32 <dons> ?hoogle mconcat
05:56:33 <lambdabot> Data.Monoid.mconcat :: Monoid a => [a] -> a
05:56:35 <Igloo> http://people.debian.org/~igloo/popcon-graphs/index.php?packages=libghc6-gtk-dev%2Clibghc6-mtl-dev&show_installed=on&want_legend=on&beenhere=1 - quite a cute visualisation of what happens if you don't support the latest GHC
05:56:37 <lambdabot> Title: popcon graph, http://tinyurl.com/vmk3c
05:57:16 <Igloo> But hsplugins seems completely unaffected, interestingly
05:59:57 <dons> what are we looking at there, Igloo ?
06:00:02 <dons> bug reports?
06:00:30 <Igloo> dons: Number of people who have hte package installed (and also have popularity-contest installed)
06:01:08 <dons> so the green mtl thread shows people installing the extralibs package?
06:01:20 <Igloo> Yes (which didn't exist before GHC 6.6)
06:01:33 <dons> right. so that tells us who's using 6.6. very interesting!
06:07:44 <Pastorn> @type intersperse
06:07:45 <lambdabot> forall a. a -> [a] -> [a]
06:08:08 <Pastorn> @source intersperce
06:08:08 <lambdabot> intersperce not available
06:08:17 <Pastorn> @source intersperse
06:08:18 <lambdabot> intersperse not available
06:08:41 <dons> ?hoogle intersperse
06:08:41 <lambdabot> List.intersperse :: a -> [a] -> [a]
06:08:45 <dons> ?docs Data.List
06:08:45 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
06:08:48 <dons> ?source Data.List
06:08:49 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
06:08:52 <Pastorn> danke =)
06:10:34 <chessguy> @hoogle [a] -> [a] -> [a]
06:10:35 <lambdabot> Prelude.(++) :: [a] -> [a] -> [a]
06:10:35 <lambdabot> List.intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
06:10:35 <lambdabot> List.unionBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
06:11:24 <chessguy> hmm. is there a built-in way, if i have two lists a and b, to remove from a all occurrences of anything in b?
06:11:24 <lambdabot> chessguy: You have 1 new message. '/msg lambdabot @messages' to read it.
06:11:58 <dons> ?hoogle (\\)
06:11:59 <lambdabot> Did you mean: (\\)
06:11:59 <lambdabot> Prelude.undefined :: a
06:11:59 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
06:12:01 <dons> ?hoogle \\
06:12:01 <lambdabot> Hoogle Error: Parse Error: Unexpected character '\\'
06:12:08 <dons> :t (\\)
06:12:09 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
06:12:12 <chessguy> ohh, stupid me
06:12:21 <dons> > "abcdef" \\ "ab"
06:12:23 <lambdabot>  "cdef"
06:12:40 <dons> @hoogle [a] -> [a] -> [a]
06:12:40 <lambdabot> Prelude.(++) :: [a] -> [a] -> [a]
06:12:41 <lambdabot> List.intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
06:12:41 <lambdabot> List.unionBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
06:12:42 <dons> ?hoogle+
06:12:43 <lambdabot> Data.List.deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
06:12:43 <lambdabot> Prelude.zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
06:12:43 <lambdabot> List.(\\) :: Eq a => [a] -> [a] -> [a]
06:12:50 <dons> ah , there it is :)
06:15:12 <chessguy> thanks
06:15:51 <chessguy> this is a bugger of a math problem. i should write a wiki article on all the haskell crap i've written to help me with this problem over the last 6 weeks
06:26:48 <Itkovian> chessguy: one address: TMR
06:26:57 <chessguy> huh?
06:27:06 <fasta> Are assocaciated types implemented in GHC?
06:27:15 <fasta> er associated
06:27:45 <chessguy> Itkovian, what's that?
06:28:27 <roconnor> @what TMR
06:28:27 <lambdabot> http://www.haskell.org/tmrwiki/FrontPage
06:28:48 <Itkovian> there ya go
06:29:07 <chessguy> aha
06:29:50 <chessguy> for a minute i thought you were telling me to put the reader monad in my app before you even knew what it was :)
06:31:05 <chessguy> how hard is it to tell if two lists are the same, just with some terms rearranged
06:31:21 <Pastorn> howcome the function 'intercalate' is in Data.List but not documented?
06:31:42 <ropine> chessguy: use Data.Set?
06:31:53 <Syzygy-> ?t intercalate
06:31:53 <lambdabot> Maybe you meant: tell time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
06:32:00 <Syzygy-> ?type intercalate
06:32:02 <lambdabot> Not in scope: `intercalate'
06:32:16 <chessguy> ropine, i figured i could do that, but i wondered how hard it is
06:32:20 <Pastorn> @source Data.List
06:32:21 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
06:32:26 <Pastorn> check there
06:33:04 <chessguy> i'm thinking it's like like O(Min{|a|^2,|b|^2})
06:33:25 <Itkovian> well now
06:33:33 <Itkovian> look who just popped in
06:33:41 <chessguy> or i guess i could say O(Min{|a|,|b|}^2)
06:35:55 <ropine> unsortedEq xs ys = let xSet = Set.fromList xs in (and [member y xset | y <- ys])
06:35:57 <chessguy> ?doc Data.Set
06:35:57 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Set.html
06:37:38 <dionoea_work> Anyone spot obvious simplifications to this small "wrap" function: http://pastebin.ca/277688 ? (I'm trying to make it as small and simple as possible ...)
06:39:53 <dionoea_wrk> gra...
06:40:48 <ropine> the set constructor is O(n log n) and the membership function is O(log n), so unsortedEq would be O((|xs|+|ys|) log (|xs|))
06:43:36 <chessguy> maybe i could improve it by using sets instead of lists all along
06:43:44 <chessguy> that's gonna require some serious rewrite though
06:45:20 <chessguy> what's the difference between Data.Set.map and Data.Set.mapMonotonic
06:45:40 <chessguy> oh, it's described, sorry
06:50:13 <lisppaste2> Pastorn pasted "IO is the shit" at http://paste.lisp.org/display/32283
06:50:57 <Pastorn> it seems to be very simple, i just can't understand why one of them doesn't work...
06:50:59 <integral> Pastorn: You need to learn about the "return" combinator.
06:51:14 <Pastorn> integral: please annote
06:51:19 <integral> annote?
06:51:32 <integral> I don't understand?  I'm, umm, talking to you?
06:51:32 <Pastorn> *annotate*
06:51:45 <integral> What do you mean?
06:51:59 <Pastorn>  = fix the code and press the annotate button
06:52:08 <ropine> "x <- y" within a do-block is not the same as "let x = y"
06:52:39 <vincenz> nope
06:52:41 <ropine> also you mean to say "putStr y" instead of "putStr x" there, right?
06:52:44 <Pastorn> oh, how do they differ
06:52:47 <vincenz> x <- y executes the y action
06:53:00 <Pastorn> ropine:  yeah
06:53:02 <integral> Oh, I was going to tell you why you need return. *sigh*
06:53:48 <ropine> if you imagine a monad as a sort of wrapper, "<-" within a do-block takes the contents out of the wrapper so you can do stuff with it and "return" puts it back in the wrapper
06:54:07 <ropine> "let" does straight assignment without unwrapping
06:54:08 <Pastorn> riiiight! 'x <-' does an IO a action and stores a in x
06:56:04 <ropine> if y is an IO action like "getStr" then "x <- y" does the action and puts the result in x
06:56:54 <ropine> if y is a Maybe type then "x <- y" either gets the contents of y or makes the whole do-block return Nothing, depending on whether y is "Just y'" or "Nothing"
06:57:11 <ropine> if y is a list then "x <- y" lets you treat x as a single element of the list
06:57:26 <sieni> http://lehti.samizdat.info/2006/12/10/1843/
06:57:30 <lambdabot> Title: Lehti Â» Raportti todistaa: Dianan kuolemalla ei merkitystä
06:57:38 <Pastorn> what element would that be?
06:57:38 <ropine> etc etc etc
06:57:49 <Pastorn> head y?
06:57:58 <ropine> ah, but that's the beauty of it, you see
06:58:26 <ropine> > do { x <- [0, 1, 2, 3, 4] ; return (x * 2) }
06:58:33 <lambdabot>  [0,2,4,6,8]
06:58:34 <ropine> @help
06:58:36 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
06:58:48 <Pastorn> niiiice
06:59:07 <fasta> What happened to Data.Graph.Inductive and where do I get it?
06:59:12 <Pastorn> btw, why the {}?
06:59:19 <ropine> so I can put everything on one line
06:59:27 <Pastorn> oh
07:00:14 <fasta> > [0..4] >>= (*2)
07:00:15 <lambdabot>  add an instance declaration for (Num [b])
07:00:46 <fasta> > [0..4] >>= return . (*2)
07:00:47 <lambdabot>  [0,2,4,6,8]
07:00:57 <fasta> ^^ also on one line :)
07:01:18 <Pastorn> > map (*2) [0..4]
07:01:19 <lambdabot>  [0,2,4,6,8]
07:01:50 <fasta> > [0..2,..8]
07:01:51 <lambdabot>  Parse error
07:02:16 <Pastorn> [0,2..8]
07:02:20 <Pastorn> > [0,2..8]
07:02:21 <lambdabot>  [0,2,4,6,8]
07:02:30 <fasta> right
07:02:36 <Pastorn> :D
07:03:36 <Volatile> > [1,1,2..13] -- let's see it do fibonacci
07:03:37 <lambdabot>  Parse error
07:03:45 <yuten> hello~
07:04:22 <yuten> can i use "jsldf sd f\ sjdlf sldk f" this long string ?
07:04:30 <yuten> can haskell accept the string like
07:04:30 <yuten> "cxxcccc\
07:04:30 <yuten> sd fsdf lksdj fls d\
07:04:30 <yuten> sjdlfj "
07:05:01 <Volatile> if not, you always have the ++ operator
07:05:40 <yuten> but use ++, you have to call ++ function, and it's not very convenient
07:06:01 <fasta> Where do I get the "extra" libraries from?
07:06:33 <fasta> yuten: yes, Haskell has multi-line strings.
07:07:51 <yuten> fasta: but i can't use in ghci
07:08:13 <fasta> yuten: I can't use UTF-8 in ghci.... What's your point?
07:09:13 <yuten> fasta: i write in a file, but the ghci interpreter said that lexical error
07:09:29 <yuten> fasta: for my multi-line string ~
07:09:45 <fasta> yuten: It's "foobar"\<newline>"OMG!", IIRC
07:10:14 <fasta> yuten: check the Haskell Report if you want to be sure
07:10:24 <yuten> fasta: thanks~ i thought it's the same as C
07:10:31 <Volatile> Where can I use utf-8?
07:10:46 <Volatile> Never got it to work anywhere...
07:10:58 <fasta> Volatile: ghc can understand it
07:11:06 <fasta> Volatile: ghci doesn't.
07:11:15 <Volatile> hmm
07:11:20 <fasta> yuten: My advice was incorrect.
07:11:25 <Volatile> what ghc version?
07:11:29 <fasta> Volatile: 6.6
07:11:39 <yuten> fasta: ya...i still get lexical error
07:12:14 <fasta> str = "multi\ \line"
07:12:25 <fasta> str = "multi\
07:12:31 <fasta>     \line"
07:12:33 <fasta> Try that
07:12:38 <Volatile> fasta, ah, there's the problem then =)
07:12:51 * Volatile only had 6.4
07:13:15 <ropine> reddit has been down all morning
07:13:22 <ropine> I bet if they still used Lisp they wouldn't have this problem :-)
07:13:45 <yuten> fasta: it's work now! thanks a lot fasta:p
07:20:35 <vincenz> ropine: or haskell
07:21:26 <fabiim> what does : "Pattern match(es) are overlapped" means ?
07:21:43 <dionoea_wrk> two parterns match and some of the characters that match are the same i guess
07:22:12 <dionoea_wrk> err ... no
07:22:18 <dionoea_wrk> it's when you do like:
07:22:28 <vincenz> fabiim: @paste your code
07:22:29 <Volatile> could anyone point me to some documentation for GenParser?
07:22:38 <vincenz> @google GenParser
07:22:42 <lambdabot> http://www2.lifl.fr/~pawlak/rp/doc/grapple/parser/GenParser.html
07:22:43 <lambdabot> Title: GenParser
07:22:54 <Volatile> hmm
07:22:59 <vincenz> hmm
07:23:02 <vincenz> @hoogle GenParser
07:23:03 <lambdabot> Text.ParserCombinators.Parsec.Prim.GenParser :: data GenParser tok st a
07:23:08 <Volatile> well
07:23:11 <vincenz> @doc Text.ParserCombinators.Parsec.Prim
07:23:12 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/parsec/Text-ParserCombinators-Parsec-Prim.html
07:24:23 <Volatile> Well, I DID find that page on my own, but thanks anyway...
07:25:03 <fabiim> doit (x:y) = all ( foo) (x:y)
07:25:21 <fabiim> doit (x:y:z:xs) = foo2...
07:26:31 * therp .oO("doit is a good function name. it sounds so productive")
07:27:08 <fabiim> ei , just playing around =)
07:27:25 <fabiim> nothing productive so no productive name
07:27:27 <fabiim> =)
07:29:03 <allbery_b> there's an outdated but still useful paper (pdf) about parsec somewhere
07:29:10 <allbery_b> @google parsec haskell
07:29:13 <lambdabot> http://www.cs.uu.nl/~daan/parsec.html
07:29:13 <lambdabot> Title: Parsec
07:29:54 <klymen> Question: How many prolog programmers does it take to screw in the light bulb?
07:29:57 <allbery_b> yeh, that
07:30:05 <klymen> Answer: Yes
07:30:08 <Volatile> allbery_b, ooh, that's more like it!
07:30:09 <Volatile> thanks
07:30:25 <Volatile> klymen, hehe
07:30:27 <Pastorn> what's the right way (just considering style here) to write this?
07:31:08 <Pastorn> f (x:y:z:zs) = f' (x:y:z) ++ f zs
07:31:10 <Pastorn> OR
07:31:38 <Pastorn> f xs = f' (take 3 xs) ++ f (drop 3 xs)
07:32:06 <klymen> Has anyone implemented a 2-3-4 tree in Haskell?
07:32:34 <klymen> I wish I knew about this channel one month ago
07:34:02 <klymen> YOu guys could have helped me with my assignment
07:34:02 <vincenz> klymen: a finger-tree?
07:34:09 <vincenz> klymen: erm, no
07:34:11 <vincenz> @quote vininim
07:34:11 <lambdabot> vininim hasn't said anything memorable
07:34:13 <vincenz> @quote vincenz
07:34:13 <lambdabot>  [Philippa] you can catch stuff off someone who's asymptomatic [vincenz] Philippa: only if you allow your body to become assymptotic with his [Binkley] nice typo [vincenz] it's a typo?
07:34:15 <vincenz> grr
07:34:25 <vincenz> klymen: The point of this channel is not to solve homework
07:34:26 <vincenz> :)
07:34:37 <klymen> I kid
07:34:39 <vincenz> Unless you want us to mail it for you to your teacher/professor
07:36:32 <Volatile> so this channel helps people to configure sendmail? ;)
07:36:56 <flux__> I doubt even haskell is powerful enough to help in configuring sendmail..
07:37:08 <klymen> Haskell is great for hashtables!!
07:37:35 <therp> really? is there a way to derive hash functions for ADTs automatically?
07:37:42 <klymen> That was a joke
07:38:06 <Volatile> hehe
07:38:34 <klymen> Haskell goes O(n) on hashtables, totally defeating the whole purpose of having a O(1)
07:38:41 <klymen> that may not be true though
07:38:59 <klymen> As far as I know Haskell is a mess with hashtables
07:39:41 <Pastorn> @hoogle splitAt
07:39:42 <lambdabot> Prelude.splitAt :: Int -> [a] -> ([a], [a])
07:39:42 <lambdabot> Data.PackedString.splitAtPS :: Int -> PackedString -> (PackedString, PackedString)
07:39:42 <lambdabot> List.genericSplitAt :: Integral a => a -> [b] -> ([b], [b])
07:40:01 <dylan> Data.Map is not
07:40:07 <dylan> *O(n)
07:40:31 <klymen> Data.Map?
07:40:55 <klymen> How can you not be O(n) when you don't have arrays
07:41:03 <klymen> for hashtables
07:41:06 <dylan> it can be O(lg n)
07:41:12 <klymen> oh
07:41:28 <klymen> Some clever recursive algorithm
07:41:30 <dylan> and Data.HashTable uses IOArrays
07:41:51 <klymen> I thought Haskell was all Lists
07:42:04 <vincenz> @localtime dons
07:42:05 <lambdabot> Local time for dons is Thu Dec 14 02:35:39 2006
07:42:17 <dylan> -- The implementation of 'Map' is based on /size balanced/ binary trees (or
07:42:17 <dylan> -- trees of /bounded balance/) as described by:
07:42:35 <dylan> http://www.swiss.ai.mit.edu/~adams/BB
07:42:38 <lambdabot> Title: Weight balanced binary trees
07:43:21 <klymen> Intersting
07:43:28 <klymen> Learn something new everyday
07:43:33 <dylan> and Data.HashTable is O(1) best-case, I think.
07:43:49 <dylan> like a hash table in any other language
07:43:59 <vincenz> dylan++
07:45:16 <klymen> I have my Haskell/Prolog final in 2 days
07:45:20 <klymen> Gotta go study
07:58:00 <pitecus> ?pl f x y = y
07:58:01 <lambdabot> f = const id
08:01:39 <glguy> Perhaps *what* is, *itself*, delicious.
08:05:50 <Botje> @pl \x y -> abs $ x - y
08:05:51 <lambdabot> (abs .) . (-)
08:06:27 <Botje> hmm
08:06:38 <Botje> so how does haskell fill in the variables?
08:07:15 <Botje> I assume it first fills in the x, so it becomes \y -> (abs .) . (x-)
08:07:25 <integral> "fill in the variables"?
08:07:34 <glguy> \y abs . (x -)
08:07:36 <Botje> bad choice of words.
08:07:36 <glguy> erro
08:07:42 <Botje> apply the variables to the lambda expression?
08:07:44 <glguy> \y -> abs . (x - y)
08:08:00 <integral> Fairly boringly...
08:08:28 <Botje> why the (abs .), then ?
08:08:45 <glguy> so that the second argument is applied to the result of (-) x
08:08:53 <integral> Botje: because you've got two args, not just one
08:08:57 <glguy> instead of the result of (abs ((-) x))
08:09:17 <integral> :t curry (abs . (uncurry (-)))
08:09:18 <lambdabot> forall b. (Num b) => b -> b -> b
08:09:33 <glguy> (abs .) . (-) becomes \y -> abs . ((-) y)
08:09:42 <Botje> hmm. looking at the type of (abs .) and abs, it makes sense.
08:09:58 <glguy> abs . ((-) y) becomes \x -> abs ( ((-) y) x )
08:10:49 <Botje> yay for newfound knowledge
08:10:56 <Botje> now, back to writing a silly paper.
08:12:21 <glguy> Reddit being down is really cutting into my ability to enjoy the day
08:13:11 <Botje> glguy: digg, del.icio.us?
08:13:54 <glguy> digg is borderline useless
08:14:06 <glguy> seems like all I enjoy is the comedy section on digg
08:14:22 <glguy> I've never been much of a del.icio.us user, but maybe this is the time to try
08:27:28 <cjs> 261 people here! Wow.
08:29:06 <cjs> Is ghc's --make mode a good thing, or do most people use something else?
08:32:27 <lisppaste2> metaperl pasted "how can I extend this data type with an additional operation" at http://paste.lisp.org/display/32291
08:32:55 <dr_strangelove> why does    (show "test")  yield "\"test\"" and not "test"?
08:34:19 <ropine> metaperl: you mean, without just editing the source and adding "| SomethingElse" to the end?
08:34:36 <metaperl> ropine - yes
08:34:45 <metaperl> kind of like subclassing in OO
08:35:00 <metaperl> data Edit2 = Swap x y deriving (Edit)
08:35:25 <metaperl> something like that
08:36:01 <ventonegro> data Edit2 = OldEdit Edit | SomeThingElse
08:36:06 <vincenz> metaperl: ++!
08:36:25 <metaperl> @type (++)
08:36:27 <lambdabot> forall a. [a] -> [a] -> [a]
08:36:31 <vincenz> ehm, no
08:36:40 <metaperl> I dont know how to upvote you
08:36:43 <vincenz> ventonegro's solution is the correct one
08:36:45 <metaperl> i'm supposed to upvote you
08:36:52 <vincenz> ventonegro++
08:36:56 <metaperl> ventonegro - thanks
08:36:57 <ventonegro> :-)
08:37:01 <metaperl> vincenz++
08:37:07 <metaperl> ventonegro++
08:37:11 <metaperl> it aint workin
08:37:16 <metaperl> @karma vincenz
08:37:17 <lambdabot> vincenz has a karma of 18
08:37:22 <vincenz> it does work
08:37:24 <metaperl> @karma ventonegro
08:37:24 <lambdabot> ventonegro has a karma of 2
08:37:25 <vincenz> it's silent
08:37:30 <ventonegro> well, the types are not really interchangeable
08:37:49 <vincenz> you'd need polymorphic variant types like in ocaml
08:38:13 <ropine> if Edit were a typeclass...
08:41:05 <metaperl> @yaht
08:41:06 <lambdabot> Maybe you meant: fact part yarr
08:41:11 <metaperl> ?url yaht
08:41:12 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
08:41:13 <ventonegro> metaperl, if you could identify the set of functions you expect to apply on all the instances of Edit, you could make a typeclass out of them
08:41:27 <metaperl> I need a typeclass tutorial
08:41:37 <metaperl> YAHT has one... i want YAHT in html
08:41:53 <ventonegro> there is a yaht in wikibook
08:42:05 * metaperl googles
08:43:38 <ropine> http://en.wikibooks.org/wiki/Haskell/YAHT/Type_advanced#Classes
08:44:19 <paolino> 'nasera everyone
08:44:20 <paolino> is it possible to elide 'a' type in this code ?
08:44:20 <paolino> class (Graph g a) => Cursor l g a where
08:44:20 <paolino>   totop  :: [l g a -> l g a]       -- the functional path from the top
08:45:38 <paolino> all methods in the class has at least (g a) type
08:46:50 <paolino> noone of them has 'a' alone in the signature
08:48:44 <paolino> idiot question eh ?
08:49:13 <paolino> I'm not fully understanding types probably
08:52:46 <paolino> nm
08:55:05 <Taral> g isn't a type. It has to be applied to a type.
08:55:31 <paolino> class (Averageable a) => Graph g a where
08:55:47 <paolino> this is g
08:56:00 <Taral> still not a type.
08:56:01 <paolino> what is its name ?
08:56:14 <Taral> that's a typeclass, not a type.
08:56:40 <AStorm> a class of types? :P
08:56:50 <benja_> ibid: moi =)
08:56:54 <ibid> uh, g is a type in that context
08:57:12 <AStorm> Hmm, well, yes, it is.
08:57:12 <Taral> ibid: Mmm, ground type or whatever you want to call it. type of kind *
08:57:19 <AStorm> As is a
08:57:22 <ibid> well, not exactly a type, but not type class at least
08:57:34 <Taral> no, the class...where thing is a typeclass.
08:57:40 <benja_> hi all. does anyone here know what the easiest way to get gtk2hs running on ubuntu 6.06 would be?
08:57:56 <ibid> benja_: build from source
08:58:02 <AStorm> Would be to install the package from their repository :P
08:58:09 <AStorm> (it is there)
08:58:14 <ibid> AStorm: it's uninstallable
08:58:18 <AStorm> Other than that, build from source. Quick and simple too.
08:58:40 <ibid> AStorm: waiting for the upstream release that works with ghc 6.6
08:58:58 <paolino> ok, so I cannot ever nominate it (g) without a subtype after it ?
08:58:58 <ibid> benja_: i did that on debian (and ubuntu 5.10) when i was working on unbounded
08:59:03 <benja_> (apt-cache search gtk2hs didn't find anything... wrong name?)
08:59:12 <ibid> paolino: there are no subtypes in haskell
08:59:13 <benja_> ibid: ok
08:59:53 <ventonegro> benja_, libghc6-gtk-dev
09:00:01 <ibid> benja_: gtk2hs is the source name; look for libghc6-gtk-dev etc (but likely not in ubuntu 6.06)
09:00:04 <paolino> without an argument ?
09:00:04 <ventonegro> but it won't work
09:00:32 <ibid> paolino: yeah. g is essentially a function at type level
09:01:01 <paolino> can I work partially with it , like with functions ?
09:01:43 <ibid> paolino: you are doing that already
09:02:12 <ibid> paolino: but note that where a type is expected, you need to give a type (kind *)
09:02:18 <niarium> hello everyone
09:02:35 <ibid> benja_: oh, hei :)
09:02:42 <benja_> ibid: :)
09:02:53 <niarium> does anybody remember where's Simon P. Jones' presentation covering the history of haskell and breif introduction?
09:03:17 <niarium> i mean, a presentation file (*.pdf iirc)
09:03:34 <ibid> niarium: google for "wearing the hair shirt"? or do you mean the history of programming languages preprint?
09:04:12 <niarium> ah, "wearing the hair skirt" seems to be correct. thanks a lot!
09:04:16 <paolino> ibid, here I'm not interested in using its type argument, but I cannot omit it,
09:04:16 <paolino> class (Graph g a) => Cursor l g a where
09:04:50 <ibid> paolino: you are omitting it there. are you saying it doesn't work?
09:06:05 <paolino> it does work, it's just that all methods sees (g a) as a unit , they never use a in their signature
09:06:35 <ibid> paolino: and that is a problem because...?
09:08:03 <paolino> nothing if there is no way to say ,I will call (g a)  h in the next signatures
09:08:35 <ibid> paolino: EPARSE
09:10:27 <paolino> well I think one omits the argument in a function declaration to have a cleaner code,I'm asking if I can do it here with these higher order types or , what is their name
09:11:50 <ibid> paolino: no, you cannot omit the argument in a function signature
09:12:19 <ibid> paolino: and there is useful information in that they all have the same a: that is, they all take the same type parameter
09:13:02 <paolino> ok, satisfied ,thanks
09:15:12 <rev> lambdabot: hola
09:26:44 <glasser> I (well, a colleague) downloaded some software whose makefile calls ghc with "-package lang", and the lang package can't be found.  I'm having trouble googling for information on the lang package.  does anyone know what it is?  Is it maybe outdated?
09:35:21 <psnl> glasser: ghc.6?
09:35:26 <psnl> 6.6, even
09:35:52 <glasser> yeah
09:35:54 <glasser> (on intel mac)
09:36:07 <psnl> yeah, I normally take the -package lang out
09:37:22 <scodil> can I use gadt's to enforce run-time constraints on values? like, a pair of ints that is always in sorted order? or can it only do type constraints?
09:37:29 <glasser> psnl: do you know what it meant?
09:37:41 <glasser> (I think she tried that and had some other problems afterwards, actually)
09:39:14 <cjs> So is HUnit just a weird thing that I should be avoiding, or do even weird Haskell programmers use that kind of unit testing?
09:40:06 <dr_strangelove> I have a data type    data X = X { bla :: Integer }     and want to define another function (somewhere else)      bla y :: Y -> Integer        but I get an error (multiple declarations) why can't I do this? The compiler should be able to distinguish the functions by type.
09:40:14 <scodil> hunit has the herpes. stay away
09:40:27 <vincenz> dr_strangelove: they share the same space
09:40:33 <vincenz> dr_strangelove: no
09:40:40 <vincenz> dr_strangelove: definitely not, that would screw up type-inference
09:40:40 <cjs> Hm. So why does it come with ghc?
09:40:49 <scodil> i'm kidding. i'm sure its nice
09:43:06 <dr_strangelove> vincenz, so I can't define a function "length" anywhere in my code?
09:43:22 <vincenz> dr_strangelove: not unless you don't import the std length
09:43:38 <twb> Quick question: what's the function that takes an element and a list and sticks the element in between each element of the list?
09:43:39 <vincenz> import Prelude hiding(length)
09:43:50 <vincenz> twb: intersperse
09:43:50 <Botje> twb: intersperse
09:43:54 <twb> Good, good.
09:43:55 * vincenz beeps Botje 
09:44:05 <Botje> :(
09:44:16 <Botje> I was first in at least 42 parallel universes
09:44:22 <vincenz> hah!
09:44:26 <dr_strangelove> vinzenz, leads to verbose names ...
09:44:33 <vincenz> dr_strangelove: hardly
09:45:00 <dr_strangelove> lengthMyType1, lengthMyType2
09:45:08 <vincenz> tbh
09:45:13 <vincenz> how often do you need "length"
09:45:35 <vincenz> this is not OO
09:45:44 <vincenz> you don't design a zillion superfluous classes that do the same
09:46:14 <dr_strangelove> I don't know, but in my current project I could use some accessor functions with the same name
09:46:21 <vincenz> make a typeclass
09:46:37 <vincenz> class SomeClass where
09:46:42 <vincenz> class SomeClass a where
09:46:49 <vincenz>   somFunc :: a -> something else
09:46:54 <vincenz> instance SomeClass MyType1 where
09:46:55 <vincenz>   ...
09:48:14 <dr_strangelove> hm, I'll see, thx
09:54:21 <xs> hello. i'm trying to work out where a space leak is, by using ghc's profiling, but the .hp file has truncated call paths. is there a way to untruncate these?
10:00:19 <dr_strangelove> what book can you recommend for learning haskell?
10:00:53 <xs> dr_strangelove, what is your past experience?
10:01:28 <xs> http://www.haskell.org/haskellwiki/Books#Textbooks
10:01:31 <lambdabot> Title: Books and tutorials - HaskellWiki
10:01:31 <dr_strangelove> c, c++, java, ruby, and a little bit haskell (only toy programs)
10:01:32 <ptolomy> I'm a bit in favour of the Ocaml -> Haskell approach.
10:01:44 <ptolomy> Ocaml is a gateway drug to haskell.
10:02:02 <ptolomy> Then, once you've tasted the sweet lazy high, softer drugs seem lame.
10:02:09 <Trevion> Although I've found that Ocaml has lingering syntactic effects that never quite wear off
10:02:16 <Trevion> I still find myself occasionally typing double semi-colons.
10:03:25 <dr_strangelove> i looked at the haskell school of expression, but it uses windows gui libs in the examples, and I don't use windows
10:04:00 <cjeris> every time someone says "i don't use windows" i die a little... of jealousy
10:04:14 <sjanssen> dr_strangelove: I think there's a reimplementation of the library in GTK
10:04:45 <dr_strangelove> sjanssen, where can I get it?
10:05:30 <scodil> gtk2hs has it i think
10:05:56 <scodil> yeah
10:06:02 <scodil> Graphics.SOE.Gtk
10:06:03 <ventonegro> cjeris, i know the feeling
10:06:06 <ray> i don't use windows
10:06:09 <ray> =D
10:06:25 <scodil> http://haskell.org/gtk2hs/
10:06:26 <dr_strangelove> scodil, thx
10:06:27 <lambdabot> Title: Gtk2Hs
10:06:37 <bitshifter> I haven't used windows in 12 years
10:07:47 <scodil> how is nub implemented? if the input list doesn't have to be sorted
10:08:01 <scodil> does it sort it? or is there some other method of removing duplicates
10:08:11 <Volatile> are there people who still use windows?
10:08:18 <Trevion> Volatile: yes
10:08:20 <Volatile> ;)
10:08:32 <kpreid> scodil: comparison with every previously-seen element
10:08:35 <ray> nope
10:08:38 <kpreid> O(n^2)
10:08:43 <ray> very few "people" per se
10:09:28 <scodil> kpreid: is there an advantage to that over sorting first then doing an stl-style unique?
10:09:43 <kpreid> scodil: yes: you can do it without requiring Ord, just Eq
10:09:45 <LoganCapaldo_> You keep the order
10:09:47 <Trevion> scodil, nub doesn't change the order of elements in the resulting list
10:09:58 <scodil> ah
10:11:44 * resiak assumes SPJ uses Windows
10:12:39 <klapmuetz> is this now the time where people go and check cvs commits to windows only libs? "I know what you commited last summer!"
10:12:40 <Trevion> At least his laptop does.  John Hughes was using a Windows Tablet PC in Portland as well.
10:13:41 <ray> sif windows only libraries use version control
10:17:41 <yaarg> anyone else having problems compiling latest hs-plugins?
10:17:59 <yaarg> Bad interface file: /home/jg/src/hs-plugins-0.9.10/src/hi/Language/Hi/Parser.hi
10:18:21 <Excedrin> it doesn't work on ghc-6.6 yet
10:18:51 <yaarg> oh
10:19:03 <yaarg> right...yeah that makes sense then
10:22:12 <yaarg> i was overjoyed to find a backport for ghc6.6 as well 8-)
10:35:18 <lenbit> supposing some of you here read programming.reddit.com -- what is a good alternative to reddit's programming sub-section now that reddit seems to be down?
10:41:22 <Cale> wow, reddit's still down, haha
10:48:26 <klapmuetz> I even resorted to look at digg today while being at work
10:51:23 <lenbit> so what are we to do?
10:59:01 <holdenk> I've spent the time looking at comp.compilers trying to figure out which language to use for my next project, but it just isn't the same :(
12:59:08 --- topic: '["Get yourself some cognitive dissonance!", "Haskell - the language of ICFP winners 3 years running", "Logs: http://tunes.org/~nef/logs/haskell/"]'
12:59:08 --- topic: set by dons on [Fri Dec 08 21:02:10 2006]
13:00:05 <integral> hmm, rather a nice cheese is yaarg
13:11:38 <syntaxfree> ontology or onthology?
13:11:45 <syntaxfree> (what's the correct spelling?)
13:11:54 <Randroid> anthology or ornithology?
13:12:03 <Randroid> (The correct spelling is ontology.)
13:12:04 * syntaxfree laughs.
13:12:40 <Randroid> ontos "being" + logos "knowledge" (at a Greek guess)
13:12:55 <Randroid> Well, logos means word, actually.
13:12:57 <Randroid> But whatever.
13:13:13 <Randroid> My Greek sucks, but I know enough for simple etymologies.
13:13:24 <integral> "ontology" in english
13:17:29 <glguy> > msum . sequence [(\x -> guard (and x) >> return True),(\x -> guard (not $ or x) >> return False)] $ [False,True] :: Maybe Bool
13:17:31 <lambdabot>  Nothing
13:17:39 <glguy> > msum . sequence [(\x -> guard (and x) >> return True),(\x -> guard (not $ or x) >> return False)] $ [True,True] :: Maybe Bool
13:17:41 <lambdabot>  Just True
13:22:02 <syntaxfree> is "overly" a word?
13:23:06 <kpreid> Yes. Similar to "excessively"
13:23:11 <kpreid> or perhaps a misspelling of "overlay"
13:27:38 <LoganCapaldo_> ly :: Adjective -> Adverb
13:28:00 <glguy> LoganCapaldo_: ly over?
13:28:22 <LoganCapaldo_> postfix (ly) ;)
13:28:40 <glguy> over is a preposition though?
13:29:12 <LoganCapaldo_> Adjective is an instance of Adverbable
13:29:23 <LoganCapaldo_> I was just showing the one overloading of ly :-p
13:29:29 <glguy> I'm just being a pest
13:29:31 <glguy> (=
13:32:41 <glguy> is there a better version of: converge (first:rest@(second:_)) | first == second = first | otherwise = converge rest   -or-   fst $ find (uncurry (==)) $ zip xs (tail xs)
13:33:07 <kosmikus> zeeeee: what OS are you on?
13:33:17 <glguy> [a | (a,b) <- zip xs (tail xs), a == b]
13:34:23 <glguy> (I know that my second example has a type error)
13:36:06 <glguy> converge (x:xs) = aux x xs where aux x (y:ys) | x == y = x | otherwise aux y ys
13:36:44 <Randroid> glguy: "Over" is a (usually) a preposition, yes.
13:38:57 <LoganCapaldo_> over-complicated, overly complicated, I think over may just be an adjective in this case anyway. Stupid english ;)
13:39:25 <glguy> uncons f (x:xs) = f x xs -- similar to uncurry
13:39:29 <glguy> ?hoogle uncons
13:39:29 <lambdabot> No matches found
13:41:21 <syntaxfree> is "damning" a word?
13:41:28 <syntaxfree> meaning "complication"?
13:41:38 <glguy> an action can be "damning"
13:41:45 <glguy> so can a statement
13:41:46 <syntaxfree> er, not complication.
13:41:48 <syntaxfree> condemnation.
13:43:00 <lisppaste2> glguy annotated #32305 with "feel free to disregard" at http://paste.lisp.org/display/32305#2
13:45:22 <syntaxfree> is "possibilitate" a word?
13:45:36 <Botje> it could possibilitate to be.
13:45:40 <Randroid> Sure, just not one that a formal dictionary would like.
13:45:40 <Ugarte> Yes. It's when you consider debilitating someone, but there's only a possibility.
13:45:44 <Botje> also, no :)
13:45:52 <Botje> syntaxfree: "make possible" ?
13:46:02 <Botje> or "enable"
13:46:04 <syntaxfree> "does in fact make possible"  looks UGLY.
13:46:29 <Ugarte> "does in fact possibilitate" doesn't look any better.
13:46:35 <Ugarte> How about "allows"?
13:46:43 <syntaxfree> I'm going for enables.
13:46:48 <Ugarte> That works, too.
13:47:16 <ropine> programming.reddit.com is up!
13:47:26 <mbishop> about time heh
13:47:50 <glguy> hooray for reddit returning!
13:49:23 <Averell> what's the new ip? i get connection refused
13:50:37 <ropine> Averell: 72.5.28.218
13:51:10 * edwardk waves hello
13:55:19 <Daveman> hey chessguy :)
13:55:27 <chessguy> yo!
13:55:28 <glguy> lol, i get redirected to http://www.reddit.com/noreddit
13:55:33 <glguy> and then I get "server not found"
13:55:38 <Ugarte> Yeah, same.
13:55:47 <glguy> i need to edit my hosts file maybe
13:55:53 <ropine> \me feels so special
13:56:06 <chessguy> so it looks like i have a shot at a second job offer now too. it seems a lot more boring, but pays like 30% more
13:56:32 <ropine> define "a lot more boring"
13:56:37 <chessguy> java :)
13:56:40 * earthy took a 35% pay cut to get to work with Haskell
13:56:53 <glguy> "a lot more boring" can be quite painful
13:56:53 <ropine> J2EE?
13:57:08 <chessguy> ropine, i think so. i'll find out more details when i interview tomorrow
13:57:12 <earthy> and I wasn't doing boring things anyway
13:57:32 <chessguy> earthy, well, if i take the first job, i think there's a great chance at using haskell to simplify their process
13:57:39 <chessguy> but i don't know if they'll be open to it
13:58:19 * glguy got to reddit by adding a reddit.com line to hosts
13:58:28 <earthy> time for a second talk
13:59:12 <chessguy> talk?
13:59:20 <syntaxfree> talk?
13:59:30 <glguy> ?yow
13:59:31 <lambdabot> Look!  A ladder!  Maybe it leads to heaven, or a sandwich!
13:59:45 <chessguy> lol
13:59:58 <ropine> the latest versions of J2EE, with Hibernate/Spring, sound a lot less painful than the monstrosity I was trying to work with a couple years ago
14:00:38 <earthy> sorry
14:00:42 * earthy is too damn tired to be on IRC
14:00:45 <Daveman> :D
14:00:55 * glguy wonders what it means to be too tired to IRC
14:01:03 <earthy> three evenings of dance class does take the life out of you
14:01:04 * chessguy knows the feeling
14:01:33 * earthy wonders what the hell Dazzle is doing
14:01:41 <chessguy> i think i'm likely to sleep through my first class tomorrow
14:01:50 <earthy> it's been running for some 10 hours already...
14:02:04 <chessguy> it's cruelty to schedule a class at 9:30 in the morning anyway
14:02:17 <earthy> nah
14:02:20 <earthy> 9:30 is fine
14:02:24 <dino-> I'm wondering if somebody can help me. I'm about to install some of the gtk2hs stuff and I'm not sure what exactly to install..
14:02:26 <earthy> our classes are at 9. ;)
14:02:43 <chessguy> that's just inhumane
14:02:50 <cjeris> classes should not be held at AM hours of single digits
14:02:50 <dino-> I see a lot of stuff here, some of which I can tell I probably don't need. Like the mozembed and sourceview things.
14:03:02 <dino-> But what about mogul? glade? gconf? etc..
14:03:16 <Daveman> cjeris, particularly not exams :)
14:03:24 <Daveman> Alas.
14:03:56 <Trevion> I had an abstract algebra class at 8:45.  By the second week of class, there were three of us getting there on time.
14:04:22 <earthy> our first year programming class was on friday 9 am
14:04:47 <newsham> the prof should close the door and ban late entry.
14:04:49 <Daveman> I have a physics exam at 8AM :)
14:04:54 <newsham> that'll get people there on time or not at all
14:04:56 <bitshifter> I had an 8am class with about 20 students, we all told the prof that we'd be there at 5pm every day and if he wanted to teach he should too
14:05:00 <bitshifter> AND, it worked.
14:05:09 * Trevion chuckles
14:05:10 <Daveman> heh
14:05:35 <Trevion> I had more than one 8AM exam on Saturdays.  One prof and I concluded that the registrar had sold her soul to Satan.
14:05:35 <newsham> i had an early class where the prof said "no late entries" and it worked.
14:05:36 <bitshifter> The prof didn't want an 8am either
14:05:36 <edwardk> heh, i would have welcomed moving my 8am class to 5pm, but alas, some of my students couldn't move =(
14:05:42 <dylan> I had a professor that was always 10 minutes late, at best
14:06:09 <dylan> one day he came in 20 minutes late, opened the classroom, and disappeared for 30 minutes
14:06:25 <syntaxfree> I had a professor who would always 30 minutes late.
14:06:41 <dylan> this was for a 50 minute class
14:06:41 <syntaxfree> We'd already expect him being 30 minutes late.
14:06:45 <Trevion> I am reminded of why one of my major goals in life has always been to get a professorship.
14:06:50 <syntaxfree> This was a class after another, so we waited for him at his classroom.
14:06:55 <dylan> he showed up after class was technically over and began lecturing.
14:07:01 <syntaxfree> One day, we waited for 45 minutes and he didn't come.
14:07:20 <dylan> of course, because of his being late, he let us get away with lots of stuff, especially in the lab. :)
14:07:22 <syntaxfree> So we concluded he was sick or something and went home.
14:07:32 <glguy> when I was in school, you had to be a department chair if you expected students to stick around more than 10 minutes
14:07:34 * earthy had that happen at an exam
14:07:59 <syntaxfree> We later learned that he somehow arrived and taught eigenvalues, eigenvectors and the spectral theorem in that single class.
14:07:59 <earthy> prof had completely forgotten that he had to let us take it
14:08:05 <dylan> we used to have jousting contests using the very tall rolling lab chairs. XD
14:08:10 <bitshifter> I had a prof that showed up for the final 1.5hrs late (2hr final) looking like his wife left him or something
14:08:15 <Daveman> haha
14:08:19 <Daveman> owned :P
14:08:25 <dylan> and then there was the people that moved their seats into the bio-bubble portable clean room.
14:08:33 <Daveman> o_O
14:08:40 <glguy> making it a "not-clean" room?
14:08:43 <dylan> (this was an electronics class)
14:08:54 <dylan> no, we wore the smocks
14:08:57 <integral> heh.  I had a lecturer who a week before the end of term realised that the term was 2 weeks shorter than he thought, so he managed to teach e-vals and stractral theorem in one lecture
14:09:00 <dylan> and didn't take anything else in.
14:09:03 <edwardk> ah
14:09:26 <edwardk> so moved their posteriors to seats in the cleanroom, not moved the actual seats =)
14:09:38 <dylan> That professor is a big reason why I dediced I want to be a professor, somehow, some day. ;)
14:10:02 <syntaxfree> integral: I had a lecturer (on first-year graduate statistics) who just realized it was the last class in that term in the middle of a demonstration and just said "Ok, we'll finish that next semester".
14:10:31 <syntaxfree> About one third of the next course (which was supposed to be econometrics) was actually the end of the first stats course.
14:10:37 * cjeris never had any of these bizarre things happen, but did have an analysis prof with an eyepatch, a pegleg and a swearing habit
14:10:51 <Trevion> I had a (MacArthur-grant receiving) professor who decided to give her final one week before the end of the quarter.  Then, she lectured slowly and ended up having a lecture after she'd given the final.
14:10:54 <bitshifter> Really, that is just as good.
14:11:17 <Trevion> I've tried ever since to find out what she talked about in that lecture, but I have yet to find anyone who went to it.
14:11:21 <syntaxfree> I've had dozens of lectures past finals.
14:11:28 <earthy> otoh I managed to fall asleep in class... where I was one of the 2 students.
14:11:30 <cjeris> diabetic. didn't listen to his doctors.  didn't take care of his blood sugar.  bits of his body kept falling off.
14:11:35 <dylan> then there was the algebra teacher that would go on rants about the bookstore being owned by crack dealers...
14:12:00 <bitshifter> cjeris, are you sure he wasn't just a pirate.
14:12:04 <earthy> arrr
14:12:12 <chessguy> @yar
14:12:13 <lambdabot> Har de har har!
14:12:14 * ropine is strangely relieved to not be in graduate school
14:12:26 <glguy> I had an Literature prof in his first semester teaching. he started out quite strict wasted no time, started adn stopped on schedule
14:12:32 <glguy> by the end of the semester, he'd figured it out
14:12:33 <chessguy> @yar . slap
14:12:34 <lambdabot> I'd like to drop me anchor in her lagoon
14:12:39 * Randroid never went to college at all.
14:12:40 <cjeris> bitshifter: well, that's how everyone thought of him, but he often left his prostheses lying around the lecture hall
14:12:50 <glguy> and would just chat with us for 10 minutes before even considering starting class
14:12:51 <syntaxfree> The econometrics course that had to share time with the end of the previous course was then horribly compressed.
14:13:01 <syntaxfree> We'd have twice the class time we were supposed to have.
14:13:12 <syntaxfree> We once were expelled from the computer lab by a janitor.
14:13:39 <glguy> The only encounter I had with a janitor was being told to take my inline skates off while inside the building
14:13:46 * glguy always skated to and in class
14:14:10 <Daveman> :P
14:14:13 <cjeris> bitshifter:  representation theorist named Paul Sally.
14:14:29 * syntaxfree just wrote another exceedingly long post and is already worried that he'll be expelled from planet haskell from being such a sycophantic freak.
14:14:51 <Daveman> sounds good :)
14:15:23 <bitshifter> cjeris, I read that Paul Silly at first glance.
14:15:32 <Daveman> me too :P
14:15:34 <Daveman> probably is
14:15:40 <IPI> i am working on a question: provide the signature of efg and fgh : efg c list = c == fgh list
14:15:41 <IPI> fgh (x:y:xs) = fgh (y:xs)
14:15:41 <IPI> fgh (x:xs) = x
14:15:58 <IPI> efg:: Ord a => a -> [a]-> bool ?
14:16:07 <IPI> fgh:: [a] -> a
14:16:11 <IPI> is this correct?
14:16:15 <yaarg> shapr: heh thank you
14:16:19 <newsham> glguy: if you regularly show up more than 10 minutes late dont you get promoted to dept chair? ;-)
14:16:22 <syntaxfree> that sounds strangely like homework.
14:16:27 <yaarg> it's a very satisfying sound i find
14:16:37 <yaarg> people call me it in real life too :-D
14:16:58 <chessguy> IPI, can't you just put it in the interpreter and find out?
14:17:20 <IPI> well i guess i could ... chessguy .. let me try it .. good idea
14:17:21 <chessguy> ?let efg c list = c == fgh list
14:17:21 <lambdabot> <local>:8:18: Not in scope: `fgh'
14:17:30 <syntaxfree> @type fgh (x:y:xs) = fgh (y:xs);  fgh (x:xs) = x
14:17:31 <lambdabot> parse error on input `='
14:17:39 <glguy> his fgh is just last
14:17:51 <CosmicRay> syntaxfree: they haven't expelled me for writing about my house...
14:17:56 <glguy> and efg a xs asks if last xs == a
14:17:59 <IPI> efg :: Eq a => a -> [a] -> Bool
14:17:59 <chessguy> mmm, not last, i don't think
14:18:23 <syntaxfree> CosmicRay: OTOH, that's not the least bit antagonistic.
14:18:23 <IPI> fgh :: [a] -> a
14:18:23 <chessguy> next to last
14:18:31 <syntaxfree> @type should just desugar named functions into lambda forms.
14:18:32 <lambdabot> parse error (possibly incorrect indentation)
14:18:33 <IPI> that was easy ... Thanks for the hint chessguy
14:18:36 <syntaxfree> it's bizarre that
14:18:42 <syntaxfree> @type \x->x+1
14:18:43 <glguy> chessguy: I don't think that it's next to last, actually
14:18:44 <lambdabot> forall a. (Num a) => a -> a
14:18:48 <syntaxfree> works, but
14:18:51 <syntaxfree> @type f x = x + 1
14:18:53 <syntaxfree> doesn't.
14:18:53 <chessguy> oh, you're right
14:18:53 <lambdabot> parse error on input `='
14:19:01 <chessguy> xs will match []
14:19:03 <earthy> @type \x -> x + 1
14:19:04 <lambdabot> forall a. (Num a) => a -> a
14:19:08 <glguy> chessguy: right, so it's last
14:19:11 <chessguy> yes
14:19:18 * chessguy shuts up now
14:19:22 <glguy> ah, I didn't see you agree with me
14:19:32 <glguy> syntaxfree: was poluting (-;
14:19:49 <earthy> @type let fgh (x:y:xs) = fgh (y:xs);  fgh (x:xs) = x in fgh
14:19:50 <lambdabot> forall a. [a] -> a
14:20:35 <earthy> @type let fgh (x:y:xs) = fgh (y:xs);  fgh (x:xs) = x in let fg c list = c == fgh list in fg
14:20:36 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
14:20:47 <glguy> IPI: is that homework? or are you just writing bizzare functions?
14:20:56 <Daveman> hehe
14:21:04 <chessguy> lol
14:21:24 <IPI> glguy, this was sample final ... the strange naming is because the proof doesn't want us to guess what the function does by its name :)
14:21:33 <IPI> *prof
14:21:42 <chessguy> well, more than just the name is weird
14:21:46 <Trevion> We always called that function mystery.  It also was _always_ subtraction...
14:21:48 <syntaxfree> bizarre naming is worst in Prolog.
14:22:35 <IPI> actually the next question asks us to write the equivalent prolog code
14:22:52 <syntaxfree> wow. a Haskell+Prolog course. What IS that?
14:23:03 <IPI> i know ...
14:23:45 <Daveman> heh
14:23:48 <Daveman> neat
14:24:12 <glguy> last (x:xs) | null xs = x | otherwise = last xs
14:24:13 * IPI is glad this course is almost over 
14:24:29 * glguy is aware that everyone knew hwo to do that
14:24:40 <chessguy> > null []
14:24:41 <lambdabot>  True
14:24:47 <chessguy> wow, didn't know that one
14:24:51 * chessguy feels dumb
14:25:00 <Trevion> My PL course included SML, Prolog, C++ and Java with Generics.
14:25:02 <glguy> hooray, I inadvertently taught someone something
14:25:27 <chessguy> ours is just doing scheme and prolog
14:25:35 <bitshifter> I try to avoid teaching people at all costs, they just keep comming to you with questions.
14:25:36 <newsham> glguy: last [] ?
14:25:39 <syntaxfree> my CS 101 was just Scheme.
14:25:45 <glguy> > last []
14:25:45 <lambdabot>  Add a type signature
14:25:49 <glguy> > last [] :: ()
14:25:50 <lambdabot>  Exception: Prelude.last: empty list
14:25:52 <syntaxfree> It was also the only CS course I ever took.
14:25:59 <IPI> ours has 3 : imperative (of our choice such as java or C) , Haskell & prolog
14:26:09 <glguy> > let last (x:xs) | null xs = x | otherwise = last xs in last [] :: ()
14:26:11 <lambdabot>  Non-exhaustive patterns in function last
14:26:15 <glguy> newsham: neither works :)
14:26:16 <newsham> > let last (x:xs) | null = xs = x | otherwise = last xs in last []
14:26:16 <lambdabot>  Parse error
14:26:18 <syntaxfree> (Except for the "applied computational intelligence" course that covered neural nets, genetic algorithms and fuzzy control)
14:26:20 <Daveman> ah so it was like a sampler platter :p
14:26:38 <newsham> > let last (x:xs) | null xs = x | otherwise = last xs in last []
14:26:39 <lambdabot>  Add a type signature
14:26:44 <newsham> > let last (x:xs) | null xs = x | otherwise = last xs in last [] :: [Int]
14:26:46 <lambdabot>  Non-exhaustive patterns in function last
14:26:54 <bitshifter> last doesn't make sense on empty lists
14:27:02 <glguy> newsham: right, you should not apply either function to []
14:27:03 <syntaxfree> last [] = undefined
14:27:11 <bitshifter> there is no singleton null valye
14:27:13 <syntaxfree> that's why there's an undefined value in first place.
14:27:15 <syntaxfree> bottom, y'know.
14:27:18 <newsham> i prefer "error" to "undefined" :)
14:27:32 <glguy> I prefer that people not take last of [] (-;
14:27:32 <syntaxfree> I prefer undefined.
14:27:44 <newsham> ps: i wish there was documentation specifying the incomplete functions :(
14:28:01 <Trevion> The last major project I worked on had a monadic failure along those lines called 'wtf'
14:28:13 <bitshifter> That was a good monad.
14:28:28 <newsham> if you meet the monad on the road, kill the monad.
14:28:42 <bitshifter> one of these days, I'm going to get up the will to go through GHC and add the plumbing to get a call stack when errors happen.
14:29:07 <chessguy> well, we definitely need some kind of run-time debugging device
14:29:11 <bitshifter> head of empty list isn't quite as useful as I'd like
14:29:29 <Trevion> Even having JHC's srcloc-annotate magic would be fine with me.
14:29:32 <chessguy> > head []
14:29:33 <lambdabot>  Add a type signature
14:29:35 * bitshifter wants a core dump (think unix and c, not Core Language)
14:29:40 <chessguy> > head []::Integer
14:29:41 <lambdabot>  Exception: Prelude.head: empty list
14:29:42 <Daveman> :p
14:29:43 <glguy> > head [] :: ()
14:29:44 <lambdabot>  Exception: Prelude.head: empty list
14:29:44 <newsham> if i wanted to prove that an app i had written had no runtime errors, it would be nice having a list of all possible runtime errors
14:30:16 <Trevion> > "ab" !! 3
14:30:18 <lambdabot>  Exception: Prelude.(!!): index too large
14:30:24 <glguy> > listToMaye [1,2,3]
14:30:25 <lambdabot>  Not in scope: `listToMaye'
14:30:26 <Trevion> I spent four hours trying to track one of those down once.
14:30:27 <glguy> > listToMaybe [1,2,3]
14:30:29 <lambdabot>  Just 1
14:30:37 <glguy> ^ safer than head (=
14:30:54 <Trevion> It transpired that it was in the Data.Generics code, and that we were using different encodings to write something to a stream and read it back
14:31:18 <chessguy> i once spent about 4-6 hours (in another language) tracking down an 'and' that should have been an &&
14:31:25 <Trevion> I think that was about the nadir of error message helpfulness ever.
14:32:57 <Excedrin> chessguy: Perl?
14:33:26 <chessguy> Excedrin, no. it was vb.net, actually
14:34:19 * mbishop looks at chessguy funny
14:34:31 <Trevion> Ooh!  Doesn't one of those short-circuit and the other not?
14:34:54 <chessguy> i don't remember
14:34:59 <chessguy> that was several years ago
14:36:16 <chessguy> i was writing a chess program in vb.net, just to show it could be done. the error was making pieces randomly disappear off the board
14:36:38 <glguy> Trevion: that is the case in VB I believe
14:37:25 <chessguy> it was one of those things that probably should have blown up, but the language thought it could figure out what i really meant
14:38:16 <ndm> hi
14:38:38 <ndm> a quick pretty printing question
14:38:44 <ndm> how do i do one line after another?
14:39:01 <Saizan> ?
14:39:03 <ndm> i.e. render a ++ "\n" ++ render b
14:39:15 <ndm> i.e. insert a blank line, no need to pretty print between things
14:39:16 <integral> vcat?
14:39:36 <Saizan> just putStr "\n"?
14:40:11 <newsham> unlines $ map render [a,b,c,d]
14:40:26 <zeeeee> kosmikus: fc5
14:40:45 <ndm> i think vcat means something else
14:41:02 <earthy> concat . intersperse "\n" . map render $ [a,b,c,d]
14:41:06 <ndm> the docs says its using $$, and that has an example where $$ puts two things on the same line
14:41:10 <glguy> unlines?
14:41:12 <ndm> earthy: unlines :)
14:41:29 <ndm> i can do it by returning a list of strings, but i'd rather do it all in teh combinators
14:41:31 <earthy> glguy, ndm: the concat . intersperse thingy teaches a more general method ;)
14:41:31 <bitshifter> >unlines ["a","b","c"]
14:41:34 <ndm> if its possible, and easy enough
14:41:36 <glguy> intercalate = (concat .) intersperse
14:41:44 <glguy> intercalate = (concat .). intersperse
14:41:50 <bitshifter> > unlines ["a","b","c"]
14:41:51 <lambdabot>  "a\nb\nc\n"
14:42:06 <bitshifter> > intersperse "\n" ["a","b","c"]
14:42:08 <lambdabot>  ["a","\n","b","\n","c"]
14:42:20 <lrrrr> hi there
14:42:25 <ndm> so, is there a way to do this in the pretty printer, or is using lines after the best way?
14:42:30 <lrrrr> can anybody help me with state monad ?
14:42:50 <chessguy> > map (++ "\n") ["a","b","c"]
14:42:52 <lambdabot>  ["a\n","b\n","c\n"]
14:43:06 <chessguy> > map (`++` "\n") ["a","b","c"]
14:43:06 <lambdabot>  Parse error
14:43:08 <glguy> lrrrr: not until you ask a question
14:43:24 <ndm> oh, just tried it using vcat
14:43:39 <ndm> works :) - the documentation could probably do with being a bit clearer!
14:43:43 <lisppaste2> lrrrr pasted "tail recursion with state monad" at http://paste.lisp.org/display/32325
14:43:49 * earthy `ap` sleep
14:44:14 <lrrrr> can 'compute' function be made tail-recursive somehow?
14:45:07 <glguy> compute n = modify (+n)
14:45:11 <glguy> there you go ;)
14:45:32 <Trevion> Durn!  I had just gotten started with ContT too.
14:47:03 <lrrrr> shame on me.. :)
14:47:09 <lrrrr> glguy> thanks :)
14:47:16 <dons> ?users
14:47:17 <lambdabot> Maximum users seen in #haskell: 288, currently: 270 (93.8%), active: 50 (18.5%)
14:47:18 <glguy> compute n = replicateM n iter2
14:47:26 <dons> heya dcoutts__
14:47:39 <dcoutts__> hia dons
14:47:40 <glguy> (this case would merit replicateM_
14:47:52 <jlouis> oh, that Applicative paper by McBride and Paterson is cool
14:47:53 <dons> dcoutts__: do we have the information for the Nice hotel all sorted?
14:48:02 <dons> dcoutts__: maybe you could forward the details to me :)
14:48:13 <jlouis> I didn't get the category-theory part, but the other things were insanely clever
14:48:16 <dcoutts__> dons: I've not seen anything recently
14:48:32 <dcoutts__> dons: I assume it was booked
14:49:21 <dons> do you have the address?
14:49:36 <dcoutts__> dons: at the moment, no
14:49:42 <glguy> Applicative is just Monad without (>>=) (while still having liftMn) right?
14:50:11 <dcoutts__> dons: I know it wasn't the park hotel but the one associated with it
14:50:30 <dcoutts__> dons: which is probably also listed on the conference web page
14:50:39 <dons> ok i'll look
14:50:49 <dcoutts__> dons: I've not got my full archive of email with me here, sorry
14:50:53 <lrrrr> glguy> replicateM_ thing actually doesn't look tail-recursive
14:51:01 * dcoutts__ is curently in Bergen
14:51:10 <lrrrr> glguy> it consumes all the stack space..
14:52:37 <lrrrr> iter2 = modify (+1) also does.. am i missing something important here?
14:56:44 <glguy> lrrrr: for what value of n?
14:57:00 <lrrrr> 1000000
14:58:07 <Igloo> @seen eivuokko
14:58:08 <lambdabot> I saw eivuokko leaving #darcs and #ghc 1m 17d 14h 43m 53s ago, and .
14:58:18 <Igloo> Hmm
14:58:49 <kosmikus> zeeeee: if it's you who also wrote the mail, then I already answered you ...
15:00:34 <dibblego> http://www.scdi.org/~avernet/projects/jaskell/ is that anyone here?
15:00:35 <IPI> Any one knows prolog here ? i need to write an equivalent function of haskell in prolog. can't figure it out ... it is very simple ... (working on sample exam questions).
15:00:36 <lambdabot> Title: Jaskell Project Home Page
15:00:47 <dibblego> IPI, you still writing reverse?
15:00:58 <IPI> dibblego, no , its one other question
15:01:04 <dibblego> what is it?
15:01:41 <dibblego> I assume you got reverse done?
15:02:04 <IPI> efg c list
15:02:05 <IPI> 	= c == fgh list
15:02:05 <IPI> fgh (x:y:xs)
15:02:05 <IPI> 	= fgh (y:xs)
15:02:05 <IPI> fgh (x:xs)
15:02:05 <IPI> 	= x
15:02:32 <IPI> well , sort of yes on that reverse ...
15:02:47 <IPI> on this haskell function, here is what i got:
15:03:14 <vininim> @eval
15:03:17 <vininim> err
15:03:23 <zeeeee> kosmikus: ah, i got it...thanks for the thorough response, i'll try it out
15:03:25 <IPI> efg(Key, List) :- fgh([X|Xs], Key =:= X.
15:03:46 <IPI> fgh([X|Xs] := X\= [], Xs = [].
15:03:47 <vininim> is 'projx (x,y) = x' enough for gets from State monad?
15:04:16 <IPI> fgh([X|Xs]):- Xs \= [], fgh(Xs).
15:04:55 <IPI> efg(Key, List) :- fgh([X|Xs], Key =:= X.
15:04:55 <IPI> fgh([X|Xs] := X\= [], Xs = [].
15:04:55 <IPI> fgh([X|Xs]):- Xs \= [], fgh(Xs).
15:05:11 <IPI> so dibblego , is this even close to what the equiv. code should be ?
15:05:27 <dibblego> IPI, I don't know prolog that well
15:06:05 <IPI> np
15:06:46 <chr1s> hey!
15:06:59 <chr1s> I've got a very basic question
15:07:12 <chr1s> suppose I have a = '\\'
15:07:18 <chr1s> and b = 'n'
15:07:32 <chr1s> how do I combine a and b to '\n'
15:07:42 <chr1s> or "\n" would be ok too
15:08:29 <newsham> are there any advocacy docs on using haskell for multithreaded programming?
15:08:31 <dibblego> > length "\n"
15:08:32 <lambdabot>  1
15:08:43 <dibblego> chr1s, think about that for a moment
15:08:52 <newsham> (ie. why use haskell for multithreading instead of other language)
15:09:01 <chr1s> dibblego: that's one
15:09:27 <chr1s> but lenght (a:b) = 2
15:09:30 <dibblego> chr1s, how would you get a list of length 1 from 2 characters?
15:09:44 <dibblego> you might mean a:[b]
15:10:03 <chr1s> yes, I'm sorry
15:10:09 <newsham> a:b:[]
15:10:24 <chr1s> dibblego: well, head will get a list of length 1
15:10:31 <chr1s> but that won't do the trick
15:10:32 <dibblego> no it won't
15:10:37 <dibblego> ?type head
15:10:39 <lambdabot> forall a. [a] -> a
15:10:44 <dibblego> it doesn't return a list
15:10:53 <newsham> if a is a list it does :)
15:11:02 <newsham> > head [[1],[2,3]]
15:11:04 <lambdabot>  [1]
15:11:13 <chr1s> hm
15:11:18 <chr1s> concat...maybe?
15:11:31 <dibblego> let f '\\' 'n' = '\n'; f_ _ = error "todo" in f '\\' 'n'
15:11:35 <dibblego> > let f '\\' 'n' = '\n'; f_ _ = error "todo" in f '\\' 'n'
15:11:37 <lambdabot>  '\n'
15:11:54 <vininim> let projx (x,y) = x in  gets projx (1,1)
15:12:10 <chr1s> dibblego: yeah, that's easy, but I want to do it for other characters as well :)
15:12:20 <dibblego> chr1s, that's my point, you'll have to
15:12:30 <chr1s> hm
15:12:36 <dibblego> how else do you get a list of length 1 from 2 characters?
15:13:22 <vininim> let projx (x,y) = x in  gets projx (State (1,1) 1)
15:13:25 <vininim> o_O
15:13:31 <sorear> projx = fst
15:13:46 <vininim> yeah, but it doesn't work anyway
15:14:09 <chr1s> ok, thanks :)
15:16:39 <chr1s> so, next question: is there a standard way of detecting something is escaped?
15:17:00 <sorear> escaped?  like \\ ?
15:17:00 <chr1s> i.e., return True on '\n', '\t', '\\', etc.
15:17:06 <dibblego> let f '\n' = True; f _ = False in f '\n'
15:17:10 <dibblego> > let f '\n' = True; f _ = False in f '\n'
15:17:12 <lambdabot>  True
15:17:30 <dibblego> you do realise that '\n' is a *representation* of *one* character?
15:17:40 <chr1s> yes
15:17:48 <chr1s> that's the whole problem
15:17:50 <dibblego> whether or not "something" is "escaped" is up to the *representation*
15:17:52 <newsham> you want    let f "\\n" = True
15:17:52 <bd_> > let f c = 0 /= length (filter (== '\\') $ show c) in f '\n'
15:17:54 <lambdabot>  True
15:17:56 <dons> > let n = show '\n' in n `isPrefixOf` "\nfoo"
15:17:56 <bd_> > let f c = 0 /= length (filter (== '\\') $ show c) in f 'n'
15:17:58 <lambdabot>  False
15:17:59 <lambdabot>  False
15:18:27 <dons> > let n = show '\n' in n `isPrefixOf` "\\nfoo"
15:18:29 <lambdabot>  False
15:18:29 <bd_> that'll let you know if it's escaped in the haskell show implementation anyway
15:18:39 <bd_> > show '\n'
15:18:41 <lambdabot>  "'\\n'"
15:18:44 <chr1s> wow, cool
15:19:18 <dons> > let n = "\\n" in n `isPrefixOf` "\\nfoo"
15:19:20 <lambdabot>  True
15:19:39 <sorear> ?where readp
15:19:40 <lambdabot> I know nothing about readp.
15:20:07 <bd_> :t readp
15:20:08 <lambdabot> Not in scope: `readp'
15:20:18 <newsham> length (show ch) > 3
15:20:30 <chr1s> the show's a really good trick! thanks!
15:25:02 <vininim> Is the 'gets' function from the state monad class used so that you don't have to provide state transformers for acessing your state?
15:25:41 <joelr1> good evening
15:25:46 <joelr1> Lemmih: ping
15:26:04 <newsham> hey joel.
15:26:33 <joelr1> kinda quiet here. hi newsham
15:27:53 <dons> ?users
15:27:54 <lambdabot> Maximum users seen in #haskell: 288, currently: 264 (91.7%), active: 55 (20.8%)
15:28:02 <joelr1> dons: hehe
15:28:11 <dons> hmm. active: 55 is the highest i've seen,
15:28:13 <joelr1> dons: did you ever ask Lemmih about the status of hs-plugins
15:28:22 <dons> haven't seen him in the last couple of days
15:28:29 <joelr1> ok
15:28:31 <dons> but i fully expect to get hs-plugins done by the hackathon
15:28:35 <dons> ?wiki Hac_2007
15:28:35 <lambdabot> http://www.haskell.org/haskellwiki/Hac_2007
15:28:39 <dons> (we're having a hackathon!)_
15:28:43 <vininim> :wiki State
15:28:47 <vininim> ?wiki State
15:28:48 <lambdabot> http://www.haskell.org/haskellwiki/State
15:28:51 <dons> get some libraries out there!
15:28:58 <dons> get hackage/cpan up
15:29:06 * dons thinks this will make joelr1 happy 
15:29:20 <joelr1> dons: very happe!
15:29:22 <joelr1> happy :D
15:29:37 <dons> have you seen the new library constructoin guide?
15:29:37 <mbishop> a module distribution system would make me happy as well :P
15:29:46 <newsham> cpan like?
15:29:59 <dons> mbishop: hmm? isn't that what cabal/hackage is for?
15:30:16 <joelr1> newsham: i envision a futures and options trading platform
15:30:18 <dons> i.e. cabal-get lambdabot ; cabal-put ruby-killer ; ...
15:30:38 <joelr1> newsham: very much tied to the mac, most likely
15:30:41 <newsham> which parts?  entirety?  server?  client?  interop with anything existing?
15:30:47 <sorear> apt-get install apt-hackage-lambdabot
15:30:49 <mbishop> I don't know, is it? I want to be able to just install modules from the command line, have them put in the proper place on the system and Just Work
15:30:50 <newsham> web based?
15:30:54 <chessguy> ?hoogle State
15:30:54 <dons> joelr1: in case you haven't seen it, we're starting a big libraries and infrastructure push: starting here http://haskell.org/haskellwiki/How_to_write_a_Haskell_program
15:30:55 <lambdabot> Control.Monad.State :: module
15:30:55 <lambdabot> Control.Monad.State.State :: (s -> (a, s)) -> State s a
15:30:55 <lambdabot> Control.Monad.State.State :: newtype State s a
15:30:56 <lambdabot> Title: How to write a Haskell program - HaskellWiki
15:31:10 <joelr1> why the mac? well, there's core-data, for example, the data storage framework. meaning that i don't have to reinvent that wheel
15:31:10 <dons> mbishop: exactly. that's the goal of cabal + hackage
15:31:22 <dons> a central server, with tools to pull, chase, build packages
15:31:32 <joelr1> dons: lots of news! thank you!
15:31:40 <joelr1> newsham: no, cocoa based
15:31:41 <newsham> dons: cabal + hackage -> cabage?
15:31:45 <dons> heh
15:32:04 <joelr1> newsham: hoc is the objective-c bindings library for mac osx
15:32:36 <joelr1> dons: awesome stuff! i volunteer to be a guinea pig
15:32:36 <chessguy> ok guys, i'm planning on rebuilding my laptop here to be a lean, mean, haskell-developing machine. what distro do i want?
15:32:49 <dons> joelr1: great.
15:32:58 <dons> chessguy: hmm, debian or gentoo?
15:33:13 * chessguy doesn't have a clue
15:33:15 <joelr1> newsham: i don't even need an interface other than the command line initially
15:33:16 <dons> (debian's got Igloo behind it, with the ghc 6.6 stuff all in apt)
15:33:41 <dons> joelr1: hvae you played around with the new smp runtime yet?
15:34:07 <joelr1> dons: not at all. i don't think so. why? this is certainly one of the reasons for me to use haskell.
15:34:20 <dons> we've got a 16 core box arriving this week, dedicated for working on the new parallel arrays library.
15:34:22 <sorear> Would it work/be a good idea to set up hackage.haskell.org/debian/ using a daily-compile-updated-packages script?
15:34:26 <dons> oh, just thought you'd like to play with it :) its fun
15:34:30 <joelr1> dons: what i'm truly looking for is data parallel haskell. arrays are still slow, i think
15:34:37 <dons> right.
15:34:42 <dons> ?where dph
15:34:42 <lambdabot> http://haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
15:34:43 <joelr1> dons: you are reading my mind :D
15:34:46 <dons> that's what the new box is for :)
15:34:57 <dons> bytestring-style fast single and multiple core arrays
15:35:06 * shapr boings furiously
15:35:15 <joelr1> dons: i want huge time series arrays and i have a dual-core mac
15:35:19 <dons> sorear: hmm. nice idea
15:35:31 <newsham> are there any advocacy docs on using haskell for multithreaded programming?
15:35:36 <newsham> (ie. why use haskell for multithreading instead of other language)
15:35:51 <mbishop> I think dons put one on reddit
15:35:53 <sorear> ?go multi-core STM now
15:35:56 <lambdabot> http://www.acmqueue.com/modules.php?name=Content&pa=showpage&pid=444&page=4
15:35:57 <lambdabot> Title: ACM Queue - Unlocking Concurrency - Multicore programming with transactional mem ...
15:36:14 <sorear> I *think* that is it...
15:36:35 <joelr1> dons: i would be in haven if i could do time series correlation analysis on arrays bigger than memory. fast data-parallel arrays that fit in memory would be great too
15:36:37 <jlouis> newsham, the advantage is that things going on in STM a is not in IO a. That makes for some rather interesting consequences
15:37:01 <newsham> jlouis: i want an URL, not an explanation :)
15:37:09 <jlouis> you know what STM a does?
15:37:22 <newsham> this isnt for myself.
15:38:15 <jlouis> ?go composeable memory transactions
15:38:17 <lambdabot> http://programming.reddit.com/info/ld0w/related
15:38:30 <joelr1> dons: are you guys gonna be working on nested arrays? convenience w/o the speed
15:38:56 <newsham> newsham@lenoxp$ ping programming.reddit.com
15:38:57 <newsham> ping: unknown host programming.reddit.com
15:38:57 <newsham> :(
15:39:28 <shapr> is broke
15:39:36 <shapr> the dns record is toasted somehow
15:39:38 <jlouis> http://research.microsoft.com/Users/simonpj/papers/stm/stm.pdf
15:39:38 <joelr1> shapr: hi
15:39:41 <jlouis> newsham, ^^
15:39:42 <dons> joelr1: both nested and flat
15:39:48 <shapr> hiya joelr1, how's code?
15:39:50 <newsham> is that an advocacy paper?
15:39:54 <dons> its probably not widely known, but microsoft is funding this for 3 years
15:39:57 <jlouis> newsham, no ;)
15:40:04 <jlouis> its how it works in Haskell
15:40:06 <newsham> are there any advocacy docs on using haskell for multithreaded programming?
15:40:08 <joelr1> dons: you must be kidding me! funding what exactly
15:40:15 <joelr1> shapr: so far so good!
15:40:32 * jlouis goes and buys Vista
15:40:36 <dons> they're paying for Roman Leschinskiy to write the code, for a 3 year project
15:40:39 <dons> the DPH project
15:40:41 <newsham> I need URL to give to someone who says "ugh!  debugging multithreaded code sucks!"
15:40:43 <jlouis> joelr1, still hacking Common Lisp (LispWorks)
15:40:47 <jlouis> ?
15:40:53 <joelr1> dons: any clues if arrays can be bigger than memory? suggestions on to work with such arrays?
15:40:56 <dons> newsham: ok, there's the multiproc stuff
15:41:01 <dons> (research papers)
15:41:01 <joelr1> jlouis: nope. dunno why i bought it :(
15:41:06 <vininim> How do I test (modify (+1)) in the interpreter?
15:41:09 <dons> joelr1: lazy ones can be bigger than memory
15:41:15 <joelr1> dons: that's awesome! i wonder why microsoft needs dph
15:41:19 <jlouis> joelr1, the indulging homepage maybe?
15:41:24 <dons> > runState (modify (+1)) 1
15:41:24 <joelr1> dons: lazy arrays?
15:41:25 <lambdabot>  ((),2)
15:41:32 <dons> joelr1: like Data.ByteString.Lazy
15:41:48 <joelr1> jlouis: mmm... dunno... :) it's all at http://wagerlabs.com these days
15:41:50 <lambdabot> Title: Tenerife Skunkworks&mdash;Trading & Technology
15:41:59 <jlouis> I had a toss with Common Lisp. I gave up, came back to Haskell and began looking at cool stuff instead ;)
15:42:00 <dons> yeah, I gess microsoft is really really looking for a way into the parallel programming world
15:42:02 <joelr1> dons: oh, i was thinking about arrays of floats or doubles
15:42:08 <dons> hence they've hired all the STM researchers, and paying for DPH
15:42:15 <jlouis> OTOH, I don't do FP-intensive shit
15:42:20 <dons> joelr1: right, so you want Lazy arrays on any unboxed value
15:42:29 <dons> joelr1: which we don't have, but could be done.
15:42:52 <joelr1> dons: that's what i'm hinting at. any idea how that can be done?
15:43:00 <jlouis> newsham, STM's can't deadlock. They can starve, but they can't deadlock
15:43:09 <jlouis> (and the starvation problem can be solved)
15:43:13 <joelr1> jlouis: well... i did a haskell project a year ago.
15:43:19 <dons> ok, we take Data.ByteString.Lazy, and sjanssen generalised bytestring vectors, and combine them
15:43:19 <nominolo> oh, joelr1 is a CL to Haskell convert?
15:43:20 <jlouis> Poker server?
15:43:24 <joelr1> jlouis: lisp pays my bills right now
15:43:34 <dons> newsham: http://www.haskell.org/ghc/dist/current/docs/users_guide/lang-parallel.html
15:43:37 <lambdabot> Title: 7.15. Concurrent and Parallel Haskell, http://tinyurl.com/zqwkf
15:43:38 * joelr1 and haskell go a long way back
15:43:39 <jlouis> nominolo, joelr1 hacks anything, I guess ;)
15:44:03 <joelr1> jlouis: no, the test harness for a poker server that i ended up rewriting in erlang
15:44:04 <IPI> The signature for two of three functions, a, b, and c are given below.
15:44:04 <IPI> a ::
15:44:04 <IPI> b :: Ord a => [(a,b,c)] -> [(a,b,c)]
15:44:04 <IPI> c :: [(a,b,c)] -> [([a], (b,c))]
15:44:04 <IPI> The following composition is executed.
15:44:05 <IPI> c â¢ b â¢ (a(x:xs)) y:ys
15:44:07 <IPI> Part (a)  Provide the signature for function a in the space provided below.
15:44:08 <newsham> jlouis: thats not an advocacy page :(
15:44:09 <IPI> a ::
15:44:10 * joelr1 bows
15:44:15 <dons> newsham: perhaps? which should lead you to other resrources
15:44:18 <joelr1> jlouis:  ;)
15:44:19 <IPI> any idea what signature of a is anyone ??
15:44:21 <dons> IPI: best to @paste that kind of thing
15:44:31 <nominolo> ah, you're the poker-server guy.  :)
15:44:35 <IPI> sorry dons :)
15:44:46 <jlouis> newsham, its hard when there is next to no advocacy outh there. Maybe the ACM queue article is worth something. I haven't read it
15:44:50 <joelr1> nominolo: yes, i am
15:44:55 <newsham> *nod* thanks.
15:45:03 <dons> newsham: but yes, we do need a compartive study page
15:45:08 * jlouis does a magic Rain-dance to make more Ross Paterson papers fall from the sky
15:45:21 <dons> comparing ghc's par, stm, smp and dph stuff, with erlang, python, ...
15:45:23 <joelr1> i find lisp ... to easy, actually. and the really good lisp i don't want to pay for.
15:45:30 <newsham> sounds like what concurrent haskell needs is some advocacy :)
15:45:34 <joelr1> haskell is tough but deeply satisfying
15:45:35 <jlouis> token-passing, mutex locking. CML, etc
15:45:52 <jlouis> joelr1, I find CL insanely hard
15:45:54 <nominolo> joelr1: last time i read, you were comparing haskell, erlang and CL, and i think you reported that Haskell+SMP was quite unstable.  has it changed now?
15:45:58 <dons> since there are some unique features in haskell's paralellism: particularly the purity of the language makes some new kinds of problems tractable: such as transparently parallel (DPH) arrays
15:46:01 <jlouis> haskell is bliss however
15:46:04 <newsham> joelr: its actually not so bad, other than having to read academic papers written by phd's to learn how to use language features.
15:46:17 <dons> nominolo: I think he wasn't using haskell+SMP
15:46:22 <dons> nominolo: since that's quite new
15:46:26 <newsham> in my opinion its a documentation problem not a language problem.
15:46:30 <dons> the were stability problems with ghc on windows though
15:46:30 <joelr1> nominolo: i did not say unstable, i think. i just changed my mind about being a pioneer ;-)
15:46:38 <dons> which joelr1 exaimined in detail :)
15:47:04 <joelr1> dons: he's referring to a new comparison that i made. see my homepage.
15:47:09 <dons> ah ok.
15:47:28 <joelr1> let me dig that up... http://wagerlabs.com/2006/12/8/re-birth-of-a-trading-platform
15:47:30 <lambdabot> Title: Tenerife Skunkworks&mdash;Trading & Technology
15:47:38 <joelr1> dons: that one
15:47:41 <shapr> dons: whoa, DPH is ms funded?
15:47:56 <dons> you know, your original article about the 3 windows-related rts bugs is the most widely used reference when people want to say "don't use haskell" ;)
15:48:01 <shapr> Sounds like ms has a clue then.
15:48:08 <joelr1> dons: i started trading and need a trading platform
15:48:10 <dons> "Look, there were these runtime bugs on windows! phear!"
15:48:15 <joelr1> dons: ugh...
15:48:20 <joelr1> dons: well...
15:48:20 <newsham> dons: not the "its hard to serialize data in haskell" paper?
15:48:22 <shapr> yeah, sort of sucks.
15:48:26 <joelr1> dons: i hope to change that!
15:48:42 <edi> 'lo
15:48:43 <joelr1> the haskell category blows everything else away in my blog
15:48:50 <joelr1> people are clamoring for haskell articles
15:48:51 <edi> Oops, nickname... I'm xerox anyway.
15:48:59 <joelr1> the urge must be satisfied
15:49:03 <joelr1> the thirst quenched!
15:49:09 <shapr> hi xerox!
15:49:09 <joelr1> image is nothing
15:49:15 <joelr1> thirst is everything
15:49:22 <joelr1> obey the thirst!
15:49:22 <dons> joelr1: hmm, maybe we should syndicate your haskell stuff to planet.haskell.org
15:49:29 <shapr> newsham: Did you see musasabi's most recent code for serializing lazy bytestrings?
15:49:31 <joelr1> dons: sure, if you want
15:49:32 <edi> shapr: I like this nick more than xerox, but everybody knows me as the latter, argh! (:
15:49:41 <dons> joelr1: just ping ibid, in this channel , with the rss feed
15:49:52 <jlouis> dons, do ya need a ph.d more for that DPH? (Though I am not even B.A. Yet :P)
15:49:53 * IPI is stuck on this question ... any help is greatly appreciated ... http://www.rafb.net/paste/results/NmDcPU54.html
15:50:00 <joelr1> dons: but seriously, i'll probably have some stm and haskell advocacy soon
15:50:01 <dons> shapr: yeah, the lazy bytestring serialisatoin stuff is one of my goals for the hackathon
15:50:05 <joelr1> ibid: ping
15:50:09 <dons> good binary serialisation in base is key
15:50:15 <dons> (wouldn't you agree joel? :)
15:50:19 <joelr1> dons: yes, yes!!!!
15:50:24 <jlouis> haha
15:50:34 <dons> and now we have these fast bytestrings for doing byte-wise stuff
15:50:38 <joelr1> dons: i'm dying to see a persistence layer for haskell
15:50:46 <dons> musasabi's serialisation code from HAppS on top of that makes good sense
15:50:49 <shapr> edi: well, link edi to xerox and stick with it.
15:50:50 <jlouis> MACID
15:50:59 <joelr1> dons: unfortunately, my template haskell is nowhere near good
15:51:02 <edi> shapr: yeah.
15:51:05 <jlouis> MACID in HAppsS is quite cool
15:51:08 <newsham> happs is nice in that it serializes everything for you (and atomicity)
15:51:21 <shapr> edi: You know about NICKSERV link already?
15:51:32 <edi> shapr: yeah, those nicks are linked from some time (:
15:51:40 <dons> yeah, we need to factor out some of these HAppS libs
15:51:44 <dons> into core/extralibs stuff
15:51:44 <shapr> newsham: Yeah, but it doesn't yet infer lazy bytestring serializers yet. I can barely wait :-)
15:51:50 <shapr> edi: oh ok :-)
15:51:59 <edi> shapr: but I can't decide, hehe.
15:52:08 <shapr> dons: Truly, can you suggest specifics?
15:52:19 <edi> shapr: edi is nice because it is the name of ... let me find the explanatori wikipedia page.
15:52:25 <shapr> edi: I nearly switched to shaper for awhile... but many people were horrified.
15:52:35 <dons> well, the web server should be a standaone package
15:52:37 <jlouis> factor :: (Factorizable f) => f a b -> (a, b)
15:52:39 <jlouis> hmm
15:52:48 <astrolabe> @users
15:52:48 <lambdabot> Maximum users seen in #haskell: 288, currently: 257 (89.2%), active: 49 (19.1%)
15:53:04 <edi> shapr: http://en.wikipedia.org/wiki/Little_Helper_(Disney)
15:53:08 <shapr> I've been shapr for almost fifteen years.
15:53:29 <dons> and the serialisation stuff can be the core of a new Data.Serial or something
15:53:51 <edi> I use the computer from that long, but I didn't have internet from the beginning...
15:53:54 <astrolabe> dons: is there an up to data graph of #haskell numbers?
15:53:54 <dons> joelr1: i'd be interested in any suggestions of missing functionality in library you'd like to see/need
15:54:12 <dons> ?where stats
15:54:13 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
15:54:14 <shapr> @where stats
15:54:15 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
15:54:21 <dons> astrolabe: we seem to be around #python in size atm
15:54:25 <sorear> I'm currently working on the generic serialization library
15:54:26 <joelr1> dons: oh, believe me, you will hear from me :-)
15:54:27 <dons> we've been above and below it all week
15:54:38 <joelr1> i just have to get started
15:54:38 <dons> joelr1: we have a new page for making library suggestoins
15:54:43 <dons> in preparation for the hackathon
15:54:44 <joelr1> ok
15:55:00 <dons> http://haskell.org/haskellwiki/Recommendations
15:55:01 <lambdabot> Title: Wanted libraries - HaskellWiki
15:55:08 <dons> (from http://haskell.org/haskellwiki/Libraries_and_tools)
15:55:09 <lambdabot> Title: Libraries and tools - HaskellWiki
15:55:18 <dons> which is growing by about 5 libs a week currently (!)
15:55:46 <edi> shapr: wow, you had a different name for "Archimedes" too!...
15:55:51 <edi> http://en.wikipedia.org/wiki/Gyro_Gearloose
15:56:04 <dons> shapr: yeah, MS Research wants data parallel arrays
15:56:15 <shapr> smart
15:56:38 <shapr> DPH is the shortest path to make windows scale well.
15:56:39 <astrolabe> @dons: thanks.  It would be nice to have something that averages over a much shorter period.
15:56:40 <lambdabot> thanks.  It would be nice to have something that averages over a much shorter period. not available
15:56:53 <shapr> heh
15:56:57 * astrolabe confuses dons with lambdabot :)
15:57:00 <shapr> @quote
15:57:01 <lambdabot> kyevan says: I haven't tried learning C++, from what I've seen, simple c++ is readable pretty easily, complex C++ makes me want to hide in the closet.  (I'm not refering to my sexuality, either)
15:57:35 <jlouis> @karma+ kyevan
15:57:36 <lambdabot> kyevan's karma raised to 2.
15:58:03 <mbishop> @quote
15:58:04 <lambdabot> sjanssen says: Quoth the Prelude, Chapter 6, verse 4:  Yeah verily shall repeat floweth cons cells over.
15:58:22 <dons> sorear: have you looked at the other serialisation libs, btw?
15:58:24 <astrolabe> dons: sorry, I've just found it
15:58:58 <dons> sorear: http://www.haskell.org/haskellwiki/Libraries_and_tools/Data_structures#Serialising_data
15:59:00 <lambdabot> Title: Libraries and tools/Data structures - HaskellWiki, http://tinyurl.com/y5abp4
15:59:35 <ptaron> Hey guys, I'm working through the haskell.org/tutorial, currently on chapter 7
15:59:40 <jlouis> Damn, those quotes kick ass
16:00:03 <ptaron> There's a code sample there that's not working in GHC 6.6
16:00:23 <ptaron> main                    =  do c <- getChar putChar c
16:00:29 <ptaron>   putChar c
16:00:35 <dons> missing a ;
16:00:48 <dons> main = do x <- getChar ; putChar c; putChar c -- ?
16:00:49 <ptaron> Where should it go? I don't have a sense for that yet. :)
16:00:51 <ptaron> ah
16:01:05 <ptaron> err, the extra putChar was an IRC client artifact
16:01:13 <dons> ok :)
16:01:27 <jlouis> x <- getChar?
16:01:31 <jlouis> nah, c <- getChar
16:01:37 <astrolabe> 'dcoutts_ has quite a potty mouth. 0.0% words were foul language.
16:01:37 <astrolabe> Pseudonym also makes sailors blush, 0.0% of the time.'
16:01:46 <sorear> Two days ago it was suggested that "if it uses Data.Generics it should be Data.Generics.Serialization".  How does this interact with teh new Data.Serial proposal?
16:02:12 <dons> sorear: its not a proposal yet :) but I agree that Data.Generics.Serial would be a good name...
16:02:39 <dons> i.e. we don't have Text.PrettyPrint_ing_ so we shouldn't have .Serial_isation_
16:03:09 <sjanssen> Data.Monading
16:03:11 <dons> mm, has reddit been down for nearly 24 hours now
16:03:15 <sjanssen> erm, Control.Monading
16:03:20 <sorear> PrettyPrint is a verb, Serial is a noun
16:03:36 <sorear> Serialize?
16:03:37 <sjanssen> dons: it was up a few hours ago
16:03:38 <dons> how will I find out what is new in the world of lisp and django!
16:04:00 <dons> http://reddit.com
16:04:08 <dons> nope.
16:04:09 <sjanssen> and by few I mean as many as 6 ;)
16:04:47 <sjanssen> dons: reddit is working for me
16:04:52 <dons> huh
16:04:56 <Pseudonym> I don't make sailors blush, I just make them confused.
16:05:07 <Pseudonym> They don't know that I'm chewing them out.
16:05:12 <Pseudonym> Stupid sailors...
16:05:35 <mbishop> dons: worse yet, how are we going to find out what new, uninteresting thing Douglas Adam has written about on his blog, or what Joel thinks about <insert buzzword here>!
16:05:44 <dons> sjanssen: ah, see I get: No DNS records
16:05:46 <dons> mbishop: hehe
16:06:08 <dons> sjanssen: so if there was some DNS attack, it might take a little while to propgagate the fix to sunny .au
16:07:14 <dons> $ host reddit.com
16:07:15 <dons> reddit.com A record currently not presen
16:07:43 <mbishop> reddit.com isn't working for me either
16:07:59 <jgrimes> reddit isn't working for me either, due to the same reason. :|
16:08:02 <mbishop> www.reddit.com redirect to reddit.com, but it worked heh
16:08:02 <ptaron> Hmmm, for every example that I'm trying to run from the IO tutorial (http://www.haskell.org/tutorial/io.html) I'm getting errors saying "The last statement in a 'do' construct must be an expression." How should I be thinking about these errors? Where should I read to understand what the heck that means? :)
16:08:03 <lambdabot> Title: A Gentle Introduction to Haskell: IO
16:08:10 <jlouis> Here is your fix:
16:08:11 <jlouis> succubus% host reddit.com
16:08:11 <jlouis> reddit.com has address 72.5.28.218
16:08:25 <jlouis> But don't tell the police, ok
16:08:31 <dons> ptaron: hmm. can you @paste the code you're using
16:08:32 <mbishop> heh
16:08:33 <dons> ?paste <--
16:08:33 <lambdabot> http://paste.lisp.org/new/haskell
16:08:37 <sjanssen> ptaron: probably an indentation issue
16:09:25 <lisppaste2> ptaron pasted "Example from http://www.haskell.org/tutorial/io.html" at http://paste.lisp.org/display/32333
16:10:01 <sjanssen> ptaron: make the "return (c:l)" start in the same column as "l <- getLine"
16:11:36 <astrolabe> and the if start at the same line as the 'c' above
16:12:01 <ptaron> OK.
16:12:17 <dons> mmm did peopel know about the import haskellembed module in python?
16:12:32 <astrolabe> I didn't
16:12:38 <dons> ah but its not released yet!
16:12:41 <dons> http://www.kuarepoti-dju.net/index.php?p=86
16:12:43 <lambdabot> Title: kuarepoti-dju Â» Advanced Python Hacking II
16:13:09 <astrolabe> I've really got a strong feeling that haskell is taking off.
16:13:41 <dons> i hope so. we have the technology
16:13:53 <dons> now we just need the manpower
16:14:21 <ptaron> Thanks, guys--that fixed the errors about do. Now I'm trying to print the line :)
16:15:01 <astrolabe> dons: I'm not sure that we have the technology.  I don't think we have a good enough debugger :(
16:15:10 <dons> we have the new ghci debugger
16:15:14 <dons> should be in the next stable release
16:15:22 <IPI> Do you guys know what dot (.) operator here does : c â¢ b â¢ (a(x:xs)) y:ys  does it feed the input of each function to the other one ?
16:15:23 <astrolabe> dons: cool!
16:15:30 <dons> (pepe's working on it during the hackathon, too)
16:15:36 <dons> IPI: yeah
16:15:38 <dons> :t (.)
16:15:39 <Excedrin> IPI: . is function composition
16:15:39 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
16:16:01 <IPI> but the 'a' function takes in a list ... what is y:ys then?
16:16:01 <dons> :t (ord . toUpper . toLower) 'X'
16:16:03 <lambdabot> Int
16:16:21 <astrolabe> dons:when is the next ghc release due?
16:16:23 <Excedrin> y:ys is pattern matching a list into head and tail
16:16:27 <vininim> Now that I tested monad transformations I just need to have a global State :/
16:16:35 <Excedrin> y = head of the list, ys = tail of the list
16:16:43 <IPI> Excedrin, yes, but does that mean that the 'a' function takes in two lists?
16:16:49 <dons> vininim: why? wouldn't you use runState from main to setup a (global) state monad?
16:17:25 <dons> astrolabe: a few months. until then the debugger should be in the head
16:17:33 <Excedrin> IPI: oh, sorry, in that context, xs is some list, x is prepended to it, then the new list is passed to a
16:17:55 <dons> i really hope haskell takes off, i don't want our industry to be programming in something like C++ in 20 years time..
16:18:03 <dons> our species can't afford it!
16:18:31 <ray> haskell: saving humanity from global warming
16:18:33 <astrolabe> dons: I'm pretty sure a lot of people will still be using C++, I just hope I'm not one of them.
16:18:53 <IPI> Excedrin, i am confused on what a takes in .. 'a' takes in a list (having at a patter of x:xs) , but then y:ys gets fed to which function?
16:19:07 <goltrpoat> if i'm still programming in c++ 20 years from now, i'll probably move to harrisburg and spend the rest of my days making furniture and whittling toy trains.
16:19:11 <ptaron> speaking of that... is there some bank of simple programs illustrating haskell principles?
16:19:27 <dons> ptaron: have a look on haskell.org
16:19:29 <astrolabe> ptaron: have you read the prelude?
16:19:50 <dons> ptaron: you could try solving, http://haskell.org/haskellwiki/99_Haskell_exercises
16:19:51 <lambdabot> Title: 99 Haskell exercises - HaskellWiki
16:19:56 <ptaron> I'm reading through the tutorial, and the programs there aren't complete. What's the prelude?
16:19:57 <astrolabe> and where was that page of examples that shapr used to point to?
16:20:02 <goltrpoat> ptaron:  take a look at http://haskell.org/haskellwiki/Category:Idioms as well
16:20:03 <lambdabot> Title: Category:Idioms - HaskellWiki
16:20:14 <clanehin> dons: you need manpower?
16:20:23 <dons> ?wiki Example_code
16:20:24 <lambdabot> http://www.haskell.org/haskellwiki/Example_code
16:20:35 <Excedrin> IPI: c . b is some new function that apparently takes two parameters, the first parameter is the result of "a (x:xs)" the 2nd parameter is y:ys
16:20:37 <dons> clanehin: yeah, testing, releasing new library, making sure the runtime work eveywhere
16:20:44 <astrolabe> ptaron:   prelude : haskell :: stdlib : c
16:20:46 <dons> manpower issues improve stability, get more libraries done
16:20:55 <goltrpoat> ptaron:  http://haskell.org/haskellwiki/Blow_your_mind in particular
16:20:56 <lambdabot> Title: Blow your mind - HaskellWiki
16:21:43 <vininim> dons: I have diferentes funcions that are going to use the state, and they are all spilled in different modules
16:21:56 <astrolabe> ptaron: http://www.haskell.org/onlinereport/standard-prelude.html
16:21:57 <lambdabot> Title: The Haskell 98 Report: Standard Prelude
16:22:03 <IPI> Excedrin,  could you please check the function i have pasted here : http://www.rafb.net/paste/results/NmDcPU54.html this is where i am stuck ... i need to get the signature of 'a'
16:22:10 <vininim> and they are being called in a callback way
16:22:17 <ptaron> Bookmarking! Thanks for the links, guys!
16:22:34 <clanehin> I would be happy to offer some manpower, if only someone in the know could direct me to a specific task and reasonable size
16:22:56 <dons> vininim: ok.  that's fine. they should be in the state monad then. -- since they access a global state
16:23:12 <[d-_-b]> hi... someone knows how to use the lib System.Random ??
16:23:33 <sjanssen> [d-_-b]: yes, someone does know how to use System.Random ;)
16:23:50 <sjanssen> [d-_-b]: feel free to ask your question
16:24:01 <dons> > take 3 (randoms (mkStdGen 42)) :: [Int]
16:24:02 <lambdabot>  [-1673289139,1483475230,-825569446]
16:24:32 <[d-_-b]> I want to creat a random number between 0-10
16:24:37 <ptaron> Another question... I don't quite understand the syntax Name :: a -> a -> a, and this seems quite crucial to understand.
16:24:42 <ptaron> How should one read this?
16:25:01 <dibblego> given an 'a', then another 'a', return an 'a'
16:25:09 <ray> Name has type function from a to function from a to a
16:25:13 <dons> > take 3 (randomRs (0,1) (mkStdGen 42)) :: [Int]
16:25:15 <lambdabot>  [1,1,1]
16:25:24 <dons> > take 3 (randomRs (0,10) (mkStdGen 42)) :: [Int]
16:25:26 <lambdabot>  [4,9,3]
16:25:27 <dibblego> interface F<a>{a f(a a1, a a2);} // without partial application (you'll need "design patterns" for that)
16:25:35 <dibblego> s/f/Name
16:25:46 <dons> > randomRs (0,10) (mkStdGen 42)
16:25:48 <lambdabot>  [4,9,3,3,5,8,6,5,4,8,4,8,6,5,3,4,8,5,7,1,10,10,5,3,5,4,6,5,7,9,1,6,6,4,4,2,8...
16:26:14 <[d-_-b]> the mkStdGen 42 is for what?
16:26:20 <ptaron> dibblego, rons, are those the same answers? they sound like they're quite different
16:26:20 <dons> that's jsut a seed value
16:26:34 <notsmack> ptaron: read about "currying"
16:26:38 <notsmack> they're the same because of it
16:26:43 <ray> ptaron: they mean the same thing
16:26:44 <ray> yeah
16:26:49 <dibblego> ptaron, same meaning, ray's is more accurate and Haskell-like
16:27:01 <astrolabe> ptaron: have you seen yaht?
16:27:06 <astrolabe> @where yaht
16:27:07 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
16:27:47 <dibblego> there is a section in Martin Fowler's book "Refactoring" called "Replace Parameter With Method"
16:27:48 <ptaron> Ah, the PDF. I saw it and went for an HTML tutorial because I hate adobe reader. :)
16:28:00 <ptaron> Opening it now
16:28:01 <ray> despite the format, it's pretty good
16:28:08 <dibblego> he could have just said "Java sucks, it doesn't have partial application"
16:28:09 <dons> [d-_-b]: so you can use newStdGen if you want a different random seed
16:28:30 <dibblego> but that won't sell his books
16:28:30 <dons> dibblego: you still work at a java company, right ?   ;)
16:28:38 <dibblego> dons, yep :)
16:28:43 <dons> or is it an FP company yet?
16:28:44 <dibblego> dons, writing Haskell all day long
16:28:58 <dons> dibblego: should WorkingMouse be on the Haskell-in-industry page yet?
16:29:00 <dibblego> not yet - I really don't know what direction to go in
16:29:11 <dibblego> probably not yet
16:29:14 <astrolabe> ptaron: http://en.wikibooks.org/wiki/Haskell/YAHT   --but it has some minor transcription errors.
16:29:48 <dons> dibblego: did I point you at the (new?) german consulting firm using haskell?
16:29:57 <dibblego> yeah I saw that one
16:29:57 <dons> iba (I think)
16:30:21 <dibblego> we're still nowhere near the point we can approach a client confidentally and say "let's use haskell"
16:30:27 <dibblego> which is very frustrating
16:30:36 <dibblego> it seems the onus is on me
16:30:39 <sjanssen> http://programming.reddit.com/info/updn/comments . . . wow, just wow
16:30:59 <astrolabe> There are a couple of us using haskell now where I work, but I'm not sure whether that will grow, or if we'll have to stop.  We have a large amount of C++ code, and it is a risk starting with a new language.
16:31:04 <dibblego> programming.reddit.com won't resolve for me
16:31:05 <Excedrin> IPI: I guess the type of a has to be something like: Ord a => [t] -> (a1 -> [([a], (b, c))]) -> a1 -> [(a, b, c)]
16:31:10 <dons> dibblego: yeah. I understand
16:31:25 <dons> sjanssen: can you @paste that?
16:31:27 <sjanssen> http://groups.google.com/group/comp.lang.lisp/browse_frm/thread/88a36fb2c239a44e/89405e202723a377?lnk=raot#89405e202723a377 -- for the redditless
16:31:29 <lambdabot> Title: Google Groups : comp.lang.lisp, http://tinyurl.com/razdq
16:31:34 <shapr> dibblego: What exactly is the path from where you are to saying "let's use Haskell" ?
16:31:45 <dibblego> shapr, anything will do!
16:31:51 <goltrpoat> dibblego:  reddit has been intermittently down for the past couple of days, not sure what's going on
16:32:05 <dibblego> shapr, 3 months ago, I knew nothing of Haskell - I was struggling through YAHT
16:32:07 <[d-_-b]> thanks dons :)
16:32:13 <Excedrin> IPI: oh, it is "c . b . (a(x:xs)) y:ys" right? (two .s?)
16:32:27 <sjanssen> dons: the comments don't say much.  The article title is "Why lisp hasn't taken over the world"
16:32:30 <dibblego> shapr, today, I *wish* I could write an app for HAppS for example
16:32:31 <IPI> Excedrin, yes
16:32:40 <dibblego> shapr, I assume that is what you do all day long for clients
16:32:46 <nominolo> sjanssen: i've read this on c.l.l .. plain idiotic
16:33:13 <shapr> dibblego: Why can't you write an app for HAppS?
16:33:14 <dons> whoa. ok, nice way to kill a community there guys ;)
16:33:18 <edi> ?type \a b c x xs y ys -> c . b . (a (x:xs)) y : ys
16:33:19 <lambdabot> forall c b c1 a t a1. ([a] -> t -> a1 -> b) -> (b -> c1) -> (c1 -> c) -> a -> [a] -> t -> [a1 -> c] -> [a1 -> c]
16:33:26 <shapr> Oh, because your clients aren't confident?
16:33:29 <edi> ?type \a b c x xs y ys -> c . b . (a (x:xs)) (y:ys)
16:33:30 <lambdabot> forall c b c1 a a1 a2. ([a] -> [a1] -> a2 -> b) -> (b -> c1) -> (c1 -> c) -> a -> [a] -> a1 -> [a1] -> a2 -> c
16:33:37 <dibblego> shapr, a) I haven't tried :) I should, but time is another problem b) I don't feel capable
16:33:49 <edi> I suppose the second one have more possibilities to be something sensible :)
16:33:55 <dibblego> shapr, I don't care so much about my client's confidence - it is my confidence tht is lacking
16:34:08 <dibblego> shapr, remember, I am surrounded by Java people who know nothing about what I am doing
16:34:12 <astrolabe> sjanssen: could you give a direct link please?
16:34:21 <dibblego> I am on my own it seems to tackle this problem
16:34:23 <shapr> dibblego: Only way to gain confidence is to succeed in doing that thing once or twice.
16:34:29 <IPI> Excedrin,  i know that a at least taks in [a] , now what happens to y:ys and which function takes that in is where the question is ... we know that b takes in [(a,b,c)], so 'a' returns [(a,b,c)] but what 'a' takes in ??
16:34:36 <vininim> > take 10 (randomRs (1,5) (MkStdGen 15))
16:34:37 <lambdabot>  Not in scope: data constructor `MkStdGen'
16:34:39 <dibblego> shapr, agreed, I will do it some time very soon
16:34:43 <vininim> > take 10 (randomRs (1,5) (mkStdGen 15))
16:34:43 <syntaxfree> sjannsen: there's a new article to the effect of "Why Ruby hasn't taken over..."
16:34:44 <lambdabot>  [4,1,1,2,3,5,2,4,5,3]
16:34:50 <vininim> > take 10 (randomRs (1,5) (mkStdGen 15))
16:34:51 <lambdabot>  [4,1,1,2,3,5,2,4,5,3]
16:34:55 <vininim> mmm...
16:35:10 <dons> I wonder if we can do more to pick up alientated FPers fleeing lisp
16:35:10 <edi> IPI: a :: [a] -> [a] -> ..
16:35:14 <dons> and to unify the FP community
16:35:30 <dons> it seems such a waste to have people thrashing around in the lisp community with that kind of stuff going on
16:35:39 <syntaxfree> dons: I don't feel Lisp is a fundamentally functional language.
16:35:40 <dons> they should visit us and play in the sun for a while
16:35:46 <dibblego> syntaxfree, neither do I
16:35:47 <dons> syntaxfree: I agree :)
16:35:56 <ray> i'm an alienated FPer fleeing lisp! (sorta)
16:35:56 <syntaxfree> Lisp is fundamentally a bottom-up language. Because of closures and because of macros.
16:35:57 <dons> they give FP a bad name ...
16:36:04 <dons> ray cool!
16:36:09 <vininim> ?wiki haskell date
16:36:10 <lambdabot> http://www.haskell.org/haskellwiki/haskell date
16:36:13 <shapr> dibblego: Anyway, I'm working towards a coherent HAppS tutorial, I'll poke you when I have something worth looking at :-)
16:36:14 <vininim> ...
16:36:22 <dons> > (\x -> x^ 2) 7 -- have a lambda, ray!
16:36:24 <lambdabot>  49
16:36:24 <Excedrin> IPI: the function a has to take some list and return some function for c . b . a to work
16:36:28 <dibblego> shapr, excellent
16:36:29 <astrolabe> why are they so nasty?   lisp seems a nice enough language?
16:36:31 <ray> \o/
16:36:33 <edi> vininim: it just augments the base url with the argument string
16:36:39 <syntaxfree> Haskell, on the other hand, is partly bottom-up (because of closures) and partly top-down (because you have to, or at least should, design a type structure for any piece of serious software.
16:36:54 <edi> Excedrin: I think it misses a '$'.
16:37:00 <IPI> Excedrin, why should a return a fuction though? b is not taking in a fuction
16:37:05 <dons> ray, what are you impressions so far?
16:37:12 <syntaxfree> http://www.javalobby.org/java/forums/m92056297.html
16:37:12 <dons> are there things we should be doing better?
16:37:13 <lambdabot> Title: Contrast of Java and Ruby code ...
16:37:22 <edi> IPI: (.) is taking one as argument
16:37:25 <syntaxfree> Then someone says there that you can't compare apples and oranges.
16:37:34 <syntaxfree> and I quote.
16:37:36 <shapr> astrolabe: It's the curse of elitism. Sometimes people think they're literally better than others, or that others must go through the same pain to reach a particular level of knowledge.
16:37:36 <syntaxfree> "Ruby - weak typing, more of a scripting language better for ad hoc stuff and better for some specific tasks
16:37:36 <syntaxfree> Java - Strong typing, strict, formal, better for reliability performance and security (multi-layered sandbox type security) "
16:37:43 <IPI> edi, what you mean ? taking one as argument?
16:37:49 <syntaxfree> Haskell brings forth elements from both.
16:37:56 <edi> ?type (.)
16:37:58 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
16:38:04 <IPI> edi: this is given : b :: Ord a => [(a,b,c)] -> [(a,b,c)]
16:38:21 <syntaxfree> Some bottom-up, freewheeling closure programming, and some of strong design, strong typing, etc. etc.
16:38:28 <edi> IPI: hence the type of |a (x:xs)| should unify with the type |a -> b|
16:38:30 <dibblego> I find those "I know more than you so there!" people amusing - I used to get annoyed (re: reddit thing)
16:38:36 <ray> dons: i really like haskell, but i'm horribly bigoted towards functional style in the first place
16:38:45 <shapr> astrolabe: When in reality, the goal of a teacher is to distill their understanding in the hope that their students will exceed their teacher's accomplishments.
16:38:53 <vininim> > toCalendarTime (getClockTime)
16:38:54 <syntaxfree> ray: how are you liking the type system so far?
16:38:54 <lambdabot>  Not in scope: `getClockTime'
16:39:14 * IPI is totaly confused .... 
16:39:23 <astrolabe> dons: the main critisms of haskell from the guy at work are   1) Can't see what is going wrong when you run a program (ie no debugger)   2) space leaks are difficult to predict, and difficult to locate (at least at our level of expertise).  3) Compared to C, inefficient memory and time use.
16:39:23 <dibblego> shapr, do you write HAppS applications for clients all day long?
16:39:24 <edi> IPI: join #haskell-overflow
16:39:42 <ray> i like the type system, which is something i wouldn't have expected myself to say
16:39:54 <syntaxfree> it took me a while to appreciate the type system.
16:39:56 <ray> because i'm originally a C programmer
16:40:00 <ray> :)
16:40:30 <syntaxfree> I nowadays feel the type system is the key to the sheer declarativeness of Haskell.
16:40:42 <ray> i really didn't understand typing at all until i took up haskell, to be honest :)
16:41:11 <astrolabe> shapr: I partly agree with 'pupil needs to go through some pain' idea, but that lisp stuff was pointless nastyness.
16:41:20 <jlouis> C is for demonologists and Necromancers
16:41:41 <syntaxfree> astrolabe: what Lisp stuff?
16:42:02 <dons> ray, great :) welcome.
16:42:05 <ray> that flame that i still can't view 'cause the only link links to a frameset and i don't want to enable frames
16:42:06 <kNt> hi i have http://paste.lisp.org/display/32336#1 this but it isn't working with other expressions like assocrPw because it have a pair inside a pair..
16:42:18 <astrolabe> SyntaxNinja: http://groups.google.com/group/comp.lang.lisp/browse_frm/thread/88a36fb2c239a44e/89405e202723a377?lnk=raot#89405e202723a377
16:42:20 <lambdabot> Title: Google Groups : comp.lang.lisp, http://tinyurl.com/razdq
16:42:42 <dons> astrolabe: right. so those are well known and being addressed actively. i.e. ghci-debugger, the new hpc tracing tool/code coverage tool. bang patterns ease the insertion of strictness
16:42:47 <goltrpoat> i'm not sure if the fact that c.l.l. is mostly filled with pompous jackasses these days, is anything new
16:42:53 <dons> and Binkley's working on strictness analsysi in ghci
16:42:57 <_frederik_> does FFI work with c++? i'm managing to link stuff by looking up the mangled names in the object files, but i'm wondering if there's a better way
16:42:58 <dons> so I think things are getting better
16:43:04 <dons> _frederik_: it has been done
16:43:08 <dons> but its not trivial I think
16:43:26 <_frederik_> it's certainly not difficult
16:43:38 <_frederik_> but thanks
16:43:46 <syntaxfree> astrolabe: oh, boy, that's just nastiness.
16:43:48 <_frederik_> (just ugly at the moment)
16:43:55 <syntaxfree> I can expect that from Linux/Gentoo kiddies, but from Lispers?
16:43:56 <sorear> I *like* haskell's inefficiency.  It has finally forced me to take to heart "premature optimization is the root of all evil."
16:44:18 <syntaxfree> maybe Paul Graham is pushing Lisp popularity a little too far in the wrong audiences!
16:44:44 <Excedrin> sorear: maybe you should try Ruby?
16:45:07 <_frederik_> i have: foreign import ccall "reftest.h _Z5reffnRi" reffn :: Ptr Int -> IO ()
16:45:16 <astrolabe> dons:  It would be nice to be able to interrupt ghc (in some kind of trace mode) and be able to sample a random segment of a random thunk-tree (if that makes sense)  I bet that would help to track-down a space leak.
16:45:32 <syntaxfree> if you think Haskell has whimsical syntax, look at Ruby, heh.
16:45:49 <_frederik_> dons: are you saying that i can do it with reffn rather than _Z5reffnRi, or is that what you meant by not trivial?
16:46:36 <dibblego> everyone thought JAva was inefficient until the HotSpot/JIT improved; I still fail to see how a language can perform poorly on its own
16:46:38 <sorear> _frederik_ try nm -C and some list mangling
16:46:57 <astrolabe> sorear: I see what you mean, but when you are trying to convince people to rewrite a time critical application from C++ to haskell, it is a disadvantage :)
16:47:07 <dibblego> inefficiency is either a) poor use of language b) poor compiler c) both
16:47:08 <syntaxfree> dibblego: I'm sure Malbolge performs horribly for concurrent programming ;)
16:47:14 <_frederik_> sorear: what is the goal?
16:47:26 <dons> _frederik_: I think the symbols are the main issue. but check on haskell-cafe@
16:47:31 <sorear> nm -C (iirc) prints the demangled names
16:47:52 <_frederik_> sorear: yes, that's not what i'm trying to do though
16:48:00 <_frederik_> dons: ok thanks
16:48:11 <_frederik_> i'll just keep doing it this way
16:48:14 <sorear> thus in  a few lines of Haskell you could process an object file into a map DemangledName -> MangledName
16:48:43 <_frederik_> sorear: and then load it dynamically?
16:48:45 <sorear> then use TH (?) to use that map, maybe ?
16:48:53 <_frederik_> i see
16:48:59 <_frederik_> nah, too much trouble
16:49:21 <dons> astrolabe: there's no theoretical reason ghc can't outstrip C++ though. our compiler has more global knowledge ultimately, consider c++ versus clean (i.e. a stripped down haskell with a native code gen about 5 years ahead of ghc's :   http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=gpp&lang2=clean)
16:49:26 <lambdabot> Title: C++ g++ benchmarks | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Language ..., http://tinyurl.com/sqx7r
16:49:44 <dons> things like stream fusion on all strings and arrays give us the edge technology-wise
16:49:56 <dons> just a matter of fixing the backend (which rl and spj are on to now)
16:50:12 <_frederik_> dons: clean is more than a stripped down haskell, isn't it?
16:50:14 <dons> (now that the native gen is the main bottleneck for fast array lops)
16:50:32 <dons> _frederik_: well, kinda. its a lazy pure language, with typeclasses (but missing a lot of things haskell has)
16:50:40 <sorear> I refuse to believe that haskell will ever be faster than assembly.  (but that kind of speed *will* become a niche market.)
16:50:43 <astrolabe> dons: that would be fantastic, but I feel they've got quite a long way to go.
16:50:44 <dons> so in that sense, stripped down is fair, I think
16:51:09 <dons> astrolabe: I think its not quite that far. the bottlenecks in the native code gen are well known and understood
16:51:18 <dons> so its not like we need a sustained long term effort
16:51:27 <dons> more, fix the bigg issues. in particular: loops in the code gen
16:51:29 <_frederik_> sorear: it's already faster than assembly, if you use my library to multiply matrices, and the assembly version is straightforward and doesn't do tricky block-processing :)
16:51:39 <dons> (the current handling costs us about 4x slowdown over clean for tight loops)
16:51:51 <dons> and fixing that is maybe a week's work.
16:51:52 <astrolabe> dons: what is a ball-park figure for the speed increase removing those bottlenecks might give, typically?
16:52:11 <astrolabe> Ah 4x ?
16:52:14 <dons> i would say we'd get pretty close to Clean, across the board for loops.
16:52:26 <astrolabe> wow wow wow!
16:52:42 * astrolabe feels like shapr :)
16:52:52 <dons> the ghc optimiser is already generating code 3-4x faster than 6 months ago (for bytestring/array code)
16:52:58 <dons> but we've pushed that about as far as it can go
16:53:05 <dons> now its the native code gen itself that needs the work
16:53:55 <astrolabe> dons: I really really hope all this comes true!
16:54:01 <mbishop> has anyone made/plan to make a VM for haskell? or at least haskell to JVM/CLR/etc?
16:54:11 <dons> I think it will. we've got people paid full time to work on this
16:54:14 <sorear> I wonder how long it will be before Haskell will be talked about in the same context as we here are discussing C, a language too low level for extensive optimizations...
16:54:16 <sorear> YHC
16:54:17 <dibblego> mbishop, Jaskell
16:54:30 <sorear> Ycr2Js
16:54:33 <dons> sorear: hehe
16:54:36 <ray> sorear: 25 years? :)
16:54:42 <dons> sorear: there's already some advantages in epigram
16:54:42 <newsham> doesnt yhc emit to several different targets?  any of those VMs?
16:54:47 <newsham> dot-net.  thats CLR
16:54:47 <dons> where you know even more things statically
16:54:57 <dons> but yeah, 25-30 years?
16:55:02 <sorear> oh, wait, GHCi is a VM
16:55:05 <dons> i mean, lisp is too low level now..
16:55:08 <dons> how long did that take
16:55:25 <dons> and C++ is too low level. even java
16:55:40 <newsham> dons: on traditional optimizations:  http://research.microsoft.com/~toddpro/papers/law.htm
16:55:42 <lambdabot> Title: Proebsting's Law
16:55:42 <dons> once we all have 32 cores, all imperative languages will be considered too low level ;)
16:55:42 <sorear> back in Lisp's heyday, compilers were too stupid to compete with lower-level languages
16:55:45 <dibblego> "low level" meaning "close to the hardware and far remove from software"
16:55:55 <astrolabe> I could believe we'll all be using 16 cores in 10 years time, which would millitate towards haskell adoption.
16:56:01 <dons> its like : "what, you mean i have to program my parallelism explicitly!??"
16:56:06 <newsham> "This means that while hardware computing horsepower increases at roughly 60%/year, compiler optimizations contribute only 4%. Basically, compiler optimization work makes only marginal contributions. "
16:56:18 <dons> astrolabe: I have a 16 core box arriving on Friday :)
16:56:26 <dons> so 10 years maybe is too long a timeframe...
16:56:43 <astrolabe> dons: you are a special case!  What kind of box?
16:56:50 <dons> 16 core amd64
16:56:55 <sorear> DPH testere
16:56:56 <mbishop> heh
16:56:57 <dons> a good gaming machine
16:57:20 <mbishop> Intellisys (where Moore works) has started to do like 24 core chips I believe
16:57:24 <dons> actually, i'll take some photos of lambdabot frolicking around when it arrives
16:57:25 <sjanssen> and an excellent lambdabot box
16:57:45 <syntaxfree> lambdabot is our Erwin?
16:57:51 <newsham> ?elite i'm rotten to the cores
16:57:52 <lambdabot> i'M RO7tEn +o T|-|e (oR35
16:58:24 <dons> newsham: yeah. good thing that improving the backend doesn't requrie implementing new optimisations: just fixing the existing ones :)
16:58:27 <kpreid> ?id I've got a sixteen-track mind
16:58:28 <lambdabot> I've got a sixteen-track mind
16:58:50 <dons> if it actually required new compiler technology to make haskell go faster, then 4% a year is far more plausible
16:59:14 <dons> hmm. though +RTS -N2 was kind of a big improvement this year
16:59:27 <dons> some programs are now 100% faster... or more
16:59:30 <dons> and the speed is then tied to the number of cores..
17:00:15 <Trevion> ?elite +RTS -N2
17:00:16 <lambdabot> +rtz0rz -N2
17:00:25 <dons> we shoudl write some tutorials on ecouraging the use of `par` and forkIO
17:00:49 * mbishop was looking at Alice ML
17:00:53 <mbishop> neat lookin little language
17:00:57 * notsmack hasn't heard of par or forkIO
17:01:03 <Trevion> GHCi needs an option to enable l33t-speak.
17:01:12 <sorear> it's called GOA
17:01:23 <dons> ?hoogle forkIO
17:01:24 <lambdabot> Control.Concurrent.forkIO :: IO () -> IO ThreadId
17:01:26 <newsham> there's also the fact that we're reaching the end of 60% single-threaded speedup per year
17:01:33 <astrolabe> dons: do they work as easily as the ghc user guide suggests?
17:01:33 <kpreid> dons: what's the relationship of ghc 6.6 to GPH?
17:01:39 <dons> astrolabe: yeah
17:01:54 <dons> kpreid: the ghc smp + par stuff is  GPH-style haskell
17:02:03 <kpreid> ok
17:02:15 <dons> i.e. you annotate pure code with the odd `par` or strategy, and the runtime works out how many threads to use and run
17:02:15 <Excedrin> mbishop: I really like Alice, the distributed features would be nice in Haskell
17:02:21 <kpreid> is there any way I could test the effects of `par` on a single-processor machine?
17:02:42 <sorear> yes...
17:02:47 <kpreid> (hm, actually, I have access to a dual-processor machine...that doesn't have GHC installed)
17:02:48 <mbishop> Excedrin: indeed
17:03:11 <sjanssen> kpreid: par shouldn't do anything on a single processor machine
17:03:15 <dons> hehe, i see the top reddit link now: "
17:03:23 <kpreid> sjanssen: exactly
17:03:28 <dons> " Productivity Surges Amid Reddit Downtime" :)
17:04:01 <kpreid> I mean, to examine how a program *would* behave on a multiprocessor system
17:04:06 <Excedrin> for values of Productivity equal to "IRC usage"
17:04:21 <sorear> wow.  (looking up data for kpreid)  [GranSim] "has not yet been ported to the new GHC 5.0 runtime"
17:04:26 <sorear> *5.0*
17:04:36 <dons> it was a research project though
17:04:36 <kpreid> yeah, I saw that already
17:04:45 <dons> who's results are used to design ghc 6.6's runtime :)
17:04:53 <kpreid> understand I know zilch about GPH other than it having once been the place to go for `par`
17:04:59 <nominolo> Excedrin: i'd say these are in fact inversely proportional ..
17:05:08 <dons> kpreid: right. so now you get it in standard ghc 6.6
17:05:20 * dons hunts for a ref
17:05:23 <kpreid> yes, but that page mentions a simulator. is that available in GHC 6.6?
17:05:27 <dons> sjanssen: you should write a blog on the use of control.parallel.*
17:05:32 <dons> and get famous :)
17:09:52 <dons> hehe "In the worst case, it wouldnt take long to program a brand new reddit, said Weiden. I mean, Ive been dying for an excuse to learn Erlang."
17:10:14 <mbishop> heh
17:10:41 <dons> still seems a bit broken. i got the front page to load just once
17:10:43 <vininim> ?google scaping from IO ClockTime
17:10:45 <lambdabot> http://acis.mit.edu/gips/gips-tutor.ps
17:11:00 <dons> vininim: mm, what are you trying to do ? :)
17:11:19 <dons> something like: http://haskell.org/haskellwiki/Timing_computations
17:11:20 <vininim> to use toCalendarTime =p
17:11:20 <lambdabot> Title: Timing computations - HaskellWiki
17:11:28 <dons> ah
17:11:34 <dons> let me find you an example..
17:11:54 <dons> there's some examples here: http://www.cse.unsw.edu.au/~dons/code/hwn/utils/publish.hs
17:12:09 <dons> time <- getClockTime >>= toCalendarTime
17:12:31 <dons> formatCalendarTime defaultTimeLocale "%Y%m%d.pdf" time
17:12:53 <vininim> yeah... sometimes I forget that IO is monad... u_u
17:12:56 <sorear> ?where streams
17:12:57 <lambdabot> I know nothing about streams.
17:13:00 <sorear> ?where stream
17:13:03 <lambdabot> I know nothing about stream.
17:13:31 <newsham> http://citeseer.ist.psu.edu/mcilroy00music.html
17:13:32 <lambdabot> Title: The Music of Streams (ResearchIndex)
17:13:45 <newsham> \m/ rock on!
17:15:00 <sorear> random: http://www.haskell.org/haskellwiki  is redundant and hard to type...
17:15:03 <lambdabot> Title: Haskell - HaskellWiki
17:15:12 <dons> sorear: I agree
17:15:21 <dons> (you can drop the www.)
17:15:47 <sorear> /wiki  (which came IIRC before hawiki) is dead, can't we reuse the name?
17:16:36 <ptaron> (or go down to just w :))
17:17:09 <ptaron> also, holy cow, the YAHT wikibook is fantastic
17:17:28 <dons> vininim: http://haskell.org/haskellwiki/Unix_tools/Date
17:17:30 <lambdabot> Title: Unix tools/Date - HaskellWiki
17:17:33 <dons> for you!
17:18:11 <vininim> thanks ^_^
17:18:13 <dancor> what's the coolest way to take an alternating sum of a list of ints
17:18:26 <newsham> alternating sum?
17:18:28 <sjanssen> alternating sum?
17:18:40 <astrolabe> +l1 -l2 +l3 -...
17:18:45 <edi> > cycle [1,subtract 1]
17:18:46 <lambdabot>  add an instance declaration for (Num (a -> a))
17:18:47 <lambdabot>   In the list element: 1
17:19:12 <vininim> > cycle [ (+1), (_1)]
17:19:13 <lambdabot>  Not in scope: `_1'
17:19:14 <kpreid> > zipWith ($) (cycle [(+1), subtract 1]) [1, 2, 3, 4]
17:19:16 <lambdabot>  [2,1,4,3]
17:19:16 <vininim> heh
17:19:22 <kpreid> er
17:19:27 <sorear> foldr (-) 0 [1,2,3,4,5]
17:19:28 <kpreid> > sum . zipWith ($) $ (cycle [(+1), subtract 1]) [1, 2, 3, 4]
17:19:29 <lambdabot>    Expecting a function type, but found `b'
17:19:29 <lambdabot>    Expected type: [a1] -> [a...
17:19:36 <kpreid> > sum $ zipWith ($) (cycle [(+1), subtract 1]) [1, 2, 3, 4]
17:19:37 <lambdabot>  10
17:19:45 <sorear> > scanl (-) 0 [1,2,3,4,5]
17:19:46 <lambdabot>  [0,-1,-3,-6,-10,-15]
17:19:54 <sorear> > scanl subtract 0 [1,2,3,4,5]
17:19:56 <lambdabot>  [0,1,1,2,2,3]
17:19:56 <kpreid> er, that's not right
17:20:06 <kpreid> > sum $ zipWith (*) (cycle [1, -1]) [1, 2, 3, 4]
17:20:07 <lambdabot>  -2
17:20:12 <newsham> sum $ zipWith (*) [1,2,3,4] (cycle [1, -1])
17:20:12 <kpreid> there we go
17:20:39 <kpreid> > sum $ zipWith ($) (cycle [id, negate]) [1, 2, 3, 4]
17:20:40 <lambdabot>  -2
17:20:51 <kpreid> that's cooler
17:20:59 <vininim> kind of straightfoward =p
17:21:11 <newsham> > map ((-1)^) [1..5]
17:21:13 <lambdabot>  [-1,1,-1,1,-1]
17:21:14 <vininim> I bet he wanted some monad transfotaions
17:21:24 <vininim> and transformations too
17:22:02 <newsham> sum [x * (-1)^n | (x,n) <- zip xs [0..]]
17:22:07 <newsham> reads mathily
17:22:18 <dons> ?pl reverseWords = concat . reverse . groupBy ((==) `on` isSpace)
17:22:19 <lambdabot> reverseWords = join . reverse . groupBy ((==) `on` isSpace)
17:22:44 <int-e> zipWith (*) xs (cycle [1,-1])
17:25:56 <dons> > zipWith (*) xs (cycle [1,-1]) [1..10]
17:25:57 <lambdabot>  Not in scope: `xs'
17:26:06 <dons> > (\xs -> zipWith (*) xs (cycle [1,-1])) [1..10]
17:26:07 <lambdabot>  [1,-2,3,-4,5,-6,7,-8,9,-10]
17:27:24 <newsham> > let indexed xs = zip [1..] xs in sum [x*(-1)^n | (x,n) <- indexed [1,2,3,4]]
17:27:26 <lambdabot>  2
17:27:44 <newsham> SUM_n x*(-1)^n
17:30:34 <vininim> > snd (runState (modify id) [1,2,3,4])
17:30:35 <lambdabot>  [1,2,3,4]
17:30:54 <edi> ?type execState
17:30:56 <lambdabot> forall s a. State s a -> s -> s
17:31:01 <edi> ?type evalState
17:31:02 <lambdabot> forall a s. State s a -> s -> a
17:31:08 <edi> (so you don't need fst or snd)
17:32:47 <newsham> > execState do { modify $ map (* 2); modify $ map (subtract 3) } [1,2,3,4]
17:32:47 <lambdabot>  Parse error
17:32:56 <edi> (do { .. })
17:33:05 <sorear> ?type guard
17:33:06 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
17:33:10 <astrolabe> > sum (zipWith (*) (scanl (*) 1 (repeat (-1))) [1..10])
17:33:11 <newsham> > execState (do { modify $ map (* 2); modify $ map (subtract 3) }) [1,2,3,4]
17:33:16 <lambdabot>  -5
17:33:16 <lambdabot>  [-1,1,3,5]
17:33:21 <kpreid> or execState $ do ...
17:33:33 <edi> kpreid: and then the initial state?
17:33:38 <kpreid> er...
17:34:00 <kpreid> flip execState, then
17:34:03 <kpreid> I think the first $ I used in a haskell program was a $ do
17:34:18 <edi> good idea
17:35:13 <edi> actually State s a =~= s -> (a,s) so it would make sense to have {exec,eval}State :: s -> State s a -> {s,a}, right?
17:35:56 <newsham> the first dollar is always the most memorable
17:36:36 <sjanssen> just ask Scrooge McDuck
17:36:38 <newsham> edi: what are you saying?  swap exec and eval?
17:36:47 <edi> newsham: no, flip their arguments
17:37:55 <newsham> isnt that standard convention for all of the runXXX's?
17:38:11 <edi> that's what the point I was making yeah
17:38:42 <newsham> huh?  now i'm confused :)
17:38:53 <newsham> ?type runState
17:38:55 <lambdabot> forall s a. State s a -> s -> (a, s)
17:38:56 <newsham> ?type evalState
17:39:01 <lambdabot> forall a s. State s a -> s -> a
17:39:03 <edi> Hm.
17:39:07 <sorear> the runXXX's probably only do that because they are record projectors.
17:39:11 <edi> oh I se what you mean
17:39:16 <edi> yes
17:39:21 <dons> > (`runState` 0) $ do x <- get ; put (x+1) ; return "foo"
17:39:23 <lambdabot>  ("foo",1)
17:39:48 <sorear> (`anything` anythingElse) is a bad sign
17:39:55 <dons> :)
17:40:14 <kpreid> @pl (`anything` anythingElse) is a bad sign
17:40:14 <lambdabot> (is `anything` anythingElse) a bad sign
17:40:22 <kpreid> @. pl unpl (`anything` anythingElse) is a bad sign
17:40:23 <lambdabot> anything is anythingElse a bad sign
17:40:26 <edi> hahah
17:40:31 <newsham> @{$oh->{'pshaw'} `its` %perfectly @normal@!}
17:40:31 <lambdabot> Unknown command, try @list
17:40:42 <dons> newsham: you're making me cry
17:40:48 <newsham> :)
17:40:56 <newsham> then my job here is done.
17:40:57 <dons> #haskell gets a dose of syntactic realism from newsham
17:40:59 * juli sets newsham on fire.
17:41:09 <kpreid> I'd call it syntactic surrealism
17:41:12 <dons> programming should just not look like that!
17:41:18 <edi> burning down the house!
17:41:24 <dons> our industry has failed if that's where we are
17:41:36 <kpreid> dons: let me assure you that that *isn't* valid Perl 5 syntax.
17:41:49 <newsham> dont confuse larry wall's drug induced vision of computing with the state of reality
17:41:50 <edi> but it is valid perl6 syntax
17:41:51 <kpreid> though it would be if you added some commas
17:42:09 <edi> ...if you defined the right stuff, I believe.
17:42:24 <kpreid> oh? what does %foo @bar mean in perl 6?
17:42:36 <edi> you have complete control over the syntax in perl6
17:43:06 <edi> you can define your own circumfix operators for example, like <!-- --!> like HTML comments, to do something...
17:43:08 <kpreid> yes, but in that sense, it's not worth saying that something is valid perl 6 syntax
17:43:18 <edi> it leaves a door open (:
17:43:33 <edi> even if it's not perl5...
17:43:44 <savanni> Can any of you recommend a tutorial that really thoroughly explains Monads... and how to write them?
17:43:54 <dylan> @where aam
17:43:55 <lambdabot> http://www.nomaware.com/monads/
17:44:11 <savanni> Okay, I'll try that one next.
17:44:15 <savanni> Thanks.
17:45:35 <newsham> > (`runState` 1:3:((+) 5 6):[]) $ modify ((:).(+3).head)
17:45:36 <lambdabot>    The operator `runState' [infixl 9] of a section
17:45:37 <lambdabot>     must have lower ...
17:45:49 <newsham> > (`runState` (1:3:((+) 5 6):[])) $ modify ((:).(+3).head)
17:45:50 <lambdabot>  Couldn't match `[a]' against `[a] -> [a]'
17:46:13 <dancor> hm i thought it would be easier to make a determinant function
17:46:18 <newsham> > (`runState` (1:3:((+) 5 6):[])) $ modify ((:8:[]).(+3).head)
17:46:20 <lambdabot>  ((),[4,8])
17:46:28 <mbishop> If I have GHC 6.6, do I need to install anything special to begin doing the examples/exercises in SOE?
17:46:42 <newsham> not too far from perl ;-)
17:48:54 <dons>  thoughts for today: a) perl5 syntax will be considered an aberation in 100 years time. it will be like looking back at Frege's logic notation b) The alien rulers of the galaxy must surely use a statically typed language with type inference, and c)
17:48:58 <dons> The programming languages of the future will look like:
17:49:00 <kpreid> @unpl (`runState` (1:3:((+) 5 6):[])) $ modify ((:8:[]).(+3).head)
17:49:00 <lambdabot> (runState (modify (\ h -> ((head h) + 3) : 8 : [])) (1 : 3 : (5 + 6) : []))
17:49:00 <dons> fib 0 = 1
17:49:03 <dons> fib n = fib (n-1) + fib (n-2)
17:49:17 <dons> if they _dont_ look like this, we've failed
17:49:37 <kpreid> hm, should unpl resugar list construction?
17:49:46 <bd_> take 10 $ fix $ (1:) . (1:) . uncurry (zipWith (+)) . liftM2 (,) id tail
17:49:49 <bd_> err
17:49:50 <bd_> > take 10 $ fix $ (1:) . (1:) . uncurry (zipWith (+)) . liftM2 (,) id tail
17:49:52 <lambdabot>  [1,1,2,3,5,8,13,21,34,55]
17:50:15 <kpreid> dons: what do you think? it seems like the right thing to do, and yet it's not really a pl-ness issue
17:50:32 <bd_> @unpl take 10 $ fix $ (1:) . (1:) . uncurry (zipWith (+)) . liftM2 (,) id tail
17:50:32 <dons> yeah, should be able to do it
17:50:33 <lambdabot> (\ k -> take 10 fix (\ a -> 1 : a) (1 : (uncurry (zipWith (+)) (((\ h -> h) >>= \ d -> tail >>= \ c -> return ((,) d c)) k))))
17:51:01 <kpreid> dons: it's certainly possible, but is it *appropriate*?
17:51:13 <dons> kpreid: can you give me a small example
17:51:15 <kpreid> dons: or should it be in a separate command (like @redo)
17:51:32 <kpreid> dons: the unpl I did above: converting 1 : 3 : (5 + 6) : [] into [1, 3, 5 + 6]
17:51:59 <dons> right, it should end up back at list notation
17:52:16 <kpreid> but the two are equally pointful...
17:52:51 <kpreid> @pl 1:2:[]
17:52:51 <lambdabot> [1, 2]
17:53:19 <newsham> it would be interesting compiling a small haskell program, putting up the object code, and challenging people to figure out what it does
17:54:00 <kpreid> perhaps the answer is just that it should do that because it *is* orthogonal, and we'd like to eliminate silly consequences of transformations
17:55:41 * chessguy suddenly realizes that he has to turn his desktop ON before he can boot it remotely
17:55:43 <newsham> hey juli
17:55:44 <astrolabe> Dons: I'd agree with your fibs example, and add  primes = [n <- N | factors n = [1,n]]  I'd be impressed if a compiler could get that efficient.
17:56:04 <astrolabe> I wonder if we could get SET comprehensions in haskell.
17:56:36 <newsham> how about monad comprehensions?
17:57:02 <astrolabe> newsham: we used to have them I believe
17:57:24 <newsham> ?where comprehending monads
17:57:25 <lambdabot> I know nothing about comprehending.
17:57:28 <Binkley> heh
17:57:42 <astrolabe> but making haskell easy for learners got a higher priority than making it easy for users.
17:57:43 <newsham> ?wherey anything
17:57:43 <lambdabot> Maybe you meant: where where+
17:57:51 <newsham> ?where anything
17:57:51 <lambdabot> I know nothing about anything.
17:58:00 <Binkley> ?where your_mom
17:58:00 <astrolabe> heh
17:58:01 <lambdabot> I know nothing about your_mom.
17:58:22 <mbishop> ?where the missing cookie...I didn't eat it
17:58:22 <lambdabot> I know nothing about the.
17:58:26 <mbishop> aww
17:59:05 <mbishop> ?where plnews
17:59:05 <lambdabot> I know nothing about plnews.
17:59:19 <newsham> ?where monads
17:59:20 <lambdabot> http://www.nomaware.com/monads/html/index.html
17:59:27 <newsham> ?where perl
17:59:28 <lambdabot> I know nothing about perl.
17:59:38 <Binkley> ?where haskell
17:59:39 <lambdabot> http://haskell.org/
17:59:41 <Binkley> heh
17:59:43 <Binkley> damn.
17:59:48 <mbishop> ?where+ plnews http://www.plnews.org
17:59:48 <lambdabot> Done.
18:00:10 <newsham> ?where programming
18:00:11 <lambdabot> I know nothing about programming.
18:00:37 <newsham> ?elite but i got warez
18:00:37 <lambdabot> BuT i 9Ot War3z
18:00:38 <chessguy> ?where irc
18:00:38 <lambdabot> I know nothing about irc.
18:00:40 <reppie> ?where sex
18:00:41 <lambdabot> I know nothing about sex.
18:01:04 <Pseudonym> ?where anything
18:01:04 <lambdabot> I know nothing about anything.
18:01:43 <Smokey`> ?where topics irrelevant to this channel
18:01:43 <lambdabot> I know nothing about topics.
18:01:46 <Smokey`> bah
18:01:50 <Smokey`> ?where "topics irrelevant to this channel"
18:01:51 <lambdabot> I know nothing about "topics.
18:02:01 * Smokey` hands his head in shame
18:02:04 <chessguy> hehe
18:02:17 <chessguy> ?where topicsirrelevanttothischannel
18:02:18 <lambdabot> I know nothing about topicsirrelevanttothischannel.
18:02:27 <newsham> ?elite i totally pwned smokey
18:02:28 <lambdabot> i 7o+4|LY pwnEd 5/\/\OKEy
18:02:43 <Binkley> ?where where-the-on-topic-ness-of-#haskell-went
18:02:43 <lambdabot> I know nothing about where-the-on-topic-ness-of-#haskell-went.
18:04:28 <chessguy> Binkley, well now you've gone and killed the conversation
18:04:56 <Binkley> haha
18:05:02 <Binkley> well, at least it's not off-topic anymore ;-)
18:05:16 <chessguy> hehe
18:05:27 <Binkley> I had to kill the conversation in order to save it
18:05:33 <chessguy> have you had any luck setting up forums?
18:05:54 <Binkley> chessguy: me in particular? or are you asking the channel?
18:05:58 <Binkley> oh, for the book
18:06:05 <chessguy> right
18:06:10 <Binkley> No, I've been hosed with preparation for the talk I'm giving tomorrow
18:06:28 <chessguy> ah
18:06:35 <Binkley> by "I've been hosed" I mean that I've been spending a lot of time walking up and down bike paths holding a notebook
18:06:46 <chessguy> lol
18:06:50 <chessguy> what's the topic?
18:06:54 <chessguy> (or shouldn't i ask)
18:07:05 <Binkley> demand analysis in GHC
18:07:11 <Binkley> anyone near Cambridge should come :-)
18:07:21 <Binkley> or not near Cambridge, if you feel like flying out for the day
18:07:49 <chessguy> hehe, i'll have to call my interviewers and postpone, because i'll be suddenly out of the country for the day :)
18:07:53 <benja_> @hoolge a -> List a -> Int
18:07:54 <lambdabot> No matches, try a more general search
18:07:55 <Binkley> :-)
18:08:00 <benja_> @hoolge List a -> a -> Int
18:08:01 <lambdabot> No matches, try a more general search
18:08:29 <benja_> @hoolge a -> List a -> Maybe Int
18:08:29 <chessguy> anyway, i was thinking it might work well to do like a content management system.
18:08:30 <lambdabot> No matches, try a more general search
18:08:38 <benja_> @hoolge List a -> a -> Maybe Int
18:08:39 <lambdabot> No matches, try a more general search
18:08:40 <Binkley> what do you mean by "content management system"?
18:08:47 <Binkley> anyway, I have to think about the logistics of this
18:08:49 * benja_ sighs
18:08:52 <Binkley> I really meant to ask, originally, for 2-3 coauthors
18:08:56 <Binkley> and it turned into a huge discussion
18:09:00 <Binkley> I mean, the discussion was great
18:09:07 <Binkley> but for actual book writing, I think a very small group would work best
18:09:13 <chessguy> i think django added asynchronous collaboration tools as a SoC project
18:09:49 <Binkley> I'll have to look at that
18:09:55 <mbishop> hmm
18:09:57 <Binkley> this probably won't be until after December 22
18:10:08 <chessguy> perfect, that's when i graduate :)
18:10:15 <Binkley> heh
18:10:19 <Binkley> graduate from undergrad or grad school?
18:10:20 <dons> astrolabe: yes. the goal should be: work out the notation, work out the semantics. then spend 20 years making it efficient
18:10:24 <mbishop> what is SamB's interactive fiction thingie called?
18:10:27 <dons> (remind you of any language out there ? ;)
18:10:32 <Binkley> dons: heh :-)
18:10:40 <SamB_XP> mbishop: I'm not very creative
18:10:41 <Binkley> but since when did anybody work out the semantics? :-)
18:10:44 <SamB_XP> its called ZMachine
18:10:47 <mbishop> heh
18:10:49 <SamB_XP> @where ZMachine
18:10:50 <lambdabot> http://naesten.dyndns.org:8080/repos/ZMachine
18:10:51 <mbishop> ?where ZMachine
18:10:51 <lambdabot> http://naesten.dyndns.org:8080/repos/ZMachine
18:10:54 <mbishop> :P
18:10:59 <dons> astrolabe: actually, I decided to blog this: http://cgi.cse.unsw.edu.au/~dons/blog/2006/12/14#on-syntax
18:11:00 <lambdabot> Title: Haskell, hacking and other stuff
18:11:02 <chessguy> Binkley, sorry, from undergrad
18:11:10 * astrolabe reads
18:11:12 <Binkley> chessguy: cool, now your real life begins :-)
18:11:23 <newsham> > foldl (\x y -> x*256+(fromIntegral $ fromEnum y)) 0 "j000leeeeeeee" :: Integer
18:11:24 <lambdabot>  8413098764095931745575081698661
18:11:25 <chessguy> indeed
18:12:47 <chessguy> that's a big number :)
18:12:52 <SamB_XP> > foldl (\x y -> x*fromEnum (maxBound::Char)+(fromIntegral $ fromEnum y)) 0 "j000leeeeeeee" :: Integer
18:12:52 <lambdabot>  Couldn't match `Integer' against `Int'
18:13:11 <SamB_XP> > foldl (\x y -> x*fromIntegral (fromEnum (maxBound::Char))+(fromIntegral $ fromEnum y)) 0 "j000leeeeeeee" :: Integer
18:13:12 <lambdabot>  387656962099605145023521688535621678488057266972073003531987000447922340006
18:13:37 <SamB_XP> > fromEnum (maxBound :: Char)
18:13:38 <lambdabot>  1114111
18:14:04 <SamB_XP> > log (fromIntegral (fromEnum (maxBound :: Char))) / log 2
18:14:06 <lambdabot>  20.087461546321563
18:14:12 <astrolabe> dons: nice
18:14:14 <SamB_XP> > 2^20
18:14:15 <lambdabot>  1048576
18:14:25 <SamB_XP> > maxBound :: Char
18:14:27 <lambdabot>  '\1114111'
18:14:41 <SamB_XP> why in the world is that the maxBound of Char?
18:14:44 <chessguy> > 2^20
18:14:46 <lambdabot>  1048576
18:14:57 <chessguy> is that right? looks small
18:15:00 <Igloo> Because Unicode says so
18:15:25 <SamB_XP> I thought unicode was at least 31-bit!
18:15:42 <SamB_XP> (so what if they don't use the last few bits yet!)
18:26:26 <sorear> mad idea: connect the haskell-mode hover-sigs to Hoogle.
18:34:26 <chessguy> ok, it's too quiet in here. time to ask a newbie question
18:34:28 <chessguy> @paste
18:34:29 <lambdabot> http://paste.lisp.org/new/haskell
18:34:56 <lisppaste2> chessguy pasted "How do I use it?" at http://paste.lisp.org/display/32343
18:35:04 <madhadron> Well...if it's noise you want, anyone have thoughts on how to bind OpenCV into Haskell?
18:35:06 <chessguy> someone pasted this code earlier
18:35:28 <chessguy> i'm trying to figure out how someone would actually use it. like create a new state, add things to it, etc.
18:39:40 <chessguy> well don't everyone talk at once
18:40:48 <madhadron> What is the iter2 function?
18:40:57 <vininim> all I know, is that modify function can be quite usefull
18:41:17 <vininim> and that you have to runState around main
18:41:49 <goltrpoat> > let iter2 = get >>= put . (+1) :: State Int (); compute n = case n of 0 -> return (); n -> iter2 >> compute (n-1) in execState (compute 5) 10
18:41:51 <lambdabot>  15
18:42:12 <madhadron> Just a roundabout way of storing n in a State
18:42:19 <vininim> you might actually get to the point where you can't pass runState around due to type restrictions in callbacks. =P
18:42:37 <vininim> (wtr to return type)
18:47:51 <geckosen1tor> I'm reading yaht, and it says that :t "Hello" should give me String..
18:47:55 <geckosen1tor> > :t "Hello"
18:47:55 <lambdabot>  Parse error
18:48:03 <geckosen1tor> well, I get [Char] instead
18:48:05 <notsmack> @type "Hello"
18:48:07 <lambdabot> [Char]
18:48:09 <notsmack> [Char] is String.
18:48:48 <chessguy> @type execState
18:48:50 <notsmack> type  String = [Char]
18:48:50 <lambdabot> forall s a. State s a -> s -> s
18:49:44 <Excedrin> @type String
18:49:45 <lambdabot> Not in scope: data constructor `String'
18:49:56 <lisppaste2> Excedrin annotated #32343 with "state" at http://paste.lisp.org/display/32343#1
18:50:37 <chessguy> geckosen1tor, "Hello" is just syntactic sugar for ['H','e','l','l','o']
18:50:39 <Excedrin> @type "" :: String
18:50:41 <lambdabot> String :: String
18:50:43 <chessguy> in haskell
18:50:58 <Excedrin> @type "" :: [Char]
18:50:59 <lambdabot> [Char] :: [Char]
18:51:03 <SamB_XP> chessguy: "just"?
18:51:25 <geckosen1tor> well is'nt yaht wrong then?
18:51:36 <madhadron> No, it's an implementation thing.
18:51:48 <chessguy> SamB_XP, as opposed to some other type
18:51:50 <geckosen1tor> well it said using ghci and I am using that.. hmm
18:51:53 <SamB_XP> are you telling me that GHC is smart enough to pack ['H','e','l','l','o'] into an array?
18:51:55 <madhadron> If I defined > type Thingie = Int
18:52:10 <SamB_XP> like it does with "Hello"?
18:52:20 <madhadron> It could tell me Thingie or Int for appropriate types
18:52:30 <SamB_XP> (of course, it only uses that to keep code sizes down)
18:52:34 <Smokey`> two questions... how would I go about using an array with my own data type (not a standard / tuple type), I realise I have to implement something for my data type, but I'm kinda lost as to what I'm supposed to be doing :\
18:52:51 <vininim> syntatic sugar gor H:(e:(l:(l:(o:[]))))
18:52:52 <SamB_XP> (though actually you can pull some fusion tricks with that, I think)
18:53:04 <sorear> you only need to implement something for array *indices*
18:53:13 <sorear> array *values* can be any type
18:53:23 <SamB_XP> Smokey`: you could try "deriving Ix"
18:53:42 <SamB_XP> if that doesn't work you might as well either give up or use a Map instead
18:53:42 <sorear> > array (1,20) [(i,i) | i <- [1..20]]
18:53:44 <lambdabot>  array (1,20) [(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10),...
18:54:02 <sorear> > array (1,20) [(i,i*i*i) | i <- [1..20]]
18:54:04 <lambdabot>  array (1,20) [(1,1),(2,8),(3,27),(4,64),(5,125),(6,216),(7,343),(8,512),(9,7...
18:54:58 <sorear> arrays are assumed dense.  If your type is mostly uninhabited, you should use Map or HashTable.  (Map is usually preferred.)
18:55:59 <Excedrin> > array('a','j') (zip ['a'..'j'] ['a'..'j'])
18:56:01 <lambdabot>  array ('a','j') [('a','a'),('b','b'),('c','c'),('d','d'),('e','e'),('f','f')...
18:56:02 <Smokey`> hmmm
18:56:54 <sorear> > Data.Map.fromList $ map (join (,)) [0..5]
18:56:55 <lambdabot>  Not in scope: `Data.Map.fromList'
18:57:25 <liquidengineer> Hi
18:58:47 <dons> sorear: you could submit a patch to RunPlugs.hs that imports everything qualified also
18:59:13 <sorear> > fromList $ map (join (,)) [0..5]
18:59:14 <lambdabot>  Not in scope: `fromList'
18:59:39 <dons> its imported as M.*
19:00:02 <liquidengineer> Is there a builtin way to swap two elements of a list at given indices?
19:00:16 <sorear> > M.fromList $ map (join (,)) [0..5]
19:00:18 <lambdabot>  {0:=0,1:=1,2:=2,3:=3,4:=4,5:=5}
19:01:27 <Excedrin> is that join from Control.Monad.List?
19:01:53 <sorear> join from Control.Monad.Instances, on (->) x
19:02:00 <sorear> ?pl (\x -> (x,x))
19:02:00 <lambdabot> join (,)
19:03:12 <dons> liquidengineer: no built in way, but its a one liner
19:04:34 <liquidengineer> dons: It is?  Yay.
19:04:48 <liquidengineer> what is it?
19:05:12 <joelk> I'm trying to use cabal on my own lib for the first time and even though I gave a prefix to configure, it seems to be trying to install globally. What gives?
19:05:53 <dons> or is it trying to *register* it globally?
19:06:04 <dons> i.e. are you using --user (to register locally?)
19:06:16 <joelk> yeah, that's it register.
19:07:06 <joelk> Okay, that's the info I was missing. Thanks.
19:07:14 <sorear> ?hoogle Monad m => m (Maybe a) -> m [a]
19:07:15 <lambdabot> No matches, try a more general search
19:07:25 <dons> > let insert x n xs = let (a,b) = splitAt n xs in a ++ [x] ++ b in insert '#' 3 "haskell"
19:07:27 <lambdabot>  "has#kell"
19:07:35 <dons> liquidengineer: now you finish it off
19:08:46 <liquidengineer> ah
19:08:49 <liquidengineer> I see now
19:08:59 <liquidengineer> Thanks. :D
19:09:29 <Smokey`> sorear: overlooking my code just then, seems my problem was with (unboxed) immutable array, not normal arrays...
19:10:46 <joelk> dons, on your dlist "how to" blog entry did you leave the --user out of the transcript or register globally?
19:12:04 <liquidengineer> I'm guessing an almost instantaneous stack overflow is a sign of badly coded recursion, yes?
19:12:15 <liquidengineer> I refuse to believe I am using up all the memory in the machine
19:12:33 <SamB_XP> that usually doesn't happen instantaneously, no ;-)
19:13:23 <geckosen1tor> so haskell is like a cross between python and lisp?
19:13:41 <Smokey`> hmmm, making progress... I think I'm still just a little mislead by some of the error messages given by ghc
19:14:06 <liquidengineer> SamB: so what DOES cause instant overflow?
19:14:43 <SamB_XP> I meant, usually if you run out of RAM it takes a while because of swapping
19:14:53 <liquidengineer> Yeah
19:15:00 <liquidengineer> I've seen it happen and it usually takes at least 30 seconds
19:15:11 <liquidengineer> this islitterally ::blink:: Exception
19:16:25 <sorear> > let f !x = f (x + 1) in f x
19:16:26 <lambdabot>  Not in scope: `x'
19:16:36 <sorear> > let f x = x `seq` f (x + 1) in f x
19:16:37 <lambdabot>  Not in scope: `x'
19:16:42 <sorear> > let f x = x `seq` f (x + 1) in f 1
19:16:43 <lambdabot>  Add a type signature
19:16:48 <sorear> > let f x = x `seq` f (x + 1) in f (1::Int)
19:16:49 <lambdabot>  Add a type signature
19:17:03 <sorear> > let f :: Int -> Int ; f x = x `seq` f (x + 1) in f (1::Int)
19:17:07 <lambdabot> Terminated
19:17:20 <sorear> > let f :: Int -> Int ; f x = x `seq` f (f (x + 1)) in f (1::Int)
19:17:24 <lambdabot> Terminated
19:17:37 <sorear> > let f :: Int -> Int ; f x = x `seq` (3 + f (x + 1)) in f (1::Int)
19:17:42 <lambdabot> Terminated
19:18:30 <sorear> > let f :: Int -> Int ; f x = x `seq` ((+) 3 $! f (x + 1)) in f (1::Int)
19:18:34 <lambdabot> Terminated
19:21:23 <dons> joelk: yes, I just registered globally, and installed locally
19:21:37 <dons> geckosen1tor: hmm, close!
19:21:53 <dons> geckosen1tor: haskell is lisp's grandchild. python borrows from both lisp and haskell
19:22:05 <dons> (haskell doesn't borrow anything from python, afaik)
19:22:12 <geckosen1tor> so python came later?
19:22:30 <dons> a couple of years later, yeah
19:22:43 <dons> i.e. python takes whitespace and comprehensions from haskell
19:24:58 <dons> geckosen1tor: how are you going with it so far? your haskell learning.
19:26:19 <geckosen1tor> dons: i'm taking my time and it's the second day
19:26:40 <geckosen1tor> dons: right now the goal is to learn something new about programming, I am not sure what I might actually use haskell for
19:27:35 <vininim> http://paste.lisp.org/display/32343#1 needs yet another anotation, one that passes states between functions. =P
19:28:32 <dons> geckosen1tor: writing programs :) ones that work without needing much debugging , or run well on parallel hardware. (just a few reasons)
19:28:42 <dons> geckosen1tor: what kind of problems do you typically need to solve?
19:29:34 <dino-> I had read that I needed to get the latest from darcs in order to build gtk2hs against ghc 6.6. Now, the INSTALL document says run the configure script. But there is none! Anybody here done this recently?
19:29:38 * sjanssen felt like an amateur next to a pro when he saw Ross Paterson was contributing to the 99 questions too
19:29:46 <Smokey`> would anyone be able to give me an example of how to implement an instance of IArray UArray Foo, I'm soo lost :(  from what I can tell it only has a single method (, called bounds) that is required, but I'm soo clueless as to how I'd go about implementing it
19:29:51 <Pastorn> vininim: wtf does that do?
19:29:52 <dons> sjanssen: hehe. yeah, I saw that
19:29:56 <dons> he's doing the hard ones!
19:30:14 <dons> Smokey`: a new instance?
19:30:15 <Excedrin> dons: Python apparently takes comprehensions from ABC, which took them from SETL
19:30:44 <Smokey`> dons: correct, where Foo is my own data type...
19:30:52 <dons> Excedrin: ah interesting. I know the phrase 'comprehension' is due to Wadler though (circa 85), and the generalisation from lists to arbitrary monads is also Wadler et al from the Haskell days
19:31:05 <dons> the notatin is from one of Turner's languages
19:31:18 <dons> (pre-haskell)
19:31:35 <sjanssen> how important is it to stick to Haskell '98 when solving the 99 questions?
19:31:51 <dons> sjanssen: not that important , I think. only if you know a nice way to do it in h98.
19:31:55 <dons> let's say: 70% important
19:31:58 <chessguy> sjanssen, we want idiomatic solutions.
19:32:04 <chessguy> that's the priority
19:32:26 <sjanssen> @where paste
19:32:27 <lambdabot> http://paste.lisp.org/new/haskell
19:32:33 <dons> yeah. if that means it needs -fglasgow-exts though, then good
19:32:40 <vininim> Pastorn: it encapsulates the passing around of states in a monad
19:33:05 <Excedrin> dons: ABC also has whitespace
19:33:23 <lisppaste2> sjanssen pasted "my solution to P48" at http://paste.lisp.org/display/32344
19:33:24 <Excedrin> (syntactically significant whitespace too)
19:33:26 <dons> yeah, I know.
19:33:36 <vininim> Pastorn: but only inside a function it seems, we are trying to figure how to emulate a "global variable" using state
19:34:07 <Pastorn> check the wxHaskell source, they did it
19:34:17 <sjanssen> that requires extensions because you may only apply type variables to type constructors in instances in H '98
19:34:20 <beschmi> dino-: you have to use autoreconf since configure is generated from configure.in
19:35:19 <dino-> beschmi: I just this second found those build instructions on the gtk2hs site (that differ from what's still in INSTALL)
19:35:46 <dino-> beschmi: Thank you.
19:36:39 <Excedrin> dons: ya, SETL called them set formers
19:36:53 <Daveman> wow, still at it, chessguy :) ?
19:37:00 <dino-> Bah, now no "aclocal"
19:37:30 <dons> guys, could people read this: http://headrush.typepad.com/creating_passionate_users/2006/12/how_to_build_a_.html
19:37:32 <lambdabot> Title: Creating Passionate Users: How to Build a User Community, Part 1, http://tinyurl.com/y2jvu5
19:37:48 <dons> I'm thinking of formalising a "zero-tolerance for abuse" policy in here
19:38:27 <dons> we've acted on this maybe 5 times in 5 years, for people who've been intimidating and abusive towards newbies, but the justification has always been a bit ad hoc
19:38:40 <dons> should we just say: #haskell has a zero tolerance policy for abuse of beginners
19:38:43 <dons> ?
19:38:48 <Daveman> heh
19:38:51 <dons> let me know what you think?
19:39:09 <allbery_b> this is already one of the most beginner-friendly IRC channels I've run across
19:39:15 <dons> we can do better! :)
19:39:19 <Daveman> bah
19:39:33 <dons> or, we can state that this is an explicit goal, anyway
19:39:40 <dons> (that's what I'm thinking about)
19:39:42 <dino-> allbery_b: Yeah, I was just thinking that.
19:39:45 <allbery_b> (and in general I have a low tolerance for BS --- there are quite a few channels I've joined and lft shortly after because people had no manners to speak of)
19:40:04 <Excedrin> dons: "Adopt a near-zero-tolerance "Be Nice" policy" (Absolutely no Niceness will be tolerated!)
19:40:11 <dons> heh
19:40:34 <SamB_XP> that might work *if we were contrary*
19:40:40 <dino-> That page is funny: "Scoble says blogging will make us richer and improve our sex life..."
19:40:48 <dons> just planning for the future. if the commmunity/channel keeps growing t the current rate..
19:40:49 <liquidengineer> Hmm
19:40:51 <Daveman> It's not imcumbent that you set some sort of standard... :P
19:40:52 <liquidengineer> This is strange
19:41:04 <Daveman> This channel is not large.
19:41:16 <dino-> Does absolutely everything said on here get logged somewhere?
19:41:19 <goltrpoat> dons:  i'm not sure about #4 on that list.. it can degenerate into a "there are no wrong answers" type deal.  personally, if i answer a question incorrectly, someone *better* correct me before the person walks away with the wrong impression
19:41:19 <dons> Daveman: well, its about the size of #python now. and sits around the top 10 on freenode
19:41:28 <dons> Daveman: the main thing is that its growing about 10% a month
19:41:30 <sjanssen> dino-: yes
19:41:42 <dons> s/5% a month/
19:41:42 <liquidengineer> If I take the celing of a float, that's an Int, right?
19:41:49 <sjanssen> @where logs
19:41:50 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://meme.b9.com/cdates.html?channel=haskell
19:41:51 <dino-> Then it's possible to go back and say, "Yep, you were a prick, Chucky. Knock it off."
19:42:02 <goltrpoat> and one person's correction is another person's slam.
19:42:07 <dons> ?where stats
19:42:08 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
19:42:09 <liquidengineer> eg.: ceiling 7 / 2
19:42:10 <dons> Daveman: ^^
19:42:15 <Excedrin> @type ceiling
19:42:16 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
19:42:23 <dons> dino-: right. that's been used a few times in fact
19:42:30 <dons> I use the logs extensively for checking on trolls
19:42:35 <dons> and inspecting patterns of behaviour
19:42:39 <liquidengineer> Excedrin: so, that means it should return an int, right?
19:42:40 <dons> (they're available by darcs, btw)
19:42:58 <dino-> Hm. Maybe lambdaprofiler
19:43:04 <Excedrin> liquidengineer: not necessarily, just some Integral type (Int, Integer...)
19:43:07 <dons> the entire logs, via darcs (~500M) http://www.cse.unsw.edu.au/~dons/code/irc-logs/
19:43:09 <lambdabot> Title: Index of /~dons/code/irc-logs
19:43:12 * allbery_b has a fromIntegral . truncate utility function in his zemanim calculator because he uses it so much
19:43:15 <liquidengineer> I keep getting this error:
19:43:17 * sjanssen begins submitting patches for his misspellings
19:43:19 <liquidengineer> No instance for (RealFrac Int)
19:43:44 <Excedrin> liquidengineer: paste your code
19:43:46 <allbery_b> you need to coerce it back up with FromIntegral if you pass the result on to something else expecting an instance of RealFrac.
19:43:48 <Excedrin> @paste
19:43:49 <lambdabot> http://paste.lisp.org/new/haskell
19:43:57 <dons> sjanssen: heh
19:44:19 <Daveman> dons, yeah I figured that ;)
19:44:27 <dons> Daveman: have you had much experience of channels > 300 users?
19:44:31 <dons> how well do they function?
19:44:37 <dons> what works, what doesn't?
19:44:58 <Daveman> My point was just that while planning a new policy to enact may be a good idea, there is no need to institute abrupt changes immediately. :)
19:45:03 <allbery_b> er.  fromIntegral, of course
19:45:16 <Daveman> dons, I'm in at least ten right now, and they're just on this net :)
19:45:40 <dons> ah, there would be no abrupt changes
19:45:53 <dons> i'm just saying: would any disagree if I put our (currently informal) policy on the wiki
19:45:59 <dons> and made it formal
19:46:00 <Daveman> They function pretty well.
19:46:04 <dons> so it could be referred to
19:46:20 <lisppaste2> liquidengineer pasted "rounding problem" at http://paste.lisp.org/display/32346
19:46:24 <allbery_b> might be a good idea
19:46:28 <dons> there's a few guidelines here, http://haskell.org/haskellwiki/IRC_channel
19:46:30 <lambdabot> Title: IRC channel - HaskellWiki
19:46:37 <liquidengineer> It's the first line of the where statement
19:46:49 <Daveman> Though in general, once a large channel reaches 1000-1200 and there are a relatively large number of active users, it becomes difficult to moderate anything let alone carry on a conversation, due to the immense scrollback ;)
19:47:04 <dons> I'm not expecting 1000 any time soon :)
19:47:10 <Daveman> let's hope not :p
19:47:19 <Daveman> unless they're haskell users :)
19:47:23 <dino-> dons: I think it's a good idea to put this information on the wiki.
19:47:31 <Daveman> and even then I'd find that dubious, ... for the next 5-6 years.
19:47:36 <dons> ok
19:48:10 <allbery_b> liquidengineer:  I'm guessing that somewhere the result is being used with the expectation that it's a RealFloat (i.e. you passed it to / ).
19:48:35 <Excedrin> allbery_b: it's only used by take and drop
19:48:42 <liquidengineer> Yeah
19:48:46 <liquidengineer> it doesn't live outside the where
19:48:50 <liquidengineer> it's just supposed to be an Int
19:48:59 <liquidengineer> or suitable for use as an Int
19:49:03 <allbery_b> in that function, yes, but the result of the whole function may be used somewhere else which expects RealFloat
19:49:06 <dons> currently there's only 11 channels over 300 on freenode
19:49:07 <Excedrin> liquidengineer: I think you can simply add a :: Int annotation to crossPt
19:49:42 <dons> so given that haskell has been as high as 12th in size, I think some planning for this is a good idea :) just a little
19:50:21 <sorear> maybe... #haskell.a-m, #haskell.n-z
19:50:22 <goltrpoat> (ceiling ((length lpA) / 2)) - 1 might be better written as (length lpA) `div` 2
19:50:26 <liquidengineer> Excedrin: thanks
19:50:29 <sorear> go to your username channel
19:50:41 <goltrpoat> eliminating the RealFrac requirement as a side effect
19:50:43 <Excedrin> > let a = [1..10] in take (length a `div` 2) a
19:50:45 <lambdabot>  [1,2,3,4,5]
19:50:49 <sorear> (not yet, of course)
19:51:06 <dons> hehe
19:51:23 <dons> we do have #haskell.{es,se,fi,de,fr,pt,jp,ru....} already though ;)
19:51:39 * allbery_b type-annotates just about everything these days because type inference can otherwise lead to "spooky action at a distance"
19:51:48 <dons> hehe
19:51:55 <dons> allbery_b: do you have an editor script to insert the types?
19:52:00 <dons> I find that useful
19:52:05 <dons> since you get the types, without the typing
19:52:07 <sorear> Almost all haskellers are english though, so it doesn't effectively partition the noise
19:52:38 <Excedrin> dons: some vim script?
19:52:40 <dons> yeah
19:52:44 <allbery_b> where you use e.g. a ResultPath somewhere expectinga  RealFloat, and you don't annotate it *there*, it can propgate back to the function that produced the non-RealFrac value and complain about the unexpected type there
19:53:23 * allbery_b uses emacs, and doesn't use a script to do types --- being still something of a beginner, he thinks it's good to have to *think* about the types
19:53:38 <goltrpoat> > let a = [1..10] in take (ceiling ((fromIntegral $ length a) / 2) - 1)
19:53:39 <sorear> wow, just /who'd all the channels listed : largest is .se with *4* users including lambdabot
19:53:40 <lambdabot>  Add a type signature
19:53:41 <allbery_b> it keeps me honest, makes sure I know what's going on
19:53:47 <goltrpoat> > let a = [1..10] in take (ceiling ((fromIntegral $ length a) / 2) - 1) :: Int
19:53:48 <lambdabot>    Expecting a function type, but found `Int'
19:53:48 <lambdabot>    Expected type: Int
19:53:48 <lambdabot>   ...
19:53:51 <goltrpoat> er.
19:53:55 <goltrpoat> > let a = [1..10] in take (ceiling ((fromIntegral $ length a) / 2) - 1) :: [Int]
19:53:56 <lambdabot>    Expecting a function type, but found `[Int]'
19:53:56 <lambdabot>    Expected type: [Int]
19:53:56 <lambdabot> ...
19:54:01 <goltrpoat> > let a = [1..10] in take (ceiling ((fromIntegral $ length a) / 2) - 1) a
19:54:03 <lambdabot>  [1,2,3,4]
19:54:03 <goltrpoat> pardon.
19:54:08 <sorear> adding type signatures ruins my LOC stats :(
19:54:18 <dons> sorear: hmm, that's strange. they've been as high as 15 in .es, .fi and .se
19:54:20 <sjanssen> @users
19:54:21 <lambdabot> Maximum users seen in #haskell: 288, currently: 248 (86.1%), active: 42 (16.9%)
19:54:40 <sorear> ?users #haskell.se
19:54:41 <lambdabot> Maximum users seen in #haskell.se: 12, currently: 0 (0.0%), active: 0 (NaN%)
19:54:43 <allbery_b> goltrpoat: you are missing a parameter to take, so it's returning a partial application (a function) which you're trying to annotate as a value
19:55:06 <goltrpoat> yeah, didn't see that
19:55:09 <dons> here's a small script, http://cgi.cse.unsw.edu.au/~dons/tmp/typeof.txt
19:55:12 <goltrpoat> third time's a charm i guess.
19:55:38 <dons> Excedrin: ^^ which I have as:   :map ty :.!typeOf %^M
19:55:39 <sorear> what is lambdabot2 for?
19:55:40 <dons> in my .vimrc
19:55:48 <dons> sorear: defeating freenode
19:55:51 <sjanssen> dons++ -- I use that script every day
19:56:01 <sorear> defeating ?
19:56:49 <allbery_b> there' a limit to the number of channels a bot (or anyone?  haven't played with it) may join
19:56:52 <dons> yeah, there's a 20 chan limit
19:56:57 <dons> hence lisppaste2 and 3
19:57:12 <robreim> How might I go about making cabal have system-dependent build-depends? eg require win32 on windows platforms and gconf on linux.
19:57:32 <vininim> gah, I'm about to use IORef even though it looks ugly :/
19:59:25 <dons> robreim: currently there's no 'conditional cabal' syntax
19:59:29 <dons> but it has been proposed
19:59:35 <dons> so the work around is to create 2 cabal files
19:59:47 <dons> and ask the win32 (or unix) people to mv foo.cabal.win32 to foo.cabal
19:59:49 <dons> before building
20:00:13 <robreim> *nods* makes sense. Thanks.
20:01:11 <SamB_XP> tell me when I can make a package only build if people give me candy!
20:02:04 <dons> SamB_XP: so there's a proposal to add build-depends: candy
20:02:14 <dons> the candy meta-package isn't online
20:02:29 <dons> what you do is mail candy to SamB, who then mails you back the package source
20:02:30 <sjanssen> cabal-get candy
20:02:30 <dons> which you build
20:02:44 <dons> once that goes through, you hvae satisfied the candy dep, and build can proceed
20:02:53 <dons> sjanssen: cabal-put candy http://SamB.org
20:02:56 <lambdabot> Title: [Gandi] Nom de domaine - Enregistrement et Transfert
20:03:02 <dons> oh my
20:03:02 <SamB_XP> lol
20:03:03 <sjanssen> ha
20:03:20 <SamB_XP> fits of laughter
20:03:23 <sjanssen> SamB_XP: no domain for you!
20:03:33 * SamB_XP too tired or something
20:03:52 <dons> there's some plans to automate the candy dep resolution
20:03:53 <sjanssen> intercalate "is"
20:04:02 <dons> so that cabal-get foo, where foo depends on candy
20:04:10 <dons> will automatically request fedex to send SamB some candy
20:04:15 <dons> so the user only needs to say:
20:04:17 <dons> cabal-get foo
20:04:23 <dons> and not have to worry about resolving candy deps
20:04:41 <dons> i hope to have this implemented by the hackathon
20:04:49 <sjanssen> instead you've got the compulsory --credit-card= flag
20:05:07 <dons> heh
20:05:25 <SamB_XP> oooh, obviously we need {/etc/cabal,~/.cabal}/payment.conf!
20:06:27 * Binkley wants candy
20:06:49 * allbery_b wants The Go-Gos (or whoever thgey were) otu of his head :>
20:06:50 <kNt> someone can give me a help here.. i need some help here.. i re-used some code applying it to my data & i'm stuck here in details that are missing me here's the code --> http://paste.lisp.org/display/32347
20:07:03 <sorear> yes candy | nc samb.org
20:07:31 <sjanssen> kNt: could you annotate with the error message?
20:07:31 <SamB_XP> actually my domain name is naesten.dyndns.org
20:07:39 <kNt> ok
20:07:59 <SamB_XP> but port 80 is blocked, because we don't have a serving account with the ISP...
20:08:24 <kNt> http://paste.lisp.org/display/32347#1 here it is
20:09:16 <syntaxfree> gmail is down!
20:09:16 <robreim> cabal should add to the author's karma on lambdabot each time it installs a package for someone.
20:09:17 <sorear> kNt: if you select #haskell from the list lisppaste2 will do your announcing for you
20:10:34 <shapr> juli: Hey, do you code Haskell?
20:10:49 <monochrom> X X X
20:11:00 <juli> shapr: A/S/HASKELL?
20:11:03 <shapr> Y Y Y
20:11:03 <juli> shapr: Also, yes.
20:11:04 <kNt> tnks.. i've done that before but today i wasnt able to find it. kind of blindf matter i think :)
20:11:29 <SamB_XP> oh. does A/S/L mean Age/Sex/Programming Language?
20:11:55 <shapr> hah
20:12:03 <allbery_b> @remember SamB_XP oh. does A/S/L mean Age/Sex/Programming Language?
20:12:52 <SamB_XP> hmm.
20:13:00 <SamB_XP> @quote SamB_XP
20:13:00 <monochrom> Agility/Synergy/Language
20:13:01 <lambdabot>  oh. does A/S/L mean Age/Sex/Programming Language?
20:13:03 <SamB_XP> @quote SamB_XP
20:13:04 <lambdabot>  oh. does A/S/L mean Age/Sex/Programming Language?
20:13:07 <SamB_XP> hmm.
20:13:26 <monochrom> The three most irrelevant and pointless things of programmers. :)
20:13:32 <SamB_XP> are we establishing a special section for quotes I say when I should have gone to bed or something?
20:13:55 <monochrom> There is no need.
20:14:14 <sjanssen> kNt: you're missing a parameter to insert on the line the compiler complains about
20:14:15 <SamB_XP> because otherwise shouldn't that have gone under "SamB"?
20:14:18 <sjanssen> @type Data.Map.insert
20:14:19 <lambdabot> forall a k. (Ord k) => k -> a -> Data.Map.Map k a -> Data.Map.Map k a
20:14:36 <robreim> kNt: insert ((Fst :.: Snd) :@: (Var x)) st <-- missing an argument
20:15:35 <robreim> gah, too late
20:16:13 * allbery_b doesn't know what conventions apply to whose /nickns, sorry
20:19:45 <kNt> tnks. i've seen it. because i've readapted the code i don't have much practice the Data.Map .. how can i change MyState without using the insert function? i don't want to insert anything.. i just want to update it
20:20:29 <kNt> is it the ! function ?
20:21:51 <dons> Excedrin et al, for those interested in the typeOf script, i've written it up here, http://www.cse.unsw.edu.au/~dons/blog/2006/12/14#vim-typeof
20:21:52 <lambdabot> Title: Haskell hacking
20:23:36 <kNt> is there any function like insert but only to update ?
20:23:46 <robreim> @type Data.Map.update
20:23:47 <lambdabot> forall a k. (Ord k) => (a -> Maybe a) -> k -> Data.Map.Map k a -> Data.Map.Map k a
20:23:59 <robreim> @type Data.Map.adjust
20:24:00 <lambdabot> forall a k. (Ord k) => (a -> a) -> k -> Data.Map.Map k a -> Data.Map.Map k a
20:24:01 <dons> insert will update too , no?
20:24:09 <dons> ?docs Data.Map
20:24:10 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
20:24:13 <IPI> Question: In order to show in Haskell that there are one or more items in a list , [x:xs] can be used right?
20:24:25 <allbery_b> (x:xs) is cons syntax
20:24:27 <dons> IPI: close (x:xs)
20:24:50 <kNt> @type Data.Map.insert
20:24:51 <lambdabot> forall a k. (Ord k) => k -> a -> Data.Map.Map k a -> Data.Map.Map k a
20:24:52 <dons> the squre brackets are special list notation, used as:    [1,2,3,4]
20:25:00 <IPI> ok ... what about there are only two items in given list : (x:xs:zs) ?
20:25:14 <dons> (x:y:[])
20:25:16 <dons> or [x,y]
20:25:28 <IPI> right .. :) Thanks
20:25:42 <dons> > let only2 [x,y] = True ; only2 _ = False in only2 [1,2]
20:25:44 <lambdabot>  True
20:25:47 <dons> > let only2 [x,y] = True ; only2 _ = False in only2 "ab"
20:25:49 <lambdabot>  True
20:25:58 <dons> > let only2 [x,y] = True ; only2 _ = False in only2 (1.0:2.0:[])
20:25:59 <lambdabot>  True
20:26:26 <IPI> makes sense
20:26:31 <dons> > let only2 (x:y:[]) = True ; only2 _ = False in only2 "haskell"
20:26:32 <lambdabot>  False
20:27:08 <dons> $ host reddit.com
20:27:09 <dons> reddit.com A record currently not present
20:27:11 <dons> *sigh*
20:27:26 <dons> i'll have to *shock horror* write something
20:27:54 <vininim> :t fromInt
20:27:55 <lambdabot> Not in scope: `fromInt'
20:28:01 <dons> :t fromIntegral
20:28:03 <dons> ?
20:28:03 <lambdabot> forall b a. (Num b, Integral a) => a -> b
20:28:09 <sorear> :t fromInteger
20:28:10 <lambdabot> forall a. (Num a) => Integer -> a
20:28:22 <dons> ?users
20:28:22 <lambdabot> Maximum users seen in #haskell: 288, currently: 257 (89.2%), active: 44 (17.1%)
20:28:23 <sorear> :t fromRational
20:28:25 <lambdabot> forall a. (Fractional a) => Rational -> a
20:28:37 <Excedrin> dons: neat, thanks!
20:28:41 <vininim> they should reap all old haskell doc in the net. =P
20:29:16 <kNt> :t Data.Map.insert
20:29:18 <lambdabot> forall a k. (Ord k) => k -> a -> Data.Map.Map k a -> Data.Map.Map k a
20:29:25 <dons> vininim: reap? remove you mean?
20:29:28 <dons> (yes!)
20:29:31 <dons> starting with zvon's guide
20:32:30 <Smokey`> ouch, pack foo -- where foo is a list of size 480000, takes ~6 seconds, even with -O2 -_-
20:33:00 <dons> to compile?
20:33:04 <Smokey`> no, to run
20:33:12 <Smokey`> takes a second or so to compile :P
20:33:26 <dons> umm. is pack as in Data.ByteStringpack ?
20:33:29 <vininim> There we go IORef :~~~~~
20:33:33 <dons> and foo is static? or dynamic?
20:33:40 <dons> (is it a string literal?)
20:33:49 <Smokey`> dons: correct, and not a string literal
20:33:58 <sorear> 480Kb string literal - would be something :)
20:34:03 <dons> Smokey`: so you've got a really big [Char] ?
20:34:12 <Smokey`> really big [Word8], yes :)
20:34:13 <dons> Smokey`: why not suck it directly into a bytestring then.
20:34:29 <dons> you must avoid [Word8]
20:34:46 <sorear> 480,000 [word8] takes atleast 6 Mbytes
20:34:46 <Smokey`> mainly because I'm not sure how... only way I know how to construct ByteStrings, is by packing a list into a bytestring
20:34:47 <dons> Smokey`: want to paste the code?
20:35:07 <sorear> [Word8] consumes 12 bytes per byte of data
20:35:15 <dons> you can use unfold/replicate/...  and so on
20:35:25 <dons> sorear: exactly. so it'll be 480k in a bytestring
20:35:31 <sorear> for each byte, a address generation stall *and* cache miss are forced
20:35:35 <dons> but 480k * 12 outside
20:35:52 <Smokey`> sorear: I envy how much you know about the insides of Haskell :)
20:35:52 <sjanssen> unfoldr++
20:36:30 <Smokey`> dons: hmm not right now, I should be getting ready to go out soon :)  but i'll have a quick look at alternate methods of constructing the ByteString before I do :)
20:36:31 <jcreigh> hmm...is Word8 not an immediate type? Or does Haskell (By which I mean: GHC) even have those.
20:36:49 <geckosen1tor> dons: hi, i spaced out
20:36:54 <dons> jcreigh: immediate?
20:37:02 <dons> unboxed?
20:37:14 <sorear> [a] needs four bytes for the (:) v.s. [], four bytes for a (it's boxed), and four bytes for the link pointer
20:37:21 <geckosen1tor> dons: i'm interested in using opengl with haskell
20:37:28 <sorear> ?kind []
20:37:29 <lambdabot> * -> *
20:37:36 <sorear> ?kind GHC.Prim.Word8#
20:37:38 <lambdabot> Not in scope: type constructor or class `GHC.Prim.Word8#'
20:37:39 <sorear> ?kind GHC.Prim.Int#
20:37:41 <lambdabot> #
20:37:44 <vininim> geckosen1tor: http://blog.mikael.johanssons.org/archive/2006/09/opengl-programming-in-haskell-a-tutorial-part-2/
20:37:46 <dons> geckosen1tor: cool. there's pretty good opengl support (have you seen Frag?)
20:37:48 <lambdabot> Title: Michi&#8217;s blog Â» Blog Archive Â» OpenGL programming in Haskell, a tutorial  ..., http://tinyurl.com/yl5ljl
20:37:49 <kNt> someone with pacience to try to explain me what http://paste.lisp.org/display/32347 can i do to convert an expression (fst(snd(x)) to (fst.snd) x that's what defo should do.. but i can't update the stte. i don't really know howto
20:37:50 <jcreigh> dons: I think I mean unboxed. Stored in the same word that a pointer would be, but take advantage of memory alignment to and use a few magic bits to say "this isn't a pointer, this is a fixnum"
20:37:54 <geckosen1tor> dons: no
20:38:09 <sorear> a value of kind # cannot be forces into a slot of kind *
20:38:11 <dons> jcreigh: yes, you can unbox things (i.e. the {-# UNPACK #-} pragma. but [a] doesn't do this
20:38:29 <dons> but bytestrings certainly do
20:38:32 <SamB_XP> jcreigh: yhc does this, IIRC
20:38:43 <SamB_XP> tagging of ints
20:38:46 <jcreigh> > maxBound :: Int
20:38:47 <lambdabot>  2147483647
20:39:01 <sorear> bytestrings are also *bytes*.  [Char] uses UTF-32
20:39:37 <geckosen1tor> dons: do you know.. is there glut support?
20:39:46 <geckosen1tor> dons: I have a very funny opengl setup, but it has glut
20:39:55 <dons> yeah, there's glut support
20:39:59 <sjanssen> sorear: probably more accurate to say that String is a list of code points.  [Char] doesn't really have an encoding
20:40:01 <sorear> Graphics.UI.GLUT
20:40:08 <geckosen1tor> cool
20:40:19 <geckosen1tor> well I need to learn the language first
20:41:25 <JFT> Is Template Haskell part of the "regular" GHC6.6 distro or is it something that needs to be installed in extra?
20:41:37 <dons> its part of the regular install
20:41:56 <dons> you need -fth to enable it of course
20:42:02 <JFT> and haskell-src is too I guess?
20:42:14 <JFT> Actually I'm just trying to compile Hoc
20:42:28 <dons> not haskell-src, template-haskell package
20:42:45 <JFT> haskell-src isn't include?
20:43:01 <dons> yeah, its there too
20:43:11 <JFT> Ok thanks you
20:43:12 <dons> (actually, it might be in extra-libs)
20:43:30 <JFT> does it make any difference if  it is there?
20:43:36 <JFT> anything specific I should setup?
20:43:39 <dons> no difference
20:43:51 <dons> if you've installed the extra-libs package
20:44:25 <JFT> ghc-pkg list doesn't show extra-libs....
20:44:35 <JFT> is that the right way to check?
20:45:03 <dino-> Whew, finally gtk2hs is building.
20:45:14 <allbery_b> extra-libs is an OS-level package.
20:45:25 <sjanssen> JFT: extralibs is a collection of packages
20:45:30 <allbery_b> try looking for mtl, which IIRC is one of the GHC packages in extralibs
20:45:59 <JFT>  mtl-1.0 ?
20:46:17 <allbery_b> that'd be it, yes
20:46:31 <JFT> so that mean I have extralibs too?
20:46:43 <allbery_b> yes.  at least some of it.
20:46:54 <JFT> Thanks
20:46:55 <sjanssen> JFT: if you have haskell-src, it should appear in ghc-pkg list too
20:46:59 <allbery_b> I don't recvall getting haskell-src when I installed ghc 6.6 and extralibs, but...
20:47:23 <allbery_b> ...but it seems I'm wrong :) it's listed in my install
20:47:23 <dino-> How spooky. Just when you guys were saying yada 'mtl' yada, my build stopped because I'm missing mtl.
20:47:41 <JFT> sjanssen: Thanks
20:47:44 <sorear> ... also in extralibs.
20:47:54 <dons> dino-: extra libs! :)
20:48:06 <dons> package systems should always install extra libs by default, I think..
20:48:10 <dons> dino-: what system are you on?
20:48:23 <dino-> Trying to do this as much 'The Debian Way' as possible, so I had it install libghc6-mtl-dev
20:48:29 <dons> yep
20:48:35 <sjanssen> dons: I prefer each package to install separately
20:48:46 <scsibug> I feel like I'm doing something icky with the read/show in this code... anyone want to set me straight?
20:48:48 <sorear> If you're using the darcs-version, ./darcs-all --extra get
20:48:48 <lisppaste2> scsibug pasted "better way to get time?" at http://paste.lisp.org/display/32350
20:49:01 <Smokey`> ugh, much to learn I still have... so very very much...  how this is now a) taking longer, using unfoldr, and peaks at a memory usage of ~220mb, is soo far beyond me
20:49:02 <dons> sjanssen: ok. as long as its easy to do
20:49:23 <dons> Smokey`: Data.ByteString.unfoldr?
20:49:27 <Smokey`> dons: correct
20:49:34 <dons> Smokey`: can you post the code?
20:49:40 <dons> ?paste ,<-- here
20:49:41 <lambdabot> http://paste.lisp.org/new/haskell
20:50:15 <Smokey`> sure thing... but I've gotta go after that
20:50:28 <JFT> when building Hoc I'm getting:  Could not find module `Language.Haskell.THSyntax' hence why I'm asking about THaskell and haskell-src
20:50:37 <dons> so I've put up our first 'policy' to cement the newbie-friendly culture, http://haskell.org/haskellwiki/IRC_channel#Principles
20:50:38 <lambdabot> Title: IRC channel - HaskellWiki
20:50:48 <dons> JFT: hmm. are you using --make
20:50:56 <JFT> dons: yes
20:50:59 <dons> It's possibly HoC hasn't been updated to ghc 6.6?
20:51:05 <dons> (or there's a new er version?)
20:51:24 <JFT> I just got it from sourceforge
20:51:41 <dons> let's ask the author:
20:51:46 <dons> ozone, around?
20:51:56 <dons> ozone: what's the latest place to find HoC?
20:52:21 <JFT> doh.... latest release on sourcefogre is 0.7 May 2004.....
20:52:26 <lisppaste2> Smokey` pasted "bad... bad code..." at http://paste.lisp.org/display/32351
20:52:27 <JFT> I guess that explains it :P
20:52:35 <dons> right. now I think there's been recent activity on this though
20:52:44 <dons> I'm pretty sure Wolfgang Thaller mentioned something on the mailing list this week
20:52:51 <dons> JFT, you might like to mail him?
20:52:56 <Smokey`> there's my terrible newbie code :)   hope you can make some sense of it...
20:52:58 <dons> Smokey`: thanks
20:53:00 <dons> i'll hvae a look
20:53:13 <Smokey`> with that said I'm off for the night, feel free to ask more Qs / comment, i'll answer when I get back
20:53:17 <JFT> dons: I need to get on the list I guess!
20:53:29 <dons> ?where mailinglist
20:53:29 <lambdabot> http://haskell.org/haskellwiki/Mailing_lists
20:54:18 <JFT> dons: Which list do you recommand?
20:54:25 <dons> Smokey`: so you know the length fo the final string before you start to create it?
20:54:38 <dons> JFT: haskell-cafe@ and haskell@
20:54:45 <dons> (i.e. discussion and announcements)
20:54:45 <JFT> dons: Thank you
20:55:59 <mwolak> is there a "nice" way to create Infinity::Double ?
20:56:07 <brad> dons and others - any experience with JRegex? is it cheating to use pcre in haskell?
20:56:45 <jcreigh> > (1 / 0) :: Double
20:56:47 <lambdabot>  Infinity
20:56:56 <jcreigh> ...but that's not "nice"
20:57:05 <monochrom> Nullity :)
20:57:15 <shapr> regexes aren't cheating in Haskell, but most people write parsers because they tend to be better for error reporting and long term maintenance.
20:57:24 <monochrom> 1/0 is already the nicest.
20:57:32 <sorear> ?quote jwz
20:57:33 <lambdabot> jwz hasn't said anything memorable
20:57:37 <shapr> noo!
20:57:39 <SamB_XP> hahaha
20:57:45 <SamB_XP> lambdabot is so naive
20:57:49 <mwolak> ugly to my eyes :( but if that's the best there is, thans
20:57:51 <brad> i'm an old perl head, i think i need to bring pcre with me if i am going to continue with haskell :)
20:57:52 <mwolak> err thanks
20:58:07 <jcreigh> monochrom: Floating point numbers are way ahead of the curve. :)
20:58:11 <sjanssen> Smokey`: Data.List.length rgb will be revaluated for each byte emitted ... probably very very slow
20:58:26 <monochrom> regex is fine.  as long as you write readable regex.
20:58:49 <sjanssen> Smokey`: you should just be using unpack instead of unfoldr here
20:59:02 <brad> well thanks for the insights! take care
20:59:20 <dons> brad: you should consider the new regex packages though
20:59:29 <dons> such as regex-pcre and regex-compat
20:59:33 <monochrom> left
20:59:35 <dons> ah well
20:59:47 <SamB_XP> @tell brad to look at regex-pcre
20:59:48 <lambdabot> Consider it noted.
21:00:00 <dons> ?where regex-pcre
21:00:01 <lambdabot> I know nothing about regex-pcre.
21:00:27 <IPI> Question: a function composition in Haskel is : func1.func2.func3
21:00:34 <dons> yeah
21:00:39 <dons> uses the (.) function
21:00:57 <dons> > (ord . toUpper) 'x'
21:00:59 <lambdabot>  88
21:01:04 <IPI> but then how do you tell what is the signiture of func ? in my example?
21:01:17 <IPI> do you basically line up the signiture of all the other funcs?
21:01:24 <dons> :t (.)
21:01:26 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
21:01:27 <dons> :t toUpper
21:01:28 <lambdabot> Char -> Char
21:01:29 <dons> :t ord
21:01:30 <lambdabot> Char -> Int
21:01:31 <dons> hence:
21:01:37 <dons> :t (ord . toUpper)
21:01:39 <lambdabot> Char -> Int
21:02:03 <dons> so you take: (b -> c) -> (a -> b) -> a -> c and unify it with: a == Char, b == Char, c == Int
21:02:36 <dons> so then (.) ord toUpper :: Char -> Int
21:02:43 <dons> :t (.) ord toUpper
21:02:44 <lambdabot> Char -> Int
21:02:54 <dons> :t ord . toUpper -- same thing
21:02:55 <lambdabot> Char -> Int
21:03:06 <monochrom> I love Bird's way of writing function types as  codomain <- domain.  Works perfectly with (.)
21:03:26 <monochrom> OK basically I love Bird.
21:03:27 <jcreigh> > let compose f g x = f (g x) in compose ord toUpper 'x'
21:03:28 <lambdabot>  88
21:03:31 <IPI> ok .. makes sense ...
21:04:11 <dons> IPI: best way to work this out is to open up ghci, and when you don't know what the type is, ask :t
21:04:21 <dons> you'll quickly work out how the types are inferred
21:04:56 <sorear> I wonder how easy it would be to parse the standardized-looking Wikiquote pages.  ?wq Jamie W. Zawinski ...
21:06:17 <IPI> dons, its a little more complicated than it seems
21:06:24 <jcreigh> PIP: note that you can ask for the type of *any* expression, not just functions. So you can say, eg, :t map toUpper
21:06:30 <jcreigh> *IPI
21:06:39 <IPI> here is the question i am working one now: http://www.rafb.net/paste/results/mgh92Z13.html check it out your self
21:07:40 <IPI> so from there here is the function : alltogether input = morefunction.onefunction.moremore.anotherfunction input
21:08:40 <IPI> so based one what you had up there i would just write the signature of each function followed by -> in this format right? (    ) -> (   )
21:08:56 <sorear> map toUpper is a function.
21:09:04 <dons> let me see if I can illustrate how the inference works
21:09:22 <jcreigh> sorear: sorry, I meant other than just :t foldl or :t sequence or whatever.
21:10:08 <dons> (just give me a second to write all this down)
21:10:41 <monochrom> morefunction.onefunction.moremore.anotherfunction is right :)
21:11:18 <IPI> np
21:11:29 <sorear> :t (:[]) . (:[])
21:11:31 <lambdabot> forall a. a -> [[a]]
21:15:36 <dibblego> if you have a function that has pre-conditions on its arguments, but it does not check that pre-condition intentionally (it is expensive), what is the best way to do it?
21:15:53 <sorear> name it unsafeFoo
21:16:01 <dibblego> that's what I figured
21:16:03 <sorear> provide foo that checks precondition
21:16:11 <sorear> like unsafeRead in Array
21:16:28 <sorear> also note Data.Map.mapAsc as an example
21:16:33 <dibblego> ok thanks
21:16:44 <sorear> ?hoogle mapMonotonic
21:16:45 <lambdabot> Data.Set.mapMonotonic :: (a -> b) -> Set a -> Set b
21:16:49 <sorear> ?hoogle mapAsc
21:16:50 <lambdabot> No matches found
21:16:56 <dibblego> it would be nice if you could annotate with meta-data without having to use the name
21:17:04 <sorear> ?
21:17:21 <dibblego> [unsafe] foo -- or something
21:17:40 <Smokey`> dons: correct, i know the length before I start.
21:17:56 <dibblego> have the compiler turn on pre-condition checking or something
21:18:02 <dons> IPI: ok, I've written up the solution I use to do this: http://cgi.cse.unsw.edu.au/~dons/blog/2006/12/14#type-inference-by-hand
21:18:05 <sorear> Currently, function annotation is accomplished by wrapping the result in an escape-proof constructor (IO)
21:18:07 <lambdabot> Title: Haskell hacking, http://tinyurl.com/y7oock
21:18:13 <dons> IPI: see if you can follow those reasoning steps
21:18:24 <dibblego> an escape-proof constructor?
21:18:35 * IPI is working on it...
21:18:37 <dibblego> I might be using one of those myself
21:18:40 * IPI thanks dons
21:18:53 <dons> the key is to use 'type' to name the complex types
21:18:58 <dons> then you can see how it all plugs together
21:19:01 <dibblego> a data type without constructors outside the module
21:19:05 <dons> (at least, I see that :)
21:20:30 <sorear> What Cabal extension declarations should I use for SYB?  Rank2Types ? Generics ? both ?
21:20:39 <brad> seeing an error when building Jregex:
21:20:40 <lambdabot> brad: You have 1 new message. '/msg lambdabot @messages' to read it.
21:20:51 <brad> Could not find module `Monad': it is a member of package haskell98, which is hidden
21:21:07 <sorear> brad: ghc-pkg expose haskell98
21:21:18 <sorear> does anyone know why that feature exists?
21:21:34 <dons> h98 compatibilitiy?
21:22:07 <allbery_b> module hiding, presumably
21:22:11 <brad> hmmm, the command you gave me did do something, but i still get the same error
21:22:16 <allbery_b> er, package hiding
21:22:32 <sorear> brad: Monad is now called Data.Monad
21:22:39 <sorear> in post-98 implementations
21:22:48 <brad> ah, okay, since i have ghc6.6 this would be an issue (?)
21:23:01 <allbery_b> haskell98 mode should still be supported
21:23:07 <sorear> Monad is a compatibility alias, which is hidden by default for some silly reason.
21:23:17 <allbery_b> (haskell98 had a flat namespace)
21:23:24 <dons> IPI: let me know if that helps
21:23:30 <sorear> s/Data./Control./
21:23:46 <IPI> dons, i see what you did .. very nice... i just need to write it down .. and try to do it my self ...
21:23:52 <IPI> great job ...
21:24:20 <brad> Could not find module `Data.Monad': Use -v to see a list of the files searched for.
21:24:28 <brad> use -v for what ? ghc-pkg?
21:24:32 <mathewm> Control.Monad
21:24:41 <allbery_b> sorear corrected him; it's Control.Monad, not Data.Monad
21:24:42 <mathewm> it changed again in the last minute ;)
21:24:59 <allbery_b> and the error message is referring to ghc -v ...
21:25:06 <dons> brad: Data.Monad ?
21:25:21 <brad> it is Control.Monad. now it complains about Maybe
21:25:26 * glguy blinks
21:25:28 <brad> i thought Maybe was in the Prelude?
21:25:40 <monochrom> This is now strange.
21:25:42 <dibblego> it is exported by Prelude
21:25:46 <dibblego> I think
21:25:56 <mathewm> I always needed to import Maybe
21:26:03 <dibblego> oh wait, me too
21:26:23 <glguy> I never import Maybe and always import Data.Maybe for the extra functions it imports
21:26:37 * mathewm goes to read up on Data.Maybe
21:26:59 <monochrom> But "import Maybe" is supposed to work.
21:27:07 <sorear> ?hoogle Maybe
21:27:08 <lambdabot> Maybe :: module
21:27:08 <lambdabot> Prelude.Maybe :: data Maybe a
21:27:08 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
21:27:16 * glguy came in late to the conversation and can be safely ignored
21:27:16 <sorear> ?hoogle fromMaybe
21:27:17 <lambdabot> Maybe.fromMaybe :: a -> Maybe a -> a
21:27:28 * mathewm cannot find docs on Data.Maybe
21:27:41 <brad> hmmm, i think i am getting there, changing to Data.Maybe, Data.Array seems to be working
21:27:48 <brad> i guess JRegex is a little old
21:27:55 <sorear> ?doc Data.Maybe
21:27:56 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Maybe.html
21:28:19 <mathewm> why isn't it in hoogle?
21:29:45 <brad> well i got it to build - thanks to you folks!
21:29:58 <brad> always amazed at how helpful this forum is!
21:30:22 <brad> dons - is lambabot documented on the web somewhere by the way?
21:30:24 <mathewm> I think this channel is the killer-feature of Haskell
21:30:43 <dons> ?where lambdabot
21:30:43 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
21:30:51 <dons> brad: there's a wiki page too
21:30:55 <dons> ?list <-- also commands
21:30:56 <lambdabot> No module "<-- also commands" loaded
21:30:59 <dons> ?list
21:31:00 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
21:31:14 <brad> awesome! thanks dons, i will bookmark it, seems legitimately useful!
21:31:21 <dons> brad: have you seen the new text-pcre package though?
21:31:35 <dons> there's regex-base/    regex-compat/  regex-posix/
21:31:41 <dons> in ghc 6.6's extra-libs bundle
21:31:46 <dons> and I belive also a pcre binding
21:31:56 <dons> (for efficient bytestring-based regexes)
21:32:19 <dons> http://sourceforge.net/projects/lazy-regex
21:32:20 <lambdabot> Title: SourceForge.net: Text.Regex.Lazy
21:32:35 <dons> it is the replacement for JRegex
21:32:40 <brad> ah!
21:32:52 <brad> i won't be hitting the "install" phase on cabal
21:32:54 <brad> just yet
21:33:34 <brad> so this is the preferred route for perl-compatible regex's now?
21:33:43 <mathewm> I am not seeing much difference in the Data.Maybe and haskell98.Maybe packages
21:33:58 <dons> and the regex-* things are in extralibs, docs here: http://haskell.org/ghc/docs/latest/html/libraries/regex-posix/Text-Regex-Posix-ByteString.html
21:33:59 <lambdabot> http://tinyurl.com/y2msu5
21:34:16 <dons> brad: yeah. since regex-* comes in the standard ghc install
21:34:27 <brad> does lambdadot make the tinyurl automagically?
21:34:32 <dons> yeah :)
21:34:38 <brad> ITS ALIVE
21:34:56 <lambdabot> And full of LAMBDAS!
21:35:17 <brad> oh bull, thats someone typing
21:35:20 <brad> had me going though
21:35:41 <dons> now, regards regex-pcre, I think its a separate package (since it depends on pcre.h)
21:35:42 <dibblego> can you have two modules loaded into ghci at the same time?
21:35:49 <dons> so you might have to grab that from the sourceforge page
21:35:54 <dons> dibblego: :m + Foo
21:35:56 <mathewm> :module +Foo
21:36:06 <dibblego> ah thanks
21:36:52 <brad> okay, so to be straight - if i have ghc66 installed, i already have Text.Regex.Posix.ByteString, but i need the files from sf.net to get pcre?
21:37:18 <brad> answered my own question with ghci
21:37:26 <brad> :m Text.Regex.Posix.ByteString
21:37:57 <dons> I think so yes.
21:38:09 <dons> you get posix regexes, i.e. regex.h, with a bytestring interface
21:38:17 <dons> or a String interface (if you use one of the other modules)
21:38:40 <brad> awesome
21:38:42 <dons> pcre regexes require regex-pcre, which I belive is a separate package.
21:38:58 <dons> when you find the url, please tell lambdabot with : @where regex-pcre http:// ....
21:39:07 <dons> (it 'd be on the sf page, I think)
21:39:11 <brad> will do!
21:39:25 <dons>  @where+ I mean
21:39:48 <brad> how do i send lambabot a message (irc idiot here)
21:40:08 <jcreigh> brad: /msg lambdabot whatever
21:40:10 <glguy>  /msg lambdabot a message
21:40:22 <brad> thanks jcreigh and glguy!
21:42:12 <sorear> Ok, I've reached the 'bug #haskell' threshold...  What's wrong?
21:42:13 <lisppaste2> sorear pasted "haddock gives a syntax error." at http://paste.lisp.org/display/32353
21:42:14 <dons> ?remember mathewm I think this channel is the killer-feature of Haskell
21:42:40 <dons> sorear: backslash in front of /
21:42:45 <dons> (annoying, I know)
21:42:53 <dons> so to/from  ->   to \/from
21:43:02 <dons> why, you may ask:
21:43:13 <dons> well, actually, I don't know
21:43:29 <dons> ah, I do. /emph/
21:43:44 <monochrom> yeah
21:44:16 <sorear> thank you, that would have taken uncomfortably close to forever to figure out.
21:44:41 <dons> heh
21:45:50 <dons> head . sortBy length . filter typeCorrect . map queDstion (users #haskell")
21:46:01 <dons> actually, that's a mapPar
21:46:08 <dons> (which is the whole point!)
21:46:51 <dons> miso time!
21:47:31 <brad> regex-pcre build error: Setup.hs: cannot satisfy dependency fps>=0.7
21:47:35 <brad> what is fps?
21:47:44 <Korollary> Data.ByteString
21:47:54 <notsmack> @where fps
21:47:55 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
21:47:55 <Korollary> if you have ghc6.6, you have that satisfied
21:48:04 <IPI> thanks dons for your function composition solution... got it now :)
21:48:04 <Korollary> so you can remove it from the cabal file
21:48:44 <IPI> one more question : does this like look ok, if 'target' is a list :      fillarray target n = [target|target <-[2*(x+1)|x<-[1..n]]]
21:49:31 <brad> ah, okay Korollary, thanks@
21:49:37 <brad> i will try that
21:50:24 <brad> Korollary - your advice worked
21:50:28 <brad> thank you!
21:50:55 <dons> brad, so you got regex-pcre building?
21:51:16 <dons> > [target|target <-[2*(x+1)|x<-[1.10]]]
21:51:18 <lambdabot>  [4.2]
21:51:58 <brad> o have it built and installed dons!
21:52:07 <brad> thanks to everyone here!
21:52:08 <dons> great. I'm glad that went smoothly
21:52:23 <IPI> so it works .. nice ... what is exactly this lambdabot ?
21:52:25 <brad> i installed it using --user (by the way, cabal is great!)
21:52:30 <brad> and ghci still found it
21:52:56 <dons> IPI, its a super bot from beyond the stars! given to us as a gift by alien lambda beings with superior technology   ;)
21:52:57 <brad> cabal is a worthy repsonse to Make::Maker!
21:52:58 <jcreigh> You know you're making progess when your backtracking solver merely non-terminates instead of not compiling due to type errors. :)
21:53:23 <IPI> intresting ... LOL
21:53:59 <glguy> please correct: {-# GHC_OPTIONS fglasgow-exts #-}
21:54:11 <Lemmih> OPTIONS_GHC
21:54:26 <glguy> and a '-'
21:54:27 <glguy> got it
21:54:29 <glguy> thansk
21:54:46 <mathewm> I thought "OPTIONS" was preferred to "OPTIONS_GHC"
21:54:49 <mathewm> where did I see that?
21:55:08 <IPI> having : fillarray target n = [target|target <-[2*(x+1)|x<-[1..n]]] , what variables exit before , during and after execution of the function ?
21:55:09 <Lemmih> mathewm: -fglasgow-exts might not be available on hugs/nhc/...
21:55:15 <IPI> i guess before , there is none ...
21:55:19 <mathewm> oh, I get it
21:55:32 <IPI> during : we have n , x , [target] right?
21:55:39 <IPI> after: we have target ?
21:55:47 <dons> after, you have just the result list
21:56:01 <dons> > let f n = [ n | n <- [1..10] ] f 10
21:56:02 <lambdabot>  Parse error
21:56:05 <dons> > let f n = [ n | n <- [1..10] ] in f 10
21:56:06 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
21:56:14 <IPI> ok ... but what about during ?
21:56:14 <dons> > let f x = [ n | n <- [1..x] ] in f 10
21:56:16 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
21:56:32 <dons> IPI: during , you can see the names of variables that are used. such as 'n'
21:56:49 <IPI> so n and x  but not the result right?
21:57:17 <dons> the result is built incrementally. (I don't really understand your question though)
21:57:37 <glguy> wanted to be able to write: [a == b |b <- x |(Just a) <- known]
21:57:49 <IPI> right ... this was a sample final question ..
21:57:55 <IPI> anyways , thanks again dons :)
21:58:00 <dons> sure :)
21:58:01 <vininim> argh
21:58:14 <vininim> Does IORef have any problem with list?
21:58:51 <dons> vininim: example?
21:59:02 <dons> (why are you using IORefs?)
21:59:33 <vininim> dons: State == too much dissonance for me
21:59:52 <vininim> example would be (Int,Int,[Int]) and doing the usual list processing
22:00:06 <dons> and you want mutable references for this?
22:00:25 <vininim> (functional) and expecting to pass functional stuff to modifyIO
22:00:31 <dons> ok.
22:00:32 <dons> that's fine
22:00:43 <dons> you got the IORef docs handy?
22:00:45 <glguy> vininim: data MyState = MyState { first :: Int, second::Int, third :: [Int] } -- then you can say: a <- gets first
22:01:46 <glguy> and if you write a setFirst,Second,Third, you'd have : modify (setFirst 4)
22:02:05 <vininim> dons: reading the cvs.haskell.org/Hugs o_O
22:02:05 <dons> > flip runState  (0,[]) $ do a <- get fst ; put (a+1, [1]) ; return "done"
22:02:06 <lambdabot>     add an instance declaration for (MonadState (State (a1, [a2]) a1)
22:02:07 <lambdabot>   ...
22:02:32 <dons> > flip runState (0,[]) $ do a <- gets fst ; put (a+1, [1]) ; return "done"
22:02:34 <lambdabot>  ("done",(1,[1]))
22:02:57 <vininim> =O
22:02:58 <mathewm> speaking of type errors, anyone not see the verizonmath debacle ?
22:02:58 <dons> vininim: note that using IORefs commits you to the IO monad for state updates
22:03:10 <dons> mathewm: yeah, pretty funny eh?
22:03:19 <glguy> > flip runState (0,[]) $ do a <- gets fst ; modify (first (+1)); modify (second (2:)) ; return "done"
22:03:20 <lambdabot>  ("done",(1,[2]))
22:03:57 <mathewm> yeah, the audio recording had me in stitches
22:04:12 <mathewm> though I think he could have explained a little more clearly to them
22:04:33 <dons> hey thetallguy
22:04:40 <dons> how's the lambdas?
22:06:12 * glguy wonders if there is a more idiomatic way to write: 
22:06:13 <glguy> prependN n x xs | n >= 0 = aux n | otherwise = error "buildList called with negative argument (n)" where aux 0 = xs ; aux n = x : aux (n-1)
22:06:31 <thetallguy> Funny you should ask.
22:06:42 <thetallguy> I logged on to talk to pointless.
22:06:51 <glguy> like... prependN n x xs = take n $ iterate (x:) xs
22:06:52 <dons> uh oh!
22:06:53 <glguy> or something
22:06:54 <thetallguy> ?pl (\x -> getFileStatus x >>= return . fileSize)
22:06:54 <lambdabot> (fileSize `fmap`) . getFileStatus
22:07:11 <thetallguy> I don't like the answer.
22:07:14 <glguy> >>= return is never a good idea :)
22:07:21 <thetallguy> That is, I don't think it clears things up.
22:07:28 <dons> neither do I :)
22:07:38 <dons> I'm not sure where the impression @pl clarifies things comes from
22:07:41 <dons> certainly not me!
22:07:41 <thetallguy> So I was looking for a more clever obscure solution.
22:07:54 <thetallguy> Is Dr. Haskell connected?
22:07:55 <glguy> prependN n x xs = iterate (x:) xs !! n -- rather
22:08:02 <dons> mm. is _that_ kleisli composition too?
22:08:27 <dons> thetallguy: no, it isn't
22:08:33 <thetallguy> Too late in the day for a question like that for little old me.
22:08:34 <glguy> (Kleisli getFileStatus >> arr fileSize) x
22:08:35 <dons> but it should be.
22:08:41 <glguy> runKleisli^
22:09:00 <glguy> and >>>
22:09:02 <dons> glguy: but what about with the >=> proposal?
22:09:12 <thetallguy> Okay, well at least  nothing tremendously obvious popped up.
22:09:13 <glguy> dons you'd have to tell me about that proposal
22:09:30 <dons> these guys: http://hackage.haskell.org/trac/ghc/ticket/997
22:09:30 <thetallguy> I just kept looking at it thinking it should simplify to something clearer.
22:09:32 <lambdabot> Title: #997 (Add Kleisli composition to Control.Monad) - GHC - Trac
22:09:37 <thetallguy> Nice post about community.
22:09:41 <dons>     (>=>) :: (Monad m) => (a -> m b) -> (b -> m c) -> (a -> m c)
22:09:41 <dons>     (<=<) :: (Monad m) => (b -> m c) -> (a -> m b) -> (a -> m c)
22:09:45 <thetallguy> Yeah, I'll read that in the morning..
22:10:03 <dons> so, (getFileStatus >=> return . fileSize) x
22:10:04 <thetallguy> I saw all that go by last month and decided to ignore it for the time being.
22:10:21 <thetallguy> Hardly better.
22:10:25 <glguy> in that specific case, I'd prefer fmap
22:10:30 <glguy> but I can see how that might be useful
22:10:43 <dons> so you want something like: >.> (Monad m) => (a -> m b) -> (b -> c) -> (a -> m c)
22:10:45 <thetallguy> And frankly, I've already alienated enough people.
22:10:58 <dons> and thus:  (getFileStatus >.> fileSize) x
22:11:18 <thetallguy> I don't want to piss off my friends who do like haskell.
22:11:21 <glguy> what is the difference in (fmap fileSize) and (fileSize `fmap`)
22:11:29 <dons> i.e. f >.> g = \x -> f x >>= return . g
22:11:45 <thetallguy> My eyes are crossing.
22:12:01 <thetallguy> This client has teeny little fonts.
22:12:05 <dons> ?let (>.>) :: (Monad m) => (a -> m b) -> (b -> c) -> (a -> m c) ; f >.> g = \x -> f x >>= return . g
22:12:06 <thetallguy> is that > dot >?
22:12:07 <lambdabot> Defined.
22:12:29 <thetallguy> Okay, I'm sticking with my little lambda for now.
22:12:33 <dons> > L.>.> readFile length
22:12:34 <lambdabot>  Parse error
22:12:39 <dons> > (L.>.>) readFile length
22:12:41 <lambdabot>  <[Char] -> IO Int>
22:12:44 <glguy> dons: what's wrong with   liftM g . f?
22:12:52 <dons> >readFile L.>.> length
22:12:56 <dons> > readFile L.>.> length
22:12:57 <lambdabot>  <[Char] -> IO Int>
22:12:58 <thetallguy> lol
22:13:21 <dons> > liftM length . readFile
22:13:22 <glguy> ?let oL = "for sure"
22:13:23 <lambdabot>  <[Char] -> IO Int>
22:13:23 <lambdabot> Defined.
22:13:26 <dons> :)
22:13:28 <glguy> > L.oL
22:13:29 <lambdabot>  "for sure"
22:13:39 <dons> heh
22:13:44 <dons> glguy++ wins for liftM
22:14:11 * glguy codes for the masses ;)
22:14:16 <dons> ?pl \x -> f x >>= return . g
22:14:17 <lambdabot> (g `fmap`) . f
22:14:23 <thetallguy> Hah!
22:14:26 <dons> and back to thetallguy's original code
22:14:26 <glguy> I think that lambdabot is over complicating that
22:14:34 <dons> ?unpl (g `fmap`) . f
22:14:35 <thetallguy> thanks glguy.  that's what I was thinking of.
22:14:35 <lambdabot> (\ d -> fmap g (f d))
22:15:02 <thetallguy> How do I give glguy karma?
22:15:14 <dons>  nick++
22:15:20 <dons> without leading space
22:15:23 <glguy> I accept Visa karma and Mastercard karma (=
22:15:27 <thetallguy> glguy++
22:15:28 <dons> or that ;)
22:15:33 <glguy> heh, thanks thetallguy
22:15:38 <glguy> I like your nick suffix
22:15:46 <mathewm> darn, I couldn't /nick nick :(
22:15:47 <thetallguy> Now I can sleep.
22:15:50 <thetallguy> ?
22:15:52 <dons> :)
22:15:58 <thetallguy> suffix?
22:16:04 <glguy> thetallguy
22:16:08 <glguy>       glguy
22:16:12 <thetallguy> Ah.
22:16:17 <glguy> err, off by one, just like C
22:16:17 <dibblego> f | x == a = .. | x == b = .. | otherwise = .. or f | x == a = .. | x == b = .. | x == c = ..  when I know that x can only be a, b or c - which is a better practice?
22:16:17 <thetallguy> See, I must be tired.
22:16:20 <IPI> Question: c â¢ b â¢ (a(x:xs)) y:ys in this line does function 'a' take in two lists ??
22:16:47 <sjanssen> > all ("guy" `isSuffixOf`) ["thetallguy", "glguy"]
22:16:49 <lambdabot>  True
22:16:58 <thetallguy> dons: you didn't cover how to deal with people who think going anywhere near Haskell is trouble.
22:17:03 <glguy> > all ("lguy" `isSuffixOf`) ["thetallguy", "glguy"]
22:17:05 <lambdabot>  True
22:17:48 <thetallguy> glguy: if you say your nick backwards, it sounds like you're drowning.
22:18:34 <dons> thetallguy: mm. you mean true advocacy?
22:18:42 <sjanssen> @elite yuglg
22:18:42 <lambdabot> YuGLG
22:19:16 <thetallguy> dons: this was something we discussed at CUFP
22:19:16 <dons> sjanssen: so did you ever get your blog set up?
22:19:21 <lisppaste2> mathewm pasted "what does this error mean?" at http://paste.lisp.org/display/32355
22:19:26 <glguy> > let f xs n = (reverse $ take n xs) ++ drop n xs in foldl f "lguy" [3]
22:19:28 <lambdabot>  "ugly"
22:19:29 * dons continues grooming sjanssen for lambda world domination...   ;)
22:19:38 <thetallguy> How to handle people who think your choice of language is dooming the world.
22:19:41 <sjanssen> dons: nope
22:19:44 <dons> thetallguy: hehe
22:19:47 <glguy> > let f xs n = (reverse $ take n xs) ++ drop n xs in foldl f "glguy" [5,3]
22:19:49 <lambdabot>  "guylg"
22:20:03 <glguy> > let f xs n = (reverse $ take n xs) ++ drop n xs in foldl f "glguy" [5,4,3]
22:20:04 <lambdabot>  "uglyg"
22:20:12 <thetallguy> The fellow from the Air Force said the C++ people in his group were angry about Scheme....
22:20:16 <dons> thetallguy: i.e. people who say: "Haskell seems to be buzz-full research platform" ?   ;-)
22:20:29 <geckosen1tor> antry about scheme?
22:20:39 <dons> "there could be a global advise : do not use this for doing your tasks"
22:20:43 <thetallguy> ...but completely squashed a job ad for a Smalltalk programmer.
22:20:43 <glguy> > let f xs n = let (a,b) = splitAt n xs in (reverse a) ++ b in foldl f "glguy" [5,4,3] -- last one, i swear
22:20:45 <lambdabot>  "uglyg"
22:20:50 * dons doesn't have a good strategy yet for people who say things like that.
22:21:00 <geckosen1tor> c++ is a horrible language
22:21:04 <thetallguy> Actually, I think you do.
22:21:04 <dibblego> dons, "your choice of language was once that too"
22:21:23 <thetallguy> I believe you said, `` Screw 'em, we have the technology.''
22:21:28 <dons> ah yes :)
22:21:42 <thetallguy> We were discussing Calvin and Hobbes at the time.
22:21:50 <sjanssen> is "we have the technology" from a movie?
22:21:52 <glguy> dons, I think that Prelude (or Data.List) should include  uncons f (x:xs) = f x xs
22:21:55 <dons> as long as we've got oleg and spj chained up somewhere, feeding us new abstractions, thing will be good...
22:21:57 <glguy> to compliment uncorry
22:21:59 <glguy> u*
22:22:09 <thetallguy> How's the next hackathon shaping up?
22:22:16 <dons> glguy: interesting! I was thinking this myself yesteday
22:22:21 <dons> thetallguy: pretty good. 15 so far
22:22:28 <dons> and big motivation to get hackage/cpan done
22:22:32 <dons> ?wiki Hac_2007
22:22:32 <lambdabot> http://www.haskell.org/haskellwiki/Hac_2007
22:22:45 <dons> I'm hoping to see a big spike in commits, some new libraries, and hackage finished
22:22:45 <glguy> dons: I think someone else probably suggested this (in channel even) but I rediscovered it today ;)
22:22:50 <mathewm> what makes a type context "rigid"?  has a non-polymorphic type?
22:22:51 <IPI> can you figure out the signature of 'a' in this example ?  http://www.rafb.net/paste/results/YFwr2z57.html
22:22:52 <glguy> converge = uncons aux where
22:22:52 <glguy>    aux x (y:ys) | x == y    = x
22:22:53 <glguy>                 | otherwise = aux y ys
22:22:56 <thetallguy> Ah, that reminds me.  Jeremy and I need to get that Cabal -> Debian thing finished.
22:23:06 <thetallguy> Everytime I turn around, there's a library missing.
22:23:15 <dons> mm. yes. that kind of thing will nicely complement a functionl hackage server
22:23:19 <vininim> dons: flip still doesn't work in a main that does IO
22:23:21 <dons> once all these new libraries start appearing online
22:23:26 <thetallguy> Speaking of which, do the gtk libs work with 6.6?
22:23:28 <sjanssen> glguy: technically, the list equivalent of uncurry is foldr
22:23:29 <dons> and we can safely add build-depends willy nilly
22:23:41 <dons> vininim: hmm?
22:23:46 <dons> vininim: oh, you wnat runStateT ?
22:24:06 <glguy> sjanssen: I think they are both equally related... one just knows more about the whole list
22:24:08 <dons> or somethign like: main =let (a,b)= runState .... in print a ?
22:24:21 <glguy> sjanssen: and one simply breaks apart a single instance of the constructor
22:24:47 <vininim> I don't think it will work with GLUT callbacks
22:25:27 <sjanssen> glguy: I meant that foldr is the hylomorphism on [a] and uncurry is the hylomorphism on (a, b)
22:26:06 <sjanssen> @pl \(x:y) -> f x y
22:26:06 <lambdabot> liftM2 f head tail
22:26:13 <geckosenator> how do I do a lambda function that doesn't take args?
22:26:22 <geckosenator> I tried (\ -> 5)
22:26:32 <sjanssen> @pl \f (x:y) -> f x y
22:26:32 <lambdabot> (`ap` tail) . (. head)
22:26:57 <glguy> iterate (x:) xs !! n  --  this doesn't actually store a list in memory does it? (discards as it goes?)
22:27:01 <sjanssen> geckosenator: that is a function that takes an argument and doesn't use it
22:27:15 <geckosenator> sjanssen: ok, well I want a function that doesn't take an argument
22:27:34 <geckosenator> is that even possible?
22:27:35 <sjanssen> geckosenator: umm, don't write the \ then? ;)
22:27:48 <thetallguy> That's called a value.
22:27:53 <glguy> > 5
22:27:55 <lambdabot>  5
22:27:56 <sjanssen> geckosenator, no, not really
22:27:58 <glguy> hooray!
22:28:17 <thetallguy> gecko: are you a scheme programmer?
22:28:20 <glguy> > let f = 5 in f -- even better
22:28:21 <lambdabot>  5
22:28:28 <geckosenator> thetallguy: i have used scheme a bit
22:28:28 <glguy> (lambda () 5)
22:28:35 <thetallguy> what are you trying to do?
22:28:42 <geckosenator> glguy: yeah, how do I do that?
22:28:43 <sjanssen> glguy: yes, the cons cells will be allocated and then immediately discarded
22:28:54 <mathewm> ew, I see this is a 6.4 -> 6.6 issue :(
22:29:07 <geckosenator> ((lambda () 5)) and get 5
22:29:16 <thetallguy> 5
22:29:23 <glguy> geckosenator: you just want to return the literal 5
22:29:28 <dons> > (\_ -> 5) ()
22:29:30 <lambdabot>  5
22:29:37 <glguy> geckosenator: you can name it: let x = 5
22:29:49 <geckosenator> maybe dons has what I'm trying to do
22:30:02 <geckosenator> but he still passed an arg
22:30:02 <glguy> > (\_ -> 5) "one argument"
22:30:03 <lambdabot>  5
22:30:05 <dons> > (const 5)()
22:30:05 <thetallguy> Sounds like you want a thunk.
22:30:06 <lambdabot>  5
22:30:12 <geckosenator> thetallguy: yeah
22:30:12 <thetallguy> Do you wan tthe value to change ?
22:30:16 <sjanssen> geckosenator: why do you want to write such a function?
22:30:20 <thetallguy> Like a random number generator?
22:30:46 <geckosenator> thetallguy: well right, every time you invoke it you can get a different result
22:30:51 <geckosenator> but maybe that doesn't make sense either
22:30:53 <glguy> What!
22:30:55 * glguy faints
22:30:57 <thetallguy> Not in Haskell
22:31:03 <geckosenator> ok
22:31:05 <thetallguy> That's Scheme thinking.
22:31:24 <thetallguy> You need to read the tutorial `you could have invented monads'
22:31:42 <thetallguy> read the example about random number generation.
22:31:51 <sjanssen> you can't call it a function if you get different results for the same input!
22:31:58 <geckosenator> does haskell have continuations?
22:32:07 <thetallguy> You would have to turn your head sideways for a bit.
22:32:08 <bitshifter> Yes
22:32:11 <thetallguy> but it is worth it.
22:32:12 <sjanssen> @hoogle Cont
22:32:25 <dons> geckosenator: it has monads, which generalise continutations, imperative flow control, backtracking and so on
22:32:36 <dons> ?docs Control.Monad.Cont
22:32:37 <glguy> > (flip runCont id) . callCC $ \exit -> exit 1
22:32:44 <geckosenator> dons: i'm still on types.. I think monads might be next
22:32:50 <dons> oh, the bot's having heart failure of some kind
22:33:10 <thetallguy> gecko: take a quick read through that tutorial
22:33:11 <dons> glguy: that was a nice bit of code to have just on hand...
22:33:25 <glguy> dons: the Cont code?
22:33:29 <dons> yeah
22:33:36 <thetallguy> it's the best way to start the conversion of your mind from Scheme to Haskell thinking.
22:33:39 <glguy> yeah, that's macro-3 (=
22:33:48 <geckosenator> i program in c a lot more than anything else
22:33:55 <thetallguy> dons, do you have the link?
22:33:55 <lambdabot> Control.Monad.Cont :: module
22:33:57 * glguy is kidding, of course
22:33:57 <lambdabot> Control.Monad.Cont.Cont :: ((a -> r) -> r) -> Cont r a
22:33:59 <lambdabot> Control.Monad.Cont.Cont :: newtype Cont r a
22:34:01 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Cont.html
22:34:03 <lambdabot>  1
22:34:12 <thetallguy> http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
22:34:14 <dons> ?google you could have invented monads
22:34:18 <thetallguy> There we go..
22:34:32 <glguy> dons: when I see the oportunity to type some code in for lambdabot to run that would be interesting to someone else... I type as fast as I can (-;
22:34:33 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ..., http://tinyurl.com/ecqzl
22:34:39 <thetallguy> Just 'invented monads' will put it up.
22:34:40 <lambdabot> http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
22:34:41 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ...
22:34:42 * glguy is still trying to prove his worth
22:34:46 <thetallguy> Okay, this time for sure, guys.
22:34:47 <dons> hehe :) good!
22:34:53 <thetallguy> I'll drop in this weekend.
22:34:57 <thetallguy> 'night.
22:35:08 <dons> ciao!
22:35:18 <glguy> byebye
22:36:10 <notsmack> so for happs i need base, regex-base, and regex-compat?  or am i missing an easier route?
22:36:26 <dons> all those are in the core and extra-libs package
22:36:30 <dons> (but that sounds reasonable)
22:37:06 <dons> so does everyone know who thetallguy is? :) (good to see him around)
22:37:19 <glguy> should we know who he is?
22:37:24 * sjanssen doesn't know who thetallguy is
22:37:27 <glguy> beshers?
22:37:28 <dons> ?google linspire
22:37:31 <lambdabot> http://www.linspire.com/
22:37:31 <lambdabot> Title: Linspire - The World's Easiest Desktop Linux
22:37:36 <dons> hint ..
22:37:52 <glguy> mainroom guy?
22:37:53 <glguy> mail*
22:39:13 <glguy> OS Team Lead at Linspire
22:39:22 <dons> previous work includes: http://www.galois.com/cufp/2006Abstracts.html#CliffordBeshers
22:39:25 <lambdabot> Title: Commercial Users of Functional Programming 2006 Abstracts
22:41:37 <lisppaste2> mathewm annotated #32355 with "yay me - fixed a trivial type error" at http://paste.lisp.org/display/32355#1
22:42:37 <glguy> mathewm: why "whatever k = \gen ->" instead of "whatever k gen ="
22:42:38 <glguy> ?
22:42:53 <mathewm> http://www.mail-archive.com/haskell@haskell.org/msg19388.html
22:42:55 <lambdabot> Title: [Haskell] Lexically scoped type variables
22:43:05 <mathewm> 6.4 made changes to lexical type variables
22:43:11 <mathewm> er, 6.6 changed it
22:43:48 <dons> sigfpe's back from holiday,
22:43:50 <dons> http://sigfpe.blogspot.com/2006/11/why-isnt-listt-monad.html
22:43:54 <mathewm> I don't understand why yet, but this was required for the PiMonad to build on 6.6
22:43:55 <lambdabot> Title: A Neighborhood of Infinity: Why isn't ListT [] a monad?
22:44:00 <dons> ah sorry. maybe that's old (?)
22:44:07 <dons> nono. its new
22:45:11 <dons> huh, now I get 'connection refused' for reddit
22:45:15 <dons> bee-zaar
22:45:32 * glguy can connect to programming.reddit.com
22:46:37 <dons> i'm in some kind of DNS backwater, obviously
22:48:00 <glguy> http://lwn.net/Articles/213977/
22:48:01 <lambdabot> Title: LWN: Binary-only kernel modules may be banned
22:48:17 <glguy> whoa, its like April fools and Theo-deRaadt is running the kernel
22:48:27 <dons> yeah . that was my thought!
22:48:44 <dons> Linus sez "Theo as right all along"
22:49:26 <glguy> heh, now the linux fankids can't get mad when I tell them blobs are "for the lose"
22:49:34 <glguy> (assuming this goes through)
22:49:54 <dons> :)
22:50:09 <bd_> what about http://article.gmane.org/gmane.linux.kernel/475824 ?
22:50:11 <lambdabot> Title: Gmane -- Mail To News And Back Again
22:50:57 <Excedrin> mathewm: you got PiMonad to build on ghc 6.6? what were the changes?
22:51:02 <glguy> that message (at least the first couple paragraphs) makes baby jesus want to cry (and so close to xmas too)
22:51:15 <mathewm> just the one to new, in the paste
22:51:27 <dons> mmm. have you guys been in contact with the author?
22:51:31 <dons> or should we just fork the PiMonad stuff?
22:51:34 <mathewm> and the use of -fallow-undecidable-instances
22:51:48 <dons> I guess submitting patches back is a better idea
22:52:11 <mathewm> I don't have a 4.4 handy - I wonder if my change is backward compatible
22:52:48 <mathewm> afk
22:53:41 <dons> hehe, get you some lambda warez eh? http://www.demonoid.com/files/details/567882/775222/
22:53:43 <lambdabot> Title: Demonoid.com - Haskell - the Craft of Functional Programming
22:53:46 <dons> (is that what I think it is?)
22:53:51 <glguy> one thing I don't like about the use of techincal limitations on binary drivers is that you shouldn't have to mark your driver as GPL if you aren't going to distribute it
22:54:42 <sjanssen> dons: wow
22:55:06 <sjanssen> despite the piracy, maybe that is a good sign for Haskell?
22:55:21 <dons> I *think* so.. (I think)
22:56:12 <dons> the 'de-monoid' name is misleading, I think ;)
22:56:34 <sjanssen> heh
23:03:56 <reppie> merry xmas everyone
23:07:11 <glguy> J-ism (no the programming language you sicko) (f ^: n) x = iterate f x !! n
23:07:48 <mathewm> anyone familiar with mozart? (programming environment)
23:19:36 <vininim> loooooooooooooool
23:19:42 <dons> anyone got some thoughts on implementing this: http://haskell.org/haskellwiki/GHCi_in_colour
23:19:44 <lambdabot> Title: GHCi in colour - HaskellWiki
23:19:50 <vininim> 2 hours, to figure out that the redraw function is not being called :/
23:20:01 <geckosenator> hehe
23:21:15 <lisppaste2> glguy annotated #32305 with "because I can't stop tweaking" at http://paste.lisp.org/display/32305#3
23:22:33 <mathewm> glguy: what is that solving?
23:22:41 <glguy> a nonogram puzzle
23:22:51 <glguy> as introduced to me by the 99 problems
23:23:54 <dons> vininim: heh
23:24:00 <notsmack> dons: i tried to syntax colorize a readline app once...  readline's certainly not built for the task.
23:24:20 <dons> notsmack: but ghci could be! :)
23:24:25 <glguy> I think they call it Visual Haskell
23:24:36 <mathewm> colorize the inferior-haskell mode of emacs
23:24:40 <dons> (we might not be able to type in coloured code, but ansi coloured output seems easy enough)
23:24:43 <mathewm> then you colorize hugs and ghci :)
23:25:01 <notsmack> dons: agreed
23:26:41 <dons> looking at the type error, I think this could be really helpful: http://haskell.org/haskellwiki/GHCi_in_colour
23:26:42 <lambdabot> Title: GHCi in colour - HaskellWiki
23:26:55 <dons> and its a 1 day task, I think...
23:27:05 <dons> let's see what Simon M says
23:28:03 <dons> ah, HsColour is now a library anyway...
23:41:32 <astrolabe> dons: seen this? http://www-users.cs.york.ac.uk/~ndm/projects/guihaskell.php
23:41:34 <lambdabot> Title: Neil Mitchell - GuiHaskell
23:42:32 <dons> doesn't run in a terminal, does it? ah no. its a gtk thing
23:42:50 <dons> now. maybe ther's a good ghci wrapper in there?
23:43:11 <dons> ndm around?
23:43:48 <dons> ultimately, I just want to say: ghci --colour
23:43:52 <dons> and get ansi output
23:47:47 <dons> astrolabe: ok, added some more notes to that page
23:52:33 <astrolabe> dons: It seems sensible to do it for different compilers and different platforms if that is possible
23:53:00 <astrolabe> different = multiple
23:53:26 <dons> right. so you envisage a generic wrapper application
23:53:32 <dons> that imports HsColour
23:53:39 <dons> rather than a hack in ghci?
23:54:10 <astrolabe> dons: I don't know enough about it, but that sounds better.  Would it work on windows?
23:54:31 <dons> it would need a separate backend to HsColour for win32 codes
23:54:47 <dons> so but we're back at the problem of wrapping readline, no?
23:54:58 <dons> or do you see it as: ghci | colour
23:55:30 <dons> kfish: any experience with colour console output hacks?
23:55:37 <dons> kfish: i.e. http://haskell.org/haskellwiki/GHCi_in_colour
23:55:39 <lambdabot> Title: GHCi in colour - HaskellWiki
23:55:40 <astrolabe> I don't know enough to follow you :(
23:56:06 <dons> ok. we'll see if there's any feedback on the mailing list
23:56:32 <dons> ghci uses this for printing output, (I think)
23:56:32 <dons> showTyThing (AnId id) = do
23:56:33 <dons>   ty' <- cleanType (GHC.idType id)
23:56:33 <dons>   str <- showForUser (ppr id <> text " :: " <> ppr ty')
23:56:33 <dons>   io (putStrLn str)
23:56:44 <dons> which we replace with a call to putStrLn.colour
23:56:46 <reppie> i should try sending my resume to google
23:56:47 <reppie> and see if they'd hire me.
23:57:06 <kfish> dons: console colour is all about ansi escape sequences isn't it?
23:57:26 <dons> yep (and we have a library for that)
23:57:38 <dons> I'm thinking about the best way to add --colour to ghci/hugs/...
23:58:26 <kfish> ah ok ... well, that'd be the only way to go for console afaik
23:58:53 <kfish> doing gtk etc is a totally different app ...
23:58:58 <dons> i'm more interested in whether its feasible to wrap ghci (i.e intercept its input and output)
23:59:05 <astrolabe> maybe you should have one project to mark-up ghci output (as text), to allow multiple solns to printing it out coloured
23:59:06 <dons> or to hack ghci to replace putStrs with putStr.colour
23:59:22 <kfish> does ghci allow generic filters on its IO?
23:59:34 <dons> not that I know of (?)
23:59:55 <kfish> how does one interface with it?
