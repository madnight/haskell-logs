00:06:34 <sjanssen> are the haddocks generated nightly, or just for every release?
00:11:50 <Heffalump> ivanm: IIRC the main thing was finding one for the dihedral group
00:14:35 <ivanm> Heffalump: You did it in Haskell I presume? I'm just interested in what your algorithm was for testing and/or generating critical sets if you had them.
00:15:01 <Heffalump> no, in C. This was a long time ago, before I knew Haskell.
00:15:04 <ivanm> I'm doing a project at the moment looking for premature partial Latin squares such that, if you remove any one set element it becomes a critical set.
00:15:11 <Heffalump> it was mainly manual, actually, though I ended up writing a program
00:15:27 <ivanm> Oh, OK, you just mentioned it in #haskell so I presumed you wrote it in haskell
00:15:30 <ivanm> thanks anyway!
00:15:39 <Heffalump> no, it was only because of the context of the conversation at the time
00:15:49 <ivanm> fair enough
00:15:53 <Heffalump> I don't think the algorithm was anything other than the obvious.
00:15:58 <Heffalump> (for testing)
00:22:22 <aFlag> does anyone know some page or paper that will teach me the basics of incremental garbage collection? I'd rather like if it starts by a non-moving incremental garbage collection algorithm.
00:24:51 <dons> sjanssen: the 'latest' ones can be regenerated on demand (I think)
00:28:51 <paolino> xerox, helped me in zipping my ntree with a Loc so I can handle it in every node. I can easily change the subgraph in the loc, but... I want to reorder it, floor by floor having a list of Loc for every floor exchanging  their subgraphs.
00:31:38 <paolino> Do I need the concept of path, so I can program a sequence of modifications, made by a/the single cursor ?
00:33:24 * paolino should stop programming clusterers and go back to the farm
00:36:04 <ski> morning #haskell
00:36:28 <paolino> but every winter the prgramming sirens call me to the sea of machines. I last killed  the python metaclass one. It's going to be hard to kill the  haskell monad siren .
00:36:35 <paolino> morining ski
00:48:44 <dons> paolino: hehe
01:39:33 <dons> ?yow
01:39:34 <lambdabot> I'm thinking about DIGITAL READ-OUT systems and computer-generated
01:39:34 <lambdabot> IMAGE FORMATIONS ...
01:39:40 <dons> ?users
01:39:41 <lambdabot> Maximum users seen in #haskell: 288, currently: 249 (86.5%), active: 26 (10.4%)
01:45:02 <beelsebob> @yow
01:45:03 <lambdabot> Mmmmmm-MMMMMM!!  A plate of STEAMING PIECES of a PIG mixed with the
01:45:03 <lambdabot> shreds of SEVERAL CHICKENS!! ... Oh BOY!!  I'm about to swallow a
01:45:03 <lambdabot> TORN-OFF section of a COW'S LEFT LEG soaked in COTTONSEED OIL and
01:45:03 <lambdabot> SUGAR!! ... Let's see ... Next, I'll have the GROUND-UP flesh of CUTE,
01:45:03 <lambdabot> BABY LAMBS fried in the MELTED, FATTY TISSUES from a warm-blooded
01:45:04 <lambdabot> [3 @more lines]
01:46:05 * Syzygy- really, really, REALLY doesn't understand yow.
01:46:16 <beelsebob> isn't that the point?
01:46:19 <beelsebob> @. elite yow
01:46:19 <lambdabot> D03z0rz $O/\/\eONE phr0/\/\ PeOrIa |-|av3 a sHOr+3R At7eNtioN zP4n thAN m3?
01:46:51 <gour> dons: lambda is not a real vegetarian :-(
01:50:40 <nornagon> @. elite yow
01:50:41 <lambdabot> 0n $3(oNd Th0Ught, MaY83 i'L1 |-|34T UP $0/\/\e Bax3D b3anS aND \/\/aTch re9iS phiLBIN ... I7'5 9r34T +0 8E A|I\/3!!
01:51:01 <mq_mattr> ?yow!
01:51:01 <lambdabot> JAPAN is a WONDERFUL planet -- I wonder if we'll ever reach their level
01:51:02 <lambdabot> of COMPARATIVE SHOPPING ...
01:58:19 <aFlag> how do I compile a static binary? I've tried adding -optl -static on ghc but I can't make it work
02:07:15 <dons> aFlag: -static, iirc
02:07:20 <dons> and maybe -optc-static
02:07:27 <dons> (there's a wiki page on it)
02:08:47 <aFlag> dons: where? I googled for it but I couldn't find anything
02:09:00 <dons> ghc user's guide?
02:09:26 <dons> -static        xUse static Haskell libraries
02:09:49 <dons> (and maybe then pass -optc-static to gcc, and -optl-static to the linker ?)
02:10:04 <dons> (if in doubt, check on glasgow-haskell-users@ )
02:10:56 <Svrog> doesn't ghc statically link by default on most systems?
02:11:09 <aFlag> oh, there's no space between -optl and the option?
02:30:10 <Masklinn> Hello everybody
02:30:29 <beelsebob> hi dr nick
02:30:34 <beelsebob> wait n
02:30:36 <beelsebob> o
02:32:02 <trh> Hello.
02:32:17 <trh> I was looking around at compiler jobs on the net before.
02:32:47 <trh> There's all sorts of (potential) stuff out there...
02:56:21 <mq_mattr> trh: like what ?
02:57:26 <ibid> party on! debian etch frozen!
02:57:27 <ibid> :)
02:58:23 <mq_mattr> yay!
02:58:40 <mq_mattr> what does etch bring to the party?
02:58:52 <mq_mattr> over sarge?
03:01:43 <ibid> i would have responded had you stayed on the channel :)
03:08:21 <Stinger> hmmm didnt kill my modem after all joker
03:14:10 <dons> Stinger: ?
03:14:39 <dons> Igloo: do you want to commit sjanssen's stm doc patch?
03:22:22 <scriptdevil> myTry a fn = map fn myOwnRange 0 a
03:22:30 <scriptdevil> is this a correct assignment
03:22:37 <scriptdevil> fn is a function
03:22:46 <scriptdevil> myOwnRange is the range function
03:23:06 <scriptdevil> eg myOwnRange 1 4 gives [1,2,3,4]
03:23:12 <Masklinn> wrap trhe myOwnRange call in parens
03:23:17 <dons> looks like too many arguments to map
03:23:29 <dons> myTry a fn = map fn (myOwnRange 0 a) -- perhaps?
03:23:52 <Masklinn> yeah what dons said, or map will try to grab everything and end with 4 arguments
03:24:05 <scriptdevil>  myTry 5 myFibo
03:24:07 <scriptdevil> [*** Exception: stack overflow
03:24:19 <scriptdevil> after adding paanthesis
03:24:32 <scriptdevil> myFibo is the Fibonacci generator.
03:24:37 <scriptdevil> Everything recursive
03:25:01 <scriptdevil> myFibo a =
03:25:01 <scriptdevil>     case a of
03:25:01 <scriptdevil>       1 -> 1
03:25:01 <scriptdevil>       2 -> 1
03:25:01 <scriptdevil>       _ -> myFibo (a-1) + myFibo (a-2)
03:25:08 <scriptdevil> myOwnRange a b=
03:25:08 <scriptdevil>     if a > b then []
03:25:08 <scriptdevil>        else a : (myOwnRange (a+1) b)
03:25:15 <scriptdevil> sorry for the paste
03:25:19 <scriptdevil> am in a hurry
03:25:32 <scriptdevil> myTry a fn = map fn (myOwnRange 0 a)
03:25:46 <scriptdevil> so what is wrong??
03:26:01 <ski> 'myFibo 0' will hang
03:26:12 <scriptdevil> ski: omg.. thats it
03:26:13 <scriptdevil> thanks
03:26:27 <scriptdevil> :D
03:26:29 <scriptdevil> done
03:26:31 <scriptdevil> thanks
03:26:33 <scriptdevil> bye
03:26:56 <dons> hmm
03:27:40 <Masklinn> I don't quite see how the 0 case can hang since he never calls it unless explicitely though
03:28:49 <ski> > let myOwnRange a b = if a > b then [] else a : myOwnRange (a+1) b in myOwnRange 0 5
03:28:50 <lambdabot>  [0,1,2,3,4,5]
03:29:10 <ski> then 'map'ping over that
03:30:31 <dons> > let map'ping = (^2) in map map'ping [1..3]
03:30:32 <lambdabot>  [1,4,9]
03:30:48 * ski grins
03:31:57 <Igloo> dons: I'll take a look later today, hopefully
03:32:13 <dons> > let this'n'that (x:xs) = (x,xs) in this'n'that "fofe"
03:32:14 <lambdabot>  ('f',"ofe")
03:32:22 <dons> there's an idiom in there somewhere ;)
03:32:26 <dons> Ig	cool
03:40:48 <beelsebob> dons: do you ever sleep?
03:41:06 <nornagon> heh
03:41:12 <nornagon> everyone asks that >.>
03:41:31 * beelsebob wonders if dons is a bot
03:41:52 <nornagon> lambdabot coded him
03:42:00 <nornagon> he's a meta-bot
03:42:01 <beelsebob> lol
03:42:07 <kzm> Hmm...an enterprising individual might add a plugin to lambdabot that keeps track of active people.
03:42:18 <kzm> Not sure if that would be politically correct, though.
03:42:36 <kzm> Perhaps if it was part of the war on terror, it would be okay?
03:42:51 <kzm> @stats
03:42:51 <lambdabot> Unknown command, try @list
03:43:00 <dons> bots should be destroyed. they are so annoying
03:43:07 <Masklinn> truth is that lambdabot and dons recursively coded each other
03:43:21 <nornagon> * dons has quit IRC (Annihilated.)
03:43:26 <Masklinn> we're still looking for the fool who started the chain reaction
03:43:30 <nornagon> Masklinn: like that escher drawing
03:43:36 <Masklinn> yeah pretty much
03:43:37 <dons> Unknown command escher, try @list
03:43:47 <kzm> Well - they say that learning Haskell changes the way you think as a programmer - so perhaps that's not too far off the mark? :-)
03:44:01 <dons> Ooh, functional programmers are so hot!
03:44:11 <nornagon> ?escher
03:44:11 <lambdabot> Unknown command, try @list
03:44:56 <Masklinn> @remember dons Ooh, functional programmers are so hot!
03:45:09 <nornagon> ?dons
03:45:09 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
03:45:15 <nornagon> ... quite
03:45:31 <dons> church is my favourite computer scientist.
03:46:00 <beelsebob> dons *is* the docs
03:46:00 <Masklinn> Do you find church hot?
03:46:12 <dons> me? hot? naw, it's a nice comfortable 73 degrees in here
03:46:14 <nornagon> only in summer
03:46:27 <dons> i could really use a backrub
03:46:37 * dons stops being vixen for a little while
03:46:41 <dons> phew!
04:50:52 <AStorm> Hello all.
04:51:06 <AStorm> I've a problem with hsc2hs (not quite experienced in FFI use, too)
04:54:51 <AStorm> It's weird, but ghc seems to ignore foreign decls.
04:56:23 <greentea> i'm in no way knowledgable in this area, but: Are you using the -fffi switch to GHC?
04:57:08 <AStorm> Sorry, wrong. Yes, I forgot the -fffi. I have another problem though, with the use of the interface.
04:57:21 <AStorm> http://wklej.org/id/442dce413e
04:57:26 <AStorm> That's the interface.
04:57:27 <lambdabot> Title: NOPASTE! - Wklej KOD ; PASTE CODE ; NO PASTE ; WKLEJ ; PASTE ; SYNTAX
04:57:50 <AStorm> I can't use cap_to_text <somecap>
04:58:44 <greentea> Sorry, can't make any useful suggestions at this point. :-(
05:00:43 <AStorm> :-(
05:00:51 <AStorm> I just want to try gap_get_proc
05:01:14 <AStorm> Maybe I'll dig something out in the doc.
05:14:46 <fasta> What's wrong with data (Monad m) => Foo a = Foo (m a)?
05:14:56 <fasta> Hmm, nm...
05:15:15 <fasta> data (Monad m) => Foo a m = Foo (m a)
05:17:24 <AStorm> What is that a? :>
05:17:32 <AStorm> Anything?
05:25:17 <AStorm> fasta, data is a keyword
05:25:23 <AStorm> :>
05:27:19 <fasta> AStorm: I already answered my own question, which is that I forgot a parameter.
05:28:42 <AStorm> Yes, maybe. Other than that, you may want an instance instead of a datatype.
05:29:23 <fasta> AStorm: classes only make sense when you have multiple implementations.
05:29:46 <AStorm> Hmm, well. Monad exists already, why take the name?
05:30:08 <fasta> AStorm: This was an extremely simplified example.
05:30:42 <AStorm> Ah, right. :>
05:31:08 <fasta> AStorm: data Foo s a i m = Foo (STArray s i (m a))
05:31:23 <AStorm> .hoogle addForeignPtr
05:31:26 <fasta> AStorm: this type is isomorphic to mine. Does the same advice hold?
05:31:38 <AStorm> Blah, wrong name.
05:31:48 <fasta> @hoogle addForeignPtr
05:31:49 <lambdabot> Foreign.Concurrent.addForeignPtrFinalizer :: ForeignPtr a -> IO () -> IO ()
05:31:49 <lambdabot> Foreign.ForeignPtr.addForeignPtrFinalizer :: FinalizerPtr a -> ForeignPtr a -> IO ()
05:31:50 <AStorm> This one looks ok.
05:32:17 <AStorm> @hoogle addPtrFinalizer
05:32:17 <lambdabot> No matches found
05:33:31 <AStorm> Hmmm, hmm. I'd love to make the pointer autofinishing, but I can't get it as a ForeignPtr. (only a normal Ptr)
05:35:13 <JaffaCake> kzm: I'm looking into your bug: http://www.haskell.org//pipermail/glasgow-haskell-users/2006-April/009977.html
05:35:16 <lambdabot> Title: ghc releasing memory during compilation, http://tinyurl.com/uj5oa
05:35:24 <AStorm> Ah,, newForeignPtr anyway.
05:35:28 <kzm> Yes?
05:35:43 <kzm> Give me a second, and I'll just refresh my memory.
05:35:49 <JaffaCake> did you tag your darcs repo at that point?  It doesn't seem to compile on its own now
05:36:08 <JaffaCake> should I try to repro with your latest sources, or go back?
05:36:22 <kzm> Hm. It should compile.  What happens?
05:36:32 <JaffaCake> I just need the bio package
05:36:52 <kzm> Oh, okay.  It should be easy to install, cabalized and all.
05:37:03 <JaffaCake> right, where from?
05:37:14 <kzm> Sibling directory.  (darcs repo)
05:37:18 <JaffaCake> ok, ta
05:37:25 <kzm> s/rbr/bio/
05:37:55 <kzm> Do let me know if there's any difficulties, or non-idiomatic cabal stuff, or whatever.
05:38:41 <JaffaCake> bio built and installed fine
05:39:01 <kzm> Any theory at all about what might be happening?  Confirmed sightings?
05:39:15 <JaffaCake> dunno yet :)
05:39:33 <kzm> Well - good hunting.
05:40:15 <Pupeno> Igloo: ping?
05:41:48 <Pupeno> @time Igloo
05:41:50 <lambdabot> Local time for Igloo is Mon Dec 11 13:34:08 2006
05:42:13 <Igloo> Hello
05:42:44 <Pupeno> Igloo: Hello. Are you Ian, the one making the Debian packages of many Haskell packages ?
05:42:50 <Igloo> Yup
05:43:43 <Pupeno> Igloo: I am working on making and using some packages and I have some doubts, do you have some free time to answer some questions now ?
05:43:56 <Igloo> Sure
05:44:52 <Pupeno> Igloo: Is the Debian Unsafe project active ?
05:45:14 <Igloo> There's probably nothing useful in it at the moment
05:45:17 <Pupeno> I mean, Hasxell Unsafe.
05:46:02 <Pupeno> Igloo: I seen that many packages in there look a-like. Is there some template or tool to build Haskell packages ?
05:46:03 <Igloo> If we try to keep stable up-to-date then that's probably where we'll put the packages
05:46:52 <Pupeno> Igloo: I couldn't understand that last phrase.
05:46:53 <Igloo> Pupeno: Currently I copy the debian/{rules,*.postinst,*.preinst} (they are exactly the same for all my library packages), but I don't autogenerate debian/control.in
05:47:33 <Igloo> Pupeno: If we try to make the latest packages built for a Debian stable system available then we'll put them in Haskell Unsafe. Did that make more sense?
05:48:04 <kzm> Igloo - would it make sense to take the 'unstable' packages and have a separate Ubuntu repository with up-to-date packages?
05:48:19 <JaffaCake> kzm: -M400m seems to work on x86_64 here
05:48:30 <kzm> I could probably volunteer to do it, but I don't know much about building debs.
05:48:58 <Igloo> kzm: That's a question for the Ubuntu people
05:49:04 <kzm> JaffaCake, yes.  I've only seen it on some distros, and with some values of x in -Mxm
05:49:16 <JaffaCake> interesting
05:49:20 <JaffaCake> I'll try on x86
05:49:37 <AStorm> Hmm, how does one do <- as a function? I somehow forgot.
05:49:49 <kzm> Igloo, hmm..yes, but perhaps I could make it a question for Ubuntu-using Haskell people (i.e. I) - who may have different preferences?
05:50:11 <mauke> AStorm: >>=
05:50:15 <dons> ?undo do x <- getChar ; return x
05:50:16 <lambdabot> getChar >>= \ x -> return x
05:50:16 <kzm> JaffaCake, the whole business seems very strange to me.
05:50:25 <AStorm> Ah, that arrow.
05:50:33 <Igloo> kzm: Well, if you want the packages then presumably it would make sense  :-)
05:50:52 <Pupeno> Igloo: yes, it made sense... but you are corrently conentrating on Debian unstable, right ? Sarge + 1 ?
05:51:03 <kzm> Igloo, right.  Do you maintain a separate archive of Haskell debs?
05:51:07 <AStorm> Except it should work as a function (I've to extract the original Ptr from ForeignPtr)
05:51:07 <Igloo> kzm: To build them, you shouldn't need to do much more than dpkg-buildpackage -rfakeroot -us -uc  (in teh right order), BTW
05:51:43 <Igloo> kzm: Not exactly. Experimental stuff and stable backports generally go to http://haskell-unsafe.alioth.debian.org/haskell-unsafe.html
05:51:45 <lambdabot> Title: Haskell Unsafe
05:51:51 <AStorm> Augh, I should've used withForeignPtr
05:52:26 <Igloo> Pupeno: Yeah; I doubt I'll do anything more for stable before etch releases
05:52:35 <Igloo> Pupeno: (etch = sarge + 1)
05:54:42 <kzm> Igloo, should I just rsync alioth.../dists/unstable ?
05:55:22 <Igloo> kzm: There's probably nothing interesting in there at the moment, everything for GHC 6.6 is in Debian unstable AFAIK
05:55:36 <kzm> Ah, okay.
05:55:53 <dylan> and most of the things for ghc 6.6 are in testing too.
05:56:00 * Igloo thought you were talking about building the Debian unstable debs for Ubuntu
05:56:10 <kzm> I guess I should be able to add it as a deb-src archive.
05:56:23 <jlouis> ?users
05:56:24 <lambdabot> Maximum users seen in #haskell: 288, currently: 257 (89.2%), active: 15 (5.8%)
05:56:25 <kzm> Igloo was right.
05:56:48 <Pupeno> kzm: I am actually using both, Debian and (K)ubuntu, we can talk about it latter.
05:56:56 <kzm> Or, to be precise, I just want more updated packages than Ubuntu ships.
05:57:00 <dylan> http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=402245
05:57:03 <lambdabot> Title: #402245 - Package fails with ghc6 6.6 - Debian Bug report logs
05:57:23 <kzm> Pupeno, sure.  I have to leave shortly, though.
05:57:45 <Pupeno> Igloo: so, you don't work with the .in files ?
05:57:52 <Igloo> dylan: We're still waiting for dons to fix hsplugins I believe
05:58:14 <Igloo> Pupeno: Sorry, I do, I braino'd above
05:58:45 <Pupeno> Igloo: ok, then I think I have a good package here :)
05:58:45 <dylan> yeah, but it's still an RC bug
05:59:19 <Igloo> dylan: Well, I expect Debian to just ship without it if it doesn't get fixed
05:59:27 <Pupeno> Igloo: it would only work with GHC6 because it is hardcoded, it doesn't create hugs package, would that be ok (for Debian itself) ?
05:59:31 <Igloo> Pupeno: Cool  :-)
05:59:54 <dylan> *nods*, but then the plugins package should be removed.
06:00:08 <Igloo> Pupeno: It's OK, yes, but it would be better if it built hugs packages too. Making the generic scripts do that, along with haddock docs, is on my TODO list
06:00:50 <Pupeno> Igloo: that means improving rules, right ?
06:01:00 <Igloo> Pupeno: Right
06:01:31 <Pupeno> I think that's beyond my possibilities currently.
06:01:39 <Igloo> dylan: Hmm, odd that they haven't been
06:02:12 <Igloo> Pupeno: No worries, once I've done it you should be able to just copy the new ones over (and add a hugs and docs stanza to debian/control.in)
06:02:40 <Pupeno> Igloo: one last thing, I see there's a ghc6-hopengl package, which seems to be built from ghc6, but ghc6 doesn't built it anymore. Is ghc6-hopengl some old package that should have been removed ?
06:02:53 <Igloo> Pupeno: Where do you see that?
06:03:14 <Pupeno> Igloo: Here: http://packages.debian.org/stable/devel/ghc6-hopengl
06:03:15 <lambdabot> Title: Debian -- ghc6-hopengl
06:03:34 <Pupeno> Igloo: oh! ghc 6.2!
06:04:02 <Igloo> Pupeno: Right, that's only in stable
06:04:15 <Pupeno> Ok.
06:05:10 <road> Is there some may to trace evaluation of functions without using the IO monad?
06:05:27 <Pupeno> I have some more questions... :) You write the .in files an then you run update-haskell-control by hand ?
06:05:51 <Igloo> Pupeno: You can run "debian/rules update-generated-files" or similar
06:06:36 <Pupeno> Good.
06:07:07 <Pupeno> Igloo: Once I have a package, what do I do with it ? any place I can submit it for possible inclussion in Debian ?
06:10:34 <Igloo> Pupeno: I can't find the general Debian page to point you at, but you're probably best off talking to http://urchin.earth.li/mailman/listinfo/debian-haskell anyway
06:10:36 <lambdabot> Title: debian-haskell Info Page
06:11:12 <dons> road: Debug.Trace.trace
06:11:29 <dons> you can search yourself with hoogle:
06:11:30 <dons> ?hoogle trace
06:11:31 <lambdabot> Debug.Trace.trace :: String -> a -> a
06:11:31 <lambdabot> Debug.Trace :: module
06:11:31 <lambdabot> Debug.Trace.putTraceMsg :: String -> IO ()
06:11:38 <dons> ?docs Debug.Trace
06:11:38 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Debug-Trace.html
06:12:31 <Pupeno> Igloo: thank you. I'll do. Thank you for your time.
06:12:46 <road> dons: thanks
06:12:51 <Igloo> np
06:14:20 <JaffaCake> kzm: can't repro your bug on either machine I have here
06:14:30 <kzm> Okay.
06:15:01 <kzm> Anything I can do?
06:15:32 <JaffaCake> could you send me the output froim +RTS -Sstderr on a run that shows the bug?
06:15:40 <kzm> Don't know if it could be specific to some particular ghc/library/kernel.
06:16:00 <JaffaCake> I can't think of a way it could be dependent on the kernel
06:16:04 <kzm> I'm about to leave now, but I'll see if I can do it tomorrow.
06:16:09 <JaffaCake> or libc, in fact
06:16:20 <AStorm> Hmm, I'm having a problem with creating a function returning a String by calling some foreign function allocating the data itself.
06:16:30 <kzm> Just that I've only seen it on some machines.
06:16:43 <JaffaCake> very odd, I'm intrigued :)
06:16:53 <AStorm> You know, peekCAString only works on CString, while I'd prefer to have a proper self-freeing String.
06:17:11 <JaffaCake> kzm: does it stick at the -M value for a while, or just seem to ignore it completely?
06:17:14 <AStorm> Does peekCAString copy the data?
06:17:18 <kzm> I might also go to Hac, we could perhaps look at it there?
06:17:29 <AStorm> (or does it free the CString itself)
06:17:30 <JaffaCake> kzm: sure, that'd be good
06:17:48 <kzm> JaffaCake, hard to say.  I'd think 'ignore completely', but it's been a while.
06:18:06 <JaffaCake> see if you can get a +RTS -Sstderr run, that'll help
06:18:21 <kzm> Okay.  Tacking a post-it to my keyboard now. :-)
06:23:50 <AStorm> How would I create a pointer to some Haskell value easily to use it in a foreign function requiring a Ptr?
06:24:07 <AStorm> (actually, it's CSize and the function needs a ssize_t*)
06:24:52 <AStorm> I could theoretically cheat and use IntPtr... but I dont know if the ssize_t is really int
06:25:42 <AStorm> Or maybe WordPtr
06:27:33 <Pupeno> Igloo: do you mind if I make a sumary of our conversation into my blog ?
06:27:45 <Igloo> No, go for it
06:32:39 <xerox> how shall one define a circular list in Haskell?
06:33:57 <xerox> can one?
06:34:12 <norpan> circ = 1:circ
06:34:22 <Syzygy-> xerox: Circular list?
06:34:28 <Syzygy-> You mean like
06:34:34 <Syzygy-> > take 10 $ cycle [1,2,3]
06:34:36 <lambdabot>  [1,2,3,1,2,3,1,2,3,1]
06:34:36 <xerox> norpan: that is the fixpoint of (1:)
06:34:43 <xerox> Syzygy-: no :(
06:34:54 <norpan> xerox: that is a circular list containing 1
06:36:07 <xerox> norpan: now if I use a zipper on that... do you think I'd travel like I were in a circle?
06:36:30 <norpan> you'd travel round and round and round, yes :)
06:37:25 <norpan> you have no way of knowing that as you don't have pointer equality in haskell
06:37:28 <xerox> norpan: uhm, how would you define left and right?
06:37:49 <norpan> you ask such strange questions
06:37:58 <xerox> no I mean the functions
06:38:00 <norpan> left and right implies double-linked
06:38:36 <xerox> we don't have double-linked lists in the standard libraries
06:38:39 <xerox> do we?
06:39:07 <earthy> no
06:39:23 <xerox> (For left and right I mean the actual Loc a -> Loc a functions, btw.)
06:39:25 <norpan> double-linked and purely functional don't mix very well
06:39:49 <norpan> any list update would be O(n)
06:40:17 <xerox> argh, but I'd really like to have my zipper that travels on a circle, for a program I'm writing
06:40:26 <AStorm> Any idea on: Num -> Ptr CSize
06:40:33 <AStorm> How would one convert that?
06:40:47 * notsmack is curious about xerox's program
06:40:52 <norpan> xerox: a zipper that travels on a cricle?
06:41:04 <xerox> right, and arcs of circles are lists
06:41:47 <norpan> if you're not updating the list you can create such lists
06:43:13 <xerox> no Haskell `data'type could handle that?
06:43:21 <AStorm> Hmm? So how would one convert a simple numeral to Ptr CSize? Any nice FFI examples?
06:43:40 <xerox> AStorm: did you read the FFI documentation?
06:44:01 <AStorm> Mostly.
06:44:08 <norpan> well, haskell datatypes can contain references to themselves but you can't compare objects for pointer equality in haskell
06:44:25 <AStorm> A StablePtr, but that can't be cast to Ptr
06:44:30 <xerox> I suppose you can write a library
06:44:39 <AStorm> I'd have to go through IO
06:46:07 <AStorm> (because the only constructor for a StablePtr is newStablePtr, which returns an IO monad with the pointer)
06:47:01 <AStorm> Also, the casting may cause "undefined behaviour" - I hope only in the case StablePtr is freed.
06:47:21 <ski> (xerox : hm .. i made a simple text-adventure whose world data structure was inspired by zippers)
06:48:15 <Cale> AStorm: what are you trying to accomplish?
06:48:42 <AStorm> Give a C function requiring a ssize_t* some numeric value: length.
06:49:11 <Cale> don't you call that from IO anyway?
06:49:12 <AStorm> In C I'd just use &someint.
06:49:14 <xerox> ?hoogle poke
06:49:15 <lambdabot> Foreign.Storable.poke :: Storable a => Ptr a -> a -> IO ()
06:49:15 <lambdabot> Foreign.Storable.pokeByteOff :: Storable a => Ptr b -> Int -> a -> IO ()
06:49:15 <lambdabot> Foreign.Storable.pokeElemOff :: Storable a => Ptr a -> Int -> a -> IO ()
06:49:35 <AStorm> The other way around.
06:49:42 <AStorm> I need a pointer.
06:49:49 <mauke> with (fromIntegral len) $ \p -> do c_func p
06:49:51 <Cale> ?hoogle sizeOf
06:49:52 <lambdabot> Foreign.Storable.sizeOf :: Storable a => a -> Int
06:49:53 <xerox> you can't take the Haskell pointer I believe
06:49:56 <ski> (xerox : so the state was distributed over the rooms in the world .. but i couldn't handle cycles or sharing in the world graph)
06:50:04 <mauke> (without context)
06:50:05 <xerox> ski: aw.
06:50:06 <Cale> that'll give you (something to do with) the value to poke
06:50:15 <Cale> you can use malloc to create a cell
06:50:16 <AStorm> lambdabot, pointer, again :/
06:50:38 <Cale> and then just poke the cell with whatever value you want and pass it off
06:50:40 <ski> xerox : but otherwise it was quite nice to add the parent as a child of the new node, when travelling, methinks
06:50:43 <AStorm> Why would I need to copy the value if it's Haskell-allocated?
06:50:52 <Cale> copy?
06:51:17 <xerox> ski: but that copies-on-write, right?
06:51:23 <AStorm> That malloc+poke would just copy the value.
06:51:27 <Cale> How do you know that it'll copy it?
06:51:31 <AStorm> And I'd have to free that too.
06:51:37 <norpan> there is nothing you can do outside of haskell on a StablePtr anyway
06:51:37 <Cale> (well, it will :)
06:51:54 <AStorm> norpan, yes :/
06:52:12 <ski> xerox : what do you mean ? .. i copied nodes as i walked around .. but only the local node, not whole sub-worlds
06:52:17 <mauke> AStorm: what's the problem with allocating a new object?
06:52:25 <AStorm> I'll try that malloc+free route, though it sounds wasteful.
06:52:40 <mauke> I'd use 'with'
06:52:43 <AStorm> None, except it seems wasteful. Why couldn't I grab a pointer to a Haskell object...
06:52:44 <Cale> It's one integer, man :)
06:52:45 <norpan> the best thing to do is to write some glue code
06:53:06 <mauke> AStorm: because the haskell object may be incompatible with what the C function expects
06:53:08 <Cale> You can't because you might pass it to some C code and then the GC would come along and decide to free it.
06:53:13 <AStorm> Well, the function has to return something, so with is out :>
06:53:27 <AStorm> mauke, hmm... cast Int to CSize and tell me again :P
06:53:28 <mauke> AStorm: why can't you return IO Int or whatever?
06:53:31 <Cale> So if that was the norm, then everything you passed to C code could never be freed by GC.
06:53:41 <Cale> That would be wasteful.
06:53:45 <mauke> AStorm: Int is boxed, size_t isn't
06:54:08 <AStorm> mauke, yes, I actually have to unbox it and get a pointer at that.
06:54:12 <Cale> Yeah, that's a good point too.
06:54:23 <Cale> an Int is actually a pointer to code
06:54:26 <norpan> so, if the c function you are trying to call needs a pointer (why) then write some glue code which allocates on the stack, calls function
06:54:33 <Cale> which when executed returns an int
06:54:53 <AStorm> norpan, dunno why, it's stupid, but that's how the function was written.
06:54:56 <Cale> and after executing one time, rewrites itself to return the value immediately
06:55:15 <AStorm> Ghraaa..
06:55:17 <xerox> mauke is right, `with' is perfect
06:55:20 <AStorm> I misunderstood the C api.
06:55:23 <norpan> and if the function needs a pointer in order to modify the value, make the glue function instead return that value
06:55:26 <AStorm> I just have to pass it a nullPtr
06:55:36 <norpan> ah, nullPtr, that's good :)
06:55:41 <AStorm> Or better, some Ptr to malloced CSize-something :>
06:55:56 <AStorm> It will return the length in that, not _take_ the length.
06:56:00 <Pupeno> Igloo: When I mention you, would you like me to link to http://web.comlab.ox.ac.uk/oucl/work/ian.lynagh/ or somewhere else ?
06:56:01 <lambdabot> Title: Ian Lynagh
06:56:05 <Cale> that seems far more likely :)
06:56:11 <mauke> AStorm: alloca then
06:56:15 <Igloo> Pupeno: Nowhere, please
06:56:27 <AStorm> It can also take the length.
06:56:28 <mauke> alloca $ \ptr -> do c_func ptr; peek ptr
06:56:31 <xerox> Cale, do you do GHC Hacking?
06:56:35 <AStorm> (though it returns something else then)
06:56:36 <Pupeno> Igloo: really ?
06:56:40 <Igloo> Really
06:56:43 <Cale> xerox: no
06:57:01 <Pupeno> Ok. as you wish.
06:57:04 <AStorm> Well, I don't have to throw it some length anyway.
06:57:19 <Cale> (but I did read the STG machine paper)
06:57:22 <AStorm> Unless I want to use pokeCAStringLen
06:57:31 <xerox> Igloo: have you ever encountered double linked lists in your GHC workings?
06:57:34 <AStorm> (which isn't all that much faster than pokeCAString)
06:58:27 <Igloo> xerox: I think I've seen some, why?
06:59:24 <AStorm> Hmm, how would one define some opaque pointer type? (I mean a pointer to some opaque struct)
06:59:41 <AStorm> Just to be sure nobody passes some incorrect pointer.
06:59:59 <Igloo> AStorm: If you don't mind a tiny extension, then   data Opaque   and use Ptr Opaque
07:00:04 <mauke> there doesn't seem to be a good way
07:00:15 <mauke> yeah, I used that
07:00:38 <Cale> newtype MyTypeP = MyTypeP (Ptr MyTypeP)
07:00:38 <AStorm> Igloo, just that data? No constructors?
07:00:42 <Igloo> Yup
07:00:43 <xerox> Igloo: do you have any link to some implementation?
07:01:00 <AStorm> Ah, glasgow ext :>
07:01:05 <Igloo> xerox: Ah, I haven't seen GHC using a generic doubly linked list
07:01:10 <Igloo> xerox: glib might have one?
07:01:27 <AStorm> Though I'd prefer something H98.
07:01:35 <Cale> my newtype works :)
07:01:36 <xerox> Never used glib...
07:02:31 <Igloo> Cale: It'll give unused constructor warnings
07:02:51 <mauke> AStorm: FFI isn't exactly H98 either
07:03:10 <AStorm> Huh, it does work finally.
07:03:10 <Cale> It will?
07:03:57 <AStorm> H' will finally come up with H2k7, right?
07:04:17 <Cale> Or Haskell 1.6 or something :)
07:04:19 <AStorm> Ok, now to publish that damned libcap wrapper and write some more software.
07:05:22 <AStorm> What was the "ifdef" for GHC extensions?
07:06:48 <AStorm> And the question is still there: does peekCAString free the string on its own?
07:07:00 <AStorm> (the C representation)
07:07:07 <mauke> no
07:07:14 <AStorm> Or does that copy?
07:08:08 <mauke> how could it not copy?
07:10:19 <AStorm> Actually, it doesn't copy:
07:10:30 <AStorm> *** glibc detected *** ./testcaps: free(): invalid pointer: 0x0808264c ***
07:10:41 <AStorm> And I did something like:
07:11:36 <AStorm> let str = <function returing a CString>
07:11:47 <AStorm> x <- peekCAString str
07:11:53 <AStorm> free str
07:11:53 <AStorm> return x
07:12:15 <AStorm> Ah, laziness got me again :P
07:12:37 <AStorm> Or not...
07:14:02 <AStorm> Let's see the strace.
07:16:15 <AStorm> Hmm, it doesn't free the object explicitly, but I can't free it myself :/
07:17:17 <Saizan> seq?
07:17:40 <mauke> AStorm: how so?
07:19:38 <AStorm> Well, would the above code free it properly? I think it should.
07:19:51 <AStorm> Instead, I get an invalid pointer warning from glibc.
07:20:18 <hyrax42> ?hoogle Stm a -> IO a
07:20:18 <mauke> hmm, can you give me a testcase?
07:20:19 <lambdabot> No matches, try a more general search
07:20:32 <hyrax42> ?hoogle STM () -> IO ()
07:20:32 <lambdabot> No matches, try a more general search
07:20:53 <hyrax42> ?docs Control.Concurrent.STM
07:20:53 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/stm/Control-Concurrent-STM.html
07:21:02 <dylan> ?hoogle STM a -> IO a
07:21:02 <lambdabot> GHC.Conc.atomically :: STM a -> IO a
07:21:03 <AStorm> mauke, Hmm, ok. Just have some string-returning C function handy.
07:21:14 <mauke> what do you mean by that?
07:21:18 <AStorm> Or maybe the full code :>
07:21:19 <fasta> How many indices has newArray (0, 0) 1?
07:21:43 <mauke> C functions can't really return strings because "string" isn't a C type
07:21:48 <fasta> 0 or 1?
07:22:03 <hyrax42> hoogle should have unified STM () -> IO () with STM a -> IO a
07:22:04 <AStorm> Yes, they return the char*
07:22:17 <AStorm> CString is actually Ptr CChar
07:22:17 <dylan> yay CString.
07:22:33 <mauke> AStorm: what does the char* point to?
07:22:42 <AStorm> and doing Foreign.Marshal.Alloc.free on it should work
07:22:43 <hyrax42> first character in the string
07:22:51 <AStorm> It points to C-alocated memory.
07:22:59 <mauke> how did it allocate the memory?
07:23:41 <AStorm> cap_to_text internally allocates the memory and returns a pointer.
07:23:54 <AStorm> That's what its manpage says anyway.
07:24:22 <mauke> how did it allocate the memory?
07:24:23 <AStorm> "This function allocates any memory necessary to contain the string, and returns a pointer to the string."
07:24:50 <AStorm> Don't know. Internal matters... but they don't say it should be freed... weird.
07:24:57 <mauke> yes, they do
07:25:15 <mauke>  The caller should free any releasable memory, when the capability state in working storage is no longer required, by calling cap_free with cap_p as an argument.
07:25:24 <AStorm> Blah...
07:25:26 <Cale> free :: Ptr a -> IO ()
07:25:26 <Cale>     Free a block of memory that was allocated with malloc, mallocBytes, realloc, reallocBytes, or any of the allocation functions from MarshalArray (see Section 5.9).
07:25:35 <AStorm> With cap_free, not free on the string.
07:25:41 <AStorm> So they actually lie somewhat. :P
07:25:42 <Cale> That doesn't include foreign stuff anyway :)
07:25:50 <AStorm> So it was freed properly by the autofinisher I added.
07:26:02 <mauke> note that Marshall.Alloc.free /= C free()
07:26:11 <AStorm> cap_get_proc = newForeignPtr cap_free_p cap_get_proc_i
07:26:42 <Cale> Depending on how long the thing sticks around in Haskell-land, it might be convenient to use ForeignPtrs
07:27:05 <AStorm> Well, I do use them :>
07:27:25 <AStorm> And I actually get at the ptr by converting (unsafely though)
07:27:25 <Cale> ah, right, you just said that as I was typing :)
07:27:50 <AStorm> Cale, no, I'm just lagged :P
07:30:04 <Cale> why be unsafe about it?
07:30:09 <AStorm> I wonder why would one want cap_init anyway. For setting capabilities from zero? Quite useless anyway :>
07:30:37 <AStorm> Cale, not in this case, just the name. unsafeForeignPtrToPtr
07:31:16 <Cale> yeah, isn't it better to use withForeignPtr?
07:31:33 <AStorm> Can't, it only works on IO () returning functions.
07:31:48 <AStorm> And I want to return a String.
07:32:10 <mauke> wtf?
07:32:19 <Cale> that's bizarre
07:32:22 <mauke> :t Foreign.ForeignPtr.withForeignPtr
07:32:23 <AStorm> IO () != IO String
07:32:23 <lambdabot> forall b a. GHC.ForeignPtr.ForeignPtr a -> (GHC.Ptr.Ptr a -> IO b) -> IO b
07:32:32 <mauke> surprise
07:32:33 <AStorm> Stupid docs on the webpage :>
07:32:44 <mauke> which webpage?
07:32:49 <Cale> http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffise5.html#x8-300005.5
07:32:50 <lambdabot> Title: 5 Marshalling, http://tinyurl.com/yfoy96
07:32:55 <AStorm> Not these.
07:32:59 <AStorm> haskell.org
07:33:15 <mauke> http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign-ForeignPtr.html ?
07:33:18 <lambdabot> http://tinyurl.com/y67cak
07:33:34 <Cale> that one has it right too
07:33:36 <AStorm> withForeignPtr :: ForeignPtr a -> (Ptr a -> IO b) -> IO b
07:33:43 <AStorm> It's Ptr a, so... :/
07:33:53 <AStorm> The function takes 2 args.
07:33:54 <mauke> what is a Ptr a?
07:34:02 <AStorm> I'd have to somehow curry it :P
07:34:09 <mauke> you're confused
07:34:17 <Cale> mauke: a plain pointer to a value of type a
07:34:19 <AStorm> MY function takes 2 args.
07:34:41 <AStorm> Though one is known... time to curry/lambdaise
07:34:41 <mauke> AStorm: withForeignPtr foo $ \ptr -> do ... call your function here
07:34:47 <AStorm> Yes.
07:35:37 <Cale> Ah, I see what was confusing about that now. That's how all the functions named 'with...' work
07:35:55 <mauke> it's like lisp :-)
07:37:01 <Cale> You pass them something to do with some resource, and they manage the allocation/deallocation or wrapping/unwrapping or what-have-you.
07:37:02 <AStorm> :>
07:37:14 <AStorm> More or less.
07:37:16 <mauke> typical use: http://rafb.net/paste/results/zlI9Xu10.html
07:37:45 <Cale> I usually indent more
07:37:59 <Cale> (a little more for each nested block)
07:38:03 <mauke> even for <- in do notation?
07:38:10 <ElMaia> Hi
07:38:14 <mauke> because that's what <- is: another level of nesting
07:38:23 <Cale> hm?
07:38:23 <ElMaia> Someone here use wxHaskell ?
07:39:00 <Cale> mauke: anywhere where I don't want a ; to appear when desugaring the layout rule
07:39:02 <fasta> Is there a doubly linked list implementation somewhere? (or anything that enables deletion anywhere in the structure in constant time and append)?
07:39:24 <mauke> Cale: that rule is too literal
07:39:42 <Cale> I'm just explaining the rule that I use :)
07:40:02 <niarium_> is wxHaskell alive? is the project dead?
07:40:06 <fasta> Edison doesn't list the complexity of its operations :(
07:40:16 <mauke> ; also opens a new block
07:40:20 <ElMaia> I dont know
07:40:23 <fasta> niarium: it has been revived
07:40:33 <Cale> fasta: how's O(log(min(n1,n2))) ?
07:40:34 <mauke> why not increase indentation after ; ?
07:40:41 <Cale> where n1 and n2 are the distances to the ends?
07:40:49 <ElMaia> But I need to do a job
07:40:50 <fasta> Cale: not good
07:41:02 <Cale> mauke: because it's part of the same do-block
07:41:17 <ElMaia> I want to creaty dinamic buttons
07:41:22 <mauke> do-blocks are just syntactic sugar for >>= and lambda
07:41:26 <Cale> and not the same statement
07:41:27 <ElMaia> Someone can help me ?
07:41:33 <ElMaia> dynamic
07:41:36 <Cale> mauke: so?
07:41:47 <Cale> ElMaia: hm?
07:41:50 <niarium> ElMaia, i suggest you to use Gtk2Hs, although i don't like GTK
07:41:58 <Cale> ElMaia: what do you mean by dynamic buttons?
07:42:00 <mauke> I refuse to add indentation just because haskell lacks support for user-defined do-like blocks
07:42:08 <fasta> Cale: What's the practical use of all these log n operations where constant time also works? It's not like there log n operations is faster on modern hardware for small n.
07:42:19 <niarium> wxHaskell project seems to have stopped
07:42:20 <ElMaia> ž->Cale<-ž: I want to give a parameter n for example
07:42:22 <AStorm> Hmm, what's the arrow to undo this:
07:42:26 <ElMaia> and create n buttons
07:42:34 <Cale> fasta: Usually not requiring mutability
07:43:05 <ElMaia> niarium ,thanks a lot, but I already have a ready part in wxHaskell
07:43:09 <xerox> What would you think of having lambdabot try to interpret snippets of code every time she can parse some, like now she spits tinyurls for parsable urls?
07:43:13 <AStorm> I want to apply some function to the item inside the monad and get a monad on exit.
07:43:15 <ElMaia> change all is very dificult
07:43:19 <AStorm> Was that liftM or what?
07:43:44 <mauke> AStorm: depends on the type of the function
07:43:53 <mauke> >>=, liftM or fmap
07:44:05 <Cale> ElMaia: maybe something like mapM (\k -> button win ... k ...) [1..10] ?
07:44:25 <niarium> if you've got the parameter n and you are to create n buttons, you may write a monadic recursive function
07:44:25 <ElMaia> I need to create button and assign events to each one
07:44:32 <mauke> xerox: potentially very annoying
07:44:41 <Cale> mauke: Do you lay out guards based on how they're desugared into case?
07:44:43 <AStorm> >>= won't work, I have to apply the item to a function returning the monad and make that the result of the function.
07:44:49 <fasta> Cale: you don't know of any structure that has this property implemented anywhere (e.g. in ST)?
07:44:52 <ElMaia> niarium , my problem is that Button -> x -> IO (Button ())
07:45:11 <ElMaia> IO is very dificult to work
07:45:11 <Cale> fasta: oh, you can easily do it in ST, but ST is a pain in the ass..
07:45:13 <mauke> Cale: nope
07:45:21 <ElMaia> and x is a frame
07:45:24 <fasta> Cale: I meant more like a _library_.
07:45:38 <ElMaia> Than, I need to put n button in one frame
07:45:49 <niarium> so that function creates a new button?
07:45:49 <xerox> mauke: it would be fun if she could @let definitions though
07:45:50 <Cale> mauke: Why lay out do-blocks based on how they desugar into >>= then?
07:46:00 <ElMaia> Yeah
07:46:01 <mauke> Cale: I don't
07:46:05 <xerox> mauke: we can then evaluate things while discussing
07:46:16 <ElMaia> [niarium], Yeah
07:46:19 <Cale> that's what you were just claiming I should do :)
07:46:40 <mauke> Cale: it was my attempt at reductio ad absurdum :-)
07:46:41 <AStorm> The hell... withForeignPtr doesn't give me a monad :P
07:46:42 <niarium> ElMaia: do you know how the function length work?
07:46:47 <Cale> mauke: it didn't work
07:46:51 <ElMaia> ž->niarium<-ž: Yeah
07:47:07 <AStorm> It somehow gives me just a CString.
07:47:33 <niarium> I think you can do exactly same thing with a number and a function that creates a button. wait, i'll try to write some pseudo-code
07:47:34 <Cale> Basically, I use a restricted layout rule (for essentially everything except module), where things that are indented the same amount have semicolons placed between them.
07:48:00 <ElMaia> <>-niarium-<>, do you want go see the constructor ?
07:48:19 <niarium> ElMaia: sure
07:48:24 <Cale> and to not have that, you must indent at least one space. I find that it improves readability a whole lot.
07:48:44 <ElMaia> %%+niarium+%%: bPlay <- bitmapButton p1 [text := "Play", on command := close f, picture := "Play.gif", clientSize := sz 200 50]
07:49:01 <mauke> Cale: I don't even know all of the layout rules; I indent stuff the way it makes sense to me
07:49:13 <Cale> ElMaia: Something strange and random is going on with your nick autocompletion.
07:49:21 <ElMaia> %%+niarium+%%, I need a function that create n buttons like that
07:49:36 <Cale> ElMaia: You know how mapM works, right?
07:49:47 <AStorm> Hmm... How does one wrap something inside an IO monad?
07:49:51 <ElMaia> %%+Cale+%%, mapM no, map yes
07:49:55 <AStorm> wrapM?
07:49:59 <Cale> AStorm: apply the IO type constructor
07:50:16 <mauke> AStorm: what are you really trying to do?
07:50:24 <AStorm> Blah anyway. Forgot to include it.
07:50:25 <Cale> ElMaia: okay, well, mapM is similar, but it runs each action the function produces in turn.
07:50:31 <Cale> @type mapM
07:50:33 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
07:50:37 <Cale> it's basically a loop
07:50:53 <ElMaia> @type mapM
07:50:54 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
07:51:03 <fasta> What was the advantage of newtype again?
07:51:17 <Cale> you pass it a function from values to actions to run, and a list of values, and it produces an action which runs all the produced actions in turn and returns a list of the results
07:51:30 <Cale> fasta: no additional boxing
07:51:40 <ElMaia> %%+Cale+%%, sorry but I dont know Haskell very well... Monad I dont understand
07:52:05 <AStorm> mauke, well, trying to use that withForeignPtr
07:52:06 <Cale> ElMaia: okay, well, let me get a quick intro to how IO is done in Haskell
07:52:15 <Cale> http://haskell.org/haskellwiki/Introduction_to_IO
07:52:17 <lambdabot> Title: Introduction to IO - HaskellWiki
07:52:20 <AStorm> :>
07:52:30 <Cale> basically mapM is a loop
07:52:34 <ElMaia> Let me see
07:52:38 <fasta> Cale: Why would there be additional boxing when the data declaration only has one constructor?
07:52:50 <Cale> fasta: the semantics are different
07:53:02 <mauke> AStorm: use it to do what?
07:53:07 <fasta> Cale: I suppose that's in the Report in case I want to know?
07:53:14 <Cale> With data D = D Integer, you have D undefined is not equal to undefined
07:53:18 <Cale> yes
07:53:35 <Cale> with newtype N = N Integer, you have N undefined = undefined
07:53:41 <AStorm> mauke, As you can see, withForeignPtr requires something returning an IO monad.
07:53:46 <AStorm> Maybe I'll just try return :P
07:53:51 <ElMaia> -=[Cale]=-, sure, but I want to create n Buttons
07:53:52 <Cale> AStorm: an IO action
07:54:17 <Cale> AStorm: The term "monad" refers to the thing which is sending types to other types.
07:54:17 <mauke> AStorm: what are you doing with a Ptr that doesn't require IO?
07:54:18 <ElMaia> I dont have n buttons yet to put in a list and apply mapM
07:54:40 <Cale> (that is, IO the type constructor itself is what "the monad" is referring to)
07:54:54 <Cale> ElMaia: hmm
07:55:00 <fasta> Cale: what about data D = D !Integer?
07:55:18 <AStorm> mauke, exactly returning a string pointer which _doesn't_ need to be freed.
07:55:42 <AStorm> Maybe I'll use IO for that.
07:55:46 <Cale> http://haskell.org/onlinereport/decls.html#sect4.2.3
07:55:46 <mauke> AStorm: do you mean a haskell String or something else?
07:55:48 <lambdabot> Title: The Haskell 98 Report: Declarations
07:55:50 <niarium_> grr
07:56:08 <Cale> ElMaia: which bunch of buttons would you like to create?
07:56:09 <niarium_> freenode disconnects me again and again
07:56:14 <Cale> how do they differ?
07:56:39 <ElMaia> -=[Cale]=-: What ?
07:56:55 <Cale> ElMaia: you said you want to create a bunch of buttons, right?
07:57:03 <Cale> Are they related somehow?
07:57:08 <niarium_> He would have a list of events, like [play, stop, pause, skip, ...]
07:57:11 <AStorm> mauke, no, a CString, which means a Ptr CChar
07:57:16 <AStorm> it's an internal function.
07:57:20 <ElMaia> ž->Cale<-ž: Yeah
07:57:27 <Cale> You can just keep making separate buttons in exactly the way you pasted
07:57:28 <AStorm> External one is an IO String
07:57:29 <niarium_> and then he wants buttons for every single events
07:57:47 <Cale> If you want a bunch of related buttons, you could create them in a loop
07:57:52 <Cale> (mapM)
07:58:13 <ElMaia> Cale and niarium, I need to create buttons, but the user will choose this n
07:58:25 <ElMaia> But and the events
07:58:26 <Cale> okay, then you probably want a loop
07:58:27 <ElMaia> ?
07:58:35 <ElMaia> I dont know
07:58:45 <ElMaia> As I said, I'm newbee
07:58:47 <Cale> Well, what will the kth button do?
07:59:19 <ElMaia> [Cale], I need a button that knows who its... Let me try to explain
07:59:24 <Cale> (when you press it)
07:59:31 <ElMaia> Supose You create 3 buttons
07:59:52 <niarium_> Cale, is mapM and (sequence_ . map) identical?
07:59:53 <AStorm> Any a -> IO a functions/keywords?
08:00:04 <niarium_> sorry, are*
08:00:05 <Cale> niarium: mapM_ is sequence_ . map
08:00:07 <mauke> AStorm: return
08:00:13 <Cale> and mapM is sequence . map
08:00:14 <ElMaia> Each button needs to know who its, like when I press it to do a command based in position
08:00:17 <AStorm> Well, return does something weird.
08:00:20 <niarium_> Ah. i got it
08:00:44 <ElMaia> Creating each button is easy because I now its name
08:00:49 <Cale> ElMaia: yes, do you know how to determine what that command is from the position
08:00:55 <Cale> ?
08:01:10 <ElMaia> Cale , order to create for example
08:01:25 <ElMaia> order from create for example
08:01:36 <Cale> hm?
08:01:50 <Cale> Suppose I'm a user, what does pushing the 6th button do?
08:01:52 <xerox> ...do you have buttons' coordinates?
08:01:57 <ElMaia> %%+Cale+%%, kind... B1, b2, b3, etc
08:02:00 <ElMaia> no
08:02:05 <AStorm> mauke, my stupidity is enormous nowadays <blush>
08:02:10 <ElMaia> b1 <- button
08:02:14 <ElMaia> b2 <- button
08:02:17 <mauke> whoa
08:02:20 <xerox> Cale, it's a library usage problem
08:02:27 <ElMaia> That way I now its name
08:02:48 <ElMaia> but and dynamic ? What`s its name to put in event ?
08:02:55 <Cale> xerox: I'm absolutely certain this is solvable with mapM, but I can't write the code for him until he tells me what he wants the buttons to do
08:03:00 <AStorm> ElMaia, what will each button actually do? Launch some callback? Change something?
08:03:32 <ElMaia> =@>AStorm<@=: Yeah... do a test and based in answer, change a staticText
08:03:46 <niarium_> does 'dynamic' means that the behavior of each button can change in run-time?
08:04:00 <ElMaia> no
08:04:03 <ElMaia> `@@´niarium`@@´, no
08:04:14 <ElMaia> each button have its behavior
08:04:19 <VerbalDK> b3 <-yet another button
08:04:21 <Cale> okay, let's suppose that pushing the kth button causes buttonPushed k to be run
08:04:27 <VerbalDK> b101 <--learn to use buttons
08:04:31 <ElMaia> But, diferent buttons have differents behavior
08:04:42 <VerbalDK> b666 <--MUHAHAHAHahaaaa.. end of the world
08:04:48 <AStorm> Mhm, you can either use a list of functions to be called
08:04:59 <AStorm> or a single function governing all of those buttons.
08:05:18 <Cale> bs <- mapM (\k -> button f [text := "Button " ++ show k, on command := buttonPushed k]) [1..n]
08:05:19 <AStorm> The first is susceptible to mapM :>
08:05:21 <ElMaia> a single event, but one parameters is a button name
08:05:31 <ElMaia> like...
08:05:39 <Cale> ElMaia: look ^^
08:05:42 <AStorm> Yes.
08:05:51 <xerox> Cale, ah, *there* is where you save the information :)
08:05:57 <AStorm> If you wan't a list of functions, then just change that buttonPushed into:
08:06:05 <AStorm> buttonFunctions !! k
08:06:20 <Cale> nonono :)
08:06:27 <AStorm> Or some take? :>
08:06:33 <Cale> you'd just change how k is used
08:06:37 <Cale> and pass the list of functions
08:06:50 <Cale> let's say you had a list of (label,function) pairs
08:06:53 <Cale> then you could write
08:07:09 <AStorm> a list comprehension? :>
08:07:14 <Cale> bs <- mapM (\(l,a) -> button f [text := l, on command := a]) xs
08:07:31 <AStorm> Ah, right :P
08:07:36 <Cale> where xs is the list of (label, action) pairs to build buttons for
08:07:55 <ski> @type flip mapM
08:07:57 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
08:07:58 <ElMaia> ž->Cale<-ž, uhm... good, I will try, but the action I understood
08:08:00 <xerox> Cale: now I see why you were sure, sorry
08:08:15 <Cale> and yes, flip mapM is convenient, and often named forM
08:08:19 <Cale> it's in GHC 6.6 and up
08:08:31 <AStorm> THen, bs is the list of generated buttons.
08:08:37 <Cale> right
08:08:43 <ElMaia> =@>Cale<@=, GHC 6.4 have mapM ?
08:08:48 <Cale> yes
08:09:03 <mauke> what are those =@> <@= things?
08:09:05 <Cale> all Haskells in the last several years have mapM :)
08:09:10 <AStorm> Name quotes.
08:09:14 <Cale> yeah, those are annoying
08:09:16 * ski wrapped 'flip mapM' in a continuation monad transformer ..
08:09:17 <AStorm> I'd disable it on the spot.
08:09:23 <Cale> What's wrong with a simple colon?
08:09:24 <ElMaia> -=[mauke]=-, I dont know... my script does it
08:09:38 <mauke> AIIRRR
08:09:42 <Cale> If you don't know how your script works, don't use it.
08:09:59 <ElMaia> ž->Cale<-ž, I instaled now just o enter here
08:10:09 <xerox> Does anything need recompilation installing GHC 6.6?
08:10:15 <Cale> hm?
08:10:33 <xerox> Hmm... ghc-pkg will show a whole series of new packages
08:10:58 <Cale> things which use hs-plugins will be unhappy
08:10:58 <xerox> I should recompile the libraries I have in ghc-pkg -user ?
08:10:59 <ElMaia> I installed now... just to enter in this channel
08:11:05 <Cale> yes, that too
08:11:10 <ski> collect :: Monad m => [a] -> Cont2T b [b] m a
08:11:13 <xerox> Okay.
08:11:13 <Cale> because you won't have any of your old packages
08:11:14 <Igloo> xerox: All packges will need to be compiled for 6.6
08:11:34 <xerox> Igloo: ghc-pkg can't be asked to do that work via cabal right? :)
08:11:59 <Igloo> Right
08:12:03 <xerox> (:
08:12:29 <xerox> Where does ghc install itself usually?
08:12:43 <niarium_> HDD
08:12:52 <xerox> I remember he's nice enough to stay into only one sub-dir, but I don't remember where
08:12:54 <Cale> I think under /usr/local
08:12:57 <chessguy> is it a bad thing if you start dreaming about monads?
08:13:06 <VerbalDK> depends
08:13:08 <xerox> Cale: good idea
08:13:10 <VerbalDK> do they have boobs?
08:13:22 <VerbalDK> chessguy
08:13:32 <niarium_> VerbalDK: ROFL
08:13:33 <Cale> xerox: and mostly into /usr/local/lib/ghc-<version>
08:13:35 <xerox> Cale, well, the binaries are under bin/
08:13:42 <xerox> right, that was the dir I was searching for :)
08:13:44 <xerox> Cale++
08:13:57 <Cale> with symlinks into /usr/local/bin and such
08:14:07 <xerox> I have proper binaries, crazy
08:14:23 <xerox> I was just doing ls -l in home to follow the symlinks back
08:14:26 <AStorm> Well, people are monads too :P
08:14:41 <LoganCapaldo_> I am not a Monad! I am a human being!
08:15:00 <AStorm> Which is... some thing holding state :P
08:15:01 <psnl> done joke
08:15:20 <psykotic> LoganCapaldo_, prisoner?
08:15:25 <niarium_> Remember remember. A monster can devour a value. return :: Monster m => a -> m b
08:15:35 <AStorm> Well, people aren't Monoids, so people aren't Monads :/
08:15:36 <niarium_> Monads aren't human
08:15:44 <xerox> person :: RWST r w s m a
08:15:47 <xerox> :P
08:16:30 <AStorm> You can't just add/concatenate two persons
08:16:36 <AStorm> :P
08:16:43 <xerox> person :: RWST (Environment,Education) (Either () Biography) World IO a
08:16:56 * xerox ducks
08:17:15 <AStorm> How would you define the operations? :P
08:17:17 <savanni> Fascinating.
08:17:39 <ElMaia> Cale
08:17:45 <ElMaia> %%+Cale+%%, thanks a lot
08:17:46 <chessguy> AStorm, i think some experimentation is required
08:17:46 <xerox> you can convey so much informations in types....
08:17:51 <psnl> edwinb: where is your paper called "I am not a number... "
08:17:55 <psnl> ?
08:17:56 <ElMaia> Works a lot
08:18:13 <ElMaia> exacty that I wanted to do
08:18:24 <ElMaia> works very well
08:18:40 <fasta> How can one express that in a recursive data type the Empty constructor cannot appear as part of a large structure?
08:19:06 <ski> you need somthing like refinement types for that, methinks
08:19:20 <AStorm> Hmm?
08:19:37 <AStorm> Just don't include it in the constructor list?
08:19:45 <fasta> ski: and how can one express these in Haskell?
08:19:47 <ski> (another options is to not include the 'Empty', but pass around 'Maybe' structures, instead)
08:19:55 <ski> fasta : not to my knowledge
08:20:23 <fasta> ski: Is there any language that does support those things?
08:20:28 <ski> (well, supertyping like in O'Haskell, would probably work, also)
08:20:42 <xerox> (i reserve the right to change the log ...)
08:20:44 <psykotic> what's wrong with having two data types here? up to isomorphism it should give you what you want
08:20:59 <ski> (and possibly, it could be done with polymorphic variants in O'Caml .. not sure)
08:21:04 <ElMaia> [ Cale ], One more time... Thanks
08:21:16 <VerbalDK> (why are you whispering)
08:21:36 <fasta> psykotic: yes, but that's more of a work-around.
08:22:10 <AStorm> Well, how does one build/install modules so that they're readily includable w/o additional linking?
08:22:12 <Cale> ElMaia: no problem
08:22:14 <psykotic> (it's essentially what ski means by Maybe, i think)
08:22:28 <AStorm> (like my libcap bindings not requiring Libcap.o or -lcap on the commandline)
08:22:30 <psykotic> with Nothing corresponding to Empty and the Just a being the non-Empty part of the type
08:22:43 <allbery_b> AStorm: Cabal
08:23:07 <ski> psykotic : yes
08:23:11 <ElMaia> [ Cale ], no abusing... do you know a component to put a Image, but not a Button
08:23:45 <ElMaia> Do you know ImageBox, in Delphi for example ?
08:23:51 <Cale> ElMaia: It's been a while since I used wxHaskell, look in the documentation for an Image control.
08:23:54 <AStorm> allbery_b, hmm...
08:23:57 <AStorm> :>
08:24:22 <fasta> E.g. for a doubly linked list it would be nice to be able to express that it only has one head and one tail node.
08:24:24 <ElMaia> [ Cale ], ok... Thanks
08:24:34 <allbery_b> basically a package system.  if you wrap your lirary in the Cabal stuff, installing t registeres it as a package and then ghc --make or ghc -package mylib or whatever
08:24:46 <chessguy> ooh, nice question just arrived on haskell-cafe
08:24:47 <Cale> http://wxhaskell.sourceforge.net/doc/Graphics.UI.WX.Controls.html#18 -- maybe an imageList?
08:24:50 <lambdabot> http://tinyurl.com/y5eoyb
08:25:11 <AStorm> allbery_b, mhm. Then if it's installed, other stuff just imports the module, right?
08:25:17 <chessguy> @pl \x -> (snd x) - (fst x)
08:25:17 <lambdabot> liftM2 (-) snd fst
08:25:22 <allbery_b> right
08:26:55 <chessguy> :t liftM2
08:26:56 <lambdabot> forall r (m :: * -> *) a2 a1. (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
08:28:18 <allbery_b> http://www.haskell.org/cabal
08:28:20 <lambdabot> Title: The Haskell Cabal
08:31:42 <chessguy> what's concatMap used for?
08:32:19 <ski> @type (=<<)
08:32:20 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> m a -> m b
08:32:22 <ski> @type concatMap
08:32:24 <lambdabot> forall b a. (a -> [b]) -> [a] -> [b]
08:32:24 <fasta> chessguy: for the same things concat.map is used for.
08:33:01 <chessguy> i know what the type is. can someone give a simple example?
08:33:52 <chessguy> oh wait
08:33:54 <chessguy> @type words
08:33:55 <lambdabot> String -> [String]
08:34:18 <chessguy> concatMap (words) "This is a simple example."
08:34:26 <chessguy> > concatMap (words) "This is a simple example."
08:34:27 <lambdabot>  Couldn't match `String' against `Char'
08:34:44 <chessguy> > concatMap (words) (words "This is a simple example.")
08:34:45 <lambdabot>  ["This","is","a","simple","example."]
08:35:03 <psnl> wot the hell? openHatFile is in C
08:35:05 <ski> > concatMap words ["This is a simple example.","This is another"]
08:35:07 <lambdabot>  ["This","is","a","simple","example.","This","is","another"]
08:35:23 <chessguy> ohhhhh
08:35:31 <ski> > map words ["This is a simple example.","This is another"]
08:35:32 <lambdabot>  [["This","is","a","simple","example."],["This","is","another"]]
08:36:06 <chessguy> so it maps over all the elements of a list and then combines the result into a single list
08:36:28 <ski> > map (\c -> if c == ' ' then "|||" else [c]) "This is a simple example."
08:36:29 <lambdabot>  ["T","h","i","s","|||","i","s","|||","a","|||","s","i","m","p","l","e","|||"...
08:36:35 <ski> > concatMap (\c -> if c == ' ' then "|||" else [c]) "This is a simple example."
08:36:37 <lambdabot>  "This|||is|||a|||simple|||example."
08:36:45 <ski> right
08:38:48 <chessguy> hmmm
08:39:10 <chessguy> > concatMap (*2) [1..5]
08:39:10 <lambdabot>  add an instance declaration for (Num [b])
08:39:11 <lambdabot>   In an arithmetic sequence: [1...
08:39:56 <chessguy> > concatMap (\x -> [x*2]) [1..5]
08:39:57 <lambdabot>  [2,4,6,8,10]
08:41:17 <Syzygy-> > concatMap (\x -> [x*2,x*3]) [1..5]
08:41:18 <lambdabot>  [2,3,4,6,6,9,8,12,10,15]
08:41:42 <Syzygy-> A bit clearer what it makes if you don't only work with singletons. :)
08:41:52 <Syzygy-> (though, wait, "|||" isn't a singleton...)
08:42:10 <chessguy> i don't get this, though
08:42:11 <chessguy> instance Monad [] where
08:42:11 <chessguy> return x = [x]
08:42:11 <chessguy> l >>= f = concatMap f l
08:42:11 <chessguy> fail _ = []
08:42:20 <chessguy> why is concatMap used here instead of map?
08:43:44 <twanvl> ?type (>>=)
08:43:46 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
08:44:04 <twanvl> so for lists: [a] -> (a -> [b]) -> [b]
08:44:10 <twanvl> ?type concatMap
08:44:11 <lambdabot> forall b a. (a -> [b]) -> [a] -> [b]
08:45:44 <chessguy> ok, i think i get it
08:48:18 <psnl> quick FFI question: if you are in a C function called from haskell, can you call malloc?
08:49:07 <chessguy> so is everything pretty much done in the list monad then?
08:49:13 <Igloo> psnl: Yes
08:49:13 <mauke> psnl: sure, why not?
08:50:35 <psnl> lovely thanks
08:51:03 * psnl has a bit of code with char filename[MAX_STRING]; and was wondering why
08:53:36 <chessguy> i'm trying to figure out why you don't seem to have the usual typical messiness of being "in" the list monad and having to do explicit returns and such. is it because *everything*takes place in the list monad?
08:55:10 <Cale> chessguy: sorry, what?
08:55:12 <psi> generally you don't use lists as monads
08:55:25 <chessguy> oh really?
08:55:29 <Cale> no, you do quite a bit :)
08:55:33 <Cale> at least I do
08:55:40 <mauke> because the implementation of return/>>= doesn't use return/>>=
08:55:41 <Cale> List comprehensions
08:56:16 <allbery_b> you don't *visibly* treat lists as monads, but the standard list operations all obey the monad laws
08:56:19 <Cale> For a while we had general monad comprehensions, and I hope some kind person reimplements them in GHC (the patch will be accepted)
08:56:28 <int-e> chessguy: in the list monad you can write  [x]  for 'return x', is that what's confusing you?
08:56:46 <Cale> But list comprehensions are essentially the list monad in syntax-sugary-disguise.
08:56:49 <chessguy> i guess
08:56:50 <allbery_b> return and >>= aren't magic, they're just convention --- especially in the case of lists
08:57:04 <Cale> Especially in the case of everything except IO
08:57:12 <Cale> IO is the only magic monad
08:57:20 <Cale> (and maybe STM)
08:57:28 <int-e> return and >>= are just what all monads have in common. it's glue.
08:57:45 <Cale> but they actually have more than that
08:57:50 <chessguy> with most monads, don't you have to write do {....whatever you want to do within the monad....return something}
08:57:59 <Cale> they have nearly all the stuff in Control.Monad in common :)
08:58:05 <allbery_b> no, that's a convenience mechanism
08:58:05 <Cale> yes you do
08:58:13 <allbery_b> which turns into >>= (or >>) and return
08:58:13 <Cale> well, you don't *have* to
08:58:14 <int-e> because it's built on top of >>= and return. yes.
08:58:16 <chessguy> but not with lists?
08:58:22 <int-e> don't underestimate glue :)
08:58:23 <Cale> you can and do with lists
08:58:40 <chessguy> ...
08:58:45 <Cale> > do { x <- [1..3]; y <- [4..7]; return (x, y) }
08:58:47 <lambdabot>  [(1,4),(1,5),(1,6),(1,7),(2,4),(2,5),(2,6),(2,7),(3,4),(3,5),(3,6),(3,7)]
08:58:58 <allbery_b> but with lists, return and >>= are really [x] and concatMap
08:59:06 <AStorm> Is there any nice howto on handling exceptions in Haskell? :>
08:59:16 <int-e> > return 1 `mplus` return 2 `mplus` return 3 :: [Int]
08:59:18 <lambdabot>  [1,2,3]
08:59:19 <AStorm> (yes, IOErrors)
08:59:28 <chessguy> so i guess what's really confusing me is all the sugar'
08:59:37 <Cale> that's the same as:
08:59:38 <int-e> @type  return 1 `mplus` return 2
08:59:40 <lambdabot> forall (m :: * -> *) a. (MonadPlus m, Num a) => m a
08:59:51 <Cale> > [1..3] >>= \x -> [4..7] >>= \y -> return (x, y)
08:59:53 <lambdabot>  [(1,4),(1,5),(1,6),(1,7),(2,4),(2,5),(2,6),(2,7),(3,4),(3,5),(3,6),(3,7)]
09:00:02 <Cale> which is:
09:00:12 <AStorm> Read those >>= like a shell pipeline.
09:00:24 <Cale> > [1..3] >>= \x -> concatMap (\y -> [(x, y)]) [4..7]
09:00:26 <lambdabot>  [(1,4),(1,5),(1,6),(1,7),(2,4),(2,5),(2,6),(2,7),(3,4),(3,5),(3,6),(3,7)]
09:00:32 <int-e> allbery_b: in fact if the list monad were the only useful monad, nobody would use them ;)
09:00:38 <allbery_b> most of the time you don't need to care that lists are monads.  but it's there if you want it.
09:00:41 <Cale> > concatMap (\x -> concatMap (\y -> [(x, y)]) [4..7]) [1..3]
09:00:47 <lambdabot>  [(1,4),(1,5),(1,6),(1,7),(2,4),(2,5),(2,6),(2,7),(3,4),(3,5),(3,6),(3,7)]
09:01:03 <int-e> allbery_b: monads that is. lists are useful, whether you have monads or not.
09:01:13 <AStorm> Which is: tons uglier than >>= or 'do notation'
09:01:34 <chessguy> so if i do map (*2) [1..10], is that using the list monad or not?
09:01:41 * shapr boings
09:01:41 <AStorm> No, it isn't.
09:01:44 <Cale> Lists are useful to think of as a monad because they let you think as if you have nondeterministic variables.
09:02:09 <AStorm> It's actually applying a partially-applied function to each item in the list.
09:02:12 <Cale> If I wanted to write map in the list monad,
09:02:20 <AStorm> That'd be mapM :P
09:02:30 <xerox> Cale, would you have a proof of the Riemann Series Theorem?  (Maybe it's even in Spivak... I didn't check yet :))
09:02:34 <psi> chessguy, a list is just a list. it just happens to be a monad as well.
09:02:42 <Cale> > let map f xs = do { x <- xs; return (f x) } in map (*2) [1..10]
09:02:44 <lambdabot>  [2,4,6,8,10,12,14,16,18,20]
09:02:57 <Cale> not mapM
09:03:07 <Cale> liftM
09:03:16 <Cale> > let map = liftM in map (*2) [1..10]
09:03:16 <AStorm> Yes, liftM :|
09:03:18 <lambdabot>  [2,4,6,8,10,12,14,16,18,20]
09:04:07 <Cale> xerox: (had to look up which theorem that was) yes, the proof is in Spivak
09:04:33 <chessguy> xerox, no offense, but isn't that a #math question?
09:04:49 <chessguy> @type liftM
09:04:49 <Cale> xerox: basically the idea is "take positive terms until you're over the value you want, then take negative terms until you're below, and alternate"
09:04:50 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
09:04:52 <chessguy> @type liftM2
09:04:54 <lambdabot> forall r (m :: * -> *) a2 a1. (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
09:05:01 <xerox> Oh, cool!  It's always the last reference I look up because I am too scared to find my answers formulated as problems :)
09:05:17 <Cale> hehe
09:05:28 <xerox> chessguy: yeah, I just saw Cale typing and asked him
09:06:47 * xerox glues the nose in the book
09:08:09 <chessguy> i think i'm starting to get monads. (if only i had a penny for every time i've said that)
09:08:16 <savanni> Heh.
09:09:00 <nomeata> > let map = fmap in map (*2) [1..10]
09:09:01 <lambdabot>  [2,4,6,8,10,12,14,16,18,20]
09:09:20 <nomeata> therefore, "" = "f"
09:11:14 * chessguy now has "If I were a rich man" from Fiddler on the roof running through his head
09:12:36 <nomeata> Is there a monad where liftM /= fmap?
09:12:54 <Daveman> xerox :D
09:13:12 <Philippa_> nomeata: it'd be possible
09:13:20 <nomeata> > fmap (+1) [ (+1), (+2) , (+3) ]
09:13:21 <lambdabot>  add an instance declaration for (Num (a -> a))
09:13:29 <nomeata> > (fmap (+1) [ (+1), (+2) , (+3) ]) 1001
09:13:30 <lambdabot>    The function `(fmap ((+ 1)) [(+ 1), (+ 2), (+ 3)])' is applied to one ar...
09:13:43 <nomeata> @type fmap (+1) [ (+1), (+2) , (+3) ]
09:13:45 <lambdabot> forall a. (Num (a -> a), Num a) => [a -> a]
09:14:03 <nomeata> > head (fmap (+1) [ (+1), (+2) , (+3) ]) 1
09:14:05 <lambdabot>  add an instance declaration for (Num (a -> a))
09:14:13 <nomeata> > (head (fmap (+1) [ (+1), (+2) , (+3) ])) 1
09:14:15 <lambdabot>  add an instance declaration for (Num (a -> a))
09:14:25 <allbery_b> nomeata: the (Num (a -> a)) suggests you have a problem somewhere
09:14:28 <Cale> nomeata: no, by definition of a monad
09:14:48 <Cale> Philippa_: no, it's not, so long as the instances obey the laws
09:14:57 <nomeata> oh, right, I misread it as Num a => (a -> a), and tried to fix it by adding parameters...
09:15:14 <Daveman> Cale, what if I don't want to obey the laws?
09:15:23 <allbery_b> then it's not a monad
09:15:33 <allbery_b> and using monad operations will produce strange results
09:15:34 <Daveman> Do they throw me in jail with the other bad monads?
09:15:34 <Cale> Well, then fine, but it's either not a monad, or not a functor
09:15:37 <Cale> hmm
09:15:40 <Daveman> :p
09:15:41 <nomeata> @type fmap (+1) (+2)
09:15:43 <lambdabot> forall a. (Num a) => a -> a
09:15:52 <nomeata> > (fmap (+1) (+2)) 1001
09:15:54 <lambdabot>  1004
09:16:07 <nomeata> oh, right, fmap = (.), in the (->) monad
09:16:12 <sjanssen> @remember Daveman Cale, what if I don't want to obey the laws?  Do they throw me in jail with the other bad monads?
09:16:13 <nomeata> > (liftM (+1) (+2)) 1001
09:16:15 <lambdabot>  1004
09:16:16 <Cale> actually, it would be interesting to know whether you could have a functor instance which was correct but didn't correspond to the monad instance
09:16:30 <Daveman> heh :P
09:16:35 <Cale> but that would be an incredibly silly thing to do, and break people's code
09:16:41 <Daveman> Cale, it would be like defying physics!?!
09:17:06 <Daveman> Cale, that sounds more like php... or something.
09:17:26 <Daveman> intent to break peoples' code :p
09:17:31 <Cale> well, okay, you could do something really stupid
09:17:42 <Cale> instance Functor [] where
09:17:43 <Daveman> Surely.
09:17:46 <Cale>    fmap = const []
09:17:50 <Daveman> haha
09:18:10 <Cale> er
09:18:15 <Cale> fmap f = const []
09:18:40 <nomeata> > fmap (+1) ("test", 1)
09:18:41 <lambdabot>  add an instance declaration for (Functor ((,) [Char]))
09:18:41 <lambdabot>   In the definitio...
09:18:48 <Cale> but yeah, that satisfies the laws to be a functor, but it's dumb
09:19:07 <nomeata> according to hoogle, there is an instance Functor ((->) r)
09:19:15 <Cale> It would be pretty rare when you have two nonidiotic instances of Functor for the same type.
09:19:21 <sjanssen> nomeata: lambdabot is missing imports, it seems
09:19:23 <nomeata> I mean  Functor ((,) r)
09:19:28 <Cale> sure
09:19:33 <AStorm> Well, that data Cap_t protection isn't worth squat.
09:19:35 <Daveman> hallowed are the functors
09:19:38 <Cale> fmap f (x,y) = (x, f y)
09:19:48 <AStorm>     newForeignPtr_ nullPtr >>= cap_set_proc -- this bypasses it
09:20:03 <AStorm> Haskell didn't even warn.
09:20:08 <nomeata> that might be an idea for two functor instances: fmapâ€™ping over the first or the secend element of a tupel.
09:20:20 <AStorm> Fortunately, I've added nice errno handling and it works correctly.
09:20:34 <sjanssen> nomeata: you can't fmap over the first element -- there are kind issues
09:20:42 <nomeata> hmm. ok.
09:21:19 * Daveman recompiles
09:22:43 <nomeata> So is there a good reason where there is no instance Monad m => Functor M where fmap = liftM ?
09:22:49 <nomeata> There is Monad m => Functor (WrappedMonad m)
09:23:31 <sjanssen> nomeata: there aren't any good reasons IMHO
09:23:35 <nomeata> Whatever WrappedMonad is
09:23:37 <Cale> Actually, we ought to even have:
09:23:47 <Cale> class (Functor m) => Monad m where
09:23:56 <Cale>   ... everything but fail ...
09:23:58 <syntaxfree> Will the wxHaskel binaries for GHC 6.4.0 work with 6.6.2
09:24:17 <Cale> oh, and throw in join there, because it's pretty crucial :)
09:24:19 <AStorm> How does one catch an IOError generated by an Errno handling function?
09:24:38 <AStorm> (just one kind of Errno, not all of them)
09:24:52 <Cale> @type Control.Exception.catch
09:24:54 <lambdabot> forall a. IO a -> (GHC.IOBase.Exception -> IO a) -> IO a
09:25:15 <AStorm> Let's see.
09:25:15 <Cale> @type Control.Exception.catchJust
09:25:16 <lambdabot> forall a b. (GHC.IOBase.Exception -> Maybe b) -> IO a -> (b -> IO a) -> IO a
09:25:27 <AStorm> That's much better.
09:27:02 <syntaxfree> (Oh, no it doesn't)
09:27:18 <syntaxfree> I can't seem to build it. It expects a gtk/ directory where there's none.
09:34:36 <AStorm> Hmm, how would I detect that an Errno IOError has been raised and not some other IOError? By parsing? :P
09:36:37 <AStorm> There should be a separate subclass of IOException for these.
09:36:44 <AStorm> ErrnoException maybe?
09:36:59 <AStorm> But then, it wouldn't be H98
09:39:23 <AStorm> Or not. There are some nice predicates...
09:39:31 <AStorm> But none of them for errnos.
09:40:04 <allbery_b> errno isn't especially portable
09:41:23 <AStorm> It is as the C library is :>
09:41:39 <AStorm> You could have some errnoErrorType
09:41:59 <AStorm> and isErrno :: Num a -> IOErrorType -> Bool
09:42:15 <AStorm> Maybe s/Num a/Errno/
09:43:18 <allbery_b> but there is no guarantee that the Haskell runtime system uses the standard C library
09:43:49 <AStorm> Yes, no guarantee at all. Errno can be undefined anyway.
09:43:59 <AStorm> BUT if you use FFI, you're guaranteed to get some errnos :P
09:45:00 <allbery_b> you should pass those back as part of the FFI then, there is no guarantee that errno is consistent once you return to haskell
09:45:21 <AStorm> Not errno.
09:45:27 <AStorm> The exception thrown.
09:45:57 <AStorm> My major gripe with those errnos is that the exception thrown by throwErrnoIf* functions is plain IOError
09:46:12 <AStorm> Not some special IOErrorType, which you could check on.
09:46:27 <allbery_b> and, as to H98 compatibility:  the FFI is not H98
09:47:09 <AStorm> Yes, so this tiny thing could be changed.
09:47:18 <AStorm> I mean, just add a new IOErrorType
09:47:30 <AStorm> and some predicate on it.
09:47:41 <Philippa_> the FFI is an official addendum to the H98 standard though
09:48:06 <AStorm> Actually, what I propose wouldn't change the official addendum at all.
09:48:15 <AStorm> It would still be an IOError, just different IOErrorType
09:48:26 <fasta> How can I use mfix for this? http://pastebin.ca/275600
09:50:37 <syntaxfree> lisppaste is really down, eh?
09:50:46 <chessguy> again?
09:50:52 <chessguy> lisppaste2, paste
09:51:01 <chessguy> @paste
09:51:01 <lambdabot> http://paste.lisp.org/new/haskell
09:51:26 <allbery_b> it's "lisppaste2: url"
09:51:34 <lisppaste2> chessguy pasted "test" at http://paste.lisp.org/display/32018
09:52:45 <chessguy> looks ok to me
09:55:17 <AStorm> @hoogle mfix
09:55:18 <lambdabot> Control.Monad.Fix.mfix :: MonadFix m => (a -> m a) -> m a
10:03:19 <sjanssen> we need lambdabotpaste, stat
10:06:34 <sjanssen> @where happs
10:06:34 <lambdabot> http://happs.org
10:14:46 <syntaxfree> happs.org needs a redesign.
10:15:08 <syntaxfree> It looks like it's ready to change the world, yet the site makes it looks like a little research problem.
10:16:42 <nominolo> is it deprecated to reexport a module in GHC 6.x?
10:17:13 <nominolo> i.e. module Foo ( module Bar, [...] ) where import Bar ...
10:17:41 <nominolo> i get error messages in AFRP when compiling it with ghc 6.6
10:17:51 <Saizan> i don't whink so, Data.Array export Data.Ix
10:19:25 <nominolo> ah, no. the problem is that at another place someone does module X (module Foo, module Bar) where ...
10:19:43 <nominolo> there i get lots of error message
10:20:17 <nominolo> i seem to have read somewhere that there were some changes wrt modules in ghc 6.6 (or 6.5, or 6.4)
10:21:11 <sjanssen> nominolo: paste the error messages, perhaps?
10:21:24 <nominolo> k, mom ...
10:21:49 <syntaxfree> nominolo is sjanssen's son?
10:22:11 <Excedrin> no, daughter
10:22:37 <nominolo> no, that was short for "one moment please"
10:23:02 <nominolo> but it's probably ambiguous in english :)
10:25:38 <lisppaste2> nominolo pasted "AFRP build error message" at http://paste.lisp.org/display/32020
10:27:50 <lisppaste2> nominolo annotated #32020 with "code" at http://paste.lisp.org/display/32020#1
10:28:26 <nominolo> i assume this worked in older versions of ghc. (at least < 6)
10:30:32 <sjanssen> nominolo: this doesn't look like a GHC 6.6 problem
10:30:52 <sjanssen> it looks like AFRPUtilities both defines and imports >>^
10:31:49 <nominolo> well, i assume this is because it exports a module which another module it also exports.
10:32:02 <nominolo> but i assume it used to work some time
10:32:26 <nominolo> i was just asking if this is a well-known change
10:32:38 <sjanssen> I've never heard of this
10:32:52 <sjanssen> can you paste the file AFRPUtilities.hs?
10:35:22 <lisppaste2> nominolo annotated #32020 with "AFRPUtilities" at http://paste.lisp.org/display/32020#2
10:35:38 <nominolo> you're right.  it does reexport this
10:36:45 <sjanssen> perhaps it should import AFRP hiding ((>>^))?
10:36:58 <nominolo> yes, i'll try that
10:38:14 <sjanssen> it looks like >>^ is defined in the standard lib Control.Arrow, that might be a new addition as of GHC 6.6
10:38:25 <nominolo> nice, worked
10:38:28 <nominolo> thanks!
10:38:54 <xerox> (^>> >>^ ^<< <<^ should be defined in 6.4 too I think)
10:40:24 <ski> @type (Control.Arrow.>>^)
10:40:25 <lambdabot> forall d b (a :: * -> * -> *) c. (Arrow a) => a b c -> (c -> d) -> a b d
10:40:57 <ski> hm
10:41:03 <cjeris> Control.Arrow clearly needs to make use of Commodore-64 ASCII graphics and IBM box-drawing characters
10:41:52 <ski> cjeris : haha
10:42:24 <nominolo> xerox: well let's see what happens if i try to use my newly build lib
10:42:26 <ski> (maybe a task for my less-than vapourware functional language on C64, then ..)
10:43:00 <nominolo> these boxes are also part of unicode
10:43:10 <SyntaxNinja> Igloo: do you still maintain the document about how to package stuff for haskell on Debian?  I was trying to reply to  Pupeno and couldn't dig up that document for some reason.
10:43:10 <ski> can anyone see why 'case e of Left l -> Left l; Right r -> Right r' would not be equivalent to 'e' ?
10:43:54 <xerox> ski: e :: forall a. a, case e of .. :: forall a b. Either a b
10:44:03 <AStorm> ski, what about e not being Left or Right?
10:44:22 <ski> AStorm : then it could only be bottom
10:44:24 <AStorm> I mean _ -> Whatever
10:44:32 <AStorm> So use Either.
10:44:49 <ski> :t \e -> case e of Left l -> Left l; Right r -> Right r
10:44:50 <lambdabot> forall b a. Either a b -> Either a b
10:45:00 <ski> it already uses 'Either'
10:45:07 <xerox> :t \e -> e
10:45:09 <lambdabot> forall t. t -> t
10:45:20 <AStorm> So throw that case away :>
10:45:27 <Cale> hmm
10:45:46 <xerox> pattern matching forcing evaluation?
10:45:56 <ski> (of course the equivalence is over the common type of both sides ..)
10:46:03 <AStorm> Well, more or less.
10:46:25 <ski> xerox : but that shouldn't happen before the result is demanded, yes ? .. at which point 'e' would be demanded as well
10:46:59 <ski> Daniel C. Wang is stating that it doesn't hold in haskell .. i fail to see how it fails to hold
10:47:49 <Cale> I don't think I see that either. Bottom is sent to bottom, there doesn't seem to be any way in which seq/trace can be abused.
10:48:14 <Cale> (well, more importantly, nothing else is sent to bottom)
10:48:28 <ski> m
10:48:44 <ski> he's been stating this twice or thrice on c.l.f, now
10:48:49 <ski> i suspect he mixed up this eta-rule with a beta-rule .. hm
10:48:54 <Cale> I think that's absurd
10:49:21 <sjanssen> ski: 'case e ...' and 'e' are equivalent in your example
10:49:58 <AStorm> Doesn't the case involve Eq protocol?
10:50:12 <sjanssen> AStorm: no
10:50:16 <ski> (you can see for yourself, if you want .. thread "Why purely functional languages?")
10:50:41 <ski> sjanssen : yes, that's what i think, too
10:51:23 <Cale> Why does he claim they're different?
10:51:29 <astrolabe> link please?
10:52:04 <sjanssen> http://groups.google.com/group/comp.lang.functional/browse_frm/thread/8c32122fa1970299/39508fdcf64c8b7c?lnk=gst&q=Why+purely+functional+languages&rnum=1#39508fdcf64c8b7c I think
10:52:04 <ski> (moment)
10:52:06 <lambdabot> Title: Google Groups : comp.lang.functional, http://tinyurl.com/yymbba
10:52:19 <astrolabe> sjanssen: thank you
10:55:14 <ndm> hi everybody!
10:55:19 <Cale> hello
10:55:30 <twodogsandacat> hi
10:57:39 <allbery_b> boom
10:57:45 <savanni> What happened?
10:58:46 <AStorm> Split.
10:59:35 <ski> http://groups.google.com/group/comp.lang.functional/msg/84658172ffc13d50 (and responses) .. and http://groups.google.com/group/comp.lang.functional/msg/9e169f3f48199764
10:59:54 <dylan> clear
11:00:04 <dylan> err, oops
11:00:39 <syntaxfree> Split happens.
11:00:39 <vincenz> dylan: how is #ocaml
11:00:53 <vincenz> @type \irc -> join irc
11:01:09 <dylan> vincenz: I stopped going there.
11:01:14 <vincenz> ah
11:01:14 <dylan> when I started coming here
11:01:19 <AStorm> Well, lambdabot is still out.
11:01:26 <dylan> I essentially abandoned ocaml as a useable language
11:01:30 <vincenz> dylan: same
11:01:34 <dylan> (after writing a fairly big project in it)
11:01:46 <vincenz> same
11:01:46 <twodogsandacat> dylan, vincenz: why?
11:01:47 <AStorm> Ocaml is quite unusable for me due to awkward Unicode support.
11:01:59 <vincenz> twodogsandacat: haskell is superior
11:02:06 <syntaxfree> some financial companies are starting to use ocaml, it appears.
11:02:11 <AStorm> Yes, and Haskell is superior :>
11:02:33 <Masklinn> Astorm > haskell is only better as long as you're not using ByteStrings right?
11:03:05 <vincenz> o.O
11:03:35 <AStorm> Why not? There is an UTF-8 variant of them...
11:03:42 <Masklinn> oh is there?
11:04:20 <vincenz> use [Char]?
11:04:24 <vincenz> Bytestrings are intended for ...
11:04:26 <vincenz> drumroll...
11:04:27 <vincenz> bytes
11:05:18 <syntaxfree> It's smart in an algebraic way that String = [Char], but not practical.
11:05:21 <Masklinn> Uh no, ByteStrings are intended for Strings implemented as byte arrays, which is to say C-like strings
11:05:43 <dylan> twodogsandacat: haskell's community as a whole has more social skills than ocaml's.
11:05:43 <AStorm> Yes. Other than that, encode and decode from UTF-8 ByteStrings into plain Strings works ok.
11:05:49 <Masklinn> the point of bytestrings is that they're much faster than Data.String for most string-related manipulations
11:05:49 <AStorm> :>
11:06:01 <Masklinn> AStorm > Don't bytestrings only work on Char8?
11:06:11 <AStorm> They do. UTF-8 is 8-bit.
11:06:11 <vincenz> dylan: agreed
11:06:18 <AStorm> Unicode = Char
11:06:34 <Masklinn> Uh no, UTF-8 definitely isn't 8 bit
11:06:37 <AStorm> "It can be expected that these functions will run at identical speeds to their Word8 equivalents in Data.ByteString."
11:06:43 <syntaxfree> There's a nonlinearity in the skillset-smugness curve
11:06:45 <Masklinn> it's 8 bit as long as you're only using ASCII chars
11:06:49 <allbery_b> er
11:06:53 <fasta> How can I make this tie function work with mfix? http://pastebin.ca/275694
11:06:55 <AStorm> It's 8-bit if you're using any chars.
11:06:58 <AStorm> It's multibyte.
11:07:07 <allbery_b> Unicode is not 8 bit.  UTF8 is, becuse it is an encoding of Unicode into 8-bit bytes
11:07:11 <syntaxfree> For most values of skill level, smugness is crescent, but it peaks at the MSc. level and decreases from PhD on.
11:07:31 <savanni> However, 8-bit does not mean 8-bits == 1 character
11:07:38 <vincenz> syntaxfree: and then peaks at tenure
11:07:51 <allbery_b> (which is precisely why it is used; it works reasonably well with traditional byte strings, as used in e.g. C)
11:07:52 <Masklinn> AStorm > What I meant is that, at the moment, the only ByteString implementation I see (fps, which is in GHC 6.6) only has Char8 datatype, which means 1 char == 8 bits
11:08:03 <Masklinn> Unicode characters can take 1 to 6 bytes
11:08:05 <Igloo> SyntaxNinja: http://urchin.earth.li/~ian/haskell-policy/ - I haven't touched it recently, but it should be mostly up-to-date
11:08:07 <Masklinn> so that wouldn't work
11:08:07 <syntaxfree> you mean, reaches a critical point?
11:08:46 <Masklinn> allbery_b > yes, but what I said was that Haskell's Unicode support is only good as long as you don't need ByteString
11:08:47 <AStorm> Masklinn, yes, they do.
11:09:12 <AStorm> But when UTF-8 encoded, the string is still 8-bit :P
11:09:22 <AStorm> You can decode on the fly if you need to.
11:09:22 <Masklinn> It's not 8 bit/character
11:09:29 <AStorm> Yes, it's not 8bit/char
11:09:53 <syntaxfree> @wikipedia UTF-8
11:09:56 <Masklinn> And the current Data.ByteString datatype is Data.ByteString.Char8
11:10:07 <syntaxfree> @dict UTF-8
11:10:08 <Masklinn> which specifically states "A ByteString contains 8-bit characters only."
11:10:23 <Masklinn> so as I said, Unicode in haskell is good until you need ByteString
11:10:29 <savanni> Might be fun to write a unicode library that introduces a unicode data type and the encoding/decoding functions.
11:10:48 <AStorm> No, it's still good. You can easily convert between ByteString and String as needed.
11:10:49 <allbery_b> you can get away with it as long as you demarshal utf8 into unicode (in a String) as needed.
11:11:10 <AStorm> allbery_b, ;-)
11:11:14 <allbery_b> if you don't actually need to manipulate unicode qua unicode, ByteString should work fine
11:11:34 <allbery_b> this is, after all, more or less the way C / C++ handles unicode
11:11:39 <SyntaxNinja> Igloo: thanks.
11:11:51 <Masklinn> allbery_b > which doesn't mean it's a good way
11:11:57 <user317> is there a haskell math library somewhere?  i am looking for an implementation of the recursive least squares algorithm
11:12:01 <AStorm> I don't have to install any special libs to work with unicode, unlike Ovaml.
11:12:01 <allbery_b> no, but there is no good way
11:12:10 <AStorm> user317, implement it yourself. Fast and simple.
11:12:19 <AStorm> And why recursive? :P
11:12:37 <allbery_b> the simple way is the equivalent of Haskell's String type, but that's slow (hence ByteString)
11:13:02 <syntaxfree> recursive least-squares (Gauss-Newton regression) is often the fastest algorithm for large datasets.
11:13:04 <AStorm> It's fast enough, unless you work on strings > 10MB and do a lot of ops.
11:13:11 <Masklinn> allbery_b > well the "good way" would be to use a unicode-compatible internal format for bytestrings (ucs-2 or utf-16 internals, or even raw Unicode codepoints), which is what Python or Java do
11:13:15 * syntaxfree just had an exam on GNR methods in econometrics.
11:13:20 <AStorm> syntaxfree, Lagrange's variant is always faster :P
11:13:28 <Masklinn> so instead of 8 bit chars you'd manipulate 16 or 32 bits chars
11:13:35 <AStorm> There's also a summing variant, this is fast too.
11:13:41 <user317> AStorm, is it simple?  the ones that I find on the net all involve solving a set of linear equations, i don't think thats trivial to implement.
11:13:53 <AStorm> user317, ehhh.... Wikipedia :P
11:14:14 <AStorm> There is a correct equation on Polish one at least.
11:14:31 <syntaxfree> user317: the book I studied the GNR with is "Econometric Theory and Methods" by Davidson & McKinnon. I can send you the PDF if you wish.
11:15:01 <AStorm> http://pl.wikipedia.org/wiki/Metoda_Najmniejszych_Kwadrat%C3%B3w
11:15:02 <Masklinn> allbery_b > now I don't mean that it's easy or anything, not by a long shot, I don't go any further than my initial statement which was "Haskell's unicode support is very good until you need packed strings"
11:15:10 <user317> I think its available in Russian on wp :)
11:15:54 <AStorm> (sorry for the language, but the equations are simple anyway)
11:16:14 <syntaxfree> what *is* the monomorphism restriction?
11:18:42 <AStorm> Masklinn, it's still very good. After extending ByteStrings to WideStrings... (using Word32 or something like that)
11:19:00 <AStorm> And WChar as the base.
11:19:25 <Cale> syntaxfree: it basically says that certain declaration groups which are missing type explicit type declarations can't be assigned polymorphic types
11:19:48 <Cale> er, minus spurious extra instance of the word "type"
11:19:51 <AStorm> As to the equasions: the only caveat is that delta is a small number - requires a lot of floating-point precision.
11:20:09 <Cale> http://haskell.org/onlinereport/decls.html#sect4.5.5
11:20:11 <AStorm> But you can avoid that problem in Haskell by using Rational type.
11:20:25 <syntaxfree> Basically, explicitly declaring all types should avoid the "Monomorphism restriction applied to.."  errors?
11:20:33 <Cale> yeah
11:20:44 <Cale> and/or just turning the MR off altogether
11:20:53 <Cale> -fno-monomorphism-restriction
11:21:01 <syntaxfree> that sounds unsafe.
11:21:05 <Cale> It's not
11:21:11 <AStorm> Usually not.
11:21:28 <syntaxfree> @hoogle GLFloat
11:21:39 <Cale> There are a few spurious programs which can run much slower without it, because of their polymorphism.
11:21:45 <ski> no lambdabot :(
11:22:00 <syntaxfree> come back lambdabot!
11:22:03 <syntaxfree> we love you!
11:22:14 <Cale> Basically, if you define what is supposed to be a memoised constant, and it's accidentally assigned a polymorphic type, then it won't be memoised the way you want.
11:22:18 <AStorm> He died with the split...
11:22:30 <ski> s/He/She/
11:22:39 <Cale> because the typeclass transformation will add parameters turning it into a function
11:22:43 <Saizan> is female?
11:23:00 <Cale> That's basically the only reason for it.
11:23:07 <AStorm> Whatever. Bot anyway.
11:23:30 <AStorm> There are 4 sexes: Male, Female, Both, Undefined :>
11:23:36 <Cale> also, in a few cases, you'll get ambiguity which resolves itself via the MR, but it's not that serious either.
11:23:44 <syntaxfree> I remember reading that there are 11 sexes.
11:23:51 <AStorm> Could be too :P
11:24:05 <syntaxfree> Most people concentrate in the two main ones, though.
11:24:07 <ndm> AStorm: isn't sex a latice? Top, Bottom, Male, Female
11:24:17 <AStorm> :P
11:24:22 <syntaxfree> ndm: that's S&M sex.
11:24:27 <Cale> All you have to remember about the MR is that if you're relying on something being shared in a major way for performance, explicitly give it a monomorphic type.
11:24:40 <Cale> (that is, if the MR is turned off)
11:24:55 <Cale> In fact, it's a pretty good idea with the MR turned on anyway
11:25:37 <Cale> But the MR is a pain way more than it's actually helpful.
11:25:47 <fasta> fixSomeHow element =  do
11:25:47 <fasta>   (ret,_)<-mfix (\(_,ref)->do tail_ref <- newSTRef (Tail ref)
11:25:47 <fasta>                               head_ref <- newSTRef (Head ref)
11:25:47 <fasta>                               let new_link = Link element head_ref tail_ref
11:25:47 <fasta>                               elem_ref_thingie <-newSTRef new_link
11:25:49 <fasta>                               return (new_link, elem_ref_thingie))
11:25:52 <fasta>   return ret
11:25:59 <ski> Saizan,AStorm : http://trappist.elis.ugent.be/~kehoste/haskell-blah_lambdabotContest.html
11:26:04 <fasta> Can this be improved somehow?
11:26:18 <Cale> why not use mdo?
11:26:29 <Cale> That's what mdo was made for.
11:26:36 <fasta> I.e. by only using mfix, and not the pattern match outside it?
11:26:38 <syntaxfree> mdo? :(
11:26:46 <Excedrin> Hermaphrodite male, Hermaphrodite female, Hermaphrodite simultaneous
11:27:05 <fasta> Cale: I know, but I would like to do(heh) it without mdo.
11:27:26 <vincenz> @quote vincenz
11:28:15 <vincenz> Anyawys
11:28:18 <vincenz> you're all wrong
11:28:19 <AStorm> ski, LOL
11:28:27 <vincenz> Each sex is a different type, all they share is _|_
11:28:30 <fasta> Can it be done with just one call to mfix?
11:28:42 <ski> fasta : does that work without a lazy pattern ?
11:28:57 <zeeeee> why does the example code snippet under 'Scheduling' in the Control.Concurrent docs not work as described? (i see long sequences of "aaa"s and "bbbb"s interleaved, whereas the docs say there is no preemption)
11:29:00 <syntaxfree> Excedring: data Sex = (Maybe Male) (Maybe Female)?
11:29:06 <fasta> ski: I didn't execute it yet :)
11:29:10 <glguy> isn't undefined just Haskell's version of null in languages with nullable types?
11:29:30 <glguy> and passing and failing because of undefined is just like a NullReferenceException?
11:29:37 <vincenz> (_|_)
11:29:57 <AStorm> syntaxfree, data Sex = Maybe Either Male Female
11:30:08 <ski> glguy : no, bottom is more like 'for(;;);'
11:30:10 <savanni> lol
11:30:14 <Cale> glguy: I'd say it's more like nontermination, but somewhat, sure.
11:30:36 <Cale> #define ever (;;)
11:30:39 <AStorm> Bottom is the generic error. Undefined is a special case of it.
11:30:41 <vincenz> ski: No, (_|_) or bottom is shared by all types, Male and Female
11:31:02 <ski> vincenz : hm ?
11:31:16 <Botje> vincenz: how about (__|__) ?
11:31:25 <vincenz> Botje: Only the dutch
11:31:33 <Botje> :)
11:31:47 * vincenz tends to get a kind error with those tho
11:32:10 <Excedrin> syntaxfree: yea, I think that covers most of it...
11:32:38 <zeeeee> the example i'm referring to is http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html#3
11:32:40 <fasta> ski: but is it possible to define that function only with mfix?
11:33:32 <Cale> Someone posted "A Gentle Introduction to ML" on programming.reddit. As much as I like to see stuff about functional programming there, I mean, isn't that kind of like posting the Haskell 98 Report?
11:33:50 <fasta> For the US it would be (_._._._._._._._|_._._._._._._._) :)
11:34:25 <AStorm> This is even a syntax error.
11:34:34 <AStorm> It means there is no word to call that.
11:35:05 <ski> fasta : i guess you could use 'readSTRef' instead of looping over the pair .. though i don't know why you're odd, here
11:35:18 <vincenz> fasta: that's one with pimples?
11:35:32 <AStorm> Yes, and wiiii....iiide
11:35:36 <fasta> vincenz: ascii hairs
11:35:45 <fasta> vincenz: my ascii art stinks
11:35:49 <fasta> hehe
11:35:52 <vincenz> fasta: yeah, wide bottoms tend to do that
11:36:28 <AStorm> That certainly fubars my programming ;>
11:36:58 <fasta> ski: I basically want to have a new node linked to a head node and a tail node.
11:37:37 <ski> and the head and tail looping back to the node
11:38:10 <fasta> ski: right
11:38:39 <ski> why
11:38:44 <ski> fixSomeHow :: a -> ST s (FooOdd s a)
11:38:46 <ski> instead of
11:38:49 <ski> fixSomeHow :: a -> ST s (FooEven s a)
11:38:50 <ski> ?
11:39:07 <ski> type FooEven s a = STRef s (FooOdd s a)  -- newtype, if you want
11:39:38 <ski> data FooOdd s a = Link (FooHead s a) (FooTail s a)
11:39:53 <ski> data FooHead s a = Head (FooEven s a)
11:40:01 <ski> data FooTail s a = Tail (FooEven s a)
11:40:23 <ski> (or am i misinterpreting ?)
11:40:34 <vincenz> http://xkcd.com/
11:40:59 <fasta> ski: FooEven is a singly connected list. I need a doubly connected list.
11:41:06 <fasta> ski: If that's what you meant?
11:41:24 <ski> it is not singly connected
11:41:32 <fasta> ski: oh, right.
11:41:56 <vincenz> why do you need a doubly connected list
11:42:12 <fasta> vincenz: I want to represent an edge list
11:42:57 <ski> How to add laziness to a strict language without even being odd, http://homepages.inf.ed.ac.uk/wadler/papers/lazyinstrict/lazyinstrict.ps.gz
11:43:15 <ski> (that explains the 'even' vs. 'odd' terminology)
11:43:59 <vincenz> fasta: you still have not given me a valid reason
11:44:16 <fasta> vincenz: I want constant time addition and removal of edges.
11:44:46 <fasta> vincenz: I am not aware of pure functional data structures with this property
11:45:22 <shapr> Shazam!
11:46:16 <Philippa_> fasta: what does "pure functional" have to do with time?
11:46:17 <Nafai> Hello shapr!
11:46:21 * ski starts thinking of salt water wells
11:46:21 <Philippa_> (no, I'm not just taking the piss)
11:47:15 <Philippa_> to put it another way: the problem isn't being pure functional, it's not knowing about sharing
11:47:17 <ski> shapr : varen hälsad
11:48:52 <fasta> Philippa_: yes, so, how does one implement a doubly linked list without using ST?
11:49:01 <vincenz> very carefully
11:49:02 <AStorm> fasta, uhh... a fibonacci tree?
11:49:21 <AStorm> Or maybe some other balanced tree.
11:49:38 <vincenz> fasta: you're mistaking implementation detail for requirement
11:50:18 <vincenz> I'm certain you can get amortized constant removal with something that is not perse a DLL
11:50:20 <fasta> AStorm: constant time removal?
11:50:25 <AStorm> Let's see...
11:50:36 <vincenz> you're thinking DLL cause you're thinking imperatively
11:50:41 <vincenz> Look at okasaki's work
11:51:17 <fasta> vincenz: I have looked at his work and I would guess that he would have included a DLL if he had known a way.
11:51:36 <AStorm> fasta, you can't do constant time removal :P
11:51:42 <AStorm> You have to find the item first :P
11:52:00 <fasta> AStorm: if you already have a reference to the item it's constant time....
11:52:02 <AStorm> Unless it's a good hash table.
11:52:14 <AStorm> If you have a reference, it's constant time everywhere :P
11:52:16 <glguy> http://tinyurl.com/ykok6h
11:52:32 <syntaxfree> Hoogle doesn't seem to know about OpenGL and GLUT functions.
11:52:36 <glguy> ?version
11:52:44 <glguy> )-X
11:52:54 <ski> no lambdabot :(
11:53:11 <syntaxfree> glguy: can't see that image, man.
11:53:19 <syntaxfree> host it on imageshack.us
11:53:27 <ndm> syntaxfree: no, it doesn't
11:53:33 <ndm> syntaxfree: Hoogle 4 will
11:53:41 <AStorm> Pirates, arr :>
11:53:57 <syntaxfree> ndm: okie dokie.
11:54:04 <fasta> vincenz: How can you be that certain?
11:54:11 * syntaxfree reverts to Haddock+Ctrl-F mode.
11:54:21 <vincenz> fasta: about?
11:54:33 <AStorm> fasta - implement a hash table and there you have your constant-time insertion and removal.
11:54:57 <AStorm> (or amortised constant time in case of open addressing)
11:55:27 <fasta> AStorm: I don't think you understand.
11:56:09 <fasta> A Google search suggests that nobody ever has implemented a DLL without using something like ST that supports constant time removal.
11:56:19 <xerox> syntaxfree: are you doing opengl on os x?
11:56:30 <fasta> Even in an amortized setting
11:56:34 <AStorm> fasta, so what do you exactly want from that hash table?
11:56:44 <AStorm> s/hash table/data structure/
11:56:48 <syntaxfree> xerox:  yes, why?
11:56:54 <xerox> syntaxfree: *how*? (:
11:57:12 <syntaxfree> xerox, uh, I don't know. It just worked.
11:57:17 <AStorm> GLUT.
11:57:22 <syntaxfree> I saw this tutorial on programming.reddit.com
11:57:24 <syntaxfree> ah, yes, GLUT.
11:57:26 <xerox> What worked? I'd like to try something.
11:57:31 <xerox> Any link?
11:57:45 <fasta> vincenz: "I'm certain you can get amortized constant removal with something that is not perse a DLL"
11:57:50 <syntaxfree> it's not a specific tutorial about OS X.
11:57:55 <xerox> or just what modules do you use
11:57:56 <vincenz> fasta: cause DLLs is definitely not the way to go
11:57:56 <syntaxfree> It Just Works on OS X.
11:57:59 <ndm> amortised constant time?
11:58:01 <vincenz> fasta: read okasaki's work
11:58:25 <syntaxfree> It used to just work on the 6.4.2 binaries distributed on haskell.org
11:58:26 <fasta> vincenz: I have browsed it, and AFAIR, he didn't treat something like DLLs
11:58:31 <syntaxfree> now it just works on 6.6.2 I compiled myself.
11:58:33 <vincenz> fasta: that's my point
11:58:41 <vincenz> fasta: DLLs won't work in a language with sharing
11:58:50 <vincenz> fasta: so find another structure that gives you ammortized constant time
11:58:54 <vincenz> stop fixing on a solution that works in C
11:59:04 <AStorm> You don't need the DLL most of the time.
11:59:08 <fasta> vincenz: and what makes you think such a solution exists?
11:59:20 <fasta> You are all making existential statements.
11:59:25 <AStorm> fasta, once again, what do you want to do?
11:59:40 <vincenz> fasta: Either way, I know for sure DLLs are -not- the way to go, unless you enter an imperative monad
11:59:44 <AStorm> (except than implementing an O(1) DLL)
11:59:49 <fasta> AStorm: browse back in history or read the logs.
12:00:05 <AStorm> Why a DLL then, when a singly linked list will suffice?
12:00:32 <AStorm> Actually, a DLL, but w/o loops at the ends.
12:01:07 <AStorm> Insertion at the ends would be O(1)
12:01:32 <AStorm> Removal anywhere theoretically O(1), worst case O(n) (full lookup)
12:01:49 <fasta> AStorm: You are really creative in your arguments.
12:01:56 <AStorm> No, I'm not :P
12:02:05 <fasta> AStorm: Produce a formal proof with a program and I will check it out.
12:02:09 <AStorm> :P
12:02:33 <AStorm> Well, keep references to both ends and that's it.
12:02:45 <Cale> meh, I'd settle for logarithmic time.
12:03:06 <fasta> If you want to hackup something then logarithmic time suffices.
12:03:24 <AStorm> How can you do random-access removal at O(1) with a DLL in C? :P
12:03:27 <Cale> Data.Sequence is really nicely flexible and doesn't involve dealing with pointer mutation.
12:03:47 <AStorm> Exactly.
12:03:50 <fasta> Cale: yes, but log n operations that are O(1)
12:04:17 <fasta> Edison (Okasaki's stuff) is nice and all, but doesn't state the complexities of the operations in the documentation.
12:04:37 <vincenz> fasta: that's not the work I meand
12:04:44 <vincenz> fasta: I meant his thesis on lazy datastructures
12:04:50 <fasta> vincenz: yes, I know.
12:04:52 <vincenz> fasta: That mention amortized complexity
12:05:14 <Cale> you can delete an arbitrary element in O(log(min(i,n-i))) time (with n the total length, i the index to delete)
12:05:14 <fasta> vincenz: I read he implemented a queue and some other data structures.
12:05:15 <vincenz> AStorm: the assumption is that you have an iterator
12:05:24 <xerox> Loading package OpenGL-2.1 ... ghc-6.6: can't load .so/.DLL for: HSOpenGL_cbits (dlopen(libHSOpenGL_cbits.dylib, 10): image not found)
12:05:30 <vincenz> fasta: what about a fingertree
12:05:33 <xerox> anybody knows what that does mean?
12:05:39 <fasta> vincenz: log n operation, IIRC.
12:05:42 <vincenz> hm
12:05:50 <fasta> vincenz: I saw a presentation about those.
12:06:00 <AStorm> Well, iteration itself is O(1), at most you'd have to iterate n times to remove an item.
12:06:30 <vincenz> AStorm: hence that's O(n)
12:06:42 <AStorm> That's why I don't know why does he want a DLL.
12:06:49 * vincenz peers at AStorm 
12:07:05 <vincenz> AStorm: in C, given a pointer to an element, a DLL allows O(1) removal
12:07:15 <vincenz> of any random element, not just the head
12:07:27 <AStorm> Given a reference to an element, Haskell can do that too :P (STRef)
12:07:35 <vincenz> AStorm: he's trying to forego ST
12:07:43 <AStorm> So he has a problem :P
12:07:47 <vincenz> aka a purely functional datastruture
12:07:57 <Cale> log time is practically constant time in this case
12:08:06 <AStorm> "practically"
12:08:10 <fasta> haha
12:08:16 <Cale> You only have so much memory
12:08:23 <Cale> and log(n) will be small regardless
12:08:55 <AStorm> Well, he could create a skiplist.
12:08:55 <vincenz> @quote fasta
12:09:05 <AStorm> A list with empty items on removal - to be skipped.
12:09:19 <AStorm> Fixing the links on traversal.
12:09:52 <AStorm> Though the traversal wouldn't be O(1) necessarily then.
12:10:09 <fasta> AStorm: Really, why don't you take my advice?
12:10:14 <Cale> For practical purposes, you can usually ignore logarithmic factors.
12:10:26 <vincenz> Cale: you better flee now
12:10:26 <SlowByte> hey, even memory access is not O(1) these days
12:10:33 <AStorm> :D
12:10:41 <fasta> Cale: it's a constant factor of about 20.
12:11:03 <AStorm> It's actually not constant, just a very small ln
12:11:08 * vincenz shakes his head and leaves this rather ridiculous conversation
12:11:22 <cjeris> SlowByte: "O(1) ain't what it used to be"
12:11:34 <AStorm> At current memory sizes, it is said to be bounded by some constant :P
12:11:58 <AStorm> Anyway.
12:12:00 * AStorm ducks
12:12:25 <vincenz> 10^80 ?
12:12:26 <Cale> How big is your list?
12:12:27 <SlowByte> at infinite memory sizes I guess it'd be O(log n), but that's better left to physicists ;)
12:12:58 <SlowByte> at least using current memory architectures
12:13:05 <SlowByte> you can't make a bus with infinite fanout
12:13:17 <AStorm> vincenz, log 10^80/number of cells ns maybe?
12:13:32 <vincenz> AStorm: 10^80 = number of atoms in universe
12:13:50 <AStorm> I know :P
12:14:00 <vincenz> No you don't
12:14:15 <AStorm> (because it's imprecise and tenative?)
12:14:39 <int-e> @spell tentative
12:14:48 <AStorm> :>
12:14:52 <AStorm> No lambdabot today.
12:14:57 <int-e> aww
12:15:13 <AStorm> And my mistake :P
12:15:30 <Cale> If you need a finite sequence which is easy to split up and manipulate, try Data.Sequence, and see if it's fast enough, and only if it's really not, then go ahead and implement some doubly linked list monstrosity. :)
12:15:59 <fasta> And as for my original question? How to do it only with mfix?
12:16:00 <int-e> doubly linked lists aren't the problem. updating them is ;)
12:16:50 <fasta> Cale: Data.Sequence can be used in one part of the algorithm I am implementing, just not here.
12:16:58 <int-e> data DLL a = DLL { left :: DLL; value :: a; right :: DLL } plus some knot tying - voila, a doubly linked list.
12:17:01 <Cale> What are you implementing?
12:17:37 * vincenz ties a knot around int-e 
12:17:38 <AStorm> int-e, but not constant time removal :P
12:17:41 <fasta> Cale: some algorithm that was recently invented that nobody implemented yet.
12:17:47 <vincenz> fasta: which one
12:17:54 <int-e> AStorm: I said that manipulating it would be problematic ;)
12:17:59 <xerox> int-e: do you know of a library that defines an usable implementation?
12:18:03 <AStorm> W/o STRefs certainly.
12:18:10 <ski> hm, isn't there some function with type 'forall s a. (STRef s a -> a) -> ST s (STRef s a)' ?
12:18:26 <fasta> vincenz: perfect matching in bipartite multi-graphs in O(m), where m is the number of edges.
12:18:26 <int-e> xerox: no. I have my doubts about its usefulness anyway.
12:18:29 <vincenz> ski: yes
12:18:52 <AStorm> Sounds OCRy.
12:18:59 <vincenz> oh wait, no
12:19:24 <Cale> How do you even get an STRef s a -> a in order to pass to that function?
12:19:42 <vincenz> Cale: runST?
12:19:50 <Cale> nope
12:19:58 <Cale> that won't typecheck
12:20:00 <ski> \ref -> DLL {left = ref,value = 'a',right = ref}
12:20:10 <AStorm> @hoogle STRef s a -> a
12:20:17 <fasta> fixSomeHow element =  do
12:20:17 <fasta>   (ret,_)<-mfix (\ iteration ~(_,ref)->do tail_ref <- newSTRef (Tail ref)
12:20:17 <fasta>                                 head_ref <- newSTRef (Head ref)
12:20:17 <fasta>                                 let new_link = Link element head_ref tail_ref
12:20:17 <fasta>                                 elem_ref_thingie <-newSTRef new_link
12:20:18 <int-e> Cale: unsafePerformIO + unsafe?STtoIO
12:20:19 <fasta>                                 return (new_link, elem_ref_thingie))
12:20:22 <fasta>   return ret
12:20:27 <ski> er, using a 'DLL' which indirects the links, of course
12:20:28 <vincenz> fasta: !!
12:20:29 <Cale> okay, so you can break things
12:20:30 <vincenz> fasta: @paste
12:20:41 <AStorm> Blah, no ugly bot :P
12:20:41 <fasta> Hmm, ok, that's the wrong version
12:20:51 <vincenz> fasta: shouldn't it be O(km)/
12:20:55 <vincenz> not O(m)
12:20:59 <fasta> vincenz: no
12:21:06 <vincenz> fasta: no?
12:21:09 <fasta> vincenz: NO
12:21:14 <vincenz> Hmm, odd
12:21:24 <vincenz> I googled and best I find is O(km) or O(Dm)
12:21:29 <vincenz> D = big delta
12:21:47 <nominolo> anyone know of a "spreadsheets-cell" library for haskell?  I think FRP is not quite appropriate for this, is it?
12:22:07 <ski> the point of 'forall s a. (STRef s a -> a) -> ST s (STRef s a)' would be that you don't have to initialize the reference to garbage, and the function argument can't read the reference, only place it into the structure somewhere
12:23:06 <fasta> ski: I didn't really get your even/odd argument, since I didn't read that paper, but I think the question should be answerable without me reading that paper.
12:24:07 <ski> fasta : i was just wondering whether returning a reference to the link wouldn't be better (maybe it wouldn't, i don't know)
12:24:58 <ski> (if you return a reference directly, then you don't need to 'mfix' over a pair, and you don't need to extract the wanted result from the pair)
12:26:05 <fasta> ski: but still use mfix nonetheless, right?
12:26:23 <ski> though, of course you could use 'liftM fst $ mfix \ ~(_,ref) -> do ...' if it's only syntax bothering you
12:26:29 <ski> yep
12:26:51 <fasta> ski: ok, with that first comment between parens I understand.
12:27:56 <ski> the "odd" style is primarily working directly with the "cell" type, in this case your links .. the "even" style is primarily working with references to "cells"
12:28:34 <araujo> good day
12:29:01 <ski> (so called because in the "even" style, there's the same number of references as cell constructors, while in the "odd" style, there's one less reference (at toplevel))
12:35:12 <fasta> ski: thanks
12:36:52 <syntaxfree> I just found a site with great mathematics lectures in video.
12:36:56 <syntaxfree> Most of them are in english.
12:37:06 <syntaxfree> http://strato.impa.br/
12:38:23 <chessguy> hey, really good discussion going on in haskell-cafe about a collaborative "haskell for dummies" type book
12:39:44 <nominolo> hm, is hIDE real or vaporware?
12:39:58 <chessguy> syntaxfree, that looks like some pretty advanced mathematics
12:41:24 <kyevan> Yar!
12:41:47 <Lemmih> nominolo: It's not usable if that's what you're asking.
12:41:58 <kyevan> yaht has my head spinning. And not even on haskell, on an exercise where I can't decipher what they want!
12:42:08 <nominolo> ok, but there's Real Work being done ..
12:42:46 <Lemmih> nominolo: Nope, noone's working on it anymore.
12:43:02 <nominolo> Lemmih: oh. why not?
12:43:08 <chessguy> kyevan, where?
12:43:11 <chessguy> @yar
12:43:21 <syntaxfree> chessguy: ah, yes, they're research lectures.
12:43:23 <kyevan> chessguy: Exercise 4.10
12:43:29 <chessguy> hmm, no bot
12:43:47 <gour> ndm: latest yhc does not build here
12:43:53 <gour> @where paste
12:43:57 <kyevan> nominolo: I think most people are using emacs, now....
12:43:59 <ndm> gour: paste the error and we'll see
12:44:06 <ndm> gour: scons depends might be required
12:44:21 <Lemmih> nominolo: There are lots of issues to work out. Designing a proper IDE isn't a well known topic.
12:44:27 <gour> @where paste
12:44:39 <kyevan> gour: Lambdabot seems to be dead.
12:45:01 <chessguy> hmmm.
12:45:14 <lisppaste2> gour pasted "nhc build" at http://paste.lisp.org/display/32034
12:45:29 <nominolo> Lemmih: ok, so it's no wasted work if i play around with a couple of ideas related to that :)
12:45:49 <jlouis> Lemmih: saw your 1GB leech yesterday. Congratz!
12:45:57 <ndm> gour: scons fullclean, scons depends, scons build - give that a whirl
12:46:14 <chessguy> @type foldl
12:46:19 <chessguy> oh right
12:46:19 <chessguy> lol
12:46:30 <ndm> gour: probably with a darcs pull first
12:46:47 <gour> ndm: i alread did pull before
12:46:54 <gour> ndm: something is new?
12:47:05 <Lemmih> jlouis: Thanks! It feels great to have the whole thing finally working.
12:47:21 <ndm> gour: no, no obvious reason it looks broken
12:47:35 <gour> ndm: let's see
12:48:12 <jlouis> Lemmih: now for some optimizations?
12:48:33 <jlouis> or is it reasonably fast?
12:48:45 <kyevan> Eh, whatever.
12:49:04 <chessguy> kyevan, they want foldTree :: (a -> b -> b) -> b -> BinaryTree a -> b
12:49:32 <kyevan> The closest I've vome is treeFold :: (a -> a -> a) -> a -> BinaryTree a -> a
12:49:46 <Lemmih> jlouis: It's using too much CPU. The memory consumption is pretty good, though.
12:49:58 <chessguy> kyevan, this is the signature for their solution
12:50:16 <kyevan> chessguy: Right, and that's the signature for my (partial) soulution.
12:50:20 <jlouis> Lemmih: see, now one is majorly glad the profiler can be enabled via +RTS :P
12:51:35 <chessguy> so you just need to generalize a little
12:52:04 * Lemmih records the patches.
12:52:37 <gour> @yhc
12:52:41 <gour> @where yhc
12:53:37 <kyevan> gour: Lambdabot isn't here
12:53:52 <gour> kyevan: it's in #haskell.hr :-)
12:54:00 <chessguy> gour, http://www.haskell.org/haskellwiki/Yhc
12:54:55 <kyevan> 14:47 -!- lambdabot: No such nick/channel
12:55:10 <kyevan> As far as I can tell, she isn't on freenode, period./
12:56:03 <kyevan> :/
12:56:05 <kyevan> Hmm.
12:56:42 <kyevan> Well, I can't just apply the function I'm given to apply to the folded left and right...
12:57:20 <kyevan> Since that's two values of type b, and the function I'm given takes an a and a b.
12:57:34 <kyevan> Hmm....
12:57:44 <gour> kyevan: lambda is enjoying in #haskell.hr ;)
12:58:10 <vininim> does "data Tree a = Leaf a | Branch a [Tree a]" make sense for a arbritary-ary tree who have data not only in leaf nodes? o_O
12:58:43 <xerox> vininim: you don't need the a in Branch I think
12:58:52 <Heffalump> what's the difference between Leaf a and Branch a [] ?
12:59:07 <xerox> vininim: http://darcs.haskell.org/~paolo/darcs/tao/ZipNtree.hs
12:59:42 <kyevan> Branch in mine takes a tree ("left"), a value, and another tree ("right").
12:59:44 <gour> chessguy: thanks. i was looking for yhc ml address
13:02:10 <chessguy> xerox, if you don't have the a there, you can only contain data on the leaves
13:02:51 <xerox> chessguy: isn't that equivalent to putting a (Leaf x) between the branches?
13:03:03 <chessguy> sure
13:03:11 <chessguy> err, no
13:03:25 <chessguy> you can't have a leaf in the middle of a tree
13:03:33 <monochrom> <3
13:03:56 <xerox> X [X [L 1, L 2], L 3, X [L 4, L 5]]
13:04:10 <xerox> (X being visual aid for branching.)
13:04:20 <chessguy> xerox, yeah but now you don't have any data except at the leaves
13:04:41 <chessguy> think of how you would usually draw a tree on paper
13:04:59 <vininim> and what would X [X [L 1, L2], L 3, L 4, L 5, X[ L 6, L 7]] supposed to mean?
13:05:02 <monochrom> ok, data at internal nodes, they're called keys not leaves.
13:05:16 <xerox> monochrom: ah, nice to know.
13:05:42 <chessguy> i think data Tree a = Leaf a | Branch a [Tree a] is a perfectly reasonable model
13:06:20 <Heffalump> I don't, I think it's redundant.
13:06:32 <chessguy> huh?
13:06:35 <Heffalump> Leaf a and Branch a [] both express the same thing, unless you ban Branch a []
13:06:40 <monochrom> If you place data in internal nodes, it is unusual to also place data in leaves.  There are programming inconveniences if you do.
13:07:17 <monochrom> data BST a = Null | Branch a (BST a) (BST a)   is more usual.
13:07:20 <chessguy> mmm, not in any applications i've seen
13:07:20 <xerox> that's why I usually do just use leaves.
13:07:31 <vininim> but Branch a is a "typing aid" for depth
13:07:32 <chessguy> e.g., take a game tree
13:07:37 <chessguy> every node represents a position
13:07:44 <chessguy> both internal nodes and leaves
13:07:53 <vininim> or every node represent a state in a minimax algorithm =D
13:08:48 <monochrom> Suppose you write a routine to dump the data.
13:09:09 <chessguy> ok
13:09:22 <monochrom> If data are into both branches and leaves, you repeat the same code in both cases.
13:09:27 <notsmack> chessguy: the leaves and the branches should be treated the same in that case, shouldn't they?
13:10:04 <monochrom> Then you start asking things like "is there a way to say 'if x matches either this pattern or that pattern'?" because you see repeated code.
13:10:26 <monochrom> But that is so wrong a thing to ask for.
13:10:33 <chessguy> inorder Leaf a = do {output a}; inorder t Branch left right = do {inorder; output a; inorder right}
13:11:07 <monochrom> The right way is to confine data to branches.  Leaves are null pointers, as per tradition.  Then you will never need code repetition or case unions.
13:11:18 <xerox> WriterT? :)
13:11:23 <monochrom> Yes, see the repeated "output a" there?
13:11:24 <chessguy> i really don't get it
13:11:30 <chessguy> sure
13:11:41 <monochrom> In general it's not going to be as simple as "output a".
13:11:52 <chessguy> fine, so abstract that to another function
13:11:57 <norpan> data at the branches is the roxxor
13:12:14 <norpan> the only sane way
13:12:29 <monochrom> That abstraction can be eliminated by the way I suggest.
13:12:35 <vininim> I think it's more sane to have leaf typified
13:12:51 <norpan> typified?
13:13:03 <vininim> not as a special case of branch
13:13:26 <chessguy> but the total number of nodes is going to explode if you add a leaf for every internal branch
13:13:30 <notsmack> vininim: but in this case leaf /is/ a special case of branch
13:13:52 <vininim> and is treated differently
13:14:11 <monochrom> Look, it is the same debate as the following.  data ListZero a = Nul | Cons a (ListZero a).  data ListOne = Single a | More a (ListOne a).
13:14:52 <xerox> !
13:15:58 * Botje goes quietly back to implementing tries in haskell
13:15:59 <norpan> well, unless you want a tree that have data only at leaves, then
13:16:10 <chessguy> i don't know, i've never seen a tree represented the way you're suggesting. it seems to me like it would make the number of nodes get way bigger
13:16:20 * vincenz implements Botje in haskell
13:17:01 <vininim> Seems to be a discussion of style. =p
13:17:04 <notsmack> who's saying a leaf at each node?
13:17:32 <jlouis> Botje: build them on data Trie a b = T (Maybe b) (Map a (Trie a b)) <-- might take some tweaking
13:17:35 <Botje> vincenz: it'll be hard. I'm highly imperative and legislative.
13:18:03 <chessguy> notsmack, if i'm understanding right, that's what xerox an monochrom are suggestiong
13:18:05 <jlouis> Then generalize the Map out into another variable c
13:18:07 <chessguy> *suggesting
13:18:24 <chessguy> mind you, they're much smarter than i am, but i still think their implementation is strange
13:18:40 <jlouis> Then you can make tries of tries
13:18:55 <Botje> jlouis: I was going for Trie a = Leaf | Branch [(a, Trie)]
13:19:02 * vincenz is monadic
13:19:07 <vincenz> Botje: wrong
13:19:24 <notsmack> chessguy: i think they just wanted the data stored in the branch nodes itself
13:19:27 <vincenz> Trie a = Leaf | Branch[(a, Trie *a*, Bool)]
13:19:34 <Botje> oh yeah.
13:19:49 <chessguy> notsmack, i don't think so, but i could be wrong
13:19:49 <Botje> I didn't parametrize it on my first try, actually
13:19:50 <vininim> your context is more similar to mine (minimax-search, data in branchs)
13:19:59 <jlouis> Isn't the Leaf superflous? It can be the empty list
13:20:08 <vincenz> yes
13:20:26 <jlouis> And your trie is a Set of elements then. Not a Map. Hope that is what you want
13:20:28 <vincenz> data Trie a = M.Map a (Trie a, Bool)
13:20:31 <chessguy> i think their suggestion is Tree a = Leaf a | Branch [Tree a]
13:20:38 <chessguy> as opposed to Tree a = Leaf a | Branch a [Tree a]
13:20:44 <vincenz> data Trie a = M.Map a (Trie a, Bool)
13:20:50 <vincenz> You guys keep forgetting about Bool
13:20:55 <xerox> chessguy: just fix the latter with Null instead of Leaf a.
13:20:59 <jlouis> vincenz: the Constructor :)
13:20:59 <vincenz> -!-
13:21:03 <vininim> hah
13:21:04 <vincenz> jlouis: no
13:21:09 <vincenz> jlouis: oh yesm like that
13:21:10 <vincenz> sorry
13:21:12 <vininim> did we just backtrack in our discussion? =)
13:21:22 <vincenz> vininim: it's the List monad
13:21:34 <notsmack> the 'a' on Leaf is your problem, you'll need separate code to access it
13:21:49 * vincenz peers at you all
13:21:52 <chessguy> vininim, i'd say it was more like a loop with a few barrel rolls
13:21:54 <vincenz> You people are forgetting subwords that are words
13:22:07 <jlouis> In general, if you can kill a variant in an algebraic datatype, your code is much more fluent.
13:22:28 <norpan> and you should kill your darlings
13:22:36 <vincenz> data Trie a = Trie (M.Map a [a])
13:22:44 <vincenz> (inefficient in space but ok)
13:22:48 <vincenz> whoops
13:22:51 <jlouis> haha
13:22:54 <vininim> bool o_O
13:22:55 <jlouis> Not recursive
13:22:55 <vincenz> data Trie a = Trie (M.Map a (Trie a, Maybe [a]))
13:23:07 <vincenz> that or
13:23:10 <vincenz> data Trie a = Trie (M.Map a (Trie a, Bool))
13:23:42 <lisppaste2> metaperl pasted "I need to add an instance declaration for (Show Season) ... how?" at http://paste.lisp.org/display/32039
13:24:57 <lisppaste2> jlouis annotated #32039 with "deriving show" at http://paste.lisp.org/display/32039#1
13:24:58 <lisppaste2> bobo annotated #32039 with "the clown" at http://paste.lisp.org/display/32039#2
13:26:01 <lisppaste2> vincenz annotated #32039 with "even better" at http://paste.lisp.org/display/32039#3
13:26:14 <vininim> o_O
13:26:57 <vincenz> of course that's only for Winter
13:27:08 <lisppaste2> metaperl annotated #32039 with "a season is actually depend on day, not just month" at http://paste.lisp.org/display/32039#4
13:27:55 <SlowByte> unless you live in Estonia, where you derive (CrappyWeather) for all seasons
13:28:08 * SlowByte peers outside
13:28:13 <kzm_> type Trie a = [(a,Trie a)] ?
13:28:26 <metaperl> I wrote a a season funciton, but clearly August is not Autumn, only late August... how would you make seasons a function of day of month
13:28:52 <lisppaste2> vincenz annotated #32039 with "nicer looking" at http://paste.lisp.org/display/32039#5
13:28:55 <int-e> season :: Month -> Day -> Season
13:28:59 <vincenz> kzm_: no
13:29:03 <vincenz> kzm_: for two reasons
13:29:16 <kzm_> efficiency?
13:29:20 <vincenz> no
13:29:22 <vincenz> incorrect
13:29:29 <vincenz> a) can't recursive without a data-cons
13:29:35 <vincenz> b) you're missing the necessary Bool
13:29:41 <vincenz> you guys keep looking at Tries like pure Trees
13:29:57 <vincenz> "wind" "windy" might both be part of a dictionary
13:30:03 <vincenz> so you need to indicate the end of word
13:30:39 <kzm_> True.  The textbooks do it with an extra character, but that's pretty unhaskellish.
13:31:10 <kzm_> OTOH, *my* tries don't care much about words.
13:31:24 <jlouis> type FixedTrie = Trie (Bool, Foo)
13:31:44 <jlouis> Might work with a lot of hammering
13:32:00 <vincenz> data Trie a b = Trie (M.Map a (Trie a, Maybe b))
13:32:01 <vincenz> that's ideal
13:32:23 <metaperl> vincenz - deriving Snow ... very cute :)
13:34:16 <vincenz> "I see you winding...grinding ... up on that pole.."
13:36:59 <shapr> @yow !
13:37:24 <vincenz> she's dead
13:37:51 <vincenz> it's a pity that enums dont autowarp
13:37:54 <vincenz> autowrap
13:38:05 <metaperl> vincenz - you mean cycle back to beginning?
13:38:08 <jlouis> @yow! shapr
13:38:13 <metaperl> @type cycle
13:38:13 <Masklinn> hello again
13:38:22 <metaperl> Masklinn - hi
13:38:32 <vincenz> metaperl: yes but with the .. syntax
13:38:32 <metaperl> there is a cycle function... it doesn't handle that?
13:38:39 <metaperl> oh
13:38:40 <vincenz> [Nov..Jan]
13:38:47 <metaperl> [ greater .. less ]
13:38:48 <metaperl> right
13:38:59 <metaperl> I have not shed any tears over it yet, but I can see your point :)
13:39:18 <chessguy> dons, wake up
13:40:01 * gour thinks "Poor dons...he always has to be alert taking care about that girl..."
13:41:08 <kzm_> gour ?
13:41:17 <Lemmih> ADEpt: Your conjure UI rocks, btw.
13:41:21 <gour> kzm_: yes?
13:41:46 <kzm_> Guess I missed the reference (your care about that girl comment).
13:42:02 <vincenz> ADEpt: show me?
13:42:09 <gour> kzm_: dons has to take care about lambda
13:42:20 <kzm_> *that* girl.
13:42:23 <vincenz> Lemmih: link?
13:42:29 <kzm_> I see. Thanks.
13:42:36 <kyevan> Continuation passing style seems weird, ugly, and notnice....
13:42:41 * gour gives permission to haskell users to use  lambda in #haskell.hr for a moderate donation :-)
13:43:38 <Lemmih> vincenz: http://martinus.homedns.org:3080/
13:44:20 <vincenz> gracias
13:44:24 <allbery_b> does that one speak Bosnian instead of English? :)
13:44:25 <vincenz> erm
13:44:26 <jlouis> kyevan: CPS has its uses. For instance it lets you write compilers easily if you do it right
13:44:27 <vincenz> Lemmih: no?
13:44:30 <kyevan> what is 'hr', anyway.
13:44:34 <vincenz> Lemmih: what sort of content is that
13:44:43 * kyevan doesn't recognise that language code
13:44:46 <kzm_> Hungary?
13:44:50 * allbery_b is probably confused
13:44:51 <gour> kyevan: Croatia (local Hrvatska)
13:44:55 <kzm_> Ah.
13:44:58 <allbery_b> ah, croatia.  right
13:45:07 <allbery_b> so it speaks Croatian :>
13:45:23 <kzm_> Was that added when Yugoslavia split up?
13:45:27 <Lemmih> vincenz: It's a http UI showing everything that's going on inside conjure (:
13:45:28 <gour> sort of...it can beat england in soccer ;)
13:45:32 <vincenz> Lemmih: oh
13:45:38 <vincenz> Lemmih: nasty
13:45:45 <Lemmih> vincenz: It's great.
13:45:58 <gour> kzm_: it became sort of 'independent', previously it was a part of yu
13:46:15 <kzm_> I like the www.hr domain :-)
13:46:17 <allbery_b> gour: these days, who can't? :)
13:46:21 <kzm_> Can you get gour@hr ?
13:46:23 <Lemmih> vincenz: It's not for the end users, though. (:
13:46:27 <allbery_b> (well, the US :)
13:46:32 <vincenz> Lemmih: Of course it is!
13:46:37 <kyevan> allbery_b: The US.
13:46:39 <vincenz> Lemmih: Just add some ajax and css
13:46:41 <kyevan> kzm_: proll'
13:46:46 <kyevan> kzm_: proll'y not.
13:46:51 * shapr yowrz
13:46:53 <kyevan> There's nothing special about "www."
13:46:56 <gour> kzm_: 1st time i visited that page
13:47:19 <kyevan> You could regester "www.com" if you wanted
13:47:24 <gour> kzm_: well, i need to explain a bit about gour@hr
13:47:25 <Lemmih> shapr: How's alex?
13:47:30 <kyevan> Except, someone already has it :P
13:47:48 <kyevan> I HIGHLY doubt there is an mx record on ht.
13:47:50 <kyevan> er
13:47:52 <kyevan> hr.
13:47:59 * vincenz pushes Lemmih to #oasis
13:48:05 <kzm_> There's an unused domain (.bt, I think) for bouvet island.
13:48:20 <gour> d'night
13:48:23 * SamB wonders if there is any reasonable support for character grid display in GTK?
13:48:40 <kzm_> I don't think it's in use, but it is adminstered by the .no domain.  I need a plausible reason to ahem.. borrow it. :-)
13:48:42 <kyevan> Damn. There actually IS
13:48:43 <kyevan> hr mail is handled by 10 alpha.carnet.hr.
13:49:12 <shapr> Lemmih: Haven't heard from him in the last few days, but I think he's doing fine.
13:49:24 <kyevan> so yes, he theoreticaly could.
13:49:48 <kyevan> if he knew the admin of alpha.carnet.hr well enough to bribe a name out of him :P
13:50:02 <kyevan> most automated checkers would reject it, though.
13:50:14 <kzm_> Where did you see that?  I don't get anything.
13:50:19 <Lemmih> shapr: He's not responding to my emails.
13:50:23 <shapr> I like Tony Finch's email address.
13:50:42 <shapr> Lemmih: If you sent it earlier than last thursday, that probably means he's hypefocussed on something.
13:50:49 <kyevan> kzm_: host kr.
13:51:45 <kyevan> (Technicaly there is a domain above the tlds we know. www.google.com./search?q=foo is leagal, and points to Google's search for foo, for instance)
13:52:05 <shapr> kyevan: how so?
13:52:05 <kyevan> also, yay for unix tools :)
13:52:19 <kyevan> shapr: the
13:52:25 <kyevan> shapr: the "." domain
13:52:32 <xerox> shapr, the DNS is hierarchycal
13:52:37 <shapr> That's not a tld though.
13:52:38 <xerox> @spell hierarchycal
13:52:39 <kyevan> The root which the various TLDs are under.
13:52:48 <shapr> Every *canonical* DNS name ends in a dot.
13:52:48 <kyevan> shapr: right
13:52:54 <kyevan> But it it's still there
13:53:13 <allbery_b> "hierarchical"
13:53:28 <shapr> Oh, I see what you mean. right!
13:53:31 <kyevan> it's the root the tlds are under.
13:53:48 <shapr> @paste
13:53:51 <allbery_b> <shapr> Every *canonical* DNS name ends in a dot.
13:54:00 <allbery_b> strictly speaking, you're forbidden to use such names
13:54:04 <shapr> Really?
13:54:18 <shapr> Tell me more!
13:54:23 <kyevan> allbery_b: You pretty much have to when refering to the TLDs themselves, thoug
13:54:36 <kyevan> A lot of utils get pissy
13:54:44 <allbery_b> nameservers use them internally, some programs let you use them for various hacky reasons, but technically a name ending in a dot is not "legal"
13:54:46 <kyevan> (It looks like host on this machine doesn't care)
13:55:53 <shapr> Tony Finch has the coolest email address ever: dot@dotat.at
13:56:34 <norpan> a friend of mine was reachable at .@se once
13:56:37 <norpan> that's short
13:57:11 <SlowByte> there was some nice study that showed that the majority of root name server queries came from misconfigure Windows machines :)
13:57:14 <xerox> shapr: ah!!
13:57:49 <kyevan> I'd rather have ASnowspeaderDestroyedMy@at
13:57:53 <road> :hoogle (Monad m) => m [a] -> [m a]
13:57:54 <xerox> real    100m7.244s  user    92m30.995s  sys     28m30.938s
13:57:57 <xerox> ghc-6.6
13:58:02 * xerox is happy
13:58:32 * kyevan murders CPS with fire
13:58:38 <kyevan> It doesn't make SENSEEEEEEee/
13:58:43 <chessguy> CPS?
13:58:50 <road> ?hoogle (Monad m) => m [a] -> [m a]
13:58:51 <bd_> Continuation Passing Style?
13:58:52 <kyevan> I mean, it's not bad on a conceptual level, but...
13:59:00 <chessguy> computationally prurient symbols?
13:59:01 <kyevan> Continu... what bd_ said
13:59:02 <road> ?lambdabot hoogle (Monad m) => m [a] -> [m a]
13:59:08 <xerox> kyevan: you don't really need to do the CPS exercises of yaht
13:59:13 <SlowByte> CPS is just your processor doing IP++ ;)
13:59:20 <kyevan> road: LambdaBot is dead.
13:59:28 <kyevan> Someone needs to do CPR on her
13:59:33 <chessguy> haha
13:59:44 <bd_> I never truly understood monads until I implemented ContT :P
13:59:51 <SamB> kyevan: I suppose you were hoping to do it?
13:59:57 <SlowByte> or IP = x, less often
14:00:31 <kyevan> SamB: I think that's dons' job, isn't it?
14:00:55 <SamB> sort of ;-)
14:01:00 <allbery_b> lambdabot.codersbase.com, folks :)
14:01:46 <vincenz> allbery_b: it's not the same *sniff*
14:01:58 <vincenz> it's like a sterilized version of our beloved girl
14:02:22 <allbery_b> better than nothing until dons wakes up, though :)
14:02:36 <kyevan> No it's not.
14:02:52 <SlowByte> I think the tranformation from CPS to machine code is instructive... there's quite a nice correspondence
14:03:23 <kyevan> Someone rebuild Lambdabot on their box as Lamdbabot, quick!
14:05:00 <kyevan> but that web interface makes me wonder if I could hack together something with it and yubnub....
14:05:08 <shapr> Lemmih: When did you send him an email last?
14:05:34 <SamB> oh, actually missing this time?
14:05:59 <kyevan> Hmm
14:06:48 <kyevan> ohyay, it's get.
14:09:43 <kyevan> hmm...
14:09:48 <kyevan> \ or \bot?
14:09:54 <kyevan> \bot
14:10:16 <kyevan> \ should be saved for one of the uberuseful hacks people build for yubnub :)
14:10:36 <jlouis> kyevan: in CPS you extend every function to an extra parameter, normally called k. k represents "the rest of the program" and the last thing a function does is to call <<k res>> where res is the result of the function. It makes the imperative nature of your program explicit in the k
14:10:53 <lisppaste2> metaperl annotated #32039 with "implementing show for a data type" at http://paste.lisp.org/display/32039#6
14:11:09 <vincenz> metaperl: incorrect
14:11:27 <metaperl> vincenz - so what should I do?
14:11:31 <kyevan> jlouis: So basicly, it's a way to make a functional program imperitive with an ugly look?
14:11:51 <vincenz> just a sec
14:12:10 <jlouis> kyevan: it can be used for that yes. The important thing is that the continuation of a function is made explicit. It makes some optimizations vastly easier to apply while compiling
14:12:44 <shapr> It's also called "green threads" or non-preemptive multitasking in some cases.
14:12:54 <fabiim> can someone point me out on something to read about read/write files in haskell?
14:13:15 <jlouis> CPS is closely related with SSA-form normally seen in compilers for imperative languages
14:13:23 <bd_> kyevan: Note that all this ugly continuation stuff can be hidden in a monad, of course :)
14:13:25 <jlouis> (And the MLton SML compiler by the way)
14:13:35 <lisppaste2> vincenz annotated #32039 with "here" at http://paste.lisp.org/display/32039#7
14:13:45 <metaperl> fabiim - http://www.zvon.org/other/haskell/Outputprelude/readFile_f.html
14:13:59 <fabiim> metaperl: thanks =)
14:13:59 <vincenz> ack
14:14:01 <vincenz> remove the first '
14:15:07 <metaperl> vincenz - ok ,thanks
14:15:46 <malsyned> so I'm trying to learn haskell, and I've typed what ought to be a simple function that emulates (!!), but it's crashing on me and I can't tell why.
14:16:14 <norpan> crashing?
14:16:21 <metaperl> malsyned - paste at http://paste.Lisp.Org/new/haskell
14:16:22 <malsyned> throwing an exception
14:17:40 <norpan> you are sooo non-descriptive, what exception, what program, how do you expect anyone to be able to comment on information like that
14:17:50 <kyevan> yay.
14:17:51 <malsyned> woah.  I take it back.  It throws an exception when I define it on the GHCi command line, but not if I put the definition in a file and then load it into GHCi.
14:18:04 <malsyned> norpan: I'm getting a paste together to be more descriptive.  hoas.
14:18:21 <monochrom> The exception throw is evidently "the list is empty!"  You are evidently forgetting to handle that case.
14:18:29 <kyevan> Any other yubnub users: \bot now exists. Used alone, it goes to the ajax lambdabot page, with arguments, those args are used as a command to her!
14:18:40 <norpan> it's probably that
14:20:55 <malsyned> paste.lisp.org keeps timing out when I try to submit.  I'll try again in a second.
14:21:32 <malsyned> To be fair, yes, I did forget the case of the list being empty, but I don't think that's why it's throwing an exception.  (the exception is "Non-exhaustive patterns in function kth")
14:22:01 <mwc> that exception is saying it couldn't match the data to your patterns
14:22:07 <mwc> maybe because the empty list wasn't a patter?
14:22:24 <malsyned> OK, I'm just going to paste this into the channel.  it's a one liner.
14:22:50 <metaperl> vincenz - your code is throwing a parse/indentation error - http://paste.lisp.org/display/32039#7
14:22:51 <kyevan> Is continuation passing style ever really that important?
14:23:01 <shapr> yes
14:23:29 <vincenz> metaperl: did you remove the first '
14:23:30 <vincenz> on the second line
14:23:37 <kyevan> malsyned: I thought that was "Non-exhaustive patterns in function kthxbai" for a sec
14:23:47 <malsyned> OK, now the code that wasn't working suddenly started.  all I did was restart ghci.  Must be some weird state thing I'm running into.  Never mind guys, thanks.
14:23:54 <kyevan> That would be weird, if ghci (or hugs) started talking like that :P
14:24:14 <lisppaste2> vincenz  annotated #32039 with "typo fixed" at http://paste.lisp.org/display/32039#8
14:24:20 <lisppaste2> malsyned pasted "simple (!!)-like function" at http://paste.lisp.org/display/32046
14:24:51 <lisppaste2> metaperl annotated #32039 with "vincenz, it is still throwing parse error after removing '" at http://paste.lisp.org/display/32039#9
14:24:53 <malsyned> and now the paste goes through.  anyway, the first half is what /was/ happening, but when I try to reproduce it, it doesn't fail anymore.
14:25:25 <vincenz> metaperl: oh right
14:25:34 <norpan> malsyned: because let binding is not the same as function definition
14:25:35 <vincenz> showsPrec _ NilT = ("Nil" ++)
14:25:45 <vincenz> slices need to be parenthesized
14:26:00 <mwc> > let kth lls k = case (k,lls) of {(0,l:_) -> l; (k,_:ls) -> kth ls (k-1)} in kth [] 3
14:26:25 <monochrom> If you need two equations to define a function, e.g., "f 0 = blah" and "f n = bah", and you wonder how to combine that into one line so as to please ghci, ...
14:26:28 <mwc> malsyned, i suspect that's where your program was coming from. Pattern failures generally mean you didn't concsider each case
14:26:40 <monochrom> it is: let { f 0 = blah; f n = bah }
14:26:49 * mwc wonders where the lambdabot is.
14:26:57 <vincenz> mwc: rip
14:27:02 <malsyned> monochrom: that's what I did.
14:27:07 <metaperl> vincenz - should I remove deriving (Show) from the data declaration if I want to use your instance code?
14:27:14 <vincenz> metaperl: yes
14:27:17 <metaperl> ok
14:27:21 <mwc> vincenz, what? Somebody murdered lambdabot?
14:27:26 <vincenz> mwc: netsplit
14:27:28 <metaperl> lol
14:27:37 <metaperl> C# did it
14:27:49 <metaperl> PHP did it
14:27:50 <mwc> Damn their jealous souls!
14:27:53 <metaperl> phpbot
14:28:18 <monochrom> kth [] 10 will not find a matching pattern.
14:28:46 <monochrom> But it is up to you what you want.  You can even ignore it.
14:29:42 <metaperl> vincenz - it worked. thanks. see you later
14:29:51 <shahn_> sorry, how does the let statement inside monadic do-statements with curly brackets work? (simple example, anywhere?)
14:30:03 <monochrom> ghc (the compiler) will not bug you on these things unless you give an option to order it to be anal.
14:30:15 <malsyned> monochrom: yeah, I realize I didn't fill in sufficient patterns.  I tried a version of it that used Maybe to return Nothing when I was getting to [] before hitting the kth element, and it was returning Nothing for the call (kth [2, 3, 4, 5] 1).
14:30:31 <vincenz> metaperl: don't forget to ++ me when lambdabot reascends
14:30:34 <malsyned> but I went and rebooted the interpreter and now I can't reproduce the problem.
14:30:38 * vincenz is a karma-whore
14:30:38 <metaperl> OK!
14:30:41 <metaperl> lol
14:30:43 <_magus_> hmmm, this is off-topic, but does anyone know a good channel to ask about ptrace on Linux?
14:31:06 <kyevan> _magus_: On freenode? If you find one, tell me!
14:31:21 <kyevan> All the Linux-related channels seem to be not that nice :(
14:31:24 <SamB> ... maybe ##c?
14:31:43 <_magus_> kyevan, hmm, this doesn't sound good :(
14:31:45 * kyevan wonders if ##c# is a valid channel name.
14:32:04 <SamB> the channel is called ##csharp, iirc
14:32:21 <kyevan> SamB: Oh.
14:32:23 <vincenz> it should be called ##cdull
14:32:35 <kyevan> vincenz: ##cflat
14:32:38 <kzm_> ##cblunt?
14:32:41 <monochrom> #, ##, and ### are valid channel names too!
14:32:44 <Pseudonym> Or ##cpointless
14:32:50 <kyevan> No, cdull
14:33:00 <bd_> ##cps?
14:33:02 <kyevan> Since sharp is a reference to music, not cutting ability.
14:33:22 <vincenz> Heh
14:33:27 <vincenz> ./j ############################
14:33:30 <malsyned> hey, speaking of C#, I saw a website (C)2004 that was claiming to be where an H# compiler would be released "RSN".  Is that a dead project, or just a slow one?
14:33:32 <shapr> On the other hand, C sharp is also D flat.
14:33:39 <shapr> So I always called it De Flat Language.
14:33:56 <kzm_> There already is a D-flat.  Dr Dobbs Journal library project thingy.
14:34:02 <mwc> H#? Is that like Haskell hosted on .NET?
14:34:05 <kzm_> For C++, IIRC.
14:34:16 <monochrom> C sharp was not D flat until around the time of Bach.
14:34:17 <_magus_> shapr, IIRC csharp isn't dflat, at least not in music
14:34:17 <malsyned> C# isn't Db if you play a fretless instrument :-P
14:34:18 <kyevan> mwc: Yes, that would be.
14:34:28 <_magus_> ah, monochrom is the man it seems
14:34:31 <shapr> _magus_: Ã¤r du sÃ¤kert?
14:34:41 <mwc> I read somewhere, probably #haskell, that .NET and the JVM were really wretched for hosting functional languages
14:34:45 <kyevan> malsyned: It is if you do vocal music, though
14:34:47 <kzm_> One thing I'd like to see in the language shootout (or similar places) is edit distance/alignment problems.
14:34:51 <jlouis> malsyned: nope ;) (I am a trombonist ;)
14:35:06 <monochrom> Of course monochrom is the man.  But no one listens to him ever.
14:35:15 <kyevan> mwc: They're not that good for hosting imperetive languages, either.
14:35:15 <kzm_> They tend to get bogged down in indexing, but I think they can be expressed nicely and functionally.
14:35:28 <_magus_> shapr, inte helt sÃ¤ker, men hyfsat... de rÃ¥kar lÃ¥ta vÃ¤ldigt like pÃ¥ de flesta instrument, och ha samma grepp osv, men inte samme :)
14:35:32 <monochrom> Sometimes they even put words into his mouth.
14:35:48 <malsyned> jlouis: well, a trombone doesn't have frets.  I don't even know where you'd put them.  it could click like a mouse wheel when you passed notes, I guess.
14:36:02 <SamB> malsyned: heh
14:36:04 <shapr> _magus_: Okej, om du sÃ¤ger...
14:36:15 <SamB> malsyned: wouldn't that mess up the slides?
14:36:40 <_magus_> shapr, haha, verkar som om monochrom kan vara bÃ¤ttre insatt
14:37:10 * _magus_ off to ##c to find out the dark secrets of ptrace
14:39:13 <jlouis> malsyned: the slide is just that. You just know where to place it. It lets you get notes exactly
14:40:05 <monochrom> analog scale instruments :)
14:40:44 <monochrom> You can play a Cauchy sequence on these things.  Very profound.
14:41:05 <cjeris> (voltage controlled oscillator)++
14:41:31 <monochrom> neato
14:42:13 <malsyned> jlouis: right.
14:45:02 <jlouis> so in some sense, its fretless
14:46:45 * shapr frets
14:47:00 * Pseudonym capos
14:47:15 <Pseudonym> I'm a cellist.  We don't fret.
14:57:55 <therp> I hate proofreading my papers
14:58:01 <therp> this is so boring.
14:58:36 <glguy> i always skipped that step
14:58:46 <glguy> in english or history classes
14:58:50 <SamB_XP> I can't proofread my own stuff
15:01:06 <therp> sambxp: what's your alternative?
15:01:41 <kosmikus> therp: what's it about? you could let #haskell proofread the paper ...
15:01:46 <xerox> minions
15:02:33 <therp> kosmikus: It's about Liskell, my hybrid language of Haskell and Lisp. interested? :)
15:02:55 <kosmikus> how many pages?
15:03:08 <vininim> omg, it renders!
15:03:21 <therp> 16
15:03:27 <vininim> (ugly, and wrong, but it works (tm))
15:03:39 <kosmikus> therp: llncs, I hope. but yeah, I'm interested.
15:04:35 <therp> kosmikus: no, memoir class.
15:04:56 <kosmikus> not too bad either
15:06:39 <vininim> wooray for honpengl
15:06:45 <vininim> and hopengl too
15:07:34 <xerox> vininim: what did you render?
15:08:18 <vininim> two squares of different colours, that should look like a match =p
15:17:05 <xerox> vininim: I've plotted sin, let's party :)
15:17:14 <vininim> =D
15:17:32 <vininim> after this is done maybe, wich might take the whole night
15:17:48 <Pseudonym> I've only plotted three of the seven deadly sins.
15:18:08 <xerox> Greets P.
15:18:21 <Pseudonym> So we can't quite party yet.
15:19:47 <Pseudonym> Actually, is it a coincidence that two of the three "programmer virtues" of Larry Wall are also deadly sins?
15:20:26 <xerox> Isn't he a very religious person?
15:20:52 <Pseudonym> Yes.  Though he's not what most people would think of as "very religious".
15:20:58 <Pseudonym> His religion is very postmodern.
15:21:34 <Pseudonym> When most people think "very religious", they think of a lot of things that Larry Wall is not.
15:22:10 <xerox> I think _|_ is the only thing that remains postmodern as the time goes on.
15:22:10 <Excedrin> wouldn't it be easier to just say no?
15:22:29 <xerox> G'nite.
15:22:47 <Pseudonym> Excedrin: No, it wouldn't.  Even "no" is complicated when you're talking philosophy.
15:27:15 <Philippa_> it's almost certainly not a coincidence
15:27:32 <glguy> Are scoped type variables new to GHC 6.6?
15:28:26 <Igloo> No, but the details have changed
15:36:07 <glguy> Suppose I wanted to explicitly type this statement:
15:36:11 <glguy> forever :: Monad m => m a -> m b
15:36:11 <glguy> forever x = aux  where
15:36:11 <glguy> --  aux :: What goes here? aux = x >> aux
15:36:26 <glguy> and suppose that the last two lines weren't merged into one
15:36:28 <sorear> ?let forever x = x >> forever x
15:37:00 <glguy> what is the type of aux
15:37:14 <LoganCapaldo_> Is there anything fundamentally wrong with newtype Stack a = [a] ?
15:37:19 <glguy> Visual Haskell says: aux :: forall b. mb
15:37:21 <glguy> m b
15:37:36 <glguy> but can aux be explicitly typed?
15:37:50 <kpreid> LoganCapaldo_: no
15:37:53 <bd_> glguy: m () works
15:38:10 <sorear> m () is not the Most General Type.
15:38:14 <LoganCapaldo_> Hmm, then I guess I have a typo :)
15:38:40 <sorear> LC_ : should be newtype Stack a = Stack [a]
15:38:43 <kpreid> LoganCapaldo_: Oh, wait, there is. No constructor.
15:38:58 <LoganCapaldo_> ah
15:39:11 <sorear> type Stack a = [a] works, but newtypes and datas need a name
15:39:17 <bd_> :t \m -> let forever = m >> forever in forever
15:39:34 <kpreid> LoganCapaldo_: are you specifically wanting a list, or will any simple stack do?
15:39:34 <sorear> lambdabot's not here right now.
15:39:44 <kpreid> Er, oh, stack, not queue, never mind.
15:39:47 <lisppaste2> glguy pasted "Can you explicitly type this?" at http://paste.lisp.org/display/32060
15:40:15 <bd_> sorear: aw :/
15:40:41 <sorear> glguy: No.  That *cannot* be explicitly typed.
15:40:52 <glguy> ok, cool, that makes me feel better :)
15:41:03 <sorear> glguy: Look for 'scoped type variables' in the GHC docs
15:41:09 <glguy> kk
15:41:17 <sorear> glguy: (a GHC extension needed to type that)
15:41:37 <glguy> are scoped type variables expected for haskell'?
15:41:37 <LoganCapaldo_> Ok next exciting question
15:41:55 <LoganCapaldo_> what's wrong with instance (Monad) Stack ?
15:42:18 * LoganCapaldo_ is trying to embed "forth" as a monad
15:42:21 <bd_> LoganCapaldo_: What are the semantics of that?
15:42:23 <bd_> ohh
15:42:34 <glguy> instance Monad (Stack a) where
15:42:34 <bd_> You can just make a State monad around a stack.
15:42:59 <glguy> State MyState Stack
15:43:04 <kpreid> "instance Monad Stack" should be fine, but you more likely want a state monad
15:43:27 <LoganCapaldo_> It's giving me kind errors
15:43:32 <glguy> to be a monad, doesn't Stack have to have kind *->*
15:43:43 <kpreid> yes
15:44:03 <LoganCapaldo_> nvm
15:44:10 <LoganCapaldo_> instance Monad Stack works
15:44:14 <kpreid> LoganCapaldo_: you can load just your newtype, then ask ghc for its kind
15:44:22 <kpreid> but note that instance Monad Stack isn't forth
15:44:33 <kpreid> it's nondeterminism or something broken
15:44:38 <LoganCapaldo_> Now I've reached the next step where I discover that my bind is broken :)
15:44:46 <kpreid> use the state monad
15:44:54 <LoganCapaldo_> yeah
15:45:03 <LoganCapaldo_> I was thinking about that earlier
15:45:03 <glguy> State Stack () --?
15:45:10 <glguy> what does a forth program return?
15:45:26 <shapr> glguy: An operating system?
15:45:30 <LoganCapaldo_> lol
15:45:34 <glguy> =/
15:45:36 <shapr> Maybe I've used too much Sun hardware in my time :-)
15:45:49 <glguy> wouldn't it be: State Stack ProgramResult ?
15:46:00 <kpreid> LoganCapaldo_: you *might* find this interesting: http://kpreid.livejournal.com/7351.html
15:46:03 <shapr> Hey, did you hear that Sun open sourced their Forth bootloader code?
15:46:42 <glguy> I only know of forth as an RPN language
15:46:44 <LoganCapaldo_> kpreid, you are right, I do find that interesting :)
15:46:45 <glguy> (never programmed in it)
15:46:58 <LoganCapaldo_> thanks
15:47:04 <shapr> I attest that kpreid is an interesting person.
15:49:37 <Pseudonym> Hey, now here's an idea.
15:49:47 <Pseudonym> A web-of-interest like the PGP web of trust.
15:49:56 <shapr> I have one of my own already.
15:50:01 <shapr> But it's not distributed.
16:01:40 <dons> moin
16:01:46 <dons> ?users
16:02:04 <LoganCapaldo_> Oh yeah, now I remember why I wasn't gonna use State. Or why rather I didn't want to
16:02:07 <SamB_XP> dons: you need a lambdabot to do that, silly!
16:02:11 <sorear> dons: nice try.
16:02:14 <LoganCapaldo_> I wanted return to be push
16:02:27 <dons> no bot?
16:02:50 <sorear> /whois lambdabot ...
16:02:51 <dons> oh, hmm. is my machine down!
16:03:03 <SamB_XP> hahaha
16:03:09 <LoganCapaldo_> and write things like + as add = do { x <- stack; y <- stack; return $ x + y }
16:03:58 <sorear> LC_: interesting idea...
16:04:00 <LoganCapaldo_> I guess I can wrap state in another monad to get that?
16:04:03 <kpreid> LoganCapaldo_: stack = x <- get; modify tail; x
16:04:07 <kpreid> LoganCapaldo_: yes. use a newtype
16:04:13 <psnl> shapr: that would be cool
16:04:21 <kpreid> newtype Forth a = Forth (State Stack a)
16:04:28 <LoganCapaldo_> heh
16:04:31 <sorear> ?hello
16:04:39 <LoganCapaldo_> I'm gonna have to cogitate on this
16:04:43 <LoganCapaldo_> thanks for all the input
16:05:01 <lambdabot> Maybe you meant: help hylo tell
16:05:20 <lambdabot> I'm back, baby!
16:05:29 <dons> ?uptime
16:05:29 <lambdabot> uptime: 1m 26s, longest uptime: 9d 2h 23m 6s
16:05:32 <thermoplyae> :)
16:05:53 <thermoplyae> I'd like to think lambdabot was making a joke at my connection's expense
16:06:03 <dons> mm, my other bot 10:58  lambdabot> uptime: 1m 10d 22h 28m 47s
16:09:55 <mwc> http://shootout.alioth.debian.org/gp4/benchmark.php?test=fasta&lang=ghc&id=0 Is this something one could rewrite with FPS or ByeString for better performance?
16:09:57 <lambdabot> Title: fasta Haskell GHC program | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer L ..., http://tinyurl.com/y4y8z8
16:10:06 <mwc> Something I might try after exams next week
16:10:40 <dons> sjanssen: already submitted a better one, I think.
16:10:45 <dylan> hmm, are IORefs safe inside a signal handler?
16:10:48 <dons> just waiting for ghc 6.6 to get into gentoo
16:10:58 <dons> dylan: I'd use MVars
16:11:08 <dylan> dons: not TVars?
16:11:10 <SamB_XP> does anyone know how to implement something that looks a bit like a terminal in gtk2hs?
16:11:12 <mq_mattr> dons: you use gentoo?
16:11:32 <dons> mq_mattr: nope
16:11:45 <mwc> dons, was that to me?
16:11:59 <dylan> I think dons uses openbsd, based on what lambdabot says.
16:12:01 <dons> mwc, yes. sorry
16:12:18 <SamB> in particular, I want a rectangular text area with fixt-width characters, cursor-positioning, and overwriting
16:12:27 <mwc> no probs. It was killing the haskell score when I was proselytizing haskell a coupla minutes ago
16:12:30 <mq_mattr> dons: openbsd, on a thinkpad - how easy is it?
16:12:36 <sorear> SamB: almost
16:12:42 <SamB> sorear: almost?
16:12:51 <dons> mwc, http://haskell.org/haskellwiki/Shootout/Fasta
16:12:53 <lambdabot> Title: Shootout/Fasta - HaskellWiki
16:13:03 <sorear> SamB: I implemented a terminal in GLUT for my life program
16:13:04 <dons> mq_mattr: easy. most of the openbsd kernel devs use thinkpads, so it all just works
16:13:30 <mwc> Does that include the lenovo stuff now?
16:13:33 <SamB> I could probably use zvt, but it looks like it uses escape codes!
16:13:36 <mq_mattr> dons: sweet, how about keeping up to date with ghc?  This is the major sticking point for me on most sytems
16:13:36 <SamB> which is rather icky.
16:13:45 <mq_mattr> dons: including my mac
16:14:02 <dons> mq_mattr: right, you tend to have to build from darcs yourself
16:14:26 <mq_mattr> dons: but as long as that goes smoothly most times ......
16:14:31 <sorear> SamB: I'd been planning on porting HsLife (includeing the terminal) to Gtk2HS
16:14:46 <mq_mattr> I have to admit, I am only *able* to build from scratch.
16:15:00 <mq_mattr> when something goes wrong, I can only fix it about half the time.
16:15:45 * sorear is now resurrecting hsLife (warning: in my history as a programmer this is pre-Darcs, pre-Cabal code)
16:16:34 <mwc> it looks to me like they fixed a leak in Non Leaking Entry related to the PRNG... should that change me merged onto the first entry? The one using FPS
16:17:05 <mwc> s/FPS/BS
16:17:44 <SamB> http://www.gnelson.demon.co.uk/zspec/sect08.html#seven talks about what I want (it is called the "upper window")
16:17:45 <dons> mwc, maybe. freel free to grab the code on the wiki and improve it
16:18:08 <mwc> sounds like a projcet then :)
16:20:16 <SamB> actually, that doesn't describe it very well...
16:23:34 <SamB> anyway, basically I want a character matrix widget ;-)
16:23:44 <sorear> I've figured out how to use mkcabal.  The logic is blissfully simple;  the quoting requirements were not...
16:26:57 <AStorm> Sorry for asking stupid questions, but here it comes.
16:27:10 <AStorm> How does one use FFIs #enum?
16:27:23 <SamB> anyway, without one my Z-machine interpreter will not display the upper window, and so you can't see the status line *or* navigate menus...
16:27:24 <AStorm> The first argument is a type or class, the second a constructor.
16:27:42 <AStorm> Do I have to create my own type for it using newtype?
16:27:58 <dibblego> I want a formal proof that "software" cannot be detached from referential transparency - which academic has produced the basic premises then formulated the logical proof?
16:28:16 <allbery_b> look for the syslog package for haskell, it has an example of using #enum to export the log facilities
16:28:26 <AStorm> Let's see :>
16:28:28 <SamB> dibblego: wth?
16:28:38 <dibblego> SamB, surely someone has produced it
16:28:56 <SamB> I don't understand what you want proved!
16:29:16 <dibblego> that referential transparency is an inherent propery of all software
16:29:23 <SamB> is it now?
16:29:39 <dibblego> I believe so and have done for a long time - still trying to prove otherwise
16:29:45 <SamB> what about this .COM file here that will reboot your computer?
16:29:57 <AStorm> Isn't that Syslog in MissingH?
16:30:16 <dibblego> that steps outside of "software"
16:30:17 <SamB> AStorm: dude, you missed the announcements?
16:30:28 <SamB> dibblego: I don't believe you
16:30:33 <LoganCapaldo_> SamB, every function takes an implicit parameter, the current time :)
16:30:39 <dibblego> SamB, then find me that academic! :)
16:30:40 <AStorm> SamB, uh?
16:30:45 <mq_mattr> dibblego: any software that takes input from user must include *world* in its state to achieve referential transparacny
16:30:47 <LoganCapaldo_> therefore everything is referentially transparent! QED
16:30:47 <dibblego> LoganCapaldo_, agreed! LoganCapaldo++
16:30:51 <SamB> AStorm: they split it off
16:30:55 <dibblego> the axis of time is the only mutating dimension!
16:31:13 <AStorm> Hmm, my package system doesn't have a separate syslog haskell package. Which is weird.
16:31:16 <allbery_b> it was separate when I grabbed it sometime earlier this year
16:31:29 <dibblego> mq_mattr, not necessarily, the universe of discourse need not be that large, it can be a subset
16:31:43 <mq_mattr> dibblego: but it must include me
16:31:44 <SamB> AStorm: oh, the announcement was only a few days ago
16:31:55 <mq_mattr> dibblego: since I am the varying factor
16:32:06 <dibblego> mq_mattr, it must include "the standard input stream"
16:32:19 <AStorm> SamB, is that hslogger?
16:32:23 <mq_mattr> dibblego: it must include *me* since it is my state that dictates the output
16:32:23 <sorear> hehehe, I just chmodded +x my .cabal instead of my Setup.lhs
16:32:35 <SamB> AStorm: yeah
16:32:44 <LoganCapaldo_> ./.cabal
16:32:46 <dibblego> mq_mattr, it needn't include you
16:32:59 <mq_mattr> dibblego: if a different user (or a user in a different mood) sits in from the the same input stream, you get different results
16:33:03 <dibblego> for the purposes of the software
16:33:19 <AStorm> If there's anyone taking care of Gentoo Haskell overlay, please add hslogging and newer missingh.
16:33:20 <dibblego> no, if a different user produces the same input stream, the software doesn't care
16:33:29 <AStorm> *around here
16:33:33 <dibblego> *something else* might care though
16:33:36 <mq_mattr> dibblego: to get referential transparancy, the same inputs need to give the same outputs right?
16:33:36 <SamB> dibblego: what if that other user types faster?
16:33:48 <dibblego> SamB, then it is a different input stream
16:33:53 <dibblego> mq_mattr, sure
16:34:05 <SamB> dibblego: good luck getting the same input stream twice!
16:34:14 <mq_mattr> dibblego: you are just expanding *input stream* to include all external modifications
16:34:21 <SamB> also, good luck excluding the user from the input stream!
16:34:30 <mq_mattr> dibblego: you are renaming *world* to *input stream*
16:34:37 <dibblego> mq_mattr, fine then, we agree
16:34:56 <SamB> dibblego: can we also agree to call you crazy?
16:35:02 <AStorm> dibblego, but if you're using certain monads... time is indeed a parameter. E.g. Random
16:35:03 <mq_mattr> dibblego: but you cannot inlclude *world* in your parameters
16:35:28 <AStorm> There are inputs (file, text, others, maybe time) and outputs.
16:35:56 <SamB> that sounds an awful lot like pre-monadic Haskell, for some reason!
16:36:19 <dibblego> SamB, I enjoy being called crazy, but only a well-stated illogical premise of the accuser :)
16:36:31 <mq_mattr> dibblgo: instead of showing your initial assertion (that referential transparency is an inherent propery of all software) you have shown that all software can be cast as referentially transparent, for which the proof is just the existence of Haskell
16:36:31 <dibblego> yes, we agreed
16:36:46 <dibblego> mq_mattr, yes I agree entirely
16:36:52 <mq_mattr> yay!
16:36:55 <mq_mattr> that was fun
16:37:04 <dibblego> perhaps I didn't word it correctly to start off with
16:37:08 <SamB> we have also rendered referential transparency meaningless!
16:37:19 <AStorm> There is no explicit time parameter - if the program doesn't depend on time and has a many to one relation between inputs and output(s), it is referentially transparent.
16:37:21 <mq_mattr> samB: you lost me
16:37:24 <dibblego> well, while the bounds of our universe are unknown at least
16:37:56 <SamB> AStorm: what about a 0-to-1 relation!
16:38:11 <AStorm> No input -> some output? If the output is predictable, then well :P
16:38:16 <AStorm> I mean constant.
16:38:46 <dons> ?pl \l r -> (l == ' ') == (r == ' ')
16:38:46 <lambdabot> (. (' ' ==)) . (==) . (' ' ==)
16:38:54 <AStorm> You want to present a program as a function of multiple arguments for it to be referentially transparent.
16:39:14 <allbery_b> hm... :)
16:39:43 <AStorm> And it must be a function, that is one to one mapping.
16:39:53 <AStorm> (but of multiple arguments to multiple outputs)
16:42:35 <sorear> dons: wasn't that the function of the `on` combinator?
16:42:38 <sorear> :t on
16:42:39 <lambdabot> Not in scope: `on'
16:42:51 <LoganCapaldo_> :t +
16:42:52 <lambdabot> parse error on input `+'
16:42:56 <sorear> :t (+)
16:42:57 <lambdabot> forall a. (Num a) => a -> a -> a
16:43:01 <LoganCapaldo_> ;)
16:43:06 <sorear> :t Data.Function.on
16:43:07 <lambdabot> Couldn't find qualified module.
16:43:43 <sorear> what, lambdabot isn't using base-2.1? :)
16:43:57 <LoganCapaldo_> @hoogle Data.Function.on
16:43:58 <lambdabot> No matches, try a more general search
16:44:02 <LoganCapaldo_> @hoogle on
16:44:02 <lambdabot> Test.QuickCheck.oneof :: [Gen a] -> Gen a
16:44:02 <lambdabot> System.Console.Readline.onNewLine :: IO ()
16:44:02 <lambdabot> Text.ParserCombinators.Parsec.Char.oneOf :: [Char] -> CharParser st Char
16:44:08 <LoganCapaldo_> ah well
16:44:29 <sorear> Data.Function.on is in my ghci.  My ghci is compiled from the ghc development darcs.
16:44:40 <sorear> IIRC it's not even in 6.6.
16:44:53 <LoganCapaldo_> I don't even have that module :)
16:44:58 <LoganCapaldo_> much less the function
16:45:03 * LoganCapaldo_ is totally uncool
16:46:26 <dons> sooorlooks like it
16:46:29 <dons> sorear:
16:48:31 <sorear> anyways: Data.Function.on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
16:48:44 <AStorm> Hmm, are plain numbers (.|.)-able (or-able) in Haskell?
16:49:07 <mathewm> ?hoogle Bits
16:49:08 <lambdabot> Data.Bits :: module
16:49:08 <lambdabot> Data.Bits.Bits :: class Num a => Bits a
16:49:08 <lambdabot> Data.Bits.bitSize :: Bits a => a -> Int
16:49:12 <sorear> ?let f `on` o x y = f x `o` f y
16:49:13 <lambdabot>  Parse error in pattern
16:49:14 <AStorm> Yes Bits.
16:49:19 <sorear> ?let (f `on` o) x y = f x `o` f y
16:49:20 <lambdabot> Defined.
16:49:53 <AStorm> But do I have to explicitly convert, or is that a class?
16:49:56 <sorear> \l r -> (l == ' ') == (r == ' ')  <==>  (==' ') `on` (==)
16:50:00 <AStorm> Hmm, datatype :/
16:50:52 <allbery_b> I seem to have started something.  And not what I expected. :)
16:50:56 <sorear> :t L.on(==' ')(==)
16:50:57 <lambdabot> Couldn't find qualified module.
16:51:06 <dons> allbery_b: hehe
16:51:11 <sorear> :t L.on
16:51:12 <lambdabot> Couldn't find qualified module.
16:51:16 <sorear> > L.on
16:51:16 <lambdabot>  Add a type signature
16:51:19 <dons> sorear: the L.* stuff isn't in :type
16:51:35 * allbery_b expected to see something less similar to the quick redo of the C++ version
16:51:52 <allbery_b> ..perhaps one which doesn't waste time reversing strings of spaces
16:52:45 <AStorm> Hmm, hslogging doesn't use #enum anymore, they've defined everything locally.
16:52:51 <AStorm> Any other example?
16:53:22 <vininim> ?let {f 0 n = 1; f x 0 =  f (x -1) 0; f x n = f ( x, f(x-1, n))} in f 4 3
16:53:22 <lambdabot>  Parse error
16:53:36 <vininim> u_u
16:54:02 <AStorm> Fibonnacci?
16:54:07 <vininim> ackermann
16:54:12 <Pupeno> Hello.
16:54:15 <AStorm> Yes, Ackermann
16:54:31 <Pupeno> Is there some version of the haskell logo that I can use ?
16:54:57 <AStorm> And the parse error is... f (x -1) 0
16:55:11 <AStorm> x-1 is not the same as x -1
16:55:37 <allbery_b> welcome to haskell :) that's one of the more annoying warts of the language
16:55:53 <AStorm> No, it's a feature.
16:55:55 <dons> Pupeno: the one on haskell.org, or on the logo pages: http://haskell.org/haskellwiki/Haskell_logos
16:55:56 <lambdabot> Title: Haskell logos - HaskellWiki
16:56:04 <AStorm> x actually could be a single-argument function.
16:56:20 <dons> Pupeno: and also http://xahlee.org/UnixResource_dir/lambda_logo.html
16:56:21 <lambdabot> Title: Xah: A Lambda Logo Tour
16:56:33 <sorear> > 1 + -1
16:56:33 <lambdabot>    precedence parsing error
16:56:33 <lambdabot>     cannot mix `(+)' [infixl 6] and prefix ...
16:56:36 <Pupeno> dons: I'd like to use the one at haskell.org, but that is too small, I like something bigger to work with.
16:56:39 <sorear> > 1 + (-1)
16:56:40 <lambdabot>  0
16:56:49 <sorear> > (join (*)) -1
16:56:50 <lambdabot>  add an instance declaration for (Num (a -> a))
16:56:51 <dons> Pupeno: there's a bigger version on the wiki somewhere
16:56:52 <sorear> > (join (*)) (-1)
16:56:53 <lambdabot>  1
16:56:56 <AStorm> > 1 -1
16:56:57 <lambdabot>  0
16:57:00 <dons> if you can work out how to find all the images
16:57:03 <AStorm> Hmm, it even does work.
16:57:06 <Pupeno> http://haskell.org/haskellwiki_logo.png
16:57:18 <AStorm> > let x = 4; x -1
16:57:18 <lambdabot>  Parse error
16:57:19 <dons> also these ones http://xahlee.org/haskell/haskell-logo.html
16:57:19 <lambdabot> Title: Xah: A Haskell A Day: Haskell Logo
16:57:20 <sorear> x -1 is parsed as (-) x 1
16:57:31 <sorear> > let x=4 in x -1
16:57:31 <dons> Pupeno: ah yes. that one
16:57:32 <lambdabot>  3
16:57:37 <AStorm> Yes.
16:57:57 <sorear> > let f x = x*x in f -4
16:57:57 <lambdabot>  add an instance declaration for (Num (a -> a))
16:58:00 <sorear> > let f x = x*x in f (-4)
16:58:01 <lambdabot>  16
16:58:38 <AStorm> Ok, any nice #enum examples?
17:01:37 <AStorm> Anyway, how would I fashion a data constructor and type/class for #enum?
17:03:35 <AStorm> I want that the enumerated valued support or-ing (somewhat connected with Bits type)
17:04:05 <dons> have you tried googling for #enum in haskell code?
17:04:20 <shapr> @google filetype:hs "#enum"
17:04:21 <dons> or using the code search stuff on google?
17:04:21 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/c2hs/docu/lib/CTypes.hs
17:04:25 <AStorm> Nothing relevant unfortunately.
17:04:26 <dons> there we go
17:04:28 <dons> shapr++
17:04:32 * shapr boings!
17:04:44 <AStorm> Forgot the filetype :P
17:05:11 <dons> shapr, should HAppS Inc. be on the official haskell in industry page?
17:05:24 <shapr> I don't know.
17:05:32 <shapr> Probably.
17:05:40 <dons> http://haskell.org/haskellwiki/Haskell_in_industry
17:05:42 <lambdabot> Title: Haskell in industry - HaskellWiki
17:05:55 <dons> (if you're in a position to add it, please do :)
17:05:56 <shapr> I'll look at it later, I'm hacking code at the moment...
17:06:13 <dons> ok
17:06:15 <dons> good!
17:06:23 <shapr> It's irritating, I used to understand the Template Haskell accessors that musasabi created, but now I don't...
17:06:34 <dons> ?users
17:06:34 <lambdabot> Maximum users seen in #haskell: 288, currently: 259 (89.9%), active: 21 (8.1%)
17:06:37 <ElMaia> [ Cale ], hi
17:06:44 <AStorm> Hmm, bleh, still zilch with that #enum.
17:07:13 <ElMaia> Can you help me again ?
17:07:14 <dons> AStorm: in ginus there's a curses binding that uses them
17:07:22 <dons> look for Curses.hsc in ginsu
17:07:26 <shapr> ginsu?
17:07:30 <shapr> @where ginsu
17:07:31 <lambdabot> http://repetae.net/john/computer/ginsu/
17:07:41 <dons> @google filetype:hsc "#enum"
17:07:44 <lambdabot> http://darcs.haskell.org/packages/X11/Graphics/X11/Types.hsc
17:07:57 <dons> (duh, they're going to be in .hsc files, silly me)
17:08:05 <AStorm> Hmm :>
17:08:06 <shapr> Well, I suggested hs :-)
17:08:09 <ElMaia> [ AStorm ], hi
17:08:19 <dons> ElMaia: just ask your question :)
17:08:23 <dons> you don't have to ask to ask
17:08:34 <ElMaia> dons
17:09:29 <ElMaia> Today, Cale and AStorm helped me with a problem
17:09:46 <ElMaia> But now, I just need to know
17:10:24 <ElMaia> If, when I'm creating a Button, if exist a way to know who its
17:10:53 <ElMaia> createBStars n f = mapM (\k -> bitmapButton f [text := "B" ++ show k,
17:10:53 <ElMaia> picture := "Play.gif",
17:10:53 <ElMaia> on command := changeColor b f k]) [1..sum [1..n]] where
17:10:53 <ElMaia> changeColor b f k = do set b [on command := infoDialog f "Toba" ("Eu sou o Botao" ++ show k)]
17:11:15 <ElMaia> I need to know who is b to pass by changeColor
17:12:24 <ElMaia> [ dons ], can you help me ?
17:12:28 <ElMaia> Or someone ?
17:16:48 <ElMaia> Hello
17:16:56 <ElMaia> Some one can help me ??
17:17:16 <dons> ElMaia: if no one answers, that generall means they can't think of a solution.
17:17:19 <psnl> yes, maybe
17:17:31 <dons> you might have better luck asking on the gtk2hs mailing list?
17:17:38 <dons> either way, don't repeat yourself in channel :)
17:17:44 <ElMaia> [ dons ]: But I use wxHaskell
17:17:53 <dons> ah sorry, wxhaskell's list
17:18:29 <dons> also, don't both putting people's names inside [ ] -- its not needed
17:18:33 <dons> s/bother/
17:18:47 <notsmack> i think his client does random symmetrical framings of names?
17:19:06 <dons> oh. you think?
17:19:20 <dons> no, I don't think so.
17:19:35 <dons> (different delimiters each time :)
17:19:58 <notsmack> silly either way; whether he's typing it or somebody wrote that :-)
17:20:39 <mathewm> [ dons ): I dunno, kinda fun :)
17:20:47 <vininim> "Kind error" lol
17:21:02 <dons> vininim: you got that? cool! well done
17:21:05 <dons> you've reached level 3.
17:21:14 <notsmack> btw dons, should yi from darcs be expected to build with dynamic loading support?
17:21:18 <vininim> =)
17:21:47 <dons> notsmack: hmm. I think it might be broken since I switched the buidl ystem over to cabal
17:22:10 <notsmack> i was afraid of that, couldn't quite figure it out
17:22:19 <notsmack> it seems it builds Main ignoring Boot
17:22:49 <shapr> haskell-mode has a monster bug >:-(
17:23:15 <vininim> any hopengl guru?
17:23:17 <Pseudonym> You need to (set-monster 'nil)
17:23:42 <vininim> :t Graphics.Rendering.OpenGL.ModelView
17:23:43 <lambdabot>   Not in scope: data constructor `Graphics.Rendering.OpenGL.ModelView'
17:23:51 <sorear> vininim: I wouldn't say 'guru', but I'm advanced enough to crash Xorg :(
17:24:05 <allbery_b> hrm?  it's actually been behaving for me since I finally got a working updated xemacs
17:25:06 <shapr> allbery_b: C-c C-] has problems when there are many cases, it adds spaces in the lines of code that are indented less than the =
17:25:36 <dons> it seems to me that we really should be able to have a ver ygood haskell-mode for emacs
17:25:43 <dons> its not crippled by the implementation language, unlike vim
17:25:45 * sorear is glad he didn't know about C-c C-]
17:25:52 <vininim> sorear: I'm following an old tutorial that has "matrixMode Modelview", but matrixMode is now a settable GLState wich means it would be like "matrixMode $= Projection", but apparentaly "matrixMode $= ModelView" doesn't make sense
17:26:40 <sorear> matrixMode $= Modelview 0
17:26:54 <sorear> is in one of my (working) programs...
17:27:34 <dons> mmm, interesting comment on the mailing list, a person, after seeing all the new wiki projects, library process improvements and so on says:
17:27:37 * sorear finds GPM extremely useful
17:27:37 <dons> "These activities are among the major reasons why I'm finally prepared to
17:27:40 <dons> get my feet wet with Haskell after years of interested watching."
17:27:43 <shapr> heh, cool
17:27:47 <dons> we have to be very organised!
17:27:50 <dons> people like stability
17:28:01 <shapr> Nah, they like *support*
17:28:05 <dons> that too :)
17:28:07 <vininim> hug please?
17:28:16 <dons> hugs, you mean.
17:28:21 <vininim> =D
17:28:32 <shapr> Personally, I like Haskell because it continues to build on the advances of the past.
17:29:02 <dons> as an aside, I'd like to write an article on why all the (US) lisp users should consider switching to haskell
17:29:10 <AStorm> You mean it's still in development? :>
17:29:12 <dons> (lisp gets way way more press than it merits, imo .... )
17:29:25 <sorear> why only U.S. users?
17:29:27 <AStorm> Lisp is ugly. ;>
17:29:36 <dons> and people pick up lisp to learn FP -- but lisp ain't FP!
17:29:51 <dons> sorear: oh, just that's where the big lisp stronghold seems to be
17:30:04 <dons> while, say, europe is happy to use erlang, haskell and ocaml :)
17:30:27 <johnnowak> US programmers like their Freedom.. none of these nonsense static type shackles!
17:30:35 <dons> the USAsians keep on with their lisps and schemes.
17:31:16 <AStorm> Hmm... I wonder... I have an enum, sort of.
17:31:19 <johnnowak> i don't see what immigrants have to do with it..
17:31:20 <mathewm> if static checking was the problem for US ppl, then erlang wouldn't be a problem
17:31:34 <AStorm> Actually, it's a bunch of constants. I'd love to convert it into Data.Set
17:31:53 <dons> to our advantage, though, the lisp community seems hopelessly fractured. but I suspect that just drives people away from FP all together in some cases.
17:32:31 <psnl> lisp is popular in the states since tons of us profs whent to MIT and <whereever> and were taught lisp, while tons of europeans profs have researched into haskell, erlang and ocaml, so they teach to their students
17:32:33 <dons> lisp is not a good ambassador for FP techniques
17:32:36 <mathewm> at times, I wish haskell functions could be easily inspected, like in LISP
17:32:45 <dons> psnl: yeah, exactly
17:33:00 * sorear vaguely thought the reason the Haskell community wasn't fractured was because it was itself one of the smaller and more distant shards of Greater Lisp-use
17:33:03 <AStorm> psnl, tons? Uh... not here :P
17:33:04 <dons> and the states is full of bloggers ;)
17:33:24 <AStorm> Here, the latest rage is still Java (yuck) with some .NET crawling.
17:33:25 <johnnowak> dons: i resent that remark... :)
17:33:49 <AStorm> Haskell? They haven't even heard about it. :P
17:34:14 <mathewm> Even in the US Haskell is growing in popularity rapidly
17:34:16 <Pseudonym> Speaking of being full of bloggers... http://www.spaff.com/mp3/Spaff.com%20Green%20Day%20Parody%20-%20I%20Blog%20Alone%20(~%20Boulevard%20of%20Broken%20Dreams).mp3
17:34:17 <sorear> "You mean Pascal, right?"
17:34:18 <lambdabot> http://tinyurl.com/nsp4y
17:34:19 <Pseudonym> Seems appropriate.
17:34:40 <AStorm> sorear, uh... that's a quote.
17:34:44 <mwolak> sorear: I get that every time someone asks what I'm writing stuff in
17:34:58 <dons> hehe
17:35:00 * johnnowak also gets that
17:35:17 <AStorm> I got weird stares when I said Python, but lately that seems to be changing.
17:35:58 <psnl> its also a natural swing. Lisp is 50s/60s stuff, while haskell is 80s/90s stuff (approx). at some point Lisp people will start looking for a new lauguage, and will take haskell and make it better just as  people have improved on ideas in lisp, and thrown in some new ones, to make haskell.
17:36:52 <psnl> it the  "foo language would be  a bit better if it had..." thinking
17:36:53 <johnnowak> psnl: i'm not sure haskell can fit any more ideas.
17:37:25 <AStorm> Sure it can. "object orientation" (as if it didn't have classes and types)
17:37:36 <psnl> johnnowak: dependent types? erlang style concurrency?
17:37:39 <AStorm> "structure support" (don't mind the datatypes)
17:37:52 <dons> don't we have erlang style concurrency? (chans?)
17:38:04 <AStorm> The concurency could be implemented a bit better, but it's ok.
17:38:06 <psnl> johnnowak: haskell isn't perfect, there is always a better language
17:38:14 <dons> is anyone familiar enough with lisp to help write a "10 reasons lisp programmers should consider HAskell" article with me?
17:38:15 <johnnowak> psnl: you'll have to excuse me.. i'm a scheme programmer. i feel privileged if i have arrays.
17:38:23 <AStorm> :>
17:39:06 <mathewm> I will work on the "Top 10 reasons VBA programmers should consider Haskell" with you :)
17:39:08 <dons> (happily, though, and a good sign, #haskell is the largest FP irc channel around, a fair bit bigger than #lisp or #scheme or #ocaml)
17:39:09 <AStorm> Well, I feel privileged when I have some true pointers.
17:39:16 <dons> and bigger than python  still (?)
17:39:22 <AStorm> mathewm, uhhh... :D
17:39:43 <johnnowak> why is #haskell so big anyway?
17:39:52 <dons> lambdabot?
17:39:53 <jlouis> ?users
17:39:53 <lambdabot> Maximum users seen in #haskell: 288, currently: 258 (89.6%), active: 26 (10.1%)
17:40:05 <dons> we have a link from the front page of haskell.org to the irc channel?
17:40:08 <mathewm> I blame pugs - drawing in the Perl riffraff
17:40:09 <johnnowak> perhaps all the #ocaml programmers are getting work done?
17:40:10 <LoganCapaldo_> lambdabot is definitely the reason :)
17:40:14 * mathewm is Perl riffraff
17:40:21 <greentea> dons: i'd like to ask you for some advice, if i may . . . .
17:40:26 <AStorm> johnnowak, who? :P
17:40:32 * greentea is Perl riffraff too. :-)
17:40:34 <Pseudonym> I learned Perl AFTER I learned Haskell, so there.
17:40:43 <jlouis> Perl == dangerous
17:40:47 <AStorm> Pseudonym, didn't it feel like a downgrade.
17:40:49 * LoganCapaldo_ is ruby riffraff (?)
17:40:52 <jlouis> its so damn easy to write crap perl.
17:40:52 <AStorm> s/./?/
17:41:04 <johnnowak> jlouis: i think that's the point.
17:41:08 <mathewm> see! Perl is easy!
17:41:13 <dons> greentea: please feel free
17:41:15 <jlouis> perl is easy
17:41:15 <Pseudonym> AStorm: It was an upgrade from aek.
17:41:17 <Pseudonym> awk
17:41:27 <jlouis> writing cool perl is damn fucking hard
17:41:29 <AStorm> Hmm, so I'm Python riffraff. ;-)
17:41:35 <Pseudonym> But it was Perl 4.  Half the good stuff came in in Perl 5.
17:41:48 <AStorm> Good for obfuscation?
17:41:56 <shapr> I'm Python riffraff too.
17:41:57 <monochrom> globs were da bomb
17:42:10 <jlouis> mmm, globs!
17:42:18 <sorear> glombs?
17:42:34 <shapr> johnnowak: Anyway, #haskell wasn't always this big, if you look at the stats page you'll see it took years of steady growth to get this big.
17:42:40 <mathewm> I did like Perl's lack of . show $ silly_number
17:42:47 <greentea> dons: Do you think it's better for a noob like me to work on adding to an existing codebase, or doing something new? The reason i ask is that i'm wondering whether to do some work on the HTTP lib, rather than slogging through this Jabber stuff . . . .
17:42:50 <dons> ?where stats
17:42:50 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
17:43:03 <dons> greentea: hmm. interesting idea.
17:43:05 <shapr> greentea: You have jabber code?
17:43:22 <dons> greentea: I know that sometimes it is better to work on an existing code base
17:43:23 <shapr> Oh, I got a mail from jmuk...
17:43:27 <Pseudonym> greentea, you should do whatever floats your boat the most.
17:43:33 <Excedrin> mathewm: ya, it's: print $silly_number instead! ;)
17:43:36 <Pseudonym> You're more likely to get it done that way.
17:43:39 <dons> (sjanssen for example, is an excellent programmer, after learning from the bytestring and fps source)
17:44:05 <greentea> shapr: Basically, no . . . . i've got the beginnings of stuff, but nothing working, because i've been spending a lot of time getting my head around HaXml.
17:44:16 <Pseudonym> If the Jabber stuff is a slog, then definitely work on HTTP lib.
17:44:17 <greentea> Pseudonym: True.
17:44:29 <shapr> greentea: In that case, why not jump onto Dmitry Astapov's Jabber codebase and compare it with what you have?
17:44:39 <Pseudonym> I have more Haskell toys sitting around than anything else, because I like toys.
17:44:45 <greentea> shapr: Oh! i didn't realise there already was one.
17:45:07 <AStorm> Well, and I'm starting to write useful things. Libcap bindings, for instance.
17:45:17 <jlouis> shapr is our project-octopus. He knows about ALL haskell projects
17:45:23 <greentea> *chuckle*
17:45:26 <shapr> greentea: When in doubt, @google filetype:hs <keyword>
17:45:26 <jlouis> even the ones that doesn't exist yet
17:45:28 <AStorm> (as a part of package management and sandboxing system)
17:45:40 <greentea> shapr: Yeah, i should have thought of doing that. :-|
17:45:42 <Pseudonym> I bet shapr doesn't know what I'm working on now.
17:45:43 <shapr> jlouis: I don't know about all the projects, but I do know a bunch.
17:45:47 <Excedrin> how's that pi calculus monad coming?
17:45:55 <shapr> Yeah, the Pi calculus monad was a surprised.
17:45:58 <AStorm> pi calculus? :
17:46:00 <shapr> So was lambdabot the first time.
17:46:04 <greentea> i mainly looked through HCAR.
17:46:08 <jlouis> picalc monad, hehe
17:46:10 <jlouis> sounds fun
17:46:14 <shapr> Since Pseudonym consistently surprises me, I don't try to predict his projects =)
17:46:14 <Pseudonym> That is cool.
17:46:19 <greentea> Anyway, thanks everyone for your thoughts and suggestions. :-)
17:46:21 <Pseudonym> How about a Linda monad next?
17:46:27 <jlouis> Linda monad?
17:46:33 <shapr> Linda tuplespace?
17:46:36 <Pseudonym> Yup.
17:46:42 <jlouis> hmm
17:46:57 <Excedrin> http://tsukimi.agusa.i.is.nagoya-u.ac.jp/~sydney/PiMonad/ -- it doesn't build with ghc 6.6, someone fix it :)
17:47:00 <lambdabot> Title: PiMonad - a network programming framework based on Pi-Calculus
17:47:00 <AStorm> This pi calculus could be... useful for thread management.
17:49:40 <AStorm> Other than that, programming in Pi calculus sounds even more fun than programming in Lambda calculus :P
17:49:49 <shapr> Who's the person to ask about darcs repo space on darcs.haskell.{org,net} ?
17:50:09 <shapr> Jun Mukai wants to move the HaskellNet repo.
17:50:11 <sorear> ?wiki Haskell.org
17:50:12 <lambdabot> http://www.haskell.org/haskellwiki/Haskell.org
17:50:19 <sorear> ^^^ it's in there
17:50:22 <shapr> Ah, too easy...
17:51:00 <mathewm> Hmm, no PiMonadT :(
17:51:08 <shapr> Ask for it!
17:51:14 <mathewm> I guess I could learn how to roll it myself.
17:51:45 <vininim> on a site note: programming drunk is kind of funky
17:51:54 <shapr> vininim: And usually a waste of time
17:52:03 <shapr> At least, for me it is.
17:52:15 <Pseudonym> As we always say, don't drink and derive.
17:52:25 <vininim> heh
17:52:43 <vininim> come on, linus drinking beer picture comes into mind
17:52:51 <emu> i remember being able to fix a type error i had in one of my programs, while coming home later that night completely smashed
17:52:59 <Pseudonym> {- drunk.. fix later -}
17:54:35 * shapr almost never sees that in his source code.
17:54:43 <Saulzar> It could help with endurance, perhaps not attention to detail :)
17:54:46 <Pseudonym> http://everything2.com/index.pl?node=MONKEY%20PROSTITUTE
17:54:53 <Pseudonym> Hmm.
17:55:05 <Pseudonym> Yes, apparently some people put in /* MONKEY PROSTITUTE */
17:55:06 <lambdabot> Title: Findings:@Everything2.com
17:55:20 <Pseudonym> http://everything2.com/index.pl?node_id=1314575
17:55:33 <dons> Coding drunk in Haskell is ok though, its like drinking on a passenger plane flight -- the stewards will prevent you from hurting anyone. However, coding drunk in C is just scary, DUI territory, and should not be allowed. I hope linux kernel devs don't write code under the influence
17:55:38 <lambdabot> Title: Drunk, fix later@Everything2.com
17:55:58 <dibblego> coding in drunk in C helps it all make sense
17:56:04 <dibblego> it's actually beneficial
17:56:08 <Pseudonym> It's probably not so bad in the case of the linux kernel.
17:56:14 <Pseudonym> It'll get caught by the upstream maintainers.
17:56:23 <dons> it explains a lot of the code in linux ;)
17:56:34 <dibblego> yes sir :)
17:56:50 <vininim> "She was an intellectual prostitute, seducing me with profound truisms"
17:56:57 * shapr saves that dons quote
17:57:00 <shapr> @quote dons
17:57:00 <lambdabot>  hugs should spot the blackhole, or fail gracefully
17:57:02 <dons> actually, the git 'merge' algorithm will handle it: Linus (or someone) will just ignore the patch
17:57:27 <mathewm> how can you recall those quotes from lambdabot?
17:57:36 * Pseudonym hugs the blackhole
17:57:46 <sorear> ?help note
17:57:47 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:57:56 <sorear> ?help tell
17:57:56 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
17:58:16 <dons> ?help quote
17:58:16 <lambdabot> quote <nick>
17:58:16 <lambdabot> remember <nick> <quote>
17:58:16 <lambdabot> Quote somebody, a random person, or save a memorable quote
17:58:48 <mathewm> ?quote mathewm
17:58:48 <lambdabot>  I am playing with (.)
17:58:53 <mathewm> oh yeah
17:59:13 <shapr> @quote
17:59:14 <lambdabot> Masklinn says: stability is overrated
17:59:50 <shapr> @quote
17:59:50 <lambdabot> ChristopherHendrie says: Sometimes I wonder if Java will be indirectly responsible for hastening the adoption of functional programming languages
18:00:01 <sorear> ?quote
18:00:01 <lambdabot> pjdelport says: qwe1234, boldly defining where no man has defined before!
18:00:15 <shapr> I like that one.
18:01:04 <sorear> ?google "boldly defining where no man" site:cse.unsw.edu.au
18:01:05 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/lambdabot/State/quote
18:04:25 <psnl> edwinb: can I repeat my question about the free var paper?
18:04:34 <edwinb> you can, although I saw it in my away log
18:04:41 <vininim> aha.. car crash
18:04:42 <edwinb> I didn't write it, it was Conor and James
18:04:42 <sorear> ?google filetype:hsc curses
18:04:43 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/hmp3/Curses.hsc
18:04:48 * vininim goes to watch the aftermath at window
18:05:11 <psnl> edwinb: aah, it had a prisoner reference, so I figred you were behind it
18:05:21 <shapr> Reminds me of the many police cars that stop in my area.
18:05:28 <shapr> I am not a number!
18:05:36 <shapr> I am a free man!
18:05:37 <psnl> shapr: you got it
18:05:39 <edwinb> psnl: I'm not the only one who makes gratuitous prisoner references ;)
18:05:43 <Pseudonym> But if you were a number, what number would you like to be?
18:05:49 * shapr attacks psnl with a big blobby white balloon
18:06:00 <shapr> Whatever comes out of 1/0
18:06:05 <Pseudonym> yes, nullity!
18:06:07 <psnl> Pseudonym: by long standting tradition, I'm number six
18:06:20 <sorear> c
18:07:37 <psnl> edwinb: does the title explain all, or should
18:07:46 <Pseudonym> Can I be the Khintchine constant?
18:07:47 * dons just ordered the prisoner on dvd
18:07:51 <psnl> I read it?
18:08:11 <edwinb> it's worth a read, it explains some nice implementation details
18:08:29 <edwinb> psnl: is it this week you're coming up to St Andrews?
18:08:39 <psnl> edwinb: thursday
18:08:52 * Nafai is getting "The Craft of Functional Programming" for Christmas!
18:08:53 <edwinb> I'll try to explain some of it at a whiteboard then ;)
18:09:14 <psnl> edwinb: whats the best way to do the bus/train thing then?
18:09:17 <edwinb> but be warned that our Christmas Party is on Wednesday so I might be even less coherent than usual
18:09:25 <psnl> oh, and should I wear a tie?
18:09:32 <edwinb> train to Leuchars, get next 99 or 96
18:09:45 <edwinb> and if you wear a tie, we'll send you away to dress more appropriately
18:09:45 <psnl> ah
18:10:10 <shapr> Nafai: yay!
18:10:53 <psnl> edwinb: I'm feling imtimadated by the size of the thing
18:11:11 <edwinb> don't worry
18:11:33 <edwinb> we're doing the selling, not you ;)
18:11:46 <Pseudonym> OK, BBL.  Job interview.
18:11:56 <psnl> good luck
18:11:59 <Pseudonym> Thanks!@
18:12:13 <Pseudonym> I like any job advert with the job title "physics programmer".
18:12:19 <Pseudonym> I suspect it might be games, thohugh.
18:12:22 <Pseudonym> Anyway, BBS.
18:12:53 <sorear> Is there a 'standard' curses-binding library?
18:13:14 <LoganCapaldo_> ?where hscurses
18:13:15 <lambdabot> http://www.informatik.uni-freiburg.de/~wehr/haskell/
18:13:49 <psnl> edwinb: oh, its not that... its thinking about one fleid for three/four years
18:14:07 <edwinb> you can see how it goes after one year
18:14:26 <edwinb> you can always get an MSc and move on
18:15:20 <sorear> I'd heard of hscurses but was mislead by the fact that it didn't top ?google; note that it is not in hackagedb.
18:15:38 <LoganCapaldo_> I dunno
18:15:42 <psnl> I'm spending a bit of time thinking about how to get very scalable infrastructure, which is long-winded and tricky
18:15:45 <LoganCapaldo_> I've never used it
18:15:51 <LoganCapaldo_> just noted that it exists :)
18:17:17 <newsham> > take 20 $ map ((`mod` 10).(floor)) (iterate (* 10) (4*atan 1.0))
18:17:19 <lambdabot>  [3,1,4,1,5,9,2,6,5,3,5,8,9,7,9,4,0,2,2,8]
18:17:35 <sorear> > pi
18:17:36 <lambdabot>  3.141592653589793
18:17:45 <psnl> parsers: is there anything better than happy?
18:17:53 <sorear> of course.
18:18:00 <dons> parsec or happy the the big 2
18:18:09 <newsham> > take 20 $ map ((`mod` 10).(floor)) (iterate (* 2) (2*atan 1.0))
18:18:10 <lambdabot>  [1,3,6,2,5,0,0,1,2,4,8,6,3,7,5,1,3,7,4,9]
18:18:36 <newsham> oops
18:20:27 <newsham> > take 20 $ map ((`mod` 2).(floor)) (iterate (* 2) (pi/2))
18:20:28 <lambdabot>  [1,1,0,0,1,0,0,1,0,0,0,0,1,1,1,1,1,1,0,1]
18:22:37 <mwolak> are Ints always strictified?
18:22:58 <mwolak> (in ghc)
18:24:52 <sorear> no
18:25:04 <sorear> > let (x :: Int) = fix id in x
18:25:04 <lambdabot>  Parse error in pattern
18:25:12 <sorear> > let x :: Int ; x = fix id in x
18:25:13 <lambdabot>  Exception: <<loop>>
18:25:22 <sorear> > let x :: Int ; x = fix id in 1
18:25:23 <lambdabot>  1
18:25:45 <mwolak> oh, yeah, totally strict ints would really screw things up
18:30:00 <newsham> is there a function to return the fracitonal part of a number?  (ie. x - floor x)
18:30:17 <sorear> ?hoogle Fractional
18:30:18 <lambdabot> Prelude.Fractional :: class Num a => Fractional a
18:30:20 <vininim> tuples > constructors
18:30:32 <sorear> ?def Fractional
18:30:33 <lambdabot> Maybe you meant: define definitions bf let
18:30:40 <sorear> ?definitions Fractional
18:30:40 <lambdabot> []
18:31:01 <sorear> ?hoogle Fractional a => a -> a
18:31:02 <lambdabot> Prelude.recip :: Fractional a => a -> a
18:31:02 <lambdabot> Prelude.id :: a -> a
18:31:02 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
18:31:18 <newsham> > let frac x = x - (fromIntegral $ floor x) in frac pi
18:31:19 <lambdabot>  0.14159265358979312
18:31:48 <vininim> mm I certanly needs to learn about datatypes and constructor, all of sudden all my problesm dissapear when I use tuple
18:31:57 <vininim> I -> *need
18:35:13 <vininim>  No instance for (Monad ((->) GLfloat))
18:36:03 <sorear> You need Control.Monad.Instances (?)
18:38:13 <syntaxfree> I can't compile wxHaskell.
18:38:22 <syntaxfree> it complains about a gtk/ directory that doesn't exist.
18:45:59 <LoganCapaldo_> Lazy + pure means short of things like IO every expression is evaluated once and only once right?
18:46:21 <LoganCapaldo_> I mean at most once
18:46:28 <LoganCapaldo_> not exactly once
18:46:30 <newsham> pure means it doesnt matter, right?
18:46:30 <LoganCapaldo_> oops :)
18:46:48 <LoganCapaldo_> Ok in Haskell is what I've described accurate?
18:46:53 <SamB_XP> er. no.
18:46:54 <LoganCapaldo_> forget I said pure
18:47:12 <SamB_XP> > map (\x -> x * 2) [1..]
18:47:13 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,5...
18:47:27 <newsham> i imagine haskell tries to remember some things to avoid recomputing the same value, but probably doesnt remember everything
18:47:32 <SamB_XP> the expression "x * 2" has been evaluated an indeterminate number of times ;-)
18:47:40 <SamB_XP> depends on buffering and things like that ;-)
18:47:57 <LoganCapaldo_> SamB_XP, that's not what I meant :)
18:48:19 <newsham> map (* 2) [1,2,3,4,3,2,3,5,4,3,2]
18:48:30 <newsham> you want to know if the 2*2 gets computed more than once
18:48:37 <newsham> (same function, same args)
18:48:39 <SamB_XP> usually if you have a constant expression it only gets evaluated once
18:48:41 <LoganCapaldo_> newsham, maybe
18:48:48 <SamB_XP> but, usually things don't memoize
18:49:17 <sorear> Seriously, the compiler is entitled to evaluate something more than once.  Usually it doesn't...
18:49:18 <SamB_XP> (the compiler is free to memoize things if it can get away with it, of course ;-)
18:49:32 <sorear> but for instance see Optimistic-Haskell
18:49:41 <dibblego> memoization is not always optimal
18:49:50 <SamB_XP> dibblego: indeed
18:49:54 <newsham> since its pure, there is no difference (other than perf) if the compiler evaluates the same thing once or multiple times, backwards, forwards, in another order, whatever
18:49:59 <SamB_XP> sometimes it is downright pessimal!
18:50:06 <LoganCapaldo_> well
18:50:30 <dibblego> newsham, memoization is a computation at the expense of space, trade
18:50:40 <SamB_XP> dibblego: maybe
18:50:42 <newsham> dibble: you're telling the wrong person :)
18:50:43 <LoganCapaldo_> what I was going for was calling a continuation being "free"but I guess not :)
18:50:55 <dibblego> oh
18:51:01 <dibblego> yes, and maybe
18:51:24 <SamB_XP> dibblego: but if you memoize a Bool -> Bool function, that probably saves space ;-)
18:51:30 <dibblego> who are we telling? or are we reminding ourselves?
18:52:09 <LoganCapaldo_> so much for my intuitive leaps :)
18:52:37 <SamB_XP> LoganCapaldo_: I don't think I want to see you play megaman
18:52:49 <chessguy> hmm, if i have a function foo :: a -> String, is there a way to say "if a is already a String, don't do anything"?
18:52:56 <LoganCapaldo_> SamB_XP, huh?
18:53:11 <SamB_XP> LoganCapaldo_: you'd probably make an intuitive leap into a bottomless pit ;-P
18:53:18 <dibblego> instance Show String where show = id
18:53:26 <newsham> logan: didnt reach escape velocity?
18:53:44 <chessguy> mmmm
18:53:54 <chessguy> well, i still need to be able to show the string later
18:54:03 <shapr> Does anyone know of a darcs-backed wiki? I know Igloo hacked up a prototype, but are there any other possibilities?
18:54:08 <dibblego> I find the terminology "do something" is confused with what is really required - a transform
18:54:28 <dibblego> "do something" is for imperative programmers to think about
18:54:36 <Jessehk> I was wondering if anybody had any suggestions for a short Cards module I wrote to better learn Haskell. http://paste.lisp.org/display/32079
18:54:36 <newsham> gravity weights heavily upon intuition
18:54:36 <Cale> I'll explain lazy evaluation and then the whole "magical memoisation" thing will seem a whole lot less magical
18:54:52 * shapr boings
18:55:06 <dibblego> hello shapr
18:55:14 <shapr> hiya dibblego, how's code?
18:55:28 <shapr> dibblego: Have you looked at arrows? They're much more a transform than a do something.
18:55:29 <Cale> In strict evaluation, which is what most programming languages use, evaluation proceeds innermost-first, which means that the parameters to a function are fully evaluated before they're passed to the function.
18:55:31 <dibblego> fromJust exceptions at the mo, but I'm eating lunch trying to find out where
18:55:55 <dibblego> Java has lazy eval, I watch Java programmers use it all the time
18:56:08 <chessguy> ok, i guess the easiest way to ask is if there's a way to test whether a function which can accept a parameter of any type received a parameter of type String
18:56:14 <dibblego> they will "refactor" function f(Integer[] is) to be f(Iterator<Integer> is)
18:56:15 <SamB_XP> dibblego: but it doesn't have lazy programming!
18:56:19 <shapr> I really wish GHC had some way to give the line number of the function that called function X. Then you could always find those evil fromJust or "head empty list" errors.
18:56:27 <dibblego> shapr, agreed
18:56:29 <SamB_XP> it makes you write so much stuff!
18:56:32 <newsham> jessehk: poker hand rankings? :)
18:56:36 <Excedrin> didn't dons figure that out?
18:56:46 <Cale> In normal-order evaluation, this situation is reversed, evaluation is outermost-first, which means that parameters to a function are substituted directly into the body of the function right away.
18:56:52 <shapr> btw, if you're ever in Birmingham, Alabama - Big Sky Bakery makes the best cookies, bread, etc that I have ever eaten in my entire life.
18:56:54 <Excedrin> his safeFromJust thing?
18:56:59 <Jessehk> newsham: Eventually. ;)
18:57:06 <Cale> However, this leaves open the potential for duplicating work
18:57:08 <sorear> ?let showDyn x = case cast x of Nothing -> show x ; Just x -> x
18:57:09 <lambdabot> Defined.
18:57:10 <shapr> On the downside, it costs $7 USD for a loaf of bread, but for once, it is worth it.
18:57:20 <Cale> If you have something like (\x -> x * x) (5 + 5)
18:57:21 <sorear> chessguy: ^^^
18:57:26 <dibblego> I have a fromJustE :: String -> Maybe a -> a -- to pass an error message if I want to use that in a minute
18:57:38 <Cale> then evaluation will proceed like ((5 + 5) * (5 + 5))
18:57:46 <mwolak> how come ByteString.Lazy is all Int64's instead of Ints?
18:57:51 <chessguy> hmm
18:57:52 <Cale> and then each of the (5 + 5)'s will be evaluated separately
18:57:52 <SamB_XP> shapr: better cookies than your grandma?
18:57:54 <dibblego> ?where safeFromJust
18:57:55 <lambdabot> I know nothing about safefromjust.
18:57:58 <chessguy> > showDyn "foo"
18:57:59 <lambdabot>  Not in scope: `showDyn'
18:58:04 <newsham> jesse: i did some.  it was the first thing i wrote in haskell so I dont claimits any good, but might be helpful?  http://www.thenewsh.com/%7Enewsham/x/machine/poker.lhs.txt
18:58:08 <SamB_XP> mwolak: they can be really really really long
18:58:15 <Cale> The difference in lazy evaluation is that values which result from the duplication of a variable are shared
18:58:18 <allbery_b> chessguy: L.showDyn
18:58:21 <shapr> SamB_XP: The cookies are really worth $6 for four cookies. And the bread is really worth $7 for one loaf.
18:58:24 <chessguy> oh
18:58:27 <Cale> and that's it
18:58:27 <chessguy> > L.showDyn "foo"
18:58:28 <lambdabot>  "foo"
18:58:32 <SamB_XP> shapr: must be big cookies!
18:58:32 <chessguy> > L.showDyn 3
18:58:33 <lambdabot>  Add a type signature
18:58:37 <jcreigh> how there even be such a thing as a "safeFromJust"? What would it be?
18:58:40 <sorear> > L.showDyn (3 :: Int)
18:58:41 <lambdabot>  "3"
18:58:47 <chessguy> > 3
18:58:48 <lambdabot>  3
18:58:51 <chessguy> hmm
18:58:55 <shapr> SamB_XP: Even better, the bakery is in Mountain Brook and you can get this stuff still warm. It's truly an amazing experience.
18:58:56 <SamB_XP> I would eat four cookies in a very very short while, if they were of ordinary size!
18:58:56 <mwolak> SamB_XP: ahh, I suppose that makes sense
18:58:59 <dibblego> if you ask a Java programmer to return the first 2 elements from an Iterator<Integer> is, they won't evaluate the entire Iterator until it is  exhausted (or infinite)
18:59:47 <dibblego> jcreigh, that's what I am wondering
18:59:48 <SamB_XP> dibblego: but can you pass the same iterator in twice and get the same answer?
18:59:51 <chessguy> @type showDyn
18:59:52 <lambdabot> Not in scope: `showDyn'
18:59:54 <chessguy> @type L.showDyn
18:59:55 <lambdabot> Couldn't find qualified module.
18:59:57 <shapr> SamB_XP: haha, they got xmas-dotted http://www.bigskybreadcompany.com/down_for_maintenance.php
18:59:58 <dibblego> SamB, Iterable you can
18:59:59 <lambdabot> Title: Site Closed for Renovations
19:00:12 <allbery_b> @type doesn't know about stuff defined by ?let
19:00:13 <lambdabot> Not in scope: `doesn't'
19:00:13 <lambdabot>  
19:00:13 <lambdabot> <interactive>:1:8: Not in scope: `know'
19:00:20 <dibblego> SamB, Java programmers prefer referential transparency too, they just call it "design patterns" or something
19:00:20 <allbery_b> heh
19:00:35 <chessguy> @type let showDyn x = case cast x of Nothing -> show x ; Just x -> x
19:00:36 <lambdabot> not an expression: `let showDyn x = case cast x of Nothing -> show x ; Just x -> x'
19:00:42 <shapr> @quote dibblego
19:00:42 <lambdabot>  using logic in imperative programming language channels is generally considered trolling
19:00:46 <SamB_XP> dibblego: python programmers called it "referential transparency", last I heard ;-)
19:00:47 <chessguy> @type let showDyn x = case cast x of Nothing -> show x ; Just x -> x in showDyn
19:00:48 <lambdabot> forall a. (Typeable a, Show a) => a -> String
19:01:33 <newsham> badmouthing python again?
19:01:40 <SamB_XP> newsham: no!
19:01:56 <chessguy> @type cast
19:01:57 <lambdabot> forall b a. (Typeable b, Typeable a) => a -> Maybe b
19:02:06 <dibblego> I mean, a Java programmer will "refactor" their Iterator "out to an Iterable"
19:02:15 <SamB_XP> I'm saying python programmers call "referential transparency" "referential transparency" -- how could that be "badmouthing"?
19:02:28 <dibblego> so that f(Iterable) is referentially transparent (since f(Iterator) is not)
19:02:31 <newsham> thats what i want to know!
19:02:37 * shapr hugs newsham 
19:02:38 <newsham> (ok, i'm not making sense)
19:02:41 <newsham> hi shapr
19:02:47 <shapr> hi newsham!
19:02:50 * shapr boings cheerfully
19:02:51 <chessguy> hmph, i don't get how that works, but i guess that's ok
19:03:10 <SamB_XP> > typeOf "Hi!"
19:03:11 <lambdabot>  [Char]
19:03:28 <chessguy> whoah
19:03:29 <jcreigh> @type typeOf
19:03:30 <lambdabot> forall a. (Typeable a) => a -> TypeRep
19:03:34 <shapr> newsham: Hey is your python/haskell webapp source online for comparison?
19:03:35 <jcreigh> > typeOf TypeOf
19:03:36 <lambdabot>  Not in scope: data constructor `TypeOf'
19:03:41 <jcreigh> > typeOf typeOf
19:03:41 <lambdabot>  Add a type signature
19:03:51 <SamB_XP> see, it only works on monomorphic things
19:03:54 <SamB_XP> hence the string literal
19:03:55 <newsham> shapr: no.
19:03:57 <shapr> aww
19:04:04 <newsham> maybe eventually.
19:04:10 <shapr> Will it be online? Or is it somethin for your job?
19:04:21 <newsham> this is personal project but i'm not decided yet.
19:04:22 <SamB_XP> > toDyn "hi!"
19:04:23 <lambdabot>  <<[Char]>>
19:04:26 <shapr> oh, ok.
19:04:37 <SamB_XP> @hoogle Dynamic -> a
19:04:37 <lambdabot> No matches, try a more general search
19:04:40 <shapr> I'd definitely like to see the two codebases just for personal learning.
19:04:41 <SamB_XP> @hoogle Dynamic
19:04:41 <newsham> btw, did you take a look at the happs state stuff yet?
19:04:41 <lambdabot> Data.Dynamic :: module
19:04:41 <lambdabot> Data.Dynamic.Dynamic :: data Dynamic
19:04:41 <lambdabot> Data.Dynamic.fromDynamic :: Typeable a => Dynamic -> Maybe a
19:04:59 <shapr> Not yet, I'm gathering momentum towards that goal by hacking on my happswiki source.
19:05:08 <svref> I've grabbed MiniHTTP, and it works, only problem is it takes, like, 3 minutes to download a page, that downloads in .1 seconds in a web browser.  Thoughts?
19:05:22 <SamB_XP> > map fromDynamic [toDyn "hi!", toDyn ()] :: [Maybe String]
19:05:23 <lambdabot>  [Just "hi!",Nothing]
19:05:37 <newsham> its pretty easy to access tate from happs.  although in general working with stateful computation in hsakell seems tedious to me
19:05:51 <shapr> Even with monads, accessors, etc?
19:06:03 <newsham> they help to some degree..
19:06:19 <shapr> Can you describe the what or why of the tediousness?
19:06:35 <shapr> @quote BjarneStroustrup
19:06:35 <lambdabot>  any verbose and tedious solution is error-prone because programmers get bored. [S 9.4 of C++, 2nd edition]
19:06:51 <newsham> but when you have complex nested code..   you either have to use a lot of accessors that compose, or break down the state monads into subspace monads somehow if you want to have modularity
19:07:31 <sorear> ?where lambdabot
19:07:31 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
19:07:39 <newsham> where as in an imperative language you get all the accessors you want more or less for free and can use them where ever you want (wether or not that is a good thing :)
19:07:45 <shapr> I'm having that same problem right now with some HAppS code actually. It looks monad transformers is the right approach to break a chunk of the record off into "composable state" but I'm not completely sure...
19:08:16 <shapr> The basic problem is that the mail sending code shouldn't have to know anything about how to render the mail message itself.
19:08:32 <newsham> i posted my code to haskell-cafe about decomposing the state monad into subspaces, but the feedback I got was mostly that its better to just use accessor functions
19:08:41 <newsham> and I ended u prewriting most of my code along those lines
19:08:45 <shapr> No one suggested monad transformers?
19:09:02 <newsham> in my case i dont think monad transformers buy anything.
19:09:17 <newsham> i'm in a state monad, and i want to go into another state monad.  i dont really want to combine different types of monads
19:09:32 <shapr> I don't think I understand.
19:09:44 <shapr> Or maybe I do and disagree, I'm not sure.
19:09:52 <newsham> here's the thread with example code.  http://www.haskell.org/pipermail/haskell-cafe/2006-December/020069.html
19:09:54 <lambdabot> Title: [Haskell-cafe] state updates and efficiency, http://tinyurl.com/yenfbo
19:09:59 <shapr> For me at least, I want to keep state with different purposes in different places.
19:10:01 * shapr reads thread
19:11:24 <newsham> in my real life code i've got records with about 5-15 members each, some Data.Map's, some lists, etc.
19:12:24 <newsham> (i ended up getting rid of some of the nesting by using some Map's at the top level, and instead of nesting a structure, using the map key in other records to reference items from the maps)
19:12:27 <vininim> "Suppose that we are writing a program to keep track of sheep cloning
19:12:48 <vininim> experiments" <-- how to not write a tutorial =p
19:12:54 <liyang> newsham: there's some stuff in http://e-pig.org/darcs/epigram/src/Idiomatica.lhs with respect to extending state (or reader, or writer, or error) monads, and you can even refer to the bit of state you're after by name.
19:12:55 <sorear> newsham: you've just reinvented Control.Monad.ST
19:13:20 <liyang> newsham: from \section{Constructing Monads} onwards.
19:13:55 <newsham> sorear: hmm.. i'll investigate that.  thanks.
19:14:06 <newsham> are you talking about things like iorefs?
19:14:15 <newsham> liyang: thanks.
19:14:24 <liyang> (where by `by name' I mean, `as opposed to trying to work out how many |lift|s you need.')
19:15:05 <newsham> is this library in the std libs?
19:15:09 <sorear> st+stref is the same as io+ioref...
19:15:10 <shapr> Also, arrows can definitely optimize out updates that don't change anything.
19:15:10 <sorear> yes
19:15:17 <newsham> sorry, that was to liyang.
19:15:42 <liyang> The only problem is that you'll have to decipher Conor's code. And allow -fundecidable-instances.
19:15:46 <sorear> except thanks to exceedingly clever implementation tricks runST can be used in pure code.
19:15:56 <sorear> ?where Lazy functional state threads
19:15:56 <lambdabot> I know nothing about lazy.
19:16:40 <liyang> newsham: nope. It was freshly concocted about a month ago...
19:16:45 <jcreigh> @pl (\xs -> xs == (reverse xs))
19:16:45 <lambdabot> ap (==) reverse
19:17:08 <mq_mattr> dons:
19:17:14 <newsham> is there a good intro to Control.Monad.ST?
19:17:23 <mq_mattr> dons: having trouble gettinn lambdabot
19:17:26 <mq_mattr> >darcs get --partial http://www.cse.unsw.eu.au/~dons/lambdabot
19:17:26 <mq_mattr> Invalid repository:  http://www.cse.unsw.eu.au/~dons/lambdabot
19:17:26 <mq_mattr> darcs failed:  Failed to download URL http://www.cse.unsw.eu.au/~dons/lambdabot/_darcs/inventory
19:17:27 <mq_mattr> libcurl: couldn't resolve host
19:17:39 <sorear> eu
19:17:44 <sorear> EDUcation
19:18:02 <mq_mattr> haha - so freaking obvious
19:18:03 <sorear> the University of New South Wales is in AUstralia, not the EU.
19:18:06 <mq_mattr> what a stooge I am
19:18:23 <mq_mattr> just takes another pair of eyes
19:18:30 <mq_mattr> at least that is what I will tell myself
19:18:37 <mq_mattr> dons: fixed
19:19:14 <allbery_b> it's not *truly* embarrassing until you type that in and then spot it yourself :)
19:21:24 <sorear> hey, I've tried to use lisp.paste.org, google.org, etc etc
19:21:24 <sorear> ?google Lazy functional state threads
19:21:26 <lambdabot> http://www.cse.ogi.edu/~jl/Papers/stateThreads.ps
19:23:17 <newsham> is there a copy of this idiomatica formatted into a .pdf?
19:24:00 <newsham> sorear: thanks.
19:24:18 <mq_mattr> now, how do I get that gaff out of the archive :)
19:24:30 <newsham> i shall rewrite my code yet again :)   but yah, i think using references that I dont manually have to manage will be useful.
19:25:40 <jcreigh> > take 20 $ map fst $ iterate (\(n, inc) -> (n + inc, inc + 2)) (0, 1)
19:25:41 <lambdabot>  [0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361]
19:26:31 <newsham> jcreigh: is that an unfold?
19:26:54 <sorear> iterate is an unfold
19:26:55 <jcreigh> newsham: err...I don't know. :)
19:27:12 <sorear> iterate f x = unfoldr (\x -> Just (x, f x))
19:27:17 <sorear> iterate f x = unfoldr (\x -> Just (x, f x)) x
19:27:25 <sorear> ?let iterate f x = unfoldr (\x -> Just (x, f x)) x
19:27:26 <lambdabot> Defined.
19:27:32 <sorear> > L.iterate (*2) 1
19:27:33 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
19:28:04 <jcreigh> @type unfoldr
19:28:06 <lambdabot> forall a b. (b -> Maybe (a, b)) -> b -> [a]
19:29:58 <jcreigh> I guess the function is supposed to return Nothing when it's "done" unfolding?
19:30:18 <jcreigh> > unfoldr (\_ -> Nothing) 42
19:30:19 <lambdabot>  Add a type signature
19:30:25 <newsham> yes.
19:30:26 <jcreigh> > unfoldr (\_ -> Nothing) 42 :: [Int]
19:30:27 <lambdabot>  []
19:30:37 <mq_mattr> OK, I don't think this is such a silly question.
19:30:41 <kpreid> unfoldr is a general means of constructing a list
19:30:43 <mq_mattr> I just installed fps7
19:30:50 <mq_mattr> and running the tests gives an error
19:31:03 <mq_mattr> >make
19:31:03 <mq_mattr> Interpreted
19:31:04 <mq_mattr> runhaskell Properties.hs
19:31:04 <mq_mattr> QuickCheckUtils.hs:24:17:
19:31:04 <mq_mattr>     Could not find module `Data.ByteString.Lazy.Char8':
19:31:04 <mq_mattr>       it was found in multiple packages: fps-0.7 base
19:31:05 <mq_mattr> make: *** [prop] Error 1
19:31:12 <mq_mattr> any tips?
19:31:21 <allbery_b> you installed it in ghc 6.6, which doesn't need it
19:31:45 <mq_mattr> aha - but my lambdabot install stopped with a missing dependency for fps
19:31:53 <mq_mattr> which is why I tried installing it
19:31:57 <allbery_b> there's a .cabal file for ghc6.6
19:32:10 <mq_mattr> for lambdabot?
19:32:13 <allbery_b> yes
19:32:17 <mq_mattr> cool
19:32:27 <allbery_b> look at lambdabot.cabal*
19:32:31 <mq_mattr> how do I remove the fps I just put in
19:32:41 <jcreigh> > unfoldr (\(n, inc) -> if n > 25 then Just (n, (n + inc, inc + 2)) else Nothing) (0,1)
19:32:41 <allbery_b> the default is for ghc6.4, you need to copy the other one over it for 6.6
19:32:42 <lambdabot>  []
19:32:53 <jcreigh> > unfoldr (\(n, inc) -> if n < 25 then Just (n, (n + inc, inc + 2)) else Nothing) (0,1)
19:32:54 <lambdabot>  [0,1,4,9,16]
19:32:57 <jcreigh> heh.
19:32:58 <allbery_b> ghc-pkg unregister fps
19:33:07 <mq_mattr> thanks
19:33:22 <jcreigh> I guess (<) /= (>) :)
19:33:47 <mwolak> sure, if you want to use the "traditional" math
19:35:26 <newsham> > unfoldr (\x -> let (a,b) = x `divMod` 10 in if a == 0 && b == 0 then Nothing else Just (b,a)) 90210
19:35:28 <lambdabot>  [0,1,2,0,9]
19:36:07 <mq_mattr> so, how do I build lambdabot with cabal, the instructions told me to ./build; but that lead to a dependency error
19:36:47 <newsham> is there a \pred val -> if pred then Just val else Nothing ?
19:37:20 <jcreigh> @hoogle Bool -> a -> Maybe a
19:37:20 <lambdabot> No matches, try a more general search
19:39:10 <Jessehk> Sorry if this is obvious, but how do I import a module into the interactive prompt?
19:39:32 <sorear> :m + foo
19:39:42 <sorear> :also foo <Hugs>
19:40:27 <Jessehk> sorear: Thanks
19:40:34 <jcreigh> newsham: it sure seems like you could (ab)use some monadic function to get that result, but I don't know what it would be...
19:41:07 <sorear> ?hoogle toMaybe
19:41:07 <lambdabot> Maybe.listToMaybe :: [a] -> Maybe a
19:41:07 <lambdabot> System.Win32.Types.numToMaybe :: Num a => a -> Maybe a
19:41:07 <lambdabot> System.Win32.Types.ptrToMaybe :: Ptr a -> Maybe (Ptr a)
19:41:33 <newsham> seems like something that would be useful often..  not that typing out the if-then-else is hard
19:42:00 <sorear> ?pl \p v -> if p then Just v else Nothing
19:42:00 <lambdabot> flip flip Nothing . (. Just) . if'
19:42:02 <jcreigh> newsham: well, writing a function is a one-off
19:42:24 <sorear> ?pl \p v -> guard p >> return v
19:42:24 <lambdabot> (. return) . (>>) . guard
19:42:40 <sorear> :t guard
19:42:41 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
19:43:13 <newsham> guard p >> return v   might be concise enough
19:43:42 <greentea> Heh, i just read O(log n) as 'Oleg'. :-P
19:44:04 <newsham> > unfoldr (\x -> let (a,b) = x `divMod` 10 in guard (a /= 0 || b /= 0) >> return (b,a)) 90210
19:44:05 <lambdabot>  [0,1,2,0,9]
19:44:11 * SamB_XP sends dons an email
19:44:39 <newsham> > unfoldr (\x -> let (a,b) = x `divMod` 2 in guard (a /= 0 || b /= 0) >> return (b,a)) 90210
19:44:40 <lambdabot>  [0,1,0,0,0,1,1,0,0,0,0,0,0,1,1,0,1]
19:44:48 <dons> @seen mq_mattr
19:44:48 <lambdabot> I saw mq_mattr leaving #haskell 5m 3s ago, and .
19:44:52 <dons> SamB_XP: oh?
19:45:04 <SamB_XP> dons: yes!
19:45:08 <jcreigh> whoa! ghci has tab-completion!
19:45:11 <dons> SamB_XP: Monoid sounds good
19:45:19 <dons> SamB_XP: also, want to add cons?
19:45:31 <jcreigh> ghc++
19:45:31 <dons> cons = (.) . (:)
19:45:33 <dons> I think
19:45:39 <SamB_XP> of course, you'll need a newtype rather than a type synonym
19:45:45 <dons> SamB_XP: right
19:45:51 <dons> I think that's ok though
19:45:54 <SamB_XP> yeah
19:45:55 <dons> then we can add a few other instances
19:46:03 <SamB_XP> nobody will have started using it yet anyway ;-)
19:46:05 <newsham> dons: you should make a smiley-expression-haskell-code  competition.
19:46:12 <dons> hehe
19:46:20 <dons> we should run the nexT IOHCC soon
19:46:58 <sorear> A while ago I ?tell'd SamB; now SamB_XP appears.  How feasable would it be to give LB support for multiple names?
19:47:07 <dons> pretty easy I think
19:47:17 <dons> we need a general lib for regex matches, normalised names and so on
19:47:21 <dons> just a few utils, in Lib/*
19:47:26 <dons> would be useful, for @seen, @quote and so on
19:47:36 <dons> sorear: would be an easy project for getting into lambdabot hacking.... ;)
19:47:43 * SamB checks for messages
19:47:43 <lambdabot> SamB: You have 1 new message. '/msg lambdabot @messages' to read it.
19:47:49 <SamB> @messages
19:47:49 <lambdabot> sorear said 1h 49m 9s ago: If what you want is in there it'd be in UI.Console or UI.GLUT.Main (warning: newbie code) : darcs get http://members.cox.net/stefanor/hslife/
19:47:54 <newsham> > (8)-p     where p = 2
19:47:54 <lambdabot>  Parse error
19:48:25 <dons> newsham: 'where' is an expression form (wart imo, but for hysterical raisins)
19:48:36 <dons> s/is not/
19:48:57 <SamB> you have a wierd server, sorear!
19:49:14 <dons> anyone want to translate these into haskell, for fame and reddit glory? http://www.ic.unicamp.br/~meidanis/courses/mc336/2006s2/funcional/L-99_Ninety-Nine_Lisp_Problems.html
19:49:15 <lambdabot> Title: L-99: Ninety-Nine Lisp Problems, http://tinyurl.com/tt9e7
19:49:29 <dons> would be another good intro.
19:49:52 <sorear> SamB: are you referring to the fact that it gives 404's instead of access denied for missing index.html?
19:50:06 <SamB> sorear: instead of a directory listin, you mean?
19:50:12 <sorear> yes.
19:50:17 <SamB> dons: is that like 99 bottles of beer on the wall?
19:50:40 <newsham> dons: would the answers be allowed to use prelude functions?   "find the k'th element of a list" isnt exactly challenging
19:50:51 <newsham> maybe 99 answers for each? ;-)
19:51:12 <sorear> > iterate ("id "++) "(!!)"
19:51:12 <dons> newsham: I guess the idea is to reimplement them, then introduce the idiomatic solution
19:51:17 <lambdabot>  ["(!!)","id (!!)","id id (!!)","id id id (!!)","id id id id (!!)","id id id ...
19:51:20 <dons> sorear: nice
19:51:41 <jcreigh> OTOH, #7 seems like it would be tricky in Haskell...
19:52:02 <dons> jcreigh, newsham: could someone start a new wiki page, for the transcription?
19:52:12 <dons> ?wiki 99_Haskell_exercises
19:52:12 <lambdabot> http://www.haskell.org/haskellwiki/99_Haskell_exercises
19:52:13 <newsham> jc: why?
19:52:15 <dons> for example
19:52:43 <dons> we want to assimilate the (legacy) lisp programmers, before they self destruct and run over to ruby
19:53:04 <jcreigh> newsham: well, what is the type of [1,2,[3,4,[5,6],7],8,[9,10]]?
19:53:41 <SamB> @pl snoc (DL dxs) x = DL (dxs . (x:))
19:53:41 <lambdabot> (line 1, column 17):
19:53:42 <lambdabot> unexpected "="
19:53:42 <lambdabot> expecting variable, "(", operator or end of input
19:53:42 <jcreigh> seems like you'd have to do something clever. (Or perhaps [Either a [a]] would work. Seems hackish.)
19:53:57 <SamB> @pl snoc dxs x = DL (unDL dxs . (x:))
19:53:58 <lambdabot> snoc = (DL .) . (. (:)) . (.) . unDL
19:54:13 <newsham> jcreigh: data MyList = ANum Int | ... ?
19:54:14 <sorear> fix a. Either Int [a]
19:54:24 * SamB wonders what dons thinks of this code?
19:55:09 <SamB> @pl append dxs dys = DL (unDL dxs . unDL dys)
19:55:09 <lambdabot> append = (DL .) . (. unDL) . (.) . unDL
19:55:39 <chessguy> hehe
19:55:40 <chessguy> this is cute:
19:55:44 <newsham> jcreigh: thats just mapping the problem onto haskell.  the answer's easy once the problem is asked properly
19:55:46 <chessguy> > let nonTerm x = nonTerm (x+1); three x = 3 in three (nonTerm 0)
19:55:50 <lambdabot>  3
19:55:52 <SamB> dons: aren't you going to stop me before this gets out of hand?
19:56:05 <newsham> (also what about the dynamic typing stuff?)
19:56:27 <sorear> :t typeOf
19:56:29 <newsham> probably sholdnt be encouraging lisp programmers to use haskell's dynamic typing stuff :)
19:56:29 <lambdabot> forall a. (Typeable a) => a -> TypeRep
19:56:39 <SamB> @pl snoc x dxs = DL ((x:) . unDL dxs)
19:56:40 <lambdabot> snoc = (DL .) . (. unDL) . (.) . (:)
19:56:42 <SamB> er.
19:56:45 <SamB> @pl cons x dxs = DL ((x:) . unDL dxs)
19:56:45 <lambdabot> cons = (DL .) . (. unDL) . (.) . (:)
19:58:22 <newsham> > typeOf ["hi"]
19:58:24 <SamB> dons: well? aren't you going turn me from my pointless course of action?
19:58:25 <lambdabot>  [[Char]]
19:58:58 <newsham> > ["test", ["this", "out"]] :: [Typeable]
19:58:59 <lambdabot>    Class `Typeable' used as a type
19:58:59 <lambdabot>   In the type `Typeable'
19:58:59 <lambdabot>   In the ty...
19:59:48 <SamB> > [toDyn "test", toDyn ["this", "out"]]
19:59:49 <lambdabot>  [<<[Char]>>,<<[[Char]]>>]
19:59:50 <newsham> > [toDyn "test", toDyn ["this", "out"]]
19:59:51 <lambdabot>  [<<[Char]>>,<<[[Char]]>>]
20:00:34 <SamB> @unpl snoc        = (DL .) . (. (:)) . (.) . unDL
20:00:34 <lambdabot> snoc h q = (DL) (\ e -> unDL h (((:)) q e))
20:00:40 <SamB> heh
20:00:43 <newsham> > [toDyn "test", toDyn [toDyn "this", toDyn [toDyn "out"], toDyn []]
20:00:43 <lambdabot>  Parse error
20:00:53 <newsham> > [toDyn "test", toDyn [toDyn "this", toDyn [toDyn "out"], toDyn []]]
20:00:54 <lambdabot>  Add a type signature
20:01:12 <SamB> dons: is it just me, or does that have way more parens than it needs?
20:01:20 <Jessehk> I'm a bit confused. What's the difference between Data.List and List?
20:01:33 <SamB> Jessehk: List is from Haskell 98
20:01:48 <SamB> Data.List is newer and shinier ;-)
20:01:51 <allbery_b> List is the old flat namespace from Haskell 98.  modern Haskell uses hierarchival libraries, hence Data.List
20:01:56 <newsham> is there any shorthand for writing out Dyn literals?
20:02:00 <allbery_b> ^v^c
20:02:19 <SamB> newsham: eval "haskell expression"?
20:02:33 <newsham> i dont know what that means
20:02:46 <SamB> hs-plugins might let you do that
20:03:14 <SamB> not that that is shorter ;-)
20:03:17 <dons> mmm, the new lambdabot 16 core server arrives this week!
20:03:22 <dons> hear that lambdabot?
20:03:27 <shapr> newsham: Got distracted, but now I see what you mean.
20:03:34 <newsham> ?quote lamdabot
20:03:34 <lambdabot> lamdabot hasn't said anything memorable
20:03:37 <SamB> dons: are you going to put a stop to my madness or what?
20:03:39 <lambdabot> Yay! A new roomy home!
20:03:41 <newsham> ?quote lamdabot
20:03:41 <lambdabot> lamdabot hasn't said anything memorable
20:03:52 <SamB> ?quote me
20:03:52 <lambdabot> me hasn't said anything memorable
20:03:56 <SamB> @remember me
20:03:58 <lambdabot> Incorrect arguments to quote
20:04:03 <SamB> @remember me
20:04:04 <lambdabot> Incorrect arguments to quote
20:04:08 <allbery_b> ?quote lambdabot
20:04:08 <lambdabot>  i 4M THe cooLES+ bo+ e\/eR
20:04:14 <SamB> @remember me
20:04:14 <lambdabot> Incorrect arguments to quote
20:04:22 <SamB> hmm. spaces no worky.
20:04:43 <newsham> ?elite i have more cores than you.
20:04:43 <lambdabot> i H4V3 m0RE COrEz0rz than y0U.
20:04:47 <SamB> @pl cons        = (DL .) . (. unDL) . (.) . (:)
20:04:48 <lambdabot> cons = (DL .) . (. unDL) . (.) . (:)
20:05:10 <dons> doesn't have to be pointfree, by the way.
20:05:24 <dons> and be sure to update the tests
20:05:53 <SamB> dons: update them to do what?
20:06:11 <shapr> Ya know, we need something like the cult of the dead cow for the Haskell world...
20:06:12 <JFT> can parMap be used from "anywhere" or does it need to be used from within a specific Monad?
20:06:28 <dons> the cult of the bound variable?
20:06:38 <dons> JFT: anywhere, its pure no?
20:06:49 <dons> (that's the point of the pure par stuff -- you can use it anywhere :)
20:07:00 <dons> ?hoogle parMap
20:07:01 <lambdabot> Control.Parallel.Strategies.parMap :: Strategy b -> (a -> b) -> [a] -> [b]
20:07:05 <dons> looks good to me
20:07:14 <JFT> thanks you :)
20:07:19 <JFT> I checked Hoogle
20:07:22 <dons> got some cores to run it on?
20:07:31 <SamB> dons: I was kinda hoping you would tell me to make these three pointfull ;-)
20:07:33 <dons> we need some par/Parallel.Strategies tutorials!
20:07:37 <JFT> not "yet" but I'm learning Haskell
20:07:41 <dons> SamB: please make them pointful
20:07:53 <JFT> and specifically interrested in its use for Parrallelism
20:07:53 <dons> SamB: and submit a darcs patch for karma points
20:07:56 <dons> JFT: great!
20:08:04 <dons> JFT: you've found the resources you need to get started?
20:08:09 <dons> and have ghc 6.6 installed?
20:08:19 <JFT> yes I have 6.6 installed
20:08:32 <JFT> but no tutorial and any of the concurrent stuff so far just GHC Library
20:08:36 <JFT> (documentation)
20:08:38 <dons> got the ghc user's guide sections on parallelism handy?
20:09:04 <JFT> just started on it but so far only saw switches to enable stuff
20:09:11 <JFT> Unless I checked the wrong section
20:09:18 <dons> ?where+ parallel http://www.haskell.org/ghc/dist/current/docs/users_guide/lang-parallel.html
20:09:18 <lambdabot> Done.
20:09:53 <JFT> awesome thank you!
20:10:14 <dons> JFT: also, a little demo here, http://haskell.org/haskellwiki/Concurrency_demos/Zeta#Or_using_Strategies
20:10:16 <lambdabot> Title: Concurrency demos/Zeta - HaskellWiki, http://tinyurl.com/y6e7wc
20:10:29 <dons> but we need more material! so if you write some examples, ping me, and we can stick them on the wiki
20:11:12 <JFT> sure thing but I only started on Haskell 2 months ago so I'm still in the "figuring out" period :P
20:11:16 <dons> JFT: how'd you hear about the parallelism stuff?
20:11:37 <dons> JFT: ok. well, be sure to ask here or on haskell-cafe@ for any assistance
20:11:43 <JFT> I dont recall from which paper I read about it, not sure if it was STM or the release note for GHC 6.6
20:11:57 <dons> ok.
20:12:28 <dons> mmm, Processor    8 x  AMD OpteronT Dual Core 870, 2MB (2.0GHz)
20:12:33 <SamB> dons: well, your existing tests all pass. which is good, because this module is so ridiculously simple I had better be able to get it right when I didn't even get a type error...
20:12:34 <dons> tasty bot machine
20:12:36 <JFT> Nice!
20:12:41 <dons> SamB: damn straight
20:12:57 <JFT> This beast is just for lambdabot?
20:13:05 <SamB> I mean, with the newtype-ified code, of course
20:13:19 <dons> SamB: yep
20:13:23 <dons> JFT: hehe. no ;)
20:13:27 <dons> but I like to pretend that it is
20:13:31 <JFT> lol
20:13:43 <dons> (it's actually going to be the ghc smp / parallelism benchmark machine
20:13:49 <dons> for the new data parallel arrays)
20:14:01 <dons> (but i might just run lambdabot on it, since its already set up for smp parallelism)
20:14:34 <JFT> Are most Haskeller academics or is there a lot of people on this channel using in "at work"?
20:14:39 <dons> at $AU 23,400, it would be a little much for an irc bot, despite how cool lambdabot is
20:14:54 <SamB> what is an academic?
20:14:58 <SamB> I am a program-person!
20:15:10 <dons> JFT: probably 1/3 language researchers (still), 1/3 students, 1/3 work/commercial/hobby
20:15:15 <SamB> or maybe a plays-around-with-program person
20:15:16 <dons> something like that
20:15:34 <SamB> anyway. they don't teach this stuff where I go to school!
20:15:36 <JFT> dons: Thanks I'm quite please to see that as much as 1/3 might be work/commercial
20:15:55 <dons> most people in here aren't programming language researchers/academics
20:15:59 <JFT> I have some hidden agenda to convince coworker to use it on a future project ;)
20:16:02 <dons> but we've certainly got more than your average irc han
20:16:06 <monochrom> I like Danial Wang's answer to that.  He says he writes OCaml in his head, then types out C++ or something on the keyboard.
20:16:06 <dons> JFT: great.
20:16:12 <dons> heh
20:16:15 <JFT> lol
20:16:24 <SamB> dons: so how come empty doesn't get a test?
20:16:26 <chessguy> hmm, apparent mistake in the haskell video lectures
20:16:26 <dons> JFT: you might be interested in talking to shapr, he's doing a bit of haskell-in-industry work now
20:16:32 <dons> SamB: go for it
20:16:49 <dons> SamB: less talk, more bug fixes == karma for you :)
20:17:18 <JFT> Is anybody aware of a GHC port to the 360? (or PS3)?
20:17:38 <dons> its been discussed, but I don't know of any progress in that area
20:18:13 <JFT> Just "discussed" nobody has started anything ?
20:18:22 * sorear finds it interesting that the two big consoles a bit back had the same name as old popular IBM computers
20:18:24 <dons> jcreigh++ thanks for starting the page
20:18:31 <dons> http://haskell.org/haskellwiki/99_Haskell_exercises
20:18:32 <lambdabot> Title: 99 Haskell exercises - HaskellWiki
20:18:44 <dons> anyone else want to dive in and add more translations to that page!
20:18:47 <jcreigh> dons: I hope I got the formatting right, I hadn't used HaskellWiki before.
20:18:59 <dons> looks ok here
20:19:23 <dons> using == for headings == , and <haskell>foo</haskell> for code blocks?
20:19:26 <SamB> it is so silly how QuickCheck will spend 1000 iterations on a Bool value...
20:19:34 <JFT> sorear: lol just got that!
20:19:54 <dons> jcreigh: add [[Category:Tutorials]] to the page
20:19:59 <dons> so its is indexed in the right place
20:20:17 <jcreigh> dons: just throw that text in at the top of the article?
20:20:35 <dons> anywhere (I prefer the bottom)
20:20:43 <dons> its a meta taggy thing
20:20:52 <dons> (technical terminology)
20:21:32 <chessguy> dons, are you looking for just anyone to work through those exercises?
20:21:33 <SamB> hmm, the autotest fails :-(
20:21:33 <jcreigh> done
20:21:37 <SamB> it can't find the module
20:21:44 <jcreigh> > sequence (map uncurry [(+), (-), (*), (/)]) (3,7)
20:21:49 <lambdabot>  [10.0,-4.0,21.0,0.42857142857142855]
20:22:02 <dons> SamB: did you install first?
20:22:06 <SamB> dons: of course not
20:22:19 <dons> (its using the package system, after all. a good work around for this would be apprciated)
20:22:22 <SamB> I don't want it to test the installed version anyway
20:22:29 <SamB> I want it to test the version I'm trying to record!
20:22:30 <dons> -Ifoo
20:22:41 <dons> or is it -i.
20:22:50 <SamB> autotests that test the wrong version are worse than useless
20:23:00 <chessguy> jcreigh, are you planning on putting solutions to all those problems on that page?
20:23:11 <jcreigh> chessguy: not me personally. :)
20:23:28 <chessguy> it looks like about my speed, i'll work through it if you want
20:23:30 <dons> SamB: less complaints, more bug fixes!
20:23:55 <jcreigh> chessguy: for #2, I'm trying to find something cleaner than (reverse . take 2 . reverse)
20:24:00 * dons tries to school SamB in open source bug fix etiquette
20:24:16 <dons> SamB++ patch: Newtypify, add Monoid instance, add con
20:24:55 <sorear> There are at least two other ways to implement DLists.
20:25:01 <jcreigh> I was thinking for the stuff that's in Prelude, we just say, "look! It's builtin! And here's how short, clean, and elegant the standard definition! Honk if you love lambdas! etc."
20:25:12 <monochrom> honk
20:25:17 <chessguy> @pl \l -> drop ((length l) - 2)
20:25:17 <lambdabot> drop . subtract 2 . length
20:25:33 <chessguy> what about that?
20:25:51 <dons> sorear: oh?
20:25:58 <dons> jcreigh: yes, I like that idea
20:26:01 <dons> show the builtin solution
20:26:09 <dons> then show how to write your own
20:27:06 <chessguy> how do you like that solution, jcreigh?
20:27:30 <SamB> dons: how do I change what it does for tests?
20:27:35 <jcreigh> @pl \l -> drop ((length l) - 2) l
20:27:36 <lambdabot> drop =<< subtract 2 . length
20:27:52 <dons> SamB: "change what it does" -- more info please
20:27:58 <dons> (you mean setpref ?)
20:28:04 <SamB> ah, maybe!
20:28:21 <dons> check the blog details on how i wrote it in the first place, http://cgi.cse.unsw.edu.au/~dons/blog
20:28:22 <lambdabot> Title: Haskell, hacking and other stuff
20:28:24 <syntaxfree> how can I prdouce a list of which GHC packages I have installed?
20:28:28 <dons> ghc-pkg list
20:28:48 * jcreigh starts adding chessguy's solution to the wiki
20:29:03 <chessguy> :)
20:29:21 <dons> ?users
20:29:21 <lambdabot> Maximum users seen in #haskell: 288, currently: 249 (86.5%), active: 34 (13.7%)
20:30:01 <syntaxfree> GHC should really ship with Network.HTTP.
20:30:05 <allbery_b> > let d2 [] = []; d2 l@[_] = l; d2 l@(x:y:[]) = l; d2 (_:xs) = d2 xs in map d2 [[], [1], [1,2],[1,2,3],[1..20]] -- another solution, not especially elegant
20:30:08 <syntaxfree> In the interest of "batteries included".
20:30:10 <lambdabot>  [[],[1],[1,2],[2,3],[19,20]]
20:30:14 <dons> syntaxfree: I agree.
20:30:17 <dons> this will happen
20:30:23 * dons is very keen to polish up http
20:30:33 <syntaxfree> the last release is Jul-2006.
20:30:35 <dons> sounds like a job for ... the hackathon!
20:30:41 <chessguy> @type (!!)
20:30:44 <allbery_b> at least if I understand what people are doing :) haven't looked at the pset
20:30:44 <lambdabot> forall a. [a] -> Int -> a
20:30:48 <syntaxfree> That's either abandoned or mature.
20:30:49 <SamB> dons: okay, now it is working
20:30:57 <dons> SamB: great.
20:31:02 <dons> any other ops you want to implement?
20:31:05 <dons> and any other instances?
20:31:53 <syntaxfree> I should have a Haskell blog.
20:31:53 <SamB> dons: eh, not in particular. I mean maybe other instances would be nice, but those are my main interests.
20:32:10 <dons> ok, add any useful ones you're interested in
20:32:13 <syntaxfree> In english, separated from my semiprofessional economics blog in portuguese.
20:32:19 <dons> syntaxfree: sounds good
20:32:26 <dons> you could syndicate to planet.haskell.org
20:32:32 <dons> (just ping ibid about that, with the rss feed)
20:32:36 <SamB> the point of this for me is that it works nicely for MonadWriter
20:33:10 <syntaxfree> dons: I do post quite a bit of Haskell-related stuff, but it's mixed in with a comparatively larger quantity of economics material, and it's all in portuguese.
20:33:14 <dons> syntaxfree: ah good
20:33:21 <dons> SamB: great idea! I'd not thought of that
20:33:26 <syntaxfree> I did "post" my main two tutorials to the Communities report.
20:33:38 <dons> syntaxfree: have you thought of starting a [pt] subsection of the haskell.org wiki?
20:33:40 <SamB> dons: what? isn't that the whole point of Monoid?
20:33:43 <dons> we already have a spanish and romanian section
20:33:50 <SamB> what, you tell me it has other uses?
20:34:00 <dons> SamB: particularly, Writer, makes sense for an O(1) append system
20:34:16 <SamB> strike that, reverse it
20:34:25 <SamB> an O(1) append system makes sense for Writer
20:34:34 <SamB> also WriterT, really
20:34:39 <syntaxfree> dons: I know of four portuguese-speaking people who use Haskell.
20:34:42 * dons sucks down the caffeine, darcs applies
20:34:49 <syntaxfree> One of them makes a big deal about it, but.
20:34:50 <dons> syntaxfree: yeah, there's plenty more in fact
20:34:53 <syntaxfree> @google uminho
20:34:55 <dons> syntaxfree: the entire Minho university team...
20:34:56 <lambdabot> http://www.uminho.pt/
20:34:56 <lambdabot> Title: Universidade do Minho
20:35:03 <syntaxfree> yes, yes.
20:35:07 <dons> as well as the new portugese haskell textbook!
20:35:15 <syntaxfree> Yes, I saw that.
20:35:16 <dons> (you've seen that? with the unicycle cover?)
20:35:18 <syntaxfree> I was surprised.
20:35:26 <syntaxfree> I wish I had written it before ;)
20:35:26 <jcreigh> hmm... #3 is !!...should we show the error handling code for out-of-bounds conditions, or just assume the index is okay?
20:35:29 <dons> let me create a new Pt page on the wiki, and you can start adding some content...
20:36:11 <SamB> I mean, you probably still want O(1) append even if you are dealing with, say, a WriterT over (inside?) []
20:36:13 <syntaxfree> I'm really trying to cross over to the english-speaking world rather than populating the portuguese-speaking one right now.
20:36:14 <dons> ?babel en pt Haskell in Portugese
20:36:15 <lambdabot>  Haskell em Portugese
20:36:38 <chessguy> jcreigh, doesn't look like the lisp solution does error checking
20:36:38 <syntaxfree> Blogging in portuguese really alienates me from most people who would be interested in the non-economics stuff I care about.
20:37:23 * syntaxfree ponders the relative advantages of Blogspot and Wordpress.com
20:37:32 <dons> syntaxfree: what's the portuguese word for 'Textbooks' ?
20:37:34 <SamB> I had half expected a DList type to show up in Data.Monoid sometime ;-)
20:37:44 <dons> ?babel en pt Textbook
20:37:44 <chessguy> ?babel en pt textbook
20:37:44 <lambdabot>  Textbook
20:37:45 <lambdabot>  textbook
20:37:47 <chessguy> lol
20:37:53 <syntaxfree> "Livros-texto", in general.
20:37:58 <dons> cheers
20:38:00 <syntaxfree> Sometimes "manual".
20:38:09 * dons back after meeting
20:38:11 <SamB> ?babel pt en livros-texto
20:38:12 <syntaxfree> "Livros-texto" is more likely to be used by the publishing industry.
20:38:12 <lambdabot>  book-text
20:38:31 <syntaxfree> "Manual" is more likely to be used by people who use textbooks either for learning or teaching.
20:38:41 <SamB> ?babel en pt book-text
20:38:43 <lambdabot>  livro-texto
20:38:48 <SamB> !
20:39:19 <syntaxfree> Portuguese has a different word order.
20:39:26 <syntaxfree> Rarely adjectives are used before nouns.
20:39:43 <syntaxfree> "Livro vermelho" (word by word, book red), not "Vermelho livro" (word by word red book)
20:39:50 <SamB> I'm remarking over the fact that the s has gone missing
20:40:14 <seba> ?babel jp en umami
20:40:14 <lambdabot> babel module failed: IRCRaised Error: Language jp not supported
20:40:14 <syntaxfree> You usually only see adjective-noun order in ancient poetry.
20:40:14 <chessguy> > let unclear x = not (unclear x) in unclear 3
20:40:17 <lambdabot>  Exception: <<loop>>
20:40:33 <chessguy> > let unclear x = not (unclear x) in unclear False
20:40:34 <syntaxfree> SamB: "Livro-texto" = textbook. "Livros-texto" = textbooks
20:40:34 <lambdabot>  Exception: <<loop>>
20:40:39 <allbery_b> it provided the singular translation for the plural you fed it
20:40:41 <allbery_b> yeh
20:40:49 <monochrom> The pro of wordpress.com is you can take their software and host it wherever you please.  The pro of blogspot is it's google so you and your friends just need the google login.
20:40:58 <SamB> syntaxfree: I suspected as much
20:41:17 * SamB takes doggy out and goes to bed
20:41:17 <syntaxfree> monochrom: I'm already a Wordpress user; I have a blog on my own server.
20:41:23 <seba> ?babel pt en apostila
20:41:24 <lambdabot>  it emends
20:41:25 <syntaxfree> I don't want to host my Haskell blog on this domain, though.
20:41:29 <SamB> dons: goodnight
20:41:46 <syntaxfree> (It's not really my own server, it's my dad's business server, and I'm already using up too much bandwidth)
20:41:52 <chessguy> > let und True y = y; und False y = False; unclear x = not (unclear x) in und False (unclear 0)
20:41:54 <lambdabot>  False
20:41:59 <chessguy> nice
20:42:02 <syntaxfree> I hear Wordpress.com has a lot of restrictions re:templates and all.
20:42:21 <JFT> @help
20:42:21 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
20:42:23 <monochrom> I don't think a haskell blog will receive a slashdot effect.  Har har har.
20:42:26 <JFT> list
20:42:28 <JFT> @list
20:42:28 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
20:42:36 <sorear> http://members.cox.net/stefanor/DList3.hs
20:42:52 <sorear> #1 is simple ; #2 is deforested
20:43:05 <JFT> @search nrf
20:43:05 <lambdabot> Unknown command, try @list
20:43:12 <sorear> #3 is, well, in need of benchmarking
20:43:25 <JFT> search nrf
20:43:41 <base_16> no, but you might suffer the reddit effect :)
20:43:51 <sorear> ?google nrf
20:43:54 <lambdabot> http://www.nrf.com/
20:43:54 <lambdabot> Title: The National Retail Federation
20:44:21 <JFT> doh rnf
20:44:27 <syntaxfree> Well, for one, I'd be in some kind of community.
20:44:37 <syntaxfree> With my current blog, I'm basically a lone voice with a bunch of fans.
20:44:38 <JFT> in Control.Parallel.Strategies
20:44:43 <seba> ?google lambdabot
20:44:44 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
20:44:44 <lambdabot> Title: lambdabot
20:45:31 <JFT> ?hoogle rnf
20:45:32 <lambdabot> Control.Parallel.Strategies.rnf :: NFData a => Strategy a
20:45:56 <syntaxfree> what's a good name for a Haskell blog?
20:46:30 <chessguy> Hog
20:46:32 <sorear> dons: The three implementations of DList : http://members.cox.net/stefanor/DList3.hs  (Warning, the idea dates from my window as an Unlambda programmer)
20:47:01 <base_16> syntaxfree: you gonna focus on anything specific?
20:47:20 <JFT> syntaxfree: Vindaloo (if you like curry ;))
20:47:31 <allbery_b> heh
20:47:32 <syntaxfree> There are actual unlambda programmers?
20:47:45 <allbery_b> or call it ">>="
20:47:54 <JFT> that's to binding :P
20:47:59 <JFT> *too*
20:48:23 <chessguy> jcreigh, hmm. i think reverse should be written more simply
20:48:38 <jcreigh> chessguy: yeah, I was just thinking that.
20:48:59 <jcreigh> chessguy: rather, I was thinking of added a paragraph or two that walked through how the standard definition works.
20:49:05 <jcreigh> *adding
20:49:09 <chessguy> reverse [] = []     reverse (x:xs) = [x] ++ xs
20:49:30 <JFT> Does anybody know what "NF" stands for in NFData? (That page is very low on description...)
20:49:36 <sorear> ?let reverse = foldl (flip (:)) []
20:49:37 <lambdabot> Defined.
20:49:41 <sorear> > L.reverse "hello"
20:49:42 <lambdabot>  "olleh"
20:49:44 <Daveman> chessguy :)
20:49:52 <Daveman> busy playing I see
20:49:54 <chessguy> sorear, yes, but i'm trying to write it more simply
20:50:02 <chessguy> for people coming from another language
20:50:11 <sorear> lisp has folds
20:50:16 <chessguy> Daveman, of course :)
20:50:24 <base_16> ?flip
20:50:24 * lambdabot slaps
20:50:30 <chessguy> sorear, that's fine, but we're trying to implement these as simply as possible
20:50:36 <monochrom> I think you've just defined some kind of identity function.
20:50:49 <chessguy> oh whoops
20:50:53 <allbery_b> a slow identity function :)
20:50:53 <chessguy> xs ++ [x] of course
20:51:08 <sorear> foldr (:) []
20:51:10 <jcreigh> ITYM reverse xs ++ [x]
20:51:40 <chessguy> let reverse [] = []; reverse (x:xs) = xs ++ [x] in reverse "hello"
20:51:45 <chessguy> > let reverse [] = []; reverse (x:xs) = xs ++ [x] in reverse "hello"
20:51:46 <lambdabot>  "elloh"
20:51:55 * chessguy sighs
20:52:05 <chessguy> > let reverse [] = []; reverse (x:xs) = (reverse xs) ++ [x] in reverse "hello"
20:52:06 <lambdabot>  "olleh"
20:52:36 <sorear> hmmm - you can reverse a list by joining the reversed halves in reversed order
20:52:53 <SamB> sorear: the only versions I like are _Fun and _Tree
20:53:25 <sorear> what does _Fold do wrong?
20:54:01 <SamB> it is too mystifying or something!
20:54:05 <sorear> (BTW : is the code in hsLife of any use to you?)
20:54:23 <SamB> oh, haven't looked yet
20:54:28 <SamB> I'm supposed to be in bed ;-)
20:54:39 <SamB> maybe I'll look after finals or something
20:54:52 <SamB> if I can maintain self-discipline long enough!
20:54:59 <jesusphreak> muhaha...I love being able to program...I just got through my statistics class this semester by writing functions (in Python) for different problems I came across
20:54:59 <chessguy> aww, did your parents tell you its past your bedtime, sammy?
20:55:11 <jesusphreak> it would've been so much error-prone work if I had to do it all by hand and calculator
20:55:38 <sorear> do you have to declare IORefs as volatile?  I want to write to one from a signal handler.
20:55:59 <chessguy> jesusphreak, you should bundle your code into a library!
20:56:06 <chessguy> (if it's in haskell)
20:56:21 <monochrom> That must be a poorly administered stats class.
20:56:24 <sjanssen> sorear: hsLife, is that what it sounds like?
20:56:30 <jesusphreak> it is online
20:56:33 <shapr> newsham: When do you add Haskell to the list of languages on your web resume?
20:56:56 <sorear> sjanssen: *Conway* life.
20:56:59 <monochrom> That makes it more certain to be a poorly administered stats class.
20:57:06 <chessguy> ?where library
20:57:06 <lambdabot> I know nothing about library.
20:57:16 <chessguy> dons, where's your write-a-library article
20:57:21 <jesusphreak> thankfully around here the colleges take community college courses as full credit, and the community college by me has lots of online classes
20:57:28 <sorear> ?wiki How to write a haskell program
20:57:28 <lambdabot> http://www.haskell.org/haskellwiki/How to write a haskell program
20:57:29 <sjanssen> sorear: what I suspected.  Is the code online?
20:57:31 <allbery_b> ?where program
20:57:32 <lambdabot> I know nothing about program.
20:57:47 <jesusphreak> so I'm half way to a bachelor's by taking some pretty easy and cheap classes
20:58:08 <chessguy> hmm, i thought there was one more specifically for library-writing
20:58:51 <jesusphreak> but I'm kind of sad...I won't be able to get a CS bach. degree because of the way my credits trasnferred :/
20:59:03 <sorear> sjanssen: darcs get http://members.cox.net/stefanor/hslife && cd hslife && ghc --make UI/GLUT/Main.hs # the cabalization isn't done yet
20:59:14 <kfish> http://cgi.cse.unsw.edu.au/~dons/blog -- how to make a library
20:59:14 <lambdabot> Title: Haskell, hacking and other stuff
20:59:36 <greentea> dons: Just been reading through HTTP.hs - when you wrote "simple get and head functionality" on the Wanted_libraries page, did you mean "a function that provides 'sensible defaults' for GET/HEAD requests"?
20:59:54 <dons> I didn't write it :)
20:59:58 <dons> but i've been thinking about this.
21:00:02 <greentea> Oh?
21:00:11 <dons> so, do you know of a good python, perl ,... http library?
21:00:16 <dons> we could just reimplement that interface
21:00:21 <dons> on top of the existing HTTP.hs
21:00:33 <chessguy> ah, there ya go
21:00:33 <dons> ?google How to write a haskell program
21:00:35 <lambdabot> http://haskell.org/haskellwiki/How_to_write_a_Haskell_program
21:00:36 <lambdabot> Title: How to write a Haskell program - HaskellWiki
21:00:36 <dons> chessguy: ^^
21:00:47 <dons> or did you mean my new blog article on the same topic?
21:00:53 <chessguy> jesusphreak, you should use one of these to bundle up your code into a statistics module
21:00:55 <sorear> dons: http://members.cox.net/stefanor/DList3.hs <--- the three ways, expressed in Haskell
21:01:29 <jesusphreak> I may do that one of these days chess
21:01:40 <shapr> @seen coffeedude
21:01:40 <lambdabot> I haven't seen coffeedude.
21:01:45 <greentea> Well, i don't know if the relevant Perl lib(s) are regarded as 'good' or not. 'Good' in Perl usually means "gets the job done", not necessarily "lovely to use". :-)
21:01:48 <chessguy> if i had the tools, i'd offer to do it for you
21:02:38 <dons> greentea: well, any other system that has an interface you'd like
21:02:50 <dons> (designing a good interface is 60% of the work :)
21:02:54 <dons> so stealing one is a good idea
21:03:04 <jesusphreak> Python always has good quality libraries
21:03:08 <jesusphreak> probably best to scope that out first
21:03:33 <dons> for http?
21:03:36 <dons> got a url?
21:03:44 <chessguy> hmmm
21:03:46 <shapr> Python's urllib is okay.
21:03:46 <dons> (there must be some famous, standard one, surely)
21:04:03 <jesusphreak> dons, no I don't, just a suggestion on where to look :)
21:04:06 <greentea> Meh. Since i'm not at all familiar with Python, and much more familiar with Perl, i would need someone who has experience using HTTP APIs in a variety of langs to make a recommendation as to a good one.
21:04:12 <rongenre> i just showed up.. i've used urllib a lot, it's ok
21:04:19 <shapr> greentea: Are you trying to use Haskell to do http fetching?
21:04:21 <jesusphreak> you know what would be pretty neat for Haskell..
21:04:22 <Pseudonym> Perh's libraries are nice.
21:04:25 <dons> rongenre: any experience with other http libs?
21:04:33 <Pseudonym> I have some experience with it.
21:04:34 <rongenre> client or server?
21:04:39 <chessguy> let fact 0 = 1; fact (x+1) = (fact x) * (x+1) in fact 5
21:04:39 <jesusphreak> of course Haskell isn't used a lot for web programming, but Python's WSGI is pretty brilliant
21:04:42 * shapr can't find the relevant info in the scrollback.
21:04:44 <chessguy> > let fact 0 = 1; fact (x+1) = (fact x) * (x+1) in fact 5
21:04:45 <lambdabot>  Parse error in pattern
21:04:54 <shapr> jesusphreak: Haskell is getting surprisingly much web programming use these days.
21:04:55 <greentea> shapr: i'm looking at working on helping to improve the HTTP module.
21:04:58 <rongenre> dons: client or server?
21:05:09 <shapr> greentea: Oh, so you wanted to see what's done in other languages?
21:05:18 <dons> rongenre: client, I think.
21:05:25 <Pseudonym> LWP::UserAgent is nice.
21:05:30 <dons> shapr: also, Happs must have some good http stuff in it?
21:05:31 <greentea> shapr: Well, dons was suggesting that we use an established non-Haskell API as a guide.
21:05:35 <dons> can we split it up, missingh style, ?
21:05:52 <greentea> dons: That's how the HTTP::* modules in Perl are set up.
21:06:01 <greentea> There's HTTP::Request, HTTP::Response etc.
21:06:09 <chessguy> > let fact 0 = 1; fact (x+1) = (x+1) * (fact x) in fact 5
21:06:09 <sorear> for the Yi super-IRC: how about a module to seamlessly extend scrollback from tunes.org?
21:06:09 <lambdabot>  Parse error in pattern
21:06:12 <jesusphreak> Like I said, I'd love to get something similar to Django up in Haskell once (if) I ever get a hang of the language
21:06:14 <shapr> I haven't gone over all the HAppS code yet, I've been focussed on fixing specific pieces. And musasabi is very sick.
21:06:21 <shapr> jesusphreak: What's so cool about django?
21:06:22 <dons> sorear: nice idea
21:06:22 <chessguy> did x+1 patterns get removed from haskell?
21:06:29 <rongenre> dons:  I do so much jython, turns out the http client stuff I was doing was using java api's
21:06:34 <jesusphreak> Django is just very good about simplicity and being de-coupled
21:06:34 <shapr> heh
21:06:53 <shapr> rongenre: http://www.scannedinavian.com/~shae/blog/images/nokia-emu-jython.png
21:06:55 <jesusphreak> and I think its basic layout would fit haskell well
21:06:56 <lambdabot> http://tinyurl.com/ye3epv
21:07:14 <rongenre> server was pretty easy too... took me a couple hours to export some simple functionality as an http server.
21:07:19 <greentea> Certainly at the moment it doesn't appear that there's an equivalent of a simple request a la "$request = HTTP::Request->new(GET => 'http://www.example.com/')" in Perl.
21:07:46 <dons> jesusphreak: the django layout?
21:07:47 <rongenre> shapr: wow, very nice.. i've had such high hopes for jython
21:07:50 <dons> jesusphreak: nice idea
21:08:03 <shapr> rongenre: That's from years and years ago when the Nokia 9210 SDK was just out.
21:08:21 <rongenre> shapr; at least it's the current jython version ;-/
21:08:39 <shapr> I was irritated that file().read() wasn't ever going to be fixed.
21:08:52 <jesusphreak> well, what I mean is
21:09:09 <Excedrin> greentea: there's: get :: URI -> IO String
21:09:29 <chessguy> > let fact 0 = 1; fact (x+1) = (x+1) * (fact x) in fact 5 -- why doesn't this work?
21:09:30 <lambdabot>  Parse error in pattern
21:09:39 <jesusphreak> Django works by you simply mapping URLs to functions
21:09:49 <dons> mmm. interesting
21:09:55 <dons> I should look into this before the hackathon
21:10:08 <jesusphreak> and it is based around wrapping functions...so in that respect it is a lot more Haskell friendly than perhaps the very class-based Rails
21:10:12 <Excedrin> jesusphreak: have you looked at HAppS?
21:10:19 <dons> jesusphreak: yeah, sounds like it
21:10:21 <sjanssen> chessguy: the pre-parser in lambdabot doesn't understand n+k patterns
21:10:27 <jesusphreak> no, not too much
21:10:37 <jesusphreak> one other thing is the Django templating language would work well for really any language
21:10:45 <jesusphreak> and probably would be rather trivial to do in Haskell
21:10:46 <chessguy> oh, it's a lambdabot thing?
21:10:55 <base_16> chessguy: it works in ghci
21:10:56 <chessguy> ah, nice
21:10:57 <dons> sjanssen: interested in having a look at django, re. improving an http lib for haskell, over the winter?
21:11:02 <chessguy> yes, it does
21:11:07 <chessguy> silly bot
21:11:11 <dons> sjanssen: i.e. both of us, and anyone else who wants to chip in?
21:11:38 <jesusphreak> unfortunately I've gotten a little distracted by Common Lisp...I dunno if I should look into it or Haskell more...both are very interesting to me
21:11:44 <jcreigh> @paste
21:11:44 <lambdabot> http://paste.lisp.org/new/haskell
21:11:44 <sjanssen> chessguy: it's actually Language.Haskell, the library that lambdabot uses that is at fault
21:11:54 <dons> jesusphreak: you know haskell is the grandchild of lisp, yeah?
21:11:58 <chessguy> interesting
21:12:02 <dons> so it fixes many of the problems in the lisp world :)
21:12:03 <sjanssen> dons: sure
21:12:11 <dons> i.e. parens, community, standards, ... :)
21:12:11 <syntaxfree> http://syntaxfree.wordpress.com/
21:12:13 <lambdabot> Title: Data.Syntaxfree
21:12:15 <syntaxfree> my new Haskell blog.
21:12:27 <jesusphreak> whoa, Happs http server performs better than PHP and Apache? neat
21:12:30 <dons> sjanssen: ok. i'll see if I can work out how to make this happen
21:12:39 <dons> jesusphreak: yeah, its heavily optimised with lovely fusible bytestring io
21:12:46 <allbery_b> ...CLOS... :)
21:13:01 <lisppaste2> jcreigh pasted "Solution to lisp problem #7" at http://paste.lisp.org/display/32092
21:13:15 <jcreigh> what do you guys think about that solution? Is there a nicer way to do it?
21:13:20 <Excedrin> how can it be a Haskell blog on wordpress?
21:13:28 <dons> heh
21:13:42 <jcreigh> Excedrin: why not?
21:13:45 <jesusphreak> no, dons, didn't realize haskell was lisps, 'grandchild'...but most modern languages are, no?
21:13:58 <dons> syntaxfree: I've created a new portuguese language subsection for haskell.org, http://haskell.org/haskellwiki/Haskell (click on the 'pt' link)
21:13:59 <lambdabot> Title: Haskell - HaskellWiki
21:14:03 <dons> if you want to check and add anything
21:14:11 <base_16> jesusphreak: there are many languages that are not derived from lisp
21:14:19 <dons> jesusphreak: oh. its directly a child though, in the lambda calculus/functional programming tradition
21:14:22 <rongenre> Hey.. I'm doing some perl-ilke stuff, using ByteStrings to go through a big delimited file line-by-line.  I've got some int fields, is there's an efficient way to turn ByteStrings (from split) into ints/floats?
21:14:25 <dons> adding more functional programming though
21:14:32 <dons> (i.e. purity, laziness, pattern matching , ...)
21:14:39 <jesusphreak> ah, got ya
21:15:11 <chessguy> jcreigh, nice one. i would've thrown that one out for not being a "haskell problem"
21:15:20 <svref> I'm working with MiniHTTP, and readPage works, only problem is it takes, like, 3 minutes to download a page, that downloads in .1 seconds in a web browser.  Thoughts on why this could be?
21:15:35 <dons> you start with lisp, get to statically typed lisp (ML), add laziness, add whitespace to solve the parens stuff, add syntax sugar (for human programmability), and finally, add purity (i.e. true functional programming), and you've got haskell
21:16:21 <jcreigh> chessguy: what? not a "haskell problem"? No such thing! :)
21:16:32 <dons> svref: have you seen the improved MiniHTTP in lambdabot?
21:16:38 <chessguy> ?remember dons you start with lisp, get to statically typed lisp (ML), add laziness, add whitespace to solve the parens stuff, add syntax sugar (for human programmability), and finally, add purity (i.e. true functional programming), and you've got haskell
21:16:39 <svref> not sure
21:16:49 <chessguy> jcreigh, true. i meant it as a good thing though :)
21:16:52 <dons> would be very worth rewriting to use bytestrings
21:17:02 <svref> dons: how do I look at this improved MiniHTTP?
21:17:03 <dons> (and i'm pretty sure bringert's done something in this area)
21:17:05 <dons> we should ask him
21:17:17 <dons> http://www.cse.unsw.edu.au/~dons/lambdabot/Lib/MiniHTTP.hs
21:17:33 <dons> svref: but bringerts implemented some big data handling lazy bytestring http stuff
21:17:41 <Excedrin> http://merd.sourceforge.net/pixel/language-study/diagram.html
21:17:42 <lambdabot> Title: diagram & history of programming languages
21:17:50 <Excedrin> neat diagrams of language history
21:18:05 <monochrom> Ah yeah, lazy read on http requests.
21:18:37 <monochrom> I am not sure whether it is a good idea, and whether it is important.
21:20:11 <dons> sjanssen: we might want to look into this django stuff in the context of hackage
21:20:23 <dons> since that's web programming, presenting all the stats and so on
21:20:25 <kfish> monochrom, it sounds very useful to me
21:20:41 * dons needs a motivating project to really get into this kind of hacking
21:20:50 <chessguy> jcreigh, let me know when you get tired of working through those, and i'll work on them
21:22:25 <dons> kfish: you're just starting your phd right? want to help change the world? :)
21:22:30 <greentea> dons: The problem with choosing an existing API as a model is that it will inevitably make some people happier than others, whereas with a new one, everyone can be more equally unhappy. ;-)
21:22:33 * dons tries to squeeze more code out of kfish
21:22:41 <dons> greentea: hah!
21:22:42 <monochrom> A problem with lazy read is this.  In the middle of the stream, the source introduces an error.  You will get pretty little information on the error.  This is also why Parsec reads eagerly.
21:23:02 <jesusphreak> speaking of phd...I have a question that some of you may be able to answer
21:23:16 <monochrom> The answer is: don't do a phd. XD
21:23:32 <jesusphreak> can you start working on a masters in CS if you have a bachelors in arts and not in science (and obviously not CS) ?
21:23:50 <sorear> yes
21:23:53 <monochrom> Yes, provided you know enough CS to convince someone to admit you.
21:23:58 <jesusphreak> I see
21:24:05 <chessguy> > group [a, a, a, a, b, c, c, a, a, d, e, e, e, e]
21:24:06 <lambdabot>  Not in scope: `e'
21:24:11 <sorear> because "working on a masters" includes "satisfying any prerequisites" :)
21:24:14 <greentea> dons: Hah?
21:24:34 <dons> "equally unhappy" :)
21:24:34 <sjanssen> dons: do you know how HApps compares to Django?
21:24:38 <sjanssen> anybody used both?
21:24:39 <chessguy> > group ['a', 'a', 'a', 'a', 'b', 'c', 'c', 'a', 'a', 'd', 'e', 'e', 'e', 'e']
21:24:41 <lambdabot>  ["aaaa","b","cc","aa","d","eeee"]
21:24:43 <dons> sjanssen: no, we need to find out
21:24:50 <dons> shapr: how does HAppS compare to Django?
21:24:50 * greentea has been experiencing signal loss problems with her net connection. :-|
21:24:52 <lisppaste2> jcreigh annotated #32092 with "Slightly different version" at http://paste.lisp.org/display/32092#1
21:24:53 <jesusphreak> glancing over happs it looks quite different from Django
21:24:59 <greentea> dons: Ah. :-)
21:25:05 <jesusphreak> but I am only familiar with Django so I couldn't really say anything other than that
21:25:18 <jesusphreak> and I'm familiar with Rails, but I'd rather not talk about that ;)
21:25:27 <greentea> Excedrin: Is that function in the HTTP module, or one of the submodules?
21:25:31 * shapr asks google about django
21:25:40 <jesusphreak> djangoproject.com
21:25:50 <jesusphreak> some of the best docs you'll find in an open source project
21:26:24 <Excedrin> which other pure lazy functional languages were around when Haskell was created? (Miranda, Lazy ML, anything else?)
21:26:26 <chessguy> > group [1, 1, 1, 1, 2, 3, 3, 1, 1, 1, 5, 5, 5, 5]
21:26:27 <lambdabot>  [[1,1,1,1],[2],[3,3],[1,1,1],[5,5,5,5]]
21:26:52 <chessguy> > ((map head) . group [1, 1, 1, 1, 2, 3, 3, 1, 1, 1, 5, 5, 5, 5]
21:26:53 <lambdabot>  Parse error
21:26:55 <monochrom> Was Gofer lazy?
21:27:09 <rongenre> wow, gofer.. forgot about that one
21:27:11 <rongenre> caml
21:27:12 <chessguy> > (map . head . group) [1, 1, 1, 1, 2, 3, 3, 1, 1, 1, 5, 5, 5, 5]
21:27:13 <lambdabot>  Couldn't match `a -> b' against `[a1]'
21:27:15 <jcreigh> I think I'm going to add the latter version to the wiki
21:27:16 <rongenre> er.. not lazy
21:27:29 <rongenre> icon?  was that lazy?
21:27:36 <Excedrin> greentea: it's in test/get.hs :)
21:27:41 <chessguy> > ((map . head) . group) [1, 1, 1, 1, 2, 3, 3, 1, 1, 1, 5, 5, 5, 5]
21:27:42 <lambdabot>  Couldn't match `a -> b' against `[a1]'
21:27:48 <syntaxfree> who is responsible for Planet Haskell again?>
21:28:00 <shapr> ibid
21:28:15 <monochrom> caml is eager
21:28:23 <sorear> caml is impure
21:28:28 <chessguy> @pl map (head) (group l)
21:28:28 <lambdabot> map head (group l)
21:28:39 <greentea> Excedrin: Ah, i see, thanks. So perhaps this should actually be included in the library itself?
21:29:04 <chessguy> map (head) (group l) [1, 1, 1, 1, 2, 3, 3, 1, 1, 1, 5, 5, 5, 5]
21:29:10 <chessguy> > map (head) (group l) [1, 1, 1, 1, 2, 3, 3, 1, 1, 1, 5, 5, 5, 5]
21:29:10 <lambdabot>  Not in scope: `l'
21:29:29 <chessguy> > map (head) (group [1, 1, 1, 1, 2, 3, 3, 1, 1, 1, 5, 5, 5, 5])
21:29:30 <lambdabot>  [1,2,3,1,5]
21:29:46 <chessguy> there's not a point-free version of that?
21:30:03 <chessguy> @pl \l -> map (head) (group l)
21:30:03 <lambdabot> map head . group
21:30:07 <chessguy> oh there we go
21:30:52 <mathewm> gnight all
21:31:23 <rongenre> yeah you're right, i was thinking of languages where were available around 1993
21:31:34 <rongenre> prolog may count, you could do lazy in prolog
21:31:54 <svref> dons: so...yes, I've now tried that one too.  It also takes quite a long time (its been thinking about getting a page now for, oh, 5mins)...I built ghc-6.6 from source to get either of em to work...ghc-6.2.2 (debian stable) didn't have uriRegName for some reason...maybe I did that wrong.
21:32:21 <dons> svref: very strange. svref check bjorn bringerts projects
21:32:32 <dons> somewhere in there is a big, fast http system, using lazy bytestrings
21:32:42 <dons> ( i know he's sucked down gigabytes effectively)
21:32:46 <chessguy> jcreigh, there's a solution to #8. compress = map head . group
21:33:23 <svref> dons: (its probably clear, but nothing's eating cpu, it almost smells like the system's IO blocking)
21:33:29 <dons> chessguy, are you guys putting the solns up on the wiki
21:33:32 <dons> svref: yeah
21:33:38 <dons> chessguy: I see you are. great!
21:33:40 <chessguy> dons, jcreigh is
21:33:53 <chessguy> i'm trying hard not to duplicate his efforts
21:34:21 <jcreigh> chessguy: I'm editing it right now adding #7. I'll let you know when you can add #8.
21:37:41 <dons> chessguy, jcreigh I suggest adding, first, the example soution
21:37:46 <dons> i.e.
21:37:47 <dons> Reverse a list.
21:37:51 <dons> reverse [1..10]
21:37:56 <dons> [10,9,8..]1
21:37:59 <dons> then explain how its implemented
21:38:01 <greentea> Hmm, perhaps if nothing else, i can write test cases for HTTP . . . .
21:38:50 <dons> greentea: if you want to do a survey of good apis, that would be a great start
21:38:55 <dons> then start coding up the best one :)
21:39:26 <greentea> Well, i meant for HTTP the module, rather than HTTP the protocol. :-)
21:39:40 <syntaxfree> what's the lamdabot command to send a message to someone?
21:39:50 <Pseudonym> ?help tell
21:39:50 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
21:39:59 <greentea> i've leave other people to fight over what the 'best' API is. :-)
21:41:00 <dons> a good start would be to take -package http, and clean it up for the 21st century
21:41:07 <dons> haddocks, cabal, readmes, examples, tests
21:41:10 <dons> then port to bytestring
21:41:11 <jcreigh> chessguy: done (for now) with #7
21:41:15 <dons> and then port to some nice api
21:41:48 * syntaxfree volunteers.
21:41:55 <greentea> dons: Yep, i can definitely start on the tests part.
21:42:00 <chessguy> jcreigh, do you want me to do #8 ?
21:42:05 <jcreigh> chessguy: sure.
21:42:19 <dons> ok. can you grab the http package, and start  a darcs repo fork?
21:42:19 <syntaxfree> tomorrow, though.
21:42:24 <chessguy> did you see dons' suggestion for formatting?
21:42:28 <dons> greentea: do you have somewhere to host it?
21:42:32 <dons> (i can do that if you want)
21:42:47 <jcreigh> dons: I don't quite get what you mean. You mean more explaination of how it actually works than just "here's the code"?
21:43:01 <syntaxfree> dons: I'll talk to you about it tomorrow night.
21:43:04 <greentea> dons: Well, i've just darcs-got that package to my laptop . . . . i don't have any public location to host it.
21:43:06 <syntaxfree> Now I should get to sleep.
21:44:12 <shapr> jesusphreak: Speaking of docs, I really need to improve HAppS-docs
21:45:09 <dons> jcreigh: no. i mean, show the example of it in use first
21:45:12 <dons> then the current text
21:47:26 <jcreigh> dons: hmm, good idea, examples are good.
21:49:46 <dons> jcreigh: i.e. show them what they have to type into ghci, to reverse a list
21:49:50 <dons> that is:   reverse [1..10]
21:49:51 <dons> is all
21:53:25 <chessguy> hmmm, my addition didn't format very well
21:53:39 <sjanssen> shapr: can you recommend some nice example code to learn HApps?  the stuff in HApps/examples/ is a bit too simple
21:54:08 <sorear> poll: Where in the HHL should I put generic serialization?  Data.Serialization.Generic?
21:54:41 <sjanssen> sorear: if it uses Data.Generic, I'd put it in Data.Generic.Serialization
21:54:57 <shapr> sjanssen: Did you see the wiki I wrote?
21:55:01 <shapr> I'm cleaning it up even now...
21:55:06 <monochrom> I didn't realize HHL has such an apt dual meaning!
21:55:13 <dons> sjanssen: or Data.Generic.Serial
21:55:35 <sjanssen> shapr: I have not, but I think that would fit the bill
21:55:53 <sorear> what would HHL's other meaning be?  I was just being a compulsive abbreviator.
21:55:54 <shapr> Lemme push today's changes...
21:56:06 <monochrom> It pronounces as "hell"
21:56:32 * sorear thinks vim's ^X^K would make a very useful addition to an IRC client
21:56:34 <jcreigh> chessguy: If you're not working on the page right now, I'll try to fix that, since there's a few other formatting quirks that I'm going to fix anyway.
21:56:58 <chessguy> hang on one second
21:57:03 <jcreigh> sure
21:57:38 <chessguy> ok, i patched it up somewhat
21:57:52 <chessguy> we should decide on a basic format for each solution
22:01:51 <jcreigh> chessguy: I think #8 looks nice. I think I'm going to pull the description (not the lisp example code) out of a <pre>, so that it wraps properly.
22:02:27 <chessguy> ok
22:03:05 <chessguy> we should divide the problems up somehow, you work on some, and me work on some
22:03:45 <dons> parallelise!
22:03:49 <dons> divide and conquer!
22:03:49 <jcreigh> well, I'm just about to go to bed, so you can have your pick. <g>
22:04:04 <dons> there's 200 people in the channel, and 99 problems....
22:04:11 <chessguy> well, i'll probably get to bed before too long too
22:04:19 <shapr> sjanssen: darcs get http://www.scannedinavian.com/~shae/happswiki/
22:04:20 <lambdabot> Title: Index of /~shae/happswiki
22:04:22 <dons> everyone, pick a problem from here: http://haskell.org/haskellwiki/99_Haskell_exercises
22:04:23 <lambdabot> Title: 99 Haskell exercises - HaskellWiki
22:04:32 <chessguy> but we should agree on something so that we can work on them whenever
22:04:33 <dons> write down the canonical haskell solution, put it on the wiki
22:04:36 <dons> we'l be done in 30 minutes
22:04:44 <chessguy> lol
22:04:49 <chessguy> dons, some of them are non-trivial
22:04:50 <dons> chessguy: you could put a little list up on a sub page, with 1..99
22:04:57 <jcreigh> ...using #8 as a template for the format.
22:04:57 <dons> and then people can assign names if  they're working on them
22:05:13 <dons> if the process is clear, we can announce on haskell-cafe@
22:05:25 <chessguy> ok, is it free to edit, jcreigh?
22:05:32 <jcreigh> chessguy: yup
22:05:37 <dons> btw, I'd put ghci output inside <haskell> tags
22:05:47 <sjanssen> shapr: thanks
22:05:56 <jesusphreak> does Haskell have anything like Ruby's gems?
22:06:03 <dons> jesusphreak: we have cabal packages
22:06:19 <dons> which all configure, build and install identically
22:07:09 <dons> jesusphreak: is that what you meant about gems?
22:07:13 <sjanssen> I'll take problems 9 and 10
22:07:15 <shapr> Isn't problem 8 solved by nub?
22:07:28 <jesusphreak> hmm, something one might do in ruby is like 'gem --install rails' or such from the command line, and it'd instantly find the program and install it
22:07:41 <jesusphreak> or I should say libary
22:07:41 <dons> ah right. so that's cabal-get
22:07:43 <shapr> jesusphreak: cabal-get
22:07:44 <dons> which is in beta
22:07:48 <jesusphreak> no way!
22:07:52 <dons> i'd expect it to be done by january
22:07:53 <jesusphreak> wow that's cool
22:08:19 <chessguy> ok, check out the problem n template
22:08:26 <dons> we've been working on our top secret alien lambda technology for the last 15 years, now the focus is on conquering and subjugation
22:08:31 <jesusphreak> heck, even Python doesn't have a 100% system, that's pretty neat if Haskell has one
22:08:35 <chessguy> i plan on copying that 91 more times, changing n for each
22:08:37 <chessguy> sound good?
22:08:38 <Excedrin> I guess the translation of a list of symbols to Haskell is simplest as a list of char?
22:08:39 <jesusphreak> the Haskell community seems very busy with practical stuff
22:08:42 <dons> chessguy: ok good
22:08:55 <shapr> jesusphreak: And research too!
22:09:05 <chessguy> it's a great time to be a haskeller :)
22:09:22 <dons> I agree, it feels very exciting
22:09:28 <shapr> yeah!
22:09:52 <dons> you can kinda tell somethinng's happening, our irc channel is almost always near its record high
22:10:07 <dons> whereas the big channels are quite a bit down from the maximum
22:10:10 <dons> (ie. python)
22:10:20 <dons> ruby's the other exception, of course.
22:11:17 <dons> i.e. #python: Current: 259, Max: 468
22:11:33 <Syrin> So, uh.. I just found out about Haskell from my friend who's been wanting to learn it for a while, but he's been too busy. So now we're both sort of learning Haskell in bits and steps, and I have about 11 lines of code now that should work, but one, apparently, doesn't.
22:11:35 <dons> whereas, right behind it: #haskell Current: 250, Max: 286
22:11:46 <jcreigh> chessguy: okay, if you're not hacking on the page right now, I'll go back and convert my solutions to match the template.
22:12:01 <sjanssen> @where paste
22:12:01 <lambdabot> http://paste.lisp.org/new/haskell
22:12:01 <dons> Syrin: ok. great.
22:12:02 <Syrin> Is it alright if I copy+paste code into here?
22:12:09 <dons> use @paste's url
22:12:14 <dons> ?paste <-- here
22:12:14 <lambdabot> http://paste.lisp.org/new/haskell
22:12:19 <chessguy> jcreigh, WAIT
22:12:25 * jcreigh waits
22:12:28 <chessguy> i'm copying the template
22:12:31 <chessguy> a lot of times :)
22:12:39 <jcreigh> man, threading is such a bad way to do concurrency. :)
22:12:40 <Syrin> Oh, wow, that's pretty cool >_>
22:12:57 <shapr> chessguy: tell us when you've got numbers in place...
22:13:17 <dons> I'd like to get this 99 problems thing done in the next 2 days
22:13:19 <monochrom> threading is ok if you don't have to create them by hand...
22:13:19 <dons> and then up on reddit
22:13:26 <chessguy> dons, some of them are hard
22:13:28 <dons> to take advantage of the 99 lisp thingy at the moment
22:13:45 <dons> (i.e. we got agile by the bucket load ;)
22:13:51 <lisppaste2> Syrin pasted "The last line" at http://paste.lisp.org/display/32100
22:13:59 <jcreigh> also, since they're translated from Prolog, many of them still have Prolog example code.
22:14:00 <Syrin> It's the last line that's not working right
22:14:03 <Syrin> And I have no idea why
22:14:28 <Syrin> Oh, shoot, I didn't include mullc in there. it's just mullc (a:as) n = a*n : mullc as n
22:14:41 <araujo> @yarr!
22:14:41 <lambdabot> Is that a hornpipe in yer pocket, or arr ya just happy ta see me?
22:14:57 <augustss> @yow
22:14:57 <lambdabot> I used to be a FUNDAMENTALIST, but then I heard about the HIGH
22:14:57 <lambdabot> RADIATION LEVELS and bought an ENCYCLOPEDIA!!
22:14:57 * shapr does number 12
22:15:03 <shapr> hej augustss
22:15:06 <augustss> hej
22:15:11 <chessguy> i'm up to 40, this is tedious
22:15:15 <shapr> fÃ¥ du trÃ¤ffa alexj idag?
22:15:29 <chessguy> you know what, they can change the n for each one
22:15:31 <chessguy> this is silly
22:15:39 <jcreigh> chessguy: Can't you just tell your editor to paste it 90 times?
22:15:43 <sjanssen> Syrin: do you get a compile error, or what?
22:15:45 <chessguy> there's a number at the beginning of each line
22:15:48 * araujo does the lambda dancing
22:15:48 <Syrin> Yea, a compile error
22:15:56 <Adamant> @(elite . yarr!)
22:15:57 <lambdabot> . y4RR!)
22:16:01 <sjanssen> Syrin: please paste the error too :)
22:16:09 <Syrin> I can't copy-paste out of ghci :S
22:16:18 <chessguy> ok, let me just add some instructions quick, then you can change yours
22:16:21 <dons> chessguy: do you need a little regex to do the numbering for you?
22:16:27 <shapr> sjanssen: That happswiki source is a work in progress for the last few hours, so if anything is confusing, tell me and I'll fix it as fast as possible :-)
22:16:30 <sorear> Syrin: why not?
22:16:38 <Syrin> I have no idea why
22:16:42 <sorear> case system of
22:16:52 <sorear>   xterm -> Shift drag
22:16:58 <sjanssen> Syrin: it looks like you forgot a parameter to addc in the first line of checktotal
22:17:06 <Syrin> What?
22:17:18 <chessguy> dons, it's ok, i'll let them do it themselves :)
22:17:21 <jcreigh> chessguy: are you using vim?
22:17:21 <dons> ok
22:17:22 <augustss> shapr: alexj?
22:17:24 <sorear>   Windows -> Right click on system-menu , select Mark, Copy
22:17:31 <shapr> augustss: Alex Jacobson?
22:17:40 <dons> chessguy: also, set __NOTOC__ at the top of the page
22:17:46 <sjanssen> Syrin: you have "addc c", but it looks like addc should take two parameters
22:17:47 <dons> since we don't need the table of contents
22:17:50 <shapr> augustss: Maybe I'm just confused =)
22:17:52 <Syrin> Uh
22:17:55 <augustss> shapr: not that i know
22:18:05 <Syrin> Oh, right
22:18:06 <Syrin> >_>
22:18:16 <Syrin> That should actually be just 'c', I don't know why addc is there
22:18:21 <augustss> i'm meeting jeff polakow for a beer tomorroe night
22:18:38 <Syrin> That doesn't change the error though
22:18:38 <sjanssen> Syrin: also, addc will always fail because you don't handle the empty list
22:18:49 <Syrin> Oh..
22:19:23 <chessguy> ok, refresh and see how it looks
22:19:26 <Syrin> The error is still the same
22:19:31 <chessguy> i hope i didn't make any typos 92 times :)
22:20:19 <jcreigh> chessguy: nothing :%s can't fix, I'm sure. :)
22:20:23 <sorear> couldn't you just map a correction function over the wiki?
22:20:38 <jcreigh> chessguy: looks good, I'll update my solutions to match the new format.
22:20:40 <sjanssen> Syrin: can you really not copy from ghci?
22:20:42 <chessguy> :%s ?
22:20:52 <lisppaste2> Syrin annotated #32100 with "The error" at http://paste.lisp.org/display/32100#1
22:20:54 <sorear> chessguy: vi global-search-replace
22:20:56 <shapr> augustss: Too bad I won't be in NYC tomorrow.
22:20:59 <chessguy> aha
22:21:04 <Syrin> It was a problem with the propertis :p
22:21:04 <sorear> vi for M-x replace-regexp
22:21:09 <Syrin> Quick-edit wasn't enabled
22:21:22 <shapr> augustss: Oh, I will be in Stockholm for a coupla weeks in April, will you be in the area?
22:21:25 <augustss> shapr: ping me when you are
22:21:48 <augustss> shapr: unlikely, i'll be in London
22:21:51 <shapr> Ah, too bad.
22:22:12 <sjanssen> Syrin: in addc, you probably want "a + b : addc as bs", ie without the brackets
22:22:31 <Syrin> ...whoops >_>
22:22:36 <shapr> I may be in NYC for a happs sprint at some point.
22:22:44 <chessguy> dons, should we suggest a way on the wikipage to let people know that it's being edited at the moment?
22:22:46 <Syrin> That was, incidentally, the first code I wrote :p
22:22:59 <Syrin> Wow, thanks, that fixed it
22:22:59 <chessguy> otherwise we're going to have concurrent editing issues if we solve 200 problems in 2 days
22:23:04 <shapr> yeah
22:23:17 <shapr> Or we could split it into problems 10 - 19, etc
22:23:23 <shapr> Take the cs solution, ABSTRACT!
22:23:26 <sjanssen> > zipWith (+) [1, 2, 3] [4, 5, 6] -- Syrin, is this a good replacement for addc? ;)
22:23:29 <lambdabot>  [5,7,9]
22:23:29 <dons> yeah, spit the page into chunks of 10
22:23:32 <shapr> coi djul .i ma nuzba
22:23:42 <Syrin> Yea, it probably is
22:23:53 <dons> ie. /0_10 subpage
22:23:54 <dons> and so on
22:24:23 <dons> make the locks more fine grained ;)
22:24:30 <Excedrin> I'm doing 20... it seems easy
22:24:37 <dons> (and people should be editing the subsections only anyway)
22:24:53 <sjanssen> how do we respond to problems that require heterogenous lists?
22:24:56 <shapr> I just did 14 and 15 instantly.
22:25:10 <dons> sjanssen: existential lists, I think, would be bst
22:25:12 <chessguy> ugh, i think i better not break it apart while people are hacking on it
22:25:25 <dons> sjanssen: using a typeclass for the common operations
22:25:39 <monochrom> I use a two-phase commit.  I read, then I draft (no commit yet), then I read again to see if other's modification conflicts, if no conflict then I commit quickly.  (If conflict, oh well, have to revise draft...)  (STM anyone? :) )
22:25:49 <shapr> How does MediaWiki handle conflicts?
22:25:51 <dons> its really born for STM, isn't it
22:26:05 <monochrom> heh
22:26:09 <shapr> ISAGN as Igloo would say...
22:26:12 <dons> sjanssen: like this? http://programming.reddit.com/info/twtt/comments/ctxl6
22:26:13 <lambdabot> Title: You have exceeded your Internet quota
22:26:15 <shapr> STM-wiki here we come!
22:26:17 <dons> bah!
22:26:22 <dons> thanks lambdabot
22:26:32 <chessguy> time for someone to design a web-based collaborative editing tool in haskell!
22:26:35 <shapr> Whoa lambdabot got tinyurl upset.
22:26:46 <monochrom> hahahahaha
22:26:49 <chessguy> ?tiny http://programming.reddit.com/info/twtt/comments/ctxl6
22:26:50 <lambdabot> http://tinyurl.com/y35xsj
22:26:53 <dons> http://programming.reddit.com/info/twtt/comments/ctxl6
22:26:54 <lambdabot> Title: Functional programming is a silver bullet (reddit.com)
22:27:08 <dons> (fixed, but dialup download speeds only till the admins increase my quota)
22:28:31 <shapr> augustss: Anyway, I'd be happy to give you an enhjuling lesson next time we meet. You'd be in good company since I have pix of John Hughes and SPJ on unicycles already.
22:28:40 <shapr> Oh, and edwinb too!
22:28:49 <shapr> and Philippa, I think...
22:28:53 * shapr looks around
22:29:00 <monochrom> this unicycle is infectious like haskll
22:29:01 <Pseudonym> You know, at the interview I went to today, they said that there was a serious shortage of C++ people.
22:29:10 <Pseudonym> Because everyone is so infected by Java.
22:29:13 <chessguy> heh. i think i'm officially addicted. i'm chatting in #haskell, helping hack on a haskellwiki page, browing a reddit thread about haskell, while playing a haskell video lecture in the background
22:29:15 <Pseudonym> That's quite funny, actually.
22:29:28 <dibblego> chessguy, haskell lecture - url?
22:29:37 <chessguy> Pseudonym, in this area it's hard to find java programmers
22:29:38 * shapr tokes on a lambda and passes it to chessguy 
22:29:40 <dibblego> Pseudonym, I agree, thoroughly amusing
22:29:41 <monochrom> @remember chessguy heh. i think i'm officially addicted. i'm chatting in #haskell, helping hack on a haskellwiki page, browing a reddit thread about haskell, while playing a haskell video lecture in the background
22:29:47 <Pseudonym> I had great hopes for Java.  That people would say: "Well, I have a job to do, and I could do it in either C... OR in Java!"
22:29:53 <chessguy> dibblego, http://lambda-the-ultimate.org/node/1303
22:29:54 <lambdabot> Title: Haskell video lectures online | Lambda the Ultimate
22:29:59 <dibblego> chessguy, ta
22:30:00 <Excedrin> ugh, some of these are stupid... the Lisp P20 breaks if you give it 0; it expects lists to start at 1
22:30:07 <shapr> hiya Randroid, how's code?
22:30:14 <Pseudonym> So it would be a gateway language.  People would get that you can use more than one language in your career.
22:30:20 <Pseudonym> And it's had the exact opposite effect.
22:30:20 <chessguy> aww, monochrom, you could've fixed my typo while you were at it :)
22:30:32 <monochrom> there is a typo?!
22:30:33 <Randroid> Excellent, shapr.
22:30:40 <chessguy> s/browing/browsing/
22:30:54 <shapr> Pseudonym: I don't think anything will ever get lazy people to stop being lazy.
22:31:17 <dibblego> shapr, are they truly lazy or just misled?
22:31:22 <monochrom> OH!  I didn't know browing was a typo!  I have always secretly wanted to brow reddit comments!
22:31:30 <chessguy> lol
22:31:31 <Pseudonym> Especially not Haskell.
22:31:31 * greentea heads off to concentrate on learning how to set up tests.
22:31:34 <Pseudonym> Laziness is a virtue.
22:31:34 <greentea> Later all.
22:31:36 <monochrom> I meant blow.
22:31:52 * Randroid will never touch blow again.
22:32:47 <chessguy> i'm looking forward to my new job. they tell me i'm going to be cutting and pasting a lot of javascript/html/perl code. i'm going to show them how using haskell to auto-generate the code will reduce the payload enormously!
22:33:21 <Randroid> What a strange-sounding job, chessguy.
22:33:33 <dons> nice. are you going to use one of the javascript or html DSL libraries?
22:33:41 <chessguy> Randroid, yeah i think so too
22:33:46 <chessguy> dons, i'm not sure yet.
22:34:10 <dibblego> chessguy, you downloaded all 26 lectures? they are ~700MB each!
22:34:17 <chessguy> i'm very curious why any technical company is having its employees do a lot of repetitive actions
22:34:31 <chessguy> dibblego, no, i'm downloading them one at a time
22:34:38 <dibblego> chessguy, because it pays $$$
22:35:09 <chessguy> dibblego, surely it's COSTing them money to pay their programmers
22:35:31 <dibblego> you would think so, but I concluded otherwise after working for IBM for a few years
22:35:36 <monochrom> "If I'm not chatting in #haskell, I'm editing haskellwiki.  If I'm not editing haskellwiki, I'm watching haskell lectures."  Assuming the speaker cannot do more than one thing at a time, what is he doing?
22:36:19 <chessguy> hmmm
22:36:31 <allbery_b> talking about haskell? :)
22:36:38 * dibblego breaks open first-order logic rules of inference
22:37:04 * chessguy bribes someone from #logic to help him
22:37:26 <jcreigh> hmm, bedtime. I'll look at more cleanups tomorrow night.
22:38:00 <chessguy> jcreigh, ok. see you later
22:38:37 <chessguy> is anyone working on that wiki page, or can i work on breaking it into subpages?
22:39:17 <chessguy> dons, how do i create a new page?
22:39:27 <dons> you just type the intended url into your browswer
22:39:39 <dons> ?wiki 99_questions/1_to_10
22:39:40 <lambdabot> http://www.haskell.org/haskellwiki/99_questions/1_to_10
22:39:42 <dons> for example
22:39:52 <chessguy> cool
22:39:54 <dons> (choose something appropriate for the stem, and that's the page title)
22:45:58 <Excedrin> ugh the Lisp remove-at (problem 20) inserts a bunch of NIL into a list when the index is past the end of the list
22:46:06 <dons> urgh
22:46:17 <dons> (you should note down these flaws in the lisp solutions, I think...)
22:46:28 <Excedrin> I'm not going to bother duplicating its behavior exactly
22:46:32 <dons> good!
22:47:19 <dons> chessguy, jcreigh: once we've got 25% or so of the solutoins, do you want to advertise on haskell-cafe@ for the rest of the solutions?
22:48:06 <chessguy> i don't see why we can't do that once we have the 11 pages set up
22:48:12 <dons> go for it then :)
22:48:21 <dons> fork those threads!
22:48:26 <chessguy> working on it
22:49:58 <chessguy> i'm putting the general description on each page, and then i'm going to have an index page, and link them all together too
22:50:58 <dons> is there anyone who doesn't read the HWN via email?
22:51:07 <dons> I'm thinking I should probaby send HWN issues to haskell-cafe@ these days..
22:51:13 <dons> since that's where all the beginners hang out
22:51:46 <chessguy> what's HWN?
22:52:04 <anonfunc> I use RSS.
22:52:39 <dons> chessguy: the weekly news
22:52:42 <dons> anonfunc: ok. good
22:53:00 <dons> chessguy: you don't subscribe to haskell@haskell.org? but instead to haskell-cafe@ ?
22:53:37 <chessguy> i'm on both
22:53:50 * notsmack reads it on sequence.complete.org every so often
23:01:59 <monochrom> HWN on email is in its present format less convenient on the web, following links is not easy.
23:02:15 <monochrom> darn. need correction.
23:02:21 <monochrom> HWN on email is in its present format less convenient than on the web, following links is not easy.
23:04:15 <chessguy> don, hmm. i'm not very good at this formatting stuff
23:04:32 <chessguy> how do i make sure i go to a new line?
23:04:58 <monochrom> If between two paragraphs, blank line.
23:05:03 <dons> monochrom: yep.
23:05:46 <chessguy> ok, suggestions for improving this? http://haskell.org/haskellwiki/99_Haskell_exercises
23:05:47 <lambdabot> Title: 99 Haskell exercises - HaskellWiki
23:06:09 <dons> put them in a table
23:06:17 <dons> let me do that... (I have the syntax on hand)
23:06:27 <monochrom> But if for listing, consider list, table, ...
23:06:28 * dons edits
23:06:48 <chessguy> ok. i think that's all we need. we probably don't need to link each page to each other, since we'll be linking people to the index page anyway
23:07:14 <monochrom> link back to index page
23:07:27 <ibid> whew. comp.lang.haskell *finally* arrived in my news server
23:07:27 <lambdabot> ibid: You have 2 new messages. '/msg lambdabot @messages' to read them.
23:07:34 <chessguy> that's what the back button is for :)
23:07:36 <ibid> gah!
23:08:05 <Pseudonym> Gotta go.
23:08:09 <Pseudonym> Nytol!
23:08:19 <ibid> i *hate* lambdabot @messages
23:08:27 <dons> ok done.
23:08:32 <monochrom> is anything fun going on comp.lang.haskell?
23:08:33 <dons> ibid: more info please?
23:08:42 <chessguy> ah, nice
23:09:03 <chessguy> oh, the | is what i was missing
23:09:10 <dons> yep
23:09:29 <dons> ibid: would it be better if lambdabot privmsgd the user, do you mean?
23:09:33 <chessguy> ok, let me shoot a message to haskell-cafe
23:09:39 <dons> go for it!
23:09:53 <ski> hm
23:10:20 <ibid> dons: the main point is that it tells me about the messages the first time i speak on this channel after the message has been recorded. this may, sometimes, be days later than necessary
23:10:32 <ibid> dons: i've complained about this before
23:10:34 <dons> ibid: ah right. we've talked about this
23:10:41 <ski> if '@tell' was 'privmsg'ed to lambdabot, lambdabot should privmsg the message to the recipient
23:10:42 <dons> you wanted the msg when you appear
23:10:45 <ibid> dons: there is no need for it, either, as there is the memoserv
23:10:45 <dons> not just when you talk
23:10:51 <dons> indeed
23:11:00 <dons> porting @tell to use memoserv might be more useful
23:11:06 <ski> if '@tell' was used in channel, lambdabot should just state the message direactly in channel
23:11:28 <ibid> dons: or just privmsg me immediately after the message is recorded, if i am idling
23:11:36 <ski> (instead of saying that there is a message, but you have to ask for it)
23:11:40 <dons> ibid: good idea
23:12:06 <ibid> dons: i will see the privmsg the next time i look at irc, unless the client has crashed in the meantime (which is rare)
23:12:37 <ski> there can be a use for "public" messaging in channel .. otherwise memoserv could be used instead ..
23:13:23 <ski> dons : what do you think ?
23:13:42 <ibid> yes, but at least my client notifies me if someone has addressed me on a channel where i am on, so no need for lambdabot messages there either
23:14:06 <dons> i can imagine @tell being improved, but don't have time to write the code atm
23:14:18 <dons> it wouldn't be hard. so if someone has a better strategy, please darcs send!
23:15:20 <chessguy> ok, it's off
23:16:14 <dons> chessguy++ thanks for that!
23:16:25 <dons> jcreigh++ you too!
23:16:41 <dblhelix> sorry...
23:16:50 <dblhelix> irc client had some troubles updating... should be okay now
23:18:54 <chessguy> sure, it's nice to finally be able to contribute something to the community, as small as it is
23:19:59 <dons> :D
23:20:46 <dons> I think it can't be that small, in fact, considering the size of this channel (bigger than #python), and the news this week there's been more than 100 committers to darcs.
23:20:49 <dons> maybe its just very noisy :)
23:20:55 <chessguy> @pl l -> (drop 3 l) ++ (take 3 l)
23:20:55 <lambdabot> (line 1, column 3):
23:20:55 <lambdabot> unexpected ">" or "-"
23:20:55 <lambdabot> expecting variable, "(", operator or end of input
23:21:34 <chessguy> @pl l -> ((drop 3 l) ++ (take 3 l))
23:21:34 <lambdabot> (line 1, column 3):
23:21:34 <lambdabot> unexpected ">" or "-"
23:21:34 <lambdabot> expecting variable, "(", operator or end of input
23:21:35 <ski> liftM2 (++) (drop 3) (take 3)
23:21:45 <ski> @pl \l -> ((drop 3 l) ++ (take 3 l))
23:21:46 <lambdabot> ap ((++) . drop 3) (take 3)
23:21:48 <chessguy> oh, forgot the \
23:21:54 <chessguy> @pl \l -> ((drop 3 l) ++ (take 3 l))
23:21:54 <lambdabot> ap ((++) . drop 3) (take 3)
23:22:08 <ski> @type \l -> ((drop 3 l) ++ (take 3 l))
23:22:10 <lambdabot> forall a. [a] -> [a]
23:22:14 <chessguy> hmmm, i don't know how canonical that is
23:22:17 <ski> @type liftM2 (++) (drop 3) (take 3)
23:22:18 <lambdabot> forall a. [a] -> [a]
23:23:12 <chessguy> hmm, some of these problems are really interesting
23:23:56 <ski> which ?
23:24:43 <chessguy> oh, i wasn't thinking of any particular one, just glancing down through them
23:25:45 * ski still wonders what 'them' be ..
23:26:31 <chessguy> oh, sorry. the problems linked at http://haskell.org/haskellwiki/99_Haskell_exercises
23:26:32 <lambdabot> Title: 99 Haskell exercises - HaskellWiki
23:26:47 <ski> ah
23:27:13 <chessguy> definitely some very non-trivial problems in there
23:27:51 <shapr> sjanssen: Whoops, I forgot to push the happswiki changes, they're pushed now.
23:28:40 <base_16> i don't see any names where people have claimed problems :/
23:29:48 <dons> whoa, cool , a new ui lib!
23:29:49 <chessguy> i just posted them a few minutes ago :)
23:29:52 <dons> ?where+ phooey http://darcs.haskell.org/packages/phooey
23:29:52 <lambdabot> Done.
23:29:56 <dons> conal++
23:31:00 <chessguy> "P.S. I'm very grateful for Don Stewart's recent pointers on how to create & release Haskell projects."
23:31:09 <dons> heh
23:31:22 <dons> didn't see that..
23:31:28 <dons> ah there it is.
23:31:47 <dons> the lambda revolution will not be televised!
23:32:30 <chessguy> hehe
23:32:48 <chessguy> probably a good thing: no commercials!
23:33:14 <chessguy> it looks like some of these problems aren't even solved in lisp
23:34:11 <chessguy> we should put a scoreboard on the wiki page showing which ones are and aren't solved in lisp and haskell
23:34:23 <dons> good idea
23:34:29 <chessguy> how should i format it?
23:34:58 <chessguy> i guess just a table
23:35:10 <shoffsta> problem 19 is done :)
23:35:29 <dons> shoffsta++ great :)
23:36:23 <chessguy> hmm, i wondered if that one could be done more efficiently with drop and take
23:36:47 <chessguy> drop n ++ take n
23:37:37 <chessguy> or if not more efficiently, at least more understandably
23:38:55 <shoffsta> hmm, yeah... my implementation really isn't too efficient
23:40:35 <chessguy> dons, grrr. i don't know how to format this
23:41:47 <notsmack> hmm, p10:  encode = map (\x -> (length x, head x)) . group  -- ?
23:42:12 <base_16> ok, problem 14 is done
23:42:51 <ski> (chessguy : hm, that wiki page looks empty, to my browser)
23:43:13 <dons> base_16++ great!
23:43:20 <chessguy> ski, which?
23:43:30 <ski> http://haskell.org/haskellwiki/99_Haskell_exercise
23:43:30 <base_16> someone might want to check it since i'm a noob :)
23:43:31 <lambdabot> Title: 99 Haskell exercise - HaskellWiki
23:44:06 <chessguy> grrr, did i break it?
23:44:10 <sjanssen> shapr: the wiki code is very helpful
23:45:21 <sjanssen> shapr: wiki.hs contains the entire implementation, yeah?  the other source files look like they're something else
23:47:00 <ailndx> dons: does hs-plugins work in 6.6 yet?
23:47:45 <dons> not yet.
23:47:46 <chessguy> ski, ok, i think it should wokr
23:47:48 <chessguy> *work
23:47:54 <dons> ailndx: what are you using it for/
23:48:03 <ski> chessguy : ah, now i see something :)
23:48:47 <ailndx> dons: nothing atm, but i didnt get it to work properly in win with 6.4, gonna try again once with 6.6 laters
23:49:30 <dons> did you try ghc 6.4.2?
23:49:35 <ailndx> yep
23:49:42 <dons> (should work on win32 then..) what went wrong?
23:49:56 <sjanssen> so, dons, what do you think about having a lambdabotpaste?
23:50:09 <ski> > let dupli = (>>= \x -> [x,x]) in dupli [1,2,3]
23:50:10 <lambdabot>  [1,1,2,2,3,3]
23:50:13 <ailndx> some dll or posix error when i tried to use it
23:50:17 <dons> sjanssen: how'd it work? like lispaste?
23:50:26 <ski> (that another solution for problem 14)
23:50:36 <sjanssen> yeah, I'd pretty much clone lisppaste's features
23:50:40 <dons> i like the idea
23:50:49 <dons> but not sure if we need it :)
23:50:54 <dons> unless lisppaste gets worse
23:51:38 <sjanssen> oh, I acknowledge that it's entirely unnecessary
23:52:22 <dons> hehe o
23:52:23 <dons> k
23:53:08 <base_16> ski: nice
23:53:12 <base_16> i like yours better :)
23:53:28 <ski> ty
23:54:12 <ski> > group "aaaabccaadeeee"
23:54:13 <lambdabot>  ["aaaa","b","cc","aa","d","eeee"]
23:54:21 <ski> that's problem 9, yes ?
23:54:28 <base_16> how about this for 15?
23:54:32 <base_16> let repli (x:xs) r = (take r $ repeat x) ++ repli xs r; repli [] r = []
23:55:19 <ski> > let repli xs n = do x <- xs; replicate n xs in repli "abc" 3
23:55:20 <lambdabot>  ["abc","abc","abc","abc","abc","abc","abc","abc","abc"]
23:55:27 <ski> no
23:55:36 <ski> > let repli xs n = do x <- xs; replicate n x in repli "abc" 3
23:55:37 <lambdabot>  "aaabbbccc"
23:56:14 <ski> (that's using same idea as 'dupli' above)
23:56:24 <base_16> hmm yeah
23:56:47 <ski> of course one could use list comprehensions here, instead of '(>>=)' or 'do'-notation
23:56:47 <base_16> i'll have to make notes of what you're doing because it's using fancy bind stuff i'm not using :)
23:57:13 <ski> > [y | x <- [1,2,3] , y <- [x,x]]
23:57:14 <lambdabot>  [1,1,2,2,3,3]
23:57:25 <ski> > [y | x <- "abc" , y <- replicate 3 x]
23:57:26 <lambdabot>  "aaabbbccc"
23:59:16 <base_16> nice
23:59:27 <ski> it's basically the same
23:59:31 <base_16> yeah
