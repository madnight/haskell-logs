00:00:12 <kilimanjaro> it's a computation structure
00:00:19 <allbery_b> the state monad is a good start; it's simple yet expresses all the power of monads.
00:00:23 <sorear> mgsloan: IMO mapM_ would make it clearer
00:00:31 <allbery_b> IO is a *terrible* way to start because even for a monad it's weird
00:00:33 <mgsloan> oh, probably
00:00:42 <mgsloan> I'm not very up on the up of monadic style
00:00:55 <goltrpoat> ive had good luck explaining the concept by contrasting Maybe with State and Either and asking for commonalities, and then tossing in IO
00:01:01 <kilimanjaro> learning about monads is like like learning about recursion: it's just opening your eyes to the properties of certain structures of code
00:01:15 <benja_> (I have this feeling that I ought to write yet another monad/monad transformer tutorial. dissuade me)
00:01:24 <mgsloan> I think I messed up the parenthesis too
00:01:29 <allbery_b> it's a rite of passage, I understand :>
00:01:34 <mgsloan> that second $ needs to be replaced with proper parens
00:01:35 <mr_tenor> atm, i suck everything from IO, float about in functional land, then hook it up to IO to writethings out again :P
00:01:35 <kilimanjaro> benja_: do you have an acm membership?
00:01:46 <zeeeee> benja_: this might not dissuade you, but if you do...send me a link :)
00:01:54 <quazimodo> does this list comprehension lead onto string comparison, or is that done using a totaly different structure?
00:01:55 <kilimanjaro> ehh. i/o in functional programming is inherently weird
00:01:59 <mgsloan> zeeeee: check out my annotation
00:02:01 <allbery_b> strings are lists
00:02:16 <allbery_b> type String = [Char] -- this is the literal definition
00:02:32 <zeeeee> mgsloan: that's weird, it didnt get announced for some reason...
00:02:51 <kilimanjaro> functions aren't supposed to interact with the world interactively, so we just construct placeholder computations for the actual i/o
00:02:53 <quazimodo> allbery_b, well what i meant was when i want to see if "foo" exists in "bla bla bla foo" am i going to use Chars and a bit of programming, or is there a structure that exists to do that automatically
00:02:55 <mgsloan> it did, was just a while ago
00:03:25 <allbery_b> I understand there used to be monad comprehensions as a generalization of list comprehensions but they didn't make it into Haskell98
00:03:25 <sorear> mgsloan: mapM_ hurts? I'm a little suprised
00:03:27 <goltrpoat> i think IO should really be explained in a whole different setting, the awkward squad paper handles that nicely
00:03:38 <sorear> allbery_b: yes
00:03:52 <mgsloan> nah, it doesn't hurt I just haven't learned the stuff enough to keep all the M funcs straight
00:04:00 <allbery_b> quazimodo: you could do it that way but there are standard functions for that kind of thing, in your case isInfixOf
00:04:06 <mgsloan> :t mapM
00:04:07 <sorear> ?docs Control.Monad
00:04:07 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
00:04:08 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html
00:04:08 <zeeeee> mgsloan: !
00:04:09 <allbery_b> @index isInfixOf
00:04:09 <lambdabot> bzzt
00:04:16 <allbery_b> hm, maybe I misremember the name
00:04:18 <mgsloan> :t mapM_
00:04:19 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> [a] -> m ()
00:04:20 <sorear> ?docs Is Your Friend
00:04:20 <lambdabot> Is Your Friend not available
00:04:20 <quazimodo> thanks allbery_b
00:04:36 <goltrpoat> in other words, the whole "suppose we had a function that returned a Char from user input, and we wanted a pair of Chars" angle
00:04:39 <quazimodo> ?docs Top 10 reasons Quazimodo ought to be coronated
00:04:40 <lambdabot> Top 10 reasons Quazimodo ought to be coronated not available
00:04:42 * allbery_b should be in bed but is still recovering from delays earlier
00:04:44 <quazimodo> meh
00:04:47 <mgsloan> ah yeah, I remember the _ chucks the crap you don't need
00:05:08 <mr_tenor> quazimodo: it would be instructie to write it yourself first, but http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html#v%3AisInfixOf
00:05:10 <lambdabot> http://tinyurl.com/yhrw65
00:05:15 <mr_tenor> instructive, rather
00:05:16 <kilimanjaro> I still don't think that monadic i/o is necessarily the ideal way to deal with i/o (though I can't think of anything better for a language like haskell). the reason is that, deep down, I feel like we are fooling ourselves into thinking that adjectives like "interactive" are just unfortunate carryovers from the real world
00:05:25 <zeeeee> mgsloan: fmap! (>>)! i know of these things, yet would never have thought of using them
00:05:36 <allbery_b> hm, right name, no idea why it disliked it.  it's in Data.List
00:05:59 <mgsloan> zeeeee: yeah, fmap actually is probably the wrong one for that spot :)
00:06:17 <mgsloan> the main trick was to move out modify
00:06:23 <quazimodo> string editing <- ignore, i just use this to search for relevant things in my logs :)
00:06:32 <zeeeee> mgsloan: btw what does the >> pair operate on? (i don't know the indent rules well)
00:06:44 <zeeeee> er, ">> operate"
00:06:46 <mgsloan> zeeeee: actually, I messed up there
00:06:56 <pejo> kili, "Reactive Objects in a Functional Language, An escape from the evil "I"", so atleast half of it can be removed. :-)
00:07:35 <mgsloan> you need parens around all the stuff before that, until the first $ which is then deleted
00:07:54 <allbery_b> kilimanjaro: it's not ideal but also not the worst, most FP languages have IO held on with duct tape and baling wire because it doesn't fir the functional paradigm at all
00:08:11 <goltrpoat> i actually like benja's version better for readability (assuming it works)
00:08:29 <lisppaste2> mgsloan annotated #33603 with "fix1" at http://paste.lisp.org/display/33603#3
00:08:32 <goltrpoat> allbery:  what was clean's approach again?
00:08:49 <zeeeee> ah
00:08:50 <allbery_b> monads provide a functional-programming notion of state, so it's not a *complete* impedance mismatch
00:08:53 <mgsloan> goltr - yeah, mine is a bit tricky, though I like how it looks sorta impery
00:09:05 * allbery_b doesn't know Clean
00:09:24 <sorear> uniqueness types
00:09:48 <kilimanjaro> pejo: well, i've read some of the frp papers and it's really somewhere between exciting and disappointing. the idea behind frp is not anything all that new
00:09:49 <sorear> main = %World -> %World
00:09:53 <sorear> main :: %World -> %World
00:10:00 <zeeeee> what's the convention in ending certain function names with _?
00:10:00 <allbery_b> I'm still rather new to Haskell and my previous FP "experience" (if you can call it that) was some folling around with J 15 years ago.  and learning just barely enough SML to understand when jhutz@CS tossed out the random expression :)
00:10:00 <sorear> dunno the exact syntax
00:10:11 <zeeeee> (eg forM_)
00:10:15 <allbery_b> zeeeee:  result is discarded
00:10:17 <zeeeee> (or mapM_)
00:10:18 <pejo> kilimanjaro, frp is very different from the O'Haskell ideas.
00:10:18 <zeeeee> oh
00:10:31 <kilimanjaro> pejo: I don't know anything about O'Haskell
00:10:35 <allbery_b> you use that with IO actions mostly, since the intended result is the IO side effect and the result is IO () which is a fairly useless value
00:10:44 <hyrax42> zeeeee: they generally return (), ie.e. throw away results
00:10:47 <sorear> %foo must be used in a single threaded way (you can't pass it to two functions)
00:10:51 <quazimodo> why does let ssb a b = etcetc work but let ssb phrase1 char1 = etcetc doesnt?
00:11:04 <hyrax42> often used when you're doing IO actions
00:11:11 <pejo> kilimanjaro, well, the "getting rid of the evil I"-paper is for that context.
00:11:19 <kilimanjaro> frp is basically saying "we can describe dynamical systems as a set of differential/algebraic equations"
00:11:27 <kilimanjaro> ohh, I guess I confused what you were talking about
00:12:11 <sorear> frp /= functional interactivity.
00:12:19 <kilimanjaro> right
00:12:33 <sorear> IMO the Fudgets design is a lot cleaner and more implementable
00:12:53 <sorear> Unfortunatly the Fudgets *implementation* is bitrotted to oblivion
00:12:59 <sorear> Who still uses hbc?
00:13:18 <pejo> sorear, and coincidentially Hallgren, Carlsson and Nordlander were all grad students at Chalmers at the same time.
00:13:29 <sorear> Why should I want code that proudly announces having being updated for GHC 5.0?
00:13:31 <pejo> sorear, hm, even the Fudgets released in 2006?
00:13:52 <kilimanjaro> pejo: ok, so I haven't read this paper you mentioned, and it is completely different from what I thought it was. take my prior comments as proof of my ignorance :)
00:14:06 <quazimodo> wow haskell is so mathematical !
00:14:25 <quazimodo> sorear, you know mahogny?
00:14:30 <pejo> kilimanjaro, shrug, it's not out of context. They just chose a very different path for frp.
00:14:30 <kilimanjaro> mathematics is so haskellical
00:14:31 <sorear> nope
00:14:38 <quazimodo> johan henriksoon
00:14:54 <quazimodo> ?
00:15:14 <quazimodo> he *loves* haskell too and was in chalmers, the guy was doing 40 courses a session
00:15:19 <quazimodo> he specialised in *everything*
00:15:20 <pejo> sorear, are the snapshots at http://www.cse.ogi.edu/~hallgren/untested/Source_code/ bitrotted?
00:15:22 <lambdabot> Title: Source code
00:15:41 <kilimanjaro> if there is anybody here with an acm membership who is willing to get a paper for me, please send me a pm
00:15:56 <kilimanjaro> quazimodo: how long is a session?
00:17:12 <goltrpoat> sorear:  i forget, what did you say you switched to after your gpgpu work?
00:17:55 <sorear> I'm afraid you are mistaken wrt my identity
00:18:02 <goltrpoat> entirely possible.
00:18:26 <goltrpoat> but now i'm going to have to figure out who it was i was thinking of
00:18:46 <sorear> The only gpu programming I've ever done was the beginnings of a fractal flame renderer, and that's hardly GP.
00:18:51 <goltrpoat> haha
00:19:28 <goltrpoat> sorry, wrong nick then.
00:19:28 <sorear> got any good regexes?
00:19:44 <sorear> I've got the full 200MB #haskell logs on a local disk
00:19:48 <sorear> will grep
00:20:13 <mgsloan> bah, lisppaste is so occasional
00:20:15 <allbery_b> pejo: if they don't work with GHC 6.6 (current release), they're not really useful
00:20:27 <goltrpoat> actually.. i was so convinced it was you that i was talking to, that i can't really pull out any sort of an alternative right now
00:20:40 <goltrpoat> i'm sure it'll come to me
00:20:52 <pejo> allbery_b, the task of fixing fudgets for going from 6.4 to 6.6 is probably a lot easier than getting the chalmers snapshots from the mid 90's.
00:21:21 <quazimodo> kilimanjaro, i think inchalmers its 1/4 of the year
00:21:28 <quazimodo> and he was taking 250hours of lectures a week
00:21:42 <kilimanjaro> lol
00:21:43 <quazimodo> ofcourse he didnt go to them, but he only failed a handful of things :/
00:21:45 <quazimodo> amazing guy
00:21:54 <kilimanjaro> how did he take finals?
00:21:55 <goltrpoat> > 7*24
00:21:57 <lambdabot>  168
00:22:02 <goltrpoat> (hours in a week)
00:22:04 <quazimodo> he was able to take his finals as he wanted
00:22:10 <kilimanjaro> goltrpoat: that's why he didn't go to all of them
00:22:21 <mgsloan> haha
00:22:21 <quazimodo> he had no restrictions,they gave him like a month and he could do which ever whenever
00:22:25 <sorear> hey, you coulda just asked me, I had the answer memoized :)
00:22:50 * goltrpoat inserts sorear into the ghc codebase
00:22:53 <zeeeee> mgsloan: hmm...i can't figure out how to fix the fmap thingie... (or what to use instead of the fmap)
00:22:54 <quazimodo> well
00:22:59 <quazimodo> between 240 and 120 :/
00:23:10 <quazimodo> not 250, i was exagerating, but the work load was immense
00:23:27 <quazimodo> he hd a routine fo 20 hours study, 4 hours sleep on average
00:23:31 <mgsloan> _ -> if fmap all $ mapM (isNothing.gets) [name, urls] then
00:23:42 <mgsloan> i should really compile and then annotate, but ahwell
00:24:15 <goltrpoat> quazi:  i did that for a couple of years, it tends to catch up
00:24:34 <mgsloan> this is basically the crazy way of saying
00:24:48 <goltrpoat> that was working "in the field" though, not at school, and then there are some people who seem to be invincible, like edwardk
00:24:55 <zeeeee> mgsloan: i think the problem is in isNothing.gets, since gets returns m a or m (Maybe x)
00:24:59 <mgsloan> if isNothing $ gets name && isNothing $ gets urls then
00:25:21 <mgsloan> oh, hmm
00:25:24 <zeeeee> mgsloan: that wouldn't work either...
00:25:37 <zeeeee> cursed monads!
00:25:38 <mgsloan> then your original == Nothing
00:25:45 <mgsloan> though I thought you couldn't do that...
00:26:40 <mgsloan> :t gets
00:26:40 <quazimodo> goltrpoat, he was successful doing it, he knows everything about everything currently
00:26:42 <lambdabot> forall a (m :: * -> *) s. (MonadState s m) => (s -> a) -> m a
00:26:53 <mgsloan> see, I've never actually used the state monad :)
00:26:57 <goltrpoat> quazi:  that's nuts, i wish i could do that.
00:27:08 <mgsloan> I know the idea though
00:27:18 <mgsloan> that's what I'm mostly here for - the ideas
00:27:39 <mgsloan> though i'm thinking about actually doing real things
00:27:45 <mgsloan> (in haskell)
00:28:03 <goltrpoat> i would like to point out the fact that doing real things is a remarkably overrated venture
00:28:19 <goltrpoat> one that i'm fairly sure i wouldn't actually miss
00:28:34 <quazimodo> goltrpoat, he is an amazing person
00:28:57 <quazimodo> i want to get him drunk and see what the hell is going on inside his head behind the fascade
00:29:02 <quazimodo> is that how it is spelled?
00:29:10 <zeeeee> hehe
00:29:14 <ptolomy> facade?
00:29:19 <goltrpoat> facade.. c with a cedille is common too
00:29:45 <sorear> façade
00:29:51 <sorear> man latin1
00:29:59 <goltrpoat> it actually makes sense there, unlike when people spell "role" with a circumflex on the o
00:30:08 <goltrpoat> which i'm pretty sure hasn't been done in french in a good hundred fifty years.
00:30:43 <sorear> how do you feel about naïve?
00:30:59 <mgsloan> that's a good one
00:31:17 * allbery_b decides he's to tired to point out to the poster on -cafe that Haskell isn't Lisp
00:31:24 <sorear> agred.
00:31:25 <allbery_b> (or, apparentl, to spell...)
00:31:35 <goltrpoat> sorear:  i'm okay with it
00:32:24 <goltrpoat> allbery:  pphetra's post?
00:32:31 <allbery_b> yeh
00:32:39 <quazimodo> btw
00:32:43 <sorear> ?
00:32:47 <quazimodo> haskell defines things like perl?
00:32:49 <quazimodo> i mean
00:32:49 <allbery_b> you can't *do* nested lists in Haskell except the way he did
00:32:49 <quazimodo> lisp
00:33:01 <sorear> elaborate?
00:33:12 <quazimodo> well, are the two languages similar?
00:33:18 <sorear> yes
00:33:22 <allbery_b> he was asking for help cleaning up what looked to me like a reasonable implementation of flatting nested lists
00:33:34 <goltrpoat> yeah, i have no problem with that implementation
00:33:37 <quazimodo> i was always interested in learning lisp
00:33:53 <allbery_b> of course, there's a limit to the cleanness of he Haskell solution because hthe only way to implement a nested list of that type is to define your own type and operations on it
00:33:56 <sorear> someone should hit him with the [Dynamic] implementation
00:34:09 <allbery_b> well, or that but that's got its own ugliness IMO
00:34:34 <goltrpoat> the lisp version is more concise, but that's a fairly rare thing -- and i have never, ever, needed a nested list in haskell, which is what makes me wonder about the post to begin with
00:34:34 <mgsloan> zeeeee: (k:v) -> updateField (k, join ": " v)
00:34:55 <goltrpoat> i mean, if it's nested, it's usually tagged, and there's usually an interpreter to go with it
00:34:56 <goltrpoat> heh
00:35:16 <allbery_b> I suspect it's a "99 Problems" type of thing
00:35:20 <mgsloan> @undo do name' <- gets name; urls' <- gets urls; if name' == Nothing && urls' == Nothing
00:35:20 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 2, srcColumn = 1}) "Parse error"
00:35:25 <zeeeee> mgsloan: the problem with that is that it will *always* fall into that case if you don't require >2 elems
00:35:32 <goltrpoat> allbery:  ooh.  good point.
00:35:54 <mgsloan> ah, nice one
00:36:04 <mgsloan> then at least replace them with _
00:36:34 <allbery_b> (in fact I think that *is* one of the canonical 99)
00:36:38 <kilimanjaro> I don't understand how people can study for 20 hours a day and sleep only 4
00:36:56 <goltrpoat> i sleep about five hours a night, but it takes me a good 3 hours to wake up
00:36:58 <mgsloan> one of those funny sleep cycles would do it
00:37:05 <goltrpoat> and then i usually try to not do any work afterwards
00:37:11 * allbery_b has had a sleep cycle that behaves like that for the past week
00:37:13 <kilimanjaro> I'm the opposite. If I slept for 20 hours a day and studied for 4, I would no doubt be one of if not the top performers among my peers ;)
00:37:19 <allbery_b> except when it knocks me out for 12+ hours instead
00:37:31 <mgsloan> polyphasic sleep you can do about 3hrs out of 24 per day
00:37:39 <allbery_b> (like last night, hence I'm insomniac and babbling tonight)
00:37:45 <goltrpoat> mgsloan:  elucidate.
00:37:47 <kilimanjaro> I just need lots of sleep, and I usually don't need much studying
00:38:22 <kilimanjaro> goltrpoat: awake 3.5 hours, sleep 0.5 hours, repeat 6 times a day
00:38:27 <mgsloan> goltrpoat - basically, you go through a few weeks of hell to change your sleep cycle to something that really messes with normal life
00:38:34 <mgsloan> yeah, kili's got it right
00:39:01 <goltrpoat> i actually *need* 12 hours of sleep a night, i established that through relatively rigorous experimentation during the course of two years that i took off from work a while back.  i do ok on 8, but i find that 5-6 works slightly better, for whatever odd reason.
00:39:06 <kilimanjaro> drink lots of grape juice because you don't produce chemicals that you would normally have made during a full nights sleep
00:39:20 <nornagon> in darcs, how do i push to a remote location?
00:39:28 <goltrpoat> kili:  oh, odd.
00:39:29 <sorear> darcs send
00:39:36 <mgsloan> I would try it, but i've got school
00:39:37 <goltrpoat> didn't napoleon do something similar?
00:39:38 <sorear> Unfortunately I've gotten into a mental state that tells me studying is immortal.
00:39:38 <nornagon> sorear: can i give it a sftp url?
00:39:50 <sorear> try it
00:39:50 <kilimanjaro> goltrpoat: I think it was thomas edison
00:39:55 <mgsloan> goltrpoat: there's rumours plenty of famous geniuses did
00:40:04 <mgsloan> edison, leonardo, etc
00:40:07 <nornagon> evidently not :/
00:40:20 <nornagon> "
00:40:20 <goltrpoat> odd.  sounds like it'd more or less deprive you of all deep sleep.
00:40:22 <nornagon> Send by email a bundle of one or more patches.
00:40:29 <kilimanjaro> I would try using a polyphasic sleep system if it wasn't for the fact that I have work, school, friends, and family
00:40:29 <nornagon> ^- i don't want to send an email.
00:40:38 <zeeeee> mgsloan: oh! you know what your original fmap snippet made me realize? it ran into one of those cases where the type system is hindering us. we have Maybe String and Maybe [String] in the same list
00:40:39 <mgsloan> kili - yeah me too
00:40:46 <pejo> nornagon, or darcs push
00:40:54 <sorear> oh, no, darcs send is for email, darcs push is the one that might work over sftp
00:41:04 <mgsloan> zeee - ah
00:41:06 <kilimanjaro> goltrpoat: nahh, it's actually the opposite. your body requires the deep sleep, so you become efficient at dropping into one of the later phases of rem
00:41:15 <nornagon> "darcs: Pushing to sftp URLs is not supported." :(
00:41:19 <mgsloan> well, i'd just use your original stuff for that spot
00:41:27 <goltrpoat> kili:  you mean getting to REM earlier?
00:41:37 <kilimanjaro> yea
00:41:42 <mgsloan> @undo do name' <- gets name; urls' <- gets urls; if name' == Nothing && urls' == Nothing then return foo else return blah
00:41:43 <lambdabot> gets name >>= \ name' -> gets urls >>= \ urls' -> if name' == Nothing && urls' == Nothing then return foo else return blah
00:41:47 <goltrpoat> i should try that.
00:42:15 <kilimanjaro> goltrpoat: but, stuff does happen even before you get into rem. that's the reason why you need to take more vitamin and mineral supplements than normal
00:42:15 <mgsloan> yeah, pretty cool
00:42:16 <zeeeee> ?help undo
00:42:17 <lambdabot> undo <expr>
00:42:17 <lambdabot> Translate do notation to Monad operators.
00:42:27 <mgsloan> apparently there are ~30 min REM chunks
00:42:28 <kilimanjaro> i don't know what other physiological effects it would hae
00:42:29 <kilimanjaro> have
00:42:52 <kilimanjaro> like I said, I would try it if I had 90 days without any obligations to the real world ;)
00:42:59 <mgsloan> me too
00:43:24 <goltrpoat> hmm
00:43:37 <mgsloan> actually, I would have that much time - summer vacation
00:43:49 <goltrpoat> actually sounds remarkably painful at first, if you read the theory section on the wikipedia page, and if you've done any of what it talks about in the first two sentences
00:44:30 <mgsloan> thing is, if i did adopt to it, it'd be another few weeks of hell getting back to normal
00:44:36 <goltrpoat> the tiny naps you get after 3-4 days of being up, they're not exactly fun.
00:44:52 <kilimanjaro> maybe I could write a paul graham-like essay on it, "Lisp and Sleep Deprivation: How the power of Common Lisp and polyphasic sleep systems can make you as productive as an uncountable number of sheep"
00:44:54 <mgsloan> yep
00:44:58 <mgsloan> 2 weeks of hell
00:45:06 <mgsloan> heh
00:45:32 <zeeeee> oh man you guys are talking about that 'uberman sleep schedule'
00:45:35 <mgsloan> I think the fact that boat racers have used it fairly well validates it
00:45:36 <kilimanjaro> it took me about 6-days to go from sleeping during the day to sleeping during the night, and those were some weird times
00:45:44 <zeeeee> i tried it during my undergrad. i stopped when i got really sick.
00:46:11 <kilimanjaro> mgsloan: validate it? how long do these boat racers use it?
00:46:24 <mgsloan> kili - yeah, i've been gravitating towards sleep during the day (christmas break still), but my mom doesn't like when I stay up till 4 am and get up at 2pm
00:46:24 <goltrpoat> basically, you wake up a) thirsty as all get out, b) you stay dizzy for a good hour, c) it takes an enormous amount of effort to get anything accomplished
00:46:37 <goltrpoat> of course i was never insane enough to try to do that several times in a row
00:46:41 <goltrpoat> so perhaps it gets better
00:46:43 <kilimanjaro> goltrpoat: what was this?
00:46:49 <mgsloan> kilimanjaro: dunno, says extended periods and alone
00:46:51 <kilimanjaro> the polyphasic sleep?
00:47:07 <mgsloan> you might hallucinate as well, after the first few days
00:47:23 <kilimanjaro> i have hallucinated from sleep deprivation before
00:47:27 <goltrpoat> kili:  im just talking about the short 2-3 hour naps you get after staying up for a few days, sometimes.  you just wake up, and it feels like you got hit over the head with a brick, but you can't go back to bed.
00:47:45 <goltrpoat> it appears related to what these folks are talking about.
00:47:55 <goltrpoat> on the wikipedia page i mean.
00:48:01 <kilimanjaro> goltrpoat: I did that for 5 months (actually more like 4 hours of sleep, during the daytime)
00:48:17 <goltrpoat> 4 hours of sleep is close to normal though.
00:48:48 <kilimanjaro> 4 hours for me is like 2 hours for some people
00:48:57 <goltrpoat> this page is talking about pushing yourself to the point where survival strategy type mechanisms kick in.
00:49:09 <goltrpoat> so like, 36 off, 4 on.
00:49:21 <goltrpoat> (in the beginning, that is)
00:49:40 <kilimanjaro> the worst i have ever done is 50 on, 16 off
00:49:47 <zeeeee> i think this quote accurately sums up my own sentiments: "I firmly believe that you are entitled to try out whatever experiments on yourself that you wish. But don't try to sell it to others, hiding behind a few misunderstood "scientific" facts. I recommend to anyone that wants to try this out, or any other self-experimentation, to check out the facts before jumping on the bandwagon."
00:49:48 <kilimanjaro> actually, more like 52 on
00:50:27 <goltrpoat> the worst ive ever done while not uh, chemically assisted, back when i was a young whippersnapper, was 3 days straight on a deadline
00:50:48 <mgsloan> yikes
00:50:52 <kilimanjaro> goltrpoat: chemically assisted? are you a meth addict or something?
00:51:05 <goltrpoat> i may have misspoken there.
00:51:16 * allbery_b has pulled a couple of 36-hours.  when you're in your 40s, that is *not* fun
00:51:32 <goltrpoat> the chemically assisted part relates to the whippersnapper part.
00:51:58 <mgsloan> so, correction - WAS a meth addict ;p
00:51:58 <kilimanjaro> 52 hours was pretty rough for me, it basically involved me playing diablo 2 for the first 18, trying to watch a movie, and then spending the rest of the time a) doing yardwork and b) playing dreamcast until I gave up
00:52:33 <goltrpoat> mgs:  wouldn't really call that being an addict.
00:52:38 <goltrpoat> more like an enthusiast.
00:52:55 <mgsloan> heh, well, that's better at least
00:53:15 <kilimanjaro> it's safer than exploring the north pole!
00:53:31 <goltrpoat> right, so of course then i became a rock climber.
00:53:42 <goltrpoat> haven't been to the north pole though!
00:53:51 <mgsloan> I have a feeling if i do anything I'll probably get addicted.  Some people probably not.  I can get addicted to say a particular food though  (no, I am not fat!)
00:54:01 <petter_>   if (OPA_SUCCESS(Result))
00:54:01 <petter_>   {
00:54:01 <petter_>     Dimensions.Height = pThis->prefHeight;
00:54:01 <petter_>     Dimensiont.Width = pThis->prefWidth;
00:54:01 <petter_>     
00:54:01 <petter_>     IGoaContainer_SetPreferredSize(pThis->StaticChoiceGroupInternals.pIGoaContainer, &Dimensions);
00:54:03 <petter_>   }
00:54:07 <mgsloan> uh oh
00:54:13 <mgsloan> heh
00:54:16 <kilimanjaro> dude, I'm addicted to taco bueno
00:54:16 <goltrpoat> lawrdy.
00:54:24 <mgsloan> left out of embarasment of the C#
00:54:33 <goltrpoat> c# doesn't have ->
00:54:41 <mgsloan> HOLY CRAP!
00:54:59 <goltrpoat> that's c++
00:55:06 <kilimanjaro> but anyways, there are different levels of addiction
00:55:38 <kilimanjaro> the sort of addiction you get from an amphetamine is a bit more significant than the addiction that you get from, say, a burrito
00:55:46 <quazimodo> lies
00:55:56 <quazimodo> why do you attempt to make the gray areas black and white?
00:56:13 <quazimodo> why reinvent the wheel?
00:56:33 <goltrpoat> very tasty burritos have been known to exist.
00:56:52 <kilimanjaro> did you know that the first wheel was actually made from a piece of flatbread wrapped around beans, cheese, and possibly grilled beef?
00:57:22 <kilimanjaro> i want one right now
00:57:38 <quazimodo> hah
00:57:55 <quazimodo> actualy, i had a whole chicken and a half for lunch today :)
00:58:04 <quazimodo> starting to feel a bit hungry now tho :/
00:58:29 <goltrpoat> haskell:  it's what you want for dinner.
00:59:55 <kilimanjaro> haskell: functional programming is a better distraction from loneliness than imperative programming
01:00:41 <quazimodo> bbl
01:00:50 <goltrpoat> i like mine better, since dinners compose.
01:01:17 <goltrpoat> distractions are a monad with zero and plus at best
01:01:50 * kilimanjaro wonders about what sort of operation would be titled "plusAtBest"
01:02:05 <goltrpoat> a dynamically typed one.
01:02:06 <kilimanjaro> some sort of nondeterministic plus
01:02:20 <mgsloan> goltrpoat: oh, i thought you were implying it was haskell. forgot that C++ has ->
01:02:28 <sorear> x ò y = [x + y, x - y]
01:02:36 <goltrpoat> mgs:  what petter pasted?
01:02:43 <mgsloan> yeah
01:03:01 <kilimanjaro> I'm going to make a stoically typed language
01:03:02 <goltrpoat> mgs:  i just said that c# doesn't have ->, since you mentioned c#
01:03:12 <mgsloan> as for addiction, its not really the mechanism so much as the reaction - I can't resist it very well
01:03:20 <mgsloan> right
01:03:29 <kilimanjaro> Neither the compiler nor runtime complain about errors. They just continue computing, without any regrets
01:03:41 <mgsloan> and from that i thought it might be haskell, hence the "HOLY CRAP"
01:03:46 <goltrpoat> kilimanjaro:  the typechecker won't terminate in the presense of an error?
01:03:59 <goltrpoat> oh, didn't see yours.
01:04:20 <kilimanjaro> goltrpoat: A righteous war is better than an unrighteous peace. Keep on compiling!
01:04:36 * kilimanjaro begins a battle cry
01:05:33 <goltrpoat> kilimanjaro:  put the compiler in the Either monad and call it Mucius
01:06:01 <goltrpoat> good lord i'm funny.  Either, Left, Right, get it.
01:06:33 <kilimanjaro> hahaha
01:06:43 <kilimanjaro> that's one of those wikipedia laughs
01:07:06 <goltrpoat> aww come on.  Mucius being the guy who tried to kill Porsena and ended up burning his right hand over a torch as a show of Roman Manliness.
01:07:13 <goltrpoat> link up to stoicism there.
01:07:43 <kilimanjaro> But really though, it's not an error if you don't acknowledge it, right?
01:09:20 <kilimanjaro> goltrpoat: I think I may have asked you this before, but where in austin do you live?
01:09:36 <goltrpoat> kilimanjaro:  up north, mopac and steck
01:09:50 <kilimanjaro> ahh
01:10:00 <kilimanjaro> I grew up in oak hill, way southwest
01:10:05 <goltrpoat> ah ok
01:10:31 <kilimanjaro> I'm in dallas now, but I have a love for the city of austin, for no apparent reason
01:11:41 <lisppaste2> metaperl pasted "the notation a -> State state b confuses me... please help" at http://paste.lisp.org/display/33613
01:11:53 <kilimanjaro> i might try to go to UT for grad school, if I can get in (still a couple of years though)
01:12:08 <mgsloan> I can't believe how lax with standards math people are
01:12:17 <Syzygy-> mgsloan: Hmmmmm?
01:12:21 <mgsloan> i'd think they'd be the once who would emphasize standards
01:12:27 <kilimanjaro> uhh ohh, here come the math people
01:12:31 <goltrpoat> mgs:  hmm?
01:12:31 <mgsloan> oh, just reading up on graph theory
01:12:36 <Syzygy-> How do you use 'standards' right now?
01:13:05 <mgsloan> I mean like, consistency with vocabulary
01:13:05 <Syzygy-> Are you railing against specific authors, specific styles, or are you talking about adherence to .. say .. technology standards?
01:13:09 <Syzygy-> Ah.
01:13:21 * metaperl prays for help on http://paste.lisp.org/display/33613
01:13:27 <mgsloan> I mean everyone as a whole, particularly fresher fields though
01:13:29 <sorear> metaperl: code looks correct
01:13:45 <Syzygy-> There are, as in every other field, authors that are painfully lax. And there is not necessarily one single consensus when it comestoterminology. Most good maths authors, though, are internally consistent.
01:13:55 <goltrpoat> mgs:  example?
01:14:00 <kilimanjaro> any good author will either a) use the traditional vocabulary and symbolism, or b) specify his particular deviations and their motivation
01:14:01 <mgsloan> ture
01:14:04 <mgsloan> true
01:14:06 <metaperl> yes, but what does (a -> State state b) mean? State takes a single state arg
01:14:22 <mgsloan> but internal consistency isn't enough
01:14:28 <Syzygy-> kilimanjaro: In as far as traditional vocabulary exists.
01:14:30 <allbery_b> it's a function from a to State state b
01:14:37 <Syzygy-> mgsloan: And external consistency is not seldom impossible.
01:14:50 <mgsloan> http://en.wikipedia.org/w/index.php?title=Glossary_of_graph_theory
01:14:53 <lambdabot> Title: Glossary of graph theory - Wikipedia, the free encyclopedia, http://tinyurl.com/y9aw2e
01:15:04 <metaperl> yes, but State is a type constructor taking 1 argument, shouldnt it be from a -> State state
01:15:08 <kilimanjaro> Syzygy-: well, if it doesn't exist, then you just have to do the best job you can to define a coherent vocabulary to use
01:15:24 <mgsloan> yeah, it'll stabalize, but math needs some kind of organization to decide these things
01:15:29 <allbery_b> and your newtype shows two type parameters (newtype State st a = ...)
01:15:52 <benja_> metaperl: it takes 2 args, read again :)
01:15:53 <Syzygy-> kilimanjaro: Problem is that even different parts of the same field can have very different demands on the vocabulary. And mathematicians tend to be rather allergic to people telling them that their ideas need to give way.
01:15:56 <sorear> metaperl: btw, Monad is more than you need - once you understand this Data.Traversable would probably be a better fit.
01:15:57 <mgsloan> actually, even age old fields are fairly inconsistant
01:16:17 <sorear> (but don't try this 'til you understand the current problem)
01:16:23 <metaperl> I'm confused - note the return  = State (\state -> (state, a)) -- it only has 1 parm
01:16:32 <goltrpoat> maybe i'm being dumb here, but the only real inconsistency i can think of is how different books treat multrigraphs
01:16:37 <allbery_b> your instance is on an incomplete type, much as there's a MonadError instance for Either String which is incomplete
01:16:38 <goltrpoat> multigraphs, too
01:16:39 <mgsloan> yes, I suppose that's true.  I'm still partial to my notation for the hyper operator
01:16:43 <metaperl> sorear - thanks for the input
01:16:44 <kilimanjaro> the only problem I have really had with math terminology is from reading old russian books (reprinted by dover). Apparently the soviet union didn't like to mention theorems by the name of the author, unless he was russian
01:17:03 <Syzygy-> kilimanjaro: Ayup. They went to absurd lengths to find a russian author too.
01:17:11 <sorear> metaperl: State (the data constructor) has 1 arg, State (the type constructor) has 2 args
01:17:30 <goltrpoat> kili:  russian is my first language, and i can't read russian math texts
01:17:33 <goltrpoat> partially for that reason
01:17:35 <kilimanjaro> Syzygy-: the fact that different parts of the field have different demands on the vocabulary is just proof of how important vocabulary is to aiding thought and conceptual discussion
01:17:36 <sorear> metaperl: you can always tell the difference by context
01:17:53 <kilimanjaro> goltrpoat: well, these were translated to english, but it was a very literal translation
01:17:59 <goltrpoat> -nod-
01:18:05 <metaperl> oh, so type signatures use the type constructor, but data constructors are used to construct values!
01:18:06 * allbery_b wanted to say that but is still not completely clear on newtype vs. type vs. data
01:18:11 <mgsloan> not that I'm a mathematician, but I have reinvented about 4 things in math over my lifespan
01:18:12 <goltrpoat> there was one guy who did a ton of dover translations from russian.  silverman, was it?
01:18:15 <sorear> yes
01:18:18 <allbery_b> something liek that, yes
01:19:03 <kilimanjaro> goltrpoat: I think so, I have a couple of books by shilov, kolmogorov, ... others I can't remember
01:19:06 <metaperl> sorear - is that what you meant by context?  type signatures use the type constructor, but data constructors are used to construct values?
01:19:11 <kilimanjaro> all bought used for about $10 total
01:19:17 <sorear> metaperl: yes
01:19:20 <kilimanjaro> and I haven't used them very much at all
01:19:28 <metaperl> ok, so who wants to ship me a copy of bird and wadler "essence of fp" for 10.00?
01:19:32 <metaperl> :)
01:19:47 <metaperl> he should open-source the book , it's out of print
01:19:54 <goltrpoat> kili:  i tend to recommend "linear algebra" by shilov actually
01:20:53 <kilimanjaro> goltrpoat: yea, I have that, but at the time I got it I wasn't ready for an actual course in linear algebra, and now i have gotten to the point where it wouldn't do me much good anyways
01:22:00 <goltrpoat> iirc, i got it well after i needed it, read it as a refresher, and was happy enough with it to add it to The List.
01:22:17 <goltrpoat> brb
01:22:24 <zeeeee> benja_: i can't seem to fix the type error on the line that says "Case id null id". i tried changing the last one to "return" and to "(>> (return ()))" to no avail
01:22:45 <kilimanjaro> let me go take a look at it, I have it sitting merely a few feet away
01:25:08 <kilimanjaro> it would probably make a better linear algebra reference book than my other algebra book
01:26:12 <shapr> Argh! The company that claimed to have Richard Hamming's book in stock did not really have it!
01:26:28 <kilimanjaro> Numerical Methods for Scientists and Engineers?
01:26:34 <goltrpoat> to get back On Topic, i recall doing a lot of numerical analysis stuff when i first started with haskell, and it was fairly awkward
01:27:11 <zeeeee> benja_: hrm...the problem seems to go deeper (not just that first line, but the type error shows up for all sebsequent items in the list)
01:27:21 <kilimanjaro> numerical analysis in haskell is basically an extra puberty that some nerds just have to go through
01:27:50 <kilimanjaro> goltrpoat: out of curiosity, why was it awkward?
01:27:51 <goltrpoat> as in, i was trying to write clear code, since i was starting out, this was a couple of years ago, i don't remember the details
01:28:10 <goltrpoat> but i remember thinking that i was writing very suboptimal code
01:28:30 <kilimanjaro> alot of algorithms seem to expect a computation model where a mutable array is a given
01:28:35 <Syzygy-> kilimanjaro: I want to do algebra code in Haskell... :)
01:28:40 <goltrpoat> i suspect a lot of things that i thought were suboptimal were really not though, due to deforestation/fusion/etc
01:28:45 <Syzygy-> Work with higher multiplicative structures et.c.
01:29:03 <kilimanjaro> Syzygy-: i happen to think that haskell is pretty good for just about anything
01:29:08 <Syzygy-> Yeah.
01:29:17 <kilimanjaro> i don't actually know that much math, but i'm getting there
01:30:00 <kilimanjaro> i've been trying to teach myself analysis and algebra
01:30:25 <quazimodo> how would i do import Char(toLower) in ghci?
01:30:49 <shapr> kilimanjaro: "The Art of Science and Engineering : Learning to Learn" I can't find that for less than $600
01:30:54 <wolverian> quazimodo, :m + Char
01:31:17 <shapr> Actually, it's available as a $30 PDF, but the Adobe ebook encryption works only on windows. *grrr*
01:31:40 <quazimodo> shapr, cant extract the content out of the ebook?
01:31:42 <shapr> And the PDF I found does not allow printing or copying of pages.
01:32:01 <shapr> Actually, it allows copying of ten pages per day, but I'm not that patient.
01:32:10 <quazimodo> what a shitcunt?
01:32:12 <mr_tenor> i think you can get around some ofthat pdf stuff
01:32:15 <quazimodo> what is itcalled?
01:32:26 <shapr> quazimodo: That's pretty much what I thought, but I said it much more politely.
01:32:56 <quazimodo> sorry, but what is the pdf that wont allow yout o cpy more than 10 pages a day? the .pdf file or the pdf reader?
01:32:57 <shapr> mr_tenor: Yes, but only if I violate the DMCA. And I choose not to do that.
01:33:07 <kilimanjaro> shapr: http://www.amazon.com/Art-Doing-Science-Engineering-Learning/dp/9056995014/ref=ed_oe_p/002-0323034-5329645
01:33:10 <lambdabot> http://tinyurl.com/y3rh5f
01:33:18 <goltrpoat> kili:  i taught myself analysis (well after a decent amount of exposure to LA), and i was swearing by baby rudin for a long time.
01:33:43 <kilimanjaro> i have that book, i'm on chapter 2 (though I haven't done much in the past few days, because I've been working so damn much)
01:33:52 <mr_tenor> what if you use a combination of normal ps and pdf converting tools and are left with no printing-prevention as an unwanted side efect
01:34:02 <shapr> kilimanjaro: I ordered that once every two months for about six months. They repeatedly came back and told me it was out of stock.
01:34:08 <shapr> kilimanjaro: you have this book?!
01:34:13 <kilimanjaro> shapr: what a bunch of dicks
01:34:24 <kilimanjaro> no, i have the rudin book mentioned by goltrpoat
01:34:27 <shapr> oh
01:34:30 <mr_tenor> damn dmca. i bought it, it's mine >:(
01:34:49 <kilimanjaro> if I had the hamming book I would scan it for you just because I know how crazy not having a book can make someone
01:34:53 <quazimodo> mr_tenor, break the dmca?
01:35:04 <shapr> mr_tenor: Digital *Restrictions* Management says "You bought this book, but you can only use it in exactly the ways we let you use it."
01:35:06 <quazimodo> i have no hesitation in breaking apart the dmca in anything i get
01:35:13 <quazimodo> i refuse to obey rediculous laws
01:35:30 <quazimodo> and rediculous agreements
01:35:36 <goltrpoat> shapr:  totally offtopic, but have you read hamming's 'you and your research speech'?
01:35:41 <kilimanjaro> shapr: but really though, you can get around that copy protection
01:35:44 <shapr> goltrpoat: That's the book!
01:35:57 <mr_tenor> dmca talks about "circumvention deices" under a certain definition, doesn't it? i haven't read the american legislation
01:35:58 <goltrpoat> shapr:  oh.  well, the speech is at http://www.paulgraham.com/hamming.html
01:35:59 <shapr> goltrpoat: Hamming turned that speech into a book a few years later, and that's why I want this book so much!
01:36:00 <lambdabot> Title: Richard Hamming: You and Your Research
01:36:03 <quazimodo> shapr, do you have the pdf with dmca restrictions?
01:36:08 <shapr> quazimodo: yup
01:36:23 <quazimodo> shapr, and the law says you cant dc it over to me?
01:36:29 <shapr> That's right.
01:36:36 <quazimodo> i see
01:36:39 <shapr> But I did get my money back from the company.
01:36:55 <quazimodo> id send the file to me anyway and let me crack it for all to enjoy :/
01:37:23 <shapr> One part of me would like to do that, but I do my very best to follow the laws where physically possible.
01:37:25 <mr_tenor> well, copyright violationis a separate legal and ethical matter
01:37:34 <goltrpoat> shapr:  i can see it being turned into a book, it was an excellent read.  i'm in an r&d driven industry, so a lot of stuff translated.
01:37:36 <shapr> In cases where two laws conflict, I just do what I think is best.
01:37:49 <kilimanjaro> goltrpoat: what industry is that?
01:37:57 <goltrpoat> game development.
01:38:15 <quazimodo> shapr, consider the idiocy of your law, and the fact that its entire existance is the big wallets of big companies?? its not a real law for the people...
01:38:17 <kilimanjaro> (I thought you were gonna say semiconductor)
01:38:30 <goltrpoat> -nod- that would certainly work as well
01:38:36 <quazimodo> dont shoot shapr, is a good law for the people ...
01:38:37 <goltrpoat> one of my partners worked at celoxica for a while.
01:38:39 <kilimanjaro> where do you work?
01:38:45 <kilimanjaro> partners?
01:38:47 <goltrpoat> i co-own a company here.
01:38:50 <kilimanjaro> ohh
01:38:53 <quazimodo> dont let him read over your shoulder incase he learns ??
01:38:57 <kilimanjaro> that's better than having gay lovers
01:39:09 <goltrpoat> well, depends on who you ask.
01:39:11 <shapr> quazimodo: From one viewpoint, the companies employ people. From another viewpoint, digital restrictions don't have any benefit. I know and agree with your intent, but I disagree with your methods :-)
01:39:12 <kilimanjaro> goltrpoat: what company?
01:39:18 <goltrpoat> pyramind labs.
01:39:29 <quazimodo> shapr, as you are then, ill go about my own ways :)
01:39:45 <quazimodo> *if only a better dcpp client existed for unix*
01:40:22 <shapr> I do what I think is right, and I figure other people do that for themselves.
01:40:39 <quazimodo> shapr, if you want i can go into why i think what i say isnt wrong, though
01:40:47 <shapr> quazimodo: But I do enjoy talking about the right way to approach things, and new input can change my mind.
01:40:57 <kilimanjaro> goltrpoat: ping pm
01:41:08 <shapr> quazimodo: I'd like to talk about it, but I won't have time for a coupla days...
01:41:16 <shapr> It's 3:30am and I have work tomorrow.
01:41:27 <quazimodo> it actually involves debt, the federal reserve and congress
01:41:40 <shapr> Sounds particularly interesting, do you have a blog?
01:42:20 <quazimodo> my dad was almost killed in iran by the old shah during the revolution because of his active role in yelling at people his ideas... most of his friends were butchered. i dont think ill have a blog :)
01:42:31 <shapr> yikes
01:43:05 <shankys> Does anyone know if the authors of Takusen ever hang out here?
01:43:10 <quazimodo> i met his friend that had  been in jail and tortured for 8 years by the current regime, they told the guy they were doing the same to his son....
01:43:17 <shapr> In the USA, economic and scientific ideas are usually just ignored if unpopular.
01:43:22 <shapr> Or enshrined by UFO cultists.
01:43:29 <shapr> shankys: I haven't seen them here, no.
01:43:35 <shapr> shankys: And I see almost everybody :-)
01:43:43 <shankys> shapr: hehe
01:43:43 <quazimodo> lets talk haskell :)
01:43:45 <shapr> quazimodo: sad :-(
01:43:59 <shapr> I'm going to go talk to my pillow, g'nite!
01:44:02 <quazimodo> shapr, i haev stories that would make you retch :/
01:44:03 <quazimodo> bye
01:45:02 <sorear> there, I just posted a very short solution to the flattening problem using existentially quantified types and Data.Typeable...
01:46:35 <quazimodo> http://www.foxnews.com/story/0,2933,239317,00.html <- awsp,e
01:46:36 <sorear> flatten (D x) = maybe [D x] (>>= flatten) $ cast x
01:46:37 <lambdabot> Title: FOXNews.com - Alabama Strippers Staying Semi-Clothed With Spray-On Bikinis - Cel ...
01:47:02 <sorear> ?pl let flatten (D x) = maybe [D x] (>>= flatten) (cast x) in flatten
01:47:03 <lambdabot> (line 1, column 16):
01:47:03 <lambdabot> unexpected "x"
01:47:03 <lambdabot> expecting operator or ")"
01:47:19 <sorear> ?pl let flatten x = case x of D x -> maybe [D x] (>>= flatten) (cast x) in flatten
01:47:20 <lambdabot> (line 1, column 31):
01:47:20 <lambdabot> unexpected ">"
01:47:20 <lambdabot> expecting variable, "(", operator, ";" or "in"
01:48:31 <sorear> ?pl let f x of g a (b x) c in f
01:48:32 <lambdabot> (line 1, column 19):
01:48:32 <lambdabot> unexpected "x"
01:48:32 <lambdabot> expecting operator or ")"
01:48:35 <sorear> ?pl let f x = g a (b x) c in f
01:48:36 <lambdabot> flip (g a . b) c
01:48:46 <sorear> ?pl let f = g a (b f) c in f
01:48:47 <lambdabot> fix (flip (g a . b) c)
01:49:22 <dons>  sorear nice soln
01:49:40 <sorear> thanks
01:49:54 <dons> i was thinking that using Typeable was beyond the 'don't show this to newbies' boundary, but in this case he wants (for unknown reasons) an hlist
01:50:23 <sorear> dons: is it legitimate for lambdabot-plugin-A to use types defined in lambdabot-plugin-B?
01:50:33 <dons> sorear: not terribly. but it is doable
01:50:48 <dons> it'll just require hs-plugins to get the loading order right
01:50:48 <metaperl> I am confused about lines 31 and 32 of this - http://rafb.net/p/G1J6dz30.html .... cur <- getState  puts the datum of State in cur... this datum is a function... and then the next line tries to increment the function?
01:50:49 <lambdabot> Title: Nopaste - No description
01:51:00 <dons> lisppaste still down, eh?
01:51:07 * dons grumbles about lisppaste
01:51:22 <metaperl> dons  - line numbering doesnt work there very well... its up I think
01:52:34 <sorear> I was thinking I could keep IRC out of the core by using Typeable to allow $PROTOCOL_MODULE to fail badly typed requests - so I'll need to have all the request types in the core?
01:52:34 <metaperl> rather, line numbering suffers from two issues  there - (1) it is optional and I am asking about line numbers so I want them there. (2) the line numbers are in the same table cell with the source code which fux0rs cut and paste
01:55:13 <zeeeee> benja_: egad! i think your super slick solution was a little *too* slick
01:55:26 <zeeeee> it suffers from the same problem that i was just discussing with mgsloan
01:55:36 <zeeeee> you're constructed a mixed-type list
01:55:42 <zeeeee> *you've
01:56:03 <zeeeee> took me long enough :/
01:56:22 <quazimodo> DUDE they made a 2d ocarina of time!
01:56:59 <geckosenator> what is that?
01:57:14 <geckosenator> is it normally 1d?
01:57:42 <zeeeee> geckosenator: 3d, normally
01:57:42 <quazimodo> they are still working on it :(
01:57:49 <quazimodo> no its a 3d game on nintendo 64
01:58:03 <quazimodo> zelda...
01:59:11 <metaperl> I am confused about lines 31 and 32 of this - http://rafb.net/p/G1J6dz30.html .... cur <- getState  puts the datum of State in cur... this datum is a function... and then the next line tries to increment the function?
01:59:12 <lambdabot> Title: Nopaste - No description
02:01:42 <wilx> @type >>
02:01:43 <lambdabot> parse error on input `>>'
02:01:48 <wilx> @type (>>)
02:01:49 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> m b -> m b
02:02:38 <wilx> @info Monad
02:02:39 <lambdabot> Monad
02:03:39 <sorear> wilx: ?
02:04:13 <wilx> I am just trying to find grounds for what I think :)
02:06:31 <metaperl> why am I being ignored??? I am confused about lines 31 and 32 of this - http://rafb.net/p/G1J6dz30.html .... cur <- getState  puts the datum of State in cur... this datum is a function... and then the next line tries to increment the function?
02:06:31 <lambdabot> Title: Nopaste - No description
02:07:14 <wilx> You are not being ignored. There just is nobody who is able to coherently answer :)
02:07:22 <metaperl> :)
02:07:28 <metaperl> should I email a haskell list? which one?
02:07:38 <wilx> Well, I think the datum is not a function.
02:07:46 <sorear> why do you think the datum is a function?
02:08:27 <goltrpoat> cur <- getState, right.  cur <- State (\state -> (state, state)).  put it differently, State (\state -> (state, state)) >>= f cur.  look at State run >>= action.
02:08:31 <metaperl> because the definition of getState is = State (\state -> (state, state))
02:09:08 <sorear> You are confusing the data and type constructors again.
02:09:18 <sorear> maybe you should give them different names?
02:09:24 <metaperl> Oh, I was thinking that <- simply "de-containerized" the thing in the container
02:09:42 <metaperl> sorear - how am I confusing data and type constructors?
02:09:54 <benja_> metaperl: the type of numberTree says State Int (Tree (a, Int))
02:10:04 <sorear> you weren't, I misinterpreted your statement
02:10:31 <benja_> so the state is of type Int
02:10:32 <wilx> goltrpoat explained it well...
02:10:45 <sorear> State (\state -> (state,state)) is a container, but it contains many values - it is indexed by old states.
02:10:47 <wilx> Follow the definition >>= operator from there.
02:15:50 <quazimodo> the annoying thing about functions is the arguments have to be given in the correct order :(
02:16:10 <goltrpoat> that's usually the idea :)
02:16:25 <quazimodo> well that is sucks!
02:16:28 <quazimodo> it made me confused
02:16:41 <quazimodo> haskell comments are -- right?
02:16:42 <goltrpoat> oh, are you coming from a smalltalk background then?
02:16:59 <goltrpoat> yeah, -- is the line comment, {- -} are the block comments.
02:17:07 <quazimodo> thanks
02:17:32 <mr_tenor> yeah, we need partial evaluation of arbitrary arguments :D
02:17:51 <dancor> what is the best way to get epoch time plus subsecond accuracy
02:18:17 <goltrpoat> mr_tenor:  foldr [] f 1? :)
02:18:30 <metaperl> goltrpoat - so the "f" in State (\state -> (state, state)) >>= f cur   ... is f = (putState .  (+1)) .. right?
02:19:07 <goltrpoat> metaperl:  right
02:19:08 <metaperl> re: lines 31 and 32 here: http://rafb.net/p/G1J6dz30.html
02:19:08 <lambdabot> Title: Nopaste - No description
02:19:11 <metaperl> ok thanks
02:19:19 <goltrpoat> ?undo cur <- getState; putState (cur+1); return (v,cur)
02:19:19 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 5}) "Parse error"
02:19:22 <goltrpoat> bah.
02:19:32 <goltrpoat> ?undo do { cur <- getState; putState (cur+1); return (v,cur) }
02:19:33 <lambdabot> getState >>= \ cur -> putState (cur + 1) >> return (v, cur)
02:20:15 <goltrpoat> ?pl \cur -> putState (cur + 1)
02:20:16 <lambdabot> putState . (1 +)
02:20:34 <mr_tenor> goltrpoat: sorry?
02:20:46 <goltrpoat> mr_tennor:  arbitrary argument order
02:20:55 <goltrpoat> mr_tenor:  the compiler gets to read your mind and all.
02:21:00 <goltrpoat> it's the wave of the future, i figure.
02:21:02 <dancor> actually it's right there in clocktime right?
02:22:04 <mr_tenor> goltrpoat: ah. i thought you were actually trying to suggest something succinctly ;) i mean, like, if haskell had named arguments then it would be syntactically feasible. no idea if it's a sane language concept
02:22:40 <goltrpoat> well, works in smalltalk.  i don't think it's a good idea in haskell
02:23:22 * mr_tenor does not know how currying and partial evaluation is implemented, but suspects it's pretty fundamental to a haskell implementation
02:24:08 <mr_tenor> with quantum computers, maybe we can have the compiler compile all possible guessed meanings of the program :)
02:24:11 <goltrpoat> eg, how the hell do you curry foldl (+) in foldl (acc : 1) (list : [1..5]) (binOp : (+))
02:24:29 <goltrpoat> yes!
02:24:38 <goltrpoat> and then we can pick whichever one halts.
02:24:43 <mr_tenor> heh
02:24:50 <mgsloan> mr_tenor: i think it has something to do with thunks :)
02:26:11 <goltrpoat> i actually made myself laugh with the 'and then we can pick whicever one halts' bit.  i should probably go to bed at some point.
02:26:20 <quazimodo> argh i deleted the folder that contained my emacs-haskell mode :(
02:26:23 <goltrpoat> whichever, rather
02:27:13 <goltrpoat> good lord.  of course there had to be a Typeable solution in response to pphetra's nested list thing
02:31:18 <MarcWebe1> Do you know a parser library where you can customize error handling and parser failure messages? Am I wrong that you can only use SourcePos Col Line with parsec?
02:34:02 <goltrpoat> i don't think parsec lets you do anything terribly custom as far as error handling goes
02:34:21 <goltrpoat> which is rather unfortunate
02:34:53 <goltrpoat> but the good news is that reimplementing parsec from scratch takes about a day
02:36:00 <goltrpoat> so i'm guessing grabbing the source and adding nicer error handling to it isn't a huge amount of effort
02:36:45 <goltrpoat> something that someone should perhaps do at some point.
02:40:16 <metaperl> I just need to verify something on line 8 of this: http://rafb.net/p/tWBEV821.html   ... it seems odd that getState would simply return st as st'  and also I dont see how st is passed in
02:40:18 <lambdabot> Title: Nopaste - getState = State (\state -> (state, state))
02:41:20 <goltrpoat> i actually remember there being some major issues with parsec, come to think of it, fixing which would require rewriting major chunks of it
02:43:07 <goltrpoat> (eg, buildExpressionParser takes a list of things that are very limited -- try writing a single-pass compiler with ternary operators using it)
02:43:34 <dancor> uh.. how do i divide integers
02:43:59 <dancor> requires a fractional type..
02:44:05 <dancor> /
02:44:08 <benja_> who has a good simple example making use of the Maybe monad?
02:44:11 <goltrpoat> dancor:  div
02:44:17 <goltrpoat> > 10 `div` 2
02:44:19 <lambdabot>  5
02:44:38 * benja_ is writing that monad (transformer) tutorial I wasn't dissuaded from writing :)
02:44:40 <dancor> benja_: i use the maybe monad to parse lines of a file that may be empty
02:45:07 <goltrpoat> > (Just 5 >> Just 10, Just 5 >> Nothing, Nothing >> Just 10)
02:45:09 <lambdabot>  Add a type signature
02:45:15 <goltrpoat> meh?
02:45:33 <benja_> goltrpoat: polymorphic literals
02:45:37 <dancor> the lines are just of the form "a   b" and they are for a memorization program (learn that b is the answer to a)
02:45:40 <goltrpoat> > (Just 5 >> Just 10, Just 5 >> Nothing, Nothing >> Just 10) :: (Maybe Int, Maybe Int, Maybe Int)
02:45:41 <dancor> 5 is Num
02:45:42 <lambdabot>  (Just 10,Nothing,Nothing)
02:46:04 <goltrpoat> shouldn't those default to Integer, though
02:46:23 <benja_> dancor: so where does the monad come in?
02:46:26 <goltrpoat> does in ghci
02:47:11 <dancor> readQ :: String -> Either String (Maybe Qna)
02:47:37 <dancor> an error (could not find the spaces) or a q-and-a or Nothing
02:48:17 <dancor> then just sequence to see if there was an error and catMaybes to kill the maybes
02:48:35 <benja_> ideally, I'm looking for an example that has just do { x <- expr1; expr2 }, i.e. expr1 >>= \x -> expr2
02:49:05 <dancor> isn't / 0 good
02:49:37 <dancor> can't you use Maybe to deal nicely with threading the NaN resulting from / 0
02:50:15 <goltrpoat> why would you want to
02:50:17 <benja_> hm, so would you have both expr1 and expr2 be divisions?
02:52:08 <goltrpoat> benja:  you're looking for an example of that in the Maybe monad?
02:52:26 <benja_> goltrpoat: yes
02:52:34 <goltrpoat> > Just 5 >>= return . (* 3)
02:52:36 <lambdabot>  Just 15
02:52:58 <goltrpoat> > Nothing >>= return . (* 3)
02:53:00 <lambdabot>  Nothing
02:53:29 <benja_> goltrpoat: but I mean, a useful one :)
02:53:59 <benja_> a pair of possibly-failing functions f and g where you want to compute f (g x)
02:54:23 <dibblego> openFile; readFile; closeFile
02:54:44 <benja_> dibblego: but that's IO, not just Maybe
02:54:47 <MarcWebe1> goltrpoat: ternary? Can you give me an example?
02:54:54 <benja_> (you could use MaybeT IO)
02:55:07 <goltrpoat> marc:  the pred ? t : f operator in c++
02:55:10 <dibblego> so make it not IO
02:56:21 <goltrpoat> benja, how's this..
02:56:29 <benja_> dibblego, I can't make sense of that :-/
02:56:50 <goltrpoat> > let myMap = M.singleton "x" 15 in (M.lookup "x" myMap :: Maybe Int) >>= return . (*3)
02:56:52 <lambdabot>  Just 45
02:56:55 <goltrpoat> > let myMap = M.singleton "x" 15 in (M.lookup "y" myMap :: Maybe Int) >>= return . (*3)
02:56:57 <lambdabot>  Nothing
02:57:01 <cperfumo> is there any way of invoking several times a function without getting a stack overflow? currently I'm using replicateM_ but with numbers around 100000 i get the SO
02:57:03 <dibblego> aren't you looking for a practical example of Maybe in do?
02:58:29 <goltrpoat> not fully sure how many useful examples one can come up with in a oneliner.  the Maybe monad chains computations up to the first point of failure.
02:58:47 <benja_> goltrpoat: hm, Map is a good idea. not >>= return . f though, since I already have an example with fmap and am now talking about why more than that is needed :)
02:58:49 <goltrpoat> er, that's badly phrased.
02:59:16 <goltrpoat> chains computations unless one of them fails.
02:59:29 <goltrpoat> that's also badly phrased.  crap.
02:59:30 <benja_> perhaps I should actually just use 'f' and 'g' without saying what they are
03:01:31 <Syzygy-> True or false: Monads are Functors, so for a monad m, we could potentially use both fmap and liftM; with the same function signature. Do these do the very same thing for monads?
03:01:34 <goltrpoat> benja:  the return . (something) was more or less a placeholder to put at the end of it
03:02:08 <goltrpoat> syzygy:  except for the fact that writing an instance of Monad doesn't automatically create an instance of Functor
03:02:12 <benja_> oh, I can just use a map of maps :)
03:02:28 <Syzygy-> goltrpoat: Ah. So you'd have to make it explicitly a functor.
03:02:31 <goltrpoat> right
03:03:37 <lisppaste2> ph8 pasted "Is this guard syntax wrong?" at http://paste.lisp.org/display/33616
03:03:45 <ph8> hi all
03:03:50 <ph8> is that the wrong way to express guards??
03:04:04 <ph8> ERROR "Main.lhs":48 - Syntax error in expression (unexpected `=')
03:04:09 <ph8> line 48 is the second guard in the paste
03:05:07 <goltrpoat> parentheses after haystackMap
03:05:12 <goltrpoat> might help things.
03:05:26 <ph8> haha cheers :p
03:05:30 <goltrpoat> :)
03:05:44 <ph8> and then of course != is undefined
03:05:50 * ph8 pulls out the book
03:05:57 <goltrpoat> :t (/=)
03:05:59 <lambdabot> forall a. (Eq a) => a -> a -> Bool
03:06:09 <ph8> /= is !=?
03:06:10 <goltrpoat> think the usual not-equals sign
03:06:16 <ph8> ah thx
03:07:17 <ph8> ?type Data.Map.findWithDefault
03:07:18 <lambdabot> forall a k. (Ord k) => a -> k -> Data.Map.Map k a -> a
03:07:46 <goltrpoat> 0 isn't a [[Char]]
03:08:02 <goltrpoat> may i suggest not using [[Char]] as a key into a map though
03:08:02 <goltrpoat> hehe
03:08:07 <goltrpoat> that makes baby jesus cry.
03:09:35 <ph8> i have to unfortunately
03:09:39 <goltrpoat> ah
03:09:49 <Syzygy-> Is there a map type built already that only needs keys to be Eq?
03:09:50 <quazimodo> when writing haskell code, do we generally include things like myFunction :: [a] -> [a]
03:09:50 <quazimodo> ?
03:09:54 <ph8> the map is [String, String] => [String]
03:09:57 <Syzygy-> quazimodo: I do.
03:10:14 <ph8> quazimodo: It depends how readable you want it to by I guess
03:10:17 <quazimodo> Syzygy-, but there is no rule in the language wanting it?
03:10:18 <ph8> it's not necessary
03:10:19 <Syzygy-> ph8: If it's always twostrings, then consider using (String,String)
03:10:21 <quazimodo> ok
03:10:40 <quazimodo> what about if we have myFunction str chr bool  as arguemnts?
03:10:44 <ph8> Sometimes it's [String] => [String]
03:10:51 <dons> ?uptime
03:10:52 <lambdabot> uptime: 7d 10h 29m 1s, longest uptime: 9d 2h 23m 6s
03:10:59 <quazimodo> and the only outcome is Char
03:10:59 <Syzygy-> quazimodo: No, but debugging gets easier, because you're helping the typechecker to point to the right points of breakdown.
03:11:01 <goltrpoat> syzygy:  only requiring Eq would make it a list, no?  in which case, the prelude functions like lookup etc work on lists of tuples
03:11:13 <ph8> String -> Char -> Bool?
03:11:21 <ph8> oh as args
03:11:23 <ph8> String -> Char -> Bool -> Char
03:11:28 <Syzygy-> myFunction :: String -> Char -> Bool -> Char
03:11:30 <ph8> that would be taking string, char bool and returning Char
03:11:51 <cperfumo> > replicate 1000000 "XXX"
03:11:53 <lambdabot>  ["XXX","XXX","XXX","XXX","XXX","XXX","XXX","XXX","XXX","XXX","XXX","XXX","XX...
03:12:00 <ph8> lol cperfumo
03:12:02 <quazimodo> i thought perhaps it might be different looking
03:12:04 <Syzygy-> goltrpoat: It does? Nice! Then lists probably may be a good way to tackle some of my weirder algebraic apps.
03:12:26 <Syzygy-> cperfumo: take 1000000 $ cycle ["XXX"]
03:13:54 <cperfumo> Syzygy- : should it give a stack overflow if the number of times i want to replicate something is very big?
03:14:15 <goltrpoat> > lookup "x" [("x", 5), ("y", 10)]
03:14:17 <lambdabot>  Just 5
03:14:35 <Syzygy-> cperfumo: Dependson what you do with it.
03:14:55 <ph8> in that definition of genNext, that i just pastebin'ed
03:15:02 <ph8> what does the IO ( ) around the map argument signify?
03:15:11 <ph8> I thought i knew what it meant but i'm getting some weird errors that would say otherwise
03:15:22 <Syzygy-> > lookup [1,2,1] [([1,1,0],5), ([0,1,0],3), ([1,2,1],7)]
03:15:23 <lambdabot>  Just 7
03:15:27 <Syzygy-> Woooooot!
03:15:33 <goltrpoat> :)
03:15:40 <Syzygy-> I can build generic finitely presented algebra handling with this!!!
03:15:59 <benc__> does lambabot let you set variables for use in later lines?
03:16:01 <quazimodo> can we do 'a' == 'x' ?
03:16:09 <goltrpoat> > 'a' == 'x'
03:16:11 <lambdabot>  False
03:16:11 <Syzygy-> ?let foo=3
03:16:13 <lambdabot> Defined.
03:16:16 <cperfumo> Syzygy- : I want two threads to execute a function many times, lets say one billion. The function doesn't return any result and just modifies a shared TVar
03:16:19 <Syzygy-> > L.foo + 45
03:16:20 <lambdabot>  48
03:16:27 <quazimodo> :D
03:16:30 <Syzygy-> cperfumo: I don't know about TVars or threads.
03:16:36 <Syzygy-> ?undefine foo
03:16:37 <lambdabot> Undefined.
03:16:41 <Syzygy-> > L.foo
03:16:43 <lambdabot>  Not in scope: `L.foo'
03:16:46 <benc__> thats what I want
03:17:12 <benc__> i have some pieces of lambdabot (but not all -mostly just the direct expression evaluation) hacked into a MUD
03:17:18 <Syzygy-> Neat.
03:17:22 <xerox> > /QUERY lambdabot
03:17:22 <lambdabot>  Parse error
03:17:24 <xerox> ops.
03:17:26 <benc__> was thinking that it would nice to have variable definitions too
03:17:44 <benc__> i guess i just need to tie a bit more of lambdabot in
03:17:58 <goltrpoat> ph8:  in the code that you pasted, there's no reason for the map argument to be in IO
03:18:10 <ph8> that's what i thought, but it seemed to satisfy it :p
03:18:33 <ph8> now String is created with getLine, in a previous function - then passed into genNext - does that mean String should be in IO() ?
03:18:44 <goltrpoat> no, it's a pure string, right.
03:18:52 <ph8> right
03:18:52 <ph8> hmm
03:19:14 <cperfumo> i want to fork 2 threads and wait until they finish to do something else. Anyone knows how to do that?
03:19:29 <xerox> > let map = (M.fromList  [([1,1,0],5), ([0,1,0],3), ([1,2,1],7)]) in (M.lookup [1,2,1] map :: Maybe Int, M.lookup [1,1,0] map :: [Int])
03:19:31 <lambdabot>  (Just 7,[5])
03:19:39 <goltrpoat> :t forkIO
03:19:41 <lambdabot> Not in scope: `forkIO'
03:19:47 <goltrpoat> of course not.
03:20:17 <Syzygy-> xerox: Nice. And now with a finite group algebra. For the case of multigraded polynomials, maps still work out, but I can't necessarily see how to do it when there's no natural grading.
03:20:18 <lisppaste2> ph8 annotated #33616 with "New w/errors" at http://paste.lisp.org/display/33616#1
03:20:27 <ph8> goltrpoat ^
03:20:30 <ph8> tis a mystery?
03:20:47 <xerox> Syzygy-: cool, I think I see what you mean.
03:21:08 <xerox> benc__: in order to save definitions \bot appends them to a module.
03:21:15 <goltrpoat> ph8:  is theMap a Map [[Char]] [[Char]] ?
03:21:40 <goltrpoat> or rather, what's the type of processFile
03:22:25 <goltrpoat> syzygy:  you should post an overview somewhere when you're done.
03:22:47 <goltrpoat> of the implementation i mean
03:22:50 <Syzygy-> goltrpoat: When I'm done with what I'm thinking about, there'll be several publications including my PhD thesis about it. :)
03:22:57 <goltrpoat> oh hah
03:23:09 <Syzygy-> But I'm slowly adding the algebra code I'm writing into the NumericPrelude.
03:23:14 <goltrpoat> ah ok
03:23:21 <ph8> goltrpoat: ya
03:23:26 <ph8> > processFile :: FilePath -> IO (Map [[Char]] [[Char]])
03:23:27 <lambdabot>  Not in scope: type constructor or class `Map'
03:23:28 <goltrpoat> it definitely needs it :)
03:23:43 <goltrpoat> ph8:  theMap <- processFile "testFile"
03:24:04 <xerox> Syzygy-: lately I've been playing with PARI/gp, and thinking I would love to be able to do the stuff it can do in a strictly-typed setting.
03:24:05 <ph8> what's the difference between that and let? if you'll forgive my ignorance
03:24:17 <ph8> that works now though :)))
03:24:25 <xerox> But I have no time to implement all that stuff of course.
03:24:42 <goltrpoat> ph8:  the let statement gives theMap the type IO (Map [[Char]] [[Char]]), which you're then passing to genNext, which certainly doesn't need an IO (Map [[Char]] [[Char]])
03:25:09 <xerox> do { x <- amb ; ... }  =  amb >>= \x -> ...
03:25:36 <goltrpoat> ph8:  the theMap <- processFile "testFile" bit, "extracts" the Map ... value from the IO action processFile "testFile"
03:25:50 <ph8> ahh genious
03:25:51 <ph8> cheers
03:27:10 <goltrpoat> ph8:  in general, do { x <- a; b x } is equivalent to a >>= \x -> b x, or equivalently, a >>= b.  when in doubt, get rid of the do notation and see if things make sense.
03:27:43 <goltrpoat> and vice versa, heh.
03:27:56 <quazimodo> im off
03:28:00 <quazimodo> thanks for *all* the help
03:28:04 <quazimodo> bed time
03:28:05 <Syzygy-> > Just 3 >>= (*5)
03:28:06 <quazimodo> night all
03:28:06 <lambdabot>  add an instance declaration for (Num (Maybe b))
03:28:23 <xerox> fmap! fmap!
03:28:26 <quazimodo> > a-> [a]
03:28:26 <Syzygy-> Ah.
03:28:26 <lambdabot>  Parse error
03:28:27 <Syzygy-> Right.
03:28:29 <quazimodo> heh
03:28:49 <xerox> > (Just 3) >>= return . (*5)
03:28:51 <lambdabot>  Just 15
03:29:09 <Syzygy-> > Nothing >>= return . (*5)
03:29:10 <lambdabot>  Nothing
03:30:16 <xerox> ?pl \f xs -> xs >>= return . f
03:30:17 <lambdabot> fmap
03:37:43 <ph8> ?type Data.Map.findWithDefault
03:37:45 <lambdabot> forall a k. (Ord k) => a -> k -> Data.Map.Map k a -> a
03:38:30 <Syzygy-> default, key, map => value
03:40:08 <ph8> ja
03:40:10 <ph8> i'm having issues
03:40:28 <ph8> i have a return type of String, with my arbitrary function
03:40:37 <ph8> and i want to return the output of findWithDefault
03:40:39 <ph8> whatever that may be
03:40:42 <ph8> ah sec
03:40:57 <goltrpoat> > M.findWithDefault const "times" (M.singleton "times" (*)) 2 3
03:40:59 <lambdabot>  6
03:41:03 <goltrpoat> > M.findWithDefault const "plus" (M.singleton "times" (*)) 2 3
03:41:04 <lambdabot>  2
03:41:48 <ph8> > genNext :: String -> Map [[Char]] [[Char]] -> String
03:41:48 <lambdabot>  Not in scope: type constructor or class `Map'
03:41:52 <ph8> ...
03:41:53 <ph8> >	| otherwise = (findWithDefault [[]] [needle] haystackMap)
03:42:01 <ph8> it's the otherwise that's being triggered
03:42:07 <ph8> hence my want to see what findWithDefault is outputting
03:42:12 <ph8> /returning
03:43:56 <goltrpoat> that looks fine, assuming you want to look for [needle] in the values (not keys), and get [[]] if the value isn't found
03:44:49 <ph8> eep.
03:45:00 <ph8> i wanted to look for [[needle]] in the keys, and have the value returned if it's found
03:45:02 <ph8> [[]] if not
03:45:04 <ph8> or [] i suppose
03:45:19 <ph8> where have i gone wrong though?
03:45:23 <goltrpoat> [needle], right..  needle is String, and your keys are [String]
03:46:26 <goltrpoat> er.  i'm on crack.  keys, not values.
03:46:52 <ph8> ya, example data item would be:
03:46:59 <ph8> ["small","cat"]:=["sat"]
03:47:17 <ski> findWithDefault [[]] [needle] haystackMap :: [String]  -- i think
03:47:33 <goltrpoat> right so that should be fine
03:47:34 <ski> while 'genNext' returns a 'String'
03:47:38 <xerox> Maybe you can use [""] in place of [[]] for clarity.
03:48:17 <goltrpoat> well, perhaps genNext should return [String] if your values are lists of strings, and you're planning on returning values :)
03:48:21 <xerox> But.. why are you using [String] as keys?
03:49:08 <Syzygy-> For the use cases described, (String,String) would be MUCH more appropriate.
03:49:37 <goltrpoat> i did mention that maps on [[Char]] make baby jesus cry, earlier.
03:49:43 <Syzygy-> > compare ("abc","ab") ("ab","abc")
03:49:44 <lambdabot>  GT
03:49:53 <Syzygy-> > compare "abc" "ab
03:49:54 <lambdabot>  Improperly terminated string
03:49:55 <Syzygy-> > compare "abc" "ab"
03:49:57 <lambdabot>  GT
03:50:10 <ski> > compare ["abc","ab"] ["ab","abc"]
03:50:12 <lambdabot>  GT
03:50:44 <goltrpoat> assuming there's a good reason for the [[Char]] bit, and your function is returning two distinct types of things -- success messages and values, say, then a type union makes sense
03:50:59 <xerox> Lexicographic ordering?
03:51:02 <goltrpoat> i.e. have it return a Result where data Result = Message String | Value [String]
03:52:13 <xerox> That is isomorphic to Either String [String], for which you have a huge number of predefined functions in the libraries.
03:52:47 <goltrpoat> none of which are of any use here.
03:53:38 <xerox> I suppose his whole program doesn't just count of a map lookup.
03:54:17 <goltrpoat> no, but his whole program seems to be hinging on this one function that returns a string, and fails to compile due to a pattern evaluating to a list of strings.
03:55:21 <goltrpoat> i'm not sure what the point is behind using Either as a generic type sum type when a specific tagged sum is a lot more readable
03:56:10 <cperfumo> does anybody know something about STM?
04:00:00 <goltrpoat> (also, can we stop throwing the word "isomoprhic" around willy nilly?  Either String [String] is certainly not isormophic to data Result = Message String | Value [String], the "bijection" you have in mind is forgetful)
04:01:13 <goltrpoat> not fully sure how i managed to misspell isomorphic twice in a row, though.
04:02:18 <Syzygy-> goltrpoat: How is that being forgetful? Because the constructors change names?
04:02:31 <Syzygy-> Or because the things written for Either need rewriting?
04:02:36 <mattam> these spellings are isomorphic to the casual reader anyway :)
04:02:36 <goltrpoat> because Either is in a large number of type classes that my Result type isn't in? :)
04:02:44 <Syzygy-> Ah.
04:03:34 <xerox> That was silly.  That's one of the reason I'd suggest using Either instead of a made-up type of the same shape.
04:04:10 <Syzygy-> And furthermore, it'd be an easy matterto use the pseudo-forgetfulfunctor to reimplement all theinstantiations.
04:04:42 <Syzygy-> instance Blah Result where foo (Message s) = foo (Left s)
04:04:52 <Syzygy-> This is just renaming stuff, thus just using the isomorphism.
04:05:42 <Syzygy-> Your isomorphism concept, if it requires membership the same way for all type classes isn't really good for isomorphisms, but rather for equality.
04:05:55 <goltrpoat> of course it's easy.  so then why should i have to say Left "value not found!" and Right value, and then rely on convention or wading through several modules to figure out what Left and Right mean, when i can put Result into whatever classes i care about when i need to?
04:06:07 <goltrpoat> Either isn't exactly relying on a beast of library support.
04:06:13 <Syzygy-> That said, isomorphism is a highly polymorphic concept anyway.
04:07:11 <goltrpoat> well, when you say isomorphism between types, you mean a fairly specific thing, usually, no?
04:07:20 <Syzygy-> goltrpoat: I agree that the specific type class is a better choice for legibility. I only object to saying that they're not isomorphic, when most of the arguments for that implies that isomorphism isn't the interesting, but equality rather.
04:07:37 <goltrpoat> ah ok
04:07:59 <goltrpoat> i take isomorphism on types to be structure preserving, where Either is endowed with additional structure
04:08:29 <Syzygy-> I don't know enough type theoryto know what they meanbyisomorphism betweentypes. However, isomorphisms inthe category of Haskell types are easily described, as generic categorical concepts: viz adjunct morphisms composing the right ways.
04:08:33 <goltrpoat> that could certainly be unconventional though.
04:08:42 <xerox> ?docs Control.Monad.Error
04:08:42 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Error.html
04:09:03 <Syzygy-> Saying "it's structure preserving" in general is a bit too much intuition and too little rigour.
04:09:44 <goltrpoat> fair enough.  i'm not sure how to unify the algebra with the haskell here though.
04:09:47 <xerox> goltrpoat - The very fact that Either has more structure is the reason I was suggesting it. Excuse me for the bad wording.
04:10:18 <xerox> "You can think of a natural isomorphism between Either and Result."
04:10:26 <xerox> That's probably vague enough.
04:10:33 <goltrpoat> that works :)
04:11:02 <goltrpoat> we'll take Either and Result as disjoint unions on sets.
04:11:14 <goltrpoat> whee, isomorphisms left and right.
04:11:55 <Templar2> is there any function in haskell who can convert an int 1 to "one"
04:12:11 <Syzygy-> goltrpoat: For another example of why you'd need to take care, take the cyclic four group and the klein four group. These are isomorphic as sets, not as groups. The group algebras are isomorphic as vector spaces, not as algebras.
04:12:26 <Syzygy-> Isomorphism depends entirely on what you look at.
04:12:50 <goltrpoat> but we *were* talking about types, not sets :)
04:13:01 <Syzygy-> Templar2: Try convertit :: Int ->String; convertit 1 = "one; convertit _ = ""
04:13:54 <Syzygy-> goltrpoat: The crags, though, are illuminating for this discussion as well though.
04:14:35 <nornagon> hmph, does darcs put require darcs to be installed on the remote side? :(
04:14:41 <Templar2> Syzygy aha, k, so there is no std function?
04:14:44 <Syzygy-> And as (Type-With-All-Implemented-Type-Classes), there is some work to do until Result and Either String are isomorphic. As Types not.
04:14:47 <xerox> nornagon: yes it does.
04:14:49 <daniel_larsson> nornagon: yes
04:14:53 <nornagon> :(
04:14:53 <Syzygy-> Templar2: I don't think so. I'm not certain.
04:15:12 <Templar2> Syzygy- ok, ty anyway
04:15:24 <goltrpoat> hmm
04:15:24 <nornagon> Is there a way I can set up a central repo that a bunch of people can push to, but without having to give them all ssh access?
04:15:40 <Templar2> anyone who can explain what deriving means?(deriving  show)
04:15:50 <xerox> nornagon: yes, you have them send patches via email.
04:15:57 <Syzygy-> Templar2: It means that it inherits a standard implementation of the type class from the component types.
04:16:00 <goltrpoat> > let convertit = ((["zero", "one", "two", "three", "four", "five"] ++ (map show [6..])) !!) in (map convertit [0..10])
04:16:01 <nornagon> ew :/
04:16:02 <lambdabot>  ["zero","one","two","three","four","five","6","7","8","9","10"]
04:16:25 <xerox> nornagon: the setup for automatic patch applying with signatures is explained in the manual. Also, "darcs send" takes care of mailing the stuff in the right format.
04:16:36 <xerox> Anyway, bbl, off to lunch.
04:18:18 <goltrpoat> syzygy:  if x is in Either a b, then x is in Eq.  that sounds like structure to me.
04:19:28 <goltrpoat> syzygy:  by mapping to Result, we're forgetting whatever machinery Eq is adding to the type, right
04:19:35 <Syzygy-> goltrpoat: I don't agree.
04:20:29 <Syzygy-> We can getback from Result to Either String [String] by the isomorphism we get from the way both types are constructed. This isomorphism, composed with whatever we get from Eq for Either gives us the machinery for Eq for Result.
04:20:39 <dcoutts__> hia xerox, long time no see!
04:20:41 <Syzygy-> And this is completely coherent with the way isomorphisms tend to work.
04:22:37 <cperfumo> does anyone know how to use seq in IO monad?
04:23:24 <Syzygy-> ?hoogle seq
04:23:24 <lambdabot> Prelude.seq :: a -> b -> b
04:23:24 <lambdabot> Prelude.sequence :: Monad m => [m a] -> m [a]
04:23:24 <lambdabot> Prelude.sequence_ :: Monad m => [m a] -> m ()
04:23:32 <Syzygy-> what is it supposed to do?
04:23:46 <goltrpoat> syzygy:  i guess technically, not without the extra natural transformations on whatever we're using to take Either String [String] to Result, right
04:24:12 <goltrpoat> i follow you, but saying "Either String [String] is isomorphic to Result" still seems dodgy to me
04:24:54 <Syzygy-> I don't agree. Again. Saying it without being aware of the questions inherent - such as "isomorphisms of WHAT?" - is dodgy.
04:25:10 <goltrpoat> well, exactly.
04:25:46 <Syzygy-> But it seems to me that there is a way to talk about types which makes these isomorphic,and it's even rather intuitive how and what.
04:26:08 <goltrpoat> i assumed types.  i'm too tired to come up with a good counterexample.  but then another person might assume sets
04:26:42 <Syzygy-> I'm very used to concrete categories.
04:28:59 <ski> mayhaps types as dcpos or something ?
04:29:07 <Syzygy-> dcpo?
04:29:20 <ski> directed complete partial order
04:29:26 <ski> (iirc)
04:29:45 <Syzygy-> With the order being? And how is this better than Haskell type system as a category?
04:30:17 <ski> e.g., 'Maybe ()' is not iso to 'Bool', since the former has an extra value in the partial order
04:30:23 <Syzygy-> Never mind that second question.
04:30:24 <ski> partial order being definedness
04:30:38 <ski> forall a. _|_ [= a
04:31:02 <Syzygy-> ski: oooooook. I really want to know how you define this po-structure.
04:31:11 <Syzygy-> Looks interesting, andI'm not certainIunderstandit.
04:31:22 <Syzygy-> (sorry for the rambling. I have a dodgy space bar here)
04:31:23 <goltrpoat> i think the way i'm visualizing it is Either in its own category, with an injection into Eq, and we want a functor that preserves the injection, so there needs to be extra machinery
04:31:30 <ski> i don't recall details .. i have just skimmed some papers that used such to model types
04:31:41 <goltrpoat> which, come to think of it, is weird.
04:31:48 <Syzygy-> goltrpoat: That's REALLY weird.
04:31:53 <goltrpoat> yeah.
04:31:56 <goltrpoat> ok, i'm on crack.
04:31:59 <Syzygy-> Yeah.
04:32:05 <Syzygy-> I'm doubting you could formalize this.
04:32:07 <goltrpoat> i figured you had to be right, but i wasn't quite sure why :)
04:32:13 <Syzygy-> Ehe
04:32:51 <goltrpoat> on that note, it's 6:30am, and my girlfriend looks like she's about to kill me, so i think that means i should go to bed.
04:33:00 <ski> (anyway, 'isomorphic' is always relative to which structure should be preserved ..)
04:33:07 <Syzygy-> Awwwww. Why not discuss categories with her instead.
04:33:10 <goltrpoat> haha
04:33:13 <goltrpoat> i'll try that
04:33:19 <goltrpoat> adios
04:34:02 <Syzygy-> ski: Personally I think that structurepreserving is kinda out-of-date for isomorphisms... The category theory version is much saner, and depends on the category bothering about the structure instead.
04:35:42 <ski> Syzygy- : yes, i thought what i said was consistent with that
04:36:01 <Syzygy-> ski: You're still talking about the isomorphism as being responsible for preserving structures.
04:36:15 <Syzygy-> And I'm talking about isomorphisms being a result of the category used.
04:36:27 <Syzygy-> There is a fine, but important difference between these viewpoints.
04:36:50 <ski> yes .. because the isomorphism consisting of two morphisms, which are structure-preserving (what that means depend on the category)
04:37:22 <Syzygy-> And my point is that morphisms don't have to be defined through preservation of some structure or other.
04:37:22 <ski> (i don't see the difference)
04:37:44 <Syzygy-> Have you seen a construction of derived categories?
04:38:07 <ski> i meant like defining that "structure-preserving" in terms of what morphisms there are :)
04:38:08 <sieni> aww
04:38:13 <Syzygy-> There a bunch of categories are built, one on top of the other, and only in the first or so step, you really have structure-preserving.
04:38:31 <Syzygy-> If you use "structure-preserving" to mean just morphism, you're losing out on semantics.
04:39:26 <ski> what should it mean, in your opinion ?
04:40:19 <sieni> what is a "structure"
04:40:22 <Syzygy-> Structure preserving, in my opinion, should mean that whatever functions are guaranteed to exist foran object commute with the map.
04:40:38 <Syzygy-> sieni: Like groups, vector spaces, et.c.
04:40:53 <sieni> something like a concrete category or what?
04:41:00 <ski> like in universal algebra ?
04:41:31 <sieni> do topological spaces have a structure in your sense?
04:41:38 <Syzygy-> ski: Very much so.
04:42:10 <Syzygy-> sieni: Topological spaces have a structure. That of the hierarchy of open sets. And morphisms are defined as all maps respecting open sets.
04:43:15 <Syzygy-> Whereby topological spaces not necessarily have the structuregiven as maps per se ... i may need quite abit of work before having these ideas formalized quite properly. i have a clear imageof it in my mind though :P
04:43:28 <Syzygy-> (apologies for lack of space and shift)
04:43:55 <sieni> well, at least the definition of a concrete category is, well, concrete and not all categories are concrete
04:44:06 <ski> ty .. would like to see your ideas more elaborated, later
04:44:57 <Syzygy-> sieni: And this is very much the point why I think that isomorphisms should NOT be discussed preassuming that all categories are concrete.
04:46:15 <Syzygy-> Specifically, I don't think that types should be treated necessarily as objects inconcrete categories; and thus discussing type isomorphisms using structure-preservation as a key argument triggers my sensibilities in the matter. :)
04:47:09 <ski> hm, iirc 'abstract' here means just that you don't view it as built concretely on another category, yes ?
04:47:12 <Syzygy-> (in concrete categories <<- correct spacing)
04:47:40 <Syzygy-> Abstract here means that you work from category axioms. Concrete means that it is built on sets with additional structure.
04:48:04 <ski> (or at least built from some other category)
04:48:08 <Syzygy-> I don't mean concrete category as "something you'd understand", I mean it as "something with a forgetful functor to Set"
04:48:18 <ski> right
04:48:55 * ski seems to recall such from "Abstract and Concrete Categories, The Joy of Cats"
04:49:01 <Syzygy-> Yah
04:49:54 <Syzygy-> And yes, I think it's cool that I can spend hours discussing fine points of the usage of categorytheory in programming. On a programming irc channel.
04:53:40 <syntaxfree> I'm confused about choosing one of the existing web frameworks.
04:53:50 <Syzygy-> Then don't.
04:53:51 <Syzygy-> ;)
04:54:00 <syntaxfree> The ones I've seen (HappS and WebFunctions) compile to a web server itself.
04:54:10 <Saizan> a good book on category theory? (for a not group/topology initiated)
04:54:12 <syntaxfree> I'd like to compile to an executable that's called via CGI.
04:54:20 <syntaxfree> Saizan: Asperti & LOngo.
04:54:23 <Syzygy-> Saizan: Categories for the working mathematician ;)
04:54:47 <syntaxfree> "Categories for the working mathematician" and "Abelian categories" are the deeper books I've seen on the subjects.
04:55:13 * Syzygy- has absorbed most of his category theory from learning and doing homological algebra.
04:55:16 <sieni> and weibel's book on homological algebra!
04:55:18 <syntaxfree> Easier, introductory books are "Arrows, structures, functors" by Michael Arbib and "Categories for the working computer scientist" by Asperti & Longo.
04:55:43 <Syzygy-> Oh yes. Don't forget Hilton&Stammbach and MacLanes homologicalalgebra bookseither  - they have really good category theorysections
04:55:55 <Syzygy-> Though slightly tainted by the module category case :)
04:56:01 <syntaxfree> Syzygy-: I think he wants something more basic.
04:56:11 <Syzygy-> syntaxfree: Wha? Hilton&Stammbach isn't basic?
04:56:13 <sieni> although weibel's book contains an irritating elementary mistake in the set theory tutorial that it contains
04:56:17 <Saizan> i'll try the latter, i've started ".. working mathematician" but i'm not a working matematician it seems :D
04:56:26 <syntaxfree> Syzygy-: I don't know Hilton&Stambach.,
04:56:43 <Syzygy-> syntaxfree: It's an updated companion volume to MacLane: Homology.
04:56:45 <syntaxfree> I've seen "Categories for the working mathematician", and frankly couldn't make sense of it.
04:56:51 <Syzygy-> It's out of date by now, though.
04:57:01 <syntaxfree> Then again, I was more naïve when I saw it.
04:57:34 <syntaxfree> I'd really recommend Asperti & Longo. It's an "applied math"  book all throughout, and much closer to computer science.,
04:57:53 <Syzygy-> Which probably'd make me run away from it, so you'll probably end up liking it. ;)
04:57:59 <Saizan> ok, thanks :)
04:58:16 <syntaxfree> Saizan: ftp://ftp.di.ens.fr/pub/users/longo/CategTypesStructures/book.pdf
04:58:22 <fasta> How can I reexport Data.Array.Diff from a module? I tried module Foo(module Data.Array.Diff) where ..., but it gives as a warning: that Data.Array.Diff doesn't export anything.
04:58:39 <Syzygy-> Hmmmm... TT&T may also be worth looking at.
04:58:42 <Saizan> i like abstraction but i feel i don't have the background for it in this field
04:58:44 <syntaxfree> Syzygy-: sometimes it helps to read the Apostol-like calculus books before dicking around with real analysis, to use an analogy.
04:59:11 <Syzygy-> syntaxfree: Sorry. analysis-analogies tell me next to nothing. I haven't read any analysis since Baby Rudin.
04:59:24 <syntaxfree> Saizan: well, cat theory is all about abstraction. The advantage of Asperti & Longo to me is that it doesn't have many prerequisites and its examples are closer to CS.
05:00:02 <syntaxfree> Syzygy-: well, you could replace "analysis" with "topology" if you want. The analogy remains.
05:00:17 <Saizan> syntaxfree: perfect, thanks :)
05:00:21 <Syzygy-> Did Apostol write topology?
05:01:05 <syntaxfree> I was comparing Apostol's "Calculus" with an arbitrary topology manual.
05:01:18 <Syzygy-> Ah. I've never seen that one.
05:01:25 <Saizan> ooh Asperti and Longo are italians, maybe there's an italian version too?
05:01:33 <Syzygy-> Saizan: Quite possible.
05:01:35 <pejo> fasta, module PP (module Text.PrettyPrint) where <..> works for me.
05:01:55 <syntaxfree> He works at France, it seems.
05:02:02 <fasta> pejo: hmm, odd.
05:02:18 <syntaxfree> Syzygy-: Well, Apostol is pretty much the standard calculus manual around these parts.
05:02:29 <syntaxfree> Some like Spivak, but he's too chatty for my tastes.
05:03:01 <syntaxfree> anyway, back to web frameworks..
05:03:23 <syntaxfree> The ones I've seen (HappS and WebFunctions) compile to a web server itself, and I'd like to compile to an executable that's called via CGI.
05:04:14 <pejo> fasta, module Test2 (module Data.Array.Diff) where RET import Data.Array.Diff RET idd x = x doesn't give me any warnings either.
05:04:38 <fasta> pejo: can you add foo = id to Test2?
05:04:48 <fasta> pejo: Maybe I misinterpreted the error.
05:05:30 <pejo> fasta, shrug, a bunch of warnings about no type signatures, and that functions are defined but not used, but nothing else.
05:05:51 <fasta> pejo: I do use 6.7, never mind it.
05:07:36 <fasta> pejo: When I substitute MArray for Diff, I don't get the warning.
05:10:43 <xerox> Saizan: did you find the italian version by chance? (:
05:11:08 <Saizan> xerox: no, :\
05:11:20 <xerox> Dang.
05:12:17 <benja_> damn, my monad tutorial draft is too wordy and the io stuff is too complicated. I think I'll need to shelve it and start over.
05:12:50 <benja_> pity -- it would probably have been one of the first monad tutorials to be written on a cell phone =)
05:13:10 <benja_> http://flowerpot.kaijanaho.fi/~benja/2006/monads.html
05:13:12 <lambdabot> Title: Benja's monads tutorial (unfinished draft)
05:13:35 <joelr1> good afternoon
05:14:10 <joelr1> Cale: did you write the hrss example that uses arrows?
05:15:00 <xerox> > "hiya " ++ iterate (++"_") "dcoutts"
05:15:01 <lambdabot>  Couldn't match `[Char]' against `Char'
05:15:11 <xerox> > "hiya " ++ (iterate (++"_") "dcoutts")
05:15:13 <lambdabot>  Couldn't match `[Char]' against `Char'
05:15:26 <xerox> hiya dcoutts dcoutts_
05:15:40 <ToRA> >"hiya " ++ (concat.(iterate (++"_") "dcoutts"))
05:15:45 <int-e> > unwords $ "hiya":(iterate (++"_") "dcoutts")
05:15:46 <lambdabot>  "hiya dcoutts dcoutts_ dcoutts__ dcoutts___ dcoutts____ dcoutts_____ dcoutts...
05:15:53 <ToRA> > "hiya " ++ (concat.(iterate (++"_") "dcoutts"))
05:15:53 <lambdabot>    Expecting a function type, but found `[a]'
05:15:53 <lambdabot>    Expected type: a1 -> [[...
05:16:01 <xerox> haha... please, it's fine :)
05:17:12 <joelr1> @seen musasabi
05:17:13 <lambdabot> I saw musasabi leaving #ghc, #haskell-overflow, #haskell-blah, #haskell and #Haskell 1m 3d 22h 28m 42s ago, and .
05:17:22 <joelr1> wow! where did musasabi go?
05:26:01 <Lor> You can ask him over at ircnet. :)
05:26:58 <joelr1> Lor: ircnet?
05:27:20 <joelr1> is there another haskell channel?
05:27:41 <Keith_Adams> Good morning, #haskell!
05:27:48 <Lor> I didn't say so. Probably not.
05:27:57 <sieni> Lor: nice screen savers you have btw (the poster installation dropped to the floor)
05:28:30 <Lor> Big surprise.
05:51:40 <cperfumo> does anyone know how to force evaluation (avoid lazy eval) within IO monad?
05:51:42 <syntaxfree> bringert++
05:51:51 <syntaxfree> (did it pick it up?)
05:52:11 <nornagon> ?karma bringert
05:52:12 <lambdabot> bringert has a karma of 18
05:52:58 <syntaxfree> Hope looks interesting. But it doesn't have much of a community, sp. templates, etc.
05:53:04 <xerox> cperfumo: seq a b strictly evaluates its first argument and returns its second.
05:54:52 <syntaxfree> Too Many Web Programming Frameworks!
05:54:56 <cperfumo> xerox: good, how to use it in IO Monad?
05:55:04 <Lemmih> @type Control.Exception.evaluate
05:55:06 <lambdabot> forall a. a -> IO a
05:56:03 <xerox> It depends on what you are doing.  Lemmih's suggestion is pretty interesting.
05:58:17 <kowey> one possible hrss-ish mini-project might be to write an openid client lib and integrate it into things like Hope
05:58:45 <kowey> sort of a "look, it's useful for 'practical things' too" idea
05:59:22 <kowey> one could then follow up by writing an OpenId implementation as well
05:59:43 * syntaxfree is beginning to consider learning Rails.
06:03:12 <Saizan> aren't cgi and web frameworks two quite different approaches?
06:04:02 <syntaxfree> CGI is how the server communicates with the program.
06:04:27 <syntaxfree> When there's no mod_perl/mod_php/whatever to make the process easier, people fall back on CGI.
06:05:13 <Saizan> yeah i know that, and it's wuite different from tomcat/django/rails whatever
06:05:48 <syntaxfree> well, django and rails don't use CGI because there's already a mod_python and a mod_ruby. But isn't that really besides the point?
06:06:04 <syntaxfree> http://en.wikipedia.org/wiki/Web_framework
06:06:53 <bringert> syntaxfree: have you seen fastcgi?
06:07:28 <syntaxfree> I'm not worried about the communication protocol right now; the app's gonna start pretty small, so it doesn't matter much.
06:08:32 <syntaxfree> I wanna start right by building upon the best stack, though. My head groks FP much better than object-oriented programming, but I can't really make sense of the dozens of web libraries/frameworks available in Haskell and documented with a PhD thesis.
06:08:50 <bringert> syntaxfree: fair enough. If you go with the haskell cgi package, you can very easily use you program with fastcgi later.
06:09:54 <syntaxfree> I actually just wrote an email to this provider I'm considering asking for details on what kind of Haskell support they provide.
06:10:35 <bringert> syntaxfree: yeah, that's a problem. shankys is working on what seems to be a more practical framework, but I don't think it's public
06:10:47 <cperfumo> can I do "x <- atomically(..." and after that "evaluate x" in order to assure that in that moment it will be evaluated?
06:11:10 <bringert> syntaxfree: being able to upload a statically linked CGI binary should be enough, but more could be nice of course
06:13:44 <syntaxfree> At times it seems better to just start out from some CMS/blog package and start hacking application logic into it.
06:14:04 <syntaxfree> at least templating is taken care ofl
06:14:06 <syntaxfree> s/ofl/of.
06:14:49 * syntaxfree is designing a job board oriented around peer-to-peer recommendations and testimonials.
06:15:11 <syntaxfree> Testimonials have some structure, though. Peers rate each other's trustworthiness, problem-solving skills, yadda yadda.
06:15:39 <shankys> syntaxfree: Interesting... Is this a startup or a part-time thing on the side?
06:15:45 <Philippa_> syntaxfree: you might want to specify trustworthiness carefully
06:16:43 <syntaxfree> shankys: I'm in grad school, and I have a two-month recess ahead.
06:16:56 <Philippa_> I'm mostly thinking of the distinction between "can I trust this person to tell the truth and act on their promises" vs "can I trust them with a tight deadline" (some people the answer to the latter might be no but they'd say as much, for example - they're still trustworthy)
06:16:58 <syntaxfree> I don't feel like doing any research, so I thought I might as well see what I can hack up.
06:17:31 <syntaxfree> Philippa: deadline-meeting is correlated to trustworthiness, but not by much.
06:17:49 <syntaxfree> Deadline-meeting is much more correlated to the ability of correctly estimating your own productivity.
06:18:23 <syntaxfree> I have a huge problem estimating how long a project will take me, and yet that doesn't mean people can't rely on me -- they just need to assist me in setting realistic goals.
06:18:34 <fasta> syntaxfree: Do you know that those things already exist?
06:18:41 <shankys> syntaxfree: Hehe, I know what you mean. Have you started working on your project? And if so what are you using to build it?
06:18:52 <Philippa_> syntaxfree: that, and to telling people when they're asking for too tight a deadline
06:19:44 <syntaxfree> that's assertiveness.
06:20:04 <syntaxfree> shankys: I've just started shopping around for basic tools.
06:20:12 <syntaxfree> I'm looking at the Haskell web frameworks, but ain't too happy.
06:20:37 <shankys> syntaxfree: I came to the same conclusion, and decided to roll my own using existing components
06:21:31 <syntaxfree> I once tried to roll my own basic tools in PHP. In the end, I had just built function wrappers around common SQL queries and function wrappers around common combinations of these function wrappers.
06:21:45 <syntaxfree> It works, and I built a toy or two, but it's a mess.
06:21:46 <shankys> syntaxfree: Getting things to interoperate nicely is a pain though and takes a fair amount of work if you want to roll your own.
06:23:32 <diegito> Hi everybody! i'm a new haskell user searching for some answers on the language... can i ask to someone?
06:23:44 <syntaxfree> You can ask everyone.
06:23:52 <Syzygy-> Just ask away.
06:24:10 <syntaxfree> Don't worry, we look evil but we're sweet people.
06:24:24 * syntaxfree thinks these vampire teeth really scare people away.
06:24:55 <diegito> eheh of course :) so.. i find some problems using the lazyness of the language and i want to learn how to use that...
06:25:19 <xerox> odds = 1 : map (+1) evens; evens = map (+1) odds
06:26:01 <syntaxfree> dieguito: the best thing is to think of Haskell statements as equations.
06:26:20 <syntaxfree> You're never really sending out orders to a compiler, as you've probably been taught to think of programming as. It's more like defining things.
06:26:40 <syntaxfree> That's why Haskell is often referred as a "declarative" programming language. Write what you mean.
06:26:52 <syntaxfree> Write what things mean.
06:27:38 <diegito> things... objects? which have attributes
06:27:48 <syntaxfree> functions.
06:27:54 <syntaxfree> a Haskell program is a series of equations.
06:28:15 <fasta> diegito: If you really want to do something in Haskell:
06:28:22 <fasta> @where rafb
06:28:22 <lambdabot> Read A F*cking Book. This entry was inspired by ##c++
06:28:28 <syntaxfree> haha.
06:28:49 <syntaxfree> jesus, let us not RTFM the newbies.
06:29:08 <syntaxfree> @where DFRTN Don't F*cking RTFM the Newbies
06:29:08 <lambdabot> I know nothing about dfrtn.
06:29:11 <syntaxfree> er,
06:29:18 <syntaxfree> @where+ DFRTN Don't F*cking RTFM the Newbies
06:29:19 <lambdabot> Done.
06:29:29 <fasta> cute
06:29:40 <xerox> diegito: lazy means that things are computed if and only if they are actually needed, do you have any specific question?
06:30:18 <diegito> i have a problem to apply the laziness on, i don't know actually how to do that...
06:30:24 <vegai> for #haskell, that might be "Write a F*cking Dissertation"
06:30:25 <fasta> Imo it's not really "Actually needed".
06:30:49 <fasta> Since if that would be the case the compiled has to be omniscient.
06:30:54 <fasta> er compiler
06:31:22 <shankys> bringert: You maintain HaskellDB so you're probably in the know about Haskell database stuff. Do you know any projects that make use of Takusen? I can't really find anything, and Takusen's authors never seem to be on #haskell (I was using HDBC for the web framework's backend but didn't like the lazy IO so I'm contemplating a switch to Takusen).
06:31:35 <xerox> diegito - Laziness is turned on by default.
06:31:55 <syntaxfree> dieguito: don't worry too much about that.
06:32:08 <xerox> > [1..]
06:32:09 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
06:32:12 <xerox> It usually does what you want.
06:32:23 <Philippa_> diegito: just do it, and don't worry about infinities
06:32:25 <syntaxfree> dieguito: Write a toy project, and when/if things don't behave as you expect them to, come here and ask away.
06:32:33 <syntaxfree> dieguito: just remember to use the pastebot.
06:32:38 <syntaxfree> @paste
06:32:39 <lambdabot> http://paste.lisp.org/new/haskell
06:32:42 <fasta> diegito: In C you have references to values and values. In Haskell you only have values, but they are references to value under the hood.
06:32:50 <syntaxfree> (when you mean to show us some code)
06:34:06 <xerox> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
06:34:08 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
06:34:33 <fasta> xerox: For a "newbie" I think that example is too difficult.
06:34:51 <fasta> (I'd recommend him to read SICP first. )
06:35:41 <syntaxfree> fasta: Maybe you'd recommend he learns calculus, functional analysis, homologic algebra and category theory as well?
06:35:47 <syntaxfree> Jesus, just help the kid do what he wants.
06:35:49 <fasta> Cale has made pretty nice graphics for illustrating folds (and other structures)
06:35:51 <xerox> I don't think it is difficult, you can carry out why it works by using the definition of zipWith together with equational reasoning.
06:36:18 <diegito> syntaxfree: ok, ihad difficulties in an exercise i had to use lazyness to solve it but i can't figure out how to...
06:36:20 <Jaak_> > const 1 (length (reverse [1..]))
06:36:28 <lambdabot>  1
06:36:48 <syntaxfree> dieguito: tell us more.
06:37:10 <xerox> zipWith _ [] _ = []; zipWith _ _ [] = []; zipWith f (x:xs) (y:ys) = f x s : zipWith f xs ys
06:37:56 <fasta> syntaxfree: There's little wrong with learning those things, although I think it's more extreme than I suggested.
06:38:15 <syntaxfree> I should learn some more algebra, one of these days.
06:38:20 <xerox> fibs = 0 : 1 : zipWith (+) fibs (tail fibs)   fibs = 0 : 1 : zipWith (+) (0 : 1 : ...) (1 : ...)   fibs = 0 : 1 : 1 : zipWith (1 : 1 : ...) (1 : ...)   fibs = 0 : 1 : 1 : 2 : zipWith (+) (1 : 2 : ...) (2 : ...)   and so on.
06:38:39 <syntaxfree> I want to take a number theory course this summer. I'm hella afraid of becoming one of those number theory trolls, though.
06:38:48 <syntaxfree> 9 out 10 mathematical cranks are number theory trolls.
06:38:52 <fasta> > if length [1..] > length [1..10] then True else False -- look Haskell is not that lazy
06:38:57 <lambdabot> Terminated
06:39:25 <syntaxfree> There's no "infinity" number.
06:39:40 <syntaxfree> You can't compare infinities to finite numbers in mathematics.
06:39:46 <xerox> > 1 / 0
06:39:48 <lambdabot>  Infinity
06:39:52 <xerox> :0
06:39:55 <syntaxfree> okie :)
06:39:57 <diegito> syntaxfree:the exercise was to find the minimum of a list and then subtract that minimum to the list using the lazyness
06:40:00 <syntaxfree> > length [1..1000] > length [1..10]
06:40:01 <lambdabot>  True
06:40:12 <syntaxfree> (if p then True else False)  is an ugly way of writing just "p".
06:40:33 <syntaxfree> > length [1..100000000000000000000000000000000000000] > length [1..10]
06:40:38 <lambdabot> Terminated
06:41:05 <syntaxfree> maybe there's some research to be done in the area of same-function comparisons.
06:41:40 <syntaxfree> [f x `compare` f y]-type expressions can often be optimized by evaluating them side-by-side smartly.
06:41:56 <syntaxfree> maybe with coroutines or something.
06:42:06 <syntaxfree> dieguito:
06:42:30 <bringert> shankys: I don't know of any projects using Takusen. You can easily write a strict layer on top of HDBC, or modify HDBC.
06:42:30 <Syzygy-> syntaxfree: Actually, you can compare infinities to numbers.
06:42:46 <cperfumo> @paste
06:42:46 <lambdabot> http://paste.lisp.org/new/haskell
06:43:06 <syntaxfree> > let f x = map (\y->y - (minimum x)) x  in f [9, 5, 12, 3]
06:43:08 <lambdabot>  [6,2,9,0]
06:43:16 <syntaxfree> Syzygy-: Oh. Maybe I'm just stupid :)
06:43:18 <bringert> shankys: I think I proposed some strict functions to cosmicray a while back, but I can't remember the details
06:43:20 <Syzygy-> For instance, one useful definition of positive and negative infinities in extended number systems are symbols with specific participation in the algebraic structure, and being greatest or least elements.
06:43:35 <Syzygy-> That doesn't necessarilymakethe cranks rightthough.:)
06:43:36 <syntaxfree> diegito: did you see the solution to your problem? Not that hard, is it?
06:43:47 <shankys> shankys: I also like Takusen's design with the left-fold enumerator
06:43:56 <lisppaste2> cperfumo pasted "stack overflow" at http://paste.lisp.org/display/33620
06:44:05 <shankys> bringert: Whoops... I also like Takusen's design with the left-fold enumerator
06:44:14 <xerox> Such extensions, like the hyperreal numbers, have pros and cons.
06:44:36 <syntaxfree> > > let f x = map (\y->y - (minimum x)) x  in f [9, 5, 12, 3, 4, 9, 12, 1, 1, 17]
06:44:36 <lambdabot>  Parse error
06:44:40 <xerox> Woops.
06:44:46 <syntaxfree> > let f x = map (\y->y - (minimum x)) x  in f [9, 5, 12, 3, 4, 9, 12, 1, 1, 17]
06:44:48 <lambdabot>  [8,4,11,2,3,8,11,0,0,16]
06:44:50 <shankys> bringert: If nothing else, I want to check it out for ideas I could use. I've got a decent handle on how it works, it would just be nice to see some real world code.
06:44:52 <syntaxfree> this is a cool function, somehow.
06:45:12 <cperfumo> I pasted something and i wanted to ask for some help. I recieve stack overflow when i give it big numbers, like 100000. Can someone give me any help?
06:45:17 <cperfumo> http://paste.lisp.org/display/33620
06:45:18 <bringert> shankys: ask the authors, they seem to respond to takusen questions on the mailing lists
06:46:47 <xerox> In fact it turns out that one can't define + and * on R* = R U {-oo,+oo} maintaining all of their nice properties intact.
06:46:50 <shankys> bringert: Alright, I need to ask them about how to fix ghci being broken in the latest Takusen release anyway (I might end up fixing it if it's not too much work) so I'll post to haskell-cafe.
06:50:57 <lisppaste2> diegito pasted "exercise" at http://paste.lisp.org/display/33621
06:51:18 <diegito> syntaxfree: this is what i was thinking and it's wrong...
06:52:11 <diegito> my first solution looked like this: stz xs = map (-minimum xs) xs
06:52:47 <diegito> but this do not use the lazyness
06:55:41 <Jaak_> heh, it has really nice solution :P
06:56:22 <Jaak_> but i don't think you can do it with foldr
06:56:26 <dcoutts__> xerox: had a good holiday then eh?
06:56:41 <augustss> howdy
06:56:53 <dcoutts__> xerox: btw, no need to iterate _ I can see them all :-)
06:57:35 <augustss> Jaak_: something you can't do with foldr?  *gasp*
06:57:44 <dcoutts__> cperfumo: did you seq in IO question get answered? take a look at 'evaluate'
06:57:53 <Jaak_> you can, but not like this
06:57:53 <xerox> dcoutts_ hehe, 'lo!  Yes I did.  Did you have a good Christmas?
06:57:59 <Jaak_> i *think*
06:58:07 <dcoutts__> xerox: I did, yes and Norway was fun too
06:58:11 <fasta> syntaxfree: I think Cantor has something to say about sizes of infinite sets...
06:58:46 <dcoutts__> xerox: for new year's eve I'll be in a National Trust stately home / mansion (a friend of mine is the house manager) :-)
06:58:59 <augustss> fasta: yes, but things are easier in Haskell.  all infinite sets have the same size. :)
06:59:09 <xerox> dcoutts_ - What's that?
06:59:37 <fasta> augustss: yes, a limitation of constructive mathematics.
06:59:41 <dcoutts__> xerox: it's a huge 18th century gothic mansion with 100's of rooms, vast grounds etc
07:00:01 <augustss> fasta: I see it as a strength
07:00:16 <dcoutts__> xerox: it's owned by a charity and is normally open to the public
07:00:44 <xerox> http://www.nationaltrust.org.uk/main/w-vh/w-visits/w-findaplace.htm
07:00:45 <xerox> :D
07:00:47 <lambdabot> Title: National Trust | Find a place, http://tinyurl.com/yl8o86
07:00:58 <fasta> augustss: well, it would have been nice if constructive mathematics was equal to just "mathematics".
07:01:15 <dcoutts__> @google national trust Tyntesfield
07:01:16 <lambdabot> http://www.nationaltrust.org.uk/main/w-vh/w-visits/w-findaplace/w-tyntesfield.htm
07:01:17 <lambdabot> Title: National Trust | Tyntesfield
07:01:27 <dcoutts__> xerox: nice huh? :-)
07:01:30 <xerox> Wow, that looks nice!
07:01:52 <fasta> Friends in high places, huh? ;)
07:01:56 <augustss> fasta: you might thinks so, but I think construvtive is the way to go.  so i'm just as glad you can't do the weird things regular mathematics allows
07:02:10 <dcoutts__> fasta: something like that
07:02:31 * dcoutts__ dissapears in search of lunch
07:02:34 <xerox> Bye!
07:02:51 <augustss> dcoutts: wow, cool looking place
07:03:13 <fasta> augustss: I understand what you mean, but I'd rather have existential claims than no claims. Everyone (?) likes constructive proofs more than non-constructive ones.
07:03:38 <Jaak_> diegito: because of lazyness you can always assume that you already have the minimum element. other that that you have recursion sceme similar to foldr
07:04:00 <fasta> Too bad constructive proofs are generally a lot longer than non-constructive ones
07:04:09 <Jaak_> scheme*
07:04:36 <diegito> jaak_: ok, but how could i do that without incurring in 'x not in scope' errors?
07:04:55 <Syzygy-> I like constructive more than non-constructive, but i like proofs at all more than no proofs, and I like proofs i grok more than proofs I don't...
07:05:14 <Jaak_> submin xs = ys where (m, ys) = f xs; f ... = ...
07:05:15 <augustss> fasta: that's ok if you believe in the axioms classical maths, i'm not sure I do.
07:05:36 <Syzygy-> augustss: Bitten by the intuitionist bug? :)
07:06:19 <fasta> Brouwer ftw!
07:06:28 <augustss> Syzygy-: oh, for the last 25 years :)
07:07:23 <qwr> hmm, why the debians ghc6 thinks, that Control.Monad.Reader don't exists?
07:07:58 <dylan> you need mtl I think.
07:08:52 <vegai> qwr: do you have the extra libs?
07:08:58 <dylan> libghc6-mtl-dev
07:09:01 <qwr> thanks, that helped
07:09:38 * vegai finds the practice of splitting everything a bit silly
07:09:44 <Cale> btw, I have some new versions of the scanl and scanl1 diagrams which are straightened out to show their structure better:
07:09:46 <vegai> but that's probably a discussion for some other channel
07:09:47 <Cale> http://cale.yi.org/index.php/Fold_Diagrams
07:09:51 <lambdabot> Title: Fold Diagrams - CaleWiki
07:09:59 <Jaak_> diegito: like that you can use m in f's scope. f has to do 2 things, compute min elem and subtract it from list at the same time:)
07:10:02 <Cale> er, oops :)
07:10:12 <dylan> vegai: well, take it up with Igloo I think. ;)
07:10:27 <dylan> I prefer modular packages to monolithic ones.
07:10:35 <vegai> dylan: no, I'd have to take it up with Debian
07:10:54 <vegai> And I don't mess with Debian :P
07:10:55 <dylan> especially on horrible net connections.
07:11:23 <Cale> there we go
07:13:16 <diegito> Jaak_: so f:: [a] -> (a,[a])
07:14:00 <Jaak_> yes
07:14:27 <Jaak_> f :: (Ord a, Num a) => [a] -> (a,[a])
07:18:54 <fasta> I can't write this without foo, right? (list ! lui)>>= \foo->return foo{next=x})
07:19:48 <fasta> (or without introducing a "helper function".)
07:20:12 <wolverian> right, can't curry record syntax.
07:22:41 <MarcWeber> http://rafb.net/p/sv7gix42.html Can you have look at this error? What am I doing wrong?
07:22:43 <lambdabot> Title: Nopaste - compiler error I can&#039;t cope with
07:22:46 <diegito> jaak_: f (x:xs) = ((min x m),x-m:ys)
07:23:04 <diegito> or something like this?
07:23:22 <Saizan> you should not use m to calculate m
07:23:42 <Jaak_> no, you can't use m in computing the min
07:24:38 <Saizan> (neither ys to compute ys)
07:28:03 <augustss> MarcWeber: you can't have a context in a type definition
07:28:19 <diegito> Jaak:...i can't figure out how to do... the only way i see is to use minimum and then a map to archieve the ys...
07:30:03 <syntaxfree> diegito: that's bad.
07:30:25 <Jaak_> you are basically doing that with the lazy solution. and forget the ys, ys is already the solution
07:30:32 <Jaak_> bah
07:31:44 <diegito> ...
07:31:46 <Jaak_> i can't really give more hints :P
07:32:36 <Saizan> to compute f (z:zs) you should rely on f zs
07:35:21 <Jaak_> that should be more than enough for solution :P
07:35:39 <MarcWeber> augustss: Can you give me another hint how to do it the right way?
07:36:44 <syntaxfree> marcweber: is the error in line 7?
07:36:56 <MarcWeber> Yes
07:37:02 <fasta> MarcWeber: you need to delete (Monad m)
07:37:05 <MarcWeber> If you scroll down you can see the error message
07:37:14 <syntaxfree> You can't have context in type synonyms.
07:37:19 <syntaxfree> type synonyms are just that.
07:37:29 <fasta> MarcWeber: and you need to add m as type parameter
07:37:46 <augustss> MarcWeber: You'd have to make 'm' another argument of Parser, or fix it to some particular monad.
07:37:55 <ph8> is there an easy way to output a [[char]]?
07:38:08 <ph8> let var = [[char]]; show var?
07:38:18 <MarcWeber> I don't wont to fix it because I want to use IO or Identity.
07:38:29 <augustss> ph8: yes, but how do you want printed?
07:38:41 <ski> > show [["a","b"],["c","d"]]
07:38:42 <MarcWeber> ph8: What about (print . unlines) [['a']] ?
07:38:43 <lambdabot>  "[[\"a\",\"b\"],[\"c\",\"d\"]]"
07:38:48 <augustss> MarcWeber: then make it an argument
07:39:06 <MarcWeber> I'll try
07:39:28 <ski> (MarcWeber : preferably the last argument before 'result')
07:39:34 <Saizan> > show [['a','b'],['c','d']]
07:39:35 <MarcWeber> ski: be careful: Char not String
07:39:36 <lambdabot>  "[\"ab\",\"cd\"]"
07:39:43 <ski> MarcWeber : ah
07:40:11 <MarcWeber> > (print . unlines) [[ 'a', 'b'],['c','d']]
07:40:12 <ski> ph8 : do you want to print each string on a line ?
07:40:13 <lambdabot>  <IO ()>
07:40:52 <ph8> it's just a debug thing
07:40:55 <MarcWeber> > (putStrLn . unlines) [[ 'a', 'b'],['c','d']]
07:40:56 <ph8> so the output i'm getting is suitable for the moment
07:40:57 <lambdabot>  <IO ()>
07:41:00 <ph8> especially since it's [] :p
07:41:02 <ph8> > genNext :: String -> Map [[Char]] [[Char]] -> [[Char]]
07:41:02 <ph8> > genNext needle haystackMap = (findWithDefault [] [needle] haystackMap)
07:41:03 <lambdabot>  Not in scope: type constructor or class `Map'
07:41:03 <lambdabot>  Parse error
07:41:20 <ph8> my map definitely contains the key/value: ["small","cat"]:=["sat"]?
07:41:31 <ph8> and i'm hand-typing String
07:41:47 <ph8> which i've tried specifying as 'small cat', "small" "cat", "small", "cat"
07:41:47 <ph8> etc
07:41:52 <ph8> but it always just returns empty
07:42:00 <ph8> (or the default in this case)
07:42:38 <ski> 'genNext' can only lookup keys which are singleton list
07:42:47 <ski> '["small","cat"]' is not a singleton list
07:42:48 <ph8> singleton list?
07:42:59 <ski> a list with exactly one element
07:43:04 <ph8> arg! is that restriction with findWithDefault?
07:43:08 <ski> no
07:43:17 <MarcWeber> > lookup (fromList [("small","cat")]) "cat"
07:43:18 <lambdabot>  Not in scope: `fromList'
07:43:18 <ski> that is a restriction with your 'genNext'
07:43:19 <ph8> I should have it take a [String]?
07:43:28 <ski> if that's what you want :)
07:43:56 <MarcWeber> ph8: There is no real difference. ;) String=[Char]
07:45:12 <ph8> muwahaha
07:45:13 <ph8> it works :)
07:45:23 <ph8> yes i'm having a crap load of problems using [String] to represent [[Char]] though
07:45:26 <ph8> so i always use [[Char]]
07:45:31 <ph8> apart from here it appears :p
07:45:34 <ph8> it works now
07:45:44 <ski> '[String]' is the same as '[[Char]]'
07:57:35 <cperfumo> dcoutts_: I managed to do it by using the function you suggested me, at the beginning it seemed not to work but (by simply putting "evaluate x") but you can always "evaluate (length (show x))". THANK YOU VERY MUCH!!!
08:00:58 <xerox> What about this for calculating the minimum element of a list and then subtracting it from every element of the list:
08:01:10 <xerox> > let (x,xs) = foldl (\(m,k) x -> (if x < m then x else m, (\n -> ((x - n): k n)) )) (10000, const []) [6..10] in xs x
08:01:11 <lambdabot>  [4,3,2,1,0]
08:01:27 <xerox> I don't remember who was asking about that...
08:02:28 <norpan> huh?
08:02:29 <xerox> If you don't mind the reordering, it works :)
08:03:17 <norpan> how about finding the minimum first and then map?
08:04:12 <xerox> > let (x,f) = foldr (\x (m,k) -> (if x < m then x else m, (\n -> (x - n) : k n))) (10000, const []) [1,4,6,2] in f x
08:04:13 <lambdabot>  [0,3,5,1]
08:04:18 <xerox> err
08:04:30 <xerox> Isn't it nice?
08:05:09 <norpan> > let x = minimum list in map (subtract x) list where list = [6..10]
08:05:10 <lambdabot>  Parse error
08:05:15 <norpan> bah
08:05:25 <diegito> t'was me to ask that
08:05:33 <paolino> hi , how I check all elements of a list are the same ?
08:05:34 <norpan> > let list = [6..10]; x = minimum list in map (subtract x) list
08:05:40 <lambdabot>  [0,1,2,3,4]
08:06:23 <xerox> > null .tail . group $ [2,2,2,2]
08:06:32 <xerox> > null .tail . group $ [2,2,1,2,2]
08:06:40 <xerox> paolino -^
08:06:52 <metaperl> > group [2,2,1,2,2]
08:06:54 <lambdabot>  True
08:06:59 <metaperl> true?
08:07:02 <xerox> hehe
08:07:06 <lambdabot>  False
08:07:07 <xerox> It's a True group.
08:07:11 <metaperl> [ [1]. [2,2,2,2]]
08:07:15 <metaperl> thats what I expected
08:07:18 <syntaxfree> > group "#haskell"
08:07:23 <xerox> And that is not what she will say.
08:07:23 <norpan> lambdabot is not done yet
08:07:26 <lambdabot>  [[2,2],[1],[2,2]]
08:07:28 <norpan> you have to wait
08:07:35 <metaperl> oh
08:07:48 <lambdabot>  ["#","h","a","s","k","e","ll"]
08:07:54 <metaperl> i think it has to be sorted first
08:08:06 <metaperl> group $ sort [2,2,1,2,2]
08:08:15 <metaperl> > group $ sort [2,2,1,2,2]
08:08:16 <lambdabot>  [[1],[2,2,2,2]]
08:08:20 <metaperl> there
08:08:21 <allbery_b> why sort?  for this it's good enough (and only strict until it hits the first difference)
08:08:27 <kowey> metaperl: yaht fixed, btw
08:08:29 <xerox> metaperl - For the purpose of the problem, it is not needed, which is pretty nice.
08:08:41 <metaperl> I must've missed the prob
08:08:47 <metaperl> > sort [2,2,1,2,2]
08:08:48 <lambdabot>  [1,2,2,2,2]
08:08:49 <metaperl> oops
08:08:50 <xerox> <paolino> hi , how I check all elements of a list are the same ?
08:08:56 <metaperl> > group [2,2,1,2,2]
08:08:57 <lambdabot>  [[2,2],[1],[2,2]]
08:09:03 <metaperl> oh interesting
08:09:10 <xerox> :)
08:09:26 <paolino> it should exit on first difference!
08:09:47 <xerox> It does.
08:09:59 <dcoutts__> cperfumo: seq and evaluate only force the first level of a value, to force all levels you can use something like you came up with using show etc, for the general case take a look at Control.Parallel.Strategies
08:10:01 <xerox> Remember Haskell is lazy.
08:10:36 <norpan> > null . tail . group $ [1..]
08:10:38 <lambdabot>  False
08:10:41 <ph8> sorry for all the noobie questions, but why is this wrong?
08:10:41 <norpan> lookie
08:10:41 <ph8> >		let genWords = words genString
08:10:42 <ph8> >		putStrLn "Showing " ++ show genWords
08:10:47 <metaperl> min ls == max ls
08:11:05 <allbery_b> putStrLn ("Showing " ++ show genWords")
08:11:26 <xerox> Which is why this is a feasable definition in Haskell, but it wouldn't be in a strict programming language: xs `isSubtringOf` xs = any (xs `isPrefixOf`) (tails ys).
08:11:28 <Cale> ph8: that's (putStrLn "Showing ") ++ (show genWords), which isn't what you want
08:11:30 <dcoutts__> @docs Control.Parallel.Strategies
08:11:30 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Parallel-Strategies.html
08:11:39 <paolino> ok. Great haskell
08:11:39 <allbery_b> function application is high precedence, so putStrLn eats "Showing " and then wants to concatenate with the result (which is IO (), so a type error)
08:11:48 * xerox high-fives paolino 
08:11:54 <ph8> ah cheers Cale
08:11:57 <ph8> schoolboy error :p
08:12:08 <shapr> xerox: No more edi?
08:12:16 <diegito> xerox: my problem is written like this: write a function which,given a list, builds a new list containing all the elements lowered by the value of the minimum element in the original list. The function must not visit the list's elements more then once (use the laziness) this is why i asked about that...
08:12:22 * xerox shakes head.
08:12:44 <kowey> ph8: i used to be bitten by that a lot, but learning that one precedence rule made my life tons easier
08:12:58 <Saizan> @paste
08:12:59 <lambdabot> http://paste.lisp.org/new/haskell
08:13:37 * paolino jojos the (null.tail.group)  for a while
08:13:39 <xerox> diegito: my function does exactly that. It builds up the computation that builds the result list while traversing the input list for searching the minimum.
08:14:04 <lisppaste2> Saizan pasted "simple solution for diegito" at http://paste.lisp.org/display/33624
08:14:11 <xerox> shapr: everybody knows me by this name, maybe it's better if I stick with it and nevermind.
08:15:06 <xerox> ?docs Control.Arrow
08:15:07 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Arrow.html
08:17:14 <xerox> ?type app
08:17:16 <lambdabot> forall (a :: * -> * -> *) c b. (ArrowApply a) => a (a b c, b) c
08:17:26 <xerox> > app . foldr (\x (m,k) -> (\n -> (x - n) : k n, if x < m then x else m)) (10000, const []) $ [10,100,1000]
08:17:27 <lambdabot>    Occurs check: cannot construct the infinite type: t = [t1 -> t]
08:17:27 <lambdabot>    Ex...
08:17:29 <xerox> oops
08:17:54 <xerox> > app . foldr (\x (k,m) -> (\n -> (x - n) : k n, if x < m then x else m)) (const [], 1000000) $ [10,100,1000,1,10000]
08:17:56 <lambdabot>  [9,99,999,0,9999]
08:17:58 <xerox> ta-da.
08:18:41 <norpan> haskell masturbation
08:19:18 <shapr> I'm more into haskell reproduction.
08:19:50 <norpan> replicate baby
08:20:17 <shapr> > take 5 $ repeat "whee!"
08:20:19 <lambdabot>  ["whee!","whee!","whee!","whee!","whee!"]
08:20:30 <metaperl> lol
08:20:44 <xerox> It's the library that provides so many nice function!
08:20:49 <xerox> functions, even.
08:23:36 <diegito> xerox,Saizan,Jaak: thanks for the help... now i'm studying ur examples to understand them well. sorry for bothering and thanks a lot 4 the help
08:23:51 <dylan> > take 5 $ breakL ',' $ repeat "foo,"
08:23:51 <lambdabot>  Not in scope: `breakL'
08:23:55 <dylan> > take 5 $ L.breakL ',' $ repeat "foo,"
08:23:56 <lambdabot>  Couldn't match `Char' against `[Char]'
08:24:09 <xerox> diegito: you're welcome, it's good to ask questions if you have them.
08:25:22 <diegito> :)
08:26:37 <shapr> xerox: Well, I'm glad you're back!
08:26:44 * xerox hugs shapr 
08:26:57 <shapr> xerox: I tried to change my irc nick to shaper once a few years ago, and it didn't work for me either.
08:27:00 * shapr hugs xerox 
08:29:16 <dylan> > take 5 $ L.breakL ',' $ cycle "foo,"
08:29:17 <lambdabot>  ["foo","foo","foo","foo","foo"]
08:30:55 <iulus> :t L.breakL
08:30:56 <lambdabot> Couldn't find qualified module.
08:31:15 <allbery_b> :t doesn't know about stuff defined with ?let
08:31:17 <lambdabot> Not in scope: `doesn't'
08:31:17 <lambdabot>  
08:31:17 <lambdabot> <interactive>:1:8: Not in scope: `know'
08:31:20 <allbery_b> heh
08:31:26 <iulus> ah, okay.
08:31:35 * allbery_b not fully awake yet
08:31:52 <shapr> Too bad, they should all have the same bindings.
08:31:56 <AStorm> There should be some ?dump to dump defines or lets :>
08:32:00 <AStorm> ?help dump
08:32:01 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
08:36:06 <allbery_b> there is but that's not what i's called
08:36:47 <alexj__> shapr: ping
08:37:07 <shapr> pong
08:37:58 <ski> > let subMin [] = []; subMin xs@(x0:_) = ys where (m0,ys) = loop xs; loop [] = (x0,[]); loop (x:xs) = (x `min` m,x-m0 : ys) where (m,ys) = loop xs in subMin [1,4,6,2]
08:38:00 <lambdabot>  [0,3,5,1]
08:39:31 <xerox> where... where... where?!?!?
08:39:43 <ski> just nested
08:40:42 <iulus> wha...?
08:40:44 <Templar2> I cant get sort to work (sort [3,1,2] -> [1,2,3].) Any ideas why?
08:41:05 <iulus> > let submin = map (-1) in submin [1,4,6,2]
08:41:06 <lambdabot>  add an instance declaration for (Num (a -> b))
08:41:14 <norpan> Templar2: what do you mean by that?
08:41:21 <mahogny_> you prefer another order?
08:41:39 <ski> subMin    [    ] = []
08:41:39 <ski> subMin xs@(x0:_) = ys
08:41:39 <ski>   where
08:41:39 <ski>   (m0,ys) = loop xs
08:41:39 <ski>   loop [    ] = (        x0,[       ])
08:41:41 <ski>   loop (x:xs) = (x `min` m ,x-m0 : ys)
08:41:44 <ski>     where
08:41:46 <ski>     (m,ys) = loop xs
08:41:49 <Templar2> norpan was there no standard funktion to sort lists?
08:41:56 <xerox> iulus: map (flip (-) 1)  or  map (subtract 1)
08:41:59 <mahogny_> module List?
08:42:04 <norpan> Templar2: yes, it's called sort
08:42:05 <Jaak_> @paste
08:42:06 <lambdabot> http://paste.lisp.org/new/haskell
08:42:06 <iulus> yeah, I caught it, but I didn't want to polute
08:42:08 <norpan> > sort [3,1,2]
08:42:09 <lambdabot>  [1,2,3]
08:42:45 <lisppaste2> Jaak_ pasted "My submin" at http://paste.lisp.org/display/33625
08:42:52 <Templar2> Hugs> :i sort  ->  Unknown reference `sort'
08:42:53 <iulus> :t min
08:42:55 <lambdabot> forall a. (Ord a) => a -> a -> a
08:43:04 <iulus> > min 1 3
08:43:05 <lambdabot>  1
08:43:09 <xerox> ski - I quite like building the functions explicitly.
08:43:13 <Jaak_> all the same anyways...
08:43:32 <Templar2> any ideas why Im getting Unknown reference `sort'?
08:43:39 <Jaak_> import Data.List
08:43:53 <ski> xerox : like ?
08:44:01 <xerox> > app . foldr (\x (k,m) -> (\n -> (x - n) : k n, if x < m then x else m)) (const [], 1000000) $ [10,100,1000,1,10000]
08:44:03 <lambdabot>  [9,99,999,0,9999]
08:44:16 <ski> (xerox : did you like my cyclicness ?)
08:44:18 <Jaak_> nice...
08:44:30 <xerox> ski - Indeed.
08:44:36 <Templar2> thanks
08:44:58 <Saizan> you should replace that 1000000 with something more general
08:45:06 <xerox> I indeed should.  maxBound?
08:45:23 <Saizan> > maxBound
08:45:24 <lambdabot>  Add a type signature
08:45:34 <Saizan> ?type maxBound
08:45:35 <xerox> Yeah, its type is general enough.
08:45:35 <lambdabot> forall a. (Bounded a) => a
08:45:53 <ski> > maxBound :: Int
08:45:57 <lambdabot>  2147483647
08:46:02 <iulus> > maxBound :: Integer
08:46:03 <Jaak_> > maxBound :: Integer
08:46:05 <lambdabot>  add an instance declaration for (Bounded Integer)
08:46:05 <Jaak_> bah
08:46:07 <lambdabot>   In the expression: ma...
08:46:09 <lambdabot>  add an instance declaration for (Bounded Integer)
08:46:09 <lambdabot>   In the expression: ma...
08:46:12 <ski> > maxBound :: Word
08:46:16 <lambdabot>  4294967295
08:46:33 <Saizan> Ord /= Bounded
08:47:18 <xerox> Well...
08:47:22 <ski> (xerox : UUAG could be used for this ..)
08:47:54 <AStorm> Integer is infinite length (almost)
08:48:17 <xerox> Saizan: another solution is taking the first element of the list.
08:48:28 <ski> xerox : ah, now i see your version with 'app' :)
08:48:30 <xerox> ski - What is UUAG?
08:48:32 <xerox> (:
08:49:12 <ski> (that would work in a strict language, too)
08:50:48 <ski> @where UUAG
08:50:51 <lambdabot> http://www.cs.uu.nl/wiki/HUT/AttributeGrammarSystem
08:51:06 <ski> (ah, i don't need to add it :)
08:51:55 <ph8> hmmm
08:51:57 <iulus> data InfiniteInteger = NegInf | I Integer | Inf; instance Bounded where minBound = NegInf; maxBound = Inf
08:52:05 <ph8> i'm after an easy way to get the last x elements of an array?
08:52:12 <ph8> do i have to do tails recursively until the length is right?
08:52:13 <iulus> (with a bunch of other instance declarations using Integer properties)
08:52:18 <ph8> or even last
08:52:25 <DeliQ> can somebody look at this paste for me? http://paste.lisp.org/display/33626
08:52:33 <SamB_XP> iulus: what manner of algebraic structure does that form?
08:52:53 <xerox> ski - the very last xs is the one on the RHS of x:xs in the first argument of loop, right?
08:53:00 <iulus> SamB_XP: Just the Integers, but you can use Inf or NegInf as your bounds
08:53:01 <AStorm> ?type 1/0
08:53:07 <lambdabot> forall a. (Fractional a) => a
08:53:12 <AStorm> Hmm.
08:53:14 <ph8> ?hoogle tail
08:53:15 <AStorm> ?type Infinity
08:53:18 <iulus> SamB_XP: I didn't really think about it long, so don't read too much into it
08:53:19 <ski> xerox : indeed
08:53:19 <lambdabot> Prelude.tail :: [a] -> [a]
08:53:20 <lambdabot> List.tails :: [a] -> [[a]]
08:53:20 <lambdabot> Data.PackedString.tailPS :: PackedString -> PackedString
08:53:21 <SamB_XP> so what is [NegInf..]
08:53:23 <lambdabot> Not in scope: data constructor `Infinity'
08:53:56 <xerox> ski - Nifty.
08:54:04 <allbery_b> deliq: don't see the need for a state there, what you're (incompletely) describing sounds like either a map or a fold over the left nodes to me
08:54:09 <allbery_b> be more specific
08:54:22 <iulus> SamB_XP: well, CLEARLY, it's [NegInf,NegInf-1,NegInf-2,...] :P
08:54:32 <DeliQ> hmm..
08:54:58 <Jaak_> > let takeLast n = snd . foldr f (n, []) where f x (n, xs) = if n == 0 then (0, xs) else (n - 1, x : xs) in takeLast 5 [1..10]
08:55:01 <ski> xerox : now that lisppaste doesn't proxy-error me, i see that Saizan's solutions is basically the same
08:55:01 <lambdabot>  [6,7,8,9,10]
08:55:27 <xerox> Saizan is very dry :)
08:55:36 <DeliQ> allbery_b: i thought keeping the value in a state would simplify matters...
08:55:38 <ph8> i'm after an easy way to get the last x elements of an array? do i have to make a seperate function to recurse over it until it's the right length? or is there some built in i've missed?
08:55:55 <Jaak_> oh, array
08:55:56 <allbery_b> of course I'm still not awake yet, so I could be missing something, or it could be that what yu're really doing requires state
08:56:17 * shapr isn't awake either.
08:56:17 <Jaak_> ph8: or do you mean list?
08:56:23 <ph8> sorry i mean list
08:56:25 <xerox> Err. Cough, maybe I shouldn't be the one saying that.
08:56:28 <ph8> force of habit :)
08:56:37 <DeliQ> haha, here in holland it's almost 6 PM
08:56:37 <AStorm> Jaak_, reverse . take 5 . reverse
08:56:42 <Jaak_> ew
08:56:43 <AStorm> :P
08:56:43 <ph8> ah nice
08:56:44 <ph8> cheers
08:56:46 <allbery_b> again, you need to be more specific about what you're doing
08:56:52 <Jaak_> > let takeLast n = snd . foldr f (n, []) where f x (n, xs) = if n == 0 then (0, xs) else (n - 1, x : xs) in takeLast 5 [1..10]
08:56:56 <lambdabot>  [6,7,8,9,10]
08:57:08 <AStorm> Jaak_, uh, slow.
08:57:31 <Jaak_> is reverse . f . reverse faster?
08:58:01 <AStorm> > let takeLast = (reverse .) . (. reverse) . take in takeLast 3 [1,2,3,4,5,6]
08:58:05 <lambdabot>  [4,5,6]
08:58:08 <AStorm> :>
08:58:19 <vegai> hmm. IntMap is ridiculously fast. Is my benchmark probably wrong (I'm doing things such as filtering a map of 100k entries and transforming to list)?
08:58:33 <Jaak_> i'm really too lazy to profile them...
08:58:59 <AStorm> Other than that, do iterative tail
08:59:16 <AStorm> This could be the fastest way.
08:59:26 <ph8> a is an input'ed String, if it's over the length, i need to take the last x words
08:59:26 <ph8> >	| ((length a) > (gramSize-1)) = reverse a . (take (gramSize-1))
08:59:29 <augustss> vegai: IntMap should be fast, but benchmarking lazy code can be tricky
08:59:30 <ph8> that doesn't work atm
08:59:39 <ph8> ?type take
08:59:43 <lambdabot> forall a. Int -> [a] -> [a]
08:59:46 <ph8> ah
08:59:57 <vegai> augustss: ah, indeed. I did putStrLn $ show it, though.
09:00:01 <ph8> >	| ((length a) > (gramSize-1)) = reverse a . (take (gramSize-1) a)
09:00:03 <ph8> is still a bit broken :/
09:00:06 <ph8> should i use $ ?
09:00:45 <augustss> vegai: that should do it
09:00:57 <AStorm> What is that |
09:01:07 <ph8> guard
09:01:27 <AStorm> Ah, but what does it guard?
09:02:02 <lisppaste2> ph8 pasted "padKey" at http://paste.lisp.org/display/33627
09:02:08 <ph8> AStorm ^
09:02:09 <Jaak_> hmm... how come reverse . take n . reverse is so fast :\
09:02:32 <AStorm> Jaak_, lazyness :>
09:02:38 <AStorm> It actually doesn't reverse anything.
09:02:43 <Jaak_> ooh, right
09:02:54 <ph8> can you spot what's wrong with that code?
09:02:59 <ph8> it's the right usage of $ right?
09:04:03 <AStorm> no.
09:04:10 <DeliQ> maybe someone else who could help me with this: http://paste.lisp.org/display/33626 ??
09:04:16 <AStorm> But anyway, what do you want it to do?
09:04:28 <syntaxfree> @type ($)
09:04:29 <lambdabot> forall b a. (a -> b) -> a -> b
09:04:42 <syntaxfree> @type ((+1)$)
09:04:42 <lambdabot> forall a. (Num a) => a -> a
09:05:04 <ph8> AStorm: as the comment says really
09:05:10 <ph8> keys must be of length 2 for searching
09:05:11 <syntaxfree> > foldr ((flip(:))$) [] [1,2,3,4]
09:05:12 <lambdabot>    Occurs check: cannot construct the infinite type: b = [b]
09:05:12 <lambdabot>    Expected...
09:05:14 <ph8> or length gramSize-1
09:05:29 <ph8> so if the key provided is > gramSize-1, take the last 3 elements as the key
09:05:38 <Templar2> is there any swap function in haskell?
09:05:50 <AStorm> Templar2, what do you mean?
09:05:52 <iulus> DeliQ: I don't understand what you want to do
09:05:53 <syntaxfree> Huh?
09:05:56 <AStorm> Like swapping two items in the list?
09:05:57 <syntaxfree> What's a swap function?
09:06:01 <ski> > uncurry (flip (,)) -- ?
09:06:02 <lambdabot>  Add a type signature
09:06:18 <ski> @type uncurry (flip (,)) -- ?
09:06:20 <lambdabot> forall a b. (a, b) -> (b, a)
09:06:21 <ph8> does that make sense AStorm?
09:06:43 <AStorm> I don't know what you're trying to do with teh code, I'll have to reread.
09:06:45 <Templar2> AStorm yea, like [a,b,c]    swaped: [b,a,c]
09:06:53 <DeliQ> iulus: trying to make simple tree-based theorem prover, but i simplified it for myself to this...
09:07:10 <AStorm> Just the first two or all?
09:07:15 <DeliQ> because i'm having a hard time to understand state monads
09:07:22 <Templar2> Im happy with first two
09:07:27 <AStorm> ph8, GramSize is some numeric value, right?
09:07:31 <syntaxfree> > let swap a b l = take (x-1) l : y : take (y-x) (drop x+1) l : x : drop (y+1) l in swap 1 2 [1,2,3]
09:07:32 <Templar2> but best would be a standard function offcorse
09:07:32 <lambdabot>  Not in scope: `y'
09:07:38 <syntaxfree> oh, I forgot.
09:07:47 <iulus> DeliQ: so what you have is a Binary Search Tree, right? And you want to add numbers to the right subtree successively?
09:07:59 <DeliQ> or left subtree ...
09:08:25 <syntaxfree> > let swap a b l = take (x-1) l : y : take (y-x) (drop x+1) l : x : drop (y+1) l  where { x = min a b; y = max a b} in swap 1 2 [1,2,3]
09:08:26 <lambdabot>    The function `take' is applied to three arguments,
09:08:27 <lambdabot>   but its type `Int...
09:08:32 <ph8> AStorm: ya, it just = 3 in this case
09:08:34 <iulus> so why not: foldr insertMyTree emptyMyTree listOfNumbers   ?
09:08:36 <AStorm> syntaxfree, almost :-)
09:08:50 <AStorm> ph8, what do you want to pad with?
09:08:53 <AStorm> ""?
09:08:53 <syntaxfree> > let swap a b l = take (x-1) l : y : take (y-x) ((drop x+1) l) : x : drop (y+1) l  where { x = min a b; y = max a b} in swap 1 2 [1,2,3]
09:08:57 <ph8> [""] ya
09:08:59 <lambdabot>  Couldn't match `[Int]' against `Int'
09:09:00 <ph8> well
09:09:05 <ph8> in the case here i'm not paddin
09:09:06 <ph8> * padding
09:09:09 <ph8> but taking the last three elements
09:09:22 <Templar2> that swap method looks a bit to advance =/
09:09:39 <DeliQ> some rules do not apply, so the tree must stay the same, and ony expand when a rule has been applied
09:09:51 <AStorm> Templar2, it's quite simple
09:09:54 <ski> DeliQ : what is 'value' ?
09:10:01 <DeliQ> just the a
09:10:11 <DeliQ> the value in Node
09:10:11 <xerox> > join ((app .) . foldr (\x (k,m) -> (\n -> (x - n) : k n, if x < m then x else m)) . ((,) (const [])) . head) [10000,10,1000,1,100]
09:10:11 <ski> ?
09:10:15 <lambdabot>  [9999,9,999,0,99]
09:10:23 <xerox> (No need for the default value, but it breaks on empty list.)
09:10:48 <AStorm> ph8, You're not composing right
09:10:54 <AStorm> a is meant to be that list, right?
09:11:00 <ph8> a is [[Char]]
09:11:03 <AStorm> So the second guard should be:
09:11:06 <ph8> or a list of words in a sentence
09:13:03 <lisppaste2> AstralStorm annotated #33627 with "Fixed?" at http://paste.lisp.org/display/33627#1
09:13:21 <ski> DeliQ : which values do you want to add to a left branch ?
09:13:28 <AStorm> ++ is for [Char]
09:13:32 <AStorm> : is for generic lists
09:13:39 <ph8> ah
09:13:46 <DeliQ> the current value in a Node but than +1
09:13:48 <ph8> but it's producing the desired results as is
09:13:49 <ski> :t (++)
09:13:53 <lambdabot> forall a. [a] -> [a] -> [a]
09:13:53 <ski> :t (:)
09:13:54 <DeliQ> simple as that..
09:13:54 <ph8> for the length < gramSize-1
09:13:59 <ph8> it's the > gramSize-1 that's the problem
09:14:00 <lambdabot> forall a. a -> [a] -> [a]
09:14:03 <AStorm> Anyway :P
09:14:06 <DeliQ> it's just a concept for me, so i can understand it better...
09:14:07 <ski> '(++)' works on any lists
09:14:13 <AStorm> So, fix my fix :P
09:14:19 <AStorm> Blah me again.
09:14:44 <ski> DeliQ : so you want to increment the nodes on a left path ?
09:14:50 <DeliQ> yup
09:14:56 <DeliQ> idd
09:15:01 <ph8> AStorm: eh?
09:15:06 <ski> why would you need the state ?
09:15:09 <ph8> i don't get what i'm doing wrong with that take
09:15:29 <ph8> ah sorted it
09:15:34 <ph8> just made the take argument (reverse a)
09:16:02 <DeliQ> it's just in my theorem prover, i scan all formulas in a Node, and when a reduction rule applied, i expand the Tree
09:16:05 <AStorm> Indeed.
09:16:18 <AStorm> But you could also compose the functions, as I did. :>
09:16:21 <DeliQ> but in haskell you don't have global variables
09:16:39 <ski> DeliQ : wouldn't you just recurse into the left path, and increment each node you find .. i don't see why you'd need state for that
09:17:04 <DeliQ> i could do that i guess... maybe i just overestimated the problem :P
09:17:21 <DeliQ> but that leaves me with another thingy...
09:17:42 <DeliQ> only when a rule applies to a Node is must expand.. how should i code this ?
09:18:12 <ph8> AStorm: compose the waa?
09:18:25 <ph8> reverse a . take 5 ?
09:18:35 <ph8> because the . is magic?
09:18:37 <ski> DeliQ : have a guard or 'if' that checks if a rule applies ?
09:18:39 <ph8> it makes it much harder to read imo
09:18:54 <AStorm> ph8, . is the composition
09:19:07 <ski> reverse . take (gramSize-1) $ a
09:19:09 <AStorm> That nice circle between function names in math
09:19:10 <ski> (reverse . take (gramSize-1)) $ a
09:19:15 <ski> (reverse . take (gramSize-1)) a
09:19:21 <ski> reverse $ take (gramSize-1) $ a
09:19:30 <ski> reverse (take (gramSize-1) a)
09:19:33 <ski> those are all the same
09:19:36 <DeliQ> ski: guess so idd...
09:19:36 <AStorm> Yep.
09:19:57 <AStorm> Basic dollar form is probably the best:
09:20:24 <AStorm> ski, uh... it has to be reversed first
09:20:33 <DeliQ> maybe i can just make a function for each rule that have a return type with Eiher, where only Right means a change ?
09:20:46 <AStorm> So maybe take (gramSize-1) . reverse $ a
09:21:18 <AStorm> Or: take (gramSize-1) $ reverse a
09:21:27 <ski> (AStorm : sorry, havent't checked what the problem was)
09:22:12 <syntaxfree> if I have a where block with many definitions..
09:22:21 <AStorm> One thing I always missed in Lisp: $ operator :>
09:22:23 <syntaxfree> are they all aware of one each other, like in the main block?
09:22:30 <syntaxfree> or do I need to nest wheres inside of wheres?
09:22:31 <xerox> syntaxfree: yep.
09:23:34 <augustss> syntaxfree: they are mutually recursive, no need to nest
09:24:38 <syntaxfree> how do I find out if an operator is left or right-associative?
09:24:53 <ski> in hugs ':i ++'
09:25:02 <AStorm> :i ++
09:25:15 <AStorm> Hmm, lambdabot can't do that? :P
09:25:18 <AStorm> ?info (++)
09:25:19 <lambdabot> (++)
09:25:32 <AStorm> In ghci it's also there.
09:25:36 <ski> ok
09:25:44 <allbery_b> someone should write a plugin :>
09:25:49 <syntaxfree> oh, good.
09:25:50 <syntaxfree> :)
09:26:12 * allbery_b should probably download the source and play around with it, but on 6.6 it's problematic due to ho hs-plugins...
09:26:20 <allbery_b> ^ho^no
09:26:37 <syntaxfree> Haskell does need a better REPL than ghci or hugs.
09:27:05 <syntaxfree> Not being able to check on the inferred type of some function because the whole thing doesn't compile is somewhat annoying, but bypasseable by massive commenting out of code.
09:27:16 <syntaxfree> But on large where blocks, it kills ya.
09:27:23 <xerox> AStorm: we used to have it, but somebody complained because it was too verbose, and it got removed. Same thing happened to @moo.
09:27:49 <allbery_b> put it back in but limit use to /msg?
09:27:57 <Saizan> @moo?
09:28:02 <xerox> allbery_b: you just darcs get lambdabot and cp lambdabot.cabal.ghc6.6 lambdabot.cabal, then build.
09:28:11 <allbery_b> cowsay, is my guess
09:28:24 <xerox> Some collection of cows.
09:28:43 <xerox> E.g. http://tunes.org/~nef/logs/haskell/04.06.06
09:28:59 <allbery_b> @go cowsay
09:29:01 <lambdabot> http://www.nog.net/~tony/warez/cowsay.shtml
09:29:01 <lambdabot> Title: cowsay and cowthink
09:29:42 <AStorm> xerox, too verbose? It's just 2-6 lines :P
09:30:06 <xerox> There were many different ones.  Maybe they still are in lambdabot sources.
09:30:21 <ph8> is there a repeat?
09:30:28 <ph8> like repeat 5 "a"
09:30:30 <ph8> to get aaaaa?
09:30:33 <allbery_b> that's replicate
09:30:38 <ph8> cheers!
09:30:39 <xerox> Here boegel is complaining because we banned @moo http://tunes.org/~nef/logs/haskell/06.09.01
09:30:47 <allbery_b> repeat is similar but produces an infinite list
09:31:05 <allbery_b> and it'd be:
09:31:09 <allbery_b> > replicate 5 'a'
09:31:10 <lambdabot>  "aaaaa"
09:31:15 <AStorm> > repeat 5 'a'
09:31:17 <lambdabot>    The function `repeat' is applied to two arguments,
09:31:17 <lambdabot>   but its type `a -...
09:31:23 <AStorm> > repeat 5 ['a'[
09:31:24 <lambdabot>  Parse error
09:31:25 <AStorm> > repeat 5 ['a']
09:31:26 <lambdabot>    The function `repeat' is applied to two arguments,
09:31:26 <lambdabot>   but its type `a -...
09:31:31 <augustss> > take 5 $ repeat 'a'
09:31:32 <araujo> hi hi
09:31:33 <lambdabot>  "aaaaa"
09:31:36 <xerox> @code
09:31:37 <lambdabot> Maybe you meant: more todo vote
09:31:42 <ski> @ghc
09:31:42 <AStorm> > repeat 'a'
09:31:43 <lambdabot>  Can't represent a guarded lambda in Template Haskell
09:31:44 <lambdabot>  "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
09:32:20 <AStorm> :i is totally awesome
09:32:25 <AStorm> add it back please :>
09:32:33 <AStorm> (the ghci version)
09:32:43 <lisppaste2> syntaxfree pasted "swap function, finally. sometimes I trip over these indexes so badly, it's pathetic" at http://paste.lisp.org/display/33629
09:32:43 <xerox> It's easy to add, go for it :)
09:32:54 <allbery_b> lambdabot uses ghci for that kind of thing anyway
09:33:32 * allbery_b doesn't see what's so ard about keeping a ghci wndow around, anyway
09:33:43 <allbery_b> ...pretend I cn type :>
09:33:52 <syntaxfree> My self-compiled ghci is not readline-aware, now.
09:34:02 <syntaxfree> I make one mistake, type backspace and this is what I  get:
09:34:16 <syntaxfree> *Main> :t min^?^?ax
09:34:16 <syntaxfree> <interactive>:1:3: lexical error at character '\DEL'
09:34:25 <syntaxfree> up and down arrows, etc. are also broken.
09:34:28 * allbery_b is still waiting for big portupgrade to finish so he can poke at it
09:34:40 <sorear> hmm - you try using ^H instead?
09:34:46 <AStorm> syntaxfree, readline hates you?
09:34:49 <monochrom> ^^
09:34:49 <allbery_b> (it's an old Athlon 600, it's liable to be a while :)
09:34:50 <syntaxfree> nothing.
09:34:58 <syntaxfree> Astorm: curiously enough, rlwrap does nothing either.
09:35:09 <syntaxfree> I had readline problems with python, but rlwrap fixes it.
09:35:17 <sorear> and stty erase is already ^? ?
09:35:35 <allbery_b> that almost sounds like it's going into raw mode
09:35:48 <allbery_b> but thinks it's in standard mode
09:35:48 <monochrom> getLine is funny
09:36:17 <syntaxfree> it's not getLine, it's my ghci.
09:36:26 <syntaxfree> programs I compile are ok.
09:38:09 <syntaxfree> Templar2: anyway, there's the swap function.
09:38:24 <norpan> he's not here
09:38:52 <syntaxfree> took me ages :)
09:38:58 <syntaxfree> first, I just dropped it as uninteresting.
09:39:14 <syntaxfree> But I was annoyed in the background that I couldn't do it.
09:39:15 <yaxu> i'm trying to output sound and update a hopengl window at the same time, but the graphic output updates in 'spurts' every second
09:39:27 <syntaxfree> I also got mixed up big time with starting-from-zero indexes.
09:39:30 <sorear> use flush
09:39:38 <sorear> yaxu: flush is needed
09:39:39 <syntaxfree> you need to flush.
09:39:48 <norpan> flush it, baby
09:39:49 <yaxu> sorear: i'm making sure i flush
09:39:59 <syntaxfree> all you need is flush, tada da da da, all you need is flush, ta da da da da
09:40:05 <syntaxfree> all you need is flush ... flush is all you need
09:40:44 <monochrom> oh, opengl flush, yeah!
09:40:45 <yaxu> i'm flushing in the idle and display callbacks, and also hFlushing every write to the output buffer
09:41:12 <sorear> oh glut
09:41:16 <yaxu> oh come on now you're not taking this problem of mine seriously
09:41:37 <yaxu> one mention of the word flush and the channel descends into chaos
09:41:53 <sorear> how did you get close enough to the OpenGL output buffer to hFlush it?
09:42:02 <psnl> you ought to try "guys"
09:42:15 <sorear> IIRC even the C-level api doesn't let you get at the output fd.
09:42:19 <yaxu> sorear: i'm hFlush-ing the audio output (writing straight to /dev/dsp)
09:42:20 <allbery_b> the flip side of free support is the occasional stream-of-consciousness :)
09:42:36 <allbery_b> @hoogle flush
09:42:37 <lambdabot> GHC.ConsoleHandler.flushConsole :: Handle -> IO ()
09:42:37 <lambdabot> System.Win32.File.flushFileBuffers :: HANDLE -> IO ()
09:42:37 <lambdabot> IO.hFlush :: Handle -> IO ()
09:42:49 <yaxu> at least no-one picked up on the word spurt
09:42:50 <allbery_b> hm, not quite
09:43:12 <AStorm> yaxu, are you using threads?
09:43:29 <yaxu> AStorm: yes
09:43:33 <AStorm> Separate sound, gfx, event thread?
09:43:37 <Azmo> woohoo, i wrote a Stone-Scissor-Paper game and implemented a computer player that chose actions randomly, however, i consistently won against it by seeing a pattern in the random data!. i thought i had created a good computer player there.. :/
09:43:44 <yaxu> AStorm: no only two threads
09:43:56 <AStorm> sound and gfx are in the same? Bad idea :P
09:44:09 <sorear> what is your thread-pattern, are you using -threaded?
09:44:21 <yaxu> no they're not, but communicating via an mvar
09:44:35 <AStorm> Check if there's contention on it.
09:44:38 <yaxu> sorear: is that a ghc option?
09:44:40 <sorear> so gfx+event, sound?
09:44:45 <sorear> yaxu: yes.
09:45:17 <AStorm> Threaded app w/o -threaded is not threaded :P
09:45:25 <AStorm> It's just simulated.
09:45:33 <sorear> yaxu: you need to delete at least one object to force re-linking after changing -threaded
09:46:23 <yaxu> still the same with -threaded, i think my thread 'design' is the problem though
09:47:01 <yaxu> i have one thread reading from a file and writing to an mvar and to /dev/dsp, and another thread reading from that mvar and sending to the hopengl screen
09:47:19 <yaxu> i deleted all the .hi files sorear
09:48:59 <yaxu> i've turned off all the buffering on the filehandles but i think the kernel is still taking my audio data in big chunks
09:49:46 <xerox> Azmo: paste the code :)
09:50:10 <yaxu> ?paste
09:50:11 <lambdabot> http://paste.lisp.org/new/haskell
09:50:55 <Azmo> xerox: just a minute or 2, trying to create another computer player.
09:51:00 <lisppaste2> yaxu pasted "hpeano_live.hs" at http://paste.lisp.org/display/33632
09:51:03 <xerox> 'lo yaxu.
09:51:21 <yaxu> hey xerox
09:52:34 <xerox> Oooh.  You are using GL for the UI.
09:52:35 <SamB> hmm. too bad the compiler can't diagnose spelling errors in what was supposed to be the last case of a function definition...
09:52:39 <AStorm> Why so many flushes?
09:52:47 <AStorm> (in present)
09:52:57 <SamB> maybe he is really lucky?
09:53:08 <Stinger_> does anyone have some examples for using fix, I've forgotten how it works
09:53:16 <xerox> Stinger_: yup
09:53:40 <AStorm> ?type fix
09:53:42 <lambdabot> forall a. (a -> a) -> a
09:53:42 <xerox> http://darcs.haskell.org/~paolo/tao/ZipNtree.hs
09:53:46 <yaxu> AStorm: pure frustration :)  i just deleted them all but one
09:53:52 <xerox> See "top".
09:54:25 <Stinger_> do I have to darcs that?
09:54:31 <yaxu> if i don't write to output the animation works fine, so i think it's definitely output buffering that's ruining my day.  i need to somehow slow everything down to the output samplerate
09:54:31 <xerox> Stinger_: nope, just that file.
09:54:35 <Stinger_> cause its 404 :(
09:54:45 <xerox> Stinger_: argh, add darcs/ after ~paolo/ sorry.
09:54:46 <AStorm> yaarg, what about checking your eofLoopingHandler?
09:54:55 <AStorm> It is a nice hog ;.
09:54:59 <monochrom> fix (\f x -> case x of {0 -> 0; _ -> f (x-1)})
09:55:02 <Stinger_> ok works now :)
09:55:37 <yaxu> AStorm: well it's not getting to the eof yet, the file is pretty big
09:55:38 <xerox> > fix (\f x -> case x of {0 -> 0; 1 -> 0; n -> f (x-1) + f (x-2)}) 10
09:55:40 <lambdabot>  0
09:55:49 <xerox> Sigh.
09:56:11 <AStorm> yaxu, but it's reading char by char
09:56:17 <AStorm> That is bound to be slow
09:56:24 <AStorm> then the other thread sleeps on that MVar
09:56:32 <monochrom> Haha
09:57:00 <xerox> > fix (\f x -> case x of {0 -> 0; 1 -> 1; n -> f (x-1) + f (x-2)}) 10
09:57:01 <lambdabot>  55
09:57:08 <monochrom> Are we competing on the slowest way to implement f_|_=_|_, f x = 0 ?  :D
09:57:18 * xerox laughs
09:57:33 <Stinger_> hmmm so is fix useful for anything else other than avoiding binding a name to a function for recursive purposes?
09:57:42 <AStorm> yaxu, readfile.hs could help with that
09:58:23 <xerox> yaxu: the program you pasted loads a file, prints it peano-encoded and plays it?
09:58:27 * allbery_b saw something recently about using a relative of fix for fancy circular reference stuff
09:58:52 <yaxu> xerox: yep, needs LSystem.hs which i can post too
09:59:06 <SamB> wouldn't it play better if it was piano-encoded?
09:59:09 <xerox> yaxu: yeah, I remember it :)
09:59:22 <monochrom> Most times I use fix for anonymous recursion.
09:59:38 <allbery_b> @go tying knots generically
09:59:39 <monochrom> And of course it doesn't happen often.
09:59:40 <lambdabot> http://sigfpe.blogspot.com/2006/12/tying-knots-generically.html
09:59:40 <lambdabot> Title: A Neighborhood of Infinity: Tying Knots Generically
09:59:55 <yaxu> AStorm: sure but i think the problem is that reading and processing is too fast so it's bound by the output, which is buffered in chunks
10:00:09 <xerox> I wonder why loeb is more general than fix.
10:00:19 <DeliQ> I have a datatype for propositions named Prop and made it an instance of Show, which worked perfectly, but i cannot make an instance of Show with [Prop], which is what i would like right now
10:00:36 <DeliQ> is this solveable ? :P
10:01:07 <AStorm> It is. Just add all Show methods.
10:01:13 <ski> (allbery_b : i think i got sigfpe's last example there to work ..)
10:01:19 <AStorm> You don't have to use derives.
10:01:42 <DeliQ> ghci complains when i do instance Show [Prop] where ....
10:01:48 <xerox> ski - ...to work?
10:01:54 <DeliQ> Illegal instance declaration for `Show [Prop]'
10:02:08 <lisppaste2> Azmo pasted "SSP game in haskell" at http://paste.lisp.org/display/33635
10:02:17 <DeliQ> (The instance type must be of form (T a b c) where T is not a synonym, and a,b,c are distinct type variables)
10:02:22 <allbery_b> hrm.  I thought [a] was already Show as long as a was an instance of Show
10:02:23 <SamB> yaxu: maybe, uh, jack would be interesting?
10:02:48 <DeliQ> allbery_b: idd, but i sort of want to redefine it...
10:03:01 <Azmo> xerox: http://paste.lisp.org/display/33635
10:03:02 <sorear> redefine the Show method showList
10:03:06 <yaxu> SamB: yes, there aren't bindings yet though?
10:03:13 <ski> Loeb> u2
10:03:14 <ski> Just [1,2] :: Maybe [Integer]
10:03:19 <ski> xerox
10:03:29 <sorear> instance Show Prop where .... showList = mySpecialCaseCode
10:03:34 <DeliQ> hmm, gonna try... ;)
10:03:36 <DeliQ> ty!
10:03:49 <sorear> this is the trick used to make [Char] print in quotes
10:03:56 <Azmo> i was wrong though, just a coincience that i was able to beat the random player.
10:04:11 <sorear> it's an ugly hack, and you've already reached it's limit - beware.
10:04:19 <SamB> yaxu: surely jack bindings are easier than figuring out how to beat the kernel into submission?
10:04:31 <yaxu> heh
10:04:42 * sorear invokes the Kernel Source Code
10:04:49 <SamB> ... and keeping up with the kernel afterwards...
10:07:17 <yaxu> it would be great to have
10:07:30 <DeliQ> showList [] = showString ""
10:07:30 <DeliQ> showList (p:ps) = show p ++ "," ++ show ps
10:07:36 <DeliQ> doesn't work
10:08:13 <AStorm> show ps? :P
10:08:17 <AStorm> showList ps
10:08:50 <DeliQ> Couldn't match expected type `[Char]' against inferred type `ShowS' In the second argument of `(++)', namely `showList ps'
10:09:00 <DeliQ> this is with showList ps
10:09:28 <AStorm> WTF?
10:09:50 <AStorm> Ah, I know.
10:10:04 <AStorm> (show p) ++ "," ++ (show ps)
10:10:20 <AStorm> Otherwise you're doing something stupid probably :>
10:10:51 <allbery_b> that shouldn't make a difference, show should be high precedence compared to ++
10:10:58 <DeliQ> nope
10:11:05 <DeliQ> doesn't make a difference
10:11:14 <AStorm> The second one should.
10:11:51 <DeliQ> nope...
10:12:19 <sorear> showList (p:ps) = shows p . showsChar "." . shows ps
10:12:34 <DeliQ> showList (p:ps) = shows p . showString "," . showList ps
10:12:36 <DeliQ> idd :P
10:12:40 <DeliQ> ty! ;)
10:12:57 <sorear> yw.
10:14:04 <AStorm> > let showList [] = ""; showList (p:ps) = show p ++ "," ++ (showList ps) in showList [1,2,3
10:14:04 <lambdabot>  Parse error
10:14:13 <AStorm> > let showList [] = ""; showList (p:ps) = show p ++ "," ++ (showList ps) in showList [1,2,3]
10:14:15 <lambdabot>  "1,2,3,"
10:14:20 <AStorm> Almost :P
10:14:33 <DeliQ> yes i had to add this case []
10:14:37 <DeliQ> uhh [p] i mean
10:14:40 <DeliQ> only 1 element
10:14:41 <sorear> separators are evil!
10:14:58 <sorear> terminators much better.
10:15:55 <DeliQ> :P
10:16:09 <AStorm> > let showList [] = ""; showList (p:ps) = show p ++ "," ++ (showList ps); showList p = show p in showList [1,2,3]
10:16:10 <lambdabot>    Warning: Pattern match(es) are overlapped
10:16:10 <lambdabot>        In the definition...
10:16:12 <AStorm> :>
10:16:32 <AStorm> Actually, it'd have to check on length :/
10:16:33 <sorear> worse, that last case is infinite recursion
10:16:55 <sorear> > let showList [] = ""; showList [p] = show p ; showList (p:ps) = show p ++ "," ++ (showList ps) in showList [1,2,3]
10:16:55 <AStorm> A guard maybe?
10:16:56 <lambdabot>  "1,2,3"
10:17:07 <sorear> order is all you need to change
10:17:43 <sorear> also I changed p (match-anything) to [p] (match-singleton-lists)
10:17:49 <AStorm> :>
10:17:55 <AStorm> Nice.
10:18:02 <AStorm> Forgot you can do that.
10:18:02 <sorear> ?type showList
10:18:04 <lambdabot> forall a. (Show a) => [a] -> ShowS
10:18:24 <AStorm> ?type ShowS
10:18:26 <lambdabot> Not in scope: data constructor `ShowS'
10:18:35 <sorear> > let showList [] = id; showList [p] = shows p ; showList (p:ps) = shows p . showsChar "," . showList ps in showList [1,2,3] ";"
10:18:35 <lambdabot>  Not in scope: `showsChar'
10:18:46 <sorear> > let showList [] = id; showList [p] = shows p ; showList (p:ps) = shows p . (',':) . showList ps in showList [1,2,3] ";"
10:18:47 <lambdabot>  "1,2,3;"
10:18:52 <sorear> > let showList [] = id; showList [p] = shows p ; showList (p:ps) = shows p . (',':) . showList ps in showList [1,2,3] ""
10:18:53 <lambdabot>  "1,2,3"
10:19:08 <AStorm> Why that id?
10:19:13 <sorear> ^^^ there's the ShowS implementation you need for the showList method
10:19:24 <sorear> ShowS == String -> String
10:19:32 <ski> 'id' is like 'nop' .. shows nothing
10:19:57 <ski> (',':)
10:20:00 <ski> could be written as
10:20:04 <ski> showChar ','
10:20:35 <sorear> yea, well, (',':) is easier to remember :)
10:22:26 <AStorm> and looks like a smiley
10:22:55 <sorear> to me it looks more like an electrical socket ...
10:23:05 <AStorm> That too.
10:24:03 <AStorm> ?let socket = ('.')
10:24:04 <lambdabot> Defined.
10:25:13 <sorear> NB: this is a US electical socket
10:25:46 <bd_> :t ('.')
10:25:48 <lambdabot> Char
10:25:52 <bd_> oh, doh
10:25:54 <sorear> ..red?
10:26:04 <sorear> sorry
10:32:00 * shapr boings furiously
10:32:48 <shapr> @users
10:32:49 <lambdabot> Maximum users seen in #haskell: 309, currently: 280 (90.6%), active: 43 (15.4%)
10:33:27 <sorear> pong!
10:33:32 <shapr> mmm code!
10:33:51 <shapr> sorear: Are you in San Diego?
10:34:16 <sorear> Treu
10:34:20 <sorear> True
10:34:33 <shapr> In that case, I probably won't be visiting you soon. Too bad!
10:35:02 * shapr grumbles at HList
10:36:08 <shapr> Is anyone here able to build HList with ghc 6.6?
10:39:57 <lisppaste2> ph8 pasted "Stripping punctation from a "(words string)"" at http://paste.lisp.org/display/33637
10:40:09 <ph8> does anyone have any insight into that by any chance?
10:40:13 <ph8> my first foldl endaevour ;)
10:40:19 <ph8> i get type errors
10:41:21 <kowey> ph8: the function given to a fold should take two arguments ; yours takes one
10:41:24 * shapr throws ice at Igloo 
10:41:26 <psnl> ph8: looks like you want map
10:41:43 <ph8> aha!
10:41:45 <ph8> genious :)
10:41:46 <kowey> ah, that sounds like a better response :-)
10:41:49 <psnl> [String]->[String] suggests map
10:42:03 <ph8> map [[char]] <function>?
10:42:18 <allbery_b> map function list
10:42:30 <psnl> @hoogle map
10:42:31 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
10:42:31 <lambdabot> Data.IntMap.map :: (a -> b) -> IntMap a -> IntMap b
10:42:31 <lambdabot> Data.IntSet.map :: (Int -> Int) -> IntSet -> IntSet
10:42:42 <psnl> top one
10:42:55 <ph8> haha works :)
10:43:44 <kowey> out of curiosity, why [Char] and not String?
10:44:16 <syntaxfree> they're synonyms.
10:44:18 <AStorm> The same.
10:44:37 <syntaxfree> > foldr ((:) . (+1))  [] [1,2,3]
10:44:39 <lambdabot>  [2,3,4]
10:44:50 <syntaxfree> @type foldr ((:) . (+1)) []
10:44:51 <lambdabot> forall a. (Num a) => [a] -> [a]
10:44:56 <syntaxfree> so there!
10:45:00 * syntaxfree shows his tongue.
10:45:16 <kowey> right... so why say [Char] when you can say String?
10:45:16 <sorear> > fix . (:) $ 42
10:45:17 <lambdabot>  [42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,...
10:45:35 <syntaxfree> I don't understand type fix points to the day.
10:45:41 <sorear> [Char] uses MORE PUNCTUATION!!!!
10:45:44 <syntaxfree> kowey: you can say String if you want.
10:46:16 <kowey> syntaxfree: thanks; i'm aware of that :-D.  this was supposed to be a probing question for ph8
10:46:35 <kowey> which was supposed to lead to "oh maybe I really meant String and not [Char]"
10:49:07 * shapr hugs _frederik_ 
10:52:54 * syntaxfree dances and spins in the embrace of the trade winds
10:55:25 <SamB> syntaxfree: a fixpoint of a function is a value that, if you pass it to the function, the function will return
10:55:36 <syntaxfree> That I know.
10:55:42 * syntaxfree *is* an economist, remember.
10:55:44 <sorear> > fix . (++) $ "Fix! "
10:55:45 <SamB> what more is there to know?
10:55:45 <lambdabot>  "Fix! Fix! Fix! Fix! Fix! Fix! Fix! Fix! Fix! Fix! Fix! Fix! Fix! Fix! Fix! ...
10:55:55 <dylan> :t fix
10:55:57 <lambdabot> forall a. (a -> a) -> a
10:56:04 <sorear> > fix . const $ "Fix! "
10:56:05 <lambdabot>  "Fix! "
10:56:06 <syntaxfree> Kakutani's fixed point theorem is a basic tool of the trade.
10:56:14 <Stinger_> I dont get how that works :(
10:56:20 <SamB> syntaxfree: so what don't you understand?
10:56:20 <syntaxfree> well, how does Haskell determine the fixpoint of a type?
10:56:25 <SamB> of a type?
10:56:26 <syntaxfree> > fix (*2)
10:56:28 <lambdabot>  Exception: <<loop>>
10:56:37 <syntaxfree> and yet (*2) 0 = 0
10:56:39 <sorear> Stinger_: It's fun, what more do you need to know? :)
10:56:49 <sorear> *least* fixed point operator
10:56:55 <sorear> (*2) _|_ = _|_
10:56:56 <SamB> it gives you the least fixed point, where the partial ordering is called "definedness"
10:56:57 <sorear> _|_ < 0
10:57:00 <SamB> or something like that
10:57:10 <syntaxfree> well, that's what I don't know!
10:57:38 <ski> Loeb!
10:57:39 <syntaxfree> So Haskell is basically aware of all fixed points of an arbitrary function so it selects the minimum?
10:57:43 <SamB> anyway, if you take something and replace one of its limbs with a _|_, that makes it less defined
10:57:52 <SamB> syntaxfree: no.
10:57:58 <syntaxfree> the minimum on the definedness scale.
10:58:06 <sorear> no, it selects things magically such that the minimun is always chosen.
10:58:06 <SamB> it just passes the functions return value to the function
10:58:32 <ski> fix f = a
10:58:35 <ski>   where
10:58:37 <sorear> and theres some crazy proof that this will always give the minimum fixpoint
10:58:37 <ski>   a = f a
10:58:52 <SamB> if the function needs to look at that value before it has returned it, that gives you _|_
10:58:53 <Saizan> fix (*2) = (*2) (fix (*2)) = ... = _|_
10:58:57 <Stinger_> could someone put in parens to show the precedence/fixity in fix . (:) $ 42
10:58:59 <syntaxfree> ski: that doesn't tell me how it's computed, just what it is.
10:59:04 <SamB> if it doesn't, you get something else
10:59:08 <sorear> > fix (42:)
10:59:09 <lambdabot>  [42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,...
10:59:12 <syntaxfree> oh. fix is just a stupid infinite recursive function.
10:59:18 <ski> syntaxfree : it may do the former, too
10:59:25 <norpan> fix f = f (fix f)
10:59:26 <sorear>  = 42 : fix (42:) = 42 : 42 : fix (42:)
10:59:29 <norpan> or something
10:59:40 <SamB> norpan: that is exactly it
10:59:46 <norpan> yeah
10:59:52 <SamB> although some people don't trust the compiler so much and write
11:00:05 <kpreid> Stinger: (fix . (:)) $ 42
11:00:05 <SamB> fix f = x where x = f x
11:00:06 <syntaxfree> > fix (max 10)
11:00:07 <lambdabot>  Exception: <<loop>>
11:00:35 <Stinger_> oh right, duh
11:00:36 <syntaxfree> nah, not yet.
11:00:44 <norpan> don't trust the compiler?
11:00:54 <sorear> to do full memoization
11:00:55 <syntaxfree> > fix (\x->max (x+1) 10)
11:00:56 <lambdabot>  Exception: <<loop>>
11:01:09 <syntaxfree> >iterate (\x->max (x+1) 10)
11:01:18 <syntaxfree> > iterate (\x->max (x+1) 10) 1
11:01:19 <lambdabot>  [1,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,3...
11:01:24 <SamB> norpan: well. is it really CSE if one of the occurences was in a pattern rather than in an expression?
11:01:33 <syntaxfree> > iterate (\x->min (x+1) 10) 1
11:01:35 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,...
11:01:39 <monochrom> Eh? Playing with fix?  It is pretty trivial.
11:01:53 <syntaxfree> > fix (\x->min (x+1) 10)
11:01:55 <lambdabot>  Exception: <<loop>>
11:02:01 * sorear points at syntaxfree
11:02:05 <norpan> SamB: eh, what is the common expression?
11:02:18 <SamB> monochrom: syntaxfree thought fix was complicated magic
11:02:24 <SamB> norpan: fix f
11:02:40 <SamB> I think.
11:02:41 <syntaxfree> I didn't *think* anything. I knew there had to be a catch.
11:02:53 <SamB> syntaxfree: well, you seemed to ;-)
11:03:02 <syntaxfree> It does something simpler than what I thought, though. It's just a stupid infinite recursive function.
11:03:10 <SamB> yeah, exactly
11:03:11 <monochrom> Yes.
11:03:12 <syntaxfree> SamB: yes, because I wanted the catch to be revealed.
11:03:23 <syntaxfree> Hell, determining fixed points of simple algebraic functions is complex enough.
11:03:26 <SamB> which conveniently gives you the least fixed point
11:03:45 <sorear> > (fix . (>>) $ return 5) :: [Int]
11:03:47 <lambdabot>  Exception: <<loop>>
11:03:48 <monochrom> "fixed point in economics" = "fixed point in real analysis" /= "fixed point in partial orders".
11:04:01 <SamB> monochrom: um.
11:04:03 <SamB> what?
11:04:20 <monochrom> The /= there is not perfect /=.  There are similarities and differences.
11:04:25 <kpreid> @pl fix2 f = (curry f) (fix2 f)
11:04:26 <lambdabot> fix2 = fix (ap curry)
11:04:31 <sorear> > (fix . (>>) $ return 5) :: Control.Monad.Identity.Identity Int
11:04:32 <lambdabot>  add an instance declaration for (Show (Identity Int))
11:04:51 <sorear> > (Control.Monad.Identity.runIdentity $ fix . (>>) $ return 5) :: Int
11:04:52 <lambdabot>  Exception: <<loop>>
11:05:11 <sorear> > (Control.Monad.Identity.runIdentity $ fix . (>>=) $ \x -> return (2:x)) :: [Int]
11:05:13 <lambdabot>    Occurs check: cannot construct the infinite type: b = a -> b
11:05:13 <lambdabot>    Expec...
11:05:27 <Codex_> I've always wanted to know whether you can use fix to calculate center of rotation of a rotation matrix. :)
11:05:35 <sorear> > (Control.Monad.Identity.runIdentity $ fix . (=<<) $ \x -> return (2:x)) :: [Int]
11:05:36 <lambdabot>  [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2...
11:06:00 <monochrom> Thus, you run into the /= in Codex_'s application.
11:06:02 <syntaxfree> Codex_: precisely. It doesn't calculate fixpoints in the sense of Brouwer's FPT, for example.
11:06:04 <sorear> > (fix . (=<<) $ \x -> return (2:x)) :: [[Int]]
11:06:05 <lambdabot>  Exception: <<loop>>
11:06:45 <monochrom> I think I can explain it.
11:07:48 <syntaxfree> The thing is, types aren't the same as sets.
11:07:59 <monochrom> First, applicable to both kinds of fixed points: on a computer and for interesting cases you will never get the exact fixed point.  You settle for an approximation attainable in a short time.
11:07:59 <araujo> Anybody knows if there exist some tarball package for the Haskell standard libs?
11:08:07 <araujo> I want to surf them off-line
11:08:21 <Stinger_> the docs?
11:08:23 <syntaxfree> Apparently, for any Haskell type, there's an undefined value.
11:08:28 <sorear> yes
11:08:37 <sorear> all haskell types are 'lifted'
11:08:44 <araujo> Stinger_, yes
11:08:50 <ski> @kind Int#
11:08:52 <lambdabot> Not in scope: type constructor or class `Int#'
11:09:12 <allbery_b> @hoogle Int#
11:09:16 <lambdabot> Hoogle Error: Parse Error: Unexpected character '>'
11:09:17 <monochrom> If you are in a metric space, you can use the metric to ask "am I close enough?", and stop when you are close enough.  This is how you approximate an economics or real-analysis fixed point.
11:09:22 <sorear> that's not a *Haskell* type :) GHC/Hugs/etc...
11:09:22 <allbery_b> *blink*
11:09:29 <sorear> ski:
11:09:34 <araujo> http://haskell.org/ghc/docs/latest/html/libraries/ , i want that for off-line
11:09:35 <sorear> @kind GHC.Prim.Int#
11:09:53 <ski> danke
11:09:57 <lambdabot> #
11:10:00 <Stinger_> http://haskell.org/haskellwiki/GHC
11:10:06 <ski> sorear :)
11:10:09 <monochrom> But such a metric is not available in a partial order, such as the values of a Haskell data type.
11:10:17 <syntaxfree> a topological fixpoint, really.
11:10:25 <lambdabot> Title: GHC - HaskellWiki
11:10:40 <syntaxfree> Most modern economics is done on differentiable manifolds, but I really haven't studied that yet.
11:10:49 <Stinger_> araujo has a link at that page ^
11:11:38 <Stinger_> actually I think I tried to find that the other day
11:11:45 <Stinger_> but ended up wgeting them all :P
11:12:31 <Saizan> you can just download the ghc source and build the doc with haddock
11:13:07 <monochrom> For a Haskell data type such as [Int], there are two points.  (a) it is undecidable whether it is a fixed point or not.  (b) how do you know you get "close"? there is no metric, however there is a theorem saying if you iterate longer you will get closer.
11:13:10 * shapr nails one of his own feet to the floor in order to research topological fixpoints...
11:13:45 <araujo> thanks a lot Stinger_
11:14:23 <araujo> monochrom, monads?
11:14:49 <monochrom> Point (a) together with a lack of metric means you don't have a stopping criterion.  Point (b) means you don't bother with a stopping criterion.  Therefore fixed points of Haskell functions are computed by unbounded iteration, which is written as a simple recursion.
11:16:17 <araujo> monads?
11:16:29 * Heffalump wonders what point monochorom is trying to make
11:16:47 <syntaxfree> That supposes simple iteration gets you arbitrarily close to a fixpoint.
11:16:47 <sorear> > mfix (\_ -> return (2)) :: [Int]
11:16:49 <lambdabot>  [2]
11:17:05 <syntaxfree> That's not clear to me.
11:17:14 <sorear> > mfix (\x -> return [0,x+1]) :: [Int]
11:17:14 <lambdabot>  Couldn't match `Int' against `[a]'
11:17:20 <sorear> > mfix (\x -> [0,x+1]) :: [Int]
11:17:22 <lambdabot>  Exception: <<loop>>
11:17:27 <sorear> > mfix (\x -> [x+1,0]) :: [Int]
11:17:28 <lambdabot>  Exception: <<loop>>
11:17:33 <Heffalump> syntaxfree: it does under certain conditions, e.g. monotonic functions on a lattice
11:17:57 <syntaxfree> Heffalump: well, sure.
11:17:59 <monochrom> If you really want to use a real-analysis background to understand the partial order case, here is an imperfect way but it works for a few minutes (until you realize there is no metric).  Imagine the real projective plane.  Imagine functions whose fixed points are "at infinity".  (There are many infinities.)  All Haskell functions are like that: their fixed points are at infinity.
11:18:02 <sorear> > mfix (\x -> [x,x+1]) :: [Int]
11:18:04 <lambdabot>  Exception: <<loop>>
11:19:34 <monochrom> I do not know why araujo asks me about monads.  I am not talking about monads.
11:19:36 * shapr hugs Heffalump 
11:20:57 <Heffalump> hello shapr
11:21:27 <monochrom> All Haskell functions are monotonic wrt the partial orders we impose on data types.
11:21:59 <shapr> hiya Heffalump! How's code?
11:23:06 <monochrom> Example.  For Int, the order is _|_ [= everyone; for every number (i.e. not _|_) n, n[=n; nothing more.
11:23:25 <scodil> whats the simplest way to associate a finalizer for a haskell value? not necessarily a pointer
11:23:31 <Codex_> >fix id
11:23:43 <norpan> scodil: a finalizer? how'd that work?
11:23:56 <scodil> a function to get called right before its collected
11:24:04 <norpan> what use would that be?
11:24:04 <monochrom> You cannot write a Haskell function (this generalizes to all prog langs) such that f 1 = _|_, f _|_ = 1.  Thus you cannot write a function that breaks the order.
11:24:05 <araujo> monochrom, I just think that the monads help to have that 'undecidable' fixed point data type.
11:24:06 <Lemmih> @hoogle addFinalizer
11:24:07 <lambdabot> System.Mem.Weak.addFinalizer :: key -> IO () -> IO ()
11:24:19 * shapr hugs Lemmih 
11:24:39 <Lemmih> Hiya shapr. *hugs*
11:24:47 <norpan> scodil: for debugging?
11:24:48 <scodil> Lemmih: but then the value is of type (Weak a), not a, right?
11:24:51 <shapr> Lemmih: How's code?
11:25:25 <scodil> norpan: no for opengl. the opengl interface has this slick add-on where it will free display lists when they go out of scope, but for some reason it doesn't do it for textures. i'm trying to do that
11:25:51 <Lemmih> shapr: Good good. I'm looking forward to working for Alex again.
11:26:00 <monochrom> I do not know how to parse "'undecidable' fixed point data type".   Dart, I blew my statement.  It should be: it is undecidable whether a value is a fixed point or not.
11:26:20 <Lemmih> scodil: I think it should work for everything.
11:26:28 <kilimanjaro> shapr: btw, if you find a place that is selling several copies of that Hamming book, brag about it in this channel so I can buy one :)
11:26:32 <norpan> Lemmih: that texture would be a ForeignPtr then?
11:26:45 <norpan> err scodil
11:28:25 <norpan> addFinalizer should work
11:28:28 <shapr> kilimanjaro: I found a used copy last night for $125, and my credit card nearly flew out of my hands at the rate I purchased...
11:28:45 <shapr> Other than that, I've only found the $600 copy in the netherlands.
11:28:58 <benja_> @remember vegai for #haskell, that might be "Write a F*cking Dissertation"
11:28:59 <scodil> norpan: yeah i guess foreign ptr works too, but its not a pointer. its just an unsigned int
11:29:31 <shapr> @quote vegai
11:29:32 <lambdabot>  Hey Haskell! Give me that File! -Naah, I'm too lazy. *thinks* I'll give you a cookie if you tell me how many letters that file has! -Oh, ok!
11:29:34 <shapr> @quote vegai
11:29:35 <lambdabot>  for #haskell, that might be "Write a F*cking Dissertation"
11:29:36 <shapr> yay!
11:29:50 <sorear> @quote quazimodo
11:29:50 <lambdabot>  btw i think i have a feeling i know why you guys are so ready to deal with me and put up with noob questions ... your program so fast compared to other language users that you have time to mess
11:29:50 <lambdabot> around?
11:29:52 <norpan> @quote norpan
11:29:52 <lambdabot>  the comonad of the No monad is the Yes monad?
11:30:13 <kilimanjaro> shapr: wow
11:30:27 <sorear> quazimodo said that yesterday...
11:30:50 <Heffalump> @quote Heffalump
11:30:50 <lambdabot>  docs aren't all that useful, generally
11:31:04 <monochrom> I hurts my heart that only 1% of us know lattice theory.
11:31:27 <shapr> monochrom: So, write a TMR article that mixes Haskell and lattice theory!
11:31:47 <monochrom> I have to "Write a F*cking Dissertation"
11:32:35 <geckosenator> haha
11:33:10 <sorear> Add 0.33% - I know what a lattice is
11:33:36 <norpan> i know what a crystal lattice is
11:33:55 <kilimanjaro> ok, that's halfway there
11:33:58 <monochrom> My "1%" there was a very rough approximation.  Could be 1%-10%.
11:33:59 <Saizan> a lattice is when you have a set and a partial order relation?
11:34:06 <sorear> a little more
11:34:18 <sorear> a lattice gives you lub and glb operators
11:34:28 <SamB> lub and glub, yay!
11:34:28 <Saizan> ah, yes
11:34:55 <sorear> e.g naturals under divisible-by, with lcm and gcd
11:34:57 <norpan> lube and glue!
11:35:00 <monochrom> Actually you won't need a lattice for Haskell.  You need a partial order with a lub.  (glb not used)
11:35:10 <sorear> i.e a semilattice
11:35:22 <Saizan> a lub b == a iff a <= b ?
11:35:29 <sorear> yes
11:35:36 <monochrom> a lub b == b
11:35:47 <sorear> that is how you reconstruct the partial order given only lub
11:36:01 <kilimanjaro> whatever happened to terms like sup and inf?
11:36:08 <monochrom> lub = sup
11:36:11 <sorear> huh?
11:36:16 <sorear> :)
11:36:28 <kilimanjaro> yea, I just have never seen anybody say lub and glub
11:36:35 <kilimanjaro> mathematicians are above that
11:36:37 <SamB> kilimanjaro: they don't have as much mnemonic value
11:36:52 <sorear> LUB = Least Upper Bound, I made up GLB
11:37:07 <benja_> (sorear: supremum and infimum)
11:37:15 <benja_> (just in case that was the question =))
11:37:16 <monochrom> you are not the first one to have made up glb.
11:37:18 <syntaxfree> economists are lazy.
11:37:22 <Saizan> aaah ok, it's kind of difficult to map math terminology from a language to the other :D
11:37:27 <sorear> I never am :(
11:37:34 <SamB> Saizan: hmm?
11:37:46 <syntaxfree> Preferences are a partial order, but they just invent an equivalence class of monotonic continuous functions that "represent" that partial order.
11:38:23 <syntaxfree> Then everything's done on ordinary analysis.
11:38:31 <syntaxfree> Well, not everything.
11:38:35 <kilimanjaro> whee, that's the good kind of laziness
11:38:55 <syntaxfree> General equilibrium models need abstract-er stuff to show existence/uniqueness of equilibria, etc.
11:38:58 <Saizan> SamB: when i read about math in english i'm often unsure if i already encountered it in italian terms
11:39:10 <SamB> ah
11:39:20 <syntaxfree> But a lot of economics, and particularly a lot of the *very best* economics is done with that trick.
11:39:24 * benja_ has recently noticed that vectors are not actually monads
11:39:27 <SamB> that problem is not unique to inter-lingual learning
11:39:34 <kilimanjaro> syntaxfree: the bad kind of laziness is "so they just invent an equivalance class of monotonic continuous functions that `represent' that partial order. but they haven't taken a shower in like 10 days!"
11:40:35 <monochrom> I have to see the details to be convinced that it is a better approach.  My past experience is that partial orders are more abstract and therefore to-the-point than real-valued functions.
11:40:53 <allbery_b> @remember kilimanjaro  the bad kind of laziness is "so they just invent an equivalance class of monotonic continuous functions that `represent' that partial order. but they haven't taken a shower in like 10 days!"
11:41:20 <sorear> y'know, dons will have to read through all these quotes... :)
11:41:21 <syntaxfree> monochrom: the basic problems of economic analysis often boil down to goal function optimization.
11:41:46 <syntaxfree> monochrom: That trick allows us to use Kuhn-Tucker almost everywhere.
11:41:55 <syntaxfree> "Almost everywhere" not being the measure-theoretical term :)
11:42:02 <SamB> haha
11:43:10 <benja_> kilimanjaro: the bad kind of laziness is to use italics to indicate that you want to make up a term but not explain it
11:43:21 <kilimanjaro> syntaxfree: are you an economics student?
11:43:26 <kilimanjaro> benja_: ok, agreed :)
11:43:37 <benja_> "intuitively, the equivalence class represents the _absolute_ information content of these objects"
11:44:00 <kilimanjaro> that's not italics,/this/ is italics
11:44:27 <shapr> Oh Yes! The hamming book has been shipped!!
11:44:39 <syntaxfree> I'm so used to employing _this_ for emphasis, the CSS on  my blog remaps <em> and <i> to bold.
11:45:10 * benja_ tends to use *this* for <em> and _this_ for italics which are not <em>
11:45:16 <jgrimes> shapr, the hamming book? forgive my ignorance.
11:45:18 * shapr just waves his hands...
11:45:28 <kilimanjaro> syntaxfree: i'm thinking about picking up a bs in economics as a second major (my primary being mathematics)
11:45:29 <syntaxfree> benja_: oh. forgotten context: I use markdown syntax.
11:45:33 <benja_> although in the above, you can read it as emphasis
11:45:52 <syntaxfree> kilimanjaro: that's a good idea. I wish I had taken a BS in mathematics and later gone to grad school in economics.
11:45:54 * sorear tends to use this for unfontified text and  for invisible text.
11:46:10 <syntaxfree> well, worse yet,, I wish I had taken a BS in mathematics and was doing FP work right now.
11:46:13 <benja_> sorear: :-)!
11:46:15 <shapr> jgrimes: http://www.amazon.com/gp/product/9056995014/ - and don't believe the $40 price.
11:46:51 <kilimanjaro> syntaxfree: well, a year ago I would have said I wanted to be doing work in theoretical CS. now i'm not so certain
11:47:02 <ph8> in this rather simple function to strip punctuation from a string
11:47:03 <ph8> > stripPunc "mr."  = "mr"
11:47:03 <ph8> > stripPunc "mrs." = "mrs"
11:47:04 <lambdabot>  Parse error
11:47:04 <lambdabot>  Parse error
11:47:12 <ph8> how would i say, if there's a " at the front, remove it?
11:47:19 <kilimanjaro> i decided to major in math because even though my interests flip flop alot, a solid understanding of math is the one recurring theme
11:47:22 <syntaxfree> yeah. Anyway, I want to get my masters' and go out and get a job.
11:47:23 <jgrimes> shapr, interesting.
11:47:25 <ph8> would i have to stripPunc a, then have some do ...?
11:47:33 <sorear> ph8: filter (not . flip elem ".,\"") ?
11:47:37 <kilimanjaro> syntaxfree: doing what?
11:47:38 <shapr> jgrimes: Read the speech - http://www.cs.virginia.edu/~robins/YouAndYourResearch.html
11:47:39 <lambdabot> Title: You and Your Research
11:47:54 <ph8> sexy sorear
11:48:02 <shapr> jgrimes: Hamming turned that speech into a book a few years later. But the book is *very* hard to find. I've been looking for five years or so.
11:48:03 <ph8> flip?
11:48:04 <syntaxfree> I really should be doing research right now. Or these days.
11:48:15 <jgrimes> shapr, oh, I didn't know he turned it into a book
11:48:15 <sorear> > elem '.' ".,!"
11:48:17 <lambdabot>  True
11:48:18 <syntaxfree> Anyway, since my girlfriend dumped me two weeks ago I've been kinda sleepwalking all day.
11:48:25 <sorear> > flip elem ".,!" '.'
11:48:27 <lambdabot>  True
11:48:28 <syntaxfree> I think I need to find me a new woman before I can resume good work.
11:48:35 <shapr> jgrimes: or read what I wrote about the speech - http://lambda-the-ultimate.org/node/668
11:48:37 <lambdabot> Title: Richard Hamming - "You and Your Research" | Lambda the Ultimate
11:48:43 <kilimanjaro> syntaxfree: what area of study is your masters in?
11:49:02 <syntaxfree> I'm supposed to be doing work in insurance contracts. I have a grant that specifies that.
11:49:09 <ph8> ?type filter
11:49:10 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
11:49:13 <syntaxfree> I'm thinking of kicking the bucket and doing something in econometrics.
11:49:16 <syntaxfree> I really enjoy econometrics.
11:49:20 <jgrimes> shapr, all right, thanks. :)
11:49:25 <sorear> ?type flip
11:49:26 <lambdabot> forall c a b. (a -> b -> c) -> b -> a -> c
11:49:32 <sorear> ?type elem
11:49:32 <ph8> that never helps me :/
11:49:33 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
11:49:34 <syntaxfree> As an economist, each day I doubt its significance more, but I love doing econometric work.
11:49:39 <ph8> > stripPunc :: String -> String
11:49:39 <ph8> > stripPunc w = filter (not . flip w ".,\"")
11:49:40 <ph8> ?
11:49:40 <lambdabot>  Not in scope: `stripPunc'
11:49:40 <lambdabot>  Parse error
11:49:48 <shapr> jgrimes: The downside is that you'll want the book after reading the speech, and you can't have my copy =) But you can borrow it if you're really nice...
11:49:58 <ph8> i don't understand the clever bits. :p
11:50:04 <shapr> My friend Darius Bacon already has dibs on the first borrow though.
11:50:07 <ph8> ?hoogle filter
11:50:08 <lambdabot> Prelude.filter :: (a -> Bool) -> [a] -> [a]
11:50:09 <lambdabot> Data.IntMap.filter :: (a -> Bool) -> IntMap a -> IntMap a
11:50:09 <lambdabot> Data.IntSet.filter :: (Int -> Bool) -> IntSet -> IntSet
11:50:10 <syntaxfree> There's really an unsustainable tension in economics -- dunno if CS has something like that.
11:50:11 <shapr> loan*
11:50:13 <ph8> still not helping :/
11:50:16 <shapr> Swedish confuses me.
11:50:18 * ph8 hops on to the web
11:50:19 <jgrimes> shapr, haha. all right. :)
11:50:20 <Saizan> ph8: you missed 'elem' inside there
11:50:28 <sorear> stripPunc w = filter (\ch -> not (elem ch ".,\"")) w
11:50:31 <ph8> but wasn't elem meant to be 'arbitrary element'?
11:50:33 <syntaxfree> In theoretical matters, ceteris paribus-type premises are the sickness eating our profession inside out.
11:50:37 <ph8> oh god it's got worse
11:50:49 <syntaxfree> I think it's no longer possible to do progress in ceteris paribus terms.
11:50:50 * benja_ has a Swedish for foreign students exam on jan 19th
11:50:54 <benja_> (in Finland)
11:51:02 <shapr> benja_: hyvää!
11:51:08 <shapr> benja_: Talar du svenska?
11:51:14 <shapr> benja_: puhutko suomea?
11:51:16 <syntaxfree> OTOH, small econometric models better predict the future than large, hundreds-of-equations models.
11:51:19 <benja_> jag talar lite svenska. och du?
11:51:22 <shapr> xu do tavla mi bau la lojban
11:51:22 <sorear> > filter (\ch -> not (elem ch ".,\"!?")) "Hello, this is a sample sentence!  \"Punctuate?\""
11:51:24 <lambdabot>  "Hello this is a sample sentence  Punctuate"
11:51:29 <kilimanjaro> i don't really know econometrics
11:51:34 <syntaxfree> In part because of heteroskedacity in the distribution of *population* parameters.
11:51:41 <kilimanjaro> my only experience with economics has been two crappy macro and micro classes
11:51:53 <syntaxfree> (That population parameters are stochastic is a given nowadays)
11:51:58 <shapr> Jo, jag talar lite svenska också. Jag bodde i Boden och i Stockholm i 3.5 år. Det var jättekul!
11:52:03 * araujo hopes not to take econo* courses in his career
11:52:08 <benja_> puhun myös vhn suomea
11:52:12 <allbery_b> whee, I actually guessed what @pl would do with that.  maybe I'm starting to get the hang of this
11:52:15 <araujo> Though i think they have something like in the last semesters
11:52:15 <benja_> vähän
11:52:18 <syntaxfree> anyway. So most interesting econometric work is still being done in low-dimensional models.
11:52:19 <ph8> i'm just looking up things like.. elem
11:52:27 <shapr> Och jag bodde i Finland 3.5 år också, i Tornio. Det var inte så kul. Men det var kalt.
11:52:33 <araujo> I could probably take it, so i learn a bunch of new weird words :-)
11:52:39 <syntaxfree> Yet as a theoretician I feel low-dimensional models can't take us much further.
11:52:42 <sorear> ph8: elem o list --> is o anywhere in list?
11:52:59 <ph8> ahh
11:53:05 <benja_> shapr: hah :)
11:53:05 <sorear> ph8: elem o list --> is o an 'elem'ent of list, treated as a set?
11:53:19 <ph8> that assumes i'm going through each word char-by-char though?
11:53:20 <benja_> missä Boden on?
11:53:22 <shapr> benja_: Är du författare av "using P2P to make the desktop part of the web" ?
11:53:22 <kilimanjaro> syntaxfree: maybe I will be able to continue this conversation in... 2 years :)
11:53:24 <ph8> or is that what the \ch stuff is doing?
11:53:25 <syntaxfree> So, anyway. The standard Richard Hamming advice of "find out what's the hottest open question in your field and work on it" is really bitter for me.
11:53:38 <benja_> shapr: jag är
11:53:41 <shapr> benja_: Boden är nära till Tornio och Haparanda, just ute av Luleå
11:53:43 <benja_> niin olen :)
11:53:45 <shapr> benja_: Jättekul!
11:53:59 <benja_> shapr: ok
11:54:03 <syntaxfree> I don't enjoy economics any longer, and research is conducted in different "schools of thought" emphasizing different low-dimensional "clippings" of reality, and worse, these don't communicate.
11:54:08 <sorear> > let isNotPunct ch = not (elem ch ".,!?\"") in inNotPunct '?'
11:54:09 <lambdabot>  Not in scope: `inNotPunct'
11:54:12 <sorear> > let isNotPunct ch = not (elem ch ".,!?\"") in isNotPunct '?'
11:54:14 <lambdabot>  False
11:54:15 <sorear> > let isNotPunct ch = not (elem ch ".,!?\"") in isNotPunct 'a'
11:54:16 <lambdabot>  True
11:54:18 <monochrom> There are many competing ideas in CS but there is no tension.
11:54:24 <syntaxfree> I was also dumped by my girlfriend. Did I say that?
11:54:24 <shapr> Du är också författare av "Freenet-like GUIDs for implementing xanalogical hypertext" ?
11:54:37 <kilimanjaro> syntaxfree: it was implied
11:54:37 <sorear> > let isNotPunct ch = not (elem ch ".,!?\"") in filter isNotPunct "He,llo! pun\"ctuation?"
11:54:39 <lambdabot>  "Hello punctuation"
11:54:43 <benja_> joo :)
11:54:43 <shapr> Har du nån hemsida eller blog?
11:54:51 <sorear> ph8: clearer?
11:54:57 <syntaxfree> So, anyway, if I may use an expletive, I'm really fucked.
11:54:59 <syntaxfree> *sigh*
11:55:18 <monochrom> COME JOIN THE DARK SIDE.....
11:55:19 <ph8> yes sorear, cheers - but how is it getting it into characters?
11:55:20 <shapr> syntaxfree: don't worry, there's a fascinating world out there, you just gotta grab it and do cool stuff.
11:55:24 <ph8> is that what filter does automagically?
11:55:24 <allbery_b> or not, as the case may be
11:55:25 <benja_> shapr: not a current one, but http://flowerpot.kaijanaho.fi/~benja/board/blog/
11:55:30 <ph8> ah of course, a string is a character array
11:55:33 <allbery_b> ph8: a string is a list of characters
11:55:34 <ph8> so filter is over that list
11:55:36 <ph8> s/array/list
11:55:36 <ph8> :p
11:55:38 <shapr> benja_: tack / kiitos
11:55:41 <syntaxfree> shapr: well, that's kinda what I feel about FP.
11:55:44 <ph8> oh my! was that perl?
11:55:52 * ph8 sews his mouth shut
11:55:54 <shapr> benja_: Oh, you are/were part of the fenfire project!
11:55:59 <sorear> no, that's ed.
11:56:03 <benja_> am :)
11:56:06 <sorear> ed is the standard text editor.
11:56:10 <syntaxfree> I know a bit of FP theory by now, but the deep, gaping voids in my general CS education show.
11:56:15 <benja_> more interesting than my page is my current code: http://antti-juhani.kaijanaho.fi/darcs/fenfire-hs/
11:56:15 <sorear> using ed is O.K. here.
11:56:15 <shapr> benja_: Are you here because of ibid then?
11:56:19 <benja_> (started this month)
11:56:26 <benja_> shapr: I'm here because I'm using Haskell :)
11:56:36 <lambdabot> Title: Index of /darcs/fenfire-hs
11:56:44 <shapr> How are you going to beat the patent problems involved in fenfire?
11:56:44 * sorear has actually used ed, for its original purpose
11:56:55 <shapr> I heard bits of the long sordid story of the first few incarnations.
11:57:11 <benja_> shapr: right now, by not using code written by people too worried about the patent
11:57:14 <shapr> heh, ok
11:57:30 <Stinger_> who or what is Fenfire?
11:58:02 <shapr> It's a really cool idea that's sort of like multidimensional spreadsheets.
11:58:16 <Stinger_> sounds horrible :)
11:58:19 <monochrom> Perhaps I should write that partial order primer for TMR.
11:58:23 <shapr> It's about halfway between multidimensional spreadsheets and the original 'xanadu' idea behind the web.
11:58:29 <benja_> if they send us a letter that we're supposed to stop doing what we're doing, we can decide what to do
11:58:29 <shapr> Stinger_: It's way spiffy, check it out.
11:58:49 * SamB wishes he had two minus signs on his keyboard, like calculators have
11:58:55 <shapr> If they can beat the patent problems, I predict it'll be the next killer app.
11:59:17 <benja_> multidimensional spreadsheets is actually more (G)ZigZag, which is what Fenfire was before it became Fenfire because ZigZag is patented... :/
11:59:19 <sorear> SamB: look at standard ML
11:59:25 <benja_> Fenfire is more like mindmaps :)
11:59:33 <SamB> sorear: that is not a kind of keyboard!
11:59:51 <sorear> SamB: SML uses ~ for negation and - for subtraction
11:59:54 <SamB> ah
12:00:03 <SamB> don't we already use ~ for something else?
12:00:05 <benja_> they're not really that different in many ways, but ZigZag uses a tabular-looking layout and Fenfire a more mindmappish layout
12:00:09 <shapr> benja_: I'd love to talk about this in great detail, but I have to go åka min enhjuling... I'll bug you when I have more time :-)
12:00:16 <benja_> shapr: sure :)
12:00:27 <benja_> I should go to bed soon, I just came back today from Finland
12:00:38 <shapr> Var bor du?
12:00:45 <SamB> I just want the special-casing of - to go away
12:00:53 <AStorm> 3D spreadsheet... sounds evil
12:01:04 <AStorm> though we're actually doing that with those multiple sheets :P
12:01:05 <benja_> at home with my parents in germany
12:01:25 <norpan> SamB: wouldn't we have to special-case ~ instead?
12:01:38 <sorear> no! just make all patterns lazy
12:01:44 <SamB> norpan: hmm?
12:01:56 <SamB> I don't follow you.
12:01:58 <norpan> unary operators are evil
12:02:02 <SamB> oh, right.
12:02:31 <sorear> unary operators aren't evil, it's the overloading of - as both that is
12:02:59 <SamB> yeah, I'm with sorear
12:04:16 <monochrom> I also like *ML's ~ for unary minus and - for binary minus.
12:05:05 <AStorm> Define your own unary minus
12:05:13 <AStorm> I suggest ---
12:05:15 <Saizan> and we should have n-k patterns
12:05:24 <AStorm> Ah, nay, this is a comment
12:05:43 <SamB> ascii: you can't do that without prefix fixity support!
12:05:45 <SamB> er.
12:05:46 <SamB> AStorm:
12:05:50 * SamB sorry
12:06:10 <AStorm> Why? It's just a function :P
12:06:12 <monochrom> > (- 1) 2  {- I expect binary minus there -}
12:06:13 <lambdabot>  add an instance declaration for (Num (t -> a))
12:06:13 <lambdabot>   In the definition of `ir...
12:06:17 <AStorm> Of high fixity
12:06:40 <AStorm> ---1 2
12:06:48 <AStorm> That'd mean something else.
12:06:58 <AStorm> -1 2 in math notation
12:07:03 <AStorm> e.g. f ---1 2
12:07:22 <monochrom> I expect binary minus in (- 1), but the parser thinks it's unary minus.  AStorm, this shows that your suggestion "define your own unary minus" does not make a difference.  Perhaps you meant "define your own binary minus"
12:07:41 <AStorm> ((-) 1)
12:07:42 <AStorm> :>
12:07:48 <AStorm> > ((-) 1) 2
12:07:49 <lambdabot>  -1
12:07:57 <AStorm> Hmm.
12:08:02 <AStorm> Stupid parsed!
12:08:08 <AStorm> *parser
12:08:08 <monochrom> I want (- 1) 2 = 2-1
12:08:24 <allbery_b> > (subtract 1) 2
12:08:25 <lambdabot>  1
12:08:32 <AStorm> > (1 (-)) 2
12:08:33 <lambdabot>  add an instance declaration for (Num ((a -> a -> a) -> t -> a1))
12:08:33 <lambdabot>   In the...
12:08:48 <humasect> http://aycu12.webshots.com/image/6691/2004291971817969593_rs.jpg -- haskell + xcode
12:08:56 <AStorm> ?type (-)
12:08:58 <lambdabot> forall a. (Num a) => a -> a -> a
12:09:14 <AStorm> Overloading that is evil, totally :P
12:09:22 <allbery_b> > (flip (-) 1) 2
12:09:23 <lambdabot>  1
12:09:35 <monochrom> Hehehehehehe
12:09:48 <AStorm> > (- . 1) 2
12:09:48 <lambdabot>  Parse error
12:09:55 <AStorm> > ((-) . 1) 2
12:09:56 <lambdabot>  add an instance declaration for (Num (a -> b))
12:10:13 <AStorm> No, flip is correct :>
12:10:25 <AStorm> @pl flip (-)
12:10:26 <lambdabot> subtract
12:10:39 <mgsloan> > (-1) 2 -- /me wonders how smart subtraction/negation sections are
12:10:39 <lambdabot>  add an instance declaration for (Num (t -> a))
12:10:40 <lambdabot>   In the definition of `ql...
12:10:49 <mgsloan> > (- 1) 2
12:10:50 <lambdabot>  add an instance declaration for (Num (t -> a))
12:10:50 <lambdabot>   In the definition of `mz...
12:10:50 <allbery_b> this is a well known parser wart, "subtract" is the workaround
12:11:25 <allbery_b> (and as pl said, subtract is just flip (-) )
12:11:51 <AStorm> If you want it shorter...
12:12:04 <syntaxfree> Warts.
12:12:13 <syntaxfree> There should be a list of warts in the wiki.
12:12:16 <AStorm> > let (-s) = `subtract` in (-s) 1 2
12:12:17 <lambdabot>  Parse error
12:12:23 <AStorm> > let (-s) = subtract in (-s) 1 2
12:12:24 <lambdabot>  Parse error in pattern
12:12:35 <AStorm> > let (-s) = subtract in (-s 1) 2
12:12:35 <syntaxfree> Just so that some random dick doesn't find us too self-congratulatory and invents some warts that really aren't.
12:12:36 <lambdabot>  Parse error in pattern
12:12:51 <AStorm> Bleh.
12:12:59 <mgsloan> parser issue, not compiler/prlude
12:13:24 <AStorm> > let (--) = subtract in (-- 1) 2
12:13:25 <lambdabot>  Parse error
12:13:49 <AStorm> Stupid choice of a comment delimiter :P
12:14:08 <syntaxfree> yes. {- should be enough -}
12:15:37 <AStorm> ?type (//)
12:15:39 <lambdabot> forall e i. (Ix i) => Array i e -> [(i, e)] -> Array i e
12:16:25 <AStorm> What does this operator do?
12:16:41 <AStorm> Removes some items?
12:16:49 <benja_> from the type, it ought to be update?
12:17:14 <benja_> I can't see that it could be doing anything else, given that type :)
12:17:23 <AStorm> removal of items maybe?
12:17:27 <ph8> hmm
12:17:33 <benja_> AStorm: it doesn't require Eq e
12:17:44 <AStorm> Hmm, right.
12:17:51 <benja_> and you can't remove from an array, can you? just replace
12:17:55 <mgsloan> right, and you actually pass it e - removal would just be [i]
12:17:56 <ph8> :o)
12:17:59 <ph8> sorry it wasn't related to anything
12:18:02 <mgsloan> that too
12:18:02 <ph8> i was typing my thoughts :p
12:18:24 <ph8> i'm wondering how i still get ["","\"'If"]:=["you"] <-- keys like that, using sorear's stripping function
12:18:27 <AStorm> Indeed. So why // and not something else? :P
12:18:34 <AStorm> ?type update
12:18:36 <lambdabot> Not in scope: `update'
12:19:30 <alc> installed a lambdabot, but always got the following error:
12:19:38 <mgsloan> perhaps it is because they defined the access operator, !
12:19:39 <alc> search module failed: IRCRaised getHostByName: does not exist (no such host entry)
12:19:44 <alc> any hint?
12:20:01 <mgsloan> figured it deserved a parallel update op - you'd be doing a lot of these if you're messing with arrays
12:20:05 <alc> when i try to '@google something'
12:20:54 <AStorm> Next time, name it <// or something
12:21:05 <AStorm> With that arrow :P
12:21:48 <alc> uh got it
12:21:54 <mgsloan> AStorm - well, you can reuse identifiers in your own programs
12:21:54 <alc> that proxy thing
12:22:17 <AStorm> mgsloan, I know, but nonstandard syntax is unreadable to some people :P
12:22:21 <mgsloan> you just have to import Array stuff qualified to use them both
12:22:26 <mgsloan> ah
12:22:41 <mgsloan> yeah, that is a bit obtuse, even looks like a c comment
12:22:47 <AStorm> :>
12:22:48 * allbery_b wonders if that's indicative... "Copying patch <n> of 1337..."
12:23:10 <AStorm> ?type (:>)
12:23:13 <lambdabot> Not in scope: data constructor `:>'
12:23:33 <AStorm> I wonder if the parser can parse :) as an operator
12:23:40 <AStorm> (:))
12:23:56 <allbery_b> think parens are special
12:24:48 <paolino> mmh, is there a findBy like function ?
12:24:59 <metaperl> ?url monads as containers
12:25:00 <lambdabot> http://www.nomaware.com/monads/html/index.html
12:25:10 <AStorm> thick parens? Tell me more about it :>
12:25:15 <metaperl> Cale - is this the right URL? http://www.haskell.org/hawiki/MonadsAsContainers
12:25:16 <lambdabot> Title: MonadsAsContainers - The Haskell Wiki
12:25:30 <metaperl> it looks different to the one I was looking at a day ago
12:25:36 <Cale> that's the old wiki
12:25:49 <metaperl> @url monads as containers
12:25:49 <lambdabot> http://www.nomaware.com/monads/html/index.html
12:25:50 <Cale> you'll notice a link from there to the same article on the new wiki
12:25:52 <mgsloan> :t find
12:25:54 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
12:26:02 <Cale> http://www.haskell.org/haskellwiki/Monads_as_Containers
12:26:05 <lambdabot> Title: Monads as containers - HaskellWiki
12:26:10 <mgsloan> is that what you want paolino?
12:26:17 <metaperl> ok thanks
12:26:46 * psnl winces, I can't make hac anymore
12:27:14 <metaperl> Cale - monads as computation... will that be written soon?
12:27:26 <AStorm> Arrows as computation :>
12:27:43 <Cale> metaperl: well, most of the other articles out there take that route
12:27:44 <metaperl> I am not to arrows yet and it wont be soon I'm afraid :)
12:27:48 <AStorm> Monads can't be all kinds of them.
12:27:50 <diegito> thanks to everyone, i leave...
12:28:05 <AStorm> Well, arrows are indeed simple, like monads but less limited.
12:28:05 <metaperl> arrows is the next step after monads I suppose
12:28:07 <Cale> I sort of left that link there as an invitation for someone else to write that page.
12:28:10 <paolino> mgsloan, there is a deleteBy , sortBy, groupBy , I need a findBy
12:28:12 <metaperl> yes, a generalization
12:28:17 <ski> > let (---) = 42 in (---)
12:28:17 <lambdabot>  Parse error
12:28:23 <AStorm> -- is a comment
12:28:27 <metaperl> paolino - filter?
12:28:29 <metaperl> @type filter
12:28:31 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
12:28:45 * ski thought '---' could be an operator
12:28:58 * allbery_b thought so too 
12:29:10 <monochrom> arrow as dataflow
12:29:17 <dylan> ugh, why are web frameworks so huge?
12:29:31 <araujo> dylan, they are usually written on java
12:29:35 * araujo flips
12:29:46 <AStorm> Ah, right, my question... Any nice Haskell web framework available?
12:29:48 <AStorm> E.g. for CGI programming
12:29:52 <dylan> araujo: well, even perl and python ones are evil.
12:29:57 <paolino> metaperl: filterBy
12:30:10 <dylan> Catalyst seemed nice at first, but I find all the abstractions useless.
12:30:25 <_matthew_> AStorm: eerr, other than the basic cgi/fastcgi stuff, I don't know of anything haskelly
12:30:34 <Cale> A comment starts with two or more consecutive dashes and extends to the following newline, however the sequence of dashes must not form part of a legal lexeme.
12:30:35 <dylan> `HAppS?
12:30:54 <allbery_b> paolino: explain what filterBy would do that filter doesn't
12:30:56 <AStorm> HAppS is a server
12:30:56 <dylan> s/`//
12:31:10 <dylan> 'tis?
12:31:14 <dylan> I thought it was a framework.
12:31:23 <AStorm> Yes, framework a'la Zope
12:31:27 <AStorm> I don't need that :P
12:31:28 <_matthew_> NO!
12:31:34 <dylan> oh. zope-like. eeew
12:31:40 <_matthew_> please, may no one ever reinvent zope
12:31:50 <AStorm> But better of course, lighter
12:32:11 <metaperl> @hoogle filterBy
12:32:12 <lambdabot> No matches found
12:32:18 <paolino>  I have a list of tuples, I need to find by fst snd and third
12:32:21 <AStorm> Anyway, I need something that'll help me handle all that auth stuff
12:32:24 <AStorm> and other mess
12:32:35 <AStorm> (like cookies)
12:32:42 <AStorm> Something basic like mod_python
12:32:46 <metaperl> AStorm - WASH as well...
12:32:48 <_matthew_> doing something as wrong as zope once is, perhaps, forgiveable. twice isn't!
12:32:50 <metaperl> @url wash
12:32:51 <lambdabot> http://www.informatik.uni-freiburg.de/~thiemann/haskell/WASH/
12:33:02 <AStorm> metaperl, well thanks!
12:33:03 <metaperl> AStorm - also WebFunctions
12:33:25 <metaperl> AStorm - but all the Haskell web frameworks are very different from my experience with Perl and Python...
12:33:44 <AStorm> Yes, because they're combinatorial
12:33:48 <metaperl> AStorm - as soon as I finish monads I want to explore a RAD framework for Haskell based on Django
12:33:52 <AStorm> Not procedural. Exactly nice
12:34:01 <metaperl> I dont understand them
12:34:18 <_matthew_> Presumeably the Haskell ones are more along the lines of "If we'd invented the web, it would work like this" rather than the Perl/Python "let's just do something that works"... ;)
12:34:27 <metaperl> LOL
12:34:56 <araujo> Haskell will be reaplacing all that in the next 10 years
12:35:09 <metaperl> PHP ownz j00
12:35:17 <araujo> Perl6 will be our backdoor
12:35:20 * araujo hides
12:35:21 <metaperl> Haskell people have no sense of design
12:35:27 <jgrimes> :(
12:35:34 <allbery_b> PHP is more commonly 0wn3d than 0wn1ng :>
12:35:35 <metaperl> you need pretty web pages and spiffy graphics to own the web
12:35:40 <metaperl> no - PHP owns
12:35:44 <metaperl> it sucks, but it owns
12:35:56 <metaperl> they have the most web deliverables of any language. period.
12:36:05 <araujo> metaperl, our design is just a bit twisted, os it is difficult to appreciate its beauty.
12:36:10 <_matthew_> metaperl: true. but as Vista and OSX points out, there're more important things than design
12:36:19 <metaperl> it's easy to criticise, but vis-a-vis web deliverables. PHP delivers, Haskell only talks
12:36:49 <_matthew_> araujo: are you on a dvorak keyboard?
12:37:06 <araujo> _matthew_, why do you ask?
12:37:23 <_matthew_> the typeo of "os" vs "as"; o is next to a on dvorak
12:37:33 * allbery_b read it as transposed "so"
12:37:33 <AStorm> metaperl, that WASH looks almost like HSP
12:37:39 <araujo> s/os/so/
12:37:40 <AStorm> Haskell Server Pages
12:37:40 <araujo> :-)
12:37:52 <_matthew_> araujo: ahh! ok. :-)
12:37:53 <metaperl> I never saw haskell server pages
12:38:06 <AStorm> ;-)
12:38:19 <metaperl> http://www.cs.chalmers.se/~d00nibro/hsp/
12:38:22 <lambdabot> Title: HSP - Haskell Server Pages
12:38:25 <AStorm> You know, those <% someinputid = thatwhatever %>
12:38:26 <araujo> Hope?
12:47:15 <monochrom> Eh?  PHP owns because it is the most widely delivered?  So Windows owns because it is the most widely installed?
12:47:33 <monochrom> So democracy works?
12:47:35 <allbery_b> that *is* a common argument...
12:47:56 <lisppaste2> ph8 pasted "How come  doesn't work" at http://paste.lisp.org/display/33645
12:48:06 <ph8> sorry
12:48:08 <AStorm> PHP owns your soul, then sells it :P
12:48:08 <ph8> incomplete pastebin
12:48:29 <lisppaste2> ph8 pasted "How come (1) doesn't work when (2) does" at http://paste.lisp.org/display/33646
12:48:40 <monochrom> I use counting arguments too, but I do weighted counting.
12:48:44 <ph8> could anyone help me with that?
12:48:54 <ph8> it's my endaevour to get a debug 'print' inside the stripPunc function
12:49:03 <ph8> i just want to print what's being filtered, and what the final output is
12:49:08 <ph8> since it's not behaving as expected
12:49:48 <ph8> monochrom: PHP does own
12:50:14 <ph8> haskell server pages.. could be interesting
12:50:20 <monochrom> it has its merits
12:50:25 <lisppaste2> allbery_b annotated #33646 with "try this?" at http://paste.lisp.org/display/33646#1
12:50:27 <ph8> i just can't imagine FP being the future
12:50:32 <ph8> so often i get confused as hell with haskell
12:50:39 <ph8> admittedly i've only been learning it for a term and really coding it for about 4 days
12:50:45 <monochrom> the future is confusing too
12:50:45 <ph8> even then on and off :p
12:50:49 <ph8> vraiment
12:51:00 <allbery_b> oh, you want to print what's being filtered, not the result?
12:51:01 <_matthew_> driving on the right is confusing at first too
12:51:10 <allbery_b> also, take a look at Debug.Trace
12:52:06 <monochrom> Ten years ago if you held up a credit-card-sized thingie and claimed "this holds my entire collection of 1000 CDs" people would be confused.
12:52:23 <mgsloan> that's different though
12:52:36 <mgsloan> the people would be confused, but 5 minutes later they'd work it fine
12:52:43 <ph8> allbery_b: it means i have to deal with a load of this IO String bollocks
12:52:50 <ph8> which means changing loads of code
12:52:55 <ph8> for a simple debug echo
12:52:56 <monochrom> Five years go if you talked to Java coders about C++ templates they would be confused.
12:52:59 <allbery_b> yes, so look at Debug.Trace
12:53:12 <ph8> ah didn't see that
12:53:14 <ph8> will have a hoogle
12:53:19 <mgsloan> I'm afraid I agree - there's lots to learn from haskell, but its not the future
12:53:45 <ph8> thing is
12:53:45 <ph8> > stripPuncList :: [[Char]] -> [[Char]]
12:53:46 <ph8> > stripPuncList a = map stripPunc a
12:53:46 <lambdabot>  Not in scope: `stripPuncList'
12:53:46 <lambdabot>  Parse error
12:53:47 <dylan> it allows the future.
12:53:54 <mgsloan> right
12:53:54 <monochrom> Now we're going to have to talk to Java coders about closures next year.
12:54:07 <ph8> if i pass something like (["Foo", "bar"], ["Foo"])
12:54:10 <ph8> to stripPuncList
12:54:12 <ph8> sorry that's wrong
12:54:19 <ph8> if i pass something like ["Foo", "bar"]:=["Foo"]
12:54:21 <ph8> to stripPuncList
12:54:22 <mgsloan> i think any language of the future that has a chance of really improving things will take a lot of inspiration from haskell
12:54:42 <ph8> foo bar and the last foo should get stripped of punctuation right?
12:54:43 <monochrom> http://lambda-the-ultimate.org/node/1939
12:54:45 <lambdabot> Title: More Haskell in Java 7 or 8? | Lambda the Ultimate
12:54:48 <ph8> because the key doesn't appear to be atm
12:55:00 <ph8> monochrom: C# baby
12:55:06 <ph8> if it wasn't owned by microsoft i'd be in love
12:55:24 <monochrom> Haskell maybe is not the future, but Java and C# becoming more and more like Haskell is the immediate future.
12:55:45 <mgsloan> heh
12:55:45 <ph8> it's easier as systems become more powerful
12:55:46 * psnl shakes his head at ph8
12:56:02 <ph8> is that in reference to my punctuation stripping psnl?
12:56:06 <ph8> it's doing my head in :p
12:56:25 <mgsloan> C# is good, but the xml docs are rediculous, quite a bit of the API sucks (vast improvement over previous MS atrocities, though)
12:56:25 <augustss> C# is getting Haskell features, but it still lacks some essentials.
12:56:30 <mgsloan> yeah
12:56:49 <monochrom> Because the essentials are "confusing" :)
12:57:16 <augustss> monochrom: not only that, they also forgot to add the necessary stuff to .NET
12:57:18 <monochrom> I say it's just the Dark Age educational background getting into the way.
12:57:26 <mgsloan> might be quite good to have an imperative language with two types of functions - pure functions and imperative
12:57:26 <augustss> like higher kinded type variables
12:58:06 <mgsloan> I always get confused with that useage of "higher".  I say than what? :)
12:58:20 <mbishop> mgsloan: wouldn't that be like ocaml/scheme?
12:58:37 <mbishop> you COULD do "pure" functions if you wanted
12:58:57 <psnl> ph8: no, this time last year I would have said the same thing about haskell
12:59:07 <mgsloan> I mean use classical syntax for imperative, functional syntax for pure
12:59:17 <mgsloan> i dunno if ocaml does this or not
12:59:47 <mgsloan> i think ruby has a half hearted shot at this.  More like functional as a DSL in imperative though
13:00:03 <monochrom> I learned Haskell this way.  My brain is a versioning system.  I made a new branch to learn Haskell.  In the new branch I denounced all imperative and OO programming concepts.  Then Haskell made a lot of sense.  At the end I just needed to merge it back to the main trunk.
13:00:25 <mgsloan> hah. yeah I'm like that atm too
13:00:36 <augustss> the lack of higher kinded type variables in C# means,e.g., that they have the concept of monads, but they cannot abstract over monads.  so you can't write a function that works for any monad, just particular ones.
13:00:37 <dylan> haskell makes using anything else not fun.
13:00:38 <monochrom> I am obviously down-playing the "merge" part heh heh!
13:00:42 <ph8> oh my i'm such a fool
13:00:45 <ph8> punctuation stripping works
13:00:48 <ph8> i'm just a muppet :p
13:00:57 <mgsloan> I still haven't done the merge
13:01:47 <mgsloan> augustss: is that type parameters?
13:01:59 <ski> @type mapM
13:02:01 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
13:02:29 <monochrom> I upgraded the main trunk first, i.e., refactored and generalized the imperative and OO concepts a little bit.  Then the merge was elegant and pleasing.
13:02:40 <augustss> mgsloan: yes, type variables in C# can only range over ordinary types, not type constructors
13:03:16 <mgsloan> alright, so it's like * -> * instead of *
13:03:45 <monochrom> So the result is not just Haskell being beautiful but also imperative can be made beautiful.  It's joyful.
13:03:48 <augustss> and C# really has several monads, and cool monad comprehensions.  (they don't call it monads, of course)
13:03:58 <augustss> mgsloan: yes
13:04:17 <Heffalump> Haskell only has a few monads, but the ability to create your own :-)
13:04:34 <augustss> Heffalump: that's true in C# as well
13:04:38 <mgsloan> perhaps it'll make the haskell jump less difficult for those who learn linq
13:04:42 <Heffalump> augustss: ah, ok
13:05:05 <ski> augustss : hm, i assume monad transformers isn't possible in C#, then ?
13:05:15 <augustss> ski: no way
13:05:25 <jgrimes> aww
13:05:33 <Saizan> how do they call their monads in C#?
13:06:11 <Saizan> (or what is monad in C#)
13:06:15 <augustss> hmm, what are they called?  it's all the LINQ stuff.  it's some kind of collection
13:06:34 <jgrimes> yeah, I need to see an example of monads in C#
13:06:46 <augustss> you have to implement a certain interface
13:07:02 <lisppaste2> fabiim pasted "class method gives me an error : Cannot submit rigid variable a against inferred type " at http://paste.lisp.org/display/33648
13:07:21 <augustss> jgrimes: arrays is one example
13:08:39 <ski> nondeterminism ?
13:09:30 <augustss> all the C# (predefined) monads are containter-like
13:11:06 <Saizan> so, what can you do with the array monad?
13:12:09 <mgsloan> uh, aren't haskell monads mostly container like?
13:12:15 <ph8> ?type tails
13:12:17 <lambdabot> forall a. [a] -> [[a]]
13:12:19 <augustss> LINQ provides something similar to list comprehensions.  so you can map and filter the array
13:12:21 <ph8> should tails of a [[char]] produce a [[[char]]]?
13:12:34 <ph8> because that's what (tails myDoubleCharList) seems to be doing
13:12:36 <Saizan> isn't that more like functors?
13:12:36 <mgsloan> yes
13:12:39 <ph8> if hugs' type error is right
13:12:44 <mgsloan> tails returns each tail
13:12:47 <ph8> oh wait i didn't even look at the type :p
13:12:58 <ph8> sorry, misconception of the function :p
13:13:03 <ph8> is the tail all but the first element?
13:13:03 <ski> mgsloan : 'State s','IO','(r ->)','(o,)'
13:13:04 <ph8> or just the last?
13:13:15 <augustss> Saizan: no, it's more like monads :)
13:13:21 <Saizan> > tail [1..10]
13:13:23 <lambdabot>  [2,3,4,5,6,7,8,9,10]
13:13:27 <ski> fabiim : do you have 'instance Jogador Agente' ?
13:13:28 <ph8> danke
13:13:31 <mgsloan> ski - State just manages manipulations on one, contained object
13:13:40 * shapr kramar augustss 
13:13:50 <mgsloan> same goes for IO, except the object doesn't actually exist...
13:13:56 <mgsloan> and I don't know about the others :)
13:14:03 <fabiim> ski : yes
13:14:11 <Saizan> well map is in the Functor class :D
13:14:27 <ski> mgsloan : have you read 'MonadsAsContainers' attempt at seeing 'State s' as a container type ?
13:14:47 <mgsloan> nope
13:15:17 <ski> fabiim : the problem is that you have, in class 'Action', specified 'gereopcao :: forall a. Jogador a =>  t -> IO a' ..
13:15:34 <augustss> Saizan: yes, but you can do more than mapping with LINQ.  I'd have to look up the details to say exactly what
13:15:43 <Saizan> okok
13:16:16 <ski> fabiim : i.e. 'gereopcao' must be able to return *anything* in the 'Jogador' class
13:16:37 <ski> fabiim : but your code always decides to return something of type 'Agente'
13:17:27 <ski> if you have 'gereopcao :: forall a. Jogador a =>  t -> IO a', then the *caller* of 'gereopcao' gets to decide what type 'a' should be .. not the *callee* (i.e. body of 'gereopcao')
13:17:43 <ski> augustss : concat, i assume ?
13:18:06 <augustss> ski: yes
13:18:48 <augustss> they have renamed all operations into database lingo as well.  so map is called select, i think
13:19:08 <ski> right
13:19:24 <ph8> is head reverse string the fastest way to get the last character of a string?
13:19:44 <dmhouse> ph8: or last, yeah.
13:20:05 <dmhouse> It's necessarily O(n), but using last avoids the O(n) space, I guess.
13:20:07 <ski> fabiim : so either you have to change 'gereopcao' so it can (monadically) return any type 'a' in the 'Jogador' class that the caller wants it to return ..
13:20:12 <dmhouse> *necessarily O(n) time
13:20:15 <ph8> last <list> ?
13:20:18 <augustss> last should be slightly faster
13:20:24 <ph8> chrs
13:20:27 <dmhouse> ?type last
13:20:28 <lambdabot> forall a. [a] -> a
13:21:20 <ski> fabiim : or you have to change the type signature of 'gereopcao' so that the callee (i.e. 'gereopcao' itself), gets to decide which type 'a' (in 'Jogador' class) the monadically returned value should have
13:21:46 <ski> (fabiim : or you could fix 'a' to 'Agente' directly in the type signature .. or something else)
13:23:35 <fabiim> ski :  how can i do that ? ( 2nd option )
13:24:30 <rahikkala> Riiiight. ghci just started crashing on startup. I blame Windows :p. I'll reboot and see if that fixes things - they've got some awesome engineering in this OS considering how many things are usually fixed by rebooting :)
13:25:21 <ski> if we had existential quantifier in types one could do somthing like 'gereopcao :: t -> IO (exists a. Jogador a *> a)' . but we don't have that  (jhc can't handle this, i think)
13:25:56 <ski> another option is to CPS-transform, Church-style
13:26:27 <ski> gereopcao :: t -> (forall a. Jogador a => a -> IO r) -> IO r
13:26:55 <ski> the third way would be to make an existential wrapper datatype
13:27:07 <ski> gereopcao :: t -> IO SomeJogador
13:27:36 <ski> data SomeJogador = forall x. Jogador x => MkSomeJogador x
13:27:47 <ski> possibly the third way is simplest
13:28:35 <ski> (one can alternatively define 'SomeJogador' with GADT-syntax, like
13:28:39 <augustss> fabiim: I'd try adding 'a' as a second parameter to Action
13:28:40 <ski>  data SomeJogador
13:28:43 <ski>    where
13:28:57 <ski>   MkSomeJogador :: Jogador x => x -> SomeJogador
13:28:57 <ski> )
13:29:12 <augustss> and maybe a functional dependence from t to a.
13:29:33 <augustss> fabiim: it's hard to advice since we don't know exactly what your aim is
13:29:36 <ski> hm, that possibly be a better solution :)
13:30:38 <fabiim> what do you guy's mean? I can declare classes on 2 types ?
13:30:49 <augustss> fabiim: is the type t in Action related to what gereopcao returns?
13:31:07 <augustss> fabiim: yes, if you turn on that extension
13:31:26 <syntaxfree> why is this code written in portuguese?
13:31:27 <fabiim> yes , type t must contain some type of class (Jogador ( player in english ) )
13:32:10 <augustss> fabiim: so then I think a multiparameter type class might be the way to go
13:32:41 <fabiim> how can i do something like that?
13:33:48 <ski> fabiim : yes .. if you read 'Eq a' as "the type 'a' supports equality", then e.g. 'MonadState m s' could be read as "the monad 'm' provides state operations over the 's' state type"
13:34:39 <ski> fabiim : point being that a multi-parameter type class reads as a relation between types .. just as a single-parameter type class (the ordinary kind) reads as a property of types
13:34:40 <zeeeee> benja_: hi, i was thinking some more about that code you posted yesterday, and it dawned on me that the way to deal with multiple types was not to use a list, but perhaps to use >>... does this mean, then, i should be writing my own monad? perhaps there already exists a monad for conds and cases?
13:34:40 * SamB has written a small raytracer ;-)
13:34:53 <syntaxfree> "This arrangement is by no means unique to Lisp; it's called a singly linked list. However, few languages outside the Lisp family provide such extensive support for this humble data type."
13:35:00 <dmhouse> :)
13:35:02 <Vq^> SamB: nice
13:35:04 <syntaxfree> why? Lifo stacks are so useful for so many things.
13:35:18 <syntaxfree> C doesn't have singly-linked lists?
13:35:20 <ski> sorear : regarding 'mfix'
13:35:23 <ski> > take 10 `fmap` mfix (\xs -> Just (0 : map (1+) xs))
13:35:25 <lambdabot>  Just [0,1,2,3,4,5,6,7,8,9]
13:35:26 <ski> > take 10 `map` mfix (\xs -> [[42..47],0 : map (1+) xs,[7], 1 : map (2*) xs])
13:35:27 <lambdabot>  [[42,43,44,45,46,47],[0,1,2,3,4,5,6,7,8,9],[7],[1,2,4,8,16,32,64,128,256,512]]
13:35:33 <lisppaste2> augustss annotated #33648 with "multiparam" at http://paste.lisp.org/display/33648#1
13:35:39 <dmhouse> syntaxfree: surely any language with objects and pointers has linked lists.
13:35:52 <SamB> mind you, right now it only shoots primary rays and outputs the fractional part of the surface normals in ppm format
13:35:55 <ph8> | ((findWithDefault [] needle haystackMap) == []) = (genNext (padKey (tail needle)) haystackMap)
13:36:03 <ph8> that equality test's alright, right? it never seems to get triggered
13:36:04 <augustss> oops, I lost the connection.  (we're approaching New York and the plane was turning)
13:36:41 <ph8> the idea being, if no match is found the function is called with a padded version of needle
13:36:42 <ph8> oooo
13:36:48 <ph8> which means needle never ends
13:36:49 <glguy> > M.findWithDefault 0 undefined M.empty
13:36:50 <lambdabot>  Add a type signature
13:36:55 <SamB> well, C doesn't do generic linked lists
13:37:03 <ph8> i might have just figured it out myself again :/
13:37:04 <Heffalump> augustss: what are you IRCing from?
13:37:07 <glguy> > M.findWithDefault 0 undefined M.empty :: Data.Map.Map Int Int
13:37:08 <lambdabot>  Not in scope: type constructor or class `Data.Map.Map'
13:37:12 <ph8> it helps to say it outloud, i might find an empty channel to talk to myself in :)
13:37:26 <SamB> and doesn't come with facilities for them...
13:37:28 <augustss> Heffalump: flight LH410, Munich-JFK
13:37:33 <ph8> is there a way to say "if, all elements in needle == [""]" ?
13:37:46 <Heffalump> wow :-) Satellite phone?
13:37:47 <augustss> Heffalump: using the wireless network on board
13:37:56 <Heffalump> oh, nice.
13:37:57 <augustss> Heffalump: satellite internet
13:38:12 <ski> ph8 : 'all ([""] ==) needle'
13:38:12 <ph8> could i map a function that returns a bool across it  and will the results be suitably &&'ed together?
13:38:17 <ph8> ah sexy
13:38:20 <ph8> that's where haskell comes into it's own
13:38:24 <ski> which is same as
13:38:27 <augustss> Heffalump: very nice, but they are shutting down at the end of the year.  not enough profit
13:38:33 <ski> and (map ([""] ==) needle)
13:38:35 <ph8> and is | the or symbol or ||?
13:38:37 <Heffalump> ah. :-(
13:38:43 <ski> @type (&&)
13:38:45 <Heffalump> how much do they charge?
13:38:45 <lambdabot> Bool -> Bool -> Bool
13:38:45 <ski> @type and
13:38:47 <lambdabot> [Bool] -> Bool
13:38:51 <ph8> @type ||
13:38:52 <lambdabot> parse error on input `||'
13:38:53 <SamB> @type (||)
13:38:54 <ph8> @type |
13:38:55 <lambdabot> Bool -> Bool -> Bool
13:38:56 <lambdabot> parse error on input `|'
13:38:57 <ph8> chrs
13:39:03 <ski> @type all
13:39:06 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
13:39:07 <ski> @type any
13:39:08 <fabiim> well that's seem way over my head right now , i guess i'll go the ugly way : gereopcao :: t -> Agente , thanks anyway =)
13:39:11 <augustss> Heffalump: it used to be $25 for the flight.  it's been free the last month (since they are shutting down)
13:39:11 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
13:39:31 <SamB> who is shutting down?
13:39:44 <augustss> SamB: Connexion by Boing
13:40:15 <shapr> Argh, is any one willing to spare an Oleg of clue? Why does this fail in ghc6.6? --> hUnproxyLabel l (v::v) r = hUpdateAtLabel l v r where (_::Proxy v) = hLookupByLabel l r
13:40:48 <augustss> shapr: not sure we can produce all of an Oleg here
13:40:57 * shapr laughs
13:41:15 <shapr> The HList repo on darcs.haskell.org won't compile for me.
13:41:17 <shapr> So I'm trying to fix it.
13:41:39 <augustss> shapr: have you turned on all the dangerous ghc extensions?
13:41:57 * Heffalump finds some links suggesting the airlines are hoping to rescue it
13:41:59 <ibid> isn't that the code's job
13:42:20 <lisppaste2> shapr pasted "v::v" at http://paste.lisp.org/display/33649
13:42:27 <SamB> shapr: do you mean a centi-oleg?
13:42:39 <augustss> Heffalump: yes, i bet LH wants to rescue it.  they have equipment installed in almost all their long haul fleet now
13:43:04 <shapr> SamB: (v::v) seems to have been legal code in HList at some point. That scares me.
13:43:14 <lisppaste2> ph8 pasted "Doesn't ever ["Error"] ???" at http://paste.lisp.org/display/33651
13:43:33 <SamB> btw, SI says that you don't capitalize the full names of units that are named after people...
13:43:33 <shapr> Doesn't that mean that the type of a value is the same?
13:43:33 <augustss> shapr: ah, yes.  scoped type variables have changed.
13:43:35 <sorear> v :: v -- uh, -fscoped-type-signatures?
13:43:48 <SamB> shapr: no!
13:44:06 <SamB> it just means they have the same name
13:44:14 <SamB> (in human terms)
13:44:18 <shapr> sorear: Is that a real opt?
13:44:26 <SamB> it shoudl be!
13:44:33 <SamB> well. there is one like that
13:44:34 <sorear> I want it to be!
13:44:52 <sorear> if that fails -fglasgow-exts
13:44:55 <SamB> -fscoped-type-variables
13:45:01 <sorear> (but I'm sure you tried that)
13:45:06 <shapr> yup
13:45:19 <sorear> start ghci, type :set -f, and press TAB
13:45:20 * ski had some strange example of a recursive type signature some while back ..
13:45:22 <shapr> Neithor -fscoped-type-signatures nor -fscoped-type-variables works.
13:45:39 <shapr> I don't get tab completion in emacs-ghci
13:45:40 <SamB> I'm pretty sure -fglasgow-exts doesn't enable that one because it would choke on valid Haskell 98
13:45:43 <augustss> shapr: you need to change the code.  bring v into scope some other way
13:45:43 <sorear> that'll give you a nice list of valid options
13:45:53 <sorear> shapr: i know :(
13:46:03 <shapr> augustss: See, that's where I need an Oleg of clue :-)
13:46:04 <sorear> it works on the linux-console though
13:46:04 <augustss> shapr: can you paste the surrounding code?
13:46:26 <lisppaste2> shapr pasted "whole chunk of code" at http://paste.lisp.org/display/33652
13:46:53 <shapr> Do you want all of GhcRecord.hs from the HList repo?
13:47:20 <augustss> shapr: you should give hUnproxyLabel a type signature with an explicit forall.  that will bind v
13:47:34 <ski> (shapr : hm, no paste annotation ?)
13:47:35 <augustss> and then replace (v::v) by v
13:47:47 <SamB> augustss: how is that going to work?
13:47:59 <ski> shapr : do you have a type signature for 'hUnproxyLabel' ?
13:49:02 <ski> SamB : it's a strange feature in ghc
13:49:49 <shapr> ski: No, I can't get it to typecheck.
13:49:54 <zeeeee> help, how do i fix this simple parsec code so that it parses "abc\ndef\n\nghi" as [[abc,def],[ghi]]? object = many1 letter `sepBy` newline; objects = object `sepBy` (newline >> newline)
13:50:21 <zeeeee> i don't know how to make 'try' and 'sepBy' work together
13:50:46 <SamB> I think you need to go back to an earlier version of GHC, get the code to load, :type hUnproxyLabel, then paste that into the file and try it again in the version you are using now
13:52:57 <ph8> ph8 pasted "Doesn't ever ["Error"] ???" at http://paste.lisp.org/display/33651 <-- can anyone tell me what's going wrong with that reduction? padKey turns ["string"] into ["", "string"] if necessary
13:53:03 <ph8> since the key length must be constant
13:55:08 <monochrom> zeeeee: I'll need a few minutes to investigate.
13:55:35 <ski> ph8 : what if you pass '[]' or '["","",""]' as first argument to 'genNext' ?
13:56:13 <ph8> then the guard that = ["Error"] should catch it/
13:56:34 <ph8> that's exactly the circumstance i'm trying to accomodate
13:56:37 <ph8> is something awry?
13:56:59 <ski> but does it catch it, or not ?
13:57:49 <ski> btw, '((needle == []) || (all (""==) needle))' can be simplified to 'all null needle'
13:59:49 <monochrom> I hate it when the emacs haskell-mode uses hugs.  Who uses hugs?  Everyone uses ghci.
14:00:09 <ibid> iirc it can use either; it's configurable
14:00:42 <monochrom> Yes I know.
14:01:36 * ski uses hugs and ghci
14:01:51 <ph8> cheers ski
14:01:53 <ph8> but it appears not too
14:01:58 <ph8> since error never gets returned
14:02:09 <zeeeee> monochrom: any luck :)
14:02:20 <ph8> >		let result = genNext genWords theMap
14:02:20 <ph8> >		putStrLn ("Done - " ++ show result)
14:02:22 <ph8> done never appears
14:02:26 <zeeeee> monochrom: i think the variable to set was:
14:02:46 <zeeeee> (setq haskell-program-name "ghci -fglasgow-exts")
14:03:39 <glguy> ?docs Data.ByteString
14:03:40 <lambdabot> Data.ByteString not available
14:03:48 <glguy> ?docs Data.Char
14:03:48 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Char.html
14:03:55 <ski> ph8 : maybe something before that is not working ?
14:04:40 <ph8> well genNext worked before i made it ever-reducing
14:04:49 <ph8> that's when it was just = ((findWithDefault [] needle haystackMap)
14:05:34 <ski> strange
14:05:48 <ski> wb augustss
14:05:52 <dylan> @dice 200d300
14:05:52 <lambdabot> 200d300 => 30674
14:06:14 <ph8> yes :/
14:06:34 <glguy> What would the most efficient way be to do this with Data.ByteString? liftM (map read . words) getLine ?
14:06:36 <augustss> ski: ty
14:06:44 <SamB> @dice 5d1
14:06:44 <lambdabot> 5d1 => 5
14:06:47 <SamB> @dice 5d1
14:06:48 <lambdabot> 5d1 => 5
14:06:49 <monochrom> (many1 letter `sepBy` newline) wants to eventually run into something neither (many1 letter) nor (newline).
14:06:50 <glguy> i know that Data.ByteString.getLien exists
14:06:51 <SamB> hmm.
14:07:39 <monochrom> perhaps we shall change (newline) into "one newline but not two newlines"
14:08:09 <ph8> ski: think the complete code would help?
14:08:12 <zeeeee> hmm
14:08:17 <ph8> i don't think anything else is affecting it though
14:09:16 <zeeeee> monochrom: yeah, i think it's because there's no backtracking; i just wasn't sure how to mix 'try' in here
14:09:29 <ph8> i can't add debug without adding loads of io stuff in can i?
14:09:41 <sorear> ?hoogle trace
14:09:41 <lambdabot> Debug.Trace.trace :: String -> a -> a
14:09:42 <lambdabot> Debug.Trace :: module
14:09:42 <lambdabot> Debug.Trace.putTraceMsg :: String -> IO ()
14:09:44 <ski> *Main> genNext [] undefined
14:09:44 <ski> ["Error"]
14:09:44 <ski> *Main> genNext ["","",""] undefined
14:09:44 <ski> ["Error"]
14:09:47 <allbery_b> :t Debug.Trace.trace
14:09:50 <allbery_b> heh
14:09:53 <lambdabot> forall a. String -> a -> a
14:09:54 <ski> ph8 : seemed to work here
14:10:08 <ski> ph8 : try those two examples in hugs / ghci
14:10:18 <allbery_b> note there is no IO there (it does evil in the background, with some protections)
14:10:57 <ph8> k
14:11:28 <ph8> ok ski
14:11:30 <ph8> those two work the same
14:11:32 <ph8> on my PC
14:11:37 <monochrom> (try (newline >> notFollowedBy newline))
14:11:45 <ski> ph8 : so the problem lies elsewhere, then ..
14:11:49 <ph8> hmm
14:11:51 <ph8> indeed
14:11:55 <zeeeee> monochrom: where does that o?
14:11:55 <ph8> i'd love an echo at each stage
14:11:56 <zeeeee> *go
14:12:09 <monochrom> many1 letter `sepBy` (try (newline >> notFollowedBy newline))
14:12:18 <ph8> so i can make it a | findWith... ) do Debug.Trace; = findWith...
14:12:25 <ph8> without having to add io rubbish?
14:12:35 <ph8> what's the 2nd arg in trace?
14:12:43 <zeeeee> monochrom: ooh, yay! closer
14:12:50 <monochrom> Success!
14:12:52 <ski> | findWith... = do Debug.Trace "foo !" (findWith...)
14:13:05 <ski> s/do //
14:13:37 <zeeeee> monochrom: well... :) i ultimately would like a parser that can parse something like "abc\n def \n \n \nghi\n \n" as the same thing
14:13:41 <ski> | findWith... = Debug.Trace.trace ("needle is " ++ show needle) (findWith...)
14:13:47 <ski> ph8 : like that
14:13:54 <zeeeee> one step at a time, i guess...
14:13:57 <ph8> danke
14:14:39 <monochrom> perhaps s/newline/(many space >> newline >> many space)
14:14:47 <ski> (ph8 : you wrap 'Debug.Trace.trace (..some trace message..)' around an expression)
14:15:45 <monochrom> Now I am going to beat up haskell-mode real hard.
14:15:55 <ph8> muwaha
14:15:55 <ph8> needle is ["","foo"]
14:15:55 <ph8> needle is ["","foo"]
14:15:55 <ph8> needle is ["","foo"]
14:15:56 <ph8> for ever
14:15:58 <ph8> it appears
14:16:10 <ph8> obviously only if the search fails first time
14:16:43 <ski> ph8 : how does your 'padKey' look like ?
14:17:18 <lisppaste2> ph8 pasted "padkey" at http://paste.lisp.org/display/33653
14:17:45 <ski> (ph8 : next time you can annotate the previous paste ..)
14:17:51 <ph8> ah ofc
14:19:02 <ski> and 'gramSize' is '2', yes ?
14:19:10 <ph8> gramsize is 3
14:19:16 <ph8> for the moment at least
14:19:16 <ski> ok
14:19:20 <ph8> which means keys of size 2
14:20:07 <syntaxfree> oh boy. I'm getting depressed.
14:21:30 <ph8> ski
14:21:35 <ph8> i'm with the program
14:21:39 <ph8> it'll continally tail foo
14:21:44 <ph8> it'll continally tail "", foo
14:21:44 <ph8> even
14:21:49 <ph8> which means "", foo will get produced
14:21:59 <ski> yes
14:22:12 <ph8> bugger.
14:22:13 <ski> ah
14:22:16 <ski> i see
14:22:21 <ph8> custom tailing function to fix? :/
14:22:41 <zeeeee> is there a way in parsec to specify 'x `except` y'? (eg 'space `except` newline')
14:22:52 <ski> > dropWhile null ["","","","foo","bar"]
14:22:54 <lambdabot>  ["foo","bar"]
14:22:56 <ski> use that
14:24:10 <ph8> before the tail?
14:24:12 <ski> zeeeee : can that 'space' parser parse a newline ?
14:24:21 <ski> ph8 : instead of the 'tail'
14:24:21 <ph8> that raises the question is the tail of ["foo"] [] or ["foo"]
14:24:32 <ski> er
14:24:35 <ski> actually
14:24:46 <ski> > tail (dropWhile null ["","","","foo","bar"])
14:24:47 <lambdabot>  ["bar"]
14:24:56 <ski> so, yes, before the 'tail'
14:25:17 <ski> > tail (dropWhile null ["","","","","bar"])
14:25:18 <lambdabot>  []
14:26:14 <ph8> Showing ["near","foo"]
14:26:14 <ph8> needle is ["near","foo"]
14:26:14 <ph8> needle is ["","foo"]
14:26:14 <ph8> Done - ["Error"]
14:26:15 <ph8> hmmm
14:26:16 <ph8> sort of progress
14:26:19 <ph8> sorry for paste spam
14:28:17 <zeeeee> ski: the point is to not parse a newline
14:28:26 <zeeeee> ski: (yeah it can)
14:30:55 <lisppaste2> zeeeee pasted "help writing super-simple parsec parser" at http://paste.lisp.org/display/33655
14:31:20 <ski> notFollowedBy newline >> space
14:31:23 <ski> maybe that ?
14:31:25 <zeeeee> anybody have an idea about that error?
14:31:42 <zeeeee> ski: oh...let me try that
14:32:41 <zeeeee> ski: yay, that worked
14:33:27 <zeeeee> i still get this strange error about 'many', though - i don't understand the error
14:35:21 <dmhouse> zeeeee: if you do many p, and p can match on an empty string, then you have a problem.
14:35:45 <zeeeee> dmhouse: i just realized that...i'm not sure how to rewrite that
14:38:03 <zeeeee> this parser is pretty simple when expressed as: GenUtil.tokens (null . Data.String.strip) . lines
14:41:00 <ph8> ok
14:41:34 <ph8> what's the best way to get the first 9 items, of a 10 item list, reverse list . tail . reverse $?
14:41:40 <ph8> or something like that that works?
14:41:55 <dmhouse> ph8: take 9?
14:41:55 <allbery_b> > take 9 [..20]
14:41:55 <lambdabot>  Parse error
14:41:59 <ph8> ofc :p
14:41:59 <allbery_b> oops
14:42:02 <ph8> ty
14:42:08 <allbery_b> > take 9 [1..20]
14:42:09 <lambdabot>  [1,2,3,4,5,6,7,8,9]
14:42:10 <ph8> so many prelude functions
14:42:19 <dmhouse> ph8: in general, init takes all but the last element of a list.
14:42:31 <ski> > init [0..9]
14:42:32 <lambdabot>  [0,1,2,3,4,5,6,7,8]
14:42:35 <dmhouse> head is to tail as init is to last.
14:42:40 <ski> ph8 : ^^
14:42:44 <dmhouse> Remember those four.
14:43:04 <ski> > tail [0..9]
14:43:05 <lambdabot>  [1,2,3,4,5,6,7,8,9]
14:43:07 <ski> > inits [0..9]
14:43:09 <lambdabot>  [[],[0],[0,1],[0,1,2],[0,1,2,3],[0,1,2,3,4],[0,1,2,3,4,5],[0,1,2,3,4,5,6],[0...
14:43:10 <ski> > tails [0..9]
14:43:12 <lambdabot>  [[0,1,2,3,4,5,6,7,8,9],[1,2,3,4,5,6,7,8,9],[2,3,4,5,6,7,8,9],[3,4,5,6,7,8,9]...
14:43:21 <syntaxfree> 7:53 PM  monochrom: I hate it when the emacs haskell-mode uses hugs.  Who uses hugs?  Everyone uses ghci.
14:43:29 <dmhouse> ph8: Open up GHCi, and type :b Data.List. That's a nice summary of the list functions you might want.
14:43:29 <syntaxfree> yes. What is hugs good for, these days?
14:43:39 <monochrom> newbies
14:43:40 <dmhouse> syntaxfree: Windows.
14:43:48 <monochrom> windows newbies
14:43:58 <syntaxfree> why?
14:44:00 * dmhouse <3 WinHugs
14:44:31 <dmhouse> WinHugs, certainly, is Windowsified (in terms of its look'n'feel).
14:44:45 <emu> um, emacs haskell-mode works fine with ghci
14:44:50 <dmhouse> It also supports nice things like automatically reloading your files when they change, which makes the edit-compile loop a bit quicker.
14:45:05 <dmhouse> Yes, I use haskell-ghci.el.
14:45:44 <syntaxfree> nor ghci nor hugs have a nice REPL.
14:45:53 <syntaxfree> One wrong function, and you don't have access to the rest!
14:45:57 <emu> i work at their repl all the time
14:45:59 <syntaxfree> You're forced to resort to commenting out.
14:46:01 <emu> its a different thing than lisp
14:46:13 <emu> due to the static type nature
14:46:19 <dmhouse> syntaxfree: erm, or fix the function?
14:46:23 <syntaxfree> it should me more ammenable to partial compilation than Lisp, given referential transparency.
14:46:29 <dmhouse> If you don't want to write the function right now, undefined.
14:46:45 <emu> it would be nice if it was better at handling that.  i get by with inserting "undefined" in stubs
14:46:45 <dmhouse> Lots of undefined everywhere is a nice top-down programming style.
14:46:56 <monochrom> Why do I keep creating World War III  :D
14:47:33 <emu> it would also be nice to return to a previous, consistent, version of the current module rather than dumping it entirely when there is an error
14:47:44 <emu> one of these days i may even look into fixing these things...
14:47:47 <dmhouse> Yes.
14:47:48 <syntaxfree> emu: that, too.
14:47:59 <dmhouse> I hate how if you have one error it dumps _all_ your modules, as well.
14:48:17 <emu> but there is a fundamental issue which i explored a number of years ago standing in the way: generativity of types
14:48:42 <emu> in Lisp, type identity is controlled by name alone, and is reconciled on-the-fly
14:48:45 <Botje> assignment would be nice, too
14:48:50 <emu> let works
14:49:00 <Botje> but it doesn't stick, does it?
14:49:20 <daniel_larsson> Depends what you mean by stick
14:49:25 <emu> in H-M type systems, every time you define a data type, it gets a fresh identifier -- no matter if it has the same name as a previously defined one
14:49:30 <syntaxfree> emu: well, yes. But can't the interpreter load the functions that work, ignoring those that don't?
14:49:32 <Botje> :set x = <complicated expression you want to examine>
14:50:30 <emu> syntaxfree: this would require (a) a smart parser capable of recovering from syntax errors gracefully (b) a smart type checker capable of the same (c) defined semantics for what to do in case parts of the system needed by others don't get loaded
14:50:48 <ski> Botje : in ghci you can 'let x = ...'
14:50:59 <emu> and you would have to confront the generativity of types
14:51:05 <daniel_larsson> # let a = 5
14:51:05 <daniel_larsson> # a
14:51:05 <daniel_larsson> 5
14:51:05 <allbery_b> does it last past :r though?
14:51:08 <Botje> ah, i was trying in hugs
14:51:09 <Botje> nm then :)
14:51:12 <syntaxfree> emu: um, can't you just ignore functions that reference functions that aren't loaded?
14:51:36 <daniel_larsson> allbery_b: nope
14:51:45 <ph8> ski: i'll pastebin the final product
14:51:47 <ph8> it looks fugly
14:51:48 <ph8> but works:p
14:51:55 <emu> syntaxfree: when you load the file, all the functions will have different types from the previous versoins
14:52:08 <trh> > let z = 5 in z * z
14:52:09 <lambdabot>  25
14:52:10 <Botje> ph8: but haskell is not made to look fugly!
14:52:12 <lisppaste2> ph8 annotated #33653 with "the final padkey" at http://paste.lisp.org/display/33653#1
14:52:27 <ph8> see ^ :p
14:52:27 <syntaxfree> emu: ah, yes. Just ignore the previous versions.
14:52:33 <syntaxfree> But load the part of the file that works!
14:52:39 <ph8> haskell is definitely made to look fugly
14:52:40 <emu> hs-plugins though, seems to have some of these issues taken care of, so i will be taking a look at it sometime
14:52:45 <ph8> .lhs anyway
14:52:50 <ph8> commenting as you go is next to impossible
14:52:50 <trh> > let arr = listArray ((1,5),(1,5)) [0,0..] in arr ! (2,2)
14:52:52 <lambdabot>  Exception: Error in array index
14:52:55 <ph8> without having ridiculous amounts of whitepsace :p
14:52:57 <ph8>  whitespace
14:53:03 <trh> Dammit.
14:53:08 <syntaxfree> I don't use layout. I always get it wrong.
14:53:21 <daniel_larsson> emacs-mode...
14:53:36 <syntaxfree> well, I do use indentation and all, but I always use explicit brackets and semicolons.
14:53:42 <dmhouse> Eww.
14:53:48 <Botje> ph8: reverse ( take ... ) reverse a ? why not just drop n a ?
14:54:02 <Botje> well, drop (gramsize-1) a
14:54:11 <dmhouse> ph8: I think Haskell is one of the most beautiful looking languages out there. Literate Haskell is awful, though. :)
14:54:20 <ski> ph8 : '((findWithDefault [] (padKey needle) haystackMap) == [])' can be written as 'null (findWithDefault [] (padKey needle) haystackMap)'
14:54:47 <trh> Can anyone help me quickly with multidimensional arrays?
14:54:49 <Botje> ph8: do you need to pad at the beginning?
14:55:07 <norpan> trh: just use (Int, Int) as index type
14:55:13 <trh> I thought the following should work:
14:55:15 <trh> > let arr = listArray ((1,5),(1,5)) [0,0..] in arr ! (2,2)
14:55:16 <lambdabot>  Exception: Error in array index
14:55:19 <xerox> ski rocks.
14:55:20 <dmhouse> ph8: you know about Data.Map.member, right?
14:55:43 <norpan> trh: (1,5) to (1,5) does not contain (2,2)
14:55:45 <emu> trh: (1,1),(5,5)
14:55:55 <allbery_b> try using the latexy one instead of > mumble?
14:55:55 <Botje> ph8: if not, you can do take (gramSize-1) $ a ++ repeat ""
14:56:02 <ph8> dmhouse: what's that then?
14:56:04 <ph8> Botje: yes
14:56:13 <ph8> eventually the whole thing will whittle down to just [""]
14:56:19 <ph8> which will match with the beginning of a sentence
14:56:21 <Botje> oh
14:56:25 <ph8> eventually
14:56:27 <Botje> :)
14:56:32 <dmhouse> ph8: it seems like you're trying to find out whether padKey needle is a key for some item in haystackMap.
14:56:35 <norpan> > let arr = listArray ((1,1),(5,5)) [0,0..] in arr ! (2,2)
14:56:37 <lambdabot>  0
14:56:40 <ph8> i am dmhouse
14:56:48 <norpan> > let arr = listArray ((1,1),(5,5)) [0,1..] in arr ! (2,2)
14:56:50 <lambdabot>  6
14:56:51 <ph8> ?type Data.map.member
14:56:52 <lambdabot> Couldn't find qualified module.
14:56:53 <ph8> ?type Data.Map.member
14:56:55 <lambdabot> forall a k. (Ord k) => k -> Data.Map.Map k a -> Bool
14:56:55 <syntaxfree> Using {- -} comments is less trouble than using Literate Haskell anyway.
14:57:03 <trh> Ahh, right!  Thanks!
14:57:04 <ph8> i have to unfortunately
14:57:09 <emu> i'm enjoying latex-lhs though, makes code look all pretty
14:57:13 <ph8> so you think i can > -- in lhs?
14:57:23 <emu> ph8: you can
14:57:24 <lisppaste2> ski annotated #33653 with "prettier" at http://paste.lisp.org/display/33653#2
14:58:05 * ph8 humps ski
14:58:08 <ph8> oh nice
14:58:13 <ph8> i might do that for my in-function commenting at least
14:59:21 <dmhouse> Actually, I think findWithDefault [] is just the same as lookup.
14:59:22 <syntaxfree> latex-lhs is nice in that you get to compile your articles.
14:59:33 <syntaxfree> >-mode lhs is just pointless.
14:59:36 <ph8> can i have multiple things in the where?
14:59:36 <dmhouse> As lookup fails in an arbitrary monad, and fail in the list monad is [].
14:59:48 <ph8> like on the line below where it has result =
14:59:51 <ph8> could i have foobar = ?
14:59:55 <Botje> of course
14:59:58 <ph8> coolio
15:03:45 <ski> dmhouse : but the result shouldn't be monadic there .. '[String]' is the type of values in the association map
15:04:07 <metaperl> per http://www.haskell.org/haskellwiki/Monads_as_Containers we read <quote>The list monad, in some sense, models computations which could return any number of values. Bind pumps values in, and catches all the values output.</quote> ... now of course wondering minds are wondering what happens if you simply want to map across all values in a monad without having join squish them all together... is there a way to derive map from return and
15:04:09 <lambdabot> Title: Monads as containers - HaskellWiki
15:04:57 <ski> ".. to derive map from return and" <- cut off
15:05:07 <metaperl> oh ok
15:05:15 <metaperl> is there a way to derive map from return and bind and use it to get "isolated " values
15:05:28 <metaperl> ski - what IRC client do you use?
15:06:28 <metaperl> I will email Cale about this
15:06:48 <shapr> SHAZAM!
15:07:29 <ski> metaperl : irssi
15:07:29 <metaperl> I see that shapr's sugar binge is having after-effects :)
15:07:38 * nmessenger is turned into CAPTAIN LAMBDA!
15:07:42 <metaperl> lol
15:08:16 <ski> metaperl : 'liftM' is 'fmap' (i.e. 'map', in the list monad case), for monads
15:08:31 <metaperl> oh ok. I will keep reading. he gets to that
15:08:40 <ski> (dunno what 'use it to get "isolated " values' means)
15:08:50 <metaperl> map creates isolated values
15:08:53 <metaperl> @type map
15:08:54 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
15:09:01 <metaperl> actually it doesnt
15:09:28 <nmessenger> ?type liftM
15:09:29 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
15:09:34 <metaperl> here's what I mean type-wise     do_thang :: [a] -> (a -> [b]) -> [ [ b ] ]
15:09:54 <xerox> ?hoogle fixM
15:09:56 <lambdabot> No matches found
15:09:56 * metaperl consults hoogle
15:09:59 <xerox> ?hoogle mfix
15:10:00 <lambdabot> Control.Monad.Fix.mfix :: MonadFix m => (a -> m a) -> m a
15:11:05 <metaperl> there is no such thing as my do_thang
15:11:16 <metaperl> do_thang :: [a] -> (a -> [b]) -> [ [ b ] ]
15:11:37 <metaperl> @type map
15:11:38 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
15:11:50 <xerox> ?type \x -> mfix (\mu -> x `mapM` ($ mu))
15:11:52 <lambdabot>   Expecting a function type, but found `[a]'
15:11:52 <lambdabot>    Expected type: [a]
15:11:53 <metaperl> oh , if = [b] then map works
15:12:02 <metaperl> if b = [b] then map works
15:12:19 <olliej> ?seen tautological
15:12:20 <lambdabot> I haven't seen tautological.
15:12:24 <olliej> ?seen tautilogical
15:12:25 <lambdabot> I haven't seen tautilogical.
15:12:28 <olliej> :-/
15:12:38 <metaperl> seen Madonna
15:12:54 <olliej> ?seen tautologico
15:12:54 <lambdabot> I saw tautologico leaving #haskell 1d 17h 19m 44s ago, and .
15:13:00 <olliej> :-/
15:14:18 <MarcWeber> fix f = let x = f x in x  <<< When does this function return ?
15:14:41 <emu> > fix (1:)
15:14:42 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
15:14:56 <metaperl> take 5 $ fix (1:)
15:15:13 <metaperl> zip [5..7] (fix (1:))
15:15:21 <metaperl> > zip [5..7] (fix (1:))
15:15:22 <lambdabot>  [(5,1),(6,1),(7,1)]
15:15:41 <metaperl> @type zip [5..7] (fix (1:))
15:15:43 <lambdabot> forall a b. (Num a, Enum a, Num b) => [(a, b)]
15:15:43 <shapr> metaperl, nmessenger: You guys need MORE SUGAR!
15:15:52 <MarcWeber> can I kill lambdabot by querying the result of fix (*2) ? ghci showd an stack overflow..
15:15:54 <nmessenger> SUGAR YAY!
15:15:58 <metaperl> is shapr lambdabot in disguise?
15:16:02 <metaperl> I think so
15:16:17 <metaperl> @type fix
15:16:19 <lambdabot> forall a. (a -> a) -> a
15:16:23 <metaperl> quick shapr answer :)
15:16:23 <shapr> Bob Barker let me host THE PRICE IS RIGHT! YOW!
15:16:28 <emu> @yow
15:16:28 <lambdabot> I smell a RANCID CORN DOG!
15:16:29 <metaperl> lol
15:16:50 <emu> > fix (*2)
15:16:52 <lambdabot>  Exception: <<loop>>
15:16:57 * metaperl departs
15:17:06 <MarcWeber> emu: Thanks. This example did help me. But why not just use repeat 1 ?
15:17:15 <shapr> YOW! Simon Peyton-Jones called me a spineless machine something!
15:17:21 <emu> MarcWeber: well, if i did want a repeatign list of 1s, sure
15:17:44 <emu> MarcWeber: but fix is more general: it allows you to construct any recursive function
15:19:47 * metaperl calls the DEA to have all the sugar confiscated from shapr's abode
15:20:04 * metaperl departs
15:20:30 <nmessenger> GRBLPHMBPIPLGOKIDDYRABPBP!
15:20:48 * shapr infiltrates the DEA
15:21:11 <shapr> I always wonder about those people who join the channel for a second and then leave.
15:21:22 <shapr> Maybe their attention span is smaller than mine?
15:21:37 <ski> metaperl : do you mean you want to preserve the nested lists in result of 'do_thang :: [a] -> (a -> [b]) -> [ [ b ] ]', instead of concatenating them ?
15:21:53 <nmessenger> shapr: Or maybe pf_moore works for the DEA? :)
15:21:57 <shapr> uh oh
15:22:03 <metaperl> yes, bind done without join doing it's m (m a) -> m a
15:22:09 * metaperl must depart soon
15:22:17 <lisppaste2> paolino pasted "straigth cluster" at http://paste.lisp.org/display/33661
15:22:32 <ski> metaperl : you can always use 'pam' instead of '(>>=)' ..
15:22:46 <metaperl> I am not a womanizer
15:22:51 <nmessenger> metaperl: pam = flip map
15:22:53 <metaperl> I refuse to use pam
15:22:55 <shapr> metaperl:  I am!
15:23:04 <metaperl> lol... thou art the son of sam
15:23:06 <shapr> I'm an unsuccessful womanizer. :-|
15:23:14 <metaperl> @type pam
15:23:15 <lambdabot> Not in scope: `pam'
15:23:23 <nmessenger> @index pam
15:23:23 <lambdabot> bzzt
15:23:27 * metaperl departs.... REALLY
15:23:28 <MarcWeber> emu: He, it's somehting like  (last . iterate)  f ;-)
15:23:33 <ski> @type let pam = flip map in pam
15:23:35 <lambdabot> forall a b. [a] -> (a -> b) -> [b]
15:23:48 <emu> > fix (\f n -> if n < 2 then 1 else n * f (n - 1)) 10
15:23:50 <lambdabot>  3628800
15:24:12 <nmessenger> in this case b is [a], for what you wnat
15:24:16 <nmessenger> *want
15:24:29 <ski> [0,1,2,3] >>= \x ->
15:24:29 <ski> [100,200] >>= \y ->
15:24:29 <ski> return (x+y)
15:24:33 <ski> vs.
15:24:37 <ski> [0,1,2,3] `pam` \x ->
15:24:37 <ski> [100,200] `pam` \y ->
15:24:37 <ski> x+y
15:25:07 <nmessenger> ski: but that doesn't concat, does it?
15:25:20 <ski> nmessenger : first does .. second doesn't
15:25:41 <ski> (try it ! :)
15:26:09 <nmessenger> Don't wanna
15:26:43 <nmessenger> :-P
15:26:49 <ski> (first is same as
15:26:51 <ski> do x <- [0,1,2,3] >>= \x ->
15:26:51 <ski>    y <- [100,200] >>= \y ->
15:26:51 <ski>    return (x+y)
15:26:52 <ski> and
15:27:01 <ski> [ x+y
15:27:01 <ski> | x <- [0,1,2,3]
15:27:01 <ski> , y <- [100,200]
15:27:01 <ski> ]
15:27:02 <ski> )
15:27:17 <nmessenger> SYNTAX ERROR!
15:27:29 <nmessenger> You mixed do-notation with lambda binds.
15:28:38 <ski> ah, yes i did
15:28:51 <ski> heh
15:28:52 <ski> do x <- [0,1,2,3]
15:28:52 <ski>    y <- [100,200]
15:28:52 <ski>    return (x+y)
15:29:25 <nmessenger> > [0,1,2,3] >>= \x -> [100,200] >>= \y -> return (x+y)
15:29:27 <lambdabot>  [100,200,101,201,102,202,103,203]
15:30:13 <nmessenger> ?quote ski
15:30:14 <lambdabot>  please talk to your son or daughter about parametric polymorphism
15:30:25 <newsham> ?quote dons
15:30:25 <lambdabot>  -fglasgow-exts ~= -fhaskell-prime
15:30:41 <emu> and -fkitchen-sink
15:30:42 <nmessenger> succinct
15:30:55 <nmessenger> ?quote emu
15:30:55 <lambdabot>  design patterns are what you choose for wallpaper and carpets
15:31:02 <nmessenger> :D
15:31:49 <shapr> @quote newsham
15:31:50 <lambdabot>  irc bots executing external programs..  always a good idea! what could possibly go wrong?
15:32:08 * nmessenger resolves to henceforth alternate between @command and ?command
15:32:28 <emu> :t fix
15:32:29 <lambdabot> forall a. (a -> a) -> a
15:33:52 <ski> @quote lennart
15:33:52 <lambdabot>  L M L  version 0.99. FTP a copy now and a free Haskell compiler is included.
15:34:14 <xerox> emu - the Real Thing (TM) is mfix.
15:34:15 <ski> ooh :O
15:34:26 <emu> :t mfix
15:34:28 <lambdabot> forall (m :: * -> *) a. (MonadFix m) => (a -> m a) -> m a
15:34:49 <shapr> @quote augustss
15:34:50 <lambdabot>  hbc still has some unique features, like views.  that i've never used..
15:34:56 <psi> ?quote
15:34:57 <lambdabot> SamB_XP says: I once saw it eat a comment (:[{- Help! -}])
15:35:05 <ski> > let pam = flip map in [0,1,2,3] `pam` \x -> [100,200] `pam` \y -> x+y
15:35:06 <lambdabot>  [[100,200],[101,201],[102,202],[103,203]]
15:35:43 * ski wants LML ..
15:35:43 <shapr> @quote
15:35:44 <lambdabot> cypherx says: Oh god, C++ is like a lamprey in my urethra.
15:35:48 <shapr> aiee
15:36:04 <nmessenger> @yow!
15:36:04 <lambdabot> I don't understand the HUMOUR of the THREE STOOGES!!
15:36:07 <ski> @ghc
15:36:07 <lambdabot>  Illegal polymorphic type signature in pattern
15:36:09 <xerox> > let paMc = flip concatMap in [0,1,2,3] `paMc` \x -> [100,200] `paMc` \y
15:36:09 <xerox>     -> [x+y]
15:36:10 <lambdabot>  Parse error
15:36:12 <xerox> aww.
15:36:18 <xerox> > let paMc = flip concatMap in [0,1,2,3] `paMc` \x -> [100,200] `paMc` \y -> [x+y]
15:36:20 <lambdabot>  [100,200,101,201,102,202,103,203]
15:36:25 <xerox> that's the usual list monad
15:36:42 <nmessenger> xerox: rather paMtacnoc.
15:36:46 <mgsloan> @ghc
15:36:47 <lambdabot>  Malformed context in type or class declaration
15:37:36 <nmessenger> ynnuFerAsemaNdrawkcab
15:38:10 <xerox> > reverse "ynnuFerAsemaNdrawkcab"
15:38:12 <lambdabot>  "backwardNamesAreFunny"
15:39:05 <mgsloan> > reverse "eitherWayItsAFunctionIdentifier"
15:39:07 <lambdabot>  "reifitnedInoitcnuFAstIyaWrehtie"
15:39:41 <nmessenger> > fix (selfReferenceRules 2)
15:39:42 <lambdabot>  Not in scope: `selfReferenceRules'
15:43:46 <dmhouse> Hey all. I want to use runInteractiveCommand to run a command, give it some data, then read what it tells me.
15:44:17 <xerox> Please do.
15:44:21 <dmhouse> I.e. I want to do the equivalent of, in a shell, typing command RET data data data C-d, then grabbing the result.
15:44:32 <dmhouse> However, I think I'm missing some specifics.
15:45:08 <yaxu> anyone know how to pass a haskell Handle to some C code via the ffi?
15:45:28 <lisppaste2> dmhouse pasted "runInteractiveCommand func" at http://paste.lisp.org/display/33662
15:45:36 <monochrom> there is a coercion from Handle to fd.
15:45:42 <dmhouse> That's my current effort, which doesn't appear to be working.
15:45:43 <quazimodo> > whos the coolest cat of them all?
15:45:44 <lambdabot>  Parse error
15:45:49 <yaxu> monochrom: oh perfect
15:45:50 <quazimodo> laaame it should say shaft
15:45:55 <quazimodo> what kind of crappy language is this
15:46:43 <yaxu> monochrom: found it in system.posix.io i think, thanks
15:46:46 <dmhouse> Do I need some kind of concurrent trickery?
15:46:57 <nmessenger> quazimodo: (++) is a pretty cool cat.
15:47:16 <quazimodo> nmessenger, i dont get it
15:47:27 * SamB groans
15:47:32 <mr_tenor> :D
15:47:42 <nmessenger> ?jargon concatenate
15:47:44 <lambdabot> No match for "concatenate".
15:47:47 <xerox> System.Process System.IO> runInteractiveCommand "echo hiya" >>= \(_,o,_,_) -> hGetLine o >>= putStrLn
15:47:47 <xerox> hiya
15:47:53 <nmessenger> @web1913 concatenate
15:47:55 <lambdabot> *** "Concatenate" web1913 "Webster's Revised Unabridged Dictionary (1913)"
15:47:55 <lambdabot> Concatenate \Con*cat"e*nate\ (k[o^]n*k[a^]t"[-e]*n[=a]t), v. t.
15:47:55 <lambdabot>   [imp. & p. p. {Concatenated}; p. pr. & vb. n.
15:47:55 <lambdabot>   {Concatenating}.] [L. concatenatus, p. p. of concatenare to
15:47:55 <lambdabot>   concatenate. See {Catenate}.]
15:47:57 <lambdabot> [5 @more lines]
15:48:01 <nmessenger> ?more
15:48:02 <lambdabot>   To link together; to unite in a series or chain, as things
15:48:02 <lambdabot>   depending on one another.
15:48:03 <lambdabot>  
15:48:05 <lambdabot>      This all things friendly will concatenate. --Dr. H.
15:48:07 <lambdabot>                          More
15:48:13 <SamB> dmhouse: the program is hanging?
15:48:13 <monochrom> Please use /msg
15:48:18 <dmhouse> xerox: that's fine, I think the complication comes when I try to give it data.
15:48:30 <dmhouse> SamB: no, in fact it seems to return an empty string.
15:48:47 <SamB> dmhouse: oh. how odd!
15:48:53 <dmhouse> Let me confirm that.
15:48:58 <SamB> what about stderr?
15:49:28 <xerox> System.Process System.IO> runInteractiveCommand "wc" >>= \(i,o,_,_) -> hPutStr i "foo bar baz" >> hGetLine o >>= putStrLn
15:49:28 <xerox>        0       3      11
15:49:29 <dmhouse> I'll check that.
15:49:33 <xerox> It seems to work here.
15:51:14 <xerox> runInteractiveCommand "wc" >>= \(i,o,_,h) -> hPutStr i "foo bar baz" >> hGetLine o >>= \res -> waitForProcess h >> putStrLn res
15:51:20 <xerox> This is probably saner.
15:51:35 <yaxu> wah, System.Posix.IO.handleToFd closes the handle .  damn you, uncertainty principle
15:51:45 <nmessenger> sanity is overrated
15:52:26 <sorear> ?bot
15:52:27 <lambdabot> :)
15:52:32 <monochrom> I think it closes the handle to prevent you from accessing the fd from the haskell side afterwards.
15:52:43 <nmessenger> ga-HA, HAHAHA HAH!  HA hee hee hoo hee
15:53:15 <lisppaste2> dmhouse annotated #33662 with "Now it hangs" at http://paste.lisp.org/display/33662#1
15:53:22 <dmhouse> Seems to be hanging with that.
15:53:30 <xerox> monochrom: did you see last comment on loebM by ski, on sigfpe's blog?
15:53:41 <monochrom> No.
15:53:44 <xerox> It's *really* interesting.
15:54:03 * ski *blushes*
15:54:53 <nmessenger> @go sigfpe loebM
15:54:55 <lambdabot> http://sigfpe.blogspot.com/2006/12/tying-knots-generically.html
15:54:55 <lambdabot> Title: A Neighborhood of Infinity: Tying Knots Generically
15:55:08 * xerox brews some more tea.
15:55:25 <dmhouse> SamB: what might that mean?
15:55:31 <dmhouse> SamB: I need forkIOs?
15:56:05 <SamB> dmhouse: I think so
15:56:13 <SamB> lambdabot has some code for that...
15:56:59 <xerox> Yeah, dons and sjanssen wrote some code for parallel unix-processing in bg
15:57:06 <xerox> I think it's on the wiki
15:57:30 <dmhouse> Well, this shouldn't be an expensive computation.
15:57:59 <SamB> xerox: actually, even just non-hanging processing is nice ;-)
15:58:04 <monochrom> I can't get it to hang.
15:58:22 <xerox> http://haskell.org/haskellwiki/Timing_out_computations
15:58:23 <lambdabot> Title: Timing out computations - HaskellWiki
15:58:50 <xerox> http://haskell.org/haskellwiki/Background_thread_example
15:58:52 <lambdabot> Title: Background thread example - HaskellWiki
16:00:06 <dmhouse> Hrm, it might be to do with the finally.
16:01:14 <dmhouse> No, it hangs even without that.
16:02:31 <monochrom> hClose i hangs
16:02:55 <monochrom> runInteractiveCommand "wc" >>= \(i,o,e,_) -> (hPutStr i "foo bar baz" >> hGetContents o >>= putStrLn) `finally` (hClose o >> hClose e)   {- does not hang me -}
16:03:26 <xerox> hClose i hangs here too.
16:03:48 <dmhouse> And it seems hClose o makes it return an empty string.
16:04:06 <monochrom> If I change hGetContents o to hGetContents e, still does not hang, even though wc writes nothing to e.
16:04:06 <SamB> dmhouse: don't close anything you've passed to getContents
16:04:07 <SamB> ever
16:04:19 <SamB> er, hGetContents
16:04:21 <SamB> whatever.
16:04:21 <dmhouse> Okay then :)
16:04:38 <dmhouse> (Why not?)
16:04:45 <xerox> ?index hGetContents
16:04:46 <lambdabot> System.IO
16:04:49 <xerox> ?docs System.IO
16:04:49 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html
16:04:51 <monochrom> Because hGetContents will close it at the right time for you.
16:05:02 <monochrom> However, we are not hGetContentsing i.
16:05:27 <monochrom> i is just for us to pump things to the process.  why can we not close it?
16:05:37 <sorear> read the docs, the behaivior is scary and evil.
16:05:54 <sorear> when you close the handle the lazy stream is automatically truncated
16:05:56 <xerox> "Computation hGetContents hdl returns the list of characters corresponding to the unread portion of the channel or file managed by hdl, which is put into an intermediate state, semi-closed. In this state, hdl is effectively closed, but items are read from hdl on demand and accumulated in a special list returned by hGetContents hdl."
16:06:04 <monochrom> More interestingly, why is dmhouse's computer acting differently from mine and xerox's?  We can't reproduce the hang.
16:06:37 <sorear> http://haskell.org/onlinereport/io.html#sect21.2.2
16:06:37 <lambdabot> Title: The Haskell 98 Library Report: Input/Output
16:06:54 <SamB> kernel, libc, and GHC versions please?
16:06:58 <sorear> "Once a semi-closed handle becomes closed, the contents of the associated list becomes fixed."
16:07:21 <dmhouse> unsafePerformIO $ runInteractiveCommand "pandoc" >>= \(i,o,e,_) -> hPutStr i "ra *ar* gh" >> hGetContents e >>= putStr >> hGetContents o
16:07:23 <sorear> i.e. if it read half the file, and you close the file, the list will have an artificial eof.
16:07:28 <dmhouse> Does not hang in GHCi.
16:07:41 <sorear> this is generally considered undesirable behaivor.
16:07:45 <monochrom> Oh, right, I'm ghci-ing
16:07:47 <lisppaste2> dmhouse annotated #33662 with "Current formatPost" at http://paste.lisp.org/display/33662#2
16:07:48 <xerox> Darwin 8.8.1 Darwin Kernel Version 8.8.1: Mon Sep 25 19:42:00 PDT 2006; root:xnu-792.13.8.obj~1/RELEASE_I386 i386
16:07:50 <xerox> The Glorious Glasgow Haskell Compilation System, version 6.6
16:07:55 <dmhouse> ^^ Does hang my firefox.
16:07:57 <sorear> It *should* throw an exception.
16:08:04 <xerox> I am also GHCi-ing.
16:08:52 <quazimodo> yahoo im understanding these silly types :)
16:09:04 <SamB> sorear: you mean like "user error: the programmer is an idiot -- he hClosed a handle after calling hGetContents on it!"
16:09:06 <quazimodo> i get what (a->a->a) -> [a] ->a means!
16:09:16 <sorear> SamB: yes.
16:09:21 <xerox> quazimodo: yippie!
16:09:38 <quazimodo> aw man this channel rock
16:09:39 <quazimodo> s
16:09:44 <sorear> SamB: that's much more user-friendly than silently corrupting data!
16:09:48 <mauke> @djinn (a->a->a) -> [a] ->a
16:09:49 <lambdabot> -- f cannot be realized.
16:10:08 <nmessenger> quazimodo: types are so awesome!
16:10:30 <sorear> yeah, if that func existed you could apply it to 'const' and '[]' and get foo const [] :: forall a. a
16:10:59 <monochrom> I'll try compile to reproduce dmhouse's hang
16:11:31 <sorear> thats why that function cannot exist (totally)
16:11:39 <xerox> > mfix (\mu -> ($ mu) `mapM` [const (Just 1), const (Just 2)])
16:11:41 <lambdabot>  Just [1,2]
16:11:46 <xerox> :X
16:11:55 <quazimodo> nmessenger, type b is boolean?
16:12:02 <quazimodo> a is all, b is boolean c is char?
16:12:16 <nmessenger> quazimodo: what?
16:12:17 <quazimodo> or are wel using  a b and c to mean just differnt types?
16:12:20 <sorear> they are just letters, no meaning
16:12:23 <Adamant> question - effects systems. What is their relevance to Haskell? how do they compare to Monads?
16:12:34 <nmessenger> quazimodo: yeah, a b c etc are type variables
16:12:36 <SamB> @djinn a -> [a]
16:12:37 <lambdabot> -- f cannot be realized.
16:12:38 <quazimodo> sorear, so that means they can be the same, or they must be different?
16:12:47 <monochrom> hee hee, compiled code hangs.  embarrassing
16:12:50 <SamB> I think djinn just doesn't know about []
16:12:52 <sorear> they can be the same.
16:12:58 <sorear> SamB: yes
16:12:59 <quazimodo> sorear, thats a bit silly
16:13:11 <SamB> well, it still wouldn't be realizable...
16:13:12 <sorear> @djinn-add listreturn :: a -> [a]
16:13:20 <SamB> but ;-)
16:13:25 <sorear> @djinn a -> [a]
16:13:25 <lambdabot> f = listreturn
16:13:29 <sorear> @djinn a -> [[a]]
16:13:30 <lambdabot> -- f cannot be realized.
16:13:30 <Adamant> ping dons. :)
16:13:31 <nmessenger> ?type (:[])
16:13:32 <lambdabot> forall a. a -> [a]
16:13:37 <nmessenger> BAM! bitch
16:13:37 <xerox> > fix (\mu -> ($ mu) `fmap` [length, head])
16:13:39 <lambdabot>  [2,2]
16:13:45 <quazimodo> so a->b->c could mean Char->Char->Char or it could also mean [Char]->Char->Boolean
16:13:48 <sorear> @help djinn-add
16:13:48 <lambdabot> djinn-add <expr>.
16:13:48 <lambdabot> Define a new function type or type synonym
16:13:55 <sorear> q-m: yes
16:14:07 <sorear> @list djinn
16:14:07 <lambdabot> djinn provides: djinn djinn-add djinn-del djinn-env djinn-names djinn-clr djinn-ver
16:14:09 <dmhouse> > fix (\mu -> ($ mu) `fmap` [length, last])
16:14:10 <lambdabot>  Exception: <<loop>>
16:14:12 <Adamant> dons, how do effect systems relate to Haskell and Monads? thanks in advance. :)
16:14:13 <quazimodo> i refuse to accept that!
16:14:20 <quazimodo> a b and c should be differnt!
16:14:25 <monochrom> I guess dmhouse will have to forkIO the (hPutStr i ...) part.
16:14:31 <mauke> quazimodo: no
16:14:32 <sorear> @tell Adamant dons doesn't read the logs
16:14:32 <lambdabot> Consider it noted.
16:14:48 <dmhouse> monochrom: all I do is place forkIO ( ... ) around the hPutStr call?
16:14:58 <nmessenger> quazimodo: in a plain mathematical equation, do x and y *always* have to be different?
16:15:01 <monochrom> I'm trying.
16:15:07 <mgsloan> quazimodo: you know how in algebra where x, y, z have no concrete value? this is like that except with types
16:15:10 <dmhouse> ?tell Adamant but you could use ?tell.
16:15:10 <lambdabot> Consider it noted.
16:15:12 <mgsloan> bah, nmessenger beat me too it
16:15:12 <Adamant> @tell dons how do effects systems relate to Monads in Haskell?
16:15:12 <lambdabot> Consider it noted.
16:15:21 <Adamant> dmhouse, I figured. :)
16:15:21 <lambdabot> Adamant: You have 2 new messages. '/msg lambdabot @messages' to read them.
16:15:28 <monochrom> It still hangs.
16:15:37 <dmhouse> monochrom: you can reproduce my hang, now?
16:15:42 <monochrom> Yes.
16:15:45 <mgsloan> by concrete value I mean constant
16:15:48 <dmhouse> Without hClosing o?
16:15:58 <Adamant> I forget how busy this channel is.
16:15:59 <monochrom> Without hClosing anything.
16:16:02 <dmhouse> Great.
16:16:08 <sorear> ?seen dons
16:16:09 <lambdabot> dons is in #haskell.hac07, #haskell-overflow, #ghc and #haskell. I last heard dons speak 13h 5m 8s ago.
16:16:35 <monochrom> Oh!  I forgot to flush.
16:16:51 <quazimodo> mgsloan, yah i got that, i was just being a smartarse. it would have been more familiar if the letters meant something but looking at it now, it is a whole lot more sensible for them to be variables, using the same letter to imply the same type is more sensible
16:17:38 <monochrom> forkIO (hPutStr i whatever >> hClose i)
16:17:38 <mgsloan> yep
16:17:48 <quazimodo> like a->a->b would mean Char->Char->Char as well as Char->Char->[Char] right?
16:17:54 <mgsloan> right
16:17:58 <quazimodo> good
16:18:01 <mgsloan> as well as many other things :)
16:18:14 <monochrom> Alternatively, (hPutStr i whatever >> hClose i) without forkIO too!
16:18:22 <nmessenger> so long as the first a is the same as the second
16:18:48 <quazimodo> yup
16:18:53 <dmhouse> monochrom: Great. :D
16:18:54 <monochrom> My conclusion is you have to hClose i as early as possible.  forkIO is optional and you make the judgement call.
16:19:02 <dmhouse> monochrom: thanks very much for your perseverance.
16:19:06 <quazimodo> this language is quite cool, i can see why it would be so fast to code in
16:19:29 <dmhouse> monochrom: is there any disadvantage to forkIO? Apart from the 'small' (according to docs) thread creation overhead?
16:19:48 <sorear> dmhouse: it makes brains explode
16:20:00 <dmhouse> sorear: what, a little harmless threading? :)
16:20:29 <mgsloan> quazimodo: yep, quite cool.  one thing, though, is that a -> a -> b is actually impossible to write :)
16:20:36 <nmessenger> sorear: how is that a disadvantage.  I thought it was a normal occurance in Haskell :)
16:20:43 <mauke> @type \_ _ -> undefined
16:20:45 <monochrom> No disadvantage apart from an extra lightweight thread.  If lots of bytes to be transferred, a good idea to forkIO.
16:20:45 <lambdabot> forall a t t1. t1 -> t -> a
16:21:02 <dmhouse> ?type \x _ -> unsafeCoerce# x
16:21:04 <lambdabot> Not in scope: `unsafeCoerce#'
16:21:05 <dmhouse> Aww.
16:21:09 <sorear> @type undefined :: a -> a -> b
16:21:10 <lambdabot> a -> a -> b :: forall a b. a -> a -> b
16:21:27 <lisppaste2> monochrom annotated #33662 with "my recommendation" at http://paste.lisp.org/display/33662#3
16:21:29 * dmhouse wonders how to proves mgsloan's statement.
16:21:29 <mauke> @type \a b -> snd (a `asTypeOf` b, undefined)
16:21:31 <sorear> ^^^ ANY function can be realized as a special case of undefined (except maybe unboxed-fu)
16:21:31 <lambdabot> forall a a1. a -> a -> a1
16:21:32 <mgsloan> this is a funny result of polymorphic functions, which allows telling what functions are impossible, and in some cases what functions must do, based on their type signature alone.  This is called Theorems for Free
16:22:03 <sorear> of course _|_ wreaks havoc, as does seq
16:22:08 <sorear> ?free seq
16:22:09 <lambdabot> f . seq x = seq (g x) . f
16:22:18 <dmhouse> ?help free
16:22:18 <lambdabot> free <ident>. Generate theorems for free
16:22:19 <mgsloan> dmhouse - yeah, actually I'm wrong.... because this could just be a really really loose type sig
16:22:23 <sorear> let g = const 1, x = undefined, f = id
16:22:25 <dmhouse> ?map free
16:22:25 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
16:22:29 <dmhouse> Err...
16:22:31 <dmhouse> ?free map
16:22:32 <lambdabot> f . h = k . g => $map f . map h = map k . $map g
16:22:42 <mgsloan> :t const . const
16:22:44 <lambdabot> forall b a b1. a -> b -> b1 -> a
16:22:57 <dmhouse> What's $map?
16:23:00 <sorear> :free undefined :: a
16:23:03 <mgsloan> :t \x y -> 0
16:23:04 <lambdabot> forall t t1 t2. (Num t) => t2 -> t1 -> t
16:23:09 <sorear> ?free undefined :: a
16:23:09 <lambdabot> f undefined = undefined
16:23:20 <mgsloan> ah, my bad, quazimodo, that function is possible
16:23:27 <sorear> ?free fii :: a -> a
16:23:27 <lambdabot> f . fii = fii . f
16:23:33 <dmhouse> mgsloan: how?
16:23:38 <mgsloan> see above
16:23:52 <sorear> ?free fii :: a -> GHC.Prim.Int#
16:23:52 <lambdabot> Extra stuff at end of line
16:23:53 <mgsloan> sure, there's the added Num constraint, but for return types it doesn't matter
16:24:04 <dmhouse> mgsloan: yes, but they're not universally quantified.
16:24:14 <dmhouse> The Num constraint makes it way easier.
16:24:28 <dmhouse> Because otherwise the only way to get something of type b is to use an argument or to use undefined.
16:24:44 <dmhouse> By the way, I think we can focus on a -> b, not a -> a -> b.
16:24:46 <augustss> indeed
16:25:04 <augustss> @djinn a->b
16:25:04 <lambdabot> -- f cannot be realized.
16:25:08 <dmhouse> ?type const 5
16:25:09 <lambdabot> forall a b. (Num a) => b -> a
16:25:19 <mauke> @type const (fix id)
16:25:20 <dmhouse> The only thing special about numbers is that they're polymorphic, but not universally so.
16:25:21 <lambdabot> forall a b. b -> a
16:25:32 <dmhouse> mauke: because fix id == undefined
16:25:40 <dmhouse> fix f for any strict f == undefined
16:25:51 <dmhouse> ?type const undefined -- exactly the same as this
16:25:52 <lambdabot> forall a b. b -> a
16:25:56 <nmessenger> is it possible to write a non-divergent, non-constrained (a -> b) ?
16:26:06 <augustss> nmessenger: no
16:26:08 <dmhouse> Without using unsafeCoerce :)
16:26:15 <mgsloan> yeh, i remember reading that you can't have a->b.  I guess once you can determine the type sig further that doesn't count
16:26:18 <dmhouse> augustss: what does the proof look like?
16:27:03 <augustss> well, you could probably make proof along the theorems for free stuff
16:27:05 <lisppaste2> zeeeee annotated #33655 with "still can't hack it...help!" at http://paste.lisp.org/display/33655#1
16:27:22 <nmessenger> It sorta makes sense intuitively, it's not obvious how to write a function to turn anything into some other some of thing.
16:27:39 <augustss> dmhouse: or use the Curry-Howard isomorphiosm, then a->b would lead to an inconsistent logic
16:27:46 <dmhouse> True.
16:27:48 <nmessenger> ANY other sort of thing, rather
16:27:48 <dmhouse> That's nice.
16:28:15 <nmessenger> ?type const 1 -- turns anything into Int
16:28:16 <lambdabot> forall a b. (Num a) => b -> a
16:28:24 <quazimodo> wow
16:28:27 <nmessenger> or Num a => a :P
16:28:28 <quazimodo> foldr1 is quite useful
16:28:30 <dmhouse> What does 'Not' look like as a type?
16:28:44 <augustss> dmhouse: or ask djinn, if it says no, it's impossible
16:28:48 <dmhouse> I think I've seen type Not x = x -> Void, that right?
16:28:50 <nmessenger> ?type not -- ?
16:28:51 <lambdabot> Bool -> Bool
16:28:58 <augustss> dmhouse: yes, that's right
16:29:15 <dmhouse> nmessenger: no, I mean what's the type that represents logical negation, just as Either represents logical disjunction.
16:29:16 <augustss> dmhouse: it's like negation in logic
16:29:21 <quazimodo> ?version
16:29:22 <lambdabot> lambdabot 4p307, GHC 6.5 (OpenBSD i386)
16:29:22 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
16:29:46 <quazimodo> hey cool they wrote lambdadot at unsw?
16:29:50 <dmhouse> So you could construct (a, a -> Void) -> b. (Given a contradiction, anything is provable.)
16:29:58 <yaxu> ?hoogle Fd -> Int
16:29:59 <lambdabot> No matches, try a more general search
16:30:00 <dmhouse> ?djinn-env
16:30:00 <lambdabot> data () = ()
16:30:00 <lambdabot> data Either a b = Left a | Right b
16:30:00 <lambdabot> data Maybe a = Nothing | Just a
16:30:00 <lambdabot> data Bool = False | True
16:30:01 <lambdabot> data Void
16:30:03 <lambdabot> type Not x = x -> Void
16:30:05 <lambdabot> listreturn :: a -> [a]
16:30:11 <augustss> @djinn (a, Not a) -> b
16:30:12 <lambdabot> f (a, b) = void (b a)
16:30:17 <mauke> yaxu: IIRC Fd is a CInt
16:30:38 <dmhouse> void :: Void -> a?
16:30:45 <augustss> dmhouse: yes
16:30:50 <dmhouse> Cool. :)
16:30:59 <augustss> it's elimination rule for the empty type
16:31:04 <dmhouse> Yeah.
16:31:11 <nmessenger> does Void have no members?
16:31:12 <augustss> dmhouse: it would be an empty case expression
16:31:15 <dmhouse> nmessenger: exactly.
16:31:27 <dmhouse> augustss: or indeed unsafeCoerce, which is safe here.
16:31:34 * nmessenger doesn't understandhow it would be useful
16:31:36 <SamB> nmessenger: yeah, hence the lack of an = sign or constructors
16:31:41 <ksandstr> so, uhh... what's the general opinion on using pattern guards on non-functions? heresy, or just a minor sin like n+k patterns?
16:31:42 <mgsloan> quazimodo: yeah, dons is a phd student there
16:31:49 <SamB> nmessenger: because you can't have one
16:31:56 <augustss> nmessenger: it's typically not usefule until you get dependent types
16:32:08 <dmhouse> nmessenger: Tree a is the type of tree with leaves of type a, Tree Void is the type of tree with no leaves (or bottom leaves).
16:32:19 <nmessenger> ksandstr: use them if they're useful, but careful of the monomorphism restriction.
16:32:58 <quazimodo> mgsloan, is it possible to define your own operators in haskell?
16:33:02 <augustss> you can actually define Void in Haskell. I mean the really empty one, no bottom
16:33:14 <SamB> augustss: how?
16:33:20 <dmhouse> Not in Haskell98 you can't.
16:33:24 <augustss> newtype Void = Void Void
16:33:32 <SamB> eh?
16:33:33 <quazimodo> i have a problem that would be easier solved if i could define an operator to get its arguments from its left and right, rather than a function with its arguments to the right
16:33:36 <nmessenger> Ooh pretty
16:33:37 <SamB> is that Haskell 98?
16:33:47 <dmhouse> augustss: that has lots of members, _|_, Void _|_, Void (Void _|_), ...
16:33:52 <mauke> quazimodo: you can use x `function` y or define your own operator
16:33:56 <dmhouse> Ah!
16:34:03 <quazimodo> mauke, how?
16:34:05 <dmhouse> But as newtype'd constructors are strict, they're all _|_. Clever.
16:34:28 <nmessenger> newtype Void = Void !Void -- perhaps?
16:34:28 <mgsloan> quazimodo: yep, check this out
16:34:30 <quazimodo> mauke, does haskell just *do* it , such as function a b = blah, value1 function value 2
16:34:36 <nmessenger> nvm
16:34:41 <mgsloan> > let 1 + 2 = 5 in 1 + 2
16:34:42 <lambdabot>  5
16:34:48 <SamB> nmessenger: you can't use ! there, or at least it doesn't do anything
16:35:04 <mauke> > 'r' `elem` "bar"
16:35:05 <lambdabot>  True
16:35:08 <yaxu> mgsloan: how would i convert it to an Int, in that case?
16:35:09 <quazimodo> mgsloan thats a bit silly :P
16:35:12 <mauke> > elem 'r' "baz"
16:35:13 <lambdabot>  False
16:35:17 <mgsloan> yes, it is quite silly :)
16:35:18 <dmhouse> augustss: that's very cool.
16:35:30 <mgsloan> yaxu - hmm?
16:35:48 <nmessenger> > 0 L./ 0
16:35:48 <lambdabot>  Not in scope: `L./'
16:35:52 <yaxu> mgsloan: oops sorry, wrong person :/
16:35:54 <mgsloan> the let 1 + 2 = 5 thing just changes the definition of + within that scope
16:36:11 <yaxu> mauke: how would i convert an Fd to an Int, in that case?
16:36:14 <nmessenger> > let 3 = 5 in 3
16:36:15 <lambdabot>  3
16:36:29 <quazimodo> how do we increasethe size of its scope?
16:36:37 <quazimodo> as in to make it a global thing
16:36:44 <Saizan> just define it at the top
16:36:48 <quazimodo> Prelude> let 1+2 = 5 in 1+2
16:36:49 <quazimodo> 5
16:36:49 <quazimodo> Prelude> 1+2
16:36:49 <quazimodo> 3
16:36:50 <quazimodo> ?
16:36:54 <mgsloan> quazimodo: as far as just *doing* it depends on what you mean.  its got lazy evaluation, so it'll delay doing it till it must
16:37:19 <newsham> Prelude> let 1+2 = 5
16:37:19 <newsham> Prelude> 1+2
16:37:19 <newsham> 5
16:37:20 <nmessenger> quazimodo: you can't redine LB's toplevel, but she does give you an L namespace
16:37:28 <augustss> Haskell 1.4 (or maybe 1.3) had the Void type.
16:37:33 <nmessenger> redine? redefine, even.
16:37:39 <mgsloan> @let 1+2 = 5
16:37:40 <lambdabot> Defined.
16:37:42 <quazimodo> oh i see, the in 1+2 will make it just now
16:37:48 <augustss> But then non-typetheory people "improved" it. :)
16:37:49 <mgsloan> > 1 L.+ 2
16:37:50 <nmessenger> > 1 L.+ 2
16:37:50 <lambdabot>  5
16:37:51 <lambdabot>  5
16:37:57 <mauke> @hoogle Fd -> CInt
16:37:58 <lambdabot> No matches, try a more general search
16:37:59 <quazimodo> so 1+2 = 5 in 1+2 will only let it apply within that sentence
16:38:05 <mgsloan> > 1 + 1
16:38:06 <lambdabot>  2
16:38:12 <quazimodo> but let 1+2 = 5 will define it for later
16:38:14 <mgsloan> > 1 L.+ 1
16:38:15 <lambdabot>  Exception: <local>:3:0-6: Non-exhaustive patterns in function +
16:38:18 <mgsloan> uh-ohes
16:38:21 <mauke> yaxu: fromIntegral, I guess
16:38:21 <dylan> augustss: "improved"?
16:38:38 <dmhouse> augustss: I think it's gone (or going) back in, there was a discussion on libraries@haskell.org.
16:38:40 <yaxu> mauke: thanks, i think fromEnum is it
16:38:45 <augustss> dylan: they removed Void (and void).
16:38:55 <dylan> what was Void/void?
16:38:58 <nmessenger> quazimodo: the @let command defines in the L namespace, @eval let foo = ... is an expression that has a local foo
16:39:00 <mgsloan> quazimodo: yes, within ghci/LB.  otherwise the let is unecessary if you want it to be global
16:39:16 <augustss> dylan: Void, the empty type, abd void, the elimination function
16:39:29 <nmessenger> ?undefine +
16:39:30 <lambdabot> Undefined.
16:39:35 <mgsloan> this is something that, imho, needs fixing
16:39:50 <nmessenger> @let 1 + 2 = 5; x + y = x Prelude.+ y
16:39:51 <lambdabot> Defined.
16:40:06 <mgsloan> @let (-) = (+)
16:40:07 <lambdabot> <local>:2:6:     Ambiguous occurrence `+'     It could refer to either `L.+',...
16:40:13 <augustss> dmhouse: I think it's going in because people are becoming more aware of dependent types.  then it gets more useful
16:40:15 <mgsloan> interesting
16:40:18 * nmessenger muses that LB needs a ?redefine
16:40:27 <mgsloan> @let (-) = (*)
16:40:27 <lambdabot> Defined.
16:40:29 <mgsloan> :)
16:40:39 <mgsloan> > 5 L.- 10
16:40:40 <nmessenger> CONFUSING REIGNS
16:40:40 <augustss> @let (-) = 5
16:40:41 <lambdabot>  50
16:40:41 <lambdabot> <local>:3:0:     Multiple declarations of `L.-'     Declared at: <local>:2:0 ...
16:40:49 <nmessenger> s/ING/ION/
16:40:59 <augustss> > (L.-)
16:41:01 <lambdabot>  <Integer -> Integer -> Integer>
16:41:22 <Saizan> > 1 + 2
16:41:23 <lambdabot>  3
16:41:24 <mgsloan> what's with the < >s
16:41:25 <augustss> @undefine -
16:41:26 <lambdabot> Undefined.
16:41:34 <mgsloan> oh, thats what happens when you eval a func..
16:41:36 <augustss> @let (-) = 5
16:41:37 <lambdabot> Defined.
16:41:37 <nmessenger> augustss: how do a write a showType like LB uses?
16:41:42 <mgsloan> huh. show instance for funcs eh
16:41:59 <mgsloan> I think its unpossible
16:42:05 <nmessenger> augustss: showType negate = "<Num a => a -> a>"
16:42:08 <Saizan> maybe with typeable?
16:42:25 <mgsloan> probably due to the fact that LB is what runs the interpreter or something
16:42:25 <augustss> nmessenger: I'm not sure how it's done in LB.  maybe through typable
16:42:36 <dmhouse> It uses typeable, yeah.
16:42:37 <nmessenger> Saizan: I've not used typeable and family before.
16:42:44 <dmhouse> nmessenger: 'compiler magic'.
16:42:51 <dmhouse> ?type Data.Typeable.typeOf
16:42:53 <lambdabot> forall a. (Typeable a) => a -> TypeRep
16:43:00 <Saizan> nmessenger: however i was asking too :D
16:43:04 <dmhouse> That's the key, really. It allows you to define:
16:43:09 <dmhouse> ?type Data.Typeable.cast
16:43:10 <lambdabot> forall b a. (Typeable b, Typeable a) => a -> Maybe b
16:43:15 <augustss> dmhouse: except it's not magic at all.  you can define it yourself.  except deriving
16:43:15 <dmhouse> Which is safe.
16:43:29 <dmhouse> augustss: And you need a magically extensible TypeRep type.
16:43:37 <augustss> dmhouse: true
16:43:57 <augustss> dmhouse: if you do it by hand you need to be careful
16:43:59 <Saizan> ?docs Data.Typeable
16:44:00 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Typeable.html
16:44:01 <nmessenger> ?hoogle TypeRep
16:44:01 <lambdabot> Data.Typeable.TypeRep :: data TypeRep
16:44:01 <lambdabot> Data.Typeable.typeRepArgs :: TypeRep -> [TypeRep]
16:44:01 <lambdabot> Data.Typeable.typeRepTyCon :: TypeRep -> TyCon
16:44:14 <ski> nmessenger : i used 'Void' as a continuation result type in a coroutining thread monad ..
16:44:21 <dmhouse> nmessenger: it's an abstract type that is really the only magic bit in there.
16:44:33 <nmessenger> ski: wouldn't 'a' do?
16:44:33 <dmhouse> Things like Data.Generics and Data.Dynamic use Typeable.
16:44:47 <ski> nmessenger : i needed a concrete type
16:45:15 * dcoutts__ fires off win32 builds of gtk2hs-0.9.10.3 with ghc-6.6 and gtk+ 2.8 and 2.10
16:45:34 <augustss> Void id your friend, just like 0. :)
16:45:40 <augustss> s/id/is/
16:45:53 * ski nods
16:46:23 <ski> (hm, 'Identity' is the initial monad, yes ?)
16:46:37 * nmessenger is realizing just how much of Haskell wants to be my friend
16:46:41 * nmessenger likes this
16:47:22 <dmhouse> Are dependent types basically just types parametrised over some value?
16:47:31 <dcoutts__> dmhouse: yep
16:47:31 <augustss> dmhouse: yes
16:47:34 <Saizan> typeOf gets insane with polymorphic types..
16:47:51 <Saizan> > Data.Typeable.typeOf map
16:47:52 <lambdabot>  Add a type signature
16:47:59 <nmessenger> :D
16:48:11 <yaxu> ha!  ffi conquered!  now my animation no longer stutters
16:48:19 <Saizan> > Data.Typeable.typeOf (undefined :: Int -> Int)
16:48:21 <lambdabot>  Int -> Int
16:48:27 <dcoutts__> yaxu: sounds good, tell us more
16:48:28 * dmhouse is off
16:48:39 <dcoutts__> and he's starting to smell
16:48:42 <nmessenger> Saizan: how terribly unexpected
16:49:08 <quazimodo> >let multAdd a b = a+10*b
16:49:13 <nmessenger> space
16:49:39 <quazimodo> >let horner ab = foldr1 multAdd ab
16:49:43 <quazimodo> horner [1,2,3,4]
16:49:44 <yaxu> dcoutts__: i'll make a screencast
16:49:48 <nmessenger> quaz: add a space
16:49:52 <quazimodo> oh
16:49:56 <quazimodo> after the > ?
16:50:00 <nmessenger> yep
16:50:12 <quazimodo> > let multAdd a b = a+10*b
16:50:13 <lambdabot>  Parse error
16:50:19 <quazimodo> ?
16:50:20 <nmessenger> '>' is an LB command, '>let' isn't
16:50:27 <Saizan> ?let is
16:50:28 <lambdabot>  Parse error
16:50:33 <quazimodo> > multAdd a b = a+10*b
16:50:34 <lambdabot>  Parse error
16:50:39 <quazimodo> blekh
16:50:45 <nmessenger> ?let is = is
16:50:46 <lambdabot> Defined.
16:51:00 <augustss> @let multAdd a b = a+10*b
16:51:01 <lambdabot> Defined.
16:51:01 <quazimodo> what was wrong with it?
16:51:01 <mgsloan> > let multAdd a b = a+10*b in 5 `multAdd` 4
16:51:02 <lambdabot>  45
16:51:15 <Saizan> > L.is
16:51:15 <psi> ?type is
16:51:16 <lambdabot>  Add a type signature
16:51:17 <lambdabot> Not in scope: `is'
16:51:20 <mgsloan> I agree, the interpreters/LB suck
16:51:28 <mgsloan> would avoid this confusion
16:51:35 <mgsloan> basically, > accept expressions
16:51:35 <nmessenger> Saizan: 'is' is bottom
16:51:44 <nmessenger> > L.is :: Int
16:51:45 <lambdabot>  Exception: <<loop>>
16:51:48 <Saizan> i know
16:51:56 <quazimodo> mgsloan, so, why does in 5 `multAdd` 4 work ad give 45?
16:51:58 <nmessenger> ?undefine is
16:51:58 <lambdabot> Undefined.
16:52:26 <quazimodo> @let horner  ab = foldr1 multAdd ab
16:52:27 <lambdabot> <local>:1:20: Not in scope: `multAdd'
16:52:31 <mgsloan> `func` is the infix version of a function that takes 2 arguments
16:52:45 <mgsloan> where the first argument is before, and the second after
16:52:47 <augustss> quazimodo: you need L. for @let bindings
16:52:59 <quazimodo> uhuh
16:53:01 <augustss> @let horner  ab = foldr1 L.multAdd ab
16:53:02 <lambdabot> <local>:1:20: Not in scope: `L.multAdd'
16:53:15 <quazimodo> :D
16:53:18 <mgsloan> doh, looks like someone undefined it
16:53:18 <augustss> hupp!
16:53:22 <nmessenger> > let base b x y = x+b*y in foldl1 (base 10) [1,3,5,2,6,9]
16:53:24 <lambdabot>  251
16:53:25 <Saizan> quazimodo: i suggest you to use your local ghci, much more consistent :)
16:53:47 <augustss> yes, LB is only good for one-liners
16:53:50 <quazimodo> Saizan, the reaso i was doingthat here is to ask why the hell it works!
16:54:03 <Saizan> oh ok then
16:54:17 <augustss> quazimodo: it works because it's right :)
16:54:19 <shankys> ?paste
16:54:19 <lambdabot> http://paste.lisp.org/new/haskell
16:54:43 <quazimodo> i have to write procedure to do horners multiplication, and i wrote one that works but i dont understand why it works, it was a stab in the dark
16:55:03 <lisppaste2> shankys pasted "Layout Issues" at http://paste.lisp.org/display/33668
16:55:06 <quazimodo> its just two lines, can i post it to the channel?
16:55:25 <mgsloan> yes, i think usual polite limit is 3
16:55:34 <shankys> I can't seem to get this code to work without {}'s and semicolons...
16:55:40 <quazimodo> multAdd a b = a+10*b
16:55:40 <quazimodo> horner10 ab = foldr1 multAdd ab
16:55:55 <shankys> Could someone tell me what's wrong with just taking out the {}'s and semicolons in the code I pasted?
16:56:15 <augustss> quazimodo: a good way to understand is to execute some small example by hand
16:56:26 <nmessenger> shankys: shouldn't 'c <-' line up with 'r <-' ?
16:56:34 <monochrom> If you expand (foldr1 multAdd [3,1,4]) you will see.
16:56:47 <shankys> nmessenger: Oh, in my code it is -- something funny happened in the paste
16:56:52 <quazimodo> i dont entirely get how that works, fromw hat i understand  horner10 [1,2,3,4] is (1 multAdd (2 multAdd (3 multAdd 4)))
16:57:08 <mr_tenor> not mixingtabs andspaces?
16:57:09 <mgsloan> exactly!
16:57:14 <augustss> shankys: the lines are not equally indented inside do
16:57:27 <dancor> is it normal for hdbc to return ever numeric columns as SqlString's??
16:57:33 <monochrom> I'll do it.  I use # for multAdd.  foldr1 multAdd [3,1,4] = 3 # (1 # 4).  Now plug in # x y = x+10*y.
16:57:34 <dancor> s/ever/even
16:57:39 <nmessenger> augustss: see shankys msg to me
16:57:44 <quazimodo> so, why does (3 mutltAdd 4) work?
16:58:01 <mgsloan> it should be (3 `multAdd` 4)
16:58:07 <monochrom> 3+10*4 as you have defined it.
16:58:13 <mgsloan> there's no real difference, its just syntax
16:58:29 <quazimodo> mgsloan, what if multAdd a b c d e ?
16:58:39 <mgsloan> then you'd have to write it normally
16:58:44 <monochrom> If you have a 2-parameter function f you can use `f` as infix.
16:58:49 <nmessenger> quaz: multAdd is defined for two arguments
16:58:57 <mgsloan> and you wouldn't do foldr with it, without producing a list of functions at least
16:59:09 <quazimodo> nmessenger, so this is just a language feature to make these sorts of things easier
16:59:15 <mgsloan> yeah
16:59:16 <monochrom> YES!
16:59:29 <monochrom> It makes a whole lot of sense doesn't it?
16:59:33 <quazimodo> cool, this would make lots of maths stuff easier
16:59:44 <mgsloan> operators can be made to look like normal funcs. 1 + 2 <=> (+) 1 2
16:59:45 <monochrom> It makes you wonder why the whole world hasn't caught on.
16:59:47 <nmessenger> quazimodo: x `f` y IS ENTIRELY EQUIVALENT TO and CAN BE REPLACED WITH f x y
17:00:08 <monochrom> It's so obvious after you've seen it.  Best thing since fire.
17:00:10 <quazimodo> nmessenger, dont have to yell :/ i like to be thorough so i udnerstand exactly what and why :/
17:00:24 <mgsloan> actually, that last bit is a result of what's called sections
17:00:29 <mgsloan> > (+13) 5
17:00:30 <lambdabot>  18
17:00:31 <nmessenger> quaz: just trying to emphasize, sorry for coming off rude
17:00:48 <quazimodo> i was trying to write it so that instead of 3 `multAdd` 4 i would be getting multAdd 3 4 and i couldnt :/
17:00:58 <quazimodo> not easily anyway
17:01:04 <mgsloan> hmm?
17:01:05 <monochrom> I never emphasize.  I expect you to read every letter of mine carefully and thoroughly.
17:01:06 <quazimodo> nmessenger, all good :)
17:01:24 <monochrom> Then if you fail to, I'll yell at you "are you illiterate or blind?"
17:01:36 <nmessenger> I LIKE TO YELL
17:01:41 <monochrom> Then I'll tell you my definition of IQ.
17:01:44 <mgsloan> (multAdd 1 (multAdd 2 (multAdd 3 4)))
17:01:58 <nmessenger> > (multAdd 1 (multAdd 2 (multAdd 3 4)))
17:01:59 <lambdabot>  Not in scope: `multAdd'
17:02:03 <quazimodo> mgsloan, how do we do that with foldr1?
17:02:07 <mgsloan> also, to make writing things like this easier, the $ syntax sugar was introduced
17:02:07 <nmessenger> > (L.multAdd 1 (L.multAdd 2 (L.multAdd 3 4)))
17:02:08 <lambdabot>  Not in scope: `L.multAdd'
17:02:15 <mgsloan> quazimodo: foldr1 does do that
17:02:15 <quazimodo> heh
17:02:29 <mgsloan> infix or normal presentation, its the same thing
17:02:43 <nmessenger> infix is neat cause you can do sections!
17:02:45 <quazimodo> foldr1 function [1,2,3,4,5] does 1 function 2 function 3 function 4 ??
17:02:50 <mgsloan> multAdd 1 $ multAdd 2 $ multAdd 3 4
17:02:58 <nmessenger> @type (`elem` " \n\r")
17:02:59 <lambdabot> Char -> Bool
17:03:13 <mgsloan> basically $ sticks everything to the right in parenthesis
17:03:31 * dancor will rewrite hdbc someday
17:03:40 <mgsloan> though technically its just a low precedence operator
17:03:47 <nmessenger> (++ "\n") "<- this function adds newlines"
17:03:50 <quazimodo> mgsloan, well infix is cool, but if the language couldnt handle it, foldr1 wouldnt work?
17:03:52 <dancor> for now i will do ridiculous  read $ fromSql $ row!!0
17:03:54 <nmessenger> > (++ "\n") "<- this function adds newlines"
17:03:56 <lambdabot>  "<- this function adds newlines\n"
17:04:12 <syntaxfree> the language is pretty good.
17:04:14 <mgsloan> quazimodo: it could, foldr1 really has nothing to do with infix notation
17:04:46 <mauke> dancor: !!0 is also head
17:05:01 <nmessenger> quazimodo: you can use flip to give a second argument if there were no sections: (flip elem " \n\r")
17:05:07 <dancor> mauke: true
17:05:11 <mgsloan> well, it has a bit.  there's the niceness that the number of func applications = n - 1.  This cooresponds with infix notation, which makes it a nice way to write what foldr does
17:05:20 <Saizan> foldr1 f (x:xs) = f x (foldr1 f xs)  <-- you can easily write it with prefix
17:05:29 <dancor> mauke: i'm more concerned with having to do the  read
17:05:36 <augustss> quazimodo: you should look at the Prelude how foldr1 (&co) is defined
17:05:47 <quazimodo> ok
17:05:48 <scodil> is there a wrapper for zlib that lets you read/write to compressed files, like the c library?
17:05:53 <nmessenger> ?source Prelude
17:05:54 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
17:05:57 <quazimodo> i am probably just a bit  newb to look at this stuff
17:06:04 <quazimodo> ill keep reading and come back to it
17:06:07 <mgsloan>  foldr1 f [x]     =  x
17:06:07 <mgsloan> foldr1 f (x:xs)  =  f x (foldr1 f xs)
17:06:17 <augustss> quazimodo: many of the definitions are very short
17:06:29 <Saizan> scondil: i've seen something on the ByteString page
17:06:33 <quazimodo> mgsloan, ah ok
17:06:34 <nmessenger> there's just a big wall of them
17:06:49 <mgsloan> yep. the prelude surprised me when i was noobish (a few months ago) - its all written quite clearly, yet its like the core
17:07:43 * nmessenger notices that that link wasn't very helpful.  Most of the Prelude is imported
17:07:58 <quazimodo> mgsloan, the definition i read for foldr1 was foldr1f(x:xs) = x f(foldr1fxs) and was shown to me with operators such as . so it would go  1 . 2 . 3 . 4
17:08:22 <mgsloan> right
17:09:02 <mgsloan> which could be written (.) 1 ((.) 2 ((.) 3 ((.) 4)))
17:09:07 <quazimodo> yep
17:09:14 <quazimodo> and i didnt know that :)
17:09:26 <mgsloan> yeah, sometimes intro things are a bit unclear
17:09:28 <dcoutts__> scodil: yep, I wrote one for zlib and bzlib2, it is indeed linked from the ByteString page
17:09:30 <quazimodo> but this means that all operators in haskell are just infixed functions ?
17:09:36 <mgsloan> yep
17:09:38 <nmessenger> quaz: yes!
17:09:50 <quazimodo> lame + gay at the same time :/
17:09:53 <mahogny_> quazimodo: the way it should be :)
17:09:53 <dcoutts__> scodil: it's nice and easy, compress, decompress :: Lazy.ByteString -> Lazy.ByteString
17:09:58 <quazimodo> haha :)
17:10:02 <quazimodo> hay mahogny_ !
17:10:02 <mgsloan> quazimodo: why?
17:10:03 <nmessenger> quaz: heresy!
17:10:14 <shapr> quazimodo: Actually, it's quite nice, because operators aren't magic or special.
17:10:15 <quazimodo> im just kidding !
17:10:19 <mgsloan> oh
17:10:22 <quazimodo> its good
17:10:23 <nmessenger> quaz: lol!
17:10:25 <scodil> dcoutts__: yeah I was looking for something along the lines of gzwrite(file,ptr,numBytes)
17:10:30 <dcoutts__> scodil: in other words it does a whole stream (there are versions of the functions with more control over parameters too)
17:10:45 <mgsloan> yeah, you can even declare precedence for function operators.  eg, make `foo` bind more eagerly than *
17:10:53 <shankys> ?paste
17:10:53 <quazimodo> mahogny_, you come to this channel often, or after i mentioned it>
17:10:54 <lambdabot> http://paste.lisp.org/new/haskell
17:11:05 <mahogny_> quazimodo: often, but in periods
17:11:08 <dcoutts__> scodil: well you already know how to write a ByteString to a Handle
17:11:19 <scodil> dcoutts: i do?
17:11:27 <lisppaste2> shankys pasted "Problems With let's inside do's" at http://paste.lisp.org/display/33669
17:11:52 <shankys> Can anyone tell me why the code I pasted fails? I've been struggling with let's inside do's in this functions for a while.
17:11:53 <dcoutts__> scodil: check the ByteString docs, it's really jsut like writing a String to a file
17:12:03 <quazimodo> mahogny_, cool, i was talking about you to someone earlier since he went to chalmers. the conversation was like "you know mahogny, they crazy guy that studies like no other human?"
17:12:11 <shankys> I don't see why this shouldn't work -- maybe I'm missing something really obvious.
17:12:13 <augustss> shankys: looks like you still have tab/space problems.  the sql line is not lined up
17:12:13 <quazimodo> he didnt know you though :/
17:12:16 <nmessenger> quazimodo: in ghci, say ':i `someFunction`' to see its precedence.  I'm pretty sure the only ones explicitly specified are `elem` and `notElem`
17:12:22 <dancor> how do i do a lambda with two args
17:12:22 <mauke> shankys: how does it fail?
17:12:27 <dancor> \x, y -> x + y
17:12:34 <nmessenger> dancor: no comma
17:12:38 <mauke> dancor: \x y -> ... or \x -> \y -> ...
17:13:02 <monochrom> I'll take a look, shankys.
17:13:03 <shankys> augustss: But I've wrapped stuff up in {}'s and semicolons which should take care of the tab/space problem right?
17:13:04 <quazimodo> i have not learnt about elem and notElem yet
17:13:15 <scodil> dcoutts: ok so ByteString.packAddress is what i want, right? but where is the documentation for this function?
17:13:15 <nmessenger> dancor: you might also make a lambda of pairs: \(x,y) -> ...
17:13:19 <shankys> mauke: I'm getting a parse error on 'r'
17:13:31 <shankys> mauke: Which is the part after the let
17:13:31 <augustss> shankys: oh, ok.  how does it fail?
17:13:41 <nmessenger> ?type elem -- then ask LB!
17:13:42 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
17:13:50 <shankys> augustss: See my reply to mauke
17:13:55 <monochrom> I don't understand why the "sql $ ..." line is indented way to the right.
17:13:56 <nmessenger> ?. docs index elem
17:13:57 <lambdabot> Data.List, Prelude not available
17:14:39 <dcoutts__> scodil: it's probably in Data.ByteString.Base which is not documented. Do you really need that?
17:14:40 <monochrom> I think the presence of { ; } does not completely disable layout rules.
17:14:53 <nmessenger> > 'a' `elem` "abc"
17:14:55 <shankys> monochrom: It isn't in my editor but it shouldn't matter?
17:14:55 <lambdabot>  True
17:15:10 <augustss> monochrom: it does, unless you start a new block without {}
17:15:13 <monochrom> It matters.
17:15:15 <scodil> dcoutts: how else would you write a contiguous array to a compressed file?
17:15:33 <scodil> by way of elems? seems kind of round-about, doesn't it?
17:16:12 <monochrom> It sounds like an extra indentation is starting a new block without {}.
17:16:24 <dcoutts__> scodil: I don't follow completely, you just want to compress a ByteString and write it to a file ?
17:16:44 <dcoutts__> otherwise what is this contiguous array exactly ?
17:16:50 <monochrom> Haskell parsers follows the tab and space rules of the Haskell 98 standard, not your editor's standard.  I am sorry I have to say that.
17:17:22 <dcoutts__> scodil: packAddress is really very low level, it takes an Addr#, you'd probably use packCStringLen instead.
17:17:23 <shankys> monochrom: I thought I had my editor set to spaces only -- it seems it's not I guess...
17:17:27 <scodil> dcoutts: hah no the only reason ByteString was mentioned (and your interested piqued) is because I said I wanted to write to a zlib-comressed file, and someone said "use dcoutt's ByteString interface"
17:17:41 <LordBrain> in vim, set et, expandtabs
17:18:03 <dcoutts__> scodil: are you writing a whole file or re-writing a subsection?
17:18:09 <monochrom> I look at what you have pasted solely.  I think it is a faithful representation of what is going on.  I know that most editors lie to you.
17:18:11 <scodil> the whole file
17:18:21 <dcoutts__> scodil: then that's easy!
17:18:44 <dcoutts__> writeFile "foo.gz" (GZip.compress foo)
17:19:05 <monochrom> In the old days editors showed the real thing by default.  You had to sweat over configs to make it lie.
17:19:06 <scodil> whats foo?
17:19:11 <dcoutts__> scodil: a ByteString
17:19:27 <mbishop> foo is what Mr. T thinks you are
17:19:33 <mbishop> and he pittys you
17:19:34 <dcoutts__> scodil: and writeFile is really Data.ByteString.Lazy.writeFile
17:19:37 <scodil> and how do I make a ByteString from a Ptr Int?
17:19:40 <monochrom> Now editors misrepresent files by default.  You have to sweat over configs to see the truth.
17:19:44 <scodil> non-null terminated, even
17:19:53 <scodil> i'm just going to wrap gzwrite
17:19:58 <dcoutts__> scodil: using packCStringLen and castPtr
17:20:17 <monochrom> This whole world is completely fraudulent!
17:20:32 <mr_tenor> ed man!
17:20:45 <mauke> !man ed
17:20:47 <quazimodo> can i get permission to post about 5 or 6 lines from a messenger conversation i just had, it is funny?
17:20:53 <dcoutts__> scodil: writeFile "foo.gz" (GZip.compress (packCStringLen (castPtr ptr, len)))
17:21:07 <monochrom> #haskell-blah is suitable for that
17:21:19 <dcoutts__> scodil: a onw liner like that has to be nicer and easier than wrapping gzwrite :-)
17:21:23 <quazimodo> yeh but you guys arent there
17:21:24 <monochrom> unless you're pasting a haskell joke.  make it a good one.
17:21:35 <augustss> shankys: I finally figured out what's wrong
17:21:50 <scodil> dcoutts: perfect, thanks.
17:21:50 <shankys> augustss: Oh?
17:21:57 <mgsloan> quazimodo: or paste it in rafb or something
17:21:57 <augustss> shankys: your let introduces a new non-{} block
17:22:06 <augustss> you need to write 'let {x=1};
17:22:31 <monochrom> OH!  augustss is good!
17:22:36 <shankys> augustss: Oh! I knew it wasn't tabs/spaces issues... Thanks a lot :)
17:23:23 <quazimodo> quazi:  it has infixing too
17:23:24 <quazimodo> quazi:  so you have say a function
17:23:24 <quazimodo> quazi:  myFunction arg1 arg2 = blabla
17:23:24 <quazimodo> quazi:  you can do passedArg1 `myFunction` passedArg2 as well as standard myFunction passedArg1 passedArg2
17:23:24 <quazimodo> quazi:  makes life so easy
17:23:24 <quazimodo> (Labbeik, allahum, labbeik:  i'm buying you friends next chrissie
17:24:01 <monochrom> You know what,  arg1 `myFunction` arg2 = blabla   works too.
17:24:28 <quazimodo> im thinking perhaps you missed the joke?
17:25:09 <monochrom> Yes. But I don't know.
17:28:12 <quazimodo> methinks my friends joke just hurt everyones feelings so they stopped talking?
17:28:15 <quazimodo> :P
17:28:41 <mr_tenor> no, it's not haskell or category theory, so they're not interested
17:28:56 <shapr> I'm writing code.
17:29:11 <shapr> I heard back from Oleg, but I forgot to ask about the v::v stuff! argh!
17:29:15 <augustss> I'm just idling.
17:29:35 <augustss> shapr: so you've not solved that problem?
17:29:47 <shapr> augustss: What do you think about proof programming? That is, generating programs from proofs?
17:29:47 <augustss> shapr: I can give you a workaround
17:29:48 <mr_tenor> i'm pondering porting a game i started in ruby to haskell because i'm finding ruby not much fun
17:29:54 <shapr> augustss: Nah, I went unicycling instead :-)
17:29:57 <shapr> augustss: Yes please!
17:30:31 <augustss> shapr: can you paste it again?
17:31:26 <augustss> shapr: Generating programs from proofs is not a bad idea.  but if you are only concerned with proving you are unlikely to get an efficient program.
17:31:30 <lisppaste2> shapr pasted "v::v problem" at http://paste.lisp.org/display/33670
17:31:53 <shapr> augustss: Actually, I'm interested in generating efficient programs from proofs.
17:32:51 <shapr> I suspect proof programming is the wave of the future. My interest is mostly on how to generate *efficient* programs.
17:32:53 <lisppaste2> augustss annotated #33670 with "a workaround" at http://paste.lisp.org/display/33670#1
17:33:09 <mgsloan> I'l bet its a wave of the future
17:33:19 <augustss> shapr: with the right proof you'll get efficient code
17:33:52 <shapr> Yeah, but general proofs end up being more generally applicable, and result in slower programs.
17:34:08 <shapr> So I wonder if compiler optimizations have been turned into their equivalent proofs as well?
17:34:32 <shapr> Would that work?
17:34:40 <augustss> shapr: I'm not sure what that statement means.
17:35:00 <augustss> You mean proving that the optimizationa re correct?
17:35:03 <shapr> I read a recent paper where .. fibonacci? was generated from a proof.
17:35:05 <yaxu> dcoutts__: bah, i can't make a screencast, would involve having two processes reading from /dev/dsp which my sound driver can't cope with
17:35:17 <dcoutts__> yaxu: :-(
17:35:20 <shapr> I think it took days to get fib!!5 from the generated program.
17:35:31 <dcoutts__> yaxu: how about one with no sound ?
17:35:41 <shapr> One optimization that gave a massive speed increase was to declare 0 < 1 as an axiom.
17:35:42 <augustss> shapr: Xavier Leroy has made a C compiler in Coq.  An optimizing compiler.
17:36:01 <shapr> Hm, I think it might have been a paper by him that I read, I'm not sure.
17:36:35 <augustss> shapr: the compiler is made by program extraction from the proof
17:36:51 <quazimodo> does indentation matter in haskell?
17:37:01 <augustss> quazimodo: very much!
17:37:03 <shapr> In any case, it seems to me that if such simple properties can generate faster programs, the smart approach is for humans to suggest certain optimization properties to be proved correct, and then see if that speeds up the resulting program.
17:37:10 <quazimodo> so the compiler actually looks for indentation?
17:37:17 <quazimodo> odd language :/
17:37:19 <augustss> quazimodo: yes
17:37:31 <augustss> quazimodo: it feels strange at first
17:37:50 <liyang> you can override it with braces and semicolons though
17:38:00 <augustss> quazimodo: but once you get used to it, it's very natural
17:38:27 <shapr> yaxu: tee ?
17:38:32 <augustss> yes, you have a choice, {;} or indentation
17:38:35 <shapr> yaxu: Or esd? Or ALSA?
17:38:54 <quazimodo> augustss, the braces do seem to be the safer choice?
17:39:15 <augustss> quazimodo: well, it's not how Haskell code is typically written
17:39:16 <liyang> quazimodo: indentation is easier on the eyes...
17:39:25 <nmessenger> quazimodo: indentation is mostly only applicable in special syntax forms like 'do', 'let', 'where', etc
17:40:15 <augustss> quazimodo: if you want to read code you might as well get used to indentation
17:40:31 <quazimodo> i never had a problem reading code with brackets :/
17:40:34 <shapr> augustss: thanks for the type fix!
17:40:38 * shapr boings cheerfully!
17:40:45 <nmessenger> quazimodo: RESISTANCE IS FUTILE!
17:40:58 <shapr> Capacitance, on the other hand...
17:41:03 <augustss> YOU WILL BE INDENTED!
17:41:09 <quazimodo> hahah
17:41:10 <quazimodo> ok ok
17:41:24 * nmessenger rolls his eyes into the back of his head
17:41:37 <shapr> Poultrygeist!
17:41:51 <wchogg> Haskell syntax is suppose to look a lot like real math, and mathematicians don't separate statements in proofs with semicolons.
17:42:03 <quazimodo> i think its cool you can do func a b = c d where c = somfunc a, d = someotherfunc b
17:42:11 <mgsloan> shapr - I recently played that song - its a jazz song
17:42:18 <yaxu> dcoutts__: wouldn't be much good without sound
17:42:23 <mgsloan> by that one guy obsessed with chickens
17:42:25 <dcoutts__> oh ok :-(
17:42:31 <nmessenger> ?google poultrygeist song
17:42:33 <lambdabot> http://forums.tromaville.com/viewtopic.php?t=1359&sid=413d4358ba8e17be204ce39ca40421f3
17:42:41 <quazimodo> shapr, poultrygeist? chicken-geist?
17:42:45 <yaxu> shapr: a bit too low level for tee, i'm looking at software mixing in alsa with oss emulation right now...
17:44:02 <mgsloan> oh, it was actually Poultry Guest
17:44:08 <nmessenger> quazimodo: turkey discriminator.
17:45:36 <shapr> Speaking of jazz, it's time for Louis Armstrong!
17:46:08 <nmessenger> velco must not like jazz
17:47:11 <quazimodo> ergh stupid emacs doesnt do the indentations right, stupid thing
17:47:22 <danjafagw> i know this is relaly simple, but how would i write a function that a program
17:47:22 <danjafagw> that reads from standard input and prints to standard output each line with
17:47:22 <danjafagw> the characters reversed.
17:47:29 <danjafagw> oops
17:47:30 <danjafagw> sorry
17:47:30 <danjafagw> but yeah
17:48:15 <lisppaste2> zeeeee annotated #33603 with "to all (but esp. benja_): how can i make this nicer, if i can? can i somehow use monads/do instead of my own operator?" at http://paste.lisp.org/display/33603#4
17:48:31 <nmessenger> > putStr =<< liftM (unlines . map reverse . lines) getContents
17:48:33 <lambdabot>  <IO ()>
17:48:38 <Saizan> quazimodo: you just have to install haskell-mode and than hit tab till it get it right :)
17:48:56 <mauke> main = interact (unlines . map reverse . lines)
17:49:06 <nmessenger> oh yeah, interact
17:49:43 <danjafagw> thank you very much
17:50:18 <quazimodo> i have haskell-mode installed but every time i click tab it goes 1 tab extra :/
17:50:35 <syntaxfree> associative arrays are not the same as arrays, right?
17:50:50 <nmessenger> assoc arrays usually mean [(a,b)]
17:51:00 <syntaxfree> I'm reading a little story about javascript, and they speak of "pushing" objects into an assoc array.
17:51:10 <syntaxfree> Shouldn't arrays be fixed-size?
17:51:36 <mauke> syntaxfree: not in perl
17:51:40 <Saizan> in js they are basically Data.Map
17:51:42 <blsecres> syntaxfree: associative arrays are similar to hashes
17:51:44 <yaxu> ok that worked, but i got the offset wrong so it's just a video of an application menu bar
17:51:45 <nmessenger> javascript arrays are kinda loose
17:51:56 <syntaxfree> ahh. they're Maps.
17:52:09 <nmessenger> syntaxfree: as are all things in js
17:52:20 <shapr> yaxu: Sounds exciting!
17:52:24 <syntaxfree> JS supports HOFs. I appreciate that.
17:52:27 <shapr> yaxu: How did you do the livecoding demo?
17:52:31 <syntaxfree> It's also Available Everywhere.
17:52:39 <scodil> dcoutts: did you ever figure out what the deal was with building gtk2hs w/ profiling support? is it easy yet, or still difficult?
17:52:49 <nmessenger> HOF?
17:52:50 <dcoutts__> scodil: still difficult
17:52:57 <Saizan> higher order funcs
17:52:59 <scodil> bummer
17:53:03 <yaxu> shapr: you mean my earlier screencast?
17:53:11 <syntaxfree> there's an "iterator" that's almost-almost a map.
17:53:13 <dcoutts__> scodil: I'll see about making it easier for this upcomming release which should be in a week or two
17:53:21 <shapr> yaxu: yeah
17:53:29 <syntaxfree> I should write mini-lisp/haskell in JavaScript.
17:53:34 <yaxu> shapr: i recorded it with ffmpeg, easier because ffmpeg was the only thing wanting to read from /dev/dsp
17:53:34 <syntaxfree> fold, map, filter, etc.
17:53:44 <yaxu> shapr: now the haskell is reading from /dev/dsp as well
17:53:48 <scodil> dcoutts: awesome.
17:54:31 <scodil> dcoutts: also, since your here, whats the status on the more-haskellish tree/listview widgets?
17:54:31 <nmessenger> syntaxfree: Javascript is a lot nicer than many people think, but anon func syntax isn't very sexy.
17:55:01 <syntaxfree> i like codinghorror.com
17:55:11 <dcoutts__> scodil: you can play with it, it's in the pre-release http://haskell.org/gtk2hs/0.9.10.3.tar.gz
17:56:28 <dcoutts__> scodil: there are some demos of the new api included
17:56:48 <shapr> yaxu: Oh, I see.
17:57:34 <scodil> dcoutts: rad. i'm actually using gtk2hs quite a bit now. its one of those deals where I'm writing prototype software for people who aren't really paying for it, so it will end up being the production software, so you'll probably be getting emails in 5 years asking "what is haskell and how do I install it?"
17:57:45 <shapr> augustss: Oleg uses code like your code elsewhere...
17:57:46 <blsecres> looking forward to the new listview, the old one was the reason I had to put gtk2hs aside for a while
17:58:20 <dcoutts__> scodil: heh, heh, setting up a lucrative line in consultancy eh? :-)
17:58:29 <lisppaste2> shapr pasted "v::v part tv" at http://paste.lisp.org/display/33672
17:58:40 <dcoutts__> blsecres: aye, the old one made us all want to vomit :-)
17:59:01 <scodil> dcoutts: yeah something like that, instead of job security though, i'm ensuring funding for my phd, so I can take my sweet time
17:59:09 <dcoutts__> nice
17:59:16 <dcoutts__> blsecres: there are no more TreeIters for one thing
17:59:28 <shapr> @remember scodil dcoutts: rad. i'm actually using gtk2hs quite a bit now. its one of those deals where I'm writing prototype software for people who aren't really paying for it, so it will end up being the production software, so you'll probably be getting emails in 5 years asking "what is haskell and how do I install it?"
17:59:36 <shapr> @quote
17:59:36 <lambdabot> JonFairbarn says: I think we should call it "Abstraction Oriented Programming". It's got the "oriented" buzzword in it, and we don't need to tell folk that "abstraction" means more than one thing to
17:59:36 <lambdabot> us until we're sure they're OK.
18:00:24 * shapr tries to understand augustss's code in order to apply the same idea here...
18:00:32 <dcoutts__> blsecres: check out the demos that use the new api and tell us what you think, I think there's still room for improvement but it's much much better
18:01:23 <blsecres> dcoutts__: I'll try and dig out the code that was crashing on me regularly
18:01:33 <dcoutts__> blsecres: the stuff about columns, cell renderers and so on is still non-trivial, but perhaps that just needs some wrappers for the simple case
18:02:02 <dcoutts__> blsecres: oh crasher bugs? that'd should be our fault not yours so if it still borks to report it.
18:02:14 <scodil> dcoutts: i get a 404 on that link: http://haskell.org/gtk2hs/0.9.10.3.tar.gz
18:02:20 <dcoutts__> scodil: oops
18:02:27 <dcoutts__> http://haskell.org/gtk2hs/gtk2hs-0.9.10.3.tar.gz
18:02:33 <scodil> thx
18:03:52 <blsecres> dcoutts__: OK, couldn't figure out whether the issue was the library's fault or mine for trying to (un)load a liststore with too much data
18:05:08 <dcoutts__> blsecres: segfaults should almost always be the fault of gtk+ or gtk2hs and not you, so you can and should report them to us and we'll do our best to track it down
18:05:31 <dcoutts__> though it's much easier with a small test case to look at
18:05:43 <dcoutts__> and I can't fix OSX problems sadly :-(
18:08:05 <dibblego> ?where hackagedb
18:08:07 <lambdabot> http://hackage.haskell.org/ModHackage/Hackage.hs?action=home
18:08:53 <MarcWeber> http://rafb.net/p/rHjGnT55.html
18:08:56 <lambdabot> Title: Nopaste - How to access the value of the inner reader monad?
18:10:29 <Saizan> ?type ask
18:10:31 <lambdabot> forall r (m :: * -> *). (MonadReader r m) => m r
18:10:36 <Saizan> ?type liftM
18:10:37 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
18:10:47 <Saizan> ?type liftM ask
18:10:49 <lambdabot> forall r (m :: * -> *). (Monad m) => m r -> m r
18:11:03 <Saizan> ?type lift ask
18:11:04 <lambdabot> forall (t :: (* -> *) -> * -> *) (m :: * -> *) r. (MonadTrans t, MonadReader r m) => t m r
18:11:27 <Saizan> the latter i suppose
18:12:12 <MarcWeber> Saizan: Thanks. I can see it now. *me feels happy again*
18:14:28 <yaxu> http://slub.org/20010203.avi # takes a while to get started and yes, it is supposed to sound like that (probably)
18:14:58 <yaxu> (that's the screencast i just did)
18:15:42 * shapr slurps it down
18:16:10 <Saizan> MarcWeber: by the way, in your definition of run, i is what you pass to the outer monad and o to the inner
18:16:31 * yaxu makes one with more conventional music
18:17:49 <MarcWeber> Saizan: You're right. thanks.
18:18:26 <monochrom> yaxu: so you have solved the choppy problem?
18:18:44 <blackdog> yoyo shapr. am back hacking haskell, and it only took killer earache and insomnia to do it
18:18:45 <dino-> @paste
18:18:46 <lambdabot> http://paste.lisp.org/new/haskell
18:19:25 <sorear> @seen
18:19:25 <lambdabot> Lately, I have seen blackdog, dcoutts__, dibblego, dino-, marcweber, monochrom, saizan, shapr, sorear, svnbot6 and yaxu.
18:19:39 <syntaxfree> 11:53 PM  lambdabot: JonFairbarn says: I think we should call it "Abstraction Oriented Programming".
18:19:46 <syntaxfree> I'm trying to push "Programming 2.0"
18:19:53 <monochrom> heh heh heh
18:20:06 <monochrom> I move for "Programming 7"
18:20:23 <yaxu> monochrom: yes, with ffi and a call to ioctl
18:20:26 <lisppaste2> dino- pasted "Monad transformers help" at http://paste.lisp.org/display/33674
18:20:47 <dino-> I'm going through the Monad Transformers wikibook and am having trouble with the MaybeT implementation (in the paste)
18:21:05 <monochrom> Is the ioctl call to change kernel buffering?
18:21:06 <dino-> Specifically, trying to write the corresponding return function for this monad.
18:22:41 <psi> ?hoogle (a -> Bool) -> [a] -> a
18:22:42 <lambdabot> No matches, try a more general search
18:23:01 <Saizan> yaxu: animated is way cooler than the images :O
18:23:08 <dino-> I tried  return = MaybeT  and  return v = MaybeT $ Just v  but, no gots and not sure what I'm doing wrong.
18:23:59 <monochrom> return {- for MaybeT m -} x = MaybeT (return {- of m -} (Just x))    {- how about this? -}
18:24:10 <sorear> there needs to be something that uses the type of the base monad
18:25:06 <dino-> monochrom: Hm. So the Just puts it into the bottom layer. The return does the middle one (the m) and then MaybeT because that's the monad we're writing this function for.
18:25:16 <sorear> yes.
18:25:23 <monochrom> sorear is right, and if m is the base monad, return {- of m -} provides that.
18:26:20 <monochrom> I am inspired by: newtype MaybeT m a = MaybeT { runMaybeT :: m (Maybe a) }.
18:26:50 <monochrom> I practice type-oriented programming.
18:26:53 <dino-> monochrom: That's directly out of the text I'm reading at http://en.wikibooks.org/wiki/Haskell/Monad_transformers
18:27:13 <monochrom> Yes.
18:28:55 <dino-> Is this normally how it's done with these transformers? Using a record data type?
18:30:01 <sorear> yes
18:30:40 <monochrom> It is a lazy way to write two lines of code:
18:30:56 <monochrom> newtype MaybeT m a = MaybeT (m (Maybe a))
18:31:12 <monochrom> runMaybeT (MaybeT blah) = blah
18:31:26 <shankys> I have a quick question: If I have r which is of type [(String, String, String, String, String, String)] and I want to map a function across only the third string in each tuple in the list, is there a nice one-liner to do that?
18:32:01 <emu> that type is screaming to be a record
18:32:05 <shankys> I feel like there ought to be, but I can't think of it
18:32:35 <nmessenger> map (\(a,b,c,d,e,f) -> (a,b,f c,d,e,f)) -- :)
18:32:46 <Korollary> well, lambdas have patterns. You can use map \(a,b,c,d,e,f) -> do something with c.
18:32:48 <nmessenger> er, rename 'f c'
18:32:56 <emu> but yea
18:33:34 <shankys> Oh, duh...
18:33:37 <shankys> Thanks.
18:33:40 <dino-> Ah, I see. It seems confusing the way the record looks. Perhaps I bring baggage from languages with classes.
18:33:58 <dino-> OO languages
18:34:32 <nmessenger> let tup6_3 fn (a,b,c,d,e,f) = (a,b,fn c,d,e,f)
18:34:34 <dino-> monochrom, sorear: Thanks a lot.
18:58:11 <nmessenger> shall I also leave and rejoin?
18:58:32 <LoganCapaldo> nmessenger: netsplit?
18:58:55 <nmessenger> LoganCapaldo: I suppose.  *still a newbie*
19:01:09 <shapr> blackdog: hiya!
19:01:16 <blackdog> hey dude
19:01:23 <shapr> Wassup?
19:01:28 <jcreigh_> @type error
19:01:29 <lambdabot> forall a. [Char] -> a
19:01:44 <jcreigh_> How does "error" work? Is it magic?
19:01:54 <nmessenger> [Char]?  Why doesn't it say String?
19:01:55 <blackdog> haven't hacked anything but embedded basic and dodgy c-based guis for a while - i almost forgot what programming for fun felt like :)
19:02:19 <Korollary> yes, error is magic implemented by the compiler.
19:02:30 <nmessenger> jcreigh_: basically just blows up your prog :)
19:02:38 <shapr> blackdog: What are you writing?
19:02:48 <blackdog> finger exercises
19:02:53 <shapr> huh?
19:03:01 <blackdog> doing some of the problems on the project euler site
19:03:27 <blackdog> got earache and insomnia, so i went to the haskell site and started poking around
19:03:28 <jcreigh> nmessenger: I know what it does. I'm just wondering how it does it. (ie, compiler black magic, unsafePerformIO or whatever)
19:03:42 <blackdog> fixed some of dons' grammar then started working on silly problems. :)
19:04:26 <shapr> Sounds like fun to me.
19:04:33 <Nafai> Hey shapr
19:04:37 <shapr> hiya Nafai
19:05:42 <shapr> yaarg: I like the music, but I think the screen part is broken.
19:05:49 <shapr> argh, yaxu
19:14:15 <augustss> jcreigh: yes, error have to use some kind of magic
19:14:17 <dancor> groupPairs :: [(a, b)] -> [(a, [b])]
19:15:05 <augustss> groupPairs?
19:15:14 <dancor> i want to go from like [('a',4),('b',3),('a',6)] to [('a',[4,6]),('b',[3])]
19:15:35 <dancor> should i sort the list on a first and then collapse the contiguous same-a regions?
19:15:42 <augustss> groupBy ((==) `on` fst) . sortBy (compare `on` fst)
19:15:47 <Korollary> use Data.Set
19:16:15 <Korollary> err Data.Map
19:17:12 <augustss> that works too, using insertWith
19:17:34 <Korollary> augustss: how are your haskell lackeys doing?
19:17:54 <augustss> Korollary: you mean the users? :)
19:18:12 <dibblego> saddam = undefined
19:18:14 <Korollary> yeah
19:18:53 <augustss> Korollary: there's only like 3 users so far.  they seem to be doing great.  a larger scale rollout will happen in a few months
19:19:30 <Korollary> augustss: Did the 3 know any FP before?
19:23:57 <deadbeef> saddam hussein has just been executed
19:24:04 <augustss> one of them had a course on Haskell at university
19:24:32 <mgsloan> is this one of your langs?
19:25:13 <augustss> mgsloan: are you asking me?
19:26:09 <mgsloan> yep
19:27:06 <augustss> mgsloan: it's DSL, embedded in Haskell
19:27:43 <mgsloan> ah, I remember you were doing dependent types - Cayenne and something else...
19:27:50 <augustss> mgsloan: so in some sense it's another language, but using a lot of haskell infrastructure
19:28:04 <augustss> mgsloan: Bluespec?  pH?
19:28:41 <fabiim> augustss : thanks for the multiple parameter  tip
19:28:53 <augustss> fabiim: it worked out?
19:28:55 <mgsloan> could be.  Ahwell, I'll probably be messing around with my visual language once I ascertain that I can't figure out a better IO metaphor
19:29:47 <augustss> mgsloan: this DSL is a little bit different than many.  when you run the haskell code it generates the real program.
19:30:22 <mgsloan> oh, interesting
19:30:32 <fabiim> well ,  don't know , ghci does not deal with that right away , trying to figure out how to make it work
19:30:39 <mgsloan> so since its a DSL, the actual generator is indeed haskell
19:32:31 <mgsloan> hmm, by my sentence a few messages back I mean that my visual language will likely translate to haskell, unless I can figure out something more fitting for IO, and perhaps monads in general.
19:32:58 <mgsloan> Even then likely initial versions will use haskell as the backend
19:33:10 <augustss> interesting, since I generate a visual language of sorts.  I generate Excel. :)
19:33:27 <mgsloan> hehe, crazy
19:33:28 <SamB_XP> excel isn't really a visual language...
19:33:35 <mgsloan> I actually tried generating excel
19:33:43 <SamB_XP> hahaha
19:33:51 <mgsloan> before, for a completely unrelated thing
19:34:00 <SamB_XP> .... oh ;-)
19:34:01 <mgsloan> (yeah, that statement is funnier out of context)
19:34:06 <shankys> If I have a function f of type Int -> IO String and want to do: map (\(a b c) -> (a, f b, c)) [("1", "2", "3"), ("4", "5", "6")] -- how would I do that (I know that map code doesn't work, but I want to pull off a similar effect)? I want the output of the map to be of type IO [(String, String, String)] or [(String, String, String)].
19:34:09 <ctkrohn> If someone could make a Haskell library that generated Excel macros, that would be fantastic
19:34:20 <SamB_XP> mgsloan: it is funnier in the context of your visual language, I think ;-)
19:34:28 <ctkrohn> I'll be working at a bank after I graduate... I spent a ton of time there this summer coding VBA among other things
19:34:31 <ctkrohn> so much pain ;_;
19:34:31 <mgsloan> Instead I just outputted openoffice charts, which are opened up and saved as excel
19:34:32 <mr_tenor> mgsloan: can you implement excel in haskell in a few months?
19:34:40 <mgsloan> noo way
19:34:49 <mgsloan> well, maybe an interpreter
19:34:56 <mr_tenor> <mgsloan> I actually tried generating excel
19:34:58 <augustss> ctkrohn: well, i'm doing that.  but the bank is unlikely to give it away
19:34:59 <mgsloan> even then it'd be a long slog and probably leave out things
19:35:11 <mgsloan> would have much to learn
19:35:19 <ctkrohn> augustss: unsurprising, I guess
19:35:48 <mgsloan> SamB_XP = heh, yeah
19:36:26 <augustss> shankys: mapM (\ (a,b,c) -> do b' <- f b; return (a, b', c)) [...]
19:36:34 <dancor> augustss: what is that `on` fcn?
19:36:55 <shankys> augustss: Ah, just what I was looking to do. Thanks :)
19:37:25 <augustss> op `on` f = \ x y -> f x `op` f y
19:37:55 <dancor> why can't hoogle find it, did you invent it
19:37:57 <augustss> dancor: it's going into the standard libraries, but might not be there yet
19:38:01 <dancor> ah
19:39:23 <augustss> ctkrohn: my stuff actually generates very little VBA, it generates a UI and excel formulae to go with it
19:40:13 <augustss> mgsloan: the way to generate Excel sheets is to generate the XML version.  it's pretty ok
19:40:24 <mgsloan> ohh, MS's new format
19:40:36 <mgsloan> the old one was basically impossible
19:40:48 <SamB_XP> it isn't the default format though is it?
19:40:55 <mgsloan> unless you are very determined
19:41:03 <augustss> it's not the default
19:41:27 <mgsloan> yeah, MS's formats used to be insane - all encrypted and obtuse and such
19:41:34 <SamB_XP> so they allow tool support for writing, but not easy compatability for everyday usage?
19:41:48 <SamB_XP> that makes sense in a twisted kind of way...
19:41:53 <mgsloan> yep
19:42:02 <mgsloan> you wanna view doc files? buy office.
19:42:09 <ctkrohn> augustss: makes sense
19:42:28 <SamB_XP> oh, you wanna write a tool to *generate* excel? heres a nice little XML format for you ;-)
19:42:29 <mgsloan> of course, OOO helps with that
19:42:57 <mgsloan> yep, the fact that that exists pretty much prove it
19:43:08 <mgsloan> *proves
19:43:11 <SamB_XP> an XML format that we could easily have made the default, but decided not to because that would make competition too easy
19:44:01 <mgsloan> actually, my bad, I had to read excel sheets and create a text file based on it
19:44:17 <augustss> mgsloan: you can also save as XML :)
19:44:23 <mgsloan> so you had to convert with openoffice to the much more sensible format
19:44:26 <mgsloan> ah, huh
19:44:35 <SamB_XP> augustss: which doesn't help much :-(
19:44:37 <mgsloan> how long has it been like that?  because this was like 3 years ago
19:44:52 <augustss> excel 2005, i think
19:45:01 <mgsloan> oh, ok then
19:45:10 <augustss> of course, it can't save everything.  that would be too easy
19:45:14 <augustss> nor load
19:45:19 <SamB_XP> augustss: oh?
19:45:21 <SamB_XP> hmm.
19:45:24 <augustss> for instance, no VBA save/load
19:45:41 <SamB_XP> is that a deliberate anticompetive strategy?
19:45:52 <Adamant> of course
19:45:56 <mgsloan> probably because then xml would be far too easy for malicious people
19:46:01 <augustss> i cen never tell if it's that or just plain incompetence
19:46:09 <Adamant> also laziness, of course
19:46:19 <Adamant> not the good kind
19:46:24 <augustss> i think excel 2007 can save and load the VBA too
19:46:31 <SamB_XP> or maybe they actually just don't want to expose their highly dangerous scripting language to OSS people?
19:47:14 <mgsloan> one time they released a version of the .net directx 9/10 binding, and left a bunch of crap out
19:47:54 <augustss> well, MS seems to have huge APIs.  it's a lot of work
19:48:01 <mgsloan> that the previous stuff had
19:48:06 <augustss> oh
19:48:09 <mgsloan> yeah, they do have giant APIs
19:48:17 <mgsloan> yeah, it wasn't intentional
19:48:27 <mgsloan> the documentation had loads of classes and methods that didn't exist
19:48:30 <augustss> looking closer into excel is really scary, btw
19:48:40 <mgsloan> what's sad is how long it took to fix
19:48:52 <mgsloan> they basically said "ahhh, just wait for the next version..."
19:49:07 <SamB_XP> mgsloan: maybe they had forgotten to write the bindings?
19:49:08 <augustss> i had never imagined that they would use floating point
19:49:22 <SamB_XP> augustss: you don't have much imaganation!
19:49:29 <mgsloan> Samb - nah, they were there in previous versions
19:49:30 <Korollary> augustss: they have to
19:49:48 <SamB_XP> Korollary: for storage?
19:49:56 <mgsloan> augustss: :O my uncle actually used excel for his Boeing engineering calculations...
19:50:10 <augustss> so that means that adding up 100 times 1 cent will not make a dollar
19:50:15 <Korollary> rephrase: had to. There are a lot of huge excel files and performance mattered
19:50:34 <augustss> do compensate for that they have ruined IEEE floating point addition and subtraction
19:50:57 <SamB_XP> huh. they ought to use decimal floating point...
19:51:04 <mr_tenor> yeah, it's scary how much important work is done in excel
19:51:06 <augustss> + and = in excel does not do FP + and -
19:51:32 <augustss> they fiddle with the last 4 bits under certain circumstances
19:52:00 <mr_tenor> oh great
19:52:01 <augustss> to make up for floating point being the wrong choice for the job
19:52:34 <mgsloan> jeez.  they could have at least added a "exact calculation" button
19:52:36 <mr_tenor> typical MS... (1) bad decisions (2) broken fixes piled waist deep (3) profit
19:52:37 <augustss> so now it looks good a lot of the time, but is even more inaccurate for some other things
19:52:45 <mgsloan> at least then you could get the right answer
19:57:24 <SamB_XP> ... decimal would have been better, definately
20:04:30 <dancor> does anyone think it's a good idea to always import .. as
20:04:59 <dancor> as opposed to dropping the as
20:05:10 <SamB_XP> I rarely use as
20:05:20 <SamB_XP> except when I am doing a qualified import
20:06:12 <augustss> right, for instance Data.Map and Data.Set
20:06:18 <SamB_XP> yeah
20:06:25 <augustss> where the names clash with Prelude names
20:36:53 <araujo> :-)
20:56:23 <quazimodo> is there a list of things i cant use for function names
20:56:34 <quazimodo> suppose i try to use reverse as a function name, for example
20:57:07 <quazimodo> a sensible thing to do would be reserve all things such as Reserve or SomeFunction that are in built with a capital at the front as well as intercapping
20:57:25 <LoganCapaldo> quazimodo: you can use anything. it'll just hide the eixisting defn if it exists
20:57:36 <Cale> reverse exists in the prelude, so if you use it as a function name, you should hide it from the Prelude
20:57:40 <quazimodo> but you lose things like reverse?
20:57:50 <Cale> you'd do
20:57:58 <Cale> import Prelude hiding (reverse)
20:58:04 <LoganCapaldo> you can say Prelude.reverse iirc
20:58:11 <quazimodo> hrm
20:58:12 <quazimodo> thats ok
20:58:17 <Cale> or, sure, use it qualified everywhere
20:58:31 <Cale> Obviously, you also can't use keywords for function names.
21:03:06 <quazimodo> i want a function called wher!
21:03:08 <quazimodo> where!
21:03:19 <mr_tenor> go ":t reverse" in ghci i you're not surewhether it's taken ;)
21:04:29 <Cale> It might be sensible to have a function named if, but you can't have it of course. :)
21:05:13 <Cale> However, you can define   if' i t e = case i of True -> t; False -> e
21:05:48 <quazimodo> scared ;/
21:06:00 <Cale> Or just  if' i t e = if i then t else e
21:06:35 <Cale> I just wrote it that way to show that there's no need for if to be primitive, it's purely syntax sugar (however important that syntax sugar is)
21:07:09 <LoganCapaldo> heck theres no need to write if period
21:07:23 <LoganCapaldo> @djinn Bool -> a -> a -> a
21:07:24 <lambdabot> f a b c =
21:07:24 <lambdabot>   case a of
21:07:24 <lambdabot>   False -> c
21:07:24 <lambdabot>   True -> b
21:07:30 <LoganCapaldo> see, it writes itself
21:08:23 <quazimodo> what does False -> c mean?
21:08:28 <quazimodo> does that mean a will get the value of c?
21:08:30 <Cale> it's a pattern match
21:08:32 <quazimodo> or c gets the value of a?
21:08:37 <quazimodo> erm ok
21:08:41 <Cale> it's not an assignment
21:08:44 <quazimodo> okok
21:08:50 <quazimodo> so we are saying if an a exists in c?
21:08:58 <Cale> If a is False, the result is c
21:09:14 <Excedrin> if a is equal to False, then the entire case expression evaluates to c
21:09:38 <Excedrin> that case could be written as an equivalent if expression: if a then b else c
21:09:44 <quazimodo> ok
21:09:58 <Cale> function bindings with multiple definitions are automatically turned into case expressions
21:10:04 <Cale> So it's like we wrote
21:10:17 <quazimodo> so we could say if function a returns a False, do function c ?
21:10:17 <Cale> if' True t e = t
21:10:21 <Cale> if' False t e = e
21:10:28 <quazimodo> i didnt know how haskell ifs worked
21:10:28 <Cale> like that
21:10:40 <Cale> > if True then 5 else 6
21:10:41 <lambdabot>  5
21:10:45 <Cale> > if False then 5 else 6
21:10:46 <lambdabot>  6
21:11:17 <Cale> that's basically how if works in Haskell, if you know C, then it's roughly like the ternary operator there.
21:11:19 <dancor> what if i want the same enum value in two different enums
21:11:31 <Cale> dancor: then you're out of luck
21:12:27 <dancor> well i could do it in separate files and import them
21:12:32 <Cale> well, okay
21:12:41 <Cale> but they still wouldn't be the same value
21:12:58 <Cale> and you'd have to use them qualified
21:13:29 <Cale> If you don't care about pattern matching, you could do something like create a typeclass.
21:13:42 <Cale> Usually it's just best to name the values slightly differently
21:14:03 <Cale> Perhaps by prepending or appending them with a couple letters from the type name
21:16:44 <LoganCapaldo> It wouldn't be so bad if you could do data A = A; data A' = A; x = A :: A; y = A :: A'
21:17:52 <Cale> If you wanted to do it in a way which was at all meaningful, it's quite tricky.
21:19:20 <LoganCapaldo> Cale: I'm pretty sure its just that people want to avoid someShortPrefixA someOtherPrefixB
21:19:22 <Cale> If you have to give explicit type signatures to every occurrence of A, then why not just rename the values? The type signature has just become part of the name.
21:19:39 <quazimodo> i think i will write a script that runs every few hours, checks my external ip and makes sure my no-ip account has that ip
21:19:46 <LoganCapaldo> Cause you could be a little more implict than that
21:19:56 <LoganCapaldo> f :: A -> B vs. g :: A' -> B
21:20:12 <LoganCapaldo> and then you do a case x of ...
21:20:14 <quazimodo> would a haskell script be a good idea?
21:20:30 <quazimodo> id probably have to talk to lynx to log in and change things around?
21:20:40 <Cale> quazimodo: you could do that. Personally, I just have a shell script doing that.
21:20:51 <Cale> er, but I don't use no-ip
21:20:51 <iulus> quazimodo: if you're already familiar with perl, that'd work well with LWP
21:20:54 <SamB_XP> quazimodo: they already have some things for that...
21:21:05 <quazimodo> SamB_XP, who does?
21:21:08 <Cale> Does no-ip support an update protocol like gnudip2?
21:21:10 <quazimodo> and i know no perl
21:21:24 <iulus> then that's probably out
21:21:25 <SamB_XP> try ddclient?
21:21:32 <quazimodo> and why use a shell script instead of haskell
21:21:49 <iulus> best tool for the job
21:21:59 <Cale> quazimodo: because presumably it's one line :)
21:22:07 <iulus> it interfaces with lynx, other programs better, probably.
21:22:09 <Cale> or at most 2
21:22:24 <SamB_XP> lynx?
21:22:24 <Cale> Interfacing with lynx seems like a silly way to do something like that
21:22:33 <SamB_XP> why is lynx being mentioned so much?
21:22:58 <iulus> err... because that's what he mentioned earlier?
21:23:05 * SamB_XP is happy with ddclient and dyndns.org
21:23:12 <Cale> no-ip provides an update client for linux
21:23:15 <Cale> why not use that?
21:23:23 <dino-> I use ddclient/dyndns.org too.
21:23:27 * iulus is happy his ip doesn't change often and dyndns.org
21:23:33 <Cale> I use yi.org and gnudip2
21:23:50 <SamB_XP> iulus: "doesn't change very often" isn't really good enough for me
21:23:57 <SamB_XP> I like to be able to ssh in when I please
21:24:13 <iulus> SamB_XP: you probably use yours more than I do; I just host a website for my brother
21:24:23 <iulus> not mission critical
21:24:57 <SamB_XP> oh, well, all I do is write things in LaTex and such that I tend to want to change from a distance...
21:25:19 <Cale> SamB_XP: I have no problems with ssh, even though theoretically my IP changes every once in a while. My cron job runs every 5 minutes or so to test whether cale.yi.org maps to the current wan ip, and updates it if it's wrong.
21:25:23 <dibblego> same, so I have a static IP
21:25:51 <SamB_XP> I have ddclient set to go about every hour, actually...b
21:26:19 <Cale> I figured hitting my nameserver once every 5 minutes would not be a big deal :)
21:26:20 <SamB_XP> but that is good enough as long as I don't want to ssh within an hour of the IP changing ;-)
21:29:37 <quazimodo> Cale, what is the update client, bear in mind i am using their free service?
21:29:51 <Cale> http://www.no-ip.com/downloads.php?page=linux
21:29:53 <lambdabot> Title: Download a Free Dynamic DNS Update client for your dynamic IP
21:30:09 <SamB_XP> quazimodo: what kind of free service is usefull if you have to use it manually?
21:31:04 <quazimodo> SamB_XP, no idea, i am using thier port 80 redirect, will this program work with that? i have not found any info on this in their site yt
21:33:36 <quazimodo> lol it already exists in ports
21:33:54 <quazimodo> i am amazed by the sheer number of up to date ports, as if there are this many freebsd users??
21:34:23 <SamB_XP> how many freebsd users do you honestly think it takes to keep ports up-to-date?
21:35:07 <quazimodo> a thousand atleast
21:35:13 <SamB_XP> heh
21:35:17 <sieni> I thought freebsd is quite widely used
21:35:21 <quazimodo> make it 3 thousand
21:35:24 <SamB_XP> are there a thousand debian developers?
21:35:29 <LoganCapaldo> Just 1, but the port has to want to stay up to date
21:35:40 <quazimodo> heh
21:35:43 <quazimodo> well actually i dont know
21:35:50 <quazimodo> does freebsd have a larger user base than debian?
21:35:50 <SamB_XP> LoganCapaldo: what?
21:36:09 <LoganCapaldo> I thought you were telling a lightbulb joke
21:36:18 <SamB_XP> are you talking about FreeBSD ports, the repository of makefiles to build packages?
21:36:30 <quazimodo> me?
21:36:37 <SamB_XP> LoganCapaldo: are you?
21:36:39 <SamB_XP> quazimodo: you are
21:36:40 <LoganCapaldo> How many psychiatrists does it take to change a light bulb?
21:36:45 <quazimodo> tes
21:36:45 <quazimodo> yes
21:36:57 <quazimodo> and i think you would need a fair few guys
21:37:02 <quazimodo> the sheer number of ports is incredible
21:37:18 <SamB_XP> hmm, psychiatrists don't change lightbulbs -- for that you need a psychologist
21:37:19 <LoganCapaldo> see previous answer with s/port/light bulb/
21:37:38 <LoganCapaldo> and s/up to date/change
21:38:16 <SamB_XP> quazimodo: and how big is a "port"?
21:38:16 * LoganCapaldo decides not to tell any dead baby jokes
21:39:01 <SamB_XP> wise choice!
21:39:04 <quazimodo> a hand full of files
21:39:24 <SamB_XP> and what must be changed to update one?
21:39:34 <quazimodo> a few files :/
21:39:41 <SamB_XP> how many lines in each?
21:40:08 <quazimodo> a few
21:40:12 <quazimodo> stop it!
21:40:13 <quazimodo> lol
21:40:27 <quazimodo> how do i know that noip2 is working?
21:40:48 <SamB_XP> it doesn't sound like it takes thousands of people to keep ports up-to-date to *me*!
21:41:40 <quazimodo> you will concede it does if you want to keep your teeth *growl*
21:41:48 <quazimodo> quazimodo has been known to cock punch before
21:42:12 <SamB_XP> it don't work too well on IRC
21:42:17 <SamB_XP> besides, I'm a Debian user!
21:42:26 <quazimodo> forgiven
21:42:28 <quazimodo> debian is good
21:43:08 <SamB_XP> note that I think it is *better* if it requires less work to keep ports up to date ;-)
21:43:17 <quazimodo> indeed
21:43:17 <olliej> what's the syntax for a record in haskell?
21:43:25 <quazimodo> there are ofcourse the annoying ones that need to be patched to work right
21:43:36 <SamB_XP> mmmm.
21:43:53 <SamB_XP> and then sometimes they change the buildsystem...
21:44:15 <quazimodo> Cale, are you using their ip update program?
21:44:47 <Cale> quazimodo: I don't use no-ip
21:44:50 <Cale> I just googled for it
21:44:55 <quazimodo> oh
21:44:57 <quazimodo> thanks :D
21:44:58 <quazimodo> how nice
21:48:35 <TSC> olliej: have a look at: http://en.wikibooks.org/wiki/Haskell/YAHT/Language_advanced#Named_Fields
21:48:37 <lambdabot> http://tinyurl.com/y4u7rv
21:48:45 <olliej> TSC: cheers
22:09:54 <sorear> @seen
22:09:54 <lambdabot> Lately, I have seen johnmeacham and sorear.
22:10:15 <sorear> @messages?
22:10:15 <lambdabot> Sorry, no messages today.
22:10:17 <sorear> @users
22:10:17 <lambdabot> Maximum users seen in #haskell: 309, currently: 259 (83.8%), active: 32 (12.4%)
22:10:50 <shapr> @seen
22:10:50 <lambdabot> Lately, I have seen johnmeacham, shapr and sorear.
22:10:53 <shapr> yay
22:11:40 <sorear> --- MINDLESS CHANNEL PADDING --- MINDLESS CHANNEL PADDING --- ... ...
22:13:16 <dylan> hmmm... for those that use laptops -- what sort of laptop do y'all use? (mostly interested in screen size and platform)
22:13:56 <xpika> can someone help me with STrefs http://rafb.net/p/yJaNxH23.html ?
22:13:58 <lambdabot> Title: Nopaste - No description
22:14:48 <sorear> type annotations are your friend, especially with deep hackary like ST
22:15:08 * sorear now actually looks
22:15:10 <xpika> does st stand for strict?
22:15:27 <xpika> as in (x :: Int)
22:15:44 <sorear> xpika - print requires the IO monad, it won't work in ST
22:16:16 <sorear> @quote skeq
22:16:16 <lambdabot> skeq hasn't said anything memorable
22:16:17 <sorear> @quote skew
22:16:17 <lambdabot>  Swapping is just a constant factor
22:16:41 <sorear> @quote <skew>
22:16:42 <lambdabot>  also, if you use ST you know the code is just using mutable variables, rather than formatting your hard drive
22:17:18 <sorear> lambdabot needs reverse-quote: ?rquote format --> <skew> said: ....
22:17:47 <dylan> or a quote indexing system
22:17:47 <goltrpoat> xpika, you could could try b = stToIO (do r <- newSTRef 1; modifySTRef r (*2); readSTRef r)
22:17:54 <dylan> e.g. quote #1234
22:17:56 <sorear> anyway, ST stands for 'state thread', as in it threads state.
22:18:06 <sorear> @go Lazy functional state threads
22:18:08 <lambdabot> http://www.cse.ogi.edu/~jl/Papers/stateThreads.ps
22:18:10 <xpika> ok
22:18:41 <sorear> but the default ST is strict, a comment in the source says too many people were experiencing space leaks in the lazy days.
22:19:02 <sorear> use Control.Monad.ST.Lazy if you want the lazy st-monad
22:19:12 <sorear> no I don't understand the difference either
22:20:30 <dancor> can you specify a range in a case statement
22:20:47 <xpika> i dont think so
22:21:12 <sorear> I think ('a':_) is a range of values :)
22:21:16 <_Stinger_> you can use guards with a general pattern
22:21:43 <svref> how do I import Prelude except (take) ?
22:21:45 <sorear> case () of _ | isBigEnough && isSmallEnough -> returnSomething
22:21:54 <sorear> svref: s/except/hiding/
22:22:08 <sorear> 'import Prelude hiding (take)'
22:22:17 <svref> sorear:thx!
22:52:56 <xpika2> @hoogle stToIO
22:52:57 <lambdabot> Control.Monad.ST.stToIO :: ST RealWorld a -> IO a
22:54:21 <sorear> sow an ST state thread fragment into an IO thread, as if it were made of IO actions
22:57:03 <sorear> http://haskell.org/haskellwiki/How_to_write_a_Haskell_program (which IMO needs a link on the frontpage) tells you everything about how to do CoolLib 1.0, and that's *it*.
22:57:04 <lambdabot> Title: How to write a Haskell program - HaskellWiki
22:57:44 <sorear> I have CoolLib ?.?, I need to break compatibility, I have many very useful new features, and no idea of what to do.
22:59:25 <benja_> @seen zeeeee
22:59:25 <lambdabot> zeeeee is in #haskell and #oasis. I last heard zeeeee speak 8h 21m 15s ago.
23:00:40 <benja_> morning btw :)
23:06:02 <sorear> that gripe was also supposed to be a question :)
23:06:16 * shapr gripes
23:07:12 <benja_> =)
23:07:26 * sorear checks the mailing lists for examples of version n+1 announces
23:07:46 <benja_> no idea, but this makes me realize that I ought to learn about Cabal at some point :)
23:07:59 <shapr> sorear: Most of the time libraries have maintainers that are responsible for such a thing.
23:08:32 <shapr> sorear: If a library does not have a maintainer and you cannot contact the previous maintainer, you are free to take it over and do what you think is right.
23:08:38 <sorear> I'm not completely sure on this, but I think in this case I'm the maintainer, and I have no clue what to do.
23:08:51 * allbery_b doesn't see either of you in the gripe queue :)  (lots of spam though...)
23:08:53 <sorear> Its my code, I wrote it, Yi currently uses it
23:08:59 <shapr> It's considerate to listen to the community, but when in doubt heed the words of SyntaxNinja
23:09:05 <shapr> @quote SyntaxNinja
23:09:06 <lambdabot>  That's what we, in the computer industry, call teh suck.
23:09:17 <shapr> hm, not those words.
23:09:23 <shapr> @quote SyntaxNinja
23:09:24 <lambdabot>  That's what we, in the computer industry, call teh suck.
23:09:34 <shapr> :-P
23:09:44 <sorear> this? "I recommend seeing if people have a major problem, then pouring concrete on them, and implementing what you want anyway ;)
23:09:53 <shapr> @quote SyntaxNinja
23:09:54 <lambdabot>  I think that the compiler authors will fly here from England just to kill me if I did that
23:10:01 <shapr> sorear: If you want to break backwards compat, increment the major number and go forth and code!
23:10:01 <shapr> sorear: You got it.
23:10:07 <shapr> The one about concrete.
23:10:25 <sorear> I have an INTEGER in my public API with BIT FLAGS :(
23:10:32 <shapr> If you feel really nice, you can implement a compat layer on top of your new code. Otherwise people just have to live with it.
23:10:40 <shapr> wow
23:10:58 <allbery_b> so yi modifies its .cabal to specify a major version it works with (that is arguably good practice anyway) and you release a new major version
23:11:09 <allbery_b> perhaps that should be added to the wiki
23:12:15 <sorear> I'm also unsure as to how prone to mailing-list-announcing I should be
23:12:40 <shapr> The major version increment means "API change, client code will need changing"
23:12:55 <sorear> if you say foo>=1.0 in the cabal file, will it fail eagerly when configure sees foo 2.0?
23:13:06 <sorear> nm, thats easy to test
23:13:38 <shapr> So, what code does the community really need these days?
23:14:01 <allbery_b> ghc-pkg/cabal supports multiple concurrent versions, at least if you do things right
23:14:08 <shapr> I'm trying to think of something fun to hack on.
23:14:35 <allbery_b> (hugs etc. I wouldn't know about)
23:14:45 <sorear> configure: Dependency vty>=0.0: using vty-1.1  --- :(
23:15:09 <dylan> what is vty, btw?
23:15:22 <dylan> is it a terminal manipulation lib like slang or ncurses?
23:15:29 <allbery_b> the dependency is phrased wrongly
23:15:31 <sorear> a small simple robust terminal manipulation lib
23:15:35 <sorear> oh?
23:15:46 * allbery_b doesn't know if cabal lets you say "major version == N" though
23:16:00 <allbery_b> >= is bad, it's asserting compatibility with any future API change
23:16:21 <sorear> well, you CAN say (if cabal is as much of a dpkg clone as it looks) >=1.0, <2.0
23:16:46 <sorear> cabal has cloned all of dpkg's best and worst features.
23:17:05 <sorear> I'd like to see someone come up with a better idea than version numbers.
23:17:21 <allbery_b> could be worse; it could have cloned rpm.  or System V pkgadd :>
23:17:26 <dylan> compatibility checks!
23:17:54 <dylan> That way the compilation process gets slower as more features are added.
23:17:58 <dylan> wait. that's bad.
23:18:00 <sorear> My best musing has been to automatically extract from programs a set of constraints on the types of library symbols.
23:18:17 <quazimodo> what is the procedure GHC takes to compile haskell code?
23:18:23 <quazimodo> does it ever go near gcc?
23:18:23 <allbery_b> so you're going to heap the worst of autoconf on top of it? :)
23:18:52 <allbery_b> quazimodo: with -fvia-c it does, recent versions like to generate native code directly though
23:19:01 <allbery_b> (platform dependent, I suspect)
23:19:23 <sorear> q-m: lots of parts with fanciful names like the Glorious Driver and Evil Mangler
23:20:11 <quazimodo> allbery_b, id like to think that a GTK could be written directly in haskell
23:20:41 <sorear> GTK?  as in, gimp toolkit gtk?
23:20:49 <allbery_b> it quite possibly could,  but reimplementing everything from xlib on up would be painful and time-consuming
23:20:49 <quazimodo> yep
23:21:06 <allbery_b> there is already gtk2hs, though, and "the good is the enemy of the best"
23:21:33 <allbery_b> (meaning, nobody is likely to put effort into a pure-Haskell rewrite.)
23:21:33 <sorear> why reimplement gdk+xlib?
23:21:51 <quazimodo> no reason, i just said i would like to think that it *could*
23:21:52 <allbery_b> and, well, then you'd have to track changes to gdk, gtk, etc.
23:21:52 <sorear> Graphics.Rendering.Gdk.* already exists iirc :)
23:22:37 <sorear> plenty of gui libs have been written in haskell, most documented with phd dissertations
23:22:49 <sorear> fruit, fudgets, fran, etc
23:23:24 <allbery_b> they all hook into some existing library via FFI, though.  quazimodo seems to want to create one ex nihilo
23:23:34 <quazimodo> i dont like X11, i get the feeling that it is a hunk of arse
23:23:52 <dylan> X11 isn't that bad for what it does.
23:23:54 <allbery_b> it is.  sadly, replacing it is difficult at best
23:24:11 <mgsloan> the win32 of the linux world? ;p
23:24:12 <dylan> I've been learning xlib lately because of my addiction.
23:24:16 <allbery_b> there have been a number of attempts, none of which have gained any traction
23:24:31 <sorear> dylan: what could be that bad?
23:24:47 <dylan> sorear: dwm. :)
23:24:54 <sorear> dwm?
23:25:12 <sorear> btw, Xlib is being retired
23:25:14 <dylan> yeah. window manager in 2,000 lines of C code. it's dons' fault I started using it
23:25:15 <mgsloan> that one window manager
23:25:48 <dylan> xlib is being 'retired'?
23:25:56 <sorear> @go xcb
23:25:59 <lambdabot> http://xcb.freedesktop.org/
23:25:59 <lambdabot> Title: XCB Wiki - xcb
23:26:45 <sorear> Keith Packard has a couple papers on how to correct the mal-design of Xlib, the replacement is the X C Binding
23:27:36 <allbery_b> makes sense.  xlib is pretty warty
23:27:59 <sorear> I haven't tried it myself, but supposedly its a LOT simpler, and designed for extensibility, and designed for language-bindability
23:28:04 <dylan> hmm. I bet dwm could be made even smaller.
23:28:25 <dylan> xcb + haskell = 100 line window manager? :)
23:28:30 <sorear> dylan: try rewriting it in haskell? :)
23:28:34 <allbery_b> port xcb t haskell and rewrite dwm :)
23:28:42 <allbery_b> heh
23:28:58 <dylan> First I'm going to finish my chat client... and then probably port it from slang to vty.
23:29:13 <sorear> e.g. lambdabot is non-living proof that completely monadic haskell isn't necessarily ugly.
23:29:40 <sorear> there is almost no pure code in the core of the beast
23:30:27 <dylan> I really hope my slang binding is at least a few weeks older than the pre 1.0 versions of vty
23:30:29 <sorear> Even if I stop hacking lambdabot, I'm going to keep my repo around just for grepping the State/ files.
23:30:51 <sorear> vty is >1 year old
23:31:01 <sorear> it's been rewritten about a week ago
23:31:15 <dylan> Bah. Someone should've mentioned that when I asked about ncurses. :)
23:31:25 <sorear> but evolutionarily, I wrote it before I learned haskell
23:31:39 <sorear> 150 line C lib
23:32:14 <dylan> I'd be interested in helping test it in the future. :)
23:32:29 <sorear> I also only released it a week ago ... you can get away with a lot more when you are the only user
23:32:35 <dylan> I still need to figure out how to use a pretty printer combinator with a terminal output library
23:33:13 * sorear is still fairly amazed that there is a niche for a "oh, rewriting ncurses will be easier than understanding it" library
23:33:42 * allbery_b isn't
23:33:42 <dylan> oh, you're an O'Rear. Heh. I've only seen one other person ever with that last name.
23:33:59 <dylan> sorear: anything is better than ncurses.
23:34:14 <allbery_b> curses, like xlib, has a lot of badly understood and oddly interacting cruft
23:34:25 <allbery_b> ^badly^poorly
23:34:34 <dylan> ncurses' idea about handling colors is moronic
23:34:35 <lisppaste2> benja_ annotated #33603 with "cases with existential types" at http://paste.lisp.org/display/33603#5
23:34:41 <sorear> yes... more amazingly, my paternal line is almost full-blooded Russian - nobody remembers how an Irish last name entered
23:34:55 <allbery_b> much of it hanging around from when people had to support weirdstuff like Teleray terminals
23:35:08 <dylan> sorear: you must be very pale. A very white russian, that is. *ducks*
23:35:27 <allbery_b> the color support was hacked onto the existing attribute support by AT&T.  and I do mean *hacked*
23:35:33 <allbery_b> like, with an ax
23:35:51 <benja_> @tell zeeeee sorry, that's the problem with giving example code when being on a cellphone and not being able to test it... :-/ it works when enabling existential types in GHC: http://paste.lisp.org/display/33603#5
23:35:52 <lambdabot> Consider it noted.
23:35:53 <dylan> color support at the termio level or at the ncurses level?
23:36:10 <allbery_b> at the curses level
23:36:15 <dylan> Fun!
23:36:22 <dylan> that explains the colorpair nonsense.
23:36:25 <allbery_b> the terminfo level was then designed off of that
23:36:58 <dylan> why is it terminal applications still often feel... less horrible than graphical ones?
23:37:11 <dylan> if the underlying software is crappy?
23:37:15 <sorear> the redraw algorithms are stupid - curses must have been designed when CPUs were slower than modems
23:37:29 <sorear> dylan: terminals don't have mice
23:37:34 <allbery_b> yeh, colorpairs were basically a way to hack colors into a limited attribute space
23:38:12 <allbery_b> and curses dates from when 20MHz workstations were astoundingly fast, yes
23:38:39 <quazimodo> why doesnt someone write a framebuffer for console to give it any resolution and 24bit color?
23:38:45 <allbery_b> (and not so much for modems; it preferred 9600 baud serial connections)
23:38:53 <sorear> vty uses a (very simple) minimal difference algorithm for redraw regions - nothing was traded off for comp. efficiency
23:39:10 <allbery_b> quazimodo: svgalib :)
23:39:11 <sorear> q-m: you mean like sisfb+fbcon? (linux)
23:39:16 * dylan sleeps
23:39:24 <quazimodo> allbery_b, svgalib!?
23:39:40 <allbery_b> and a bunch of kernel things for linux, and a few for freebsd, but the generic solution is toss the fb into graphics mode and use svgalib
23:39:46 * sorear <heart> fbcon
23:39:49 <quazimodo> how did the terminal using guys look at pictures?
23:40:01 <sorear> I use fbi
23:40:04 <allbery_b> they didn't
23:40:11 <sorear> figlet?
23:40:24 <sorear> @google aalib
23:40:24 <allbery_b> actually svgaconsole or something like that, which was wqritten on top of svgalib
23:40:26 <lambdabot> http://aa-project.sourceforge.net/aalib/
23:40:26 <lambdabot> Title: An ascii-art library
23:40:42 <sorear> Real time ASCII art rendering.  Be very afraid.
23:41:02 * sorear isn't fond of the fact that aalib is the default backend for sdl
23:41:15 <allbery_b> *snerk*
23:41:43 <sorear> i.e you play a movie with ffplay and it shows up in the terminal in shades of / and #
23:42:08 <quazimodo> ive seen that ascii art video thingo
23:42:11 <quazimodo> its lame and cool
23:42:29 <sorear> Cool, yes.  Default-worthy?  absolutely not.
23:42:33 <allbery_b> vt100 star wars movie :)
23:43:27 <quazimodo> ffplay doesnt exist in freebsd ports
23:43:43 <sorear> oooh, mailing list post :  "How do I make .lhs files readable?"
23:44:08 <sorear> my answer: get a real editor
23:45:55 <goltrpoat> someone ported quake to an ascii renderer a while back
23:46:09 <goltrpoat> http://webpages.mr.net/bobz/ttyquake/
23:46:10 <lambdabot> Title: TEXTMODE QUAKE!!!
23:46:53 <sorear> I agree, it is Very Cool, but I'd rather play may FPS's with bitmapped graphics.
23:48:44 <quazimodo> Run the 'ttyquake' script from your Quake directory.
23:48:44 <quazimodo> Put your head between your legs and breathe deeply until the shock wears off.
23:48:46 <quazimodo> hahaha
23:49:06 <sorear> allbery_b: so what is the right way to state a dependency in cabal?
23:49:53 * allbery_b hasn't yet looked at cabal closely enough to know how to answer spexcifically
23:49:58 <quazimodo> Update: The source for Quake has been released under the GNU Public License. Download it here and leave me the hell alone.
23:49:59 <quazimodo> hahahaha
23:50:02 <quazimodo> this guy is hilarious
23:50:37 <allbery_b> my point was that one should not declare an open-ended dependency, but depend on a specific major version (== API) and if necessary minor version (== bugfix)
23:50:47 <allbery_b> avoiding the latter if possible
23:51:00 <sorear> I wonder if people say 'GNU Public License' *because* the FSF says it's wrong.
23:51:20 <allbery_b> that way you don't break when someone releases a new version with a changed API
23:51:36 <allbery_b> it's surprising to me how often people get that wrong
23:53:27 <ClaudiusMaximus> what's the easiest way to measure elapsed time between calls of my idlecallback when using hopengl?
23:53:48 <allbery_b> (of course, it relies on developers playing by the rules)
23:54:02 * allbery_b is glaring at *you*, OpenSSL!
23:54:54 <sorear> just to be pedantic, hopengl doesn't have idlecallbacks, GLUT does
23:55:30 <ClaudiusMaximus> sorear: noted :)
23:55:53 * sorear runs grep -lr gettimeofday /usr/local/src/ghc-source/libraries
23:56:24 <sorear> System.Time looks good
23:56:32 <allbery_b> System.Tme, even has time diff foo
23:57:00 * sorear loves his fast hard drive
23:57:51 <ClaudiusMaximus> thanks sorear, allbery_b
23:58:27 <allbery_b> of course, timing lazy code introduces complications
23:58:52 <sorear> even in the strict IO monad?
23:59:08 <allbery_b> hopefully not
23:59:11 * sorear doesn't know what he's talking about
23:59:30 <allbery_b> but you can have lazy code even inside of IO, so it can still be tricky
