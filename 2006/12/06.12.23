00:00:06 <glguy> ?type let f xs = [(b,(a ++).(:c)) | (a,b:c) <- zip (inits xs) (tails xs)] in f
00:00:07 <lambdabot> forall a. [a] -> [(a, a -> [a])]
00:00:09 <sorear> Of course in this case you'd be better of using elem and a guard, but that's not always possible <grump>
00:00:17 <povman> ah, that is slightly nifty sorear
00:00:20 <povman> yeah.
00:00:33 <povman> well, i hope that condition is under consideration for haskell'
00:00:39 <povman> i gotta go have dessert
00:00:41 <sorear> creating an intermediate datatype...
00:00:59 <Stinger> when isnt it possible?
00:01:19 <sorear> I see stuff like:
00:02:19 <sorear> no, wait, bad example, (||)
00:02:37 <sorear> (inspiration) can patterns be reified?
00:02:51 <Stinger> reified?
00:03:08 <mgsloan> well, xyz could reference a function in the where clause
00:03:38 <mgsloan> that's probably missing the point though :)
00:03:52 <sorear> a typeclass is a non-first-class thing, a dictionary (equiv. existential box) is a first class value that reifies a dictionary
00:04:22 <lispy> povman: i don't see any way to do it, but are you really gaining anything by allowing it?
00:04:52 <sorear> type Pat a = (a -> Bool) ; data MyObj = A Int | I MyObj MyObj  -- sample object
00:05:11 <lispy> povman: syntatically isn't specifying the options to "or" together the same as just listing the new option on a new line?
00:05:16 <Cale> factoring out the common RHS with let isn't so bad.
00:05:31 <sorear> mA :: Int -> Pat MyObj ; mA i (A j) = i == j ; mA i (I _ _) = False
00:05:36 <sjanssen> sorear: I'd write this: | any (`isPrefixOf` x) ["s1", "s2"] = RHS
00:06:08 <ski> OCaml and (iirc) some SML impls have disjunctive / "or" patterns
00:08:11 <povman> lispy: but then you have to repeat the rhs a bunch of times
00:08:15 <sorear> If they have extensions, why are they *S*ML? :(
00:08:47 <ski> > let allSlices :: [a] -> [([a],a,[a])]; allSlices [] = []; allSlices (x:xs) = ([],x,xs) : map (\(ys0,y,ys1) -> (x:ys0,y,ys1)) (allSlices xs) in allSlices [1..4]
00:08:49 <lambdabot>  [([],1,[2,3,4]),([1],2,[3,4]),([1,2],3,[4]),([1,2,3],4,[])]
00:09:01 <ski> > let allSlices :: [a] -> [([a],a,[a])]; allSlices [] = do {mzero}; allSlices (x:xs) = do {return ([],x,xs)} `mplus` do {(ys0,y,ys1) <- allSlices xs; return (x:ys0,y,ys1)} in allSlices [1..4]
00:09:03 <lambdabot>  [([],1,[2,3,4]),([1],2,[3,4]),([1,2],3,[4]),([1,2,3],4,[])]
00:09:29 <ski> probably the 'inits','tails' solutions is simpler ..
00:09:58 <ski> @type foldM
00:10:00 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
00:12:06 <sorear> > liftM3 zip3 inits id tails [1..10]
00:12:07 <lambdabot>  [([],1,[1,2,3,4,5,6,7,8,9,10]),([1],2,[2,3,4,5,6,7,8,9,10]),([1,2],3,[3,4,5,...
00:12:34 <sorear> > liftM3 zip3 inits id (tails . tail) [1..10]
00:12:35 <lambdabot>  [([],1,[2,3,4,5,6,7,8,9,10]),([1],2,[3,4,5,6,7,8,9,10]),([1,2],3,[4,5,6,7,8,...
00:12:36 <ski> nice
00:12:38 <sorear> > liftM3 zip3 inits id (tails . tail) [1..3]
00:12:40 <lambdabot>  [([],1,[2,3]),([1],2,[3]),([1,2],3,[])]
00:13:11 <povman> i feel like such a noob here
00:13:14 <sorear> the 'instance Monad (->) a' has so many uses...
00:13:44 <ski> :t liftM3 zip3 inits id (tails . tail)
00:13:45 <lambdabot> forall a. [a] -> [([a], a, [a])]
00:13:47 <sorear> glguy: this short enough for you :)
00:14:01 <ski> (rather the list monad)
00:14:11 <mgsloan> :t tails
00:14:12 <lambdabot> forall a. [a] -> [[a]]
00:14:26 <mgsloan> cool
00:14:39 <sorear> > liftM2 zip2 inits tails [1..4]
00:14:40 <lambdabot>  Not in scope: `zip2'
00:14:43 <sorear> > liftM2 zip inits tails [1..4]
00:14:45 <lambdabot>  [([],[1,2,3,4]),([1],[2,3,4]),([1,2],[3,4]),([1,2,3],[4]),([1,2,3,4],[])]
00:15:15 <ski> (um, no, i thought worng)
00:15:31 <ski> hm
00:16:06 <lispy> thinko
00:16:53 <mgsloan> > (\x -> zip (inits x) (tails x)) [1..4]
00:16:54 <lambdabot>  [([],[1,2,3,4]),([1],[2,3,4]),([1,2],[3,4]),([1,2,3],[4]),([1,2,3,4],[])]
00:17:14 <sorear> ?pl \x -> zip (inits x) (tails x)
00:17:14 <lambdabot> liftM2 zip inits tails
00:17:39 <mgsloan> ?unpl liftM2 zip inits tails
00:17:40 <lambdabot> (inits >>= \ b -> tails >>= \ a -> return (zip b a))
00:17:45 <mgsloan> bah
00:18:29 <sorear> let allSlices :: [a] -> [([a],a,[a])]; allSlices [] = do {mzero}; allSlices (x:xs) = do {return ([],x,xs)} `mplus` do
00:18:47 <sorear> ?pl let allSlices :: [a] -> [([a],a,[a])]; allSlices [] = do {mzero}; allSlices (x:xs) = do {return ([],x,xs)} `mplus` do {(ys0,y,ys1) <- allSlices xs; return (x:ys0,y,ys1)} in allSlices
00:18:47 <lambdabot> (line 1, column 15):
00:18:48 <lambdabot> unexpected ":"
00:18:48 <lambdabot> expecting pattern or "="
00:18:57 <sorear> ?. pl undo let allSlices :: [a] -> [([a],a,[a])]; allSlices [] = do {mzero}; allSlices (x:xs) = do {return ([],x,xs)} `mplus` do {(ys0,y,ys1) <- allSlices xs; return (x:ys0,y,ys1)} in allSlices
00:18:58 <lambdabot> (line 1, column 5):
00:18:58 <lambdabot> unexpected "{"
00:18:58 <lambdabot> expecting natural, identifier or "in"
00:19:02 <mgsloan> I wonder how you would do forkIO if you just passed around RealWorlds
00:19:35 <lispy> mgsloan: because they need to have the same RealWorld?
00:19:58 <lispy> mgsloan: you'd have to store the "real world" inside an IORef?
00:20:01 <mgsloan> well, I don't know how forkIO works normally, so i guess that's the prob
00:20:08 <mgsloan> yeah, something like that
00:20:30 <sorear> ?let allSlices [] = mzero; allSlices (x:xs) = return ([],x,xs) `mplus` fmap (\(a,b,c) -> (x:a,b,c)) (allSlices xs) in allSlices
00:20:30 <lambdabot>  Parse error
00:21:10 <sjanssen> I don't think you can express forking with the RealWorld passing style
00:21:15 <sorear> ?pl let allSlices [] = mzero; allSlices (x:xs) = return ([],x,xs) `mplus` fmap (\(a,b,c) -> (x:a,b,c)) (allSlices xs) in allSliceslet allSlices [] = mzero; allSlices (x:xs) = return ([],x,xs) `mplus` fmap (\(a,b,c) -> (x:a,b,c)) (allSlices xs) in allSlices
00:21:16 <lambdabot> (line 1, column 15):
00:21:16 <lambdabot> unexpected "["
00:21:16 <lambdabot> expecting pattern or "="
00:21:41 <mgsloan> i'm trying to figure out how my graphical functional language does side effects.  At the moment RealWorld passing seems to be good (intuitive, even), but a lot of things i haven't figured out
00:22:31 <lispy> mgsloan: have you read "Tackling the akward squad"?
00:22:32 <mgsloan> it's practically like drawing a flowchart.
00:22:37 <mgsloan> maybe
00:22:42 <mgsloan> i'll check it out
00:22:49 <lispy> mgsloan: iirc, it covers forkIO and i know it talks about real world passing
00:22:54 <mgsloan> i've at least glanced at it a few times ;p
00:24:12 <lispy> mgsloan: this would make a good discussion on haskell-cafe too
00:24:18 <lispy> so i would recommend you ask there
00:24:39 <mgsloan> would it? I should probably sign up to the mailing list..
00:25:14 <sjanssen> RealWorld is just a hack to make sure that the compiler doesn't optimize IO programs in broken ways
00:25:24 <mgsloan> sure
00:25:44 <sorear> continuation passing has also been used, cf hbc
00:26:39 <mgsloan> from a visual standpoint - funcs are boxes, lines are data, it makes perfect sense.  Especially if you color Realworld lines something unique
00:27:52 <Cale> I kind of dislike the RealWorld analogy. It would be much more reasonable to represent values of type (IO t) as imperative program scripts which produce a value of type t
00:29:44 <sjanssen> what would >>= look like then?
00:30:55 <sorear> I like to think of IO a as a contuation-generated tree of inputs and outputs, with a godlike interpreter performing IO and traversing the tree.
00:31:08 <mgsloan> sjanssen - in mine? a >>= b would be a red line from a to b, and a white (normal data) line from a to b.
00:31:15 <mgsloan> multiple outputs for functions, you see
00:31:18 <sjanssen> in Cale's
00:31:22 <mgsloan> oh
00:31:53 <ski> sjanssen : maybe like in http://www.cs.chalmers.se/Cs/Grundutb/Kurser/afp/code/week2/ProgramDeep.hs
00:31:56 <lambdabot> http://tinyurl.com/ubrfh
00:31:59 <Cale> x >>= f would produce the script which is has the code from x, followed by f of the result of x (which is some internal variable)
00:32:15 <Cale> -is
00:32:39 <mgsloan> problems come up when functions throw away that execution though (its just like unsafePerformIO).  I suppose this is why the wire is distinguished
00:32:51 <ski> *AllSlices> (liftM3 . liftM3) (,,) inits id (tails . tail) (MkS [0..3])
00:32:51 <ski> [([],0,[1,2,3]),([0],1,[2,3]),([0,1],2,[3]),([0,1,2],3,[])]
00:33:03 <ski> sorear : ^^ whaddya think ?
00:33:20 <sorear> very impressive !
00:33:41 <ski> the stream monad can be useful :)
00:34:14 <sorear> wait - I thought streams were only an applicative functor?
00:34:21 <ski> nope ;)
00:35:24 <ski> if you take infinite streams, recall that 'Stream a' is roughly the same as 'Nat -> a', and there you have the '(Nat ->)' environment/reader monad :)
00:35:56 <sorear> ahh...
00:36:05 <ski> ('join' takes the diagonal)
00:36:24 <ski> (i.e. duplicating the index and uses it twice)
00:36:43 <ski> (while 'return' throws away the index, i.e. 'return = repeat' :)
00:37:31 <sorear> Streams can be constructed as both monads and comonads, this seems interesting... (cojoin = iterate tail)
00:38:22 <ski> tails
00:38:52 <ski> > take 4 $ iterate tail $ [0..]
00:38:53 <lambdabot>  [[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
00:39:02 <ski> > take 4 . map (take 4) $ iterate tail $ [0..]
00:39:04 <lambdabot>  [[0,1,2,3],[1,2,3,4],[2,3,4,5],[3,4,5,6]]
00:39:12 <ski> > take 4 . map (take 4) $ tails $ [0..]
00:39:14 <lambdabot>  [[0,1,2,3],[1,2,3,4],[2,3,4,5],[3,4,5,6]]
00:39:46 * ski tentatively calls 'cojoin' 'split'
00:40:44 <sorear> cojoin on streams-as-(->)Nat is cojoin f = \x y -> f (x+y)
00:41:02 <ski> yep
00:41:33 <ski> i.e. a monoid
00:41:49 <ski> instance Monoid o => Comonad ((->) o)
00:43:08 <sorear> interesting
00:44:07 <sorear> The (->) o monad (reader) corresponds to the (,) o comonad
00:44:31 <sorear> Thus in some sense the Comonad (->) o should be a writer ?
00:44:55 <sorear> or something even higher than a reader?
00:47:01 <ski> a -> (o -> b)
00:47:09 <ski> =============
00:47:11 <mgsloan> hah, whats funny is that tackling the awkward squad practically uses my lang (the very rudiments) in explaining the IO monad
00:47:14 <ski> (o,a) -> b
00:47:42 <ski> and
00:47:55 <ski> Monoid o => (o -> a) -> b
00:47:58 <ski> ???
00:48:15 <ski> Monoid o => a -> (o,b)
00:49:55 <ski> :t \aob oa -> let (o,b) = aob a; a = oa o in b
00:49:57 <lambdabot> forall a b t. (t -> (a, b)) -> (a -> t) -> b
00:50:08 <ski> hm .. that's cyclic, though
00:51:18 <ski> :t \oab a -> let b = oab (\o -> a) in (o,b)  -- doesn't work
00:51:20 <lambdabot> Not in scope: `o'
00:53:15 <ski> actually, it'd be interesting to somehow use 'Comonoid' in the environment/reader monad and the environment comonad
00:53:35 <ski> (maybe in an enriched category, hm ..)
00:53:47 <sorear> :t let cojoin f = \x y -> f (x + y) ; cofmap f g = f . g ; (x =>= y) v = y (cofmap x $ cojoin v) in (=>=)
00:53:48 <lambdabot> forall a t c t1. (Num a) => ((a -> t) -> c) -> ((a -> c) -> t1) -> (a -> t) -> t1
00:53:57 <sorear> :pl let cojoin f = \x y -> f (x + y) ; cofmap f g = f . g ; (x =>= y) v = y (cofmap x $ cojoin v) in (=>=)
00:54:24 <sorear> ^^ that's kliesi composition, let's see what lambdabot's code digestor things
00:54:26 <sorear> ?pl let cojoin f = \x y -> f (x + y) ; cofmap f g = f . g ; (x =>= y) v = y (cofmap x $ cojoin v) in (=>=)
00:54:27 <lambdabot> (line 1, column 57):
00:54:27 <lambdabot> unexpected "("
00:54:27 <lambdabot> expecting natural or identifier
00:54:59 <sorear> ?pl let cojoin = \f x y -> f (x + y) ; (x =>= y) v = y ((.) x $ cojoin v) in (=>=)
00:54:59 <lambdabot> (line 1, column 36):
00:54:59 <lambdabot> unexpected "("
00:54:59 <lambdabot> expecting natural or identifier
00:55:18 <sorear> ?pl let cojoin = \f x y -> f (x + y) ; g = \x y v -> y ((.) x $ cojoin v) in g
00:55:19 <lambdabot> flip (.) . (. ((. (+)) . (.))) . (.)
00:55:35 <sorear> that isn't terribly enlightening :(
00:55:47 <sorear> ?. unpl pl let cojoin = \f x y -> f (x + y) ; g = \x y v -> y ((.) x $ cojoin v) in g
00:55:48 <lambdabot> (\ q c f -> c (\ n -> q (\ j -> f (n + j))))
00:56:21 <ski> :t let (.:) = (.) . (.); cojoin = (.: (+)); cofmap = (.) ; x =>= y = y . cofmap x . cojoin in (=>=)
00:56:23 <lambdabot> forall a c c1 c2. (Num a) => ((a -> c) -> c1) -> ((a -> c1) -> c2) -> (a -> c) -> c2
00:57:42 <ski> :t let (.:) = (.) . (.); cojoin = (.: (+)); cofmap = (.) ; (=>=) = flip (.) . (. cojoin) . cofmap in (=>=)
00:57:43 <lambdabot> forall a c c1 c2. (Num a) => ((a -> c) -> c1) -> ((a -> c1) -> c2) -> (a -> c) -> c2
00:58:38 <Cale> http://cale.yi.org/autoshare/evalexec.png -- this is roughly how I think of IO
01:00:21 <mgsloan> ooh, nice inkscapeage ;)
01:04:10 <Cale> thanks
01:04:32 <mgsloan> what does the red triangle represent?
01:04:44 <mgsloan> ohh, execution point
01:04:54 <mgsloan> and the lines are thunks?
01:05:12 <mgsloan> (or something, I have only read about thunks in passing, here)
01:05:42 <mgsloan> the box + lines collectively a thunk
01:05:55 <Cale> the lines are things to do
01:06:30 <mgsloan> ooooh
01:06:31 <Cale> i.e. the "page" is a value of type (IO t) with v :: t
01:06:44 <mgsloan> and it just shows you the last line
01:07:10 <Cale> yeah
01:07:58 <Cale> since the return value of that action is all we really care about for the purposes of bind
01:08:58 <mgsloan> yeah. interesting illustration.  Could be improved a bit by colorizing the last lines the same as the rest of the lines.  Thanks, i think it improved my grasp
01:10:25 <mgsloan> maybe also if the execution boxes were moved downwards such that the first cross-wise line is near horizontal
01:11:01 <mgsloan> nah, probably not necessary
01:11:21 <Cale> that's a good idea
01:12:58 <Cale> there we go
01:13:47 <mgsloan> nice
01:15:00 <mgsloan> oh no - the awkward squad recommends using unsafeIO for a config file
01:15:49 <mgsloan> well, not really, but it uses it in an example
01:16:19 <syntaxfree> http://blogs.msdn.com/ralflammel/archive/2006/12/21/more-haskell-in-java-7-or-8.aspx
01:16:22 <lambdabot> Title: Grammarware, Haskellware, XMLware : More Haskell in Java 7 or 8?, http://tinyurl.com/ymozle
01:17:12 <syntaxfree> In a sense, Haskell is winning, as its features are half-adopted by the mainstream languages who have no urgent competition-led business in adopting features.
01:18:08 <syntaxfree> maybe Haskell *is* the new Lisp, and the world will be dragged kicking and screaming halfway to Haskell in the next 20 years, as we, the hardcore, resemble further and further the bitter, smug Lisp weenies.
01:18:59 <mgsloan> don't forget insane
01:19:21 <mgsloan> i can totally see more advanced monads driving me insane
01:20:03 <mgsloan> brilliantly bipolar too
01:20:10 <syntaxfree> Not to mention the comonads.
01:20:18 <syntaxfree> And the Hughes Arrows!
01:20:24 <syntaxfree> I'm entranced by comonads, at the moment.
01:20:46 <syntaxfree> Not doing much work because of bouts of post-breakup depression, but still entranced.
01:23:11 * integral wishes Typable/Data didn't have to be derived since TH is missing them *sigh*
01:23:54 * sorear wishes haskell no need for user defined types - they complicate so many things *sigh*
01:24:59 <sorear> In a sense, no user defined types is equivalent to structural type equality - interpret all type defns as synonyms.
01:25:16 <syntaxfree> except they're not.
01:25:44 <syntaxfree> As far as I understood it, Haskell's deep connections with cat theory comes precisely from types.
01:25:59 <sorear> I'm a little unclear on the concept of structural type equality, where did I go wrong?
01:26:07 <syntaxfree> maybe you didn't.
01:26:15 * integral doesn't think sorear did
01:26:23 <syntaxfree> you probably didn't, then.
01:26:40 <syntaxfree> I took "structural type eqaulity" as a colloquail teerm.
01:26:43 <mgsloan> yeah, i've thought about it before - referentially transparent type synonym functions
01:26:50 <syntaxfree> if it's an actual technical term, I'm unaware of it.
01:28:19 <mgsloan> I've heard it before.  Means that Foo [1] == [1], or at least there is nothing like Foo [1].  Anything like Foo [1] would be [1]
01:29:12 <syntaxfree> as in, there's a functor taking Foo a types to a types and functions over Foo a to functions over a?
01:29:16 <sorear> I've understood it to mean data Horz = Left | Right  is treated the same as data Size = Big | Small
01:29:34 <sorear> i.e. the names are irrelevant
01:29:53 <syntaxfree> uh, sure.
01:30:07 <syntaxfree> Isn't that the big deal about Generic programming anyway?
01:30:16 <sorear> But, I've never seen it defined anywhere...
01:30:17 <mgsloan> syntaxfree: nah, its out of the haskell world
01:30:36 <sorear> Generic programming is completely unneccessary with structural type equality.
01:31:11 <sorear> Generic programming lets you define functions based on the "shape of the type", which is the type itself when names are irrelevant.
01:31:19 <syntaxfree> maybe there's some concept less general than kinds, but more general than types, that captures that ahape.
01:31:30 <syntaxfree> I know about product types, sum types, etc.
01:31:50 <syntaxfree> But, uh, anyway, I'm really talking out of my armpits. I don't know enough to comment on this.
01:32:21 <mgsloan> hah, i don't know enough to comment on much of anything :)
01:32:36 <sorear> Most of the ultra-dynamic languages, (Perl, Tcl, Python, Lua, etc) do not have user-defined types.
01:32:57 <mgsloan> yeah. Lua's stuff is pretty elegant though
01:33:26 <sorear> I wonder if this is because "ultra-dynamic" languages tend to be minimalist, or because nominal type equality interferes with dynamicness?
01:34:07 <syntaxfree> runtime type inference with user-defined types musy be hell.
01:34:11 <syntaxfree> s/musy/must.
01:34:21 <mgsloan> yeah, I'm taking the latter
01:34:43 * syntaxfree knows personally the principal designers of Lua.
01:34:58 <sorear> Oooh... cool...
01:35:17 <mgsloan> nice
01:35:20 <syntaxfree> My undergrad years were spent at the school where Lua was born.
01:35:25 <syntaxfree> I was in the economics dept. though.
01:37:21 * sorear is two degrees to Ed Witten, but directly knows nobody you've likely even heard of...
01:37:33 <mgsloan> all we really need is pattern matches like this:
01:37:45 <mgsloan> foo (_ x) = x
01:38:03 <syntaxfree> well, that's why you have tuples, for instance.
01:38:04 <mgsloan> generic programming, bing bang boom
01:38:08 <syntaxfree> Tuples are unspecified product types.
01:38:23 <mgsloan> i suppose they are
01:38:28 <sorear> so, what would the semantics of foo be?
01:38:44 <mgsloan> and Either is unspecified sum types :)
01:38:50 <syntaxfree> yep.
01:39:05 <mgsloan> sorear - yeah, quite tricky in the haskell world
01:39:07 <sorear> I mean, what does it do.  I seem to have gotting my concision filter flipped :(
01:39:10 <mgsloan> well, impossible
01:39:14 <syntaxfree> there are not enough Either function in the std. lib
01:39:25 <syntaxfree> a couple more are needed. Simple extensions, of course.
01:39:40 <sorear> what do you want it to do?
01:39:55 <mgsloan> foo (Bar [1,2]) <=> [1,2]; foo (Tar 1) <=> 1
01:40:03 <ski> higer-order patterns (like '_ x') is possible (to a degree) in lambdaProlog
01:40:19 <sorear> foo (1,2)?  foo (Left 3) ?  foo (Right 4) ?
01:40:49 <syntaxfree> with some type theory backing the informal notion of "type shapes", you can easily write some general type-shapes as classes, and be happy.
01:40:50 <sorear> or, if haskell had no udt's, foo (_,x) = x :: a + b -> b
01:40:50 <mgsloan> first would be an error
01:41:00 <mgsloan> second would be 3, third would be 4
01:41:02 <syntaxfree> I'm not sure that's what generic haskell does, though.
01:41:06 <ski> foo (1,2) = foo ((\n -> (1,n)) 2) = 2
01:41:11 <ski> foo (1,2) = foo ((\n -> (n,2)) 1) = 1
01:41:15 <ski> so
01:41:16 <ski> 1 = 2
01:41:19 <mgsloan> oh, its probably not.  I have no idea what generic haskell does
01:41:25 <Vq^> mgsloan: foo ((,) 1 2)  ?
01:41:39 <mgsloan> is , an infix constructor?
01:41:47 <syntaxfree> it's not hard to write some "lift" functions, for example.
01:41:47 <mgsloan> if so, 1.  if not, type error
01:41:50 <sorear> almost, see current tjread.
01:41:57 <mgsloan> err wait
01:42:00 <mgsloan> type error either way
01:42:21 <mgsloan> because this only accepts one parameter constructors
01:42:32 <syntaxfree> You can write Control.Typeshape and define useful functions for unspeciied product types, unspecified sum types and so on.
01:42:48 <syntaxfree> I can't guarantee you won't be laughed at by the theoreticians, though.
01:42:50 <ski> foo (1,2) = foo (((,) 1) 2) = 2
01:42:59 <sorear> data Null x = Nu ; (foo :: Null x -> x) Nu ?
01:43:04 <ski> foo (1,2) = foo ((,) 1 2) = 2  -- unneeded parens
01:43:11 <Vq^> mgsloan: wouldn't you loose the type-information after you applied the argument?
01:43:14 <mgsloan> (1,2) doesn't match (_ x) though
01:43:19 <ski> it does
01:43:39 <ski> (1,2)  =  (,) 1 2  =  ((,) 1) 2
01:43:42 <ski> '_
01:43:51 <ski> '_' matches '(,) 1'
01:43:54 <sorear> Not all members of a type need have the same nf-shape.
01:43:56 <mgsloan> damn, you're right
01:44:02 <sorear> data X = X Int Int | Y Int
01:44:12 <mgsloan> ahwell, as i already said, i have no real grounds for comment
01:44:16 <sorear> OTOH, type X = Int*Int + Int
01:44:24 <syntaxfree> you could try and program some stuff.
01:44:39 <ski> the touble is that '_ x' patterns can be nondeterministic (and in general undecidable)
01:44:46 <syntaxfree> you might be better equipped for that with some hard type theory backing you, though.
01:45:00 <Vq^> mgsloan: me neither, but it's an interesting thought
01:48:42 <mgsloan> well, in my imaginary world, the _ only matches individual constructor identifiers.
01:51:07 <ski> (so 'head (x:_) = x' is disallowed, then ? :)
01:52:10 <mgsloan> hah
01:52:36 <mgsloan> nah, _ just means different things in different contexts. like capitalized words
01:55:47 <syntaxfree> mgsloan: methinks you could maybe write a different language that gets parsed into Haskell.
01:56:10 <syntaxfree> just to test whether that itch of yours goes anywhere.
01:56:32 <mgsloan> hah, nah.  I'm actually not that interested in the idea.  good idea though
01:56:52 <mgsloan> I'm not sure what the translated haskell would look like anyway
01:57:13 <syntaxfree> well, you can write unspecified sum types, product types, etc.
01:57:21 <syntaxfree> cons-like types also.
01:57:21 <mgsloan> unless you assume that all applicable data types are generated by my thingamabob
01:57:45 <syntaxfree> of the form data Thing = Nothing | Together Thing Nothing
01:58:43 <mgsloan> you mean Together Thing Thing?
01:58:55 <syntaxfree> I mean together thing nothing.
01:59:03 <mgsloan> 0_o
01:59:11 <syntaxfree> lists are data List = Nil | Cons List Nil, ain't?
01:59:57 <mgsloan> data List a = Nil | Cons a List ?
02:00:37 <syntaxfree> uh, true.
02:00:46 <mgsloan> I think you're doing church numerals or whatever you call em
02:00:51 <syntaxfree> yep.
02:00:57 <syntaxfree> or Peano numbers.
02:01:03 <syntaxfree> no, not peano numbers.
02:01:12 <syntaxfree> peano numbers are data Nat = Zero | Next N at
02:03:21 <syntaxfree> anyway, I'm just talking out of my armpits here. I have such a conceit.
02:04:15 <syntaxfree> They should port lamdabot to vim.
02:04:21 <syntaxfree> Google, dictionaries, etc. are trÃ¨s useful.
02:04:49 <mgsloan> :)
02:06:46 <mgsloan> I've only had haskell on my comp for 4 months...
02:07:00 <mgsloan> (and no functional langs before that)
02:08:27 <syntaxfree> Not even Scheme, from CS101?
02:08:54 <mgsloan> hah.
02:08:57 <syntaxfree> I've been thinking of an informal enumeration of ways people arrive to Haskell.
02:09:06 <mgsloan> I'm in highschool
02:09:22 <syntaxfree> One classic way is through learning Scheme as a first language and never adapting to the later imperative expectations.
02:09:32 <syntaxfree> Another is through mathematics.
02:09:41 <mgsloan> my way was language design
02:09:54 <syntaxfree> A third one, that we're only starting to see is through Haskell's sheer cool factor.
02:10:19 <audreyt> my way was through dire need to write high-performing binary stream processors running on 350mhz AIX machines
02:10:25 <audreyt> "industrial"
02:11:07 <mgsloan> ooh. nice. the performance way
02:11:23 <audreyt> ocaml would've worked better, but its codegen doesn't evn work on aix.
02:11:31 <syntaxfree> the industrial way.
02:11:48 <audreyt> and then I got addicted to unsafeInterleaveIO
02:11:52 <audreyt> and the rest just follows :)
02:12:29 <mgsloan> sheer cool factor might lead to the cocky type though - people move up the Blub chain and reach the top and lord it over the rest
02:12:44 <mgsloan> then again this lording might enduce jelousy and thus more converts... hmm
02:13:08 <audreyt> but I was convinced of its industrial purpose only after looking at darcs code
02:13:23 <audreyt> so droundy is also arguably of the industrial school, as he needs something to replace C++, and quick
02:14:41 <audreyt> and to me a fine working program beats beautiful source code or algorithm every single time :)
02:15:27 <mgsloan> heh.  For me, if it doesn't work, at least you have something pretty to look at :)
02:16:18 <audreyt> well my codepath is basic->visualbasic->perl->haskell so that may have affected my sense of aesthetics... :)
02:17:10 <syntaxfree> I did some Basic as a kid.
02:17:14 <mgsloan> ah.  I'm Basic -> tons of other things -> haskell
02:17:21 <syntaxfree> Really, a kid. I even wrote some stupid games.
02:17:29 <syntaxfree> I did look at VB once or twice as a teen.
02:17:36 <mgsloan> yeah, I did basic at 8
02:17:43 <syntaxfree> But essentially I hadn't programmed much from ages 10 to 21.
02:17:52 <syntaxfree> At age 21, I took an introductory CS course in Schem,
02:17:57 <syntaxfree> s/Schem,/Scheme
02:17:57 <mgsloan> wrote unbeatable tic tac toe at 9 and a wireframe renderer at 10 or 11
02:18:08 <mgsloan> those are my cool programs at least
02:19:00 <mgsloan> problem with chronological ordering is for lots of languages I learned them, used them a bit, and went back to my old fav language
02:19:12 <mgsloan> plus i can't really remember it straight
02:20:54 <mgsloan> basic certainly affected my sense of aesthetics for a long while
02:21:28 <mgsloan> but nothing else really recaptured it, which is maybe why I'm into language design :)
02:23:42 <mgsloan> argh.  Tackling the awkward squad is starting to use math symbols - time to skim :)
02:37:51 <mgsloan> > length [error "foobar"]
02:37:52 <lambdabot>  1
02:37:55 <mgsloan> hah
02:42:19 <syntaxfree> tsc.
02:42:40 <Cale> mgsloan: math symbols?
02:44:23 <Cale> mgsloan: are you referring to the places where they include semantics?
02:44:42 <mgsloan> yeah.
02:44:51 <mgsloan> on further inspection its just pretty printed haskell...
02:45:26 <mgsloan> well, that transitions stuff is definitely not haskell
02:45:52 <mgsloan> starts looking like epigram by the time it gets to IORefs
02:53:12 <therp> there is no way to get anything like a backtrace in GHC?
02:55:19 <audreyt> you can with +RTS -xc
02:55:28 <audreyt> or with the new debugger support in GHC trunk (6.7)
02:56:33 <audreyt> google for details :) bbl &
03:02:34 <Stinger> hmm there are quite a few libs that don't work with 6.6-3?
03:02:51 <Stinger> or are debian packages lying to me
03:04:19 <Igloo> Which libs?
03:04:52 <Stinger> gtk2hs and the cairo one
03:05:26 <Igloo> Right, there hasn't been a release of them which works with 6.6
03:06:16 <Stinger> damn, aptitude isnt giving me compatible versions of ghc :(
04:01:34 <Stinger> dont suppose anyone knows where I can find ghc 6.4.2 debian packages?
04:03:22 <lightstep> they should be on the standard repositories. you can also check ubuntu universe repositories
04:22:29 <Igloo> Stinger: snapshot.debian.{org,net} might have them
04:25:17 <Stinger> hmm looks promising
04:28:51 <lightstep> ?darcs gtk2hs
04:28:51 <lambdabot> gtk2hs not available
04:29:42 <lightstep> ?darcs+ gtk2hs http://darcs.haskell.org/gtk2hs/
04:29:43 <lambdabot> Unknown command, try @list
04:36:24 <lightstep> will haskell' have lexical syntax for ByteStrings?
04:49:23 <yip> what sort of syntax?
04:58:19 <lightstep> like numbers, perhaps? so you can use "" :: ByteString
04:58:20 <ski> maybe the usual string one .. overloading
04:59:01 <ski> "foo" :: Str s => s
04:59:05 <ski> or something
05:02:06 <delYsid> Anyone got a haskell-ldap usage example for me?
05:11:33 <rohar> yawn
05:14:22 <therp> yeah, be gone TH restriction to not use local bindings in splices!
05:21:23 <ski> therp : there's no cross-stage persistance in TH ?
05:22:27 <ski> hm, did you mean local bindings in the run-time program or local bindings in the compile-time program ?
05:22:31 <therp> ski: no, I'm not talking about that. TH forbids you to use bindings in splices that are defined in the same file which is being compiled.. well this restriction is gone now
05:24:01 <ski> (it's not clear which bind and use levels you refer to ..)
05:24:39 <therp> you can now use top level bindings in splices, not only from external modules but from the compiled one
05:25:04 <ski> use inside '[|','|]' in splices, or outside ?
05:25:15 <therp> splices == $(xx)
05:25:22 <therp> [ ] brackets
05:25:46 <ski> yeah .. but '$(..foo..)' or '$(..[|..foo..|]..)' ?
05:26:09 <therp> first one. the second one works already...
05:26:12 <ski> ok
05:26:27 <therp> foo = ... ; $(... foo ...)
05:27:28 <ski> hm, how does that work if 'foo' is defined to be 'unsafePerformIO . newIORef $ ...' ?
05:28:07 <ski> (.. probably badly)
05:29:29 <jethr0> *yuch*, recursive metaprogramming. as if my head didn't hurt enough already
05:29:40 <jethr0> now you can generate code that is the fixpoint of some function ^_^
05:30:28 <Philippa> ski: probably by just doing it, as the quotation monad can do IO anyway
05:30:38 <Philippa> a fact I've abused in the past :-)
05:55:40 <ski> (Philippa : i meant that probably the io-reference used in the TH stage will be unrelated to the one used at run-time ..)
06:01:55 <augustss> howdy
06:02:21 <hygge> how
06:04:25 <Philippa> ski: D'oh. Yes, horribly unsafe in that regard
06:05:07 <Philippa> at least, if you're not careful
06:05:47 <ski> (:
06:13:47 <augustss> anything defined by unafePerformIO should be treated with caution :)
06:13:59 <augustss> even with unsafePerformIO :)
06:17:26 <therp> ski: well it would work, but there would be two effects of an unsafePerformIO, one to the compile and one to the runtime environment
06:20:26 * ski wonders if jethr0 meant 'foo = ..$(..foo..)..'
06:42:18 <augustss> I just love the list of top used words on this channel :)
06:42:31 <pjd> where?
06:42:56 <augustss> http://www.cse.unsw.edu.au/~dons/irc/haskell-06.html
06:42:57 <lambdabot> Title: #haskell @ freenode.org stats by dons
06:43:15 <pesco> Can anyone think of a nice adjective for "supporting out-of-order operation" which is not "asynchronous"?
06:44:10 <augustss> haskell think would which right should Monad could function something
06:45:34 <augustss> pesco: you mean different from the usual suspects like parallel or concurrent?
06:46:49 <kpreid> reorderable?
06:47:09 <kpreid> independent?
06:47:35 <pesco> Okay, let me be more concrete. It's a parser and you can tell it to save the stuff a subparser just consumed and to (re-)parse it again later.
06:47:52 <pesco> s/and to/to/
06:48:03 <ndm> i'd call it a form of modular
06:48:04 <lambdabot> ndm: You have 1 new message. '/msg lambdabot @messages' to read it.
06:48:34 <pesco> ndm: Hm, nah. I'm looking for something to convey the fact that this enables you to basically jump around in the input.
06:48:42 <kpreid> nonlinear?
06:48:56 <pesco> kpreid: That's what I was looking for! I think. :)
06:49:26 <pesco> My brain isn't the best today. ;)
06:51:53 <pesco> augustss: Would be interesting to see the list of words most used modulo their frequency in "normal language".
06:55:50 <ndm> @tell glguy i went with a variant of that - i @ulpl'd the generate, to make it a bit clearer - thanks!
06:55:51 <lambdabot> Consider it noted.
06:57:08 <pjd> kpreid: possibly some variant of "preemptive"
07:00:11 <pjd> "inconsequential parsing" :)
07:00:56 <ndm> the darcs irc is dead, no one is answering me :(
07:17:29 <SamB> ndm: hang on for maybe a day or so?
07:17:39 <ndm> SamB, have an answer now
07:17:44 <SamB> ;-)
07:28:41 <lisppaste2> fabiim pasted "Show problem - how can i get the newline characters to make a new line and not \n on a string ?" at http://paste.lisp.org/display/33284
07:29:56 <Lemmih> Print the string with 'putStrLn'?
07:30:09 <fabiim> well it isn't working .
07:30:21 <yip> ndm: i think rollback will automatically create an inverse patch
07:31:00 <ndm> yip: my question was more if you can push the reversre patch, i think when i tried a push it did push it, butwithout any confirmation or notice
07:31:17 <Lemmih> fabiim: Works for me.
07:33:08 <fabiim> well , it works when you putStrLn  " put a string here with \n characters where you want" , with me it doesn't because... well if i knew i wasn't asking right? =)
07:34:14 <Saizan> fabiim you have to remove those "show"
07:34:19 <Saizan> notice the difference:
07:34:20 <Saizan> Prelude> putStrLn "\n"
07:34:20 <Saizan> Prelude> putStrLn $ show "\n"
07:34:20 <Saizan> "\n"
07:34:20 <Saizan> Prelude>
07:34:57 <Saizan> (avfter the first command there should be 2 empty lines)
07:36:30 <fabiim> i see . thanks
07:36:53 <pesco> Anybody know what's the current story wrt. to http://hackage.haskell.org/trac/ghc/wiki/GhcPackages ?
07:36:55 <lambdabot> Title: GhcPackages - GHC - Trac
07:44:07 <moomlyn> hey, can anybody here read sanskrit?
07:44:59 <Lemmih> moomlyn: How's sanskrit related to Haskell?
07:45:17 <moomlyn> Lemmih, in many subtle ways
07:52:25 <kpreid> ndm: someone answered after you left #darcs.
07:52:43 <ndm> kpreid: cheers, i've sorted it now
07:53:06 <ndm> kpreid: is darcs logged?
07:54:18 <kpreid> ndm: there's a URL in the topic. the single line was: <clanehin> ndm: rollback
07:54:51 <ndm> ah :)
07:55:11 <clanehin> yeah, I did, and then I was like, wait, someone answered before me in #haskell
07:57:36 <ndm> clanehin: well thanks for the answer anyway :)
08:11:39 <posidon> Is it normal that GHC creates big executables? How that impacts on performance?
08:12:11 <hyrax42> posidon: I believe it's normal
08:12:27 <hyrax42> I think it is due to including the ghc runtime in there
08:12:39 <hyrax42> and performance, not much I think
08:13:00 <posidon> Ok, thanks.
08:15:11 <ndm> does anyone know how to load an HTML document into a parse tree?
08:15:32 <ndm> specifically i want to take a haddock document and navigate it a bit
08:15:48 <ndm> Text.HTML seems to go HTML -> String, not the other way round
08:15:52 <ndm> @hoogle String -> HTML
08:15:53 <lambdabot> No matches, try a more general search
08:17:17 <Saizan> hxt?
08:17:53 <ndm> ideally in the base libraries...
08:18:13 <ndm> and yeah, there seem to be plenty of libs to do this, i just want to parse somesimple HTML without much structure...
08:18:17 <opqdonut> ?hoogle primhtml
08:18:18 <lambdabot> Text.Html.primHtml :: String -> Html
08:18:18 <lambdabot> Text.Html.primHtmlChar :: String -> Html
08:19:34 <ndm> @hoogle String -> Html
08:19:35 <lambdabot> Text.Html.afile :: String -> Html
08:19:35 <lambdabot> Text.Html.clickmap :: String -> Html
08:19:35 <lambdabot> Text.Html.itag :: String -> Html
08:19:47 <ndm> @karma- hoogle -- for being case sensitive in stupid ways
08:19:47 <lambdabot> hoogle's karma lowered to 1.
08:19:56 <ndm> thanks opqdonut
08:20:37 <opqdonut> np
08:21:07 <yaxu> this programming in haskell book really is good
08:21:26 <Saizan> dons's posts?
08:23:01 <ndm> yaxu: graham huttons?
08:53:13 <Botje> @pl \arr x y -> arr ! (x,y)
08:53:14 <lambdabot> (. (,)) . (.) . (!)
08:53:16 <Botje> eep
08:55:01 * allbery_b remembers being traumatized by J's pointfree style years ago
08:55:16 <integral> @type uncurry
08:55:16 * LoganCapaldo wonders how long it'll be until @pl spits out ...
08:55:17 <lambdabot> forall c b a. (a -> b -> c) -> (a, b) -> c
08:55:20 <allbery_b> ...explains why it took me so long to look into functional programming :)
08:55:44 <integral> @type \arr -> curry (arr!)
08:55:45 <lambdabot> forall e a b. (Ix (a, b)) => Array (a, b) e -> a -> b -> e
08:55:52 <integral> @pl \arr -> curry (arr!)
08:55:52 <lambdabot> curry . (!)
08:55:57 <integral> oooh, nice
08:56:59 <syntaxfree> http://steve.yegge.googlepages.com/next-big-thing
08:57:00 <lambdabot> Title: Stevey&#39;s Home Page - The Next Big ThingÂ
08:57:12 <syntaxfree> this Steve Yegge does a good job in explaining functional programming to the perplexed masses.
08:57:40 <syntaxfree> (Until he goes on to toot Ruby's horn, but his patient, step-by-step explanation of why closures and first-class functions matter is nice)
08:58:24 <matthew__> ?hoogle a -> (a -> b) -> b
08:58:26 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
08:58:26 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
08:58:26 <lambdabot> Control.Parallel.Strategies.($|) :: (a -> b) -> Strategy a -> a -> b
08:58:50 <opqdonut> matthew__: what are you looking for?-)
08:58:54 <syntaxfree> this quotation is interesting:
08:59:00 <matthew__> applySubsToType :: Type -> [TypeSubstitution] -> Type
08:59:00 <matthew__> applySubsToType t subs = foldl (\t' s -> s t') t subs
08:59:05 <syntaxfree> "Heck, Haskell has thus far been unable to reach me, even though I've bashed my thick skull against three or four Haskell books."
08:59:13 <matthew__> opqdonut : how to replace the \lambda in there
08:59:34 <augustss> @pl \t' s -> s t'
08:59:35 <lambdabot> flip id
08:59:38 * Botje is still stuck in the buying-a-ten-foot-pole-to-check-out-monads stadium
08:59:39 <matthew__> ahh, tnx
08:59:48 <matthew__> I thought flip might be involved
08:59:51 <matthew__> ;)
08:59:58 <opqdonut> :)
08:59:59 <syntaxfree> I'm starting to consider the idea that comonads are easier to understand than monads.
09:00:08 <syntaxfree> Sigfpe's recent examples are very compelling.
09:01:00 <tolik> @type (>>>)
09:01:02 <lambdabot> forall (a :: * -> * -> *) d b c. (Arrow a) => a b c -> a c d -> a b d
09:01:14 <koala_man> I have a list of lists like [[1],[2,3]]. How can I get a string like "1 23"? I have (unwords (map (foldl (++) "") (map (map show) [[1],[2,3]]))) which works but it seems kind of obscure
09:01:36 <integral> @type (>>>) :: (b -> c) -> (c -> d) -> (b -> d)
09:01:37 <lambdabot> (b -> c) -> (c -> d) -> (b -> d) :: forall b c d. (b -> c) -> (c -> d) -> b -> d
09:02:10 <matthew__> syntaxfree: do comonads have anything to do with coinductive types?
09:02:19 <syntaxfree> Maybe they do.
09:02:29 <syntaxfree> I don't know coinductive types!
09:02:50 <Igloo> koala_man: You can write that as unwords (map (concact . map show) [[1],[2,3]])
09:03:09 <matthew__> ahh ok. they confuse me. so if they were related then I might not agree with the "easiness" of them ;)
09:03:10 <koala_man> Igloo: nice, thanks
09:03:16 <syntaxfree> matthew: http://sigfpe.blogspot.com/
09:03:18 <lambdabot> Title: A Neighborhood of Infinity
09:03:37 <Igloo> koala_man: Or   unwords (map (concatMap show) [[1],[2,3]])
09:03:50 <koala_man> yay, even better
09:04:12 <Igloo> koala_man: If you like point-free then that's   f = unwords . map (concatMap show)
09:05:06 <Botje> @pl \x y -> compare (fst x) (fst y)
09:05:07 <lambdabot> (. fst) . compare . fst
09:05:38 <glguy> comparing g x y = g x `compare` g y -- I usually define this
09:05:39 <lambdabot> glguy: You have 1 new message. '/msg lambdabot @messages' to read it.
09:06:22 <glguy> oh my, I feel so popular
09:06:56 <AtnNn> "
09:07:26 * monochrom is back to destroy you!
09:09:17 <reborn___> HI i have something like this
09:09:19 <reborn___> main=
09:09:21 <reborn___>     do menu
09:09:22 <reborn___> 	 s<-getLine
09:09:23 <reborn___> 	 case (read(s)::Int) of
09:09:25 <reborn___> 	 1 -> do name<-getLine
09:09:27 <reborn___> 		      x<-readFile name
09:09:27 <syntaxfree> @paste
09:09:27 <lambdabot> http://paste.lisp.org/new/haskell
09:09:28 <reborn___> 	              convert x
09:09:30 <reborn___> 		      main
09:09:31 <reborn___>           3 -> do name<-getLine
09:09:32 <syntaxfree> don't''paste here, paste there.
09:09:33 <reborn___> 		       x<-readFile name
09:09:34 <reborn___> 	               writeFile name (convertgr x)
09:09:36 <reborn___> 		       main
09:09:37 <reborn___> The first one which only reads a file works fine and the other says "Exception:***openFile permission denied, when I open the same file, what's wrong?
09:09:40 <syntaxfree> that's incredibly rude.
09:09:45 * glguy does a /clear
09:09:46 <lambdabot> glguy: You have 1 new message. '/msg lambdabot @messages' to read it.
09:10:01 <Botje> reborn___: put that on a pastebot. have you read the topic?
09:10:15 <Botje> (maybe the topic should include something about pastebots)
09:10:18 <monochrom> I think it's ok for the first time. :)
09:10:19 <reborn___> no:S
09:10:43 <reborn___> sorry then
09:10:55 <gravity> I don't think the paste stuff is in /topic right now
09:10:58 <syntaxfree> put the code in the pastebot. it's also hard to read it interspersed by nicknames.
09:11:13 <dylan> @topic-add "pastebin: http://paste.lisp.org/new/haskell"
09:11:13 <lambdabot> Unknown command, try @list
09:11:20 <dylan> @topic+ "pastebin: http://paste.lisp.org/new/haskell"
09:11:21 <lambdabot> Unknown command, try @list
09:11:44 <dylan> ah, right. list operations
09:11:50 <dylan> @topic-cons "pastebin: http://paste.lisp.org/new/haskell"
09:11:51 <lambdabot> I do not know the channel "pastebin:
09:12:09 <monochrom> perhaps the file is already open for reading, and therefore not available for writing?
09:12:15 <syntaxfree> @topic-cons #haskell "paste-bin: : http://paste.lisp.org/new/haskell"
09:12:24 <glguy> people that don't know enough about IRC to use a paste bin probalby don't read the topic
09:12:42 <syntaxfree> clueless newbies are a sign of popularity :)
09:12:48 <glguy> hurrah!
09:12:48 <monochrom> Eh? The topic is so short? :)
09:13:07 <dylan> the channel is set +t
09:13:15 <dylan> and lambdabot is not an op
09:13:16 <glguy> and lambdabot is -o
09:13:45 <syntaxfree> \bot should be smart enough to op himself via chanserv when needed.
09:14:21 <clanehin> I would like to mention a computer game I'm writing with haskell and opengl at http://roguestar.downstairspeople.org
09:14:22 <lambdabot> Title: Roguestar
09:14:24 <glguy> \bot should respond to \bot
09:14:40 <monochrom> that is strict.
09:14:48 <matthew__> clanehin: ooh! woot.
09:15:20 <syntaxfree> clanehin: mention it to the HCAR as well!
09:15:40 <syntaxfree> @google haskell community and activities report
09:15:42 <lambdabot> http://www.haskell.org/communities/11-2006/html/report.html
09:15:42 <lambdabot> Title: Haskell Communities and Activities Report
09:15:52 <syntaxfree> also, mentioning it in haskell-cafe is likely to get you in Haskell Weekly News.
09:16:28 <clanehin> I plan to do all of that; I thought I'd get an initial reaction
09:16:32 <matthew__> mmm. are you doing any intensive physics or game engine?
09:16:40 <syntaxfree> The screenshots look cool.
09:16:55 <clanehin> there is a tremendous amount of work that is not yet done
09:17:08 <syntaxfree> I'm not a fan of nethacks.
09:17:11 <syntaxfree> Or games in general.
09:17:17 <syntaxfree> Except maybe for Tetris and variants.
09:17:22 <syntaxfree> Block Out, Snood, etc.
09:17:22 <matthew__> I'm in the process of writing a haskell+ogl game and would be glad to talk about optimisations that have worked for you...
09:18:10 <yip> i've done a bit of haskell opengl programming
09:18:20 <yip> including some car physics
09:18:24 * allbery_b is kinda like that, except he's developed a perverse fondness for lindley's dungeon crawl after mostly not being able to get into roguelikes
09:18:25 <syntaxfree> I've drawn squares in OpenGL ;)
09:18:58 <clanehin> matthew: I havn't needed to do many optimizations, other than using display lists heavily, my perlin noise function is very slow thought which is a problem
09:19:04 <syntaxfree> I'm attracted to the idea of Z-machine like text-adventure games. But I never actually enjoyed a game.
09:19:17 <matthew__> I've done full spring mesh physics, real gravity and octtrees...
09:19:25 <monochrom> I'm a fan of destruction :)
09:19:55 <clanehin> no I don't do that kind of physics
09:19:56 <dylan> I like nethack-like games, though,
09:20:07 <yip> clanehin: looks kind of cool. but 1995 called and they want there wm back :P
09:20:16 <monochrom> full spring mesh, does that mean the fish wiggles, and the guy woggles? :)
09:20:22 <matthew__> yes
09:20:22 <dylan> syntaxfree: re: destruction, I only have really like games where I can abuse things (black and white, the sims, grand theft auto...) :)
09:20:32 * monochrom wobbles
09:20:38 <matthew__> monochrom: and when there are impacts, you get ripples and stuff
09:20:51 <syntaxfree> You destroy things in Tetris and Block Out!
09:20:51 <yaxu> ndm: yes (sorry for the delay)
09:20:53 <syntaxfree> Whole squares!
09:21:47 <matthew__> clanehin: I presume that in the screenshot of encephalon it's deliberate that you seem to have the normals of the areas of the field/beach unaveraged?
09:22:20 <clanehin> matthew__: yes, it makes a quilt pattern that lets you know where the tiles are
09:22:23 <monochrom> I play Age of Mythology.  I save the game at the moment I am ready to devastate the enemy.  Then I re-load it many times.
09:22:59 <clanehin> I'll eventually add grass or something
09:23:00 <matthew__> clanehin: sure.
09:23:03 <monochrom> (I am perverted)
09:23:54 <monochrom> (I killed the conversation)
09:24:19 <glguy> ?slap monochrom
09:24:28 <lambdabot> why on earth would I slap monochrom
09:24:34 <monochrom> hahahaha
09:24:37 <glguy> heh
09:24:38 <matthew__> ?slap lambdabot
09:24:39 * lambdabot beats up lambdabot
09:24:45 <matthew__> ?slap monochrom
09:24:46 * lambdabot smacks monochrom about with a large trout
09:24:50 <matthew__> sorted.
09:27:22 <clanehin> matthew__: url for yours?
09:28:59 <opqdonut> ?slap me
09:29:00 * lambdabot beats up opqdonut
09:29:03 <opqdonut> oh yeah!
09:52:29 <yaxu> what are recommended haskell opengl bindings?
09:53:52 <gravity> Are there more than one?
09:55:27 <yaxu> well i found hogl and hopengl, the latter seems more developed but not updated since '03
09:56:13 <Lemmih> Got an URL for hogl?
09:56:47 <allbery_b> "nott updated", or "not independently updated"?  (HOpenGL is part of the standard libs these days)
09:56:59 <Lemmih> Ah, found it.
09:57:35 <yaxu> allbery_b: ah right, maybe the latter
09:58:19 * allbery_b tripped over that with parsec, google points you to the original disribution but the version in the standard libs is newer
09:58:53 <yaxu> so if this example isn't compiling, i should try grabbing the latest ghc
09:59:31 <allbery_b> make sure you get the extralibs
10:01:49 <yaxu> thanks
10:15:02 <emu> yea i noticed a lot of out of date tutorial material for HOpenGL
10:16:19 <glguy> is there parsec documentation newer than 4 Oct 2001? http://www.cs.uu.nl/~daan/download/parsec/parsec.html
10:17:34 <glguy> I guess: http://www.haskell.org/ghc/docs/latest/html/libraries/parsec/Text-ParserCombinators-Parsec.html
10:17:37 <lambdabot> http://tinyurl.com/yzf69j
10:18:23 <psi> has anyone used HGL and found that the display just won't update, unless you move around with mouse etc.?
10:18:53 <emu> i didn't have any trouble working from the parsec manual from the parsec homepage
10:19:05 <emu> (besides the fact that the module names are different)
10:19:20 <allbery_b> there's some newer combinators not documented there, though
10:19:23 <emu> psi: do you have an update function
10:19:59 <psi> i don't think there is one
10:20:03 <rohar> I've got a little piece of Haskell code that isn't sexy enough.  Can anyone help me sex it up?
10:20:24 <emu> that would be the problem
10:20:38 <emu> http://blog.mikael.johanssons.org/archive/2006/09/opengl-programming-in-haskell-a-tutorial-part-1/
10:20:40 <allbery_b> @paste
10:20:43 <lambdabot> Title: Michi&#8217;s blog Â» Blog Archive Â» OpenGL programming in Haskell - a tutorial ..., http://tinyurl.com/ea6tc
10:20:43 <lambdabot> http://paste.lisp.org/new/haskell
10:21:09 <augustss> rohar: show us
10:21:12 <rohar> processArgs :: [String] -> IO ()
10:21:12 <rohar> processArgs [] = return ()
10:21:12 <rohar> processArgs(x : xs) = do
10:21:12 <rohar>     case x of
10:21:12 <rohar>     	"-h" -> printHelp
10:21:12 <rohar>     	"-u" -> printComputation
10:21:15 <rohar>     	_ -> error "Invalid option"
10:21:17 <rohar>     processArgs xs
10:21:23 <allbery_b> rohart: stop.  use the pastebin
10:21:29 <psi> emu: this is not opengl, but the Graphics.HGL library.
10:21:31 <augustss> ummm, a paste please
10:21:33 <rohar> ack sorry
10:21:40 <allbery_b> @paste
10:21:40 <lambdabot> http://paste.lisp.org/new/haskell
10:21:46 <emu> rohar: stop, use GetOpt
10:21:58 <rohar> GetOpt ?
10:22:27 <emu> psi: oops. i havent messed much with that
10:22:31 <paolino> I'm reading http://www.nomaware.com/monads/html/writermonad.html which says there is no way to modify the past output.
10:22:32 <paolino> So that delayed logging is necessary. Isn't censor there to modify it  ?
10:22:32 <lambdabot> Title: The Writer monad
10:22:45 <emu> http://haskell.org/haskellwiki/High-level_option_handling_with_GetOpt
10:22:47 <lambdabot> Title: High-level option handling with GetOpt - HaskellWiki, http://tinyurl.com/ynhvsx
10:23:44 <rohar> GetOpt noted.  From a learning point of view, anyway to do that pattern match on a list and it's first element in the same construct?
10:24:26 * allbery_b is actually nto convinced GetOpt is all that useful in Haskell.  in other languages, yes, but Haskell isn't that lame :)
10:24:45 <glguy> allbery_b: How do you parse command line arguements instead?
10:24:47 <emu> it's a nice declarative options parser
10:25:04 <allbery_b> pattern matching
10:25:07 <emu> rohar: '-':'h':xs
10:25:07 <pesco> rohar: Yes, the obvious way: processArgs ("-h":xs) = printHelp >> processArgs xs
10:25:27 <glguy> allbery_b: so you write pattern matches that understand that: -abc is actually -a -b -c
10:25:30 <allbery_b> getopt was originally developed for C-like languages which suck at that kindof thing
10:25:30 <emu> er, yea list of strings, not list of chars
10:25:34 <emu> "-h":xs
10:25:42 <augustss> rohar: does that even do what you want?
10:25:55 <pesco> rohar: Where "obvious" was supposed to be put in quotes. ;)
10:26:08 <rohar> augustss: it does.. but I have low expectations :-)
10:26:28 <allbery_b> sure, it's not that hard (but note that the -abc style is deprecated these days, because having both -abc and -hfoo (for example) is confusing
10:26:43 <glguy> it's deprecated?
10:26:51 <pesco> Depends on who you ask.
10:27:00 <glguy> that's not how deprecation works
10:27:01 <augustss> rohar: perhaps you should use a paste so we can see it with the right indentation
10:27:01 <allbery_b> well, perhaps not officially, but many folks consider it a Bad Idea
10:27:04 <rohar> allbery_b: y, but I'm just playing around.. not writing anything significant
10:27:27 <rohar> augustss: is this the place to admit that I don't know how to use pastebin?
10:27:40 <rohar> I'm using mIRC
10:27:44 <glguy> allbery_b: either way, most folks perfer that all their ocmmand line tools interpret flags the same... so writing a custom parser seems like a "Bad Idea"
10:28:01 <glguy> rohar: If you can't figure out hte pastebin website... haskell isgoing to be a nightmare
10:28:34 <allbery_b> rohar: just go to the page in your browser.  it gives you a big text box into which you paste your code, and boxes where you say who you are and what channel to paste to.
10:28:46 <allbery_b> it's pretty obvious
10:28:59 <Khisanth> hrm it's one anyway :/
10:29:23 <rohar> glguy: ta da! http://pastebin.com/843845
10:29:47 <glguy> rohar: but next time use the following if you want syntax highlighting ;)
10:29:48 <glguy> ?paste
10:29:49 <lambdabot> http://paste.lisp.org/new/haskell
10:30:10 <pesco> rohar: I've written a command line parsing lib: Search http://www.khjk.org/~sm/ for the words "Command line".
10:30:12 <glguy> rohar: sure, if you are only looking for a single flag or so, that works fine
10:30:14 <allbery_b> glguy: (1) it's trivial to achieve that without a magc function in haskell, vs. (say) C or Java; (2) you already have divergent getopt standards anyway
10:30:56 <yaxu> well compiling ghc6.6 has taken care of heating the house
10:31:06 <rohar> glguy: thx.. was wondering if there was a more elegant idiomatic way
10:31:08 <allbery_b> (USG getopt vs. GNU getopt, and hen several varieties of GNUish getopt differing n how long options handle arguments)
10:31:12 <pesco> rohar: John Meacham has one also, called GetOptions: http://www.repetae.net/
10:31:13 <lambdabot> Title: John Meacham's Homepage
10:31:23 <allbery_b> yaxu: no binary package for your platform?
10:31:42 <rohar> pesco: thx, I'll look... just trying to learn Haskell
10:31:53 <augustss> rohar: looks like you could use mapM
10:32:16 <glguy> rohar: I use GetOpts as my more elegant way, but if you are only checking for two flags, no arguments, no optional arguments, and not filenames and not checking for "--" to end flag parsing, this is fine
10:32:19 <augustss> or mapM_
10:32:34 <Saizan> rohar: maybe you can pattern match on the argument instead of using case .. of
10:32:57 <rohar> glguy: what is ?paste ?
10:33:09 <glguy> rohar: the reason that lambdabot prints the url
10:34:15 <glguy> rohar: http://pastebin.com/843848
10:34:50 <glguy> rohar: of, and you would get rid of the processArgs [] line in this case
10:35:40 <lisppaste2> glguy pasted "my response to rohar on paste.lisp.org" at http://paste.lisp.org/display/33291
10:39:12 <yaxu> allbery_b: i hadn't really thought about it for some reason...  i'm on ubuntu, the official packages are still on 6.4 although i guess i could have taken the binary tarball
10:40:25 <allbery_b> normallyI'd go for source as well.  but, well, I've built ghc before (being a user of ports on both freebsd and OSX) --- I'll take the binary packages, thanks :)
10:41:16 <allbery_b> (then again, one learns that early in freebsd, by making the mistake of trying to build cvsup from ports :)
10:41:45 <glguy> it's written in modula3 or something , right?
10:41:58 <allbery_b> yes.  so it sucks in a modula3 compiler
10:42:08 <glguy> yeah, I remember making that mistake :)
10:42:16 <allbery_b> and it's only very recently that cvsup has been obviated by csup (for the base system) and portsnap (for ports)
10:43:14 <psi> is anyone running ghc 6.6 with GLUT under debian? I get undefined references to various glut stuff, and --make or -package GLUT doesn't help.
10:44:20 <psi> installed the libghc6-glut-dev package...
10:44:55 <yaxu> ah, i was going to suggest libghc6-library-dev
10:44:58 <arjanoosting> psi: can you paste the error?
10:45:00 <allbery_b> do you have the non-haskell glut libs installed?
10:45:06 <psi> ?paste
10:45:06 <lambdabot> http://paste.lisp.org/new/haskell
10:45:30 <allbery_b> (since libghc6-glut-dev is just a wrapper for the GLUT libs)
10:47:15 <lisppaste2> psi pasted "glut issue" at http://paste.lisp.org/display/33292
10:49:07 <psi> i manually installed some of that stuff, they weren't all dependencies of libghc6-glut-dev
10:52:50 <arjanoosting> psi: ghc does not call gcc with the -lglut, so the glut library does not get linked in
10:55:16 <arjanoosting> psi: ghc -lglut -package GLUT tut.hs
10:55:31 <arjanoosting> psi: ^ should work.
10:56:09 <psi> you're right, it did. thanks :)
10:57:26 <Lemmih> '-package GLUT' should imply -lglut.
10:59:41 <glguy> like a special case built into GHC for that specific package?
10:59:49 <arjanoosting> Lemmih: yes it should. I will file a bug against the debian package
11:00:55 <sorear> ?seen
11:00:55 <lambdabot> Lately, I have seen arjanoosting, glguy, lemmih, lisppaste2, psi and sorear.
11:01:16 <opqdonut> ?seen
11:01:17 <lambdabot> Lately, I have seen arjanoosting, glguy, lemmih, lisppaste2, opqdonut, psi and sorear.
11:01:23 <opqdonut> :)
11:10:42 <arjanoosting> glguy: no need for a special case, the extra-libraries entry in the .cabal file can be used for this.
11:10:58 <glguy> ah, cool
11:11:27 <arjanoosting> anyway bug filed. /me continues watching movies
11:19:02 <glguy> why would ViM highlight the word default in a Haskell file?
11:19:12 <sjanssen> default is a keyword
11:19:12 <Cale> because it's a keyword
11:19:21 <glguy> right, but I can't remember where it's used
11:19:30 <Cale> to start a default declaration
11:19:32 <sjanssen> for numeric defaulting
11:19:55 <Cale> http://haskell.org/onlinereport/decls.html#sect4.3.4
11:19:56 <lambdabot> Title: The Haskell 98 Report: Declarations
11:20:39 <sjanssen> it's a very rarely used feature
11:20:47 <glguy> woa
11:20:50 <glguy> whoa* :)
11:21:07 <glguy> looks like I stumbled into learning something new
11:22:20 <Uccus> I have a question, is it a good time to ask?
11:22:28 <glguy> do you have an appointment?
11:22:39 <Uccus> err... no
11:22:42 <Uccus> 8-)
11:22:56 <Cale> Ask away :)
11:23:03 <psnl> this is a walk in irc channel
11:23:07 <liyang> take a ticket from the dispenser over there and wait in like please.
11:23:11 <emu> just be warned, if you ask a question ... we might answer it
11:23:23 <rohar> it's true.  they do.
11:23:33 <Uccus> well, what's the difference between data and newtype?
11:23:35 <Cale> however, if you ask no question, we will certainly answer it
11:23:55 <rohar> that's true too.  They answer no question all the time
11:24:03 <emu> question () = ()
11:24:03 <Cale> Semantically newtypes are unlifted, which means if youu have:
11:24:08 <Cale> data D = D Integer
11:24:10 <Uccus> well, yeah, I've heard about the friendliness tossed around in this channel
11:24:13 <Cale> newtype N = N Integer
11:24:21 <Cale> Then N undefined = undefined
11:24:29 <glguy> Uccus: Hurry up and answer before Cale goes into a <<loop>>
11:24:29 <Cale> but D undefined is not equal to undefined
11:24:31 <glguy> ask*
11:24:32 <emu> Uccus: newtype is a more primitive declaration, you can think of it
11:24:41 <glguy> oh, he did
11:24:54 <glguy> and I thought Cale was just spouting possible answers
11:24:56 <Cale> What this means is that compilers are free to implement newtypes at runtime by the original types
11:24:56 <emu> Uccus: it only allows 1 constructor, and that 1 constructor can only have 1 parameter
11:25:03 <liyang> newtype literally just gives a different name to an existing type.
11:25:04 <Uccus> well I thought it word be much subtle a difference
11:25:12 <Uccus> so GHC likes newtypes, right?
11:25:18 <Uccus> why, may I ask?
11:25:27 <emu> less boxing?
11:25:38 <Uccus> just one leve!
11:25:39 <Cale> It's one less pointer to dereference.
11:25:43 <Uccus> level I mean
11:25:51 <Uccus> yes :) obviously
11:25:56 <glguy> the newtype "compiles away"
11:25:58 <Uccus> but that's it!
11:26:01 <Cale> right
11:26:10 <Cale> the semantics are slightly different
11:26:10 <emu> hmm, is data Foo = Foo !Bar similar to the newtype, then?
11:26:21 <allbery_b> similar but not identical
11:26:23 <Uccus> should be
11:26:34 <emu> other than the whole unboxing thing
11:26:36 <sjanssen> emu: same semantics, different runtime representation
11:26:44 <Uccus> really?
11:27:00 <emu> sjanssen: blah, didn't you have me replace a newtype with a data ! one time
11:27:15 <sjanssen> pretty sure the semantics are the same, perhaps somebody else could chip in
11:27:16 <Cale> er, are you sure?
11:27:19 <Uccus> I thought just constructing (Foo undefined) would
11:27:32 <monochrom> Don't you love it?  It's both mathematically simpler and computationally faster!
11:27:48 <Cale> d (D k) = k
11:27:51 <Cale> n (N k) = k
11:28:00 <Cale> then with data D = D !Integer
11:28:06 <Uccus> yeah
11:28:16 <Cale> er
11:28:21 <Cale> no, that's not what I want :)
11:28:30 <Cale> d (D k) = 42
11:28:31 <emu> > let data Foo = Foo Int in Foo 1
11:28:31 <Uccus> it should "evaluate" undefined the moment it's defined
11:28:32 <lambdabot>  Parse error
11:28:33 <Cale> n (N k) = 42
11:28:48 <Cale> then d (D undefined) = undefined
11:28:56 <allbery_b> you can't do data/type/newtype in lambdabot
11:28:56 <Cale> but n (N undefined) = 42
11:29:02 <sjanssen> ah yes, they're very slightly different
11:29:06 <Cale> So it's not quite the same
11:29:20 <Cale> because pattern matching is different
11:29:29 <Cale> newtypes are never pattern matched
11:29:43 <Cale> (it's purely a compile-time construction)
11:30:00 <Uccus> I get it (I think)
11:30:26 <Uccus> any example where you *want* newtype semantics?
11:30:31 <Cale> performance
11:30:40 <Uccus> I understand that
11:30:46 <monochrom> alternative class instances
11:30:52 <Uccus> but apart from performance, is there any
11:30:57 <Uccus> monochrom: what?
11:31:01 <emu> strictness, though you can achieve that with data
11:31:12 <Cale> also, newtypes in GHC and hugs have a nice feature that you can derive any class through them
11:31:12 <Uccus> yes I suppose
11:31:23 <Cale> (any class implemented on the base type)
11:31:29 <Uccus> can't I do that with data?
11:31:32 <Cale> no
11:31:36 <emu> too general
11:31:38 <Cale> So for instance
11:31:47 <emu> deriving MyFooClass too
11:32:07 <Uccus> oh I get it
11:32:07 <Cale> newtype MyMonad a = StateT MyState [] a deriving (Functor, Monad)
11:32:14 <EvilRanter> so... {newtype N a = N a} is similar under-the-hood to {type T a = a}, except (N a) is not equivalent to a and (T a) is?
11:32:34 <emu> that doesn't look right
11:32:35 <Cale> EvilRanter: yes
11:32:35 <Uccus> but doesn't deriving mean automatically adding appropriate functions?
11:32:53 <Cale> Uccus: not in this case
11:33:18 <Cale> In this case, because the values are represented identically at runtime, it just means allowing the use of the old functions.
11:33:49 <Uccus> okay ...
11:34:10 <Cale> Or even if there was a slight change, the new functions would be a very mechanical step away.
11:34:14 <Uccus> hmm... well, where's the documentation for all this?
11:34:16 <lispy> when i've used the technique Cale is describing i usually don't expose those old functions from the module, but instead come up with more descriptive names (for my purpose) and expose those
11:34:31 <Cale> Uccus: http://haskell.org/onlinereport/decls.html#sect4.2.3
11:34:32 <lambdabot> Title: The Haskell 98 Report: Declarations
11:34:55 <Cale> lispy: well, some of them you might want to derive -- usually the Functor and Monad instances
11:35:09 <lispy> yeah, i do do the deriving
11:35:23 <paolino> mmhh, how can I read the "output" from inside the Writer monad ?
11:35:32 <Uccus> another question if you guys don't mind
11:35:49 <Cale> :t listen
11:35:49 <Uccus> what does the word 'lifting' mean in general?
11:35:50 <lambdabot> Not in scope: `listen'
11:35:56 <SamB> you can do that?
11:36:00 <Cale> :t Control.Monad.Writer.listen
11:36:01 <lambdabot> forall (m :: * -> *) w a. (Control.Monad.Writer.MonadWriter w m) => m a -> m (a, w)
11:36:15 <paolino> Cale , listen want a Writer as argment
11:36:18 <Cale> Uccus: in total generality, almost nothing :)
11:36:22 <Cale> paolino: yes it does
11:36:30 <lispy> Uccus: it's when you bring something (like a function) up into another structure
11:36:50 <monochrom> give it "return ()"
11:36:51 <Cale> passing from less structure to more structure
11:37:05 <Cale> monochrom: that will give boring results :)
11:37:07 <paolino> ah
11:37:12 <Uccus> more like "wrap a structure around it"?
11:37:16 <lispy> :t liftM2 (+)
11:37:18 <lambdabot> forall a2 (m :: * -> *). (Monad m, Num a2) => m a2 -> m a2 -> m a2
11:37:18 <Cale> Uccus: sure
11:37:24 <Cale> :t lift
11:37:26 <lambdabot> forall (t :: (* -> *) -> * -> *) a (m :: * -> *). (MonadTrans t, Monad m) => m a -> t m a
11:37:43 <monochrom> Hmm can I listen to myself? XD
11:37:51 <Uccus> what lamdabot just said about liftM2 (+)
11:37:51 <Cale> paolino: you can't have access to the log for the currently executing Writer
11:37:59 <Cale> paolino: if you need that, use a State monad
11:38:06 <monochrom> Darn, I can't listen to myself.
11:38:10 <glguy> paolino: that's what makes a writer a writer :)
11:38:18 <monochrom> I can talk to myself but I can't hear it!!
11:38:36 <lispy> > let foo = liftM2 (+) in (Just 1) `foo` (Just 2)
11:38:38 <lambdabot>  Just 3
11:38:41 <Uccus> monochrom: because you are typing... you could if you were shouting :)
11:38:43 <lispy> Uccus: does that help?
11:38:52 <lispy> Uccus: i lifted (+) into the Maybe monad
11:38:54 <monochrom> No, I'm using the Writer monad.
11:39:09 <Uccus> let me think!
11:39:13 <Cale> Uccus: It said that for every numeric type a2 and every monad m, it has type m a2 -> m a2 -> m a2
11:39:39 <Cale> that is, it takes two computations computing values of type a2 and produces a computation computing a value of type a2
11:40:04 <Uccus> :t lift
11:40:06 <lambdabot> forall (t :: (* -> *) -> * -> *) a (m :: * -> *). (MonadTrans t, Monad m) => m a -> t m a
11:40:18 <glguy> lift has to do with monad transformers
11:40:25 <Uccus> okay okay I don't want lift
11:40:29 <Uccus> :t lift2
11:40:30 <lambdabot> Not in scope: `lift2'
11:40:37 <lispy> the biggest problem with the generic liftM* functions is that they try to run their monadic parameters before computing the lifted function
11:40:37 <Cale> that takes a computation and lifts it to work in a transformed version of the monad it was in
11:40:42 <Uccus> :t Control.Monad.lift2
11:40:44 <lambdabot> Not in scope: `Control.Monad.lift2'
11:40:53 <Uccus> damnit...
11:40:59 <Cale> lispy: isn't that sort of unavoidable?
11:41:01 <glguy> lispy: what do you mean "biggest problem"
11:41:03 <lispy> > (liftM2 and) (Just False) (Just undefined)
11:41:04 <lambdabot>    Expecting a function type, but found `Bool'
11:41:04 <lambdabot>    Expected type: [Bool] ...
11:41:05 <Cale> lispy: it can still be lazy
11:41:11 <SamB> lispy: you were hoping for *afterwards*?
11:41:15 <lispy> > (liftM2 (&&)) (Just False) (Just undefined)
11:41:17 <lambdabot>  Just False
11:41:23 <lispy> wait a sec
11:41:34 <Cale> hehe
11:41:35 <edi> :O
11:41:42 <edi> it short-cuts
11:41:56 <Uccus> wait
11:42:06 <allbery_b> hm?
11:42:06 <glguy> > liftM2 (&&) (Just False) undefined -- is this what doesn't work for you lispy?
11:42:07 <Cale> just because you have something like  x <- return y, doesn't mean y is evaluated
11:42:08 <Uccus> if that monad was IO instead of Maybe
11:42:08 <lambdabot>  Undefined
11:42:14 <SamB> > liftM2 (&&) (Just False) Nothing
11:42:16 <lambdabot>  Nothing
11:42:16 <monochrom> You probably want (liftM2 (&&)) (Just undefined) (Just False)
11:42:21 <lispy> glguy: yeah i think so
11:42:30 <glguy> lispy: that shouldn't work though
11:42:33 <SamB> monochrom: :-P
11:42:49 <lispy> the point is, it's less lazy than (&&)
11:42:57 <Uccus> > liftM2 (&&) (Just False) undefined
11:42:58 <lambdabot>  Undefined
11:43:00 <Cale> > do {x <- return False; y <- return undefined; return (x && y)}
11:43:01 <lambdabot>  add an instance declaration for (Show (m Bool))
11:43:06 <lispy> so if you want to lift (&&) you have to code it to be short-circuit
11:43:07 <Cale> > do {x <- return False; y <- return undefined; return (x && y)} :: Maybe Bool
11:43:09 <lambdabot>  Just False
11:43:24 <glguy> lispy: but that breaks the point of hte Maybe monad
11:43:36 <emu> this DpH report is very cool; but the authors really need to run a spellchecker before submitting papers
11:43:49 <Cale> > do {x <- Nothing; y <- return undefined; return (x && y)} :: Maybe Bool
11:43:50 <lambdabot>  Nothing
11:43:59 <monochrom> It works for a higher structure, and then it is less lazy.  I wonder if there is anything wrong with that.
11:44:02 <Cale> Looks like it short-circuits to me
11:44:10 <glguy> lispy: because you have to make sure that the second argument isn't Nothing
11:44:14 <Cale> both the computations have to be defined, but their results don't
11:44:30 <Uccus> guys :$
11:44:42 <Uccus> if the monad was IO instead of Maybe
11:44:53 <Uccus> would it evaluate undefined?
11:44:55 <Cale> no
11:45:08 <Cale> there's no reason to do so here
11:45:14 <Uccus> so all monads have the same behavior
11:45:17 <Cale> unless you did something like print it
11:45:20 <Cale> I wouldn't say that
11:45:33 <Uccus> well, I *was* thinking of printing it
11:45:34 <Cale> you can easily make a monad where return is strict
11:45:40 <monochrom> It may be provable from the monad laws.
11:45:56 <allbery_b> uccus: sort of.  the notion of monad encodes certain consistent behaviors
11:45:58 <Cale> http://cale.yi.org/autoshare/evalexec.png -- btw, I made a picture of how I think of the IO monad working.
11:46:21 <monochrom> A formula is worth a thosand pictures. :)
11:46:22 <allbery_b> but there's still quite a lot of room for variation
11:46:43 <lispy> http://darcs.net/pipermail/darcs-devel/2006-January/003913.html
11:46:45 <lambdabot> Title: [darcs-devel] Repository.lhs vs. DarcsRepo.lhs
11:46:46 <glguy> > flip Control.Monad.Cont.runCont id . Control.Monad.Cont.callCC $ \out -> liftM2 (&&) (out 4) (undefined) >> undefined
11:46:48 <lambdabot>  4
11:46:56 <Uccus> I follow the upper bit but not the lower bit
11:47:00 <glguy> lispy: in this case, liftM2 ignores the second argument :)
11:47:03 <Cale> haha
11:47:08 <Cale> that's an awesome example
11:47:15 <glguy> a high five!
11:47:32 <glguy> (for those that saw Borat)
11:47:48 <monochrom> The picture is a bit hard to follow.  I have to use my existing knowledge of monads to understand it.
11:48:09 <Cale> glguy: jagshemash
11:48:14 <psi> i liked the church bit in borat - he seemed quite normal in comparison
11:48:15 <monochrom> In fact I used the formulas.
11:48:47 <Cale> monochrom: well, it would be best accompanied with some text
11:49:04 <Cale> the idea is that values of type (IO t) are actually program scripts
11:49:07 <Uccus> at least an indication what ret w is supposed to mean
11:49:10 <glguy> ?let evalCont =  flip Control.Monad.Cont.runCont id
11:49:11 <lambdabot> Defined.
11:49:11 <lispy> glguy: actually it's mand that ignores the second argument if it can, so i'm not sure what you mean
11:49:28 <Cale> and not crazy functions from RealWorld to (RealWorld, value) pairs
11:49:37 <glguy> ?let callCC  =  Control.Monad.Cont.callCC
11:49:38 <lambdabot> <local>:7:11:     Ambiguous type variable `m' in the constraint:       `Monad...
11:50:11 <Uccus> what just happened to glguy's declaration?
11:50:26 <glguy> blew up
11:50:30 <monochrom> I treat IO t as formula scripts too.
11:50:36 <glguy> :t Control.Monad.Cont.callCC
11:50:37 <lambdabot> forall (m :: * -> *) a b. (Control.Monad.Cont.MonadCont m) => ((a -> m b) -> m a) -> m a
11:50:40 <Cale> In some sense, that diagram works for any monad, except in most cases, execution is carried out as evaluation
11:50:49 <Cale> But in the case of IO, it is not.
11:51:20 <Uccus> erm.. didn't understand what you said, Cale
11:51:30 <Cale> did you see my diagram?
11:51:52 <Uccus> I thought the IO type expresses execution _as_ evaluation
11:51:56 <glguy> > L.runCallCC $ \out -> liftM2 (&&) (out 4) (undefined) >> undefined -- more managable
11:51:58 <lambdabot>  4
11:51:59 <Cale> no
11:52:07 <Uccus> no?
11:52:14 <Cale> evaluating an expression of type (IO t) has no side effects
11:52:14 <monochrom> why do I have to have seen Borat to high five?
11:52:41 <glguy> monochrom: he says "a high five!" in a certain way, its more fun that just saying it seriously
11:52:50 <Uccus> can you explain please?
11:52:51 <Cale> a function of type  (a -> IO b)  is still pure, and always gives the same IO computation for the same input value
11:53:08 <Cale> and values of type  (IO a)  are like inert constants
11:53:16 <Cale> evaluating them does essentially nothing
11:53:31 <Uccus> yes, that bit I understand
11:53:55 <Cale> Only on execution do side effects actually happen, but there's no way to cause that execution to occur in the course of evaluation (slight lie)
11:54:03 <Angel_Monadico> Hail Cale
11:54:08 <Uccus> but something >>= somethingelse... does a sequential job, right?
11:54:23 <Cale> (there are hooks into the RTS which let you do that, but they're not properly part of Haskell)
11:54:35 <EvilRanter> unsafePerformIO etc?
11:54:46 <glguy> lispy: my point was that it's only as strict as it needed to be. in maybe, the value of the second argument was the difference between Just False and Nothing, in Cont, the value of the second argument didn't matter
11:54:47 <Uccus> well I don't think I want know about unsafePerfomIO
11:54:49 <EvilRanter> (is it called that?)
11:55:07 <Cale> (x >>= f) evaluates to the computation which if executed will execute x, take its result, pass it to f to get a new computation, which it then executes
11:55:11 <Cale> returning the result of that
11:55:27 <Saizan> isn't IO like a State monad where only the haskell runtime can do the runState equivalent?
11:55:28 <Uccus> yes that made perfect sense
11:55:37 <Cale> the key point here is "if executed"
11:55:40 <glguy> it doesn't so much run the second action though
11:55:46 <Uccus> yeah I get that part too
11:55:46 <Cale> the evaluation doesn't cause that execution to occur
11:55:46 <glguy> it returns a new action that hasn't been run
11:55:50 <Uccus> glguy's example
11:55:58 <SamB_XP_> Saizan: and people who like to live dangerously and/or prove things
11:56:07 <Cale> Saizan: sort of, except there's no appropriate type for the State
11:56:25 <glguy> Uccus: what about my example?
11:56:27 <SamB_XP> oh, wait, no, thats ST!
11:56:30 * SamB_XP sorry
11:56:44 <Cale> So it's better to just think of values of type (IO a) as program scripts which describe their side effects, return value, etc.
11:56:51 <Uccus> your example had a >>= that didn't execute
11:57:06 <Cale> Angel_Monadico: hello :)
11:57:15 <glguy> >>= doesn't execute anything, it sequences things to be executed
11:57:28 <Uccus> erm... yeah. that's what I meant
11:57:29 <glguy> in my example, runCont executed things
11:57:44 <Angel_Monadico> hello my friend! I read "all about tutorial", very good tutorial
11:57:52 <Cale> Angel_Monadico: cool :)
11:57:52 <Angel_Monadico> ooj all about monad
11:58:02 <glguy> but since I called the current continuation, the things to be executed were ignored
11:58:39 <Angel_Monadico> I uses transform state  monad
11:58:59 <glguy> > L.runCallCC $ \out -> liftM2 (&&) (return False) (out 4) >> undefined -- more managable
11:59:01 <lambdabot>  4
11:59:07 <glguy> lispy: is that what you wanted to see instead?
11:59:11 <Angel_Monadico> now I have issues IO for calc jejejeje
11:59:34 <Angel_Monadico> are you use gtk2hs???
11:59:35 <glguy> lispy: since && knew it wouldn't return True after the first argument
11:59:43 <benomatic> newbie question: what's the trick to decoding haskell's error messages?  the Hugs common error message page seems to help about 50% of the time, and the rest of the time i do the headless chicken dance...  any suggestions on resources?
11:59:58 <Uccus> glguy, can you stick with me for a moment and help me understand what happens in your example?
12:00:01 <glguy> benomatic: typically the trick is to use GHC's error messages :)
12:00:23 <Cale> benomatic: you just learn what all the words mean :)
12:00:25 <glguy> Uccus: I'll be here, feel free to ask whatever
12:00:36 <Cale> benomatic: but yeah, GHC's error messages are usually nicer
12:00:55 <benomatic> heh.  ghci wasn't much better unfortunately, but that may be more due to me learning the lang in the last 24hrs
12:00:58 <Cale> benomatic: alternately, you ignore the words, and pay attention to the line number and then stare at your code :)
12:00:59 <Uccus> liftM2 says, give me a function and I will lift it
12:01:14 <benomatic> Cale: the code staring thing == the headless chicken thing
12:01:22 <Cale> benomatic: yeah
12:01:40 <glguy> > L.runCallCC $ \out -> liftM2 undefined (return undefined) (out 4) >> undefined -- how does this even typecheck ;)
12:01:41 <Cale> benomatic: but then once you figure it out, you get a better idea of what the words it gave you originally meant
12:01:42 <lambdabot>  4
12:01:56 <glguy> Uccus: right, and I'm lifting things into the Cont monad
12:01:58 <Uccus> the function passed is (&&), so liftM2 (&&), in my understanding, expects two more argument
12:02:04 <Cale> benomatic: on the other hand, you can use lisppaste to paste your code and error and we'll help sort it out
12:02:06 <glguy> right
12:02:09 <Cale> lisppaste2: url
12:02:10 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
12:02:23 <benomatic> Cale: i figured to do that eventually, but wanted to check for general resources first :-)
12:02:30 <Uccus> the first argument is understandable, it's Cont.return, right?
12:02:33 <glguy> Uccus: do you understand the do-notation representation of liftM2?
12:02:40 <glguy> Uccus: yeah
12:02:42 <Cale> benomatic: we usually don't mind :)
12:03:01 <Uccus> then comes the bit I don't understand, (out 4)
12:03:20 <glguy> Uccus: do you understand calling with the current continutation?
12:03:23 <Uccus> what's its type?
12:03:26 <Uccus> yes I do
12:03:30 <Cale> out is a function handed to you by callCC, which represents the part of the computation after the callCC finishes
12:03:42 <glguy> ?type Control.Monad.Cont.callCC
12:03:43 <lambdabot> forall (m :: * -> *) a b. (Control.Monad.Cont.MonadCont m) => ((a -> m b) -> m a) -> m a
12:03:45 <Uccus> but what's its type?
12:03:51 <glguy> (a -> m b)
12:04:05 <Uccus> out :: a -> Cont b ?
12:04:19 <glguy> in this case, a was Integer
12:04:47 <glguy> I never did understand how the second type worked, in fact i think this is the one where people say it's "wrong"
12:05:01 * glguy tags Cale
12:05:24 <Cale> the second type?
12:05:29 <glguy> m b
12:05:36 <Uccus> m is the monad
12:05:41 <Cale> oh, the b is just there because it's not using the result
12:05:47 <Cale> it's fully polymorphic
12:06:05 <glguy> oh, ok
12:06:08 <glguy> ?type flip Control.Monad.Cont.runCont id . Control.Monad.Cont.callCC
12:06:09 <lambdabot> forall a b. ((a -> Control.Monad.Cont.Cont a b) -> Control.Monad.Cont.Cont a a) -> a
12:06:23 <glguy> (a -> Control.Monad.Cont.Cont a b) -- current continuation
12:06:47 <glguy> Cont a b -- b is the return type, a is the early exit type
12:07:03 <Uccus> so what's b here?
12:07:11 <glguy> unused
12:07:18 <Uccus> unconstrained?
12:07:27 <glguy> yeah, that's why I end with >> undefined
12:07:41 <glguy> so that b can match a
12:07:52 <Uccus> the >> undefined part was what made absolutely no sense to me
12:08:04 <lisppaste2> benomatic pasted "mmm error codes" at http://paste.lisp.org/display/33293
12:08:12 <glguy> the return value needs to match the exit value at the end of the computation
12:08:16 <glguy> errrr
12:08:17 <glguy> TYPE
12:08:24 <Uccus> yeah I get it
12:08:37 <Uccus> so if you don't pipe it to undefined it doesn't typecheck?
12:08:52 <benomatic> ok, code + errors in that lovely link.  Any takers on fixing something that's probably obvious? :-)
12:08:53 <glguy> yeah, the other solution is to add a >> return 5 , for exmaple
12:09:03 <glguy> so that the types match
12:09:21 <Uccus> anything of type Cont Int?
12:09:29 <glguy> Cont Int Int
12:09:42 <Uccus> oh the return type again
12:10:11 <Uccus> okay, Cont Int Int. but it can be anything, anything at all because (out 4) ends the control flow?
12:10:16 <glguy> you have to ensure that regardless of whether the computation ends with early exit, or completion, the return type is the same
12:10:21 <glguy> Uccus: right
12:10:41 <Uccus> thanks, glguy, Cale
12:11:05 <Uccus> man, all the monad tutes combined is not enough to cover this
12:11:09 <Korollary> @karma++ glguy Cale
12:11:10 <lambdabot> glguy's karma raised to 13.
12:11:12 <Iulus> benomatic: try putting the (x2:xs) in paretheses
12:11:27 <glguy> heh
12:11:31 <Iulus> compress x2:xs => compress  (x2:xs)
12:11:50 <glguy> thnx Korollary (=
12:11:54 <benomatic> no dice :(
12:12:05 <Iulus> different error?
12:12:17 <allbery_b> hm, does that also need 'Eq a =>' in the signature?
12:12:31 <benomatic> similar:
12:12:40 <benomatic>     Couldn't match expected type `[a]'
12:12:40 <benomatic>            against inferred type `a1' (a rigid variable)
12:12:40 <benomatic>       `a1' is bound by the type signature for `compress' at l.hs:51:13
12:12:40 <benomatic>     In the first argument of `compress', namely `x2'
12:12:40 <benomatic>     In the first argument of `(:)', namely `compress x2'
12:12:42 <benomatic>     In the second argument of `(:)', namely `((compress x2) : xs)'
12:12:56 <glguy> Uccus: yw
12:13:18 <benomatic> what's too many lines here?  i don't know irc etiquette particularly well...
12:13:30 <glguy> 4 is about the limit
12:13:36 <benomatic> check
12:13:38 <Iulus> benomatic: you need to surround the x2:xs with parentheses in the 'otherwise' line, too.
12:13:48 <Uccus> you need the bracket around (x2:xs) for sure
12:13:50 <Uccus> heh
12:14:03 <Iulus> compress :: (Eq a) => [a] -> [a]
12:14:03 <Iulus> compress (x1:x2:xs)
12:14:03 <Iulus>          | x1 == x2 = compress (x2:xs)
12:14:03 <Iulus>          | otherwise = x1 : (compress (x2:xs))
12:14:03 <Iulus> compress l = l
12:14:19 <benomatic> kewl
12:14:48 <benomatic> thanks!
12:14:56 <Iulus> in the lats line of your error message, it gives you the clue
12:14:56 <Uccus> benomatic: the problem is that function application has a higher precedence over (:)
12:15:02 <benomatic> i see this
12:15:11 <Uccus> benomatic: did you get what I said?
12:15:16 <glguy> otherwise = x1 : compress (x2:xs) -- if you don't like ()s
12:15:18 <benomatic> i was literally about to note that : seems like a high precendent operator (intuitively) but must not be
12:15:35 <benomatic> Uccus: yeah, i got it
12:15:37 <Uccus> :) @glguy... that's what I wanted to point out next
12:16:23 <Uccus> well function application has an unusually high precendence in Haskell
12:16:39 <Uccus> try the factorial definition
12:16:46 <_alex_br_> which can be lowered
12:16:51 <_alex_br_> :t ($)
12:16:52 <lambdabot> forall b a. (a -> b) -> a -> b
12:17:25 <Uccus> n * factorial n - 1 does _not_ mean n * factorial (n - 1)
12:17:57 <benomatic> higher function precedence is going to take my eyes some time to see
12:18:05 <Uccus> thanks alex_br for the pointer
12:18:33 <Iulus> benomatic: but once your eyes get used to it, it hurts your eyes to see anything else
12:18:48 <Uccus> benomatic: you can use the $ operator to separate parameters
12:18:49 <Iulus> I was thinking about syntax for a language I'm going to write for class
12:19:02 <Iulus> and print( f( 4 ) ) just looks bad to me now
12:19:30 <Iulus> print $ f 4 -- so clean!
12:19:40 <benomatic> as long as it doesn't resemble perl i can handle it
12:19:51 <benomatic> well, resemble "bad" perl anywaiz
12:19:56 <Uccus> I... erm... never liked the look of the $ operator
12:20:05 <Cale> The only problem with the $ operator is that they got the precedence the wrong way
12:20:06 <Uccus> but it's so handy that I guess...
12:20:07 <Iulus> oddly enough, perl got me hookedon higher order stuff
12:20:19 <Cale> er
12:20:19 <allbery_b> you might want to look at some J code before committing to that :)
12:20:25 <Cale> the associativity
12:20:36 <glguy> > let comp = foldr f [] where f x [] = [x]; f x (y:ys) | x == y = y:ys | otherwise = x:y:ys in comp [1,1,1,2,2,2,3,3,3]
12:20:38 <lambdabot>  [1,2,3]
12:20:40 <Uccus> Cale: can you explain?
12:20:58 <Cale> f $ g $ h $ x means f (g (h x)) which is the same as f . g . h $ x
12:21:35 <allbery_b> huh.  here I thought I was the onlyone who was tinking that it'd be nice of $ associated the other way
12:21:37 <Cale> but if they'd make it left associative, like I think they should have, it would mean f g h x, which is something different.
12:21:59 <lisppaste2> glguy pasted "compress', because I hate explicit recursion" at http://paste.lisp.org/display/33297
12:22:02 <opqdonut> it's kinda intuitive that it associates as it does
12:22:06 <Cale> (which would save brackets in cases where g,h and x are long parameters to f
12:22:07 <Cale> )
12:22:22 <opqdonut> true, true
12:22:23 <Cale> actually, I think it's unintuitive that it does
12:22:37 <Cale> because application is normally left associative
12:22:38 <emu> i usually use f . g . h $ x instead of multiple $
12:22:45 <Cale> emu: good :)
12:22:47 <Uccus> I am new enough to grow any intuition on this
12:22:51 <_alex_br_> emu, me too
12:23:19 <emu> though sometimes it's f . g $ h x
12:23:22 <opqdonut> Cale: good point
12:23:22 <allbery_b> every so often I contemplate defining an infixl 9 $, or something for my own use
12:23:24 <Cale> I highly recommend using the f . g . h $ x form, because there might be a push to get the associativity of $ changed at some point :)
12:23:31 <opqdonut> :D
12:23:39 <glguy> Cale: who would do that??
12:23:41 <Cale> (or regardless, some form which uses only one $)
12:23:54 <Cale> glguy: do what?
12:23:59 <glguy> push for that ;)
12:24:02 <Cale> I would
12:24:05 <Uccus> but what's wrong wth parentheses anyway?
12:24:07 <glguy> i know!
12:24:15 <Uccus> it's not like it's as bad as lisp!
12:24:15 <glguy> shesh, there's no kidding with you
12:24:17 <allbery_b> ugly clutter
12:24:30 <_alex_br_> Uccus, try calling a function on an action :-)
12:24:31 <Cale> Uccus: sometimes it still can be, and $ helps there
12:24:33 <_alex_br_> a large one
12:24:33 <glguy> (.) doesn't play nice with `f` but ($) does..
12:24:35 <emu> mostly because you'd have to rewrite a nice composition as: (f . g . h) x
12:25:05 <Cale> glguy: that's true, but I've never had a problem with it myself, and would be solved by having more precedence levels.
12:25:39 <emu> actually, i prefer the parentheses of Lisp, because if you are smart you can use very clever editor commands for working with them
12:25:41 <Cale> (or better yet, a different way of assigning precedence altogether)
12:25:51 <Uccus> precendence should, *ahem*, not be defined by numbers (let alone 1 to 10), but should have a partial ordering
12:26:04 <Cale> indeed
12:26:05 <Iulus> that was debated on the mailing list recently
12:26:16 <emu> i often miss being able to transpose expressions neatly, and to lift and lower expressions
12:26:25 <Cale> everyone wants that, but someone has to actually do it
12:26:32 <Uccus> someone mentioned a crucial issue on the list
12:26:36 <Cale> oh?
12:26:44 <Uccus> haddock doesn't give you precendence info
12:26:49 <opqdonut> true
12:27:08 <glguy> == looks like a 4 to me
12:27:10 <Cale> haddock can be fixed :)
12:27:14 <glguy> I go on feelings
12:27:16 <opqdonut> :D
12:27:23 <emu> all this precedence crap just makes me wonder whether it is worth it for a "natural" syntax
12:27:25 <Uccus> emu: I prefer parens too
12:27:34 <Cale> emu: I'd say yes :)
12:27:39 <glguy> I like being able to type: 1 + 2 * 3
12:27:45 <SamB_XP> hmm. partial orders mean you'd need to have both names around to say which of the two was higher in precedence!
12:27:50 <Uccus> haha
12:28:00 <Uccus> yeah precendence is natural
12:28:11 <glguy> without precedence we are no better than J
12:28:13 <Cale> I like do be able to say  withFoo $ \e -> do ...
12:28:20 <Uccus> but not for _every_ operator
12:28:29 <emu> Cale: speaking of which, i swear, there is a bug in GHC related to that
12:28:38 <emu> runSTArray $ do ...
12:28:42 <Cale> not a bug
12:28:48 <glguy> emu: that's because of the existential type
12:28:58 <Cale> that won't typecheck because the type of $ isn't sufficiently general
12:29:06 <emu> erp
12:29:09 <Korollary> it's a tradeoff involving the number of symbols and length of expressions. If you have very many symbols, people will hate precedence. If you have long expressions, people will hate the parens overhead.
12:29:11 <Cale> (and I don't think the type system allows for a general enough type)
12:29:18 * SamB_XP thinks it ought to be
12:29:43 <SamB_XP> Cale: yeah, thats the problem all right.
12:29:45 <emu> yea, precedence works great with basic arithmetic, but introduce 20 new operators, and suddenly its a mess
12:29:48 <SamB_XP> if it did, I think $ would have it!
12:30:03 <Uccus> haha @SamB_XP
12:30:12 <Cale> Well, possibly not -- lots of things in the Prelude have less general types than they should.
12:30:18 <Uccus> but I do realize the importance
12:30:31 <SamB_XP> Cale: but $ has the most general type it can, does it not?
12:30:36 <emu> @type ($)
12:30:38 <lambdabot> forall b a. (a -> b) -> a -> b
12:30:38 <Uccus> of $, like when applying a constructor
12:31:01 <Cale> In our existing system, yes.
12:31:05 <Uccus> may be he meant it's not general enough to handle monads?
12:31:08 <Cale> no
12:31:17 <emu> just the ST existential type var
12:31:19 <Cale> it's not general enough to handle higher-rank types
12:31:37 <glguy> rank-2 to represent rank-n, right?
12:31:42 <glguy> s/to/can
12:31:51 <Uccus> Cale, emu: can you explain a bit?
12:31:55 <Uccus> where does it fail?
12:32:00 <emu> i wish i could, i'm learning as we speak
12:32:00 <Iulus> maybe an example?
12:32:06 <Cale> @t Control.Monad.ST.runST
12:32:07 <lambdabot> Maybe you meant: tell time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
12:32:10 <Cale> :t Control.Monad.ST.runST
12:32:11 <lambdabot> forall a. (forall s. GHC.ST.ST s a) -> a
12:32:13 <glguy> runSTArray $ thaw (listArray (0,0) 0)
12:32:20 <Cale> runST is simpler
12:32:30 <Uccus> ok
12:32:32 <Uccus> I'm with you
12:32:49 <yip> what do you guys do when you are forced to code in c#?
12:32:58 <glguy> use VS2005
12:33:05 <LoganCapaldo> what's wrong with b = <that mess right there> ?
12:33:10 <Uccus> so runST has a forall s inside the forall a
12:33:12 * emu has avoided C# so far
12:33:16 <Cale> So let's look at  runST $ return ()
12:33:25 <yaxu> yip: force how?
12:33:35 <Uccus> yaxu: job?
12:33:36 <Cale> ($) :: (a -> b) -> a -> b
12:33:42 <yip> yaxu: like, "force of nature"
12:33:46 <glguy> if I had to program in an imperative language at work, which I do, I'd want it to be C#, and it is!
12:34:11 <Uccus> glguy: C# is nice enough for all practical purposes
12:34:16 <emu> C# seems to be getting strongly influenced by FPers lately
12:34:16 <yaxu> i'd get another job
12:34:21 <opqdonut> :D
12:34:22 <glguy> emu: yup, it's great
12:34:27 <glguy> emu: I'm looking forward to 3.0
12:34:33 <yip> i just wish it had algebraic data types
12:34:34 * Shimei is "forced" to code in C most of the time
12:34:35 <emu> can you use perhaps F# in place of it?
12:34:41 <Uccus> erm... I'm not, actually
12:34:50 <LoganCapaldo> glguy: if you could pick *any* imperative language in the world, you'd still pick C#?
12:34:52 <emu> what with the vaunted "CLR"
12:35:06 <Uccus> yeah, F# is great (if you are okay to let go of the IDE support)
12:35:28 <mattam> Cale: finished already ?
12:35:29 <glguy> LoganCapaldo: yeah, probably
12:35:32 <Cale> If I was going to be forced to use any imperative language I wanted, I'd get to work on a new imperative language :)
12:35:42 <mattam> :t runST $ return ()
12:35:42 <Cale> mattam: sorry, discussion took a turn there :)
12:35:43 <LoganCapaldo> k, was just curious
12:35:43 <lambdabot> Not in scope: `runST'
12:35:56 <Cale> :t Control.Monad.ST.runST $ return ()
12:35:57 <lambdabot>   Inferred type is less polymorphic than expected
12:35:58 <lambdabot>    Quantified type variable `s' escapes
12:35:59 <Uccus> sorry Cale
12:36:06 <emu> when we gonna see officially supported haskell compiler for .net? =)
12:36:08 * allbery_b has been starting to migrate from perl to ruby at work
12:36:18 <emu> isn't ghc kinda sorta being supported by MS Research as it is
12:36:20 * glguy died
12:36:21 <jbalint> "officialy"?
12:36:25 * allbery_b 's coworkers probably hate him :)
12:36:57 * wolverian uses perl6 for what he can nowadays 
12:37:03 <benomatic> glguy: tnx for compress', but i'm not up to foldr in my tutorials yet ;-)
12:37:03 <glguy> allbery_b: because you are changing your brand of poison?
12:37:10 <Uccus> what does it _mean_? `s' escapes?
12:37:12 <emu> not that it matters to me, i don't think i've done much serious work on Windows
12:37:17 <allbery_b> to somehting not well known by the rest of the group, yes
12:37:18 <Cale> :t ($) Control.Monad.ST.runST
12:37:19 <lambdabot>   Inferred type is less polymorphic than expected
12:37:19 <lambdabot>    Quantified type variable `s' escapes
12:37:42 <glguy> ruby makes my eyes tear up
12:37:53 <mattam> :t ($)
12:37:53 <Cale> Uccus: s is only in scope in the parameter to runST (the computation to run)
12:37:54 <lambdabot> forall b a. (a -> b) -> a -> b
12:37:54 <allbery_b> what, compared to perl?
12:38:04 <Cale> but it ends up being used in another scope
12:38:07 <glguy> allbery_b: as a programming language :)
12:38:20 <Cale> (when you try to unify)
12:38:32 <pejo> emu, the Simons are researchers, and that's their jobs.
12:38:55 <Uccus> I still don't get it
12:38:56 <mattam> you can't find a more generalized ($) though
12:38:57 <emu> pejo: sure, but is ghc "on the job" or "on the side"?
12:38:59 <pejo> emu, and I doubt any company would count it as support, since there is no contract.
12:39:02 <Cale> because you're trying to match (a -> b) against (forall s. ST s a -> a)
12:39:07 <glguy> allbery_b: we don't have to debate it, especially here, but if you get to announce you are using it, I get to cry ;)
12:39:13 <Uccus> mattam: that's what I gathered so far as well
12:39:33 <sorear> you can define a more general ($), but the compiler won't generalize ($) for you
12:39:36 <Cale> and it won't allow that, because if you naively allow things like that, you end up with problems
12:39:38 <Uccus> it should not match
12:39:48 <Cale> (there might be a way to do it, but it's not simple)
12:40:06 <SamB_XP> emu: I'm sure MS knows that GHC is very important to them...
12:40:21 <mattam> how would you expect (a -> b) to match (forall x, (a -> b)) ?
12:40:39 <sorear> ?let ($$) :: (forall s. Control.Monad.ST.ST s a -> a) -> forall s. Control.Monad.ST.ST s a -> a ; a $$ b = a b
12:40:40 <lambdabot>  Parse error
12:40:40 <Uccus> I just checked out some videos (featuring Simon Peyton-Jones) on the Singularity project
12:40:42 <mattam> hum ok, maybe i see how
12:40:46 <Korollary> 0
12:40:50 <Uccus> GHC _should_ be important
12:41:16 <Uccus> if I get mature enough, I'll read the STM paper
12:41:16 <wolverian> Uccus, Singularity?
12:41:19 <Cale> Uccus: Singularity?
12:41:20 <glguy> C# is getting local type inference and inferred typed lambda expressions
12:41:27 <glguy> singularity isa C# kernel
12:41:33 <glguy> or a .NET kernel rather
12:41:37 <glguy> managed code
12:41:52 <emu> well i'm stuck interfacing with Java, and every week brings more Java related miseries
12:41:53 <Iulus> Uccus: link?
12:41:56 <pejo> Cale, MS' research OS
12:42:01 <Cale> SPJ is MAD! He's going to create a BLACK HOLE, and kill us ALL!
12:42:02 <emu> so that makes C# look oddly attractive :/
12:42:11 <Uccus> channel9.msdn.com
12:42:17 <SamB_XP> Cale: are you channeling zippy?
12:42:20 <Uccus> :) check the singuarity videos
12:42:21 <Cale> hehe
12:42:23 <emu> @yow
12:42:24 <lambdabot> JAPAN is a WONDERFUL planet -- I wonder if we'll ever reach their level
12:42:24 <lambdabot> of COMPARATIVE SHOPPING ...
12:42:32 <glguy> C#:  myList.Where(x => x.IsPimping)
12:42:37 <Iulus> Uccus: thanks
12:43:03 <Uccus> well, Simon almost rants in the video that the STM ideas are neatly expressed in Haskell
12:43:15 <wolverian> glguy, I dislike how they wired the lambda into the syntax.
12:43:17 <Uccus> but in .NET
12:43:29 <glguy> wolverian: I dislike how they wired a lot of stuff in
12:43:34 <emu> i liked the suggestion that VB should use \x -> x as lambda syntax
12:43:35 <wolverian> right.
12:43:40 <Uccus> you don't have IO types and that makes it harder (I'm quoting Simon)
12:43:42 <emu> that didn't go over so well
12:43:46 <glguy> wolverian: especialy tying language constructs to library classes
12:44:06 <wolverian> the whole linq thing seems like just another ORM to me, except tied to syntax.
12:44:23 <glguy> wolverian: what's cool about it is that you can join results from arbitrary sources
12:44:30 <Uccus> C# 3.0 has no fundanmental features
12:44:57 <Uccus> [apart from anonymous structs, types who are identified by their labels]
12:45:39 <Uccus> glguy: I just broke one of the rules of sensible programming: don't diss a language
12:45:50 <glguy> ?
12:45:57 <Uccus> can you explain the "join results from arbitrary source" bit?
12:46:27 <glguy> you can perform a join on a database table and a local list
12:46:29 <glguy> for example
12:46:31 <glguy> without flinching
12:46:36 <Uccus> yes I understand
12:46:37 <glguy> and the join calculus figures out how
12:46:48 <Uccus> .NET promises good optimization?
12:46:54 <Iulus> is this in the syntax already? I really could have used that for my job last summer
12:47:14 <Uccus> Iulus: C# 3.0, the LINQ project
12:47:17 <wolverian> glguy, that doesn't seem too special to me.
12:47:21 <Uccus> future
12:47:24 <glguy> wolverian: then don't use it
12:47:34 <wolverian> right.
12:47:36 <glguy> wolverian: it will make a lot of stuff I do at work easier
12:47:39 <Iulus> and likely, my shop won't upgrade any time soon
12:47:51 <wolverian> sorry - I'm not used to C#.
12:48:01 <glguy> my group will.. our devs have msdn subscriptions
12:48:08 <glguy> so it's not a big financial issue to move up
12:48:54 <wolverian> so.. where's linq for haskell? :)
12:49:05 <glguy> you mean list comprehensions?
12:49:13 <mattam> Cale: ok, i don't see how ($) runST could be typable in any system, is it ?
12:49:25 <Uccus> I don't see either
12:49:50 <Uccus> or at least, IMHO, should not be
12:50:01 <Cale> well...
12:50:12 <Cale> :t id Control.Monad.ST.runST
12:50:14 <lambdabot>   Inferred type is less polymorphic than expected
12:50:14 <lambdabot>    Quantified type variable `s' escapes
12:50:19 <Cale> right
12:50:31 <Cale> I think there ought to be systems where things like that typecheck
12:50:51 <mattam> ?
12:51:03 <mattam> inconsistent systems you mean ?
12:51:06 <Cale> no
12:51:11 <Uccus> id (anything) should always typecheck, Cale means, I guess
12:51:25 <Cale> Well, that's not true
12:51:37 <Uccus> it's not? :|
12:51:54 <Cale> id (something) doesn't typecheck here :)
12:51:58 <Uccus> exactly
12:52:02 <Cale> But there ought to be a way to have higher-rank polymorphism like that without breaking thingss
12:52:04 <Cale> -s
12:52:05 <sorear> id (1 + "")
12:52:21 <Cale> even when (something) typechecks :)
12:52:31 <Cale> :t Control.Monad.ST.runST
12:52:33 <lambdabot> forall a. (forall s. GHC.ST.ST s a) -> a
12:52:38 <Cale> :t id Control.Monad.ST.runST
12:52:38 <lambdabot>   Inferred type is less polymorphic than expected
12:52:39 <lambdabot>    Quantified type variable `s' escapes
12:52:45 <glguy> :t when something
12:52:47 <lambdabot> Not in scope: `something'
12:53:10 <Cale> :t when otherwise
12:53:12 <lambdabot> forall (m :: * -> *). (Monad m) => m () -> m ()
12:53:22 <edi> hehe
12:53:28 <Uccus> I meant when you said "I think there ought to be systems where things like that typecheck" you meant (id (any well-typed thing)) should typecheck
12:53:34 <mattam> id and ($) have different problems i think
12:53:35 <Uccus> didn't you?
12:53:44 <Uccus> not really
12:53:58 <Cale> It's really sort of the same problem.
12:54:15 <mattam> I can code id and ($) in Coq and have one typecheck and not the other :)
12:54:42 <Uccus> so Cale, higher-order types will always have this possibility of exposing it's "bound" type variable, right?
12:54:44 <emu> :t id ($)
12:54:46 <lambdabot> forall a b. (a -> b) -> a -> b
12:54:52 <Cale> well, the only difference between id and ($) is the type
12:54:55 <mattam> id doesn't touch the argument at all. ($) decomposes the (a -> b) product
12:55:08 <Cale> ($) = id
12:55:18 <sorear> ?let ($) = id
12:55:19 <lambdabot> Defined.
12:55:22 <Cale> (but with a different type signature)
12:55:30 <Uccus> heh
12:55:39 <mattam> and as s is bound in a...
12:55:44 <sorear> but, ($)'s type is a special case of id's type
12:55:47 <Uccus> Cale: am I following you?
12:55:52 <mattam> well yes
12:56:05 <Uccus> Cale: is exposing the bound variable is what bothers you?
12:56:10 <Cale> Uccus: yeah, you have to avoid that
12:56:12 <basht> :t id ($)
12:56:14 <lambdabot> forall a b. (a -> b) -> a -> b
12:56:22 <Cale> In this case, it would actually be safe to apply id to the thing
12:56:54 <Cale> but in general, the sorts of mechanisms which allow for that sort of type matching allow variables to escape unless you're pretty careful
12:56:57 <Iulus> > sum `id` [1,2,3,4]
12:56:58 <lambdabot>  10
12:57:03 <Iulus> interesting
12:57:28 <Uccus> Iulus: what's so interesting?
12:57:46 <Iulus> I just never thought of ($) = id before
12:58:05 <Uccus> Iulus: that the 'id' is being applied to sum and not [1,2,3,4]?
12:58:22 <glguy> > id id id id id id 10
12:58:23 <lambdabot>  10
12:58:26 <Iulus> it makes sense to me, I had just had never occurred to me
12:59:11 <Uccus> well, yeah, we've made a fundamental discovery
12:59:24 <Iulus> haha
12:59:25 <Uccus> ($) = id [with a different type signature]
13:00:04 <mgsloan> :t $
13:00:05 <lambdabot> parse error on input `$'
13:00:07 <Uccus> after all, JHC throws away type info at the end of compilation, no?
13:00:09 <ndm> Uccus: usually $ is just used to avoid brackets, no functinoality
13:00:11 <mgsloan> :t ($)
13:00:13 <lambdabot> forall b a. (a -> b) -> a -> b
13:00:14 <mgsloan> :t id
13:00:15 <lambdabot> forall a. a -> a
13:00:23 <ndm> Uccus: JHC, notquite, GHC/Yhc, yes
13:00:34 <Cale> Uccus: want something more interesting? (.) = map with different signatures :)
13:00:44 <Uccus> wow!
13:00:46 <Iulus> mgsloan: think of (a -> b) -> a -> b as (a -> b) -> (a -> b)
13:00:47 <sorear> s/map/fmap/
13:00:53 <Uccus> let me doublecheck that
13:00:58 <Cale> well, they're both specialisations of fmap
13:01:00 <mgsloan> lulus - yeah, that helps with that
13:01:23 <sorear> ((->) (((->) a) b)) (((->) a) b)
13:01:24 <mgsloan> > fmap (+1) 5
13:01:25 <lambdabot>  add an instance declaration for (Num (f a))
13:01:35 <mgsloan> :t fmap
13:01:37 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
13:01:42 <glguy> ?djinn (a -> b) -> a -> b
13:01:42 <Uccus> yeah
13:01:43 <lambdabot> f a = a
13:01:43 <sorear> > fmap (+1) (*2) 10
13:01:45 <lambdabot>  21
13:01:47 <Uccus> map belongs to []
13:01:47 <Cale> > let (.) :: Functor f => (a -> b) -> f a -> f b; (.) = fmap in ((+1) . (*3)) . [1..10]
13:01:48 <lambdabot>  [4,7,10,13,16,19,22,25,28,31]
13:01:50 <Uccus> fmap to function
13:01:52 <Uccus> Functor
13:02:01 <Cale> see?
13:02:07 <Uccus> same meaning, as I was ranting
13:02:09 <mgsloan> cool
13:02:19 <sorear> unfortunately, Haskell only has a class for covariant functors.
13:02:30 <Uccus> yeah
13:02:37 <Uccus> ndm: you there?
13:02:47 <Cale> It's not hard to make a contravariant functor class.
13:02:51 <ndm> Uccus: yep
13:02:54 <Uccus> Cale: that's awesom
13:03:06 <sorear> e
13:03:15 <glguy> contravariant functor class works on things of kind * instead of *->*?
13:03:29 <Cale> glguy: no, it's the same, but map reverses arrows
13:03:37 <glguy> oh
13:03:38 <sorear> e.g. Set is a contravariant functor
13:03:39 <Cale> cmap :: (a -> b) -> f b -> f a
13:04:03 <Uccus> ndm: did you happen to come across my hopeless cry for a revolution in "The Other Prelude" page on the wiki?
13:04:11 <pesco> quit
13:04:13 <Uccus> ndm: thought you might be interested
13:04:22 <sorear> (although cfmap on sets does not preserve finitude)
13:04:36 <ndm> Uccus: not really, my categorical knowledge is nearly none - its not my thing
13:04:39 <Cale> We'll be able to make Set an instance of Functor in the new GHC.
13:04:48 <Uccus> ndm: mine too
13:04:51 <ndm> Uccus: if your cry is the same as it was on the mailing list
13:04:55 <ndm> Uccus: ah, link me up :)
13:04:57 <Iulus> which reminds me--is there any good book for Category Theory?
13:05:00 <Cale> (but not Monad, stupid return)
13:05:11 <Iulus> I mean, there is, but is there any you guys would suggest?
13:05:15 <Uccus> ndm: but I was hoping that you might know people who are category theorists
13:05:23 <glguy> ndm: I got your message
13:05:28 <Cale> Categories for the Working Mathematician is good if you're a working mathematician.
13:05:34 <ndm> Uccus: none at all
13:05:42 <ndm> glguy: thanks for the code, its in now
13:05:49 <Cale> (as opposed to a broken mathematician)
13:05:49 <Iulus> if working mathematician == math major still in college, then maybe
13:05:54 <glguy> I saw that :) and I saw you added an allOverContext example
13:05:58 <monochrom> cries for a revolution are hopeless
13:06:01 <Cale> yeah, should be good :)
13:06:05 <ndm> glguy: and i diagram :)
13:06:14 <Cale> monochrom: cries for a revolution?
13:06:21 <Uccus> monochrom: so it seems
13:06:46 <monochrom> I'm a broken mathematician.
13:06:59 <Uccus> Cale: I started a page on the wiki, calling for all the revolutionaries to throw away the past and write a Prelude of our own
13:07:20 <Uccus> Cale: was meant to be a jump start towards "World Dominition!"
13:07:25 <Uccus> but alas!
13:07:37 <Cale> The problem with writing your oown prelude is that it's a pain in the ass to actually use it.
13:07:39 <Uccus> I used the wrong word! :(
13:07:42 <sorear> As soon as I figure out what to replace them with in general, I'm going to post "Constructor classes considered harmful" to -cafe; (e.g. if Array was a constructor class rather than an MPTC UArray would be impossible)
13:07:48 <Cale> We need a fork of fptools.
13:08:01 <ndm> Uccus: unfortunately in Yhc the Prelude is practically baked into the compiler...
13:08:06 <ndm> sucks really bad
13:08:23 <sorear> Why can't we kill fptools and port GHC to Cabal?
13:08:32 <mattam> Cale: ok coq is able to typecheck "($) runST" once i generalize ($) to take a dependent function as argument :) I can see why it was decided to forget about that kind of generality.
13:08:33 <Uccus> ndm: doesn't really matter
13:08:38 <jajs> hello. i just read the "Partial Functions and the Semantic Approximation Order" section of the wikibook and there is something i don't undestand : does "a \sqsubset b" mean that a is more or less defined than b ?
13:08:59 <Uccus> ndm: I guess slight irritations are not a good enough reason to throw the Prelude away anyway
13:09:05 <ndm> sorear: please do that, i'd karma point you as much as you wish!
13:09:07 <Cale> a is less defined than b
13:09:21 <sorear> CCHL or Cabal ghc?
13:09:23 <ndm> Uccus: yeah, i guess one day we'll have a new prelude, but i don't think its necessary  yet
13:09:35 <jajs> Cale, thanks, so there is a mistake
13:09:36 <ndm> sorear: Cabal ghc + fptools/whatever
13:09:37 <Cale> I think the sooner the better
13:09:39 <monochrom> a is less defined than b
13:09:52 <monochrom> and I am not just copying Cale.
13:09:58 <Iulus> how are you going to convince people to use the new instead of the old?
13:10:14 <Uccus> ndm: me too, but I wanted to see how badly people are hurt (by the Prelude). conclusion: not badly enough.
13:10:16 <monochrom> by a red revolution
13:10:18 <Iulus> it's unfamiliar--almost like learning a new language
13:10:20 <mgsloan> reasoning!
13:10:33 <Uccus> Iulus: not instead of, but "side by side"
13:10:39 <mgsloan> not if you only change the stuff that needs changeing
13:10:43 <monochrom> how do you convince rich people to give their money to the state? by a red revolution.
13:10:46 <Iulus> I suppose maybe enough Haskellers will respond to reason--not something that can be said about every language
13:10:47 <Cale> Iulus: The changes people want aren't that huge
13:10:49 <Uccus> it's a pretty ordinary idea for a revolution really :p
13:11:17 <Iulus> Uccus: okay, that makes sense
13:11:21 <Cale> 1. Delete fail from Monad and change the translation of do-notation to reflect that.
13:11:23 <Uccus> mgsloan: that's what I wanted to know, if anything needs changing
13:11:35 <Cale> 2. Bring back MonadZero and monad comprehensions
13:11:43 <Uccus> well, Cale, can you have a look at it?
13:11:46 <mgsloan> I think there's a page on the wiki about that.  maybe it's yours
13:11:49 <mattam> what's MonadZero ?
13:12:04 <Cale> mattam: It just has mzero in it
13:12:06 <Uccus> http://www.haskell.org/haskellwiki/The_Other_Prelude
13:12:07 <lambdabot> Title: The Other Prelude - HaskellWiki
13:12:12 <Uccus> here's the page
13:12:18 <mattam> without mplus ?
13:12:22 <Uccus> feel free to edit it
13:12:32 <mattam> what's the point ?
13:12:34 <Uccus> I liked the idea of monad comprehensions
13:12:41 <Cale> mattam: expressing failure
13:12:53 <mattam> right
13:12:54 <monochrom> I should go invent arrow comprehension.
13:12:59 <ndm> Cale: i like list comps only, makes it much more natural
13:13:08 <Uccus> mattam: [] implements MonadPlus by mzero = []
13:13:28 <mattam> and Maybe by Nothing i know
13:13:53 <mattam> but why remove mplus ?
13:13:57 <Uccus> so obviously the whole point of the MonadPlus class is to
13:14:02 <Uccus> remove mplus?
13:14:04 <jajs> so, should I correct "Here, a\sqsubset b denotes that a is more defined than b." in http://en.wikibooks.org/wiki/Haskell/Denotational_semantics#Partial_Functions_and_the_Semantic_Approximation_Order ?
13:14:07 <Uccus> did I miss anything?
13:14:07 <lambdabot> http://tinyurl.com/yxxgb8
13:14:15 <Cale> I like monad comprehensions because they give us another way of introducing monads to beginners
13:14:22 <Uccus> who said anything about removing mplus?
13:14:37 <Cale> which is less imperative-programming-esque
13:14:53 <Uccus> "do notation considered harmful"... again
13:14:54 <Cale> We're not going to remove mplus, it will still be in MonadPlus
13:14:55 <mattam> Cale said having just mzero would be good
13:14:57 <glguy> can you people please stick to one train of thought? coming back and reading the backlog gets complicated
13:15:16 <glguy> mattam: I thought that the idea was that you could not have mzero
13:15:20 <Cale> mattam: http://www.haskell.org/haskellwiki/MonadPlus
13:15:22 <mattam> i reiterate, what's the point of having mzero without mplus
13:15:23 <lambdabot> Title: MonadPlus - HaskellWiki
13:15:28 <Saizan> Uccus: decoupling mplus from mzero
13:15:31 <Cale> er no, http://www.haskell.org/haskellwiki/MonadPlus_reform_proposal
13:15:31 <lambdabot> Title: MonadPlus reform proposal - HaskellWiki
13:15:51 <Uccus> Saizan: thanks
13:16:28 <Cale> You only need MonadZero to do comprehensions
13:16:44 <glguy> to handle failed pattern matches
13:16:49 <Cale> and for that
13:17:03 <Cale> failed pattern matches and guards
13:17:34 <Cale> I'd want do-notation to generate a MonadZero constraint whenever there's a refutable pattern match
13:18:18 <mattam> it would be cleaner indeed
13:18:23 <Cale> If you want to avoid the MonadZero constraint and really make the thing crash when the pattern fails, make the pattern irrefutable with ~.
13:18:31 <glguy> Cale: is this being considered for haskell'?
13:18:34 <Cale> glguy: I don't know
13:18:43 <Cale> Probably not, because it's not what's implemented
13:18:49 <Uccus> Cale: do you mean to say that if we rewrite the Prelude from the scratch again, fail should go into MonadZero?
13:18:56 <Uccus> glguy: definitely not
13:18:59 <Cale> Haskell' is about formally stating what's been implemented.
13:19:07 <glguy> oh
13:19:16 <Cale> Uccus: roughly
13:19:24 <Uccus> ok
13:19:35 <glguy> Cale: so Haskell' will look a lot like GHC Head with some of the extensions?
13:19:39 <Cale> yeah
13:19:50 <Uccus> but... pardon me if this is way too stupid
13:19:56 <Cale> If you want something new to go into Haskell', you have to implement it.
13:20:01 <glguy> ah
13:20:11 <Uccus> fail takes a String argument, mzero doesn't!
13:20:16 <Cale> Uccus: right
13:20:24 <Uccus> I mean, fail is more informative
13:20:33 <Cale> So that might warrant the use of MonadError or something like that
13:20:33 <glguy> or at least it can be :)
13:20:46 <Cale> But the reason fail is in Monad is not for the string argument
13:21:11 <Cale> it's just to report pattern match failures, which we can already do accurately in lambda terms
13:21:13 <Uccus> I think in order to get into Haskell' it has to be not only implemented but also thoroughly tested
13:21:33 <Uccus> Cale: I see the point
13:24:02 <Cale> the Functor hierarchy proposal is decent -- I'm not sure whether to have Applicative => Monad or Functor => Monad though.
13:24:06 <fasta> Did anyone ever wrote something about how to implement a dynamic graph optimally?
13:24:17 <fasta> s/wrote/write
13:25:02 <Cale> join should be in the Monad class
13:25:19 <glguy> :t join -- Functor?
13:25:21 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
13:25:45 <Uccus> well, my naive understanding is that Applicative seems to factorize well
13:26:12 <Uccus> erm, guys, I have another stupid question
13:26:18 <Uccus> what does join mean?
13:26:33 <ndm> hmm, anyone no how to convert from String -> Html, using the Text.Html library in base
13:26:48 <Cale> join x = x >>= id
13:26:57 <ndm> all the ones i try seem to just create a string within the Html document, as a single string...
13:27:04 <Cale> or:
13:27:17 <Cale> join x = do { y <- x; v <- y; return v }
13:27:31 <Cale> or:
13:27:35 <Cale> join x = do { y <- x; y }
13:27:36 <Uccus> then, what does it mean for lists?
13:27:40 <Cale> concat
13:27:47 <Cale> > join [[1,2,3],[4,5],[6,7,8]]
13:27:48 <lambdabot>  [1,2,3,4,5,6,7,8]
13:27:51 <Uccus> that's what I wanted to know
13:28:14 <Uccus> throwing out the outer layer
13:28:39 <Uccus> so for lists, join and mplus coincide?
13:28:50 <Uccus> damnit
13:28:52 <Uccus> retreat
13:28:57 <Uccus> didn't mean it
13:28:59 <ndm> @source Text.Html
13:28:59 <lambdabot> http://darcs.haskell.org/packages/base/Text/Html.hs
13:29:49 <Uccus> is there any other monadic operator on lists that is equivalent to concat? [apart from join]
13:30:43 <Cale> @type msum
13:30:45 <lambdabot> forall a (m :: * -> *). (MonadPlus m) => [m a] -> m a
13:30:56 <Cale> > msum [[1,2,3],[4,5],[6,7,8]]
13:30:57 <lambdabot>  [1,2,3,4,5,6,7,8]
13:31:21 <Uccus> thanks
13:32:12 <Saizan> is there a nice example of a comonad?
13:34:58 <dobblego> > [1..10, 2]
13:34:59 <lambdabot>  Parse error
13:35:06 <dobblego> how do I have a list range with a step?
13:35:12 <Cale> http://www.haskell.org/haskellwiki/The_Other_Prelude
13:35:14 <lambdabot> Title: The Other Prelude - HaskellWiki
13:35:58 <allbery_b> > [1, 2..10]
13:36:00 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
13:36:09 <allbery_b> > [1, 3 .. 10]
13:36:11 <lambdabot>  [1,3,5,7,9]
13:36:26 <dobblego> oh thanks
13:36:28 <allbery_b> "by example"
13:36:56 <glguy> > enumFromThenTo 1 2 10
13:36:58 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
13:37:01 <Cale> Eventually, we'll have it do a search in Sloane to get the rest of the terms :)
13:37:13 <Uccus> Cale: yay! the fundamental discovery! me likes...
13:38:38 <Uccus> Cale: beautiful. this looks better than the Prelude. honestly.
13:41:00 <glguy> can you write: import qualified Prelude?
13:41:23 <Uccus> yes you can AFAIC
13:42:13 <Uccus> ndm: you there?
13:42:38 <ndm> Uccus: yep, am around, not watching the channel but can be prodded
13:42:55 <Uccus> ndm: last week I read the things on the web on your parsing framework
13:43:08 <ndm> Uccus: ah yes :)
13:43:11 <Uccus> ndm: makes a lot more sense than YACC for sure
13:43:16 <Uccus> :)
13:43:18 <ndm> good good :)
13:43:31 <ndm> its still not implemented fully, sadly
13:43:39 <Uccus> did you do any work on that afterwards?
13:43:54 <ndm> not in quite a while, did you click on teh helix link?
13:44:04 <Cale> another thing which might be doable is extending do-notation to be type-sensitive. If a statement is a boolean value, then it is treated as a guard.
13:44:05 <Uccus> nope
13:44:17 <ndm> turned out that current maximal munch lexers have O(n^2) performance, which would give my system bad performance
13:44:30 <Uccus> cale: somebody proposed something like that on haskell-prime mailing list
13:44:37 <Cale> Uccus: yes, I saw that
13:44:37 <Uccus> Cale: you might want to check that out
13:44:40 <ndm> so have redesigned teh maximal munch lexer algorithm, which has been where the workwas going
13:44:43 <Uccus> ok :)
13:44:49 <ndm> once thats done, i can move back to the parsing using that as a library
13:44:55 <ndm> although currently hacking on hoogle
13:44:59 <Cale> (I am on that list, but I haven't been following the lists too closely lately
13:45:01 <Cale> )
13:45:06 <Uccus> O(N^2) worst case?
13:45:52 <ndm> Uccus: yes, for lex generated lexers
13:46:00 <ndm> including alex etc
13:46:08 <Cale> I think that leaving (>>) outside of the applicative/monad class somewhat ignores its original reason for being defined
13:46:28 <ndm> http://www-users.cs.york.ac.uk/~ndm/projects/helix.php - more details on lexing being O(n^2)
13:46:30 <lambdabot> Title: Neil Mitchell - Helix
13:46:38 <ndm> including an example of an input/lexer which triggers it
13:46:40 <Uccus> Cale: I would have no idea
13:46:53 <Uccus> Cale: I've just started learning Haskell last year
13:46:54 <Cale> okay, I'll move it into Applicative
13:47:01 <Uccus> sure
13:47:09 <Cale> Let's adopt the Functor hierarchy proposal :)
13:47:11 <Uccus> applicative, if I understand correctly
13:47:14 <Uccus> yay!
13:47:18 <Cale> since there's very little reason not to
13:47:24 <Uccus> I guess
13:47:39 <Uccus> and very little reason for an alternative prelude without it
13:48:04 <Uccus> Cale: I don't understand Category theory or practices
13:48:24 <Cale> well, I don't think this requires a really deep understanding of category theory
13:48:33 <Uccus> yeah, me too
13:48:38 <Cale> Reading the Haskell 1.4 prelude is enough to give you lots of ideas :)
13:48:59 <PaulAJ> I've just been having a quick look at the libsecondlife project.  They have an IRC bridge
13:49:01 <PaulAJ> http://www.libsecondlife.org/content/view/17/33/
13:49:04 <lambdabot> Title: libsecondlife - SLIRC
13:49:27 <PaulAJ> Which makes me wonder if we might look at migrating over there.
13:49:40 <SamB_XP_> um, no!
13:49:46 <SamB_XP_> we already have no life
13:49:52 <SamB_XP_> we don't need *more* no life
13:50:14 <PaulAJ> I was thinking, what would Lambdabot look like?
13:50:25 <Uccus> Cale: but isn't (>>) somewhat secondary?
13:50:36 <ski> :t let ma >> mb = (\a b -> b) `liftM` ma `ap` mb in (>>)
13:50:38 <lambdabot> forall (m :: * -> *) a1 a. (Monad m) => m a1 -> m a -> m a
13:50:38 <roconnor> We have a pic of lambdabot
13:50:46 <SamB_XP> Uccus: it is
13:50:49 <PaulAJ> Where?
13:50:56 <roconnor> http://www.cse.unsw.edu.au/~dons/images/lambdabot.png
13:51:07 <SamB_XP> Uccus: but having it in the class could allow for significantly optimized implementations
13:51:10 <Uccus> aww
13:51:11 <Cale> Uccus: yes, but the whole reason for providing it separately from (>>=) is because it can be more efficiently implemented on some types
13:51:15 <Uccus> so cute (lambdabot)
13:51:32 <PaulAJ> That is not quite how I imagined her.
13:51:50 <SamB_XP> is she not very sexy?
13:52:02 <Uccus> so if we don't include it in the class, it cannot be re-implemented by the user?
13:52:12 <SamB_XP> Uccus: right.
13:52:20 <PaulAJ> If so then that portrait does not do her justice.  I thought of something slimmer, say in a long black dress with a white lambda on the front.
13:52:42 <Uccus> samb_xp: the lamdabot in the pic looks so lost. but our lambdabot is so damn smart!
13:52:49 <SamB_XP> with purple eyes?
13:52:53 <roconnor> I think the pic is quite good.  It conveys a certain busy telephone operatator kinda look
13:53:01 <ski> Cale : how about defining it in terms of 'ap' and 'fmap', instead ?
13:53:10 <roconnor> She's not lost, she is very very tired.
13:53:16 <PaulAJ> Maybe busy, but effortless as well.
13:53:18 <ski> Cale : is that too inefficient, in some cases ?
13:53:27 <Uccus> but lambdabot doesn't even break sweat typing runSTs!
13:53:34 <roconnor> She has been working 24 hours a day for ...
13:53:38 <SamB_XP> ski: good question
13:53:39 <roconnor> @uptime
13:53:40 <lambdabot> uptime: 1d 21h 13m 25s, longest uptime: 9d 2h 23m 6s
13:53:50 <roconnor> for er almost 2 days
13:53:55 <ski> (see implementation above)
13:53:55 <Uccus> ski,cale: is there a better name than `ap`?
13:54:11 <SamB_XP> ski: it depends on the compiler, the monad, the options you pass to the compiler...
13:54:14 <roconnor> I thought she'd be up longer than that.
13:54:31 <roconnor> But still, how would you look after a 45 hour shift?
13:54:39 <PaulAJ> Somehow the idea of Lambdabot going down and getting rebooted as 3d animations are not quite what I had in mind.
13:54:45 <Cale> ski: building (>>) from that?
13:55:01 <ski> Uccus : there's another name .. don't think it is better, though
13:55:02 <Uccus> do you guys understand how scary it is for a newbie like me to start learning a function and faces something like an `ap`?
13:55:06 <ski> Cale : yes
13:55:09 <ski> :t let ma >> mb = (\a b -> b) `liftM` ma `ap` mb in (>>)
13:55:10 <lambdabot> forall (m :: * -> *) a1 a. (Monad m) => m a1 -> m a -> m a
13:55:25 <PaulAJ> Uccus: yes.  Been there, done that.  Currently designing the tee shirt.
13:55:50 <SamB_XP> PaulAJ: be sure to run it through GHCi before sending it to be printed!
13:56:03 <yip> Cale: in our lifetime, will the compiler be able to automatically figure out how to optimize >>?
13:56:08 <PaulAJ> Too right.
13:56:39 <PaulAJ> Actually I'm really designing the logo for the Lambda Revolution.
13:56:40 <Uccus> yip: yes. guaranteed. provided quantum computing becomes a reality.
13:56:42 <SamB_XP> which compiler?
13:56:50 <SamB_XP> Uccus: you are silly
13:57:04 <Uccus> samb_xp: thanks
13:57:06 <SamB_XP> quantum computing isn't good for that
13:57:21 <SamB_XP> can you even *loop* in quantum computing?
13:57:35 <Uccus> well, they say it's good for combinatorial explosion!
13:57:38 <mgsloan> hmm, why can't i darcs send to gtk2hs-devel@lists.sourceforge.net?
13:57:52 <PaulAJ> Yes.  Each iteration creates a new universe for the variables to be instantiated in.
13:57:53 <SamB_XP> there certainly seem to be some big restrictions on it anyway
13:58:44 <SamB_XP> anyway, is it actually possible to build a quantum computer? has anyone built one?
13:59:05 <PaulAJ> I believe they can just about factor 14.
13:59:11 <roconnor> I B M
13:59:19 <SamB_XP> just about?
13:59:31 <Uccus> samb: it was a joke. I'm learning physics. it seems that building 5 bit processors is possible. but beyond that, well it's exponential in bits, the complexity
13:59:58 <Uccus> yeah
13:59:59 <SamB_XP> Uccus: hmm. that seems like it gives you a sublinear payback!
14:00:04 <roconnor> The current quantum computers aren't universal computers yet
14:00:18 <SamB_XP> roconnor: I didn't think they were
14:00:29 <yip> none of the computers we have today are universal computers :)
14:00:36 <SamB_XP> yip: oh really?
14:00:46 <Uccus> which brings us back to computer science: quantum computers are only Turing complete, you shouldn't ask more from them
14:00:56 <yip> SamB: they all have memory constraints, among other things
14:00:58 <SamB_XP> just because I can't play N64 games, you think my computer isn't universal?
14:00:58 <PaulAJ> On another subject, I want a list I can delete arbitrary items from in constant time, say by handing back a cookie.
14:01:29 <PaulAJ> If I were doing this in an imperative language I'd use a double linked list, but I don't know how to do the equivalent in FP.
14:01:39 <Uccus> s/Turing Complete/Turing Machines
14:01:47 <SamB_XP> PaulAJ: have you looked at zippers?
14:01:54 <mgsloan> once you get a script to auto-register gmail accounts and mount a gmail file system, you've got practically infinite mem
14:02:11 <SamB_XP> mgsloan: assuming you have enough invites!
14:02:24 <SamB_XP> if they cut off your supply of invites, you are hozed!
14:02:27 <ski> all clear ?
14:02:29 <PaulAJ> Not in this context, but I don't think they would help.  Moving through them requires memory allocations, and I want to keep this lightweight.
14:02:32 <ski> (ECHAN)
14:03:15 <PaulAJ> Also I think the cookies would be delimited continuations, and I haven't grocked them yet.
14:03:35 <SamB_XP> PaulAJ: you could always, um, use a doubly linked list?
14:03:38 <mgsloan> samb - heh, good thing you can give them to yourself :)
14:04:07 <ski> Saizan : how about the environment comonad ?
14:04:21 <SamB_XP> mgsloan: well, if they catch on they might get rid of the starting invites...
14:04:28 <sorear> main = forkIO (print [0..])  <---  how can this be made to work?
14:04:31 <PaulAJ> Yeah.  I'm going to have to look at the wiki page on the subject.  Its probably still going to include continuations because I want to add and remove items at random.
14:04:39 <PaulAJ> SEc, gotta go do something.
14:05:29 <mgsloan> true, they've probably got something to look for misbehavior like that
14:06:31 <SamB_XP> sorear: you have to make sure the main thread doesn't return!
14:07:30 <Cale> ski: well, hmm, you can implement it in various ways, but I think that leaving it up to the monad designer is probably best for efficiency purposes
14:08:01 <Uccus> so back to silly newbie question
14:08:09 <Uccus> I want to write quickSort
14:08:12 <PaulAJ> Back.
14:08:19 <sorear> samb: I've figured that much out already, but I want my program to quit when the last thread is garbage collected.
14:08:21 <Uccus> but I don't want it to be efficient
14:08:38 <SamB_XP> sorear: oh, you need something to reap them
14:08:41 <Korollary> you need better marketing then
14:08:50 <Uccus> instead, what I want is to pipeline functions
14:08:52 <SamB_XP> and somehow know that there aren't any more...
14:09:13 <SamB_XP> search list archives
14:10:06 <Uccus> [quickSort, id, quickSort] applied to [respectly] filter . [(<), (==), (>)] applied to x applied to xs
14:10:17 <Uccus> then concatenate them
14:10:37 <Uccus> how should I go about this? zipWith apply?
14:10:54 <SamB_XP> that actually isn't quicksort
14:11:03 <lisppaste2> glguy pasted "efficient quicksort :)" at http://paste.lisp.org/display/33299
14:11:04 <Cale> sure it is
14:11:18 <SamB_XP> no, someone said that it is actually a different sorting algorithm...
14:11:27 <Cale> It doesn't have to be in-place in order to be quicksort
14:11:43 <SamB_XP> does it even have the same time complexity?
14:11:44 <sorear> by the same logic, DLists aren't lists at all.
14:11:54 <Uccus> glguy: that's too efficient ;)
14:11:55 <monochrom> I don't know.
14:12:00 <SamB_XP> sorear: they aren't ;-P
14:12:01 <ski> Uccus : would one instance be 'quickSort (filter (x <) xs)' ?
14:12:06 <SamB_XP> they are functions between lists ;-)
14:12:10 <Cale> SamB_XP: It's worst case n^2 due to the poor choice of pivot, but it's average case n log n
14:12:15 <Uccus> ski: yes
14:12:30 <sorear> Dlists are trees of PAp nodes
14:12:39 <SamB_XP> Cale: does that include the cost of garbage collection?
14:12:42 <Cale> actually, it's average case k log n where k is the number of values you need.
14:12:49 <sorear> (partial applications with 2 args of the 3-arg function (.))
14:12:58 <Uccus> ski: but my question is, what would it look like if I want to "factor out" as much as possible
14:13:12 <ski> Uccus : do you want a list of all possibilities (lists, in this case), or a list of list of possibilities ?
14:13:13 <Cale> er
14:13:18 <SamB_XP> Cale: anyway apparantly it has a name all its own!
14:13:19 <Cale> no
14:13:35 <Cale> (that would be silly)
14:13:38 <sorear> Cale: if I ask for the first element of a sorted list, how do you expect to find the minimum of a list in O(1 log n)!
14:13:41 <monochrom> Somehow, I believe both of you.
14:13:52 <Cale> no, it's O(n) in that case
14:14:00 <ski> > return (+) `ap` [100,200] `ap` [3,4,5]
14:14:01 <lambdabot>  [103,104,105,203,204,205]
14:14:03 <Cale> So perhaps O(n log k)
14:14:06 <Cale> hmm
14:14:59 <SamB_XP> Cale: it takes O(n) to "take 0" off of the result?
14:15:04 <Uccus> ski: that approach I guess will be very, very inefficient
14:15:16 <Cale> to get the head of the result
14:15:21 <Cale> take 1
14:15:43 <SamB_XP> > log 1
14:15:44 <lambdabot>  0.0
14:15:47 <SamB_XP> oh, right.
14:15:48 * SamB_XP silly
14:16:05 <SamB_XP> wait wait...
14:16:11 <SamB_XP> that would be k of zero...
14:16:14 <SamB_XP> > log 0
14:16:15 <lambdabot>  -Infinity
14:16:29 <augustss> > log (exp 1)
14:16:31 <lambdabot>  1.0
14:16:35 <Cale> remember it doesn't have to work for small values
14:16:42 <Uccus> ski: I mean, I do understand that [quickSort, id, quickSort] and [(<), (==), (>)] have the same length, so I want to pipe the functions in parallel
14:16:43 <SamB_XP> oh right.
14:16:56 <Cale> but perhaps that's still wrong, I forget how the analysis went
14:17:02 <ski> Uccus : hm, yes .. you probably want to share the filters, yes ?
14:17:07 <Uccus> yes
14:17:19 <glguy> sequence $map filter [(<), (==), (>)]
14:17:20 <Uccus> the filters, the xs, and the x
14:18:21 <ski> hmm
14:18:22 <Uccus> > sequence $ map filter [(<), (==), (>)]
14:18:23 <lambdabot>    Expecting a function type, but found `t_a1VH'
14:18:23 <lambdabot>    Expected type: a -> ...
14:18:24 <svref> I recently built {ghc,hmake,hat,HaXml,http} from sources for the first time.  All went well, except for hat, which hmake & ghc claim they don't know about -package hat-2.05.  ghc-pkg lists (hat-2.5) in its ~/.../package.conf, and can tell me somethings about it, but won't let me enable it.  "cannot find package hat".  :(
14:18:40 <glguy> > sequence (map filter [(< 4),(== 4),(> 4)])
14:18:41 <lambdabot>  Add a type signature
14:18:44 <ski> do you want to combine each sorting with each comparision, or just three times ?
14:18:46 <glguy> > sequence (map filter [(< 4),(== 4),(> 4)]) [1..10[
14:18:47 <lambdabot>  Parse error
14:18:48 <glguy> > sequence (map filter [(< 4),(== 4),(> 4)]) [1..10]
14:18:49 <lambdabot>  [[1,2,3],[4],[5,6,7,8,9,10]]
14:19:02 <Uccus> cool!
14:19:05 <glguy> > mapM filter [(< 4),(== 4),(> 4)]) [1..10]
14:19:05 <lambdabot>  Parse error
14:19:10 <glguy> > mapM filter [(< 4),(== 4),(> 4)] [1..10]
14:19:12 <lambdabot>  [[1,2,3],[4],[5,6,7,8,9,10]]
14:19:20 <ski> do cmp <- [(<), (==), (>)]; let ys = filter (x `cmp`) xs; sort <- [quickSort, id, quickSort]; return (sort ys)
14:19:29 <ski> ^^ will do all nine combinations
14:20:30 <ski> do (cmp,sort) <- [(<), (==), (>)] `zip` [quickSort, id, quickSort]; let ys = filter (x `cmp`) xs; return (sort ys)
14:20:44 <ski> ^^ will do the three ones with corresponding elements
14:21:06 <glguy> > mapM filter (map ($ 4) [(<),(==),(>)]) [1..10]
14:21:07 <lambdabot>  [[5,6,7,8,9,10],[4],[1,2,3]]
14:21:19 <Uccus> ski: the first one, I think I'm following you, has all nine combinations
14:21:26 <ski> yep
14:21:29 <ski> (in a flat list)
14:21:30 <Uccus> ski: how do I extract the ones I want?
14:21:37 <dcoutts__> mgsloan: you mean it's not getting though or it's going to the moderator?
14:22:25 <mgsloan> darcs failed:  failed to send mail to: Gtk2Hs-devel List <gtk2hs-devel@lists.sourceforge.net>
14:22:31 <ski> Uccus : in this case it is simple .. if 'i' is the index of the comparision you want, and 'j' is the index of the sorting you want, just index the resulting list with 'i*3 + j'
14:22:42 <dcoutts__> mgsloan: in that case it's your local mail setup that's not right
14:22:51 <Uccus> ski:  I understand
14:22:54 <ski> of course, if you want to select like this, it could be nicer to get a list of lists, instead of a flattened list
14:23:08 <mgsloan> oh.  yeah, I use web browser mail
14:23:09 <ski> Uccus : is that what you want ?
14:23:41 <Uccus> ski: not really, I want to use quickSort!
14:24:08 <dcoutts__> mgsloan: yeah, you need a local mail forwarding prog, eg ssmtp and configure it to forward to your isp's smtp server
14:24:08 <Uccus> ski: (cmp, sort) <- [somelist] `zip` [otherlist]
14:24:35 <Uccus> ski: doesn't zip give me a list of pairs instead of a pair of lists?
14:24:42 <ski> oh .. i think i misinterpreted you as wanting the one with nine solutions
14:24:52 <ski> Uccus : indeed
14:25:13 <glguy> > let f [] = []; f (x:xs) = (\[a,b] -> a ++ x:b) $ mapM ((f .) . filter) (map ($ x) [(>=),(<)]) xs in f [4,2,6,7,3] :: [Int]
14:25:15 <lambdabot>  [2,3,4,6,7]
14:25:19 <glguy> that can probably be cleaned ;)
14:25:38 <mefistofeles> wow... crowded :P
14:25:40 <monochrom> poinless quicksort?
14:25:44 <ski> @users
14:25:45 <lambdabot> Maximum users seen in #haskell: 309, currently: 272 (88.0%), active: 43 (15.8%)
14:25:48 <glguy> monochrom: almost :(
14:26:05 <Uccus> monochrom: yeah, sort of
14:26:12 <SamB_XP> @pl f [] = []; f (x:xs) = (\[a,b] -> a ++ x:b) $ mapM ((f .) . filter) (map ($ x) [(>=),(<)]) xs
14:26:13 <lambdabot> (line 1, column 6):
14:26:13 <lambdabot> unexpected "="
14:26:13 <lambdabot> expecting variable, "(", operator or end of input
14:26:30 <glguy> might need the let in
14:26:31 <fabiim> why is read "123" telling me : Ambiguous type variable `a' in the constraint:
14:26:40 <SamB_XP> @pl let f [] = []; f (x:xs) = (\[a,b] -> a ++ x:b) $ mapM ((f .) . filter) (map ($ x) [(>=),(<)]) xs in f
14:26:41 <lambdabot> (line 1, column 7):
14:26:41 <lambdabot> unexpected "["
14:26:41 <lambdabot> expecting pattern or "="
14:26:45 <glguy> fabiim: what are you trying to read it to?
14:26:52 <glguy> fabiim: it doesn't know
14:26:53 <ski> fabiim : it doesn't know what type to try to read as
14:27:04 <glguy> > read "123" :: Int
14:27:05 <lambdabot>  123
14:27:09 <glguy> > read "123"
14:27:10 <lambdabot>  Add a type signature
14:27:11 <fabiim> ohhh
14:27:17 <fabiim> ok
14:27:21 <ski> > read "123" :: Bool
14:27:23 <lambdabot>  Exception: Prelude.read: no parse
14:27:27 <monochrom> read "123" is very ambiguous.  how do I know you mean it to be List?
14:27:41 <Uccus> fabiim: read reads to _any_ type, you need to tell it what type you want
14:27:45 <dcoutts__> mgsloan: what patches are you sending us?
14:27:51 <fabiim> wait : how the hell the function read receives that?
14:28:06 <glguy> :t read
14:28:06 <ski> fabiim : return type overloading :)
14:28:08 <lambdabot> forall a. (Read a) => String -> a
14:28:12 <Uccus> fabiim: hehe.
14:28:21 <fasta> What does newListArray (1,10) (repeat 3) do?
14:28:39 <glguy> fasta: makes a new mutable array
14:28:43 <fabiim> cool ...
14:28:44 <glguy> indexes 1 though 10
14:28:47 <glguy> all elements 3
14:28:52 <glguy> ?type newArray
14:28:53 <lambdabot> Not in scope: `newArray'
14:28:55 <fasta> glguy: I mean whether it terminates
14:28:59 <glguy> fasta: sure
14:29:01 <monochrom> It does.
14:29:07 <fasta> glguy: and whether it crashes
14:29:08 <monochrom> You have my word for it.
14:29:08 <glguy> but : newArray (1,10) 3 might be better
14:29:13 <mgsloan> dcoutts - I made a cairo graphing demo, clarified/brought up to date INSTALL, and fixed calls to deprecated functions in the cairo demos - 3 seperate patches
14:29:34 <fasta> glguy: I know, but the actual case is of course more complicated
14:29:40 <dcoutts__> mgsloan: cool
14:30:03 * glguy &
14:30:15 <fasta> monochrom: thanks
14:32:27 <Uccus> @pl let f 0 = 1; f n = n * f (n - 1) in f
14:32:27 <lambdabot> ap (*) (ap id (subtract 1))
14:34:35 <Uccus> :t (>>=)
14:34:37 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
14:36:18 <mgsloan> dcoutts__ sent
14:39:25 <mgsloan> it awaits moderator approval though
14:40:00 <dcoutts__> mgsloan: ok, no problem, Axel will let it through soonish
14:41:22 <dcoutts__> mgsloan: or if you want it applied quicker (I think Axel might be away) you can use 'darcs send --to' and send it to me directly
14:42:53 <mgsloan> @gentoo.org ?
14:42:54 <lambdabot> Unknown command, try @list
14:43:45 <mgsloan> sent, anyway
14:49:09 <benomatic> dumb questions: list splitting and list concats (ie, x:xs and x ++ [y]) -- are these both O(1) operations in haskell?
14:49:14 <fabiim> i have a data type : data Actions = J String [(String,Agent)] , Agent is like : H Smart 12 ) i can read it easily (including list's of ) with read . How could i read  the Actions type? ( i have all them deriving from class Read .
14:49:59 <fabiim> would i need to declare instances of Read Actions ?
14:49:59 <Igloo> x ++ [y] is O(n) where n = length x
14:50:15 <benomatic> that's what i figured.  head list only.
14:51:09 * benomatic aware of the history of cons'ing, but not so much as to be sure of that query
14:51:36 <dcoutts__> mgsloan: patches look good, thanks very much. Now applied.
14:52:26 <dcoutts__> mgsloan: are you interested in updating the cairo package at all? It could do with updating to take advantage of the new features in cairo-1.2 (and perhaps even the upcomming 1.4 version)
14:53:20 <Uccus> fabiim: you there?
14:53:22 <dcoutts__> mgsloan: if you feel like helping out more in future that'd be cool, if so we can talk about what stuff there is to do, what's fun/interesting etc
14:53:50 <fabiim> Uccus : what?
14:54:23 <Uccus> use deriving
14:54:28 <Uccus> see if it works
14:55:44 <Uccus> fabiim: actually, I didn't get what you are asking for
14:56:41 <fabiim> i'm trying , but read " J "string" [("string" ,  Agent ) , ("string" , Agent) ] doesn't work
14:57:01 <sorear> ghci -e 'Array.array (0::Int,maxBound) [(1000000,0)]' -- this was discovered a day ago on #haskell, no EvilIx required
14:57:10 <fabiim> say's that `stringÂ´ is not in scope
14:57:35 <fabiim> i'm trying to convert a string  to my action type .
14:57:41 <Uccus> that's funny
14:58:07 <fabiim> would be , when it works
14:58:23 <Uccus> did you use escape characters?
14:58:29 <Uccus> are you using hugs?
14:58:47 <fabiim> no , ghci
14:59:20 <Uccus> can you cut and paste the exact expression you are feeding GHCi?
15:00:03 <fabiim> read "J  "ola"  [ ( "ola "  , H Forca 12  ) , ( "ola2 " , H Destreza 13 ) ]" :: [Accoes]
15:00:58 <Uccus> what does GHCi say about that?
15:01:12 <hyrax42> ?type either Nothing Just
15:01:12 <fabiim> data Accoes = J String [(String,Agent)]  ; data Agent = H Skill Int  ; both deriving read
15:01:13 <lambdabot>   Expecting a function type, but found `Maybe a'
15:01:13 <lambdabot>    Expected type: a -> c
15:01:31 <hyrax42> ?type either (const Nothing) Just
15:01:33 <lambdabot> forall a b. Either a b -> Maybe b
15:02:04 <fabiim> Not in scope: `ola' ... 3 of these errors , it's because of the "" right ?
15:02:10 <Uccus> exactly!
15:02:22 <fabiim> how make it work ?
15:02:30 <Uccus> you see, to put a quote sign inside quotes, you escape them
15:02:42 <Uccus> replace all " inside the quotes with \"
15:03:19 <Uccus> > read "something" :: String
15:03:21 <lambdabot>  Exception: Prelude.read: no parse
15:03:36 <fabiim> did that already , Exception : Prelude.read : no parse
15:03:38 <Uccus> > read "\"something\"" :: String
15:03:40 <lambdabot>  "something"
15:03:56 <Uccus> like what I did?
15:04:21 <fabiim> wait
15:04:41 <dibblego> > [10..1]
15:04:42 <lambdabot>  []
15:04:46 <dibblego> > [10, 9..1]
15:04:47 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
15:05:32 <fabiim> yes .
15:05:35 <fabiim> *Main> read "J  \"ola\"  [ ( \"ola \"  , H Forca 12  ) , ( \"ola2 \" , H Destreza 13 ) ]" :: [Accoes]
15:05:51 <fabiim> like that ?
15:05:58 <Uccus> urd
15:06:00 <Uccus> yes
15:06:56 <fabiim> exception : Prelude.read : no parse . That was when i tought that deriving wasn't enough . But that's strange .
15:08:06 <ctkrohn> hi, I have a function getClockTime :: IO ClockTime and another function toCalendarTime :: ClockTime -> IO CalendarTime.  I'd like to do toCalendarTime getClockTime, but the input types don't match up.
15:08:10 <ctkrohn> how can I get around this?
15:08:20 <ctkrohn> I'm pretty new to Haskell
15:08:27 <sorear> getClockTime >>= toCalendarTime
15:08:32 <sorear> :t (>>=)
15:08:33 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
15:08:35 <Uccus> read "Just [(\"how\", 0), \"come\", 1)]" :: Maybe [(String, Int)]
15:08:38 <ctkrohn> ok
15:08:48 <ctkrohn> that makes sense
15:08:52 <hyrax42> does toCalendarTime actually perform IO?
15:08:54 <Uccus> > read "Just [(\"how\", 0), \"come\", 1)]" :: Maybe [(String, Int)]
15:08:55 <lambdabot>  Exception: Prelude.read: no parse
15:09:04 <hyrax42> funciton name sounds like it could be pure
15:09:06 <sorear> doesn't it have to read locale files?
15:09:09 <ctkrohn> hyrax42: it depends on yourlocal time zone setting
15:09:09 <ctkrohn> yeah
15:09:13 <hyrax42> oh
15:09:15 <Uccus> > read "[(\"how\", 0), \"come\", 1)]" :: [(String, Int)]
15:09:16 <lambdabot>  Exception: Prelude.read: no parse
15:09:17 <hyrax42> did not realise
15:09:39 <Uccus> > read "[(0, 0), (0, 1)]" :: [(Int, Int)]
15:09:40 <lambdabot>  [(0,0),(0,1)]
15:10:03 <Uccus> > read "[(\"how\", 0), (\"come\", 1)]" :: [(String, Int)]
15:10:05 <lambdabot>  [("how",0),("come",1)]
15:10:20 <Uccus> > read "Just [(\"how\", 0), (\"come\", 1)]" :: Maybe [(String, Int)]
15:10:21 <lambdabot>  Just [("how",0),("come",1)]
15:10:36 <Uccus> seems to work fine here...
15:11:18 <hyrax42> > (>>= Just . show) $ Just 5
15:11:19 <lambdabot>  Just "5"
15:11:57 <yaxu> > foldl (++) "" $ map ( : "potato") "123"
15:11:58 <lambdabot>  "1potato2potato3potato"
15:12:24 <ski> Cale : Functor => Applicative => Monad
15:12:41 <yaxu> is that a reasonable potatoisation function?
15:12:56 <ski> (Cale : though something like JohnMeacham's "super-class" proposal would be nice)
15:13:20 <Uccus> ski: where did Meacham talk about it?
15:13:20 <fabiim> Uccus: sorry time wasted , I was giving him a wrong type
15:13:21 <fabiim> lol
15:13:28 <fabiim> thanks
15:13:29 <fabiim> =)
15:13:32 <Uccus> fabiim: no worries :)
15:13:45 <ski> > do x <- "123"; return x `mplus` "potato"
15:13:46 <lambdabot>  "1potato2potato3potato"
15:13:48 <hyrax42> > concatMap (:"potato") "123"
15:13:50 <lambdabot>  "1potato2potato3potato"
15:14:00 <Uccus> I was about to say, concatMap...
15:14:05 <hyrax42> > "123" >>= (:"potato")
15:14:07 <lambdabot>  "1potato2potato3potato"
15:14:13 <Uccus> but mplus is just wicked!
15:14:36 <Uccus> :t msum
15:14:37 <lambdabot> forall a (m :: * -> *). (MonadPlus m) => [m a] -> m a
15:14:55 * ski has used the list monad in a 'Show' instance to generate a string :)
15:14:57 <yaxu> my word
15:14:57 <hyrax42> aye mplus is a fun littl thing
15:15:29 <hyrax42> yaxu: Haskell, there's more than one way to do it ;)
15:15:53 <yaxu> but they're all provably the same?
15:16:05 <hyrax42> in this case, they all mean exactly the same thing
15:16:13 <Uccus> yes
15:16:20 <Uccus> "1potato2potato3potato"
15:16:23 <hyrax42> actually no, the mplus version works differently
15:16:27 <yaxu> ha
15:16:29 <hyrax42> but all produce the same result
15:16:34 <SamB_XP> really?
15:16:43 <allbery_b> just like perl, there's more than one way to do it.  and just like perl,most of them are incomprehensible to non-gurus :)
15:16:48 <hyrax42> SamB: no :(
15:16:51 <hyrax42> not really
15:16:54 <mgsloan> dcoutts__ - thanks.  I'll probably help out in the future as I plan to use cairo extensively.  Assuming I can get my head around writing real apps in haskell....
15:17:01 <ski> Uccus : http://repetae.net/john/recent/out/supertyping.html
15:17:03 <lambdabot> Title: Supertyping Suggestion for Haskell
15:17:13 <Uccus> thanks ski
15:17:43 <SamB_XP> about as different as [x]++ and x: are...
15:18:15 <hyrax42> SamB: yeah not very different
15:18:53 <ski>   instance Show Sudoku
15:18:54 <ski>     where
15:18:54 <ski>     show (Sudoku rows) = do
15:18:54 <ski>       row <- rows
15:18:54 <ski>       (do cell <- row
15:18:56 <ski>           maybe "." ((:[]) . intToDigit) cell
15:18:58 <hyrax42> ski, that sounds useful (?)
15:18:58 <ski>        `mplus`
15:19:01 <ski>        do "\n")
15:19:54 <yaxu> well concatMap seems the clearest to me as a non-guru
15:20:03 <Uccus> ski: how did it go with the proposal? did he implement it?
15:20:27 <Uccus> concatMap is clean, does what it says it does
15:20:28 <hyrax42> yaxu: when you get to it, the bind operator (>>=) for list monad is actually just (flip concatMap)
15:20:33 <ski> Uccus : not that i know .. maybe he plans to try it in his compiler
15:20:48 <ski> concatmap = (=<<)
15:20:50 <Uccus> sounds sensible enough
15:21:04 <Uccus> John's proposal, I mean
15:21:11 <hyrax42> yeah, it does
15:21:26 <yaxu> interesting
15:21:45 <hyrax42> ?where monads as containers
15:21:45 <lambdabot> http://www.nomaware.com/monads/html/index.html
15:21:48 <hyrax42> ?where mac
15:21:49 <lambdabot> I know nothing about mac.
15:21:59 * ski thinks 'foo >>= baz . bar' could be better written as 'baz . bar =<< foo' (or 'foo >>= bar >.> baz', given '(>.>) = flip (.)')
15:22:00 <hyrax42> ?wiki monads as containers
15:22:00 <lambdabot> http://www.haskell.org/haskellwiki/monads as containers
15:22:05 <hyrax42> gah
15:22:17 <jcreigh> @wiki MonadsAsContainers
15:22:17 <yaxu> i did want to map concatenations though, so concatMap seems a good choice :)
15:22:17 <lambdabot> http://www.haskell.org/haskellwiki/MonadsAsContainers
15:22:41 <jcreigh> http://www.haskell.org/haskellwiki/Monads_as_containers
15:22:42 <hyrax42> yaxu: see that link
15:22:43 <lambdabot> Title: Monads as containers - HaskellWiki
15:22:51 <jcreigh> bloody underscores. :)
15:22:58 <hyrax42> jcreigh: :)
15:23:11 <wolverian> hm, sather looks interesting.
15:23:20 <yaxu> hyrax42: seen before, but not read, will do that...
15:23:31 <hyrax42> yaxu: it's very good
15:23:43 <hyrax42> will take some time likely though
15:23:47 <hyrax42> or maybe not
15:24:49 <yaxu> i just read about monads in the new "programming in haskell" book, except hutton does a chapter on a parser monad and IO monad before using the word at all, and only then in passing...
15:25:13 <hyrax42> I have not seen this book
15:25:15 <yaxu> a good beginner's book imho
15:25:25 <hyrax42> is it online or published
15:25:40 <yaxu> published, but the first five chapters are online
15:25:49 <hyrax42> ooh, link?
15:25:53 <yaxu> one sec
15:26:31 <yaxu> http://www.cs.nott.ac.uk/~gmh/book.html
15:26:33 <lambdabot> Title: Programming in Haskell
15:26:39 <hyrax42> great many thanks!
15:26:41 <yaxu> he's taken the sample chapters online now its published :(
15:27:03 <hyrax42> oh that's annoying
15:27:29 <jcreigh> "offline"?
15:27:38 <yaxu> yes that
15:28:42 <hyrax42> I do auto-sense-making corrections
15:30:31 <yaxu> good thing i saved a copy
15:30:36 <jcreigh> heh
15:32:36 <monochrom> Cambridge University Press is a good publisher.  I have no moral problem paying them.
15:32:53 <mgsloan> I bet its possible to do some really cool undo/redo system with monads :)
15:33:37 <jcreigh> wayback machine for the win: http://web.archive.org/web/20060501035552/http://www.cs.nott.ac.uk/~gmh/book.html
15:33:41 <lambdabot> Title: Programming in Haskell, http://tinyurl.com/yhcmlr
15:33:45 <monochrom> Its books are also cheaper than other, overpriced publishers such as Springer, Prentice Hall, ...
15:33:52 <yaxu> monochrom: oh yes, i bought the book.  the pdf is only a preview of a few of the chapters
15:34:20 <ndm> i have heard good things about that book, from a few people
15:34:29 <ndm> does it have any advanced stuff in it?
15:34:33 <yaxu> the publish date isn't until mid january, but my pre-ordered copy arrived last week
15:34:45 <ndm> i know the wadler-bird book does
15:34:46 <hyrax42> yaxu: would you recommend that book to a beginner at haskell (though not at programming)
15:34:48 <hyrax42> as a good way to learn it
15:34:50 * monochrom is waiting 50 years for the copyright to be transferred to Dover. XD
15:34:57 <Uccus> it does?
15:35:13 <Uccus> the wadler-bird book intro to functional programming?
15:35:44 <ndm> from what i';ve been told "intro" is stetching it a bit, the guy sat next to me has a copy on his desk, and thats 2 years into a phd in FP
15:35:54 <yaxu> ndm: it depends what you mean by advanced, in terms of programming then yes, in terms of haskell then maybe no
15:36:02 <yaxu> hyrax42: yes definitely
15:36:16 <hyrax42> yaxu: thanks
15:36:19 <hyrax42> I will look over it
15:36:21 <Uccus> well neil, I've read that book
15:36:22 <dibblego> anyone used Scala?
15:36:51 <Uccus> dibblego: I've used Scala to write a pretty-HTML representation of .. erm .. Scala code
15:37:10 <dibblego> Uccus, care to take a look at a problem I have?
15:37:15 <dibblego> Uccus, http://rafb.net/p/5WkEjP92.html
15:37:16 <yaxu> hyrax42: speaking as an experienced programmer new to haskell and fairly new to functional programming
15:37:17 <lambdabot> Title: Nopaste - No description
15:37:32 <Uccus> ndm: it was from the Pre-Haskell era, right?
15:37:52 <ndm> Uccus: very much so, although apparently the monad stuff is quite deep - not read it myself
15:37:54 <lispy> dibblego: i've used scala
15:38:02 <lispy> dibblego: what's the problem?
15:38:07 <dibblego> lispy, http://rafb.net/p/5WkEjP92.html
15:38:08 <lambdabot> Title: Nopaste - No description
15:38:44 <Uccus> ndm: it had references. you know. ref boxes. that's very weird for a Haskell programmer. no monad. much ado about strictness.
15:39:05 <Uccus> ndm: well, I guess the times really have advanced
15:39:06 <ndm> Uccus: ok, maybe its a later edition my friend has
15:39:20 <lispy> dibblego: if you're going to program in scala you'll need to use scala idioms not haskell idioms :)
15:39:39 <dibblego> that's what I figured
15:39:47 <lispy> dibblego: and scala's oo is nothing to shy away from...it's quite well done except that traits have some gotchas
15:39:57 <Uccus> ndm: could be. UNSW poster sale had a booksale too. bought it for an amazing 50c. my tribute to Phil Wadler. :p
15:40:14 <dibblego> yes it does look pretty good from reading; I just want to make sure I am forced to do it this way
15:40:34 <lispy> dibblego: for example, if you have a base trait and two traits that inherint from it and both child traits are in the same class, then any state in the base trait only exists once in the objects
15:40:40 <ndm> Uccus: there are several editions, some are bird-wadler, some are only one of them, apparently the latest version is not the best, but neither is the earliest one - sometime around the middle they were best
15:40:41 <hyrax42> yaxu: thanks
15:40:53 <lispy> dibblego: ah, well i don't know scala well enough to judge if you're "forced"
15:41:06 <lispy> dibblego: i've only written about 1000 lines
15:41:24 <dibblego> I wish Haskell compiled to the JVM neatly
15:41:34 <hyrax42> a professor of mine is thinking of switching his languages course from SML/Scheme to Haskell(/Scheme?) so I was just wondering what sort of nice texts of that sort there are
15:41:49 <SamB_XP> hyrax42: texts?
15:41:52 <SamB_XP> what is a text?
15:41:59 <Uccus> dibblego: I just wish Haskell compiler to JVM preserving as much _structure_ as possible
15:42:02 <ndm> dibblego: Yhc has the ability to be run on teh JVM, and compiles to the .NET
15:42:10 <dibblego> hyrax42, I strongly recommend Simon Thompson for that kind of thing
15:42:15 <lispy> dibblego: look at that business objects language
15:42:17 <ndm> although it is something that needs going over
15:42:22 <hyrax42> SamB_XP: frequently used for "textbook" no?
15:42:25 <lispy> dibblego: maybe it wal called cal?
15:42:28 <SamB_XP> what is that?
15:42:30 <yaxu> hyrax42: they'd probably enjoy the online powerpoint slides for that hutton book then :)
15:42:43 <ndm> hyrax42: the new Graham Hutton one is what seems to be the way forward
15:42:51 <lispy> dibblego: they took haskell and modified it so that it made sense to be able to link it with java and run it on the jvm
15:43:13 <dibblego> ndm, I'll have to wait until Yhc can compile to the JVM cleanly
15:43:16 <lispy> dibblego: it doesn't have as much syntatic sugar as haskell but apparantly the semantics are pretty similar
15:43:20 <Uccus> Simon Thompson has a book (available online) called 'Type Theory and Functional Programming'. it took me a while to recover from that book.
15:43:22 <ndm> dibblego: prepare to wait a while...
15:43:30 <dibblego> lispy, yes, that's exactly what I think of it
15:43:42 <dibblego> ndm, I am prepared; so prepared I am learning Scala in the meantime :)
15:43:51 <hyrax42> dibblego: I'm not sure.  The goal would be to get a core level of haskell quickly and then move to writing monadic interpreters
15:43:52 <ndm> (although it is on my list of things to do, perhaps for bhc rather than yhc)
15:43:53 <hyrax42> I think
15:44:10 <lispy> dibblego: F# is another option if the CLR is just as viable as JVM
15:44:26 <dibblego> yeah, but it's not - the JVM is crucial
15:44:33 <dibblego> Scala apparently has some CLR support
15:44:39 <lispy> it used to
15:44:50 <lispy> but apparantly scala 2.x doesn't run on CLR yet
15:45:05 <hyrax42> anyway I'll take a look at both books
15:45:18 <lispy> but, scala _is_ i nice language...(but some things seem really broken to me, like traits)
15:45:23 <dibblego> hyrax42, http://www.cs.kent.ac.uk/people/staff/sjt/craft2e/
15:45:25 <lambdabot> Title: Haskell: The Craft of Functional Programming, Second Edition
15:45:40 <hyrax42> dibblego: aye, I'm there
15:45:42 <lispy> the only use i found for traits was implementing the strategy pattern...but with functional programming you don't usually need that pattern
15:46:05 <fasta> lispy: aren't traits in Haskell broken too?
15:46:12 <dibblego> hyrax42, a good beginner book assuming no prior knowledge (Java/C means no prior understanding of computer programming to me)
15:46:15 <hyrax42> but the course is less a funtional programming course than a programming languages and paradigms (the tile of it, in fact) course
15:46:23 <lispy> fasta: i've never heard of traits in terms of haskell :)
15:46:28 <deadbeef> hi guys
15:46:31 <deadbeef> marry xmas
15:46:37 <dibblego> s/traits/typeclasses ?
15:46:43 * dibblego marries xmas
15:46:46 <deadbeef> (ho ho ho)
15:46:53 <fasta> lispy: C++ traits can be emulated with fundeps
15:47:07 <fasta> lispy: it's just an ugly solution
15:47:18 <lispy> i don't remember if C++ traits are the same as scala traits
15:47:23 <dibblego> I think I will just read some Scala source
15:47:29 <lispy> in scala a trait is a partilaly implemented interface
15:47:50 <lispy> and there is some support for choosing your traits at instantiation time
15:47:56 <lispy> so you can "mix" them together
15:48:03 <dibblego> Scala has mixins as well
15:48:20 <fasta> mixins mean at least three different things
15:48:24 <lispy> i thought traits in scala were exactly what they call mixins?
15:48:46 <lispy> yeah, i've heard CLOS has mixins too via method combination
15:48:52 <dibblego> well, I'm a bit confused on that myself - I have read sections called "Traits" and sections called "Mixins" but they seem to describe the same thing
15:48:59 <lispy> but i would never think to call method combination a mixin
15:49:37 <Uccus> well personally I think Scala is interesting because of the platforms it targets
15:49:40 <fasta> The C++ definition of a mixin is a class which has two super classes that both implement some member function of the same virtual base class.
15:49:42 <dibblego> "To deï¬ne a class that can be used as a mixin we use the keyword trait."
15:49:55 <dibblego> I love it when my confusion is solved by something even simpler
15:49:57 <Uccus> not because of the language design
15:50:10 <dcoutts__> mgsloan: great. The main thing with the cairo binding is to get the ps and pdf bits working properly, it should provide a great way to do printing via the same api as on screen or to bitmap, there's an svg backend too now. :-)
15:50:16 <Uccus> both C# and Java are headed directly towards where Scala is now...
15:50:21 <lispy> Uccus: wouldn't that reasoning make java interesting?
15:50:28 <lispy> ah
15:50:29 <lispy> yeah
15:50:44 <lispy> is it java 1.8 that will have closures
15:50:50 <Uccus> yeah
15:50:53 <dibblego> 7
15:51:11 <Uccus> did you see Ralf's paper? on planet.haskell.org?
15:51:15 <dibblego> I sure hope things have moved on by then
15:51:18 <fasta> lispy: ? You can already create closures in Java.
15:51:33 <lispy> fasta: not lexical closures though
15:51:43 <allbery_b> more likely it'll have something almost but not quite like clusures.  (see also Java "generics")
15:51:45 <lispy> not proper ones
15:52:04 <dibblego> http://www.javalobby.org/java/forums/m92103961.html#92103961 (nonsense)
15:52:04 <Uccus> lispy: what do you mean 'proper ones'?
15:52:08 <lispy> allbery_b: the proposal i saw was pretty well thought out and allowed some really nice things
15:52:09 <fasta> lispy: I am not too much into Java, but can't you nest anonymous classes?
15:52:23 <monochrom> Will Java 1.8 be called Java 8? XD
15:52:46 <lispy> Uccus: scheme and haskell (as examples) have proper closures, they capture all the free variables lexically
15:52:54 <monochrom> Every programming language evolve to Haskell.
15:53:03 <Uccus> hear! hear!
15:53:04 <mgsloan> dccoutts__ - ah, yeah, I know the guy working on that using cairo for inkscape pdf output :)
15:53:10 <dibblego> fasta, an anonymous class must exist within a method and it has limitations
15:53:19 <Uccus> lispy: what does it mean to capture free variables lexically?
15:53:22 <lispy> monochrom: yeah, sun likes to do that confusing thing with the naming, see SunOS vs. Solaris
15:53:26 <dibblego> s/method/method\/constructor\/initialiser
15:53:47 <monochrom> Slowaris is a good name. :)
15:53:50 <lispy> Uccus: i'm not a good person to explain this
15:54:03 <lispy> Uccus: but it's usually discussed in scheme tutorials when you get to closures
15:54:08 <Uccus> lispy: because this is something I sumble upon time to time
15:54:15 <yaxu> hah, 39 lines of java in 3 lines of haskell
15:54:35 <Uccus> lispy: but Scheme tutorials won't show me the difference, will it? :)
15:54:40 <lispy> yaxu: your haskell implementation could probably be shortened then ;)
15:54:43 <dibblego> yaxu, 50 lines of Java in 1 line of Haskell http://blog.tmorris.net/maybe-in-java
15:54:44 <lambdabot> Title: Î» Tony&#8217;s blog Î» Â» Blog Archive Â» Maybe in Java
15:55:13 <dibblego> lispy++
15:55:14 <Uccus> yaxu: it's not the line count, it's the Way of Thinking that counts
15:55:28 <lispy> Uccus: maybe this would help? http://www.perl.com/doc/FAQs/FAQ/oldfaq-html/Q4.3.html
15:55:30 <lambdabot> Title: Perl FAQ 4.3: What's the difference between dynamic and static (lexical) scoping ...
15:55:37 <dibblego> or the 'systematic method of reasoning and required spatial ability'
15:55:54 <Uccus> yaxu: Haskell is getting higher and higher order day by day... it's hard to keep up for me... I cannot even count to infinity yet
15:56:37 <wolverian> lispy, you probably want to link to http://perldoc.perl.org/perlfaq7.html#What%27s-the-difference-between-dynamic-and-lexical-%28static%29-scoping%3F--Between-local%28%29-and-my%28%29%3F
15:56:40 <lambdabot> Title: perlfaq7 - perldoc.perl.org, http://tinyurl.com/qmymq
15:56:42 <wolverian> (eep, nice url)
15:56:52 <yaxu> lispy: is that an offer? :)
15:56:55 <Uccus> lispy: that only explains lexical scoping.
15:57:02 <lisppaste2> yaxu pasted "peano curve lsystem" at http://paste.lisp.org/display/33304
15:57:22 <wolverian> Uccus, see my link, which also explains dynamic scoping.
15:57:25 <wolverian> (succintly.)
15:57:35 <wolverian> (wait, why are we discussing perl here? :)
15:57:56 <fasta> Haskell evolves to Perl ;)
15:57:58 <lispy> Uccus: once a free variable has been capture in a lexical sense it cannot be modified outside of the closure that captures it, but if it's dynamic then it can be modified outside it...that's a poor way of saying it in a nutshell
15:58:04 <Uccus> only because I don't know what a closure is
15:58:23 <allbery_b> pugs is written in haskell, what's the problem? :)
15:58:24 <fasta> lispy: then Scheme has no real lexical closures.
15:58:32 <wolverian> Uccus, http://perldoc.perl.org/perlfaq7.html#What%27s-a-closure%3F
15:58:33 <lambdabot> Title: perlfaq7 - perldoc.perl.org
15:58:38 <wolverian> (yes, perlfaq has everything)
15:58:57 <Uccus> lispy: which ones are the proper closures then?
15:58:58 <mauke> lispy: that sounds wrong
15:59:39 <Uccus> the lexically captured ones or the dynamic ones?
15:59:44 <lispy> mauke, fasta: you guys are free to explain it better...i said i didn't want to try :)
16:00:15 <fasta> lispy: yes, it's hard to explain completely correct.
16:00:32 <fasta> lispy: that's why people write books
16:00:45 <dibblego> I disagree; that's not why they write them
16:01:12 <monochrom> that's why people write blogs
16:01:26 <fasta> monochrom: I wanted to say that first ;)
16:01:27 <mgsloan> that's why people write emails
16:01:51 <fasta> s/books/anything with more space than IRC
16:02:29 <lispy> http://en.wikipedia.org/wiki/Scope_(programming)#Static_versus_dynamic_scoping
16:02:31 <Uccus> okay, I understand the *difference* but it's the *terminology* that got me
16:02:32 <lambdabot> http://tinyurl.com/y898xa
16:03:07 <Uccus> so a lexical closure is a function whose variables *cannot* be changed from the outside?
16:03:21 <lispy> in current java, and i don't now a good example or all the details because i don't use java much, you can do weird things with scope and innerclasses and anonymous classes
16:03:23 <mauke> I only know how perl does it
16:03:35 <Uccus> in Groovy (think of it as an imaginary language)
16:03:42 <Uccus> var sum = 0
16:04:09 <Uccus> col.each(x -> sum += x)
16:04:22 <Uccus> which is supposed to add the numbers in col
16:04:26 <dibblego> a local inner class can access external locals if they are declared final (write-once)
16:04:41 <Uccus> is that a closure?
16:04:51 <lispy> not a proper one ;)
16:04:52 <mauke> if -> constructs a function, yes
16:04:56 <monochrom> (x -> sum += x) is a closure
16:05:02 <Uccus> ya Allah
16:05:06 <Uccus> (oh God ;))
16:05:11 <jcreigh> when we say talk about variables that can't be changed, do we mean: a) Variables that can't be made to point to a different object or b) The object being pointed to can't be changed.
16:05:31 <dibblego> jcreigh, we contradict ourselves immediately, "variables that cannot vary"? a absurdity
16:05:42 <dancor> what is showsPrec for
16:05:50 <lispy> precedence
16:05:55 <monochrom> for building show
16:06:00 <mauke> variables don't, constants aren't
16:06:06 <lispy> iirc, it has something to do with putting parens around nested parts
16:06:12 <dibblego> a common myth among the Java community is that final locals can never change; they are in fact, write once
16:06:12 <Uccus> dibblego: take it easy. Haskellers haven't come up with a better word yet.
16:06:26 <Korollary> Variables do vary in haskell
16:06:39 <dibblego> variables do not vary in English
16:06:39 <jcreigh> Well, in scheme there's, eg, set-car!
16:06:46 <lispy> dibblego: well, and say they are holding a pointer to an object, you can aks the object to mutate itself without violating final
16:06:55 <dibblego> er, other way around
16:07:03 <monochrom> there is no change
16:07:15 <mauke> panta rhei
16:07:15 <Uccus> lispy: what's a proper closure?
16:07:38 <dibblego> lispy, that's just a perspective; you're free to put yourself in a position to reason about it in such a way that you're actually describing monad bind; in fact, that's what Java programmers inadvertently do if you ask them to describe the operation
16:07:41 <lispy> Uccus: oh, i thought i said already...like in scheme and haskell where they are lexical
16:07:47 <dancor> so showsPrec take an integer and your type and a string
16:07:55 <dancor> what is the integer
16:08:06 <dancor> a level of depth
16:08:07 <dancor> ?
16:08:08 <monochrom> the integer is the precedence level of the surrounding context
16:08:29 <Uccus> that would mean... (\x -> x + y) is a closure?
16:08:38 <dancor> this all seems very hidden-contract to me
16:08:42 <monochrom> (\x -> x + y) is a closure
16:08:42 <lispy> Uccus: my reasoning is that with a lexical scope you can reason about what's in the closure when you're looking at the source code...instead of having to run the program
16:08:48 <dancor> maybe if i knew the contract i would feel better
16:08:51 <Uccus> x is certainly lexically bound
16:09:01 <Korollary> "Variables" in lambda calculus refer to symbols in an expression. They have "bindings". In imperative languages, people think variables refer to things whose values can be changed. That's not entirely correct.
16:09:10 <mauke> Uccus: if y is an outer lexical, yes
16:09:13 <jcreigh> monochrom: or possibly a parse error. :)
16:09:23 <monochrom> Perhaps dancor just needs better doc.  I recommend Hudak's SOE, explains it all.
16:09:30 <dibblego> Korollary, it's not correct in lambda calculus, bit it is correct, since English said
16:09:47 <dibblego> Variable \Va"ri*a*ble\, n.   1. That which is variable; that which varies, or is subject to change.
16:09:55 <lispy> > let {y = 1; foo x = x + y} in foo 2
16:09:56 <dibblego> how can you argue against that!?
16:09:57 <lambdabot>  3
16:09:58 <Korollary> dibblego: They do vary. Their bindings are not constant.
16:10:18 <dibblego> "In imperative languages, people think variables refer to things whose values can be changed." -- they are right?
16:10:29 <lispy> in that example, foo captures y
16:10:42 <Korollary> So if you look at a mathematical expression ax + b, do you call x a variable because its value can be anything, or a constant because it has a single value that doesn't change?
16:10:47 <dibblego> I don't see how they are wrong, unless the dictionary is wrong
16:11:02 <SamB_XP> I once asked a mathemetician the difference between a variable and a constant
16:11:08 <dibblego> I understand the mathematical expression
16:11:14 <SamB_XP> I don't remember what he said though ;-)
16:11:38 <sorear> Let's just stop this whole issue and eliminate the naming problem.  I propose "gnaarblots".
16:11:43 <jcreigh> I know it's probably not "correct", but I refer to the pattern matches like "x" in "f x = x * x" as "variables". But what else what you call them?
16:11:43 <EvilRanter> SamB: constants aren't and variables don't?
16:11:55 <wolverian> jcreigh, parameters
16:12:03 <SamB_XP> well, he might have said something like "point of view"
16:12:05 <monochrom> "variables can change" this is right if you accept change.  most people accept change.  but change is an illusion.
16:12:09 <lispy> SamB_XP: that's a tough question...even 1, a constant, can have different representations and meanings depending on context :)
16:12:12 <dibblego> monochrom++
16:12:14 <SamB_XP> but then again maybe *I* proposed that
16:12:19 <Uccus> lispy: foo "captures" y,... means foo can "refer" to y because they are lexically... erm... close?
16:12:22 <dibblego> SamB, that's what the mathematician said :)
16:12:27 <EvilRanter> in haskell, everything is a function, jcreigh :P
16:12:41 <lispy> Uccus: basically yeah
16:12:41 <EvilRanter> (albeit sometimes a function of no arguments)
16:12:48 <dcoutts__> well, everything is a value and functions are values
16:12:52 <nornagon> foo = 1 -- a function
16:12:57 <dibblego> change requires time and time is an illusion
16:13:05 <mauke> lunchtime doubly so
16:13:07 <augustss> there is a difference between a variable and a constant? :)
16:13:13 <lispy> Uccus: in lisp (for example) y wouldn't have to be in scope when i define foo, but later i could give it a value and then call foo and foo would work...and then i could change y and call foo again to get a new value
16:13:14 <nornagon> mauke: :)
16:13:15 <SamB_XP> augustss: not really, no
16:13:22 <Korollary> The variable vs constant distinction exists in logic as well. You specify your constants explicitly.
16:13:23 <sorear> f(x) = blah -- every algebra text I've seen calls x an "Independant variable"
16:13:41 <dibblego> sorear, I have seen 'free variable'
16:13:45 <Uccus> lispy: that's outrageous
16:13:52 <lispy> Uccus: that's dynamic scope
16:13:58 <mauke> that's global variables
16:14:11 <EvilRanter> ...that's why i use scheme over lisp
16:14:39 <Uccus> if I understand correctly
16:14:45 <SamB_XP> EvilRanter: that doesn't happen in scheme?
16:14:51 <Uccus> none of the modern languages suffer from this disease
16:14:56 <Korollary> scheme doesnt have dynamic scoping.
16:14:57 <mauke> who invented "dynamic scope"? lispers?
16:15:09 <Uccus> none of those after ISWIM...
16:15:09 <Korollary> lisp had it by accident
16:15:16 <augustss> dynamic binding is nasty, even if you can make sense of it (like the dynamic binding in ghc)
16:15:25 <SamB_XP> Uccus: it works in Python...
16:15:34 <mauke> (because I think "dynamic scope" isn't actually a scope, and the name is stupid)
16:15:37 <wolverian> Uccus, perl allows explicit dynamic scoping too.
16:15:59 <Korollary> mauke: you can't go wrong with the word "dynamic", though. Would you like some dynamic eggnog?
16:16:08 <Uccus> well, as I understand it
16:16:17 <Uccus> lisp had it by chance
16:16:20 <SamB_XP> Korollary: wouldn't you like some dynamic typing?
16:16:28 <augustss> i think plenty of languages after lisp have had dynamic binding.  if you implement a language with first class function and don't know what you are doing it's easy to end up with dynamic binding
16:16:30 <Korollary> SamB_XP: Oh yes please!
16:16:33 <Uccus> someone pointed it out, and so the term was invented, am I right?
16:16:33 <EvilRanter> samB, scheme uses lexical scoping
16:16:47 <SamB_XP> EvilRanter: oh really?
16:16:56 <wolverian> yes, really.
16:16:57 <augustss> yep
16:17:00 <augustss> really
16:17:01 <lispy> Uccus: i'm pretty sure anonymous classes effectively have dynamic scope in certain situations
16:17:03 <dylan> (define x 10) (define (foo y) (+ x y)) (define x 25) (foo 10)
16:17:04 <SamB_XP> what happens if I define two mutually recursive functions seperately?
16:17:07 <monochrom> By the time of modern logic (19th century), "variable" has lost its change; it means "place holder".
16:17:08 <lispy> Uccus: in java i mean
16:17:26 <wolverian> dylan, I looked at that line and thought "but.. they didn't use sexprs in dylan!"
16:17:29 <EvilRanter> samb, you can't. i think you have to use (letrec ...)
16:17:29 <mauke> "dynamic scoping" is probably a special case of lexical scoping
16:17:43 <SamB_XP> EvilRanter: that sounds terribly inconvenient!
16:17:57 <EvilRanter> i can't remember the details, i may be wrong...
16:18:24 <Uccus> monocrom: in my sleep, I invented a word for "variable", thought I might share it with you guys
16:18:28 <Korollary> you have to lambda lift them
16:18:30 <Uccus> it's "pronoun"
16:18:42 <monochrom> YES!
16:19:03 <mauke> heh, that reminds me of perl/larry wall
16:19:04 <lispy> well, i should probably go xmas shoping before things close
16:19:07 <monochrom> "Let x,y,z,... be an infinite supply of pronouns..."
16:19:10 * lispy &
16:19:18 <Uccus> doesn't it does beautiful?
16:19:26 <monochrom> YES!
16:19:36 <Uccus> let's adopt it!
16:19:49 <augustss> yes, and confuse every one!
16:19:57 <dylan> I once implemented a very . . . weird variant of lexical scoping
16:20:03 <Uccus> imagine how lucid it is to a newbie
16:20:06 <Korollary> we confuse everyone anyway
16:20:16 <wolverian> return him = "bad dog"
16:20:20 <Uccus> f n = n + 1
16:20:26 <SamB_XP> oh, so now I have to call my variables "him", "her", "it", "I", "me", "myself", and "bob"?
16:20:31 <Uccus> now, this n, here... it's a number
16:20:31 <mgsloan> yeah, might as well confuse them with words that didn't come from category theory...
16:20:42 <monochrom> It's right on.  Consider: "every dog obeys its owner" = forall d. d `obeys` owner(d)
16:20:43 <Korollary> there are a lot of variables already called it. They're usually stl iterators.
16:20:46 <Uccus> but not any specific number, it sort of, stands for a number
16:21:00 <dylan> or, rather, I had the world's slowest lexical scoping.
16:21:00 <mauke> Perl's $_ is sometimes called "it"
16:21:17 <Uccus> so it's not a "proper" noun, like 3, it's a pronoun... it stands for another number
16:21:20 <Uccus> I love it!
16:21:24 <monochrom> "variable" is really a historical choice, not well-thought.
16:21:24 <augustss> I think "it" should refer to the last mentioned variable
16:21:29 <dylan> people that don't like perl call it $hit. (but I like perl :)
16:21:35 <mauke> augustss: no, to the current "topic"
16:21:40 <Korollary> "it" should refer to really hot variables
16:21:41 <mbishop> sml uses 'it' in the repl
16:21:46 <allbery_b> so, so now it's applescript?
16:21:48 <SamB_XP> augustss: that would be pretty useless
16:21:56 <Uccus> so you see? they are "pronouns" :)
16:21:59 <mauke> (you can set the current topic in perl with "for")
16:21:59 <augustss> x * it, instead of x*x :)
16:22:04 <SamB_XP> > \x -> x x
16:22:04 <lambdabot>    Occurs check: cannot construct the infinite type: t = t -> t1
16:22:04 <lambdabot>    Expe...
16:22:11 <Uccus> [monochrom, a bit support here!]
16:22:12 <mauke> for ($x) { $_ *= 2; $_ += 1; } # etc
16:22:16 <SamB_XP> I mean, about the only thing you could say is "x it"
16:22:28 <SamB_XP> (involving "it")
16:22:42 <SamB_XP> and that often doesn't make sense
16:22:45 <SamB_XP> id id
16:22:49 <SamB_XP> > id id
16:22:50 <lambdabot>  Add a type signature
16:22:58 <SamB_XP> well. rarely it works ;-)
16:23:11 <augustss> SamB_XP: hmmmm, you have a point
16:23:29 <augustss> SamB_XP: if x then it else False
16:23:39 <SamB_XP> hmm, you cheated
16:23:43 <SamB_XP> you used a construct!
16:23:45 <mauke> that's equivalent to x
16:23:53 <mgsloan> yeah, haskell's damn elegance gets in the way of the usefulness of it
16:24:03 <SamB_XP> mgsloan: ;-P
16:24:06 <monochrom> It is practical to talk of "variables" as change in physics and calculus for physics, since change is still the most intuitive to most people, no matter how little ground it has.
16:24:08 <augustss> id x = it
16:24:22 <SamB_XP> hmm.
16:24:41 <SamB_XP> it makes sense to talk about variables
16:24:43 <Uccus> specially bound variables
16:24:48 <augustss> I admit that it's usefulness is limited
16:24:51 <Korollary> how about let (x:xs) a = if a then it else they
16:24:55 <monochrom> But already in my first probability class in highschool, the first sentence my teacher said was, "a random variable is a FUNCTION, the name is misleading".
16:25:12 <Uccus> I guess you guys are getting the wrong idea here
16:25:17 <SamB_XP> the only thing is that variables and constants are not really so different...
16:25:25 <SamB_XP> er.
16:25:30 <SamB_XP> the difference is subjective usually...
16:25:37 <Uccus> the idea is to rename "variable" (which doesn't vary) to "pronoun"
16:25:54 <augustss> If Integers are female and booleans are male we can use he and she as well
16:26:03 <Uccus> emphasizing linguistics rather than maths
16:26:08 <Korollary> let's redefine variable in english instead
16:26:15 <mauke> or we could use $ for single values ("scalars") and @ for arrays
16:26:27 * mbishop laughs at mauke
16:26:41 <SamB_XP> mauke: we alrady use $ for TH *and* application, and @ for subpatterns
16:26:46 <Uccus> oh God
16:26:47 <monochrom> I use "this guy" for numbers and sets all the time, and "it" for people all the time.
16:26:58 <mauke> SamB_XP: not in perl :-)
16:27:01 <Uccus> when talking
16:27:23 <mgsloan> if he then she else it
16:27:33 <Uccus> aarrrggghhh!
16:27:37 <Uccus> cya guys
16:27:40 <augustss> hmmm, is that type correct?
16:27:43 <jcreigh> mauke: that's ridiculous. Next thing you'll be saying we should use % as shorthand for Data.Map...
16:27:45 <monochrom> E.g., you: "... f(x+y)..." me: "who is f?" |  you: "SPJ is a cool guy" me: "what is SPJ?"
16:27:49 <Uccus> it was nice to talk to you
16:27:55 <monochrom> I do that on purpose. :)
16:28:00 * Korollary waves
16:28:16 <mauke> jcreigh: and & for functions!
16:28:20 <mgsloan> augustss: should be - it == she, so the whole expr == she
16:28:38 <jcreigh> mauke: again, that would *never* fly in a real language. :)
16:28:58 <monochrom> like perl?
16:29:02 * monochrom ducks
16:29:08 <augustss> mgsloan: ah, so it is polymorphic :)
16:29:42 <mgsloan> yes, it is.
16:29:48 <wolverian> jcreigh, the visual indication is nice.
16:29:57 <wolverian> (once you get past the "whoa that's ugly" thing)
16:30:03 <mauke> ObPerl: http://mauke.ath.cx/stuff/perl/add.pl
16:30:38 <wolverian> @karma+ mauke
16:30:38 <lambdabot> mauke's karma raised to 6.
16:31:04 <nornagon> @karma+ nornagon
16:31:05 <lambdabot> You can't change your own karma, silly.
16:31:13 <nornagon> darn :)
16:31:23 <mbishop> @karma+ nornagon
16:31:24 <lambdabot> nornagon's karma raised to 1.
16:31:27 <mbishop> :P
16:31:35 <nornagon> :)
16:31:36 <mbishop> +1 for effort :P
16:33:40 <ski> i wonder if one could say that variables in physics are things that depend on "dynamically scoped" variable
16:33:58 <ski> position :: (?time :: Real) -> Pos
16:34:07 <SamB_XP> no...
16:34:13 <ski> (s/->/=>/)
16:34:20 <jcreigh> Is it possible to say something like "type (MonadPlus m) => Matcher = Match -> m Match". I'm starting to think it's impossible, because if you have, eg, "f :: Char -> Matcher" that doesn't actually *say* what the type of f is. There'd be no way for the compiler to infer the type of "f 'x'". Is this correct?
16:34:24 <SamB_XP> variables in physics depend on smart people
16:34:35 <SamB_XP> to sort them out
16:35:17 <mauke> the type of f 'x' should be forall m. (MonadPlus m) => Match -> m Match
16:36:21 <dancor> what the coolest way to do e.g.  f 3 [1,2,3,4,5,6,7] = [[1,4,7],[2,5],[3,6]]
16:36:40 <dancor> i feel like that is or is the inverse of some standard fcn
16:37:47 <jcreigh> mauke: hmm, that's true. Does that mean that you can reference type classes in a type synonym? If so, how?
16:38:09 <wolverian> hm, got a 4/5 on my introduction to FP course. should have returned more homework :)
16:38:16 <wolverian> ('twas haskell so it was easy.)
16:39:50 <dancor> does anyone ever think it's silly to type fcn names twice
16:40:18 <jcreigh> dancor: what do you mean?
16:40:21 <dancor> why not  f n l :: Int -> [a] -> [a] = ...
16:40:30 <jcreigh> oh
16:40:44 <nornagon> ew
16:40:45 <dancor> duplication is wrong
16:40:45 <ski> > let grab n = reverse . foldr (\x (ys:yss) -> yss ++ [x:ys]) (replicate n []) in grab 3 [1,2,3,4,5,6,7]
16:40:47 <lambdabot>  [[1,4,7],[2,5],[3,6]]
16:40:55 <jcreigh> because "f n l" has type [a], not "Int -> [a] -> [a]", perhaps?
16:41:08 <nornagon> dancor: you don't actually need to specify the type
16:41:13 <nornagon> most of the time
16:41:16 <nornagon> so, like
16:41:18 <nornagon> don't
16:41:19 <nornagon> if it bothers you
16:41:30 <dancor> nornagon: yeah if you like impossible ghc (pre-)debugging
16:41:43 <nornagon> :)
16:42:05 <dancor> "something is wrong.  here is a mess of letters that we call an error _mess_age"
16:43:37 <jcreigh> dancor: I don't think that kind of duplication is wrong. I mean, the name of the function is duplicated where it's defined and where it's called. Are you going to try to get rid of that, too? ;)
16:44:21 <nornagon> i wonder
16:44:29 <nornagon-> @karma+ nornagon
16:44:30 <lambdabot> nornagon's karma raised to 2.
16:44:35 <nornagon-> huh.
16:44:38 <nornagon-> @karma- nornagon
16:44:38 <lambdabot> nornagon's karma lowered to 1.
16:44:51 <mauke> omghax
16:45:03 <sorear> yeah, there are *lots* of ways around that...
16:45:14 <jcreigh> nornagon++ Clever. :)
16:45:21 <wolverian> @karma nornagon
16:45:21 <lambdabot> nornagon has a karma of 2
16:45:31 <wolverian> ah, it notices foo++ now
16:45:32 <nornagon> :)
16:45:41 <sorear> @karma
16:45:41 <lambdabot> You have a karma of 6
16:45:43 <sorear> sorear++
16:45:45 <sorear> @karma
16:45:45 <lambdabot> You have a karma of 6
16:45:46 <nornagon> @karma wolverian
16:45:46 <lambdabot> wolverian has a karma of 3
16:45:47 <dancor> jcreigh: but if you had to type it 3 times to define it, would that be too many
16:45:56 <nornagon> wolverian+=1
16:46:00 <dancor> jcreigh: why is 2 not too many
16:46:00 <nornagon> @karma wolverian
16:46:01 <lambdabot> wolverian has a karma of 3
16:46:02 <sorear> nice try
16:46:20 <wolverian> heh
16:46:29 <nornagon> darn :)
16:47:23 <dancor> @karma
16:47:23 <wolverian> wolverian = succ wolverian -- cough
16:47:23 <lambdabot> You have a karma of 0
16:47:48 <nornagon> wolverian: heh
16:49:02 <mauke> > let wolverian = succ wolverian in wolverian
16:49:04 <lambdabot>  Add a type signature
16:49:33 <wolverian> > let f = succ f in f :: Int
16:49:35 <lambdabot>  Exception: <<loop>>
16:49:46 <wolverian> infinite karma
16:49:57 <twanvl> undefined karma
16:50:15 <nornagon> > let f n = succ $ f n in f 0
16:50:15 <wolverian> @karma bottom
16:50:15 <lambdabot>  Add a type signature
16:50:16 <lambdabot> bottom has a karma of 0
16:50:17 <sorear> ?karma+ wolverian 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
16:50:17 <lambdabot> wolverian's karma raised to 4.
16:50:34 <sorear> ?karma- wolverian
16:50:35 <lambdabot> wolverian's karma lowered to 3.
16:50:42 <sorear> ?help karma+
16:50:43 <lambdabot> karma+ <nick>. Increment someone's karma
16:50:44 <nornagon> > let f n = succ $ f n in f 0 :: Ith
16:50:45 <lambdabot>  Not in scope: type constructor or class `Ith'
16:50:46 <nornagon> er
16:50:49 <nornagon> > let f n = succ $ f n in f 0 :: Int
16:50:50 <lambdabot>  Exception: <<loop>>
16:53:20 <mgsloan> ?karma
16:53:20 <lambdabot> You have a karma of 0
16:53:32 <mgsloan> > print "mgsloan++"
16:53:34 <lambdabot>  <IO ()>
16:53:45 <mgsloan> > "mgsloan++"
16:53:46 <lambdabot>  "mgsloan++"
16:53:53 <mgsloan> ?karma
16:53:53 <lambdabot> You have a karma of 0
16:54:34 <mgsloan> ?echo mgsloan++
16:54:34 <lambdabot> echo; msg:IrcMessage {msgPrefix = "mgsloan!n=michael@c-24-18-43-240.hsd1.wa.comcast.net", msgCommand = "PRIVMSG", msgParams = ["#haskell",":?echo mgsloan++"]} rest:"mgsloan++"
16:54:40 <sorear> ?msg lambdabot ?msg #haskell mgsloan++
16:54:42 <fabiim> how do i do a map with read? I'm trying map ( read :: Accoes )  but i get type error ...
16:54:57 <sorear> ?msg #haskell mgsloan++
16:54:57 <lambdabot> mgsloan++
16:55:03 <mgsloan> ?karma
16:55:03 <lambdabot> You have a karma of 0
16:55:06 <mgsloan> aww
16:55:20 <augustss> map (read :: String -> Accoes) ...
16:55:43 <mgsloan> ?msg mgsloan hi!
16:55:43 <lambdabot> Not enough privileges
16:55:44 <fabiim> :) tks
16:56:20 <mgsloan> ah, one of the mystic admin commands
16:57:07 <SamB_XP> ?msg #haskell hi!
16:57:07 <lambdabot> Not enough privileges
16:58:33 <twanvl> using ?msg you could talk to this channel through lambdabot
16:58:55 <sorear> I think that's the reason it exists.
16:59:12 <SamB_XP> yeah, for fun ;-)
16:59:17 <sorear> /msg nickserv is handled through an entirely different mechanism
16:59:27 <SamB_XP> so lambdabot can make snide remarks etc.
16:59:33 <twanvl> :)
17:14:47 <glguy> slow night
17:18:11 * ndm curses the fact there is no good debugger for Haskell
17:18:28 <ndm> @karma- Haskell -- no debugger
17:18:29 <lambdabot> Haskell's karma lowered to 8.
17:18:36 <sorear> #haskell ?
17:18:43 <zarvok> heh
17:18:44 <sorear> @karma Haskell
17:18:45 <lambdabot> Haskell has a karma of 8
17:18:47 <sorear> @karma haskell
17:18:47 <lambdabot> haskell has a karma of 15
17:18:50 <mauke> > let q 0 = 1; q 1 = 1; q n = q (n - q (n - 1)) + q (n - q (n - 2)) in q 13
17:18:52 <lambdabot>  8
17:19:04 <allbery_b> ghc nightlies?
17:20:04 <ndm> allbery_b: thats not a good debugger, breakpoints does not a good debugger make
17:20:12 <ndm> definately in a lazy declarative language
17:20:18 <ndm> what i want is Hat++
17:20:28 <ndm> where ++ stands for works and is reliable
17:20:34 * allbery_b hasn't actually looked at it, since there don't seem to be nightlies for OSX/PPC
17:20:39 <mauke> > let q = 1 : 1 : [q !! (n - q !! (n - 1)) + q !! (n - q !! (n - 2)) | n <- [2 ..]] in q
17:20:41 <lambdabot>  [1,1,2,3,3,4,5,5,6,6,6,8,8,8,10,9,10,11,11,12,12,12,12,16,14,14,16,16,16,16,...
17:20:49 <ndm> its a good first step, but its about a million steps behind hat
17:21:11 <ndm> which in terms of good engineering and reliability is a million steps behind Windows
17:21:42 <mauke> @pl let q = 1 : 1 : [q !! (n - q !! (n - 1)) + q !! (n - q !! (n - 2)) | n <- [2 ..]] in q
17:21:51 <lambdabot> fix ((1 :) . (1 :) . return . ap ((+) . ap (!!) ((-) n . (!! (n - 1)))) ((<- [2..]) . (| n) . ap (!!) ((-) n . (!! (n - 2)))))
17:21:51 <lambdabot> optimization suspended, use @pl-resume to continue.
17:21:57 * dancor wonders what it means to compare a debugger to a bugos
17:22:10 <nornagon> @pl-resume
17:22:26 <lambdabot> fix ((1 :) . (1 :) . return . ap ((+) . ap (!!) ((-) n . (!! (n - 1)))) ((<- [2..]) . (| n) . ap (!!) ((-) n . (!! (n - 2)))))
17:22:26 <lambdabot> optimization suspended, use @pl-resume to continue.
17:22:32 <mauke> @pl let q = 1 : 1 : map (\n -> q !! (n - q !! (n - 1)) + q !! (n - q !! (n - 2))) [2 ..] in q
17:22:48 <lambdabot> fix ((1 :) . (1 :) . flip map [2..] . ap (ap . ((+) .) . ap ((.) . (!!)) (ap (-) . (. subtract 1) . (!!))) (ap ((.) . (!!)) (ap (-) . (. subtract 2) . (!!))))
17:22:48 <lambdabot> optimization suspended, use @pl-resume to continue.
17:23:00 <mauke> ok, that's better
17:23:01 <nornagon> :)
17:23:11 <nornagon> hooray for pointless style
17:23:15 * rohar looks at all of the symbols
17:23:21 <EvilRanter> eegad
17:23:24 <dancor> ndm: is hat being actively developed
17:23:36 <dancor> ndm: and why do they use cvs
17:23:57 <ndm> dancor: they use darcs, recently moved from cvs (website is probably out of date)
17:24:19 <ndm> dancor: and somewhat actively developed, certainly the windows port and gui are new in the last few months
17:24:34 <ndm> dancor: and there are meetings once a year, but not much full time hacking, sadly
17:24:58 <dancor> that's odd since good bedugging is one of the Serious Problems with FP
17:25:07 <dancor> maybe that makes it not odd
17:25:50 <ndm> the theory side is solved
17:25:52 <ndm> thats the good news
17:26:07 <dancor> theory != practice.  that's the other problem with FP :)
17:26:17 <ndm> and unfortunately, because the theory side is solved that means you can't get academic funding for it!
17:26:23 <dancor> nice
17:26:43 <ndm> if someone paid me to work on hat for 2 years, we'd have a great debugger by the end, guaranteed
17:27:16 <ndm> unfortunately no one will :(
17:27:56 <dancor> maybe if you make the first step someone else will make the next one
17:28:12 <ndm> i ported it to windows and wrote a GUI
17:28:18 <ndm> what other steps do you want ;)
17:28:34 <dancor> ones that affect my os :)
17:28:37 <ndm> and its hard to make time to make any more steps, because its not something i have any time for
17:28:42 <ndm> the GUI is cross platform :)
17:29:03 * dcoutts__ grins
17:29:14 * dcoutts__ rolls a tarball for 0.9.11 pre-release
17:29:15 <ndm> (and single threaded...)
17:29:26 <ndm> dcoutts__, how long til you break the API
17:29:34 <dcoutts__> ndm: it's already done
17:29:35 <ndm> dcoutts__, and is there a web browser control in Gtk2Hs?
17:29:39 <dcoutts__> yes
17:29:46 <ndm> neat, was thinking of Hoogle Gtk
17:29:56 <dcoutts__> ndm: the good news is we didn't break the api much
17:30:03 <dcoutts__> in fact really hardly at all
17:30:30 <ndm> bah, thats hardly a new version then ;)
17:30:33 <dcoutts__> for the tree/list business we've got both the old and new apis available for this release
17:30:48 <dcoutts__> so you can continue to use the old or transition to the new
17:30:52 <ndm> i program against PropLang anyway, so not much of an issue for me
17:31:42 <dcoutts__> ndm: well for lists etc it's a bit more tricky than what PropLang covers I reckon
17:31:49 <dcoutts__> I mean tree/list widgets
17:32:04 <ndm> dcoutts__ indeed it is, lists/trees is one place where pure proplang doesn't work too well, still thinking about that
17:32:19 <dcoutts__> ndm: well take a look at our new api
17:32:25 <ndm> i'm thinking a diff approach might be best, i.e. a stream of actions
17:32:25 <dcoutts__> it does much more on the Haskell side
17:32:31 <dcoutts__> sounds sensible
17:32:42 <dcoutts__> that's basically what we have now
17:32:46 <ndm> anyway, am trying not to focus on proplang
17:32:55 <ndm> trying to make my compiler optimiser terminate
17:33:11 <ndm> i have a termination proof of my algorithm, but try telling that to hugs...
17:33:16 <dcoutts__> there's a fairly simple mapping between lsit/tree state diffs and actions to notify the view of changes
17:33:26 <dcoutts__> ndm: heh :-)
17:38:26 <mgsloan> proofs just really mean 'i've checked this really hard', not that it is actually right
17:40:22 <ndm> if you remove the words 'really hard' you probably get a lot closer to what proof really means
17:40:33 <pejo> mgsloan, if it isn't right, it's not a proof.
17:40:36 <mgsloan> heh
17:41:06 <ndm> most proofs have "obvious bits" which are skipped, often these bits are wrong :)
17:41:14 <ndm> unless you use coq or something
17:41:16 <mgsloan> ok, then for your proofs to really be right, you'll have to proof your proofs are right, then proof that your proofs of proof are right, ad infinitum
17:41:42 <mgsloan> some of those proof = prove
17:41:42 <ndm> eventually you need axioms, things you take to be correct
17:42:01 <ndm> and those are correct by definitino, then you can stop :)
17:42:24 <mgsloan> sure, but what if you did it wrong?
17:42:53 <dancor> mgsloan: death
17:42:56 <ndm> i don't make mistakes :)
17:43:29 <mgsloan> take (-3)
17:43:30 <mgsloan> :O
17:43:56 <dancor> mgsloan: before you pick what constitutes a proof and your axioms, you are doing metaphysics.  after that, you are doing math.
17:44:21 <ndm> it would be nice if all proofs were automated and proved properly
17:44:24 <ndm> but its a lot of work
17:44:31 <dancor> logic is somwhere in between, or everywhere
17:44:34 <mgsloan> i prefer the term philosophy - metaphysics should be physics about physics :)
17:44:58 <mgsloan> yeah, I want a prover that can prove itself accurate
17:45:08 <mgsloan> bootstrap proof
17:45:30 <dancor> mgsloan: prove itself accurate in what proof system
17:45:38 <sorear> A weak type system gives very little protection, but it only requires you to enter the program.  A strong type system would give much more, and probably be able to infer most of the program given a type-level description.  But we will probably never get there, because people have seen the middle ground and don't like programming their code at both levels :(
17:46:13 <ndm> sorear: so if the type means you can infer the code, isn't that just writing the code in a different way?
17:46:41 <ndm> i.e. hopping through type shaped hoops, instead of value shaped hoops, but now in an untyped domain
17:46:42 <sorear> yes; weak types = code , strong types = types , medium types = both.
17:47:00 <mgsloan> add, subtract :: Int -> Int -> Int
17:47:06 <mgsloan> I'm beginning to like this language
17:47:12 <mgsloan> everything is so darn concise
17:47:17 <dancor> mgsloan: you could probably costruct some 'null proof' and some 'null proof system' for which you get your metatruth but it is completely empty
17:47:34 <ndm> coq has the unsafeCoerce style proof, which proves everything
17:47:59 <mgsloan> nice
17:48:06 <Saizan> [02·40·35] <mgsloan> yeah, I want a prover that can prove itself accurate <-- wouldn't this prove that is not consistent? (from Goedel teorems)
17:48:19 <mgsloan> I have no idea, maybe
17:48:29 * mgsloan looks up goedel...
17:48:40 <AStorm> Saizan, no mathematical system is complete, so... anyway :>
17:48:45 <ray> old news
17:48:47 <AStorm> Consistent it may be.
17:49:31 <dancor> Saizan: i'm not sure if you run into that problem here or not
17:49:59 <sorear> augment the SKI-calculus with error :: a, and you have a complete logic.
17:50:23 <sorear> It can prove every statement... true and false at the same time.
17:50:46 <Saizan> well, the problem was raised when they searched a formal system for mathematics which could be proven consistent from within
17:50:56 <AStorm> Yes, there's some "but" left: How can it prove its definitions are correct?
17:50:59 <AStorm> :>
17:51:20 <AStorm> (by not using them?)
17:51:47 <Saizan> and if iirc Goedel showed that such a system was inconsistent..
17:51:54 <AStorm> Axioms. Anyway, it's uninteresting.
17:52:26 <AStorm> It's _consistent_, but _incomplete_. Please don't mix the two :>
17:52:59 <Saizan> no
17:53:17 <Saizan> it's complete and inconsistent
17:53:33 <dancor> there is no assumption of completeness right
17:54:12 <Saizan> well, you can have one but not both :)
17:54:20 <dancor> mgsloan: what did you mean by wanting a "prover"
17:54:32 <dancor> mgsloan: a proof-checker?
17:54:40 <AStorm> If it's inconsistent, it doesn't prove anything, ergo, is not a proof checker :>
17:55:01 <Saizan> if it's inconsistent it proves anything :D
17:55:24 <AStorm> Therefore, it proves nothing correctly. :P
17:55:32 <emu> you can't prove the consistency of a formal system of mathematics using the system
17:55:40 <emu> or rather, if you could, it would be inconsistent
17:55:49 <Saizan> exactly
17:55:55 <emu> that is the 2nd theorem
17:56:11 <Saizan> so a prover who would prove itself would be inconsistent
17:57:02 <dancor> i thought mgsloan wanted a proof-checker that could check its own proof of correctness
17:57:15 <AStorm> meta-proof-checker? :P
17:57:35 <dancor> and i'm not sure that that runs into goedel problems
17:57:40 <dancor> though it still has other problems
17:58:07 <AStorm> Well, that'd be an infinite loop.
17:58:29 <AStorm> Check the proof of the proof of the ... of the proof.
17:58:49 <dancor> AStorm: not necessarily i don't think..
17:58:55 <Saizan> nah
17:59:11 <AStorm> Not necessarily if it'd loop somewhere.
17:59:22 <Saizan> it depens on what basis you can express the proof of the proof-checker
17:59:26 <AStorm> Yes.
18:04:26 <Saizan> mmh to check a proof in lamda calculus you have to expands it and see if it terminates, no?
18:04:48 <monochrom> A proof should need no expansion.
18:05:46 <AStorm> A proof should need a finite expansion.
18:05:49 <monochrom> If a proof has length n, a check should take O(n) steps.
18:06:01 <AStorm> not really
18:07:01 <AStorm> O(2^n) at most
18:07:45 <dancor> AStorm: isn't proof checking like a big thing with P =? NP
18:08:07 <AStorm> Don't know, I'd have to check. Probably...
18:08:11 <dancor> AStorm: which would (sociologic proof) imply that it's O(P(n)) at most
18:11:21 <AStorm> The funniest are long-term multi-implication tautologies
18:12:20 <fnord123> p = np... everyone knows that
18:14:56 <AStorm> Sans the N :>
18:15:08 <AStorm> Or when n = epsilon
18:17:31 <kyevan> Hmm, since the #darcs people seem to be dead, and I know there are a number of darcs users here....
18:17:59 <kyevan> Does anyone know of a good util to handle binary files to use along side a darcs repo?
18:19:20 <sorear> I had success sending a message, then lurking several hours.
18:19:51 <kyevan> sorear: I'm still lurking there :P
18:19:58 <kyevan> I just figured I'd ask here, too
18:21:16 <psnl> I'm going to shoot the next person who makes the p=np when n=1 joke
18:22:04 <ndm> psnl: got any hat work for public consumption yet?
18:22:33 <psnl> yes
18:23:41 <psnl> I should get around to mailing it to the list at some point
18:23:43 <ndm> woot, do tell :)
18:24:50 <AStorm> psnl, I'm not guilty. 1 is too simple for my taste. I prefer the null element.
18:24:52 <AStorm> :P
18:24:58 * AStorm ducks
18:25:36 <psnl> uh, it has a nice frontend to some of the tools; the main problem with it right now is each toolis seperate from the rest.
18:26:15 * psnl needs to get back to working on it
18:26:27 <ndm> oh, the gui you mean?
18:26:34 <psnl> yeah
18:26:38 <ndm> please flash a screen shot :)
18:27:24 <psnl> can I post one tomorrow? I'm feeling like going to bed
18:27:42 <psnl> since I'm supposed to be the christmas service in 6 hours
18:27:49 <ndm> fair enough :)
18:28:10 <psnl> and I don't have one handy
18:28:55 <ndm> am just curious to see which direction you've taken it in
18:29:06 <ndm> did you properly libraryfy the existing tools?
18:29:15 <glguy> http://xckd.com/c55.html
18:29:16 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
18:29:40 <psnl> not really
18:30:03 <psnl> most of the key stuff has been seperated out already
18:30:17 <psnl> and I have no idea how to make a libhat
18:31:05 <ndm> fair enough
18:34:31 <glguy> Yeah, did you see what he said on his wobsite?
18:35:00 <psnl> I'm not sure if its worth the effort to have a libhat, unless n things depend on it, rather than 2
18:35:00 <ndm> whose website?
18:36:08 <glguy> his wobsite
18:36:33 <ndm> i just meant a split like for hat-cover, one file is an API, one is a console program
18:36:38 <ndm> glguy: the xckd?
18:36:51 <psnl> ndm: oh, thats ben done for lots of the tools
18:36:57 <glguy> ndm: yeah, the one about misprouncing words :)
18:37:10 <psnl> been, even
18:37:18 <ndm> by you?
18:37:24 <psnl> no
18:38:20 <ndm> hmm, when i checked they were all over the place
18:39:36 <psnl> A problem is a lot of the display code is also doing work of one form or another
18:46:13 <ndm> yes, i noticed that
18:46:24 <ndm> in general, they seemed to be pretty indistinguishable
18:46:31 <sorear> (on the subject of hat) why does the entire program need to be evaluated before tracing begins?  why can't the trace generate a (value,trace) pair, where both are lazily evaluated?
18:46:33 <ndm> i had to do a lot of work to tidy up hat-cover to a clear api
18:47:01 <ndm> sorear: explain again, tracing begins immediately, debugging begins once you have a trace complete
18:47:14 <ndm> sorear: you can kill teh trace with Ctrl+C at any time, or wehn it finishes
18:48:56 <ndm> sorear: are you asking why you can't step through things like in an imperative debugger?
18:53:14 <ndm> dcoutts__: why not flip to the google bug tracker?
18:53:32 <sorear> no I just think generating the entire trace is wastefully strict
18:53:58 <dcoutts__> ndm: innertia?
18:54:13 <ndm> sorear: it might be wasteful, but it sure beats debugging a program where every value is <thunk>
18:54:22 <ndm> dcoutts__, it makes trac look like a pile of crap
18:54:37 <dcoutts__> ndm: they're planning to switch trac over to 0.10 anyway on darcs.haskell.org
18:54:54 <dcoutts__> ndm: you use it for yhc now ?
18:54:56 <ndm> thats still miles behind google's bug tracker
18:54:57 <ndm> yep
18:55:06 <ndm> we've got over 100 Yhc bugs in there
18:55:07 <dcoutts__> what's the advantage over trac ?
18:55:15 <ndm> written by google
18:55:20 <ndm> blessed with googly goodness
18:55:27 <ndm> much easier to enter bugs
18:55:31 <ndm> much better searching
18:55:37 <dcoutts__> can the db be backed up ?
18:55:41 <ndm> tagging is more flexible
18:55:51 <ndm> not by you, but google doesn't loose data
18:56:07 <dcoutts__> hrm, so not easy to transition away
18:56:14 <dcoutts__> if they've got your data
18:56:35 <ndm> you might be able to, just checking...
18:57:19 <dcoutts__> I still want to migrate our gtk2hs mailing lists from SF to haskell.org, it's a bit annoying having n different hosting things for project infrastrucutre
18:57:34 <ndm> yeah, makes sense
18:57:51 <ndm> can't find a way to get the data out, but you can always screen scrape if you want
18:58:24 <dcoutts__> trac is at least just a simple sqlite db
18:58:56 <ndm> google is a simple google project
18:59:02 <ndm> really easy, took me 5 mins to set up
18:59:04 <dcoutts__> I'm not overly fond of trac but I don't think we've got particularly high needs
18:59:15 <ndm> trac is just horrible, compared to google
18:59:19 <ndm> way too complex
18:59:29 <dcoutts__> I've already got it configured
18:59:42 <atsampson> ndm: so how much are Google paying you to do marketing for them?>
18:59:43 <atsampson> ;)
18:59:52 <Excedrin> is it open source?
19:00:04 <ndm> atsampson: nothing, but they provide me with lots for free (gmail, google reader, google calendar, searching...)
19:00:20 <ndm> atsampson: although they do pay the Gtk2Hs project...
19:00:47 <dcoutts__> well in SoC coders, I suppose so
19:01:33 <ndm> indeed
19:02:43 <fnord123> @seen cale
19:02:43 <lambdabot> cale is in #ghc, #haskell and #oasis. I last heard cale speak 4h 45m 43s ago.
19:02:54 <ndm> @karma+ google
19:02:55 <lambdabot> google's karma raised to 0.
19:02:59 <ndm> @karma+ google
19:02:59 <lambdabot> google's karma raised to 1.
19:03:04 <jethr0> hehe
19:03:31 <hyrax42> > fix succ
19:03:32 <lambdabot>  Add a type signature
19:03:44 <hyrax42> > fix (succ :: Integer -> Integer)
19:03:45 <lambdabot>  Exception: <<loop>>
19:03:54 <glguy> what do you want it to do?
19:04:01 <hyrax42> exactly that
19:04:22 <sorear> fix show
19:04:24 <sorear> > fix show
19:04:24 <fnord123> do you still need to invited to join google?
19:04:24 <glguy> > fix ( (0:) . map succ )
19:04:25 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
19:04:26 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
19:04:43 <hyrax42> I was just thinking that there can't be any fixpoints for "atomic" types
19:04:45 <hyrax42> :?
19:04:59 <hyrax42> or non-recursive types, rather
19:05:03 <hyrax42> inductive
19:05:03 <sorear> > fix (const 0)
19:05:05 <lambdabot>  0
19:05:05 <hyrax42> that's the word
19:05:10 <hyrax42> ack
19:05:18 <hyrax42> thanks
19:05:35 <glguy> > fix (\ ~(a,b) -> (b,1) )
19:05:36 <lambdabot>  (1,1)
19:05:48 <hyrax42> ~?
19:05:51 <sorear> > fix . (++) $ "hehe. "
19:05:52 <lambdabot>  "hehe. hehe. hehe. hehe. hehe. hehe. hehe. hehe. hehe. hehe. hehe. hehe. heh...
19:05:56 <glguy> lazy pattern match
19:06:05 <hyrax42> oh really
19:06:07 <hyrax42> h98?
19:06:17 <sorear> y
19:06:22 <glguy> e
19:06:22 <glguy> s
19:06:29 <glguy> ?
19:06:33 <hyrax42> hmmm never saw that one before
19:06:42 <hyrax42> well I guess I'll get back to the dishes
19:06:50 <hyrax42> now that I had a delusion removed
19:06:54 <hyrax42> thanks :)
19:07:20 <dancor> can i do a let in the middle of a do
19:07:28 <glguy> me too
19:07:38 <dancor> i thought i could but i'm getting Parse error in pattern
19:07:39 <jethr0> dancor: yes
19:07:40 <glguy> oh can you? yes you can
19:08:16 <jethr0> > do {let x = 5; return x}
19:08:17 <lambdabot>  Parse error
19:08:22 <glguy> dancor: paste your code in a pastebot if you need help
19:08:23 <glguy> ?paste
19:08:23 <lambdabot> http://paste.lisp.org/new/haskell
19:08:25 <jethr0> *grmpf*
19:08:39 <jethr0> my haskell is just too rusty to code directly to irc :(
19:08:59 <glguy> jethr0: that probably should have worked, but would n't have done anything
19:09:19 <glguy> except print a type maybe
19:10:01 <glguy> > runIdentity (do { return 5 } )
19:10:03 <lambdabot>  5
19:10:19 <glguy> > (do { return 5 })
19:10:20 <lambdabot>  add an instance declaration for (Show (m a))
19:10:20 <jethr0> glguy: i wanted to be in Maybe monad for example
19:10:39 <jethr0> which of course i should've made clear by typing it
19:10:42 <glguy> jethr0: but lambdabot doesn't seem to allow let statements in it's do-notation
19:11:02 <jethr0> well, that explains some things
19:12:18 <mgsloan> just figured out i don't need a state monad - just pass around the IORef State!
19:13:14 <glguy> State is just a restricted monad that only lets you store a single value, and as a result you can escape from it
19:13:20 <glguy> IO is for life
19:14:02 <hyrax42> a tatoo that said that would be quite apropos
19:14:05 <hyrax42> "IO is for life"
19:14:36 <glguy> IO therefore I am
19:15:13 <liyang> although unsafePerformIO does let you escape from life, whatever that means
19:15:43 <hyrax42> haskeller suicide cult
19:16:16 <liyang> very apt, I'd say
19:16:48 <glguy> that's why they call it necromancy
19:17:53 <mgsloan> well, its a good thing that my state is pretty much fully IO dependany
19:17:58 <mgsloan> dependant
19:18:19 <glguy> then it would seem fitting :)
19:19:29 <dancor> oh i was just missing a second do
19:26:22 <Angel_Monadico> Hi
19:27:25 <sorear> iH
19:27:35 <glguy> ugh
19:27:38 <jcreigh> 'evening. (in my timezone, at least)
19:27:41 <Angel_Monadico> please, how can I install ghc 6.6 in my ubuntu distribution, actually I have insalled ghc6.4.1
19:28:17 <glguy> Ubuntu? Nah, I'm not really into Pokemon
19:28:46 <gravity> :-)
19:29:07 <mgsloan> I've got 6.6 on ubuntu. forgot how i did it though...
19:29:16 <Angel_Monadico> ?
19:29:49 <Angel_Monadico> exist a repository???
19:29:50 <liyang> Angel_Monadico: http://xkcd.com/c178.html
19:29:52 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
19:30:40 <fnord123> xkcd is over posted on reddit. I'm with the haters now
19:30:41 * glguy wonders if that question was "higher kinded"
19:30:53 <mgsloan> I don't think its a repository, but i know it wasn't hard because i don't remember struggling
19:31:06 <Angel_Monadico> mmmmmmmmmm que mala onda
19:31:38 <liyang> let me show you my pokemans: http://packages.debian.org/ghc6
19:31:40 <lambdabot> Title: Debian -- Debian Package Search Results
19:31:52 <fnord123> fwiw, I stayed with 6.4.1 on kubuntu, Angel_Monadico
19:32:01 <arcatan> liyang: \o/
19:32:08 <glguy> My pokemons, let me show you them!
19:32:13 <arcatan> I mean, for the pokemans
19:32:27 <mgsloan> http://www.haskell.org/ghc/dist/6.6/ghc-6.6-i386-unknown-linux.tar.bz2
19:32:29 <lambdabot> http://tinyurl.com/y9myfk
19:32:52 <Angel_Monadico> Yes I have ghc 6.4.1, but i need install gtk2hs, and require ghc 6.6
19:33:01 <mgsloan> right
19:33:22 <mgsloan> so download that - it's 6.6 for arbitrary linux distributions
19:34:17 <Angel_Monadico> yes, I install unknow-distro , but gtk2hs install say "no ghc install on your system"
19:34:42 <liyang> Angel_Monadico: hang on a minute, Gtk2Hs doesn't work with 6.6 yet!
19:34:43 <mgsloan> ah, well, i never got gtk2hs installing
19:34:57 <liyang> You want 6.4.2...
19:35:04 <mgsloan> nah, it works. just download the darcs copy
19:35:12 <mgsloan> compile and install
19:35:17 <mgsloan> only way i could get it working...
19:35:28 <Angel_Monadico> yep >= 6.4.2
19:35:31 <mgsloan> then again, i didn't want to downgrade to 4.2
19:36:00 <sorear> gtk2hs *does* work w/ 6.6, I tried it
19:36:20 <liyang> not the current *release*
19:37:08 <sorear> releases are for wimps :)
19:37:14 <liyang> Easiest solution would be to grab the Debian 6.6 packages and compile Gtk2Hs from the Darcs repo...
19:38:02 <newsham> hi
19:38:13 <sorear> pong.
19:39:01 <Angel_Monadico> I use rI try with deb http://carwash.cs.nott.ac.uk:992/~lyh/debian/ repo, but say need ghc >= 6.4.2
19:39:02 <jethr0> pang
19:39:03 <lambdabot> Title: Debian Repository &ndash; Liyang on the IntarWeb
19:40:33 <liyang> We didn't have GHC 6.6 when I made those... sorry.
19:41:11 <Angel_Monadico> I install unknow-distro ghc 6.4.2, but no install well the dependecy of libraries
19:41:50 <liyang> They're the same as the ones in the Debian repositories.
19:42:20 <Angel_Monadico> for examples hopengl can't use a .so library of x11
19:42:57 <gravity> Has anyone managed to embed hopengl in a gtk window using h2gtk?
19:43:35 <sorear> haskls?
19:43:45 <Angel_Monadico> I want check these, all about gtk and hopengl
19:43:47 <mgsloan> yeah, carwash didn't work for me
19:43:55 <mgsloan> actually, i think its still in my source list...
19:43:59 <hyrax42> > 'a' < 'b'
19:44:00 <lambdabot>  True
19:44:30 <sorear> > 'Z' < 'a'
19:44:31 <lambdabot>  True
19:44:40 <hyrax42> > 'Ï' < 'Âµ'
19:44:41 <lambdabot>  Improperly terminated character constant
19:44:50 <mgsloan> @define L.<=> = compare
19:44:50 <gravity> It'd be nice to use opengl without needing glut
19:44:50 <lambdabot> (line 1, column 2):
19:44:50 <lambdabot> unexpected "="
19:44:50 <lambdabot> expecting space or simple term
19:44:51 <newsham> > pred 'a'
19:44:52 <lambdabot>  '`'
19:45:03 <sorear> LB doesn't speak utf-8 :(
19:45:14 <sorear> > 'Ã¿' > 'z'
19:45:15 <lambdabot>  Improperly terminated character constant
19:45:23 <hyrax42> are the unicode characters sorted by their codes?
19:45:32 <hyrax42> *ordered
19:45:37 <hyrax42> so latin is less than any other alphabet?
19:45:39 <sorear> > 'ÿ' > 'z'
19:45:39 <mgsloan> gravity - yeah. I was making a GLFW module
19:45:40 <lambdabot>  True
19:45:44 <dancor> what does <<loop>> mean
19:45:54 <newsham> > toEnum 130 :: Char
19:45:55 <lambdabot>  '\130'
19:46:04 <dancor> my program died saying that while runnig
19:46:06 <newsham> > toEnum 1305 :: Char
19:46:07 <lambdabot>  '\1305'
19:46:14 <mgsloan> infinite loop
19:46:17 <sorear> there, I just had to set my encoding to latin1 to send lambdabot a character...
19:46:20 <mgsloan> infinite recursion
19:46:25 <dancor> mgsloan: how is that detected
19:46:25 <sorear> > toEnum 255 :: Char
19:46:27 <lambdabot>  '\255'
19:46:33 <sorear> > [toEnum 255]
19:46:34 <mgsloan> perhaps deterministically
19:46:34 <lambdabot>  Add a type signature
19:46:38 <sorear> > [toEnum 255] :: [Char]
19:46:39 <lambdabot>  "\255"
19:46:42 <mgsloan> I'm not sure
19:47:20 <gravity> mgsloan: Does that use gtk underneath? Or glut?
19:47:24 <sorear> > 'ÿ' > 'ø'
19:47:25 <lambdabot>  True
19:47:26 <hyrax42> is hugs really "the most widely used implementation of Haskell"?
19:47:40 <liyang> dancor: Patent-Pending Halting Machine(TM)
19:47:40 <gravity> I can't find the info on the sight
19:47:43 <sorear> I *seriously* doubt that
19:47:43 <hyrax42> well I suppose perhaps it could hinge on the meaning of "widely", but that would be being pedantic
19:47:44 <mgsloan> no.  it is its own very minimal xplat GL application system
19:47:47 <gravity> s/sight/site/ (geez...)
19:48:06 <gravity> Interesting. Ok
19:48:09 <hyrax42> gravity: at least you missepelled "upwards"
19:48:12 <Angel_Monadico> Has anyone managed ogre3D for programing in haskell???
19:48:12 <hyrax42> ;)
19:48:24 <sorear> ?wiki H3D
19:48:24 <gravity> heh
19:48:24 <lambdabot> http://www.haskell.org/haskellwiki/H3D
19:48:40 <sorear> ^^ those folks are atleast trying to use ogre3d
19:48:45 <Angel_Monadico> yep, no more??
19:48:47 <hyrax42> nobody has input on hugs being most widely used haskell?
19:49:05 <sorear> ?version
19:49:06 <lambdabot> lambdabot 4p307, GHC 6.5 (OpenBSD i386)
19:49:06 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
19:49:09 <mgsloan> bah.  we'd probably have to code our own 3d engine for it to be proper
19:49:12 <Cale> I'd say GHC is probably more widely used than Hugs
19:49:19 <gravity> Whoa... L systems. I haven't heard about those in a few years. Not since the last time I did any opengl work.
19:49:22 <newsham> i use ghc, qed.
19:49:25 <gravity> I had even forgotten the name
19:49:26 <hyrax42> Cale: that's what I think
19:49:34 <Angel_Monadico> ghc excellent compiler
19:49:58 <hyrax42> he could just hae said "hugs is an excellent implementation of haskell for a beginner"
19:50:04 <Angel_Monadico> http://www.cse.unsw.edu.au/~dons/lambdabot    <----- ???
19:50:04 <hyrax42> or any other such thing
19:50:05 <lambdabot> Title: Index of /~dons/lambdabot
19:50:10 <hyrax42> oh something of mine was lost
19:50:18 * hyrax42 wonders why Hutton says otherwise, when really the statement isn't even relevant
19:50:19 <glguy> Angel_Monadico: a url
19:50:28 <liyang> not counting all the Introoduction to FP classes where Hugs is used, of course.
19:50:34 <lispy> hyrax42: but then i would argue...when i started out i evaluated both hugs and ghci and found ghci was better with error messages
19:50:50 <Angel_Monadico> :-/ obiusly man
19:50:51 <hyrax42> ok he could just say "excellent"
19:50:54 <hyrax42> or "good"
19:50:56 <hyrax42> or "an"
19:50:59 <lispy> hyrax42:  :)
19:51:03 <lispy> or just ""
19:51:09 <hyrax42> or he could just assert "hugs is."
19:51:09 <mgsloan> gravity: check out these L-systems - http://haskell.org/gtk2hs/archives/2005/09/02/koch-rules/
19:51:10 <lambdabot> Title: Gtk2Hs Â» Blog Archive Â» Koch rules
19:51:35 <sorear> context insensensitive Lindenmaeyer systems are equivalent to multistate iterated function systems - I tried to write an opengl renderer for ifs's, but my xserver kept crashing, so I stopped :(
19:51:42 <Angel_Monadico> sorry my english not good
19:52:41 <sorear> the bug was reported several years ago in Xfree and remains unfixed in Xorg, I guess they think people who use software 3d deserve crashes :(
19:53:26 <Angel_Monadico> fractales
19:53:42 <mgsloan> yeah, gedit has had a bug where if you click both mousebuttons it crashes for ages
19:53:59 <glguy> that darned open sores software
19:54:10 <sorear> we just need to rewrite the Xserver in a crash-proof language!
19:55:10 <mgsloan> yeah! then we'd just get non-exhaustive pattern match errors - alright!
19:55:10 <liyang> or use a mouse with only one button.
19:55:51 <sorear> Just use -Wall -Werror import Prelude hiding(error), and all will be well :)
19:56:11 <glguy> sorear: what about undefined?
19:56:16 <mgsloan> heh, lets hope all the modules don't use error either
19:56:45 <glguy> or writing your own let undef = x where x = x :)
19:56:49 <mgsloan> actually, error handling does seem rather course in haskell.  I'm surprised we can't do some monad foolery
19:57:27 <glguy> you can use monads for error handling
19:57:29 <hyrax42> ?instances Num
19:57:30 <lambdabot> Double, Float, Int, Integer
19:57:40 <sorear> just use epigram :)  "due to language restrictions the server cannot run forever.  Please restart it now."
19:57:48 <mgsloan> :)
19:58:01 <glguy> lol
19:58:02 <mgsloan> nah, math symbols are generally scary
19:58:56 <sorear> I just need a bigger keyboard, that's all :)
20:00:08 <gravity> sorear: I've thought about rewriting the X server :-)
20:00:24 <gravity> mgsloan: Very cool
20:01:27 <sorear> I think there are all of 1 implementations of the Xserver - IIRC even the propriatary ones are extended versions of the "sample implementation".
20:01:44 <sorear> dunno about kdrive, though.
20:01:56 <LoganCapaldo> What about things like X-Win 32 ?
20:02:00 <gravity> Right
20:02:05 <LoganCapaldo> And theres that Java one...
20:02:11 <gravity> sorear: kdrive is another ddx in the server
20:02:21 <gravity> sorear: So it harnesses the basic common architecture that they all do
20:02:50 <gravity> That said, the common parts aren't nearly as substantial as the xfree86 ddx for example.
20:05:01 <glguy> "Looking Glass" seems like it is great if you rotate your desktop all day
20:05:15 <glguy> and get paid to fold your windows off to the side and bring them back
20:05:25 <glguy> at least that's the impression I got from the LiveCD i tried
20:05:33 <gravity> ha!
20:05:44 <dancor> how do you track down an infinite loop in a program
20:06:04 <sorear> very carefully
20:06:31 <sorear> you send it to lisppaste2
20:06:37 <LoganCapaldo> Man that must be weird in Haskell. Even the infinite loops are lazy ;)
20:06:49 <glguy> verify that the few places that you used explicit recursion are guaranteed to get closer to the stopping condition each step
20:07:20 <sorear> > let f x = f (x+1) ; y = f 0 in 12
20:07:21 <lambdabot>  12
20:07:23 <LoganCapaldo> Prove that your functions terminate ;)
20:07:58 <glguy> fortunately you should have relatively few instances that you would need to check
20:08:02 <dancor> so basically there is nothing better than inspection
20:08:03 <glguy> for a small program
20:08:12 <dancor> which is the weakest debugging tool imaginable
20:08:19 <glguy> you could put in Debug.Trace.trace statements
20:08:42 <LoganCapaldo> Well you can use -fenable-oracle but that's only in the dev branch ;)
20:09:51 <sorear> rewriting hat is looking more attractive at an increasing rate
20:10:59 <sorear> the debug rts is extremeltydduseful , esp with concurrency problems
20:11:11 <glguy> dancor: how big is your program?
20:12:03 <dancor> 190 lines
20:12:52 <dancor> just big enough for me to not be able to write it without encountering death
20:14:06 <sorear> oh, well, we can make it shorter :)
20:14:25 <glguy> do i hear 180 lines, 180 lines, 170, do I hear 160,
20:14:30 <glguy> 160 going once! 150
20:14:31 <glguy> 150 lines
20:14:40 <mgsloan> woohoo interactive cairo canvas!
20:19:50 <audreyt> interactive cairo canvas where?
20:20:12 <hyrax42> sorear: hat is not good?
20:21:14 <glguy> ?unl ```s``s``sii`ki`k.*``s``s`ks``s`k`s`ks``s``s`ks``s`k`s`kr``s`k`sikk`k``s`ksk
20:21:14 <lambdabot>  *
20:21:14 <lambdabot>  *
20:21:14 <lambdabot>  **
20:21:15 <lambdabot>  ***
20:21:17 <lambdabot>  *****
20:21:51 <sorear> I'm going on what almost everyone else has said .dabout it...
20:22:09 <mgsloan> audreyt: in my app.  Doesn't even use funny monads either.  plain sensical IORefs
20:22:18 <audreyt> mgsloan: url?
20:22:37 <sorear> The special keys on my keyboard are intermittently not working :( esp. basckpace. who
20:22:50 <hyrax42> ?pl \c -> ord c - ord 'a'
20:22:51 <lambdabot> subtract (ord 'a') . ord
20:22:55 * sorear curses everything wireless
20:23:14 <lisppaste2> mgsloan pasted "you asked for it" at http://paste.lisp.org/display/33314
20:23:18 <glguy> sensical?
20:23:46 <hyrax42> glguy: you better not be attacking the status of "sensical" as a word
20:23:46 <mgsloan> yeah, I haven't really devoted time to understanding any monads except IO and a bit of List
20:23:52 <hyrax42> ;)
20:24:04 <glguy> hyrax42: merely asking for him to create a definition to match
20:24:17 <hyrax42> why the sensical one, of course
20:24:43 <sorear> > liftM2 zip inits tails "My favorite use of other monads"
20:24:44 <lambdabot>  [("","My favorite use of other monads"),("M","y favorite use of other monads...
20:24:47 <glguy> ?freshname
20:24:48 <lambdabot> Haef
20:24:49 <glguy> ?freshname
20:24:49 <lambdabot> Haeg
20:24:51 <glguy> ?
20:24:59 <mgsloan> sensical = better version of sensible
20:25:13 <dancor> != scrabble word
20:25:29 <hyrax42> the scrabble world lags, as always
20:25:33 <mgsloan> ?. elite freshname
20:25:33 <lambdabot> |-|aeH
20:25:35 <mgsloan> nice
20:25:36 <arcatan> cosmical fluidums
20:25:44 <sorear> dancor: it's /= here :)
20:25:54 <dancor> oh, o<<loop>>
20:25:56 <glguy> != must be some kind of strict assignment
20:25:59 <LoganCapaldo> sensical = non . non sensical
20:26:31 <hyrax42> > not . not True
20:26:32 <lambdabot>    Expecting a function type, but found `Bool'
20:26:32 <lambdabot>    Expected type: a -> Bo...
20:26:39 <mgsloan> ?. elite unpl liftM2 zip inits tails "My favorite use of other monads"
20:26:39 <lambdabot> (inI7$ >>= \ B -> T4ilz >>= \ A -> RetURN (Zip b A)) "mY F4vorIt3 U$e 0f Ot|-|Er /\/\On4DS"
20:26:40 <hyrax42> LoganCapaldo: that doesn't type check ;)
20:26:43 <mgsloan> hah
20:26:44 <sorear> > not $ not true
20:26:45 <lambdabot>  Not in scope: `true'
20:26:51 <sorear> > not $ not True
20:26:52 <lambdabot>  True
20:26:58 <mgsloan> composing elite onto other things is my new favorite hobby
20:27:05 <hyrax42> > (not . not) true
20:27:06 <lambdabot>  Not in scope: `true'
20:27:09 <hyrax42> > (not . not) True
20:27:10 <dancor> is elite deterministic
20:27:11 <lambdabot>  True
20:27:14 <sorear> ?. elite eval runST $ return 5
20:27:15 <lambdabot> Say again?
20:27:25 <dancor> it did different things to different esses
20:27:28 <sorear> ?. elite eval runST id
20:27:28 <lambdabot> Say again?
20:27:33 * LoganCapaldo is dissapointed in the precedence of (.)
20:27:35 <sorear> ?eval runST id
20:27:36 <mgsloan> ?. elite unpl liftM2 zip inits tails "My favorite use of other monads"
20:27:37 <lambdabot> (iniTz0rz >>= \ 8 -> T4I1$ >>= \ a -> r3tUrn (sIp 8 a)) "my f4VOrite U53 Of O7her /\/\ONADz"
20:27:46 <sorear> ?eval runST id
20:27:50 <hyrax42> ?elite let's see
20:27:51 <lambdabot> 13+'z0rz S33
20:27:53 <hyrax42> ?elite let's see
20:27:54 <lambdabot> l37's 53e
20:27:58 <hyrax42> ?elite let's see
20:27:58 <mgsloan> yeah, looks like someone put out the effort to use random
20:27:59 <lambdabot> 137's $EE
20:27:59 <sjanssen> sorear: the command is called run
20:28:13 <sorear> ?. elite run runST $ return 5
20:28:13 <lambdabot> nO+ iN 5C0pe: `rUNz7'
20:28:20 <hyrax42> lol
20:28:23 <sorear> ?. elite run Control.Monad.ST.runST $ return 5
20:28:24 <lambdabot> nO+ IN Sc0Pe: `c0ntR0L.MONaD.57.ruNz7'
20:28:34 <glguy> ?. elite run L.mypokemans
20:28:36 <lambdabot> "|e7 mE show y0u THem"
20:28:37 <mgsloan> ?. vixen run runST $ return 5
20:28:38 <lambdabot> what's the matter?
20:28:48 <sjanssen> sorear: dons removed ST when there was a security hole discovered
20:28:59 <sorear> ?. elite type Control.Monad.ST.runST $ return 5
20:29:00 <lambdabot> INpheRr3D tYp3 i5 |3$5 p0lY/\/\ORphic ThAn Expe(T3d qUANTIfIed tYpE v4ri4blE `S' es(4PEs
20:30:25 <mgsloan> audreyt: the actual thing I'm working on will be a visual programming language in a few years time :)
20:30:38 <glguy> like "Visual Basic"?
20:30:49 <mgsloan> nah, like labview haskell style
20:31:01 <sorear> when was it removed?
20:31:06 <mgsloan> with a bit of a sloan secret sauce
20:31:13 <sorear> darcs changes | grep wasn't helpful :(
20:31:15 <glguy> I was joking, but what is labview haskell style?
20:31:22 <sjanssen> sorear: a few months ago
20:31:34 <mgsloan> oh, labview is probably the most popular graphical language
20:32:04 <dylan> as long as there is a textual representation somewhere, that's perhaps useful.
20:32:07 * LoganCapaldo gets cold sweats from the mention of LabView
20:32:30 <mgsloan> bah, I guess you could serialize it, but it'd be ugly as hell
20:32:51 * dylan remembers how people thought he'd never understand math because graphs of functions were introduced first....
20:33:26 <mgsloan> well, the thing is, I think a linear representation is only really good for 2 argument functions - infix
20:33:48 <mgsloan> that way you can look in the immediate area of the function and see what it applies to
20:34:27 <mgsloan> you will notice that most often-used multi-parameter functions in mathematics take their parameters on the top and bottom
20:35:15 <dylan> I never understood those either, until I discovered how to convert it to ascii. :-/
20:35:33 <mgsloan> single output is also due to this linear representation
20:35:43 <dancor> can i match on [], or d:[], or d:ds in that order
20:35:52 <dancor> or is that somehow bad
20:35:59 <glguy> dancor: that works
20:36:01 <sjanssen> dancor: you can
20:36:01 <mgsloan> pattern match?
20:36:04 <dylan> dancor: I see no problem.
20:36:06 <glguy> dancor: what does your function do?
20:36:10 <mgsloan> d:[] could be [d]
20:36:43 <LoganCapaldo> mgsloan: Your argumetn makes sense to certain extent, with mathematical notation, but please dear god, no LabView, with pointless wires running all over the place
20:36:59 <dancor> it computes the score of a list of darts in 501, but you have to keep track of if the game requires a double to start and/or end
20:37:19 <mgsloan> well, I haven't actually recieved my labview (ordered the student edition recently), but i promise it won't suck
20:37:20 <dylan> mgsloan: at some level, if it's just a better way of describing text, then I think that would suit my mind. But if you're talking about making pipes and shapes, that's terribly difficult to understand (for me)
20:38:00 <mgsloan> yeah, I'll probably have it translate to haskell at first, perhaps always
20:38:09 <dylan> I remember the week of hell when I had to draw flow charts... oh the joy when I found out how to generate those from code.
20:38:19 <LoganCapaldo> I'm pretty sure theres a good reason they went schematic -> HDLs and not the other way around.
20:38:21 <mgsloan> hah. yeah, i never use flow charts
20:38:27 <dancor> (and the double-off invalidates the whole turn if violated, but the double-on just invalidates those single darts before the double)
20:38:43 <mgsloan> LoganCapaldo: heh, i think we've had this conversation before :)
20:38:43 <dancor> (hooray for weird casings in common games)
20:39:01 <LoganCapaldo> mgsloan: Really?
20:39:06 <dylan> LoganCapaldo: I can understand, though, some people think more visually than I. Perhaps a visual language would be good for that.
20:39:07 * LoganCapaldo honestly doesn't recall
20:39:19 <mgsloan> yeah, or someone else brought up the schematic -> HDL thing
20:39:38 <mgsloan> yeah, I'm very visual
20:39:41 <dylan> For programming, and especially math, I *feel* the shape, but seeing it is different.
20:40:14 <mgsloan> you could make a language for blind people :)
20:40:19 <dylan> I first learned algebra because of ohm's law + the equation for power.
20:41:01 <dylan> when it hit me, I felt how I could push/pull and bend the values around to find power from resistence and voltage, etc.
20:41:32 <glguy> dancor: so mathschallenge.net/
20:41:35 <glguy> ?
20:41:50 <dylan> It was actually a dizzying experience.
20:42:00 <mgsloan> nice, i remember that too
20:42:35 <mgsloan> not for Ohms law, it was like 3rd grade after we learned division...
20:42:49 <dylan> I learned division in first grade. :)
20:42:55 <mgsloan> nice
20:43:00 <mgsloan> I invented it in 2nd :)
20:43:03 <dylan> but didn't understand algebra until after I took a college electronics class.
20:43:14 <dylan> I invented the pythagorean theorum. :)
20:43:22 <mgsloan> ooh nice
20:43:52 <LoganCapaldo> I'm lame. I invented the formula for the derivative
20:44:13 <LoganCapaldo> No wait
20:44:18 <LoganCapaldo> No I didn't
20:44:18 <mgsloan> yeah, i figured out the power rule
20:44:19 <dancor> glguy: what
20:44:23 <LoganCapaldo> I invented the power rule
20:44:27 <LoganCapaldo> yeah that was it
20:44:35 <glguy> dancor: there's a project euler problem for what you described, i wondered if that was what you were doing
20:44:51 <glguy> dancor: http://projecteuler.net/index.php?section=problems&id=109
20:44:55 <lambdabot> Title: Project Euler
20:44:59 <dylan> I feel somewhat bad that it took me forever to learn algebra.
20:45:19 <mefistofeles> dylan: what type of algebra?
20:45:36 <dylan> mefistofeles: solving for 1 variable, e.g. electronics stuff
20:45:43 <mefistofeles> I see
20:46:05 <dancor> glguy: nah i just want to keep track of darts playing
20:46:09 <glguy> heh
20:46:10 <glguy> ok
20:46:12 <dylan> yeah. Everyone tried drawing pretty pictures to explain it to me.
20:46:14 <dancor> glguy: i already wrote one for cricket
20:46:25 <dancor> that one actually worked
20:46:41 <dancor> so what is the deal with shadowing variables with a let
20:46:52 <glguy> what about it?
20:46:56 <dancor> i'm getting a loop if i do shadow and not if i don't
20:47:20 <mgsloan> dylan - ah, i see how that would polarize you against graphical languages :)
20:47:42 <dancor> i guess bc i have  let var' = f var in  and i had been using var instead of var' hoping it would shadow
20:47:54 <LoganCapaldo> I'm polarized cause they made use LabView in freshman engineering.
20:48:01 <dylan> mgsloan: now, mind you, this is because I learned to program first, and because I learned to type before I got good at writing...
20:48:02 <LoganCapaldo> gah
20:48:06 <LoganCapaldo> worst experience ever
20:48:20 <mgsloan> I hadn't actually thought about that too much.  My intuition is that textual is just really really limited graphical, and breaking this limitation is beneficial
20:48:50 <glguy> dancor: the name of a variable is visible to the definition of the variable
20:48:58 <mgsloan> ah. yeah, i did something similar
20:49:08 <dylan> mgsloan: well, to me text is second nature. I think in text even when I'm speaking.
20:49:25 <mgsloan> LoganCapaldo: really.  What were your problems with it?
20:49:39 <dylan> before computers I spent almost every waking moment reading books.
20:50:07 <mgsloan> dylan - yeah, that's the problem.  People are very attached to their text.  its probably more of a leap from text -> graphical than procedural -> functional
20:50:11 <dylan> and I often have a running monologue of what's going on at the moment.
20:50:20 <mgsloan> whoah
20:50:32 <LoganCapaldo> mgsloan: I just felt like there was so much unecessary explcitness. Connecting outputs to inputs with lines, placing little boxes as functions, etc.
20:50:45 <dylan> Right now a part of my mind is going "And he mentioned his strange relationship with the written word..."
20:50:56 <mgsloan> that'd be pretty cool.  In books you can often times see what's going to happen because you are an observer of the scene rather than a participant.  Or just the author is predictable
20:51:26 <mgsloan> Logan - I don't see how that's very explicit - you do the same thing with text juxtaposition in haskell
20:51:33 <dylan> I used to repeat everything I said under my breath, too, but I only do that subvocally now.
20:51:46 <LoganCapaldo> IMO it doesn't scale down because you have a lot of slow boilerplate mouse movements. It doesn't scale up because it's that much harder to break up a diagram. Admittedly this may be more a problem with the specific graphical language than the concept of a more graphical programming alnguage
20:51:53 <mgsloan> though i will allow box juxtaposition
20:52:10 <mgsloan> ah, there will be a keyboard interface
20:52:19 <dylan> LoganCapaldo: But if you could manipulate the boxes with both hands without the aid of a pointing device?
20:52:30 <mgsloan> yeah, that's my long term plan
20:52:34 <mgsloan> multitouch displays
20:52:38 <LoganCapaldo> That would certainly be better
20:52:42 <dylan> I don't mean 2D either.
20:52:55 <LoganCapaldo> I still don't know how to "divide a diagam" into component
20:52:57 <dylan> The best interface 2D can provide me is textual.
20:53:12 <LoganCapaldo> But that could be a lack of imagination on my part
20:53:12 <dylan> 3D, now, can do a little better.
20:53:20 <dylan> and what I really want a neural interface.
20:53:40 <mgsloan> break up a diagram? it's just like a haskell program
20:53:49 <mgsloan> ah.  3D would be crazy
20:53:59 <mgsloan> well, maybe it'd be nice,  I'm undecided
20:54:06 <dylan> This is where the difference of mental models is apparent.
20:54:32 <dylan> For me, moving things around in a 3D space (holodec-style) would be good.
20:54:36 <mgsloan> if there is lots of airspace in the 3d it'd be ok
20:54:49 <dylan> well, I picture it being like my office or whatever.
20:55:26 <dylan> the perfect interface would just allow me to subvocalize a command/request and display it 3D-like.
20:55:47 <dylan> hmm, a eureka thing just happened.
20:55:58 <LoganCapaldo> mgsloan: Can I ask you, how would your language "diagram" recursion?
20:56:13 <dylan> Even with a neural interface, I would still program in text. You know why?
20:56:16 <LoganCapaldo> or rather a recursive function
20:56:18 <sorear> higher order?
20:56:24 <sorear> fix!
20:56:29 <mgsloan> Logan - I'm glad you asked.  Zoom.  When you zoom into a labeled function it turns into its definition
20:56:36 <dylan> I can't... I can't imagine thinking in order otherwise. my thoughts would not be able to take shape as a program.
20:56:40 <mgsloan> well, thats how recursion looks at least
20:56:56 <LoganCapaldo> How do I draw it though?
20:57:17 * LoganCapaldo guesses you could have a Y combinator box to drop on the page
20:57:30 <LoganCapaldo> so that would work
20:57:32 <mgsloan> Like a definition box labeled "foo" with a reference box labeled "foo" inside
20:58:57 <sorear> I'd love to see how any of these graphical languages fare at the ICFP - see Fitt's Law and time constraints...
20:59:14 <mgsloan> dylan - interesting.  I'm adapted to text as well.  I suspect graphical will have a bit of a learning curve, varying similarly to the procedural -> haskell curve (the longer you're with procedural the harder it is)
20:59:47 <dylan> I think a better description is adapted to language.
21:00:02 <mgsloan> sorear - there are no good graphical languages, yet :)
21:00:11 <mgsloan> that too
21:00:26 <mgsloan> probably the phenomena is directly resultant from language
21:01:09 <dylan> Does anyone else remember learning that they have to order their thoughts, much like learning how to walk by ordering the way you put your feet one after the other?
21:01:16 <geckosenator> mgsloan: what about simulink?
21:01:20 <mgsloan> sorear - I will attempt a keyboard interface, i think its possible
21:01:38 <mgsloan> geckosenator: ah, haven't seen that one.  I've been trawling sites for weeks too...
21:01:50 <mgsloan> well, maybe days more like
21:02:04 <geckosenator> not even 1 week
21:03:08 <LoganCapaldo> mgsloan: How do you feel about APL?
21:03:21 * dylan twiches at APL
21:03:24 <mgsloan> nevermind, I've seen it before. didn't give it as hard of a look as I should probably though
21:03:46 <mgsloan> I have no idea how to use APL, but it has some interesting ideas.  I'm never going to learn it
21:04:11 <LoganCapaldo> k
21:04:48 <LoganCapaldo> It just strikes me as being at least a little graphical
21:05:42 <sorear> The problem with trying to optimize a language for productivity is that its definition is deeply tied to the non-repeatability of humans.
21:05:55 <mgsloan> hmm, simulink does look pretty good.  Has more of the features of my lang than any other lang
21:06:09 <LoganCapaldo> Hey look a giant list: http://en.wikipedia.org/wiki/Visual_programming_language
21:06:11 <lambdabot> Title: Visual programming language - Wikipedia, the free encyclopedia
21:06:13 <mgsloan> well, readability and clarity is very important in productivity
21:06:19 <LoganCapaldo> sorear: This is why I
21:06:24 <sorear> Once we have a practical solution for NP-problems, I think a good approximation metric would be code density.
21:06:24 <mgsloan> logan - yeah, i've looked through those
21:06:26 <geckosenator> to be honest graphical programming languages are a pain to debug
21:06:44 <LoganCapaldo> ve decided that future programming languages should be optimized for maintainability
21:06:51 <sorear> (P=NP or cheap quantum computers, either will do)
21:06:52 <LoganCapaldo> stupid enter key
21:06:53 <mgsloan> really, I'd think they'd be awesome for it
21:07:24 <mgsloan> I mean, a decent lang will show you the var with each wire
21:08:19 <sorear> A good language should be well meshed to the capabilities of *humans*.  Perhaps we should represent variables in different colors?
21:09:14 <LoganCapaldo> colorforth! woo ;)
21:09:21 <mgsloan> yeah, i've been thinking about that too.  The kernel lang will be very uniform, but the displayed will look like you have special control structures and such (like do notation, except you can make new ones)
21:09:23 <sorear> A graphical language as I see it is one which is designed to effectively use the 2d capabilities of the human eye.  I do not see graphical and symbolic as mutually exclusive...
21:09:34 <mgsloan> yeah, certainly not
21:12:02 <sorear> for instance, a newly designed non-textfile language should not use parens.
21:12:25 <sorear> Circles are much less confusing IME.
21:12:37 <mgsloan> anyway, I'm just going to make a vector image editor with a slant towards expanding into this lang.
21:12:44 <mgsloan> good idea
21:13:29 <mgsloan> Eventually it would have a math pretty printer/editor, and that will often times scale the outer parens up, or use a different type
21:13:49 <sorear> Paren-matching is one of the leading causes of confusion in my high school math class.
21:13:59 <mgsloan> hah
21:14:15 <LoganCapaldo> 1) No parens 2) Instead of parens name everything :)
21:15:58 <mgsloan> one thing is that I played mindrover (a robot programming game) alot when i was younger.  it had a visual language embedded
21:16:41 <mgsloan> Wasn't actually a very good language - if you actually used the wiring method competitively you'd have to wire it in order such that events don't have to wait until the next game tick to be propogated
21:17:35 <mgsloan> so anyway, my goal for now is to get a system up and going so i can mess with some of these ideas
21:18:07 <mgsloan> though maybe i can just do that in inkscape :)
21:18:32 <sorear> The only visual language I've ever used is the Lego Mindstorms IDE.  I will not torture you with a description of the interface.
21:19:07 <LoganCapaldo> sorear: I had to use that before they let us work up to LabVIEW
21:19:13 <LoganCapaldo> gah
21:19:25 <LoganCapaldo> color coded gotos! wheeee
21:19:33 <sorear> I've never heard of LabView. (I should be greatful, right?)
21:19:50 <sorear> LC: I never got to the gotos
21:21:11 <mgsloan> sorear - hah, yeah
21:21:30 <mgsloan> I hear the mindstorms NXT IDE isn't so bad
21:21:36 <mgsloan> I used NQC for lego mindstorms
21:25:43 <bd_> :t ap
21:25:44 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
21:26:03 <mgsloan> ah, simulink looks like it's dataflow.  That'll be a DSL in mine, i think
21:26:48 <LoganCapaldo> Domain specific drawing <g>
21:27:00 <mgsloan> :) exactly!
21:27:26 <mgsloan> domain specific notation, or just notation for short will be the terminology though
21:27:57 <LoganCapaldo> Hmm this idea might be warming on me. You could have "brushes" that would be like macros
21:28:08 <LoganCapaldo> Or maybe call them "stamps
21:29:43 <LoganCapaldo> Hmmm
21:30:01 <LoganCapaldo> I wonder what the "syntax" for the type system would look like
21:30:23 <mgsloan> yeah, I haven't figured that out very well
21:31:23 <sorear> SPJ did a paper on type inference for spreadsheets
21:31:50 <mgsloan> despite objections, I'm confident that a well implemented graphical lang can generally own any textual language.
21:31:55 <mgsloan> well, any current ones
21:33:56 <mgsloan> problem with finding a syntax is that I haven't figured out semantics yet.  I'm not really sure how the type system will work
21:34:04 <mgsloan> it'll certainly be static though.
21:34:24 <mgsloan> that's one thing that'll be cool about this - no syntax errors, and no type errors - it won't let you in the first place
21:36:02 <sorear> well, infinite type inference solves the type error problem, and Jot has solved the syntax error problem
21:36:36 <mgsloan> infinite type inference?
21:36:50 <sorear> but errors are *good* because they increase (for lack of a better term) the Hamming distance of the set of legal programs, and thus increase the error detecting power of the language.
21:36:57 <sorear> ?quote sorear
21:36:57 <lambdabot>  Haskell is amazing. I'm still working on my infinite-types unifier, and in a day I've added sums, products, and lambda abstractions, refactored the code until there was a net *decrease* in LOC, and
21:36:57 <lambdabot> helped man #haskell all at the same time. This'd take me a week in C, no doubt.
21:37:15 <sorear> I'll try and find the url if you're interested.
21:37:44 <mgsloan> I'm a bit interested, just to know the basic idea
21:37:48 <mgsloan> i take it its textual
21:37:50 <sorear> http://members.cox.net/~stefanor/Unifier.hs
21:37:52 <sorear> yeah :)
21:38:16 <sorear> basically, it is possible to add types of the form fix a. foo to the type system
21:38:30 <mgsloan> ah
21:38:36 <sorear> like fix a. Either () (Int,a)  is the type of lists of Int
21:38:44 <mgsloan> which has the side effect of making everything legal maybe?
21:38:56 <mgsloan> if you coerce things around a bit
21:38:58 <sorear> in the absence of sums and products, yes
21:38:59 <mgsloan> or something
21:39:01 <mgsloan> ah
21:39:06 <mgsloan> cool
21:39:23 <sorear> every valid CL expression has a typing, if you allow infinite types.
21:39:39 <sorear> (sii) has type fix a. a -> b
21:39:46 <sorear> (sii)(sii) has type a
21:40:09 <sorear> yes, with infinite types recursion does not need to be built in to the language.
21:40:30 <sorear> Unfortunately the possibility of errors returned once I added sums and products.
21:41:28 <mgsloan> thing is, it's not that the language is dynamic or something - the types should be as strict as haskell, it's just that the ide will not allow you to construct things with type errors
21:42:23 <sorear> then you still have type errors
21:42:33 <sorear> Perl has type errors at runtime
21:42:42 <sorear> Haskell has type errors at compile time
21:42:43 <LoganCapaldo> I like constructing things with type errors. It lets me read the error and try and figure out what I'm really trying to do :)
21:42:46 <mgsloan> you never see the type errors though
21:42:53 <mgsloan> heh
21:42:55 <sorear> mgsloan's language has type errors at type time
21:43:10 <sorear> (or click-and-drag time)
21:43:26 <nmessenger> code-writing time?
21:43:30 <mgsloan> well, you'r making a wire, and suddenly all the input ports that would be a type error close off - can't even click em
21:43:38 <mgsloan> yeah
21:43:46 <LoganCapaldo> I think what I'm trying to say is I
21:43:46 <LoganCapaldo> I'
21:43:46 <LoganCapaldo> ack
21:43:49 <mgsloan> type time too hopefully
21:44:04 <LoganCapaldo> I'd get very frustrated if I couldn't "type in" something with a type error
21:44:46 <mgsloan> yes, its very possible I'll allow you to construct an error, but blatantly visually highlight it
21:45:11 <sorear> The eye-brain-hand path is a very high latency connection, and it may turn out that batching type errors is better for productivity than interrupting you every time you make one.
21:45:28 <nmessenger> ?remember LoganCapaldo I like constructing things with type errors. It lets me read the error and try and figure out what I'm really trying to do :)
21:45:50 <mgsloan> ah, yeah, that is something to remember.
21:46:17 <nmessenger> I agree wholeheartedly
21:46:35 <nmessenger> (with the quote)
21:46:54 <mgsloan> ah, I was referring to both actually :)
21:47:20 <mgsloan> thing is, ghc type errors just tell you expected/inferred and the textual context.  with my language that is readily apparent on the screen
21:48:06 <sorear> how about making type errors flash :)
21:48:15 <sorear> use space AND time :)
21:48:32 <LoganCapaldo> hypothetically I could hook the type checker / inferrer into my textual editor and make it flash type errors too
21:48:36 <nmessenger> Ooh, how about loud noises and shakings?!
21:48:40 <mgsloan> yes, i have actually thought about using animation
21:49:17 * mgsloan imagines a readerM walking along a list
21:49:25 <sorear> ?spell received
21:49:26 <lambdabot> received
21:49:33 <LoganCapaldo> How about some electrodes. It could give you a small electric shock every time you drew something that didn't type check :)
21:49:46 <nmessenger> *walk, walk, walk*
21:49:47 <mgsloan> would be pretty cool to mix inverse kinematics and debugging though
21:49:58 <mgsloan> hah
21:50:18 <mgsloan> or just have user defined actions when things don't check
21:50:32 <mgsloan> after all, the language's configuration will be edited using itself
21:50:43 <nmessenger> stick figures would be REQUIRED to animate list-walking
21:51:00 <LoganCapaldo> stick figures are essential
21:51:14 <mgsloan> yeah, and when you zoom in on said stick figures they become the visual representation of the reader monad
21:51:33 <mgsloan> eg, the actual code. still in stick figure form though
21:51:41 <nmessenger> interactions between monads would be Xiao-Xiao-style stick figure fights
21:52:03 <LoganCapaldo> No Monads would be little stick figure spacesuits
21:52:04 <sorear> lol
21:52:52 <mgsloan> lol
21:53:50 <LoganCapaldo> Like that tutorial
21:53:50 <LoganCapaldo> A multithreaded program would look like a game of Starcraft ;)
21:53:59 <nmessenger> D00d!!
21:55:56 <sorear> I'd just like to see guru(1) implemented...
21:56:33 <sorear> (from the a.s.r. manpage collection)
21:56:52 <nmessenger> ?pl \a b c -> (-b + sqrt (b^2 - 4*a*c)) / (2*a)
21:56:59 <lambdabot> ap (flip . ((flip . (((/) . subtract) .)) .) . liftM2 (.) (+) . ((sqrt .) .) . flip ((.) . (-) . (^ 2)) . (*) . (4 *)) (2 *)
21:56:59 <lambdabot> optimization suspended, use @pl-resume to continue.
21:57:11 <LoganCapaldo> woah
21:57:24 <nmessenger> Gah!  It burns!
21:58:00 <allbery_b> pl == Practically ilLegible? :)
21:58:16 <sorear> it's pointless to continue
21:58:23 <sieni> pl == peruslätkä
21:58:44 <mgsloan> pl = pretty lame
21:58:52 <sorear> ?babel sv en peruslätkä
21:58:53 <lambdabot> babel module failed: IRCRaised Error: Language sv not supported
21:58:56 <sorear> ?babel fi en peruslätkä
21:58:57 <lambdabot> babel module failed: IRCRaised Error: Language fi not supported
21:59:11 <sieni> i.e. a finnish euphemism for regular quality hashish
21:59:23 <nmessenger> pl = painfully liftMed
21:59:45 <sorear> ?pl \x -> ((((((x.).).).).).)
21:59:46 <lambdabot> (.) . (.) . (.) . (.) . (.) . (.)
21:59:52 <sorear> ?pl \x -> ((((((x.).).).).x).)
21:59:53 <lambdabot> (.) . ((.) =<< (.) . (.) . (.) . (.))
22:00:05 <nmessenger> ooh, preeeeeetty
22:00:35 <mgsloan> pretty if you're a multi-eyed arachnid
22:00:52 <nmessenger> there are other kinds?
22:01:02 <mgsloan> good point
22:01:06 <nmessenger> :P
22:01:17 <mgsloan> still, i wanted to emphasize the multi-eyed bit
22:01:30 <mgsloan> (.) . (.) is fun to play with, but beyond that, i dunno
22:01:42 <nmessenger> looks like boobies!
22:02:03 <sieni> also (.)(.) is a valid Haskell function
22:02:17 <mgsloan> (.) . (.) .
22:02:17 <mgsloan> (.) . (.) .
22:02:17 <mgsloan> (.) . (.)
22:02:22 <mgsloan> is like a cow or something
22:03:02 * nmessenger cackles heartily
22:03:48 <bd_> @unpl (.).(.)
22:03:48 <lambdabot> (\ i b c f -> i (b c f))
22:04:00 <bd_> @unpl ((.).(.)).((.).(.))
22:04:00 <lambdabot> (\ o b c f i l -> o (b c f i l))
22:04:04 <sieni> @unpl (.)(.)
22:04:05 <lambdabot> (\ b c e f -> b c (e f))
22:04:14 <sorear> @. pl yow
22:04:14 <lambdabot> (line 1, column 27):
22:04:14 <lambdabot> unexpected ","
22:04:14 <lambdabot> expecting variable, "(", operator or end of input
22:04:18 <sieni> @unpl (.)(.).
22:04:18 <lambdabot> SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 8}: Parse error
22:04:48 <mgsloan> :O
22:05:20 <nmessenger> @unpl ((.)(.).)
22:05:20 <lambdabot> (\ g j c e f -> g j c (e f))
22:05:41 <nmessenger> how does she pick those names?
22:06:18 <sorear> @. unpl run cycle "(.)"
22:06:20 <lambdabot> SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 2}: Improperly terminated string
22:06:42 <sorear> @. unpl run concat $ replicate 20 "(.)"
22:06:43 <lambdabot> "(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)"
22:06:49 <mgsloan> aw
22:07:07 <sorear> @. unpl {. read run concat $ replicate 20 "(.)"}
22:07:07 <lambdabot> compose module failed: IRCRaised Parse error: "{."
22:07:44 <sorear> Tcl-style quoting should be added to LB...
22:08:02 <sorear> @unpl (.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)
22:08:02 <lambdabot> (\ fm fo fp fv fy -> fm (fo fp fv fy))
22:08:06 <sorear> in the meantime
22:08:35 <sorear> @unpl (.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.)
22:08:36 <lambdabot> (\ cj b c f i l o r u x aa ad ag aj am aq at aw az bc bf bi bl bo br bu bx ca cd cg -> cj (b c f i l o r u x aa ad ag aj am aq at aw az bc bf bi bl bo br bu bx ca cd cg))
22:09:01 <mgsloan> wow I might just use that one
22:09:06 <sorear> oooh, looks like I got around the line chopper...
22:09:13 <sorear> @unpl (.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.)
22:09:16 <lambdabot> (\ hi b c f i l o r u x aa ad ag aj am aq at aw az bc bf bi bl bo br bu bx ca cd cg cj cm cp cs cv cy db de dh dk dn dq dt dw dz ec ef ei el eo er eu ex fa fd fg fj fm fp fs fv fy gb ge gh gk gn gq
22:09:16 <lambdabot> gt gw gz hc hf -> hi (b c f i l o r u x aa ad ag aj am aq at aw az bc bf bi bl bo br bu bx ca cd cg cj cm cp cs cv cy db de dh dk dn dq dt dw dz ec ef ei el eo er eu ex fa fd fg fj fm fp fs fv fy gb
22:09:16 <lambdabot> ge gh gk gn gq gt gw gz hc hf))
22:09:27 <sorear> @unpl (.).(.).(.).(.).(.).(.).(.).(.).(+).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.).(.)
22:09:30 <lambdabot> (\ hf b c f i l o r u x -> (\ z aa ad ag aj am aq at aw az bc bf bi bl bo br bu bx ca cd cg cj cm cp cs cv cy db de dh dk dn dq dt dw dz ec ef ei el eo er eu ex fa fd fg fj fm fp fs fv fy gb ge gh
22:09:30 <lambdabot> gk gn gq gt gw gz hc -> hf (z aa ad ag aj am aq at aw az bc bf bi bl bo br bu bx ca cd cg cj cm cp cs cv cy db de dh dk dn dq dt dw dz ec ef ei el eo er eu ex fa fd fg fj fm fp fs fv fy gb ge gh gk
22:09:30 <lambdabot> gn gq gt gw gz hc)) + (b c f i l o r u x))
22:09:56 <nmessenger> @pl \a b c d e f g h i j k l m n o p q s t u v w x y z r -> (r (t h i s i s a f i x e d p o i n t c o m b i n a t o r))
22:09:56 <mgsloan> you can almost start to see words
22:10:09 <mgsloan> BC Filorux sounds like a medication
22:10:09 <lambdabot> (((((const .) .) .) .) .) . (((((((const .) .) .) .) .) .) .) . (((((((const .) .) .) .) .) .) .) . (((((((const .) .) .) .) .) .) .) . (((((((((((const .) .) .) .) .) .) .) .) .) .) .) . (((((((((((
22:10:09 <lambdabot> ((const .) .) .) .) .) .) .) .) .) .) .) .) .) . (((((((((((((const .) .) .) .) .) .) .) .) .) .) .) .) .) . (((((((((((((const .) .) .) .) .) .) .) .) .) .) .) .) .) . ((((((((((((((const .) .) .) .
22:10:09 <lambdabot> ) .) .) .) .) .) .) .) .) .) .) . ((((((((((((((const .) .) .) .) .) .) .) .) .) .) .) .) .) .) . ((((((((((((((ap id .) .) .) .) .) .) .) .) .) .) .) .) .) .) . flip (flip . (flip .) . ((flip .) .)
22:10:09 <lambdabot> . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . (((((((flip .) .) .) .) .) .) .) . ((((((((flip .) .) .) .) .) .) .) .) . (((((((((ap .) .) .) .)
22:10:12 <lambdabot>  .) .) .) .) .) . ((((((((((flip .) .) .) .) .) .) .) .) .) .) . (((((((((((flip .) .) .) .) .) .) .) .) .) .) .) . ((((((((((((flip .) .) .) .) .) .) .) .) .) .) .) .) . (((((((((((((flip .) .) .) .
22:10:15 <lambdabot> [24 @more lines]
22:10:17 <lambdabot> optimization suspended, use @pl-resume to continue.
22:10:28 <nmessenger> um, sorry?
22:10:44 <sorear> LB spamgen!
22:11:24 <sorear> @pl-resume
22:11:31 <nmessenger> oh noes!
22:11:40 <lambdabot> (((((const .) .) .) .) .) . (((((((const .) .) .) .) .) .) .) . (((((((const .) .) .) .) .) .) .) . (((((((const .) .) .) .) .) .) .) . (((((((((((const .) .) .) .) .) .) .) .) .) .) .) . (((((((((((
22:11:40 <lambdabot> ((const .) .) .) .) .) .) .) .) .) .) .) .) .) . (((((((((((((const .) .) .) .) .) .) .) .) .) .) .) .) .) . (((((((((((((const .) .) .) .) .) .) .) .) .) .) .) .) .) . ((((((((((((((const .) .) .) .
22:11:40 <lambdabot> ) .) .) .) .) .) .) .) .) .) .) . ((((((((((((((const .) .) .) .) .) .) .) .) .) .) .) .) .) .) . ((((((((((((((ap id .) .) .) .) .) .) .) .) .) .) .) .) .) .) . flip (flip . (flip .) . ((flip .) .)
22:11:40 <lambdabot> . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . (((((((flip .) .) .) .) .) .) .) . ((((((((flip .) .) .) .) .) .) .) .) . (((((((((ap .) .) .) .)
22:11:43 <lambdabot>  .) .) .) .) .) . ((((((((((flip .) .) .) .) .) .) .) .) .) .) . (((((((((((flip .) .) .) .) .) .) .) .) .) .) .) . ((((((((((((flip .) .) .) .) .) .) .) .) .) .) .) .) . (((((((((((((flip .) .) .) .
22:11:46 <lambdabot> [24 @more lines]
22:11:48 <lambdabot> optimization suspended, use @pl-resume to continue.
22:11:53 <mgsloan> 0-o
22:11:58 <nmessenger> @more
22:12:02 <mgsloan> it just did the same thing
22:12:33 <nmessenger> lambdabot?
22:12:41 <nmessenger> you okay?
22:12:48 <mgsloan> lol
22:12:56 <mgsloan> > 1 + 1 --?
22:12:56 <lambdabot>  Parse error
22:13:16 <mgsloan> looks to be as pedantic as ever
22:13:22 <sorear> > 1 + 1 -- ?
22:13:23 <lambdabot>  2
22:13:42 <mgsloan> yeah, i guess --? could be an operator
22:13:53 <gravity> What is this?
22:14:06 <nmessenger> An IRC channel
22:14:10 <LoganCapaldo> what's the precedence number for + ?
22:14:12 <mgsloan> > let (--?) = (+) in 1 --? 3
22:14:14 <lambdabot>  4
22:14:29 <sorear> :i (+)
22:14:39 <nmessenger> no :info :(
22:14:43 <sorear> in your friendly neighborhood GHCi
22:14:49 <LoganCapaldo> thanks
22:15:00 <sorear> iirc 3
22:15:08 <LoganCapaldo> 6 fwiw
22:15:38 <mgsloan> > let (---) = const . negate in 5 --- 13
22:15:38 <lambdabot>  Parse error
22:15:44 <mgsloan> ahwell
22:16:45 <sorear> let (==) = (/=) in True == False
22:16:46 <LoganCapaldo> ?instances Floating
22:16:47 <lambdabot> Double, Float
22:16:54 <LoganCapaldo> ?instances Fractional
22:16:55 <lambdabot> Double, Float
22:17:00 <LoganCapaldo> hmmm
22:17:04 <LoganCapaldo> fine
22:17:06 <sorear> > let (==) = (/=) in "fact" == "government propaganda"
22:17:07 <lambdabot>  True
22:17:09 <nmessenger> sorear commits blasphemy upon the holiness of Eq!
22:17:43 <sorear> Yes! I CAN change truth!
22:17:50 <sorear> (locally)
22:18:08 <nmessenger> Story of the world, that.
22:19:01 <LoganCapaldo> Yay! I made the quadractic formula from early in the list monad and defined a +- operator
22:20:02 <sorear> not a ± operator?
22:20:08 <LoganCapaldo> ooooo
22:20:14 * LoganCapaldo copies and pastes
22:20:25 <sorear> man latin1
22:20:38 <sorear> Alt-Numpad works in linux
22:20:43 <nmessenger> man page for latin1 not found.
22:20:58 <LoganCapaldo> Option-Shift-=
22:21:16 <sorear> > let a ± b = [a + b, a - b] in 2 ± 3
22:21:16 <lambdabot>  Illegal character ''\177''
22:21:26 <nmessenger> :(
22:21:51 <sorear> LB *really* needs to support UTF-8 :(
22:22:32 * LoganCapaldo makes a sad face
22:23:35 <mgsloan> alright who here is fairly familiar with the codebase? like recently moved the irc-stuff-into-a-plugin-familiar.  They should be able to handle it
22:23:51 * mgsloan pokes sorear
22:23:57 <allbery_b> heh
22:26:06 * nmessenger looks for a skull-and-crossbones using Windows' charmap.  He fails.
22:26:45 <mgsloan> unicode should have inline svg
22:26:52 <sorear> hehehe
22:26:53 * nmessenger wanted to define it as bottom.
22:26:57 <LoganCapaldo> ghci does not want to lex Â±
22:27:00 <LoganCapaldo> :(
22:27:31 <sorear> I've seen some comment on support for unicode operators, (e.g. for U-nion)
22:27:52 <mgsloan> yep, i think it actually has that
22:28:05 <nmessenger> "it" being GHC?
22:28:15 <mgsloan> nah, it being the unicode spec(s)
22:28:15 <sorear> my ghci-head lexes Â± just fine...
22:28:29 <LoganCapaldo> that's what I get for using my lame ghci
22:28:35 <mgsloan> the one inside your head doesn't count
22:28:46 <allbery_b> I thought someone said ac couple days ago that ghci 6.6 didn't handle utf8
22:28:49 <sorear> and my 6.6
22:28:54 <allbery_b> and fo course LB would be 6.5
22:28:59 <allbery_b> hm
22:29:01 <sorear> it does, and that's the problem
22:29:18 <nmessenger> ?version
22:29:19 <lambdabot> lambdabot 4p307, GHC 6.5 (OpenBSD i386)
22:29:19 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
22:29:35 <mgsloan> I don't think lambdabot's problem has anything to do with its ghc version
22:29:37 <sorear> the GHC IO libraries don't do UTF8 - only ISO-8859-1
22:29:54 <sorear> Lambdabot runs fine on 6.6
22:30:05 <mgsloan> does it? huh
22:30:12 <sorear> however, the library used to implement > foo doesn't.
22:30:14 <mgsloan> I figured it was a prob with the irc
22:30:54 <LoganCapaldo> well my 6.4.1 doesn't like Â± in either UTF8 or ISO-8859-1
22:31:04 <sorear> Well it *compiles* fine on 6.6; I don't think I tried running the unmangled version.
22:32:35 <LoganCapaldo> let (=) = (â ) in 1 = 2
22:33:13 <LoganCapaldo> > let { (â ) = (/=); (=) = (â ) } in 1 = 2
22:33:14 <lambdabot>  Illegal character ''\137''
22:33:27 <sorear> heh - that's illegal, = is a reservedop in the Haskell Report
22:33:34 <LoganCapaldo> doh
22:33:37 <LoganCapaldo> I meant ==
22:33:48 <LoganCapaldo> > let { (â ) = (/=); (==) = (â ) } in 1 == 2
22:33:49 <lambdabot>  Illegal character ''\137''
22:33:51 <sorear> what's \137 supposed to be?
22:34:00 <sorear> (it isn't in my console font)
22:34:12 <LoganCapaldo>  /=
22:34:20 <LoganCapaldo> but with the slash thru the equal
22:34:35 <nmessenger> random question for anyone: when stating in prose that two functions are equivalent, do you use = or ==?
22:34:44 <mgsloan> unicode union could handle that fairly well
22:34:58 <LoganCapaldo> I'd use = unless I had a good reason not to
22:35:02 <mgsloan> I use <=>
22:35:09 <nmessenger> :t <=>
22:35:10 <lambdabot> parse error on input `<=>'
22:35:15 <nmessenger> :t (<=>)
22:35:16 <mgsloan> even though that's the spaceship operator
22:35:16 <lambdabot> Not in scope: `<=>'
22:35:23 <allbery_b> no spaceship operator in haskell:)
22:35:26 <mgsloan> what do you mean by prose?
22:35:37 <nmessenger> written stuff
22:35:54 <nmessenger> informal usually
22:36:01 <mgsloan> ah, yeah, i use <=>.  It gives the feeling of equivalence and interchangeability
22:36:25 <sorear> I use <===> with a nondeterministically chosen count of ='s.
22:36:34 <mgsloan> = and == are too overloaded
22:36:37 <nmessenger> <==================================================>
22:36:38 <sorear> ?spell nondeterministically
22:36:38 <lambdabot> nondeterministically
22:36:57 <nmessenger> to REALLY emphasize things
22:37:04 * mgsloan remembers arguing back in the day that = should be both equality and variable-set
22:37:13 <allbery_b> ~= with the ~ atop the =
22:37:20 <nmessenger> variable-set?  What is that?  ;P
22:37:21 <LoganCapaldo> â
22:37:36 <mgsloan> nondetirmineistic shpelling
22:38:08 <mgsloan> nmessenger: heh
22:38:22 <LoganCapaldo> \leftrightarrow
22:38:31 <LoganCapaldo> I mean \Leftrightarrow
22:38:44 <LoganCapaldo> or \Longleftrightarrow
22:39:03 <LoganCapaldo> or \equiv
22:39:04 <LoganCapaldo> heh
22:39:07 <LoganCapaldo> go latex
22:39:16 <mgsloan> there's a suggestion for that unofficial new prelude thing - replace compare with <=>
22:39:20 <nmessenger> 21d4
22:42:34 <LoganCapaldo> @pl (\x y -> [x + y, x -y])
22:42:36 <lambdabot> ap (ap . ((:) .) . (+)) (flip flip [] . ((:) .) . (-))
22:42:38 <mgsloan> > 1 < 2 < 3
22:42:38 <lambdabot>    precedence parsing error
22:42:40 <lambdabot>     cannot mix `(<)' [infix 4] and `(<)' [i...
22:42:46 <mgsloan> would be nice to be able to do that
22:43:03 <LoganCapaldo> doesn't python do that>
22:43:04 <LoganCapaldo> ?
22:43:46 <nmessenger> Huh?  Even if you qualify with parens, it'd be a type error:
22:43:50 <nmessenger> > (1 < 2) < 3
22:43:51 <lambdabot>  add an instance declaration for (Num Bool)
22:44:08 <nmessenger> or do you mean the shorthand for:
22:44:12 <LoganCapaldo> nmessenger: (<<) :: a -> a -> a -> Bool
22:44:14 <mgsloan> yeah, its shorthand
22:44:17 <nmessenger> > 1 < 2 && 2 < 3
22:44:19 <lambdabot>  True
22:44:31 <allbery_b> icon used to do that.  of course it didn't have true/false so much as succeed/fail
22:44:51 <LoganCapaldo> I keep wanting to play with icon
22:45:18 <nmessenger> :t inRange
22:45:19 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Bool
22:46:00 <nmessenger> ?pl \x lb ub -> inRange (lb, ub) x
22:46:01 <lambdabot> flip (flip . (inRange .) . (,))
22:46:11 <nmessenger> ?pl \lb x ub -> inRange (lb, ub) x
22:46:11 <lambdabot> flip . (inRange .) . (,)
22:46:39 <nmessenger> let fromTo = flip . (inRange .) . (,) in fromTo 1 2 3
22:46:44 <nmessenger> > let fromTo = flip . (inRange .) . (,) in fromTo 1 2 3
22:46:46 <lambdabot>  True
22:46:49 <allbery_b> come to think of it, you could simulate that with Maybe, couldn't you?  by treating Nothing as false
22:47:21 <allbery_b> it'd require rewiring everything though
22:47:55 <nmessenger> maybe a syntactic extension for tertiary operators?
22:48:13 <sorear> Unneccessary.
22:48:27 <nmessenger> so?
22:48:33 <nmessenger> :P
22:48:33 <sorear> I've thought of a far more general extension for the deferred precedence parsing
22:48:39 <mgsloan> > let a<b = if a<b then Just True else Nothing in 1 < 2 < 3
22:48:40 <lambdabot>  Couldn't match `Bool' against `Maybe a'
22:48:54 <mgsloan> didn't expect that to work, but wanted to see the error..
22:49:30 <nmessenger> (<) is available in its definition
22:49:34 <allbery_b> (Just n) < (Just m) would return Nothing or Just m, which could then chain with another comparison.  that's roughly how Icon handled it
22:50:14 <mgsloan> > let (Just a)<(Just b) = if a<b then Just True else Nothing; _ < _  = Nothing in (Just 1) < (Just 2) < (Just 3)
22:50:16 <lambdabot>    Occurs check: cannot construct the infinite type: a = Maybe a
22:50:16 <lambdabot>    Expe...
22:50:19 <allbery_b> and Nothing < _ and _ < Nothing both produce Nothing
22:51:12 <mgsloan> > let (Just a)<(Just b) = if a<b then Just a else Nothing; _ < _  = Nothing in (Just 1) < (Just 2) < (Just 3)
22:51:13 <lambdabot>    Occurs check: cannot construct the infinite type: a = Maybe a
22:51:13 <lambdabot>    Expe...
22:51:17 <LoganCapaldo> @paste
22:51:17 <lambdabot> http://paste.lisp.org/new/haskell
22:51:22 <mgsloan> heh
22:51:30 <nmessenger> @check (\x -> (Nothing >> x) == Nothing && (x >> Nothing) == Nothing) :: Maybe Bool -> Bool
22:51:31 <lambdabot>  Add a type signature
22:51:41 <allbery_b> > let Nothing < _ = Nothing; _ < Nothing = Nothing; (Just m) < r@(Just n) = if m < n then r else Nothing in 3 < 4 < 5
22:51:42 <lambdabot>    Occurs check: cannot construct the infinite type: a = Maybe a
22:51:42 <lambdabot>    Expe...
22:51:54 <nmessenger> ??  But there is a type signature!
22:51:55 <sorear> > let a < b = if liftM2 (Prelude.<) a b then Just 0 else Nothing in 1 < 2 < 3
22:51:55 <lambdabot>  Couldn't match `Bool' against `m r'
22:52:05 <lisppaste2> LoganCapaldo pasted "This works for it, sort of" at http://paste.lisp.org/display/33318
22:52:23 <sorear> > let a < b = if liftM2 (Prelude.<) a b then Just 0 else Nothing in Just 1 < Just 2 < Just 3
22:52:24 <lambdabot>  Couldn't match `Bool' against `m r'
22:52:25 <allbery_b> > let Nothing < _ = Nothing; _ < Nothing = Nothing; (Just m) < r@(Just n) = if not m Prelude.< n then r else Nothing in 3 < 4 < 5
22:52:26 <lambdabot>  add an instance declaration for (Num (Maybe Bool))
22:52:38 <allbery_b> > let Nothing < _ = Nothing; _ < Nothing = Nothing; (Just m) < r@(Just n) = if m Prelude.< n then r else Nothing in 3 < 4 < 5
22:52:39 <lambdabot>  add an instance declaration for (Num (Maybe a))
22:52:47 <nmessenger> meh
22:53:00 <allbery_b> > let Nothing < _ = Nothing; _ < Nothing = Nothing; (Just m) < r@(Just n) = if m Prelude.< n then r else Nothing in (Just 3) < (Just 4) < (Just 5)
22:53:01 <lambdabot>  Just 5
22:53:02 <nmessenger> > 3 < 4 && 4 < 5
22:53:04 <lambdabot>  True
22:53:04 <sorear> > let a < b = liftM2 (Prelude.<) a b >>= \x -> if x then Just 0 else Nothing in Just 1 < Just 2 < Just 3
22:53:05 <allbery_b> there we go
22:53:05 <lambdabot>  Just 0
22:53:13 <sorear> > let a < b = liftM2 (Prelude.<) a b >>= \x -> if x then Just 0 else Nothing in Just 1 < Just 2 < Just 3
22:53:15 <lambdabot>  Just 0
22:53:20 <sorear> > let a < b = liftM2 (Prelude.<) a b >>= \x -> if x then Just 0 else Nothing in Just 1 < Just 2 > Just 3
22:53:21 <sorear> d'oh
22:53:21 <lambdabot>  False
22:53:22 <allbery_b> > let Nothing < _ = Nothing; _ < Nothing = Nothing; (Just m) < r@(Just n) = if m Prelude.< n then r else Nothing in (Just 3) < (Just 5) < (Just 4)
22:53:23 <lambdabot>  Nothing
22:53:29 <sorear> > let a < b = liftM2 (Prelude.<) a b >>= \x -> if x then Just 0 else Nothing in Just 1 < Just 3 < Just 2
22:53:30 <lambdabot>  Just 0
22:53:33 <sorear> > let a < b = liftM2 (Prelude.<) a b >>= \x -> if x then Just 0 else Nothing in Just 1 < Just 3 < Just 2
22:53:35 <lambdabot>  Just 0
22:53:56 <sorear> small bug there :)
22:54:28 <allbery_b> yeh, I figured there was a better way to do it but my brain is fried :)
22:55:33 <nmessenger> let adjacentsSatisfy p xs = and (zipWith p xs (tail xs))
22:56:08 <nmessenger> @define adjacentsSatisfy \p xs -> and (zipWith p xs (tail xs))
22:56:08 <lambdabot> adjacentsSatisfy defined
22:56:10 * allbery_b wonders how commit is is to thread state through calculations by using foldl
22:56:23 <nmessenger> adjacentsSatisfy (<) [3,4,5]
22:56:28 <nmessenger> > adjacentsSatisfy (<) [3,4,5]
22:56:29 <lambdabot>  Not in scope: `adjacentsSatisfy'
22:56:32 <_lygaret> !paste
22:56:42 <_lygaret> @paste
22:56:42 <lambdabot> http://paste.lisp.org/new/haskell
22:56:43 <nmessenger> > L.adjacentsSatisfy (<) [3,4,5]
22:56:43 <lambdabot>  Not in scope: `L.adjacentsSatisfy'
22:56:50 <allbery_b> actually it's foldM now becuse I had to bring IO into the mix
22:57:53 <lisppaste2> _lygaret pasted "How to clean up the main function?" at http://paste.lisp.org/display/33320
22:58:18 <_lygaret> Would anyone like to take a crack at explaining a way to clean up the main function in that paste?
22:58:27 <mgsloan> nice
22:58:39 <_lygaret> It's got some fuglyness to it, but I don't know how to handle it differently.
22:59:18 <_lygaret> basically, I get lines from stdin of the form "i j" and have to print out "i j maxcycle"
22:59:26 <sorear> ick!
22:59:32 <sorear> partial functions!
22:59:45 <nmessenger> Looks pretty enough to me
23:00:05 <nmessenger> ('cept for partial functions.  runtime errors = bad)
23:00:19 <nmessenger> but whatever
23:00:29 <_lygaret> er, not main, but problem
23:00:43 <_lygaret> you mean the map?
23:01:37 <mgsloan> if y < (x | 5) then write("y=", y)
23:01:43 <mgsloan> Icon has some pretty stuff
23:02:02 <nmessenger> Do all the lines look like i j?
23:02:13 <nmessenger> s/the lines/the input lines/
23:02:26 <_lygaret> yeah, garunteed
23:02:39 <_lygaret> by the judge -
23:02:51 <_lygaret> it's automated testing; input validation isn't required.
23:03:27 <nmessenger> then you might replace (i ++ " " ++ j) with (str) in problem, but other than that I don't see any other obvious changes.
23:03:57 <_lygaret> alright, killer.
23:04:06 <_lygaret> thanks! first time I haven't had issues :D
23:05:41 <sorear> where is max_cycle defined?
23:06:27 <nmessenger> elsewhere, probably :D
23:06:46 <_lygaret> yeah
23:06:54 <sorear> problem str = let [i,j] = map read (words str) in str ++ ' ': show (max_cycle i j)
23:06:58 <_lygaret> later on - I'm pretty comfortable with rest of the problem
23:07:08 <sorear> that better?
23:07:35 <_lygaret> I like that yeah; I didn't know you could do let binding to individual elements in a list.
23:07:50 <nmessenger> [i,j] is sugar for i:j:[]
23:07:55 <sorear> ?pl \str -> let [i,j] = map read (words str) in str ++ ' ': show (max_cycle i j)
23:07:56 <lambdabot> (line 1, column 13):
23:07:56 <lambdabot> unexpected "["
23:07:56 <lambdabot> expecting natural, identifier or "in"
23:08:05 <sorear> ?pl \str -> let i:j:[] = map read (words str) in str ++ ' ': show (max_cycle i j)
23:08:05 <lambdabot> (line 1, column 14):
23:08:05 <lambdabot> unexpected ":"
23:08:05 <lambdabot> expecting letter or digit, pattern or "="
23:08:26 <sorear> ?pl \str -> let l = map read (words str) ; i = l!!0 ; j = l !! 1 in str ++ ' ': show (max_cycle i j)
23:08:39 <lambdabot> ap ((`ap` (!! 1)) . (. (!! 0)) . flip . (. ((((' ' :) . show) .) . flip max_cycle)) . (.) . (++)) (map read . words)
23:08:55 <sorear> ?. unpl pl \str -> let l = map read (words str) ; i = l!!0 ; j = l !! 1 in str ++ ' ': show (max_cycle i j)
23:09:04 <_lygaret> in that case...
23:09:04 <lambdabot> SrcLoc {srcFilename = "<unknown>", srcLine = 2, srcColumn = 1}: Parse error
23:09:29 <_lygaret> problem str = str ++ show (max_cycle i j) where [i, j] = map read words str
23:09:30 <sorear> oooh, pl can generate stuff unpl can't parse?
23:09:49 <sorear> _lygaret: won't work.
23:09:57 <sorear> problem str = str ++ show (max_cycle i j) where [i, j] = map read $ words str
23:10:00 <sorear> ^^^ might.
23:10:12 <_lygaret> parens?
23:10:20 <_lygaret> Thats what $ is for fixing right?
23:10:24 <sorear> words isn't a list.
23:10:28 <sorear> yeah.
23:10:30 <sorear> precedence
23:10:38 <_lygaret> map read (words str)
23:10:48 <sorear> map read words str <===> (map read words) str
23:11:00 <sorear> map read words str <===> (map read words) str <==> ((map read) words) str
23:11:26 <_lygaret> what's better style? map read $ words str or map read (words str)?
23:11:46 <sorear> $, usually
23:11:47 <int-e> depends on who you ask I guess.
23:11:52 <nmessenger> Matter of taste
23:11:52 <sorear> for short things
23:12:12 <_lygaret> hmmm.
23:12:23 <int-e> a third way is  map read . words $ str
23:13:12 <nmessenger> I know that as a newbie, ($) looked scary to me.  I'm comfortable with it now, but I often use parens for clarity.
23:13:37 <_lygaret> Yeah, I'm leaning that way for the same reason nmessenger
23:14:36 <nmessenger> At least once I've been confounded by operator precedence causing weird type errors.
23:14:36 <_lygaret> do you know where documentation for $ is? google has a hard time with the dollar sign
23:14:45 <nmessenger> ?hoogle ($)
23:14:46 <lambdabot> Did you mean: ($)
23:14:46 <lambdabot> Prelude.undefined :: a
23:14:46 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
23:14:53 <nmessenger> ?hoogle $
23:14:53 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
23:14:53 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
23:14:53 <lambdabot> Control.Parallel.Strategies.($|) :: (a -> b) -> Strategy a -> a -> b
23:15:06 <sieni> @pl $
23:15:07 <lambdabot> (line 1, column 1):
23:15:07 <lambdabot> unexpected "$"
23:15:07 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
23:15:08 <_lygaret> killer, hoogle I forgot.
23:15:12 <sieni> @pl ($)
23:15:12 <lambdabot> id
23:15:16 <sieni> there
23:15:17 <sorear> @unpl ($)
23:15:18 <lambdabot> (\ a b -> a b)
23:15:19 <mgsloan> the type basically tells you what it does.  Actually, it does formally i think
23:15:27 <sorear> yes
23:15:27 <mgsloan> theorems for free
23:15:35 <sorear> LB can tell you
23:15:38 <sorear> ?djinn ($)
23:15:39 <lambdabot> Cannot parse command
23:15:42 <sorear> ?djinn id
23:15:42 <lambdabot> -- f cannot be realized.
23:15:45 <mgsloan> hah
23:15:49 <nmessenger> pwned
23:15:51 <mgsloan> ?list
23:15:51 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
23:15:51 <sorear> ?djinn (a -> b) -> a -> b
23:15:52 <lambdabot> f a = a
23:15:59 <int-e> @free id :: a -> a
23:15:59 <lambdabot> f . id = id . f
23:16:15 <sorear> ah, so ?free needs an identifier and ?djinn needs a type.
23:16:15 <mgsloan> ?. djinn type ($)
23:16:17 <lambdabot> f a = a
23:16:19 <mgsloan> ooh
23:16:31 <sorear> ?. djinn type either
23:16:33 <lambdabot> f a b c =
23:16:33 <lambdabot>   case c of
23:16:33 <lambdabot>   Left d -> a d
23:16:33 <lambdabot>   Right e -> b e
23:16:55 <nmessenger> neat
23:17:02 <LoganCapaldo> @djinn Bool -> a -> a -> a
23:17:03 <lambdabot> f a b c =
23:17:03 <lambdabot>   case a of
23:17:03 <lambdabot>   False -> c
23:17:03 <lambdabot>   True -> b
23:17:09 <mgsloan> ?. djinn type Either
23:17:10 <lambdabot> Cannot parse command
23:17:11 <mgsloan> :P
23:17:21 <nmessenger> ?. djinn type catch
23:17:22 <lambdabot> f a _ = a
23:17:23 <_lygaret> hah - sticking with parens.
23:17:23 <sorear> djinn is a theorem prover, using the curry howard isomorphism.
23:17:28 <_lygaret> thank's y'all
23:17:33 <mgsloan> ?. kind Either
23:17:34 <lambdabot> compose module failed: IRCRaised Parse error: "Either"
23:17:37 <sorear> ?. djinn (a -> a) -> a
23:17:37 <lambdabot> compose module failed: IRCRaised Parse error: "(a"
23:17:44 <sorear> ?djinn (a -> a) -> a
23:17:45 <lambdabot> -- f cannot be realized.
23:17:46 <nmessenger> ?. djinn type maybe
23:17:47 <lambdabot> f a b c =
23:17:47 <lambdabot>   case c of
23:17:47 <lambdabot>   Nothing -> a
23:17:47 <lambdabot>   Just d -> b d
23:17:49 <mgsloan> ?. djinn kind Either
23:17:50 <lambdabot> Cannot parse command
23:17:58 <mgsloan> yeah, would be impossible
23:18:11 <LoganCapaldo> @djinn (Enum a, Num b) => a -> b
23:18:12 <lambdabot> Cannot parse command
23:18:14 <sorear> ?djinn (c -> b) -> (a -> b) -> (a,c) -> (b,b)
23:18:14 <lambdabot> f a b (c, d) = (a d, b c)
23:18:29 <LoganCapaldo> @hoogle (Enum a, Num b) => a -> b
23:18:30 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
23:18:30 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
23:18:30 <lambdabot> Control.Monad.Writer.tell :: MonadWriter w m => w -> m ()
23:18:39 <sorear> stream-comonad?
23:18:42 <LoganCapaldo> @hoogle (Enum a, Integral b) => a -> b
23:18:44 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
23:18:44 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
23:18:44 <lambdabot> Control.Monad.Writer.tell :: MonadWriter w m => w -> m ()
23:18:48 <sorear> ?djinn [a] -> [[a]]
23:18:48 <lambdabot> -- f cannot be realized.
23:18:51 <LoganCapaldo> @hoogle (Enum a, Integer b) => a -> b
23:18:52 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
23:18:52 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
23:18:52 <lambdabot> Control.Monad.Writer.tell :: MonadWriter w m => w -> m ()
23:18:58 <LoganCapaldo> lol duh
23:19:04 <sorear> ?list djinn
23:19:04 <lambdabot> djinn provides: djinn djinn-add djinn-del djinn-env djinn-names djinn-clr djinn-ver
23:19:05 <LoganCapaldo> Integer isnt a type class
23:19:10 <nmessenger> ?botsnack
23:19:11 <lambdabot> :)
23:19:13 <int-e> @index fromEnum
23:19:13 <sorear> ?help djinn-add
23:19:13 <lambdabot> djinn-add <expr>.
23:19:13 <lambdabot> Define a new function type or type synonym
23:19:13 <lambdabot> Prelude
23:19:18 <LoganCapaldo> @hoogle (Enum a) => a -> Integer
23:19:18 <lambdabot> Prelude.floatRadix :: RealFloat a => a -> Integer
23:19:19 <lambdabot> Prelude.toInteger :: Integral a => a -> Integer
23:19:21 <int-e> @type fromEnum
23:19:22 <lambdabot> forall a. (Enum a) => a -> Int
23:19:27 <LoganCapaldo> @hoogle (Enum a) => a -> Int
23:19:28 <lambdabot> Prelude.fromEnum :: Enum a => a -> Int
23:19:28 <lambdabot> Data.Map.findIndex :: Ord k => k -> Map k a -> Int
23:19:28 <lambdabot> Prelude.exponent :: RealFloat a => a -> Int
23:19:32 <LoganCapaldo> yay
23:19:42 <LoganCapaldo> the quest is concluded
23:19:43 <nmessenger> ?where hoogle
23:19:43 <lambdabot> http://www.haskell.org/hoogle
23:20:01 <LoganCapaldo> hmm
23:22:41 <shapr> Good Morning #haskell!
23:23:41 <nmessenger> go away!
23:23:45 <shapr> aww
23:23:52 <sorear> Good morning!!!
23:24:09 <nmessenger> Well, you were so friendly sounding, I couldn't resist.
23:24:20 * shapr sniffles piteously
23:24:32 <mgsloan> ?. elite run show ("Greetings sha" ++ "pr")
23:24:33 <lambdabot> "\"GREeTIN9$ sH4Pr\""
23:24:39 <shapr> Everybody says I'm so friendly... so friendly they think I could be a BOT!
23:24:43 * nmessenger apologizes and hugs shapr
23:24:48 * shapr boings happily
23:24:51 * shapr hugs nmessenger 
23:25:09 <shapr> hiya mgsloan
23:25:40 <sieni> shapr: @eval product [1..1000]
23:25:47 <shapr> 0
23:25:56 <nmessenger> ?
23:26:02 <mgsloan> ?elite I think I'll just talk like this for now
23:26:02 <lambdabot> I t|-|InK I'l| jus+ t4Lk LIKE 7|-|iz0rz For NoW
23:26:04 <shapr> See, I'm not a very good bot...
23:26:12 <nmessenger> Ah
23:26:14 <sorear> > product [1 .. 1000] :: Int
23:26:14 <mgsloan> overflow, i think
23:26:15 <lambdabot>  0
23:26:23 <mgsloan> :O
23:26:27 <opqdonut> :D
23:26:28 <shapr> Yeah, I overflow at anything greater than 4
23:26:32 <nmessenger> XD
23:27:08 <_lygaret> @type forever a = a >> forever a
23:27:12 <lambdabot> parse error on input `='
23:27:16 <_lygaret> hah :P nm
23:27:20 <sorear> shapr: I've been inducted!
23:27:36 <allbery_b> hm.  I finished memoizing the time calculations.  only got me a 50% speedup.  I suspect ghc was being smarter than I expected about recognizing that it was recomputing the same times
23:27:46 <shapr> sorear: Cool! Is that like being co-deducted?
23:28:23 <shapr> sorear: You mean inducted into Planet Haskell? lambdabot's list of admins? Or what?
23:28:26 <allbery_b> (or I'm doing something very stupid such that it's spending more time on housekeeping now)
23:28:37 <sorear> !! 1
23:28:46 <shapr> Yeah, I saw that. It's cool!
23:28:47 <nmessenger> 2665 GHC
23:29:50 <shapr> I bought myself some unicycle goodies for christmas.. but I haven't yet coughed up fifty bucks for replacement titanium bolts.
23:29:59 <nmessenger> Random question for anybody: when reading types, how do you pronounce a -> b?
23:30:20 <shapr> I think there's a wiki page about how to speak Haskell.
23:30:26 <nmessenger> I usually say "a to b"
23:30:34 <shapr> But honestly, I don't speak that sort of thing so I don't know.
23:30:53 <mgsloan> a arrow b :)
23:30:58 <sorear> ?who sorear-lambdabot
23:30:59 <lambdabot> Maybe you meant: echo ghc show what wn
23:31:03 <mgsloan> then again i never speak it
23:31:11 <nmessenger> Or if I'm feeling convoluted, "a function that when given an a, produces a b"
23:31:14 <mgsloan> ?speak could be a cool lambdabot ext
23:31:15 <lambdabot> could be a cool lambdabot ext
23:31:18 <mgsloan> lol
23:31:20 <sorear> ack, too many command characters
23:31:31 <mgsloan> ?speak mgsloan++
23:31:31 <lambdabot> Sloan muslin Magellan McLean Malian
23:31:43 <shapr> @quote nmessenger
23:31:44 <lambdabot> nmessenger hasn't said anything memorable
23:31:46 <mgsloan> what is going on
23:31:52 <nmessenger> I'm new here
23:31:57 <shapr> hi nmessenger
23:32:01 <nmessenger> hello
23:32:03 <sorear> ?help speak
23:32:03 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
23:32:13 <shapr> How did you find this branch of lambdaholics anonymous?
23:32:38 <mgsloan> ?speak floopmoop
23:32:38 <lambdabot> Limpopo flipflop foolproof floppy flop
23:32:41 <mgsloan> lol
23:32:47 <mgsloan> that's awesome
23:32:51 <sorear> ?remember shapr How did you find this branch of lambdaholics anonymous?
23:32:58 * shapr grins
23:33:05 * nmessenger thinks hard. He can't remember how he started Haskelling.
23:33:09 <mgsloan> ?speak lambdaholics
23:33:25 <mgsloan> :(
23:33:29 <mgsloan> > 1+2
23:33:31 <lambdabot>  3
23:33:43 <mgsloan> ?speak lambdabot
23:33:44 <lambdabot> lambda bot lambda-bot lambda lambdas lambda's
23:33:59 <nmessenger> badmalt
23:34:04 <mgsloan> ?speak dons
23:34:05 <lambdabot> dons
23:34:09 <nmessenger> obama
23:34:13 <sorear> oh, I get it
23:34:15 <mgsloan> ?speak obama
23:34:15 <lambdabot> ABM IBM AMA abeam ABMs
23:34:20 <mgsloan> I still don't
23:34:25 <sorear> ?speak privledged
23:34:25 <lambdabot> privileged privileges privilege privilege's
23:34:32 <shapr> It's a spell checker, yeah?
23:34:33 <mgsloan> ?speak sorear
23:34:34 <lambdabot> sorer soarer sourer so rear so-rear
23:34:35 <sorear> ?speak is ?spell
23:34:36 <lambdabot> is ?spell
23:34:43 <mgsloan> ohh
23:34:47 <shapr> Oh wait, it's one of those phonetic algorithms?
23:34:51 <shapr> What's it called again?
23:34:55 <mgsloan> except when you can't spell it speaks it back...
23:34:55 <nmessenger> I thought it was an anagram maker
23:35:00 <sorear> Plugin/Spell.gs
23:35:03 <sorear> Plugin/Spell.hs
23:35:12 <shapr> What's the algorithm called? I should remember it...
23:35:18 <nmessenger> Someone should write an @anagram!
23:35:24 <mgsloan> anyway, a haskell -> english converter might be fun
23:35:25 <sorear> IIRC it shells out to aspell.
23:35:25 <shapr> nmessenger: Write it!
23:35:44 <shapr> nmessenger: It'll be easy to do in pure haskell, and you get the thrill of seeing your code in public use!
23:35:46 <mgsloan> @hengl foobar :: noopl -> quat
23:35:47 <lambdabot> Unknown command, try @list
23:35:49 <shapr> @seen dons
23:35:49 <sorear> I've gotten into the lambdabot hacking game.
23:35:49 <lambdabot> dons is in #ghc, #haskell-overflow, #haskell and #haskell.hac07. I don't know when dons last spoke.
23:35:58 <nmessenger> shapr: I've only written a couple toys.  I guess a lambdabot plugin would be good practice.
23:36:01 <sorear> dons is on vacation this week.
23:36:10 <shapr> Yeah, lambdabot plugin is a fun way to get started.
23:36:10 <nmessenger> shapr: where do I start?
23:36:16 <int-e> @version
23:36:17 <shapr> Grab the source!
23:36:17 <lambdabot> lambdabot 4p307, GHC 6.5 (OpenBSD i386)
23:36:17 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
23:36:34 <sorear> so I have no idea how far away from acceptable my hacked lambdabot has gotten :(
23:36:45 <shapr> Do you submit patches to dons?
23:36:55 <nmessenger> who me?
23:37:09 <int-e> @karma sorear
23:37:10 <lambdabot> sorear has a karma of 6
23:37:26 <shapr> nmessenger: Nah, I was asking sorear.
23:37:33 <shapr> nmessenger: But you too can submit patches to dons
23:37:51 <shapr> aha, I was thinking of Soundex
23:38:02 <shapr> @wikipedia Soundex
23:38:05 <lambdabot> No Result Found.
23:38:10 <shapr> http://en.wikipedia.org/wiki/Soundex :-P
23:38:52 <sorear> i've sent him a tweak to make Lib/Parser.hs compile on HEAD, and a patch that extends the karma special casing from C++ to c++.
23:39:12 <shapr> I haven't hacked on lambdabot in years, though I keep meaning to get back to it.
23:39:28 <sorear> so far I've hoarded my much more controversial change that separates IRC out into an ordinary plugin.
23:39:36 <shapr> Submit it!
23:39:45 <shapr> It's a logical step, and one I'd like to use.
23:39:51 <sorear> so, my lambdabot can quite easily have multiple servers
23:40:02 <shapr> I'd like lambdabot to have IRC, Jabber, etc as ordinary plugins.
23:40:05 * allbery_b wonders if karma should just ignore case
23:40:14 <sorear> Good idea!
23:40:50 <shapr> I think all of lambdabot's IRC-nick or IRC-channel input should ignore case.
23:40:54 <allbery_b> @karma Haskell
23:40:54 <lambdabot> Haskell has a karma of 8
23:40:58 <allbery_b> @karma haskell
23:40:58 <lambdabot> haskell has a karma of 15
23:41:00 <shapr> @karma
23:41:01 <lambdabot> You have a karma of 34
23:41:03 <allbery_b> ...silly
23:41:03 <shapr> w00
23:42:13 <mgsloan> ?hoggle [(a,a)] -> [a] -> [a]
23:42:14 <lambdabot> No matches, try a more general search
23:42:23 <mgsloan> ?hoggle [(a,b)] -> [a] -> [b]
23:42:23 <lambdabot> No matches, try a more general search
23:42:24 <nmessenger> hoggle?
23:42:28 <mgsloan> heh
23:42:44 <mgsloan> just taking advantage of the spell-checked command words :)
23:42:54 <nmessenger> lambdabot++
23:43:20 <mgsloan> ?hoogel substitute
23:43:21 <lambdabot> Maybe you meant: hoogle hoogle+
23:43:30 <mgsloan> hmm hoogle+ eh
23:43:36 <nmessenger> ?help hoogle+
23:43:36 <lambdabot> hoogle <expr>. Haskell API Search for either names, or types.
23:43:47 <nmessenger> ?help hoogle
23:43:47 <lambdabot> hoogle <expr>. Haskell API Search for either names, or types.
23:43:53 <nmessenger> ?
23:44:10 <mgsloan> ?hoogle+ (a->b->b) -> b -> [a] -> b
23:44:33 <nmessenger> lambdabot?
23:44:38 <mgsloan> > 1+1
23:44:40 <lambdabot>  2
23:44:43 <mgsloan> hmm
23:44:47 <nmessenger> I think you made her angry, mgsloan
23:44:56 <hyrax42> > hoogle (a -> b -> b) -> b -> [a] -> b
23:44:56 <lambdabot>  Parse error
23:45:02 <hyrax42> ?hoogle (a -> b -> b) -> b -> [a] -> b
23:45:03 <lambdabot> Prelude.foldr :: (a -> b -> b) -> b -> [a] -> b
23:45:06 <mgsloan> ?vixen are you angry?
23:45:06 <lambdabot> no, i'm not angry at all
23:45:13 <mgsloan> see, she's not angry at all
23:45:16 <hyrax42> ?hoogle+ (a -> b -> b) -> b -> [a] -> b
23:45:26 <nmessenger> well that's good
23:45:28 <hyrax42> seems like + = ignore
23:45:32 <sorear> did the Emacs folks *have* to put C-x next to C-z ?
23:45:33 <hyrax42> ?help vixen
23:45:34 <lambdabot> vixen <phrase>. Sergeant Curry's lonely hearts club
23:45:45 <mgsloan> lol
23:45:51 <hyrax42> sorear: ummm? that's more the fault of qwerty guy no?
23:45:58 <hyrax42> :p
23:46:00 <mgsloan> ?help vixen
23:46:01 <lambdabot> vixen <phrase>. Sergeant Curry's lonely hearts club
23:46:02 <nmessenger> sorear: I think the qwerty folks... darnit hyrax!
23:46:11 <mgsloan> aw, it should vixenize the help message
23:46:22 <mbrandt> anyone care to help a noob?
23:46:28 <sorear> ?. vixen help vixen
23:46:28 <lambdabot> i am a bit of a vixen :)
23:46:28 <shapr> Oh, I ordered myself a copy of Richard Hamming's "The Art of Science and Engineering: Learning to Learn" for only $80 USD! My librarian mother found it for me.
23:46:36 <nmessenger> mbrandt: indubitably!
23:46:37 <hyrax42> mbrandt: ask away, and find out
23:46:39 <sorear> yay
23:46:44 <mgsloan> ?. vixen vixen hello
23:46:44 <lambdabot> Math is hard. Let's go shopping.
23:46:49 <shapr> @quote samc
23:46:50 <lambdabot>  monads are hard, let's go shopping
23:47:05 <mgsloan> :O
23:47:09 <sorear> ?. vixen yow
23:47:10 <lambdabot> really!
23:47:15 <mgsloan> that contextual quote thing is so cool
23:47:23 <mbrandt> I'm getting stuck understanding how to get IO objects into regular space...
23:47:30 <mgsloan> heh
23:47:31 <allbery_b> you don't, mostly
23:47:37 <hyrax42> mbrandt: you can't
23:47:43 <hyrax42> or "shouldn't" at the very least
23:47:46 <mgsloan> yeah, pretty much everyone asks that question at some point
23:47:46 <nmessenger> mbrandt: mostly, you bring regular space things up into IO
23:48:08 <hyrax42> yup... for a while it seems like everything you do will be tainted by IO
23:48:17 <shapr> The sad thing is that "math is hard, let's go shopping" is a quote from a talking barbie doll.
23:48:20 <mgsloan> yeah, IO is viral like that, thankfully you can lift functions rather than letting it spread to all code
23:48:21 <mbrandt> so what I was trying to do was create a directory scan like this: data FileDescriptor = File String | Dir String [FileDescriptor]
23:48:34 <nmessenger> ?paste
23:48:34 <lambdabot> http://paste.lisp.org/new/haskell
23:48:37 <mgsloan> ?. vixen yow
23:48:38 <lambdabot> that's okay, i don't know either
23:48:56 <nornagon> ?yow
23:48:56 <mbrandt> but the FileDescriptor thing is IO because I check to see if it is a file or directory of course...
23:48:57 <lambdabot> ... I have read the INSTRUCTIONS ...
23:49:08 <sorear> Is everything ?vixen generates a quote from talking barbies?
23:49:40 <shapr> No, vixen is a Haskell port of a Visual Basic program called Vixenlove.
23:49:52 <hyrax42> mbrandt, paste your code
23:49:55 <hyrax42> ?paste
23:49:56 <lambdabot> http://paste.lisp.org/new/haskell
23:50:12 <mbrandt> import System.Directory
23:50:12 <mbrandt> data FileDescriptor = File String | Dir String [FileDescriptor]
23:50:12 <mbrandt> getDirList dname = do
23:50:12 <mbrandt>     dirlist <- getDirectoryContents dname
23:50:12 <mbrandt>     return $ map examine $ filter notdotordotdot dirlist
23:50:12 <mbrandt>     where
23:50:14 <mbrandt>         notdotordotdot "." = False
23:50:16 <mbrandt>         notdotordotdot ".." = False
23:50:18 <mbrandt>         notdotordotdot _ = True
23:50:19 <shapr> It matches against a bunch of regular expressions to find a result.
23:50:20 <mbrandt>         examine fname = do
23:50:22 <mbrandt>             let fullpath = dname ++ "/" ++ fname
23:50:24 <mbrandt>             isdir <- doesDirectoryExist fullpath
23:50:24 <sorear> and read RFC 2813 section 5.8 before pasting anything into IRC
23:50:26 <mbrandt>             if isdir then
23:50:28 <mbrandt>                 do
23:50:28 <shapr> mbrandt: I think he meant "paste it on that paste url"
23:50:30 <mbrandt>                     dirs <- getDirList fullpath
23:50:31 <nmessenger> Gah, he meant at the pastebin!
23:50:32 <mbrandt>                     return $ Dir fname dirs
23:50:34 <mbrandt>                 else
23:50:36 <mbrandt>                     return $ File fname
23:50:44 <shapr> mbrandt: It's considered impolite to paste more than three lines of source code into this channel.
23:50:46 <sorear> and read RFC 2813 section 5.8 before pasting anything into IRC
23:50:49 <mbrandt> I'm an irc noob too...
23:50:59 <hyrax42> ?paste
23:51:00 <lambdabot> http://paste.lisp.org/new/haskell
23:51:02 <sorear> automatic flood control!
23:51:06 <nmessenger> everyone makes a mistake or too.
23:51:09 * shapr swims!
23:51:18 <shapr> Yeah, you gotta learn somewhere.
23:51:28 <shapr> First time is no problem.
23:51:29 * nmessenger laughs at his unintentional misspelling.
23:51:43 <lisppaste2> mbrandt pasted "dir scanner (IO question)" at http://paste.lisp.org/display/33322
23:52:06 <mbrandt> I get it now..
23:52:38 <shapr> mbrandt: So, how did you get into Haskell? Business or pleasure?
23:52:51 <sorear> try using mapM
23:52:53 <sorear> ?type mapM
23:52:53 <mbrandt> just trying to learn something new...
23:52:54 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
23:52:59 <mgsloan> cool
23:53:16 <sorear> :t (mapM :: (a -> IO b) -> [a] -> IO [b])
23:53:18 <lambdabot> forall a b. (a -> IO b) -> [a] -> IO [b]
23:53:19 <shapr> mbrandt: Good motivation
23:53:21 * hyrax42 thinks that counts as pleasure
23:53:41 <hyrax42> it is indeed
23:53:50 <sorear> agreed.
23:54:11 <hyrax42> so mbrandt, what is the thing that's got you troubled
23:54:39 <Shimei> So, I'm reading a chapter on STM by Peyton-Jones (http://haskell.org/haskellwiki/Talk:SantaClausProblem), and I'm finding his little Haskell intro for it explains monads better than a lot of tutorials. :p
23:54:40 <lambdabot> Title: Talk:SantaClausProblem) - HaskellWiki
23:55:13 <sorear> yes!  rc-file loading is now working in sorear-lambdabot
23:55:25 <mbrandt> mapM moves the IO around, but I still seem to have an extra one...
23:55:28 <shapr> Shimei: Different explanations work for different people, it's best to read a bunch of them and see what works for you.
23:55:40 <shapr> That's my opinion, at least.
23:56:02 <mbrandt> Now I have IO (IO [FileDescriptor]) when I should have IO [FileDescriptor]
23:56:05 <hyrax42> shapr: I agree
23:56:05 <nmessenger> map examine produces a [IO FileDescriptor], mapM changes it to IO [FileDescriptor].  The IO is already there, so the return is unnecessary
23:56:05 <shapr> I liked "You could have invented monads." and "Monads as Containers."
23:56:13 <hyrax42> mbrandt: join
23:56:17 <hyrax42> ?type join
23:56:18 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
23:56:29 <hyrax42> at least I think that'll work as expected for IO?
23:56:33 <mbrandt> thanx nmessenger
23:56:41 <dabblego> > foldl []
23:56:42 <lambdabot>    Expecting a function type, but found `[a]'
23:56:42 <lambdabot>    Expected type: a -> b -...
23:56:48 <dabblego> er
23:56:49 <nmessenger> :t foldM
23:56:50 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
23:56:50 <shapr> But Steve Atkins' step by step refactoring of a bunch of explicit state passing code into a state monad was also helpful.
23:56:52 <dabblego> ?type foldl
23:56:53 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
23:56:55 <mbrandt> works!
23:56:56 <hyrax42> I learned from "Monads as Containers"
23:56:59 <dabblego> > foldl (+) 7 []
23:57:00 <lambdabot>  7
23:57:11 <nmessenger> mbrandt: yay!
23:57:13 <hyrax42> and didn't get the "Monads as Computation" analogy until I spotted it myself
23:57:16 <Shimei> shapr: I haven't read the former, but I liked the container one too. I find that CS concepts in general need different metaphors for people to "get" them (e.g. pointers is one I've seen).
23:57:19 <dufflebunk> I learned form soemthign that didn't use the do notation... the do notation just confused me
23:57:30 <hyrax42> in a recursion theory part of a class I was doing
23:57:49 <shapr> I think syntaxfree also said that the do-notation was confusing.
23:58:08 <sorear> I just directly "get" mathematical structures.  I think of monads as like rings, only a bit fancier.
23:58:12 <nmessenger> shapr: and I agreed to such on the programming.reddit.com thread.
23:58:12 <hyrax42> essentially spotted the Maybe monad
23:58:39 <shankys_> Could someone tell me how to elegantly go from String to Int?
23:58:45 <shapr> I wish we had some automated rewriting tools that could turn do-notation into explicit >>= usage.
23:58:46 <shankys_> I hoogled it and didn't find anything
23:58:50 <shapr> shankys_: read
23:58:51 <hyrax42> shankys_: read
23:58:56 <shapr> > read "55" :: Int
23:58:57 <nmessenger> http://programming.reddit.com/info/ujjo/comments/cuk37
23:58:57 <lambdabot>  55
23:58:58 <lambdabot> Title: Haskell: Do-notation considered harmful (reddit.com)
23:59:00 <hyrax42> > read "5" :: Int
23:59:02 <lambdabot>  5
23:59:05 <hyrax42> ha
23:59:05 <shankys_> Oh, ok thanks
23:59:23 <allbery_b> hoogle wouldn't have helped because:
23:59:29 <shankys_> So read converts string to anything?
23:59:29 <allbery_b> ?type read
23:59:30 <lambdabot> forall a. (Read a) => String -> a
23:59:31 <shapr> After I used >>= for a week or two, I switched to do notation.
23:59:50 <allbery_b> any type which has an instance of the Read class
23:59:59 <shapr> shankys_: Anything that has a Read instance, yeah. If you make up your own datatypes, they won't automatically have that instance.
