00:00:13 <shankys_> Ok, thanks guys
00:00:15 <hyrax42> nmessenger: I would agree that things should be taught using (>>=) first
00:00:16 <shapr> But GHC can derive an instance for you.
00:00:29 <shankys_> Back to hacking on the Haskell web framework :)
00:00:31 <hyrax42> or should be learned
00:00:40 <nmessenger> hyrax42: it is scary-looking though
00:00:41 <shapr> shankys_: I want to see it!
00:00:54 <hyrax42> nmessenger: I know, I got a fight/flight response when I saw those operators
00:00:57 <sorear> #help
00:01:05 <hyrax42> lasted till Cale pointed me to Monads as Containers
00:01:07 <shankys_> shapr: We're launching a news site that's written purely in Haskell in probably 1 weekish
00:01:11 <shapr> cool!
00:01:14 <shapr> Will the source be available?
00:01:35 <int-e> @undo do age <- getLine; putStr ("You're "++age++"years old! \n"); putStr "Congratulations! \n"
00:01:36 <lambdabot> getLine >>= \ age -> putStr ("You're " ++ age ++ "years old! \n") >> putStr "Congratulations! \n"
00:01:37 <shapr> Monads are just an abstraction, like objects are just an abstraction. They're not scary, I promise.
00:01:43 <hyrax42> nmessenger: but it seems people often introduce IO early on with do notation
00:01:43 <Shimei> shankys_: Where will you announce this? I'm interested.
00:01:44 <nmessenger> > let shankys_ = "one weekish!"
00:01:44 <lambdabot>  Parse error
00:01:48 <shapr> int-e: oh cool!
00:01:51 <shankys_> shapr: Not to the news site unfortunately, but I will be releasing the framework, and anything that's not specific to the news site under the BSD license
00:01:51 <lisppaste2> mgsloan annotated #33322 with "Not better, just smaller, and probably syntax-errory" at http://paste.lisp.org/display/33322#1
00:01:57 <shapr> shankys_: awesome!
00:02:02 <hyrax42> which leads to incorrect expectations
00:02:20 <nmessenger> I wish I had @undo and @redo
00:02:33 <shapr> I think IO and State are bad ways to start with monads.
00:02:42 <hyrax42> so if I was teaching someone, I'd go with Maybe and using (>>=)
00:02:45 <shankys_> Shimei: I'll be sure to announce it in a number of places including this channel
00:02:56 <hyrax42> Maybe is easy to understand from containers and computation view points
00:02:58 <dabblego> hyrax42, exactly what I did, successfully
00:03:02 <shapr> I like starting with the Maybe monad and saying "Have you ever wanted to abstract out a bunch of nested if-then-else statements?"
00:03:08 <mgsloan> @undo do isdir <- doesDirectoryExist $ dname ++ "/" ++ fname; if isdir then (getDirList fullpath) >> (return . Dir fname) else return File fname
00:03:08 <lambdabot> doesDirectoryExist $ dname ++ "/" ++ fname >>= \ isdir -> if isdir then (getDirList fullpath) >> (return . Dir fname) else return File fname
00:03:12 <hyrax42> dabblego: really, where?
00:03:16 <sorear> why are monads so much harder for ppl than groups?
00:03:16 <mgsloan> nice
00:03:21 <dabblego> shapr, "you have because you have used the throws keyword"
00:03:27 <dabblego> hyrax42, at work, with a few people
00:03:28 <shapr> sorear: I've never been any good in groups ;-)
00:03:38 <Shimei> shankys_: Cool. How are you hosting a haskell web app, by the way? Do you have dedicated servers or somesuch?
00:03:42 <shapr> dabblego: hah
00:03:42 <mgsloan> wait, nevermind, that's no good
00:03:46 <hyrax42> dabblego: cool
00:03:51 <nmessenger> sorear: "our biggest mistake, using the scary term Monad rather than 'Warm, Fuzzy Thing'"
00:03:58 <mgsloan> ?pl doesDirectoryExist $ dname ++ "/" ++ fname >>= \ isdir -> if isdir then (getDirList fullpath) >> (return . Dir fname) else return File fname
00:03:58 <lambdabot> doesDirectoryExist (flip (flip if' (getDirList fullpath >> return . Dir fname)) fname =<< dname ++ '/' : fname)
00:03:59 <shapr> @quote
00:04:00 <lambdabot> EvilRanter says: I find "your a moron! unban me, or i shall TAUNT YOU A SECOND TIME!!" to be a particularly poor attempt
00:04:27 <sorear> isn't that a monty python quote?
00:04:36 <Shimei> Monad sounds too much like Gonad. That's why. :P
00:04:38 <sorear> (except for the unbanning of course)
00:05:24 <hyrax42> dabblego: so what was it you used... msum?
00:05:26 <nmessenger> Your mother was a hamster and your father smelt of elderberries!
00:05:35 <hyrax42> nmessenger: best quote :)
00:06:08 <hyrax42> also the other scary thing about monads, once you get a grasp on them, is the number of library functions for them
00:06:19 <hyrax42> I still don't know what ap does
00:06:33 <sorear> ap = liftM2 ($)
00:06:34 <hyrax42> and get confused between all the ones that deal with lists of actions
00:06:36 <nmessenger> something like liftM ($)
00:06:36 <mgsloan> so comonads would be "Cool, Smooth Thing"?
00:06:44 <int-e> sorear: maybe because you can do a few interesting things with groups; monads (in a programming context) just provide plumbing; anything interesting relies on a concrete instance.
00:06:47 <nmessenger> hee hee
00:06:48 <dabblego> hyrax42, I just rewrote Maybe, explained its benefits (which is easy); then watched then write if then else ..., then said "wouldn't it be nice if..."
00:07:39 <hyrax42> dabblego: oh so you introduced it as a awy to have explicit nullable types?  and then showed how to abstract the "if blah == null" checks?
00:07:43 <nmessenger> I'm still very much a beginner at Haskell, I've not yet written a Monad tutorial.
00:07:44 <sorear> what useful can you that is polymorphic in a group?
00:07:51 <dabblego> hyrax42, correct
00:07:57 <hyrax42> nmessenger: I was hoping ot never write one
00:07:58 <dabblego> hyrax42, then we wrote >>=
00:08:12 <dabblego> hyrax42, then called it; then said "it gets even nicer" (do notation)
00:08:23 <hyrax42> but now my prof is considering switching his course to haskell, I might help out with that
00:08:33 <hyrax42> and may end up writing or giving a monads tutorial
00:08:37 <nmessenger> hyrax42: didn't you know?  It's standard procedure for newbies
00:08:38 <dabblego> then reassured them along the way, "you now understand 90% of what monads are, but not necessarily the implications"
00:08:40 <int-e> sorear: exponentiation, element orders ... you have a lot of stuff that works for all finite groups for example.
00:08:48 <Shimei> @undo do { val <- readIORef var; writeIORef (val + 1) }
00:08:48 <lambdabot> readIORef var >>= \ val -> writeIORef (val + 1)
00:08:53 <hyrax42> nmessenger: I know, but I wanted to pretend I never was one
00:08:54 <shapr> dabblego: That's a good way to put it.
00:08:57 <int-e> sorear: maybe I'm wrong and it comes down to teaching methodology. *shrugs*
00:09:00 <mgsloan> I think I'll figure out how my graphical language does monadish stuff and explain it with that
00:09:07 <hyrax42> dabblego: nice idea
00:09:21 <dabblego> shapr, I think that's the fundamental mistake - not separating the concept and the implications
00:09:29 <nmessenger> I grok IO pretty well, and I wrote a Parsec grammar.  That was fun.
00:09:36 <sorear> nmessenger: I don't think n00bness is as totally ordered as you think it is; I haven't written a monad tutorial, but I have proposed type system extensions.
00:09:45 <allbery_b> @. pl undo do { val <- readIORef var; writeIORef (val + 1) }
00:09:46 <lambdabot> writeIORef . (1 +) =<< readIORef var
00:09:53 <shapr> I think you're right. The concept is small and simple, the implications are large.
00:10:08 <hyrax42> nmessenger: the scheme in 48 hours thing was an eye-opener for me
00:10:19 <nmessenger> hyrax42: aye
00:10:28 <hyrax42> and parsec is too cool to exist, I still think so
00:10:46 <nmessenger> double aye!
00:11:01 <hyrax42> it's the most natural non-straightforward monad I find
00:11:07 <hyrax42> for writing code in
00:11:36 <dabblego> hyrax42, you mean maybe?
00:11:47 <hyrax42> dabblego: no, parsec
00:11:48 <nmessenger> dabblego, you mean Maybe?
00:11:55 <nmessenger> :P
00:12:02 <mbrandt> mgsloan: cool examples of >>=. I'll look into that more...
00:12:14 <hyrax42> I found I didn't really have to think of what was going on, just wrote what made sense
00:12:17 <hyrax42> and it generally worked
00:12:44 <mgsloan> heh, the undo of that is pretty pointless.  In my opinion you should learn the >>= syntax first, then learn and use do
00:12:48 <hyrax42> compare to list monad for example, which I don't find as straightforward
00:12:51 <shankys_> Shimei: Yeah, we're using a dedicated server. I'm developing the Haskell framework for a startup or two that I'm doing ;)
00:13:24 <mbrandt> I'll give that a shot.
00:13:33 <lisppaste2> mgsloan annotated #33322 with "doh, i did make an error" at http://paste.lisp.org/display/33322#2
00:13:34 <mbrandt> Thanks for the help. You guys rock...
00:13:53 <mgsloan> bah, and I repasted without fixing
00:13:54 <mgsloan> ahwel
00:14:06 <hyrax42> it is true, #haskell rocks
00:14:21 <hyrax42> most helpful IRC channel I've visited, at least
00:14:55 <shapr> :-)
00:14:58 <shapr> Me too!
00:14:59 <sorear> somehow I parsed that as "most IRC channels I've visited are helpful"
00:15:02 <nmessenger> mgsloan: should there be parens around isPrefix "."?
00:15:57 <mgsloan> ah, yeah, probably around (isPrefixOf "." x)
00:16:32 <mgsloan> It'd be interesting if the language would actually try alternative parse trees and see if they typecheck
00:16:46 <mgsloan> the end of $
00:16:52 <shapr> Walk an ambiguous grammar looking for something that works?
00:16:58 <mgsloan> basically :)
00:17:02 <shapr> What if you get multiple valid results?
00:17:02 <sorear> curses autorepeat
00:17:04 <Shimei> Hmm. This code snippet from this STM paper seems wrong: " let incRef val = do { val <- readIORef val; writeIORef (val + 1) }"
00:17:15 <nmessenger> mgsloan: that sounds like a swamp of misinterpreted code.
00:17:19 <mgsloan> then complain to the uman, or use the first valid one
00:17:19 <Shimei> :t writeIORef
00:17:21 <lambdabot> Not in scope: `writeIORef'
00:17:23 <mgsloan> yeah, it would be
00:17:27 <mgsloan> but still interesting
00:17:28 <Shimei> :t Data.IORef.writeIORef
00:17:29 <lambdabot> forall a. GHC.IOBase.IORef a -> a -> IO ()
00:17:44 <mgsloan> actually, not too much would get misinterpreted i think
00:17:54 <shapr> mgsloan: Have you seen Wouter van Oortmeersen's languages?
00:17:55 <nmessenger> mgsloan: There's a reason web devs hate IE for "just working"
00:17:57 <mgsloan> as long as it doesn't consider too many pare trees
00:18:01 <mgsloan> hehe
00:18:10 <mgsloan> shapr - yeah, they're cool
00:18:26 <shapr> I do wish he'd write real docs for Aardapple though...
00:18:27 <mgsloan> he's very prolific
00:18:38 <shapr> Yeah he is.
00:18:58 <nmessenger> shapr: van Oortmeersen?  I've written 3 False interpreters so far!
00:19:03 <shapr> Cool!
00:19:08 <nmessenger> shapr: One in Haskell!
00:19:17 <mgsloan> has to label his languages not only by year, but also month!
00:19:29 <shapr> See you should turn that into a lambdabot plugin, definitely.
00:19:41 <shapr> There's already a brainfuck interpreter.
00:19:53 * nmessenger shouts OMG! uncontrollably.
00:20:09 <shapr> @help bf
00:20:10 <lambdabot> bf <expr>. Evaluate a bainf*ck expression
00:20:21 <nmessenger> It's extroardinarily dumb, though.  Unhelpful errors.
00:20:45 <shapr> I'd like to see an Aardappel interpreter plugin for lambdabot .
00:20:48 <mgsloan> LB's show String needs to leave off the quotes. then we could do cool stuff like ?. bf run
00:20:57 <sorear> mgsloan: ?read
00:21:01 * nmessenger shall write a False interpreter lambdabot plugin.
00:21:08 <mgsloan> ohh, hmm
00:21:16 <sorear> ?. read run cycle "bah! "
00:21:17 <lambdabot> compose module failed: IRCRaised Prelude.read: no parse
00:21:25 <sorear> ?run cycle "bah! "
00:21:26 <lambdabot>  "bah! bah! bah! bah! bah! bah! bah! bah! bah! bah! bah! bah! bah! bah! bah! ...
00:21:28 <int-e> @unlambda `.!`.o`.o`.t`. `.,`.a`.d`.b`.m`.a`.l`.n`.Ui
00:21:28 <lambdabot>  Unlambda, too!
00:21:31 <shapr> I read wouter's thesis, but it does not include sufficient docs for actual use of Aardappel. Also, I don't want to learn Aardappel by reading the source.
00:21:40 <nmessenger> > cycle "w00t! "
00:21:41 <lambdabot>  "w00t! w00t! w00t! w00t! w00t! w00t! w00t! w00t! w00t! w00t! w00t! w00t! w00...
00:21:48 <shapr> @echo test
00:21:48 <lambdabot> echo; msg:IrcMessage {msgPrefix = "shapr!n=user@cs6625119-169.bham.res.rr.com", msgCommand = "PRIVMSG", msgParams = ["#haskell",":@echo test"]} rest:"test"
00:21:51 <sorear> ?. read run concat $ replicate 5 "bah! "
00:21:52 <lambdabot>  bah! bah! bah! bah! bah!
00:21:57 <sorear> ?. read run concat $ replicate 10 "bah! "
00:21:58 <lambdabot>  bah! bah! bah! bah! bah! bah! bah! bah! bah! bah!
00:22:08 <lambdabot> SHAZBOT!
00:22:15 <nmessenger> Where did all these sheep come from?
00:22:35 <shapr> oh ewe
00:22:43 <mgsloan> ?. bf . read run concat $ replicate 5 "<+"
00:22:43 <shapr> lamb-da cow-kulus?
00:22:44 <lambdabot> Done.
00:22:49 <mgsloan> shaweet
00:23:04 <sorear> ?. bf {. read run} concat $ replicate 10 "bah! " -- wouldn't this be nice
00:23:04 <lambdabot> compose module failed: IRCRaised Parse error: "{."
00:23:06 * nmessenger rolls his eyes into the back of his head
00:23:14 <sorear> ?moo
00:23:15 <lambdabot> Maybe you meant: map more msg todo yow
00:23:23 <nmessenger> ?help msg
00:23:24 <lambdabot> msg <nick or channel> <msg>
00:23:25 <sorear> ?list moo
00:23:25 <lambdabot> No module "moo" loaded
00:23:29 <sorear> ?list cow
00:23:29 <lambdabot> No module "cow" loaded
00:23:32 <sorear> curses autorepeat
00:23:32 <shapr> Oh my, time to sleep.
00:23:43 <nmessenger> @localtime shapr
00:23:45 <lambdabot> Local time for shapr is Sun Dec 24 02:19:17 2006
00:23:49 <int-e> @unlambda ``ci`. `.!`.h`.a`.l`.b`ci
00:23:50 <lambdabot>  blah! blah! blah! blah! blah! blah! blah! blah! blah! blah! blah! blah! blah...
00:23:59 <sorear> nmess: it works like this:
00:24:20 <shapr> nmessenger: I moved back to the USA, I'm no longer in Sweden.
00:24:25 <sorear> ?msg #haskell note that this is a privledged command
00:24:25 <lambdabot> note that this is a privledged command
00:24:48 <nmessenger> ?msg #haskell I am not priveliged :(
00:24:49 <lambdabot> Not enough privileges
00:25:04 <nmessenger> See?
00:25:14 <shapr> ?msg #haskell What about me?
00:25:15 <lambdabot> What about me?
00:25:33 <shapr> nmessenger: You know how to get privileged?
00:25:38 <nmessenger> nopers
00:25:42 <shapr> Write a lambdabot plugin =)
00:25:54 <nmessenger> =)
00:26:00 <sorear> be in the right place when dons goes on vacation, that's how :)
00:26:18 <mgsloan> ?. bf . read run "++++++++++ [>+++++++>++++++++++>+++>+<<<<-]" ++ concat $ replicate 5 ">++."
00:26:19 <lambdabot>  Prelude.read: no parse
00:26:22 <sorear> gotta have someone to do the spontane-yows
00:26:26 <shapr> @yow !
00:26:27 <lambdabot> Gee, I feel kind of LIGHT in the head now, knowing I can't make my
00:26:27 <lambdabot> satellite dish PAYMENTS!
00:26:52 <nmessenger> ?help yow
00:26:53 <lambdabot> yow. The zippy man.
00:27:07 <sorear> ?. read run "++++++++++ [>+++++++>++++++++++>+++>+<<<<-]" ++ concat $ replicate 5 ">++."
00:27:08 <lambdabot> compose module failed: IRCRaised Prelude.read: no parse
00:27:10 <mgsloan> > "++++++++++ [>+++++++>++++++++++>+++>+<<<<-]" ++ concat $ replicate 5 ">++."
00:27:10 <lambdabot>    Expecting a function type, but found `[a]'
00:27:11 <lambdabot>    Expected type: [Char]
00:27:11 <lambdabot>  ...
00:27:14 <sorear> ?run "++++++++++ [>+++++++>++++++++++>+++>+<<<<-]" ++ concat $ replicate 5 ">++."
00:27:15 <lambdabot>    Expecting a function type, but found `[a]'
00:27:15 <lambdabot>    Expected type: [Char]
00:27:15 <lambdabot>  ...
00:27:21 <sorear> ?run show $ "++++++++++ [>+++++++>++++++++++>+++>+<<<<-]" ++ concat $ replicate 5 ">++."
00:27:22 <lambdabot>    Expecting a function type, but found `[a]'
00:27:22 <lambdabot>    Expected type: [Char]
00:27:22 <lambdabot>  ...
00:27:32 <sorear> ?. read run show ("++++++++++ [>+++++++>++++++++++>+++>+<<<<-]" ++ concat $ replicate 5 ">++.")
00:27:33 <lambdabot> compose module failed: IRCRaised Prelude.read: no parse
00:27:38 <sorear> ?run show ("++++++++++ [>+++++++>++++++++++>+++>+<<<<-]" ++ concat $ replicate 5 ">++.")
00:27:39 <lambdabot>    Expecting a function type, but found `[a]'
00:27:39 <lambdabot>    Expected type: [Char]
00:27:39 <lambdabot>  ...
00:27:51 <mgsloan> ?. read run "++++++++++ [>+++++++>++++++++++>+++>+<<<<-]" ++ (concat $ replicate 5 ">++.")
00:27:52 <shapr> Yow! Spam!
00:27:53 <lambdabot>  ++++++++++ [>+++++++>++++++++++>+++>+<<<<-]>++.>++.>++.>++.>++.
00:27:54 <nmessenger> sorear: /msg maybe
00:27:56 <sorear> ?run show ("++++++++++ [>+++++++>++++++++++>+++>+<<<<-]" ++ concat (replicate 5 ">++."))
00:27:58 <lambdabot>  "\"++++++++++ [>+++++++>++++++++++>+++>+<<<<-]>++.>++.>++.>++.>++.\""
00:28:06 <sorear> ?. bf . read run show ("++++++++++ [>+++++++>++++++++++>+++>+<<<<-]" ++ concat (replicate 5 ">++."))
00:28:07 <lambdabot>  Hf
00:28:08 <nmessenger> ?yow
00:28:08 <lambdabot> I'm ZIPPY the PINHEAD and I'm totally committed to the festive mode.
00:28:15 <mgsloan> yes!
00:28:39 <nmessenger> no!
00:28:55 <mgsloan> ?vixen fooblemoop
00:28:55 <lambdabot> I have 2 c what u look like.. u have pic?? URL?? NOT a fake please.. ill know!
00:29:06 <sorear> ?bf ++++++[>++++++<-]+[.]
00:29:14 <lambdabot> Done.
00:29:20 <sorear> ?bf ++++++[>++++++<-]+[.-]
00:29:21 <lambdabot> Done.
00:29:22 <int-e> @. bf run let p c = "[-]" ++ replicate (ord c) '+' ++ "." in "Hello, world!" >>= p
00:29:24 <lambdabot>  HHH
00:29:42 <mgsloan> ?bf +[+[+]]
00:29:42 <lambdabot> Done.
00:29:43 <nmessenger> I hate wrestling
00:29:56 <sorear> int-e: bf interprets the ... as print 3x
00:30:19 <sorear> LB should disable chopping when used in Compose
00:30:28 <int-e> sorear: hah. right. it worked in a privmsg ;)
00:30:54 <mgsloan> @. bf . read run let p c = "[-]" ++ replicate (ord c) '+' ++ "." in "Hello, world!" >>= p
00:30:56 <lambdabot>  Prelude.read: no parse
00:31:13 <mgsloan> > let p c = "[-]" ++ replicate (ord c) '+' ++ "." in "Hello, world!" >>= p
00:31:14 <lambdabot>  "[-]++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++...
00:31:18 <mgsloan> heh
00:31:19 <int-e> mgsloan: it won't work on the channel; the generated code is too long
00:31:26 <mgsloan> ohh
00:31:45 <int-e> mgsloan: the read is unneeded because brainfuck just ignores unknown characters like "
00:31:51 <mgsloan> probably a good way of optimizing that - pre building up a var to 70
00:31:54 <mgsloan> nice
00:32:06 <Shimei> Hmm. I'm failing to understand IORef. Shouldn't "do { x <- val; modifyIORef x (+1) }" where val is IO (IORef a) mutate the value of val as bound in the toplevel? (e.g. from let val = newIORef 5)
00:32:06 <mgsloan> > ord 'A'
00:32:07 <lambdabot>  65
00:32:11 <mgsloan> 65 i mean
00:32:40 <mgsloan> Shirmei - it mutates it, but toplevel has nothing to do with it
00:32:53 <int-e> mgsloan: yes, typically you can work with 3 or so initialized variables that you then select with <> and increment and decrement appropriately
00:32:58 <mgsloan> and calling val multiple times will make multiple IORefs
00:33:38 <Shimei> Well, I try that but "val >>= readIORef" always shows my initial value.
00:33:57 <sorear> val isn't an IORef
00:34:14 <sorear> it is an action which allocates an IORef with the initial value
00:34:26 <sorear> every time you read it you are reading a fresh IORef
00:34:40 <Shimei> Ohhh. I see.
00:35:30 <mgsloan> > ord 'a'
00:35:31 <lambdabot>  97
00:35:44 <sorear> > fromEnum '¬±'
00:35:45 <lambdabot>  Improperly terminated character constant
00:36:15 <mgsloan> > div 97 5
00:36:16 <lambdabot>  19
00:36:25 <sorear> > fromEnum '√É¬ø'
00:36:26 <lambdabot>  Improperly terminated character constant
00:36:46 <sorear> ieee, I just entered a UTF-8 multibyte sequence by hand
00:36:52 <sorear> ALT-195 ALT-191
00:36:59 <nmessenger> neato
00:37:15 <shapr> Does that work in X window also?
00:37:15 <sorear> > fromEnum 'a'
00:37:16 <lambdabot>  97
00:37:26 <shapr> Doesn't work in emacs at least.
00:37:28 <mgsloan> ? bf +++++[>+++++++++++++>+++++++++++++++++++<<-]>.
00:37:38 <nmessenger> shapr: did you try the numpad?
00:37:42 <mgsloan> ?bf +++++[>+++++++++++++>+++++++++++++++++++<<-]>.
00:37:42 <lambdabot>  A
00:37:53 <mgsloan> ?bf +++++[>+++++++++++++>+++++++++++++++++++<<-]>>.
00:37:53 <lambdabot>  _
00:37:56 <sorear> I doubt much beyond the linux console doesn't support full Unicode these days...
00:38:06 <mgsloan> > ord '_'
00:38:07 <lambdabot>  95
00:38:27 <mgsloan> ?bf +++++[>+++++++++++++>+++++++++++++++++++<<-]>>++.
00:38:28 <lambdabot>  a
00:38:30 <sorear> ?bf ++++++[>++++++<-]+[<+<+>>-]<[<.>-]
00:38:31 <lambdabot> Done.
00:38:32 <mgsloan> hurrah
00:38:40 <sorear> ?bf ++++++[>++++++<-]+[<+<+>>-]<[<.>--]
00:38:47 <lambdabot> Done.
00:38:49 <sorear> ?bf ++++++[>++++++<-]+[<+<+>>-]<[<.>---]
00:38:49 <lambdabot> Done.
00:38:53 <sorear> ?bf ++++++[>++++++<-]+[<+<+>>-]<[<.>------]
00:38:56 <int-e> sorear: hmm
00:38:59 <lambdabot> Done.
00:39:03 <int-e> sorear: your pointer is going off the tape
00:39:10 <sorear> ?bf >++++++[>++++++<-]+[<+<+>>-]<[<.>------]
00:39:16 <lambdabot> Done.
00:39:20 <int-e> ?bf ++++++[>++++++<-]>[>+>+<<-]>[>.<------]
00:39:21 <lambdabot>  $$$$$$
00:39:24 <sorear> ?bf >>>++++++[>++++++<-]+[<+<+>>-]<[<.>------]
00:39:29 <lambdabot> Done.
00:39:54 <sorear> ?bf ++++++[>++++++<-]>[<+<+>>-]<[<.>------]
00:39:54 <lambdabot>  $$$$$$
00:39:57 <sorear> ?bf ++++++[>++++++<-]>[<+<+>>-]<[<.>---]
00:39:57 <lambdabot>  $$$$$$$$$$$$
00:40:09 <sorear> I think I prefer Haskell.
00:40:12 <sorear> ?bf ++++++[>++++++<-]>[<+<+>>-]<[<+.>---]
00:40:12 <lambdabot>  %&'()*+,-./0
00:40:27 <nmessenger> ?v
00:40:27 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
00:40:42 <sorear> ?bf +++++[>++++++<-]>++[<+<+>>-]<[<+.>-]
00:40:42 <lambdabot>  !"#$%&'()*+,-./0123456789:;<=>?@
00:40:55 <sorear> ?bf +++++[>++++++<-]>[>++<-]>++[<+<+>>-]<[<+.>-]
00:40:55 <lambdabot>  ?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|
00:41:05 <sorear> ?bf +++++[>++++++<-]>[>++++<-]>++[<+<+>>-]<[<-.>-]
00:41:06 <lambdabot>  yxwvutsrqponmlkjihgfedcba`_^]\[ZYXWVUTSRQPONMLKJIHGFEDCBA@?>=<;:9876543210/....
00:42:58 <shapr> bok gour
00:42:58 <nornagon> cute
00:43:15 <nornagon> sorear: the linux console totally does support unicode
00:43:17 <nmessenger> ?jargon bok
00:43:18 <lambdabot> No match for "bok".
00:43:26 <hyrax42> #brainfuck?
00:43:35 <shapr> nmessenger: bok is Croatian for "hi"
00:43:50 <sorear> > array (0::Int,maxBound) [(1000000,0)]  -- ve had a problem 2 days ago
00:43:52 <lambdabot> Terminated
00:43:52 <shapr> nmessenger: Talar du svenska ist‰llet?
00:43:54 <nornagon> ?jargon+ box Croation for "hi"
00:43:58 <lambdabot> *** "box" jargon "Jargon File (4.3.1, 29 Jun 2001)"
00:43:58 <lambdabot> box n. 1. A computer; esp. in the construction `foo box' where foo is
00:43:58 <lambdabot>   some functional qualifier, like `graphics', or the name of an OS (thus,
00:43:58 <lambdabot>   `Unix box', `MS-DOS box', etc.) "We preprocess the data on Unix boxes
00:43:58 <lambdabot>   before handing it up to the mainframe." 2. [IBM] Without qualification
00:44:00 <lambdabot> [10 @more lines]
00:44:06 <sorear> > array (0::Int,maxBound) [(3,0)]
00:44:07 <nmessenger> shapr: not a word.
00:44:08 <lambdabot> Terminated
00:44:30 <sorear> > array (0::Int,maxBound) [(2^30-4,0)]
00:44:32 <lambdabot> Terminated
00:44:40 <sorear> > array (0::Int,maxBound-1) [(0,0)]
00:44:42 <lambdabot> Terminated
00:46:23 <nmessenger> shapr: 65e5672c8a9e5206304b308bff1f
00:46:52 <opqdonut> merry christmas ^_^
00:47:26 <shapr> nmessenger: what?
00:47:33 <shapr> opqdonut: God Jul!
00:47:48 <nmessenger> shapr: Nihongo wakaru?
00:47:55 <shapr> ozo_: Jag √•ker p√• enhjuling, och nu jag firar hjul!
00:48:04 <shapr> nmessenger: konichiwa nmessenger-san!
00:48:09 <Lemmih> Gl√¶delig Jul!
00:48:15 <shapr> God Jul Lemmih!
00:48:18 <opqdonut> shapr: Hyv‰‰ joulua!
00:48:34 <shapr> joulupukki joulupukki! Hyvi lapset and all!
00:48:42 <nmessenger> shapr: 3053309330703093306fff01
00:48:44 <opqdonut> shapr: almoust :)
00:48:49 <opqdonut> -u
00:49:07 <shapr> My Finnish is leaving me quickly :-)
00:49:28 <shapr> Min√§ en puhu suomea! Min√§ en tieda!
00:49:28 <nmessenger> hopefully some of it will come my way
00:50:01 <nmessenger> ?babel fi en Min‰ en puhu suomea! Min‰ en tieda!
00:50:02 <lambdabot> babel module failed: IRCRaised Error: Language fi not supported
00:50:06 <nmessenger> :(
00:50:15 <shapr> nmessenger: I said "I don't speak Finnish! I don't know!"
00:50:18 <Shimei> This STM paper is amusing: "atomically (do { x <- readTVar xv; y <- readTVar yv; if x>y then launchMissiles else return () } where launchMissiles :: IO () causes serious international side-effects."
00:50:37 <shapr> Shimei: Yeah, SPJ's papers are always fun. Have you seen him give a talk in person?
00:50:54 <shapr> nmessenger: I do speak Swedish though, and a bit of French.
00:51:00 <Shimei> shapr: Unfortunately no.
00:51:14 <nmessenger> shapr: 65e5672c8a9e5206304b3089306a3044ff017d765bfe5206304b3089306a3044ff01
00:51:18 <shapr> And I can get by with speaking Swedish to Danes.. at least, to Lemmih :-)
00:51:28 <arcatan> lambdabot clearly needs a lambdabot module
00:51:47 <nmessenger> the identity module!
00:51:55 <arcatan> oh, wait, a typo
00:51:58 <nmessenger> I could maybe write that!
00:52:00 <arcatan> transexp module I mean
00:52:04 <mgsloan> ?. bf run let a n=take n.concat.repeat;p n=a n "+";b l=(p$ord l-97)++"." in p 5++"[>"++p 13++">"++p 19++"<<-]>>++"++(concat$map(b)"hello")
00:52:05 <lambdabot>  hlwyyy
00:52:12 <mgsloan> almost :P
00:52:28 <opqdonut> :D
00:52:44 <shapr> nmessenger: What the heck is all that? Big5?
00:53:02 <nmessenger> I dunno what encoding it uses.  I just type it.
00:53:06 <int-e> mgsloan: you need to keep track of the current value ...
00:53:10 <arcatan> transexp's Finnish translation is wonderful
00:53:35 <mgsloan> int-e - yeah, I know what's wrong.  I just learned bf a min ago :P
00:54:07 <shapr> I can stil swear in Finnish, and ask for hamburgers and chocolate.. that's about my limit.
00:55:07 <arcatan> there must be some kind of universal rule that if somebody can speak any Finnish, they can certainly swear in Finnish
00:55:12 <mgsloan> ?. bf run let a n=take n.concat.repeat;p n=a n "+";s n = a n "-";b l=(p$ord l-97)++"."++(s$ord l-97) in p 5++"[>"++p 13++">"++p 19++"<<-]>>++"++(concat$map(b)"hello")
00:55:14 <lambdabot>  heddd
00:55:15 <nmessenger> shapr: I'm lucky if I could get half that it Japanese.
00:55:43 <shapr> nmessenger: I can't figure out which encoding you're using for whatever that is...
00:56:05 <shapr> nmessenger: Yeah, but I lived in Finland for 3.5 years, and Sweden for 3.5 years, so I had to learn or starve ;-)
00:56:08 <nmessenger> Does it not show up right?
00:57:05 <shapr> arcatan: I think it's universal in all languages. But Finnish is a lot more fun than most, even 'rakasta' sounds like swearing to non-Finns when you say it right.
00:57:31 <sorear> <nmessenger> shapr: ^65e5^672c^8a9e^5206^304b^3089^306a^3044^ff01^7d76^5bfe^5206^304b^3089^306a^3044^ff01
00:57:43 <arcatan> shapr: heh, yeah
00:57:44 <nmessenger> Shift_JIS?
00:57:58 <mgsloan> > let a n=take n.concat.repeat;p n=a n "+";s n = a n "-";b l=(p$ord l-97)++"."++(s$ord l-97) in p 5++"[>"++p 19++"<-]>>++"++(concat$map(b)"hello")
00:58:00 <lambdabot>  "+++++[>+++++++++++++++++++<-]>>+++++++++.-------++++.----+++++++++++.------...
00:58:01 <nmessenger> I think that's what it's called
00:58:10 <mgsloan> oh, jeez
00:58:46 <shapr> nmessenger: Viewing the logs as Shift_JIS in my browser doesn't work here.
00:58:51 <gour> shapr: bok
00:59:11 <sorear> utf-7?  iirc that used hex
00:59:57 <nmessenger> I'm not sure how to ask Windows what encoding it's using and how it interacts with my client.
01:00:23 <sorear> ?pl \a b c d e f g h i j k l m n o p q r s t u v w x y z -> t h i s (i s p r o b a b l y) n o t a f i x e d p o i n t c o m b i n a t o r)
01:00:24 <lambdabot> (line 1, column 134):
01:00:24 <lambdabot> unexpected ")"
01:00:24 <lambdabot> expecting variable, "(", operator or end of input
01:00:27 <sorear> ?pl \a b c d e f g h i j k l m n o p q r s t u v w x y z -> t h i s (i s p r o b a b l y) n o t a f i x e d p o i n t c o m b i n a t o r
01:00:43 <lambdabot> (((((const .) .) .) .) .) . (((((((const .) .) .) .) .) .) .) . (((((((const .) .) .) .) .) .) .) . ((((((((((((const .) .) .) .) .) .) .) .) .) .) .) .) . (((((((((((((((const .) .) .) .) .) .) .) .
01:00:43 <lambdabot> ) .) .) .) .) .) .) .) . (((((((((((((((const .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) . (((((((((((((((const .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) . (((((((((((((((((const .) .) .) .) .)
01:00:43 <lambdabot> .) .) .) .) .) .) .) .) .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . (((((((flip .) .) .) .
01:00:43 <lambdabot> ) .) .) .) . ((((((((flip .) .) .) .) .) .) .) .) . (((((((((flip .) .) .) .) .) .) .) .) .) . ((((((((((flip .) .) .) .) .) .) .) .) .) .) . (((((((((((flip .) .) .) .) .) .) .) .) .) .) .) . ((((((
01:00:45 <lambdabot> ((((((ap .) .) .) .) .) .) .) .) .) .) .) .) . (((((((((((((flip .) .) .) .) .) .) .) .) .) .) .) .) .) . ((((((((((((((flip .) .) .) .) .) .) .) .) .) .) .) .) .) .) . (((((((((((((((flip .) .) .) .
01:00:48 <lambdabot> [58 @more lines]
01:00:50 <lambdabot> optimization suspended, use @pl-resume to continue.
01:00:56 <nmessenger> @more
01:00:56 <sorear> we found a great way to generate vast amounts of data from ?pl earlier
01:01:08 <nmessenger> I know!  I wrote that!
01:01:49 <sorear> except it only said 23 @more earlier, obviously it's very input sensitive
01:02:02 <mgsloan> > let a n=take n.concat.repeat;p n=a n "+";s n = a n "-";b l=(p$ord l-97)++"."++(s$ord l-97) in map(b)"hello"
01:02:02 <shapr> Is there a @pointful?
01:02:04 <lambdabot>  ["+++++++.-------","++++.----","+++++++++++.-----------","+++++++++++.------...
01:02:12 <nmessenger> ?unpl
01:02:12 <lambdabot> pointful module failed: IRCRaised Lib/Pointful.hs:38:24-51: Non-exhaustive patterns in lambda
01:02:56 <sorear> ?. unpl pl \a b c d e f g -> c a f e b a g g
01:03:06 <sorear> ?pl \a b c d e f g -> c a f e b a g g
01:03:11 <lambdabot> SrcLoc {srcFilename = "<unknown>", srcLine = 2, srcColumn = 1}: Parse error
01:03:19 <mgsloan> oh godamnit
01:03:20 <lambdabot> ((const .) .) . flip flip id . ((flip . ((flip . ((flip . (ap .)) .)) .)) .) . join (flip . ((flip . ((flip . (flip .)) .)) .) . flip . (flip .) . ((flip .) .) . (flip .) . flip id)
01:03:20 <lambdabot> optimization suspended, use @pl-resume to continue.
01:03:31 <mgsloan> my code works, its just that ellipsis at the end
01:03:38 <mgsloan> gotta make the bf slimmer :)
01:03:40 <nornagon> heh
01:03:55 <sorear> ?. unpl pl \a b c d e f g -> c a f e b a g g
01:04:10 <lambdabot> (\ bh da dd _ p s -> (((\ al dv ab ac af ai -> al dv ac af ai ab) >>= \ x y z -> x z y) (\ an ao as av -> ao bh av as an) da dd p s) >>= \ by -> (\ j -> j) >>= \ bx -> return (by bx))
01:04:20 <nmessenger> pretty!
01:04:27 <sorear> pointy!
01:04:53 <nornagon> heh
01:05:19 <nmessenger> lol @ (\ j -> j)
01:06:02 <sorear> pointy needs to know more about instance Monad (->) x
01:08:03 <mgsloan> ?. bf run let a n=take n.concat.repeat;p n=a n "+";s n = a n "-";b l=(p$ord l-97)++"."++(s$ord l-97) in p 5++"[>"++p 13++">"++p 19++"<<-]>>++"++(concat$map(b)"hi")
01:08:04 <lambdabot>  hifff
01:08:13 <mgsloan> I'll just leave it at that...
01:08:36 <nmessenger> It *is* rather offensive.
01:09:27 <mgsloan> I'm sure I could do clever swap stuff and factorization etc and get it to say hello in the space limit but eh
01:09:48 <sorear> ?read "hello"
01:09:49 <lambdabot>  hello
01:09:53 <sorear> ^^^ much easier
01:10:08 <mgsloan> yeah, but so much less cool
01:10:34 <nmessenger> Hey everybody, let's write an OS in False!
01:10:38 <mgsloan> ?read [0,1]
01:10:39 <lambdabot> dummy module failed: IRCRaised Prelude.read: no parse
01:11:08 <sorear> ?read "\001TIME\001"
01:11:09 <lambdabot>  TIME
01:11:14 <nmessenger> or Lazy K!
01:12:10 <sorear> ?read "\001SHOULD THIS NOT WORK?\001"
01:12:10 <lambdabot>  SHOULD THIS NOT WORK?
01:12:35 <nmessenger> ?help read
01:12:35 <lambdabot> read "<foo>". Print <foo>
01:12:37 <sorear> I'm ... vaguely suprized.
01:13:13 <nmessenger> ?read map chr [0..31]
01:13:13 <lambdabot> dummy module failed: IRCRaised Prelude.read: no parse
01:13:35 <nmessenger> > print $ map chr [0..31]
01:13:36 <lambdabot>  <IO ()>
01:13:41 <nmessenger> :)
01:14:12 <int-e> sorear: it should not. lambdabot adds a space in front to prevent this
01:14:57 <sorear> well, my client interpreted it , did yours?
01:15:03 <int-e> sorear: no
01:15:07 <sorear> > array (minBound,0::Int) [(-10000,0)]
01:15:08 <lambdabot>  Exception: (Array.!): undefined array element
01:15:14 <sorear> > array (minBound,0::Int) [(-1,0)]
01:15:16 <lambdabot>  Exception: (Array.!): undefined array element
01:15:18 <sorear> > array (minBound,0::Int) [(]
01:15:19 <lambdabot>  Parse error
01:15:20 <sorear> > array (minBound,0::Int) []
01:15:20 <lambdabot>  Add a type signature
01:15:47 <sorear> > array (minBound,-1::Int) [(-100,0)]
01:15:49 <lambdabot>  internal error: EVACUATED object entered!
01:15:49 <lambdabot>   Please report this as a bug to...
01:15:49 <nmessenger> ?protontorpedo
01:15:49 <lambdabot> I read somewhere that large systms get confusing and haskell ends up a s a bunch of functions
01:17:17 <nmessenger> ?protontorpedo
01:17:18 <lambdabot> is there going to be a better dns server in haskell?
01:17:59 <nmessenger> ?yhjulwwiefzojcbxybbruweejw
01:18:00 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
01:18:19 <shapr> I have a totally off-topic question... are glove sizes standardized? As in, can I measure my hands and know whether I should buy L or XL?
01:18:45 <sorear> confirming that was for #haskell?
01:19:02 <shapr> I already tried #unicycling =)
01:19:11 <sorear> > array (minBound,-1::Int) [(-100,0xf00fc7c8)]
01:19:12 <lambdabot>  internal error: EVACUATED object entered!
01:19:13 <lambdabot>   Please report this as a bug to...
01:19:15 * nmessenger reels from the off-topicitude
01:19:29 <shapr> It's just that #haskell is so good for almost any subject...
01:19:37 <sorear> can't quite get the code-injection workign :(
01:19:58 <shapr> I forget who said #haskell was a better ##c than ##c itself..
01:22:22 <sorear> what, I can't use unboxed types in lambdabot! :)
01:22:34 <nmessenger> ?faq Can I inject arbitrary code into a running lambdabot instance?
01:22:34 <lambdabot> The answer is: Yes! Haskell can do that.
01:22:47 <goltrpoat> haha
01:24:02 <nmessenger> ?faq How?
01:24:02 <lambdabot> The answer is: Yes! Haskell can do that.
01:24:22 <nmessenger> ?faq You're not helpful at all.
01:24:23 <lambdabot> The answer is: Yes! Haskell can do that.
01:24:33 <int-e> ?help faq
01:24:33 <lambdabot> faq. Answer frequently asked questions about Haskell
01:25:29 <nmessenger> ?slap ?faq
01:25:29 * lambdabot beats up ?faq
01:26:15 <int-e> @index maxbound
01:26:16 <lambdabot> bzzt
01:26:29 <int-e> oh. maxBound
01:26:51 <nmessenger> It's so playful.  Bzzt!
01:27:24 <int-e> @botsnack
01:27:25 <lambdabot> :)
01:27:30 <int-e> @arr
01:27:31 <lambdabot> Aye
01:28:50 <nmessenger> ?botsmack
01:28:50 <lambdabot> :)
01:29:26 <allbery_b> whee, -fno-monomorphism-restriction to the rescue (freaking type unification problems...)
01:30:32 * allbery_b should dig up that discussion on -cafe about when ghc dislikes someone specifying the types it claims for functions
01:32:34 <nmessenger> ?get-shapr
01:32:35 <lambdabot> shapr!!
01:32:38 <shapr> WHAT?
01:32:46 <nmessenger> nothing, just testing.
01:32:49 <nornagon> ?get-nornagon
01:32:50 <lambdabot> Unknown command, try @list
01:32:52 * shapr goes back to sleep
01:33:10 <shapr> g'day nornagon
01:33:17 <nornagon> sup :)
01:33:30 <shapr> Warm down there?
01:33:45 <sorear> has this been noticed more than 2 days ago?
01:33:54 <sorear> > array (minBound,-1::Int) [(-100,0xf00fc7c8)]
01:33:56 <lambdabot> Terminated
01:34:00 <sorear> > array (minBound,-1::Int) [(-101,0xf00fc7c8)]
01:34:02 <lambdabot> Terminated
01:34:04 <sorear> > array (minBound,-1::Int) [(-2,0xf00fc7c8)]
01:34:06 <lambdabot> Terminated
01:34:08 <sorear> > array (minBound,-1::Int) [(-3,0xf00fc7c8)]
01:34:10 <lambdabot> Terminated
01:34:12 <shapr> I think sjanssen found the array bound problem a week or two ago.
01:34:32 <shapr> But I'm not totally sure of that...
01:37:44 <dobblego> ?hoogle Eq a => [a] -> Bool
01:37:45 <lambdabot> Prelude.null :: [a] -> Bool
01:37:45 <lambdabot> Prelude.elem :: Eq a => a -> [a] -> Bool
01:37:45 <lambdabot> Prelude.notElem :: Eq a => a -> [a] -> Bool
01:38:13 <nornagon> shouldn't and and or be in there?
01:38:23 <dobblego> is there a "has all unique elements" function in the standard libraries?
01:38:35 <shapr> nub?
01:38:51 <shapr> (\x -> nub x == x) ?
01:38:53 <nmessenger> first approximation: \xs -> length xs == length (nub xs)
01:39:02 <nmessenger> that works too :)
01:39:07 <dobblego> ?type nub
01:39:08 <lambdabot> forall a. (Eq a) => [a] -> [a]
01:39:15 <dobblego> nub "abcabc"
01:39:16 <shapr> length is probably more efficient.
01:39:18 <dobblego> > nub "abcabc"
01:39:19 <lambdabot>  "abc"
01:39:59 <dobblego> > let f xs = length $ nub xs == length xs in f "abcabc"
01:40:00 <nmessenger> > nub "accabbdcabcda"
01:40:00 <lambdabot>  Couldn't match `[a]' against `Int'
01:40:01 <shapr> Comparing list length must be cheaper than comparing item value.
01:40:01 <lambdabot>  "acbd"
01:40:17 * shapr likes nmessenger's solution.
01:40:26 <nmessenger> (==) binds more tightly than ($)
01:40:29 * shapr falls over asleep
01:40:38 * nmessenger is about to
01:40:39 <dobblego> > let f xs = length (nub xs) == length xs in f "abcabc"
01:40:40 <lambdabot>  False
01:41:00 <sorear> ap (ap (==) nub) length
01:41:06 <sorear> > ap (ap (==) nub) length "abcdefg"
01:41:06 <lambdabot>    Expecting a function type, but found `Bool'
01:41:07 <lambdabot>    Expected type: a1 -> a...
01:41:47 <sorear> > ap (==) nub "abcdefg"
01:41:48 <lambdabot>  True
01:41:51 <sorear> > ap (==) nub "abcdefge"
01:41:53 <lambdabot>  False
01:44:11 <nmessenger> > ap ((==) . length) nub "abcdefg"
01:44:11 <lambdabot>  Couldn't match `Int' against `[a]'
01:47:12 <dobblego> ?info nub
01:47:13 <lambdabot> nub
01:47:19 <dobblego> ?hoogle nub
01:47:19 <lambdabot> List.nub :: Eq a => [a] -> [a]
01:47:19 <lambdabot> List.nubBy :: (a -> a -> Bool) -> [a] -> [a]
01:48:15 <nmessenger> ?type ap
01:48:16 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
01:48:18 <nmessenger> ?type ap (==)
01:48:19 <lambdabot> forall a. (Eq a) => (a -> a) -> a -> Bool
01:48:23 <nmessenger> I don't understand how the second follows from the first
01:50:32 * nmessenger almost had an epiphany
01:50:47 <goltrpoat> substitute (a ->) for m
01:52:03 <nmessenger> OMG BRAIN SPLODEY!
01:52:24 <nmessenger> that's awesome!
01:53:02 <goltrpoat> innit :)
01:55:41 <ibid> merry whatever, everyone :)
01:56:04 <nmessenger> Merry Whatever To All!
01:56:32 <opqdonut> \o/
01:57:14 <nmessenger> And have a very happy You-Know-What!
02:01:41 <nmessenger> ?pretty id = undefined where 1 = 2
02:01:41 <lambdabot>  id = undefined
02:01:41 <lambdabot>   where 1 = 2
02:03:20 <dobblego> ?hoogle getArs
02:03:21 <lambdabot> No matches found
02:03:21 <dobblego> ?hoogle getArgs
02:03:22 <lambdabot> System.getArgs :: IO [String]
02:04:14 <nmessenger> ?arg
02:04:15 <lambdabot> I want me grog!
02:07:58 <lisppaste2> metaperl pasted "does this while function have to use IO Bool instead of Bool?" at http://paste.lisp.org/display/33327
02:09:02 <Lemmih> Well, a plain 'Bool' wouldn't be very useful.
02:11:18 <int-e> it could be useful in other monads, too. (State and ST are obvious candidates)
02:19:46 <lisppaste2> metaperl annotated #33327 with "help needed writing a getInt function" at http://paste.lisp.org/display/33327#1
02:20:59 <integral> :t (readLn :: IO Int)
02:21:00 <lambdabot> IO Int
02:21:13 <integral> metaperl, your type annotation in getInt looks incorrect to me.
02:21:26 <metaperl> hmm
02:21:27 <integral> oh, my mistake, it's not the annotation, but the lack of 'let'
02:21:42 <integral> Not that the annotation is needed since it can be inferred from the annotation for the whole function.
02:23:20 <metaperl> why do I need a let?
02:23:32 <metaperl> could I write i <- return(read ln)
02:23:32 <integral> Umm, because that's the way they defined the syntax of the language?
02:23:37 <integral> Yes.
02:23:37 <metaperl> lol
02:24:59 <metaperl> how would you read a signed int from the keyboard? http://haskell.org/hoogle/?q=read
02:25:01 <lambdabot> Title: read - Hoogle
02:25:12 <metaperl> readInt reads unsigned ints only
02:25:29 <integral> I'd just use readLn instantiated at Int
02:26:26 <metaperl> integral - can you annotate with a fully working example?
02:27:27 <goltrpoat> > read "-3" :: Int
02:27:28 <lambdabot>  -3
02:28:02 <metaperl> i <- readLn :: Int
02:28:02 <metaperl> ?
02:28:13 <metaperl> is that right?
02:28:31 <TSC> :t readLn
02:28:32 <lambdabot> forall a. (Read a) => IO a
02:28:41 <integral> No, that can't be right.
02:29:19 <metaperl> well, please provide a fully working example? :)
02:29:23 <integral> The rhs of a <- must be an action and Int is not the type of any action.
02:29:31 <goltrpoat> (readLn :: IO Int) >>= ...
02:29:45 <metaperl> ah
02:29:55 <metaperl> i <- readLn :: IO Int
02:29:56 <metaperl> bingo
02:29:58 <goltrpoat> or that
02:29:59 <metaperl> thanks
02:30:06 <metaperl> yeah, SJT has not gotten to >>= yet
02:30:10 <metaperl> just do notation
02:30:13 <goltrpoat> ah
02:30:36 <integral> TBH wouldn't it just be easier adding the "let" and removing the annotation in your original code?
02:30:56 <integral> (Especially if this is meant to be an exercise in 'do' notation of which let is a part, surely?)
02:45:57 <_matthew_> any news on hs-plugins?
02:46:33 <lisppaste2> metaperl annotated #33327 with "why is the Queue data constructor not in scope on line 16?" at http://paste.lisp.org/display/33327#2
02:47:48 <metaperl> oh Data.Queue is deprecated... on to Data.Sequence
02:48:38 <_matthew_> metaperl: what do you think the type sig is of the collectInts function?
02:49:21 <_matthew_> cos where you're calling it, the parameter you're passing is a type rather than a value no?
02:49:22 <goltrpoat> Queue is not a constructor
02:49:32 <metaperl> _matthew_ - can I ignore your question? I went on to Data.Sequence
02:49:37 <_matthew_> ok. ;)
02:49:47 <metaperl> I just dont know how to force a sequence to return a list... hold on pasting
02:50:06 <goltrpoat> you probably want to use collectInts emptyQueue or some such
02:50:24 <lisppaste2> metaperl annotated #33327 with "how to convert a sequence to a list" at http://paste.lisp.org/display/33327#3
02:50:43 <metaperl> Queue is deprecated... I am using Data.Seuqnce
02:51:27 <_matthew_> metaperl: do I take it that doesn't work?
02:52:29 <metaperl> _matthew_  - line 17 will not work because queueToList is not in the API for Data.Sequence... I'm looking to convert a sequence to a list
02:53:01 <_matthew_> The type of empty you want is Seq Int surely? But I don't think you should have to specify that anyway
02:53:08 <_matthew_> sequence does implement monad
02:53:12 <_matthew_> so a foldM ?
02:53:40 <_matthew_> where the initial accumulator is [] and then cons in each value ?
02:53:45 <metaperl> we havent gotten to foldM... I'm just thinking that it is dumb to mix I/O and summing a list the way that SJT showed in the original sumInts
02:54:15 <metaperl> _matthew_ - that reverses the order of the list.... which is fine for summing, but not for division, subtraction
02:54:20 <metaperl> I want to maintain the list order
02:54:26 <metaperl> the input order
02:55:25 <metaperl> it was poor software engineering on SJT's part to mix reading in a list and summing it.. That is OCaml style :)
02:55:27 <_matthew_> right, yes, that makes a lot of sense
02:55:49 <goltrpoat> Seq is Foldable
02:56:36 <goltrpoat> so.. return (foldl (+) 0) or some such
02:56:47 <goltrpoat> er.. return (foldl (+) 0 is)
02:57:35 <metaperl> really, reading I/O kills the lazy nature of haskell... I should be reading an infinite stream of numbers which gets passed to sum :: [Int] -> Int
02:57:46 <metaperl> sum . collectIntsFromIO
02:57:49 <metaperl> done
02:57:51 <opqdonut> :)
02:58:03 <metaperl> my compositional nature of Haskell is gone
02:58:03 <opqdonut> product would benefit more from that
02:58:04 <goltrpoat> oh, duh
02:58:10 <opqdonut> once we encounter a 0, bam
02:58:14 <integral> :t interleaveIO
02:58:15 <lambdabot> Not in scope: `interleaveIO'
02:58:26 <opqdonut> ?hoogle interleaveIO
02:58:27 <lambdabot> System.IO.Unsafe.unsafeInterleaveIO :: IO a -> IO a
02:58:32 <opqdonut> ?hoogle interleave
02:58:32 <lambdabot> Control.Monad.ST.unsafeInterleaveST :: ST s a -> ST s a
02:58:32 <lambdabot> System.IO.Unsafe.unsafeInterleaveIO :: IO a -> IO a
02:58:36 <opqdonut> ok
02:58:44 <integral> metaperl: sum `fmap` collectIntsFromIO
02:59:10 <metaperl> fmap is also beyond me...I think I should've just done is <- readLn :: [Int]
02:59:29 <opqdonut> hrmmm
02:59:31 <metaperl> return (sum is)
03:01:51 <_matthew_> metaperl: IO doesn't destroy lazyness. It only limits it
03:02:15 <lisppaste2> goltrpoat annotated #33327 with "this typechecks" at http://paste.lisp.org/display/33327#4
03:02:27 <_matthew_> you can still do lazy stuff, but most easily in non-IO functions that get called from your IO functions
03:05:19 <augustss> metaperl: you don't get fmap?  but fmap is simple.  it just applies a function to what's inside a "container"
03:05:49 <lisppaste2> metaperl annotated #33327 with "help needed reading in [Int]" at http://paste.lisp.org/display/33327#5
03:06:09 <metaperl> augustss - thanks .
03:06:11 <metaperl> @type fmap
03:06:13 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
03:06:52 <goltrpoat> OT, anyone know where thunderbird stores the path to the user profile on windows?  both thunderbird and firefox decided to disown me for whatever reason
03:07:02 <goltrpoat> but i see the thunderbird profile with what looks like the right data
03:07:19 <_matthew_> neat. Is in fmap, is the f meant to typically be a data constructor, eg Just ?
03:07:33 <_matthew_> ahh, I can't read. ignore than
03:08:07 <goltrpoat> > fmap negate (Just 5)
03:08:08 <lambdabot>  Just (-5)
03:08:22 <metaperl> > read "[1,2,3]" :: [Int]
03:08:24 <lambdabot>  [1,2,3]
03:08:27 <metaperl> hey it worked
03:09:34 <_matthew_> goltrpoat : Ahh, maybe implements functor
03:12:54 <lisppaste2> metaperl annotated #33327 with "please help me read in a list of ints" at http://paste.lisp.org/display/33327#6
03:12:57 <augustss> > fmap negate [1,2,3]
03:12:58 <lambdabot>  [-1,-2,-3]
03:13:23 <metaperl> @type negate
03:13:24 <lambdabot> forall a. (Num a) => a -> a
03:13:34 <metaperl> map negate [1,2,3]
03:13:37 <_matthew_> > map negate [1,2,3]
03:13:38 <lambdabot>  [-1,-2,-3]
03:13:55 <metaperl> same results...
03:14:17 <_matthew_> different types though. map only works on lists
03:14:26 <_matthew_> ?type map
03:14:28 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
03:14:53 <augustss> > negate 1.2
03:14:53 <augustss> yes, fmap=map for lists
03:14:53 <augustss> > negate (5%6)
03:14:53 <augustss> lambdabot, where are you?
03:14:54 <lambdabot>  -1.2
03:14:56 <lambdabot>  (-5)%6
03:15:01 <_matthew_> fmap is a generalisation of it I guess
03:15:24 <augustss> fmap is the generalization of map to all "containers"
03:15:25 <metaperl> why won't anyone help me read a list of Ints? http://paste.lisp.org/display/33327#6
03:15:36 <_matthew_> ?t (5%6)
03:15:37 <lambdabot> Maybe you meant: tell time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
03:15:40 <_matthew_> ?type (5%6)
03:15:42 <lambdabot> forall a. (Integral a) => Ratio a
03:15:52 <_matthew_> wow. So ration implements functor?
03:15:54 <_matthew_> -n
03:16:06 <augustss> no
03:16:28 <augustss> metaperl: what format is the list you want to read?
03:16:39 <_matthew_> well why did it choose to negate the numerator and not the denominator?
03:16:40 <metaperl> [1.2.3]
03:16:44 <metaperl> oops
03:17:01 <metaperl> augustss - just a format that read :: [Int] can read
03:17:09 <metaperl> > read "[1,2,3]" :: [Int]
03:17:11 <lambdabot>  [1,2,3]
03:17:13 <metaperl> see
03:17:27 <metaperl> but I cant get getLine to return such a string
03:17:29 <augustss> _matthew_: because that's how Ratio is defined.  the sign is on the numerator
03:17:49 <metaperl> please help
03:17:54 <metaperl> :)
03:17:58 <augustss> do istr <- getLine; return $ sum $ read istr
03:18:24 <augustss> read is not in the IO monad, so it needs no <-
03:18:58 <metaperl> maybe I should learn the let construct
03:19:02 <augustss> you could write 'let is = read istr :: [Int]'
03:19:03 <metaperl> how would I use let here : http://paste.lisp.org/display/33327#6
03:19:52 <lisppaste2> lennart annotated #33327 with "with let" at http://paste.lisp.org/display/33327#7
03:20:53 <lisppaste2> lennart annotated #33327 with "one line" at http://paste.lisp.org/display/33327#8
03:20:58 <lisppaste2> metaperl annotated #33327 with "reading a list of Ints ... augustss's soln did not quite work" at http://paste.lisp.org/display/33327#9
03:21:47 <augustss> but you didn't use my solution :)
03:22:19 <augustss> that version needs parens: '(read istr :: [Int])'
03:22:33 <augustss> but i prefer putting the type on readInts''
03:24:51 <metaperl> augustss - it still didnt work
03:25:56 <metaperl> @seen lennart
03:25:57 <lambdabot> I saw lennart leaving #haskell 1m 12h 26m 32s ago, and .
03:26:12 <metaperl> his soln doesnt compile either
03:26:20 <augustss> oh, sorry, no IO on that type
03:27:23 <metaperl> no IO?
03:27:25 <metaperl> @type read
03:27:27 <lambdabot> forall a. (Read a) => String -> a
03:27:56 <metaperl> > read "[1,2,3']"
03:27:57 <lambdabot>  Add a type signature
03:28:02 <metaperl> > read "[1,2,32]"
03:28:03 <lambdabot>  Add a type signature
03:28:16 <integral> > read "[1,2,32]" :: [Int]
03:28:17 <lambdabot>  [1,2,32]
03:28:20 <augustss> And my one line version compiles just fine :)
03:28:20 <augustss> read is not in the IO monad
03:28:20 <augustss> only getLine is
03:28:25 <augustss> the rest of the functions are pure
03:28:28 <metaperl> that's true
03:28:33 <metaperl> > read "[1,2,3]"
03:28:35 <lambdabot>  Add a type signature
03:28:42 <integral> > (sum . read) "[1,2,3]"
03:28:43 <lambdabot>  6
03:30:00 <metaperl> why did lennart put fmap in front of that integral?
03:30:14 <metaperl> > fmap (sum . read) "[1,2,3]"
03:30:14 <lambdabot>  Couldn't match `String' against `Char'
03:30:22 <integral> Sorry, I have no idea what you're talking about.
03:30:40 <metaperl> integral - right here - http://paste.lisp.org/display/33327#8
03:31:13 <integral> fmap transforms the output of an action by a pure function
03:31:47 <integral> getLine is an action, but (sum . read) is a function.
03:31:50 <metaperl> oh yes, he pulled the String out of the IO String produced by getLine right?
03:31:52 <metaperl> yes
03:32:09 <integral> Well, with fmap you don't need to pull it out yourself
03:32:17 <metaperl> righ
03:32:18 <metaperl> right
03:32:24 <integral> fmap encapsulates the pattern of pulling out the value, transforming it purely, and then putting it back in with return.
03:32:45 <integral> fmap f a = do { v <- a; let v' = f v; return v' }
03:46:16 <augustss> perhaps I should have used liftM instead of fmap.  It's just another name, but it sounds more monadic :)
03:51:56 <gour> which one provides better haskell support: emacs or xemacs?
03:53:05 <augustss> i've had some minor problems with the haskell mode in xemacs
03:53:55 <gour> augustss: i'm vim user, but looking if there is some better haskell-support...
03:56:20 <augustss> I'm only an occasional vim user, so I can't tell.
03:56:39 <gour> augustss: how is gtk+ support in emacs?
04:00:10 <augustss> I don't know if it has any.
04:00:22 <augustss> and I don't really care :)
04:07:35 <anonfunc> gour: CVS builds of emacs can use Gtk+
04:08:20 <_matthew_> why does ghc6.4 often require a -package foo flag but 6.6 doesn't?
04:11:21 <gour> anonfunc: yep, i saw that on gentoo, emacs-cvs ebuild has 'gtk+ flag :-)
04:12:10 <gour> anonfunc: and how about emacs vs. emacs with haskell mode? afaik, xemacs' gtk is not ready?
04:12:12 <anonfunc> gour: Ah.  As for "how", it seems all right.  I haven't used it in ages.
04:12:53 <gour> anonfunc: do you use some other editor?
04:13:18 <gour> anonfunc: or you don't know about xemacs?
04:13:33 <anonfunc> gour: and emacs seems to do well with haskell-mode.  I use the Aquamacs variant of cvs emacs
04:14:00 <gour> anonfunc: mac?
04:14:15 <anonfunc> gour: precisely
04:15:00 <_matthew_> gour: what functionality do you want?
04:15:18 <gour> _matthew_: maybe better indenting than vim...
04:15:27 <_matthew_> ahh, yes, emacs is fine for that
04:15:30 <_matthew_> though not great
04:15:40 <_matthew_> I've no idea if xemacs is better though
04:15:52 <gour> _matthew_: you're on with emacs?
04:15:59 <_matthew_> yup,
04:16:03 <gour> thanks
04:16:14 <_matthew_> np
04:16:20 <anonfunc> Takes a bit to get used to tab cycling through the possibilities, rather than reading your mind.
04:16:21 <gour> atm, i'm using pida (pida.berlios.de) with gvim
04:16:48 <gour> _matthew_: and how does emacs play with darcs?
04:17:05 <_matthew_> I don't use darcs
04:17:07 <_matthew_> I use monotone
04:17:23 <_matthew_> and I love the command line. And dislike guis.
04:17:24 <_matthew_> ;-)
04:17:47 <gour> well, darcs is gui :-)
04:17:52 <gour> *cli
04:17:55 <_matthew_> lol
04:17:58 <_matthew_> some typeo!
04:18:19 <gour> darcs does not need it, so simple & powerful
04:18:23 <_matthew_> yeah, but the first entry on the monotone faq isn't "why has darcs frozen"
04:18:46 <gour> _matthew_: "tag like crazy" and no problem
04:19:28 <_matthew_> I would have thought that the haskell community would be against solutions involving "by convention"...
04:19:50 * _matthew_ is, believe it or not, not trying to start a flamewar.
04:19:51 <gour> emcs-cvs ebuild fails here...
04:20:46 <gour> after i tried pida, i did not look elsewhere...
04:20:50 <gour> *darcs
04:40:13 <lisppaste2> fasta pasted "Why does this need -fno-monomorphism-restriction?" at http://paste.lisp.org/display/33335
04:55:14 <_matthew_> it really is a shame that in some fonts, '~' appears horizontally in line with '-' which makes ~> look a bit like -> but in other fonts, '~' is right at the top.
05:01:10 <wilx|wrk> :)
05:34:11 <ToRA> _matthew_: so what you really want is a „Ä ?
05:43:35 <ToRA> „Äú even
05:44:05 <_matthew_> err yeah, that'll be SO convenient to enter...
05:44:07 <_matthew_> ;)
05:44:24 <ToRA> well if you were a vim user...
05:44:31 <_matthew_> ?slap ToRA
05:44:32 * lambdabot beats up ToRA
05:51:07 <malebria> Hello.
05:51:18 <malebria> Is there a possible release date for the next version of gtk2hs?
05:51:27 <syntaxfree> are there any clever tuple functions in the prelude?
05:51:30 <syntaxfree> stuff like
05:51:36 <syntaxfree> lift f (x,y) = (f x, f y)
05:51:42 <edi> yep
05:52:06 <edi> > (join (***) (*2)) (1,10)
05:52:07 <lambdabot>  (2,20)
05:52:19 <edi> > ((*2) *** (*2)) (1,10)
05:52:21 <lambdabot>  (2,20)
05:52:28 <_matthew_> ?type ***
05:52:29 <lambdabot> parse error on input `***'
05:52:31 <edi> > ((+2) *** (*2)) 10
05:52:31 <lambdabot>  add an instance declaration for (Num (b, b'))
05:52:35 <edi> > ((+2) &&& (*2)) 10
05:52:36 <lambdabot>  (12,20)
05:52:37 <edi> sorry
05:52:39 <malebria> ?type (***)
05:52:41 <lambdabot> forall (a :: * -> * -> *) c' c b' b. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
05:52:48 <ToRA> that feel's very arrow like
05:52:58 <syntaxfree> ah, that's too much trickery for the tutorial I'm writing.
05:53:11 <edi> It's just the (a -> b) arrow
05:53:29 <syntaxfree> I will mention it en passant.
05:53:34 <syntaxfree> Let me see if I understand.
05:53:50 <syntaxfree> > (join (***) (+1)) (5,6)
05:53:51 <lambdabot>  (6,7)
05:54:25 <_matthew_> if tuple implemented functor ... ?
05:54:46 <Cale> It would only apply the function to its second part
05:55:11 <Cale> (or last part, in general)
05:55:48 <Cale> instance Functor ((,) a) where
05:55:57 <Cale>    fmap f (x,y) = (x, f y)
05:56:45 <_matthew_> ahh, because of the rules... so the id one is safe regardless
05:56:50 <_matthew_>  fmap (f . g)  ==  fmap f . fmap g
05:57:26 <_matthew_> so why would that be violated if fmap f (x,y) = (f x, f y)
05:58:19 <_matthew_> mm. I can't see it would so I must be missing something else. Cale?
05:58:48 <Cale> Think about the types :)
05:59:04 * _matthew_ tries to think
05:59:11 <edi> ah, a functor has kind * -> *.
05:59:22 <Cale> and yes, the kinds :)
05:59:30 <Cale> (,) has kind * -> * -> *
05:59:51 <_matthew_> ah ha.
06:00:06 <Cale> You'd need type-lambda to join its parameters, which we don't have.
06:00:14 <_matthew_> why not?
06:00:34 <Cale> It makes type inference and checking harder.
06:00:40 <_matthew_> and? ;)
06:00:44 <syntaxfree> I don't understand (,). It's a data constructor?
06:00:54 <_matthew_> :t (,)
06:00:56 <edi> Both data and type constructor.
06:00:56 <lambdabot> forall b a. a -> b -> (a, b)
06:01:00 <Philippa> as in "much much harder, you thought there are problems with GADTs and typeclasses but this is much worse"
06:01:00 <Cale> (,) is both a type constructor and data constructor
06:01:01 <syntaxfree> ah.
06:01:07 <syntaxfree> So (,) 2 3 5 is illegal.
06:01:15 <_matthew_> :t []
06:01:17 <lambdabot> forall a. [a]
06:01:19 <Cale> > join (,) 5
06:01:21 <lambdabot>  (5,5)
06:01:28 <Cale> > ap (,) succ 5
06:01:29 <lambdabot>  (5,6)
06:01:39 <syntaxfree> I was thinking it wouldn't be typeable if different-sized tuples were to be constructable from (,)
06:01:42 <syntaxfree> > (,) 5 6
06:01:43 <lambdabot>  (5,6)
06:01:50 <syntaxfree> > (,) 5 6 7
06:01:51 <roconnor> > (,,) 5 6 7
06:01:51 <lambdabot>    The function `(,)' is applied to three arguments,
06:01:51 <lambdabot>   but its type `a ->...
06:01:52 <lambdabot>  (5,6,7)
06:01:54 <syntaxfree> POIFECT.
06:01:58 <syntaxfree> er, poifect.
06:01:59 <_matthew_> > (,,) 5 6 7
06:02:02 <lambdabot>  (5,6,7)
06:02:04 <edi> > ((+1) &&& (*2) &&& (subtract 3)) 10
06:02:06 * syntaxfree didn't mean to scream.
06:02:06 <lambdabot>  (11,(20,7))
06:02:32 <_matthew_> Philippa: and that's an excuse?!! ;-P
06:03:21 <Philippa> given that a broken type system makes false promises, yes
06:03:27 <edi> > (succ >>= (,)) 5
06:03:29 <lambdabot>  (6,5)
06:03:30 <edi> dual to Cale's
06:03:59 <_matthew_> why does lambdabot give more info on :t than ghci? eg:
06:04:05 <_matthew_> ?type fmap
06:04:06 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
06:04:19 <_matthew_> :t fmap
06:04:19 <_matthew_> fmap :: (Functor f) => (a -> b) -> f a -> f b
06:04:21 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
06:04:23 <edi> In fact ?type only calls GHCi.
06:04:34 <Cale> -fglasgoe-exts
06:04:39 <Cale> *cough*
06:04:39 <Philippa> presumably with a verbose flag on?
06:04:40 <Cale> -fglasgow-exts
06:04:43 <_matthew_> mmm. ahh. many thanks
06:04:51 <Philippa> it shouldn't be showing forall at all without it, but hey
06:05:28 <Cale> The verbosity is a little annoying when you're trying to show something to beginners.
06:06:58 <syntaxfree> It wasn't showing kinds some time ago.
06:08:04 <_matthew_> err, so if "kinds" are *s then what are ?? and ? ?
06:08:07 <_matthew_> i.e.
06:08:12 <_matthew_> :kind (->)
06:08:18 <_matthew_> ?kind (->)
06:08:20 <lambdabot> ?? -> ? -> *
06:08:44 <metaperl> lil help dudes.... how can I get this to work. sumInts''' =  (readLn :: IO [Int]) >>= sum >>= return
06:09:55 <ToRA> (readLn :: IO [Int] ) >>= return.sum
06:10:36 <Cale> sumInts''' = fmap sum (readLn :: IO [Int])
06:10:59 <metaperl> figured it out - sumInts''' =  (readLn :: IO [Int]) >>= return . sum
06:11:00 <metaperl> yes
06:12:41 <lisppaste2> metaperl annotated #33327 with "which sumInts do you like the best?" at http://paste.lisp.org/display/33327#10
06:15:14 <ToRA> > fmap (+3) [1,2,3,4,5]
06:15:16 <lambdabot>  [4,5,6,7,8]
06:16:26 <metaperl> ToRA, hwy not just map?
06:16:34 <metaperl> > map (+3) [1..5]
06:16:36 <lambdabot>  [4,5,6,7,8]
06:16:38 <ToRA> yeah i know
06:16:50 <ToRA> i hadn't seen / looked at Functor  / fmap before
06:16:51 <_matthew_> > fmap (+3) $ map Just [1,2,3,4,5]
06:16:52 <lambdabot>  add an instance declaration for (Num (Maybe a))
06:16:56 <ToRA> wanted to check my intuition
06:17:36 <ToRA> >fmap (fmap (+3)) $ map Just [1,2,3,4,5]
06:17:46 <ToRA> > fmap (fmap (+3)) $ map Just [1,2,3,4,5]
06:17:47 <syntaxfree> fmap is fun, fmap is fair. You may already have one, you may already be there.
06:17:47 <lambdabot>  [Just 4,Just 5,Just 6,Just 7,Just 8]
06:18:04 <syntaxfree> anyway, this is what I was writing.
06:18:05 <syntaxfree> http://syntaxfree.wordpress.com/2006/12/24/static-vs-dynamic-typing-do-what-thou-wilt/
06:18:08 <lambdabot> Title: Static vs dynamic typing: do what thou wilt ¬´ Data.Syntaxfree, http://tinyurl.com/ykvay5
06:18:09 <_matthew_> oh yeah, thanks ToRA
06:18:10 <syntaxfree> I'm out for xmas lunch.
06:18:13 <syntaxfree> Thanks for the help everyone.
06:22:43 <_matthew_> > let fm = fmap (fmap (+3)) $ map Just [1.]; m = map (fmap (+3)) $ map Just [1..] in fm == m
06:22:44 <lambdabot>  Parse error
06:22:55 <_matthew_> > let fm = fmap (fmap (+3)) $ map Just [1..]; m = map (fmap (+3)) $ map Just [1..] in fm == m
06:22:59 <lambdabot> Terminated
06:22:59 <_matthew_> ;)
06:26:44 <ndm> does anyone understand Joachim on teh mailing list?
06:27:00 <ndm> and can anyone think of a place where serialising an infinite data structure is a good idea?
06:30:13 <Philippa> not one that doesn't have a corresponding finite structure to serialise instead
06:31:27 <sieni> what's wrong with like, sending the string "[1..]" down a wire?
06:31:38 <metaperl> I want to try to simulate map with do...
06:31:54 <metaperl> > do { x <- [1..5]; y <- x + 1; return y }
06:31:55 <lambdabot>  add an instance declaration for (Num [a])
06:32:03 <metaperl> ?
06:32:14 <Philippa> sieni: per se, nothing
06:32:16 <_matthew_> metaperl : yeah, to use (<-) you have to have a monadic function
06:32:18 <Cale> > do { x <- [1..5]; return (x + 1) }
06:32:20 <lambdabot>  [2,3,4,5,6]
06:32:23 <_matthew_> (+) is not monadic
06:32:25 <Philippa> however, attempting to send actual thunks is... damn stupid
06:32:25 <ndm> sieni: the fact that it _will_ go wrong, the only question is when
06:32:30 <Cale> > do { x <- [1..5]; let y = x + 1; return y }
06:32:31 <lambdabot>  Parse error
06:32:34 <metaperl> Cale - thanks!
06:32:48 <metaperl> ahhh! I see _matthew_
06:32:49 <Cale> > do { x <- [1..5]; let {y = x + 1}; return y }
06:32:50 <Philippa> ndm: you mean the open invitation to DoS? :-)
06:32:50 <metaperl> thanks
06:33:16 <lambdabot>  [2,3,4,5,6]
06:33:21 <Cale> ah, okay
06:33:22 <ndm> Philippa: yeah, i didn't get how lazy=dos, especially when a lazy language is guaranteed to terminate everywhere a strict one will, and more
06:33:24 <Philippa> shit, if you care that much write an interpreter already and serialise the code
06:33:29 <Cale> hehe
06:33:44 <Cale> I think it would be rather cool to be able to serialise thunks
06:33:56 <Philippa> it would hypothetically if you could make it portable
06:33:56 <ndm> yes, cool, and you can with Yhc, but also not a great idea
06:34:17 <Cale> actually, what would be far more cool than that is being able to serialise values of IO type into native executables
06:34:18 <Philippa> ndm: I remember talking to beelsebob about that and a few other bits and pieces
06:34:21 <ndm> its great for doing distributed computing, but for client-server communicatino
06:34:37 <Philippa> for client-server, WT/F/ are you sending code?
06:34:44 <Cale> indeed
06:35:00 <ndm> i would define a concrete message, and send that between client/server
06:35:32 <Cale> actually, hmm... that would let you write a "compiler" from an interpreter extremely easily.
06:35:47 <Cale> (serialising IO into binaries)
06:36:04 <ndm> that would be neat
06:36:09 <Cale> however, you probably wouldn't want to actually do it that way :)
06:36:17 <ndm> although seems impossbile, not sure why though
06:36:21 <Philippa> TH works easily enough for that
06:36:27 <Philippa> you just sort of stage-annotate the interpreter
06:36:49 <dcoutts__> @tell malebria did you see the gtk2hs pre-release notice? the next release should be soonish, I'd guess early in the January, eg 6th or there abouts. You can try the pre-release tarball right now.
06:36:49 <lambdabot> Consider it noted.
06:36:54 <Cale> Still, it would be nice for being able to save the future of your computation for later.
06:37:23 <Philippa> true
06:37:39 <Cale> For very long computations, it's nice to be able to save (or back up) all their intermediate state to disk.
06:38:23 <Philippa> reifying the state might be an obvious way to start
06:38:44 <Cale> However, if you're using infinite (or combinatorially large) data structures, that becomes impossible without the ability to serialise thunks.
06:38:47 <Philippa> wouldn't be too hard to write a yielding state monad, no?
06:39:00 <Cale> I don't just mean state in that sense
06:39:43 <Cale> but something like that :)
06:42:10 <Philippa> I think I'm saying that if you're worried about that it's time to build the relevant infrastructure rather than hoping for a 'magic' solution from the language
06:42:34 <metaperl> > [1..5] >>= return (y+1)
06:42:39 <lambdabot>  Not in scope: `y'
06:43:01 <metaperl> > [1..5] >>= return . (\x -> x+1)
06:43:04 <lambdabot>  [2,3,4,5,6]
06:43:08 <Philippa> > [1..5] >>= return . (+1)
06:43:10 <lambdabot>  [2,3,4,5,6]
06:43:21 <metaperl> sweet. thanks
06:43:32 <Lemmih> > [2..6]
06:43:33 <lambdabot>  [2,3,4,5,6]
06:43:50 <metaperl> is there a >> like operator that relieves me from putting return there?
06:44:05 <metaperl> that's a great solution Lemmih - the telepathic approach :)
06:44:15 <metaperl> lol
06:44:27 <metaperl> to hell with computation when telepathy will do
06:44:28 <Lemmih> > (+1) `fmap` [1..5]
06:44:30 <lambdabot>  [2,3,4,5,6]
06:44:52 <metaperl> @type fmap
06:44:54 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
06:45:06 <ToRA> > [1,2,3] >> return 4
06:45:07 <lambdabot>  [4,4,4]
06:45:10 <metaperl> oh sweet
06:45:16 <metaperl> thanks Lemmih I like that fmap a lot
06:45:28 <metaperl> I knew there some was something wrong with typing return so much
06:45:31 <twanvl> > map (+1) [1..5]
06:45:32 <lambdabot>  [2,3,4,5,6]
06:45:40 <metaperl> but it only works on functors not monads... hmm
06:45:41 <twanvl> Or is that too obvious?
06:46:04 <metaperl> no twanvl  that's fine tooo. thanks
06:46:37 <metaperl> Cale's tutorial goes over when a Monad is not a functor
07:16:14 <benja_> metaperl: you can add an instance declaration to make it a functor, of course :-)
07:17:05 <benja_> instance Functor MyMonad where fmap f x = x >>= return . f
08:45:54 * arjanoosting thinks it's beautifull
08:46:28 <arjanoosting> oeps wrong channel
08:50:47 <Axioplase> Hi
08:53:47 <Axioplase> Can someone help me find how to use the StateMonad to achieve the following at http://rafb.net/p/UHWKYk28.html ?
08:53:49 <lambdabot> Title: Nopaste - Lambda term labelling
09:00:11 <emu> is there a limit on the size of ghc arrays?
09:00:37 <roconnor> @type StateMonad
09:00:39 <lambdabot> Not in scope: data constructor `StateMonad'
09:00:47 <roconnor> @type Control.Monad.StateMonad
09:00:48 <lambdabot> Not in scope: data constructor `Control.Monad.StateMonad'
09:00:52 <roconnor> @type Control.Monad.StateMonad.StateMonad
09:00:53 <lambdabot> Couldn't find qualified module.
09:01:00 <roconnor> oh wait, it is called MonadState?
09:01:05 <roconnor> @type Control.Monad.State.MonadState
09:01:06 <lambdabot>   Not in scope: data constructor `Control.Monad.State.MonadState'
09:01:12 <roconnor> @hoogle MonadState
09:01:14 <lambdabot> Control.Monad.State.MonadState :: class Monad m => MonadState s m
09:01:53 <roconnor> So you want something like conv :: Term -> Int -> MonadState Integer LabelTerm I suppose
09:02:08 <Axioplase> roconnor: Control.Monad.State
09:02:52 <roconnor> oh wait
09:02:57 <roconnor> So you want something like conv :: Term -> MonadState Integer LabelTerm I suppose
09:03:08 <Axioplase> roconnor: well... All I want is a counter.. So I guess it's a good use for the State monad...
09:03:55 <Axioplase> roconnor: Yes, this would be nice as long as I can get the generated LabelTerm outside the monad after it is generated
09:04:46 <roconnor> conv (App a b) label = do { x <- (conv a); y <- (conv b); i<-get; put (i+1); return (Sapp i x y)}
09:04:55 <roconnor> conv (App a b) = do { x <- (conv a); y <- (conv b); i<-get; put (i+1); return (Sapp i x y)}
09:05:01 <roconnor> or something like that
09:05:07 <roconnor> @type get
09:05:09 <lambdabot> forall s (m :: * -> *). (MonadState s m) => m s
09:05:15 <roconnor> @type put
09:05:18 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => s -> m ()
09:05:38 <roconnor> @type runState
09:05:40 <lambdabot> forall s a. State s a -> s -> (a, s)
09:06:03 <roconnor> @type evalState
09:06:05 <lambdabot> forall a s. State s a -> s -> a
09:06:35 <roconnor> Then to get the result you do evalState (conv term) 0
09:06:47 <roconnor> Um, so this is off the top of my head.
09:06:52 <Axioplase> Ok. I try to write my func in the monad.
09:06:54 <roconnor> So you may encounter some troubles
09:07:02 <roconnor> but this is the general idea
09:08:35 <roconnor> @type Control.Monad.State.State
09:08:37 <lambdabot> forall a s. (s -> (a, s)) -> State s a
09:08:46 <roconnor> right
09:09:04 <roconnor> the type will me more like conv :: Term -> State Integer LabelTerm I suppose
09:09:15 <roconnor> State is the type constructor
09:09:21 <roconnor> MonadState is the type class
09:09:46 <shapr> @yow !
09:09:46 <lambdabot> PUNK ROCK!!  DISCO DUCK!!  BIRTH CONTROL!!
09:10:04 <yaxu> i just did some maths without understanding it
09:10:16 <shapr> Is that legal?
09:11:12 <roconnor> yaxu: I used to do that all the time when doing differential geometry.
09:11:37 <yaxu> i was trying to get the type conversion right so this would work:  (x + ( (x' - x) * 0.5 ) - 0.5
09:11:59 <yaxu> then somehow realised that "min" is the same
09:12:05 <yaxu> although i'm not sure why
09:12:33 <roconnor> yaxu: that strikes me as unlikely
09:12:58 <roconnor> @quickcheck \x x' -> min x x' == (x + ( (x' - x) * 0.5 ) - 0.5
09:12:58 <yaxu> well at this point i'm quite confused, but my code works
09:12:59 <lambdabot> Unknown command, try @list
09:13:05 <roconnor> @qcheck \x x' -> min x x' == (x + ( (x' - x) * 0.5 ) - 0.5
09:13:05 <lambdabot> Maybe you meant: check scheck
09:13:09 <roconnor> @check \x x' -> min x x' == (x + ( (x' - x) * 0.5 ) - 0.5
09:13:10 <lambdabot>  Parse error
09:13:18 <roconnor> @check \x x' -> min x x' == (x + ( (x' - x) * 0.5 ) - 0.5)
09:13:20 <lambdabot>  Add a type signature
09:13:32 <roconnor> @check \x x' -> min x x' == ((x + ( (x' - x) * 0.5 ) - 0.5)::Rational)
09:13:34 <lambdabot>  Falsifiable, after 0 tests: 1%1, 1%1
09:13:40 <roconnor> tada
09:14:23 <yaxu> hum
09:15:13 <roconnor> > let x' = 1 in let x = 1 in ((x + ( (x' - x) * 0.5 ) - 0.5))
09:15:15 <lambdabot>  0.5
09:15:45 <lisppaste2> yaxu pasted "peano space filling" at http://paste.lisp.org/display/33344
09:15:45 <roconnor> yaxu: to be fair I added a closing brace randomly to your formula
09:16:39 <yaxu> roconnor: was a good guess though
09:16:41 <yaxu> :)
09:19:45 <integral> "An airplane written in Haskell would be a comonadic catamorphism of a 10 dimensional hypertree...or something."
09:19:47 <yaxu> i'm making an lsystem to construct a peano curve that fills a 2D plane, and that bit is finding midpoints on each step of the path around the plane
09:20:38 <roconnor> integral: I would have expected 6 dimensions
09:20:58 <roconnor> or maybe 12
09:21:15 <yaxu> somehow both that formula and min makes sense to me
09:21:49 <roconnor> yaxu: I don't think you can write min without invoking absolute value somewhere
09:22:25 <yaxu> roconnor: i'm only dealing with integers if that's what you mean
09:22:37 <roconnor> yaxu: still.
09:24:10 <yaxu> roconnor: what do you mean by absolute value?
09:25:40 <roconnor> @type abs
09:25:42 <lambdabot> forall a. (Num a) => a -> a
09:33:16 <araujo> morning!
09:58:03 <george> how can i use System.Random to pick a random item from a list of [a] ?
09:58:21 <george> so i guess, pick a random number between 1 and length [a]
09:58:31 <george> and i know how to select that item then
10:02:06 <shapr> george: Can you use System.Random.randomR ?
10:02:23 <shapr> file:///usr/share/doc/ghc6-doc/html/libraries/base/System-Random.html#v%3ArandomR
10:02:44 <george> will have a look
10:09:06 <george> any idea how i can convert an IO int to an int?
10:09:27 <_matthew_> you can't
10:09:36 <_matthew_> except with (<-)
10:09:55 <_matthew_> and then you can use the value to call another function
10:10:04 <_matthew_> eg.
10:10:36 <_matthew_> if a::IO Int then you can do b <- a and b::Int so then you can call a function. Eg b+10
10:10:52 <bd_> only in a do-block does (<-) work
10:11:09 <_matthew_> yup. I should have mentioned that too.
10:11:10 <bd_> you can do (>>=) :: IO a -> (a -> IO b) -> IO b
10:11:24 <bd_> but there's no way to 'escape' IO
10:11:26 <bd_> that's the point :)
10:11:40 <george> but i have been told to use randomRIO
10:11:42 <bd_> [1] - there are ways to escape IO actually, but chances are they don't do what you want
10:11:56 <george> and that gives me a random number between a and b
10:12:07 <george> but i cant use this number in my program
10:12:11 <george> because its a IO int
10:12:14 <george> what is the use
10:12:44 <bd_> you have to accept the random value in a do-block
10:12:44 <bd_> eg
10:12:51 <bd_> :t randomRIO
10:12:52 <lambdabot> forall a. (Random a) => (a, a) -> IO a
10:12:53 <george> but i dont know how many random values i need
10:13:06 <bd_> do v <- randomRIO (1, 10)
10:13:09 <bd_>    print v
10:13:22 <bd_> george: you have to loop in hte do-block then :p
10:13:43 <george> i dont understand...
10:14:00 <bd_> eg
10:14:07 <Jaak> > take 3 . map (`mod` 100) . randoms $ mkStdGen 0
10:14:07 <lambdabot>  [31,80,62]
10:14:07 <bd_> do v <- randomRIO (0, 10)
10:14:10 <bd_>    print v
10:14:17 <bd_> er
10:14:24 <bd_> loop = do v <- randomRIO (0, 10)
10:14:28 <bd_>           print v
10:14:34 <bd_>           when (v /= 0) loop
10:14:40 <bd_> something like that
10:14:49 <Jaak> > randomRIO (0, 100 :: Int) >>= print -- maybe?
10:14:51 <lambdabot>  <IO ()>
10:14:56 <Jaak> uh :\
10:15:04 <bd_> Jaak: lambdabot doesn't allow IO :)
10:15:09 <bd_> security reasons
10:15:18 <bd_> anyway, I must go for now
10:15:20 <Jaak> ooh
10:15:27 <Jaak> it used to, no?
10:15:32 <bd_> I hope not :p
10:15:38 <bd_> ghci will do it though
10:15:44 <bd_> *gone*
10:27:11 <allbery_b> hm.  I'm getting a headache from trying to comprehend the business about functional dependencies and ghc failing to unify types that look identical to me. feh
10:28:02 <alc> how to read 2 numbers separated by space on the same line, like '123 456'?
10:28:48 <alc> hmm i can use readLn to read one number at one line.. but for 2 or more numbers.. is there some kind of scanf-like function?
10:29:46 <allbery_b> > map (read :: String -> Int) $ words "123 456"
10:29:47 <lambdabot>  [123,456]
10:30:43 <allbery_b> you may not need the type annotation if the context in which you're using it forces a type; "read" is very polymorphic
10:30:54 <Axioplase> allbery_b: read::IO(Int,Int)  and then (1,2) for example
10:31:42 <Axioplase> I meant alc
10:31:55 <Axioplase> or read::IO[Int] and [1,2,3,4]
10:32:34 <alc> allbery_b, thanks. map is really cool. =)
10:46:39 <scodil> anyone use neil mitchell's FilePath library?
10:51:00 <yaxu> anyone read sound samples from /dev/dsp or similar with haskell?
10:51:17 <yaxu> or care to suggest how i might do that? :)
10:52:57 <lightstep> hGetBuf?
10:56:12 <lisppaste2> allbery_b pasted "what am I missing about the type here? (line 90)" at http://paste.lisp.org/display/33347
10:56:23 <yaxu> seems like i'd need to do some things with ioctl first to get something other than 8bit mono
10:57:59 <allbery_b> I expect you'll need FFI to deal with the sound device ioctls
10:58:58 <yaxu> foreign function interface
10:59:03 <yaxu> ok thanks
10:59:13 <lightstep> allbery_b, do you really want ZemanState to be an existential type?
10:59:45 <scodil> yaxu: there's haskell bindings to openAL, if that helps
11:01:14 <allbery_b> sigh.  I don't understand the questionm.  (just woke up, brain not quite there yet)
11:01:27 <allbery_b> if I add "forall a." it doesn't change anything
11:01:43 <yaxu> scodil: aha yes hopefully
11:02:01 <lightstep> i wonder why you didn't define is as type ZemanState a = ..., analogous to ZemanBase
11:03:52 <allbery_b> I made that change (I'm not sure it should matter, just wanted a shorter name for that unwieldy type --- and also, preferably, to hide the Map from outside eyes) but adding it doesn't change the error
11:04:42 <shapr> yaxu: Have you tried the latest version of Haskore with all the changes?
11:05:21 <shapr> yaxu: Also, do you have some library for talking directly to a supercollider server from Haskell?
11:06:09 <yaxu> shapr: no i haven't been working on that project recently, will have more time from it from now on though
11:06:30 <yaxu> shapr: rohan drape's hsc library is what you want
11:06:41 <yaxu> http://slavepianos.org/rd/f/409875/
11:06:43 <lambdabot> Title: rohan drape: hsc [409875]
11:06:48 <lightstep> allbery_b, can you give the new declaration?
11:07:34 <shapr> ah cool!
11:07:56 <lisppaste2> allbery_b annotated #33347 with "refined the type a bit, same error" at http://paste.lisp.org/display/33347#1
11:08:26 <allbery_b> when I type some of the actual functions with it, I also get complaints about functional dependencies
11:08:38 <yaxu> shapr: he's separated some stuff out here too - http://slavepianos.org/rd/f/507293/
11:08:39 <lambdabot> Title: rohan drape: sc.* [507293]
11:08:41 <allbery_b> which suggests I'm missing something somewhere but I'm just not getting *what*
11:09:11 <shapr> yaxu: Your livecoding screencast reminds me of Kid Koala's performances.
11:10:09 <yaxu> shapr: oh yeah?  i'll have to download some...
11:10:40 <yaxu> shapr: any recommended releases?
11:11:48 <dancor> is getTables supposed to return [] when i have a table?
11:12:02 <dancor> in HDBC-PostgreSQL
11:12:08 <shapr> yaxu: Check out this live performance of Drunk Trumpets for example - http://video.google.com/videoplay?docid=122310250207899098&q=kid+koala
11:12:11 <lambdabot> Title: shoowfloo Kid Koala Turntablism Champion - Google Video, http://tinyurl.com/ttgbf
11:12:16 <lightstep> allbery_b, what i think you're trying to do is control the type in TimeOffset
11:12:34 <dancor> also quickQuery-ing all rows from that table returns []
11:12:37 <lightstep> allbery_b, the usual awy to do this is to pass it all the way down, like in ZemanBase
11:12:52 <dancor> but if i change the table name to something non-existent i get an "unknown error"
11:13:04 <dancor> who was it that told me that HDBC was really good
11:13:18 <yaxu> shapr: NICE
11:13:40 <lightstep> allbery_b, this "forall" in the right hand side of the "=" overrides the "a" parameter to ZemanState, so it's still an existential type, which means you need to give it very polymorphic parameters
11:14:28 <allbery_b> actually I'd tried with and without the forall, no difference.  (note also that if I omit the type and let ghc(i) infer it, it includes the forall)
11:15:07 <george> is it valid code if i use guards, and then for the otherwise case I  use do?
11:15:09 <lightstep> it infers it since you use a qualifying clause (this RealFloat a =>). this "a" in the clause had to come from somewhere
11:15:42 <shapr> yaxu: I like this one better - http://www.youtube.com/watch?v=YiSFxDJQU48
11:15:46 <yaxu> shapr: i'm not worthy
11:16:09 <shapr> Kid Koala sho is good stuff :-)
11:16:11 <allbery_b> hrm.  latest one is telling me that it's already got "a" in scope and I need a forall.
11:16:12 <lightstep> if this type was existential, you couldn't construct ZemanState from (TimeOffset Double), you would ahve to construct it from (forall a. RealFloat a => TimeOffset a)
11:17:09 <lightstep> you can't declare a type class constraint on type aliases, so you have to leave that out
11:19:38 <allbery_b> hm.  sure enough, delete the cnstraint and it works.
11:19:48 <yaxu> shapr: ha i wouldn't like to be the guy playing after him in that video
11:20:22 <shapr> You think he's a hard act to follow?
11:21:05 <shapr> Moby might be able to play after him and survive.
11:21:51 <yaxu> shapr: yeah it would be ok if you were playing something completely different i guess
11:22:35 <yaxu> well i must say that #haskell is a much more relaxing place to hang out in than #atheism
11:23:06 <shapr> Yeah, I'm a Baptist, and #atheism never did much for me.
11:23:38 <yaxu> it's a tad argumentative
11:23:41 <shapr> I don't mind what other people believe as long as they don't bother me about what I believe.
11:24:10 <yaxu> there is much bother over there
11:24:11 <shapr> But I do get pissy when condescending things are said about my beliefs.
11:24:15 <ndm> i would have thought most people on atheism were atheists, and hence in basic agreement...
11:24:39 <yaxu> ndm: that's what i thought, but no
11:25:31 <ndm> its like the slashdot debates on whether open source is good or not, its like an argument between a large number of people all of whom think absolutely the same thing
11:26:11 <shapr> I think part of the problem is that many people are just sheep, and they follow whoever yells loudest.
11:26:30 <yaxu> ndm: there are plenty of religious people on #atheism
11:26:51 <yaxu> #atheism seems to be where people go to bother each other
11:27:00 <ndm> nice :)
11:27:02 <shapr> Yow, I'll stay away from that place.
11:27:14 <shapr> I have useful things to do :-)
11:27:19 <newsham> merry christmas to those living in tomorow.
11:27:33 <george> anyone could tell me what is bad with: >		   let z = findWithDefault [] k m         i get error:  Syntax error in declaration (unexpected token)
11:27:37 <yaxu> shapr: indeed
11:28:09 <ndm> george: nothing i can see, perhaps paste the whole chunk of code and teh exact error message
11:28:11 <ndm> @paste
11:28:11 <lambdabot> http://paste.lisp.org/new/haskell
11:28:31 <shapr> yaxu: Is that your first encounter with Kid Koala?
11:28:44 <ndm> george: unless you are using plain .hs, rather than .lhs, in which case the > is an error
11:29:19 <yaxu> shapr: yes i think so, it looks like the kind of thing best seen live
11:29:31 <yaxu> will check out his records tho
11:29:54 <lisppaste2> george pasted "playing with IO" at http://paste.lisp.org/display/33348
11:30:08 <yaxu> i definitely need to see more live music next year though
11:31:11 <george> basically, i had a function that works and i want to make it work with an IO RNG too
11:31:19 <george> but that part is later
11:31:25 <george> im just really bad with IO
11:31:28 <ndm> george: you are missing an =
11:31:35 <ndm> george: before the do
11:31:49 <yaxu> i think #atheism is stuck in a 15 minute cycle, now i've done my 15 minutes i don't have to go there again
11:32:14 <george> ndm: ty
11:32:17 <shapr> I could point you to more Kid Koala live performances.
11:32:21 <fasta> Doesn't Haskell double the amount of type classes needed, since you can have a monadic interface or not?
11:32:26 <yaxu> the channel that is, rather than the philosophical stance
11:32:31 <yaxu> shapr: yes please
11:32:32 <shapr> fasta: huh?
11:32:52 <fasta> shapr: class Foo a versus class Foo m a
11:33:31 <shapr> I don't understand, why would you need to have a monadic typeclass like that?
11:33:35 <fasta> shapr: implementations in Foo m a can use ST
11:34:36 <fasta> shapr: the separation between pure and impure code implies it, unless I am mistaken.
11:36:07 <shapr> I don't think I understand what you mean. I think ST a means you can have whatever type you want in ST.
11:36:12 <augustss> fasta: usually you don't bother with that kind of duplication
11:36:12 <sorear> Identity monad.
11:36:43 <sorear> you can have a monadic interface, and use it with no monad, using Control.Monad.Identity.
11:36:47 <fasta> sorear: yes, I thought of that, but still that degrades everything to the monadic interface which is arguable "uglier"
11:37:05 <fasta> augustss: what do you do in this case?
11:37:14 <sorear> Are you referring to e.g. IArray/MArray?
11:37:38 <augustss> fasta: let me ask you, what classes are you complaining about?
11:39:53 <fasta> augustss: My own classes, a pure interface is possible in this case, but according to some paper I read, very slow.
11:40:07 <shapr> yaxu: Searching for Kid Koala on YouTube turns up a bunch of different things.
11:40:34 <fasta> sorear: IArray/Marray is an instance of the problem
11:40:45 <newsham> wouldnt an identity monad artificially imply ordering where functional code would not?
11:40:46 <augustss> fasta: so i've not really experienced the problem.  but as sorear suggested, there is the identity monad
11:40:46 <fasta> MArray, even
11:40:53 <newsham> (err. funcitonal non-monadic code)
11:40:58 <fasta> augustss: is that the usual solution?
11:41:20 <newsham> so seems like you'd still want separation
11:41:25 <augustss> from my experience, the problem isn't common enough to talk about a usual solution
11:44:07 <yaxu> shapr: it's a shame my audio and video are always out of sync with flash :/
11:45:37 <fasta> augustss: you can see a good example of this in The Functional Graph Library. It has a GraphM type class and a Graph type class, both with the same operations.
11:46:00 <george> if i have a function that returns an IO String
11:46:04 <george> how do i show this string?
11:46:16 <sorear> getLine >>= print ?
11:46:33 <shapr> yaxu: Yeah, me too :-/ Flash sucks butt.
11:46:51 <sorear> or: do x <- getLine ; putStrLn x
11:47:25 <george> sorear: my function already returns a type IO String
11:47:50 <integral> @hoogle Char -> Int
11:47:50 <lambdabot> Char.digitToInt :: Char -> Int
11:47:50 <lambdabot> Char.ord :: Char -> Int
11:48:21 <george> with putStr i get errors that an IO String does not match the expected type (String)
11:48:22 <sorear> integral: fromEnum will probably also do (and is in the Prelude)
11:48:29 <integral> ah, okay
11:48:30 <augustss> and fromEnum
11:48:43 <augustss> ord=fromEnum
11:49:01 <sorear> so, you have a function foo :: IO String, and you want to make a bar :: IO () which calls foo and displays the result?
11:49:08 <george> yes
11:49:19 <augustss> but fromEnum is always in scope
11:49:26 <yaxu> bah, i openAL isn't compiling...  "Failed to load interface for `Sound.OpenAL.AL':"
11:49:28 <george> foo :: lots of junk -> IO String
11:49:44 <wolverian> bar = foo >>= putStrLn
11:50:11 <sorear> :t putStrLn (getLine)
11:50:12 <lambdabot>   Couldn't match `String' against `IO String'
11:50:13 <lambdabot>    Expected type: String
11:50:20 <sorear> :t getLine >>= putStrLn
11:50:21 <lambdabot> IO ()
11:50:35 <sorear> :t do { x <- getLine  ;  putStrLn x }
11:50:36 <lambdabot> IO ()
11:50:46 <sorear> ^^^ those two are equivalent
11:52:02 <augustss> fasta: i think i'd just make the monadic class and then define the pure interface in terms of that
11:52:50 <augustss> unless there is some good reasons for splitting the classes.  like different implementations with and without monads
11:52:56 <george> hah =) it is working perfectly, thanks guys
11:53:28 <sorear> fasta: perhaps you could define the pure interface in terms of runState?
11:54:40 <sorear> class MArray a where ... write :: i -> e -> a -> m () ...   pureWrite :: i -> e -> a -> a ; pureWrite i e = runState (write i e) ...
11:55:32 <augustss> well, i think it varies from case to case.  some things just don't have a reasonable pure interface
11:56:08 <fasta> augustss: how about a graph?
11:56:20 <sorear> like what? arrays can be made pure with only a logarithmic penalty (tries)
11:56:35 <fasta> augustss: more specifically an adjacency list graph
11:56:36 <sorear> (granted, log * large constant factor)
11:58:06 <augustss> fasta: what do you want to do with your graph?
11:58:47 <fasta> augustss: wait a few minutes, I have quite a lot of operations
11:58:48 <augustss> sorear: arrays have a reasonable pure interface.  IO doesn't, imo
11:59:51 <augustss> fasta: why don't you just try something?  haskell code is short enough that you can rewrite it a few times until it feels good
12:00:36 <fasta> augustss: O(1) number of edges, O(1) number of nodes, O(deg(v)) removal of vertex v, O(1) check for emptyness, O(1) insertion of vertices and edges
12:00:40 <sorear> where'd IO come from? (and in a decent higher order language, you can implement monads, continuation passing, and decision-tree IO quite easily)
12:00:42 <fasta> augustss: among some others.
12:01:34 <fasta> augustss: making the elements of the edges point back into the adjacency list as is done in imperative language is most difficult.
12:02:37 <ndm> i still haven';t found a natural Haskell representation of graphcs
12:02:43 <augustss> fasta: so why not make an imperative implementation in ST, if you feel that is the right thing
12:02:49 <sorear> what are 'elements of the edges'
12:02:58 <ndm> i tend to use GP (Graph Programming) language, which is both much faster, and much easier than Haskell for workign with graphs
12:03:01 <fasta> sorear: type Edge = (Int, Int)
12:03:20 <fasta> sorear: The "elements" are the two Ints
12:03:28 <fasta> sorear: This is for a matrix implementation
12:03:56 <augustss> fasta: probably some imperatively inspired one ;)
12:04:27 <fasta> ndm: sounds interesting
12:04:45 <ndm> fasta: also non-deterministic with back tracking, its the future of graph algorithms, i think
12:04:55 <fasta> ndm: url?
12:04:58 <ndm> sadly its not really useable externally yet..
12:05:20 <ndm> fasta: http://www-users.cs.york.ac.uk/~gm/YAM/
12:05:22 <lambdabot> Title: The York Abstract Machine
12:05:49 <fasta> ndm: Is there documentation about the language?
12:05:54 <wolverian> ndm, is Graph.Inductive not natural, you think?
12:06:16 <ndm> wolverian: i tried it, looks great for certain types of graph algorithms, looks horrbile for others
12:06:32 <fasta> wolverian: I think it's quite natural, except that it's slow
12:07:07 <wolverian> ndm, what kind of algorithms fall into the latter category?
12:07:27 <ndm> fasta: http://www-users.cs.york.ac.uk/~sandra/publications/steinert03.ps.gz, page 35 has an example on it
12:07:29 <lambdabot> http://tinyurl.com/y4phlx
12:07:51 <ndm> wolverian: algorithms doing finite state automata minimization, construction, traversal etc
12:08:09 <ndm> (at least i was doing that, and couldn't figure how to make it work well)
12:08:16 <wolverian> does it matter if it's nondeterministic?
12:08:21 <ndm> fasta: i;ve seen loads of talks on this, but no papers
12:08:28 <ndm> wolverian: not in this case, the transformation is confluent
12:09:14 <wolverian> interesting.
12:10:02 <fasta> ndm: on what?
12:11:27 <ndm> fasta: loads of talks on GP programming, its a speciality at York - 3 of the people in my group do this all day long, and most of us dabble now and again
12:11:54 <shankys_> Quick question: How do it pattern match ``Update a `Set` b `Where` c'' and ``Update a `Set` b'' without having overlapping pattern matches? For the second one I want to somehow specify that it doesn't match a `Where` part.
12:12:31 <ndm> shankys_: matches are order dependant, put the first one first and it will never run on to the second one
12:12:34 <fasta> ndm: From a quick skim I miss the point. What are the up arrows?
12:12:46 <shapr> rohar: Are you the same Michael Feathers that I've seen on Ward's Wiki for years?
12:12:47 <ndm> fasta: apply this rule as long as possible
12:12:53 <shankys_> Ok, thanks. I thought that might be the case but wasn't sure about the exact rules.
12:13:15 <ndm> shankys_: rules are match top to bottom, first matching alternative is taken
12:13:18 <fasta> ndm: to what does that language compile?
12:13:32 <ndm> fasta: YAM bytecode, which you can run with the YAM interpretter
12:13:43 <fasta> ndm: and it's faster than Haskell?
12:13:57 <ndm> fasta: if you are going to manipulate graphs all day, yes, by a LONG way
12:14:21 <ndm> as all it does is play with graphs, with hash tables and reverse lookups etc to make everything super fast
12:14:52 <fasta> ndm: so, it already has adjacency lists/matrices/hyper graphs built in?
12:15:25 <ndm> fasta: it _only_ plays with graphs, so yes, those are built in properly - as adjaceny lists with extra bits and extra mappings
12:15:28 * shapr pokes rohar
12:15:39 <ndm> fasta: i think it does hypergraphs, not sure though, they are in the language, but perhaps not the impelemtnation yet
12:15:49 <fasta> ndm: multigraphs?
12:15:54 <ndm> was discussing their implementation last month, so not sure if the ideas got coded yet
12:16:01 <ndm> fasta: multigraphs?
12:16:07 <ndm> not sure what that means
12:16:32 <fasta> ndm: a simple graph with parallel edges, but no self-loops
12:16:37 <ndm> i'm not a graph theoretician, i just happen to go for lunch with a lot of them :)
12:16:49 <ndm> fasta: how is that not just a restricted class of graphs?
12:17:03 <fasta> ndm: (it has also three other definitions)
12:17:08 <george> how do i merge to IO Strings to make a [IO String] or is it IO [String] ?
12:17:10 <george> to = 2
12:17:11 <ndm> i.e. Graph is a superset of multigraph
12:17:27 * basht looking around
12:17:31 <ndm> @hoogle sequence
12:17:31 <lambdabot> Prelude.sequence :: Monad m => [m a] -> m [a]
12:17:32 <lambdabot> Prelude.sequence_ :: Monad m => [m a] -> m ()
12:17:32 <lambdabot> Language.Haskell.TH.Syntax.sequenceQ :: [Q a] -> Q [a]
12:17:38 <fasta> ndm: it is, but a lot of people mean "simple graph" by graph.
12:17:41 <ndm> george: sequence, as above
12:17:55 <ndm> fasta: these are full graphs, parallel edges, self-loops, the works
12:18:03 <fasta> ndm: there's a notation war going on for about 30 years
12:18:04 <ndm> labelled edges and nodes
12:18:22 <ndm> we have one graph specialist lecturer, so his notation is law
12:19:43 <fasta> Did anyone read "Algorithms: A functional approach"?
12:22:13 <fasta> Anyway, I read it, and I think the graph reduction presentation was nice, although simplified. The rest of the book had little to offer. It also discussed graphs, but again in a hugely simplified way(and I think everything presented was already in some other literature (not original work)).
12:22:18 <shapr> fasta: I love that book.
12:22:21 <george> ndm I cannot just use (a:as)
12:22:23 <george> ?
12:22:38 <fasta> shapr: you liked the lazy analysis?
12:22:52 <fasta> shapr: (that's what I would expect from you)
12:22:59 <shapr> I did like the ground level intro to lazy algorithms.
12:23:08 <fasta> shapr: yes, there wasn'
12:23:08 <ndm> george: you acn do, do {x <- one; xs <- two; return (x:xs)}
12:23:13 <fasta> t anything wrong with that.
12:23:25 <shapr> I enjoyed the book because it was the second data structures and algorithms book I'd read. The first was one of the old imperative books.
12:23:33 <sorear> :t liftM2 (++)
12:23:34 <lambdabot> forall a (m :: * -> *). (Monad m) => m [a] -> m [a] -> m [a]
12:23:38 <george> hmmm
12:23:44 <george> im doing something very similar and getting a type error
12:23:45 <sorear> :t liftM2 (++) :: IO String -> IO String -> IO String
12:23:46 <lambdabot> IO String -> IO String -> IO String :: IO String -> IO String -> IO String
12:23:53 <shapr> For me, the Rabhi & Lapalme book was easier to read, and significantly more clear.
12:24:02 <fasta> shapr: Did you read the The Haskell School of Expression?
12:24:08 <sorear> runs two IO actions producing strings, and catenates the results.
12:24:09 <shapr> Only part of it.
12:24:20 <shapr> I ended up switching to The Craft of Functional Programming instead.
12:24:38 <fasta> That's more advanced?
12:24:44 <shapr> No, rather the opposite.
12:24:52 <shapr> But I was learning Haskell at the time :-)
12:25:03 <ndm> george: paste away :)
12:25:08 <shapr> Remember, I've never had any CS classes, or any math classes worth mentioning.
12:25:13 <syntaxfree> I just hung out here and asked questions.
12:25:27 * syntaxfree had one horrible CS course, in Scheme.
12:25:47 <shapr> My academic background includes most of a two year degree in art...
12:25:49 * syntaxfree is an economist, and is somewhat profficient in intermediate-level mathematics. No real cat theory, though.
12:25:59 <syntaxfree> I have a year in a half in film studies, before economics :)
12:26:19 <opqdonut> :D
12:26:22 <shapr> I had a year and a half in health physics (radiation safety) before the art degree attempt.
12:26:45 <pejo> Any kind of math helps for programming, I have barely nothing that is directly useful.
12:26:47 <shapr> fasta: On the other hand, I'm *really* enjoying Okasaki's book.
12:27:02 <ndm> i want a copy of that!
12:27:21 <ndm> my friend implemented one of the algorithms out of his thesis, and found there was a bug in it
12:27:26 <ndm> which got fixed in teh book
12:28:05 <pejo> ndm, can't you get that book through work? Sounds fairly relevant for your work. :-)
12:28:26 <pejo> (And the book wasn't very expensive iirc).
12:28:33 <fasta> pejo: he might want to read it at home ;)
12:28:34 <ndm> pejo: i don't think we have a budget for that kind of thing...
12:28:52 <ndm> i often pay train fares to various things myself, rather than claiming through work
12:29:24 <ndm> i also feel guilty when drinking beer that the uni has paid for, seems wrong somehow
12:29:52 <ndm> (although in teh reverse, if its uni provided wine i feel honour bound to drink more, weirdly)
12:29:55 <pejo> Um, I'd claim there is a quite large difference between beer and a book by Okasaki, from a moral pov.
12:30:02 <lisppaste2> george pasted "more IO problems" at http://paste.lisp.org/display/33349
12:30:06 <ndm> yes, but one is paid for by the uni!
12:30:06 <yaxu> i have four years in computer science, which was a total diversion from programming as well
12:30:09 <ndm> and its not the book
12:30:48 <ndm> george: i really suspect you want: > foo :: [Int] -> [String] -> Int -> IO [String]
12:31:08 <ndm> with that i suspect it typechecks
12:31:12 <george> well, my method when i am not sure is try every possibility... and i also get errors with that
12:31:30 <yaxu> shapr: radiation safety sounds handy, i'm organising a camp next to a nuclear power station
12:31:31 <ndm> typically IO methods are arg -> arg -> arg -> IO result
12:31:47 <george> *** Term           : do {...}      *** Type           : IO [[Char]]    *** Does not match : [a]
12:32:22 <sorear> foo m k i <===>  replicateM i (bar m k)
12:32:29 <ndm> george: is that with the type sig changed?
12:32:37 <sorear> remember you can partially apply IO actions.
12:32:41 <sorear> :t replicateM
12:32:42 <lambdabot> forall a (m :: * -> *). (Monad m) => Int -> m a -> m [a]
12:32:52 <ndm> george: just repaste everything :)
12:32:59 <sorear> :t replicateM :: Int -> IO String -> IO [String]
12:33:00 <lambdabot> Int -> IO String -> IO [String] :: Int -> IO String -> IO [String]
12:33:10 <george> ndm: that is with type sig changed yeah
12:33:21 <george> so kjust gone from [IO String] to IO [String]
12:33:33 <sorear> you need a return before []
12:33:49 <earthy> nwo that's dedication. Programming Haskell on christmas eve.
12:33:54 <george> ahhhh.. ty =)
12:33:59 <george> :e
12:34:00 <fasta> ndm: Is GP a visual programming language?
12:34:00 <george> oops
12:34:22 <fasta> ndm: nm
12:34:38 <sorear> in actual practice, I'd use the 'Control.Monad.replicateM' from the standard libs
12:34:40 <ndm> fasta: it has a GUI editor, but not
12:35:19 <fasta> ndm: It seems that it would also be possible to use the pictures as the description of rules.
12:35:38 <ndm> fasta: yes, they are equivalent
12:40:19 <george> is there an unwords equivalent for IO [String] instead of [String] ?
12:40:48 <dylan> :t lift unwords
12:40:50 <lambdabot> forall (t :: (* -> *) -> * -> *). (MonadTrans t) => t ((->) [String]) String
12:41:01 <dylan> er,
12:41:06 <dylan> :t liftM unwords
12:41:08 <lambdabot> forall (m :: * -> *). (Monad m) => m [String] -> m String
12:41:56 <george> errr
12:41:58 <george> liftM?
12:42:30 <lightstep> you can bind values from IO computations with (>>=)
12:43:02 <sorear> if foo :: a -> b, liftM foo :: IO a -> IO b (or generally for any monad)
12:43:13 <lightstep> so you can say "getArgs >>= \args -> putStr (unwords args)" or something
12:43:13 <ndm> lightstep: yes, since IO is a monad, and...
12:43:29 <george> ERROR - Undefined variable "liftM"
12:43:31 <ndm> lightstep: exactly, or rather getArgs >>= putStr . unwaords
12:43:36 <dylan> import Control.Monad
12:43:39 <shapr> yaxu: Nuclear power stations put out a lot less radiation than coal burning power stations, radiation safety is really only useful after accidents or if you work directly with radioactive material.
12:43:43 <dylan> I think...
12:43:45 <fasta> ndm: what version of HaXml does jam depend on?
12:43:54 <sorear> you need to import Control.Monad, (or Monad for very old Haskells)
12:44:04 <sorear> s/Monad/just Monad/
12:44:09 <ndm> fasta: probably teh darcs version
12:44:13 <ndm> fasta: if any
12:44:29 <george> ty =)
12:45:14 <fasta> What happened to cabal-get?
12:45:24 <ndm> fasta: vapourware?
12:45:43 <fasta> I thought xerox would write it for Google SOC?
12:45:44 <ndm> fasta: actually i think there was half an implementation, a lot of this stuff depends on teh hackage framework, which isn't finished
12:45:44 <DebolazX> vaporware++
12:46:12 <lightstep> what is hackage?
12:46:42 <sorear> vaporware...
12:46:44 <fasta> Compiling Haskell software makes me think my machine is slow...
12:46:54 <sorear> http://hackage.haskell.org
12:46:56 <lambdabot> Title: haskell.haskell.org
12:47:04 <ndm> fasta: blame Cabal, before Cabal haxml compiled 8 times faster...
12:47:26 <yaxu> shapr: interesting, i didn't think about coal burning power stations giving off radiation before
12:47:41 <fasta> ndm: are you implying that the output as generated by GHC is going through another Haskell program?
12:48:18 <ndm> fasta: no, but with Cabal each .exe has a separate copy of eahc .obj, before they all shared the same .obj's, which sped it up loads
12:48:30 <sorear> it's a database of Haskell programs and libraries.  Amazingly, it has lambdabot but not hscurses...
12:48:52 <LoganCapaldo> ?pl let myliftM f x = x >>= (\v -> return $ f v)  in myliftM
12:48:52 <sorear> haxml has executables?
12:48:53 <lambdabot> fmap
12:48:56 <fasta> sorear: yes
12:48:57 <lightstep> is HackageDB online?
12:49:06 <LoganCapaldo> Is there a difference between fmap and liftM?
12:49:17 <sorear> yes.
12:49:26 <sorear> Each is more general than the other.
12:49:27 <fasta> sorear: for generating Haskell modules from some XML specification
12:49:50 <sorear> fmap works on every Functor, liftM works on every Monad.
12:50:01 <LoganCapaldo> ?type let myliftM f x = x >>= (\v -> return $ f v)  in myliftM
12:50:03 <lambdabot> forall a a1 (m :: * -> *). (Monad m) => (a -> a1) -> m a -> m a1
12:50:08 <LoganCapaldo> ?type liftM
12:50:09 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
12:50:15 <LoganCapaldo> ?type fmap
12:50:17 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
12:50:18 <sorear> Any category theorist will tell you that every Monad is a Functor, but try telling that to the Haskell Committee.
12:50:23 <LoganCapaldo> Is that a bug in pl?
12:51:14 <sorear> If the cat. theorists had their way, fmap would be strictly more general than liftM, and the ?pl rule would be correct.
12:51:39 <LoganCapaldo> Ok
12:51:54 <sorear> However, the Haskell committee didn't listen to the theorists (ask Cale, he seems to know) and fmap doesn't always replace liftM.
12:51:54 <LoganCapaldo> Thats a good enough  answer for me for now :)
12:52:05 <pejo> l
12:52:30 <Cale> There was a good reason to separate them
12:52:41 <Cale> though it's not a very good reason
12:53:07 <lightstep> what was it? making Monad small?
12:53:49 <Cale> Because the Monad class is defined using return and bind, rather than return and join, you actually get liftM for free from any instance. Not including that subclass constraint means that people can be lazy and neglect to define instances of Functor.
12:54:11 <Cale> (but liftM provides the functionality that fmap would have)
12:55:02 <Cale> I think I might keep liftM around even if it were a subclass, since it makes the instance of Functor that much easier to write.
12:55:46 <Cale> Might be good to name it something like defaultMap though.
12:56:04 <fasta> HaXml is still compiling... GHC looks like gcc (twice as slow every release) ;)
12:56:07 <Cale> Better yet would be to provide a way for instances of subclasses to provide default instances of superclasses.
12:56:59 <ndm> fasta: wait til Yhc is useable, much much faster :)
12:57:30 <LoganCapaldo> There's a generic definition of join?
12:57:40 <LoganCapaldo> ?type join
12:57:42 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
12:57:45 <sorear> join x = x >>= id
12:57:52 <LoganCapaldo> ah
12:58:07 <LoganCapaldo> nope still confused
12:58:15 <sorear> fasta: look at Jhc. "Use -v, because the compiler frequently feigns nontermination"
12:58:22 <LoganCapaldo> I though id was id x = x
12:58:33 <LoganCapaldo> How does that type check?
12:58:37 <LoganCapaldo> oooooo
12:58:37 <sorear> join x = do { y <- x ; x }
12:58:39 <LoganCapaldo> lol
12:58:43 <sorear> join x = do { y <- x ; y }
12:59:01 <sorear> my join there was actually join (>>) :(
12:59:22 <LoganCapaldo> I feel dumb sometimes :)
12:59:39 <Cale> or, join x = do { y <- x; v <- y; return v }
12:59:44 <Cale> if that helps :)
12:59:50 <LoganCapaldo> but the "clicking" is like a huge rush
13:00:00 <Cale> > join (*) 5
13:00:02 <lambdabot>  25
13:00:13 <LoganCapaldo> I actually got it before the do notation examples, jsut didn't think hard enough :)
13:00:16 <Cale> It has a nice effect in the ((->) e) monad
13:00:32 <LoganCapaldo> Mmmm
13:00:37 <sorear> > join (^) 5
13:00:37 <Cale> It ties the two parameters of a 2-parameter function together.
13:00:39 <lambdabot>  3125
13:00:50 <LoganCapaldo> and this is why @pl spits out join (,) for (x, y)
13:00:53 <Cale> right
13:00:59 <Cale> \x -> (x,x)
13:01:03 <Cale> @pl \x -> (x,x)
13:01:04 <lambdabot> join (,)
13:01:09 <LoganCapaldo> yeah
13:01:13 <LoganCapaldo> (x,x) sorry
13:01:15 <Cale> another handy one is ap
13:01:24 <Cale> In the ((->) e) monad,
13:01:30 <kpreid> > let m >>== x = join $ fmap m x in [1,2,3] >>== replicate 2
13:01:31 <lambdabot>  Couldn't match `a -> f a1' against `[a2]'
13:01:33 <Cale> ap f g x = f x (g x)
13:01:38 <fasta> ndm: GP is a Forth like language?
13:01:46 <kpreid> > let m >>== f = join $ fmap f m in [1,2,3] >>== replicate 2
13:01:46 <Cale> So you can do:
13:01:47 <lambdabot>  [1,1,2,2,3,3]
13:01:56 <Cale> > ap (,) (*2) 5
13:01:57 <lambdabot>  (5,10)
13:02:07 <ndm> fasta: nothing like, i'd have said
13:02:08 <Cale> > map (ap (,) (^2)) [1..10]
13:02:10 <lambdabot>  [(1,1),(2,4),(3,9),(4,16),(5,25),(6,36),(7,49),(8,64),(9,81),(10,100)]
13:02:22 <ndm> fasta: although the implemlementation borrows from it
13:02:25 <LoganCapaldo> ((->) e) is the Monad of one argument functions whose return type is the same as the argument type?
13:02:25 <Cale> or, taking things to the ridiculous extreme
13:02:30 <sorear> my favorite:
13:02:33 <Cale> > map (ap (,) (join (*))) [1..10]
13:02:34 <lambdabot>  [(1,1),(2,4),(3,9),(4,16),(5,25),(6,36),(7,49),(8,64),(9,81),(10,100)]
13:02:41 <sorear> > ap(++)show"> ap(++)show"
13:02:42 <lambdabot>  "> ap(++)show\"> ap(++)show\""
13:02:51 <LoganCapaldo> lol
13:02:53 <LoganCapaldo> quine
13:02:55 <fasta> ndm: ok, then I was probably looking at the generated code. I didn't see a definition for the INIT rule then.
13:02:59 <Cale> LoganCapaldo: The monad of functions from the type e
13:03:14 <Cale> ((->) e) a = (e -> a)
13:03:18 <ndm> fasta: ah yes, the bytecode is forth-like, in that it has a stack
13:03:21 <LoganCapaldo> gotcha
13:03:57 <Cale> Computations in that monad can be thought of as "reading from an environment of type e"
13:03:59 <sorear> most bytecode langs use stacks.
13:04:19 <sorear> infact (->) a used to be called the Reader monad
13:04:33 <Cale> > (do { x <- (*10); y <- (*100); return (x+y) }) 5
13:04:35 <lambdabot>  550
13:04:38 <Cale> > (do { x <- (*10); y <- (*100); return (x+y) }) 6
13:04:39 <sorear> then someone figured out that a newtype would give better error messages.
13:04:40 <lambdabot>  660
13:05:15 <Cale> Well, the newtype is more useful in bigger cases, but it's heavier. Both instances have their place :)
13:05:18 <kpreid> It bothers me sometimes that Reader and Writer are not as similar as they could be.
13:05:33 <Cale> How would you make them more similar?
13:05:34 <kpreid> that is, that the name Reader was applied to something unlike Writer
13:06:07 <Cale> hm?
13:06:19 <kpreid> given Writer I'd expect Reader to have an operation which takes an element of input from a stream
13:06:29 <LoganCapaldo> Those examples are nuts
13:06:40 <Cale> oh
13:06:54 <kpreid> i.e. gets head; modify tail
13:07:04 <Cale> right
13:07:11 <Cale> I have a monad like that on the wiki
13:07:16 <kpreid> MonadRandom, I know
13:07:19 <Cale> MonadSupply
13:07:36 <kpreid> er, right
13:07:44 <LoganCapaldo> Especially since I've thought about defining + for functions so that f x = ..., g x = ..., (f + g) x = (f x) + (g x)
13:07:48 <kpreid> is there such a thing as a comonoid, and would it be relevant?
13:07:48 <Cale> http://haskell.org/haskellwiki/NewMonads/MonadSupply
13:07:50 <lambdabot> Title: New monads/MonadSupply - HaskellWiki
13:08:08 <sorear> I find it interesting that all three of the basic categorical operations give rise to monads.
13:08:12 <LoganCapaldo> and you just did it
13:08:22 <LoganCapaldo> but all in Haskell
13:08:24 <Cale> kpreid: There's a general notion of a comonoid object in a category, but there's no algebraic structure called a comonoid.
13:08:39 <sorear> sums beget Error, products beget Writer, exponentials beget Reader
13:09:51 <sorear> In comonads, products beget reader, exponentials beget streams, and sums beget nothing at all (since given Either s x, you can't have coreturn :: Either a b -> b)
13:09:52 <Cale> LoganCapaldo: it gets nicer when you go ahead and use liftM2
13:10:01 <Cale> > liftM2 (+) (*10) (*100) 5
13:10:03 <lambdabot>  550
13:10:15 <kpreid> Cale: is there something which would be to Supply as Monoid is to Writer?
13:10:18 <sorear> If my overloaded apposition could be made sane...
13:10:37 <Cale> kpreid: hmm
13:10:40 <sorear> Splittable?
13:10:40 <LoganCapaldo> ?type liftM2
13:10:43 <lambdabot> forall r (m :: * -> *) a2 a1. (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
13:10:54 <LoganCapaldo> Oh
13:10:55 <sorear> ?type GHC.Prim.split
13:10:56 <lambdabot> Not in scope: `GHC.Prim.split'
13:10:59 <Cale> yeah, it'd be a splittable sort of thing
13:10:59 <sorear> ?type GHC.Exts.split
13:11:01 <kpreid> sorear: maybe. not symmetric though
13:11:01 <lambdabot> forall t. (GHC.Exts.Splittable t) => t -> (t, t)
13:11:19 <LoganCapaldo> heh, this is crazy
13:11:20 <kpreid> lists aren't splittable in the general way implied by that type
13:11:23 <sorear> Writer often uses lists because lists are free monoids.
13:11:27 <Cale> actually, any type with a map to lists would do it :)
13:11:47 <kpreid> ah. e.g. randoms
13:11:49 <sorear> Supply needs something that can have it's first elem extracted
13:12:13 <sorear> class Extractable a x where extract :: a -> (x, a)
13:12:24 <Cale> | a -> x
13:12:39 <kpreid> and Writer *could* be defined to always produce a list, which you might mconcat afterward
13:12:41 <sorear> of course if our Supply is a monad-zero then supply could fail...
13:12:42 <kpreid> @type mconcat
13:12:44 <lambdabot> Not in scope: `mconcat'
13:12:51 <kpreid> @type Data.Monoid.mconcat
13:12:52 <lambdabot> forall a. (Data.Monoid.Monoid a) => [a] -> a
13:13:25 <kpreid> rather, Monoid b => (a -> b) -> [a] -> b
13:13:31 <kpreid> mconcatMap
13:13:32 <sorear> kpried : lists are very inefficient for some things, esp. left associative loops
13:13:38 <kpreid> sorear: exactly
13:13:42 <sorear> kpried: fold
13:13:47 <kpreid> I said *could*, not that it'd be efficient
13:13:53 <kpreid> er...so it is
13:13:56 <sorear> ?type Data.Foldable.foldMap
13:13:58 <lambdabot> Couldn't find qualified module.
13:13:58 <kpreid> @type foldr mplus
13:14:00 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> [m a] -> m a
13:14:09 <kpreid> @type foldr Data.Monoid.msum
13:14:11 <lambdabot> Not in scope: `Data.Monoid.msum'
13:14:16 <kpreid> @type foldr Data.Monoid.mappend
13:14:18 <lambdabot> forall b. (Data.Monoid.Monoid b) => b -> [b] -> b
13:14:29 <kpreid> no...
13:14:40 * kpreid stops
13:15:00 <LoganCapaldo> msum would be what? "foldr" mplus ?
13:15:06 <sorear> well, it's not in the Lambdabot libs, but my stdlibs have Data.Foldable.foldMap :: (Foldable a, Monoid b) => (c -> b) -> a c -> b
13:15:30 <kpreid> LoganCapaldo: foldr mplus mzero
13:15:50 <kpreid> mconcat = foldr mappend mempty
13:16:14 <LoganCapaldo> but with mfoldr or something like that right?
13:16:24 <kpreid> no
13:16:39 <sorear> We need to have class (Monad m, Monoid m) => MonadPlus m where {-Empty-}, all it provides is distributivity laws
13:16:41 <kpreid> msum is to mplus as sum is to (+)
13:16:52 * LoganCapaldo falls off the cliff of understanding again
13:17:07 <kpreid> LoganCapaldo: they're just the 'N-ary' versions of the binary functions
13:17:08 <LoganCapaldo> so msum only works with (Monad m) => [m a]
13:17:26 <sorear> s/Monad/\&Plus/
13:17:27 <kpreid> @type ((+), sum)
13:17:28 <lambdabot> forall a a1. (Num a, Num a1) => (a -> a -> a, [a1] -> a1)
13:17:36 <kpreid> @type (mplus, msum)
13:17:38 <lambdabot> forall (m :: * -> *) a (m1 :: * -> *) a1. (MonadPlus m, MonadPlus m1) => (m a -> m a -> m a, [m1 a1] -> m1 a1)
13:18:02 <kpreid> @type (Data.Monoid.mappend, Data.Monoid.mconcat)
13:18:03 * LoganCapaldo agrees with sorear's regexp
13:18:04 <lambdabot> forall a a1. (Data.Monoid.Monoid a, Data.Monoid.Monoid a1) => (a -> a -> a, [a1] -> a1)
13:18:04 <LoganCapaldo> oops
13:19:24 <LoganCapaldo> I need to stop hanging out in here, and maybe write a program in Haskell and pretend I don't give a beep for Monads or anything else weird ;)
13:19:58 <LoganCapaldo> else all I'll ever be able to do is come up with weird pointless abstract Monads ;)
13:20:04 <Saizan> i should find a category theory course next semester :D
13:20:06 <sorear> Monads aren't weird! They are ... they are ... they are ... ...
13:20:19 <dylan> they are nothing! :)
13:24:19 <LoganCapaldo> Monads are weird. return 1 `mplus` return 2 `mplus` return 3 might be [1,2,3] or it might be Just 1 or it might be something I've never heard of
13:24:25 <LoganCapaldo> that's _weird_
13:25:05 <Philippa> no, that's just overloading
13:25:08 <opqdonut> :D
13:25:12 <Philippa> I mean, C++ does that kind of weirdness
13:25:20 <Philippa> totally first-order ;-)
13:25:25 <sorear> it could be ReaderT (const $ Right 1)
13:26:40 <LoganCapaldo> Philippa: lemme restate. It could be anyone of those things and I'll still know that certain rules apply. (which I can't know from C++). And that is weird
13:27:37 <dfranke> I've just written this type declaration:
13:27:40 <dfranke> newtype (Num e) => SquareMatrix e = SquareMatrix ((Array (Int,Int) e),Int)
13:27:44 <sorear> so, you're saying haskell is weirder because you know *more* about it?  I see our job is done. :)
13:28:01 <dfranke> I'm trying to make SquareMatrix an instance of IArray.
13:28:03 <wolverian> sorear++
13:28:15 <dfranke> But IArray has kind (* -> * -> *) and SquareMatrix has kind (* -> *).
13:28:44 <dons> moin
13:28:44 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
13:28:46 <sorear> an IArray must be polymorphic in the type of indices :(
13:29:09 <sorear> constructor classes *are* harmful; if only there was a decent replacement.
13:29:40 <sorear> (can you define Monads using first-kinded MPTC's? fundeps? ATs?)
13:31:01 <dfranke> I'll see if I can make this work then:
13:31:02 <dfranke> newtype (Ix e, Num e) => SquareMatrix i e = SquareMatrix ((Array (i,i) e),i)
13:31:21 <sorear> Ix e?
13:31:33 <sorear> what if you want a matrix of functions?
13:31:53 <dfranke> oops
13:31:56 <dfranke> Ix i
13:36:01 <svref> can someone help me understand the difference between the types "IO [String]" and "[IO String]"?
13:36:29 <kpreid> in the first, you can't know the length of the list until you run it
13:36:41 <kpreid> in the second, you do, and you can run the pieces separately
13:37:10 <allbery_b> hm.  somehow I was expecting an exception when I (deliberately) fed 2006-12-32 to toClockTime
13:37:11 <svref> kpreid: so in a sense [IO String] is better?
13:37:19 <fasta> ndm:
13:37:20 <kpreid> svref: you can do more with it
13:37:36 <kpreid> @type sequence
13:37:37 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
13:37:48 <kpreid> sequence :: [IO String] -> IO [String]
13:38:01 <svref> @type mapM
13:38:03 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
13:38:38 * svref strokes beard, lost in thought
13:38:53 <kpreid> svref: note that you *can't have* an [IO String] if IO is necessary to compute the length of the list
13:38:59 <dons> sorear: re. hs-plugins and laziness: data you want to persist should be strict (i.e. !F -style fields, or forced before the state resync)
13:38:59 * wolverian strokes svref's beard, lost in pleasure
13:39:09 <dons> otherwise it'll just eval the old code later (which is ok, I suppose)
13:39:35 <sorear> so.. unload *doesn't* free memory?
13:40:18 <svref> I'm still learning Haskell "the hard way".  My current thinking is that I want all the IO actions as near the root of the call-graph as possible
13:40:49 <kpreid> svref: that's a decent principle
13:41:33 <svref> from that I thought IO [String] would be "better" than [IO String]...not sure why.
13:41:55 <kpreid> well, it's less complex IO
13:42:02 <opqdonut> svref: well, they're totally different concepts
13:42:19 <opqdonut> so i wouldn't say one is better, although IO [String] is somewhat of a simpler case
13:42:29 <pzpz> hey -- i'm playing with typeclasses, and i'd like to also add an Ord instance for my Card datatype that uses the Value and ignores the Suit, but i'm not sure how :)
13:43:17 <svref> IO [String] seems to play nicer with "do x <- (e::IO [String])"
13:43:34 <svref> I'm not sure how to take apart [IO String]...
13:43:46 <LoganCapaldo> pzpz: I think you just need to define < and == in terms of the Suit
13:43:51 <LoganCapaldo> err Value rather
13:43:53 <dons> ?uptime
13:43:54 <lambdabot> uptime: 2d 21h 3m 22s, longest uptime: 9d 2h 23m 6s
13:43:57 <dons> ?users
13:43:57 <lambdabot> Maximum users seen in #haskell: 309, currently: 260 (84.1%), active: 33 (12.7%)
13:43:59 <opqdonut> svref: sequence
13:44:05 <opqdonut> :t sequence
13:44:07 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
13:44:26 <kpreid> svref: do x <- sequence e; ...
13:44:28 <pzpz> LoganCapaldo: well, yah -- I easily derived (show, Ord, Eq) for my Value type
13:44:28 <opqdonut> svref: that will do [IO String] -> IO [String] for you
13:44:41 <yaxu> > sqrt 3 :: Int
13:44:43 <lambdabot>  add an instance declaration for (Floating Int)
13:44:43 <lambdabot>   In the expression: sqrt ...
13:44:43 <svref> opqdonut: allright, what about (IO a,IO b)?
13:44:44 <LoganCapaldo> (Card _ v) < (Card _ v') = v < v'
13:44:52 <kpreid> svref: in the case that either makes sense, IO [String] is more likely to be what you want
13:44:58 <opqdonut> svref: hmm, that one aint so simple
13:45:05 <pzpz> LoganCapaldo: However, a card is composed of a Suit and a Value, and I only want to derive Eq for Suit
13:45:22 <pzpz> ah
13:45:24 <kpreid> svref: you probably want to rewrite the code that produced it to do 'return (..., ...)'
13:45:34 <pzpz> i see.
13:45:52 <svref> kpreid: expanding the IO pollution, so to speak
13:45:53 <pzpz> how would I add that instance:    instance Ord a => Card a where ... ?
13:46:02 <kpreid> svref: er, no?
13:46:15 <kpreid> svref: I mean the thing which was already polluted
13:46:35 <kpreid> it's really hard to suggest what to do without seeing the code...
13:47:37 <kpreid> sequencePair (a,b) = liftM2 (,) a b
13:47:41 <svref> kpreid: well if you agree that IO [String] is "more polluted" than [IO String], wouldn't you also agree that IO (a,b) is more polluted than (IO a,IO b)?  Or are they just "different polluted"?  :)
13:47:53 <kpreid> svref: no, the opposite
13:48:32 <kpreid> do what makes it easy to write the program you want
13:48:39 <kpreid> svref: but really, thinking in those terms isn't all that useful
13:50:14 <george> inside a do, i want to have a short statement if (z == []) then return []
13:50:17 <george> how can i do this?
13:50:33 <george> i know one way with case
13:50:35 <yaxu> > sqrt $ length [0 .. 8]
13:50:36 <lambdabot>  add an instance declaration for (Floating Int)
13:50:43 <yaxu> > sqrt $ fromInteger $ length [0 .. 8]
13:50:44 <lambdabot>  Couldn't match `Integer' against `Int'
13:50:50 <george> but it will be the third nest of a 'case' and i would prefer not
13:50:53 <kpreid> george: what are you doing in the alternative?
13:50:59 <sorear> how do you compile GHC 6.4.2 using GHC 6.6 ?  my system is too new to run the 6.4.2 binary package...
13:51:06 <george> kpreid: in the alternative carrying on a list of other stuff
13:51:12 <george> including case's
13:51:23 <george> and a let statement
13:51:30 <svref> kpreid: I have this type alias something like: [(Int,String,[[(Int,String)]])], and when I'm constructing it the "natural" type of the constructor is [(Int,String,[[IO (Int,String)]])], and I'm trying to figure out if I should rewrite the loader to return type IO [(Int,String,[[(Int,String)]])]
13:51:42 <kpreid> george: if it was actions on z, then perhaps flip mapM z ... is what you want
13:51:43 <sorear> (I've compiled HEAD using 6.6 so I know the process, but 6.6 gives syntax errors on constructs in the 6.4.2 code)
13:52:00 <kpreid> svref: yes
13:52:15 <george> kpreid its actions on ALOT of things
13:52:22 <yaxu> ok how do I get the output of length into a suitable form that sqrt can give me an answer?
13:52:37 <kpreid> yaxu: fromIntegral
13:52:44 <pzpz> ah, figured it out!
13:52:47 <george> i mean, i was considering calling a case z of and then 2 case [] and _
13:52:58 <pejo> sorear, I don't think they support compiling old versions of ghc with recent ones.
13:53:01 <svref> > sqrt $ fromIntegral $ length [1..10]
13:53:02 <lambdabot>  3.1622776601683795
13:53:15 <george> i just wondered if there was a way of shoving in a quick conditional that returns out of the function
13:53:27 <yaxu> kpreid: thanks!
13:53:34 <kpreid> george: no. what would define where it returns to?
13:53:46 <george> well
13:53:50 <pejo> sorear, and how can your system be too new to run an old version?
13:54:00 <george> return [] sends a [] back to the calling function
13:54:05 <kpreid> no, it doesn't
13:54:16 <george> why not?
13:54:25 <kpreid> return [] is an action that returns []
13:54:30 <svref> return [] taints the empty list with IO-ness.
13:54:36 <kpreid> it has no effect on the block it's in
13:54:42 <george> yeah its an IO list
13:54:54 <Philippa> "taints" is inaccurate
13:54:55 <syntaxfree> if you need "break", you're probably doing it *too* imperatively.
13:55:00 <dons> ?time
13:55:02 <Philippa> it allows you to use it from IO
13:55:03 <kpreid> > flip runState () $ do return []; return "hi"
13:55:04 <dons> ?time dons
13:55:05 <lambdabot>  ("hi",())
13:55:08 <lambdabot> Local time for dons is Mon Dec 25 08:50:27 2006
13:55:10 <dons> time to open presents!
13:55:13 <kpreid> see, it returned hi
13:55:17 * dons goes to find coffee
13:55:19 <kpreid> because return doesn't *stop*
13:55:23 <Philippa> if you think about tainting all the time you'll just end up with a filthy mind
13:55:25 <kpreid> it just gives a value
13:55:27 <sorear> pejo: I don't have a readline.so.4
13:55:31 <kpreid> > flip runState () $ do fail []; fail "hi"
13:55:33 <lambdabot>  Add a type signature
13:55:39 <svref> Philippa: You know me well, stranger.  :)
13:55:41 <kpreid> fail, on the other hand, would
13:55:46 <allbery_b> just hope your presents aren't IO [Present] :)
13:55:53 <george> return doesnt stop the rest of the function from continuing?
13:55:59 <kpreid> george: right.
13:56:05 <Philippa> allbery_b: I dunno, I was kinda hoping for something like that from one of my partners ;-)
13:56:12 <kpreid> george: Haskell *never* works in terms of "the current function"
13:56:16 * sorear tries hexediting the binary
13:56:23 <svref> Philippa: how do you think of it?  "transports to another plane of existance, where life sucks and you have to use 'do' all the time"?
13:56:27 <george> ok
13:56:49 <Philippa> "turns the value into a computation". And you don't have to use do, >>= works fine and so do combinators
13:56:49 <george> I want it like if z = [] then finish function. otherwise continue
13:57:21 <sorear> ?where fps
13:57:22 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
13:57:26 <Philippa> does the function return anything other than ()?
13:57:40 <pejo> sorear, isn't that just for ghci?
13:57:46 <Philippa> case z of {[] -> return (); _ -> continue}
13:57:52 <svref> Philippa: so you know the difference between a "combinator" and a "function"?!! Great!  Tell me!
13:57:56 <sorear> suprisingly enough, editing the binary didn't make it crash
13:58:02 <george> yeah, i was looking for a way to do it without case =)
13:58:08 <george> this was my original question
13:58:18 <sorear> (lambdabot depends on Data.ByteString, I want to make sure I haven't broken the 6.4 build)
13:58:34 <Philippa> svref: lack of free variables, blah blah. Though you might not define actually /as/ a combinator, and usually constructors don't count as free variables
13:59:01 <svref> :t actually
13:59:02 <lambdabot> Not in scope: `actually'
13:59:53 <syntaxfree> george: do notation is not imperative programming.
13:59:59 <syntaxfree> It's just convenient, misleading syntactic sugar.
14:00:21 <Philippa> which might be for something that's... well, suspiciously imperative in nature, only also purely functional
14:00:49 <svref> bye
14:01:10 <george> syntaxfree, im a little lost by what you mean
14:02:27 <syntaxfree> do notation doesn't mean what it seems it means.
14:02:46 <syntaxfree> george: um, do you know about monads?
14:03:17 <george> syntaxfree, i know of them, i would say my knowledge is at the level i would not like to teach it to someone else
14:03:37 <Philippa> a monad describes something a lot like a new programming language
14:03:38 <syntaxfree> anyway, if you have a faint idea of monads but don't really grok how it relates to do notation, this is my personal stance on the problem you're facing:
14:03:38 <syntaxfree> http://syntaxfree.wordpress.com/2006/12/12/do-notation-considered-harmful/
14:03:41 <lambdabot> Title: Do-notation considered harmful ¬´ Data.Syntaxfree, http://tinyurl.com/tlmrl
14:03:45 <Philippa> except that it happens to be haskell values too...
14:04:01 <Philippa> ...oh, and to contain haskell values lifted into it with return
14:05:41 <george> syntaxfree, ill give it a read =)
14:06:06 <Philippa> syntaxfree: not all monads are implemented or indeed implementable (entirely) in Haskell. That's kinda the point for IO
14:08:20 <syntaxfree> Philipppa: I know.
14:08:33 <syntaxfree> It's not that IO isn't implementable in Haskell as much as its platform-dependent.
14:08:52 <Philippa> no, it's not implementable in Haskell at all except in terms of itself
14:09:03 <syntaxfree> IO can mean Something Completely Different in a Macintosh and a Lisp Machine.
14:09:08 <Philippa> you can get half an implementation with the right type system extensions, but only half
14:09:36 <syntaxfree> Philippa: only in the sense it can't be implemented in any language. Cale has a good essay on the IO monad in his wiki.
14:09:38 <Philippa> (that is, you can build up values representing the computations, but you can't interpret them in such a manner as to eg print text or launch missiles)
14:09:46 <Philippa> sylvan,
14:09:49 <Philippa> er
14:09:51 <sorear> You can implement an entire IO monad in haskell, but you'll have to simulate the computer.
14:09:56 <Philippa> syntaxfree: I'm not in need of articles
14:10:01 <syntaxfree> sorear: my point precisely.
14:10:02 <Philippa> yeah, funny that
14:10:11 <Cale> hi
14:10:16 <Cale> I do?
14:10:17 <Philippa> and precisely mine, as well
14:10:19 <syntaxfree> http://haskell.org/haskellwiki/IO_inside
14:10:20 <lambdabot> Title: IO inside - HaskellWiki
14:10:25 <Cale> I have an article on the Haskell wiki
14:11:09 <Philippa> unfortunately launching virtual missiles isn't necessarily any good in a real war
14:11:34 <syntaxfree> yeah.
14:11:34 <syntaxfree> Cale: hey. Thanks for putting me down the rabbit hole of arithmetic derivatives, btw.
14:11:37 <mgsloan> doesn't the compiler just treat RealWorld as an unevaluated var?  Pretends that it can evaluate it, but in the end realizes it doesn't need it
14:11:54 <Philippa> mgsloan: it'd need it if you tried to duplicate it
14:12:00 <Philippa> well, it'd have bigger problems than that
14:12:22 <mgsloan> ah, well, you can't because its stuck in the monad :)
14:12:22 <Cale> syntaxfree: :)
14:12:36 <Philippa> syntaxfree: part of what I'm pointing out is that most other languages that take a bolthole approach like this do it by inlining or linking in chunks from another language
14:12:40 <mgsloan> yeah, that derivative stuff is cool
14:12:40 <rohar> was Haskell designed with monads in mind, or did they come after the language definition?
14:12:49 <mgsloan> i think after
14:12:53 <Philippa> they came after the original definition
14:13:07 <mgsloan> before 98 though, maybe
14:13:24 <_roconnor> IO used to be done by some horrible list processing
14:13:38 <Philippa> syntaxfree: the monad approach is really rather neat in that regard, compare and contrast with calling back to your high-level language in inline asm...
14:13:46 <roconnor> main :: [Events] -> [Actions]
14:13:50 <roconnor> or something like that
14:14:11 <opqdonut> ugh
14:14:13 <Philippa> Haskell instead chooses to effectively model the entire lower-level language in itself at the same time
14:14:19 <mgsloan> http://en.wikibooks.org/wiki/Haskell/Denotational_semantics#Bottom_and_Partial_Functions  I've changed the possible values of Integer to contain negatives as well, but it looks ugly, especially if i were to change it in the later instances
14:14:22 <lambdabot> http://tinyurl.com/yxxgb8
14:18:44 <syntaxfree> "8:03 PM  george: syntaxfree, i know of them, i would say my knowledge is at the level i would not like to teach it to someone else"
14:18:50 <syntaxfree> ah, yes. I'm not really in a level to teach either.
14:19:02 <syntaxfree> I do it anyway, out of boredom maybe.
14:19:26 <george> heh, what i meant is I have taken 2 lectures i think which discussed monads and that is all =)
14:19:54 <syntaxfree> It's surprising how smart the average Haskell hacker is, as compared to, say, Perl or Java hackers.
14:20:05 <syntaxfree> I often find myself reading their blogs and thinking "oh, I can write good blog entries as well".
14:20:11 <syntaxfree> Then comes along sigfpe and shames me ;)
14:20:34 * benja_ got a whole new perspective on monads lately by reinventing them from a different point of view
14:20:38 <syntaxfree> (their blogs = average hacker blogs)
14:20:52 <syntaxfree> comonads give an interesting perspective on monads.
14:20:57 <Philippa> benja_: new to you, or one you think's new generally?
14:21:00 <syntaxfree> Sometimes I feel comonads are a more "natural" concept.
14:21:06 <pejo> syntax, considering that java is marketed as a language for the masses, is it surprsiing if some people who do haskell are clevered?
14:21:18 <pejo> Or rather, the average Haskell user.
14:21:32 <syntaxfree> pejo: yeah, But there are these blogs from project leaders and semi-famous hackers.
14:21:32 <benja_> Philippa: new to me :)
14:21:40 <pejo> (Considering that I bet there is clustering of users around York, Nottingham, Oxford, etc).
14:21:41 <Philippa> pejo: I think the language itself and the community emphasis tends to keep people intellectually honest, too. That helps a lot
14:21:52 <syntaxfree> I'm thinking of Steve Yegge, for instance. The man was a top code architect at Amazon.
14:22:09 <Philippa> hmm. If I propose NotHUG someone's going to ask what I had in mind instead, right?
14:22:12 <syntaxfree> and in spite of that, the average Cale essay is worth about five Yegge essays.
14:22:27 <Cale> heh, thanks :)
14:22:31 <syntaxfree> in content, knowledge, surprise, depth.
14:23:08 <psnl> ooh, I need to read though all of Cale's essay's then
14:23:11 <Cale> syntaxfree: the value of the monad abstraction is in making lots of combinator libraries (implementing embdedded domain specific languages) have the same interface, so that things like control structures (think mapM) can be shared between them
14:23:37 <benja_> I noticed that they provide just what you need if you want to make a language where if you write e.g. ([7,8,9] * 2) it does the lifting to (map (*2) [7,8,9]) automatically based on types
14:23:56 <Cale> So Philippa is very much right in that monads give you a nice way to embed other languages in Haskell.
14:24:03 <syntaxfree> many matrix-oriented languages do that.
14:24:11 <syntaxfree> Matlab, Octave, S-Plus, GNU R.
14:24:50 <mgsloan> nice.  I'm thinking of having my graphical lang auto-lift functions, and provide visual annotations of this fact.
14:24:52 <pejo> Philippa, isn't that partly the same values as in academia+
14:24:53 <syntaxfree> I think Matlab even overloads (*) for inner product.
14:24:54 <syntaxfree> IIRC.
14:25:02 <syntaxfree> R uses %*%.
14:25:31 <Philippa> pejo: partly, but they're also (good) hackerdom values
14:25:52 <benja_> syntaxfree: my point was that if you want a language where you can make your own types which have this kind of auto-lifting
14:25:56 <Philippa> Haskell is very much where academia and hackerdom meet at the moment, in a way that I'm not sure's been seen in quite the same way since lisp
14:26:08 <syntaxfree> benja: sure. You just have to make numbers be one-vectors.
14:26:11 <roconnor> huh, hacerkdom?
14:26:17 <roconnor> hackerdom?
14:26:26 <syntaxfree> Then you define inner product.
14:26:32 <syntaxfree> Or better yet, matrix multiplication.
14:26:48 <benja_> then monads provide an interface which lets the language do auto-lifting for any expression in which monadic values occur
14:27:03 <benja_> (as long as they're all in the same monad, anyway =))
14:27:05 <Philippa> roconnor: "the collective culture of hackers". By which I don't mean crackers...
14:27:14 <syntaxfree> Much of numerics is expressed in matrix form because theorems come cheap from linear algebra.
14:27:32 <syntaxfree> I first approached "real" programming via Matlab, and I'd be expressing loops as chains of artificial matrix multiplication.
14:27:40 <syntaxfree> (In hope I'd get some theoretical tractability)
14:28:02 <roconnor> Philippa: no I understand what you mean by hackers, but I do they use Haskell?
14:28:19 <syntaxfree> In my statistics classes (graduate-level econometrics), the matrix approach is still pretty much mandated.
14:28:19 <pejo> roconnor, some of them do.
14:28:22 <roconnor> Due to my sample bias I only see academics using Haskell.
14:28:36 <syntaxfree> All academics I know personally use R.
14:28:37 <pejo> roconnor, who says academics can't be hackers?
14:28:43 <syntaxfree> But then all academics I know are econometricians.
14:28:48 <syntaxfree> At least the ones that use computers :)
14:29:14 <benja_> (you need to be able to lift different kinds of application: of m (a -> b) to a; of (a -> b) to m a; of (m a -> b) to a; etc.)
14:29:20 <shankys_> Are there any libraries in Haskell that manipulate normal String types and are useful other than Data.List and Text.Regex?
14:29:28 <shankys_> *String type
14:29:40 <Philippa> roconnor: I could happily count a number of people in here as hackers. I've been described as one myself, though my output's a bit on the low side
14:29:59 <roconnor> Funny, I only write fun toy things in Haskell.
14:30:05 <syntaxfree> benjo: I think you're just better off defining matrix product and doing away with singleton number values in your language.
14:30:12 <Philippa> yes. Some of my fun toys are suspiciously meta in nature...
14:30:29 <Philippa> I've written a couple of things for personal use, one of which was admittedly arguably a toy
14:30:41 <syntaxfree> shanky: the Text.* hierarchy in general?
14:30:44 <Philippa> I've written more as workhorses for hacking-related experimentation
14:30:50 <syntaxfree> There's Text.HTML and suchlike.
14:31:08 <benja_> syntaxfree: what if I want to do a non-deterministic language or a language with IO or functional reactive programming? :-)
14:31:48 <syntaxfree> Still. If I may use one expletive, matrix algebra is fucking powerful.
14:32:30 <sorear> parsers?
14:32:46 <benja_> I don't think I get your point :-/
14:32:47 <syntaxfree> sorear: Parsec is in the Text.* hieratchy somewhere.
14:32:50 <syntaxfree> Parsec is almost magical.
14:32:56 <Philippa> heh
14:33:20 <Philippa> I don't know I'd go that far - I can envisage a couple of other points in the design space that'd be more powerful for many uses
14:33:35 <Philippa> though I don't have nice ways to implement them quite yet
14:33:36 <sorear> (parsec+readp are standard)
14:33:46 <Philippa> Parsec is damn nice though once you get the hang of it
14:33:54 <roconnor> Just for the record, MonadFix is totally awsome.
14:33:56 <mgsloan> http://en.wikibooks.org/wiki/Haskell/Denotational_semantics#Partial_Functions_and_the_Semantic_Approximation_Order  This stuff on semantic approximation order seems shakey.  mainly the bit about neither of those integer relations holding.
14:33:59 <lambdabot> http://tinyurl.com/yxxgb8
14:34:03 <syntaxfree> The bad thing about parsec is the so-called User's Guide.
14:34:15 <syntaxfree> That thing is useless to the point of being vaguely misleading.
14:34:54 <syntaxfree> Using bind-notation and perusing the function guide while you begin to grok gets you quickly to speed.
14:35:05 <syntaxfree> Do-notation is surprisingly powerful for Parsec, though.
14:35:19 <Philippa> maybe it's just me, but I didn't find the use of do notation in the guide a problem
14:35:34 <Philippa> well yes. That's because there's an obvious interpretation for sequencing and it's rather relevant for parsing
14:35:53 <roconnor> I thought bind wasn't too common for parsing.  It does context senstive stuff right?
14:35:53 <syntaxfree> Philippa: maybe it's that I wasn't too sure of what I expected from a combinator parsing language.
14:36:02 <Philippa> I only really use >> or >>= in Parsec when I'm trying to keep something on one line because it's conceptually small
14:36:26 <Philippa> roconnor: it makes sense for Parsec. It allows context-sensitive stuff, and that's one of Parsec's strengths
14:36:28 <syntaxfree> Yes, yes. It's just a pointer on how to learn it. I rarely use do notation for IO, and I use it for Parsec all the time.
14:37:12 <Philippa> you're weird
14:37:17 <dfranke> type Matrix = (Num e) => (Array (Int,Int) e)
14:37:18 <Philippa> most people use do notation for most of their IO
14:37:24 <dfranke> Why can I write
14:37:28 <dfranke> instance (Num e) => Num (Array (Int,Int) e)  where
14:37:30 <dfranke> but not
14:37:31 <Cale> Wow, that's pretty odd. I pretty much always use do-notation for IO :)
14:37:35 <dfranke> instance Num Matrix where
14:37:37 <dfranke> ?
14:37:37 <Philippa> this suggests your pointers may be most useful for weird people
14:37:43 <syntaxfree> Heh.
14:37:51 <Philippa> (FWIW, there are many ways in which I'm extremely weird, most of which belong in -blah)
14:37:53 <syntaxfree> I don't think I do much IO anyway.
14:38:37 <Cale> dfranke: the (Num e) is actually part of the syntax of the instance declaration
14:38:58 <mgsloan> I use >> or >>= for IO if its not clumsy and there are about two expressions.  So basically only one of these chain ops
14:39:22 <syntaxfree> I just break down IO in more functions.
14:39:31 <syntaxfree> sometimes in the top level, sometimes just using a lot of "where".
14:40:02 <Philippa> that can be a good idea, yeah
14:40:18 <syntaxfree> I find that I have a few use cases for IO-type work.
14:40:18 <Philippa> names are important, where/let give you names
14:40:41 <syntaxfree> s/a few/few.
14:41:08 <syntaxfree> Let's say I have a program that does a few numerical computations.
14:41:08 <dfranke> Cale: yeah, I just noticed that I can't even write the type synonym without enabling -fglosgow-exts
14:41:32 <Cale> dfranke: yes, that's a really strange type synonym
14:41:45 <Cale> I'm not even completely sure what it means
14:42:18 <syntaxfree> output_results = putStrLn . unlines . map show
14:42:43 <dfranke> I'm trying to say "A Matrix is an Array indexed by (Int,Int)s whose elements are Nums)
14:42:43 <syntaxfree> then main function becomes main = output_results ["Strings can be here", so_can_be_numerical_functions]
14:43:00 <dfranke> s/\)$/"/
14:43:03 <syntaxfree> it's often just an "iterate".
14:43:18 <vomjom> are there any plans to incorporate optimistic evaluation (http://research.microsoft.com/~simonpj/papers/optimistic/icfp2003.pdf ) into ghc?
14:43:20 <lambdabot> http://tinyurl.com/sjxe7
14:43:29 <syntaxfree> then iterate_and_print = output_results . iterate
14:43:38 <pejo> vomjom, according to Ennals thesis it was too much maintainance overhead.
14:44:09 <sorear> uh, syntaxfree, Haskell lists cannot be heterogenous
14:44:23 <syntaxfree> sorear: um, true.
14:44:28 <vomjom> pejo, only in code size in memory, i thought...?
14:44:31 <syntaxfree> I should add "concat" ;)
14:44:36 <dfranke> Also, irritatingly, it seems I can't create new instances of IArray.  GHC defines two required methods that aren't in the docs.
14:44:49 <syntaxfree> It's funny that I never used strings and never ran into that. Maybe because I just do stuff for my own use.
14:45:01 <sorear> main = foldr ($) "" [shows "String", shows 23, shows True]
14:45:24 <sorear> dfranke: look at Data.Array.Base
14:45:48 <sorear> it's marked as @hide, so the docs aren't generated, but the module exists
14:46:02 <syntaxfree> anyway, xmas dinner.
14:46:04 <vomjom> pejo, ah, nevermind, found the part you're referring to
14:46:11 <syntaxfree> Merry Festivus everyone.
14:47:02 <psnl> same to you
14:47:34 * syntaxfree screamed at a few people today and was happier. Maybe the Airing of Grievances should be an actual tradition.
14:48:18 <psnl> heh, my family is about to start screaming at each other over the dinner table
15:02:56 <emu> mgsloan: that whole wikibook seems shakey. i need to find some time to go over it.
15:14:33 <yaxu> my perl programming improves the more beer i drink, with haskell it's the opposite
15:15:06 <yaxu> my perl programming gets worse the more haskell i drink
15:16:00 <mr_tenor> yeah, i can still write bits of haskell when hungover...the type system and functional style are sorta like handrails you can lean on :)
15:17:30 <Philippa> yaxu: but can you code in beer?
15:18:37 <metaperl> the best beginner tutorial with practical examples of monads is the nomaware one still, no?
15:19:38 <mgsloan> emu - yeah, its true
15:20:10 <mgsloan> who would have guessed that haskell is a non-strict language, heh
15:21:29 <mgsloan> I suppose as far as evaluation sequence goes... I guess that's what this is referring too.
15:24:32 <sorear> non-strict ---> const 5 _|_ = 5
15:24:32 <araujo> mgsloan, it's kind of reasonable
15:24:58 <araujo> Haskell is a purely functional lang.
15:26:18 <araujo> Merry Xmas!
15:26:32 <araujo> And a Functional New Year!
15:27:40 <metaperl> A Haskelling we go! A Haskelling we go! Hi-Ho Monadics I/O, a Haskelling we go!
15:28:31 <emu> non-strict is the term for normal-order and call-by-name evaluation (and related)
15:38:49 <mgsloan> ah, well, I'm reading about it in respect to bottom
15:41:57 <mgsloan> ohh, i get it
15:42:19 <mgsloan> when there is an _ the expression doesn't need to be evaluated, and thus may be non-terminating, _|_
15:42:30 <emu> it's a possibility
15:43:34 <mgsloan> s/expression/parameter
15:43:41 <emu> the bit about semantic approximation order is relevant to that
15:43:50 <emu> reminds me a bit of a talk i saw a few weeks ago
15:50:09 <mgsloan> whoah whoah.  that semantic approximation order stuff says that every concrete value is more defined than _|_, then goes on to define that funky operator, but then uses it in the wrong way, or defines it in the wrong way
15:51:15 <emu> yea i think that paragraph is unclear
15:51:42 <mgsloan> I'm going to guess that it just defines the operator incorrectly
15:53:28 <emu> he's not saying that 1 \lessdefeq 2 is false, that would imply 2 \lessdefeq 1.  it's simply not specified, hence, partial
15:54:11 <mgsloan> I'd think they'd both be true
15:55:33 <emu> it's not, however, and this is used later on
15:55:57 <Cale> hm?
15:56:06 <Cale> with the eq there, it is
15:56:11 <mgsloan> yeah
15:56:12 <Cale> er
15:56:12 <emu> we're discussing http://en.wikibooks.org/wiki/Haskell/Denotational_semantics
15:56:46 <Cale> oh, \lessdefeq is the union of \lessdef with =
15:57:01 <mgsloan> ohhh
15:57:40 <Cale> It's not "less or equally defined as"
15:57:45 <mgsloan> Here, a \lessdef b denotes that a is more defined than b. Likewise, a \lessdefeq b will denotes that either a is more defined than b or both are equally defined.
15:57:51 <mgsloan> That's just flat wrong, right?
15:57:53 <Cale> oh
15:58:02 <Cale> pick one and stick with it :)
15:58:10 <mgsloan> because it uses it the other way around
15:58:16 <Cale> If it means that, then 1 \lessdefeq 2
15:58:23 <Cale> (and 2 \lessdefeq 1)
15:58:47 <mgsloan> well, actually I edited that a few hours ago.  I think it was right before
15:58:57 <mgsloan> but i didn't switch the params around
15:59:15 <mgsloan> a \lessdef b should mean (and is used like this) a is less defined than b
15:59:45 <mgsloan> hmm, a darcs wiki would be cool.  just delete my patch...
16:00:02 <mgsloan> well, unapply it or whatever.  I'm not well versed in darcs yet
16:03:16 <emu> my understanding is that 1 and 2 are not related by \lessdefeq
16:03:28 <emu> and this is used in the later proof that succ _|_ = _|_
16:07:15 <emu> or \sqsubseteq, which i finally looked up =)
16:19:55 <pzpz> is there a way to enumerate all of a specific type deriving Enum other than doing [a..b] where a,b are the first/last elements defined?
16:20:20 <ndm> [minBound..maxBound]
16:20:26 <ndm> > [minBound..maxBound] :: [Bool]
16:20:28 <lambdabot>  [False,True]
16:20:31 <ndm> > [minBound..maxBound] :: [Char]
16:20:32 <lambdabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\SY...
16:21:28 <ndm> pzpz: minBound/maxBound give you that easily
16:21:53 <pzpz> heh, require me to define a Bounded instange :)
16:22:03 <pzpz> s/insatge/instance
16:22:24 <sorear> ?let allObs = [minBound..]
16:22:24 <lambdabot> Ambiguous type variable `a' in the constraints
16:22:44 <sorear> ?let allObs :: (Enum a, Bounded a) => a ; allObs = [minBound..]
16:22:44 <lambdabot> Couldn't match the rigid variable `a' against `[a1]'
16:23:09 <sorear> ?let allObs :: (Enum a, Bounded a) => [a] ; allObs = [minBound..maxBound]
16:23:10 <lambdabot> Defined.
16:23:17 <sorear> > L.allObs :: [Char]
16:23:19 <lambdabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\SY...
16:23:21 <sorear> > L.allObs :: [Int]
16:23:23 <lambdabot>  [-2147483648,-2147483647,-2147483646,-2147483645,-2147483644,-2147483643,-21...
16:23:32 <sorear> > L.allObs :: [Double]  -- wart?
16:23:33 <lambdabot>  add an instance declaration for (Bounded Double)
16:23:33 <lambdabot>   In the expression: L.a...
16:23:46 <sorear> ah, good (they do have an Enum, however)
16:24:40 <Cale> > map (foldr (-) 0 . enumFromTo 1) [1..]
16:24:40 <ndm> @instance Enum Double
16:24:41 <lambdabot> Maybe you meant: instances instances-importing
16:24:42 <lambdabot>  [1,-1,2,-2,3,-3,4,-4,5,-5,6,-6,7,-7,8,-8,9,-9,10,-10,11,-11,12,-12,13,-13,14...
16:24:49 <ndm> @instances Enum
16:24:50 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
16:24:58 <sorear> Now, if only Lambdabot would let me define classes, I could create a class Finite and populate it with ...
16:25:05 <Cale> > map (foldr (-) 0 . enumFromTo 1) [0..]
16:25:07 <lambdabot>  [0,1,-1,2,-2,3,-3,4,-4,5,-5,6,-6,7,-7,8,-8,9,-9,10,-10,11,-11,12,-12,13,-13,...
16:25:23 <Cale> What a gloriously inefficient way to produce that list :)
16:26:02 <sorear> Now, if you'd used foldl and memoization it'd be pretty fast...
16:26:15 <Cale> only it wouldn't be the same :)
16:26:22 <Cale> > map (foldl (-) 0 . enumFromTo 1) [0..]
16:26:24 <lambdabot>  [0,-1,-3,-6,-10,-15,-21,-28,-36,-45,-55,-66,-78,-91,-105,-120,-136,-153,-171...
16:26:57 <sorear> class Eq a => Countable a where counting :: [a] ; toCount :: a -> Integer ; fromCount :: Integer -> a ; toCount a = head (elemIndex a counting) ; fromCount = (counting!!)
16:27:13 <sorear> class Countable a => Finite a where last :: Integer
16:27:19 <Cale> > 0 : ([1..] >>= \x -> [x,-x])
16:27:21 <lambdabot>  [0,1,-1,2,-2,3,-3,4,-4,5,-5,6,-6,7,-7,8,-8,9,-9,10,-10,11,-11,12,-12,13,-13,...
16:27:58 <sorear> oh, that Countable class is bogus...
16:28:06 <sorear> class Countable a => Finite a where lastOb :: a
16:29:09 <sorear> instance (Finite a, Finite b) => Finite (a,b) where lastOb = (lastOb,lastOb) ; counting = map (\x -> map ((,) x) counting) counting
16:29:31 <sorear> pretend there's a diagonalize there :)
16:36:07 <sorear> ?users
16:36:08 <lambdabot> Maximum users seen in #haskell: 309, currently: 257 (83.2%), active: 28 (10.9%)
16:36:18 <Jaak> @pl \x -> [x,-x]
16:36:18 <lambdabot> (line 1, column 7):
16:36:18 <lambdabot> unexpected "["
16:36:18 <lambdabot> expecting lambda abstraction or expression
16:36:25 <Jaak> hmm
16:37:17 <sorear> @pl \x -> x : (-x) : []
16:37:18 <lambdabot> ap (:) (return . subtract)
16:37:19 <ndm> @pl \x -> (x : (-x) : [])
16:37:20 <lambdabot> ap (:) (return . subtract)
16:38:07 <Jaak> hah. but why didn't the original work?
16:38:46 <lisppaste2> allbery_b pasted "there are better ways to do this, right?" at http://paste.lisp.org/display/33368
16:41:01 * allbery_b suspecs there's a better way to thread the state through there than foldl, for one :)
16:43:20 <EvilRanter> that looks to me like a situation where explicit recursion may actually be nicer than cunning applications of fold
16:45:54 <sorear> try using mapAccumL
16:46:21 <sorear> > mapAccumL (\x a -> (x+1, [a]++show x)) "abcd"
16:46:22 <lambdabot>  add an instance declaration for (Num [Char])
16:46:34 <sorear> > mapAccumL (\a x -> ([a]++show x, x+1)) 0 "abcd"
16:46:35 <lambdabot>  Couldn't match `Char' against `[Char]'
16:46:46 <sorear> :t mapAccumL
16:46:48 <lambdabot> forall y acc x. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
16:46:59 <ndm> Jaak: i suspect @pl can't desugar lists properly
16:47:10 <sorear> > mapAccumL (\x a -> (x+1, [a]++show x)) 0 "abcd"
16:47:12 <lambdabot>  (4,["a0","b1","c2","d3"])
16:47:33 <sorear> ^^^ allbery_b -- try using this for state threading
16:47:48 <ndm> allbery_b: explain in more detail what you are trying to do?
16:48:16 <ndm> allbery_b: that code looks horrible - i suspect you can do the whole thing neater
16:48:53 <sorear> The whole thing can be done with a zipWIth and a lambda, I believe.
16:48:55 <ndm> (oh, read the comments, now i understand)
16:48:59 <allbery_b> that would be why I'm asking :)
16:49:28 <allbery_b> it's fugly, but that was what came to mind to detect common prefixes on successive lines and replace with spaces
16:49:30 <sorear> ?let prefix (x:xs) (y:ys) | x == y = ' ' : prefix x y ; prefix xs ys = ys
16:49:30 <lambdabot> <local>:2:45:     Occurs check: cannot construct the infinite type: a = [a]  ...
16:49:50 <ndm> allbery_b: so you can have an absolute "whole prefix", and what about the inner prefixes?
16:50:19 <EvilRanter> allbery_b, it looks to me that for each line, you space out the prefix that matches the previous line, right?
16:50:27 <EvilRanter> and any earlier/later lines're irrelevant?
16:50:28 <allbery_b> yes
16:50:56 <sorear> ?let prefix (x:xs) (y:ys) | x == y = ' ' : prefix xs ys ; prefix xs ys = ys
16:50:57 <lambdabot> Defined.
16:51:00 * EvilRanter visualises a zipWith (...) lines (tail lines)
16:51:06 <Eidolos> ?hoogle showHex
16:51:06 <lambdabot> Numeric.showHex :: Integral a => a -> ShowS
16:51:11 <Eidolos> ?hoogle showBin
16:51:12 <lambdabot> No matches found
16:51:15 <Eidolos> ?hoogle showBinary
16:51:15 <lambdabot> No matches found
16:51:33 <sorear> ap (zipWith prefix) tail ["foo", "food", "fork", "bar", "bazaar" ]
16:51:38 <sorear> > ap (zipWith L.prefix) tail ["foo", "food", "fork", "bar", "bazaar" ]
16:51:39 <lambdabot>  ["   d","  rk","bar","  zaar"]
16:51:50 <sorear> close enought
16:52:00 <EvilRanter> then tack the first item back on the start
16:52:25 <allbery_b> huh.  thanks sorear++
17:01:32 <kpreid> @type L.prefix
17:01:33 <lambdabot> Couldn't find qualified module.
17:01:38 <kpreid> @type Data.List.prefix
17:01:39 <lambdabot> Not in scope: `Data.List.prefix'
17:02:09 <kpreid> oh
17:02:32 * kpreid got confused and thought L. was like M.
17:11:48 <Eidolos> Could someone advise me how to do this, only syntactically correctly? :) http://rafb.net/p/5ZipwQ36.html
17:11:49 <lambdabot> Title: Nopaste - No description
17:12:27 <Eidolos> Hm.
17:12:48 <Eidolos> some kind of screwup pasting, that "x3 = x1 == sort . digits 3*x" is on its own line
17:31:15 <robreim> happy/merry solstice/holidays/Christmas everyone!
17:32:47 <_matthew_> now drink! for it is christmas
17:32:58 <_matthew_> and no type system can stop you
17:36:58 <audreyt> No instance for (Drikable [Alchohol])
17:37:10 <audreyt> No instance for (Drinkable [Alchohol])
17:38:22 <robreim> I don't drink alcohol. Will it stop me drinking water?
17:38:24 <allbery_b> "Alcohol"
17:40:39 <_matthew_> robreim: there's always an excuse to start
18:40:43 <topaz_> jews
18:42:12 <allbery_b> hrm?
18:42:22 <topaz_> what?
18:42:37 <topaz_> this isn't no facetoface conversation
18:42:42 <topaz_> you heard me
18:42:43 <topaz_> jews
18:43:10 <audreyt> apple jews or orange jews?
18:43:52 <_matthew_> fmap?
18:45:02 <audreyt> Can't match expected type `[Apple]' against inferred type `[Orange]'
18:45:15 <audreyt> In the second argument of `(==)', namely orangeJews
18:45:24 <_matthew_> data Fruit :: *1
18:47:20 <audreyt> wikipedia's "Apples and oranges" has some pretty funny idiomatic counterparts in other languages
18:47:33 <audreyt> in Serbian it's "comparing grandmothers and frogs"
18:47:41 <audreyt> in Romanian it's "comparing grandmothers and machine guns"
18:49:00 <wolverian> heh, the criticism section is fun too.
18:56:02 <bd_> @hoogle Byte8
18:56:03 <lambdabot> No matches found
18:56:06 <bd_> @hoogle Byte
18:56:06 <lambdabot> System.Win32.Types.BYTE :: type BYTE
18:56:06 <lambdabot> System.Posix.Types.ByteCount :: type ByteCount
18:56:06 <lambdabot> System.Win32.Types.LPBYTE :: type LPBYTE
19:17:11 <topaz_> @where jesus
19:17:12 <lambdabot> I know nothing about jesus.
19:19:15 <topaz_> of course you wouldn't, heathen
19:29:46 * jeffno grumbles about GHC breaking stuff
19:54:00 <Adamant> @vixen Merry Christmas!
19:54:00 <lambdabot> Why is magenta on blues clues a boy while blue is a girl? what has this world come to and what is wrong with the government, blues clues should be stopped while its ahead!!
20:06:20 <topaz_> @vixen
20:06:20 <lambdabot> I'm sorry, I'm confused.
20:06:26 <topaz_> @vixen LOL!
20:06:26 <lambdabot> hey, what's in a jack and coke anyhow?
20:13:01 <ramza3> ....jack bea and coke?
20:16:10 <topaz_> jesus juice?
21:01:40 <metaperl> ist monad?
21:01:56 <metaperl> couldnt the Maybe monad be formulated as a special case of the List monad somehow?
21:02:36 <allbery_b> given listToMaybe and maybeToList, it seems pretty obvious
21:03:02 <metaperl> @hoogle listToMaybe
21:03:03 <lambdabot> Maybe.listToMaybe :: [a] -> Maybe a
21:03:16 <metaperl> @hoogle maybeToList
21:03:17 <lambdabot> Maybe.maybeToList :: Maybe a -> [a]
21:03:32 <metaperl> thanks. I never knew of those
21:03:41 <SamB_XP> I don't think that it will wokr like you are thinking...
21:04:14 <metaperl> returns 1 value for Just x and zero values for Nothing
21:04:28 <metaperl> a list of length 1 for Just x and a list of length 0 for no values
21:05:37 <mgsloan> yeah, maybe is like a special case of list
21:15:49 <metaperl> um, I cant get this page to come up : http://www.nomaware.com/monads/html/laws.html
21:23:30 <gravity> Why would 'lighting $= Enabled' compile, but not actually enable lighting in an hopengl program?
21:23:59 <allbery_b> hm, nomaware.com doesn't seem to be responding
21:24:37 <metaperl> thank goodness for Archive.Org's wayback machine: http://web.archive.org/web/20060419212020/http://www.nomaware.com/monads/html/index.html
21:25:05 <lambdabot> Title: All About Monads, http://tinyurl.com/y6pnwd
21:29:56 <topaz_> ?gonads
21:29:57 <lambdabot> Unknown command, try @list
21:30:01 <topaz_> @list
21:30:02 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
21:34:40 <lisppaste2> metaperl pasted "will this pattern match work for _any_ member of the list?" at http://paste.lisp.org/display/33371
21:37:22 <allbery_b> so, since it's in Maybe it should shortcircuit to Nothing for the Nothing entries, and match on the nonempty lists, I'd wonder only for the empty lists
21:37:45 <allbery_b> (because the monad is in Maybe, you don't see the Justs)
21:40:52 <metaperl> but doesn't the <- operator give each element of a list... ah! that's the trick. The <- extracts things out of the monad, so when the element is Just [1,2,3], the <- operator provides [1,2,3]... got it
21:41:19 <allbery_b> right
21:41:43 <metaperl> what does <- extract out of Nothing?
21:41:54 <allbery_b> it gets shortircuited into returning Nothing
21:42:38 <allbery_b> and it looks like the failed pattern match also produces Nothing
21:44:14 <metaperl> what definition within the monad instance for Maybe guarantees the behavior of x <- Nothing
21:45:00 <jcreigh> http://www.nomaware.com/monads/html/maybemonad.html
21:45:01 <lambdabot> Title: The Maybe monad
21:45:06 <jcreigh> Nothing >>= f = Nothing
21:45:34 <jcreigh> metaperl: are you familar with how do-notation translates to >>=?
21:46:10 <allbery_b> yeh, I was looking for the formalization (and nomaware seems to be hosed, btw) but that's the basics of it; Nothing >>= _ = Nothing
21:46:21 <allbery_b> which is why it shortcircuits away
21:46:47 <jcreigh> nomaware is working fine for me, as of a couple of seconds ago.
21:47:35 <allbery_b> ah.  maybe shapr's lurking.  half an hour ago all requests were hanging
21:48:08 <topaz_> or maybe its because you're a dumb faggot
21:50:23 <metaperl> jcreigh - how does do notatoin translate to bind?
21:50:35 <bd_> @hoogle EpochTime
21:50:35 <lambdabot> System.Posix.Types.EpochTime :: type EpochTime
21:50:39 <metaperl> what does shapr have to do with nomaware?
21:52:01 * metaperl checks http://syntaxfree.wordpress.com/2006/12/12/do-notation-considered-harmful/
21:52:04 <lambdabot> Title: Do-notation considered harmful ¬´ Data.Syntaxfree, http://tinyurl.com/tlmrl
21:52:10 * allbery_b is probably msiremembering who belongs to wat, it's not unusual
21:52:39 <allbery_b> @undo do { x <- y; return x }
21:52:40 <lambdabot> y >>= \ x -> return x
21:54:19 <metaperl> I get it now. thanks allbery_b
21:55:58 <nornagon> oh hey, people are explaining monads here in a very similar way to how dylan explained them
22:05:31 <bd_> hmm, if I do an (undefined `seq` return ()) in an ErrorT, will I be able to catch it?
22:06:03 <bd_> > runIdentity $ runErrorT (undefined `seq` return ())
22:06:04 <lambdabot>  Add a type signature
22:06:14 <bd_> > (runIdentity $ runErrorT (undefined `seq` return ())) :: Either String ()
22:06:15 <lambdabot>  Undefined
22:06:20 <bd_> darn
22:06:55 <bd_> > (runIdentity $ runErrorT (do { () <- undefined `seq` (); return ()} ) :: Either String ()
22:06:55 <lambdabot>  Parse error
22:06:59 <bd_> > (runIdentity $ runErrorT (do { () <- undefined `seq` (); return ()} )) :: Either String ()
22:07:00 <lambdabot>  Couldn't match `t t1' against `()'
22:07:32 <newsham> merry christmas
22:12:51 <nornagon> so, who wants to make a haskell->arm converter so i can write haskell for the DS? >:)
22:13:00 <nornagon> s/converter/compiler/
22:17:12 <topaz_> Stfu faggot
22:17:22 <topaz_> DS is for homos
22:20:20 <geckosenator> ur a homo
22:20:52 <geckosenator> what's a homo? like homosapien?
22:21:26 <bd_> @hoogle (Read a, Error e, MonadError e m) => String -> m a
22:21:27 <lambdabot> Prelude.error :: String -> a
22:21:27 <lambdabot> Debug.Trace.trace :: String -> a -> a
22:21:27 <lambdabot> Prelude.fail :: Monad m => String -> m a
22:21:41 <robreim> nornagon: I think NHC compiles to ARM?
22:22:37 <nornagon> robreim: NHC?
22:22:38 <geckosenator> compile to c
22:22:43 <nornagon> ah
22:22:47 <nornagon> is it any good?
22:22:58 <bd_> geckosenator: Still need an RTS...
22:23:04 <topaz_> Are you fucking gay geckosenator?
22:23:13 <topaz_> most lame shit ever
22:23:14 <topaz_> shut the fuck up
22:23:21 <nornagon> why are there trolls in my #haskell?
22:23:36 <bd_> nornagon: /ignore him
22:23:46 <nornagon> aight
22:23:50 <topaz_> your haskell indeed
22:23:58 <topaz_> nice name nornagon... sounds D&D
22:24:08 <topaz_> sound just like the nerd you are above
22:24:32 <robreim> nornagon: http://www.cs.york.ac.uk/fp/nhc98/
22:24:34 <lambdabot> Title: nhc98
22:24:35 <Angel_Monadico> Hi
22:25:27 <topaz_> lol bolivia
22:25:32 <topaz_> HAHAHAHAH
22:25:35 <nornagon> is it just my settings or is that page in a really huge font?
22:25:39 <Angel_Monadico> ha Bolivia
22:25:42 <Angel_Monadico> Cochabamba
22:25:52 <nornagon> ah, it appears i am screwing with dpi
22:25:56 <topaz_> i'm sorry i don't speak faggot
22:26:07 <nornagon> and firefox doesn't retroactively apply the setting to tabs already open
22:26:08 <topaz_> could you translate for me geckosenator
22:26:35 <mgsloan> topaz - if you hadn't noticed, i think he has /ignored you
22:26:46 <geckosenator> is topaz talking?
22:26:50 <mgsloan> yes
22:26:56 <nornagon> dunno :)
22:26:57 <allbery_b> why does anyone care?
22:26:57 <mgsloan> ?list
22:26:58 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
22:27:07 <topaz_> ?kike
22:27:07 <Angel_Monadico> some from bolivia????
22:27:07 <lambdabot> Maybe you meant: dice kind time wiki
22:27:08 <mgsloan> allbery_b: it's annoiying
22:27:18 <topaz_> ?jew
22:27:19 <lambdabot> Maybe you meant: let yow
22:27:22 <topaz_> ?yow
22:27:22 <lambdabot> I don't believe there really IS a GAS SHORTAGE ... I think it's all
22:27:23 <lambdabot> just a BIG HOAX on the part of the plastic sign salesmen -- to sell
22:27:23 <lambdabot> more numbers!!
22:27:33 <topaz_> thats what i figured too lambdabot
22:27:35 <topaz_> snuggle close
22:27:37 <topaz_> ?negroid
22:27:38 <lambdabot> Unknown command, try @list
22:27:40 <topaz_> ?pill
22:27:40 <lambdabot> Maybe you meant: pl spell tell
22:27:44 <topaz_> ?coathanger
22:27:45 <lambdabot> Unknown command, try @list
22:27:47 <mgsloan> ?slap topaz_
22:27:48 * lambdabot smacks topaz_ about with a large trout
22:27:54 <topaz_> ?hammer mgsloan
22:27:54 <lambdabot> Unknown command, try @list
22:28:01 <topaz_> ?jews
22:28:02 <lambdabot> Unknown command, try @list
22:28:06 <topaz_> ?faggots
22:28:06 <lambdabot> Unknown command, try @list
22:28:07 <nornagon> where are our admins
22:28:10 <topaz_> @dmin
22:28:11 <lambdabot> Maybe you meant: djinn join
22:28:14 <topaz_> @djinn
22:28:15 <lambdabot> Cannot parse command
22:28:17 <topaz_> @join LOLL
22:28:17 <lambdabot> Not enough privileges
22:28:21 <nornagon> ?karma- topaz_
22:28:22 <lambdabot> topaz_'s karma lowered to -1.
22:28:23 <nornagon> ?karma- topaz_
22:28:23 <topaz_> @djinn OMAIJESUS
22:28:23 <lambdabot> topaz_'s karma lowered to -2.
22:28:24 <nornagon> ?karma- topaz_
22:28:24 <lambdabot> -- f cannot be realized.
22:28:24 <nornagon> ?karma- topaz_
22:28:24 <lambdabot> topaz_'s karma lowered to -3.
22:28:25 <lambdabot> topaz_'s karma lowered to -4.
22:28:31 <topaz_> O MAI JESUS KARMA'D
22:28:37 <topaz_> ?karma+ topaz_
22:28:37 <lambdabot> You can't change your own karma, silly.
22:28:37 <bd_> I've msged network staff
22:28:43 <topaz_> uh oh!
22:28:47 <topaz_> ?karma- nornagon
22:28:48 <lambdabot> nornagon's karma lowered to 1.
22:28:49 <topaz_> ?karma- nornagon
22:28:50 <topaz_> ?karma- nornagon
22:28:50 <topaz_> ?karma- nornagon
22:28:50 <lambdabot> nornagon's karma lowered to 0.
22:28:50 <topaz_> ?karma- nornagon
22:28:50 <lambdabot> nornagon's karma lowered to -1.
22:28:50 <topaz_> ?karma- nornagon
22:28:51 <topaz_> ?karma- nornagon
22:28:51 <lambdabot> nornagon's karma lowered to -2.
22:28:51 <lambdabot> nornagon's karma lowered to -3.
22:28:51 <lambdabot> nornagon's karma lowered to -4.
22:28:52 <lambdabot> nornagon's karma lowered to -5.
22:28:52 <topaz_> ?karma- nornagon
22:28:54 <lambdabot> nornagon's karma lowered to -6.
22:28:54 <topaz_> ?karma- nornagon
22:28:56 <lambdabot> nornagon's karma lowered to -7.
22:28:56 <topaz_> ?karma- nornagon
22:28:58 <lambdabot> nornagon's karma lowered to -8.
22:28:58 <topaz_> ?karma- nornagon
22:29:00 <lambdabot> nornagon's karma lowered to -9.
22:29:00 <topaz_> ?karma- nornagon
22:29:02 <lambdabot> nornagon's karma lowered to -10.
22:29:02 <topaz_> ?karma- nornagon
22:29:04 <lambdabot> nornagon's karma lowered to -11.
22:29:04 <topaz_> ?karma- nornagon
22:29:06 <lambdabot> nornagon's karma lowered to -12.
22:29:06 <topaz_> ?karma- nornagon
22:29:08 <lambdabot> nornagon's karma lowered to -13.
22:29:10 <nornagon> :O
22:29:10 <topaz_> ?karma- nornagon
22:29:12 <lambdabot> nornagon's karma lowered to -14.
22:29:14 <topaz_> Dumb jew
22:29:23 <nornagon> excellent
22:29:23 <geckosenator> wtf
22:29:24 <topaz_> is there antiflood on lambdabot?
22:29:37 <topaz_> i know there isn't here
22:29:39 <nornagon-> ?karma+ nornagon
22:29:40 <lambdabot> nornagon's karma raised to -13.
22:29:42 <nornagon-> ?karma+ nornagon
22:29:43 <lambdabot> nornagon's karma raised to -12.
22:29:44 <nornagon-> ?karma+ nornagon
22:29:44 <lambdabot> nornagon's karma raised to -11.
22:29:46 <nornagon-> ?karma+ nornagon
22:29:46 <nornagon-> ?karma+ nornagon
22:29:46 <lambdabot> nornagon's karma raised to -10.
22:29:47 <nornagon-> ?karma+ nornagon
22:29:47 <bd_> nalioth: log at http://twinsen.warpedgames.com/~bdonlan/topaz.log
22:29:47 <lambdabot> nornagon's karma raised to -9.
22:29:48 <lambdabot> nornagon's karma raised to -8.
22:29:48 <topaz_> stop spamming please
22:29:50 <nornagon-> ?karma+ nornagon
22:29:50 <lambdabot> nornagon's karma raised to -7.
22:29:54 <nornagon-> ?karma+ nornagon
22:29:54 <lambdabot> nornagon's karma raised to -6.
22:29:56 <nornagon-> ?karma+ nornagon
22:29:56 <lambdabot> nornagon's karma raised to -5.
22:29:59 <nornagon-> ?karma+ nornagon
22:29:59 <bd_> nornagon-: stop it please
22:29:59 <lambdabot> nornagon's karma raised to -4.
22:30:00 <topaz_> could you ban him nalioth? he's spamming my chat window
22:30:00 <mgsloan> I think you can priv karma
22:30:03 <topaz_> PLEASE MAKE IT STOP
22:30:06 <topaz_> PLEASE MAKE IT STOP
22:30:10 <nornagon> oh
22:30:16 <nornagon> i didn't know that, sorry for the spam :$
22:30:26 <geckosenator> is nornagon the same as topaz?
22:30:32 <mgsloan> no
22:31:00 <geckosenator> i thought they were the same person
22:31:01 <topaz_> mgsloan? like that guy from alias?
22:31:07 <topaz_> shittiest show ever
22:31:13 <topaz_> eleven seasons and it still blows
22:31:19 <mgsloan> uh, maybe... my nick is derived from my real name
22:31:22 <sieni> any channel operators around?
22:31:30 <mgsloan> sounds like you've watched it anyway, topaz
22:31:38 <nornagon> sieni: 17:24:23 -!- nalioth [i=nalioth@freenode/staff/ubuntu.member.nalioth] has joined #haskell
22:31:42 <topaz_> i watched two seasons for the chick
22:31:49 <topaz_> but its so drab i can't stand it
22:31:53 <nalioth> yes, but i'm not a channel operator, nornagon
22:32:03 <topaz_> nalioth: so, uh, how's Greg doing?
22:32:17 <topaz_> Groggles?
22:32:20 <nornagon> oh, i thought you might have super magical powers
22:32:21 <mgsloan> sieni - that's what i was thinking, but LB doesn't seem to have anything to ping ops
22:33:14 <mgsloan> I wonder why some people are total jackasses once they get on the internet
22:33:16 <Angel_Monadico> someone use Yampa??????
22:33:23 <topaz_> i have to say i admire the GNAA's work
22:33:32 <topaz_> completely duped that dumb sob lilo
22:33:41 <mgsloan> I mean, sure its mostly anonymous, but that has nothing really to do with it
22:33:44 <topaz_> and then he went and got himself flattened by a shortbus
22:34:06 <sieni> `Shortbus' was a cool movie.
22:34:28 <nornagon> i've been recommended that
22:37:45 <topaz_> ?karma- nornagon
22:37:45 <topaz_> ?karma- noliath
22:37:45 <topaz_> ?karma- audreyt
22:37:45 <topaz_> ?karma- dons
22:37:45 <topaz_> ?karma- lilo
22:37:45 <lambdabot> nornagon's karma lowered to -5.
22:37:45 <lambdabot> noliath's karma lowered to -1.
22:37:45 <topaz_> ?karma- Karlprof
22:37:46 <lambdabot> audreyt's karma lowered to 40.
22:37:46 <lambdabot> dons's karma lowered to 104.
22:37:46 <lambdabot> lilo's karma lowered to -1.
22:37:47 <lambdabot> Karlprof's karma lowered to -1.
22:37:48 <topaz_> ?karma- ademan
22:37:49 <lambdabot> ademan's karma lowered to -1.
22:37:50 <topaz_> ?karma- aking
22:37:51 <lambdabot> aking's karma lowered to -1.
22:37:51 <topaz_> ?karma- Adamant
22:37:53 <topaz_> ?karma- ascii
22:37:55 <lambdabot> Adamant's karma lowered to -1.
22:37:55 <topaz_> ?karma- balliet
22:37:57 <lambdabot> ascii's karma lowered to -1.
22:37:57 <topaz_> ?karma- atsampson
22:37:59 <lambdabot> balliet's karma lowered to -1.
22:38:00 <topaz_> ?karma- clog
22:38:01 <lambdabot> atsampson's karma lowered to -1.
22:38:01 <topaz_> ?karma- carp_
22:38:03 <lambdabot> clog's karma lowered to -1.
22:38:03 <topaz_> ?karma- Cale
22:38:05 <lambdabot> carp_'s karma lowered to -1.
22:38:05 <topaz_> ?karma- Cale
22:38:07 <lambdabot> Cale's karma lowered to 36.
22:38:07 <topaz_> ?karma- Cale
22:38:09 <mgsloan> christ, without dons this channel really goes to hell
22:38:09 <lambdabot> Cale's karma lowered to 35.
22:38:09 <topaz_> ?karma- nornagon
22:38:11 <lambdabot> Cale's karma lowered to 34.
22:38:12 <topaz_> ?karma- noliath
22:38:13 <topaz_> ?karma- audreyt
22:38:14 <mgsloan> Cale - you have ops eh?
22:38:15 <lambdabot> nornagon's karma lowered to -6.
22:38:16 <topaz_> ?karma- dons
22:38:17 <lambdabot> noliath's karma lowered to -2.
22:38:18 <topaz_> ?karma- lilo
22:38:18 <nornagon> oh my
22:38:19 <lambdabot> audreyt's karma lowered to 39.
22:38:21 <mgsloan> probably asleep
22:38:23 <topaz_> always good to have bots do things for you
22:38:23 --- mode: nalioth set +b *!*@adsl-68-121-148-82.dsl.pltn13.pacbell.net
22:38:23 --- kick: topaz_ was kicked by nalioth (nalioth)
22:38:24 <lambdabot> dons's karma lowered to 103.
22:38:26 <lambdabot> lilo's karma lowered to -2.
22:38:34 <nornagon> hooray
22:38:35 <bd_> nalioth: thanks :)
22:38:38 * nornagon hugs nalioth 
22:38:38 <nalioth> don't worry, he'll be right back
22:38:42 <geckosenator> finally
22:44:46 <metaperl> nalioth - hi
22:44:54 <nalioth> metaperl: howdy
22:47:37 <nornagon> whoever raised my karma back to 3, i only had 2 before
22:48:49 <mgsloan> I raised it to 2
22:49:05 <nornagon> oh, maybe i'm a dork :)
22:49:15 <nornagon> yeah, that'd be it
22:49:17 <nornagon> sry
22:49:18 <nornagon> >.>
22:49:30 <mgsloan> :)
22:59:37 <metaperl> How do you create the handle for hGetContents - http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html#v%3AhGetContents
22:59:39 <lambdabot> http://tinyurl.com/sbkmj
23:00:23 <Shimei> Wow, this channel gets strange trolls. Maybe not as strange as #nethack though... ;)
23:00:32 <mgsloan> openFile
23:00:41 <metaperl> mgsloan - thanks
23:01:30 <mgsloan> no prob.  It returns an IO Handle, of course, so you have to lift hGetContents
23:01:48 <mgsloan> or use do notation
23:02:09 <metaperl> yeah - they use do notation here - http://www.nomaware.com/monads/html/monadfns.html
23:02:10 <lambdabot> Title: Monad support in Haskell
23:15:30 <metaperl> liftM f = \a -> do { a' <- a; return (f a') } --- how does a' <- a work? a is not a monad and hence <- cannot extract it from a monad...
23:18:02 <sieni> of course a is not a monad, since it's a value, not a type
23:19:02 <metaperl> yes , so what does a' <- do?
23:19:10 <metaperl> I mean a' <- a
23:19:13 <allbery_b> @type liftM
23:19:14 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
23:19:32 <allbery_b> looks like a is in a monad to me.
23:20:30 <metaperl> oh yeah, we are lifting the _function_!
23:23:43 <mgsloan> within the {} is do notation
23:30:24 <dons> ?yow
23:30:25 <lambdabot> BARRY ... That was the most HEART-WARMING rendition of "I DID IT MY
23:30:25 <lambdabot> WAY" I've ever heard!!
23:31:47 <dons> urgh. zptao came around again did he? :/
23:32:37 <allbery_b> well, something did
23:32:57 <dons> topaz == zptao == known pain
23:34:09 <mgsloan> hey dons is back
23:34:15 <mgsloan> 'lo dons
23:34:54 * allbery_b wouldn't know, but school vacation time is usually when the kiddies come out to play
23:35:23 <dons> hey guys :)
23:35:53 <dons> sorry about the troll. we get spoilt here with reasonable, polite conversation :)
23:36:36 <mgsloan> albery - true, but christmas eve/day
23:36:49 <dons> ?time dons
23:36:53 <lambdabot> Local time for dons is Mon Dec 25 18:32:05 2006
23:37:21 <mgsloan> ?time mgsloan
23:37:38 <mgsloan> huh
23:37:41 <dons> not all clients respond (you can block it)
23:37:53 <mgsloan> i haven't blocked it but apparently gaim doesn't give it
23:38:12 <dons> ah yes. sounds like gaim ;)
23:38:32 <dons> we had to modify lambdabot due to a different bustedness in gaim, re. notices
23:38:44 <mgsloan> huh
23:38:48 <metaperl> > (liftM2 (+)) [0,1] [7,8,9]
23:38:50 <lambdabot>  [7,8,9,8,9,10]
23:38:55 <dons> heya metaperl
23:39:01 <metaperl> dons - yo!
23:39:17 <mgsloan> well, I might switch to something else if there's a decent jabber/irc client
23:39:21 <metaperl> > (liftM2 zip) [0,1] [7,8,9]
23:39:22 <lambdabot>  add an instance declaration for (Num [b])
23:39:22 <lambdabot>   In the list element: 9
23:40:01 * allbery_b keeps the jabber separate from the irc (and the zephyr), because in general they behave like different beasts
23:40:21 <metaperl> @type (liftM2 (+))
23:40:22 <lambdabot> forall a2 (m :: * -> *). (Monad m, Num a2) => m a2 -> m a2 -> m a2
23:40:42 <metaperl> @type (+)
23:40:44 <lambdabot> forall a. (Num a) => a -> a -> a
23:40:56 <dons> mm, where's ChanServ gone?
23:41:15 <metaperl> it's the do-notation that does it... slick!
23:41:31 <metaperl> liftM2 is slick once you understand it's implementation
23:41:45 <mgsloan> allbery - true, if you do more than text
23:42:31 <mgsloan> ?. djinn type liftM2
23:42:33 <lambdabot> Cannot parse command
23:43:24 <metaperl> > (liftM2 (\a b -> (a,b))) [0,1] [7,8,9]
23:43:25 <lambdabot>  [(0,7),(0,8),(0,9),(1,7),(1,8),(1,9)]
23:43:30 --- mode: irc.freenode.net set +o ChanServ
23:43:38 <metaperl> is that the easiest way to do that?
23:44:17 <mgsloan> > zipWith (,) [0,1] [7,8,9]
23:44:19 <lambdabot>  [(0,7),(1,8)]
23:44:22 <mgsloan> hmm
23:44:30 <mgsloan> oh, yeah, cartesian product
23:45:10 <metaperl> I think it would be hard to implement liftM2 without do-notation
23:45:41 <allbery_b> well, monads at least
23:45:53 <mgsloan> oh? do notation has quite automatic changes to normal syntax
23:46:13 <mgsloan> ?type liftM2
23:46:14 <lambdabot> forall r (m :: * -> *) a2 a1. (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
23:46:42 <metaperl> liftM2 f = \a b -> do { a' <- a; b' <- b; return (f a' b') }
23:47:10 <metaperl> a' takes on all values in the first monad/list and b' takes on all values in the second monad/list
23:47:30 <metaperl> @type ($)
23:47:32 <lambdabot> forall b a. (a -> b) -> a -> b
23:47:33 <uccus> > let liftM2 f = \a b -> do { a' <- a; b' <- b; return (f a' b') }
23:47:34 <lambdabot>  Parse error
23:48:01 <metaperl> (1+) $ 5
23:48:10 <metaperl> > (1+) $ 5
23:48:12 <lambdabot>  6
23:48:22 <uccus> > let liftM2 f = \a b -> do { a' <- a; b' <- b; return (f a' b') } in liftM2 (,) [1, 3] [3, 4]
23:48:23 <lambdabot>  [(1,3),(1,4),(3,3),(3,4)]
23:48:36 <mgsloan> ?undo do { a' <- a; b' <- b; return (f a' b') }
23:48:37 <lambdabot> a >>= \ a' -> b >>= \ b' -> return (f a' b')
23:48:43 <mgsloan> thar yah go
23:48:56 <metaperl> hmm
23:49:16 <uccus> does @pl work on it?
23:49:32 <allbery_b> @. pl undo do { a' <- a; b' <- b; return (f a' b') }
23:49:33 <lambdabot> (`fmap` b) . f =<< a
23:49:38 <mgsloan> ooh
23:50:10 <mgsloan> even uses the reverse applicator
23:50:33 <uccus> is it supposed to be cool to use the reverse applicator?
23:52:00 <metaperl> http://www.nomaware.com/monads/html/monadfns.html makes a confusing statement: "Note that liftM2 f x y is equivalent to return f `ap` x `ap` y, and so on for functions of more arguments. "  ... but liftM2 just takes one function liftM2 f x y makes no sense ot me
23:52:00 <lambdabot> Title: Monad support in Haskell
23:52:19 <allbery_b> @pl \f a b = a >>= \a' -> b >>= \b' -> return (f a b)
23:52:19 <lambdabot> (line 1, column 8):
23:52:19 <lambdabot> unexpected "="
23:52:19 <lambdabot> expecting pattern or "->"
23:52:29 <allbery_b> @pl \f a b -> a >>= \a' -> b >>= \b' -> return (f a b)
23:52:30 <lambdabot> liftM2 (.) (>>=) . (((const .) . ap (>>=) . ((const . return) .)) .)
23:52:39 <allbery_b> there are also liftM3, liftM4, etc.
23:52:54 <allbery_b> (up to 6 IIRC)
23:53:00 <uccus> is that pl the simplest?
23:53:32 <uccus> @pl liftM2
23:53:33 <lambdabot> liftM2
23:53:41 <uccus> figures 8-)
23:54:24 <uccus> :t ap
23:54:26 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
23:54:26 <mgsloan> @define liftM2
23:54:26 <allbery_b> any bare function will @pl to itself
23:54:27 <lambdabot> (line 1, column 1):
23:54:27 <lambdabot> unexpected end of input
23:54:27 <lambdabot> expecting white space or simple term
23:54:41 <mgsloan> should pull definitions from a nice source (eg, pretty prelude)
23:55:01 <allbery_b> because it's already point-free
23:55:37 <uccus> but define didn't work
23:55:53 <mgsloan> yeah, it's unimplemented
23:56:02 <uccus> :)
23:56:18 <allbery_b> hm, I thought @define was like @let
23:56:29 <mgsloan> oh, I forgot it is
23:56:36 <mgsloan> ahwell, it should be repurposed
23:57:16 <uccus> well, most haskell function definitions are the easiest way to describe it
23:57:29 <uccus> so occasionally we would want to see the def
23:57:50 <uccus> is there a Haskell tool (like Hoogle) to do that? does GHCi show the definitions?
23:57:59 <allbery_b> @source Prelude
23:58:00 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
23:58:15 <uccus> alright
23:58:24 <uccus> but does it work for functions?
23:58:32 <allbery_b> only one I know of offhand.  but it's not necessarily pretty, as those tend to be optimized
23:58:38 <uccus> it could well be re-imported buy Prelude
23:58:49 <metaperl> @type ($)
23:58:51 <lambdabot> forall b a. (a -> b) -> a -> b
23:58:55 <allbery_b> (I don't recall if liftM2 is in there or somewhere else)
23:59:11 <allbery_b> @hoogle liftM2
23:59:11 <lambdabot> Monad.liftM2 :: Monad a => (b -> c -> d) -> a b -> a c -> a d
23:59:11 <lambdabot> Control.Monad.liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
23:59:15 <mgsloan> http://www.haskell.org/onlinereport/standard-prelude.html
23:59:17 <lambdabot> Title: The Haskell 98 Report: Standard Prelude
23:59:18 <mgsloan> this one is nice
23:59:25 <allbery_b> yeh
23:59:30 <metaperl> uccus - if Hoogle points you to the ghci docs, then you can click on "Source code" at the top of the page, to see the source for that module
23:59:36 <uccus> allbery_b: I am talking about any module in scope
