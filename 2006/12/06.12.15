00:00:13 <sjanssen> Excedrin: no, it'd be a special new command
00:01:02 <treitter> kzm: forgot main
00:01:12 <treitter> is main always a monad?
00:01:23 <treitter> (also, is main a keyword, or just convention?)
00:01:28 <Excedrin> main is a function
00:01:36 <kzm> main :: IO ()
00:01:41 <kzm> main is an IO action.
00:01:43 <sjanssen> treitter: yes, main is always an IO () (a monadic IO action)
00:01:43 <dancor> sjanssen: why not just and endedit one.  like ipython uses two newlines to know to exit an indentation level
00:01:49 <ski> main is an IO-action !
00:02:03 <newsham> just 1 IO action (but it can be a really big one)
00:02:03 <treitter> Excedrin, kzm, sjanssen: apparently you're all right :)
00:02:04 <dancor> s/\(just an\)d/\1
00:02:04 <sjanssen> treitter: main is just convention
00:02:14 <Excedrin> no, I'm wrong
00:02:27 <kzm> I guess we'll just have to disagree that we agree?
00:02:30 <treitter> are monads not a subset of functions?
00:02:32 <sjanssen> dancor: because then every single expression would need :endedit
00:02:43 <treitter> or can functions never have side effects?
00:02:57 <kzm> treitter, no.
00:02:57 <treitter> ..OK, I realize how dumb of a question that is :)
00:03:00 <sjanssen> functions do not have side effects
00:03:03 <newsham> an action is a value.  a function may result in a value.
00:03:08 <Excedrin> functions never have side effects (unless you use unsafePerformIO)
00:03:10 <dancor> treitter: monads just like postpone the moment of truth
00:03:57 <ski> 'IO' itself is a monad, 'main' is an IO-*action*, i.e. a monadic action, from the IO-monad
00:04:29 <Excedrin> is it correct to say it's a value of IO type?
00:04:33 <ski> yes
00:04:39 <newsham> examples of IO actions are "print the number 5", "open a socket to www.google.com", "read in two lines, convert them to integers, add them, and print the result"
00:05:15 <newsham> IO actions can result in values.  the distinguished value () (type ()?) denotes no important value
00:05:43 <Excedrin> @type ()
00:05:45 <lambdabot> ()
00:06:02 * ski finds it convenient to say that monadic actions "monadically return" a value
00:06:29 <newsham> the "monadic return"/"result" is in addition to any side effects that may occur.
00:06:30 <sjanssen> Excedrin: except IO isn't a complete type.  You need to say "IO ()" or something when being pedantic ;)
00:06:59 <ski> so, e.g. 'getLine' reads a line from standard input, and monadically returns that line
00:07:02 <ski> @type getLine
00:07:03 <lambdabot> IO String
00:07:14 <newsham> ?type print 5
00:07:16 <lambdabot> IO ()
00:07:28 <Excedrin> sjanssen: ya, I considered that, but it's a bit odd since GHC's main can be of types other than IO ()
00:07:35 <newsham> "print 5" is an IO action that doesnt have a meaningful result value
00:07:54 <ski> i'd s/meaningful/interesting/ :)
00:08:16 <newsham> do-blocks (or the bind operator >>=) are used to combine two or more IO actions into one big IO action.
00:08:38 <newsham> because the haskell program only runs 1 action (main :: IO ())
00:08:44 <ski> (or more generally, to combine two actions, from any particular monad, into one big action, from that monad)
00:08:58 * sjanssen notes that treitter has been silent for the past several minutes ;)
00:09:06 <treitter> sjanssen: just reading it in :)
00:09:18 <treitter> still trying to wrap my head around a lot of this stuff
00:09:27 <treitter> ..like why "IO String" is a type :)
00:09:43 <newsham> a la:   main = do { as <- getArgs; print as }
00:09:47 <ski> treitter : do you understand why 'Maybe Int' is a type ?
00:10:40 <newsham> getLine is an action that when run affects the real world (causes the program to consume input).  It also results in a string value that is monadically returned.
00:10:51 <treitter> ski: nope
00:10:52 <newsham> a la:  main = do { l <- getLine; print l }
00:11:08 <Excedrin> treitter: are you familiar with other languages?
00:11:12 <newsham> so in addition to having some sort of affect ont he world (IO), it has resulted in a String value.
00:11:18 <newsham> hence (IO String)
00:11:37 <newsham> "print l" on the other hand affected the world (IO) but doesnt result in a value (IO ())
00:11:55 <treitter> Excedrin: assembly (a few types), C, Java, Python, shell, some Perl, some SQL, PHP (though it's been a while), etc.
00:11:57 <newsham> (ps: the resulting value of the entire do-block is the result of its last action)
00:12:15 <ski> treitter : hm, do you understand what the type '[Int]' means ?
00:12:21 <treitter> ski: yeah
00:12:27 <treitter> ski: a list of ints
00:12:39 <ski> '[Int]' can be read as "list of int"
00:12:49 <ski> 'IO Int' can be read as "io of int"
00:12:53 <dons> > "haskell" :: [] Char
00:12:54 <lambdabot>  "haskell"
00:13:00 <newsham> ([] Int)
00:13:40 <ski> think of a value of type 'IO Int' as a kind of box, that you can kick, and then it runs for a while, doing I/O things with the world, and then spits out an 'Int'
00:13:46 <dons> > ('a', 2) :: (Char, Int)
00:13:47 <lambdabot>  ('a',2)
00:14:07 <dons> > (Just 7) :: (Maybe Int)
00:14:09 <lambdabot>  Just 7
00:14:17 <dons> > Nothing :: (Maybe Int)
00:14:18 <lambdabot>  Nothing
00:14:46 <ski> (but, you can only kick such box from inside another box .. hm, strange analogy :)
00:15:12 <dons> > readFie
00:15:13 <lambdabot>  Not in scope: `readFie'
00:15:13 <lisppaste2> metaperl annotated #32473 with "one simple question about Named (Name a)" at http://paste.lisp.org/display/32473#4
00:15:18 <newsham> you only kick one box.  but if you look closely you can see that its lots of boxes glued together :)
00:15:23 <dons> > readFile
00:15:25 <lambdabot>  <[Char] -> IO [Char]>
00:15:32 <treitter> ski: yeah. So if you have     getint :: IO Int          why can't you do something like        a = getint + 3
00:15:46 <dons> > readFile "/etc/passwd"
00:15:48 <lambdabot>  <IO [Char]>
00:15:51 <ski> 'getint' is not an integer, so you can't add things to it
00:16:13 <treitter> ski: but if it were :: Int, you could do that addition, right?
00:16:18 <ski> it is a subprogram, that *when*run* will produce an integer (and possibly some side-effects)
00:16:21 <dons> treitter: since that would be   (IO Int) + Int
00:16:23 <newsham> treitter: only one IO action runs.  its called "main".  if you want to use "getint" you have to wrap it together into an action called "main" somehow
00:16:47 <newsham> and the way you combine actions together is a do-block.
00:17:20 <ski> main = do n <- getint
00:17:20 <ski>           let a = n + 3
00:17:20 <ski>           print a
00:17:22 <newsham> so you could do:     main = do { i <- getint; let a = i+3; print a}
00:17:25 <treitter> ski, newsham: ah. That helps clear some things up
00:17:45 <ski> newsham :)
00:18:11 <newsham> that whole main is one big  IO ().
00:18:47 <newsham> inside the do-blck you might have noticed that we use an action and get its result with      x <- act
00:18:51 <ski> to "grab the results" of an IO-action, you will probably want to use '<-' inside 'do'-notation  (there are other ways, but this is the easiest way to get going)
00:19:28 <bitshifter> if you had 2 IO Ints that you wanted to add, you could liftM2 (+) (IO int1) (IO int2)
00:19:45 <newsham> that binds x to the result of act for the remainder of the do block
00:19:48 <ski> treitter : what do you say ?
00:20:10 <newsham> (you can also use  "let x = func args"  to bind x fto a normal function result for the rest of the do-block)
00:20:21 <treitter> ski: if I used <-, could I use that in a function other than main?
00:20:30 <ski> yes
00:20:48 <treitter> ski: also, can I not do IO in a function defined at the module level, as long as I only call it within main?
00:20:53 <ski> but only inside 'do'-notation .. i.e. you must be inside some monadic action
00:21:02 <newsham> you can build up your own   (IO *)  actions outside of main, and incorporate them into your main freely.
00:21:06 <treitter> ski: ignore that first "not"
00:21:18 <ski> all functions that do IO must have 'IO' in its type
00:21:30 <ski> (otherwise you get type error)
00:21:30 <treitter> ah, cool
00:21:32 <newsham> like:    getint = do { l <- getLine; return (read l) };
00:21:38 <newsham> then use "getint" in main as we did above
00:21:50 <treitter> well, it's getting past my bed time :)
00:21:57 <treitter> newsham: awesome
00:21:59 <newsham> that getint will be an   IO Int   (assuming the read l is Int)
00:22:13 <treitter> thanks for all the help, everyone!
00:22:19 <ski> np
00:22:21 <Excedrin> http://en.wikipedia.org/wiki/Polymorphism_(computer_science)
00:22:29 <Excedrin> that's a reasonable article
00:22:38 <treitter> I'll bug you guys more as I figure out which questions to ask :)
00:22:47 <newsham> eggssellent
00:22:56 <newsham> happy coding
00:23:19 <treitter> Excedrin: ah, yeah. I've got an idea about what polymorphism is (from the OO perspective, at least)
00:23:45 <Excedrin> I'm not sure how to describe parametric poly in terms of C, Java or Python
00:23:49 <newsham> do { l <- act; return (f l) }   <- now only if there was a way to factor that out, since I do it so often!
00:24:15 <goltrpoat> act >>= return f
00:24:19 <goltrpoat> er
00:24:24 <goltrpoat> return . f
00:24:28 <Korollary> that article has some braindead sentences.
00:24:44 <ski> (subtyping polymorphism as in OO is not the same as parametric polymorphism as in FP)
00:24:52 <dblhelix> Excedrin: generics in Java, C#, templates in C++?
00:24:59 <Excedrin> the part about parametric polymorphism is the important part...
00:25:04 <goltrpoat> oh.. did i just randomly substitute the expression without reading the rest of the conversation
00:25:09 <ski> newsham : 'f `liftM` act'
00:25:11 <Excedrin> dblhelix: yes, but are generics in Java widespread?
00:25:14 <goltrpoat> yes yes, it does appear that i did.
00:25:17 <goltrpoat> sorry about that
00:25:26 <newsham> ski: i object, leading the witness.
00:25:41 <dblhelix> Excedrin: I can't really judge that...
00:25:47 <ski> newsham : huh ?
00:25:54 <dblhelix> Excedrin: I guess templates in C++ are
00:26:05 <Excedrin> the Java I learned didn't have generics yet, so I'm not familiar with them..
00:26:27 <newsham> ski: it was a leading question.  i'm aware of liftM :)
00:26:33 <Korollary> Generics is new for java, but I bet it's used quite a bit now.
00:26:47 <Korollary> Bugger this pacific northwest wind btw
00:27:38 <newsham> do { x <- act1; y <- act2; return (x `op` y) }?
00:28:22 <bitshifter> liftM2 op act1 act2
00:28:43 <araujo> http://epolyglot.sourceforge.net/
00:28:44 <lambdabot> Title: SourceForge: Welcome
00:28:45 <araujo> :-P
00:31:13 <Excedrin> araujo: ... "Functional languages are a peculiar but potentially powerful subset of languages."
00:32:03 <bitshifter> And if you strike them down they will become more powerful than you can imagine.
00:32:10 <araujo> Excedrin, ?
00:32:21 <newsham> do { f <- act1; return (f x) }
00:32:24 <Excedrin> from the epolyglot docs
00:32:46 <araujo> aah
00:32:50 <araujo> Excedrin, you use it?
00:33:14 <Excedrin> no, just browsing thru it since you linked it
00:33:29 <sjanssen> Lord Java, the more you tighten your grip, the more programmers will slip through your fingers
00:34:32 <Excedrin> "... using the four together: structure a large application in Eiffel, script it and extend it at run-time using Python, refer to Haskell for thorny numerical sections, and drop down to C for any system-specific bit-twiddling stuff."
00:34:40 <araujo> Excedrin, ah ok, i just knew about it.
00:35:53 <newsham> "refer to haskell"?
00:36:38 <newsham> so does that mean haskell is a fancy calculator?
00:36:50 <bitshifter> I used it as a fancy calculator today.
00:37:11 <newsham> i hope you used C for any bitshifting.
00:37:54 <bitshifter> Everyone knows that the best bitshifting happens with assembly
00:38:00 <bitshifter> :)
00:38:41 <newsham> that is true.  everyone loves a carry-bit
00:39:28 <bitshifter> I wonder if I can use an unsafeCoherce to "accidentally" execute machine code in a ByteString
00:40:11 <bitshifter> and then write the result back into the same ByteString.
00:41:09 <bitshifter> Of course, I think I might get lynched if I do try.
00:41:39 <sjanssen> bitshifter: I'm sure you could, if you want to learn GHC's heap and thunk structure very intimately
00:42:13 <bitshifter> I do.  I've been kicking around an idea to include something akin to a stack trace in the ghc rts
00:42:35 <Korollary> there's a bit of a problem regarding stack traces and lambda calculus.
00:43:01 <newsham> probably dont have to learn too much of ghc's layout.  just get something crashing in a debugger and make slight tweaks until it jumps to your code
00:43:01 <Korollary> This includes strict and lazy LC
00:43:43 <bitshifter> I know, but I figure the state of the machine at any point is a graph and if we have the graph plus the path through it it could be helpful when you're not sure how you got errors.
00:43:46 <Korollary> See this post: http://calculist.blogspot.com/2006_03_01_calculist_archive.html
00:43:48 <lambdabot> Title: The Little Calculist: March 2006
00:45:07 <bitshifter> As someone who has recently learned haskell for work and has run into problems it would be tremendously helpful for those of us who need to produce programs for work while learning
00:45:56 <Excedrin> "Static typing can be frustrating, but very handy."
00:50:45 <newsham> tracking down runtime bugs can be frustrating too
00:50:53 <geckosenator> how come I can type code into the interpreter and it fails, but if I load it, it works
00:51:20 <newsham> what kind of failure?  missingimports?
00:51:32 <sjanssen> geckosenator: the interpreter only accepts expressions.  You're probably entering some sort of function or data declaration
00:52:06 <Excedrin> newsham: maybe worth reading for comedy? http://epolyglot.sourceforge.net/epolyglot/c1517.html
00:52:55 <geckosenator> sjanssen: ok, what if I want to do that?
00:53:14 <sjanssen> geckosenator: you enter declarations into a file
00:53:34 <sjanssen> dons: ^^^ maybe we really do need that FAQ :)
00:53:38 <geckosenator> why can't I do it as I go?
00:53:54 <sjanssen> because the interpreters don't work like that
00:54:06 <geckosenator> i thought they did
00:54:22 <sjanssen> it's quite tricky in Haskell, because you never know when a declaration is finished until you look at the next line
00:55:05 <geckosenator> hmm
00:55:18 <bitshifter> I felt the same way when I started entering things in ghci, I eventually read something that made it clear why it wouldn't work.
00:55:32 <bitshifter> I think it was in the ghc users guide
00:55:54 <sjanssen> bitshifter: do you remember roughly what the explanation is?
00:55:57 <geckosenator> how would I make a datatype where two of the elements are the same type?
00:56:28 <newsham> data Foo = Foo Int Int Int String Int ?
00:56:29 <sjanssen> data Two a = Two a a -- is one example
00:57:15 <geckosenator> ooh thanks
00:57:16 <geckosenator> I got it
00:57:48 <Excedrin> does
00:58:13 <Excedrin> Helium let you enter definitions and evaluate things as you go?
00:58:30 <sjanssen> good question
00:58:41 <geckosenator> waht is helium?
00:58:43 <bitshifter> sjanssen: Not really, just that I didn't like it because I really wanted to put data types and whatnot directly into ghci but the explaination made sense
00:59:08 <Excedrin> http://www.cs.uu.nl/helium/
00:59:09 <bitshifter> helium is another implemntation of haskell
00:59:10 <lambdabot> Title: [ The Helium Homepage - Home]
00:59:48 <Excedrin> but no typeclasses
00:59:52 <dons> sjanssen: hmm. yes.
00:59:55 <dons> so we do need a page
01:09:27 <bitshifter> Yeah, I re-read the documentation on ghci and I couldn't find the explaination I so vaugely recall
01:10:08 <bitshifter> It must have been somewhere else.
02:54:28 <Masklinn> hello everybody
02:57:30 <therp> good morning everyone
02:57:50 <therp> who wants a copy of my liskell paper?
02:58:07 <oip> morning... i!
02:58:23 <therp> /msg therp <youremail> :)
02:59:05 <Saizan> liskell?
02:59:50 <therp> or for unregistered users you might also /msg #liskell <youremail>
03:00:19 <therp> saizan: a hybrid of lisp and haskell aiming for meta-programming in a pure functional programming language (such as haskell)
03:00:38 <Saizan> macro in haskell?
03:00:49 <therp> saizan: exactly
03:00:57 <Saizan> :O
03:01:03 <therp> they are called parse tree transformers in Liskell and are more generall than macros.
03:01:09 <therp> lisp macros are implemented on top of them.
03:01:31 <lightstep> they can do more than a stateful replacement of the source code?
03:01:42 <lightstep> can they go back in time or something?
03:02:05 <therp> lightstep: no. but macros can not implement quoting/backquoting for instance
03:02:26 <norpan> liskell!
03:02:36 <norpan> and hasp
03:02:54 <dons> therp: !
03:03:14 <dons> therp, url please!
03:03:26 <dons> this is your chance to get famous :)
03:04:26 <therp> dons: ah I'm a bit shy :) also I'm not sure what are the requirements for the publisher the paper goes to wrt to publishing it on my own on my website and so on.
03:04:59 <dons> who's the publisher?
03:05:05 <therp> ACM SIGPLAN
03:05:05 <lightstep> bummers. darcs doesn't work well on some samba file systems, 'cause it can't get a lock on files
03:05:24 <dons> therp, they let authors post preprint version on the website (all my papers are acm sigplan)
03:05:29 <dons> or springer
03:05:43 <dons> it should say on the copyright form you've signed?
03:06:00 <therp> dons: no, I haven't signed anything yet..
03:06:21 <dons> ah , then its still your copyright. you could post it marked as "draft"
03:06:38 <therp> yes, that's a good idea
03:06:45 <dons> so until you hand over copyright, its yours to publish as you wish
03:06:58 <dons> and i know about 200 people on reddit.com that want haskell with lisp syntax ... ;)
03:07:07 <therp> omg! :)
03:07:25 <therp> dons: actually I ordered a new webcam yesterday, so I could make screencast for that thing.
03:07:43 <dons> mmm. nice idea!
03:08:22 <therp> the syntax looks a bit ugly at the moment, I'm afraid. at least the lispers I demo-ed it to yesterday.
03:08:53 <dons> you might also want to announce it on haskell@haskell.org
03:09:03 <dons> so you can get some people testing the preprocessor
03:10:14 <therp> yes sure. I already started cleaning out my patches to GHC and I hope to merge my tree with the latest darcs and start to 'darcs record' my patches
03:10:26 <therp> but at the moment I'm fine if the paper is out before the deadline today :)
03:10:32 <dons> great
03:12:11 <therp> dons: do you want a copy too per mail?
03:12:27 <dons> yes please :) dons@cse.unsw.edu.au
03:12:52 <therp> found it already thanks :).. it's not like you're a stranger to a planet.haskell.org reader
03:13:50 <dons> ah ok :)
03:29:35 <goltrpoat> this is kind of interesting:  http://refal.botik.ru/book/html/
03:29:40 <lambdabot> Title: REFAL-5
03:39:53 <araujo> good morning
03:40:11 * araujo looking for suggestions
03:40:39 <araujo> what would be a nice functional domain name? :-)
03:40:50 <pejo> goltr, it's all blank for me? (What is it, Refal-5 manual or something?)
03:42:10 <goltrpoat> yeah it's a refal-5 manual
03:42:33 <goltrpoat> never seen actual refal source before
03:43:58 <pejo> Oh, it looks good in Mozilla.
03:44:51 <dons> araujo: comonad.org ?
03:44:58 <dons> that's edwardk's new domain :)
03:45:14 <dons> fmap.org ?
03:45:35 <dons> www.unsafePerformIO.org
03:45:43 <dons> bah, Florida Market Assistance Plan (FMAP)
03:46:03 <araujo> argh
03:46:06 <araujo> hi dons !
03:46:16 <dons> hey
03:47:24 <araujo> hah, that last one is tempting :-)
03:48:39 <malebria> dons: I'm reading your haskell syntax recent article.
03:48:44 <araujo> dons, wanna get something that might probably be used by the community in the long
03:49:09 <malebria> dons: In the on syntax part it really sounds that haskell syntax is great.
03:50:08 <malebria> dons: but in Type declarations made mechanical, you use an implementation of fibonacci which I don't would like to write, fibs = fix ((1:) . scanl (+) 1)
03:50:19 <dons> hehe. its a joke :)
03:50:30 <dons> its just a fun toy fibonacci example
03:50:57 <malebria> dons: I'm trying to understand how it works for some minutes now..
03:50:57 <dons> araujo: like what?
03:50:58 <malebria> =D
03:51:03 <dons> malebria: hehe
03:51:10 <dons> :t scanl
03:51:11 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
03:51:20 <dons> scanl is like a for loop, that returns all intermediate results
03:51:26 <malebria> yes, now I got it.
03:51:32 <dons> > scanl (\a b -> a + b) 0 [1..5]
03:51:33 <lambdabot>  [0,1,3,6,10,15]
03:51:47 <dons> > foldl (\a b -> a + b) 0 [1..5]
03:51:48 <lambdabot>  15
03:51:53 <malebria> But I don't get fix.
03:51:58 <malebria> fix is very complicated.
03:52:08 <malebria> > scanl (+) 1 [1, 2, 3]
03:52:09 <lambdabot>  [1,2,4,7]
03:52:15 <malebria> > take 10 $ fix ((1: ) . scanl (+) 1)
03:52:17 <lambdabot>  [1,1,2,3,5,8,13,21,34,55]
03:52:21 <malebria> I just can't get from one to another.
03:52:25 <dons> its a recursion function.
03:52:30 <dons> so instead of:
03:53:10 <dons> here's the defintioin of fix:
03:53:10 <ms_> > let fib = 0:1: [(fib !! (i-2)) + (fib !! (i-1))  |i <- [2..]] in fib !! 10
03:53:11 <dons> fix :: (a -> a) -> a
03:53:11 <lambdabot>  55
03:53:13 <dons> fix f = let x = f x in x
03:53:23 <dons> so, fix ((1: ) . scanl (+) 1)
03:53:33 <malebria> Sorry.
03:53:41 <malebria> My wireless disconnected here.
03:54:14 <malebria> (12:47:56) dons: here's the defintioin of fix:
03:54:16 <dons> > let fibs = ((1: ) . scanl (+) 1) fibs in fibs
03:54:17 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
03:54:21 <malebria> That's the last message I got.
03:54:28 <dons> fix f = let x = f x in x
03:54:32 <dons> is the definition of fix
03:54:41 <malebria> Yes, I saw it in the ghc darcs repo.
03:54:46 <dons> so you can rewrite:  fix ((1: ) . scanl (+) 1)
03:54:52 <dons> as let fibs = ((1: ) . scanl (+) 1) fibs in fibs
03:55:01 <malebria> But anyway, it's not clear to me why (1:) . scanl (+) 1 generates fibs.
03:55:09 <malebria> dons: yes..
03:55:31 <dons> ?unpl (1:) . scanl (+) 1
03:55:32 <lambdabot> (\ d -> 1 : (scanl (+) 1 d))
03:56:10 <dons> so you start with 1
03:56:19 <dons> then get 1 : scanl (+) 1
03:56:31 <dons> giving you 1 : 1 : scanl (+) 1 (....)
03:56:36 <malebria> hum...
03:56:40 <dons> and it just unfolds into the entire sequence
03:56:51 <araujo> dons, not sure yet, package repo , news site , etc
03:56:57 <dons> so the key to understanding this is to trace the inlining of definitions
03:57:25 <malebria> yes, I'm trying to do this.
03:57:49 <dons> a much easier one to start with is here: http://haskell.org/haskellwiki/The_Fibonacci_sequence
03:57:50 <lambdabot> Title: The Fibonacci sequence - HaskellWiki
03:58:01 <dons> > let fib = 1 : 1 : zipWith (+) fib (tail fib) in fib
03:58:03 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
03:58:18 <dons> which uses the recursion, but isn't as deeply nested as the little scanl version
03:58:29 <malebria> hum..
03:59:13 <malebria> dons: this one is quite simple for me.
03:59:19 <dons> ok good :)
03:59:32 <malebria> cause it adds the first with the second and so on..
03:59:36 <dons> yeah
04:00:19 <malebria> I think I don't understood fix right.
04:00:34 <malebria> I got that it's recursive, but what's the first x value?
04:00:51 <malebria> oh, there's no first..
04:01:03 <dons> well, its lazy, so it has to start with a initial (1:) to begin building the list
04:01:08 <dons> and everything grows from that
04:01:13 <dons> > fix (1:)
04:01:14 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
04:01:21 <dons> i.e. 1: (1: (1: (1: (1:
04:01:25 <malebria> ok.
04:01:43 <dons> > fix (\d -> 1 : d)
04:01:44 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
04:01:52 <dons> > let ones = 1 : ones in ones
04:01:53 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
04:02:13 <dons> so since the list is built lazily, ones = 1 : ones works rather nicely
04:02:20 <dons> it builds a tiny little loop
04:02:34 <malebria> dons: These examples I got.
04:02:41 <malebria> dons: but the problem is scanl.
04:03:01 <malebria> > scanl (+) 1 []
04:03:02 <lambdabot>  [1]
04:03:19 <malebria> hum...
04:03:23 <dons> > ((1:) . (scanl (+) 1)) []
04:03:24 <lambdabot>  [1,1]
04:03:31 <malebria> hum...
04:03:32 <malebria> nice.
04:03:40 <dons> so almost there!
04:04:00 <dons> > let xs = ((1:) . (scanl (+) 1)) xs in xs
04:04:02 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
04:04:15 <dons> so the key is to get those first [1,1]
04:04:35 <malebria> hum...
04:04:43 <dons> (I know, this stuff rewires your brain for programming when you first start doing it:)
04:05:02 <malebria> dons: Yes, I'm used to haskell, but not this deep.
04:05:06 <dons> and then once we see the recursion, you add fix:
04:05:16 <dons> > fix (\xs -> ((1:) . (scanl (+) 1)) xs)
04:05:17 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
04:05:23 <dons> and then pointfree:
04:05:29 <malebria> I used to come here some time ago, with the nick marcot
04:05:38 <dons> > fix (((1:) . (scanl (+) 1)))
04:05:39 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
04:05:43 <dons> ah, marcot. yes. welcome back :)
04:05:46 <malebria> =D
04:05:57 <edi> > let fibs = 1 : scanl (+) 1 fibs in fibs
04:05:58 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
04:06:12 <edi> fix isn't at all needed since we support recursion this way, but well.
04:06:23 <dons> yeah, its just for fun
04:06:27 <edi> I only realized it after writing a fixpoint to go to the top of a tree :)
04:06:30 <dons> heh
04:06:45 <malebria> > scanl (+) 1 [1, 1]
04:06:46 <lambdabot>  [1,2,3]
04:07:02 <edi> `top'  http://darcs.haskell.org/~paolo/darcs/tao/ZipNtree.hs
04:07:02 <dons> > 1 : scanl (+) 1 [1, 1]
04:07:06 <lambdabot>  [1,1,2,3]
04:07:14 <dons> > 1 : scanl (+) 1 [1,1,2,3]
04:07:15 <lambdabot>  [1,1,2,3,5,8]
04:07:51 <edi> > iterate ((1:) . scanl (+) 1) [1]
04:07:52 <lambdabot>  [[1],[1,1,2],[1,1,2,3,5],[1,1,2,3,5,8,13],[1,1,2,3,5,8,13,21,34],[1,1,2,3,5,...
04:08:38 <ms_> > last $ iterate ((1:) . scanl (+) 1) [1]
04:08:40 <ms_> ;)
04:08:42 <lambdabot> Terminated
04:08:44 <dons> heh
04:09:34 <ms_> I like the zipWith version. Much more efficient than my version.
04:09:37 <ms_> > let fib = 0:1: [(fib !! (i-2)) + (fib !! (i-1))  |i <- [2..]] in take 100 fib
04:09:39 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
04:10:36 <malebria> > replicate 1
04:10:37 <lambdabot>  Add a type signature
04:10:47 <dons> :t replicate
04:10:48 <lambdabot> forall a. Int -> a -> [a]
04:10:58 <dons> > repeat 1
04:10:59 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
04:11:00 <Cale> > fix ((0:) . scanl (+) 1)
04:11:02 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
04:11:04 <malebria> dons: thanks.
04:11:23 <malebria> > scanl (+) 1 $ repeat 1
04:11:25 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
04:11:31 <malebria> hum...
04:11:56 <dons> Cale, I put this up, http://haskell.org/haskellwiki/The_Fibonacci_sequence
04:11:57 <lambdabot> Title: The Fibonacci sequence - HaskellWiki
04:12:01 <dons> if you know of some other fun ones
04:12:12 <malebria> I kind of got it..
04:12:29 <malebria> But it's still very complicated...
04:12:29 <malebria> =D
04:13:11 <robreim> when is it considered good haskell practice to use errors rather than something like a maybes for lookup failures? eg (!!) vs the type of something like lookup.
04:13:14 <dons> there's 2 or 3 things going on, so not complicated, I think. but the recursion messes with peoples brains for a while, until they stop trying to mentally unroll it
04:13:36 <dons> robreim: hmm, when you don't have a good default value?
04:13:40 <dons> so you must fail
04:14:00 <ms_> dons: would you not say it has anything to do with clarity of code?
04:14:18 <dons> the use of maybe v error?
04:14:31 <robreim> Hmm. I like the idea that maybes force the user to think about what happens when it fails. With errors it seems to open up the possibility of runtime errors.
04:14:45 <dons> yeah
04:15:14 <dons> but if you're just using:   maybe (error "failed") id (...)
04:15:25 <dons> well, that's still ok I guess :)
04:15:53 <ms_> say you were lazy when writing the code and have written functions that only pattern match on certain values of an ADT
04:16:07 <ms_> in practise, you *know* that the wrong values aren't going to appear
04:16:17 <ms_> but the way it's been written, the type system doesn't know that
04:16:20 <ms_> so ghc #
04:16:27 <ms_> oopps, ghc -Wall complains
04:16:35 <dons> error "can't happen" ?
04:16:43 <ms_> right.
04:16:50 <dons> even better, use a src located erro
04:16:54 <dons> ?where loch
04:16:55 <lambdabot> I know nothing about loch.
04:16:58 <earthy> error "shouldn't happen'
04:16:59 <dons> bah
04:17:02 <amiddelk> yes, I see those a lot (occurring at run-time ofc)
04:17:10 <earthy> it obvioulsy *can*, if the error is printed
04:17:13 <lightstep> yes, with your email so that others can tell you of that problem
04:17:22 <dons> > error "panic: the impossible happened"
04:17:23 <lambdabot>  Add a type signature
04:17:29 <dons> > error "panic: the impossible happened" :: ()
04:17:30 <lambdabot>  Exception: panic: the impossible happened
04:17:32 <ms_> right. but you could have put a filter on the call to the function
04:17:38 <dons> ?where+ loch http://www.cse.unsw.edu.au/~dons/loch.html
04:17:39 <lambdabot> Done.
04:17:45 <SamB_XP> dons: cheater!
04:17:55 <lightstep> how can i define a new signal in gtk2hs?
04:18:04 <ms_> or whatever. There really are cases where missing patterns can't cause a problem
04:18:14 <SamB_XP> ... in C?
04:18:20 <ms_> so should you just error or would you convert the whole lot to Maybe ?
04:18:25 <dons> ms_ yep, so the use of erroor there is fine.
04:18:28 <dons> I would just use error
04:18:29 <robreim> ok, so using a specific example, what might be the argument for using error rather than Maybe for (!!) ?
04:19:04 <SamB_XP> > fromJust Nothing
04:19:05 <lambdabot>  Add a type signature
04:19:09 <dons> its too easy to get the list length wrong? so handling it is a good idea.
04:19:09 <SamB_XP> > fromJust Nothing ()
04:19:11 <lambdabot>  Add a type signature
04:19:15 <dons> unless you have a strong guarantee
04:19:22 <SamB_XP> > fromJust Nothing :: ()
04:19:23 <lambdabot>  Exception: Maybe.fromJust: Nothing
04:19:33 <dons> and often you want to handle the index being too large, without failing
04:19:38 <SamB_XP> > [] !! 0
04:19:39 <lambdabot>  Add a type signature
04:19:41 <dons> (more often with things like lookup though)
04:19:44 <SamB_XP> > [] !! 0 :: ()
04:19:45 <lambdabot>  Exception: Prelude.(!!): index too large
04:19:47 <lisppaste2> metaperl pasted "a simple question about preconditions, when the precondition is not listed" at http://paste.lisp.org/display/32488
04:19:49 <ms_> ok. Really the type of the argument should change so that there's a witness index or something so that ghc doesn't moan about the missing patterns
04:20:04 <robreim> dons: sorry, was that a case for using maybe, or for using error?
04:20:48 <lightstep> metaperl, the syntax for Fact 1 is wrong
04:21:15 <metaperl> lightstep - it is straight from SJT I think...
04:21:22 <metaperl> lightstep - what is wrong with it?
04:21:26 <lightstep> since - isn't an identifier. (-) is.
04:21:28 <dons> robreim: it really depends on how likely/important the failure case is
04:21:43 <metaperl> oh,, my paste from PDF
04:21:48 <ms_> has anyone done work with octtrees in haskell?
04:21:51 * robreim nods.
04:22:00 <ms_> or quadtrees?
04:22:19 <robreim> So I suppose there's no real formal argument for one way or the other? It's just a kind of subjective preference for how you feel the lookup would best be handled?
04:23:28 <lightstep> metaperl, Name a is Named for any a, including as satisfying Movable
04:24:05 <metaperl> thanks
04:24:18 <robreim> I suppose if you take the maybe obsession too far you'll end up making div :: Integral a => a -> a -> Maybe a
04:24:36 <robreim> I'm just curious where I should be drawing the line.
04:24:38 <ms_> But, as we all know, /0 is \phi
04:24:40 <ms_> ;-)
04:25:00 <robreim> Maybes are totally a solution to / 0 :)
04:25:31 <dons> Nullity!
04:25:41 <ms_> that would make all your maths code monadic though and I'm not sure how well ghc would be able to optimise it out
04:25:57 <dons> the solution is in your hands: http://reddit.com/info/ty8s/comments/ctydx
04:25:59 <lambdabot> Title: Professor Comes Up With a Way to Divide by Zero (reddit.com)
04:26:52 <SamB_XP> how about we just say x/0 = -1?
04:27:01 <dons> I think I'd prefer pi
04:27:09 <dons> it'd be like a little surprise
04:27:10 <SamB_XP> heh
04:27:20 <ms_> mind you, apparently NaN and Inf are implemented in the Cell in a way which is not faithful to the IEEE floating point std. So there's clearly scope for variations on this one!
04:27:30 <dons> and fits nicely with e ^ pi i
04:28:57 <edi> o_0
04:29:45 <SamB_XP> ms_: so what did they do wrong?
04:30:36 <ms_> SamB_XP: err, well it's something like NaN is allowed to be a range of bit patterns in the IEEE std but the implementation on the Cell does'nt respect that. So it has extra values
04:31:10 <ms_> so consequently with std c-lib, if you printf certain values, they're "numbers" according to the cell, but the c-lib thinks they're all just NaN
04:31:39 <SamB_XP> eww
04:31:49 <ms_> I don't know whether it was done to increase the values that can be represented or just to save silicon
04:32:02 <lightstep> "The work has been proved consistent twice, by hand, by me, and has been checked at another university by computer."
04:32:22 <lightstep> he's twice as right!
04:32:51 <SamB_XP> twice as silly!
04:34:21 <lightstep> "If anyone doubts me I can hit them over the head with a computer that does it."
04:34:59 <SamB_XP> well, I could bash him over the head with a computer that sticks its tongue out! ;-P so there!
04:35:30 <Syzygy-> Are we back to the dear Dr. Anderson?
04:35:46 <Syzygy-> http://en.wikipedia.org/wiki/Wheel_theory
04:36:18 <Syzygy-> My beef isn't with whether it is correct. My beef is that he hasn't done his research properly and fails to acknowledge prior results.
04:39:56 <robreim> Huh... I thought the whole /0 thing was just a joke the journalists took too seriously?
04:40:16 <pejo> Syz, are you talking about the article that is linked there?
04:40:41 <goltrpoat> an awful lot of people seem to think it's an elaborate hoax
04:40:52 <SamB_XP> hmm
04:41:08 <SamB_XP> a hoax?
04:41:10 <SamB_XP> huh.
04:41:31 <SamB_XP> why would I sooner think "idiot! thats not the *point*!" than "hoax!"?
04:42:14 <robreim> Or maybe he's really managed to see through the matrix. I can just imagine an agent standing over him saying "Dr Anderson..."
04:42:16 <lightstep> did you read the interview?
04:42:23 <Syzygy-> I did.
04:42:47 <lightstep> he is too comical to be true
04:42:56 <goltrpoat> ive read the interview and watched the videos..  if it's not a hoax, it's phenomenally sad
04:43:03 <Syzygy-> He does have a point in that NaN doesn't really fit well into an algebraic structure. However, he comes off a bit too much like a buffoon who doesn't bother with research.
04:43:31 <Syzygy-> (which is a surprisingly bad vibe to give off in academics)
04:44:14 <SamB_XP> why is that surprisingly bad? or do you mean he wouldn't be an academic with vibes like that?
04:44:42 <goltrpoat> if we're going to put algebraic structures on floats, NaN is the least of your concerns though
04:45:04 <goltrpoat> non-commutativity and non-associativity would be higher on the priority list, methinks
04:46:18 <goltrpoat> pardon.. distributivity, not commutativity
04:47:10 <SamB_XP> yeah, I agree. I should dig out seminumerical algorithms sometime soon...
04:47:10 <lightstep> Syzygy-, his structure isn't a wheel. specifically, //-inf = inf
04:48:10 <Syzygy-> lightstep: Ah. Didn't check that much. Makes it even sillier - maybe worth calling a projective wheel. :)
04:48:16 <SamB_XP> WTH is a sphere?
04:48:29 <dons>  Cale wrote a rather nice response to the whole kufuffle
04:48:46 <dons> http://cale.yi.org/index.php/Open_letter_to_James_Anderson
04:48:48 <lambdabot> Title: Open letter to James Anderson - CaleWiki
04:49:01 <dons> #haskell rules the blarghosphere
04:49:19 <SamB_XP> in particular, the Riemann sphere...
04:50:04 <malebria> Buy guys.
04:50:15 <dons> buy socks!
04:51:11 * dons munches on weihnachts haselnusse
04:51:41 <goltrpoat> syzygy:  iirc, he takes the extended reals, adds an element off the line, calls it Phi, gives a multiplication table for +-inf and phi, and proceeds to show that 0^0 = Phi by way of cunning use of 1-1=0
04:51:57 <tom__> hey
04:52:06 <dons> hey tom__ how's the lambdas?
04:52:14 <tom__> doing fine :)
04:52:15 <goltrpoat> at which point he steps back, points at the board triumphantly, and proclaims that a "1200 year old problem has been solved"
04:52:22 <SamB_XP> goltrpoat: hmm, come to think of it, that is funny ;-)
04:52:30 <dons> hehe
04:52:33 <tom__> just wondered what the ! operator in haskell is
04:52:46 <SamB_XP> considering everyone who actually uses 0^0 says 0^0 = 1
04:53:12 <SamB_XP> tom__: array index
04:53:33 <tom__> i mean like what is the haskell alternative for not :)
04:53:43 <SamB_XP> oh ;-)
04:53:44 <SamB_XP> not
04:53:48 <goltrpoat> > not True
04:53:48 <SamB_XP> > not True
04:53:49 <lambdabot>  False
04:53:50 <lambdabot>  False
04:53:52 <SamB_XP> heh
04:53:54 <goltrpoat> heh
04:53:59 <tom__> is there no char for it?
04:54:03 <tom__> like ! ?
04:54:05 <SamB_XP> nope!
04:54:12 <tom__> ok
04:54:24 <dons> ?let (!) = not
04:54:25 <lambdabot> Defined.
04:54:37 <dons> > L.! True
04:54:38 <lambdabot>  Parse error
04:54:51 <dons> yeah, I don't like this whole L.* thing space anymore
04:55:06 <dons> > let (!) = not in !True
04:55:07 <lambdabot>  Parse error
04:55:21 <dons> oh, righ
04:55:23 <dons> t
04:55:29 <dons> > let (!) = not in (!) True
04:55:30 <lambdabot>  False
04:55:31 <dons> bah
04:56:30 <dons> ?users
04:56:31 <lambdabot> Maximum users seen in #haskell: 291, currently: 257 (88.3%), active: 26 (10.1%)
04:56:38 <norpan> hey
04:56:42 <norpan> ?users
04:56:42 <lambdabot> Maximum users seen in #haskell: 291, currently: 257 (88.3%), active: 26 (10.1%)
04:57:50 <fincher> I remember asking this question before, but I don't remember the answer: why isn't tail-recursion important in SML?
05:00:39 * SamB_XP >>= finals
05:00:52 <robreim> fincher: did you mean to ask that here or #SML?
05:00:58 <fincher> robreim: here.
05:01:08 <fincher> but I meant to say "Haskell" instead of SML :)
05:01:23 <dons> tail recursion is important to haskell, though
05:01:35 <dons> but laziness helps mitigate some issues
05:01:57 <dons> nonetheless, the ghc backend goes to great length to get proper tails calls out of the C backend
05:01:57 <robreim> Oh :) IIRC, how Cale explained it to me was that you can get tail recursion by forcing strictness. But often laziness is more efficient than tail recursion.
05:02:27 <dons> i.e. foldl' v foldr
05:02:28 <Cale> yeah, you generally want one or the other
05:03:21 <fincher> I'm guessing there's no foldr' ?
05:03:32 <robreim> Cale++ (that was my first question here and I didn't know I could give karma for your detailed answer back then)
05:03:35 <Cale> You want strict tail recursion (foldl') at most about 25% of the time, and you want lazy functions which immediately return a constructor almost the entire rest of the time
05:05:18 <robreim> 'night all
05:05:31 <Cale> 'night
05:05:37 <fincher> Cale: why the difference?
05:05:51 <fincher> Cale: i.e., can you provide an example of where you'd want one over the other?
05:06:14 <Cale> Sure
05:06:51 <Cale> You want strictness when you're collapsing a large data structure or number of values down to something which is atomic with respect to evaluation
05:07:02 <Cale> For example, adding up a list of numbers
05:07:09 <Cale> You can't partially evaluate the result
05:07:41 <flux__> couldn't the compiler be smart about it, and just think for a moment if the return value is composed of small parts of one big part :-)
05:07:58 <Cale> Well, to some extent it does.
05:08:55 <Cale> There's a strictness analyser which happens if optimisations are turned on
05:10:11 <Cale> In general though, it's hard to tell how you're going to use a particular function
05:10:19 <Syzygy-> > foldr' (+) [1,2,3,4]
05:10:20 <lambdabot>  Not in scope: `foldr''
05:10:28 <Syzygy-> ?type foldl'
05:10:29 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
05:10:33 <Syzygy-> ?type foldr'
05:10:35 <lambdabot> Not in scope: `foldr''
05:10:35 <Cale> There are a few cases where you'll have what looks like compound data but you want it evaluated all together anyway
05:11:16 <Cale> But most often, when you have compound data, partial evaluation will come in handy at some point along the way
05:11:20 <amiddelk> yep, but that's sometimes quite hard: what is the strictness of x in z b f g x = if b then f x else g x
05:12:17 <Cale> Right, it's a tough problem :)
05:12:38 <Cale> So usually it's best to be slightly explicit about it if it really matters to you.
05:13:02 <Cale> Using foldl' is usually a rather good way to get strict accumulation.
05:13:54 <Cale> You can also use seq by hand, but in most cases, places where you really want strictness actually boil down to accumulations which can be written with a little contortion as left folds.
05:14:45 <Cale> It can be handy if you're using another kind of data structure, like trees or some such, to write a strict fold over that structure.
05:17:41 <integral> @type foldl'
05:17:43 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
05:17:49 <integral> @type (foldl, foldl1)
05:17:51 <lambdabot> forall a b a1. ((a -> b -> a) -> a -> [b] -> a, (a1 -> a1 -> a1) -> [a1] -> a1)
05:19:03 <tom__> where is the paste thingy
05:19:11 <tom__> ?paste
05:19:12 <lambdabot> http://paste.lisp.org/new/haskell
05:19:14 <tom__> ah
05:20:45 <fincher> Cale: thanks for the info.
05:21:30 <tibbe> has it been an influx of haskell users lately?
05:21:51 <Cale> tibbe: Things have been growing steadily
05:22:01 <tibbe> Cale: :)
05:22:03 <Cale> So far it's been manageable :)
05:22:26 <Cale> I'm a little scared of popularising things faster than we can keep up with the beginners :)
05:22:29 <tibbe> that's beacuse I've been too busy with my thesis to overflood you guys with questions ;)
05:51:17 <nico> hi!
05:51:46 <lightstep> ?where mkcabal
05:51:48 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/mkcabal
05:52:56 <nico> I have a little problem with my haskell code
05:53:40 <nico> I donno if I'm on the right place to ask?
05:53:57 <lightstep> probably you are
05:54:55 <nico> druk :: PrologData -> [(Int, PrologData)] -> IO ()
05:54:55 <nico> druk (Var x) y =
05:54:55 <nico> 	do
05:54:55 <nico> 		if (compareVar (find_In_List (Var x) y) (Var x))
05:54:55 <nico> 			then (druk x [])
05:54:56 <nico> 			else 	(druk find_In_List y)
05:55:31 <nico> i get the following error : ERROR "opgave8.hs":23 - Syntax error in expression (unexpected `;', possibly due to bad layout)
05:56:24 <nico> find_In_List :: PrologData -> [(Int,PrologData)] -> PrologData
05:56:40 <lightstep> do you have tabs around that spot
05:56:41 <lightstep> ?
05:57:04 <Cale> hmm
05:57:18 <Cale> the layout as pasted looks fine, and the parens seem to match
05:57:22 <lightstep> dons, is there mkcabal for ghc6.4?
05:57:34 <Cale> lisppaste2: url
05:57:34 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/Haskell and enter your paste.
05:57:43 <Cale> could you paste more of the file there?
05:57:43 <pejo> nico, do you mean "druk find_In_List y" for that last else?
05:59:52 <nico> yea i think it must be (druk (find_In_List (Var x) y) y)
06:00:32 <lisppaste2> Cale pasted "this compiles" at http://paste.lisp.org/display/32492
06:00:57 <Cale> So we need more context :)
06:01:26 <Cale> probably, anyway
06:01:34 <Cale> I removed some unnecessary parens
06:01:38 <nico> i think i ve found it
06:01:38 <Cale> That's about it :)
06:01:57 <nico> it was the thing pejo said
06:02:04 <nico> thx
06:02:23 <Cale> hmm
06:02:30 <Cale> isn't that what you already had there?
06:02:37 <Cale> perhaps I'm half asleep :)
06:03:31 <Cale> oh, I see, there's an obvious type error there
06:03:42 <Cale> but not a layout problem
06:03:54 <nico> yeah exactly
06:04:09 <nico> the then was wrong eather
06:04:14 <Cale> I'm curious as to why the layout error happened
06:04:47 <Cale> Make sure you're not mixing tabs and spaces. Also, that can happen if you miss a closing paren in various cases.
06:06:01 <Cale> (In fact, it's a good idea to make sure never to write tab characters into Haskell source files -- have your editor convert them to spaces before saving)
06:07:31 <dons> lightstep: should just build on 6.4
06:07:34 <dons> its h98, afaik
06:07:48 <lightstep> i'll send you a patch soon
06:07:58 <dons> cool
06:07:59 <lightstep> (it's -fglasgow-exts)
06:08:07 <lightstep> how do i make a patch
06:08:08 <dons> ah, do I use pattern guards in there?
06:08:14 <dons> darcs record
06:08:16 <dons> darcs send
06:08:48 <lightstep> i get "failed to send mail"
06:08:50 <dons> what are you patching?
06:08:57 <dons> ah, maybe your mail isn't configured?
06:09:07 <pejo> dons, happen to know offhand if there is an easy way to extract ordinary diffs from darcs too?
06:09:07 <dons> so then: darcs send -o /tmp/dons.patch
06:09:09 <dons> and send me that file
06:09:12 <lightstep> the cabal file, and a syntax that 6.4 recognizes as TH
06:09:24 <fincher> smtp is a tremendously fragile transport for patches.
06:09:32 <dons> :) quite so
06:09:47 <dons> darcs push over ssh is a bit nicer
06:09:57 <dons> but i don't hand out ssh patches to just anyone ;)
06:10:01 <dons> s/logins/
06:10:06 <dons> ?users
06:10:07 <lambdabot> Maximum users seen in #haskell: 291, currently: 262 (90.0%), active: 26 (9.9%)
06:10:12 <dons> pejo: darcs changes -v ?
06:10:37 <dons> pejo: actually, I think there's a -u flag
06:10:40 <dons> for unified diffs
06:10:44 <ibid> pejo: darcs annotate -p patch_name
06:10:53 <ibid> pejo: optionally, specify -u for unified diff
06:11:35 <dons> ibid++
06:12:18 <pejo> ibid, does patch grok that format?
06:12:39 <dons> ah, this is interesting, http://jpmoresmau.blogspot.com/2006/12/adventures-in-haskell-parsec-magic.html
06:12:42 <lambdabot> Title: JP Moresmau's Programming Blog: Adventures in Haskell: the Parsec magic weapon, http://tinyurl.com/y4p7g3
06:12:47 <dons> pejo, if its a unified diff, I'd suspect so
06:12:53 <dons> you sending patches to cvs folk? :)
06:13:00 <dons> hey uebayasi !
06:13:28 <pejo> dons, I wouldn't say it's a unified diff by looking at it, but I'm not fluent in all the patch formats that are acceptable.
06:13:35 * dons sees patches arrive
06:13:39 <dons> lightstep++
06:13:40 <pejo> dons, if it was cvs I'd just cvs diff. :-)
06:13:49 <Syzygy-> @karma
06:13:49 <lambdabot> You have a karma of 0
06:13:53 <Syzygy-> o.O
06:13:58 <dons> oh, I assumed you kept things in darcs, and had to send them over to someone else
06:14:02 <dons> Syzygy-: oh that's weird
06:14:08 <Syzygy-> Nobody ever gives me karma?
06:14:11 <dons> hmm. could be a bug with - names?
06:14:17 <dons> Syzygy-: I'm sure I did yesterday, in fact
06:14:27 <dons> Syzygy-++
06:14:28 <pejo> dons, nods, exactly. Only the other end doesn't use darcs.
06:14:29 <Syzygy-> Heh. Yeah, then that really is weird.
06:14:30 <dons> @karma Syzygy-
06:14:31 <lambdabot> Syzygy- has a karma of 0
06:14:35 <dons> ah!
06:14:35 <Syzygy-> Oh bugger.
06:14:50 <Syzygy-> And you found the bug already?
06:14:50 <dons> @karma+ Syzygy-
06:14:51 <lambdabot> Syzygy-'s karma raised to 1.
06:15:01 <dons> probably a regex issue ;)
06:15:06 <Syzygy-> Right.
06:15:10 <dons> ah thanks lightstep
06:15:16 <dons> yes, silly TH, show.snd.version$c
06:15:48 <pejo> (I'll admit I'm not very comfortable with darcs, but I guess that is just a habit).
06:16:09 <Syzygy-> Yup.
06:16:36 <Syzygy-> dons: regex = mkRegex "^([a-zA-Z0-9_'+-]*[a-zA-Z0-9_'])(\\+\\+|--)($| )" doesn't allow for - in nick endings
06:16:56 * Syzygy- suggests regex = mkRegex "^([a-zA-Z0-9_'+-]*[a-zA-Z0-9_'+-])(\\+\\+|--)($| )"
06:17:56 * dons patches
06:18:00 * Syzygy- woots
06:18:02 <Syzygy-> dons++
06:18:32 <nico> my program compiles now but when I run it appently cant find the case
06:18:48 <dons> Syzygy-: its in the repo now.
06:18:59 <Syzygy-> Woot.
06:19:02 <dons> ?paste <-- nico, would you like to paste the error here?
06:19:02 <lambdabot> http://paste.lisp.org/new/haskell
06:19:09 <dons> and the program
06:19:25 <Syzygy-> Greping my logs, I seem to have missed two karma bumps in the past.
06:19:32 <nico> ok
06:19:38 * Syzygy- shrugs it off. At least now I'll get karma. :)
06:19:45 <dons> i'll add them back after the rebuild
06:19:55 <Syzygy-> Thanks!
06:21:26 <dons> I think this whole 'On syntax' comment fest on reddit is proof of Wadler's law :)
06:21:42 <Syzygy-> Wadler's law? About time spent on syntax vs other features?
06:22:22 <dons> yeah
06:22:35 <dons> syntax is the ultimate bikeshed topic for programmers
06:22:42 <lightstep> http://www.informatik.uni-kiel.de/~curry/listarchive/0017.html
06:22:44 <lambdabot> Title: Curry mailing list: Re: Curry
06:23:12 <dons> I didn't know there was a curry mailing list!
06:23:38 <lisppaste2> nico pasted "program haskel" at http://paste.lisp.org/display/32493
06:23:56 <dons> lightstep: thanks for finding that
06:24:03 <dons> is that the original reference, I wonder?
06:24:11 <dons> ?where+ wadlers_law http://www.informatik.uni-kiel.de/~curry/listarchive/0017.html
06:24:12 <lambdabot> Done.
06:24:15 <dons> actually, I think its older
06:24:21 <lightstep> me too. it's the earliest i could find the last time this came up
06:24:23 <dons> (there should really be a wikipedia page on this, if there isn't one)
06:24:39 <dons> i happen to have the haskell mailing list archives on my laptop
06:24:43 <dons> lets see if grep can find it
06:25:42 <dons> PS:  Wadler's Law:
06:25:42 <dons>         The emotional intensity of debate on a language feature
06:25:42 <dons>         increases as one moves down the following scale:
06:25:42 <dons>                 Semantics,
06:25:42 <dons>                 Syntax,
06:25:44 <dons>                 Lexical syntax,
06:25:47 <dons>                 Comments.
06:25:51 <dons>   * From: Philip Wadler <wadler@dcs.glasgow.ac.uk>
06:25:51 <dons>   * Date: Wed, 5 Feb 1992 09:14:00 +0000
06:26:14 <dons> http://www.cse.unsw.edu.au/~dons/haskell-1990-2006/msg00737.html
06:26:14 <lambdabot> Title: Literate comments
06:26:45 <dons> Cale: you edit wikipedia, right? Want to make a page for 'Wadler's law?' , using those two references :)
06:27:18 <Syzygy-> I wonder whether the naïve algorithm for group generation (multiply the next known element with all generators, throw away all you already have seen) can be done lazily. And whether this will make the complexity at least slightly better.
06:27:26 <Syzygy-> I wrote it tailrecursively on my blod a while ago.
06:27:41 <nico> can anybody see the problem in the program I pasted?
06:27:43 <dons> its pronounced 'blarrgh'
06:27:51 <dons> ah, nico, sorry, forgot!
06:27:51 <Syzygy-> I also wonder whether Shreier-Sims can be done lazily.
06:27:52 * dons looks
06:28:04 <nico> no prob :)
06:28:43 <nico> I thing that error is cause he cant find that case
06:28:51 <dons> nico, btw, ghci gives nicer error messages
06:28:53 <dons> and runs faster
06:28:55 <dons> ?where ghc
06:28:56 <lambdabot> http://haskell.org/ghc
06:29:39 <nico> ok I ll give it a try
06:30:04 <wolverian> dons, heh, I was just about to ask why you think $x is extraneous typing before you pasted wadler's law :)
06:31:04 <Syzygy-> wolverian: The simple answer is because it belongs to a syntax world where $x and @x (and possibly more) are used to denote different type data extracted from one single object.
06:31:24 <dons> wolverian: because it is only there to help the compiler, not the human
06:31:27 <Syzygy-> And using things like Haskell, the expected type'll get deduced anyway, giving more and better information to the compiler.
06:31:38 <dons> esp. considering type inference is pretty easy, and has been known since the 30s
06:31:46 <wolverian> dons, I think the idea is specifically to help the human.
06:31:57 <dons> ok, maybe :)
06:31:57 <wolverian> (at least, that is what I've understood from larry's comments.)
06:32:08 <dons> he's in a league of his own on that one though
06:32:22 <wolverian> I agree it is weird if the language only has one sigil (e.g. php)
06:32:22 <dons> ${@{%x{$x->[1]}} ?
06:32:47 <nnunley> Evil.
06:32:48 <dons> (x (h :: T) (f :: P -> T) :: Int)
06:32:48 * araujo looking for domain name suggestion!
06:32:49 <Syzygy-> dons: Missing right bracket
06:32:51 <earthy> type inference is pretty easy in *some* languages
06:32:57 <earthy> it's undecidable in others.
06:33:02 <dons> :)
06:33:14 <dons> earthy: and they're either really bad or really good languages, the undecidable ones
06:33:16 <wolverian> dons, I think you meant $x{ there :) anyway, yes, sigil variance is bad. perl5 is broken in that sense, but it's not (in my opinion) an inherent flaw in sigils, just the way perl5 uses them.
06:34:03 <earthy> um. I beg to differ. but then again, I was fed Barendregt's lambda cube in my second year
06:34:06 <nnunley> dons: I believe that that always evaluates to 1. provided that $x is a reference to an array.
06:34:14 * nnunley grins.
06:34:29 <earthy> (hm, lambdacubes, nourishing. :))
06:34:30 <dons> hehe. it was just supposed to be noise! maybe its legal too. ;)
06:34:42 <dons> earthy: part of every complete breakfast!
06:34:48 * Cale puts a couple of lambdacubes in his coffee
06:34:59 <wolverian> it's almost legal.
06:35:22 <wolverian> (the %h{ is a syntax error.)
06:35:24 <Cale> hmm, it appears to have turned the coffee into scala
06:35:40 <dons> heh
06:35:43 <nnunley> An array in scalar context in perl returns its size. %x{} returns a list of values matching the keys within. Or it used to.
06:35:55 <nnunley> Evil perl.
06:36:12 <wolverian> nnunley, @x{} you mean.
06:36:28 <dons> wouldn't be fun if perl had (.), and you had to annotate with sigls all its uses
06:36:29 <wolverian> in perl5, the sigil denotes the result of the expression.
06:36:33 <nnunley> I think older versions of perl 5.0 allowed the %{} syntax.
06:36:49 <wolverian> nnunley, oh. that's certainly possible.
06:37:17 <dons> @->$g  (($->@->@->$). $->@h
06:37:18 <lambdabot> Unknown command, try @list
06:37:20 <wolverian> so, perl6 just ignores all that and makes the sigil a part of the variable name.
06:37:26 <wolverian> so it no longer changes.
06:37:33 <Cale> Perl is a beautiful language in about the same way that English is a beautiful language. Whether it can actually be considered a good idea for a computer language to be beautiful in that particular way is debateable.
06:37:51 <wolverian> Cale, debatable. ;)
06:37:55 <Cale> yeah
06:38:08 <Cale> (typo)
06:38:26 <wolverian> anyway, I didn't want to say you're wrong, dons, I can certainly see your point. I just wanted to give you my pov that sigils _can_ be broken but aren't necessarily.
06:38:28 * nnunley grins.
06:39:18 <malebria> hello.
06:39:40 <dons> wolverian: but in a dream world I would not want to write them
06:40:02 <malebria> dons: still this subject. =D
06:40:04 <dons> i'd like to write pseudocode, and I've not seen a pseudocode language with $@ :)
06:40:07 <dons> malebria: hehe
06:40:24 * earthy has seen one language that was better suited to writing pseudocde than Haskell is
06:40:31 <earthy> code, even
06:40:36 <wolverian> dons, but is that just because they are ugly? :)
06:40:49 <earthy> it was imperative though
06:40:56 <earthy> but supported the use of 'refinements'
06:41:10 <lisppaste2> dons annotated #32493 with "nico" at http://paste.lisp.org/display/32493#1
06:41:18 <earthy> and refinements really read like pseudocode for imperative stuff
06:41:27 <dons> nico: I cleaned it up a bit, but I guess this is a homework problem?
06:41:36 <malebria> dons: what do you think about GHC's (x :: Int) <- ... syntax?
06:41:39 <dons> nico: it looked like there was a bug on the line of find_In_list that the error indcated
06:41:40 <earthy> otoh, the extra overhead that haskell imposes isn't all that great
06:41:58 <dons> malebria: i'm glad I don't need it for 97% of my code :)
06:42:05 <wolverian> I learned data structures with haskell. imperative pseudocode is terrible for demonstrating the algorithm.
06:42:05 <nico> yeah ghci gives that error
06:42:17 <malebria> dons: you don't use a lot of do notation?
06:42:17 <nico> ghci is much better
06:42:21 * araujo wonders if somebody here would have a nice suggestion for a lambdish domain name
06:43:05 <dons> nico, but you might want to look at the example interpreter here (at the bottom of the page. its pretty small, but might give some hints for layout and design, http://cgi.cse.unsw.edu.au/~dons/blog/2006/12/11#interpreters-with-reader-monads)
06:43:07 <lambdabot> Title: Haskell hacking, http://tinyurl.com/y7wvnq
06:43:31 <dons> nico, btw, when a missing case falls through, you need to look at what patterns you're matching on
06:43:31 <pjd> araujo: lamb.da doesn't seem to be taken
06:43:39 <dons> i think your bug was ((x,y) , ys)
06:43:44 <dons> instead of ((x,y) : ys)
06:43:54 <dons> i'm not sure why your code even typechecked though..
06:44:32 <araujo> pjd, hah, that looks sweet!
06:45:49 <nico> i ve found that one too but it still gives the same error about the non exhaustive patterns
06:46:26 <pjd> araujo: wait, da is a language code, not (apparently) a country code
06:46:31 <pjd> d'oh
06:46:35 <dons> nico, ok. so look at what pattern failed
06:46:43 <dons> you could even add a base case, to show you
06:46:52 <dons> i.e. f x = error (show x)
06:46:59 <dons> which will print out the failing case
06:47:10 <dons> nico: also, try :set -Wall
06:47:21 <dons> which will turn on all warnings (including missing patterns) in ghci
06:48:03 <araujo> pjd, :-P
06:49:40 <nico> nice
06:50:13 <araujo> mmm...
06:51:09 <earthy> ohkay.
06:51:18 <araujo> unsafePErformIO.org
06:51:22 <earthy> Install-Includes: is valid cabal as of which version?
06:51:29 <araujo> mmm....
06:52:04 <dons> hehe, ok, funniest comment on the whole syntax/reddit saga:
06:52:06 <dons> pet@quasar:~$ ./hsfib 100000 | wc -c
06:52:07 <dons> 20900
06:52:07 <dons> pet@quasar:~$ ./cfib | wc -c
06:52:07 <dons> 9
06:52:09 <dons> Hmmm, it seems to me that your C version doesn't work well
06:52:16 <dons> hehe
06:54:13 <earthy> ah. 1.1.6
06:54:31 <earthy> obviously we are in need of versioning of .cabal files
06:55:12 <earthy> (and as obviously I need to upgrade to 6.6 from 6.4.1)
06:55:23 <pjd> araujo: .io, OTOH, is a TLD
06:55:54 <dons> earthy: I think we do have versioning now
06:56:07 <earthy> versioning *of* the .cabal files?
06:56:17 <dons> well, at least that's been talked about
06:56:24 <dons> depends: Cabal 1.14
06:56:25 <dons> or such.
06:56:31 <dons> but maybe it didn't get committed/
06:56:46 <malebria> dons: I'm trying to use that script to call ghc, but's it's not working.
06:56:48 <araujo> pjd, oh, haha, i think we could come up with some interesting combinations with that domain :-)
06:56:48 <malebria> @paste
06:56:49 <lambdabot> http://paste.lisp.org/new/haskell
06:56:51 <earthy> I mean, 1.1 was backwards incompatible with 1.0, I can grok that
06:57:06 <earthy> err.. forwards incompatible
06:57:15 <earthy> but that 1.1.6 is forwards incompatible with 1.1.4...
06:57:19 <earthy> yuck
06:57:26 <lisppaste2> malebria pasted "haskell.sh" at http://paste.lisp.org/display/32498
06:58:01 <dons> oto-oto-oto: welcome to #haskell
06:58:56 <dons> > fix ((1:) . scanl (+) 1) -- have a free puzzle, oto-oto-oto :)
06:58:58 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
06:59:30 <pjd> araujo: how about λ as an IDN?
07:00:39 <malebria> dons: how can I use it without vim?
07:01:08 <nico> dons: I found my error
07:01:34 <dons> malebria: what do you mean? your haskell.sh program?
07:01:40 <dons> ah sorry
07:01:44 <dons> the typeof script?
07:01:46 <malebria> dons: yes, it's the script you've posted.
07:01:48 <malebria> yes.
07:01:49 <dons> ?where typeof
07:01:50 <lambdabot> I know nothing about typeof.
07:02:10 <dons> ?where+ typeof http://www.cse.unsw.edu.au/~dons/code/typeof/
07:02:11 <lambdabot> Done.
07:02:14 <dons> i wrote a new version in haskell
07:02:26 <dons> you can build that and use it from vim (or from the shell too, I guess)
07:02:32 <dons> the Readme has the instructions for how to use it
07:02:36 <nico> ik used find_In_List and find_In_list: such a stupid error :)
07:02:45 <malebria> dons: ok, thanks.
07:02:53 <dons> ibid: heh.
07:02:56 <earthy> hm. dons, mind if I swipe that and put it in the new set of vim support stuff I'm developing?
07:02:57 <dons> nico: heh
07:03:13 <dons> earthy: please do
07:03:23 <yip> @seen dcoutts
07:03:23 <lambdabot> dcoutts is in #ghc, #gentoo-haskell, #haskell.hac07, #haskell-overflow and #haskell. I don't know when dcoutts last spoke.
07:03:28 <nico> dons what editor do you use for haskel?
07:03:29 <yip> @seen dcoutts_
07:03:29 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell, #ghc, #haskell-overflow and #haskell.hac07. I don't know when dcoutts_ last spoke.
07:03:40 <dons> nico, vim, many here use emacs too
07:04:02 <dons> visual studio might be a good choice on windows these days, with the visual haskell plugin
07:04:06 <nico> does it has highlichts?
07:04:09 <dons> yeah
07:04:17 <dons> both vim and emacs do
07:04:25 <earthy> there's a manual missing for that typeof though. is it as in your blog post?
07:04:52 <dons> earthy: its in the readme file, which isn't showing up online
07:04:54 <earthy> there's even haskell highlighting for stuff like ConText
07:04:55 <dons> but is in the repo
07:04:59 <earthy> ah, thanks
07:05:12 <Syzygy-> Need to retry installing visual haskell again, and then file a bug report....
07:05:19 <dons> heh
07:06:22 <araujo> pjd, which name?
07:06:38 <pjd> ?
07:07:23 <glguy> Visual Haskell's biggest feature for me is the typing on hover
07:07:43 <dons> do you use it, glguy ?
07:07:47 <glguy> yeah
07:07:48 <nico> thx a lot guys! :)
07:07:54 <nico> bb
07:07:58 <dons> ciao!
07:08:18 <flux__> I imagine it's the same feature as ocaml has for emacs, and it indeed does rock (display the type of expression under cursor)
07:08:45 <dons> flux__: mmm. how hard would it be to port the ocaml stuff to haskell ?
07:08:54 <flux__> dons, that specific feature?
07:08:55 <dons> does it use any ocaml compiler magic interface underneath?
07:09:10 <flux__> dons, yes, the compiler provides a list of expression types with -dtypes
07:09:24 <dons> ah interesting.
07:09:27 <flux__> you can actually convert the code to a type-annotated version with a little ocaml program
07:09:45 <flux__> so each and every expression has its type expressed there.. like C on steroids :-)
07:09:53 <dons> right. so ghc has -ddump-types I think
07:10:08 <dons> we could grab that and play games
07:10:19 <flux__> there was some feature in ghc which provided the list for top-level definitions, but that covers everything then?
07:10:29 <dons> not sure.
07:10:36 <dons> we could get it with ghc-api though
07:10:44 <dons> now that its bundled with 6.6
07:11:13 <dons> wow, ross is doing a great job on the hard puzzles here, http://haskell.org/haskellwiki/99_Haskell_exercises
07:11:15 <lambdabot> Title: H-99: Ninety-Nine Haskell Problems - HaskellWiki
07:11:23 <flux__> -fdump-types dumps only top-level definitions
07:14:54 <glguy> ?lastlog #4
07:14:55 <lambdabot> Unknown command, try @list
07:14:57 <glguy> ?lastlog #3
07:14:57 <lambdabot> Unknown command, try @list
07:18:31 <yip> 'i'm not interested in strings'
07:19:46 <yuten> hello~~
07:20:11 <yuten> why it is reasonable thing to require three monad law?
07:21:38 <ski> if you first do two things : A, and then B ; and after that do C
07:21:58 <ski> then that ought to be same as first doing A, and then doing two things : B and then C
07:22:12 <ski> this is roughly one of the monad laws
07:23:54 <ski> do y <- do x <- <A>
07:24:10 <ski>            <B>
07:24:15 <ski>    <C>
07:24:22 <ski> should be same as
07:24:31 <ski> do x <- <A>
07:24:44 <ski>    do y <- <B>
07:24:51 <ski>       <C>
07:25:10 <ski> and since these should be same, we shorten this to
07:25:14 <ski> do x <- <A>
07:25:17 <ski>   y <- <B>
07:25:22 <ski>    <C>
07:25:31 <yuten> so making these laws is to make the computation sequential?
07:26:02 <yuten> because FL didn't have the specific sequential computing?
07:26:21 <ski> it makes sure that computation is "linear" in a sense .. it doesn't matter if you call a function, or if you copy the contents of the function in the call's place
07:26:41 <dons> yuten, this might clarify things, http://cale.yi.org/index.php/The_Monad_Laws
07:26:42 <lambdabot> Title: The Monad Laws - CaleWiki
07:27:01 <ski> note how above is similar to saying '(a * b) * c' is same as 'a * (b * c)', which we then shorten to 'a * b * c'
07:27:04 <Cale> wow, people are starting to recommend that to other people, I should clean it up
07:27:07 <malebria> dons: I can't run typeof.. =(
07:27:14 <malebria> typeof: user error (Pattern match failure in do expression at Typeof.hs:7:4-9)
07:27:22 <Cale> I originally intended it as a quick reply to a message on reddit
07:27:34 <dons> malebria: you give it a file name as an argument
07:27:47 <dons> and a top level name to stdin
07:27:55 <dons> (check the readme file for how to use it from vim)
07:28:12 <glguy> ?hoogle isRight
07:28:13 <lambdabot> No matches found
07:28:36 <dons> malebria: $ typeof A.hs
07:28:37 <dons> druk
07:28:37 <dons> druk :: PrologData -> [(Int, PrologData)] -> IO ()
07:28:37 <dons> druk
07:28:55 <dons> so the argument is a file name, and you type in the identifier who's type you want
07:28:57 <yip> cale automagically wakes up on mention of calewiki? :o
07:29:10 <Cale> I wake up on mention of my name.
07:29:26 <Cale> cale.yi.org has my name in it, so I get alerted :)
07:29:26 <dons> Cale: maybe it should go on haskell.org ?
07:29:34 <malebria> dons: hum, nice.
07:29:41 <Syzygy-> Hehe
07:29:58 <Cale> hmm, if people really like it :) I don't think I'd structure it quite the way I had if it was intended as an article.
07:30:01 <dons> Syzygy-: you want to write an article on the monad laws, from Moggi's perspective?
07:30:11 <Syzygy-> Moggi?
07:30:12 <lisppaste2> glguy pasted "worthwhile alternate solution to problem 96?" at http://paste.lisp.org/display/32501
07:30:22 <dons> oh, I thought all your maths guys were into moggi, like sigfpe ;)
07:30:30 <Syzygy-> I have no idea what Moggi is.
07:30:35 <dons> (Moggi is Mr. Monad)
07:30:35 <earthy> Eugenio Moggi
07:31:20 <Syzygy-> Oh .. well .. never had heard of him before.
07:31:20 <dons> Syzygy-: http://www.disi.unige.it/person/MoggiE/ftp/ic91.ps.gz
07:31:23 <earthy> 'Notions of computation and monads'
07:31:25 <dons> Notions of computation and monads
07:31:26 <dons>     Eugenio Moggi. Information and Computation, 93(1):55-92, July 1991 ( Cited by 649)
07:31:48 <Syzygy-> I was thinking about writing about monads and operads - have started a blogpost on that - to connect with some stuff about M-algebras and M-operads I heard at a workshop a while ago.
07:32:27 * edi ponders Monads and I-Ching.
07:32:29 <dons> some of the monad theory stuff is here, http://haskell.org/haskellwiki/Research_papers/Monads_and_arrows#Monad_theory
07:32:31 <lambdabot> Title: Research papers/Monads and arrows - HaskellWiki, http://tinyurl.com/fgd83
07:32:39 <dons> if you want to come at it from the categorical side of things
07:33:31 <glguy> dons: do you think that using Parsec on that problem is worth posting (I'm not sure if using libraries are in teh spirit of the 99 questions)
07:34:02 <dons> glguy: sure. if its a solution
07:34:07 <dons> parsec is nice :)
07:35:28 <lightstep> cabal tells me it cannot satisfy dependency gtk-any, but i have gtk-0.9.10.2 installed. is it using ghc-pkg incorrectly
07:35:29 <lightstep> ?
07:38:36 <Tanuk-> Is anyone aware of a lib for finding out the amount of free space of a storage device?
07:41:25 <lightstep> oh, it wanted --user, since it's installed locally
07:43:40 <dons> Cale, did you see this: http://programming.reddit.com/info/utqb/comments/cuw9w  :D
07:43:42 <lambdabot> Title: Ask Reddit: Why do so many reddit users hate java? (reddit.com)
07:43:54 <dons> Tanuk-: a haskell library?
07:43:54 <Cale> dons: yeah
07:44:04 <dons> (the comment by nostrademons ?)
07:44:06 <Tanuk-> dons: Yes.
07:44:12 <Cale> dons: look at all my posts on that article
07:44:18 <dons> Tanuk-: I don't know of such a library.
07:44:23 <dons> Cale: yeah, I saw them :)
07:44:39 <dons> Tanuk-: do you hvae a C library for this? you could bind to that, or just call 'du'
07:45:35 <Cale> er, not that article...
07:45:58 <pejo> dons, you mean "df"?
07:46:34 <Cale> oh, no, it really was that article after all, for some reason my browser wasn't showing my comments for a moment
07:46:52 <dons> pejo: ah yes :)
07:46:57 <Tanuk-> I'm a newbie, and for this thing I'm planning, I'd rather not learn C bindings (unless it's reeally easy). Parsing df output is one possibility, but I don't know...
07:47:13 <dons> Tanuk-: do you know of a C library for this? I don't
07:47:27 <dons> I think, as a newbie, grabbing df output would be easier
07:47:32 <pejo> Parsing output from df is for sure not very portable, unfortunately.
07:47:36 <dons> otherwise, look into how df is written
07:48:39 <edi> Anybody knows if HXT will just barf at an XML file which doesn't pass the W3C validation, or will it let me extract informations from the file even if it contains errors?
07:48:41 <Tanuk-> Ok, so there is no such Haskell lib, that's pretty much I wanted to know. I think I'll drop the feature that needs it.
07:48:45 <allbery_b> unfortunately, it's all nonportable.
07:49:36 <Baughn> Tanuk-: There isn't a /lib/ required. Let's see..
07:49:39 <allbery_b> there are at least 4 different "standard" APIs for statfs(), and then there's all the systems which have their own things that do almost the same thing, and then the ones that require you to sync, open the fs read-only, and read the superblock
07:50:19 <Baughn> ..yep, that's the one I was about to suggest. Oh dear.
07:50:49 <allbery_b> parsing df output, as horrid as it is, is the easiest and most portable solution.  which says something.  :/
07:51:53 <dons> Tanuk-: it was a good question :)
07:52:17 <Tanuk-> dons: Thank you :)
08:03:09 <earthy> hm. I know too little vim
08:03:47 <ski> :q
08:04:22 * ski yesterday learned ':wq'
08:04:35 <earthy> which is equal to :x
08:04:36 <glguy> http://img.hetemeel.com/hahashow.php?headline=I'm%20programming%20in&text=see%20sharp%20to%20point%20whoa
08:04:39 <lambdabot> http://tinyurl.com/ylcwyy
08:05:09 <glguy> ?fptools Data.Graph
08:05:09 <lambdabot> http://darcs.haskell.org/packages/base/Data/Graph.hs
08:05:17 <glguy> ?docs Data.Graph
08:05:17 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Graph.html
08:07:50 <glguy> > product [1..14]
08:07:51 <lambdabot>  87178291200
08:08:15 <glguy> hmm, 87 billion.. wonder if that will take long to brute force :)
08:10:42 <xs> is there anything other than ghc profiling to analyse a space leak?
08:19:05 <lispy> anyone know what's up with the Hugs98 .NET FFI junk?
08:19:45 <lispy> i added it to the "wanted" libraries list because i think it's defunct
08:19:57 <lispy> well, and i want it for GHC instead of hugs
08:19:58 <therp> lispy: I hope you don't mind that I spamed you with my liskell paper
08:20:31 <dylan> liskell?
08:20:47 <therp> Lisp + Haskell = Liskell
08:21:32 <dylan> haskell with lisp syntax or haskell with lisp semantics?
08:21:37 <therp> first one
08:21:49 <dylan> interesting.
08:22:04 <dylan> do-notation would be a macro, no?
08:22:06 <lispy> therp: that's fine, i hope you don't mind that i won't have time to read it for a while :)
08:22:12 <therp> dylan: right
08:22:18 <therp> lispy: ah ok :) no prob.
08:22:24 <dylan> how would typing work for macros?
08:23:10 <lispy> therp: what type of conference did you submit to?
08:23:19 <lispy> therp: the name is unfamiliar to me
08:23:32 <therp> dylan: well, not very efficiently. macros are transforming parse trees, and therefore are just functions from ParseTree -> ParseTree. there is no guarantee that a macro will produce forking meaningful code (unbound vars/functions, non existant data constructors etc.)
08:23:42 <therp> lispy: ILC07=international lisp conference
08:24:16 <lispy> neat
08:24:20 <therp> dylan: also macros are run before type checking, as macros are operating purely on the syntactic structure
08:24:55 <therp> dylan http://clemens.endorphin.org/LskVsLisp.html
08:24:57 <lambdabot> Title: Liskell versus Lisp
08:25:21 <therp> I should really start blogging about it.
08:26:14 <therp> nah, but I'm obsessed with putting out a ready-for-production version of a hacked GHC..
08:27:48 <pejo> therp, is there massive surgery inovlved to get ghc to do what you want?
08:28:04 <therp> pejo: hm, about 1500 lines of code
08:28:16 <earthy> hm. interesting
08:29:47 <therp> pejo: but yes, I want to lift a few restrictions to meta-programming.. module X is being compiled, but uses code from module X while being compiled..
08:30:14 <therp> (at compile-time)
08:35:48 <chessguy> ok, so now the question becomes: how do i distract myself from haskell long enough to study for finals?
08:36:46 <earthy> gotcha.
08:36:59 <integral> Stop paying your electricity and phone bills.
08:37:12 <earthy> chessguy: self discipline.
08:38:44 <chessguy> earthy, bah. that's no fun
08:39:21 <Cale> Get addicted to playing go instead?
08:39:33 <pjd> chessguy: write a program to budget and keep track of how much time you spend on Haskell and other activities
08:39:38 <Cale> It won't help with the finals, but it might distract you from Haskell for a bit
08:40:05 <chessguy> Cale, nah. then i'll just start thinking about how to write Go AI in haskell
08:40:16 <dylan> pjd: that sounds like something I'd do. XD
08:40:29 <Cale> Writing Go AI is mostly kind of a lost cause at the moment anyway.
08:41:02 <Cale> It's much less satisfying than chess AI, since even the best Go AI programs suck.
08:41:22 <earthy> hm. choices choices choices.
08:41:23 <therp> cale: I would consider it a great challenge :
08:41:27 <LordBrain> that meanst he bar isnt high
08:41:27 <therp> :)
08:41:27 <Cale> hehe :)
08:41:31 <earthy> am I going to require vim 7 for my scripts or not?
08:41:44 <Cale> LordBrain: this isn't because people haven't tried
08:42:15 <LordBrain> maybe go strategy is just more complex than chess
08:42:47 <therp> but gnugo still beats me really hard. I conquered it only once with +20 points for me, but that was with an ancient version.
08:43:08 <LordBrain> i dont even know how to play go
08:43:36 <therp> ha :) there are just like 9 rules or something. first rule, "there are two players :)".. others similarly simple
08:43:58 <chessguy> heh. it's hard to even figure out whether a go game is over or not
08:44:07 <malebri1> dons: really nice your articles.
08:44:54 <Cale> Without giving it a massive handicap, I can crush gnugo really badly.
08:45:05 <malebri1> dons: but that example on the end of your planet.haskell.org last article is what makes a lot of people give up about using haskell.
08:45:10 <Cale> I either force it to resign or win by something like 60-80 points.
08:45:28 <therp> cale: you can? you are my hero. what's your kyu/dan rating?
08:45:45 <malebri1> dons: when haskell is obscure, it's really obscure, even more than C nad others...
08:45:48 <Cale> I'm somewhere in the single digit kyus
08:45:58 <Cale> For some reason it gives off this emotion of being blind and angry.
08:46:21 <LordBrain> which example malebri1 ?
08:46:28 <Cale> Unwilling to accept mistakes that it's made. (Of course, it just can't see them at all.)
08:46:32 <therp> cale: my best rating ever was 13 kyu. but I think that was wrong :) .. also by european standards..
08:46:40 <LordBrain> in the "Haskell Hacking" article?
08:46:44 <malebri1> LordBrain: http://planet.debian.org/ The last example of the first article.
08:46:48 <lambdabot> Title: Planet Debian
08:46:50 <LordBrain> oh
08:47:24 <LordBrain> First Article? you mean first of dons's?  "More On Syntax" ?
08:47:26 <Cale> chessguy: indeed, it really is hard for a computer to determine when it's done
08:48:14 <edwinb> someone turned up at our go club the other day with his computer program; I was impressed with it.
08:48:20 <chessguy> eh? the first article is about firmware?
08:48:27 <edwinb> He's never made it availble but it played at about 10kyu
08:48:40 <Cale> 10k is not bad
08:48:52 <Cale> How well does he play himself?
08:49:13 <edwinb> 3-4k maybe
08:49:48 <malebri1> LordBrain: yes.
08:50:21 <Cale> It would be interesting to know if a go program ever beat its own creator.
08:50:52 <therp> how is this principle called that only by accident an entity can create another entity that is more intelligent than its creator?
08:50:55 <Cale> I'd be willing to believe it for 9x9 go, perhaps.
08:51:35 <chessguy> it certainly happens in chess. it's very common for a chess engine to quickly surpass the ability of its creator
08:51:54 <edwinb> I'm quite sure I could write a chess program that could beat me ;)
08:51:59 <edwinb> but just playing random moves would achieve that
08:52:15 <therp> haha :)
08:52:24 <chessguy> well, most people who write chess programs are tournament players
08:52:25 <Cale> 19x19 is another matter entirely. It's genuinely hard to construct a go-playing program which plays even at the lower end of the intermediate level.
08:53:23 <Cale> I haven't played enough chess to be the least bit good at it.
08:53:42 <chessguy> I haven't played enough go to be the least bit good at it.
08:54:01 <Cale> When I played a few games with my aunt a while back, I started to get some idea of the strategy, but lacked any tactical ability whatsoever.
08:54:48 <chessguy> hmm, strategy is way harder than tactics
08:54:49 <Cale> I know a few things about pawn structure and such, but generally don't have much of a toolbox when it comes to setting particular things up.
08:55:18 <Cale> There's a good amount of strategy which transfers directly from go.
08:55:30 <Cale> For example, the idea of sente is genuinely useful.
08:55:33 <LordBrain> from go to chess?
08:55:37 <Cale> yeah
08:56:02 <Cale> It's mostly stuff which applies to any game of that sort.
08:56:21 <edwinb> chess players I've taught go generally get reasonably good pretty quickly
08:57:09 <Cale> Sente, in case anyone doesn't know what that means, is the idea that you should always play a move which forces your opponent to move in some way, it's never good enough to make a move which sets something up but doesn't force an immediate response.
08:57:35 <Cale> A player is said to have sente if they are in a position to force their opponent's next move.
08:57:50 <pjd> "sente" ~= "initiative"
08:57:54 <Cale> yes
08:58:19 <pjd> <Cale> For some reason it gives off this emotion of being blind and angry.
08:58:31 <pjd> that's as good a summary of the spirit of the computer as i've ever seen
08:59:13 <chessguy> Cale, it's called initiative in chess.
08:59:21 <Cale> right
09:00:42 <Cale> Have you played shogi?
09:01:05 <chessguy> not really
09:01:21 <Cale> I haven't really either, but it looks quite interesting
09:01:36 <chessguy> well, it has more in common with chess than Go
09:01:47 <Cale> I rather like the idea of being able to place a captured opponent's piece as a move.
09:02:11 <chessguy> you should try bughouse or crazyhouse
09:03:01 <Cale> placement increases the width of the game tree enormously. I wonder how good computer shogi players are.
09:03:33 <Cale> ah, apparently they're rather good
09:03:39 <Cale> Amateur 5-dan.
09:03:46 <chessguy> really? that's surprising
09:05:07 <edwinb> I'd have guessed they'd do better than go because board evaluation is easier
09:05:36 <pbx> As a non-Haskell programmer, I was driven by that ever-present Haskell Quicksort example to try adapting it to Python. It's only, like 25% longer and 75% uglier!
09:05:49 <Cale> hehe
09:06:04 <chessguy> hehe
09:06:28 <Cale> Python's not a bad language as far as imperative languages go.
09:06:38 <pbx> Cale: Agreed, it could have been worse  :)
09:06:40 <pbx> http://dpaste.com/hold/3767/
09:06:46 <Vq^> thats pretty good score anyway :)
09:07:22 * pjd has never understood the point of doing quicksort on a linked list
09:07:39 <chessguy> doesn't  python have some functional aspects to it?
09:07:55 <Cale> yeah, it does, it's just that most programmers don't use it that way
09:08:03 <Cale> and the lambda is a little broken iirc.
09:08:31 <pejo> Wasn't there a lot of noise about Guido removing map and some other things from Python version x.y?
09:08:38 <Cale> yeah
09:09:06 <pjd> Cale: a def works fine, though
09:09:25 <Cale> that's not the same
09:09:54 <Cale> also, I really dislike the choice of 'lambda' or 'function' for introducing a lambda, because that's way too much syntactic overhead in lots of cases
09:10:02 <pjd> pejo: "removing" as in "moving out of the builtins and into the standard library"
09:10:15 <LordBrain> you would rather \?
09:10:25 <Cale> Yeah, \ is certainly better
09:10:30 <LordBrain> me too
09:10:30 <Cale> You want something short
09:10:51 <pjd> Cale: aside from syntax, it's the same
09:10:57 * glguy posts a brute force solution to the Von Koch problem on the 99-problems... (do I need to focus on inteligent algorithms over brute force?)
09:11:03 <emu> when you run it through lhs2tex, does it convert \ to \lambda? =)
09:11:08 <Cale> Because there are lots of cases where you want lambda where 'lambda' will be a large percentage of the characters you're going to type.
09:11:39 <pjd> Python's lambda is a bit of a misnomer; it should have been called "convenient-inline-expr" instead
09:11:56 <pjd> the name is a bit of a historical accident that got stuck
09:12:05 <emu> cale, i had a question about your MonadNondet code
09:12:13 <Cale> emu: sure, it's not exactly my code
09:12:15 <emu> i was poking around with it yesterday
09:12:17 <emu> yea, i saw it elsewhere
09:12:18 <Cale> but I've used it :)
09:12:28 <glguy> Cale seems to get credit for a lot of stuff around here
09:12:31 <glguy> (=
09:12:50 <Cale> I'm usually quite clear about what is and isn't mine :)
09:12:55 <lisppaste2> emu pasted "nondet" at http://paste.lisp.org/display/32515
09:13:04 <LordBrain> whenever i google 99 problems i get hits for a band by that name
09:13:05 <glguy> Cale: I'm not accusing you of any wrong-doing q-:
09:13:29 <emu> you posed it as a drop-in replacement for the list monad, kinda.  so i decided to see how they were similar.
09:13:46 <emu> here i have (nondet foo) == bar
09:14:01 <glguy> MonadNondet is more efficient for backtracking when compiling with optimizations (i believe)
09:14:03 <emu> i got confused over the semantics of 'option'
09:14:26 <glguy> a <- [1,2,3] -- list code,    a <- option [1,2,3]   -- MonadNondet code
09:14:27 <Syzygy-> Right. Time to go home, shower, and don my tuxedo for the Winter Ball.
09:14:29 <Cale> option is the identity map on lists
09:14:36 <emu> that's what i'd think, but they acted differently
09:14:47 <emu> if i did: runNondet foo, i'd only get 1 thing
09:14:55 <emu> (the first option)
09:15:05 <Cale> oh, that's because that's what runNondet does
09:15:09 <glguy> what if you said: guard (a /= 1)
09:15:29 <emu> yea runNondet just returns the first result
09:15:36 <Syzygy-> > do a <- [1,2,3]; guard (a /= 1); return a;
09:15:37 <emu> that seemed less than useful. but maybe i'm not using it right
09:15:44 <lambdabot>  [2,3]
09:15:51 <Syzygy-> > do a <- [1,2,3]; guard (a /= 2); return a;
09:15:53 <lambdabot>  [1,3]
09:15:56 <Syzygy-> Neato!
09:15:57 <Syzygy-> :)
09:15:59 <Cale> emu: well, it's for the usual case where one result is good enough
09:16:00 <ptolomy> say, is there a good reason that the new spiffy Regex libraries don't come with a regex replace function?
09:16:08 <edi> Syzygy-: Winter Ball, that's impressive!
09:16:13 <Cale> foldNondet handles the rest of the cases
09:16:25 <ptolomy> dons: My simple bytestring k-nucleotide has been submitted to the shootout.
09:16:29 <Syzygy-> edi: It's a student ball, but still...
09:16:48 <edi> Syzygy-: have fun (:
09:17:04 <Syzygy-> I will, most probably, be the highest dressed at the party though. Most students here have no dress sense. Almost noone owns a tux!
09:17:42 <emu> Cale: basically, i wrote a "sorting" function which takes a list of items and each one has a (lower,upper) bound.  the function generates permutations of the sorted list where items could exchange places if they overlap in bounds.  i was using this to generate a search space to evaluate the various orderings, using the list monad.
09:17:44 <glguy> Most people don't "own" tuxes, they rent them
09:18:31 <emu> i was poking around haskell.org yesterday to see if i could find a better monad
09:18:35 <LordBrain> classical musicians own tuxes
09:18:38 <ptolomy> I wrote my own regex-based bytestring-specific replacement function, but I feel like I shouldn't have to.
09:18:47 <glguy> LordBrain: ... most people aren't classical musicians! :)
09:18:52 <ptolomy> LordBrain: Yep. Swhy I have 3.
09:18:58 <Cale> emu: well, if you're concerned with the complete list of results, then yeah, use foldNondet and turn the thing back into a list
09:19:02 <Syzygy-> glguy: I bought one because the Ball culture at the  Stockholm student clubs was quite tux-based...
09:19:11 <Syzygy-> So I own one. And since I do, I'm entitled to snark about it. :)
09:19:22 <Cale> emu: but often you're just trying to find one acceptable solution to a problem, and don't care how many there are
09:19:25 <Syzygy-> (but now, I'm leaving Seeya)
09:19:32 <Cale> which is what runNondet does.
09:19:52 <emu> i see. i think i need to stay in the monad when evaluating the generated solutions.
09:20:09 <emu> then runNondet would make sense, as the first well-evaluated solution
09:20:24 <Cale> yeah
09:20:27 <glguy> emu: you use guard to pick and chose which paths to go down
09:20:50 <glguy> or at least *I* do (=
09:22:02 <Cale> HXT almost makes me feel like finding a web application of some kind to write.
09:22:48 <vincenz> @yow
09:22:49 <lambdabot> Half a mind is a terrible thing to waste!
09:22:52 <Cale> I'm surprised at some of the omissions in the arrow libraries at present though. I found a couple of useful combinators which don't seem to be there right away.
09:24:22 <glguy> Cale: do you know where the official, or latest version of MonadNondet lives?
09:24:37 <Cale> there is no official version
09:24:45 <Cale> On the wiki though
09:24:51 <glguy> kk
09:25:31 <Cale> In fact, it appears that the only occurrence on the new wiki is in my Sudoku solver. That's a bit of a shame.
09:25:39 <emu> that's how i found it
09:25:52 <Cale> On the old wiki, it had its own page.
09:27:53 <glguy> Why does MonadNondet end up running faster?
09:28:07 <ptolomy> hm. This weekend I plan on beginning research for my wiki Article: "Down 'n Dirty: An Adventure in text processing with ByteString, Regex.Base, and Milkshakes."
09:28:42 <emu> i'm curious what optimization helps it too, because, i don't generally compile with -O. too slow.
09:28:50 <chessguy> Milkshakes?
09:28:57 <emu> milkshakes as monads?
09:29:09 <glguy> MonadNondet kills Visual Haskell
09:29:12 <glguy> so that's pretty sweet
09:29:17 <ptolomy> Eh. I like milkshakes.
09:29:29 <ptolomy> And I wanted a third item.
09:29:36 <emu> isn't visual haskell just hooked up to ghc?
09:29:36 <ptolomy> The title is subject to change. :)
09:30:01 <glguy> emu: yeah, but there is glue betweenthe two
09:30:33 <dcoutts__> @yarr
09:30:41 <dcoutts__> hia SyntaxNinja
09:30:46 <lambdabot> Eat maggoty hardtack, ye unkempt, jenny frequentin', son of a gun.
09:33:05 <ptolomy> I think making efficient non-trivial string processing without resorting to ugliness accessable is an important step to revealing the practicality of haskell.
09:33:22 <Trevion> ptolomy, what's wrong with the ByteString libraries for that purpose?
09:34:03 <PaulAJ> I want a Lambda Revolution tee-shirt
09:34:18 * Trevion chuckles
09:34:19 <SyntaxNinja> hey dcoutts__
09:34:19 <ptolomy> Trevion: Nothing, really. I love ByteString. However, my text processing background is all perl/ruby/hardcore regex matching and replacing. The new efficient regex libraries work on ByteString, but it is non-obvious.
09:34:50 <PaulAJ> I'm thinking, a raised fist on the front, clutching a lambda, with the caption "Long live the Lambda Revolution"
09:34:58 <dcoutts__> Trevion: we still need a decent parser for ByteString
09:35:09 <ndm> dcoutts__, i'm working on it...
09:35:15 <dcoutts__> ndm: oh yes?
09:35:24 <PaulAJ> And on the back "The Lambda Revolution will be Blogged\nwww.lambdatheultimate.com"
09:35:32 <ndm> dcoutts__, http://www-users.cs.york.ac.uk/~ndm/projects/parsing.php
09:35:35 <lambdabot> Title: Neil Mitchell - Parsing
09:35:56 <ndm> dcoutts__, [Char] and ByteString and Lazy ByteString are all supported
09:36:09 <Trevion> I had an idea to port Frisby to ByteStrings, but never really got started on it.
09:36:23 <ndm> ndm parsers are the only sensible way forward for parsing!
09:36:25 <Igloo> dcoutts__: Shouldn't it be almost as simple as twiddling imports on a String parser?
09:37:08 <pjd> PaulAJ: be sure not to color it pink, or people might get the wrong idea
09:37:12 <ptolomy> @google Frisby
09:37:15 <lambdabot> http://www.frisbytire.com/
09:37:15 <lambdabot> Title: Frisby Tire Co.
09:37:25 <ptolomy> Well, that was predictable.
09:37:37 <PaulAJ> I was thinking of black on a red ground.
09:38:10 <dcoutts__> Igloo: I think parsec makes more use of the [a] rep/behaviour.
09:38:14 <Trevion> ptolomy: http://repetae.net/john/computer/frisby/
09:38:26 <ptolomy> Trevion: Thanks. :)
09:38:29 <dcoutts__> Igloo: at least people seem to have had a hard time porting it
09:38:38 <Igloo> dcoutts__: rep?
09:38:40 <dcoutts__> ndm: is this the packrat thing?
09:38:57 <ndm> dcoutts__, no, much more efficient
09:39:02 <ndm> and much more expressive
09:39:13 <dcoutts__> Igloo: well also parsec is generalised over lists of arbitrary tokens
09:39:28 <dcoutts__> ndm: sounds tasty
09:39:29 <Igloo> Ah, right
09:40:12 <ndm> dcoutts__, i think it is the future of parsing, but i've been wrong before and will be again, so no guarantees
09:40:35 <ndm> dcoutts__, plus requires about a year of work from me to get it to the completed stage, which will require someone paying my food for a year...
09:40:49 <dcoutts__> ndm: ah I see :-)
09:42:09 <ndm> but if anyone does have a way to fund my food for a year, i'd really like to do it - i think its a bigger technology than any of my other stuff - since it works with C, Java, Haskell etc.
09:42:42 <ndm> and i think it would kill yacc/lex/happy/alex, i hope
09:43:10 <Igloo> Convince EPSRC you're right, then  :-)
09:43:44 <ndm> Igloo: how do i go about doing that? doesn't it involve convincing 3 referees that despite the fact that I think the whole world is wrong, and no one agrees with me, that i'm actually right? sounds hard...
09:43:48 <astrolabe> heh.  who said that c++ is a twisted parody of a language?
09:44:10 <emu> i think everyone except bjarne.
09:44:13 <Igloo> Hey, I never said it would be easy
09:44:37 <norpan> bjarne said that "there are languages that people complain about, and then there are languages that people don't use"
09:44:39 <ndm> I know, would be much easier if i just wanted to extend the type system in some directoin...
09:44:42 <norpan> or something like that :)
09:44:44 <Igloo> But if no-one agrees with you then you're going to have a hard time getting someone to fund it  :-)
09:45:03 <ndm> yes, but if everyone is wrong, then how can i convince them of that before i've done the work?
09:45:08 <norpan> and if he didn't say that, then i want credit for saying it
09:45:23 <astrolabe> ndm seems to want to do something useful.  He should be kicked out of academia.
09:45:24 <ndm> norpan: he did, in a recent interview
09:45:34 <norpan> good
09:45:43 <ndm> astrolabe: i can leave academia at any time, and become a C monkey somewhere...
09:45:55 <astrolabe> ndm: yeah :(
09:46:03 <gour> ndm: nice post on your blog!
09:46:11 <ndm> gour: the advertisement one?
09:46:21 <gour> ndm: yep
09:46:43 <ndm> cheers, again seems to be somewhere i disagree with most of the people posting to -cafe
09:47:09 <astrolabe> ndm: why would it be so much work?
09:48:01 <ndm> astrolabe: the parser? i can probably trim it down to 3 months, if thats all the funding i have, but more would give a more polished version
09:48:31 <vincenz> ndm: glr-style parsing?
09:48:32 <ndm> astrolabe: my parser is 100% cross-platform/language/standard, so i'd like my parser to include a Haskell/C/Latex/XML parser etc, and never make anyone rewrite those
09:48:49 <ndm> vincenz: nothing like anything you've ever heard of - its completely unique (as far as I can tell)
09:48:58 <gour> ndm: become a yogi and trim your eating ;)
09:49:03 <ndm> vincenz: but the benefits that everything is a valid grammar, much like glr
09:49:16 <ndm> gour: i still need to pay rent and drink beer, food is a secondary concern :)
09:49:18 <astrolabe> ndm: commercial possiblities?
09:49:19 <vincenz> ndm: well the main advantage of GLR besides that is ambiguity
09:49:47 <ndm> vincenz: GLR is O(n^2.6), mine is O(n), and mu;ch easier to specify
09:50:00 <vincenz> ndm: GLR fills a niche cause it allows ambiguous syntaxes
09:50:09 <ndm> astrolabe: at the end, maybe, i'd rather have the whole world use it. but while i'm writing it there is no commercial possibility
09:50:21 <gour> who wants to raise funds for ndm' s beer?
09:50:31 <ndm> vincenz: indeed, mine merely picks what the user actually wants, which i think is a better choice
09:50:35 <Igloo> ndm: Oh, an MSRC internship might work if you can convince the Simons
09:50:35 <vincenz> I vote we move ndm to belgium, beer is much cheaper
09:50:47 <gour> good idea
09:50:53 <astrolabe> How much is 1 year of student these days?
09:50:54 <vincenz> ndm: No, cause the problem is that c++ is inherently ambiguous and can only be disambiguated during namespace lookup and typecheck
09:50:57 <ndm> Igloo: i think that might be one of the few ways it could get done
09:51:04 <vincenz> ndm: there is no "right" hence "ambiguous"
09:51:19 <ndm> vincenz: unless you parse to an intermediate format, and then do full parsing later - i.e. like infix operators of unknown precedence
09:51:46 <ndm> vincenz: parsing to one form should be unambiguous, name lookup should happen later, i beleive
09:51:59 <vincenz> ndm: C++, syntactically, -is- ambiguous
09:52:01 <vincenz> the language itself
09:52:38 <ndm> vincenz: thats entirely a question of where parsing ends and resolution begins - at the level of "one character after another" it is not ambiguous, the question si how far you can extend that
09:53:08 <ndm> anyway, C++ has a crap syntax, x<Array <Int>> gets parsed wrong, how broken is that...
09:53:22 * vincenz shrugs and shuts up
09:53:31 <vincenz> I was merely pointing out that GLR has some merits
09:53:37 <psnl> someone said beer
09:53:55 <ndm> vincenz: yes, i agree entirely, and one of the things my 1 year beer money would pay for is an investigation into that
09:54:20 <ndm> vincenz: i think it can be done better than is traditionally done, but the language is at fault, i feel - a difficult challenge
09:55:16 <emu> glguy: one thing about guard: i have this case expression, and in one branch I wanted it to backtrack basically, so I said "guard False" but that didn't make the typechecker happy, i had to add a "fake" return statement after it
09:55:33 <pejo> astrolabe, 100k EUR roughly, with an insane overhead.
09:55:50 <vincenz> pejo: you have got to be kidding me
09:56:11 <vincenz> marie curie, which is quite high, is 1800 euro/month, so multiply that by 12
09:56:41 <emu> i just stuffed my backtracking logic into the list monad and it just "worked"
09:56:48 * emu is thinking something is going to bite back shortly
09:57:03 <vincenz> emu: nah, haskell's type system will stop biting
09:58:08 <gour> ndm: what's missing for gtk2hs via yhc?
09:58:28 <pejo> vincenz, first year grad students here get ~2100 eur/month, and then office space / cleaning / overhead / taxes on top of that.
09:58:33 <dcoutts__> gour: gtk2hs build system would certainly need work
09:58:38 <vincenz> pejo: uk?
09:58:41 <pejo> vincenz, oh, but marie curie might be some sort of tax free stuff?
09:58:44 <ndm> gour: proper library support, some FFI, cabal building with Yhc, then Gtk2Hs building with Cabal
09:58:45 <pejo> vincenz, Sweden.
09:58:53 <vincenz> damn, I should've gone to sweden
09:59:00 <gour> ndm: thanksdcoutts__:
09:59:08 <gour> oops, stupid client
09:59:10 <dcoutts__> ndm: it does do import foreign "wrapper" doesn't it?
09:59:13 <gour> ndm: thanks
09:59:17 <vincenz> pejo: my scholarship is just from the university and is also exempt
09:59:18 <pejo> vincenz, probably some travelling and things included in that sum too. And the final year grad students have higher salaries.
09:59:26 <ndm> dcoutts__, no idea - thats Tom's area
09:59:30 <dcoutts__> ok
09:59:44 <dcoutts__> I thought I recalled that it was implemented
09:59:45 <ndm> dcoutts__, have you seen my bhc post?
09:59:54 <ndm> dcoutts__, we have some FFI, not sure which bits though
10:00:04 <dcoutts__> ndm: not yet, on planet.h.o ?
10:00:20 <gour> dcoutts__: cabal build is not concerned for xmas release?
10:00:25 <ndm> dcoutts__, yep - thats my goal of kind of what Yhc should be in a few years time, kind of my own compiler
10:00:42 <dcoutts__> gour: we're not doing gtk2hs with cabal yet
10:01:17 <pejo> vincenz, I don't think anyone goes to grad school to be rich though, but nods - you should have come to sweden. ;)
10:01:18 <gour> dcoutts__: i know that, but no work is also done on it, ie. focus is on api-issues, right?
10:01:40 <gour> dcoutts__: still in sweden?
10:01:41 <ndm> pejo: isn't beer really expensive in sweden? (it was in norway)
10:01:49 <dcoutts__> gour: currently in norway
10:02:06 <gour> dcoutts__: oh, you have nordic tour?
10:02:07 <pejo> ndm, heh. Would guess around 5 eur in a pub, depending on what you're drinking.
10:02:26 <dcoutts__> gour: do you want to work on cabal improvements to help gtk2hs build with it
10:02:39 <dcoutts__> gour: something like that :-)
10:03:26 <helmut> Hi. I have recently seen a parser (in another unpopular language similar to haskell) consisting of acceptor functions like accept-something :: ([Token] -> Maybe Result) -> ([Token] -> Maybe Result). I'd like to understand this. Could you point me to something to read?
10:03:33 <pejo> ndm, are you saying I should have a higher salary? :-)
10:03:39 <ndm> pejo: thats about £3.50, i typically pay £2-2.50 in a pub, £0.67 at an off license, less for home brew
10:03:46 <gour> dcoutts__: tm, i'm busy with non-haskell stuff, but...is there some draft of cabal development for the future?
10:04:00 <dcoutts__> gour: there's the bug list
10:04:05 <ndm> pejo: i am saying i'd wnat a higher salary to make up for higher beer costs
10:04:23 <pejo> ndm, what is that symbol of yours, "£"?
10:04:45 <gour> dcoutts__: what about c2hs? no new development?
10:04:45 <dcoutts__> gour: as you know, as with most open source projects, there's no firm future feature list
10:04:46 <ndm> pejo: yep, pounds
10:05:04 <ndm> dcoutts__, all of mine have a feature list in my head :)
10:05:08 <vincenz> pejo: what do you mean, noone goes to grad school to be rich, why else did I inscribe?!?
10:05:22 <dcoutts__> ndm: yeah, same, so not written anywhere
10:05:23 * gour needs some free time to resume haskell studies too...
10:05:39 <ndm> i used to want to get rich, then i spent a summer hacking C for various companies, and decided i'd rather have fun than destroy my soul with C
10:05:58 * vincenz pays 1.5 for a beer in a pub, if he's unllucky, 1.7 euro
10:05:59 <gour> right, keep your soul sane
10:06:01 <ndm> (now I get rich hacking Javascript and VBScript, and save hacking Haskell for fun)
10:06:03 <dcoutts__> gour: as of c2hs, I've got some ideas and plans but less time to carry through on them. Gtk2Hs release is my priority at the moment.
10:06:34 <gour> dcoutts__: are you on the track with your phd?
10:06:40 * ndm visits vincenz
10:06:55 <ndm> gour: phd students have a rule, never ask that question!
10:07:13 <dcoutts__> heh
10:07:23 <ndm> dcoutts__, what year are you in?
10:07:25 <psnl> someone else reads piled higher and deeper, I see
10:07:26 * gour is ignorant not being phd student :-(
10:07:35 <dcoutts__> ndm: 4th out of 5
10:07:43 <ndm> dcoutts__, out of 5?
10:07:48 <vincenz> nice
10:07:50 <dcoutts__> ndm: yep :-)
10:07:54 <ndm> psnl: yes, that and dilbert describe my life
10:08:01 <vincenz> here it's 4 years
10:08:02 <ndm> dcoutts__, how?
10:08:17 <vincenz> ndm: I thought it was phdcomics.com
10:08:20 <ndm> i am currently 3/3, and intend to hit 4/3, but no more
10:08:26 <dcoutts__> ndm: phd funding tied to being the teaching assistant for the dept
10:08:48 <ndm> vincenz: yep, thats the one
10:08:52 <ndm> dcoutts__, part time?
10:09:06 <dcoutts__> ndm: lots of teaching during term time
10:09:29 <ndm> i have 6 hours a week, which sucks, makes me do virtually nothing during term time
10:10:05 * vincenz had 20 hours of TA this week
10:10:12 <ndm> ouch!
10:10:14 <vincenz> yeah
10:10:18 <cjeris> doctoral students shouldn't have to teach 2 classes a term... hell, assistant professors shouldn't have to teach 2 classes a term
10:10:19 <vincenz> every afternoon except Wed from 2-7
10:10:22 <gour> dcoutts__: hIDE is in the graveyard or just dead?
10:10:55 <dcoutts__> gour: dunno, I would still like to work on it, but I have so much else to do
10:10:56 * earthy is currently at 4 hours of TA face to face a week
10:11:01 <cjeris> junior people have too much to do climbing the damn research ladder.  sometimes i'm glad to be an ex academic :)
10:11:07 <earthy> that excludes preparation and grading
10:11:21 <ndm> i prepare for my demonstrating by getting drunk the night before...
10:11:31 * earthy doesn't demonstrate :P
10:11:45 * earthy just points out mistakes in the code people write
10:11:51 <cjeris> Understanding Monads.  1.  Get completely blasted.  2. ...\
10:12:12 <earthy> oh, in fact, I code better after a glass of whisky
10:12:26 <earthy> however, quality does degrade after 3. :)
10:12:27 <ndm> yes, after a single beer, yes, after 15 i'm not as hot
10:12:53 <earthy> but, time to go home and make some cale
10:12:59 <earthy> or is that kale?
10:13:03 <earthy> (boerenkool)
10:13:31 * gour sees that ndm's beers could be a major amount of his funding
10:13:59 <ndm> gour: am drinking wine right now, but yes, typically beer money == food money
10:14:01 <earthy> anybody interested in a vim ftplugin for haskell that does some rudimentary folding and defines a rather nice mapping for automatically inserting types?
10:14:47 <gour> earthy: whatver for vim you have i'm interested 'cause pida is my present IDE
10:14:47 <shapr> @yarr
10:14:48 <lambdabot> Avast!
10:15:12 <earthy> okay, I'll work to a release later this evening
10:15:37 <gour> earthy: great, have you seen pida? gvim + darcs...
10:15:43 <earthy> haven't
10:16:01 <earthy> will look ;)
10:16:02 <gour> earthy: pida.erlios.de
10:16:04 <earthy> first, food. :)
10:16:07 <earthy> tnx
10:16:32 <gour> earthy: pida.berlios.de
10:16:37 <Excedrin> http://pida.berlios.de/
10:16:39 <lambdabot> Title: Home - PIDA
10:16:40 * earthy found it ;)
10:17:03 <gour> earthy: it misses only haskell :-)
10:18:03 <gour> earthy: you need kiwi + docutils (python stuff), i pull with bzr from http://bazaar.launchpad.net/~pida/pida/main/ and run ./develop.sh script
10:18:05 <lambdabot> Title: Index of /~pida/pida/main
10:19:51 * glguy crosses his fingers that VS.NET2005SP1 doesn't kill off Visual Haskell
10:20:10 <ndm> glguy: my experience is any little thing kills of VH
10:20:19 <Saizan> what's the right ip for reddit?
10:20:24 <glguy> )-':
10:20:35 <ndm> @ip reddit.com
10:20:36 <lambdabot> reddit.com
10:20:37 <chessguy> @where reddit
10:20:37 <lambdabot> I know nothing about reddit.
10:21:00 <glguy> 72.5.28.218 programming.reddit.com
10:21:04 <Excedrin> 72.5.28.218
10:21:09 <Saizan> thanks
10:21:43 * glguy did an /exec grep prog /etc/hosts :)
10:22:03 <glguy> my dns is still broken partially too
10:22:25 <Saizan> now i just have to find hosts in windows, somewhere like windows\ i presume..
10:22:28 <glguy> reddit.com resolves for me, but not programming.redit.com
10:22:31 <glguy> notepad c:\windows\system32\drivers\etc\hosts
10:22:38 <Saizan> thanks
10:22:48 <Saizan> i'll use gvim however :D
10:22:57 <glguy> either way
10:23:12 <glguy> I had that as the first entry in my Run... dialog
10:23:19 <glguy> so you got what I copied out ;)
10:23:41 <Saizan> :)
10:23:42 <PaulAJ> programming.reddit.com (72.5.28.218)
10:29:29 <bd_> ?where yaht
10:29:30 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
10:32:58 <chessguy> hmm
10:33:12 <chessguy> it just dawned on me that lambdabot doesn't address answers to specific users
10:34:19 <chessguy> > 2^2^5
10:34:21 <lambdabot>  4294967296
10:34:48 <chessguy> most bots would respond something like "chessguy: 4294967296"
10:35:05 <kpreid> most? I don't think so
10:35:27 <chessguy> well, mbot does anyway
10:35:51 <erg0t> but you can send the bot  a pirv msg anyways
10:36:11 <chessguy> true, but in that case specifying the user it's talking to is pretty pointless
10:40:48 <ndm> dcoutts__: any idea of a cheap and crappy B&B for Hac07?
10:42:39 <SamB_XP> I think the idea is that if you are interacting with lambdabot in public, you are doing so along with others...
10:42:51 <Excedrin> chessguy: I don't remember mbot doing that either
10:43:33 <ph8> hi guys! I'm hoping someone can clear up a little gap in my haskell learning - I understand how to define a function that reads data in from a file and assigns it to a Map (of Data.Map) but how do i make that Map variable global?
10:43:52 <Syzygy-> ph8: You don't.
10:44:04 <notsmack> ph8: it may be a slightly bigger gap than you thought :-)
10:44:21 <ph8> ah. how can i then access it from other methods? or is the idea it's continually passed from function to function?
10:44:50 <Syzygy-> Yup.
10:44:53 <Syzygy-> That's the idea.
10:45:47 <Syzygy-> Of course, you can put it inside a whole block of things that are supposed to be passed around; or even use the State monad to keep track of it. But still, the basic idea is that you'll have to tell each function about all the state of the world that influences the function.
10:46:22 <Syzygy-> This is one of the benefits of Haskell (no matter what it sounds like ;) since it makes the functions non-dependent on non-predictable things, like the state of the world.
10:46:23 <notsmack> ph8: functions are a one to one mapping from inputs to output.  If you want a function to act differently based on some value, the value needs to be a parameter.
10:47:40 <notsmack> ph8: it seemed awkward to me until i realized the word "function" in haskell means less "subroutine" and more "mathematical function"
10:50:25 <ph8> cool
10:50:47 <ph8> yeh it's a bit different to get used to; i've got loads of java/perl/C# experience, and similar but this is my first truly functional language
10:51:43 <notsmack> ph8: i'm still pretty new to it too.  how are you liking it so far?
10:53:16 <kzm_> I'm not supposed to say this, but if you want to treat the map as a global constant, you may be able to cheat using unsafePerformIO.
10:53:28 <kzm_> Now I will have to shoot you :-)
10:53:29 <notsmack> haha, no you aren't.  :-)
10:55:49 <ph8> lol
10:56:15 <ph8> well, i'm being taught it at university so a lot of this is compulsory stuff, right now what i'm doing is a project involving n-grams for the Christmas holiday
10:56:23 <ph8> I can't say i'm too keen on it at the moment, but it might grow on me
10:56:38 <ph8> it seems you can do loads of cool stuff, but it's not very intutitive - but it might just be the alternative way of thinking that i need to get used to
11:01:47 <ndm> ph8: you'll find once you get into it, C seems like cruel and unusual torture
11:03:36 * shapr boings
11:04:38 * ndm collapses
11:06:55 <nnunley> So. Is there an easy way of getting at ghc's c-- compiler?
11:07:38 <ndm> nnunley: it is there easily, just pass a .cmm file on the command line
11:07:49 <nnunley> Excellent.
11:08:37 <ndm> (i think)
11:08:48 * nnunley is glad that he doesn't use his initials, or this would be confusing.
11:09:05 <nnunley> I'll give it a try later on.
11:09:18 <ndm> ask Igloo if it doesn't work, he was the one who told me
11:09:23 <lisppaste2> ptolomy pasted "ByteString regex replace.. potential optimizations?" at http://paste.lisp.org/display/32521
11:09:32 <nnunley> Will do.
11:11:09 <ptolomy> (In that lisppaste snippet, I was working on a way to do "here is a regex, here is a bytestring. Replace all occurances of regex with this other bytestring".
11:13:04 <ph8> this is tough, i'm in a 'do' loop - and i've got 'let ls = readFile f' - f is a filepath argument, how then do i start creation of my map object? if i'm trying to loop through each character in the file and generate a frequency table
11:13:13 <ph8> do i need an Insert function that takes an array if Ints?
11:13:25 <ph8> (which is the frequency)
11:13:31 <ph8> actually i need a map valuE!
11:13:38 <ph8> but how do i create that with insertWith?
11:13:43 * ph8 was born confused
11:13:54 <Excedrin> "do" loop?
11:14:37 <ph8> sorry i just mean the function is defined as function f = do
11:14:59 <Excedrin> as in, loop = do { a; b; c; loop } ?
11:15:14 <Excedrin> oh, ok
11:15:22 <allbery_b> hrm, I'd expect readFile is IO, so you can't "let" it
11:15:37 <Excedrin> I'd suggest simply using getContents
11:15:43 <ph8> i've got an example with binary trees but it's got a funky insert function with some foldl action or something crazy
11:15:57 <Excedrin> actually, nevermind that, readFile is the same
11:16:34 <ph8> so my problem is i've got a readFile -> Map a b function - that i want to put chars into an array of (Int,Char)s
11:16:40 <ph8> or vice versa even
11:16:44 <ph8> Char,Ints
11:17:09 <Excedrin> is there any reason why you need an array?
11:17:14 <ph8> so it's the creation of that map that i have no idea how to do
11:17:31 <ph8> well i've been told to use maps for this work, there's probably not a better way of tracking the frequencies?
11:17:33 <lightstep> ?type Data.Map.empty
11:17:34 <lambdabot> forall a k. Data.Map.Map k a
11:17:48 <lightstep> arrays and maps are the same for this
11:18:03 <ndm> IntMap's are faster than arrays...
11:18:22 <ph8> ok, but how do i intialise any of those?
11:18:23 <ndm> 100x faster in my experiements, scarily
11:18:28 <ph8> i'm told there's this insertWith function
11:18:33 <ph8> so after i've done ls <- readFile F
11:18:34 <ph8> do i then just put
11:18:50 <ph8> insertWith randomInsertFunction 1 value mapSoFar
11:19:01 <lightstep> you can use insert
11:19:21 <lightstep> oh, right, insertWith so you can add it
11:19:21 <ph8> but then my randomInsertFunction will have to construct and return an.... array? a (1, Value) pairing? and insertWith will sort the rest?
11:19:47 <lightstep> insertWith creates a new map from a given one
11:20:24 <ptolomy> ph8: http://www.haskell.org/haskellwiki/Shootout/Knucleotide#Data.Map_.233_.28ByteString.29
11:20:27 <lambdabot> Title: Shootout/Knucleotide - HaskellWiki, http://tinyurl.com/taj64
11:20:32 <ptolomy> Check out the loadMap function.
11:20:49 <ph8> so my insert function would be like, "myInsert :: Char -> Int -> (Char, Int) myInsert (a,b) = (a,b)"?
11:20:52 <ptolomy> it's an example of creating a tally map.
11:20:57 <ph8> cheers for linkage
11:21:24 <lightstep> ndm, these are Array.Array, Data.Array.Array, or Data.Array.ST.STUArray?
11:21:53 <Excedrin> is "mapM_ print $ map (\x -> (head x,length x)) $ group $ sort ls" a horrible way to do that?
11:22:24 <ptolomy> insertWith just takes a function so that if a value already exists for that key, the value is changed to the value of "insertWithFunction oldvalue newvalue".
11:22:46 <ptolomy> Excedrin: Depends on data set size, really.
11:22:50 <ptolomy> it isn't so efficient.
11:22:56 <ndm> lightstep: IOArray
11:22:57 <Cale> I think my automatic reaction to Java people for the time being will just be pointing them at Scala.
11:22:57 <ptolomy> but it is an apparently common pattern.
11:22:58 <emu> i think i'm going to start working in .lhs all the time
11:23:01 <scodil> dcoutts: you there?
11:23:09 <notsmack> ph8:  myInsert a b = (a, b)
11:23:09 <lightstep> unless sort is bucketSort
11:25:12 <lightstep> which it is, i think, in ByteString
11:25:13 <Cale> Excedrin: I'd say it's pretty close to an ideal way to do that, but you're overusing ($) ;)
11:25:52 <Excedrin> are parens better?
11:25:53 <Cale> Remember that whenever you write f $ g $ h $ x, you can write f . g . h $ x instead.
11:26:16 <Cale> It's nicer that way, because, for example, (g . h) is still well-typed, but (g $ h) isn't.
11:26:18 <Excedrin> oh, right
11:26:45 <Cale> So it makes it a little easier to think about and refactor even though it's the same thing.
11:26:47 * notsmack looks for a definition of well-typed
11:27:02 <integral> @type \g h -> (g$).(h$)
11:27:04 <lambdabot> forall b b1 a. (b1 -> b) -> (a -> b1) -> a -> b
11:27:47 <Cale> notsmack: Well, assuming that the original thing worked, g and h are functions such that the result of h is a valid parameter for g
11:28:02 <Cale> so g . h makes sense as far as types are concerned
11:28:14 <Excedrin> style wise, if you start to exceed 75 or so characters and you want to break the line, is it more typical to put the . on the new line or at the end of the old line?
11:28:32 <Cale> but g is unlikely to take something of the same type as h as its parameter (actually it's impossible given what we know)
11:28:43 <Cale> on the new line, I think
11:28:57 <Cale> Like if you're adding things, you usually don't end a line with a +
11:30:17 <Cale> Also, I want people to write things using (.) instead of repeated ($) because of my hidden agenda to flip the associativity of ($)
11:30:52 <Cale> which will break all of the code which is written like that, but will be more useful given that (.) can be used to get the effect of composition
11:31:23 <glguy> Cale: the one advantage I found to $ over .
11:31:29 <Masklinn> yeah but the precedence of (.) is too low, you have to use parens
11:31:39 <glguy> is in cases like: this `that` theother $ this `that` another
11:31:41 <Cale> Masklinn: not if you use a single ($)
11:31:51 <glguy> because of $'s 1 precedence
11:32:00 <Cale> any case with exactly one $ I'm okay with
11:32:02 <Masklinn> yeah but in that case we still have to use ($)
11:32:05 <Masklinn> lol
11:32:16 <glguy> is in cases like: this `that` theother $ this `that` another $ x
11:32:18 <Cale> It's when people start chaining ($)'s where I suggest composition.
11:32:19 <glguy> there, that's what I meant
11:32:33 <Masklinn> @remember Cale Also, I want people to write things using (.) instead of repeated ($) because of my hidden agenda to flip the associativity of ($)
11:33:07 <glguy> while you can't write: this `that` theother .  this `that` another $ x (without extra parentheses)
11:33:20 <sjanssen> I'm a recent convert from ($) style to (.) style -- it really is better!
11:33:27 <Cale> glguy: that should work fine with (.) so long as `that` is declared with the right precedence.
11:33:30 <glguy> (a `b` c) . (a `b` d) $ e
11:33:48 <integral> single letter variables make haskell look much better :-P
11:33:58 <glguy> Cale: . has precedence 9, so you couldn't set it higher
11:34:04 <Masklinn> single letter variables make haskell look like perl
11:34:18 <glguy> (can you set it higher?)
11:34:50 <Cale> actually, that's a good question
11:34:54 <integral> Masklinn: Perl actually discourages $a and $b (at least) by making them not work quite right.
11:35:02 <Cale> I don't know whether the standard guarantees more than 10 levels.
11:35:16 <glguy> Cale: where 10 is function application?
11:35:24 <Masklinn> yeah, but single letter variables in Haskell generates a very high punctuation / letters ratio
11:35:27 <Cale> They go from 0 to 9
11:35:31 <glguy> oh
11:35:37 <Masklinn> and high punctuation/letters ratio is one of perl's trademarks
11:35:41 <Cale> I suppose you could count function application separately at 10
11:35:57 <integral> Masklinn: perl can do better though since it doesn't require any letters.
11:36:14 <Cale> You can still write   that this theother . that this another $ x
11:36:16 <integral> (oops, haskell too)
11:36:22 <Masklinn> integral > well I wouldn't call that "better" but I see your point
11:36:27 <Excedrin> how do $a and $b not work right in perl?
11:36:47 <integral> Excedrin: declare them as lexicals then try sorting something with a custom comparison routine.
11:37:13 <glguy> Cale: in my case I was writing: (1:) ^: x $ (0:) ^: y $ xs -- where (f ^: n) x = iterate f x !! n
11:37:23 <integral> (hint: the comparison routine takes the values to compare in $a, and $b, but the global versions not your lexical ones)
11:37:29 <Excedrin> ok, it's not single letter variables in general, it's a and b specifically...
11:37:38 <Excedrin> that's typical of perl, so I'm not surprised
11:38:01 <glguy> ^: is a J function, and I was using it in code that was just for me, so I didn't care if it was confusing to someone who didn't know J
11:38:09 <Cale> okay
11:38:20 <cjeris> @karma+ J
11:38:20 <lambdabot> J's karma raised to 1.
11:38:49 <glguy> in J, f ^: _1     means "do the inverse of f
11:39:07 <glguy> _1 is -1 in J
11:39:10 <Cale> right
11:39:18 <glguy> my version obviously couldn't handle that :)
11:39:20 <Cale> how does it compute that?
11:39:23 <cjeris> J is the awesome.  and makes Perl look like the punctuationiness of Pascal.
11:39:40 <glguy> Cale: for functions that you define, you have to tell J the inverse function if you want support for that
11:39:42 <Cale> dc is way more punctuationy
11:39:53 <glguy> Cale: all the built in functions have support for it (more of less) out of the box
11:39:58 <Cale> What other language lets you use newline as a variable name?
11:40:05 <emu> does anyone here write .lhs -latex?
11:40:46 <Cale> emu: I've used the latex literate haskell form
11:40:54 <cjeris> Cale: Perl does, and Common Lisp might -- I don't remember.
11:40:56 <glguy> I think if you wrote:  f ^:__    (where __ is infinity) it would apply the function until the result stopped changing
11:41:05 <alexj__> shapr: you here?
11:41:07 <emu> cjeris: probably | <newline> |
11:41:16 <Cale> glguy: why not just forever?
11:41:34 <emu> Cale: did you set it up with emacs?
11:41:34 <sjanssen> might as well write _|_ then
11:42:14 <Cale> emu: A little bit, I think.
11:42:28 <emu> i have mmm-mode setup for it, it just doesn't seem to be switching keybindings
11:42:33 <Cale> I seem to recall all the code being coloured, and the latex being the comment colour
11:42:36 <emu> wasn't sure if it was supposed to
11:42:37 <Cale> which was fine with me
11:43:14 <emu> hmm, thats probably an issue too. looks like i'm primary latex / secondary haskell
11:43:59 <Cale> sjanssen: least fixed points of functions are not always _|_ :)
11:44:05 <glguy> Cale: "Integer. The verb u is applied n times. An infinite power n produces the limit of the application of u "
11:44:25 <glguy> Cale: I don't know why it's that way, but it was useful
11:44:51 <Cale> What happens when f is the equivalent of \g n -> if n == 0 then 1 else n * g (n - 1)
11:45:12 <Cale> do you get the factorial function? :)
11:45:26 <glguy> nope
11:45:27 <sjanssen> > fix (const 1) -- of course, Cale, you are right :)
11:45:28 <lambdabot>  1
11:45:39 <Cale> no?
11:46:01 <glguy> Cale: it's not fix
11:46:08 <glguy> Cale: it's iterate
11:46:14 <Cale> sure...
11:46:31 <glguy> so you only get the previous result
11:46:35 <glguy> not a referece to yourself
11:47:00 <glguy> functions in J don't have an arbitrary number of arguments
11:47:15 <glguy> they either take a right argument, or a right and a left argument
11:47:16 <Cale> > iterate (\g n -> if n == 0 then 1 else n * g (n - 1)) undefined !! 10 $ 9
11:47:18 <lambdabot>  362880
11:47:33 <Cale> > iterate (\g n -> if n == 0 then 1 else n * g (n - 1)) undefined !! 10 $ 10
11:47:35 <lambdabot>  Undefined
11:47:40 <Cale> > iterate (\g n -> if n == 0 then 1 else n * g (n - 1)) undefined !! 20 $ 10
11:47:41 <lambdabot>  3628800
11:47:46 <glguy> J doesn't have first class functions either
11:47:52 <Cale> ah, okay
11:47:53 <glguy> to write higher order functions, you write adverbs
11:48:11 <glguy> which specifically act on functions
11:48:33 <Cale> is that a conscious design decision?
11:48:40 <glguy> I believe so
11:48:48 <Cale> What does it buy you?
11:48:55 <glguy> having adverbs?
11:48:59 <Cale> yeah
11:49:06 <Cale> the separation of functions and adverbs
11:49:13 <glguy> adverbs are applied first
11:49:24 <glguy> that could be one thing
11:49:30 <glguy> I have only dabbled in J
11:49:55 <glguy> first the verbs are modified by the adverbs
11:50:00 <glguy> and then the verbs are applied to the values
11:50:12 <glguy> since you only take 1 or 2 arguments
11:50:17 <glguy> it's not a huge restriction
11:50:32 <Cale> I suppose it makes some kind of sense. It feels like it loses compositionality to me.
11:50:47 <glguy> J definitely isn't a drop in replacement for Haskell :)
11:50:51 <Cale> hehe
11:51:16 <glguy> Fibonacci Sequence code: {. +/\@|.^:n 0 1x [ n=:128       NB. n-th term of the Fibonacci sequence
11:51:25 <glguy> it lets you write some pretty terse code
11:52:13 <Cale> fix ((0:) . scanl (+) 1)
11:52:16 <Cale> *grin*
11:52:22 <Cale> but yeah
11:52:36 <Cale> I've looked at similar languages, and it is fairly powerful
11:52:48 <Cale> they do seem to struggle with the whole precedence issue though
11:53:00 <glguy> evaluation is right to left
11:53:14 <alexj__> @seen shapr
11:53:14 <lambdabot> shapr is in #haskell, #scannedinavian and #haskell-blah. I last heard shapr speak 49m 39s ago.
11:53:17 <Cale> right :)
11:53:26 <glguy> they seem to skirt the issue altogether , heh
11:53:45 <sjanssen> @quote
11:53:47 <lambdabot> emu says: hijack the stack and take this compiler to Fun-land!
11:53:48 <fnord123> hi all.
11:54:07 <sjanssen> salutations
11:54:26 <Cale> hello
11:54:27 <fnord123> I have a function that takes String :: IO [String] and I want to print out the results of running the function several times (on a [String]).
11:54:57 <sjanssen> fnord123: do you mean String -> IO [String] ?
11:55:09 <fnord123> yes
11:55:10 <notsmack> fnord123: map?
11:55:12 <Cale> sjanssen: good guess, I was confused
11:55:17 <Cale> @type mapM
11:55:18 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
11:55:24 <Cale> m = IO
11:55:26 <Cale> a = String
11:55:29 <Cale> b = String
11:55:42 <fnord123> I'm unsure how to get map to work... xs <- map func args yields a complaint that xs needs an io value, not a [], which i understand
11:55:43 <Cale> (String -> IO String) -> [String] -> IO [String]
11:55:50 <glguy> results <- mapM yourfunction yourinputs
11:55:54 <notsmack> fnord123: no, Cale's right.  mapM
11:55:58 <fnord123> ok mapM
11:56:08 <Cale> mapM is very very important
11:56:33 <Cale> It takes the place of for-loops in monadic code.
11:56:51 <glguy> forM is flip mapM
11:56:54 <Cale> If you're running GHC 6.6 or newer there's also forM, which is the same as mapM, but with the parameters flipped
11:56:55 <TSC> Is mapM the same as (sequence . map) ?
11:56:56 <fnord123> Shoryuken! mapM works a treat.
11:57:01 <Cale> TSC: yep
11:57:03 <Cale> er
11:57:09 <glguy> (sequence .) . map
11:57:10 <Cale> mapM f = sequence . map f
11:57:27 <sjanssen> fnord123: the M stands for Monadic.  There are several functions that are list functions lifted into a monad: replicateM, foldM, for example
11:57:35 <glguy> filterM
11:57:43 <glguy> > filterM (const [True,False]) [1..3]
11:57:44 <glguy> wild!
11:57:44 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
11:57:53 <sjanssen> glguy: oh, that one is my favorite!
11:58:16 <glguy> > filterM(\_->[False ..])[1..3] -- shortest version I found
11:58:17 <lambdabot>  [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
11:58:20 <fnord123> >const [True, False]
11:58:41 <Cale> > const [True, False] 5
11:58:42 <fnord123> > :type const [True, False]
11:58:42 <lambdabot>  [True,False]
11:58:43 <lambdabot>  Parse error
11:58:48 <sjanssen> @. djinn type const
11:58:49 <Cale> const x y = x
11:58:50 <lambdabot> f a _ = a
11:59:40 <Cale> > filterM (const [True]) [1..3]
11:59:41 <lambdabot>  [[1,2,3]]
11:59:46 <Cale> > filterM (const [True,True]) [1..3]
11:59:48 <lambdabot>  [[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3]]
11:59:53 <Cale> > filterM (const [False,True]) [1..3]
11:59:54 <lambdabot>  [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
11:59:57 <ptolomy> @pl takeWhile (((/=) '>') . head)
11:59:57 <lambdabot> takeWhile (('>' /=) . head)
12:00:02 <Cale> > filterM (const [True,False]) [1..3]
12:00:03 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
12:00:47 <fnord123> the ZVON Prelude docs say const is the constant function but doesn't really explain what it does.
12:01:01 <Cale> const is a maker of constant functions
12:01:02 * glguy wonders what ZVON is
12:01:06 <sjanssen> fnord123: const takes two arguments, it returns the first one and ignores the second one
12:01:17 <Cale> (const x) is the constant function which gives x for every input value
12:01:19 <fnord123> const 1 2 3
12:01:24 <fnord123> > const 1 2 3
12:01:25 <lambdabot>  add an instance declaration for (Num (t -> a))
12:01:30 <Cale> > const 1 2
12:01:31 <lambdabot>  1
12:01:34 <Cale> > const 1 5
12:01:35 <lambdabot>  1
12:01:37 <glguy> fnord123: you just tried to write: > 1 3
12:01:43 <Cale> > map (const 1) [1..10]
12:01:45 <lambdabot>  [1,1,1,1,1,1,1,1,1,1]
12:01:48 <fnord123> http://www.zvon.org/other/haskell/Outputprelude/index.html
12:01:49 <lambdabot> Title: Zvon - Haskell Reference
12:01:54 <Cale> It's a constant function
12:02:00 <glguy> > [1..10] >> [1]
12:02:01 <lambdabot>  [1,1,1,1,1,1,1,1,1,1]
12:02:02 <Cale> const 1 = \x -> 1
12:02:04 <sjanssen> fnord123: you're probably better off with:
12:02:06 <sjanssen> @docs
12:02:08 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
12:02:23 <Cale> const k = \x -> k
12:02:24 <emu> hm i think i just created a mmm-mode which primaries haskell and secondaries latex, and swaps keybindings nicely too
12:02:35 <Cale> that might make it easier to see why it's called const
12:03:46 <Cale> x >> y = x >>= const y
12:04:36 <Cale> Makes sense, because no matter which result x gives, we're going to ignore it, and use y next.
12:04:53 <cjeris> hey, an angry industrial band called Battery Cage made a song about Haskell taking over the world -- either that, or they really hate lexers
12:04:53 <Cale> > [1..10] >> [1,2]
12:04:55 <lambdabot>  [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2]
12:05:06 <cjeris> The refrain goes "We are your executioners, destroy your state machine" :)
12:05:08 <Cale> cjeris: what?
12:05:08 <glguy> ?pl x >>= const y -- can lambdabot find >>?
12:05:09 <lambdabot> x >> y
12:05:10 <Cale> oh
12:05:11 * SamB wants AJAM
12:05:12 <glguy> hurrah!
12:05:36 <glguy> ?unpl x >> y
12:05:36 <lambdabot> (x >> y)
12:05:48 <SamB> ?redo x >> y
12:05:49 <lambdabot> do { x; y}
12:05:59 <SamB> how lon have we had that
12:06:02 <SamB> ?
12:06:06 <Cale> ?redo x >>= const y
12:06:07 <lambdabot> do { a <- x; const y a}
12:06:08 <SamB> *long
12:06:10 <int-e> map concat $ mapM (([]:).([]:)) [1..3]
12:06:12 <int-e> > map concat $ mapM (([]:).([]:)) [1..3]
12:06:13 <lambdabot>  add an instance declaration for (Num [[a]])
12:06:13 <lambdabot>   In an arithmetic sequence: ...
12:06:16 <SamB> ugly though its output may be
12:06:26 <SamB> @. pretty redo x >> y
12:06:26 <lambdabot> "Parse error" at column -17
12:06:40 <SamB> @. pretty redo f = x >> y
12:06:40 <lambdabot> "Parse error" at column -17
12:06:47 <Cale> column -17
12:06:58 <ebitshiftr> that's a good column
12:07:08 <Trevion> That one's off the edge of my screen
12:07:22 * glguy had to adjust his monitor to see column -17
12:07:27 <sjanssen> SamB: I submitted the redo patch at the end of August
12:07:42 <ptolomy> Would anyone strongly disagree with the notion that haskell makes it harder to do dirty ugly hacks of design than most other languages?
12:07:52 <int-e> > map concat $ mapM (([]:).(:[]).(:[])) [1,2,3]
12:07:53 <Trevion> NO!
12:07:54 <lambdabot>  [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
12:08:10 <norpan> YES!
12:08:12 <norpan> or NO!
12:08:24 <Trevion> I have roughly 13 months of experience to prove that people can do things in Haskell equally horrid to anything ever done in Java or C++
12:08:28 <SamB> ptolomy: well, less appealing!
12:08:35 <arcatan> yes AND no!
12:08:39 <Cale> Trevion: hehe
12:08:45 <Cale> Trevion: well, of course
12:08:55 <Trevion> I think it probably takes them more effort to accomplish such horridness, thus providing an overall loss of productivity.
12:08:55 <Cale> You can obfuscate code in any language.
12:08:58 <int-e> Trevion: I'm sure you can write Fortran programs in Haskell, too.
12:09:06 <SamB> Trevion: hahaha
12:09:06 <Cale> Trevion: hahaha
12:09:14 <SamB> heh
12:09:14 <Cale> SamB: jinx!
12:09:30 <fnord123> depends which fortran
12:09:32 <norpan> you can do pretty ugly things with things like unsafePerformIO
12:09:45 <Trevion> int-e is going down the right track.  Most of this consisted of things like refusing to use Maybe to indicate failure.
12:09:48 <Cale> unsafePerformIO should require a compiler switch
12:10:04 <ptolomy> I ask because I'm currently doing C++ code for work, and I feel like the specification (or lack thereof) to a certain degree forces bad design.. nothing is consistent, all sorts of ugly special cases.. seems like that'd be much harder in haskell.
12:10:06 <glguy> does ST use unsafePerformIO?
12:10:09 <SamB> -fmy-name-is-simon ?
12:10:16 <Cale> SamB: exactly
12:10:30 <norpan> c++ invites to ugly hacks
12:10:33 <ebitshiftr> There were plenty of good algorithmic abuses trevion,
12:10:34 <sjanssen> glguy: no, it uses more specific compiler hacks
12:10:43 <ebitshiftr> remember the concentric octagon thing
12:10:56 <glguy> sjanssen: does writing ST code provide the same performance as IO code?
12:10:57 <ptolomy> academic projects tend to (in my experience) be less messy/dirty than "real world" problems, which tend to not be about the big interesting idea so much as the little things working.
12:11:04 <Trevion> Ah, hi Mark.  I was wondering if that was a permutation of your name.
12:11:13 <ebitshiftr> It is!
12:11:21 <SamB> that said, should I try to write a MOO client in Haskell?
12:11:22 <sjanssen> glguy: yes.  Under the hood, IO is actually ST RealWorld
12:11:30 <Trevion> SamB: yes.
12:11:47 <ebitshiftr> SamB, can I steal it when you are done?
12:11:50 <Trevion> It will go nicely with my long-held plan to write a MOO server in Haskell
12:11:53 <SamB> or IDE, even
12:12:01 <norpan> IDE
12:12:05 <pejo> SamB, mud client!
12:12:08 <Cale> Where was that C++ code which abused operator overloading to compute the volumes of ascii-art cubes?
12:12:10 <norpan> if we're allowed to vote
12:12:12 <SamB> Trevion: will it use the same language?
12:12:17 <psi> what's the difference between moo and mud?
12:12:18 <scodil> is reads guaranteed to skip whitespace? the docs don't mention it
12:12:26 <fnord123> just make an eclipse mode
12:12:31 <Cale> psi: moo is specifically object oriented
12:12:32 <SamB> pejo: generally MOO clients work with MUDs, just without any of the MOO features being of any use
12:12:32 <nnunley> SamB: You're a MOOer?
12:12:46 <twanvl> Cale: http://www.xs4all.nl/~weegen/eelis/analogliterals.xhtml
12:12:48 <SamB> nnunley: not exactly
12:12:49 <glguy> > reads "  1   " :: (Int,String)
12:12:50 <lambdabot>  Couldn't match `(Int, String)' against `[(a, String)]'
12:12:56 <glguy> > reads "  1   " :: [(Int,String)]
12:12:57 <Cale> twanvl: aha, that's right :)
12:12:57 <lambdabot>  [(1,"   ")]
12:12:57 <SamB> but I like to tinker with my own personal MOO database
12:13:21 <pejo> SamB, would give lots of exercise of the regexp code, and bytestrings!
12:13:22 * twanvl bookmarked it :)
12:13:26 <glguy> > [a | (a,"") <- reads "   1    "] :: [Int]
12:13:27 <lambdabot>  []
12:13:36 <SamB> pejo: regex code?
12:13:42 <nnunley> moo has an oob protocol for coding, so it's a little more complicated than just a line based mud client
12:13:48 <SamB> pejo: oh, you mean for a server?
12:13:50 <pejo> SamB, for triggers!
12:13:52 <SamB> OOB?
12:13:53 <glguy> > [a | (a,_) <- reads "   1    "] :: [Int]
12:13:54 <lambdabot>  [1]
12:14:02 <nnunley> Out of band
12:14:02 <cjeris> has anybody made an "Evolution of a haskell programmer" collecting all the irc ways to make the subsets of [1,2,3] ?
12:14:02 <fnord123> twanvl: that's absolute genius
12:14:32 <SamB> nnunley: oh, yeah, that
12:14:37 <scodil> glguy: so where is it defined what exactly it will skip?
12:14:40 <SamB> I was afraid it stood for Object Oriented Broker
12:14:59 <nnunley> I think they tried that, too, with little success.
12:15:01 <SamB> more than one protocol, actually ;-)
12:15:10 <nnunley> Yes, of course.
12:15:14 <SamB> I don't even know what an Object Oriented Broker is
12:15:22 <Trevion> Honestly, I was more interested in the engine's guts than the interface..
12:15:28 <Trevion> Part of CORBA, perhaps?
12:15:36 <SamB> anyway, I was thinking of doings some MacMOOSE protocol support
12:15:37 <nnunley> But they like to call them orbs.
12:16:06 <glguy> scodil: I'm nto sure, but I jsut wanted to demonstrate what it would do
12:16:38 <SamB> probably I will do MCP too, of course ;-)
12:17:00 * nnunley nods.
12:17:59 <SamB> if I even do it
12:18:08 * nnunley grins.
12:18:22 * SamB wonders how hard it is to get source coloring
12:20:20 <ptolomy> @pl dropWhile (\x -> not ("green" `isPrefixOf` x))
12:20:21 <lambdabot> dropWhile (not . ("green" `isPrefixOf`))
12:20:44 <nnunley> SamB: Looks like there's a vim module for moo syntax highlighting. ;)
12:21:02 <psnl> hello
12:21:11 <Vq^> psnl: hiya
12:22:50 <glguy> dropWhile (not . isPrefixOf "green")
12:25:03 <kpreid> SamB: fwiw, I have a bit of experience implementing MCP 2
12:26:38 <scodil> if you freeze a StorableArray, will it box the array elements?
12:27:45 <bd_> @hoogle [String] -> IO Int
12:27:45 <lambdabot> No matches, try a more general search
12:27:50 <bd_> @hoogle String -> IO Int
12:27:51 <lambdabot> Network.Socket.send :: Socket -> String -> IO Int
12:27:51 <lambdabot> Network.Socket.sendTo :: Socket -> String -> SockAddr -> IO Int
12:28:12 <PaulAJ> What do you want to do?
12:29:08 <Cale> scodil: it will make a copy, and the elements will be either boxed or not, depending on which type of IArray you're freezing it to
12:29:49 <scodil> so, in general, it will box them
12:29:55 <Cale> in general, sure
12:29:59 <scodil> bummer
12:30:05 <Cale> In general, it may box them
12:30:19 <Cale> If you freeze to a UArray, obviously they won't be boxed.
12:30:32 <scodil> well thats only for those handful of types
12:30:36 <Cale> right
12:30:48 <scodil> what if I have (Vector Float Float Float)  which is an instance of Storable
12:30:51 <scodil> shit outta lick
12:30:52 <scodil> luck
12:30:57 <dcoutts__> scodil: pong
12:31:53 <scodil> hey, dcoutts__, i'm using pango and drawLayout to render text on a gl window, and its flickering. any ideas?
12:32:00 <dcoutts__> ndm: see the HAC web page for a couple cheep suggestions
12:32:41 <dcoutts__> ndm: there's a backpacker hostel and the YHA, there's probably a bunch of B&Bs too which are probably more costly
12:32:42 <Cale> scodil: you could freeze it to three UArrays of Floats
12:33:06 <dcoutts__> scodil: hmm
12:33:21 <dcoutts__> scodil: it's only the text that's flickering?
12:33:30 <dcoutts__> scodil: you're using opengl double buffering ?
12:33:30 <scodil> sure, but then I can't do (vectorOp vectorArray!i vectorArray!j)
12:33:35 <scodil> yeah
12:33:42 <scodil> dcoutts__: yeah only the text, dbl buffering on
12:34:06 <dcoutts__> scodil: so is the text actually not rendering on alternate frames or what?
12:34:12 <scodil> dcoutts__: exactly
12:34:31 <dcoutts__> scodil: it's pretty weird to get flicker with double buffering on
12:34:57 <dcoutts__> scodil: are you using the functions to sync gl and non-gl rendering to the same surface ?
12:35:15 <scodil> i dunno. here i'll paste it
12:35:17 <scodil> ?paste
12:35:17 <lambdabot> http://paste.lisp.org/new/haskell
12:35:46 <lisppaste2> scodil pasted "render text" at http://paste.lisp.org/display/32525
12:36:52 <ndm> dcoutts__, cheers - i might not be able to make it to HAC after all, but will no in a few days
12:36:55 <scodil> nm its something with project
12:37:03 <scodil> if i render in window coords it doesn't flicker
12:37:11 <dcoutts__> scodil: interesting
12:37:12 <scodil> well, it flickers a little. but not every other frame
12:38:22 <dcoutts__> scodil: try using glDrawableWaitGdk
12:38:22 <shapr> alexj__: y0!
12:38:45 <dcoutts__> scodil: use that after the text rendering bit
12:39:19 <dcoutts__> scodil: which ensures that the gdk bit is done before carrying on with the next gl bit
12:40:00 <Igloo> Hmm, malloc is segfaulting
12:40:04 <dcoutts__> scodil: they use different pipelines so need syncing sometimes, sadly, it's a little annoying if you ask me
12:48:47 <vegai> Hey. I spotted on amazon an upcoming Haskell book by Graham Hutton: "Programming in Haskell"
12:49:34 <vegai> Does anyone have inside information about its scope, target audience, et al?
12:49:56 <scodil> dcoutts__: i stuck (withGLDrawingArea canvas $ glDrawableWaitGdk) at the end and now it doesn't draw at all.
12:53:40 <dcoutts__> scodil: try putting the wsit gdk at the end of the block that draws the text, not in it's own withGL
12:53:53 <glguy> Man, talk about "most inefficient update ... ever" the vs.net 2005 sp1 patch has been running for upwards of 1 hour at 100% CPU
12:54:05 <glguy> and I haven't gotten past "gathering information"
12:54:19 <glguy> and the patch is 431 meg
12:54:29 <dcoutts__> vegai: I'm reviewing it, but haven't got my copy yet
12:54:45 <Masklinn> glguy > what are the improvements/patches?
12:54:53 <glguy> Masklinn: tons of bug fixes
12:55:05 <glguy> Masklinn: theres a KB article listing them
12:55:15 <dcoutts__> vegai: in other words, no idea yet but look out for the review in the next TMR
12:55:32 <ibid> vegai: did you hear? benja is rewriting fenfire in haskell :)
12:56:40 <Masklinn> glguy > Yeah but I'm lazy :D Does it implement
12:56:53 <Masklinn> sorry, does it improve C#3.0 support?
12:56:58 <glguy> I don't think so
12:58:36 <scodil> dcoutts__: got it. you have to render the text after you swap the gl buffers
12:58:53 <dcoutts__> scodil: oh, that's interesting.
12:59:13 <dcoutts__> scodil: want to submit a patch to add some haddock doc that describes this ?
12:59:39 <dcoutts__> scodil: or better still, send in a little demo app that we can include in the demos collection
13:00:06 <dcoutts__> scodil: especially if it describes the issue in the demo prog comments :-)
13:00:13 <scodil> ok sure. i'll email it to you. is your email on the gtk2hs webpage?
13:00:25 <fnord123> Is dons around? I quite like his blog articles
13:00:35 <Masklinn> @seen dons
13:00:36 <lambdabot> dons is in #ghc, #haskell.hac07, #haskell-overflow and #haskell. I last heard dons speak 5h 8m 50s ago.
13:00:45 <Masklinn> doesn't seem to be
13:00:53 <dcoutts__> scodil: the gtk2hs-devel list address is on the gtk2hs development page
13:01:00 <Masklinn> @quote dons
13:01:01 <lambdabot>  Haskell: The language that never sells out!
13:01:18 <scodil> wait nm it stopped working again. it worked for a second there
13:02:11 <[d-_-b]> why my ghc doesn't import the lib Data.Time.Clock ??
13:02:22 <[d-_-b]> Could not find module `Data.Time.Clock'
13:02:32 <glguy> Installation fails on Windows Server 2003 editions with Windows Server 2003 SP1 Installed:
13:02:35 <glguy> The error reported is
13:02:37 <glguy> Error 1718. File Filename was rejected by digital signature policy.
13:02:40 <glguy> This problem occurs when the computer has insufficient contiguous memory for Windows Server 2003 or Windows XP to verify that the .msi package or the .msp package is correctly signed.
13:02:44 <glguy> To resolve this issue:
13:02:47 <glguy> SORRY
13:02:59 * glguy right clicked on Putty with a bit too much in the clipboard...
13:06:50 <dcoutts__> scodil: I gotta go, email the gtk2hs-users list with your problem report (and example failing code) if you're still stuck.
13:06:55 <scodil> dcoutts__: what exactly does withGLDrawingArea do? does it have side effects? because I think the problem is that I've gotten into the habbit of declaring my expose callback as local to the realize callback, so that expose has access to things created in realize
13:07:02 <scodil> texture objects, display lists and whatnot
13:07:17 <scodil> ok sure i'll email it
13:07:25 <dcoutts__> scodil: check the code for details, it uses gl begin and end
13:07:40 <scodil> what? no way
13:08:08 <scodil> anyway, i'll look into it
13:08:13 <scodil> seeya
13:18:59 <glguy> hurray! VH still works with SP1
13:23:01 <chessguy> ok, it's time to turn this machine into a lean, mean, haskell-interpreting machine
13:23:42 <chessguy> i think i'm going to try ubuntu first, and hope that it can figure out my wireless drivers
13:24:11 * shapr boings
13:24:21 <glguy> OpenBSD is the operating system for wireless users (-:
13:24:36 <chessguy> really?
13:24:41 <glguy> yeah
13:24:46 <shapr> yeah
13:24:47 <chessguy> does it come with support for a broadcom
13:25:13 <glguy> yeah... my del laptop was supported
13:25:36 <chessguy> does it come with any haskell tools?
13:25:47 <glguy> ghc is in ports
13:25:48 <Excedrin> OpenBSD has fewer drivers than Linux, specifically because they've decided to not support drivers that require reverse engineering or binary only drivers...
13:26:06 <glguy> right, linux has  lot of adhoc added support
13:26:10 <Masklinn> OpenBSD drivers are often of a higher quality though
13:26:10 <SamB> what about buggy devices?
13:26:14 <glguy> requiring random tools
13:26:20 <Excedrin> dons uses OpenBSD
13:26:22 <Masklinn> and they have very strong support for networking stuff
13:26:23 <glguy> openbsd has it all integrated well and all using ifconfig
13:26:27 <chessguy> wait, OpenBSD isn't a linux distro?
13:26:28 <shapr> glguy: Hey, I like adhoc networks.
13:26:33 <Excedrin> and he has a page for openbsd Haskell stuff
13:26:35 <Masklinn> chessguy > no it's a BSD
13:26:38 <SamB> chessguy: hahaha
13:26:57 <kzm_> chessguy, it's a linux distro with a different kernel.
13:27:03 <chessguy> heh
13:27:05 <Masklinn> chessguy > shares UNIX roots with Linux, but that's as far as you go
13:27:22 <SamB> kzm: aren't you confused with Debian GNU/FreeBSD?
13:27:27 <Excedrin> and different user land tools
13:27:32 <glguy> its ilke linux but with better man pages
13:27:32 <chessguy> so what's my best bet to both get builtin support for my wireless and haskell tools?
13:27:38 <glguy> openbsd
13:27:57 <glguy> ?version
13:27:57 <lambdabot> lambdabot 4p302, GHC 6.5 (OpenBSD i386)
13:27:57 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
13:27:58 <kzm_> SamB, well - that was tounge-in-cheek.
13:28:01 <Excedrin> chessguy: what device do you have?
13:28:24 <glguy> openbsd drivers:
13:28:24 <glguy> openbsd drivers:bce (4) - Broadcom BCM4401 10/100 Ethernet device
13:28:24 <glguy> bcw (4) - Broadcom IEEE 802.11b/g wireless network device
13:28:24 <glguy> bge (4) - Broadcom BCM57xx/BCM590x 10/100/Gigabit Ethernet device
13:28:34 <chessguy> Excedrin, it's a broadcom
13:28:43 <Excedrin> glguy: were those added in 4.0?
13:28:52 <glguy> The bcw driver provides support for Broadcom BCM43xx based PCI/Cardbus
13:28:56 <glguy> Excedrin: possibly
13:28:59 <chessguy> it's this one, i thin:  Broadcom IEEE 802.11b/g wireless network device
13:29:02 <chessguy> +k
13:29:09 <glguy> HISTORY The bcw driver first appeared in OpenBSD 4.1.
13:29:34 * glguy runs the SNAPSHOT version of OpenBSD -- never had any issues
13:29:52 <chessguy> and you said there's a page that has haskell tools for OpenBSD?
13:30:01 <Excedrin> chessguy: you should look up the exact card version, sometimes the same model card has different versions that are supported or not
13:30:13 <Excedrin> http://www.cse.unsw.edu.au/~dons/haskell_openbsd.html
13:30:13 <lambdabot> Title: Haskell on OpenBSD
13:30:27 <glguy> chessguy: openbsd has "ports" which manages thirdparty software installs, ghc can be installed through ports
13:30:46 <chessguy> well, my device manager just says Broadcom 802.11g
13:30:56 <glguy> chessguy: and ghc 6.6 can compile on openbsd
13:31:00 <glguy> chessguy: without much fuss
13:31:24 <glguy> I submitted the patch to fix runtime linking in ghci so that ghci runs on openbsd 4.x
13:32:00 <shapr> I still don't like the BCM43xx much. I had one for a coupla months.
13:32:12 <glguy> I was stuck with it (work laptop)
13:32:24 <chessguy> heh. there is no CD image for the i386
13:32:33 <glguy> huh?
13:32:43 <glguy> I'm going to guess at this path:
13:32:44 * SamB finally has his MOO webserver giving the whole results for http://localhost:7780/help/subject!index
13:32:46 <thebug> solaris express supported bcm43xx quite well with its ndiswrapper on my amd64 laptop
13:32:57 <chessguy> oh wait
13:32:58 <glguy> ftp://ftp.openbsd.org/pub/OpenBSD/snapshots/i386/cd40.iso
13:33:00 <chessguy> i can't read
13:33:09 <SamB> @bot
13:33:10 <lambdabot> :)
13:33:17 <glguy> that URL might be wrong... it's from memory
13:33:20 * SamB wonders why oh.
13:33:22 <shapr> chessguy: That happens to me sometimes too.
13:33:26 <SamB> ehehe
13:33:27 <earthy> pida looks to me like a no-go area
13:33:44 * SamB finally has his MOO webserver giving the whole results for http://naesten.dyndns.org:7780/help/subject!index
13:33:45 <earthy> something about GTK+ not being mac native :)
13:33:45 <lambdabot> Title: Available Help Indices
13:33:49 <shapr> @remember SamB * SamB wonders why oh.
13:33:57 <SamB> heh
13:34:09 <shapr> That describes about half of my waking time.
13:34:15 * shapr wonders why .. oh.
13:34:21 <SamB> http://naesten.dyndns.org:7780/help/subject!index
13:34:23 <lambdabot> Title: Available Help Indices
13:34:31 <SamB> oh, oops, it showed that already.
13:34:40 * SamB doesn't know how he missed it
13:34:46 <SamB> *she, rather
13:35:04 <shapr> Are you female?
13:35:09 <shapr> Samantha B?
13:35:41 * glguy doesn't think so:  (*) SamB finally has his MOO 
13:35:42 <SamB> no
13:35:51 <SamB> I meant lambdabot is a she, not an it
13:35:53 <SamB> ;-)
13:35:58 <shapr> oh
13:36:09 <mbishop> lambdabot is a dirty whore
13:36:11 <SamB> as in "oh, oops, she showed that already."
13:36:13 <mbishop> @botsnack
13:36:14 <lambdabot> :)
13:36:16 <glguy> ?vixen are you a dirty whore?
13:36:17 <lambdabot> i truely am
13:36:18 <shapr> Not that gender makes any difference on irc.
13:36:36 <shapr> hiya bringert, did you see yourself in that .signature on haskell-cafe?
13:36:40 <chessguy> glguy, that links work
13:36:54 <chessguy> *link works
13:36:56 <bringert> shapr: hi. nope
13:36:56 <SamB> shapr: haven't you seen my RealName? my darcs patches? my emails?
13:37:02 <shapr> SamB: Yes, I was joking.
13:37:29 <glguy> chessguy: I've learned the ftp structure because when I install stuff with pkg_add, I'll type: PKG_PATH=ftp://ftp.openbsd.org/pub/OpenBSD/snapshot/packages/i386
13:37:33 <edi> Anybody has HXT experience? I can't understand how to apply some arrow to all the subnodes of the node I am at.
13:37:34 <shapr> I tend to dig up info on people that I know for any length of time, whether in person or online.
13:37:36 <glguy> for some reason, I'm too lazy to add that to my profile
13:37:53 <vegai> ibid: No, I didn't.
13:38:07 <vegai> dcoutts__: Ok, I'll look forward to it.
13:38:42 <shapr> bringert: I saw "Surely making someone not survive must count as non-verbal communication --bring"
13:39:09 <edi> bringert: yo. Do you have any knowledge of HXT?
13:39:23 <bringert> edi: nope, sorry
13:39:25 <shapr> edi: I've used HXT, but not the arrow interface.
13:40:04 <chessguy2> ok, now i can hose my other hard drive
13:40:08 <chessguy2> m
13:40:10 <chessguy2> jj/
13:40:12 <edi> shapr: ah. I can't understand how to apply some arrow to all the result of a |multi ..|, so I'm stuck.
13:40:14 <chessguy2> d'oh, this keyboard sucks
13:40:31 <shapr> edi: What are the types?
13:40:37 <bringert> shapr: heh, interesting. where did he find that?
13:40:43 <vegai> shapr: done any cool Happs things recently? :)
13:40:43 <shapr> bringert: http://www.haskell.org/hawiki/QuotesPage
13:40:45 <lambdabot> Title: QuotesPage - The Haskell Wiki
13:41:09 <edi> shapr: sigh.
13:41:10 <shapr> vegai: I've just been learning more about HAppS internals while cleaning up and extending my wiki.
13:41:26 <shapr> edi: Hm, I think I have used a multi before...
13:41:30 <edi> shapr: Arrow a => a XmlTree XmlTree
13:41:42 <shapr> And what's the type of a multi?
13:41:51 <shapr> I should remember that, I'm sure... but it has been a few years :-/
13:41:54 <edi> multi :: (ArrowTree a, Tree t) => a (t b) c -> a (t b) c
13:42:35 <shapr> Sounds like you've almost got it matched up.
13:42:58 <bringert> shapr: ah, yes
13:43:10 <edi> HXT does not expose the node datatype constructor, so I can't simply pattern-match, extract the list, and map the same filter to every subtree...
13:43:21 <shapr> It's too bad there's no good way to put multiline quotes into lambdabot, I have several that are very funny.
13:43:59 <Excedrin> is a LanguageDef required in order to use the TokenParser stuff in Parsec?
13:44:17 <bringert> shapr: yeah, there are a lot of good ones on that wiki page
13:44:30 <shapr> And I have more in my personal quote collection.
13:44:34 <shapr> Some that are definitely NSFW.
13:45:17 <chessguy> ok, here goes nothing
13:45:23 * shapr explodes!
13:45:40 <chessguy> oops
13:45:44 <edi> shapr: now I have an XmlTree which is made of 10 subtrees of the same shape.
13:46:00 <shapr> :: Orchard
13:46:01 <bringert> shapr: are they SF#H?
13:46:09 <shapr> Hm, probably not.
13:46:39 <edi> shapr: I can take the information out directly, getting a list of things
13:46:46 * chessguy hopes he e
13:46:57 <edi> but I rather prefer a list of lists, that is, reduce the subtrees to the only useful informations
13:47:01 * chessguy hopes he doesn't get stuck logging onto IRC from this desktop for weeks
13:47:05 <bringert> does anyone have a Zaurus SL-5600 for sale?
13:47:10 <edi> filter out the unuseful one, but keeping the shape.  makes any sense?
13:47:15 <chessguy> brb
13:47:17 <edi> *ones
13:47:28 <fnord123> bbiab
13:48:20 <Philippa> bringert: I don't, and nor am I selling my SL-C3200 :-)
13:49:19 * bringert wants to run Opera with XHTML+Voice
13:49:47 <shapr> edi: Here's what I did when I was trying to figure out HXT - http://www.scannedinavian.com/~shae/Demo_Hxml.hs
13:50:20 <shapr> bringert: May I suggest a Nokia 770?
13:50:41 <bringert> shapr: is there an XHTML+Voice browser for it?
13:50:44 <shapr> Or the new and unreleased Nokia 870?
13:50:53 <shapr> I doubt it...
13:50:54 <Saulzar_> edi, Can use a mapA on the extracted children, is the HXT arrow an ArrowChoice?  Something like getChildren >>> mapA foo
13:51:11 <bringert> that's all I want it for atm
13:51:17 <shapr> But the 770 runs various open source browsers, and it does have some flavor of Opera on it.
13:51:36 <edi> shapr: argh.
13:51:44 <edi> Saulzar_: mapA... uhm.
13:51:46 <shapr> edi: didn't help?
13:51:59 <bringert> yeah, it seems cool. but this is for research stuff, and I need XHTML+Voice
13:52:05 <edi> Saulzar_: I believe it has got lots of features, let me check
13:52:21 <edi> Saulzar_: http://www.fh-wedel.de/~si/HXmlToolbox/hdoc_arrow/Control-Arrow-ArrowIf.html
13:52:21 <shapr> bringert: Is Opera the only XHTML+Voice browser?
13:52:24 <lambdabot> http://tinyurl.com/ygbcxs
13:52:40 <bringert> shapr: some Netfront versions support it too
13:53:00 <shapr> Don't think I've heard of that.
13:53:07 <bringert> shapr: X+V is not very alive, but it should be. It's really cool
13:53:19 <edi> Saulzar_: it is crazy because it is _based_ on ArrowList, but it has fot no mapA!
13:53:27 <Saulzar_> edi, Don't think it's a standard function - but you can make one to map over each element in a list
13:53:36 <bringert> you can run spoken language apps integrated in web pages
13:53:43 <shapr> Sounds way cool.
13:53:48 <edi> Saulzar_: I tried but HXT does not export the tree constructors
13:54:53 <Saulzar_> edi, Doesn't getChildren give you a list of subtrees?
13:55:20 <edi> Saulzar_: nope, an XmlTree
13:55:28 <Saulzar_> Ah...
13:55:49 <edi> I know it is a Rose Tree, but I can't chop it into parts
13:57:46 <shapr> A Rose Tree by any other branch... will still be as prickly!
13:58:16 <edi> Saulzar_: I have 10 <div> which contain 2 <div> each, and inside the former there is some information (let's call it A), inside the latter some other information (let's call it B).  I can get as :: [A] and bs :: [B] with two passes.  But what I really want is foo :: [(A,B)] in one pass.
13:58:55 <edi> getChildren >>> ... >>> multi (hasName "div" >>> ...) -- gets the 10 outer divs
13:59:30 <Saulzar_> By the definition given in here: type XmlFilter = XmlTree -> [XmlTree]   and getChildren is an XmlFilter ...
13:59:42 * SamB wonders if there is a nicer core database than jhcore
13:59:59 <edi> getChildren :: (ArrowTree a, Tree t) => a (t b) (t b)
14:00:08 <edi> uhm
14:00:32 <Saulzar_> Hehe, maybe it's because I'm looking at the beginners intro :)
14:00:33 <edi> I think the list passing is internal to >>>
14:00:43 <edi> ah :D
14:00:54 <edi> I've gone through that.
14:01:00 <dino-> I have a question about the 99 Haskell Questions, number 23 here: http://haskell.org/haskellwiki/99_questions/21_to_28
14:01:02 <lambdabot> Title: 99 questions/21 to 28 - HaskellWiki
14:01:13 <dino-> The Alternative Solution
14:01:16 <edi> Look at 3.3 (>>>)    :: XmlFilter -> XmlFilter -> XmlFilter
14:01:25 <edi> (f >>> g) t =  concat [g t' | t' <- f t]
14:01:47 <dino-> The rnd_select is doing randomR (0, length l)  I'm thinking it should actually be (0, (length l) - 1)
14:01:53 <liquidengineer> hello
14:01:58 <liquidengineer> I have a ghc question
14:02:09 <liquidengineer> I'm using 6.6
14:02:20 <dino-> Without that - 1 it seems to be able to generate (max + 1) indices into the list.
14:02:31 <liquidengineer> 6.6 has the fromIntegral
14:02:35 <liquidengineer> function
14:02:53 <liquidengineer> I need to run my code on ghc 6.4.2
14:02:57 <liquidengineer> it only has fromInt
14:03:02 <liquidengineer> are these equivilent?
14:03:38 <dino-> It seems to work I guess because the removeAt function is kind to this bogus index.
14:04:11 <kzm_> liquidengineer, I'm fairly sure fromIntegral is in 6.4.2.
14:04:47 <liquidengineer> Is there a way I can check?
14:05:03 <kzm_> ghci and :i fromIntegral?
14:06:03 <emu> any neato latex command to use in place of ">>="?
14:06:05 <dino-> But, wow, a very cool solution. I was freaking out at first wondering where the : or ++ was happening to make the new list of randomly selected numbers.
14:06:07 <Cale> liquidengineer: fromIntegral has been in every implementation since before Haskell 98
14:06:22 <liquidengineer> Okay
14:06:25 <liquidengineer> then I'm probably set
14:06:28 <Cale> fromInt is very old, basically no Haskell implementation you use will have it
14:07:14 * chessguy sighs. #openbsd wasn't ha
14:07:19 <chessguy> wasn't any help. bunch of jerks
14:08:02 <Cale> chessguy: what's up?
14:08:12 <Cale> I think dons runs openbsd
14:08:27 <chessguy> i'm trying to install openbsd on my laptop
14:08:39 <chessguy> the install notes assume i want to share the drive with windows. i don't
14:08:48 <glguy> chessguy: #haskell has spoiled you
14:08:51 <chessguy> i asked for assistance and got mocked and banned
14:09:00 <Masklinn> ouch
14:09:29 <glguy> chessguy: if you don't want to share the drive, when the installer asks "should I use the whole drive?"
14:09:32 <glguy> say yes
14:09:45 <chessguy> glguy, right, but then i have to figure out how to partition the thing
14:09:45 <Nafai> glguy: #haskell is extremely open and friendly compared to most channels
14:10:01 <Nafai> glguy: Actually that's one of the reasons I still intend on learning Haskell
14:10:03 <glguy> chessguy: the install notes describe using disklabel to do it
14:10:06 <chessguy> and i don't have a partitioning scheme to use, because the install notes assume i'm splitting it
14:10:16 <glguy> chessguy: you need ot keep reading
14:10:30 <glguy> chessguy: first the notes talk about partitioning with fstab if you are spliting
14:10:39 <edi> Saulzar_: It's funny that if I only want 1 information, it's an Haskell oneliner, but if I want some more structure, it's a big headache. This thing needs more study :)
14:10:43 <glguy> later they talk about making slices with disklabel, openbsd looks at the slices
14:10:43 <chessguy> anyway, there was no call for them being so stupid about it
14:11:09 <glguy> chessguy: if your skin isn't thick enough... you might try a different OS
14:11:11 <Philippa> I think #openbsd's a development-only chan
14:11:20 <Cale> edi: hm?
14:11:35 <glguy> openbsd's community isn't particularly open to new users... but once you get used to it they are fine
14:11:58 <Philippa> unless you ask awkward questions about arm ports
14:11:58 <glguy> If you come here asking "How do I get the String out of IO String"
14:12:02 <glguy> you'll get an answer
14:12:16 <glguy> #openbsd is likely to say "stfu newb, rtfm"
14:12:25 <glguy> because you can infact find that out from the docs
14:12:29 <Philippa> yeah. Especially when there isn't an M
14:12:49 <chessguy> they didn't even give me a chancd
14:12:49 <glguy> openbsd's man pages are usually pretty good
14:13:04 <edi> Cale, extracting that information is easy because it's tagged by id="..". But I can't see how to proceed to extract also some other related information to each tagged one, and return it together with the former.
14:13:18 <glguy> I'm not going to defend the obsd community, but the OS is sweet
14:13:34 <Cale> :t (***)
14:13:36 <lambdabot> forall (a :: * -> * -> *) c' c b' b. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
14:13:48 <Cale> Might that be useful?
14:13:51 <Philippa> glguy: my housemate spent an awful lot of time building stuff on her zaurus before running into trouble...
14:13:53 <Cale> er
14:13:58 <Cale> :t (&&&)
14:14:00 <lambdabot> forall (a :: * -> * -> *) c' c b. (Arrow a) => a b c -> a b c' -> a b (c, c')
14:14:06 <Cale> or perhaps that
14:14:22 <glguy> Philippa: how do you mean?
14:14:36 <edi> Cale, yes, at some point I thought applyA was the answer, but I couldn't figure out how to apply it.
14:14:50 <edi> http://www.fh-wedel.de/~si/HXmlToolbox/hdoc_arrow/Control-Arrow-ArrowList.html
14:14:53 <lambdabot> http://tinyurl.com/upyok
14:14:53 <Philippa> I've forgotten the details, unfortunately. But being on a niche architecture that nobody's got a machine for = not a lot of stuff built for you...
14:15:03 <Philippa> and it kinda got worse from there
14:15:04 <goltrpoat> reminds me..  [1..5] +++ [1..5] forces a panic in ghci (6.6)
14:15:05 <glguy> Philippa: oh, yeah
14:15:16 <glguy> Philippa: not many people have a 700 toy computer
14:15:20 <edi> +++ ??
14:15:22 <goltrpoat> 6.4.* seem to error out appropriately
14:15:24 <glguy> Philippa: that you can't buy locally
14:15:25 <Philippa> generic arm works
14:15:40 <Philippa> (no, really, I'm running a generic arm debian in a chroot on mine as well as Cacko)
14:15:58 <goltrpoat> edi:  yeah
14:16:05 <Philippa> and as soon as you step off the desktop, arm's really rather common
14:16:06 <edi> :t (+++)
14:16:07 <lambdabot> forall (a :: * -> * -> *) c' c b' b. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
14:16:17 <edi> eek.
14:16:18 <Philippa> a hell of a lot of PDAs're running on it, for example
14:16:21 <glguy> Philippa: you have a zaurus too?
14:16:23 <goltrpoat> no, i know it won't typecheck.  im saying it should result in a panic :)
14:16:27 <Philippa> yeah. They're not toys, btw :-)
14:16:28 <Cale> edi: is your code pasted somewhere?
14:16:29 <goltrpoat> er
14:16:30 <goltrpoat> shouldn't
14:16:32 <edi> Cale, nope
14:16:36 <Cale> Can I see the xml which you're trying to parse?
14:17:05 <Philippa> mine's within a factor of two in all regards of the old laptop I borrowed when my desktop fell over, and rather more usable for many tasks
14:17:20 <Philippa> already got hugs on it, need to upgrade the debian image to testing and get GHC6.6 on there
14:17:37 <glguy> Philippa: so you use debian on it exclusively?
14:18:02 <glguy> or both that an obsd? (or just your roommate used obsd?)
14:18:05 <Philippa> nope, I've got a drive image mounted on loopback that I chroot into - most of the time it's running a modded version of the default OS that ships with it
14:18:12 <glguy> ohh
14:18:15 <Philippa> was my housemate who had OBSD on it, forget what she's running now
14:20:14 <edi> Hiya monochrom!
14:20:17 <chessguy> ok, so all they had to do was tell me to skip the stuff about fdisk and use something similar to the scheme in disklabel. i don't think it's unreasonable to want that
14:20:46 <monochrom> <3
14:21:31 <edi> (I'm xerox) You surely know how to do something in HXT. In particular: apply the same arrow to 10 same-shaped subtrees I've got through getChildren >>> ... >>> multi (getChildren >>> hasName "div" >>> ...).
14:23:49 <LordBrain> does ghc6.6 come with QuickCheck?
14:26:22 <Bourbaki> moin
14:26:26 <Bourbaki> dons you there?
14:26:48 <Bourbaki> is the guy atm in the channel who wrote the audio tool in haskell?
14:27:13 <chessguy> glguy, do i need to get the file sets separately?
14:27:17 <edi> Bourbaki: nope
14:27:24 <Bourbaki> dang
14:27:26 <Excedrin> the thing that talks to supercollider?
14:27:45 <glguy> chessguy: are you at the stage where you download (for example) base40.tgz man40.tgz, etc?
14:27:52 <Bourbaki> is there any dsp tool for haskell where i can just write the height of the current wave to the sound board?
14:28:03 <Bourbaki> or do i have to record the wave and then put it to the board?
14:28:43 <chessguy> it's asking me to install the file sets. the only one available is bsd.rd, though. and when i try to install that it keeps taking me around in circles
14:29:00 <glguy> chessguy: you might need a different mirror then
14:29:09 <glguy> chessguy: there are a lot more than bsd.rd
14:29:20 <chessguy> oh, that's a site?
14:29:42 <Gwern> hey everybody
14:29:49 <chessguy> i thought all the install stuff i needed to get a minimal system going would be on the CD.
14:30:10 <glguy> chessguy: nope, it's so small because you download everything you need
14:30:22 <chessguy> the network install failed, probably because i'm trying to connect wirelessly. i assumed i could just set that up later, but not if i need to be downloading stuff
14:30:40 <glguy> do you have a wired network to connect to in the mean-time?
14:30:47 <chessguy> well yeah, this one
14:30:51 <Gwern> I have a question: I'm reading peyton's paper on financial contracts in haskell, and he says the incrediably obvious solution is a 'combinator library'. but what is a combinator library? is it just a bunch of functions and types built out of a few well-chosen primitives for the relevant domain?
14:31:29 <norpan> Gwern: yeah
14:31:39 <chessguy> let me see if i can find another ethernet cable around here that works
14:31:46 <shapr> @wikipedia combinator
14:31:48 <lambdabot> No Result Found.
14:31:51 <shapr> hmm
14:31:57 <Gwern> shapr: if there is a wikipedia article on it, I wrote it...
14:32:06 <Gwern> but it was so crappy I'm here asking questions
14:32:17 <norpan> Gwern: basically a combinator is a function that creates data objects
14:32:19 <SamB> "combinator" seems to now mean "fun things"
14:32:37 <norpan> by combinating smaller elements
14:32:40 <glguy> Parsec is a Parser-combinator library, for example :)
14:32:50 <Gwern> norpan: aren't those constructors tho?
14:32:55 <shapr> Gwern: http://en.wikipedia.org/wiki/Combinatory_logic ?
14:33:09 <norpan> constructors are the primary things in the data type
14:33:13 <Gwern> shapr: see it. didn't really help
14:33:15 <Gwern> *seen
14:33:39 <norpan> normally you don't use the constructors directly, you use the combinators
14:33:59 <shapr> That way you get certain spiffy properties.
14:34:00 <emu> LordBrain: its under Test.QuickCheck
14:34:03 <chessguy> test
14:34:09 <chessguy> wow, i didn't even get booted
14:34:16 <Gwern> ok... so a lisp analogy would be a bunch of list functions defined in terms of cons, car, and cdr?
14:34:23 <shapr> So yeah, from one viewpoint it's just a bunch of functions and types built out of a few well-chosen primitives.. but that describes *everything* in the CS world.
14:34:24 <Gwern> (am I even close?)
14:34:44 <LordBrain> emu: it seems to be left out of the debian package..
14:34:51 <emu> LordBrain: there is an extra-libs package
14:34:57 <LordBrain> oh
14:35:00 <norpan> i don't think a combinator is a very well-defined concept though
14:35:22 <emu> a function with no free variables
14:35:29 <shapr> Gwern: Maybe it would help to read John Hughes' tutorial on writing your own combinator libraries?
14:35:33 <Gwern> btw, my wikipedia article is at [[Combinator library]]
14:35:39 <Gwern> shapr: I'll look for that
14:35:43 <SamB_XP> emu: except none of them are!
14:35:55 <SamB_XP> well, they rarely are...
14:36:44 <norpan> combinators are intelligent constructors
14:36:53 <Gwern> "Yampa is a domain-specific language embedded in the lazy functional language Haskell (i.e., it is a Haskell combinator library). " <-- well, that sort of makes sense
14:36:53 <pejo> Gwern, there is a technical report for parsec that contains some pointers to other tutorials as well.
14:36:57 <SamB_XP> `on` is actually a combinator
14:37:05 <Gwern> pejo: thanks, I'll look for that too
14:37:26 <Philippa> combinators are (supposedly) functions without any free variables
14:37:34 <Gwern> "John Hughes, The Design of a Pretty-Printing Library,"?
14:37:39 <Philippa> only the value of "free" involved is a bit interesting in the context of top-level bindings
14:38:02 <chessguy> heh. by the time i actually get through this install process, i'll be pretty darn good at it
14:38:12 <norpan> i don't understand what a function with a free variable is
14:38:29 <emu> norpan: a variable not defined within the scope of the function
14:38:52 <emu> y is a free variable: \x -> y
14:39:17 <norpan> yeah i know what a free variable is but i don't see how it makes sense here
14:39:56 <norpan> no top-level functions have free variables
14:40:03 <Gwern> shapr: http://citeseer.ist.psu.edu/hughes95design.html "The Design of a Pretty-printing Library (1995)"?
14:40:06 <lambdabot> Title: The Design of a Pretty-printing Library - Hughes (ResearchIndex)
14:40:12 <emu> norpan: sure they do
14:40:38 <emu> they often refer to other, outside, function and variable definitions
14:40:43 <glguy> toplevel: f = g; g = 1
14:40:56 <norpan> so a combinator may not use a helper function? that's a strange definition
14:40:56 <emu> f = 1 + 1 -- (+) is free in f
14:41:04 <emu> combinators are self-contained
14:42:01 <goltrpoat> by that logic, I is not a combinator, because I = S K K
14:42:15 <Cale> lisppaste2: url
14:42:16 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/Haskell and enter your paste.
14:42:17 <norpan> no, I = \x -> x
14:42:29 <goltrpoat> right, but S K K works as a definition too, right
14:42:37 <lisppaste2> Cale pasted "scraper" at http://paste.lisp.org/display/32533
14:42:43 <norpan> S K K is a pretty bad definition of I
14:42:52 <goltrpoat> how come?
14:43:04 <Philippa> goltrpoat: I can be defined in such a way as to be a combinator, that'll do...
14:43:07 <norpan> because \x -> x is much clearer :)
14:43:12 <goltrpoat> hehe
14:43:26 <int-e> norpan: but invalid in S K combinator calculus
14:43:27 <glguy> > ap const const 1
14:43:28 <lambdabot>  1
14:43:40 <glguy> > let i = ap const const in i "fun"
14:43:42 <lambdabot>  "fun"
14:43:52 <norpan> but this is not the kind of combinators we're talking about when we talk about a combinator library
14:44:01 <norpan> is it?
14:44:10 <goltrpoat> that was part of my question :)
14:45:24 <ph8> does "ls <- readFile f" read each character of the file provided into 'ls' and loop until finished?
14:45:25 <chessguy> glguy, hmmm. what's a good ftp site to pull file sets from?
14:45:33 <scodil> is there anymore danger in using (unsafePerformIO . readArray) than in using unsafeFreeze?
14:45:34 <glguy> rt.fm works
14:45:46 <ph8> where can that be found?
14:46:06 <glguy> ftp://rt.fm/pub/OpenBSD/snapshots/i386/
14:46:19 <monochrom> Eh!  ap = S ??!!
14:46:30 <glguy> AH HA!
14:46:31 <Excedrin> ph8: no, ls is a string that represents the contents of the file, it's filled in lazily as you use it
14:46:45 <hyrax42> d'oh I need HXT
14:46:50 <chessguy> cool, it's working now
14:46:54 <hyrax42> I forgot I only have haxml
14:46:56 <ph8> ah ok, so to get say frequencies of each character i need to loop through it in a subtle way? i'll have to look that up
14:46:59 <glguy> > let i = ap const undefined in i "fun"
14:47:00 <lambdabot>  "fun"
14:47:03 <ph8> so it's a [char]?
14:47:18 <Excedrin> ph8: you don't need to loop, and yes it's a [char]
14:47:29 <ph8> how do i pull things out of it?
14:47:32 <monochrom> loops are not subtle :)
14:47:35 <ph8> heh
14:48:10 <hyrax42> ph8, if you want to collect frequencies
14:48:15 <monochrom> Consider "length".  It loops through a string and counts all characters as though they're all the same.
14:48:19 <hyrax42> I would use DiffArray Char Int
14:48:34 <monochrom> A generalization of "length" will count things in a more fine-grained way.
14:48:34 <SamB_XP> hyrax42: um
14:48:36 <ph8> I'm trying to do it with Maps as part of a project
14:48:41 <SamB_XP> can't one just do...
14:48:46 <SamB_XP> @type accumArray
14:48:46 <ph8> so i'm trying to build a (Char, Int) map, that i can then output
14:48:47 <lambdabot> forall e i a. (Ix i) => (e -> a -> e) -> e -> (i, i) -> [(i, a)] -> Array i e
14:48:55 <monochrom> Yeah, for example using an array rather than one single int for the accumulator.
14:49:05 <Excedrin> ph8: http://rafb.net/paste/results/E9hwhB66.html -- I know you're not going to use this, since you're using a map...
14:49:12 <hyrax42> Maps will be slow, I think
14:49:27 <ph8> probably, from the sound of things - but it's in the assignment instructions
14:49:32 <SamB_XP> oh.
14:49:34 <SamB_XP> whatever.
14:49:47 <SamB_XP> @type Data.Map.insertWith
14:49:48 <monochrom> You should know how to implement "length" on your own first.
14:49:48 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> k -> a -> Data.Map.Map k a -> Data.Map.Map k a
14:50:42 <scodil> what happens if you do str <- readFile and then modify the file before str is used? or is this prevented somehow with locking?
14:50:47 <hyrax42> ?hoogle insertWithDefault
14:50:48 <lambdabot> No matches found
14:50:53 <hyrax42> ?hoogle insertWith
14:50:54 <lambdabot> Data.IntMap.insertWith :: (a -> a -> a) -> Key -> a -> IntMap a -> IntMap a
14:50:54 <lambdabot> Data.Map.insertWith :: Ord k => (a -> a -> a) -> k -> a -> Map k a -> Map k a
14:50:54 <lambdabot> Data.IntMap.insertWithKey :: (Key -> a -> a -> a) -> Key -> a -> IntMap a -> IntMap a
14:51:02 <ph8> yeh i'm toying with insertWith atm
14:51:03 <ph8> atm i have
14:51:09 <ph8> >	ls <- readFile f
14:51:09 <ph8> >	let result = insertWith insertChar 1 ls result
14:51:11 <hyrax42> ?paste
14:51:11 <lambdabot> http://paste.lisp.org/new/haskell
14:51:13 <ph8> but that won't work right?
14:51:15 <ph8> sorry hyraz
14:51:17 <ph8> * x
14:51:32 <hyrax42> ph8: pre-emptive in case you were about ot put lots of code
14:51:54 <hyrax42> ?docs Data.Map
14:51:55 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
14:52:12 <Excedrin> ph8: did you see what I pasted? copy it to a file called freq.hs, then do: runhaskell freq.hs
14:52:13 <monochrom> Have you written "length" yourself?
14:52:45 <lisppaste2> Cale annotated #32533 with "extended scraper" at http://paste.lisp.org/display/32533#1
14:53:16 <ph8> hmm interesting
14:53:36 <Cale> (for anyone playing along with edi and I, HXT is awesome, isn't it? :)
14:54:00 <hyrax42> Cale: I want to try it out
14:54:01 <monochrom> HXT is awesome.  It will take most people another 20 years to realize that.
14:54:03 <ph8> i'm not entirely sure i understand it though Excedrin :/
14:54:31 <hyrax42> cale: can you annotate with a transcript of running that?
14:54:33 <monochrom> Right now they're still struggling with counting things!
14:54:36 <Cale> sure
14:54:43 <hyrax42> thanks
14:54:54 <lisppaste2> Cale annotated #32533 with "results" at http://paste.lisp.org/display/32533#2
14:54:55 <Excedrin> ph8: break it down one piece at a time
14:55:35 <ph8> well mapM_ print.. i don't know what the mapM is doing, since all this is in main?
14:55:40 <ph8> print is obviously a print instruction
14:55:49 <ph8> the print instruction that belongs to some mapM_ type?
14:56:19 <ph8> i'm used to lhs, is there a huge format difference between that and hs?
14:56:27 <Cale> I can't imagine how messy and horrible this would look like with someone trying to struggle it out with regexps
14:56:36 <hyrax42> just the "> " at the beginning of lines
14:56:39 <Excedrin> lhs is comments by default, with > indicating code
14:56:42 <monochrom> haha regexps
14:56:48 <ph8> good if that's the only difference
14:56:50 <ph8> am i right so far?
14:57:10 <ph8> i guess i need to lookup what those \ mean
14:57:15 <hyrax42> cale: that is quite good for such short code
14:57:17 <ph8> i know it's creating pseudo functions or something
14:57:21 <ph8> confusing as hell though
14:57:44 <Cale> hyrax42: yeah, basically, you tell it where you want to look and it gets stuff for you :)
14:57:49 <hyrax42> ph8: where are you?
14:57:52 <glguy> ph8: you might want to read through a whole tutorial
14:58:02 <Cale> It's about as short as I could ever expect such code to be.
14:58:09 <ph8> heh, at the mapM_ part, from above :p
14:58:20 <hyrax42> ph8: physically!
14:58:23 <Excedrin> (or LaTeX \begin{code} indicating code)
14:58:34 <ph8> oh, in the UK
14:58:36 <ph8> why do you ask?
14:58:44 <hyrax42> just curious at the timing of the assignment
14:58:51 <hyrax42> haven't you all broken up over there by now?
14:58:54 <ph8> your initials aren't PC are they? ;)
14:58:55 <Excedrin> @type mapM_
14:58:57 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> [a] -> m ()
14:59:11 <Excedrin> @type print
14:59:12 <lambdabot> forall a. (Show a) => a -> IO ()
14:59:31 <Excedrin> @type mapM_ . print
14:59:32 <lambdabot>   Couldn't match `a -> m b' against `IO ()'
14:59:33 <lambdabot>    Expected type: a1 -> a -> m b
14:59:37 <ph8> looks like i've got more reading to do before i come back to this ;)
14:59:41 <hyrax42> ?type deep
14:59:42 <lambdabot> Not in scope: `deep'
14:59:48 <Excedrin> @type mapM_ print
14:59:50 <lambdabot> forall a. (Show a) => [a] -> IO ()
14:59:51 <hyrax42> ?type Text.XML.HXT.Arrow.deep
14:59:53 <lambdabot> Couldn't find qualified module.
14:59:57 <Gwern> http://en.wikipedia.org/wiki/Combinator_library <-- woot. now it looks like it was written by someone who actually had a clue what they were talking about :) (seriously tho, I'd appreciate anyone taking the time to check it over)
15:00:13 <hyrax42> is deep from Arrow or from HXT?
15:00:14 <ph8> oh hyrax, you're in canada
15:00:21 <ph8> i thought you were my professor for a moment!
15:00:23 <hyrax42> ph8: I know
15:00:27 <ph8> heh
15:00:32 <hyrax42> oh ha
15:00:34 <ph8> it's a holiday project
15:00:40 <hyrax42> ph8 ah, I see
15:00:48 <hyrax42> I hope you have some time to work on it yet
15:00:55 <monochrom> deep is in Control.Arrow.ArrowTree
15:01:07 <monochrom> Control.Arrow.ArrowTree is in HXT
15:01:14 <hyrax42> monochrom: thanks
15:01:18 <ph8> holidays began yesterday, i've just started reading a book on Haskell.. although i've been lectured in it all year so I should probably be a bit better than I am by now!
15:01:26 <glguy> Cale: have you guys converted any of that to proc notation?
15:01:42 <hyrax42> well assuming you have until Jan 20-odd to do it (you guys always get long holidays)
15:01:50 <hyrax42> try starting at the basics
15:01:54 <ph8> ?DOCS READFILE
15:01:55 <lambdabot> Unknown command, try @list
15:02:01 <ph8> oops at the caps
15:02:04 <hyrax42> ?index readFile
15:02:05 <lambdabot> System.IO, Prelude
15:02:09 <ph8> does it return an array?
15:02:17 <hyrax42> no
15:02:20 <ph8> does that mean i can do some fancy recursive head/tail'ing to get it into my insert function?
15:02:21 <hyrax42> ?type readFile
15:02:21 <ph8> bugger
15:02:22 <lambdabot> FilePath -> IO String
15:02:37 <hyrax42> ph8: start with the basics
15:02:40 <hyrax42> you have a couple of weeks
15:02:51 <ph8> ok, i'm happy with arrays and basic definitions
15:02:54 <ph8> i think anyway
15:02:55 <hyrax42> learn Haskell from the ground up, this will be trivial then
15:03:07 <ph8> and lists
15:03:08 <hyrax42> lists or arrays?
15:03:12 <ph8> both
15:03:19 <ph8> actually, is there a difference?
15:03:24 <hyrax42> yes!
15:03:42 <ph8> well lists are [Char]
15:03:49 <hyrax42> still, I would recommend looking at yaht
15:03:53 <Cale> glguy: I suppose I could.
15:03:57 <hyrax42> the first 3-5 chapters
15:04:02 <ph8> yaht?
15:04:03 <hyrax42> ?where yaht
15:04:03 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
15:04:08 <Cale> glguy: I think that in this case, it's actually simpler in ordinary notation
15:04:12 <ph8> i have the craft of functional projgramming by THompson
15:04:16 <ph8> i'll take a look at that too, cheers
15:04:22 <ph8> typos galore tonight
15:04:23 <glguy> Cale: yeah, since it's all one pipeline
15:04:30 <glguy> Cale: I was just thinking about what it might look like
15:04:42 <hyrax42> because, no offense meant, you do not seem "happy" with lists &c.
15:04:57 <hyrax42> and if you get a good grasp of the basics, this should be a pretty easy assignment then :)
15:05:09 <monochrom> The present scraper code of Cale and edi does not yet benefit from the proc notation.
15:05:37 <hyrax42> ther was a new release of HXT recently, was there not?
15:05:53 <monochrom> HXT 7.0 to celebrate GHC 6.6
15:06:07 <hyrax42> is the author in here?
15:06:25 <hyrax42> hard to match real names to IRC nicks
15:06:43 <edi> Cale: do you think that is really different from getting the informations in different passes and zipping them together?
15:06:58 <ph8> thanks hyrax
15:07:32 <hyrax42> ph8: no problem
15:07:42 <monochrom> proc notation for arrows, do notation for monads, pointful notation for functions --- their use fall under the same principle.  If the dataflow is straightforward, use pointfree; if the dataflow is messy, use pointful.
15:08:07 <hyrax42> what is proc notation
15:08:25 <allbery_b> used with arrows IIRC
15:08:48 <sorear> do-notation for arrows
15:08:56 <hyrax42> ph8: yeah, in yaht take good care up to end of ch4
15:08:57 <sorear> like proc x <- y <- z
15:09:02 <monochrom> x &&& y = proc e -> do { a <- x -< e; b <- y -< e; returnA -< (a,b) }
15:09:31 <monochrom> proc x <- y <- z  is syntax error IIRC
15:09:47 <hyrax42> monochrom: ah ok
15:10:00 <hyrax42> ok I need to stop wasting time
15:10:16 <monochrom> Don't waste time on non-haskell things.
15:10:35 <hyrax42> monochrom: I'm wasting time from haskell things :p
15:10:40 <edi> :t writeFile
15:10:42 <lambdabot> FilePath -> String -> IO ()
15:10:48 <edi> :index writeFile
15:10:58 <edi> ?index writeFile
15:10:58 <lambdabot> System.IO, Prelude
15:11:05 <edi> ?docs System.IO
15:11:05 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html
15:12:57 <monochrom> Perhaps you want the results to be a flat tuple (a,b,c) rather than a nested tuple (a,(b,c))
15:13:37 <monochrom> You can easily achieve that by inserting this arrow: arr (\(a,(b,c)) -> (a,b,c))
15:14:15 <glguy> what is the difference in arr and pure?
15:14:23 <glguy> is one part of the class contract
15:14:29 <monochrom> same difference.
15:14:32 <glguy> and the ohter a specific implementatino?
15:14:51 <glguy> oh
15:15:20 <monochrom> they are both class methods.
15:15:42 <int-e> and their default implementations are: arr = pure and pure = arr
15:15:55 <Philippa> they're supposed to be synonymous
15:16:39 <int-e> probably their were papers with conflicting names
15:17:20 <Cale> edi: somewhat, yeah
15:17:43 <Cale> edi: it's different in that the part which is being handled in separate passes is smaller
15:18:18 <edi> Cale: monochrom's definition cleared it up a bit for me, it is passing the same subtree to each of the f &&& g &&& h, which is nice
15:18:29 <Cale> right
15:19:15 <edi> I should have guessed that, fun afternoon anyway.
15:19:44 <Cale> It's a really amazingly nice example of an EDSL that HXT provides.
15:19:45 <shapr> SHAZAM!
15:19:56 <shapr> Dang, it's too dark to unicycle now :-(
15:20:02 <shapr> I guess I'll have to code instead.
15:20:06 * edi nods
15:20:18 <monochrom> pointful dataflow languages are ways of avoiding to draw clear dataflow diagrams
15:20:19 <Cale> shapr: Have you played around with HXT much?
15:20:24 <shapr> Cale: Not recently.
15:20:52 <monochrom> proc, do, and function parameters are pointful dataflow languages
15:21:13 <Cale> edi and I just wrote a little HTML scraper for a particular site, the code is rather nice :)
15:21:16 <shapr> Though I did get paid a chunk of money to write HXT code a few years back. My client wanted 45mb of ms.doc files in a custom XML format, so I saved them as OOo xml and then convert from the OOo DTD to the custom xml flavor.
15:21:22 <shapr> Oh, I'd like to see that!
15:21:23 <Cale> http://paste.lisp.org/display/32533#1
15:21:25 * edi nods
15:21:34 <shapr> I recently wanted to write an html scraper in Haskell.
15:21:45 <Cale> It's really really easy to do
15:22:02 <edi> Well, after you learnt a bunch of things :)
15:22:09 <shapr> hah
15:22:22 <Cale> You can mostly guess ;)
15:22:40 <Cale> well, once you know the arrow combinators, anyway
15:22:45 * glguy home going time!
15:22:56 * edi is very happy
15:23:11 <Cale> I found HXT's naming of things pretty intuitive and easy to search the documentation for
15:24:25 <edi> The language is indeed very clean
15:24:27 <monochrom> Here is how I got to learn HXT.  On a forum there was an imaginary stock trading game.  I wanted to automate certain buy-sell actions (for example, dumping!).  The prices were in HTML tables and the actions were to be submitted via HTML forms.  I learned HXT for that.  I would accept no substitute.
15:25:02 <edi> Here is how I got to learn HXT.  On monochrom's site I saw an HXT tutorial...
15:25:24 <monochrom> Darn. Now this is infectious and viral.
15:25:56 * edi sneezes on the crowd
15:26:50 <Sgeo> Hi all
15:27:37 <shapr> Here is how I got to learn HXT. My client wanted to turn 48mb of ms.doc files into a custom XML flavor, and their programmer guy gave up after 1.5 months and handed me a huge non-working chunk of XSLT, JavaScript, and Java...
15:27:48 <bd_> > nub "aba"
15:27:49 <lambdabot>  "ab"
15:27:58 <bd_> O(n^2)?
15:28:04 <monochrom> Yah
15:28:05 <edi> True
15:28:13 <Sgeo> What's nub?
15:28:20 <int-e> 'essence'
15:28:27 <bd_> Sgeo: removes duplicate elements
15:28:30 <bd_> for anything in Eq
15:28:47 <hyrax42> can't be done better than O(n^2) if you're only assuming Eq
15:28:54 <bd_> Data.Set faster ofc, if your datatype is Ord and you don't mind it being sorted.
15:29:00 <shapr> I completed the conversion for my client in Three Days.
15:29:06 <hyrax42> for finite list, can be done O(n log n) if data in Ord
15:29:06 <monochrom> nub is http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html#v%3Anub
15:29:09 <lambdabot> http://tinyurl.com/wfo7q
15:29:25 <dmead> bonk
15:30:02 <monochrom> With Java and/or XSLT it shouldn't be more than a week.
15:30:08 <shapr> Address Space Layout Randomization - when you're too lazy to use anything but C!
15:30:43 <Excedrin> is Three Days a euphemism for something or trademarked?
15:30:56 <hyrax42> nubOrd = map head . group . sort
15:31:00 <monochrom> There can be the same phenomenon with formal methods.  A formal method user may finish the job faster with less errors.
15:31:04 <shapr> Nah, it's just that it wasn't even three days of fulltime work, I just hacked it together.
15:31:28 <sorear> Idea for performance comparison: C+ASLR+stackguard or like  vs.  GHC+prelink
15:31:33 <Sgeo> > twos n = (iterate (\x -> 2^x) 1 ) !! n
15:31:33 <lambdabot>  Parse error
15:31:38 <Sgeo> > let twos n = (iterate (\x -> 2^x) 1 ) !! n
15:31:39 <lambdabot>  Parse error
15:31:42 <shapr> I learned HXT, the OOo DTD, and got the job done.
15:31:43 <Sgeo> erm
15:31:45 * shapr &
15:31:55 <Sgeo> > help
15:31:56 <lambdabot>  Not in scope: `help'
15:32:00 <sorear> ?help
15:32:00 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
15:32:07 <Sgeo> list
15:32:10 <Sgeo> help list
15:32:11 <monochrom> On closer examination, the formal method user or the haskell user is also smarter.  (How else could you master a formal method or haskell?)
15:32:16 <sorear> ?list
15:32:16 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
15:32:28 <Syrin> So
15:32:32 <hyrax42> > let twos n = (iterate (2^) 1) !! n in twos 5
15:32:33 <Syrin> If I use haskell, I become smarter?
15:32:34 <lambdabot>  2003529930406846464979072351560255750447825475569751419265016973710894059556...
15:32:42 <hyrax42> that didn't work at all
15:32:57 <Excedrin> what if the haskell user just sort of fumbles around until things typecheck?
15:33:05 <Sgeo> hyrax42, hm?
15:33:13 <hyrax42> > let twos n = (iterate (2^) 1) !! n in twos 0
15:33:15 <lambdabot>  1
15:33:15 <monochrom> No. If you are smarter, you can understand Haskell.
15:33:17 <dibblego> is there a way of using wildcards for exposed-modules in Project.cabal?
15:33:20 <hyrax42> > let twos n = (iterate (2^) 1) !! n in twos 1
15:33:21 <Sgeo> > let twos n = (iterate (2^) 1) !! n in twos 7
15:33:21 <lambdabot>  2
15:33:25 <lambdabot> Terminated
15:33:27 <hyrax42> > let twos n = (iterate (2^) 1) !! n in twos 2
15:33:29 <lambdabot>  4
15:33:29 <Botje> hyrax42: you probably want to iterate (2*) instead
15:33:38 <monochrom> Excedrin: Ah, but that will take more than 3 days. :)
15:33:45 <hyrax42> oh, I was just copying sgeo's code
15:33:45 <Botje> 2^(2^(2^(2^(... is quite a large number
15:33:48 <hyrax42> and realise yea
15:33:52 <dibblego> do I have to explicitly list every single module that I wish to expose in Project.cabal?
15:33:52 <hyrax42> this is super-exponentiation
15:33:54 <hyrax42> yikes
15:34:07 <edi> monochrom: I guess that if you understand '=' in mathematics you can program in Haskell.
15:34:07 <Sgeo> Ah, so the bot won't crash on large numbers..
15:34:20 <Sgeo> > let twos n = (iterate (2^) 1) !! n in twos 6
15:34:25 <lambdabot> Terminated
15:34:34 <hyrax42> 5 is as high as it goes, apparently
15:34:51 <hyrax42> Sgeo: lambdabot is fairly well tested/abused by the people in here
15:34:56 <monochrom> Yes. But not to the point of using monads and arrows successfully.
15:34:59 <Pastorn> hyrax42:  my one goes to eleven...
15:35:03 <Syrin> Hey, I know squididdly about Haskell, so: how would I concatenate a number with a string?
15:35:04 <Pastorn> *min
15:35:10 <Pastorn> **mine'
15:35:18 * Pastorn shoots himself
15:35:24 <Sgeo> Syrin, I think: the_str ++ (show the_num)
15:35:24 <monochrom> What is the semantics of "concatenate a number with a string"?
15:35:26 <goltrpoat> > "hello" ++ show 5
15:35:27 <lambdabot>  "hello5"
15:35:33 <hyrax42> Syrin: show
15:35:38 <Syrin> Ah, alright
15:36:02 <hyrax42> or actually, monochrom's answer is the correct one
15:36:09 <Syrin> Heh
15:36:17 <monochrom> I guess Syrin came from Perl.  Can concatenate a hash table with a higher-order function and then with a whole module.
15:36:23 <goltrpoat> haha
15:36:34 <Syrin> I phrased my question wrong :(
15:36:35 <nornagon> heh.
15:36:37 <Philippa> monochrom: and then treat it as an int? :-)
15:36:39 <Syrin> I just meant how to convert a number to a string
15:36:43 <Philippa> *nod*
15:36:50 <monochrom> YEAH!  As a freaking INT!!!111
15:36:51 <dmead> show
15:36:52 <Sgeo> Wow, two siners (not including me) are in here
15:36:56 <dmead> (show 5)
15:36:56 * edi sedates monochrom 
15:36:59 <dmead> is a string of 5
15:37:02 <Philippa> Syrin: 'sok, you got the answer anyway, right?
15:37:04 <Syrin> Yes, I already got that
15:37:08 <dmead> > (show 5)
15:37:09 <lambdabot>  "5"
15:37:12 <Syrin> Thanks :P
15:37:15 <dmead> =p
15:37:15 <Sgeo> > :t 5
15:37:16 <lambdabot>  Parse error
15:37:19 <allbery_b> I have no point here, I just like saying:  "Duck!!" typing
15:37:23 <Sgeo> > (:t 5)
15:37:23 <lambdabot>  Not in scope: `t'
15:37:24 <hyrax42> ?type intAtBase
15:37:26 <lambdabot> Not in scope: `intAtBase'
15:37:29 <Philippa> > show (Just 26.4)
15:37:30 <dmead> > :type 5
15:37:31 <lambdabot>  "Just 26.4"
15:37:31 <lambdabot>  Parse error
15:37:34 <Sgeo> ?type 5
15:37:35 <lambdabot> forall t. (Num t) => t
15:37:38 <hyrax42> ?index showIntAtBase
15:37:39 <lambdabot> Numeric
15:37:49 <Sgeo> Isn't "forall" nonstandard?
15:37:50 <hyrax42> ?type Numeric.showIntAtBase
15:37:51 <dmead> (read "5")
15:37:51 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> ShowS
15:37:53 <dmead> > (read "5")
15:37:54 <lambdabot>  Add a type signature
15:38:09 <Philippa> Sgeo: it's not H98. It's defacto standard though
15:38:11 <hyrax42> > char 48
15:38:12 <lambdabot>  Not in scope: `char'
15:38:22 <hyrax42> > map chr [48..60]
15:38:24 <lambdabot>  "0123456789:;<"
15:38:37 <Sgeo> > [1..]
15:38:39 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
15:38:50 <dmead> > map 1+ [1..100]
15:38:51 <lambdabot>  Couldn't match `[a] -> [b]' against `[a1]'
15:39:00 <dmead> o0
15:39:08 <dmead> > map 1+  [1..100]
15:39:09 <lambdabot>  Couldn't match `[a] -> [b]' against `[a1]'
15:39:17 <dmead> > map 1 +  [1..100]
15:39:17 <goltrpoat> > map (1+) [1..5]
15:39:17 <Syrin> What're you guys doing?
15:39:18 <lambdabot>  Couldn't match `[a] -> [b]' against `[a1]'
15:39:19 <lambdabot>  [2,3,4,5,6]
15:39:24 <hyrax42> > map (1+) [1..100]
15:39:24 <dmead> foolin
15:39:26 <lambdabot>  [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
15:39:26 <dmead> around
15:39:27 <dmead> ah ah
15:39:29 <dmead> thats it
15:39:37 <hyrax42> dmead: brain fart? ;)
15:39:40 <dmead> ya =p
15:39:47 <dibblego> is there a function to take the last n elements from a finite list?
15:40:10 <dmead> ya
15:40:11 <Syrin> reverse drop n reverse?
15:40:16 <Syrin> Or take n, rather
15:40:25 <dmead> take something something drop something something
15:40:26 <dibblego> then they will be reversed!
15:40:30 <dibblego> oh wait
15:40:41 <dmead> oh
15:40:44 <dmead> drop xD
15:40:53 <goltrpoat> > let takeLastN n s = drop (length s - n) s in takeLastN 3 "hello"
15:40:53 <dmead> > map (sqrt) [1..100]
15:40:54 <lambdabot>  "llo"
15:40:55 <lambdabot>  [1.0,1.4142135623730951,1.7320508075688772,2.0,2.23606797749979,2.4494897427...
15:41:15 <dmead> > drop 5 [1..10]
15:41:16 <lambdabot>  [6,7,8,9,10]
15:41:38 <Sgeo> re nornagon_
15:41:53 <dibblego> I think reverse take reverse will be more efficient than using length
15:42:21 <Sgeo> > length [1..]
15:42:25 <lambdabot> Terminated
15:42:55 <Sgeo> How does it know when to terminate?
15:42:58 <Syrin> So my solution is efficient? >_>
15:43:00 <dmead> on the ...
15:43:07 <goltrpoat> dibblego:  should be about equivalent, no?  each reverse has to touch about n/2 elements, and length has to touch all n elements
15:43:08 <monochrom> By a timeout
15:43:30 <dmead> omfg
15:43:31 <Cale> Sgeo: It only computes as much as is needed to print the result, and lambdabot has an explicit timeout.
15:43:32 <Syrin> No
15:43:33 <dmead> drop x  list
15:43:35 <dmead> thats it
15:43:38 <dmead> :>
15:43:53 <Syrin> The second reverse doesn't have to touch n/2 elements
15:43:56 <Excedrin> > let last2 [] = undefined; last2 (x:[]) = undefined; last2 ([x,x1]) = [x,x1]; last2 (x:xs) = last2 xs in last2 ['a'..'z']
15:43:58 <lambdabot>  "yz"
15:43:58 <goltrpoat> dmead:  x = length s - n though
15:44:00 <Syrin> Oh wait
15:44:09 <hyrax42> won't reverse have to touch all elements?
15:44:21 <monochrom> If you need "last N elements" often enough, you will start to keep track of lengths.
15:44:23 <goltrpoat> it'll do n/2 swaps, right
15:44:30 <ph8> ?paste
15:44:30 <lambdabot> http://paste.lisp.org/new/haskell
15:44:41 <dmead> i'm pretty sure reverse is a waste of time
15:44:53 <lisppaste2> ph8 pasted "File Length" at http://paste.lisp.org/display/32540
15:45:02 <monochrom> One reverse is fine.  Two reverses is a bit wasteful.
15:45:06 <ph8> Would anyone mind telling me why that's rubbish?
15:45:14 <Syrin> The second reverse is to reverse the take
15:45:16 <dibblego> what is undefined?
15:45:18 <Syrin> So that it's in the original order
15:45:19 <hyrax42> Excedrin: why do you have the undefineds?  To avoid non-exhastive patter warnings?
15:45:20 <ph8> i know i'm redefining (or trying to redefine) length
15:45:25 <dmead> if your going to use take, just use drop
15:45:29 <dmead> and drop the reverses
15:45:29 <ph8> running fileLength "test.txt" in hugs returns ''
15:45:31 <dmead> whats the problem
15:45:43 <dibblego> dmead, drop will not work unless you calculate length
15:45:56 <monochrom> reverse . take . reverse will construct two new lists, one of which is intermediate.
15:46:04 <dmead> o0
15:46:09 <hyrax42> ph8: try testing just myLength without the IO part
15:46:16 <hyrax42> ph8: myLength "abcdefg"
15:46:23 <ph8> good plan :p
15:46:25 <hyrax42> isolate your problem
15:46:29 <monochrom> drop (length ___ - n)  will construct no new list.
15:46:32 <ph8> that works ;)
15:46:46 <dmead> > mydrop n [] = []
15:46:47 <lambdabot>  Parse error
15:46:52 <hyrax42> so do you have a "test.txt" in the same directory that you launched Hugs from?
15:46:55 <dmead> how do you tell lambdabot functions?
15:46:56 <ph8> yup
15:46:57 <monochrom> Clearly, the former has much worse cache locality.
15:47:02 <Sgeo> > twos
15:47:02 <ph8> i might try a full path
15:47:02 <lambdabot>  Not in scope: `twos'
15:47:03 <Syrin> use let/in
15:47:05 <hyrax42> or in hugs' current working directory
15:47:06 <dmead> ah
15:47:08 <hyrax42> ah
15:47:12 <dibblego> > let mydrop n [] = [] in mydrop []
15:47:13 <lambdabot>  Add a type signature
15:47:14 <hyrax42> you cannot show an IO Int
15:47:25 <dmead> > let mydrop n [] = []
15:47:26 <lambdabot>  Parse error
15:47:26 <ph8> same output
15:47:30 <dmead> wot o0
15:47:31 <Syrin> lol
15:47:33 <hyrax42> so it can't be printed
15:47:37 <hyrax42> try swapping return for print
15:47:38 <ph8> it errored with an 'Int', said it was missing IO - hence the addition
15:47:39 <Syrin> > let mydrop n [] = [] in mydrop n []
15:47:40 <lambdabot>  Not in scope: `n'
15:47:41 <hyrax42> or print for return
15:47:48 <Syrin> Or, rather, the second n shouldbe like 0
15:47:54 <Sgeo> > let mydrop n [] = [] in mydrop 5 []
15:47:55 <hyrax42> ph8:  yes but IO Int can't be "show"n
15:47:55 <lambdabot>  Add a type signature
15:48:04 <monochrom> ph8's code is not rubbish.
15:48:08 <dmead> i want an entire function
15:48:13 <hyrax42> > show (return 5 :: IO Int)
15:48:14 <lambdabot>  "<IO Int>"
15:48:21 <hyrax42> ph8: see?
15:48:24 <goltrpoat> how's this for inefficient..
15:48:27 <goltrpoat> > let dropLastN n = (!! (n-1)) . tails in dropLastN 3 "hello"
15:48:28 <lambdabot>  "llo"
15:48:30 <ph8> oo victoryish
15:48:36 <Sgeo> > mydrop :: Integer->[a]->[a]; let mydrop n [] = [] in mydrop 5 []
15:48:37 <lambdabot>  Parse error
15:48:46 <hyrax42> ph8: ish?
15:48:46 <Sgeo> > {mydrop :: Integer->[a]->[a]}; let mydrop n [] = [] in mydrop 5 []
15:48:47 <lambdabot>  Parse error
15:48:56 <monochrom> Too much noise.
15:49:02 <Sgeo> How do I do type declarations in lambdabot?
15:49:19 <dmead> dunno =(
15:49:20 <dmead> mydrop 0 x = x
15:49:20 <dmead> mydrop n x:xs = mydrop (n-1) xs
15:49:22 <dmead> hows that eh
15:49:23 <ph8> i get some invalid character encoding on my actual test file, but if i echo a basic file.lhs, that works
15:49:41 <Syrin> uh
15:50:06 <Syrin> Isn't that the original definition of drop?
15:50:10 <dmead> yea
15:50:15 <dmead> probably
15:50:46 <dmead> isn't that what you wanted?
15:50:46 <dmead> o0
15:51:05 <allbery_b> > let mydrop :: Integer -> [a] -> [a]; mydrop n [] = [] in mydrop 5 []
15:51:05 <Sgeo> Why doesn't Hoogle do definitions?
15:51:06 <lambdabot>  Add a type signature
15:51:08 <ph8> so..
15:51:10 <Excedrin> > let sgeo :: Integer -> Integer; sgeo = id in sgeo 42
15:51:11 <lambdabot>  42
15:51:19 <ph8> do i need to put show in the type signature somewhere to get it to echo an IO Int like i want?
15:51:25 <monochrom> No.
15:51:35 <Sgeo> ah
15:51:39 <ph8> it'll print one for me atm
15:51:50 <ph8> but i'd quite like it to be the return value of the function, one which hugs can display
15:51:52 <Sgeo> > let mydrop :: Integer->[a]->[a]; mydrop n [] = [] in mydrop 5 []
15:51:53 <lambdabot>  Add a type signature
15:52:03 <Sgeo> > let mydrop :: Integer->[a]->[a]; mydrop n [] = [] in mydrop 5::Integer []
15:52:04 <lambdabot>    Kind error: `Integer' is applied to too many type arguments
15:52:04 <lambdabot>   In the t...
15:52:08 <hyrax42> ph8: IO Int cannot be shown, it must be printed
15:52:13 <Sgeo> > let mydrop :: Integer->[a]->[a]; mydrop n [] = [] in mydrop 5 []
15:52:14 <allbery_b> > let mydrop :: Integer -> [a] -> [a]; mydrop n [] = [] in mydrop 5 ([] :: [Char])
15:52:14 <lambdabot>  Add a type signature
15:52:15 <lambdabot>  ""
15:52:28 <ph8> ah ok, but if i return it normally - programs could use it as any normal Int, even if it can't be shown?
15:52:29 <hyrax42> you coudl do > print (fileLength "testfile")
15:52:43 <allbery_b> of course, that's a pretty useless definition of mydrop...
15:52:54 <monochrom> If ph8 is on GHC 6.6: at the ghci prompt, just typing in fileLength "filename here" will work.
15:53:05 <Sgeo> Why does it require the []::Char or []::some_type
15:53:14 <hyrax42> monochrom: he's on hugs
15:53:15 <ph8> ah cunning
15:53:25 <ph8> but if i wanted to say... add 5 to fileLength ?
15:53:36 <ph8> could i get away with print (fileLength "testFile" + 5) ?
15:53:47 <hyrax42> ph8: nope
15:53:53 <monochrom> On hugs: type in: do { answer <- fileLength "filename here"; print answer }
15:53:55 <hyrax42> you need some do in there
15:53:57 <ph8> or let b = fileLength "testFile" + 5; print(b)
15:54:02 <ph8> hmm :
15:54:03 <SamB> ah
15:54:03 <ph8> hmm :s
15:54:13 <SamB> fileLength "filename here" >>= print
15:54:27 <hyrax42> or what samB gave you
15:54:29 <monochrom> see http://www.haskell.org/haskellwiki/A_brief_introduction_to_Haskell#Imperative_Programming for more information
15:54:31 <lambdabot> Title: A brief introduction to Haskell - HaskellWiki, http://tinyurl.com/y6cbnf
15:54:36 <norpan> print . (5+)
15:55:51 <ph8> ok cheers - that's some progress
15:55:52 <ph8> p
15:55:54 <allbery_b> @. redo unpl fileLength "foo" >>= print . (5 +)
15:55:55 <lambdabot> (\ d -> (do { a <- (fileLength "foo"); print a}) (5 + d))
15:55:55 <ph8> :p
15:55:56 <edi> foldl (\.. -> forkIO (do { h <- runProcess ".."; waitForProcess h }) is a good way of parallelizing some unix process in the background?
15:56:13 <allbery_b> huuuuh.  not what I expected
15:56:27 <allbery_b> @. redo unpl fileLength "foo" >>= (print . (5 +))
15:56:27 <lambdabot> (do { d <- (fileLength "foo"); print (5 + d)})
15:56:35 <allbery_b> there we go
15:56:50 <monochrom> I want to emphasize that the present fileLength is just fine.  It answers an Int.  This is the right thing to do.  In general, you want fileLength to give you the answer, then the caller - not fileLength - will decide whether or how to display it.  If you hardcode an output command inside fileLength, that's bad and childish software engineering.
15:57:29 <dibblego> ?docs Data.Map
15:57:29 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
15:58:07 <norpan> childish software engineering indeed
15:58:16 <Syrin> trying to force Python to iterate over 2^20 items is not fun :(
15:58:32 <Syrin> S'why I'm trying to do it in Haskell
15:59:30 <sorear> > foldr (+1) 0 [1..2^20]
15:59:31 <lambdabot>  add an instance declaration for (Num (b -> b))
15:59:49 <sorear> > foldr 0 (+1) [1..2^20]
15:59:50 <lambdabot>  add an instance declaration for (Num (a1 -> (a -> a) -> a -> a))
16:00:00 <sorear> > foldr (+1) (0::Int) [1..2^20]
16:00:01 <lambdabot>  add an instance declaration for (Num (Int -> Int))
16:00:02 <Sgeo> > 2^20
16:00:04 <lambdabot>  1048576
16:00:06 <Syrin> lol
16:00:15 <sorear> > foldr (+1) (0::Int) [1..1048576]
16:00:16 <lambdabot>  add an instance declaration for (Num (Int -> Int))
16:00:16 <lambdabot>   In an arithmetic seq...
16:00:28 <sorear> :t foldr
16:00:29 <norpan> foldr (+) ...
16:00:29 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
16:00:45 <Sgeo> foldr (+1)::(Int->Int->Int) (0::Int) [1..1048576]
16:00:46 <sorear> > foldr (1+) (0::Int) [1..1048576]
16:00:47 <lambdabot>  add an instance declaration for (Num (Int -> Int))
16:00:47 <lambdabot>   In an arithmetic seq...
16:00:50 <Sgeo> > foldr (+1)::(Int->Int->Int) (0::Int) [1..1048576]
16:00:50 <lambdabot>  Parse error
16:00:58 <Syrin> lol
16:00:58 <sorear> > foldr ((1+) :: Int->Int) (0::Int) [1..1048576]
16:00:59 <lambdabot>    Expecting a function type, but found `Int'
16:01:00 <lambdabot>    Expected type: Int -> b...
16:01:11 <sorear> > foldr ((+) 1 :: Int->Int) (0::Int) [1..1048576]
16:01:12 <lambdabot>    Expecting a function type, but found `Int'
16:01:12 <lambdabot>    Expected type: Int -> b...
16:01:15 <norpan> (+)
16:01:17 <norpan> come on
16:01:19 <Syrin> Uh
16:01:20 <Syrin> Yea
16:01:21 <int-e> sorear: what are you trying to do?
16:01:21 <Sgeo> > foldr ((1+) :: Int->Int->Int) (0::Int) [1..1048576]
16:01:23 <lambdabot>    Expecting a function type, but found `a'
16:01:23 <lambdabot>    Expected type: Int -> Int...
16:01:25 <Syrin> Do you know what foldr does?
16:01:32 <sorear> what happened to foldr?
16:01:34 <Syrin> Are you looking for like fmap?
16:01:45 <Sgeo> ?type (1+)
16:01:46 <lambdabot> forall a. (Num a) => a -> a
16:01:51 <sorear> no, I'm trying to write  length
16:01:55 <int-e> > foldr (const (1+)) 0 [1..25] -- I guess he wants this
16:01:56 <lambdabot>  25
16:02:07 <norpan> ah, length
16:02:11 <sorear> d'oh!
16:02:24 <monochrom> I can't believe it.  Following my advice an hour ago, now everyone is trying to write length.
16:02:28 <Sgeo> length [1..2^20]
16:02:36 <int-e> monochrom: I wasn't ;)
16:02:44 <sorear> > length [1..2^20]
16:02:46 <lambdabot>  1048576
16:02:48 <Sgeo> Oh dug
16:02:50 <Syrin> uh, length [1..2^20] will just be 2^20
16:02:51 <monochrom> OK, every newbie...
16:02:51 <Sgeo> *duh
16:03:11 <sorear> yes, but it requires iterating over 2^20 items first!
16:03:19 <Sgeo> foldl1 (*) [1..2^20]
16:03:27 <Syrin> lol
16:03:29 <sorear> (unless GHCi has some evil simplification rule)
16:03:33 <ph8> > mapFile :: [t] -> Map (a, b)
16:03:34 <lambdabot>  Not in scope: type constructor or class `Map'
16:03:40 <ph8> anyone know how i should return a map properly?
16:03:43 <ph8> Data.Map?
16:03:44 <Sgeo> > foldl1 (*) [1..2^20]
16:03:46 <lambdabot>  Exception: stack overflow
16:03:47 <edi> ?source Data.List
16:03:48 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
16:03:48 * Sgeo keeps forgetting the >
16:03:52 <norpan> ph8: Data.Map is fine
16:03:57 <Sgeo> > foldr1 (*) [1..2^20]
16:03:59 <Syrin> Is that supposed to be 2^20!?
16:03:59 <lambdabot>  Exception: stack overflow
16:04:06 <Syrin> Sorry, 2^20!
16:04:19 <int-e> Anyway. Lambdabot answeres private messages, too. And there's always ghci to try stuff.
16:04:20 <ph8> apparently it's undefined norpan
16:04:22 <monochrom> [t] -> Map (a, b)  is fine.
16:04:22 <ph8> which is bad :p
16:04:23 <emu> > product [1..(2^20)]
16:04:25 <ph8> hmm
16:04:26 <lambdabot>  Terminated
16:04:27 <ph8> doesn't want to work
16:04:31 <norpan> ph8: undefined?
16:04:36 * SamB wonders why Living Room is inside first room
16:04:46 <monochrom> Don't use lambdabot as your judge.  It has certain things turned off.
16:05:04 <edi> ?hoogle foldM
16:05:05 <lambdabot> Monad.foldM :: Monad a => (b -> c -> a b) -> b -> [c] -> a b
16:05:06 <lambdabot> Control.Monad.foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
16:05:06 <lambdabot> Control.Monad.foldM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()
16:05:13 <edi> ?docs Control.Monad
16:05:14 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html
16:05:14 <Sgeo> Monads confuse me
16:05:14 <sorear> factorial of 2^20 has millions of digits.  Lambdabot has cpu quotas.
16:05:25 <monochrom> Basically, just don't use lambdabot.  (That will save me a lot of trouble.)
16:05:36 <ph8> Data.Map> :l Main.lhs
16:05:36 <ph8> ERROR "Main.lhs":20 - Illegal type "[a] -> Map (b,c)" in constructor application
16:05:41 <dons> moin
16:05:51 <ph8> > mapFile :: [t] -> Map (a, b)
16:05:52 <lambdabot>  Not in scope: type constructor or class `Map'
16:05:54 * sorear welcomes Sgeo to the Monad-confusee club
16:05:58 <monochrom> Have you imported Data.Map etc?
16:06:02 <ph8> yup
16:06:08 <ph8> import Data.Map(Map, toList, empty, insertWith, findWithDefault, showTree)
16:06:08 <emu> Map a b
16:06:13 <sjanssen> hello, dons
16:06:13 <dons> ph8, do you mean:   Map a b
16:06:15 <monochrom> Oh haha, darn.
16:06:18 <allbery_b> moin dons
16:06:20 <notsmack> has anybody hooked hs-plugins up to happs?
16:06:23 <Sgeo> > fromJust Nothing
16:06:23 <ph8> ah cheers
16:06:24 <lambdabot>  Add a type signature
16:06:28 <Sgeo> ..
16:06:29 <emu> this ain't sml, after all
16:06:30 <dons> notsmack: nope, its been talked about though
16:06:33 * sjanssen just finished his finals and is ready to CODE
16:06:39 <dons> sjanssen: cool!
16:06:41 <notsmack> dons: yeah, seems like it'd have to happen sooner or later
16:06:42 <dons> oohoo!
16:06:58 <Sgeo> > Maybe.fromJust Nothing
16:07:00 <lambdabot>  Add a type signature
16:07:04 <chessguy> woohoo! i just successfully installed my first openBSD package
16:07:13 <allbery_b> > fromJust Nothing :: Maybe Int
16:07:14 <Sgeo> Shouldn't that just be an exception?
16:07:14 <lambdabot>  Exception: Maybe.fromJust: Nothing
16:07:29 <monochrom> You need a type signature.
16:07:37 <Sgeo> GHCi didn't need one
16:07:40 <dibblego> I feel like I am doing something wrong with data FiniteList a = FiniteList [a] Int -- length
16:07:45 <Sgeo> Prelude> Maybe.fromJust Nothing
16:07:45 <Sgeo> *** Exception: Maybe.fromJust: Nothing
16:07:48 <monochrom> GHCi is more advanced.
16:07:53 <dons> ?users
16:07:54 <lambdabot> Maximum users seen in #haskell: 291, currently: 254 (87.3%), active: 60 (23.6%)
16:08:15 <monochrom> Like I said, don't use lambdabot as your judge, hell don't use lambdabot period, ok?
16:08:18 <Sgeo> > fromJust (Just 1)
16:08:20 <lambdabot>  1
16:09:11 <chessguy> what's wrong with using lambdabot
16:09:16 <sorear> I take lambdabot's continued prescence as a sign that dons wants us to use it.
16:09:26 <dmead> lol
16:09:33 <sjanssen> sorear: common misconception
16:09:38 <dons> heh
16:09:40 <monochrom> The last ten minutes of lambdabot usage is what's wrong.
16:10:01 <Sgeo> Would this be my fault, by any chance?
16:10:08 <dmead> is there a page for the jvm-haskell bridge?
16:10:12 <monochrom> Together with all those "cross-examination" i.e., "but GHCi behaves differently!"
16:10:16 <edi> dons: what's the best way to run a number of parallel unix process from an Haskell program?
16:10:26 <edi> processes
16:10:26 <Sgeo> monochrom, that was me, just once, I think
16:10:33 <dons> edi, hmm interesting. just fork them?
16:10:37 <sjanssen> edi: mapM_ forkIO?
16:10:43 <dons> or do you want a haskell thread dedicated to each unix procoess?
16:10:47 <dibblego> is there some implied problem with defining the data type data FiniteList a = FiniteList [a] Int -- length I wonder why nobody has written it before
16:10:54 <edi> dons: no I don't
16:11:09 <twanvl> Perhaps if a person uses lambdabot more then x times in y minutes it should say "Please /msg me so we can talk in private"
16:11:20 <edi> I just want to notice if they fail, and have all them finish before exiting.
16:11:31 <edi> (...from the main program.)
16:11:39 <dons> edi, forkIO, no?
16:11:49 <edi> forkIO $ runCommand .. ?
16:11:50 <dons> ?docs Control.Concurrent
16:11:50 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html
16:11:59 <sorear> "You have exceeded your lambdabot quota."
16:12:00 <dons> edi, ah I see what you mean
16:12:23 <fnord123> yell ya what.. literate haskell's > characters really interfere with formatting macros in vim. :(
16:12:24 <dons> so yeah, I'd launch a haskell thread that populates an mvar when the job is done
16:12:30 <dons> then the main thread can wait
16:13:07 <emu> fnord123: tried latex-literate?
16:13:12 <edi> would doing the process serially make the code shorter/cleaner?
16:13:30 <dons> edi, possibly. it really depends on what you're trying to do
16:13:39 <dons> why not try to write it in a simple unthreaded way
16:13:51 <fnord123> emu, no
16:13:53 <dons> and then we can see if making it concurrent is a better structure
16:14:02 <monochrom> dibblego: I think it's fine.
16:14:08 <dibblego> monochrom, thanks
16:14:08 <edi> dons: I'm not entirely comfortable with System.Process
16:14:13 <emu> fnord123: that doesn't require > at start of lines
16:14:26 <edi> dons: I know you're good at unixish stuff :)
16:14:58 <dons> edi: hehe
16:15:05 <Sgeo> Can I define a:
16:15:24 <Sgeo> data fOrdered = LT | GT | EQ | FZ
16:15:24 <Sgeo> ?
16:15:37 <dons> edi: have a stab at it, come back if that doesn't work, and I can help some more
16:15:39 <Sgeo> Or is the fact that LT is Ordered(?) preventing that?
16:15:54 <dons> here's a quick *.Process wrapper I wrote yesterday, http://www.cse.unsw.edu.au/~dons/code/typeof/Process.hs
16:16:05 <Sgeo> Or would a "Maybe Ordered" be the way to go?
16:16:14 <sjanssen> @where paste
16:16:15 <lambdabot> http://paste.lisp.org/new/haskell
16:16:21 <dons> Sgeo: it'll a) be a name clash with the prelude defintioins. and b) fOrdered is syntactically wrong, it would be FOrdered
16:16:29 <emu> Sgeo: type names must begin with capital letters
16:16:39 * Sgeo blushes in embarrasement
16:16:51 <dons> and c) Maybe Ordered would be nicer, maybe..?
16:17:26 <vincenz> dons: repetition repetition
16:17:31 <vincenz> :P
16:17:42 <vincenz> data MySpecial = Fz
16:17:42 <Sgeo> erm
16:17:48 <vincenz> Either Ordered Fz
16:17:52 <Sgeo> It's "Maybe Ordering" I guess
16:17:59 <vincenz> Or yeah, ordering
16:18:02 <Sgeo> ?type LT
16:18:04 <lambdabot> Ordering
16:18:08 <lisppaste2> sjanssen pasted "this runs processes in parallel for me" at http://paste.lisp.org/display/32548
16:18:17 * Sgeo blushes in more embarrasement
16:18:37 <sjanssen> edi: will that work?
16:19:10 <Sgeo> So how would I make an "MOrd" class?
16:19:15 <dons> sjanssen: that's come up 2 times now, this processes-in-parallel stuff. could you put the solution on the wiki?
16:19:33 <dons> (I know its small ;)
16:21:41 <monochrom> Phooey!  Phooey looks like dream come true!
16:24:48 <Cale> man, the mailing lists have been consistently overwhelming this week
16:25:22 <dibblego> ##java is so funny
16:25:34 <edi> sjanssen: I'm doing it serially, and it works
16:25:43 <Cale> dibblego: why?
16:25:45 <edi> sjanssen: ah, didn't see the past, I'll try
16:25:57 <edi> *paste
16:26:02 <edi> Man, I'm tired.
16:26:23 <dibblego> just how they reinvent the concepts that Haskell (or any pure FP language) fundamentally provides; without ever knowing it and with a non-optimal approach
16:26:27 <sjanssen> dons: what would you name the wiki page?
16:26:37 <Cale> dibblego: just point them at Scala
16:27:02 <dibblego> why use HAppS when we have the servlet specification?
16:27:03 <Cale> It'll be an easier transition from Java to Scala, and then it will be a pretty easy step from there to Haskell :)
16:27:09 <dibblego> :)
16:27:38 <Excedrin> why not CAL? the CAL "Gem" stuff is very neat
16:27:49 <Cale> Plus, they can even use all the Java libraries from Scala transparently
16:28:00 <dibblego> Haskell needs that
16:28:38 <Cale> Transparent access to Java libraries?
16:28:42 <dibblego> yes
16:28:48 <dons> sjanssen: Running_unix_processes_concurrently ?
16:28:48 <Excedrin> CAL also seems more polished than Scala
16:28:51 <dibblego> for no reason other than to market itself
16:28:58 <dibblego> not necessarily for a rational reason
16:30:16 <Cale> I think there's too large an impedance mismatch for that to really be possible, but I don't see anything wrong with making the FFI easy
16:30:28 <Cale> Excedrin: oh really?
16:30:33 <Cale> Excedrin: I'll have to look at it
16:31:10 <Cale> Excedrin: is the result nearly so Haskellish?
16:31:29 * sjanssen can't even figure out how to create a new page
16:31:50 <allbery_b> just try to go to it, it'll dump you in an editor
16:32:03 <allbery_b> that's the nature of wikis
16:32:35 <shapr> sjanssen: Are you talking about the happswiki?
16:32:45 <shapr> I haven't gotten around to modifying the parser for WikiWords yet.
16:32:49 <sjanssen> shapr: no, haskellwiki.  Think I figured it out
16:33:33 <sjanssen> apparently I needed to just type the URL in myself?  Typing the name in the Go/Search box didn't work
16:33:49 <allbery_b> right
16:33:50 <dons> yep
16:33:50 <dons> you just type in the url
16:34:12 <SamB> to have transparent access to Java stuff, Haskell would need to have roughly the same kind of structure...
16:35:54 <fnord123> Cale, did you try more of that HXT stuff? I'm trying out writeDocument, and it doesn't seem to write it anywhere like the examples on the HXT page suggest.
16:36:08 <Cale> fnord123: hmm
16:36:16 <fnord123> and I tried going req <- writeDocument -- blah blah blah
16:36:20 <Cale> I haven't tried constructing documents yet
16:36:27 <Cale> But I'll try it now
16:36:39 <fnord123> and then printing out some stuff.. and it gave me some peculiar memory dump of the xml i built.
16:36:54 <fnord123> Ill give you a paste to get started if you like
16:37:09 <Cale> sure
16:37:17 <Cale> Is it giving you an XmlTree?
16:37:19 <fnord123> @paste
16:37:20 <lambdabot> http://paste.lisp.org/new/haskell
16:38:05 <sjanssen> http://haskell.org/haskellwiki/Running_processes_concurrently
16:38:06 <lambdabot> Title: Running processes concurrently - HaskellWiki
16:38:09 * sjanssen leaves
16:39:45 <dons> sjanssen++ thanks
16:40:00 <lisppaste2> fnord123 pasted "writeDocument doesn't print" at http://paste.lisp.org/display/32550
16:40:32 <fnord123> OOPS I put in my password!!
16:41:31 <chessguy> ?version
16:41:31 <lambdabot> lambdabot 4p302, GHC 6.5 (OpenBSD i386)
16:41:31 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
16:41:34 <dibblego> I want a data type that is a list of a fixed length; is a typical approach newtype T a = T [a], then hide the data constructor and make sure it is constructed correctly?
16:41:41 <allbery_b> you get to change it now, looks like :)
16:41:47 <Sgeo> Does the typing system actually make Haskell more powerful?
16:41:55 <dibblego> Sgeo, hell yes
16:41:56 <chessguy> hm, doesn't say what version of BSD
16:42:10 <Sgeo> example?
16:42:24 <dibblego> ?type (>>=)
16:42:25 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
16:42:32 <dibblego> gotta go, sorry
16:42:36 <chessguy> Sgeo, yes, thanks to its typing system, haskell is Turing-ultra-complete instead of merely turing-complete
16:42:41 <fnord123> less code and unit tests are required, Sgeo, because we know the typing is correct.
16:42:47 <Sgeo> lol chessguy
16:42:54 <LordBrain> lol
16:43:09 <fnord123> no more "if(blah.type==typeX) errorz
16:43:25 <chessguy> in all seriousness, the nice thing about haskell's typing is that much of the time, if the code types correctly, it just works
16:43:28 <Sgeo> fnord123, other than preventing errors, what does typing do?
16:43:32 <chessguy> s/the/one/
16:43:47 <dons> literally, though, the type system is also turning complete...
16:43:53 <dibblego> haskell type system + QuickCheck proofs -> works (almost)
16:43:59 <Cale> Sgeo: First of all, you can say things about what code doesn't do. This is something which people often ignore the value of, but it's really quite important as far as writing software that actually works goes, as you start to do more and more sophisticated things.
16:44:00 <sorear> i thought it already was :)
16:44:07 <LordBrain> well, type classes make it more powerful, in the sense that we can have various kinds of polymorphism
16:44:08 <fnord123> adds annotation to the code. intent. "oh i can see that "Strings" is a list of strings because it's passed in as [String], etc.
16:44:35 <dibblego> try to write the Maybe data type in Java :)
16:44:38 <Cale> Secondly, with typeclasses, you can direct the behaviour of code based on the types that it has.
16:44:47 <LordBrain> well placing a restriction on your code is an act of doing something which i think should count into our power measure...
16:45:28 <Cale> Let's consider the type of length
16:45:34 <Cale> length :: [a] -> Integer
16:46:01 <Cale> this has implicit in it the guarantee that length will never look at the elements of the list which it is given in order to determine its result
16:46:53 <Cale> This is because it must work for every type of element possible (and there are very few things you can do with something without knowing its type)
16:47:05 <edi> If it worked the other way around then you would probably have been staring at Oleg's code.
16:47:05 <Cale> Another example:
16:47:16 <Cale> map :: (a -> b) -> [a] -> [b]
16:47:18 <Sgeo> Cale, what CAN be done w/ just a
16:47:20 <Sgeo> ?
16:47:31 <Cale> You can apply the identity function to it
16:47:46 <mbishop> http://programming.reddit.com/info/ux9d/comments/cuzdo
16:47:48 <lambdabot> Title: Does Bad Writing Reflect Poor Programming Skills? (reddit.com)
16:47:49 * Sgeo knows that the signature of any function dealing w/ it must begin w/ "a->"
16:47:50 <Cale> and you can copy them around and permute them
16:47:52 * mbishop waits for the ensuing flamewar
16:47:58 <hyrax42> ?djinn a -> a
16:47:59 <lambdabot> f a = a
16:48:18 <Cale> mbishop: hehe
16:48:21 <Excedrin> is there an easy way to parse floating point numbers that can be negative with parsec?
16:48:24 <hyrax42> ?free \a -> a
16:48:25 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
16:48:41 <Cale> Sgeo: but basically not much :)
16:49:18 <Cale> So length really can only look at the structure of the list in order to produce its result, and if it tries to do anything with the elements, that'll be a compile time error
16:49:37 <goltrpoat> is there a name for the set of functions that can be obtained by reifying a particular type?
16:49:59 <Cale> Even if you pass it a list of integers, you have a guarantee that it doesn't go and return the first one or add them up or something :)
16:50:31 <Cale> (even without looking at the code)
16:50:37 <Sgeo> Would the type system be useful at all for a hypothetical Perfect Programmer?
16:50:44 <Cale> actually it still would :)
16:51:00 <Sgeo> e.g.?
16:51:10 <Cale> The reason for that is that types actually can be used to direct what computations are performed as well.
16:51:21 <newsham> sgeo: why would you bother programming?
16:51:43 <LordBrain> if he was perfect you mean?
16:51:45 <Cale> Haskell has these things called typeclasses, which are essentially interfaces to functionality that can be implemented on various types.
16:52:06 <newsham> > Map.empty :: (Map.Map Int Int)
16:52:07 <lambdabot>  Not in scope: type constructor or class `Map.Map'
16:52:12 <Cale> @type (==)
16:52:13 <lambdabot> forall a. (Eq a) => a -> a -> Bool
16:52:31 <Cale> The behaviour of (==) is dependent on the types of things you give it.
16:52:34 <goltrpoat> newsham:  it's imported as M in lambdabot, i think
16:52:37 <yip> hello Cale
16:52:39 <newsham> > return 3 :: (Maybe Int)
16:52:41 <lambdabot>  Just 3
16:52:43 <newsham> > return 3 :: ([] Int)
16:52:44 <lambdabot>  [3]
16:52:50 <Cale> The typeclass Eq is the interface to that functionality
16:52:53 <Cale> @type sort
16:52:55 <lambdabot> forall a. (Ord a) => [a] -> [a]
16:53:25 <Cale> Here, what the sort function does is dependent on the way in which the type of values of the list you pass it are ordered.
16:53:36 <Cale> Which makes sense.
16:53:53 * Sgeo wonders what could be done with a type of class MOrd (like ord except uses Maybe Ordering)
16:54:03 <goltrpoat> sgeo:  posets?
16:54:19 <Cale> Yeah, you might be able to do a topological sort
16:54:35 * Sgeo looks up posets
16:54:38 <Sgeo> goltrpoat, yes
16:54:38 <newsham> partial ordering
16:55:36 <Sgeo> http://en.wikipedia.org/wiki/Surreal_number#Games
16:58:07 * SamB thinks he will try LambdaCore soonish...
17:01:43 <Sgeo> LambdaCore?
17:04:56 <SamB> it is a MOO core database
17:05:08 <[d-_-b]> how to convert an IO Int type in a Int type without the unsafePerformIO function??????
17:05:15 <[d-_-b]> someone knows?
17:05:50 <Cale> http://haskell.org/haskellwiki/Introduction_to_IO -- this should get you started [d-_-b]
17:05:52 <lambdabot> Title: Introduction to IO - HaskellWiki
17:05:53 <int-e> you don't. you run it into the IO monad and then use its result.
17:06:17 <Cale> A value of type (IO Int) is an action which, if it's run, will produce an Int
17:06:26 <int-e> for example: act :: IO Int;  main :: IO (); main = act >>= print
17:06:28 <Cale> Ordinary Haskell evaluation doesn't cause IO actions to run
17:06:41 <Cale> but when a Haskell program is run, main is executed
17:06:50 <Cale> and so are any actions which it's made up of
17:07:16 * yip wonders how many times Cale has encountered this question
17:07:16 <Cale> similarly, you can run an IO action for yourself at the ghci or hugs prompt
17:07:23 <Cale> hundreds? :)
17:07:46 <Cale> It's one of those things which is a little different about Haskell and catches everyone off guard at first.
17:07:52 <Cale> Don't worry, you'll grow to like it.
17:08:06 <[d-_-b]> lolol
17:08:09 <[d-_-b]> ya! ;)
17:08:11 <chessguy> i'm actually just starting to learn to appreciate it
17:08:25 <yip> maybe someone should publish a book with all of the answers that have been used to answer this question over the ages...
17:08:35 <Cale> The fact that IO actions are treated as values is really quite nice because it means that you can construct your own ways of gluing them together, that is, your own control structures.
17:09:22 <mbishop> http://types.bu.edu/modular/compositional/system-i/index.html
17:09:22 <[d-_-b]> ya I see
17:09:24 <lambdabot> Title: System I Experimentation Tool
17:09:40 <Cale> That introduction to IO is pretty short, but should help get you off the ground
17:09:47 <[d-_-b]> thank you all =)
17:09:53 <[d-_-b]> humm thanks =)
17:10:13 <Cale> Let us know if you have any more questions after reading that
17:11:10 <edi> Goodnight!
17:11:37 <Cale> 'night edi
17:11:49 <fnord123> Cale, are you in oz?
17:11:53 <Cale> nope
17:11:58 <Cale> Canada
17:12:02 <fnord123> oh ok
17:12:27 <Cale> You might notice that I'm often up at the same time as the Australians though :)
17:12:33 <fnord123> which one? Mighty Quebec? or Lame Western Canadia?
17:12:46 <Cale> Ontario
17:12:54 <newsham> heh.. "mighty quebec"
17:13:03 <Cale> hehe
17:13:20 <dibblego> 1108 here in Australia (EST)
17:13:24 <newsham> thats where they speak 1600 peasent french right?
17:13:30 <Cale> (In particular, Brantford, Ontario)
17:13:44 <shapr> yow!
17:13:49 <Cale> newsham: sort of, modified over time
17:13:52 <Adamant> @yow
17:13:52 <lambdabot> Now KEN and BARBIE are PERMANENTLY ADDICTED to MIND-ALTERING DRUGS ...
17:13:56 <fnord123> sarabot's in #scheme
17:14:07 <Cale> newsham: but in a different way from how mainland French developed
17:14:10 <newsham> ?quote lambdabot
17:14:11 <lambdabot>  ghc-6.5: panic! (the `impossible' happened, GHC version 6.5):        checkPr...
17:14:34 <fnord123> like USian is a peasant English from 1600s, developed differently from other englishes
17:14:59 <mbishop> http://www.cs.chalmers.se/Cs/Education/Kurser/d1pt/d1pta/external.html
17:15:03 <lambdabot> Title: Programming in Haskell, http://tinyurl.com/y7csh3
17:15:16 <newsham> riiighttt...
17:15:24 <dons> mbishop: nice, hadn't seen that.
17:15:30 <Cale> I can't wait until the US eventually starts spelling phosphorus as fosforus.
17:15:39 <Cale> It's only a matter of time though.
17:15:41 <dons> mbishop: is that available from haskell.org somewhere? under 'tutorials'?
17:15:43 <mbishop> dons: powerpoint slides, but still :)
17:15:45 <dons> mbishop: if not, can you add it?
17:15:51 <mbishop> dons: don't think so, I looked before pasting :P
17:16:00 <fnord123> too many different vowels. try fosforos
17:16:04 <mbishop> oh never mind
17:16:06 <dons> mbishop: you want to add it to the 'Books and tutorials' page?
17:16:06 <Cale> They've already done it to sulphur
17:16:14 <mbishop> it is there, first link under "Course Material"
17:16:16 <fnord123> and paedophile
17:16:17 <dons> ah ok :)
17:16:26 <fnord123> and filipino
17:16:34 <monochrom> filosofy?!
17:16:34 <dons> I'm currently rewriting 'Programming Perl' in Haskell, btw :)
17:16:40 <dons> for today's blog entry :)
17:16:47 <dons> figure its time for some practical stuff
17:16:52 <Saizan> forsfors will be almost italian, "fosforo"
17:16:53 <vincenz> philosophae
17:16:54 <yip> dons: are you familiar with catalyst?
17:16:57 <dons> after the bikeshed^h^h^h syntax debates
17:17:52 * vincenz paints dons transparent
17:18:08 <dons> yip, no?
17:18:28 <yip> dons: is perl worth learning?
17:18:39 <nornagon> yip: no
17:19:17 <Saizan> it's very nice if have to edit huge text files in very few lines.
17:19:22 <yip> nornagon: eh?
17:19:26 <Saizan> +you
17:19:30 <monochrom> filosofae naturalis prinkipia mazematika
17:19:32 <yip> Saizan: well what about the catalyst "web framework"?
17:19:32 <newsham> saizan: and you dont know how to use sed or awk
17:19:33 <dons> sure its worth knowing!
17:19:35 <blsecres> that's what sed and awk are for
17:19:39 <vincenz> monochrom: philosophae
17:19:40 <dons> sed is also worth knowing
17:19:41 <chessguy2> perl has its uses, just like any language
17:19:52 <newsham> perl makes great swear words.
17:19:55 <lisppaste2> fnord123 annotated #32550 with "Printing XML" at http://paste.lisp.org/display/32550#1
17:19:59 * monochrom teases vincenz.
17:20:05 <dons> I don't use perl anymore, but I still use sed. hmm.
17:20:20 <goltrpoat> incidentally, i spent a good two hours last night trying to come up with a single redeeming feature of cobol
17:20:23 <newsham> and usable regexp libs for haskell?
17:20:24 <goltrpoat> i failed miserably
17:20:27 <dons> oh, heheh, http://sob.apotheon.org/?p=171
17:20:28 <lambdabot> Title: SOB: Scion Of Backronymics » UCBLogo and the Fibonacci sequence
17:20:30 <lisppaste2> fnord123 annotated #32550 with "The printed xml" at http://paste.lisp.org/display/32550#2
17:20:41 <dons> newsham: use regex-pcre, regex-posix and so on
17:20:50 <dons> the bytestring based regex libs in the core libs set
17:21:03 <dons> fibs are taking over the universe!
17:21:11 <newsham> i like python's regexp lib a lot.
17:21:27 <newsham> (much omre so than having it language built-in as in perl)
17:21:52 <dons> mmm. we should steal it then!
17:22:16 <chessguy2> dons: s/steal/port/
17:22:24 <newsham> do any of the regexp libs compile the regexp at compile-time?
17:23:14 <dons> newsham: hmm. don't think so. but it /could/ be done
17:23:20 <dons> TH to dump the compiled code into a bytestring
17:23:22 <dons> then goto *
17:23:28 <dons> would be pretty sweet...
17:24:30 <newsham> python api is basically:  m = re.search(exp, str);  m is either Nothing, or a match object in which case m.groups() are the captured groups of the pattern.
17:24:51 <newsham> i guess in haskell something like  search :: RExp -> Maybe [String] ?
17:25:13 <newsham> err String ->  too
17:25:32 <edi> ?where lazy-regex
17:25:33 <lambdabot> http://sourceforge.net/projects/lazy-regex
17:25:38 <newsham> (oh, also accessors for knowing the range of each group's match)
17:25:58 <dons> yeah, I think its got all that going on
17:26:06 <newsham> cool
17:26:21 <newsham> do you get to use strings for regexps or does it condemn you to using some kinda IR? :)
17:26:29 <Saizan> do you think it could be possible to have a string type with regex-like pattern matching?
17:27:01 <dons> newsham: strings
17:27:14 <dons> if you're using a lot, graduating to parser combinators is a good idea, though
17:27:33 <Sgeo> What is "Either" useful for?
17:27:39 <dons> Saizan: hmm. yes. there's nibro's haskell regex preprocessor, in fact
17:27:45 <dons> giving us regex pattern matching on [a] types
17:27:56 <newsham> sgeo: return a proper value or an error value
17:27:57 <dons> Sgeo: returning one of two possible results
17:28:10 <dons> often used to return the real value, or an error value/string
17:28:14 <allbery_b> Sgeo: error handling is a common one:  Either String a -- Left errormessage or Right result
17:28:30 <dons> its equivalent to returning -1 and setting errno in C, but type safe
17:28:40 * Sgeo doesn't know C
17:28:42 <Sgeo> that well
17:28:45 * Sgeo knows Python
17:28:55 <newsham> get it Right or print.Left
17:29:14 <dons> > case 1 + 2 of 3 -> Right "good" ; _ -> Left "No such device or address." -- like errno
17:29:16 <lambdabot>  Right "good"
17:29:34 <Saizan> ?where nibro
17:29:35 <lambdabot> I know nothing about nibro.
17:29:56 <newsham> ?where land_wars_in_central_asia
17:29:56 <lambdabot> I know nothing about land_wars_in_central_asia.
17:30:19 <newsham> (and neither do we :(  )
17:30:32 <Saizan> oh, nibro is a person :)
17:30:52 <dons> yes, google for Niklas Broberg
17:30:58 <dons> and his paper on the haskell regex preprocessor
17:31:08 <dons> (which is widely used , in fact, at least for a few projects)
17:31:22 <Sgeo> Umm... what types are NOT instances of Typeable?
17:31:59 <dons> Sgeo: why all the random questions?
17:32:09 <dons> are you using something that has Either and Typeable on your first day? :)
17:32:27 * Sgeo is just curious
17:32:33 <Cale> fnord123: I have a nice example of document construction for you
17:32:42 <Cale> lisppaste2: url
17:32:42 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/Haskell and enter your paste.
17:32:43 * Sgeo is looking through the Haskell API thingy..
17:32:47 <dons> Sgeo: there are some out there, in particular, polymorphic types
17:33:04 <Saizan> oh, it's trhsx! i've installed it to build lambdabot or some prerequisite iirc
17:33:06 <fnord123> i tried the copyXML example and it works. but the one I've made I'm pretty puzzled why mine doesn't
17:33:08 <mbishop> ?users
17:33:08 <lambdabot> Maximum users seen in #haskell: 291, currently: 252 (86.6%), active: 56 (22.2%)
17:33:12 <lisppaste2> Cale pasted "wallpaper scraper" at http://paste.lisp.org/display/32554
17:33:21 <newsham> is Either instance of Monad?
17:33:32 <Cale> (Either e) is
17:33:53 <fnord123> haha nice hack tool
17:33:56 <newsham> works like maybe to propogate errors (Left)?
17:34:01 <dons> yeah it is
17:34:04 <dons> its the Error monad
17:34:16 <Cale> newsham: exactly
17:34:29 <dons> where, instance (Error e) => Monad (Either e) where
17:34:29 <dons>     return        = Right
17:34:29 <dons>     Left  l >>= _ = Left l
17:34:29 <dons>     Right r >>= k = k r
17:34:32 <dons>     fail msg      = Left (strMsg msg)
17:34:43 <dons> like Maybe with better errors
17:35:49 <shapr> shazam!
17:35:55 <allbery_b> there, by the way, is an example of the type system letting you do things conveniently that require more work in other languages
17:35:59 <dibblego> ?type (:)
17:36:00 <lambdabot> forall a. a -> [a] -> [a]
17:36:04 <yip> is Either () String the same as Maybe String?
17:36:22 <newsham> > liftM (+ 1) $ Right 3
17:36:23 <lambdabot>  Add a type signature
17:36:32 <allbery_b> the monad framework keeps track of the error handling glue for you
17:36:33 <newsham> > liftM (+ 1) $ Right 3 :: Error Int
17:36:34 <lambdabot>    Class `Error' used as a type
17:36:34 <lambdabot>   In the type `Error Int'
17:36:34 <lambdabot>   In an expre...
17:36:35 <dons> yip, they're isomorphic, yes. :)
17:36:46 <newsham> > liftM (+ 1) $ Right 3 :: Either Int
17:36:47 <lambdabot>    `Either Int' is not applied to enough type arguments
17:36:47 <lambdabot>   Expected kind `...
17:37:22 <dons> Either String Int ?
17:37:29 <yip> dons: is there such a thing as a one-way isomorphism?
17:37:30 <newsham> > liftM (+ 1) $ Right 3 :: Either String Int
17:37:31 <lambdabot>  Right 4
17:37:38 <newsham> > liftM (+ 1) $ Left "oops" :: Either String Int
17:37:39 <lambdabot>  Left "oops"
17:38:02 <chessguy> test
17:38:17 <sorear> Terminal Resizing now works in vty
17:38:25 <chessguy> sorry for the identity crisis
17:38:26 <fnord123> Cale, sweet. writeDocumentToString works a treat.
17:38:53 <lisppaste2> Cale annotated #32554 with "refinement (using a nicer datatype, some proc syntax)" at http://paste.lisp.org/display/32554#1
17:39:41 <dons> http://3.141592653589793238462643383279502884197169399375105820974944592.com
17:39:44 <lambdabot> Title: Pi to 1,000,000 places, http://tinyurl.com/fd4v
17:39:56 <Sgeo> How do I type _|_ into Haskell?
17:40:08 <bd_> undefined :)
17:40:09 <dons> > undefined :: () -- like this
17:40:11 <lambdabot>  Undefined
17:40:54 <bd_> > (error "_|_") :: ()
17:40:56 <lambdabot>  Exception: _|_
17:41:04 <dons> :)
17:41:49 <jcreigh> dons: what does the type signature do? Are there "different types" of undefined?
17:41:56 <bd_> let x = case 1 of 2 -> () in x
17:42:01 <bd_> > let x = case 1 of 2 -> () in x
17:42:02 <lambdabot>  Non-exhaustive patterns in case
17:42:03 <allbery_b> :t undefined
17:42:05 <lambdabot> forall a. a
17:42:18 <allbery_b> that way you can use undefined in place f any value without raising a type error
17:42:21 <edi> Cale, nice add (:
17:42:32 <edi> (Spivak-ing instead of sleeping)
17:42:36 <sorear> dons: announce: resizing terminals (catching SIGWINCH, using STM for multiplexing, timing out reads) works
17:42:39 <Cale> hehe
17:42:43 * Sgeo is resuprised by bd_'s presense here
17:42:46 <vincenz> Cale: really nice art
17:42:55 <bd_> Sgeo: Why so surprsing? >.>
17:43:09 <Cale> vincenz: you're referring to the stuff on cale.yi.org?
17:43:12 <vincenz> nod
17:43:16 <Cale> thanks :)
17:43:30 <vincenz> do you start with a preconceived idea when making these things
17:43:35 <vincenz> or just play around until you see something
17:43:42 <Sgeo> Just I keep thinking I'm in lobby when I see "bd_"
17:43:43 <jcreigh> > let f = (+) :: Int -> Int -> Int in f 2 (undefined :: Char)
17:43:44 <lambdabot>  Couldn't match `Int' against `Char'
17:43:49 <jcreigh> > let f = (+) :: Int -> Int -> Int in f 2 undefined
17:43:51 <Cale> Usually I start with some idea, but sometimes I just play around.
17:43:51 <lambdabot>  Undefined
17:44:07 <vincenz> Cause they certainly have strong elements of randomness
17:44:14 <Cale> It's almost never completely fixed in my mind
17:44:25 <dibblego> damn I wish I could use the gimp
17:44:29 <dibblego> that's nice work
17:44:35 <dibblego> very creative
17:44:46 <newsham> > take 10 $ unfoldr (\x -> let (a,b) = x `divMod` 2 in Just (b,a)) (floor (2^8 * pi))
17:44:47 <dons> sorear: nice!
17:44:47 <lambdabot>  [0,0,1,0,0,1,0,0,1,1]
17:44:50 <Cale> Well, also, I'm using fractal generators in some of them, and looking for fractals which I like and then composing those together.
17:45:06 <vincenz> I like the elements
17:45:19 <vincenz> Nothing symbological, but they still contain the feel of the element
17:45:59 <vincenz> How do you do cutups?
17:46:30 <Cale> That was in Adobe Illustrator, which has an x-acto knife tool.
17:46:52 <Cale> But if you'd like to do it manually, it should be easy enough in inkscape
17:46:55 <vincenz> You know is messy (n a good way)... Ever thought about making those shapes actually resemble animals?
17:47:01 <vincenz> "YouKnow"
17:47:09 <vincenz> In an escher style gone futuristic
17:47:59 <Cale> Actually, there's a large portion of my art which is basically completely unrepresented there, because it's all on paper.
17:48:16 <vincenz> xkcd? :P
17:48:27 <vincenz> Anyways > me >>= sleep
17:48:32 <Cale> no hehe :)
17:48:40 <Cale> I might have a picture of one
17:49:47 * vincenz needs to go however, next time :)
17:51:40 <Cale> http://cale.yi.org/autoshare/drawing.jpg -- actually, this one is not nearly as representative of that particular style as I'd hoped, but it's something like it.
17:56:23 <edi> Cale, the dali clock is funny (:
17:56:23 <goltrpoat> > let pi n = 3 + foldr1 (\a b -> a / (6 + b)) (map (^2) [1,3..n]) in pi 10000
17:56:25 <lambdabot>  3.141592653591793
17:56:32 <Cale> edi:  :)
17:56:37 <edi> Cale: I've seen drawings like that before somewhere...
17:57:37 <beelsebob> > let pi n = 3 + foldr1 (\a b -> a / (6 + b)) (map (^2) [1,3..n]) in map pi [1..10]
17:57:38 <lambdabot>  [4.0,3.066666666666667,3.066666666666667,3.158974358974359,3.158974358974359...
17:57:46 <beelsebob> useful
17:58:12 <ray> not bad
17:58:18 <newsham> scanr1?
17:58:44 <chessguy> woohoo! i've got gnome up and running. using X by itself gets old REAL fast
17:58:49 <ray> i was so pissed off when xdaliclock wasn't a real dali clock
17:58:52 <chessguy> test
17:58:59 <ray> twm's not that bad dude
17:59:07 <ray> don knuth uses it
17:59:18 <Saizan> Cale: remember my cellular automata simulator? i've done this http://ic3.deviantart.com/fs7/f/2006/344/4/4/Ichi_by_saizan.png with it and photoshop :D
17:59:22 <chessguy> hmm, are you guys seeing my handle or just <     >
17:59:34 <newsham> <chessguy> hmm, are you guys seeing my handle or just <     >
17:59:35 <ray> hehe
17:59:43 <chessguy> weird, i can't see my own handle
17:59:49 <ray> change its colour
18:00:04 <sorear> I use X by itself ... OK, OK, I use ion
18:00:06 <chessguy> dunno how
18:00:09 <sorear> (used to use fvwm2)
18:00:25 <sorear> (actually most of my work is done on the linux-console)
18:00:26 <edi> Saizan: is it in Haskell? (:
18:00:26 <chessguy> i don't much like irssi
18:00:46 <Cale> Saizan: awesome
18:00:46 <newsham> saizan: looks like you might have caught something.
18:01:02 <Saizan> newsham: in what sense?:D
18:01:03 <ray> it's white by default
18:01:07 <ray> so if you're using a white background
18:01:16 <Cale> chessguy: what distribution are you running?
18:01:23 <chessguy> just installed openbsd
18:01:28 <Cale> Or was that openbsd, right
18:01:36 <ray> a real os :D
18:01:55 <chessguy> i kinda like it. wish it had support for my wireless card
18:02:06 <Saizan> Cale: thanks, edi: the CA sim? yes, it's only ugly to write the rules for it at the moment
18:02:07 <newsham> http://www.thenewsh.com/%7Enewsham/x/machine/mand3_2.jpg
18:02:30 <newsham> saizan: whatever you seeded that culture with is growing.
18:02:39 <jcreigh> chessguy: hmm...that doesn't sound like a feature. You're seeing "<        >" for your messages?
18:02:45 <dons> chessguy: blame the evil broadcom vendors
18:03:06 <Saizan> newsham: if you know life, it was a slight modified turbine8 :)
18:03:06 <newsham> mand3_2.jpg == haskell
18:03:14 <sorear> Question about Concurrency: Having read the STM Invariants paper: are normal threads GC'd when all the refs that could wake them are held only by that thread?
18:03:15 <ray> hey, at least broadcom gives them stuff to sing about
18:03:18 <chessguy> jcreigh: yeah, if i highlight all the text, it shows up
18:03:23 <newsham> saizan: i wrote many CA's.
18:03:29 <dons> chessguy: hey, so you're running irssi on openbsd right now?
18:03:31 <chessguy> i just don't know how to tell irssi to change the color of my handle
18:03:31 <newsham> but i'm not really familiar with life.
18:03:37 <dons> $ uname -msr
18:03:38 <chessguy> dons: indeed
18:03:38 <dons> OpenBSD 3.8 i386
18:03:41 <dons> cool!
18:03:59 <chessguy> i got gnome to install
18:04:04 <dons> nice
18:04:05 <chessguy> and firefox
18:04:14 <chessguy> i feel l33t now
18:04:15 <dons> got emacs on there?
18:04:21 <chessguy> not yet
18:04:21 <newsham> why gnome?  machine was using too little ram?
18:04:23 <Cale> sorear: hmm, that sounds like more of an implementation question than a semantics question, I don't know
18:04:26 <ray> try mg
18:04:43 <dons> yeah, if you're happy with mg, its already on there, and pretty sweet
18:04:45 <Cale> why not gnome?
18:04:49 <dons> but it ain't no emacs
18:04:58 <Cale> RAM is pretty cheap these days
18:05:03 <ray> it's emacs for people like me
18:05:12 <newsham> cale: save the ram for vmware :)
18:05:34 <sorear> Cale: I consider it similar to tail recursion.  It is an implementation issue, but it would have a big effect on programming style.
18:05:36 <Cale> what do you run in vmware?
18:05:42 <sjanssen> sorear: I think threads are only GC'ed when they complete
18:06:40 <fnord123> ram is cheap until you decide you want to scale your server up to handle more work
18:06:54 <fnord123> then, a user using 400 mb on a process is harsh!
18:07:10 <Saizan> ram is cheap unless you open eclipse.
18:07:15 <newsham> cale: many winxp's, occasionally a linux, freebsd or vista.
18:07:37 <monochrom> why install gnome?  ram is so cheap you can run vmware, inside which you ssh to a server and run gnome there.
18:07:41 <loufoque> Saizan: it's not eclipse which is the problem, it's Java.
18:07:53 <ray> i've got a plan9 in qemu
18:08:32 <ray> i'd love to spend some time learning it, but time is expensive
18:08:32 <wy> ray: how do you feel about plan9?
18:08:39 <Saizan> loufoque: well, my tomcat process takes very less ram than eclipse :)
18:08:45 <ray> i don't have enough information to say
18:08:57 <Saizan> (is "very less" correct?)
18:09:07 <ray> the whatever-it-is (acme, i think) is pretty cool
18:09:14 <loufoque> Saizan: they don't use the same libraries
18:09:15 <ray> saizan: "much less"
18:09:17 <newsham> i dont find gnome terribly useful.
18:09:28 <newsham> i use twm on my uni xmachines usually
18:09:34 <loufoque> newsham: it's a desktop, it's not meant to bake bread.
18:09:38 <newsham> ray: yah, i like acme.
18:10:15 <Cale> Gnome has a filemanager which actually manages to add value over the terminal for quite a few tasks.
18:10:16 <newsham> louf: yah, its meant to run xterms and the occasional gui app.  not sure why i need a start menu and a bunch of docking applets.
18:10:26 <chessguy> is vi the only editor that comes built into openbsd?
18:10:28 <Cale> Otherwise, I probably wouldn't use it :)
18:10:38 <newsham> i never use the filemanager.
18:11:00 <ray> chessguy: mg
18:11:04 <Cale> I used to never use the filemanager, but nautilus has some rather nice features.
18:11:10 <chessguy> oh that's right
18:11:17 <ray> :)
18:11:29 <edi> Cale, like?
18:11:46 <loufoque> newsham: the menu allows to give easy access to the graphical applications you typically use and group them in categories. Of course, if you only use graphical applications occasionally, it's quite useless.
18:12:00 <dons> chessguy, also mg
18:12:03 <dons> and ed
18:12:06 <dons> and anything in ports :)
18:12:07 <newsham> louf: its faster to type "mozilla&" than to nav the menu
18:12:21 * sorear loves ed
18:12:38 <newsham> (also virtually every wm for unix lets you put apps in a menu if you choose to)
18:12:41 <ray> typing is almost always faster
18:12:54 <sorear> Among the computers I've been restricted to was an OSX mac with no other editor
18:12:54 <geckosenator> why would you use a menu when you can type in a console?
18:13:14 <ray> especially if your mouse is far away while you lean back in a chair with your keyboard (which is my setup)
18:13:19 <chessguy> yeah, i'm slowly adding packages
18:13:34 <Cale> Its file previews are rather good. It also has really nice integration with network shares that I haven't quite managed to get at the filesystem level with kernel modules.
18:13:39 <chessguy> how do i save and exit mg?
18:13:44 <sorear> ^X^C
18:13:59 <chessguy> naturally, why didn't i think of that
18:14:24 <sorear> mg clones everything about emacs except the programmability.
18:14:28 <newsham> automount?
18:14:42 <allbery_b> you'd prefer ^Kd like some dos-ish editor used?
18:14:48 <sorear> automount? Bah.  I want auto*u*mount!
18:15:11 <sorear> It predicts when you are about to remove the disc and umounts it 1 second earlier!
18:15:16 <jcreigh> *mutter* silly monomorphism restriction...
18:15:36 <newsham> how about hot-key eject which does an unmount and eject?
18:15:36 <Cale> oops, I noticed that I pasted the wrong version of the code on that last annotation :)
18:15:57 <Cale> but that was a while ago, and I suspect that anyone who cares has noticed what was wrong
18:16:11 <sorear> Unfortunately, I do not yet have an auto-ejecting USB port.
18:16:16 <shapr> pting!
18:16:21 <sorear> How about what ancient Macs did?
18:16:31 <newsham> this is far offtopic.  (`mv` #haskell-blah)
18:16:55 <lisppaste2> Cale annotated #32554 with "correction" at http://paste.lisp.org/display/32554#2
18:17:15 <Cale> well, there it is, trivial renaming :)
18:18:12 * chessguy pkg_add's nedit and emacs
18:18:18 <sorear> if you remove a disc, the system remembers the disc, and you can umount it *after* you remove it - but when it tries to sync, it asks you to reinsert the disc.
18:18:28 <fnord123> what is -< ?
18:18:29 <Cale> Somehow I managed to learn how to use HXT by skimming the tutorial, and looking a few things up in the documentation :)
18:18:48 <monochrom> -< is a punctuation.
18:18:48 <Cale> -< is the right half of an arrow :)
18:18:56 <fnord123> evidence of a great lib, Cale
18:19:12 <chessguy> hmm, i think next is to add some haskell tools!
18:19:34 <sorear> (Topic ago) I wrote a test program that forks an infinite number of deadlocked threads, and ran it for 30 seconds with no sign of strictly monotonic memory usage.
18:19:39 <Cale> HXT's documentation is really scary when you first look at it though
18:19:48 <fnord123> i noticed :P
18:20:03 <sorear> (is this sufficiently tricky that I should paste my test program for critique?)
18:21:29 <chessguy> ?go ghc site:haskell.org
18:21:31 <lambdabot> http://www.haskell.org/ghc/
18:21:31 <lambdabot> Title: The Glasgow Haskell Compiler
18:21:48 <monochrom> HXT's manual is an MSc thesis - that's scary point one.  Scary point two: a large number of arrows introduced are not needed if you use proc and/or the ArrowApp operators.  E.g., those <$< thingies.
18:22:21 <Cale> Well, I was more thinking of the Haddock
18:22:25 <Cale> but yeah
18:22:47 <chessguy> aww, the latest package is pretty old
18:22:49 <chessguy> 6.2.2
18:23:55 <monochrom> The Haddock could use some elaboration.  But ok if you're willing to experiment to find out the details and not need spoon-feeding.
18:24:11 <Sgeo> Erm, I recently read a tutorial claiming that lambda expressions couldn't be recursive
18:24:30 <Cale> The problem is mostly that there's a lot of stuff there, so it's tricky to find what's important.
18:24:47 <jcreigh> Sgeo: well, not easily, but there's always the Y combinator.
18:24:49 <Cale> Sgeo: right
18:25:17 <Cale> The Y combinator can't be written as a lambda term in the simply typed lambda calculus.
18:25:28 <Sgeo> ..oh..
18:25:57 <Sgeo> The tutorial just said that it was because it couldn't refer to itself..
18:26:26 <Cale> well, that's kind of a more practical way to look at it. :)
18:27:10 <Cale> But yeah, it's not possible to write well-typed fixed point operators directly, so they're usually added explicitly.
18:28:02 <Cale> > fix (\f n -> if n == 0 then 1 else n * f (n - 1)) 10
18:28:04 <lambdabot>  3628800
18:28:15 <Sgeo> ?type fix
18:28:16 <lambdabot> forall a. (a -> a) -> a
18:28:20 <Cale> of course, once you have such an operator, it's no problem to do recursion
18:28:23 <Sgeo> ?info fix
18:28:23 <lambdabot> fix
18:28:32 <Cale> fix f = f (fix f)
18:28:38 * SamB can't get genericserialize to work
18:28:39 <Cale> is the definition
18:28:59 <Cale> (In Haskell, even)
18:29:15 <SamB> in particular, it refuses to typecheck
18:30:01 <Cale> Some people seem to like   fix f = let x = f x in x
18:30:16 <Cale> which is the same
18:30:47 <Saizan> mmh, i've a problem with fix when is used to generate an infinite recursion
18:30:48 <SamB> only because we don't trust the compiler to do CSE with the lhs!
18:30:50 <jcreigh> Cale: are you saying that, using only lambda forms, you can't write the Y combinator in Haskell?
18:31:02 <Cale> yes
18:31:03 <SamB> jcreigh: indeed!
18:31:20 <sorear> using lambda terms, you *can* write Y, but not in Haskell.
18:31:41 <monochrom> If you go untyped, you can.
18:31:57 <SamB> > (\b->bb)(\->.vv)
18:31:58 <Cale> You can only do it in untyped lambda calculus, or possibly in some fancily typed lambda calculi
18:31:59 <lambdabot>  Not in scope: `vv'
18:32:01 <SamB> > (\b->bb)(\v->.vv)
18:32:01 <lambdabot>  Parse error
18:32:02 <monochrom> Then someone will demonstrate a paradox using it.
18:32:07 <SamB> > (\b->bb)(\v->vv)
18:32:08 <lambdabot>  Not in scope: `vv'
18:32:13 <Saizan> as in fix ((1:) . scanl (+) 1), i just don't see at which point it could get something to work on
18:32:14 <sorear> You can do it in the untyped Unlambda, and you can do it in my infinite-types lambda calculus, but not in the finitely typed Hindley-Damas-Milner calculus
18:32:18 <SamB> > (\b->b b)(\v->v v)
18:32:19 <lambdabot>    Occurs check: cannot construct the infinite type: t = t -> t1
18:32:19 <lambdabot>    Expe...
18:32:32 <jcreigh> hmm...that's interesting. I had assumed that you could.
18:32:33 <SamB> who wrote genericserialize?
18:32:38 <sorear> me
18:32:46 <Cale> Saizan: something to work on?
18:32:47 <monochrom> (1:) bootstraps the recursion.
18:32:48 <SamB> sorear: it won't typecheck in 6.4!
18:33:18 <Cale> Saizan: think about actually printing the list of values, generating demand -- first of all you're going to need to know the first element of the list
18:33:22 <sorear> is GHC choking on the scoped type variable?
18:33:22 <Saizan> Cale: an argument for ((1:) . scanl (+) 1)
18:33:26 <Cale> Saizan: you can tell immediately what that is
18:33:32 <Cale> argument?
18:33:49 <SamB> sorear: the what?
18:33:50 <Cale> fix ((1:) . scanl (+) 1) = ((1:) . scanl (+) 1) (fix ((1:) . scanl (+) 1))
18:33:59 <monochrom> No matter what x is, ((1:) . scanl (+) 1) x = 1 : something more.  Now you're in business.
18:34:13 <monochrom> Recall lazy evaluation or call-by-name.
18:34:18 <SamB> serGeneral :: (Data a, MonadWStream m Char) => a -> m ()
18:34:19 <SamB> serGeneral a = let (cn, act) = gSerial (\a -> putv " " >> sexpSerialize a) a
18:34:19 <SamB>                in putv "("; putv (concatMap sanitizeA (show cn)); act;  putv ")"
18:34:22 <monochrom> (my "or" does not mean they're the same.)
18:34:24 <Saizan> well ((1:) . scanl (+) 1) is a function, to produce a value it needs an argument
18:34:25 <SamB> it complains about the show cn
18:34:33 <SamB> yes, I realize that isn't quite what you have
18:34:35 <Cale> Saizan: fix f = f (fix f)
18:34:42 <Saizan> ooh, so it's the "no matter what" that matters?
18:34:43 <Cale> Saizan: the parameter will be fix f
18:34:46 <SamB> Data/Generics/Serialization/SExp.hs:41:66:
18:34:47 <SamB>     No instance for (MonadWStream m Char)
18:34:47 <SamB>       arising from use of `cn' at Data/Generics/Serialization/SExp.hs:41:66-67
18:34:47 <SamB>     Probable fix: add an instance declaration for (MonadWStream m Char)
18:34:47 <SamB>     In the first argument of `show', namely `cn'
18:34:47 <SamB>     In the second argument of `concatMap', namely `(show cn)'
18:34:48 <SamB>     In the first argument of `putv', namely `(concatMap sanitizeA (show cn))'
18:35:03 <Cale> lisppaste2: url
18:35:03 <edi> > iterate ((1:) . scanl (+) 1) [1]
18:35:03 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/Haskell and enter your paste.
18:35:05 <lambdabot>  [[1],[1,1,2],[1,1,2,3,5],[1,1,2,3,5,8,13],[1,1,2,3,5,8,13,21,34],[1,1,2,3,5,...
18:35:08 <edi> clear? (:
18:35:18 <Cale> edi: that's backwards though :)
18:36:58 <Saizan> mmh yes, i get it again now, you don't need to evaluate (fix f) for f to is it as its argument, so it works
18:37:21 <Saizan> s/is/use/
18:37:31 <chessguy> ummm
18:37:35 <Cale> Remember this is lazy evaluation, which is outermost-first with sharing
18:37:46 <chessguy> stupid question, how can i tell whether emacs correctly started in haskell mode?
18:37:48 <jcreigh> hmmm...so, is it correct that the basic problem is that we can't write "\f -> f f"? (becuase no matter what type "f" has, it's wrong, because it needs to have "its own" type as its argument.)
18:37:51 <Cale> So f is expanded before its parameter (fix f) is
18:38:14 <edi> chessguy: you read "Haskell" in the modeline of the buffer in which haskell-mode has been activated
18:38:20 <Cale> jcreigh: yeah, it would have an infinite type
18:38:51 <chessguy> oh, i see it now
18:39:13 <monochrom> lazy evaluation is very easy to understand.
18:39:30 <monochrom> or at least, call-by-name is.
18:39:59 <sorear> Setup.lhs: Multiple description files found.  Please use only one of : [".#genericserialize.cabal","genericserialize.cabal"]
18:40:01 <monochrom> Recall that call-by-name is the first evaluation strategy conceived for the lambda calculus.
18:40:15 <monochrom> call-by-value was an after-thought.
18:40:21 <SamB> sorear: some crazy emacs thing?
18:40:41 <sorear> an emacs autosave file confused cabal
18:41:22 <sorear> SamB: is that the only error you got?
18:41:22 <SamB> yeah, well, you want it to specifically check for those?
18:41:33 <SamB> sorear: now that I edited some things, yes!
18:41:40 <SamB> you want me to send you a patch?
18:41:49 <sorear> yes
18:42:02 <sorear> I don't have 6.4 available...
18:42:11 <araujo> hello around here
18:42:24 <SamB> oh, btw, I don't think what I pasted parses right now
18:42:28 <SamB> but anyway...
18:42:37 <SamB> I'll just skip that part
18:43:23 <chessguy> wow, how much easier can it get to install darcs than just typing 'pkg_add darcs'
18:43:35 <Cale> It would be nice to make an animation of the graph transformation which takes place as fix ((0:) . scanl (+) 1) is evaluated.
18:43:48 <SamB> chessguy: is that harder than apt-get install darcs somehow?
18:43:58 <SamB> sorear: what is your email?
18:44:03 <Saizan> cale: I was thinking just that just now :O
18:44:04 <monochrom> Someone writes the code "os = 1:os".  Here is a way to find out what it does.
18:44:08 <SamB> you neglected to put it in the repo
18:44:18 <sorear> it should be in the cabal file...  (will add to repo, thanks)
18:44:20 <chessguy> SamB: what is that, debian?
18:44:26 <SamB> chessguy: yeah
18:44:34 <monochrom> Nevermind, it's long.
18:44:34 <chessguy> ah
18:44:40 <ray> monochrom: list o' ones!
18:44:45 <chessguy> aww, no package for cabal though
18:45:03 <sorear> debian has a cabal package
18:45:09 <Cale> The way I tend to think about lazy lists is just to consider what I'd do if I was going to work out the first element, or the second, and so on.
18:45:18 <SamB> monochrom: what?
18:45:22 <monochrom> Yes, listen to Cales.
18:45:25 <SamB> I know what it does!
18:45:31 <SamB> > repeat 1
18:45:33 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
18:45:38 <SamB> thats what it does!
18:45:39 <geckosenator>  what if there are algorithms that are faster than O(n) to find an element?
18:45:43 <monochrom> I was targetting that total newbies.
18:45:45 <geckosenator> then a lazy list is bad
18:45:50 <Cale> > cycle (repeat 1)
18:45:52 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
18:46:19 <Cale> My infinite list of 1's is way more infinite than yours! :)
18:46:20 <sorear> then use a lazy array rose tree! O(log log n)
18:46:32 <monochrom> No, geckosenator, no one asserts that we should use restrict ourselves to lazy lists.
18:46:35 <geckosenator> sorear: how do you do that?
18:46:49 <sorear> ?hawiki MemoizingCafs
18:46:49 <lambdabot> Maybe you meant: gwiki wiki
18:46:53 <geckosenator> monochrom: well wouldn't it be better if it could use various algorithms?
18:47:00 <ray> lazy lists are the best way to handle infinite sequences and stuff
18:47:01 <Saizan> uhm, can we put a ... for infinite lists in ghci too?:D
18:47:10 <monochrom> I think you're just rambling.
18:47:12 <geckosenator> so it would know if n < 20 use iterative
18:47:19 <Cale> geckosenator: lazy lists are the data structure reification of loops
18:47:36 <Cale> geckosenator: Just as you wouldn't always use a loop, you wouldn't always use a list.
18:47:43 <geckosenator> Cale: can you do a loop where your counter increases by different amounts with each iteration?
18:47:49 <ray> tjere
18:47:50 <ray> er
18:47:57 <ray> there's arrays somewhere
18:48:05 <monochrom> troll
18:48:05 <Cale> Sure, by dropping elements of a list, if you'd like.
18:48:16 <sorear> lazy binary trees are the data structure reification of induction on the binary index,  hence O(log n).
18:48:33 <geckosenator> how do you do lazy binary trees?
18:48:49 <Cale> data Tree a = Leaf | Branch a (Tree a) (Tree a)
18:48:50 <sorear> array rose trees (my name) take ever-increasing chunks of the index off
18:49:14 <geckosenator> Cale: cool
18:50:09 <geckosenator> is there a list-ref in haskell?
18:50:22 <chessguy> hmm, i can't find cabal for openbsd
18:50:42 <Cale> > "Hello" !! 1
18:50:43 <lambdabot>  'e'
18:50:52 <SamB> chessguy: doesn't it come with GHC?
18:51:03 <allbery_b> cabal's a base ghc package
18:51:04 <Cale> xs !! n takes O(n) time, of course.
18:51:14 <chessguy> oh
18:51:18 <SamB> if you want a newer one, just use darcs!
18:51:19 <geckosenator> oh, I wanted it to be O(logn) if possible :-P
18:51:31 <Cale> Well, you won't get that with lists.
18:51:38 <geckosenator> ok
18:51:49 <Cale> Note that the list doesn't even exist beyond where you've looked at it.
18:51:50 <SamB> you could try Okasaki's book ;-)
18:51:57 <SamB> @hoogle Sequence
18:51:58 <lambdabot> Prelude.sequence :: Monad m => [m a] -> m [a]
18:51:59 <lambdabot> Prelude.sequence_ :: Monad m => [m a] -> m ()
18:51:59 <lambdabot> Language.Haskell.TH.Syntax.sequenceQ :: [Q a] -> Q [a]
18:52:11 <Cale> So !! can't do any magic to tell what parts of the computation to skip.
18:52:32 <chessguy> ok, i'm done hacking for a while. i got a lot done today
18:52:35 <sjanssen> geckosenator: use Data.Sequence if you have a newish Haskell compiler
18:52:39 <sorear> SamB: patch recieved and applied.
18:52:44 <Sgeo> Um...
18:52:45 <fnord123> is there a pretty print function that will turn \n into actual newlines?
18:52:50 <Sgeo> dumb question.. but..
18:53:02 <SamB> sorear: of course, it still won't build :-(
18:53:04 <Cale> Yeah, Data.Sequence restricts you to finite sequences, but has really good complexities for all operations.
18:53:08 <SamB> I think
18:53:09 <monochrom> putStr "\n"  like that?
18:53:11 <Sgeo> Is there a better way to make an infinite list of factorials then making a factorial function then using a list comprehension?
18:53:18 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Sequence.html
18:53:20 <lambdabot> http://tinyurl.com/um3d4
18:53:37 <jcreigh> > scanl (*) 1 [1..]
18:53:38 <lambdabot>  [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,...
18:53:40 <SamB> scanl (*) 1 [1..]
18:53:48 <SamB> yeah, I was going to do that too jcreigh ;-)
18:53:53 <SamB> but I forgot the >
18:53:53 <jcreigh> heh
18:53:58 <Cale> Generally, splitting a sequence at the index k takes O(log(min(k, n-k))) time.
18:54:01 <monochrom> scanl reuses results
18:54:01 <SamB> and you beat me anyway
18:54:02 <Cale> where n is the length
18:54:03 <sorear> I hit C-a C-k just in the nick of time!
18:54:19 <Cale> and concatenation takes O(log(min(n1,n2))) time
18:54:34 <Cale> and accesses to both ends are constant time
18:54:41 <Cale> So it's really very quick :)
18:54:44 <geckosenator>  sjanssen thanks, I will look into it
18:55:10 <SamB> how similar is the datastructure to Data.Map?
18:55:40 <Cale> Not all that similar?
18:55:48 <fnord123> yes like putStr, thanks
18:55:51 <Cale> I suppose they're both trees
18:56:14 * SamB thought Data.Map used a structure that could easily be adapted for that purpose.
18:56:19 <SamB> maybe not quite as catenable
18:57:26 <monochrom> If sequence operations are logarithmic time, they sound like going through a binary search tree of number keys.
18:57:42 <Cale> http://www.soi.city.ac.uk/~ross/papers/FingerTree.html
18:57:43 <monochrom> or trie, or ...
18:57:45 <lambdabot> Title: Finger Trees: A Simple General-purpose Data Structure
18:57:50 <Sgeo> > scanl1 (*) [1..]
18:57:51 <lambdabot>  [1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,87...
18:58:07 * Sgeo likes scanl1 better
18:58:11 <monochrom> OTOH, if you are careful in your analysis, nothing in the world is constant time.
18:58:53 <SamB> monochrom: well, many things can be considered to be O(1)
18:58:58 <sorear> if you are careful in your analysis, Hugs is impossible, because Haskell is turing complete and C is not.
18:59:02 <jcreigh> Sgeo: yeah, but then 0! isn't defined...
18:59:14 <SamB> as long as you don't put your swapfile on a DHT
18:59:37 <Sgeo> > (scanl1 (*) [1..]) !! 0
18:59:39 <lambdabot>  1
18:59:40 <Sgeo> > (scanl1 (*) [1..]) !! 1
18:59:42 <lambdabot>  2
18:59:47 <monochrom> For example, suppose you have a large array.  Because for all practical purposes, array-like memory must be organized into several levels (a simple example is L0 cache, L1 cache, L2 cache, ...), accesses are logarithmic.  The only claims you can make is that the base of the logarithm is like 10^6.
18:59:52 <Sgeo> oO at off-by-one thingy
18:59:59 <SamB> monochrom: no no
19:00:11 <SamB> you can just allow the longest access time, and say it is O(1)
19:00:11 <monochrom> yes yes
19:00:20 <SamB> clearly this ain't true
19:00:30 <SamB> or, rather, ain't the whole picture
19:00:33 <SamB> ;-)
19:00:44 <sorear> ... but then when you double the array size, you need to move the memory further away.
19:00:55 <monochrom> If you believe SamB's logic, the whole bloody universe is finite, so every search operation must be O(2^128) times.
19:00:57 <Cale> SamB: as you add more memory to the system, are you really going to be able to place it in a single spherical shell?
19:01:04 <SamB> monochrom: I never said that
19:01:05 <jcreigh> is "f x = f x" O(1)? :)
19:01:11 <sorear> If you consider latency, memory access is at most O(n^1/3)
19:01:13 <Cale> (Of constant radius)
19:01:24 <SamB> indeed, I won't even say that the part of the universe you could use for storage is finite
19:01:27 <monochrom> You never said that, because you don't realize the implication of your logic.
19:01:34 <Cale> Or I suppose you get the whole content of a ball.
19:01:46 <sorear> But this is Haskell, and a sufficiently clever compiler could pipeline memory access, thereby allowing O(1) throughput.
19:01:47 <SamB> I'm just saying *if you keep everything inside the computer*
19:01:53 <SamB> or maybe *on the LAN*
19:01:59 <SamB> emphasis on the L
19:02:13 <kpreid> "given some maximum distance, access is O(1)"
19:02:25 <SamB> sorear: they are always claiming that a "sufficiently clever compiler" could do this or that
19:02:38 <Cale> SamB: if you fix the amount of space available, there's only so much information which you're going to be able to pack into that space, unless you make some assumption like that the universe supports unbounded information density.
19:02:38 <SamB> I claim that a sufficiently clever compiler could write its own damn program
19:02:54 <SamB> Cale: true!
19:03:01 <sorear> access can be faster if you are allowed to pipeline access - I can send data quickly to Japan, even though it takes at least 1/14 sec to get there.
19:03:18 <sorear> (speed-of-light)
19:03:19 <SamB> But probably you couldn't actually access an infinite amount of storage anyway.
19:03:33 <Cale> No, but complexity analysis is as n -> infinity
19:03:42 <Cale> you're never assuming that n = infinity
19:03:45 <SamB> sorear: is that surface distance, or is that through-the-core distance?
19:03:46 <monochrom> Perhaps SamB is unimaginative about the whole bloody universe and can only comprehend one single computer.  OK, let us just focus on that.  Because the computer has bounded memory, say 4GB RAM, all binary search tree operations are going to be O(4GB) too, i.e., not the academically-acclaimed, Perler-derided O(log n).
19:03:51 <Cale> but you are assuming that it grows without bound
19:03:51 <Sgeo> > let twos = iterate (2^) 1 in twos !! 6
19:03:56 <lambdabot> Terminated
19:04:03 <SamB> monochrom: point
19:04:23 <Sgeo> > let twos = iterate (2^) 1 in twos !! 5
19:04:25 <lambdabot>  2003529930406846464979072351560255750447825475569751419265016973710894059556...
19:04:28 <Cale> If you restrict yourself to finite memory, everything takes O(1) space
19:04:33 <sorear> If you try to store more than O(r^2) (that's 2 not 3) data in a sphereical shell of radius r, your memory will collapse into a black hole.  See "Bekenstein Bound".
19:04:41 <SamB> monochrom: except I could use my hard disk
19:04:44 <monochrom> I am just trying to demonstrate that the Perl monkey's "oh oh O(log n) is sloooowwww! Look at our O(1) hash tables" is unfounded.
19:04:47 <SamB> last I checked, I had like a 40 GB drive
19:04:58 <SamB> hahaha
19:04:58 <Sgeo> Does Haskelll have a constant representing e?
19:05:10 <SamB> > exp 1
19:05:11 <lambdabot>  2.718281828459045
19:05:18 <Sgeo> Ah
19:05:22 <sorear> last I checked my hard drive is made of matter...
19:05:24 <SamB> that is a constant, too!
19:05:25 <Cale> > log (exp 1)
19:05:27 <lambdabot>  1.0
19:05:28 <sorear> let e = exp 1 in ...
19:06:11 <newsham> does ghc implement System.Posix.* for windows?
19:06:21 <Sgeo> Ctrl-C isn't stopping the twos !! 6 thing that I ran in my interpreter :(
19:06:23 <sorear> System.Posix.Signal is in 'base'
19:06:41 <sorear> Sgeo: try killall -9 ghci-6.6
19:06:56 <Sgeo> It just ran out of memory
19:07:04 <sorear> Oh, that'll work too :)
19:07:21 <newsham> Prelude> :module +System.Posix.Directory
19:07:22 <newsham> Could not find module `System.Posix.Directory'
19:07:27 <int-e> hmm. bash: ^Z ; kill %1
19:08:17 <monochrom> hard disks and lans are ok.  When your hashtable is large, you have to spill it over to the hard disk, spread it over the lan, .... all the slower.
19:09:09 <monochrom> No one can escape Omega(log_b n) access cost of an element in a collection.  The only thing you can fudge is b.
19:09:14 <newsham> how does one list directories in windows in ghc?
19:10:08 <SamB> I think if you are storing the element in memory it is okay to pretend it is O(1) to access...
19:10:32 <SamB> I mean, only crazies use DHTs for their swapfiles
19:11:23 <kpreid> @let settle f x = head . head . filter (not . null . tail) . group $ iterate f x
19:11:25 <lambdabot> <local>:11:64:     Ambiguous occurrence `iterate'     It could refer to eithe...
19:11:25 <Saizan> newsham: System.Directory
19:11:31 <monochrom> I don't think it's ok to pretend O(1).  I think it's more honest to pretend b=10^6 and n<=10^6.
19:11:36 <kpreid> @let settle f x = head . head . filter (not . null . tail) . List.group $ Prelude.iterate f x
19:11:38 <lambdabot> Defined.
19:12:08 <Saizan> ?type L.settle
19:12:10 <lambdabot> Couldn't find qualified module.
19:12:19 <Sgeo> > let es   = iterate (exp) 1 in es!!5
19:12:21 <lambdabot>  NaN
19:12:22 <newsham> I dont see any System.Directory functions for enumeration in the docs.
19:12:28 <kpreid> > settle exp 1
19:12:29 <Sgeo> > let es   = iterate (exp) 1 in es!!200
19:12:29 <lambdabot>  Not in scope: `settle'
19:12:31 <lambdabot>  NaN
19:12:34 <kpreid> > L.settle exp 1
19:12:38 <lambdabot> Terminated
19:12:40 <kpreid> > L.settle (exp . recip) 1
19:12:42 <lambdabot>  1.7632228343518968
19:13:10 <Sgeo> umm...
19:13:13 <Sgeo> What does settle do?
19:13:14 <newsham> ahh, but it does have functions in :browse System.Directory.  nevermind.
19:13:17 <Sgeo> ?type L.settle
19:13:19 <lambdabot> Couldn't find qualified module.
19:13:22 <Sgeo> ?type settle
19:13:24 <lambdabot> Not in scope: `settle'
19:13:27 <kpreid> @type let settle f x = head . head . filter (not . null . tail) . List.group $ Prelude.iterate f x in settle
19:13:30 <lambdabot> forall a. (Eq a) => (a -> a) -> a -> a
19:13:40 <allbery_b>  ?type doesn't know about stuff that's been ?let
19:13:57 <kpreid> Sgeo: applies f until the result is the same as the argument
19:14:57 * Sgeo wishes he understood it
19:16:17 <monochrom> You can understand it one stage at a time.
19:16:34 <monochrom> Prelude.iterate f x should be obvious.
19:17:06 <monochrom> List.group [x, f x, f (f x), ...] you also know what that intends.
19:17:10 <monochrom> etc. etc.
19:18:00 <sorear> ?go DHT
19:18:03 <lambdabot> http://www.d-h-t.be/
19:18:04 <lambdabot> Title: {{ D-H-T Featuring Edmee: Listen to your heart }}
19:18:10 <monochrom> Have you learned unix shell script pipelines, Sgeo?
19:18:26 <Sgeo> I guess
19:18:44 <monochrom> "f . g . h" is like "h | g | f".
19:19:01 <kpreid> > delete 'a' "banana"
19:19:03 <lambdabot>  "bnana"
19:19:27 <kpreid> > L.settle delete 'a' "banana"
19:19:29 <lambdabot>    Occurs check: cannot construct the infinite type: t = [t -> t1]
19:19:29 <lambdabot>    Ex...
19:19:30 <kpreid> > L.settle (delete 'a') "banana"
19:19:33 <lambdabot>  "bnn"
19:19:43 <Philippa> > (fix (delete 'a')) "banana"
19:19:44 <lambdabot>    The function `(fix (delete 'a'))' is applied to one arguments,
19:19:47 <lambdabot>   but i...
19:20:10 <Philippa> oh well
19:20:12 <monochrom> "but i get silenced by the Cabal"
19:20:13 <kpreid> fix has no initial value
19:20:18 <kpreid> nor a termination condition :)
19:20:29 <Philippa> > fix ((delete 'a') "banana")
19:20:30 <lambdabot>    Expecting a function type, but found `[Char]'
19:20:30 <lambdabot>    Expected type: a -> ...
19:20:33 <monochrom> fix is not what you think it is
19:20:41 <Philippa> fix isn't how I'm misusing it, anyway
19:20:47 <Philippa> it's 3am, who says I'm thinking? :-)
19:20:49 <kpreid> well, fix is a vaguely similar concept
19:21:09 <monochrom> fix has an initial value, and a termination condition, but they are not what you think they are.
19:21:09 <Philippa> right. What I'm actually trying to do there is fixpoint iteration...
19:21:15 <Sgeo> Can infinite lists be tested for equality?
19:21:18 <Cale> hmm, given physical constraints, it seems like you can't do any better than O(n^(1/3)) time to access an element of a data structure with n elements, because latency to access an element is proportional to the distance travelled to reach it, and even assuming that your memory is arranged as a ball of maximum possible information density, with the processor as a point in the centre, the amount of information you can st
19:21:18 <Cale> ore at a maximum radius of r will be proportional to r^3
19:21:29 <Philippa> Sgeo: yes, if you have infinite time to check in
19:21:30 <kpreid> Sgeo: only if they are unequal at a finite distance.
19:21:42 <monochrom> Cale: that's a nice conclusion. I like it.
19:21:58 * Sgeo wishes that infinite lists could have more than aleph_null eelements ;;)
19:22:06 <kpreid> > cycle 1 == cycle 2
19:22:08 <lambdabot>  add an instance declaration for (Num [a])
19:22:21 <kpreid> > repeat 1 == repeat 2
19:22:23 <lambdabot>  False
19:22:24 <kpreid> > repeat 1 == repeat 1
19:22:29 <lambdabot> Terminated
19:22:38 <monochrom> You can have nested infinite lists, like cycle (repeat 1) of Cale.  That is more than aleph_null.
19:22:44 <Cale> no, it's not
19:22:50 <Cale> (I was joking :)
19:22:58 <monochrom> ℵ_0
19:23:13 <SamB_XP> so are there more points in a sphere than in a disc?
19:23:21 <newsham> > cycle "Cale."
19:23:22 <lambdabot>  "Cale.Cale.Cale.Cale.Cale.Cale.Cale.Cale.Cale.Cale.Cale.Cale.Cale.Cale.Cale....
19:23:29 <SamB_XP> monochrom: that looks like
19:23:35 <SamB_XP> o_0
19:23:36 <SamB_XP> here
19:23:38 <SamB_XP> ;-)
19:23:45 <Cale> Countable union of countable sets is countable
19:23:50 <SamB_XP> except the thing on the left is rectangular
19:24:02 <Cale> but even so, cycle (repeat 1) = repeat 1
19:24:06 <newsham> ?check \x -> cycle 1 == cycle 2
19:24:09 <lambdabot>  add an instance declaration for (Num [a])
19:24:12 <Sgeo> monochrom, isn't aleph_null the thing that means countable?
19:24:14 * allbery_b observes that he needs to teach xchat2 about a better Hebrew font
19:24:24 <Cale> yeah
19:24:46 <Sgeo> So if there were more than aleph_null, you'd need an uncountable amount of elements somehow..
19:24:47 <Cale> If xs is an infinite list, then xs ++ ys = xs
19:24:49 <newsham> ?check \x -> (cycle 1) == (cycle 2)
19:24:50 <lambdabot>  add an instance declaration for (Num [a])
19:24:56 <newsham> why?
19:25:11 <Cale> newsham: are you asking that to me?
19:25:17 <SamB_XP> allbery_b: just install more fonts ;-)
19:25:23 <newsham> why lambdabot?
19:25:26 <int-e> newsham: you mean repeat?
19:25:30 <Cale> ?check (cycle 1) == (cycle 2)
19:25:32 <SamB_XP> defoma should take care of getting them set up, right?
19:25:32 <lambdabot>  add an instance declaration for (Num [a])
19:25:34 <int-e> ?check (repeat 1) == (repeat 2)
19:25:36 <lambdabot>  Falsifiable, after 0 tests:
19:25:37 <newsham> oh
19:25:41 <int-e> ?check (repeat 1) == (cycle [2])
19:25:43 <lambdabot>  Falsifiable, after 0 tests:
19:25:46 <Cale> oh, yes, that's silly :)
19:26:05 <newsham> ?check \x -> repeat 1 == repeat 1
19:26:06 <lambdabot>  Add a type signature
19:26:18 <Cale> cycle xs = let ys = cycle xs in xs ++ ys
19:26:46 <newsham> ?check \x -> (repeat 1) ++ x == (repeat 1)
19:26:48 <lambdabot>  Add a type signature
19:26:55 <Cale> cycle xs = xs' where xs' = xs ++ xs'
19:26:58 <Cale> right
19:27:04 <Cale> that's the right way to do it :)
19:27:11 <Sgeo> ?check (repeat 1) == (repeat 2)
19:27:12 <lambdabot>  Falsifiable, after 0 tests:
19:27:13 <Sgeo> ?check (repeat 1) == (repeat 1)
19:27:20 <lambdabot> Terminated
19:27:27 <int-e> I wonder if the compiler optimizes cycle xs = let ys = cycle xs in xs ++ ys ... I think it (ghc that is) should.
19:27:52 <Cale> Or  cycle xs = xs ++ cycle xs
19:27:54 <Saizan> foldl1 (++) (repeat (repeat 1)) would be "longer" i suppose :)
19:28:23 <Sgeo> Saizan, still countable
19:28:33 <Cale> cycle xs = let ys = xs ++ ys in ys
19:28:48 <kpreid> @let settleM f x = f x >>= \x' -> if x == x' then return x else settleM f x
19:28:50 <lambdabot> Defined.
19:28:55 <SamB_XP> I think the compiler should keep track of which lists are infinite and which functions don't need to be applied when one of their args is infinite ;-)
19:29:19 <Cale> The problem is that the list structure won't get you to any ordinal beyond ω
19:29:33 * Sgeo wonders if SamB_XP's suggestion would be equivelent to the Halting problem or something
19:29:34 <Cale> and it certainly won't get you anything uncountabl
19:29:36 <Cale> e*
19:29:37 <sorear> let myList = unfoldr initSt turing in some_operation
19:29:48 <SamB_XP> Sgeo: no silly
19:29:54 <SamB_XP> it wouldn't keep track totally
19:30:01 <SamB_XP> just of certain obvious cases
19:30:26 <SamB_XP> (perhaps made obvious by source annotations)
19:30:28 <sorear> non-heuristic code optimization is prob. impossible
19:30:29 <Cale> You can't really construct uncountable datastructures in Haskell.
19:30:56 <SamB_XP> Cale: are they datastructures if they are uncountable?
19:31:05 <sorear> (Rational -> Bool).
19:31:17 <sorear> Dedekind cut construction of the reals
19:31:27 <Cale> In some sense, even types like Natural -> Bool are countable, because you can say that they only consist of computable functions.
19:31:31 <monochrom> Damn!  I forgot aleph_null is not an ordinal.
19:31:38 <sorear> (Sure, it is only *inhabited* by computable reals...)
19:31:46 <dylan> gah, is there no haskell *textual* templating library?
19:31:55 <Cale> dylan: hm?
19:32:06 <monochrom> what is the semantics of that?
19:32:08 <dylan> e.g. something to replace values in a file.
19:32:22 <dylan> a file which is not haskell source code.
19:33:21 <dylan> the simplest such system takes a file with the contents "fooo" and produces a program that consists of main = putStr "fooo"
19:33:45 <monochrom> A program that inputs a string "hello my name is $n" and outputs a string "hello my name is monochrom"?
19:34:04 <newsham> > fail :: IO ()
19:34:05 <dylan> monochrom: basically, but perhaps with some other features.
19:34:06 <lambdabot>    Expecting a function type, but found `IO ()'
19:34:06 <lambdabot>    Expected type: IO ()
19:34:06 <lambdabot> ...
19:34:22 <newsham> > fail "foo" :: IO ()
19:34:24 <dylan> such as conditionals and a looping construct.
19:34:26 <lambdabot>  <IO ()>
19:34:59 <Saizan> php?
19:35:01 <monochrom> In TH you can do arbitrary IO.  Is it satisfactory?
19:35:27 <monochrom> Maybe it is unsatisfactory.
19:35:41 <dylan> the unix program 'subst' would work better than that.
19:36:02 <dylan> err, whatever it's called
19:36:09 <newsham> > fail "foo" :: [] Int
19:36:11 <lambdabot>  []
19:36:18 <dylan> it's in core utils and expands shell-style variables from the environment
19:36:55 * Sgeo wonders if a halts :: (a->b) -> a -> Bool could be written in terms of a isInfinite :: [a]->Bool
19:37:10 <newsham> IO monad propogates failure like the Error monad?
19:37:40 <monochrom> Yes.
19:41:02 <sorear> Sgeo: yes ... halts fn v = do { a <- newChan ; ti <- forkIO (repeatM (putChan a ()) ; forkIO (fn v `seq`  killThread ti) ; return $ not $ isInfinite $ getChanContents a }
19:41:20 <sorear> (Do you consider concurrent haskell cheating?)
19:41:41 <Sgeo> Umm... I was hoping for something in terms of stuff I understand
19:41:56 <dylan> envsubst, that's the command.
19:43:00 <Cale> dylan: you could build a parsec parser for it
19:43:06 <fnord123> @paste
19:43:07 <lambdabot> http://paste.lisp.org/new/haskell
19:43:18 <sorear> creates a pipe ; a thread writes to the pipe forever ; another thread evaluates the function, then kills the writer ; if the contents of the pipe are infinite, the function never halts.  This any better?
19:43:33 <dylan> Cale: yeah, I'm trying to avoid that option. :)
19:43:44 <Cale> It's not a particularly difficult option
19:43:49 <fnord123> Cale, did you happen to see if it was easy to convert XML strings to numbers?
19:44:01 <Cale> fnord123: show :)
19:44:05 <dylan> Cale: I want to write a blosxom-workalike in less code than blosxom itself is.
19:44:16 <fnord123> e.g. I see in your data Wallpaper = WP { title :: String, etc}, I would like some fields to rip as ints
19:44:17 <Cale> fnord123: or if you're in the arrow,  pure show
19:44:33 <Cale> right
19:44:38 <Cale> you can do that just fine
19:44:44 <fnord123> i wouldn't use b <- getValue -< pt ?
19:44:55 <Cale> dylan: let me look that up
19:45:57 <dylan> Cale: much appreciated. :)
19:46:11 <Sgeo> sorear, ty
19:46:23 <dylan> I realize a parsec parser needn't be very big, but still. I'd like this to be a very short program.
19:46:46 <jcreigh> dylan: why? Just proof of concept?
19:47:13 <dylan> jcreigh: No, to make it interesting enough to do.
19:47:27 <dylan> a simple blosxom-like blog is trivial, but difficult to get done as it is trivial.
19:48:06 <dylan> forcing myself to write only 100 to 250 lines is a challene.
19:48:23 <Cale> hmm, where's a better description of exactly what blosxom does?
19:48:34 <Cale> I could read this perl code...
19:49:26 <Cale> It goes through everything in a directory and uses the things it finds to build HTML pages?
19:49:39 <dylan> yes
19:49:42 <dylan> that part is easy
19:50:14 <Cale> what's the hard part?
19:50:21 <dylan> but for producing html, I'd prefer to write html files.
19:50:32 <Cale> I bet I could code something up really quickly using HXT.
19:50:47 <dylan> what's HXT?
19:50:55 <Cale> The Haskell XML Toolbox
19:51:05 <SamB_XP> ick
19:51:11 <SamB_XP> too many exports
19:51:11 <Cale> The documentation for HXT is a little scary, but it's a beautiful library.
19:51:43 <SamB_XP> its an ugly library which could be beautiful if only they would take stuff out and document stuff more!
19:52:01 <dylan> eeew, no XML.
19:52:16 <Cale> well, of course it works with HTML just as well
19:52:39 <SamB_XP> maybe not the parsing part
19:52:50 <dylan> not the replacing-values-in-the-file part.
19:52:58 <fnord123> HXT is great since it doesnt use code generators
19:53:00 <Cale> http://paste.lisp.org/display/32554#2 -- here's a program which scrapes http://interfacelift.com/wallpaper/index.php?sort=random&w=1680&h=1050, and builds an XML document which has the title, description, and URL of each of the images listed.
19:53:21 <Cale> lisppaste2: url
19:53:21 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/Haskell and enter your paste.
19:53:23 <dylan> pretty.
19:53:44 <fnord123> why are you lot using lisppaste2 and not @paste? out of interest
19:53:45 <lisppaste2> Cale pasted "trivial rss" at http://paste.lisp.org/display/32564
19:54:00 <Cale> (that just lists headlines)
19:54:18 <Cale> fnord123: they're the same thing
19:54:20 <dylan> see, I need a haskell textual replacement engine for other things too
19:54:43 <Cale> I would call that Parsec :)
19:54:53 <dylan> I use the perl-based template toolkit for various overly-verbose config files...
19:55:08 <fnord123> perhaps someone should make a html-literate haskell
19:55:09 <SamB_XP> maybe you could use pugs ;-)
19:55:14 <dylan> and I'd rather use something with the power of haskell.
19:55:27 <fnord123> which compiles to html or some mod_haskell server side script
19:55:50 <Cale> What does the thing actually need to do? Just replace variables with... files? computed values?
19:56:11 <fnord123> Cale, it all ends up just catting text
19:56:21 <Sgeo> ?type head . head
19:56:23 <lambdabot> forall a. [[a]] -> a
19:56:28 <Cale> It just has to concatenate text?
19:56:36 <monochrom> I think there is value in writing dylan's library or program once and for all.
19:56:53 <Cale> I still don't understand what dylan's library would do.
19:56:55 <fnord123> Cale, well sure. it ends up as an html docco
19:56:57 <Sgeo> > (head . head) [[5,6],[7,8,9]]
19:56:59 <lambdabot>  5
19:57:14 <Cale> Maybe I'm thick :)
19:57:22 <Sgeo> Yay Dylan!
19:57:24 <Sgeo> erm
19:57:39 <Cale> cale@zaphod:~$ lsd
19:57:39 <Cale> bash: lsd: command not found
19:57:39 <SamB_XP> heh
19:57:40 <Cale> heh
19:57:56 <SamB_XP> dylan is a person, not a language, btw ;-)
19:58:09 <Sgeo> SamB_XP, I know
19:58:18 <Sgeo> erm, dylan is also a language
19:58:22 * Sgeo was cheering the person
19:58:23 <dylan> sgeo is another person that came here because of me.
19:58:28 <fnord123> if you give your server a request it's a url string, essentially. or args to a post or get command. you run them through your args and then probably access a db, then cat some text
19:58:28 <Cale> dylan: so what does the specification for this thing look like?
19:58:29 <dylan> indirectly at least
19:58:30 <SamB_XP> I know that ;-)
19:59:07 <Sgeo> What, I couldn't have become interested in Haskell on my own?
19:59:09 <SamB_XP> but I thought maybe you thought the "dylan's library" there referred to the language, because you then capitalized it ;-)
19:59:11 <Cale> Do you want something which does the same thing as envsubst?
19:59:23 <Cale> That's not hard.
19:59:27 <fnord123> it's convenient, however, to put in the code where text will be catted, into the code itself between some tags. like <?haskell> blah blah blah</haskell>
19:59:48 <dylan> fnord123 is explaining it.
19:59:51 <geckosenator> you want haskell script?
19:59:59 <dylan> Either variable substitution or code evaluation would be good.
20:00:00 <SamB_XP> heh
20:00:18 <dylan> the later is a lot more useful. I could do the former with a foldr I suppose. :)
20:00:23 <SamB_XP> you could maybe do something crazy with hs-plugins and some namespace-supporting XML library ;-)
20:00:34 <dylan> SamB_XP: No XML. :P
20:00:34 <SamB_XP> <haskell:eval></haskell:eval>
20:00:36 * araujo got fmap.us !
20:00:48 <SamB_XP> dylan: XML is just like SGML only with less features
20:00:50 <SamB_XP> honest!
20:00:55 <fnord123> im think he wants literate-html-haskell. and each nugget of haskell code is executed at compile time and inserted into the rest of the document (which isn't thrown away as a comment would be)
20:01:04 <araujo> mm.. now let's see what i'll put there specifically
20:01:04 <SamB_XP> oh, and you can't turn the features it has off
20:01:16 <dons> hey guys, anyone want to have a quick look any my (longish) new tutorial: http://cgi.cse.unsw.edu.au/~dons/blog/2006/12/16#programming-haskell-intro
20:01:18 <lambdabot> Title: Haskell hacking, http://tinyurl.com/yz4kdc
20:01:33 <fnord123> er, not executed at compile time, but compiled at compile time and filled in by the mod_haskell process
20:01:42 <araujo> dons, got a fmap domain after alla :-)
20:01:51 <dons> araujo: cool!
20:01:52 <dylan> I think I'll just implement envsubst now -- except it'll be Map String String -> String -> String.
20:02:29 <araujo> dons, hah, i am still thinking what i should put there
20:02:54 * SamB_XP hopes he didn't spend too much on his christmas gifts
20:02:55 <Cale> I just had a nice idea. Wouldn't it be nice to have an IO primitive of type  FilePath -> IO () -> IO (), which serialised an IO action to disk as a native executable?
20:03:19 <dons> Cale: hmm. interesting.
20:03:21 <Cale> (i.e. you'd get a program for which that IO action was main)
20:03:36 <SamB_XP> that could be possible
20:03:39 <Cale> yeah
20:03:45 <SamB_XP> hmm. is that like undump?
20:04:06 <Cale> basically
20:04:27 <kpreid> forkIO = runProcess . writeIO ?
20:04:31 <kpreid> er, forkOS
20:04:33 <Cale> If you want to do it nicely, you'd stick some garbage collection in the copy of memory before serialising it.
20:04:41 <chessguy> avocados    = 6.02e23
20:04:43 <chessguy> hehe
20:04:50 <Cale> haha
20:05:00 <SamB_XP> kpreid: no silly
20:05:05 <SamB_XP> that would run a different executable
20:05:36 <kpreid> and the difference in behavior is...?
20:05:42 <kpreid> well, close-on-exec fds, I suppose
20:05:42 <chessguy> ?remember dons avocados = 6.02e23
20:05:48 <Cale> because writing everything out to disk when the IO action you're saving is  putStrLn "Hello, World!"  is a bit of a waste.
20:06:40 <SamB_XP> also!
20:06:47 <dons> chessguy: that's a quote from 'Programming Perl' though :)
20:06:57 <SamB_XP> how are you going to use MVars across process boundaries?
20:07:18 <kpreid> Cale: you do realize this is rather like what an image-based system does? (smalltalk, lisp)
20:07:21 <chessguy> ohhh, i do remember that now
20:07:22 <Cale> dons: why is this not on reddit so that I can mod it up?
20:07:34 <Cale> kpreid: Yes, I know :)
20:07:41 <SamB_XP> Cale: because you didn't put it there?
20:07:48 <SamB_XP> you can do that you know!
20:08:22 <Cale> dons: did you want to reddit it?
20:08:27 <dons> Cale, no, you can do it
20:08:44 <dons> i don't really want to be the one man haskell blog army on reddit :)
20:09:34 <dons> might be a good idea to submit to the front reddit.com page though
20:09:40 <dons> (not just the programming subreddit)
20:09:50 <Cale> ah, too late :)
20:09:59 <dons> ah well
20:10:10 <Cale> well, I could also post it there, separately
20:10:21 <fnord123> you can post it and bury it
20:10:25 <fnord123> then no one will see it
20:10:37 <monochrom> the front reddit.com page is full of junk.  don't mix gem into junk.
20:10:42 <fnord123> and if someone comes along to submit it, then it will get to your already downed post
20:10:57 <dons> is that useful, fnord123 ? :)
20:11:10 <dons> ah, thanks Cale, http://programming.reddit.com/info/uzts/details
20:11:10 <fnord123> if you dont want people to discuss and disagree with you, sure
20:11:13 <lambdabot> Title: Programming Haskell Intro (reddit.com)
20:11:14 <dons> hehe
20:11:25 <dons> I think the idea is to have people discuss though :)
20:12:03 <Cale> well, now it will be in two separate places
20:12:13 <dons> ok
20:12:18 <fnord123> i think posting Cale's rss ripper might be more useful. a lot of the people who see the basic tutorials want to do something immediately useful
20:12:30 <fnord123> G'day mate isn't all that useful, i would have thought.
20:12:34 <dons> yeah. that should go up, for sure.
20:12:55 <dons> fnord123: get to the bottom :)
20:13:02 <dons> i'ts a series i'm planning
20:13:07 <shapr> Cale: Actually RFSQ can teleport signals to various parts of the chip, so the minimum complexity is much lower.
20:13:13 <dons> i.e. maybe we'll toss some threads in tomorrow
20:13:17 <geckosenator> teleport?
20:13:20 <fnord123> yeah the class grade problem. its really useful
20:13:34 <dons> fnord123: hehe ok. go talk to Larry about that then ;)
20:13:54 <Cale> shapr: RFSQ?
20:14:04 <fnord123> you racistly put the non WASP names as having bad grades
20:14:14 <dons> oh I did?
20:14:20 <fnord123> im kidding
20:14:21 <shapr> rapid single flux quantum, sorry, RSFQ
20:14:27 <shapr> Cale: josephson junctions
20:14:30 <dons> > randomRs (60,100) (mkStdGen 42)
20:14:31 <sorear> SamB: I think I've figured out the problem
20:14:32 <lambdabot>  [70,61,79,69,80,94,77,73,87,62,83,94,95,88,91,67,100,79,70,86,79,87,60,66,64...
20:14:35 <dons> fnord123: ^^ ;)
20:14:42 <shapr> There is the minor drawback that josephson junctions require superconducting materials, but hey...
20:14:47 <fnord123> poor churchy failed functional programmign
20:15:00 <SamB> sorear: oh?
20:15:08 <Cale> shapr: this lets you send signals at faster than the speed of light?
20:15:18 <shapr> Oh, probably not.
20:15:41 <shapr> But you may be able to send signals at multiples of the speed of light anyway.
20:15:42 <sorear> SamB: gSerial and serGenreral are mutually recursive, but gSerial needs any old monad while serGeneral need a MonadWStream
20:16:06 <SamB> oh huh
20:16:08 <sorear> All members of a dependency group must have the same class context
20:16:18 <SamB> yeah, I know
20:16:29 <SamB> but I would have expected this to show up in *that* module
20:16:36 <sorear> But, GHC 6.6 is smart enough to break dependency groups at type signatures
20:16:54 <sorear> you notice the paranoidly added type sigs in genericserialize?
20:17:02 <SamB> wait, huh?
20:17:03 <monochrom> josephson!  fearsome...
20:17:03 <Cale> shapr: so long as we make the assumption that there's a maximum speed at which information may travel, I think my bound is right :)
20:17:04 <sorear> I didn't realize the problem then.
20:17:19 <shapr> Cale: Yeah, good point.
20:17:22 <Cale> Oh, and that space is 3-dimensional, that's important.
20:17:29 <sorear> *Latency* bound.  Bandwidth is limited by chip surface area.
20:17:38 <shapr> Could you beat it with distributed processing?
20:17:44 <SamB> mutually recursive but in different modules huh?
20:17:47 <SamB> thats a good trick
20:18:08 <shapr> For example, have the data be operated on by a nearby processor and then send smaller intermediate results around?
20:18:24 <sorear> Don't forget about the Shwartzchild and Bekenstein bounds (i.e. your computer will turn into a black hole if you try and store too much information)
20:18:35 <Cale> sorear: you mean volume?
20:18:50 <dons> heh, coffeemug wrote a new article, http://www.defmacro.org/ramblings/haskell-productivity.html
20:18:53 <lambdabot> Title: defmacro - On Haskell, Intuition And Expressive Power
20:18:55 <Cale> My "chip" is a solid ball of information
20:18:57 <SamB> sorear: so, are you fixing it?
20:19:01 <SamB> or do you want me to?
20:19:32 <sorear> The bekenstein bound says the maximum amount of information in a region is determined by the region's sufface area.
20:19:56 <sorear> SamB: Only if you've already figured out how to.
20:19:58 <monochrom> Holographic wheeeee....
20:20:10 <shapr> Cale: This encourages my fantasy of atomic/molecular FPGAs where each unit is a processing element as much as it is information storage. I'm thinking something like lambda calculus in hardware.
20:20:31 <SamB> sorear: well my guess would be to say MonadWStream in Standard.hs
20:20:35 <shapr> Those will be fun to program.
20:20:44 <Cale> sorear: oh, that's interesting
20:20:57 <Cale> sorear: under what conditions?
20:21:09 <Cale> How do you measure the surface area?
20:21:18 * monochrom giggles at the thought that a molecular STG machine "going into a blackhole" now has a new meaning!
20:21:20 <fnord123> Cale, I'm hijacking your syntax for "urls". urls = proc x -> do ... doesn't parse when I try to use it in my own program. the only real difference is that I'm not using "x" as a far name...
20:21:28 <fnord123> s/far/var/
20:21:32 <Cale> fnord123: -farrows
20:21:43 <Cale> You need to turn on arrow syntax
20:22:01 <fnord123> Hadouken! thanks
20:22:12 <sorear> Cale: I dunno; this is parsed and indexed WP facts, I don't understand the theory :(
20:22:18 <shapr> Is hadouken like eureka?
20:22:30 <SamB> sorear: is that too onerous a restriction for you or not?
20:22:34 <fnord123> it's like Shoryuken but it shoots fireballs
20:22:58 <Cale> heh, I used to play SF2 as well.
20:23:11 <SamB> I got it to compile at least
20:23:14 <fnord123> "used to"?
20:23:22 <sorear> SamB: *whack* I'm prob. still wrong, dynamic mutual recursion shouldn't have any effect on type checking, the problem is prob. in SExp.hs
20:23:26 <jcreigh> hmm, the Maybe monad doesn't really do backtrack, does it.
20:23:34 <jcreigh> *backtracking
20:23:38 <sorear> *whack* of my head, to clarify
20:24:19 <SamB> sorear: nope, you aren't wrong, apparantly
20:24:46 <sorear> how'd you get it to compile?
20:24:54 <SamB> as I said, it builds now!
20:25:20 * SamB sends patch bundle
20:25:21 <dons> whoa, coffeemug rocks: "Go ahead, give it a try. The first guy to write a complete Java method that does this in five lines or less of reasonably normal looking Java code3 gets a free (as in beer) book of his choice:"
20:25:33 <dons> including SICP!
20:25:37 <dons> http://www.defmacro.org/ramblings/haskell-productivity.html
20:25:38 <lambdabot> Title: defmacro - On Haskell, Intuition And Expressive Power
20:25:59 <shapr> Free Beer Books!
20:26:18 <SamB> as opposed to making him pay for a free-documentation book?
20:26:39 <shapr> bwaha, I love this post
20:27:06 <Korollary> I wonder whether coffeemug knows of scrap-your-boilerplate papers
20:27:11 <shapr> I really do sit in one place and stare out the window thinking about how to match the types to my understanding.
20:27:33 <jcreigh> what's with Haskell propaganada coming from a domain named defmacro.org? :)
20:27:43 <sieni> jcreigh: :-D
20:27:46 <Korollary> former lisper
20:27:50 <shapr> alexj and I spent several hours today trying to figure out some of musasabi's code.
20:28:04 <shapr> musasabi writes powerful stuff, and I know how to use it, but trying to modify it can be quite scary.
20:28:13 <SamB> sorear: apparantly that somehow gets into the same boat as mutual-recursion-by-name?
20:28:26 <sorear> SamB++ : thank you, your help is appreciated.
20:28:39 <SamB> sorear: as is yours ;-)
20:29:22 <shapr> We were trying to figure out how to modify this towards some other purpose: newtype Ev state event t = Ev { unEv :: Env state event -> STM t } ; type EvPar res st = ReaderT (Ev st Request res -> Request -> IO Result) IO
20:29:50 <shapr> And of course, our code was several layers above those concrete types...
20:31:27 <SamB> sorear: btw, have you seen the Writer monad?
20:32:07 <SamB> your ListBuild monad reminds me of it
20:35:14 <sorear> yes; the original version used the writer monad; however using MonadWriter for the write-streams precludes efficiently using the IO monad, since you can't censor etc. IO
20:36:18 <SamB> well, actually, I wouldn't suggest using Writer cross-GHC, now that I think of it.
20:36:31 <sorear> Or were you refering to the concrete monad (which happens to be named ListBuild :) ?
20:36:49 <SamB> they just broke compatibility for endomorphisms in Data.Monoid :-(
20:36:55 <SamB> they used to just be (a -> a).
20:37:00 <SamB> now they are Endo a
20:37:59 <SamB> but if you used the Data.DList module I guess that would be beside the point
20:38:19 <SamB> however I don't know if dons has released 0.2 yet
20:38:43 <SamB> anyway, yes I'm talking about the concrete monad
20:39:21 <SamB> btw, what do you use for IO?
20:39:43 <SamB> ReaderT Handle IO?
20:44:54 <sorear> Nothing ATM - I released as soon as I had one of everything.  If my (or someone else's) interest is sustained there will be XML, Streams, Binary-compatible, AltBinary-compatible, YAML, etc.
20:50:09 <SamB_XP> hopefully that restriction in that patch I sent you won't be a problem
20:50:28 <SamB_XP> if it is, I think you could just offer a restricted version of the function with another name
20:50:59 <sorear> Not a problem at all.  I can't think of a use that requires the general type.
20:51:23 <sorear> I simply find artificially restricted types 'unclean'...
20:51:47 <Cale> Well, in a library, they're bad
20:51:54 <Cale> In an application, they're usually good.
20:52:14 <SamB_XP> well, this is an internal portion of a library
20:52:15 <SamB_XP> I think
20:52:30 <SamB_XP> at least, it says it shouldn't need to be imported by user code
20:54:05 <sorear> This is convieniece functions to be used when defining your own syntax modules.
20:54:20 <sorear> If you are using a standard module, you shouldn't need it.
20:54:24 <Cale> Do people really think I should reddit that trivial RSS reader? Perhaps I should do something more with it, like implement more of the RSS standard :)
20:54:50 <SamB_XP> *which* RSS standard?
20:54:52 <dons> well, you can hold off a day or two :)
20:54:52 <SamB_XP> Atom?
20:55:05 <dons> and really polish it up?
20:55:37 <Cale> RSS 2 ?
20:56:08 <SamB_XP> shoulda used RSS 3!
20:56:25 <SamB_XP> I think that stands for Really Silly Syndication
20:57:00 <SamB_XP> or maybe RFC-xxxx Style Syndication, where xxxx is the number for the email-header RFC
20:57:28 <sorear> 822
20:57:35 <SamB_XP> or maybe it just stands for Really Simple Syndication
20:57:50 <SamB_XP> take your pick ;-)
20:58:04 <SamB_XP> (I don't think anyone uses it though, which seems a shame to me)
21:01:19 <sorear> dons : (very pre-release) darcs get http://members.cox.net/stefanor/vty   don't bother with the stub cabal, the build command is ghc -threaded --make Test.hs gwinsz.c
21:04:29 <lisppaste2> jcreigh pasted "attempt at a simple regex engine" at http://paste.lisp.org/display/32568
21:05:20 <jcreigh> okay, so  [("", "aabbcc")] >>= ordered [star dot, one 'c'] returns [("aabbcc",""),("aabbc","c")] (as expected.)
21:05:52 <jcreigh> but Just ("", "aabbcc") >>= ordered [star dot, one 'c'] returns Nothing
21:06:15 <jcreigh> I think this is because "star dot" consumes the whole string, and then one 'c' returns mzero because it doesn't match.
21:06:41 <jcreigh> Is there any way to structure this so it backtracks, or is that what the list monad is for?
21:06:55 <jcreigh> ("backtracks with the Maybe monad", that is.)
21:08:49 <fnord123> haha my recommended page on prog.reddit.com has both the haskell posts just discussed in here
21:09:00 <fnord123> the 3rd and 4th are also haskell
21:09:36 <sorear> The list monad is for easy backtracking.
21:13:11 <sieni> 7
21:14:59 <jcreigh> "easy backtrack"?
21:15:03 <jcreigh> *ing
21:15:53 <jcreigh> so the answer is "the Maybe monad is not really for backtracking"?
21:16:06 <sorear> correct.
21:16:45 <jcreigh> okay, thank you
21:17:16 <jcreigh> I won't try to use it as such then.
21:20:52 <geckosenator> is there a way to single-step haskell?
21:21:08 <SamB_XP> sorear: how is the list monad better than the maybe monad?
21:21:12 <SamB_XP> for that?
21:22:17 <Cale> geckosenator: I usually do that by hand, there are some tools like hat and buddha which do things like that, I think.
21:22:31 <monochrom> mplus of Maybe seems assymmetric.
21:22:40 <Cale> monochrom: yes, it is
21:22:41 <sorear> List stores multiple possibilities.
21:22:48 <geckosenator> Cale: ok thanks
21:23:01 <Cale> monochrom: We really need a MonadElse
21:23:05 <monochrom> whereas mplus of [] is symmetry, at least denotationally.
21:27:47 <dons> ?users
21:27:48 <lambdabot> Maximum users seen in #haskell: 291, currently: 235 (80.8%), active: 29 (12.3%)
21:30:17 <sorear> dons : (very pre-release) darcs get http://members.cox.net/stefanor/vty   don't bother with the stub cabal, the build command is ghc -threaded --make Test.hs gwinsz.c
21:34:09 <dons> right. thanks.
21:38:26 <geckosenator> does an if have to have an else even if it's in a do?
21:41:23 <Lemmih> geckosenator: Yes.
21:41:29 <Lemmih> @type when
21:41:31 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
21:41:45 <geckosenator> that sucks :(
21:42:30 <jcreigh> geckosenator: why? what would the result of "if False then foo" be?
21:43:15 <geckosenator> it wouldn't have a result
21:43:16 <geckosenator> it's in a do
21:43:23 <geckosenator> so the next statment just executes
21:43:28 <Excedrin> geckosenator: use when
21:44:02 <geckosenator> hmm
21:44:03 <geckosenator> ok
21:47:45 <jcreigh> oh, you mean like "do foobar; if cond then whatever; baz" if cond was false, then it would be as if you'd said "foobar >> baz"
21:51:58 <sorear> use when
21:52:38 <sorear> because when is a higher order function, you can do neat tricks like  readTVar wait >>= flip unless retry
21:55:40 <sorear> SamB : I've just uploaded a new batch of changes to the genericserialize darcs; tag 'rel-0-0-1' contains the fixes (I've probably rebroken 6.4 compatibility at the all-patches)
21:58:19 <Excedrin> what is [4,3..1] sugar for?
21:59:00 <jcreigh> Excedrin: [4,3,2,1], I think
21:59:04 <jcreigh> > [9,8..1]
21:59:06 <lambdabot>  [9,8,7,6,5,4,3,2,1]
21:59:23 <jcreigh> > [9,7..1]
21:59:25 <lambdabot>  [9,7,5,3,1]
21:59:46 <Pastorn> > [1,2,3,5,7,11,13..]
21:59:47 <lambdabot>  Parse error
21:59:53 <Excedrin> sorry, I mean, there's some "range" function
21:59:58 <Excedrin> ah, enumFromTo
21:59:59 <Pastorn> aw... it's just primes...
22:00:00 <sorear> [1,12,..300]
22:00:39 <Excedrin> except enumFromTo 4 1 isn't the same as [4,3..1]
22:01:06 <dons> > [1,3..300]
22:01:08 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
22:02:00 <jcreigh> > enumFromThenTo 4 3 1
22:02:02 <lambdabot>  [4,3,2,1]
22:02:16 <jcreigh> Haskell report FTW: http://www.haskell.org/onlinereport/basic.html
22:02:17 <lambdabot> Title: The Haskell 98 Report: Predefined Types and Classes
22:02:18 <Excedrin> ah, thanks
22:03:11 <dons> ?where h98
22:03:11 <lambdabot> http://haskell.org/onlinereport/
22:04:49 <jcreigh> > [9,8..20]
22:04:50 <lambdabot>  []
22:06:08 <Excedrin> > enumFromTo LT GT
22:06:10 <lambdabot>  [LT,EQ,GT]
22:06:30 <jcreigh> > LT < GT
22:06:32 <lambdabot>  True
22:06:34 <jcreigh> heh
22:06:37 <Excedrin> > [False..True]
22:06:37 <lambdabot>  Parse error
22:07:05 <mr_tenor> hmm
22:07:14 <jcreigh> > enumFrom False
22:07:16 <lambdabot>  [False,True]
22:07:28 <jcreigh> > [False..]
22:07:28 <lambdabot>  Parse error
22:07:38 <jcreigh> Why doesn't that work?
22:07:58 <jcreigh> > let f = False in [f..]
22:08:00 <lambdabot>  [False,True]
22:08:35 <monochrom> [ False .. ]  will work.
22:08:59 <sorear> [False..] lexes as [x] where x is (.) in module False
22:09:13 <monochrom> Yeah.
22:09:30 <sorear> Haskell's period rules are ... funny
22:09:33 <monochrom> The False Module!  The False Prophet!  The False God!  :)
22:10:16 <Excedrin> weird
22:10:48 <jcreigh> sorear++ I wouldn't have figured that out on my own.
22:11:47 <Excedrin> > [() ..]
22:11:49 <lambdabot>  [()]
22:12:45 <sorear> > [ 'z'.. ]
22:12:46 <lambdabot>  "z{|}~\DEL\128\129\130\131\132\133\134\135\136\137\138\139\140\141\142\143\1...
22:13:47 <mr_tenor> signifigant whitespace and signifigant lac-of-whitespace... fun
22:14:07 <Excedrin> > [1.2..9.03]
22:14:08 <lambdabot>  [1.2,2.2,3.2,4.2,5.2,6.2,7.2,8.2,9.2]
22:18:59 <dmead> ['!'..]
22:19:03 <dmead> > ['!'..]
22:19:05 <lambdabot>  "!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghi...
22:19:08 <dmead> =P
22:20:42 <Excedrin> > ([1..1.5], [1..1.49999999])
22:20:44 <lambdabot>  ([1.0,2.0],[1.0])
22:20:57 <jcreigh> gah!
22:21:18 <jcreigh> I don't know why that happens, but I don't like it.
22:21:21 <Excedrin> that's weird, I don't understand what the rules are for Float's Enum instance
22:22:08 <dons> The @Enum@ instances for Floats and Doubles are slightly unusual.
22:22:22 <dons> The @toEnum@ function truncates numbers to Int.  The definitions
22:22:22 <dons> of @enumFrom@ and @enumFromThen@ allow floats to be used in arithmetic
22:22:22 <dons> series: [0,0.1 .. 1.0].  However, roundoff errors make these somewhat
22:22:22 <dons> dubious.
22:22:48 <Excedrin> > succ 1.0
22:22:49 <lambdabot>  2.0
22:23:02 <dons>     toEnum         = int2Float
22:23:03 <dons>     fromEnum       = fromInteger . truncate   -- may overflow
22:23:11 <Excedrin> ok, makes sense now
22:23:26 <jcreigh> In short, only fools trust their lives to floating point arithmetic.
22:24:08 <dons> > 1.1 + 2.2
22:24:10 <lambdabot>  3.3000000000000003
22:24:32 <emu> > 1.1 + 2.2 > 3.3
22:24:33 <lambdabot>  True
22:25:17 <dons> > [ 1%2 .. 10%2 ]
22:25:19 <lambdabot>  [1%2,3%2,5%2,7%2,9%2,11%2]
22:25:41 <Cale> http://cale.yi.org/autoshare/Screenshot-3.png
22:25:50 <monochrom> I trust my life to floating point arithmetic, but I am not a fool.  I am a well-educated computer scientist.
22:25:54 <Cale> How's that for RSS? :)
22:26:05 <sorear> ?go what every computer scientist should know about floating
22:26:07 <lambdabot> http://docs.sun.com/source/806-3568/ncg_goldberg.html
22:26:07 <lambdabot> Title: What Every Computer Scientist Should Know About Floating-Point Arithmetic
22:26:33 <monochrom> Yeah, for example I read that article.
22:28:11 <dons> Cale, is that news.html produced by your rss grabber?
22:28:51 <Cale> dons: yep
22:29:02 <Cale> 61 lines of code
22:29:05 <Cale> the whole thing
22:29:23 <Cale> (and that includes lines which are blank)
22:29:33 <dons> Cale, that is really really nice
22:29:38 <sorear> (yi.org --> is that yi?  (sorta looks like vim))
22:29:39 <Excedrin> what editor is that, and what do the ||- things mean?
22:29:48 <dons> can you make it multithreaded :)
22:29:51 <sorear> vim : folds...
22:29:56 <Cale> hehe
22:30:05 <Cale> First I think I'll make it aggregate.
22:30:13 <dons> (hpodder just went multithreaded on downloades, iirc)
22:30:17 <dons> so it might be quite easy to do
22:30:22 <Cale> Currently all it does is read a single rss feed and make an HTML page out of it.
22:30:26 <Excedrin> what do you set to get folds like that?
22:30:28 <dons> ok. nice
22:31:49 <Cale> Excedrin: that is vim
22:31:53 <Cale> oh
22:32:05 <Cale>   set foldmethod=indent
22:32:05 <Cale>   set foldcolumn=4
22:32:05 <Cale>   set foldlevel=100
22:33:25 <Cale> hmmm...
22:34:06 <Cale> aha, beautiful, I think catA will do it
22:55:29 <t> hye
22:55:29 <Excedrin> I have a somewhat ugly file format that I'd like to parse with parsec. It has lines like "-1.0 foo\n" "1 foo\n" "1\n" "-1.0\n" they should parse to String, String, Int, Float
22:55:53 <t> trying to come up with an algo for determining if a digit is divisible (without remainders) by multiple digits
22:56:01 <t> anyone know what functions i should be looking at to do that?
22:56:12 <Excedrin> but, the natural and float from ...Parsec.Token are defined in terms of lexeme, which eats the space or newline, so "-1.0 foo\n" eats the space and leaves the parser at "foo\n"
22:56:59 <Cale> okay, 63 lines, and it's an aggregator
22:57:10 <Excedrin> if I use do { float; newline } it always fails to match the newline
22:58:39 <jcreigh> t: "multiple digits"?
22:58:42 <Cale> Excedrin: hmm... it's may be easier to just parse the number as a string and then read it.
22:58:47 <Cale> it*
22:58:58 <Excedrin> ok, I'll do that, thanks
23:00:36 <t> jcreigh: like, say, 60 is divisible by 2, 3, 4, 5, and 6
23:01:06 <monochrom> Does 60 `mod` 2 == 0  work?
23:02:48 <sorear> > (flip filter [0..9] . ((==) 0 .) . mod) 60
23:02:50 <lambdabot>  Exception: divide by zero
23:02:54 <sorear> > (flip filter [1..9] . ((==) 0 .) . mod) 60
23:02:56 <lambdabot>  [1,2,3,4,5,6]
23:03:03 <sorear> > (flip filter [1..9] . ((==) 0 .) . mod) 59
23:03:04 <lambdabot>  [1]
23:03:09 <sorear> > (flip filter [1..9] . ((==) 0 .) . mod) 58
23:03:11 <lambdabot>  [1,2]
23:03:13 <glguy> ?seen dons
23:03:14 <lambdabot> dons is in #ghc, #haskell.hac07, #haskell-overflow and #haskell. I last heard dons speak 32m 46s ago.
23:03:15 <t> that is brilliant
23:03:30 <Korollary> You want to find the smallest common multiple of those numbers
23:03:32 <Cale> which syntax highlighting plugin for mediawiki do people recommend?
23:03:38 <Cale> (for Haskell, of course)
23:09:53 <cerculetz> hi, is there a common reason why ghc errors with a message such as "Bad interface file: glib/System/Glib/GType.hi -- magic number mismatch: old/corrupt interface file?" ?
23:10:07 <cerculetz> (I'm obviously trying to build gtk2hs from source on win32)
23:10:37 <cerculetz> using ghc 6.4.2 and latest gtk2hs release
23:10:40 <monochrom> if you change ghc version, old .hi files are no good
23:11:07 <cerculetz> I thought those are generated by the build process ?
23:11:38 <sorear> In cabal, how do I make it such that all programs are linked with the threaded RTS ?
23:11:38 <monochrom> So, this is the first time you build gtk2hs?
23:11:45 <cerculetz> yes
23:12:25 <Excedrin> did you recently build a new GHC?
23:12:25 <Excedrin> I think that's caused by having .hi files from an old GHC version
23:13:00 <cerculetz> no, using the MSI package from haskell.org
23:13:22 <monochrom> I am suspecting you need ghc 6.6
23:13:42 <cerculetz> latest released gtk2hs doesn't have support for 6.6
23:13:49 <cerculetz> that's why I'm stuck with 6.4
23:14:33 <geckosenator> > signum 0/0
23:14:34 <lambdabot>  NaN
23:14:39 <cerculetz> (and the darcs version ... I couldn't get the mingw automake to generate a usable configure script)
23:14:41 <geckosenator> > signum (0/0)
23:14:43 <lambdabot>  -1.0
23:14:46 <geckosenator> wtf
23:15:16 <monochrom> gtk2hs 0.9.10, you downloaded the tarball and tried to build?
23:15:26 <cerculetz> monochrom: yes
23:15:36 <Excedrin> can you delete that .hi file and retry building it?
23:15:59 <cerculetz> sure. I looked in the tarball and there are no .hi files in there
23:16:15 <cerculetz> I'll try rebuilding, thanks for the help
23:16:22 <Excedrin> geckosenator: (signum 0)/0 vs signum (0/0)
23:16:47 <geckosenator> Excedrin: why is it -1?
23:17:10 <sorear> ?seen dons
23:17:10 <lambdabot> dons is in #ghc, #haskell.hac07, #haskell-overflow and #haskell. I last heard dons speak 46m 42s ago.
23:17:12 <Excedrin> apparently it's negative NaN
23:17:23 <sorear> ?seen shapr
23:17:23 <lambdabot> shapr is in #haskell, #scannedinavian and #haskell-blah. I last heard shapr speak 2h 47m 36s ago.
23:17:40 <geckosenator> Excedrin: I don't think so
23:17:50 <sorear> ?seen cale
23:17:51 <lambdabot> cale is in #oasis, #ghc and #haskell. I last heard cale speak 14m 13s ago.
23:17:57 <sorear> ?seen xerox
23:17:58 <lambdabot> Last time I saw xerox was when I left #darcs, #gentoo-haskell, #gentoo-uy, #ghc, #haskell, #haskell-blah, #haskell-overflow, #haskell.hac07, #jtiger, #oasis, #perl6, #scannedinavian and #unicycling
23:17:58 <lambdabot> 3d 6h 41m 51s ago, and .
23:18:08 <sorear> ?seen lispy
23:18:09 <lambdabot> lispy is in #oasis, #darcs, #ghc, #haskell-blah and #haskell. I last heard lispy speak 8h 22m 39s ago.
23:18:14 <monochrom> 0/0 is strange anyway
23:18:16 <sorear> ?seen vincenz
23:18:16 <lambdabot> I saw vincenz leaving #oasis and #haskell 5h 28m 34s ago, and .
23:19:05 <Cale> http://cale.yi.org/index.php/HRSS
23:19:07 <lambdabot> Title: HRSS - CaleWiki
23:19:13 <Cale> I should probably Cabalise it.
23:19:21 <monochrom> But I am surprised that signum NaN is not NaN again.
23:21:27 <Excedrin> it's because signum is defined as x > 0 = 1, 0 = 0, _ = -1
23:22:20 <geckosenator> oh
23:22:24 <geckosenator> isn't that wrong?
23:22:57 <geckosenator> it should be x > 0 = 1, 0 = 0, x < 0 = -1
23:23:17 <monochrom> and NaN otherwise
23:23:30 <geckosenator> or jsut don't match nan
23:23:41 <geckosenator> throw an error
23:25:00 <Cale> http://cale.yi.org/hrss/news.html -- example output :)
23:26:35 <lambdabot> Title: HRSS Aggregate
23:29:00 <sorear> I've described genericserialize on the wiki
23:29:08 <sorear> (very briefly)
23:31:02 <Cale> what do people think, is that redditable?
23:33:13 <Excedrin> Cale: nice, the first thing I tried is parsing reddit's rss and it came back with a "Cookie parse failure"
23:33:41 <Cale> oh, right, perhaps I ought to use the curl engine instead
23:33:42 <dons> Cale, the presented text should be marked up though
23:33:46 <dons> HsColour -css  :)
23:33:51 <Excedrin> s/,/, but/
23:34:17 <Cale> dons: that's why I was asking earlier what people recommend in terms of haskell syntax highlighting plugins for mediawiki
23:35:20 <Excedrin> I prefer "]]]]]" to "]\n]\n]\n", which is more usual haskell style?
23:36:50 <dons> Cale, also, it might be worth cabalising and announcing on the usual haskell lists...
23:38:26 <Cale> yeah
23:38:44 <reilly> has anybody been able to get at any of the papers on research.microsoft.com lately?
23:38:48 <Cale> You wouldn't happen to know what the Haskell wiki is using in terms of syntax highlighting?
23:40:47 <shapr> sorear: You called?
23:41:17 <shapr> sorear: xerox is now known as edi
23:41:42 <cerculetz> Excedrin, monochrom: thanks for the suggestion, seems for some reason the rebuild worked :D
23:41:44 <shapr> reilly: which papers do you want?
23:42:08 <monochrom> nice
23:43:16 <reilly> the august version of "Composable Memory Transactions", "Lock -Free Data Structures using STMs in Haskell", and "Transactional memory with data invariants"  --- All the transactional memory papers.
23:43:22 <reilly> august 06
23:44:13 <monochrom> I haven't tried lately.
23:44:50 <reilly> shapr: was disconnected - back
23:45:01 <Korollary> reilly: I can't seem to be able to get them
23:45:10 <shapr> which papers?
23:45:29 <Korollary> any. research.micrsoft.com seems to have problems
23:45:34 <Syrin> Where's that place to paste code?
23:45:41 <Korollary> We've had power outages in Seattle. Maybe their servers are down.
23:46:01 <Korollary> lisppaste2: url
23:46:02 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/Haskell and enter your paste.
23:46:06 <reilly> shapr:  the 3 transaction memory papers.  The august06 edit of "Composable Memory Transactions",   "Lock -Free Data Structures using STMs in Haskell", and "Transactional memory with data invariants"
23:46:07 <Syrin> I gots me another problem with my code, and I'd like somebody more experienced at this Haskell stuff to look over it
23:46:09 <Syrin> Thanks
23:47:22 <bd_> ?where paste
23:47:22 <lambdabot> http://paste.lisp.org/new/haskell
23:47:24 <lisppaste2> Syrin pasted "code" at http://paste.lisp.org/display/32573
23:47:30 <bd_> ah, I see you found it :)
23:47:40 <Syrin> Yes
23:47:46 <Syrin> Now, an explanation of what the code does:
23:48:14 <Syrin> There's a puzzle wherein there are 5 'cyphers', and each cypher cannot go below -4 nor above 4
23:48:28 <Syrin> And you are given 20 different 'techniques' with which to solve them, applied in whichever order you want
23:48:59 <Syrin> So what it does is returns a comma-separated string of the 'path' to follow in order to get to [0,0,0,0,0], which is a completed puzzle
23:49:31 <bd_> So, you sum up a set of these 'paths' plus an initial value, and try to get zero... am I understanding it correctly?
23:49:35 <Cale> createarray l i = replicate i l
23:49:51 <Syrin> It works perfectly fine, and rather fast; however, it keeps turning up "false" whenever I try to solve [-1,-4,1,3,2] as an initial set
23:49:56 <Syrin> Yes, exactly
23:49:57 <bd_> and cyphcheck = all (\n -> abs n > 4)
23:50:12 <bd_> er
23:50:14 <bd_> cyphcheck = all (\n -> abs n <= 4)
23:50:19 <Excedrin> adding a_use_curl makes it possible to aggregate reddit with hrss... neat
23:50:25 <Syrin> Okay, that all still works, your guys' version just makes it smaller but more complicated :(
23:50:32 <bd_> XD
23:50:41 <Syrin> but, why is it
23:50:42 <bd_> let me figure out the real part of the code :p
23:51:04 <Syrin> that when I run chkpath [-1,-4,1,3,2] n for any n (even up to a milion), it returns false?
23:51:13 <Cale> hmm
23:51:29 <Syrin> It must have something to do with the different techniques...
23:51:33 <Syrin> however, -1,-4,1,3,2 IS solvable
23:51:55 <Syrin> If you add t !! 12
23:52:01 <Syrin> And then solve that, it returns a correct path
23:52:20 <Syrin> But the code can never seem to figure that out, even though it should
23:52:32 <Cale> oh, I see what it's doing
23:52:33 <bd_> Syrin: To clarify the original problem; can you apply any of these techniques only once, or as many times as you want?
23:52:41 <Syrin> As many times as you want
23:53:30 <Syrin> The first way of solving it jumped out at me, screaming 'matrix', but I abandoned it because it would involve making sure that each and every value in the solution was a non-negative integer
23:53:49 <Syrin> And I had no hope in hell of ever doing that my first time programming Haskell :S
23:55:27 <Korollary> I wonder how Cabal compares to this: http://godi.ocaml-programming.de/
23:55:29 <bd_> is it me or shouldn't this require an unreasonably long running time? O(20!) or thereabouts...
23:55:34 <Syrin> Nope.
23:55:37 <Syrin> It takes like 3 seconds.
23:55:37 <Syrin> :)
23:55:44 <bd_> then I must be reading it wrong... 2:50am here XD
23:55:47 <Syrin> And each solution is absolutely correct
23:55:50 <Syrin> Oh, no
23:55:56 <Syrin> I expected it to be like O(20!) too
23:56:00 <bd_> well
23:56:07 <Syrin> It turned out much faster, and I know why now
23:56:14 <Syrin> But I didn't when I was programming it
23:56:30 <sorear> > 9^5
23:56:32 <lambdabot>  59049
23:57:02 <bd_> so let's see... x is the intermediate problem matrix
23:57:07 <Syrin> That's the number of different possible 'cypher' combinations, yea
23:57:14 <sjanssen> > logBase 2 $ product [1..20]
23:57:15 <lambdabot>  61.07738392090622
23:57:26 <sjanssen> bd_: 20! is pretty big
23:57:32 <bd_> y is the result of, um, trying another solution?hmm
23:57:39 <Syrin> Yes
23:57:41 <bd_> Syrin: What does the first arg of checkpath represent?
23:57:45 <Cale> Syrin: what's the solution?
23:57:51 <Syrin> Hold on, I have to look
23:57:56 <Syrin> oh
23:58:00 <Syrin> that's the path
23:58:04 <Syrin> I think... yes
23:58:07 <sorear> there are only 59049 nodes in your statespace; you could do a breadthfirst search, O *at most* 59049*20
23:58:08 <bd_> ah
23:58:15 <Cale> I mean, what's the solution to the one which isn't working
23:58:21 <Syrin> Oh
23:58:25 <Syrin> Well
23:58:31 <Syrin> uh
23:58:39 <sorear> 59049 / 32
23:58:40 <Syrin> Hold on, let me run it once I add t!!12 ;P
23:58:46 <sorear> > 59049 / 32
23:58:47 <lambdabot>  1845.28125
23:58:49 <bd_> Syrin: but y is trying a /different/ element for the step; it shouldn't get the intermediate problem matrix
23:58:52 <bd_> that is
23:59:01 <bd_> y = checkpath ((p-1):ps) x i l
23:59:01 <bd_> right?
23:59:06 <bd_> er
23:59:09 <bd_> y = checkpath ((p-1):ps) c i l
23:59:19 <Syrin> That is not a different element
23:59:24 <Syrin> That's the same element, however
23:59:29 <Syrin> that element in p is decreased by 1
23:59:33 <Syrin> so if it was 9, it decreases to 8
23:59:42 <Syrin> When it's passed to the checkpath
23:59:43 <bd_> right, so it should use the original problem definition, right?
23:59:49 <bd_> unless I'm misunderstanding things horribly
23:59:55 <Syrin> What's the original problem definition? :S
