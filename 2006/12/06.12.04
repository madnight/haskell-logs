00:00:10 <dons> mbishop: you posted the 'what features ...' ask reddit?
00:00:22 <_lygaret> night all - thanks again
00:01:03 <mbishop> dons: oh, yeah, forgot about that, did it get any replies?
00:01:10 <dons> I think so. want to know my list of desired features?
00:01:36 <mbishop> dons: I kept hearing people say things about "merging languages" (I was reading that Liskell comment)
00:01:41 <mbishop> so I figured I'd ask :P
00:01:58 <dons> some of the required things, pattern matching, algebraic data types, monads, 2d layout, typeclses, parametric polymorphism
00:02:02 <dons> ah interesting
00:05:09 <mbishop> 2d layout?
00:05:24 <dons> layout, based on whitespace and code blocks
00:05:27 <dons> not on { ;;; }
00:05:32 <mbishop> ah, right
00:06:45 <mbishop> and I assume that you ment typeclasses?
00:06:54 <dons> oh yes :)
00:07:15 <dons> i.e. controlled bounded parametric polymorphism, as well as the usual parametric polymorphis
00:07:19 <dons> m
00:07:30 <dons> an smp runtime
00:07:52 <dons> oh, the big one: a separation on the type level of side effecting code from pure code
00:08:07 <dons> since that enables so many useful things
00:08:47 <dons> kfish++ patches
00:10:31 <kfish> dons: heh, cheers
00:11:18 <mbishop> For me, I think I'd want something with a simple syntax (not necessarily s-expr, just simple to parse), static typing with type inference, and something with a fairly smallish spec, but a really good documentation of the spec, and a good book teaching the language
00:12:34 <johnnowak> mbishop: i think that's what a lot of us want.
00:12:47 <johnnowak> a statically-typed scheme.
00:13:12 <mbishop> heh that would be nice
00:13:44 <johnnowak> well there's prescheme, but that's not quite it.
00:29:37 <xtruppaw> is there a way how I can 'overload' the output of a function in haskell?
00:30:30 <xtruppaw> that is I would like function for instance that sometimes it can return a pair or sometimes a triple !
00:32:00 <mgsloan> you can just return a tuple. or have the function's type be a list. or return an Either (OneType) (TheOtherType)
00:32:44 <mgsloan> Either (OneType) (OType1, OType2, OType3)
00:34:12 <xtruppaw> hmm list is not that elegant in the situation that I have got
00:34:13 <dons> or use a typeclass
00:34:25 <dons> what's your function called?
00:34:42 <dons> and what are its arguments?
00:35:03 <xtruppaw> lets for example call the function f and its arguments are a pair (a,b)
00:35:15 <rc-1> can you write a progran to tell weather or not a haskell program will halt, since it has no side effects?
00:35:38 <xtruppaw> no rc-1
00:35:40 <dons> rc-1: no, because of general recursion
00:35:46 <mgsloan> rc-1: no, lambda calculus, the basis of haskell was formulated to prove that you can't
00:35:51 <dons> > let f () = f () in f () :: ()
00:35:51 <lambdabot>  Exception: <<loop>>
00:36:14 <dons> rc-1: however, in Epigram, a language built on top of Haskell, you can... ;)
00:36:45 <dons> side effects aren't the issue.
00:36:50 <mgsloan> but you can't express a whole class of computations, which is what allows that
00:37:04 <mgsloan> it's arguably part of the issue
00:37:27 <mgsloan> not the root, for sure though
00:37:50 <dons> xtruppaw: and what kind of results do you want to return with your (a,b) ?
00:38:10 <xtruppaw> I want f to return either (a,b) or (a,b,c)
00:40:32 <mgsloan> hah, nice.  that shows how clever 'they' were in naming these type combinators :)
00:40:41 <dons> xtruppaw: depending on what?
00:40:57 <mgsloan> f :: (a,b) -> Either (a,b) (a,b,c)
00:41:15 <xtruppaw> dons : on the input:)
00:41:21 <xtruppaw> I think Either will work :)
00:41:22 <dons> xtruppaw: on the value of a or b?
00:41:23 <mgsloan> err, well, c is kinda undefined there
00:41:27 <dons> Either will work, yes
00:41:35 <dons> are a and b polymorphic?
00:41:52 <xtruppaw> no no just for instance (Int, Int)
00:41:59 <mgsloan> ohh
00:42:10 <xtruppaw> say if the first param is 10 then I would like to return a triple !
00:42:12 <xtruppaw> :)
00:42:14 <mgsloan> f :: (Int, Int) -> Either (Int, Int) (Int, Int, Int)
00:42:17 <xtruppaw> I think i found a solution
00:42:19 <xtruppaw> yep
00:42:20 <dons> yeah
00:42:30 <xtruppaw> thanks guys .. thanks dons and mgsloan
00:42:31 <xtruppaw> :)
00:42:36 <dons> if you wanted to return a differnt value based on the type, you coud use a typeclass
00:43:07 <dons> but since you have a monomorphic argument type, you have to use Either, or something isomorphic to it
00:43:19 <xtruppaw> ic ic!
00:43:57 <calvins_> On topic of Either (a, b) (a, b, c), could you also use (a, b, Maybe c)? Why would Either be preferable, if it is?
00:44:16 <xtruppaw> now another question.. if you don;t mind...
00:44:29 <xtruppaw> yep that could be also calvins_
00:44:52 <xtruppaw> Is it possible to say define a type
00:45:15 <xtruppaw> for instance ... type X whatever
00:45:16 <mgsloan> calvins - you could, i think either would be preferable though
00:45:24 <xtruppaw> such that...
00:45:44 <xtruppaw> someone using the type that you defined could do the follow:
00:45:46 <mgsloan> closer to what he specified (even used the word 'either'), and probably more efficient or somesuch
00:46:15 <xtruppaw> define a function: say f:: Int -> X q:: Int -> X
00:46:29 <xtruppaw> but f returns (Int,Int) and q returns (Int,Int,Int)
00:47:16 <mbishop> dons: can you recommend a good book that teaches haskell? (a "real" book, I have the pdfs of the ones that are available)
00:50:03 <dons> xtruppaw: here's a version that is polymorphic in the *return* type
00:50:04 <dons> http://www.cse.unsw.edu.au/~dons/tmp/Phantom.hs
00:50:08 <dons> so no Either's required
00:50:20 <dons> it'll return a (Int,Int) pair if you give it the type A as an arg
00:50:26 <dons> or a (Int,Int,Int) pair, if you give it B
00:53:29 <xtruppaw> dons thanks for the example :)
00:53:31 <xtruppaw> cheers
01:00:11 <dons> of course, its not what you need, since the dispatch is done statically, based on the type argument
01:00:15 <dons> not at runtime, based on some value
01:03:48 <dons> *Main> :t ret pair (undefined :: A)
01:03:48 <dons> ret pair (undefined :: A) :: (Int, Int)
01:03:48 <dons> *Main> :t ret pair (undefined :: B)
01:03:48 <dons> ret pair (undefined :: B) :: (Int, Int, Int)
01:03:48 <dons> *Main> :t pair
01:03:51 <dons> pair :: (Int, Int)
01:03:53 <dons> *Main> :t ret
01:03:56 <dons> ret :: (Ret c d) => (Int, Int) -> c -> d
01:03:59 <dons> *Main> :t ret pair
01:04:01 <dons> ret pair :: (Ret c d) => c -> d
01:04:58 <Cale> dons: hehe, check out my reply :)
01:13:48 <dons> Cale: nice response
01:28:59 <mattr> hi all
01:32:49 <mattr> beep
01:32:53 <mattr> bye
01:41:03 <metaperl> mbishop - "Haskell: The Craft of Functional Programming" by Simon Thompson
01:54:49 <_frederik_> is there an API to tell if a thunk has been evaluated or not?
01:56:54 <Lemmih> _frederik_: Not readily available, no.
01:56:57 <dons> _frederik_: seq ? -- seriously, you're not supposed to know this, so the answer isno
01:57:25 <dons> _frederik_: i'm interested, why would you need to distinguish them? writing a debugger?
01:58:06 <Masklinn> hello
01:58:51 <_frederik_> dons: no. sometimes there are two representations of the same datatype, and i'll use laziness to avoid creating both at once. some functions will depend on having one representation, so they will just use it and force evaluation if necessary; other functions will be able to use either one, so it would be nice to be able to test which one has already been evaluated
02:00:08 <_frederik_> dons: for instance, i might have a matrix datatype with one thunk for a row-order representation, and another for a column-order representation. some functions will prefer one representation, but others (such as "sum all the elements") won't care
02:01:52 <astrolabe> That's interesting
02:02:21 <Cale> hmm, actually, you might be able to do it with unsafePerformIO, that is, record which representation has been evaluated
02:02:27 <dons> hmm. yeah
02:02:29 <astrolabe> maybe you should base your decision about which to use on which you've used before rather than which the program has evaluated
02:03:01 <dons> i wouldn't want to rely on the representation, without explicit !'s and seqs
02:03:12 <nornagon> hr, how do you do a case statement that has the equivalent of C's fallthroughs?
02:03:21 <nornagon> like case foo of 1, 2 -> blah
02:03:23 <Cale> However, it's probably a whole lot safer just to make an algebraic datatype which is a tagged union of representations, and write up some basic functions for operating across different ones.
02:04:00 <dons> > let x = 1 in case x of _| x == 1 || x == 2 -> x
02:04:02 <lambdabot>  1
02:04:08 <Cale> case foo of n | n `elem` [1,2] -> blah
02:04:25 <dons> yep, use a list
02:04:32 <nornagon> dons: _|?
02:04:34 <roconnor>  case foo of 1, 2 -> blah doesn't look like fallthough to me.
02:04:40 <Cale> nornagon: _ |
02:04:44 <nornagon> oh
02:04:48 <nornagon> okay.
02:04:55 <nornagon> so, guards
02:04:55 <nornagon> 'k.
02:05:04 <roconnor> fallthough is when there is no break between case branches
02:05:11 <dons> > let x = 1 in case x of use_a_guard | True -> x
02:05:13 <lambdabot>  1
02:05:57 <nornagon> roconnor: right, i meant switch (foo) { case a: case b: blah; break; }
02:06:36 <astrolabe> in pure code though, it isn't clear what performing two operations consecutively means.
02:06:45 <roconnor> ah, ... I suppose that is sort of technically fallthough
02:06:57 <nornagon> astrolabe: right
02:06:59 <roconnor> but at least that is a reasonable C idom
02:07:16 <_frederik_> Cale: well, i can use unsafePerformIO to hack around the lack of an API, that's true. but i think one should exist
02:07:19 <nornagon> is there a nicer way in a case to say 'otherwise' than True -> (blah)?
02:07:44 <roconnor> nornagon:  use otherwise
02:07:44 <astrolabe> _frederik_: but it's cheating!
02:07:51 <roconnor> > otherwise
02:07:52 <lambdabot>  True
02:07:55 <roconnor> :)
02:08:00 <nornagon> i see :P
02:08:10 <_frederik_> astrolabe: but i'm not playing a game, i'm trying to do work
02:08:21 <nornagon> happily, otherwise matches non-Bool types, too.
02:09:30 <roconnor> nornagon: actually, what is going on is that you are binding `otherwise' to the value
02:09:56 <roconnor> nornagon: you can use _ to mach everything else at the end of a case statement
02:10:27 <nornagon> ah
02:10:31 <nornagon> i see :)
02:10:40 <astrolabe> _frederik_: I understand that, but the choice to use haskell is an acceptance that the costs of referential transparency are out-weighed by the benefits.  In this case, the costs are having to work-out yourself an efficient representation strategy.
02:11:43 * astrolabe sounds like a purity nazi
02:14:43 <_frederik_> no, this should be part of the standard library so people don't duplicate work. there should be an interface for creating thunks, of which unsafePerformIO is the primary function (probably renamed). it should be possible to indicate to the RTS how expensive a thunk is to evaluate, and also there should be an interface to show the RTS how to unevaluate thunks (which can be ignored by the RTS until it is smart enough to decide to do that)
02:15:43 <_frederik_> the point of these things is to provide *more* referential transparency; to allow *more* things to use the lazy-pure paradigm
02:16:28 <_frederik_> the RTS will always be imperative behind the scenes; allowing people to interface with this imperativeness with Haskell libraries does not make Haskell a poorer language, but quite the opposite
02:16:37 <dons> _frederik_: it would be an interesting proposal to make on haskell-cafe@
02:17:04 <dons> there might be some cross over with the Parallel.Strategies stuff, and some of the debugging guys have asked for internal hooks before
02:17:24 <_frederik_> sure, well i don't have the time to wikify it :)
02:21:28 <dons> you could do that too ;)
02:31:54 <Philippa> _frederik_: one of the problems with more internal hooks is it fixes the evaluation strategy
02:32:02 <Philippa> the H98 standard doesn't do that
02:41:19 <mattr_> j
02:42:37 <_frederik_> Philippa: is unsafePerformIO not in H98? anyway, it should be
02:42:52 <Lemmih> mattr_: Indeed.
02:42:55 <_frederik_> and the stuff i'm proposing is implementable with it
02:44:28 <dons> that's good then
02:44:37 <dons> its h98 + FFI-valid ;)
02:44:40 <Philippa> _frederik_: given the nature of H98, no it shouldn't have been
02:44:47 <Philippa> H98 didn't even have an FFI
02:45:01 <dons> we really really need a safe h98 core -- if just to make lambdabot safe ;)
02:45:10 <dons> so its good that h98 is what it is
02:45:27 <Philippa> furthermore, H98 didn't specify an order of evaluation and you can't define unsafePerformIO sensibly without one. There's no notion of sharing in the standard...
02:45:57 * psnl mutters about the unsafe in unsafePerformIO. 
02:46:34 <Philippa> *nod*
02:46:53 <Philippa> it needs marking out in such a way that a safe core can be obtained and stuck to in every implementation
02:47:43 <psnl> whats wrong with monads, apart from them being old-skool ?
02:47:55 <dons> wrong with them? :)
02:48:03 <sieni> old-skool?
02:48:19 <dons> aren't they new and just right? :)
02:48:23 <Philippa> psnl: that would work if ordinary evaluation was in one as well
02:48:41 <dons> well, not quite. they could be commutative, and we need more monad transformers, but ...
02:49:02 <Philippa> (I've toyed with related ideas - for example, suppose -> only "really" did constructor application and an eval primitive and you had to build the rest yourself?)
02:49:44 <mattr_> quick question for you all
02:50:13 <mattr_> does anyone know how to get ghc to spit out STG code (or c-minus-minus, etc)
02:50:26 <sieni> monadic IO is the greatest thing since sliced bread
02:50:30 <mattr_> I want to be able to inspect the stg code that ghc generates
02:50:39 <mattr_> for certain programs.
02:50:49 <mattr_> sieni: aggreed
02:52:05 <psnl> mattr_: two ticks, I'm reading the man page
02:52:11 <dons> mattr_: -ddump*
02:52:17 <dons> -ddump-stg, -ddump-cmm
02:52:23 <dons> -ddump-simpl for the core
02:52:31 <mattr_> thankyou very much
02:52:42 <mattr_> I promise I looked over man and the user guide first
02:52:56 <psnl> thats it.
02:52:58 <mattr_> dons: I thought you might know that one :)
02:53:06 <dons> check options-debugging.html
02:53:32 <mattr_> btw - those ghc hackathon videos are wonderful if you haven't seen them yet
02:53:34 <psnl> sieni: old-skool is just old-school spelt badly, and it implies a older school of thought about an issue.
02:54:00 <_frederik_> Philippa: unsafePerformIO is a good thing. every thunk in every RTS, which is inspected, will be evaluated at some point, whether during compilation or during program execution, and this evaluation will take place in time. so to ask for a thunk's value to be defined by an imperative computation is quite natural. one simply has to be careful to use it correctly if one wants to preserve desirable semantics. unsafePerformIO is a way to modify
02:54:03 <sieni> psnl: yes, I know that
02:54:23 <dons> psnl: why are monads old school? they're the new generatoin, after all (after cps and all the other hacks ;)
02:54:52 <Philippa> _frederik_: what are these thunks of which you speak?
02:55:10 <mattr_> A  thunk is a suspended computation
02:55:14 <_frederik_> "expression", then
02:55:32 <psnl> dons: I'm younger than you ;-), and haskell has had monads for all the time I have been using it and for some time before.
02:55:46 <_frederik_> Philippa: if you like, you can point me to an RTS in which it is not possible to implement unsafePerformIO
02:56:01 <roconnor> _frederik_: what is this ``time'' of which you speak ;)
02:56:16 <Philippa> _frederik_: please specify the exact semantics you want for it first
02:56:32 <_frederik_> Philippa: it's a Haskell RTS
02:56:34 <kosmikus> psnl: but doesn't old-school imply that there's something newer?
02:56:45 <psnl> kosmikus: nah
02:56:50 <mattr_> psnl: quite the opposite
02:56:59 <Philippa> _frederik_: again, please specify unsafePerformIO. I can show you many which won't have the exact semantics of GHC's RTS...
02:57:23 <mattr_> boy o boy - it is hard to keep up with all this :)
02:57:28 <int-e> unsafePerformIO: This will be evaluated if the thunk it represents is executed. It could be evaluated more than once, even if the sharing is obvious. (current semantics of unsafePerformIO on ghc with the SMP RTS). That's rather weak.
02:57:46 <mattr_> anyone doing their irc'ing on the amc command line?
02:57:50 <Philippa> int-e: yup. For a number of purposes it's too weak
02:57:55 <mattr_> amc = mac
02:58:08 <roconnor> int-e: doesn't evaluating more than once break referential transparency?
02:58:10 <Philippa> nope. I've done it from a *nix console enough times though
02:58:19 <Philippa> roconnor: see that "unsafe" bit?
02:58:21 <_frederik_> Philippa: ok, so maybe something is wrong with your purposes
02:58:25 <mattr_> I am having troubl with identd on mac
02:58:29 <Philippa> (and yes, but then you want it to for Debug.Trace)
02:58:34 <_frederik_> Philippa: and not the weak unsafePerformIO semantics
02:58:59 <roconnor> Philippa: ah, so maybe we should just say that a program that has unsafePerformIO can do anything.
02:59:08 <int-e> roconnor: yes it does cause trouble. see for example http://hackage.haskell.org/trac/ghc/ticket/986
02:59:10 <lambdabot> Title: #986 (SMP race condition in getContents) - GHC - Trac
02:59:28 <Philippa> roconnor: maybe we just shouldn't be specifying it in the standard just yet?
03:00:00 <int-e> 'at most once' semantics is what people seem to expect and want.
03:00:04 <Philippa> or we could have a family of standardised operations, not all of which are supported by a given implementation
03:00:16 <Philippa> int-e: they're hackable given IORefs though
03:00:39 <_frederik_> Philippa: your suggestion defeats the purpose of "standardisation"
03:00:40 <Philippa> granted that amounts to manually building your own representation of a thunk...
03:00:56 <Philippa> _frederik_: no more so than cabal's support for specifying used extensions
03:02:06 <_frederik_> Philippa: clearly a bad example
03:02:22 <Philippa> _frederik_: depends what you want an example *of*
03:02:31 <int-e> Philippa: I'm not trying to say that unsafePerformIO would be safe with that guarantee.
03:03:00 <Philippa> we're at fundamental disagreement as to what's appropriate, complaining about someone's showing the consequences of their approach as "a bad example" isn't productive
03:03:05 <int-e> Philippa: I'm just going by the examples in the standard libraries, most notably getContents.
03:03:26 <int-e> Philippa: (and what I'm saying is ghc specific. I'm aware of that.)
03:03:34 <_frederik_> Philippa: i'm just saying that the language itself shouldn't aim to be as ill-specified as Cabal
03:03:36 <Philippa> int-e: yeah. SMP was always going to cause fun
03:03:59 <Philippa> _frederik_: and *I'm* saying that hey, that looks a lot like we shouldn't specify unsafePerformIO as part of Haskell' then
03:05:06 <Philippa> you've just been shown an example of an RTS where even the more restricted unsafeInterleaveIO isn't safe in its canonical use case...
03:05:29 <Philippa> ...how much more broken do you want?
03:07:19 <_frederik_> Philippa: well, i think what you call the "canonical example" isn't very easy to implement at all. there are much simpler examples which work fine everywhere
03:07:39 <_frederik_> such as unsafePerformIO (newIORef ...)
03:07:53 <_frederik_> no wait, not that :)
03:08:04 <_frederik_> well, such as what i'm doing
03:08:29 <Philippa> when most of the common use cases are broken or require further pragmas, I think it's a bit early for standardisation
03:09:24 <_frederik_> Philippa: well anyway, i think the answer is more API, not less. 
03:09:25 <mq_mattr> thanks again for the help, this stg stuff is fun
03:09:34 <mq_mattr> complex, confusing, and fun
03:09:49 <mq_mattr> actually, the concepts are brilliantly simple
03:09:52 <Philippa> sure, you may've noticed I proposed that too (albeit with less requirement for everything to support all of it)
03:10:01 <mq_mattr> but once you get into the nitty-gritty, things get fun
03:10:02 <mq_mattr> fun
03:10:04 <mq_mattr> fun
03:10:08 <Philippa> but it's too early to expect a single do-everything API portable across all implementations
03:11:15 <_frederik_> Philippa: well, i don't think it's so early, myself
03:22:42 <mq_mattr> this is probably old hat to you guys, but I just hit the monomorphism restriction for the first time
03:22:51 <mq_mattr> how exciting :)
03:27:20 <_frederik_> Philippa: for instance, the SMP getContents bug advocates a 'justOnce' function. That's pretty simple. and there are a ton of cases (for instance readFile) where the use of unsafePerformIO/unsafeInterleaveIO is both necessary and well-defined
03:28:14 <_frederik_> Philippa: the problem with getContents is that it uses unsafePerformIO when it wants a justOnce; but why should other users of unsafePerformIO suffer as a result?
03:28:37 <_frederik_> Philippa: some people don't need a justOnce
03:28:52 <ski> the way Mercury solves this is quite interesting ..
03:29:00 <ski> (or maybe .. solves part of this)
03:29:42 <_frederik_> how is that?
03:29:52 <ski> in Mercury, predicates and functions can be 'impure' .. this is noted in the type signatures of them
03:29:55 <Philippa> _frederik_: you're still not giving strong enough arguments for standardisation
03:30:15 <ski> if you use an impure function, the function you're defining automatically gets impure, too
03:30:30 <ski> impure functions use a strict sequential semantics
03:30:46 <dons> mq_mattr: hehe!
03:30:48 <_frederik_> ski: but then you can't use impure functions to define pure ones like readFile, right?
03:31:00 <Philippa> _frederik_: what's wrong with a 'de facto' standard?
03:31:14 <ski> calls to impure functions must be prepended with with the 'impure' keyword (syntactic salt)
03:31:27 <Philippa> why should all users of Haskell suffer a badly-defined and unpreventable unsafePerformIO in their language?
03:31:32 <dons> syntactic poiso, you mean? ;)
03:31:46 <_frederik_> Philippa: it's not badly defined
03:31:51 <ski> one can at a point use a 'promise_pure' construction to say that, at this interface, it behaves in a pure way
03:32:13 <ski> ffi functions are per default impure, if you don't use 'promise_pure' there, too
03:32:34 <ski> anyway, 'impure' is not intended for everyday programming
03:32:57 <_frederik_> ski: interesting. but it just sounds the same as unsafePerformIO. how does it guarantee sharing when people want sharing?
03:32:58 <Philippa> that's equivalent to Haskell's approach, pretty much
03:33:02 <ski> the intension is to use this to interace to foreign libraries, so that one can write as much of the wrapper code in mercury as possible
03:33:21 <ski> also in some special efficiency cases, it is approved to use
03:33:36 <_frederik_> right
03:34:11 <ski> this is not the same as 'unsafePerformIO', since the type (and module) system keeps track of which functions are impure (adn there's a surface syntax for this)
03:34:32 <ski> also because the semantics of impure functions are specified to be strict sequential
03:34:37 <Philippa> ski: so does the IO monad, with unsafePerformIO being promise_pure, no?
03:35:03 <Philippa> though I guess return gives the monadic solution some extra power - the ability to be lazy again
03:35:07 <ski> Philippa : well, yes, to a certain degree i agree
03:40:22 <_frederik_> certainly, the current weak definition of 'unsafePerformIO' doesn't fix the evaluation strategy
03:41:02 <_frederik_> anyway, i'm off to lunch
03:45:22 <ski> (though mercury also has an intermediate purity called 'semipure' to be used when reordering between pure and semipure parts are ok, but not moving across impure "boundaries" .. since 'semipure' should only be able to depend on current implicit state, but not affect it)
03:48:36 <nornagon> ?hoogle bracket
03:48:37 <lambdabot> IO.bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
03:48:37 <lambdabot> IO.bracket_ :: IO a -> (a -> IO b) -> IO c -> IO c
03:48:37 <lambdabot> Control.Exception.bracket_ :: IO a -> IO b -> IO c -> IO c
03:49:47 <ski> (another difference is that using 'unsafePerformIO' badly, e.g. performing things in the wrong order may make the system instable, while usually IO-actions don't do that .. i.e. it could be worthwhile to separate ordinary 'IO' from unsafe things for that reason)
04:05:33 <int-e> _frederik_: justOnce would be a pure function. (why? because it has to be possible to apply it to an arbitrary chunk.)
04:05:42 <int-e> _frederik_: it's not an unsafePerformIO replacement.
04:07:32 <Philippa> having the dual might be nice too
04:07:36 <Philippa> I could see it preventing space leaks
04:08:54 <int-e> interesting thought.
05:06:03 <nornagon> ?pl func1 x = map (\y -> y*x)
05:06:03 <lambdabot> func1 = map . (*)
05:06:47 <nornagon> ?type func1 x = map (\y -> y*x)
05:06:48 <lambdabot> parse error on input `='
05:07:02 <nornagon> ?type let func1 x = map (\y -> y*x) in func1
05:07:04 <lambdabot> forall a. (Num a) => a -> [a] -> [a]
05:07:09 <dylan> ?type (map . (*))
05:07:11 <lambdabot> forall a. (Num a) => a -> [a] -> [a]
05:07:16 <nornagon> ... i see
05:07:29 <nornagon> I am getting Integer -> [Integer] -> [Integer]
05:07:32 <nornagon> from ghci
05:07:43 <Botje> well, Integer is a member of the Num typeclass
05:07:46 <Botje> so that's okay
05:07:48 <roconnor> monomorphism restriction strikes again
05:07:51 <Cale> You're putting it in a file, and it's defaulting
05:08:10 <Cale> yeah, if you turn off the MR, you'll get the better type
05:08:11 <Botje> and (\y -> y*x) can be written as (*x)
05:08:27 <Botje> or (x*), since * is commutative
05:08:30 <roconnor> Try eta expanding it
05:08:41 <nornagon> it turns out if i actually specify the type to be (Num a) => a -> [a] -> [a], it works fine
05:08:58 <dylan> yep.
05:09:09 <Cale> right
05:09:11 <nornagon> o/ dylan
05:13:10 <nornagon> ?pl \x -> x*x
05:13:11 <lambdabot> join (*)
05:20:30 <syntaxfree> @hoogle [Map k a] -> Map k a
05:20:31 <lambdabot> Data.Map.unions :: Ord k => [Map k a] -> Map k a
05:20:31 <lambdabot> Data.Map.unionsWith :: Ord k => (a -> a -> a) -> [Map k a] -> Map k a
05:21:05 <syntaxfree> okie dokie.
05:29:33 <syntaxfree> @paste
05:29:34 <lambdabot> http://paste.lisp.org/new/haskell
05:29:49 <syntaxfree> no lisppaste!
05:29:56 <Lemmih> lisppaste2: url
05:29:56 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/Haskell and enter your paste.
05:30:35 <syntaxfree> Not working! ;)
05:30:36 <Lemmih> hm
05:30:44 <syntaxfree> anyway..
05:30:45 <syntaxfree> http://www.rafb.net/paste/results/Tha8hc81.html
05:30:46 <syntaxfree> :~
05:31:24 <syntaxfree> it's all okay until manySections
05:31:51 <syntaxfree> Parsec should anticipate a section division coming on, but it doesn't./
05:35:05 <Lemmih> syntaxfree: You're eating the '['.
05:35:28 <syntaxfree> I've thought of that.
05:36:15 <Lemmih> *Gini> doof
05:36:15 <Lemmih> [fromList [("hehe",fromList [("bound","to be"),("this","is"),("very","interesting")])],fromList [("sectiontwo",fromList [("k\ey1","val1"),("key2","val2")])],fromList [("sectionthree",fromList [("key1","val1"),("key2","val2")])]]
05:36:17 <syntaxfree> but, if, in line 38, I replace "manyTill keyVal (char '[')" with "many keyVal", I get no luck either.
05:36:26 <syntaxfree> oh god.
05:36:28 <syntaxfree> How did you fix it?
05:37:15 <syntaxfree> :~
05:38:22 <Lemmih> Use 'many keyVal' and make sure 'keyVal' doesn't parse "[section] key=val" as ("[section] key", "val").
05:38:45 <syntaxfree> hmm.
05:39:07 <syntaxfree> notFollowedBy (char '[') ?
05:39:08 <syntaxfree> :~
05:39:21 <Lemmih> @index noneOf
05:39:21 <lambdabot> Text.ParserCombinators.Parsec.Char, Text.ParserCombinators.Parsec
05:39:31 <syntaxfree> oh.
05:39:51 <syntaxfree> @type noneOf
05:39:52 <lambdabot> Not in scope: `noneOf'
05:39:57 <Lemmih> You could probably benefit from using a lexer.
05:40:14 <syntaxfree> yes. I thought this was simple enough that I wouldn't need to learn about lexers.
05:41:26 <syntaxfree> bingo. Thanks for helping!
05:41:58 <Lemmih> My pleasure.
05:43:28 <syntaxfree> the show definition for Maps is ugly.
05:45:15 * shapr boings
05:45:20 <shapr> Good morning #haskell!
05:45:31 <Syzygy-> Heya shapr
05:45:58 <shapr> From the lambda to the universal quantification, it's cold out there!
05:46:01 <Lemmih> Greetings shapr.
05:46:05 * shapr boings more!
05:46:15 <shapr> Syzygy-: how's code?
05:46:21 <shapr> Lemmih: hiya!
05:46:44 * Syzygy- grumbles. Need to stop thinking about code for long enough to get this bloody homework bloody corrected in time for the bloody class tomorrow...
05:47:05 <Syzygy-> (also known as "Oooops, I spent all of last week on my research, and now the time I had to correct is gone....")
05:47:19 <syntaxfree> Syzygy-: I wish it was homework.
05:47:38 <syntaxfree> I'm actually killing time when I should be studying bloody industrial economics.
05:47:49 <syntaxfree> oh, I thought.
05:47:51 <Syzygy-> But I very much want a completely generic matrix library for Haskell, an implementation of group algebra arithmetic, and automated liftings of maps between free kG-modules...
05:47:53 <syntaxfree> Nevermind!
05:47:53 <shapr> syntaxfree: Why not implement the industrial economics ideas in Haskell?
05:48:03 <ms_> there is no reason to "study" industrial economics. ;)
05:48:36 <syntaxfree> shapr: I'm working first on reframing theoretical super-game theory into cata-ana-hylo-para-zygo form.
05:48:54 <syntaxfree> (Super-games are merely repeated games. They arise in oligopolistic competition analysis)
05:48:57 <Syzygy-> cata-ana-hylo-para-zygo-say-what-now??
05:49:06 <shapr> expialadocious?
05:49:12 <shapr> @quote stepcut
05:49:13 <lambdabot>  how can you possibly implement business logic without knowing about Schonfinkel!?
05:49:14 <syntaxfree> what is the damn monomorphism restriction again?
05:49:16 <shapr> @quote stepcut
05:49:16 <lambdabot>  how can you possibly implement business logic without knowing about Schonfinkel!?
05:49:18 <shapr> doh
05:51:06 <shapr> syntaxfree: I know about game theory, and I know about bananas, lenses, barbed wire, etc, but the rest of that...
05:51:33 <shapr> @quote stepcut
05:51:33 <lambdabot>  how can you possibly implement business logic without knowing about Schonfinkel!?
05:51:34 <syntaxfree> well, you may have heard of repeated prisoner dilemma strategies.
05:51:36 <shapr> @quote stepcut
05:51:36 <lambdabot>  I wrote 1 + 1 in php once, and got 11 -- wasn't quite what I was hoping for
05:51:41 <shapr> bah
05:51:42 <syntaxfree> trigger, tit-for-n-tat, etc.
05:52:26 <Lemmih> @time shapr
05:52:27 <lambdabot> Local time for shapr is Mon Dec  4 07:48:35 2006
05:54:35 <shapr> syntaxfree: Yeah, I've read about that.
05:54:55 <syntaxfree> so, um, more complicated forms of that arise in oligopolistic competition analysis.
05:55:06 <syntaxfree> anyway.
05:55:09 <shapr> That makes sense.
05:55:17 <syntaxfree> for example, one thing that frequently arises is discounting future pay-offs to the present.
05:55:40 <syntaxfree> There's current research on whether changing exponential (interest-rate-like) discounting to hyperbolic discounting changes results.
05:56:27 <syntaxfree> if results on discounted future pay-offs  can be stated in terms of catas, then they don't -- nor does any other discounting scheme.
05:56:30 <shapr> syntaxfree: Hey, that has a direct connection to amortization in non-strict algorithmic complexity.
05:56:55 <earthy> this is weirding me out
05:57:00 <syntaxfree> It seems so.
05:57:01 * earthy actually understands what is being said
05:57:30 <syntaxfree> anyway, there is a number of other connection points between supergame analysis and cata-ana-hylo-yadda theory.
05:58:08 <syntaxfree> the way I see it, Bird-Merteens calculus is about the algebraic properties of recursive functions.
05:58:16 * earthy nods
05:58:17 <syntaxfree> FP is merely an early application.
05:58:55 <shapr> I've never looked at bird-merteens calculus, is there a good intro? Should I check wikipedia or other early google hit?
05:59:52 <syntaxfree> maybe I'm misusing the term. As far as I understood, Bird-Merteens calculus is the cata-ana-hylo-yadda stuff.
06:00:12 <syntaxfree> At least that's what I understand from Meijer (1991).
06:00:27 <earthy> almost
06:01:12 <shapr> breakfast time, bbl
06:01:58 <earthy> cata, ana, para and hylo
06:02:09 <shapr> what's a para?
06:02:16 <shapr> ah, breakfast calls... with two of my siblings even!
06:02:18 * shapr &
06:02:19 <syntaxfree> Meijer-91 is already an extension to Bird-Merteens?
06:02:33 <earthy> syntaxfree: it is based on squiggol, yeah
06:02:55 <earthy> for a good intro, shapr, read 'sorting morphisms' by lex augusteijn
06:03:11 <syntaxfree> oh. I just saw it as an addition to a continuum of research, not as a break.
06:03:20 <syntaxfree> earthy: hey. good reference, it seems.
06:04:01 <syntaxfree> I was just breaking my  head between Freyd's "Abelian Categories", "Functional programming with bananas etc." and "Bananas in space" to figure the theory out.
06:04:21 <earthy> basically, squiggol (bird meertens formalism) was a functional language that was designed to reason about cleanly
06:04:32 <earthy> to do so it strongly advocated pointless functions
06:04:37 <earthy> err, point free
06:05:09 <syntaxfree> I find Squiggol visually appealing.
06:05:22 <syntaxfree> I wish Haskell would support [(a, b)] ([c,d]) notation.
06:05:32 <earthy> http://www.cs.uu.nl/research/techreps/repo/CS-1989/1989-09.pdf by the way
06:06:48 <Lemmih> syntaxfree: What does [c,d] mean?
06:07:00 <earthy> and, shapr: http://www.cs.uu.nl/research/techreps/repo/CS-1990/1990-04.pdf
06:07:46 <syntaxfree> ah, c and d are inside banana-shaped brackets.
06:08:01 <Syzygy-> syntaxfree: Huh?
06:08:28 <syntaxfree> h = ([c,d]) basically means foldr c d
06:08:48 <syntaxfree> er, h = ([c,d])  ===> h x = foldr c d x
06:09:28 <syntaxfree> or whatever the current foldr syntax is.
06:09:36 <syntaxfree> jesus, it's noon already.
06:09:42 <syntaxfree> I haven't done any work!
06:09:44 <earthy> ;)
06:09:49 <earthy> that happens to me all the time :)
06:09:52 * Syzygy- looks at his watch.... 3pm....
06:33:47 <llama32> i'd like to implement an ml-like type system... i've been reading up on the HM algorithm, but i'm not really grasping it... anyone know of some small type inferer sources [pseudo-code?] out there - or some good papers/articles/.. about it? [preferably not in haskell code - i don't know haskell... i'm asking here because i figured there would be some people with knowledge of type inference]
06:34:56 <Philippa> llama32: do you know how unification works?
06:35:12 <Philippa> if not you may get a bit stuck
06:35:41 <llama32> nope lol
06:35:52 <Philippa> read up on that first, then
06:36:14 * llama32 googles
06:39:22 <pejo> llama32, Simon Peyton Jones has a book on his homepage which contains miranda code for a type inference algorithm iirc.
06:39:53 <pejo> There is probably some surrounding text that explains it too.
06:40:09 <Philippa> cardelli's got a good tutorial paper if you don't mind it having code in MODULA-2
06:40:33 <llama32> hmm
06:41:03 <pejo> "The implementation of Functional programming languages" was the name of it.  Chapter 8/9.
06:55:53 <araujo> morning
06:57:03 <niarium> midnight here
07:24:56 <kzm> Argh.
07:25:36 <kzm> Spent hours struggling with 'unfoldr' that insisted on introducing a Char in the (somewhat complex) state.
07:26:01 <kzm> Turns out Data.ByteString.unfoldr was in scope, but Data.List.unfoldr wasn't.
07:39:50 <LoganCapaldo> @pl (\n xs -> head $ drop n xs
07:39:50 <lambdabot> (line 1, column 27):
07:39:50 <lambdabot> unexpected end of input
07:39:50 <lambdabot> expecting variable, "(", operator, "$", "$!", "`seq`" or ")"
07:39:54 <LoganCapaldo> @pl (\n xs -> head $ drop n xs )
07:39:55 <lambdabot> (head .) . drop
07:40:13 <Syzygy-> Is there any comment I can put in a source file to get GHC to not complain about incomplete type class instances for that file?
07:42:40 <Lemmih> Syzygy-: {-# OPTIONS_GHC -w #-}
07:42:55 <Syzygy-> Lemmih: And this won't turn off warnings I actually do want to see?
07:45:14 <Lemmih> You can fix that by not wanting to see any warnings (:
07:47:23 <fizbin> So I'm not going to do it, because I don't want to spam the channel accidentally, but does lambdabot have protections against people asking her to print out [1..] or similar messes?
07:47:38 <eviltwin_b> hm.  I'm probably doing something stupid, but:  ?pl gave me `(=<<) . ap (showZ zemanimDefs) . ($ zemanimDefs)' yesterday, but actually using that gets an error from ap about missing instance for Monad ((->) a).  (the first parameter, and showZ, are monadic in IO)
07:47:52 <eviltwin_b> fizbin: there are limits onboth runtime and amount of output
07:48:37 <eviltwin_b> <eviltwin_b> ?pl \f dm -> dm >>= \t -> showZ zemanimDefs t (f zemanimDefs t)
07:48:38 <eviltwin_b> <lambdabot> (=<<) . ap (showZ zemanimDefs) . ($ zemanimDefs)
07:48:47 <Lemmih> > [1..]
07:48:49 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
07:48:53 <eviltwin_b> am I being dumb or is it?
07:49:26 <Lemmih> eviltwin_b: Try importing Control.Monad.Reader
07:49:45 <eviltwin_b> hm.  Control.Monad is already there (ap was undefined otherwise)
07:50:47 <norpan> you need the instance for Monad ((->) a) which is defined in the module Control.Monad.Reader
07:52:13 <eviltwin_b> indeed, that fixed it.  not exactly intuitive...
07:52:24 <eviltwin_b> thanks lemmih++ norpan++
08:11:45 <fizbin> ?pl \x -> x x
08:11:46 <lambdabot> join id
08:17:55 <fizbin> Is there a way to have lambdabot spit back a given instance declaration?  For example, what if I wanted to see how ((->) r) is a Monad?
08:18:55 <metaperl> @type (->)
08:18:57 <lambdabot> parse error on input `->'
08:19:15 <fizbin> @type ((->) r)
08:19:17 <lambdabot> parse error on input `->'
08:22:03 <Daveman> hey chessguy :)
08:22:26 <chessguy> yo!
08:25:17 <chessguy> if allergic to extreme n00biness, please close your eyes:
08:25:19 <chessguy> http://cpp.sourceforge.net/?show=25801
08:25:24 <lambdabot> Title: #C++ Pastebin
08:26:07 <chessguy> i've pasted the error i'm getting at the bottom of the code
08:26:29 <chessguy> all i'm trying to do is construct a population with a random distribution
08:26:36 <chessguy> err, with a known distribution
08:28:02 <chessguy> in this case, the likelihood of 0 arrivals is .2, 1 arrival is .3, 2 arrivals is .4, and 3 arrivals is .1
08:29:17 <Syzygy-> chessguy: With that easy a distribution, why don't you just take a uniform distribution and redistribute? So, say, use .1 as the generic bin size, and generate a uniformly distributed integer between 1 and 10, returning 0,0,1,1,1,2,2,2,2,3 respectively.
08:29:37 <Syzygy-> Oh. That's what you're doing...
08:29:41 <Syzygy-> Hrm. *blush*
08:30:07 <Syzygy-> Ah.
08:30:11 <eviltwin_b> hm, is the problem there that myRands is in IO but randomTrials is in List?
08:30:18 <Syzygy-> Yup, that seems to be it.
08:30:26 <eviltwin_b> (yes, myRands returns a list but it's wrapped in an IO so it'
08:30:31 <Syzygy-> You need to stay in IO .
08:30:37 <eviltwin_b> s the IO that gets "unwrapped" instead of the list)
08:30:52 <chessguy> hmm, so how do i fix it?
08:31:07 <Syzygy-> You could try to just change the signature to Int -> [Int] -> IO [Customer]
08:31:11 <eviltwin_b> for one, the result type is IO [Customer]
08:31:21 <eviltwin_b> once you're in IO, you have t stay there
08:31:26 <chessguy> hmm
08:33:59 <Syzygy-> I have one that compiles...
08:34:41 <Syzygy-> http://cpp.sourceforge.net/?show=25804
08:34:42 <lambdabot> Title: #C++ Pastebin
08:35:14 <Syzygy-> Changing the result to IO [Customer] and changing all Integers to Ints did the trick.
08:36:35 <Syzygy-> You will want to controll the rn as well though.
08:36:43 <Syzygy-> *MonteCarloLineSim> myRands 1
08:36:43 <Syzygy-> [-5199690855206529777]
08:36:54 <Syzygy-> and your case statement only handles things modulo 10.
08:37:19 <Syzygy-> So you'll want to either redefine myRands or randomTrials to involve a `mod` 10 somewhere
08:38:17 <chessguy> well, main does the `mod 10`
08:38:36 <chessguy> though i guess i should do that in myRands
08:39:05 <Syzygy-> Oh, and, it may be an idea to let Customer inherit Show.
08:39:25 <Syzygy-> Time to leave the office though. *poof*
08:39:30 <chessguy> thanks
08:47:43 <Daveman> :)
08:53:09 <chessguy> integral--
08:53:31 <integral> bah!
08:54:40 <Wikipedia-Gast72> HEY HO LETS GO
08:55:12 <Lemmih> SamB: black-knot?
08:57:36 <kaol> I must be bored to come up with thoughts like this... Could quicksort be generalized to MonandPlus? (++) == `mplus` already, but what could be the generalisation of filter?
08:58:10 <kaol> s/Monand/Monad/
09:00:49 <kaol> oh, there's a filterM.
09:01:21 <kaol> it's an another question then that would such a thing be useful
09:01:56 <norpan> filterM is not what you're looking for
09:02:27 <vegai> norpan, the jedi master
09:02:46 <kaol> @type filterM
09:02:47 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
09:03:34 <chessguy> @pl event x y = (x,y)
09:03:35 <lambdabot> event = (,)
09:03:51 <norpan> you'd want something like m >>= \x -> if p x then return x else mzero
09:04:08 <kaol> @type filter
09:04:10 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
09:04:12 <chessguy> @pl f x = f x []
09:04:13 <lambdabot> f = fix (flip flip [])
09:04:35 <chessguy> heh
09:04:37 <norpan> @type \p m -> m >>= \x -> if p x then return x else mzero
09:04:39 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => (a -> Bool) -> m a -> m a
09:04:56 <kaol> @hoogle (MonadPlus m) => (a -> Bool) -> m a -> m a
09:04:57 <lambdabot> Prelude.until :: (a -> Bool) -> (a -> a) -> a -> a
09:05:22 <norpan> (\p m -> m >>= \x -> if p x then return x else mzero) (>5) [1,3,6,7,2,4,9]
09:05:28 <norpan> > (\p m -> m >>= \x -> if p x then return x else mzero) (>5) [1,3,6,7,2,4,9]
09:05:29 <lambdabot>  [6,7,9]
09:05:43 <norpan> there you go
09:06:20 <kaol> yay, I can run quicksort on Maybe now :-)
09:10:35 <kaol> what other MonadPlus instances are there besides Maybe and List?
09:10:46 <norpan> @instances MonadPlus
09:10:47 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
09:11:25 <kaol> ooh. Think you could qsort any of those?
09:11:33 <norpan> all, obviously :)
09:11:42 <kaol> would it be of any use?
09:12:03 <norpan> not really
09:12:29 <Saizan> qsort IO :O
09:12:38 <kaol> aww. A fun exercise, nonetheless?
09:12:47 * eviltwin_b was being amused by that thoight as well
09:13:13 <norpan> well, the filter i gave above is just made so it works on the list monad, i have not thought about it in any other terms
09:14:04 <norpan> but it sorts of makes sense
09:14:16 <norpan> if you have some other kind of non-determinism than lists
09:14:32 <norpan> it would filter out those alternatives matching the predicate
09:37:07 <mbishop> metaperl: I'm way late, but thanks :)
09:37:23 <nomeata> http://www.joachim-breitner.de/blog/archives/210-FourFours-in-Haskell.html
09:37:27 <lambdabot> Title: FourFours in Haskell - nomeata's mind shares, http://tinyurl.com/y66mnu
09:38:30 <metaperl> mbishop - heh. glad you benefitted... I am learning from that book. Some people like the Sethi and Almaasi "Algorithms in Haskell" but that doesnt get into Monads (I dont think)
09:39:01 <emu> > Just 1 `mplus` Just 2
09:39:02 <lambdabot>  Just 1
09:40:57 <glguy> > msum [Just 1, Just 2]
09:40:58 <lambdabot>  Just 1
09:47:38 <kpreid> @type guard
09:47:40 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
09:48:21 <kpreid> @type \f x -> guard (f x) >> return x
09:48:23 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => (a -> Bool) -> a -> m a
09:49:00 <kpreid> @pl \f -> (>>= \x -> guard (f x) >> return x)
09:49:00 <lambdabot> (=<<) . (`ap` return) . (((>>) . guard) .)
09:49:03 <kpreid> ack
09:49:36 <kpreid> anyway, 'guard' is useful for 'else mzero' purposes
09:58:42 <rc-1> haskell should use this as the default sorting mechanism: http://www.dangermouse.net/esoteric/intelligentdesignsort.html
09:58:45 <lambdabot> Title: DM's Esoteric Programming Languages - Intelligent Design Sort
10:12:13 * nomeata is all in favour of rc-1’s proposal.
10:13:22 <rc-1> also, the teaching of any other way of sorting should be banned, since it would conflict with The Great Sorters plan.
10:13:58 <newsham> i sort lists by randomly swapping base pairs, i mean.. um.. elements
10:14:06 <newsham> its a sexy algorithm
10:14:34 <newsham> if not somewhat incestuous
10:15:31 <rc-1> lol
10:21:20 <vegai> Did you see the intelligent design sort?
10:22:00 <vegai> http://www.dangermouse.net/esoteric/intelligentdesignsort.html
10:22:00 <lambdabot> Title: DM's Esoteric Programming Languages - Intelligent Design Sort
10:23:57 <emu> is anyone aware of a graph-coloring algorithm library for haskell?
10:35:57 <psnl> is anyone aware of a graph colouring algorithm?
10:46:32 <astrolabe> What kind of colouring?  What kind of graph?  (and the answer to the question is no).
10:50:30 <nomeata> Hi. Is there a function with type:  (a -> [b]) -> [a -> b]
10:50:58 <nomeata> @type sequence
10:50:59 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
10:51:06 <Saizan> ?hoogle (a -> [b]) -> [a -> b]
10:51:07 <lambdabot> No matches, try a more general search
10:51:24 <nomeata> like sequence in the ((->) a) monad, just the other way around
10:51:37 <nomeata> ?hoogle m [a] -> [m a]
10:51:38 <Lemmih> Isn't that impossible?
10:51:38 <lambdabot> Prelude.repeat :: a -> [a]
10:51:39 <lambdabot> List.intersperse :: a -> [a] -> [a]
10:51:39 <lambdabot> Prelude.(:) :: a -> [a] -> [a]
10:51:42 <astrolabe> @hoogle (a -> [b]) -> [a -> b]
10:51:43 <lambdabot> No matches, try a more general search
10:51:44 <nomeata> dunno
10:52:36 <astrolabe> I think it is impossible, because what would it take (\a -> []) to?
10:52:49 <nomeata> const []?
10:52:56 <nomeata> no
10:52:57 <nomeata> []
10:53:07 <astrolabe> hmm
10:53:35 <astrolabe> yeah const [] is of the right type I s'pose
10:53:53 <fizbin> ?type (const [])
10:53:55 <lambdabot> forall a b. b -> [a]
10:53:55 <nomeata> let \f g -> [\a -> g a !! n | n [1..] ]
10:54:41 <nomeata> @type let \f g -> [\a -> g a !! n | n [1..] ] in repeat' = f (flip repeat 'a') in repeat'
10:54:43 <lambdabot> parse error on input `in'
10:54:52 <nomeata> @type let \f g -> [\a -> g a !! n | n [1..] ] in f
10:54:54 <lambdabot> parse error on input `in'
10:55:09 <nomeata> @type let \f g -> [(\a -> g a !! n) | n <- [1..] ] in f
10:55:10 <lambdabot> parse error on input `in'
10:55:15 <Saizan> @type let r = \f g -> [\a -> g a !! n | n [1..] ] in r
10:55:16 <lambdabot> Not in scope: `n'
10:55:17 <lambdabot>  
10:55:17 <lambdabot> <interactive>:1:34: Not in scope: `n'
10:55:30 <nomeata> @type let f = \g -> [(\a -> g a !! n) | n <- [1..] ] in f
10:55:31 <astrolabe> How about the function that returns the list of all functions sending a to elements of f a?
10:55:32 <lambdabot> forall t a. (t -> [a]) -> [t -> a]
10:55:59 <astrolabe> Ah :)
10:56:18 <nomeata> but that does not seem to be a good way to do it
10:56:40 <nomeata> @pl let f = \g -> [(\a -> g a !! n) | n <- [1..] ] in f
10:56:41 <lambdabot> return . (<- [1..]) . (| n) . flip flip n . ((!!) .)
10:56:48 <astrolabe> something clever with the list monad?
10:56:48 <nomeata> not much better :-)
10:57:36 <nomeata> there is no general m1 (m2 a) -> m2 (m1 a) function, is there?
10:57:38 <nomeata> @type lift
10:57:39 <lambdabot> forall (t :: (* -> *) -> * -> *) a (m :: * -> *). (MonadTrans t, Monad m) => m a -> t m a
10:59:19 <nomeata> @type let f = \g -> map (\n a -> g a !! n) [1..]  in f
10:59:21 <lambdabot> forall t a. (t -> [a]) -> [t -> a]
10:59:26 <nomeata> @pl let f = \g -> map (\n a -> g a !! n) [1..]  in f
10:59:27 <lambdabot> flip map [1..] . flip . ((!!) .)
11:02:11 <nomeata> @pl let f = \g -> map ((\a -> g a !!)) [1..]  in f
11:02:12 <lambdabot> (line 1, column 33):
11:02:12 <lambdabot> unexpected ")"
11:02:12 <lambdabot> expecting white space or simple term
11:02:17 <nomeata> @pl let f = \g -> map ((\a -> (g a !!))) [1..]  in f
11:02:18 <lambdabot> flip map [1..] . ((!!) .)
11:02:25 <nomeata> @type let f = \g -> map ((\a -> (g a !!))) [1..]  in f
11:02:26 <lambdabot> forall a a1. (Enum a, Num a) => (a -> [a1]) -> [Int -> a1]
11:05:54 <neonse> @type foldr (++) [] (map f x)
11:05:56 <lambdabot> Not in scope: `f'
11:05:56 <lambdabot>  
11:05:56 <lambdabot> <interactive>:1:21: Not in scope: `x'
11:06:04 <neonse> oops
11:07:24 <nomeata> @type \f x ->  foldr (++) [] (map f x)
11:07:26 <lambdabot> forall a a1. (a1 -> [a]) -> [a1] -> [a]
11:07:36 <nomeata> close
11:08:00 <nomeata> @type \f ->  foldr (++) [] (map f)
11:08:02 <lambdabot>   Expecting a function type, but found `[a]'
11:08:03 <lambdabot>    Expected type: [[a]]
11:08:12 <nomeata> @type \f ->  foldr (++) [] (\x -> map f x)
11:08:14 <lambdabot>   The lambda expression `\ x -> ...' has one arguments,
11:08:14 <lambdabot>   but its type `[a]' has none
11:15:31 <newsham> > sortBy (\x y -> EQ) "testing"
11:15:33 <lambdabot>  "testing"
11:17:05 <newsham> > sortBy (\x y -> toEnum ((13*(fromEnum x) + (fromEnum y)) % 3)) "testing"
11:17:06 <lambdabot>  Couldn't match `Int' against `Ratio Int'
11:17:17 <newsham> > sortBy (\x y -> toEnum ((13*(fromEnum x) + (fromEnum y)) `mod` 3)) "testing"
11:17:18 <lambdabot>  "testnig"
11:27:27 <neonse> > (\f x->foldr (++) [] (map f x))(\y->(y+2):(y+1):y:[])[1..6]
11:27:28 <lambdabot>  [3,2,1,4,3,2,5,4,3,6,5,4,7,6,5,8,7,6]
11:28:18 <SyntaxNinja> y0
11:29:50 <nomeata> @type (\y->(y+2):(y+1):y:[])
11:29:52 <lambdabot> forall a. (Num a) => a -> [a]
11:30:00 <nomeata> @type (\f x->foldr (++) [] (map f x)
11:30:02 <lambdabot> parse error (possibly incorrect indentation)
11:30:05 <nomeata> @type (\f x->foldr (++) [] (map f x))
11:30:07 <lambdabot> forall a a1. (a1 -> [a]) -> [a1] -> [a]
11:30:20 <Cale> > [1..6] >>= \k -> [k+2,k+1,k]
11:30:22 <lambdabot>  [3,2,1,4,3,2,5,4,3,6,5,4,7,6,5,8,7,6]
11:32:25 <neonse> monads win again
11:32:39 <Cale> :)
11:33:17 <Cale> > [y | k <- [1..6], y <- [k+2,k+1,k]]
11:33:19 <lambdabot>  [3,2,1,4,3,2,5,4,3,6,5,4,7,6,5,8,7,6]
11:33:45 <int-e> > liftM2 (+) [1..6] [2,1,0]
11:33:47 <lambdabot>  [3,2,1,4,3,2,5,4,3,6,5,4,7,6,5,8,7,6]
11:34:34 <newsham> > [3,2,1,4,3,2,5,4,3,6,5,4,7,6,5,8,7,6]
11:34:36 <lambdabot>  [3,2,1,4,3,2,5,4,3,6,5,4,7,6,5,8,7,6]
11:36:41 <nomeata> If I have a == map f b
11:37:00 <nomeata> Can I resolve that I have b == something?
11:37:23 <kpreid> no, because f could be const ()
11:37:55 <nomeata> but for an inversible f, it is just b == map f^{-1} a
11:38:33 <nomeata> now, is (\g -> g v) inversible for a given v? hmm. probably not.
11:39:09 <int-e> (\g -> g v) id = v
11:41:38 <newsham> > (\g -> g 5) (const 3)
11:41:40 <lambdabot>  3
11:41:46 <newsham> > (\g -> g 6) (const 3)
11:41:48 <lambdabot>  3
11:43:15 <kaol> what would be the generalisation of (x:xs) to MonadPlus? I'd need that for a MonadPlus qsort too.
11:43:48 <kaol> perhaps I should try to think about this a bit more myself first, never mind
11:43:49 <int-e> return x `mplus` xs
11:44:35 <kaol> but can I use that for pattern matching?
11:44:39 <int-e> no.
11:45:13 * kaol goes to think of the semantics of bind
11:45:42 <int-e> if you remember that Maybe is a MonadPlus instance you'll see that this kind of pattern matching won't work.
11:46:10 <int-e> (not using the monad and monadplus interfaces, that is)
11:46:27 <nomeata> @type \a2bs -> (head . a2bs) : sequence (tail . a2bs)
11:46:29 <lambdabot>   Couldn't match `a1 -> a' against `[a2]'
11:46:30 <lambdabot>    Expected type: [a1 -> a]
11:47:09 <nomeata> @type let f a2bs = (head . a2bs) : f (tail . a2bs) in f
11:47:11 <lambdabot> forall a a1. (a -> [a1]) -> [a -> a1]
11:59:59 <Excedrin> this "what features do you want in a new language" thread on reddit is interesting
12:04:33 <newsham> "whatever paul graham says we want"?
12:07:07 <psnl> no losers using it
12:09:19 <Cale> Excedrin: :)
12:13:16 <cjeris> Excedrin: two features come to mind - 1. Haskell 2. The kind of marketing power Sun put into Java
12:13:51 <newsham> be careful what you ask for
12:15:04 <Codex_> is there url for the thread on reddit?
12:15:41 <mahogny> newsham, 100 000 n00bs all joining here asking for explanations of monads. isn't it exactly what we want? :)
12:17:18 <newsham> popularity can bring all sorts of unintended consequences
12:19:22 <kaol> aw, I guess a MonadPlus qsort can't be done after all. But a MonadPlus, Functor qsort does look possible.
12:19:41 <cjeris> newsham: "New features in Microsoft Visual Haskell 2010.  1. All variables are now mutable by default." :p
12:19:58 <int-e> C# ?
12:20:10 <Vq^> @where paste
12:20:10 <lambdabot> http://paste.lisp.org/new/haskell
12:20:14 <kaol> let's make the world referentially transparent instead
12:20:40 <newsham> everything's transparent at the right frequency.
12:20:43 <int-e> and make a MonadPlus instance for it.
12:20:43 <Vq^> the paste page doesn't seem to work :/
12:20:50 <eviltwin_b> nope, still down
12:22:08 <Johan14> how to check if element is 1st 3rd 5th 7th ...  element of list ?
12:22:36 <vincenz> > take 1 . iterate (drop 2) $ [1..10]
12:22:38 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10]]
12:22:43 <vincenz> @type iterate
12:22:45 <lambdabot> forall a. (a -> a) -> a -> [a]
12:23:08 <int-e> > iterate (drop 2) $ [1..10] !! 2
12:23:09 <lambdabot>  add an instance declaration for (Num [a])
12:23:10 <lambdabot>   In an arithmetic sequence: [1...
12:23:10 <vincenz> > . takeWhile (not . null) . map take 1 . iterate (drop 2) $ [1..10]
12:23:11 <lambdabot>  Parse error
12:23:14 <Vq^> Johan14: what if the element isn't unique?
12:23:18 <vincenz> > 3 `elem` . takeWhile (not . null) . map take 1 . iterate (drop 2) $ [1..10]
12:23:18 <int-e> > (iterate (drop 2) $ [1..10]) !! 2
12:23:19 <lambdabot>  [5,6,7,8,9,10]
12:23:20 <lambdabot>  Parse error
12:23:28 <vincenz> > (3 `elem`) . concat . takeWhile (not . null) . map take 1 . iterate (drop 2) $ [1..10]~
12:23:29 <lambdabot>  Parse error
12:23:32 <vincenz> > (3 `elem`) . concat . takeWhile (not . null) . map take 1 . iterate (drop 2) $ [1..10]
12:23:33 <lambdabot>    Expecting a function type, but found `[b]'
12:23:33 <lambdabot>    Expected type: b -> c
12:23:33 <lambdabot>  ...
12:23:40 <vincenz> > concat . takeWhile (not . null) . map take 1 . iterate (drop 2) $ [1..10]
12:23:41 <lambdabot>    Expecting a function type, but found `[b]'
12:23:41 <lambdabot>    Expected type: b -> c
12:23:41 <lambdabot>  ...
12:23:43 <vincenz> hmm
12:23:49 <int-e> vincenz: what are you trying to do?
12:24:02 <Johan14> vq^ doesnt matter
12:24:16 <vincenz> duh
12:24:17 <int-e> map (take 1)
12:24:41 <vincenz> > (3 `elem` ) . concatMap (take 1) . iterate (drop 2) $ [1..10]
12:24:42 <lambdabot>  True
12:24:45 <vincenz> > (4 `elem` ) . concatMap (take 1) . iterate (drop 2) $ [1..10]
12:24:49 <lambdabot> Terminated
12:24:58 <vincenz> > (4 `elem` ) . concatMap (take 1) . takeWhile (not . null) . iterate (drop 2) $ [1..10]
12:25:00 <lambdabot>  False
12:26:28 <Vq^> > snd $ fromJust $ find ((==6) . fst) $ zip [5,7,1,6,4,5] [0..]
12:26:29 <lambdabot>  3
12:26:35 <Vq^> > snd $ fromJust $ find ((==7) . fst) $ zip [5,7,1,6,4,5] [0..]
12:26:37 <lambdabot>  1
12:26:42 <Vq^> Johan14: like that?
12:27:05 <Johan14> woh
12:27:07 <Johan14> :P
12:27:51 <Johan14> [1,2,3,4,5,6] -> [1,3,5], [2,4,6]
12:28:02 <Vq^> oh
12:31:19 <metaperl> CosmicRay isn't here .. hmm
12:35:37 <kaol> @hoogle (Functor m, MonadPlus m) => m a -> m a
12:35:38 <lambdabot> Prelude.id :: a -> a
12:35:39 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
12:35:39 <lambdabot> Prelude.asTypeOf :: a -> a -> a
12:36:05 <int-e> > transpose . unfoldr (\x -> guard (not . null $ x) >> return (splitAt 2 x)) $ [1..6]
12:36:07 <lambdabot>  [[1,3,5],[2,4,6]]
12:36:14 <metaperl> @type guard
12:36:15 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
12:36:31 <int-e> m is Maybe here
12:36:45 <Vq^> @pl (\(a,b) (c,d) -> (a++c,b++d))
12:36:48 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (++)) . flip . (((.) . (,)) .) . (++))
12:37:57 <int-e> @type transpose . unfoldr (liftM2 (>>) (guard . not . null) (return . splitAt 2))
12:37:58 <lambdabot> forall a. [a] -> [[a]]
12:38:02 <metaperl>  more flips than Nadia Comenici
12:38:41 <Codex_> @type flip flip
12:38:43 <lambdabot> forall a c b. b -> (a -> b -> c) -> a -> c
12:38:52 <Vq^> > foldr1 (\(a,b) (c,d) -> (a++c,b++d)) $ zipWith id (cycle [(return &&& const []), (const [] &&& return)]) "This is a test"
12:38:53 <lambdabot>  ("Ti sats","hsi  et")
12:40:49 <int-e> > foldr (\c (xs, ys) -> (c:ys, xs)) ([],[]) "This is a test, too"
12:40:50 <lambdabot>  ("Ti sats,to","hsi  et o")
12:41:21 <Vq^> int-e: easier to grook thought
12:46:22 <shapr> What are the best things to read if I want to learn to use GADTs for all my datatypes?
12:46:30 <shapr> Should I start with the original wobbly types in Haskell paper?
12:46:41 <swiert> shapr: no - I wouldn't
12:46:55 <shapr> What would you suggest?
12:47:03 <swiert> Maybe for a few examples - but only if you're really into the type inference stuff.
12:47:19 <swiert> Not too sure.
12:47:42 <shapr> GADTs seem to describe/document ADTs better because of the type signatures.
12:48:04 <shapr> They're easier to read for newbies, because they give constructors a type sig just like any function.
12:48:06 <swiert> The idea is simple - recognizing when a GADT makes sense can be tricky.
12:48:22 <shapr> Also, I think GADTs can be used to explicitly describe state machines somehow, but I'm not quite sure how.
12:48:23 <mbishop> yay my hp jornada 720 came in
12:49:43 <shapr> audreyt originally suggested GADT syntax on everyday ADTs for newbie comprehension, I like it.
12:50:27 <shapr> swiert: You're right, I want to see GADTs applied, the theory isn't so important to me.
12:53:26 <swiert> There aren't too many published examples that I know.
12:53:37 <swiert> They haven't been around long enough maybe.
13:09:07 <Cale> One recent cool thing which I'm actually happier with than GADTs is the fact that typeclass constraints in data declarations now mean what they should have meant all along (provided that you use the GADT-style syntax.)
13:09:51 <shapr> Can you demonstrate that?
13:10:25 <Nafai> Hey shapr
13:11:20 <shapr> hiya Nafai
13:11:30 <Vq^> http://arda.no-ip.org/prof/stdet.hs.html
13:11:32 <lambdabot> Title: Haskell Code by HsColour
13:11:52 <Nafai> What's up?
13:12:02 <Vq^> could someone give me some hints on how to avoid stack overflows in that piece of code?
13:13:50 <mwc> Vq^, if you have sufficient manna left at this turn, you could try Summon Dire Knuth
13:13:59 <Vq^> :/
13:14:27 <Vq^> i tried to profile it but the result wasn't very helpful
13:15:32 <mwc> Well, if you post a non-html-ized version, I'll have a look at the profile and see what I can suggest
13:15:38 <Vq^> oh, ok
13:15:45 <Vq^> http://arda.no-ip.org/prof/stdet.hs
13:16:37 <Cale> shapr: sure. For example, you know how before if you were to write data (Ord a) => Set a = Empty | Insert a (Set a)
13:17:08 * mux enjoys his new "work" laptop
13:17:39 <Cale> Suppose you wanted to write  delete :: a -> Set a -> Set a
13:18:46 <Cale> You couldn't actually give it that type signature, because you'd still need an Ord dictionary
13:18:47 <mwc> Vq^, my first question is why you're using a list to represent a matrix
13:18:56 * shapr blinks
13:19:38 <Cale> All that the (Ord a) in the data declaration does is to add a spurious Ord constraint to the Insert constructor
13:19:39 <mwc> Cale, so now the dictionary is associated with the data and not the functions?
13:19:51 <Vq^> mwc: i figured it was the easiest to set up
13:19:54 <Cale> So now, if you write that in the new syntax...
13:20:02 <Cale> data Set a where
13:20:09 <Cale>    Empty :: Set a
13:20:23 <Cale>    Insert :: (Ord a) => a -> Set a -> Set a
13:20:38 <mwc> Vq^, okay, I haven't really went through this, but are you being careful about each list operation (list comps, zips, etc.) being O(N) at best?
13:20:41 <Cale> Then the Ord dictionary is stored along with the Insert
13:20:57 <Vq^> mwc: well, efficiency isn't my priority here
13:20:57 <shapr> hm
13:21:05 <Cale> so when you pattern match, you get one out for free, and you don't need to add that constraint to your type signatures
13:21:32 <Vq^> mwc: in fact, the program itself or it correctness isn't a priority either
13:21:58 <mwc> Vq^, right, but building huge amounts of data structures is gonna hurt. I suppose offhand you could just increase the stack size :)
13:22:23 <Vq^> mwc: it shouldn't build a huge datastructure
13:22:34 <Vq^> mwc: it's supposed to build a small number
13:22:49 <Cale> Of course, you still need to guarantee that you have an Ord dictionary when you apply the Insert constructor in the first place.
13:22:59 <Excedrin> Cale: regarding the language feature thread on reddit, have you looked at Alice ML?
13:23:19 <jlouis> Excedrin, for some time ago. Interesting concept
13:23:31 <Cale> Excedrin: a little bit
13:23:38 <Excedrin> it's missing two things from Cale's list (monads and OO)
13:23:59 <Vq^> mwc: if the program was completely strict the maximum callstack level would be the width of the matrix
13:24:27 <Excedrin> and #4 is implemented a little differently, as integration with the gecode constraint library
13:24:28 <Cale> Those aren't features which I think all languages should have, they're things which I think that all language designers should know about when designing a language :)
13:25:21 <Excedrin> right.. I was just noting that there's some intersection between your list and other people's lists and Alice's features
13:25:27 <Cale> yeah
13:25:53 <Vq^> mwc: btw, could you recomend some profiling flags for a problem like this?
13:26:06 <Excedrin> I wrote a Sudoku solver in Alice and noticed that it's a little buggy (memory leaks), but it's interesting and has a nice GUI environment
13:27:40 <mwc> Vq^, I'm just thinking about this. Determinants are hard
13:28:22 <Vq^> mwc: yeah, and this is the "wrong" way to solve them
13:28:54 <mwc> My suggestion would be to increase your stack size to something obscene and give it another try
13:28:59 <Cale> An interesting thing someone pointed out the other day here is that the subtext guy has a new demo: http://subtextual.org/demo1.html
13:29:00 <lambdabot> Title: Subtext demo
13:29:04 <Vq^> mwc: there are much better algorithms for solving this problem but thats not important, what i'm hunting for is knowledge on how to solve these problems
13:29:26 <int-e> Cale: yes, that change is great. we can store dictionaries without having to resort to explicit existencial types now.
13:29:33 <Cale> int-e: yeah
13:30:00 <Vq^> mwc: that might work, but as i said, if strictness is applied correctly i believe it won't require much space at all
13:30:17 <jlouis> ugh! A new oleg post. Now I have to read 2 hours to understand
13:30:28 <Vq^> im thinking about writing my own semi-strict 'sequence'
13:30:43 <mwc> You might need to beat it with a few critically placed seq's once you find the bottlenecks
13:31:03 <Vq^> that will force all other branches to be fully evaluated before going down a new
13:31:03 <int-e> Cale: now all I want is a way to create dictionaries at runtime ;)
13:31:06 <astrolabe> mwc: a more traditional approach would be polynomial (cubic) rather than exponential in the matrix size, and would automatically use less stack space because of that.
13:31:07 <Cale> I actually downloaded the code for subtext and played around a bit, and the implementation appears to be pretty buggy right now, but it's sort of a neat idea. I did find it annoyingly slow to actually build things up though.
13:31:20 <astrolabe> er Vq^: I mean
13:31:33 <mwc> There's a cubic approach to finding determinants? AFAIK they're O(N!)
13:31:59 <int-e> Cale: without having to jump through hoops by encoding them into an infinite family of types with proper class instances.
13:32:03 <Vq^> astrolabe: as i said before, this is more about fixing space leaks than implementing the function
13:32:08 <astrolabe> Do a QR decomposition, that's O(n^3) I believe.
13:32:31 <Vq^> astrolabe: i know this is a terrible way to do it, thats why i wanted to test it :)
13:32:54 <Vq^> thats also why i got a 'State Int a', to count the operations
13:33:02 <astrolabe> Vq: righto
13:33:41 <mwc> astrolabe, so then the R part has an easy to calculate determinant, how do you handle Q?
13:33:56 <astrolabe> Q is a rotation, so has determinant 1.
13:33:58 <int-e> it has determinant 1.
13:34:16 <mwc> right, right, it's orthonormal, not just orthogonal
13:34:18 <astrolabe> or if you use householder transformations, it could be -1, but it is easy to get.
13:34:36 <chessguy> Jonathan Edwards, where do i know that name from?
13:34:49 * mwc fishes around for first year linear algebra text
13:34:51 <astrolabe> The terminology is a bit funny for matrices I think, and varies between disciplines.
13:34:57 <mwc> chessguy, isn't Jon Edwards that TV psychic
13:35:18 <chessguy> dunno, his name's on this subtext thing
13:36:00 <astrolabe> In pure maths I was taught that an orthogonal matrix satisfies AA^T=I, but a better name might be orthonormal, and I know that's what engineers where I work call them.
13:36:14 <mwc> astrolabe, well, I forgot you have to have Q with orthonormal columns, I was thinking they were just orthogonal. Now that I think about it, you find Q and then do R = transpose(Q)*A to find R.
13:36:26 <mwc> astrolabe, right, applied mathematicians teach the engineers, so we have similar terms
13:37:29 <mwc> but the textbook didn't differentiate between orthogonal and orthonormal (columned) matrices.
13:37:36 * mwc experiences Linear Algebra 040 flashbacks
13:38:12 <astrolabe> mwc: I think you have to calculate R as you go along, but I'm being picky :)
13:38:25 <astrolabe> Oh, no, you don't.  Sorry.
13:38:40 <mwc> R = Qt A => QR = Q Qt A = A
13:38:51 * astrolabe checks the terminology on wikipedia
13:38:53 <newsham> PV = nRT
13:39:04 <newsham> (ideally)
13:39:16 <astrolabe> E = mc^2
13:39:39 <newsham> e^2 = p^2 c^2 + m^2 c^4
13:39:45 <mwc> newsham, I had to derive that from partition function last year in thermo. But that's all OT
13:40:08 <newsham> OT?
13:40:36 <koffein_> offtopic?
13:41:12 <newsham> oh.
13:41:21 <newsham> you're right sir.  *idles*
13:41:37 <Vq^> ?
13:42:26 * Vq^ gets the feeling he should read more LA
13:45:24 <defcon8> hello
13:45:42 <astrolabe> hello
13:48:39 <defcon8> bloody hell, cafepress doesn't take solo debit card :(
13:49:19 <defcon8> anyone know some proper haskell merchandise stores?
13:49:58 <norpan> debit card? not visa?
13:50:09 <chessguy> man, this subtext thing is taking forever to download
13:50:35 <defcon8> naah, not visa
13:50:39 <defcon8> I'm not old enough :)
13:50:39 <Nafai> I watched the subtext demos yesterday and I admit I didn't get it
13:50:56 <defcon8> I've always wanted a haskell t-shirt and now I'll never be able to get one
13:50:59 <defcon8> well, not for two years
13:51:29 <Excedrin> this Terracotta stuff is pretty cool; I wonder if CAL works on it
13:51:34 <eviltwin_b> can't get one of those rechargeable mastercruds at a drugstore?
13:52:04 * eviltwin_b keeps considering doing so to work around a stupidity with some vendors' visa interfaces
13:52:28 <defcon8> anyone help?
13:53:37 <Excedrin> hahaha, "80% of new apps are written on the Java language"
13:53:50 <mbishop> "solo" debit cards?
13:53:54 <defcon8> yeah
13:54:01 <defcon8> it's a UK bullshit debit card thing
13:54:02 <mbishop> Excedrin: god help us all
13:55:04 <nornagon> ?pl \f g -> filter f . map g
13:55:05 <lambdabot> (. map) . (.) . filter
13:55:10 <nornagon> eek.
13:55:23 <defcon8> no haskewll t-shirts on ebay either
13:55:33 <nornagon> ?pl \f g l -> filter f (map g l)
13:55:33 <lambdabot> (. map) . (.) . filter
13:55:39 <nornagon> blah.
13:55:44 <nornagon> that sure is horrible.
13:55:56 <kpreid> multiple parameters are hard for pl
13:56:09 <nornagon> is there a better way to do that?
13:56:30 <kpreid> myself I'd stick with the \f g
13:56:51 <nornagon> right, but this is an exercise out of YAHT i'm trying to figure out :)
13:57:36 <kpreid> @unpl ((flip filter .) .) . map
13:57:37 <lambdabot> (\ h k n c -> filter c (map h k n))
13:57:46 <kpreid> @unpl (flip filter .) . map
13:57:46 <lambdabot> (\ g j c -> filter c (map g j))
13:57:53 <agocorona> what is the best editor for Haskell?
13:57:56 <kpreid> @unpl flip $ (flip filter .) . map
13:57:57 <lambdabot> (\ j -> ((\ a b c -> a c b) $ \ g m f -> filter f (g m)) (map j))
13:58:04 <kpreid> aieee
13:58:10 <kpreid> @unpl flip ((flip filter .) . map)
13:58:11 <lambdabot> (\ b c f -> filter f (map c b))
13:58:23 <kpreid> @unpl (flip filter .) . flip map
13:58:23 <lambdabot> (\ j m c -> filter c (map m j))
13:58:42 <kpreid> @unpl (flip (.)) (flip filter .) (flip map)
13:58:43 <lambdabot> (\ f m -> map m (\ p i -> filter i (f p)))
13:58:47 <kpreid> @unpl (flip (.)) (flip filter .) map
13:58:47 <lambdabot> (\ f -> map (\ m i -> filter i (f m)))
13:58:50 <kpreid> I quit
13:59:21 <astrolabe> Did anyone actually do the 'which part of  <the Hindley Milnor type system> do you not understand' tee-shirt, or was that just a myth?
13:59:35 <chessguy> hmm. doesn't look like this subtext thing would scale very well
13:59:37 <kpreid> yes, someone did
13:59:45 <nornagon> kpreid: heh.
13:59:56 <mbishop> astrolabe: yeah it's on cafepress
13:59:57 <psnl> astrolabe: http://www.cafepress.com/skicalc.6225368
14:00:13 <nornagon> ?hoogle join
14:00:14 <lambdabot> Monad.join :: Monad a => a (a b) -> a b
14:00:14 <lambdabot> Control.Monad.join :: Monad m => m (m a) -> m a
14:00:14 <lambdabot> Data.PackedString.joinPS :: PackedString -> [PackedString] -> PackedString
14:00:20 <kpreid> @unpl flip . (flip filter .) . map
14:00:21 <lambdabot> (\ j b c -> filter b (map j c))
14:00:37 <kpreid> there we go. add one flip if you insist on the function order
14:00:53 <astrolabe> cool: thanks
14:01:10 <nornagon> no wonder i was having trouble :P
14:01:23 <kpreid> also, I see I forgot to tell @unpl about ($)
14:01:27 <nornagon> @unpl flip (flip . (flip filter .) . map)
14:01:28 <lambdabot> (\ b c f -> filter b (map c f))
14:02:20 <astrolabe> heh: now I just need to work out if that is too pretentious to wear.
14:02:34 <kpreid> removing $ isn't especially a pointification, but without that it can't simplify $-applications
14:02:43 <kpreid> @unpl (flip . flip) id
14:02:44 <lambdabot> (\ b c -> b c)
14:02:47 <kpreid> @unpl flip . flip $ id
14:02:48 <lambdabot> ((\ j b c -> j b c) $ \ g -> g)
14:03:39 <wchogg> astrolabe:  I think it's definitely very pretentious.  The tone of the shirt comes across as "I'm smarter than you".
14:04:41 <wchogg> That's why I like the t-shirt that says "There are 10 kinds of people in the world:  those that understand binary, and those that have friends"  Self-efacing yet geeky.
14:05:40 <therp> I actually wanted to order some fix point combinator t-shirts, but then this web form for setting your t-shirt text would not accept λ
14:05:47 <kpreid> hm.
14:06:08 <kpreid> speaking of fixpoint, @unpl's definition of fix doesn't work in Haskell's type system, or is just broken
14:06:17 <kpreid> is there one that does, that doesn't use let?
14:07:00 <kpreid> (or should @unpl just not touch fix?)
14:07:26 <chessguy> Cale, what do you like using subtext for?
14:07:49 <Saizan> kpreid: (a a) leads to an infinite type so..
14:08:17 <kpreid> Saizan: exactly. so what should I do about it?
14:09:45 <Saizan> i suppose nothing, Y in that form works only in untyped lambda i suspect
14:10:07 <kpreid> I don't care about that form!
14:10:32 <kpreid> I just had the idea that @unpl should eliminate fix. should it not do so, or is there another form which it can and should use?
14:11:11 <emu> ?pl \p -> do v <- arbitrary; return (v, p)
14:11:12 <lambdabot> (line 1, column 24):
14:11:12 <lambdabot> unexpected ";"
14:11:12 <lambdabot> expecting letter or digit, variable, "(", "`", "!!", ".", operator or end of input
14:11:34 <mbishop> When can I expect haskell for strongarm? :o
14:11:44 <emu> ?pl \p -> (do v <- arbitrary; return (v, p))
14:11:44 <kpreid> ?. pl undo \p -> do v <- arbitrary; return (v, p)
14:11:44 <lambdabot> (line 1, column 25):
14:11:44 <lambdabot> unexpected ";"
14:11:44 <lambdabot> expecting letter or digit, variable, "(", "`", "!!", ".", operator or ")"
14:11:45 <lambdabot> (`fmap` arbitrary) . flip (,)
14:12:04 <EvilRanter> ?pl \p -> do v <- undefined; return (v, p)
14:12:04 <lambdabot> (line 1, column 24):
14:12:05 <lambdabot> unexpected ";"
14:12:05 <lambdabot> expecting letter or digit, variable, "(", "`", "!!", ".", operator or end of input
14:12:17 <kpreid> emu, EvilRanter: pl doesn't understand do syntax, you have to use undo
14:12:33 <EvilRanter> @undo?
14:12:34 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 2, srcColumn = 1}) "Parse error"
14:12:48 <kpreid> @undo do x; y
14:12:49 <lambdabot> x >> y
14:12:50 <EvilRanter> ?type arbitrary
14:12:52 <lambdabot> Not in scope: `arbitrary'
14:22:36 <Cale> chessguy: I haven't used it for anything, I played around with it a bit
14:22:51 <Cale> chessguy: It's not usable at the moment. The implementation is quite buggy.
14:23:25 <Cale> But it has some interesting ideas there. I think the lack of higher-level abstractions makes it a bit of a pain to really use though.
14:24:16 <emu> ok
14:30:32 <jeroeng> What should one do when '<interactive>:1:2:ghc-6.4.1: panic! (the `impossible' happened, GHC version 6.4.1):' appears?
14:31:07 <sjanssen> cry
14:31:28 <sjanssen> then make sure there aren't any problems with your GHC installation (try reinstalling perhaps)
14:32:04 <sjanssen> and finally, file a GHC bug report after you've narrowed the problem down as much as possible
14:32:18 <jeroeng> Oh it definately is my code that's causing it, since changing the code makes the message go away.
14:32:30 <pejo> jeroeng, the compiler shouldn't crash, regardless of what you input.
14:32:40 <sjanssen> jeroeng: is the code short enough to paste?
14:32:42 <sjanssen> @where paste
14:32:43 <lambdabot> http://paste.lisp.org/new/haskell
14:32:44 <jeroeng> Being quite new to this, how do I file a good bug report?
14:33:02 <jeroeng> sjansen, yes, and I know exactly what is causing it, I guess
14:33:04 <pejo> But it might be worth trying a more recent 6.4 version, or 6.6, atleast before filing the bug report.
14:33:19 <sjanssen> jeroeng: also, please try your program with GHC 6.4.2
14:33:50 <sjanssen> or, if you paste, I can try it with GHC 6.6
14:33:51 <jeroeng> I was using template haskell, and made two lambda-abstraction over the same variable, which is wrong
14:34:20 <jeroeng> sjanssen: Is 6.6 available in some debian/ubuntu repository?
14:35:01 <sjanssen> I believe there's a debian repository somewhere, I've got no idea where
14:36:26 <Saizan> err, how do i fill this depency? "Setup.hs: cannot satisfy dependency plugins-any" is referring to hs-plugins?
14:37:41 <jeroeng> sjanssen: The method mentioned on http://www.haskell.org/ghc/download_ghc_66.html#debian gets me 6.4.1
14:37:42 <lambdabot> Title: GHC: Download version 6.6
14:38:17 <newsham> hmm.. wonder if arrows could be used to specify flows in a webapp.
14:38:24 <newsham> arrow notation would make the flow pretty readable
14:38:34 <jlouis> jeroeng, for Debian unstable/sid its been there for some time
14:39:02 <jeroeng> Which repository is that, jlouis?
14:39:17 <jlouis> you mean deb-repository?
14:39:29 <jeroeng> Yup
14:40:09 <jlouis> Let me find my line...
14:40:28 <jlouis> deb http://ftp.dk.debian.org/debian/ sid main non-free contrib
14:40:30 <lambdabot> Title: Index of /debian
14:40:31 <jlouis> somewhere in there
14:40:42 <jlouis> note its the unstable/sid tree though
14:40:55 <jlouis> and you might end up pulling a lot of dependencies to make it work
14:41:15 <jlouis> I don't know how the Ubuntu is faring. Its only Ubuntu at work
14:43:57 <jeroeng> Thanks jlouis
14:44:31 <jlouis> jeroeng, are you running stable?
14:44:49 <jlouis> then its almost sure death to put that line inside /etc/apt/sources.list?
14:45:01 <jeroeng> I noticed :P
15:09:36 <agocorona> Just a Question: all the haskeel Data.Xxxxx types are thread safe?
15:09:54 <agocorona> form example Data.HashTable
15:10:00 <dons> yeah
15:10:19 <agocorona> ok, fine
15:10:21 <dons> or you can wrap them in an MVar if you're worried
15:10:47 <agocorona> thats what I want to know to avoid something that the language does for me
15:12:39 <agocorona> Data.Map is   faster that Data.HashTable at lookup?
15:14:11 <sjanssen> agocorona: there have been certain performance problems in Data.HashTable in the past.  I'm not sure how well the latest version performs
15:14:38 <agocorona> i heard about that, yes
15:14:58 <sjanssen> Data.HashTable ties you to IO, so there's another strike against it
15:16:04 <agocorona> sjanssen, but Data.Map has to be regenerated on every update! this is not good for large data sets i guess....
15:16:16 <jlouis> Unless you have a performance bottleneck a HashTable is definitely going to solve, I would not let that viral IO get me. I'd go for a Data.Map
15:16:48 <jlouis> agocorona, it only replaces the path from the insertion point to the root
15:17:50 <agocorona> so Data.Map just play with the pointers when updated?. then, why Data.HashTable?
15:18:36 <jlouis> A HashTable has different properties, so it might be better for some kinds of access patterns
15:20:06 <jlouis> I am wary of saying this in a Haskell forum, but in the imperative world, A hash table often beats the crap out of a tree if the lookup ratio is far greater than the update ratio. The primary reason is cache.
15:20:18 <jlouis> In Haskell, I am pretty sure that thing doesn't hold
15:20:29 <agocorona> I can not figure out how a Map can maintain referential transparency just updating the pointers when updated...
15:20:36 <jlouis> or rather
15:20:43 <jlouis> I am unsure if anything like that holds
15:20:56 <jlouis> its persistent
15:21:58 <dons> agocorona: same way as a list can be.. but with more ptrs
15:22:04 <jlouis> it replaces all nodes on the path from the inserted node to the root with a new (allocated) node and reuses all parts of the tree structure that doesn't change.
15:22:07 <dons> ?source Data.Map
15:22:07 <lambdabot> http://darcs.haskell.org/packages/base/Data/Map.hs
15:22:10 <dons> ^^check the src
15:22:16 <dons> ?source Data.IntMap
15:22:16 <lambdabot> http://darcs.haskell.org/packages/base/Data/IntMap.hs
15:22:18 <dons> even faster ^^
15:22:50 <jlouis> and the cool thing about this is that you can still reference the old copy. And it will work correctly
15:23:59 <agocorona> jlouis, so the Map does something like " versioning", because other code that references the same map would not detect any change, to keep the ref. transp.
15:24:29 <agocorona> ok
15:25:09 <jlouis> agocorona, yes, I think you have a grasp of the idea
15:25:12 <agocorona> this is very important for programmers to reason about performance
15:26:50 <jlouis> agocorona, and correctness. Its much easier to prove something correct with persistent datastructures
15:27:05 <agocorona> I note that, for example O`Caml people are more aware of how the compiler handles the data. Even it is so in Clean, but in Haskell the empashis on that is lesser
15:28:09 <agocorona> Thanks for the info
15:28:30 <jlouis> OCaml (and SML) are Eager. They are different beasts
15:29:05 <conal> could i get some cabal+haddock help?  i'm getting the following message when i do "runhaskell Setup.hs haddock" on monadLib:
15:29:05 <conal> Warning: cannot use package base-2.0:
15:29:05 <conal>    HTML directory $topdir\html\libraries\base does not exist.
15:30:09 <jlouis> conal, it seems it tells you that it cannot find the base library documentation
15:30:31 <conal> jlouis.  i do have c:/ghc/ghc-6.6/doc/html/libraries/base/.  is there some way i can let cabal know how to find it?
15:30:32 <wy> Hi all
15:30:40 <eviltwin_b> you don't have the haddock docs installed, or they're in the wroing place.  so haddock won't be able to link to them.
15:31:03 <wy> Has anyone here studied the type system of Haskell? I wonder if it is using let-polymorphism now?
15:31:07 <jlouis> conal, I don't know actually
15:31:45 <conal> jlouis: okay, thanks.
15:31:50 <conal> anyone else know?
15:32:06 <agocorona> but I had the gasp about why overloading funcitions are slower in Haskell by reading OCaml documentation about performance..
15:32:11 <jlouis> wy, let-poly? I don't know what that is. But I am curious ;)
15:33:42 <jlouis> wy, ah, wikipedia is explaining
15:35:22 <jlouis> oh, wikipedia is not explaining
15:35:57 <conal> eviltwin_b: do you know where haddock looks for  the docs, i.e., where "topdir" is in that error message?
15:37:12 <eviltwin_b> nope, not even on unix.
15:37:20 <wy> jlouis: well. I'm just curious it can type the expression. (\f->if (f True) then (f 3) else (f 4)) (\x->x)
15:39:25 <newsham> hrmm...  http://hackage.haskell.org/trac/hackage/ticket/102
15:39:27 <lambdabot> Title: #102 (building haddock for executables wont CPP) - Hackage - Trac
15:39:38 <newsham> haddock isnt intended to document binaries, just libs?
15:40:03 <wy> jlouis: Well, it worked before. But it doesn't work now.
15:46:40 <dons> ?users
15:46:41 <lambdabot> Maximum users seen in #haskell: 276, currently: 263 (95.3%), active: 39 (14.8%)
15:47:00 <dons> newsham: yeah, basically. but it should!
15:50:31 <newsham> sounds like push-back to me :(
15:52:26 <dons> the problem is that cabal doesn't want to build haddocks for executables
15:52:32 <dons> its a one line fix to cabal, i think...
15:52:51 <dons> you can always run haddock by hand, of course. or use the 'its a library too!' fix I suggested
15:52:57 <dons> or ... have a look a tthe cabal src
15:53:42 <jlouis> wy, ah you want stuff like that. Take a look at http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html. I tried for a couple of minutes to cook up an example, but the type system fights me
15:53:45 <lambdabot> Title: 7.4. Type system extensions, http://tinyurl.com/uxvor
15:53:51 <kpreid> dons: sent you a couple of pointful patches
15:54:23 <dons> got it and building
15:54:55 <dons> wy, if you've got a type puzzle, a good place to ask is haskell-cafe@. the community loves figuring out tricksy type games
15:55:13 <dons> starting with turing machines on the type level, and ending I don't know where...
15:57:48 <newsham> i'm using the "its a library" workaround.
15:57:59 <newsham> but i still want a fix :)
15:59:32 <jlouis> dons, exactly. We don't have any grue on the haskell-cafe@ list. But we _do_ have an oleg
16:00:09 <wy> dons: I'm just trying to do an extension to my homework, implementing a more powerful type inference than let-polymorphsim. But later I found that it doesn't work for some examples. I began to wonder if let-polymorphism is all we can do.
16:00:55 <pzpz> How do IORefs/Ptrs impact Haskell's "pureness" ?
16:00:59 <newsham> working on homework after its due?  tsk tsk
16:01:32 <newsham> pzpz: they're in the IO monad which treats em like functions on the real world.
16:01:43 <dons> pzpz: you have to use them in a monad, then the encapsulated code remains referentially transparent (for Refs), for Ptrs, you are in a moand, and can do untold IO-monad evil
16:02:19 <pzpz> Gotcha.
16:02:20 <dons> pzpz: they're not damaging, they just require sequencing for them to make sense, hence they're wrapped in a monad
16:02:33 <jlouis> untold monad evil?? can you say necromancy?
16:03:05 <pzpz> as long as my computer stays dead, I'm happy.
16:03:43 <ozone> that quote has gotta be in hwn
16:04:25 <Philippa> wy: Haskell uses let polymorphism as part of the inference process, yes. It also has several extensions, type classes being a notable one
16:05:11 <jlouis> Sorry for being unknowing, but what is the similarity between System F and let-poly.?
16:05:21 <wy> Philippa: But it still can't derive the type of (\f->if (f True) then (f 3) else (f 4)) (\x->x). I'm wondering if this can be made possible
16:07:22 <Pseudonym> ?unpl test . (.) f
16:07:36 <Saulzar> If f True forces the f to be of type Bool -> Bool ...
16:07:48 <wy> jlouis: System F is from church-style lambda calculus. You have to write explicitly the types
16:07:49 <lambdabot> (\ g -> test (\ c -> f (g c)))
16:08:16 <Philippa> and you /have/ to explicitly supply at least some, because full type inference on it's undecidable
16:08:18 <dons> ?pl (\ g -> test (\ c -> f (g c)))
16:08:19 <lambdabot> test . (f .)
16:08:22 <dons> great
16:08:33 <dons> ?uptime
16:08:33 <lambdabot> uptime: 1m 41s, longest uptime: 9d 2h 23m 6s
16:08:35 <dons> ?users
16:08:35 <lambdabot> Maximum users seen in #haskell: 276, currently: 257 (93.1%), active: 5 (1.9%)
16:08:38 <Philippa> I forget whether the rank-2 fragment's doable
16:08:58 <Philippa> either predicative or impredicative
16:09:09 <jlouis> wy, Philippa: Yes I know that. But what is let-polymorphism then? I searched via google, but all that shows up are some ML papers on siteceer
16:09:18 <wy> Philippa: I still haven't realized why it's undecidable.
16:09:50 <Philippa> jlouis: it's where you use let to give you a boundary to generalise at
16:10:02 <Pseudonym> An example might help here.
16:10:39 <Pseudonym> The problem is that you need to assign a type to, say, f, without seeing all of the uses of f.
16:10:54 <kpreid> dons: I hope that removing fix will have made @unpl no longer give incorrect results
16:11:03 <Philippa> except if you've got a let fixing its scope, you can see them all
16:11:12 <Pseudonym> True.
16:11:15 <jlouis> ah
16:11:25 <Pseudonym> But in the case of a module export, you don't.
16:11:37 <Pseudonym> A Haskell program is logically one expression:
16:11:42 <Pseudonym> let { top-level definitions } in main
16:11:47 <Pseudonym> Or something./
16:11:48 <jlouis> so if f is let-bound inside another function, g say, and you can see all its uses, then you may be able to type it
16:11:55 <Pseudonym> Yes.
16:12:02 <Pseudonym> But what if you can't see all of its uses?
16:12:32 <Pseudonym> Damas and Milner proved that in the HM type system, f has a "most general type".
16:12:55 <jlouis> ok, and that is what is obtained by generalization via the HM-algorithm?
16:12:58 <Pseudonym> And you find it by type checking f, then adding foralls at the top level.
16:13:01 <Pseudonym> Bingo.
16:13:13 <wy> Pseudonym: Any suggestions about a reference to the HM type system?
16:13:15 <Philippa> jlouis: generalisation is where all the type variables you hadn't fixed during inference get forall-bound
16:13:21 <Philippa> TaPL's goo
16:13:22 <Philippa> *good
16:13:29 <Philippa> TaPL's a good starting point generally, in fact
16:13:36 <Pseudonym> TaPL is very good.
16:13:45 <jlouis> Philippa, yup, that makes perfectly sense.
16:14:18 <mbishop> TaPL?
16:14:27 <Pseudonym> Types and Programming Languages
16:14:35 <Pseudonym> Pierce
16:14:38 <jlouis> Benjamin C. Pierce
16:14:42 <mbishop> oh yeah
16:14:42 <jlouis> **5's Pseudonym
16:14:55 <jlouis> I should probably buy that book
16:14:58 <Pseudonym> http://ttic.uchicago.edu/~pl/classes/CMCS321-Fall06/lectures/damas-milner.pdf
16:15:01 <lambdabot> http://tinyurl.com/ujtuc
16:15:07 <Pseudonym> Go ahead and read that paper, too.
16:15:20 <Pseudonym> It's surprisingly readable.
16:15:30 <jlouis> I had it in my hand, but was in Scheme hiatus at that moment so I though "ooow, ugly type systems. go away!"
16:15:35 <jlouis> thuoght
16:15:38 <Pseudonym> Also check out Simon PJ's book.
16:15:51 <jlouis> Which one?
16:15:56 <Pseudonym> http://ttic.uchicago.edu/~pl/classes/CMCS321-Fall06/lectures/damas-milner.pdf
16:15:58 <Pseudonym> Errr.
16:15:58 <lambdabot> http://tinyurl.com/ujtuc
16:16:03 <Pseudonym> http://research.microsoft.com/~simonpj/papers/slpj-book-1987/index.htm
16:16:05 <Pseudonym> That one.
16:16:06 <lambdabot> Title: The Implementation of Functional Programming Languages, http://tinyurl.com/fvgtw
16:16:26 <Pseudonym> The chapter on type checking is very good.
16:16:53 <jlouis> SPJ's book is about lazy languages mostly?
16:16:58 <Pseudonym> Yes,
16:17:01 <dons> whoa, ok, SimonM++ make -j10 > /dev/null  1015.77s user 155.19s system 249% cpu 7:49.50 total
16:17:04 <jlouis> I know most of the Tiger book outside and in
16:17:06 <dons> (ghc in under 8 minutes!)
16:17:07 <Pseudonym> But the type checking bit applies to ML too.
16:17:16 <Pseudonym> Ah, well.  If you've got the Tiger book...
16:17:21 <Pseudonym> Well, the ML version, at least...
16:17:34 <jlouis> The ML Version
16:17:35 * mbishop is going to buy http://www.amazon.com/Haskell-Craft-Functional-Programming-2nd/dp/0201342758/sr=1-1/qid=1165277582/ref=pd_bbs_sr_1/102-2163331-0678548?ie=UTF8&s=books
16:17:38 <lambdabot> http://tinyurl.com/yxc2ub
16:17:39 <Pseudonym> Cool.
16:17:50 <Pseudonym> The C and Java versions make more sense if you translate the code back into the original ML.
16:17:54 <jlouis> I come from the SML world
16:18:07 <Pseudonym> And I assume you have the final version, not the "basic techniques" version.
16:18:09 * mbishop likes ML, but not SML heh
16:18:15 <jlouis> So I can juggle the ML-style functors pretty easily
16:18:46 <jlouis> Pseudonym, if the final version includes the SSA-form, Lengaur Tarjan etc, then yes
16:18:52 <Pseudonym> Yeah.
16:19:09 <Pseudonym> The tiger book is nice, and long overduie.
16:19:09 <jlouis> I need to buy TaPL
16:19:26 <Pseudonym> The dragon book has been the workhorse of compiler development for 20 years.
16:19:30 <Pseudonym> Probably 25 now.
16:19:41 <wy> What's the Tiger book?
16:19:42 <jlouis> ah, yes.. the Dragon is also here
16:19:46 <Pseudonym> And just about every compiler you can get uses many techniques not in the dragon book.
16:19:58 <jlouis> wy, Andrew C. Appel - Modern compiler generation in ML
16:20:02 <Pseudonym> The dragon book doesn't cover colouring register allocation, bottom-up code generation...
16:20:04 <jlouis> there is a tiger on the cover...
16:20:08 <Pseudonym> SSA form, lazy code motion...
16:20:20 <Pseudonym> Partial redundancy elinimation...
16:20:28 <Pseudonym> Code scheduling, dcache/icache optimisation...
16:20:29 <jlouis> well, most of the cool reg. alloc stuff was done in 90's
16:20:42 <dons> anyone know if this guy hangs out here, http://pozorvlak.livejournal.com/35930.html
16:20:43 <lambdabot> Title: pozorvlak: On Haskell
16:20:45 <dons> ?
16:20:46 <jlouis> the Tiger doesn't do PRE either
16:20:46 <Pseudonym> All very important these days, and none if it is in the dragon book.
16:20:53 <dons> (he says he spoke to Duncan, so maybe... ?)
16:20:56 <Pseudonym> Sure, but it covers SSA form.
16:21:02 <jlouis> indeed
16:21:06 <jlouis> SSA-PRE is evil
16:21:17 <dons> Mitchnik's book is maybe a bit more relevant these days
16:21:32 <Pseudonym> Mitchnik's book is brilliant.
16:21:41 <Pseudonym> That plus Appel and you feel like you can do anything,.
16:21:43 <dons> it has PRE, but still, if you're implementing GHC, you'd start with Appel, and then read papers
16:22:03 <jlouis> GHC and friends seems very different
16:22:12 <mbishop> dons: what book do you recommend for learning haskell?
16:22:19 <dons> compilation via transformation, jlouis :)
16:22:19 <jlouis> I had my score of AHA! moments when reading about the tagless-spineless
16:22:23 <Pseudonym> jlouis: In that case, get Appel's "compiling with continuations".
16:22:41 <dons> mbishop: hmm. learning? something from the textbooks page. it depends on your hacker level, I guess
16:22:41 <Pseudonym> Actually, the tiger book is more useful for a G-machine or GRIN-based compiler.
16:22:58 <dons> there's lots of good intro books (Craft of FP, for exampel)
16:23:01 <Pseudonym> The STG paper really glosses over the actual code generation.
16:23:11 <mgsloan> mbishop - also depends on interests.  I like that one media focused one
16:23:12 <wy> jlouis: Is it "Modern compiler implementation in ML : basic techniques / Andrew W. Appel."?
16:23:15 <dons> but i'm holding out for the smp+stm concurrent web server-as-an-example haskell book
16:23:21 <jlouis> wy, yup
16:23:35 <Pseudonym> No!
16:23:36 * mgsloan likes books that aren't dry
16:23:40 <Pseudonym> That's the "basic techniques" one.
16:23:45 <jlouis> Andrew C. Appel .. close... it rhymes
16:23:48 <Pseudonym> Get the one that came after that.
16:23:49 <jlouis> oh, doh
16:23:54 <jlouis> I should really read
16:24:02 <jlouis> sorry
16:24:08 <Pseudonym> "Modern Compiler implementation in ML".
16:24:12 <Pseudonym> No further qualifications.
16:24:21 <Pseudonym> http://www.cs.princeton.edu/~appel/modern/ml/
16:24:23 <lambdabot> Title: Modern Compiler Implementation in ML
16:24:37 <mbishop> mgsloan: yeah, I wasn't sure about that one, (SOE) or craft of funtional programming
16:24:42 <dons> mbishop: free books:
16:24:45 <dons> ?where plbook
16:24:45 <lambdabot> http://www-2.cs.cmu.edu/~rwh/plbook/
16:24:47 <dons> is good
16:24:56 <mbishop> dons: yeah, but I hate reading on a monitor :)
16:25:35 <mgsloan> mbishop - yeah.  SOE.  It's good, but if you prefer something more textbooky the other one might be right (though i've never looked at it - i had to make the same decision you're making)
16:25:48 <CosmicRay> dons: do you think the sequence is any faster today?
16:25:53 <wy> Pseudonym: You mean they are two different books?
16:26:36 <jlouis> Pseudonym, so to conclude. Let-poly is where you allow special abstraction of a let-bound you know the scope of and specifically _not_ take the most-general variant?
16:26:45 <Pseudonym> wy: Yes.
16:27:00 <wy> Pseudonym: I'm confused...
16:27:09 <Pseudonym> "Basic techniques" was a work-in-progress designed to be a simpler textbook.
16:27:20 <Pseudonym> Useful for an undergraduate course.
16:27:23 <dons> CosmicRay: i'm getting a connect refused msg...
16:27:32 <Pseudonym> The full version is the Dragon book replacement.
16:27:43 <wy> Pseudonym: I see. Are they by the same author?
16:27:48 <Pseudonym> Yes.
16:27:50 <CosmicRay> dons: ah, your dns likely has an old ip address cached
16:27:58 <CosmicRay> I moved my server to new hosting
16:28:09 <CosmicRay> (the whole thing, not just sequence)
16:28:14 <Pseudonym> jlouis: Errr... with let-polymorphism, you do construct the most general type.
16:28:26 <CosmicRay> but that's odd, TTL on the domain is 5m...
16:28:30 <Pseudonym> And when you use the function inside the "in" part, you instantiate the type.
16:28:43 <Pseudonym> Substituting skolem variables for the forall-bound bits.
16:29:18 <dons> CosmicRay: ok. good
16:29:22 <wy> Ah.. also in Java
16:29:31 <dons> .au seems a bit slow on the dns, i've noticed in the past when people's servers changed
16:29:42 <Pseudonym> wy: The Java code is hand-translated from the ML code.
16:29:57 <Pseudonym> The C code is too, only it looks even worse in C than in Java.
16:30:08 <wy> Pseudonym: I see. I haven't the full one in our library
16:30:12 <Pseudonym> Ah.
16:30:16 <jlouis> Pseudonym, aha! That nails it
16:30:22 <Pseudonym> OK, well the basic technique book is a great read.
16:30:26 <Pseudonym> I just wouldn't buy it.
16:31:02 <mgsloan> does TaPL hit dependent types and the like?
16:31:07 <Pseudonym> jlouis: let-polymorphism is what makes Hindley-Milner NP-hard.
16:31:20 * psnl rolls his eyes
16:31:20 <Pseudonym> Well... Damas-Milner, anyway.
16:31:28 <araujo> If looking for a good Haskell book, the Bird book.
16:31:50 <jlouis> I should really take more PL courses. After all we have both Henglein and Filinski as teachers
16:32:22 <jlouis> Henglein is brilliant as a teacher
16:32:43 <dons> anyone have a > 4 core linux machine?
16:32:44 <psnl> most of the time, NP-hard isn't that relevent. ATiTaPL discusses this wrt to ML type system
16:33:05 <mbishop> araujo: Haskell Primer?
16:33:21 <araujo> mbishop, Introduction to Functional Programming
16:33:37 <Pseudonym> Right.
16:33:47 <Pseudonym> Oh, I'm not saying it's a problem in practice.
16:34:03 <Pseudonym> In particular, it's not a problem at all if you slap type annotations on anything top-level.
16:34:15 <mbishop> araujo: ahh, Richard Bird :)
16:35:36 <araujo> mbishop, there is only one Truth Bird ;-)
16:35:43 <wy> jlouis: Who's Henglein?
16:36:00 <jlouis> wy, Fritz Henglein
16:36:18 <Pseudonym> Bird and Wadler sounds like a kids' TV show.
16:36:28 <jlouis> wy, I think he made some great contributions to HM around 1993 or so
16:36:37 <mbishop> Hmm, I think I've got a bunch of different answers for what's a good book for learning haskell and functional programming heh
16:36:54 <wy> jlouis: Great! You are taking his course?
16:37:35 <jlouis> wy, sadly no. He and Filinski are running type courses this fall/winter. I got tangled up in Algebraic topology instead
16:39:01 <wy> jlouis: So it seems (\f->if (f True) then (f 3) else (f 4)) (\x->x) is not that easy to type... I almost thought I beat the let-polymorphism.
16:39:39 <wy> jlouis: It seems Europeans are good at these things
16:39:42 <jlouis> do you mean type-infer or type-check?
16:40:39 <jlouis> wy, I just think they have had a longer exposure. ML has been there for a long time and was concieved at a time where most US universities played around in Lisp
16:41:12 <mbishop> dons: seems my reddit question was pretty popular :D
16:41:46 <wy> jlouis: I see... It seems Paul Graham is trying to make Lisp a religion?
16:42:45 <wy> jlouis: I finished a semester's "advanced" PL course, and found that I still have a lot to learn about this subject.
16:42:47 <jlouis> wy, I dont think so. Lisp is a pretty cool language. But it is cool on another axis than the axis eg SML or Haskell are cool
16:43:04 <dons> mbishop: very open ended, and people get to talk about their fav language ;)
16:43:19 <mgsloan> so we just need to do the vector summation of the two :)
16:43:35 <mbishop> dons: yeah, but they did that anyway, just in a lot of other places...I should get a job in marketing :P
16:44:26 <wy> jlouis: Do you think ML and Haskell learned something from Mathematica, or Mathematica learned from them?
16:45:02 <dons> Haskell learnt from ML, not sure Mathematica had any input
16:45:10 <mgsloan> mbishop - yeah, i was disappointed that there weren't any really good ideas.  Most interesting one to me was probably compile-time-GC.  most of them seemed to be more like confluence of features they liked from various languages, regardless of the contradictions this produces.
16:45:21 <mgsloan> ugg, mathematica...
16:45:47 <mgsloan> then again, my only mathematica experience was in #math, but still, pretty crappy syntax
16:46:50 <jlouis> wy, I never used Mathematica, so I don't know
16:46:59 <mbishop> mgsloan: indeed, but that is sort of what I wanted, even if they do confict (like someone wanting macros with a python like syntax), I think it's still good to know what they want, and who knows, someone might overcome the contradictions to make it happen :P
16:47:07 <jlouis> But haskell certainly learned a bit o' tricks from ML
16:47:34 <dons> and learnt the layout lesson from lisp
16:47:48 <jlouis> indeed
16:48:25 <mbishop> anyone tried the "factor" language? it's forth + lisp...sorta
16:48:30 <mgsloan> mbishop - heh, possible.  Also interesting is when people nearly point by point described languages i know of
16:49:12 <dons> i find the dyn typed fp community a strange place. esp. the lisp guys, with their messianic fervour for a language trapped in a pre-1985 warp.
16:49:15 <dons> </end lisp rant>
16:49:20 <jlouis> I think I've used up the next 5 years of "try another language" quota
16:49:55 * mbishop likes scheme
16:50:08 <sorear> OT: What is the accepted criteria for /msg lambdabot vs. /msg #haskell ?
16:50:09 <Pseudonym> Scheme is a much better lisp.
16:50:12 <jlouis> dyn typed fp is much different from static typed fp. At least I learnt that
16:50:13 <dons> yeah
16:50:17 <wy> I'll paste a type checker. Can you help me to find the errors? I forgot the address of the paste server.
16:50:19 <Pseudonym> The thing is, Lisp/Scheme have done a lot of good in the world.
16:50:27 <jlouis> ?where paste
16:50:28 <dons> ?paste
16:50:28 <lambdabot> http://paste.lisp.org/new/haskell
16:50:28 <lambdabot> http://paste.lisp.org/new/haskell
16:50:33 <mbishop> but I've also learned to love static typing...as long as there is type inference
16:50:34 <dons> and if that's not up (!)
16:50:36 <dons> ?where rafb
16:50:36 <lambdabot> http://rafb.net/paste
16:50:38 <jlouis> **5's dons
16:50:46 <Pseudonym> Especially when you consider how well it ran on 1960s hardware.  Even ML would never have managed that.
16:50:54 <mbishop> who wants to waste their time declaring types? :P
16:51:06 <Pseudonym> mbishop: And in Haskell, you don't!
16:51:13 * mbishop nods
16:51:23 <sorear> Except when you make typos.
16:51:28 <wy> connection refused by http://paste.lisp.org
16:51:41 <dons> yeah, try rafb
16:51:44 <sjanssen> why does paste.lisp.org go down every so often?
16:51:48 <jlouis> Lisp/Scheme has done a lot of good for sure. Its just sad that it is extremely hard to compile to effectivity
16:51:50 <dons> apparently lisppaste seems to suck now
16:51:51 <dons> :/
16:52:02 <dons> sjanssen: want to hack up lambdapaste this arvo?
16:52:09 <dons> ;)
16:52:15 <mbishop> I can't stand any language that isn't either dynamically typed, or staticlly typed with type inference...also it needs GC
16:52:16 <jlouis> (PLT Scheme is not a good representative for its speed though, even if the shootout has that language)
16:52:17 <sorear> arvo?
16:52:42 <dons> ?google translate arvo for sorear
16:52:43 <lambdabot> No Result Found.
16:52:45 <dons> bah
16:52:53 <sjanssen> dons: not a bad idea.  I bet lisppaste goes down due to type errors ;)
16:52:53 <dons> ?babel au en arvo
16:52:54 <lambdabot> babel module failed: IRCRaised Error: Language au not supported
16:52:57 <dons> bah
16:53:02 <dons> sjanssen: afternoon :)
16:53:09 <mbishop> jlouis: stalin can beat ML in the raytracer benchmark...but it takes about 5 minutes to compile, where the ML versions take a second at the most :P
16:53:10 <dons> sjanssen: yeah :)
16:53:10 <jlouis> lambdapaste.... ghc -o lambdapaste LambdaPaste.hs -package HAppS
16:53:16 <wy> Uh.. No hightlighting for ML and Haskell
16:53:43 <jlouis> mbishop, stalin is evil. I've tried to read the code on that one. It does partial evaluation a friggin' lot.
16:53:48 <wy> jlouis: I think the most serious problem with Lisp is it hasn't static type checking
16:54:06 <jlouis> (DECLARE (FIXNUM 'foo))
16:54:10 <jlouis> ehm
16:54:15 <cjeris> mbishop: stalin beats MLton too?
16:54:16 <jlouis> (DECLARE (FIXNUM foo)) even
16:54:24 <dons> yes, i don't understand really how anyone in the fP community -- with its big emphasis on reducing bugs and improving productivity -- could fail to embrace static checking
16:54:29 <mbishop> A lot of people on reddit seemed to want a statically typed scheme
16:54:51 <dons> yeah. i.e. haskell with lisp syntax, no?
16:55:04 <sorear> bigloo supports static typing <evil laugh>
16:55:18 <sorear> At least C can infer the types of subexpressions!
16:55:46 <wy> sorear: It let me feel the world is in more chaos than before
16:55:49 * sorear would like to note he has only read the docs, not used it
16:56:07 <cjeris> lisp syntax is brilliant because of the syntactic abstraction it lets you do, not for any other reason.  but as i learn more haskell it seems like you can do more abstraction _above_ the syntactic level, and then you can prove more about it too.
16:56:37 <mbishop> cjeris: In 32-bit, Stalin-compiled Scheme is fastest, followed closely by the more concise MLton-compiled SML program. OCaml, SML/NJ-compiled SML and g++-compiled C++ all give similar performance. The Lisp is not only 30% more verbose than the OCaml but is also 4.9x slower.
16:56:47 <mbishop> cjeris: from the ffconsultancy website
16:57:01 <cjeris> mbishop: thanks!
16:57:26 <wy> http://rafb.net/paste/results/rT7kaq35.html
16:57:29 <mbishop> cjeris: but mlton built in 8.6 seconds, whereas stalin took 680s (!)
16:57:58 <cjeris> or - do you need lisp-style macros when you have higher order function/typeclass/monad crack?
16:58:03 <jlouis> dons, its a bit hard to explain, but its about increasing productivity but not taking care of the details before they emerge as a problem. In Common Lisp you often dynamically improve on the problem by recompiling and reinjecting stuff into the running image
16:58:26 <glguy> ?paste
16:58:26 <lambdabot> http://paste.lisp.org/new/haskell
16:58:46 <glguy> hmm, I guess it's down
16:58:51 <jlouis> yes, your program will probably have more errors - and you will need to spend time improving on the running image. But the idea is that "good enough(TM)" is appropriate sometimes
16:59:19 <wy> jlouis: I pasted a type checker at http://rafb.net/paste/results/rT7kaq35.html. See if you can make the last example work?
16:59:42 <dons> jlouis: yes. exactly
16:59:56 <dons> its a superficial feeling of productivity (like say, perl), in that something runs immediately
17:00:04 <dons> and you lazily fix bugs as they demand fixes of you
17:00:20 <mbishop> what ungrateful little bugs...
17:00:23 <dons> like writing haskell code with undefines for things you haven't done yet
17:00:27 <jlouis> and we both know the problem however
17:00:46 <jlouis> I dislike that such programs haunts you in your sleep....
17:01:05 <jlouis> Been there , done that, hacked my piece of Python
17:01:42 <mbishop> Shouldn't that be "Strangle you in your sleep"?
17:01:45 <jlouis> wy, hah, ML
17:01:57 <dons> in haskell, I suppose you could avoid type errors lisp style by wrapping code that might work, or might not, in an unsafeCoerce#
17:02:05 <dons> then if the thing ever segfaults, sit down and make it type safe
17:02:19 <kpreid> dons: now, now. segfaults are an entire nother class of unsafery
17:02:22 <kpreid> unsafety
17:02:29 <dons> ok :)
17:02:38 <dons> ok. wrap it in Dynamic ;)
17:02:43 <kpreid> ...yeah.
17:02:45 <dons> and if it ever fails the dynamic test, then fix it
17:03:26 <wy> jlouis: yes. My professor wrote that and we just modify it.
17:03:41 <kpreid> Dynamic, annoyingly, doesn't let you get the TypeRep of a dynamic, even though it shows with it
17:04:06 <Saulzar> Yeah, every single variable in my programs are Dynamic .. it's a bit cluttered with all this toDyn fromDyn nonsense about :)
17:05:30 <jlouis> wy, so your professor should learn SML if he wrote things like fun inTheta ... ;)
17:05:48 <dons> lisp in action:
17:05:51 <dons> > let f x = case toDyn x of dyn -> (fromDynamic dyn :: Maybe Int) in show (f (7::Int)) ++ show (f "foo" )
17:05:52 <lambdabot>  "Just 7Nothing"
17:06:09 <dons> it keeps running even with type errors, stunning!
17:06:21 <wy> jlouis: inTheta is my function. Hehe
17:07:24 <kpreid> dons: on the other hand, there are things which Haskell makes Unnecessarily Difficult :)
17:07:36 <Excedrin> Saulzar: what kind of program is it?
17:07:39 <dons> I guess. What's a good example?
17:07:54 <newsham> instance Binary?
17:07:58 <jlouis> wy, it has a foldl/r form with andalso ;)
17:08:08 <kpreid> dons: (Ord a) => [a], say
17:08:13 <Saulzar> Excedrin: Imaginary :)
17:08:25 <mgsloan> dons - that's a pretty magic func there...
17:08:27 <kpreid> dons: the inability to write such things without wrappers
17:08:29 <newsham> \f r = r {field=f}  ?
17:08:33 <jlouis> wy, but even more effectively there is a SML Basis Library function in List that does that for you ;)
17:08:41 <kpreid> dons: that's a poor example...
17:08:58 <dons> mgsloan: you like? :)
17:09:16 <glguy> does this look like the "right way" to do this with Cont? http://rafb.net/paste/results/Cin12Z43.html
17:09:24 <dons> as Bob Harper has pointed out: you can always add more dynamic typing to a statically typed language, with a library. but adding static typing to a dyn typed language is going to be damn hard
17:09:32 <wy> jlouis: I haven't looked much into the library. Because most program we do with ML is simple so I just wrote these utility functions myself
17:09:33 <kpreid> dons: my arrows-for-concatenative-programming notion failed because values are monomorphic (whereas in CL &c they aren't)
17:09:41 <Excedrin> Saulzar: oh, and here I thought you had some interesting example of code where dynamic types were necessary (possibly involving serializing types or something...)
17:09:42 <mgsloan> dons - uhuh. I don't like dynamic typing that much, but that you can do that is pretty cool
17:09:50 <jlouis> wy, I've read through it and skimmed. It doesn't look wrong to me. But I did not try the code (No SML compiler here at the moment)
17:10:06 <jlouis> dons, oh, thats a cool comment
17:10:25 <kpreid> dons: sure, but using that library may involve putting in a layer around the language's base semantics
17:10:32 <dons> mgsloan: yeah. dynamic typing is just a degenerate static typing system where you wrap everything in a universal type, and case-analyse all expressions.
17:10:41 <dons> at runtime
17:10:44 <mgsloan> :type (\x -> case toDyn x of dyn -> (fromDynamic dyn :: Maybe Int))
17:10:46 <kpreid> e.g. the classic existential list problem [Wrapper 1, Wrapper "a"]
17:10:59 <mgsloan> :t (\x -> case toDyn x of dyn -> (fromDynamic dyn :: Maybe Int))
17:10:59 <dons> so bugs are delayed till you execute that branch, and chances for optimisations are missed.
17:11:01 <lambdabot> forall a. (Typeable a) => a -> Maybe Int
17:11:09 <dons> the benefit being that bugs are delayed till after you sell
17:11:25 <mgsloan> heh
17:11:28 <dons> and that some new programs act type safe
17:11:30 * kpreid refrains from commenting on dons's less concrete accusations
17:11:31 <jlouis> and that your time-to-market is low...
17:11:50 <newsham> type system doesnt preclude runtime bugs
17:11:56 <dons> yeah, but any decent dev is going to have to approximate a static type system with unit tests anyway
17:11:56 <mgsloan> yeah, i've used a lang with dyn in static before even coming to fp.  Also had type inference as a matter of fact
17:12:17 <dons> s/bugs are delayed/more bugs are delayed/
17:12:53 <CosmicRay> wow.  I've been using haskell for 2 years and I still feel like a newbie at it.
17:12:57 <dons> heh
17:13:00 <dons> CosmicRay: ow so?
17:13:02 <mgsloan> basically, you typed a static variable as 'ducky', and you can do anything with it
17:13:13 <dons> mgsloan: yeah. Typeable == ducky
17:13:18 <mgsloan> yep
17:13:33 <CosmicRay> dons: I have yet to even try to understand arrows or STM.  My understanding of monads is passable but not complete.  My understanding of TH is non-existant.
17:13:55 <dons> how about your GADT or rank N polymorphism ? :)
17:14:31 <CosmicRay> dons: "I've heard talk of those things"
17:14:34 <dons> heh
17:14:38 <kpreid> dons: actually, Typeable/Dynamic aren't quite sufficient
17:14:44 <jlouis> STM is cool!
17:14:52 <dons> yeah, they've got a monomorphsm restriction, so that's not quite enough
17:14:52 <sorear> agreed :)
17:14:57 <kpreid> dons: for example, iirc, you can't go from Typeable a to Show a
17:15:02 <emu> using STM, or  implementing it/
17:15:03 <dons> oh?
17:15:08 <kpreid> > (show . cast)
17:15:09 <lambdabot>  Add a type signature
17:15:13 <kpreid> @type (show . cast)
17:15:15 <lambdabot> forall a. (Typeable a) => a -> String
17:15:16 <CosmicRay> dons: and the scary thing was, I wrote about this feeling of still being a newbie back in March 2005, and nothing has changed even though I've learned a good deal of haskell since then.  http://changelog.complete.org/posts/265-Haskell-The-Humbling-Language.html
17:15:17 <kpreid> hm
17:15:20 <lambdabot> Title: Haskell: The Humbling Language - The Changelog, http://tinyurl.com/wx27f
17:15:25 <kpreid> > (show . cast) "abc"
17:15:26 <lambdabot>  Add a type signature
17:15:34 <kpreid> @type (show . cast) "abc"
17:15:35 <lambdabot> String
17:15:39 <kpreid> see!
17:15:50 <kpreid> same for Dynamic, of course
17:16:08 <jlouis> CosmicRay, I looked at your "New House" pics... its beginning to look like one ;P
17:16:09 <sjanssen> STM is pretty easy, just imagine that "atomic" has one giant lock around the entire transactional system, so only one transaction can run at a time
17:16:12 <dons> > let f :: (Show a , Typeable a) => a -> String ; f = show . cast in f "foo"
17:16:13 <lambdabot>  Add a type signature
17:16:16 <CosmicRay> jlouis: heh, indeed ;-)
17:16:16 <dons> yeah
17:16:29 <kpreid> because Typeable's cast strategy depends on a single concrete type
17:16:52 <sjanssen> and failing transactions get retried in a little while.  This is all the programmer has to know to write STM code
17:17:10 <kpreid> I concede that you could make a DynamicWithShow and so on, but still, you can't express some common dynamic patterns with any casting/typeclass trick
17:17:16 <jlouis> (and that in a little while is chosen intelligently ;)
17:18:02 <CosmicRay> dons: the other scary thing is that I periodically forget that I wrote an LDAP binding for Haskell, though it is in daily use at my employer
17:18:06 <dons> heh
17:18:33 <jlouis> I am doing some Log-traversing code in Haskell for the work
17:19:53 * CosmicRay notes that he has checked in the Great Renaming to MissingH
17:20:42 <jlouis> still in the MissingH darcs repo?
17:22:02 <CosmicRay> jlouis: yes
17:22:11 <CosmicRay> jlouis: it will stay there (decided not to do a name change)
17:22:21 <CosmicRay> jlouis: new homepage at http://software.complete.org/missingh though
17:22:24 <lambdabot> Title: MissingH
17:22:29 <CosmicRay> what is the canonical homepage for regex-compat?
17:22:41 <CosmicRay> http://sourceforge.net/projects/lazy-regex seems to be rather oudated
17:22:41 <lambdabot> Title: SourceForge.net: Text.Regex.Lazy
17:22:45 <CosmicRay> err, outdated.
17:24:31 <CosmicRay> so I think I will make an 0.18.0 release with everything renamed, and then start splitting things off.
17:33:20 <sorear> I saw the haskell-cafe@ posting by SM on Data.Array, and... This apparent wontfix worries me.  (If lambdabot was developed faster and had support for 'harmless' class decls, anyone on freenode could subvert dons' computer).
17:36:17 <dons> sorear: I suspect we'll fix this. i wouldn't worry too much
17:36:30 <dons> at least, add some big warnings to the Ix instances
17:36:40 <dons> ;)
17:39:13 <sorear> Haskell always seems like a safe language - we'd need a WARNING: MALICIOUS PURE HASKELL CODE *CAN* HARM YOUR COMPUTER!!!
17:40:19 <dons> yeah, that's why it was surprising
17:40:51 <dons> we only know of this Ix issue though -- and the report says a side condition must hold to be a valid Ix instance. its not like h98 in general is dangerous
17:41:06 <dons> so its a little bit like the side conditions on valid monad instances
17:41:29 <dons> would be worth getting ndm to use catch to verify Ix instance side conditions statically
17:42:43 <sorear> If we don't trust Ix and force ! to check the return for range-ness, we can skip one of the Ix range checks, so it doesn't seem like paranoia would hurt performance
17:42:55 <dons> no, I agree
17:43:21 <sorear> e.g (,) instance can skip checking the row value because (!) will check it
17:44:05 <sorear> (of course anyone caught subverting lambdabot would be rewarded with a ban but that's beside the point entirely)
17:44:08 <rc-1> im confused why doesnt this produce an infinite loop fibs = 0 : 1 : [ a + b | (a, b) <- zip fibs (tail fibs)]
17:44:41 <sorear> Lazyness.  Haskell values are like functions-returning-values in other lanuages.
17:44:54 <CosmicRay> rc-1: think like a human.  what must you evaluate to find out the first number in the sequence?
17:45:12 <dons> > let fibs = 0 : 1 : zipWith (+) fibs (tails fibs) in 1 -- laziness
17:45:13 <lambdabot>    Occurs check: cannot construct the infinite type: a = [a]
17:45:13 <lambdabot>    Expected...
17:45:16 <sorear> when you access say fibs!!20 the compiler calls the first 20 functions and dosn't call more
17:45:21 <dons> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in 1
17:45:23 <lambdabot>  1
17:45:26 <dons> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
17:45:28 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
17:45:38 <CosmicRay> rc-1: you only need to look at the 0, and so does haskell, because it is lazy
17:45:38 <dons> infinite loops are for strict languages ;)
17:45:46 <CosmicRay> rc-1: however, calling length(fibs) is infinite.
17:45:53 <dons> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in length fibs
17:45:55 <sorear> > let foo = 0 : 1 : error "won't happen" in foo ! 1
17:45:57 <lambdabot> Terminated
17:45:58 <lambdabot>  Couldn't match `Array i e' against `[a]'
17:46:02 <sorear> > let foo = 0 : 1 : error "won't happen" in foo !! 1
17:46:04 <lambdabot>  1
17:46:06 <sorear> > let foo = 0 : 1 : error "won't happen" in foo !! 2
17:46:06 <CosmicRay> there are certain things you can do on infinite lists in haskell
17:46:08 <lambdabot>  Exception: won't happen
17:46:11 <CosmicRay> evaluating their length isn't one of them
17:46:11 <rc-1> ah ok thanks
17:46:17 <dons> > [1..]
17:46:18 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
17:46:23 <dons> > length [1..]
17:46:27 <lambdabot> Terminated
17:46:30 <dons> > map (^2) [1..]
17:46:31 <lambdabot>  [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,484...
17:46:42 <dons> > scanl (+) 0 [1..]
17:46:43 <lambdabot>  [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,2...
17:46:45 <rc-1> so does it always save the partial list for later? or the compiler decides?
17:46:56 <dons> only if you need the list
17:47:02 <Pseudonym> > scanl (+) 1 [3,5..]
17:47:03 <lambdabot>  [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,484...
17:47:07 <CosmicRay> that would be an optimization.  ghc may be smarter about it than hugs
17:47:18 <dons> if you're reducing it to a value, ghc may fuse the operations , avoiding the list
17:47:49 <CosmicRay> dons: would ghc ever be smart enough to evaluate it at compile time?
17:47:49 <rc-1> scanr (+) 1 [3,5..]
17:47:56 <rc-1> > scanr (+) 1 [3,5..]
17:47:59 <lambdabot>  Exception: stack overflow
17:48:19 <sorear> > scanl (+) [3,5..]
17:48:20 <lambdabot>  add an instance declaration for (Num [a])
17:48:31 <sorear> > scanl (+) 1 [3,5..]
17:48:32 <lambdabot>  [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,484...
17:48:41 <CosmicRay> scanr doesn't work on infinite lists
17:48:50 <CosmicRay> because an infinite list has no "rightmost" element
17:49:15 <CosmicRay> make sense?
17:49:16 <dons> CosmicRay: mm. not sure
17:49:20 <CosmicRay> eh?
17:49:22 <rc-1> yeah, just seeing what happened
17:49:23 <dons> maybe... given enough inlining
17:49:41 <CosmicRay> dons: truly you are a genious if you can turn an infinite list into a finite one ;-)
17:49:57 <dons> oh yes. I was referring to your earlier comment
17:50:02 <dons> "would ghc ever be smart enough to evaluate it at compile time?"
17:50:06 <CosmicRay> oh ;-)
17:50:34 <dons> i suspect with the right fusion strategy, and enough inlining, and maybe a replicate or unfold, you could turn a head . unfold into a value at compile time
17:50:41 * cjeris is an idiot, having forgotten that the solution set of (x /= j) is not an interval
17:51:20 <sorear> an unfoldr maybe
17:51:36 <dons> grr. still can't find sequence.complete.org on my box :/
17:51:41 <dons> the HWN will have to wait
17:51:53 <CosmicRay> dons: 64.85.160.192
17:51:57 <CosmicRay> dons: add it to /etc/hosts
17:52:06 <dons> good idea
17:52:12 <CosmicRay> dons: that is really weird.  are you aussies using nameservers with broken caches?
17:52:27 <CosmicRay> TTL on the domain was set to 5 minutes, and it has easily propogated to secondary by now too
17:52:46 <dons>   hmm, it keeps reporting 64.79.199.69
17:53:04 <CosmicRay> what does: host sequence.complete.org glockenspiel.complete.org
17:53:05 <CosmicRay> say?
17:53:06 <dons> could be my provider's nameserver is busted...
17:53:26 <dons> $ host sequence.complete.org glockenspiel.complete.org
17:53:27 <dons> ;; connection timed out; no servers could be reached
17:53:31 <dons> hmm
17:53:33 <CosmicRay> bah
17:53:33 <sorear> ?hoogle (a -> Maybe a) -> a -> [a]
17:53:34 <lambdabot> No matches, try a more general search
17:53:37 <CosmicRay> that is weird.
17:53:40 <sorear> ?hoogle a -> (a -> Maybe a) -> [a]
17:53:41 <lambdabot> No matches, try a more general search
17:53:44 <CosmicRay> what does: host sequence.complete.org ns6.gandi.net
17:54:12 <dons> on my uni machine, I do get:
17:54:13 <dons> $ host sequence.complete.org glockenspiel.complete.org
17:54:13 <dons> sequence.complete.org   CNAME   glockenspiel.complete.org
17:54:13 <dons> glockenspiel.complete.org       A       64.85.160.192
17:54:22 <CosmicRay> excellent.
17:54:26 <CosmicRay> that's what you should get.
17:54:45 <CosmicRay> and if you leave off glockenspiel.c.o?
17:54:46 <rc-1> wont laziness mess stuff up if you have a function do output?
17:54:47 <dons> however, my home machine sez, $ host sequence.complete.org ns6.gandi.net
17:54:47 <dons> Using domain server:
17:54:47 <dons> Name: ns6.gandi.net
17:54:47 <dons> Address: 217.70.177.40#53
17:54:51 <CosmicRay> (on the uni one)
17:54:58 <sorear> rc-1: Yes.
17:55:05 <CosmicRay> dons: err, where's the rest of the answer? ;-)
17:55:17 <sorear> rc-1: That's why haskell forbids functions from doing output :)
17:55:43 <sorear> rc-1: Or input, or even checking the time.
17:55:47 <CosmicRay> dons: the 217.* is the ip addr for ns6.gandi.net
17:56:00 <dons> ah yes
17:57:23 <sorear> :t fmap (join (,))
17:57:24 <lambdabot> forall (f :: * -> *) a. (Functor f) => f a -> f (a, a)
17:57:35 <sorear> :t unfoldr . fmap (join (,))
17:57:37 <lambdabot>   Couldn't match `Maybe (a, b)' against `(a1, a1)'
17:57:37 <lambdabot>    Expected type: a1 -> a1 -> Maybe (a, b)
17:57:56 <sorear> :t fmap (fmap (join (,)))
17:57:58 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a. (Functor f, Functor f1) => f (f1 a) -> f (f1 (a, a))
17:58:08 <sorear> :t unfoldr . fmap (fmap (join (,)))
17:58:10 <lambdabot> forall a. (a -> Maybe a) -> a -> [a]
17:59:07 <sorear> I need an iterate that stops at Nothing; better ideas?
17:59:49 <CosmicRay> sorear: ahh, I think I have that in MissingH
18:00:01 <CosmicRay> one sec
18:00:37 <rc-1> > test = 10 : 1:  scanl (/) test (tail test)
18:00:38 <lambdabot>  Parse error
18:00:42 <sorear> why isn't it in the ?hoogle database, then?
18:01:10 <CosmicRay> hoogle doesn't index missingh
18:01:11 <sorear> rc-1: scanl should be zipWith?
18:01:37 <sorear> Aiee! why not? how can I fix it?
18:01:40 <rc-1> > test = 10 : 1 :  zipWith <- (/) test (tail test)
18:01:40 <lambdabot>  Parse error
18:02:23 <CosmicRay> hrmm, I may not have that, though I may come close.
18:02:25 <CosmicRay> http://64.85.160.193:70/devel/missingh/html/MissingH-List.html#v%3AtakeWhileList
18:02:27 <lambdabot> http://tinyurl.com/y37bfj
18:02:29 <CosmicRay> see wholeMap and takeWhile
18:02:43 <CosmicRay> that url will go invalid shortly (I gave you the IP because the server just moved)
18:03:17 <rc-1> > test = 10 : 1 : [ a / b | (a, b) <- zip test (tail test)]
18:03:17 <lambdabot>  Parse error
18:03:43 <rc-1> :(
18:05:33 <dons> CosmicRay: sequence now works :)
18:05:42 <CosmicRay> woohoo, what did you do?
18:05:45 <Pseudonym> > let test = 10 : 1 : [ a / b | (a, b) <- zip test (tail test)] in test
18:05:46 <lambdabot>  [10.0,1.0,10.0,0.1,100.0,1.0e-3,100000.0,1.0e-8,1.0e13,1.0000000000000001e-2...
18:05:53 <dons> nothing. just waited..
18:05:57 <CosmicRay> heh
18:06:19 <rc-1> ah thanks!
18:06:24 <sorear> > let test = 10 : 1 : zipWith (/) test (tail test) in test
18:06:26 <lambdabot>  [10.0,1.0,10.0,0.1,100.0,1.0e-3,100000.0,1.0e-8,1.0e13,1.0000000000000001e-2...
18:06:39 * CosmicRay afks
18:06:40 <sorear> List comprehension is not always good...
18:07:03 <rc-1> yeah, thats what i was going for at first sorear
18:07:55 <rc-1> why do you have to say let..... int test
18:07:59 <rc-1> in*
18:08:09 <sorear> to give it a name
18:08:17 <sorear> there are other ways
18:08:28 <sorear> > fix (\test -> 10 : 1 : zipWith (/) test (tail test))
18:08:30 <lambdabot>  [10.0,1.0,10.0,0.1,100.0,1.0e-3,100000.0,1.0e-8,1.0e13,1.0000000000000001e-2...
18:09:03 <rc-1> ah i see! so much syntactic sugar :)
18:09:32 <sjanssen> > let test = 10 : 1 : [a / b | (a, b) <- zip test (tail test)] in map fromRational test
18:09:37 <lambdabot> Terminated
18:12:05 <mgsloan> rc-1 - not really syntactic sugar, just function calls :)
18:12:30 <mgsloan> then again, pretty much all haskell syntax is syntax sugar
18:12:55 <rc-1> the perl of functional langs :)
18:13:50 <sjanssen> rc-1: except our sugar isn't ugly
18:14:48 <Pseudonym> Syntax is sugar.
18:14:57 <Pseudonym> But not all sugar is syntax.
18:15:21 <Pseudonym> Let me rephrase that for the benefit of people who like quoting me:
18:15:27 <Pseudonym> All syntax is sugar, but not all sugar is syntax.
18:15:44 <rc-1> > let test = 10 : 1 : scanl (*) 2 (zipWith (/) test (tail test)) in test
18:15:45 <lambdabot>  [10.0,1.0,2.0,20.0,10.0,1.0,2.0,20.0,10.0,1.0,2.0,20.0,10.0,1.0,2.0,20.0,10....
18:17:00 <sorear> :t asset
18:17:01 <sorear> :t assert
18:17:02 <lambdabot> Not in scope: `asset'
18:17:03 <lambdabot> Not in scope: `assert'
18:18:03 * sorear suddenly remebers haskell-mode hover behaivior
18:18:16 <sieni> Pseudonym: too much syntactic sugar causes cancer of the semicolon (Alan Perlis)
18:18:39 <Pseudonym> Yup, that sounds like a Perlis quote.
18:18:52 <Pseudonym> We should put Alan Perlis quotes in lambdabot.
18:19:01 <Pseudonym> And Phil Wadler quotes.
18:19:57 <rc-1> whats NAN
18:20:01 <dons> HWN out now: http://programming.reddit.com/info/tn1f/comments
18:20:03 <lambdabot> Title: Haskell Weekly News: Visual Haskell, the community report and a restricted IO mo ...
18:20:14 <newsham> i have a weird problem, I dont think there's a good haskell solution (except maybe TH).  I have a function that takes two functions and returns a new function, and another function that takes one of those functions and returns a new one.  they're both related.
18:20:24 <dons> (and an insane number of haskell blog articles this week...)
18:20:26 <newsham> usually I want to create them together like   (f1, f2) = mkFunks f3 f4
18:20:45 <sorear> that works.
18:20:48 <newsham> but sometimes I want to take args and would like to do:   (f1 k, f2 k) = mkfuncs (func of k) (func of k)
18:21:32 <newsham> which doesnt work so well :)
18:21:46 <dons> looking at the umm .. nearly 40 blog articles on haskell this week... I think maybe we're getting some traction
18:22:06 <newsham> if I wrote a TH thing, I could just write one TH line to generate both funcs as separate lines.
18:22:08 * sorear thinks would be nice: (!=) = (/=)
18:22:23 <dons> ?let (!=) = (/=)
18:22:24 <lambdabot> <local>:1:7:     Ambiguous type variable `a' in the constraint:       `Eq a' ...
18:22:29 <dons> heh
18:23:13 <sorear> ?help let
18:23:14 <lambdabot> let <x> = <e>. Add a binding
18:23:26 <dons> ?undefine
18:23:27 <lambdabot> Undefined.
18:23:43 <dons> ?let (!=) :: Eq a => a -> a -> Bool ; (!=) = (/=)
18:23:43 <lambdabot> Defined.
18:23:51 <dons> > (L.!=) True False
18:23:52 <lambdabot>  True
18:24:40 <sorear> ?hoogle (!=)
18:24:41 <lambdabot> Did you mean: (!=)
18:24:42 <lambdabot> Prelude.undefined :: a
18:24:42 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
18:24:55 <dons> ?hoogle !=
18:24:56 <lambdabot> No matches found
18:24:57 <dons> no such thing
18:25:12 * sorear just wonders why dons used L.
18:25:46 <dons> oh, lambdabot style for local definitions
18:25:55 <dons> (so people can't maliciously redefine + or map ;)
18:26:12 <dons> i.e. anything defined with ?let is imported qualified as L
18:28:20 <svref> So there isn't a installed-by-default works-on-all-implementations h98 regexp library, is there?
18:29:26 <svref> Is there a decent works-on-all-implementations one that I can download & install myself?
18:30:11 <dons> Text.Regex
18:30:57 <dons> there are pure h98 regex modules around. but if you really care about purity: use lists
18:31:10 <svref> aha, never occurred to me that it would be appreviated without the 'p'.  regexP
18:31:30 <dons> ?hoogle regex
18:31:30 <lambdabot> Text.Regex :: module
18:31:31 <lambdabot> Text.Regex.Regex :: data Regex
18:31:31 <lambdabot> Text.Regex.Posix.regexec :: Regex -> String -> IO (Maybe (String, String, String, [String]))
18:31:38 <mbishop> does lambdabot do quotes?
18:31:43 <dons> sure
18:31:49 * mbishop tries to remember JWZ's quote about regex
18:33:45 <sorear> ?google JWZ regex
18:33:45 <dons> heya coffeemug
18:33:47 <lambdabot> http://blogs.msdn.com/oldnewthing/archive/2006/05/22/603788.aspx
18:33:47 <dons> how's code?
18:33:47 <lambdabot> Title: The Old New Thing : How do I write a regular expression that matches an IPv4 dot ...
18:34:07 <dons> svref: also, would be worth using parsec for any non-trivial regex
18:34:11 <coffeemug> hey guys
18:34:12 <coffeemug> hey dons
18:34:27 <dons> basically, if its trivia, use Data.List, if its non-trivial use Parsec. if there's lots of them, use Text.Regex
18:34:27 <coffeemug> how goes it
18:34:32 <dons> good good.
18:34:45 <dons> coffeemug: 40 haskell blog articles this week! pretty nuts
18:34:53 <coffeemug> yeah
18:34:58 <coffeemug> haskell is exploding in popularity :)
18:35:01 <svref> its pretty durn simple.
18:35:03 <lispy> dons: but it's only monday
18:35:09 <dons> heh
18:35:17 <coffeemug> there'll be a backlash though
18:35:17 <mbishop> Some people, when confronted with a problem, think "I know, I'll use regular expressions." Now they have two problems.
18:35:21 <coffeemug> were people will flock to it
18:35:24 <coffeemug> get disappointed
18:35:26 <coffeemug> and leave :)
18:35:27 <dons> mbishop: that's the one.
18:35:43 <dons> coffeemug: ah well. some will stick ;)
18:35:48 <dons> and some will write new code
18:35:57 <dons> and some will go away and understand recursion a little better
18:36:01 <lispy> and some will get annoyed at their job for disallowing haskell :(
18:36:03 <dons> its all good
18:36:20 <coffeemug> yeah
18:36:26 <coffeemug> hey guys
18:36:37 * lispy was looking at job ads today and none are worth jumping ship for at this point
18:36:38 <coffeemug> does ext1Q from SYB work? :)
18:36:47 <kpreid> explicit recursion is the tool of last resort
18:36:57 <kpreid> (...I'm not sure I actually believe that, but...)
18:37:29 <lispy> kpreid: funny, i wouldn't have thought to call perl, "explicit recursion" ;)
18:37:35 <dons> that's reasonable. you use it if there's no higher order functional to do it for you
18:37:46 <dons> i.e. what loops should be in an imperative language ...
18:37:48 <coffeemug> I'm trying to ext1Q gshow and it doesn't seem to work
18:37:58 <dons> hmm. coffeemug try haskell-cafe@, I think it should work..
18:38:04 <lispy> coffeemug: i'd like to help but i have no idea what you're talking about
18:38:11 <dons> SYB 'sposed to work out of the box, after all
18:38:20 <dons> and has in my experience
18:38:37 <coffeemug> there is an obscure post on haskell cafe I found on google
18:38:44 <kpreid> @type G.ext1Q
18:38:45 <lambdabot> Couldn't find qualified module.
18:38:48 <kpreid> @type ext1Q
18:38:49 <lambdabot> Not in scope: `ext1Q'
18:38:55 <kpreid> @type Data.Generics.ext1Q
18:38:56 <lambdabot> forall q d (t :: * -> *). (Typeable1 t, Data.Generics.Basics.Data d) => (d -> q) -> (forall d1. (Data.Generics.Basics.Data d1) => t d1 -> q) -> d -> q
18:38:56 <dons> :t Data.Generics.ext1Q
18:38:57 <lambdabot> forall q d (t :: * -> *). (Typeable1 t, Data.Generics.Basics.Data d) => (d -> q) -> (forall d1. (Data.Generics.Basics.Data d1) => t d1 -> q) -> d -> q
18:38:59 <dons> or is it in SyB?
18:39:01 <coffeemug> that something there doesn't work properly because GHC doesn't derive Data properly in some cases
18:39:05 <dons> ah no. there it is. lovely
18:39:09 <kpreid> dons: shouldn't it be imported as G for consistency with eval?
18:39:15 <dons> stick that in your type checker and smoke it
18:39:23 <dons> kpreid: why?
18:39:25 <dons> doesn't it clash?
18:39:29 <dons> s/'t//
18:39:34 <dons> s/n//
18:39:50 <kpreid> I mean imported additionally as G, so that that which @runs also @types
18:39:58 <kpreid> @run G.ext1Q
18:39:59 <lambdabot>    Inferred type is less polymorphic than expected
18:39:59 <lambdabot>    Quantified type va...
18:40:02 <dons> ah
18:40:09 <kpreid> @type G.ext1Q
18:40:10 <lambdabot> Couldn't find qualified module.
18:40:26 <dons> hmm. I'm not sure we can import qualified nicely in :t
18:40:31 <lispy> would also be nice of @type import L
18:40:36 <dons> the L.* trick works because there's a lcoal module
18:40:43 <lispy> oh that works now?
18:40:48 <lispy> ?type L.foo
18:40:49 <lambdabot> Couldn't find qualified module.
18:41:03 <coffeemug> so I'm trying to do persistance to relational db for haskell types
18:41:14 <lispy> oh, i think i misunderstood you dons
18:41:19 <dons> coffeemug: ok nice.
18:41:24 <dons> sounds like something HAppS does already
18:41:32 <coffeemug> something like this
18:41:33 <coffeemug> data User = User {
18:41:34 <coffeemug>       id :: PKey Int,
18:41:34 <coffeemug>       firstName :: String,
18:41:34 <coffeemug>     } deriving (Show, Typeable, Data)
18:41:58 <coffeemug> where PKey is the type that says id is a primary key
18:42:10 <coffeemug> HAppS does persistance?
18:42:13 <lispy> just realized if i were going to do that, i'd make a new type class and use something like DrIFT so that i can make instances of it
18:42:14 <coffeemug> I thought it didn't
18:42:37 <dons> yeah. DrIFT would be nice for this (i.e. like DrIFT's Binary deriving)
18:42:49 <coffeemug> well
18:42:52 <coffeemug> SYB should work for this
18:43:02 <coffeemug> you could have load/store functions
18:43:03 <coffeemug> to do this
18:43:15 <coffeemug> generically
18:43:22 <coffeemug> which is what I do for HTML rendering
18:43:33 <coffeemug> but what causes problem here is the PKey type
18:43:36 <coffeemug> it's defined like this:
18:43:43 <coffeemug> data PKey a = PKey a
18:43:52 <coffeemug> and derives typeable and data
18:44:10 <coffeemug> but when I do gshow `ext1Q` fn
18:44:19 <coffeemug> where fn tries to do something different for PKey
18:44:37 <coffeemug> the query doesn't seem to ever evaluate fn
18:44:48 <dons> i'm not aware on any work on serialisation via SYB methods. sounds intriguing
18:44:49 <coffeemug> uses standard gshow
18:45:14 <dons> try haskell-cafe@ perhaps? needs a Ralf or Simon input
18:45:54 <coffeemug> I'll send an email probably after I poke around  a little more
18:46:11 <coffeemug> btw, here's something someone did I think
18:46:12 <coffeemug> http://homepages.cwi.nl/~ralf/syb3/src/PseudoFmap3.hs
18:46:19 <coffeemug> that demonstrates where ext1Q fails
18:48:04 <dmead> hey kids
18:48:06 <dmead> =p
18:48:38 <dons> ?users
18:48:38 <lispy> we are all the children of lambda
18:48:38 <lambdabot> Maximum users seen in #haskell: 276, currently: 242 (87.7%), active: 25 (10.3%)
18:48:50 <newsham> so I dont know if this is a good idea or not, but I want through and made separate member lifters for modifiable (State) and read-only (Reader).
18:48:57 <newsham> s/want/went/
18:49:05 <lispy> dons: i thought we were up to something like 290s at one point recently
18:49:17 <dmead> hmm
18:49:20 <dons> nah 276 is the highest i've seen
18:49:22 <dmead> the python page is nice ;o
18:49:22 <newsham> so my functions which only read are all in the Reader monad and my functions wihch update are in the State monad.
18:49:28 <dons> dmead: ?
18:49:38 <dons> newsham: ok. that's good
18:49:39 <dmead> why doesnt haskell have a nice page like that =(
18:49:43 <newsham> and "withRead" goes from state to reader monad
18:49:47 <dmead> dons: www.python.org
18:49:49 <dmead> is pretty
18:50:00 <dons> oh, they've improved it?
18:50:07 <dons> used to be a bit ugly
18:50:11 <dmead> I might have to defect if something isn't done fast =(
18:50:13 <dons> ah, still a bit ugly :)
18:50:14 <mbishop> last I saw it got uglier
18:50:16 <dmead> =p
18:50:26 <dons> dmead: http://sequence.complete.org/hwn/20061205
18:50:27 <lambdabot> Title: Haskell Weekly News: December 05, 2006 | The Haskell Sequence
18:50:28 <dons> how's that?
18:50:28 <mbishop> the little green snake was cuter
18:50:44 <dgriffi3> it seems less dense now
18:51:02 <dmead> oh
18:51:08 <dmead> sequence is pretty
18:51:14 <dons> anyway, haskell.org looks nice for the very active wiki it is
18:51:20 <dmead> should make that the homepage for haskell.org
18:51:21 <dons> we win in new-content terms :)
18:51:25 <dmead> yes
18:51:26 <mbishop> haskell.org has everything :D
18:51:39 <coffeemug> ahh
18:51:42 <dons> see the python.org: Wed, 25 Oct 2006 07:33 +0000
18:51:52 <dons> haskell.org 2006-12-05
18:51:55 * dmead is working on the finishing touches for his FOL prover
18:52:01 <dons> looks like python is dying ;)
18:52:03 <coffeemug> you have to handcode Typeable instances for kinds that have one or more parameters
18:52:07 <dmead> :o
18:52:10 <mbishop> #haskell is probably the nicest IRC channel for any language...#scheme is ok, #ocaml is usually silent, ##C is...well, you shouldn't use C, but you really shouldn't visit ##C either :)
18:52:22 <dons> mbishop: we try very hard :)
18:52:37 <dmead> yea someone is always active here
18:52:41 <dmead> at any hour
18:52:42 <dons> and seems to be working: http://haskell.org/haskellwiki/IRC_channel
18:52:44 <lambdabot> Title: IRC channel - HaskellWiki
18:52:45 <mbishop> haskell.org also has gobs of info...ocaml's site is pretty nice, but scheme and others are typically spread out all over the place
18:52:52 <dons> (look at the growth stats)
18:53:14 <leather> mbishop: The Topic at ##C says "Please be civil" ;)
18:53:15 <dons> mbishop: yeah, the aim is to centralise everything. or at least link to the stuff we can't get on h.org itself
18:53:31 <sorear> It's nice that we can still do that.
18:53:36 <mbishop> dons: seems you try pretty hard at that too :P
18:53:50 <dons> i want a haskell job once i finish my phd ... ;)
18:54:12 <lispy> i was thinking about this in the shower today, there must be a critical mass at which a community becomes profitable to the members, but there must also be a point after which it's too noisy and mediocre
18:54:27 <dons> lispy: yeah, quality control is important
18:54:32 <dons> hence -overflow and -blah
18:54:36 <sorear> SPJ talks about "fear of a success-disaster"
18:54:38 <dons> and the -cafe mailing list
18:54:55 <lispy> dons: what is -overflow for?
18:55:02 <lispy> i'm quite aquantied with -blah :)
18:55:24 <dons> overflow is long conversations about technical topics between a few people
18:55:25 <lispy> #haskell-blah is one of my favorite channels for just random chat
18:55:28 <dons> i.e. like bytestring dev
18:55:35 <lispy> Oh, right
18:55:36 <dons> (its been pretty quiet recently though)
18:55:39 <mbishop> ##C is every grumpy systems programmer, angry at the pain of having to do their own memory management and type declarations, taking it out on the poor kids who have to learn C to do their homework
18:55:46 <dons> mbishop: hehe.
18:56:13 <lispy> i get grumpy when i write windows stuff
18:56:19 <lispy> so i can relate to those old C programmers
18:56:42 <leather> I don't know about "old" C programmers... I do C/C++ as a day job.
18:56:55 * mbishop steps back a little from leather
18:56:57 <leather> That is, when I'm not doing Verilog.
18:57:12 <lispy> friend of mine usually sends me at least one IM a day about something he found in C#, VS or .NET in general that is legitimately annoying and causing him grief
18:57:24 <leather> mbishop: You do what you gotta do when you're working with embedded systems.
18:57:37 * mgsloan does opensource c++, but at least pretty much everyone working on the project is familiar with haskell
18:58:37 <Cale> mgsloan: you can share the pain equally then
18:59:51 <mgsloan> heh yeah
19:00:08 <mgsloan> it's actually intended as a library for another C/
19:00:50 <mgsloan> ++ project mainly, as well as others
19:01:28 <leather> mgsloan: What's the name?
19:01:54 <mgsloan> (geometry framework for rinkscape)  Actually, before they had implemented an extremely minimal inkscape lambda, but abandoned that at some point
19:02:11 <mgsloan> rinkscape -> inkscape
19:02:12 <mbishop> rinkscape?
19:02:14 <mbishop> heh
19:02:25 <leather> Ah, inkscape looks cool, though I haven't used it.
19:02:43 <Cale> Oh cool, I love inkscape
19:02:54 <mbishop> darn, I was excited at the idea of a roller skating landscape project :)
19:02:58 <mgsloan> yeah, only program I can draw in :)
19:03:19 <mgsloan> only problem with it is the code is hidious
19:03:44 <mgsloan> were trying to fix the geometry side of that...  Do stuff properly.
19:04:29 <mgsloan> It's like 350,000 lines of c++ though (with C all over the place too because it was converted to c++ when it went from sodipodi to inkscape)
19:05:19 <mbishop> can't convince your employer to let you redo it in haskell? :P
19:05:32 <mgsloan> employer? It's opensource
19:05:43 <mgsloan> and there was an inkscape lambda written in haskell
19:05:45 <mbishop> oh, I thought you said you get paid to do that
19:06:20 <Cale> > 350000 `div` 15
19:06:21 <lambdabot>  23333
19:06:37 <mgsloan> nah, I'm still in high school, heh
19:07:48 <coffeemug> ok
19:07:52 <coffeemug> off to do some more work
19:07:54 <coffeemug> and then sleep
19:07:56 <coffeemug> night everyone
19:07:58 <lispy> Cale: you'd estimate 15x more code to write in C?
19:08:02 <coffeemug> thanks for the help
19:09:33 <Excedrin> since Xara LX is GPL, has any of the code made it into Inkscape?
19:09:43 <Cale> lispy: yeah :)
19:11:19 <mgsloan> yeah, that's the interesting thing, inkscape lambda would probably <30,000.  Tubad it never happened.  Anyway, inkscape itself has quite alot of developers who would probably be pissed, and waste lots of effort trying to catch up to the lambda effort
19:12:15 <mgsloan> (this is considering that if you properly wrote it in C++ it'd probably be 50k shorter or something)
19:13:16 <mgsloan> Excedrin - as far as i know, no.
19:13:32 <mgsloan> It has been discussed though.  they've got a faster renderer
19:14:36 <mgsloan> cairo is probably the next renderer if any (currently its custom) - its speed will be improved a ton once firefox uses it, and it has a nice api
19:14:44 <niarium> mgsloan: can you tell me what "Expressions do not scale" means in the manifesto of PLF?
19:16:08 <mgsloan> uhh, probably that many things are awkwardly expressed as expressions, particularly when you get up into larger numbers of function arguments (~>4)
19:17:53 <glguy> Is the movie Primer what happens when you have continuations in real life?
19:17:53 <niarium> yeap, i've got it in that way too, but still i don't know what 'scale' means in this context (i'm trying to translate it in Korean, my native language)
19:19:18 <niarium> should i get it like, "expressions cannot expand that much" or something like that?
19:20:30 <mgsloan> hmm, sorta,  I think he means that once you get truely complicated and large applications, expressions don't work well
19:20:52 <mgsloan> then again, neither does normal programming
19:21:45 <niarium> thanks
19:21:53 <dmead> niarum: i think your way of thinking about it is fine
19:22:53 <mgsloan> yeah, yours is close enough.  It's a phrase used with programming languages/techniques a lot though.  If something doesn't scale its not effective in the extreme, big case
19:23:38 <niarium> i think this article is interesting enough, although i can't agree with it totally, and deserves to be translated
19:24:48 <dmead> you need to translate the term 'scale' in this context?
19:25:03 <niarium> i wonder how would my friends response, who don't even adapt themselves to Python and stick with C/C++
19:25:33 <niarium> they may just ignore this one, or may trolled
19:25:39 <niarium> dmead, yes
19:26:28 <dmead> niarium: do you know the terms "large scale" and "small scale"?
19:30:48 <niarium> yes, if what you mean is, like a blockbuster movie called "large-scaled"
19:39:16 <Pseudonym> BTW, "scale" works in both directions.
19:39:24 <Pseudonym> Many modern programming languages don't scale _down_.
19:39:34 <dmead> niarium: yes, "scale" in the context of programming means how well a system changes from "large scale" to "small scale" an vis versa
19:39:38 <dmead> *and
19:40:09 <dmead> anyone know you use ~ as a type constructor?
19:40:10 <Pseudonym> You wouldn't use Fortran if you could write a 20-line shell script.
19:41:32 <dmead> dons
19:41:34 <dmead> poke poke
19:41:48 <Pseudonym> I don't think you can.
19:41:55 <Pseudonym> How would you pattern match on it?
19:42:16 <dmead> foo(~ a) = bar
19:42:29 <Pseudonym> That, surely, is a non-strict pattern.
19:42:44 <Pseudonym> A degenerate case, to be sure, but still.
19:42:53 <dmead> mmm yes?
19:43:05 <dmead> i'm doing logic
19:43:16 <dmead> and i want a proper negation operator
19:43:25 <Pseudonym> In Prolog, it's spelled \+
19:43:37 <dmead> hmm
19:43:49 <Pseudonym> Or you could just use Not.
19:44:44 <niarium> dmead: i think now i've got it. thanks!
19:44:55 <Pseudonym> BRB
19:45:05 <dmead> niarium: no problem
19:45:15 <dmead> Pseudonym: yea i've been using Neg
19:46:02 <dmead> lispy: you there?
19:46:14 <mgsloan> @let norm n xs = (sum . map (**) $ xs) ** (1/n)
19:46:15 <lambdabot> <local>:2:0:     Warning: Pattern match(es) are overlapped              In th...
19:46:33 <mgsloan> oh, priv sessions overlap into the chan eh
19:47:10 <mgsloan> @let norm n xs = (sum . map (**) $ xs) ** (1/n)
19:47:11 <lambdabot> Defined.
19:47:23 <mgsloan> > norm 2 [5,5]
19:47:24 <lambdabot>  Not in scope: `norm'
19:47:34 <mgsloan> > L.norm 2 [5,5]
19:47:35 <lambdabot>  add an instance declaration for (Floating (a -> a))
19:47:36 <lambdabot>   In the definition o...
19:47:55 <mgsloan> ohh
19:47:59 * mgsloan goes back to priv
19:52:50 <mgsloan> > map (`L.norm`[2,5]) [1..10]
19:52:51 <lambdabot>  [7.0,5.385164807134504,5.104468722001463,5.031697308299092,5.010198312825118...
19:52:55 <mgsloan> yey for me
20:05:38 <LoganCapaldo> So what's this monomorphism restriction thing?
20:07:40 <shapr> SHAZAM!
20:08:05 <shapr> LoganCapaldo: In short, you can't instantiate a polymorphic type, you can only instantiate a monomorphic concrete type.
20:08:15 <mgsloan> it's the restriction that you can't ask about the monomorphism restriction
20:08:20 <mgsloan> aw too late :(
20:08:27 <shapr> aww
20:08:56 <shapr> mgsloan: inkscape lambda sounds way cool.
20:09:21 <mgsloan> shapr - yeah, thanks for reminding me, i was going to hunt down the code :)
20:09:34 <LoganCapaldo> shapr: Uh huh. And the definitions of those two things are? ;)
20:09:41 <shapr> I bet it'd be far less than 30k loc
20:09:49 <mgsloan> probably
20:09:49 <shapr> Heck, I'd bet it'd be less than 10k loc
20:10:05 <mgsloan> dunno about that :) if you match inkscape feature to feature
20:10:22 <shapr> LoganCapaldo: Do you know how this works? --> data Tree a = Branch (Tree a) a (Tree a) | Nil
20:10:34 <mgsloan> basic good enough functionality could probably be 10K
20:10:36 <LoganCapaldo> I think I know how it works :)
20:10:41 <mgsloan> (and less)
20:11:31 <shapr> LoganCapaldo: Hm, I don't remember any more details :-(
20:11:49 <shapr> @google monomorphism restriction haskell
20:11:52 <lambdabot> http://hackage.haskell.org/trac/haskell-prime/ticket/80
20:11:53 <lambdabot> Title: #80 (Reform the monomorphism restriction) - Haskell Prime - Trac
20:12:02 <LoganCapaldo> Yeah see I tried that :)
20:12:07 <LoganCapaldo> I got more confusered :)
20:12:16 <LoganCapaldo> hence my asking in here :)
20:12:26 <sorear> What's the difference between ?do-something and @do-something ?
20:12:34 <sorear> (lambdabot commands)
20:13:09 <shapr> sorear: No difference, @ was the original "command" character (I had to pick something!) and dons later added more options.
20:14:33 <mgsloan> I bet the core of inkscape lambda could be <10Kloc, but with a bunch of pluginish things to bring it up to inkscape level
20:14:41 <shapr> LoganCapaldo: http://www.haskell.org/hawiki/MonomorphismRestriction
20:14:42 <lambdabot> Title: MonomorphismRestriction - The Haskell Wiki
20:15:08 <LoganCapaldo> Thanks, that should work
20:15:40 <LoganCapaldo> ahhhhh it's already clear why my function triggered the warning
20:16:25 <LoganCapaldo> err error rather
20:18:32 <LoganCapaldo> Thanks shapr, that page is at the perfect level of understanding for me :)
20:18:59 <dons> mmm, http://thedailywtf.com/forums/thread/104662.aspx
20:19:00 <lambdabot> Title: The Daily WTF - WTF in Haskell
20:19:08 <dons> when haskell appears on WTF something is happening
20:19:45 <dons> dmead: ?
20:23:21 <digitaleric> can anyone recommend a place to start reading to learn about the foreign function interface (or, better still a SWIG-like tool for haskell)?
20:23:33 <mgsloan> ?where ffi
20:23:34 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
20:24:30 <digitaleric> so, if I didn't understand those docs, I'm sol?
20:25:32 <Excedrin> dons: that's an interesting thread... it's sort of a view into some "typical" programmer minds
20:25:36 <digitaleric> it looked like one was more or a tutorial than just a spec, but that link is dead (I've been looking, but mostly find (dead) links to http://www.reid-consulting-uk.ltd.uk/docs/ffi.html)
20:26:08 <sorear> there's a link to the spec at http://haskell.org/definition/
20:26:10 <lambdabot> Title: Language and library specification - HaskellWiki
20:26:33 <sorear> oooh, lambdabot follows redirects!
20:26:47 <shapr> digitaleric: Good stuff on the oldwiki - http://www.haskell.org/hawiki/FfiTutorial http://www.haskell.org/hawiki/FfiExample http://www.haskell.org/hawiki/FfiCookbook
20:26:48 <lambdabot> Title: FfiTutorial - The Haskell Wiki
20:27:42 <sorear> (s'pose it would have seemed like a bug if: Title: 301 Moved Permanently)
20:28:36 <dmead> dons: how would you use ~ as a constructor?
20:28:59 <digitaleric> shapr: thanks - "ffi cookbook" is exactly what I was looking for :)
20:29:28 <digitaleric> also thanks sorear, mgsloan
20:29:35 <sorear> uh, ~ is lazy pattern match
20:29:48 <sorear> > let (x,y) = undefined in 1
20:29:49 <lambdabot>  1
20:30:04 <sorear> oh, yeah, let weirdness...
20:30:15 <sorear> > (\ (x,y) -> 1) undefined
20:30:16 <lambdabot>  Undefined
20:30:20 <sorear> > (\ ~(x,y) -> 1) undefined
20:30:21 <lambdabot>  1
20:30:32 <sorear> that's what ~ does.
20:30:52 <Cale> Pattern bindings are always lazy
20:32:36 <dmead> what?
20:32:52 <dmead> i just want to use ~ as a negation operator ;o
20:33:27 * mgsloan wants to have wavy arrows, like ~> and <~ they look cool
20:34:03 <sorear> ---\
20:34:05 <sorear>     >
20:34:07 <sorear>    /
20:34:29 <sorear> moral: font differences will make your thing unusable
20:34:43 <sorear> (That's what ~> look like on the linux-console)
20:36:11 <shapr> mgsloan: Wavy arrows are already in use for arrow constructors.
20:36:21 <shapr> At least, the right pointing arrows.
20:38:16 <rc-1> in stuff like (.) :: (b -> c) -> (a -> b) -> a -> c how do i know whats a paramater and whats returned?
20:38:32 <niarium> c.
20:38:45 <rc-1> not that specific one, in general
20:39:02 <mgsloan> shapr - oh, cool
20:39:03 <niarium> parameters and return-values are separated by ->s, and the last one is the return value
20:39:38 <rc-1> ah, only the last one, thanks
20:39:45 <niarium> e.g. type signature a -> b -> c -> d means arity of 3 and d as a return value
20:39:46 <Excedrin> something that's typed: a -> b is a function that takes one parameter
20:39:51 <sorear> -> only separates two types.  the right is return, the left is param.  associativity conspires to make you think functions have multiple parms, but they don't
20:40:01 <shapr> Partial application means that if you don't feed in all the parameters, you get a new function returned that can take the 'leftover' params.
20:40:12 <niarium> if you want to return some multiple values, you should write like a -> b -> (c, d)
20:40:16 <Excedrin> something that's typed a -> b -> c is a function that takes a parameter that returns a function that takes one parameter (b -> c)
20:40:18 <shapr> Yeah, what sorear said.
20:40:46 <sorear> a -> b -> c is code for a -> (b -> c)
20:40:57 <shapr> Technically, everything after the first -> is what gets returned.
20:42:15 <rc-1> oh wow, so the compiler will change all "multiple paramater" functions into chained ones?
20:42:16 <shapr> With (+) :: Int -> Int -> Int  you get neat tricks like making an addOne function with (+ 1)
20:42:34 <sorear> rc-1: Yes.
20:43:18 <sorear> "Assuming a sufficiently clever compiler (and this GHC actually does), chained functions are turned into multiple parm funcs at the end of compilation.
20:43:57 <sorear> That way, you get the speed of (Int, Int) -> Int and the expressiveness of Int -> (Int -> Int)
20:45:12 <shapr> I like partial application, it feels like a more trustworthy sort of object instances.
20:45:29 <shapr> You'll find that idea called closures in PLT.
20:46:01 <shapr> (of course, partial application and closures aren't the same thing)
20:46:39 <sorear> A techinque called lambda lifting is used by some compilers to turn closures into partial application.
20:48:14 <mgsloan> ah, so all funcs just take tuples, and you define a lambda at the partial app.  makes more sense to me (than defaulting to chained and then optimizing to multi param)
20:48:36 <rc-1> is haskell written in c? seems like it would be a nightmare to make c do all this cool stuff
20:48:48 <sorear> Hugs is written in C
20:48:57 <Excedrin> GHC is written in Haskell
20:49:01 <sorear> JHC, GHC, and YHC are written in Haskell
20:49:25 <sorear> But Hugs is an interpreter, and you can't bootstrap interpreters.
20:49:35 <svref> Should one always pad the composition-of-functions dot ('.') with spaces on both sides?
20:49:42 <sorear> Yes.
20:49:58 <niarium> some compilers generate C code
20:50:03 <sorear> There are syntactic ambiguities between composition and module selection.
20:50:18 <niarium> GHC generates C code afaik
20:50:23 <sorear> > Just.subtract 5
20:50:24 <lambdabot>  Not in scope: `Just.subtract'
20:50:30 <sorear> Just . subtract 5
20:50:31 <shapr> Much like $ got a new meaning in Template Haskell.
20:50:40 <sorear> > Just . subtract 5
20:50:41 <lambdabot>  Add a type signature
20:50:44 <mgsloan> also, syntactic ambiguities with decimal points, but haskell doesn't even treat that nicely
20:50:47 <shapr> niarium: GHC has both C and native code backends.
20:50:51 <mgsloan> > 3 - .5
20:50:51 <lambdabot>  Parse error
20:50:57 <sorear> JHC compiles to C
20:51:01 <shapr> I think I've heard of a C-- backend as well.
20:51:03 <sorear> YHC generates bytecode
20:51:20 <shapr> or Javascript ;-)
20:51:28 <mgsloan> hmm
20:51:35 <sorear> GHC compiles IIRC to a proprietary form of C--, which is then transformed into C or assembly
20:51:37 * mgsloan thought there were some that went all the way to asm
20:51:53 <sorear> GHC can't IIRC generate standard C--.
20:51:57 <shapr> proprietary C--?
20:52:17 <niarium> shapr: can GHC generate a pure machine code?
20:52:21 <niarium> not via C?
20:52:23 <shapr> I would find that surprising since SPJ is behind both GHC and C--
20:52:30 <Excedrin> I thought GHC's output went to C, from that to asm which is then processed by "the mangler", then assembled and linked
20:52:32 <shapr> niarium: yup
20:52:50 <shapr> It has both options.
20:52:53 <sorear> Excedrin : that is the "old way", when you use -fvia-C
20:53:07 <niarium> i thought why GHC has GCC was it can only generate a C code, not a machine code, surprised
20:53:12 <sorear> -fasm (the default) uses the native code generator
20:53:27 <shapr> The C backend used to be better, but these days the native backend is about as good, and will soon be much better.
20:53:52 <Excedrin> is the output of the native code gen still passed thru the mangler?
20:53:54 <rc-1> sorry im still a little confused: curry :: ((a, b) -> c) -> a -> b -> c; if you just are returning c, and a and b are in the first "paramater" why -> a -> b ?
20:54:01 <sorear> in 6.6, -O implies -fvia-C, but in the devel branch -fvia-C is never turned on automatically
20:54:15 <niarium> then, is there still a layer to handle the exception, when i compile my code to a machine code?
20:54:19 <sorear> first parm: ((a,b) -> c)
20:54:27 <sorear> parm-of-result : a
20:54:33 <shapr> rc-1: curry operates on a function. Do you understand flip?
20:54:51 <niarium> like, if a runtime error occurs, does it spit out a haskell error message, or just dies with, say, segfault?
20:54:52 <shapr> Excedrin: I don't remember, sorry.
20:55:55 <rc-1> oh, so it takes a function, and returns an altered function?
20:55:57 <Excedrin> curry converts f(a,b) -> c to (f a) b -> c
20:56:02 <shapr> You'll get a haskell error message almost always.
20:56:35 <shapr> rc-1: Right, if you look at the type of flip, you can see how curry does the same sort of thing.
20:56:41 <sorear> :t flip
20:56:43 <lambdabot> forall c a b. (a -> b -> c) -> b -> a -> c
20:56:49 <sorear> :t (flip,curry)
20:56:50 <lambdabot> forall a b c a1 b1 c1. ((a -> b -> c) -> b -> a -> c, ((a1, b1) -> c1) -> a1 -> b1 -> c1)
20:56:59 <niarium> shapr: you mean every compiled executable haskell code contains an interpreter-like thing?
20:57:21 <sorear> haskell compiles check code
20:57:47 <niarium> i mean, a compiled haskell code is consist with a VM, and a bytecode for VM?
20:57:47 <sorear> like if in C every a[i] = 0; became if (i in bounds) a[i] = 0; else throw_error();
20:58:02 <Cale> niarium: In the case of yhc, yes
20:58:13 <sorear> niarium: no, haskell is compiled to machine by Ghc + Jhc
20:58:15 <Cale> niarium: GHC compiles to native code, or via C
20:58:19 <niarium> oops, i'm sorry, i meant ghc
20:58:26 <Cale> Hugs just interprets
20:58:29 <mwc> niarium, GHC executables contain machine code, with a sort of library attached called a run time system
20:58:36 <shapr> GHC binaries do have a runtime though.
20:58:51 <sorear> the Haskell RTS is just like a C-library
20:59:16 <Cale> Only GHC tends to statically link it at the moment
20:59:18 <sorear> the existance of /lib/libc.so.6 doesn't mean C is interpreted
20:59:27 <sorear> or /usr/lib/libc.a
20:59:36 <shapr> The RTS is sort of like an OS kernel as well.
21:00:07 <sorear> But, thanks to Damas-Hindley-Milner, there is no need for runtime protection.
21:00:22 <emu> didn't you know? C executables are completely standalone.  they run in a vacuum.
21:00:36 <emu> quantum physical runtime
21:00:40 <niarium> then... again, a stupid question, can a segfault occur with ordinary haskell code(without any odd attempt to raise a segfault)?
21:00:49 <Cale> niarium: no
21:01:00 <mwc> niarium, I've done it with some array code on high optimizatoin
21:01:04 <emu> modulo compiler/rts bugs
21:01:06 <mwc> I assume bounds checks were removed
21:01:27 <Cale> mwc: If your instance of Ix doesn't satisfy the required laws, you can get that
21:01:36 <dons> re.
21:01:37 <sorear> unsafePerformIO, unsafeCoerce#, unsafeRead, unsafeWrite, etc: all can crash
21:01:38 <rc-1> :t (curry,flip)
21:01:39 <lambdabot> forall a b c a1 b1 c1. (((a, b) -> c) -> a -> b -> c, (a1 -> b1 -> c1) -> b1 -> a1 -> c1)
21:01:40 <mwc> Cale, precisely what happened :)
21:01:48 <shapr> It really takes work (or an unknown bug) to get a segfault from a GHC binary.
21:01:55 <sorear> it was on haskell-cafe@
21:02:18 <shapr> hi dons!
21:02:44 <niarium> Cale, you mean any with ghc-compiled haskell code without any attempt to deliberately raise segfault, there would be no segfault but a exception message?
21:02:54 <Cale> niarium: right
21:02:58 <sorear> SMarlow himself seems to have declared a wontfix :(
21:03:25 <Pseudonym> He won't fix it because it can't happen.
21:03:30 <Pseudonym> GHC binaries never segfault.
21:03:33 <sorear> Just don't use development compilers or unsafe* functions, and you should be safe.
21:03:46 <niarium> and still, the target code is a native machine code?
21:03:53 <shapr> sorear: I think it's good to have the option to use unsafe* calls.
21:03:56 <dons> sorear: I'm not sure he's declared 'won't fix'.. http://www.haskell.org/pipermail/libraries/2006-December/006550.html
21:03:57 <lambdabot> Title: The Data.Array.* hierarchy is unsafe (or, Segfaulting for fun and profit), http://tinyurl.com/y2lqas
21:04:07 <shapr> I don't think it's something that needs fixing.
21:04:12 <dons> seems to imply, he agrees its bad. its in the h98 standard that this can be assumed, lets fix it officially
21:04:39 <dons> sorear: don't you read this as meaning "let's fix it for good"? : "You might well argue that having this assumption is undesirable (and I'd
21:04:41 <mgsloan> niarium - yep
21:04:42 <dons> probably agree), but haskell-prime at haskell.org is probably a better place to
21:04:45 <dons> start that discussion.
21:04:48 <dons> "
21:05:04 <mgsloan> in .net, for example, the bytecode is compiled to native stuff on JIT
21:06:00 <mgsloan> actually JIT stuff for haskell could be pretty awesome
21:06:17 * sorear doesn't understand the JIT hype
21:06:30 <dons> yeah, why jit when we know how to compile it :)
21:06:35 <mgsloan> sorear - basically runtime optimization
21:06:59 <mgsloan> I do in general agree though, its a kookie idea
21:07:12 <mgsloan> haskell could probably make better use of runtime opt though
21:07:45 <monochrom> I saw a cool paper on JITing Smalltalk.
21:07:59 <monochrom> Of course this is only because of Smalltalk.
21:08:48 <shapr> You could take the YHC approach of compiling to platform independent bytecode and then JITing to native code at runtime.
21:08:48 <emu> a lot of JIT research was done on Self
21:09:25 <mgsloan> shapr - yeah, that's what i'm talking about.  does YHC use its own, or java/.net/other?
21:09:35 <monochrom> When you write "1+2" and the runtime has to pretend it doesn't know "1" is "1" and "2" is "2" and "+" is applicable by definition, of course you need to JIT away all the runtime dynamic dispatch.
21:10:13 <shapr> I don't know if YHC does JIT or not.
21:10:34 <bobsaget> DCC SCHAT isoiledmypantaloon
21:10:41 <shapr> wtf?
21:10:42 <monochrom> This becomes particularly bad because even if-then-else is initially a bunch of dynamic dispatch.
21:10:42 --- mode: ChanServ set +o dons
21:10:51 <niarium> wtf?
21:10:52 <dons> grr
21:10:58 <dylan> that's ike a weird sort of split
21:11:07 <shapr> It's a client vulnerability, not a split.
21:11:09 <mgsloan> uhh, bob saget and netsplit at once? more than a coincidence
21:11:16 <dylan> oh.
21:11:22 <dylan> bad router?
21:11:24 <sorear> bobsaget?
21:11:38 <mgsloan> (21:06:38) bobsaget [n=negro@adsl-211-100-206.asm.bellsouth.net] entered the room.
21:11:38 <mgsloan> (21:06:40) bobsaget: DCC SCHAT isoiledmypantaloon
21:11:43 <shapr> dylan: No, the DCC bit before that is what did it.
21:11:44 <shapr> see?
21:11:46 <dons> mgsloan: please don't ...
21:11:53 <mgsloan> oh, doh
21:11:55 <dons> scary
21:12:01 <mgsloan> didn't realize the text could be anywhere
21:12:12 <dylan> how does that kill clients?
21:12:13 <Korollary> dear antivirus tools heh
21:12:16 <monochrom> Wow that's like an Easter Egg!
21:12:17 <dons> looks like some people need to fix their clients
21:12:27 <sorear> what the...
21:13:17 --- mode: ChanServ set -o dons
21:13:31 <monochrom> It's hard to imagine any sane programmer would write a program, ever, that exhibits that kind of behaviour.  I mean, all letters and space, there is not even a slash, and the string could appear anywhere?
21:13:49 <sorear> what kind of behaivor???
21:13:58 <monochrom> quitting or crashing
21:14:01 <dons> what's the query command for finding out what client people are using?
21:14:04 * sorear is extremely confused
21:14:15 <dylan> dons: /ctcp person version
21:14:18 <dons> that's it
21:14:32 <niarium> i'm xchat
21:14:39 <niarium> mine is xchat*
21:14:40 <dons> so conversation on mac osx?
21:14:47 <dons> who else got kicked?
21:15:05 <monochrom> I mean, you have to put in extra work to have the client act on slash-less strings.
21:15:09 <niarium> they haven't got back all yet
21:15:15 <robreim> johnMeacham_ did but his client isn't responding
21:15:15 <dons> someone else used xchat though
21:15:18 <dons> hmm. strange
21:15:25 <dons> JohnMeacham_: xchat
21:15:35 <sorear> what hapenned?
21:15:46 <niarium> somebody set up us the bomb.
21:15:56 <dons> sometimes there are modem hangup string exploits.
21:16:01 <dons> but this looks like something else
21:16:07 <niarium> we get signal.
21:16:09 <robreim> I used to love playing with modem string hangup exploits :)
21:16:31 <dons> ?users
21:16:32 <lambdabot> Maximum users seen in #haskell: 276, currently: 237 (85.9%), active: 28 (11.8%)
21:16:38 <robreim> I think it's probably just that their clients don't properly implement schat. Perhaps they're missing the SSL libraries or something which are expected by schat.
21:16:46 <dons> ah yeah
21:17:01 <niarium> that was not a real schat message
21:17:25 <robreim> No, but if the implementation is broken, it might break before it even checks the message's sanity
21:17:37 <niarium> oh
21:17:45 <Excedrin> afaik, it's not the client at all, it's the "personal firewall" that detects the pattern and closes the connection
21:17:48 <dons> welcome to planet earth: our software is crappy
21:18:02 <dons> Excedrin: oh?
21:18:12 <Korollary> there was an exploit that depended on norton antivirus to kill the irc client recently
21:18:14 <dons> then why are people on linux and the mac too
21:18:25 <dons> that doesn't seem to fit a pattern -- pretty sure JohnMeacham doesn't use windows...
21:18:38 <niarium> * This accident led the programmers to write a IRC client in Haskell.
21:18:45 <dons> we have one, ginsu
21:18:50 <dons> but maybe we need another!
21:18:52 <monochrom> I knew I was wise when I uninstalled Norton Antivirus.
21:18:55 <mgsloan> that would explain why it can appear in the middle of a message
21:18:57 <niarium> right
21:18:58 <dons> actually, JohnMeacham wrote ginsu, didn't he?
21:19:03 <niarium> what?
21:19:04 <dons> maybe he should be using it!
21:19:05 <sorear> where can I get it
21:19:08 <dons> ?where ginsu
21:19:09 <lambdabot> http://repetae.net/john/computer/ginsu/
21:19:17 <dons> its based on lambdabot :)
21:19:34 <dons> but i'd like to write another one, using smp threading, and the hmp3 curses binding
21:19:41 <dons> so like hmp3, but for irc
21:19:44 <dons> ?where hmp3
21:19:44 <lambdabot> http://www.cse.unsw.edu.au/~dons/hmp3.html
21:19:53 <monochrom> OK, perhaps some people use Windows + Norton Antivirus for internet sharing.
21:20:08 <dons> that's a scary thought
21:20:16 * dons passes around the openbsd packet filter
21:20:17 <niarium> softwares checking the packet?
21:20:24 <niarium> weird
21:20:29 <monochrom> It happens because some people have to live with Windows worshippers.
21:20:53 <dons> but surely you'd stick a free os packet filter in front of the windows machine
21:20:56 <dons> not the other way around...
21:20:57 <monochrom> The major source of Windows worshippers is parents, siblings, and spouses.
21:21:24 <mgsloan> same for religion
21:21:25 <niarium> Windows is just, not good, but most of 3rd party softwares on it is evil
21:21:51 <monochrom> dons, it comes down to home politics.
21:21:56 <dons> ah well
21:21:59 <dons> not in my home :)
21:22:04 <sorear> I use Debian-sid, I have a single board Linux 2.4.x cable modem.
21:22:16 <sorear> My family uses WinXP :(
21:22:23 <monochrom> You can't always expect every geek wins the election for the minister of IT.
21:22:27 <sieni> monochrom: usually the best approach with e.g. women is to just tell them to get a mac
21:22:36 <dylan> my mother uses ubuntu, ion3, and mutt. my father uses win2k
21:22:41 <mgsloan> no point in getting my family off xp when they just use word and firefox
21:22:56 <dons> dylan: nice
21:22:58 <sorear> Actually my father got the cable modem - I wonder what he'd think if he knew it had Linux inside :)
21:23:02 <shapr> mgsloan: Isn't it the other way around?
21:23:11 <mgsloan> heh
21:23:26 <shapr> If they only use firefox and word, no point in them using windows?
21:23:26 <mgsloan> well, they'd rather just stick to it
21:23:30 <niarium> my family hates the machines
21:23:56 <sorear> IIRC my father is an MCSE
21:24:07 <mgsloan> I tried to get my dad on linux, but I couldn't get java applets/flash, etc working
21:24:33 <shapr> I don't have those working either.
21:24:37 <niarium> flash doesn't work?
21:24:38 <sorear> Java applets? what are those? :))
21:24:41 <robreim> I gave up trying to get flash working properly years ago
21:24:55 <dylan> I have flash working on all my x86 machines
21:25:11 <shapr> flash is mostly win32 specific (does it work on mac?) and for linux it is definitely x86 specific.
21:25:13 <dylan> well, it's not me that did it, but debian, but still
21:25:16 <mgsloan> i've actually got flash working, but it has a wierd bug where text isn't displayed
21:25:19 * sorear senses something fishy in dylans specification-of-architecture
21:25:24 <Excedrin> flash 9 doesn't exist for linux, but otherwise it works fine for me...
21:25:27 <shapr> mgsloan: That's the DAMAGE option in your X config
21:25:29 <mgsloan> everything else is seemless. could have something to do with fonts
21:25:41 <shapr> or was it composite?
21:25:44 <shapr> One of those.
21:25:49 <mgsloan> heh
21:25:53 <niarium> Excedrin, there is a beta version of Adobe Flash Player 9 on Linux
21:25:54 <mgsloan> I'll check
21:26:08 <sorear> SPJ just needs to step up his haskell-applets pressure
21:26:17 <dylan> sorear: I am an abused user of amd64.
21:26:22 <shapr> Flash is just a hi-tek <BLINK>
21:26:22 <dylan> sorear: and a bitter one
21:26:30 <dons> hmm!
21:26:31 <dons> http://www.rentacoder.com/RentACoder/misc/BidRequests/ShowBidRequest.asp?lngBidRequestId=583478
21:26:33 <lambdabot> Title: Rent A Coder - Haskell Language Help, http://tinyurl.com/y2g38q
21:26:48 <dons> anyone want to make some $lambdas
21:27:13 <monochrom> Is this one moral and ethical?
21:27:14 * sorear uses elinks, ircii, bash, and emacs-snapshot -nw, and shuns all graphics
21:27:35 <mgsloan> monochrom: probably not - stinks of homework assignment
21:27:35 <nornagon> tsk, emacs
21:27:44 <emu> screen!
21:27:53 <mgsloan> then again it just asks for help
21:27:55 <dons> mgsloan: agreed
21:27:57 <nornagon> vim is the One True Editor.
21:28:07 <emu> emacs is the one true kitchen sink
21:28:16 <shapr> I like graphics just fine, but I don't like using non-standardized closed source stuff on my box.
21:28:19 <emu> i wash my dishes in it
21:28:20 <dons> mgsloan: have people been known to pay for homework solutions this way?
21:28:25 <sorear> emacs -nw and vim are the same, compared to say OOo.
21:28:34 <mgsloan> not necessarily coding.  Could bid $0 and give #haskell freenode
21:28:37 <mgsloan> dons - sure
21:28:43 <dons> yeah.
21:28:44 <shapr> SMIL, SVG, and declarative animation is the w3c way to do web animation.
21:29:01 <robreim> I used to be a vi monk. Then I figured I'd try emacs just so I knew why I was choosing vi over emacs. I haven't used vi except under suffrance since.
21:29:35 <dylan> vi or vim?
21:29:36 <sorear> this is not a free-software issue.  this is an i-hate-mice issue.
21:29:42 <mgsloan> more like large projects though, not usually the daily assignment type things
21:29:49 <robreim> (wrong use of "suffrance". Oh well)
21:29:55 <sorear> duress?
21:29:59 <monochrom> "Need help with Haskell language function for basic program. So please let me know if you have knowledge of that language."  Is that the full question?  It's extremely complete, informative, and precise.
21:30:12 <sorear> lambdabot needs ?dict
21:30:22 <dons> ?web1913 suffrance
21:30:24 <lambdabot> *** "Suffrance" web1913 "Webster's Revised Unabridged Dictionary (1913)"
21:30:24 <lambdabot> Suffrance \Suf"france\, n.
21:30:24 <lambdabot>   Sufferance. [Obs.] --Chaucer.
21:30:25 <emu> robreim: i use both /shrug
21:30:31 <emu> ask me how I keep the keybindings straight
21:30:38 <dons> monochrom: homework -- or they don't know about #haskell, i think
21:30:47 <robreim> how do you keep the keybindings straight?
21:30:51 <emu> i have no fscking clue
21:30:54 <nornagon> vimacs!
21:30:59 <Excedrin> monochrom: he clearly needs a basic compiler written in Haskell...
21:31:00 <robreim> :)
21:31:03 <dons> heh
21:31:03 <Excedrin> viper!
21:31:08 <dons> Haskell language function for basic program
21:31:26 <dons> i.e. something of type Basic -> Asm
21:31:30 <sorear> I can't type C... int main [] = printf "Hello world"; } why doesn't this compile :)
21:31:39 <nornagon> heh.
21:31:53 <dons> oh, you mean: main :: [String] -> Int I think
21:32:03 <monochrom> OH I know why it has to be so complete, informative, and precise.  The asker really wants the class teacher to recognize the question.
21:32:14 <dons> heh
21:32:19 <dylan> I think vim and emacs fit two different usage patterns.
21:32:48 <dylan> it's a nice way of avoiding argument, at least. XD
21:33:19 <mgsloan> yep, that buyer has purchased 19 other homework solutions
21:33:22 <robreim> they don't mean the language when they say "Basic", do they?
21:33:28 <dons> mgsloan: ah very interesting
21:33:42 <dons> mgsloan: anyway to find out more info about the buyer? i.e. report it to their college...
21:33:43 <jcreigh> I think the quotes of the week alone makes the Haskell weekly news worthwhile. :)
21:33:51 <sorear> yeah.
21:33:53 <monochrom> Yes jcreigh :)
21:33:57 <mgsloan> http://www.rentacoder.com/RentACoder/SoftwareBuyers/ShowBuyerInfo.asp?lngAuthorId=1365615
21:33:59 <dons> mgsloan: at least find out what uni they're at, so we can see if their haskell tutor is in channel
21:34:00 <lambdabot> Title: Show Buyer Info, http://tinyurl.com/ya5j9c
21:34:07 <dons> jcreigh: cool
21:34:10 <monochrom> I eagerly read the quotes every time
21:34:12 <robreim> meh, I'm not going to argue if emacs or vim is better. Just relating to how religion can be turned on its head just by looking at the alternatives.
21:34:31 <monochrom> Knuth chooses emacs and fvwm.  There.
21:34:33 <dons> mm. San Jose, eh?
21:34:50 <emu> fvwm? that moron!! :P
21:34:57 <niarium> a friend of mine who is a total newbie for programming wants to learn it. i wanted to recommend him haskell, but wasn't able to find any proper material(i. e. tutorial) for beginner with haskell
21:34:57 <mwc> knuth runs linux?
21:35:07 <mgsloan> could be like an all to quick week or two haskell jaunt, and he doesn't want to actually learn it :/
21:35:15 <emu> Knuth is also religious
21:35:16 <jcreigh> Knuth uses fvwm? Huh, I figured he would be using "literate twm" or something.
21:35:17 <dons> niarium: for a bginner programmer?
21:35:23 <emu> I read a bit from him about it
21:35:29 <dons> niarium: I think one of the text books, i.e. 'craft of fp' -- designed for beginers
21:35:36 <dons> niarium: or 'introduction to programming, using haskell'
21:35:42 <shapr> Yeah, I think craft or SOE is good for starting.
21:35:52 <shapr> But really your friend should just hang out here and learn stuff.
21:35:53 <monochrom> One day, Knuth visited Waterloo for several days.  On the first day he offered to answer questions from the floor.  "All questions --- except for religion, because I'll do that tomorrow."
21:36:01 <emu> jcreigh: maybe they would have given him a 5 year sabbatical to design a good WM
21:36:18 * sorear started with C, and wants to deprive niarium's friend of the experience
21:36:19 <dons> niarium: http://www.cs.kent.ac.uk/people/staff/sjt/craft2e/
21:36:20 <lambdabot> Title: Haskell: The Craft of Functional Programming, Second Edition
21:36:25 <monochrom> So eventually someone raised, "which editor do you use --- or is that considered a religion question?"
21:36:26 <dons> niarium: was my first programming book
21:36:42 <mgsloan> haha
21:36:44 <niarium> A Gentle Intro(blah) or YAHT doesn't seem to fit a beginner, who isn't familiar with any other language
21:37:03 <Korollary> Knuth doesn't use an editor. He roundhouse kicks the filesystem to produce the text file he wants.
21:37:07 <chessguy> only knuth could visit a place one day for several days
21:37:16 <monochrom> Damn you
21:37:47 <dons> niarium: agreed.
21:37:56 <mwc> Korollary, heh
21:38:06 <dons> niarium: there's some good introductory to programmer textbooks, in haskell. but i don't know of any free online resources
21:38:18 <niarium> i should make it
21:38:28 <jcreigh> @where yaht
21:38:29 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
21:38:42 * sorear has reached the point where haskell? what do you mean 'paradigm shift', it's just a pure language with declarative infix syntax and extensive type inference...
21:38:44 <emu> i used the "Gentle Introduction"
21:39:02 <sorear> all my favorite features, in one language.
21:39:04 <dons> sorear: great.
21:39:33 <sorear> I actually discovered Haskell through the Unlambda docs...
21:39:37 <dons> huh
21:39:38 <niarium> that Gentle Introduction was good, but wasn't Gentle at all
21:39:48 <emu> hehe
21:39:51 <niarium> it should be renamed
21:39:57 <sorear> = the functional programmer's INTERCAL.
21:40:01 <emu> however I came from an SML background, so it wasn't too hard to adapt
21:40:27 <niarium> like, A Formal Introduction
21:41:03 <niarium> or, Haskell for intermediate programmers
21:41:12 <mwc> What's needed is a violent, bloody, but not permanently scarring introduction to Haskell.
21:41:22 <mgsloan> heh, yeah
21:41:32 <mgsloan> its amazing how hard it is for people to learn procedural though
21:41:38 <chessguy> yes, and it should involve lots of monsters
21:42:17 <mgsloan> i take it for granted since i learned it when i was 8, but now that i know people that are trying to learn python...
21:42:21 <monochrom> "A monster can devour values.  return :: (Monster m) => a -> m a"
21:42:23 <mwc> mgsloan, I learned C from my uncle (Electrical Engineer) at 8. IT was all explained to me from the foundations of switches and these things called registers
21:42:44 <mgsloan> hehe, cool
21:42:47 <sorear> I learned C from a book at 7-8
21:43:02 <mwc> From the standpoint of the computer flipping switches, procedural programming made sense
21:43:11 <mgsloan> As far back as five i drew circuit schematics....
21:43:15 <mwc> I think procedural programming is easy for people to learn if you teach it from the implementation
21:43:18 <niarium> i've learned GW-BASIC when i was about 10
21:43:26 <mwc> mgsloan, at 5, my grandpa showed me how to wire a house
21:43:32 <mgsloan> lol, nice
21:43:47 <mwc> he owned the hardware store in the small town he lived in
21:43:50 <mgsloan> whenever i saw a pipe or anything i'd have to stop and figure out what it did
21:43:51 <niarium> monochrom, (Monster m) is cool
21:44:01 <monochrom> Yeah!
21:44:13 <mwc> mgsloan, lol, my mom used to tell me I could learn electricity, and plumbing, but not both at the same time
21:44:20 <sorear> hehehe
21:44:23 <mgsloan> haha
21:44:38 <niarium> we need a guide about monad for beginners, like "All About Monadsters"
21:44:39 <mgsloan> I wasn't in to plumbing, just things that did things
21:44:46 <mgsloan> especially vaccum cleaners, apparently
21:44:48 <monochrom> You go show your mom that both electricity and plumbing are arrows...
21:44:51 <shapr> Bah, I didn't learn any programming when I was a kid. But I did get to play with ionizing radiation sources!
21:45:20 <monochrom> Did you watch them with a cloud chamber?
21:45:39 <sorear> I got all the theoretic stuff very young, but most of my practical knowledge is "don't stick your finger ina live computer power supply"
21:45:43 <mwc> So what I was getting at is that procedural programming is easy if you teach it from the direction of the implementation. Functional programming required me to finally start seeing programming as mathematics
21:45:49 <shapr> No, but we did have dosimeters and geiger counters hanging around the house.
21:45:55 <mwc> niarium, I'm wokring on bind right now :)
21:46:02 <sorear> (Yes, I learned that the hard way :( )
21:46:03 <shapr> And bits of tungsten, boron, etc
21:46:15 <niarium> mwc: i can't wait for that
21:46:23 <mwc> sorear, I've absorbed a lot of voltage myself :)
21:46:40 <shapr> mwc: Yeah, same for me.
21:46:57 <sorear> Oh, yeah, and don't use your fingers to guide obstinate plugs...
21:47:10 <sorear> *Especially* not one finger from each hand.
21:47:19 <shapr> Imperative programming for me was always practice without principles. Functional Programming has pointed me towards the underlying systems.
21:47:54 <mgsloan> yeah
21:48:03 <mwc> "A monster can devour a smaller monster. This smaller monster will devour the value in the larger monster. Then the larger monster will digest the small monster and the small monster's value will end up in the large monster's stomach. They have to be the same kind of monster or it would cause indigestion. (>>=) :: (Monster m) => m a -> (a -> m b) -> m b
21:48:35 <sorear> mwc: that sounds like it could be adapted to lifting
21:48:59 <mwc> Oh no, that strained my credibility as a storyteller enough.
21:49:28 <Excedrin> http://permalink.gmane.org/gmane.comp.lang.haskell.cafe/16214
21:49:29 <sorear> monster transformers... (don't tell me they're related to that tv show)
21:49:30 <lambdabot> Title: gmane.comp.lang.haskell.cafe
21:49:33 <Excedrin> that one, right?
21:51:40 <mwc> sorear, maybe we'll save the monster eating for transformers... bind is then explained as a monster barfing up the digested remains of a value. Another monster will do something to make that palatable, add spices, maybe some virgins, then eat it.
21:52:18 <chessguy> hehe
21:53:42 <monochrom> I don't believe in the claim that imperative programming is not susceptible to mathematics and principles.  This is because I have seen the disproof.  Dijkstra's weakest preconditions, and Hehner and Hoare's relations.
21:54:00 <mwc> monochrom, I certainly didn't say that
21:54:25 <mwc> just that it build best on a mental model of a THING doing STUFF that changes the state of the THING
21:54:26 <monochrom> However, you can say that these really turn imperative programming into functional programming, so the point may still stand.
21:54:33 <shapr> I do wonder whether the systematic approaches of the Haskell world are purely derived from the community.
21:55:06 <sorear> who cares why it
21:55:27 <shapr> Because I want to know.
21:56:15 <shapr> What if imperative languages could lend themselves to analysis as much as Haskell does? Maybe there's some nifty sweet spot that could do that?
21:56:37 <emu> you can have a formal model of imperative programming.  it's just that it's much more difficult to think about everything that is going on in typical such systems, formally.
21:56:41 <sieni> shapr: ssa?
21:58:02 <sorear> It is probably equally hard to provide formal proofs for haskell vs. C.  but normally you don't want formal proofs, and FP seems to interact with brains to facilitate "inuitive proof".  Formal proof is not yet practical.
21:58:08 <monochrom> It does seem that to reason about state mutation, you have to remove the state mutation and talk about values-before and values-after instead.  So perhaps it's still functional programming in another notation.
21:59:54 <shapr> sorear: Not proofs, but lending themselves to analysis.
22:00:35 <monochrom> I recommend my supervisor's book on this.  http://www.cs.utoronto.ca/~hehner/aPToP/
22:00:36 <lambdabot> Title: a Practical Theory of Programming
22:01:45 <niarium> some says that FP doesn't fit for the human cognitive skills, and monad is reductio ad absurdum
22:02:14 <mwc> wow, I had no idea that Springer-Verlag had a special "canadian" format
22:02:35 <mwc> Is that so you can read it in Egypt without getting set on fire?
22:03:57 <monochrom> Springer-Verlag gave the copyright back to the author.
22:04:31 <mwc> I'm talking about the cover
22:04:37 <mwc> Green with red maple leaf
22:04:39 <monochrom> So the Canadian sign is his, not Springer's.
22:04:44 <mwc> ahhhhh
22:04:53 <mwc> Looked like the books original cover
22:04:56 <leather> shapr: IMHO, there's nothing inherently preventing analysis of imperative languages, per se. It's just the features you commonly find with them: pointers, references, etc.
22:05:03 <monochrom> Yes he fudged it.
22:06:02 <mgsloan> partial application and pointfree doesn't help with functional analysis
22:06:47 <mgsloan> not to mention when the $ operator is an actual func not syntax
22:07:36 <sorear> it all desugers to simply typed lambda calculus - even adt's if you try hard enough.
22:08:04 <mgsloan> true
22:08:41 <monochrom> pointfree helps.  see Bird's book "Algebra of Programming"
22:10:04 <mgsloan> well, i think one of the most useful analysis, especially for imperative, but functional as well, is essentially what piece of code may have done a particular thing
22:10:35 <sorear> in functional it
22:10:49 <mgsloan> basically like grepping, but actual code analysis
22:11:18 <sorear> 's easy - values only come from their definitions... (I hate my enter key)
22:11:46 <mgsloan> uhh
22:12:33 <mgsloan> I mean more like, what are all function calls that might add to or create a map with an integer key
22:12:43 <mgsloan> MAp
22:14:08 <mwc> so I read above that the native code gen is superceeding the C one at long last
22:14:43 <mwc> that's awesome news... I always thought that trying to encode haskell concepts as C and letting GCC bash at it was a pretty inefficient thing to do
22:15:28 <niarium> well, the generated C code was like an assembly code
22:15:40 <sorear> OTOH it allowed GHC to support all arches gcc did - which is a lot...
22:16:08 <sorear> C is *portable* structured assembly
22:16:13 <niarium> that's the good point
22:16:33 <mwc> I know the MLton guys say their native code generator built better code than the C one, after a lot of effort went into it
22:16:35 <sorear> hence the OTOH - the main hand is still a bad point :)
22:17:19 <mwc> I think they estimated 9 man-months to implement another NCG that could supass the C one on any given platform
22:24:27 <newsham> and how many people are working on it?
22:25:31 <Excedrin> http://mlton.org/pipermail/mlton/2005-June/027143.html
22:25:33 <lambdabot> Title: [MLton] native vs. C code generation
22:40:29 <mwc> Excedrin, that's precisely what I was remembering
22:50:46 <goltrpoat> how does the offsite blog thing work on haskell sequence?  do people just submit urls randomly, or does someone with access say "oh that looks cool, let me add it to this xml file i keep in my fridge."
22:51:17 <sjanssen> xml files need to be refrigerated?
22:51:33 <goltrpoat> yes
22:51:39 <sjanssen> oh my
22:51:44 <dons> goltrpoat: you ping CosmicRay, and he adds it I think
22:51:50 <goltrpoat> ah ok
22:51:54 <dons>  /methinks he should add all of planet haskell
22:52:08 <goltrpoat> i think i'll wait a little bit until i have more content, was just curious
22:52:33 <dons> mwc, newsham: you'll be excited to know the ghc native codegen effort is starting up
22:52:36 <dons> now that -fasm is the default
22:52:46 <dons> expect some action in late jan, feb
22:53:00 <mwc> Right, from that article on the mlton list, it sounds like their old and busted native generator was better than the GCC backend
22:53:14 <dons> yeah, I think its not too hard to beat GCC when feeding it FP code
22:53:15 * mwc can't wait for the new hotness
22:53:45 <dons> I see no reason why ghc haskell should not run around Clean speed for tight loops
22:53:51 <dons> but with lots of more fun libraries and types :)
22:54:51 <goltrpoat> there aren't a whole lot of semantic differences between haskell and clean, are there
22:54:54 <mgsloan> once you add schemas and such they'll rot without refrigeration
22:54:57 <goltrpoat> i only looked at clean pretty briefly
22:55:20 <dons> goltrpoat: not really, its a haskell branch that didn't quite manage to merge into the main haskell stream almost ;)
22:55:35 <mwc> I thought clean was older than Haskell
22:55:38 <goltrpoat> that's more or less what it looked like
22:55:39 <dons> it is
22:56:11 <goltrpoat> older, as in, a pre-98 branch?
22:56:13 <mwc> so clean is like a funny uncle with a hairy forehead and a tail to Haskell
22:56:13 <dons> we had lennart describing recently how when haskell was standardised, people abandoned their private lazy languages , in favour of concentrating on haskell. all except clean, that is
22:56:32 <mwc> dons, I think I wsa here for that discussion
22:56:34 <dons> there were efforts to ensure clean and haskell were basically identical, but clean has diverged further
22:56:35 <goltrpoat> ah
22:56:39 <dons> you can still cross compile both ways, I think
22:56:50 <goltrpoat> so hence the mirandaish syntax, and they probably kept incorporating the same things along the way
22:57:02 <Cale> Typeclasses, for instance
22:57:10 <goltrpoat> -nod-
22:57:16 <dons> and intereseting, the EHC haskell compiler now has uniqueness typing..
22:57:42 <dons> but languages rise and fall on their community, and I think clean has stayed pretty much as a research language
22:58:05 <goltrpoat> i thought it was closed-source and they were selling licenses
22:58:12 <goltrpoat> or am i thinking of something else
22:58:12 <dons> good thing is you can take a research paper on clean, and rewrite it in haskell with little problem
22:58:18 <dons> goltrpoat: yeah, that used to be the case
22:58:19 <mgsloan> http://en.wikipedia.org/wiki/Clean_(programming_language) <- could perhaps add history to this
22:58:34 <goltrpoat> ive seen about 10 times more research papers on curry than i have on clean :)
22:58:41 <goltrpoat> and i think ive only seen about 10 of the former
22:58:59 <dons> there was a recent paper on QuickCheck for hofs, for Clean
22:59:04 <goltrpoat> ah
22:59:07 <goltrpoat> ohh right i remember that
22:59:20 <goltrpoat> i think you posted it on reddit, come to think of it
22:59:30 <dons> yeah, after I met the author :)
22:59:36 <goltrpoat> ah cool
22:59:41 <dons> and asked him lots of pestering questions
22:59:44 <goltrpoat> hehe
23:01:27 <mgsloan> yeesh, on the shootout once you eliminate the ones that clean doesn't implement, it beats ghc
23:01:40 <dons> it has unboxed bytestrings by default on the shootout.
23:01:46 <mgsloan> ohh
23:01:48 <dons> so you can't really compare string stuff against ghc yet
23:01:56 <dons> unless you write the haskell code using bytestrings
23:02:10 <mgsloan> which we will, right?
23:02:17 <dons> but after that, clean should still win a few things, since its nativegen is better
23:02:21 <dons> mgsloan: quite so
23:02:25 <dons> we have bytestring fusion too
23:02:29 <dons> so that's an advantage
23:03:06 <dons> mgsloan: so what haskell code are you working on/
23:03:33 <goltrpoat> GNAT is in 5th place?  nuts
23:03:34 <mgsloan> that markov stuff is on a backburner
23:03:41 <mgsloan> mostly been c/c++ ing
23:04:33 * dons hunts for exciting new projects in haskell
23:04:37 <dons> who's working on something!?
23:04:48 <dons> do i have to write the ruby on rails killer myself? :}
23:05:05 <niarium> i'm planning HqT
23:05:09 <dons> HqT?
23:05:11 <mgsloan> and on the idea backburner is a functional graphical language...
23:05:11 <goltrpoat> i was going to implement an inverse kinematics solver prototype in haskell, based on automatic differentiation as the distinguishing feature
23:05:21 <mgsloan> ooh, coolio
23:05:22 <niarium> a Haskell binding of Qt
23:05:22 <goltrpoat> once i get some actual.. time and all
23:05:25 <dons> goltrpoat: yeah? using oleg's technique?
23:05:30 <mgsloan> I think haskell needs a geometry lib
23:05:31 <dons> niarium: ah, GREAT idea!
23:05:38 <niarium> with FFI
23:05:40 <goltrpoat> dons:  i haven't seen oleg's technique
23:05:46 <dons> niarium: you should ping dcoutts about how the automated the gtk binding generation
23:05:53 <mwc> Last I heard FFI with C++ was scary
23:05:57 <dons> goltrpoat: you don't read the weekly news?
23:06:03 <mwc> something to do with name mangling
23:06:05 <dons> goltrpoat: http://article.gmane.org/gmane.comp.lang.haskell.general/14566
23:06:06 <niarium> mwc, true
23:06:07 <lambdabot> Title: Gmane -- Mail To News And Back Again
23:06:10 <dons> mwc: a little. but it can be done
23:06:21 <dons> even if you have to generate C wrappers automagically
23:06:27 <niarium> i think i should make a neat C binding of Qt, and then link it to Haskell
23:06:29 <mwc> that and the name mangling subtly changes someimes
23:06:29 <goltrpoat> dons:  i came across something on sigfpe's blog that made sense (the non-standard non-standard analysis thing, dual numbers), wrote up some haskell code, and started thinking of what it could be used for.. then suddenly IK jumped out
23:06:34 <dons> niarium: but i'd expect to get quite a bit of interest on haskell-cafe if you put some code up
23:07:31 <goltrpoat> dons:  ok, i'll have to read this, but the second sentence makes me think he's doing something a hell of a lot more heavyweight than what i'm doing :)
23:07:48 <dons> it might be -- it's oleg after all, he's a heavyweight in general
23:08:04 <niarium> dons: i think i can't make enough time to work on it now... maybe start with new year
23:08:27 <dons> ok. good idea. if you want people to help out, ask on haskell-cafe@
23:08:32 * mgsloan doesn't even have a millioleg :O
23:08:36 * Cale sees the C++ to HTML converter on reddit and considers reimplementing it in terms of parsec :)
23:08:52 <niarium> dons, can you tell me more about... what haskell-cafe is?
23:09:01 <Cale> niarium: it's a mailing list
23:09:02 <dons> niarium: ah, the mailing list :)
23:09:06 <Cale> @where haskell-cafe
23:09:06 <lambdabot> I know nothing about haskell-cafe.
23:09:08 <Cale> hmm
23:09:11 <dons> niarium: visit haskell.org, click on 'mailing lsits' and subscribe :)
23:09:18 <niarium> oh, ok
23:09:24 <mgsloan> yeh, bot definitely needs a smarter where
23:09:44 <Cale> @where+ haskell-cafe http://www.haskell.org/mailman/listinfo/haskell-cafe
23:09:45 <lambdabot> Done.
23:10:37 <Cale> @where mailinglist
23:10:38 <lambdabot> I know nothing about mailinglist.
23:11:09 <Cale> @where haskell@
23:11:10 <lambdabot> I know nothing about haskell@.
23:11:15 <Cale> @where+ haskell@ http://www.haskell.org/mailman/listinfo/haskell
23:11:16 <lambdabot> Done.
23:11:33 <Cale> @where+ haskell-cafe@ http://www.haskell.org/mailman/listinfo/haskell-cafe
23:11:34 <lambdabot> Done.
23:11:52 <Cale> @where+ mailinglist http://www.haskell.org/mailman/listinfo/haskell
23:11:53 <lambdabot> Done.
23:11:57 <sjanssen> and the bot just got a smarter where :)
23:12:03 <dons> when I say haskell-cafe@ in line, lambdabot could print the url ...
23:12:15 <dons> the @where'll do for now though
23:13:57 <dons> Cale: do you find whenever you see C/C++ used for string processing, you have a strange sense of disbelief?
23:13:59 <Cale> @where+ mailinglist http://haskell.org/haskellwiki/Mailing_lists
23:14:00 <lambdabot> Done.
23:14:06 <Cale> dons: hehe
23:14:17 <dons> i always ask myself "why do that?"
23:14:28 <Cale> That code looks at least 10 or 20 times longer than it ought to be.
23:14:32 <dons> yeah
23:14:58 <dons> not sure why this guy keeps posting kinda crappy code to reddit..
23:15:18 <sjanssen> this is just a lexer, right?
23:16:04 <dons> I think so
23:17:42 <Cale> He's probably just unaware of the fact that it could be made a whole lot better.
23:18:36 <dons> yeah I guess
23:18:44 * mbishop is no longer surprised at the idiocy of reddit
23:19:19 <mbishop> I had it set to show 50 links per page, and I sometimes look at the main page, and hide anything uninteresting, yesterday, out of 50 links, only 12 were left
23:19:24 * dons hunts for more hard pdfs on type theory to submit, to scare off the boring posters
23:19:35 <dons> mbishop: heh
23:19:39 <sjanssen> maybe Clinton will start a "Clinton's Haskell Examples" blog after Cale demonstrates better code several times
23:19:46 <dons> sjanssen: ah yes.
23:19:49 <Cale> hehe :)
23:20:00 <dons> now I wonder, after 40 blog entries this week, if we'll top that next week...
23:20:16 <dons> we just need all ~250 people in this channel to write one small haskell program...
23:20:24 <goltrpoat> i just set it to sort by hot instead of new, whatever the hell that means.  and trust the masses to filter out the fluff for me
23:20:24 <dons> and we'd OWN reddit ;)
23:20:41 <dons> yeah, set to 'new' only if you want to moderate
23:21:10 <dons> Cale: you're going to start writing your concies reddit replies on your blog when?.. ;)
23:21:22 <dons> concise/elegant/incisive.
23:21:52 <Cale> Hehe, I only post content on other people's blogs.
23:22:07 <dons> that's ok :)
23:23:32 <goltrpoat> good lord.  getNumberToken, getWhitespaceToken, getForwardSlashToken, get<insert-token-here>Token, all have the same signature
23:23:39 <Cale> indeed
23:24:02 <Cale> The code is almost exactly the same for each of them
23:24:28 <goltrpoat> there should be one of those giant cartoon hammers with GENERALIZE written on it
23:25:14 <goltrpoat> employed in situations like this
23:25:30 <mbishop> I love how in the post I made, almost no one made speed of execution a requirement for their dream language :)
23:26:11 <dons> that's great isn't it
23:39:31 <zeeeeee> hi all, is there a code browser, cross-referencing html pretty printer, etc. for haskell? i found Programatica but it barely works (eg can't handle operator definition syntax)
23:39:36 <lispy> mbishop: yeah, programming languages should be for programmers :)
23:39:51 <lispy> zeeeeee: huh?
23:39:59 <lispy> zeeeeee: i don't understand :(
23:40:15 <dons> zeeeeee: haddock generates docs/cross references
23:40:24 <zeeeeee> lispy: that should be: "...code browser or cross-referencing pretty printer or..."
23:40:26 <dons> and HsColour does syntax markup to css and other forms
23:40:28 <zeeeeee> dons: not for code
23:40:43 <zeeeeee> dons: i'm trying to actually browse and understand some large pile of code
23:40:44 <dons> right. so you want to turn code into hyperlinked code?
23:40:52 <dons> how about using hasktags?
23:40:54 <zeeeeee> dons: yeah
23:40:56 <dons> from vim or emacs
23:41:03 <zeeeeee> dons: cool, thanks for the pointer
23:41:03 <dons> ?where hasktags
23:41:04 <lambdabot> http://www.cl.cam.ac.uk/users/rje33/software.html
23:41:18 <dons> I use it all the time (i've got the entire std libraries tagged)
23:41:39 <goltrpoat> visual haskell does 'go to definition', if you're in windows and running 6.6
23:41:41 <dons> i should write a little tut on hasktagging projects
23:41:54 <lispy> oh, well haddock can help when you have a big pile of code
23:41:59 <zeeeeee> dons: is it that complicated :(
23:42:06 <lispy> i started using it on the darcs source just for that reason
23:42:10 <dons> zeeeeee: not really :) just not many people seem to use it
23:42:26 <zeeeeee> dons: it should deserve a mention in the wiki alongside other haskell tools/ides
23:42:46 <dons> i'm pretty sure hasktags is on the wiki already
23:42:53 <goltrpoat> haddock isn't exactly the type of thing you're use while browsing through the said pile of code and asking yourself, oh, what does this function do that's being referenced here
23:43:05 <dons> here's a script to hasktags multiple large dirs, http://www.cse.unsw.edu.au/~dons/tmp/tag-fptools
23:43:20 <dons> and here's a tags file for the standard libraries, http://www.cse.unsw.edu.au/~dons/tmp/tags
23:43:36 <lispy> goltrpoat: i guess in that case i resort to grep/find
23:43:49 <dons> tags are a much nicer way to do this kind of thing though, lispy
23:43:58 <goltrpoat> i mean.  it's easier to click on something and say 'what is this', instead of having to go through the documentation (that is, assuming whoever wrote the pile of code, actually documented it)
23:44:00 * dons resolves to write a small blog entry on this
23:44:07 <lispy> goltrpoat: it's fast for me (assuming unix) but tags is probably better...just haven't invested in those tools yet
23:44:16 <goltrpoat> -nod-
23:44:56 <lispy> i should though, dave love has added a target to the darcs makefile to generate the gas
23:44:58 <lispy> er tags
23:45:02 <dons> lispy: oh?
23:45:04 <goltrpoat> not bashing anyone or anything, just seemed like there was a disconnect between what zeee is asking, and what is being addressed in the answers
23:45:05 <goltrpoat> hehe
23:45:10 <dons> lispy: more info please
23:45:18 <lispy> dons: make tags, iirc
23:45:27 <lispy> dons: there is a target for vim and one for emacs
23:45:33 <dons> lispy: makes a tags file, for darcs only?
23:45:37 <dons> using some little script?
23:45:40 <lispy> dons: are you an darcs-devel@?
23:45:43 <dons> yes
23:46:01 <dons> i've been meaning to rewrite hasktags, maybe i'll do that tonight
23:46:10 <lispy> i haven't tried it, but the email said it would generate the approriate tage file for use with your editor
23:46:15 <dons> mmm
23:47:17 <lispy> dons: he hasn't sent in that many patches, so if you have a local archive of the list it should be easy to search for dave and find it
23:47:23 <dons> ok
23:47:49 <lispy> oh, and i just realized lambdabot needs an eggtimer
23:48:21 <lispy> i'm baking and i don't have one so it would be nice to have lambdabot ping me when i need to check stuff :)
23:48:23 <dons> ah ha,
23:48:23 <dons> +TAGS: $(DARCS_FILES)
23:48:24 <dons> +   hasktags -e $(DARCS_FILES) && etags -a *.c
23:48:29 <dons> lispy: heh
23:48:55 <kosmikus> good morning #haskell
23:49:06 <dons> good morning mr. kosmikus
23:49:07 <lispy> like, ?settimer 10 foo, then in 10 minutes lambdabot says, lispy: foo
23:49:20 <dons> lispy: you know how to submit a darcs patch ;)
23:49:20 <lispy> (preferably over /msg)
23:49:24 <lispy> dons: i do
23:49:26 <dons> (this would be a 10 line plugin, if that)
23:49:28 <astrolabe> judging by don's plot http://www.haskell.org/haskellwiki/Image:Nick-activity.png the number of haskeller's seems to growing linearly rather than exponentially.  That suggests to me that it is not growing by word of mouth, but that there is a constant rate of new people starting the language, very few of whom then leave it.
23:49:30 <lambdabot> Title: Image:Nick-activity.png - HaskellWiki
23:49:46 <lispy> dons: really? i was sort of wondering how i'd get lambdabot to wake up at the right time
23:50:02 <dons> astrolabe: interesting. some people made a similar analysis of the history of the mailing list archives, in the 'history of haskell' paper
23:50:32 <dons> astrolabe: i suspect we're starting to see a word of mouth (over the last month) since haskell decided to enter the blog space
23:50:43 <dons> lispy: threadDelay, no?
23:50:48 <lispy> dons: for example, i dont' think you can use the alarm signal unless you set it to wakeup every 30 seconds or something
23:50:55 <opqdonut> haskell gets spread by word of mouth but only a small part of people who hear about it decide to start
23:51:00 <astrolabe> dons: any idea which statistics would show that first?
23:51:03 <dons> lispy: much like the darcs-patch plugin, which checks repos every 30 minutes
23:51:04 <lispy> dons: oh, lambdabot is thread happy...hmm...not a bad idea
23:51:10 <goltrpoat> dons:  i suspect your reddit blitzkrieg is helping a lot :)
23:51:25 <dons> astrolabe: hmm. the number of blogs entries mentioned in hwn?
23:51:30 <astrolabe> opqdonut: you would expect an exponential growth if it was by word of mouth.
23:51:33 <dons> it was about 10 last week, this week 40 :)
23:51:45 <dons> astrolabe: the haskell-cafe mailing list traffic?
23:51:56 <astrolabe> dons:  We should have no trouble recognising that by next year then :)
23:52:02 <dons> :)
23:52:10 <dons> blogs would show a word of mouth effect I think
23:52:13 <opqdonut> astrolabe: not necessarily, you see if the percentage of "really interested people" reached goes doens on each step-of-word-of-mouth
23:52:27 <opqdonut> astrolabe: then you could get linear growth :)
23:52:48 <dons> lispy: use threadDelay, with a 5 minute sleep time, when it wakes up, print a msg
23:52:53 <lispy> i think most people learn about haskell from classes at uni
23:52:55 <astrolabe> opqdonut: That is true if you think we have started saturating the population.  But I doubt that.
23:52:58 <dons> do threadDelay ten_minutes ; print "lispy!"
23:53:08 <lispy> dons: yeah, sounds easy
23:53:09 <astrolabe> lispy: yay! that fits my model :)
23:53:28 <opqdonut> astrolabe: that was exactly my point, i don't think there's a boundless demand for high-level functional languages
23:53:31 <opqdonut> atm at least
23:53:32 <dons> or, \user -> forkIO $ do threadDelay 10mins ; printf "Wakeup %s" user
23:53:39 <goltrpoat> i still think that haskell has to have top-notch tools in order to gain real acceptance.  by tools i mean, eg, an integrated environment, with a code browser, darcs, haddock, alex, happy, a snapshop of common lib binaries, etc, all in a nice convenient package
23:53:55 <goltrpoat> and by that i really don't mean emacs or eclipse
23:54:06 <dons> it would certainly help.
23:54:07 <goltrpoat> visual haskell comes close, although that's not exactly cross-platform
23:54:07 <opqdonut> goltrpoat: bah, c does fine without an ide
23:54:25 <astrolabe> goltrpoat: I think hat is most important, or would be if it worked.
23:54:29 <opqdonut> goltrpoat: so does perl, python etc
23:54:54 <dons> libraries are kinda key, and a central repository for them
23:54:54 <lispy> dons: thanks
23:55:05 <dons> lispy: check DarcsPatchWatch.hs for hints
23:55:06 <astrolabe> dons: yeah, that too
23:55:15 <dons> hence hackage. bring it on!
23:55:21 <goltrpoat> astrolabe:  you know.. ive never actually *needed* hat.  but yeah, i seen a lot of requests for it
23:55:48 <astrolabe> Also, some more principled method of finding space leaks would be nice.
23:56:04 <astrolabe> Maybe that would come from hat.
23:56:06 <dons> astrolabe: mm. that would be interesting. you mean a tool that analyses profiling info, and gives you hints?
23:56:20 <dons> note also the new HPC, coverage tool, integrated into ghc
23:56:21 <astrolabe> dons: do you think that might be possible?
23:56:26 <dons> that's going to be important in the future
23:56:27 <goltrpoat> opq:  c++ has any number of good ides, and a giant installed user base.  python has a ton of use cases, and appeal in web development.
23:56:37 <goltrpoat> haskell has neither right now, so i'm not sure if the comparison holds.
23:56:39 <eviltwin_b> CPAN is easily perl's #1 feature --- 90% of what you need's already been done.
23:56:39 <dons> astrolabe: not sure. sounds like a researchy tool
23:56:41 <astrolabe> dons: what's this HPC?
23:56:54 <dons> ?where hpc
23:56:54 <lambdabot> http://www.haskell.org/haskellwiki/Haskell_Program_Coverage
23:56:58 <opqdonut> goltrpoat: my point was, you can be succesful without a tightly integrated ide
23:56:58 <dons> its in ghc *now*
23:57:13 <mbishop> eviltwin_b: Too bad about 99% of CPAN is the same module redone over and over
23:57:19 <dons> heh
23:57:21 <eviltwin_b> only too true :>
23:57:22 <mbishop> eviltwin_b: in varying degrees of completness :P
23:58:08 <astrolabe> dons: thanks
23:58:32 <dons> remember guys, we make our own future. if something's missing, write it, or write a work around.
23:58:40 <dons> or if in doubt, port a library from cpan :)
23:58:50 <dons> those who write code, get things done.
23:59:19 <sieni> hmm... I wonder if one could automatically import e.g. python modules to ghc. At least the python C API looked sensible, when I looked at it many years ago
23:59:19 <dons> i will personally give karma to anyone who releases a new project :)
23:59:30 <dons> sieni: we have missingpy too
23:59:33 <dons> so that could be doable
23:59:36 <dons> ?where missingpy
23:59:36 <lambdabot> http://quux.org:70/devel/missingpy
23:59:36 <goltrpoat> opq:  and my point was that the languages you cited are a) entrenched (c, c++, perl), b) have a number of excellent post-factum dev environments (c++), or c) are riding on the popularity of a field that they happen to be good at (python)
23:59:55 <opqdonut> goltrpoat: true, true
